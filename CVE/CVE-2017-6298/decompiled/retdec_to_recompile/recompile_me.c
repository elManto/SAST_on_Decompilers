//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

//struct _IO_FILE {
//    int32_t e0;
//};

// ------------------- Function Prototypes --------------------



int __printf_chk(int flag, const char * restrict format, ...);
int __snprintf_chk(char * restrict s, size_t n, int flag, size_t slen, const char * restrict format, ...);


int64_t DecompressRTF(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t entry_point(void);
int64_t function_1940(void);
int64_t function_1950(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_1960(char * s, int32_t n, int32_t flag, int32_t slen, char * format, ...);
void function_1970(int64_t * ptr);
int32_t function_1980(int32_t c);
int64_t function_1990(int64_t a1, int64_t a2);
int32_t function_19a0(char * s);
int64_t function_19b0(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_19c0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_19d0(struct _IO_FILE * stream);
int64_t function_19e0(void);
int32_t function_19f0(char * s);
int64_t function_1a00(int64_t a1);
void function_1a10(void);
int64_t function_1a20(int64_t a1, int64_t * a2);
int64_t function_1a30(int64_t a1);
int64_t function_1a40(int64_t a1);
int64_t function_1a50(int64_t a1, int64_t a2, int64_t a3, int32_t a4);
int64_t * function_1a60(int32_t nmemb, int32_t size);
int64_t * function_1a70(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen);
int64_t * function_1a80(int64_t * dest, int64_t * src, int32_t n);
int64_t function_1a90(int64_t a1, int64_t a2);
int64_t function_1aa0(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t * function_1ab0(int32_t size);
int64_t function_1ac0(int64_t a1, int64_t a2);
int64_t function_1ad0(int64_t a1);
int64_t function_1ae0(int64_t a1);
int32_t function_1af0(int32_t flag, char * format, ...);
int64_t function_1b00(int64_t a1);
int64_t function_1b10(int64_t a1);
int64_t function_1b20(int64_t a1, int64_t a2);
struct _IO_FILE * function_1b30(char * filename, char * modes);
int64_t function_1b40(int64_t a1, int64_t a2, int64_t a3);
int16_t ** function_1b50(void);
int64_t function_1b60(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
void function_1b70(int64_t * d);
int64_t function_1bc0(void);
int64_t function_1c10(void);
int64_t function_1c50(void);
int64_t IsCompressedRTF(int64_t a1, int64_t a2, int64_t a3);
int64_t MAPIFindProperty(int64_t a1, int64_t a2);
int64_t MAPIFindUserProp(int64_t a1, int64_t a2);
int64_t MAPIPrint(int64_t a1);
int64_t MAPISysTimetoDTR(int64_t a1, int64_t a2);
int64_t SwapDDWord(int64_t a1, int64_t a2);
int64_t SwapDWord(int64_t a1, int64_t a2);
int64_t SwapWord(uint64_t a1, int64_t a2, int64_t a3);
int64_t TNEFAttachmentFilename(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFAttachmentMAPI(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFAttachmentSave(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFBody(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFCheckForSignature(int64_t a1);
int64_t TNEFCodePage(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFDateHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFDefaultHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFDetailedPrint(int64_t a1, int64_t a2, int64_t c, int64_t a4);
int64_t TNEFFile_Close(int64_t a1);
int64_t TNEFFile_Open(int64_t a1);
int64_t TNEFFile_Read(int64_t a1, int64_t size, int64_t nmemb, int64_t data);
int64_t TNEFFillMapi(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFFree(int64_t a1);
int64_t TNEFFreeAttachment(int64_t a1);
int64_t TNEFFreeMapiProps(int64_t a1);
int64_t TNEFFromHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFGetHeader(int64_t a1, int64_t a2, int64_t a3);
int64_t TNEFGetKey(int64_t a1, int64_t a2);
int64_t TNEFHexBreakdown(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFIcon(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFInitAttachment(int64_t a1);
int64_t TNEFInitialize(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t TNEFInitMapi(int64_t a1);
int64_t TNEFMapiProperties(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFMemory_Close(void);
int64_t TNEFMemory_Open(int64_t a1);
int64_t TNEFMemory_Read(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFMessageClass(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFMessageID(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFOriginalMsgClass(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFParentID(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFParse(int64_t a1);
int64_t TNEFParseFile(int64_t a1, int64_t a2);
int64_t TNEFParseMemory(int64_t a1, int64_t a2, int64_t a3);
int64_t TNEFPrintDate(uint64_t a1, uint64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t TNEFPriority(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFRawRead(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFRecipTable(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFRendData(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFSentFor(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFSubjectHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TNEFVersion(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t to_utf8(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x147b
int32_t g2 = 0x14000000; // 0x1c9
int64_t g3 = 0x300000014; // 0x1cc
int64_t g4 = 0x554e470000000300; // 0x1cf
int32_t g5 = 0x47000000; // 0x1d1
int64_t g6 = -0x9d72ffaab1b900; // 0x1d3
int64_t g7 = 0x45d956af8f595822; // 0x1dc
int64_t g8; // 0x1e8
int32_t * g9 = (int32_t *)0x1400000025; // 0x1f0
int16_t * g10 = (int16_t *)0x800000014; // 0x1f4
int64_t g11 = 0x900000008; // 0x1f8
int64_t g12 = 0x1180d8221b661100; // 0x1ff
int64_t g13 = 0x30148410491180d8; // 0x204
int64_t g14 = 0; // 0x207fa8
int64_t g15 = 0; // 0x207fb0
int32_t * g16 = NULL; // 0x207fb8
int32_t * g17 = NULL; // 0x207fc0
int64_t g18 = 0; // 0x207fd0
int64_t g19 = 0; // 0x207fd8
int64_t g20 = 0; // 0x207fe0
int64_t g21 = 0; // 0x207fe8
int64_t g22 = 0; // 0x207ff8
int64_t g23 = -0x7efddbf7cfeb7bf0; // 0x208
int64_t g24 = -0x1dbf7efddbf7cfec; // 0x20a
int64_t g25 = 0xe2408102240830; // 0x20b
int32_t * g26 = (int32_t *)0x202200010400e240; // 0x210
int64_t g27 = 0x2a18202200010400; // 0x212
int64_t g28 = 0; // 0x216978
int64_t g29 = 0x10020540d002a18; // 0x218
int32_t * g30 = (int32_t *)0x10c01600414400d0; // 0x220
int32_t * g31 = (int32_t *)0x490660162000b042; // 0x230
int64_t g32 = 0x210932042e490660; // 0x235
int64_t g33 = 0x6210932042e4906; // 0x236
int64_t g34 = 0x10206210932042e; // 0x238
int32_t * g35 = (int32_t *)0x1500000014; // 0x240
int64_t g36 = 0x1800000015000000; // 0x241
int64_t g37 = 0x18000000150000; // 0x242
int64_t g38 = 24; // 0x248
int64_t g39 = 0x1a0000000000; // 0x24b
int64_t g40 = 0x1a00000000; // 0x24c
int32_t * g41 = (int32_t *)0x1b0000001a; // 0x250
int64_t g42 = 0x1f0000001d; // 0x258
int64_t g43 = 0; // 0x25f
int64_t g44 = 0; // 0x260
int64_t g45 = 0x2400000000000000; // 0x261
int64_t g46 = 0x25000000240000; // 0x266
int32_t * g47 = (int32_t *)40; // 0x270
int32_t * g48 = (int32_t *)47; // 0x280
int64_t g49 = 53; // 0x290
int64_t g50 = 0x3600000000; // 0x294
int64_t g51 = 0x370000003600; // 0x297
int64_t g52 = 0x3b0000003800; // 0x29f
int32_t g53 = 0x515b2878; // 0x30e
int32_t g54 = 0x2b7a515b; // 0x310
int32_t g55 = -0x1e078d6c; // 0x31d
int32_t g56 = 0; // 0x3e7
int32_t g57 = 0; // 0x3e8
int32_t g58 = 0; // 0x4a2
int32_t g59 = 0; // 0x4a4
int64_t g60 = 0x1660000; // 0x5f6
int64_t g61 = 0x9d000000000000; // 0x612
int64_t g62 = 0x1de0000c; // 0x61e
int32_t g63 = 0; // 0x642
int64_t g64 = 0x2f000000000; // 0x644
int128_t g65; // 0x6c70
int128_t g66; // 0x6c80
int128_t g67; // 0x6c90
int128_t g68; // 0x6ca0
int128_t g69; // 0x6cb0
int128_t g70; // 0x6cc0
int128_t g71; // 0x6cd0
int128_t g72; // 0x6ce0
int128_t g73; // 0x6cf0
int128_t g74; // 0x6d00
int128_t g75; // 0x6d10
int128_t g76; // 0x6d20
int16_t g77 = 0x4200; // 0x745c
int32_t g78 = 0x1e80000c; // 0x7fe
int32_t g79 = 0x52c0000c; // 0xa3e
int32_t g80;

// ------------------------ Functions -------------------------

// Address range: 0x1928 - 0x193f
//int64_t _init(void) {
//    int64_t result = 0; // 0x1936
//    if (*(int64_t *)0x207fc8 != 0) {
//        // 0x1938
//        __gmon_start__();
//        result = &g80;
//    }
//    // 0x193a
//    return result;
//}
//
// Address range: 0x1940 - 0x194c
int64_t function_1940(void) {
    // 0x1940
    int64_t result; // 0x1940
    return result;
}

// Address range: 0x1950 - 0x1960
int64_t function_1950(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1950
    return function_1940();
}

// Address range: 0x1960 - 0x1966
int32_t function_1960(char * s, int32_t n, int32_t flag, int32_t slen, char * format, ...) {
    // 0x1960
    return __snprintf_chk(s, n, flag, slen, format);
}

// Address range: 0x1970 - 0x1976
void function_1970(int64_t * ptr) {
    // 0x1970
    free(ptr);
}

// Address range: 0x1980 - 0x1986
int32_t function_1980(int32_t c) {
    // 0x1980
    return putchar(c);
}

// Address range: 0x1990 - 0x19a0
int64_t function_1990(int64_t a1, int64_t a2) {
    // 0x1990
    return function_1940();
}

// Address range: 0x19a0 - 0x19a6
int32_t function_19a0(char * s) {
    // 0x19a0
    return puts(s);
}

// Address range: 0x19b0 - 0x19c0
int64_t function_19b0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x19b0
    return function_1940();
}

// Address range: 0x19c0 - 0x19c6
int32_t function_19c0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x19c0
    return fread(ptr, size, n, stream);
}

// Address range: 0x19d0 - 0x19d6
int32_t function_19d0(struct _IO_FILE * stream) {
    // 0x19d0
    return fclose(stream);
}

// Address range: 0x19e0 - 0x19f0
int64_t function_19e0(void) {
    // 0x19e0
    return function_1940();
}

// Address range: 0x19f0 - 0x19f6
int32_t function_19f0(char * s) {
    // 0x19f0
    return strlen(s);
}

// Address range: 0x1a00 - 0x1a10
int64_t function_1a00(int64_t a1) {
    // 0x1a00
    return function_1940();
}

// Address range: 0x1a10 - 0x1a16
void function_1a10(void) {
    // 0x1a10
    __stack_chk_fail();
}

// Address range: 0x1a20 - 0x1a30
int64_t function_1a20(int64_t a1, int64_t * a2) {
    // 0x1a20
    return function_1940();
}

// Address range: 0x1a30 - 0x1a40
int64_t function_1a30(int64_t a1) {
    // 0x1a30
    return function_1940();
}

// Address range: 0x1a40 - 0x1a50
int64_t function_1a40(int64_t a1) {
    // 0x1a40
    return function_1940();
}

// Address range: 0x1a50 - 0x1a60
int64_t function_1a50(int64_t a1, int64_t a2, int64_t a3, int32_t a4) {
    // 0x1a50
    return function_1940();
}

// Address range: 0x1a60 - 0x1a66
int64_t * function_1a60(int32_t nmemb, int32_t size) {
    // 0x1a60
    return calloc(nmemb, size);
}

// Address range: 0x1a70 - 0x1a76
int64_t * function_1a70(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen) {
    // 0x1a70
    //return __memcpy_chk(dest, src, len, dstlen);
}

// Address range: 0x1a80 - 0x1a86
int64_t * function_1a80(int64_t * dest, int64_t * src, int32_t n) {
    // 0x1a80
    return memcpy(dest, src, n);
}

// Address range: 0x1a90 - 0x1aa0
int64_t function_1a90(int64_t a1, int64_t a2) {
    // 0x1a90
    return function_1940();
}

// Address range: 0x1aa0 - 0x1ab0
int64_t function_1aa0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1aa0
    return function_1940();
}

// Address range: 0x1ab0 - 0x1ab6
int64_t * function_1ab0(int32_t size) {
    // 0x1ab0
    return malloc(size);
}

// Address range: 0x1ac0 - 0x1ad0
int64_t function_1ac0(int64_t a1, int64_t a2) {
    // 0x1ac0
    return function_1940();
}

// Address range: 0x1ad0 - 0x1ae0
int64_t function_1ad0(int64_t a1) {
    // 0x1ad0
    return function_1940();
}

// Address range: 0x1ae0 - 0x1af0
int64_t function_1ae0(int64_t a1) {
    // 0x1ae0
    return function_1940();
}

// Address range: 0x1af0 - 0x1af6
int32_t function_1af0(int32_t flag, char * format, ...) {
    // 0x1af0
    return __printf_chk(flag, format);
}

// Address range: 0x1b00 - 0x1b10
int64_t function_1b00(int64_t a1) {
    // 0x1b00
    return function_1940();
}

// Address range: 0x1b10 - 0x1b20
int64_t function_1b10(int64_t a1) {
    // 0x1b10
    return function_1940();
}

// Address range: 0x1b20 - 0x1b30
int64_t function_1b20(int64_t a1, int64_t a2) {
    // 0x1b20
    return function_1940();
}

// Address range: 0x1b30 - 0x1b36
struct _IO_FILE * function_1b30(char * filename, char * modes) {
    // 0x1b30
    return fopen(filename, modes);
}

// Address range: 0x1b40 - 0x1b50
int64_t function_1b40(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1b40
    return function_1940();
}

// Address range: 0x1b50 - 0x1b56
int16_t ** function_1b50(void) {
    // 0x1b50
    return __ctype_b_loc();
}

// Address range: 0x1b60 - 0x1b70
int64_t function_1b60(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    // 0x1b60
    return function_1940();
}

// Address range: 0x1b70 - 0x1b76
void function_1b70(int64_t * d) {
    // 0x1b70
    __cxa_finalize(d);
}

// Address range: 0x1b80 - 0x1bb2
int64_t entry_point(void) {
    // 0x1b80
    return &g28;
}

// Address range: 0x1bc0 - 0x1c02
int64_t function_1bc0(void) {
    // 0x1bc0
    return 0;
}

// Address range: 0x1c10 - 0x1c4a
int64_t function_1c10(void) {
    // 0x1c10
    if (*(char *)&g28 != 0) {
        // 0x1c48
        int64_t result; // 0x1c10
        return result;
    }
    // 0x1c19
    if (g22 != 0) {
        // 0x1c27
        __cxa_finalize((int64_t *)*(int64_t *)0x208140);
    }
    int64_t result2 = entry_point(); // 0x1c33
    *(char *)&g28 = 1;
    return result2;
}

// Address range: 0x1c50 - 0x1c5a
int64_t function_1c50(void) {
    // 0x1c50
    return function_1bc0();
}

// Address range: 0x1c60 - 0x1c6e
int64_t TNEFMemory_Open(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 24); // 0x1c60
    *(int64_t *)(v1 + 8) = *(int64_t *)v1;
    return 0;
}

// Address range: 0x1c70 - 0x1c73
int64_t TNEFMemory_Close(void) {
    // 0x1c70
    return 0;
}

// Address range: 0x1c80 - 0x1d26
int64_t TNEFParentID(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = (uint32_t)(int32_t)a4 >= 50 ? 50 : a4 & 0xffffffff; // 0x1c8f
    uint32_t v2 = (int32_t)v1; // 0x1c92
    if (v2 < 8) {
        if ((v1 & 4) != 0) {
            // 0x1d00
            *(int32_t *)(a1 + 186) = (int32_t)a3;
            *(int32_t *)(v1 + a1 + 182) = *(int32_t *)(v1 + a3 - 4);
            // 0x1cae
            return 0;
        }
        if (v2 == 0) {
            // 0x1cae
            return 0;
        }
        // 0x1ca0
        *(char *)(a1 + 186) = (char)a3;
        if ((v1 & 2) != 0) {
            // 0x1d18
            *(int16_t *)(v1 + a1 + 184) = *(int16_t *)(v1 + a3 - 2);
        }
        // 0x1cae
        return 0;
    }
    int64_t v3 = a1 + 186; // 0x1c88
    *(int64_t *)v3 = a3;
    int64_t v4 = a1 + 194 & -8; // 0x1cc8
    *(int64_t *)(v1 + a1 + 178) = *(int64_t *)(v1 + a3 - 8);
    int64_t v5 = v3 - v4; // 0x1cd6
    uint32_t v6 = (int32_t)(v1 + v5); // 0x1ce1
    if (v6 < 8) {
        // 0x1cae
        return 0;
    }
    int64_t v7 = 0;
    int64_t v8 = v7 + 8; // 0x1ced
    *(int64_t *)(v7 + v4) = *(int64_t *)(a3 - v5 + v7);
    while ((v6 & -8) > (int32_t)v8) {
        // 0x1ceb
        v7 = v8 & 0xffffffff;
        v8 = v7 + 8;
        *(int64_t *)(v7 + v4) = *(int64_t *)(a3 - v5 + v7);
    }
    // 0x1cae
    return 0;
}

// Address range: 0x1d30 - 0x1dd6
int64_t TNEFMessageID(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = (uint32_t)(int32_t)a4 >= 50 ? 50 : a4 & 0xffffffff; // 0x1d3f
    uint32_t v2 = (int32_t)v1; // 0x1d42
    if (v2 < 8) {
        if ((v1 & 4) != 0) {
            // 0x1db0
            *(int32_t *)(a1 + 136) = (int32_t)a3;
            *(int32_t *)(v1 + a1 + 132) = *(int32_t *)(v1 + a3 - 4);
            // 0x1d5e
            return 0;
        }
        if (v2 == 0) {
            // 0x1d5e
            return 0;
        }
        // 0x1d50
        *(char *)(a1 + 136) = (char)a3;
        if ((v1 & 2) != 0) {
            // 0x1dc8
            *(int16_t *)(v1 + a1 + 134) = *(int16_t *)(v1 + a3 - 2);
        }
        // 0x1d5e
        return 0;
    }
    int64_t v3 = a1 + 136; // 0x1d38
    *(int64_t *)v3 = a3;
    int64_t v4 = a1 + 144 & -8; // 0x1d78
    *(int64_t *)(v1 + a1 + 128) = *(int64_t *)(v1 + a3 - 8);
    int64_t v5 = v3 - v4; // 0x1d86
    uint32_t v6 = (int32_t)(v1 + v5); // 0x1d91
    if (v6 < 8) {
        // 0x1d5e
        return 0;
    }
    int64_t v7 = 0;
    int64_t v8 = v7 + 8; // 0x1d9d
    *(int64_t *)(v7 + v4) = *(int64_t *)(a3 - v5 + v7);
    while ((v6 & -8) > (int32_t)v8) {
        // 0x1d9b
        v7 = v8 & 0xffffffff;
        v8 = v7 + 8;
        *(int64_t *)(v7 + v4) = *(int64_t *)(a3 - v5 + v7);
    }
    // 0x1d5e
    return 0;
}

// Address range: 0x1de0 - 0x1e7e
int64_t TNEFMessageClass(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = (uint32_t)(int32_t)a4 >= 49 ? 49 : a4 & 0xffffffff; // 0x1dec
    uint32_t v2 = (int32_t)v1; // 0x1def
    if (v2 < 8) {
        if ((v1 & 4) != 0) {
            // 0x1e58
            *(int32_t *)(a1 + 86) = (int32_t)a3;
            *(int32_t *)(v1 + a1 + 82) = *(int32_t *)(v1 + a3 - 4);
            // 0x1e08
            return 0;
        }
        if (v2 == 0) {
            // 0x1e08
            return 0;
        }
        // 0x1dfd
        *(char *)(a1 + 86) = (char)a3;
        if ((v1 & 2) != 0) {
            // 0x1e70
            *(int16_t *)(v1 + a1 + 84) = *(int16_t *)(v1 + a3 - 2);
        }
        // 0x1e08
        return 0;
    }
    int64_t v3 = a1 + 86; // 0x1de8
    *(int64_t *)v3 = a3;
    int64_t v4 = a1 + 94 & -8; // 0x1e1d
    *(int64_t *)(v1 + a1 + 78) = *(int64_t *)(v1 + a3 - 8);
    int64_t v5 = v3 - v4; // 0x1e2b
    uint32_t v6 = (int32_t)(v1 + v5); // 0x1e36
    if (v6 < 8) {
        // 0x1e08
        return 0;
    }
    int64_t v7 = 0;
    int64_t v8 = v7 + 8; // 0x1e42
    *(int64_t *)(v7 + v4) = *(int64_t *)(a3 - v5 + v7);
    while ((v6 & -8) > (int32_t)v8) {
        // 0x1e40
        v7 = v8 & 0xffffffff;
        v8 = v7 + 8;
        *(int64_t *)(v7 + v4) = *(int64_t *)(a3 - v5 + v7);
    }
    // 0x1e08
    return 0;
}

// Address range: 0x1e80 - 0x1f17
int64_t TNEFMemory_Read(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = *(int64_t *)(a1 + 24); // 0x1e88
    int64_t v2 = 0x100000000 * a2 * 0x100000000 * a3 / 0x100000000 / 0x100000000; // 0x1e96
    int64_t * v3 = (int64_t *)(v1 + 8); // 0x1e99
    int64_t v4 = *v3; // 0x1e99
    if (v2 > *(int64_t *)v1 + *(int64_t *)(v1 + 16) - v4) {
        // 0x1ec5
        return 0xffffffff;
    }
    uint32_t v5 = *(int32_t *)(v1 + 24); // 0x1ea8
    int64_t v6 = v4; // 0x1eb1
    if (v5 > 2) {
        // 0x1ed0
        __printf_chk(1, "DEBUG(%i/%i):", 3, (int64_t)v5);
        __printf_chk(1, "Copying %i bytes", v2 & 0xffffffff);
        putchar(10);
        v6 = *v3;
    }
    // 0x1eb3
    memcpy((int64_t *)a4, (int64_t *)v6, (int32_t)v2);
    *v3 = *v3 + v2;
    // 0x1ec5
    return a3 & 0xffffffff;
}

// Address range: 0x1f20 - 0x1f8a
int64_t TNEFFile_Open(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 24); // 0x1f21
    uint32_t v2 = *(int32_t *)(v1 + 16); // 0x1f25
    int64_t * file_path; // 0x1f20
    if (v2 > 2) {
        // 0x1f50
        __printf_chk(1, "DEBUG(%i/%i):", 3, (int64_t)v2);
        int64_t * v3 = (int64_t *)v1;
        __printf_chk(1, "Opening %s", (char *)*v3);
        putchar(10);
        file_path = v3;
    } else {
        // 0x1f20
        file_path = (int64_t *)v1;
    }
    struct _IO_FILE * file = fopen((char *)*file_path, "rb"); // 0x1f37
    *(int64_t *)(v1 + 8) = (int64_t)file;
    return file == NULL ? 0xffffffff : 0;
}

// Address range: 0x1f90 - 0x201a
int64_t TNEFFile_Read(int64_t a1, int64_t size, int64_t nmemb, int64_t data) {
    int64_t v1 = *(int64_t *)(a1 + 24); // 0x1fa1
    uint32_t v2 = *(int32_t *)(v1 + 16); // 0x1fa5
    if (v2 > 2) {
        // 0x1fd8
        __printf_chk(1, "DEBUG(%i/%i):", 3, (int64_t)v2);
        __printf_chk(1, "Reading %i blocks of %i size", nmemb & 0xffffffff, size & 0xffffffff);
        putchar(10);
    }
    int64_t stream = *(int64_t *)(v1 + 8); // 0x1faf
    int64_t items_read = 0xffffffff; // 0x1fb7
    if (stream != 0) {
        // 0x1fb9
        items_read = fread((int64_t *)data, (int32_t)size, (int32_t)nmemb, (struct _IO_FILE *)stream);
    }
    // 0x1fc7
    return items_read;
}

// Address range: 0x2020 - 0x208a
int64_t TNEFFile_Close(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 24); // 0x2021
    uint32_t v2 = *(int32_t *)(v1 + 16); // 0x2025
    if (v2 > 2) {
        // 0x2050
        __printf_chk(1, "DEBUG(%i/%i):", 3, (int64_t)v2);
        __printf_chk(1, "Closing file %s", (char *)*(int64_t *)v1);
        putchar(10);
    }
    int64_t * v3 = (int64_t *)(v1 + 8); // 0x202d
    int64_t file = *v3; // 0x202d
    if (file != 0) {
        // 0x2036
        fclose((struct _IO_FILE *)file);
        *v3 = 0;
    }
    // 0x2043
    return 0;
}

// Address range: 0x2090 - 0x20e3
int64_t TNEFDefaultHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x2090
    if (*(int32_t *)(a1 + (int64_t)L"25") < 1) {
        // 0x20e0
        return 0;
    }
    int64_t v1 = 0x100000000 * a2;
    __printf_chk(1, "%s: [%i] %.*s\n", (char *)((8 * (v1 / 0x20000000 - v1 / 0x100000000) | 4) + (int64_t)g17), a4, a4 & 0xffffffff, (char *)a3);
    return 0;
}

// Address range: 0x20f0 - 0x2155
int64_t TNEFCodePage(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int32_t nmemb = a4;
    *(int32_t *)(a1 + (int64_t)&g26) = nmemb;
    int64_t * mem = calloc(nmemb, 1); // 0x210b
    *(int64_t *)(a1 + (int64_t)&g23) = (int64_t)mem;
    int64_t result; // 0x20f0
    if (mem == NULL) {
        // 0x2131
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 255);
        result = 0xffffffff;
    } else {
        // 0x211c
        memcpy(mem, (int64_t *)a3, nmemb);
        result = 0;
    }
    // 0x212c
    return result;
}

// Address range: 0x2160 - 0x2203
int64_t TNEFBody(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int32_t v1 = a4;
    *(int32_t *)(a1 + 296) = v1;
    if (v1 >= 0x186a1) {
        // 0x21b0
        __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", v1, "ytnef.c", 273, 0x186a0);
        // 0x21a9
        return 0xffffffff;
    }
    int64_t * mem = calloc(v1 + 1, 1); // 0x2187
    *(int64_t *)(a1 + 288) = (int64_t)mem;
    int64_t result; // 0x2160
    if (mem == NULL) {
        // 0x21df
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 275);
        result = 0xffffffff;
    } else {
        // 0x2199
        memcpy(mem, (int64_t *)a3, v1);
        result = 0;
    }
    // 0x21a9
    return result;
}

// Address range: 0x2210 - 0x2321
int64_t TNEFOriginalMsgClass(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a3;
    uint64_t v2 = a4 + 0xffffffff; // 0x2218
    uint32_t v3 = (int32_t)a4; // 0x221f
    *(int32_t *)(a1 + (int64_t)&g30) = v3;
    if ((int32_t)v2 >= 100) {
        // 0x22c8
        __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", v3, "ytnef.c", 282, 100);
        // 0x2270
        return 0xffffffff;
    }
    int64_t * mem = calloc(v3 + 1, 1); // 0x223f
    int64_t v4 = (int64_t)mem; // 0x223f
    *(int64_t *)(a1 + (int64_t)&g29) = v4;
    if (mem == NULL) {
        // 0x22fa
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 284);
        // 0x2270
        return 0xffffffff;
    }
    int64_t v5 = a4 & 0xffffffff; // 0x2216
    if (v3 >= 8) {
        // 0x2280
        *(int64_t *)(v5 + v4 - 8) = *(int64_t *)(v1 + v5 - 8);
        __asm_rep_movsq_memcpy((char *)mem, (char *)v1, v2 / 8 % 0x20000000);
        // 0x2270
        return 0;
    }
    if ((a4 & 4) != 0) {
        // 0x22b0
        *(int32_t *)mem = *(int32_t *)&v1;
        *(int32_t *)(v5 + v4 - 4) = *(int32_t *)(v1 + v5 - 4);
        // 0x2270
        return 0;
    }
    // 0x225e
    if (v3 == 0) {
        // 0x2270
        return 0;
    }
    // 0x2262
    *(char *)mem = *(char *)&v1;
    if ((a4 & 2) != 0) {
        // 0x22a0
        *(int16_t *)(v5 + v4 - 2) = *(int16_t *)(v1 + v5 - 2);
    }
    // 0x2270
    return 0;
}

// Address range: 0x2330 - 0x2441
int64_t TNEFFromHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a3;
    uint64_t v2 = a4 + 0xffffffff; // 0x2338
    uint32_t v3 = (int32_t)a4;
    if ((int32_t)v2 >= 100) {
        // 0x23e8
        __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", v3, "ytnef.c", 295, 100);
        // 0x238b
        return 0xffffffff;
    }
    int64_t * mem = calloc(v3 + 1, 1); // 0x2359
    int64_t v4 = (int64_t)mem; // 0x2359
    *(int64_t *)(a1 + 16) = v4;
    if (mem == NULL) {
        // 0x241a
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 297);
        // 0x238b
        return 0xffffffff;
    }
    int64_t v5 = a4 & 0xffffffff; // 0x2336
    *(int32_t *)(a1 + 24) = v3;
    if (v3 >= 8) {
        // 0x23a0
        *(int64_t *)(v5 + v4 - 8) = *(int64_t *)(v5 + a3 - 8);
        __asm_rep_movsq_memcpy((char *)mem, (char *)a3, v2 / 8 % 0x20000000);
        // 0x238b
        return 0;
    }
    if ((a4 & 4) != 0) {
        // 0x23d0
        *(int32_t *)mem = *(int32_t *)&v1;
        *(int32_t *)(v5 + v4 - 4) = *(int32_t *)(v5 + a3 - 4);
        // 0x238b
        return 0;
    }
    // 0x2379
    if (v3 == 0) {
        // 0x238b
        return 0;
    }
    // 0x237d
    *(char *)mem = *(char *)&v1;
    if ((a4 & 2) != 0) {
        // 0x23c0
        *(int16_t *)(v5 + v4 - 2) = *(int16_t *)(v5 + a3 - 2);
    }
    // 0x238b
    return 0;
}

// Address range: 0x2450 - 0x2508
int64_t TNEFIcon(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1 + 320;
    int64_t v2 = *(int64_t *)(v1 + 128); // 0x246b
    while (v2 != 0) {
        // 0x246b
        v1 = v2;
        v2 = *(int64_t *)(v1 + 128);
    }
    int32_t nmemb = a4; // 0x247a
    *(int32_t *)(v1 + 160) = nmemb;
    if (nmemb >= 0x2711) {
        // 0x24b5
        __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", nmemb, "ytnef.c", 353, 0x2710);
        // 0x24b0
        return 0xffffffff;
    }
    int64_t * mem = calloc(nmemb, 1); // 0x248f
    *(int64_t *)(v1 + 152) = (int64_t)mem;
    int64_t result; // 0x2450
    if (mem == NULL) {
        // 0x24e4
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 355);
        result = 0xffffffff;
    } else {
        // 0x24a0
        memcpy(mem, (int64_t *)a3, nmemb);
        result = 0;
    }
    // 0x24b0
    return result;
}

// Address range: 0x2510 - 0x262e
int64_t TNEFAttachmentFilename(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1 + 320;
    int64_t v2 = *(int64_t *)(v1 + 128); // 0x2533
    while (v2 != 0) {
        // 0x2533
        v1 = v2;
        v2 = *(int64_t *)(v1 + 128);
    }
    int64_t v3 = a4 & 0xffffffff; // 0x2519
    uint64_t v4 = v3 + 0xffffffff; // 0x253f
    uint32_t v5 = (int32_t)a4; // 0x2543
    *(int32_t *)(v1 + 24) = v5;
    if ((int32_t)v4 >= 100) {
        // 0x25da
        __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", v5, "ytnef.c", (int64_t)&g53, 100);
        // 0x258b
        return 0xffffffff;
    }
    int64_t * mem = calloc(v5 + 1, 1); // 0x255b
    int64_t v6 = (int64_t)mem; // 0x255b
    *(int64_t *)(v1 + 16) = v6;
    if (mem == NULL) {
        // 0x2607
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g54);
        // 0x258b
        return 0xffffffff;
    }
    if (v5 >= 8) {
        // 0x25a0
        *(int64_t *)(v3 + v6 - 8) = *(int64_t *)(v3 + a3 - 8);
        __asm_rep_movsq_memcpy((char *)mem, (char *)a3, v4 / 8 % 0x20000000);
        // 0x258b
        return 0;
    }
    int64_t v7; // 0x2510
    if ((a4 & 4) != 0) {
        // 0x25c9
        *(int32_t *)mem = *(int32_t *)&v7;
        *(int32_t *)(v3 + v6 - 4) = *(int32_t *)(v3 + a3 - 4);
        // 0x258b
        return 0;
    }
    // 0x2578
    if (v5 == 0) {
        // 0x258b
        return 0;
    }
    // 0x257c
    *(char *)mem = *(char *)&v7;
    if ((a4 & 2) != 0) {
        // 0x25bc
        *(int16_t *)(v3 + v6 - 2) = *(int16_t *)(v3 + a3 - 2);
    }
    // 0x258b
    return 0;
}

// Address range: 0x2630 - 0x26c1
int64_t TNEFAttachmentSave(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1 + 320;
    int64_t v2 = *(int64_t *)(v1 + 128); // 0x2653
    while (v2 != 0) {
        // 0x2653
        v1 = v2;
        v2 = *(int64_t *)(v1 + 128);
    }
    int32_t size = a4;
    int64_t * mem = calloc(1, size); // 0x266a
    *(int64_t *)(v1 + 136) = (int64_t)mem;
    int64_t result; // 0x2630
    if (mem == NULL) {
        // 0x269d
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g55);
        result = 0xffffffff;
    } else {
        // 0x267b
        *(int32_t *)(v1 + 144) = size;
        memcpy(mem, (int64_t *)a3, size);
        result = 0;
    }
    // 0x2692
    return result;
}

// Address range: 0x26d0 - 0x27e9
int64_t TNEFSubjectHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t * v1 = (int64_t *)(a1 + 32); // 0x26e2
    int64_t v2 = *v1; // 0x26e2
    if (v2 != 0) {
        // 0x26eb
        free((int64_t *)v2);
    }
    int64_t v3 = a4 & 0xffffffff; // 0x26dc
    uint64_t v4 = v3 + 0xffffffff; // 0x26f0
    uint32_t v5 = (int32_t)a4;
    if ((int32_t)v4 >= 100) {
        // 0x2790
        __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", v5, "ytnef.c", 307, 100);
        // 0x2739
        return 0xffffffff;
    }
    int64_t * mem = calloc(v5 + 1, 1); // 0x2707
    int64_t v6 = (int64_t)mem; // 0x2707
    *v1 = v6;
    if (mem == NULL) {
        // 0x27c2
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 309);
        // 0x2739
        return 0xffffffff;
    }
    // 0x2719
    *(int32_t *)(a1 + 40) = v5;
    if (v5 >= 8) {
        // 0x2748
        *(int64_t *)(v3 + v6 - 8) = *(int64_t *)(v3 + a3 - 8);
        __asm_rep_movsq_memcpy((char *)mem, (char *)a3, v4 / 8 % 0x20000000);
        // 0x2739
        return 0;
    }
    int64_t v7; // 0x26d0
    if ((a4 & 4) != 0) {
        // 0x2778
        *(int32_t *)mem = *(int32_t *)&v7;
        *(int32_t *)(v3 + v6 - 4) = *(int32_t *)(v3 + a3 - 4);
        // 0x2739
        return 0;
    }
    // 0x2727
    if (v5 == 0) {
        // 0x2739
        return 0;
    }
    // 0x272b
    *(char *)mem = *(char *)&v7;
    if ((a4 & 2) != 0) {
        // 0x2768
        *(int16_t *)(v3 + v6 - 2) = *(int16_t *)(v3 + a3 - 2);
    }
    // 0x2739
    return 0;
}

// Address range: 0x27f0 - 0x2840
int64_t SwapWord(uint64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = __readfsqword(40); // 0x27f4
    int32_t v2 = a2; // 0x2804
    int64_t result = 0; // 0x2806
    if (v2 != 0) {
        int64_t v3 = a1 % 256; // 0x280d
        int64_t v4 = v3; // 0x280f
        if (v2 != 1) {
            // 0x2811
            v4 = 256 * (int64_t)*(char *)(a1 + 1) | v3;
        }
        // 0x2817
        result = v4 & 0xffffffff;
    }
    // 0x2819
    if (v1 == __readfsqword(40)) {
        // 0x2829
        return result;
    }
    // 0x282e
    __stack_chk_fail();
    return &g80;
}

// Address range: 0x2840 - 0x28a3
int64_t TNEFVersion(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    uint64_t v1 = function_19b0(a3, a4 & 0xffffffff, a3, a4); // 0x2857
    __snprintf_chk((char *)a1, 16, 1, 16, "TNEF%i.%i", function_19b0(a3 + 2, a4 + 0xfffffffe & 0xffffffff, a3, a4) % 0x10000, v1 % 0x10000);
    return 0;
}

// Address range: 0x28b0 - 0x2a27
int64_t TNEFSentFor(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = 0x100000000 * a4;
    if (v1 < 1) {
        // 0x29e8
        return 0;
    }
    uint64_t v2 = v1 / 0x100000000; // 0x28ba
    if (v2 < 2) {
        // 0x29b4
        __printf_chk(1, "Corrupted file detected at %s : %i\n", "ytnef.c", (int64_t)&g50);
        return 0xffffffff;
    }
    int32_t * v3 = (int32_t *)(a1 + (int64_t)L"25");
    int64_t v4 = a3; // 0x28b0
    int64_t v5 = a3 + 2; // 0x2990
    int64_t v6 = function_19b0(a3, 2, v4, a4) % 0x10000; // 0x299c
    int64_t v7 = &g51; // 0x29a9
    while (v5 - a3 + v6 <= v2) {
        uint32_t v8 = *v3; // 0x28f0
        int64_t v9 = v8; // 0x28f9
        int64_t v10 = v4; // 0x28f9
        if (v8 >= 1) {
            // 0x28fb
            __printf_chk(1, "Sent For : %.*s", v6, (char *)v5);
            v9 = v5;
            v10 = v6;
        }
        int64_t v11 = v6 + v5; // 0x2910
        v7 = (int64_t)L"78;=?AEFL";
        if (2 - a3 + v11 > v2) {
            // break -> 0x29b4
            break;
        }
        int64_t v12 = v11 + 2; // 0x292e
        int64_t v13 = function_19b0(v11, 2, v10, v9) % 0x10000; // 0x293a
        int64_t v14 = v13 + v12 - a3; // 0x2941
        v7 = &g52;
        if (v14 > v2) {
            // break -> 0x29b4
            break;
        }
        uint32_t v15 = *v3; // 0x294d
        int64_t v16 = v14; // 0x2956
        v4 = v15;
        if (v15 >= 1) {
            // 0x2958
            __printf_chk(1, "<%.*s>\n", v13, (char *)v12);
            v16 = v12;
            v4 = v13;
        }
        int64_t v17 = v13 + v12; // 0x2971
        uint64_t v18 = v17 - a3; // 0x2977
        if (v18 >= v2) {
            // 0x29e8
            return 0;
        }
        // 0x297f
        v7 = &g50;
        if (v18 + 2 > v2) {
            // break -> 0x29b4
            break;
        }
        v5 = v17 + 2;
        v6 = function_19b0(v17, 2, v4, v16) % 0x10000;
        v7 = &g51;
    }
    // 0x29b4
    __printf_chk(1, "Corrupted file detected at %s : %i\n", "ytnef.c", v7);
    return 0xffffffff;
}

// Address range: 0x2a30 - 0x2b86
int64_t TNEFDateHandler(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x2a30
    if ((int32_t)a4 < 14) {
        // 0x2aae
        return 0xffffffff;
    }
    int64_t v1 = 0x100000000 * a2;
    int64_t v2 = (int64_t)g17; // 0x2a40
    int64_t v3 = a1 + 320; // 0x2a55
    uint32_t v4 = *(int32_t *)(8 * (v1 / 0x20000000 - v1 / 0x100000000) + v2); // 0x2a63
    int64_t v5; // 0x2a30
    int64_t v6; // 0x2a30
    if (v4 == 0x38006) {
        // 0x2b60
        v6 = v3;
        v5 = a1 + 62;
        goto lab_0x2ae0;
    } else {
        if (v4 < 0x38007) {
            switch (v4) {
                case 0x30007: {
                    // 0x2b70
                    v6 = v3;
                    v5 = a1 + (int64_t)&g46;
                    goto lab_0x2ae0;
                }
                case 0x38005: {
                    // 0x2b50
                    v6 = v3;
                    v5 = a1 + 48;
                    goto lab_0x2ae0;
                }
                default: {
                    if (v4 != 0x30006) {
                        goto lab_0x2a93;
                    } else {
                        // 0x2ad5
                        v6 = v3;
                        v5 = a1 + (int64_t)&g42;
                        goto lab_0x2ae0;
                    }
                }
            }
        } else {
            // 0x2a72
            switch (v4) {
                case 0x38013: {
                    int64_t v7 = v3;
                    int64_t v8 = *(int64_t *)(v7 + 128); // 0x2b13
                    while (v8 != 0) {
                        // 0x2b13
                        v7 = v8;
                        v8 = *(int64_t *)(v7 + 128);
                    }
                    // 0x2b1f
                    v6 = v7;
                    v5 = v7 + 62;
                    goto lab_0x2ae0;
                }
                case 0x38020: {
                    // 0x2b40
                    v6 = v3;
                    v5 = a1 + (int64_t)&g8;
                    goto lab_0x2ae0;
                }
                case 0x38012: {
                    int64_t v9 = v3;
                    int64_t v10 = *(int64_t *)(v9 + 128); // 0x2b2b
                    while (v10 != 0) {
                        // 0x2b2b
                        v9 = v10;
                        v10 = *(int64_t *)(v9 + 128);
                    }
                    // 0x2b37
                    v6 = v9;
                    v5 = v9 + 48;
                    goto lab_0x2ae0;
                }
                default: {
                    goto lab_0x2a93;
                }
            }
        }
    }
  lab_0x2ae0:;
    int64_t v11 = v5; // 0x2ae4
    int64_t v12 = a3;
    *(int16_t *)v11 = (int16_t)function_19b0(v12, 2, v6, v2);
    v11 += 2;
    int64_t v13 = v12 + 2; // 0x2b04
    while (a3 + 12 != v12) {
        // 0x2ae8
        v12 = v13;
        *(int16_t *)v11 = (int16_t)function_19b0(v12, 2, v6, v2);
        v11 += 2;
        v13 = v12 + 2;
    }
    // 0x2aae
    return 0;
  lab_0x2a93:
    // 0x2a93
    if (*(int32_t *)(a1 + (int64_t)L"25") >= 1) {
        // 0x2aa2
        puts("MISSING CASE");
    }
    // 0x2aae
    return 0xfffffff9;
}

// Address range: 0x2b90 - 0x2c00
int64_t SwapDWord(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x2b94
    int32_t v2 = 0; // bp-20, 0x2bac
    int64_t v3 = (int32_t)a2 < 5 ? a2 & 0xffffffff : 4; // 0x2bb4
    int64_t result = 0; // 0x2bb9
    if (v3 != 0) {
        int64_t v4 = 0; // 0x2bc0
        char v5 = *(char *)(v4 + a1); // 0x2bc2
        *(char *)(v4 + (int64_t)&v2) = v5;
        v4++;
        while (v4 != v3) {
            // 0x2bc2
            v5 = *(char *)(v4 + a1);
            *(char *)(v4 + (int64_t)&v2) = v5;
            v4++;
        }
        // 0x2bd1
        result = v2;
    }
    // 0x2bd5
    if (v1 == __readfsqword(40)) {
        // 0x2be5
        return result;
    }
    // 0x2bf4
    __stack_chk_fail();
    return &g80;
}

// Address range: 0x2c00 - 0x2c4e
int64_t TNEFRecipTable(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = 0x100000000 * a4;
    int64_t v2 = v1 / 0x100000000; // 0x2c00
    int64_t result; // 0x2c00
    if (v1 == 0x300000000 || v2 < 3) {
        // 0x2c28
        __printf_chk(1, "Corrupted file detected at %s : %i\n", "ytnef.c", 369);
        result = 0xffffffff;
    } else {
        // 0x2c0d
        function_1aa0(a3, 4, a3, v2);
        result = 0;
    }
    // 0x2c1c
    return result;
}

// Address range: 0x2c50 - 0x2cc2
int64_t TNEFPriority(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int32_t v1 = function_1aa0(a3, a4 & 0xffffffff, a3, a4); // 0x2c5e
    switch (v1) {
        case 2: {
            // 0x2c90
            *(int32_t *)(a1 + 304) = 0x6d726f6e;
            *(char *)(a1 + 310) = 0;
            *(int16_t *)(a1 + 308) = (int16_t)"=-=-=-=-=-=-=-";
            return (int32_t)"=-=-=-=-=-=-=-" ^ (int32_t)"=-=-=-=-=-=-=-";
        }
        case 3: {
            // 0x2cb0
            *(int32_t *)(a1 + 304) = 0x68676968;
            *(char *)(a1 + 308) = 0;
            return 0;
        }
    }
    // 0x2c6f
    *(int32_t *)(a1 + 304) = v1 != 1 ? 0x412f4e : 0x776f6c;
    return 0;
}

// Address range: 0x2cd0 - 0x2d30
int64_t SwapDDWord(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x2cd4
    int64_t result = 0; // bp-24, 0x2cec
    int64_t v2 = (int32_t)a2 < 9 ? a2 & 0xffffffff : 8; // 0x2cf4
    result = 0;
    if (v2 != 0) {
        int64_t v3 = 0; // 0x2cfd
        char v4 = *(char *)(v3 + a1); // 0x2d00
        *(char *)(v3 + (int64_t)&result) = v4;
        v3++;
        while (v3 != v2) {
            // 0x2d00
            v4 = *(char *)(v3 + a1);
            *(char *)(v3 + (int64_t)&result) = v4;
            v3++;
        }
    }
    // 0x2d13
    if (v1 == __readfsqword(40)) {
        // 0x2d23
        return result;
    }
    // 0x2d28
    __stack_chk_fail();
    return &g80;
}

// Address range: 0x2d30 - 0x2e1d
int64_t to_utf8(int64_t a1, int64_t a2) {
    int64_t mem = (int64_t)malloc((int32_t)((uint64_t)(3 * a1) / 2) + 1); // 0x2d4b
    if (a1 == 1) {
        // 0x2ddc
        *(char *)mem = 0;
        return mem;
    }
    int64_t v1 = a2 + 2 + (a1 - 2 & -2); // 0x2d68
    int64_t v2 = a2; // 0x2d6d
    int64_t v3 = 0; // 0x2d6d
    int64_t v4; // 0x2d30
    int64_t v5; // 0x2d30
    int64_t v6; // 0x2d30
    int64_t v7; // 0x2d30
    int64_t v8; // 0x2d30
    int64_t v9; // 0x2d30
    int64_t v10; // 0x2d30
    int64_t v11; // 0x2d30
    int64_t v12; // 0x2d30
    int64_t v13; // 0x2df6
    while (true) {
      lab_0x2d81_2:;
        int64_t v14 = v3;
        v5 = v2;
        uint64_t v15 = function_19b0(v5, 2, v11, v8); // 0x2d89
        int64_t v16 = v14 + 1; // 0x2d8e
        int64_t v17 = v15 % 0x10000; // 0x2d93
        int64_t v18 = 0x100000000 * v14 / 0x100000000 + mem; // 0x2d99
        int64_t v19 = 0x100000000 * v16 / 0x100000000 + mem; // 0x2d9f
        uint32_t v20 = (int32_t)v17; // 0x2da2
        if (v20 < 128) {
            // 0x2d70
            *(char *)v18 = (char)v15 % 128;
            v6 = v17;
            v9 = v19;
            v13 = v16 & 0xffffffff;
            goto lab_0x2d78;
        } else {
            int64_t v21 = v14 + 2; // 0x2da7
            uint64_t v22 = v17 / 64; // 0x2db1
            int64_t v23 = v15 % 64 | 0xffffff80; // 0x2db4
            int64_t v24 = 0x100000000 * v21 / 0x100000000 + mem; // 0x2dba
            if (v20 > (int32_t)&g78) {
                // 0x2df0
                v13 = v14 + 3;
                uint32_t v25 = v20 / 0x1000 | -32; // 0x2dfa
                *(char *)v18 = (char)v25;
                *(char *)v19 = (char)v22 % 64 | -128;
                *(char *)v24 = (char)v23;
                v6 = v25;
                v9 = 0x100000000 * v13 / 0x100000000 + mem;
                goto lab_0x2d78;
            } else {
                int64_t v26 = v5 + 2; // 0x2dc5
                *(char *)v18 = (char)v22 | -64;
                *(char *)v19 = (char)v23;
                v7 = v17;
                v10 = v24;
                v2 = v26;
                v4 = v21;
                v12 = v24;
                if (v26 == v1) {
                    // break -> 0x2ddc
                    break;
                }
                goto lab_0x2d81;
            }
        }
    }
  lab_0x2ddc:
    // 0x2ddc
    *(char *)v12 = 0;
    return mem;
  lab_0x2d78:;
    int64_t v27 = v5 + 2; // 0x2d78
    v7 = v6;
    v10 = v9;
    v2 = v27;
    v4 = v13;
    v12 = v9;
    if (v27 == v1) {
        // break -> 0x2ddc
        goto lab_0x2ddc;
    }
    goto lab_0x2d81;
  lab_0x2d81:
    // 0x2d81
    v8 = v7;
    v11 = v10;
    v3 = v4 & 0xffffffff;
    goto lab_0x2d81_2;
}

// Address range: 0x2e20 - 0x3aa0
int64_t TNEFFillMapi(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a4;
    uint64_t v2 = a3 & 0xffffffff; // 0x2e24
    int64_t v3 = __readfsqword(40); // 0x2e30
    int32_t * v4; // 0x2e20
    int64_t v5; // 0x2e20
    int64_t v6; // 0x2e20
    int64_t v7; // 0x2e20
    int64_t v8; // 0x2e20
    bool v9; // 0x2e20
    int64_t v10; // 0x2e20
    int64_t v11; // 0x2e20
    int64_t v12; // 0x2e20
    int64_t v13; // 0x2e20
    int64_t v14; // 0x2e20
    int64_t v15; // 0x2e20
    int64_t v16; // 0x2e20
    int64_t v17; // 0x2e20
    int64_t v18; // 0x2e20
    int64_t v19; // 0x2e20
    int64_t v20; // 0x2e20
    int64_t v21; // 0x2e20
    int64_t v22; // 0x2e20
    int64_t v23; // 0x2e20
    int64_t v24; // 0x2e20
    int64_t v25; // 0x2e20
    int64_t result; // 0x2e20
    int64_t v26; // 0x2e20
    int64_t v27; // 0x2e20
    int64_t v28; // 0x2e20
    int64_t v29; // 0x2e20
    int64_t v30; // 0x2e20
    int64_t v31; // 0x2e20
    int64_t v32; // 0x2e20
    int64_t v33; // 0x2e20
    int64_t v34; // 0x2e20
    int64_t v35; // 0x2e20
    int32_t * v36; // 0x2e20
    int32_t * v37; // 0x2e20
    int64_t * v38; // 0x2e20
    int64_t v39; // 0x2ef3
    if (v2 < 4) {
        // 0x386a
        v1 = 426;
        v7 = 426;
        goto lab_0x386f;
    } else {
        int64_t v40 = function_1aa0(a2, 4, a3, v1); // 0x2e6c
        int32_t nmemb = v40;
        if (nmemb - 1 > (int32_t)&g56) {
            // 0x3893
            v1 = (int64_t)"ytnef.c";
            v27 = v40 & 0xffffffff;
            v15 = 430;
            v16 = &g57;
            goto lab_0x38a8;
        } else {
            int64_t * mem = calloc(nmemb, 48); // 0x2e89
            int64_t v41 = (int64_t)mem; // 0x2e89
            *(int64_t *)(a4 + 8) = v41;
            v34 = 432;
            if (mem == NULL) {
                goto lab_0x3992;
            } else {
                // 0x2ea3
                *(int32_t *)a4 = nmemb;
                v35 = 4 - a2;
                v36 = (int32_t *)(a1 + (int64_t)L"25");
                v37 = (int32_t *)(a1 + 40);
                v38 = (int64_t *)(a1 + 32);
                v26 = a3;
                v23 = 0xffffffff;
                v17 = a2 + 4;
                v10 = 0;
                v13 = v41;
                while (true) {
                  lab_0x2ed5:
                    // 0x2ed5
                    v14 = v13;
                    int64_t v42 = v10;
                    int64_t v43 = v17;
                    int64_t v44 = v23;
                    int64_t v45 = v26;
                    int32_t * v46; // 0x2e20
                    int64_t v47; // 0x2e20
                    int64_t v48; // 0x2e20
                    int64_t v49; // 0x2e20
                    if (v44 == 0xffffffff) {
                        if (v2 < v43 + v35) {
                            // break -> 0x3860
                            break;
                        }
                        int64_t v50 = v43 + 4; // 0x315f
                        int32_t v51 = function_1aa0(v43, 4, v45, v1); // 0x3168
                        int32_t * v52 = (int32_t *)(v14 + 20);
                        *v52 = v51;
                        int32_t * v53 = (int32_t *)v14; // 0x316e
                        *v53 = 0;
                        int32_t * v54 = (int32_t *)(v14 + 28); // 0x3175
                        *v54 = 0;
                        int64_t v55 = v45; // 0x317d
                        int64_t v56 = v50; // 0x317d
                        if (v51 < 0) {
                            if (15 - a2 + v50 >= v2) {
                                // 0x38fa
                                v1 = 447;
                                v6 = 447;
                                goto lab_0x37d9;
                            }
                            int64_t v57 = v43 + 20; // 0x319a
                            __asm_movups(*(int128_t *)(v14 + 4), __asm_movdqu(*(int128_t *)v50));
                            if (v2 < v57 + v35) {
                                // 0x3932
                                v1 = 451;
                                v6 = 451;
                                goto lab_0x37d9;
                            }
                            int64_t v58 = v43 + 24; // 0x31c4
                            int64_t v59 = function_1aa0(v57, 4, v45, v1); // 0x31c8
                            int32_t nmemb2 = v59;
                            int64_t v60 = v59 & 0xffffffff; // 0x31cf
                            int64_t v61; // 0x2e20
                            int64_t v62; // 0x2e20
                            if (nmemb2 != 0) {
                                int64_t v63 = v59 + 0xffffffff; // 0x35f0
                                if ((int32_t)v63 > (int32_t)&g56) {
                                    // 0x3a6f
                                    __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", nmemb2, "ytnef.c", 455, (int64_t)&g57);
                                    result = 0xffffffff;
                                    goto lab_0x3495;
                                }
                                int64_t * mem2 = calloc(nmemb2, 16); // 0x360a
                                int64_t * v64 = (int64_t *)(v14 + 32); // 0x3612
                                *v64 = (int64_t)mem2;
                                if (mem2 == NULL) {
                                    // 0x3a39
                                    __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g2);
                                    result = 0xffffffff;
                                    goto lab_0x3495;
                                }
                                int64_t v65 = 16 * v63 & 0xffffffff0; // 0x3620
                                v1 = v65;
                                *v54 = nmemb2;
                                if (v2 < v58 + v35) {
                                    // 0x37d0
                                    v1 = &g3;
                                    v6 = &g3;
                                    goto lab_0x37d9;
                                }
                                int64_t v66 = function_1aa0(v58, 4, v60, v1); // 0x3663
                                int64_t v67 = v66 & 0xffffffff; // 0x3668
                                uint32_t v68 = (int32_t)v66;
                                v18 = v67;
                                v32 = 100;
                                v33 = &g4;
                                if (v68 >= 101) {
                                    goto lab_0x380b_2;
                                }
                                int64_t v69 = v65;
                                int64_t * mem3 = calloc(v68 + 1, 1); // 0x3685
                                int64_t v70 = *v64 + v69; // 0x368a
                                *(int64_t *)v70 = (int64_t)mem3;
                                if (mem3 == NULL) {
                                    // 0x382c
                                    __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g5);
                                    result = 0xffffffff;
                                    goto lab_0x3495;
                                }
                                int64_t v71 = v58 + 4; // 0x365f
                                *(int32_t *)(v70 + 8) = v68;
                                if (v2 < v71 - a2 + v67) {
                                    // 0x3852
                                    v1 = &g6;
                                    v6 = &g6;
                                    goto lab_0x37d9;
                                }
                                int64_t v72 = 0; // 0x36bc
                                int64_t v73; // 0x2e20
                                uint32_t v74; // 0x2e20
                                int64_t v75; // 0x36be
                                unsigned char v76; // 0x36d9
                                unsigned char v77; // 0x36d9
                                int64_t v78; // 0x36e2
                                if (v68 >= 2) {
                                    // 0x36be
                                    v74 = v68 / 2 - 1;
                                    v75 = v74;
                                    v76 = *(char *)v71;
                                    v1 = v76;
                                    *(char *)mem3 = v76;
                                    v72 = 1;
                                    if (v74 != 0) {
                                        v73 = 1;
                                        v77 = *(char *)(2 * v73 + v71);
                                        v1 = v77;
                                        *(char *)(*(int64_t *)(*v64 + v69) + v73) = v77;
                                        v78 = v73 + 1;
                                        v72 = v78;
                                        while (v73 != v75) {
                                            // 0x36d0
                                            v73 = v78;
                                            v77 = *(char *)(2 * v73 + v71);
                                            v1 = v77;
                                            *(char *)(*(int64_t *)(*v64 + v69) + v73) = v77;
                                            v78 = v73 + 1;
                                            v72 = v78;
                                        }
                                    }
                                }
                                int64_t v79 = v72;
                                uint32_t v80 = v68 % 4; // 0x36ee
                                int64_t v81 = v67; // 0x36f1
                                if (v80 != 0) {
                                    // 0x36f3
                                    v81 = v66 + 4 - (int64_t)v80 & 0xffffffff;
                                }
                                int64_t v82 = v81 + v71; // 0x36fd
                                v62 = v79;
                                v61 = v82;
                                int64_t v83 = v69 - 16; // 0x3706
                                while (v69 != 0) {
                                    // 0x3640
                                    if (v2 < v82 + v35) {
                                        // 0x37d0
                                        v1 = &g3;
                                        v6 = &g3;
                                        goto lab_0x37d9;
                                    }
                                    // 0x3657
                                    v66 = function_1aa0(v82, 4, v79, v1);
                                    v67 = v66 & 0xffffffff;
                                    v68 = (int32_t)v66;
                                    v18 = v67;
                                    v32 = 100;
                                    v33 = &g4;
                                    if (v68 >= 101) {
                                        goto lab_0x380b_2;
                                    }
                                    // 0x3677
                                    v69 = v83;
                                    mem3 = calloc(v68 + 1, 1);
                                    v70 = *v64 + v69;
                                    *(int64_t *)v70 = (int64_t)mem3;
                                    if (mem3 == NULL) {
                                        // 0x382c
                                        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g5);
                                        result = 0xffffffff;
                                        goto lab_0x3495;
                                    }
                                    // 0x369a
                                    v71 = v82 + 4;
                                    *(int32_t *)(v70 + 8) = v68;
                                    if (v2 < v71 - a2 + v67) {
                                        // 0x3852
                                        v1 = &g6;
                                        v6 = &g6;
                                        goto lab_0x37d9;
                                    }
                                    // 0x36b7
                                    v72 = 0;
                                    if (v68 >= 2) {
                                        // 0x36be
                                        v74 = v68 / 2 - 1;
                                        v75 = v74;
                                        v76 = *(char *)v71;
                                        v1 = v76;
                                        *(char *)mem3 = v76;
                                        v72 = 1;
                                        if (v74 != 0) {
                                            v73 = 1;
                                            v77 = *(char *)(2 * v73 + v71);
                                            v1 = v77;
                                            *(char *)(*(int64_t *)(*v64 + v69) + v73) = v77;
                                            v78 = v73 + 1;
                                            v72 = v78;
                                            while (v73 != v75) {
                                                // 0x36d0
                                                v73 = v78;
                                                v77 = *(char *)(2 * v73 + v71);
                                                v1 = v77;
                                                *(char *)(*(int64_t *)(*v64 + v69) + v73) = v77;
                                                v78 = v73 + 1;
                                                v72 = v78;
                                            }
                                        }
                                    }
                                    // 0x36eb
                                    v79 = v72;
                                    v80 = v68 % 4;
                                    v81 = v67;
                                    if (v80 != 0) {
                                        // 0x36f3
                                        v81 = v66 + 4 - (int64_t)v80 & 0xffffffff;
                                    }
                                    // 0x36f9
                                    v82 = v81 + v71;
                                    v62 = v79;
                                    v61 = v82;
                                    v83 = v69 - 16;
                                }
                            } else {
                                if (v2 < v58 + v35) {
                                    // 0x3a01
                                    v1 = &g7;
                                    v6 = &g7;
                                    goto lab_0x37d9;
                                }
                                // 0x31ee
                                *(int16_t *)(v14 + 22) = (int16_t)function_1aa0(v58, 4, v60, v1);
                                v62 = v60;
                                v61 = v43 + 28;
                            }
                            // 0x3204
                            *v53 = 1;
                            v55 = v62;
                            v56 = v61;
                        }
                        int64_t v84 = v56;
                        uint32_t v85 = *v36; // 0x3210
                        int64_t v86 = v85; // 0x3210
                        v1 = v86;
                        int64_t v87 = v55; // 0x3219
                        if (v85 > 2) {
                            // 0x35a0
                            __printf_chk(1, "DEBUG(%i/%i):", 3, v86);
                            uint32_t v88 = *v52; // 0x35b8
                            uint32_t v89 = v88 % 0x10000;
                            uint32_t v90 = v88 / 0x10000; // 0x35cf
                            v1 = v90;
                            __printf_chk(1, "Type id = %04x, Prop id = %04x", v89, v90);
                            putchar(10);
                            v87 = v89;
                        }
                        uint32_t v91 = *v52; // 0x321f
                        int64_t v92 = 0xffffffff; // 0x3226
                        int64_t v93 = v87; // 0x3226
                        int64_t v94 = 1; // 0x3226
                        int64_t nmemb3 = 1; // 0x3226
                        int64_t v95 = v84; // 0x3226
                        if ((v91 & 0x1000) != 0) {
                            int64_t v96 = (int64_t)(v91 % 0x10000) - (int64_t)(int32_t)"ontents"; // 0x3232
                            *v52 = v91 & -0x10000 | (int32_t)v96;
                            if (v2 < v84 + v35) {
                                // 0x396b
                                v1 = &g8;
                                v6 = &g8;
                                goto lab_0x37d9;
                            }
                            // 0x3255
                            v93 = v96 & 0xffffffff;
                            int64_t v97 = function_1aa0(v84, 4, v93, v1); // 0x3261
                            v94 = v97 & 0xffffffff;
                            v18 = v94;
                            v32 = &g57;
                            v33 = 493;
                            if ((int32_t)v97 - 1 > (int32_t)&g56) {
                                goto lab_0x380b_2;
                            }
                            // 0x3276
                            v92 = 0;
                            nmemb3 = 0x100000000 * v97 / 0x100000000;
                            v95 = v84 + 4;
                        }
                        int64_t * mem4 = calloc((int32_t)nmemb3, 16); // 0x3553
                        int64_t v98 = (int64_t)mem4; // 0x3553
                        *(int64_t *)(v14 + 40) = v98;
                        if (mem4 == NULL) {
                            // 0x38c5
                            __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 495);
                            result = 0xffffffff;
                            goto lab_0x3495;
                        }
                        // 0x3568
                        *(int32_t *)(v14 + 24) = (int32_t)v94;
                        v46 = v52;
                        v49 = v93;
                        v25 = v92;
                        v48 = v95;
                        v11 = v42;
                        v47 = v98;
                    } else {
                        int64_t v99 = v44 + 1; // 0x2ede
                        v46 = (int32_t *)(v14 + 20);
                        v49 = v45;
                        v25 = v99;
                        v48 = v43;
                        v11 = v42 + 0xffffffff & 0xffffffff;
                        v47 = *(int64_t *)(v14 + 40) + 0x100000000 * v99 / 0x10000000;
                    }
                    // 0x2ef3
                    v12 = v47;
                    v19 = v48;
                    v28 = v49;
                    v4 = v46;
                    v24 = v25 & 0xffffffff;
                    uint32_t v100 = *v4; // 0x2ef3
                    v39 = v100;
                    v1 = v39;
                    uint32_t v101 = v100 % 0x10000;
                    if (v101 < 12) {
                        if (v101 >= 10) {
                            goto lab_0x34ce;
                        } else {
                            if (v101 < 5) {
                                if (v101 >= 3) {
                                    goto lab_0x34ce;
                                } else {
                                    if (v101 != 2) {
                                        // 0x3484
                                        puts("Bad file");
                                        result = 0xffffffff;
                                        goto lab_0x3495;
                                    }
                                    int32_t * v102 = (int32_t *)(v12 + 8); // 0x3026

                                    int64_t * mem5 = calloc(*v102, 2); // 0x302e
                                    int64_t * v103 = (int64_t *)v12; // 0x303b
                                    *v103 = (int64_t)mem5;
                                    int64_t v104 = function_19b0(v19, 2, v28, v1); // 0x303f
                                    int32_t v105 = *v102; // 0x3044
                                    int64_t v106 = v105; // 0x3044
                                    int64_t v107 = v19 + 4; // 0x304c
                                    int64_t v108 = 0x1000000000000 * v104 / 0x1000000000000; // bp-78, 0x3055
                                    memcpy((int64_t *)*v103, &v108, v105);
                                    uint32_t v109 = *v4; // 0x305f
                                    int64_t v110 = v109 / 0x10000; // 0x3063
                                    v1 = v110;
                                    v5 = v110;
                                    v9 = v109 < 0x490000;
                                    v30 = v106;
                                    v21 = v107;
                                    v31 = v106;
                                    v22 = v107;
                                    if ((v109 & -0x10000) != 0x490000) {
                                        goto lab_0x2f70;
                                    } else {
                                        goto lab_0x3070;
                                    }
                                }
                            } else {
                                if (v101 == 5) {
                                    goto lab_0x332f;
                                } else {
                                    if (v101 >= 8) {
                                        // 0x3484
                                        puts("Bad file");
                                        result = 0xffffffff;
                                        goto lab_0x3495;
                                    }
                                    goto lab_0x34ce;
                                }
                            }
                        }
                    } else {
                        if (v101 < 32) {
                            if (v101 == 13 || v101 >= 30) {
                                goto lab_0x33a0;
                            } else {
                                if (v101 != 20) {
                                    // 0x3484
                                    puts("Bad file");
                                    result = 0xffffffff;
                                    goto lab_0x3495;
                                }
                                goto lab_0x332f;
                            }
                        } else {
                            if (v101 != 72) {
                                switch ((int16_t)v100) {
                                    case 258: {
                                        goto lab_0x33a0;
                                    }
                                    case 64: {
                                        goto lab_0x332f;
                                    }
                                    default: {
                                        // 0x3484
                                        puts("Bad file");
                                        result = 0xffffffff;
                                        goto lab_0x3495;
                                    }
                                }
                            } else {
                                // 0x2f15
                                *(int32_t *)(v12 + 8) = 16;
                                int64_t * mem6 = calloc(16, 1); // 0x2f2b
                                *(int64_t *)v12 = (int64_t)mem6;
                                v1 &= 0xffffffff;
                                if (mem6 == NULL) {
                                    // 0x3904
                                    v1 = &g39;
                                    v8 = &g39;
                                    goto lab_0x3909;
                                }
                                int64_t v111 = v19 - a2 + 16; // 0x2f49
                                if (v111 > v2) {
                                    // 0x3961
                                    v1 = &g40;
                                    v7 = &g40;
                                    goto lab_0x386f;
                                }
                                // 0x2f58
                                __asm_movups(*(int128_t *)mem6, __asm_movdqu(*(int128_t *)v19));
                                v29 = v111;
                                v20 = v19 + 16;
                                goto lab_0x2f64;
                            }
                        }
                    }
                }
                // 0x3860
                v1 = 438;
                v6 = 438;
                goto lab_0x37d9;
            }
        }
    }
  lab_0x380b_2:
    // 0x380b
    __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", (int32_t)v18, "ytnef.c", v33, v32);
    result = 0xffffffff;
    goto lab_0x3495;
  lab_0x3495:
    // 0x3495
    if (v3 != __readfsqword(40)) {
        // 0x3a9a
        __stack_chk_fail();
        return &g80;
    }
    // 0x34ab
    return result;
  lab_0x3992:
    // 0x3992
    v1 = v34;
    __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", v34);
    result = 0xffffffff;
    goto lab_0x3495;
  lab_0x34ce:;
    int32_t * v112 = (int32_t *)(v12 + 8); // 0x34ce
    *v112 = 4;
    int64_t * mem7 = calloc(4, 1); // 0x34e0
    int64_t * v113 = (int64_t *)v12; // 0x34e8
    *v113 = (int64_t)mem7;
    if (mem7 == NULL) {
        // 0x3946
        v1 = &g32;
        v8 = &g32;
        goto lab_0x3909;
    }
    if (3 - a2 + v19 >= v2) {
        // 0x394d
        v1 = &g33;
        v7 = &g33;
        goto lab_0x386f;
    }
    int64_t v114 = function_1aa0(v19, 4, v28, v1); // 0x3515
    int32_t v115 = *v112; // 0x351a
    int64_t v116 = 0x100000000 * v114 / 0x100000000; // bp-76, 0x3527
    memcpy((int64_t *)*v113, &v116, v115);
    v1 = (int64_t)*v4;
    v29 = v115;
    v20 = v19 + 4;
    goto lab_0x2f64;
  lab_0x2f64:;
    int64_t v117 = v1 / 0x10000 % 0x10000; // 0x2f64
    v1 = v117;
    uint32_t v118 = (int32_t)v117; // 0x2f67
    v5 = v117;
    v9 = v118 < 73;
    v30 = v29;
    v21 = v20;
    v31 = v29;
    v22 = v20;
    if (v118 == 73) {
        goto lab_0x3070;
    } else {
        goto lab_0x2f70;
    }
  lab_0x33a0:;
    int64_t v119 = v19 - a2 + 4; // 0x33a8
    int64_t v120 = v119; // 0x33af
    int64_t v121 = v19; // 0x33af
    if (v24 == 0xffffffff) {
        if (v2 < v119) {
            // 0x3a65
            v1 = &g12;
            v6 = &g12;
            goto lab_0x37d9;
        }
        int64_t v122 = v19 + 4; // 0x3733
        *(int32_t *)(v12 + 8) = (int32_t)function_1aa0(v19, 4, v28, v39);
        v120 = v122 + v35;
        v121 = v122;
    }
    // 0x33b5
    if (v2 < v120) {
        // 0x393c
        v1 = &g13;
        v7 = &g13;
        goto lab_0x386f;
    }
    int64_t v123 = v121 + 4; // 0x33c8
    int64_t v124 = function_1aa0(v121, 4, v28, v1); // 0x33cc
    int32_t v125 = v124; // 0x33d1
    int32_t * v126 = (int32_t *)(v12 + 8); // 0x33d3
    *v126 = v125;
    int64_t v127; // 0x2e20
    int64_t v128; // 0x2e20
    if (v125 == 0) {
        // 0x3580
        v1 = (int64_t)*v4;
        *(int64_t *)v12 = 0;
        v127 = v124;
        v128 = 0;
    } else {
        int64_t nmemb4 = 0x100000000 * v124 / 0x100000000; // 0x33e5
        if (v123 - a2 + nmemb4 > v2) {
            // 0x3a25
            v1 = &g24;
            v7 = &g24;
            goto lab_0x386f;
        }
        if (v125 >= 0x186a1) {
            // 0x3a0b
            v1 = (int64_t)"ytnef.c";
            v27 = v124 & 0xffffffff;
            v15 = &g25;
            v16 = 0x186a0;
            goto lab_0x38a8;
        }
        uint32_t v129 = *v4; // 0x3405
        int64_t v130 = v129; // 0x3405
        v1 = v130;
        int64_t v131; // 0x2e20
        if ((int16_t)v129 == 31) {
            int64_t v132 = function_1a50(nmemb4, v123, nmemb4, v129); // 0x375e
            *(int64_t *)v12 = v132;
            result = 0xffffffff;
            if (v132 == 0) {
                goto lab_0x3495;
            }
            // 0x3770
            v131 = (int64_t)*v4;
        } else {
            int64_t * mem8 = calloc((int32_t)nmemb4, 1); // 0x3424
            *(int64_t *)v12 = (int64_t)mem8;
            v1 = v130;
            if (mem8 == NULL) {
                // 0x3a5b
                v1 = &g27;
                v8 = &g27;
                goto lab_0x3909;
            }
            // 0x343f
            memcpy(mem8, (int64_t *)v123, v125);
            v131 = v130;
        }
        // 0x3452
        v1 = v131;
        uint32_t v133 = *v126; // 0x3452
        uint32_t v134 = v133 % 4; // 0x3458
        int64_t v135 = v134; // 0x3458
        v127 = v133;
        v128 = v134 == 0 ? v135 : 4 - v135;
    }
    // 0x358e
    v29 = v128;
    v20 = (v128 + v127 & 0xffffffff) + v123;
    goto lab_0x2f64;
  lab_0x3070:;
    uint32_t v136 = *v36; // 0x3075
    int64_t v137 = v136; // 0x3075
    v1 = v137;
    int64_t v138 = v31; // 0x307e
    int64_t v139 = v22; // 0x307e
    int64_t v140 = v137; // 0x307e
    int64_t v141 = v22; // 0x307e
    if (v136 > 2) {
        goto lab_0x32b0;
    } else {
        goto lab_0x3084;
    }
  lab_0x2f70:;
    int64_t v142 = v21;
    int64_t v143 = v30;
    int64_t v144 = v5;
    int64_t v145; // 0x2e20
    int64_t v146; // 0x2e20
    if (v9) {
        int64_t v147 = v144 + 0xffffffc9; // 0x3290
        v1 = v147 & 0xffffffff;
        v146 = v143;
        v145 = v142;
        if ((int32_t)v147 < 2) {
            uint32_t v148 = *v36; // 0x32a1
            int64_t v149 = v148; // 0x32a1
            v1 = v149;
            v138 = v143;
            v139 = v142;
            v140 = v149;
            v141 = v142;
            if (v148 < 3) {
                goto lab_0x3084;
            } else {
                goto lab_0x32b0;
            }
        } else {
            goto lab_0x2f8b;
        }
    } else {
        int32_t v150 = v144; // 0x2f76
        v146 = v143;
        v145 = v142;
        v31 = v143;
        v22 = v142;
        if (v150 == 112 || v150 == (int32_t)"NEFAttachmentMAPI") {
            goto lab_0x3070;
        } else {
            goto lab_0x2f8b;
        }
    }
  lab_0x332f:;
    int32_t * v151 = (int32_t *)(v12 + 8); // 0x332f
    *v151 = 8;
    int64_t * mem9 = calloc(8, 1); // 0x3341
    int64_t * v152 = (int64_t *)v12; // 0x3349
    *v152 = (int64_t)mem9;
    if (mem9 == NULL) {
        // 0x392b
        v1 = &g36;
        v8 = &g36;
        goto lab_0x3909;
    }
    if (7 - a2 + v19 >= v2) {
        // 0x3957
        v1 = &g37;
        v7 = &g37;
        goto lab_0x386f;
    }
    int64_t v153 = function_1990(v19, 8); // 0x3376
    int32_t v154 = *v151; // 0x337b
    int64_t v155 = v153; // bp-72, 0x3388
    memcpy((int64_t *)*v152, &v155, v154);
    v1 = (int64_t)*v4;
    v29 = v154;
    v20 = v19 + 8;
    goto lab_0x2f64;
  lab_0x32b0:;
    int64_t v156 = v141;
    __printf_chk(1, "DEBUG(%i/%i): %s\n", 3, v140, "Got a Subject");
    v146 = 3;
    v145 = v156;
    int64_t v157; // 0x2e20
    if (*v37 != 0) {
        goto lab_0x2f8b;
    } else {
        uint32_t v158 = *v36; // 0x32df
        int64_t v159 = v158; // 0x32df
        v1 = v159;
        v157 = v156;
        if (v158 >= 3) {
            // 0x32ee
            __printf_chk(1, "DEBUG(%i/%i): %s\n", 3, v159, "Assigning a Subject");
            v157 = v156;
        }
        goto lab_0x3094;
    }
  lab_0x3084:
    // 0x3084
    v146 = v138;
    v145 = v139;
    v157 = v139;
    if (*v37 != 0) {
        goto lab_0x2f8b;
    } else {
        goto lab_0x3094;
    }
  lab_0x2f8b:;
    int64_t v160 = v145;
    int32_t v161 = v25; // 0x2f92
    bool v162 = v161 == -1 | *(int32_t *)(v14 + 24) == v161 + 1;
    int64_t v163 = v11 + 1; // 0x2fa8
    v26 = v146;
    v23 = v162 ? 0xffffffff : v24;
    v17 = v160;
    v10 = v163 & 0xffffffff;
    v13 = v162 ? v14 + 48 : v14;
    if (*(int32_t *)&v1 <= (int32_t)v163) {
        int64_t v164 = v160 - a2; // 0x2fbf
        if (v2 > v164) {
            int32_t v165 = *v36; // 0x377e
            result = 0xffffffff;
            if (v165 < 1) {
                goto lab_0x3495;
            } else {
                // 0x378c
                puts("ERROR DURING MAPI READ");
                int64_t v166; // 0x2e49
                __printf_chk(1, "Read %td bytes, Expected %u bytes\n", v164, (int32_t)v166);
                __printf_chk(1, "%td bytes missing\n", v2 - v164);
                result = 0xffffffff;
                goto lab_0x3495;
            }
        } else {
            // 0x2fcb
            result = 0;
            if (v2 < v164) {
                int32_t v167 = *v36; // 0x2fdb
                result = 0xffffffff;
                if (v167 >= 0 == (v167 != 0)) {
                    // 0x39b6
                    puts("ERROR DURING MAPI READ");
                    __printf_chk(1, "Read %td bytes, Expected %u bytes\n", v164, (int32_t)(0x100000000 * a3 / 0x100000000));
                    __printf_chk(1, "%li bytes extra\n", (int32_t)(v164 - a3));
                    result = 0xffffffff;
                    goto lab_0x3495;
                } else {
                    goto lab_0x3495;
                }
            } else {
                goto lab_0x3495;
            }
        }
    }
    goto lab_0x2ed5;
  lab_0x3094:;
    int32_t * v168 = (int32_t *)(v12 + 8); // 0x3094
    uint32_t v169 = *v168; // 0x3094
    if (v169 >= 101) {
        // 0x3975
        v1 = (int64_t)"ytnef.c";
        v27 = v169;
        v15 = &g43;
        v16 = 100;
        goto lab_0x38a8;
    }
    int64_t * mem10 = calloc(v169 + 1, 1); // 0x30b3
    int64_t v170 = (int64_t)mem10; // 0x30b3
    v1 = v170;
    *v38 = v170;
    v34 = &g45;
    if (mem10 == NULL) {
        goto lab_0x3992;
    }
    int64_t v171 = *(int64_t *)v12; // 0x30d6
    *v37 = v169;
    int32_t v172 = *v168; // 0x30e1
    int64_t dest_mem = (int64_t)memcpy((int64_t *)v1, (int64_t *)v171, v172); // 0x30f2
    int64_t v173 = 0; // 0x30f2
    int64_t v174 = v173 + dest_mem; // 0x3115
    v1 = v174;
    char * v175 = (char *)v174; // 0x3118
    switch (*v175) {
        case 92: {
        }
        case 47: {
        }
        case 0: {
            // 0x3120
            *v175 = 95;
            // break -> 0x3101
            break;
        }
    }
    int64_t v176 = v173 + 1; // 0x3101
    while (*v37 != (int32_t)v176) {
        // 0x3111
        v174 = v176 + *v38;
        v1 = v174;
        v175 = (char *)v174;
        switch (*v175) {
            case 92: {
            }
            case 47: {
            }
            case 0: {
                // 0x3120
                *v175 = 95;
                // break -> 0x3101
                break;
            }
        }
        // 0x3101
        v176++;
    }
    // 0x2f8b
    v146 = v176 & 0xffffffff;
    v145 = v157;
    goto lab_0x2f8b;
  lab_0x386f:
    // 0x386f
    __printf_chk(1, "Corrupted file detected at %s : %i\n", "ytnef.c", v7);
    result = 0xffffffff;
    goto lab_0x3495;
  lab_0x38a8:
    // 0x38a8
    __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", (int32_t)v27, "ytnef.c", v15, v16);
    result = 0xffffffff;
    goto lab_0x3495;
  lab_0x37d9:
    // 0x37d9
    __printf_chk(1, "Corrupted file detected at %s : %i\n", "ytnef.c", v6);
    result = 0xffffffff;
    goto lab_0x3495;
  lab_0x3909:
    // 0x3909
    __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", v8);
    result = 0xffffffff;
    goto lab_0x3495;
}

// Address range: 0x3aa0 - 0x3ac8
int64_t TNEFAttachmentMAPI(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1 + 320; // 0x3aac
    v1 += 128;
    while (v1 != 0) {
        // 0x3ab3
        v1 += 128;
    }
    // 0x3abf
    return function_19e0();
}

// Address range: 0x3ad0 - 0x3f70
int64_t TNEFPrintDate(uint64_t a1, uint64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    uint64_t v1 = a2 / 0x100000000; // 0x3adb
    int64_t v2; // bp-360, 0x3ad0
    int64_t v3 = &v2; // 0x3ae3
    int64_t v4 = __readfsqword(40); // 0x3af0
    v2 = a1;
    if ((int16_t)v1 < 7) {
        // 0x3f18
        __printf_chk(1, "%s ", (char *)(15 * (v1 % 0x10000) + 16 + v3));
    }
    uint64_t v5 = a1 / 0x10000; // 0x3c03
    if ((int16_t)v5 < 13) {
        // 0x3ee0
        __printf_chk(1, "%s ", (char *)(15 * (v5 % 0x10000) + 113 + v3));
    }
    uint64_t v6 = a1 / 0x1000000000000; // 0x3b11
    uint64_t v7 = a2 / 0x10000; // 0x3d10
    int16_t v8; // 0x3ad0
    __printf_chk(1, "%hu, %hu ", v8, (int16_t)v2);
    uint16_t v9 = (int16_t)v6; // 0x3e6d
    if (v9 < 13) {
        int16_t v10 = a2;
        int16_t v11 = v7;
        if (v9 == 12) {
            // 0x3ec0
            __printf_chk(1, "%hu:%02hu:%02hu pm", 12, v10, v11);
        } else {
            // 0x3e80
            __printf_chk(1, "%hu:%02hu:%02hu am", v9, v10, v11);
        }
    } else {
        // 0x3f40
        __printf_chk(1, "%i:%02hu:%02hu pm", v6 + 0xfffffff4 & 0xffffffff, (int16_t)a2, (int16_t)v7);
    }
    int64_t result = __readfsqword(40) ^ v4; // 0x3e9e
    if (result == 0) {
        // 0x3ead
        return result;
    }
    // 0x3f5e
    __stack_chk_fail();
    return &g80;
}

// Address range: 0x3f70 - 0x4033
int64_t TNEFHexBreakdown(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x3f70
    if (*(int32_t *)(a1 + (int64_t)L"25") == 0) {
        // 0x3f7a
        return 0;
    }
    int64_t v1 = 0x100000000 * a2;
    __printf_chk(1, "%s: [%i bytes] \n", (char *)((8 * (v1 / 0x20000000 - v1 / 0x100000000) | 4) + (int64_t)g17), a4);
    if ((int32_t)a4 < 1) {
        // 0x401c
        putchar(10);
        return 0;
    }
    int64_t v2 = a4 + 0xffffffff & 0xffffffff; // 0x3fc4
    __printf_chk(1, "%02x ", 0x1000000 * (int32_t)a3 / 0x1000000);
    if (v2 == 0) {
        // 0x401c
        putchar(10);
        return 0;
    }
    uint64_t v3 = 2;
    __printf_chk(1, "%02x ", (int32_t)*(char *)(a3 - 1 + v3));
    if (v3 % 16 == 0) {
        // 0x4009
        putchar(10);
    }
    while (v2 + 1 != v3) {
        // 0x4013
        v3++;
        __printf_chk(1, "%02x ", (int32_t)*(char *)(a3 - 1 + v3));
        if (v3 % 16 == 0) {
            // 0x4009
            putchar(10);
        }
    }
    // 0x401c
    putchar(10);
    return 0;
}

// Address range: 0x4040 - 0x40bc
int64_t TNEFDetailedPrint(int64_t a1, int64_t a2, int64_t c, int64_t a4) {
    // 0x4040
    if (*(int32_t *)(a1 + (int64_t)L"25") == 0) {
        // 0x404a
        return 0;
    }
    int64_t v1 = 0x100000000 * a2;
    __printf_chk(1, "%s: [%i bytes] \n", (char *)((8 * (v1 / 0x20000000 - v1 / 0x100000000) | 4) + (int64_t)g17), a4);
    if ((int32_t)a4 < 1) {
        // 0x40a9
        putchar(10);
        return 0;
    }
    int64_t v2 = c + 1; // 0x409b
    putchar((int32_t)*(char *)c);
    while (v2 != c + 1 + (a4 + 0xffffffff & 0xffffffff)) {
        int64_t c2 = v2;
        v2 = c2 + 1;
        putchar((int32_t)*(char *)c2);
    }
    // 0x40a9
    putchar(10);
    return 0;
}

// Address range: 0x40c0 - 0x40eb
int64_t TNEFCheckForSignature(int64_t a1) {
    int64_t v1 = 0x100000000 * a1 / 0x100000000; // bp-12, 0x40c9
    int64_t v2; // 0x40c0
    int64_t v3; // 0x40c0
    int64_t v4 = function_1aa0((int64_t)&v1, 4, v2, v3); // 0x40d2
    int64_t v5 = (int32_t)v4 == 0x223e9f78 ? 0xffffffff : 0xfffffffe; // 0x40e6
    return v5 + (int64_t)((int32_t)v4 == 0x223e9f78) & 0xffffffff;
}

// Address range: 0x40f0 - 0x4204
int64_t TNEFGetKey(int64_t a1, int64_t a2) {
    // 0x40f0
    int64_t v1; // 0x40f0
    int32_t v2 = v1; // 0x4116
    if (v2 >= 0 != v2 != 0) {
        int32_t v3 = *(int32_t *)(a1 + (int64_t)L"25"); // 0x411a
        if (v3 >= 0 != v3 != 0) {
            // 0x4129
            return 0xfffffffd;
        }
        // 0x4138
        puts("Error reading Key");
        return 0xfffffffd;
    }
    int64_t v4 = function_19b0(a2, 2, 1, a2); // 0x4158
    int32_t * v5 = (int32_t *)(a1 + (int64_t)L"25"); // 0x415d
    uint32_t v6 = *v5; // 0x415d
    *(int16_t *)a2 = (int16_t)v4;
    if (v6 <= 1) {
        // 0x4129
        return 0;
    }
    // 0x4180
    __printf_chk(1, "DEBUG(%i/%i):", 2, (int64_t)v6);
    int64_t v7; // 0x40f0
    uint16_t v8 = *(int16_t *)&v7; // 0x4198
    __printf_chk(1, "Key = 0x%X", (int32_t)v8);
    putchar(10);
    uint32_t v9 = *v5; // 0x41b9
    if (v9 >= 2) {
        // 0x41c4
        __printf_chk(1, "DEBUG(%i/%i):", 2, (int64_t)v9);
        __printf_chk(1, "Key = %i", (int64_t)v8);
        putchar(10);
    }
    // 0x4129
    return 0;
}

// Address range: 0x4210 - 0x4490
int64_t TNEFGetHeader(int64_t a1, int64_t a2, int64_t a3) {
    int32_t * v1 = (int32_t *)(a1 + (int64_t)L"25"); // 0x4223
    uint32_t v2 = *v1; // 0x4223
    int64_t v3 = __readfsqword(40); // 0x4229
    int64_t result = 0xfffffffd; // 0x423c
    int64_t v4; // 0x4210
    if (v2 < 2) {
        goto lab_0x435f;
    } else {
        // 0x425b
        result = 0xfffffffd;
        if (__printf_chk(1, "DEBUG(%i/%i): %s\n", 2, (int64_t)v2, "About to read Component") < 1) {
            goto lab_0x435f;
        } else {
            int32_t v5 = *v1;
            if (v5 < 2) {
                // 0x42f7
                v4 = v5;
                goto lab_0x433b;
            } else {
                int32_t v6 = __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, (int64_t)v5, "About to read type"); // 0x42a7
                uint32_t v7 = *v1;
                if (v6 < 1) {
                    // 0x4450
                    result = 0xfffffffd;
                    if (v7 >= 1) {
                        // 0x445a
                        puts("ERROR: Error reading type");
                        result = 0xfffffffd;
                    }
                    goto lab_0x435f;
                } else {
                    // 0x42ca
                    if (v7 > 1) {
                        // 0x4380
                        int64_t v8; // 0x4210
                        int32_t v9 = v8;
                        __printf_chk(1, "DEBUG(%i/%i):", 2, (int64_t)v7);
                        __printf_chk(1, "Type = 0x%X", v9);
                        int32_t putchar_rc = putchar(10); // 0x43b4
                        uint32_t v10 = *v1; // 0x43b9
                        int32_t v11 = v10; // 0x43c2
                        int32_t v12 = putchar_rc; // 0x43c2
                        if (v10 >= 2) {
                            // 0x43c8
                            __printf_chk(1, "DEBUG(%i/%i):", 2, (int64_t)v10);
                            __printf_chk(1, "Type = %u", v9);
                            int32_t putchar_rc2 = putchar(10); // 0x43fc
                            uint32_t v13 = *v1; // 0x4401
                            v11 = v13;
                            v12 = putchar_rc2;
                            if (v13 >= 2) {
                                int32_t v14 = __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, (int64_t)v13, "About to read size"); // 0x442a
                                v11 = *v1;
                                v12 = v14;
                            }
                        }
                        uint32_t v15 = v11;
                        if (v12 < 1) {
                            // 0x4438
                            result = 0xfffffffd;
                            if (v15 >= 0 == (v15 != 0)) {
                                // 0x4470
                                puts("ERROR: Error reading size");
                                result = 0xfffffffd;
                            }
                            goto lab_0x435f;
                        } else {
                            int64_t v16 = v15; // 0x42f7
                            v4 = v16;
                            if (v15 >= 2) {
                                // 0x4302
                                __printf_chk(1, "DEBUG(%i/%i):", 2, v16);
                                __printf_chk(1, "Size = %u", 1);
                                putchar(10);
                                v4 = v16;
                            }
                            goto lab_0x433b;
                        }
                    } else {
                        // 0x42f7
                        v4 = v7;
                        goto lab_0x433b;
                    }
                }
            }
        }
    }
  lab_0x435f:
    // 0x435f
    if (v3 != __readfsqword(40)) {
        // 0x4486
        __stack_chk_fail();
        return &g80;
    }
    // 0x4373
    return result;
  lab_0x433b:
    // 0x433b
    *(int32_t *)a2 = (int32_t)function_1aa0(a2, 4, 1, v4);
    *(int32_t *)a3 = (int32_t)function_1aa0(a3, 4, 1, v4);
    result = 0;
    goto lab_0x435f;
}

// Address range: 0x4490 - 0x4541
int64_t TNEFRawRead(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    uint32_t v1 = (int32_t)a3; // 0x44bc
    int64_t v2; // 0x4490
    if ((int32_t)v2 < v1) {
        int32_t v3 = *(int32_t *)(a1 + (int64_t)L"25"); // 0x44c1
        if (v3 >= 0 != v3 != 0) {
            // 0x44d1
            return 0xfffffffd;
        }
        // 0x4528
        puts("ERROR: Error reading data");
        return 0xfffffffd;
    }
    // 0x44e0
    if (a4 == 0) {
        // 0x44d1
        return 0;
    }
    int16_t * v4 = (int16_t *)a4; // 0x44ea
    *v4 = 0;
    if (v1 == 0) {
        // 0x44d1
        return 0;
    }
    int64_t v5 = a2 + 1; // 0x4503
    int64_t v6 = (int64_t)*(char *)a2; // 0x4507
    *v4 = (int16_t)v6;
    int64_t v7 = v6 & 0xffffffff; // 0x4510
    while (v5 != a2 + 1 + (a3 + 0xffffffff & 0xffffffff)) {
        int64_t v8 = v5;
        v5 = v8 + 1;
        v6 = v7 + (int64_t)*(char *)v8;
        *v4 = (int16_t)v6;
        v7 = v6 & 0xffffffff;
    }
    // 0x44d1
    return 0;
}

// Address range: 0x4550 - 0x455f
int64_t TNEFInitMapi(int64_t a1) {
    // 0x4550
    *(int32_t *)a1 = 0;
    *(int64_t *)(a1 + 8) = 0;
    int64_t result; // 0x4550
    return result;
}

// Address range: 0x4560 - 0x4600
int64_t TNEFInitAttachment(int64_t a1) {
    // 0x4560
    int128_t v1; // 0x4560
    int128_t v2 = __asm_pxor(v1, v1); // 0x4560
    *(int64_t *)a1 = 0;
    *(int32_t *)(a1 + 8) = 0;
    *(int16_t *)(a1 + 12) = 0;
    __asm_movups(*(int128_t *)(a1 + 96), v2);
    *(int64_t *)(a1 + 16) = 0;
    *(int32_t *)(a1 + 24) = 0;
    *(int64_t *)(a1 + 32) = 0;
    *(int32_t *)(a1 + 40) = 0;
    *(int64_t *)(a1 + 48) = 0;
    *(int64_t *)(a1 + 56) = 0;
    *(int64_t *)(a1 + 64) = 0;
    *(int32_t *)(a1 + 72) = 0;
    *(int64_t *)(a1 + 80) = 0;
    *(int32_t *)(a1 + 88) = 0;
    *(int64_t *)(a1 + 136) = 0;
    *(int32_t *)(a1 + 144) = 0;
    *(int64_t *)(a1 + 152) = 0;
    *(int32_t *)(a1 + 160) = 0;
    int64_t result = function_1a30(a1 + 112); // 0x45ee
    *(int64_t *)(a1 + 128) = 0;
    return result;
}

// Address range: 0x4600 - 0x46a9
int64_t TNEFRendData(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t * v1 = (int64_t *)(448 + a1);
    int64_t v2 = *v1; // 0x4623
    while (v2 != 0) {
        // 0x4623
        v1 = (int64_t *)(v2 + 128);
        v2 = *v1;
    }
    int64_t * mem = calloc(1, 168); // 0x4639
    int64_t v3 = (int64_t)mem; // 0x4639
    *v1 = v3;
    int64_t result; // 0x4600
    if (mem == NULL) {
        // 0x4683
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", 324);
        result = 0xffffffff;
    } else {
        // 0x464d
        function_1b00(v3);
        uint32_t v4 = (int32_t)a4; // 0x4655
        memcpy((int64_t *)(v3 + 96), (int64_t *)a3, v4 >= 16 ? 16 : v4);
        result = 0;
    }
    // 0x4678
    return result;
}

// Address range: 0x46b0 - 0x48c3
int64_t TNEFInitialize(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x46b0
    int128_t v1; // 0x46b0
    int128_t v2 = __asm_pxor(v1, v1); // 0x46b0
    *(int16_t *)(a1 + 84) = 0;
    int64_t v3; // 0x46b0
    __asm_movups(*(int128_t *)&v3, v2);
    *(int16_t *)(a1 + 134) = 0;
    *(int16_t *)(a1 + 184) = 0;
    __asm_movups(*(int128_t *)(a1 + 86), v2);
    __asm_movups(*(int128_t *)(a1 + 102), v2);
    __asm_movups(*(int128_t *)(a1 + 118), v2);
    __asm_movups(*(int128_t *)(a1 + 136), v2);
    __asm_movups(*(int128_t *)(a1 + 152), v2);
    __asm_movups(*(int128_t *)(a1 + 168), v2);
    __asm_movups(*(int128_t *)(a1 + 186), v2);
    __asm_movups(*(int128_t *)(a1 + 202), v2);
    __asm_movups(*(int128_t *)(a1 + 218), v2);
    __asm_movups(*(int128_t *)(a1 + 236), v2);
    __asm_movups(*(int128_t *)(a1 + 252), v2);
    __asm_movups(*(int128_t *)(a1 + 268), v2);
    *(int16_t *)(a1 + 234) = 0;
    *(int64_t *)(a1 + 16) = 0;
    *(int32_t *)(a1 + 24) = 0;
    *(int64_t *)(a1 + 32) = 0;
    *(int32_t *)(a1 + 40) = 0;
    *(int64_t *)(a1 + 48) = 0;
    *(int64_t *)(a1 + 56) = 0;
    *(int64_t *)(a1 + 64) = 0;
    *(int32_t *)(a1 + 72) = 0;
    *(int64_t *)(a1 + 76) = 0;
    *(int16_t *)(a1 + 284) = 0;
    *(int16_t *)(a1 + 312) = 0;
    *(int64_t *)(a1 + 288) = 0;
    *(int32_t *)(a1 + 296) = 0;
    *(int64_t *)(a1 + 304) = 0;
    function_1b00(a1 + 320);
    *(int64_t *)(a1 + (int64_t)&g8) = 0;
    *(int32_t *)(a1 + (int64_t)&g9) = 0;
    *(int16_t *)(a1 + (int64_t)&g10) = 0;
    int64_t result = function_1a30(a1 + (int64_t)&g11); // 0x47d3
    *(int64_t *)(a1 + (int64_t)&g23) = 0;
    *(int32_t *)(a1 + (int64_t)&g26) = 0;
    *(int64_t *)(a1 + (int64_t)&g29) = 0;
    *(int32_t *)(a1 + (int64_t)&g30) = 0;
    *(int64_t *)(a1 + (int64_t)"\b$") = 0;
    *(int32_t *)(a1 + (int64_t)&g31) = 0;
    *(int64_t *)(a1 + (int64_t)&g34) = 0;
    *(int32_t *)(a1 + (int64_t)&g35) = 0;
    *(int64_t *)(a1 + (int64_t)&g38) = 0;
    *(int32_t *)(a1 + (int64_t)&g41) = 0;
    *(int64_t *)(a1 + (int64_t)&g42) = 0;
    *(int64_t *)(a1 + (int64_t)&g44) = 0;
    *(int64_t *)(a1 + (int64_t)L"$%(") = 0;
    *(int32_t *)(a1 + (int64_t)&g47) = 0;
    *(int64_t *)(a1 + (int64_t)L"),/") = 0;
    *(int32_t *)(a1 + (int64_t)&g48) = 0;
    *(int32_t *)(a1 + (int64_t)L"125") = 0;
    *(int64_t *)(a1 + (int64_t)L"=?AEFL") = 0;
    *(int64_t *)(a1 + (int64_t)&g49) = 0;
    *(int64_t *)(a1 + (int64_t)L"678;=?AEFL") = 0;
    *(int64_t *)(a1 + (int64_t)L"8;=?AEFL") = 0;
    *(int32_t *)(a1 + (int64_t)L"AEFL") = 50;
    return result;
}

// Address range: 0x48d0 - 0x49f7
int64_t TNEFFreeMapiProps(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8);
    int64_t v2 = 0; // 0x48e6
    int64_t v3 = 0; // 0x48e6
    int64_t v4; // 0x48d0
    if ((int32_t)v4 == 0) {
        // 0x49df
        free((int64_t *)*v1);
        *(int32_t *)a1 = 0;
        return &g80;
    }
    while (true) {
        int64_t v5 = v3;
        int64_t v6 = *v1; // 0x48f0
        int64_t v7 = v6 + v5; // 0x48fa
        int64_t v8 = *(int64_t *)(v7 + 40); // 0x48fe
        int64_t v9 = v8; // 0x4907
        int64_t v10 = v6; // 0x4907
        int64_t v11 = v8; // 0x4907
        if (*(int32_t *)(v7 + 24) != 0) {
            int64_t v12 = v10 + v5;
            int32_t * v13 = (int32_t *)(v12 + 24);
            int64_t * v14 = (int64_t *)(v12 + 40);
            int64_t v15 = 0;
            int64_t v16 = 0;
            int64_t v17 = v16 + v9; // 0x4926
            int64_t v18; // 0x48d0
            int64_t v19; // 0x48d0
            int64_t v20; // 0x4914
            int64_t v21; // 0x4920
            while (*(int32_t *)(v17 + 8) < 1) {
                // 0x4910
                v20 = v15 + 1;
                v21 = *v14;
                v18 = v16 + 16;
                v19 = v20 & 0xffffffff;
                v11 = v21;
                if (*v13 <= (int32_t)v20) {
                    // break (via goto) -> 0x495d
                    goto lab_0x495d;
                }
                v15 = v19;
                v16 = v18;
                v17 = v16 + v21;
            }
            int64_t v22 = v15 + 1; // 0x4935
            free((int64_t *)*(int64_t *)v17);
            int64_t v23 = *v1; // 0x493e
            int64_t v24 = v23 + v5; // 0x4942
            int64_t v25 = *(int64_t *)(v24 + 40); // 0x4946
            *(int32_t *)(v16 + 8 + v25) = 0;
            v11 = v25;
            while (*(int32_t *)(v24 + 24) > (int32_t)v22) {
                // 0x4932
                v12 = v23 + v5;
                v13 = (int32_t *)(v12 + 24);
                v14 = (int64_t *)(v12 + 40);
                v15 = v22 & 0xffffffff;
                v16 += 16;
                v17 = v16 + v25;
                while (*(int32_t *)(v17 + 8) < 1) {
                    // 0x4910
                    v20 = v15 + 1;
                    v21 = *v14;
                    v18 = v16 + 16;
                    v19 = v20 & 0xffffffff;
                    v11 = v21;
                    if (*v13 <= (int32_t)v20) {
                        // break (via goto) -> 0x495d
                        goto lab_0x495d;
                    }
                    v15 = v19;
                    v16 = v18;
                    v17 = v16 + v21;
                }
                // 0x4932
                v22 = v15 + 1;
                free((int64_t *)*(int64_t *)v17);
                v23 = *v1;
                v24 = v23 + v5;
                v25 = *(int64_t *)(v24 + 40);
                *(int32_t *)(v16 + 8 + v25) = 0;
                v11 = v25;
            }
        }
      lab_0x495d:
        // 0x495d
        free((int64_t *)v11);
        int64_t v26 = *v1; // 0x4962
        int64_t v27 = v26 + v5; // 0x4966
        int64_t v28 = *(int64_t *)(v27 + 32); // 0x496d
        int64_t v29 = v28; // 0x4973
        int64_t v30 = v26; // 0x4973
        int64_t v31 = v28; // 0x4973
        if (*(int32_t *)(v27 + 28) >= 1) {
            int64_t v32 = v30 + v5;
            int32_t * v33 = (int32_t *)(v32 + 28);
            int64_t * v34 = (int64_t *)(v32 + 32);
            int64_t v35 = 0;
            int64_t v36 = 0;
            int64_t v37 = v36 + v29; // 0x4996
            int64_t v38; // 0x48d0
            int64_t v39; // 0x4984
            int64_t v40; // 0x4990
            while (*(int32_t *)(v37 + 8) < 1) {
                // 0x4980
                v39 = v35 + 1 & 0xffffffff;
                v40 = *v34;
                v38 = v36 + 16;
                v31 = v40;
                if (v39 >= (int64_t)*v33) {
                    // break (via goto) -> 0x49cb
                    goto lab_0x49cb;
                }
                v35 = v39;
                v36 = v38;
                v37 = v36 + v40;
            }
            int64_t v41 = v35 + 1 & 0xffffffff; // 0x49a3
            free((int64_t *)*(int64_t *)v37);
            int64_t v42 = *v1; // 0x49ac
            int64_t v43 = v42 + v5; // 0x49b0
            int64_t v44 = *(int64_t *)(v43 + 32); // 0x49b4
            *(int32_t *)(v36 + 8 + v44) = 0;
            v31 = v44;
            while (v41 < (int64_t)*(int32_t *)(v43 + 28)) {
                // 0x4996
                v32 = v42 + v5;
                v33 = (int32_t *)(v32 + 28);
                v34 = (int64_t *)(v32 + 32);
                v35 = v41;
                v36 += 16;
                v37 = v36 + v44;
                while (*(int32_t *)(v37 + 8) < 1) {
                    // 0x4980
                    v39 = v35 + 1 & 0xffffffff;
                    v40 = *v34;
                    v38 = v36 + 16;
                    v31 = v40;
                    if (v39 >= (int64_t)*v33) {
                        // break (via goto) -> 0x49cb
                        goto lab_0x49cb;
                    }
                    v35 = v39;
                    v36 = v38;
                    v37 = v36 + v40;
                }
                // 0x49a0
                v41 = v35 + 1 & 0xffffffff;
                free((int64_t *)*(int64_t *)v37);
                v42 = *v1;
                v43 = v42 + v5;
                v44 = *(int64_t *)(v43 + 32);
                *(int32_t *)(v36 + 8 + v44) = 0;
                v31 = v44;
            }
        }
      lab_0x49cb:
        // 0x49cb
        free((int64_t *)v31);
        int64_t v45 = v2 + 1; // 0x49d0
        v2 = v45 & 0xffffffff;
        v3 = v5 + 48;
        if ((int32_t)v31 <= (int32_t)v45) {
            // break -> 0x49df
            break;
        }
    }
    // 0x49df
    free((int64_t *)*v1);
    *(int32_t *)a1 = 0;
    return &g80;
}

// Address range: 0x4a00 - 0x4a93
int64_t TNEFFreeAttachment(int64_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 24); // 0x4a04
    if (*v1 >= 1) {
        // 0x4a0b
        free((int64_t *)*(int64_t *)(a1 + 16));
        *v1 = 0;
    }
    int32_t * v2 = (int32_t *)(a1 + 40); // 0x4a1b
    if (*v2 >= 1) {
        // 0x4a22
        free((int64_t *)*(int64_t *)(a1 + 32));
        *v2 = 0;
    }
    int32_t * v3 = (int32_t *)(a1 + 88); // 0x4a32
    if (*v3 >= 1) {
        // 0x4a39
        free((int64_t *)*(int64_t *)(a1 + 80));
        *v3 = 0;
    }
    int32_t * v4 = (int32_t *)(a1 + 144); // 0x4a49
    if (*v4 >= 1) {
        // 0x4a53
        free((int64_t *)*(int64_t *)(a1 + 136));
        *v4 = 0;
    }
    int32_t * v5 = (int32_t *)(a1 + 160); // 0x4a69
    if (*v5 >= 1) {
        // 0x4a73
        free((int64_t *)*(int64_t *)(a1 + 152));
        *v5 = 0;
    }
    // 0x4a89
    return function_1a00(a1 + 112);
}

// Address range: 0x4aa0 - 0x4c06
int64_t TNEFFree(int64_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 24); // 0x4aa9
    if (*v1 >= 1) {
        // 0x4ab2
        free((int64_t *)*(int64_t *)(a1 + 16));
        *v1 = 0;
    }
    int32_t * v2 = (int32_t *)(a1 + 40); // 0x4ac2
    if (*v2 >= 1) {
        // 0x4acb
        free((int64_t *)*(int64_t *)(a1 + 32));
        *v2 = 0;
    }
    int32_t * v3 = (int32_t *)(a1 + 296); // 0x4adb
    if (*v3 >= 1) {
        // 0x4ae7
        free((int64_t *)*(int64_t *)(a1 + 288));
        *v3 = 0;
    }
    int32_t * v4 = (int32_t *)(a1 + (int64_t)&g26); // 0x4afd
    if (*v4 >= 1) {
        // 0x4b09
        free((int64_t *)*(int64_t *)(a1 + (int64_t)&g23));
        *v4 = 0;
    }
    int32_t * v5 = (int32_t *)(a1 + (int64_t)&g30); // 0x4b1f
    if (*v5 >= 1) {
        // 0x4b29
        free((int64_t *)*(int64_t *)(a1 + (int64_t)&g29));
        *v5 = 0;
    }
    int32_t * v6 = (int32_t *)(a1 + (int64_t)&g31); // 0x4b3f
    if (*v6 >= 1) {
        // 0x4b49
        free((int64_t *)*(int64_t *)(a1 + (int64_t)"\b$"));
        *v6 = 0;
    }
    int32_t * v7 = (int32_t *)(a1 + (int64_t)&g35); // 0x4b5f
    if (*v7 >= 1) {
        // 0x4b69
        free((int64_t *)*(int64_t *)(a1 + (int64_t)&g34));
        *v7 = 0;
    }
    int32_t * v8 = (int32_t *)(a1 + (int64_t)&g41); // 0x4b7f
    if (*v8 >= 1) {
        // 0x4b89
        free((int64_t *)*(int64_t *)(a1 + (int64_t)&g38));
        *v8 = 0;
    }
    int32_t * v9 = (int32_t *)(a1 + (int64_t)&g48); // 0x4b9f
    if (*v9 >= 1) {
        // 0x4ba9
        free((int64_t *)*(int64_t *)(a1 + (int64_t)L"),/"));
        *v9 = 0;
    }
    int64_t result = function_1a00(a1 + (int64_t)&g11); // 0x4bc6
    int64_t v10 = *(int64_t *)(a1 + 448); // 0x4bcb
    if (v10 == 0) {
        // 0x4bff
        return result;
    }
    function_1ad0(v10);
    int64_t v11 = *(int64_t *)(v10 + 128); // 0x4be8
    free((int64_t *)v10);
    while (v11 != 0) {
        int64_t v12 = v11;
        function_1ad0(v12);
        v11 = *(int64_t *)(v12 + 128);
        free((int64_t *)v12);
    }
    // 0x4bff
    return &g80;
}

// Address range: 0x4c10 - 0x5210
int64_t TNEFParse(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x4c1e
    int64_t v2; // 0x4c10
    int64_t v3; // 0x4c10
    int64_t result; // 0x4c10
    int64_t v4; // 0x4c10
    int32_t * v5; // 0x4c4d
    if (*(int64_t *)(a1 + (int64_t)L"678;=?AEFL") == 0) {
        // 0x51e6
        puts("ERROR: Setup incorrectly: No ReadProc");
        result = 0xfffffff8;
        goto lab_0x4f39;
    } else {
        int64_t * v6 = (int64_t *)(a1 + (int64_t)&g49); // 0x4c3c
        int64_t v7 = *v6; // 0x4c3c
        v5 = (int32_t *)(a1 + (int64_t)L"25");
        uint32_t v8 = *v5; // 0x4c4d
        int64_t v9 = v8; // 0x4c4d
        v3 = 0;
        v4 = v9;
        if (v7 == 0) {
            goto lab_0x4eb8;
        } else {
            int64_t v10 = v7; // 0x4c64
            if (v8 > 1) {
                // 0x4f5e
                __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, v9, "About to initialize");
                v10 = *v6;
            }
            // 0x4c6a
            result = 0xffffffff;
            if ((int32_t)v10 != 0) {
                goto lab_0x4f39;
            } else {
                uint32_t v11 = *v5; // 0x4c7b
                v2 = v10;
                if (v11 > 1) {
                    // 0x4e95
                    v3 = __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, (int64_t)v11, "Initialization finished");
                    v4 = (int64_t)*v5;
                    goto lab_0x4eb8;
                } else {
                    goto lab_0x4c8a;
                }
            }
        }
    }
  lab_0x4f39:
    // 0x4f39
    if (v1 != __readfsqword(40)) {
        // 0x51fc
        __stack_chk_fail();
        return &g80;
    }
    // 0x4f4f
    return result;
  lab_0x4e10:;
    // 0x4e10
    int64_t v12; // 0x4c10
    int64_t v13 = v12 + 1; // 0x4e10
    int64_t v14 = v13; // 0x4e1c
    if ((int32_t)v13 == 33) {
        // break -> 0x4e88
        goto lab_0x4e88_2;
    }
    goto lab_0x4e1e;
  lab_0x4e1e:;
    // 0x4e1e
    int64_t v15; // 0x4c10
    int64_t v16 = v15 + 56; // 0x4c10
    int64_t v17 = v14; // 0x4c10
    goto lab_0x4e1e_2;
  lab_0x4e88_2:;
    // 0x4e88
    int64_t * mem; // 0x4d9d
    free(mem);
    int64_t v22; // 0x4d2d
    int64_t v23; // 0x4d37
    int64_t v24 = function_1b40(a1, v23, v22); // 0x4d54
    int64_t v25 = v24; // 0x4d5e
    result = 0;
    if ((int32_t)v24 != 0) {
        goto lab_0x4f39;
    }
    goto lab_0x4d64;
  lab_0x4eb8:
    // 0x4eb8
    v2 = v3;
    if ((int32_t)v4 >= 2) {
        // 0x4ec1
        v2 = __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, v4, "Reading Signature");
    }
    goto lab_0x4c8a;
  lab_0x4c8a:
    // 0x4c8a
    if ((int32_t)v2 < 1) {
        // 0x5080
        puts("ERROR: Error reading signature");
        result = 0xfffffffd;
        goto lab_0x4f39;
    } else {
        uint32_t v36 = *v5; // 0x4cae
        int64_t v37 = v36; // 0x4cae
        uint32_t v38; // 0x4c10
        if (v36 > 1) {
            // 0x4ee5
            __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, v37, "Checking Signature");
            if ((int32_t)function_1b60((int64_t)v38, (int64_t)"DEBUG(%i/%i): %s\n", 2, (int64_t *)v37) >= 0) {
                goto lab_0x4cce;
            } else {
                // 0x4f15
                puts("ERROR: Signature does not match. Not TNEF.");
                result = 0xfffffffe;
                goto lab_0x4f39;
            }
        } else {
            // 0x4cbd
            if ((int32_t)function_1b60((int64_t)v38, 4, 1, (int64_t *)v37) < 0) {
                // 0x4f15
                puts("ERROR: Signature does not match. Not TNEF.");
                result = 0xfffffffe;
                goto lab_0x4f39;
            } else {
                goto lab_0x4cce;
            }
        }
    }
  lab_0x4cce:;
    uint32_t v39 = *v5; // 0x4cce
    if (v39 > 1) {
        // 0x4f89
        __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, (int64_t)v39, "Reading Key.");
    }
    // 0x4cdd
    int64_t v40; // bp-82, 0x4c10
    if ((int32_t)function_1a20(a1, &v40) < 0) {
        // 0x50a6
        puts("ERROR: Unable to retrieve key.");
        result = 0xfffffffc;
    } else {
        uint32_t v41 = *v5; // 0x4cf2
        if (v41 >= 2) {
            // 0x4cfd
            __printf_chk(1, "DEBUG(%i/%i): %s\n", 2, (int64_t)v41, "Starting Full Processing.");
        }
        // 0x4d1c
        int32_t nmemb; // bp-72, 0x4c10
        v22 = &nmemb;
        int32_t v18; // bp-76, 0x4c10
        v23 = &v18;
        int64_t v42 = function_1b40(a1, v23, v22); // 0x4d54
        result = 0;
        if ((int32_t)v42 == 0) {
            // 0x4d64
            int16_t v35; // bp-78, 0x4c10
            int64_t v31 = 0x100000000 * (int64_t)&v35 / 0x100000000;
            int64_t v34; // bp-80, 0x4c10
            int64_t v32 = &v34;
            v25 = v42;
            while (true) {
              lab_0x4d64:;
                uint32_t v26 = *v5; // 0x4d64
                if (v26 > 1) {
                    // 0x4fb0
                    __printf_chk(1, "DEBUG(%i/%i):", 2, (int64_t)v26);
                    __printf_chk(1, "Header says type=0x%X, size=%u", v18, nmemb);
                    putchar(10);
                    if (*v5 >= 2) {
                        // 0x4ff8
                        uint32_t v27; // 0x4fe9
                        __printf_chk(1, "DEBUG(%i/%i):", 2, (int64_t)v27);
                        int32_t v28 = nmemb; // 0x500c
                        int32_t v29 = v18; // 0x5010
                        __printf_chk(1, "Header says type=%u, size=%u", v29, v28);
                        putchar(10);
                    }
                }
                // 0x4d73
                if (nmemb == 0) {
                    // break -> 0x5153
                    break;
                }
                uint32_t v30 = 0x100000 * *(int32_t *)(a1 + (int64_t)L"AEFL"); // 0x4d88
                if (v30 < nmemb) {
                    // 0x5126
                    __printf_chk(1, "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n", nmemb, "ytnef.c", (int64_t)&g58, (int64_t)v30);
                    result = 0xffffffff;
                    goto lab_0x4f39;
                }
                // 0x4d95
                mem = calloc(nmemb, 1);
                if (mem == NULL) {
                    // 0x50fd
                    __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g59);
                    result = 0xffffffff;
                    goto lab_0x4f39;
                }
                // 0x4dae
                if ((int32_t)function_1950(a1, (int64_t)mem, (int64_t)nmemb, v31) < 0) {
                    // 0x50cc
                    puts("ERROR: Unable to read data.");
                    // 0x50eb
                    free(mem);
                    result = 0xfffffffd;
                    goto lab_0x4f39;
                }
                // 0x4dc9
                if ((int32_t)function_1950(a1, v32, 2, 0) < 0) {
                    // 0x51b4
                    puts("ERROR: Unable to read checksum.");
                    // 0x50eb
                    free(mem);
                    result = 0xfffffffd;
                    goto lab_0x4f39;
                }
                int64_t v33 = function_19b0(v32, 2, 2, 0); // 0x4deb
                v34 = 0x1000000000000 * v33 / 0x1000000000000;
                if (v35 != (int16_t)v33) {
                    // 0x5183
                    puts("ERROR: Checksum mismatch. Data corruption?:");
                    free(mem);
                    result = 0xfffffffb;
                    goto lab_0x4f39;
                }
                // 0x4e00
                v16 = (int64_t)g17;
                v17 = v25;
                while (true) {
                  lab_0x4e1e_2:
                    // 0x4e1e
                    v15 = v16;
                    v12 = v17 & 0xffffffff;
                    if (*(int32_t *)v15 != v18) {
                        goto lab_0x4e10;
                    } else {
                        int64_t v19 = *(int64_t *)(v15 + 48); // 0x4e27
                        if (v19 != 0) {
                            if ((int32_t)v19 >= 0) {
                                goto lab_0x4e88_2;
                            } else {
                                // 0x5057
                                free(mem);
                                result = 0xfffffffa;
                                goto lab_0x4f39;
                            }
                        }
                        uint32_t v20 = *v5; // 0x4e34
                        if (v20 < 1) {
                            goto lab_0x4e10;
                        } else {
                            int64_t v21 = v12 + 1; // 0x4e4d
                            __printf_chk(1, "DEBUG(%i/%i):", 1, (int64_t)v20);
                            __printf_chk(1, "No handler for %s: %u bytes", (char *)(v15 + 4), nmemb);
                            putchar(10);
                            v14 = v21;
                            if ((int32_t)v21 == 33) {
                                // break -> 0x4e88
                                break;
                            }
                            goto lab_0x4e1e;
                        }
                    }
                }
                goto lab_0x4e88_2;
            }
            // 0x5153
            puts("ERROR: Field with size of 0");
            result = 0xfffffffd;
        }
    }
    goto lab_0x4f39;
}

// Address range: 0x5210 - 0x52c0
int64_t TNEFParseFile(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x521c
    if (*(int32_t *)(a2 + (int64_t)L"25") >= 1) {
        // 0x5236
        __printf_chk(1, "Attempting to parse %s...\n", (char *)a1);
    }
    // 0x5252
    int64_t v2; // bp-56, 0x5210
    *(int64_t *)(a2 + (int64_t)L"=?AEFL") = (int64_t)&v2;
    v2 = a1;
    *(int64_t *)(a2 + (int64_t)&g49) = g21;
    *(int64_t *)(a2 + (int64_t)L"678;=?AEFL") = g19;
    *(int64_t *)(a2 + (int64_t)L"8;=?AEFL") = g14;
    int64_t result = function_1ae0(a2); // 0x529a
    if (v1 == __readfsqword(40)) {
        // 0x52af
        return result;
    }
    // 0x52b6
    __stack_chk_fail();
    return &g80;
}

// Address range: 0x52c0 - 0x5380
int64_t TNEFParseMemory(int64_t a1, int64_t a2, int64_t a3) {
    uint32_t v1 = *(int32_t *)(a3 + (int64_t)L"25"); // 0x52d1
    int64_t v2 = __readfsqword(40); // 0x52d7
    if (v1 >= 1) {
        // 0x52eb
        __printf_chk(1, "DEBUG(%i/%i): %s\n", 1, (int64_t)v1, "Attempting to parse memory block...\n");
    }
    int64_t v3 = a1; // bp-72, 0x5314
    *(int64_t *)(a3 + (int64_t)L"=?AEFL") = (int64_t)&v3;
    *(int64_t *)(a3 + (int64_t)&g49) = g20;
    *(int64_t *)(a3 + (int64_t)L"678;=?AEFL") = g15;
    *(int64_t *)(a3 + (int64_t)L"8;=?AEFL") = g18;
    int64_t result = function_1ae0(a3); // 0x5357
    if (v2 == __readfsqword(40)) {
        // 0x536c
        return result;
    }
    // 0x5375
    __stack_chk_fail();
    return &g80;
}

// Address range: 0x5380 - 0x53d9
int64_t MAPIFindUserProp(int64_t a1, int64_t a2) {
    if (a1 == 0 || (int32_t)a1 == 0) {
        // 0x53d7
        return -1;
    }
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x5395
    if (*(int32_t *)(v1 + 20) == (int32_t)a2) {
        // 0x53be
        if (*(int32_t *)v1 == 1) {
            // 0x53c3
            return *(int64_t *)(v1 + 40);
        }
    }
    int64_t v2 = v1 + 48; // 0x53b0
    while (v2 != 48 * (a1 + 0xffffffff & 0xffffffff) + 48 + v1) {
        int64_t v3 = v2;
        if (*(int32_t *)(v3 + 20) == (int32_t)a2) {
            // 0x53be
            if (*(int32_t *)v3 == 1) {
                // 0x53c3
                return *(int64_t *)(v3 + 40);
            }
        }
        // 0x53b0
        v2 = v3 + 48;
    }
    // 0x53d7
    return -1;
}

// Address range: 0x53e0 - 0x5439
int64_t MAPIFindProperty(int64_t a1, int64_t a2) {
    if (a1 == 0 || (int32_t)a1 == 0) {
        // 0x5437
        return -1;
    }
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x53f5
    if (*(int32_t *)(v1 + 20) == (int32_t)a2) {
        // 0x541e
        if (*(int32_t *)v1 == 0) {
            // 0x5424
            return *(int64_t *)(v1 + 40);
        }
    }
    int64_t v2 = v1 + 48; // 0x5410
    while (v2 != 48 * (a1 + 0xffffffff & 0xffffffff) + 48 + v1) {
        int64_t v3 = v2;
        if (*(int32_t *)(v3 + 20) == (int32_t)a2) {
            // 0x541e
            if (*(int32_t *)v3 == 0) {
                // 0x5424
                return *(int64_t *)(v3 + 40);
            }
        }
        // 0x5410
        v2 = v3 + 48;
    }
    // 0x5437
    return -1;
}

// Address range: 0x5440 - 0x56e0
int64_t MAPISysTimetoDTR(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x5451
    int64_t v2 = 0x1c0000001f; // bp-72, 0x5475
    int32_t v3; // 0x5440
    int64_t v4; // 0x5440
    int64_t v5; // 0x5440
    int64_t v6; // 0x5440
    int64_t v7; // 0x5440
    int64_t v8; // 0x5440
    int64_t v9; // 0x5440
    int64_t v10; // 0x5440
    int64_t v11; // 0x55c1
    int32_t v12; // 0x55b6
    uint64_t v13; // 0x55bd
    int16_t * v14 = (int16_t *)a2; // 0x557c
    *v14 = (int16_t)&g63;
    v3 = 2;
    v7 = &g63;
    v5 = 365;
    v8 = 0;
    v10 = 2;
    v9 = 0;
    int16_t v15; // 0x5440
    while (true) {
      lab_0x55bd:;
        int32_t v16 = v3;
        v13 = v7 + 1;
        int64_t v17 = v16 + 1; // 0x55c4
        v15 = v13;
        v6 = 365;
        v4 = v17;
        if (v13 % 4 != 0) {
            goto lab_0x5598;
        } else {
            if (100 * ((int16_t)(v13 / 4 % 0x4000 * (int64_t)(int32_t)&g1 / 0x20000) % 0x8000) != v15) {
                // 0x5620
                v6 = 366;
                v4 = v16 + 2;
                goto lab_0x5598;
            } else {
                // 0x55fa
                v6 = 365;
                v4 = v17;
                if (-400 * (int16_t)(v13 / 16 % 0x1000 * (int64_t)(int32_t)&g79 / 0x10000) != -v15) {
                    goto lab_0x5598;
                } else {
                    // 0x5620
                    v6 = 366;
                    v4 = v16 + 2;
                    goto lab_0x5598;
                }
            }
        }
    }
  lab_0x5598_2:
    // 0x5598
    *v14 = v15;
    v10 = v12;
    v9 = v11;
    int64_t v18 = v9 + v10; // 0x563e
    int32_t v19 = v18; // 0x564d
    int32_t v20 = 0x24924925 * (v18 & 0xffffffff) / 0x100000000; // 0x564f
    int16_t * v21 = (int16_t *)(a2 + 2); // 0x5669
    *v21 = 0;
    *(int16_t *)(a2 + 12) = (int16_t)(-7 * ((v19 - v20) / 2 + v20) / 4 + v19);
    int64_t v22 = 1; // 0x5678
    int16_t v23 = 1; // 0x5678
    int64_t v24 = v9 & 0xffffffff; // 0x5678
    if (v9 >= 32) {
        int64_t v25 = v24 - 31; // 0x5680
        v24 = v25 & 0xffffffff;
        int64_t v26 = v22 + 1; // 0x5685
        uint32_t v27 = *(int32_t *)((4 * v22 & 0x3fffc) + (int64_t)&v2); // 0x5688
        v22 = v26 & 0xffffffff;
        while (v27 < (int32_t)v25) {
            // 0x5680
            v25 = v24 - (int64_t)v27;
            v24 = v25 & 0xffffffff;
            v26 = v22 + 1;
            v27 = *(int32_t *)((4 * v22 & 0x3fffc) + (int64_t)&v2);
            v22 = v26 & 0xffffffff;
        }
        // 0x568f
        v23 = v26;
    }
    // 0x5692
    *v21 = v23;
    *(int16_t *)(a2 + 4) = (int16_t)v24 + 1;
    if (v1 != __readfsqword(40)) {
        // 0x56d2
        __stack_chk_fail();
        return &g80;
    }
    // 0x56b1
    return 0;
  lab_0x5598:
    // 0x5598
    v11 = v8 - v5;
    int32_t v28 = v4; // 0x559e
    int32_t v29 = 0x24924925 * v4 / 0x100000000; // 0x55a1
    v12 = -7 * ((v28 - v29) / 2 + v29) / 4 + v28;
    v3 = v12;
    v7 = v13 & 0xffffffff;
    v5 = v6;
    v8 = v11;
    if (v11 < v6) {
        // break -> 0x5598
        goto lab_0x5598_2;
    }
    goto lab_0x55bd;
}

// Address range: 0x56e0 - 0x571f
int64_t IsCompressedRTF(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a1 + 8; // 0x56e0
    if (*(int32_t *)v1 < 12) {
        // 0x56e6
        return 0;
    }
    // 0x56f0
    int64_t v2; // 0x56e0
    int32_t v3 = function_1aa0(v1, 4, a3, v2); // 0x5705
    return v3 == 0x75465a4c | v3 == 0x414c454d;
}

// Address range: 0x5720 - 0x5bce
int64_t DecompressRTF(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t * mem = calloc(208, 1); // 0x5740
    if (mem == NULL) {
        // 0x5b7e
        __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g60);
        // 0x5ab6
        return 0;
    }
    int64_t v1 = (int64_t)mem; // 0x5740
    int128_t v2 = __asm_movdqa(g65); // 0x5753
    int32_t * v3 = (int32_t *)(a1 + 8); // 0x575e
    __asm_movups(*(int128_t *)mem, v2);
    int128_t v4 = __asm_movdqa(g66); // 0x576b
    int128_t * v5 = (int128_t *)(v1 + 16); // 0x5773
    __asm_movups(*v5, v4);
    int128_t v6 = __asm_movdqa(g67); // 0x5777
    int128_t * v7 = (int128_t *)(v1 + 32); // 0x577f
    __asm_movups(*v7, v6);
    int128_t v8 = __asm_movdqa(g68); // 0x5783
    int128_t * v9 = (int128_t *)(v1 + 48); // 0x578b
    __asm_movups(*v9, v8);
    int128_t v10 = __asm_movdqa(g69); // 0x578f
    int128_t * v11 = (int128_t *)(v1 + 64); // 0x5797
    __asm_movups(*v11, v10);
    int128_t v12 = __asm_movdqa(g70); // 0x579b
    int128_t * v13 = (int128_t *)(v1 + 80); // 0x57a3
    __asm_movups(*v13, v12);
    int128_t v14 = __asm_movdqa(g71); // 0x57a7
    int128_t * v15 = (int128_t *)(v1 + 96); // 0x57af
    __asm_movups(*v15, v14);
    int128_t v16 = __asm_movdqa(g72); // 0x57b3
    int128_t * v17 = (int128_t *)(v1 + 112); // 0x57bb
    __asm_movups(*v17, v16);
    int128_t v18 = __asm_movdqa(g73); // 0x57bf
    int128_t * v19 = (int128_t *)(v1 + 128); // 0x57c7
    __asm_movups(*v19, v18);
    int128_t v20 = __asm_movdqa(g74); // 0x57ce
    int128_t * v21 = (int128_t *)(v1 + 144); // 0x57d6
    __asm_movups(*v21, v20);
    int128_t v22 = __asm_movdqa(g75); // 0x57dd
    int128_t * v23 = (int128_t *)(v1 + 160); // 0x57e5
    __asm_movups(*v23, v22);
    int128_t v24 = __asm_movdqa(g76); // 0x57ec
    int128_t * v25 = (int128_t *)(v1 + 176); // 0x57f4
    __asm_movups(*v25, v24);
    int32_t * v26 = (int32_t *)(v1 + 200); // 0x5805
    *v26 = 0x6261745c;
    char * v27 = (char *)(v1 + 206); // 0x580f
    *v27 = 120;
    int64_t * v28 = (int64_t *)(v1 + 192); // 0x5816
    *v28 = 0x755c695c625c3032;
    int16_t * v29 = (int16_t *)(v1 + 204); // 0x5822
    *v29 = (int16_t)&g77;
    if (*v3 < 20) {
        // 0x5b18
        puts("File too small");
        // 0x5ab6
        return 0;
    }
    int64_t v30 = function_1aa0(208, 4, a3, (int64_t)&g60); // 0x5837
    int64_t nmemb = function_1aa0(212, 4, a3, (int64_t)&g60); // 0x5847
    int64_t v31 = function_1aa0(216, 4, a3, (int64_t)&g60); // 0x5858
    uint32_t v32 = *v3; // 0x585d
    uint32_t v33 = v32 - 4; // 0x5862
    int32_t v34 = v30; // 0x5866
    if (v33 != v34) {
        // 0x5b30
        __printf_chk(1, " Size Mismatch: %u != %i\n", v34, (int64_t)v33);
        free(mem);
        // 0x5ab6
        return 0;
    }
    int32_t v35 = v31; // 0x586e
    int32_t v36; // 0x5720
    int64_t v37; // 0x5720
    int64_t v38; // 0x5720
    int64_t result2; // 0x5720
    int64_t v39; // 0x5720
    int64_t v40; // 0x5720
    int64_t v41; // 0x5720
    int64_t v42; // 0x5720
    int64_t v43; // 0x5720
    int64_t v44; // 0x5720
    int64_t v45; // 0x5720
    int64_t v46; // 0x5720
    uint32_t nmemb2; // 0x58a6
    if (v35 == 0x414c454d) {
        int64_t * mem2 = calloc((int32_t)nmemb, 1); // 0x5ad8
        v43 = &g61;
        result2 = (int64_t)mem2;
        if (mem2 != NULL) {
            // 0x5aea
            free(mem);
            // 0x5ab6
            return 0;
        }
    } else {
        if (v35 != 0x75465a4c) {
            // 0x5ba0
            __printf_chk(1, "Unknown compression type (magic number %x)\n", v35);
            // 0x5aea
            free(mem);
            // 0x5ab6
            return 0;
        }
        int32_t nmemb3 = nmemb;
        if (-nmemb3 < 0x800000d1) {
            // 0x5bba
            puts("Corrupted file");
            // 0x5ab6
            return 0;
        }
        // 0x5897
        nmemb2 = nmemb3 + 207;
        int64_t * mem3 = calloc(nmemb2, 1); // 0x58a6
        if (mem3 == NULL) {
            // 0x5b7e
            __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", (int64_t)&g62);
            // 0x5ab6
            return 0;
        }
        int64_t v47 = (int64_t)mem3; // 0x58a6
        __asm_movups(*(int128_t *)mem3, __asm_movdqu(*(int128_t *)mem));
        __asm_movups(*(int128_t *)(v47 + 16), __asm_movdqu(*v5));
        __asm_movups(*(int128_t *)(v47 + 32), __asm_movdqu(*v7));
        __asm_movups(*(int128_t *)(v47 + 48), __asm_movdqu(*v9));
        __asm_movups(*(int128_t *)(v47 + 64), __asm_movdqu(*v11));
        __asm_movups(*(int128_t *)(v47 + 80), __asm_movdqu(*v13));
        __asm_movups(*(int128_t *)(v47 + 96), __asm_movdqu(*v15));
        __asm_movups(*(int128_t *)(v47 + 112), __asm_movdqu(*v17));
        __asm_movups(*(int128_t *)(v47 + 128), __asm_movdqu(*v19));
        __asm_movups(*(int128_t *)(v47 + 144), __asm_movdqu(*v21));
        __asm_movups(*(int128_t *)(v47 + 160), __asm_movdqu(*v23));
        __asm_movups(*(int128_t *)(v47 + 176), __asm_movdqu(*v25));
        *(int64_t *)(v47 + 192) = *v28;
        *(int32_t *)(v47 + 200) = *v26;
        *(int16_t *)(v47 + 204) = *v29;
        *(char *)(v47 + 206) = *v27;
        v42 = 16;
        v46 = 207;
        v39 = 0;
        v37 = 0;
        if (nmemb2 >= 208 && v32 >= 17) {
            while (true) {
              lab_0x59cf:;
                int64_t v48 = v46;
                int64_t v49 = v42;
                int64_t v50 = v49; // 0x59d8
                v38 = (int32_t)v37 / 2;
                if (v39 % 8 == 0) {
                    // 0x59da
                    v50 = v49 + 1;
                    v38 = (int64_t)*(char *)(v49 + 208);
                }
                int64_t v51 = v50;
                int64_t v52 = v51 & 0xffffffff;
                if (v38 % 2 == 0) {
                    if (v32 <= (int32_t)v51) {
                        // break -> 0x5b00
                        break;
                    }
                    int64_t v53 = v48 + 1; // 0x59b3
                    *(char *)((v48 & 0xffffffff) + v47) = *(char *)(v52 + 208);
                    v36 = v53;
                    v40 = v51 + 1 & 0xffffffff;
                    v44 = v53 & 0xffffffff;
                    goto lab_0x59b9;
                } else {
                    int64_t v54 = v51 + 2 & 0xffffffff; // 0x59eb
                    unsigned char v55 = *(char *)(v52 + 208); // 0x59ee
                    unsigned char v56 = *(char *)((v51 + 1 & 0xffffffff) + 208); // 0x59f3
                    int64_t v57 = 16 * (int64_t)v55 | v48 & 0xfffff000 | (int64_t)(v56 / 16); // 0x5a11
                    int32_t v58 = v48;
                    int64_t v59 = (int32_t)v57 >= v58 ? v57 + 0xfffff000 : v57; // 0x5a1b
                    uint32_t v60 = (int32_t)v59; // 0x5a1e
                    v36 = v58;
                    v40 = v54;
                    v44 = v48;
                    if (nmemb2 > (int32_t)(v60 >= v58 ? v59 : v48)) {
                        uint32_t v61 = (int32_t)(v59 + (int64_t)(v56 % 16 + 2)); // 0x5a2f
                        v36 = v58;
                        v40 = v54;
                        v44 = v48;
                        int64_t v62 = v59; // 0x5a32
                        int64_t v63 = v48; // 0x5a32
                        if (v60 >= v61) {
                            goto lab_0x59b9;
                        } else {
                            int64_t v64 = v62 & 0xffffffff;
                            int64_t v65 = v63 + 1; // 0x5a3a
                            int64_t v66 = v65 & 0xffffffff; // 0x5a3a
                            int64_t v67 = v64 + 1; // 0x5a3d
                            uint32_t v68 = (int32_t)v67; // 0x5a44
                            *(char *)(v63 + v47) = *(char *)(v64 + v47);
                            uint32_t v69 = (int32_t)v65;
                            v63 = v66;
                            while (nmemb2 > v68 == (v61 > v68 && nmemb2 > v69)) {
                                // 0x5a38
                                v64 = v67 & 0xffffffff;
                                v65 = v63 + 1;
                                v66 = v65 & 0xffffffff;
                                v67 = v64 + 1;
                                v68 = (int32_t)v67;
                                *(char *)(v63 + v47) = *(char *)(v64 + v47);
                                v69 = (int32_t)v65;
                                v63 = v66;
                            }
                            // 0x5a62
                            v41 = v54;
                            v45 = v66;
                            if (nmemb2 <= v69) {
                                goto lab_0x5a70_3;
                            }
                            goto lab_0x59c2;
                        }
                    } else {
                        goto lab_0x59b9;
                    }
                }
            }
            // 0x5b00
            puts("Corrupted stream");
            // 0x5ab6
            return 0;
        }
      lab_0x5a70_3:;
        int64_t * mem4 = calloc(nmemb3, 1); // 0x5a7b
        int64_t result = (int64_t)mem4; // 0x5a7b
        v43 = &g64;
        result2 = result;
        if (mem4 != NULL) {
            // 0x5a8c
            memcpy(mem4, (int64_t *)(v47 + 207), nmemb3);
            free(mem3);
            *(int32_t *)a2 = nmemb3;
            free(mem);
            // 0x5ab6
            return result;
        }
    }
    // 0x5b5a
    __printf_chk(1, "Out of Memory at %s : %i\n", "ytnef.c", v43);
    // 0x5ab6
    return result2;
  lab_0x59b9:
    // 0x59b9
    v41 = v40;
    v45 = v44;
    if (nmemb2 <= v36) {
        goto lab_0x5a70_3;
    }
    goto lab_0x59c2;
  lab_0x59c2:
    // 0x59c2
    v42 = v41;
    v46 = v45;
    v39 = v39 + 1 & 0xffffffff;
    v37 = v38;
    if (v32 <= (int32_t)v41) {
        goto lab_0x5a70_3;
    }
    goto lab_0x59cf;
}

// Address range: 0x5bd0 - 0x6410
int64_t MAPIPrint(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x5be0
    int64_t v2; // 0x5bd0
    int64_t v3; // 0x5bd0
    int64_t v4; // 0x5bd0
    int64_t v5; // 0x5bd0
    int64_t v6; // 0x5c3a
    int16_t * v7; // 0x5c45
    if ((int32_t)v4 != 0) {
        // 0x5bfd
        uint16_t v8; // 0x5bd0
        uint16_t v9; // 0x5bd0
        uint16_t v10; // 0x5bd0
        v5 = 0x100000000 * (int64_t)v8 | (int64_t)v9 | 0x10000 * (int64_t)v10;
        v2 = 0;
        v3 = 0;
        while (true) {
          lab_0x5c20:
            // 0x5c20
            v6 = *(int64_t *)(a1 + 8) + v3;
            __printf_chk(1, "   #%i: Type: [", v2);
            v7 = (int16_t *)(v6 + 20);
            uint16_t v11 = *v7; // 0x5c45
            if (v11 == 10) {
                // 0x63ec
                __printf_chk(1, "  ERROR  ");
                goto lab_0x5d30;
            } else {
                if (v11 < 11) {
                    if (v11 == 3) {
                        // 0x63d4
                        __printf_chk(1, "  LONG   ");
                        goto lab_0x5d30;
                    } else {
                        if (v11 < 4) {
                            switch (v11) {
                                case 1: {
                                    // 0x6374
                                    __printf_chk(1, "  NULL   ");
                                    // break -> 0x5d30
                                    break;
                                }
                                case 0: {
                                    // 0x5ce7
                                    __printf_chk(1, "  NONE   ");
                                    // break -> 0x5d30
                                    break;
                                }
                                default: {
                                    // 0x5fd7
                                    __printf_chk(1, "   I2    ");
                                    // break -> 0x5d30
                                    break;
                                }
                            }
                            goto lab_0x5d30;
                        } else {
                            if (v11 == 5) {
                                // 0x63bc
                                __printf_chk(1, " DOUBLE  ");
                                goto lab_0x5d30;
                            } else {
                                if (v11 < 5) {
                                    // 0x635c
                                    __printf_chk(1, "   R4    ");
                                    goto lab_0x5d30;
                                } else {
                                    if (v11 == 6) {
                                        // 0x5fbf
                                        __printf_chk(1, "CURRENCY ");
                                        goto lab_0x5d30;
                                    } else {
                                        if (v11 != 7) {
                                            // 0x5d17
                                            __printf_chk(1, "<%x>", (int32_t)v11);
                                            goto lab_0x5d30;
                                        } else {
                                            // 0x5c80
                                            __printf_chk(1, "APP TIME ");
                                            goto lab_0x5d30;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (v11 == 30) {
                        // 0x638c
                        __printf_chk(1, " STRING8 ");
                        goto lab_0x5d30;
                    } else {
                        if (v11 < 31) {
                            switch (v11) {
                                case 13: {
                                    // 0x63a4
                                    __printf_chk(1, " OBJECT  ");
                                    goto lab_0x5d30;
                                }
                                case 20: {
                                    // 0x5fef
                                    __printf_chk(1, "   I8    ");
                                    goto lab_0x5d30;
                                }
                                case 11: {
                                    // 0x632c
                                    __printf_chk(1, " BOOLEAN ");
                                    goto lab_0x5d30;
                                }
                                default: {
                                    // 0x5d17
                                    __printf_chk(1, "<%x>", (int32_t)v11);
                                    goto lab_0x5d30;
                                }
                            }
                        } else {
                            if (v11 == 64) {
                                // 0x6344
                                __printf_chk(1, "SYS TIME ");
                                goto lab_0x5d30;
                            } else {
                                if (v11 < 65) {
                                    if (v11 != 31) {
                                        // 0x5d17
                                        __printf_chk(1, "<%x>", (int32_t)v11);
                                        goto lab_0x5d30;
                                    } else {
                                        // 0x6314
                                        __printf_chk(1, " UNICODE ");
                                        goto lab_0x5d30;
                                    }
                                } else {
                                    if (v11 == 72) {
                                        // 0x5fa7
                                        __printf_chk(1, "OLE GUID ");
                                        goto lab_0x5d30;
                                    } else {
                                        if (v11 != 258) {
                                            // 0x5d17
                                            __printf_chk(1, "<%x>", (int32_t)v11);
                                            goto lab_0x5d30;
                                        } else {
                                            // 0x5cc3
                                            __printf_chk(1, " BINARY  ");
                                            goto lab_0x5d30;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x5f84:;
    int64_t result = __readfsqword(40) ^ v1; // 0x5f89
    if (result != 0) {
        // 0x6404
        __stack_chk_fail();
        return &g80;
    }
    // 0x5f98
    return result;
  lab_0x5eb8:;
    // 0x5eb8
    int32_t * v12; // 0x5df5
    uint32_t v13 = *v12; // 0x5eb8
    int64_t v14; // 0x5bd0
    int64_t v15 = v14 + 1; // 0x5ebb
    int32_t v16 = v13; // 0x5ec6
    int64_t v17 = v15; // 0x5ec6
    if (v13 <= (int32_t)v15) {
        // break -> 0x5f68
        goto lab_0x5f68_2;
    }
    goto lab_0x5ecc;
  lab_0x5ecc:;
    int32_t v18 = v16; // 0x5bd0
    int64_t v19 = v17 & 0xffffffff; // 0x5bd0
    int64_t v20; // 0x5bd0
    int64_t v21 = v20 + 16; // 0x5bd0
    goto lab_0x5ecc_2;
  lab_0x5f37:;
    // 0x5f37
    int64_t v23; // 0x5ed0
    int64_t v48 = *(int64_t *)v23; // 0x5f37
    int64_t v49 = v14 + 1; // 0x5f4c
    int32_t * v25; // 0x5ef2
    __printf_chk(1, "    Value: [%.*s]\n", (int64_t)*v25, (char *)v48);
    uint32_t v50 = *v12; // 0x5f59
    v16 = v50;
    v17 = v49;
    if (v50 <= (int32_t)v49) {
        // break -> 0x5f68
        goto lab_0x5f68_2;
    }
    goto lab_0x5ecc;
  lab_0x5d30:
    // 0x5d30
    __printf_chk(1, "]  Code: [");
    if (*(int32_t *)v6 == 1) {
        // 0x6258
        __printf_chk(1, "UD:x%04x", (int32_t)*(int16_t *)(v6 + 22));
    } else {
        int64_t v51 = (int64_t)g16; // 0x5d4c
        int64_t v52 = v51 + 0xe0d0; // 0x5d55
        bool v53 = true;
        int32_t v54 = (int32_t)*(int16_t *)(v6 + 22);
        int64_t v55 = v51;
        int64_t v56; // 0x5d60
        while (v53 != (*(int32_t *)v55 == v54)) {
            // 0x5d60
            v56 = v55 + 132;
            if (v52 == v56) {
                if (v53) {
                    // 0x62ef
                    __printf_chk(1, "0x%04x", v54);
                    goto lab_0x5da9;
                } else {
                    goto lab_0x5da9;
                }
            }
            v55 = v56;
        }
        int64_t v57 = v55 + 132; // 0x5d8b
        __printf_chk(1, "%s", (char *)(v55 + 4));
        while (v52 != v57) {
            // 0x5d6c
            v53 = false;
            v54 = (int32_t)*(int16_t *)(v6 + 22);
            v55 = v57;
            while (v53 != (*(int32_t *)v55 == v54)) {
                // 0x5d60
                v56 = v55 + 132;
                if (v52 == v56) {
                    if (v53) {
                        // 0x62ef
                        __printf_chk(1, "0x%04x", v54);
                        goto lab_0x5da9;
                    } else {
                        goto lab_0x5da9;
                    }
                }
                v55 = v56;
            }
            // 0x5d79
            v57 = v55 + 132;
            __printf_chk(1, "%s", (char *)(v55 + 4));
        }
    }
    goto lab_0x5da9;
  lab_0x5da9:
    // 0x5da9
    puts("]");
    int32_t * v58 = (int32_t *)(v6 + 28); // 0x5db5
    if (*v58 >= 1) {
        int64_t v59 = 0; // 0x5ddc
        int64_t v60 = 0; // 0x5bd0
        int64_t v61 = *(int64_t *)(v6 + 32); // 0x5dd0
        v59 = v59 + 1 & 0xffffffff;
        __printf_chk(1, "    Name: %s\n", (char *)*(int64_t *)(v61 + v60));
        v60 += 16;
        while (v59 < (int64_t)*v58) {
            // 0x5dd0
            v61 = *(int64_t *)(v6 + 32);
            v59 = v59 + 1 & 0xffffffff;
            __printf_chk(1, "    Name: %s\n", (char *)*(int64_t *)(v61 + v60));
            v60 += 16;
        }
    }
    // 0x5df5
    v12 = (int32_t *)(v6 + 24);
    int32_t v62 = *v12; // 0x5df5
    if (v62 != 0) {
        int64_t * v24 = (int64_t *)(v6 + 40); // 0x5ecc
        v18 = v62;
        v19 = 0;
        v21 = 0;
        while (true) {
          lab_0x5ecc_2:
            // 0x5ecc
            v20 = v21;
            v14 = v19;
            int32_t v22 = v18;
            if (v22 == 1) {
                // 0x6010
                __printf_chk(1, "    ");
            } else {
                // 0x5edc
                __printf_chk(1, "    [%i/%u] ", v14, v22);
            }
            // 0x5ef2
            v23 = *v24 + v20;
            v25 = (int32_t *)(v23 + 8);
            __printf_chk(1, "Size: %i", (int64_t)*v25);
            uint16_t v26 = *v7; // 0x5f09
            if (v26 == 13) {
                // 0x6249
                putchar(10);
                goto lab_0x5eb8;
            } else {
                if (v26 < 14) {
                    switch (v26) {
                        case 3: {
                            // 0x620e
                            __printf_chk(1, "    Value: %i\n", (int64_t)*(int32_t *)*(int64_t *)v23);
                            goto lab_0x5eb8;
                        }
                        case 11: {
                            // 0x61ed
                            if (*(char *)*(int64_t *)*v24 == 0) {
                                // 0x62de
                                puts("    Value: False");
                            } else {
                                // 0x61fd
                                puts("    Value: True");
                            }
                            goto lab_0x5eb8;
                        }
                        case 2: {
                            // 0x622b
                            __printf_chk(1, "    Value: %hi\n", *(int16_t *)*(int64_t *)v23);
                            goto lab_0x5eb8;
                        }
                        default: {
                            goto lab_0x5f37;
                        }
                    }
                } else {
                    if (v26 == 64) {
                        // 0x6149
                        int64_t v27; // bp-102, 0x5bd0
                        function_1b20(*(int64_t *)v23, (int64_t)&v27);
                        __printf_chk(1, "    Value: ");
                        function_1ac0(v27, v5);
                        __printf_chk(1, " [HEX: ");
                        int64_t v28; // 0x5bd0
                        int64_t v29 = v28 + 1; // 0x61c1
                        int64_t * v30; // 0x614e
                        __printf_chk(1, " %02x", (int32_t)*(char *)(*v30 + v28));
                        v28 = v29;
                        while (v29 != 8) {
                            int64_t v31 = v28;
                            int64_t v32 = *v30; // 0x61b0
                            unsigned char v33 = *(char *)(v32 + v31); // 0x61bb
                            v29 = v31 + 1;
                            __printf_chk(1, " %02x", (int32_t)v33);
                            v28 = v29;
                        }
                        // 0x61d0
                        int64_t v34; // 0x6178
                        __printf_chk(1, "] (%llu)\n", v34);
                        goto lab_0x5eb8;
                    } else {
                        if (v26 < 65) {
                            if (v26 != 30) {
                                goto lab_0x5f37;
                            } else {
                                int64_t * str = (int64_t *)v23; // 0x603d
                                __printf_chk(1, "    Value: [%.*s]\n", (int64_t)*v25, (char *)*str);
                                if (strlen((char *)*str) == *v25 - 1) {
                                    goto lab_0x5eb8;
                                } else {
                                    // 0x606e
                                    __printf_chk(1, "Detected Hidden data: [");
                                    if (*v25 >= 1) {
                                        int16_t ** v35 = __ctype_b_loc(); // 0x6089
                                        int64_t v36 = 0; // 0x6098
                                        while (true) {
                                            int64_t v37 = v36;
                                            unsigned char c = *(char *)(*str + v37); // 0x60b5
                                            char v38 = *(char *)((int64_t)*v35 + 1 + 2 * (int64_t)c); // 0x60b9
                                            int64_t v39; // 0x5bd0
                                            if ((v38 & 64) != 0) {
                                                // 0x609a
                                                putchar((int32_t)c);
                                                int64_t v40 = v37 + 1; // 0x60a2
                                                v39 = v40;
                                                if ((v40 & 0xffffffff) >= (int64_t)*v25) {
                                                    // break -> 0x60dc
                                                    break;
                                                }
                                            } else {
                                                // 0x60c0
                                                putchar(46);
                                                int64_t v41 = v37 + 1; // 0x60ca
                                                v39 = v41;
                                                if ((v41 & 0xffffffff) >= (int64_t)*v25) {
                                                    // break -> 0x60dc
                                                    break;
                                                }
                                            }
                                            // 0x60af
                                            v36 = v39;
                                        }
                                    }
                                    // 0x60dc
                                    puts("]");
                                    goto lab_0x5eb8;
                                }
                            }
                        } else {
                            if (v26 == 72) {
                                // 0x60ed
                                __printf_chk(1, "    Value: ");
                                __printf_chk(1, "[HEX: ");
                                int64_t v42 = 0;
                                int64_t v43 = v42 + 1; // 0x6129
                                __printf_chk(1, " %02x", (int32_t)*(char *)(*(int64_t *)v23 + v42));
                                while (v43 != 16) {
                                    // 0x6118
                                    v42 = v43;
                                    v43 = v42 + 1;
                                    __printf_chk(1, " %02x", (int32_t)*(char *)(*(int64_t *)v23 + v42));
                                }
                                // 0x6138
                                puts("]");
                                goto lab_0x5eb8;
                            } else {
                                if (v26 != 258) {
                                    goto lab_0x5f37;
                                } else {
                                    // 0x5e43
                                    if ((int32_t)function_1a40(v23) != 1) {
                                        // 0x6274
                                        __printf_chk(1, "    Value: [");
                                        if (*v25 >= 1) {
                                            int16_t ** v44 = __ctype_b_loc(); // 0x6293
                                            int64_t v45 = 0; // 0x62a2
                                            unsigned char c2 = *(char *)(*(int64_t *)v23 + v45); // 0x62c7
                                            char v46 = *(char *)((int64_t)*v44 + 1 + 2 * (int64_t)c2); // 0x62cb
                                            if ((v46 & 64) != 0) {
                                                // 0x62a8
                                                putchar((int32_t)c2);
                                            } else {
                                                // 0x62d2
                                                putchar(46);
                                            }
                                            // 0x62b0
                                            v45++;
                                            while ((v45 & 0xffffffff) < (int64_t)*v25) {
                                                // 0x62c1
                                                c2 = *(char *)(*(int64_t *)v23 + v45);
                                                v46 = *(char *)((int64_t)*v44 + 1 + 2 * (int64_t)c2);
                                                if ((v46 & 64) != 0) {
                                                    // 0x62a8
                                                    putchar((int32_t)c2);
                                                } else {
                                                    // 0x62d2
                                                    putchar(46);
                                                }
                                                // 0x62b0
                                                v45++;
                                            }
                                        }
                                        // 0x60dc
                                        puts("]");
                                        goto lab_0x5eb8;
                                    } else {
                                        // 0x5e54
                                        __printf_chk(1, "    Detected Compressed RTF. ");
                                        puts("Decompressed text follows");
                                        puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
                                        int64_t v47; // bp-80, 0x5bd0
                                        int64_t str2 = function_1a90(v23, (int64_t)&v47); // 0x5e87
                                        if (str2 != 0) {
                                            // 0x5e96
                                            puts((char *)str2);
                                            free((int64_t *)str2);
                                        }
                                        // 0x5ea8
                                        puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
                                        goto lab_0x5eb8;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x5f68_2:;
    int64_t v63 = v2 + 1;
    v2 = v63;
    v3 += 48;
    if (v63 == (v4 & 0xffffffff)) {
        // break -> 0x5f84
        goto lab_0x5f84;
    }
    goto lab_0x5c20;
}

// Address range: 0x6410 - 0x6466
int64_t TNEFMapiProperties(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x6410
    if ((int32_t)function_19e0() < 0) {
        // 0x6453
        puts("ERROR Parsing MAPI block");
        // 0x644c
        return 0xffffffff;
    }
    // 0x6431
    if (*(int32_t *)(a1 + (int64_t)L"25") >= 3) {
        // 0x643c
        function_1b10(a1 + (int64_t)&g11);
    }
    // 0x644c
    return 0;
}

// Address range: 0x6468 - 0x6471
//int64_t _fini(void) {
//    // 0x6468
//    int64_t result; // 0x6468
//    return result;
//}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// void __cxa_finalize(void * d);
// void __gmon_start__(void);
// void * __memcpy_chk(void * dest, const void * src, size_t len, size_t dstlen);
// int __printf_chk(int flag, const char * restrict format, ...);
// int __snprintf_chk(char * restrict s, size_t n, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int putchar(int c);
// int puts(const char * s);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.5.0)
// Detected functions: 95
