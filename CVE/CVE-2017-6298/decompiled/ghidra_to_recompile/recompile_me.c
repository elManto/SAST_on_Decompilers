#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef unsigned long    qword;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;


long DAT_001065b2;
long TNEFList;
long DAT_00106852;
long DAT_001068e8;
long MPList;
long DAT_00316230;
long DAT_00106857;
long DAT_0010693a;
long __bss_start;
long PTR_LOOP_00308140;
long DAT_00316244;






byte * to_utf8(long param_1,long param_2);
ulong SwapDWord(long param_1,uint param_2);
undefined8 MAPISysTimetoDTR(ulong *param_1,ushort *param_2);
undefined8 TNEFGetHeader(long param_1,uint *param_2,uint *param_3);
ulong TNEFCheckForSignature(undefined4 param_1);
void __stack_chk_fail(void);

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

//struct _IO_FILE {
//    int _flags;
//    char * _IO_read_ptr;
//    char * _IO_read_end;
//    char * _IO_read_base;
//    char * _IO_write_base;
//    char * _IO_write_ptr;
//    char * _IO_write_end;
//    char * _IO_buf_base;
//    char * _IO_buf_end;
//    char * _IO_save_base;
//    char * _IO_backup_base;
//    char * _IO_save_end;
//    struct _IO_marker * _markers;
//    struct _IO_FILE * _chain;
//    int _fileno;
//    int _flags2;
//    __off_t _old_offset;
//    ushort _cur_column;
//    char _vtable_offset;
//    char _shortbuf[1];
//    _IO_lock_t * _lock;
//    __off64_t _offset;
//    void * __pad1;
//    void * __pad2;
//    void * __pad3;
//    void * __pad4;
//    size_t __pad5;
//    int _mode;
//    char _unused2[15];
//};
//
//struct _IO_marker {
//    struct _IO_marker * _next;
//    struct _IO_FILE * _sbuf;
//    int _pos;
//};
//
//typedef struct _IO_FILE FILE;

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef enum Elf_ProgramHeaderType {
    PT_DYNAMIC=2,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_RELRO=1685382482,
    PT_GNU_STACK=1685382481,
    PT_INTERP=3,
    PT_LOAD=1,
    PT_NOTE=4,
    PT_NULL=0,
    PT_PHDR=6,
    PT_SHLIB=5,
    PT_TLS=7
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_AUDIT=1879047932,
    DT_AUXILIARY=2147483645,
    DT_BIND_NOW=24,
    DT_CHECKSUM=1879047672,
    DT_CONFIG=1879047930,
    DT_DEBUG=21,
    DT_DEPAUDIT=1879047931,
    DT_ENCODING=32,
    DT_FEATURE_1=1879047676,
    DT_FILTER=2147483647,
    DT_FINI=13,
    DT_FINI_ARRAY=26,
    DT_FINI_ARRAYSZ=28,
    DT_FLAGS=30,
    DT_FLAGS_1=1879048187,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_HASH=1879047925,
    DT_GNU_LIBLIST=1879047929,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_GNU_PRELINKED=1879047669,
    DT_HASH=4,
    DT_INIT=12,
    DT_INIT_ARRAY=25,
    DT_INIT_ARRAYSZ=27,
    DT_JMPREL=23,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_MOVETAB=1879047934,
    DT_NEEDED=1,
    DT_NULL=0,
    DT_PLTGOT=3,
    DT_PLTPAD=1879047933,
    DT_PLTPADSZ=1879047673,
    DT_PLTREL=20,
    DT_PLTRELSZ=2,
    DT_POSFLAG_1=1879047677,
    DT_PREINIT_ARRAYSZ=33,
    DT_REL=17,
    DT_RELA=7,
    DT_RELACOUNT=1879048185,
    DT_RELAENT=9,
    DT_RELASZ=8,
    DT_RELCOUNT=1879048186,
    DT_RELENT=19,
    DT_RELSZ=18,
    DT_RPATH=15,
    DT_RUNPATH=29,
    DT_SONAME=14,
    DT_STRSZ=10,
    DT_STRTAB=5,
    DT_SYMBOLIC=16,
    DT_SYMENT=11,
    DT_SYMINENT=1879047679,
    DT_SYMINFO=1879047935,
    DT_SYMINSZ=1879047678,
    DT_SYMTAB=6,
    DT_TEXTREL=22,
    DT_TLSDESC_GOT=1879047927,
    DT_TLSDESC_PLT=1879047926,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_VERSYM=1879048176
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_CHECKSUM=1879048184,
    SHT_DYNAMIC=6,
    SHT_DYNSYM=11,
    SHT_FINI_ARRAY=15,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191,
    SHT_GROUP=17,
    SHT_HASH=5,
    SHT_INIT_ARRAY=14,
    SHT_NOBITS=8,
    SHT_NOTE=7,
    SHT_NULL=0,
    SHT_PREINIT_ARRAY=16,
    SHT_PROGBITS=1,
    SHT_REL=9,
    SHT_RELA=4,
    SHT_SHLIB=10,
    SHT_STRTAB=3,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_syminfo=1879048188,
    SHT_SYMTAB=2,
    SHT_SYMTAB_SHNDX=18
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_pad[9];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};




//int _init(EVP_PKEY_CTX *ctx)
//
//{
//  int iVar1;
//  
//  iVar1 = __gmon_start__();
//  return iVar1;
//}
//


undefined8 TNEFRawRead(long param_1,byte *param_2,undefined8 param_3,undefined2 *param_4)

{
  byte *pbVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  
  uVar3 = (uint)param_3;
  uVar4 = (**(void*(*)())(param_1 + 0x298))(param_1 + 0x290,1,param_3,param_2);
  if (uVar3 <= uVar4) {
    if ((param_4 != (undefined2 *)0x0) && (*param_4 = 0, uVar3 != 0)) {
      pbVar1 = param_2 + (ulong)(uVar3 - 1) + 1;
      iVar5 = 0;
      do {
        bVar2 = *param_2;
        param_2 = param_2 + 1;
        iVar5 = iVar5 + (uint)bVar2;
        *param_4 = (short)iVar5;
      } while (param_2 != pbVar1);
    }
    return 0;
  }
  if (0 < *(int *)(param_1 + 0x28c)) {
    puts("ERROR: Error reading data");
    return 0xfffffffd;
  }
  return 0xfffffffd;
}



//void snprintf(void)
//
//{
//  snprintf();
//  return;
//}
//


// WARNING: Unknown calling convention yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



long SwapDDWord(long param_1,uint param_2)

{
  long lVar1;
  long lVar2;
  long in_FS_OFFSET;
  long lStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  lStack24 = 0;
  if (8 < param_2) {
    param_2 = 8;
  }
  lVar1 = 0;
  lVar2 = lVar1;
  if (param_2 != 0) {
    do {
      *(undefined *)((long)&lStack24 + lVar1) = *(undefined *)(param_1 + lVar1);
      lVar1 = lVar1 + 1;
      lVar2 = lStack24;
    } while ((int)lVar1 < (int)param_2);
  }
  if (lStack16 != *(long *)(in_FS_OFFSET + 0x28)) {
    lStack24 = lVar2;
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar2;
}



// WARNING: Unknown calling convention yet parameter storage is locked





ulong SwapWord(byte *param_1,uint param_2)

{
  ulong uVar1;
  long in_FS_OFFSET;
  
  uVar1 = 0;
  if (param_2 != 0) {
    uVar1 = (ulong)*param_1;
    if (1 < param_2) {
      uVar1 = (ulong)CONCAT11(param_1[1],*param_1);
    }
  }
  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)
//
//{
//  size_t sVar1;
//  
//  sVar1 = fread(__ptr,__size,__n,__stream);
//  return sVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int fclose(FILE *__stream)
//
//{
//  int iVar1;
//  
//  iVar1 = fclose(__stream);
//  return iVar1;
//}



ulong TNEFFillMapi(long param_1,long param_2,ulong param_3,uint *param_4)

{
  undefined auVar1 [16];
  char cVar2;
  void *__src;
  undefined2 uVar3;
  int iVar4;
  uint uVar5;
  undefined4 uVar6;
  undefined *puVar7;
  ulong uVar8;
  undefined4 *puVar9;
  void *__dest;
  long lVar10;
  ulong uVar11;
  uint uVar12;
  undefined8 uVar13;
  uint uVar14;
  size_t __nmemb;
  long lVar15;
  undefined *puVar16;
  undefined *__src_00;
  undefined *puVar17;
  undefined8 uVar18;
  uint uVar19;
  void **ppvVar20;
  undefined4 *puVar21;
  long in_FS_OFFSET;
  bool bVar22;
  uint uStack128;
  undefined2 uStack78;
  undefined4 uStack76;
  undefined8 uStack72;
  long lStack64;
  
  puVar7 = (undefined *)(param_3 & 0xffffffff);
  lStack64 = *(long *)(in_FS_OFFSET + 0x28);
  if (puVar7 < (undefined *)0x4) {
    uVar13 = 0x1aa;
LAB_0010386f:
    uStack128 = 0xffffffff;
    printf(1,"Corrupted file detected at %s : %i\n","ytnef.c",uVar13);
  }
  else {
    uVar8 = SwapDWord(param_2,4);
    uVar11 = uVar8 & 0xffffffff;
    if ((int)uVar8 - 1U < 1000) {
      puVar21 = (undefined4 *)calloc((long)(int)(uint)uVar11,0x30);
      *(undefined4 **)(param_4 + 2) = puVar21;
      if (puVar21 == (undefined4 *)0x0) {
        uVar13 = 0x1b0;
LAB_00103992:
        uStack128 = 0xffffffff;
        printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar13);
      }
      else {
        uVar19 = 0;
        *param_4 = (uint)uVar11;
        uStack128 = 0xffffffff;
        puVar16 = (undefined *)(param_2 + 4);
        do {
          if (uStack128 == 0xffffffff) {
            if (puVar7 < puVar16 + (4 - param_2)) {
              uVar13 = 0x1b6;
            }
            else {
              __src_00 = puVar16 + 4;
              iVar4 = SwapDWord(puVar16,4);
              puVar21[5] = iVar4;
              *puVar21 = 0;
              puVar21[7] = 0;
              if (-1 < iVar4) {
LAB_0010320b:
                if (2 < *(int *)(param_1 + 0x28c)) {
                  printf(1,"DEBUG(%i/%i):",3);
                  printf(1,"Type id = %04x, Prop id = %04x",(ulong)(ushort)puVar21[5]);
                  putchar(10);
                }
                uVar12 = puVar21[5];
                if ((uVar12 & 0x1000) == 0) {
                  __nmemb = 1;
                  iVar4 = 1;
                  puVar16 = __src_00;
                  uVar12 = uStack128;
                }
                else {
                  puVar21[5] = uVar12 & 0xffff0000 | (uVar12 & 0xffff) - 0x1000;
                  if (puVar7 < __src_00 + (4 - param_2)) {
                    uVar13 = 0x1e8;
                    goto LAB_001037d9;
                  }
                  uVar8 = SwapDWord(__src_00,4);
                  uVar11 = uVar8 & 0xffffffff;
                  iVar4 = (int)uVar11;
                  if (999 < (int)uVar8 - 1U) {
                    uVar18 = 1000;
                    uVar13 = 0x1ed;
LAB_0010380b:
                    printf(1,
                                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                                 ,uVar11,"ytnef.c",uVar13,uVar18);
                    goto LAB_00103495;
                  }
                  __nmemb = SEXT48(iVar4);
                  puVar16 = __src_00 + 4;
                  uVar12 = 0;
                }
                ppvVar20 = (void **)calloc(__nmemb,0x10);
                *(void ***)(puVar21 + 10) = ppvVar20;
                if (ppvVar20 != (void **)0x0) {
                  puVar21[6] = iVar4;
                  uStack128 = uVar12;
                  goto LAB_00102ef3;
                }
                printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x1ef);
                goto LAB_00103495;
              }
              if ((long)(__src_00 + (0xf - param_2)) < (long)puVar7) {
                    // WARNING: Load size is inaccurate
                auVar1[0] = *(undefined *)(puVar16 + 4);
                if (puVar16 + 0x14 + (4 - param_2) <= puVar7) {
                  __src_00 = puVar16 + 0x18;
                  uVar8 = SwapDWord(SUB168(auVar1,0),puVar16 + 0x14);
                  iVar4 = (int)uVar8;
                  if (iVar4 == 0) {
                    if (puVar7 < __src_00 + (4 - param_2)) {
                      uVar13 = 0x1dc;
                      goto LAB_001037d9;
                    }
                    uVar3 = SwapDWord(__src_00,4);
                    *(undefined2 *)((long)puVar21 + 0x16) = uVar3;
                    __src_00 = puVar16 + 0x1c;
                  }
                  else {
                    if (999 < iVar4 - 1U) {
                      printf(1,
                                   "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                                   ,uVar8 & 0xffffffff,"ytnef.c",0x1c7,1000);
                      goto LAB_00103495;
                    }
                    __dest = calloc(uVar8 & 0xffffffff,0x10);
                    *(void **)(puVar21 + 8) = __dest;
                    if (__dest == (void *)0x0) {
                      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x1c9);
                      goto LAB_00103495;
                    }
                    lVar10 = (ulong)(iVar4 - 1U) << 4;
                    puVar21[7] = iVar4;
                    do {
                      uStack128 = 0xffffffff;
                      if (puVar7 < __src_00 + (4 - param_2)) {
                        uVar13 = 0x1cc;
                        goto LAB_001037d9;
                      }
                      uVar8 = SwapDWord(__src_00,4);
                      uVar11 = uVar8 & 0xffffffff;
                      uVar12 = (uint)uVar11;
                      if (99 < (int)uVar8 - 1U) {
                        uVar18 = 100;
                        uVar13 = 0x1cf;
                        goto LAB_0010380b;
                      }
                      lVar15 = *(long *)(puVar21 + 8);
                      __dest = calloc((ulong)(uVar12 + 1),1);
                      *(void **)(lVar15 + lVar10) = __dest;
                      if (__dest == (void *)0x0) {
                        printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x1d1);
                        goto LAB_00103495;
                      }
                      *(uint *)((void **)(lVar15 + lVar10) + 1) = uVar12;
                      if ((long)puVar7 < (long)(__src_00 + 4 + (uVar11 - param_2))) {
                        uVar13 = 0x1d3;
                        goto LAB_001037d9;
                      }
                      if (uVar12 >> 1 != 0) {
                        lVar15 = 0;
                        while( true ) {
                          *(undefined *)((long)__dest + lVar15) = __src_00[lVar15 * 2 + 4];
                          lVar15 = lVar15 + 1;
                          if ((ulong)((uVar12 >> 1) - 1) + 1 == lVar15) break;
                          __dest = *(void **)(*(long *)(puVar21 + 8) + lVar10);
                        }
                      }
                      if ((uVar8 & 3) != 0) {
                        uVar11 = (ulong)((uVar12 + 4) - (uVar12 & 3));
                      }
                      lVar10 = lVar10 + -0x10;
                      __src_00 = __src_00 + 4 + uVar11;
                    } while (lVar10 != -0x10);
                  }
                  *puVar21 = 1;
                  goto LAB_0010320b;
                }
                uVar13 = 0x1c3;
              }
              else {
                uVar13 = 0x1bf;
              }
            }
LAB_001037d9:
            printf(1,"Corrupted file detected at %s : %i\n","ytnef.c",uVar13);
            goto LAB_00103495;
          }
          uVar19 = uVar19 - 1;
          ppvVar20 = (void **)((long)(int)(uStack128 + 1) * 0x10 + *(long *)(puVar21 + 10));
          uStack128 = uStack128 + 1;
LAB_00102ef3:
          uVar12 = puVar21[5];
          uVar5 = uVar12 & 0xffff;
          if (uVar5 < 0xc) {
            if (9 < uVar5) {
LAB_001034ce:
              *(undefined4 *)(ppvVar20 + 1) = 4;
              __dest = calloc(4,1);
              *ppvVar20 = __dest;
              if (__dest == (void *)0x0) {
                uVar13 = 0x235;
                goto LAB_00103909;
              }
              if ((long)(puVar16 + (3 - param_2)) < (long)puVar7) {
                __src_00 = puVar16 + 4;
                uStack76 = SwapDWord(puVar16,4);
                memcpy(*ppvVar20,&uStack76,(long)*(int *)(ppvVar20 + 1));
                uVar12 = puVar21[5];
                goto LAB_00102f64;
              }
              uVar13 = 0x236;
              goto LAB_0010386f;
            }
            if (4 < uVar5) {
              if (uVar5 == 5) goto LAB_0010332f;
              if (7 < uVar5) goto LAB_00103484;
              goto LAB_001034ce;
            }
            if (2 < uVar5) goto LAB_001034ce;
            if (uVar5 != 2) goto LAB_00103484;

            __dest = calloc((*(undefined4 *)(ppvVar20 + 1)),2);
            *ppvVar20 = __dest;
            uStack78 = SwapWord(puVar16,2);
            __src_00 = puVar16 + 4;
            memcpy(*ppvVar20,&uStack78,(long)*(int *)(ppvVar20 + 1));
            uVar12 = (uint)puVar21[5] >> 0x10;
            bVar22 = uVar12 == 0x49;
            if (!bVar22) goto LAB_00102f70;
LAB_00103070:
            uVar12 = *(uint *)(param_1 + 0x28c);
            if ((int)uVar12 < 3) goto LAB_00103084;
LAB_001032b0:
            printf(1,"DEBUG(%i/%i): %s\n",3,(ulong)uVar12,"Got a Subject");
            if (*(int *)(param_1 + 0x28) == 0) {
              if (2 < (int)*(uint *)(param_1 + 0x28c)) {
                printf(1,"DEBUG(%i/%i): %s\n",3,(ulong)*(uint *)(param_1 + 0x28c),
                             "Assigning a Subject");
              }
              goto LAB_00103094;
            }
          }
          else {
            if (uVar5 < 0x20) {
              if ((0x1d < uVar5) || (uVar5 == 0xd)) goto LAB_001033a0;
              if (uVar5 != 0x14) goto LAB_00103484;
LAB_0010332f:
              *(undefined4 *)(ppvVar20 + 1) = 8;
              __dest = calloc(8,1);
              *ppvVar20 = __dest;
              if (__dest == (void *)0x0) {
                uVar13 = 0x241;
                goto LAB_00103909;
              }
              if ((long)puVar7 <= (long)(puVar16 + (7 - param_2))) {
                uVar13 = 0x242;
                goto LAB_0010386f;
              }
              __src_00 = puVar16 + 8;
              uStack72 = SwapDDWord(puVar16,8);
              memcpy(*ppvVar20,&uStack72,(long)*(int *)(ppvVar20 + 1));
              uVar12 = puVar21[5];
            }
            else {
              if (uVar5 == 0x48) {
                *(undefined4 *)(ppvVar20 + 1) = 0x10;
                puVar9 = (undefined4 *)calloc(0x10,1);
                *(undefined4 **)ppvVar20 = puVar9;
                if (puVar9 != (undefined4 *)0x0) {
                  if ((long)(puVar16 + (0x10 - param_2)) <= (long)puVar7) {
                    // WARNING: Load size is inaccurate
                    auVar1[0] = *(undefined *)puVar16;
                    __src_00 = puVar16 + 0x10;
                    goto LAB_00102f64;
                  }
                  uVar13 = 0x24c;
                  goto LAB_0010386f;
                }
                uVar13 = 0x24b;
LAB_00103909:
                uStack128 = 0xffffffff;
                printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar13);
                goto LAB_00103495;
              }
              if (uVar5 != 0x102) {
                if (uVar5 == 0x40) goto LAB_0010332f;
LAB_00103484:
                uStack128 = 0xffffffff;
                puts("Bad file");
                goto LAB_00103495;
              }
LAB_001033a0:
              __src_00 = puVar16 + (4 - param_2);
              puVar17 = puVar16;
              if (uStack128 == 0xffffffff) {
                if (puVar7 < __src_00) {
                  uVar13 = 0x1ff;
                  goto LAB_001037d9;
                }
                puVar17 = puVar16 + 4;
                uVar6 = SwapDWord(puVar16,4);
                *(undefined4 *)(ppvVar20 + 1) = uVar6;
                __src_00 = puVar17 + (4 - param_2);
              }
              if (puVar7 < __src_00) {
                uVar13 = 0x204;
                goto LAB_0010386f;
              }
              __src_00 = puVar17 + 4;
              uVar11 = SwapDWord(puVar17,4);
              uVar5 = (uint)uVar11;
              *(uint *)(ppvVar20 + 1) = uVar5;
              if (uVar5 == 0) {
                uVar12 = puVar21[5];
                *ppvVar20 = (void *)0x0;
                uVar14 = 0;
              }
              else {
                __nmemb = SEXT48((int)uVar5);
                if ((long)puVar7 < (long)(__src_00 + (__nmemb - param_2))) {
                  uVar13 = 0x20a;
                  goto LAB_0010386f;
                }
                if (99999 < uVar5 - 1) {
                  uVar18 = 100000;
                  uVar13 = 0x20b;
                  uVar11 = uVar11 & 0xffffffff;
                  goto LAB_001038a8;
                }
                uVar12 = puVar21[5];
                if ((short)uVar12 == 0x1f) {
                  __dest = (void *)to_utf8(__nmemb,__src_00);
                  *ppvVar20 = __dest;
                  if (__dest == (void *)0x0) goto LAB_00102fe9;
                  uVar12 = puVar21[5];
                }
                else {
                  __dest = calloc(__nmemb,1);
                  *ppvVar20 = __dest;
                  if (__dest == (void *)0x0) {
                    uVar13 = 0x212;
                    goto LAB_00103909;
                  }
                  memcpy(__dest,__src_00,__nmemb);
                }
                uVar5 = *(uint *)(ppvVar20 + 1);
                uVar14 = uVar5 & 3;
                if (uVar14 != 0) {
                  uVar14 = 4 - uVar14;
                }
              }
              __src_00 = __src_00 + (uVar5 + uVar14);
            }
LAB_00102f64:
            uVar12 = uVar12 >> 0x10;
            bVar22 = uVar12 == 0x49;
            if (bVar22) goto LAB_00103070;
LAB_00102f70:
            if (0x48 < uVar12 && !bVar22) {
              if ((uVar12 == 0x70) || (uVar12 == 0xe1d)) goto LAB_00103070;
              goto LAB_00102f8b;
            }
            if (1 < uVar12 - 0x37) goto LAB_00102f8b;
            uVar12 = *(uint *)(param_1 + 0x28c);
            if (2 < (int)uVar12) goto LAB_001032b0;
LAB_00103084:
            if (*(int *)(param_1 + 0x28) == 0) {
LAB_00103094:
              uVar12 = *(uint *)(ppvVar20 + 1);
              uVar11 = (ulong)uVar12;
              if (99 < uVar12 - 1) {
                uVar18 = 100;
                uVar13 = 0x25f;
                goto LAB_001038a8;
              }
              __dest = calloc((long)(int)(uVar12 + 1),1);
              *(void **)(param_1 + 0x20) = __dest;
              if (__dest == (void *)0x0) {
                uVar13 = 0x261;
                goto LAB_00103992;
              }
              __src = *ppvVar20;
              *(uint *)(param_1 + 0x28) = uVar12;
              memcpy(__dest,__src,(long)*(int *)(ppvVar20 + 1));
              lVar10 = 0;
              while( true ) {
                cVar2 = *(char *)((long)__dest + lVar10);
                if (((cVar2 == '/') || (cVar2 == '\\')) || (cVar2 == '\0')) {
                  *(char *)((long)__dest + lVar10) = '_';
                }
                iVar4 = (int)lVar10;
                lVar10 = lVar10 + 1;
                if (*(int *)(param_1 + 0x28) == iVar4 + 1) break;
                __dest = *(void **)(param_1 + 0x20);
              }
            }
          }
LAB_00102f8b:
          if ((puVar21[6] - 1 == uStack128) || (uStack128 == 0xffffffff)) {
            puVar21 = puVar21 + 0xc;
            uStack128 = 0xffffffff;
          }
          uVar19 = uVar19 + 1;
          puVar16 = __src_00;
        } while (uVar19 <= *param_4 && *param_4 != uVar19);
        __src_00 = __src_00 + -param_2;
        if ((long)__src_00 < (long)puVar7) {
          if (0 < *(int *)(param_1 + 0x28c)) {
            puts("ERROR DURING MAPI READ");
            printf(1,"Read %td bytes, Expected %u bytes\n",__src_00,puVar7);
            printf(1,"%td bytes missing\n",puVar7 + -(long)__src_00);
          }
        }
        else {
          uStack128 = 0;
          if ((long)__src_00 <= (long)puVar7) goto LAB_00103495;
          if (0 < *(int *)(param_1 + 0x28c)) {
            uStack128 = 0xffffffff;
            puts("ERROR DURING MAPI READ");
            printf(1,"Read %td bytes, Expected %u bytes\n",__src_00,puVar7);
            printf(1,"%li bytes extra\n",__src_00 + -(long)puVar7);
            goto LAB_00103495;
          }
        }
LAB_00102fe9:
        uStack128 = 0xffffffff;
      }
    }
    else {
      uVar18 = 1000;
      uVar13 = 0x1ae;
LAB_001038a8:
      uStack128 = 0xffffffff;
      printf(1,
                   "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                   ,uVar11,"ytnef.c",uVar13,uVar18);
    }
  }
LAB_00103495:
  if (lStack64 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (ulong)uStack128;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void TNEFFreeMapiProps(uint *param_1)

{
  uint *puVar1;
  int *piVar2;
  long lVar3;
  uint uVar4;
  void *__ptr;
  long lVar5;
  uint uVar6;
  int iVar7;
  long lVar8;
  
  lVar8 = 0;
  uVar4 = 0;
  if (*param_1 != 0) {
    do {
      lVar3 = *(long *)(param_1 + 2);
      lVar5 = 0;
      uVar6 = 0;
      __ptr = *(void **)(lVar3 + lVar8 + 0x28);
      if (*(int *)(lVar3 + lVar8 + 0x18) != 0) {
        do {
          while (*(int *)((void **)((long)__ptr + lVar5) + 1) < 1) {
            uVar6 = uVar6 + 1;
            lVar5 = lVar5 + 0x10;
            puVar1 = (uint *)(lVar3 + lVar8 + 0x18);
            __ptr = *(void **)(lVar3 + lVar8 + 0x28);
            if (*puVar1 < uVar6 || *puVar1 == uVar6) goto LAB_0010495d;
          }
          uVar6 = uVar6 + 1;
          free(*(void **)((long)__ptr + lVar5));
          lVar3 = *(long *)(param_1 + 2);
          __ptr = *(void **)(lVar3 + lVar8 + 0x28);
          *(undefined4 *)((long)__ptr + lVar5 + 8) = 0;
          lVar5 = lVar5 + 0x10;
          puVar1 = (uint *)(lVar3 + lVar8 + 0x18);
        } while (uVar6 <= *puVar1 && *puVar1 != uVar6);
      }
LAB_0010495d:
      free(__ptr);
      lVar3 = *(long *)(param_1 + 2);
      __ptr = *(void **)(lVar3 + lVar8 + 0x20);
      if (0 < *(int *)(lVar3 + lVar8 + 0x1c)) {
        lVar5 = 0;
        iVar7 = 0;
        do {
          while (*(int *)((void **)((long)__ptr + lVar5) + 1) < 1) {
            iVar7 = iVar7 + 1;
            lVar5 = lVar5 + 0x10;
            piVar2 = (int *)(lVar3 + lVar8 + 0x1c);
            __ptr = *(void **)(lVar3 + lVar8 + 0x20);
            if (*piVar2 == iVar7 || *piVar2 < iVar7) goto LAB_001049cb;
          }
          iVar7 = iVar7 + 1;
          free(*(void **)((long)__ptr + lVar5));
          lVar3 = *(long *)(param_1 + 2);
          __ptr = *(void **)(lVar3 + lVar8 + 0x20);
          *(undefined4 *)((long)__ptr + lVar5 + 8) = 0;
          lVar5 = lVar5 + 0x10;
          piVar2 = (int *)(lVar3 + lVar8 + 0x1c);
        } while (*piVar2 != iVar7 && iVar7 <= *piVar2);
      }
LAB_001049cb:
      free(__ptr);
      uVar4 = uVar4 + 1;
      lVar8 = lVar8 + 0x30;
    } while (uVar4 <= *param_1 && *param_1 != uVar4);
  }
  free(*(void **)(param_1 + 2));
  *param_1 = 0;
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFGetKey(long param_1,ushort *param_2)

{
  ushort uVar1;
  int iVar2;
  
  iVar2 = (**(void*(*)())(param_1 + 0x298))(param_1 + 0x290,2,1);
  if (0 < iVar2) {
    uVar1 = SwapWord(param_2,2);
    iVar2 = *(int *)(param_1 + 0x28c);
    *param_2 = uVar1;
    if (1 < iVar2) {
      printf(1,"DEBUG(%i/%i):",2);
      printf(1,"Key = 0x%X",(ulong)*param_2);
      putchar(10);
      if (1 < *(int *)(param_1 + 0x28c)) {
        printf(1,"DEBUG(%i/%i):",2);
        printf(1,"Key = %i",(ulong)*param_2);
        putchar(10);
      }
    }
    return 0;
  }
  if (0 < *(int *)(param_1 + 0x28c)) {
    puts("Error reading Key");
    return 0xfffffffd;
  }
  return 0xfffffffd;
}



void TNEFInitMapi(undefined4 *param_1)

{
  *param_1 = 0;
  *(undefined8 *)(param_1 + 2) = 0;
  return;
}



ulong IsCompressedRTF(long *param_1)

{
  int iVar1;
  
  if (0xb < *(uint *)(param_1 + 1)) {
    iVar1 = SwapDWord(*param_1 + 8,4);
    return (ulong)(iVar1 == 0x75465a4c || iVar1 == 0x414c454d);
  }
  return 0;
}



byte * to_utf8(long param_1,long param_2)

{
  long lVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  byte *pbVar5;
  uint uVar6;
  byte *pbVar7;
  byte *pbVar8;
  int iVar9;
  int iVar10;
  
  pbVar5 = (byte *)malloc(((ulong)(param_1 * 3) >> 1) + 1);
  pbVar7 = pbVar5;
  if (param_1 != 1) {
    lVar1 = param_2 + 2 + (param_1 - 2U & 0xfffffffffffffffe);
    iVar10 = 0;
    do {
      while( true ) {
        uVar4 = SwapWord(param_2,2);
        iVar9 = iVar10 + 1;
        pbVar8 = pbVar5 + iVar10;
        pbVar7 = pbVar5 + iVar9;
        if (0x7f < (uVar4 & 0xffff)) break;
        *pbVar8 = (byte)uVar4 & 0x7f;
LAB_00102d78:
        param_2 = param_2 + 2;
        iVar10 = iVar9;
        if (param_2 == lVar1) goto LAB_00102ddc;
      }
      uVar6 = uVar4 & 0xffff;
      bVar3 = (byte)uVar4 & 0x3f | 0x80;
      bVar2 = (byte)(uVar6 >> 6);
      if (0x7fe < uVar6) {
        iVar9 = iVar10 + 3;
        *pbVar8 = (byte)(uVar6 >> 0xc) | 0xe0;
        *pbVar7 = bVar2 & 0x3f | 0x80;
        pbVar5[iVar10 + 2] = bVar3;
        pbVar7 = pbVar5 + iVar9;
        goto LAB_00102d78;
      }
      param_2 = param_2 + 2;
      *pbVar8 = bVar2 | 0xc0;
      *pbVar7 = bVar3;
      pbVar7 = pbVar5 + (iVar10 + 2);
      iVar10 = iVar10 + 2;
    } while (param_2 != lVar1);
  }
LAB_00102ddc:
  *pbVar7 = 0;
  return pbVar5;
}



// WARNING: Unknown calling convention yet parameter storage is locked
//
//void * calloc(size_t __nmemb,size_t __size)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = calloc(__nmemb,__size);
//  return pvVar1;
//}
//
//
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void * memcpy(void *__dest,void *__src,size_t __n)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = memcpy(__dest,__src,__n);
//  return pvVar1;
//}



void * DecompressRTF(long *param_1,uint *param_2)

{
  uint uVar1;
  undefined auVar2 [16];
  byte bVar3;
  uint uVar4;
  int iVar5;
  long lVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  undefined4 *__ptr;
  undefined4 *__ptr_00;
  void *__dest;
  undefined8 uVar11;
  ulong uVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  uint uVar16;
  ulong uVar17;
  ulong __nmemb;
  
  __ptr = (undefined4 *)calloc(0xd0,1);
  uVar11 = 0x5f6;
  if (__ptr == (undefined4 *)0x0) {
LAB_00105b7e:
    printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar11);
    return (void *)0;
  }
  iVar5 = *(int *)(param_1 + 1);
  lVar6 = *param_1;
  *__ptr = 0x74725c7b;
  __ptr[1] = 0x615c3166;
  __ptr[2] = 0x74725c7b;
  __ptr[3] = 0x615c3166;
  __ptr[4] = 0x66666564;
  __ptr[5] = 0x65645c30;
  __ptr[6] = 0x66666564;
  __ptr[7] = 0x65645c30;
  __ptr[8] = 0x6e6f665c;
  __ptr[9] = 0x6c627474;
  __ptr[10] = 0x6e6f665c;
  __ptr[0xb] = 0x6c627474;
  __ptr[0xc] = 0x206c696e;
  __ptr[0xd] = 0x6f72665c;
  __ptr[0xe] = 0x206c696e;
  __ptr[0xf] = 0x6f72665c;
  __ptr[0x10] = 0x20737369;
  __ptr[0x11] = 0x6f6d665c;
  __ptr[0x12] = 0x20737369;
  __ptr[0x13] = 0x6f6d665c;
  __ptr[0x14] = 0x70697263;
  __ptr[0x15] = 0x665c2074;
  __ptr[0x16] = 0x70697263;
  __ptr[0x17] = 0x665c2074;
  __ptr[0x18] = 0x6e615320;
  __ptr[0x19] = 0x65532073;
  __ptr[0x1a] = 0x6e615320;
  __ptr[0x1b] = 0x65532073;
  __ptr[0x1c] = 0x6972416c;
  __ptr[0x1d] = 0x69546c61;
  __ptr[0x1e] = 0x6972416c;
  __ptr[0x1f] = 0x69546c61;
  __ptr[0x20] = 0x616d6f52;
  __ptr[0x21] = 0x756f436e;
  __ptr[0x22] = 0x616d6f52;
  __ptr[0x23] = 0x756f436e;
  __ptr[0x24] = 0x74726f6c;
  __ptr[0x25] = 0x725c6c62;
  __ptr[0x26] = 0x74726f6c;
  __ptr[0x27] = 0x725c6c62;
  __ptr[0x28] = 0x625c306e;
  __ptr[0x29] = 0x3065756c;
  __ptr[0x2a] = 0x625c306e;
  __ptr[0x2b] = 0x3065756c;
  __ptr[0x2c] = 0x64726170;
  __ptr[0x2d] = 0x616c705c;
  __ptr[0x2e] = 0x64726170;
  __ptr[0x2f] = 0x616c705c;
  __ptr[0x32] = 0x6261745c;
  *(undefined *)((long)__ptr + 0xce) = 0x78;
  *(undefined8 *)(__ptr + 0x30) = 0x755c695c625c3032;
  *(undefined2 *)(__ptr + 0x33) = 0x745c;
  if (iVar5 < 0x14) {
    puts("File too small");
    return (void *)0;
  }
  uVar7 = SwapDWord(0x616c705c64726170,lVar6);
  uVar8 = SwapDWord(lVar6 + 4,4);
  __nmemb = (ulong)uVar8;
  uVar9 = SwapDWord(lVar6 + 8,4);
  uVar4 = *(uint *)(param_1 + 1);
  if (uVar4 - 4 != uVar7) {
    printf(1," Size Mismatch: %u != %i\n",(ulong)uVar7);
    free(__ptr);
    return (void *)0;
  }
  if (uVar9 == 0x414c454d) {
    __dest = calloc(__nmemb,1);
    uVar11 = 0x612;
    if (__dest != (void *)0x0) goto LAB_00105aea;
  }
  else {
    if (uVar9 != 0x75465a4c) {
      printf(1,"Unknown compression type (magic number %x)\n",(ulong)uVar9);
LAB_00105aea:
      free(__ptr);
      return (void *)0;
    }
    if (0x7fffffff - uVar8 < 0xd0) {
      puts("Corrupted file");
      return (void *)0;
    }
    uVar7 = uVar8 + 0xcf;
    __ptr_00 = (undefined4 *)calloc((ulong)uVar7,1);
    if (__ptr_00 == (undefined4 *)0x0) {
      uVar11 = 0x61e;
      goto LAB_00105b7e;
    }
                    // WARNING: Load size is inaccurate
    auVar2[0] = *(undefined *)__ptr;
                    // WARNING: Load size is inaccurate
    auVar2[1] = *(undefined *)(__ptr + 4);
                    // WARNING: Load size is inaccurate
    auVar2[2] = *(undefined *)(__ptr + 8);
                    // WARNING: Load size is inaccurate
    auVar2[3] = *(undefined *)(__ptr + 0xc);
                    // WARNING: Load size is inaccurate
    auVar2[4] = *(undefined *)(__ptr + 0x10);
                    // WARNING: Load size is inaccurate
    auVar2[5] = *(undefined *)(__ptr + 0x14);
                    // WARNING: Load size is inaccurate
    auVar2[6] = *(undefined *)(__ptr + 0x18);
                    // WARNING: Load size is inaccurate
    auVar2[7] = *(undefined *)(__ptr + 0x1c);
                    // WARNING: Load size is inaccurate
    auVar2[8] = *(undefined *)(__ptr + 0x20);
                    // WARNING: Load size is inaccurate
    auVar2[9] = *(undefined *)(__ptr + 0x24);
                    // WARNING: Load size is inaccurate
    auVar2[10] = *(undefined *)(__ptr + 0x28);
                    // WARNING: Load size is inaccurate

    *(undefined8 *)(__ptr_00 + 0x30) = *(undefined8 *)(__ptr + 0x30);
    __ptr_00[0x32] = __ptr[0x32];
    *(undefined2 *)(__ptr_00 + 0x33) = *(undefined2 *)(__ptr + 0x33);
    *(undefined *)((long)__ptr_00 + 0xce) = *(undefined *)((long)__ptr + 0xce);
    if ((0xcf < uVar7) && (0x10 < uVar4)) {
      uVar9 = 0;
      uVar17 = 0;
      uVar14 = 0xcf;
      uVar12 = 0x10;
      do {
        uVar17 = (ulong)(uint)((int)uVar17 >> 1);
        if ((uVar9 & 7) == 0) {
          uVar17 = (ulong)*(byte *)(lVar6 + uVar12);
          uVar12 = (ulong)((int)uVar12 + 1);
        }
        uVar16 = (uint)uVar14;
        uVar10 = (uint)uVar12;
        if ((uVar17 & 1) == 0) {
          if (uVar4 <= uVar10) {
            puts("Corrupted stream");
            return (void *)0;
          }
          uVar13 = (ulong)(uVar10 + 1);
          uVar15 = (ulong)(uVar16 + 1);
          *(undefined *)((long)__ptr_00 + uVar14) = *(undefined *)(lVar6 + uVar12);
LAB_001059b9:
          uVar16 = (uint)uVar15;
          uVar12 = uVar13;
          uVar14 = uVar15;
        }
        else {
          uVar13 = (ulong)(uVar10 + 2);
          bVar3 = *(byte *)(lVar6 + (ulong)(uVar10 + 1));
          uVar10 = ((uint)(bVar3 >> 4) | (uint)*(byte *)(lVar6 + uVar12) << 4) +
                   (uVar16 & 0xfffff000);
          if (uVar16 <= uVar10) {
            uVar10 = uVar10 - 0x1000;
          }
          uVar1 = uVar10 + 2 + ((uint)bVar3 & 0xf);
          if (uVar16 <= uVar10) {
            uVar16 = uVar10;
          }
          uVar15 = uVar14;
          if ((uVar7 <= uVar16) || (uVar1 <= uVar10)) goto LAB_001059b9;
          do {
            uVar12 = (ulong)uVar10;
            uVar16 = (int)uVar14 + 1;
            uVar10 = uVar10 + 1;
            *(undefined *)((long)__ptr_00 + uVar14) = *(undefined *)((long)__ptr_00 + uVar12);
            uVar14 = (ulong)uVar16;
            if (uVar1 <= uVar10 || uVar7 <= uVar16) break;
          } while (uVar10 < uVar7);
          uVar14 = (ulong)uVar16;
          uVar12 = uVar13;
        }
      } while ((uVar16 < uVar7) && (uVar9 = uVar9 + 1, (uint)uVar12 < uVar4));
    }
    __dest = calloc(__nmemb,1);
    if (__dest != (void *)0x0) {
      memcpy(__dest,(void *)((long)__ptr_00 + 0xcf),__nmemb);
      free(__ptr_00);
      *param_2 = uVar8;
      free(__ptr);
      return __dest;
    }
    uVar11 = 0x644;
  }
  printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar11);
  return __dest;
}



ulong SwapDWord(long param_1,uint param_2)

{
  long lVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint uStack20;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack20 = 0;
  if (4 < param_2) {
    param_2 = 4;
  }
  if (param_2 == 0) {
    uVar2 = 0;
  }
  else {
    lVar1 = 0;
    do {
      *(undefined *)((long)&uStack20 + lVar1) = *(undefined *)(param_1 + lVar1);
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < (int)param_2);
    uVar2 = (ulong)uStack20;
  }
  if (lStack16 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void TNEFPrintDate(ulong param_1,ulong param_2)

{
  ulong uVar1;
  ushort uVar2;
  long in_FS_OFFSET;
  undefined8 uStack344;
  undefined4 uStack336;
  undefined2 uStack332;
  undefined uStack330;
  undefined8 uStack329;
  undefined4 uStack321;
  undefined2 uStack317;
  undefined uStack315;
  undefined8 uStack314;
  undefined4 uStack306;
  undefined2 uStack302;
  undefined uStack300;
  undefined8 uStack299;
  undefined4 uStack291;
  undefined2 uStack287;
  undefined uStack285;
  undefined8 uStack284;
  undefined4 uStack276;
  undefined2 uStack272;
  undefined uStack270;
  undefined8 uStack269;
  undefined4 uStack261;
  undefined2 uStack257;
  undefined uStack255;
  undefined8 uStack254;
  undefined4 uStack246;
  undefined2 uStack242;
  undefined uStack240;
  undefined8 uStack232;
  undefined4 uStack224;
  undefined2 uStack220;
  undefined uStack218;
  undefined8 uStack217;
  undefined4 uStack209;
  undefined2 uStack205;
  undefined uStack203;
  undefined8 uStack202;
  undefined4 uStack194;
  undefined2 uStack190;
  undefined uStack188;
  undefined8 uStack187;
  undefined4 uStack179;
  undefined2 uStack175;
  undefined uStack173;
  undefined8 uStack172;
  undefined4 uStack164;
  undefined2 uStack160;
  undefined uStack158;
  undefined8 uStack157;
  undefined4 uStack149;
  undefined2 uStack145;
  undefined uStack143;
  undefined8 uStack142;
  undefined4 uStack134;
  undefined2 uStack130;
  undefined uStack128;
  undefined8 uStack127;
  undefined4 uStack119;
  undefined2 uStack115;
  undefined uStack113;
  undefined8 uStack112;
  undefined4 uStack104;
  undefined2 uStack100;
  undefined uStack98;
  undefined8 uStack97;
  undefined4 uStack89;
  undefined2 uStack85;
  undefined uStack83;
  undefined8 uStack82;
  undefined4 uStack74;
  undefined2 uStack70;
  undefined uStack68;
  undefined8 uStack67;
  undefined4 uStack59;
  undefined2 uStack55;
  undefined uStack53;
  long lStack48;
  
  lStack48 = *(long *)(in_FS_OFFSET + 0x28);
  uStack344 = 0x7961646e7553;
  uStack329 = 0x7961646e6f4d;
  uVar2 = (ushort)(param_2 >> 0x20);
  uStack314 = 0x79616473657554;
  uStack299 = 0x616473656e646557;
  uStack284 = 0x7961647372756854;
  uStack332 = 0;
  uStack269 = 0x796164697246;
  uStack317 = 0;
  uStack302 = 0;
  uStack287 = 0;
  uStack272 = 0;
  uStack257 = 0;
  uStack336 = 0;
  uStack330 = 0;
  uStack321 = 0;
  uStack315 = 0;
  uStack306 = 0;
  uStack300 = 0;
  uStack291 = 0x79;
  uStack285 = 0;
  uStack276 = 0;
  uStack270 = 0;
  uStack261 = 0;
  uStack255 = 0;
  uStack254 = 0x7961647275746153;
  uStack246 = 0;
  uStack232 = 0x797261756e614a;
  uStack242 = 0;
  uStack220 = 0;
  uStack240 = 0;
  uStack217 = 0x7972617572626546;
  uStack224 = 0;
  uStack205 = 0;
  uStack218 = 0;
  uStack202 = 0x686372614d;
  uStack209 = 0;
  uStack190 = 0;
  uStack203 = 0;
  uStack187 = 0x6c69727041;
  uStack194 = 0;
  uStack175 = 0;
  uStack188 = 0;
  uStack160 = 0;
  uStack179 = 0;
  uStack145 = 0;
  uStack173 = 0;
  uStack172 = 0x79614d;
  uStack164 = 0;
  uVar1 = (param_2 & 0xffffffff) >> 0x10;
  uStack158 = 0;
  uStack157 = 0x656e754a;
  uStack149 = 0;
  uStack143 = 0;
  uStack142 = 0x796c754a;
  uStack134 = 0;
  uStack130 = 0;
  uStack128 = 0;
  uStack127 = 0x747375677541;
  uStack119 = 0;
  uStack112 = 0x65626d6574706553;
  uStack115 = 0;
  uStack97 = 0x7265626f74634f;
  uStack113 = 0;
  uStack82 = 0x7265626d65766f4e;
  uStack104 = 0x72;
  uStack100 = 0;
  uStack98 = 0;
  uStack89 = 0;
  uStack85 = 0;
  uStack83 = 0;
  uStack74 = 0;
  uStack70 = 0;
  uStack68 = 0;
  uStack67 = 0x7265626d65636544;
  uStack59 = 0;
  uStack55 = 0;
  uStack53 = 0;
  if (uVar2 < 7) {
    printf(1,&DAT_001065b2,(undefined8 *)((long)&uStack344 + (ulong)uVar2 * 0xf));
  }
  if ((ushort)((short)((param_1 & 0xffffffff) >> 0x10) - 1U) < 0xc) {
    printf(1,&DAT_001065b2,
                 (undefined8 *)
                 ((long)&uStack232 + (long)((int)((param_1 & 0xffffffff) >> 0x10) + -1) * 0xf));
  }
  printf(1,"%hu, %hu ",param_1 >> 0x20 & 0xffff,param_1 & 0xffff);
  uVar2 = (ushort)(param_1 >> 0x30);
  param_2 = param_2 & 0xffff;
  if (uVar2 < 0xd) {
    if (uVar2 == 0xc) {
      printf(1,"%hu:%02hu:%02hu pm",0xc,param_2,uVar1);
    }
    else {
      printf(1,"%hu:%02hu:%02hu am",(ulong)uVar2,param_2,uVar1);
    }
  }
  else {
    printf(1,"%i:%02hu:%02hu pm",(ulong)((uint)uVar2 - 0xc),param_2,uVar1);
  }
  if (lStack48 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void TNEFFreeAttachment(long param_1)

{
  if (0 < *(int *)(param_1 + 0x18)) {
    free(*(void **)(param_1 + 0x10));
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  if (0 < *(int *)(param_1 + 0x28)) {
    free(*(void **)(param_1 + 0x20));
    *(undefined4 *)(param_1 + 0x28) = 0;
  }
  if (0 < *(int *)(param_1 + 0x58)) {
    free(*(void **)(param_1 + 0x50));
    *(undefined4 *)(param_1 + 0x58) = 0;
  }
  if (0 < *(int *)(param_1 + 0x90)) {
    free(*(void **)(param_1 + 0x88));
    *(undefined4 *)(param_1 + 0x90) = 0;
  }
  if (0 < *(int *)(param_1 + 0xa0)) {
    free(*(void **)(param_1 + 0x98));
    *(undefined4 *)(param_1 + 0xa0) = 0;
  }
  TNEFFreeMapiProps(param_1 + 0x70);
  return;
}



undefined8 TNEFParse(long param_1)

{
  uint *puVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  void *pcVar5;
  void *__ptr;
  ulong uVar6;
  undefined8 uVar7;
  uint *puVar8;
  long in_FS_OFFSET;
  undefined auStack82 [2];
  short sStack80;
  short sStack78;
  uint uStack76;
  uint uStack72;
  uint uStack68;
  long lStack64;
  
  lStack64 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(long *)(param_1 + 0x298) == 0) {
    uVar7 = 0xfffffff8;
    puts("ERROR: Setup incorrectly: No ReadProc");
    goto LAB_00104f39;
  }
  pcVar5 = *(void*(*)())(param_1 + 0x290);
  lVar2 = param_1 + 0x290;
  uVar6 = (ulong)*(uint *)(param_1 + 0x28c);
  if (pcVar5 == (void *)0x0) {
LAB_00104eb8:
    if (1 < (int)uVar6) {
      printf(1,"DEBUG(%i/%i): %s\n",2,uVar6,"Reading Signature");
    }
  }
  else {
    if (1 < (int)*(uint *)(param_1 + 0x28c)) {
      printf(1,"DEBUG(%i/%i): %s\n",2,uVar6,"About to initialize");
      pcVar5 = *(void*(*)())(param_1 + 0x290);
    }

    if (iVar3 != 0) {
      uVar7 = 0xffffffff;
      goto LAB_00104f39;
    }
    if (1 < (int)*(uint *)(param_1 + 0x28c)) {
      printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                   "Initialization finished");
      uVar6 = (ulong)*(uint *)(param_1 + 0x28c);
      goto LAB_00104eb8;
    }
  }
  iVar3 = (**(void*(*)())(param_1 + 0x298))(param_1 + 0x290,4,1);
  if (iVar3 < 1) {
    puts("ERROR: Error reading signature");
    pcVar5 = *(void*(*)())(param_1 + 0x2a0);
    uVar7 = 0xfffffffd;
  }
  else {
    if ((int)*(uint *)(param_1 + 0x28c) < 2) {
      iVar3 = TNEFCheckForSignature((ulong)uStack68);
    }
    else {
      printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),"Checking Signature");
      iVar3 = TNEFCheckForSignature((ulong)uStack68);
    }
    if (iVar3 < 0) {
      puts("ERROR: Signature does not match. Not TNEF.");
      pcVar5 = *(void*(*)())(param_1 + 0x2a0);
      uVar7 = 0xfffffffe;
    }
    else {
      if (1 < (int)*(uint *)(param_1 + 0x28c)) {
        printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),"Reading Key.");
      }
      iVar3 = TNEFGetKey(param_1,auStack82);
      if (-1 < iVar3) {
        if (1 < (int)*(uint *)(param_1 + 0x28c)) {
          printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                       "Starting Full Processing.");
        }
        while( true ) {
          uVar4 = TNEFGetHeader(param_1,&uStack76,&uStack72);
          uVar6 = (ulong)uVar4;
          if (uVar4 != 0) break;
          if (1 < *(int *)(param_1 + 0x28c)) {
            printf(1,"DEBUG(%i/%i):",2);
            printf(1,"Header says type=0x%X, size=%u",(ulong)uStack76);
            putchar(10);
            if (1 < *(int *)(param_1 + 0x28c)) {
              printf(1,"DEBUG(%i/%i):",2);
              printf(1,"Header says type=%u, size=%u",(ulong)uStack76,(ulong)uStack72);
              putchar(10);
            }
          }
          uVar4 = uStack72;
          if (uStack72 == 0) {
            uVar7 = 0xfffffffd;
            puts("ERROR: Field with size of 0");
            goto LAB_00104f39;
          }
          if ((uint)(*(int *)(param_1 + 0x2b0) << 0x14) < uStack72) {
            printf(1,
                         "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                         ,(ulong)uStack72,"ytnef.c",0x4a2);
            uVar7 = 0xffffffff;
            goto LAB_00104f39;
          }
          __ptr = calloc((ulong)uStack72,1);
          if (__ptr == (void *)0x0) {
            uVar7 = 0xffffffff;
            printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x4a4);
            goto LAB_00104f39;
          }
          iVar3 = TNEFRawRead(param_1,__ptr,(ulong)uVar4, 0);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read data.");
            pcVar5 = *(void*(*)())(param_1 + 0x2a0);
joined_r0x001050e2:
            if (pcVar5 != (void *)0x0) {
              (   *(void*(*)())(param_1 + 0x2a0))(lVar2);
            }
            uVar7 = 0xfffffffd;
            free(__ptr);
            goto LAB_00104f39;
          }
          iVar3 = TNEFRawRead(param_1,&sStack80,2, 0);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read checksum.");
            pcVar5 = *(void*(*)())(param_1 + 0x2a0);
            goto joined_r0x001050e2;
          }
          sStack80 = SwapWord(&sStack80,2);
          if (sStack80 != sStack78) {
            puts("ERROR: Checksum mismatch. Data corruption?:");
            if (*(void*(*)())(param_1 + 0x2a0) != (void *)0x0) {
              (**(void*(*)())(param_1 + 0x2a0))(lVar2);
            }
            uVar7 = 0xfffffffb;
            free(__ptr);
            goto LAB_00104f39;
          }
          puVar8 = (uint *)&TNEFList;
          do {
            while (*puVar8 != uStack76) {
LAB_00104e10:
              uVar4 = (int)uVar6 + 1;
              uVar6 = (ulong)uVar4;
              puVar8 = puVar8 + 0xe;
              if (uVar4 == 0x21) goto LAB_00104e88;
            }
            if (*(void*(*)())(puVar8 + 0xc) != (void *)0x0) {
              iVar3 = (**(void*(*)())(puVar8 + 0xc))(param_1,uVar6,__ptr);
              if (iVar3 < 0) {
                free(__ptr);
                pcVar5 = *(void*(*)())(param_1 + 0x2a0);
                uVar7 = 0xfffffffa;
                goto joined_r0x0010506e;
              }
              break;
            }
            if (*(int *)(param_1 + 0x28c) < 1) goto LAB_00104e10;
            uVar4 = (int)uVar6 + 1;
            uVar6 = (ulong)uVar4;
            printf(1,"DEBUG(%i/%i):",1);
            puVar1 = puVar8 + 1;
            puVar8 = puVar8 + 0xe;
            printf(1,"No handler for %s: %u bytes",puVar1);
            putchar(10);
          } while (uVar4 != 0x21);
LAB_00104e88:
          free(__ptr);
        }
        if (*(void*(*)())(param_1 + 0x2a0) == (void *)0x0) {
          uVar7 = 0;
        }
        else {
          uVar7 = 0;
          (**(void*(*)())(param_1 + 0x2a0))(lVar2);
        }
        goto LAB_00104f39;
      }
      puts("ERROR: Unable to retrieve key.");
      pcVar5 = *(void*(*)())(param_1 + 0x2a0);
      uVar7 = 0xfffffffc;
    }
  }
joined_r0x0010506e:
  if (pcVar5 != (void *)0x0) {
     (*(void*(*)())(param_1 + 0x2a0))(lVar2);
  }
LAB_00104f39:
  if (lStack64 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar7;
}



//void printf(void)
//
//{
//  printf();
//  return;
//}
//


void TNEFInitAttachment(undefined8 *param_1)

{
  *param_1 = 0;
  *(undefined4 *)(param_1 + 1) = 0;
  *(undefined2 *)((long)param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)((long)param_1 + 100) = 0;
  *(undefined4 *)(param_1 + 0xd) = 0;
  *(undefined4 *)((long)param_1 + 0x6c) = 0;
  param_1[2] = 0;
  *(undefined4 *)(param_1 + 3) = 0;
  param_1[4] = 0;
  *(undefined4 *)(param_1 + 5) = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  *(undefined4 *)(param_1 + 9) = 0;
  param_1[10] = 0;
  *(undefined4 *)(param_1 + 0xb) = 0;
  param_1[0x11] = 0;
  *(undefined4 *)(param_1 + 0x12) = 0;
  param_1[0x13] = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  TNEFInitMapi(0);
  param_1[0x10] = 0;
  return;
}



void MAPIPrint(uint *param_1)

{
  uint *puVar1;
  undefined8 *puVar2;
  byte *pbVar3;
  ushort uVar4;
  undefined8 uVar5;
  bool bVar6;
  size_t sVar7;
  ushort **ppuVar8;
  uint uVar9;
  int *piVar10;
  uint *puVar11;
  long lVar12;
  int iVar13;
  uint uVar14;
  ulong uVar15;
  long lVar16;
  uint **ppuVar17;
  long in_FS_OFFSET;
  uint uStack148;
  long lStack144;
  undefined8 uStack102;
  undefined2 uStack94;
  undefined2 uStack92;
  undefined2 uStack90;
  char *pcStack88;
  undefined auStack80 [16];
  long lStack64;
  
  lStack64 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_1 != 0) {
    lStack144 = 0;
    uStack148 = 0;
    do {
      piVar10 = (int *)(lStack144 + *(long *)(param_1 + 2));
      printf(1,"   #%i: Type: [",(ulong)uStack148);
      uVar4 = *(ushort *)(piVar10 + 5);
      if (uVar4 == 10) {
        printf(1,"  ERROR  ");
      }
      else {
        if (uVar4 < 0xb) {
          if (uVar4 == 3) {
            printf(1,"  LONG   ");
          }
          else {
            if (uVar4 < 4) {
              if (uVar4 == 1) {
                printf(1,"  NULL   ");
              }
              else {
                if (uVar4 < 2) {
                  printf(1,"  NONE   ");
                }
                else {
                  printf(1,&DAT_00106852);
                }
              }
            }
            else {
              if (uVar4 == 5) {
                printf(1," DOUBLE  ");
              }
              else {
                if (uVar4 < 5) {
                  printf(1,"   R4    ");
                }
                else {
                  if (uVar4 == 6) {
                    printf(1,"CURRENCY ");
                  }
                  else {
                    if (uVar4 != 7) goto LAB_00105d17;
                    printf(1,"APP TIME ");
                  }
                }
              }
            }
          }
        }
        else {
          if (uVar4 == 0x1e) {
            printf(1," STRING8 ");
          }
          else {
            if (uVar4 < 0x1f) {
              if (uVar4 == 0xd) {
                printf(1," OBJECT  ");
              }
              else {
                if (uVar4 == 0x14) {
                  printf(1,"   I8    ");
                }
                else {
                  if (uVar4 != 0xb) goto LAB_00105d17;
                  printf(1," BOOLEAN ");
                }
              }
            }
            else {
              if (uVar4 == 0x40) {
                printf(1,"SYS TIME ");
              }
              else {
                if (uVar4 < 0x41) {
                  if (uVar4 == 0x1f) {
                    printf(1," UNICODE ");
                  }
                  else {
LAB_00105d17:
                    printf(1,&DAT_001068e8);
                  }
                }
                else {
                  if (uVar4 == 0x48) {
                    printf(1,"OLE GUID ");
                  }
                  else {
                    if (uVar4 != 0x102) goto LAB_00105d17;
                    printf(1," BINARY  ");
                  }
                }
              }
            }
          }
        }
      }
      printf(1,"]  Code: [");
      if (*piVar10 == 1) {
        printf(1,"UD:x%04x",(ulong)*(ushort *)((long)piVar10 + 0x16));
      }
      else {
        puVar11 = (uint *)&MPList;
        bVar6 = false;
        do {
          while ((*puVar11 != (uint)*(ushort *)((long)piVar10 + 0x16) || (bVar6))) {
            puVar11 = puVar11 + 0x21;
            if (puVar11 == (uint *)&DAT_00316230) goto LAB_00105da1;
          }
          puVar1 = puVar11 + 1;
          puVar11 = puVar11 + 0x21;
          printf(1,0x1064d7,puVar1);
          bVar6 = true;
        } while (puVar11 != (uint *)&DAT_00316230);
LAB_00105da1:
        if (!bVar6) {
          printf(1,"0x%04x",(ulong)*(ushort *)((long)piVar10 + 0x16));
        }
      }
      puts("]");
      if (0 < piVar10[7]) {
        lVar16 = 0;
        iVar13 = 0;
        do {
          iVar13 = iVar13 + 1;
          puVar2 = (undefined8 *)(*(long *)(piVar10 + 8) + lVar16);
          lVar16 = lVar16 + 0x10;
          printf(1,"    Name: %s\n",*puVar2);
        } while (piVar10[7] != iVar13 && iVar13 <= piVar10[7]);
      }
      uVar9 = piVar10[6];
      if (uVar9 != 0) {
        lVar16 = 0;
        uVar15 = 0;
        do {
          while( true ) {
            ppuVar17 = (uint **)(*(long *)(piVar10 + 10) + lVar16);
            if (uVar9 == 1) {
              printf(1,&DAT_00106857);
            }
            else {
              printf(1,"    [%i/%u] ",uVar15);
            }
            printf(1,"Size: %i",(ulong)*(uint *)(ppuVar17 + 1));
            uVar4 = *(ushort *)(piVar10 + 5);
            if (uVar4 != 0xd) break;
            putchar(10);
LAB_00105eb8:
            uVar9 = piVar10[6];
            uVar14 = (int)uVar15 + 1;
            uVar15 = (ulong)uVar14;
            lVar16 = lVar16 + 0x10;
            if (uVar9 <= uVar14) goto LAB_00105f68;
          }
          if (uVar4 < 0xe) {
            if (uVar4 == 3) {
              printf(1,"    Value: %i\n",(ulong)**ppuVar17);
            }
            else {
              if (uVar4 == 0xb) {
                if (***(char ***)(piVar10 + 10) == '\0') {
                  puts("    Value: False");
                }
                else {
                  puts("    Value: True");
                }
              }
              else {
                if (uVar4 != 2) goto LAB_00105f37;
                printf(1,"    Value: %hi\n",(ulong)(uint)(int)*(short *)*ppuVar17);
              }
            }
            goto LAB_00105eb8;
          }
          if (uVar4 == 0x40) {
            lVar12 = 0;
            MAPISysTimetoDTR(*ppuVar17,&uStack102);
            printf(1,"    Value: ");
            uVar5 = *(undefined8 *)*ppuVar17;
            TNEFPrintDate(uStack102,(ulong)CONCAT24(uStack90,CONCAT22(uStack92,uStack94)));
            printf(1,&DAT_0010693a);
            do {
              pbVar3 = (byte *)((long)*ppuVar17 + lVar12);
              lVar12 = lVar12 + 1;
              printf(1," %02x",(ulong)*pbVar3);
            } while (lVar12 != 8);
            printf(1,"] (%llu)\n",uVar5);
            goto LAB_00105eb8;
          }
          if (0x40 < uVar4) {
            if (uVar4 == 0x48) {
              lVar12 = 0;
              printf(1,"    Value: ");
              printf(1,"[HEX: ");
              do {
                pbVar3 = (byte *)((long)*ppuVar17 + lVar12);
                lVar12 = lVar12 + 1;
                printf(1," %02x",(ulong)*pbVar3);
              } while (lVar12 != 0x10);
              puts("]");
            }
            else {
              if (uVar4 != 0x102) goto LAB_00105f37;
              iVar13 = IsCompressedRTF(ppuVar17);
              if (iVar13 != 1) {
                printf(1,"    Value: [");
                if (0 < *(int *)(ppuVar17 + 1)) {
                  ppuVar8 = __ctype_b_loc();
                  lVar12 = 0;
                  do {
                    if ((*(byte *)((long)*ppuVar8 +
                                  (ulong)(uint)*(byte *)((long)*ppuVar17 + lVar12) * 2 + 1) & 0x40)
                        == 0) {
                      putchar(0x2e);
                    }
                    else {
                      putchar((uint)*(byte *)((long)*ppuVar17 + lVar12));
                    }
                    iVar13 = (int)lVar12 + 1;
                    lVar12 = lVar12 + 1;
                  } while (*(int *)(ppuVar17 + 1) != iVar13 && iVar13 <= *(int *)(ppuVar17 + 1));
                }
                goto LAB_001060dc;
              }
              printf(1,"    Detected Compressed RTF. ");
              puts("Decompressed text follows");
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
              pcStack88 = (char *)DecompressRTF(ppuVar17,auStack80);
              if (pcStack88 != (char *)0x0) {
                puts(pcStack88);
                free(pcStack88);
              }
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            }
            goto LAB_00105eb8;
          }
          if (uVar4 == 0x1e) {
            printf(1,"    Value: [%.*s]\n",(ulong)*(uint *)(ppuVar17 + 1));
            sVar7 = strlen((char *)*ppuVar17);
            if (sVar7 != (long)(*(int *)(ppuVar17 + 1) + -1)) {
              printf(1,"Detected Hidden data: [");
              if (0 < *(int *)(ppuVar17 + 1)) {
                ppuVar8 = __ctype_b_loc();
                lVar12 = 0;
                do {
                  while( true ) {
                    if ((*(byte *)((long)*ppuVar8 +
                                  (ulong)(uint)*(byte *)((long)*ppuVar17 + lVar12) * 2 + 1) & 0x40)
                        == 0) break;
                    putchar((uint)*(byte *)((long)*ppuVar17 + lVar12));
                    iVar13 = (int)lVar12 + 1;
                    lVar12 = lVar12 + 1;
                    if (*(int *)(ppuVar17 + 1) == iVar13 || *(int *)(ppuVar17 + 1) < iVar13)
                    goto LAB_001060dc;
                  }
                  putchar(0x2e);
                  iVar13 = (int)lVar12 + 1;
                  lVar12 = lVar12 + 1;
                } while (*(int *)(ppuVar17 + 1) != iVar13 && iVar13 <= *(int *)(ppuVar17 + 1));
              }
LAB_001060dc:
              puts("]");
            }
            goto LAB_00105eb8;
          }
LAB_00105f37:
          uVar14 = (int)uVar15 + 1;
          uVar15 = (ulong)uVar14;
          lVar16 = lVar16 + 0x10;
          printf(1,"    Value: [%.*s]\n",(ulong)*(uint *)(ppuVar17 + 1));
          uVar9 = piVar10[6];
        } while (uVar14 < uVar9);
      }
LAB_00105f68:
      uStack148 = uStack148 + 1;
      lStack144 = lStack144 + 0x30;
    } while (uStack148 <= *param_1 && *param_1 != uStack148);
  }
  if (lStack64 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



undefined8 MAPISysTimetoDTR(ulong *param_1,ushort *param_2)

{
  short sVar1;
  uint uVar2;
  ulong uVar3;
  ulong uVar4;
  ushort uVar5;
  uint uVar6;
  uint uVar7;
  long in_FS_OFFSET;
  undefined8 uStack72;
  undefined8 uStack64;
  undefined8 uStack56;
  undefined8 uStack48;
  undefined8 uStack40;
  undefined8 uStack32;
  long lStack16;
  
  uVar4 = *param_1;
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack72 = 0x1c0000001f;
  uStack64 = 0x1e0000001f;
  uStack56 = 0x1e0000001f;
  uStack48 = 0x1f0000001f;
  uStack40 = 0x1f0000001e;
  uStack32 = 0x1f0000001e;
  uVar3 = (uVar4 / 10000000) / 0x3c;
  param_2[5] = (short)(uVar4 / 10000000) + ((short)(uVar3 << 4) - (short)uVar3) * -4;
  uVar3 = (uVar4 / 600000000) / 0x3c;
  param_2[4] = (short)(uVar4 / 600000000) + ((short)(uVar3 << 4) - (short)uVar3) * -4;
  param_2[3] = (short)(uVar4 / 36000000000) + (short)((uVar4 / 36000000000) / 0x18) * -0x18;
  uVar4 = uVar4 / 864000000000;
  if (uVar4 < 0x16d) {
    uVar2 = 1;
    *param_2 = 0x641;
  }
  else {
    uVar4 = uVar4 - 0x16d;
    uVar6 = 0x642;
    *param_2 = 0x642;
    uVar3 = 0x16d;
    uVar7 = 2;
    while (uVar2 = uVar7 % 7, uVar3 <= uVar4) {
      uVar6 = uVar6 + 1;
      uVar4 = uVar4 - uVar3;
      uVar7 = uVar2 + 1;
      uVar5 = (ushort)uVar6;
      *param_2 = uVar5;
      uVar3 = 0x16d;
      if (((uVar6 & 3) == 0) &&
         ((uVar5 != (ushort)((((ushort)(uVar6 >> 2) & 0x3fff) / 0x19) * 100) ||
          (uVar5 == (ushort)(((uVar5 >> 4) / 0x19) * 400))))) {
        uVar7 = uVar2 + 2;
        uVar3 = 0x16e;
      }
    }
    if ((uVar6 & 3) == 0) {
      uStack72 = 0x1d0000001f;
    }
  }
  sVar1 = (short)uVar4;
  uVar2 = uVar2 + (int)uVar4;
  param_2[1] = 0;
  param_2[6] = (short)uVar2 + (short)(uVar2 / 7) * -7;
  uVar3 = uVar4 & 0xffffffff;
  uVar5 = 1;
  if (0x1f < uVar4) {
    uVar2 = 0x1f;
    uVar5 = 1;
    do {
      uVar6 = (int)uVar3 - uVar2;
      sVar1 = (short)uVar6;
      uVar3 = (ulong)uVar6;
      uVar4 = (ulong)uVar5;
      uVar5 = uVar5 + 1;
      uVar2 = *(uint *)((long)&uStack72 + uVar4 * 4);
    } while (uVar2 < uVar6);
  }
  param_2[1] = uVar5;
  param_2[2] = sVar1 + 1;
  if (lStack16 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention yet parameter storage is locked
//
//FILE * fopen(char *__filename,char *__modes)
//
//{
//  FILE *pFVar1;
//  
//  pFVar1 = fopen(__filename,__modes);
//  return pFVar1;
//}
//


undefined8 TNEFGetHeader(long param_1,uint *param_2,uint *param_3)

{
  long lVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (1 < (int)*(uint *)(param_1 + 0x28c)) {
    printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                 "About to read Component");
  }
  lVar1 = param_1 + 0x290;
  iVar3 = (**(void*(*)())(param_1 + 0x298))(lVar1,1,1);
  if (0 < iVar3) {
    if (1 < (int)*(uint *)(param_1 + 0x28c)) {
      printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),"About to read type");
    }
    iVar3 = (**(void*(*)())(param_1 + 0x298))(lVar1,4,1);
    if (iVar3 < 1) {
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading type");
        uVar5 = 0xfffffffd;
        goto LAB_0010435f;
      }
    }
    else {
      if (1 < *(int *)(param_1 + 0x28c)) {
        printf(1,"DEBUG(%i/%i):",2);
        printf(1,"Type = 0x%X",(ulong)*param_2);
        putchar(10);
        if (1 < *(int *)(param_1 + 0x28c)) {
          printf(1,"DEBUG(%i/%i):",2);
          printf(1,"Type = %u",(ulong)*param_2);
          putchar(10);
          if (1 < (int)*(uint *)(param_1 + 0x28c)) {
            printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                         "About to read size");
          }
        }
      }
      iVar3 = (**(void*(*)())(param_1 + 0x298))(lVar1,4,1);
      if (0 < iVar3) {
        if (1 < *(int *)(param_1 + 0x28c)) {
          printf(1,"DEBUG(%i/%i):",2);
          printf(1,"Size = %u",(ulong)*param_3);
          putchar(10);
        }
        uVar4 = SwapDWord(param_2,4);
        *param_2 = uVar4;
        uVar4 = SwapDWord(param_3,4);
        *param_3 = uVar4;
        uVar5 = 0;
        goto LAB_0010435f;
      }
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading size");
        uVar5 = 0xfffffffd;
        goto LAB_0010435f;
      }
    }
  }
  uVar5 = 0xfffffffd;
LAB_0010435f:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//ushort ** __ctype_b_loc(void)
//
//{
//  ushort **ppuVar1;
//  
//  ppuVar1 = __ctype_b_loc();
//  return ppuVar1;
//}
//


ulong TNEFCheckForSignature(undefined4 param_1)

{
  int iVar1;
  undefined4 auStack12 [3];
  
  auStack12[0] = param_1;
  iVar1 = SwapDWord(auStack12,4);
  return (ulong)(((uint)(iVar1 == 0x223e9f78) - 2) + (uint)(iVar1 == 0x223e9f78));
}



//void __cxa_finalize(void)
//
//{
//  __cxa_finalize();
//  return;
//}
//
//
//
//// WARNING: Removing unreachable block (ram,0x00101b97)
//// WARNING: Removing unreachable block (ram,0x00101ba3)
//
//void entry(void)
//
//{
//  return;
//}
//
//
//
//void _FINI_0(void)
//
//{
//  if (__bss_start != '\0') {
//    return;
//  }
//  __cxa_finalize(PTR_LOOP_00308140);
//  entry();
//  __bss_start = 1;
//  return;
//}
//
//
//
//// WARNING: Removing unreachable block (ram,0x00101be8)
//// WARNING: Removing unreachable block (ram,0x00101bf4)
//
//void _INIT_0(void)
//
//{
//  return;
//}
//


undefined8 TNEFMemory_Open(long param_1)

{
  (*(undefined8 **)(param_1 + 0x18))[1] = **(undefined8 **)(param_1 + 0x18);
  return 0;
}



undefined8 TNEFMemory_Close(void)

{
  return 0;
}



undefined8 TNEFParentID(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < param_4) {
    param_4 = 0x32;
  }
  if (param_4 < 8) {
    if ((param_4 & 4) == 0) {
      if ((param_4 != 0) &&
         (*(undefined *)(param_1 + 0xba) = *(undefined *)param_3, (param_4 & 2) != 0)) {
        *(undefined2 *)(param_1 + 0xb8 + (ulong)param_4) =
             *(undefined2 *)((long)param_3 + ((ulong)param_4 - 2));
      }
    }
    else {
      *(undefined4 *)(param_1 + 0xba) = *(undefined4 *)param_3;
      *(undefined4 *)(param_1 + 0xb6 + (ulong)param_4) =
           *(undefined4 *)((long)param_3 + ((ulong)param_4 - 4));
    }
  }
  else {
    *(undefined8 *)(param_1 + 0xba) = *param_3;
    uVar5 = param_1 + 0xc2U & 0xfffffffffffffff8;
    *(undefined8 *)(param_1 + 0xb2 + (ulong)param_4) =
         *(undefined8 *)((long)param_3 + ((ulong)param_4 - 8));
    lVar3 = (param_1 + 0xba) - uVar5;
    uVar2 = param_4 + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)((long)param_3 + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
    }
  }
  return 0;
}



undefined8 TNEFMessageID(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < param_4) {
    param_4 = 0x32;
  }
  if (param_4 < 8) {
    if ((param_4 & 4) == 0) {
      if ((param_4 != 0) &&
         (*(undefined *)(param_1 + 0x88) = *(undefined *)param_3, (param_4 & 2) != 0)) {
        *(undefined2 *)(param_1 + 0x86 + (ulong)param_4) =
             *(undefined2 *)((long)param_3 + ((ulong)param_4 - 2));
      }
    }
    else {
      *(undefined4 *)(param_1 + 0x88) = *(undefined4 *)param_3;
      *(undefined4 *)(param_1 + 0x84 + (ulong)param_4) =
           *(undefined4 *)((long)param_3 + ((ulong)param_4 - 4));
    }
  }
  else {
    *(undefined8 *)(param_1 + 0x88) = *param_3;
    uVar5 = param_1 + 0x90U & 0xfffffffffffffff8;
    *(undefined8 *)(param_1 + 0x80 + (ulong)param_4) =
         *(undefined8 *)((long)param_3 + ((ulong)param_4 - 8));
    lVar3 = (param_1 + 0x88) - uVar5;
    uVar2 = param_4 + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)((long)param_3 + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
    }
  }
  return 0;
}



undefined8 TNEFMessageClass(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x30 < param_4) {
    param_4 = 0x31;
  }
  if (param_4 < 8) {
    if ((param_4 & 4) == 0) {
      if ((param_4 != 0) &&
         (*(undefined *)(param_1 + 0x56) = *(undefined *)param_3, (param_4 & 2) != 0)) {
        *(undefined2 *)(param_1 + 0x54 + (ulong)param_4) =
             *(undefined2 *)((long)param_3 + ((ulong)param_4 - 2));
      }
    }
    else {
      *(undefined4 *)(param_1 + 0x56) = *(undefined4 *)param_3;
      *(undefined4 *)(param_1 + 0x52 + (ulong)param_4) =
           *(undefined4 *)((long)param_3 + ((ulong)param_4 - 4));
    }
  }
  else {
    *(undefined8 *)(param_1 + 0x56) = *param_3;
    uVar5 = param_1 + 0x5eU & 0xfffffffffffffff8;
    *(undefined8 *)(param_1 + 0x4e + (ulong)param_4) =
         *(undefined8 *)((long)param_3 + ((ulong)param_4 - 8));
    lVar3 = (param_1 + 0x56) - uVar5;
    uVar2 = param_4 + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)((long)param_3 + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
    }
  }
  return 0;
}



ulong TNEFMemory_Read(long param_1,int param_2,uint param_3,void *param_4)

{
  long *plVar1;
  ulong uVar2;
  void *__src;
  ulong __n;
  
  plVar1 = *(long **)(param_1 + 0x18);
  __n = SEXT48((int)(param_2 * param_3));
  __src = (void *)plVar1[1];
  if ((plVar1[2] + *plVar1) - (long)__src < (long)__n) {
    uVar2 = 0xffffffff;
  }
  else {
    uVar2 = (ulong)param_3;
    if (2 < *(int *)(plVar1 + 3)) {
      printf(1,"DEBUG(%i/%i):",3);
      printf(1,"Copying %i bytes",__n & 0xffffffff);
      putchar(10);
      __src = (void *)plVar1[1];
    }
    memcpy(param_4,__src,__n);
    plVar1[1] = plVar1[1] + __n;
  }
  return uVar2;
}



ulong TNEFFile_Open(long param_1)

{
  char **ppcVar1;
  FILE *pFVar2;
  
  ppcVar1 = *(char ***)(param_1 + 0x18);
  if (2 < *(int *)(ppcVar1 + 2)) {
    printf(1,"DEBUG(%i/%i):",3);
    printf(1,"Opening %s",*ppcVar1);
    putchar(10);
  }
  pFVar2 = fopen(*ppcVar1,"rb");
  *(FILE **)(ppcVar1 + 1) = pFVar2;
  return (ulong)-(uint)(pFVar2 == (FILE *)0x0);
}



size_t TNEFFile_Read(long param_1,uint param_2,uint param_3,void *param_4)

{
  long lVar1;
  FILE *__stream;
  size_t sVar2;
  
  lVar1 = *(long *)(param_1 + 0x18);
  if (2 < *(int *)(lVar1 + 0x10)) {
    printf(1,"DEBUG(%i/%i):",3);
    printf(1,"Reading %i blocks of %i size",(ulong)param_3,(ulong)param_2);
    putchar(10);
  }
  __stream = *(FILE **)(lVar1 + 8);
  if (__stream == (FILE *)0x0) {
    sVar2 = 0xffffffff;
  }
  else {
    sVar2 = fread(param_4,(long)(int)param_2,(long)(int)param_3,__stream);
  }
  return sVar2;
}



undefined8 TNEFFile_Close(long param_1)

{
  undefined8 *puVar1;
  
  puVar1 = *(undefined8 **)(param_1 + 0x18);
  if (2 < *(int *)(puVar1 + 2)) {
    printf(1,"DEBUG(%i/%i):",3);
    printf(1,"Closing file %s",*puVar1);
    putchar(10);
  }
  if ((FILE *)puVar1[1] != (FILE *)0x0) {
    fclose((FILE *)puVar1[1]);
    puVar1[1] = 0;
  }
  return 0;
}



undefined8 TNEFDefaultHandler(long param_1,int param_2,undefined8 param_3,uint param_4)

{
  if (0 < *(int *)(param_1 + 0x28c)) {
    printf(1,"%s: [%i] %.*s\n",&DAT_00316244 + (long)param_2 * 0x38,param_4,(ulong)param_4,
                 param_3);
    return 0;
  }
  return 0;
}



undefined8 TNEFCodePage(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  void *__dest;
  undefined8 uVar1;
  
  *(int *)(param_1 + 0x210) = param_4;
  __dest = calloc((long)param_4,1);
  *(void **)(param_1 + 0x208) = __dest;
  if (__dest == (void *)0x0) {
    printf(1,"Out of Memory at %s : %i\n","ytnef.c",0xff);
    uVar1 = 0xffffffff;
  }
  else {
    memcpy(__dest,param_3,(long)param_4);
    uVar1 = 0;
  }
  return uVar1;
}



undefined8 TNEFBody(long param_1,undefined8 param_2,void *param_3,uint param_4)

{
  void *__dest;
  undefined8 uVar1;
  
  *(uint *)(param_1 + 0x128) = param_4;
  if (param_4 - 1 < 100000) {
    __dest = calloc((long)(int)(param_4 + 1),1);
    *(void **)(param_1 + 0x120) = __dest;
    if (__dest == (void *)0x0) {
      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x113);
      uVar1 = 0xffffffff;
    }
    else {
      memcpy(__dest,param_3,(long)(int)param_4);
      uVar1 = 0;
    }
  }
  else {
    printf(1,
                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                 ,(ulong)param_4,"ytnef.c",0x111,100000);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



undefined8 TNEFOriginalMsgClass(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  undefined8 uVar1;
  ulong uVar2;
  ulong uVar3;
  undefined8 *puVar4;
  byte bVar5;
  
  bVar5 = 0;
  uVar3 = (ulong)param_4;
  *(uint *)(param_1 + 0x220) = param_4;
  if (param_4 - 1 < 100) {
    puVar4 = (undefined8 *)calloc((long)(int)(param_4 + 1),1);
    *(undefined8 **)(param_1 + 0x218) = puVar4;
    if (puVar4 == (undefined8 *)0x0) {
      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x11c);
      uVar1 = 0xffffffff;
    }
    else {
      if (param_4 < 8) {
        if ((param_4 & 4) == 0) {
          if ((param_4 != 0) && (*(undefined *)puVar4 = *(undefined *)param_3, (param_4 & 2) != 0))
          {
            *(undefined2 *)((long)puVar4 + (uVar3 - 2)) =
                 *(undefined2 *)((long)param_3 + (uVar3 - 2));
          }
        }
        else {
          *(undefined4 *)puVar4 = *(undefined4 *)param_3;
          *(undefined4 *)((long)puVar4 + (uVar3 - 4)) = *(undefined4 *)((long)param_3 + (uVar3 - 4))
          ;
        }
      }
      else {
        uVar2 = (ulong)(param_4 - 1 >> 3);
        *(undefined8 *)((long)puVar4 + (uVar3 - 8)) = *(undefined8 *)((long)param_3 + (uVar3 - 8));
        while (uVar2 != 0) {
          uVar2 = uVar2 - 1;
          *puVar4 = *param_3;
          param_3 = param_3 + (ulong)bVar5 * 0x1ffffffffffffffe + 1;
          puVar4 = puVar4 + (ulong)bVar5 * 0x1ffffffffffffffe + 1;
        }
      }
      uVar1 = 0;
    }
  }
  else {
    printf(1,
                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                 ,(ulong)param_4,"ytnef.c",0x11a,100);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



undefined8 TNEFFromHandler(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  undefined8 uVar1;
  ulong uVar2;
  ulong uVar3;
  undefined8 *puVar4;
  byte bVar5;
  
  bVar5 = 0;
  uVar3 = (ulong)param_4;
  if (param_4 - 1 < 100) {
    puVar4 = (undefined8 *)calloc((long)(int)(param_4 + 1),1);
    *(undefined8 **)(param_1 + 0x10) = puVar4;
    if (puVar4 == (undefined8 *)0x0) {
      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x129);
      uVar1 = 0xffffffff;
    }
    else {
      *(uint *)(param_1 + 0x18) = param_4;
      if (param_4 < 8) {
        if ((param_4 & 4) == 0) {
          if ((param_4 != 0) && (*(undefined *)puVar4 = *(undefined *)param_3, (param_4 & 2) != 0))
          {
            *(undefined2 *)((long)puVar4 + (uVar3 - 2)) =
                 *(undefined2 *)((long)param_3 + (uVar3 - 2));
          }
        }
        else {
          *(undefined4 *)puVar4 = *(undefined4 *)param_3;
          *(undefined4 *)((long)puVar4 + (uVar3 - 4)) = *(undefined4 *)((long)param_3 + (uVar3 - 4))
          ;
        }
      }
      else {
        uVar2 = (ulong)(param_4 - 1 >> 3);
        *(undefined8 *)((long)puVar4 + (uVar3 - 8)) = *(undefined8 *)((long)param_3 + (uVar3 - 8));
        while (uVar2 != 0) {
          uVar2 = uVar2 - 1;
          *puVar4 = *param_3;
          param_3 = param_3 + (ulong)bVar5 * 0x1ffffffffffffffe + 1;
          puVar4 = puVar4 + (ulong)bVar5 * 0x1ffffffffffffffe + 1;
        }
      }
      uVar1 = 0;
    }
  }
  else {
    printf(1,
                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                 ,uVar3,"ytnef.c",0x127,100);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



undefined8 TNEFIcon(long param_1,undefined8 param_2,void *param_3,uint param_4)

{
  long lVar1;
  void *__dest;
  undefined8 uVar2;
  long lVar3;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar3 = lVar1;
    lVar1 = *(long *)(lVar3 + 0x80);
  } while (*(long *)(lVar3 + 0x80) != 0);
  *(uint *)(lVar3 + 0xa0) = param_4;
  if (param_4 - 1 < 10000) {
    __dest = calloc((long)(int)param_4,1);
    *(void **)(lVar3 + 0x98) = __dest;
    if (__dest == (void *)0x0) {
      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x163);
      uVar2 = 0xffffffff;
    }
    else {
      memcpy(__dest,param_3,(long)(int)param_4);
      uVar2 = 0;
    }
  }
  else {
    printf(1,
                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                 ,(ulong)param_4,"ytnef.c",0x161,10000);
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



undefined8 TNEFAttachmentFilename(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  long lVar1;
  undefined8 uVar2;
  ulong uVar3;
  long lVar4;
  ulong uVar5;
  undefined8 *puVar6;
  byte bVar7;
  
  bVar7 = 0;
  uVar5 = (ulong)param_4;
  lVar1 = param_1 + 0x140;
  do {
    lVar4 = lVar1;
    lVar1 = *(long *)(lVar4 + 0x80);
  } while (*(long *)(lVar4 + 0x80) != 0);
  *(uint *)(lVar4 + 0x18) = param_4;
  if (param_4 - 1 < 100) {
    puVar6 = (undefined8 *)calloc((long)(int)(param_4 + 1),1);
    *(undefined8 **)(lVar4 + 0x10) = puVar6;
    if (puVar6 == (undefined8 *)0x0) {
      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x310);
      uVar2 = 0xffffffff;
    }
    else {
      if (param_4 < 8) {
        if ((param_4 & 4) == 0) {
          if ((param_4 != 0) && (*(undefined *)puVar6 = *(undefined *)param_3, (param_4 & 2) != 0))
          {
            *(undefined2 *)((long)puVar6 + (uVar5 - 2)) =
                 *(undefined2 *)((long)param_3 + (uVar5 - 2));
          }
        }
        else {
          *(undefined4 *)puVar6 = *(undefined4 *)param_3;
          *(undefined4 *)((long)puVar6 + (uVar5 - 4)) = *(undefined4 *)((long)param_3 + (uVar5 - 4))
          ;
        }
      }
      else {
        uVar3 = (ulong)(param_4 - 1 >> 3);
        *(undefined8 *)((long)puVar6 + (uVar5 - 8)) = *(undefined8 *)((long)param_3 + (uVar5 - 8));
        while (uVar3 != 0) {
          uVar3 = uVar3 - 1;
          *puVar6 = *param_3;
          param_3 = param_3 + (ulong)bVar7 * 0x1ffffffffffffffe + 1;
          puVar6 = puVar6 + (ulong)bVar7 * 0x1ffffffffffffffe + 1;
        }
      }
      uVar2 = 0;
    }
  }
  else {
    printf(1,
                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                 ,(ulong)param_4,"ytnef.c",0x30e,100);
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



undefined8 TNEFAttachmentSave(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  long lVar1;
  void *__dest;
  undefined8 uVar2;
  long lVar3;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar3 = lVar1;
    lVar1 = *(long *)(lVar3 + 0x80);
  } while (*(long *)(lVar3 + 0x80) != 0);
  __dest = calloc(1,(long)param_4);
  *(void **)(lVar3 + 0x88) = __dest;
  if (__dest == (void *)0x0) {
    printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x31d);
    uVar2 = 0xffffffff;
  }
  else {
    *(int *)(lVar3 + 0x90) = param_4;
    memcpy(__dest,param_3,(long)param_4);
    uVar2 = 0;
  }
  return uVar2;
}



undefined8 TNEFSubjectHandler(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  undefined8 uVar1;
  ulong uVar2;
  ulong uVar3;
  undefined8 *puVar4;
  byte bVar5;
  
  bVar5 = 0;
  uVar3 = (ulong)param_4;
  if (*(void **)(param_1 + 0x20) != (void *)0x0) {
    free(*(void **)(param_1 + 0x20));
  }
  if (param_4 - 1 < 100) {
    puVar4 = (undefined8 *)calloc((long)(int)(param_4 + 1),1);
    *(undefined8 **)(param_1 + 0x20) = puVar4;
    if (puVar4 == (undefined8 *)0x0) {
      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x135);
      uVar1 = 0xffffffff;
    }
    else {
      *(uint *)(param_1 + 0x28) = param_4;
      if (param_4 < 8) {
        if ((param_4 & 4) == 0) {
          if ((param_4 != 0) && (*(undefined *)puVar4 = *(undefined *)param_3, (param_4 & 2) != 0))
          {
            *(undefined2 *)((long)puVar4 + (uVar3 - 2)) =
                 *(undefined2 *)((long)param_3 + (uVar3 - 2));
          }
        }
        else {
          *(undefined4 *)puVar4 = *(undefined4 *)param_3;
          *(undefined4 *)((long)puVar4 + (uVar3 - 4)) = *(undefined4 *)((long)param_3 + (uVar3 - 4))
          ;
        }
      }
      else {
        uVar2 = (ulong)(param_4 - 1 >> 3);
        *(undefined8 *)((long)puVar4 + (uVar3 - 8)) = *(undefined8 *)((long)param_3 + (uVar3 - 8));
        while (uVar2 != 0) {
          uVar2 = uVar2 - 1;
          *puVar4 = *param_3;
          param_3 = param_3 + (ulong)bVar5 * 0x1ffffffffffffffe + 1;
          puVar4 = puVar4 + (ulong)bVar5 * 0x1ffffffffffffffe + 1;
        }
      }
      uVar1 = 0;
    }
  }
  else {
    printf(1,
                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                 ,uVar3,"ytnef.c",0x133,100);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



//ulong SwapWord(byte *param_1,uint param_2)
//
//{
//  ulong uVar1;
//  long in_FS_OFFSET;
//  
//  uVar1 = 0;
//  if (param_2 != 0) {
//    uVar1 = (ulong)*param_1;
//    if (1 < param_2) {
//      uVar1 = (ulong)CONCAT11(param_1[1],*param_1);
//    }
//  }
//  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar1;
//}
//


undefined8 TNEFVersion(undefined8 param_1,undefined8 param_2,long param_3,uint param_4)

{
  ushort uVar1;
  ushort uVar2;
  undefined8 uVar3;
  
  uVar1 = SwapWord(param_3,(ulong)param_4);
  uVar3 = 0x10286c;
  uVar2 = SwapWord(param_3 + 2,(ulong)(param_4 - 2));
  snprintf(param_1,0x10,1,0x10,"TNEF%i.%i",(ulong)uVar2,(ulong)uVar1,uVar3);
  return 0;
}



undefined8 TNEFSentFor(long param_1,undefined8 param_2,long param_3,int param_4)

{
  ushort uVar1;
  ulong uVar2;
  undefined8 uVar3;
  long lVar4;
  long lVar5;
  ulong uVar6;
  
  uVar6 = SEXT48(param_4);
  if ((long)uVar6 < 1) {
    return 0;
  }
  lVar4 = param_3;
  if (1 < uVar6) {
    do {
      lVar5 = lVar4 + 2;
      uVar2 = SwapWord(lVar4,2);
      if ((long)uVar6 < (long)((lVar5 - param_3) + (uVar2 & 0xffff))) {
        uVar3 = 0x297;
        goto LAB_001029b4;
      }
      if (0 < *(int *)(param_1 + 0x28c)) {
        printf(1,"Sent For : %.*s",uVar2 & 0xffff,lVar5);
      }
      lVar5 = lVar5 + (uVar2 & 0xffff);
      if (uVar6 < (lVar5 - param_3) + 2U) {
        uVar3 = 0x29c;
        goto LAB_001029b4;
      }
      lVar4 = lVar5 + 2;
      uVar1 = SwapWord(lVar5,2);
      if ((long)uVar6 < (long)((lVar4 - param_3) + (ulong)uVar1)) {
        uVar3 = 0x29f;
        goto LAB_001029b4;
      }
      if (0 < *(int *)(param_1 + 0x28c)) {
        printf(1,"<%.*s>\n",(ulong)uVar1,lVar4);
      }
      lVar4 = lVar4 + (ulong)uVar1;
      lVar5 = lVar4 - param_3;
      if ((long)uVar6 <= lVar5) {
        return 0;
      }
    } while (lVar5 + 2U <= uVar6);
  }
  uVar3 = 0x294;
LAB_001029b4:
  printf(1,"Corrupted file detected at %s : %i\n","ytnef.c",uVar3);
  return 0xffffffff;
}



undefined8 TNEFDateHandler(long param_1,int param_2,long param_3,uint param_4)

{
  uint uVar1;
  undefined2 uVar2;
  long lVar3;
  undefined2 *puVar4;
  undefined8 uVar5;
  long lVar6;
  
  if (param_4 < 0xe) {
    uVar5 = 0xffffffff;
  }
  else {
    uVar1 = *(uint *)(&TNEFList + (long)param_2 * 0x38);
    if (uVar1 == 0x38006) {
      puVar4 = (undefined2 *)(param_1 + 0x3e);
      goto LAB_00102ae0;
    }
    if (uVar1 < 0x38007) {
      if (uVar1 == 0x30007) {
        puVar4 = (undefined2 *)(param_1 + 0x266);
        goto LAB_00102ae0;
      }
      if (uVar1 == 0x38005) {
        puVar4 = (undefined2 *)(param_1 + 0x30);
        goto LAB_00102ae0;
      }
      if (uVar1 == 0x30006) {
        puVar4 = (undefined2 *)(param_1 + 600);
        goto LAB_00102ae0;
      }
    }
    else {
      lVar6 = param_1 + 0x140;
      if (uVar1 == 0x38013) {
        do {
          lVar3 = lVar6;
          lVar6 = *(long *)(lVar3 + 0x80);
        } while (lVar6 != 0);
        puVar4 = (undefined2 *)(lVar3 + 0x3e);
LAB_00102ae0:
        lVar6 = param_3;
        do {
          lVar3 = lVar6 + 2;
          uVar2 = SwapWord(lVar6,2);
          *puVar4 = uVar2;
          puVar4 = puVar4 + 1;
          lVar6 = lVar3;
        } while (param_3 + 0xe != lVar3);
        return 0;
      }
      if (uVar1 == 0x38020) {
        puVar4 = (undefined2 *)(param_1 + 0x1e8);
        goto LAB_00102ae0;
      }
      if (uVar1 == 0x38012) {
        do {
          lVar3 = lVar6;
          lVar6 = *(long *)(lVar3 + 0x80);
        } while (lVar6 != 0);
        puVar4 = (undefined2 *)(lVar3 + 0x30);
        goto LAB_00102ae0;
      }
    }
    uVar5 = 0xfffffff9;
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("MISSING CASE");
    }
  }
  return uVar5;
}



//ulong SwapDWord(long param_1,uint param_2)
//
//{
//  long lVar1;
//  ulong uVar2;
//  long in_FS_OFFSET;
//  uint local_14;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_14 = 0;
//  if (4 < param_2) {
//    param_2 = 4;
//  }
//  if (param_2 == 0) {
//    uVar2 = 0;
//  }
//  else {
//    lVar1 = 0;
//    do {
//      *(undefined *)((long)&local_14 + lVar1) = *(undefined *)(param_1 + lVar1);
//      lVar1 = lVar1 + 1;
//    } while ((int)lVar1 < (int)param_2);
//    uVar2 = (ulong)local_14;
//  }
//  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar2;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}
//


undefined8 TNEFRecipTable(undefined8 param_1,undefined8 param_2,undefined8 param_3,uint param_4)

{
  undefined8 uVar1;
  
  if (param_4 < 4) {
    printf(1,"Corrupted file detected at %s : %i\n","ytnef.c",0x171);
    uVar1 = 0xffffffff;
  }
  else {
    SwapDWord(param_3,4);
    uVar1 = 0;
  }
  return uVar1;
}



undefined8 TNEFPriority(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = SwapDWord(param_3,(ulong)param_4);
  if (iVar1 == 2) {
    *(undefined4 *)(param_1 + 0x130) = 0x6d726f6e;
    *(undefined *)(param_1 + 0x136) = 0;
    *(undefined2 *)(param_1 + 0x134) = 0x6c61;
    return 0;
  }
  if (iVar1 != 3) {
    uVar2 = 0x776f6c;
    if (iVar1 != 1) {
      uVar2 = 0x412f4e;
    }
    *(undefined4 *)(param_1 + 0x130) = uVar2;
    return 0;
  }
  *(undefined4 *)(param_1 + 0x130) = 0x68676968;
  *(undefined *)(param_1 + 0x134) = 0;
  return 0;
}



//long SwapDDWord(long param_1,uint param_2)
//
//{
//  long lVar1;
//  long lVar2;
//  long in_FS_OFFSET;
//  long local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_18 = 0;
//  if (8 < param_2) {
//    param_2 = 8;
//  }
//  lVar1 = 0;
//  lVar2 = lVar1;
//  if (param_2 != 0) {
//    do {
//      *(undefined *)((long)&local_18 + lVar1) = *(undefined *)(param_1 + lVar1);
//      lVar1 = lVar1 + 1;
//      lVar2 = local_18;
//    } while ((int)lVar1 < (int)param_2);
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//    local_18 = lVar2;
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return lVar2;
//}



//byte * to_utf8(long param_1,long param_2)
//
//{
//  long lVar1;
//  byte bVar2;
//  byte bVar3;
//  uint uVar4;
//  byte *pbVar5;
//  uint uVar6;
//  byte *pbVar7;
//  byte *pbVar8;
//  int iVar9;
//  int iVar10;
//  
//  pbVar5 = (byte *)malloc(((ulong)(param_1 * 3) >> 1) + 1);
//  pbVar7 = pbVar5;
//  if (param_1 != 1) {
//    lVar1 = param_2 + 2 + (param_1 - 2U & 0xfffffffffffffffe);
//    iVar10 = 0;
//    do {
//      while( true ) {
//        uVar4 = SwapWord(param_2,2);
//        iVar9 = iVar10 + 1;
//        pbVar8 = pbVar5 + iVar10;
//        pbVar7 = pbVar5 + iVar9;
//        if (0x7f < (uVar4 & 0xffff)) break;
//        *pbVar8 = (byte)uVar4 & 0x7f;
//LAB_00102d78:
//        param_2 = param_2 + 2;
//        iVar10 = iVar9;
//        if (param_2 == lVar1) goto LAB_00102ddc;
//      }
//      uVar6 = uVar4 & 0xffff;
//      bVar3 = (byte)uVar4 & 0x3f | 0x80;
//      bVar2 = (byte)(uVar6 >> 6);
//      if (0x7fe < uVar6) {
//        iVar9 = iVar10 + 3;
//        *pbVar8 = (byte)(uVar6 >> 0xc) | 0xe0;
//        *pbVar7 = bVar2 & 0x3f | 0x80;
//        pbVar5[iVar10 + 2] = bVar3;
//        pbVar7 = pbVar5 + iVar9;
//        goto LAB_00102d78;
//      }
//      param_2 = param_2 + 2;
//      *pbVar8 = bVar2 | 0xc0;
//      *pbVar7 = bVar3;
//      pbVar7 = pbVar5 + (iVar10 + 2);
//      iVar10 = iVar10 + 2;
//    } while (param_2 != lVar1);
//  }
//LAB_00102ddc:
//  *pbVar7 = 0;
//  return pbVar5;
//}
//


ulong FUN_2e20(long param_1,long param_2,ulong param_3,uint *param_4)

{
  undefined auVar1 [16];
  char cVar2;
  void *__src;
  undefined2 uVar3;
  int iVar4;
  uint uVar5;
  undefined4 uVar6;
  undefined *puVar7;
  ulong uVar8;
  undefined4 *puVar9;
  void *__dest;
  long lVar10;
  ulong uVar11;
  uint uVar12;
  undefined8 uVar13;
  uint uVar14;
  size_t __nmemb;
  long lVar15;
  undefined *puVar16;
  undefined *__src_00;
  undefined *puVar17;
  undefined8 uVar18;
  uint uVar19;
  void **ppvVar20;
  undefined4 *puVar21;
  long in_FS_OFFSET;
  bool bVar22;
  uint local_80;
  undefined2 local_4e;
  undefined4 local_4c;
  undefined8 local_48;
  long local_40;
  
  puVar7 = (undefined *)(param_3 & 0xffffffff);
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (puVar7 < (undefined *)0x4) {
    uVar13 = 0x1aa;
LAB_0010386f:
    local_80 = 0xffffffff;
    printf(1,"Corrupted file detected at %s : %i\n","ytnef.c",uVar13);
  }
  else {
    uVar8 = SwapDWord(param_2,4);
    uVar11 = uVar8 & 0xffffffff;
    if ((int)uVar8 - 1U < 1000) {
      puVar21 = (undefined4 *)calloc((long)(int)(uint)uVar11,0x30);
      *(undefined4 **)(param_4 + 2) = puVar21;
      if (puVar21 == (undefined4 *)0x0) {
        uVar13 = 0x1b0;
LAB_00103992:
        local_80 = 0xffffffff;
        printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar13);
      }
      else {
        uVar19 = 0;
        *param_4 = (uint)uVar11;
        local_80 = 0xffffffff;
        puVar16 = (undefined *)(param_2 + 4);
        do {
          if (local_80 == 0xffffffff) {
            if (puVar7 < puVar16 + (4 - param_2)) {
              uVar13 = 0x1b6;
            }
            else {
              __src_00 = puVar16 + 4;
              iVar4 = SwapDWord(puVar16,4);
              puVar21[5] = iVar4;
              *puVar21 = 0;
              puVar21[7] = 0;
              if (-1 < iVar4) {
LAB_0010320b:
                if (2 < *(int *)(param_1 + 0x28c)) {
                  printf(1,"DEBUG(%i/%i):",3);
                  printf(1,"Type id = %04x, Prop id = %04x",(ulong)(ushort)puVar21[5]);
                  putchar(10);
                }
                uVar12 = puVar21[5];
                if ((uVar12 & 0x1000) == 0) {
                  __nmemb = 1;
                  iVar4 = 1;
                  puVar16 = __src_00;
                  uVar12 = local_80;
                }
                else {
                  puVar21[5] = uVar12 & 0xffff0000 | (uVar12 & 0xffff) - 0x1000;
                  if (puVar7 < __src_00 + (4 - param_2)) {
                    uVar13 = 0x1e8;
                    goto LAB_001037d9;
                  }
                  uVar8 = SwapDWord(__src_00,4);
                  uVar11 = uVar8 & 0xffffffff;
                  iVar4 = (int)uVar11;
                  if (999 < (int)uVar8 - 1U) {
                    uVar18 = 1000;
                    uVar13 = 0x1ed;
LAB_0010380b:
                    printf(1,
                                 "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                                 ,uVar11,"ytnef.c",uVar13,uVar18);
                    goto LAB_00103495;
                  }
                  __nmemb = SEXT48(iVar4);
                  puVar16 = __src_00 + 4;
                  uVar12 = 0;
                }
                ppvVar20 = (void **)calloc(__nmemb,0x10);
                *(void ***)(puVar21 + 10) = ppvVar20;
                if (ppvVar20 != (void **)0x0) {
                  puVar21[6] = iVar4;
                  local_80 = uVar12;
                  goto LAB_00102ef3;
                }
                printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x1ef);
                goto LAB_00103495;
              }
              if ((long)(__src_00 + (0xf - param_2)) < (long)puVar7) {
                    // WARNING: Load size is inaccurate
                auVar1[0] = *(undefined *)(puVar16 + 4);
                if (puVar16 + 0x14 + (4 - param_2) <= puVar7) {
                  __src_00 = puVar16 + 0x18;
                  uVar8 = SwapDWord(SUB168(auVar1,0),puVar16 + 0x14);
                  iVar4 = (int)uVar8;
                  if (iVar4 == 0) {
                    if (puVar7 < __src_00 + (4 - param_2)) {
                      uVar13 = 0x1dc;
                      goto LAB_001037d9;
                    }
                    uVar3 = SwapDWord(__src_00,4);
                    *(undefined2 *)((long)puVar21 + 0x16) = uVar3;
                    __src_00 = puVar16 + 0x1c;
                  }
                  else {
                    if (999 < iVar4 - 1U) {
                      printf(1,
                                   "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                                   ,uVar8 & 0xffffffff,"ytnef.c",0x1c7,1000);
                      goto LAB_00103495;
                    }
                    __dest = calloc(uVar8 & 0xffffffff,0x10);
                    *(void **)(puVar21 + 8) = __dest;
                    if (__dest == (void *)0x0) {
                      printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x1c9);
                      goto LAB_00103495;
                    }
                    lVar10 = (ulong)(iVar4 - 1U) << 4;
                    puVar21[7] = iVar4;
                    do {
                      local_80 = 0xffffffff;
                      if (puVar7 < __src_00 + (4 - param_2)) {
                        uVar13 = 0x1cc;
                        goto LAB_001037d9;
                      }
                      uVar8 = SwapDWord(__src_00,4);
                      uVar11 = uVar8 & 0xffffffff;
                      uVar12 = (uint)uVar11;
                      if (99 < (int)uVar8 - 1U) {
                        uVar18 = 100;
                        uVar13 = 0x1cf;
                        goto LAB_0010380b;
                      }
                      lVar15 = *(long *)(puVar21 + 8);
                      __dest = calloc((ulong)(uVar12 + 1),1);
                      *(void **)(lVar15 + lVar10) = __dest;
                      if (__dest == (void *)0x0) {
                        printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x1d1);
                        goto LAB_00103495;
                      }
                      *(uint *)((void **)(lVar15 + lVar10) + 1) = uVar12;
                      if ((long)puVar7 < (long)(__src_00 + 4 + (uVar11 - param_2))) {
                        uVar13 = 0x1d3;
                        goto LAB_001037d9;
                      }
                      if (uVar12 >> 1 != 0) {
                        lVar15 = 0;
                        while( true ) {
                          *(undefined *)((long)__dest + lVar15) = __src_00[lVar15 * 2 + 4];
                          lVar15 = lVar15 + 1;
                          if ((ulong)((uVar12 >> 1) - 1) + 1 == lVar15) break;
                          __dest = *(void **)(*(long *)(puVar21 + 8) + lVar10);
                        }
                      }
                      if ((uVar8 & 3) != 0) {
                        uVar11 = (ulong)((uVar12 + 4) - (uVar12 & 3));
                      }
                      lVar10 = lVar10 + -0x10;
                      __src_00 = __src_00 + 4 + uVar11;
                    } while (lVar10 != -0x10);
                  }
                  *puVar21 = 1;
                  goto LAB_0010320b;
                }
                uVar13 = 0x1c3;
              }
              else {
                uVar13 = 0x1bf;
              }
            }
LAB_001037d9:
            printf(1,"Corrupted file detected at %s : %i\n","ytnef.c",uVar13);
            goto LAB_00103495;
          }
          uVar19 = uVar19 - 1;
          ppvVar20 = (void **)((long)(int)(local_80 + 1) * 0x10 + *(long *)(puVar21 + 10));
          local_80 = local_80 + 1;
LAB_00102ef3:
          uVar12 = puVar21[5];
          uVar5 = uVar12 & 0xffff;
          if (uVar5 < 0xc) {
            if (9 < uVar5) {
LAB_001034ce:
              *(undefined4 *)(ppvVar20 + 1) = 4;
              __dest = calloc(4,1);
              *ppvVar20 = __dest;
              if (__dest == (void *)0x0) {
                uVar13 = 0x235;
                goto LAB_00103909;
              }
              if ((long)(puVar16 + (3 - param_2)) < (long)puVar7) {
                __src_00 = puVar16 + 4;
                local_4c = SwapDWord(puVar16,4);
                memcpy(*ppvVar20,&local_4c,(long)*(int *)(ppvVar20 + 1));
                uVar12 = puVar21[5];
                goto LAB_00102f64;
              }
              uVar13 = 0x236;
              goto LAB_0010386f;
            }
            if (4 < uVar5) {
              if (uVar5 == 5) goto LAB_0010332f;
              if (7 < uVar5) goto LAB_00103484;
              goto LAB_001034ce;
            }
            if (2 < uVar5) goto LAB_001034ce;
            if (uVar5 != 2) goto LAB_00103484;
            *(undefined4 *)(ppvVar20 + 1) = 2;
            __dest = calloc(2,2);
            *ppvVar20 = __dest;
            local_4e = SwapWord(puVar16,2);
            __src_00 = puVar16 + 4;
            memcpy(*ppvVar20,&local_4e,(long)*(int *)(ppvVar20 + 1));
            uVar12 = (uint)puVar21[5] >> 0x10;
            bVar22 = uVar12 == 0x49;
            if (!bVar22) goto LAB_00102f70;
LAB_00103070:
            uVar12 = *(uint *)(param_1 + 0x28c);
            if ((int)uVar12 < 3) goto LAB_00103084;
LAB_001032b0:
            printf(1,"DEBUG(%i/%i): %s\n",3,(ulong)uVar12,"Got a Subject");
            if (*(int *)(param_1 + 0x28) == 0) {
              if (2 < (int)*(uint *)(param_1 + 0x28c)) {
                printf(1,"DEBUG(%i/%i): %s\n",3,(ulong)*(uint *)(param_1 + 0x28c),
                             "Assigning a Subject");
              }
              goto LAB_00103094;
            }
          }
          else {
            if (uVar5 < 0x20) {
              if ((0x1d < uVar5) || (uVar5 == 0xd)) goto LAB_001033a0;
              if (uVar5 != 0x14) goto LAB_00103484;
LAB_0010332f:
              *(undefined4 *)(ppvVar20 + 1) = 8;
              __dest = calloc(8,1);
              *ppvVar20 = __dest;
              if (__dest == (void *)0x0) {
                uVar13 = 0x241;
                goto LAB_00103909;
              }
              if ((long)puVar7 <= (long)(puVar16 + (7 - param_2))) {
                uVar13 = 0x242;
                goto LAB_0010386f;
              }
              __src_00 = puVar16 + 8;
              local_48 = SwapDDWord(puVar16,8);
              memcpy(*ppvVar20,&local_48,(long)*(int *)(ppvVar20 + 1));
              uVar12 = puVar21[5];
            }
            else {
              if (uVar5 == 0x48) {
                *(undefined4 *)(ppvVar20 + 1) = 0x10;
                puVar9 = (undefined4 *)calloc(0x10,1);
                *(undefined4 **)ppvVar20 = puVar9;
                if (puVar9 != (undefined4 *)0x0) {
                  if ((long)(puVar16 + (0x10 - param_2)) <= (long)puVar7) {
                    // WARNING: Load size is inaccurate
                    auVar1[0] = *(undefined *)puVar16;
                    __src_00 = puVar16 + 0x10;
                    goto LAB_00102f64;
                  }
                  uVar13 = 0x24c;
                  goto LAB_0010386f;
                }
                uVar13 = 0x24b;
LAB_00103909:
                local_80 = 0xffffffff;
                printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar13);
                goto LAB_00103495;
              }
              if (uVar5 != 0x102) {
                if (uVar5 == 0x40) goto LAB_0010332f;
LAB_00103484:
                local_80 = 0xffffffff;
                puts("Bad file");
                goto LAB_00103495;
              }
LAB_001033a0:
              __src_00 = puVar16 + (4 - param_2);
              puVar17 = puVar16;
              if (local_80 == 0xffffffff) {
                if (puVar7 < __src_00) {
                  uVar13 = 0x1ff;
                  goto LAB_001037d9;
                }
                puVar17 = puVar16 + 4;
                uVar6 = SwapDWord(puVar16,4);
                *(undefined4 *)(ppvVar20 + 1) = uVar6;
                __src_00 = puVar17 + (4 - param_2);
              }
              if (puVar7 < __src_00) {
                uVar13 = 0x204;
                goto LAB_0010386f;
              }
              __src_00 = puVar17 + 4;
              uVar11 = SwapDWord(puVar17,4);
              uVar5 = (uint)uVar11;
              *(uint *)(ppvVar20 + 1) = uVar5;
              if (uVar5 == 0) {
                uVar12 = puVar21[5];
                *ppvVar20 = (void *)0x0;
                uVar14 = 0;
              }
              else {
                __nmemb = SEXT48((int)uVar5);
                if ((long)puVar7 < (long)(__src_00 + (__nmemb - param_2))) {
                  uVar13 = 0x20a;
                  goto LAB_0010386f;
                }
                if (99999 < uVar5 - 1) {
                  uVar18 = 100000;
                  uVar13 = 0x20b;
                  uVar11 = uVar11 & 0xffffffff;
                  goto LAB_001038a8;
                }
                uVar12 = puVar21[5];
                if ((short)uVar12 == 0x1f) {
                  __dest = (void *)to_utf8(__nmemb,__src_00);
                  *ppvVar20 = __dest;
                  if (__dest == (void *)0x0) goto LAB_00102fe9;
                  uVar12 = puVar21[5];
                }
                else {
                  __dest = calloc(__nmemb,1);
                  *ppvVar20 = __dest;
                  if (__dest == (void *)0x0) {
                    uVar13 = 0x212;
                    goto LAB_00103909;
                  }
                  memcpy(__dest,__src_00,__nmemb);
                }
                uVar5 = *(uint *)(ppvVar20 + 1);
                uVar14 = uVar5 & 3;
                if (uVar14 != 0) {
                  uVar14 = 4 - uVar14;
                }
              }
              __src_00 = __src_00 + (uVar5 + uVar14);
            }
LAB_00102f64:
            uVar12 = uVar12 >> 0x10;
            bVar22 = uVar12 == 0x49;
            if (bVar22) goto LAB_00103070;
LAB_00102f70:
            if (0x48 < uVar12 && !bVar22) {
              if ((uVar12 == 0x70) || (uVar12 == 0xe1d)) goto LAB_00103070;
              goto LAB_00102f8b;
            }
            if (1 < uVar12 - 0x37) goto LAB_00102f8b;
            uVar12 = *(uint *)(param_1 + 0x28c);
            if (2 < (int)uVar12) goto LAB_001032b0;
LAB_00103084:
            if (*(int *)(param_1 + 0x28) == 0) {
LAB_00103094:
              uVar12 = *(uint *)(ppvVar20 + 1);
              uVar11 = (ulong)uVar12;
              if (99 < uVar12 - 1) {
                uVar18 = 100;
                uVar13 = 0x25f;
                goto LAB_001038a8;
              }
              __dest = calloc((long)(int)(uVar12 + 1),1);
              *(void **)(param_1 + 0x20) = __dest;
              if (__dest == (void *)0x0) {
                uVar13 = 0x261;
                goto LAB_00103992;
              }
              __src = *ppvVar20;
              *(uint *)(param_1 + 0x28) = uVar12;
              __dest = memcpy(__dest,__src,(long)*(int *)(ppvVar20 + 1));
              lVar10 = 0;
              while( true ) {
                cVar2 = *(char *)((long)__dest + lVar10);
                if (((cVar2 == '/') || (cVar2 == '\\')) || (cVar2 == '\0')) {
                  *(char *)((long)__dest + lVar10) = '_';
                }
                iVar4 = (int)lVar10;
                lVar10 = lVar10 + 1;
                if (*(int *)(param_1 + 0x28) == iVar4 + 1) break;
                __dest = *(void **)(param_1 + 0x20);
              }
            }
          }
LAB_00102f8b:
          if ((puVar21[6] - 1 == local_80) || (local_80 == 0xffffffff)) {
            puVar21 = puVar21 + 0xc;
            local_80 = 0xffffffff;
          }
          uVar19 = uVar19 + 1;
          puVar16 = __src_00;
        } while (uVar19 <= *param_4 && *param_4 != uVar19);
        __src_00 = __src_00 + -param_2;
        if ((long)__src_00 < (long)puVar7) {
          if (0 < *(int *)(param_1 + 0x28c)) {
            puts("ERROR DURING MAPI READ");
            printf(1,"Read %td bytes, Expected %u bytes\n",__src_00,puVar7);
            printf(1,"%td bytes missing\n",puVar7 + -(long)__src_00);
          }
        }
        else {
          local_80 = 0;
          if ((long)__src_00 <= (long)puVar7) goto LAB_00103495;
          if (0 < *(int *)(param_1 + 0x28c)) {
            local_80 = 0xffffffff;
            puts("ERROR DURING MAPI READ");
            printf(1,"Read %td bytes, Expected %u bytes\n",__src_00,puVar7);
            printf(1,"%li bytes extra\n",__src_00 + -(long)puVar7);
            goto LAB_00103495;
          }
        }
LAB_00102fe9:
        local_80 = 0xffffffff;
      }
    }
    else {
      uVar18 = 1000;
      uVar13 = 0x1ae;
LAB_001038a8:
      local_80 = 0xffffffff;
      printf(1,
                   "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                   ,uVar11,"ytnef.c",uVar13,uVar18);
    }
  }
LAB_00103495:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (ulong)local_80;
}



void TNEFAttachmentMAPI(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)

{
  long lVar1;
  long lVar2;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar2 = lVar1;
    lVar1 = *(long *)(lVar2 + 0x80);
  } while (lVar1 != 0);
  TNEFFillMapi(param_1,param_3,(ulong)param_4,lVar2 + 0x70);
  return;
}


/*
void TNEFPrintDate(ulong param_1,ulong param_2)

{
  ulong uVar1;
  ushort uVar2;
  long in_FS_OFFSET;
  undefined8 local_158;
  undefined4 local_150;
  undefined2 local_14c;
  undefined local_14a;
  undefined8 local_149;
  undefined4 local_141;
  undefined2 local_13d;
  undefined local_13b;
  undefined8 local_13a;
  undefined4 local_132;
  undefined2 local_12e;
  undefined local_12c;
  undefined8 local_12b;
  undefined4 local_123;
  undefined2 local_11f;
  undefined local_11d;
  undefined8 local_11c;
  undefined4 local_114;
  undefined2 local_110;
  undefined local_10e;
  undefined8 local_10d;
  undefined4 local_105;
  undefined2 local_101;
  undefined local_ff;
  undefined8 local_fe;
  undefined4 local_f6;
  undefined2 local_f2;
  undefined local_f0;
  undefined8 local_e8;
  undefined4 local_e0;
  undefined2 local_dc;
  undefined local_da;
  undefined8 local_d9;
  undefined4 local_d1;
  undefined2 local_cd;
  undefined local_cb;
  undefined8 local_ca;
  undefined4 local_c2;
  undefined2 local_be;
  undefined local_bc;
  undefined8 local_bb;
  undefined4 local_b3;
  undefined2 local_af;
  undefined local_ad;
  undefined8 local_ac;
  undefined4 local_a4;
  undefined2 local_a0;
  undefined local_9e;
  undefined8 local_9d;
  undefined4 local_95;
  undefined2 local_91;
  undefined local_8f;
  undefined8 local_8e;
  undefined4 local_86;
  undefined2 local_82;
  undefined local_80;
  undefined8 local_7f;
  undefined4 local_77;
  undefined2 local_73;
  undefined local_71;
  undefined8 local_70;
  undefined4 local_68;
  undefined2 local_64;
  undefined local_62;
  undefined8 local_61;
  undefined4 local_59;
  undefined2 local_55;
  undefined local_53;
  undefined8 local_52;
  undefined4 local_4a;
  undefined2 local_46;
  undefined local_44;
  undefined8 local_43;
  undefined4 local_3b;
  undefined2 local_37;
  undefined local_35;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  local_158 = 0x7961646e7553;
  local_149 = 0x7961646e6f4d;
  uVar2 = (ushort)(param_2 >> 0x20);
  local_13a = 0x79616473657554;
  local_12b = 0x616473656e646557;
  local_11c = 0x7961647372756854;
  local_14c = 0;
  local_10d = 0x796164697246;
  local_13d = 0;
  local_12e = 0;
  local_11f = 0;
  local_110 = 0;
  local_101 = 0;
  local_150 = 0;
  local_14a = 0;
  local_141 = 0;
  local_13b = 0;
  local_132 = 0;
  local_12c = 0;
  local_123 = 0x79;
  local_11d = 0;
  local_114 = 0;
  local_10e = 0;
  local_105 = 0;
  local_ff = 0;
  local_fe = 0x7961647275746153;
  local_f6 = 0;
  local_e8 = 0x797261756e614a;
  local_f2 = 0;
  local_dc = 0;
  local_f0 = 0;
  local_d9 = 0x7972617572626546;
  local_e0 = 0;
  local_cd = 0;
  local_da = 0;
  local_ca = 0x686372614d;
  local_d1 = 0;
  local_be = 0;
  local_cb = 0;
  local_bb = 0x6c69727041;
  local_c2 = 0;
  local_af = 0;
  local_bc = 0;
  local_a0 = 0;
  local_b3 = 0;
  local_91 = 0;
  local_ad = 0;
  local_ac = 0x79614d;
  local_a4 = 0;
  uVar1 = (param_2 & 0xffffffff) >> 0x10;
  local_9e = 0;
  local_9d = 0x656e754a;
  local_95 = 0;
  local_8f = 0;
  local_8e = 0x796c754a;
  local_86 = 0;
  local_82 = 0;
  local_80 = 0;
  local_7f = 0x747375677541;
  local_77 = 0;
  local_70 = 0x65626d6574706553;
  local_73 = 0;
  local_61 = 0x7265626f74634f;
  local_71 = 0;
  local_52 = 0x7265626d65766f4e;
  local_68 = 0x72;
  local_64 = 0;
  local_62 = 0;
  local_59 = 0;
  local_55 = 0;
  local_53 = 0;
  local_4a = 0;
  local_46 = 0;
  local_44 = 0;
  local_43 = 0x7265626d65636544;
  local_3b = 0;
  local_37 = 0;
  local_35 = 0;
  if (uVar2 < 7) {
    printf(1,&DAT_001065b2,(undefined8 *)((long)&local_158 + (ulong)uVar2 * 0xf));
  }
  if ((ushort)((short)((param_1 & 0xffffffff) >> 0x10) - 1U) < 0xc) {
    printf(1,&DAT_001065b2,
                 (undefined8 *)
                 ((long)&local_e8 + (long)((int)((param_1 & 0xffffffff) >> 0x10) + -1) * 0xf));
  }
  printf(1,"%hu, %hu ",param_1 >> 0x20 & 0xffff,param_1 & 0xffff);
  uVar2 = (ushort)(param_1 >> 0x30);
  param_2 = param_2 & 0xffff;
  if (uVar2 < 0xd) {
    if (uVar2 == 0xc) {
      printf(1,"%hu:%02hu:%02hu pm",0xc,param_2,uVar1);
    }
    else {
      printf(1,"%hu:%02hu:%02hu am",(ulong)uVar2,param_2,uVar1);
    }
  }
  else {
    printf(1,"%i:%02hu:%02hu pm",(ulong)((uint)uVar2 - 0xc),param_2,uVar1);
  }
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}
*/



undefined8 TNEFHexBreakdown(long param_1,int param_2,char *param_3,int param_4)

{
  ulong uVar1;
  
  if (*(int *)(param_1 + 0x28c) == 0) {
    return 0;
  }
  printf(1,"%s: [%i bytes] \n",&DAT_00316244 + (long)param_2 * 0x38);
  if (0 < param_4) {
    uVar1 = 2;
    printf(1,"%02x ",(ulong)(uint)(int)*param_3);
    while ((ulong)(param_4 - 1) + 2 != uVar1) {
      printf(1,"%02x ",(ulong)(uint)(int)param_3[uVar1 - 1]);
      if ((uVar1 & 0xf) == 0) {
        putchar(10);
      }
      uVar1 = uVar1 + 1;
    }
  }
  putchar(10);
  return 0;
}



undefined8 TNEFDetailedPrint(long param_1,int param_2,char *param_3,int param_4)

{
  char *pcVar1;
  char cVar2;
  
  if (*(int *)(param_1 + 0x28c) == 0) {
    return 0;
  }
  printf(1,"%s: [%i bytes] \n",&DAT_00316244 + (long)param_2 * 0x38);
  if (0 < param_4) {
    pcVar1 = param_3 + (ulong)(param_4 - 1) + 1;
    do {
      cVar2 = *param_3;
      param_3 = param_3 + 1;
      putchar((int)cVar2);
    } while (param_3 != pcVar1);
  }
  putchar(10);
  return 0;
}


/*
ulong TNEFCheckForSignature(undefined4 param_1)

{
  int iVar1;
  undefined4 local_c [3];
  
  local_c[0] = param_1;
  iVar1 = SwapDWord(local_c,4);
  return (ulong)(((uint)(iVar1 == 0x223e9f78) - 2) + (uint)(iVar1 == 0x223e9f78));
}




undefined8 TNEFGetKey(long param_1,ushort *param_2)

{
  ushort uVar1;
  int iVar2;
  
  iVar2 = (**(void*(*)())(param_1 + 0x298))(param_1 + 0x290,2,1);
  if (0 < iVar2) {
    uVar1 = SwapWord(param_2,2);
    iVar2 = *(int *)(param_1 + 0x28c);
    *param_2 = uVar1;
    if (1 < iVar2) {
      printf(1,"DEBUG(%i/%i):",2);
      printf(1,"Key = 0x%X",(ulong)*param_2);
      putchar(10);
      if (1 < *(int *)(param_1 + 0x28c)) {
        printf(1,"DEBUG(%i/%i):",2);
        printf(1,"Key = %i",(ulong)*param_2);
        putchar(10);
      }
    }
    return 0;
  }
  if (0 < *(int *)(param_1 + 0x28c)) {
    puts("Error reading Key");
    return 0xfffffffd;
  }
  return 0xfffffffd;
}



undefined8 TNEFGetHeader(long param_1,uint *param_2,uint *param_3)

{
  long lVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (1 < (int)*(uint *)(param_1 + 0x28c)) {
    printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                 "About to read Component");
  }
  lVar1 = param_1 + 0x290;
  iVar3 = (**(void*(*)())(param_1 + 0x298))(lVar1,1,1);
  if (0 < iVar3) {
    if (1 < (int)*(uint *)(param_1 + 0x28c)) {
      printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),"About to read type");
    }
    iVar3 = (**(void*(*)())(param_1 + 0x298))(lVar1,4,1);
    if (iVar3 < 1) {
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading type");
        uVar5 = 0xfffffffd;
        goto LAB_0010435f;
      }
    }
    else {
      if (1 < *(int *)(param_1 + 0x28c)) {
        printf(1,"DEBUG(%i/%i):",2);
        printf(1,"Type = 0x%X",(ulong)*param_2);
        putchar(10);
        if (1 < *(int *)(param_1 + 0x28c)) {
          printf(1,"DEBUG(%i/%i):",2);
          printf(1,"Type = %u",(ulong)*param_2);
          putchar(10);
          if (1 < (int)*(uint *)(param_1 + 0x28c)) {
            printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                         "About to read size");
          }
        }
      }
      iVar3 = (**(void*(*)())(param_1 + 0x298))(lVar1,4,1);
      if (0 < iVar3) {
        if (1 < *(int *)(param_1 + 0x28c)) {
          printf(1,"DEBUG(%i/%i):",2);
          printf(1,"Size = %u",(ulong)*param_3);
          putchar(10);
        }
        uVar4 = SwapDWord(param_2,4);
        *param_2 = uVar4;
        uVar4 = SwapDWord(param_3,4);
        *param_3 = uVar4;
        uVar5 = 0;
        goto LAB_0010435f;
      }
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading size");
        uVar5 = 0xfffffffd;
        goto LAB_0010435f;
      }
    }
  }
  uVar5 = 0xfffffffd;
LAB_0010435f:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFRawRead(long param_1,byte *param_2,undefined8 param_3,undefined2 *param_4)

{
  byte *pbVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  
  uVar3 = (uint)param_3;
  uVar4 = (**(void*(*)())(param_1 + 0x298))(param_1 + 0x290,1,param_3,param_2);
  if (uVar3 <= uVar4) {
    if ((param_4 != (undefined2 *)0x0) && (*param_4 = 0, uVar3 != 0)) {
      pbVar1 = param_2 + (ulong)(uVar3 - 1) + 1;
      iVar5 = 0;
      do {
        bVar2 = *param_2;
        param_2 = param_2 + 1;
        iVar5 = iVar5 + (uint)bVar2;
        *param_4 = (short)iVar5;
      } while (param_2 != pbVar1);
    }
    return 0;
  }
  if (*(int *)(param_1 + 0x28c) < 1) {
    return 0xfffffffd;
  }
  puts("ERROR: Error reading data");
  return 0xfffffffd;
}



void TNEFInitMapi(undefined4 *param_1)

{
  *param_1 = 0;
  *(undefined8 *)(param_1 + 2) = 0;
  return;
}



void TNEFInitAttachment(undefined8 *param_1)

{
  *param_1 = 0;
  *(undefined4 *)(param_1 + 1) = 0;
  *(undefined2 *)((long)param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)((long)param_1 + 100) = 0;
  *(undefined4 *)(param_1 + 0xd) = 0;
  *(undefined4 *)((long)param_1 + 0x6c) = 0;
  param_1[2] = 0;
  *(undefined4 *)(param_1 + 3) = 0;
  param_1[4] = 0;
  *(undefined4 *)(param_1 + 5) = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  *(undefined4 *)(param_1 + 9) = 0;
  param_1[10] = 0;
  *(undefined4 *)(param_1 + 0xb) = 0;
  param_1[0x11] = 0;
  *(undefined4 *)(param_1 + 0x12) = 0;
  param_1[0x13] = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  TNEFInitMapi(0);
  param_1[0x10] = 0;
  return;
}
*/


undefined8 TNEFRendData(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)

{
  long lVar1;
  void *pvVar2;
  undefined8 uVar3;
  long lVar4;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar4 = lVar1;
    lVar1 = *(long *)(lVar4 + 0x80);
  } while (lVar1 != 0);
  pvVar2 = calloc(1,0xa8);
  *(void **)(lVar4 + 0x80) = pvVar2;
  if (pvVar2 == (void *)0x0) {
    printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x144);
    uVar3 = 0xffffffff;
  }
  else {
    TNEFInitAttachment(pvVar2);
    if (0xf < param_4) {
      param_4 = 0x10;
    }
    memcpy((long)pvVar2 + 0x60,param_3,(long)(int)param_4);
    uVar3 = 0;
  }
  return uVar3;
}



void TNEFInitialize(undefined4 *param_1)

{
  *(undefined2 *)(param_1 + 0x15) = 0;
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  *(undefined2 *)((long)param_1 + 0x86) = 0;
  *(undefined2 *)(param_1 + 0x2e) = 0;
  *(undefined4 *)((long)param_1 + 0x56) = 0;
  *(undefined4 *)((long)param_1 + 0x5a) = 0;
  *(undefined4 *)((long)param_1 + 0x5e) = 0;
  *(undefined4 *)((long)param_1 + 0x62) = 0;
  *(undefined4 *)((long)param_1 + 0x66) = 0;
  *(undefined4 *)((long)param_1 + 0x6a) = 0;
  *(undefined4 *)((long)param_1 + 0x6e) = 0;
  *(undefined4 *)((long)param_1 + 0x72) = 0;
  *(undefined4 *)((long)param_1 + 0x76) = 0;
  *(undefined4 *)((long)param_1 + 0x7a) = 0;
  *(undefined4 *)((long)param_1 + 0x7e) = 0;
  *(undefined4 *)((long)param_1 + 0x82) = 0;
  param_1[0x22] = 0;
  param_1[0x23] = 0;
  param_1[0x24] = 0;
  param_1[0x25] = 0;
  param_1[0x26] = 0;
  param_1[0x27] = 0;
  param_1[0x28] = 0;
  param_1[0x29] = 0;
  param_1[0x2a] = 0;
  param_1[0x2b] = 0;
  param_1[0x2c] = 0;
  param_1[0x2d] = 0;
  *(undefined4 *)((long)param_1 + 0xba) = 0;
  *(undefined4 *)((long)param_1 + 0xbe) = 0;
  *(undefined4 *)((long)param_1 + 0xc2) = 0;
  *(undefined4 *)((long)param_1 + 0xc6) = 0;
  *(undefined4 *)((long)param_1 + 0xca) = 0;
  *(undefined4 *)((long)param_1 + 0xce) = 0;
  *(undefined4 *)((long)param_1 + 0xd2) = 0;
  *(undefined4 *)((long)param_1 + 0xd6) = 0;
  *(undefined4 *)((long)param_1 + 0xda) = 0;
  *(undefined4 *)((long)param_1 + 0xde) = 0;
  *(undefined4 *)((long)param_1 + 0xe2) = 0;
  *(undefined4 *)((long)param_1 + 0xe6) = 0;
  param_1[0x3b] = 0;
  param_1[0x3c] = 0;
  param_1[0x3d] = 0;
  param_1[0x3e] = 0;
  param_1[0x3f] = 0;
  param_1[0x40] = 0;
  param_1[0x41] = 0;
  param_1[0x42] = 0;
  param_1[0x43] = 0;
  param_1[0x44] = 0;
  param_1[0x45] = 0;
  param_1[0x46] = 0;
  *(undefined2 *)((long)param_1 + 0xea) = 0;
  *(undefined8 *)(param_1 + 4) = 0;
  param_1[6] = 0;
  *(undefined8 *)(param_1 + 8) = 0;
  param_1[10] = 0;
  *(undefined8 *)(param_1 + 0xc) = 0;
  *(undefined8 *)(param_1 + 0xe) = 0;
  *(undefined8 *)(param_1 + 0x10) = 0;
  param_1[0x12] = 0;
  *(undefined8 *)(param_1 + 0x13) = 0;
  *(undefined2 *)(param_1 + 0x47) = 0;
  *(undefined2 *)(param_1 + 0x4e) = 0;
  *(undefined8 *)(param_1 + 0x48) = 0;
  param_1[0x4a] = 0;
  *(undefined8 *)(param_1 + 0x4c) = 0;
  TNEFInitAttachment(param_1 + 0x50);
  *(undefined8 *)(param_1 + 0x7a) = 0;
  param_1[0x7c] = 0;
  *(undefined2 *)(param_1 + 0x7d) = 0;
  TNEFInitMapi(param_1 + 0x7e);
  *(undefined8 *)(param_1 + 0x82) = 0;
  param_1[0x84] = 0;
  *(undefined8 *)(param_1 + 0x86) = 0;
  param_1[0x88] = 0;
  *(undefined8 *)(param_1 + 0x8a) = 0;
  param_1[0x8c] = 0;
  *(undefined8 *)(param_1 + 0x8e) = 0;
  param_1[0x90] = 0;
  *(undefined8 *)(param_1 + 0x92) = 0;
  param_1[0x94] = 0;
  *(undefined8 *)(param_1 + 0x96) = 0;
  *(undefined8 *)(param_1 + 0x98) = 0;
  *(undefined8 *)(param_1 + 0x9a) = 0;
  param_1[0x9c] = 0;
  *(undefined8 *)(param_1 + 0x9e) = 0;
  param_1[0xa0] = 0;
  param_1[0xa2] = 0;
  *(undefined8 *)(param_1 + 0xaa) = 0;
  *(undefined8 *)(param_1 + 0xa4) = 0;
  *(undefined8 *)(param_1 + 0xa6) = 0;
  *(undefined8 *)(param_1 + 0xa8) = 0;
  param_1[0xac] = 0x32;
  return;
}



//void TNEFFreeMapiProps(uint *param_1)
//
//{
//  uint *puVar1;
//  int *piVar2;
//  long lVar3;
//  uint uVar4;
//  void *__ptr;
//  long lVar5;
//  uint uVar6;
//  int iVar7;
//  long lVar8;
//  
//  lVar8 = 0;
//  uVar4 = 0;
//  if (*param_1 != 0) {
//    do {
//      lVar3 = *(long *)(param_1 + 2);
//      lVar5 = 0;
//      uVar6 = 0;
//      __ptr = *(void **)(lVar3 + lVar8 + 0x28);
//      if (*(int *)(lVar3 + lVar8 + 0x18) != 0) {
//        do {
//          while (*(int *)((void **)((long)__ptr + lVar5) + 1) < 1) {
//            uVar6 = uVar6 + 1;
//            lVar5 = lVar5 + 0x10;
//            puVar1 = (uint *)(lVar3 + lVar8 + 0x18);
//            __ptr = *(void **)(lVar3 + lVar8 + 0x28);
//            if (*puVar1 < uVar6 || *puVar1 == uVar6) goto LAB_0010495d;
//          }
//          uVar6 = uVar6 + 1;
//          free(*(void **)((long)__ptr + lVar5));
//          lVar3 = *(long *)(param_1 + 2);
//          __ptr = *(void **)(lVar3 + lVar8 + 0x28);
//          *(undefined4 *)((long)__ptr + lVar5 + 8) = 0;
//          lVar5 = lVar5 + 0x10;
//          puVar1 = (uint *)(lVar3 + lVar8 + 0x18);
//        } while (uVar6 <= *puVar1 && *puVar1 != uVar6);
//      }
//LAB_0010495d:
//      free(__ptr);
//      lVar3 = *(long *)(param_1 + 2);
//      __ptr = *(void **)(lVar3 + lVar8 + 0x20);
//      if (0 < *(int *)(lVar3 + lVar8 + 0x1c)) {
//        lVar5 = 0;
//        iVar7 = 0;
//        do {
//          while (*(int *)((void **)((long)__ptr + lVar5) + 1) < 1) {
//            iVar7 = iVar7 + 1;
//            lVar5 = lVar5 + 0x10;
//            piVar2 = (int *)(lVar3 + lVar8 + 0x1c);
//            __ptr = *(void **)(lVar3 + lVar8 + 0x20);
//            if (*piVar2 == iVar7 || *piVar2 < iVar7) goto LAB_001049cb;
//          }
//          iVar7 = iVar7 + 1;
//          free(*(void **)((long)__ptr + lVar5));
//          lVar3 = *(long *)(param_1 + 2);
//          __ptr = *(void **)(lVar3 + lVar8 + 0x20);
//          *(undefined4 *)((long)__ptr + lVar5 + 8) = 0;
//          lVar5 = lVar5 + 0x10;
//          piVar2 = (int *)(lVar3 + lVar8 + 0x1c);
//        } while (*piVar2 != iVar7 && iVar7 <= *piVar2);
//      }
//LAB_001049cb:
//      free(__ptr);
//      uVar4 = uVar4 + 1;
//      lVar8 = lVar8 + 0x30;
//    } while (uVar4 <= *param_1 && *param_1 != uVar4);
//  }
//  free(*(void **)(param_1 + 2));
//  *param_1 = 0;
//  return;
//}
//


//void TNEFFreeAttachment(long param_1)
//
//{
//  if (0 < *(int *)(param_1 + 0x18)) {
//    free(*(void **)(param_1 + 0x10));
//    *(undefined4 *)(param_1 + 0x18) = 0;
//  }
//  if (0 < *(int *)(param_1 + 0x28)) {
//    free(*(void **)(param_1 + 0x20));
//    *(undefined4 *)(param_1 + 0x28) = 0;
//  }
//  if (0 < *(int *)(param_1 + 0x58)) {
//    free(*(void **)(param_1 + 0x50));
//    *(undefined4 *)(param_1 + 0x58) = 0;
//  }
//  if (0 < *(int *)(param_1 + 0x90)) {
//    free(*(void **)(param_1 + 0x88));
//    *(undefined4 *)(param_1 + 0x90) = 0;
//  }
//  if (0 < *(int *)(param_1 + 0xa0)) {
//    free(*(void **)(param_1 + 0x98));
//    *(undefined4 *)(param_1 + 0xa0) = 0;
//  }
//  TNEFFreeMapiProps(param_1 + 0x70);
//  return;
//}
//


void TNEFFree(long param_1)

{
  void *pvVar1;
  void *__ptr;
  
  if (0 < *(int *)(param_1 + 0x18)) {
    free(*(void **)(param_1 + 0x10));
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  if (0 < *(int *)(param_1 + 0x28)) {
    free(*(void **)(param_1 + 0x20));
    *(undefined4 *)(param_1 + 0x28) = 0;
  }
  if (0 < *(int *)(param_1 + 0x128)) {
    free(*(void **)(param_1 + 0x120));
    *(undefined4 *)(param_1 + 0x128) = 0;
  }
  if (0 < *(int *)(param_1 + 0x210)) {
    free(*(void **)(param_1 + 0x208));
    *(undefined4 *)(param_1 + 0x210) = 0;
  }
  if (0 < *(int *)(param_1 + 0x220)) {
    free(*(void **)(param_1 + 0x218));
    *(undefined4 *)(param_1 + 0x220) = 0;
  }
  if (0 < *(int *)(param_1 + 0x230)) {
    free(*(void **)(param_1 + 0x228));
    *(undefined4 *)(param_1 + 0x230) = 0;
  }
  if (0 < *(int *)(param_1 + 0x240)) {
    free(*(void **)(param_1 + 0x238));
    *(undefined4 *)(param_1 + 0x240) = 0;
  }
  if (0 < *(int *)(param_1 + 0x250)) {
    free(*(void **)(param_1 + 0x248));
    *(undefined4 *)(param_1 + 0x250) = 0;
  }
  if (0 < *(int *)(param_1 + 0x280)) {
    free(*(void **)(param_1 + 0x278));
    *(undefined4 *)(param_1 + 0x280) = 0;
  }
  TNEFFreeMapiProps(param_1 + 0x1f8);
  __ptr = *(void **)(param_1 + 0x1c0);
  while (__ptr != (void *)0x0) {
    TNEFFreeAttachment(__ptr);
    pvVar1 = *(void **)((long)__ptr + 0x80);
    free(__ptr);
    __ptr = pvVar1;
  }
  return;
}



/*
undefined8 TNEFParse(long param_1)

{
  uint *puVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  void *pcVar5;
  void *__ptr;
  ulong uVar6;
  undefined8 uVar7;
  uint *puVar8;
  long in_FS_OFFSET;
  undefined local_52 [2];
  short local_50;
  short local_4e;
  uint local_4c;
  uint local_48;
  uint local_44;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(long *)(param_1 + 0x298) == 0) {
    uVar7 = 0xfffffff8;
    puts("ERROR: Setup incorrectly: No ReadProc");
    goto LAB_00104f39;
  }
  pcVar5 = *(void*(*)())(param_1 + 0x290);
  lVar2 = param_1 + 0x290;
  uVar6 = (ulong)*(uint *)(param_1 + 0x28c);
  if (pcVar5 == (void *)0x0) {
LAB_00104eb8:
    if (1 < (int)uVar6) {
      printf(1,"DEBUG(%i/%i): %s\n",2,uVar6,"Reading Signature");
    }
  }
  else {
    if (1 < (int)*(uint *)(param_1 + 0x28c)) {
      printf(1,"DEBUG(%i/%i): %s\n",2,uVar6,"About to initialize");
      pcVar5 = *(void*(*)())(param_1 + 0x290);
    }
    iVar3 = (*pcVar5)(param_1 + 0x290);
    if (iVar3 != 0) {
      uVar7 = 0xffffffff;
      goto LAB_00104f39;
    }
    if (1 < (int)*(uint *)(param_1 + 0x28c)) {
      printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                   "Initialization finished");
      uVar6 = (ulong)*(uint *)(param_1 + 0x28c);
      goto LAB_00104eb8;
    }
  }
  iVar3 = (**(void*(*)())(param_1 + 0x298))(param_1 + 0x290,4,1);
  if (iVar3 < 1) {
    puts("ERROR: Error reading signature");
    pcVar5 = *(void*(*)())(param_1 + 0x2a0);
    uVar7 = 0xfffffffd;
  }
  else {
    if ((int)*(uint *)(param_1 + 0x28c) < 2) {
      iVar3 = TNEFCheckForSignature((ulong)local_44);
    }
    else {
      printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),"Checking Signature");
      iVar3 = TNEFCheckForSignature((ulong)local_44);
    }
    if (iVar3 < 0) {
      puts("ERROR: Signature does not match. Not TNEF.");
      pcVar5 = *(void*(*)())(param_1 + 0x2a0);
      uVar7 = 0xfffffffe;
    }
    else {
      if (1 < (int)*(uint *)(param_1 + 0x28c)) {
        printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),"Reading Key.");
      }
      iVar3 = TNEFGetKey(param_1,local_52);
      if (-1 < iVar3) {
        if (1 < (int)*(uint *)(param_1 + 0x28c)) {
          printf(1,"DEBUG(%i/%i): %s\n",2,(ulong)*(uint *)(param_1 + 0x28c),
                       "Starting Full Processing.");
        }
        while( true ) {
          uVar4 = TNEFGetHeader(param_1,&local_4c,&local_48);
          uVar6 = (ulong)uVar4;
          if (uVar4 != 0) break;
          if (1 < *(int *)(param_1 + 0x28c)) {
            printf(1,"DEBUG(%i/%i):",2);
            printf(1,"Header says type=0x%X, size=%u",(ulong)local_4c);
            putchar(10);
            if (1 < *(int *)(param_1 + 0x28c)) {
              printf(1,"DEBUG(%i/%i):",2);
              printf(1,"Header says type=%u, size=%u",(ulong)local_4c,(ulong)local_48);
              putchar(10);
            }
          }
          uVar4 = local_48;
          if (local_48 == 0) {
            uVar7 = 0xfffffffd;
            puts("ERROR: Field with size of 0");
            goto LAB_00104f39;
          }
          if ((uint)(*(int *)(param_1 + 0x2b0) << 0x14) < local_48) {
            printf(1,
                         "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n"
                         ,(ulong)local_48,"ytnef.c",0x4a2);
            uVar7 = 0xffffffff;
            goto LAB_00104f39;
          }
          __ptr = calloc((ulong)local_48,1);
          if (__ptr == (void *)0x0) {
            uVar7 = 0xffffffff;
            printf(1,"Out of Memory at %s : %i\n","ytnef.c",0x4a4);
            goto LAB_00104f39;
          }
          iVar3 = TNEFRawRead(param_1,__ptr,(ulong)uVar4);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read data.");
            pcVar5 = *(void*(*)())(param_1 + 0x2a0);
joined_r0x001050e2:
            if (pcVar5 != (void *)0x0) {
              (*pcVar5)(lVar2);
            }
            uVar7 = 0xfffffffd;
            free(__ptr);
            goto LAB_00104f39;
          }
          iVar3 = TNEFRawRead(param_1,&local_50,2);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read checksum.");
            pcVar5 = *(void*(*)())(param_1 + 0x2a0);
            goto joined_r0x001050e2;
          }
          local_50 = SwapWord(&local_50,2);
          if (local_50 != local_4e) {
            puts("ERROR: Checksum mismatch. Data corruption?:");
            if (*(void*(*)())(param_1 + 0x2a0) != (void *)0x0) {
              (**(void*(*)())(param_1 + 0x2a0))(lVar2);
            }
            uVar7 = 0xfffffffb;
            free(__ptr);
            goto LAB_00104f39;
          }
          puVar8 = (uint *)&TNEFList;
          do {
            while (*puVar8 != local_4c) {
LAB_00104e10:
              uVar4 = (int)uVar6 + 1;
              uVar6 = (ulong)uVar4;
              puVar8 = puVar8 + 0xe;
              if (uVar4 == 0x21) goto LAB_00104e88;
            }
            if (*(void*(*)())(puVar8 + 0xc) != (void *)0x0) {
              iVar3 = (**(void*(*)())(puVar8 + 0xc))(param_1,uVar6,__ptr);
              if (iVar3 < 0) {
                free(__ptr);
                pcVar5 = *(void*(*)())(param_1 + 0x2a0);
                uVar7 = 0xfffffffa;
                goto joined_r0x0010506e;
              }
              break;
            }
            if (*(int *)(param_1 + 0x28c) < 1) goto LAB_00104e10;
            uVar4 = (int)uVar6 + 1;
            uVar6 = (ulong)uVar4;
            printf(1,"DEBUG(%i/%i):",1);
            puVar1 = puVar8 + 1;
            puVar8 = puVar8 + 0xe;
            printf(1,"No handler for %s: %u bytes",puVar1);
            putchar(10);
          } while (uVar4 != 0x21);
LAB_00104e88:
          free(__ptr);
        }
        if (*(void*(*)())(param_1 + 0x2a0) == (void *)0x0) {
          uVar7 = 0;
        }
        else {
          uVar7 = 0;
          (**(void*(*)())(param_1 + 0x2a0))(lVar2);
        }
        goto LAB_00104f39;
      }
      puts("ERROR: Unable to retrieve key.");
      pcVar5 = *(void*(*)())(param_1 + 0x2a0);
      uVar7 = 0xfffffffc;
    }
  }
joined_r0x0010506e:
  if (pcVar5 != (void *)0x0) {
    (*pcVar5)(lVar2);
  }
LAB_00104f39:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar7;
}
*/



void TNEFParseFile(undefined8 param_1,long param_2)

{
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  int local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *(int *)(param_2 + 0x28c);
  if (0 < local_28) {
    printf(1,"Attempting to parse %s...\n",param_1);
    local_28 = *(int *)(param_2 + 0x28c);
  }
  *(undefined8 **)(param_2 + 0x2a8) = &local_38;
  local_30 = 0;
  local_38 = param_1;
  TNEFParse(param_2);
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void TNEFParseMemory(undefined8 param_1,undefined8 param_2,long param_3)

{
  long in_FS_OFFSET;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  uint local_30;
  long local_20;
  
  local_30 = *(uint *)(param_3 + 0x28c);
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (0 < (int)local_30) {
    printf(1,"DEBUG(%i/%i): %s\n",1,(ulong)local_30,"Attempting to parse memory block...\n");
    local_30 = *(uint *)(param_3 + 0x28c);
  }
  *(undefined8 **)(param_3 + 0x2a8) = &local_48;



  local_48 = param_1;
  local_40 = param_1;
  local_38 = param_2;
  TNEFParse(param_3);
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 MAPIFindUserProp(int *param_1,int param_2)

{
  int *piVar1;
  int *piVar2;
  
  if ((param_1 != (int *)0x0) && (*param_1 != 0)) {
    piVar2 = *(int **)(param_1 + 2);
    piVar1 = piVar2 + (ulong)(*param_1 - 1) * 0xc + 0xc;
    do {
      if ((piVar2[5] == param_2) && (*piVar2 == 1)) {
        return *(undefined8 *)(piVar2 + 10);
      }
      piVar2 = piVar2 + 0xc;
    } while (piVar2 != piVar1);
  }
  return 0xffffffffffffffff;
}



undefined8 MAPIFindProperty(int *param_1,int param_2)

{
  int *piVar1;
  int *piVar2;
  
  if ((param_1 != (int *)0x0) && (*param_1 != 0)) {
    piVar2 = *(int **)(param_1 + 2);
    piVar1 = piVar2 + (ulong)(*param_1 - 1) * 0xc + 0xc;
    do {
      if ((piVar2[5] == param_2) && (*piVar2 == 0)) {
        return *(undefined8 *)(piVar2 + 10);
      }
      piVar2 = piVar2 + 0xc;
    } while (piVar2 != piVar1);
  }
  return 0xffffffffffffffff;
}



//undefined8 MAPISysTimetoDTR(ulong *param_1,ushort *param_2)
//
//{
//  short sVar1;
//  uint uVar2;
//  ulong uVar3;
//  ulong uVar4;
//  ushort uVar5;
//  uint uVar6;
//  uint uVar7;
//  long in_FS_OFFSET;
//  undefined8 local_48;
//  undefined8 local_40;
//  undefined8 local_38;
//  undefined8 local_30;
//  undefined8 local_28;
//  undefined8 local_20;
//  long local_10;
//  
//  uVar4 = *param_1;
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_48 = 0x1c0000001f;
//  local_40 = 0x1e0000001f;
//  local_38 = 0x1e0000001f;
//  local_30 = 0x1f0000001f;
//  local_28 = 0x1f0000001e;
//  local_20 = 0x1f0000001e;
//  uVar3 = (uVar4 / 10000000) / 0x3c;
//  param_2[5] = (short)(uVar4 / 10000000) + ((short)(uVar3 << 4) - (short)uVar3) * -4;
//  uVar3 = (uVar4 / 600000000) / 0x3c;
//  param_2[4] = (short)(uVar4 / 600000000) + ((short)(uVar3 << 4) - (short)uVar3) * -4;
//  param_2[3] = (short)(uVar4 / 36000000000) + (short)((uVar4 / 36000000000) / 0x18) * -0x18;
//  uVar4 = uVar4 / 864000000000;
//  if (uVar4 < 0x16d) {
//    uVar2 = 1;
//    *param_2 = 0x641;
//  }
//  else {
//    uVar4 = uVar4 - 0x16d;
//    uVar6 = 0x642;
//    *param_2 = 0x642;
//    uVar3 = 0x16d;
//    uVar7 = 2;
//    while (uVar2 = uVar7 % 7, uVar3 <= uVar4) {
//      uVar6 = uVar6 + 1;
//      uVar4 = uVar4 - uVar3;
//      uVar7 = uVar2 + 1;
//      uVar5 = (ushort)uVar6;
//      *param_2 = uVar5;
//      uVar3 = 0x16d;
//      if (((uVar6 & 3) == 0) &&
//         ((uVar5 != (ushort)((((ushort)(uVar6 >> 2) & 0x3fff) / 0x19) * 100) ||
//          (uVar5 == (ushort)(((uVar5 >> 4) / 0x19) * 400))))) {
//        uVar7 = uVar2 + 2;
//        uVar3 = 0x16e;
//      }
//    }
//    if ((uVar6 & 3) == 0) {
//      local_48 = 0x1d0000001f;
//    }
//  }
//  sVar1 = (short)uVar4;
//  uVar2 = uVar2 + (int)uVar4;
//  param_2[1] = 0;
//  param_2[6] = (short)uVar2 + (short)(uVar2 / 7) * -7;
//  uVar3 = uVar4 & 0xffffffff;
//  uVar5 = 1;
//  if (0x1f < uVar4) {
//    uVar2 = 0x1f;
//    uVar5 = 1;
//    do {
//      uVar6 = (int)uVar3 - uVar2;
//      sVar1 = (short)uVar6;
//      uVar3 = (ulong)uVar6;
//      uVar4 = (ulong)uVar5;
//      uVar5 = uVar5 + 1;
//      uVar2 = *(uint *)((long)&local_48 + uVar4 * 4);
//    } while (uVar2 < uVar6);
//  }
//  param_2[1] = uVar5;
//  param_2[2] = sVar1 + 1;
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return 0;
//}
//


//ulong IsCompressedRTF(long *param_1)
//
//{
//  int iVar1;
//  
//  if (*(uint *)(param_1 + 1) < 0xc) {
//    return 0;
//  }
//  iVar1 = SwapDWord(*param_1 + 8,4);
//  return (ulong)(iVar1 == 0x75465a4c || iVar1 == 0x414c454d);
//}


/*
void * DecompressRTF(long *param_1,uint *param_2)

{
  uint uVar1;
  undefined auVar2 [16];
  byte bVar3;
  uint uVar4;
  int iVar5;
  long lVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  undefined4 *__ptr;
  undefined4 *__ptr_00;
  void *__dest;
  undefined8 uVar11;
  ulong uVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  uint uVar16;
  ulong uVar17;
  ulong __nmemb;
  
  __ptr = (undefined4 *)calloc(0xd0,1);
  uVar11 = 0x5f6;
  if (__ptr == (undefined4 *)0x0) {
LAB_00105b7e:
    printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar11);
    return (void *)0;
  }
  iVar5 = *(int *)(param_1 + 1);
  lVar6 = *param_1;
  *__ptr = 0x74725c7b;
  __ptr[1] = 0x615c3166;
  __ptr[2] = 0x74725c7b;
  __ptr[3] = 0x615c3166;
  __ptr[4] = 0x66666564;
  __ptr[5] = 0x65645c30;
  __ptr[6] = 0x66666564;
  __ptr[7] = 0x65645c30;
  __ptr[8] = 0x6e6f665c;
  __ptr[9] = 0x6c627474;
  __ptr[10] = 0x6e6f665c;
  __ptr[0xb] = 0x6c627474;
  __ptr[0xc] = 0x206c696e;
  __ptr[0xd] = 0x6f72665c;
  __ptr[0xe] = 0x206c696e;
  __ptr[0xf] = 0x6f72665c;
  __ptr[0x10] = 0x20737369;
  __ptr[0x11] = 0x6f6d665c;
  __ptr[0x12] = 0x20737369;
  __ptr[0x13] = 0x6f6d665c;
  __ptr[0x14] = 0x70697263;
  __ptr[0x15] = 0x665c2074;
  __ptr[0x16] = 0x70697263;
  __ptr[0x17] = 0x665c2074;
  __ptr[0x18] = 0x6e615320;
  __ptr[0x19] = 0x65532073;
  __ptr[0x1a] = 0x6e615320;
  __ptr[0x1b] = 0x65532073;
  __ptr[0x1c] = 0x6972416c;
  __ptr[0x1d] = 0x69546c61;
  __ptr[0x1e] = 0x6972416c;
  __ptr[0x1f] = 0x69546c61;
  __ptr[0x20] = 0x616d6f52;
  __ptr[0x21] = 0x756f436e;
  __ptr[0x22] = 0x616d6f52;
  __ptr[0x23] = 0x756f436e;
  __ptr[0x24] = 0x74726f6c;
  __ptr[0x25] = 0x725c6c62;
  __ptr[0x26] = 0x74726f6c;
  __ptr[0x27] = 0x725c6c62;
  __ptr[0x28] = 0x625c306e;
  __ptr[0x29] = 0x3065756c;
  __ptr[0x2a] = 0x625c306e;
  __ptr[0x2b] = 0x3065756c;
  __ptr[0x2c] = 0x64726170;
  __ptr[0x2d] = 0x616c705c;
  __ptr[0x2e] = 0x64726170;
  __ptr[0x2f] = 0x616c705c;
  __ptr[0x32] = 0x6261745c;
  *(undefined *)((long)__ptr + 0xce) = 0x78;
  *(undefined8 *)(__ptr + 0x30) = 0x755c695c625c3032;
  *(undefined2 *)(__ptr + 0x33) = 0x745c;
  if (iVar5 < 0x14) {
    puts("File too small");
    return (void *)0;
  }
  uVar7 = SwapDWord(0x616c705c64726170,lVar6,4);
  uVar8 = SwapDWord(lVar6 + 4,4);
  __nmemb = (ulong)uVar8;
  uVar9 = SwapDWord(lVar6 + 8,4);
  uVar4 = *(uint *)(param_1 + 1);
  if (uVar4 - 4 != uVar7) {
    printf(1," Size Mismatch: %u != %i\n",(ulong)uVar7);
    free(__ptr);
    return (void *)0;
  }
  if (uVar9 == 0x414c454d) {
    __dest = calloc(__nmemb,1);
    uVar11 = 0x612;
    if (__dest != (void *)0x0) goto LAB_00105aea;
  }
  else {
    if (uVar9 != 0x75465a4c) {
      printf(1,"Unknown compression type (magic number %x)\n",(ulong)uVar9);
LAB_00105aea:
      free(__ptr);
      return (void *)0;
    }
    if (0x7fffffff - uVar8 < 0xd0) {
      puts("Corrupted file");
      return (void *)0;
    }
    uVar7 = uVar8 + 0xcf;
    __ptr_00 = (undefined4 *)calloc((ulong)uVar7,1);
    if (__ptr_00 == (undefined4 *)0x0) {
      uVar11 = 0x61e;
      goto LAB_00105b7e;
    }
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)__ptr;
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 4);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 8);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0xc);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x10);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x14);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x18);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x1c);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x20);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x24);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x28);
                    // WARNING: Load size is inaccurate
    auVar2 = *(undefined *)(__ptr + 0x2c);
    *(undefined8 *)(__ptr_00 + 0x30) = *(undefined8 *)(__ptr + 0x30);
    __ptr_00[0x32] = __ptr[0x32];
    *(undefined2 *)(__ptr_00 + 0x33) = *(undefined2 *)(__ptr + 0x33);
    *(undefined *)((long)__ptr_00 + 0xce) = *(undefined *)((long)__ptr + 0xce);
    if ((0xcf < uVar7) && (0x10 < uVar4)) {
      uVar9 = 0;
      uVar17 = 0;
      uVar14 = 0xcf;
      uVar12 = 0x10;
      do {
        uVar17 = (ulong)(uint)((int)uVar17 >> 1);
        if ((uVar9 & 7) == 0) {
          uVar17 = (ulong)*(byte *)(lVar6 + uVar12);
          uVar12 = (ulong)((int)uVar12 + 1);
        }
        uVar16 = (uint)uVar14;
        uVar10 = (uint)uVar12;
        if ((uVar17 & 1) == 0) {
          if (uVar4 <= uVar10) {
            puts("Corrupted stream");
            return (void *)0;
          }
          uVar13 = (ulong)(uVar10 + 1);
          uVar15 = (ulong)(uVar16 + 1);
          *(undefined *)((long)__ptr_00 + uVar14) = *(undefined *)(lVar6 + uVar12);
LAB_001059b9:
          uVar16 = (uint)uVar15;
          uVar12 = uVar13;
          uVar14 = uVar15;
        }
        else {
          uVar13 = (ulong)(uVar10 + 2);
          bVar3 = *(byte *)(lVar6 + (ulong)(uVar10 + 1));
          uVar10 = ((uint)(bVar3 >> 4) | (uint)*(byte *)(lVar6 + uVar12) << 4) +
                   (uVar16 & 0xfffff000);
          if (uVar16 <= uVar10) {
            uVar10 = uVar10 - 0x1000;
          }
          uVar1 = uVar10 + 2 + ((uint)bVar3 & 0xf);
          if (uVar16 <= uVar10) {
            uVar16 = uVar10;
          }
          uVar15 = uVar14;
          if ((uVar7 <= uVar16) || (uVar1 <= uVar10)) goto LAB_001059b9;
          do {
            uVar12 = (ulong)uVar10;
            uVar16 = (int)uVar14 + 1;
            uVar10 = uVar10 + 1;
            *(undefined *)((long)__ptr_00 + uVar14) = *(undefined *)((long)__ptr_00 + uVar12);
            uVar14 = (ulong)uVar16;
            if (uVar1 <= uVar10 || uVar7 <= uVar16) break;
          } while (uVar10 < uVar7);
          uVar14 = (ulong)uVar16;
          uVar12 = uVar13;
        }
      } while ((uVar16 < uVar7) && (uVar9 = uVar9 + 1, (uint)uVar12 < uVar4));
    }
    __dest = calloc(__nmemb,1);
    if (__dest != (void *)0x0) {
      memcpy(__dest,(void *)((long)__ptr_00 + 0xcf),__nmemb);
      free(__ptr_00);
      *param_2 = uVar8;
      free(__ptr);
      return __dest;
    }
    uVar11 = 0x644;
  }
  printf(1,"Out of Memory at %s : %i\n","ytnef.c",uVar11);
  return __dest;
}
*/


/*
void MAPIPrint(uint *param_1)

{
  uint *puVar1;
  undefined8 *puVar2;
  byte *pbVar3;
  ushort uVar4;
  undefined8 uVar5;
  bool bVar6;
  size_t sVar7;
  ushort **ppuVar8;
  uint uVar9;
  int *piVar10;
  uint *puVar11;
  long lVar12;
  int iVar13;
  uint uVar14;
  ulong uVar15;
  long lVar16;
  uint **ppuVar17;
  long in_FS_OFFSET;
  uint local_94;
  long local_90;
  undefined8 local_66;
  undefined2 local_5e;
  undefined2 local_5c;
  undefined2 local_5a;
  char *local_58;
  undefined local_50 [16];
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_1 != 0) {
    local_90 = 0;
    local_94 = 0;
    do {
      piVar10 = (int *)(local_90 + *(long *)(param_1 + 2));
      printf(1,"   #%i: Type: [",(ulong)local_94);
      uVar4 = *(ushort *)(piVar10 + 5);
      if (uVar4 == 10) {
        printf(1,"  ERROR  ");
      }
      else {
        if (uVar4 < 0xb) {
          if (uVar4 == 3) {
            printf(1,"  LONG   ");
          }
          else {
            if (uVar4 < 4) {
              if (uVar4 == 1) {
                printf(1,"  NULL   ");
              }
              else {
                if (uVar4 < 2) {
                  printf(1,"  NONE   ");
                }
                else {
                  printf(1,&DAT_00106852);
                }
              }
            }
            else {
              if (uVar4 == 5) {
                printf(1," DOUBLE  ");
              }
              else {
                if (uVar4 < 5) {
                  printf(1,"   R4    ");
                }
                else {
                  if (uVar4 == 6) {
                    printf(1,"CURRENCY ");
                  }
                  else {
                    if (uVar4 != 7) goto LAB_00105d17;
                    printf(1,"APP TIME ");
                  }
                }
              }
            }
          }
        }
        else {
          if (uVar4 == 0x1e) {
            printf(1," STRING8 ");
          }
          else {
            if (uVar4 < 0x1f) {
              if (uVar4 == 0xd) {
                printf(1," OBJECT  ");
              }
              else {
                if (uVar4 == 0x14) {
                  printf(1,"   I8    ");
                }
                else {
                  if (uVar4 != 0xb) goto LAB_00105d17;
                  printf(1," BOOLEAN ");
                }
              }
            }
            else {
              if (uVar4 == 0x40) {
                printf(1,"SYS TIME ");
              }
              else {
                if (uVar4 < 0x41) {
                  if (uVar4 == 0x1f) {
                    printf(1," UNICODE ");
                  }
                  else {
LAB_00105d17:
                    printf(1,&DAT_001068e8);
                  }
                }
                else {
                  if (uVar4 == 0x48) {
                    printf(1,"OLE GUID ");
                  }
                  else {
                    if (uVar4 != 0x102) goto LAB_00105d17;
                    printf(1," BINARY  ");
                  }
                }
              }
            }
          }
        }
      }
      printf(1,"]  Code: [");
      if (*piVar10 == 1) {
        printf(1,"UD:x%04x",(ulong)*(ushort *)((long)piVar10 + 0x16));
      }
      else {
        puVar11 = (uint *)&MPList;
        bVar6 = false;
        do {
          while ((*puVar11 != (uint)*(ushort *)((long)piVar10 + 0x16) || (bVar6))) {
            puVar11 = puVar11 + 0x21;
            if (puVar11 == (uint *)&DAT_00316230) goto LAB_00105da1;
          }
          puVar1 = puVar11 + 1;
          puVar11 = puVar11 + 0x21;
          printf(1,0x1064d7,puVar1);
          bVar6 = true;
        } while (puVar11 != (uint *)&DAT_00316230);
LAB_00105da1:
        if (!bVar6) {
          printf(1,"0x%04x",(ulong)*(ushort *)((long)piVar10 + 0x16));
        }
      }
      puts("]");
      if (0 < piVar10[7]) {
        lVar16 = 0;
        iVar13 = 0;
        do {
          iVar13 = iVar13 + 1;
          puVar2 = (undefined8 *)(*(long *)(piVar10 + 8) + lVar16);
          lVar16 = lVar16 + 0x10;
          printf(1,"    Name: %s\n",*puVar2);
        } while (piVar10[7] != iVar13 && iVar13 <= piVar10[7]);
      }
      uVar9 = piVar10[6];
      if (uVar9 != 0) {
        lVar16 = 0;
        uVar15 = 0;
        do {
          while( true ) {
            ppuVar17 = (uint **)(*(long *)(piVar10 + 10) + lVar16);
            if (uVar9 == 1) {
              printf(1,&DAT_00106857);
            }
            else {
              printf(1,"    [%i/%u] ",uVar15);
            }
            printf(1,"Size: %i",(ulong)*(uint *)(ppuVar17 + 1));
            uVar4 = *(ushort *)(piVar10 + 5);
            if (uVar4 != 0xd) break;
            putchar(10);
LAB_00105eb8:
            uVar9 = piVar10[6];
            uVar14 = (int)uVar15 + 1;
            uVar15 = (ulong)uVar14;
            lVar16 = lVar16 + 0x10;
            if (uVar9 <= uVar14) goto LAB_00105f68;
          }
          if (uVar4 < 0xe) {
            if (uVar4 == 3) {
              printf(1,"    Value: %i\n",(ulong)**ppuVar17);
            }
            else {
              if (uVar4 == 0xb) {
                if (***(char ***)(piVar10 + 10) == '\0') {
                  puts("    Value: False");
                }
                else {
                  puts("    Value: True");
                }
              }
              else {
                if (uVar4 != 2) goto LAB_00105f37;
                printf(1,"    Value: %hi\n",(ulong)(uint)(int)*(short *)*ppuVar17);
              }
            }
            goto LAB_00105eb8;
          }
          if (uVar4 == 0x40) {
            lVar12 = 0;
            MAPISysTimetoDTR(*ppuVar17,&local_66);
            printf(1,"    Value: ");
            uVar5 = *(undefined8 *)*ppuVar17;
            TNEFPrintDate(local_66,(ulong)CONCAT24(local_5a,CONCAT22(local_5c,local_5e)));
            printf(1,&DAT_0010693a);
            do {
              pbVar3 = (byte *)((long)*ppuVar17 + lVar12);
              lVar12 = lVar12 + 1;
              printf(1," %02x",(ulong)*pbVar3);
            } while (lVar12 != 8);
            printf(1,"] (%llu)\n",uVar5);
            goto LAB_00105eb8;
          }
          if (0x40 < uVar4) {
            if (uVar4 == 0x48) {
              lVar12 = 0;
              printf(1,"    Value: ");
              printf(1,"[HEX: ");
              do {
                pbVar3 = (byte *)((long)*ppuVar17 + lVar12);
                lVar12 = lVar12 + 1;
                printf(1," %02x",(ulong)*pbVar3);
              } while (lVar12 != 0x10);
              puts("]");
            }
            else {
              if (uVar4 != 0x102) goto LAB_00105f37;
              iVar13 = IsCompressedRTF(ppuVar17);
              if (iVar13 != 1) {
                printf(1,"    Value: [");
                if (0 < *(int *)(ppuVar17 + 1)) {
                  ppuVar8 = __ctype_b_loc();
                  lVar12 = 0;
                  do {
                    if ((*(byte *)((long)*ppuVar8 +
                                  (ulong)(uint)*(byte *)((long)*ppuVar17 + lVar12) * 2 + 1) & 0x40)
                        == 0) {
                      putchar(0x2e);
                    }
                    else {
                      putchar((uint)*(byte *)((long)*ppuVar17 + lVar12));
                    }
                    iVar13 = (int)lVar12 + 1;
                    lVar12 = lVar12 + 1;
                  } while (*(int *)(ppuVar17 + 1) != iVar13 && iVar13 <= *(int *)(ppuVar17 + 1));
                }
                goto LAB_001060dc;
              }
              printf(1,"    Detected Compressed RTF. ");
              puts("Decompressed text follows");
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
              local_58 = (char *)DecompressRTF(ppuVar17,local_50);
              if (local_58 != (char *)0x0) {
                puts(local_58);
                free(local_58);
              }
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            }
            goto LAB_00105eb8;
          }
          if (uVar4 == 0x1e) {
            printf(1,"    Value: [%.*s]\n",(ulong)*(uint *)(ppuVar17 + 1));
            sVar7 = strlen((char *)*ppuVar17);
            if (sVar7 != (long)(*(int *)(ppuVar17 + 1) + -1)) {
              printf(1,"Detected Hidden data: [");
              if (0 < *(int *)(ppuVar17 + 1)) {
                ppuVar8 = __ctype_b_loc();
                lVar12 = 0;
                do {
                  while( true ) {
                    if ((*(byte *)((long)*ppuVar8 +
                                  (ulong)(uint)*(byte *)((long)*ppuVar17 + lVar12) * 2 + 1) & 0x40)
                        == 0) break;
                    putchar((uint)*(byte *)((long)*ppuVar17 + lVar12));
                    iVar13 = (int)lVar12 + 1;
                    lVar12 = lVar12 + 1;
                    if (*(int *)(ppuVar17 + 1) == iVar13 || *(int *)(ppuVar17 + 1) < iVar13)
                    goto LAB_001060dc;
                  }
                  putchar(0x2e);
                  iVar13 = (int)lVar12 + 1;
                  lVar12 = lVar12 + 1;
                } while (*(int *)(ppuVar17 + 1) != iVar13 && iVar13 <= *(int *)(ppuVar17 + 1));
              }
LAB_001060dc:
              puts("]");
            }
            goto LAB_00105eb8;
          }
LAB_00105f37:
          uVar14 = (int)uVar15 + 1;
          uVar15 = (ulong)uVar14;
          lVar16 = lVar16 + 0x10;
          printf(1,"    Value: [%.*s]\n",(ulong)*(uint *)(ppuVar17 + 1));
          uVar9 = piVar10[6];
        } while (uVar14 < uVar9);
      }
LAB_00105f68:
      local_94 = local_94 + 1;
      local_90 = local_90 + 0x30;
    } while (local_94 <= *param_1 && *param_1 != local_94);
  }
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}
*/



undefined8 TNEFMapiProperties(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)

{
  int iVar1;
  undefined8 uVar2;
  
  iVar1 = TNEFFillMapi(param_1,param_3,(ulong)param_4,param_1 + 0x1f8);
  if (iVar1 < 0) {
    puts("ERROR Parsing MAPI block");
    uVar2 = 0xffffffff;
  }
  else {
    uVar2 = 0;
    if (2 < *(int *)(param_1 + 0x28c)) {
      MAPIPrint(param_1 + 0x1f8);
      uVar2 = 0;
    }
  }
  return uVar2;
}



//void _fini(void)
//
//{
//  return;
//}


