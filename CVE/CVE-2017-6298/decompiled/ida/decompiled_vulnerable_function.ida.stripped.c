__int64 __fastcall TNEFFillMapi(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, signed __int64 a5, __int64 a6)
{
  signed __int64 v6; // rbp
  unsigned int v7; // ebx
  char *v8; // r14
  unsigned int v9; // er12
  unsigned int v10; // ebx
  signed int *v11; // r13
  unsigned int v12; // ecx
  unsigned int v13; // ST28_4
  _OWORD *v14; // rax
  unsigned int v15; // ecx
  __m128i v16; // xmm0
  unsigned int v17; // ecx
  bool v18; // cc
  signed __int64 v19; // rbp
  __int16 v20; // ax
  size_t v21; // rdx
  void *v22; // rdi
  __int64 v23; // rcx
  __int64 v24; // rdx
  void *v25; // rcx
  const void *v26; // rsi
  char *v27; // rcx
  __int64 v28; // rax
  char *v29; // rcx
  char v30; // dl
  signed __int64 v31; // r15
  int v32; // eax
  unsigned int v33; // eax
  __int64 v34; // rcx
  int v35; // eax
  int v36; // edx
  signed __int64 v37; // rdi
  unsigned int v38; // ebp
  size_t v39; // rdi
  __int64 v40; // rcx
  void *v41; // rax
  signed __int64 v42; // rdi
  __int64 v43; // rax
  size_t v44; // rdx
  void *v45; // rdi
  unsigned __int64 v46; // rax
  signed __int64 v47; // rdi
  char *v48; // rbp
  signed int v49; // eax
  void *v50; // rax
  int v51; // edx
  void *v53; // rax
  signed __int64 v54; // rdi
  int v55; // eax
  size_t v56; // rdx
  void *v57; // rdi
  __int64 v58; // r8
  __int64 v59; // r9
  unsigned int v60; // ebp
  void *v61; // rax
  char *v62; // r12
  signed __int64 v63; // rbx
  signed __int64 v64; // rbp
  unsigned int v65; // er14
  __int64 v66; // r13
  _BYTE *v67; // rax
  signed __int64 v68; // r13
  __int64 v69; // rdi
  __int64 v70; // rdx
  signed __int64 v71; // rdi
  __int64 v72; // rax
  __int64 v73; // r8
  __int64 v74; // r9
  __int64 v75; // rcx
  __int64 v76; // r8
  __int64 v77; // r9
  signed __int64 v78; // rcx
  signed __int64 v79; // r9
  signed __int64 v80; // r8
  signed __int64 v81; // rcx
  signed __int64 v82; // r9
  signed __int64 v83; // r8
  signed __int64 v84; // rcx
  signed __int64 v85; // rcx
  __int64 v86; // r8
  __int64 v87; // r9
  __int64 v88; // rcx
  __int64 v89; // r8
  __int64 v90; // r9
  signed __int64 v91; // [rsp+8h] [rbp-A0h]
  __int64 v92; // [rsp+10h] [rbp-98h]
  __int64 v93; // [rsp+18h] [rbp-90h]
  __int64 v94; // [rsp+20h] [rbp-88h]
  signed int n; // [rsp+28h] [rbp-80h]
  unsigned int na; // [rsp+28h] [rbp-80h]
  size_t nb; // [rsp+28h] [rbp-80h]
  unsigned int nc; // [rsp+28h] [rbp-80h]
  unsigned int v99; // [rsp+48h] [rbp-60h]
  unsigned int v100; // [rsp+4Ch] [rbp-5Ch]
  unsigned int v101; // [rsp+4Ch] [rbp-5Ch]
  __int16 v102; // [rsp+5Ah] [rbp-4Eh]
  int v103; // [rsp+5Ch] [rbp-4Ch]
  __int64 v104; // [rsp+60h] [rbp-48h]
  unsigned __int64 v105; // [rsp+68h] [rbp-40h]

  v105 = __readfsqword(0x28u);
  v93 = a1;
  v99 = a3;
  v94 = a4;
  v91 = a3;
  if ( a3 <= 3uLL )
  {
    v81 = 426LL;
    goto LABEL_119;
  }
  v6 = a2 + 4;
  v7 = SwapDWord(a2, 4LL);
  if ( v7 - 1 > 0x3E7 )
  {
    v82 = 1000LL;
    v83 = 430LL;
    v24 = v7;
LABEL_121:
    v10 = -1;
    __printf_chk(
      1LL,
      "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n",
      v24,
      "ytnef.c",
      v83,
      v82);
    return v10;
  }
  v8 = (char *)calloc((signed int)v7, 0x30uLL);
  *(_QWORD *)(v94 + 8) = v8;
  if ( !v8 )
  {
    v85 = 432LL;
    goto LABEL_137;
  }
  v9 = 0;
  v92 = a2;
  *(_DWORD *)v94 = v7;
  v10 = -1;
  do
  {
    if ( v10 == -1 )
    {
      if ( v91 < (unsigned __int64)(v6 - v92 + 4) )
      {
        v78 = 438LL;
        goto LABEL_112;
      }
      v31 = v6 + 4;
      v32 = SwapDWord(v6, 4LL);
      *((_DWORD *)v8 + 5) = v32;
      *(_DWORD *)v8 = 0;
      *((_DWORD *)v8 + 7) = 0;
      if ( v32 < 0 )
      {
        a5 = v31 - v92 + 15;
        if ( a5 >= v91 )
        {
          v78 = 447LL;
          goto LABEL_112;
        }
        *(__m128i *)(v8 + 4) = _mm_loadu_si128((const __m128i *)(v6 + 4));
        if ( v91 < (unsigned __int64)(v6 + 20 - v92 + 4) )
        {
          v78 = 451LL;
          goto LABEL_112;
        }
        v31 = v6 + 24;
        v33 = SwapDWord(v6 + 20, 4LL);
        if ( v33 )
        {
          v60 = v33 - 1;
          if ( v33 - 1 > 0x3E7 )
          {
            __printf_chk(
              1LL,
              "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n",
              v33,
              "ytnef.c",
              455LL,
              1000LL);
            return v10;
          }
          nc = v33;
          v61 = calloc(v33, 0x10uLL);
          *((_QWORD *)v8 + 4) = v61;
          if ( !v61 )
          {
            __printf_chk(1LL, "Out of Memory at %s : %i\n", "ytnef.c", 457LL, a5, a6);
            return v10;
          }
          v101 = v9;
          *((_DWORD *)v8 + 7) = nc;
          v62 = v8;
          v63 = 16LL * v60;
          while ( 1 )
          {
            if ( v91 < (unsigned __int64)(v31 - v92 + 4) )
            {
              v10 = -1;
              v78 = 460LL;
              goto LABEL_112;
            }
            v64 = v31 + 4;
            v65 = SwapDWord(v31, 4LL);
            if ( v65 - 1 > 0x63 )
            {
              v10 = -1;
              v38 = v65;
              v79 = 100LL;
              v80 = 463LL;
              goto LABEL_114;
            }
            v66 = *((_QWORD *)v62 + 4);
            v67 = calloc(v65 + 1, 1uLL);
            v68 = v63 + v66;
            *(_QWORD *)v68 = v67;
            if ( !v67 )
            {
              v10 = -1;
              __printf_chk(1LL, "Out of Memory at %s : %i\n", "ytnef.c", 465LL, a5, a6);
              return v10;
            }
            v69 = v65;
            *(_DWORD *)(v68 + 8) = v65;
            if ( v91 < v65 + v64 - v92 )
              break;
            if ( v65 >> 1 )
            {
              v70 = 0LL;
              while ( 1 )
              {
                v67[v70] = *(_BYTE *)(v31 + 2 * v70 + 4);
                if ( (v65 >> 1) - 1 + 1LL == ++v70 )
                  break;
                v67 = *(_BYTE **)(*((_QWORD *)v62 + 4) + v63);
              }
            }
            if ( v65 & 3 )
              v69 = v65 + 4 - (v65 & 3);
            v63 -= 16LL;
            v31 = v64 + v69;
            if ( v63 == -16 )
            {
              v8 = v62;
              v10 = -1;
              v9 = v101;
              goto LABEL_48;
            }
          }
          v10 = -1;
          v78 = 467LL;
          goto LABEL_112;
        }
        if ( v91 < (unsigned __int64)(v31 - v92 + 4) )
        {
          v78 = 476LL;
          goto LABEL_112;
        }
        v31 = v6 + 28;
        *((_WORD *)v8 + 11) = SwapDWord(v6 + 24, 4LL);
LABEL_48:
        *(_DWORD *)v8 = 1;
      }
      v34 = *(unsigned int *)(v93 + 652);
      if ( (signed int)v34 > 2 )
      {
        __printf_chk(1LL, "DEBUG(%i/%i):", 3LL, v34, a5, a6);
        __printf_chk(
          1LL,
          "Type id = %04x, Prop id = %04x",
          (unsigned __int16)*((_DWORD *)v8 + 5),
          (unsigned int)(*((_DWORD *)v8 + 5) >> 16),
          v58,
          v59);
        putchar(10);
      }
      v35 = *((_DWORD *)v8 + 5);
      if ( v35 & 0x1000 )
      {
        v36 = (unsigned __int16)v35;
        LOWORD(v35) = 0;
        *((_DWORD *)v8 + 5) = (v36 - 4096) | v35;
        if ( v91 < (unsigned __int64)(v31 - v92 + 4) )
        {
          v78 = 488LL;
          goto LABEL_112;
        }
        v37 = v31;
        v31 += 4LL;
        v38 = SwapDWord(v37, 4LL);
        if ( v38 - 1 > 0x3E7 )
        {
          v79 = 1000LL;
          v80 = 493LL;
LABEL_114:
          __printf_chk(
            1LL,
            "ERROR: invalid alloc size %u at %s : %i, suspected corruption (exceeded %i bytes)\n",
            v38,
            "ytnef.c",
            v80,
            v79);
          return v10;
        }
        v39 = (signed int)v38;
        na = 0;
      }
      else
      {
        na = v10;
        v39 = 1LL;
        v38 = 1;
      }
      v11 = (signed int *)calloc(v39, 0x10uLL);
      *((_QWORD *)v8 + 5) = v11;
      if ( !v11 )
      {
        __printf_chk(1LL, "Out of Memory at %s : %i\n", "ytnef.c", 495LL, a5, a6);
        return v10;
      }
      *((_DWORD *)v8 + 6) = v38;
      v10 = na;
      v6 = v31;
    }
    else
    {
      ++v10;
      --v9;
      v11 = (signed int *)(*((_QWORD *)v8 + 5) + 16LL * (signed int)v10);
    }
    v12 = *((_DWORD *)v8 + 5);
    if ( (unsigned __int16)v12 > 0xBu )
    {
      if ( (unsigned __int16)v12 > 0x1Fu )
      {
        if ( (unsigned __int16)v12 == 72 )
        {
          v11[2] = 16;
          v13 = v12;
          v14 = calloc(0x10uLL, 1uLL);
          *(_QWORD *)v11 = v14;
          v15 = v13;
          if ( v14 )
          {
            if ( v6 - v92 + 16 <= v91 )
            {
              v16 = _mm_loadu_si128((const __m128i *)v6);
              v6 += 16LL;
              *v14 = v16;
              goto LABEL_13;
            }
            v81 = 588LL;
LABEL_119:
            v10 = -1;
            __printf_chk(1LL, "Corrupted file detected at %s : %i\n", "ytnef.c", v81, a5, a6);
            return v10;
          }
          v84 = 587LL;
LABEL_126:
          v10 = -1;
          __printf_chk(1LL, "Out of Memory at %s : %i\n", "ytnef.c", v84, a5, a6);
          return v10;
        }
        if ( (unsigned __int16)v12 != 258 )
        {
          if ( (unsigned __int16)v12 != 64 )
            goto LABEL_78;
          goto LABEL_63;
        }
        goto LABEL_66;
      }
      if ( (unsigned __int16)v12 >= 0x1Eu || (unsigned __int16)v12 == 13 )
      {
LABEL_66:
        v46 = v6 - v92 + 4;
        if ( v10 != -1 )
        {
LABEL_67:
          if ( v91 < v46 )
          {
            v81 = 516LL;
            goto LABEL_119;
          }
          v47 = v6;
          v48 = (char *)(v6 + 4);
          v49 = SwapDWord(v47, 4LL);
          v11[2] = v49;
          if ( v49 )
          {
            if ( (signed __int64)&v48[v49 - v92] > v91 )
            {
              v81 = 522LL;
              goto LABEL_119;
            }
            if ( (unsigned int)(v49 - 1) > 0x1869F )
            {
              v82 = 100000LL;
              v83 = 523LL;
              v24 = (unsigned int)v49;
              goto LABEL_121;
            }
            if ( (unsigned __int16)*((_DWORD *)v8 + 5) == 31 )
            {
              v72 = to_utf8(v49, v48);
              *(_QWORD *)v11 = v72;
              if ( !v72 )
                return (unsigned int)-1;
              v15 = *((_DWORD *)v8 + 5);
            }
            else
            {
              v100 = *((_DWORD *)v8 + 5);
              nb = v49;
              v50 = calloc(v49, 1uLL);
              *(_QWORD *)v11 = v50;
              if ( !v50 )
              {
                v84 = 530LL;
                goto LABEL_126;
              }
              memcpy(v50, v48, nb);
              v15 = v100;
            }
            v49 = v11[2];
            v51 = v11[2] & 3;
            if ( v51 )
              v51 = 4 - v51;
          }
          else
          {
            v15 = *((_DWORD *)v8 + 5);
            *(_QWORD *)v11 = 0LL;
            v51 = 0;
          }
          v6 = (signed __int64)&v48[v51 + v49];
          goto LABEL_13;
        }
        if ( v91 >= v46 )
        {
          v71 = v6;
          v6 += 4LL;
          v11[2] = SwapDWord(v71, 4LL);
          v46 = v6 - v92 + 4;
          goto LABEL_67;
        }
        v78 = 511LL;
LABEL_112:
        __printf_chk(1LL, "Corrupted file detected at %s : %i\n", "ytnef.c", v78, a5, a6);
        return v10;
      }
      if ( (unsigned __int16)v12 != 20 )
        goto LABEL_78;
LABEL_63:
      v11[2] = 8;
      v41 = calloc(8uLL, 1uLL);
      *(_QWORD *)v11 = v41;
      if ( !v41 )
      {
        v84 = 577LL;
        goto LABEL_126;
      }
      if ( v6 - v92 + 7 >= v91 )
      {
        v81 = 578LL;
        goto LABEL_119;
      }
      v42 = v6;
      v6 += 8LL;
      v43 = SwapDDWord(v42, 8LL);
      v44 = v11[2];
      v45 = *(void **)v11;
      v104 = v43;
      memcpy(v45, &v104, v44);
      v15 = *((_DWORD *)v8 + 5);
LABEL_13:
      v17 = v15 >> 16;
      v18 = v17 <= 0x49;
      if ( v17 == 73 )
        goto LABEL_29;
      goto LABEL_14;
    }
    if ( (unsigned __int16)v12 >= 0xAu )
      goto LABEL_82;
    if ( (unsigned __int16)v12 > 4u )
    {
      if ( (unsigned __int16)v12 != 5 )
      {
        if ( (unsigned __int16)v12 > 7u )
        {
LABEL_78:
          v10 = -1;
          puts("Bad file");
          return v10;
        }
LABEL_82:
        v11[2] = 4;
        v53 = calloc(4uLL, 1uLL);
        *(_QWORD *)v11 = v53;
        if ( !v53 )
        {
          v84 = 565LL;
          goto LABEL_126;
        }
        if ( v6 - v92 + 3 >= v91 )
        {
          v81 = 566LL;
          goto LABEL_119;
        }
        v54 = v6;
        v6 += 4LL;
        v55 = SwapDWord(v54, 4LL);
        v56 = v11[2];
        v57 = *(void **)v11;
        v103 = v55;
        memcpy(v57, &v103, v56);
        v15 = *((_DWORD *)v8 + 5);
        goto LABEL_13;
      }
      goto LABEL_63;
    }
    if ( (unsigned __int16)v12 >= 3u )
      goto LABEL_82;
    if ( (unsigned __int16)v12 != 2 )
      goto LABEL_78;
    v11[2] = 2;
    *(_QWORD *)v11 = calloc(2uLL, 2uLL);	//BUG: Unchecked calloc return value
    v20 = SwapWord(v6, 2LL);
    v21 = v11[2];
    v22 = *(void **)v11;
    v6 += 4LL;
    v102 = v20;
    memcpy(v22, &v102, v21);
    v17 = *((_DWORD *)v8 + 5) >> 16;
    v18 = v17 <= 0x49;
    if ( v17 == 73 )
      goto LABEL_29;
LABEL_14:
    if ( !v18 )
    {
      if ( v17 != 112 && v17 != 3613 )
        goto LABEL_17;
LABEL_29:
      v23 = *(unsigned int *)(v93 + 652);
      if ( (signed int)v23 > 2 )
        goto LABEL_57;
      goto LABEL_30;
    }
    if ( v17 - 55 > 1 )
      goto LABEL_17;
    v23 = *(unsigned int *)(v93 + 652);
    if ( (signed int)v23 > 2 )
    {
LABEL_57:
      __printf_chk(1LL, "DEBUG(%i/%i): %s\n", 3LL, v23, "Got a Subject", a6);
      if ( *(_DWORD *)(v93 + 40) )
        goto LABEL_17;
      v40 = *(unsigned int *)(v93 + 652);
      if ( (signed int)v40 > 2 )
        __printf_chk(1LL, "DEBUG(%i/%i): %s\n", 3LL, v40, "Assigning a Subject", a6);
      goto LABEL_31;
    }
LABEL_30:
    if ( *(_DWORD *)(v93 + 40) )
      goto LABEL_17;
LABEL_31:
    v24 = (unsigned int)v11[2];
    if ( (unsigned int)(v24 - 1) > 0x63 )
    {
      v82 = 100LL;
      v83 = 607LL;
      goto LABEL_121;
    }
    n = v11[2];
    v25 = calloc((signed int)v24 + 1, 1uLL);
    *(_QWORD *)(v93 + 32) = v25;
    if ( !v25 )
    {
      v85 = 609LL;
LABEL_137:
      v10 = -1;
      __printf_chk(1LL, "Out of Memory at %s : %i\n", "ytnef.c", v85, a5, a6);
      return v10;
    }
    v26 = *(const void **)v11;
    *(_DWORD *)(v93 + 40) = n;
    v27 = (char *)memcpy(v25, v26, v11[2]);
    v28 = 0LL;
    while ( 1 )
    {
      v29 = &v27[v28];
      v30 = *v29;
      if ( *v29 == 47 || v30 == 92 || !v30 )
        *v29 = 95;
      if ( *(_DWORD *)(v93 + 40) == (_DWORD)++v28 )
        break;
      v27 = *(char **)(v93 + 32);
    }
LABEL_17:
    if ( *((_DWORD *)v8 + 6) - 1 == v10 || v10 == -1 )
    {
      v8 += 48;
      v10 = -1;
    }
    ++v9;
  }
  while ( *(_DWORD *)v94 > v9 );
  v19 = v6 - v92;
  if ( v19 < v91 )
  {
    if ( *(_DWORD *)(v93 + 652) > 0 )
    {
      puts("ERROR DURING MAPI READ");
      __printf_chk(1LL, "Read %td bytes, Expected %u bytes\n", v19, v99, v73, v74);
      __printf_chk(1LL, "%td bytes missing\n", v91 - v19, v75, v76, v77);
    }
    return (unsigned int)-1;
  }
  v10 = 0;
  if ( v19 <= v91 )
    return v10;
  if ( *(_DWORD *)(v93 + 652) <= 0 )
    return (unsigned int)-1;
  v10 = -1;
  puts("ERROR DURING MAPI READ");
  __printf_chk(1LL, "Read %td bytes, Expected %u bytes\n", v19, v99, v86, v87);
  __printf_chk(1LL, "%li bytes extra\n", v19 - v91, v88, v89, v90);
  return v10;
}
