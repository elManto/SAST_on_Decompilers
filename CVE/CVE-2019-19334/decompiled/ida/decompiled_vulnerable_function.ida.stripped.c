signed __int64 __fastcall make_canonical(__int64 a1, unsigned int a2, const char **a3, char *a4, int *a5)
{
  void *v5; // rsp
  __int64 v6; // rbx
  char *v7; // r12
  size_t v8; // rax
  const char *v9; // rsi
  signed __int64 result; // rax
  unsigned int v11; // eax
  __int64 v12; // rax
  __int64 v13; // [rsp+0h] [rbp-B0h]
  int *v14; // [rsp+8h] [rbp-A8h]
  char *v15; // [rsp+10h] [rbp-A0h]
  const char **v16; // [rsp+18h] [rbp-98h]
  unsigned int v17; // [rsp+24h] [rbp-8Ch]
  __int64 v18; // [rsp+28h] [rbp-88h]
  unsigned __int8 v19; // [rsp+31h] [rbp-7Fh]
  unsigned __int16 v20; // [rsp+32h] [rbp-7Eh]
  int i; // [rsp+34h] [rbp-7Ch]
  int v22; // [rsp+38h] [rbp-78h]
  int v23; // [rsp+3Ch] [rbp-74h]
  char *s2; // [rsp+40h] [rbp-70h]
  __int64 v25; // [rsp+48h] [rbp-68h]
  char *s; // [rsp+50h] [rbp-60h]
  char *v27; // [rsp+58h] [rbp-58h]
  __int64 v28; // [rsp+60h] [rbp-50h]
  __int64 v29; // [rsp+68h] [rbp-48h]
  __int64 v30; // [rsp+70h] [rbp-40h]
  char *s1; // [rsp+78h] [rbp-38h]
  char *src; // [rsp+80h] [rbp-30h]
  unsigned __int64 v33; // [rsp+88h] [rbp-28h]

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = a5;
  v33 = __readfsqword(0x28u);
  v20 = 511;
  v25 = 511LL;
  v5 = alloca(512LL);
  s = (char *)&v13;
  v27 = 0LL;
  switch ( (unsigned __int64)a2 )
  {
    case 2uLL:
      v27 = v15;
      v23 = *v14;
      *s = 0;
      for ( i = 0; i < v23; ++i )
      {
        if ( *(_QWORD *)&v27[8 * i] )
        {
          if ( *s )
          {
            v6 = **(_QWORD **)&v27[8 * i];
            v7 = s;
            v8 = strlen(s);
            sprintf(&v7[v8], " %s", v6);
          }
          else
          {
            strcpy(s, **(const char ***)&v27[8 * i]);
          }
        }
      }
      goto LABEL_60;
    case 4uLL:
      v29 = *(_QWORD *)v15;
      v19 = *(_BYTE *)v14;
      if ( v29 )
      {
        v23 = sprintf(s, "%ld ", v29, a4, a5, 512LL);
        if ( v29 > 0 && v23 - 1 <= v19 || v23 - 2 <= v19 )
        {
          if ( v29 <= 0 )
            v11 = v19 + 2;
          else
            v11 = v19 + 1;
          v23 = sprintf(s, "%0*ld ", v11, v29);
        }
        i = v19;
        v22 = 1;
        while ( i > 0 )
        {
          if ( v22 && i > 1 && s[v23 - 2] == 48 )
          {
            s[v23 - 1] = 0;
          }
          else
          {
            v22 = 0;
            s[v23 - 1] = s[v23 - 2];
          }
          --v23;
          --i;
        }
        s[v23 - 1] = 46;
      }
      else
      {
        *(_DWORD *)s = 3157552;
      }
      goto LABEL_60;
    case 7uLL:
      s2 = v15;
      if ( strchr(*v16, 58) )
        strcpy(s, *v16);
      else
        sprintf(s, "%s:%s", s2, *v16);
      goto LABEL_60;
    case 8uLL:
      v9 = *v16;
      v30 = sub_CB4D2(v18, *v16, *v16, a4, a5, 512LL);
      if ( !v30 )
      {
        sub_12222(v18);
        return 0LL;
      }
      s2 = 0LL;
      v23 = 0;
      i = 0;
      break;
    case 0xCuLL:
    case 0xEuLL:
    case 0x10uLL:
    case 0x12uLL:
      v29 = *(_QWORD *)v15;
      sprintf(s, "%ld", v29, a4, a5, 512LL);
      goto LABEL_60;
    case 0xDuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x13uLL:
      v28 = *(_QWORD *)v15;
      sprintf(s, "%lu", v28, a4, a5, 512LL);
      goto LABEL_60;
    default:
      return 0LL;
  }
  while ( *(unsigned __int16 *)(v30 + 32) > (unsigned int)i )
  {
    s1 = (char *)(*(_QWORD *)(v30 + 40) + *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 8)));
    if ( i )
    {
      src = (char *)(*(_QWORD *)(v30 + 40)
                   + *(unsigned __int16 *)(2LL * i - 2 + *(_QWORD *)(v30 + 8))
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + *(_QWORD *)(v30 + 16)));
      if ( src != s1 )
      {
        if ( v23 + s1 - src > v20 )
        {
          sub_12222(v18);
          sub_C488D(v30, 0LL);
          return 0LL;
        }
        strncpy(&s[v23], src, s1 - src);
        v23 += (_DWORD)s1 - (_DWORD)src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *(_QWORD *)v30) == 9
      && (src = (char *)sub_811F(s1, 58LL, *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16)))) != 0LL )
    {
      v22 = (_DWORD)++src - (_DWORD)s1;
      if ( !s2 || strncmp(s1, s2, v22) )
      {
        if ( v22 + v23 > v20 )
        {
          sub_12222(v18);
          sub_C488D(v30, 0LL);
          return 0LL;
        }
        strncpy(&s[v23], s1, v22);
        v23 += v22;
      }
      s2 = s1;
      if ( v23 + *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16)) - v22 > v20 )
      {
        sub_12222(v18);
        sub_C488D(v30, 0LL);
        return 0LL;
      }
      v9 = src;
      strncpy(&s[v23], src, *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16)) - v22);
      v23 += *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16)) - v22;
    }
    else
    {
      if ( v23 + *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16)) > v20 )
      {
        sub_12222(v18);
        sub_C488D(v30, 0LL);
        return 0LL;
      }
      v9 = (const char *)(*(_QWORD *)(v30 + 40) + *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 8)));
      strncpy(&s[v23], v9, *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16)));
      v23 += *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v30 + 16));
    }
    ++i;
  }
  if ( v23 <= v20 )
  {
    s[v23] = 0;
    sub_C488D(v30, v9);
LABEL_60:
    if ( !strcmp(s, *v16) )
    {
      result = 0LL;
    }
    else
    {
      lydict_remove(v18, *v16);
      v12 = lydict_insert(v18, s, 0LL);
      *v16 = (const char *)v12;
      result = 1LL;
    }
  }
  else
  {
    sub_12222(v18);
    sub_C488D(v30, 0LL);
    result = 0LL;
  }
  return result;
}
