/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_7180();
// char *getenv(const char *name);
__int64 __fastcall lydict_insert_zc(_QWORD, _QWORD); // weak
__int64 __fastcall ly_vecode(_QWORD); // weak
// void free(void *ptr);
__int64 __fastcall lyd_schema_sort(_QWORD, _QWORD); // weak
__int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lys_is_disabled(_QWORD, _QWORD); // weak
__int64 __fastcall ly_err_print(_QWORD); // weak
__int64 __fastcall lyd_leaf_type(_QWORD, _QWORD); // weak
// int *__errno_location(void);
__int64 __fastcall ly_set_clean(_QWORD); // weak
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
__int64 __fastcall lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall ly_errno_glob_address(_QWORD); // weak
__int64 __fastcall ly_register_exts(_QWORD, _QWORD); // weak
// char *strcpy(char *dest, const char *src);
// int ferror(FILE *stream);
__int64 __fastcall lys_ext_instance_presence(_QWORD, _QWORD, _QWORD); // weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int isatty(int fd);
__int64 __fastcall ly_set_rm_index(_QWORD, _QWORD); // weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// double atof(const char *nptr);
__int64 __fastcall lyd_insert_after(_QWORD, _QWORD); // weak
__int64 __fastcall lyd_lyb_data_length(_QWORD, _QWORD); // weak
__int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// ssize_t readlink(const char *path, char *buf, size_t len);
// ssize_t write(int fd, const void *buf, size_t n);
__int64 __fastcall lyd_list_pos(_QWORD); // weak
// int vasprintf(char **ptr, const char *f, __gnuc_va_list arg);
__int64 __fastcall lyd_find_instance(_QWORD, _QWORD); // weak
__int64 __fastcall ly_ctx_info(_QWORD, _QWORD); // weak
// int fclose(FILE *stream);
// DIR *opendir(const char *name);
__int64 __fastcall lys_set_enabled(_QWORD); // weak
__int64 __fastcall lyd_node_module(_QWORD); // weak
__int64 __fastcall lys_search_localfile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// size_t strlen(const char *s);
__int64 __fastcall ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD); // weak
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
__int64 __fastcall lyd_change_leaf(_QWORD, _QWORD); // weak
// char *strchr(const char *s, int c);
__int64 __fastcall lys_features_enable(_QWORD, _QWORD); // weak
__int64 __fastcall ly_set_free(_QWORD); // weak
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// char *strrchr(const char *s, int c);
__int64 __fastcall lys_set_implemented(_QWORD); // weak
__int64 __fastcall ly_set_contains(_QWORD, _QWORD); // weak
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
__int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lyd_dup_to_ctx(_QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall pcre_exec(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall lyxml_parse_mem(_QWORD, _QWORD, _QWORD); // weak
// void *memset(void *s, int c, size_t n);
__int64 __fastcall ly_clean_plugins(_QWORD); // weak
// int close(int fd);
__int64 __fastcall lys_parent(_QWORD); // weak
__int64 __fastcall lyd_insert_before(_QWORD, _QWORD); // weak
// int closedir(DIR *dirp);
// char *strtok_r(char *s, const char *delim, char **save_ptr);
// char *strndup(const char *string, size_t n);
__int64 __fastcall lyd_find_path(_QWORD, _QWORD); // weak
// int memcmp(const void *s1, const void *s2, size_t n);
__int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD); // weak
// __int64 __fastcall __tls_get_addr(_QWORD); weak
__int64 __fastcall lyd_merge_to_ctx(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lyxml_free_withsiblings(_QWORD, _QWORD); // weak
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// void *calloc(size_t nmemb, size_t size);
__int64 __fastcall ly_ctx_set_searchdir(_QWORD, _QWORD); // weak
// int strcmp(const char *s1, const char *s2);
// __int64 strtoll(const char *nptr, char **endptr, int base);
__int64 __fastcall ly_register_types(_QWORD, _QWORD); // weak
// int fprintf(FILE *stream, const char *format, ...);
__int64 __fastcall lyd_free_withsiblings(_QWORD); // weak
__int64 __fastcall lys_path(_QWORD, _QWORD); // weak
// __int64 strtol(const char *nptr, char **endptr, int base);
// void clearerr(FILE *stream);
// char *realpath(const char *name, char *resolved);
// void *memcpy(void *dest, const void *src, size_t n);
// int fileno(FILE *stream);
__int64 __fastcall ly_ctx_destroy(_QWORD, _QWORD); // weak
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// struct dirent *readdir(DIR *dirp);
__int64 __fastcall ly_err_first(_QWORD); // weak
__int64 __fastcall lyd_validate_value(_QWORD, _QWORD); // weak
// void *dlopen(const char *file, int mode);
// int tolower(int c);
// char *get_current_dir_name(void);
// void *pthread_getspecific(pthread_key_t key);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// __int64 __fastcall pcre_compile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void *malloc(size_t size);
// int fflush(FILE *stream);
// int _IO_getc(_IO_FILE *fp);
__int64 __fastcall ly_set_new(_QWORD); // weak
__int64 __fastcall ly_err_clean(_QWORD, _QWORD); // weak
__int64 __fastcall lyd_first_sibling(_QWORD); // weak
__int64 __fastcall lys_parse_mem(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lys_find_path(_QWORD, _QWORD, _QWORD); // weak
// int __fxstat(int ver, int fildes, struct stat *stat_buf);
// time_t mktime(struct tm *tp);
// char *strpbrk(const char *s, const char *accept);
__int64 __fastcall lyd_unlink(_QWORD); // weak
__int64 __fastcall lys_is_key(_QWORD, _QWORD); // weak
// int dlclose(void *handle);
__int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lyd_dup(_QWORD, _QWORD); // weak
__int64 __fastcall lyxml_get_ns(_QWORD, _QWORD); // weak
__int64 __fastcall lyxml_free(_QWORD, _QWORD); // weak
__int64 __fastcall lyd_validate(_QWORD, _QWORD, _QWORD); // weak
// void *realloc(void *ptr, size_t size);
__int64 __fastcall ly_ctx_get_node(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall pcre_free_study(_QWORD); weak
// int asprintf(char **ptr, const char *fmt, ...);
__int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD); // weak
// int munmap(void *addr, size_t len);
__int64 __fastcall lyd_path(_QWORD); // weak
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
__int64 __fastcall lyd_parse_xml(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lys_main_module(_QWORD); // weak
__int64 __fastcall lyd_print_mem(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// void *memmove(void *dest, const void *src, size_t n);
// long double strtold(const char *nptr, char **endptr);
__int64 __fastcall lyxml_print_mem(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall ly_ctx_get_searchdirs(_QWORD); // weak
__int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lyd_wd_default(_QWORD); // weak
__int64 __fastcall lyd_insert_sibling(_QWORD, _QWORD); // weak
__int64 __fastcall lyd_insert(_QWORD, _QWORD); // weak
__int64 __fastcall lyd_print_file(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall pcre_study(_QWORD, _QWORD, _QWORD); weak
// int open(const char *file, int oflag, ...);
// int vdprintf(int fd, const char *fmt, __gnuc_va_list arg);
// int access(const char *name, int type);
// FILE *fopen(const char *filename, const char *modes);
// __int64 sysconf(int name);
__int64 __fastcall ly_errpath(_QWORD, _QWORD); // weak
__int64 __fastcall lys_print_file(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// unsigned __int64 strtoul(const char *nptr, char **endptr, int base);
__int64 __fastcall ly_ctx_get_submodule2(_QWORD, _QWORD); // weak
// int atoi(const char *nptr);
__int64 __fastcall lyd_new(_QWORD, _QWORD, _QWORD); // weak
// int pthread_key_delete(pthread_key_t key);
// int sprintf(char *s, const char *format, ...);
// void __noreturn exit(int status);
__int64 __fastcall ly_ctx_internal_modules_count(_QWORD); // weak
__int64 __fastcall lyd_free_diff(_QWORD, _QWORD); // weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
__int64 __fastcall lyd_merge(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lys_parse_fd(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lyxml_unlink(_QWORD, _QWORD); // weak
// char *strdup(const char *s);
// char *strerror(int errnum);
// void *dlsym(void *handle, const char *name);
__int64 __fastcall lys_node_module(_QWORD); // weak
// char *strptime(const char *s, const char *fmt, struct tm *tp);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
__int64 __fastcall lyd_free(_QWORD); // weak
__int64 __fastcall ly_ctx_load_module(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall lydict_remove(_QWORD, _QWORD); // weak
// char *strstr(const char *haystack, const char *needle);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
__int64 __fastcall ly_ctx_new(_QWORD, _QWORD); // weak
// char *dlerror(void);
// const unsigned __int16 **__ctype_b_loc(void);
__int64 __fastcall ly_load_plugins(_QWORD); // weak
__int64 __fastcall lys_set_disabled(_QWORD, _QWORD); // weak
__int64 __fastcall j_lyd_parse_mem(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall _cxa_finalize(_QWORD); weak
char *start();
__int64 sub_7CD0();
char *sub_7D20();
__int64 sub_7D60();
__int64 __fastcall ly_errno_glob_address(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_vecode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_errmsg(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_errpath(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_errapptag(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall ly_err_first(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall destr_function(void *a1);
__int64 __fastcall ly_err_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE *__fastcall sub_80BC(_BYTE *a1, _BYTE *a2, int a3);
_BYTE *__fastcall sub_811F(_BYTE *a1, char a2, int a3);
const char *__fastcall sub_8164(unsigned int a1);
__int64 __fastcall sub_831C(__int64 a1, const char *a2);
signed __int64 __fastcall sub_83E9(_QWORD *a1, const char *a2, void **a3, __int64 *a4, size_t *a5, int a6, int a7, void **a8, void **a9, unsigned int *a10);
__int64 __fastcall sub_8F60(__int64 *a1, const char *a2, int a3, int a4, void **a5, void **a6, unsigned int *a7);
__int64 __fastcall sub_912E(__int64 *a1, const char *a2, int a3, void **a4, void **a5, unsigned int *a6);
__int64 __fastcall sub_9182(__int64 *a1, const char *a2);
signed __int64 __fastcall sub_91C4(__int64 a1, const char *a2, void **a3, __int64 *a4, size_t *a5, char *a6, int a7, int a8);
__int64 __fastcall sub_9A10(__int64 a1, const char *a2, char *a3, unsigned int a4, unsigned int a5);
char *__fastcall ly_path_xml2json(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_9BED(__int64 *a1, const char *a2);
__int64 __fastcall sub_A2CB(__int64 *a1, const char *a2);
signed __int64 __fastcall sub_A671(void **a1, __int64 a2, __int64 a3, _DWORD *a4, int a5, void **a6, __int64 *a7, size_t *a8);
void *__fastcall sub_B085(void **a1, const char *a2);
signed __int64 __fastcall sub_B202(__int64 a1, _QWORD *a2, unsigned __int16 a3, void **a4, _WORD *a5);
signed __int64 __fastcall sub_B369(void *a1, const char **a2, __int64 a3, _QWORD *a4, unsigned __int16 *a5, void **a6, _WORD *a7);
void *__fastcall ly_path_data2schema(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_C3AB(__int64 a1);
void *__fastcall sub_C422(void *a1, size_t a2);
signed __int64 __fastcall sub_C462(_BYTE *a1, _BYTE *a2);
signed __int64 __fastcall sub_C4C9(unsigned __int8 a1);
signed __int64 __fastcall sub_C508(signed __int64 a1, unsigned __int8 a2, signed __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_C5A1(const char **a1, unsigned __int8 a2);
signed __int64 __fastcall sub_C70A(__int64 a1, __int64 a2, int a3);
size_t __fastcall sub_C76D(const char *a1);
__int64 __fastcall ly_ctx_internal_modules_count(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
pthread_key_t *__fastcall ly_ctx_new(const char *a1, pthread_key_t a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CB4C(__int64 a1, __int64 a2);
__int64 __fastcall sub_CD97(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 (__fastcall *a5)(__int64, __int64, _QWORD, _QWORD, _QWORD));
__int64 __fastcall ly_ctx_new_ylpath(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_new_ylmem(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_D149(__int64 a1, int a2);
__int64 __fastcall sub_D173(__int64 a1, int a2);
__int64 __fastcall ly_ctx_set_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_unset_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_set_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_unset_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_set_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_unset_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_set_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_unset_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_set_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_unset_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_options(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_ctx_set_searchdir(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_unset_searchdirs(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall ly_ctx_destroy(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_submodule2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_submodule(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_DCEF(__int64 a1, const char *a2, size_t a3, int a4, char *a5, __int64 a6, int a7);
__int64 __fastcall ly_ctx_get_module_by_ns(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_module(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_E085(__int64 a1, const char *a2, size_t a3, char *a4, int a5);
__int64 __fastcall ly_ctx_get_module_older(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall ly_ctx_set_module_imp_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_module_imp_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall ly_ctx_set_module_data_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_module_data_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_E447(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_EB1C(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_ECF1(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6);
__int64 __fastcall ly_ctx_load_module(__int64 a1, char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_F0B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_F559(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lys_set_disabled(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_FD3F(__int64 a1, __int64 a2);
signed __int64 __fastcall lys_set_enabled(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_ctx_remove_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall ly_ctx_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_module_iter(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_disabled_module_iter(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_10999(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_10B6F(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_10D68(__int64 a1, __int64 a2, int a3);
__int64 __fastcall ly_ctx_get_module_set_id(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_info(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_get_node(void *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_ctx_find_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_verb(char a1);
__int64 __fastcall ly_log_options(char a1);
__int64 __fastcall ly_verb_dbg(unsigned int a1);
__int64 __fastcall ly_set_log_clb(__int64 a1, unsigned int a2);
__int64 (__fastcall *ly_get_log_clb())(_QWORD, _QWORD, _QWORD);
__int64 __fastcall sub_11BDA(void *a1, unsigned int a2, int a3, int a4, void *a5, void *a6, void *a7);
unsigned __int64 __fastcall sub_11EB0(void *a1, unsigned int a2, int a3, int a4, void *a5, char *a6, void *a7);
unsigned __int64 sub_12222(__int64 a1, unsigned int a2, int a3, char *a4, __int64 a5, __int64 a6, ...);
unsigned __int64 sub_12312(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...);
unsigned __int64 lyext_log(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...);
unsigned __int64 lyext_vlog(void *a1, int a2, __int64 a3, __int64 a4, int a5, char *a6, __int64 a7, ...);
signed __int64 __fastcall sub_129CF(void **a1, unsigned __int16 *a2, void *a3, unsigned __int16 a4, unsigned __int16 *a5);
signed __int64 __fastcall sub_12B3E(unsigned int a1, char *a2, void **a3, int a4, int a5);
unsigned __int64 sub_13937(void *a1, int a2, unsigned int a3, char *a4, __int64 a5, __int64 a6, ...);
unsigned __int64 sub_13C4A(void *a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6, ...);
int __fastcall ly_err_print(unsigned int *a1);
__int64 __fastcall sub_13FA5(__int64 a1, __int64 a2);
__int64 __fastcall sub_1404C(__int64 a1, __int64 a2);
void __fastcall sub_1409D(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_141E4(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4);
void __fastcall sub_142D2(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall sub_14407(__int64 a1, const char *a2);
_BOOL8 __fastcall sub_1446B(const char **a1, char **a2, __int64 a3, size_t *a4, __int64 a5, __int64 a6);
int __fastcall sub_14546(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
int __fastcall sub_145FF(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14701(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_1476E(unsigned int a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall lydict_remove(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_149A6(__int64 *a1, void *a2, size_t a3, int a4);
__int64 __fastcall lydict_insert(__int64 a1, char *a2, size_t a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lydict_insert_zc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14C8D(__int64 a1, unsigned __int16 a2, int a3);
_QWORD *__fastcall sub_14CB1(unsigned int a1, __int16 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_14E64(__int64 a1, __int64 a2);
__int64 __fastcall sub_14E8E(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14EB8(unsigned int *a1);
void __fastcall sub_14F6B(void **a1);
signed __int64 __fastcall sub_14F9D(__int64 a1, int a2);
signed __int64 __fastcall sub_1510F(__int64 a1, int a2, _QWORD *a3);
signed __int64 __fastcall sub_152D5(__int64 a1, const void **a2, const void *a3);
signed __int64 __fastcall sub_154F1(__int64 a1, __int64 a2, int a3, _QWORD *a4);
signed __int64 __fastcall sub_15669(__int64 a1, __int64 a2, int a3, _QWORD *a4);
char *__fastcall sub_15881(__int64 a1, int a2, unsigned __int16 a3);
unsigned __int64 __fastcall sub_15936(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_15B2B(__int64 a1, unsigned int a2, unsigned __int16 a3, __int64 a4);
signed __int64 __fastcall sub_15BA6(__int64 a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_15F55(__int64 a1, const void *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_15F8D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_16271(_QWORD *a1, unsigned __int8 a2, _QWORD *a3);
__int64 __fastcall sub_16564(_BYTE *a1);
__int64 __fastcall sub_16637(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, int a7);
__int64 __fastcall sub_169E9(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8);
__int64 __fastcall sub_16CF6(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, signed int *a6);
__int64 __fastcall sub_17055(__int64 a1, const char *a2, const char **a3, unsigned int *a4, _QWORD *a5, unsigned int *a6, signed int *a7, _DWORD *a8);
__int64 __fastcall sub_1729D(_BYTE *a1, signed __int64 *a2, unsigned int *a3, signed __int64 *a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_17401(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8);
__int64 __fastcall sub_17847(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, int a9);
__int64 __fastcall sub_179A7(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8);
_BOOL8 __fastcall sub_17DBA(const char **a1, const char ***a2, int a3, __int64 a4);
__int64 __fastcall sub_181E5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9);
signed __int64 __fastcall sub_1844C(char *a1, unsigned __int16 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_18B8D(__int64 a1);
__int64 __fastcall sub_18BF1(__int64 *a1, int *a2, _DWORD *a3);
__int64 __fastcall sub_18D14(__int64 a1);
signed __int64 __fastcall sub_18D8D(signed int *a1, char a2);
__int64 __fastcall sub_18E56(__int64 a1);
void __fastcall sub_18E88(__int64 a1);
__int64 __fastcall sub_18EB1(__int64 a1, unsigned __int8 a2, int a3);
__int64 __fastcall sub_18F95(__int64 a1, int a2);
__int64 __fastcall sub_1902D(__int64 *a1, int *a2, _DWORD *a3);
signed __int64 __fastcall sub_19120(__int64 *a1, char *a2, __int64 a3, int a4, __int64 a5);
__int64 *__fastcall sub_19BA2(const char *a1, __int64 *a2);
signed __int64 __fastcall sub_19DE6(const char **a1, __int64 *a2, char *a3, int a4, const char *a5, int a6);
signed __int64 __fastcall sub_19ED6(_BYTE *a1, __int64 a2, void **a3, _DWORD *a4);
signed __int64 __fastcall sub_1A193(char *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5, int a6);
signed __int64 __fastcall sub_1AF63(const char *a1, __int64 a2, int a3, int a4, _QWORD *a5);
signed __int64 __fastcall sub_1B236(const char *a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_1B28A(_BYTE *a1, __int64 a2, __int64 *a3);
signed __int64 __fastcall sub_1B39D(const char *a1, __int64 *a2, int a3, _QWORD *a4);
__int64 __fastcall sub_1B647(_BYTE *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_1B854(char *a1, void *a2, __int64 a3, int a4);
signed __int64 __fastcall sub_1C23B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9);
__int64 **__fastcall sub_1C6D1(const char *a1, void *a2, __int64 *a3, char a4, _DWORD *a5);
signed __int64 __fastcall sub_1D702(void *a1, char *a2, __int64 a3, void **a4);
signed __int64 __fastcall sub_1E592(signed __int64 a1);
signed __int64 __fastcall sub_1E65A(const char *a1, const char *a2, __int64 a3, __int64 a4, signed __int64 *a5);
__int64 __fastcall sub_1EAAF(_QWORD *a1, const char **a2, void **a3, int a4);
signed __int64 __fastcall sub_1F3F0(__int64 a1, int a2, const char *a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1F79E(__int64 a1, const char *a2, _BYTE *a3);
__int64 __fastcall sub_1FB5F(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_1FBFE(__int64 *a1, const char *a2, int a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_1FEA6(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_1FF4C(_BYTE *a1, __int64 a2, char *a3, __int64 a4);
__int64 __fastcall sub_20624(__int64 a1);
__int64 __fastcall sub_20BE2(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_21572(__int64 a1, __int64 a2, int a3, char *a4);
signed __int64 __fastcall sub_2170F(__int64 a1, __int64 a2, __int64 **a3, int a4);
signed __int64 __fastcall sub_21FB6(__int64 a1, int a2);
signed __int64 __fastcall sub_220D4(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_22209(__int64 a1, unsigned int a2, unsigned int a3);
signed __int64 __fastcall sub_2245A(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_22CDC(_QWORD *a1, __int64 **a2, __int64 a3);
__int64 __fastcall sub_23C04(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_23C91(__int64 a1, __int64 a2);
__int64 __fastcall sub_258B4(__int128 a1);
signed __int64 __fastcall sub_25971(__int64 a1, _QWORD *a2, char *a3, __int64 a4, signed __int64 *a5);
signed __int64 __fastcall sub_25CE3(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_260D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_26148(signed __int64 a1, char *a2, char *a3, __int64 *a4, int a5);
signed __int64 __fastcall sub_26D87(_BYTE **a1, __int64 a2);
signed __int64 __fastcall sub_271C8(__int64 a1, char *a2);
signed __int64 __fastcall sub_275C3(char *a1, unsigned int a2, unsigned int a3);
__int64 *__fastcall sub_27A8D(__int64 a1, __int64 *a2, _DWORD *a3);
signed __int64 __fastcall sub_27B5A(_QWORD *a1, __int64 a2, _QWORD *a3, _DWORD *a4);
signed __int64 __fastcall sub_27CDB(__int64 a1, __int64 *a2, __int64 *a3, unsigned int a4, __int64 a5);
signed __int64 __fastcall sub_27FD3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_28087(_QWORD *a1);
__int64 __fastcall sub_281C9(__int64 a1);
signed __int64 __fastcall sub_28290(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_28399(__int64 a1, int a2, __int64 *a3);
signed __int64 __fastcall sub_28E3C(__int64 a1);
signed __int64 __fastcall sub_28EDE(void **a1, __int64 a2, unsigned int a3, unsigned __int8 *a4, __int64 a5);
unsigned __int64 __fastcall sub_2A1A7(__int64 *a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_2A690(__int64 a1, int a2, __int64 a3, int a4, int a5, _DWORD *a6);
signed __int64 __fastcall sub_2A9F8(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_2AB62(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 a5);
signed __int64 __fastcall sub_2ABDE(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 *a5);
signed __int64 __fastcall sub_2B0C1(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5);
signed __int64 __fastcall sub_2B3F8(__int64 a1, int a2, __int64 a3, int a4);
_DWORD *__fastcall sub_2B4F8(__int64 a1, _QWORD *a2, unsigned int a3);
void *__fastcall sub_2B768(__int64 a1, void ***a2, int a3);
signed __int64 __fastcall sub_2B8E0(__int64 a1, const char *a2);
signed __int64 __fastcall sub_2BAA8(char *a1, __int64 a2, int a3, _QWORD *a4);
signed __int64 __fastcall sub_2C0A6(__int64 a1, const char *a2, int a3, _QWORD *a4);
signed __int64 __fastcall sub_2C282(__int64 a1, _DWORD *a2, int a3, int a4, _QWORD *a5);
signed __int64 __fastcall sub_2C85B(char *a1, unsigned int a2, unsigned int a3, __int64 *a4);
signed __int64 __fastcall sub_2CD1C(__int64 a1, __int64 a2, int a3);
_QWORD *__fastcall sub_2CEE7(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_2D16B(__int64 a1, __int64 a2, __int64 a3, __int16 a4);
signed __int64 __fastcall sub_2DB2D(char *a1);
signed __int64 __fastcall sub_2DC82(char *a1, __int16 a2, __int64 a3);
signed __int64 __fastcall sub_2E0DF(__int64 ***a1, __int64 *a2, __int64 a3, int a4);
signed __int64 __fastcall sub_2E5BD(char *a1);
signed __int64 __fastcall sub_2EB38(_QWORD **a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_2EE3F(__int64 a1, __int64 a2);
__int64 __fastcall sub_2F1BE(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_2F304(__int64 a1, unsigned __int8 a2, __int64 a3);
signed __int64 __fastcall sub_2F3D1(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_2F7BD(char *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_3010D(__int64 *a1, __int64 a2, char **a3, int a4, char *a5);
__int64 __fastcall lyxml_get_ns(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned int *__fastcall sub_304CF(__int64 a1, unsigned int *a2, __int64 a3, int a4);
unsigned int *__fastcall sub_305D2(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_30771(__int64 a1, _QWORD *a2, int a3, int a4);
_QWORD *__fastcall sub_30929(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5);
_QWORD *__fastcall lyxml_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_30B77(__int64 a1, _QWORD *a2, int a3);
unsigned __int64 __fastcall lyxml_unlink(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_30D07(__int64 a1, __int64 a2, _QWORD *a3);
_QWORD *__fastcall sub_30DDD(__int64 a1, __int64 a2);
void __fastcall sub_30E67(__int64 a1, _QWORD *a2);
void __fastcall lyxml_free(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall lyxml_free_withsiblings(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyxml_get_attr(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_3116F(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_3127E(void *a1, char *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_31603(void *a1, const char *a2, const char *a3, _DWORD *a4);
char *__fastcall sub_316C2(void *a1, __int64 a2, char a3, _DWORD *a4, __int64 a5, __int64 a6);
void *__fastcall sub_3223C(void *a1, char *a2, _DWORD *a3, __int64 a4);
char *__fastcall sub_32A07(void *a1, void *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
char *__fastcall lyxml_parse_mem(void *a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyxml_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_341EA(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_3430E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_34926(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyxml_print_file(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyxml_print_fd(int a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyxml_print_mem(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyxml_print_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall sub_34D50(__int64 a1);
signed __int64 __fastcall sub_34DD2(__int64 a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall sub_34EE2(__int64 a1, int a2, __int64 a3, size_t *a4, void **a5);
int __fastcall sub_351B4(void *a1, size_t a2);
_BOOL8 __fastcall sub_351D9(__int64 a1);
signed __int64 __fastcall sub_35CB4(const char *a1, __int64 a2, __int64 a3, int a4, __int64 *a5, char *a6);
signed __int64 __fastcall sub_35E42(const char *a1, unsigned __int64 a2, int a3, unsigned __int64 *a4, char *a5);
signed __int64 __fastcall sub_35FD9(char a1, unsigned __int64 a2, signed __int64 a3, signed __int64 a4, unsigned __int8 a5, __int64 a6, void *a7, char *a8);
signed __int64 __fastcall sub_363C2(void *a1, char *a2, __int64 a3, char *a4);
char **__fastcall sub_36760(char *a1, char **a2, int a3);
__int64 __fastcall sub_36896(void *a1, char *a2, int *a3);
signed __int64 __fastcall sub_36C95(void *a1, const char *a2, void **a3);
signed __int64 __fastcall sub_372F0(void *a1, const char *a2, void **a3, _QWORD *a4);
signed __int64 __fastcall sub_373C5(void *a1, unsigned int a2, const char **a3, char *a4, int *a5);
__int64 __fastcall sub_37D41(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_37EF5(signed __int64 a1, char **a2, __int64 a3, __int64 **a4, __int64 a5, __int64 *a6, int a7, int a8, int a9);
unsigned __int64 __fastcall sub_3A9DE(signed __int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_3AB03(__int64 a1, char *a2, __int64 a3, __int64 a4, _BYTE *a5, __int64 a6, __int64 a7, __int16 a8, char ***a9);
signed __int64 __fastcall sub_3AF7B(_QWORD *a1, _QWORD *a2, char *a3, _DWORD *a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_3B4E8(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_3B53E(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3B6AA(const char *a1, __int64 a2, int a3);
signed __int64 __fastcall sub_3B709(const char *a1, __int64 a2);
signed __int64 __fastcall sub_3B772(const char *a1, __int64 a2);
signed __int64 __fastcall sub_3B812(void *a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_3C2C9(void *a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_3C4A2(__int64 a1);
signed __int64 __fastcall sub_3C596(__int64 *a1, __int64 a2);
signed __int64 __fastcall sub_3C679(__int64 a1);
signed __int64 __fastcall sub_3C749(char a1, void **a2, __int64 a3, char a4, __int64 a5, __int64 a6, char *a7);
signed __int64 __fastcall sub_3C867(_BYTE *a1, int a2);
unsigned __int64 __fastcall sub_3C9F7(__int64 *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_3CBF8(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_3CCDF(__int64 *a1);
unsigned __int64 __fastcall sub_3CDA9(__int64 a1);
signed __int64 __fastcall sub_3CE2E(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_3D0D7(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4);
signed __int64 __fastcall sub_3D333(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_3D700(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_3D76E(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_3DBD2(__int64 a1);
void __fastcall sub_3DD01(__int64 a1, void **a2, unsigned __int8 *a3, unsigned __int8 a4);
signed __int64 __fastcall sub_3DE4E(__int64 a1, __int64 a2, int a3, __int64 a4);
signed __int64 __fastcall sub_3E3AF(__int64 a1);
signed __int64 __fastcall sub_3E959(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3EDFE(__int64 a1, __int64 **a2);
signed __int64 __fastcall sub_3EF69(__int64 a1, __int64 a2, int a3, __int64 a4);
signed __int64 __fastcall sub_3F5FE(__int64 a1);
signed __int64 __fastcall sub_3FA66(__int64 a1);
signed __int64 __fastcall sub_3FFC3(__int64 *a1);
signed __int64 __fastcall sub_40272(void *a1, _BYTE *a2, signed int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_40445(void *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_407F3(__int64 *a1, const char *a2, int a3, char *a4, int a5, int a6);
__int64 __fastcall sub_40BA1(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_40CD4(_QWORD *a1);
__int64 __fastcall sub_40D5F(__int64 a1, const char *a2, int a3);
_BOOL8 __fastcall sub_40F96(__int64 a1, int a2, int a3, char a4, __int64 *a5, __int64 a6, __int64 *a7, char a8, __int64 a9);
__int64 __fastcall sub_410A7(void *a1, __int64 a2, const char *a3);
signed __int64 __fastcall sub_411CA(__int64 *a1, __int64 a2, unsigned int a3, _QWORD *a4, int a5, __int64 a6, __int64 a7);
signed __int64 __fastcall sub_41746(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_41AE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_421DA(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_426E1(__int64 a1, char *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
signed __int64 __fastcall sub_4778E(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_47EF1(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_4852A(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_489FC(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4);
signed __int64 __fastcall sub_48AF6(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_48E4C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_492EA(__int64 a1, __int64 a2, _DWORD *a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_49735(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_4E308(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
signed __int64 __fastcall sub_4EC3D(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_505F3(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_50E7D(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_51597(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5, char a6, __int64 a7);
_QWORD *__fastcall sub_51F02(__int64 *a1, __int64 a2, __int64 a3);
unsigned __int8 *__fastcall sub_522BA(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_52E00(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_53A72(__int64 *a1, char *a2, __int64 a3, int a4, unsigned int a5, __int64 a6);
unsigned __int8 *__fastcall sub_54422(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
__int64 __fastcall sub_551D2(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_56721(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_587B3(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_599C2(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_5A553(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_5B1D8(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
unsigned __int8 *__fastcall sub_5C028(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 *__fastcall sub_5CBDA(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
__int64 __fastcall sub_5D54B(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_609BB(void **a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_60D3A(void *a1, __int64 a2, char *a3, int a4);
__int64 __fastcall sub_61383(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
signed __int64 __fastcall sub_6141C(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, char *a5, char *a6, __int64 a7);
signed __int64 __fastcall sub_6164E(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, int a5, const char *a6, __int64 a7);
_WORD *__fastcall sub_62180(__int64 a1, __int64 a2, unsigned int a3, unsigned __int16 a4);
_BOOL8 __fastcall sub_6228E(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, char *a5, char *a6, __int64 a7, __int16 a8, __int16 a9, __int64 a10);
__int64 *__fastcall sub_62426(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_62554(__int64 a1, __int64 a2, unsigned int a3);
_BOOL8 __fastcall sub_627C3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_66992(__int64 a1, __int64 a2, unsigned int a3);
_BOOL8 __fastcall sub_66AA4(char **a1, __int64 a2, char a3, int a4);
signed __int64 __fastcall sub_66BD2(__int64 a1, __int64 a2, char *a3, char *a4, __int64 a5, __int64 a6, __int64 a7, char **a8, char **a9, const char *a10);
char *lyd_parse_xml(__int64 a1, _QWORD *a2, unsigned int a3, ...);
signed __int64 __fastcall sub_69481(signed int a1);
__int64 __fastcall sub_694B2(__int64 a1);
char *__fastcall sub_694FC(void *a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_69CA9(void *a1, _BYTE *a2);
char *__fastcall sub_69FBF(void *a1, char *a2, unsigned int a3, char *a4);
__int64 __fastcall sub_6A438(void *a1, const char *a2);
__int64 __fastcall sub_6A529(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_6A75A(char *a1, char **a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_6AF0B(__int64 *a1, _QWORD *a2, __int64 a3, __int16 a4);
signed __int64 __fastcall sub_6B4DE(_QWORD *a1, _QWORD *a2, __int64 a3, char a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_6B70E(void *a1, char *a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_6B929(__int64 a1, _BYTE *a2, _QWORD *a3, char **a4, __int64 a5, __int64 a6, void **a7, unsigned int a8, __int64 a9, _QWORD *a10, const char *a11);
__int64 __fastcall sub_6D5D5(__int64 a1, __int64 a2, unsigned int a3, __int64 *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_6DF5C(__int64 a1);
__int64 __fastcall sub_6DF6A(__int64 a1, char *a2, size_t a3, __int64 a4);
signed __int64 __fastcall sub_6E1EC(_WORD *a1, unsigned __int64 a2, size_t a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_6E321(_WORD *a1, unsigned int a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_6E3A6(__int64 a1, void **a2, int a3, __int64 a4);
__int64 __fastcall sub_6E67A(__int64 a1);
signed __int64 __fastcall sub_6E6F0(__int16 *a1, __int64 a2);
signed __int64 __fastcall sub_6E8DA(__int64 a1, __int64 a2, __int64 a3);
_BYTE *__fastcall sub_6EC05(__int64 a1);
signed __int64 __fastcall sub_6ED63(char *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_6EEF7(signed __int64 a1, unsigned int a2, char a3, __int64 a4, _QWORD *a5, _WORD *a6, __int64 a7);
signed __int64 __fastcall sub_6F3B4(signed __int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_6FED3(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_7018E(__int64 a1, __int64 a2, _QWORD *a3, __int16 a4, __int64 a5);
signed __int64 __fastcall sub_704EC(__int64 a1, __int64 a2, __int16 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_708AD(const char **a1, __int64 a2, unsigned __int8 a3);
signed __int64 __fastcall sub_7090B(__int64 a1, __int64 a2, __int64 a3, char *a4, int a5, const char ***a6, __int64 a7);
signed __int64 __fastcall sub_70D13(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_70DDA(__int16 *a1, __int64 *a2, __int64 a3, char *a4, int a5, __int64 a6, __int64 a7);
signed __int64 __fastcall sub_7133F(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_71473(__int64 a1, __int64 a2);
__int64 __fastcall sub_7162D(__int64 a1, __int64 a2);
char **__fastcall sub_7168F(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, char *a5, __int64 a6);
signed __int64 __fastcall lyd_lyb_data_length(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_71FFF(__int64 a1, signed int a2, void **a3, __int64 a4, __int64 a5, __int64 **a6);
__int64 __fastcall sub_7212F(_QWORD, _QWORD); // weak
unsigned __int64 __fastcall sub_85F41(unsigned int *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_86095(__int64 a1, __int64 a2, unsigned __int64 a3);
signed __int64 __fastcall sub_89947(unsigned __int64 a1);
__int64 __fastcall sub_8A031(__int64 a1);
__int64 __fastcall sub_8A175(signed int a1, __int64 a2);
__int64 __fastcall sub_8A287(FILE *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_8A361(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_8A47F(__int64 a1);
_DWORD *__fastcall sub_8A526(FILE *a1, int a2, __int64 a3);
void __fastcall sub_8A5E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_8A68F(__int64 a1, FILE *a2, __int64 a3);
__int64 __fastcall sub_8A769(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_8A81C(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_8A94D(__int64 a1);
unsigned __int64 __fastcall sub_8AA59(unsigned __int64 a1);
_DWORD *__fastcall sub_8ABCE(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
_DWORD *__fastcall sub_8ACE3(const char *a1, unsigned __int64 a2);
_DWORD *__fastcall sub_8AD15(__int64 a1, int a2, unsigned __int64 a3);
void __fastcall __noreturn sub_8AE04(__int64 a1);
__int64 __fastcall sub_8AE48(__int64 a1);
__int64 __fastcall sub_8AE61(__int64 a1);
__int64 __fastcall sub_8AEC3(__int64 a1);
__int64 __fastcall sub_8AF25(__int64 a1);
__int64 __fastcall sub_8AF3F(__int64 a1);
__int64 __fastcall sub_8AF59(__int64 a1);
__int64 __fastcall sub_8AF72(__int64 a1);
_QWORD *__fastcall sub_8AF8F(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_8AFB1(int a1, __int64 a2);
__int64 __fastcall sub_8B02A(int a1, __int64 a2);
__int64 __fastcall sub_8B0A3(__int64 a1, __int64 a2);
__int64 __fastcall sub_8B0C6(__int64 a1, __int64 a2);
__int64 __fastcall sub_8B0E9(__int64 a1);
__int64 __fastcall sub_8B102(int a1, __int64 a2);
__int64 __fastcall sub_8B122(__int64 a1);
__int64 __fastcall sub_8B13F(__int64 a1, __int64 a2);
__int64 __fastcall sub_8B165(__int64 a1);
__int64 __fastcall sub_8B182(__int64 a1, __int64 a2);
__int64 __fastcall sub_8B1A8(void **a1);
__int64 __fastcall sub_8B22E(__int64 a1, void **a2);
__int64 __fastcall sub_8B330(__int64 a1);
__int64 __fastcall sub_8B3C7(__int64 a1);
void *__fastcall sub_8B4E8(size_t a1);
void *__fastcall sub_8B50E(void *a1, size_t a2);
void __fastcall sub_8B53F(void *a1);
signed __int64 __fastcall sub_8B566(void **a1, _QWORD *a2, __int64 a3, __int64 a4, void *a5, char *a6);
__int64 __fastcall sub_8B60F(void **a1, void *a2, unsigned int a3);
__int64 __fastcall sub_8B770(__int64 a1, __int64 a2, const char *a3, int a4);
signed __int64 __fastcall sub_8B91C(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall sub_8B9EC(__int64 *a1, __int64 a2, __int64 *a3, void *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_8BBC1(__int64 a1, __int64 a2, void *a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_8BD50(__int64 a1, __int64 a2, void *a3, __int64 a4, unsigned int a5);
_BOOL8 __fastcall sub_8BEDF(__int64 *a1, __int64 *a2, __int64 a3, const char *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_8BFF3(__int64 *a1, __int64 *a2, const char *a3, __int64 a4);
__int64 __fastcall sub_8C09B(void **a1, __int64 a2, void *a3, __int64 a4, int a5);
signed __int64 __fastcall sub_8C12B(void **a1, __int64 a2, void *a3);
_QWORD *__fastcall sub_8C1C0(__int64 *a1, __int64 a2, int a3, char *a4);
_QWORD *__fastcall sub_8C5FD(__int64 *a1, __int64 a2, signed __int64 a3, void *a4, unsigned int a5, int a6);
__int64 __fastcall sub_8C74E(void **a1, __int64 a2, void *a3, int a4);
__int64 __fastcall sub_8C82F(void **a1, __int64 a2, void *a3, int a4);
_BOOL8 __fastcall sub_8C9A3(__int64 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_8CB00(__int64 *a1, char *a2, __int64 a3, const char *a4, __int64 a5);
signed __int64 __fastcall sub_8CED8(__int64 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_8CF89(void **a1, __int64 a2, void *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_8D071(void *a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_8D12E(__int64 a1, char *a2, __int64 a3, int *a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_8EB71(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_8EC20(void *a1, __int64 a2, void *a3, unsigned int a4);
_QWORD *__fastcall sub_8EF69(void *a1, __int64 a2, void *a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_8F0AF(void *a1, _QWORD *a2, __int64 a3, const char *a4, char a5);
_QWORD *__fastcall sub_8F1C2(void *a1, __int64 a2, void *a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_8F306(void *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_8F45D(void *a1, __int64 a2, __int64 *a3, _BYTE *a4);
signed __int64 __fastcall sub_8F644(void *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5);
signed __int64 __fastcall sub_8F84B(void *a1, __int64 a2, const char **a3, __int64 a4);
signed __int64 __fastcall sub_8F948(void *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5);
signed __int64 __fastcall sub_8FAB4(__int64 *a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_8FB32(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_8FC12(void *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_8FDB8(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_90078(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_901CF(void *a1, _DWORD *a2, __int64 a3, __int64 a4, const char *a5);
signed __int64 __fastcall sub_908E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_90DFE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_91116(_DWORD *a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_91380(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_918F3(void **a1, __int64 a2, __int64 a3, int a4, __int64 a5);
signed __int64 __fastcall sub_91D1B(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_91F57(__int64 *a1, __int64 a2, void ****a3, __int64 a4);
_BYTE *__fastcall sub_920E6(__int64 a1, unsigned int a2, unsigned int a3);
_BYTE *__fastcall sub_92593(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7);
signed __int64 __fastcall sub_92A28(__int64 a1, __int64 *a2);
__int64 __fastcall sub_92C65(__int64 a1, char a2);
__int64 __fastcall sub_92DC8(__int64 *a1, __int64 a2, __int64 a3, const char *a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_92FC8(__int64 *a1, __int64 a2, const char *a3, __int64 a4, __int64 *a5);
void *__fastcall sub_9316E(__int64 a1, const char *a2, unsigned int a3, char *a4, int a5);
void *__fastcall sub_93708(__int64 a1, const char *a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_93982(__int64 a1, int a2, int a3, int a4, _DWORD *a5, __int64 a6);
_BYTE *__fastcall sub_93A2E(void *a1, __int64 a2, _BYTE *a3, int a4, int a5, __int64 a6);
void *__fastcall sub_93CE2(__int64 a1, __int64 a2);
__int64 __fastcall sub_93E46(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned int a4);
__int64 __fastcall sub_93FD3(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4);
__int64 __fastcall sub_94115(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4);
__int64 __fastcall sub_94223(__int64 a1, unsigned int a2, unsigned int a3);
void __fastcall sub_942AF(__int64 a1, __int64 a2);
void __fastcall sub_942F8(__int64 a1, __int64 a2);
__int64 __fastcall sub_943D5(__int64 a1, __int64 a2);
__int64 __fastcall sub_944B0(__int64 a1, __int64 a2);
void __fastcall sub_945C9(__int64 a1, __int64 a2);
void __fastcall sub_946EA(__int64 a1, __int64 a2);
void __fastcall sub_94729(__int64 a1, __int64 a2);
void __fastcall sub_947B0(__int64 a1, __int64 a2);
void __fastcall sub_94851(__int64 a1, __int64 a2);
void __fastcall sub_948F2(__int64 a1, __int64 a2);
void __fastcall sub_94BFB(__int64 a1, unsigned __int8 *a2);
void __fastcall sub_94ECB(__int64 a1, __int64 a2);
__int64 __fastcall sub_94FA3(__int64 a1, __int64 a2, unsigned int a3);
void __fastcall sub_952AD(void **a1);
__int64 *__fastcall sub_9534B(__int64 *a1, unsigned __int8 *a2);
signed __int64 __fastcall sub_9554F(__int64 *a1, __int64 *a2, unsigned int a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_956B5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_959A9(__int64 *a1, __int64 a2, __int64 a3, int a4, __int64 a5);
signed __int64 __fastcall sub_95C0C(__int64 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_95D5C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_96496(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_96903(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_96B86(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall sub_96C40(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_96DDA(__int64 *a1, __int64 a2, char a3, __int64 a4);
signed __int64 __fastcall sub_97015(__int64 *a1, __int64 a2, char a3, __int64 a4);
signed __int64 __fastcall sub_97396(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_9763D(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5);
signed __int64 __fastcall sub_97818(void **a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_9797A(__int64 *a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_97ABE(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall sub_97C42(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall sub_97F83(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5);
signed __int64 __fastcall sub_980FB(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4, __int64 a5);
signed __int64 __fastcall sub_988E7(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_98D32(void **a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_9979D(_QWORD *a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_99DD9(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, void **a5, int a6, unsigned int a7);
__int64 __fastcall sub_9A401(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall sub_9A502(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, unsigned int a5);
signed __int64 __fastcall sub_9A76F(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int16 a5, unsigned __int16 a6);
signed __int64 __fastcall sub_9A888(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, char a5);
signed __int64 __fastcall sub_9AB89(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
signed __int64 __fastcall sub_9ACA3(void *a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall lys_is_key(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_is_disabled(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_iffeature_value(__int64 a1);
unsigned __int64 __fastcall lys_getnext_union_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_9B262(__int64 a1, const char *a2, int a3, char *a4, int a5, int a6, const char ***a7);
signed __int64 __fastcall sub_9B536(__int64 a1, __int64 a2, char *a3, int a4, int a5, unsigned int a6, const char ***a7);
__int64 __fastcall lys_getnext(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_9BBAC(__int64 a1);
__int64 __fastcall sub_9BDFE(const char *a1, __int64 a2);
__int64 __fastcall sub_9BF66(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_9C05E(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_9C637(__int64 a1, _QWORD *a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_9D438(__int64 a1, const char *a2, int a3, char *a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_parse_mem(__int64 a1, const char *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall sub_9D687(__int64 *a1, const char *a2, int a3, __int64 a4);
__int64 __fastcall lys_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_parse_fd(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_9DC74(__int64 a1, _QWORD *a2, unsigned int a3);
__int64 __fastcall sub_9DD36(__int64 a1, signed int a2, int a3, char *a4, unsigned int a5, __int64 a6);
_QWORD *__fastcall sub_9DEAC(__int64 *a1, signed int a2, int a3, __int64 a4);
signed __int64 __fastcall lys_search_localfile(__int64 a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_9EAFC(__int64 a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
signed __int64 __fastcall sub_9EB54(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, void *a5, int a6, __int64 *a7, int a8, __int64 a9);
_BYTE *__fastcall sub_9F26D(__int64 *a1, __int64 a2, int a3, unsigned int a4, __int64 a5);
__int64 __fastcall sub_9F606(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *));
void __fastcall lys_iffeature_free(__int64 a1, void ****a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_9F7C7(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, int a6, unsigned int a7, __int64 a8);
void *__fastcall sub_A03B6(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, int a5, unsigned int a6, __int64 a7);
signed __int64 __fastcall sub_A0555(__int64 *a1, __int64 *a2, void *a3, int *a4, __int64 a5);
signed __int64 __fastcall lys_ext_instance_substmt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_A1481(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, int a5, int a6, __int64 a7);
void __fastcall sub_A1648(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *));
void __fastcall sub_A1BCA(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *));
__int64 *__fastcall sub_A1CC4(__int64 *a1, __int64 a2, int a3, __int64 a4);
void __fastcall sub_A1E16(__int64 a1, _QWORD *a2, __int64 a3);
void __fastcall sub_A1EA9(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A1FDD(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *));
void __fastcall sub_A20D9(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A2146(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A21B3(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A227F(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A234B(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_A23DC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_A24CF(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_A260F(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A27EE(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A28F5(__int64 a1, _QWORD *a2, void (__fastcall *a3)(void **, void *));
void __fastcall sub_A29AE(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *));
void __fastcall sub_A2A43(__int64 *a1, __int64 a2, void (__fastcall *a3)(void **, void *));
void __fastcall sub_A2FCB(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_A33A0(_QWORD **a1, void (__fastcall *a2)(_QWORD **, _QWORD *), unsigned int a3);
__int64 *__fastcall lys_implemented_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_A38CB(__int64 a1, void (__fastcall *a2)(void **, void *));
void __fastcall sub_A3E76(__int64 *a1, void (__fastcall *a2)(void **, void *));
_BOOL8 __fastcall sub_A3FB0(__int64 a1);
__int64 __fastcall sub_A4070(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6);
signed __int64 __fastcall sub_A5E40(__int64 a1);
_BOOL8 __fastcall sub_A6074(__int64 a1);
__int64 __fastcall sub_A60D4(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
unsigned __int64 __fastcall sub_A6294(__int64 a1, __int64 a2);
void __fastcall sub_A67C8(unsigned __int8 *a1, void (__fastcall *a2)(void **, void *), int a3, int a4);
__int64 __fastcall sub_A6A3A(__int64 a1);
_BOOL8 __fastcall sub_A6AC5(__int64 a1, const char *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall lys_features_enable(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall lys_features_disable(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lys_features_state(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall lys_features_list(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_node_module(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_main_module(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_parent(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_A75EB(__int64 a1, unsigned int a2);
__int64 __fastcall lys_set_private(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_A7706(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_xpath_atomize(__int64 a1, int a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_node_xpath_atomize(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_A7ED6(__int64 a1, __int64 a2);
__int64 __fastcall sub_A835C(__int64 a1);
unsigned __int64 __fastcall sub_A84A7(__int64 a1, __int64 *a2, __int64 a3);
unsigned __int64 __fastcall sub_A8A9A(__int64 a1);
unsigned __int64 __fastcall sub_A8D1D(__int64 a1);
__int64 __fastcall sub_A8FAF(__int64 a1, __int64 *a2, __int64 a3);
unsigned __int64 __fastcall sub_A903F(__int64 a1, __int64 *a2, __int64 a3);
unsigned __int64 __fastcall sub_A91FC(__int64 a1);
unsigned __int64 __fastcall sub_A9496(__int64 a1);
signed __int64 __fastcall sub_A9962(__int64 a1, __int64 a2);
signed __int64 __fastcall lys_set_implemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_AA3F6(__int64 a1);
__int64 __fastcall lys_path(char *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
char *__fastcall lys_data_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_AA881(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall lys_find_path(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_AAC84(__int64 a1, __int64 a2, unsigned int a3);
void __fastcall sub_AAE3B(__int64 a1, void ***a2, unsigned int a3, void (__fastcall *a4)(void **, void *));
signed __int64 __fastcall sub_ABBCE(_QWORD *a1, _QWORD *a2);
_BOOL8 __fastcall sub_ABD8D(_QWORD *a1);
signed __int64 __fastcall sub_ABE70(_BYTE **a1, _BYTE **a2, int a3);
signed __int64 __fastcall sub_ABF28(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_AC44F(__int64 *a1, _QWORD **a2, int a3, __int64 a4);
void __fastcall sub_AC551(_QWORD *a1, unsigned int *a2);
signed __int64 __fastcall sub_AC63C(const char **a1);
_QWORD *__fastcall sub_AC884(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_AC9EF(unsigned int *a1, unsigned int **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_ACC62(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_ACC82(_QWORD *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_ACE40(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_ACE6B(_QWORD *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_ACF5E(_QWORD *a1, _QWORD *a2, __int64 a3, int a4);
signed __int64 __fastcall sub_AD12C(_QWORD *a1, __int64 **a2, __int64 a3, __int64 a4, int a5, __int64 a6);
__int64 __fastcall sub_AD45A(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned int a5, unsigned int a6);
signed __int64 __fastcall sub_AD9B9(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_ADEE6(__int64 a1, __int64 *a2, __int64 a3, int a4, unsigned int a5, __int64 a6, char *a7);
__int64 __fastcall sub_AE151(__int64 a1, __int64 a2, int a3, unsigned int a4, unsigned int *a5);
__int64 lyd_parse_mem(__int64 a1, __int64 a2, int a3, __int64 a4, ...);
__int64 __fastcall sub_AE545(__int64 a1, int a2, int a3, unsigned int a4, unsigned int *a5, __int64 a6);
__int64 lyd_parse_fd(__int64 a1, int a2, int a3, __int64 a4, ...);
__int64 lyd_parse_path(__int64 a1, const char *a2, int a3, __int64 a4, ...);
__int64 __fastcall sub_AE92C(__int64 a1, __int64 a2, int a3);
_BYTE *__fastcall sub_AE9DE(__int64 a1, __int64 a2, char a3);
_BYTE *__fastcall lyd_new(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE *__fastcall sub_AECBE(__int64 a1, void *a2, char a3);
char **__fastcall sub_AEDF4(__int64 a1, __int64 a2, void *a3, unsigned int a4, unsigned int a5);
char **__fastcall lyd_new_leaf(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_AF16B(__int64 a1);
unsigned __int64 __fastcall sub_AF24B(_QWORD *a1);
signed __int64 __fastcall lyd_change_leaf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall sub_AF724(__int64 a1, __int64 a2, void *a3, unsigned int a4);
void *__fastcall lyd_new_anydata(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE *__fastcall lyd_new_yangdata(__int64 *a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE *__fastcall lyd_new_output(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
char **__fastcall lyd_new_output_leaf(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall lyd_new_output_anydata(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
char *__fastcall sub_B02CA(__int64 a1, const char *a2, int a3);
signed __int64 __fastcall sub_B045A(__int64 *a1, __int64 a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_B08C4(__int64 a1, _BYTE *a2, unsigned int a3, int a4, __int64 a5, __int64 a6);
__int64 *__fastcall lyd_new_path(__int64 *a1, void *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyd_list_pos(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE *__fastcall sub_B20A7(_QWORD *a1, _QWORD *a2, __int64 a3, void *a4, unsigned int a5);
__int64 __fastcall sub_B2578(__int64 a1, __int64 a2);
__int64 __fastcall sub_B28DB(__int64 *a1, __int64 a2);
unsigned __int64 __fastcall sub_B2929(unsigned __int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_B308E(__int64 *a1, __int64 a2);
signed __int64 __fastcall sub_B317C(_BYTE *a1, __int64 a2);
signed __int64 __fastcall sub_B3375(__int64 a1, __int64 a2, __int16 a3);
signed __int64 __fastcall sub_B384E(__int64 *a1, _QWORD *a2, __int16 a3);
signed __int64 __fastcall lyd_merge_to_ctx(__int64 **a1, _QWORD *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyd_merge(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall lyd_free_diff(void **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_B4516(void **a1, _DWORD *a2, unsigned int a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_B47F2(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_B491E(__int64 a1);
signed __int64 __fastcall sub_B49D8(_BYTE *a1, __int64 a2, char a3);
signed __int64 __fastcall sub_B4A6E(__int64 a1, __int64 a2, void **a3, _DWORD *a4, _DWORD *a5, __int64 a6, __int64 a7, char a8);
_BOOL8 __fastcall sub_B4CF2(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_B4DF4(__int64 a1, _QWORD *a2, __int64 a3);
void **__fastcall sub_B5143(__int64 a1, _DWORD *a2);
void **__fastcall lyd_diff(_QWORD *a1, _QWORD *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_B6CAE(__int64 a1);
__int64 __fastcall sub_B6F47(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall sub_B70F6(_QWORD *a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_insert(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_insert_sibling(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_B7B96(__int64 *a1, __int64 *a2, int a3, int a4);
signed __int64 __fastcall lyd_insert_before(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_insert_after(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_B857F(__int64 *a1);
signed __int64 __fastcall sub_B8611(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall compar(const void *a1, const void *a2);
signed __int64 __fastcall lyd_schema_sort(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_B8BF3(char **a1, __int64 a2, void *a3, __int64 a4, unsigned int a5, _QWORD *a6, __int64 a7);
signed __int64 __fastcall lyd_validate(char **a1, unsigned int a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_validate_modules(char **a1, void ***a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_validate_value(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_B9E6F(__int64 a1, unsigned __int64 a2, __int64 a3);
signed __int64 __fastcall sub_BA11B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_unlink(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_BA2CA(unsigned __int64 a1, __int64 a2, __int64 a3, char a4);
_QWORD *__fastcall sub_BA418(__int64 a1, __int64 a2, __int64 a3, char a4);
signed __int64 __fastcall sub_BAAC6(char *a1, __int64 a2, __int64 a3, void *a4, char a5, __int64 a6);
__int64 *__fastcall lyd_dup_to_ctx(__int64 *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyd_dup(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_BB2B8(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
_QWORD *__fastcall sub_BB4DB(_QWORD *a1, unsigned int a2, __int64 a3);
_QWORD *__fastcall lyd_dup_withsiblings(_QWORD *a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall lyd_free_attr(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_BB881(_QWORD *a1, __int64 a2);
void *__fastcall lyd_insert_attr(unsigned __int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall sub_BBE52(void *a1, int a2, char a3, signed __int64 a4, __int64 a5, _QWORD *a6, _DWORD *a7, _BYTE *a8);
void __fastcall sub_BBF19(__int64 a1);
void __fastcall sub_BC13E(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall lyd_free(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_BC223(_QWORD *a1);
signed __int64 __fastcall lyd_free_withsiblings(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_BC387(const char *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall lyd_path(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_BC8A8(__int64 *a1, __int64 *a2, const char *a3, __int64 a4);
__int64 __fastcall lyd_find_path(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyd_find_instance(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyd_first_sibling(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall ly_set_new(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall ly_set_free(void **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_set_contains(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall ly_set_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_set_add(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_set_merge(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_set_rm_index(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_set_rm(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall ly_set_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_wd_default(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_BDCC8(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_BDDC2(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall lyd_free_val_diff(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_BE08A(_QWORD **a1, _QWORD *a2, __int64 a3, __int64 a4, int a5);
signed __int64 __fastcall sub_BE34C(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_BE6C9(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_BE818(__int64 *a1, __int64 *a2, _BYTE *a3, __int64 a4, int a5, int a6, __int64 a7);
signed __int64 __fastcall sub_BF27C(__int64 *a1, __int64 a2, __int64 a3, signed int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_BF7F8(char ***a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char **a7, __int64 a8, int a9);
__int64 __fastcall lyd_node_module(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
double __fastcall lyd_dec64_to_double(const char **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall lyd_leaf_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall ly_get_loaded_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ly_clean_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_C03C5(void *a1, const char *a2);
signed __int64 __fastcall ly_register_types(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_C0875(void *a1, const char *a2);
signed __int64 __fastcall ly_register_exts(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_C0ED7(void *a1);
unsigned __int64 __fastcall sub_C0FA9(DIR *a1, __int64 a2, int a3);
int __fastcall ly_load_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_C1405(const char *a1, const char *a2, char *a3);
signed __int64 __fastcall lys_ext_instance_presence(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lys_ext_complex_get_substmt(int a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_C1906(unsigned int a1);
char *__fastcall sub_C1A2B(_BYTE *a1, _BYTE *a2, _BYTE *a3);
signed __int64 __fastcall sub_C1B58(__int64 *a1, _BYTE *a2, _QWORD *a3, __int64 a4);
unsigned __int64 __fastcall sub_C1CED(signed __int64 a1, __int64 a2, __int64 a3);
_BOOL8 __fastcall sub_C1FAD(_QWORD *a1, _QWORD *a2);
signed __int64 sub_C1FF7(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...);
int __fastcall sub_C236C(__int64 a1);
__int64 __fastcall sub_C23A5(__int64 a1, const void *a2, size_t a3);
signed __int64 __fastcall sub_C2676(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_C2888(__int64 a1, __int64 a2, const void *a3, size_t a4);
__int64 __fastcall sub_C29AA(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, int *a5, signed int *a6);
__int64 __fastcall sub_C2DA0(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4);
__int64 __fastcall sub_C2E22(_QWORD *a1, __int64 *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
__int64 __fastcall lys_print_file(__int64 a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6);
signed __int64 __fastcall lys_print_path(const char *a1, __int64 *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6);
__int64 __fastcall lys_print_fd(int a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6);
signed __int64 __fastcall lys_print_mem(_QWORD *a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6);
__int64 __fastcall lys_print_clb(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, const char *a5, __int64 a6, unsigned int a7);
signed __int64 __fastcall sub_C3393(__int64 a1, __int64 a2, const char *a3, void (__fastcall *a4)(__int64, signed __int64, int *), void (__fastcall *a5)(__int64, signed __int64, int *), void (__fastcall *a6)(__int64, signed __int64, int *), void (__fastcall *a7)(__int64, __int64, int *), void (__fastcall *a8)(__int64, __int64, int *), void (__fastcall *a9)(__int64, __int64, int *), void (__fastcall *a10)(__int64, __int64, int *), void (__fastcall *a11)(__int64, __int64, int *), void (__fastcall *a12)(__int64, __int64, int *), void (__fastcall *a13)(__int64, __int64, int *), void (__fastcall *a14)(__int64, __int64, int *), void (__fastcall *a15)(__int64, __int64, int *), void (__fastcall *a16)(__int64, __int64, int *), void (__fastcall *a17)(__int64, __int64, int *), void (__fastcall *a18)(__int64, __int64, int *), void (__fastcall *a19)(__int64, __int64, int *), void (__fastcall *a20)(__int64, __int64, int *));
signed __int64 __fastcall sub_C3DD9(_DWORD *a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_print_file(__int64 a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_print_path(const char *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_print_fd(int a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_print_mem(_QWORD *a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64 __fastcall lyd_print_clb(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, unsigned int a5, __int64 a6);
signed __int64 __fastcall sub_C424C(__int64 a1, char a2);
signed __int64 __fastcall sub_C46A7(_QWORD *a1, char a2);
void __fastcall sub_C488D(__int64 a1);
const char *__fastcall sub_C494A(_DWORD *a1);
const char *__fastcall sub_C49BD(unsigned int a1);
unsigned __int64 __fastcall sub_C4AE9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_C4D98(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_C54F2(__int64 a1, unsigned __int16 a2, void **a3, unsigned __int16 *a4, _WORD *a5, __int64 a6);
signed __int64 __fastcall sub_C5614(__int64 a1, __int64 *a2, int a3, int a4, __int64 a5, void **a6, unsigned __int16 *a7, _WORD *a8);
void *__fastcall sub_C5D5B(__int64 a1, __int64 *a2, int a3, int a4);
char *__fastcall sub_C5EB1(__int64 a1, __int64 a2, void **a3, int a4, __int64 a5, __int64 a6);
long double __fastcall sub_C607E(const char *a1);
_BOOL8 __fastcall sub_C6102(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_C6158(__int64 a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_C639B(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_C64AC(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_C65F5(__int64 a1);
void __fastcall sub_C6688(void *a1);
void **__fastcall sub_C66B8(const char **a1);
__int64 __fastcall sub_C6974(__int64 a1, char *a2, unsigned __int16 a3);
__int64 __fastcall sub_C69DE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int128 a7);
_DWORD *__fastcall sub_C6A0D(_DWORD *a1, int a2);
void __fastcall sub_C6A3F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_C6D49(__int64 a1);
void *__fastcall sub_C6DA0(_DWORD *a1, unsigned int a2);
void *__fastcall sub_C6ECE(unsigned int *a1);
signed __int64 __fastcall sub_C705F(__int64 a1, __int64 a2, int a3, int a4);
signed __int64 __fastcall sub_C7105(__int64 a1, __int64 a2, int a3, int a4);
unsigned __int64 __fastcall sub_C7180(unsigned int *a1, unsigned int *a2);
unsigned __int64 __fastcall sub_C7395(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5);
signed __int64 __fastcall sub_C765D(__int64 a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_C77EE(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5);
__int64 __fastcall sub_C78F8(__int64 a1);
__int64 __fastcall sub_C79D5(_QWORD *a1, int a2, _QWORD *a3, int a4, _QWORD **a5, unsigned int *a6);
signed __int64 __fastcall sub_C7C5E(__int64 a1, _QWORD *a2, int a3);
__int64 __fastcall sub_C7E06(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_C7E78(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_C81AC(void *a1, __int64 a2, int a3, __int64 a4, __int64 *a5, unsigned int a6, int a7);
signed __int64 __fastcall sub_C8295(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_C863F(__int64 a1);
signed __int64 __fastcall sub_C870E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_C8BDA(int *a1, __int64 a2);
signed __int64 __fastcall sub_C8ED8(__int64 a1, int a2, __int16 a3, __int16 a4);
signed __int64 __fastcall sub_C9129(void *a1, __int64 a2, unsigned __int16 a3, int a4, __int64 a5, __int64 a6);
_DWORD *__fastcall sub_C9229(__int64 a1, unsigned __int16 a2, __int16 a3);
signed __int64 __fastcall sub_C940B(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_C94CA(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_C989E(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_C99D7(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CA839(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CAB46(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CAC93(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CAE73(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CB062(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_CB1CB(void *a1, char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_CB4D2(void *a1, const char *a2);
__int64 __fastcall sub_CC407(__int64 a1);
__int64 __fastcall sub_CC474(signed __int64 a1);
__int64 __fastcall sub_CC619(signed __int64 a1);
__int64 __fastcall sub_CC70D(signed __int64 a1, unsigned int a2);
unsigned __int64 __fastcall sub_CC805(signed __int64 a1, __int64 a2);
signed __int64 __fastcall sub_CC8D8(signed __int64 a1, signed __int64 a2);
unsigned __int64 __fastcall sub_CC97E(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, unsigned __int16 a6);
unsigned __int64 __fastcall sub_CCC96(__int64 a1, _QWORD *a2, __int64 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int16 a6);
signed __int64 __fastcall sub_CD097(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6);
__int64 __fastcall sub_CD490(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64 __fastcall sub_CD50E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CD74E(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_CDA61(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6);
signed __int64 __fastcall sub_CDD3F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_CDEAF(__int64 a1, unsigned __int16 a2, __int64 a3, void **a4, __int64 a5, char a6);
signed __int64 __fastcall sub_CDF8D(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall sub_CE2E0(__int64 a1, const char *a2);
signed __int64 __fastcall sub_CE3C6(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_CE87B(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_CED6F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_CEFE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, char a6);
signed __int64 __fastcall sub_CF037(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_CF0E9(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_CF4F3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_CF5DD(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6);
signed __int64 __fastcall sub_CF8C9(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6);
signed __int64 __fastcall sub_CF913(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6);
__int64 __fastcall sub_CFC0C(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, char a6);
signed __int64 __fastcall sub_CFC7C(__int64 *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_D010E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64 __fastcall sub_D01A8(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64 __fastcall sub_D0264(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_D034E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6);
signed __int64 __fastcall sub_D06AD(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_D0925(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6);
signed __int64 __fastcall sub_D0C1C(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64 __fastcall sub_D0CD8(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64 __fastcall sub_D0FED(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_D1588(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_D18C4(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64 __fastcall sub_D1BD3(_DWORD **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_D1FBB(__int64 a1, __int64 a2, __int64 a3, void **a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_D21EC(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
__int64 __fastcall sub_D27D8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, char a6);
__int64 __fastcall sub_D282F(const char *a1, unsigned __int16 a2, __int64 a3, __int64 a4, int a5, int a6);
__int64 __fastcall sub_D2AFF(__int64 a1, int a2, _DWORD *a3);
__int64 __fastcall sub_D2BEA(__int64 a1, char a2, _DWORD *a3);
unsigned __int64 __fastcall sub_D2C95(__int64 a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_D2D37(__int64 a1, __int64 a2, char a3);
signed __int64 __fastcall sub_D2DEA(_BYTE *a1, int a2, char *a3, __int64 a4, char a5);
signed __int64 __fastcall sub_D2EBE(__int64 a1, int a2, char *a3, __int64 a4, char a5);
signed __int64 __fastcall sub_D2FD6(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64 __fastcall sub_D345B(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64 __fastcall sub_D3A01(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64 __fastcall sub_D3F81(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64 __fastcall sub_D4437(__int64 a1, __int64 a2, char *a3, unsigned __int16 a4, int a5);
signed __int64 __fastcall sub_D476C(_DWORD *a1, _DWORD *a2, _QWORD **a3, int a4);
signed __int64 __fastcall sub_D4935(__int64 a1, _QWORD **a2, char *a3, unsigned __int16 a4, int a5);
signed __int64 __fastcall sub_D4CD2(__int64 a1, int a2, unsigned int a3, __int64 a4, __int64 a5, int a6, char a7);
signed __int64 __fastcall sub_D4FB0(_QWORD *a1, __int64 a2, int a3, char a4);
signed __int64 __fastcall sub_D5245(__int64 a1, __int64 a2, int a3, char a4);
signed __int64 __fastcall sub_D5430(__int64 a1, __int64 a2, int a3, int a4);
signed __int64 __fastcall sub_D5851(__int64 a1, __int64 a2, int a3, char a4);
signed __int64 __fastcall sub_D5BFA(long double *a1, long double *a2, _BYTE *a3, __int64 a4, __int64 *a5, int a6);
signed __int64 __fastcall sub_D65EB(__int64 a1, long double *a2, _BYTE *a3, __int64 a4, __int64 *a5, int a6);
_WORD *__fastcall sub_D6835(_QWORD *a1, _WORD *a2, __int64 a3);
signed __int64 __fastcall sub_D6985(_QWORD *a1, _WORD *a2, _QWORD **a3, __int64 *a4, int a5, int a6, __int64 a7, unsigned int a8);
__int64 __fastcall sub_D729A(_QWORD *a1, __int16 *a2, __int64 a3, __int64 *a4, __int64 a5, int a6, int a7);
signed __int64 __fastcall sub_D7B49(__int64 a1, __int16 *a2, _QWORD **a3, __int64 *a4, int a5, _QWORD *a6, unsigned int a7);
__int64 __fastcall sub_D8060(_QWORD *a1, __int16 *a2, __int64 a3, void **a4, __int64 a5, int a6);
signed __int64 __fastcall sub_D8307(__int64 a1, unsigned __int16 *a2, __int64 a3, __int64 *a4, const char **a5, unsigned int a6);
signed __int64 __fastcall sub_D9687(void *a1, _QWORD *a2, _WORD *a3, __int64 a4);
signed __int64 __fastcall sub_D99FD(__int64 a1, __int16 *a2, _QWORD **a3, __int64 *a4, _QWORD *a5, unsigned int a6);
__int64 __fastcall sub_DA06F(_QWORD *a1, _WORD *a2, unsigned __int16 a3, _QWORD **a4, __int64 *a5, unsigned int *a6, int a7);
signed __int64 __fastcall sub_DA41B(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, void **a5, __int64 a6, int a7);
__int64 __fastcall sub_DA6A9(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64 __fastcall sub_DAB0C(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64 __fastcall sub_DAF68(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64 __fastcall sub_DB3CB(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64 __fastcall sub_DB8DA(_QWORD *a1, _WORD *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64 __fastcall sub_DBD1D(_QWORD *a1, _WORD *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64 __fastcall sub_DC160(_QWORD *a1, __int16 *a2, unsigned int a3, _QWORD **a4, __int64 *a5, unsigned int *a6, unsigned int a7);
signed __int64 __fastcall sub_DC4B2(const char *a1, char *a2, int a3, void **a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_DC765(__int64 a1, int a2, __int64 a3, __int64 *a4, int a5);
__int64 __fastcall sub_DCFF7(const char *a1, __int64 a2, int a3, _DWORD *a4, unsigned int a5, _QWORD *a6);
__int64 __fastcall sub_DD261(__int64 a1, void **a2, int a3);
signed __int64 __fastcall sub_DDEA9(__int64 a1);
void __fastcall sub_DE34B(__int64 a1, const char *a2, int a3);
signed __int64 __fastcall sub_DE4D3(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_DE519(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_DE573(__int64 a1, int a2, __int64 a3, const char *a4, int a5, __int64 a6);
signed __int64 __fastcall sub_DE71C(__int64 a1, int a2, int a3, unsigned int a4, const char *a5, __int64 a6, __int64 a7, unsigned __int8 a8);
signed __int64 __fastcall sub_DE97F(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_DEA7A(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
unsigned __int64 __fastcall sub_DF01A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_DF0C8(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_DF35D(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_DF66E(__int64 a1, unsigned int a2, __int64 *a3, const char **a4);
unsigned __int64 __fastcall sub_DF89A(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64 __fastcall sub_DF961(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64 __fastcall sub_DFA28(__int64 a1, int a2, __int64 *a3, __int64 a4);
signed __int64 __fastcall sub_E0678(__int64 a1, unsigned int a2, __int64 *a3, const char **a4);
signed __int64 __fastcall sub_E0707(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E0803(__int64 a1, unsigned int a2, __int64 *a3, const char **a4);
signed __int64 __fastcall sub_E0D20(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64 __fastcall sub_E1A74(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall sub_E1BDF(__int64 a1, int a2, __int64 *a3, __int64 *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E1E7A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E2106(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E252D(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E26DF(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_E2926(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E2CCF(__int64 a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall sub_E2F1F(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E34E4(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E3CC6(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E3F0E(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_E417B(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E4386(__int64 a1, unsigned int a2, __int64 a3);
unsigned __int64 __fastcall sub_E453A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_E479A(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_E4A49(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_E4BDA(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_E5C7A(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_E5CA1(__int64 a1, int a2, __int64 *a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, _DWORD *a8);
unsigned __int64 __fastcall sub_E5DFA(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, _DWORD *a6);
_WORD *__fastcall sub_E5F4E(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, unsigned __int16 a8, unsigned __int16 a9, _DWORD *a10);
unsigned __int64 __fastcall sub_E6059(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5, __int64 a6, unsigned int a7);
signed __int64 __fastcall sub_E8DAF(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7);
signed __int64 __fastcall sub_E8EE6(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_E8F8C(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_E8FD2(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_E904C(__int64 a1, int a2, int a3, char a4, __int64 a5, __int64 a6, __int64 a7, unsigned __int8 a8);
signed __int64 __fastcall sub_E933F(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_E943A(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
unsigned __int64 __fastcall sub_E99DA(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_E9C9B(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
unsigned __int64 __fastcall sub_E9F06(__int64 a1, int a2, __int64 a3, _BYTE **a4, __int64 a5);
unsigned __int64 __fastcall sub_EA002(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_EA0C6(__int64 a1, int a2, __int64 *a3, const char **a4);
unsigned __int64 __fastcall sub_EA2FF(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64 __fastcall sub_EA3C7(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64 __fastcall sub_EA48F(__int64 a1, int a2, __int64 *a3, __int64 a4);
unsigned __int64 __fastcall sub_EB0CE(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64 __fastcall sub_EB1FC(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_EB2F8(__int64 a1, int a2, __int64 *a3, const char **a4);
unsigned __int64 __fastcall sub_EB84B(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64 __fastcall sub_EC5A5(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64 __fastcall sub_EC70B(__int64 a1, int a2, __int64 *a3, __int64 *a4);
unsigned __int64 __fastcall sub_EC9A9(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_ECC45(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_ED082(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_ED24A(__int64 a1, int a2, __int64 *a3);
signed __int64 __fastcall sub_ED4A7(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_ED853(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall sub_EDABE(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_EE086(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_EE862(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_EEAC0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_EED3F(__int64 a1, int a2, __int64 a3);
unsigned __int64 __fastcall sub_EEF63(__int64 a1, int a2, __int64 a3);
unsigned __int64 __fastcall sub_EF13E(__int64 a1, int a2, __int64 *a3);
unsigned __int64 __fastcall sub_EF3B4(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_EF5BC(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_EF756(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_EF8CE(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_F08B1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F08F7(__int64 a1, int a2, __int64 *a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, _DWORD *a8);
unsigned __int64 __fastcall sub_F0A50(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, _DWORD *a6);
_WORD *__fastcall sub_F0BA4(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, unsigned __int16 a8, unsigned __int16 a9, _DWORD *a10);
unsigned __int64 __fastcall sub_F0CAF(__int64 a1, int a2, __int64 a3, int a4, char a5, __int64 a6, unsigned int a7);
const char *__fastcall sub_F391A(unsigned int a1);
void __fastcall sub_F3A17(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, _DWORD *a6);
void __fastcall sub_F3AD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, _DWORD *a6);
void __fastcall sub_F3B77(__int64 a1, char a2, _DWORD *a3);
void __fastcall sub_F3C04(__int64 a1, char a2, _DWORD *a3);
void __fastcall sub_F3C8C(__int64 a1, char a2, _DWORD *a3);
void __fastcall sub_F3D18(__int64 a1, __int16 a2, _DWORD *a3);
signed __int64 __fastcall sub_F3D9C(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _DWORD *a5, __int64 a6);
signed __int64 __fastcall sub_F3EB4(__int64 a1, __int64 *a2, _DWORD *a3);
void __fastcall sub_F3F83(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F41B3(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F42A6(__int64 a1, __int64 a2, int a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F4F54(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F4F86(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F5130(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F521A(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F526E(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F52C2(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F5438(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F5523(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F56F9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, const char **a5, __int64 a6);
unsigned __int64 __fastcall sub_F5B0E(__int64 a1, __int64 a2, _DWORD *a3);
unsigned __int64 __fastcall sub_F5C40(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F5E70(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F61D6(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F6930(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F6BB4(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F6CAB(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F6EDF(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_F6FC9(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4);
unsigned __int64 __fastcall sub_F7166(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_F7228(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F7353(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F74CB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F7505(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F753F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_F7579(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F75B3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F78E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F7B7C(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F7E29(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F804F(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F82CE(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F8599(__int64 a1, __int64 a2, _DWORD *a3);
int __fastcall sub_F8941(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F8B8C(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F8D51(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F8F2B(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F9025(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F911F(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F9323(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_F957C(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_F97D5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F9917(_QWORD *a1, __int64 *a2);
_QWORD *__fastcall sub_F99DA(_QWORD **a1);
__int64 *__fastcall sub_F9A1C(__int64 a1, __int64 a2, __int64 **a3, char a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_F9E66(__int64 a1, _BYTE *a2, char a3);
signed __int64 __fastcall sub_FA42C(__int64 a1, int a2, __int64 a3, int a4, char a5);
signed __int64 __fastcall sub_FAB93(__int64 a1, int a2, __int64 a3, int a4, unsigned int a5);
signed __int64 __fastcall sub_FAE83(__int64 a1, int a2, __int64 a3, int a4, unsigned int a5, unsigned int a6);
signed __int64 __fastcall sub_FB19F(__int64 a1, int a2, __int64 a3, int a4, int a5);
__int64 __fastcall sub_FB69D(__int64 a1, int a2, _QWORD *a3, unsigned int a4, unsigned int a5);
signed __int64 __fastcall sub_FB855(_DWORD *a1, _QWORD *a2, signed int a3);
__int64 __fastcall sub_FBBCD(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_FBC92(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_FBFBE(signed int a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_FC11E(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall sub_FC2E9(__int64 a1);
__int64 __fastcall sub_FC398(__int64 a1, unsigned int a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_FC46B(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_FC508(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FCA87(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_FCC11(_QWORD *a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6, _QWORD *a7);
__int64 __fastcall sub_FCE3A(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_FCFB0(_QWORD *a1, unsigned int a2, unsigned __int16 a3, __int64 a4, int a5, __int64 a6, int a7, __int64 a8);
unsigned __int64 __fastcall sub_FDC13(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_FDDA8(__int64 a1, unsigned int a2, unsigned __int8 a3, char *a4, __int64 a5);
signed __int64 __fastcall sub_FDED1(_QWORD *a1, __int64 *a2, __int64 a3, unsigned int a4, unsigned int a5);
signed __int64 __fastcall sub_FE7ED(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FE96A(__int64 a1, __int64 a2, __int64 a3, const char *a4);
signed __int64 __fastcall sub_FEBD1(__int64 a1, __int16 a2, __int16 a3, int a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FEE4A(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FEF59(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FEFD0(__int64 a1, __int64 *a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FF0A9(__int64 a1, __int64 *a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FF177(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FF3FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FFF2C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FFF5A(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_FFFD4(__int64 a1, __int64 **a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1000F2(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1001C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_10051E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_100621(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_100729(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_10082B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_100AC4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_100D53(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_100FC5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1010F2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_101336(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_101432(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1016EE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1019AE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_101B50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_101CF8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_101E9B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_10203F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_102228(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_102381(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_10249F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_1025D9(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1026D7(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1027D5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_10293C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_102A81(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_102BC6(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_102CD8(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_102E00(__int64 a1, int a2, _QWORD *a3, __int64 a4);
signed __int64 __fastcall sub_1031F1(__int64 a1, const char *a2, _QWORD **a3, int a4, unsigned int a5, unsigned int a6);
signed __int64 __fastcall sub_1037A1(__int64 a1, unsigned int a2, __int64 **a3, int a4, unsigned int a5);
signed __int64 __fastcall sub_103AA8(__int64 a1, unsigned int a2, __int64 **a3, int a4, unsigned int a5, unsigned int a6);
signed __int64 __fastcall sub_104282(__int64 a1, unsigned int a2, __int64 a3, int a4, int a5);
signed __int64 __fastcall sub_104827(__int64 a1, unsigned int a2, __int64 *a3, int a4, unsigned int a5, unsigned int a6);
signed __int64 __fastcall sub_104C16(__int64 a1, __int64 *a2, unsigned int a3);
__int64 __fastcall sub_104F44(__int64 a1);
signed __int64 sub_104F52();
_BOOL8 __fastcall sub_104F6C(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall sub_104FAD(__int64 a1, const char **a2, unsigned __int8 a3, int a4);
signed __int64 __fastcall sub_1050EE(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_1053BB(__int64 a1, __int64 a2);
void **__fastcall sub_105659(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_1059E6(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_105AD0(__int64 a1, char *a2, size_t a3, __int64 a4);
signed __int64 __fastcall sub_105E36(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_105F04(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_10611E(__int64 a1, size_t a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_106160(unsigned int a1, unsigned int a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_1061F7(char *a1, size_t a2, int a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_1062DC(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_1063FB(__int64 a1, unsigned __int64 a2, __int64 a3);
signed __int64 __fastcall sub_10644E(__int64 *a1, unsigned __int64 *a2, __int64 a3);
__int64 __fastcall sub_1064E5(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1068FD(__int64 a1);
__int64 __fastcall sub_106963(__int64 a1);
signed __int64 __fastcall sub_1069BD(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_106BBB(signed __int64 a1, char *a2, __int64 a3, signed int a4, char a5, char a6, __int64 a7, __int64 a8);
signed __int64 __fastcall sub_107027(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_107293(__int64 a1, const char **a2, __int64 *a3, __int64 a4);
signed __int64 __fastcall sub_1075FD(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int a5);
signed __int64 __fastcall sub_1078FB(__int64 a1, _QWORD *a2, char a3);
int __fastcall sub_107BF0(char *filename, struct stat *stat_buf);
int __fastcall sub_107C00(int fildes, struct stat *stat_buf);
void term_proc();
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

size_t size = 282584257676671uLL; // idb
char byte_8 = '\0'; // weak
__int64 (__fastcall *off_18)() = &start; // weak
__int64 qword_28 = 1339728LL; // weak
_UNKNOWN loc_17E00; // weak
_UNKNOWN loc_EFFFF; // weak
_UNKNOWN loc_100000; // weak
void *off_107C20 = (void *)0x7325LL; // weak
_UNKNOWN unk_107E6B; // weak
_UNKNOWN unk_107EEB; // weak
unsigned __int8 byte_107F80[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  1u,
  1u
}; // idb
void *__ptr32 off_1083D1 = (void *__ptr32 )0x7325LL; // weak
_UNKNOWN unk_1086CA; // weak
void *__ptr32 off_108D8F = &loc_A0020; // weak
_DWORD dword_109EA0[88] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  5,
  6,
  7,
  8,
  9,
  10,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  17,
  18,
  19,
  20,
  21,
  20,
  21,
  22,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  37,
  38,
  39,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77
}; // idb
_UNKNOWN unk_10A000; // weak
_UNKNOWN unk_10A3C1; // weak
char off_10A3EA[] = { '%', 'u', '\0', '\0' }; // idb
_UNKNOWN unk_10AA7C; // weak
char accept[] = { ' ', '\t', '\n', '\0' }; // idb
void *off_10CCE0 = (void *)0x7325LL; // weak
char byte_10CE4D = '\0'; // idb
_UNKNOWN unk_10DE4F; // weak
_UNKNOWN unk_10F10F; // weak
char off_10F526[] = { ' ', '\t', '\n', '\0' }; // idb
_UNKNOWN unk_110680; // weak
char byte_110942[2] = { '\0', '\0' }; // idb
_UNKNOWN unk_111298; // weak
void *__ptr32 off_11171E = (void *__ptr32 )0x7325LL; // weak
_WORD word_1197E0[672] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  133,
  131,
  130,
  128,
  131,
  127,
  92,
  100,
  91,
  127,
  127,
  103,
  105,
  90,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  88,
  89,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  2,
  3,
  2,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  6,
  116,
  114,
  131,
  119,
  110,
  111,
  112,
  131,
  106,
  117,
  109,
  122,
  107,
  108,
  122,
  118,
  93,
  96,
  94,
  99,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  101,
  102,
  131,
  130,
  129,
  127,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  104,
  1,
  5,
  127,
  105,
  125,
  127,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  116,
  115,
  113,
  121,
  120,
  122,
  0,
  122,
  95,
  93,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  94,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  101,
  104,
  127,
  105,
  126,
  125,
  72,
  125,
  125,
  125,
  125,
  125,
  12,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  34,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  60,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  127,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  123,
  122,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  127,
  105,
  126,
  125,
  125,
  125,
  125,
  125,
  10,
  125,
  13,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  20,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  35,
  125,
  38,
  125,
  125,
  125,
  125,
  125,
  43,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  49,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  82,
  63,
  125,
  125,
  125,
  84,
  67,
  125,
  69,
  125,
  125,
  127,
  2,
  123,
  122,
  95,
  0,
  0,
  0,
  98,
  127,
  105,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  77,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  33,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  54,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  66,
  68,
  125,
  125,
  122,
  95,
  127,
  85,
  125,
  7,
  125,
  125,
  125,
  14,
  15,
  125,
  125,
  125,
  125,
  75,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  31,
  125,
  125,
  37,
  125,
  125,
  125,
  125,
  42,
  125,
  125,
  125,
  125,
  125,
  125,
  48,
  125,
  125,
  52,
  125,
  125,
  56,
  125,
  125,
  125,
  61,
  125,
  81,
  125,
  125,
  65,
  125,
  125,
  122,
  127,
  87,
  125,
  9,
  125,
  16,
  125,
  73,
  18,
  125,
  125,
  25,
  125,
  125,
  125,
  125,
  26,
  125,
  125,
  125,
  125,
  32,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  50,
  125,
  125,
  125,
  80,
  125,
  125,
  125,
  64,
  125,
  125,
  125,
  74,
  127,
  8,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  28,
  29,
  125,
  125,
  125,
  125,
  125,
  86,
  125,
  125,
  125,
  79,
  125,
  125,
  51,
  53,
  125,
  125,
  58,
  125,
  125,
  125,
  125,
  127,
  125,
  17,
  125,
  125,
  24,
  125,
  125,
  23,
  125,
  125,
  36,
  39,
  125,
  125,
  44,
  125,
  125,
  125,
  125,
  55,
  125,
  125,
  62,
  83,
  125,
  125,
  124,
  11,
  76,
  125,
  125,
  125,
  125,
  30,
  125,
  125,
  125,
  125,
  46,
  125,
  125,
  125,
  125,
  125,
  19,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  71,
  125,
  125,
  125,
  40,
  41,
  125,
  45,
  47,
  125,
  125,
  70,
  21,
  22,
  125,
  78,
  125,
  59,
  125,
  125,
  27,
  125,
  57,
  0
}; // idb
_BYTE byte_119D20[256] =
{
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  3,
  1,
  1,
  4,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  5,
  6,
  7,
  6,
  6,
  6,
  6,
  8,
  9,
  10,
  11,
  12,
  6,
  13,
  14,
  15,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  19,
  6,
  20,
  6,
  6,
  6,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  23,
  24,
  6,
  21,
  6,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  21,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  6,
  51,
  6,
  6,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  55,
  55,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  57,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  59,
  60,
  60,
  61,
  62,
  62,
  62,
  63,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55
}; // idb
_BYTE byte_119E20[64] =
{
  0,
  1,
  2,
  2,
  2,
  2,
  3,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  3,
  4,
  4,
  5,
  2,
  3,
  6,
  3,
  3,
  3,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  2,
  2,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3
}; // idb
signed __int16 word_119E60[688] =
{
  0,
  0,
  0,
  61,
  122,
  62,
  63,
  185,
  0,
  248,
  311,
  374,
  437,
  504,
  4800,
  65,
  4800,
  474,
  19,
  4800,
  4800,
  27,
  78,
  490,
  81,
  88,
  4800,
  548,
  606,
  117,
  128,
  225,
  231,
  236,
  254,
  289,
  294,
  312,
  351,
  366,
  371,
  414,
  432,
  437,
  475,
  426,
  481,
  483,
  501,
  4800,
  4800,
  48,
  421,
  54,
  16,
  57,
  40,
  74,
  420,
  4800,
  4800,
  429,
  77,
  360,
  95,
  99,
  110,
  114,
  231,
  359,
  4800,
  168,
  4800,
  393,
  4800,
  4800,
  4800,
  4800,
  376,
  245,
  4800,
  4800,
  314,
  4800,
  4800,
  249,
  4800,
  4800,
  4800,
  4800,
  4800,
  362,
  234,
  245,
  275,
  237,
  290,
  243,
  294,
  242,
  4800,
  4800,
  298,
  274,
  4800,
  259,
  305,
  203,
  308,
  284,
  333,
  301,
  348,
  119,
  432,
  309,
  398,
  471,
  520,
  537,
  664,
  548,
  556,
  604,
  701,
  703,
  612,
  721,
  709,
  727,
  739,
  745,
  747,
  765,
  771,
  786,
  791,
  616,
  801,
  812,
  814,
  831,
  832,
  833,
  852,
  850,
  874,
  851,
  876,
  894,
  899,
  902,
  915,
  923,
  934,
  943,
  954,
  962,
  972,
  980,
  993,
  993,
  999,
  1014,
  1019,
  1022,
  1038,
  1038,
  1055,
  1057,
  1068,
  1076,
  1089,
  1095,
  487,
  534,
  542,
  549,
  583,
  662,
  665,
  4800,
  4800,
  707,
  768,
  853,
  856,
  876,
  940,
  996,
  378,
  4800,
  4800,
  4800,
  4800,
  141,
  0,
  274,
  4800,
  4800,
  1017,
  103,
  1075,
  364,
  1088,
  430,
  1091,
  60,
  4800,
  1094,
  1097,
  1100,
  1103,
  1106,
  1109,
  1112,
  4800,
  1156,
  1159,
  1166,
  1178,
  1176,
  1178,
  1184,
  1205,
  1216,
  1227,
  1235,
  1247,
  1253,
  1259,
  1263,
  1282,
  1287,
  1293,
  1305,
  1311,
  1317,
  1329,
  1340,
  1335,
  1350,
  1358,
  1371,
  1377,
  1379,
  1387,
  1389,
  1400,
  1409,
  1420,
  1421,
  1437,
  1435,
  1456,
  1458,
  1476,
  1478,
  1496,
  1501,
  1519,
  1521,
  1539,
  1544,
  1547,
  1561,
  1572,
  1580,
  1593,
  1601,
  1609,
  1622,
  1628,
  1630,
  1648,
  1659,
  1670,
  1681,
  1692,
  1700,
  1712,
  1720,
  1731,
  1739,
  1750,
  1758,
  435,
  1126,
  1213,
  1264,
  4800,
  1357,
  1438,
  1455,
  0,
  438,
  1473,
  1482,
  1501,
  1521,
  1545,
  1625,
  1628,
  4800,
  1652,
  1663,
  1678,
  612,
  1790,
  1802,
  1791,
  1806,
  1812,
  1839,
  1841,
  1859,
  1861,
  1867,
  1879,
  1885,
  1900,
  1905,
  1911,
  1923,
  1934,
  1942,
  1957,
  1962,
  1968,
  1980,
  1986,
  1991,
  2006,
  2006,
  2022,
  2024,
  2043,
  2045,
  2051,
  2063,
  2069,
  2074,
  2089,
  2094,
  2100,
  2104,
  2112,
  2120,
  2128,
  2136,
  2144,
  2152,
  2165,
  2171,
  2173,
  2191,
  2193,
  2199,
  2211,
  2222,
  2233,
  2241,
  2252,
  2263,
  2275,
  2275,
  2294,
  2296,
  2314,
  2319,
  2325,
  2337,
  2343,
  2337,
  2353,
  2355,
  2372,
  2373,
  2386,
  2394,
  451,
  4800,
  0,
  114,
  4800,
  1736,
  1744,
  1784,
  4800,
  1942,
  1957,
  2407,
  2413,
  2407,
  2429,
  2435,
  2450,
  2455,
  2470,
  2475,
  2490,
  2490,
  2507,
  2513,
  2528,
  2536,
  2547,
  2548,
  2559,
  2558,
  2578,
  2580,
  2598,
  2609,
  2617,
  2628,
  2636,
  2588,
  2636,
  2644,
  2655,
  2663,
  2671,
  2682,
  2684,
  2703,
  2705,
  2723,
  2728,
  2743,
  2751,
  2762,
  2774,
  2782,
  2793,
  2804,
  2815,
  2826,
  2834,
  2845,
  2857,
  2857,
  2876,
  2878,
  2896,
  2901,
  2907,
  2919,
  2925,
  2919,
  2935,
  495,
  4800,
  1976,
  2937,
  2948,
  2956,
  2969,
  2975,
  2969,
  2985,
  2987,
  2998,
  3007,
  3018,
  3026,
  3037,
  3048,
  3049,
  3066,
  3068,
  3067,
  3085,
  3087,
  3106,
  3108,
  3126,
  3131,
  3137,
  3149,
  3157,
  3168,
  3186,
  3191,
  3197,
  3209,
  3215,
  3209,
  3230,
  3235,
  3253,
  3255,
  3261,
  3273,
  3281,
  3279,
  3299,
  3301,
  3307,
  3325,
  3330,
  3345,
  3319,
  3350,
  3365,
  3365,
  3371,
  3386,
  3391,
  3397,
  363,
  728,
  3409,
  3415,
  3420,
  3438,
  3440,
  3458,
  3463,
  3469,
  3481,
  3489,
  3500,
  3508,
  3508,
  3525,
  3527,
  3538,
  3547,
  3558,
  3566,
  3578,
  3584,
  3578,
  3599,
  3605,
  3611,
  3617,
  3623,
  3627,
  3638,
  3646,
  3657,
  3659,
  3670,
  3679,
  3690,
  3698,
  3709,
  3717,
  3728,
  3729,
  3740,
  3748,
  3761,
  3767,
  73,
  2230,
  3769,
  3787,
  3792,
  3798,
  3810,
  3818,
  3818,
  3826,
  3839,
  3845,
  3847,
  3865,
  3867,
  3873,
  3885,
  3891,
  3909,
  3903,
  3914,
  3929,
  3934,
  3952,
  3957,
  3963,
  3975,
  3981,
  3986,
  4001,
  4013,
  4019,
  4024,
  4032,
  4040,
  2256,
  4048,
  4059,
  4068,
  4079,
  4087,
  4098,
  4099,
  4110,
  4109,
  4129,
  4134,
  4140,
  4152,
  4158,
  4160,
  4178,
  4180,
  4198,
  4200,
  4220,
  4222,
  4228,
  4240,
  4246,
  4252,
  4264,
  506,
  4270,
  4272,
  4290,
  4292,
  4312,
  4314,
  4332,
  4334,
  4352,
  4357,
  4375,
  4377,
  4395,
  4385,
  4410,
  4399,
  4418,
  4429,
  4437,
  4450,
  4463,
  4461,
  4474,
  4482,
  4495,
  4501,
  4503,
  4521,
  4526,
  4532,
  4544,
  4550,
  4556,
  4568,
  4574,
  4576,
  4594,
  4596,
  4602,
  4620,
  4614,
  4625,
  4640,
  4645,
  4663,
  4665,
  4671,
  4675,
  4691,
  4696,
  4702,
  4714,
  4800,
  4758,
  4764,
  4770,
  4774,
  4778,
  4781,
  4786,
  65,
  4790,
  4793,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
signed __int16 word_11A3C0[688] =
{
  0,
  671,
  1,
  672,
  672,
  4,
  4,
  671,
  7,
  673,
  673,
  674,
  674,
  671,
  671,
  671,
  671,
  671,
  675,
  671,
  671,
  675,
  675,
  675,
  23,
  23,
  671,
  676,
  676,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  677,
  671,
  671,
  677,
  671,
  671,
  671,
  671,
  671,
  678,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  23,
  23,
  23,
  28,
  671,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  133,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  133,
  133,
  28,
  133,
  28,
  28,
  28,
  133,
  28,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  677,
  679,
  677,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  23,
  680,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  23,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  681,
  677,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  680,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  23,
  671,
  681,
  677,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  677,
  671,
  23,
  133,
  133,
  133,
  28,
  28,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  677,
  23,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  677,
  23,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  23,
  133,
  133,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  23,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  0,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
void *off_11A920 = (void *)0x10000F000E0000LL; // weak
void *off_11CF20 = (void *)0x1000100010000LL; // weak
char off_11F9B7[] = { '%', 's', '\n', '\0' }; // idb
char off_11FDF0[] = { ' ', '\t', '\n', '\0', 'u', 'n', 'i', 'q' }; // idb
_UNKNOWN unk_1208B5; // weak
_UNKNOWN unk_120A60; // weak
void *off_120FA0 = (void *)0x7325LL; // weak
_UNKNOWN unk_121924; // weak
void *__ptr32 off_12268F = (void *__ptr32 )0x7325LL; // weak
_UNKNOWN unk_12274D; // weak
void *off_124340 = (void *)0x7325LL; // weak
_UNKNOWN unk_1243FC; // weak
_UNKNOWN unk_124B7E; // weak
__int16 asc_124E90[5] = { 40, 41, 91, 93, 46 }; // weak
char byte_124F70[4] = { '\0', '\0', '\0', '\0' }; // idb
char off_125228[] = { '%', 's', '\n', '\0', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_127220; // weak
_UNKNOWN unk_127223; // weak
_UNKNOWN unk_127226; // weak
_UNKNOWN unk_127229; // weak
void *__ptr32 off_12722C = &loc_A7B20; // weak
_UNKNOWN unk_127230; // weak
void *__ptr32 off_127255 = (void *__ptr32 )0xA3B22LL; // weak
_UNKNOWN unk_127259; // weak
char off_1272F0[] = { '%', 'u', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_127870; // weak
void *__ptr32 off_12788B = (void *__ptr32 )0xA3E2FLL; // weak
_UNKNOWN unk_12788F; // weak
void *__ptr32 off_1278CF = &loc_A3E22; // weak
char off_12796A[] = { '%', 'u', '\0', '\0' }; // idb
_UNKNOWN unk_127F9E; // weak
_UNKNOWN unk_12884C; // weak
void *__ptr32 off_1288F9 = (void *__ptr32 )0x7325LL; // weak
_UNKNOWN unk_128B1B; // weak
__int16 asc_128B7C[3] = { 40, 123, 44 }; // weak
void *__ptr32 off_128D15 = (void *__ptr32 )0xA7325LL; // weak
_UNKNOWN unk_128D19; // weak
void *off_128E00 = (void *)0x6564724F000A6F6ELL; // weak
void *__ptr32 off_12909C = &loc_A7525; // weak
_UNKNOWN unk_1293DF; // weak
void *__ptr32 off_12941A = (void *__ptr32 )0x7325LL; // weak
_UNKNOWN unk_1296A8; // weak
tls_index_local stru_335FC0 = { 1uLL, 0uLL }; // weak
__int64 qword_335FE0 = 1LL; // weak
void *off_3365A0 = &off_3365A0; // weak
char *off_3457F0 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module name=\"ietf-yang-metadata\"\n        xmlns=\"urn:ietf:params:xml:ns:yang:yin:1\"\n        xmlns:md=\"urn:ietf:params:xml:ns:yang:ietf-yang-metadata\">\n  <namespace uri=\"urn:ietf:params:xml:ns:yang:ietf-yang-metadata\"/>\n  <prefix value=\"md\"/>\n  <organization>\n    <text>IETF NETMOD (NETCONF Data Modeling Language) Working Group</text>\n  </organization>\n  <contact>\n    <text>WG Web:   &lt;https://datatracker.ietf.org/wg/netmod/&gt;\n\nWG List:  &lt;mailto:netmod@ietf.org&gt;\n\nWG Chair: Lou Berger\n          &lt;mailto:lberger@labn.net&gt;\n\nWG Chair: Kent Watsen\n          &lt;mailto:kwatsen@juniper.net&gt;\n\nEditor:   Ladislav Lhotka\n          &lt;mailto:lhotka@nic.cz&gt;</text>\n  </contact>\n  <description>\n    <text>This YANG module defines an 'extension' statement that allows\nfor defining metadata annotations.\n\nCopyright (c) 2016 IETF Trust and the persons identified as\nauthors of the code.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or\nwithout modification, is permitted pursuant to, and subject to\nthe license terms contained in, the Simplified BSD License set\nforth in Section 4.c of the IETF Trust's Legal Provisions\nRelating to IETF Documents\n(http://trustee.ietf.org/license-info).\n\nThis version of this YANG module is part of RFC 7952\n(http://www.rfc-editor.org/info/rfc7952); see the RFC itself\nfor full legal notices.</text>\n  </description>\n  <revision date=\"2016-08-05\">\n    <description>\n      <text>Initial revision.</text>\n    </description>\n    <reference>\n      <text>RFC 7952: Defining and Using Metadata with YANG</text>\n    </reference>\n  </revision>\n  <extension name=\"annotation\">\n    <argument name=\"name\"/>\n    <description>\n      <text>This extension allows for defining metadata annotations in\nYANG modules.  The 'md:annotation' statement can appear only\nat the top level of a YANG module or submodule, i.e., it\nbecomes a new alternative in the ABNF production rule for\n'body-stmts' (Section 14 in RFC 7950).\n\nThe argument of the 'md:annotation' statement defines the name\nof the annotation.  Syntactically, it is a YANG identifier as\ndefined in Section 6.2 of RFC 7950.\n\nAn annotation defined with this 'extension' statement inherits\nthe namespace and other context from the YANG module in which\nit is defined.\n\nThe data type of the annotation value is specified in the same\nway as for a leaf data node using the 'type' statement.\n\nThe semantics of the annotation and other documentation can be\nspecified using the following standard YANG substatements (all\nare optional): 'description', 'if-feature', 'reference',\n'status', and 'units'.\n\nA server announces support for a particular annotation by\nincluding the module in which the annotation is defined among\nthe advertised YANG modules, e.g., in a NETCONF &lt;hello&gt;\nmessage or in the YANG library (RFC 7950).  The annotation can\nthen be attached to any instance of a data node defined in any\nYANG module that is advertised by the server.\n\nXML encoding and JSON encoding of annotations are defined in\nRFC 7952.</text>\n    </description>\n  </extension>\n</module>"; // weak
_UNKNOWN unk_3457F8; // weak
_UNKNOWN unk_3457FC; // weak
char byte_3458A0 = '\x01'; // weak
char byte_3458A1 = '\a'; // weak
int dword_3458A4 = 1; // weak
_DWORD dword_3458B0[12] = { 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0 }; // idb
void *off_3458E0 = &unk_108F1E; // weak
char *off_345BA0[166] =
{
  "BasicLatin",
  "[\\x{0000}-\\x{007F}]",
  "Latin-1Supplement",
  "[\\x{0080}-\\x{00FF}]",
  "LatinExtended-A",
  "[\\x{0100}-\\x{017F}]",
  "LatinExtended-B",
  "[\\x{0180}-\\x{024F}]",
  "IPAExtensions",
  "[\\x{0250}-\\x{02AF}]",
  "SpacingModifierLetters",
  "[\\x{02B0}-\\x{02FF}]",
  "CombiningDiacriticalMarks",
  "[\\x{0300}-\\x{036F}]",
  "Greek",
  "[\\x{0370}-\\x{03FF}]",
  "Cyrillic",
  "[\\x{0400}-\\x{04FF}]",
  "Armenian",
  "[\\x{0530}-\\x{058F}]",
  "Hebrew",
  "[\\x{0590}-\\x{05FF}]",
  "Arabic",
  "[\\x{0600}-\\x{06FF}]",
  "Syriac",
  "[\\x{0700}-\\x{074F}]",
  "Thaana",
  "[\\x{0780}-\\x{07BF}]",
  "Devanagari",
  "[\\x{0900}-\\x{097F}]",
  "Bengali",
  "[\\x{0980}-\\x{09FF}]",
  "Gurmukhi",
  "[\\x{0A00}-\\x{0A7F}]",
  "Gujarati",
  "[\\x{0A80}-\\x{0AFF}]",
  "Oriya",
  "[\\x{0B00}-\\x{0B7F}]",
  "Tamil",
  "[\\x{0B80}-\\x{0BFF}]",
  "Telugu",
  "[\\x{0C00}-\\x{0C7F}]",
  "Kannada",
  "[\\x{0C80}-\\x{0CFF}]",
  "Malayalam",
  "[\\x{0D00}-\\x{0D7F}]",
  "Sinhala",
  "[\\x{0D80}-\\x{0DFF}]",
  "Thai",
  "[\\x{0E00}-\\x{0E7F}]",
  "Lao",
  "[\\x{0E80}-\\x{0EFF}]",
  "Tibetan",
  "[\\x{0F00}-\\x{0FFF}]",
  "Myanmar",
  "[\\x{1000}-\\x{109F}]",
  "Georgian",
  "[\\x{10A0}-\\x{10FF}]",
  "HangulJamo",
  "[\\x{1100}-\\x{11FF}]",
  "Ethiopic",
  "[\\x{1200}-\\x{137F}]",
  "Cherokee",
  "[\\x{13A0}-\\x{13FF}]",
  "UnifiedCanadianAboriginalSyllabics",
  "[\\x{1400}-\\x{167F}]",
  "Ogham",
  "[\\x{1680}-\\x{169F}]",
  "Runic",
  "[\\x{16A0}-\\x{16FF}]",
  "Khmer",
  "[\\x{1780}-\\x{17FF}]",
  "Mongolian",
  "[\\x{1800}-\\x{18AF}]",
  "LatinExtendedAdditional",
  "[\\x{1E00}-\\x{1EFF}]",
  "GreekExtended",
  "[\\x{1F00}-\\x{1FFF}]",
  "GeneralPunctuation",
  "[\\x{2000}-\\x{206F}]",
  "SuperscriptsandSubscripts",
  "[\\x{2070}-\\x{209F}]",
  "CurrencySymbols",
  "[\\x{20A0}-\\x{20CF}]",
  "CombiningMarksforSymbols",
  "[\\x{20D0}-\\x{20FF}]",
  "LetterlikeSymbols",
  "[\\x{2100}-\\x{214F}]",
  "NumberForms",
  "[\\x{2150}-\\x{218F}]",
  "Arrows",
  "[\\x{2190}-\\x{21FF}]",
  "MathematicalOperators",
  "[\\x{2200}-\\x{22FF}]",
  "MiscellaneousTechnical",
  "[\\x{2300}-\\x{23FF}]",
  "ControlPictures",
  "[\\x{2400}-\\x{243F}]",
  "OpticalCharacterRecognition",
  "[\\x{2440}-\\x{245F}]",
  "EnclosedAlphanumerics",
  "[\\x{2460}-\\x{24FF}]",
  "BoxDrawing",
  "[\\x{2500}-\\x{257F}]",
  "BlockElements",
  "[\\x{2580}-\\x{259F}]",
  "GeometricShapes",
  "[\\x{25A0}-\\x{25FF}]",
  "MiscellaneousSymbols",
  "[\\x{2600}-\\x{26FF}]",
  "Dingbats",
  "[\\x{2700}-\\x{27BF}]",
  "BraillePatterns",
  "[\\x{2800}-\\x{28FF}]",
  "CJKRadicalsSupplement",
  "[\\x{2E80}-\\x{2EFF}]",
  "KangxiRadicals",
  "[\\x{2F00}-\\x{2FDF}]",
  "IdeographicDescriptionCharacters",
  "[\\x{2FF0}-\\x{2FFF}]",
  "CJKSymbolsandPunctuation",
  "[\\x{3000}-\\x{303F}]",
  "Hiragana",
  "[\\x{3040}-\\x{309F}]",
  "Katakana",
  "[\\x{30A0}-\\x{30FF}]",
  "Bopomofo",
  "[\\x{3100}-\\x{312F}]",
  "HangulCompatibilityJamo",
  "[\\x{3130}-\\x{318F}]",
  "Kanbun",
  "[\\x{3190}-\\x{319F}]",
  "BopomofoExtended",
  "[\\x{31A0}-\\x{31BF}]",
  "EnclosedCJKLettersandMonths",
  "[\\x{3200}-\\x{32FF}]",
  "CJKCompatibility",
  "[\\x{3300}-\\x{33FF}]",
  "CJKUnifiedIdeographsExtensionA",
  "[\\x{3400}-\\x{4DB5}]",
  "CJKUnifiedIdeographs",
  "[\\x{4E00}-\\x{9FFF}]",
  "YiSyllables",
  "[\\x{A000}-\\x{A48F}]",
  "YiRadicals",
  "[\\x{A490}-\\x{A4CF}]",
  "HangulSyllables",
  "[\\x{AC00}-\\x{D7A3}]",
  "PrivateUse",
  "[\\x{E000}-\\x{F8FF}]",
  "CJKCompatibilityIdeographs",
  "[\\x{F900}-\\x{FAFF}]",
  "AlphabeticPresentationForms",
  "[\\x{FB00}-\\x{FB4F}]",
  "ArabicPresentationForms-A",
  "[\\x{FB50}-\\x{FDFF}]",
  "CombiningHalfMarks",
  "[\\x{FE20}-\\x{FE2F}]",
  "CJKCompatibilityForms",
  "[\\x{FE30}-\\x{FE4F}]",
  "SmallFormVariants",
  "[\\x{FE50}-\\x{FE6F}]",
  "ArabicPresentationForms-B",
  "[\\x{FE70}-\\x{FEFE}]",
  "HalfwidthandFullwidthForms",
  "[\\x{FF00}-\\x{FFEF}]"
}; // weak
char *off_345BA8[165] =
{
  "[\\x{0000}-\\x{007F}]",
  "Latin-1Supplement",
  "[\\x{0080}-\\x{00FF}]",
  "LatinExtended-A",
  "[\\x{0100}-\\x{017F}]",
  "LatinExtended-B",
  "[\\x{0180}-\\x{024F}]",
  "IPAExtensions",
  "[\\x{0250}-\\x{02AF}]",
  "SpacingModifierLetters",
  "[\\x{02B0}-\\x{02FF}]",
  "CombiningDiacriticalMarks",
  "[\\x{0300}-\\x{036F}]",
  "Greek",
  "[\\x{0370}-\\x{03FF}]",
  "Cyrillic",
  "[\\x{0400}-\\x{04FF}]",
  "Armenian",
  "[\\x{0530}-\\x{058F}]",
  "Hebrew",
  "[\\x{0590}-\\x{05FF}]",
  "Arabic",
  "[\\x{0600}-\\x{06FF}]",
  "Syriac",
  "[\\x{0700}-\\x{074F}]",
  "Thaana",
  "[\\x{0780}-\\x{07BF}]",
  "Devanagari",
  "[\\x{0900}-\\x{097F}]",
  "Bengali",
  "[\\x{0980}-\\x{09FF}]",
  "Gurmukhi",
  "[\\x{0A00}-\\x{0A7F}]",
  "Gujarati",
  "[\\x{0A80}-\\x{0AFF}]",
  "Oriya",
  "[\\x{0B00}-\\x{0B7F}]",
  "Tamil",
  "[\\x{0B80}-\\x{0BFF}]",
  "Telugu",
  "[\\x{0C00}-\\x{0C7F}]",
  "Kannada",
  "[\\x{0C80}-\\x{0CFF}]",
  "Malayalam",
  "[\\x{0D00}-\\x{0D7F}]",
  "Sinhala",
  "[\\x{0D80}-\\x{0DFF}]",
  "Thai",
  "[\\x{0E00}-\\x{0E7F}]",
  "Lao",
  "[\\x{0E80}-\\x{0EFF}]",
  "Tibetan",
  "[\\x{0F00}-\\x{0FFF}]",
  "Myanmar",
  "[\\x{1000}-\\x{109F}]",
  "Georgian",
  "[\\x{10A0}-\\x{10FF}]",
  "HangulJamo",
  "[\\x{1100}-\\x{11FF}]",
  "Ethiopic",
  "[\\x{1200}-\\x{137F}]",
  "Cherokee",
  "[\\x{13A0}-\\x{13FF}]",
  "UnifiedCanadianAboriginalSyllabics",
  "[\\x{1400}-\\x{167F}]",
  "Ogham",
  "[\\x{1680}-\\x{169F}]",
  "Runic",
  "[\\x{16A0}-\\x{16FF}]",
  "Khmer",
  "[\\x{1780}-\\x{17FF}]",
  "Mongolian",
  "[\\x{1800}-\\x{18AF}]",
  "LatinExtendedAdditional",
  "[\\x{1E00}-\\x{1EFF}]",
  "GreekExtended",
  "[\\x{1F00}-\\x{1FFF}]",
  "GeneralPunctuation",
  "[\\x{2000}-\\x{206F}]",
  "SuperscriptsandSubscripts",
  "[\\x{2070}-\\x{209F}]",
  "CurrencySymbols",
  "[\\x{20A0}-\\x{20CF}]",
  "CombiningMarksforSymbols",
  "[\\x{20D0}-\\x{20FF}]",
  "LetterlikeSymbols",
  "[\\x{2100}-\\x{214F}]",
  "NumberForms",
  "[\\x{2150}-\\x{218F}]",
  "Arrows",
  "[\\x{2190}-\\x{21FF}]",
  "MathematicalOperators",
  "[\\x{2200}-\\x{22FF}]",
  "MiscellaneousTechnical",
  "[\\x{2300}-\\x{23FF}]",
  "ControlPictures",
  "[\\x{2400}-\\x{243F}]",
  "OpticalCharacterRecognition",
  "[\\x{2440}-\\x{245F}]",
  "EnclosedAlphanumerics",
  "[\\x{2460}-\\x{24FF}]",
  "BoxDrawing",
  "[\\x{2500}-\\x{257F}]",
  "BlockElements",
  "[\\x{2580}-\\x{259F}]",
  "GeometricShapes",
  "[\\x{25A0}-\\x{25FF}]",
  "MiscellaneousSymbols",
  "[\\x{2600}-\\x{26FF}]",
  "Dingbats",
  "[\\x{2700}-\\x{27BF}]",
  "BraillePatterns",
  "[\\x{2800}-\\x{28FF}]",
  "CJKRadicalsSupplement",
  "[\\x{2E80}-\\x{2EFF}]",
  "KangxiRadicals",
  "[\\x{2F00}-\\x{2FDF}]",
  "IdeographicDescriptionCharacters",
  "[\\x{2FF0}-\\x{2FFF}]",
  "CJKSymbolsandPunctuation",
  "[\\x{3000}-\\x{303F}]",
  "Hiragana",
  "[\\x{3040}-\\x{309F}]",
  "Katakana",
  "[\\x{30A0}-\\x{30FF}]",
  "Bopomofo",
  "[\\x{3100}-\\x{312F}]",
  "HangulCompatibilityJamo",
  "[\\x{3130}-\\x{318F}]",
  "Kanbun",
  "[\\x{3190}-\\x{319F}]",
  "BopomofoExtended",
  "[\\x{31A0}-\\x{31BF}]",
  "EnclosedCJKLettersandMonths",
  "[\\x{3200}-\\x{32FF}]",
  "CJKCompatibility",
  "[\\x{3300}-\\x{33FF}]",
  "CJKUnifiedIdeographsExtensionA",
  "[\\x{3400}-\\x{4DB5}]",
  "CJKUnifiedIdeographs",
  "[\\x{4E00}-\\x{9FFF}]",
  "YiSyllables",
  "[\\x{A000}-\\x{A48F}]",
  "YiRadicals",
  "[\\x{A490}-\\x{A4CF}]",
  "HangulSyllables",
  "[\\x{AC00}-\\x{D7A3}]",
  "PrivateUse",
  "[\\x{E000}-\\x{F8FF}]",
  "CJKCompatibilityIdeographs",
  "[\\x{F900}-\\x{FAFF}]",
  "AlphabeticPresentationForms",
  "[\\x{FB00}-\\x{FB4F}]",
  "ArabicPresentationForms-A",
  "[\\x{FB50}-\\x{FDFF}]",
  "CombiningHalfMarks",
  "[\\x{FE20}-\\x{FE2F}]",
  "CJKCompatibilityForms",
  "[\\x{FE30}-\\x{FE4F}]",
  "SmallFormVariants",
  "[\\x{FE50}-\\x{FE6F}]",
  "ArabicPresentationForms-B",
  "[\\x{FE70}-\\x{FEFE}]",
  "HalfwidthandFullwidthForms",
  "[\\x{FF00}-\\x{FFEF}]"
}; // weak
void *off_3460E0 = &unk_10DE4F; // weak
_UNKNOWN unk_346320; // weak
const char **qword_346FA0[1] = { &size }; // idb
char edata; // weak
int dword_347048; // weak
__int64 (__fastcall *qword_347050)(_QWORD, _QWORD, _QWORD); // weak
void *ptr; // idb
__int16 word_347068; // weak
void *qword_347070; // idb
__int16 word_347078; // weak
int dword_347080; // weak
int dword_347084; // weak
void *qword_347088; // idb
pthread_mutex_t mutex; // idb
void *qword_3470C8; // idb
__int16 word_3470D0; // weak
int dword_3470D4; // weak
// extern struct _IO_FILE *stdout;
// extern struct _IO_FILE *stdin;
// extern __int64 (__fastcall *pcre_free)(_QWORD); weak
// extern _UNKNOWN __cxa_finalize; weak
// extern struct _IO_FILE *stderr;


//----- (0000000000007160) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 3473E0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000007180) ----------------------------------------------------
void sub_7180()
{
  JUMPOUT(&size);
}

//----- (0000000000007C90) ----------------------------------------------------
char *start()
{
  char *result; // rax

  result = &edata;
  if ( &edata != &edata )
  {
    result = (char *)&ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (char *)ITM_deregisterTMCloneTable();
  }
  return result;
}
// 347040: using guessed type char edata;
// 3473D8: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000007CD0) ----------------------------------------------------
__int64 sub_7CD0()
{
  return 0LL;
}

//----- (0000000000007D20) ----------------------------------------------------
char *sub_7D20()
{
  char *result; // rax

  if ( !edata )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_3365A0);
    result = start();
    edata = 1;
  }
  return result;
}
// 7C88: using guessed type __int64 __fastcall _cxa_finalize(_QWORD);
// 3365A0: using guessed type void *off_3365A0;
// 347040: using guessed type char edata;

//----- (0000000000007D60) ----------------------------------------------------
__int64 sub_7D60()
{
  return sub_7CD0();
}

//----- (0000000000007D6A) ----------------------------------------------------
__int64 __fastcall ly_errno_glob_address(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_errno_glob_address", a4, a5, a6);
  return __tls_get_addr(&qword_335FE0);
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 107C20: using guessed type void *off_107C20;
// 335FE0: using guessed type __int64 qword_335FE0;

//----- (0000000000007D9D) ----------------------------------------------------
__int64 __fastcall ly_vecode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_vecode", a4, a5, a6);
  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(unsigned int *)(*(_QWORD *)(v7 + 48) + 8LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007DF1) ----------------------------------------------------
__int64 __fastcall ly_errmsg(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_errmsg", a4, a5, a6);
  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 16LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007E46) ----------------------------------------------------
__int64 __fastcall ly_errpath(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_errpath", a4, a5, a6);
  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 24LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007E9B) ----------------------------------------------------
__int64 __fastcall ly_errapptag(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_errapptag", a4, a5, a6);
  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 32LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007EF0) ----------------------------------------------------
void *__fastcall ly_err_first(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *result; // rax

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_err_first", a4, a5, a6);
  if ( a1 )
    result = pthread_getspecific(*(_DWORD *)(a1 + 128));
  else
    result = 0LL;
  return result;
}
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007F3A) ----------------------------------------------------
void __fastcall destr_function(void *a1)
{
  void *v1; // ST18_8
  void *ptr; // [rsp+10h] [rbp-10h]

  for ( ptr = a1; ptr; ptr = v1 )
  {
    v1 = (void *)*((_QWORD *)ptr + 5);
    free(*((void **)ptr + 2));
    free(*((void **)ptr + 3));
    free(*((void **)ptr + 4));
    free(ptr);
  }
}

//----- (0000000000007FAA) ----------------------------------------------------
__int64 __fastcall ly_err_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _DWORD *v6; // rdx
  __int64 result; // rax
  __int64 v8; // rdi
  _QWORD *v9; // [rsp+0h] [rbp-20h]
  _QWORD *i; // [rsp+10h] [rbp-10h]
  _QWORD *v11; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_err_clean", a4, a5, a6, a2);
  v11 = (_QWORD *)ly_err_first(a1);
  if ( v11 == v9 )
    v9 = 0LL;
  if ( v9 )
  {
    for ( i = v11; i && v9 != (_QWORD *)i[5]; i = (_QWORD *)i[5] )
      ;
    if ( !i )
      __assert_fail("i", "/home/mantovan/Repositories/libyang/src/common.c", 0x91u, "ly_err_clean");
    i[5] = 0LL;
    v11[6] = i;
    destr_function(v9);
    v6 = (_DWORD *)ly_errno_glob_address(v9);
    result = *((unsigned int *)i + 1);
    *v6 = result;
  }
  else
  {
    destr_function(v11);
    v8 = *(unsigned int *)(a1 + 128);
    pthread_setspecific(v8, 0LL);
    result = ly_errno_glob_address(v8);
    *(_DWORD *)result = 0;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (00000000000080BC) ----------------------------------------------------
_BYTE *__fastcall sub_80BC(_BYTE *a1, _BYTE *a2, int a3)
{
  int i; // [rsp+0h] [rbp-24h]
  _BYTE *v5; // [rsp+Ch] [rbp-18h]
  _BYTE *j; // [rsp+1Ch] [rbp-8h]

  v5 = a1;
  for ( i = a3; *v5 && i; --i )
  {
    for ( j = a2; *j; ++j )
    {
      if ( *v5 == *j )
        return v5;
    }
    --v5;
  }
  return v5;
}

//----- (000000000000811F) ----------------------------------------------------
_BYTE *__fastcall sub_811F(_BYTE *a1, char a2, int a3)
{
  int v4; // [rsp+0h] [rbp-10h]
  _BYTE *v5; // [rsp+8h] [rbp-8h]

  v5 = a1;
  v4 = a3;
  while ( *v5 != a2 )
  {
    if ( !*v5 || !v4 )
      return 0LL;
    ++v5;
    --v4;
  }
  return v5;
}

//----- (0000000000008164) ----------------------------------------------------
const char *__fastcall sub_8164(unsigned int a1)
{
  if ( a1 == 128 )
    return "notification";
  if ( a1 > 0x80 )
  {
    if ( a1 == 4096 )
      return "uses";
    if ( a1 > 0x1000 )
    {
      if ( a1 == 0x4000 )
        return "action";
      if ( a1 > 0x4000 )
      {
        if ( a1 == 32800 )
          return "anydata";
        if ( a1 == 0x10000 )
          return "extension instance";
      }
      else if ( a1 == 0x2000 )
      {
        return "augment";
      }
    }
    else
    {
      if ( a1 == 512 )
        return "input";
      if ( a1 > 0x200 )
      {
        if ( a1 == 1024 )
          return "output";
        if ( a1 == 2048 )
          return "grouping";
      }
      else if ( a1 == 256 )
      {
        return "rpc";
      }
    }
  }
  else
  {
    if ( a1 == 4 )
      return "leaf";
    if ( a1 > 4 )
    {
      if ( a1 == 16 )
        return "list";
      if ( a1 > 0x10 )
      {
        if ( a1 == 32 )
          return "anyxml";
        if ( a1 == 64 )
          return "case";
      }
      else if ( a1 == 8 )
      {
        return "leaf-list";
      }
    }
    else
    {
      if ( a1 == 1 )
        return "container";
      if ( a1 < 1 )
        return 0LL;
      if ( a1 == 2 )
        return "choice";
    }
  }
  return 0LL;
}

//----- (000000000000831C) ----------------------------------------------------
__int64 __fastcall sub_831C(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  unsigned __int16 i; // [rsp+1Eh] [rbp-2h]

  if ( !a2 )
    return 0LL;
  v3 = lys_main_module(a1);
  if ( !strcmp(*(const char **)(v3 + 8), a2) )
    return *(_QWORD *)(a1 + 16);
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 69); ++i )
  {
    if ( !strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i) + 8LL), a2) )
      return *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i + 8);
  }
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000083E9) ----------------------------------------------------
signed __int64 __fastcall sub_83E9(_QWORD *a1, const char *a2, void **a3, __int64 *a4, size_t *a5, int a6, int a7, void **a8, void **a9, unsigned int *a10)
{
  __int64 v11; // r9
  __int64 v12; // r9
  size_t v13; // rbx
  size_t v14; // rax
  __int64 v15; // r9
  __int64 v16; // rbx
  int v17; // [rsp+24h] [rbp-ACh]
  size_t *v18; // [rsp+28h] [rbp-A8h]
  __int64 *v19; // [rsp+30h] [rbp-A0h]
  void **v20; // [rsp+38h] [rbp-98h]
  int v21; // [rsp+5Ch] [rbp-74h]
  unsigned int i; // [rsp+60h] [rbp-70h]
  unsigned int j; // [rsp+64h] [rbp-6Ch]
  char *src; // [rsp+68h] [rbp-68h]
  char *s; // [rsp+70h] [rbp-60h]
  size_t n; // [rsp+78h] [rbp-58h]
  __int64 v27; // [rsp+80h] [rbp-50h]
  __int64 v28; // [rsp+88h] [rbp-48h]
  void *v29; // [rsp+90h] [rbp-40h]
  _QWORD *v30; // [rsp+98h] [rbp-38h]
  char *string; // [rsp+A0h] [rbp-30h]
  void *ptr; // [rsp+A8h] [rbp-28h]
  char *v33; // [rsp+B0h] [rbp-20h]
  unsigned __int64 v34; // [rsp+B8h] [rbp-18h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v17 = a6;
  v34 = __readfsqword(0x28u);
  v27 = 0LL;
  v28 = 0LL;
  v29 = (void *)*a1;
  if ( !a1 || !a2 || (a8 || a9 || a10) && (!a8 || !a9 || !a10) )
    __assert_fail(
      "module && expr && ((!prefixes && !namespaces && !ns_count) || (prefixes && namespaces && ns_count))",
      "/home/mantovan/Repositories/libyang/src/common.c",
      0x11Eu,
      "_transform_json2xml_subexp");
  v30 = sub_CB4D2(v29, a2);
  if ( !v30 )
    return 1LL;
  for ( i = 0; ; ++i )
  {
    if ( i >= *((unsigned __int16 *)v30 + 16) )
    {
      sub_C488D((__int64)v30);
      return 0LL;
    }
    string = (char *)(v30[5] + *(unsigned __int16 *)(2LL * i + v30[1]));
    if ( i )
    {
      src = (char *)(v30[5]
                   + *(unsigned __int16 *)(2LL * (i - 1) + v30[1])
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * (i - 1) + v30[2]));
      if ( src != string )
      {
        strncpy((char *)*v20 + *v19, src, string - src);
        *v19 += string - src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *v30) == 9 )
    {
      src = sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v30[2]));
      if ( src || a7 )
        break;
    }
    if ( *(_DWORD *)(4LL * i + *v30) == 17
      && (src = sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v30[2]))) != 0LL )
    {
      *((_BYTE *)*v20 + (*v19)++) = *string;
      v33 = (char *)lydict_insert(*a1, string + 1, *(unsigned __int16 *)(2LL * i + v30[2]) - 2);
      sub_141E4(0LL, 2u, &v21, 0LL);
      if ( (unsigned int)sub_83E9((_DWORD)a1, (_DWORD)v33, (__int64)v20, (__int64)v19, (__int64)v18) )
      {
        strncpy((char *)*v20 + *v19, v33, *(unsigned __int16 *)(2LL * i + v30[2]) - 2);
        *v19 += *(unsigned __int16 *)(2LL * i + v30[2]) - 2;
      }
      sub_142D2(0LL, v21, 0LL, 0);
      lydict_remove(*a1, v33);
      *((_BYTE *)*v20 + (*v19)++) = string[*(unsigned __int16 *)(2LL * i + v30[2]) - 1];
    }
    else
    {
      strncpy(
        (char *)*v20 + *v19,
        (const char *)(v30[5] + *(unsigned __int16 *)(2LL * i + v30[1])),
        *(unsigned __int16 *)(2LL * i + v30[2]));
      *v19 += *(unsigned __int16 *)(2LL * i + v30[2]);
    }
LABEL_61:
    ;
  }
  if ( v17 )
  {
    if ( src )
    {
      n = src - string;
    }
    else
    {
      n = strlen(string);
      src = string;
    }
    ptr = strndup(string, n);
    s = (char *)sub_831C((__int64)a1, (const char *)ptr);
    free(ptr);
    if ( !s )
    {
      sub_13937(v29, 29, 0, 0LL, n, (__int64)string);
      goto LABEL_64;
    }
  }
  else
  {
    if ( src )
    {
      n = src - string;
      ptr = strndup(string, src - string);
      v27 = ly_ctx_get_module(*a1, ptr, 0LL, 0LL);
      if ( *(_QWORD *)(*a1 + 112LL) )
      {
        if ( v27 )
        {
          if ( *(_BYTE *)(v27 + 64) >= 0 )
            v27 = (*(__int64 (__fastcall **)(_QWORD, void *, _QWORD, signed __int64, _QWORD))(*a1 + 112LL))(
                    *a1,
                    ptr,
                    *(_QWORD *)(v27 + 176),
                    1LL,
                    *(_QWORD *)(*a1 + 120LL));
        }
        else
        {
          v27 = (*(__int64 (__fastcall **)(_QWORD, void *, _QWORD, _QWORD, _QWORD))(*a1 + 112LL))(
                  *a1,
                  ptr,
                  0LL,
                  0LL,
                  *(_QWORD *)(*a1 + 120LL));
        }
      }
      free(ptr);
      if ( !v27 )
      {
        sub_13937(v29, 29, 0, 0LL, n, (__int64)string);
        goto LABEL_64;
      }
      v28 = v27;
    }
    else
    {
      v27 = v28;
      if ( !v28 )
      {
        sub_12222(
          (__int64)v29,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/common.c",
          323LL);
        goto LABEL_64;
      }
      n = 0LL;
      src = string;
    }
    s = *(char **)(v27 + 16);
  }
  if ( !v17 && a10 )
  {
    for ( j = 0; j < *a10 && *((_QWORD *)*a9 + j) != *(_QWORD *)(v27 + 176); ++j )
      ;
    if ( j == *a10 )
    {
      *a8 = sub_C422(*a8, 8LL * ++*a10);
      if ( !*a8 )
      {
        sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml_subexp", v11);
        goto LABEL_64;
      }
      *a9 = sub_C422(*a9, 8LL * *a10);
      if ( !*a9 )
      {
        sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml_subexp", v12);
        goto LABEL_64;
      }
      *((_QWORD *)*a8 + *a10 - 1) = *(_QWORD *)(v27 + 16);
      *((_QWORD *)*a9 + *a10 - 1) = *(_QWORD *)(v27 + 176);
    }
  }
  v13 = *v18;
  v14 = strlen(s);
  *v18 = v13 + v14 - n + 1;
  *v20 = sub_C422(*v20, *v18);
  if ( *v20 )
  {
    strcpy((char *)*v20 + *v19, s);
    v16 = *v19;
    *v19 = v16 + strlen(s);
    if ( !n )
      *((_BYTE *)*v20 + (*v19)++) = 58;
    strncpy((char *)*v20 + *v19, src, *(unsigned __int16 *)(2LL * i + v30[2]) - n);
    *v19 += *(unsigned __int16 *)(2LL * i + v30[2]) - n;
    goto LABEL_61;
  }
  sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml_subexp", v15);
LABEL_64:
  if ( !v17 )
  {
    if ( a10 )
    {
      free(*a8);
      free(*a9);
    }
  }
  sub_C488D((__int64)v30);
  return 1LL;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000008F60) ----------------------------------------------------
__int64 __fastcall sub_8F60(__int64 *a1, const char *a2, int a3, int a4, void **a5, void **a6, unsigned int *a7)
{
  __int64 result; // rax
  __int64 v8; // r9
  void **v9; // [rsp+8h] [rbp-58h]
  void **v10; // [rsp+10h] [rbp-50h]
  int v11; // [rsp+18h] [rbp-48h]
  int v12; // [rsp+1Ch] [rbp-44h]
  void *ptr; // [rsp+40h] [rbp-20h]
  size_t size; // [rsp+48h] [rbp-18h]
  __int64 v15; // [rsp+50h] [rbp-10h]
  unsigned __int64 v16; // [rsp+58h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v16 = __readfsqword(0x28u);
  if ( !a1 || !a2 || (a5 || a6 || a7) && (!a5 || !a6 || !a7) )
    __assert_fail(
      "module && expr && ((!prefixes && !namespaces && !ns_count) || (prefixes && namespaces && ns_count))",
      "/home/mantovan/Repositories/libyang/src/common.c",
      0x1ADu,
      "_transform_json2xml");
  if ( a7 )
  {
    *a7 = 0;
    *a5 = 0LL;
    *a6 = 0LL;
  }
  if ( !*a2 )
    return lydict_insert(*a1, a2, 0LL);
  size = strlen(a2) + 1;
  ptr = malloc(size);
  if ( ptr )
  {
    v15 = 0LL;
    if ( (unsigned int)sub_83E9(a1, a2, &ptr, &v15, &size, v12, v11, v10, v9, a7) )
    {
      free(ptr);
      result = 0LL;
    }
    else
    {
      *((_BYTE *)ptr + v15) = 0;
      result = lydict_insert_zc(*a1, ptr);
    }
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml", v8, a7);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000000912E) ----------------------------------------------------
__int64 __fastcall sub_912E(__int64 *a1, const char *a2, int a3, void **a4, void **a5, unsigned int *a6)
{
  return sub_8F60(a1, a2, 0, a3, a4, a5, a6);
}

//----- (0000000000009182) ----------------------------------------------------
__int64 __fastcall sub_9182(__int64 *a1, const char *a2)
{
  return sub_8F60(a1, a2, 1, 0, 0LL, 0LL, 0LL);
}

//----- (00000000000091C4) ----------------------------------------------------
signed __int64 __fastcall sub_91C4(__int64 a1, const char *a2, void **a3, __int64 *a4, size_t *a5, char *a6, int a7, int a8)
{
  __int64 v8; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  size_t v13; // rbx
  __int64 v14; // r9
  __int64 v15; // rbx
  __int64 v16; // r9
  char *v17; // [rsp+0h] [rbp-90h]
  size_t *v18; // [rsp+8h] [rbp-88h]
  __int64 *v19; // [rsp+10h] [rbp-80h]
  void **v20; // [rsp+18h] [rbp-78h]
  unsigned __int16 i; // [rsp+32h] [rbp-5Eh]
  int v22; // [rsp+34h] [rbp-5Ch]
  char *src; // [rsp+38h] [rbp-58h]
  char *srca; // [rsp+38h] [rbp-58h]
  __int64 n; // [rsp+40h] [rbp-50h]
  __int64 v26; // [rsp+48h] [rbp-48h]
  __int64 v27; // [rsp+50h] [rbp-40h]
  _QWORD *v28; // [rsp+58h] [rbp-38h]
  char *string; // [rsp+60h] [rbp-30h]
  char *ptr; // [rsp+68h] [rbp-28h]
  __int64 v31; // [rsp+70h] [rbp-20h]
  char *v32; // [rsp+78h] [rbp-18h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v17 = a6;
  v27 = 0LL;
  v28 = sub_CB4D2((void *)a1, a2);
  if ( !v28 )
    return 1LL;
  for ( i = 0; ; ++i )
  {
    if ( i >= *((_WORD *)v28 + 16) )
    {
      sub_C488D((__int64)v28);
      return 0LL;
    }
    string = (char *)(v28[5] + *(unsigned __int16 *)(2LL * i + v28[1]));
    if ( i )
    {
      src = (char *)(v28[5]
                   + *(unsigned __int16 *)(2LL * i - 2 + v28[1])
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + v28[2]));
      if ( src != string )
      {
        strncpy((char *)*v20 + *v19, src, string - src);
        *v19 += string - src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *v28) != 9 )
      break;
    srca = sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v28[2]));
    if ( !srca )
      break;
    n = srca - string;
    ptr = strndup(string, srca - string);
    if ( !ptr )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_xml2json_subexp", v10, v17);
      goto LABEL_40;
    }
    v31 = lyxml_get_ns(v17, ptr);
    free(ptr);
    if ( !v31 )
    {
      sub_13937((void *)a1, 2, 1u, v17, (__int64)"namespace prefix", v11, v17);
      sub_13937((void *)a1, -1, 5u, 0LL, (__int64)"XML namespace with prefix \"%.*s\" not defined.", n, string);
      goto LABEL_40;
    }
    v26 = ly_ctx_get_module_by_ns(a1, *(_QWORD *)(v31 + 32), 0LL, 0LL);
    if ( a8 && *(_QWORD *)(a1 + 112) )
    {
      if ( v26 )
      {
        if ( *(_BYTE *)(v26 + 64) >= 0 )
          v26 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(a1 + 112))(
                  a1,
                  *(_QWORD *)(v26 + 8),
                  *(_QWORD *)(v26 + 176),
                  1LL,
                  *(_QWORD *)(a1 + 120));
      }
      else
      {
        v26 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 112))(
                a1,
                0LL,
                *(_QWORD *)(v31 + 32),
                0LL,
                *(_QWORD *)(a1 + 120));
      }
    }
    if ( !v26 )
    {
      sub_13937((void *)a1, 2, 1u, v17, (__int64)"module namespace", v12, v17);
      sub_13937(
        (void *)a1,
        -1,
        5u,
        0LL,
        (__int64)"Module with the namespace \"%s\" could not be found.",
        *(_QWORD *)(v31 + 32));
      goto LABEL_40;
    }
    if ( a7 && v26 == v27 )
    {
      ++srca;
      ++n;
    }
    else
    {
      v13 = *v18;
      *v18 = v13 + strlen(*(const char **)(v26 + 8)) - n;
      *v20 = sub_C422(*v20, *v18);
      if ( !*v20 )
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_xml2json_subexp", v14, v17);
        goto LABEL_40;
      }
      strcpy((char *)*v20 + *v19, *(const char **)(v26 + 8));
      v15 = *v19;
      *v19 = v15 + strlen(*(const char **)(v26 + 8));
    }
    v27 = v26;
    strncpy((char *)*v20 + *v19, srca, *(unsigned __int16 *)(2LL * i + v28[2]) - n);
    *v19 += *(unsigned __int16 *)(2LL * i + v28[2]) - n;
LABEL_37:
    ;
  }
  if ( *(_DWORD *)(4LL * i + *v28) != 9 || !a7 )
  {
    if ( *(_DWORD *)(4LL * i + *v28) == 17 && sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v28[2])) )
    {
      *((_BYTE *)*v20 + (*v19)++) = *string;
      v32 = (char *)lydict_insert(a1, string + 1, *(unsigned __int16 *)(2LL * i + v28[2]) - 2);
      v22 = *(_DWORD *)__tls_get_addr(&stru_335FC0);
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = 2;
      if ( (unsigned int)sub_91C4(a1, (_DWORD)v32, (_DWORD)v20) )
      {
        strncpy((char *)*v20 + *v19, v32, *(unsigned __int16 *)(2LL * i + v28[2]) - 2);
        *v19 += *(unsigned __int16 *)(2LL * i + v28[2]) - 2;
      }
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = v22;
      lydict_remove(a1, v32);
      *((_BYTE *)*v20 + (*v19)++) = string[*(unsigned __int16 *)(2LL * i + v28[2]) - 1];
    }
    else
    {
      strncpy(
        (char *)*v20 + *v19,
        (const char *)(v28[5] + *(unsigned __int16 *)(2LL * i + v28[1])),
        *(unsigned __int16 *)(2LL * i + v28[2]));
      *v19 += *(unsigned __int16 *)(2LL * i + v28[2]);
    }
    goto LABEL_37;
  }
  sub_13937((void *)a1, 2, 1u, v17, (__int64)"namespace prefix", v8, v17);
  sub_13937((void *)a1, -1, 5u, 0LL, (__int64)"Node name is missing module prefix.", v16);
LABEL_40:
  sub_C488D((__int64)v28);
  return 1LL;
}
// 7400: using guessed type __int64 __fastcall ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD);
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 7890: using guessed type __int64 __fastcall lyxml_get_ns(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (0000000000009A10) ----------------------------------------------------
__int64 __fastcall sub_9A10(__int64 a1, const char *a2, char *a3, unsigned int a4, unsigned int a5)
{
  __int64 v5; // r9
  __int64 result; // rax
  unsigned __int64 v7; // [rsp+0h] [rbp-50h]
  char *v8; // [rsp+8h] [rbp-48h]
  void *ptr; // [rsp+30h] [rbp-20h]
  size_t size; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = __PAIR__(a4, a5);
  v12 = __readfsqword(0x28u);
  size = strlen(a2) + 1;
  ptr = malloc(size);
  if ( ptr )
  {
    v11 = 0LL;
    if ( (unsigned int)sub_91C4(a1, a2, &ptr, &v11, &size, v8, SHIDWORD(v7), v7) )
    {
      free(ptr);
      result = 0LL;
    }
    else
    {
      *((_BYTE *)ptr + v11) = 0;
      result = lydict_insert_zc(a1, ptr);
    }
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_xml2json", v5, v7, v8, a2);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (0000000000009B1E) ----------------------------------------------------
char *__fastcall ly_path_xml2json(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  char *result; // rax
  char *v8; // [rsp+8h] [rbp-28h]
  char *v9; // [rsp+20h] [rbp-10h]
  char *s; // [rsp+28h] [rbp-8h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_path_xml2json", a4, a5, a6);
  v9 = 0LL;
  if ( a1 && a2 && v8 )
  {
    s = (char *)sub_9A10(a1, a2, v8, 0, 1u);
    if ( s )
    {
      v9 = strdup(s);
      lydict_remove(a1, s);
    }
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_path_xml2json", v6);
    result = 0LL;
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000009BED) ----------------------------------------------------
__int64 __fastcall sub_9BED(__int64 *a1, const char *a2)
{
  __int64 v2; // r9
  __int64 result; // rax
  __int64 v4; // r9
  size_t v5; // ST38_8
  __int64 v6; // r9
  signed __int64 v7; // ST38_8
  size_t v8; // ST38_8
  unsigned __int16 i; // [rsp+1Eh] [rbp-52h]
  const char *j; // [rsp+20h] [rbp-50h]
  __int128 ptr; // [rsp+28h] [rbp-48h]
  char *v12; // [rsp+38h] [rbp-38h]
  void *v13; // [rsp+40h] [rbp-30h]
  _QWORD *v14; // [rsp+48h] [rbp-28h]
  char *v15; // [rsp+50h] [rbp-20h]
  char *src; // [rsp+58h] [rbp-18h]
  char *srca; // [rsp+58h] [rbp-18h]
  char *srcb; // [rsp+58h] [rbp-18h]
  __int64 v19; // [rsp+60h] [rbp-10h]
  __int64 v20; // [rsp+68h] [rbp-8h]
  __int64 v21; // [rsp+68h] [rbp-8h]

  v13 = (void *)*a1;
  *((_QWORD *)&ptr + 1) = strlen(a2) + 1;
  *(_QWORD *)&ptr = malloc(*((size_t *)&ptr + 1));
  if ( (_QWORD)ptr )
  {
    v12 = 0LL;
    v14 = sub_CB4D2(v13, a2);
    if ( v14 )
    {
      for ( i = 0; i < *((_WORD *)v14 + 16); ++i )
      {
        v15 = (char *)(v14[5] + *(unsigned __int16 *)(2LL * i + v14[1]));
        if ( i )
        {
          src = (char *)(v14[5]
                       + *(unsigned __int16 *)(2LL * i - 2 + v14[1])
                       + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + v14[2]));
          if ( src != v15 )
          {
            strncpy(&v12[ptr], src, v15 - src);
            v12 += v15 - src;
          }
        }
        if ( *(_DWORD *)(4LL * i + *v14) == 9
          && (srca = sub_811F(v15, 58, *(unsigned __int16 *)(2LL * i + v14[2]))) != 0LL )
        {
          v19 = srca - v15;
          v20 = sub_407F3(a1, v15, (signed int)srca - (signed int)v15, 0LL, 0, 0);
          if ( !v20 )
          {
            sub_13937(v13, 29, 0, 0LL, v19, (__int64)v15, a2);
            goto LABEL_32;
          }
          *((_QWORD *)&ptr + 1) += strlen(*(const char **)(v20 + 8)) - v19;
          *(_QWORD *)&ptr = sub_C422((void *)ptr, *((size_t *)&ptr + 1));
          if ( !(_QWORD)ptr )
          {
            sub_12222((__int64)v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_schema2json", v4, a2);
            goto LABEL_32;
          }
          strcpy(&v12[ptr], *(const char **)(v20 + 8));
          v5 = (size_t)&v12[strlen(*(const char **)(v20 + 8))];
          strncpy((char *)(v5 + ptr), srca, *(unsigned __int16 *)(2LL * i + v14[2]) - v19);
          v12 = (char *)(*(unsigned __int16 *)(2LL * i + v14[2]) - v19 + v5);
        }
        else if ( *(_DWORD *)(4LL * i + *v14) == 17
               && (srcb = sub_811F(v15, 58, *(unsigned __int16 *)(2LL * i + v14[2]))) != 0LL )
        {
          for ( j = srcb; (*__ctype_b_loc())[*(j - 1)] & 8 || *(j - 1) == 95 || *(j - 1) == 45 || *(j - 1) == 46; --j )
            ;
          v21 = sub_407F3(a1, j, (signed int)srcb - (signed int)j, 0LL, 0, 0);
          if ( v21 )
          {
            *((_QWORD *)&ptr + 1) += strlen(*(const char **)(v21 + 8)) - (srcb - j);
            *(_QWORD *)&ptr = sub_C422((void *)ptr, *((size_t *)&ptr + 1));
            if ( !(_QWORD)ptr )
            {
              sub_12222(
                (__int64)v13,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"transform_schema2json",
                v6,
                a2);
              goto LABEL_32;
            }
            strncpy(&v12[ptr], v15, j - v15);
            v7 = (signed __int64)&v12[j - v15];
            strcpy((char *)(ptr + v7), *(const char **)(v21 + 8));
            v8 = strlen(*(const char **)(v21 + 8)) + v7;
            strncpy((char *)(v8 + ptr), srcb, (size_t)&v15[*(unsigned __int16 *)(2LL * i + v14[2]) - (_QWORD)srcb]);
            v12 = &v15[*(unsigned __int16 *)(2LL * i + v14[2]) - (_QWORD)srcb + v8];
          }
          else
          {
            strncpy(
              &v12[ptr],
              (const char *)(v14[5] + *(unsigned __int16 *)(2LL * i + v14[1])),
              *(unsigned __int16 *)(2LL * i + v14[2]));
            v12 += *(unsigned __int16 *)(2LL * i + v14[2]);
          }
        }
        else
        {
          strncpy(
            &v12[ptr],
            (const char *)(v14[5] + *(unsigned __int16 *)(2LL * i + v14[1])),
            *(unsigned __int16 *)(2LL * i + v14[2]));
          v12 += *(unsigned __int16 *)(2LL * i + v14[2]);
        }
      }
      v12[ptr] = 0;
      sub_C488D((__int64)v14);
      result = lydict_insert_zc(*a1, ptr);
    }
    else
    {
LABEL_32:
      free((void *)ptr);
      sub_C488D((__int64)v14);
      result = 0LL;
    }
  }
  else
  {
    sub_12222((__int64)v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_schema2json", v2, a2);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000000A2CB) ----------------------------------------------------
__int64 __fastcall sub_A2CB(__int64 *a1, const char *a2)
{
  __int64 v2; // r9
  __int64 result; // rax
  char *i; // rax
  __int64 v5; // r9
  signed __int64 v6; // ST40_8
  size_t v7; // ST40_8
  char *s; // [rsp+10h] [rbp-50h]
  char *v9; // [rsp+18h] [rbp-48h]
  __int128 ptr; // [rsp+20h] [rbp-40h]
  signed __int64 v11; // [rsp+30h] [rbp-30h]
  void *v12; // [rsp+38h] [rbp-28h]
  char *v13; // [rsp+40h] [rbp-20h]
  __int64 v14; // [rsp+48h] [rbp-18h]
  unsigned __int64 v15; // [rsp+50h] [rbp-10h]
  __int64 v16; // [rsp+58h] [rbp-8h]

  v12 = (void *)*a1;
  s = (char *)a2;
  *((_QWORD *)&ptr + 1) = strlen(a2) + 1;
  *(_QWORD *)&ptr = malloc(*((size_t *)&ptr + 1));
  if ( (_QWORD)ptr )
  {
    v11 = 0LL;
    for ( i = strchr(a2, 58); ; i = strchr(v13 + 1, 58) )
    {
      v13 = i;
      if ( !i )
        break;
      v9 = sub_80BC(i - 1, &unk_107E6B, (signed int)i - (signed int)s - 1);
      if ( *v9 == 32 || *v9 == 12 || *v9 == 10 || *v9 == 13 || *v9 == 9 || *v9 == 11 || *v9 == 40 )
        ++v9;
      v14 = v13 - v9;
      v15 = (unsigned int)sub_16564(v9);
      if ( v15 < v13 - v9 )
      {
        sub_13937(v12, 55, 0, 0LL, (unsigned int)v9[v15], (__int64)&v9[v15], a2, a1);
        free((void *)ptr);
        return 0LL;
      }
      v16 = sub_407F3(a1, v9, v14, 0LL, 0, 0);
      if ( !v16 )
      {
        sub_13937(v12, -1, 0, 0LL, (__int64)"Module prefix \"%.*s\" is unknown.", v14, v9);
        free((void *)ptr);
        return 0LL;
      }
      *((_QWORD *)&ptr + 1) += strlen(*(const char **)(v16 + 8)) - v14;
      *(_QWORD *)&ptr = sub_C422((void *)ptr, *((size_t *)&ptr + 1));
      if ( !(_QWORD)ptr )
      {
        sub_12222(
          (__int64)v12,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"transform_iffeat_schema2json",
          v5,
          a2);
        return 0LL;
      }
      strncpy((char *)(ptr + v11), s, v9 - s);
      v6 = v9 - s + v11;
      strcpy((char *)(ptr + v6), *(const char **)(v16 + 8));
      v7 = strlen(*(const char **)(v16 + 8)) + v6;
      *(_BYTE *)(ptr + v7) = 58;
      v11 = v7 + 1;
      s = v13 + 1;
    }
    strcpy((char *)(v11 + ptr), s);
    if ( *((_QWORD *)&ptr + 1) != strlen(s) + v11 + 1 )
      __assert_fail(
        "out_size == out_used",
        "/home/mantovan/Repositories/libyang/src/common.c",
        0x2F1u,
        "transform_iffeat_schema2json");
    result = lydict_insert_zc(v12, ptr);
  }
  else
  {
    sub_12222(
      (__int64)v12,
      0,
      1,
      "Memory allocation failed (%s()).",
      (__int64)"transform_iffeat_schema2json",
      v2,
      a2,
      a1);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000000A671) ----------------------------------------------------
signed __int64 __fastcall sub_A671(void **a1, __int64 a2, __int64 a3, _DWORD *a4, int a5, void **a6, __int64 *a7, size_t *a8)
{
  __int64 v9; // r8
  __int64 v10; // r9
  char *ptr; // ST70_8
  __int64 v12; // rax
  size_t v13; // rbx
  __int64 v14; // r9
  __int64 v15; // rbx
  char *v16; // ST70_8
  size_t v17; // rbx
  __int64 v18; // r9
  __int64 v19; // rbx
  void **v20; // [rsp+0h] [rbp-80h]
  int v21; // [rsp+Ch] [rbp-74h]
  _DWORD *v22; // [rsp+10h] [rbp-70h]
  __int64 v23; // [rsp+18h] [rbp-68h]
  __int64 v24; // [rsp+20h] [rbp-60h]
  char *src; // [rsp+38h] [rbp-48h]
  char *srca; // [rsp+38h] [rbp-48h]
  char *srcb; // [rsp+38h] [rbp-48h]
  char *srcc; // [rsp+38h] [rbp-48h]
  char *i; // [rsp+40h] [rbp-40h]
  size_t n; // [rsp+48h] [rbp-38h]
  size_t na; // [rsp+48h] [rbp-38h]
  void *v32; // [rsp+50h] [rbp-30h]
  char *string; // [rsp+58h] [rbp-28h]
  __int64 v34; // [rsp+68h] [rbp-18h]

  v24 = a2;
  v23 = a3;
  v22 = a4;
  v21 = a5;
  v20 = a6;
  v32 = *a1;
  while ( 1 )
  {
    if ( *v22 >= (unsigned int)*(unsigned __int16 *)(v23 + 32) )
      return 0LL;
    if ( v21 == *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) )
      return 0LL;
    string = (char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22));
    if ( *v22 )
    {
      src = (char *)(*(_QWORD *)(v23 + 40)
                   + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)(*v22 - 1))
                   + (unsigned __int64)*(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)(*v22 - 1)));
      if ( src != string )
      {
        strncpy((char *)*v20 + *a7, src, string - src);
        *a7 += string - src;
      }
    }
    if ( *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) == 3 )
    {
      strncpy(
        (char *)*v20 + *a7,
        (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
        *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
      *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)(*v22)++);
      if ( (unsigned int)sub_A671((__int64)a1, v24) )
        return 0xFFFFFFFFLL;
      if ( *v22 >= (unsigned int)*(unsigned __int16 *)(v23 + 32) )
      {
        sub_13937(v32, 68, 0, 0LL, v9, v10, v20);
        return 0xFFFFFFFFLL;
      }
      strncpy(
        (char *)*v20 + *a7,
        (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
        *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
      *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
      goto LABEL_45;
    }
    if ( *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) == 9 )
      break;
    if ( *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) == 17
      && (srcc = sub_811F(string, 58, *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22))) != 0LL )
    {
      for ( i = srcc; (*__ctype_b_loc())[*(i - 1)] & 8 || *(i - 1) == 95 || *(i - 1) == 45 || *(i - 1) == 46; --i )
        ;
      v16 = strndup(i, srcc - i);
      v34 = ly_ctx_get_module(v32, v16, 0LL, 1LL);
      free(v16);
      if ( v34 && (void **)v34 != a1 )
      {
        v17 = *a8;
        *a8 = v17 + strlen(*(const char **)(v34 + 8)) - (srcc - i);
        *v20 = sub_C422(*v20, *a8);
        if ( !*v20 )
        {
          sub_12222(
            (__int64)v32,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"transform_json2xpath_subexpr",
            v18,
            v20);
          return 0xFFFFFFFFLL;
        }
        strncpy((char *)*v20 + *a7, string, i - string);
        *a7 += i - string;
        strcpy((char *)*v20 + *a7, *(const char **)(v34 + 8));
        v19 = *a7;
        *a7 = v19 + strlen(*(const char **)(v34 + 8));
        strncpy(
          (char *)*v20 + *a7,
          srcc,
          (size_t)&string[*(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - (_QWORD)srcc]);
        *a7 += (__int64)&string[*(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - (_QWORD)srcc];
      }
      else
      {
        strncpy(
          (char *)*v20 + *a7,
          (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
          *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
        *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
      }
    }
    else
    {
      strncpy(
        (char *)*v20 + *a7,
        (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
        *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
      *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
    }
LABEL_45:
    ++*v22;
  }
  srca = sub_811F(string, 58, *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
  if ( !srca )
  {
    srcb = string;
    na = 0LL;
    goto LABEL_22;
  }
  n = srca - string;
  ptr = strndup(string, srca - string);
  v24 = ly_ctx_get_module(v32, ptr, 0LL, 1LL);
  free(ptr);
  if ( v24 )
  {
    srcb = srca + 1;
    na = n + 1;
LABEL_22:
    if ( (void **)v24 != a1 && *srcb != 42 || na && *srcb == 42 )
    {
      v13 = *a8;
      *a8 = v13 + strlen(*(const char **)(v24 + 8)) - na + 1;
      *v20 = sub_C422(*v20, *a8);
      if ( !*v20 )
      {
        sub_12222(
          (__int64)v32,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"transform_json2xpath_subexpr",
          v14,
          v20);
        return 0xFFFFFFFFLL;
      }
      strcpy((char *)*v20 + *a7, *(const char **)(v24 + 8));
      v15 = *a7;
      *a7 = v15 + strlen(*(const char **)(v24 + 8));
      *((_BYTE *)*v20 + (*a7)++) = 58;
    }
    strncpy((char *)*v20 + *a7, srcb, *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - na);
    *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - na;
    goto LABEL_45;
  }
  if ( n )
    v12 = srca - string;
  else
    v12 = *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
  sub_13937(v32, 29, 0, 0LL, v12, (__int64)string, v20);
  return 0xFFFFFFFFLL;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000B085) ----------------------------------------------------
void *__fastcall sub_B085(void **a1, const char *a2)
{
  __int64 v2; // r9
  void *result; // rax
  int v4; // [rsp+14h] [rbp-2Ch]
  void *ptr; // [rsp+18h] [rbp-28h]
  size_t size; // [rsp+20h] [rbp-20h]
  __int64 v7; // [rsp+28h] [rbp-18h]
  _QWORD *v8; // [rsp+30h] [rbp-10h]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  if ( !a1 || !a2 )
    __assert_fail(
      "cur_module && expr",
      "/home/mantovan/Repositories/libyang/src/common.c",
      0x3A7u,
      "transform_json2xpath");
  size = strlen(a2) + 1;
  ptr = malloc(size);
  if ( ptr )
  {
    v7 = 0LL;
    v8 = sub_CB4D2(*a1, a2);
    if ( v8 )
    {
      v4 = 0;
      if ( (unsigned int)sub_A671(a1, (__int64)a1, (__int64)v8, &v4, 0, &ptr, &v7, &size) )
      {
        free(ptr);
        sub_C488D((__int64)v8);
        result = 0LL;
      }
      else
      {
        *((_BYTE *)ptr + v7) = 0;
        sub_C488D((__int64)v8);
        result = ptr;
      }
    }
    else
    {
      free(ptr);
      result = 0LL;
    }
  }
  else
  {
    sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_json2xpath", v2, a2);
    result = 0LL;
  }
  return result;
}

//----- (000000000000B202) ----------------------------------------------------
signed __int64 __fastcall sub_B202(__int64 a1, _QWORD *a2, unsigned __int16 a3, void **a4, _WORD *a5)
{
  __int64 v5; // r9
  signed __int64 result; // rax
  _WORD *v7; // [rsp+8h] [rbp-38h]
  void **v8; // [rsp+10h] [rbp-30h]
  unsigned __int16 v9; // [rsp+1Ch] [rbp-24h]
  unsigned __int16 i; // [rsp+3Eh] [rbp-2h]

  v8 = a4;
  v7 = a5;
  v9 = a3;
  for ( i = *(_WORD *)(2LL * a3 + a2[2]);
        (*__ctype_b_loc())[*(char *)(a2[5] + *(unsigned __int16 *)(2LL * v9 + a2[1]) + i)] & 0x2000;
        ++i )
  {
    ;
  }
  *v8 = sub_C422(*v8, (unsigned __int16)*v7 + i);
  if ( *v8 )
  {
    sprintf((char *)*v8 + (unsigned __int16)*v7 - 1, "%.*s", i, a2[5] + *(unsigned __int16 *)(2LL * v9 + a2[1]));
    *v7 += i;
    result = 0LL;
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema_copy_token", v5);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000000B369) ----------------------------------------------------
signed __int64 __fastcall sub_B369(void *a1, const char **a2, __int64 a3, _QWORD *a4, unsigned __int16 *a5, void **a6, _WORD *a7)
{
  int v7; // eax
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 i; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  const char *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rax
  int v21; // ebx
  __int64 v22; // r9
  const char *v23; // rbx
  __int64 v24; // rdx
  const char *v25; // rax
  __int64 v26; // r9
  const char *v27; // rax
  char *v28; // rax
  __int64 v29; // r9
  void **v31; // [rsp+0h] [rbp-80h]
  unsigned __int16 *v32; // [rsp+8h] [rbp-78h]
  _QWORD *v33; // [rsp+10h] [rbp-70h]
  __int64 v34; // [rsp+18h] [rbp-68h]
  __int16 v35; // [rsp+34h] [rbp-4Ch]
  __int16 v36; // [rsp+36h] [rbp-4Ah]
  unsigned __int16 v37; // [rsp+38h] [rbp-48h]
  unsigned __int16 v38; // [rsp+38h] [rbp-48h]
  unsigned __int16 j; // [rsp+38h] [rbp-48h]
  unsigned __int16 v40; // [rsp+3Ah] [rbp-46h]
  signed int v41; // [rsp+3Ch] [rbp-44h]
  _BOOL4 v42; // [rsp+40h] [rbp-40h]
  signed int v43; // [rsp+44h] [rbp-3Ch]
  char *s; // [rsp+48h] [rbp-38h]
  char *s2; // [rsp+50h] [rbp-30h]
  const char **v46; // [rsp+58h] [rbp-28h]
  __int64 v47; // [rsp+60h] [rbp-20h]
  const char **v48; // [rsp+60h] [rbp-20h]
  const char **v49; // [rsp+68h] [rbp-18h]

  v34 = a3;
  v33 = a4;
  v32 = a5;
  v31 = a6;
  s = 0LL;
  v41 = 0;
  v7 = *(_DWORD *)(*a4 + 4LL * *a5);
  switch ( v7 )
  {
    case 3:
      v41 = 4;
      if ( (unsigned int)sub_B202((__int64)a1, a4, *a5, a6, a7) )
        goto LABEL_108;
      ++*v32;
      v42 = 0;
      break;
    case 16:
      v42 = a2 == 0LL;
      break;
    case 1:
      v41 = 2;
      if ( (unsigned int)sub_B202((__int64)a1, a4, *a5, a6, a7) )
        goto LABEL_108;
      ++*v32;
      v42 = 0;
      break;
    default:
      v42 = 1;
      break;
  }
  v43 = 0;
  v49 = a2;
  while ( 2 )
  {
    if ( *v32 >= *((_WORD *)v33 + 16) )
    {
      if ( !v41 )
        return 0LL;
      sub_13937(a1, 68, 0, 0LL, (__int64)a5, (__int64)a6, v31);
      return 0xFFFFFFFFLL;
    }
    switch ( *(_DWORD *)(*v33 + 4LL * *v32) )
    {
      case 1:
      case 3:
        if ( (unsigned int)sub_B369((__int64)a1) )
          goto LABEL_108;
        goto LABEL_103;
      case 5:
      case 6:
      case 9:
        if ( v43 )
        {
          if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
            goto LABEL_108;
          goto LABEL_103;
        }
        s = strndup(
              (const char *)(v33[5] + *(unsigned __int16 *)(v33[1] + 2LL * *v32)),
              *(unsigned __int16 *)(v33[2] + 2LL * *v32));
        if ( !s )
        {
          sub_12222(
            (__int64)a1,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"ly_path_data2schema_subexp",
            v8,
            v31);
          goto LABEL_108;
        }
        s2 = strchr(s, 58);
        if ( s2 )
          *s2++ = 0;
        if ( v42 )
        {
          if ( !s2 )
          {
            sub_13937(a1, 80, 0, 0LL, v9, v10, v31);
            goto LABEL_108;
          }
          v34 = ly_ctx_get_module(a1, s, 0LL, 0LL);
          if ( !v34 )
          {
            sub_13937(a1, 79, 4u, s, v11, v12, v31);
            goto LABEL_108;
          }
          v42 = 0;
        }
        if ( s2 )
        {
          if ( *s2 == 46 )
            goto LABEL_33;
        }
        else if ( *s == 46 )
        {
          goto LABEL_33;
        }
        if ( s2 )
        {
          if ( *s2 == 42 )
            goto LABEL_33;
        }
        else if ( *s == 42 )
        {
LABEL_33:
          free(s);
          s = 0LL;
          if ( v41 )
          {
            sub_12222((__int64)a1, 0, 3, "Invalid path used (%s in a subexpression).", 0LL, v13, v31);
            goto LABEL_108;
          }
          v43 = 1;
          if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
            goto LABEL_108;
          goto LABEL_103;
        }
        for ( i = lys_getnext(0LL, v49, v34, 256LL); ; i = lys_getnext(v46, v49, v34, 256LL) )
        {
          v46 = (const char **)i;
          if ( !i )
            break;
          if ( s2 )
            v17 = s2;
          else
            v17 = s;
          if ( !strcmp(*v46, v17) )
          {
            if ( !s2 || (v18 = lys_node_module(v46), !strcmp(*(const char **)(v18 + 8), s)) )
            {
              if ( s2 || (v19 = lys_node_module(v46), v19 == lys_node_module(v49)) )
              {
                v35 = 0;
                v47 = (__int64)v46;
                while ( (const char **)v47 != v49 )
                {
                  v47 = lys_parent(v47);
                  if ( !v47 || *(_DWORD *)(v47 + 56) != 4096 )
                    ++v35;
                }
                v40 = 0;
                while ( 1 )
                {
                  if ( !v35 )
                    goto LABEL_77;
                  v36 = v35 - 1;
                  v48 = v46;
                  while ( v36 )
                  {
                    v48 = (const char **)lys_parent(v48);
                    if ( !v48 )
                      __assert_fail(
                        "node2",
                        "/home/mantovan/Repositories/libyang/src/common.c",
                        0x44Bu,
                        "ly_path_data2schema_subexp");
                    if ( *((_DWORD *)v48 + 14) != 4096 )
                      --v36;
                  }
                  if ( v34 == lys_node_module(v48) && v49 )
                  {
                    v38 = strlen(*v48) + v40;
                    *v31 = sub_C422(*v31, (unsigned __int16)*a7 + v38);
                    if ( !*v31 )
                    {
                      sub_12222(
                        (__int64)a1,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"ly_path_data2schema_subexp",
                        v26,
                        v31);
                      goto LABEL_108;
                    }
                    if ( v40 )
                      v27 = "/";
                    else
                      v27 = (const char *)&unk_107EEB;
                    sprintf((char *)*v31 + (unsigned __int16)*a7 - 1, "%s%s", v27, *v48);
                    *a7 += v38;
                  }
                  else
                  {
                    v20 = lys_node_module(v48);
                    v21 = strlen(*(const char **)(v20 + 8)) + v40;
                    v37 = v21 + strlen(*v48) + 1;
                    *v31 = sub_C422(*v31, (unsigned __int16)*a7 + v37);
                    if ( !*v31 )
                    {
                      sub_12222(
                        (__int64)a1,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"ly_path_data2schema_subexp",
                        v22,
                        v31);
                      goto LABEL_108;
                    }
                    v23 = *v48;
                    v24 = *(_QWORD *)(lys_node_module(v48) + 8);
                    if ( v40 )
                      v25 = "/";
                    else
                      v25 = (const char *)&unk_107EEB;
                    sprintf((char *)*v31 + (unsigned __int16)*a7 - 1, "%s%s:%s", v25, v24, v23);
                    *a7 += v37;
                  }
                  v40 = 1;
                  --v35;
                }
              }
            }
          }
        }
LABEL_77:
        if ( v46 )
        {
          for ( j = 0;
                (*__ctype_b_loc())[*(char *)(v33[5]
                                           + *(unsigned __int16 *)(v33[2] + 2LL * *v32)
                                           + *(unsigned __int16 *)(v33[1] + 2LL * *v32)
                                           + j)] & 0x2000;
                ++j )
          {
            ;
          }
          if ( j )
          {
            *v31 = sub_C422(*v31, (unsigned __int16)*a7 + j);
            if ( !*v31 )
            {
              sub_12222(
                (__int64)a1,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"ly_path_data2schema_subexp",
                v29,
                v31);
              goto LABEL_108;
            }
            sprintf((char *)*v31 + (unsigned __int16)*a7 - 1, "%*s", j, " ");
            *a7 += j;
          }
          free(s);
          s = 0LL;
          v49 = v46;
LABEL_103:
          ++*v32;
          continue;
        }
        if ( s2 )
          v28 = s2;
        else
          v28 = s;
        sub_13937(a1, 81, 4u, v28, v15, v16, v31);
LABEL_108:
        free(s);
        return 0xFFFFFFFFLL;
      case 8:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
        v42 = 1;
        v43 = 0;
        v49 = a2;
        goto LABEL_91;
      case 0xA:
      case 0xB:
      case 0x11:
      case 0x12:
        goto LABEL_94;
      case 0x10:
LABEL_91:
        if ( *(_DWORD *)(*v33 + 4LL * *v32) == 16 && *(_WORD *)(v33[2] + 2LL * *v32) == 2 )
          v43 = 1;
LABEL_94:
        if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
          goto LABEL_108;
        goto LABEL_103;
      default:
        if ( !v41 || v41 != *(_DWORD *)(*v33 + 4LL * *v32) )
        {
          sub_12222(
            (__int64)a1,
            0,
            3,
            "Invalid token used (%.*s).",
            *(unsigned __int16 *)(v33[2] + 2LL * *v32),
            v33[5] + *(unsigned __int16 *)(v33[1] + 2LL * *v32),
            v31);
          goto LABEL_108;
        }
        if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
          goto LABEL_108;
        return 0LL;
    }
  }
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000000BE5A) ----------------------------------------------------
void *__fastcall ly_path_data2schema(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  char *string; // [rsp+0h] [rbp-70h]
  unsigned __int16 v18; // [rsp+1Ch] [rbp-54h]
  __int16 v19; // [rsp+1Eh] [rbp-52h]
  int v20; // [rsp+20h] [rbp-50h]
  int v21; // [rsp+24h] [rbp-4Ch]
  int v22; // [rsp+28h] [rbp-48h]
  int v23; // [rsp+2Ch] [rbp-44h]
  void *dest; // [rsp+30h] [rbp-40h]
  char *v25; // [rsp+38h] [rbp-38h]
  const char *v26; // [rsp+40h] [rbp-30h]
  __int64 v27; // [rsp+48h] [rbp-28h]
  const char **v28; // [rsp+50h] [rbp-20h]
  void *ptr; // [rsp+58h] [rbp-18h]
  _QWORD *v30; // [rsp+60h] [rbp-10h]
  unsigned __int64 v31; // [rsp+68h] [rbp-8h]

  v31 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_path_data2schema", a4, a5, a6, a2);
  v19 = 0;
  v22 = -1;
  v27 = 0LL;
  v28 = 0LL;
  if ( !a1 || !string )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_path_data2schema", v6);
    return 0LL;
  }
  v23 = sub_17847(string, &v25, (unsigned int *)&v20, &v26, (unsigned int *)&v21, &v22, 0LL, 0LL, 1);
  if ( v23 <= 0 )
  {
    sub_13937(a1, 78, 0, 0LL, (unsigned int)string[-v23], (__int64)&string[-v23]);
    return 0LL;
  }
  if ( *v26 == 35 )
  {
    if ( v22 )
    {
      sub_13937(a1, 78, 0, 0LL, 35LL, (__int64)v26);
      return 0LL;
    }
    ++v26;
    --v21;
    if ( !v25 )
    {
      ptr = strndup(string, &v26[v21] - string);
      sub_13937(a1, 80, 4u, (char *)ptr, v8, v9);
      free(ptr);
      return 0LL;
    }
    ptr = strndup(v25, v20);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema", v10);
      return 0LL;
    }
    v27 = ly_ctx_get_module(a1, ptr, 0LL, 1LL);
    free(ptr);
    if ( !v27 )
    {
      ptr = strndup(string, &v25[v20] - string);
      sub_13937(a1, 79, 4u, (char *)ptr, v11, v12);
      free(ptr);
      return 0LL;
    }
    v28 = (const char **)sub_40D5F(v27, v26, v21);
    if ( !v28 )
    {
      ptr = strndup(string, &v26[v21] - string);
      sub_13937(a1, 81, 4u, (char *)ptr, v13, v14);
      free(ptr);
      return 0LL;
    }
    v18 = (_WORD)v26 + v21 - (_WORD)string + 1;
    dest = malloc(v18);
    if ( !dest )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema", v15);
      return 0LL;
    }
    memcpy(dest, string, v18 - 1);
    string += v23;
  }
  else
  {
    v18 = 1;
    dest = malloc(1uLL);
    if ( !dest )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema", v16);
      return 0LL;
    }
  }
  v30 = sub_CB4D2(a1, string);
  if ( v30 )
  {
    if ( v28 )
    {
      if ( (unsigned int)sub_B369(a1, v28, v27, v30, (unsigned __int16 *)&v19, &dest, &v18) )
      {
        free(dest);
        dest = 0LL;
      }
    }
    else if ( (unsigned int)sub_B369(a1, 0LL, 0LL, v30, (unsigned __int16 *)&v19, &dest, &v18) )
    {
      free(dest);
      dest = 0LL;
    }
    sub_C488D((__int64)v30);
    result = dest;
  }
  else
  {
    free(dest);
    result = 0LL;
  }
  return result;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (000000000000C3AB) ----------------------------------------------------
__int64 __fastcall sub_C3AB(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-4h]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 56) & 0xC && *(_DWORD *)(a1 + 128) == 9 )
    v2 = 8;
  if ( *(_DWORD *)(a1 + 56) & 0x18 )
    v2 |= 1u;
  if ( *(_DWORD *)(a1 + 56) == 16 && *(_BYTE *)(a1 + 31) )
    v2 |= 2u;
  if ( *(_DWORD *)(a1 + 56) & 0xC1BD )
    v2 |= 4u;
  return v2;
}

//----- (000000000000C422) ----------------------------------------------------
void *__fastcall sub_C422(void *a1, size_t a2)
{
  void *v3; // [rsp+18h] [rbp-8h]

  v3 = realloc(a1, a2);
  if ( !v3 )
    free(a1);
  return v3;
}

//----- (000000000000C462) ----------------------------------------------------
signed __int64 __fastcall sub_C462(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v3; // [rsp+0h] [rbp-10h]
  _BYTE *v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 1LL;
  if ( !a1 || !a2 )
    return 0LL;
  while ( *v4 == *v3 )
  {
    if ( !*v4 )
      return 1LL;
    ++v4;
    ++v3;
  }
  return 0LL;
}

//----- (000000000000C4C9) ----------------------------------------------------
signed __int64 __fastcall sub_C4C9(unsigned __int8 a1)
{
  unsigned __int8 i; // [rsp+Bh] [rbp-9h]
  signed __int64 v3; // [rsp+Ch] [rbp-8h]

  v3 = 1LL;
  for ( i = 0; i < a1; ++i )
    v3 *= 10LL;
  return v3;
}

//----- (000000000000C508) ----------------------------------------------------
signed __int64 __fastcall sub_C508(signed __int64 a1, unsigned __int8 a2, signed __int64 a3, unsigned __int8 a4)
{
  signed __int64 v5; // [rsp+0h] [rbp-18h]
  signed __int64 v6; // [rsp+10h] [rbp-8h]

  v6 = a1;
  v5 = a3;
  if ( a2 >= a4 )
  {
    if ( a2 > a4 )
      v6 = a1 / sub_C4C9(a2 - a4);
  }
  else
  {
    v5 = a3 / sub_C4C9(a4 - a2);
  }
  if ( v6 == v5 )
    return 0LL;
  if ( v6 <= v5 )
    return 0xFFFFFFFFLL;
  return 1LL;
}

//----- (000000000000C5A1) ----------------------------------------------------
__int64 __fastcall sub_C5A1(const char **a1, unsigned __int8 a2)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rax
  unsigned int v5; // ST24_4
  unsigned __int64 v6; // rax
  unsigned __int8 v7; // [rsp+1Fh] [rbp-21h]
  int v8; // [rsp+20h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-1Ch]
  __int64 v10; // [rsp+28h] [rbp-18h]

  if ( a2 <= 3u && *((_BYTE *)a1 + a2 + 104) )
    return *((unsigned __int8 *)a1 + a2 + 104);
  v3 = lys_node_module(a1);
  v10 = v3;
  v4 = strlen(*(const char **)(v3 + 8));
  v5 = sub_1476E(0, *(_QWORD *)(v10 + 8), v4);
  v6 = strlen(*a1);
  v9 = sub_1476E(v5, (__int64)*a1, v6);
  if ( a2 )
  {
    if ( a2 <= strlen(*(const char **)(v10 + 8)) )
      v8 = a2;
    else
      v8 = strlen(*(const char **)(v10 + 8));
    v9 = sub_1476E(v9, *(_QWORD *)(v10 + 8), v8);
  }
  v7 = (128 >> a2) | (127 >> a2) & (unsigned __int64)sub_1476E(v9, 0LL, 0LL);
  if ( a2 <= 3u )
    *((_BYTE *)a1 + a2 + 104) = v7;
  return v7;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000000C70A) ----------------------------------------------------
signed __int64 __fastcall sub_C70A(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]
  int i; // [rsp+24h] [rbp-Ch]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v6 = lys_node_module(a1);
  for ( i = 0; i < v4; ++i )
  {
    if ( v6 == *(_QWORD *)(8LL * i + a2) )
      return 1LL;
  }
  return 0LL;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000000C76D) ----------------------------------------------------
size_t __fastcall sub_C76D(const char *a1)
{
  size_t v2; // [rsp+18h] [rbp-18h]
  const char *i; // [rsp+20h] [rbp-10h]
  size_t v4; // [rsp+28h] [rbp-8h]

  v2 = 0LL;
  v4 = strlen(a1);
  for ( i = a1; *i && v2 < v4; i += byte_107F80[*(unsigned __int8 *)i] )
    ++v2;
  return v2;
}

//----- (000000000000C7DA) ----------------------------------------------------
__int64 __fastcall ly_ctx_internal_modules_count(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_internal_modules_count", a4, a5, a6);
  if ( a1 )
    result = *(unsigned __int8 *)(a1 + 132);
  else
    result = 0LL;
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000C821) ----------------------------------------------------
pthread_key_t *__fastcall ly_ctx_new(const char *a1, pthread_key_t a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  char *i; // rax
  int v16; // [rsp+10h] [rbp-30h]
  signed int j; // [rsp+14h] [rbp-2Ch]
  char *v18; // [rsp+18h] [rbp-28h]
  pthread_key_t *ptr; // [rsp+20h] [rbp-20h]
  char *v20; // [rsp+28h] [rbp-18h]
  char *v21; // [rsp+30h] [rbp-10h]
  __int64 v22; // [rsp+38h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_new", a4, a5, a6);
  v16 = 0;
  ptr = (pthread_key_t *)calloc(1uLL, 0x88uLL);
  if ( !ptr )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_new", v9);
    return 0LL;
  }
  sub_14546((__int64)ptr, 136LL, v6, v7, v8, v9);
  ly_load_plugins(ptr);
  if ( pthread_key_create(ptr + 32, (void (*)(void *))destr_function) )
  {
    sub_12222(0LL, 0, 2, "pthread_key_create() in ly_ctx_new() failed", v11, v12);
LABEL_26:
    ly_ctx_destroy(ptr, 0LL);
    return 0LL;
  }
  *((_QWORD *)ptr + 8) = calloc(0x10uLL, 8uLL);
  if ( !*((_QWORD *)ptr + 8) )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_new", v13);
    free(ptr);
    return 0LL;
  }
  ptr[23] = a2;
  ptr[15] = 0;
  ptr[14] = 16;
  if ( a1 )
  {
    v20 = strdup(a1);
    if ( !v20 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_new", v14);
      goto LABEL_26;
    }
    v18 = v20;
    for ( i = strchr(v20, 58); ; i = strchr(v21 + 1, 58) )
    {
      v21 = i;
      if ( !i || v16 )
        break;
      *i = 0;
      v16 = ly_ctx_set_searchdir(ptr, v18);
      v18 = v21 + 1;
    }
    if ( *v18 && !v16 )
      v16 = ly_ctx_set_searchdir(ptr, v18);
    free(v20);
    if ( v16 )
      goto LABEL_26;
  }
  *((_WORD *)ptr + 45) = 1;
  if ( a2 & 4 )
    *((_BYTE *)ptr + 132) = 4;
  else
    *((_BYTE *)ptr + 132) = 6;
  for ( j = 0; j < *((unsigned __int8 *)ptr + 132); ++j )
  {
    v22 = lys_parse_mem(ptr, (&off_3457F0)[4 * j], *((unsigned int *)&unk_3457FC + 8 * j));
    if ( !v22 )
      goto LABEL_26;
    *(_BYTE *)(v22 + 64) = ((*((_BYTE *)&unk_3457F8 + 32 * j) & 1) << 7) | *(_BYTE *)(v22 + 64) & 0x7F;
  }
  return ptr;
}
// 7620: using guessed type __int64 __fastcall ly_ctx_set_searchdir(_QWORD, _QWORD);
// 76E0: using guessed type __int64 __fastcall ly_ctx_destroy(_QWORD, _QWORD);
// 77F0: using guessed type __int64 __fastcall lys_parse_mem(_QWORD, _QWORD, _QWORD);
// 7C60: using guessed type __int64 __fastcall ly_load_plugins(_QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;
// 3457F0: using guessed type char *off_3457F0;

//----- (000000000000CB4C) ----------------------------------------------------
signed __int64 __fastcall sub_CB4C(__int64 a1, __int64 a2)
{
  __int64 v3; // ST40_8
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int i; // [rsp+18h] [rbp-58h]
  unsigned int k; // [rsp+1Ch] [rbp-54h]
  __int64 j; // [rsp+20h] [rbp-50h]
  __int64 v9; // [rsp+28h] [rbp-48h]
  __int64 v10; // [rsp+30h] [rbp-40h]
  __int64 v11; // [rsp+38h] [rbp-38h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  int v13; // [rsp+50h] [rbp-20h]
  unsigned int v14; // [rsp+54h] [rbp-1Ch]
  __int64 v15; // [rsp+58h] [rbp-18h]
  unsigned __int64 v16; // [rsp+68h] [rbp-8h]

  v16 = __readfsqword(0x28u);
  v13 = 0;
  v14 = 0;
  v15 = 0LL;
  v11 = lyd_find_path(a2, "/ietf-yang-library:yang-library/modules-state/module");
  if ( !v11 )
    return 1LL;
  for ( i = 0; i < *(_DWORD *)(v11 + 4); ++i )
  {
    v3 = *(_QWORD *)(8LL * i + *(_QWORD *)(v11 + 8));
    v9 = 0LL;
    v10 = 0LL;
    ly_set_clean(&v13);
    for ( j = *(_QWORD *)(v3 + 64); j; j = *(_QWORD *)(j + 24) )
    {
      if ( !strcmp(**(const char ***)j, "name") )
      {
        v9 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "revision") )
      {
        v10 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "feature") )
      {
        ly_set_add(&v13, j, 1LL);
      }
      else
      {
        strcmp(**(const char ***)j, "conformance-type");
      }
    }
    v12 = ly_ctx_load_module(a1, v9, v10);
    if ( !v12 )
    {
      sub_12222(a1, 0, 3, "Unable to load module specified by yang library data.", v4, v5);
      ly_set_free(v11);
      return 1LL;
    }
    for ( k = 0; k < v14; ++k )
      lys_features_enable(v12, *(_QWORD *)(*(_QWORD *)(8LL * k + v15) + 56LL));
  }
  ly_set_free(v11);
  return 0LL;
}
// 7230: using guessed type __int64 __fastcall ly_set_clean(_QWORD);
// 7460: using guessed type __int64 __fastcall lys_features_enable(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 75A0: using guessed type __int64 __fastcall lyd_find_path(_QWORD, _QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BF0: using guessed type __int64 __fastcall ly_ctx_load_module(_QWORD, _QWORD, _QWORD);

//----- (000000000000CD97) ----------------------------------------------------
__int64 __fastcall sub_CD97(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 (__fastcall *a5)(__int64, __int64, _QWORD, _QWORD, _QWORD))
{
  __int64 v5; // ST60_8
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 (__fastcall *v9)(__int64, __int64, _QWORD, _QWORD, _QWORD); // [rsp+0h] [rbp-90h]
  unsigned int v10; // [rsp+Ch] [rbp-84h]
  unsigned int i; // [rsp+24h] [rbp-6Ch]
  unsigned int k; // [rsp+28h] [rbp-68h]
  signed int v13; // [rsp+2Ch] [rbp-64h]
  __int64 j; // [rsp+30h] [rbp-60h]
  __int64 v15; // [rsp+38h] [rbp-58h]
  __int64 v16; // [rsp+40h] [rbp-50h]
  __int64 v17; // [rsp+48h] [rbp-48h]
  __int64 v18; // [rsp+50h] [rbp-40h]
  __int64 v19; // [rsp+58h] [rbp-38h]
  __int64 v20; // [rsp+68h] [rbp-28h]
  int v21; // [rsp+70h] [rbp-20h]
  unsigned int v22; // [rsp+74h] [rbp-1Ch]
  __int64 v23; // [rsp+78h] [rbp-18h]
  unsigned __int64 v24; // [rsp+88h] [rbp-8h]

  v10 = a3;
  v9 = a5;
  v24 = __readfsqword(0x28u);
  v21 = 0;
  v22 = 0;
  v23 = 0LL;
  v17 = 0LL;
  v19 = 0LL;
  v13 = 0;
  v18 = ly_ctx_new(a1, a4);
  if ( !v18
    || (v17 = v9(v18, a2, v10, 0LL, 0LL)) == 0
    || (v19 = lyd_find_path(v17, "/ietf-yang-library:yang-library/module-set[1]/module")) == 0 )
  {
LABEL_25:
    v13 = 1;
    goto LABEL_26;
  }
  if ( !*(_DWORD *)(v19 + 4) )
  {
    if ( !(unsigned int)sub_CB4C(v18, v17) )
      goto LABEL_26;
    goto LABEL_25;
  }
  for ( i = 0; i < *(_DWORD *)(v19 + 4); ++i )
  {
    v5 = *(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 8));
    v15 = 0LL;
    v16 = 0LL;
    ly_set_clean(&v21);
    for ( j = *(_QWORD *)(v5 + 64); j; j = *(_QWORD *)(j + 24) )
    {
      if ( !strcmp(**(const char ***)j, "name") )
      {
        v15 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "revision") )
      {
        v16 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "feature") )
      {
        ly_set_add(&v21, j, 1LL);
      }
    }
    v20 = ly_ctx_load_module(v18, v15, v16);
    if ( !v20 )
    {
      sub_12222(0LL, 0, 3, "Unable to load module specified by yang library data.", v6, v7);
      goto LABEL_25;
    }
    for ( k = 0; k < v22; ++k )
      lys_features_enable(v20, *(_QWORD *)(*(_QWORD *)(8LL * k + v23) + 56LL));
  }
LABEL_26:
  if ( v17 )
    lyd_free_withsiblings(v17);
  if ( v19 )
    ly_set_free(v19);
  if ( v13 )
  {
    ly_ctx_destroy(v18, 0LL);
    v18 = 0LL;
  }
  return v18;
}
// 7230: using guessed type __int64 __fastcall ly_set_clean(_QWORD);
// 7460: using guessed type __int64 __fastcall lys_features_enable(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 75A0: using guessed type __int64 __fastcall lyd_find_path(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 76E0: using guessed type __int64 __fastcall ly_ctx_destroy(_QWORD, _QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BF0: using guessed type __int64 __fastcall ly_ctx_load_module(_QWORD, _QWORD, _QWORD);
// 7C30: using guessed type __int64 __fastcall ly_ctx_new(_QWORD, _QWORD);

//----- (000000000000D09F) ----------------------------------------------------
__int64 __fastcall ly_ctx_new_ylpath(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // ST0C_4
  unsigned int v7; // ST08_4

  v6 = a3;
  v7 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_new_ylpath", a4, a5, a6);
  return sub_CD97(a1, a2, v6, v7, (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD))lyd_parse_path);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D0F4) ----------------------------------------------------
__int64 __fastcall ly_ctx_new_ylmem(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // ST0C_4
  unsigned int v7; // ST08_4

  v6 = a3;
  v7 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_new_ylmem", a4, a5, a6);
  return sub_CD97(a1, a2, v6, v7, (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD))lyd_parse_mem);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D149) ----------------------------------------------------
__int64 __fastcall sub_D149(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 92) |= a2;
  }
  return result;
}

//----- (000000000000D173) ----------------------------------------------------
__int64 __fastcall sub_D173(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 92) &= ~a2;
  }
  return result;
}

//----- (000000000000D19F) ----------------------------------------------------
__int64 __fastcall ly_ctx_set_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_disable_searchdirs", a4, a5, a6);
  return sub_D149(a1, 8);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D1DC) ----------------------------------------------------
__int64 __fastcall ly_ctx_unset_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_disable_searchdirs", a4, a5, a6);
  return sub_D173(a1, 8);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D219) ----------------------------------------------------
__int64 __fastcall ly_ctx_set_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_disable_searchdir_cwd", a4, a5, a6);
  return sub_D149(a1, 16);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D256) ----------------------------------------------------
__int64 __fastcall ly_ctx_unset_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_disable_searchdir_cwd", a4, a5, a6);
  return sub_D173(a1, 16);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D293) ----------------------------------------------------
__int64 __fastcall ly_ctx_set_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_prefer_searchdirs", a4, a5, a6);
  return sub_D149(a1, 32);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D2D0) ----------------------------------------------------
__int64 __fastcall ly_ctx_unset_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_prefer_searchdirs", a4, a5, a6);
  return sub_D173(a1, 32);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D30D) ----------------------------------------------------
__int64 __fastcall ly_ctx_set_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_allimplemented", a4, a5, a6);
  return sub_D149(a1, 1);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D34A) ----------------------------------------------------
__int64 __fastcall ly_ctx_unset_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_allimplemented", a4, a5, a6);
  return sub_D173(a1, 1);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D387) ----------------------------------------------------
__int64 __fastcall ly_ctx_set_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_trusted", a4, a5, a6);
  return sub_D149(a1, 2);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D3C4) ----------------------------------------------------
__int64 __fastcall ly_ctx_unset_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_trusted", a4, a5, a6);
  return sub_D173(a1, 2);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D401) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_options(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_options", a4, a5, a6);
  return *(unsigned int *)(a1 + 92);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D433) ----------------------------------------------------
signed __int64 __fastcall ly_ctx_set_searchdir(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  int *v8; // rax
  char *v9; // rax
  int *v10; // rax
  char *v11; // rax
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  char *name; // [rsp+0h] [rbp-30h]
  int i; // [rsp+18h] [rbp-18h]
  unsigned int v17; // [rsp+1Ch] [rbp-14h]
  char *s1; // [rsp+20h] [rbp-10h]
  void *v19; // [rsp+28h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_searchdir", a4, a5, a6, a2);
  v17 = 1;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_set_searchdir", v6);
    return 1LL;
  }
  if ( !name )
    return 0LL;
  if ( access(name, 5) )
  {
    v8 = __errno_location();
    v9 = strerror(*v8);
    sub_12222(a1, 0, 2, "Unable to use search directory \"%s\" (%s)", (__int64)name, (__int64)v9);
    return 1LL;
  }
  s1 = realpath(name, 0LL);
  if ( s1 )
  {
    if ( *(_QWORD *)(a1 + 48) )
    {
      for ( i = 0; *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)); ++i )
      {
        if ( !strcmp(s1, *(const char **)(8LL * i + *(_QWORD *)(a1 + 48))) )
          goto LABEL_20;
      }
      v19 = realloc(*(void **)(a1 + 48), 8LL * (i + 2));
      if ( !v19 )
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_set_searchdir", v14);
        goto LABEL_22;
      }
      *(_QWORD *)(a1 + 48) = v19;
    }
    else
    {
      *(_QWORD *)(a1 + 48) = malloc(0x10uLL);
      if ( !*(_QWORD *)(a1 + 48) )
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_set_searchdir", v13);
        goto LABEL_22;
      }
      i = 0;
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL * i) = s1;
    s1 = 0LL;
    *(_QWORD *)(8 * (i + 1LL) + *(_QWORD *)(a1 + 48)) = 0LL;
LABEL_20:
    v17 = 0;
    goto LABEL_22;
  }
  v10 = __errno_location();
  v11 = strerror(*v10);
  sub_12222(a1, 0, 2, "realpath() call failed (%s).", (__int64)v11, v12);
LABEL_22:
  free(s1);
  return v17;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D6FB) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_searchdirs", a4, a5, a6);
  if ( a1 )
    return *(_QWORD *)(a1 + 48);
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_searchdirs", v6);
  return 0LL;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D763) ----------------------------------------------------
__int64 __fastcall ly_ctx_unset_searchdirs(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_searchdirs", a4, a5, a6);
  result = *(_QWORD *)(a1 + 48);
  if ( result )
  {
    for ( i = 0; *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)); ++i )
    {
      if ( a2 >= 0 && a2 != i )
      {
        if ( i > a2 )
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL * i - 8) = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL * i);
          *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)) = 0LL;
        }
      }
      else
      {
        free(*(void **)(8LL * i + *(_QWORD *)(a1 + 48)));
        *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)) = 0LL;
      }
    }
    if ( a2 < 0 || (result = **(_QWORD **)(a1 + 48)) == 0 )
    {
      free(*(void **)(a1 + 48));
      result = a1;
      *(_QWORD *)(a1 + 48) = 0LL;
    }
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D8AD) ----------------------------------------------------
void __fastcall ly_ctx_destroy(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  void (__fastcall *v10)(void **, void *); // [rsp+0h] [rbp-20h]
  int i; // [rsp+1Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_destroy", a4, a5, a6, a2);
  if ( a1 )
  {
    while ( *(_DWORD *)(a1 + 60) > 0 )
    {
      sub_A9496(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8));
      sub_A67C8(*(unsigned __int8 **)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8), v10, 1, 0);
      --*(_DWORD *)(a1 + 60);
    }
    if ( *(_QWORD *)(a1 + 48) )
    {
      for ( i = 0; *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)); ++i )
        free(*(void **)(8LL * i + *(_QWORD *)(a1 + 48)));
      free(*(void **)(a1 + 48));
    }
    free(*(void **)(a1 + 64));
    ly_err_clean(a1, 0LL);
    pthread_key_delete(*(_DWORD *)(a1 + 128));
    sub_145FF(a1, 0LL, v6, v7, v8, v9);
    ly_clean_plugins(a1);
    free((void *)a1);
  }
}
// 7530: using guessed type __int64 __fastcall ly_clean_plugins(_QWORD);
// 77D0: using guessed type __int64 __fastcall ly_err_clean(_QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000DA1A) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_submodule2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  _BYTE *v8; // [rsp+0h] [rbp-20h]
  signed int i; // [rsp+14h] [rbp-Ch]
  __int64 v10; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_submodule2", a4, a5, a6, a2);
  if ( a1 && v8 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(a1 + 70); ++i )
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i);
      if ( (unsigned int)sub_C462(v8, *(_BYTE **)(v10 + 8)) )
        return v10;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_submodule2", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000DAED) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_submodule(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  char *v8; // [rsp+8h] [rbp-58h]
  __int64 v9; // [rsp+10h] [rbp-50h]
  char *s1; // [rsp+18h] [rbp-48h]
  int v11; // [rsp+3Ch] [rbp-24h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  s1 = a3;
  v9 = a4;
  v8 = (char *)a5;
  v15 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_submodule", a4, a5, a6);
  v12 = 0LL;
  v11 = 0;
  if ( a1 && v9 && (!s1 || a2) )
  {
    while ( 1 )
    {
      v13 = ly_ctx_get_module_iter(a1, &v11);
      if ( !v13 )
        break;
      if ( (!a2 || !strcmp(*(const char **)(v13 + 8), a2))
        && (!s1 || *(_QWORD *)(v13 + 88) && !strcmp(s1, *(const char **)(v13 + 88))) )
      {
        v14 = ly_ctx_get_submodule2(v13, v9);
        if ( v14 )
        {
          if ( v8 )
          {
            if ( *(_QWORD *)(v14 + 88) && !strcmp(v8, *(const char **)(v14 + 88)) )
            {
              v12 = v14;
              break;
            }
          }
          else if ( v12 )
          {
            if ( *(_QWORD *)(v14 + 88)
              && (!*(_QWORD *)(v12 + 88) || strcmp(*(const char **)(v14 + 88), *(const char **)(v12 + 88)) > 0) )
            {
              v12 = v14;
            }
          }
          else
          {
            v12 = v14;
          }
        }
      }
    }
    result = v12;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_submodule", v6);
    result = 0LL;
  }
  return result;
}
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7AB0: using guessed type __int64 __fastcall ly_ctx_get_submodule2(_QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000DCEF) ----------------------------------------------------
__int64 __fastcall sub_DCEF(__int64 a1, const char *a2, size_t a3, int a4, char *a5, __int64 a6, int a7)
{
  __int64 result; // rax
  char *v8; // [rsp+8h] [rbp-48h]
  int v9; // [rsp+10h] [rbp-40h]
  int v10; // [rsp+14h] [rbp-3Ch]
  size_t n; // [rsp+18h] [rbp-38h]
  int i; // [rsp+3Ch] [rbp-14h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  char *s2; // [rsp+48h] [rbp-8h]

  n = a3;
  v10 = a4;
  v8 = a5;
  v9 = a6;
  v13 = 0LL;
  if ( a1 && a2 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
    {
      if ( v9 || !(*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) & 0x40) )
      {
        s2 = *(char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + v10);
        if ( *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64))
          && (n || !strcmp(a2, s2))
          && (!n || !strncmp(a2, s2, n) && !s2[n]) )
        {
          if ( v8 )
          {
            if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL)
              && !strcmp(v8, *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 88LL)) )
            {
              v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
              break;
            }
          }
          else if ( !v13
                 || *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL)
                 && (!*(_BYTE *)(v13 + 68)
                  || strcmp(
                       *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 88LL),
                       *(const char **)(v13 + 88)) >= 0) )
          {
            if ( a7 )
            {
              if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) < 0 )
              {
                v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
                break;
              }
            }
            else
            {
              v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
            }
          }
        }
      }
    }
    result = v13;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_by", a6);
    result = 0LL;
  }
  return result;
}

//----- (000000000000DFB3) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module_by_ns(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v6; // ST18_8
  int v7; // ST14_4

  v6 = a3;
  v7 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_by_ns", a4, a5, a6);
  return sub_DCEF(a1, a2, 0LL, 176, v6, 0LL, v7);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E01C) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v6; // ST18_8
  int v7; // ST14_4

  v6 = a3;
  v7 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module", a4, a5, a6);
  return sub_DCEF(a1, a2, 0LL, 8, v6, 0LL, v7);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E085) ----------------------------------------------------
__int64 __fastcall sub_E085(__int64 a1, const char *a2, size_t a3, char *a4, int a5)
{
  return sub_DCEF(a1, a2, a3, 8, a4, 0LL, a5);
}

//----- (000000000000E0D5) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module_older(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+0h] [rbp-30h]
  int i; // [rsp+1Ch] [rbp-14h]
  __int64 v10; // [rsp+20h] [rbp-10h]
  __int64 v11; // [rsp+28h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_older", a4, a5, a6, a2);
  v10 = 0LL;
  if ( a1 && v8 && *(_BYTE *)(v8 + 68) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
    {
      v11 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
      if ( !(*(_BYTE *)(v11 + 64) & 0x40)
        && v11 != v8
        && *(_BYTE *)(v11 + 68)
        && (unsigned int)sub_C462(*(_BYTE **)(v8 + 8), *(_BYTE **)(v11 + 8))
        && strcmp(*(const char **)(v11 + 88), *(const char **)(v8 + 88)) < 0 )
      {
        if ( v10 )
        {
          if ( strcmp(*(const char **)(v11 + 88), *(const char **)(v10 + 88)) > 0 )
            v10 = v11;
        }
        else
        {
          v10 = v11;
        }
      }
    }
    result = v10;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_older", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E24D) ----------------------------------------------------
unsigned __int64 __fastcall ly_ctx_set_module_imp_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  unsigned __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-18h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_module_imp_clb", a4, a5, a6);
  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_set_module_imp_clb", v6);
  *(_QWORD *)(a1 + 96) = a2;
  result = a1;
  *(_QWORD *)(a1 + 104) = v8;
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E2C8) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module_imp_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  _QWORD *v8; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_imp_clb", a4, a5, a6, a2);
  if ( a1 )
  {
    if ( v8 )
      *v8 = *(_QWORD *)(a1 + 104);
    result = *(_QWORD *)(a1 + 96);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_imp_clb", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E34A) ----------------------------------------------------
unsigned __int64 __fastcall ly_ctx_set_module_data_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  unsigned __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-18h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_module_data_clb", a4, a5, a6);
  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_set_module_data_clb", v6);
  *(_QWORD *)(a1 + 112) = a2;
  result = a1;
  *(_QWORD *)(a1 + 120) = v8;
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E3C5) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module_data_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  _QWORD *v8; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_data_clb", a4, a5, a6, a2);
  if ( a1 )
  {
    if ( v8 )
      *v8 = *(_QWORD *)(a1 + 120);
    result = *(_QWORD *)(a1 + 112);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_data_clb", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E447) ----------------------------------------------------
__int64 __fastcall sub_E447(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6)
{
  _BOOL4 v6; // ebx
  __int64 v7; // rax
  __int64 v8; // r9
  size_t v10; // rax
  __int64 v11; // r9
  int *v12; // rax
  char *v13; // rax
  const char *v14; // rdx
  __int64 v15; // rax
  __int64 v16; // [rsp+0h] [rbp-1090h]
  unsigned int v17; // [rsp+Ch] [rbp-1084h]
  char *v18; // [rsp+10h] [rbp-1080h]
  char *s1; // [rsp+18h] [rbp-1078h]
  int v20; // [rsp+34h] [rbp-105Ch]
  int i; // [rsp+38h] [rbp-1058h]
  int fd; // [rsp+3Ch] [rbp-1054h]
  char *s; // [rsp+40h] [rbp-1050h]
  char *v24; // [rsp+48h] [rbp-1048h]
  __int64 v25; // [rsp+50h] [rbp-1040h]
  char *v26; // [rsp+58h] [rbp-1038h]
  char *s2; // [rsp+60h] [rbp-1030h]
  size_t n; // [rsp+68h] [rbp-1028h]
  char resolved; // [rsp+70h] [rbp-1020h]
  unsigned __int64 v30; // [rsp+1078h] [rbp-18h]

  s1 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v30 = __readfsqword(0x28u);
  s = 0LL;
  v25 = 0LL;
  v6 = (*(_DWORD *)(a1 + 92) & 0x10) == 0;
  v7 = ly_ctx_get_searchdirs(a1);
  if ( (unsigned int)lys_search_localfile(v7, (unsigned int)v6, s1, v18, &s, &v20) )
  {
LABEL_51:
    free(s);
    return v25;
  }
  if ( s )
  {
    sub_12222(0LL, 2u, 0, "Loading schema from \"%s\" file.", (__int64)s, v8);
    v26 = strrchr(s, 46);
    v26[1] = 0;
    if ( !v18 )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
      {
        if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL) )
        {
          if ( !strcmp(s1, *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 8LL)) )
          {
            v10 = strlen(s);
            if ( !strncmp(s, *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL), v10) )
            {
              v25 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
              if ( v17 && *(_BYTE *)(v25 + 64) >= 0 )
              {
                if ( (unsigned int)lys_set_implemented(v25) )
                  v25 = 0LL;
              }
              else if ( *(_BYTE *)(v25 + 64) & 0x40 )
              {
                lys_set_enabled(v25);
              }
              goto LABEL_51;
            }
          }
        }
      }
    }
    v26[1] = 121;
    fd = open(s, 0);
    if ( fd >= 0 )
    {
      if ( a2 )
        v25 = (__int64)sub_9DEAC(a2, fd, v20, v16);
      else
        v25 = sub_9DD36(a1, fd, v20, v18, v17, v11);
      close(fd);
      if ( v25 )
      {
        v24 = strrchr(s, 47);
        if ( v24 )
          ++v24;
        else
          v24 = s;
        s2 = strchr(v24, 64);
        n = strlen(*(const char **)(v25 + 8));
        if ( strncmp(v24, *(const char **)(v25 + 8), n) || s2 && s2 != &v24[n] || !s2 && v26 != &v24[n] )
          sub_12222(
            a1,
            1u,
            0,
            "File name \"%s\" does not match module name \"%s\".",
            (__int64)v24,
            *(_QWORD *)(v25 + 8));
        if ( s2 )
        {
          n = v26 - ++s2;
          if ( !*(_BYTE *)(v25 + 68) || n != 10 || strncmp(*(const char **)(v25 + 88), s2, 0xAuLL) )
          {
            if ( *(_BYTE *)(v25 + 68) )
              v14 = *(const char **)(v25 + 88);
            else
              v14 = "none";
            sub_12222(a1, 1u, 0, "File name \"%s\" does not match module revision \"%s\".", (__int64)v24, (__int64)v14);
          }
        }
        if ( !*(_QWORD *)(v25 + 56) )
        {
          if ( realpath(s, &resolved) )
            v15 = lydict_insert(a1, &resolved, 0LL);
          else
            v15 = lydict_insert(a1, s, 0LL);
          *(_QWORD *)(v25 + 56) = v15;
        }
      }
    }
    else
    {
      v12 = __errno_location();
      v13 = strerror(*v12);
      sub_12222(a1, 0, 2, "Unable to open data model file \"%s\" (%s).", (__int64)s, (__int64)v13);
    }
    goto LABEL_51;
  }
  if ( !a2 && !v18 )
    v25 = ly_ctx_get_module(a1, s1, 0LL, 0LL);
  if ( !v25 )
    sub_12222(a1, 0, 2, "Data model \"%s\" not found.", (__int64)s1, v8);
  return v25;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 73C0: using guessed type __int64 __fastcall lys_set_enabled(_QWORD);
// 73E0: using guessed type __int64 __fastcall lys_search_localfile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 74B0: using guessed type __int64 __fastcall lys_set_implemented(_QWORD);
// 79A0: using guessed type __int64 __fastcall ly_ctx_get_searchdirs(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000000EB1C) ----------------------------------------------------
__int64 __fastcall sub_EB1C(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 (__fastcall *v6)(__int64, __int64, __int64, __int64, __int64, int *, void (__fastcall **)(_QWORD, _QWORD)); // rax
  __int64 v7; // r8
  __int64 v8; // r10
  __int64 v9; // rdi
  int *v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-60h]
  unsigned int v15; // [rsp+Ch] [rbp-54h]
  __int64 v16; // [rsp+10h] [rbp-50h]
  __int64 v17; // [rsp+18h] [rbp-48h]
  __int64 v18; // [rsp+28h] [rbp-38h]
  int v19; // [rsp+3Ch] [rbp-24h]
  void (__fastcall *v20)(const char *, _QWORD); // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  const char *v22; // [rsp+50h] [rbp-10h]
  unsigned __int64 v23; // [rsp+58h] [rbp-8h]

  v18 = a1;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v23 = __readfsqword(0x28u);
  v21 = 0LL;
  v22 = 0LL;
  v19 = 0;
  v20 = 0LL;
  *(_DWORD *)ly_errno_glob_address(a1) = 0;
  if ( a2 )
  {
    v21 = lys_main_module(a2);
    v6 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, int *, void (__fastcall **)(_QWORD, _QWORD)))(a1 + 96);
    v7 = *(_QWORD *)(a1 + 104);
    if ( *(_BYTE *)(v21 + 68) )
      v8 = *(_QWORD *)(v21 + 88);
    else
      v8 = 0LL;
    v9 = *(_QWORD *)(v21 + 8);
    v22 = (const char *)v6(v9, v8, v17, v16, v7, &v19, (void (__fastcall **)(_QWORD, _QWORD))&v20);
  }
  else
  {
    v9 = v17;
    v22 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD, int *, void (__fastcall **)(const char *, _QWORD)))(v18 + 96))(
                          v17,
                          v16,
                          0LL,
                          0LL,
                          *(_QWORD *)(v18 + 104),
                          &v19,
                          &v20);
  }
  if ( v22 || !*(_DWORD *)ly_errno_glob_address(v9) )
  {
    if ( v22 )
    {
      if ( a2 )
        v21 = (__int64)sub_9D687(a2, v22, v19, v14);
      else
        v21 = sub_9D438(v18, v22, v19, 0LL, 0LL, v15);
      if ( v20 )
        v20(v22, *(_QWORD *)(v18 + 104));
    }
    result = v21;
  }
  else
  {
    v10 = (int *)ly_errno_glob_address(v9);
    sub_12222(v18, 0, *v10, "User module retrieval callback failed!", v11, v12, v14);
    result = 0LL;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000000ECF1) ----------------------------------------------------
__int64 __fastcall sub_ECF1(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-50h]
  unsigned int v8; // [rsp+Ch] [rbp-44h]
  char *s1; // [rsp+10h] [rbp-40h]
  char *v10; // [rsp+18h] [rbp-38h]
  signed int v11[3]; // [rsp+3Ch] [rbp-14h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  s1 = a4;
  v8 = a5;
  v7 = a6;
  *(_QWORD *)&v11[1] = 0LL;
  v12 = 0LL;
  if ( a2 )
    goto LABEL_53;
  v11[0] = 0;
  *(_QWORD *)&v11[1] = 0LL;
  while ( v11[0] < *(_DWORD *)(a1 + 60) )
  {
    *(_QWORD *)&v11[1] = *(_QWORD *)(8LL * v11[0] + *(_QWORD *)(a1 + 64));
    if ( (unsigned int)sub_C462(v10, *(_BYTE **)(*(_QWORD *)&v11[1] + 8LL)) )
    {
      if ( v12 )
      {
        if ( *(_BYTE *)(*(_QWORD *)&v11[1] + 68LL)
          && *(_BYTE *)(v12 + 68)
          && strcmp(*(const char **)(*(_QWORD *)&v11[1] + 88LL), *(const char **)(v12 + 88)) > 0 )
        {
          v12 = *(_QWORD *)&v11[1];
        }
      }
      else
      {
        v12 = *(_QWORD *)&v11[1];
      }
      if ( s1 && *(_BYTE *)(*(_QWORD *)&v11[1] + 68LL) && !strcmp(s1, *(const char **)(*(_QWORD *)&v11[1] + 88LL))
        || !s1 && *(_BYTE *)(*(_QWORD *)&v11[1] + 65LL) & 1
        || v8 && *(_BYTE *)(*(_QWORD *)&v11[1] + 64LL) < 0 && !s1 )
      {
        break;
      }
    }
    v11[2] = 0;
    *(_QWORD *)v11 = (unsigned int)(v11[0] + 1);
  }
  if ( !*(_QWORD *)&v11[1] )
  {
LABEL_53:
    if ( !*(_QWORD *)(a1 + 96) || *(_DWORD *)(a1 + 92) & 0x20 )
      goto LABEL_33;
    do
    {
      if ( *(_QWORD *)(a1 + 96) )
        *(_QWORD *)&v11[1] = sub_EB1C(a1, a2, (__int64)v10, (__int64)s1, v8, v7);
      if ( *(_QWORD *)&v11[1] || *(_DWORD *)(a1 + 92) & 0x20 )
        break;
LABEL_33:
      if ( !(*(_DWORD *)(a1 + 92) & 8) )
        *(_QWORD *)&v11[1] = sub_E447(a1, a2, v10, s1, v8, v7);
    }
    while ( !*(_QWORD *)&v11[1] && *(_DWORD *)(a1 + 92) & 0x20 );
    if ( *(_QWORD *)&v11[1]
      && !s1
      && v12
      && *(_BYTE *)(*(_QWORD *)&v11[1] + 68LL)
      && *(_BYTE *)(v12 + 68)
      && strcmp(*(const char **)(*(_QWORD *)&v11[1] + 88LL), *(const char **)(v12 + 88)) < 0 )
    {
      sub_A67C8(*(unsigned __int8 **)&v11[1], 0LL, 1, 1);
      *(_QWORD *)&v11[1] = 0LL;
    }
    if ( !*(_QWORD *)&v11[1] && v12 )
      *(_QWORD *)&v11[1] = v12;
    if ( !s1 && *(_QWORD *)&v11[1] )
      *(_BYTE *)(*(_QWORD *)&v11[1] + 65LL) |= 1u;
    result = *(_QWORD *)&v11[1];
  }
  else
  {
    if ( *(_BYTE *)(*(_QWORD *)&v11[1] + 64LL) & 0x40 )
      lys_set_enabled(*(_QWORD *)&v11[1]);
    if ( v8 )
    {
      if ( (unsigned int)lys_set_implemented(*(_QWORD *)&v11[1]) )
        *(_QWORD *)&v11[1] = 0LL;
    }
    result = *(_QWORD *)&v11[1];
  }
  return result;
}
// 73C0: using guessed type __int64 __fastcall lys_set_enabled(_QWORD);
// 74B0: using guessed type __int64 __fastcall lys_set_implemented(_QWORD);

//----- (000000000000F003) ----------------------------------------------------
__int64 __fastcall ly_ctx_load_module(__int64 a1, char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  char *v8; // rax
  char *v9; // [rsp+8h] [rbp-18h]

  v9 = a3;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_load_module", a4, a5, a6);
  if ( a1 && a2 )
  {
    if ( v9 && *v9 )
      v8 = v9;
    else
      v8 = 0LL;
    result = sub_ECF1(a1, 0LL, a2, v8, 1u, 0LL);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_load_module", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000F0B0) ----------------------------------------------------
__int64 __fastcall sub_F0B0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int8 j; // [rsp+13h] [rbp-2Dh]
  int i; // [rsp+14h] [rbp-2Ch]
  unsigned int l; // [rsp+18h] [rbp-28h]
  unsigned int k; // [rsp+1Ch] [rbp-24h]
  unsigned int m; // [rsp+1Ch] [rbp-24h]
  unsigned int ii; // [rsp+1Ch] [rbp-24h]
  __int64 n; // [rsp+20h] [rbp-20h]
  __int64 v10; // [rsp+28h] [rbp-18h]
  __int64 v11; // [rsp+30h] [rbp-10h]

  for ( i = *(unsigned __int8 *)(a1 + 132) - 1; ; ++i )
  {
    result = *(unsigned int *)(a1 + 60);
    if ( i >= (signed int)result )
      break;
    v11 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
    for ( j = 0; j < *(_BYTE *)(v11 + 76); ++j )
    {
      if ( *(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) )
      {
        for ( k = 0; k < *(_DWORD *)(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) + 4LL); ++k )
        {
          if ( !a2
            || (unsigned int)ly_set_contains(
                               a2,
                               *(_QWORD *)(*(_QWORD *)(8LL * k
                                                     + *(_QWORD *)(*(_QWORD *)(((unsigned __int64)j << 6)
                                                                             + *(_QWORD *)(v11 + 128)
                                                                             + 56)
                                                                 + 8LL))
                                         + 48LL)) != -1 )
          {
            ly_set_rm_index(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56), k--);
          }
        }
        if ( !*(_DWORD *)(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) + 4LL) )
        {
          ly_set_free(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56));
          *(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) = 0LL;
        }
      }
    }
    for ( l = 0; l < *(unsigned __int16 *)(v11 + 72); ++l )
    {
      if ( *(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) )
      {
        for ( m = 0; m < *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) + 4LL); ++m )
        {
          if ( !a2
            || (unsigned int)ly_set_contains(
                               a2,
                               *(_QWORD *)(*(_QWORD *)(8LL * m
                                                     + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64)
                                                                 + 8LL))
                                         + 48LL)) != -1 )
          {
            ly_set_rm_index(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64), m--);
          }
        }
        if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) + 4LL) )
        {
          ly_set_free(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64));
          *(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) = 0LL;
        }
      }
    }
    for ( n = *(_QWORD *)(v11 + 168); n; n = v10 )
    {
      if ( *(_DWORD *)(n + 56) & 0xC && *(_QWORD *)(n + 72) )
      {
        if ( a2 )
        {
          for ( ii = 0; ii < *(_DWORD *)(*(_QWORD *)(n + 72) + 4LL); ++ii )
          {
            if ( (unsigned int)ly_set_contains(
                                 a2,
                                 *(_QWORD *)(*(_QWORD *)(8LL * ii + *(_QWORD *)(*(_QWORD *)(n + 72) + 8LL)) + 48LL)) != -1 )
              ly_set_rm_index(*(_QWORD *)(n + 72), ii--);
          }
          if ( !*(_DWORD *)(*(_QWORD *)(n + 72) + 4LL) )
          {
            ly_set_free(*(_QWORD *)(n + 72));
            *(_QWORD *)(n + 72) = 0LL;
          }
        }
        else
        {
          ly_set_free(*(_QWORD *)(n + 72));
          *(_QWORD *)(n + 72) = 0LL;
        }
      }
      v10 = *(_QWORD *)(n + 72);
      if ( *(_DWORD *)(n + 56) & 0x882C )
        v10 = 0LL;
      if ( !v10 )
        v10 = *(_QWORD *)(n + 80);
      while ( !v10 )
      {
        n = lys_parent(n);
        if ( !n )
          break;
        v10 = *(_QWORD *)(n + 80);
      }
    }
  }
  return result;
}
// 72E0: using guessed type __int64 __fastcall ly_set_rm_index(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 74C0: using guessed type __int64 __fastcall ly_set_contains(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (000000000000F559) ----------------------------------------------------
__int64 __fastcall sub_F559(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int128 v6; // di
  __int64 *v7; // rdi
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rbx
  __int64 v12; // [rsp+8h] [rbp-58h]
  unsigned int v13; // [rsp+10h] [rbp-50h]
  unsigned int i; // [rsp+14h] [rbp-4Ch]
  unsigned int j; // [rsp+18h] [rbp-48h]
  unsigned int k; // [rsp+1Ch] [rbp-44h]
  __int64 v17; // [rsp+20h] [rbp-40h]
  __int64 l; // [rsp+28h] [rbp-38h]
  __int64 v19; // [rsp+30h] [rbp-30h]
  __int64 v20; // [rsp+38h] [rbp-28h]
  __int64 v21; // [rsp+40h] [rbp-20h]
  unsigned __int64 v22; // [rsp+48h] [rbp-18h]

  v12 = a1;
  v22 = __readfsqword(0x28u);
  for ( i = 0; i < *(_DWORD *)(v12 + 4); ++i )
  {
    v19 = *(_QWORD *)(8LL * i + *(_QWORD *)(v12 + 8));
    if ( *(_BYTE *)(v19 + 64) < 0 )
    {
      for ( j = 0; j < *(unsigned __int16 *)(v19 + 72); ++j )
      {
        for ( k = 0; ; ++k )
        {
          a4 = *(_QWORD *)(v19 + 120);
          if ( k >= *(unsigned __int8 *)(a4 + 72LL * j + 31) )
            break;
          *((_QWORD *)&v6 + 1) = *(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(v19 + 120) + 72LL * j + 56));
          *(_QWORD *)&v6 = *(_QWORD *)(v19 + 120) + 72LL * j;
          sub_258B4(v6);
        }
      }
    }
    for ( j = 0; j < *(unsigned __int8 *)(v19 + 76); ++j )
    {
      for ( k = 0; k < *(unsigned __int8 *)(((unsigned __int64)j << 6) + *(_QWORD *)(v19 + 128) + 27); ++k )
      {
        v7 = (__int64 *)(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v19 + 128) + 40) + 32LL * k);
        sub_1902D(v7, 0LL, &v13);
        while ( 1 )
        {
          v9 = v13--;
          if ( !v9 )
            break;
          v21 = *(_QWORD *)(8LL * v13
                          + *(_QWORD *)(32LL * k
                                      + *(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v19 + 128) + 40)
                                      + 16));
          if ( !*(_QWORD *)(v21 + 56) )
          {
            v8 = ly_set_new(v7);
            *(_QWORD *)(v21 + 56) = v8;
          }
          v7 = *(__int64 **)(v21 + 56);
          ly_set_add(v7, *(_QWORD *)(v19 + 128) + ((unsigned __int64)j << 6), 1LL);
        }
      }
    }
    v17 = *(_QWORD *)(v19 + 168);
    for ( l = v17; l; l = v17 )
    {
      if ( *(_DWORD *)(l + 56) == 2048 )
        goto LABEL_40;
      if ( *(_DWORD *)(l + 56) & 0xC )
      {
        v20 = l + 128;
        if ( *(_DWORD *)(l + 128) == 9 )
          sub_A7706(*(_QWORD *)(v20 + 40), l, l, a4, a5, a6);
      }
      v17 = *(_QWORD *)(l + 72);
      if ( *(_DWORD *)(l + 56) & 0x802C )
        v17 = 0LL;
      if ( !v17 )
      {
LABEL_40:
        if ( l == *(_QWORD *)(v19 + 168) )
          break;
        v17 = *(_QWORD *)(l + 80);
      }
      while ( !v17 )
      {
        l = lys_parent(l);
        v10 = lys_parent(l);
        if ( v10 == lys_parent(*(_QWORD *)(v19 + 168)) )
          break;
        v17 = *(_QWORD *)(l + 80);
      }
    }
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000000F8D0) ----------------------------------------------------
signed __int64 __fastcall lys_set_disabled(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rax
  unsigned __int8 k; // [rsp+16h] [rbp-2Ah]
  unsigned __int8 n; // [rsp+16h] [rbp-2Ah]
  char v13; // [rsp+17h] [rbp-29h]
  signed int i; // [rsp+18h] [rbp-28h]
  int j; // [rsp+18h] [rbp-28h]
  int m; // [rsp+1Ch] [rbp-24h]
  unsigned int l; // [rsp+20h] [rbp-20h]
  unsigned int ii; // [rsp+20h] [rbp-20h]
  unsigned int jj; // [rsp+20h] [rbp-20h]
  unsigned int kk; // [rsp+20h] [rbp-20h]
  unsigned int ll; // [rsp+24h] [rbp-1Ch]
  __int64 v22; // [rsp+28h] [rbp-18h]
  __int64 v23; // [rsp+28h] [rbp-18h]
  __int64 v24; // [rsp+30h] [rbp-10h]
  __int64 v25; // [rsp+38h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"lys_set_disabled", a4, a5, a6);
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 64) & 0x40 )
    {
      result = 0LL;
    }
    else
    {
      v24 = *(_QWORD *)a1;
      for ( i = 0; i < *(unsigned __int8 *)(v24 + 132); ++i )
      {
        if ( a1 == *(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 64)) )
        {
          sub_12222(v24, 0, 3, "Internal module \"%s\" cannot be disabled.", *(_QWORD *)(a1 + 8), v6);
          return 1LL;
        }
      }
      *(_BYTE *)(a1 + 64) |= 0x40u;
      v25 = ly_set_new(32LL);
      ly_set_add(v25, a1, 0LL);
LABEL_11:
      for ( j = *(unsigned __int8 *)(v24 + 132); j < *(_DWORD *)(v24 + 60); ++j )
      {
        v22 = *(_QWORD *)(8LL * j + *(_QWORD *)(v24 + 64));
        if ( !(*(_BYTE *)(v22 + 64) & 0x40) )
        {
          for ( k = 0; k < *(_BYTE *)(v22 + 69); ++k )
          {
            for ( l = 0; l < *(_DWORD *)(v25 + 4); ++l )
            {
              if ( *(_QWORD *)(*(_QWORD *)(v22 + 96) + 56LL * k) == *(_QWORD *)(8LL * l + *(_QWORD *)(v25 + 8)) )
              {
                *(_BYTE *)(v22 + 64) |= 0x40u;
                ly_set_add(v25, v22, 0LL);
                goto LABEL_11;
              }
            }
          }
          if ( *(_BYTE *)(v22 + 64) >= 0 )
          {
            v13 = 0;
            for ( m = *(unsigned __int8 *)(v24 + 132); m < *(_DWORD *)(v24 + 60); ++m )
            {
              if ( !(*(_BYTE *)(*(_QWORD *)(8LL * m + *(_QWORD *)(v24 + 64)) + 64LL) & 0x40) )
              {
                for ( n = 0; n < *(_BYTE *)(*(_QWORD *)(8LL * m + *(_QWORD *)(v24 + 64)) + 69LL); ++n )
                {
                  if ( v22 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(8LL * m + *(_QWORD *)(v24 + 64)) + 96LL) + 56LL * n) )
                  {
                    v13 = 1;
                    goto LABEL_31;
                  }
                }
              }
            }
LABEL_31:
            if ( !v13 )
            {
              *(_BYTE *)(v22 + 64) |= 0x40u;
              ly_set_add(v25, v22, 0LL);
              if ( *(_BYTE *)(v22 + 69) )
                goto LABEL_11;
            }
          }
        }
      }
      for ( ii = 0; ii < *(_DWORD *)(v25 + 4); ++ii )
      {
        v8 = *(_QWORD *)(8LL * ii + *(_QWORD *)(v25 + 8));
        *(_BYTE *)(v8 + 64) &= 0xBFu;
      }
      sub_F0B0(v24, v25);
      for ( jj = *(_DWORD *)(v25 + 4); ; sub_A9496(*(_QWORD *)(8LL * jj + *(_QWORD *)(v25 + 8))) )
      {
        v9 = jj--;
        if ( !v9 )
          break;
      }
      for ( kk = 0; kk < *(_DWORD *)(v25 + 4); ++kk )
      {
        v23 = *(_QWORD *)(8LL * kk + *(_QWORD *)(v25 + 8));
        *(_BYTE *)(v23 + 64) |= 0x40u;
        for ( ll = 0; ll < *(unsigned __int8 *)(v23 + 70); ++ll )
        {
          v10 = *(_QWORD *)(*(_QWORD *)(v23 + 104) + 48LL * ll);
          *(_BYTE *)(v10 + 64) |= 0x40u;
        }
      }
      ly_set_free(v25);
      ++*(_WORD *)(v24 + 90);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_set_disabled", v6);
    result = 1LL;
  }
  return result;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000FD3F) ----------------------------------------------------
__int64 __fastcall sub_FD3F(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  unsigned int i; // [rsp+1Ch] [rbp-4h]
  unsigned int j; // [rsp+1Ch] [rbp-4h]

  ly_set_add(a1, a2, 0LL);
  *(_BYTE *)(a2 + 64) &= 0xBFu;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 70); ++i )
  {
    v2 = *(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i);
    *(_BYTE *)(v2 + 64) &= 0xBFu;
  }
  for ( j = 0; ; ++j )
  {
    result = *(unsigned __int8 *)(a2 + 69);
    if ( j >= (unsigned int)result )
      break;
    if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 96) + 56LL * j) + 64LL) & 0x40 )
      sub_FD3F(a1, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 56LL * j));
  }
  return result;
}
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000000FE35) ----------------------------------------------------
signed __int64 __fastcall lys_set_enabled(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  signed int i; // [rsp+10h] [rbp-30h]
  int j; // [rsp+10h] [rbp-30h]
  unsigned int k; // [rsp+14h] [rbp-2Ch]
  unsigned int v17; // [rsp+14h] [rbp-2Ch]
  unsigned int l; // [rsp+18h] [rbp-28h]
  unsigned int n; // [rsp+18h] [rbp-28h]
  unsigned int m; // [rsp+1Ch] [rbp-24h]
  __int64 v21; // [rsp+20h] [rbp-20h]
  __int64 v22; // [rsp+28h] [rbp-18h]
  __int64 v23; // [rsp+30h] [rbp-10h]
  __int64 v24; // [rsp+38h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"lys_set_enabled", a4, a5, a6);
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 64) & 0x40 )
    {
      v22 = *(_QWORD *)a1;
      for ( i = 0; i < *(unsigned __int8 *)(v22 + 132); ++i )
      {
        if ( a1 == *(_QWORD *)(8LL * i + *(_QWORD *)(v22 + 64)) )
        {
          sub_12222(v22, 0, 3, "Internal module \"%s\" cannot be removed.", *(_QWORD *)(a1 + 8), v6);
          return 1LL;
        }
      }
      v23 = ly_set_new(32LL);
      v24 = ly_set_new(32LL);
      v8 = a1;
      sub_FD3F(v23, a1);
LABEL_11:
      for ( j = *(unsigned __int8 *)(v22 + 132); j < *(_DWORD *)(v22 + 60); ++j )
      {
        v9 = 8LL * j;
        v21 = *(_QWORD *)(v9 + *(_QWORD *)(v22 + 64));
        if ( *(_BYTE *)(v21 + 64) & 0x40 )
        {
          v8 = *(_QWORD *)(v9 + *(_QWORD *)(v22 + 64));
          if ( (unsigned int)ly_set_contains(v24, v21) == -1 )
          {
            for ( k = 0; k < *(unsigned __int8 *)(v21 + 69); ++k )
            {
              v10 = *(_QWORD *)(v21 + 96);
              v9 = k;
              if ( *(_BYTE *)(*(_QWORD *)(v10 + 56LL * k) + 64LL) & 0x40 )
                break;
            }
            if ( k >= *(unsigned __int8 *)(v21 + 69) )
            {
              v17 = 0;
LABEL_29:
              if ( v17 < *(unsigned __int8 *)(v21 + 69) )
              {
                for ( l = 0; ; ++l )
                {
                  if ( l >= *(_DWORD *)(v23 + 4) )
                  {
                    ++v17;
                    goto LABEL_29;
                  }
                  if ( *(_QWORD *)(*(_QWORD *)(v21 + 96) + 56LL * v17) == *(_QWORD *)(8LL * l + *(_QWORD *)(v23 + 8)) )
                    break;
                }
                *(_BYTE *)(v21 + 64) &= 0xBFu;
                v8 = v21;
                ly_set_add(v23, v21, 0LL);
                for ( m = 0; m < *(unsigned __int8 *)(v21 + 70); ++m )
                {
                  v10 = *(_QWORD *)(v21 + 104);
                  v13 = *(_QWORD *)(v10 + 48LL * m);
                  v9 = *(_BYTE *)(v13 + 64) & 0xBF;
                  *(_BYTE *)(v13 + 64) &= 0xBFu;
                }
                goto LABEL_11;
              }
              v8 = v21;
              ly_set_add(v24, v21, 0LL);
            }
          }
        }
      }
      sub_F559(v23, v8, v9, v10, v11, v12);
      for ( n = 0; n < *(_DWORD *)(v23 + 4); ++n )
      {
        if ( *(_BYTE *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v23 + 8)) + 64LL) < 0 )
          sub_A91FC(*(_QWORD *)(8LL * n + *(_QWORD *)(v23 + 8)));
      }
      ly_set_free(v23);
      ly_set_free(v24);
      ++*(_WORD *)(v22 + 90);
      result = 0LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_set_enabled", v6);
    result = 1LL;
  }
  return result;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 74C0: using guessed type __int64 __fastcall ly_set_contains(_QWORD, _QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000101CE) ----------------------------------------------------
signed __int64 __fastcall ly_ctx_remove_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  void (__fastcall *v8)(void **, void *); // [rsp+0h] [rbp-40h]
  unsigned __int8 l; // [rsp+1Ah] [rbp-26h]
  unsigned __int8 ii; // [rsp+1Ah] [rbp-26h]
  char v11; // [rsp+1Bh] [rbp-25h]
  signed int i; // [rsp+1Ch] [rbp-24h]
  int j; // [rsp+1Ch] [rbp-24h]
  int k; // [rsp+1Ch] [rbp-24h]
  int jj; // [rsp+1Ch] [rbp-24h]
  int n; // [rsp+20h] [rbp-20h]
  int v17; // [rsp+20h] [rbp-20h]
  unsigned int m; // [rsp+24h] [rbp-1Ch]
  unsigned int kk; // [rsp+24h] [rbp-1Ch]
  __int64 v20; // [rsp+28h] [rbp-18h]
  __int64 v21; // [rsp+30h] [rbp-10h]
  __int64 v22; // [rsp+38h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_remove_module", a4, a5, a6, a2);
  if ( a1 )
  {
    v21 = *a1;
    for ( i = 0; i < *(unsigned __int8 *)(v21 + 132); ++i )
    {
      if ( a1 == *(__int64 **)(8LL * i + *(_QWORD *)(v21 + 64)) )
      {
        sub_12222(v21, 0, 3, "Internal module \"%s\" cannot be removed.", a1[1], v6);
        return 1LL;
      }
    }
    for ( j = *(unsigned __int8 *)(v21 + 132); j < *(_DWORD *)(v21 + 60); ++j )
    {
      if ( a1 == *(__int64 **)(8LL * j + *(_QWORD *)(v21 + 64)) )
      {
        *(_QWORD *)(8LL * j + *(_QWORD *)(v21 + 64)) = 0LL;
        break;
      }
    }
    v22 = ly_set_new(32LL);
    ly_set_add(v22, a1, 0LL);
LABEL_14:
    for ( k = *(unsigned __int8 *)(v21 + 132); k < *(_DWORD *)(v21 + 60); ++k )
    {
      v20 = *(_QWORD *)(8LL * k + *(_QWORD *)(v21 + 64));
      if ( v20 )
      {
        for ( l = 0; l < *(_BYTE *)(v20 + 69); ++l )
        {
          for ( m = 0; m < *(_DWORD *)(v22 + 4); ++m )
          {
            if ( *(_QWORD *)(*(_QWORD *)(v20 + 96) + 56LL * l) == *(_QWORD *)(8LL * m + *(_QWORD *)(v22 + 8)) )
            {
              ly_set_add(v22, v20, 0LL);
              *(_QWORD *)(8LL * k + *(_QWORD *)(v21 + 64)) = 0LL;
              goto LABEL_14;
            }
          }
        }
        if ( *(_BYTE *)(v20 + 64) >= 0 )
        {
          v11 = 0;
          for ( n = *(unsigned __int8 *)(v21 + 132); n < *(_DWORD *)(v21 + 60); ++n )
          {
            if ( *(_QWORD *)(8LL * n + *(_QWORD *)(v21 + 64)) )
            {
              for ( ii = 0; ii < *(_BYTE *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v21 + 64)) + 69LL); ++ii )
              {
                if ( v20 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v21 + 64)) + 96LL) + 56LL * ii) )
                {
                  v11 = 1;
                  goto LABEL_34;
                }
              }
            }
          }
LABEL_34:
          if ( !v11 )
          {
            ly_set_add(v22, v20, 0LL);
            *(_QWORD *)(8LL * k + *(_QWORD *)(v21 + 64)) = 0LL;
            if ( *(_BYTE *)(v20 + 69) )
              goto LABEL_14;
          }
        }
      }
    }
    v17 = *(unsigned __int8 *)(v21 + 132);
    for ( jj = *(unsigned __int8 *)(v21 + 132); jj < *(_DWORD *)(v21 + 60); ++jj )
    {
      if ( *(_QWORD *)(8LL * v17 + *(_QWORD *)(v21 + 64)) )
      {
        ++v17;
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(v21 + 64) + 8LL * v17) = *(_QWORD *)(*(_QWORD *)(v21 + 64) + 8LL * jj);
        *(_QWORD *)(8LL * jj + *(_QWORD *)(v21 + 64)) = 0LL;
      }
    }
    while ( !*(_QWORD *)(8LL * v17 + *(_QWORD *)(v21 + 64)) )
      --v17;
    *(_DWORD *)(v21 + 60) = v17 + 1;
    ++*(_WORD *)(v21 + 90);
    sub_F0B0(v21, v22);
    for ( kk = 0; kk < *(_DWORD *)(v22 + 4); ++kk )
    {
      sub_A9496(*(_QWORD *)(8LL * kk + *(_QWORD *)(v22 + 8)));
      sub_A67C8(*(unsigned __int8 **)(8LL * kk + *(_QWORD *)(v22 + 8)), v8, 1, 0);
    }
    ly_set_free(v22);
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_remove_module", v6);
    result = 1LL;
  }
  return result;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000106CA) ----------------------------------------------------
unsigned __int64 __fastcall ly_ctx_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  void (__fastcall *v7)(void **, void *); // [rsp+0h] [rbp-10h]

  result = sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_clean", a4, a5, a6, a2);
  if ( a1 )
  {
    while ( *(_DWORD *)(a1 + 60) > (signed int)*(unsigned __int8 *)(a1 + 132) )
    {
      sub_A9496(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8));
      sub_A67C8(*(unsigned __int8 **)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8), v7, 1, 0);
      *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * (signed int)(*(_DWORD *)(a1 + 60))-- - 8) = 0LL;
    }
    ++*(_WORD *)(a1 + 90);
    result = sub_F0B0(a1, 0LL);
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000107DD) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module_iter(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // rsi
  unsigned int v9; // eax
  _DWORD *v10; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_iter", a4, a5, a6, a2);
  if ( a1 && v10 )
  {
    while ( *v10 < *(_DWORD *)(a1 + 60) )
    {
      if ( !(*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * (unsigned int)*v10) + 64LL) & 0x40) )
      {
        v8 = *(_QWORD *)(a1 + 64);
        v9 = (*v10)++;
        return *(_QWORD *)(v8 + 8LL * v9);
      }
      ++*v10;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_iter", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000108BB) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_disabled_module_iter(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // rsi
  unsigned int v9; // eax
  _DWORD *v10; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_disabled_module_iter", a4, a5, a6, a2);
  if ( a1 && v10 )
  {
    while ( *v10 < *(_DWORD *)(a1 + 60) )
    {
      if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * (unsigned int)*v10) + 64LL) & 0x40 )
      {
        v8 = *(_QWORD *)(a1 + 64);
        v9 = (*v10)++;
        return *(_QWORD *)(v8 + 8LL * v9);
      }
      ++*v10;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_disabled_module_iter", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000010999) ----------------------------------------------------
signed __int64 __fastcall sub_10999(__int64 a1, __int64 a2)
{
  signed int i; // [rsp+18h] [rbp-8h]
  signed int j; // [rsp+18h] [rbp-8h]
  signed int k; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a2 + 76); ++i )
  {
    if ( *(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(a2 + 128) + 24) & 0x100
      && !lyd_new_leaf(a1, 0LL, "feature", *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(a2 + 128))) )
    {
      return 1LL;
    }
  }
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 70) && *(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j); ++j )
  {
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 76LL); ++k )
    {
      if ( *(_WORD *)(((signed __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 128LL) + 24) & 0x100
        && !lyd_new_leaf(
              a1,
              0LL,
              "feature",
              *(_QWORD *)(((signed __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 128LL))) )
      {
        return 1LL;
      }
    }
  }
  return 0LL;
}
// 7260: using guessed type __int64 __fastcall lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000010B6F) ----------------------------------------------------
signed __int64 __fastcall sub_10B6F(__int64 a1, __int64 a2, int a3)
{
  size_t v3; // rax
  void *v5; // rax
  int v6; // [rsp+Ch] [rbp-44h]
  int v7; // [rsp+28h] [rbp-28h]
  unsigned int i; // [rsp+2Ch] [rbp-24h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  char *v10; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v12 = __readfsqword(0x28u);
  v7 = 0;
  if ( *(_BYTE *)(a2 + 64) & 0x30 )
  {
LABEL_21:
    while ( 1 )
    {
      v9 = ly_ctx_get_module_iter(*(_QWORD *)a2, &v7);
      if ( !v9 )
        break;
      if ( v9 != a2 )
      {
        for ( i = 0; i < *(unsigned __int8 *)(v9 + 78); ++i )
        {
          v10 = strstr(*(const char **)(*(_QWORD *)(v9 + 144) + 56LL * i), *(const char **)(a2 + 8));
          if ( v10 )
          {
            v3 = strlen(*(const char **)(a2 + 8));
            if ( v10[v3] == 58 )
            {
              if ( v6 )
              {
                if ( lyd_new_leaf(a1, 0LL, "deviation", *(_QWORD *)(v9 + 8)) )
                  goto LABEL_21;
                return 1LL;
              }
              v11 = lyd_new(a1, 0LL, "deviation");
              if ( !v11 )
                return 1LL;
              if ( !lyd_new_leaf(v11, 0LL, "name", *(_QWORD *)(v9 + 8)) )
                return 1LL;
              if ( *(_BYTE *)(v9 + 68) )
                v5 = *(void **)(v9 + 88);
              else
                v5 = &unk_1086CA;
              if ( !lyd_new_leaf(v11, 0LL, "revision", v5) )
                return 1LL;
              goto LABEL_21;
            }
          }
        }
      }
    }
  }
  return 0LL;
}
// 7260: using guessed type __int64 __fastcall lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7AE0: using guessed type __int64 __fastcall lyd_new(_QWORD, _QWORD, _QWORD);

//----- (0000000000010D68) ----------------------------------------------------
signed __int64 __fastcall sub_10D68(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rax
  __int64 v5; // r9
  const char *v6; // rax
  int v7; // [rsp+Ch] [rbp-34h]
  signed int i; // [rsp+24h] [rbp-1Ch]
  char *ptr; // [rsp+28h] [rbp-18h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v11 = __readfsqword(0x28u);
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 70) && *(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i); ++i )
  {
    v10 = lyd_new(a1, 0LL, "submodule");
    if ( !v10 )
      return 1LL;
    if ( !lyd_new_leaf(v10, 0LL, "name", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 8LL)) )
      return 1LL;
    if ( !v7 || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 68LL) )
    {
      v4 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 68LL) ? *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i)
                                                                                        + 88LL) : &unk_1086CA;
      if ( !lyd_new_leaf(v10, 0LL, "revision", v4) )
        return 1LL;
    }
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 56LL) )
    {
      if ( asprintf(&ptr, "file://%s", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 56LL)) == -1 )
      {
        sub_12222(*(_QWORD *)a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"ylib_submodules", v5);
        return 1LL;
      }
      if ( v7 )
        v6 = "location";
      else
        v6 = "schema";
      if ( !lyd_new_leaf(v10, 0LL, v6, ptr) )
      {
        free(ptr);
        return 1LL;
      }
      free(ptr);
    }
  }
  return 0LL;
}
// 7260: using guessed type __int64 __fastcall lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);
// 7AE0: using guessed type __int64 __fastcall lyd_new(_QWORD, _QWORD, _QWORD);

//----- (0000000000011010) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_module_set_id(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_set_id", a4, a5, a6);
  return *(unsigned __int16 *)(a1 + 90);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000011043) ----------------------------------------------------
__int64 __fastcall ly_ctx_info(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // r9
  char *v12; // rax
  __int64 v13; // r9
  int i; // [rsp+18h] [rbp-48h]
  signed int v15; // [rsp+1Ch] [rbp-44h]
  char *ptr; // [rsp+20h] [rbp-40h]
  __int64 v17; // [rsp+28h] [rbp-38h]
  __int64 v18; // [rsp+30h] [rbp-30h]
  __int64 v19; // [rsp+38h] [rbp-28h]
  __int64 v20; // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  char s; // [rsp+50h] [rbp-10h]
  unsigned __int64 v23; // [rsp+58h] [rbp-8h]

  v23 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_info", a4, a5, a6);
  v18 = 0LL;
  v19 = 0LL;
  v20 = 0LL;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_info", v6);
    return 0LL;
  }
  v21 = ly_ctx_get_module(a1, "ietf-yang-library", 0LL, 1LL);
  if ( !v21 || !*(_QWORD *)(v21 + 168) )
  {
    sub_12222(a1, 0, 3, "ietf-yang-library is not implemented.", v8, v9);
    return 0LL;
  }
  if ( *(_QWORD *)(v21 + 88) && !strcmp(*(const char **)(v21 + 88), "2016-04-09") )
  {
    v15 = 0;
  }
  else
  {
    if ( !*(_QWORD *)(v21 + 88) || strcmp(*(const char **)(v21 + 88), "2019-01-04") )
    {
      sub_12222(a1, 0, 3, "Incompatible ietf-yang-library version in context.", v8, v9);
      return 0LL;
    }
    v15 = 1;
  }
  v17 = lyd_new(0LL, v21, "modules-state");
  if ( !v17 )
    return 0LL;
  if ( v15 )
  {
    v18 = lyd_new(0LL, v21, "yang-library");
    if ( !v18 )
      goto LABEL_71;
    v20 = lyd_new(v18, 0LL, "module-set");
    if ( !v20 || !lyd_new_leaf(v20, 0LL, "name", "complete") )
      goto LABEL_71;
  }
  for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
  {
    if ( !(*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) & 0x40) )
    {
      v19 = lyd_new(v17, 0LL, "module");
      if ( !v19 || !lyd_new_leaf(v19, 0LL, "name", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 8LL)) )
        goto LABEL_71;
      v10 = *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL) ? *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64))
                                                                                       + 88LL) : &unk_1086CA;
      if ( !lyd_new_leaf(v19, 0LL, "revision", v10) )
        goto LABEL_71;
      if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL) )
      {
        if ( asprintf(&ptr, "file://%s", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL)) == -1 )
        {
          sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_info", v11);
          goto LABEL_71;
        }
        if ( !lyd_new_leaf(v19, 0LL, "schema", ptr) )
        {
          free(ptr);
          goto LABEL_71;
        }
        free(ptr);
      }
      if ( !lyd_new_leaf(v19, 0LL, "namespace", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 176LL))
        || (unsigned int)sub_10999(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)))
        || (unsigned int)sub_10B6F(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 0) )
      {
        goto LABEL_71;
      }
      v12 = *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) >= 0 ? "import" : "implement";
      if ( !lyd_new_leaf(v19, 0LL, "conformance-type", v12)
        || (unsigned int)sub_10D68(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 0) )
      {
        goto LABEL_71;
      }
      if ( v15 )
      {
        if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) >= 0 )
        {
          v19 = lyd_new(v20, 0LL, "import-only-module");
          if ( !v19 )
            goto LABEL_71;
        }
        else
        {
          v19 = lyd_new(v20, 0LL, "module");
          if ( !v19 )
            goto LABEL_71;
        }
        if ( !lyd_new_leaf(v19, 0LL, "name", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 8LL))
          || (*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) >= 0
           || *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL))
          && !lyd_new_leaf(v19, 0LL, "revision", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 88LL))
          || !lyd_new_leaf(v19, 0LL, "namespace", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 176LL)) )
        {
          goto LABEL_71;
        }
        if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL) )
        {
          if ( asprintf(&ptr, "file://%s", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL)) == -1 )
          {
            sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_info", v13);
            goto LABEL_71;
          }
          if ( !lyd_new_leaf(v19, 0LL, "location", ptr) )
          {
            free(ptr);
            goto LABEL_71;
          }
          free(ptr);
        }
        if ( (unsigned int)sub_10D68(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 1)
          || *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) < 0
          && ((unsigned int)sub_10999(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)))
           || (unsigned int)sub_10B6F(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 1)) )
        {
          goto LABEL_71;
        }
      }
    }
  }
  sprintf(&s, "%u", *(unsigned __int16 *)(a1 + 90));
  if ( !lyd_new_leaf(v17, 0LL, "module-set-id", &s) || v15 && !lyd_new_leaf(v18, 0LL, "content-id", &s) )
    goto LABEL_71;
  if ( v18 )
  {
    if ( (unsigned int)lyd_insert_sibling(&v18, v17) )
      goto LABEL_71;
    v17 = v18;
    v18 = 0LL;
  }
  if ( !(unsigned int)lyd_validate(&v17, 4096LL, 0LL) )
    return v17;
LABEL_71:
  lyd_free_withsiblings(v17);
  lyd_free_withsiblings(v18);
  return 0LL;
}
// 7260: using guessed type __int64 __fastcall lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 78B0: using guessed type __int64 __fastcall lyd_validate(_QWORD, _QWORD, _QWORD);
// 79D0: using guessed type __int64 __fastcall lyd_insert_sibling(_QWORD, _QWORD);
// 7AE0: using guessed type __int64 __fastcall lyd_new(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000119D0) ----------------------------------------------------
__int64 __fastcall ly_ctx_get_node(void *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  int v8; // [rsp+4h] [rbp-2Ch]
  char *v9; // [rsp+8h] [rbp-28h]
  void *v10; // [rsp+18h] [rbp-18h]

  v10 = a1;
  v9 = a3;
  v8 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_node", a4, a5, a6);
  if ( (a1 || a2) && v9 && (*v9 == 47 || a2) )
  {
    if ( !a1 )
      v10 = **(void ***)(a2 + 48);
    result = sub_1B854(v9, v10, a2, v8);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_node", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000011A90) ----------------------------------------------------
__int64 __fastcall ly_ctx_find_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  char *v8; // [rsp+0h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-10h]
  unsigned __int64 v10; // [rsp+18h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_find_path", a4, a5, a6, a2);
  v9 = 0LL;
  if ( a1 && v8 )
  {
    sub_1A193(v8, 0LL, **(_QWORD **)(a1 + 64), &v9, 1, 1);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_find_path", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000011B56) ----------------------------------------------------
__int64 __fastcall ly_verb(char a1)
{
  unsigned int v1; // ST14_4

  v1 = (unsigned __int8)byte_3458A0;
  byte_3458A0 = a1;
  return v1;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000011B78) ----------------------------------------------------
__int64 __fastcall ly_log_options(char a1)
{
  unsigned __int8 v1; // ST17_1

  v1 = byte_3458A1;
  byte_3458A1 = a1;
  return v1;
}
// 3458A1: using guessed type char byte_3458A1;

//----- (0000000000011B98) ----------------------------------------------------
__int64 __fastcall ly_verb_dbg(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  dword_347048 = a1;
  return result;
}
// 347048: using guessed type int dword_347048;

//----- (0000000000011BAB) ----------------------------------------------------
__int64 __fastcall ly_set_log_clb(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  qword_347050 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))a1;
  result = a2;
  dword_3458A4 = a2;
  return result;
}
// 3458A4: using guessed type int dword_3458A4;
// 347050: using guessed type __int64 (__fastcall *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000011BCD) ----------------------------------------------------
__int64 (__fastcall *ly_get_log_clb())(_QWORD, _QWORD, _QWORD)
{
  return qword_347050;
}
// 347050: using guessed type __int64 (__fastcall *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000011BDA) ----------------------------------------------------
__int64 __fastcall sub_11BDA(void *a1, unsigned int a2, int a3, int a4, void *a5, void *a6, void *a7)
{
  __int64 v7; // r9
  void *v9; // [rsp+8h] [rbp-38h]
  void *ptr; // [rsp+10h] [rbp-30h]
  int v11; // [rsp+1Ch] [rbp-24h]
  int v12; // [rsp+20h] [rbp-20h]
  _DWORD *pointer; // [rsp+30h] [rbp-10h]
  void *pointera; // [rsp+30h] [rbp-10h]
  __int64 v15; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  ptr = a5;
  v9 = a6;
  if ( !a1 || a2 > 1 )
    __assert_fail("ctx && (level < LY_LLVRB)", "/home/mantovan/Repositories/libyang/src/log.c", 0x55u, "log_store");
  pointer = pthread_getspecific(*((_DWORD *)a1 + 32));
  if ( !pointer )
  {
    if ( !ptr )
      __assert_fail("msg", "/home/mantovan/Repositories/libyang/src/log.c", 0x5Au, "log_store");
    pointer = malloc(0x38uLL);
    if ( pointer )
    {
      *((_QWORD *)pointer + 6) = pointer;
      *((_QWORD *)pointer + 5) = 0LL;
      pthread_setspecific(*((_DWORD *)a1 + 32), pointer);
LABEL_22:
      *pointer = a2;
      pointer[1] = v12;
      pointer[2] = v11;
      *((_QWORD *)pointer + 2) = ptr;
      *((_QWORD *)pointer + 3) = v9;
      *((_QWORD *)pointer + 4) = a7;
      return 0LL;
    }
LABEL_23:
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"log_store", v7);
    free(ptr);
    free(v9);
    free(a7);
    return 0xFFFFFFFFLL;
  }
  if ( ptr )
  {
    if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 && (byte_3458A1 & 6) == 6 )
    {
      free(*((void **)pointer + 2));
      free(*((void **)pointer + 3));
      free(*((void **)pointer + 4));
      goto LABEL_22;
    }
    v15 = *((_QWORD *)pointer + 6);
    *((_QWORD *)pointer + 6) = malloc(0x38uLL);
    if ( *((_QWORD *)pointer + 6) )
    {
      pointer = (_DWORD *)*((_QWORD *)pointer + 6);
      *((_QWORD *)pointer + 6) = v15;
      *((_QWORD *)pointer + 5) = 0LL;
      *(_QWORD *)(v15 + 40) = pointer;
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  if ( !v9 )
    __assert_fail("path", "/home/mantovan/Repositories/libyang/src/log.c", 0x65u, "log_store");
  pointera = (void *)*((_QWORD *)pointer + 6);
  while ( *(_DWORD *)pointera )
  {
    pointera = (void *)*((_QWORD *)pointera + 6);
    if ( !*(_QWORD *)(*((_QWORD *)pointera + 6) + 40LL) )
      __assert_fail("0", "/home/mantovan/Repositories/libyang/src/log.c", 0x73u, "log_store");
  }
  free(*((void **)pointera + 3));
  *((_QWORD *)pointera + 3) = v9;
  return 0LL;
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;
// 3458A1: using guessed type char byte_3458A1;

//----- (0000000000011EB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_11EB0(void *a1, unsigned int a2, int a3, int a4, void *a5, char *a6, void *a7)
{
  __int64 v7; // r9
  __int64 v8; // r9
  void *__ptr32 *v9; // rax
  const char *f; // [rsp+8h] [rbp-48h]
  void *ptr; // [rsp+10h] [rbp-40h]
  int v13; // [rsp+1Ch] [rbp-34h]
  int v14; // [rsp+20h] [rbp-30h]
  unsigned int v15; // [rsp+24h] [rbp-2Ch]
  signed int v16; // [rsp+3Ch] [rbp-14h]
  char *v17; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v15 = a2;
  v14 = a3;
  v13 = a4;
  ptr = a5;
  f = a6;
  v18 = __readfsqword(0x28u);
  v17 = 0LL;
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) == 3 && !a2 )
    v15 = 1;
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) == 2 || v15 > (unsigned __int8)byte_3458A0 )
  {
    free(ptr);
    return __readfsqword(0x28u) ^ v18;
  }
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 && v14 )
    *(_DWORD *)ly_errno_glob_address(&stru_335FC0) = v14;
  if ( v14 == 5 && !v13 )
    v13 = ly_vecode(a1);
  if ( v15 > 1 || !a1 || !(byte_3458A1 & 2) && *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
  {
    if ( vasprintf(&v17, f, a7) == -1 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"log_vprintf", v8, a7);
      free(ptr);
      return __readfsqword(0x28u) ^ v18;
    }
    v16 = 1;
    goto LABEL_29;
  }
  if ( f )
  {
    if ( vasprintf(&v17, f, a7) == -1 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"log_vprintf", v7, a7);
      free(ptr);
      return __readfsqword(0x28u) ^ v18;
    }
    if ( (unsigned int)sub_11BDA(a1, v15, v14, v13, v17, ptr, 0LL) )
      return __readfsqword(0x28u) ^ v18;
    goto LABEL_25;
  }
  if ( !ptr )
    __assert_fail("path", "/home/mantovan/Repositories/libyang/src/log.c", 0xB7u, "log_vprintf");
  if ( !(unsigned int)sub_11BDA(a1, v15, v14, v13, 0LL, ptr, 0LL) )
  {
    v17 = "Path is related to the previous error message.";
LABEL_25:
    v16 = 0;
LABEL_29:
    if ( byte_3458A1 & 1 && *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
    {
      if ( qword_347050 )
      {
        qword_347050(v15, v17, ptr);
      }
      else
      {
        if ( ptr )
          v9 = &off_108D8F;
        else
          v9 = (void *__ptr32 *)((char *)&off_108D8F + 2);
        fprintf(stderr, "libyang[%d]: %s%s", v15, v17, v9);
        if ( ptr )
          fprintf(stderr, "(path: %s)\n", ptr);
      }
    }
    if ( v16 )
    {
      free(ptr);
      free(v17);
    }
  }
  return __readfsqword(0x28u) ^ v18;
}
// 71B0: using guessed type __int64 __fastcall ly_vecode(_QWORD);
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 108D8F: using guessed type void *__ptr32 off_108D8F;
// 335FC0: using guessed type tls_index_local stru_335FC0;
// 3458A0: using guessed type char byte_3458A0;
// 3458A1: using guessed type char byte_3458A1;
// 347050: using guessed type __int64 (__fastcall *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000012222) ----------------------------------------------------
unsigned __int64 sub_12222(__int64 a1, unsigned int a2, int a3, char *a4, __int64 a5, __int64 a6, ...)
{
  gcc_va_list va; // [rsp+20h] [rbp-D0h]
  unsigned __int64 v8; // [rsp+38h] [rbp-B8h]
  __int64 v9; // [rsp+60h] [rbp-90h]
  __int64 v10; // [rsp+68h] [rbp-88h]

  va_start(va, a6);
  v9 = a5;
  v10 = a6;
  v8 = __readfsqword(0x28u);
  va[0].gp_offset = 32;
  sub_11EB0((void *)a1, a2, a3, 0, 0LL, a4, va);
  return __readfsqword(0x28u) ^ v8;
}

//----- (0000000000012312) ----------------------------------------------------
unsigned __int64 sub_12312(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  __int64 v6; // r9
  char *ptr; // [rsp+10h] [rbp-E0h]
  const char *v9; // [rsp+18h] [rbp-D8h]
  gcc_va_list va; // [rsp+20h] [rbp-D0h]
  unsigned __int64 v11; // [rsp+38h] [rbp-B8h]
  __int64 v12; // [rsp+50h] [rbp-A0h]
  __int64 v13; // [rsp+58h] [rbp-98h]
  __int64 v14; // [rsp+60h] [rbp-90h]
  __int64 v15; // [rsp+68h] [rbp-88h]

  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  v11 = __readfsqword(0x28u);
  if ( a1 & dword_347048 )
  {
    switch ( (unsigned __int64)a1 )
    {
      case 1uLL:
        v9 = "DICT";
        goto LABEL_11;
      case 2uLL:
        v9 = "YANG";
        goto LABEL_11;
      case 4uLL:
        v9 = "YIN";
        goto LABEL_11;
      case 8uLL:
        v9 = "XPATH";
        goto LABEL_11;
      case 0x10uLL:
        v9 = "DIFF";
        goto LABEL_11;
      case 0x20uLL:
        v9 = "API";
        goto LABEL_11;
      case 0x40uLL:
        v9 = "HASH";
LABEL_11:
        if ( asprintf(&ptr, "%s: %s", v9, a2) == -1 )
        {
          sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_log_dbg", v6, a2);
        }
        else
        {
          va[0].gp_offset = 16;
          va_start(va, a6);
          sub_11EB0(0LL, 3u, 0, 0, 0LL, ptr, va);
          free(ptr);
        }
        break;
      default:
        sub_12222(
          0LL,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/log.c",
          273LL,
          a2);
        break;
    }
  }
  return __readfsqword(0x28u) ^ v11;
}
// 347048: using guessed type int dword_347048;

//----- (0000000000012554) ----------------------------------------------------
unsigned __int64 lyext_log(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  __int64 v6; // r9
  int v7; // edi
  void *v9; // [rsp+28h] [rbp-E8h]
  int v10; // [rsp+34h] [rbp-DCh]
  char *ptr; // [rsp+38h] [rbp-D8h]
  gcc_va_list va; // [rsp+40h] [rbp-D0h]
  unsigned __int64 v13; // [rsp+58h] [rbp-B8h]
  __int64 v14; // [rsp+88h] [rbp-88h]

  v9 = (void *)a1;
  v14 = a6;
  v13 = __readfsqword(0x28u);
  if ( a2 <= (unsigned __int8)byte_3458A0 )
  {
    if ( a3 )
      v10 = asprintf(&ptr, "%s (reported by plugin %s, %s())", a5, a3, a4);
    else
      v10 = asprintf(&ptr, "%s", a5);
    if ( v10 == -1 )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyext_log", v6);
    }
    else
    {
      va[0].gp_offset = 40;
      va_start(va, a6);
      if ( a2 )
        v7 = 0;
      else
        v7 = 6;
      sub_11EB0(v9, a2, v7, 0, 0LL, ptr, va);
      free(ptr);
    }
  }
  return __readfsqword(0x28u) ^ v13;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000012724) ----------------------------------------------------
unsigned __int64 lyext_vlog(void *a1, int a2, __int64 a3, __int64 a4, int a5, char *a6, __int64 a7, ...)
{
  __int64 v7; // r9
  __int64 v9; // [rsp+10h] [rbp-110h]
  __int64 v10; // [rsp+18h] [rbp-108h]
  int v11; // [rsp+30h] [rbp-F0h]
  unsigned int v12; // [rsp+34h] [rbp-ECh]
  char *ptr; // [rsp+38h] [rbp-E8h]
  void *v14; // [rsp+40h] [rbp-E0h]
  __int64 v15; // [rsp+48h] [rbp-D8h]
  gcc_va_list va; // [rsp+50h] [rbp-D0h]
  unsigned __int64 v17; // [rsp+68h] [rbp-B8h]

  v10 = a3;
  v9 = a4;
  v17 = __readfsqword(0x28u);
  v12 = dword_3458B0[a5];
  v14 = 0LL;
  if ( dword_3458A4 && v12 )
  {
    if ( v12 == 5 )
    {
      v15 = ly_err_first(a1);
      if ( v15 && *(_QWORD *)(*(_QWORD *)(v15 + 48) + 24LL) )
        v14 = strdup(*(const char **)(*(_QWORD *)(v15 + 48) + 24LL));
    }
    else if ( a6 )
    {
      sub_12B3E(v12, a6, &v14, 0, 0);
    }
    else
    {
      v14 = strdup("/");
    }
  }
  if ( v10 )
    v11 = asprintf(&ptr, "%s (reported by plugin %s, %s())", a7, v10, v9);
  else
    v11 = asprintf(&ptr, "%s", a7);
  if ( v11 == -1 )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyext_vlog", v7, a7);
    free(v14);
  }
  else
  {
    va_start(va, a7);
    sub_11EB0(a1, 0, 5, a2, v14, ptr, va);
    free(ptr);
  }
  return __readfsqword(0x28u) ^ v17;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 3458A4: using guessed type int dword_3458A4;

//----- (00000000000129CF) ----------------------------------------------------
signed __int64 __fastcall sub_129CF(void **a1, unsigned __int16 *a2, void *a3, unsigned __int16 a4, unsigned __int16 *a5)
{
  unsigned __int16 v5; // ax
  __int64 v6; // r9
  _WORD *v8; // [rsp+8h] [rbp-38h]
  unsigned __int16 v9; // [rsp+14h] [rbp-2Ch]
  void *src; // [rsp+18h] [rbp-28h]
  unsigned __int16 v11; // [rsp+36h] [rbp-Ah]
  void *v12; // [rsp+38h] [rbp-8h]

  src = a3;
  v8 = a5;
  v9 = a4;
  if ( a4 > *a2 )
  {
    v5 = 128;
    if ( a4 >= 0x80u )
      v5 = a4;
    v11 = v5;
    v12 = realloc(*a1, *a2 + *a5 + v5 + 1);
    if ( !v12 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_vlog_build_path_print", v6);
      return 0xFFFFFFFFLL;
    }
    *a1 = v12;
    memmove((char *)*a1 + *a2 + v11, (char *)*a1 + *a2, (unsigned __int16)*v8);
    *a2 += v11;
  }
  *a2 -= v9;
  memcpy((char *)*a1 + *a2, src, v9);
  *v8 += v9;
  return 0LL;
}

//----- (0000000000012B3E) ----------------------------------------------------
signed __int64 __fastcall sub_12B3E(unsigned int a1, char *a2, void **a3, int a4, int a5)
{
  __int64 v5; // r9
  signed __int64 result; // rax
  char *v7; // rax
  __int64 v8; // rax
  unsigned __int16 v9; // ax
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rax
  unsigned __int16 v13; // bx
  __int64 v14; // rax
  __int64 v15; // r9
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // ax
  unsigned __int16 v18; // ax
  int v19; // [rsp+4h] [rbp-ACh]
  void **v20; // [rsp+8h] [rbp-A8h]
  char *v21; // [rsp+10h] [rbp-A0h]
  int v22; // [rsp+18h] [rbp-98h]
  unsigned __int16 v23; // [rsp+28h] [rbp-88h]
  unsigned __int16 v24; // [rsp+2Ah] [rbp-86h]
  int j; // [rsp+2Ch] [rbp-84h]
  int v26; // [rsp+30h] [rbp-80h]
  int v27; // [rsp+34h] [rbp-7Ch]
  char *i; // [rsp+38h] [rbp-78h]
  __int64 k; // [rsp+40h] [rbp-70h]
  __int64 v30; // [rsp+48h] [rbp-68h]
  char *s; // [rsp+50h] [rbp-60h]
  char *v32; // [rsp+58h] [rbp-58h]
  char *v33; // [rsp+60h] [rbp-50h]
  char *v34; // [rsp+68h] [rbp-48h]
  size_t v35; // [rsp+70h] [rbp-40h]
  char *v36; // [rsp+78h] [rbp-38h]
  char *v37; // [rsp+80h] [rbp-30h]
  char *v38; // [rsp+88h] [rbp-28h]
  char *v39; // [rsp+90h] [rbp-20h]
  unsigned __int64 v40; // [rsp+98h] [rbp-18h]

  v21 = a2;
  v20 = a3;
  v22 = a4;
  v19 = a5;
  v40 = __readfsqword(0x28u);
  v27 = 0;
  i = 0LL;
  v30 = 0LL;
  v32 = 0LL;
  v23 = 0;
  *a3 = malloc(1uLL);
  if ( *v20 )
  {
    v24 = 0;
    while ( v21 )
    {
      if ( a1 == 2 )
      {
        if ( !v30 )
        {
          for ( i = v21; lys_parent(i); i = (char *)lys_parent(i) )
            ;
          v30 = lys_node_module(i);
        }
        for ( i = (char *)lys_parent(v21); i && *((_DWORD *)i + 14) == 4096; i = (char *)lys_parent(i) )
          ;
        if ( i && (v8 = lys_node_module(v21), v30 == v8) && !v22 )
          v32 = 0LL;
        else
          v32 = *(char **)(lys_node_module(v21) + 8);
        if ( *((_DWORD *)v21 + 14) & 0x2800 )
        {
          if ( (unsigned int)sub_129CF(v20, &v24, &unk_10A000, 1u, &v23) )
            return 0xFFFFFFFFLL;
          s = *(char **)v21;
          v9 = strlen(s);
          if ( (unsigned int)sub_129CF(v20, &v24, s, v9, &v23) )
            return 0xFFFFFFFFLL;
          if ( *((_DWORD *)v21 + 14) == 2048 )
            s = "{grouping}[";
          else
            s = "{augment}[";
        }
        else if ( *((_DWORD *)v21 + 14) == 0x10000 )
        {
          s = **(char ***)v21;
          if ( !strcmp(s, "yang-data") )
          {
            v27 = 1;
            s = (char *)*((_QWORD *)v21 + 2);
            v32 = *(char **)(lys_node_module(v21) + 8);
          }
        }
        else
        {
          s = *(char **)v21;
        }
        if ( *((_DWORD *)v21 + 14) == 0x10000 )
        {
          if ( v21[29] == 1 )
          {
            v21 = (char *)*((_QWORD *)v21 + 1);
          }
          else
          {
            i = 0LL;
            v21 = 0LL;
          }
        }
        else
        {
          do
          {
            i = (char *)*((_QWORD *)v21 + 8);
            v21 = (char *)lys_parent(v21);
          }
          while ( v21 && *((_DWORD *)v21 + 14) == 4096 );
        }
      }
      else if ( a1 > 2 )
      {
        if ( a1 != 3 )
        {
          if ( a1 != 4 )
          {
LABEL_116:
            sub_12222(
              0LL,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/log.c",
              814LL);
            return 0xFFFFFFFFLL;
          }
          v35 = strlen(v21);
          if ( (unsigned int)sub_129CF(v20, &v24, v21, v35, &v23) )
            return 0xFFFFFFFFLL;
          break;
        }
        s = **(char ***)v21;
        if ( *((_QWORD *)v21 + 5) && (v10 = lyd_node_module(v21), v10 == lyd_node_module(*((_QWORD *)v21 + 5))) )
          v32 = 0LL;
        else
          v32 = *(char **)(lyd_node_module(v21) + 8);
        if ( !v19 || v24 )
        {
          if ( *(_DWORD *)(*(_QWORD *)v21 + 56LL) == 16 )
          {
            v36 = v21;
            v37 = *(char **)v21;
            if ( v37[30] )
            {
              for ( j = (unsigned __int8)v37[30] - 1; j >= 0; --j )
              {
                for ( k = *((_QWORD *)v36 + 8);
                      k && *(_QWORD *)k != *(_QWORD *)(8LL * j + *((_QWORD *)v37 + 17));
                      k = *(_QWORD *)(k + 24) )
                {
                  ;
                }
                if ( k && *(_QWORD *)(k + 56) )
                {
                  if ( strchr(*(const char **)(k + 56), 39) )
                  {
                    v34 = "=\"";
                    v33 = "\"]";
                  }
                  else
                  {
                    v34 = "='";
                    v33 = "']";
                  }
                  if ( (unsigned int)sub_129CF(v20, &v24, v33, 2u, &v23) )
                    return 0xFFFFFFFFLL;
                  v35 = strlen(*(const char **)(k + 56));
                  if ( (unsigned int)sub_129CF(v20, &v24, *(void **)(k + 56), v35, &v23) )
                    return 0xFFFFFFFFLL;
                  if ( (unsigned int)sub_129CF(v20, &v24, v34, 2u, &v23) )
                    return 0xFFFFFFFFLL;
                  v35 = strlen(**(const char ***)k);
                  if ( (unsigned int)sub_129CF(v20, &v24, **(void ***)k, v35, &v23) )
                    return 0xFFFFFFFFLL;
                  v11 = lyd_node_module(v36);
                  if ( v11 != lyd_node_module(k) )
                  {
                    if ( (unsigned int)sub_129CF(v20, &v24, ":", 1u, &v23) )
                      return 0xFFFFFFFFLL;
                    v12 = lyd_node_module(k);
                    v35 = strlen(*(const char **)(v12 + 8));
                    v13 = v35;
                    v14 = lyd_node_module(k);
                    if ( (unsigned int)sub_129CF(v20, &v24, *(void **)(v14 + 8), v13, &v23) )
                      return 0xFFFFFFFFLL;
                  }
                  if ( (unsigned int)sub_129CF(v20, &v24, "[", 1u, &v23) )
                    return 0xFFFFFFFFLL;
                }
              }
            }
            else
            {
              v26 = lyd_list_pos(v36);
              j = v26;
              v35 = 1LL;
              while ( v26 > 9 )
              {
                ++v35;
                v26 /= 10;
              }
              if ( (unsigned int)sub_129CF(v20, &v24, &unk_10A000, 1u, &v23) )
                return 0xFFFFFFFFLL;
              v38 = (char *)malloc(v35 + 1);
              if ( !v38 )
              {
                sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_vlog_build_path", v15);
                return 0xFFFFFFFFLL;
              }
              sprintf(v38, "%d", (unsigned int)j);
              if ( (unsigned int)sub_129CF(v20, &v24, v38, v35, &v23) )
              {
                free(v38);
                return 0xFFFFFFFFLL;
              }
              free(v38);
              if ( (unsigned int)sub_129CF(v20, &v24, "[", 1u, &v23) )
                return 0xFFFFFFFFLL;
            }
          }
          else if ( *(_DWORD *)(*(_QWORD *)v21 + 56LL) == 8 && *((_QWORD *)v21 + 7) )
          {
            if ( strchr(*((const char **)v21 + 7), 39) )
            {
              v34 = "[.=\"";
              v33 = "\"]";
            }
            else
            {
              v34 = "[.='";
              v33 = "']";
            }
            if ( (unsigned int)sub_129CF(v20, &v24, v33, 2u, &v23) )
              return 0xFFFFFFFFLL;
            v35 = strlen(*((const char **)v21 + 7));
            if ( (unsigned int)sub_129CF(v20, &v24, *((void **)v21 + 7), v35, &v23) )
              return 0xFFFFFFFFLL;
            if ( (unsigned int)sub_129CF(v20, &v24, v34, 4u, &v23) )
              return 0xFFFFFFFFLL;
          }
        }
        if ( !*((_QWORD *)v21 + 5) )
        {
          v39 = (char *)sub_40CD4(v21);
          if ( v39 )
          {
            v16 = strlen(s);
            if ( (unsigned int)sub_129CF(v20, &v24, s, v16, &v23) )
              return 0xFFFFFFFFLL;
            if ( (unsigned int)sub_129CF(v20, &v24, "/", 1u, &v23) )
              return 0xFFFFFFFFLL;
            v27 = 1;
            s = v39;
          }
        }
        v21 = (char *)*((_QWORD *)v21 + 5);
      }
      else
      {
        if ( a1 != 1 )
          goto LABEL_116;
        s = (char *)*((_QWORD *)v21 + 6);
        if ( *((_QWORD *)v21 + 7) )
          v7 = *(char **)(*((_QWORD *)v21 + 7) + 24LL);
        else
          v7 = 0LL;
        v32 = v7;
        v21 = (char *)*((_QWORD *)v21 + 1);
      }
      if ( s )
      {
        v17 = strlen(s);
        if ( (unsigned int)sub_129CF(v20, &v24, s, v17, &v23) )
          return 0xFFFFFFFFLL;
        if ( v32 )
        {
          if ( v27 && (unsigned int)sub_129CF(v20, &v24, "#", 1u, &v23) )
            return 0xFFFFFFFFLL;
          if ( (unsigned int)sub_129CF(v20, &v24, ":", 1u, &v23) )
            return 0xFFFFFFFFLL;
          v18 = strlen(v32);
          if ( (unsigned int)sub_129CF(v20, &v24, v32, v18, &v23) )
            return 0xFFFFFFFFLL;
        }
      }
      if ( (unsigned int)sub_129CF(v20, &v24, "/", 1u, &v23) )
        return 0xFFFFFFFFLL;
      if ( a1 == 2 && !v21 )
      {
        if ( i )
        {
          if ( *((_DWORD *)i + 14) == 0x2000 )
          {
            v35 = strlen(*(const char **)i);
            if ( (unsigned int)sub_129CF(v20, &v24, *(void **)i, v35, &v23) )
              return 0xFFFFFFFFLL;
          }
        }
      }
    }
    memmove(*v20, (char *)*v20 + v24, v23);
    *((_BYTE *)*v20 + v23) = 0;
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_vlog_build_path", v5);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7360: using guessed type __int64 __fastcall lyd_list_pos(_QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000013937) ----------------------------------------------------
unsigned __int64 sub_13937(void *a1, int a2, unsigned int a3, char *a4, __int64 a5, __int64 a6, ...)
{
  char **v6; // rax
  char *v8; // [rsp+28h] [rbp-E8h]
  __int64 v9; // [rsp+30h] [rbp-E0h]
  char *v10; // [rsp+38h] [rbp-D8h]
  gcc_va_list va; // [rsp+40h] [rbp-D0h]
  unsigned __int64 v12; // [rsp+58h] [rbp-B8h]
  __int64 v13; // [rsp+80h] [rbp-90h]
  __int64 v14; // [rsp+88h] [rbp-88h]

  v13 = a5;
  v14 = a6;
  v12 = __readfsqword(0x28u);
  v8 = 0LL;
  if ( a2 != -2 || dword_3458A4 )
  {
    if ( dword_3458A4 && a3 )
    {
      if ( a3 == 5 )
      {
        v9 = ly_err_first(a1);
        if ( v9 && *(_QWORD *)(*(_QWORD *)(v9 + 48) + 24LL) )
          v8 = strdup(*(const char **)(*(_QWORD *)(v9 + 48) + 24LL));
      }
      else if ( a4 )
      {
        sub_12B3E(a3, a4, (void **)&v8, 0, 0);
      }
      else
      {
        v8 = strdup("/");
      }
    }
    va[0].gp_offset = 32;
    va_start(va, a6);
    if ( a2 == -2 )
    {
      if ( !v8 )
        __assert_fail("path", "/home/mantovan/Repositories/libyang/src/log.c", 0x378u, "ly_vlog");
      sub_11EB0(a1, 0, 5, 0, v8, 0LL, va);
    }
    else if ( a2 == -1 )
    {
      if ( va[0].gp_offset > 0x2F )
      {
        v6 = (char **)va[0].overflow_arg_area;
        va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
      }
      else
      {
        v6 = (char **)((char *)va[0].reg_save_area + va[0].gp_offset);
        va[0].gp_offset += 8;
      }
      v10 = *v6;
      sub_11EB0(a1, 0, 5, 0, v8, v10, va);
    }
    else
    {
      sub_11EB0(a1, 0, 5, dword_109EA0[a2], v8, (char *)*(&off_3458E0 + a2), va);
    }
  }
  return __readfsqword(0x28u) ^ v12;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 3458A4: using guessed type int dword_3458A4;
// 3458E0: using guessed type void *off_3458E0;

//----- (0000000000013C4A) ----------------------------------------------------
unsigned __int64 sub_13C4A(void *a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  size_t v6; // rax
  size_t v7; // rax
  char *s; // [rsp+8h] [rbp-108h]
  char *v10; // [rsp+20h] [rbp-F0h]
  char *dest; // [rsp+28h] [rbp-E8h]
  char *i; // [rsp+30h] [rbp-E0h]
  __int64 v13; // [rsp+38h] [rbp-D8h]
  gcc_va_list va; // [rsp+40h] [rbp-D0h]
  unsigned __int64 v15; // [rsp+58h] [rbp-B8h]
  __int64 v16; // [rsp+78h] [rbp-98h]
  __int64 v17; // [rsp+80h] [rbp-90h]
  __int64 v18; // [rsp+88h] [rbp-88h]

  s = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v15 = __readfsqword(0x28u);
  v10 = 0LL;
  if ( a2 && a2 != 5 )
    __assert_fail(
      "(elem_type == LY_VLOG_NONE) || (elem_type == LY_VLOG_PREV)",
      "/home/mantovan/Repositories/libyang/src/log.c",
      0x389u,
      "ly_vlog_str");
  if ( a2 == 5 )
  {
    v13 = ly_err_first(a1);
    if ( v13 )
    {
      if ( *(_QWORD *)(*(_QWORD *)(v13 + 48) + 24LL) )
        v10 = strdup(*(const char **)(*(_QWORD *)(v13 + 48) + 24LL));
    }
  }
  if ( strchr(s, 37) )
  {
    v6 = strlen(s);
    dest = (char *)malloc(2 * v6 + 1);
    strcpy(dest, s);
    for ( i = strchr(dest, 37); i; i = strchr(i + 2, 37) )
    {
      v7 = strlen(i);
      memmove(i + 1, i, v7 + 1);
      *i = 37;
    }
  }
  else
  {
    dest = strdup(s);
  }
  va[0].gp_offset = 24;
  va_start(va, a6);
  sub_11EB0(a1, 0, 5, 0, v10, dest, va);
  free(dest);
  return __readfsqword(0x28u) ^ v15;
}
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);

//----- (0000000000013ED6) ----------------------------------------------------
int __fastcall ly_err_print(unsigned int *a1)
{
  __int64 v1; // rax
  void *__ptr32 *v2; // rax

  LODWORD(v1) = byte_3458A1 & 1;
  if ( byte_3458A1 & 1 )
  {
    if ( qword_347050 )
    {
      LODWORD(v1) = qword_347050(*a1, *((_QWORD *)a1 + 2), *((_QWORD *)a1 + 3));
    }
    else
    {
      if ( *((_QWORD *)a1 + 3) )
        v2 = &off_108D8F;
      else
        v2 = (void *__ptr32 *)((char *)&off_108D8F + 2);
      fprintf(stderr, "libyang[%d]: %s%s", *a1, *((_QWORD *)a1 + 2), v2);
      v1 = *((_QWORD *)a1 + 3);
      if ( v1 )
        LODWORD(v1) = fprintf(stderr, "(path: %s)\n", *((_QWORD *)a1 + 3));
    }
  }
  return v1;
}
// 347050: invalid function type has been ignored
// 108D8F: using guessed type void *__ptr32 off_108D8F;
// 3458A1: using guessed type char byte_3458A1;
// 347050: using guessed type __int64 (__fastcall *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013FA5) ----------------------------------------------------
__int64 __fastcall sub_13FA5(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _DWORD *v3; // [rsp+0h] [rbp-10h]

  if ( a2 )
    v3 = *(_DWORD **)(a2 + 40);
  else
    v3 = pthread_getspecific(*(_DWORD *)(a1 + 128));
  result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
  if ( (_DWORD)result != 1 )
  {
    result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
    if ( (_DWORD)result != 2 )
    {
      while ( v3 )
      {
        ly_err_print(v3);
        if ( !*v3 )
          *(_DWORD *)ly_errno_glob_address(v3) = v3[1];
        result = *((_QWORD *)v3 + 5);
        v3 = (_DWORD *)*((_QWORD *)v3 + 5);
      }
    }
  }
  return result;
}
// 7200: using guessed type __int64 __fastcall ly_err_print(_QWORD);
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (000000000001404C) ----------------------------------------------------
__int64 __fastcall sub_1404C(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( !a2 )
    return ly_err_clean(a1, 0LL);
  result = *(_QWORD *)(a2 + 40);
  if ( result )
    result = ly_err_clean(a1, *(_QWORD *)(a2 + 40));
  return result;
}
// 77D0: using guessed type __int64 __fastcall ly_err_clean(_QWORD, _QWORD);

//----- (000000000001409D) ----------------------------------------------------
void __fastcall sub_1409D(__int64 a1, __int64 a2, int a3)
{
  int v3; // [rsp+Ch] [rbp-24h]
  const void **pointer; // [rsp+10h] [rbp-20h]
  const void **v5; // [rsp+28h] [rbp-8h]

  v3 = a3;
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
  {
    if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 2 && v3 && byte_3458A1 & 2 )
    {
      if ( (byte_3458A1 & 6) == 6 )
      {
        v5 = (const void **)pthread_getspecific(*(_DWORD *)(a1 + 128));
        if ( v5 )
        {
          pointer = (const void **)v5[6];
          pthread_setspecific(*(_DWORD *)(a1 + 128), v5[6]);
          if ( *((_QWORD *)pointer[6] + 5) && pointer != *((const void ***)pointer[6] + 5) )
            __assert_fail(
              "!prev_eitem->prev->next || (prev_eitem->prev->next == prev_eitem)",
              "/home/mantovan/Repositories/libyang/src/log.c",
              0x3F7u,
              "err_clean");
          *((_QWORD *)pointer[6] + 5) = 0LL;
          pointer[6] = pointer;
          if ( pointer != v5 )
            destr_function(v5);
        }
      }
    }
    else
    {
      sub_1404C(a1, a2);
    }
  }
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;
// 3458A1: using guessed type char byte_3458A1;

//----- (00000000000141E4) ----------------------------------------------------
__int64 __fastcall sub_141E4(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4)
{
  __int64 result; // rax
  unsigned int *v5; // rdx
  __int64 v6; // [rsp+0h] [rbp-20h]

  v6 = a4;
  if ( !a3 )
    __assert_fail("prev_ilo", "/home/mantovan/Repositories/libyang/src/log.c", 0x405u, "ly_ilo_change");
  *a3 = *(_DWORD *)__tls_get_addr(&stru_335FC0);
  if ( a2 == 1 )
  {
    if ( !a1 || !v6 )
      __assert_fail("ctx && prev_last_eitem", "/home/mantovan/Repositories/libyang/src/log.c", 0x40Au, "ly_ilo_change");
    *(_QWORD *)v6 = ly_err_first(a1);
    if ( *(_QWORD *)v6 )
      *(_QWORD *)v6 = *(_QWORD *)(*(_QWORD *)v6 + 48LL);
  }
  result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
  if ( (_DWORD)result != 2 )
  {
    v5 = (unsigned int *)__tls_get_addr(&stru_335FC0);
    result = a2;
    *v5 = a2;
  }
  return result;
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (00000000000142D2) ----------------------------------------------------
void __fastcall sub_142D2(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v4; // [rsp+8h] [rbp-18h]
  int v5; // [rsp+10h] [rbp-10h]

  v4 = a3;
  v5 = a4;
  if ( !*(_DWORD *)__tls_get_addr(&stru_335FC0) )
    __assert_fail("log_opt != ILO_LOG", "/home/mantovan/Repositories/libyang/src/log.c", 0x419u, "ly_ilo_restore");
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) == 1 )
  {
    if ( !a1 )
      __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/log.c", 0x421u, "ly_ilo_restore");
    *(_DWORD *)__tls_get_addr(&stru_335FC0) = a2;
    if ( v5 )
      sub_13FA5(a1, v4);
    sub_1409D(a1, v4, v5);
  }
  else
  {
    if ( a2 != *(_DWORD *)__tls_get_addr(&stru_335FC0) && (a1 || v4 || v5) )
      __assert_fail(
        "log_opt == prev_ilo || (!ctx && !prev_last_eitem && !keep_and_print)",
        "/home/mantovan/Repositories/libyang/src/log.c",
        0x41Cu,
        "ly_ilo_restore");
    *(_DWORD *)__tls_get_addr(&stru_335FC0) = a2;
  }
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (0000000000014407) ----------------------------------------------------
__int64 __fastcall sub_14407(__int64 a1, const char *a2)
{
  __int64 result; // rax
  __int64 v3; // ST18_8
  char *v4; // rdx

  result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
  if ( (_DWORD)result != 2 )
  {
    result = ly_err_first(a1);
    if ( result )
    {
      v3 = *(_QWORD *)(result + 48);
      v4 = strdup(a2);
      result = v3;
      *(_QWORD *)(v3 + 32) = v4;
    }
  }
  return result;
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 7710: using guessed type __int64 __fastcall ly_err_first(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (000000000001446B) ----------------------------------------------------
_BOOL8 __fastcall sub_1446B(const char **a1, char **a2, __int64 a3, size_t *a4, __int64 a5, __int64 a6)
{
  _BOOL8 result; // rax
  char *s2; // [rsp+28h] [rbp-8h]

  if ( a1 && a2 )
  {
    s2 = *a2;
    if ( *a1 && s2 && a4 )
    {
      result = strncmp(*a1, s2, *a4) == 0;
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_val_eq", a6, a4);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_val_eq", a6, a4);
    result = 0LL;
  }
  return result;
}

//----- (0000000000014546) ----------------------------------------------------
int __fastcall sub_14546(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int result; // eax

  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_init", a6);
  *(_QWORD *)a1 = sub_14CB1(0x400u, 12, (__int64)sub_1446B, 0LL, 1);
  if ( *(_QWORD *)a1 )
    result = pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0LL);
  else
    result = sub_12222(
               0LL,
               0,
               4,
               "Internal error (%s:%d).",
               (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
               57LL);
  return result;
}

//----- (00000000000145FF) ----------------------------------------------------
int __fastcall sub_145FF(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int i; // [rsp+1Ch] [rbp-14h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_clean", a6);
  for ( i = 0; i < *(_DWORD *)(*(_QWORD *)a1 + 4LL); ++i )
  {
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 32LL) + i * *(unsigned __int16 *)(*(_QWORD *)a1 + 26LL);
    if ( *(_DWORD *)(v8 + 4) == 1 )
      sub_12222(
        0LL,
        1u,
        0,
        "String \"%s\" not freed from the dictionary, refcount %d",
        *(_QWORD *)(v8 + 8),
        *(unsigned int *)(v8 + 16));
  }
  sub_14F6B(*(void ***)a1);
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
}

//----- (0000000000014701) ----------------------------------------------------
__int64 __fastcall sub_14701(__int64 a1, unsigned __int64 a2)
{
  unsigned int v2; // ST18_4
  int v4; // [rsp+18h] [rbp-8h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  v5 = 0;
  v4 = 0;
  while ( a2 > v5 )
  {
    v2 = 1025 * (*(char *)(v5 + a1) + v4);
    v4 = (v2 >> 6) ^ v2;
    ++v5;
  }
  return 32769 * (((unsigned int)(9 * v4) >> 11) ^ 9 * v4);
}

//----- (000000000001476E) ----------------------------------------------------
__int64 __fastcall sub_1476E(unsigned int a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int v3; // ST14_4
  unsigned int v5; // [rsp+14h] [rbp-14h]
  unsigned int i; // [rsp+24h] [rbp-4h]

  v5 = a1;
  if ( a2 )
  {
    for ( i = 0; a3 > i; ++i )
    {
      v3 = 1025 * (*(char *)(i + a2) + v5);
      v5 = (v3 >> 6) ^ v3;
    }
  }
  else
  {
    v5 = 32769 * ((9 * a1 >> 11) ^ 9 * a1);
  }
  return v5;
}

//----- (00000000000147E1) ----------------------------------------------------
unsigned __int64 __fastcall lydict_remove(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  int v8; // ST1C_4
  char *s; // [rsp+0h] [rbp-50h]
  unsigned int v11; // [rsp+18h] [rbp-38h]
  unsigned __int64 v12; // [rsp+20h] [rbp-30h]
  __int64 v13; // [rsp+28h] [rbp-28h]
  void *ptr; // [rsp+30h] [rbp-20h]
  char *v15; // [rsp+3Ch] [rbp-14h]
  int v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v17 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)"%s", (__int64)"lydict_remove", a4, a5, a6, a2);
  v13 = 0LL;
  if ( s && a1 )
  {
    v12 = strlen(s);
    v11 = sub_14701((__int64)s, v12);
    v15 = s;
    v16 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
    sub_14E8E(*(_QWORD *)a1, (__int64)&v12);
    if ( !(unsigned int)sub_154F1(*(_QWORD *)a1, (__int64)&v15, v11, &v13) )
    {
      if ( v13 )
      {
        if ( !--*(_DWORD *)(v13 + 8) )
        {
          ptr = *(void **)v13;
          v8 = sub_15F8D(*(_QWORD *)a1, (__int64)&v15, v11, (__int64)&v15, v6, v7);
          free(ptr);
          if ( v8 )
            sub_12222(
              a1,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
              186LL);
        }
      }
      else
      {
        sub_12222(
          a1,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
          173LL);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  }
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000149A6) ----------------------------------------------------
__int64 __fastcall sub_149A6(__int64 *a1, void *a2, size_t a3, int a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  void **v9; // rbx
  __int64 v10; // r9
  int v12; // [rsp+4h] [rbp-5Ch]
  size_t n; // [rsp+8h] [rbp-58h]
  void *ptr; // [rsp+10h] [rbp-50h]
  __int64 *v15; // [rsp+18h] [rbp-48h]
  int v16; // [rsp+28h] [rbp-38h]
  unsigned int v17[4]; // [rsp+2Ch] [rbp-34h]
  void *v18; // [rsp+3Ch] [rbp-24h]
  int v19; // [rsp+44h] [rbp-1Ch]
  unsigned __int64 v20; // [rsp+48h] [rbp-18h]

  v15 = a1;
  ptr = a2;
  n = a3;
  v12 = a4;
  v20 = __readfsqword(0x28u);
  *(_QWORD *)&v17[1] = 0LL;
  v16 = 0;
  *(_QWORD *)v17 = (unsigned int)sub_14701((__int64)a2, a3);
  sub_14E8E(*a1, (__int64)&n);
  v18 = ptr;
  v19 = 1;
  sub_12312(1u, (__int64)"inserting \"%s\"", (__int64)ptr, v4, v5, v6);
  v16 = sub_15F55(*v15, &v18, v17[0], (__int64)&v17[1], v7, v8);
  if ( v16 == 1 )
  {
    ++*(_DWORD *)(*(_QWORD *)&v17[1] + 8LL);
    if ( v12 )
      free(ptr);
  }
  else
  {
    if ( v16 )
    {
      sub_12222(
        (__int64)v15,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
        228LL);
      return 0LL;
    }
    if ( !v12 )
    {
      v9 = *(void ***)&v17[1];
      *v9 = malloc(n + 1);
      if ( !**(_QWORD **)&v17[1] )
      {
        sub_12222((__int64)v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"dict_insert", v10);
        return 0LL;
      }
      memcpy(**(void ***)&v17[1], ptr, n);
      *(_BYTE *)(**(_QWORD **)&v17[1] + n) = 0;
    }
  }
  return **(_QWORD **)&v17[1];
}

//----- (0000000000014B6B) ----------------------------------------------------
__int64 __fastcall lydict_insert(__int64 a1, char *a2, size_t a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // ST28_8
  size_t v8; // [rsp+8h] [rbp-28h]

  v8 = a3;
  sub_12312(0x20u, (__int64)"%s", (__int64)"lydict_insert", a4, a5, a6);
  if ( !a2 )
    return 0LL;
  if ( !v8 )
    v8 = strlen(a2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v7 = sub_149A6((__int64 *)a1, a2, v8, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  return v7;
}

//----- (0000000000014C04) ----------------------------------------------------
__int64 __fastcall lydict_insert_zc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  size_t v7; // rax
  __int64 v8; // ST18_8
  char *s; // [rsp+0h] [rbp-20h]

  sub_12312(0x20u, (__int64)"%s", (__int64)"lydict_insert_zc", a4, a5, a6, a2);
  if ( !s )
    return 0LL;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v7 = strlen(s);
  v8 = sub_149A6((__int64 *)a1, s, v7, 1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  return v8;
}

//----- (0000000000014C8D) ----------------------------------------------------
__int64 __fastcall sub_14C8D(__int64 a1, unsigned __int16 a2, int a3)
{
  return a3 * (unsigned int)a2 + a1;
}

//----- (0000000000014CB1) ----------------------------------------------------
_QWORD *__fastcall sub_14CB1(unsigned int a1, __int16 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // r9
  _QWORD *result; // rax
  __int64 v7; // r9
  __int16 v8; // [rsp+4h] [rbp-2Ch]
  __int64 v9; // [rsp+8h] [rbp-28h]
  __int64 v10; // [rsp+10h] [rbp-20h]
  unsigned int nmemb; // [rsp+1Ch] [rbp-14h]
  _QWORD *ptr; // [rsp+28h] [rbp-8h]

  nmemb = a1;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( !a1 || a1 & (a1 - 1) )
    __assert_fail(
      "size && !(size & (size - 1))",
      "/home/mantovan/Repositories/libyang/src/hash_table.c",
      0x11Fu,
      "lyht_new");
  if ( !a3 || !a2 )
    __assert_fail("val_equal && val_size", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x120u, "lyht_new");
  if ( a5 && a5 != 1 )
    __assert_fail(
      "resize == 0 || resize == 1",
      "/home/mantovan/Repositories/libyang/src/hash_table.c",
      0x121u,
      "lyht_new");
  if ( a1 <= 7 )
    nmemb = 8;
  ptr = malloc(0x28uLL);
  if ( ptr )
  {
    *(_DWORD *)ptr = 0;
    *((_DWORD *)ptr + 1) = nmemb;
    ptr[1] = v10;
    ptr[2] = v9;
    *((_WORD *)ptr + 12) = v8;
    *((_WORD *)ptr + 13) = a2 + 8;
    ptr[4] = calloc(nmemb, *((unsigned __int16 *)ptr + 13));
    if ( ptr[4] )
    {
      result = ptr;
    }
    else
    {
      free(ptr);
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyht_new", v7);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyht_new", v5);
    result = 0LL;
  }
  return result;
}

//----- (0000000000014E64) ----------------------------------------------------
__int64 __fastcall sub_14E64(__int64 a1, __int64 a2)
{
  __int64 v2; // ST18_8

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
  return v2;
}

//----- (0000000000014E8E) ----------------------------------------------------
__int64 __fastcall sub_14E8E(__int64 a1, __int64 a2)
{
  __int64 v2; // ST18_8

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2;
  return v2;
}

//----- (0000000000014EB8) ----------------------------------------------------
_QWORD *__fastcall sub_14EB8(unsigned int *a1)
{
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v2 = sub_14CB1(a1[1], *((_WORD *)a1 + 13) - 8, *((_QWORD *)a1 + 1), *((_QWORD *)a1 + 2), *((_WORD *)a1 + 12) != 0);
  if ( !v2 )
    return 0LL;
  memcpy((void *)v2[4], *((const void **)a1 + 4), *((unsigned __int16 *)a1 + 13) * (unsigned __int64)*a1);
  *(_DWORD *)v2 = *a1;
  return v2;
}

//----- (0000000000014F6B) ----------------------------------------------------
void __fastcall sub_14F6B(void **a1)
{
  if ( a1 )
  {
    free(a1[4]);
    free(a1);
  }
}

//----- (0000000000014F9D) ----------------------------------------------------
signed __int64 __fastcall sub_14F9D(__int64 a1, int a2)
{
  int v2; // edx
  __int64 v3; // r9
  signed __int64 result; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned int i; // [rsp+14h] [rbp-1Ch]
  unsigned int v8; // [rsp+18h] [rbp-18h]
  void *ptr; // [rsp+20h] [rbp-10h]
  unsigned int *v10; // [rsp+28h] [rbp-8h]

  ptr = *(void **)(a1 + 32);
  v8 = *(_DWORD *)(a1 + 4);
  if ( a2 )
    v2 = 2 * *(_DWORD *)(a1 + 4);
  else
    v2 = *(_DWORD *)(a1 + 4) >> 1;
  *(_DWORD *)(a1 + 4) = v2;
  *(_QWORD *)(a1 + 32) = calloc(*(unsigned int *)(a1 + 4), *(unsigned __int16 *)(a1 + 26));
  if ( *(_QWORD *)(a1 + 32) )
  {
    *(_DWORD *)a1 = 0;
    for ( i = 0; i < v8; ++i )
    {
      v10 = (unsigned int *)sub_14C8D((__int64)ptr, *(_WORD *)(a1 + 26), i);
      if ( (signed int)v10[1] > 0 )
      {
        if ( (unsigned int)sub_15F55(a1, v10 + 2, *v10, 0LL, v5, v6) )
          __assert_fail("!ret", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x186u, "lyht_resize");
      }
    }
    free(ptr);
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyht_resize", v3);
    *(_QWORD *)(a1 + 32) = ptr;
    *(_DWORD *)(a1 + 4) = v8;
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000001510F) ----------------------------------------------------
signed __int64 __fastcall sub_1510F(__int64 a1, int a2, _QWORD *a3)
{
  signed __int64 result; // rax
  _DWORD *v4; // rax
  _QWORD *v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  _DWORD *src; // [rsp+30h] [rbp-10h]
  void *dest; // [rsp+38h] [rbp-8h]

  v5 = a3;
  dest = 0LL;
  if ( a3 )
    *a3 = 0LL;
  v6 = a2 & (*(_DWORD *)(a1 + 4) - 1);
  v7 = a2 & (*(_DWORD *)(a1 + 4) - 1);
  for ( src = (_DWORD *)sub_14C8D(
                          *(_QWORD *)(a1 + 32),
                          *(_WORD *)(a1 + 26),
                          a2 & (unsigned int)(*(_DWORD *)(a1 + 4) - 1));
        ;
        src = (_DWORD *)sub_14C8D(*(_QWORD *)(a1 + 32), *(_WORD *)(a1 + 26), v6) )
  {
    if ( !src[1] || src[1] != -1 && v7 == (*src & (*(_DWORD *)(a1 + 4) - 1)) )
    {
      if ( src[1] )
      {
        if ( dest )
        {
          memcpy(dest, src, *(unsigned __int16 *)(a1 + 26));
          src[1] = -1;
          src = dest;
        }
        if ( v5 )
          *v5 = src;
        result = 0LL;
      }
      else
      {
        if ( v5 )
        {
          if ( dest )
            v4 = dest;
          else
            v4 = src;
          *v5 = v4;
        }
        result = 1LL;
      }
      return result;
    }
    if ( src[1] == -1 && !dest )
      dest = src;
    v6 = (unsigned int)(v6 + 1) % *(_DWORD *)(a1 + 4);
    if ( v6 == v7 )
      break;
  }
  if ( !dest )
    __assert_fail("inval_rec", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x1A9u, "lyht_find_first");
  if ( v5 )
    *v5 = dest;
  return 1LL;
}

//----- (00000000000152D5) ----------------------------------------------------
signed __int64 __fastcall sub_152D5(__int64 a1, const void **a2, const void *a3)
{
  signed __int64 result; // rax
  const void *v4; // [rsp+8h] [rbp-28h]
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  void *dest; // [rsp+28h] [rbp-8h]

  v4 = a3;
  dest = 0LL;
  if ( !a2 || !*a2 )
    __assert_fail(
      "last && *last",
      "/home/mantovan/Repositories/libyang/src/hash_table.c",
      0x1D7u,
      "lyht_find_collision");
  v6 = *(_DWORD *)*a2 & (*(_DWORD *)(a1 + 4) - 1);
  v5 = (_QWORD)((_QWORD)*a2 - *(_QWORD *)(a1 + 32)) / *(unsigned __int16 *)(a1 + 26);
  do
  {
    v5 = (unsigned int)(v5 + 1) % *(_DWORD *)(a1 + 4);
    *a2 = (const void *)sub_14C8D(*(_QWORD *)(a1 + 32), *(_WORD *)(a1 + 26), v5);
    if ( v4 == *a2 )
    {
      if ( !dest )
        __assert_fail(
          "inval_rec",
          "/home/mantovan/Repositories/libyang/src/hash_table.c",
          0x1E2u,
          "lyht_find_collision");
      *a2 = dest;
      return 1LL;
    }
    if ( *((_DWORD *)*a2 + 1) == -1 && !dest )
      dest = (void *)*a2;
  }
  while ( *((_DWORD *)*a2 + 1) && (*((_DWORD *)*a2 + 1) == -1 || v6 != (*(_DWORD *)*a2 & (*(_DWORD *)(a1 + 4) - 1))) );
  if ( *((_DWORD *)*a2 + 1) <= 0 )
  {
    if ( dest )
      *a2 = dest;
    result = 1LL;
  }
  else
  {
    if ( *((_DWORD *)*a2 + 1) != 1 )
      __assert_fail(
        "(*last)->hits == 1",
        "/home/mantovan/Repositories/libyang/src/hash_table.c",
        0x1EEu,
        "lyht_find_collision");
    if ( dest )
    {
      memcpy(dest, *a2, *(unsigned __int16 *)(a1 + 26));
      *((_DWORD *)*a2 + 1) = -1;
      *a2 = dest;
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000154F1) ----------------------------------------------------
signed __int64 __fastcall sub_154F1(__int64 a1, __int64 a2, int a3, _QWORD *a4)
{
  signed __int64 result; // rax
  _QWORD *v5; // [rsp+0h] [rbp-50h]
  int v6; // [rsp+Ch] [rbp-44h]
  unsigned int i; // [rsp+2Ch] [rbp-24h]
  unsigned int v8; // [rsp+30h] [rbp-20h]
  _DWORD *v9; // [rsp+38h] [rbp-18h]
  const void *v10; // [rsp+40h] [rbp-10h]
  unsigned __int64 v11; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v11 = __readfsqword(0x28u);
  if ( (unsigned int)sub_1510F(a1, a3, &v9) )
    return 1LL;
  if ( v6 == *v9
    && (*(unsigned int (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(a1 + 8))(
         a2,
         v9 + 2,
         0LL,
         *(_QWORD *)(a1 + 16)) )
  {
    if ( v5 )
      *v5 = v9 + 2;
    result = 0LL;
  }
  else
  {
    v10 = v9;
    v8 = v9[1];
    for ( i = 1; ; ++i )
    {
      if ( i >= v8 )
        return 1LL;
      if ( (unsigned int)sub_152D5(a1, (const void **)&v9, v10) )
        __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x216u, "lyht_find");
      if ( v6 == *v9
        && (*(unsigned int (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(a1 + 8))(
             a2,
             v9 + 2,
             0LL,
             *(_QWORD *)(a1 + 16)) )
      {
        break;
      }
    }
    if ( v5 )
      *v5 = v9 + 2;
    result = 0LL;
  }
  return result;
}

//----- (0000000000015669) ----------------------------------------------------
signed __int64 __fastcall sub_15669(__int64 a1, __int64 a2, int a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-50h]
  int v6; // [rsp+Ch] [rbp-44h]
  unsigned int i; // [rsp+28h] [rbp-28h]
  signed int v8; // [rsp+2Ch] [rbp-24h]
  unsigned int v9; // [rsp+30h] [rbp-20h]
  _DWORD *v10; // [rsp+38h] [rbp-18h]
  const void *v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  v8 = 0;
  if ( (unsigned int)sub_1510F(a1, a3, &v10) )
    __assert_fail("0", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x22Fu, "lyht_find_next");
  if ( v6 == *v10
    && (*(unsigned int (__fastcall **)(__int64, _DWORD *, signed __int64, _QWORD))(a1 + 8))(
         a2,
         v10 + 2,
         1LL,
         *(_QWORD *)(a1 + 16)) )
  {
    v8 = 1;
  }
  if ( v10[1] == 1 )
  {
    if ( v6 != *v10 )
      __assert_fail(
        "rec->hash == hash",
        "/home/mantovan/Repositories/libyang/src/hash_table.c",
        0x239u,
        "lyht_find_next");
    if ( !v8 )
      __assert_fail("found", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x23Au, "lyht_find_next");
    return 1LL;
  }
  v11 = v10;
  v9 = v10[1];
  for ( i = 1; ; ++i )
  {
    if ( i >= v9 )
    {
      if ( !v8 )
        __assert_fail("found", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x25Du, "lyht_find_next");
      return 1LL;
    }
    if ( (unsigned int)sub_152D5(a1, (const void **)&v10, v11) )
      __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x243u, "lyht_find_next");
    if ( v6 == *v10 )
      break;
LABEL_22:
    ;
  }
  if ( !v8 )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, _DWORD *, signed __int64, _QWORD))(a1 + 8))(
           a2,
           v10 + 2,
           1LL,
           *(_QWORD *)(a1 + 16)) )
    {
      v8 = 1;
    }
    goto LABEL_22;
  }
  if ( v5 )
    *v5 = v10 + 2;
  return 0LL;
}

//----- (0000000000015881) ----------------------------------------------------
char *__fastcall sub_15881(__int64 a1, int a2, unsigned __int16 a3)
{
  char *v3; // rax
  int v5; // [rsp+1Ch] [rbp-14h]
  int v6; // [rsp+20h] [rbp-10h]
  int v7; // [rsp+24h] [rbp-Ch]
  char *v8; // [rsp+28h] [rbp-8h]

  v7 = a3 - 8;
  v8 = (char *)malloc(2 * v7 + 1);
  v5 = 0;
  v6 = v7 - 1;
  while ( v5 < v7 )
  {
    if ( a2 <= 0 )
    {
      v3 = &v8[2 * v5];
      *(_WORD *)v3 = 8224;
      v3[2] = 0;
    }
    else
    {
      sprintf(&v8[2 * v5], "%02x", *(unsigned __int8 *)(v6 + a1));
    }
    ++v5;
    --v6;
  }
  return v8;
}

//----- (0000000000015936) ----------------------------------------------------
unsigned __int64 __fastcall sub_15936(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // r9
  __int64 v8; // ST20_8
  char *v9; // ST40_8
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  unsigned int i; // [rsp+18h] [rbp-18h]
  unsigned int v15; // [rsp+1Ch] [rbp-14h]
  char *s; // [rsp+20h] [rbp-10h]
  unsigned int *v17; // [rsp+28h] [rbp-8h]

  result = (unsigned __int8)byte_3458A0;
  if ( (unsigned __int8)byte_3458A0 > 2u )
  {
    sub_12312(0x40u, (__int64)&unk_10A3C1, a3, a4, a5, a6, a2);
    sub_12312(0x40u, (__int64)"hash table %s (used %u, size %u):", v8, *a1, a1[1], v7);
    v9 = (char *)malloc(0xBuLL);
    sprintf(v9, off_10A3EA, a1[1]);
    v15 = strlen(v9);
    free(v9);
    for ( i = 0; i < a1[1]; ++i )
    {
      v17 = (unsigned int *)sub_14C8D(*((_QWORD *)a1 + 4), *((_WORD *)a1 + 13), i);
      s = sub_15881((__int64)(v17 + 2), v17[1], *((_WORD *)a1 + 13));
      if ( (signed int)v17[1] <= 0 )
        sub_12312(
          0x40u,
          (__int64)"[%*u] val  %s  hash  %10s %% %*s  hits  %2d",
          v15,
          i,
          (__int64)s,
          (__int64)&unk_10A3C1,
          v15,
          &unk_10A3C1,
          v17[1]);
      else
        sub_12312(
          0x40u,
          (__int64)"[%*u] val  %s  hash  %10u %% %*u  hits  %2d",
          v15,
          i,
          (__int64)s,
          *v17,
          v15,
          (a1[1] - 1) & *v17,
          v17[1]);
      free(s);
    }
    result = sub_12312(0x40u, (__int64)&unk_10A3C1, v10, v11, v12, v13);
  }
  return result;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000015B2B) ----------------------------------------------------
void __fastcall sub_15B2B(__int64 a1, unsigned int a2, unsigned __int16 a3, __int64 a4)
{
  char *ptr; // ST28_8
  __int64 v5; // r9
  __int64 v6; // [rsp+8h] [rbp-28h]

  v6 = a4;
  if ( (unsigned __int8)byte_3458A0 > 2u )
  {
    ptr = sub_15881(a1, 1, a3);
    sub_12312(0x40u, (__int64)"%s value %s with hash %u", v6, (__int64)ptr, a2, v5);
    free(ptr);
  }
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000015BA6) ----------------------------------------------------
signed __int64 __fastcall sub_15BA6(__int64 a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  _QWORD *v11; // [rsp+8h] [rbp-58h]
  __int64 v12; // [rsp+10h] [rbp-50h]
  unsigned int v13; // [rsp+1Ch] [rbp-44h]
  signed int i; // [rsp+34h] [rbp-2Ch]
  unsigned int v15; // [rsp+38h] [rbp-28h]
  signed int v16; // [rsp+3Ch] [rbp-24h]
  unsigned int *v17; // [rsp+40h] [rbp-20h]
  unsigned int *v18; // [rsp+48h] [rbp-18h]
  __int64 v19; // [rsp+50h] [rbp-10h]
  unsigned __int64 v20; // [rsp+58h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = (_QWORD *)a5;
  v20 = __readfsqword(0x28u);
  v18 = 0LL;
  sub_15936((unsigned int *)a1, (__int64)"before", a3, a4, a5, a6);
  sub_15B2B((__int64)a2, v13, *(_WORD *)(a1 + 26), (__int64)"inserting");
  if ( (unsigned int)sub_1510F(a1, v13, &v17) )
  {
LABEL_19:
    if ( (signed int)v17[1] > 0 )
      __assert_fail(
        "rec->hits < 1",
        "/home/mantovan/Repositories/libyang/src/hash_table.c",
        0x2CFu,
        "lyht_insert_with_resize_cb");
    *v17 = v13;
    v17[1] = 1;
    memcpy(v17 + 2, a2, *(unsigned __int16 *)(a1 + 26) - 8LL);
    if ( v11 )
      *v11 = v17 + 2;
    if ( v18 )
    {
      if ( v18[1] == 0x7FFFFFFF )
        sub_12222(
          0LL,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
          730LL);
      ++v18[1];
    }
    v15 = 0;
    v10 = (unsigned int)(*(_DWORD *)a1 + 1);
    *(_DWORD *)a1 = v10;
    if ( *(_WORD *)(a1 + 24) )
    {
      v7 = *(unsigned int *)(a1 + 4);
      v10 = 100 * *(_DWORD *)a1 % (unsigned int)v7;
      v16 = 100 * *(_DWORD *)a1 / (unsigned int)v7;
      if ( *(_WORD *)(a1 + 24) == 1 && v16 > 49 )
        *(_WORD *)(a1 + 24) = 2;
      if ( *(_WORD *)(a1 + 24) == 2 && v16 > 74 )
      {
        if ( v12 )
          v19 = sub_14E64(a1, v12);
        v15 = sub_14F9D(a1, 1);
        if ( !v15 && v11 )
          sub_154F1(a1, (__int64)a2, v13, v11);
        if ( v12 )
          sub_14E64(a1, v19);
      }
    }
    sub_15936((unsigned int *)a1, (__int64)"after", v10, v7, v8, v9);
    result = v15;
  }
  else if ( v13 == *v17
         && (*(unsigned int (__fastcall **)(const void *, unsigned int *, signed __int64, _QWORD))(a1 + 8))(
              a2,
              v17 + 2,
              1LL,
              *(_QWORD *)(a1 + 16)) )
  {
    if ( v11 )
      *v11 = v17 + 2;
    result = 1LL;
  }
  else
  {
    v18 = v17;
    for ( i = 1; ; ++i )
    {
      if ( i >= (signed int)v18[1] )
      {
        if ( !(unsigned int)sub_152D5(a1, (const void **)&v17, v18) )
          __assert_fail(
            "r",
            "/home/mantovan/Repositories/libyang/src/hash_table.c",
            0x2CBu,
            "lyht_insert_with_resize_cb");
        goto LABEL_19;
      }
      if ( (unsigned int)sub_152D5(a1, (const void **)&v17, v18) )
        __assert_fail(
          "!r",
          "/home/mantovan/Repositories/libyang/src/hash_table.c",
          0x2BEu,
          "lyht_insert_with_resize_cb");
      if ( v13 == *v17
        && (*(unsigned int (__fastcall **)(const void *, unsigned int *, signed __int64, _QWORD))(a1 + 8))(
             a2,
             v17 + 2,
             1LL,
             *(_QWORD *)(a1 + 16)) )
      {
        break;
      }
    }
    if ( v11 )
      *v11 = v17 + 2;
    result = 1LL;
  }
  return result;
}

//----- (0000000000015F55) ----------------------------------------------------
signed __int64 __fastcall sub_15F55(__int64 a1, const void *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_15BA6(a1, a2, a3, 0LL, a4, a6);
}

//----- (0000000000015F8D) ----------------------------------------------------
signed __int64 __fastcall sub_15F8D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // rdx
  unsigned int v12; // [rsp+Ch] [rbp-44h]
  signed int i; // [rsp+28h] [rbp-28h]
  signed int v14; // [rsp+2Ch] [rbp-24h]
  unsigned int v15; // [rsp+30h] [rbp-20h]
  void *src; // [rsp+38h] [rbp-18h]
  void *dest; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v18 = __readfsqword(0x28u);
  v14 = 0;
  sub_15936((unsigned int *)a1, (__int64)"before", a3, a4, a5, a6);
  sub_15B2B(a2, v12, *(_WORD *)(a1 + 26), (__int64)"removing");
  if ( (unsigned int)sub_1510F(a1, v12, &src) )
  {
    sub_12312(0x40u, (__int64)"remove failed", v6, v7, v8, v9);
    return 1LL;
  }
  if ( v12 == *(_DWORD *)src
    && (*(unsigned int (__fastcall **)(__int64, char *, signed __int64, _QWORD))(a1 + 8))(
         a2,
         (char *)src + 8,
         1LL,
         *(_QWORD *)(a1 + 16)) )
  {
    v14 = 1;
  }
  dest = src;
  for ( i = 1; i < *((_DWORD *)dest + 1); ++i )
  {
    if ( (unsigned int)sub_152D5(a1, (const void **)&src, dest) )
      __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x31Cu, "lyht_remove");
    if ( !v14
      && v12 == *(_DWORD *)src
      && (*(unsigned int (__fastcall **)(__int64, char *, signed __int64, _QWORD))(a1 + 8))(
           a2,
           (char *)src + 8,
           1LL,
           *(_QWORD *)(a1 + 16)) )
    {
      break;
    }
  }
  if ( i >= *((_DWORD *)dest + 1) )
  {
    if ( !v14 )
    {
      sub_12312(0x40u, (__int64)"remove failed", v6, v7, v8, v9);
      return 1LL;
    }
    if ( dest != src )
    {
      *((_DWORD *)src + 1) = *((_DWORD *)dest + 1) - 1;
      memcpy(dest, src, *(unsigned __int16 *)(a1 + 26));
    }
    *((_DWORD *)src + 1) = -1;
  }
  else
  {
    if ( v14 )
      __assert_fail("!first_matched", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x326u, "lyht_remove");
    --*((_DWORD *)dest + 1);
    *((_DWORD *)src + 1) = -1;
  }
  v15 = 0;
  v11 = (unsigned int)(*(_DWORD *)a1 - 1);
  *(_DWORD *)a1 = v11;
  if ( *(_WORD *)(a1 + 24) == 2 )
  {
    v7 = *(unsigned int *)(a1 + 4);
    v11 = 100 * *(_DWORD *)a1 % (unsigned int)v7;
    if ( (signed int)(100 * *(_DWORD *)a1 / (unsigned int)v7) <= 24 && *(_DWORD *)(a1 + 4) > 8u )
      v15 = sub_14F9D(a1, 0);
  }
  sub_15936((unsigned int *)a1, (__int64)"after", v11, v7, v8, v9);
  return v15;
}

//----- (0000000000016271) ----------------------------------------------------
signed __int64 __fastcall sub_16271(_QWORD *a1, unsigned __int8 a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-38h]
  char v5; // [rsp+21h] [rbp-1Fh]
  signed __int16 v6; // [rsp+22h] [rbp-1Eh]
  signed int v7; // [rsp+24h] [rbp-1Ch]
  __int128 v8; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+38h] [rbp-8h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v7 = 0;
  v6 = 255;
  v8 = (unsigned __int64)*a1;
  if ( *(_BYTE *)v8 == 45 )
  {
    v7 = 1;
    *(_QWORD *)&v8 = v8 + 1;
  }
  else if ( *(_BYTE *)v8 == 43 )
  {
    *(_QWORD *)&v8 = v8 + 1;
  }
  if ( !((*__ctype_b_loc())[*(char *)v8] & 0x800) )
    return 1LL;
  v5 = 0;
  while ( (*__ctype_b_loc())[*(char *)v8] & 0x800 || *(_BYTE *)v8 == 46 && (v6 & 0x80u) != 0 )
  {
    if ( v5 > 18 )
      return 1LL;
    if ( *(_BYTE *)v8 == 46 )
    {
      if ( *(_BYTE *)(v8 + 1) == 46 )
        break;
      LOBYTE(v6) = v6 + 1;
    }
    else
    {
      v9 = *((_QWORD *)&v8 + 1);
      if ( v7 )
      {
        *((_QWORD *)&v8 + 1) = 10LL * *((_QWORD *)&v8 + 1) - (*(char *)v8 - 48);
        if ( *((_QWORD *)&v8 + 1) > v9 )
          return 1LL;
      }
      else
      {
        *((_QWORD *)&v8 + 1) = 10LL * *((_QWORD *)&v8 + 1) + *(char *)v8 - 48;
        if ( *((_QWORD *)&v8 + 1) < v9 )
          return 1LL;
      }
      if ( (v6 & 0x80u) == 0 )
      {
        LOBYTE(v6) = v6 + 1;
        if ( *(_BYTE *)v8 == 48 )
          ++HIBYTE(v6);
        else
          HIBYTE(v6) = 0;
      }
      ++v5;
    }
    *(_QWORD *)&v8 = v8 + 1;
  }
  if ( !(_BYTE)v6 )
    return 1LL;
  if ( (_BYTE)v6 == -1 )
    LOBYTE(v6) = 0;
  if ( HIBYTE(v6) )
  {
    LOBYTE(v6) = v6 - HIBYTE(v6);
    v5 -= HIBYTE(v6);
    *((_QWORD *)&v8 + 1) /= sub_C4C9(HIBYTE(v6));
  }
  if ( (char)v6 >= (signed int)a2 )
    goto LABEL_46;
  if ( v5 - 1 + a2 - (signed int)(char)v6 > 18 )
    return 1LL;
  v10 = *((_QWORD *)&v8 + 1);
  *((_QWORD *)&v8 + 1) *= sub_C4C9(a2 - (unsigned __int8)v6);
  if ( v7 )
  {
    if ( *((_QWORD *)&v8 + 1) > v10 )
      return 1LL;
  }
  if ( !v7 && *((_QWORD *)&v8 + 1) < v10 )
    return 1LL;
LABEL_46:
  if ( (char)v6 > (signed int)a2 )
    return 1LL;
  *a1 = v8;
  *v4 = *((_QWORD *)&v8 + 1);
  return 0LL;
}

//----- (0000000000016564) ----------------------------------------------------
__int64 __fastcall sub_16564(_BYTE *a1)
{
  _BYTE *i; // [rsp+8h] [rbp-18h]
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x9Fu, "parse_identifier");
  if ( !((*__ctype_b_loc())[(char)*a1] & 0x400) && *a1 != 95 )
    return 0LL;
  v3 = 1;
  for ( i = a1 + 1; (*__ctype_b_loc())[(char)*i] & 8 || *i == 95 || *i == 45 || *i == 46; ++i )
    ++v3;
  return v3;
}

//----- (0000000000016637) ----------------------------------------------------
__int64 __fastcall sub_16637(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, int a7)
{
  __int64 result; // rax
  unsigned int *v8; // [rsp+8h] [rbp-48h]
  _QWORD *v9; // [rsp+10h] [rbp-40h]
  unsigned int *v10; // [rsp+18h] [rbp-38h]
  _BYTE *v11; // [rsp+28h] [rbp-28h]
  _BYTE *v12; // [rsp+28h] [rbp-28h]
  int v13; // [rsp+38h] [rbp-18h]
  int v14; // [rsp+38h] [rbp-18h]
  int v15; // [rsp+38h] [rbp-18h]
  unsigned int v16; // [rsp+38h] [rbp-18h]
  int v17; // [rsp+38h] [rbp-18h]
  signed int v18; // [rsp+3Ch] [rbp-14h]
  int v19; // [rsp+40h] [rbp-10h]
  int v20; // [rsp+40h] [rbp-10h]
  unsigned int v21; // [rsp+44h] [rbp-Ch]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v18 = 0;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0xC7u, "parse_node_identifier");
  if ( (!a2 || !a3) && (a2 || a3) )
    __assert_fail(
      "(mod_name && mod_name_len) || (!mod_name && !mod_name_len)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0xC8u,
      "parse_node_identifier");
  if ( (!a4 || !a5) && (a4 || a5) )
    __assert_fail(
      "(name && nam_len) || (!name && !nam_len)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0xC9u,
      "parse_node_identifier");
  if ( a2 )
  {
    *a2 = 0LL;
    *a3 = 0;
  }
  if ( a4 )
  {
    *a4 = 0LL;
    *a5 = 0;
  }
  if ( !a7 )
    goto LABEL_47;
  if ( *a1 == 47 )
  {
    if ( a6 )
      *a6 = 1;
    v18 = 1;
  }
  else if ( a6 )
  {
    *a6 = 0;
  }
  v13 = sub_16564(&a1[v18]);
  if ( v13 <= 0 )
  {
    v14 = v18;
  }
  else
  {
    if ( a1[v18 + v13] != 58 )
      goto LABEL_47;
    if ( a2 )
    {
      *a2 = &a1[v18];
      *v10 = v13;
    }
    v14 = v18 + 1 + v13;
  }
  switch ( a1[v14] )
  {
    case 0x2A:
      if ( v9 )
      {
        *v9 = &a1[v14];
        *v8 = 1;
      }
      return (unsigned int)(v14 + 1);
    case 0x2E:
      if ( !v18 )
        return (unsigned int)-v14;
      if ( v9 )
      {
        *v9 = &a1[v14];
        *v8 = 1;
      }
      return (unsigned int)(v14 + 1);
    case 0x23:
      if ( v18 || !v14 )
        return 0LL;
      v19 = v14 + 1;
      v15 = sub_16564(&a1[v14 + 1]);
      if ( v15 <= 0 )
        return (unsigned int)(v15 - v19);
      *v9 = &a1[v19 - 1];
      *v8 = v15 + 1;
      return (unsigned int)(v19 + v15);
  }
LABEL_47:
  v16 = sub_16564(a1);
  if ( (signed int)v16 <= 0 )
    return v16;
  v21 = v16;
  v11 = &a1[v16];
  if ( *v11 == 58 )
  {
    v20 = v16 + 1;
    v12 = v11 + 1;
    v17 = sub_16564(v12);
    if ( v17 > 0 )
    {
      if ( a2 )
      {
        *a2 = a1;
        *v10 = v21;
      }
      if ( v9 )
      {
        *v9 = v12;
        *v8 = v17;
      }
      result = (unsigned int)(v20 + v17);
    }
    else
    {
      result = (unsigned int)(v17 - v20);
    }
  }
  else
  {
    if ( v9 )
    {
      *v9 = a1;
      *v8 = v16;
    }
    result = v16;
  }
  return result;
}

//----- (00000000000169E9) ----------------------------------------------------
__int64 __fastcall sub_169E9(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8)
{
  char **v9; // [rsp+0h] [rbp-40h]
  unsigned int *v10; // [rsp+8h] [rbp-38h]
  _QWORD *v11; // [rsp+10h] [rbp-30h]
  unsigned int *v12; // [rsp+18h] [rbp-28h]
  char *s; // [rsp+28h] [rbp-18h]
  char *sa; // [rsp+28h] [rbp-18h]
  char *sb; // [rsp+28h] [rbp-18h]
  char *sc; // [rsp+28h] [rbp-18h]
  signed int v17; // [rsp+30h] [rbp-10h]
  int v18; // [rsp+30h] [rbp-10h]
  int v19; // [rsp+30h] [rbp-10h]
  int v20; // [rsp+30h] [rbp-10h]
  int v21; // [rsp+34h] [rbp-Ch]
  int v22; // [rsp+34h] [rbp-Ch]
  char *v23; // [rsp+38h] [rbp-8h]
  char *i; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x15Eu, "parse_path_predicate");
  if ( a2 )
    *a2 = 0LL;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0LL;
  if ( a5 )
    *a5 = 0;
  if ( a6 )
    *a6 = 0LL;
  if ( a7 )
    *a7 = 0;
  if ( a8 )
    *a8 = 0;
  if ( *a1 != 91 )
    return 0LL;
  v17 = 1;
  for ( s = a1 + 1; (*__ctype_b_loc())[*s] & 0x2000; ++s )
    ++v17;
  v21 = sub_16637(s, a2, v12, v11, v10, 0LL, 0);
  if ( v21 <= 0 )
    return (unsigned int)(v21 - v17);
  v18 = v21 + v17;
  for ( sa = &s[v21]; (*__ctype_b_loc())[*sa] & 0x2000; ++sa )
    ++v18;
  if ( *sa != 61 )
    return (unsigned int)-v18;
  v19 = v18 + 1;
  for ( sb = sa + 1; (*__ctype_b_loc())[*sb] & 0x2000; ++sb )
    ++v19;
  v23 = strchr(sb, 93);
  if ( !v23 )
    return (unsigned int)-v19;
  for ( i = v23 - 1; (*__ctype_b_loc())[*i] & 0x2000; --i )
    ;
  v22 = (_DWORD)i + 1 - (_DWORD)sb;
  if ( v9 )
    *v9 = sb;
  if ( a7 )
    *a7 = v22;
  v20 = v22 + v19;
  for ( sc = &sb[v22]; (*__ctype_b_loc())[*sc] & 0x2000; ++sc )
    ++v20;
  if ( *sc != 93 )
    __assert_fail("id[0] == ']'", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1B3u, "parse_path_predicate");
  if ( sc[1] == 91 )
    *a8 = 1;
  return (unsigned int)(v20 + 1);
}

//----- (0000000000016CF6) ----------------------------------------------------
__int64 __fastcall sub_16CF6(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, signed int *a6)
{
  __int64 result; // rax
  signed int *v7; // [rsp+0h] [rbp-40h]
  unsigned int *v8; // [rsp+8h] [rbp-38h]
  _QWORD *v9; // [rsp+10h] [rbp-30h]
  unsigned int *v10; // [rsp+18h] [rbp-28h]
  char *s1; // [rsp+28h] [rbp-18h]
  char *s1a; // [rsp+28h] [rbp-18h]
  char *s1b; // [rsp+28h] [rbp-18h]
  char *s1c; // [rsp+28h] [rbp-18h]
  char *s1d; // [rsp+28h] [rbp-18h]
  int v16; // [rsp+34h] [rbp-Ch]
  signed int v17; // [rsp+34h] [rbp-Ch]
  int v18; // [rsp+34h] [rbp-Ch]
  int v19; // [rsp+34h] [rbp-Ch]
  int v20; // [rsp+34h] [rbp-Ch]
  signed int v21; // [rsp+38h] [rbp-8h]
  int v22; // [rsp+3Ch] [rbp-4h]

  s1 = (char *)a1;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v16 = 0;
  v21 = 0;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1D7u, "parse_path_key_expr");
  if ( !a6 )
    __assert_fail("parent_times", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1D8u, "parse_path_key_expr");
  if ( a2 )
    *a2 = 0LL;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0LL;
  if ( a5 )
    *a5 = 0;
  if ( !*a6 )
  {
    if ( strncmp(a1, "current()", 9uLL) )
      return 0LL;
    v17 = 9;
    for ( s1a = (char *)(a1 + 9); (*__ctype_b_loc())[*s1a] & 0x2000; ++s1a )
      ++v17;
    if ( *s1a != 47 )
      return (unsigned int)-v17;
    v18 = v17 + 1;
    for ( s1b = s1a + 1; (*__ctype_b_loc())[*s1b] & 0x2000; ++s1b )
      ++v18;
    if ( strncmp(s1b, "..", 2uLL) )
      return (unsigned int)-v18;
    v21 = 1;
    v16 = v18 + 2;
    for ( s1 = s1b + 2; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
      ++v16;
  }
  if ( *s1 != 47 )
    return (unsigned int)-v16;
  v19 = v16 + 1;
  for ( s1c = s1 + 1; (*__ctype_b_loc())[*s1c] & 0x2000; ++s1c )
    ++v19;
  while ( !strncmp(s1c, "..", 2uLL) && !*v7 )
  {
    ++v21;
    v20 = v19 + 2;
    for ( s1d = s1c + 2; (*__ctype_b_loc())[*s1d] & 0x2000; ++s1d )
      ++v20;
    if ( *s1d != 47 )
      return (unsigned int)-v20;
    v19 = v20 + 1;
    for ( s1c = s1d + 1; (*__ctype_b_loc())[*s1c] & 0x2000; ++s1c )
      ++v19;
  }
  if ( !*v7 )
    *v7 = v21;
  v22 = sub_16637(s1c, a2, v10, v9, v8, 0LL, 0);
  if ( v22 > 0 )
    result = (unsigned int)(v22 + v19);
  else
    result = (unsigned int)(v22 - v19);
  return result;
}

//----- (0000000000017055) ----------------------------------------------------
__int64 __fastcall sub_17055(__int64 a1, const char *a2, const char **a3, unsigned int *a4, _QWORD *a5, unsigned int *a6, signed int *a7, _DWORD *a8)
{
  unsigned int *v9; // [rsp+0h] [rbp-40h]
  _QWORD *v10; // [rsp+8h] [rbp-38h]
  unsigned int *v11; // [rsp+10h] [rbp-30h]
  const char **v12; // [rsp+18h] [rbp-28h]
  char *s1; // [rsp+20h] [rbp-20h]
  char *s1a; // [rsp+20h] [rbp-20h]
  char *s1b; // [rsp+20h] [rbp-20h]
  signed int v16; // [rsp+34h] [rbp-Ch]
  int v17; // [rsp+34h] [rbp-Ch]
  unsigned int v18; // [rsp+34h] [rbp-Ch]
  signed int v19; // [rsp+38h] [rbp-8h]
  int v20; // [rsp+3Ch] [rbp-4h]

  s1 = (char *)a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v16 = 0;
  v19 = 0;
  if ( !a2 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x261u, "parse_path_arg");
  if ( !a7 )
    __assert_fail("parent_times", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x262u, "parse_path_arg");
  if ( a3 )
    *a3 = 0LL;
  if ( a4 )
    *a4 = 0;
  if ( a5 )
    *a5 = 0LL;
  if ( a6 )
    *a6 = 0;
  if ( a8 )
    *a8 = 0;
  if ( !*a7 && !strncmp(a2, "..", 2uLL) )
  {
    v19 = 1;
    v16 = 2;
    for ( s1 = (char *)(a2 + 2); !strncmp(s1, "/..", 3uLL); s1 += 3 )
    {
      ++v19;
      v16 += 3;
    }
  }
  if ( !*a7 )
  {
    if ( v19 )
      *a7 = v19;
    else
      *a7 = -1;
  }
  if ( *s1 != 47 )
    return (unsigned int)-v16;
  v17 = v16 + 1;
  s1a = s1 + 1;
  v20 = sub_16637(s1a, v12, v11, v10, v9, 0LL, 0);
  if ( v20 <= 0 )
    return (unsigned int)(v20 - v17);
  if ( v12 && !*v12 )
  {
    *v12 = *(const char **)(lys_main_module(a1) + 8);
    *v11 = strlen(*v12);
  }
  v18 = v20 + v17;
  s1b = &s1a[v20];
  if ( *s1b == 47 || !*s1b )
    return v18;
  if ( *s1b != 91 )
    return -v18;
  if ( a8 )
    *a8 = 1;
  return v18;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000001729D) ----------------------------------------------------
__int64 __fastcall sub_1729D(_BYTE *a1, signed __int64 *a2, unsigned int *a3, signed __int64 *a4, unsigned int *a5, _DWORD *a6)
{
  _DWORD *v7; // [rsp+0h] [rbp-40h]
  unsigned int *v8; // [rsp+8h] [rbp-38h]
  signed __int64 *v9; // [rsp+10h] [rbp-30h]
  unsigned int *v10; // [rsp+18h] [rbp-28h]
  signed __int64 v11; // [rsp+28h] [rbp-18h]
  _BYTE *v12; // [rsp+28h] [rbp-18h]
  _BYTE *v13; // [rsp+28h] [rbp-18h]
  unsigned int v14; // [rsp+38h] [rbp-8h]
  int v15; // [rsp+38h] [rbp-8h]
  unsigned int v16; // [rsp+3Ch] [rbp-4h]
  unsigned int v17; // [rsp+3Ch] [rbp-4h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    __assert_fail(
      "id && model && mod_len && name && nam_len",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x2C2u,
      "parse_instance_identifier");
  if ( a6 )
    *a6 = 0;
  if ( *a1 != 47 )
    return 0LL;
  v11 = (signed __int64)(a1 + 1);
  v16 = sub_16564(a1 + 1);
  if ( (signed int)v16 <= 0 )
    return v16;
  *v9 = v11;
  *v8 = v16;
  v14 = v16 + 1;
  v12 = (_BYTE *)((signed int)v16 + v11);
  if ( *v12 == 58 )
  {
    *a2 = *v9;
    *v10 = *v8;
    v15 = v16 + 2;
    v13 = v12 + 1;
    v17 = sub_16564(v13);
    if ( (signed int)v17 <= 0 )
      return v17;
    *v9 = (signed __int64)v13;
    *v8 = v17;
    v14 = v17 + v15;
    v12 = &v13[v17];
  }
  if ( *v12 == 91 )
  {
    if ( v7 )
      *v7 = 1;
  }
  return v14;
}

//----- (0000000000017401) ----------------------------------------------------
__int64 __fastcall sub_17401(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8)
{
  char v9; // ST4F_1
  char **v10; // [rsp+0h] [rbp-50h]
  unsigned int *v11; // [rsp+8h] [rbp-48h]
  char **v12; // [rsp+10h] [rbp-40h]
  unsigned int *v13; // [rsp+18h] [rbp-38h]
  char *s; // [rsp+28h] [rbp-28h]
  char *sa; // [rsp+28h] [rbp-28h]
  char *sb; // [rsp+28h] [rbp-28h]
  char *sc; // [rsp+28h] [rbp-28h]
  int v18; // [rsp+40h] [rbp-10h]
  int v19; // [rsp+40h] [rbp-10h]
  int v20; // [rsp+40h] [rbp-10h]
  int v21; // [rsp+40h] [rbp-10h]
  unsigned int v22; // [rsp+40h] [rbp-10h]
  int v23; // [rsp+44h] [rbp-Ch]
  int v24; // [rsp+44h] [rbp-Ch]
  char *v25; // [rsp+48h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x312u, "parse_predicate");
  if ( a2 )
  {
    if ( !a3 )
      __assert_fail("mod_len", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x314u, "parse_predicate");
    *a2 = 0LL;
    *a3 = 0;
  }
  if ( a4 )
  {
    if ( !a5 )
      __assert_fail("nam_len", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x319u, "parse_predicate");
    *a4 = 0LL;
    *a5 = 0;
  }
  if ( a6 )
  {
    if ( !a7 )
      __assert_fail("val_len", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x31Eu, "parse_predicate");
    *a6 = 0LL;
    *a7 = 0;
  }
  if ( a8 )
    *a8 = 0;
  if ( *a1 != 91 )
    return 0LL;
  v18 = 1;
  for ( s = a1 + 1; (*__ctype_b_loc())[*s] & 0x2000; ++s )
    ++v18;
  if ( (*__ctype_b_loc())[*s] & 0x800 )
  {
    if ( v12 )
      *v12 = s;
    if ( *s == 48 )
      return (unsigned int)-v18;
    while ( (*__ctype_b_loc())[*s] & 0x800 )
    {
      ++v18;
      ++s;
    }
    if ( v11 )
      *v11 = (_DWORD)s - *(_DWORD *)v12;
  }
  else
  {
    if ( *s == 46 )
    {
      if ( v12 )
        *v12 = s;
      if ( v11 )
        *v11 = 1;
      v19 = v18 + 1;
      sa = s + 1;
    }
    else
    {
      v23 = sub_16637(s, a2, v13, v12, v11, 0LL, 0);
      if ( v23 <= 0 )
        return (unsigned int)(v23 - v18);
      v19 = v23 + v18;
      sa = &s[v23];
    }
    while ( (*__ctype_b_loc())[*sa] & 0x2000 )
    {
      ++v19;
      ++sa;
    }
    if ( *sa != 61 )
      return (unsigned int)-v19;
    v20 = v19 + 1;
    for ( sb = sa + 1; (*__ctype_b_loc())[*sb] & 0x2000; ++sb )
      ++v20;
    if ( *sb != 34 && *sb != 39 )
      return (unsigned int)-v20;
    v9 = *sb;
    v21 = v20 + 1;
    sc = sb + 1;
    v25 = strchr(sc, v9);
    if ( !v25 )
      return (unsigned int)-v21;
    v24 = (_DWORD)v25 - (_DWORD)sc;
    if ( v10 )
      *v10 = sc;
    if ( a7 )
      *a7 = v24;
    v18 = v24 + 1 + v21;
    s = &sc[v24 + 1];
  }
  while ( (*__ctype_b_loc())[*s] & 0x2000 )
  {
    ++v18;
    ++s;
  }
  if ( *s != 93 )
    return (unsigned int)-v18;
  v22 = v18 + 1;
  if ( s[1] == 91 )
  {
    if ( a8 )
      *a8 = 1;
  }
  return v22;
}

//----- (0000000000017847) ----------------------------------------------------
__int64 __fastcall sub_17847(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, int a9)
{
  unsigned int *v10; // [rsp+8h] [rbp-38h]
  _QWORD *v11; // [rsp+10h] [rbp-30h]
  unsigned int *v12; // [rsp+18h] [rbp-28h]
  char *s1; // [rsp+28h] [rbp-18h]
  signed int v14; // [rsp+38h] [rbp-8h]
  unsigned int v15; // [rsp+38h] [rbp-8h]
  int v16; // [rsp+3Ch] [rbp-4h]

  s1 = (char *)a1;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v14 = 0;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x3B7u, "parse_schema_nodeid");
  if ( !a6 )
    __assert_fail("is_relative", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x3B8u, "parse_schema_nodeid");
  if ( a7 )
    *a7 = 0;
  if ( *a1 == 47 )
  {
    if ( *a6 == -1 )
      *a6 = 0;
    v14 = 1;
    s1 = (char *)(a1 + 1);
  }
  else
  {
    if ( *a6 != -1 )
      return 0LL;
    *a6 = 1;
    if ( !strncmp(a1, "./", 2uLL) )
    {
      v14 = 2;
      s1 = (char *)(a1 + 2);
    }
  }
  v16 = sub_16637(s1, a2, v12, v11, v10, a8, a9);
  if ( v16 <= 0 )
    return (unsigned int)(v16 - v14);
  v15 = v16 + v14;
  if ( s1[v16] == 91 )
  {
    if ( a7 )
      *a7 = 1;
  }
  return v15;
}

//----- (00000000000179A7) ----------------------------------------------------
__int64 __fastcall sub_179A7(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8)
{
  char v9; // ST4F_1
  char **v10; // [rsp+0h] [rbp-50h]
  unsigned int *v11; // [rsp+8h] [rbp-48h]
  char **v12; // [rsp+10h] [rbp-40h]
  unsigned int *v13; // [rsp+18h] [rbp-38h]
  char *s; // [rsp+28h] [rbp-28h]
  char *sa; // [rsp+28h] [rbp-28h]
  char *sb; // [rsp+28h] [rbp-28h]
  char *sc; // [rsp+28h] [rbp-28h]
  signed int v18; // [rsp+40h] [rbp-10h]
  int v19; // [rsp+40h] [rbp-10h]
  int v20; // [rsp+40h] [rbp-10h]
  int v21; // [rsp+40h] [rbp-10h]
  unsigned int v22; // [rsp+40h] [rbp-10h]
  signed int i; // [rsp+44h] [rbp-Ch]
  int v24; // [rsp+44h] [rbp-Ch]
  char *v25; // [rsp+48h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x3F8u, "parse_schema_json_predicate");
  if ( a2 )
    *a2 = 0LL;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0LL;
  if ( a5 )
    *a5 = 0;
  if ( a6 )
    *a6 = 0LL;
  if ( a7 )
    *a7 = 0;
  if ( a8 )
    *a8 = 0;
  if ( *a1 != 91 )
    return 0LL;
  v18 = 1;
  for ( s = a1 + 1; (*__ctype_b_loc())[*s] & 0x2000; ++s )
    ++v18;
  if ( *s == 46 )
  {
    i = 1;
    if ( v12 )
      *v12 = s;
    if ( v11 )
      *v11 = 1;
  }
  else if ( (*__ctype_b_loc())[*s] & 0x800 )
  {
    if ( *s == 48 )
      return (unsigned int)-v18;
    for ( i = 1; (*__ctype_b_loc())[s[i]] & 0x800; ++i )
      ;
    if ( v12 )
      *v12 = s;
    if ( v11 )
      *v11 = i;
  }
  else
  {
    i = sub_16637(s, a2, v13, v12, v11, 0LL, 0);
    if ( i <= 0 )
      return (unsigned int)(i - v18);
  }
  v19 = i + v18;
  for ( sa = &s[i]; (*__ctype_b_loc())[*sa] & 0x2000; ++sa )
    ++v19;
  if ( *sa == 61 )
  {
    if ( v12 && (*__ctype_b_loc())[**v12] & 0x800 )
      return (unsigned int)-v19;
    v20 = v19 + 1;
    for ( sb = sa + 1; (*__ctype_b_loc())[*sb] & 0x2000; ++sb )
      ++v20;
    if ( *sb != 34 && *sb != 39 )
      return (unsigned int)-v20;
    v9 = *sb;
    v21 = v20 + 1;
    sc = sb + 1;
    v25 = strchr(sc, v9);
    if ( !v25 )
      return (unsigned int)-v21;
    v24 = (_DWORD)v25 - (_DWORD)sc;
    if ( v10 )
      *v10 = sc;
    if ( a7 )
      *a7 = v24;
    v19 = v24 + 1 + v21;
    for ( sa = &sc[v24 + 1]; (*__ctype_b_loc())[*sa] & 0x2000; ++sa )
      ++v19;
  }
  if ( *sa != 93 )
    return (unsigned int)-v19;
  v22 = v19 + 1;
  if ( sa[1] == 91 )
  {
    if ( a8 )
      *a8 = 1;
  }
  return v22;
}

//----- (0000000000017DBA) ----------------------------------------------------
_BOOL8 __fastcall sub_17DBA(const char **a1, const char ***a2, int a3, __int64 a4)
{
  _BOOL8 result; // rax
  unsigned int v5; // eax
  size_t v6; // r12
  const char *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rbx
  signed int i; // [rsp+24h] [rbp-4Ch]
  const char *v11; // [rsp+28h] [rbp-48h]
  const char **v12; // [rsp+30h] [rbp-40h]
  char *s1; // [rsp+38h] [rbp-38h]
  char *s1a; // [rsp+38h] [rbp-38h]
  const char *v15; // [rsp+40h] [rbp-30h]
  const char *v16; // [rsp+48h] [rbp-28h]
  const char *v17; // [rsp+50h] [rbp-20h]

  if ( a3 )
    __assert_fail("!mod", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x485u, "resolve_hash_table_find_equal");
  v15 = *a1;
  v16 = a1[1];
  v17 = a1[2];
  v12 = *a2;
  if ( **a2 != *a1 )
    return 0LL;
  v5 = *((_DWORD *)*v12 + 14);
  if ( v5 == 8 )
  {
    s1 = (char *)v12[7];
    result = !strncmp(v12[7], *((const char **)v17 + 4), *((signed int *)v17 + 10)) && !s1[*((signed int *)v17 + 10)];
  }
  else
  {
    if ( v5 <= 8 )
    {
      if ( v5 != 1 && v5 != 4 )
        goto LABEL_37;
      return 1LL;
    }
    if ( v5 == 32 || v5 == 32800 )
      return 1LL;
    if ( v5 != 16 )
    {
LABEL_37:
      sub_12222(
        **((_QWORD **)*v12 + 6),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        1221LL,
        a4);
      return 0LL;
    }
    if ( !(*v12)[30] )
      __assert_fail(
        "((struct lys_node_list *)val2->schema)->keys_size",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x49Cu,
        "resolve_hash_table_find_equal");
    if ( *((unsigned __int8 *)*v12 + 30) != (_DWORD)v16 )
      __assert_fail(
        "((struct lys_node_list *)val2->schema)->keys_size == pp.len",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x49Du,
        "resolve_hash_table_find_equal");
    v11 = v12[8];
    for ( i = 0; v11 && i < (signed int)v16; ++i )
    {
      if ( *(_QWORD *)&v17[48 * i] )
      {
        v6 = *(signed int *)&v17[48 * i + 8];
        v7 = *(const char **)&v17[48 * i];
        v8 = lyd_node_module(v11);
        if ( strncmp(*(const char **)(v8 + 8), v7, v6)
          || *(_BYTE *)(*(_QWORD *)(lyd_node_module(v11) + 8) + *(signed int *)&v17[48 * i + 8]) )
        {
          break;
        }
      }
      else
      {
        v9 = lyd_node_module(v11);
        if ( v9 != lys_node_module(v15) )
          break;
      }
      if ( strncmp(**(const char ***)v11, *(const char **)&v17[48 * i + 16], *(signed int *)&v17[48 * i + 24]) )
        break;
      if ( *(_BYTE *)(**(_QWORD **)v11 + *(signed int *)&v17[48 * i + 24]) )
        break;
      s1a = (char *)*((_QWORD *)v11 + 7);
      if ( strncmp(*((const char **)v11 + 7), *(const char **)&v17[48 * i + 32], *(signed int *)&v17[48 * i + 40])
        || s1a[*(signed int *)&v17[48 * i + 40]] )
      {
        break;
      }
      v11 = (const char *)*((_QWORD *)v11 + 3);
    }
    result = i == (_DWORD)v16;
  }
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000181E5) ----------------------------------------------------
__int64 __fastcall sub_181E5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9)
{
  __int64 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11; // rax
  unsigned int v12; // ST10_4
  unsigned __int64 v13; // rax
  unsigned int v14; // ST10_4
  int v15; // eax
  __int64 result; // rax
  unsigned int v17; // [rsp+10h] [rbp-30h]
  int i; // [rsp+14h] [rbp-2Ch]
  int v19; // [rsp+14h] [rbp-2Ch]
  __int64 *v20; // [rsp+18h] [rbp-28h]
  __int64 v21; // [rsp+20h] [rbp-20h]
  unsigned __int64 v22; // [rsp+28h] [rbp-18h]

  v22 = __readfsqword(0x28u);
  v20 = 0LL;
  if ( !a1 || !*(_DWORD *)(a1 + 48) )
    __assert_fail(
      "parent && parent->hash",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x4D1u,
      "resolve_json_data_node_hash");
  v21 = sub_14E64(*(_QWORD *)(a1 + 56), (__int64)sub_17DBA);
  v9 = lys_node_module(a7);
  v10 = strlen(*(const char **)(v9 + 8));
  v11 = lys_node_module(a7);
  v12 = sub_1476E(0, *(_QWORD *)(v11 + 8), v10);
  v13 = strlen(*(const char **)a7);
  v17 = sub_1476E(v12, *(_QWORD *)a7, v13);
  if ( *(_DWORD *)(a7 + 56) == 8 )
  {
    if ( a8 != 1 || **(_BYTE **)(a9 + 16) != 46 || *(_DWORD *)(a9 + 24) != 1 )
      __assert_fail(
        "(pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1)",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x4DAu,
        "resolve_json_data_node_hash");
    v14 = sub_1476E(v17, *(_QWORD *)(a9 + 32), *(signed int *)(a9 + 40));
    v15 = sub_1476E(v14, 0LL, 0LL);
  }
  else
  {
    if ( *(_DWORD *)(a7 + 56) == 16 )
    {
      for ( i = 0; i < a8; ++i )
        v17 = sub_1476E(v17, *(_QWORD *)(a9 + 48LL * i + 32), *(signed int *)(a9 + 48LL * i + 40));
    }
    v15 = sub_1476E(v17, 0LL, 0LL);
  }
  v19 = sub_154F1(*(_QWORD *)(a1 + 56), (__int64)&a7, v15, &v20);
  if ( !v19 && !*v20 )
    __assert_fail(
      "i || *ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x4E7u,
      "resolve_json_data_node_hash");
  sub_14E64(*(_QWORD *)(a1 + 56), v21);
  if ( v19 )
    result = 0LL;
  else
    result = *v20;
  return result;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000001844C) ----------------------------------------------------
signed __int64 __fastcall sub_1844C(char *a1, unsigned __int16 a2, __int64 a3, _QWORD *a4)
{
  signed __int64 result; // rax
  int v5; // er12
  char *v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rax
  __int64 v9; // r14
  __int64 v10; // r13
  __int16 v11; // r12
  __int64 v12; // rbx
  void **v13; // rax
  __int64 v14; // r14
  __int64 v15; // r13
  __int16 v16; // r12
  __int64 v17; // rbx
  void **v18; // rax
  __int64 v19; // r14
  __int64 v20; // r13
  __int16 v21; // r12
  __int64 v22; // rbx
  void **v23; // rax
  _QWORD *v24; // [rsp+0h] [rbp-80h]
  __int64 v25; // [rsp+8h] [rbp-78h]
  unsigned int v26; // [rsp+28h] [rbp-58h]
  int v27; // [rsp+2Ch] [rbp-54h]
  int v28; // [rsp+30h] [rbp-50h]
  int i; // [rsp+34h] [rbp-4Ch]
  char *v30; // [rsp+38h] [rbp-48h]
  char *s1; // [rsp+40h] [rbp-40h]
  __int64 v32; // [rsp+48h] [rbp-38h]
  void *ptr; // [rsp+50h] [rbp-30h]
  unsigned __int64 v34; // [rsp+58h] [rbp-28h]

  v25 = a3;
  v24 = a4;
  v34 = __readfsqword(0x28u);
  if ( !a4 )
    __assert_fail("feature", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x504u, "resolve_feature");
  v28 = sub_16637(a1, &v30, &v26, &s1, (unsigned int *)&v27, 0LL, 0);
  if ( v28 > 0 )
  {
    v5 = v26;
    v6 = v30;
    v7 = (__int64 *)lys_node_module(v25);
    v32 = sub_407F3(v7, 0LL, 0, v6, v5, 0);
    if ( v32 )
    {
      if ( v32 != *(_QWORD *)(v25 + 48) )
      {
        v8 = lys_node_module(v25);
        if ( v32 == v8 )
        {
          for ( i = 0; i < *(unsigned __int8 *)(*(_QWORD *)(v25 + 48) + 76LL); ++i )
          {
            if ( !strncmp(
                    s1,
                    *(const char **)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL)),
                    v27)
              && !*(_BYTE *)(*(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL)) + v27) )
            {
              v9 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL));
              v10 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL) + 48);
              v11 = *(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL) + 24);
              v12 = *(_QWORD *)v25;
              v13 = (void **)lys_node_module(v25);
              if ( (unsigned int)sub_3C749(*(_WORD *)(v25 + 24), v13, v12, v11, v10, v9, 0LL) )
                return 0xFFFFFFFFLL;
              *v24 = *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL) + ((signed __int64)i << 6);
              return 0LL;
            }
          }
        }
      }
      for ( i = 0; i < *(unsigned __int8 *)(v32 + 76); ++i )
      {
        if ( !strncmp(s1, *(const char **)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128)), v27)
          && !*(_BYTE *)(*(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128)) + v27) )
        {
          v14 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128));
          v15 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128) + 48);
          v16 = *(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128) + 24);
          v17 = *(_QWORD *)v25;
          v18 = (void **)lys_node_module(v25);
          if ( (unsigned int)sub_3C749(*(_WORD *)(v25 + 24), v18, v17, v16, v15, v14, 0LL) )
            return 0xFFFFFFFFLL;
          *v24 = *(_QWORD *)(v32 + 128) + ((signed __int64)i << 6);
          return 0LL;
        }
      }
      v28 = 0;
LABEL_35:
      if ( v28 < *(unsigned __int8 *)(v32 + 70) && *(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) )
      {
        for ( i = 0; ; ++i )
        {
          if ( i >= *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 76LL) )
          {
            ++v28;
            goto LABEL_35;
          }
          if ( !strncmp(
                  s1,
                  *(const char **)(((signed __int64)i << 6)
                                 + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL)),
                  v27)
            && !*(_BYTE *)(*(_QWORD *)(((signed __int64)i << 6)
                                     + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL))
                         + v27) )
          {
            break;
          }
        }
        v19 = *(_QWORD *)(((signed __int64)i << 6)
                        + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL));
        v20 = *(_QWORD *)(((signed __int64)i << 6)
                        + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL)
                        + 48);
        v21 = *(_WORD *)(((signed __int64)i << 6)
                       + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL)
                       + 24);
        v22 = *(_QWORD *)v25;
        v23 = (void **)lys_node_module(v25);
        if ( (unsigned int)sub_3C749(*(_WORD *)(v25 + 24), v23, v22, v21, v20, v19, 0LL) )
        {
          result = 0xFFFFFFFFLL;
        }
        else
        {
          *v24 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL) + ((signed __int64)i << 6);
          result = 0LL;
        }
      }
      else
      {
        ptr = strndup(a1, a2);
        sub_13937(**(void ***)(v25 + 48), 36, 0, 0LL, (__int64)"feature", (__int64)ptr, v24);
        free(ptr);
        result = 1LL;
      }
    }
    else
    {
      sub_13937(**(void ***)(v25 + 48), 29, 0, 0LL, v26, (__int64)v30, v24);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_13937(**(void ***)(v25 + 48), 55, 0, 0LL, (unsigned int)a1[-v28], (__int64)&a1[-v28], v24);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000018B8D) ----------------------------------------------------
__int64 __fastcall sub_18B8D(__int64 a1)
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a1 + 27); ++i )
  {
    if ( !(unsigned int)sub_18D14(32LL * i + *(_QWORD *)(a1 + 40)) )
      return 0LL;
  }
  return ((signed int)*(unsigned __int16 *)(a1 + 24) >> 8) & 1;
}

//----- (0000000000018BF1) ----------------------------------------------------
__int64 __fastcall sub_18BF1(__int64 *a1, int *a2, _DWORD *a3)
{
  __int64 v3; // rsi
  int v4; // eax
  __int64 result; // rax
  _DWORD *v6; // [rsp+8h] [rbp-28h]
  unsigned __int8 v7; // [rsp+27h] [rbp-9h]
  int v8; // [rsp+28h] [rbp-8h]
  int v9; // [rsp+2Ch] [rbp-4h]

  v6 = a3;
  v7 = sub_18F95(*a1, *a2);
  ++*a2;
  if ( (signed int)v7 > 2 )
  {
    if ( v7 == 3 )
    {
      v3 = a1[2];
      v4 = (*v6)++;
      return sub_18B8D(*(_QWORD *)(v3 + 8LL * v4));
    }
    return 0LL;
  }
  if ( (signed int)v7 < 1 )
  {
    if ( !v7 )
      return (unsigned int)sub_18BF1(a1, a2, v6) == 0;
    return 0LL;
  }
  v8 = sub_18BF1(a1, a2, v6);
  v9 = sub_18BF1(a1, a2, v6);
  if ( v7 == 1 )
    result = v8 && v9;
  else
    result = v8 || v9;
  return result;
}

//----- (0000000000018D14) ----------------------------------------------------
__int64 __fastcall sub_18D14(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+10h] [rbp-10h]
  int v3; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v2 = 0;
  v3 = 0;
  if ( *(_QWORD *)a1 && **(_QWORD **)(a1 + 16) )
    result = sub_18BF1((__int64 *)a1, &v2, &v3);
  else
    result = 0LL;
  return result;
}

//----- (0000000000018D8D) ----------------------------------------------------
signed __int64 __fastcall sub_18D8D(signed int *a1, char a2)
{
  __int64 v2; // r9
  signed __int64 result; // rax
  __int64 v4; // rsi
  signed int v5; // eax
  char v6; // [rsp+4h] [rbp-Ch]

  v6 = a2;
  if ( a1[1] != *a1 || (*a1 += 4, (*((_QWORD *)a1 + 1) = sub_C422(*((void **)a1 + 1), *a1)) != 0LL) )
  {
    v4 = *((_QWORD *)a1 + 1);
    v5 = a1[1];
    a1[1] = v5 + 1;
    *(_BYTE *)(v4 + v5) = v6;
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"iff_stack_push", v2);
    *a1 = 0;
    result = 1LL;
  }
  return result;
}

//----- (0000000000018E56) ----------------------------------------------------
__int64 __fastcall sub_18E56(__int64 a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + (signed int)--*(_DWORD *)(a1 + 4));
}

//----- (0000000000018E88) ----------------------------------------------------
void __fastcall sub_18E88(__int64 a1)
{
  *(_DWORD *)a1 = 0;
  free(*(void **)(a1 + 8));
}

//----- (0000000000018EB1) ----------------------------------------------------
__int64 __fastcall sub_18EB1(__int64 a1, unsigned __int8 a2, int a3)
{
  _BYTE *v3; // ST18_8
  __int64 result; // rax

  if ( a3 < 0 )
    __assert_fail("pos >= 0", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5AAu, "iff_setop");
  if ( a2 > 3u )
    __assert_fail("op <= 3", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5ABu, "iff_setop");
  v3 = (_BYTE *)(a3 / 4 + a1);
  *v3 &= ~(unsigned __int8)(3 << 2 * ((char)a3 % 4));
  result = a3 / 4 + a1;
  *v3 |= a2 << 2 * (a3 % 4);
  return result;
}

//----- (0000000000018F95) ----------------------------------------------------
__int64 __fastcall sub_18F95(__int64 a1, int a2)
{
  if ( a2 < 0 )
    __assert_fail("pos >= 0", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5B9u, "iff_getop");
  return (signed int)(unsigned __int8)(*(_BYTE *)(a2 / 4 + a1) & (3 << 2 * ((char)a2 % 4))) >> 2 * (a2 % 4);
}

//----- (000000000001902D) ----------------------------------------------------
__int64 __fastcall sub_1902D(__int64 *a1, int *a2, _DWORD *a3)
{
  __int64 result; // rax
  int v4; // eax
  _DWORD *v5; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+24h] [rbp-Ch]
  int v7; // [rsp+28h] [rbp-8h]
  signed int v8; // [rsp+2Ch] [rbp-4h]

  v5 = a3;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( !a1 )
    __assert_fail("iffeat", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5D0u, "resolve_iffeature_getsizes");
  result = *a1;
  if ( *a1 )
  {
    do
    {
      v4 = v6++;
      result = (unsigned __int8)sub_18F95(*a1, v4);
      if ( (signed int)result > 2 )
      {
        if ( (_DWORD)result == 3 )
        {
          ++v7;
          if ( v8 )
            --v8;
        }
      }
      else if ( (signed int)result >= 1 )
      {
        if ( v8 )
          ++v8;
        else
          v8 = 2;
      }
      else if ( !(_DWORD)result && !v8 )
      {
        v8 = 1;
      }
    }
    while ( v8 );
  }
  if ( a2 )
  {
    result = (__int64)a2;
    *a2 = v6;
  }
  if ( v5 )
  {
    result = (__int64)v5;
    *v5 = v7;
  }
  return result;
}

//----- (0000000000019120) ----------------------------------------------------
signed __int64 __fastcall sub_19120(__int64 *a1, char *a2, __int64 a3, int a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  int v8; // eax
  unsigned __int8 v9; // ST33_1
  int v10; // eax
  unsigned __int8 v11; // ST33_1
  int v12; // eax
  int v13; // eax
  __int64 v14; // r9
  int v15; // ST34_4
  unsigned __int8 v16; // ST33_1
  int v17; // eax
  __int64 v18; // [rsp+8h] [rbp-88h]
  int v19; // [rsp+14h] [rbp-7Ch]
  __int64 v20; // [rsp+18h] [rbp-78h]
  unsigned __int8 v21; // [rsp+33h] [rbp-5Dh]
  signed int v22; // [rsp+34h] [rbp-5Ch]
  unsigned int v23; // [rsp+38h] [rbp-58h]
  int i; // [rsp+3Ch] [rbp-54h]
  int j; // [rsp+3Ch] [rbp-54h]
  int v26; // [rsp+40h] [rbp-50h]
  int v27; // [rsp+40h] [rbp-50h]
  signed int v28; // [rsp+44h] [rbp-4Ch]
  signed int v29; // [rsp+48h] [rbp-48h]
  size_t nmemb; // [rsp+4Ch] [rbp-44h]
  unsigned int nmemba; // [rsp+4Ch] [rbp-44h]
  int nmemb_4; // [rsp+50h] [rbp-40h]
  signed int v33; // [rsp+54h] [rbp-3Ch]
  void *v34; // [rsp+60h] [rbp-30h]
  _QWORD *ptr; // [rsp+68h] [rbp-28h]
  int v36; // [rsp+70h] [rbp-20h]
  int v37; // [rsp+74h] [rbp-1Ch]
  _BYTE *v38; // [rsp+78h] [rbp-18h]
  unsigned __int64 v39; // [rsp+88h] [rbp-8h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v39 = __readfsqword(0x28u);
  v23 = 1;
  v29 = 0;
  nmemb = 0LL;
  v33 = 1;
  v36 = 0;
  v37 = 0;
  v38 = 0LL;
  v34 = **(void ***)(a3 + 48);
  if ( !a2 )
    __assert_fail("c", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x605u, "resolve_iffeature_compile");
  if ( (*__ctype_b_loc())[*a2] & 0x2000 )
  {
    sub_13937(v34, 55, 0, 0LL, (unsigned int)*a2, (__int64)a2);
    result = 1LL;
  }
  else
  {
    v28 = 0;
    v26 = 0;
    for ( i = 0; a2[i]; ++i )
    {
      if ( a2[i] == 40 )
      {
        v29 = 1;
        ++v26;
      }
      else if ( a2[i] == 41 )
      {
        --v26;
      }
      else if ( !((*__ctype_b_loc())[a2[i]] & 0x2000) )
      {
        v22 = 3;
        if ( !strncmp(&a2[i], "not", 3uLL)
          || (v22 = 3, !strncmp(&a2[i], "and", 3uLL))
          || (v22 = 2, !strncmp(&a2[i], "or", 2uLL)) )
        {
          if ( !a2[i + v22] )
          {
            sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
            return 1LL;
          }
          if ( (*__ctype_b_loc())[a2[i + v22]] & 0x2000 )
          {
            if ( a2[i] == 110 )
            {
              if ( v28 )
              {
                HIDWORD(nmemb) -= 2;
                v28 = 0;
              }
              else
              {
                v28 = 1;
              }
            }
            else
            {
              ++v33;
              v28 = 0;
            }
          }
          else
          {
            v28 = 0;
            LODWORD(nmemb) = nmemb + 1;
          }
          i += v22;
        }
        else
        {
          LODWORD(nmemb) = nmemb + 1;
          v28 = 0;
        }
        ++HIDWORD(nmemb);
        while ( !((*__ctype_b_loc())[a2[i]] & 0x2000) )
        {
          if ( a2[i] == 40 )
          {
            sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
            return 1LL;
          }
          if ( !a2[i] || a2[i] == 41 )
          {
            --i;
            break;
          }
          ++i;
        }
      }
    }
    if ( v26 || v33 != (_DWORD)nmemb )
    {
      sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
      result = 1LL;
    }
    else if ( (v29 || HIDWORD(nmemb) > 1) && (*(_BYTE *)(*(_QWORD *)(v20 + 48) + 64LL) & 0xE) != 4 )
    {
      sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
      sub_13937(v34, -1, 0, 0LL, (__int64)"YANG 1.1 if-feature expression found in 1.0 module.", v6);
      result = 1LL;
    }
    else
    {
      *a1 = (__int64)calloc((HIDWORD(nmemb) >> 2) + ((nmemb & 0x300000000LL) != 0), 1uLL);
      a1[2] = (__int64)calloc((unsigned int)nmemb, 8uLL);
      v38 = malloc(HIDWORD(nmemb));
      if ( v38 && *a1 && a1[2] )
      {
        v36 = HIDWORD(nmemb);
        LODWORD(nmemb) = nmemb - 1;
        nmemb_4 = HIDWORD(nmemb) - 1;
        for ( j = i - 1; j >= 0; --j )
        {
          if ( a2[j] == 41 )
          {
            sub_18D8D(&v36, 8);
          }
          else if ( a2[j] == 40 )
          {
            while ( 1 )
            {
              v21 = sub_18E56((__int64)&v36);
              if ( v21 == 8 )
                break;
              v8 = nmemb_4--;
              sub_18EB1(*a1, v21, v8);
            }
          }
          else if ( !((*__ctype_b_loc())[a2[j]] & 0x2000) )
          {
            v27 = j + 1;
            while ( j >= 0 && !((*__ctype_b_loc())[a2[j]] & 0x2000) && a2[j] != 40 )
              --j;
            if ( !strncmp(&a2[++j], "not", 3uLL) && (*__ctype_b_loc())[a2[j + 3]] & 0x2000 )
            {
              if ( !v37 || v38[v37 - 1] )
                sub_18D8D(&v36, 0);
              else
                sub_18E56((__int64)&v36);
            }
            else if ( !strncmp(&a2[j], "and", 3uLL) && (*__ctype_b_loc())[a2[j + 3]] & 0x2000 )
            {
              while ( v37 && v38[v37 - 1] <= 1u )
              {
                v9 = sub_18E56((__int64)&v36);
                v10 = nmemb_4--;
                sub_18EB1(*a1, v9, v10);
              }
              sub_18D8D(&v36, 1);
            }
            else if ( !strncmp(&a2[j], "or", 2uLL) && (*__ctype_b_loc())[a2[j + 2]] & 0x2000 )
            {
              while ( v37 && v38[v37 - 1] <= 2u )
              {
                v11 = sub_18E56((__int64)&v36);
                v12 = nmemb_4--;
                sub_18EB1(*a1, v11, v12);
              }
              sub_18D8D(&v36, 2);
            }
            else
            {
              v13 = nmemb_4--;
              sub_18EB1(*a1, 3u, v13);
              ptr = malloc(0x18uLL);
              if ( !ptr )
              {
                sub_12222(
                  (__int64)v34,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"resolve_iffeature_compile",
                  v14);
                goto LABEL_93;
              }
              *ptr = v20;
              ptr[1] = lydict_insert(**(_QWORD **)(v20 + 48), &a2[j], v27 - j);
              *((_DWORD *)ptr + 4) = v19;
              v15 = sub_2ABDE(*(__int64 **)(v20 + 48), v18, (__int64 *)(a1[2] + 8LL * nmemba--), 2u, ptr);
              if ( v15 == -1 )
              {
                lydict_remove(**(_QWORD **)(v20 + 48), ptr[1]);
                free(ptr);
                goto LABEL_93;
              }
            }
          }
        }
        while ( v37 )
        {
          v16 = sub_18E56((__int64)&v36);
          v17 = nmemb_4--;
          sub_18EB1(*a1, v16, v17);
        }
        if ( nmemb_4 == -1 && nmemba == -1 )
        {
          v23 = 0;
        }
        else
        {
          sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
          v23 = 1;
        }
      }
      else
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_iffeature_compile", v7);
      }
LABEL_93:
      sub_18E88((__int64)&v36);
      result = v23;
    }
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000019BA2) ----------------------------------------------------
__int64 *__fastcall sub_19BA2(const char *a1, __int64 *a2)
{
  __int64 v3; // r9
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 *v6; // rax
  __int64 v7; // [rsp+18h] [rbp-38h]
  char *v8; // [rsp+20h] [rbp-30h]
  __int64 *v9; // [rsp+28h] [rbp-28h]
  __int64 *i; // [rsp+30h] [rbp-20h]
  void *ptr; // [rsp+38h] [rbp-18h]
  char *v12; // [rsp+40h] [rbp-10h]
  unsigned __int64 v13; // [rsp+48h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = 0LL;
  v7 = 0LL;
  if ( !a1 || !a2 )
    __assert_fail(
      "nodeid && start",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x6BFu,
      "resolve_data_descendant_schema_nodeid");
  if ( *a1 == 47 )
    return 0LL;
  v8 = strdup(a1);
  ptr = v8;
  if ( !v8 )
  {
    sub_12222(
      **(_QWORD **)(*a2 + 48),
      0,
      1,
      "Memory allocation failed (%s()).",
      (__int64)"resolve_data_descendant_schema_nodeid",
      v3,
      a2);
    return 0LL;
  }
  while ( v8 )
  {
    v12 = v8;
    v8 = strchr(v8, 47);
    if ( v8 )
      *v8++ = 0;
    if ( !v8 )
    {
      if ( v7 )
        v5 = *(_QWORD *)(v7 + 72);
      else
        v5 = *a2;
      if ( (unsigned int)sub_1AF63(v12, v5, 4, 0, &v7) || !v7 )
      {
        v9 = 0LL;
        break;
      }
      goto LABEL_25;
    }
    if ( v7 )
      v4 = *(_QWORD *)(v7 + 72);
    else
      v4 = *a2;
    if ( (unsigned int)sub_1AF63(v12, v4, 71, 0, &v7) || !v7 )
    {
      v9 = 0LL;
      break;
    }
    if ( !(*(_DWORD *)(v7 + 56) & 0x42) )
    {
LABEL_25:
      if ( v9 )
        v6 = (__int64 *)v9[8];
      else
        v6 = a2;
      for ( i = v6; i; i = (__int64 *)i[3] )
      {
        if ( *i == v7 )
        {
          v9 = i;
          break;
        }
      }
      if ( !i )
      {
        v9 = 0LL;
        break;
      }
    }
  }
  free(ptr);
  return v9;
}

//----- (0000000000019DE6) ----------------------------------------------------
signed __int64 __fastcall sub_19DE6(const char **a1, __int64 *a2, char *a3, int a4, const char *a5, int a6)
{
  int v7; // [rsp+10h] [rbp-30h]
  int v8; // [rsp+14h] [rbp-2Ch]
  char *v9; // [rsp+18h] [rbp-28h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a6;
  if ( *a5 == 42 )
    return 2LL;
  if ( *a5 == 46 )
    return 3LL;
  if ( strncmp(a5, *a1, a6) || (*a1)[v7] )
    return 1LL;
  if ( v9 )
  {
    v10 = sub_407F3(a2, 0LL, 0, v9, v8, 0);
    if ( !v10 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v10 = (__int64)a2;
  }
  return v10 != lys_node_module(a1);
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000019ED6) ----------------------------------------------------
signed __int64 __fastcall sub_19ED6(_BYTE *a1, __int64 a2, void **a3, _DWORD *a4)
{
  size_t v5; // r12
  char *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rax
  _DWORD *v9; // [rsp+0h] [rbp-70h]
  void **v10; // [rsp+8h] [rbp-68h]
  _BYTE *v11; // [rsp+18h] [rbp-58h]
  int v12; // [rsp+2Ch] [rbp-44h]
  int v13; // [rsp+30h] [rbp-40h]
  int v14; // [rsp+34h] [rbp-3Ch]
  int i; // [rsp+38h] [rbp-38h]
  int v16; // [rsp+3Ch] [rbp-34h]
  char *v17; // [rsp+40h] [rbp-30h]
  char *s2; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  unsigned __int64 v20; // [rsp+58h] [rbp-18h]

  v11 = a1;
  v10 = a3;
  v9 = a4;
  v20 = __readfsqword(0x28u);
  if ( !(*(_DWORD *)(a2 + 56) & 0x18) )
    return 1LL;
  v19 = a2;
  while ( 1 )
  {
    v16 = sub_179A7(v11, &v17, (unsigned int *)&v12, &s2, (unsigned int *)&v13, 0LL, 0LL, &v14);
    if ( v16 <= 0 )
    {
      sub_13937(*v10, 78, 0, 0LL, (unsigned int)(char)v11[v16], (__int64)&v11[v16], v9);
      return 0xFFFFFFFFLL;
    }
    v11 += v16;
    if ( *(_DWORD *)(a2 + 56) == 8 )
      break;
    for ( i = 0; i < *(unsigned __int8 *)(v19 + 30); ++i )
    {
      if ( !strncmp(**(const char ***)(8LL * i + *(_QWORD *)(v19 + 136)), s2, v13)
        && !*(_BYTE *)(**(_QWORD **)(8LL * i + *(_QWORD *)(v19 + 136)) + v13) )
      {
        if ( v17 )
        {
          v5 = v12;
          v6 = v17;
          v7 = lys_node_module(*(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 136)));
          if ( !strncmp(*(const char **)(v7 + 8), v6, v5) )
          {
            v8 = lys_node_module(*(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 136)));
            if ( !*(_BYTE *)(*(_QWORD *)(v8 + 8) + v12) )
              break;
          }
        }
        else if ( v10 == (void **)lys_node_module(*(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 136))) )
        {
          break;
        }
      }
    }
    if ( i == *(unsigned __int8 *)(v19 + 30) )
      return 1LL;
    if ( !v14 )
      goto LABEL_25;
  }
  if ( v17 || !s2 || *s2 != 46 || v14 )
    return 1LL;
LABEL_25:
  if ( !*v11 )
    *v9 = 1;
  return 0LL;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000001A193) ----------------------------------------------------
signed __int64 __fastcall sub_1A193(char *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5, int a6)
{
  signed __int64 result; // rax
  int *v7; // rax
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  int v13; // eax
  __int64 v14; // r8
  __int64 v15; // r9
  char *v16; // rdi
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // rbx
  __int64 v20; // r9
  __int64 v21; // rbx
  __int64 v22; // rax
  __int64 v23; // r8
  __int64 v24; // r9
  int *v25; // rax
  int v26; // [rsp+8h] [rbp-D8h]
  int v27; // [rsp+Ch] [rbp-D4h]
  _QWORD *v28; // [rsp+10h] [rbp-D0h]
  __int64 v29; // [rsp+18h] [rbp-C8h]
  __int64 v30; // [rsp+20h] [rbp-C0h]
  char *v31; // [rsp+28h] [rbp-B8h]
  int v32; // [rsp+3Ch] [rbp-A4h]
  int v33; // [rsp+40h] [rbp-A0h]
  int v34; // [rsp+44h] [rbp-9Ch]
  int v35; // [rsp+48h] [rbp-98h]
  int v36; // [rsp+4Ch] [rbp-94h]
  int v37; // [rsp+50h] [rbp-90h]
  int v38; // [rsp+54h] [rbp-8Ch]
  int v39; // [rsp+58h] [rbp-88h]
  int v40; // [rsp+5Ch] [rbp-84h]
  const char *v41; // [rsp+60h] [rbp-80h]
  char *string; // [rsp+68h] [rbp-78h]
  char *s; // [rsp+70h] [rbp-70h]
  char *v44; // [rsp+78h] [rbp-68h]
  const char *v45; // [rsp+80h] [rbp-60h]
  __int64 v46; // [rsp+88h] [rbp-58h]
  __int64 v47; // [rsp+90h] [rbp-50h]
  __int64 i; // [rsp+98h] [rbp-48h]
  __int64 v49; // [rsp+A0h] [rbp-40h]
  __int64 v50; // [rsp+A8h] [rbp-38h]
  __int64 v51; // [rsp+B0h] [rbp-30h]
  void *v52; // [rsp+B8h] [rbp-28h]
  void *ptr; // [rsp+C0h] [rbp-20h]
  unsigned __int64 v54; // [rsp+C8h] [rbp-18h]

  v31 = a1;
  v30 = a2;
  v29 = a3;
  v28 = a4;
  v27 = a5;
  v26 = a6;
  v54 = __readfsqword(0x28u);
  v44 = 0LL;
  v45 = 0LL;
  v33 = 0;
  v34 = -1;
  v37 = 0;
  v40 = 0;
  v51 = 0LL;
  if ( !a1 || !a2 && !a3 || !a4 )
    __assert_fail(
      "nodeid && (start_parent || cur_module) && ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x766u,
      "resolve_schema_nodeid");
  *a4 = 0LL;
  if ( !a3 )
    v29 = lys_node_module(a2);
  v52 = *(void **)v29;
  s = a1;
  v38 = sub_17847(a1, &string, (unsigned int *)&v33, &v41, (unsigned int *)&v32, &v34, 0LL, 0LL, 1);
  if ( v38 <= 0 )
  {
    sub_13937(v52, 78, 0, 0LL, (unsigned int)s[-v38], (__int64)&s[-v38]);
    return 0xFFFFFFFFLL;
  }
  if ( *v41 == 35 )
  {
    if ( v34 )
    {
      sub_13937(v52, 78, 0, 0LL, 35LL, (__int64)v41);
      return 0xFFFFFFFFLL;
    }
    v45 = v41 + 1;
    v39 = v32 - 1;
    v44 = string;
    v40 = v33;
    s += v38;
  }
  else
  {
    v34 = -1;
  }
  if ( v27 )
    v7 = &v35;
  else
    v7 = 0LL;
  v38 = sub_17847(s, &string, (unsigned int *)&v33, &v41, (unsigned int *)&v32, &v34, &v36, v7, v27);
  if ( v38 <= 0 )
  {
    sub_13937(v52, 78, 0, 0LL, (unsigned int)s[-v38], (__int64)&s[-v38]);
    return 0xFFFFFFFFLL;
  }
  s += v38;
  if ( v44 )
  {
    string = v44;
    v33 = v40;
  }
  if ( v34 && !a2 )
  {
    sub_13937(v52, -1, 4u, a1, (__int64)"Starting node must be provided for relative paths.", v8);
    return 0xFFFFFFFFLL;
  }
  if ( v34 )
  {
    v50 = lys_node_module(a2);
    v29 = v50;
  }
  else
  {
    v50 = sub_407F3((__int64 *)v29, 0LL, 0, string, v33, 0);
    if ( !v50 )
    {
      ptr = strndup(string, v33);
      sub_13937(v52, 79, 4u, (char *)ptr, v9, v10);
      free(ptr);
      return 0xFFFFFFFFLL;
    }
    v30 = 0LL;
    if ( v45 )
    {
      v30 = sub_40D5F(v50, v45, v39);
      if ( !v30 )
      {
        ptr = strndup(a1, &v45[v39] - a1);
        sub_13937(v52, 81, 4u, (char *)ptr, v11, v12);
        free(ptr);
        return 0xFFFFFFFFLL;
      }
    }
  }
  while ( 2 )
  {
    v46 = 0LL;
    v49 = 0LL;
    if ( !v30 )
      goto LABEL_111;
    if ( !string
      || !strncmp(string, *(const char **)(v29 + 8), v33) && (v13 = strlen(*(const char **)(v29 + 8)), v13 == v33) )
    {
      v51 = v29;
    }
    else
    {
      v51 = sub_407F3((__int64 *)v29, 0LL, 0, string, v33, 0);
      if ( !v51 )
      {
        ptr = strndup(string, v33);
        sub_13937(v52, 79, 4u, (char *)ptr, v14, v15);
        free(ptr);
        return 0xFFFFFFFFLL;
      }
    }
    if ( v27 )
      goto LABEL_111;
    while ( 2 )
    {
      v49 = sub_AA881(v49, v51, v30);
LABEL_111:
      while ( 1 )
      {
        v22 = v49 ? v49 : v30;
        v46 = lys_getnext(v46, v22, v50, 395LL);
        if ( !v46 )
          break;
        v16 = (char *)v46;
        v38 = sub_19DE6((const char **)v46, (__int64 *)v29, string, v33, v41, v32);
        if ( !v27 || v38 && v38 != 2 && v38 != 3 || !v36 )
        {
          if ( !*s )
            v37 = 1;
          goto LABEL_51;
        }
        v16 = s;
        v38 = sub_19ED6(s, v46, (void **)v29, &v37);
        if ( v38 != 1 )
        {
          if ( v38 == -1 )
            return 0xFFFFFFFFLL;
LABEL_51:
          if ( !v38 )
          {
            if ( v37 )
            {
              *v28 = ly_set_new(v16);
              if ( !*v28 )
              {
                sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_schema_nodeid", v17);
                return 0xFFFFFFFFLL;
              }
              ly_set_add(*v28, v46, 1LL);
            }
            else
            {
              if ( *(_DWORD *)(v46 + 56) & 0x802C )
                return 0xFFFFFFFFLL;
              v30 = v46;
            }
            break;
          }
          if ( v38 != 1 )
          {
            if ( v38 == 2 )
            {
              if ( !*v28 )
              {
                *v28 = ly_set_new(v16);
                if ( !*v28 )
                {
                  sub_12222(
                    (__int64)v52,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"resolve_schema_nodeid",
                    v18);
                  return 0xFFFFFFFFLL;
                }
              }
              ly_set_add(*v28, v46, 1LL);
              if ( v35 )
              {
                v47 = v46;
                for ( i = v46; i; i = v47 )
                {
                  if ( i != v46 )
                    ly_set_add(*v28, i, 1LL);
                  if ( *(_DWORD *)(i + 56) & 0x802C )
                    v47 = 0LL;
                  else
                    v47 = *(_QWORD *)(i + 72);
                  if ( !v47 )
                  {
                    if ( i == v46 )
                      goto LABEL_111;
                    v47 = *(_QWORD *)(i + 80);
                  }
                  while ( !v47 )
                  {
                    i = *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(i + 64) + 88LL) : *(_QWORD *)(i + 64);
                    v19 = lys_parent(i);
                    if ( v19 == lys_parent(v46) )
                      break;
                    v47 = *(_QWORD *)(i + 80);
                  }
                }
              }
            }
            else
            {
              if ( v38 != 3 )
              {
                sub_12222(
                  (__int64)v52,
                  0,
                  4,
                  "Internal error (%s:%d).",
                  (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
                  2062LL);
                return 0xFFFFFFFFLL;
              }
              if ( !*v28 )
              {
                *v28 = ly_set_new(v16);
                if ( !*v28 )
                {
                  sub_12222(
                    (__int64)v52,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"resolve_schema_nodeid",
                    v20);
                  return 0xFFFFFFFFLL;
                }
                if ( v30 )
                  ly_set_add(*v28, v30, 1LL);
              }
              ly_set_add(*v28, v46, 1LL);
              if ( v35 )
              {
                v47 = v46;
                for ( i = v46; i; i = v47 )
                {
                  if ( i != v46 )
                    ly_set_add(*v28, i, 1LL);
                  if ( *(_DWORD *)(i + 56) & 0x802C )
                    v47 = 0LL;
                  else
                    v47 = *(_QWORD *)(i + 72);
                  if ( !v47 )
                  {
                    if ( i == v46 )
                      goto LABEL_111;
                    v47 = *(_QWORD *)(i + 80);
                  }
                  while ( !v47 )
                  {
                    i = *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(i + 64) + 88LL) : *(_QWORD *)(i + 64);
                    v21 = lys_parent(i);
                    if ( v21 == lys_parent(v46) )
                      break;
                    v47 = *(_QWORD *)(i + 80);
                  }
                }
              }
            }
          }
        }
      }
      if ( v27 && v36 )
      {
        while ( *s == 91 )
        {
          s = strchr(s, 93);
          if ( !s )
          {
            sub_12222(
              (__int64)v52,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              2072LL);
            return 0xFFFFFFFFLL;
          }
          ++s;
        }
      }
      if ( v37 && (!v38 || v38 == 2 || v38 == 3) )
        return 0LL;
      if ( !v46 )
      {
        if ( !v49 )
        {
          if ( v26 )
          {
            ptr = strndup(v31, v41 - v31 + v32);
            sub_13937(v52, 81, 4u, (char *)ptr, v23, v24);
            free(ptr);
            result = 0xFFFFFFFFLL;
          }
          else
          {
            *v28 = 0LL;
            result = 0LL;
          }
          return result;
        }
        continue;
      }
      break;
    }
    if ( v27 )
      v25 = &v35;
    else
      v25 = 0LL;
    v38 = sub_17847(s, &string, (unsigned int *)&v33, &v41, (unsigned int *)&v32, &v34, &v36, v25, v27);
    if ( v38 > 0 )
    {
      s += v38;
      continue;
    }
    break;
  }
  sub_13937(v52, 78, 0, 0LL, (unsigned int)s[-v38], (__int64)&s[-v38]);
  return 0xFFFFFFFFLL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000001AF63) ----------------------------------------------------
signed __int64 __fastcall sub_1AF63(const char *a1, __int64 a2, int a3, int a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-70h]
  int v7; // [rsp+8h] [rbp-68h]
  int v8; // [rsp+Ch] [rbp-64h]
  int v9; // [rsp+28h] [rbp-48h]
  int v10; // [rsp+2Ch] [rbp-44h]
  int v11; // [rsp+30h] [rbp-40h]
  int v12; // [rsp+34h] [rbp-3Ch]
  const char *v13; // [rsp+38h] [rbp-38h]
  char *v14; // [rsp+40h] [rbp-30h]
  const char *v15; // [rsp+48h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp-20h]
  __int64 i; // [rsp+58h] [rbp-18h]
  __int64 *v18; // [rsp+60h] [rbp-10h]
  unsigned __int64 v19; // [rsp+68h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v19 = __readfsqword(0x28u);
  v11 = -1;
  if ( !a1 || !a5 )
    __assert_fail(
      "nodeid && ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x850u,
      "resolve_descendant_schema_nodeid");
  if ( a3 & 0x3800 )
    __assert_fail(
      "!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x851u,
      "resolve_descendant_schema_nodeid");
  if ( !a2 )
    return 0LL;
  v15 = a1;
  v18 = (__int64 *)lys_node_module(a2);
  v12 = sub_17847(a1, &v14, (unsigned int *)&v10, &v13, (unsigned int *)&v9, &v11, 0LL, 0LL, 0);
  if ( v12 <= 0 )
    return (unsigned int)((_DWORD)v15 - (_DWORD)a1 - v12 + 1);
  v15 += v12;
  if ( !v11 )
    return 0xFFFFFFFFLL;
  for ( i = lys_parent(a2); *(_DWORD *)(i + 56) == 4096 && lys_parent(i); i = lys_parent(i) )
    ;
  while ( 1 )
  {
    v16 = 0LL;
    while ( 1 )
    {
      v16 = lys_getnext(v16, i, v18, 387LL);
      if ( !v16 )
        break;
      v12 = sub_19DE6((const char **)v16, v18, v14, v10, v13, v9);
      if ( v12 )
      {
        if ( v12 != 1 )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( *v15 )
        {
          i = v16;
          break;
        }
        if ( *(_DWORD *)(v16 + 56) & v8 )
        {
          *v6 = v16;
          return 0LL;
        }
      }
    }
    if ( !v16 )
    {
      *v6 = 0LL;
      return 0LL;
    }
    if ( v7 && *(_DWORD *)(v16 + 56) == 16 )
    {
      *v6 = 0LL;
      return 4294967294LL;
    }
    v12 = sub_17847(v15, &v14, (unsigned int *)&v10, &v13, (unsigned int *)&v9, &v11, 0LL, 0LL, 0);
    if ( v12 <= 0 )
      return (unsigned int)((_DWORD)v15 - (_DWORD)a1 - v12 + 1);
    v15 += v12;
  }
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000001B236) ----------------------------------------------------
signed __int64 __fastcall sub_1B236(const char *a1, __int64 a2, _QWORD *a3)
{
  signed __int64 result; // rax
  _QWORD *v4; // [rsp+8h] [rbp-18h]

  v4 = a3;
  if ( strchr(a1, 47) )
    result = 0xFFFFFFFFLL;
  else
    result = sub_1AF63(a1, a2, 32895, 0, v4);
  return result;
}

//----- (000000000001B28A) ----------------------------------------------------
signed __int64 __fastcall sub_1B28A(_BYTE *a1, __int64 a2, __int64 *a3)
{
  __int64 v4; // rax
  __int64 *v5; // [rsp+10h] [rbp-48h]
  __int64 v6; // [rsp+18h] [rbp-40h]
  int v7; // [rsp+2Ch] [rbp-2Ch]
  char v8; // [rsp+30h] [rbp-28h]
  int v9; // [rsp+34h] [rbp-24h]
  const char *v10; // [rsp+38h] [rbp-20h]
  const char *v11; // [rsp+40h] [rbp-18h]
  __int64 v12; // [rsp+48h] [rbp-10h]
  unsigned __int64 v13; // [rsp+50h] [rbp-8h]

  v6 = a2;
  v5 = a3;
  v13 = __readfsqword(0x28u);
  v9 = sub_16637(a1, &v10, (unsigned int *)&v7, &v11, (unsigned int *)&v8, 0LL, 0);
  if ( v9 <= 0 || a1[v9] )
    return (unsigned int)(1 - v9);
  v12 = sub_407F3(*(__int64 **)(a2 + 48), v10, v7, 0LL, 0, 0);
  if ( !v12 )
    return 0xFFFFFFFFLL;
  v4 = lys_main_module(*(_QWORD *)(a2 + 48));
  if ( v12 != v4 )
    v6 = *(_QWORD *)(v12 + 168);
  *v5 = sub_9BDFE(v11, v6);
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000001B39D) ----------------------------------------------------
signed __int64 __fastcall sub_1B39D(const char *a1, __int64 *a2, int a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-70h]
  int v6; // [rsp+Ch] [rbp-64h]
  int v7; // [rsp+28h] [rbp-48h]
  int v8; // [rsp+2Ch] [rbp-44h]
  int v9; // [rsp+30h] [rbp-40h]
  int v10; // [rsp+34h] [rbp-3Ch]
  const char *v11; // [rsp+38h] [rbp-38h]
  char *v12; // [rsp+40h] [rbp-30h]
  const char *v13; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  __int64 v16; // [rsp+60h] [rbp-10h]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v17 = __readfsqword(0x28u);
  v9 = -1;
  if ( !a1 || !a2 || !a4 )
    __assert_fail(
      "nodeid && module && ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x8C3u,
      "resolve_absolute_schema_nodeid");
  if ( a3 & 0x3000 || a3 != 2048 && a3 & 0x800 )
    __assert_fail(
      "!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x8C4u,
      "resolve_absolute_schema_nodeid");
  v13 = a1;
  v15 = 0LL;
  v10 = sub_17847(a1, &v12, (unsigned int *)&v8, &v11, (unsigned int *)&v7, &v9, 0LL, 0LL, 0);
  if ( v10 <= 0 )
    return (unsigned int)((_DWORD)v13 - (_DWORD)a1 - v10 + 1);
  v13 += v10;
  if ( v9 )
    return 0xFFFFFFFFLL;
  v16 = sub_407F3(a2, 0LL, 0, v12, v8, 0);
  if ( !v16 )
    return 0xFFFFFFFFLL;
  while ( 1 )
  {
    v14 = 0LL;
    while ( 1 )
    {
      v14 = lys_getnext(v14, v15, v16, 271LL);
      if ( !v14 )
        break;
      v10 = sub_19DE6((const char **)v14, a2, v12, v8, v11, v7);
      if ( v10 )
      {
        if ( v10 != 1 )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( *v13 )
        {
          v15 = v14;
          break;
        }
        if ( *(_DWORD *)(v14 + 56) & v6 )
        {
          *v5 = v14;
          return 0LL;
        }
      }
    }
    if ( !v14 )
    {
      *v5 = 0LL;
      return 0LL;
    }
    v10 = sub_17847(v13, &v12, (unsigned int *)&v8, &v11, (unsigned int *)&v7, &v9, 0LL, 0LL, 0);
    if ( v10 <= 0 )
      return (unsigned int)((_DWORD)v13 - (_DWORD)a1 - v10 + 1);
    v13 += v10;
  }
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001B647) ----------------------------------------------------
__int64 __fastcall sub_1B647(_BYTE *a1, __int64 a2, _DWORD *a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  _DWORD *v5; // [rsp+8h] [rbp-48h]
  _BYTE *v6; // [rsp+18h] [rbp-38h]
  char v7; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  int v9; // [rsp+28h] [rbp-28h]
  int i; // [rsp+2Ch] [rbp-24h]
  char v11; // [rsp+30h] [rbp-20h]
  char *s1; // [rsp+38h] [rbp-18h]
  const char **v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v14 = __readfsqword(0x28u);
  i = sub_179A7(a1, &v11, (unsigned int *)&v7, &s1, (unsigned int *)&v8, 0LL, 0LL, &v9);
  if ( i <= 0 || !strncmp(s1, ".", v8) )
  {
    sub_13937(**(void ***)(a2 + 48), 78, 0, 0LL, (unsigned int)(char)a1[-i], (__int64)&a1[-i]);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v6 = &a1[i];
    *v5 += i;
    if ( (*__ctype_b_loc())[*s1] & 0x800 )
      goto LABEL_17;
    for ( i = 0; i < *(unsigned __int8 *)(a2 + 30); ++i )
    {
      v13 = *(const char ***)(8LL * i + *(_QWORD *)(a2 + 136));
      if ( !strncmp(*v13, s1, v8) && !(*v13)[v8] )
        break;
    }
    if ( i != *(unsigned __int8 *)(a2 + 30) )
    {
LABEL_17:
      if ( v9 )
        result = sub_1B647(v6, a2, v5);
      else
        result = 0LL;
    }
    else
    {
      sub_13937(**(void ***)(a2 + 48), 82, 0, 0LL, (__int64)s1, v4);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000001B854) ----------------------------------------------------
__int64 __fastcall sub_1B854(char *a1, void *a2, __int64 a3, int a4)
{
  __int64 result; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // [rsp+4h] [rbp-ACh]
  __int64 v18; // [rsp+8h] [rbp-A8h]
  void *v19; // [rsp+10h] [rbp-A0h]
  int v20; // [rsp+2Ch] [rbp-84h]
  int v21; // [rsp+30h] [rbp-80h]
  int v22; // [rsp+34h] [rbp-7Ch]
  int v23; // [rsp+38h] [rbp-78h]
  int v24; // [rsp+3Ch] [rbp-74h]
  int v25; // [rsp+40h] [rbp-70h]
  int v26; // [rsp+44h] [rbp-6Ch]
  char *s1; // [rsp+48h] [rbp-68h]
  char *v28; // [rsp+50h] [rbp-60h]
  char *v29; // [rsp+58h] [rbp-58h]
  char *v30; // [rsp+60h] [rbp-50h]
  const char *v31; // [rsp+68h] [rbp-48h]
  __int64 v32; // [rsp+70h] [rbp-40h]
  __int64 i; // [rsp+78h] [rbp-38h]
  __int64 j; // [rsp+80h] [rbp-30h]
  __int64 v35; // [rsp+88h] [rbp-28h]
  __int64 v36; // [rsp+90h] [rbp-20h]
  __int64 v37; // [rsp+98h] [rbp-18h]
  void *ptr; // [rsp+A0h] [rbp-10h]
  unsigned __int64 v39; // [rsp+A8h] [rbp-8h]

  v19 = a2;
  v18 = a3;
  v17 = a4;
  v39 = __readfsqword(0x28u);
  v30 = 0LL;
  v31 = 0LL;
  v23 = -1;
  if ( !a1 || !a2 && !a3 )
    __assert_fail(
      "nodeid && (ctx || start)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x931u,
      "resolve_json_nodeid");
  if ( !a2 )
    v19 = **(void ***)(a3 + 48);
  v29 = a1;
  v20 = sub_17847(a1, &v28, (unsigned int *)&v22, &s1, (unsigned int *)&v21, &v23, 0LL, 0LL, 1);
  if ( v20 <= 0 )
  {
    sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
    return 0LL;
  }
  if ( *s1 == 35 )
  {
    if ( v23 )
    {
      sub_13937(v19, 78, 0, 0LL, 35LL, (__int64)s1);
      return 0LL;
    }
    v31 = s1 + 1;
    v25 = v21 - 1;
    v30 = v28;
    v26 = v22;
    v29 += v20;
  }
  else
  {
    v23 = -1;
  }
  v20 = sub_17847(v29, &v28, (unsigned int *)&v22, &s1, (unsigned int *)&v21, &v23, &v24, 0LL, 0);
  if ( v20 <= 0 )
  {
    sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
    return 0LL;
  }
  v29 += v20;
  if ( v30 )
  {
    v28 = v30;
    v22 = v26;
  }
  if ( v23 )
  {
    if ( !v18 )
      __assert_fail("start", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x957u, "resolve_json_nodeid");
    for ( i = v18; i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
      ;
    v36 = *(_QWORD *)(v18 + 48);
  }
  else
  {
    if ( !v28 )
    {
      ptr = strndup(a1, &s1[v21] - a1);
      sub_13937(v19, 80, 4u, a1, v5, v6);
      free(ptr);
      return 0LL;
    }
    ptr = strndup(v28, v22);
    v36 = ly_ctx_get_module(v19, ptr, 0LL, 1LL);
    free(ptr);
    if ( !v36 )
    {
      ptr = strndup(a1, &v28[v22] - a1);
      sub_13937(v19, 79, 4u, (char *)ptr, v7, v8);
      free(ptr);
      return 0LL;
    }
    i = 0LL;
    if ( v31 )
    {
      i = sub_40D5F(v36, v31, v25);
      if ( !i )
      {
        ptr = strndup(a1, &v31[v25] - a1);
        sub_13937(v19, 81, 4u, (char *)ptr, v9, v10);
        free(ptr);
        return 0LL;
      }
    }
    v28 = 0LL;
    v22 = 0;
  }
  v37 = v36;
  while ( 2 )
  {
    v32 = 0LL;
    while ( 1 )
    {
      v32 = lys_getnext(v32, i, v36, 0LL);
      if ( !v32 )
        break;
      if ( *(_QWORD *)v32 && !strncmp(s1, *(const char **)v32, v21) && !*(_BYTE *)(*(_QWORD *)v32 + v21) )
      {
        for ( j = lys_parent(v32); j && !(*(_DWORD *)(j + 56) & 0x600); j = lys_parent(j) )
          ;
        if ( !j || (!v17 || *(_DWORD *)(j + 56) != 512) && (v17 || *(_DWORD *)(j + 56) != 1024) )
        {
          if ( v28 )
          {
            v35 = sub_E085((__int64)v19, v28, v22, 0LL, 1);
            if ( !v35 )
            {
              ptr = strndup(a1, &v28[v22] - a1);
              sub_13937(v19, 79, 4u, (char *)ptr, v11, v12);
              free(ptr);
              return 0LL;
            }
          }
          else
          {
            v35 = v37;
          }
          v13 = lys_node_module(v32);
          if ( v35 == v13 )
          {
            if ( v24 )
            {
              v20 = 0;
              if ( *(_DWORD *)(v32 + 56) & 0xC )
              {
                v20 = sub_179A7(v29, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, &v24);
                if ( v20 <= 0 )
                {
                  sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
                  return 0LL;
                }
              }
              else
              {
                if ( *(_DWORD *)(v32 + 56) != 16 )
                {
                  sub_13937(v19, 78, 0, 0LL, (unsigned int)*v29, (__int64)v29);
                  return 0LL;
                }
                if ( (unsigned int)sub_1B647(v29, v32, &v20) )
                  return 0LL;
              }
              v29 += v20;
            }
            if ( !*v29 )
              return v32;
            if ( *(_DWORD *)(v32 + 56) & 0x802C )
            {
              sub_13937(v19, 78, 0, 0LL, (unsigned int)*v29, (__int64)v29);
              return 0LL;
            }
            i = v32;
            if ( *(_QWORD *)(v32 + 72) )
              v14 = lys_node_module(*(_QWORD *)(i + 72));
            else
              v14 = v36;
            v37 = v14;
            break;
          }
        }
      }
    }
    if ( v32 )
    {
      v20 = sub_17847(v29, &v28, (unsigned int *)&v22, &s1, (unsigned int *)&v21, &v23, &v24, 0LL, 0);
      if ( v20 > 0 )
      {
        v29 += v20;
        continue;
      }
      sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
      result = 0LL;
    }
    else
    {
      ptr = strndup(a1, &s1[v21] - a1);
      sub_13937(v19, 81, 4u, (char *)ptr, v15, v16);
      free(ptr);
      result = 0LL;
    }
    break;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000001C23B) ----------------------------------------------------
signed __int64 __fastcall sub_1C23B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9)
{
  __int64 v10; // r9
  size_t v11; // r12
  const char *v12; // rbx
  __int64 v13; // rax
  __int64 v14; // r9
  __int64 v15; // rbx
  __int64 v16; // r9
  __int64 v17; // rbx
  __int64 v18; // r9
  unsigned __int16 i; // [rsp+1Eh] [rbp-32h]
  __int64 v20; // [rsp+20h] [rbp-30h]
  void *v21; // [rsp+28h] [rbp-28h]
  __int64 v22; // [rsp+30h] [rbp-20h]
  char *s2; // [rsp+38h] [rbp-18h]

  if ( !a1 )
    __assert_fail(
      "node",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x9E4u,
      "resolve_partial_json_data_list_predicate");
  if ( *(_DWORD *)(*a1 + 56LL) != 16 )
    __assert_fail(
      "node->schema->nodetype == LYS_LIST",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x9E5u,
      "resolve_partial_json_data_list_predicate");
  if ( !a8 )
    __assert_fail(
      "pp.len",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x9E6u,
      "resolve_partial_json_data_list_predicate");
  v21 = **(void ***)(*a1 + 48LL);
  v22 = *a1;
  if ( (*__ctype_b_loc())[**(char **)(a9 + 16)] & 0x800 )
    return a2 != atoi(*(const char **)(a9 + 16));
  v20 = a1[8];
  if ( !v20 )
    return 1LL;
  for ( i = 0; i < *(unsigned __int8 *)(v22 + 30); ++i )
  {
    if ( strncmp(**(const char ***)v20, *(const char **)(a9 + 48LL * i + 16), *(signed int *)(a9 + 48LL * i + 24))
      || *(_BYTE *)(**(_QWORD **)v20 + *(signed int *)(a9 + 48LL * i + 24)) )
    {
      sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v10);
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(a9 + 48LL * i) )
    {
      v11 = *(signed int *)(a9 + 48LL * i + 8);
      v12 = *(const char **)(a9 + 48LL * i);
      v13 = lyd_node_module(v20);
      if ( strncmp(*(const char **)(v13 + 8), v12, v11)
        || *(_BYTE *)(*(_QWORD *)(lyd_node_module(v20) + 8) + *(signed int *)(a9 + 48LL * i + 8)) )
      {
        sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v14);
        return 0xFFFFFFFFLL;
      }
      v15 = lyd_node_module(v20);
      if ( v15 == lyd_node_module(a1) )
      {
        sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v16);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v17 = lyd_node_module(v20);
      if ( v17 != lyd_node_module(a1) )
      {
        sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v18);
        return 0xFFFFFFFFLL;
      }
    }
    s2 = sub_B02CA(*(_QWORD *)v20, *(const char **)(a9 + 48LL * i + 32), *(_DWORD *)(a9 + 48LL * i + 40));
    if ( !s2 )
      return 0xFFFFFFFFLL;
    if ( strcmp(*(const char **)(v20 + 56), s2) )
    {
      free(s2);
      return 1LL;
    }
    free(s2);
    v20 = *(_QWORD *)(v20 + 24);
  }
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (000000000001C6D1) ----------------------------------------------------
__int64 **__fastcall sub_1C6D1(const char *a1, void *a2, __int64 *a3, char a4, _DWORD *a5)
{
  __int64 *v5; // rax
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  void *v14; // rax
  const unsigned __int16 **v15; // rax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rax
  size_t v20; // rbx
  __int64 v21; // rax
  __int64 *v22; // rbx
  __int64 v23; // rax
  __int64 *v24; // rbx
  __int64 v25; // rax
  __int64 v26; // r9
  _DWORD *v27; // [rsp+8h] [rbp-E8h]
  char v28; // [rsp+14h] [rbp-DCh]
  __int64 *v29; // [rsp+18h] [rbp-D8h]
  void *v30; // [rsp+20h] [rbp-D0h]
  int v31; // [rsp+34h] [rbp-BCh]
  int v32; // [rsp+38h] [rbp-B8h]
  int v33; // [rsp+3Ch] [rbp-B4h]
  int v34; // [rsp+40h] [rbp-B0h]
  int i; // [rsp+44h] [rbp-ACh]
  unsigned int v36; // [rsp+48h] [rbp-A8h]
  int v37; // [rsp+4Ch] [rbp-A4h]
  int v38; // [rsp+50h] [rbp-A0h]
  int v39; // [rsp+54h] [rbp-9Ch]
  char *v40; // [rsp+58h] [rbp-98h]
  const char *v41; // [rsp+60h] [rbp-90h]
  char *v42; // [rsp+68h] [rbp-88h]
  char *s2; // [rsp+70h] [rbp-80h]
  char *s1; // [rsp+78h] [rbp-78h]
  __int64 **j; // [rsp+80h] [rbp-70h]
  __int64 **v46; // [rsp+88h] [rbp-68h]
  __int64 *v47; // [rsp+90h] [rbp-60h]
  __int64 v48; // [rsp+98h] [rbp-58h]
  void *v49; // [rsp+A0h] [rbp-50h]
  __int64 v50; // [rsp+A8h] [rbp-48h]
  __int64 v51; // [rsp+B0h] [rbp-40h]
  __int64 **v52; // [rsp+B8h] [rbp-38h]
  __int64 s; // [rsp+C0h] [rbp-30h]
  __int64 v54; // [rsp+C8h] [rbp-28h]
  void *ptr; // [rsp+D0h] [rbp-20h]
  unsigned __int64 v56; // [rsp+D8h] [rbp-18h]

  v30 = a2;
  v29 = a3;
  v28 = a4;
  v27 = a5;
  v56 = __readfsqword(0x28u);
  v33 = -1;
  v37 = 0;
  v46 = 0LL;
  if ( !a1 || !a3 || !a5 )
    __assert_fail(
      "nodeid && start && parsed",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0xA43u,
      "resolve_partial_json_data_nodeid");
  memset(&s, 0, 0x18uLL);
  v49 = **(void ***)(*v29 + 48);
  v42 = (char *)a1;
  i = sub_17847(a1, &v40, (unsigned int *)&v31, &v41, (unsigned int *)&v32, &v33, 0LL, 0LL, 1);
  if ( i <= 0 )
  {
    sub_13937(v49, 78, 0, 0LL, (unsigned int)v42[-i], (__int64)&v42[-i]);
    goto LABEL_132;
  }
  if ( *v41 == 35 )
  {
    if ( v33 )
    {
      sub_13937(v49, 78, 0, 0LL, 35LL, (__int64)v41);
      goto LABEL_132;
    }
    v42 += i;
    v37 = i;
  }
  else
  {
    v33 = -1;
  }
  i = sub_17847(v42, &v40, (unsigned int *)&v31, &v41, (unsigned int *)&v32, &v33, &v34, 0LL, 0);
  if ( i <= 0 )
  {
    sub_13937(v49, 78, 0, 0LL, (unsigned int)v42[-i], (__int64)&v42[-i]);
    goto LABEL_132;
  }
  v42 += i;
  v37 += i;
  if ( v33 )
  {
    v47 = (__int64 *)lyd_node_module(v29);
    if ( *(_DWORD *)(*v29 + 56) & 0x4191 )
      v5 = (__int64 *)v29[8];
    else
      v5 = 0LL;
    v29 = v5;
  }
  else
  {
    while ( v29[5] )
      v29 = (__int64 *)v29[5];
    v47 = (__int64 *)lyd_node_module(v29);
  }
  if ( !v29 )
    return 0LL;
  while ( 2 )
  {
    free(ptr);
    s = 0LL;
    LODWORD(v54) = 0;
    ptr = 0LL;
    while ( v34 )
    {
      LODWORD(v54) = v54 + 1;
      ptr = sub_C422(ptr, 48LL * (signed int)v54);
      if ( !ptr )
      {
        sub_12222(
          (__int64)v49,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"resolve_partial_json_data_nodeid",
          v26);
        goto LABEL_132;
      }
      i = sub_179A7(
            v42,
            (_QWORD *)ptr + 6 * (signed int)v54 - 6,
            (unsigned int *)ptr + 12 * (signed int)v54 - 10,
            (char **)ptr + 6 * (signed int)v54 - 4,
            (unsigned int *)ptr + 12 * (signed int)v54 - 6,
            (char **)ptr + 6 * (signed int)v54 - 2,
            (int *)ptr + 12 * (signed int)v54 - 2,
            &v34);
      if ( i <= 0 )
      {
        sub_13937(v49, 78, 0, 0LL, (unsigned int)*v42, (__int64)v42);
        goto LABEL_132;
      }
      v42 += i;
      v37 += i;
    }
    v48 = 0LL;
    if ( v29 && v29[5] )
      v7 = *(_QWORD *)v29[5];
    else
      v7 = 0LL;
    v50 = v7;
    while ( 1 )
    {
      v8 = v50;
      v48 = lys_getnext(v48, v50, v47, 0LL);
      if ( !v48 )
        break;
      if ( !v50 || !(*(_DWORD *)(v50 + 56) & 0x4100) )
        goto LABEL_34;
      if ( v28 & 4 )
      {
        if ( *(_DWORD *)(lys_parent(v48) + 56) != 512 )
        {
LABEL_34:
          v8 = (__int64)v47;
          if ( !(unsigned int)sub_19DE6((const char **)v48, v47, v40, v31, v41, v32) )
            break;
        }
      }
      else if ( *(_DWORD *)(lys_parent(v48) + 56) != 1024 )
      {
        goto LABEL_34;
      }
    }
    if ( !v48 )
    {
      free(ptr);
      return v46;
    }
    s = v48;
    if ( !*v42 && !(_DWORD)v54 && *(_DWORD *)(v48 + 56) == 8 )
    {
      LODWORD(v54) = 1;
      v8 = 48LL;
      ptr = calloc(1uLL, 0x30uLL);
      if ( !ptr )
      {
        sub_12222(
          (__int64)v49,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"resolve_partial_json_data_nodeid",
          v13);
        goto LABEL_132;
      }
      *((_QWORD *)ptr + 2) = ".";
      *((_DWORD *)ptr + 6) = 1;
      if ( v30 )
        v14 = v30;
      else
        v14 = &unk_10AA7C;
      *((_QWORD *)ptr + 4) = v14;
      v9 = strlen(*((const char **)ptr + 4));
      *((_DWORD *)ptr + 10) = v9;
    }
    if ( !(*(_DWORD *)(v48 + 56) & 0xC) )
    {
      if ( *(_DWORD *)(v48 + 56) == 16 )
      {
        v51 = v48;
        if ( !(_DWORD)v54 )
          return v46;
        v15 = __ctype_b_loc();
        v9 = (__int64)*v15;
        if ( (*v15)[**((char **)ptr + 2)] & 0x800 )
          goto LABEL_74;
        if ( (signed int)v54 <= *(unsigned __int8 *)(v51 + 30) )
        {
          v9 = (unsigned int)v54;
          if ( (signed int)v54 >= *(unsigned __int8 *)(v51 + 30) )
          {
            for ( i = 0; i < (signed int)v54; ++i )
            {
              v9 = 8LL * i;
              if ( *(_DWORD *)(*(_QWORD *)(v9 + *(_QWORD *)(v51 + 136)) + 128LL) == 7 )
              {
                v8 = 58LL;
                if ( !sub_811F(*((_BYTE **)ptr + 6 * i + 4), 58, *((_DWORD *)ptr + 12 * i + 10)) )
                {
                  sub_13937(
                    v49,
                    84,
                    2u,
                    *(char **)(8LL * i + *(_QWORD *)(v51 + 136)),
                    *((unsigned int *)ptr + 12 * i + 10),
                    *((_QWORD *)ptr + 6 * i + 4));
                  goto LABEL_132;
                }
              }
            }
            goto LABEL_74;
          }
          sub_13937(v49, 83, 0, 0LL, **(_QWORD **)(8LL * (signed int)v54 + *(_QWORD *)(v51 + 136)), v12);
        }
        else
        {
          sub_13937(v49, 87, 0, 0LL, v11, v12);
        }
      }
      else
      {
        if ( !ptr )
          goto LABEL_74;
        sub_13937(v49, 87, 0, 0LL, v11, v12);
      }
      goto LABEL_132;
    }
    if ( (signed int)v54 > 1 )
    {
      sub_13937(v49, 87, 0, 0LL, v11, v12);
      goto LABEL_132;
    }
    if ( (_DWORD)v54 )
    {
      if ( **((_BYTE **)ptr + 2) != 46 || *((_DWORD *)ptr + 6) != 1 )
      {
        sub_13937(v49, 78, 0, 0LL, (unsigned int)**((char **)ptr + 2), *((_QWORD *)ptr + 2));
        goto LABEL_132;
      }
      if ( *(_DWORD *)(v48 + 128) == 7 )
      {
        v8 = 58LL;
        if ( !sub_811F(*((_BYTE **)ptr + 4), 58, *((_DWORD *)ptr + 10)) )
        {
          sub_13937(v49, 84, 2u, (char *)v48, *((unsigned int *)ptr + 10), *((_QWORD *)ptr + 4));
          goto LABEL_132;
        }
      }
    }
LABEL_74:
    if ( v29[5]
      && *(_QWORD *)(v29[5] + 56)
      && (*(_DWORD *)(s + 56) != 16 || *(_BYTE *)(s + 30))
      && (*(_DWORD *)(s + 56) != 8 || *(_WORD *)(s + 24) & 1) )
    {
      j = (__int64 **)sub_181E5(v29[5], v8, v9, v10, v11, v12, s, v54, (__int64)ptr);
    }
    else
    {
      v36 = 0;
      for ( j = (__int64 **)v29; j; j = (__int64 **)j[3] )
      {
        if ( lys_parent(*j) )
        {
          if ( v28 & 4 )
          {
            if ( *(_DWORD *)(lys_parent(*j) + 56) == 512 )
            {
              sub_12222((__int64)v49, 0, 3, "Provided data tree includes some RPC input nodes (%s).", **j, v18);
              goto LABEL_132;
            }
          }
          else if ( *(_DWORD *)(lys_parent(*j) + 56) == 1024 )
          {
            sub_12222((__int64)v49, 0, 3, "Provided data tree includes some RPC output nodes (%s).", **j, v18);
            goto LABEL_132;
          }
        }
        if ( (__int64 *)v48 == *j )
        {
          if ( *(_DWORD *)(v48 + 56) == 8 )
          {
            if ( !(*(_WORD *)(v48 + 24) & 2) )
            {
              v52 = j;
              s1 = 0LL;
              v38 = 0;
              if ( ptr )
              {
                s1 = (char *)*((_QWORD *)ptr + 4);
                v38 = *((_DWORD *)ptr + 10);
              }
              if ( s1
                && !strchr(s1, 58)
                && (_DWORD)v52[9] & 7
                && (v19 = lyd_node_module(j),
                    v20 = strlen(*(const char **)(v19 + 8)),
                    v21 = lyd_node_module(j),
                    !strncmp((const char *)v52[7], *(const char **)(v21 + 8), v20))
                && (v22 = v52[7], v23 = lyd_node_module(j), *((_BYTE *)v22 + strlen(*(const char **)(v23 + 8))) == 58) )
              {
                v24 = v52[7];
                v25 = lyd_node_module(j);
                s2 = (char *)v24 + strlen(*(const char **)(v25 + 8)) + 1;
              }
              else
              {
                s2 = (char *)v52[7];
              }
              if ( (s1 || !s2 || !*s2) && (!s1 || !strncmp(s1, s2, v38) && !s2[v38]) )
                break;
            }
          }
          else
          {
            if ( *(_DWORD *)(v48 + 56) != 16 )
              break;
            ++v36;
            v39 = sub_1C23B(j, v36, v36, v16, v17, v18, s, v54, (__int64)ptr);
            if ( v39 == -1 )
              goto LABEL_132;
            if ( v39 != 1 )
              break;
          }
        }
      }
    }
    if ( !j )
    {
      free(ptr);
      return v46;
    }
    *v27 += v37;
    v46 = j;
    v47 = (__int64 *)lyd_node_module(j);
    if ( !*v42 )
    {
      free(ptr);
      return v46;
    }
    if ( *(_DWORD *)(v48 + 56) & 0x802C )
    {
      sub_13937(v49, 78, 0, 0LL, (unsigned int)*v42, (__int64)v42);
      goto LABEL_132;
    }
    if ( !j[8] )
    {
      free(ptr);
      return v46;
    }
    v29 = j[8];
    i = sub_17847(v42, &v40, (unsigned int *)&v31, &v41, (unsigned int *)&v32, &v33, &v34, 0LL, 0);
    if ( i > 0 )
    {
      v42 += i;
      v37 = i;
      continue;
    }
    break;
  }
  sub_13937(v49, 78, 0, 0LL, (unsigned int)v42[-i], (__int64)&v42[-i]);
LABEL_132:
  *v27 = -1;
  free(ptr);
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (000000000001D702) ----------------------------------------------------
signed __int64 __fastcall sub_1D702(void *a1, char *a2, __int64 a3, void **a4)
{
  __int64 v5; // r9
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rax
  __int64 v9; // rax
  void **v10; // [rsp+0h] [rbp-90h]
  __int64 v11; // [rsp+8h] [rbp-88h]
  char *v12; // [rsp+10h] [rbp-80h]
  unsigned __int8 v13; // [rsp+23h] [rbp-6Dh]
  signed int v14; // [rsp+24h] [rbp-6Ch]
  char *nptr; // [rsp+28h] [rbp-68h]
  void *ptr; // [rsp+30h] [rbp-60h]
  __int128 v17; // [rsp+38h] [rbp-58h]
  __int128 v18; // [rsp+48h] [rbp-48h]
  __int128 v19; // [rsp+58h] [rbp-38h]
  char *s; // [rsp+68h] [rbp-28h]
  void *v21; // [rsp+70h] [rbp-20h]
  char *v22; // [rsp+78h] [rbp-18h]
  signed __int64 *i; // [rsp+80h] [rbp-10h]
  unsigned __int64 v24; // [rsp+88h] [rbp-8h]

  v12 = a2;
  v11 = a3;
  v10 = a4;
  v24 = __readfsqword(0x28u);
  v17 = 0uLL;
  *((_QWORD *)&v19 + 1) = 0LL;
  v13 = 0;
  v21 = 0LL;
  v22 = 0LL;
  ptr = 0LL;
  switch ( *(_DWORD *)a3 )
  {
    case 1:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = -1LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 4:
      v14 = 2;
      *(_QWORD *)&v18 = 0x8000000000000000LL;
      *((_QWORD *)&v18 + 1) = 0x7FFFFFFFFFFFFFFFLL;
      v13 = *(_BYTE *)(a3 + 40);
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xA:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = -1LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xC:
      v14 = 1;
      *(_QWORD *)&v17 = -128LL;
      *((_QWORD *)&v17 + 1) = 127LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xD:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = 255LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xE:
      v14 = 1;
      *(_QWORD *)&v17 = -32768LL;
      *((_QWORD *)&v17 + 1) = 0x7FFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xF:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = 0xFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x10:
      v14 = 1;
      *(_QWORD *)&v17 = -2147483648LL;
      *((_QWORD *)&v17 + 1) = 0x7FFFFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x11:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = 0xFFFFFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x12:
      v14 = 1;
      *(_QWORD *)&v17 = 0x8000000000000000LL;
      *((_QWORD *)&v17 + 1) = 0x7FFFFFFFFFFFFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x13:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = -1LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
LABEL_36:
      if ( !*(_QWORD *)(a3 + 16) )
        goto LABEL_42;
      if ( (unsigned int)sub_1D702(a1, 0LL, *(_QWORD *)(a3 + 16) + 56LL, &ptr) )
        return 0xFFFFFFFFLL;
      if ( ptr && v14 != *(unsigned __int8 *)ptr )
        __assert_fail(
          "!intv || (intv->kind == kind)",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0xBDFu,
          "resolve_len_ran_interval");
LABEL_42:
      if ( !v12 )
      {
        *v10 = ptr;
        return 0LL;
      }
      if ( ptr )
      {
        i = (signed __int64 *)ptr;
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            *(_QWORD *)&v17 = i[1];
          }
          else if ( v14 == 2 )
          {
            *(_QWORD *)&v18 = i[1];
          }
        }
        else
        {
          *(_QWORD *)&v19 = i[1];
        }
        while ( i[4] )
          i = (signed __int64 *)i[4];
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            *((_QWORD *)&v17 + 1) = i[2];
          }
          else if ( v14 == 2 )
          {
            *((_QWORD *)&v18 + 1) = i[2];
          }
        }
        else
        {
          *((_QWORD *)&v19 + 1) = i[2];
        }
      }
      s = v12;
      i = 0LL;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  while ( 1 )
  {
    if ( v22 )
    {
      *((_QWORD *)v22 + 4) = malloc(0x28uLL);
      v22 = (char *)*((_QWORD *)v22 + 4);
    }
    else
    {
      if ( v21 )
        __assert_fail(
          "!local_intv",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0xC06u,
          "resolve_len_ran_interval");
      v21 = malloc(0x28uLL);
      v22 = (char *)v21;
    }
    if ( !v22 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_len_ran_interval", v5, v10);
      goto LABEL_191;
    }
    *v22 = v14;
    *((_QWORD *)v22 + 3) = v11;
    *((_QWORD *)v22 + 4) = 0LL;
    for ( nptr = s; (*__ctype_b_loc())[*nptr] & 0x2000; ++nptr )
      ;
    if ( (*__ctype_b_loc())[*nptr] & 0x800 || *nptr == 43 || *nptr == 45 )
    {
      if ( v14 )
      {
        if ( v14 == 1 )
        {
          v7 = strtoll(nptr, &nptr, 10);
          *((_QWORD *)v22 + 1) = v7;
        }
        else if ( v14 == 2 && (unsigned int)sub_16271(&nptr, v13, (_QWORD *)v22 + 1) )
        {
          sub_13937(a1, 10, 0, 0LL, (__int64)nptr, (__int64)"range", v10);
          goto LABEL_191;
        }
      }
      else
      {
        v6 = strtoull(nptr, &nptr, 10);
        *((_QWORD *)v22 + 1) = v6;
      }
    }
    else if ( !strncmp(nptr, "min", 3uLL) )
    {
      if ( v14 )
      {
        if ( v14 == 1 )
        {
          *((_QWORD *)v22 + 1) = v17;
        }
        else if ( v14 == 2 )
        {
          *((_QWORD *)v22 + 1) = v18;
        }
      }
      else
      {
        *((_QWORD *)v22 + 1) = v19;
      }
      nptr += 3;
    }
    else
    {
      if ( strncmp(nptr, "max", 3uLL) )
        goto LABEL_191;
      if ( v14 )
      {
        if ( v14 == 1 )
        {
          *((_QWORD *)v22 + 1) = *((_QWORD *)&v17 + 1);
        }
        else if ( v14 == 2 )
        {
          *((_QWORD *)v22 + 1) = *((_QWORD *)&v18 + 1);
        }
      }
      else
      {
        *((_QWORD *)v22 + 1) = *((_QWORD *)&v19 + 1);
      }
      nptr += 3;
    }
    while ( (*__ctype_b_loc())[*nptr] & 0x2000 )
      ++nptr;
    if ( *nptr != 124 && *nptr )
    {
      if ( strncmp(nptr, "..", 2uLL) )
        goto LABEL_191;
      for ( nptr += 2; (*__ctype_b_loc())[*nptr] & 0x2000; ++nptr )
        ;
      if ( (*__ctype_b_loc())[*nptr] & 0x800 || *nptr == 43 || *nptr == 45 )
      {
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            v9 = strtoll(nptr, &nptr, 10);
            *((_QWORD *)v22 + 2) = v9;
          }
          else if ( v14 == 2 && (unsigned int)sub_16271(&nptr, v13, (_QWORD *)v22 + 2) )
          {
            sub_13937(a1, 10, 0, 0LL, (__int64)nptr, (__int64)"range", v10);
            goto LABEL_191;
          }
        }
        else
        {
          v8 = strtoull(nptr, &nptr, 10);
          *((_QWORD *)v22 + 2) = v8;
        }
      }
      else
      {
        if ( strncmp(nptr, "max", 3uLL) )
          goto LABEL_191;
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            *((_QWORD *)v22 + 2) = *((_QWORD *)&v17 + 1);
          }
          else if ( v14 == 2 )
          {
            *((_QWORD *)v22 + 2) = *((_QWORD *)&v18 + 1);
          }
        }
        else
        {
          *((_QWORD *)v22 + 2) = *((_QWORD *)&v19 + 1);
        }
      }
    }
    else if ( v14 )
    {
      if ( v14 == 1 )
      {
        *((_QWORD *)v22 + 2) = *((_QWORD *)v22 + 1);
      }
      else if ( v14 == 2 )
      {
        *((_QWORD *)v22 + 2) = *((_QWORD *)v22 + 1);
      }
    }
    else
    {
      *((_QWORD *)v22 + 2) = *((_QWORD *)v22 + 1);
    }
    if ( v14 )
    {
      if ( v14 == 1 )
      {
        if ( *((_QWORD *)v22 + 1) > *((_QWORD *)v22 + 2)
          || (signed __int64)v17 > *((_QWORD *)v22 + 1)
          || *((_QWORD *)&v17 + 1) < *((_QWORD *)v22 + 2)
          || i && i[2] >= *((_QWORD *)v22 + 1) )
        {
          goto LABEL_191;
        }
      }
      else if ( v14 == 2
             && (*((_QWORD *)v22 + 1) > *((_QWORD *)v22 + 2)
              || (signed __int64)v18 > *((_QWORD *)v22 + 1)
              || *((_QWORD *)&v18 + 1) < *((_QWORD *)v22 + 2)
              || i && i[2] >= *((_QWORD *)v22 + 1)) )
      {
        goto LABEL_191;
      }
    }
    else if ( *((_QWORD *)v22 + 1) > *((_QWORD *)v22 + 2)
           || (unsigned __int64)v19 > *((_QWORD *)v22 + 1)
           || *((_QWORD *)&v19 + 1) < *((_QWORD *)v22 + 2)
           || i && (unsigned __int64)i[2] >= *((_QWORD *)v22 + 1) )
    {
      goto LABEL_191;
    }
    s = strchr(s, 124);
    if ( !s )
      break;
    ++s;
    i = (signed __int64 *)v22;
  }
  if ( !ptr )
    goto LABEL_171;
  i = (signed __int64 *)ptr;
  v22 = (char *)v21;
LABEL_168:
  while ( v22 && i )
  {
    if ( v14 )
    {
      if ( v14 == 1 )
      {
        v17 = *(_OWORD *)(v22 + 8);
        if ( (signed __int64)v17 < i[1] || (signed __int64)v17 > i[2] )
          goto LABEL_167;
        if ( *((_QWORD *)&v17 + 1) > i[2] )
          goto LABEL_191;
        v22 = (char *)*((_QWORD *)v22 + 4);
      }
      else
      {
        if ( v14 != 2
          || (v18 = *(_OWORD *)(v22 + 8), (signed int)sub_C508(v18, v13, i[1], v13) < 0)
          || (signed int)sub_C508(v18, v13, i[2], v13) > 0 )
        {
LABEL_167:
          i = (signed __int64 *)i[4];
          goto LABEL_168;
        }
        if ( (signed int)sub_C508(*((signed __int64 *)&v18 + 1), v13, i[2], v13) > 0 )
          goto LABEL_191;
        v22 = (char *)*((_QWORD *)v22 + 4);
      }
    }
    else
    {
      v19 = *(_OWORD *)(v22 + 8);
      if ( (unsigned __int64)v19 < i[1] || (unsigned __int64)v19 > i[2] )
        goto LABEL_167;
      if ( *((_QWORD *)&v19 + 1) > (unsigned __int64)i[2] )
        goto LABEL_191;
      v22 = (char *)*((_QWORD *)v22 + 4);
    }
  }
  if ( v22 )
  {
LABEL_191:
    while ( ptr )
    {
      i = (signed __int64 *)*((_QWORD *)ptr + 4);
      free(ptr);
      ptr = i;
    }
    while ( v21 )
    {
      v22 = (char *)*((_QWORD *)v21 + 4);
      free(v21);
      v21 = v22;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_171:
  if ( ptr )
  {
    for ( i = (signed __int64 *)ptr; i[4]; i = (signed __int64 *)i[4] )
      ;
    i[4] = (signed __int64)v21;
  }
  else
  {
    ptr = v21;
  }
  *v10 = ptr;
  return 0LL;
}

//----- (000000000001E592) ----------------------------------------------------
signed __int64 __fastcall sub_1E592(signed __int64 a1)
{
  signed __int64 v2; // [rsp+8h] [rbp-18h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  v2 = a1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      return 1LL;
    case 0xB:
      for ( i = 0; i < *(_DWORD *)(a1 + 40); ++i )
      {
        if ( (unsigned int)sub_1E592(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 32)) )
          return 1LL;
      }
      break;
    case 9:
      while ( !*(_QWORD *)(v2 + 32) )
      {
        if ( !*(_QWORD *)(v2 + 16) )
          __assert_fail(
            "type->der",
            "/home/mantovan/Repositories/libyang/src/resolve.c",
            0xCFDu,
            "resolve_superior_type_check");
        v2 = *(_QWORD *)(v2 + 16) + 56LL;
      }
      break;
  }
  return 0LL;
}

//----- (000000000001E65A) ----------------------------------------------------
signed __int64 __fastcall sub_1E65A(const char *a1, const char *a2, __int64 a3, __int64 a4, signed __int64 *a5)
{
  unsigned int v6; // eax
  signed __int64 *v7; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+10h] [rbp-40h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  char *s1; // [rsp+20h] [rbp-30h]
  signed int i; // [rsp+34h] [rbp-1Ch]
  int j; // [rsp+34h] [rbp-1Ch]
  signed int k; // [rsp+34h] [rbp-1Ch]
  signed int l; // [rsp+34h] [rbp-1Ch]
  signed int m; // [rsp+38h] [rbp-18h]
  int v16; // [rsp+3Ch] [rbp-14h]
  __int64 v17; // [rsp+40h] [rbp-10h]
  signed __int64 v18; // [rsp+48h] [rbp-8h]

  s1 = (char *)a2;
  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( a2 )
  {
    if ( !strcmp(a2, *(const char **)(a3 + 8)) )
      s1 = 0LL;
  }
  else
  {
    for ( i = 1; i <= 19; ++i )
    {
      if ( !strcmp(*qword_346FA0[i], a1) )
      {
        if ( v7 )
          *v7 = (signed __int64)qword_346FA0[i];
        return 0LL;
      }
    }
  }
  if ( !s1 && v8 )
  {
    while ( 1 )
    {
LABEL_41:
      if ( !v8 )
        goto LABEL_45;
      v6 = *(_DWORD *)(v8 + 56);
      if ( v6 == 256 )
        goto LABEL_31;
      if ( v6 > 0x100 )
      {
        if ( v6 == 1024 )
          goto LABEL_33;
        if ( v6 > 0x400 )
        {
          if ( v6 == 2048 )
          {
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 104);
            goto LABEL_35;
          }
          if ( v6 == 0x4000 )
          {
LABEL_31:
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 112);
            goto LABEL_35;
          }
        }
        else if ( v6 == 512 )
        {
LABEL_33:
          v16 = *(unsigned __int16 *)(v8 + 30);
          v17 = *(_QWORD *)(v8 + 104);
LABEL_35:
          for ( j = 0; ; ++j )
          {
            if ( j >= v16 )
            {
              v8 = lys_parent(v8);
              goto LABEL_41;
            }
            if ( !strcmp(*(const char **)(((signed __int64)j << 7) + v17), a1) )
              break;
          }
          v18 = ((signed __int64)j << 7) + v17;
LABEL_60:
          if ( (unsigned int)sub_1E592(v18 + 56) )
            return 1LL;
          if ( v7 )
            *v7 = v18;
          return 0LL;
        }
      }
      else
      {
        switch ( v6 )
        {
          case 0x10u:
            v16 = *(unsigned __int8 *)(v8 + 29);
            v17 = *(_QWORD *)(v8 + 128);
            goto LABEL_35;
          case 0x80u:
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 112);
            goto LABEL_35;
          case 1u:
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 128);
            goto LABEL_35;
        }
      }
      v8 = lys_parent(v8);
    }
  }
  v9 = sub_407F3((__int64 *)v9, 0LL, 0, s1, 0, 0);
  if ( !v9 )
    return 0xFFFFFFFFLL;
LABEL_45:
  for ( k = 0; k < *(unsigned __int16 *)(v9 + 74); ++k )
  {
    if ( !strcmp(*(const char **)(((signed __int64)k << 7) + *(_QWORD *)(v9 + 112)), a1) )
    {
      v18 = ((signed __int64)k << 7) + *(_QWORD *)(v9 + 112);
      goto LABEL_60;
    }
  }
  for ( l = 0; l < *(unsigned __int8 *)(v9 + 70) && *(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l); ++l )
  {
    for ( m = 0; m < *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l) + 74LL); ++m )
    {
      if ( !strcmp(
              *(const char **)(((signed __int64)m << 7)
                             + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l) + 112LL)),
              a1) )
      {
        v18 = ((signed __int64)m << 7) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l) + 112LL);
        goto LABEL_60;
      }
    }
  }
  return 1LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (000000000001EAAF) ----------------------------------------------------
__int64 __fastcall sub_1EAAF(_QWORD *a1, const char **a2, void **a3, int a4)
{
  const char *v4; // rbx
  __int64 v5; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  int v11; // [rsp+4h] [rbp-BCh]
  void **v12; // [rsp+8h] [rbp-B8h]
  unsigned int v13; // [rsp+28h] [rbp-98h]
  const char *v14; // [rsp+30h] [rbp-90h]
  char *ptr; // [rsp+38h] [rbp-88h]
  _QWORD *i; // [rsp+40h] [rbp-80h]
  void *v17; // [rsp+48h] [rbp-78h]
  char **s; // [rsp+50h] [rbp-70h]
  const char *v19; // [rsp+88h] [rbp-38h]
  void *v20; // [rsp+90h] [rbp-30h]
  int v21; // [rsp+98h] [rbp-28h]
  char v22; // [rsp+9Ch] [rbp-24h]
  unsigned __int64 v23; // [rsp+A8h] [rbp-18h]

  v12 = a3;
  v11 = a4;
  v23 = __readfsqword(0x28u);
  i = 0LL;
  v14 = 0LL;
  v13 = 0;
  v17 = *a3;
  if ( !a2 )
    __assert_fail("value", "/home/mantovan/Repositories/libyang/src/resolve.c", 0xD96u, "check_default");
  memset(&s, 0, 0x50uLL);
  if ( *(_DWORD *)a1 )
  {
    if ( v11 || *((_BYTE *)v12 + 64) < 0 )
    {
      if ( v11 && *((_BYTE *)v12 + 64) >= 0 && *(_DWORD *)a1 == 7 )
      {
        if ( *a2 )
        {
          if ( strchr(*a2, 58) )
          {
            v14 = (const char *)sub_9BED((__int64 *)v12, *a2);
          }
          else
          {
            v4 = *a2;
            v5 = lys_main_module(v12);
            if ( asprintf(&ptr, "%s:%s", *(_QWORD *)(v5 + 8), v4) == -1 )
            {
              sub_12222((__int64)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_default", v6);
              v13 = -1;
              goto LABEL_69;
            }
            v14 = (const char *)lydict_insert_zc(v17, ptr);
          }
          lydict_remove(v17, *a2);
          *a2 = v14;
          v14 = 0LL;
          goto LABEL_69;
        }
      }
      else if ( *(_DWORD *)a1 != 9 || !v11 )
      {
        v14 = (const char *)lydict_insert(v17, *a2, 0LL);
        if ( v14 )
        {
          if ( *(_DWORD *)a1 == 5 )
          {
            sub_13937(v17, 6, 0, 0LL, (__int64)"default", *(_QWORD *)a1[3]);
            sub_13937(v17, -1, 0, 0LL, (__int64)"The \"empty\" data type cannot have a default value.", v7);
            v13 = -1;
          }
          else
          {
LABEL_45:
            memset(&s, 0, 0x50uLL);
            v19 = (const char *)lydict_insert(v17, v14, 0LL);
            v21 = *(_DWORD *)a1;
            if ( v11 )
            {
              s = (char **)calloc(1uLL, 0xD0uLL);
              if ( !s )
              {
                sub_12222((__int64)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_default", v8);
                v13 = -1;
                goto LABEL_69;
              }
              if ( asprintf(s, "typedef-%s-default", *(_QWORD *)a1[3]) == -1 )
              {
                sub_12222((__int64)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_default", v9);
                v13 = -1;
                goto LABEL_69;
              }
              s[6] = (char *)v12;
              memcpy(s + 16, a1, 0x40uLL);
            }
            else
            {
              s = (char **)a1[3];
            }
            if ( *(_DWORD *)a1 == 9 )
            {
              if ( a1[5] )
              {
                v13 = sub_1EAAF(a1[5] + 128LL, &v14, v12, 0LL);
                if ( !v13 && *a2 )
                {
                  lydict_remove(v17, *a2);
                  *a2 = v14;
                  v14 = 0LL;
                }
              }
              else
              {
                v13 = 1;
                sub_13937(
                  v17,
                  -1,
                  0,
                  0LL,
                  (__int64)"Default value \"%s\" cannot be checked in an unresolved leafref.",
                  (__int64)v14);
              }
            }
            else if ( sub_37EF5((signed __int64)a1, (char **)&v19, 0LL, (__int64 **)&s, 0LL, (__int64 *)v12, 1, 1, 0) )
            {
              if ( v19 != v14 )
              {
                if ( *a2 != v14 )
                  __assert_fail(
                    "ly_strequal(dflt, *value, 1)",
                    "/home/mantovan/Repositories/libyang/src/resolve.c",
                    0xE4Bu,
                    "check_default");
                lydict_remove(v17, *a2);
                *a2 = v19;
                v19 = 0LL;
              }
            }
            else
            {
              v13 = 1;
              if ( i
                && (*(_DWORD *)a1 == 2 && *(_QWORD *)(a1[2] + 72LL) || *(_DWORD *)a1 == 6 && *(_QWORD *)(a1[2] + 72LL)) )
              {
                sub_13937(
                  v17,
                  -1,
                  0,
                  0LL,
                  (__int64)"Invalid value \"%s\" of the default statement inherited to \"%s\" from \"%s\" base type.",
                  (__int64)v14,
                  *(_QWORD *)a1[3],
                  *i);
              }
            }
          }
        }
        else
        {
          for ( i = (_QWORD *)a1[2]; i[9]; i = (_QWORD *)i[9] )
          {
            if ( i[15] )
            {
              v14 = (const char *)lydict_insert(v17, i[15], 0LL);
              break;
            }
          }
          if ( v14 )
          {
            switch ( *(_DWORD *)a1 )
            {
              case 1:
                if ( a1[4] )
                  goto LABEL_45;
                break;
              case 2:
                if ( *((_DWORD *)a1 + 10) )
                  goto LABEL_45;
                break;
              case 3:
              case 5:
              case 8:
              case 9:
                break;
              case 4:
                if ( a1[4] )
                  goto LABEL_45;
                break;
              case 6:
                if ( *((_DWORD *)a1 + 10) )
                  goto LABEL_45;
                break;
              case 7:
                if ( *(_BYTE *)(lys_main_module(*(_QWORD *)(i[10] + 48LL)) + 64) & 0x80 )
                  break;
                v12 = (void **)i[6];
                goto LABEL_45;
              case 0xA:
                if ( a1[4] || a1[5] )
                  goto LABEL_45;
                break;
              case 0xB:
                goto LABEL_45;
              case 0xC:
              case 0xD:
              case 0xE:
              case 0xF:
              case 0x10:
              case 0x11:
              case 0x12:
              case 0x13:
                if ( a1[4] )
                  goto LABEL_45;
                break;
              default:
                sub_12222(
                  (__int64)v17,
                  0,
                  4,
                  "Internal error (%s:%d).",
                  (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
                  3589LL);
                v13 = -1;
                break;
            }
          }
        }
      }
    }
  }
  else
  {
    v13 = 1;
  }
LABEL_69:
  sub_BBE52(v20, v21, v22, (signed __int64)a1, (__int64)v19, 0LL, 0LL, 0LL);
  lydict_remove(v17, v19);
  if ( v11 && s )
  {
    free(*s);
    free(s);
  }
  lydict_remove(v17, v14);
  return v13;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000001F3F0) ----------------------------------------------------
signed __int64 __fastcall sub_1F3F0(__int64 a1, int a2, const char *a3, int a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r9
  const char *v8; // rax
  const char *v9; // rax
  char *s; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+10h] [rbp-30h]
  int i; // [rsp+24h] [rbp-1Ch]
  signed int v13; // [rsp+24h] [rbp-1Ch]
  char *ptr; // [rsp+28h] [rbp-18h]
  __int64 v15; // [rsp+30h] [rbp-10h]
  void *v16; // [rsp+38h] [rbp-8h]

  s = (char *)a3;
  v11 = a4;
  v15 = *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 136));
  ptr = 0LL;
  v16 = **(void ***)(a1 + 48);
  if ( v15 )
  {
    for ( i = a2 - 1; i >= 0; --i )
    {
      if ( v15 == *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) )
      {
        sub_13937(v16, 34, 2u, (char *)a1, *(_QWORD *)v15, a6);
        return 0xFFFFFFFFLL;
      }
    }
    if ( *(_DWORD *)(v15 + 56) != 4 )
    {
      sub_13937(v16, 30, 2u, (char *)a1, *(_QWORD *)v15, a6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(v15 + 128) == 5 && ((*(_BYTE *)(*(_QWORD *)(v15 + 48) + 64LL) >> 1) & 7u) <= 1 )
    {
      sub_13937(v16, 31, 2u, (char *)a1, *(_QWORD *)v15, a6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_WORD *)(v15 + 24) & 3
      && *(_WORD *)(a1 + 24) & 3
      && ((unsigned __int8)*(_WORD *)(a1 + 24) ^ (unsigned __int8)*(_WORD *)(v15 + 24)) & 3 )
    {
      sub_13937(v16, 32, 2u, (char *)a1, *(_QWORD *)v15, a6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(*(_QWORD *)(v15 + 64) + 56LL) == 0x2000 )
    {
      sub_13937(v16, 33, 2u, (char *)v15, *(_QWORD *)v15, a6);
      sub_13937(v16, -1, 5u, 0LL, (__int64)"Key inserted from augment.", v7);
      return 0xFFFFFFFFLL;
    }
    v13 = 0;
    if ( !*(_QWORD *)(v15 + 112) )
    {
      if ( !*(_BYTE *)(v15 + 27) )
        return 0LL;
      v13 = 1;
    }
    if ( v13 )
      v8 = "if-feature";
    else
      v8 = "when";
    sub_13937(v16, 6, 2u, (char *)v15, (__int64)v8, (__int64)"leaf");
    if ( v13 )
      v9 = "if-feature";
    else
      v9 = "when";
    sub_13937(v16, -1, 5u, 0LL, (__int64)"Key definition cannot depend on a \"%s\" condition.", (__int64)v9);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( a3[a4] )
    {
      ptr = strdup(a3);
      if ( !ptr )
      {
        sub_12222((__int64)v16, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_key", a6);
        return 0xFFFFFFFFLL;
      }
      ptr[v11] = 0;
      s = ptr;
    }
    sub_13937(v16, 33, 2u, (char *)a1, (__int64)s, a6);
    free(ptr);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000001F79E) ----------------------------------------------------
signed __int64 __fastcall sub_1F79E(__int64 a1, const char *a2, _BYTE *a3)
{
  __int64 *v3; // rax
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  const char *v8; // rdx
  const char *v9; // rax
  __int16 v10; // dx
  _BYTE *v11; // [rsp+8h] [rbp-38h]
  int v12; // [rsp+24h] [rbp-1Ch]
  unsigned int v13; // [rsp+24h] [rbp-1Ch]
  __int64 v14; // [rsp+28h] [rbp-18h]
  void *v15; // [rsp+30h] [rbp-10h]
  unsigned __int64 v16; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v16 = __readfsqword(0x28u);
  v14 = 0LL;
  v15 = **(void ***)(a1 + 48);
  v3 = (__int64 *)sub_A75EB(a1, 4u);
  v12 = sub_1AF63(a2, *v3, 4, 1, &v14);
  if ( !v12 && v14 )
  {
    if ( *(_DWORD *)(v14 + 56) != 4 )
    {
      sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
      sub_13937(v15, -1, 5u, 0LL, (__int64)"Target is not a leaf.", v6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(a1 + 56) != 0x10000
      && (unsigned int)sub_3C749(
                         *(_WORD *)(a1 + 24),
                         *(void ***)(a1 + 48),
                         *(_QWORD *)a1,
                         *(_WORD *)(v14 + 24),
                         *(_QWORD *)(v14 + 48),
                         *(_QWORD *)v14,
                         (char *)v14) )
    {
      return 0xFFFFFFFFLL;
    }
    if ( *v11 )
    {
      if ( *v11 == 1 && *(_WORD *)(v14 + 24) & 2 || *v11 == 2 && *(_WORD *)(v14 + 24) & 1 )
      {
        sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
        if ( *v11 == 1 )
          v8 = "true";
        else
          v8 = "false";
        if ( *v11 == 1 )
          v9 = "false";
        else
          v9 = "true";
        sub_13937(
          v15,
          -1,
          5u,
          0LL,
          (__int64)"Leaf \"%s\" referenced in unique statement is config %s, but previous referenced leaf is config %s.",
          (__int64)a2,
          v9,
          v8);
        return 0xFFFFFFFFLL;
      }
    }
    else if ( *(_WORD *)(v14 + 24) & 1 )
    {
      *v11 = 1;
    }
    else
    {
      *v11 = 2;
    }
    v10 = *(_WORD *)(v14 + 24);
    HIBYTE(v10) |= 1u;
    *(_WORD *)(v14 + 24) = v10;
    return 0LL;
  }
  if ( v12 )
  {
    sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
    if ( v12 <= 0 )
    {
      if ( v12 == -2 )
        sub_13937(v15, -1, 5u, 0LL, (__int64)"Unique argument references list.", v4);
    }
    else
    {
      sub_13937(v15, 55, 5u, 0LL, (unsigned int)a2[v12 - 1], (__int64)&a2[v12 - 1]);
    }
    v13 = -1;
  }
  else
  {
    sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
    sub_13937(v15, -1, 5u, 0LL, (__int64)"Target leaf not found.", v5);
    v13 = 1;
  }
  return v13;
}

//----- (000000000001FB5F) ----------------------------------------------------
__int64 __fastcall sub_1FB5F(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  if ( a2 + 1 >= *(_DWORD *)(a1 + 16) )
  {
    if ( !a2 )
    {
      free(*(void **)a1);
      *(_QWORD *)a1 = 0LL;
    }
  }
  else
  {
    memmove(
      (void *)(8LL * a2 + *(_QWORD *)a1),
      (const void *)(*(_QWORD *)a1 + 8LL * (a2 + 1)),
      8LL * (*(_DWORD *)(a1 + 16) - a2 - 1));
  }
  result = a1;
  --*(_DWORD *)(a1 + 16);
  return result;
}

//----- (000000000001FBFE) ----------------------------------------------------
signed __int64 __fastcall sub_1FBFE(__int64 *a1, const char *a2, int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v7; // rax
  __int64 v8; // r9
  __int64 v9; // [rsp+8h] [rbp-38h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  int v11; // [rsp+1Ch] [rbp-24h]
  signed int v12; // [rsp+30h] [rbp-10h]
  unsigned int v13; // [rsp+34h] [rbp-Ch]
  __int64 i; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  if ( !*(_DWORD *)(a5 + 16) )
  {
    *(_DWORD *)(a5 + 16) = 1;
    *(_QWORD *)a5 = malloc(8uLL);
    if ( !*(_QWORD *)v9 )
    {
      sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_data", v5);
      return 0xFFFFFFFFLL;
    }
    **(_QWORD **)v9 = 0LL;
  }
  v13 = 0;
  while ( v13 < *(_DWORD *)(v9 + 16) )
  {
    if ( *(_QWORD *)(8LL * v13 + *(_QWORD *)v9) && *(_DWORD *)(**(_QWORD **)(8LL * v13 + *(_QWORD *)v9) + 56LL) & 0x802C )
    {
      ++v13;
    }
    else
    {
      v12 = 0;
      if ( *(_QWORD *)(8LL * v13 + *(_QWORD *)v9) )
        v7 = *(_QWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)v9) + 64LL);
      else
        v7 = v10;
      for ( i = v7; i; i = *(_QWORD *)(i + 24) )
      {
        if ( a1 == (__int64 *)lyd_node_module(i)
          && !strncmp(**(const char ***)i, a2, v11)
          && !*(_BYTE *)(**(_QWORD **)i + v11) )
        {
          if ( v12 )
          {
            *(_QWORD *)v9 = sub_C422(*(void **)v9, 8LL * (unsigned int)++*(_DWORD *)(v9 + 16));
            if ( !*(_QWORD *)v9 )
            {
              sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_data", v8);
              return 1LL;
            }
            *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(v9 + 16) - 1) + *(_QWORD *)v9) = i;
            ++v13;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)v9 + 8LL * v13) = i;
            v12 = 1;
          }
        }
      }
      if ( v12 )
        ++v13;
      else
        sub_1FB5F(v9, v13);
    }
  }
  return *(_DWORD *)(v9 + 16) == 0;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (000000000001FEA6) ----------------------------------------------------
signed __int64 __fastcall sub_1FEA6(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+4h] [rbp-2Ch]
  __int64 v6; // [rsp+8h] [rbp-28h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( a1 )
  {
    if ( lys_parent(a1) )
    {
      if ( v5 )
        return 1LL;
      for ( i = v6; i && i != a1; i = lys_parent(i) )
        ;
      if ( !i )
        return 1LL;
    }
    else if ( a1 != v6 )
    {
      return 1LL;
    }
  }
  else if ( a2 != lys_node_module(a3) )
  {
    return 1LL;
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000001FF4C) ----------------------------------------------------
__int64 __fastcall sub_1FF4C(_BYTE *a1, __int64 a2, char *a3, __int64 a4)
{
  int v5; // er12
  char *v6; // rbx
  __int64 *v7; // rax
  int v8; // er12
  char *v9; // rbx
  __int64 *v10; // rax
  __int64 v11; // rax
  const char *v12; // rbx
  const char *v13; // rax
  __int64 v14; // [rsp+0h] [rbp-C0h]
  char *v15; // [rsp+8h] [rbp-B8h]
  _BYTE *v16; // [rsp+18h] [rbp-A8h]
  int v17; // [rsp+24h] [rbp-9Ch]
  int v18; // [rsp+28h] [rbp-98h]
  int v19; // [rsp+2Ch] [rbp-94h]
  int v20; // [rsp+30h] [rbp-90h]
  int v21; // [rsp+34h] [rbp-8Ch]
  int v22; // [rsp+38h] [rbp-88h]
  int v23; // [rsp+3Ch] [rbp-84h]
  int v24; // [rsp+40h] [rbp-80h]
  unsigned int v25; // [rsp+44h] [rbp-7Ch]
  int v26; // [rsp+48h] [rbp-78h]
  int v27; // [rsp+4Ch] [rbp-74h]
  __int64 v28; // [rsp+50h] [rbp-70h]
  char *i; // [rsp+58h] [rbp-68h]
  const char *v30; // [rsp+60h] [rbp-60h]
  char *v31; // [rsp+68h] [rbp-58h]
  char *v32; // [rsp+70h] [rbp-50h]
  char *v33; // [rsp+78h] [rbp-48h]
  char *v34; // [rsp+80h] [rbp-40h]
  __int64 v35; // [rsp+88h] [rbp-38h]
  __int64 v36; // [rsp+90h] [rbp-30h]
  void *v37; // [rsp+98h] [rbp-28h]
  __int64 v38; // [rsp+A0h] [rbp-20h]
  unsigned __int64 v39; // [rsp+A8h] [rbp-18h]

  v16 = a1;
  v15 = a3;
  v14 = a4;
  v39 = __readfsqword(0x28u);
  v25 = 0;
  v37 = **(void ***)(a2 + 48);
  do
  {
    v26 = sub_169E9(v16, &v32, (unsigned int *)&v19, &v31, (unsigned int *)&v18, (char **)&v30, &v17, &v22);
    if ( v26 <= 0 )
    {
      sub_13937(v37, 55, 2u, v15, (unsigned int)(char)v16[-v26], (__int64)&v16[-v26], v14);
      return v26 - v25;
    }
    v25 += v26;
    v16 += v26;
    if ( v32 )
    {
      v5 = v19;
      v6 = v32;
      v7 = (__int64 *)lys_node_module(v15);
      v35 = sub_407F3(v7, 0LL, 0, v6, v5, 0);
    }
    else
    {
      v35 = lys_node_module(v15);
    }
    v27 = sub_9B536(v35, a2, v31, v18, 12, 0x100u, (const char ***)&v28);
    if ( v27 )
    {
      sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)&v16[-v25], v14);
      return 0LL;
    }
    v23 = 0;
    v24 = 0;
    v26 = sub_16CF6(v30, &v34, (unsigned int *)&v21, &v33, (unsigned int *)&v20, &v23);
    if ( v26 <= 0 )
    {
      sub_13937(v37, 55, 2u, v15, (unsigned int)v30[-v26], (__int64)&v30[-v26], v14);
      return -v25;
    }
    v24 += v26;
    v26 = 0;
    i = v15;
    while ( v26 < v23 )
    {
      if ( !i )
      {
        sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)v30, v14);
        return 0LL;
      }
      if ( *((_QWORD *)i + 8)
        && *(_DWORD *)(*((_QWORD *)i + 8) + 56LL) == 0x2000
        && !*(_QWORD *)(*((_QWORD *)i + 8) + 88LL) )
      {
        sub_13937(
          v37,
          -1,
          2u,
          *((char **)i + 8),
          (__int64)"Cannot resolve leafref predicate \"%s\" because it is in an unresolved augment.",
          (__int64)v30,
          v14);
        return 0LL;
      }
      for ( i = (char *)lys_parent(i); i && !(*((_DWORD *)i + 14) & 0x4191); i = (char *)lys_parent(i) )
        ;
      ++v26;
    }
    while ( 1 )
    {
      v36 = 0LL;
      if ( v34 )
      {
        v8 = v21;
        v9 = v34;
        v10 = (__int64 *)lys_node_module(v15);
        v35 = sub_407F3(v10, 0LL, 0, v9, v8, 0);
      }
      else
      {
        v35 = lys_node_module(v15);
      }
      if ( *(_BYTE *)(v35 + 64) >= 0 && i )
        goto LABEL_29;
      while ( 2 )
      {
        if ( v36 )
          v11 = v36;
        else
          v11 = (__int64)i;
        v38 = v11;
        v27 = sub_9B536(v35, v11, v33, v20, 21, 0x100u, (const char ***)&i);
        if ( v27 )
        {
          if ( !v36 )
          {
            sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)v30, v14);
            return 0LL;
          }
          i = *(char **)(v36 + 88);
LABEL_29:
          v36 = sub_AA881(v36, v35, (__int64)i);
          continue;
        }
        break;
      }
      if ( v24 == v17 )
        break;
      v26 = sub_16CF6(&v30[v24], &v34, (unsigned int *)&v21, &v33, (unsigned int *)&v20, &v23);
      if ( v26 <= 0 )
      {
        sub_13937(
          v37,
          55,
          2u,
          v15,
          (unsigned int)v30[v24 + (signed __int64)-v26],
          (__int64)&v30[v24 - (signed __int64)v26],
          v14);
        return -v25;
      }
      v24 += v26;
    }
    if ( *((_DWORD *)i + 14) != *(_DWORD *)(v28 + 56) )
    {
      sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)&v16[-v25], v14);
      v12 = sub_8164(*((_DWORD *)i + 14));
      v13 = sub_8164(*(_DWORD *)(v28 + 56));
      sub_13937(v37, -1, 5u, 0LL, (__int64)"Destination node is not a %s, but a %s.", (__int64)v13, v12);
      return -v25;
    }
    ly_set_add(v14, i, 0LL);
    ly_set_add(v14, v28, 0LL);
  }
  while ( v22 );
  return v25;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000020624) ----------------------------------------------------
__int64 __fastcall sub_20624(__int64 a1)
{
  unsigned int v1; // eax
  int v3; // [rsp+14h] [rbp-4Ch]
  unsigned int j; // [rsp+18h] [rbp-48h]
  unsigned int k; // [rsp+1Ch] [rbp-44h]
  unsigned int v6; // [rsp+20h] [rbp-40h]
  unsigned int v7; // [rsp+24h] [rbp-3Ch]
  __int64 i; // [rsp+28h] [rbp-38h]
  void *v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  v9 = **(void ***)(*(_QWORD *)(a1 + 24) + 48LL);
  v6 = 0;
  if ( !*(_QWORD *)(a1 + 24) )
    __assert_fail("type->parent", "/home/mantovan/Repositories/libyang/src/resolve.c", 0xFF7u, "check_leafref_features");
  v10 = ly_set_new(a1);
  v11 = ly_set_new(a1);
  v12 = ly_set_new(a1);
  for ( i = *(_QWORD *)(a1 + 24); i; i = lys_parent(i) )
  {
    if ( !(*(_DWORD *)(i + 56) & 0x600) )
    {
      if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
      {
        v13 = *(_QWORD *)(i + 64);
        if ( *(_BYTE *)(*(_QWORD *)(v13 + 48) + 64LL) < 0 && *(_WORD *)(v13 + 24) & 1 || !*(_QWORD *)(v13 + 88) )
        {
          sub_13937(
            v9,
            -1,
            2u,
            (char *)v13,
            (__int64)"Cannot check leafref \"%s\" if-feature consistency because of an unresolved augment.",
            *(_QWORD *)(a1 + 32));
          v6 = 1;
          goto LABEL_52;
        }
        ly_set_add(v10, v13, 1LL);
      }
      ly_set_add(v10, i, 1LL);
    }
  }
  for ( i = *(_QWORD *)(a1 + 40); i; i = lys_parent(i) )
  {
    if ( !(*(_DWORD *)(i + 56) & 0x600) )
    {
      if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
      {
        if ( (v13 = *(_QWORD *)(i + 64), *(_BYTE *)(*(_QWORD *)(v13 + 48) + 64LL) < 0) && *(_WORD *)(v13 + 24) & 1
          || !*(_QWORD *)(v13 + 88) )
        {
          sub_13937(
            v9,
            -1,
            2u,
            (char *)v13,
            (__int64)"Cannot check leafref \"%s\" if-feature consistency because of an unresolved augment.",
            *(_QWORD *)(a1 + 32));
          v6 = 1;
          goto LABEL_52;
        }
      }
      ly_set_add(v11, i, 1LL);
    }
  }
  for ( j = 0; j < *(_DWORD *)(v10 + 4); ++j )
  {
    i = *(_QWORD *)(8LL * j + *(_QWORD *)(v10 + 8));
    if ( *(_BYTE *)(i + 27) )
    {
      for ( k = 0; k < *(unsigned __int8 *)(i + 27); ++k )
      {
        sub_1902D((__int64 *)(*(_QWORD *)(i + 40) + 32LL * k), 0LL, &v3);
        while ( v3 )
        {
          if ( !*(_QWORD *)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)) )
          {
            v6 = 1;
            goto LABEL_52;
          }
          ly_set_add(
            v12,
            *(_QWORD *)(8LL * (unsigned int)(v3-- - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)),
            0LL);
        }
      }
    }
  }
  v7 = *(_DWORD *)(v12 + 4);
  for ( j = 0; j < *(_DWORD *)(v11 + 4); ++j )
  {
    i = *(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 8));
    if ( *(_BYTE *)(i + 27) )
    {
      for ( k = 0; k < *(unsigned __int8 *)(i + 27); ++k )
      {
        sub_1902D((__int64 *)(*(_QWORD *)(i + 40) + 32LL * k), 0LL, &v3);
        while ( v3 )
        {
          if ( !*(_QWORD *)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)) )
          {
            v6 = 1;
            goto LABEL_52;
          }
          v1 = ly_set_add(
                 v12,
                 *(_QWORD *)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)),
                 0LL);
          if ( v7 <= v1 )
          {
            sub_13937(v9, 46, 2u, *(char **)(a1 + 24), (__int64)"leafref", *(_QWORD *)(a1 + 32));
            sub_13937(
              v9,
              -1,
              5u,
              0LL,
              (__int64)"Leafref is not conditional based on \"%s\" feature as its target.",
              **(_QWORD **)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)));
            v6 = -1;
            goto LABEL_52;
          }
          --v3;
        }
      }
    }
  }
LABEL_52:
  ly_set_free(v12);
  ly_set_free(v10);
  ly_set_free(v11);
  return v6;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (0000000000020BE2) ----------------------------------------------------
__int64 __fastcall sub_20BE2(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  int v8; // ebx
  __int64 v9; // rax
  __int16 v10; // ax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 *v14; // rax
  __int64 v15; // [rsp+8h] [rbp-A8h]
  int v16; // [rsp+28h] [rbp-88h]
  int v17; // [rsp+2Ch] [rbp-84h]
  int v18; // [rsp+30h] [rbp-80h]
  int v19; // [rsp+34h] [rbp-7Ch]
  int l; // [rsp+38h] [rbp-78h]
  int v21; // [rsp+3Ch] [rbp-74h]
  char *v22; // [rsp+40h] [rbp-70h]
  char *s2; // [rsp+48h] [rbp-68h]
  __int64 i; // [rsp+50h] [rbp-60h]
  __int64 j; // [rsp+58h] [rbp-58h]
  __int64 k; // [rsp+60h] [rbp-50h]
  __int64 v27; // [rsp+68h] [rbp-48h]
  char *v28; // [rsp+70h] [rbp-40h]
  void *v29; // [rsp+78h] [rbp-38h]
  __int64 v30; // [rsp+80h] [rbp-30h]
  __int64 *v31; // [rsp+88h] [rbp-28h]
  __int64 *v32; // [rsp+90h] [rbp-20h]
  unsigned __int64 v33; // [rsp+98h] [rbp-18h]

  v15 = a3;
  v33 = __readfsqword(0x28u);
  j = 0LL;
  v29 = **(void ***)(a2 + 48);
  for ( i = a2; lys_parent(i); i = lys_parent(i) )
    ;
  if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
  {
    sub_13937(
      v29,
      -1,
      2u,
      *(char **)(i + 64),
      (__int64)"Cannot resolve leafref \"%s\" because it is in an unresolved augment.",
      a1[4]);
    return 1LL;
  }
  v21 = 1;
  v18 = 0;
  v28 = (char *)a1[4];
  v30 = ly_set_new(i);
  if ( !v30 )
  {
    sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_schema_leafref", v4);
    return 0xFFFFFFFFLL;
  }
  for ( j = lys_parent(a2); j && !(*(_DWORD *)(j + 56) & 0x4180); j = lys_parent(j) )
    ;
  v31 = (__int64 *)lys_node_module(a2);
  do
  {
    l = sub_17055((__int64)v31, v28, (const char **)&v22, (unsigned int *)&v16, &s2, (unsigned int *)&v17, &v18, &v19);
    if ( l <= 0 )
    {
      sub_13937(v29, 55, 2u, (char *)a2, (unsigned int)v28[-l], (__int64)&v28[-l]);
      ly_set_free(v30);
      return 0xFFFFFFFFLL;
    }
    v28 += l;
    if ( v22 )
      v5 = (__int64 *)sub_407F3(v31, 0LL, 0, v22, v16, 0);
    else
      v5 = v31;
    v32 = v5;
    if ( !v5 )
    {
      sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
      ly_set_free(v30);
      return 1LL;
    }
    v27 = 0LL;
    if ( v21 )
    {
      if ( v18 == -1 )
      {
        i = 0LL;
      }
      else
      {
        if ( v18 <= 0 )
        {
          sub_12222(
            (__int64)v29,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            4274LL);
          ly_set_free(v30);
          return 0xFFFFFFFFLL;
        }
        l = 0;
        i = a2;
        while ( l < v18 )
        {
          for ( i = lys_parent(i); i && !(*(_DWORD *)(i + 56) & 0x4191); i = lys_parent(i) )
            ;
          if ( !i )
          {
            if ( l != v18 - 1 )
            {
              sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
              ly_set_free(v30);
              return 1LL;
            }
            break;
          }
          ++l;
        }
      }
    }
    if ( *((_BYTE *)v32 + 64) >= 0 && i )
      goto LABEL_39;
    while ( 2 )
    {
      if ( v27 )
        v6 = v27;
      else
        v6 = i;
      k = v6;
      i = 0LL;
      do
      {
        i = lys_getnext(i, k, v32, 256LL);
        if ( !i )
          break;
        v7 = lys_node_module(i);
      }
      while ( v7 != lys_main_module(v32) || strncmp(*(const char **)i, s2, v17) || *(_BYTE *)(*(_QWORD *)i + v17) );
      if ( !i )
      {
        if ( !v27 )
        {
          sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
          ly_set_free(v30);
          return 1LL;
        }
        i = *(_QWORD *)(v27 + 88);
LABEL_39:
        v27 = sub_AA881(v27, (__int64)v32, i);
        continue;
      }
      break;
    }
    if ( v21 )
    {
      for ( k = a2; lys_parent(k); k = lys_parent(k) )
        ;
      v8 = v18 == -1;
      v9 = lys_node_module(k);
      if ( (unsigned int)sub_1FEA6(j, v9, i, v8) )
      {
        v10 = *(_WORD *)(a2 + 24);
        HIBYTE(v10) |= 8u;
        *(_WORD *)(a2 + 24) = v10;
      }
      v21 = 0;
    }
    if ( v19 )
    {
      if ( *(_DWORD *)(i + 56) != 16 )
      {
        sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
        ly_set_free(v30);
        return 0xFFFFFFFFLL;
      }
      l = sub_1FF4C(v28, i, (char *)a2, v30);
      if ( !l )
      {
        ly_set_free(v30);
        return 1LL;
      }
      if ( l < 0 )
      {
        ly_set_free(v30);
        return 0xFFFFFFFFLL;
      }
      v28 += l;
      v19 = 0;
    }
  }
  while ( *v28 );
  if ( *(_DWORD *)(i + 56) == 4 || *(_DWORD *)(i + 56) == 8 )
  {
    if ( (unsigned int)sub_3C749(
                         *(_WORD *)(a2 + 24),
                         *(void ***)(a2 + 48),
                         *(_QWORD *)a2,
                         *(_WORD *)(i + 24),
                         *(_QWORD *)(i + 48),
                         *(_QWORD *)i,
                         (char *)i) )
    {
      ly_set_free(v30);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      a1[5] = i;
      ly_set_add(v30, i, 0LL);
      for ( i = a2; lys_parent(i); i = lys_parent(i) )
        ;
      if ( *(_BYTE *)(lys_node_module(i) + 64) & 0x80 )
      {
        for ( l = 0; *(_DWORD *)(v30 + 4) > (unsigned int)l; ++l )
        {
          for ( i = *(_QWORD *)(8LL * l + *(_QWORD *)(v30 + 8)); i; i = lys_parent(i) )
          {
            if ( !(*(_BYTE *)(lys_node_module(i) + 64) & 0x80) )
            {
              v13 = lys_node_module(i);
              *(_BYTE *)(v13 + 64) |= 0x80u;
              v14 = (__int64 *)lys_node_module(i);
              if ( (unsigned int)sub_2ABDE(v14, v15, 0LL, 0x8000u, 0LL) == -1 )
              {
                ly_set_free(v30);
                return 0xFFFFFFFFLL;
              }
            }
          }
          if ( (unsigned int)sub_A7706(*(_QWORD *)(8LL * l + *(_QWORD *)(v30 + 8)), a1[3], a1[3], 8LL * l, v11, v12) )
          {
            ly_set_free(v30);
            return 0xFFFFFFFFLL;
          }
        }
      }
      ly_set_free(v30);
      result = sub_20624((__int64)a1);
    }
  }
  else
  {
    sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
    sub_13937(v29, -1, 5u, 0LL, (__int64)"Leafref target \"%s\" is not a leaf nor a leaf-list.", a1[4]);
    ly_set_free(v30);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000021572) ----------------------------------------------------
__int64 __fastcall sub_21572(__int64 a1, __int64 a2, int a3, char *a4)
{
  int v4; // ST2C_4
  char *s2; // [rsp+0h] [rbp-90h]
  unsigned int v7; // [rsp+24h] [rbp-6Ch]
  __int64 v8; // [rsp+28h] [rbp-68h]
  __int64 s; // [rsp+30h] [rbp-60h]
  char *s1; // [rsp+68h] [rbp-28h]
  int v11; // [rsp+78h] [rbp-18h]
  unsigned __int64 v12; // [rsp+88h] [rbp-8h]

  v4 = a3;
  s2 = a4;
  v12 = __readfsqword(0x28u);
  v8 = a1;
  memset(&s, 0, 0x50uLL);
  s1 = (char *)lydict_insert(**(_QWORD **)(a1 + 48), a2, v4);
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + 128);
    s = a1;
    if ( v11 != 9 )
      break;
    if ( !*(_QWORD *)(v8 + 168) )
    {
      sub_12222(
        **(_QWORD **)(a1 + 48),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        4421LL,
        s2);
      v7 = -1;
      goto LABEL_9;
    }
    v8 = *(_QWORD *)(v8 + 168);
  }
  if ( sub_37EF5(v8 + 128, &s1, 0LL, (__int64 **)&s, 0LL, 0LL, 0, 0, 0) )
    v7 = strcmp(s1, s2) == 0;
  else
    v7 = -1;
LABEL_9:
  lydict_remove(**(_QWORD **)(a1 + 48), s1);
  return v7;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000002170F) ----------------------------------------------------
signed __int64 __fastcall sub_2170F(__int64 a1, __int64 a2, __int64 **a3, int a4)
{
  __int64 v5; // rbx
  const char *v6; // rax
  __int64 v7; // rbx
  const char *v8; // rax
  __int64 v9; // rbx
  const char *v10; // rax
  __int64 v11; // r9
  int v12; // [rsp+4h] [rbp-8Ch]
  __int64 **v13; // [rsp+8h] [rbp-88h]
  unsigned int v14; // [rsp+28h] [rbp-68h]
  unsigned int v15; // [rsp+2Ch] [rbp-64h]
  int v16; // [rsp+30h] [rbp-60h]
  int v17; // [rsp+34h] [rbp-5Ch]
  int i; // [rsp+38h] [rbp-58h]
  unsigned int v19; // [rsp+3Ch] [rbp-54h]
  char *s2; // [rsp+40h] [rbp-50h]
  char *nptr; // [rsp+48h] [rbp-48h]
  __int64 v22; // [rsp+50h] [rbp-40h]
  __int64 j; // [rsp+58h] [rbp-38h]
  void *ptr; // [rsp+60h] [rbp-30h]
  __int64 v25; // [rsp+68h] [rbp-28h]
  void *v26; // [rsp+70h] [rbp-20h]
  unsigned __int64 v27; // [rsp+78h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v27 = __readfsqword(0x28u);
  ptr = 0LL;
  v25 = 0LL;
  v26 = *(void **)a1;
  if ( !a2 || !a3 || !*a3 )
    __assert_fail(
      "pred && node && *node",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1175u,
      "resolve_instid_predicate");
  v19 = 0;
  do
  {
    i = sub_17401((_BYTE *)((signed int)v19 + a2), &s2, &v14, &nptr, &v15, (char **)&v22, &v16, &v17);
    if ( i <= 0 )
      return i - v19;
    v19 += i;
    if ( *v13 )
    {
      if ( *nptr == 46 )
      {
        if ( *(_DWORD *)(**v13 + 56) != 8 )
        {
          v5 = *(_QWORD *)**v13;
          v6 = sub_8164(*(_DWORD *)(**v13 + 56));
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects leaf-list, but have %s \"%s\".",
            (__int64)v6,
            v5);
          v19 = -1;
          goto LABEL_62;
        }
        if ( !(unsigned int)sub_21572(**v13, v22, v16, (char *)(*v13)[7]) )
        {
          *v13 = 0LL;
          goto LABEL_62;
        }
      }
      else if ( (*__ctype_b_loc())[*nptr] & 0x800 )
      {
        if ( v22 )
          __assert_fail(
            "!value",
            "/home/mantovan/Repositories/libyang/src/resolve.c",
            0x1194u,
            "resolve_instid_predicate");
        if ( *(_DWORD *)(**v13 + 56) != 16 )
        {
          v7 = *(_QWORD *)**v13;
          v8 = sub_8164(*(_DWORD *)(**v13 + 56));
          sub_13937(v26, -1, 0, 0LL, (__int64)"Instance identifier expects list, but have %s \"%s\".", (__int64)v8, v7);
          v19 = -1;
          goto LABEL_62;
        }
        if ( *(_QWORD *)(**v13 + 136) )
        {
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects list without keys, but have list \"%s\".",
            *(_QWORD *)**v13);
          v19 = -1;
          goto LABEL_62;
        }
        if ( v12 != atoi(nptr) )
        {
          *v13 = 0LL;
          goto LABEL_62;
        }
      }
      else
      {
        if ( *(_DWORD *)(**v13 + 56) != 16 )
        {
          v9 = *(_QWORD *)**v13;
          v10 = sub_8164(*(_DWORD *)(**v13 + 56));
          sub_13937(v26, -1, 0, 0LL, (__int64)"Instance identifier expects list, but have %s \"%s\".", (__int64)v10, v9);
          v19 = -1;
          goto LABEL_62;
        }
        v25 = **v13;
        if ( !ptr )
        {
          ptr = malloc(8LL * *(unsigned __int8 *)(v25 + 30));
          if ( !ptr )
          {
            sub_12222((__int64)v26, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_instid_predicate", v11);
            return 0xFFFFFFFFLL;
          }
          for ( i = 0; i < *(unsigned __int8 *)(v25 + 30); ++i )
            *((_QWORD *)ptr + i) = *(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 136));
        }
        for ( i = 0;
              i < *(unsigned __int8 *)(v25 + 30)
           && (!*((_QWORD *)ptr + i)
            || strncmp(**((const char ***)ptr + i), nptr, (signed int)v15)
            || *(_BYTE *)(**((_QWORD **)ptr + i) + (signed int)v15));
              ++i )
        {
          ;
        }
        if ( i == *(unsigned __int8 *)(v25 + 30) )
        {
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects list with the key \"%.*s\", but list \"%s\" does not define it.",
            v15,
            nptr,
            *(_QWORD *)v25);
          v19 = -1;
          goto LABEL_62;
        }
        if ( s2 )
        {
          if ( strncmp(*(const char **)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL), s2, (signed int)v14)
            || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL) + (signed int)v14) )
          {
            sub_13937(
              v26,
              -1,
              0,
              0LL,
              (__int64)"Instance identifier expects key \"%s\" from module \"%.*s\", not \"%s\".",
              **((_QWORD **)ptr + i),
              s2,
              v14,
              *(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL));
            v19 = -1;
            goto LABEL_62;
          }
        }
        else if ( a1 != *(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) )
        {
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects key \"%s\" from module \"%s\", not \"%s\".",
            **((_QWORD **)ptr + i),
            *(_QWORD *)(a1 + 8),
            *(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL));
          v19 = -1;
          goto LABEL_62;
        }
        for ( j = (*v13)[8]; j && *(_QWORD *)j != *((_QWORD *)ptr + i); j = *(_QWORD *)(j + 24) )
          ;
        if ( !j )
        {
          sub_12222(
            (__int64)v26,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            4581LL);
          v19 = -1;
          goto LABEL_62;
        }
        if ( (unsigned int)sub_21572(*(_QWORD *)j, v22, v16, *(char **)(j + 56)) )
          *((_QWORD *)ptr + i) = 0LL;
        else
          *v13 = 0LL;
      }
    }
  }
  while ( v17 );
  if ( *v13 && ptr )
  {
    for ( i = 0; i < *(unsigned __int8 *)(v25 + 30); ++i )
    {
      if ( *((_QWORD *)ptr + i) )
      {
        sub_13937(v26, -1, 0, 0LL, (__int64)"Instance identifier is missing list key \"%s\".", **((_QWORD **)ptr + i));
        v19 = -1;
        break;
      }
    }
  }
LABEL_62:
  free(ptr);
  return v19;
}

//----- (0000000000021FB6) ----------------------------------------------------
signed __int64 __fastcall sub_21FB6(__int64 a1, int a2)
{
  int v3; // [rsp+14h] [rbp-5Ch]
  __int64 v4; // [rsp+18h] [rbp-58h]
  char s; // [rsp+20h] [rbp-50h]
  void *ptr; // [rsp+30h] [rbp-40h]
  unsigned __int64 v7; // [rsp+68h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  if ( a2 )
  {
    v4 = a1;
    while ( v4 )
    {
      if ( *(_DWORD *)(v4 + 56) == 2048 )
        return 0LL;
      if ( *(_DWORD *)(v4 + 56) == 0x2000 )
      {
        if ( !*(_QWORD *)(v4 + 88) )
          return 1LL;
        v4 = *(_QWORD *)(v4 + 88);
      }
      else
      {
        v4 = *(_QWORD *)(v4 + 64);
      }
    }
  }
  memset(&s, 0, 0x40uLL);
  sub_141E4(0LL, 3u, &v3, 0LL);
  sub_DD261(a1, (void **)&s, 1);
  sub_142D2(0LL, v3, 0LL, 0);
  if ( ptr )
    free(ptr);
  return 0LL;
}

//----- (00000000000220D4) ----------------------------------------------------
signed __int64 __fastcall sub_220D4(__int64 a1, __int64 a2)
{
  const char *v2; // rbx
  const char *v3; // rax
  unsigned int i; // [rsp+1Ch] [rbp-14h]

  if ( *(_DWORD *)a2 == 9 )
  {
    if ( *(_WORD *)(a1 + 24) & 1
      && *(_QWORD *)(a2 + 40)
      && *(_BYTE *)(a2 + 48) != -1
      && *(_WORD *)(*(_QWORD *)(a2 + 40) + 24LL) & 2 )
    {
      v2 = sub_8164(*(_DWORD *)(*(_QWORD *)(a2 + 40) + 56LL));
      v3 = sub_8164(*(_DWORD *)(a1 + 56));
      sub_13937(
        **(void ***)(a1 + 48),
        -1,
        2u,
        (char *)a1,
        (__int64)"The leafref %s is config but refers to a non-config %s.",
        (__int64)v3,
        v2);
      return 0xFFFFFFFFLL;
    }
  }
  else if ( *(_DWORD *)a2 == 11 )
  {
    for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
    {
      if ( (unsigned int)sub_220D4(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)i << 6)) )
        return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (0000000000022209) ----------------------------------------------------
signed __int64 __fastcall sub_22209(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 v4; // r9
  unsigned __int64 v5; // [rsp+0h] [rbp-20h]
  __int64 v6; // [rsp+8h] [rbp-18h]
  void *v7; // [rsp+10h] [rbp-10h]

  v6 = a1;
  v5 = __PAIR__(a2, a3);
  if ( !a1 )
    return 0LL;
  if ( a2 & 0xFFFFFFFC )
    __assert_fail(
      "!(flags ^ (flags & LYS_CONFIG_MASK))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x125Bu,
      "inherit_config_flag");
  v7 = **(void ***)(a1 + 48);
  while ( v6 )
  {
    if ( (_DWORD)v5 )
    {
      *(_WORD *)(v6 + 24) &= 0xFFFCu;
      *(_WORD *)(v6 + 24) &= 0xFFFBu;
    }
    else
    {
      if ( *(_WORD *)(v6 + 24) & 4 )
      {
        if ( v5 & 0x200000000LL && *(_WORD *)(v6 + 24) & 1 )
        {
          sub_13937(v7, 10, 2u, (char *)v6, (__int64)"true", (__int64)"config", v5);
          sub_13937(v7, -1, 5u, 0LL, (__int64)"State nodes cannot have configuration nodes as children.", v4);
          return 0xFFFFFFFFLL;
        }
        goto LABEL_23;
      }
      if ( !(*(_DWORD *)(v6 + 56) & 0x1800) )
      {
        *(_WORD *)(v6 + 24) = *(_WORD *)(v6 + 24) & 0xFFFC | WORD2(v5);
        if ( *(_DWORD *)(v6 + 56) == 16 && *(_WORD *)(v6 + 24) & 1 && !*(_BYTE *)(v6 + 30) )
        {
          sub_13937(v7, 12, 2u, (char *)v6, (__int64)"key", (__int64)"list", v5);
          return 0xFFFFFFFFLL;
        }
      }
    }
    if ( *(_DWORD *)(v6 + 56) & 0x802C )
    {
      if ( *(_DWORD *)(v6 + 56) & 0xC && (unsigned int)sub_220D4(v6, v6 + 128) )
        return 0xFFFFFFFFLL;
    }
    else if ( (unsigned int)sub_22209(*(_QWORD *)(v6 + 72), a2, (unsigned int)v5) )
    {
      return 0xFFFFFFFFLL;
    }
LABEL_23:
    v6 = *(_QWORD *)(v6 + 80);
  }
  return 0LL;
}

//----- (000000000002245A) ----------------------------------------------------
signed __int64 __fastcall sub_2245A(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v4; // rdi
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rax
  __int64 *v9; // rax
  __int64 v10; // rbx
  const char *v11; // rax
  const char *v12; // rbx
  const char *v13; // rax
  const char *v14; // rax
  const char *v15; // rbx
  const char *v16; // rax
  const char *v17; // rax
  const char *v18; // rbx
  const char *v19; // rax
  const char *v20; // rax
  __int64 v21; // r9
  __int64 v22; // rax
  void *v23; // rax
  __int64 v24; // rax
  char v25; // al
  __int64 v26; // [rsp+8h] [rbp-68h]
  __int64 v27; // [rsp+18h] [rbp-58h]
  unsigned int v28; // [rsp+24h] [rbp-4Ch]
  __int64 v29; // [rsp+28h] [rbp-48h]
  __int64 i; // [rsp+30h] [rbp-40h]
  __int64 v31; // [rsp+38h] [rbp-38h]
  __int64 v32; // [rsp+40h] [rbp-30h]
  void *v33; // [rsp+48h] [rbp-28h]
  _WORD *v34; // [rsp+50h] [rbp-20h]
  unsigned __int64 v35; // [rsp+58h] [rbp-18h]

  v27 = a1;
  v26 = a3;
  v35 = __readfsqword(0x28u);
  if ( !a1 )
    __assert_fail("aug", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1299u, "resolve_augment");
  v32 = lys_main_module(*(_QWORD *)(a1 + 48));
  v33 = *(void **)v32;
  *(_WORD *)(a1 + 24) |= 1u;
  if ( !*(_QWORD *)(a1 + 88) )
  {
    if ( a2 )
      v4 = 0LL;
    else
      v4 = lys_node_module(a1);
    if ( (unsigned int)sub_1A193(*(char **)v27, a2, v4, &v29, 0, 0) == -1 )
    {
      sub_13937(v33, -2, 2u, (char *)v27, v5, v6);
      return 0xFFFFFFFFLL;
    }
    if ( !v29 )
    {
      sub_13937(v33, 36, 2u, (char *)v27, (__int64)"augment", *(_QWORD *)v27);
      return 1LL;
    }
    *(_QWORD *)(v27 + 88) = **(_QWORD **)(v29 + 8);
    ly_set_free(v29);
  }
  if ( *(_BYTE *)(v32 + 64) < 0 && !(*(_BYTE *)(lys_node_module(*(_QWORD *)(v27 + 88)) + 64) & 0x80) )
  {
    v8 = lys_node_module(*(_QWORD *)(v27 + 88));
    *(_BYTE *)(v8 + 64) |= 0x80u;
    v9 = (__int64 *)lys_node_module(*(_QWORD *)(v27 + 88));
    if ( (unsigned int)sub_2ABDE(v9, v26, 0LL, 0x8000u, 0LL) == -1 )
      return 0xFFFFFFFFLL;
  }
  if ( !*(_QWORD *)(v27 + 64) )
  {
    v10 = lys_node_module(v27);
    if ( v10 != lys_node_module(*(_QWORD *)(v27 + 88)) )
    {
      v28 = sub_3C596((__int64 *)v27, *(_QWORD *)(v27 + 88));
      if ( v28 )
        return v28;
    }
  }
  if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) & 0x11 )
  {
    for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_DWORD *)(i + 56) & 0xD0BF) )
      {
        v11 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(v33, 6, 2u, (char *)v27, (__int64)v11, (__int64)"augment");
        v12 = sub_8164(*(_DWORD *)(i + 56));
        v13 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
        sub_13937(v33, -1, 5u, 0LL, (__int64)"Cannot augment \"%s\" with a \"%s\".", (__int64)v13, v12);
        return 0xFFFFFFFFLL;
      }
    }
  }
  else if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) & 0x6C0 )
  {
    for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_DWORD *)(i + 56) & 0x903F) )
      {
        v14 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(v33, 6, 2u, (char *)v27, (__int64)v14, (__int64)"augment");
        v15 = sub_8164(*(_DWORD *)(i + 56));
        v16 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
        sub_13937(v33, -1, 5u, 0LL, (__int64)"Cannot augment \"%s\" with a \"%s\".", (__int64)v16, v15);
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) != 2 )
    {
      sub_13937(v33, 10, 2u, (char *)v27, *(_QWORD *)v27, (__int64)"target-node");
      v20 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
      sub_13937(v33, -1, 5u, 0LL, (__int64)"Invalid augment target node type \"%s\".", (__int64)v20);
      return 0xFFFFFFFFLL;
    }
    for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_DWORD *)(i + 56) & 0x807D) )
      {
        v17 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(v33, 6, 2u, (char *)v27, (__int64)v17, (__int64)"augment");
        v18 = sub_8164(*(_DWORD *)(i + 56));
        v19 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
        sub_13937(v33, -1, 5u, 0LL, (__int64)"Cannot augment \"%s\" with a \"%s\".", (__int64)v19, v18);
        return 0xFFFFFFFFLL;
      }
    }
  }
  for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( (unsigned int)sub_9C05E(i, *(_QWORD *)(v27 + 88), 0LL) )
      return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) == 2 )
  {
    for ( i = *(_QWORD *)(v27 + 72); ; i = v31 )
    {
      if ( i )
      {
        v31 = *(_QWORD *)(i + 80);
        v25 = 1;
      }
      else
      {
        v25 = 0;
      }
      if ( !v25 )
        break;
      if ( *(_DWORD *)(i + 56) != 64 )
      {
        v34 = calloc(1uLL, 0x70uLL);
        if ( !v34 )
        {
          sub_12222((__int64)v33, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_augment", v21);
          return 1LL;
        }
        v22 = lydict_insert(v33, *(_QWORD *)i, 0LL);
        *(_QWORD *)v34 = v22;
        v34[12] = *(_WORD *)(i + 24) & 3 | 0x40;
        *((_QWORD *)v34 + 6) = *(_QWORD *)(i + 48);
        *((_DWORD *)v34 + 14) = 64;
        *((_QWORD *)v34 + 8) = *(_QWORD *)(i + 64);
        if ( i == *(_QWORD *)(i + 88) )
          v23 = v34;
        else
          v23 = *(void **)(i + 88);
        *((_QWORD *)v34 + 11) = v23;
        if ( *(_QWORD *)(*((_QWORD *)v34 + 11) + 80LL) )
          *(_QWORD *)(*((_QWORD *)v34 + 11) + 80LL) = v34;
        else
          *(_QWORD *)(*((_QWORD *)v34 + 8) + 72LL) = v34;
        *((_QWORD *)v34 + 10) = *(_QWORD *)(i + 80);
        if ( *((_QWORD *)v34 + 10) )
          v24 = *((_QWORD *)v34 + 10);
        else
          v24 = *(_QWORD *)(*((_QWORD *)v34 + 8) + 72LL);
        *(_QWORD *)(v24 + 88) = v34;
        *((_QWORD *)v34 + 9) = i;
        *(_QWORD *)(i + 88) = i;
        *(_QWORD *)(i + 80) = 0LL;
        *(_QWORD *)(i + 64) = v34;
      }
    }
  }
  if ( *(_QWORD *)(v27 + 72) )
  {
    if ( (*(_QWORD *)(v27 + 64) || *(_BYTE *)(v32 + 64) < 0) && (unsigned int)sub_A7ED6(v27, v26) )
      return 0xFFFFFFFFLL;
  }
  else
  {
    sub_12222((__int64)v33, 1u, 0, "Augment \"%s\" without children.", *(_QWORD *)v27, v3);
    *(_WORD *)(v27 + 24) &= 0xFFFEu;
  }
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000022CDC) ----------------------------------------------------
signed __int64 __fastcall sub_22CDC(_QWORD *a1, __int64 **a2, __int64 a3)
{
  unsigned int v3; // eax
  __int64 v4; // r9
  int v6; // edx
  __int16 v7; // ax
  __int64 *v8; // rbx
  __int64 *v9; // rbx
  __int64 *v10; // rbx
  char v11; // al
  __int16 v12; // dx
  char v13; // al
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  int v17; // edx
  __int16 v18; // ax
  __int16 v19; // dx
  __int64 v20; // r9
  __int64 v21; // [rsp+8h] [rbp-88h]
  unsigned int v22; // [rsp+20h] [rbp-70h]
  unsigned int i; // [rsp+24h] [rbp-6Ch]
  unsigned int k; // [rsp+24h] [rbp-6Ch]
  unsigned int n; // [rsp+24h] [rbp-6Ch]
  unsigned int jj; // [rsp+24h] [rbp-6Ch]
  unsigned int j; // [rsp+28h] [rbp-68h]
  unsigned int ii; // [rsp+28h] [rbp-68h]
  int v29; // [rsp+2Ch] [rbp-64h]
  int v30; // [rsp+2Ch] [rbp-64h]
  char *v31; // [rsp+30h] [rbp-60h]
  unsigned __int64 v32; // [rsp+38h] [rbp-58h]
  unsigned __int64 v33; // [rsp+38h] [rbp-58h]
  _QWORD *v34; // [rsp+40h] [rbp-50h]
  _QWORD *l; // [rsp+48h] [rbp-48h]
  _QWORD *m; // [rsp+48h] [rbp-48h]
  void *v37; // [rsp+50h] [rbp-40h]
  void *v38; // [rsp+50h] [rbp-40h]
  char *s; // [rsp+58h] [rbp-38h]
  char *v40; // [rsp+60h] [rbp-30h]
  _BYTE *v41; // [rsp+68h] [rbp-28h]
  _QWORD *v42; // [rsp+70h] [rbp-20h]
  __int64 v43; // [rsp+70h] [rbp-20h]
  __int64 *v44; // [rsp+78h] [rbp-18h]

  v21 = a3;
  v3 = *((_DWORD *)a1 + 8);
  if ( v3 == 1 )
  {
    v31 = (char *)a1[2];
    v22 = 2;
  }
  else if ( v3 >= 1 && v3 - 15 > 1 )
  {
    v31 = 0LL;
    v22 = 0;
  }
  else
  {
    v31 = 0LL;
    v22 = 2;
  }
  if ( *((_DWORD *)a1 + 2) == 2 )
  {
    v42 = (_QWORD *)sub_40BA1(a1[3], *(_BYTE **)(*(_QWORD *)(*a1 + 56LL) + 32LL));
    if ( !v42 )
    {
      sub_13937(0LL, 5, v22, v31, *(_QWORD *)(*a1 + 48LL), v4);
      return 1LL;
    }
    v37 = (void *)*v42;
    v32 = 0LL;
    for ( i = 0; i < *((unsigned __int8 *)v42 + 79); ++i )
    {
      if ( *(_QWORD *)(((unsigned __int64)i << 6) + v42[19]) == *(_QWORD *)(*a1 + 48LL) )
      {
        v32 = ((unsigned __int64)i << 6) + v42[19];
        break;
      }
    }
    for ( j = 0; !v32 && j < *((unsigned __int8 *)v42 + 70); ++j )
    {
      for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(v42[13] + 48LL * j) + 79LL); ++k )
      {
        if ( *(_QWORD *)(((unsigned __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(v42[13] + 48LL * j) + 152LL)) == *(_QWORD *)(*a1 + 48LL) )
        {
          v32 = ((unsigned __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(v42[13] + 48LL * j) + 152LL);
          break;
        }
      }
    }
    if ( !v32 )
    {
      sub_13937(v37, 5, v22, v31, *(_QWORD *)(*a1 + 48LL), v4);
      return 1LL;
    }
    if ( *(_QWORD *)(v32 + 56)
      && *(_QWORD *)(*(_QWORD *)(v32 + 56) + 8LL)
      && (*(unsigned int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v32 + 56) + 8LL))(
           a1[2],
           *((unsigned int *)a1 + 8),
           *((unsigned int *)a1 + 9)) )
    {
      sub_13937(v37, 5, v22, v31, *(_QWORD *)v32, v4);
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(v32 + 56) )
      v29 = **(_DWORD **)(v32 + 56);
    else
      v29 = 0;
    if ( v29 )
    {
      if ( v29 == 1 )
      {
        *a2 = (__int64 *)calloc(1uLL, *(_QWORD *)(*(_QWORD *)(v32 + 56) + 48LL));
      }
      else if ( v29 == -1 )
      {
        sub_12222(
          (__int64)v37,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
          4983LL);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      *a2 = (__int64 *)calloc(1uLL, 0x40uLL);
    }
    if ( !*a2 )
    {
      sub_12222((__int64)v37, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_extension", v4);
      return 0xFFFFFFFFLL;
    }
    **a2 = v32;
    (*a2)[1] = a1[2];
    *((_BYTE *)*a2 + 29) = *((_DWORD *)a1 + 8);
    *((_BYTE *)*a2 + 28) = *((_DWORD *)a1 + 9);
    *((_BYTE *)*a2 + 27) = *((_BYTE *)a1 + 40);
    if ( *(_QWORD *)(v32 + 56) )
      v6 = **(_DWORD **)(v32 + 56);
    else
      LOBYTE(v6) = 0;
    *((_BYTE *)*a2 + 30) = v6;
    if ( *(_QWORD *)(v32 + 56) )
      v7 = *(_WORD *)(*(_QWORD *)(v32 + 56) + 4LL);
    else
      v7 = 0;
    *((_WORD *)*a2 + 12) |= v7;
    if ( *(_QWORD *)(v32 + 40) )
    {
      if ( *(_WORD *)(v32 + 24) & 1 )
      {
        for ( l = *(_QWORD **)(*a1 + 24LL); ; l = v34 )
        {
          if ( l )
          {
            v34 = (_QWORD *)l[4];
            v11 = 1;
          }
          else
          {
            v11 = 0;
          }
          if ( !v11 )
            break;
          if ( l[6] == *(_QWORD *)(v32 + 40) )
          {
            v10 = *a2;
            v10[2] = lydict_insert(*v42, l[8], 0LL);
            lyxml_free(*v42, l);
            break;
          }
        }
      }
      else
      {
        v8 = *a2;
        v8[2] = lyxml_get_attr(*a1, *(_QWORD *)(v32 + 40), 0LL);
        if ( !(*a2)[2] )
        {
          sub_13937(v37, 13, 0, 0LL, *(_QWORD *)(v32 + 40), *(_QWORD *)(*a1 + 48LL));
          return 0xFFFFFFFFLL;
        }
        v9 = *a2;
        v9[2] = lydict_insert(*v42, (*a2)[2], 0LL);
      }
    }
    if ( (*a2)[3] & 8 && (*((_DWORD *)a1 + 8) == 1 || *((_DWORD *)a1 + 8) == 2) )
    {
      v12 = *(_WORD *)(a1[2] + 24LL);
      HIBYTE(v12) |= 0x20u;
      *(_WORD *)(a1[2] + 24LL) = v12;
    }
    *((_DWORD *)*a2 + 14) = 0x10000;
    (*a2)[6] = a1[3];
    if ( v29 )
    {
      if ( v29 == 1 )
      {
        (*a2)[8] = *(_QWORD *)(*(_QWORD *)(v32 + 56) + 40LL);
        if ( (unsigned int)sub_627C3((__int64 *)a1[3], *a2, *a1, v21) )
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      for ( m = *(_QWORD **)(*a1 + 24LL); ; m = v34 )
      {
        if ( m )
        {
          v34 = (_QWORD *)m[4];
          v13 = 1;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
          break;
        if ( m[7] )
        {
          if ( !strcmp(*(const char **)(m[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
          {
            sub_13937(v37, 6, v22, v31, m[6], *(_QWORD *)(*a1 + 48LL));
            return 0xFFFFFFFFLL;
          }
          if ( m[7] == *(_QWORD *)(*a1 + 56LL) && *(_WORD *)(v32 + 24) & 1 && m[6] == *(_QWORD *)(v32 + 40) )
          {
            if ( (*a2)[2] )
            {
              sub_13937(v37, 14, v22, v31, m[6], *(_QWORD *)(*a1 + 48LL));
              return 0xFFFFFFFFLL;
            }
            (*a2)[2] = m[8];
            m[8] = 0LL;
            lyxml_free(*v42, m);
          }
          else if ( (unsigned int)sub_411CA((__int64 *)a1[3], (__int64)*a2, 0xBu, m, 0, 0LL, v21) )
          {
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          lyxml_free(*v42, m);
        }
      }
    }
    return 0LL;
  }
  s = (char *)**a2;
  v40 = strchr(s, 58);
  if ( v40 )
  {
    v41 = v40 + 1;
    v43 = sub_407F3((__int64 *)a1[3], s, (signed int)v40 - (signed int)s, 0LL, 0, 0);
    if ( !v43 )
    {
      sub_13937(0LL, 5, v22, v31, (__int64)s, v15);
      return 1LL;
    }
    v38 = *(void **)v43;
    v33 = 0LL;
    for ( n = 0; n < *(unsigned __int8 *)(v43 + 79); ++n )
    {
      if ( (unsigned int)sub_C462(*(_BYTE **)(((unsigned __int64)n << 6) + *(_QWORD *)(v43 + 152)), v41) )
      {
        v33 = ((unsigned __int64)n << 6) + *(_QWORD *)(v43 + 152);
        break;
      }
    }
    for ( ii = 0; !v33 && ii < *(unsigned __int8 *)(v43 + 70); ++ii )
    {
      for ( jj = 0; jj < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * ii) + 79LL); ++jj )
      {
        if ( (unsigned int)sub_C462(
                             *(_BYTE **)(((unsigned __int64)jj << 6)
                                       + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * ii) + 152LL)),
                             v41) )
        {
          v33 = ((unsigned __int64)jj << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * ii) + 152LL);
          break;
        }
      }
    }
    if ( !v33 )
    {
      sub_13937(v38, 5, v22, v31, (__int64)s, v15);
      return 1LL;
    }
    *((_WORD *)*a2 + 12) &= 0xFFFDu;
    **a2 = 0LL;
    if ( *(_QWORD *)(v33 + 56)
      && *(_QWORD *)(*(_QWORD *)(v33 + 56) + 8LL)
      && (*(unsigned int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v33 + 56) + 8LL))(
           a1[2],
           *((unsigned int *)a1 + 8),
           *((unsigned int *)a1 + 9)) )
    {
      sub_13937(v38, 5, v22, v31, *(_QWORD *)v33, v16);
    }
    else if ( !*(_QWORD *)(v33 + 40) || (*a2)[2] )
    {
      **a2 = v33;
      (*a2)[1] = a1[2];
      if ( *(_QWORD *)(v33 + 56) )
        v17 = **(_DWORD **)(v33 + 56);
      else
        LOBYTE(v17) = 0;
      *((_BYTE *)*a2 + 30) = v17;
      if ( *(_QWORD *)(v33 + 56) )
        v18 = *(_WORD *)(*(_QWORD *)(v33 + 56) + 4LL);
      else
        v18 = 0;
      *((_WORD *)*a2 + 12) |= v18;
      if ( (*a2)[3] & 8 && (*((_DWORD *)a1 + 8) == 1 || *((_DWORD *)a1 + 8) == 2) )
      {
        v19 = *(_WORD *)(a1[2] + 24LL);
        HIBYTE(v19) |= 0x20u;
        *(_WORD *)(a1[2] + 24LL) = v19;
      }
      (*a2)[6] = a1[3];
      *((_DWORD *)*a2 + 14) = 0x10000;
      if ( *(_QWORD *)(v33 + 56) )
        v30 = **(_DWORD **)(v33 + 56);
      else
        v30 = 0;
      if ( v30 )
      {
        if ( v30 == 1 )
        {
          v44 = (__int64 *)realloc(*a2, *(_QWORD *)(*(_QWORD *)(v33 + 56) + 48LL));
          if ( !v44 )
          {
            sub_12222((__int64)v38, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_extension", v20);
            goto LABEL_145;
          }
          memset(v44 + 9, 0, *(_QWORD *)(*(_QWORD *)(v33 + 56) + 48LL) - 72LL);
          *a2 = v44;
          (*a2)[8] = *(_QWORD *)(*(_QWORD *)(v33 + 56) + 40LL);
          if ( *a1 )
          {
            *v40 = 58;
            if ( (unsigned int)sub_92FC8((__int64 *)a1[3], v21, *(const char **)*a1, (__int64)s, *a2)
              || (unsigned int)sub_9ACA3(
                                 *(void **)a1[3],
                                 (__int64)*a2,
                                 (__int64)s,
                                 *(_QWORD *)(*a1 + 8LL),
                                 (unsigned __int8)(*(_BYTE *)(a1[3] + 64LL) >> 7)) )
            {
              goto LABEL_145;
            }
          }
          if ( (unsigned int)sub_3E959((__int64)*a2, (__int64)s) )
            goto LABEL_145;
        }
        else if ( v30 == -1 )
        {
          sub_12222(
            (__int64)v38,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            5180LL);
          goto LABEL_145;
        }
      }
      if ( !(unsigned int)sub_9554F((__int64 *)a1[3], *a2 + 4, *((unsigned __int8 *)*a2 + 26), (__int64)*a2, v21) )
      {
        free(s);
        return 0LL;
      }
    }
    else
    {
      sub_13937(v38, 13, 0, 0LL, *(_QWORD *)(v33 + 40), (__int64)v41);
    }
  }
  else
  {
    sub_13937(0LL, 5, v22, v31, (__int64)s, v14);
  }
LABEL_145:
  free(s);
  return 0xFFFFFFFFLL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000023C04) ----------------------------------------------------
__int64 __fastcall sub_23C04(__int64 a1, __int64 a2)
{
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  for ( i = *(_QWORD *)(a1 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) == 4096 )
    {
      v4 = sub_23C04(i, a2);
      if ( v4 )
        return v4;
    }
    if ( a2 == *(_QWORD *)i && *(_DWORD *)(i + 56) & 0x807F )
      return i;
  }
  return 0LL;
}

//----- (0000000000023C91) ----------------------------------------------------
signed __int64 __fastcall sub_23C91(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  __int64 v3; // rax
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rbx
  __int16 v11; // dx
  __int64 v12; // rbx
  unsigned int v13; // eax
  __int64 v14; // r9
  _QWORD *v15; // rbx
  signed __int64 v16; // rbx
  signed __int64 v17; // rbx
  signed __int64 v18; // rbx
  signed __int64 v19; // rbx
  __int64 v20; // r9
  void **v21; // rbx
  __int64 v22; // r9
  signed __int64 v23; // rbx
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9
  __int64 v27; // rbx
  __int64 v28; // r9
  __int64 v29; // r9
  const char *v30; // rax
  __int64 v31; // r9
  const char *v32; // rax
  __int64 v33; // r9
  char v35; // al
  unsigned __int8 v36; // [rsp+1Bh] [rbp-B5h]
  unsigned __int8 v37; // [rsp+1Bh] [rbp-B5h]
  unsigned int v38; // [rsp+1Ch] [rbp-B4h]
  unsigned int v39; // [rsp+20h] [rbp-B0h]
  int l; // [rsp+24h] [rbp-ACh]
  int m; // [rsp+28h] [rbp-A8h]
  int v42; // [rsp+2Ch] [rbp-A4h]
  int v43; // [rsp+30h] [rbp-A0h]
  char size[12]; // [rsp+34h] [rbp-9Ch]
  __int64 v45; // [rsp+40h] [rbp-90h]
  __int64 k; // [rsp+48h] [rbp-88h]
  void *ptr; // [rsp+50h] [rbp-80h]
  __int64 i; // [rsp+58h] [rbp-78h]
  __int64 n; // [rsp+60h] [rbp-70h]
  __int64 j; // [rsp+68h] [rbp-68h]
  void **v51; // [rsp+70h] [rbp-60h]
  unsigned __int8 *v52; // [rsp+78h] [rbp-58h]
  void *v53; // [rsp+80h] [rbp-50h]
  __int64 v54; // [rsp+88h] [rbp-48h]
  __int64 v55; // [rsp+90h] [rbp-40h]
  __int64 v56; // [rsp+98h] [rbp-38h]
  _BYTE *v57; // [rsp+A0h] [rbp-30h]
  _QWORD *v58; // [rsp+A8h] [rbp-28h]
  _QWORD *v59; // [rsp+B0h] [rbp-20h]
  unsigned __int64 v60; // [rsp+B8h] [rbp-18h]

  v60 = __readfsqword(0x28u);
  v53 = **(void ***)(a1 + 48);
  *(_QWORD *)&size[4] = 0LL;
  ptr = 0LL;
  if ( !*(_QWORD *)(a1 + 128) )
    __assert_fail("uses->grp", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1481u, "resolve_uses");
  if ( *(_WORD *)(*(_QWORD *)(a1 + 128) + 28LL) )
    __assert_fail(
      "!uses->grp->unres_count",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1484u,
      "resolve_uses");
  for ( i = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 72LL); i; i = *(_QWORD *)(i + 80) )
  {
    if ( !(*(_DWORD *)(i + 56) & 0x800) )
    {
      *(_QWORD *)&size[4] = sub_A60D4(*(__int64 **)(a1 + 48), a1, i, a2, 0);
      if ( !*(_QWORD *)&size[4] )
      {
        sub_13937(v53, 10, 2u, (char *)a1, **(_QWORD **)(a1 + 128), (__int64)"uses", a2);
        sub_13937(v53, -1, 5u, 0LL, (__int64)"Copying data from grouping failed.", v2);
        goto LABEL_188;
      }
      if ( *(_QWORD *)(a1 + 64) )
        v3 = *(_QWORD *)sub_A75EB(*(_QWORD *)(a1 + 64), 0x1000u);
      else
        v3 = *(_QWORD *)(lys_main_module(*(_QWORD *)(a1 + 48)) + 168);
      for ( j = v3; j; j = *(_QWORD *)(j + 80) )
      {
        if ( !(*(_DWORD *)(j + 56) & 0x1840) && *(_QWORD *)j == *(_QWORD *)i )
          goto LABEL_188;
      }
    }
  }
  if ( *(_BYTE *)(a1 + 30) )
  {
    ptr = malloc(8LL * *(unsigned __int8 *)(a1 + 30));
    if ( !ptr )
    {
      sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v4, a2);
LABEL_188:
      for ( k = *(_QWORD *)(a1 + 72); ; k = v45 )
      {
        if ( k )
        {
          v45 = *(_QWORD *)(k + 80);
          v35 = 1;
        }
        else
        {
          v35 = 0;
        }
        if ( !v35 )
          break;
        sub_A33A0((_QWORD **)k, 0LL, 0);
      }
      free(ptr);
      return 0xFFFFFFFFLL;
    }
  }
  for ( l = 0; l < *(unsigned __int8 *)(a1 + 30); ++l )
  {
    v54 = *(_QWORD *)(a1 + 112) + 80LL * l;
    v43 = sub_1AF63(*(const char **)v54, *(_QWORD *)(a1 + 72), 49407, 0, &size[4]);
    if ( v43 || !*(_QWORD *)&size[4] )
    {
      sub_13937(v53, 10, 2u, (char *)a1, *(_QWORD *)v54, (__int64)"refine", a2);
      goto LABEL_188;
    }
    if ( *(_WORD *)(v54 + 28) && !(*(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & *(unsigned __int16 *)(v54 + 28)) )
    {
      sub_13937(v53, 10, 2u, (char *)a1, *(_QWORD *)v54, (__int64)"refine", a2);
      sub_13937(v53, -1, 5u, 0LL, (__int64)"Refine substatements not applicable to the target-node.", v6);
      goto LABEL_188;
    }
    *((_QWORD *)ptr + l) = *(_QWORD *)&size[4];
    if ( *(_QWORD *)(v54 + 8) )
    {
      lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 8LL));
      v7 = *(_QWORD *)&size[4];
      *(_QWORD *)(v7 + 8) = lydict_insert(v53, *(_QWORD *)(v54 + 8), 0LL);
    }
    if ( *(_QWORD *)(v54 + 16) )
    {
      lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 16LL));
      v8 = *(_QWORD *)&size[4];
      *(_QWORD *)(v8 + 16) = lydict_insert(v53, *(_QWORD *)(v54 + 16), 0LL);
    }
    if ( *(_WORD *)(v54 + 24) & 3 && *(_WORD *)(*(_QWORD *)&size[4] + 24LL) & 3 )
    {
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) &= 0xFFFCu;
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) |= *(_WORD *)(v54 + 24) & 3;
    }
    if ( *(_BYTE *)(v54 + 31) )
    {
      if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 4 )
      {
        v55 = *(_QWORD *)&size[4];
        lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 200LL));
        v9 = lydict_insert(v53, **(_QWORD **)(v54 + 64), 0LL);
        *(_QWORD *)(v55 + 200) = v9;
        if ( (unsigned int)sub_2ABDE(
                             *(__int64 **)(v55 + 48),
                             a2,
                             (__int64 *)(v55 + 128),
                             0x1000u,
                             (__int64 *)(v55 + 200)) == -1 )
          goto LABEL_188;
      }
      else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8 )
      {
        v56 = *(_QWORD *)&size[4];
        for ( m = 0; m < *(unsigned __int8 *)(v56 + 30); ++m )
          lydict_remove(v53, *(_QWORD *)(8LL * m + *(_QWORD *)(v56 + 200)));
        free(*(void **)(v56 + 200));
        *(_QWORD *)(v56 + 200) = malloc(8LL * *(unsigned __int8 *)(v54 + 31));
        if ( !*(_QWORD *)(v56 + 200) )
        {
          sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v5, a2);
          goto LABEL_188;
        }
        *(_BYTE *)(v56 + 30) = *(_BYTE *)(v54 + 31);
        for ( m = 0; m < *(unsigned __int8 *)(v56 + 30); ++m )
        {
          v10 = (_QWORD *)(*(_QWORD *)(v56 + 200) + 8LL * m);
          *v10 = lydict_insert(v53, *(_QWORD *)(8LL * m + *(_QWORD *)(v54 + 64)), 0LL);
        }
        for ( m = 0; m < *(unsigned __int8 *)(v56 + 30); ++m )
        {
          if ( (unsigned int)sub_2ABDE(
                               *(__int64 **)(v56 + 48),
                               a2,
                               (__int64 *)(v56 + 128),
                               0x1000u,
                               (__int64 *)(*(_QWORD *)(v56 + 200) + 8LL * m)) == -1 )
            goto LABEL_188;
        }
      }
    }
    if ( *(_WORD *)(v54 + 24) & 0xC0 )
    {
      v11 = *(_WORD *)(*(_QWORD *)&size[4] + 24LL);
      LOBYTE(v11) = v11 & 0x3F;
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) = v11;
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) |= *(_WORD *)(v54 + 24) & 0xC0;
      if ( *(_WORD *)(v54 + 24) & 0x40 )
      {
        if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & 4 && *(_QWORD *)(*(_QWORD *)&size[4] + 200LL) )
        {
          sub_13937(
            v53,
            -1,
            2u,
            (char *)a1,
            (__int64)"The \"mandatory\" statement is forbidden on leaf with \"default\".",
            v5,
            a2);
          goto LABEL_188;
        }
        if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & 2 && *(_QWORD *)(*(_QWORD *)&size[4] + 112LL) )
        {
          sub_13937(
            v53,
            -1,
            2u,
            (char *)a1,
            (__int64)"The \"mandatory\" statement is forbidden on choices with \"default\".",
            v5,
            a2);
          goto LABEL_188;
        }
      }
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & 1 && *(_QWORD *)(v54 + 72) )
    {
      lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 136LL));
      v12 = *(_QWORD *)&size[4];
      *(_QWORD *)(v12 + 136) = lydict_insert(v53, *(_QWORD *)(v54 + 72), 0LL);
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 16 )
    {
      if ( *(_WORD *)(v54 + 24) & 0x10 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 152LL) = *(_DWORD *)(v54 + 72);
      if ( *(_WORD *)(v54 + 24) & 8 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 156LL) = *(_DWORD *)(v54 + 76);
    }
    else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8 )
    {
      if ( *(_WORD *)(v54 + 24) & 0x10 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 208LL) = *(_DWORD *)(v54 + 72);
      if ( *(_WORD *)(v54 + 24) & 8 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 212LL) = *(_DWORD *)(v54 + 76);
    }
    if ( *(_BYTE *)(v54 + 30) )
    {
      v13 = *(_DWORD *)(*(_QWORD *)&size[4] + 56LL);
      if ( v13 == 8 )
      {
        v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 31LL);
        v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
      }
      else if ( v13 > 8 )
      {
        if ( v13 == 32 || v13 == 32800 )
        {
          v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 31LL);
          v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
        }
        else
        {
          if ( v13 != 16 )
          {
LABEL_89:
            sub_12222(
              (__int64)v53,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              5432LL,
              a2);
            goto LABEL_188;
          }
          v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 28LL);
          v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
        }
      }
      else if ( v13 == 1 )
      {
        v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 29LL);
        v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
      }
      else
      {
        if ( v13 != 4 )
          goto LABEL_89;
        v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 31LL);
        v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
      }
      v36 = *v52 + *(_BYTE *)(v54 + 30);
      v57 = realloc(*v51, 56LL * v36);
      if ( !v57 )
      {
        sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v14, a2);
        goto LABEL_188;
      }
      v42 = 0;
      m = *v52;
      while ( v42 < *(unsigned __int8 *)(v54 + 30) )
      {
        v57[56 * m + 48] = *(_BYTE *)(56LL * v42 + *(_QWORD *)(v54 + 56) + 48);
        sub_9EB54(
          (__int64)v53,
          *(_QWORD *)(v54 + 48),
          *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 40),
          *(_BYTE *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 48),
          (void *)(*(_QWORD *)(v54 + 56) + 56LL * v42),
          7,
          (__int64 *)&v57[56 * m + 40],
          0,
          a2);
        v15 = &v57[56 * m];
        *v15 = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42), 0LL);
        v16 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v16 + 8) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 8), 0LL);
        v17 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v17 + 16) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 16), 0LL);
        v18 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v18 + 24) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 24), 0LL);
        v19 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v19 + 32) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 32), 0LL);
        *(_WORD *)&v57[56 * m++ + 50] = *(_WORD *)(56LL * v42++ + *(_QWORD *)(v54 + 56) + 50);
      }
      *v51 = v57;
      *v52 = v36;
      if ( (unsigned int)sub_2ABDE(*(__int64 **)(*(_QWORD *)&size[4] + 48LL), a2, *(__int64 **)&size[4], 0x20000u, 0LL) == -1 )
        goto LABEL_188;
    }
    if ( *(_BYTE *)(v54 + 27) )
    {
      v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 27LL);
      v58 = (_QWORD *)(*(_QWORD *)&size[4] + 40LL);
      v37 = *(_BYTE *)(*(_QWORD *)&size[4] + 27LL) + *(_BYTE *)(v54 + 27);
      v59 = realloc(*(void **)(*(_QWORD *)&size[4] + 40LL), 32LL * v37);
      if ( !v59 )
      {
        sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v20, a2);
        goto LABEL_188;
      }
      *v58 = v59;
      v42 = 0;
      m = *v52;
      while ( v42 < *(unsigned __int8 *)(v54 + 27) )
      {
        sub_1902D((__int64 *)(*(_QWORD *)(v54 + 40) + 32LL * v42), (int *)&v38, &v39);
        if ( v38 )
        {
          *(_DWORD *)size = (v38 >> 2) + (v38 & 3) != 0;
          v21 = (void **)&v59[4 * m];
          *v21 = malloc((v38 >> 2) + (v38 & 3) != 0);
          if ( !v59[4 * m] )
          {
            sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v22, a2);
            goto LABEL_188;
          }
          memcpy((void *)v59[4 * m], *(const void **)(32LL * v42 + *(_QWORD *)(v54 + 40)), *(unsigned int *)size);
          v23 = (signed __int64)&v59[4 * m];
          *(_QWORD *)(v23 + 16) = malloc(8LL * v39);
          if ( !v59[4 * m] )
          {
            sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v24, a2);
            goto LABEL_188;
          }
          memcpy((void *)v59[4 * m + 2], *(const void **)(32LL * v42 + *(_QWORD *)(v54 + 40) + 16), 8LL * v39);
          LOBYTE(v59[4 * m + 1]) = *(_BYTE *)(32LL * v42 + *(_QWORD *)(v54 + 40) + 8);
          sub_9EB54(
            (__int64)v53,
            *(_QWORD *)(v54 + 48),
            *(_QWORD *)(32LL * v42 + *(_QWORD *)(v54 + 40) + 24),
            *(_BYTE *)(32LL * v42 + *(_QWORD *)(v54 + 40) + 8),
            (void *)(*(_QWORD *)(v54 + 40) + 32LL * v42),
            18,
            &v59[4 * m + 3],
            0,
            a2);
        }
        ++*v52;
        ++v42;
        ++m;
      }
      if ( v37 != *v52 )
        __assert_fail("*old_size == size", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1574u, "resolve_uses");
    }
  }
  for ( l = 0; l < *(unsigned __int8 *)(a1 + 31); ++l )
  {
    v43 = sub_2245A(104LL * l + *(_QWORD *)(a1 + 120), a1, a2);
    if ( v43 )
      goto LABEL_188;
  }
  for ( l = 0; l < *(unsigned __int8 *)(a1 + 30); ++l )
  {
    *(_QWORD *)&size[4] = *((_QWORD *)ptr + l);
    v54 = *(_QWORD *)(a1 + 112) + 80LL * l;
    if ( *(_WORD *)(v54 + 24) & 3 && *(_WORD *)(*(_QWORD *)&size[4] + 24LL) & 3 )
    {
      for ( n = lys_parent(*(_QWORD *)&size[4]); n && *(_DWORD *)(n + 56) == 4096; n = lys_parent(n) )
        ;
      if ( n
        && *(_DWORD *)(n + 56) != 2048
        && *(_WORD *)(n + 24) & 3
        && ((unsigned __int8)*(_WORD *)(n + 24) ^ (unsigned __int8)*(_WORD *)(v54 + 24)) & 3
        && *(_WORD *)(v54 + 24) & 1 )
      {
        sub_13937(v53, 10, 2u, (char *)a1, (__int64)"config", (__int64)"refine", a2);
        sub_13937(
          v53,
          -1,
          5u,
          0LL,
          (__int64)"changing config from 'false' to 'true' is prohibited while the target's parent is still config 'false'.",
          v25);
        goto LABEL_188;
      }
      v45 = *(_QWORD *)(*(_QWORD *)&size[4] + 72LL);
      k = v45;
      while ( 2 )
      {
        if ( !k )
          goto LABEL_146;
        if ( *(_WORD *)(v54 + 24) & 1 )
        {
          if ( *(_WORD *)(k + 24) & 4 )
          {
            v45 = 0LL;
LABEL_139:
            if ( !v45 )
              v45 = *(_QWORD *)(k + 80);
            while ( !v45 )
            {
              k = lys_parent(k);
              if ( k == *(_QWORD *)&size[4] )
                break;
              v45 = *(_QWORD *)(k + 80);
            }
            k = v45;
            continue;
          }
        }
        else if ( *(_WORD *)(k + 24) & 4 && *(_WORD *)(k + 24) & 1 )
        {
          sub_13937(v53, 10, 2u, (char *)a1, (__int64)"config", (__int64)"refine", a2);
          sub_13937(
            v53,
            -1,
            5u,
            0LL,
            (__int64)"changing config from 'true' to 'false' is prohibited while the target has still a children with exp"
                     "licit config 'true'.",
            v26);
          goto LABEL_188;
        }
        break;
      }
      *(_WORD *)(k + 24) &= 0xFFFCu;
      *(_WORD *)(k + 24) |= *(_WORD *)(v54 + 24) & 3;
      if ( *(_DWORD *)(k + 56) & 0x802C )
        v45 = 0LL;
      else
        v45 = *(_QWORD *)(k + 72);
      goto LABEL_139;
    }
LABEL_146:
    if ( *(_BYTE *)(v54 + 31) && *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 2 )
    {
      v27 = *(_QWORD *)&size[4];
      *(_QWORD *)(v27 + 112) = sub_23C04(*(__int64 *)&size[4], **(_QWORD **)(v54 + 64));
      if ( !*(_QWORD *)(*(_QWORD *)&size[4] + 112LL) )
      {
        sub_13937(v53, 10, 2u, (char *)a1, **(_QWORD **)(v54 + 64), (__int64)"default", a2);
        goto LABEL_188;
      }
      if ( (unsigned int)sub_3C679(*(__int64 *)&size[4]) )
        goto LABEL_188;
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 16 && *(_DWORD *)(*(_QWORD *)&size[4] + 156LL) )
    {
      if ( *(_DWORD *)(*(_QWORD *)&size[4] + 152LL) > *(_DWORD *)(*(_QWORD *)&size[4] + 156LL) )
      {
        sub_13937(
          v53,
          -1,
          2u,
          (char *)a1,
          (__int64)"Invalid value \"%d\" of \"%s\".",
          *(unsigned int *)(v54 + 72),
          "min-elements");
        sub_13937(v53, -1, 5u, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v28, a2);
        goto LABEL_188;
      }
    }
    else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8
           && *(_DWORD *)(*(_QWORD *)&size[4] + 212LL)
           && *(_DWORD *)(*(_QWORD *)&size[4] + 208LL) > *(_DWORD *)(*(_QWORD *)&size[4] + 212LL) )
    {
      sub_13937(
        v53,
        -1,
        2u,
        (char *)a1,
        (__int64)"Invalid value \"%d\" of \"%s\".",
        *(unsigned int *)(v54 + 72),
        "min-elements");
      sub_13937(v53, -1, 5u, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v29, a2);
      goto LABEL_188;
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8 )
    {
      v56 = *(_QWORD *)&size[4];
      if ( *(_BYTE *)(*(_QWORD *)&size[4] + 30LL) && *(_DWORD *)(v56 + 208) )
      {
        if ( *(_BYTE *)(v54 + 31) )
          v30 = "default";
        else
          v30 = "min-elements";
        sub_13937(v53, 6, 2u, (char *)a1, (__int64)v30, (__int64)"refine", a2);
        sub_13937(
          v53,
          -1,
          5u,
          0LL,
          (__int64)"The \"min-elements\" statement with non-zero value is forbidden on leaf-lists with the \"default\" statement.",
          v31);
        goto LABEL_188;
      }
    }
    else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 4 )
    {
      v55 = *(_QWORD *)&size[4];
      if ( *(_QWORD *)(*(_QWORD *)&size[4] + 200LL) )
      {
        if ( *(_WORD *)(v55 + 24) & 0x40 )
        {
          if ( *(_BYTE *)(v54 + 31) )
            v32 = "default";
          else
            v32 = "mandatory";
          sub_13937(v53, 6, 2u, (char *)a1, (__int64)v32, (__int64)"refine", a2);
          sub_13937(
            v53,
            -1,
            5u,
            0LL,
            (__int64)"The \"mandatory\" statement is forbidden on leafs with the \"default\" statement.",
            v33);
          goto LABEL_188;
        }
      }
    }
    if ( *(_WORD *)(v54 + 24) & 0x40 || *(_DWORD *)(v54 + 72) )
    {
      for ( n = *(_QWORD *)(*(_QWORD *)&size[4] + 64LL);
            n && !(*(_DWORD *)(n + 56) & 0x5802) && (*(_DWORD *)(n + 56) != 1 || !*(_QWORD *)(n + 136));
            n = *(_QWORD *)(n + 64) )
      {
        ;
      }
      if ( n && *(_DWORD *)(n + 56) == 2 && *(_QWORD *)(n + 112) && (unsigned int)sub_3C679(n) )
        goto LABEL_188;
    }
  }
  free(ptr);
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000258B4) ----------------------------------------------------
__int64 __fastcall sub_258B4(__int128 a1)
{
  __int64 result; // rax
  signed int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 == 0 )
    __assert_fail(
      "der && base",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1618u,
      "resolve_identity_backlink_update");
  if ( !*(_QWORD *)(*((_QWORD *)&a1 + 1) + 64LL) )
    *(_QWORD *)(*((_QWORD *)&a1 + 1) + 64LL) = ly_set_new(a1);
  ly_set_add(*(_QWORD *)(*((_QWORD *)&a1 + 1) + 64LL), a1, 1LL);
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(*((_QWORD *)&a1 + 1) + 31LL);
    if ( i >= (signed int)result )
      break;
    sub_258B4(a1, *(_QWORD *)(8LL * i + *(_QWORD *)(*((_QWORD *)&a1 + 1) + 56LL)));
  }
  return result;
}
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (0000000000025971) ----------------------------------------------------
signed __int64 __fastcall sub_25971(__int64 a1, _QWORD *a2, char *a3, __int64 a4, signed __int64 *a5)
{
  signed __int64 *v6; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  char *s1; // [rsp+18h] [rbp-38h]
  unsigned int i; // [rsp+38h] [rbp-18h]
  unsigned int j; // [rsp+38h] [rbp-18h]
  unsigned int k; // [rsp+38h] [rbp-18h]
  unsigned int v12; // [rsp+3Ch] [rbp-14h]
  signed __int64 v13; // [rsp+40h] [rbp-10h]
  void *v14; // [rsp+48h] [rbp-8h]

  s1 = a3;
  v7 = a4;
  v6 = a5;
  v13 = 0LL;
  v14 = *(void **)a1;
  if ( !a5 )
    __assert_fail("ret", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1639u, "resolve_base_ident_sub");
  for ( i = 0; ; ++i )
  {
    if ( i >= *(unsigned __int16 *)(a1 + 72) )
    {
      v12 = 0;
LABEL_19:
      if ( v12 < *(unsigned __int8 *)(a1 + 70) && *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) )
      {
        for ( j = 0; ; ++j )
        {
          if ( j >= *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 72LL) )
          {
            ++v12;
            goto LABEL_19;
          }
          if ( !strcmp(
                  s1,
                  *(const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 120LL) + 72LL * j)) )
            break;
        }
        if ( !a2 )
        {
          *v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 120LL) + 72LL * j;
          return 0LL;
        }
        v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 120LL) + 72LL * j;
      }
      goto LABEL_21;
    }
    if ( !strcmp(s1, *(const char **)(*(_QWORD *)(a1 + 120) + 72LL * i)) )
      break;
  }
  if ( !a2 )
  {
    *v6 = *(_QWORD *)(a1 + 120) + 72LL * i;
    return 0LL;
  }
  v13 = *(_QWORD *)(a1 + 120) + 72LL * i;
LABEL_21:
  if ( !v13 )
    return 1LL;
  for ( k = 0; ; ++k )
  {
    if ( k >= *(_DWORD *)(v7 + 32) )
    {
      *v6 = v13;
      return 0LL;
    }
    if ( v13 == *(_QWORD *)(8LL * k + *(_QWORD *)v7) && *(_DWORD *)(4LL * k + *(_QWORD *)(v7 + 8)) == 256 )
      break;
  }
  if ( *(_QWORD *)(8LL * k + *(_QWORD *)(v7 + 16)) != *a2 )
    return 1LL;
  sub_13937(v14, 10, 0, 0LL, (__int64)s1, (__int64)"base");
  sub_13937(v14, -1, 0, 0LL, (__int64)"Circular reference of \"%s\" identity.", (__int64)s1);
  return 0xFFFFFFFFLL;
}

//----- (0000000000025CE3) ----------------------------------------------------
signed __int64 __fastcall sub_25CE3(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  char *v8; // rax
  __int64 v9; // r9
  __int16 v10; // dx
  const char *v11; // rax
  __int64 v12; // rsi
  unsigned __int8 v13; // al
  __int128 v14; // di
  __int64 v15; // [rsp+0h] [rbp-70h]
  __int64 v16; // [rsp+8h] [rbp-68h]
  __int64 v17; // [rsp+10h] [rbp-60h]
  char *s; // [rsp+18h] [rbp-58h]
  __int64 v19; // [rsp+20h] [rbp-50h]
  __int64 v20; // [rsp+28h] [rbp-48h]
  __int16 v21; // [rsp+36h] [rbp-3Ah]
  int v22; // [rsp+38h] [rbp-38h]
  unsigned int v23; // [rsp+3Ch] [rbp-34h]
  char v24; // [rsp+40h] [rbp-30h]
  char *v25; // [rsp+48h] [rbp-28h]
  signed __int64 *v26; // [rsp+50h] [rbp-20h]
  void **v27; // [rsp+58h] [rbp-18h]
  void *v28; // [rsp+60h] [rbp-10h]
  unsigned __int64 v29; // [rsp+68h] [rbp-8h]

  v19 = a2;
  s = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v29 = __readfsqword(0x28u);
  v22 = 0;
  v28 = *(void **)a1;
  if ( (!a2 || a5) && (a2 || !a5) )
    __assert_fail(
      "(ident && !type) || (!ident && type)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x168Fu,
      "resolve_base_ident");
  if ( a5 )
  {
    *(_QWORD *)(a5 + 32) = sub_C422(*(void **)(a5 + 32), 8LL * (unsigned int)++*(_DWORD *)(a5 + 40));
    if ( !*(_QWORD *)(v16 + 32) )
    {
      sub_12222((__int64)v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_base_ident", v6, v15);
      return 0xFFFFFFFFLL;
    }
    v26 = (signed __int64 *)(*(_QWORD *)(v16 + 32) + 8LL * (unsigned int)(*(_DWORD *)(v16 + 40) - 1));
    v21 = *(_WORD *)(*(_QWORD *)(v16 + 24) + 24LL);
    v27 = *(void ***)(*(_QWORD *)(v16 + 24) + 48LL);
  }
  else
  {
    v26 = (signed __int64 *)&v24;
    v21 = *(_WORD *)(a2 + 24);
    v27 = *(void ***)(a2 + 48);
  }
  *v26 = 0LL;
  v25 = strchr(s, 58);
  if ( v25 )
  {
    v22 = (_DWORD)v25++ - (_DWORD)s;
    if ( !strncmp(s, *(const char **)(a1 + 8), v22) && !*(_BYTE *)(*(_QWORD *)(a1 + 8) + v22) )
      v22 = 0;
  }
  else
  {
    v25 = s;
  }
  if ( v22 )
    v8 = s;
  else
    v8 = 0LL;
  v20 = sub_407F3((__int64 *)a1, 0LL, 0, v8, v22, 0);
  if ( v20 )
  {
    v23 = sub_25971(v20, (_QWORD *)a2, v25, v15, v26);
    if ( v23 )
    {
      if ( v23 == 1 )
      {
        sub_13937(v28, 36, 0, 0LL, v17, (__int64)s, v15);
        if ( v16 )
          --*(_DWORD *)(v16 + 40);
      }
    }
    else
    {
      if ( !*v26 )
        __assert_fail("*ret", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x16BCu, "resolve_base_ident");
      v10 = *(_WORD *)(*v26 + 24);
      if ( a2 )
        v11 = *(const char **)a2;
      else
        v11 = "of type";
      if ( (unsigned int)sub_3C749(v21, v27, (__int64)v11, v10, *(_QWORD *)(*v26 + 48), *(_QWORD *)*v26, 0LL) )
      {
        v23 = -1;
      }
      else if ( a2 )
      {
        v12 = *(_QWORD *)(a2 + 56);
        v13 = *(_BYTE *)(v19 + 31);
        *(_BYTE *)(v19 + 31) = v13 + 1;
        *(_QWORD *)(v12 + 8LL * v13) = *v26;
        if ( *(_BYTE *)(lys_main_module(v27) + 64) & 0x80 )
        {
          *((_QWORD *)&v14 + 1) = *v26;
          *(_QWORD *)&v14 = v19;
          sub_258B4(v14);
        }
      }
    }
    result = v23;
  }
  else
  {
    sub_13937(v28, 28, 0, 0LL, (__int64)s, v9, v15);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000260D0) ----------------------------------------------------
signed __int64 __fastcall sub_260D0(__int64 a1, __int64 a2)
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 == a2 )
    return 1LL;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 31); ++i )
  {
    if ( (unsigned int)sub_260D0(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 56)), a2) == 1 )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000026148) ----------------------------------------------------
__int64 __fastcall sub_26148(signed __int64 a1, char *a2, char *a3, __int64 *a4, int a5)
{
  __int64 result; // rax
  unsigned int v6; // ecx
  unsigned int v7; // esi
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // esi
  __int64 v11; // r9
  unsigned int v12; // esi
  __int64 v13; // rax
  unsigned int v14; // esi
  __int64 v15; // rdi
  __int64 v16; // r12
  __int64 v17; // rbx
  int *v18; // rax
  __int64 v19; // rax
  int v20; // [rsp+Ch] [rbp-A4h]
  __int64 *v21; // [rsp+10h] [rbp-A0h]
  char *v22; // [rsp+18h] [rbp-98h]
  char *s; // [rsp+20h] [rbp-90h]
  signed __int64 v24; // [rsp+28h] [rbp-88h]
  int v25; // [rsp+38h] [rbp-78h]
  char v26; // [rsp+3Ch] [rbp-74h]
  int v27; // [rsp+40h] [rbp-70h]
  unsigned int i; // [rsp+44h] [rbp-6Ch]
  unsigned int j; // [rsp+48h] [rbp-68h]
  int v30; // [rsp+4Ch] [rbp-64h]
  char *s1; // [rsp+50h] [rbp-60h]
  char *s2; // [rsp+58h] [rbp-58h]
  __int64 v33; // [rsp+60h] [rbp-50h]
  __int64 v34; // [rsp+68h] [rbp-48h]
  __int64 v35; // [rsp+70h] [rbp-40h]
  __int64 v36; // [rsp+78h] [rbp-38h]
  __int64 v37; // [rsp+80h] [rbp-30h]
  void *ptr; // [rsp+88h] [rbp-28h]
  __int64 v39; // [rsp+90h] [rbp-20h]
  unsigned __int64 v40; // [rsp+98h] [rbp-18h]

  v24 = a1;
  s = a2;
  v22 = a3;
  v21 = a4;
  v20 = a5;
  v40 = __readfsqword(0x28u);
  v27 = 0;
  v34 = 0LL;
  if ( !a1 || !a2 || !a4 )
    __assert_fail(
      "type && ident_name && mod",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1702u,
      "resolve_identref");
  v35 = *a4;
  if ( !a1 || !*(_DWORD *)(a1 + 40) && !*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL) || !a2 )
    return 0LL;
  v30 = sub_16637(a2, &s1, (unsigned int *)&v25, &s2, (unsigned int *)&v26, 0LL, 0);
  if ( v30 > 0 )
  {
    v8 = strlen(a2);
    if ( v30 >= v8 )
    {
      v36 = lys_main_module(v21);
      if ( s1 && (strncmp(s1, *(const char **)(v36 + 8), v25) || *(_BYTE *)(*(_QWORD *)(v36 + 8) + v25)) )
      {
        if ( v20 )
        {
          for ( i = 0; i < *((unsigned __int8 *)v21 + 69); ++i )
          {
            if ( !strncmp(s1, *(const char **)(*(_QWORD *)(v21[12] + 56LL * i) + 8LL), v25)
              && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v21[12] + 56LL * i) + 8LL) + v25) )
            {
              v34 = *(_QWORD *)(v21[12] + 56LL * i);
              break;
            }
          }
          if ( !v34 && a1 && *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL) )
          {
            v37 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL);
            for ( i = 0; i < *(unsigned __int8 *)(v37 + 69); ++i )
            {
              if ( !strncmp(s1, *(const char **)(*(_QWORD *)(*(_QWORD *)(v37 + 96) + 56LL * i) + 8LL), v25)
                && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v37 + 96) + 56LL * i) + 8LL) + v25) )
              {
                v34 = *(_QWORD *)(*(_QWORD *)(v37 + 96) + 56LL * i);
                break;
              }
            }
          }
          if ( !v34 )
          {
            ptr = strndup(s1, v25);
            v34 = ly_ctx_get_module(v35, ptr, 0LL, 1LL);
            free(ptr);
          }
        }
        else
        {
          for ( i = 0; i < *(_DWORD *)(*v21 + 60); ++i )
          {
            v34 = *(_QWORD *)(8LL * i + *(_QWORD *)(*v21 + 64));
            if ( !strncmp(s1, *(const char **)(v34 + 8), v25) && !*(_BYTE *)(*(_QWORD *)(v34 + 8) + v25) )
              break;
            v34 = 0LL;
          }
          if ( !v34 && *(_BYTE *)(*v21 + 88) )
          {
            for ( i = 0; i < *(unsigned __int8 *)(*v21 + 88); ++i )
            {
              v34 = *(_QWORD *)(8LL * i + *(_QWORD *)(*v21 + 72));
              if ( !(*(_BYTE *)(v34 + 64) & 1) )
              {
                if ( !strncmp(s1, *(const char **)(v34 + 8), v25) && !*(_BYTE *)(*(_QWORD *)(v34 + 8) + v25) )
                  break;
                v34 = 0LL;
              }
            }
          }
        }
      }
      else
      {
        v34 = v36;
      }
      if ( !v20 && (!v34 || *(_BYTE *)(v34 + 64) >= 0) && *(_QWORD *)(v35 + 112) )
      {
        if ( v34 )
        {
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v35 + 112))(
            v35,
            *(_QWORD *)(v34 + 8),
            *(_QWORD *)(v34 + 176),
            1LL,
            *(_QWORD *)(v35 + 120));
        }
        else if ( s1 )
        {
          ptr = strndup(s1, v25);
          v34 = (*(__int64 (__fastcall **)(__int64, void *, _QWORD, _QWORD, _QWORD))(v35 + 112))(
                  v35,
                  ptr,
                  0LL,
                  0LL,
                  *(_QWORD *)(v35 + 120));
          free(ptr);
        }
      }
      if ( v34 )
      {
        if ( v36 == v34 && v21 == (__int64 *)lys_main_module(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48LL))
          || *(_BYTE *)(v34 + 64) < 0 )
        {
          while ( *(_QWORD *)(v24 + 16) )
          {
            for ( i = 0; i < *(_DWORD *)(v24 + 40); ++i )
            {
              v33 = *(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 32));
              if ( *(_QWORD *)(v33 + 64) )
              {
                for ( j = 0; j < *(_DWORD *)(*(_QWORD *)(v33 + 64) + 4LL); ++j )
                {
                  v39 = *(_QWORD *)(8LL * j + *(_QWORD *)(*(_QWORD *)(v33 + 64) + 8LL));
                  if ( !strcmp(*(const char **)v39, s2) )
                  {
                    v13 = lys_main_module(*(_QWORD *)(v39 + 48));
                    if ( v34 == v13 )
                    {
                      v33 = v39;
LABEL_111:
                      for ( i = 0; i < *(unsigned __int8 *)(v33 + 27); ++i )
                      {
                        if ( !(unsigned int)sub_18D14(32LL * i + *(_QWORD *)(v33 + 40)) )
                        {
                          if ( v22 )
                            sub_13937((void *)v35, 50, 3u, v22, *(_QWORD *)v33, **(_QWORD **)v22);
                          sub_13937(
                            (void *)v35,
                            -1,
                            5u,
                            0LL,
                            (__int64)"Identity \"%s\" is disabled by its if-feature condition.",
                            *(_QWORD *)v33);
                          return 0LL;
                        }
                      }
                      if ( v27 )
                      {
                        if ( !v20 )
                        {
                          v19 = lys_main_module(*(_QWORD *)(v33 + 48));
                          sub_13937(
                            (void *)v35,
                            -1,
                            0,
                            0LL,
                            (__int64)"Identity found, but in a non-implemented module \"%s\".",
                            *(_QWORD *)(v19 + 8));
                          goto LABEL_107;
                        }
                        sub_12222(
                          0LL,
                          2u,
                          0,
                          "Making \"%s\" module implemented because of identityref default value \"%s\" used in the imple"
                          "mented \"%s\" module",
                          *(_QWORD *)(v34 + 8),
                          *(_QWORD *)v33,
                          v21[1]);
                        v15 = v34;
                        if ( (unsigned int)lys_set_implemented(v34) )
                        {
                          v16 = *(_QWORD *)v33;
                          v17 = *(_QWORD *)(v34 + 8);
                          v18 = (int *)ly_errno_glob_address(v15);
                          sub_12222(
                            v35,
                            0,
                            *v18,
                            "Setting the module \"%s\" implemented because of used default identity \"%s\" failed.",
                            v17,
                            v16);
                          goto LABEL_107;
                        }
                      }
                      return v33;
                    }
                  }
                }
              }
            }
            v24 = *(_QWORD *)(v24 + 16) + 56LL;
          }
        }
        else
        {
          v33 = 0LL;
          for ( i = 0; i < *(unsigned __int16 *)(v34 + 72); ++i )
          {
            if ( !strcmp(s2, *(const char **)(*(_QWORD *)(v34 + 120) + 72LL * i)) )
            {
              v33 = *(_QWORD *)(v34 + 120) + 72LL * i;
              break;
            }
          }
          if ( v33 )
            goto LABEL_126;
          for ( j = 0; j < *(unsigned __int8 *)(v34 + 70); ++j )
          {
            for ( i = 0; i < *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 72LL); ++i )
            {
              if ( !strcmp(
                      s2,
                      *(const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 120LL) + 72LL * i)) )
              {
                v33 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 120LL) + 72LL * i;
                break;
              }
            }
          }
          if ( v33 )
          {
LABEL_126:
            while ( *(_QWORD *)(v24 + 16) )
            {
              for ( i = 0; i < *(_DWORD *)(v24 + 40); ++i )
              {
                if ( (unsigned int)sub_260D0(v33, *(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 32))) )
                {
                  v27 = 1;
                  goto LABEL_111;
                }
              }
              v24 = *(_QWORD *)(v24 + 16) + 56LL;
            }
            if ( v22 )
              v12 = 3;
            else
              v12 = 0;
            sub_13937((void *)v35, -1, v12, v22, (__int64)"Identity used as identityref value is not implemented.", v11);
          }
        }
      }
LABEL_107:
      if ( v22 )
        v14 = 3;
      else
        v14 = 0;
      sub_13937((void *)v35, 36, v14, v22, (__int64)"identityref", (__int64)s);
      result = 0LL;
    }
    else
    {
      v9 = a2[v30];
      if ( v22 )
        v10 = 3;
      else
        v10 = 0;
      sub_13937((void *)v35, 55, v10, v22, v9, (__int64)&s[v30]);
      result = 0LL;
    }
  }
  else
  {
    v6 = a2[-v30];
    if ( v22 )
      v7 = 3;
    else
      v7 = 0;
    sub_13937((void *)v35, 55, v7, v22, v6, (__int64)&s[-v30]);
    result = 0LL;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 74B0: using guessed type __int64 __fastcall lys_set_implemented(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000026D87) ----------------------------------------------------
signed __int64 __fastcall sub_26D87(_BYTE **a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  signed __int64 result; // rax
  int v5; // [rsp+1Ch] [rbp-14h]
  unsigned int v6; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  void *v8; // [rsp+28h] [rbp-8h]

  v8 = *(void **)a1[6];
  for ( i = lys_parent(a1); i && *(_DWORD *)(i + 56) != 2048; i = lys_parent(i) )
    ;
  if ( i && *(_BYTE **)i == *a1 )
  {
    sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
    return 0xFFFFFFFFLL;
  }
  if ( a1[16] )
    goto LABEL_40;
  v5 = sub_1B28A(*a1, (__int64)a1, (__int64 *)a1 + 16);
  if ( v5 == -1 )
  {
    sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
    return 0xFFFFFFFFLL;
  }
  if ( v5 > 0 )
  {
    sub_13937(v8, 55, 2u, (char *)a1, (unsigned int)(char)(*a1)[v5 - 1], (__int64)&(*a1)[v5 - 1], a2);
    return 0xFFFFFFFFLL;
  }
  if ( a1[16] )
  {
LABEL_40:
    if ( *((_WORD *)a1[16] + 14) )
    {
      if ( !i || (_WORD)a1[3] & 1 )
      {
        a1[16] = 0LL;
      }
      else
      {
        if ( !++*(_WORD *)(i + 28) )
        {
          sub_12222((__int64)v8, 0, 4, "Too many unresolved items (uses) inside a grouping.", v2, v3, a2);
          return 0xFFFFFFFFLL;
        }
        *((_WORD *)a1 + 12) |= 1u;
      }
      sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
      result = 1LL;
    }
    else
    {
      v6 = sub_23C91((__int64)a1, a2);
      if ( v6 )
      {
        result = v6;
      }
      else
      {
        if ( i && (_WORD)a1[3] & 1 )
        {
          if ( !*(_WORD *)(i + 28) )
            __assert_fail(
              "((struct lys_node_grp *)par_grp)->unres_count",
              "/home/mantovan/Repositories/libyang/src/resolve.c",
              0x17FFu,
              "resolve_unres_schema_uses");
          --*(_WORD *)(i + 28);
          *((_WORD *)a1 + 12) &= 0xFFFEu;
        }
        if ( (unsigned int)sub_3C749(
                             *((_WORD *)a1 + 12),
                             (void **)a1[6],
                             (__int64)"of uses",
                             *((_WORD *)a1[16] + 12),
                             *((_QWORD *)a1[16] + 6),
                             *(_QWORD *)a1[16],
                             (char *)a1) )
          result = 0xFFFFFFFFLL;
        else
          result = 0LL;
      }
    }
  }
  else
  {
    if ( i && !((_WORD)a1[3] & 1) )
    {
      if ( !++*(_WORD *)(i + 28) )
      {
        sub_12222((__int64)v8, 0, 4, "Too many unresolved items (uses) inside a grouping.", v2, v3, a2);
        return 0xFFFFFFFFLL;
      }
      *((_WORD *)a1 + 12) |= 1u;
    }
    sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
    result = 1LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000271C8) ----------------------------------------------------
signed __int64 __fastcall sub_271C8(__int64 a1, char *a2)
{
  const char ***v3; // rbx
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  void *ptr; // ST40_8
  char *s; // [rsp+0h] [rbp-50h]
  int i; // [rsp+1Ch] [rbp-34h]
  int v10; // [rsp+20h] [rbp-30h]
  char *v11; // [rsp+28h] [rbp-28h]
  void *v12; // [rsp+38h] [rbp-18h]

  s = a2;
  v12 = **(void ***)(a1 + 48);
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 30); ++i )
  {
    if ( !s )
      __assert_fail("keys_str", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1822u, "resolve_list_keys");
    if ( !*(_QWORD *)(a1 + 72) )
    {
      sub_13937(v12, 36, 2u, (char *)a1, (__int64)"list keys", (__int64)s, s);
      return 1LL;
    }
    v11 = strpbrk(s, accept);
    if ( v11 )
    {
      v10 = (_DWORD)v11 - (_DWORD)s;
      while ( (*__ctype_b_loc())[*v11] & 0x2000 )
        ++v11;
    }
    else
    {
      v10 = strlen(s);
    }
    v3 = (const char ***)(*(_QWORD *)(a1 + 136) + 8LL * i);
    v4 = lys_node_module(a1);
    if ( (unsigned int)sub_9B536(v4, a1, s, v10, 4, 0x100u, v3) )
    {
      sub_13937(v12, 36, 2u, (char *)a1, (__int64)"list key", (__int64)s, s);
      return 1LL;
    }
    if ( (unsigned int)sub_1F3F0(a1, i, s, v10, v5, v6) )
      return 0xFFFFFFFFLL;
    if ( (unsigned int)sub_3C749(
                         *(_WORD *)(a1 + 24),
                         *(void ***)(a1 + 48),
                         *(_QWORD *)a1,
                         *(_WORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 24LL),
                         *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 48LL),
                         **(_QWORD **)(8LL * i + *(_QWORD *)(a1 + 136)),
                         *(char **)(8LL * i + *(_QWORD *)(a1 + 136))) )
      return 0xFFFFFFFFLL;
    if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 200LL) )
    {
      if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
        __assert_fail(
          "log_opt == ILO_STORE",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x184Bu,
          "resolve_list_keys");
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = 0;
      ptr = (void *)lys_path(a1, 1LL);
      sub_12222(
        (__int64)v12,
        1u,
        0,
        "Default value \"%s\" in the list key \"%s\" is ignored. (%s)",
        *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 200LL),
        **(_QWORD **)(8LL * i + *(_QWORD *)(a1 + 136)),
        ptr);
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = 1;
      free(ptr);
    }
    while ( v11 && (*__ctype_b_loc())[*v11] & 0x2000 )
      ++v11;
    s = v11;
  }
  return 0LL;
}
// 75D0: using guessed type __int64 __fastcall __tls_get_addr(_QWORD);
// 7680: using guessed type __int64 __fastcall lys_path(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (00000000000275C3) ----------------------------------------------------
signed __int64 __fastcall sub_275C3(char *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // eax
  void **v5; // rax
  __int64 *v6; // rax
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned __int64 v11; // [rsp+0h] [rbp-80h]
  char *v12; // [rsp+8h] [rbp-78h]
  unsigned __int8 j; // [rsp+16h] [rbp-6Ah]
  unsigned __int8 v14; // [rsp+17h] [rbp-69h]
  __int64 i; // [rsp+18h] [rbp-68h]
  __int64 v16; // [rsp+20h] [rbp-60h]
  void *v17; // [rsp+28h] [rbp-58h]
  char s; // [rsp+30h] [rbp-50h]
  int v19; // [rsp+40h] [rbp-40h]
  unsigned __int64 v20; // [rsp+78h] [rbp-8h]

  v12 = a1;
  v11 = __PAIR__(a2, a3);
  v20 = __readfsqword(0x28u);
  v17 = **(void ***)(*(_QWORD *)a1 + 48LL);
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x186Fu, "resolve_must");
  memset(&s, 0, 0x40uLL);
  if ( a2 )
  {
    for ( i = lys_parent(*(_QWORD *)a1); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
      ;
    if ( !i || !(*(_DWORD *)(i + 56) & 0x600) )
    {
      sub_12222(
        (__int64)v17,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        6263LL,
        v11);
      return 0xFFFFFFFFLL;
    }
    v14 = *(_BYTE *)(i + 29);
    v16 = *(_QWORD *)(i + 112);
    v12 = (char *)*((_QWORD *)a1 + 5);
    if ( !(*(_DWORD *)(*(_QWORD *)v12 + 56LL) & 0x4100) )
    {
      sub_12222(
        (__int64)v17,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        6272LL,
        v11);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_30;
  }
  v4 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v4 == 16 )
  {
    v14 = *(_BYTE *)(*(_QWORD *)a1 + 28LL);
    v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
  }
  else if ( v4 > 0x10 )
  {
    if ( v4 == 128 )
    {
      v14 = *(_BYTE *)(*(_QWORD *)a1 + 29LL);
      v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
    }
    else
    {
      if ( v4 != 32800 && v4 != 32 )
        goto LABEL_29;
      v14 = *(_BYTE *)(*(_QWORD *)a1 + 31LL);
      v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
    }
  }
  else
  {
    switch ( v4 )
    {
      case 4u:
        v14 = *(_BYTE *)(*(_QWORD *)a1 + 31LL);
        v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
        break;
      case 8u:
        v14 = *(_BYTE *)(*(_QWORD *)a1 + 31LL);
        v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
        break;
      case 1u:
        v14 = *(_BYTE *)(*(_QWORD *)a1 + 29LL);
        v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
        break;
      default:
LABEL_29:
        v14 = 0;
        break;
    }
  }
LABEL_30:
  for ( j = 0; ; ++j )
  {
    if ( j >= v14 )
      return 0LL;
    v5 = (void **)lyd_node_module(v12);
    if ( (unsigned int)sub_DC4B2(*(const char **)(56LL * j + v16), v12, 2, v5, &s, 1LL) )
      return 0xFFFFFFFFLL;
    v6 = (__int64 *)lyd_node_module(v12);
    sub_DC765((__int64)&s, 3, (__int64)v12, v6, 1);
    if ( !v19 )
      break;
LABEL_43:
    ;
  }
  if ( (_DWORD)v11 == 1 || *(_WORD *)(56LL * j + v16 + 50) & 0x600 && (_DWORD)v11 == 2 )
  {
    sub_12222(
      0LL,
      2u,
      0,
      "Must condition \"%s\" not satisfied, but it is not required.",
      *(_QWORD *)(56LL * j + v16),
      v7,
      v11);
    goto LABEL_43;
  }
  sub_13937(v17, 58, 3u, v12, *(_QWORD *)(56LL * j + v16), v7, v11);
  if ( *(_QWORD *)(56LL * j + v16 + 32) )
    sub_13C4A(v17, 5, *(char **)(56LL * j + v16 + 32), v8, v9, v10);
  if ( *(_QWORD *)(56LL * j + v16 + 24) )
    sub_14407((__int64)v17, *(const char **)(56LL * j + v16 + 24));
  return 1LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (0000000000027A8D) ----------------------------------------------------
__int64 *__fastcall sub_27A8D(__int64 a1, __int64 *a2, _DWORD *a3)
{
  __int64 v3; // rax
  __int64 *result; // rax
  __int64 v5; // [rsp+18h] [rbp-18h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a1;
  *a3 = 2;
  while ( *(_DWORD *)(v5 + 56) & 0x3642 )
  {
    if ( *(_DWORD *)(v5 + 56) == 0x2000 )
      v6 = *(_QWORD *)(v5 + 88);
    else
      v6 = *(_QWORD *)(v5 + 64);
    if ( !v6 )
    {
      if ( *(_WORD *)(v5 + 24) & 1 )
        *a3 = 1;
      else
        *a3 = 0;
      v3 = lys_node_module(v5);
      v5 = lys_getnext(0LL, 0LL, v3, 256LL);
      break;
    }
    v5 = v6;
  }
  result = a2;
  *a2 = v5;
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000027B5A) ----------------------------------------------------
signed __int64 __fastcall sub_27B5A(_QWORD *a1, __int64 a2, _QWORD *a3, _DWORD *a4)
{
  __int64 v4; // rax
  _DWORD *v6; // [rsp+0h] [rbp-50h]
  _QWORD *v7; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+10h] [rbp-40h]
  _QWORD *v9; // [rsp+18h] [rbp-38h]
  unsigned __int16 i; // [rsp+2Eh] [rbp-22h]
  unsigned __int16 v11; // [rsp+30h] [rbp-20h]
  unsigned __int16 v12; // [rsp+32h] [rbp-1Eh]
  int v13; // [rsp+34h] [rbp-1Ch]
  _QWORD *v14; // [rsp+38h] [rbp-18h]
  __int64 v15; // [rsp+40h] [rbp-10h]
  unsigned __int64 v16; // [rsp+48h] [rbp-8h]

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v16 = __readfsqword(0x28u);
  sub_27A8D(a2, &v8, &v13);
  if ( v13 == 2 )
  {
    v14 = v9;
    v11 = 0;
    while ( v14 )
    {
      v14 = (_QWORD *)v14[5];
      ++v11;
    }
    v15 = v8;
    v12 = 0;
    while ( v15 )
    {
      if ( *(_DWORD *)(v15 + 56) & 0x81BD )
        ++v12;
      if ( *(_DWORD *)(v15 + 56) == 0x2000 )
        v4 = *(_QWORD *)(v15 + 88);
      else
        v4 = *(_QWORD *)(v15 + 64);
      v15 = v4;
    }
    if ( v11 < v12 )
      return 0xFFFFFFFFLL;
    for ( i = 0; i < v11 - v12; ++i )
      v9 = (_QWORD *)v9[5];
    if ( *v9 != v8 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    while ( v9[5] )
      v9 = (_QWORD *)v9[5];
    while ( *(_QWORD *)(v9[4] + 24LL) )
      v9 = (_QWORD *)v9[4];
  }
  *v7 = v9;
  *v6 = v13;
  return 0LL;
}

//----- (0000000000027CDB) ----------------------------------------------------
signed __int64 __fastcall sub_27CDB(__int64 a1, __int64 *a2, __int64 *a3, unsigned int a4, __int64 a5)
{
  unsigned int v5; // eax
  __int64 i; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  char v12; // al
  __int64 v13; // [rsp+8h] [rbp-48h]
  unsigned int v14; // [rsp+14h] [rbp-3Ch]
  __int64 *v15; // [rsp+18h] [rbp-38h]
  _QWORD *v16; // [rsp+30h] [rbp-20h]
  _QWORD *j; // [rsp+38h] [rbp-18h]
  __int64 v18; // [rsp+40h] [rbp-10h]
  __int64 v19; // [rsp+48h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v19 = **(_QWORD **)(a1 + 48);
  v5 = *(_DWORD *)(a1 + 56);
  if ( v5 != 16 )
  {
    if ( v5 <= 0x10 )
    {
      if ( v5 != 2 )
      {
        if ( v5 > 2 )
        {
          if ( v5 != 4 && v5 != 8 )
            goto LABEL_49;
        }
        else if ( v5 != 1 )
        {
LABEL_49:
          sub_12222(
            v19,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            6527LL);
          return 0xFFFFFFFFLL;
        }
        goto LABEL_25;
      }
LABEL_18:
      for ( i = lys_getnext(0LL, a1, 0LL, 128LL); ; i = lys_getnext(v18, a1, 0LL, 128LL) )
      {
        v18 = i;
        if ( !i )
          break;
        if ( !(*(_DWORD *)(i + 56) & 0x4080) && (unsigned int)sub_27CDB(i, a2, v15, v14, v13) )
          return 0xFFFFFFFFLL;
      }
      return 0LL;
    }
    if ( v5 == 4096 )
      goto LABEL_18;
    if ( v5 > 0x1000 )
    {
      if ( v5 == 0x2000 )
        goto LABEL_18;
      if ( v5 != 32800 )
        goto LABEL_49;
    }
    else if ( v5 != 32 )
    {
      if ( v5 != 64 )
        goto LABEL_49;
      goto LABEL_18;
    }
  }
LABEL_25:
  for ( j = (_QWORD *)lyd_first_sibling(*a2); ; j = v16 )
  {
    if ( j )
    {
      v16 = (_QWORD *)j[3];
      v12 = 1;
    }
    else
    {
      v12 = 0;
    }
    if ( !v12 )
      break;
    if ( a1 == *j )
    {
      if ( j == (_QWORD *)*v15 )
      {
        if ( v14 == 2 )
        {
          sub_12222(
            v19,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            6484LL);
          return 0xFFFFFFFFLL;
        }
        if ( j == (_QWORD *)j[4] )
        {
          *v15 = 0LL;
        }
        else
        {
          v8 = j[4];
          *v15 = v8;
        }
      }
      else if ( j == (_QWORD *)*a2 )
      {
        v8 = *(_QWORD *)(*a2 + 32);
        if ( v8 == *a2 )
        {
          *a2 = 0LL;
        }
        else
        {
          v8 = *(_QWORD *)(*a2 + 32);
          *a2 = v8;
        }
      }
      sub_BA11B(j, 0, v8, v9, v10, v11);
      if ( *(_QWORD *)v13 )
      {
        if ( (unsigned int)lyd_insert_after(*(_QWORD *)(*(_QWORD *)v13 + 32LL), j) )
        {
          sub_12222(
            v19,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            6512LL);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        v8 = (__int64)j;
        *(_QWORD *)v13 = j;
      }
      if ( *(_DWORD *)(a1 + 56) & 0x8025 )
        return 0LL;
    }
  }
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7310: using guessed type __int64 __fastcall lyd_insert_after(_QWORD, _QWORD);
// 77E0: using guessed type __int64 __fastcall lyd_first_sibling(_QWORD);

//----- (0000000000027FD3) ----------------------------------------------------
signed __int64 __fastcall sub_27FD3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  char v9; // al
  int v10; // [rsp+Ch] [rbp-24h]
  __int64 *v11; // [rsp+10h] [rbp-20h]
  __int64 *i; // [rsp+28h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  for ( i = a2; ; i = v11 )
  {
    if ( i )
    {
      v11 = (__int64 *)i[3];
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( !v9 )
      break;
    sub_BA11B(i, 0, a3, a4, a5, a6);
    if ( v10 == 2 )
    {
      if ( (unsigned int)sub_B70F6(a1, 0LL, i, 0LL, v6, v7) )
        return 0xFFFFFFFFLL;
    }
    else if ( (unsigned int)sub_B7B96(a1, i, 0, 0) )
    {
      return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (0000000000028087) ----------------------------------------------------
__int64 __fastcall sub_28087(_QWORD *a1)
{
  unsigned int v1; // eax
  char v3; // [rsp+1Bh] [rbp-15h]
  unsigned int v4; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  _BYTE *v6; // [rsp+28h] [rbp-8h]

  v4 = 0;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x19ADu, "resolve_applies_must");
  v6 = (_BYTE *)*a1;
  v1 = *(_DWORD *)(*a1 + 56LL);
  if ( v1 == 16 )
  {
    v3 = v6[28];
    goto LABEL_20;
  }
  if ( v1 > 0x10 )
  {
    if ( v1 == 128 )
    {
      v3 = v6[29];
      goto LABEL_20;
    }
    if ( v1 == 32800 || v1 == 32 )
    {
      v3 = v6[31];
      goto LABEL_20;
    }
  }
  else
  {
    switch ( v1 )
    {
      case 4u:
        v3 = v6[31];
        goto LABEL_20;
      case 8u:
        v3 = v6[31];
        goto LABEL_20;
      case 1u:
        v3 = v6[29];
        goto LABEL_20;
    }
  }
  v3 = 0;
LABEL_20:
  if ( v3 )
    v4 = 1;
  if ( !*(_QWORD *)(a1[4] + 24LL) )
  {
    for ( i = lys_parent(v6); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
      ;
    if ( i && *(_DWORD *)(i + 56) & 0x600 )
      v4 += 2;
  }
  return v4;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000281C9) ----------------------------------------------------
__int64 __fastcall sub_281C9(__int64 a1)
{
  unsigned int v1; // eax

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 == 16 )
    return *(_QWORD *)(a1 + 112);
  if ( v1 <= 0x10 )
  {
    if ( v1 == 2 )
      return *(_QWORD *)(a1 + 104);
    if ( v1 > 2 )
    {
      if ( v1 == 4 )
        return *(_QWORD *)(a1 + 112);
      if ( v1 == 8 )
        return *(_QWORD *)(a1 + 112);
    }
    else if ( v1 == 1 )
    {
      return *(_QWORD *)(a1 + 112);
    }
    return 0LL;
  }
  if ( v1 == 4096 )
    return *(_QWORD *)(a1 + 104);
  if ( v1 <= 0x1000 )
  {
    if ( v1 != 32 )
    {
      if ( v1 == 64 )
        return *(_QWORD *)(a1 + 104);
      return 0LL;
    }
    return *(_QWORD *)(a1 + 112);
  }
  if ( v1 == 0x2000 )
    return *(_QWORD *)(a1 + 80);
  if ( v1 == 32800 )
    return *(_QWORD *)(a1 + 112);
  return 0LL;
}

//----- (0000000000028290) ----------------------------------------------------
signed __int64 __fastcall sub_28290(__int64 a1, int a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 )
    __assert_fail("schema", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x19FBu, "resolve_applies_when");
  if ( !(*(_DWORD *)(a1 + 56) & 0x180) && sub_281C9(a1) )
    return 1LL;
  v5 = a1;
  while ( 1 )
  {
    if ( *(_QWORD *)(v5 + 64) && *(_DWORD *)(*(_QWORD *)(v5 + 64) + 56LL) == 0x2000 && sub_281C9(*(_QWORD *)(v5 + 64)) )
      return 1LL;
    v5 = lys_parent(v5);
    if ( !v5 )
      break;
    if ( a2 )
    {
      if ( v5 == v4 )
        return 0LL;
    }
    else if ( !(*(_DWORD *)(v5 + 56) & 0x1042) )
    {
      return 0LL;
    }
    if ( sub_281C9(v5) )
      return 1LL;
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (0000000000028399) ----------------------------------------------------
__int64 __fastcall sub_28399(__int64 a1, int a2, __int64 *a3)
{
  void **v3; // rbx
  const char **v4; // rax
  __int64 *v5; // rax
  __int64 v6; // r9
  __int64 *v7; // rax
  __int64 *v8; // rax
  __int64 v9; // r9
  __int64 *v10; // rax
  __int64 v11; // r9
  __int64 *v12; // rax
  void **v13; // r13
  int v14; // er12
  char *v15; // rbx
  const char **v16; // rax
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 *v19; // rax
  __int64 v20; // r9
  __int64 *v21; // rax
  __int64 *v22; // rax
  __int64 v23; // r9
  __int64 *v24; // rax
  __int64 v25; // r9
  __int64 *v26; // rax
  void **v27; // r13
  int v28; // er12
  char *v29; // rbx
  const char **v30; // rax
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 *v33; // rax
  __int64 v34; // r9
  __int64 *v35; // rax
  __int64 *v36; // rax
  __int64 v37; // r9
  __int64 *v38; // rax
  __int64 v39; // r9
  __int64 *v40; // rax
  __int64 v41; // rax
  __int64 *v43; // [rsp+8h] [rbp-B8h]
  unsigned int v44; // [rsp+20h] [rbp-A0h]
  char v45[12]; // [rsp+24h] [rbp-9Ch]
  __int64 *v46; // [rsp+30h] [rbp-90h]
  __int64 v47; // [rsp+38h] [rbp-88h]
  __int64 v48; // [rsp+40h] [rbp-80h]
  void *v49; // [rsp+48h] [rbp-78h]
  char s; // [rsp+50h] [rbp-70h]
  int v51; // [rsp+60h] [rbp-60h]
  unsigned __int64 v52; // [rsp+98h] [rbp-28h]

  v43 = a3;
  v52 = __readfsqword(0x28u);
  *(_QWORD *)&v45[4] = 0LL;
  v49 = **(void ***)(*(_QWORD *)a1 + 48LL);
  *(_DWORD *)v45 = 0;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1A38u, "resolve_when");
  memset(&s, 0, 0x40uLL);
  if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x4180 || !sub_281C9(*(_QWORD *)a1) )
    goto LABEL_16;
  *(_BYTE *)(a1 + 8) |= 0x80u;
  v3 = (void **)lyd_node_module(a1);
  v4 = (const char **)sub_281C9(*(_QWORD *)a1);
  *(_DWORD *)v45 = sub_DC4B2(*v4, (char *)a1, 2, v3, &s, 2LL);
  *(_BYTE *)(a1 + 8) &= 0x7Fu;
  if ( *(_DWORD *)v45 )
  {
    if ( *(_DWORD *)v45 == 1 )
    {
      v5 = (__int64 *)sub_281C9(*(_QWORD *)a1);
      sub_13937(v49, 61, 3u, (char *)a1, *v5, v6);
    }
    goto LABEL_62;
  }
  v7 = (__int64 *)lyd_node_module(a1);
  sub_DC765((__int64)&s, 3, a1, v7, 2);
  if ( v51 )
  {
LABEL_15:
    v12 = (__int64 *)lyd_node_module(a1);
    sub_DC765((__int64)&s, 0, a1, v12, 0);
LABEL_16:
    v48 = *(_QWORD *)a1;
    while ( 1 )
    {
      if ( *(_QWORD *)(v48 + 64)
        && *(_DWORD *)(*(_QWORD *)(v48 + 64) + 56LL) == 0x2000
        && sub_281C9(*(_QWORD *)(v48 + 64)) )
      {
        if ( !*(_QWORD *)&v45[4] )
        {
          *(_QWORD *)v45 = (unsigned int)sub_27B5A((_QWORD *)a1, *(_QWORD *)(v48 + 64), &v45[4], &v44);
          if ( *(_DWORD *)v45 )
          {
            sub_12222(
              (__int64)v49,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              6811LL);
            goto LABEL_62;
          }
        }
        v46 = 0LL;
        v47 = a1;
        *(_DWORD *)v45 = sub_27CDB(*(_QWORD *)(v48 + 64), &v47, (__int64 *)&v45[4], v44, (__int64)&v46);
        if ( *(_DWORD *)v45 )
          goto LABEL_62;
        v27 = (void **)lys_node_module(*(_QWORD *)(v48 + 64));
        v28 = v44;
        v29 = *(char **)&v45[4];
        v30 = (const char **)sub_281C9(*(_QWORD *)(v48 + 64));
        *(_DWORD *)v45 = sub_DC4B2(*v30, v29, v28, v27, &s, 2LL);
        if ( v46
          && *(_QWORD *)&v45[4]
          && (unsigned int)sub_27FD3(*(__int64 **)&v45[4], v46, v44, (__int64)v46, v31, v32) )
        {
          *(_DWORD *)v45 = -1;
          goto LABEL_62;
        }
        if ( *(_DWORD *)v45 )
        {
          if ( *(_DWORD *)v45 == 1 )
          {
            v33 = (__int64 *)sub_281C9(*(_QWORD *)(v48 + 64));
            sub_13937(v49, 61, 3u, (char *)a1, *v33, v34);
          }
          goto LABEL_62;
        }
        v35 = (__int64 *)lys_node_module(*(_QWORD *)(v48 + 64));
        sub_DC765((__int64)&s, 3, *(__int64 *)&v45[4], v35, 2);
        if ( !v51 )
        {
          *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
          if ( a2 != 1 && (!(*(_WORD *)(sub_281C9(*(_QWORD *)(v48 + 64)) + 34) & 0x600) || a2 != 2) )
          {
            v38 = (__int64 *)sub_281C9(*(_QWORD *)(v48 + 64));
            sub_13937(v49, 59, 3u, (char *)a1, *v38, v39);
            if ( v43 )
              *v43 = sub_281C9(*(_QWORD *)(v48 + 64));
            goto LABEL_62;
          }
          v36 = (__int64 *)sub_281C9(*(_QWORD *)(v48 + 64));
          sub_12222(0LL, 2u, 0, "When condition \"%s\" is not satisfied, but it is not required.", *v36, v37);
        }
        v40 = (__int64 *)lys_node_module(*(_QWORD *)(v48 + 64));
        sub_DC765((__int64)&s, 0, *(__int64 *)&v45[4], v40, 0);
      }
      v48 = lys_parent(v48);
      if ( !v48 || !(*(_DWORD *)(v48 + 56) & 0x1042) )
      {
        *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 2) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
        goto LABEL_62;
      }
      if ( sub_281C9(v48) )
      {
        if ( !*(_QWORD *)&v45[4] )
        {
          *(_QWORD *)v45 = (unsigned int)sub_27B5A((_QWORD *)a1, v48, &v45[4], &v44);
          if ( *(_DWORD *)v45 )
          {
            sub_12222(
              (__int64)v49,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              6757LL);
            goto LABEL_62;
          }
        }
        v46 = 0LL;
        v47 = a1;
        *(_DWORD *)v45 = sub_27CDB(v48, &v47, (__int64 *)&v45[4], v44, (__int64)&v46);
        if ( *(_DWORD *)v45 )
          goto LABEL_62;
        v13 = (void **)lys_node_module(v48);
        v14 = v44;
        v15 = *(char **)&v45[4];
        v16 = (const char **)sub_281C9(v48);
        *(_DWORD *)v45 = sub_DC4B2(*v16, v15, v14, v13, &s, 2LL);
        if ( v46
          && *(_QWORD *)&v45[4]
          && (unsigned int)sub_27FD3(*(__int64 **)&v45[4], v46, v44, (__int64)v46, v17, v18) )
        {
          *(_DWORD *)v45 = -1;
          goto LABEL_62;
        }
        if ( *(_DWORD *)v45 )
        {
          if ( *(_DWORD *)v45 == 1 )
          {
            v19 = (__int64 *)sub_281C9(v48);
            sub_13937(v49, 61, 3u, (char *)a1, *v19, v20);
          }
          goto LABEL_62;
        }
        v21 = (__int64 *)lys_node_module(v48);
        sub_DC765((__int64)&s, 3, *(__int64 *)&v45[4], v21, 2);
        if ( !v51 )
        {
          if ( a2 != 1 && (!(*(_WORD *)(sub_281C9(v48) + 34) & 0x600) || a2 != 2) )
          {
            *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
            v24 = (__int64 *)sub_281C9(v48);
            sub_13937(v49, 59, 3u, (char *)a1, *v24, v25);
            if ( v43 )
              *v43 = sub_281C9(v48);
            goto LABEL_62;
          }
          v22 = (__int64 *)sub_281C9(v48);
          sub_12222(0LL, 2u, 0, "When condition \"%s\" is not satisfied, but it is not required.", *v22, v23);
        }
        v26 = (__int64 *)lys_node_module(v48);
        sub_DC765((__int64)&s, 0, *(__int64 *)&v45[4], v26, 0);
      }
    }
  }
  *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
  if ( a2 == 1 || *(_WORD *)(sub_281C9(*(_QWORD *)a1) + 34) & 0x600 && a2 == 2 )
  {
    v8 = (__int64 *)sub_281C9(*(_QWORD *)a1);
    sub_12222(0LL, 2u, 0, "When condition \"%s\" is not satisfied, but it is not required.", *v8, v9);
    goto LABEL_15;
  }
  v10 = (__int64 *)sub_281C9(*(_QWORD *)a1);
  sub_13937(v49, 59, 3u, (char *)a1, *v10, v11);
  if ( v43 )
    *v43 = sub_281C9(*(_QWORD *)a1);
LABEL_62:
  if ( *(_QWORD *)&v45[4] )
    v41 = *(_QWORD *)&v45[4];
  else
    v41 = a1;
  sub_DC765((__int64)&s, 0, v41, 0LL, 0);
  return *(unsigned int *)v45;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000028E3C) ----------------------------------------------------
signed __int64 __fastcall sub_28E3C(__int64 a1)
{
  int v1; // eax
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  if ( *(_DWORD *)a1 != 11 || !*(_DWORD *)(a1 + 40) )
    return *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 28LL);
  for ( i = 0; (unsigned int)i < *(_DWORD *)(a1 + 40); ++i )
  {
    v1 = *(_DWORD *)(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 32));
    if ( v1 == 9 )
      return 1LL;
    if ( v1 == 11 && (unsigned int)sub_28E3C(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 32)) )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000028EDE) ----------------------------------------------------
signed __int64 __fastcall sub_28EDE(void **a1, __int64 a2, unsigned int a3, unsigned __int8 *a4, __int64 a5)
{
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // rbx
  unsigned __int16 v11; // ax
  char *v12; // rdi
  __int64 v13; // r9
  int v14; // eax
  __int64 v15; // r9
  unsigned int v16; // eax
  __int64 v17; // r9
  void **v18; // rbx
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // [rsp+8h] [rbp-108h]
  unsigned __int8 *v23; // [rsp+10h] [rbp-100h]
  unsigned int v24; // [rsp+1Ch] [rbp-F4h]
  int v25; // [rsp+30h] [rbp-E0h]
  unsigned int v26; // [rsp+34h] [rbp-DCh]
  int v27; // [rsp+38h] [rbp-D8h]
  unsigned int v28; // [rsp+3Ch] [rbp-D4h]
  int i; // [rsp+40h] [rbp-D0h]
  int v30; // [rsp+44h] [rbp-CCh]
  unsigned __int8 *v31; // [rsp+48h] [rbp-C8h]
  unsigned __int8 *k; // [rsp+50h] [rbp-C0h]
  unsigned __int8 *j; // [rsp+58h] [rbp-B8h]
  void *v34; // [rsp+60h] [rbp-B0h]
  void *v35; // [rsp+68h] [rbp-A8h]
  void *src; // [rsp+70h] [rbp-A0h]
  __int64 v37; // [rsp+78h] [rbp-98h]
  __int64 v38; // [rsp+80h] [rbp-90h]
  __int64 **v39; // [rsp+88h] [rbp-88h]
  void *v40; // [rsp+90h] [rbp-80h]
  __int64 v41; // [rsp+98h] [rbp-78h]
  __int64 v42; // [rsp+A0h] [rbp-70h]
  __int64 *v43; // [rsp+A8h] [rbp-68h]
  __int64 v44; // [rsp+B0h] [rbp-60h]
  __int64 v45; // [rsp+B8h] [rbp-58h]
  __int64 v46; // [rsp+C0h] [rbp-50h]
  unsigned __int8 *v47; // [rsp+C8h] [rbp-48h]
  __int64 v48; // [rsp+D0h] [rbp-40h]
  __int64 v49; // [rsp+D8h] [rbp-38h]
  _BYTE *v50; // [rsp+E0h] [rbp-30h]
  void *ptr; // [rsp+E8h] [rbp-28h]
  void *v52; // [rsp+F0h] [rbp-20h]
  unsigned __int64 v53; // [rsp+F8h] [rbp-18h]

  v24 = a3;
  v23 = a4;
  v22 = a5;
  v53 = __readfsqword(0x28u);
  v26 = -1;
  v27 = 0;
  v28 = 0;
  v34 = *a1;
  if ( a3 == 512 )
  {
    v47 = a4;
    v27 = 1;
    v42 = a2;
    v26 = sub_25CE3((__int64)a1, 0LL, (char *)a4, (__int64)"type", a2, a5);
    goto LABEL_162;
  }
  if ( a3 > 0x200 )
  {
    if ( a3 == 0x4000 )
    {
      v41 = a2;
      v26 = sub_1F79E(*(_QWORD *)a2, *(const char **)(a2 + 8), *(_BYTE **)(a2 + 16));
      goto LABEL_162;
    }
    if ( a3 <= 0x4000 )
    {
      if ( a3 == 2048 )
      {
        ++v28;
      }
      else
      {
        if ( a3 <= 0x800 )
        {
          if ( a3 == 1024 )
          {
            v43 = (__int64 *)a2;
            if ( *(_BYTE *)(a2 + 27) )
            {
              v44 = ly_set_new(a1);
              v45 = ly_set_new(a1);
              ly_set_add(v45, v43, 0LL);
              while ( *(_DWORD *)(v45 + 4) )
              {
                v46 = *(_QWORD *)(*(_QWORD *)(v45 + 8) + 8LL * (unsigned int)(*(_DWORD *)(v45 + 4) - 1));
                ly_set_rm_index(v45, (unsigned int)(*(_DWORD *)(v45 + 4) - 1));
                for ( i = 0; i < *(unsigned __int8 *)(v46 + 27); ++i )
                {
                  sub_1902D((__int64 *)(*(_QWORD *)(v46 + 40) + 32LL * i), 0LL, &v25);
                  while ( v25 )
                  {
                    if ( !*(_QWORD *)(8LL * (unsigned int)(v25 - 1) + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)) )
                    {
                      v26 = 1;
                      goto LABEL_93;
                    }
                    if ( v43 == *(__int64 **)(8LL * (unsigned int)(v25 - 1)
                                            + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)) )
                    {
                      sub_13937(v34, 39, 0, 0LL, *v43, v13);
                      goto LABEL_93;
                    }
                    if ( *(_BYTE *)(*(_QWORD *)(8LL * (unsigned int)(v25 - 1)
                                              + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16))
                                  + 27LL) )
                    {
                      v30 = *(_DWORD *)(v44 + 4);
                      v14 = ly_set_add(
                              v44,
                              *(_QWORD *)(8LL * (unsigned int)(v25 - 1)
                                        + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)),
                              0LL);
                      if ( v30 == v14 )
                        ly_set_add(
                          v45,
                          *(_QWORD *)(8LL * (unsigned int)(v25 - 1) + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)),
                          0LL);
                    }
                    --v25;
                  }
                }
              }
              v26 = 0;
LABEL_93:
              ly_set_free(v44);
              ly_set_free(v45);
            }
            goto LABEL_162;
          }
          goto LABEL_161;
        }
        if ( a3 != 4096 )
        {
          if ( a3 != 0x2000 )
            goto LABEL_161;
          v26 = sub_271C8(a2, *(char **)(a2 + 160));
          goto LABEL_162;
        }
      }
      v42 = a2;
      v26 = sub_1EAAF((_QWORD *)a2, (const char **)a4, a1, v28);
      if ( v26 == 1 && !v28 && *(_DWORD *)v42 == 9 )
      {
        for ( j = *(unsigned __int8 **)(v42 + 24); j && *((_DWORD *)j + 14) != 2048; j = (unsigned __int8 *)lys_parent(j) )
          ;
        if ( j )
          v26 = 0;
      }
      goto LABEL_162;
    }
    if ( a3 == 0x10000 )
    {
      v40 = a4;
      v39 = (__int64 **)(*(_QWORD *)a2 + 8LL * a4[41]);
      v26 = sub_22CDC(a4, v39, a5);
      if ( !v26 )
      {
        v37 = *(_QWORD *)(**v39 + 56);
        if ( v37 )
        {
          if ( *(_QWORD *)(v37 + 16) || *(_WORD *)(v37 + 4) & 1 )
          {
            v35 = malloc(1uLL);
            if ( !v35 )
            {
              sub_12222(
                (__int64)v34,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"resolve_unres_schema_item",
                v15);
              return 0xFFFFFFFFLL;
            }
            *(_BYTE *)v35 = *((_BYTE *)v40 + 41);
            if ( (unsigned int)sub_2ABDE((__int64 *)a1, v22, (__int64 *)a2, 0x40000u, (__int64 *)v35) == -1 )
              return 0xFFFFFFFFLL;
          }
        }
      }
      if ( !v26 || v26 == -1 )
      {
        if ( *((_DWORD *)v40 + 2) == 2 )
          lyxml_free(v34, *(_QWORD *)v40);
        else
          sub_952AD(*(void ***)v40);
        free(v40);
      }
      goto LABEL_162;
    }
    if ( a3 <= 0x10000 )
    {
      if ( a3 != 0x8000 )
        goto LABEL_161;
      v26 = sub_A9962((__int64)a1, a5);
      goto LABEL_162;
    }
    if ( a3 == 0x20000 )
    {
      k = (unsigned __int8 *)a2;
      v26 = sub_21FB6(a2, 1);
      goto LABEL_162;
    }
    if ( a3 != 0x40000 )
      goto LABEL_161;
    v35 = a4;
    src = *(void **)(*(_QWORD *)a2 + 8LL * *a4);
    free(a4);
    v37 = *(_QWORD *)(*(_QWORD *)src + 56LL);
    if ( !(*(_WORD *)(v37 + 4) & 1)
      || *((_BYTE *)src + 29) != 1
      || (v38 = *((_QWORD *)src + 1), *(_DWORD *)(v38 + 56) & 0x802C) )
    {
LABEL_157:
      if ( *(_QWORD *)(v37 + 16) && (*(unsigned int (__fastcall **)(void *))(v37 + 16))(src) )
      {
        sub_12222((__int64)v34, 0, 6, "Resolving extension failed.", v20, v21);
        return 0xFFFFFFFFLL;
      }
      v26 = 0;
      goto LABEL_162;
    }
    v31 = *(unsigned __int8 **)(v38 + 72);
    for ( k = v31; ; k = v31 )
    {
      if ( !k )
        goto LABEL_157;
      if ( (unsigned int)lys_ext_instance_presence(*(_QWORD *)src, *((_QWORD *)k + 4), k[26]) == -1
        && (v38 == *((_QWORD *)k + 8)
         || *(_DWORD *)(*((_QWORD *)k + 8) + 56LL) != 0x2000
         || (unsigned int)lys_ext_instance_presence(
                            *(_QWORD *)src,
                            *(_QWORD *)(*((_QWORD *)k + 8) + 32LL),
                            *(unsigned __int8 *)(*((_QWORD *)k + 8) + 26LL)) == -1) )
      {
        if ( !*(_QWORD *)(v37 + 24) )
          goto LABEL_142;
        v16 = (*(__int64 (__fastcall **)(void *, unsigned __int8 *))(v37 + 24))(src, k);
        v26 = v16;
        if ( v16 != 1 )
          break;
      }
LABEL_151:
      v31 = (unsigned __int8 *)*((_QWORD *)k + 10);
LABEL_154:
      while ( !v31 )
      {
        k = (unsigned __int8 *)lys_parent(k);
        if ( k == (unsigned __int8 *)v38 )
          break;
        v31 = (unsigned __int8 *)*((_QWORD *)k + 10);
      }
    }
    if ( v16 != 2 )
    {
      if ( v16 )
        sub_12222(
          (__int64)v34,
          0,
          4,
          "Plugin's (%s:%s) check_inherit callback returns invalid value (%d),",
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)src + 48LL) + 8LL),
          **(_QWORD **)src,
          v26);
LABEL_142:
      v39 = (__int64 **)realloc(*((void **)k + 4), 8LL * (k[26] + 1));
      if ( !v39 )
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_unres_schema_item", v17);
        return 0xFFFFFFFFLL;
      }
      v18 = (void **)&v39[k[26]];
      *v18 = malloc(0x40uLL);
      if ( !v39[k[26]] )
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_unres_schema_item", v19);
        *((_QWORD *)k + 4) = v39;
        return 0xFFFFFFFFLL;
      }
      memcpy(v39[k[26]], src, 0x40uLL);
      *((_WORD *)v39[k[26]] + 12) |= 1u;
      *((_QWORD *)k + 4) = v39;
      ++k[26];
    }
    if ( *((_DWORD *)k + 14) & 0x802C )
      v31 = 0LL;
    else
      v31 = (unsigned __int8 *)*((_QWORD *)k + 9);
    if ( v31 )
      goto LABEL_154;
    goto LABEL_151;
  }
  if ( a3 == 16 )
  {
    ++v28;
    goto LABEL_39;
  }
  if ( a3 > 0x10 )
  {
    if ( a3 == 64 )
    {
      v26 = sub_2245A(a2, 0LL, a5);
    }
    else if ( a3 > 0x40 )
    {
      if ( a3 == 128 )
      {
        v47 = a4;
        v27 = 1;
        v49 = a2;
        if ( !*(_QWORD *)(a2 + 112) )
          *(_QWORD *)(v49 + 112) = sub_23C04(v49, (__int64)v47);
        if ( *(_QWORD *)(v49 + 112) )
          v26 = sub_3C679(v49);
        else
          v26 = 1;
        goto LABEL_162;
      }
      if ( a3 != 256 )
        goto LABEL_161;
      v47 = a4;
      v27 = 1;
      v48 = a2;
      v26 = sub_25CE3((__int64)a1, a2, (char *)a4, (__int64)"identity", 0LL, a5);
    }
    else
    {
      if ( a3 != 32 )
        goto LABEL_161;
      k = a4;
      v42 = a2;
      v26 = sub_20BE2((__int64 *)a2, (__int64)a4, a5);
    }
    goto LABEL_162;
  }
  if ( a3 == 2 )
  {
    v52 = a4;
    v10 = *(_QWORD *)a4;
    v11 = strlen(*((const char **)a4 + 1));
    v12 = (char *)*((_QWORD *)v23 + 1);
    v26 = sub_1844C(v12, v11, v10, (_QWORD *)a2);
    if ( !v26 )
    {
      if ( *((_DWORD *)v52 + 4) )
      {
        v43 = *(__int64 **)a2;
        if ( !v43[7] )
          v43[7] = ly_set_new(v12);
        ly_set_add(v43[7], *(_QWORD *)v52, 1LL);
      }
      lydict_remove(v34, *((_QWORD *)v52 + 1));
      free(v52);
    }
    goto LABEL_162;
  }
  if ( a3 > 2 )
  {
    if ( a3 == 4 )
      goto LABEL_40;
    if ( a3 != 8 )
      goto LABEL_161;
LABEL_39:
    ++v28;
LABEL_40:
    k = a4;
    v42 = a2;
    v50 = *(_BYTE **)(a2 + 16);
    *(_QWORD *)(a2 + 16) = 0LL;
    if ( *v50 >= 0 )
    {
      v26 = sub_426E1((__int64)a1, (char *)k, (__int64)v50, v42, v28, a5);
      if ( v26 && v26 != -1 )
        *(_QWORD *)(v42 + 16) = v50;
      else
        lyxml_free(v34, v50);
    }
    else
    {
      ptr = v50;
      v26 = sub_8D12E((__int64)a1, (char *)k, (__int64)v50, (int *)v42, v28, a5);
      if ( v26 )
      {
        *(_QWORD *)(v42 + 16) = ptr;
      }
      else
      {
        lydict_remove(v34, *((_QWORD *)ptr + 1));
        free(ptr);
      }
    }
    if ( v26 )
    {
      if ( v26 == 1 && *(_BYTE *)(v42 + 4) >= 0 )
      {
        for ( j = k; j && *((_DWORD *)j + 14) != 2048; j = (unsigned __int8 *)lys_parent(j) )
          ;
        if ( j )
        {
          if ( !++*((_WORD *)j + 14) )
          {
            sub_12222((__int64)v34, 0, 4, "Too many unresolved items (type) inside a grouping.", v5, v6);
            return 0xFFFFFFFFLL;
          }
          *(_BYTE *)(v42 + 4) |= 0x80u;
        }
      }
    }
    else
    {
      if ( !v28 && *((_DWORD *)k + 14) == 8 && *(_DWORD *)v42 == 5 )
        sub_12222(
          (__int64)v34,
          1u,
          0,
          "The leaf-list \"%s\" is of \"empty\" type, which does not make sense.",
          *(_QWORD *)k,
          v6);
      if ( v24 != 8 || *(_DWORD *)v42 != 11 )
      {
        if ( v24 == 4
          && *(_BYTE *)(*(_QWORD *)(v42 + 16) + 28LL)
          && (unsigned int)sub_A0555((__int64 *)a1, (__int64 *)k, (void *)v42, 0LL, v22) )
        {
          sub_12222((__int64)v34, 0, 4, "Failed to duplicate type.", v7, v8);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)(v42 + 24) + 28LL) = sub_28E3C(v42);
      }
    }
    goto LABEL_162;
  }
  if ( a3 != 1 )
  {
LABEL_161:
    sub_12222(
      (__int64)v34,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
      7267LL);
    goto LABEL_162;
  }
  v26 = sub_26D87((_BYTE **)a2, a5);
LABEL_162:
  if ( v27 )
  {
    if ( !v26 )
      lydict_remove(v34, v23);
  }
  return v26;
}
// 72B0: using guessed type __int64 __fastcall lys_ext_instance_presence(_QWORD, _QWORD, _QWORD);
// 72E0: using guessed type __int64 __fastcall ly_set_rm_index(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000002A1A7) ----------------------------------------------------
unsigned __int64 __fastcall sub_2A1A7(__int64 *a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // rax
  __int64 i; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+40h] [rbp-10h]

  v9 = 0LL;
  if ( a2 == 256 )
    return sub_12222(
             0LL,
             2u,
             0,
             "Resolving %s \"%s\" failed, it will be attempted later.",
             (__int64)"identity",
             (__int64)a3);
  if ( a2 <= 0x100 )
  {
    if ( a2 == 8 )
      goto LABEL_32;
    if ( a2 <= 8 )
    {
      if ( a2 == 2 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"if-feature",
                 a3[1]);
      if ( a2 != 4 )
      {
        if ( a2 == 1 )
          return sub_12222(0LL, 2u, 0, "Resolving %s \"%s\" failed, it will be attempted later.", (__int64)"uses", *a1);
        return sub_12222(
                 0LL,
                 0,
                 4,
                 "Internal error (%s:%d).",
                 (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
                 7360LL);
      }
      goto LABEL_32;
    }
    if ( a2 == 32 )
      return sub_12222(0LL, 2u, 0, "Resolving %s \"%s\" failed, it will be attempted later.", (__int64)"leafref", a1[4]);
    if ( a2 > 0x20 )
    {
      if ( a2 == 64 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"augment target",
                 *a1);
      if ( a2 == 128 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"choice default",
                 (__int64)a3);
      return sub_12222(
               0LL,
               0,
               4,
               "Internal error (%s:%d).",
               (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
               7360LL);
    }
    if ( a2 == 16 )
    {
LABEL_32:
      v10 = a1[2];
      if ( *(_BYTE *)v10 < 0 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"derived type",
                 *(_QWORD *)(v10 + 8));
      for ( i = *(_QWORD *)(v10 + 16); i; i = *(_QWORD *)(i + 8) )
      {
        if ( *(_DWORD *)i == 1 && !strcmp(*(const char **)(i + 24), "name") )
        {
          v9 = *(_QWORD *)(i + 32);
          break;
        }
      }
      if ( !i )
        __assert_fail(
          "attr",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x1C92u,
          "print_unres_schema_item_fail");
      return sub_12222(
               0LL,
               2u,
               0,
               "Resolving %s \"%s\" failed, it will be attempted later.",
               (__int64)"derived type",
               v9);
    }
    return sub_12222(
             0LL,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
             7360LL);
  }
  if ( a2 == 4096 )
  {
LABEL_47:
    result = *a3;
    if ( *a3 )
      result = sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"type default",
                 *a3);
    return result;
  }
  if ( a2 <= 0x1000 )
  {
    if ( a2 == 1024 )
      return sub_12222(
               0LL,
               2u,
               0,
               "There are unresolved if-features for \"%s\" feature circular dependency check, it will be attempted later",
               *a1,
               a6);
    if ( a2 != 2048 )
    {
      if ( a2 == 512 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"identityref",
                 (__int64)a3);
      return sub_12222(
               0LL,
               0,
               4,
               "Internal error (%s:%d).",
               (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
               7360LL);
    }
    goto LABEL_47;
  }
  if ( a2 == 0x4000 )
    return sub_12222(
             0LL,
             2u,
             0,
             "Resolving %s \"%s\" failed, it will be attempted later.",
             (__int64)"list unique",
             (__int64)a3);
  if ( a2 <= 0x4000 )
  {
    if ( a2 == 0x2000 )
      return sub_12222(
               0LL,
               2u,
               0,
               "Resolving %s \"%s\" failed, it will be attempted later.",
               (__int64)"list keys",
               (__int64)a3);
    return sub_12222(
             0LL,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
             7360LL);
  }
  if ( a2 != 0x10000 )
  {
    if ( a2 == 0x20000 )
      return sub_12222(
               0LL,
               2u,
               0,
               "Resolving %s \"%s\" failed, it will be attempted later.",
               (__int64)"XPath expressions of",
               *a1);
    return sub_12222(
             0LL,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
             7360LL);
  }
  if ( *((_DWORD *)a3 + 2) == 2 )
    v7 = *(_QWORD *)(*a3 + 48);
  else
    v7 = 0LL;
  return sub_12222(0LL, 2u, 0, "Resolving extension \"%s\" failed, it will be attempted later.", v7, a6);
}

//----- (000000000002A690) ----------------------------------------------------
signed __int64 __fastcall sub_2A690(__int64 a1, int a2, __int64 a3, int a4, int a5, _DWORD *a6)
{
  signed __int64 result; // rax
  _DWORD *v7; // rax
  _DWORD *v8; // [rsp+8h] [rbp-58h]
  int v9; // [rsp+14h] [rbp-4Ch]
  __int64 v10; // [rsp+18h] [rbp-48h]
  int v11; // [rsp+20h] [rbp-40h]
  int v12; // [rsp+34h] [rbp-2Ch]
  unsigned int i; // [rsp+38h] [rbp-28h]
  unsigned int v14; // [rsp+3Ch] [rbp-24h]
  unsigned int v15; // [rsp+40h] [rbp-20h]
  unsigned int v16; // [rsp+44h] [rbp-1Ch]
  int v17; // [rsp+48h] [rbp-18h]
  int v18; // [rsp+4Ch] [rbp-14h]
  __int64 v19; // [rsp+50h] [rbp-10h]
  unsigned __int64 v20; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v11 = a4;
  v9 = a5;
  v8 = a6;
  v20 = __readfsqword(0x28u);
  v16 = 0;
  if ( a4 )
  {
    v17 = *(_DWORD *)ly_errno_glob_address(a1);
    sub_141E4(v10, 1u, &v12, (__int64)&v19);
  }
  while ( 2 )
  {
    v14 = 0;
    v15 = 0;
    for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
    {
      if ( a2 & *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) )
      {
        ++v14;
        v18 = sub_28EDE(
                *(void ***)(8LL * i + *(_QWORD *)(a1 + 24)),
                *(_QWORD *)(8LL * i + *(_QWORD *)a1),
                *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)),
                *(unsigned __int8 **)(8LL * i + *(_QWORD *)(a1 + 16)),
                a1);
        if ( *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) == 0x40000 )
          *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) = 0x4000000;
        if ( v18 && *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) != 0x20000 )
        {
          if ( v18 == 1 && v11 )
          {
            sub_1404C(v10, v19);
          }
          else
          {
            if ( !v9 )
            {
              if ( v11 )
                sub_142D2(v10, v12, v19, 1);
              return 0xFFFFFFFFLL;
            }
            ++v15;
            v16 = -1;
          }
        }
        else
        {
          if ( *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) == 0x4000 )
            free(*(void **)(8LL * i + *(_QWORD *)a1));
          *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) = 0x4000000;
          ++*v8;
          ++v15;
        }
      }
    }
    if ( v15 && v15 < v14 )
      continue;
    break;
  }
  if ( v15 >= v14 )
  {
    if ( v11 )
    {
      sub_142D2(v10, v12, v19, 0);
      v7 = (_DWORD *)ly_errno_glob_address(v10);
      *v7 = v17;
    }
    result = v16;
  }
  else
  {
    if ( !v11 )
      __assert_fail(
        "forward_ref",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x1D00u,
        "resolve_unres_schema_types");
    sub_142D2(v10, v12, v19, 0);
    for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
    {
      if ( a2 & *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) )
        sub_28EDE(
          *(void ***)(8LL * i + *(_QWORD *)(a1 + 24)),
          *(_QWORD *)(8LL * i + *(_QWORD *)a1),
          *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)),
          *(unsigned __int8 **)(8LL * i + *(_QWORD *)(a1 + 16)),
          a1);
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);

//----- (000000000002A9F8) ----------------------------------------------------
signed __int64 __fastcall sub_2A9F8(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // [rsp+0h] [rbp-20h]
  int v9; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v10; // [rsp+18h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v9 = 0;
  if ( !a2 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1D22u, "resolve_unres_schema");
  sub_12222(0LL, 2u, 0, "Resolving \"%s\" unresolved schema nodes and their constraints...", a1[1], a6, a2);
  if ( (unsigned int)sub_2A690(v8, 33263, *a1, 1, 0, &v9) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_2A690(v8, (unsigned __int64)&loc_17E00, *a1, 1, 0, &v9) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_2A690(v8, 393216, *a1, 0, 1, &v9) )
    return 0xFFFFFFFFLL;
  sub_12222(0LL, 2u, 0, "All \"%s\" schema nodes and constraints resolved.", a1[1], v7);
  *(_DWORD *)(v8 + 32) = 0;
  return 0LL;
}

//----- (000000000002AB62) ----------------------------------------------------
__int64 __fastcall sub_2AB62(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 a5)
{
  __int64 *v5; // ST18_8
  unsigned int v6; // ST14_4
  unsigned int v8; // [rsp+34h] [rbp-Ch]
  __int64 *v9; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v6 = a4;
  v9 = (__int64 *)lydict_insert(*a1, a5, 0LL);
  v8 = sub_2ABDE(a1, a2, v5, v6, v9);
  if ( (v8 & 0x80000000) != 0 )
    lydict_remove(*a1, v9);
  return v8;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000002ABDE) ----------------------------------------------------
signed __int64 __fastcall sub_2ABDE(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 *a5)
{
  signed __int64 result; // rax
  __int64 v6; // rdi
  _DWORD *v7; // rax
  __int64 v8; // rdi
  _DWORD *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 *v16; // [rsp+8h] [rbp-58h]
  unsigned int v17; // [rsp+14h] [rbp-4Ch]
  __int64 *ptr; // [rsp+18h] [rbp-48h]
  __int64 *v19; // [rsp+28h] [rbp-38h]
  int v20; // [rsp+30h] [rbp-30h]
  unsigned int v21; // [rsp+34h] [rbp-2Ch]
  unsigned int i; // [rsp+38h] [rbp-28h]
  int v23; // [rsp+3Ch] [rbp-24h]
  __int64 v24; // [rsp+40h] [rbp-20h]
  __int64 v25; // [rsp+48h] [rbp-18h]
  _QWORD *v26; // [rsp+50h] [rbp-10h]
  unsigned __int64 v27; // [rsp+58h] [rbp-8h]

  v19 = a1;
  ptr = a3;
  v17 = a4;
  v16 = a5;
  v27 = __readfsqword(0x28u);
  v25 = *a1;
  if ( !a2 || !a3 && a4 != 0x8000 || a4 == 0x80000 || a4 == (_DWORD)&loc_100000 || a4 == 0x200000 || a4 == 0x400000 )
    __assert_fail(
      "unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type !="
      " UNRES_WHEN) && (type != UNRES_MUST))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1D72u,
      "unres_schema_add_node");
  for ( i = 0; i < *(_DWORD *)(a2 + 32); ++i )
  {
    if ( a4 == *(_DWORD *)(4LL * i + *(_QWORD *)(a2 + 8))
      && a3 == *(__int64 **)(8LL * i + *(_QWORD *)a2)
      && a5 == *(__int64 **)(8LL * i + *(_QWORD *)(a2 + 16))
      && a1 == *(__int64 **)(8LL * i + *(_QWORD *)(a2 + 24)) )
    {
      return 1LL;
    }
  }
  if ( a4 == 0x40000 || a4 == 0x20000 || a4 == 0x8000 )
  {
    v21 = 1;
LABEL_34:
    *(_QWORD *)a2 = sub_C422(*(void **)a2, 8LL * (unsigned int)++*(_DWORD *)(a2 + 32));
    if ( *(_QWORD *)a2 )
    {
      *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)a2) = ptr;
      *(_QWORD *)(a2 + 8) = sub_C422(*(void **)(a2 + 8), 4LL * *(unsigned int *)(a2 + 32));
      if ( *(_QWORD *)(a2 + 8) )
      {
        *(_DWORD *)(4LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)(a2 + 8)) = v17;
        *(_QWORD *)(a2 + 16) = sub_C422(*(void **)(a2 + 16), 8LL * *(unsigned int *)(a2 + 32));
        if ( *(_QWORD *)(a2 + 16) )
        {
          *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)(a2 + 16)) = v16;
          *(_QWORD *)(a2 + 24) = sub_C422(*(void **)(a2 + 24), 8LL * *(unsigned int *)(a2 + 32));
          if ( *(_QWORD *)(a2 + 24) )
          {
            *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)(a2 + 24)) = v19;
            result = v21;
          }
          else
          {
            sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v15);
            result = 0xFFFFFFFFLL;
          }
        }
        else
        {
          sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v14);
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v13);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v12);
      result = 0xFFFFFFFFLL;
    }
    return result;
  }
  v23 = *(_DWORD *)ly_errno_glob_address(a1);
  sub_141E4(v25, 1u, &v20, (__int64)&v24);
  v21 = sub_28EDE((void **)a1, (__int64)ptr, v17, (unsigned __int8 *)v16, a2);
  if ( v21 == 1 )
  {
    v8 = v25;
    sub_142D2(v25, v20, v24, 0);
    v9 = (_DWORD *)ly_errno_glob_address(v8);
    *v9 = v23;
    sub_2A1A7(ptr, v17, v16, v17, v10, v11);
    if ( v17 == 4 || v17 == 8 )
    {
      v26 = (_QWORD *)ptr[2];
      if ( *(_BYTE *)v26 >= 0 )
      {
        sub_30B77(*v19, v26, 1);
        ptr[2] = (__int64)v26;
      }
    }
    goto LABEL_34;
  }
  v6 = v25;
  sub_142D2(v25, v20, v24, v21 == -1);
  if ( v21 != -1 )
  {
    v7 = (_DWORD *)ly_errno_glob_address(v6);
    *v7 = v23;
  }
  if ( v17 == 0x4000 )
  {
    free(ptr);
  }
  else if ( v21 == -1 && v17 == 2 )
  {
    free((void *)*ptr);
  }
  return v21;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);

//----- (000000000002B0C1) ----------------------------------------------------
signed __int64 __fastcall sub_2B0C1(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5)
{
  signed __int64 result; // rax
  __int64 v6; // r9
  void *ptr; // [rsp+8h] [rbp-58h]
  unsigned int v8; // [rsp+14h] [rbp-4Ch]
  __int64 *v9; // [rsp+18h] [rbp-48h]
  int v10; // [rsp+34h] [rbp-2Ch]
  _QWORD *v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = (__int64 *)a3;
  v8 = a4;
  ptr = a5;
  v14 = __readfsqword(0x28u);
  if ( !a3 || !a5 || a4 == 0x80000 || a4 == (_DWORD)&loc_100000 || a4 == 0x200000 )
    __assert_fail(
      "item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1DCDu,
      "unres_schema_dup");
  if ( a4 == 0x4000 )
  {
    v12 = a3;
    v13 = a5[1];
    v9 = &v12;
  }
  v10 = sub_2B3F8(a2, -1, (__int64)v9, a4);
  if ( v10 == -1 )
  {
    if ( v8 == 0x4000 )
      free(ptr);
    result = 1LL;
  }
  else
  {
    if ( v8 != 32 && v8 != 1 && v8 != 4096 && v8 != 1024 && v8 != 0x4000 )
    {
      if ( v8 == 2 )
      {
        v11 = malloc(0x18uLL);
        if ( !v11 )
        {
          sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_dup", v6);
          return 0xFFFFFFFFLL;
        }
        v11[1] = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(8LL * v10 + *(_QWORD *)(a2 + 16)) + 8LL), 0LL);
        *v11 = **(_QWORD **)(8LL * v10 + *(_QWORD *)(a2 + 16));
        *((_DWORD *)v11 + 4) = *(_DWORD *)(*(_QWORD *)(8LL * v10 + *(_QWORD *)(a2 + 16)) + 16LL);
        if ( (unsigned int)sub_2ABDE(a1, a2, (__int64 *)ptr, 2u, v11) == -1 )
        {
          sub_12222(
            *a1,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            7660LL);
          return 0xFFFFFFFFLL;
        }
      }
      else if ( (unsigned int)sub_2AB62(a1, a2, (__int64 *)ptr, v8, *(_QWORD *)(8LL * v10 + *(_QWORD *)(a2 + 16))) == -1 )
      {
        sub_12222(
          *a1,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
          7665LL);
        return 0xFFFFFFFFLL;
      }
    }
    else if ( (unsigned int)sub_2ABDE(a1, a2, (__int64 *)ptr, v8, *(__int64 **)(8LL * v10 + *(_QWORD *)(a2 + 16))) == -1 )
    {
      sub_12222(
        *a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        7649LL);
      return 0xFFFFFFFFLL;
    }
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000002B3F8) ----------------------------------------------------
signed __int64 __fastcall sub_2B3F8(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+10h] [rbp-30h]
  int v7; // [rsp+2Ch] [rbp-14h]
  __int64 v8; // [rsp+30h] [rbp-10h]

  v5 = a3;
  v6 = a4;
  if ( !*(_DWORD *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  if ( a2 < 0 )
    v7 = *(_DWORD *)(a1 + 32) - 1;
  else
    v7 = a2;
  while ( v7 >= 0 )
  {
    if ( v6 == *(_DWORD *)(4LL * v7 + *(_QWORD *)(a1 + 8)) )
    {
      if ( v6 == 0x4000 )
      {
        v8 = *(_QWORD *)(8LL * v7 + *(_QWORD *)a1);
        if ( *(_QWORD *)v8 == *(_QWORD *)v5 && (unsigned int)sub_C462(*(_BYTE **)(v8 + 8), *(_BYTE **)(v5 + 8)) )
          return (unsigned int)v7;
      }
      else if ( v5 == *(_QWORD *)(8LL * v7 + *(_QWORD *)a1) )
      {
        return (unsigned int)v7;
      }
    }
    --v7;
  }
  return (unsigned int)v7;
}

//----- (000000000002B4F8) ----------------------------------------------------
_DWORD *__fastcall sub_2B4F8(__int64 a1, _QWORD *a2, unsigned int a3)
{
  unsigned int v3; // eax
  _DWORD *result; // rax
  unsigned int v5; // [rsp+Ch] [rbp-34h]
  _BYTE *v6; // [rsp+28h] [rbp-18h]

  v5 = a3;
  v3 = *(_DWORD *)(4LL * a3 + a2[1]);
  if ( v3 == 256 )
    goto LABEL_23;
  if ( v3 > 0x100 )
  {
    if ( v3 == 0x4000 )
    {
      free(*(void **)(8LL * a3 + *a2));
      goto LABEL_27;
    }
    if ( v3 > 0x4000 )
    {
      if ( v3 == 0x10000 )
      {
        free(*(void **)(8LL * a3 + a2[2]));
      }
      else if ( v3 == 0x40000 )
      {
        free(*(void **)(8LL * a3 + a2[2]));
      }
      goto LABEL_27;
    }
    if ( v3 != 512 && v3 != 0x2000 )
      goto LABEL_27;
LABEL_23:
    lydict_remove(a1, *(_QWORD *)(8LL * a3 + a2[2]));
    goto LABEL_27;
  }
  if ( v3 != 4 )
  {
    if ( v3 <= 4 )
    {
      if ( v3 == 2 )
      {
        lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(8LL * a3 + a2[2]) + 8LL));
        free(*(void **)(8LL * v5 + a2[2]));
      }
      goto LABEL_27;
    }
    if ( v3 != 8 )
    {
      if ( v3 != 128 )
        goto LABEL_27;
      goto LABEL_23;
    }
  }
  v6 = *(_BYTE **)(*(_QWORD *)(8LL * a3 + *a2) + 16LL);
  if ( *v6 >= 0 )
  {
    lyxml_free(a1, v6);
  }
  else
  {
    **(_DWORD **)(8LL * a3 + *a2) = *((_DWORD *)v6 + 1);
    lydict_remove(a1, *((_QWORD *)v6 + 1));
    free(v6);
    if ( **(_DWORD **)(8LL * v5 + *a2) == 11 )
      sub_8EB71(a1, *(_QWORD *)(8LL * v5 + *a2));
  }
LABEL_27:
  result = (_DWORD *)(4LL * v5 + a2[1]);
  *result = 0x4000000;
  return result;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000002B768) ----------------------------------------------------
void *__fastcall sub_2B768(__int64 a1, void ***a2, int a3)
{
  void *result; // rax
  int v4; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  v6 = 0;
  if ( a2 )
  {
    result = *a2;
    if ( *a2 )
    {
      if ( !a1 && *((_DWORD *)*a2 + 8) )
        __assert_fail(
          "module || ((*unres)->count == 0)",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x1E57u,
          "unres_schema_free");
      for ( i = 0; ; ++i )
      {
        result = (void *)*((unsigned int *)*a2 + 8);
        if ( i >= (unsigned int)result )
          break;
        if ( v4 || a1 == *((_QWORD *)(*a2)[3] + i) )
        {
          sub_2B4F8(*(_QWORD *)a1, *a2, i);
        }
        else if ( *((_DWORD *)(*a2)[1] + i) != 0x4000000 )
        {
          ++v6;
        }
      }
      if ( !a1 || v4 || !v6 && (result = (void *)(*(_BYTE *)(a1 + 64) & 1), !(_BYTE)result) )
      {
        free(**a2);
        free((*a2)[1]);
        free((*a2)[2]);
        free((*a2)[3]);
        free(*a2);
        result = a2;
        *a2 = 0LL;
      }
    }
  }
  return result;
}

//----- (000000000002B8E0) ----------------------------------------------------
signed __int64 __fastcall sub_2B8E0(__int64 a1, const char *a2)
{
  __int64 v3; // rdx
  __int64 v4; // rbx
  int v5; // [rsp+14h] [rbp-3Ch]
  __int64 i; // [rsp+18h] [rbp-38h]
  char *v7; // [rsp+20h] [rbp-30h]
  void *ptr; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  unsigned __int64 v10; // [rsp+38h] [rbp-18h]

  v10 = __readfsqword(0x28u);
  if ( !a2 || !*a2 )
    return 0LL;
  for ( i = lys_parent(a1); i && !(*(_DWORD *)(i + 56) & 0x4180); i = lys_parent(i) )
    ;
  if ( i && lys_parent(i) )
    return 1LL;
  v7 = strchr(a2 + 1, 47);
  if ( v7 )
    v3 = v7 - a2;
  else
    v3 = strlen(a2);
  ptr = strndup(a2, v3);
  if ( !ptr )
    return 0LL;
  sub_141E4(0LL, 2u, &v5, 0LL);
  v9 = ly_ctx_get_node(0LL, a1, ptr, 0LL);
  sub_142D2(0LL, v5, 0LL, 0);
  free(ptr);
  if ( !v9 )
    return 1LL;
  if ( i )
  {
    if ( i != v9 )
      return 1LL;
  }
  else
  {
    v4 = lys_node_module(a1);
    if ( v4 != lys_node_module(v9) )
      return 1LL;
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 78D0: using guessed type __int64 __fastcall ly_ctx_get_node(_QWORD, _QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000002BAA8) ----------------------------------------------------
signed __int64 __fastcall sub_2BAA8(char *a1, __int64 a2, int a3, _QWORD *a4)
{
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  unsigned int v7; // eax
  signed __int64 result; // rax
  _QWORD *v9; // [rsp+0h] [rbp-B0h]
  int v10; // [rsp+Ch] [rbp-A4h]
  int v11; // [rsp+24h] [rbp-8Ch]
  unsigned int v12; // [rsp+28h] [rbp-88h]
  int v13; // [rsp+2Ch] [rbp-84h]
  int v14; // [rsp+30h] [rbp-80h]
  unsigned int j; // [rsp+34h] [rbp-7Ch]
  int v16; // [rsp+38h] [rbp-78h]
  int v17; // [rsp+3Ch] [rbp-74h]
  __int64 v18; // [rsp+40h] [rbp-70h]
  char *string; // [rsp+48h] [rbp-68h]
  const char *v20; // [rsp+50h] [rbp-60h]
  __int64 v21; // [rsp+58h] [rbp-58h]
  __int64 v22; // [rsp+60h] [rbp-50h]
  char *i; // [rsp+68h] [rbp-48h]
  __int64 v24; // [rsp+70h] [rbp-40h]
  void *ptr; // [rsp+78h] [rbp-38h]
  _QWORD *s; // [rsp+80h] [rbp-30h]
  unsigned int v27; // [rsp+90h] [rbp-20h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v28 = __readfsqword(0x28u);
  v14 = 0;
  v22 = 0LL;
  v24 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  string = 0LL;
  memset(&s, 0, 0x28uLL);
  *v9 = 0LL;
  for ( i = a1; *((_QWORD *)i + 5); i = (char *)*((_QWORD *)i + 5) )
    ;
  if ( *((_QWORD *)i + 4) )
  {
    while ( *(_QWORD *)(*((_QWORD *)i + 4) + 24LL) )
      i = (char *)*((_QWORD *)i + 4);
  }
  while ( *(_BYTE *)(v14 + a2) )
  {
    j = sub_1729D(
          (_BYTE *)(v14 + a2),
          (signed __int64 *)&string,
          (unsigned int *)&v11,
          (signed __int64 *)&v20,
          &v12,
          &v13);
    if ( (signed int)j <= 0 )
    {
      sub_13937(
        (void *)v24,
        55,
        3u,
        a1,
        (unsigned int)*(char *)((signed int)(v14 - j) + a2),
        (signed int)(v14 - j) + a2,
        v9);
LABEL_54:
      free(s);
      return 0xFFFFFFFFLL;
    }
    v14 += j;
    if ( string )
    {
      ptr = strndup(string, v11);
      if ( !ptr )
      {
        sub_12222(v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_instid", v5, v9);
        goto LABEL_54;
      }
      v21 = ly_ctx_get_module(v24, ptr, 0LL, 1LL);
      if ( *(_QWORD *)(v24 + 112) )
      {
        if ( v21 )
        {
          if ( *(_BYTE *)(v21 + 64) >= 0 )
            v21 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v24 + 112))(
                    v24,
                    *(_QWORD *)(v21 + 8),
                    *(_QWORD *)(v21 + 176),
                    1LL,
                    *(_QWORD *)(v24 + 120));
        }
        else
        {
          v21 = (*(__int64 (__fastcall **)(__int64, void *, _QWORD, _QWORD, _QWORD))(v24 + 112))(
                  v24,
                  ptr,
                  0LL,
                  0LL,
                  *(_QWORD *)(v24 + 120));
        }
      }
      free(ptr);
      if ( !v21 || *(_BYTE *)(v21 + 64) >= 0 || *(_BYTE *)(v21 + 64) & 0x40 )
        break;
    }
    else
    {
      if ( !v22 )
      {
        sub_13937((void *)v24, 48, 3u, a1, v12, (__int64)v20, v9);
        sub_13937((void *)v24, -1, 5u, 0LL, (__int64)"Instance-identifier is missing prefix in the first node.", v6);
        goto LABEL_54;
      }
      v21 = v22;
    }
    if ( (unsigned int)sub_1FBFE((__int64 *)v21, v20, v12, (__int64)i, (__int64)&s) )
      break;
    if ( v13 )
    {
      j = 0;
      v16 = 0;
      v17 = 1;
      while ( (signed int)j < (signed int)v27 )
      {
        v18 = s[j];
        v16 = sub_2170F(v21, v14 + a2, (__int64 **)&v18, v17);
        if ( v16 <= 0 )
        {
          sub_13937((void *)v24, 56, 3u, a1, v14 - v16 + a2, v4, v9);
          goto LABEL_54;
        }
        if ( v18 )
          ++j;
        else
          sub_1FB5F((__int64)&s, j);
        ++v17;
      }
      v14 += v16;
    }
    else if ( v27 )
    {
      for ( j = 0; v27 > j; ++j )
      {
        if ( *(_DWORD *)(*(_QWORD *)s[j] + 56LL) == 16 )
        {
          v7 = j--;
          sub_1FB5F((__int64)&s, v7);
        }
      }
      if ( !v27 )
        sub_13937((void *)v24, -1, 3u, a1, (__int64)"Instance identifier is missing list keys.", v4, v9);
    }
    v22 = v21;
  }
  if ( v27 )
  {
    if ( v27 <= 1 )
    {
      *v9 = *s;
      free(s);
      return 0LL;
    }
    sub_13937((void *)v24, 14, 3u, a1, a2, (__int64)"data tree", v9);
    goto LABEL_54;
  }
  if ( v10 < 0 )
  {
    sub_12222(0LL, 2u, 0, "There is no instance of \"%s\", but it is not required.", a2, v4, v9);
    result = 0LL;
  }
  else
  {
    sub_13937((void *)v24, 64, 3u, a1, a2, v4, v9);
    result = 1LL;
  }
  return result;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002C0A6) ----------------------------------------------------
signed __int64 __fastcall sub_2C0A6(__int64 a1, const char *a2, int a3, _QWORD *a4)
{
  void **v4; // rax
  _QWORD *v6; // [rsp+0h] [rbp-80h]
  int v7; // [rsp+Ch] [rbp-74h]
  unsigned int i; // [rsp+2Ch] [rbp-54h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v10; // [rsp+40h] [rbp-40h]
  unsigned int v11; // [rsp+50h] [rbp-30h]
  unsigned __int64 v12; // [rsp+78h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v12 = __readfsqword(0x28u);
  memset(&s, 0, 0x40uLL);
  *v6 = 0LL;
  v4 = (void **)lyd_node_module(a1);
  if ( (unsigned int)sub_DC4B2(a2, (char *)a1, 2, v4, &s, 0LL) )
    return 0xFFFFFFFFLL;
  if ( s == 1 )
  {
    for ( i = 0; i < v11; ++i )
    {
      if ( *(_DWORD *)(16LL * i + v10 + 8) == 2
        && *(_DWORD *)(**(_QWORD **)(16LL * i + v10) + 56LL) & 0xC
        && *(_QWORD *)(a1 + 56) == *(_QWORD *)(*(_QWORD *)(16LL * i + v10) + 56LL) )
      {
        *v6 = *(_QWORD *)(16LL * i + v10);
        break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, a1, 0LL, 0);
  if ( !*v6 )
  {
    if ( v7 >= 0 )
    {
      sub_13937(**(void ***)(*(_QWORD *)a1 + 48LL), 65, 3u, (char *)a1, (__int64)a2, *(_QWORD *)(a1 + 56), v6);
      return 1LL;
    }
    sub_12222(
      0LL,
      2u,
      0,
      "There is no leafref \"%s\" with the value \"%s\", but it is not required.",
      (__int64)a2,
      *(_QWORD *)(a1 + 56),
      v6);
  }
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (000000000002C282) ----------------------------------------------------
signed __int64 __fastcall sub_2C282(__int64 a1, _DWORD *a2, int a3, int a4, _QWORD *a5)
{
  const char *v6; // rax
  __int64 v7; // rax
  void *v8; // rax
  _QWORD *v9; // [rsp+0h] [rbp-60h]
  int v10; // [rsp+8h] [rbp-58h]
  int v11; // [rsp+Ch] [rbp-54h]
  int v12; // [rsp+24h] [rbp-3Ch]
  int v13; // [rsp+28h] [rbp-38h]
  int v14; // [rsp+2Ch] [rbp-34h]
  int v15; // [rsp+30h] [rbp-30h]
  int v16; // [rsp+34h] [rbp-2Ch]
  __int64 v17; // [rsp+38h] [rbp-28h]
  __int64 v18; // [rsp+40h] [rbp-20h]
  const char *v19; // [rsp+48h] [rbp-18h]
  void *v20; // [rsp+50h] [rbp-10h]
  unsigned __int64 v21; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v21 = __readfsqword(0x28u);
  v20 = **(void ***)(*(_QWORD *)a1 + 48LL);
  v14 = 0;
  v19 = 0LL;
  if ( *a2 != 11 )
    __assert_fail(
      "type->base == LY_TYPE_UNION",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1F6Cu,
      "resolve_union");
  if ( *(_DWORD *)(a1 + 72) == 11 || *(_DWORD *)(a1 + 72) == 8 && *(_BYTE *)(a1 + 76) & 1 )
    v19 = (const char *)lydict_insert(v20, *(_QWORD *)(a1 + 64), 0LL);
  if ( v11 )
  {
    sub_BBE52(
      *(void **)(a1 + 64),
      *(_DWORD *)(a1 + 72),
      *(_BYTE *)(a1 + 76),
      *(_QWORD *)a1 + 128LL,
      *(_QWORD *)(a1 + 56),
      0LL,
      0LL,
      0LL);
    memset((void *)(a1 + 64), 0, 8uLL);
  }
  sub_141E4(0LL, 2u, &v12, 0LL);
  v18 = 0LL;
  v13 = 0;
  while ( 1 )
  {
    v18 = sub_3A9DE((signed __int64)a2, v18, &v13);
    if ( !v18 )
      break;
    v13 = 0;
    if ( *(_DWORD *)v18 == 8 )
    {
      if ( v19 )
        v6 = v19;
      else
        v6 = *(const char **)(a1 + 56);
      v16 = sub_2B8E0(*(_QWORD *)a1, v6);
      if ( v10 == 1 || v16 && v10 == 2 )
        v15 = -1;
      else
        v15 = *(char *)(v18 + 32);
      if ( v19 )
        v7 = (__int64)v19;
      else
        v7 = *(_QWORD *)(a1 + 56);
      if ( !(unsigned int)sub_2BAA8((char *)a1, v7, v15, &v17) )
      {
        if ( v11 )
        {
          if ( !v17 || v16 )
          {
            if ( v19 )
            {
              *(_QWORD *)(a1 + 64) = v19;
              v19 = 0LL;
            }
            else
            {
              *(_QWORD *)(a1 + 64) = 0LL;
            }
            *(_DWORD *)(a1 + 72) = 8;
            *(_BYTE *)(a1 + 76) |= 1u;
          }
          else
          {
            *(_QWORD *)(a1 + 64) = v17;
            *(_DWORD *)(a1 + 72) = 8;
            if ( v19 )
            {
              lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), *(_QWORD *)(a1 + 56));
              *(_QWORD *)(a1 + 56) = v19;
              v19 = 0LL;
            }
          }
        }
        v14 = 1;
      }
    }
    else if ( *(_DWORD *)v18 == 9 )
    {
      if ( v10 == 1 || *(_WORD *)(*(_QWORD *)a1 + 24LL) & 0x800 && v10 == 2 )
        v15 = -1;
      else
        v15 = *(char *)(v18 + 48);
      if ( !(unsigned int)sub_2C0A6(a1, *(const char **)(v18 + 32), v15, &v17) )
      {
        if ( v11 )
        {
          if ( !v17 || *(_WORD *)(*(_QWORD *)a1 + 24LL) & 0x800 )
          {
            sub_142D2(0LL, v12, 0LL, 0);
            if ( !sub_37EF5(v18, (char **)(a1 + 56), 0LL, (__int64 **)a1, 0LL, 0LL, 1, 0, 0) )
              return 0xFFFFFFFFLL;
            sub_141E4(0LL, 2u, &v12, 0LL);
          }
          else
          {
            *(_QWORD *)(a1 + 64) = v17;
            *(_DWORD *)(a1 + 72) = 9;
          }
        }
        v14 = 1;
      }
    }
    else if ( sub_37EF5(v18, (char **)(a1 + 56), 0LL, (__int64 **)a1, 0LL, 0LL, v11, 0, 0) )
    {
      v14 = 1;
    }
    if ( v14 )
      break;
    if ( v11 )
    {
      sub_BBE52(
        *(void **)(a1 + 64),
        *(_DWORD *)(a1 + 72),
        *(_BYTE *)(a1 + 76),
        v18,
        *(_QWORD *)(a1 + 56),
        0LL,
        0LL,
        0LL);
      memset((void *)(a1 + 64), 0, 8uLL);
    }
  }
  sub_142D2(0LL, v12, 0LL, 0);
  if ( v19 )
  {
    if ( v14 )
    {
      lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), v19);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 72) != 11 )
        __assert_fail(
          "leaf->value_type == LY_TYPE_UNION",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x1FD9u,
          "resolve_union");
      *(_QWORD *)(a1 + 64) = v19;
    }
  }
  if ( v14 )
  {
    if ( v9 )
      *v9 = v18;
    return 0LL;
  }
  if ( v10 && a2[11] )
    return 0LL;
  if ( *(_QWORD *)(a1 + 56) )
    v8 = *(void **)(a1 + 56);
  else
    v8 = &unk_10AA7C;
  sub_13937(v20, 50, 3u, (char *)a1, (__int64)v8, **(_QWORD **)a1, v9);
  return 1LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000002C85B) ----------------------------------------------------
signed __int64 __fastcall sub_2C85B(char *a1, unsigned int a2, unsigned int a3, __int64 *a4)
{
  unsigned int v5; // [rsp+10h] [rbp-40h]
  unsigned int v6; // [rsp+24h] [rbp-2Ch]
  unsigned int v7; // [rsp+24h] [rbp-2Ch]
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  unsigned int v9; // [rsp+24h] [rbp-2Ch]
  unsigned int v10; // [rsp+24h] [rbp-2Ch]
  int v11; // [rsp+28h] [rbp-28h]
  int v12; // [rsp+28h] [rbp-28h]
  int v13; // [rsp+2Ch] [rbp-24h]
  __int64 v14; // [rsp+30h] [rbp-20h]
  char *v15; // [rsp+38h] [rbp-18h]
  __int64 v16; // [rsp+40h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v17 = __readfsqword(0x28u);
  v15 = a1;
  v16 = *(_QWORD *)a1;
  if ( a2 == 0x400000 )
  {
    v9 = sub_275C3(a1, 0, a3);
    if ( v9 )
      return v9;
    return 0LL;
  }
  if ( a2 <= 0x400000 )
  {
    if ( a2 == (_DWORD)&loc_100000 )
    {
      if ( *(_DWORD *)(v16 + 128) != 8 )
        __assert_fail(
          "sleaf->type.base == LY_TYPE_INST",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x202Bu,
          "resolve_unres_data_item");
      v13 = sub_2B8E0(*(_QWORD *)v15, *((const char **)v15 + 7));
      if ( v13 == -1 )
        return 0xFFFFFFFFLL;
      if ( v5 )
        v12 = -1;
      else
        v12 = *(char *)(v16 + 160);
      if ( v13 && v5 == 2 )
      {
        v7 = 0;
        v14 = 0LL;
      }
      else
      {
        v7 = sub_2BAA8(a1, *((_QWORD *)v15 + 7), v12, &v14);
      }
      if ( v7 )
        return v7;
      if ( !v14 || v13 )
      {
        *((_QWORD *)v15 + 8) = 0LL;
        *((_DWORD *)v15 + 18) = 8;
        v15[76] |= 1u;
      }
      else
      {
        *((_QWORD *)v15 + 8) = v14;
        *((_DWORD *)v15 + 18) = 8;
        v15[76] &= 0xFEu;
      }
    }
    else if ( a2 == 0x200000 )
    {
      v8 = sub_28399((__int64)a1, a3, a4);
      if ( v8 )
        return v8;
    }
    else
    {
      if ( a2 != 0x80000 )
      {
LABEL_61:
        sub_12222(
          0LL,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
          8299LL);
        return 0xFFFFFFFFLL;
      }
      if ( *(_DWORD *)(v16 + 128) != 9 )
        __assert_fail(
          "sleaf->type.base == LY_TYPE_LEAFREF",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x2005u,
          "resolve_unres_data_item");
      if ( !(v15[8] & 8) )
        __assert_fail(
          "leaf->validity & LYD_VAL_LEAFREF",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x2006u,
          "resolve_unres_data_item");
      if ( a3 )
        v11 = -1;
      else
        v11 = *(char *)(v16 + 176);
      if ( *(_WORD *)(*(_QWORD *)v15 + 24LL) & 0x800 && a3 == 2 )
      {
        v6 = 0;
        v14 = 0LL;
      }
      else
      {
        v6 = sub_2C0A6((__int64)v15, *(const char **)(v16 + 160), v11, &v14);
      }
      if ( v6 )
        return v6;
      if ( !v14 || *(_WORD *)(*(_QWORD *)v15 + 24LL) & 0x800 )
      {
        if ( !(v15[76] & 1) && !sub_37EF5(v16 + 128, (char **)v15 + 7, 0LL, (__int64 **)v15, 0LL, 0LL, 1, 0, 0) )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( *((_DWORD *)v15 + 18) == 2 )
          free(*((void **)v15 + 8));
        *((_QWORD *)v15 + 8) = v14;
        *((_DWORD *)v15 + 18) = 9;
        v15[76] &= 0xFEu;
      }
      v15[8] &= 0xF7u;
    }
    return 0LL;
  }
  if ( a2 != 0x1000000 )
  {
    if ( a2 == 0x2000000 )
    {
      if ( (unsigned int)sub_2E5BD(a1) )
        return 0xFFFFFFFFLL;
    }
    else
    {
      if ( a2 != 0x800000 )
        goto LABEL_61;
      v10 = sub_275C3(a1, 1u, a3);
      if ( v10 )
        return v10;
    }
    return 0LL;
  }
  if ( *(_DWORD *)(v16 + 128) != 11 )
    __assert_fail(
      "sleaf->type.base == LY_TYPE_UNION",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x204Fu,
      "resolve_unres_data_item");
  return sub_2C282((__int64)v15, (_DWORD *)(v16 + 128), 1, a3, 0LL);
}

//----- (000000000002CD1C) ----------------------------------------------------
signed __int64 __fastcall sub_2CD1C(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r9
  signed __int64 result; // rax
  __int64 v5; // r9
  int v6; // [rsp+Ch] [rbp-14h]

  v6 = a3;
  if ( !a1 || !a2 )
    __assert_fail("unres && node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x207Du, "unres_data_add");
  if ( a3 != 0x80000
    && a3 != (_DWORD)&loc_100000
    && a3 != 0x200000
    && a3 != 0x400000
    && a3 != 0x800000
    && a3 != 0x1000000
    && a3 != 0x2000000 )
  {
    __assert_fail(
      "(type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST) || (type == UNRE"
      "S_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x207Fu,
      "unres_data_add");
  }
  *(_QWORD *)a1 = sub_C422(*(void **)a1, 8LL * (unsigned int)++*(_DWORD *)(a1 + 16));
  if ( *(_QWORD *)a1 )
  {
    *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 1) + *(_QWORD *)a1) = a2;
    *(_QWORD *)(a1 + 8) = sub_C422(*(void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 16));
    if ( *(_QWORD *)(a1 + 8) )
    {
      *(_DWORD *)(4LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 1) + *(_QWORD *)(a1 + 8)) = v6;
      result = 0LL;
    }
    else
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_data_add", v5);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_data_add", v3);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000002CEE7) ----------------------------------------------------
_QWORD *__fastcall sub_2CEE7(__int64 a1, unsigned int a2)
{
  _QWORD *result; // rax
  unsigned int i; // [rsp+14h] [rbp-1Ch]
  _QWORD *v4; // [rsp+18h] [rbp-18h]
  _QWORD *k; // [rsp+20h] [rbp-10h]
  __int64 j; // [rsp+28h] [rbp-8h]

  for ( i = 0; i < *(_DWORD *)(a1 + 36); ++i )
  {
    if ( *(_DWORD *)(4LL * i + **(_QWORD **)(a1 + 24)) != 1 )
    {
      if ( *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) == *(_QWORD *)(8LL * a2 + *(_QWORD *)a1) )
        return (_QWORD *)sub_BDDC2(a1, i);
      for ( j = *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) + 40LL);
            j && j != *(_QWORD *)(8LL * a2 + *(_QWORD *)a1);
            j = *(_QWORD *)(j + 40) )
      {
        ;
      }
      if ( j )
      {
        sub_BDDC2(a1, i);
        break;
      }
      for ( k = *(_QWORD **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)); k; k = v4 )
      {
        result = *(_QWORD **)(8LL * a2 + *(_QWORD *)a1);
        if ( k == result )
          return result;
        if ( *(_DWORD *)(*k + 56LL) & 0x802C )
          v4 = 0LL;
        else
          v4 = (_QWORD *)k[8];
        if ( !v4 )
        {
          if ( k == *(_QWORD **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) )
            break;
          v4 = (_QWORD *)k[3];
        }
        while ( !v4 )
        {
          k = (_QWORD *)k[5];
          if ( k[5] == *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) + 40LL) )
            break;
          v4 = (_QWORD *)k[3];
        }
      }
    }
  }
  sub_BDCC8(a1, *(_QWORD *)(8LL * a2 + *(_QWORD *)a1), *(_QWORD *)(*(_QWORD *)(8LL * a2 + *(_QWORD *)a1) + 40LL), 0);
  lyd_unlink(*(_QWORD *)(8LL * a2 + *(_QWORD *)a1));
  result = (_QWORD *)(8LL * a2 + *(_QWORD *)a1);
  *result = 0LL;
  return result;
}
// 7840: using guessed type __int64 __fastcall lyd_unlink(_QWORD);

//----- (000000000002D16B) ----------------------------------------------------
signed __int64 __fastcall sub_2D16B(__int64 a1, __int64 a2, __int64 a3, __int16 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rax
  _DWORD *v13; // rax
  _DWORD *v14; // rax
  __int16 v15; // [rsp+4h] [rbp-7Ch]
  __int64 v16; // [rsp+8h] [rbp-78h]
  __int64 v17; // [rsp+10h] [rbp-70h]
  char v18; // [rsp+23h] [rbp-5Dh]
  int v19; // [rsp+24h] [rbp-5Ch]
  unsigned int i; // [rsp+28h] [rbp-58h]
  unsigned int k; // [rsp+2Ch] [rbp-54h]
  int v22; // [rsp+30h] [rbp-50h]
  unsigned int v23; // [rsp+34h] [rbp-4Ch]
  int v24; // [rsp+38h] [rbp-48h]
  unsigned int v25; // [rsp+3Ch] [rbp-44h]
  int v26; // [rsp+40h] [rbp-40h]
  unsigned int v27; // [rsp+44h] [rbp-3Ch]
  int v28; // [rsp+48h] [rbp-38h]
  int v29; // [rsp+4Ch] [rbp-34h]
  __int64 v30; // [rsp+50h] [rbp-30h]
  __int64 v31; // [rsp+58h] [rbp-28h]
  __int64 j; // [rsp+60h] [rbp-20h]
  unsigned __int64 v33; // [rsp+68h] [rbp-18h]

  v17 = a2;
  v16 = a3;
  v15 = a4;
  v33 = __readfsqword(0x28u);
  v28 = *(_DWORD *)ly_errno_glob_address(a1);
  if ( !v16 )
    __assert_fail("root", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x20DFu, "resolve_unres_data");
  if ( !a2 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x20E0u, "resolve_unres_data");
  if ( !*(_DWORD *)(a2 + 16) )
    return 0LL;
  if ( v15 & 0x8E )
  {
    v27 = 1;
  }
  else if ( v15 & 0x8000 )
  {
    v27 = 2;
  }
  else
  {
    v27 = 0;
  }
  sub_12222(0LL, 2u, 0, "Resolving unresolved data nodes and their constraints...", v4, v5);
  if ( !v27 )
    sub_141E4(a1, 1u, &v19, (__int64)&v30);
  v22 = 1;
  v25 = 0;
  v23 = 0;
  v24 = 0;
  while ( 2 )
  {
    if ( !v27 )
      sub_1404C(a1, v30);
    v26 = 0;
    for ( i = 0; i < *(_DWORD *)(v17 + 16); ++i )
    {
      if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x200000 )
      {
        if ( v22 )
          ++v25;
        for ( j = *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 40LL);
              j && (!((*(_BYTE *)(j + 9) >> 1) & 4) || (*(_BYTE *)(j + 9) >> 1) & 3);
              j = *(_QWORD *)(j + 40) )
        {
          if ( !*(_QWORD *)(j + 40) && (*(_BYTE *)(j + 9) >> 1) & 1 )
          {
            v9 = *(_QWORD *)(8LL * i + *(_QWORD *)v17);
            *(_BYTE *)(v9 + 9) = 2 * (((*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) >> 1) & 7 | 1) & 7) | *(_BYTE *)(v9 + 9) & 0xF1;
            *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
            ++v23;
            break;
          }
        }
        if ( !j )
        {
          v18 = (*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) >> 1) & 7;
          v10 = *(unsigned int *)(4LL * i + *(_QWORD *)(v17 + 8));
          v29 = sub_2C85B(*(char **)(8LL * i + *(_QWORD *)v17), v10, v27, &v31);
          if ( v29 )
          {
            if ( v29 == -1 )
              goto LABEL_111;
          }
          else
          {
            if ( !((*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) >> 1) & 1)
              || *(_WORD *)(v31 + 34) & 0x600 && v15 & 0x8000 )
            {
              *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
            }
            else
            {
              if ( (!(v18 & 2) || !(v15 & 0x4000)) && !(*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) & 1) )
                goto LABEL_111;
              v11 = *(_QWORD *)v31;
              v12 = ly_errpath(a1, v10);
              sub_12222(0LL, 2u, 0, "Auto-deleting node \"%s\" due to when condition (%s)", v12, v11);
              for ( j = *(_QWORD *)(8LL * i + *(_QWORD *)v17);
                    *(_QWORD *)(j + 40)
                 && *(_DWORD *)(**(_QWORD **)(j + 40) + 56LL) == 1
                 && !*(_QWORD *)(**(_QWORD **)(j + 40) + 136LL)
                 && !*(_QWORD *)(j + 24)
                 && j == *(_QWORD *)(j + 32);
                    j = *(_QWORD *)(j + 40) )
              {
                ;
              }
              *(_QWORD *)(*(_QWORD *)v17 + 8LL * i) = j;
              if ( *(_QWORD *)v16 && *(_QWORD *)v16 == *(_QWORD *)(8LL * i + *(_QWORD *)v17) )
                *(_QWORD *)v16 = *(_QWORD *)(*(_QWORD *)v16 + 24LL);
              *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x8000000;
              ++v24;
              for ( k = 0; k < *(_DWORD *)(v17 + 16); ++k )
              {
                if ( *(_DWORD *)(4LL * k + *(_QWORD *)(v17 + 8)) != 0x4000000
                  && *(_DWORD *)(4LL * k + *(_QWORD *)(v17 + 8)) != 0x8000000 )
                {
                  for ( j = *(_QWORD *)(8LL * k + *(_QWORD *)v17); j; j = *(_QWORD *)(j + 40) )
                  {
                    if ( j == *(_QWORD *)(8LL * i + *(_QWORD *)v17) )
                    {
                      *(_DWORD *)(4LL * k + *(_QWORD *)(v17 + 8)) = 0x4000000;
                      ++v23;
                      break;
                    }
                  }
                }
              }
            }
            if ( !v27 )
              sub_1404C(a1, v30);
            ++v23;
            v26 = 1;
          }
        }
      }
    }
    v22 = 0;
    if ( v26 && v23 < v25 )
      continue;
    break;
  }
  if ( v25 > v23 )
    goto LABEL_111;
  for ( i = 0; v24 && i < *(_DWORD *)(v17 + 16); ++i )
  {
    if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x8000000 )
    {
      if ( *(_QWORD *)(8LL * i + *(_QWORD *)v17) )
      {
        if ( *(_DWORD *)(v17 + 20) )
          sub_2CEE7(v17, i);
        lyd_free(*(_QWORD *)(8LL * i + *(_QWORD *)v17));
        *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
        --v24;
      }
      else
      {
        *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
        --v24;
      }
    }
  }
  if ( v15 & 0x2000 )
  {
    if ( v27 )
      __assert_fail("!ignore_fail", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x2182u, "resolve_unres_data");
    v27 = 1;
    sub_142D2(a1, v19, v30, 0);
    v13 = (_DWORD *)ly_errno_glob_address(a1);
    *v13 = v28;
  }
  v22 = 1;
  v25 = 0;
  v23 = 0;
  do
  {
    v26 = 0;
    for ( i = 0; i < *(_DWORD *)(v17 + 16); ++i )
    {
      if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x80000 )
      {
        if ( v22 )
          ++v25;
        v29 = sub_2C85B(*(char **)(8LL * i + *(_QWORD *)v17), *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)), v27, 0LL);
        if ( v29 )
        {
          if ( v29 == -1 )
            goto LABEL_111;
        }
        else
        {
          *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
          if ( !v27 )
            sub_1404C(a1, v30);
          ++v23;
          v26 = 1;
        }
      }
    }
    v22 = 0;
  }
  while ( v26 && v23 < v25 );
  if ( v25 > v23 )
  {
LABEL_111:
    if ( !v27 )
      sub_142D2(a1, v19, v30, 1);
    return 0xFFFFFFFFLL;
  }
  if ( !v27 )
  {
    sub_142D2(a1, v19, v30, 0);
    v14 = (_DWORD *)ly_errno_glob_address(a1);
    *v14 = v28;
  }
  for ( i = 0; i < *(_DWORD *)(v17 + 16); ++i )
  {
    if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) != 0x4000000 )
    {
      if ( v15 & 0x2000
        && (*(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x400000
         || *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x800000) )
      {
        __assert_fail(
          "!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT))",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x21B7u,
          "resolve_unres_data");
      }
      v29 = sub_2C85B(*(char **)(8LL * i + *(_QWORD *)v17), *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)), v27, 0LL);
      if ( v29 )
        return 0xFFFFFFFFLL;
      *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
    }
  }
  sub_12222(0LL, 2u, 0, "All data nodes and constraints resolved.", v7, v8);
  *(_DWORD *)(v17 + 16) = 0;
  return 0LL;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7A70: using guessed type __int64 __fastcall ly_errpath(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (000000000002DB2D) ----------------------------------------------------
signed __int64 __fastcall sub_2DB2D(char *a1)
{
  __int64 v1; // r9
  signed int v3; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = *(_QWORD *)a1;
  v3 = 0;
  for ( i = *((_QWORD *)a1 + 8); ; i = *(_QWORD *)(i + 24) )
  {
    if ( v3 >= *(unsigned __int8 *)(v5 + 30) )
      return 0LL;
    if ( !i || *(_QWORD *)i != *(_QWORD *)(8LL * v3 + *(_QWORD *)(v5 + 136)) )
      break;
    ++v3;
  }
  sub_13937(**(void ***)(v5 + 48), 49, 3u, a1, **(_QWORD **)(8LL * v3 + *(_QWORD *)(v5 + 136)), *(_QWORD *)v5);
  while ( i )
  {
    if ( *(_QWORD *)i == *(_QWORD *)(8LL * v3 + *(_QWORD *)(v5 + 136)) )
    {
      sub_13937(**(void ***)(v5 + 48), -1, 3u, (char *)i, (__int64)"Invalid position of the key element.", v1);
      return 1LL;
    }
    i = *(_QWORD *)(i + 24);
  }
  return 1LL;
}

//----- (000000000002DC82) ----------------------------------------------------
signed __int64 __fastcall sub_2DC82(char *a1, __int16 a2, __int64 a3)
{
  __int64 v3; // r9
  signed __int64 result; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // [rsp+8h] [rbp-48h]
  __int64 *k; // [rsp+28h] [rbp-28h]
  __int64 j; // [rsp+30h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-18h]
  void *v11; // [rsp+48h] [rbp-8h]

  v7 = a3;
  v11 = **(void ***)(*(_QWORD *)a1 + 48LL);
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/validation.c", 0x3Bu, "lyv_data_context");
  if ( !a3 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/validation.c", 0x3Cu, "lyv_data_context");
  if ( lys_is_disabled(*(_QWORD *)a1, 2LL) )
  {
    sub_13937(v11, 47, 3u, a1, **(_QWORD **)a1, v3);
    return 1LL;
  }
  for ( i = *(_QWORD *)a1; i && !(*(_DWORD *)(i + 56) & 0x4180); i = lys_parent(i) )
    ;
  if ( a2 & 0x8E || a2 & 0x50 && !i )
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC )
      a1[8] &= 0xF7u;
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC )
    {
      if ( *(_DWORD *)(*(_QWORD *)a1 + 128LL) == 11 && *(_DWORD *)(*(_QWORD *)a1 + 172LL) )
      {
        if ( (unsigned int)sub_2CD1C(v7, (__int64)a1, 0x1000000) )
          return 1LL;
      }
      else if ( *(_DWORD *)(*(_QWORD *)a1 + 128LL) == 9 && (a1[8] & 8 || a1[76] & 1) )
      {
        a1[76] &= 0xFEu;
        a1[8] |= 8u;
        if ( (unsigned int)sub_2CD1C(v7, (__int64)a1, 0x80000) )
          return 1LL;
      }
      else if ( *(_DWORD *)(*(_QWORD *)a1 + 128LL) == 8
             && (unsigned int)sub_2CD1C(v7, (__int64)a1, (unsigned __int64)&loc_100000) )
      {
        return 1LL;
      }
    }
    if ( ((unsigned __int8)a1[9] >> 1) & 4 && (unsigned int)sub_2CD1C(v7, (__int64)a1, 0x200000) )
      return 1LL;
  }
  if ( a2 & 0xD && *(_WORD *)(*(_QWORD *)a1 + 24LL) & 2 )
  {
    sub_13937(v11, 47, 3u, a1, **(_QWORD **)a1, v3);
    result = 1LL;
  }
  else
  {
    if ( !(a2 & 0x2080)
      && a2 & 0x30
      && a1[8] & 4
      && i
      && a1 != *((char **)a1 + 4)
      && *(_QWORD *)(*((_QWORD *)a1 + 4) + 24LL) )
    {
      for ( j = lys_parent(*(_QWORD *)a1); j && *(_DWORD *)(j + 56) & 0x1042; j = lys_parent(j) )
        ;
      v5 = lyd_node_module(a1);
      for ( k = (__int64 *)lys_getnext(*(_QWORD *)a1, j, v5, 0LL); k; k = (__int64 *)lys_getnext(k, j, v6, 0LL) )
      {
        if ( k == **((__int64 ***)a1 + 4) )
        {
          sub_13937(v11, 60, 3u, a1, **(_QWORD **)a1, *k);
          return 1LL;
        }
        v6 = lyd_node_module(a1);
      }
    }
    result = 0LL;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (000000000002E0DF) ----------------------------------------------------
signed __int64 __fastcall sub_2E0DF(__int64 ***a1, __int64 *a2, __int64 a3, int a4)
{
  unsigned __int16 v5; // ax
  char *v6; // r12
  const char *v7; // rbx
  __int64 *v8; // rax
  int v9; // [rsp+0h] [rbp-A0h]
  unsigned __int16 v10; // [rsp+26h] [rbp-7Ah]
  int i; // [rsp+28h] [rbp-78h]
  signed int j; // [rsp+2Ch] [rbp-74h]
  signed int k; // [rsp+2Ch] [rbp-74h]
  int v14; // [rsp+34h] [rbp-6Ch]
  __int64 v15; // [rsp+38h] [rbp-68h]
  __int64 v16; // [rsp+40h] [rbp-60h]
  void *ptr; // [rsp+48h] [rbp-58h]
  void *v18; // [rsp+50h] [rbp-50h]
  __int64 **v19; // [rsp+58h] [rbp-48h]
  __int64 v20; // [rsp+60h] [rbp-40h]
  void *v21; // [rsp+68h] [rbp-38h]
  __int64 *v22; // [rsp+70h] [rbp-30h]
  __int64 *v23; // [rsp+78h] [rbp-28h]
  void *v24; // [rsp+80h] [rbp-20h]
  unsigned __int64 v25; // [rsp+88h] [rbp-18h]

  v9 = a4;
  v25 = __readfsqword(0x28u);
  if ( !a1 || !a2 )
    __assert_fail(
      "val1_p && val2_p",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x9Bu,
      "lyv_list_uniq_equal");
  v19 = *a1;
  v20 = *a2;
  if ( !v19 || *((_DWORD *)*v19 + 14) != 16 )
    __assert_fail(
      "first && (first->schema->nodetype == LYS_LIST)",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0xA1u,
      "lyv_list_uniq_equal");
  if ( !v20 || *(__int64 **)v20 != *v19 )
    __assert_fail(
      "second && (second->schema == first->schema)",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0xA2u,
      "lyv_list_uniq_equal");
  v21 = *(void **)(*v19)[6];
  v22 = *v19;
  if ( a4 > 0 )
  {
    i = a4 - 1;
    if ( a4 - 1 < *((unsigned __int8 *)v22 + 31) )
      goto LABEL_13;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= *((unsigned __int8 *)v22 + 31) )
      return 0LL;
LABEL_13:
    for ( j = 0; j < *(unsigned __int8 *)(16LL * i + v22[18] + 8); ++j )
    {
      v23 = sub_19BA2(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), v19[8]);
      if ( v23 )
      {
        v15 = v23[7];
      }
      else if ( (unsigned int)sub_BC387(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), (__int64)v19, &v15) )
      {
        return 1LL;
      }
      v23 = sub_19BA2(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), *(__int64 **)(v20 + 64));
      if ( v23 )
      {
        v16 = v23[7];
      }
      else if ( (unsigned int)sub_BC387(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), v20, &v16) )
      {
        return 1LL;
      }
      if ( !v15 || !v16 || v15 != v16 )
        break;
    }
    if ( j && j == *(unsigned __int8 *)(16LL * i + v22[18] + 8) )
      break;
    if ( v9 > 0 )
      return 0LL;
  }
  sub_12B3E(3u, (char *)v19, &ptr, 0, 0);
  sub_12B3E(3u, (char *)v20, &v18, 0, 0);
  v24 = malloc(0x400uLL);
  v10 = 0;
  for ( k = 0; k < *(unsigned __int8 *)(16LL * i + v22[18] + 8); ++k )
  {
    if ( k )
    {
      v5 = v10++;
      *((_BYTE *)v24 + v5) = 32;
    }
    v6 = (char *)v24 + v10;
    v7 = *(const char **)(8LL * k + *(_QWORD *)(16LL * i + v22[18]));
    v8 = (__int64 *)lys_node_module(v22);
    v14 = sub_BC8A8(v8, (__int64 *)v19, v7, (__int64)v6);
    if ( v14 == -1 )
      goto LABEL_36;
    v10 += v14;
  }
  sub_13937(v21, 18, 3u, (char *)v20, (__int64)v24, (__int64)ptr, v18);
LABEL_36:
  free(ptr);
  free(v18);
  free(v24);
  return 1LL;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000002E5BD) ----------------------------------------------------
signed __int64 __fastcall sub_2E5BD(char *a1)
{
  __int64 v2; // r9
  _QWORD *v3; // rbx
  __int64 v4; // r9
  unsigned __int64 v5; // rax
  unsigned int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int i; // [rsp+14h] [rbp-6Ch]
  unsigned int n; // [rsp+14h] [rbp-6Ch]
  unsigned int k; // [rsp+18h] [rbp-68h]
  unsigned int m; // [rsp+18h] [rbp-68h]
  unsigned int ii; // [rsp+18h] [rbp-68h]
  unsigned int v14; // [rsp+1Ch] [rbp-64h]
  unsigned int v15; // [rsp+20h] [rbp-60h]
  unsigned int v16; // [rsp+24h] [rbp-5Ch]
  signed int j; // [rsp+28h] [rbp-58h]
  unsigned int l; // [rsp+28h] [rbp-58h]
  char *s; // [rsp+30h] [rbp-50h]
  void *ptr; // [rsp+38h] [rbp-48h]
  void *v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h]
  __int64 v23; // [rsp+50h] [rbp-30h]
  __int64 v24; // [rsp+58h] [rbp-28h]
  __int64 *v25; // [rsp+60h] [rbp-20h]
  unsigned __int64 v26; // [rsp+68h] [rbp-18h]

  v26 = __readfsqword(0x28u);
  v14 = 0;
  v15 = 0;
  v21 = 0LL;
  v22 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  if ( !(a1[8] & 2) )
    return 0LL;
  v23 = *(_QWORD *)a1;
  if ( (unsigned int)sub_12B3E(3u, a1, &ptr, 0, 1) )
    return 0xFFFFFFFFLL;
  v24 = lyd_find_path(a1, ptr);
  free(ptr);
  if ( !v24 )
    return 0xFFFFFFFFLL;
  for ( i = 0; i < *(_DWORD *)(v24 + 4); ++i )
    *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 8)) + 8LL) &= 0xFDu;
  if ( *(_DWORD *)(v24 + 4) == 2 )
  {
    if ( (unsigned int)sub_2E0DF(*(__int64 ****)(v24 + 8), (__int64 *)(*(_QWORD *)(v24 + 8) + 8LL), 0LL, 0) )
    {
      ly_set_free(v24);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)(v24 + 4) > 2u )
  {
    for ( j = 31; j && *(_DWORD *)(v24 + 4) << j >> j != *(_DWORD *)(v24 + 4); --j )
      ;
    if ( j )
    {
      v14 = *(unsigned __int8 *)(v23 + 31);
      v21 = malloc(8LL * *(unsigned __int8 *)(v23 + 31));
      if ( v21 )
      {
        for ( k = 0; k < v14; ++k )
        {
          v3 = (char *)v21 + 8 * k;
          *v3 = sub_14CB1(1 << (32 - j), 8, (__int64)sub_2E0DF, k + 1LL, 0);
          if ( !*((_QWORD *)v21 + k) )
          {
            sub_12222(v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyv_data_unique", v4);
            v15 = -1;
            goto LABEL_44;
          }
        }
        for ( l = 0; l < *(_DWORD *)(v24 + 4); ++l )
        {
          for ( m = 0; m < v14; ++m )
          {
            s = 0LL;
            v16 = 0;
            for ( n = 0; n < *(unsigned __int8 *)(16LL * m + *(_QWORD *)(v23 + 144) + 8); ++n )
            {
              v25 = sub_19BA2(
                      *(const char **)(8LL * n + *(_QWORD *)(16LL * m + *(_QWORD *)(v23 + 144))),
                      *(__int64 **)(*(_QWORD *)(8LL * l + *(_QWORD *)(v24 + 8)) + 64LL));
              if ( v25 )
              {
                s = (char *)v25[7];
              }
              else if ( (unsigned int)sub_BC387(
                                        *(const char **)(8LL * n + *(_QWORD *)(16LL * m + *(_QWORD *)(v23 + 144))),
                                        *(_QWORD *)(8LL * l + *(_QWORD *)(v24 + 8)),
                                        &s) )
              {
                v15 = -1;
                goto LABEL_44;
              }
              if ( !s )
                break;
              v5 = strlen(s);
              v16 = sub_1476E(v16, (__int64)s, v5);
            }
            if ( s )
            {
              v6 = sub_1476E(v16, 0LL, 0LL);
              if ( (unsigned int)sub_15F55(
                                   *((_QWORD *)v21 + m),
                                   (const void *)(*(_QWORD *)(v24 + 8) + 8LL * l),
                                   v6,
                                   0LL,
                                   v7,
                                   v8) )
              {
                v15 = 1;
                goto LABEL_44;
              }
            }
          }
        }
      }
      else
      {
        sub_12222(v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyv_data_unique", v2);
        v15 = -1;
        v14 = 0;
      }
    }
    else
    {
      sub_12222(
        v22,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/validation.c",
        296LL);
      v15 = -1;
    }
  }
LABEL_44:
  ly_set_free(v24);
  for ( ii = 0; ii < v14 && *((_QWORD *)v21 + ii); ++ii )
    sub_14F6B(*((void ***)v21 + ii));
  free(v21);
  return v15;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 75A0: using guessed type __int64 __fastcall lyd_find_path(_QWORD, _QWORD);

//----- (000000000002EB38) ----------------------------------------------------
signed __int64 __fastcall sub_2EB38(_QWORD **a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  signed __int64 result; // rax
  signed int i; // [rsp+2Ch] [rbp-44h]
  _QWORD *j; // [rsp+30h] [rbp-40h]
  _QWORD *k; // [rsp+30h] [rbp-40h]
  __int64 v11; // [rsp+38h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-30h]
  __int64 v13; // [rsp+48h] [rbp-28h]
  _QWORD *v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  void *v16; // [rsp+60h] [rbp-10h]
  __int64 v17; // [rsp+68h] [rbp-8h]

  if ( !a1 || !a2 )
    __assert_fail("val1_p && val2_p", "/home/mantovan/Repositories/libyang/src/validation.c", 0x17Fu, "lyv_list_equal");
  v14 = *a1;
  v15 = *a2;
  if ( !*a1 || !(*(_DWORD *)(*v14 + 56LL) & 0x18) )
    __assert_fail(
      "first && (first->schema->nodetype & (LYS_LIST | LYS_LEAFLIST))",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x184u,
      "lyv_list_equal");
  if ( !v15 || *(_QWORD *)v15 != *v14 )
    __assert_fail(
      "second && (second->schema == first->schema)",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x185u,
      "lyv_list_equal");
  v16 = **(void ***)(*v14 + 48LL);
  v6 = *(_DWORD *)(*v14 + 56LL);
  if ( v6 == 8 )
  {
    if ( *(_WORD *)(*v14 + 24LL) & 2 && ((*(_BYTE *)(*(_QWORD *)(*v14 + 48LL) + 64LL) >> 1) & 7u) > 1 )
    {
      result = 0LL;
    }
    else if ( v14[7] == *(_QWORD *)(v15 + 56) )
    {
      sub_13937(v16, 16, 3u, (char *)v15, **(_QWORD **)v15, *(_QWORD *)(v15 + 56), a4);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else if ( v6 == 16 )
  {
    v17 = *v14;
    if ( *(_BYTE *)(*v14 + 30LL) )
    {
      for ( i = 0; i < *(unsigned __int8 *)(v17 + 30); ++i )
      {
        v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(v17 + 136));
        v12 = 0LL;
        v11 = 0LL;
        for ( j = (_QWORD *)v14[8]; j; j = (_QWORD *)j[3] )
        {
          if ( v13 == *j )
          {
            v11 = j[7];
            break;
          }
        }
        for ( k = *(_QWORD **)(v15 + 64); k; k = (_QWORD *)k[3] )
        {
          if ( v13 == *k )
          {
            v12 = k[7];
            break;
          }
        }
        if ( v11 != v12 )
          return 0LL;
      }
      sub_13937(v16, 17, 3u, (char *)v15, **(_QWORD **)v15, a6, a4);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(
      (__int64)v16,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/validation.c",
      440LL,
      a4);
    result = 1LL;
  }
  return result;
}

//----- (000000000002EE3F) ----------------------------------------------------
signed __int64 __fastcall sub_2EE3F(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // r9
  char *s; // ST58_8
  unsigned __int64 v7; // rax
  unsigned int v8; // ST24_4
  unsigned int v9; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  char *v12; // ST58_8
  unsigned __int64 v13; // rax
  __int64 v14; // [rsp+0h] [rbp-60h]
  signed int v15; // [rsp+1Ch] [rbp-44h]
  unsigned int v16; // [rsp+20h] [rbp-40h]
  unsigned int v17; // [rsp+24h] [rbp-3Ch]
  signed int j; // [rsp+28h] [rbp-38h]
  unsigned int k; // [rsp+28h] [rbp-38h]
  __int64 i; // [rsp+30h] [rbp-30h]
  __int64 v21; // [rsp+38h] [rbp-28h]
  void **v22; // [rsp+40h] [rbp-20h]
  __int64 v23; // [rsp+48h] [rbp-18h]
  __int64 v24; // [rsp+50h] [rbp-10h]

  v14 = a2;
  v16 = 0;
  v22 = 0LL;
  v23 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  if ( !a2 )
    v14 = lyd_first_sibling(a1);
  v24 = ly_set_new(a1);
  for ( i = v14; i; i = *(_QWORD *)(i + 24) )
  {
    if ( *(_QWORD *)i == *(_QWORD *)a1 )
    {
      *(_BYTE *)(i + 8) &= 0xFEu;
      ly_set_add(v24, i, 1LL);
    }
  }
  if ( *(_DWORD *)(v24 + 4) == 2 )
  {
    if ( (unsigned int)sub_2EB38(*(_QWORD ***)(v24 + 8), (__int64 *)(*(_QWORD *)(v24 + 8) + 8LL), 0LL, 0LL, v2, v3) )
    {
      ly_set_free(v24);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)(v24 + 4) > 2u )
  {
    for ( j = 31; j && *(_DWORD *)(v24 + 4) << j >> j != *(_DWORD *)(v24 + 4); --j )
      ;
    if ( j )
    {
      v22 = (void **)sub_14CB1(1 << (32 - j), 8, (__int64)sub_2EB38, 0LL, 0);
      if ( v22 )
      {
        for ( k = 0; k < *(_DWORD *)(v24 + 4); ++k )
        {
          if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) == 8 )
          {
            s = *(char **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v24 + 8)) + 56LL);
            v7 = strlen(*(const char **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v24 + 8)) + 56LL));
            v8 = sub_1476E(0, (__int64)s, v7);
            v9 = sub_1476E(v8, 0LL, 0LL);
          }
          else
          {
            v15 = 0;
            v17 = 0;
            v21 = *(_QWORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v24 + 8)) + 64LL);
            while ( v15 < *(unsigned __int8 *)(**(_QWORD **)(8LL * k + *(_QWORD *)(v24 + 8)) + 30LL) )
            {
              v12 = *(char **)(v21 + 56);
              v13 = strlen(*(const char **)(v21 + 56));
              v17 = sub_1476E(v17, (__int64)v12, v13);
              ++v15;
              v21 = *(_QWORD *)(v21 + 24);
            }
            v9 = sub_1476E(v17, 0LL, 0LL);
          }
          if ( (unsigned int)sub_15F55((__int64)v22, (const void *)(*(_QWORD *)(v24 + 8) + 8LL * k), v9, 0LL, v10, v11) )
          {
            v16 = 1;
            break;
          }
        }
      }
      else
      {
        sub_12222(v23, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyv_data_dup", v5, v14);
        v16 = 1;
      }
    }
    else
    {
      sub_12222(
        v23,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/validation.c",
        494LL,
        v14);
      v16 = 1;
    }
  }
  ly_set_free(v24);
  sub_14F6B(v22);
  return v16;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 77E0: using guessed type __int64 __fastcall lyd_first_sibling(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000002F1BE) ----------------------------------------------------
__int64 __fastcall sub_2F1BE(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  int j; // [rsp+1Ch] [rbp-24h]
  __int64 i; // [rsp+20h] [rbp-20h]
  __int64 v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+30h] [rbp-10h]
  unsigned __int64 v7; // [rsp+38h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  for ( i = a1; *(_QWORD *)(*(_QWORD *)(i + 16) + 72LL); i = *(_QWORD *)(i + 16) + 56LL )
    ;
  if ( a2 == *(_DWORD *)i )
    return i;
  if ( *(_DWORD *)i != 9 || *(_BYTE *)(i + 4) & 1 )
  {
    if ( *(_DWORD *)i == 11 )
    {
      v5 = 0LL;
      for ( j = 0; ; j = 0 )
      {
        v5 = sub_3A9DE(i, v5, &j);
        if ( !v5 )
          break;
        v6 = sub_2F1BE(v5, a2);
        if ( v6 )
          return v6;
      }
    }
    result = 0LL;
  }
  else
  {
    if ( !*(_QWORD *)(i + 40) )
      __assert_fail(
        "type->info.lref.target",
        "/home/mantovan/Repositories/libyang/src/validation.c",
        0x229u,
        "find_orig_type");
    result = sub_2F1BE(*(_QWORD *)(i + 40) + 128LL, a2);
  }
  return result;
}

//----- (000000000002F304) ----------------------------------------------------
signed __int64 __fastcall sub_2F304(__int64 a1, unsigned __int8 a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  for ( i = 0; i < a2; ++i )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * i + a1) + 24LL) & 8
      && *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(8LL * i + a1) + 56LL) + 32LL)
      && (*(unsigned int (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(**(_QWORD **)(8LL * i + a1) + 56LL) + 32LL))(
           *(_QWORD *)(8LL * i + a1),
           v4) )
    {
      return 1LL;
    }
  }
  return 0LL;
}

//----- (000000000002F3D1) ----------------------------------------------------
signed __int64 __fastcall sub_2F3D1(__int64 a1, __int64 a2, unsigned int a3)
{
  signed __int64 result; // rax
  __int64 v4; // [rsp+10h] [rbp-20h]
  unsigned int j; // [rsp+24h] [rbp-Ch]
  unsigned int i; // [rsp+24h] [rbp-Ch]
  unsigned int k; // [rsp+24h] [rbp-Ch]

  v4 = a2;
  switch ( *(_DWORD *)a2 )
  {
    case 2:
      if ( !a3 )
        goto LABEL_35;
      v4 = sub_2F1BE(*(_QWORD *)a1 + 128LL, 2u);
      for ( i = 0; ; ++i )
      {
        if ( i >= *(_DWORD *)(v4 + 40) )
          goto LABEL_35;
        if ( *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64))
          && (unsigned int)sub_2F304(
                             *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 32LL),
                             *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 26LL),
                             a1) )
        {
          break;
        }
      }
      result = 1LL;
      break;
    case 4:
      if ( !*(_QWORD *)(a2 + 32)
        || !(unsigned int)sub_2F304(
                            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL),
                            *(_BYTE *)(*(_QWORD *)(a2 + 32) + 48LL),
                            a1) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    case 6:
      if ( !a3
        || !(unsigned int)sub_2F304(
                            *(_QWORD *)(*(_QWORD *)(a1 + 64) + 32LL),
                            *(_BYTE *)(*(_QWORD *)(a1 + 64) + 26LL),
                            a1) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    case 0xA:
      if ( *(_QWORD *)(a2 + 32)
        && (unsigned int)sub_2F304(
                           *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL),
                           *(_BYTE *)(*(_QWORD *)(a2 + 32) + 48LL),
                           a1) )
      {
        result = 1LL;
      }
      else
      {
        for ( j = 0; ; ++j )
        {
          if ( j >= *(_DWORD *)(a2 + 48) )
            goto LABEL_35;
          if ( (unsigned int)sub_2F304(
                               *(_QWORD *)(*(_QWORD *)(a2 + 40) + 56LL * j + 40),
                               *(_BYTE *)(*(_QWORD *)(a2 + 40) + 56LL * j + 48),
                               a1) )
            break;
        }
        result = 1LL;
      }
      break;
    case 0xB:
      for ( k = 0;
            k < *(_DWORD *)(a2 + 40)
         && *(_DWORD *)(((unsigned __int64)k << 6) + *(_QWORD *)(a2 + 32)) != *(_DWORD *)(a1 + 72);
            ++k )
      {
        ;
      }
      if ( k >= *(_DWORD *)(a2 + 40)
        || !(unsigned int)sub_2F3D1(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)k << 6), a3) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      if ( !*(_QWORD *)(a2 + 32)
        || !(unsigned int)sub_2F304(
                            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL),
                            *(_BYTE *)(*(_QWORD *)(a2 + 32) + 48LL),
                            a1) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    default:
LABEL_35:
      if ( (unsigned int)sub_2F304(*(_QWORD *)(v4 + 8), *(_BYTE *)(v4 + 5), a1) )
      {
        result = 1LL;
      }
      else
      {
        while ( *(_QWORD *)(*(_QWORD *)(v4 + 16) + 72LL) )
        {
          v4 = *(_QWORD *)(v4 + 16) + 56LL;
          if ( *(_WORD *)(*(_QWORD *)(v4 + 24) + 24LL) & 0x2000
            && ((unsigned int)sub_2F3D1(a1, v4, 0LL)
             || (unsigned int)sub_2F304(
                                *(_QWORD *)(*(_QWORD *)(v4 + 24) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(v4 + 24) + 26LL),
                                a1)) )
          {
            return 1LL;
          }
        }
        result = 0LL;
      }
      break;
  }
  return result;
}

//----- (000000000002F7BD) ----------------------------------------------------
signed __int64 __fastcall sub_2F7BD(char *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 l; // rax
  int v11; // eax
  __int64 v12; // [rsp+8h] [rbp-98h]
  __int16 v13; // [rsp+14h] [rbp-8Ch]
  unsigned __int8 v14; // [rsp+2Fh] [rbp-71h]
  unsigned int ii; // [rsp+30h] [rbp-70h]
  char v16; // [rsp+30h] [rbp-70h]
  unsigned int n; // [rsp+34h] [rbp-6Ch]
  __int64 v18; // [rsp+38h] [rbp-68h]
  __int64 v19; // [rsp+38h] [rbp-68h]
  _QWORD *i; // [rsp+40h] [rbp-60h]
  char *j; // [rsp+40h] [rbp-60h]
  __int64 m; // [rsp+40h] [rbp-60h]
  __int64 k; // [rsp+48h] [rbp-58h]
  __int64 v24; // [rsp+50h] [rbp-50h]
  __int64 v25; // [rsp+58h] [rbp-48h]
  const char *v26; // [rsp+60h] [rbp-40h]
  __int64 v27; // [rsp+68h] [rbp-38h]
  __int64 v28; // [rsp+78h] [rbp-28h]
  void *v29; // [rsp+80h] [rbp-20h]
  __int64 v30; // [rsp+88h] [rbp-18h]

  v13 = a2;
  v12 = a3;
  v24 = 0LL;
  n = 0;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/validation.c", 0x2B2u, "lyv_data_content");
  if ( !*(_QWORD *)a1 )
    __assert_fail("node->schema", "/home/mantovan/Repositories/libyang/src/validation.c", 0x2B3u, "lyv_data_content");
  if ( !a3 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/validation.c", 0x2B4u, "lyv_data_content");
  v28 = *(_QWORD *)a1;
  v29 = **(void ***)(*(_QWORD *)a1 + 48LL);
  if ( !(*(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x4180) )
  {
    for ( i = (_QWORD *)*((_QWORD *)a1 + 5); i && !(*(_DWORD *)(*i + 56LL) & 0x4180); i = (_QWORD *)i[5] )
      ;
    if ( !i && a2 & 0x50 )
      v13 = a2 | 0x2000;
  }
  if ( a1[8] & 4 )
  {
    if ( !(v13 & 0x2080) )
    {
      if ( *(_DWORD *)(v28 + 56) == 16 && !(v13 & 6) && (unsigned int)sub_2DB2D(a1) )
        return 1LL;
      if ( *(_DWORD *)(v28 + 56) & 0x8025 )
      {
        for ( j = (char *)lyd_first_sibling(a1); j; j = (char *)*((_QWORD *)j + 3) )
        {
          if ( v28 == *(_QWORD *)j && j != a1 )
          {
            v30 = lys_parent(v28);
            if ( v30 )
            {
              if ( *(_DWORD *)(v30 + 56) == 0x10000 )
                v7 = *(const char **)(v30 + 16);
              else
                v7 = *(const char **)v30;
            }
            else
            {
              v7 = "data tree";
            }
            sub_13937(v29, 14, 3u, a1, *(_QWORD *)v28, (__int64)v7);
            return 1LL;
          }
        }
      }
      if ( v13 & 0x800 )
      {
        v18 = *(_QWORD *)a1;
        do
        {
          if ( (*(_WORD *)(v18 + 24) & 0x38) == 32 && v13 & 0x800 )
          {
            sub_13937(v29, 44, 3u, a1, *(_QWORD *)v28, a6);
            return 1LL;
          }
          v18 = lys_parent(v18);
        }
        while ( v18 && !(*(_DWORD *)(v18 + 56) & 0x803D) );
        if ( *(_DWORD *)(v28 + 56) & 0xC )
        {
          if ( v13 & 0x800 )
          {
            for ( k = *(_QWORD *)(*(_QWORD *)a1 + 144LL); k; k = *(_QWORD *)(k + 72) )
            {
              if ( (*(_WORD *)(k + 24) & 0x38) == 32 )
              {
                sub_13937(v29, 45, 3u, a1, *(_QWORD *)v28, *(_QWORD *)k);
                return 1LL;
              }
            }
          }
          if ( *((_DWORD *)a1 + 18) == 7
            && (unsigned int)sub_3C749(
                               *(_WORD *)(v28 + 24),
                               *(void ***)(v28 + 48),
                               *(_QWORD *)v28,
                               *(_WORD *)(*((_QWORD *)a1 + 8) + 24LL),
                               *(_QWORD *)(*((_QWORD *)a1 + 8) + 48LL),
                               **((_QWORD **)a1 + 8),
                               0LL) )
          {
            sub_13937(v29, -2, 3u, a1, v8, v9);
            return 1LL;
          }
        }
      }
    }
    if ( *(_WORD *)(v28 + 24) & 0x2000 )
    {
      if ( (unsigned int)sub_2F304(*(_QWORD *)(v28 + 32), *(_BYTE *)(v28 + 26), (__int64)a1) )
        return 1LL;
      if ( *(_DWORD *)(v28 + 56) & 0xC )
      {
        v24 = v28 + 128;
        if ( (unsigned int)sub_2F3D1((__int64)a1, v28 + 128, 1u) )
          return 1LL;
      }
    }
    a1[8] &= 0xFBu;
  }
  if ( *(_DWORD *)(v28 + 56) & 0x4191 )
  {
    for ( l = lys_getnext(0LL, v28, 0LL, 0LL); ; l = lys_getnext(v19, v28, 0LL, 0LL) )
    {
      v19 = l;
      if ( !l )
        break;
      if ( *(_DWORD *)(l + 56) & 0x18 )
      {
        for ( m = *((_QWORD *)a1 + 8); m; m = *(_QWORD *)(m + 24) )
        {
          if ( l == *(_QWORD *)m && *(_BYTE *)(m + 8) & 1 )
          {
            if ( v13 & 0x2006 )
            {
              *(_BYTE *)(m + 8) &= 0xFEu;
              break;
            }
            if ( !(unsigned int)sub_2EE3F(m, *((_QWORD *)a1 + 8)) )
              break;
            return 1LL;
          }
        }
      }
    }
  }
  if ( a1[8] & 2 )
  {
    if ( v13 & 0x2000 )
    {
      a1[8] &= 0xFDu;
    }
    else if ( (unsigned int)sub_2CD1C(v12, (__int64)a1, 0x2000000) )
    {
      return 1LL;
    }
  }
  if ( *(_DWORD *)(v28 + 56) & 0xC )
  {
    v11 = *((_DWORD *)a1 + 18);
    switch ( v11 )
    {
      case 6:
        v26 = "Enum";
        v27 = *((_QWORD *)a1 + 7);
        v14 = *(_BYTE *)(*((_QWORD *)a1 + 8) + 27LL);
        v25 = *(_QWORD *)(*((_QWORD *)a1 + 8) + 40LL);
        break;
      case 7:
        v26 = "Identity";
        v27 = *((_QWORD *)a1 + 7);
        v14 = *(_BYTE *)(*((_QWORD *)a1 + 8) + 27LL);
        v25 = *(_QWORD *)(*((_QWORD *)a1 + 8) + 40LL);
        break;
      case 2:
        v26 = "Bit";
        v24 = sub_2F1BE(*(_QWORD *)a1 + 128LL, 2u);
        v14 = 0;
        for ( n = 0; n < *(_DWORD *)(v24 + 40); ++n )
        {
          if ( *(_QWORD *)(8LL * n + *((_QWORD *)a1 + 8)) )
          {
            v27 = **(_QWORD **)(8LL * n + *((_QWORD *)a1 + 8));
            v14 = *(_BYTE *)(*(_QWORD *)(8LL * n + *((_QWORD *)a1 + 8)) + 27LL);
            v25 = *(_QWORD *)(*(_QWORD *)(8LL * n + *((_QWORD *)a1 + 8)) + 40LL);
            goto LABEL_90;
          }
LABEL_84:
          ;
        }
        break;
      default:
        v14 = 0;
        break;
    }
LABEL_90:
    if ( v14 )
    {
      for ( ii = 0; ii < v14; ++ii )
      {
        if ( !(unsigned int)sub_18D14(32LL * ii + v25) )
        {
          sub_13937(v29, 50, 3u, a1, *((_QWORD *)a1 + 7), *(_QWORD *)v28);
          sub_13937(v29, -1, 5u, 0LL, (__int64)"%s \"%s\" is disabled by its if-feature condition.", (__int64)v26, v27);
          return 1LL;
        }
      }
      if ( *((_DWORD *)a1 + 18) == 2 )
      {
        v14 = 0;
        goto LABEL_84;
      }
    }
  }
  if ( v13 & 0x208E )
    goto LABEL_107;
  v16 = sub_28087(a1);
  if ( v16 & 1 && (unsigned int)sub_2CD1C(v12, (__int64)a1, 0x400000) )
    return 1LL;
  if ( v16 & 2 && (unsigned int)sub_2CD1C(v12, (__int64)a1, 0x800000) )
    result = 1LL;
  else
LABEL_107:
    result = 0LL;
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77E0: using guessed type __int64 __fastcall lyd_first_sibling(_QWORD);

//----- (000000000003010D) ----------------------------------------------------
signed __int64 __fastcall sub_3010D(__int64 *a1, __int64 a2, char **a3, int a4, char *a5)
{
  __int64 v6; // r9
  char v7; // al
  char *v8; // [rsp+8h] [rbp-58h]
  int v9; // [rsp+14h] [rbp-4Ch]
  char **v10; // [rsp+18h] [rbp-48h]
  __int64 v11; // [rsp+20h] [rbp-40h]
  __int64 i; // [rsp+30h] [rbp-30h]
  __int64 k; // [rsp+30h] [rbp-30h]
  __int64 *v14; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  char *v16; // [rsp+48h] [rbp-18h]
  char *j; // [rsp+50h] [rbp-10h]
  __int64 v18; // [rsp+58h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( !a1 && !a2 )
    __assert_fail(
      "node || schemanode",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x382u,
      "lyv_multicases");
  if ( !a2 )
    v11 = *a1;
  for ( i = lys_parent(v11); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( !i || !(*(_DWORD *)(i + 56) & 0x42) )
    return 0LL;
  if ( !v10 || !*v10 )
    return 0LL;
  if ( *(_DWORD *)(i + 56) == 2 )
  {
    v14 = (__int64 *)i;
    v15 = v11;
  }
  else
  {
    v14 = (__int64 *)lys_parent(i);
    v15 = i;
  }
  while ( 1 )
  {
    for ( j = *v10; ; j = v16 )
    {
      if ( j )
      {
        v16 = (char *)*((_QWORD *)j + 3);
        v7 = 1;
      }
      else
      {
        v7 = 0;
      }
      if ( !v7 )
        break;
      if ( v11 != *(_QWORD *)j )
      {
        for ( k = lys_parent(*(_QWORD *)j); k && *(_DWORD *)(k + 56) == 4096; k = lys_parent(k) )
          ;
        if ( k
          && (*(_DWORD *)(k + 56) == 2 && (__int64 *)k == v14
           || *(_DWORD *)(k + 56) == 64 && k != v15 && v14 == (__int64 *)lys_parent(k)) )
        {
          if ( !v9 )
          {
            sub_13937(**(void ***)(v11 + 48), 57, 3u, j, *v14, v6);
            return 1LL;
          }
          if ( j == v8 )
          {
            sub_13937(**(void ***)(v11 + 48), 57, 3u, j, *v14, v6);
            return 2LL;
          }
          if ( j == *v10 )
            *v10 = v16;
          lyd_free(j);
        }
      }
    }
    if ( !*v10 )
      break;
    v18 = lys_parent(v14);
    if ( !v18 || !(*(_DWORD *)(v18 + 56) & 0x40) )
      break;
    v14 = (__int64 *)lys_parent(v18);
    v15 = v18;
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000303F5) ----------------------------------------------------
__int64 __fastcall lyxml_get_ns(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  char *s2; // [rsp+0h] [rbp-20h]
  __int64 i; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_get_ns", a4, a5, a6, a2);
  if ( !a1 )
    return 0LL;
  for ( i = *(_QWORD *)(a1 + 16); ; i = *(_QWORD *)(i + 8) )
  {
    if ( !i )
      return lyxml_get_ns(*(_QWORD *)(a1 + 8), s2);
    if ( *(_DWORD *)i == 2 )
      break;
LABEL_13:
    ;
  }
  if ( *(_QWORD *)(i + 24) )
  {
    if ( s2 && !strcmp(*(const char **)(i + 24), s2) )
      return i;
    goto LABEL_13;
  }
  if ( s2 )
    goto LABEL_13;
  if ( *(_QWORD *)(i + 32) )
    result = i;
  else
    result = 0LL;
  return result;
}
// 7890: using guessed type __int64 __fastcall lyxml_get_ns(_QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (00000000000304CF) ----------------------------------------------------
unsigned int *__fastcall sub_304CF(__int64 a1, unsigned int *a2, __int64 a3, int a4)
{
  unsigned int *result; // rax
  unsigned int *v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  result = (unsigned int *)*a2;
  if ( (_DWORD)result != 2 )
  {
    result = (unsigned int *)*((_QWORD *)a2 + 2);
    if ( result )
    {
      for ( i = a3; *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
        ;
      for ( j = *(_QWORD *)(*((_QWORD *)a2 + 2) + 16LL); *(_QWORD *)(j + 8); j = *(_QWORD *)(j + 8) )
        ;
      result = (unsigned int *)j;
      if ( j != i )
      {
        if ( a4 )
        {
          v9 = *((_QWORD *)a2 + 2);
          *((_QWORD *)a2 + 2) = lyxml_get_ns(a3, *(_QWORD *)(v9 + 24));
          result = (unsigned int *)*((_QWORD *)a2 + 2);
          if ( !result )
          {
            v5 = sub_305D2(a1, v6, v9);
            result = a2;
            *((_QWORD *)a2 + 2) = v5;
          }
        }
        else
        {
          result = a2;
          *((_QWORD *)a2 + 2) = 0LL;
        }
      }
    }
  }
  return result;
}
// 7890: using guessed type __int64 __fastcall lyxml_get_ns(_QWORD, _QWORD);

//----- (00000000000305D2) ----------------------------------------------------
unsigned int *__fastcall sub_305D2(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *result; // rax
  __int64 v4; // r9
  __int64 v5; // [rsp+8h] [rbp-28h]
  unsigned int *v6; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v5 = a3;
  if ( !a3 || !a2 )
    return 0LL;
  v6 = (unsigned int *)calloc(1uLL, 0x28uLL);
  if ( v6 )
  {
    *((_QWORD *)v6 + 4) = lydict_insert(a1, *(_QWORD *)(v5 + 32), 0LL);
    *((_QWORD *)v6 + 3) = lydict_insert(a1, *(_QWORD *)(v5 + 24), 0LL);
    *v6 = *(_DWORD *)v5;
    if ( *v6 == 1 && *(_QWORD *)(v5 + 16) )
    {
      *((_QWORD *)v6 + 2) = *(_QWORD *)(v5 + 16);
      sub_304CF(a1, v6, a2, 1);
    }
    if ( *v6 == 2 )
      *((_QWORD *)v6 + 2) = a2;
    if ( *(_QWORD *)(a2 + 16) )
    {
      for ( i = *(_QWORD *)(a2 + 16); *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
        ;
      *(_QWORD *)(i + 8) = v6;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = v6;
    }
    result = v6;
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_dup_attr", v4);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000030771) ----------------------------------------------------
_QWORD *__fastcall sub_30771(__int64 a1, _QWORD *a2, int a3, int a4)
{
  _QWORD *result; // rax
  int v5; // [rsp+8h] [rbp-48h]
  int v6; // [rsp+Ch] [rbp-44h]
  _QWORD *j; // [rsp+20h] [rbp-30h]
  __int64 l; // [rsp+28h] [rbp-28h]
  _QWORD *v9; // [rsp+30h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-18h]
  __int64 k; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  for ( i = (__int64)a2; *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
    ;
  result = a2;
  for ( j = a2; j; j = v9 )
  {
    if ( j[7] )
    {
      for ( k = *(_QWORD *)(j[7] + 16LL); k; k = *(_QWORD *)(k + 8) )
        ;
      if ( 0 != i )
      {
        if ( v6 )
        {
          v12 = j[7];
          j[7] = lyxml_get_ns(j, *(_QWORD *)(v12 + 24));
          if ( !j[7] )
            j[7] = sub_305D2(a1, (__int64)j, v12);
        }
        else
        {
          j[7] = 0LL;
        }
      }
    }
    if ( v5 )
    {
      for ( l = j[2]; l; l = *(_QWORD *)(l + 8) )
        sub_304CF(a1, (unsigned int *)l, i, v6);
    }
    v9 = (_QWORD *)j[3];
    if ( !v9 )
    {
      result = j;
      if ( j == a2 )
        return result;
      v9 = (_QWORD *)j[4];
    }
    while ( !v9 )
    {
      j = (_QWORD *)j[1];
      if ( j[1] == a2[1] )
        break;
      v9 = (_QWORD *)j[4];
    }
    result = v9;
  }
  return result;
}
// 7890: using guessed type __int64 __fastcall lyxml_get_ns(_QWORD, _QWORD);

//----- (0000000000030929) ----------------------------------------------------
_QWORD *__fastcall sub_30929(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5)
{
  __int64 v6; // r9
  unsigned __int64 v7; // [rsp+0h] [rbp-40h]
  __int64 v8; // [rsp+8h] [rbp-38h]
  __int64 v9; // [rsp+10h] [rbp-30h]
  _QWORD *v10; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+30h] [rbp-10h]
  _QWORD *v12; // [rsp+38h] [rbp-8h]

  v9 = a2;
  v8 = a3;
  v7 = __PAIR__(a4, a5);
  v10 = 0LL;
  if ( !a2 )
    return 0LL;
  while ( v9 )
  {
    v12 = calloc(1uLL, 0x48uLL);
    if ( !v12 )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_dup_elem", v6, v7);
      return 0LL;
    }
    v12[8] = lydict_insert(a1, *(_QWORD *)(v9 + 64), 0LL);
    v12[6] = lydict_insert(a1, *(_QWORD *)(v9 + 48), 0LL);
    *(_BYTE *)v12 = *(_BYTE *)v9;
    v12[5] = v12;
    if ( v8 )
    {
      sub_3116F(a1, v8, v12);
    }
    else if ( v10 )
    {
      v12[5] = v10[5];
      *(_QWORD *)(v12[5] + 32LL) = v12;
      v10[5] = v12;
    }
    v12[7] = *(_QWORD *)(v9 + 56);
    for ( i = *(_QWORD *)(v9 + 16); i; i = *(_QWORD *)(i + 8) )
      sub_305D2(a1, (__int64)v12, i);
    sub_30771(a1, v12, 1, 0);
    if ( HIDWORD(v7) )
      sub_30929(a1, *(_QWORD *)(v9 + 24), v12, 1LL, 1LL);
    if ( !v10 )
      v10 = v12;
    if ( !(_DWORD)v7 )
      break;
    v9 = *(_QWORD *)(v9 + 32);
  }
  return v10;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000030B28) ----------------------------------------------------
_QWORD *__fastcall lyxml_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST00_8
  __int64 v7; // ST08_8

  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_dup", a4, a5, a6, a2, a1);
  return sub_30929(v7, v6, 0LL, 1u, 0);
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000030B77) ----------------------------------------------------
_QWORD *__fastcall sub_30B77(__int64 a1, _QWORD *a2, int a3)
{
  _QWORD *result; // rax
  _QWORD *i; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  if ( a2 )
  {
    v5 = a2[1];
    if ( v5 )
    {
      if ( a2 == *(_QWORD **)(v5 + 24) )
        *(_QWORD *)(v5 + 24) = a2[4];
      a2[1] = 0LL;
    }
    if ( a3 <= 1 )
      sub_30771(a1, a2, a3, 1);
    result = (_QWORD *)a2[5];
    if ( a2 != result )
    {
      if ( a2[4] )
      {
        *(_QWORD *)(a2[4] + 40LL) = a2[5];
      }
      else
      {
        if ( v5 )
        {
          i = *(_QWORD **)(v5 + 24);
        }
        else
        {
          for ( i = a2; *(_QWORD *)(i[5] + 32LL); i = (_QWORD *)i[5] )
            ;
        }
        i[5] = a2[5];
      }
      if ( *(_QWORD *)(a2[5] + 32LL) )
        *(_QWORD *)(a2[5] + 32LL) = a2[4];
      a2[4] = 0LL;
      result = a2;
      a2[5] = a2;
    }
  }
  return result;
}

//----- (0000000000030CB6) ----------------------------------------------------
unsigned __int64 __fastcall lyxml_unlink(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  _QWORD *v7; // [rsp+0h] [rbp-10h]

  result = sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_unlink", a4, a5, a6, a2);
  if ( v7 )
    result = (unsigned __int64)sub_30B77(a1, v7, 1);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000030D07) ----------------------------------------------------
void __fastcall sub_30D07(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *ptr; // [rsp+8h] [rbp-28h]
  _QWORD *i; // [rsp+20h] [rbp-10h]
  _QWORD *v5; // [rsp+28h] [rbp-8h]

  ptr = a3;
  if ( a3 )
  {
    if ( !a2 )
    {
LABEL_11:
      lydict_remove(a1, a3[3]);
      lydict_remove(a1, ptr[4]);
      free(ptr);
      return;
    }
    v5 = 0LL;
    for ( i = *(_QWORD **)(a2 + 16); i && i != a3; i = (_QWORD *)i[1] )
      v5 = i;
    if ( i )
    {
      if ( v5 )
        v5[1] = a3[1];
      else
        *(_QWORD *)(a2 + 16) = a3[1];
      goto LABEL_11;
    }
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000030DDD) ----------------------------------------------------
_QWORD *__fastcall sub_30DDD(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  _QWORD *v3; // ST18_8
  _QWORD *ptr; // [rsp+10h] [rbp-10h]

  if ( a2 )
  {
    result = *(_QWORD **)(a2 + 16);
    if ( result )
    {
      ptr = *(_QWORD **)(a2 + 16);
      do
      {
        v3 = (_QWORD *)ptr[1];
        lydict_remove(a1, ptr[3]);
        lydict_remove(a1, ptr[4]);
        free(ptr);
        result = v3;
        ptr = v3;
      }
      while ( v3 );
    }
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000030E67) ----------------------------------------------------
void __fastcall sub_30E67(__int64 a1, _QWORD *a2)
{
  char v2; // al
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  if ( a2 )
  {
    sub_30DDD(a1, (__int64)a2);
    for ( i = a2[3]; ; i = v4 )
    {
      if ( i )
      {
        v4 = *(_QWORD *)(i + 32);
        v2 = 1;
      }
      else
      {
        v2 = 0;
      }
      if ( !v2 )
        break;
      sub_30E67(a1, i);
    }
    lydict_remove(a1, a2[6]);
    lydict_remove(a1, a2[8]);
    free(a2);
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000030F20) ----------------------------------------------------
void __fastcall lyxml_free(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_free", a4, a5, a6, a2);
  if ( v6 )
  {
    sub_30B77(a1, v6, 2);
    sub_30E67(a1, v6);
  }
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000030F84) ----------------------------------------------------
unsigned __int64 __fastcall lyxml_free_withsiblings(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-20h]
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 j; // [rsp+10h] [rbp-10h]
  __int64 v10; // [rsp+18h] [rbp-8h]

  result = sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_free_withsiblings", a4, a5, a6, a2);
  if ( v7 )
  {
    for ( i = *(_QWORD *)(v7 + 40); *(_QWORD *)(i + 32); i = v10 )
    {
      v10 = *(_QWORD *)(i + 40);
      lyxml_free(a1, i);
    }
    for ( j = v7; ; j = v10 )
    {
      if ( j )
      {
        v10 = *(_QWORD *)(j + 32);
        result = 1LL;
      }
      else
      {
        result = 0LL;
      }
      if ( !(_BYTE)result )
        break;
      lyxml_free(a1, j);
    }
  }
  return result;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (000000000003104B) ----------------------------------------------------
__int64 __fastcall lyxml_get_attr(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v7; // [rsp+8h] [rbp-28h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v7 = a3;
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_get_attr", a4, a5, a6);
  if ( !a1 )
    __assert_fail("elem", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1BCu, "lyxml_get_attr");
  if ( !a2 )
    __assert_fail("name", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1BDu, "lyxml_get_attr");
  for ( i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(i + 8) )
  {
    if ( *(_DWORD *)i == 1
      && !strcmp(a2, *(const char **)(i + 24))
      && (!v7 && !*(_QWORD *)(i + 16)
       || v7 && *(_QWORD *)(i + 16) && !strcmp(v7, *(const char **)(*(_QWORD *)(i + 16) + 32LL))) )
    {
      return *(_QWORD *)(i + 32);
    }
  }
  return 0LL;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (000000000003116F) ----------------------------------------------------
__int64 __fastcall sub_3116F(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // ST28_8
  _QWORD *v5; // [rsp+8h] [rbp-28h]

  v5 = a3;
  if ( !a2 )
    __assert_fail("parent", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1D3u, "lyxml_add_child");
  if ( !a3 )
    __assert_fail("elem", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1D4u, "lyxml_add_child");
  if ( a3[1] )
    sub_30B77(a1, a3, 1);
  v5[1] = a2;
  if ( *(_QWORD *)(a2 + 24) )
  {
    v3 = *(_QWORD *)(a2 + 24);
    v5[5] = *(_QWORD *)(v3 + 40);
    v5[4] = 0LL;
    *(_QWORD *)(v5[5] + 32LL) = v5;
    *(_QWORD *)(v3 + 40) = v5;
  }
  else
  {
    *(_QWORD *)(a2 + 24) = v5;
    v5[5] = v5;
    v5[4] = 0LL;
  }
  return 0LL;
}

//----- (000000000003127E) ----------------------------------------------------
__int64 __fastcall sub_3127E(void *a1, char *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v7; // ST2C_1
  char v8; // ST2C_1
  char v9; // ST2C_1
  int v10; // [rsp+24h] [rbp-Ch]
  signed int i; // [rsp+28h] [rbp-8h]
  signed int j; // [rsp+28h] [rbp-8h]

  v10 = *a2;
  *a3 = 0;
  if ( !v10 )
  {
    sub_13937(a1, 4, 0, 0LL, a5, a6);
    return 0LL;
  }
  *a3 = 1;
  if ( (v10 & 0xF8) == 240 )
  {
    *a3 = 4;
    v10 &= 7u;
    for ( i = 1; i <= 3; ++i )
    {
      v7 = a2[i];
      if ( (v7 & 0xC0) != 128 )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
        return 0LL;
      }
      v10 = (v10 << 6) | a2[i] & 0x3F;
    }
    if ( v10 <= 4095 || v10 > 1114111 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  else if ( (v10 & 0xF0) == 224 )
  {
    *a3 = 3;
    v10 &= 0xFu;
    for ( j = 1; j <= 2; ++j )
    {
      v8 = a2[j];
      if ( (v8 & 0xC0) != 128 )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
        return 0LL;
      }
      v10 = (v10 << 6) | a2[j] & 0x3F;
    }
    if ( v10 <= 2047 || v10 > 55295 && v10 <= 57343 || v10 > 65533 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  else if ( (v10 & 0xE0) == 192 )
  {
    *a3 = 2;
    v9 = a2[1];
    if ( (v9 & 0xC0) != 128 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
    v10 = ((_WORD)v10 << 6) & 0x7C0 | a2[1] & 0x3F;
    if ( v10 <= 127 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  else
  {
    if ( v10 & 0x80 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
    if ( v10 <= 31 && v10 != 9 && v10 != 10 && v10 != 13 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  return (unsigned int)v10;
}

//----- (0000000000031603) ----------------------------------------------------
signed __int64 __fastcall sub_31603(void *a1, const char *a2, const char *a3, _DWORD *a4)
{
  signed __int64 result; // rax
  _DWORD *v5; // [rsp+0h] [rbp-30h]
  char *s; // [rsp+8h] [rbp-28h]
  unsigned int n; // [rsp+24h] [rbp-Ch]
  const char *n_4; // [rsp+28h] [rbp-8h]

  s = (char *)a3;
  v5 = a4;
  n_4 = a2;
  n = strlen(a3);
  while ( *n_4 && strncmp(n_4, s, n) )
    ++n_4;
  if ( *n_4 )
  {
    *v5 = n + (_DWORD)n_4 - (_DWORD)a2;
    result = 0LL;
  }
  else
  {
    sub_13937(a1, 1, 0, 0LL, (__int64)"closing sequence", (__int64)s, v5);
    result = 1LL;
  }
  return result;
}

//----- (00000000000316C2) ----------------------------------------------------
char *__fastcall sub_316C2(void *a1, __int64 a2, char a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned int v12; // eax
  int v13; // eax
  __int64 v14; // r9
  __int64 v15; // r9
  _DWORD *v16; // [rsp+0h] [rbp-460h]
  char v17; // [rsp+Ch] [rbp-454h]
  int v18; // [rsp+2Ch] [rbp-434h]
  int v19; // [rsp+2Ch] [rbp-434h]
  int v20; // [rsp+2Ch] [rbp-434h]
  int v21; // [rsp+30h] [rbp-430h]
  int v22; // [rsp+34h] [rbp-42Ch]
  signed int v23; // [rsp+38h] [rbp-428h]
  signed int v24; // [rsp+3Ch] [rbp-424h]
  char *ptr; // [rsp+40h] [rbp-420h]
  char src[1032]; // [rsp+50h] [rbp-410h]
  unsigned __int64 v27; // [rsp+458h] [rbp-8h]

  v16 = a4;
  v17 = a3;
  v27 = __readfsqword(0x28u);
  ptr = 0LL;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  *a4 = 0;
  while ( v23 || v17 != *(_BYTE *)((unsigned int)*v16 + a2) )
  {
    if ( !*(_BYTE *)((unsigned int)*v16 + a2) || !v23 && !strncmp((const char *)((unsigned int)*v16 + a2), "]]>", 3uLL) )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"element content, \"]]>\" found", a6, v16);
LABEL_75:
      *v16 = 0;
      free(ptr);
      return 0LL;
    }
LABEL_6:
    if ( v21 > 1020 )
    {
      if ( ptr )
      {
        v22 += v21;
        ptr = (char *)sub_C422(ptr, v22 + 1);
      }
      else
      {
        v22 = v21;
        ptr = (char *)malloc(v21 + 1);
      }
      if ( !ptr )
      {
        sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_text", v6, v16);
        return 0LL;
      }
      memcpy(&ptr[v22 - v21], src, v21);
      v21 = 0;
    }
    if ( v23 || !strncmp((const char *)((unsigned int)*v16 + a2), "<![CDATA[", 9uLL) )
    {
      if ( !v23 )
      {
        v23 = 1;
        *v16 += 9;
      }
      if ( *(_BYTE *)((unsigned int)*v16 + a2) && !strncmp((const char *)((unsigned int)*v16 + a2), "]]>", 3uLL) )
      {
        *v16 += 3;
        v23 = 0;
        --v21;
      }
      else
      {
        src[v21] = *(_BYTE *)((unsigned int)(*v16)++ + a2);
      }
    }
    else if ( *(_BYTE *)((unsigned int)*v16 + a2) == 38 )
    {
      if ( *(_BYTE *)((unsigned int)++*v16 + a2) == 35 )
      {
        if ( (*__ctype_b_loc())[*(char *)((unsigned int)++*v16 + a2)] & 0x800 )
        {
          v24 = 0;
          while ( (*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x800 )
            v24 = 10 * v24 + *(char *)((unsigned int)(*v16)++ + a2) - 48;
          if ( *(_BYTE *)((unsigned int)*v16 + a2) != 59 )
          {
            sub_13937(a1, 2, 0, 0LL, (__int64)"character reference, missing semicolon", v11, v16);
            goto LABEL_75;
          }
        }
        else
        {
          v12 = (*v16)++;
          if ( *(_BYTE *)(v12 + a2) != 120 || !((*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x1000) )
          {
            sub_13937(a1, 2, 0, 0LL, (__int64)"character reference", v9, v16);
            goto LABEL_75;
          }
          v24 = 0;
          while ( (*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x1000 )
          {
            if ( (*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x800 )
            {
              v18 = *(char *)((unsigned int)*v16 + a2) - 48;
            }
            else
            {
              if ( *(_BYTE *)((unsigned int)*v16 + a2) <= 70 )
                v13 = *(char *)((unsigned int)*v16 + a2) - 55;
              else
                v13 = *(char *)((unsigned int)*v16 + a2) - 87;
              v18 = v13;
            }
            v24 = 16 * v24 + v18;
            ++*v16;
          }
        }
        v19 = sub_40272(a1, &src[v21], v24, (__int64)&src[v21], v10, v11);
        if ( !v19 )
        {
          sub_13937(a1, 2, 0, 0LL, (__int64)"character reference value", a6, v16);
          goto LABEL_75;
        }
        v21 = v21 + v19 - 1;
        ++*v16;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "lt;", 3uLL) )
      {
        src[v21] = 60;
        *v16 += 3;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "gt;", 3uLL) )
      {
        src[v21] = 62;
        *v16 += 3;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "amp;", 4uLL) )
      {
        src[v21] = 38;
        *v16 += 4;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "apos;", 5uLL) )
      {
        src[v21] = 39;
        *v16 += 5;
      }
      else
      {
        if ( strncmp((const char *)((unsigned int)*v16 + a2), "quot;", 5uLL) )
        {
          sub_13937(a1, 2, 0, 0LL, (__int64)"entity reference (only predefined references are supported)", a6, v16);
          goto LABEL_75;
        }
        src[v21] = 34;
        *v16 += 5;
      }
    }
    else
    {
      v20 = sub_40445(a1, (__int64)&src[v21], (char *)(a2 + (unsigned int)*v16), (__int64)&src[v21], v8, a6);
      if ( !v20 )
        goto LABEL_75;
      v21 = v21 + v20 - 1;
      *v16 += v20;
    }
    ++v21;
  }
  if ( v17 == 60 && !strncmp((const char *)((unsigned int)*v16 + a2), "<![CDATA[", 9uLL) )
    goto LABEL_6;
  if ( v21 )
  {
    if ( ptr )
    {
      v22 += v21;
      ptr = (char *)realloc(ptr, v22 + 1);
    }
    else
    {
      v22 = v21;
      ptr = (char *)malloc(v21 + 1);
    }
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_text", v14, v16);
      return 0LL;
    }
    memcpy(&ptr[v22 - v21], src, v21);
  }
  if ( ptr )
  {
    ptr[v22] = 0;
  }
  else
  {
    ptr = strdup(&byte_10CE4D);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_text", v15, v16);
      return 0LL;
    }
  }
  return ptr;
}
// 316C2: using guessed type char src[1032];

//----- (000000000003223C) ----------------------------------------------------
void *__fastcall sub_3223C(void *a1, char *a2, _DWORD *a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // rax
  __int64 v13; // rax
  char v14; // dl
  __int64 v15; // rax
  __int64 v16; // [rsp+0h] [rbp-70h]
  _DWORD *v17; // [rsp+8h] [rbp-68h]
  char v18; // [rsp+27h] [rbp-49h]
  unsigned int v19; // [rsp+28h] [rbp-48h]
  int i; // [rsp+2Ch] [rbp-44h]
  char *s1; // [rsp+30h] [rbp-40h]
  char *v22; // [rsp+38h] [rbp-38h]
  void *dest; // [rsp+40h] [rbp-30h]
  void *ptr; // [rsp+48h] [rbp-28h]
  __int64 j; // [rsp+50h] [rbp-20h]
  char *v26; // [rsp+58h] [rbp-18h]
  char *v27; // [rsp+60h] [rbp-10h]
  unsigned __int64 v28; // [rsp+68h] [rbp-8h]

  v17 = a3;
  v16 = a4;
  v28 = __readfsqword(0x28u);
  s1 = a2;
  dest = 0LL;
  ptr = 0LL;
  if ( !strncmp(a2, "xmlns", 5uLL) )
  {
    ptr = calloc(1uLL, 0x28uLL);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_attr", v5, v16);
      return 0LL;
    }
    *(_DWORD *)ptr = 2;
    *((_QWORD *)ptr + 2) = v16;
    s1 += 5;
    if ( *s1 != 58 )
      goto LABEL_92;
    ++s1;
  }
  else
  {
    ptr = calloc(1uLL, 0x28uLL);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_attr", v5, v16);
      return 0LL;
    }
    *(_DWORD *)ptr = 1;
  }
  v22 = s1;
  i = sub_3127E(a1, s1, &v19, (__int64)s1, v4, v5);
  if ( (i <= 96 || i > 122)
    && i != 95
    && (i <= 64 || i > 90)
    && i != 58
    && (i <= 879 || i > 0x1FFF || i == 894)
    && (i <= 191 || i > 767 || i == 215 || i == 247)
    && i != 8204
    && i != 8205
    && (i <= 8303 || i > 8591)
    && (i <= 11263 || i > 12271)
    && (i <= 12288 || i > 55295)
    && (i <= 63743 || i > 64975)
    && (i <= 65007 || i > 65533)
    && (i <= 0xFFFF || i > (signed int)&loc_EFFFF) )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"NameStartChar of the attribute", v8, v16);
    free(ptr);
    return 0LL;
  }
  v18 = 4;
  if ( *s1 == 120 )
    v18 = 1;
  s1 += v19;
  for ( i = sub_3127E(a1, s1, &v19, (__int64)s1, v7, v8);
        i > 96 && i <= 122
     || i == 95
     || i == 45
     || i > 64 && i <= 90
     || i > 47 && i <= 57
     || i == 58
     || i == 46
     || i == 183
     || i > 879 && i <= 0x1FFF && i != 894
     || i > 191 && i <= 767 && i != 215 && i != 247
     || i == 8204
     || i == 8205
     || i > 767 && i <= 879
     || i > 8303 && i <= 8591
     || i > 131854 && i <= 8256
     || i > 11263 && i <= 12271
     || i > 12288 && i <= 55295
     || i > 63743 && i <= 64975
     || i > 65007 && i <= 65533
     || i > 0xFFFF && i <= (signed int)&loc_EFFFF;
        i = sub_3127E(a1, s1, &v19, (__int64)s1, v9, v10) )
  {
    if ( *(_DWORD *)ptr == 1 )
    {
      if ( *s1 != 58 || v18 == 3 )
      {
        if ( (*s1 != 109 || v18 != 1) && (*s1 != 108 || v18 != 2) )
          v18 = 4;
        else
          ++v18;
      }
      else
      {
        v22 = s1 + 1;
        dest = malloc(s1 - a2 + 1);
        if ( !dest )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_attr", v11, v16);
          goto LABEL_117;
        }
        memcpy(dest, a2, s1 - a2);
        *((_BYTE *)dest + s1 - a2) = 0;
        v12 = lyxml_get_ns(v16, dest);
        *((_QWORD *)ptr + 2) = v12;
      }
    }
    s1 += v19;
  }
  v19 = (_DWORD)s1 - (_DWORD)v22;
  v13 = lydict_insert(a1, v22, (unsigned int)((_DWORD)s1 - (_DWORD)v22));
  *((_QWORD *)ptr + 3) = v13;
LABEL_92:
  while ( *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13 )
    ++s1;
  if ( *s1 != 61 )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"attribute definition, \"=\" expected", v5, v16);
LABEL_117:
    sub_30D07((__int64)a1, 0LL, ptr);
    free(dest);
    return 0LL;
  }
  ++s1;
  while ( *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13 )
    ++s1;
  if ( !*s1 || *s1 != 34 && *s1 != 39 )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"attribute value, \" or ' expected", v5, v16);
    goto LABEL_117;
  }
  v26 = s1;
  v14 = *s1++;
  v27 = sub_316C2(a1, (__int64)s1, v14, &v19, v4, v5);
  if ( !v27 && !v19 )
    goto LABEL_117;
  v15 = lydict_insert_zc(a1, v27);
  *((_QWORD *)ptr + 4) = v15;
  *v17 = v19 + 1 + (_DWORD)s1 - (_DWORD)a2;
  if ( *(_QWORD *)(v16 + 16) )
  {
    for ( j = *(_QWORD *)(v16 + 16); *(_QWORD *)(j + 8); j = *(_QWORD *)(j + 8) )
      ;
    *(_QWORD *)(j + 8) = ptr;
  }
  else
  {
    *(_QWORD *)(v16 + 16) = ptr;
  }
  free(dest);
  return ptr;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7890: using guessed type __int64 __fastcall lyxml_get_ns(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000032A07) ----------------------------------------------------
char *__fastcall sub_32A07(void *a1, void *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v24; // r9
  __int64 v25; // rax
  __int64 v26; // r9
  __int64 v27; // r9
  void *v28; // rax
  __int64 v29; // rax
  unsigned int v30; // [rsp+Ch] [rbp-A4h]
  __int64 v31; // [rsp+10h] [rbp-A0h]
  _DWORD *v32; // [rsp+18h] [rbp-98h]
  size_t v33; // [rsp+3Ch] [rbp-74h]
  size_t n; // [rsp+44h] [rbp-6Ch]
  int v35; // [rsp+4Ch] [rbp-64h]
  void *src; // [rsp+50h] [rbp-60h]
  char *v37; // [rsp+58h] [rbp-58h]
  void *v38; // [rsp+60h] [rbp-50h]
  void *dest; // [rsp+68h] [rbp-48h]
  char *v40; // [rsp+70h] [rbp-40h]
  void *v41; // [rsp+78h] [rbp-38h]
  _QWORD *v42; // [rsp+80h] [rbp-30h]
  void *s1; // [rsp+88h] [rbp-28h]
  void *v44; // [rsp+90h] [rbp-20h]
  unsigned __int64 v45; // [rsp+98h] [rbp-18h]

  v32 = a3;
  v31 = a4;
  v30 = a5;
  v45 = __readfsqword(0x28u);
  src = a2;
  dest = 0LL;
  n = 0LL;
  v40 = 0LL;
  v35 = 0;
  *a3 = 0;
  if ( *(_BYTE *)src != 60 )
    return 0LL;
  src = (char *)src + 1;
  v37 = (char *)src;
  HIDWORD(v33) = sub_3127E(a1, (char *)src, &v33, (__int64)src, a5, a6);
  if ( (SHIDWORD(v33) <= 96 || SHIDWORD(v33) > 122)
    && HIDWORD(v33) != 95
    && (SHIDWORD(v33) <= 64 || SHIDWORD(v33) > 90)
    && HIDWORD(v33) != 58
    && (SHIDWORD(v33) <= 879 || SHIDWORD(v33) > 0x1FFF || HIDWORD(v33) == 894)
    && (SHIDWORD(v33) <= 191 || SHIDWORD(v33) > 767 || HIDWORD(v33) == 215 || HIDWORD(v33) == 247)
    && HIDWORD(v33) != 8204
    && HIDWORD(v33) != 8205
    && (SHIDWORD(v33) <= 8303 || SHIDWORD(v33) > 8591)
    && (SHIDWORD(v33) <= 11263 || SHIDWORD(v33) > 12271)
    && (SHIDWORD(v33) <= 12288 || SHIDWORD(v33) > 55295)
    && (SHIDWORD(v33) <= 63743 || SHIDWORD(v33) > 64975)
    && (SHIDWORD(v33) <= 65007 || SHIDWORD(v33) > 65533)
    && (SHIDWORD(v33) <= 0xFFFF || SHIDWORD(v33) > (signed int)&loc_EFFFF) )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"NameStartChar of the element", v8);
    return 0LL;
  }
  v37 += (unsigned int)v33;
  for ( HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v7, v8);
        SHIDWORD(v33) > 96 && SHIDWORD(v33) <= 122
     || HIDWORD(v33) == 95
     || HIDWORD(v33) == 45
     || SHIDWORD(v33) > 64 && SHIDWORD(v33) <= 90
     || SHIDWORD(v33) > 47 && SHIDWORD(v33) <= 57
     || HIDWORD(v33) == 58
     || HIDWORD(v33) == 46
     || HIDWORD(v33) == 183
     || SHIDWORD(v33) > 879 && SHIDWORD(v33) <= 0x1FFF && HIDWORD(v33) != 894
     || SHIDWORD(v33) > 191 && SHIDWORD(v33) <= 767 && HIDWORD(v33) != 215 && HIDWORD(v33) != 247
     || HIDWORD(v33) == 8204
     || HIDWORD(v33) == 8205
     || SHIDWORD(v33) > 767 && SHIDWORD(v33) <= 879
     || SHIDWORD(v33) > 8303 && SHIDWORD(v33) <= 8591
     || SHIDWORD(v33) > 131854 && SHIDWORD(v33) <= 8256
     || SHIDWORD(v33) > 11263 && SHIDWORD(v33) <= 12271
     || SHIDWORD(v33) > 12288 && SHIDWORD(v33) <= 55295
     || SHIDWORD(v33) > 63743 && SHIDWORD(v33) <= 64975
     || SHIDWORD(v33) > 65007 && SHIDWORD(v33) <= 65533
     || SHIDWORD(v33) > 0xFFFF && SHIDWORD(v33) <= (signed int)&loc_EFFFF;
        HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v9, v10) )
  {
    if ( *v37 == 58 )
    {
      if ( (_DWORD)n )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"element name, multiple colons found", v10);
        goto LABEL_257;
      }
      v44 = v37 + 1;
      LODWORD(n) = (_DWORD)v37 - (_DWORD)src;
      if ( dest )
      {
        sub_13937(a1, 3, 0, 0LL, (__int64)v37, v10);
        goto LABEL_257;
      }
      dest = malloc((unsigned int)(n + 1));
      if ( !dest )
      {
        sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v11);
        goto LABEL_257;
      }
      memcpy(dest, src, (unsigned int)n);
      *((_BYTE *)dest + (unsigned int)n) = 0;
      src = v44;
    }
    v37 += (unsigned int)v33;
  }
  if ( !*v37 )
  {
    sub_13937(a1, 4, 0, 0LL, v9, v10);
    free(dest);
    return 0LL;
  }
  v40 = (char *)calloc(1uLL, 0x48uLL);
  if ( !v40 )
  {
    free(dest);
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v12);
    return 0LL;
  }
  *((_QWORD *)v40 + 4) = 0LL;
  *((_QWORD *)v40 + 5) = v40;
  if ( v31 )
    sub_3116F((__int64)a1, v31, v40);
  v13 = lydict_insert(a1, src, v37 - (_BYTE *)src);
  *((_QWORD *)v40 + 6) = v13;
  src = v37;
  while ( 1 )
  {
    while ( *(_BYTE *)src == 32 || *(_BYTE *)src == 9 || *(_BYTE *)src == 10 || *(_BYTE *)src == 13 )
      src = (char *)src + 1;
    if ( !strncmp("/>", (const char *)src, 2uLL) )
      break;
    if ( *(_BYTE *)src == 62 )
    {
      src = (char *)src + 1;
      v38 = 0LL;
      while ( 1 )
      {
        if ( !*(_BYTE *)src )
          goto LABEL_247;
        if ( !strncmp((const char *)src, "</", 2uLL) )
        {
          if ( !v38 || *((_QWORD *)v40 + 3) )
          {
            src = (char *)src + 2;
            v37 = (char *)src;
            HIDWORD(v33) = sub_3127E(a1, (char *)src, &v33, (__int64)src, v15, v16);
            if ( (SHIDWORD(v33) <= 96 || SHIDWORD(v33) > 122)
              && HIDWORD(v33) != 95
              && (SHIDWORD(v33) <= 64 || SHIDWORD(v33) > 90)
              && HIDWORD(v33) != 58
              && (SHIDWORD(v33) <= 879 || SHIDWORD(v33) > 0x1FFF || HIDWORD(v33) == 894)
              && (SHIDWORD(v33) <= 191 || SHIDWORD(v33) > 767 || HIDWORD(v33) == 215 || HIDWORD(v33) == 247)
              && HIDWORD(v33) != 8204
              && HIDWORD(v33) != 8205
              && (SHIDWORD(v33) <= 8303 || SHIDWORD(v33) > 8591)
              && (SHIDWORD(v33) <= 11263 || SHIDWORD(v33) > 12271)
              && (SHIDWORD(v33) <= 12288 || SHIDWORD(v33) > 55295)
              && (SHIDWORD(v33) <= 63743 || SHIDWORD(v33) > 64975)
              && (SHIDWORD(v33) <= 65007 || SHIDWORD(v33) > 65533)
              && (SHIDWORD(v33) <= 0xFFFF || SHIDWORD(v33) > (signed int)&loc_EFFFF) )
            {
              sub_13937(a1, 2, 1u, v40, (__int64)"NameStartChar of the element", v18);
              goto LABEL_257;
            }
            v37 += (unsigned int)v33;
            for ( HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v17, v18);
                  SHIDWORD(v33) > 96 && SHIDWORD(v33) <= 122
               || HIDWORD(v33) == 95
               || HIDWORD(v33) == 45
               || SHIDWORD(v33) > 64 && SHIDWORD(v33) <= 90
               || SHIDWORD(v33) > 47 && SHIDWORD(v33) <= 57
               || HIDWORD(v33) == 58
               || HIDWORD(v33) == 46
               || HIDWORD(v33) == 183
               || SHIDWORD(v33) > 879 && SHIDWORD(v33) <= 0x1FFF && HIDWORD(v33) != 894
               || SHIDWORD(v33) > 191 && SHIDWORD(v33) <= 767 && HIDWORD(v33) != 215 && HIDWORD(v33) != 247
               || HIDWORD(v33) == 8204
               || HIDWORD(v33) == 8205
               || SHIDWORD(v33) > 767 && SHIDWORD(v33) <= 879
               || SHIDWORD(v33) > 8303 && SHIDWORD(v33) <= 8591
               || SHIDWORD(v33) > 131854 && SHIDWORD(v33) <= 8256
               || SHIDWORD(v33) > 11263 && SHIDWORD(v33) <= 12271
               || SHIDWORD(v33) > 12288 && SHIDWORD(v33) <= 55295
               || SHIDWORD(v33) > 63743 && SHIDWORD(v33) <= 64975
               || SHIDWORD(v33) > 65007 && SHIDWORD(v33) <= 65533
               || SHIDWORD(v33) > 0xFFFF && SHIDWORD(v33) <= (signed int)&loc_EFFFF;
                  HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v19, v20) )
            {
              if ( *v37 == 58 )
              {
                v44 = v37 + 1;
                if ( !dest || memcmp(dest, src, v37 - (_BYTE *)src) )
                {
                  sub_13937(
                    a1,
                    -1,
                    1u,
                    v40,
                    (__int64)"Invalid (different namespaces) opening (%s) and closing element tags.",
                    *((_QWORD *)v40 + 6));
                  goto LABEL_257;
                }
                src = v44;
              }
              v37 += (unsigned int)v33;
            }
            if ( !*v37 )
            {
              sub_13937(a1, 4, 0, 0LL, v19, v20);
              goto LABEL_257;
            }
            LODWORD(v33) = (_DWORD)v37 - (_DWORD)src;
            s1 = malloc((unsigned int)((_DWORD)v37 - (_DWORD)src + 1));
            if ( !s1 )
            {
              sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v21);
              goto LABEL_257;
            }
            memcpy(s1, src, v37 - (_BYTE *)src);
            *((_BYTE *)s1 + v37 - (_BYTE *)src) = 0;
            v22 = (unsigned int)v33;
            if ( v22 != strlen(*((const char **)v40 + 6)) || memcmp(s1, *((const void **)v40 + 6), (unsigned int)v33) )
            {
              sub_13937(
                a1,
                -1,
                1u,
                v40,
                (__int64)"Invalid (mixed names) opening (%s) and closing (%s) element tags.",
                *((_QWORD *)v40 + 6),
                s1);
              free(s1);
              goto LABEL_257;
            }
            free(s1);
            for ( src = v37;
                  *(_BYTE *)src == 32 || *(_BYTE *)src == 9 || *(_BYTE *)src == 10 || *(_BYTE *)src == 13;
                  src = (char *)src + 1 )
            {
              ;
            }
            if ( *(_BYTE *)src != 62 )
            {
              sub_13937(a1, -1, 1u, v40, (__int64)"Data after closing element tag \"%s\".", *((_QWORD *)v40 + 6));
              goto LABEL_257;
            }
            src = (char *)src + 1;
            if ( !(*v40 & 1) && !*((_QWORD *)v40 + 8) )
            {
              v23 = lydict_insert(a1, &byte_10CE4D, 0LL);
              *((_QWORD *)v40 + 8) = v23;
            }
            v35 = 1;
            goto LABEL_247;
          }
LABEL_221:
          if ( v38 )
          {
            src = v38;
            v38 = 0LL;
          }
          s1 = sub_316C2(a1, (__int64)src, 60, &v33, v15, v16);
          if ( !s1 && !(_DWORD)v33 )
            goto LABEL_257;
          v25 = lydict_insert_zc(a1, s1);
          *((_QWORD *)v40 + 8) = v25;
          src = (char *)src + (unsigned int)v33;
          if ( *((_QWORD *)v40 + 3) )
          {
            if ( v30 & 2 )
            {
              sub_13937(a1, 2, 1u, v40, (__int64)"XML element with mixed content", v26);
              goto LABEL_257;
            }
            v42 = calloc(1uLL, 0x48uLL);
            if ( !v42 )
            {
              sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v27);
              goto LABEL_257;
            }
            v42[8] = *((_QWORD *)v40 + 8);
            *((_QWORD *)v40 + 8) = 0LL;
            sub_3116F((__int64)a1, (__int64)v40, v42);
            *v40 |= 1u;
          }
        }
        else if ( !strncmp((const char *)src, "<?", 2uLL) )
        {
          if ( v38 )
            v38 = 0LL;
          src = (char *)src + 2;
          if ( (unsigned int)sub_31603(a1, (const char *)src, "?>", &v33) )
            goto LABEL_257;
          src = (char *)src + (unsigned int)v33;
        }
        else if ( !strncmp((const char *)src, "<!--", 4uLL) )
        {
          if ( v38 )
            v38 = 0LL;
          src = (char *)src + 4;
          if ( (unsigned int)sub_31603(a1, (const char *)src, "-->", &v33) )
            goto LABEL_257;
          src = (char *)src + (unsigned int)v33;
        }
        else
        {
          if ( !strncmp((const char *)src, "<![CDATA[", 9uLL) )
            goto LABEL_221;
          if ( *(_BYTE *)src == 60 )
          {
            if ( v38 )
            {
              if ( *v40 & 1 )
                goto LABEL_221;
              v38 = 0LL;
            }
            if ( *((_QWORD *)v40 + 8) )
            {
              if ( v30 & 2 )
              {
                sub_13937(a1, 2, 1u, v40, (__int64)"XML element with mixed content", v16);
                goto LABEL_257;
              }
              v42 = calloc(1uLL, 0x48uLL);
              if ( !v42 )
              {
                sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v24);
                goto LABEL_257;
              }
              v42[8] = *((_QWORD *)v40 + 8);
              *((_QWORD *)v40 + 8) = 0LL;
              sub_3116F((__int64)a1, (__int64)v40, v42);
              *v40 |= 1u;
            }
            v42 = (_QWORD *)sub_32A07(a1, src, &v33, v40, v30);
            if ( !v42 )
              goto LABEL_257;
            src = (char *)src + (unsigned int)v33;
          }
          else
          {
            if ( *(_BYTE *)src != 32 && *(_BYTE *)src != 9 && *(_BYTE *)src != 10 && *(_BYTE *)src != 13 )
              goto LABEL_221;
            v38 = src;
            while ( *(_BYTE *)src == 32 || *(_BYTE *)src == 9 || *(_BYTE *)src == 10 || *(_BYTE *)src == 13 )
              src = (char *)src + 1;
          }
        }
      }
    }
    v41 = sub_3223C(a1, (char *)src, &v33, (__int64)v40);
    if ( !v41 )
      goto LABEL_257;
    src = (char *)src + (unsigned int)v33;
    if ( *(_DWORD *)v41 == 2 )
    {
      if ( dest && *(_BYTE *)dest || *((_QWORD *)v41 + 3) )
      {
        if ( dest
          && *(_BYTE *)dest
          && *((_QWORD *)v41 + 3)
          && !strncmp(*((const char **)v41 + 3), (const char *)dest, (unsigned int)(n + 1)) )
        {
          *((_QWORD *)v40 + 7) = v41;
        }
      }
      else if ( *((_QWORD *)v41 + 4) )
      {
        *((_QWORD *)v40 + 7) = v41;
      }
      else
      {
        HIDWORD(n) = 1;
      }
    }
  }
  src = (char *)src + 2;
  v14 = lydict_insert(a1, &byte_10CE4D, 0LL);
  *((_QWORD *)v40 + 8) = v14;
  v35 = 1;
LABEL_247:
  *v32 = (_DWORD)src - (_DWORD)a2;
  if ( v35 )
  {
    if ( !*((_QWORD *)v40 + 7) && !HIDWORD(n) && v31 )
    {
      if ( (_DWORD)n )
        v28 = dest;
      else
        v28 = 0LL;
      v29 = lyxml_get_ns(v31, v28);
      *((_QWORD *)v40 + 7) = v29;
    }
    free(dest);
    result = v40;
  }
  else
  {
    sub_13937(a1, 1, 1u, v40, (__int64)"closing element tag", *((_QWORD *)v40 + 6));
LABEL_257:
    lyxml_free(a1, v40);
    free(dest);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7890: using guessed type __int64 __fastcall lyxml_get_ns(_QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000033CCB) ----------------------------------------------------
char *__fastcall lyxml_parse_mem(void *a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  char *result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  char v11; // al
  unsigned int v12; // [rsp+Ch] [rbp-44h]
  unsigned int v13; // [rsp+24h] [rbp-2Ch]
  char *s1; // [rsp+28h] [rbp-28h]
  char *i; // [rsp+30h] [rbp-20h]
  char *v16; // [rsp+38h] [rbp-18h]
  char *v17; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v18 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_parse_mem", a4, a5, a6);
  s1 = a2;
  v16 = 0LL;
  if ( a1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( !*s1 )
              return v16;
            if ( *s1 != 32 && *s1 != 9 && *s1 != 10 && *s1 != 13 )
              break;
            while ( *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13 )
              ++s1;
          }
          if ( strncmp(s1, "<?", 2uLL) )
            break;
          s1 += 2;
          if ( (unsigned int)sub_31603(a1, s1, "?>", &v13) )
            goto LABEL_40;
          s1 += v13;
        }
        if ( strncmp(s1, "<!--", 4uLL) )
          break;
        s1 += 2;
        if ( (unsigned int)sub_31603(a1, s1, "-->", &v13) )
          goto LABEL_40;
        s1 += v13;
      }
      if ( !strncmp(s1, "<!", 2uLL) )
      {
        sub_12222((__int64)a1, 0, 3, "DOCTYPE not supported in XML documents.", v8, v9);
        goto LABEL_40;
      }
      if ( *s1 != 60 )
        break;
      i = sub_32A07(a1, s1, &v13, 0LL, v12, v9);
      if ( !i )
        goto LABEL_40;
      if ( v16 )
      {
        *(_QWORD *)(*((_QWORD *)v16 + 5) + 32LL) = i;
        *((_QWORD *)i + 5) = *((_QWORD *)v16 + 5);
        *((_QWORD *)v16 + 5) = i;
      }
      else
      {
        v16 = i;
      }
      for ( s1 += v13; *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13; ++s1 )
        ;
      if ( !*s1 )
        return v16;
      if ( !(v12 & 1) )
      {
        sub_12222((__int64)a1, 1u, 0, "There are some not parsed data:\n%s", (__int64)s1, v10);
        return v16;
      }
    }
    sub_13937(a1, 3, 0, 0LL, (__int64)s1, v9);
LABEL_40:
    for ( i = v16; ; i = v17 )
    {
      if ( i )
      {
        v17 = (char *)*((_QWORD *)i + 4);
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
      if ( !v11 )
        break;
      lyxml_free(a1, i);
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyxml_parse_mem", v6);
    result = 0LL;
  }
  return result;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (000000000003404F) ----------------------------------------------------
__int64 __fastcall lyxml_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  unsigned int v10; // [rsp+Ch] [rbp-44h]
  int fd; // [rsp+2Ch] [rbp-24h]
  size_t v12; // [rsp+30h] [rbp-20h]
  void *v13; // [rsp+38h] [rbp-18h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v15 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_parse_path", a4, a5, a6);
  v14 = 0LL;
  if ( !a2 || !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyxml_parse_path", v6);
    return 0LL;
  }
  fd = open(a2, 0);
  if ( fd == -1 )
  {
    sub_12222(a1, 0, 3, "Opening file \"%s\" failed.", (__int64)a2, v8);
    return 0LL;
  }
  if ( (unsigned int)sub_34EE2(a1, fd, 0LL, &v12, &v13) )
  {
    sub_12222(a1, 0, 2, "Mapping file descriptor into memory failed (%s()).", (__int64)"lyxml_parse_path", v9);
  }
  else if ( v13 )
  {
    v14 = lyxml_parse_mem(a1, v13, v10);
    sub_351B4(v13, v12);
    close(fd);
    return v14;
  }
  if ( fd != -1 )
    close(fd);
  return 0LL;
}
// 7510: using guessed type __int64 __fastcall lyxml_parse_mem(_QWORD, _QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (00000000000341EA) ----------------------------------------------------
__int64 __fastcall sub_341EA(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed int v7; // eax
  int v8; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  v8 = a3;
  if ( !a2 )
    return 0LL;
  v10 = 0;
  for ( i = 0; *(_BYTE *)(i + a2); ++i )
  {
    v7 = *(char *)(i + a2);
    if ( v7 == 38 )
    {
      v10 += sub_C1FF7(a1, "&amp;", i, a4, a5, a6);
      continue;
    }
    if ( v7 > 38 )
    {
      if ( v7 == 60 )
      {
        v10 += sub_C1FF7(a1, "&lt;", i, a4, a5, a6);
        continue;
      }
      if ( v7 == 62 )
      {
        v10 += sub_C1FF7(a1, "&gt;", i, a4, a5, a6);
        continue;
      }
    }
    else if ( v7 == 34 && v8 == 1 )
    {
      v10 += sub_C1FF7(a1, "&quot;", i, a4, a5, a6);
      continue;
    }
    sub_C23A5(a1, (const void *)(i + a2), 1uLL);
    ++v10;
  }
  return v10;
}

//----- (000000000003430E) ----------------------------------------------------
__int64 __fastcall sub_3430E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  char *v7; // rax
  char *v8; // rax
  char *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  char v14; // [rsp+8h] [rbp-48h]
  unsigned int v15; // [rsp+Ch] [rbp-44h]
  unsigned int v16; // [rsp+28h] [rbp-28h]
  int v17; // [rsp+28h] [rbp-28h]
  unsigned int v18; // [rsp+28h] [rbp-28h]
  unsigned int v19; // [rsp+28h] [rbp-28h]
  unsigned int v20; // [rsp+2Ch] [rbp-24h]
  __int64 i; // [rsp+30h] [rbp-20h]
  __int64 j; // [rsp+38h] [rbp-18h]
  char *v23; // [rsp+40h] [rbp-10h]
  char *v24; // [rsp+48h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v16 = 0;
  if ( !*(_QWORD *)(a2 + 48) )
  {
    if ( *(_QWORD *)(a2 + 64) )
      result = sub_341EA(a1, *(_QWORD *)(a2 + 64), 2, *(_QWORD *)(a2 + 64), a5, a6);
    else
      result = 0LL;
    return result;
  }
  if ( a4 & 2 )
    v7 = "\n";
  else
    v7 = &byte_10CE4D;
  v24 = v7;
  v23 = v7;
  v20 = 2 * a3;
  if ( *(_BYTE *)a2 & 1 || *(_QWORD *)(a2 + 8) && **(_BYTE **)(a2 + 8) & 1 )
    v23 = &byte_10CE4D;
  if ( *(_QWORD *)(a2 + 8) && **(_BYTE **)(a2 + 8) & 1 )
  {
    v24 = &byte_10CE4D;
    v20 = 0;
  }
  if ( (_DWORD)a5 && a4 & 0x20 )
    v24 = &byte_10CE4D;
  if ( a4 & 0xD && !(a4 & 1) )
  {
    if ( a4 & 4 )
    {
      v20 = 0;
      goto LABEL_67;
    }
  }
  else if ( *(_QWORD *)(a2 + 56) && *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL) )
  {
    v16 = sub_C1FF7(
            a1,
            "%*s<%s:%s",
            v20,
            (__int64)&byte_10CE4D,
            *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL),
            *(_QWORD *)(a2 + 48));
  }
  else
  {
    v16 = sub_C1FF7(a1, "%*s<%s", v20, (__int64)&byte_10CE4D, *(_QWORD *)(a2 + 48), a6);
  }
  for ( i = *(_QWORD *)(a2 + 16); i; i = *(_QWORD *)(i + 8) )
  {
    if ( *(_DWORD *)i == 2 )
    {
      if ( *(_QWORD *)(i + 24) )
      {
        if ( *(_QWORD *)(i + 32) )
          v8 = *(char **)(i + 32);
        else
          v8 = &byte_10CE4D;
        v16 += sub_C1FF7(a1, " xmlns:%s=\"%s\"", *(_QWORD *)(i + 24), (__int64)v8, a5, a6);
      }
      else
      {
        if ( *(_QWORD *)(i + 32) )
          v9 = *(char **)(i + 32);
        else
          v9 = &byte_10CE4D;
        v16 += sub_C1FF7(a1, " xmlns=\"%s\"", (__int64)v9, a1, a5, a6);
      }
    }
    else if ( *(_QWORD *)(i + 16) && *(_QWORD *)(*(_QWORD *)(i + 16) + 24LL) )
    {
      v16 += sub_C1FF7(
               a1,
               " %s:%s=\"%s\"",
               *(_QWORD *)(*(_QWORD *)(i + 16) + 24LL),
               *(_QWORD *)(i + 24),
               *(_QWORD *)(i + 32),
               a6);
    }
    else
    {
      v16 += sub_C1FF7(a1, " %s=\"%s\"", *(_QWORD *)(i + 24), *(_QWORD *)(i + 32), a5, a6);
    }
  }
  if ( v14 & 4 && v14 & 1 )
    return (unsigned int)sub_C1FF7(a1, "/>%s", (__int64)v23, a4, a5, a6) + v16;
  if ( v14 & 1 )
  {
    sub_C1FF7(a1, ">", a3, a4, a5, a6);
    return v16 + 1;
  }
  if ( v14 & 8 )
    return v16;
  if ( !*(_QWORD *)(a2 + 24) && (!*(_QWORD *)(a2 + 64) || !**(_BYTE **)(a2 + 64)) )
    return (unsigned int)sub_C1FF7(a1, "/>%s", (__int64)v23, a4, a5, a6) + v16;
  if ( *(_QWORD *)(a2 + 64) && **(_BYTE **)(a2 + 64) )
  {
    sub_C1FF7(a1, ">", a3, a4, a5, a6);
    v17 = (unsigned __int64)sub_341EA(a1, *(_QWORD *)(a2 + 64), 2, *(_QWORD *)(a2 + 64), v10, v11) + v16 + 1;
    if ( *(_QWORD *)(a2 + 56) && *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL) )
      v18 = (unsigned __int64)sub_C1FF7(
                                a1,
                                "</%s:%s>%s",
                                *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL),
                                *(_QWORD *)(a2 + 48),
                                (__int64)v23,
                                v13)
          + v17;
    else
      v18 = (unsigned __int64)sub_C1FF7(a1, "</%s>%s", *(_QWORD *)(a2 + 48), (__int64)v23, v12, v13) + v17;
    return v18;
  }
  v16 += sub_C1FF7(a1, ">%s", (__int64)v23, a4, a5, a6);
  for ( j = *(_QWORD *)(a2 + 24); j; j = *(_QWORD *)(j + 32) )
  {
    if ( v14 & 2 )
      v16 += sub_3430E(a1, j, v15 + 1, 2LL, 0LL);
    else
      v16 += sub_3430E(a1, j, v15, 0LL, 0LL);
  }
LABEL_67:
  if ( *(_QWORD *)(a2 + 56) && *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL) )
    v19 = (unsigned __int64)sub_C1FF7(
                              a1,
                              "%*s</%s:%s>%s",
                              v20,
                              (__int64)&byte_10CE4D,
                              *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL),
                              *(_QWORD *)(a2 + 48),
                              v24)
        + v16;
  else
    v19 = (unsigned __int64)sub_C1FF7(a1, "%*s</%s>%s", v20, (__int64)&byte_10CE4D, *(_QWORD *)(a2 + 48), (__int64)v24)
        + v16;
  return v19;
}

//----- (0000000000034926) ----------------------------------------------------
__int64 __fastcall sub_34926(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // al
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  unsigned int v9; // [rsp+24h] [rbp-1Ch]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 j; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v9 = 0;
  if ( *(_QWORD *)(a2 + 8) )
  {
    i = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24LL);
  }
  else
  {
    for ( i = a2; *(_QWORD *)(i + 40) && *(_QWORD *)(*(_QWORD *)(i + 40) + 32LL); i = *(_QWORD *)(i + 40) )
      ;
  }
  for ( j = i; ; j = v12 )
  {
    if ( j )
    {
      v12 = *(_QWORD *)(j + 32);
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
      break;
    v9 += sub_3430E(a1, j, 0LL, v8, v12 == 0, a6);
  }
  return v9;
}

//----- (00000000000349F8) ----------------------------------------------------
__int64 __fastcall lyxml_print_file(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+Ch] [rbp-64h]
  int s; // [rsp+20h] [rbp-50h]
  __int64 v11; // [rsp+28h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v12 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_file", a4, a5, a6);
  if ( !a1 || !a2 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 1;
  v11 = a1;
  if ( v9 & 0x10 )
    result = sub_34926((__int64)&s, a2, v9, a2, v7, v8);
  else
    result = sub_3430E((__int64)&s, a2, 0LL, v9, 1LL, v8);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034AC9) ----------------------------------------------------
__int64 __fastcall lyxml_print_fd(int a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // [rsp+0h] [rbp-60h]
  unsigned int v10; // [rsp+8h] [rbp-58h]
  int s; // [rsp+10h] [rbp-50h]
  int v12; // [rsp+18h] [rbp-48h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v13 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_fd", a4, a5, a6, a2);
  if ( a1 < 0 || !v9 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 0;
  v12 = a1;
  if ( v10 & 0x10 )
    result = sub_34926((__int64)&s, v9, v10, v9, v7, v8);
  else
    result = sub_3430E((__int64)&s, v9, 0LL, v10, 1LL, v8);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034B96) ----------------------------------------------------
__int64 __fastcall lyxml_print_mem(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+Ch] [rbp-74h]
  unsigned int v10; // [rsp+2Ch] [rbp-54h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v12; // [rsp+38h] [rbp-48h]
  unsigned __int64 v13; // [rsp+78h] [rbp-8h]

  v9 = a3;
  v13 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_mem", a4, a5, a6);
  if ( !a1 || !a2 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 2;
  if ( v9 & 0x10 )
    v10 = sub_34926((__int64)&s, a2, v9, a2, v7, v8);
  else
    v10 = sub_3430E((__int64)&s, a2, 0LL, v9, 1LL, v8);
  *a1 = v12;
  return v10;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034C73) ----------------------------------------------------
__int64 __fastcall lyxml_print_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+4h] [rbp-6Ch]
  __int64 v10; // [rsp+8h] [rbp-68h]
  int s; // [rsp+20h] [rbp-50h]
  __int64 v12; // [rsp+28h] [rbp-48h]
  __int64 v13; // [rsp+30h] [rbp-40h]
  unsigned __int64 v14; // [rsp+68h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v14 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_clb", a4, a5, a6);
  if ( !a1 || !v10 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 3;
  v12 = a1;
  v13 = a2;
  if ( v9 & 0x10 )
    result = sub_34926((__int64)&s, v10, v9, v10, v7, v8);
  else
    result = sub_3430E((__int64)&s, v10, 0LL, v9, 1LL, v8);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034D50) ----------------------------------------------------
_BOOL8 __fastcall sub_34D50(__int64 a1)
{
  __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = a1;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/parser.c", 0xCCu, "lyp_is_rpc_action");
  do
  {
    if ( !lys_parent(v2) )
      break;
    v2 = lys_parent(v2);
  }
  while ( *(_DWORD *)(v2 + 56) != 0x4000 );
  return (*(_DWORD *)(v2 + 56) & 0x4100) != 0;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (0000000000034DD2) ----------------------------------------------------
signed __int64 __fastcall sub_34DD2(__int64 a1, unsigned int a2, __int64 a3)
{
  signed __int64 result; // rax
  unsigned int v4; // [rsp+14h] [rbp-1Ch]
  int v5; // [rsp+2Ch] [rbp-4h]

  v4 = a2;
  v5 = a2 & 0x10000FF;
  if ( a2 & 0x4000 && (v5 == 8 || v5 == 128) )
  {
    sub_12222(
      a1,
      0,
      3,
      "%s: Invalid options 0x%x (LYD_OPT_DATA_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG)",
      a3,
      a2);
    result = 1LL;
  }
  else if ( v4 & 0x30000 && v5 )
  {
    sub_12222(a1, 0, 3, "%s: Invalid options 0x%x (LYD_OPT_DATA_*_YANGLIB can be used only with LYD_OPT_DATA)", a3, a2);
    result = 1LL;
  }
  else if ( v5 && (!v5 || v5 & (v5 - 1)) )
  {
    sub_12222(a1, 0, 3, "%s: Invalid options 0x%x (multiple data type flags set).", a3, a2);
    result = 1LL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (0000000000034EE2) ----------------------------------------------------
signed __int64 __fastcall sub_34EE2(__int64 a1, int a2, __int64 a3, size_t *a4, void **a5)
{
  __int64 v5; // r8
  __int64 v6; // r9
  int *v7; // rax
  char *v8; // rax
  __int64 v9; // r9
  signed __int64 result; // rax
  int *v11; // rax
  char *v12; // rax
  __int64 v13; // r9
  void **v14; // [rsp+8h] [rbp-D8h]
  size_t *v15; // [rsp+10h] [rbp-D0h]
  __int64 v16; // [rsp+18h] [rbp-C8h]
  unsigned __int64 v17; // [rsp+18h] [rbp-C8h]
  __int64 v18; // [rsp+30h] [rbp-B0h]
  struct stat stat_buf; // [rsp+40h] [rbp-A0h]
  unsigned __int64 v20; // [rsp+D8h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v20 = __readfsqword(0x28u);
  if ( a2 < 0 )
    __assert_fail("fd >= 0", "/home/mantovan/Repositories/libyang/src/parser.c", 0x102u, "lyp_mmap");
  if ( sub_107C00(a2, &stat_buf) == -1 )
  {
    v7 = __errno_location();
    v8 = strerror(*v7);
    sub_12222(a1, 0, 2, "Failed to stat the file descriptor (%s) for the mmap().", (__int64)v8, v9);
    result = 1LL;
  }
  else if ( (stat_buf.st_mode & 0xF000) == 0x8000 )
  {
    if ( stat_buf.st_size )
    {
      v18 = sysconf(30);
      v17 = v16 + 1;
      if ( stat_buf.st_size % v18 && v17 <= v18 - stat_buf.st_size % v18 )
      {
        *v15 = v17 + stat_buf.st_size;
        *v14 = mmap(0LL, *v15, 3, 2, a2, 0LL);
      }
      else
      {
        *v15 = stat_buf.st_size + v18;
        *v14 = mmap(0LL, *v15, 3, 34, -1, 0LL);
        *v14 = mmap(*v14, stat_buf.st_size, 3, 18, a2, 0LL);
      }
      if ( *v14 == (void *)-1LL )
      {
        v11 = __errno_location();
        v12 = strerror(*v11);
        sub_12222(a1, 0, 2, "mmap() failed (%s).", (__int64)v12, v13);
        result = 1LL;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      *v14 = 0LL;
      result = 0LL;
    }
  }
  else
  {
    sub_12222(a1, 0, 3, "File to mmap() is not a regular file.", v5, v6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000351B4) ----------------------------------------------------
int __fastcall sub_351B4(void *a1, size_t a2)
{
  return munmap(a1, a2);
}

//----- (00000000000351D9) ----------------------------------------------------
_BOOL8 __fastcall sub_351D9(__int64 a1)
{
  __int64 v1; // r9
  _BOOL8 result; // rax
  __int64 v3; // r9
  __int64 v4; // r9
  __int64 v5; // rbx
  __int64 v6; // r9
  _QWORD *v7; // rbx
  _QWORD *v8; // rbx
  _QWORD *v9; // rbx
  _QWORD *v10; // rbx
  _QWORD *v11; // rbx
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // rbx
  __int64 v15; // r9
  _QWORD *v16; // rbx
  _QWORD *v17; // rbx
  signed __int64 v18; // rbx
  __int64 v19; // r9
  void **v20; // rbx
  __int64 v21; // r9
  __int64 v22; // rbx
  __int64 v23; // r9
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9
  int i; // [rsp+14h] [rbp-3Ch]
  __int64 v28; // [rsp+18h] [rbp-38h]
  void *v29; // [rsp+20h] [rbp-30h]
  _QWORD *v30; // [rsp+28h] [rbp-28h]
  _QWORD *v31; // [rsp+28h] [rbp-28h]
  _QWORD *v32; // [rsp+28h] [rbp-28h]
  signed __int64 v33; // [rsp+30h] [rbp-20h]
  signed __int64 v34; // [rsp+30h] [rbp-20h]
  signed __int64 v35; // [rsp+30h] [rbp-20h]
  _DWORD *v36; // [rsp+38h] [rbp-18h]

  v28 = *(_QWORD *)a1;
  v29 = realloc(*(void **)(a1 + 160), 8LL * (*(unsigned __int8 *)(a1 + 80) + 3));
  if ( v29 )
  {
    *(_QWORD *)(a1 + 160) = v29;
    v30 = calloc(1uLL, 0x79uLL);
    if ( v30 )
    {
      *(_QWORD *)(8LL * *(unsigned __int8 *)(a1 + 80) + *(_QWORD *)(a1 + 160)) = v30;
      v30[2] = lydict_insert(v28, "operation", 9LL);
      *v30 = *(_QWORD *)(**(_QWORD **)(v28 + 64) + 152LL);
      *((_BYTE *)v30 + 30) = 1;
      v30[1] = a1;
      v30[6] = v30[1];
      *((_BYTE *)v30 + 29) = 0;
      v30[8] = *(_QWORD *)(*(_QWORD *)(*v30 + 56LL) + 40LL);
      *((_DWORD *)v30 + 14) = 0x10000;
      v33 = (signed __int64)(v30 + 9);
      v30[9] = calloc(1uLL, 0x40uLL);
      if ( v30[9] )
      {
        **(_DWORD **)v33 = 6;
        *(_QWORD *)(*(_QWORD *)v33 + 16LL) = qword_346FA0[6];
        *(_QWORD *)(*(_QWORD *)v33 + 24LL) = v30;
        *(_DWORD *)(*(_QWORD *)v33 + 40LL) = 5;
        v5 = *(_QWORD *)v33;
        *(_QWORD *)(v5 + 32) = calloc(5uLL, 0x30uLL);
        if ( *(_QWORD *)(*(_QWORD *)v33 + 32LL) )
        {
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 28LL) = 0;
          v7 = *(_QWORD **)(*(_QWORD *)v33 + 32LL);
          *v7 = lydict_insert(v28, "merge", 5LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 76LL) = 1;
          v8 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 48LL);
          *v8 = lydict_insert(v28, "replace", 7LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 124LL) = 2;
          v9 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 96LL);
          *v9 = lydict_insert(v28, "create", 6LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 172LL) = 3;
          v10 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 144LL);
          *v10 = lydict_insert(v28, "delete", 6LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 220LL) = 4;
          v11 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 192LL);
          *v11 = lydict_insert(v28, "remove", 6LL);
          ++*(_BYTE *)(a1 + 80);
          v31 = calloc(1uLL, 0x79uLL);
          if ( v31 )
          {
            *(_QWORD *)(8LL * *(unsigned __int8 *)(a1 + 80) + *(_QWORD *)(a1 + 160)) = v31;
            v31[2] = lydict_insert(v28, "type", 4LL);
            *v31 = *(_QWORD *)(**(_QWORD **)(v28 + 64) + 152LL);
            *((_BYTE *)v31 + 30) = 1;
            v31[1] = a1;
            v31[6] = v31[1];
            *((_BYTE *)v31 + 29) = 0;
            v31[8] = *(_QWORD *)(*(_QWORD *)(*v31 + 56LL) + 40LL);
            *((_DWORD *)v31 + 14) = 0x10000;
            v34 = (signed __int64)(v31 + 9);
            v31[9] = calloc(1uLL, 0x40uLL);
            if ( v31[9] )
            {
              **(_DWORD **)v34 = 6;
              *(_QWORD *)(*(_QWORD *)v34 + 16LL) = qword_346FA0[6];
              *(_QWORD *)(*(_QWORD *)v34 + 24LL) = v31;
              *(_DWORD *)(*(_QWORD *)v34 + 40LL) = 2;
              v14 = *(_QWORD *)v34;
              *(_QWORD *)(v14 + 32) = calloc(2uLL, 0x30uLL);
              if ( *(_QWORD *)(*(_QWORD *)v34 + 32LL) )
              {
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 28LL) = 0;
                v16 = *(_QWORD **)(*(_QWORD *)v34 + 32LL);
                *v16 = lydict_insert(v28, "subtree", 7LL);
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 76LL) = 1;
                v17 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 48LL);
                *v17 = lydict_insert(v28, "xpath", 5LL);
                for ( i = *(unsigned __int8 *)(a1 + 76); i > 0; --i )
                {
                  if ( !strcmp(*(const char **)(((signed __int64)i << 6) - 64 + *(_QWORD *)(a1 + 128)), "xpath") )
                  {
                    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 75LL) = 1;
                    v18 = *(_QWORD *)(*(_QWORD *)v34 + 32LL) + 48LL;
                    *(_QWORD *)(v18 + 40) = calloc(1uLL, 0x40uLL);
                    if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) )
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v19);
                      return 1LL;
                    }
                    v20 = *(void ***)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL);
                    *v20 = malloc(1uLL);
                    if ( !**(_QWORD **)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) )
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v21);
                      return 1LL;
                    }
                    ***(_BYTE ***)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) = 3;
                    v22 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL);
                    *(_QWORD *)(v22 + 16) = malloc(8uLL);
                    if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) + 16LL) )
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v23);
                      return 1LL;
                    }
                    **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) + 16LL) = ((signed __int64)i << 6)
                                                                                                 - 64
                                                                                                 + *(_QWORD *)(a1 + 128);
                    break;
                  }
                }
                ++*(_BYTE *)(a1 + 80);
                v32 = calloc(1uLL, 0x79uLL);
                if ( v32 )
                {
                  *(_QWORD *)(8LL * *(unsigned __int8 *)(a1 + 80) + *(_QWORD *)(a1 + 160)) = v32;
                  v32[2] = lydict_insert(v28, "select", 6LL);
                  *v32 = *(_QWORD *)(**(_QWORD **)(v28 + 64) + 152LL);
                  *((_BYTE *)v32 + 30) = 1;
                  v32[1] = a1;
                  v32[6] = v32[1];
                  *((_BYTE *)v32 + 29) = 0;
                  v32[8] = *(_QWORD *)(*(_QWORD *)(*v32 + 56LL) + 40LL);
                  *((_DWORD *)v32 + 14) = 0x10000;
                  v35 = (signed __int64)(v32 + 9);
                  v32[9] = calloc(1uLL, 0x40uLL);
                  if ( v32[9] )
                  {
                    **(_DWORD **)v35 = 10;
                    *(_QWORD *)(*(_QWORD *)v35 + 16LL) = qword_346FA0[10];
                    *(_QWORD *)(*(_QWORD *)v35 + 24LL) = v32;
                    ++*(_BYTE *)(a1 + 80);
                    v36 = calloc(1uLL, 0x80uLL);
                    if ( v36 )
                    {
                      v36[14] = 32;
                      *((_QWORD *)v36 + 11) = v36;
                      *(_QWORD *)v36 = lydict_insert(v28, "config", 0LL);
                      *((_QWORD *)v36 + 6) = a1;
                      *((_WORD *)v36 + 12) = 1;
                      result = (unsigned int)sub_9C637(0LL, (_QWORD *)a1, (__int64)v36, 0) != 0;
                    }
                    else
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v26);
                      result = 1LL;
                    }
                  }
                  else
                  {
                    sub_12222(
                      v28,
                      0,
                      1,
                      "Memory allocation failed (%s()).",
                      (__int64)"lyp_add_ietf_netconf_annotations_config",
                      v25);
                    result = 1LL;
                  }
                }
                else
                {
                  sub_12222(
                    v28,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"lyp_add_ietf_netconf_annotations_config",
                    v24);
                  result = 1LL;
                }
              }
              else
              {
                sub_12222(
                  v28,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"lyp_add_ietf_netconf_annotations_config",
                  v15);
                result = 1LL;
              }
            }
            else
            {
              sub_12222(
                v28,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"lyp_add_ietf_netconf_annotations_config",
                v13);
              result = 1LL;
            }
          }
          else
          {
            sub_12222(
              v28,
              0,
              1,
              "Memory allocation failed (%s()).",
              (__int64)"lyp_add_ietf_netconf_annotations_config",
              v12);
            result = 1LL;
          }
        }
        else
        {
          sub_12222(
            v28,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"lyp_add_ietf_netconf_annotations_config",
            v6);
          result = 1LL;
        }
      }
      else
      {
        sub_12222(v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_ietf_netconf_annotations_config", v4);
        result = 1LL;
      }
    }
    else
    {
      sub_12222(v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_ietf_netconf_annotations_config", v3);
      result = 1LL;
    }
  }
  else
  {
    sub_12222(v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_ietf_netconf_annotations_config", v1);
    result = 1LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000035CB4) ----------------------------------------------------
signed __int64 __fastcall sub_35CB4(const char *a1, __int64 a2, __int64 a3, int a4, __int64 *a5, char *a6)
{
  const char *v7; // rax
  char *v8; // [rsp+0h] [rbp-40h]
  __int64 *v9; // [rsp+8h] [rbp-38h]
  int base; // [rsp+14h] [rbp-2Ch]
  __int64 v11; // [rsp+18h] [rbp-28h]
  char *endptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v13; // [rsp+38h] [rbp-8h]

  v11 = a3;
  base = a4;
  v9 = a5;
  v8 = a6;
  v13 = __readfsqword(0x28u);
  if ( !a6 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/parser.c", 0x1B0u, "parse_int");
  if ( a1 )
  {
    if ( *a1 )
    {
      *__errno_location() = 0;
      endptr = 0LL;
      *v9 = strtoll(a1, &endptr, base);
      if ( !*__errno_location() && a2 <= *v9 && v11 >= *v9 )
      {
        if ( !endptr || !*endptr )
          return 0LL;
        while ( (*__ctype_b_loc())[*endptr] & 0x2000 )
          ++endptr;
        if ( !*endptr )
          return 0LL;
      }
    }
  }
  if ( a1 )
    v7 = a1;
  else
    v7 = (const char *)&unk_10DE4F;
  sub_13937(**(void ***)(*(_QWORD *)v8 + 48LL), 50, 3u, v8, (__int64)v7, **(_QWORD **)v8, v8);
  return 1LL;
}

//----- (0000000000035E42) ----------------------------------------------------
signed __int64 __fastcall sub_35E42(const char *a1, unsigned __int64 a2, int a3, unsigned __int64 *a4, char *a5)
{
  const char *v6; // rax
  char *v7; // [rsp+8h] [rbp-48h]
  unsigned __int64 *v8; // [rsp+10h] [rbp-40h]
  int base; // [rsp+1Ch] [rbp-34h]
  char *endptr; // [rsp+38h] [rbp-18h]
  unsigned __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  base = a3;
  v8 = a4;
  v7 = a5;
  v12 = __readfsqword(0x28u);
  if ( !a5 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/parser.c", 0x1D8u, "parse_uint");
  if ( !a1 )
    goto LABEL_17;
  if ( !*a1 )
    goto LABEL_17;
  *__errno_location() = 0;
  endptr = 0LL;
  v11 = strtoull(a1, &endptr, base);
  if ( *__errno_location() || v11 > a2 )
    goto LABEL_17;
  if ( endptr && *endptr )
  {
    while ( (*__ctype_b_loc())[*endptr] & 0x2000 )
      ++endptr;
    if ( *endptr )
      goto LABEL_17;
LABEL_16:
    *v8 = v11;
    return 0LL;
  }
  if ( !v11 || *a1 != 45 )
    goto LABEL_16;
LABEL_17:
  if ( a1 )
    v6 = a1;
  else
    v6 = (const char *)&unk_10DE4F;
  sub_13937(**(void ***)(*(_QWORD *)v7 + 48LL), 50, 3u, v7, (__int64)v6, **(_QWORD **)v7);
  return 1LL;
}

//----- (0000000000035FD9) ----------------------------------------------------
signed __int64 __fastcall sub_35FD9(char a1, unsigned __int64 a2, signed __int64 a3, signed __int64 a4, unsigned __int8 a5, __int64 a6, void *a7, char *a8)
{
  signed __int64 result; // rax
  void *v9; // rdx
  void *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  signed __int64 v14; // [rsp+20h] [rbp-60h]
  signed __int64 v15; // [rsp+28h] [rbp-58h]
  unsigned __int8 v16; // [rsp+38h] [rbp-48h]
  signed int v17; // [rsp+4Ch] [rbp-34h]
  void *ptr; // [rsp+50h] [rbp-30h]
  __int64 v19; // [rsp+58h] [rbp-28h]
  signed __int64 *v20; // [rsp+60h] [rbp-20h]
  __int64 v21; // [rsp+68h] [rbp-18h]
  void *v22; // [rsp+70h] [rbp-10h]
  unsigned __int64 v23; // [rsp+78h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v16 = a5;
  v23 = __readfsqword(0x28u);
  v19 = 0LL;
  ptr = 0LL;
  v22 = **(void ***)(*(_QWORD *)(a6 + 24) + 48LL);
  if ( (unsigned int)sub_1D702(v22, 0LL, a6, &ptr) )
  {
    sub_12222(
      (__int64)v22,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
      518LL);
    result = 1LL;
  }
  else if ( ptr )
  {
    v20 = (signed __int64 *)ptr;
    v21 = *((_QWORD *)ptr + 3);
    do
    {
      v17 = 0;
      while ( v20 && v21 == v20[3] )
      {
        if ( !v17 )
        {
          if ( !a1 && a2 < v20[1]
            || a1 == 1 && v15 < v20[1]
            || a1 == 2 && (signed int)sub_C508(v14, v16, v20[1], *(_BYTE *)(v21 + 40)) < 0 )
          {
            break;
          }
          if ( !a1 && a2 >= v20[1] && a2 <= v20[2]
            || a1 == 1 && v15 >= v20[1] && v15 <= v20[2]
            || a1 == 2
            && (signed int)sub_C508(v14, v16, v20[1], *(_BYTE *)(v21 + 40)) >= 0
            && (signed int)sub_C508(v14, v16, v20[2], *(_BYTE *)(v21 + 40)) <= 0 )
          {
            v17 = 1;
          }
        }
        v20 = (signed __int64 *)v20[4];
      }
      if ( !v17 )
        break;
      if ( v20 )
        v21 = v20[3];
    }
    while ( v20 );
    while ( ptr )
    {
      v20 = (signed __int64 *)*((_QWORD *)ptr + 4);
      free(ptr);
      ptr = v20;
    }
    if ( v17 )
    {
      result = 0LL;
    }
    else
    {
      switch ( *(_DWORD *)v21 )
      {
        case 1:
          v19 = *(_QWORD *)(v21 + 32);
          goto LABEL_42;
        case 4:
          v19 = *(_QWORD *)(v21 + 32);
          goto LABEL_42;
        case 0xA:
          v19 = *(_QWORD *)(v21 + 32);
          goto LABEL_42;
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
          v19 = *(_QWORD *)(v21 + 32);
LABEL_42:
          if ( v19 )
            v9 = *(void **)v19;
          else
            v9 = &unk_10DE4F;
          if ( a7 )
            v10 = a7;
          else
            v10 = &unk_10DE4F;
          sub_13937(v22, 54, 3u, a8, (__int64)v10, (__int64)v9);
          if ( v19 && *(_QWORD *)(v19 + 32) )
            sub_13C4A(v22, 5, *(char **)(v19 + 32), v11, v12, v13);
          if ( v19 )
          {
            if ( *(_QWORD *)(v19 + 24) )
              sub_14407((__int64)v22, *(const char **)(v19 + 24));
          }
          result = 1LL;
          break;
        default:
          sub_12222(
            (__int64)v22,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
            585LL);
          result = 1LL;
          break;
      }
    }
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (00000000000363C2) ----------------------------------------------------
signed __int64 __fastcall sub_363C2(void *a1, char *a2, __int64 a3, char *a4)
{
  __int64 v5; // r9
  unsigned int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  char *v9; // [rsp+0h] [rbp-30h]
  __int64 v10; // [rsp+8h] [rbp-28h]
  char *s; // [rsp+10h] [rbp-20h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int j; // [rsp+28h] [rbp-8h]
  int v14; // [rsp+2Ch] [rbp-4h]

  s = a2;
  v10 = a3;
  v9 = a4;
  if ( !a1 || *(_DWORD *)a3 != 10 )
    __assert_fail(
      "ctx && (type->base == LY_TYPE_STRING)",
      "/home/mantovan/Repositories/libyang/src/parser.c",
      0x263u,
      "validate_pattern");
  if ( !a2 )
    s = (char *)&unk_10DE4F;
  if ( *(_QWORD *)(a3 + 16) && (unsigned int)sub_363C2(a1, s, *(_QWORD *)(a3 + 16) + 56LL, a4) )
    return 1LL;
  if ( !*(_QWORD *)(v10 + 56) && *(_DWORD *)(v10 + 48) )
  {
    *(_QWORD *)(v10 + 56) = malloc(8LL * (unsigned int)(2 * *(_DWORD *)(v10 + 48)));
    if ( !*(_QWORD *)(v10 + 56) )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"validate_pattern", v5, v9);
      return 0xFFFFFFFFLL;
    }
    for ( i = 0; i < *(_DWORD *)(v10 + 48); ++i )
    {
      if ( (unsigned int)sub_372F0(
                           a1,
                           (const char *)(*(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * i) + 1LL),
                           (void **)(*(_QWORD *)(v10 + 56) + 16LL * i),
                           (_QWORD *)(*(_QWORD *)(v10 + 56) + 8LL * (2 * i + 1))) )
        return 1LL;
    }
  }
  for ( j = 0; ; ++j )
  {
    if ( j >= *(_DWORD *)(v10 + 48) )
      return 0LL;
    v6 = strlen(s);
    v14 = pcre_exec(
            *(_QWORD *)(16LL * j + *(_QWORD *)(v10 + 56)),
            *(_QWORD *)(8LL * (2 * j + 1) + *(_QWORD *)(v10 + 56)),
            s,
            v6,
            0LL,
            0LL,
            0LL,
            0LL);
    if ( v14 )
    {
      if ( **(_BYTE **)(*(_QWORD *)(v10 + 40) + 56LL * j) == 6 )
        break;
    }
    if ( !v14 && **(_BYTE **)(*(_QWORD *)(v10 + 40) + 56LL * j) == 21 )
      break;
  }
  sub_13937(a1, 54, 3u, v9, (__int64)s, *(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * j) + 1LL, v9);
  if ( *(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * j + 32) )
    sub_13C4A(a1, 5, *(char **)(*(_QWORD *)(v10 + 40) + 56LL * j + 32), *(_QWORD *)(v10 + 40), v7, v8);
  if ( *(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * j + 24) )
    sub_14407((__int64)a1, *(const char **)(*(_QWORD *)(v10 + 40) + 56LL * j + 24));
  return 1LL;
}
// 7500: using guessed type __int64 __fastcall pcre_exec(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000036760) ----------------------------------------------------
char **__fastcall sub_36760(char *a1, char **a2, int a3)
{
  char **result; // rax
  int v4; // [rsp+Ch] [rbp-14h]
  char *v5; // [rsp+18h] [rbp-8h]
  char *i; // [rsp+18h] [rbp-8h]

  v5 = a1;
  v4 = a3;
  if ( (*__ctype_b_loc())[*a1] & 0x800 || *a1 == 45 || *a1 == 43 )
  {
    if ( *a1 == 45 || *a1 == 43 )
      v5 = a1 + 1;
    while ( (*__ctype_b_loc())[*v5] & 0x800 )
      ++v5;
    if ( v4 == 4 && *v5 == 46 && (*__ctype_b_loc())[v5[1]] & 0x800 )
    {
      for ( i = v5 + 1; (*__ctype_b_loc())[*i] & 0x800; ++i )
        ;
      result = a2;
      *a2 = i;
    }
    else
    {
      result = a2;
      *a2 = v5;
    }
  }
  else
  {
    result = a2;
    *a2 = a1;
  }
  return result;
}

//----- (0000000000036896) ----------------------------------------------------
__int64 __fastcall sub_36896(void *a1, char *a2, int *a3)
{
  int *v4; // [rsp+8h] [rbp-48h]
  unsigned int v5; // [rsp+20h] [rbp-30h]
  signed int v6; // [rsp+24h] [rbp-2Ch]
  void *ptr; // [rsp+28h] [rbp-28h]
  char *v8; // [rsp+30h] [rbp-20h]
  char *s1; // [rsp+38h] [rbp-18h]
  void *v10; // [rsp+40h] [rbp-10h]
  unsigned __int64 v11; // [rsp+48h] [rbp-8h]

  v4 = a3;
  v11 = __readfsqword(0x28u);
  ptr = 0LL;
  s1 = a2;
  v5 = 1;
  v6 = 1;
  if ( !a2 )
    __assert_fail("expr", "/home/mantovan/Repositories/libyang/src/parser.c", 0x2C4u, "lyp_check_length_range");
  while ( 1 )
  {
    while ( (*__ctype_b_loc())[*s1] & 0x2000 )
      ++s1;
    if ( !strncmp(s1, "max", 3uLL) )
      break;
    if ( !strncmp(s1, "min", 3uLL) )
    {
      if ( !v6 )
        goto LABEL_55;
      v6 = 0;
      for ( s1 += 3; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
        ;
      if ( *s1 != 124 )
      {
        if ( !*s1 )
          goto LABEL_44;
        if ( strncmp(s1, "..", 2uLL) )
          goto LABEL_55;
        goto LABEL_21;
      }
      ++s1;
    }
    else
    {
      if ( !((*__ctype_b_loc())[*s1] & 0x800) && *s1 != 45 && *s1 != 43 )
        goto LABEL_55;
      sub_36760(s1, &v8, *v4);
      if ( s1 == v8 )
        goto LABEL_55;
      for ( s1 = v8; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
        ;
      if ( *s1 == 124 )
      {
        ++s1;
      }
      else
      {
        if ( !*s1 || strncmp(s1, "..", 2uLL) )
          goto LABEL_44;
LABEL_21:
        for ( s1 += 2; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
          ;
        if ( !*s1 )
          goto LABEL_55;
        if ( !strncmp(s1, "max", 3uLL) )
          break;
        sub_36760(s1, &v8, *v4);
        if ( s1 == v8 )
          goto LABEL_55;
        for ( s1 = v8; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
          ;
        if ( !*s1 )
          goto LABEL_44;
        if ( *s1 != 124 )
          goto LABEL_55;
        ++s1;
      }
    }
  }
  for ( s1 += 3; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
    ;
  if ( *s1 )
    goto LABEL_55;
LABEL_44:
  if ( !(unsigned int)sub_1D702(a1, a2, (__int64)v4, &ptr) )
    v5 = 0;
LABEL_55:
  while ( ptr )
  {
    v10 = (void *)*((_QWORD *)ptr + 4);
    free(ptr);
    ptr = v10;
  }
  return v5;
}

//----- (0000000000036C95) ----------------------------------------------------
signed __int64 __fastcall sub_36C95(void *a1, const char *a2, void **a3)
{
  size_t v3; // rax
  __int64 v4; // r9
  signed __int64 result; // rax
  size_t v6; // rax
  __int64 v7; // rax
  size_t v8; // rax
  __int64 v9; // rax
  size_t v10; // rax
  __int64 v11; // r9
  size_t v12; // rax
  size_t v13; // rax
  size_t v14; // rax
  void **v15; // [rsp+8h] [rbp-68h]
  int v16; // [rsp+28h] [rbp-48h]
  int j; // [rsp+2Ch] [rbp-44h]
  int v18; // [rsp+30h] [rbp-40h]
  int v19; // [rsp+34h] [rbp-3Ch]
  int v20; // [rsp+38h] [rbp-38h]
  int v21; // [rsp+3Ch] [rbp-34h]
  __int64 v22; // [rsp+40h] [rbp-30h]
  __int128 ptr; // [rsp+48h] [rbp-28h]
  const char *i; // [rsp+58h] [rbp-18h]
  void *v25; // [rsp+60h] [rbp-10h]
  unsigned __int64 v26; // [rsp+68h] [rbp-8h]

  v15 = a3;
  v26 = __readfsqword(0x28u);
  v19 = 0;
  for ( *((_QWORD *)&ptr + 1) = strchr(a2, 36);
        *((_QWORD *)&ptr + 1);
        *((_QWORD *)&ptr + 1) = strchr((const char *)(*((_QWORD *)&ptr + 1) + 1LL), 36) )
  {
    ++v19;
  }
  v3 = strlen(a2);
  ptr = (unsigned __int64)malloc(v3 + v19 + 4);
  if ( (_QWORD)ptr )
  {
    *(_BYTE *)ptr = 0;
    *((_QWORD *)&ptr + 1) = ptr;
    v6 = strlen(a2);
    if ( strncmp(&a2[v6 - 2], ".*", 2uLL) )
    {
      **((_BYTE **)&ptr + 1) = 40;
      ++*((_QWORD *)&ptr + 1);
    }
    for ( i = a2; *i; ++i )
    {
      if ( *i == 36 )
      {
        v7 = *((_QWORD *)&ptr + 1);
        **((_WORD **)&ptr + 1) = 9308;
        *(_BYTE *)(v7 + 2) = 0;
        *((_QWORD *)&ptr + 1) += 2LL;
      }
      else
      {
        **((_BYTE **)&ptr + 1) = *i;
        ++*((_QWORD *)&ptr + 1);
      }
    }
    v8 = strlen(a2);
    if ( !strncmp(&a2[v8 - 2], ".*", 2uLL) )
    {
      **((_BYTE **)&ptr + 1) = 0;
      ++*((_QWORD *)&ptr + 1);
    }
    else
    {
      v9 = *((_QWORD *)&ptr + 1);
      **((_WORD **)&ptr + 1) = 9257;
      *(_BYTE *)(v9 + 2) = 0;
      *((_QWORD *)&ptr + 1) += 2LL;
    }
    while ( 1 )
    {
      *((_QWORD *)&ptr + 1) = strstr((const char *)ptr, "\\p{Is");
      if ( !*((_QWORD *)&ptr + 1) )
        break;
      v20 = DWORD2(ptr) - ptr;
      *((_QWORD *)&ptr + 1) = strchr(*((const char **)&ptr + 1), 125);
      if ( !*((_QWORD *)&ptr + 1) )
      {
        sub_13937(a1, 35, 0, 0LL, (__int64)a2, v20 + 2LL + ptr, "unterminated character property");
        free((void *)ptr);
        return 1LL;
      }
      v21 = DWORD2(ptr) - ptr + 1;
      if ( v21 - v20 <= 18 )
      {
        v10 = strlen((const char *)ptr);
        *(_QWORD *)&ptr = sub_C422((void *)ptr, v10 + 19 - (v21 - v20) + 1);
        if ( !(_QWORD)ptr )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_check_pattern", v11);
          free(0LL);
          return 1LL;
        }
      }
      for ( j = 0; off_345BA0[2 * j]; ++j )
      {
        v12 = strlen(off_345BA0[2 * j]);
        if ( !strncmp((const char *)(ptr + v20 + 5LL), off_345BA0[2 * j], v12) )
          break;
      }
      if ( !off_345BA0[2 * j] )
      {
        sub_13937(a1, 35, 0, 0LL, (__int64)a2, v20 + 5LL + ptr, "unknown block name");
        free((void *)ptr);
        return 1LL;
      }
      v18 = 0;
      v19 = 0;
      while ( v18 < v20 )
      {
        if ( *(_BYTE *)(v18 + (_QWORD)ptr) == 91 && (!v18 || *(_BYTE *)(v18 - 1LL + ptr) != 92) )
          ++v19;
        if ( *(_BYTE *)(v18 + (_QWORD)ptr) == 93 && (!v18 || *(_BYTE *)(v18 - 1LL + ptr) != 92) )
          --v19;
        ++v18;
      }
      if ( v19 )
      {
        v13 = strlen((const char *)(v21 + (_QWORD)ptr));
        memmove((void *)(v20 + 17LL + ptr), (const void *)(ptr + v21), v13 + 1);
        memcpy((void *)(v20 + (_QWORD)ptr), off_345BA8[2 * j] + 1, 0x11uLL);
      }
      else
      {
        v14 = strlen((const char *)(v21 + (_QWORD)ptr));
        memmove((void *)(v20 + 19LL + ptr), (const void *)(ptr + v21), v14 + 1);
        memcpy((void *)(ptr + v20), off_345BA8[2 * j], 0x13uLL);
      }
    }
    v25 = (void *)pcre_compile(ptr, 4144LL, &v22, &v16, 0LL);
    if ( v25 )
    {
      free((void *)ptr);
      if ( v15 )
        *v15 = v25;
      else
        free(v25);
      result = 0LL;
    }
    else
    {
      sub_13937(a1, 35, 0, 0LL, (__int64)a2, v16 + (_QWORD)ptr, v22);
      free((void *)ptr);
      result = 1LL;
    }
  }
  else
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_check_pattern", v4);
    result = 1LL;
  }
  return result;
}
// 7780: using guessed type __int64 __fastcall pcre_compile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 345BA0: using guessed type char *off_345BA0[166];
// 345BA8: using guessed type char *off_345BA8[165];

//----- (00000000000372F0) ----------------------------------------------------
signed __int64 __fastcall sub_372F0(void *a1, const char *a2, void **a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-30h]
  void **v6; // [rsp+8h] [rbp-28h]
  __int64 v7; // [rsp+20h] [rbp-10h]
  unsigned __int64 v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  v7 = 0LL;
  if ( (unsigned int)sub_36C95(a1, a2, a3) )
    return 1LL;
  if ( v5 && v6 )
  {
    *v5 = pcre_study(*v6, 0LL, &v7);
    if ( v7 )
      sub_12222((__int64)a1, 1u, 0, "Studying pattern \"%s\" failed (%s).", (__int64)a2, v7, v5);
  }
  return 0LL;
}
// 7A10: using guessed type __int64 __fastcall pcre_study(_QWORD, _QWORD, _QWORD);

//----- (00000000000373C5) ----------------------------------------------------
signed __int64 __fastcall sub_373C5(void *a1, unsigned int a2, const char **a3, char *a4, int *a5)
{
  void *v5; // rsp
  __int64 v6; // rbx
  char *v7; // r12
  size_t v8; // rax
  signed __int64 result; // rax
  unsigned int v10; // eax
  __int64 v11; // rax
  __int64 v12; // [rsp+0h] [rbp-B0h]
  int *v13; // [rsp+8h] [rbp-A8h]
  char *v14; // [rsp+10h] [rbp-A0h]
  const char **v15; // [rsp+18h] [rbp-98h]
  unsigned int v16; // [rsp+24h] [rbp-8Ch]
  void *v17; // [rsp+28h] [rbp-88h]
  unsigned __int8 v18; // [rsp+31h] [rbp-7Fh]
  unsigned __int16 v19; // [rsp+32h] [rbp-7Eh]
  int i; // [rsp+34h] [rbp-7Ch]
  int v21; // [rsp+38h] [rbp-78h]
  int v22; // [rsp+3Ch] [rbp-74h]
  char *s2; // [rsp+40h] [rbp-70h]
  __int64 v24; // [rsp+48h] [rbp-68h]
  char *s; // [rsp+50h] [rbp-60h]
  char *v26; // [rsp+58h] [rbp-58h]
  __int64 v27; // [rsp+60h] [rbp-50h]
  __int64 v28; // [rsp+68h] [rbp-48h]
  _QWORD *v29; // [rsp+70h] [rbp-40h]
  char *s1; // [rsp+78h] [rbp-38h]
  char *src; // [rsp+80h] [rbp-30h]
  unsigned __int64 v32; // [rsp+88h] [rbp-28h]

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v32 = __readfsqword(0x28u);
  v19 = 511;
  v24 = 511LL;
  v5 = alloca(512LL);
  s = (char *)&v12;
  v26 = 0LL;
  switch ( (unsigned __int64)a2 )
  {
    case 2uLL:
      v26 = v14;
      v22 = *v13;
      *s = 0;
      for ( i = 0; i < v22; ++i )
      {
        if ( *(_QWORD *)&v26[8 * i] )
        {
          if ( *s )
          {
            v6 = **(_QWORD **)&v26[8 * i];
            v7 = s;
            v8 = strlen(s);
            sprintf(&v7[v8], " %s", v6);
          }
          else
          {
            strcpy(s, **(const char ***)&v26[8 * i]);
          }
        }
      }
      goto LABEL_60;
    case 4uLL:
      v28 = *(_QWORD *)v14;
      v18 = *(_BYTE *)v13;
      if ( v28 )
      {
        v22 = sprintf(s, "%ld ", v28, a4, a5, 512LL);
        if ( v28 > 0 && v22 - 1 <= v18 || v22 - 2 <= v18 )
        {
          if ( v28 <= 0 )
            v10 = v18 + 2;
          else
            v10 = v18 + 1;
          v22 = sprintf(s, "%0*ld ", v10, v28);
        }
        i = v18;
        v21 = 1;
        while ( i > 0 )
        {
          if ( v21 && i > 1 && s[v22 - 2] == 48 )
          {
            s[v22 - 1] = 0;
          }
          else
          {
            v21 = 0;
            s[v22 - 1] = s[v22 - 2];
          }
          --v22;
          --i;
        }
        s[v22 - 1] = 46;
      }
      else
      {
        *(_DWORD *)s = 3157552;
      }
      goto LABEL_60;
    case 7uLL:
      s2 = v14;
      if ( strchr(*v15, 58) )
        strcpy(s, *v15);
      else
        sprintf(s, "%s:%s", s2, *v15);
      goto LABEL_60;
    case 8uLL:
      v29 = sub_CB4D2(v17, *v15);
      if ( !v29 )
      {
        sub_12222(
          (__int64)v17,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
          1028LL);
        return 0LL;
      }
      s2 = 0LL;
      v22 = 0;
      i = 0;
      break;
    case 0xCuLL:
    case 0xEuLL:
    case 0x10uLL:
    case 0x12uLL:
      v28 = *(_QWORD *)v14;
      sprintf(s, "%ld", v28, a4, a5, 512LL);
      goto LABEL_60;
    case 0xDuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x13uLL:
      v27 = *(_QWORD *)v14;
      sprintf(s, "%lu", v27, a4, a5, 512LL);
      goto LABEL_60;
    default:
      return 0LL;
  }
  while ( *((unsigned __int16 *)v29 + 16) > (unsigned int)i )
  {
    s1 = (char *)(v29[5] + *(unsigned __int16 *)(2LL * i + v29[1]));
    if ( i )
    {
      src = (char *)(v29[5]
                   + *(unsigned __int16 *)(2LL * i - 2 + v29[1])
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + v29[2]));
      if ( src != s1 )
      {
        if ( v22 + s1 - src > v19 )
        {
          sub_12222(
            (__int64)v17,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
            1038LL);
          sub_C488D((__int64)v29);
          return 0LL;
        }
        strncpy(&s[v22], src, s1 - src);
        v22 += (_DWORD)s1 - (_DWORD)src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *v29) == 9 && (src = sub_811F(s1, 58, *(unsigned __int16 *)(2LL * i + v29[2]))) != 0LL )
    {
      v21 = (_DWORD)++src - (_DWORD)s1;
      if ( !s2 || strncmp(s1, s2, v21) )
      {
        if ( v21 + v22 > v19 )
        {
          sub_12222(
            (__int64)v17,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
            1054LL);
          sub_C488D((__int64)v29);
          return 0LL;
        }
        strncpy(&s[v22], s1, v21);
        v22 += v21;
      }
      s2 = s1;
      if ( v22 + *(unsigned __int16 *)(2LL * i + v29[2]) - v21 > v19 )
      {
        sub_12222(
          (__int64)v17,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
          1065LL);
        sub_C488D((__int64)v29);
        return 0LL;
      }
      strncpy(&s[v22], src, *(unsigned __int16 *)(2LL * i + v29[2]) - v21);
      v22 += *(unsigned __int16 *)(2LL * i + v29[2]) - v21;
    }
    else
    {
      if ( v22 + *(unsigned __int16 *)(2LL * i + v29[2]) > v19 )
      {
        sub_12222(
          (__int64)v17,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
          1073LL);
        sub_C488D((__int64)v29);
        return 0LL;
      }
      strncpy(
        &s[v22],
        (const char *)(v29[5] + *(unsigned __int16 *)(2LL * i + v29[1])),
        *(unsigned __int16 *)(2LL * i + v29[2]));
      v22 += *(unsigned __int16 *)(2LL * i + v29[2]);
    }
    ++i;
  }
  if ( v22 <= v19 )
  {
    s[v22] = 0;
    sub_C488D((__int64)v29);
LABEL_60:
    if ( !strcmp(s, *v15) )
    {
      result = 0LL;
    }
    else
    {
      lydict_remove(v17, *v15);
      v11 = lydict_insert(v17, s, 0LL);
      *v15 = (const char *)v11;
      result = 1LL;
    }
  }
  else
  {
    sub_12222(
      (__int64)v17,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
      1082LL);
    sub_C488D((__int64)v29);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000037D41) ----------------------------------------------------
__int64 __fastcall sub_37D41(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  __int64 v5; // [rsp+8h] [rbp-38h]
  __int64 v6; // [rsp+10h] [rbp-30h]
  char *ptr; // [rsp+20h] [rbp-20h]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v6 = a2;
  v5 = a3;
  v10 = __readfsqword(0x28u);
  do
  {
    for ( i = *(_QWORD *)(v6 + 16); i && (*(_DWORD *)i != 2 || *(_QWORD *)(i + 24)); i = *(_QWORD *)(i + 8) )
      ;
    if ( !i )
      v6 = *(_QWORD *)(v6 + 8);
  }
  while ( !i && v6 );
  if ( i )
  {
    v9 = ly_ctx_get_module_by_ns(a3, *(_QWORD *)(i + 32), 0LL, 1LL);
    if ( v9 )
    {
      if ( asprintf(&ptr, "%s:%s", *(_QWORD *)(v9 + 8), a1) == -1 )
      {
        sub_12222(v5, 0, 1, "Memory allocation failed (%s()).", (__int64)"ident_val_add_module_prefix", v4);
        result = 0LL;
      }
      else
      {
        lydict_remove(v5, a1);
        result = lydict_insert_zc(v5, ptr);
      }
    }
    else
    {
      sub_12222(
        v5,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
        1179LL);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(a3, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/parser.c", 1172LL);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7400: using guessed type __int64 __fastcall ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000037EF5) ----------------------------------------------------
signed __int64 __fastcall sub_37EF5(signed __int64 a1, char **a2, __int64 a3, __int64 **a4, __int64 a5, __int64 *a6, int a7, int a8, int a9)
{
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  char *v12; // rax
  char *v13; // rax
  char *v14; // rax
  char *v15; // rax
  __int16 v16; // dx
  __int64 v17; // rax
  __int16 v18; // dx
  char *v19; // rbx
  unsigned __int64 v20; // rsi
  char *v21; // rax
  int v22; // esi
  int v23; // esi
  int v24; // esi
  int v25; // esi
  int v26; // esi
  int v27; // esi
  int v28; // esi
  int v29; // esi
  __int64 v30; // rax
  __int64 v31; // rax
  char *v32; // rax
  __int64 *v34; // [rsp+0h] [rbp-100h]
  int v35; // [rsp+8h] [rbp-F8h]
  __int64 **v36; // [rsp+10h] [rbp-F0h]
  __int64 v37; // [rsp+18h] [rbp-E8h]
  __int64 *v38; // [rsp+20h] [rbp-E0h]
  signed __int64 v39; // [rsp+28h] [rbp-D8h]
  char v40; // [rsp+33h] [rbp-CDh]
  int v41; // [rsp+34h] [rbp-CCh]
  int v42; // [rsp+38h] [rbp-C8h]
  int v43; // [rsp+3Ch] [rbp-C4h]
  int v44; // [rsp+40h] [rbp-C0h]
  int v45; // [rsp+44h] [rbp-BCh]
  unsigned int v46; // [rsp+48h] [rbp-B8h]
  unsigned int k; // [rsp+4Ch] [rbp-B4h]
  __int64 v48; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v49; // [rsp+58h] [rbp-A8h]
  char *s; // [rsp+60h] [rbp-A0h]
  char *s1; // [rsp+68h] [rbp-98h]
  void *v52; // [rsp+70h] [rbp-90h]
  __int64 v53; // [rsp+78h] [rbp-88h]
  __int64 l; // [rsp+80h] [rbp-80h]
  unsigned __int64 i; // [rsp+88h] [rbp-78h]
  size_t j; // [rsp+90h] [rbp-70h]
  __int64 v57; // [rsp+98h] [rbp-68h]
  __int64 v58; // [rsp+A0h] [rbp-60h]
  void *ptr; // [rsp+A8h] [rbp-58h]
  void *v60; // [rsp+B0h] [rbp-50h]
  int *v61; // [rsp+B8h] [rbp-48h]
  char *v62; // [rsp+C0h] [rbp-40h]
  char *v63; // [rsp+C8h] [rbp-38h]
  __int64 v64; // [rsp+D0h] [rbp-30h]
  void *v65; // [rsp+D8h] [rbp-28h]
  __int64 v66; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v67; // [rsp+E8h] [rbp-18h]

  v39 = a1;
  v38 = (__int64 *)a2;
  v37 = a3;
  v36 = a4;
  v35 = a5;
  v34 = a6;
  v67 = __readfsqword(0x28u);
  v64 = 0LL;
  v42 = 0;
  j = 0LL;
  s1 = *a2;
  v58 = 0LL;
  ptr = 0LL;
  v65 = **(void ***)(*(_QWORD *)(a1 + 24) + 48LL);
  if ( !a4 && !a5 )
    __assert_fail("leaf || attr", "/home/mantovan/Repositories/libyang/src/parser.c", 0x4C6u, "lyp_parse_value");
  if ( a4 )
  {
    if ( a5 )
      __assert_fail("!attr", "/home/mantovan/Repositories/libyang/src/parser.c", 0x4C9u, "lyp_parse_value");
    if ( !a6 )
      v34 = (__int64 *)(*a4)[6];
    v60 = a4 + 8;
    v61 = (int *)(a4 + 9);
    v62 = (char *)a4 + 76;
    v63 = (char *)a4;
    v57 = **a4;
  }
  else
  {
    if ( !a6 )
      v34 = *(__int64 **)(*(_QWORD *)(a5 + 16) + 48LL);
    v60 = (void *)(a5 + 40);
    v61 = (int *)(a5 + 48);
    v62 = (char *)(a5 + 52);
    v63 = *(char **)a5;
    v57 = *(_QWORD *)(a5 + 24);
  }
  if ( a7 )
  {
    v58 = lydict_insert(v65, *a2, 0LL);
    sub_BBE52(*(void **)v60, *v61, *v62, a1, v58, &v52, &v43, &v40);
    *v62 &= 0xFEu;
  }
  switch ( *(_DWORD *)a1 )
  {
    case 1:
      v49 = 0LL;
      s = 0LL;
      if ( s1 )
      {
        for ( i = 0LL; (*__ctype_b_loc())[s1[i]] & 0x2000; ++i )
          ;
        s = &s1[i];
        for ( j = strlen(&s1[i]); j && (*__ctype_b_loc())[s[j - 1]] & 0x2000; --j )
          ;
        v49 = j;
        for ( i = 0LL; i < j; ++i )
        {
          if ( s[i] == 10 )
          {
            --v49;
          }
          else if ( s[i] <= 46 && s[i] != 43 || s[i] > 57 && s[i] <= 64 || s[i] > 90 && s[i] <= 96 || s[i] > 122 )
          {
            if ( s[i] == 61 )
            {
              if ( i != j - 2 || s[i + 1] != 61 )
              {
                if ( i == j - 1 )
                  v42 = 1;
              }
              else
              {
                v42 = 2;
                ++i;
              }
            }
            if ( !v42 )
            {
              sub_13937(v65, 55, 3u, v63, (unsigned int)s[i], (__int64)&s[i], v34);
              sub_13937(v65, -1, 5u, 0LL, (__int64)"Invalid Base64 character.", v9);
              goto LABEL_349;
            }
          }
        }
      }
      if ( v49 & 3 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
        sub_13937(v65, -1, 5u, 0LL, (__int64)"Base64 encoded value length must be divisible by 4.", v10, v34);
        goto LABEL_349;
      }
      v45 = 3 * (v49 >> 2) - v42;
      if ( !a9 && (unsigned int)sub_35FD9(0, v45, 0LL, 0LL, 0, a1, s1, v63) )
        goto LABEL_349;
      if ( s1 && (s != s1 || s[j]) )
      {
        s = (char *)lydict_insert(v65, s, j);
        lydict_remove(v65, *a2);
        *a2 = s;
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = s1;
        *v61 = 1;
      }
      goto LABEL_340;
    case 2:
      while ( !*(_DWORD *)(v39 + 40) )
        v39 = *(_QWORD *)(v39 + 16) + 56LL;
      if ( s1 || a7 )
      {
        ptr = calloc(*(unsigned int *)(v39 + 40), 8uLL);
        if ( !ptr )
        {
          sub_12222((__int64)v65, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_parse_value", v11, v34);
          goto LABEL_349;
        }
      }
      if ( s1 )
      {
        v44 = 0;
        v46 = 0;
        while ( 1 )
        {
          if ( !s1[v44] )
            goto LABEL_354;
          while ( (*__ctype_b_loc())[s1[v44]] & 0x2000 )
            ++v44;
          if ( !s1[v44] )
          {
LABEL_354:
            sub_373C5(v65, 2u, (const char **)a2, (char *)ptr, (int *)(v39 + 40));
            if ( a7 )
            {
              *(_QWORD *)v60 = ptr;
              *v61 = 2;
            }
            else
            {
              free(ptr);
            }
            goto LABEL_340;
          }
          v45 = 0;
          while ( s1[v44] && !((*__ctype_b_loc())[s1[v44]] & 0x2000) )
          {
            ++v44;
            ++v45;
          }
          v44 -= v45;
          v46 = 0;
          v42 = 0;
          while ( 1 )
          {
            if ( v46 >= *(_DWORD *)(v39 + 40) )
              goto LABEL_94;
            if ( !strncmp(*(const char **)(*(_QWORD *)(v39 + 32) + 48LL * v46), &s1[v44], v45)
              && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46) + v45) )
            {
              break;
            }
            ++v46;
          }
          for ( k = 0; !a9 && k < *(unsigned __int8 *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 27); ++k )
          {
            if ( !(unsigned int)sub_18D14(32LL * k + *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 40)) )
            {
              if ( v36 )
                sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
              else
                sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
              sub_13937(
                v65,
                -1,
                5u,
                0LL,
                (__int64)"Bit \"%s\" is disabled by its %d. if-feature condition.",
                *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46),
                k + 1);
              free(ptr);
              goto LABEL_349;
            }
          }
          if ( *((_QWORD *)ptr + v46) )
          {
            if ( v36 )
              sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
            else
              sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
            sub_13937(
              v65,
              -1,
              5u,
              0LL,
              (__int64)"Bit \"%s\" used multiple times.",
              *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46),
              v34);
            free(ptr);
            goto LABEL_349;
          }
          *((_QWORD *)ptr + v46) = *(_QWORD *)(v39 + 32) + 48LL * v46;
          v42 = 1;
LABEL_94:
          if ( !v42 )
          {
            if ( v36 )
              sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
            else
              sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
            free(ptr);
            goto LABEL_349;
          }
          v44 += v45;
        }
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = ptr;
        *v61 = 2;
      }
LABEL_340:
      if ( !a7 || !*(_QWORD *)(v39 + 16) || !*(_QWORD *)(*(_QWORD *)(v39 + 16) + 48LL) )
        goto LABEL_346;
      v44 = sub_C1B58(*(__int64 **)(*(_QWORD *)(v39 + 16) + 48LL), **(_BYTE ***)(v39 + 16), v38, (__int64)v60);
      if ( v44 == -1 )
        goto LABEL_349;
      if ( !v44 )
        *v62 |= 2u;
LABEL_346:
      if ( a7 )
      {
        sub_BBE52(v52, v43, v40, v39, v58, 0LL, 0LL, 0LL);
        lydict_remove(v65, v58);
      }
      return v39;
    case 3:
      if ( s1 && !strcmp(s1, "true") )
      {
        if ( a7 )
          *(_BYTE *)v60 = 1;
      }
      else
      {
        if ( !s1 || strcmp(s1, "false") )
        {
          if ( v36 )
          {
            if ( s1 )
              v12 = s1;
            else
              v12 = (char *)&unk_10DE4F;
            sub_13937(v65, 50, 3u, v63, (__int64)v12, v57, v34);
          }
          else
          {
            if ( s1 )
              v13 = s1;
            else
              v13 = (char *)&unk_10DE4F;
            sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, v13);
          }
          goto LABEL_349;
        }
        if ( a7 )
          *(_BYTE *)v60 = 0;
      }
      if ( a7 )
        *v61 = 3;
      goto LABEL_340;
    case 4:
      if ( !s1 || !*s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      s = s1;
      if ( (unsigned int)sub_16271(&s, *(_BYTE *)(a1 + 40), &v48) || *s )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
        goto LABEL_349;
      }
      if ( !a9 && (unsigned int)sub_35FD9(2, 0LL, 0LL, v48, *(_BYTE *)(a1 + 40), a1, s1, v63) )
        goto LABEL_349;
      sub_373C5(v65, 4u, (const char **)a2, (char *)&v48, (int *)(a1 + 40));
      if ( a7 )
      {
        *(_QWORD *)v60 = v48;
        *v61 = 4;
      }
      goto LABEL_340;
    case 5:
      if ( s1 && *s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
        goto LABEL_349;
      }
      if ( a7 )
        *v61 = 5;
      goto LABEL_340;
    case 6:
      while ( !*(_DWORD *)(v39 + 40) )
        v39 = *(_QWORD *)(v39 + 16) + 56LL;
      v42 = 0;
      v46 = 0;
      while ( 2 )
      {
        if ( v46 >= *(_DWORD *)(v39 + 40) )
          goto LABEL_163;
        if ( !s1 || strcmp(s1, *(const char **)(*(_QWORD *)(v39 + 32) + 48LL * v46)) )
        {
          ++v46;
          continue;
        }
        break;
      }
      k = 0;
      while ( 2 )
      {
        if ( !a9 && k < *(unsigned __int8 *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 27) )
        {
          if ( (unsigned int)sub_18D14(32LL * k + *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 40)) )
          {
            ++k;
            continue;
          }
          if ( v36 )
            sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
          else
            sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
          sub_13937(
            v65,
            -1,
            5u,
            0LL,
            (__int64)"Enum \"%s\" is disabled by its %d. if-feature condition.",
            (__int64)s1,
            k + 1);
          goto LABEL_349;
        }
        break;
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = *(_QWORD *)(v39 + 32) + 48LL * v46;
        *v61 = 6;
      }
      v42 = 1;
LABEL_163:
      if ( !v42 )
      {
        if ( v36 )
        {
          if ( s1 )
            v14 = s1;
          else
            v14 = (char *)&unk_10DE4F;
          sub_13937(v65, 50, 3u, v63, (__int64)v14, v57, v34);
        }
        else
        {
          if ( s1 )
            v15 = s1;
          else
            v15 = (char *)&unk_10DE4F;
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, v15);
        }
        goto LABEL_349;
      }
      goto LABEL_340;
    case 7:
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      if ( !v37 )
      {
        if ( a8 )
        {
          sub_141E4(0LL, 2u, &v41, 0LL);
          s1 = (char *)sub_9BED(v34, s1);
          sub_142D2(0LL, v41, 0LL, 0);
          if ( !s1 )
            s1 = (char *)lydict_insert(v65, *a2, 0LL);
        }
        else
        {
          s1 = (char *)lydict_insert(v65, *a2, 0LL);
        }
LABEL_190:
        v66 = sub_26148(a1, s1, v63, v34, a8);
        if ( !v66 )
        {
          lydict_remove(v65, s1);
          goto LABEL_349;
        }
        if ( a7 )
        {
          *(_QWORD *)v60 = v66;
          *v61 = 7;
        }
        if ( a8 )
        {
          v16 = *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL);
          HIBYTE(v16) |= 0x10u;
          *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL) = v16;
        }
        v17 = lys_main_module(v34);
        sub_373C5(v65, 7u, (const char **)&s1, *(char **)(v17 + 8), 0LL);
        lydict_remove(v65, *a2);
        *a2 = s1;
        goto LABEL_340;
      }
      sub_141E4(0LL, 2u, &v41, 0LL);
      s1 = (char *)sub_9A10((__int64)v65, s1, (char *)v37, 0, 0);
      sub_142D2(0LL, v41, 0LL, 0);
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)*a2, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *a2);
        goto LABEL_349;
      }
      if ( strchr(s1, 58) )
        goto LABEL_190;
      if ( !*(_QWORD *)(*(_QWORD *)(v37 + 56) + 24LL) )
        goto LABEL_190;
      s1 = (char *)sub_37D41((__int64)s1, v37, (__int64)v65);
      if ( s1 )
        goto LABEL_190;
LABEL_349:
      if ( a7 )
      {
        *(_QWORD *)v60 = v52;
        *v61 = v43;
        *v62 = v40;
        lydict_remove(v65, v58);
      }
      return 0LL;
    case 8:
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      if ( v37 )
      {
        sub_141E4(0LL, 2u, &v41, 0LL);
        s1 = (char *)sub_9A10((__int64)v65, s1, (char *)v37, 1u, 1u);
        sub_142D2(0LL, v41, 0LL, 0);
        if ( !s1 )
        {
          if ( v36 )
            sub_13937(v65, 50, 3u, v63, (__int64)*a2, v57, v34);
          else
            sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *a2);
          goto LABEL_349;
        }
        if ( *a2 == s1 )
          lydict_remove(v65, s1);
      }
      else if ( a8 )
      {
        sub_141E4(0LL, 2u, &v41, 0LL);
        s1 = (char *)sub_9BED(v34, s1);
        if ( s1 )
        {
          if ( *a2 == s1 )
            lydict_remove(v65, s1);
        }
        else
        {
          s1 = *a2;
        }
        sub_142D2(0LL, v41, 0LL, 0);
      }
      else if ( (unsigned int)sub_373C5(v65, 8u, (const char **)&s1, 0LL, 0LL) )
      {
        *a2 = s1;
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = 0LL;
        *v61 = 8;
        *v62 |= 1u;
      }
      if ( *a2 != s1 )
      {
        lydict_remove(v65, *a2);
        *a2 = s1;
        if ( a8 )
        {
          v18 = *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL);
          HIBYTE(v18) |= 0x10u;
          *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL) = v18;
        }
      }
      goto LABEL_340;
    case 9:
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      v53 = sub_37EF5(*(_DWORD *)(a1 + 40) + 128, (_DWORD)a2, v37, (_DWORD)v36, v35);
      s1 = *a2;
      if ( !v53 )
        goto LABEL_349;
      if ( a7 )
        *v62 |= 1u;
      v39 = v53;
      goto LABEL_340;
    case 0xA:
      if ( !a9 )
      {
        v19 = s1;
        v20 = s1 ? sub_C76D(s1) : 0LL;
        if ( (unsigned int)sub_35FD9(0, v20, 0LL, 0LL, 0, a1, v19, v63) )
          goto LABEL_349;
      }
      if ( !a9 && (unsigned int)sub_363C2(v65, s1, a1, v63) )
        goto LABEL_349;
      for ( l = *(_QWORD *)(a1 + 16);
            *(_QWORD *)(l + 48)
         && (strcmp(*(const char **)l, "xpath1.0")
          || strcmp(*(const char **)(*(_QWORD *)(l + 48) + 8LL), "ietf-yang-types"));
            l = *(_QWORD *)(l + 72) )
      {
        ;
      }
      if ( !*(_QWORD *)(l + 48) || !v37 )
        goto LABEL_252;
      if ( s1 )
        v21 = s1;
      else
        v21 = (char *)&unk_10DE4F;
      s1 = (char *)sub_9A10((__int64)v65, v21, (char *)v37, 1u, 1u);
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, *v38, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *v38);
        goto LABEL_349;
      }
      if ( (char *)*v38 != s1 )
      {
        lydict_remove(v65, *v38);
        *v38 = (__int64)s1;
      }
LABEL_252:
      if ( a7 )
      {
        *(_QWORD *)v60 = s1;
        *v61 = 10;
      }
      goto LABEL_340;
    case 0xB:
      if ( a7 )
      {
        memset(v60, 0, 8uLL);
        *v61 = 11;
      }
      if ( *(_DWORD *)(a1 + 44) )
      {
        if ( v37 )
        {
          sub_141E4(0LL, 2u, &v41, 0LL);
          v30 = sub_9A10((__int64)v65, s1, (char *)v37, 1u, 1u);
          *(_QWORD *)v60 = v30;
          sub_142D2(0LL, v41, 0LL, 0);
          if ( !*(_QWORD *)v60 )
          {
            v31 = lydict_insert(v65, s1, 0LL);
            *(_QWORD *)v60 = v31;
          }
        }
        goto LABEL_340;
      }
      v53 = 0LL;
      v42 = 0;
      sub_141E4(0LL, 2u, &v41, 0LL);
      while ( 2 )
      {
        v53 = sub_3A9DE(a1, v53, &v42);
        if ( v53 )
        {
          v42 = 0;
          v64 = sub_37EF5(v53, (_DWORD)a2, v37, (_DWORD)v36, v35);
          if ( !v64 )
          {
            if ( a7 )
            {
              sub_BBE52(*(void **)v60, *v61, *v62, v53, (__int64)*a2, 0LL, 0LL, 0LL);
              memset(v60, 0, 8uLL);
            }
            continue;
          }
          v39 = v64;
        }
        break;
      }
      sub_142D2(0LL, v41, 0LL, 0);
      if ( v53 )
        goto LABEL_340;
      if ( a7 )
        *v61 = 0;
      if ( v36 )
      {
        if ( *a2 )
          v32 = *a2;
        else
          v32 = (char *)&unk_10DE4F;
        sub_13937(v65, 50, 3u, v63, (__int64)v32, v57, v34);
      }
      else
      {
        sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *a2);
      }
      goto LABEL_349;
    case 0xC:
      if ( a8 )
        v22 = 0;
      else
        v22 = 10;
      if ( (unsigned int)sub_35CB4(s1, -128LL, 127LL, v22, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xCu, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_BYTE *)v60 = v48;
        *v61 = 12;
      }
      goto LABEL_340;
    case 0xD:
      if ( a8 )
        v26 = 0;
      else
        v26 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFuLL, v26, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xDu, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_BYTE *)v60 = v49;
        *v61 = 13;
      }
      goto LABEL_340;
    case 0xE:
      if ( a8 )
        v23 = 0;
      else
        v23 = 10;
      if ( (unsigned int)sub_35CB4(s1, -32768LL, 0x7FFFLL, v23, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xEu, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_WORD *)v60 = v48;
        *v61 = 14;
      }
      goto LABEL_340;
    case 0xF:
      if ( a8 )
        v27 = 0;
      else
        v27 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFFFuLL, v27, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xFu, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_WORD *)v60 = v49;
        *v61 = 15;
      }
      goto LABEL_340;
    case 0x10:
      if ( a8 )
        v24 = 0;
      else
        v24 = 10;
      if ( (unsigned int)sub_35CB4(s1, -2147483648LL, 0x7FFFFFFFLL, v24, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x10u, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_DWORD *)v60 = v48;
        *v61 = 16;
      }
      goto LABEL_340;
    case 0x11:
      if ( a8 )
        v28 = 0;
      else
        v28 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFFFFFFFuLL, v28, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x11u, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_DWORD *)v60 = v49;
        *v61 = 17;
      }
      goto LABEL_340;
    case 0x12:
      if ( a8 )
        v25 = 0;
      else
        v25 = 10;
      if ( (unsigned int)sub_35CB4(s1, 0x8000000000000000LL, 0x7FFFFFFFFFFFFFFFLL, v25, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x12u, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_QWORD *)v60 = v48;
        *v61 = 18;
      }
      goto LABEL_340;
    case 0x13:
      if ( a8 )
        v29 = 0;
      else
        v29 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFFFFFFFFFFFFFFFLL, v29, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x13u, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_QWORD *)v60 = v49;
        *v61 = 19;
      }
      goto LABEL_340;
    default:
      sub_12222(
        (__int64)v65,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
        1930LL,
        v34);
      goto LABEL_349;
  }
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000003A9DE) ----------------------------------------------------
unsigned __int64 __fastcall sub_3A9DE(signed __int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v4; // [rsp+8h] [rbp-28h]
  signed __int64 v5; // [rsp+18h] [rbp-18h]
  unsigned int i; // [rsp+24h] [rbp-Ch]
  __int64 v7; // [rsp+28h] [rbp-8h]

  v5 = a1;
  v4 = a3;
  v7 = 0LL;
  while ( !*(_DWORD *)(v5 + 40) )
  {
    if ( !*(_QWORD *)(v5 + 16) )
      __assert_fail("type->der", "/home/mantovan/Repositories/libyang/src/parser.c", 0x7B2u, "lyp_get_next_union_type");
    v5 = *(_QWORD *)(v5 + 16) + 56LL;
  }
  for ( i = 0; i < *(_DWORD *)(v5 + 40); ++i )
  {
    if ( *(_DWORD *)(((unsigned __int64)i << 6) + *(_QWORD *)(v5 + 32)) == 11 )
    {
      v7 = sub_3A9DE(*(_QWORD *)(v5 + 32) + ((unsigned __int64)i << 6), a2, v4);
      if ( v7 )
        return v7;
    }
    else
    {
      if ( !a2 || *v4 )
        return ((unsigned __int64)i << 6) + *(_QWORD *)(v5 + 32);
      if ( a2 == ((unsigned __int64)i << 6) + *(_QWORD *)(v5 + 32) )
        *v4 = 1;
    }
  }
  return v7;
}

//----- (000000000003AB03) ----------------------------------------------------
signed __int64 __fastcall sub_3AB03(__int64 a1, char *a2, __int64 a3, __int64 a4, _BYTE *a5, __int64 a6, __int64 a7, __int16 a8, char ***a9)
{
  signed __int64 result; // rax
  __int64 v10; // r9
  __int64 v11; // rax
  __int64 v12; // [rsp+0h] [rbp-60h]
  _BYTE *v13; // [rsp+8h] [rbp-58h]
  int v14; // [rsp+30h] [rbp-30h]
  signed int i; // [rsp+34h] [rbp-2Ch]
  signed int k; // [rsp+34h] [rbp-2Ch]
  signed int j; // [rsp+38h] [rbp-28h]
  int v18; // [rsp+3Ch] [rbp-24h]
  int v19; // [rsp+3Ch] [rbp-24h]
  __int64 v20; // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  char **ptr; // [rsp+50h] [rbp-10h]
  signed __int64 *v23; // [rsp+58h] [rbp-8h]

  v13 = a5;
  v12 = a6;
  v21 = 0LL;
  if ( a3 )
  {
    v20 = ly_ctx_get_module_by_ns(a1, a3, 0LL, 0LL);
  }
  else
  {
    if ( !a4 )
    {
      sub_12222(
        a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
        2013LL,
        a6);
      return 0xFFFFFFFFLL;
    }
    v20 = ly_ctx_get_module(a1, a4, 0LL, 0LL);
  }
  if ( !v20 )
    return 1LL;
  v14 = -1;
  for ( i = 0; i < *(unsigned __int8 *)(v20 + 80); i += v18 + 1 )
  {
    v18 = lys_ext_instance_presence(
            *(_QWORD *)(**(_QWORD **)(a1 + 64) + 152LL),
            *(_QWORD *)(v20 + 160) + 8LL * i,
            (unsigned __int8)(*(_BYTE *)(v20 + 80) - i));
    if ( v18 == -1 )
      break;
    if ( (unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(8LL * (i + v18) + *(_QWORD *)(v20 + 160)) + 16LL), v13) )
    {
      v14 = i + v18;
      break;
    }
  }
  if ( v14 == -1 )
  {
    for ( j = 0; j < *(unsigned __int8 *)(v20 + 70); ++j )
    {
      v21 = *(_QWORD *)(*(_QWORD *)(v20 + 104) + 48LL * j);
      for ( k = 0; k < *(unsigned __int8 *)(v21 + 80); k += v19 + 1 )
      {
        v19 = lys_ext_instance_presence(
                *(_QWORD *)(**(_QWORD **)(a1 + 64) + 152LL),
                *(_QWORD *)(v21 + 160) + 8LL * k,
                (unsigned __int8)(*(_BYTE *)(v21 + 80) - k));
        if ( v19 == -1 )
          break;
        if ( (unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(8LL * (k + v19) + *(_QWORD *)(v21 + 160)) + 16LL), v13) )
        {
          v14 = k + v19;
          break;
        }
      }
    }
  }
  if ( v14 == -1 )
    return 1LL;
  ptr = (char **)calloc(1uLL, 0x38uLL);
  if ( ptr )
  {
    *ptr = a2;
    ptr[1] = 0LL;
    if ( v21 )
      v11 = *(_QWORD *)(v21 + 160);
    else
      v11 = *(_QWORD *)(v20 + 160);
    ptr[2] = *(char **)(8LL * v14 + v11);
    ptr[3] = (char *)lydict_insert(a1, v13, 0LL);
    ptr[4] = (char *)lydict_insert(a1, v12, 0LL);
    v23 = (signed __int64 *)lys_ext_complex_get_substmt(48LL, ptr[2], 0LL);
    if ( v23 && sub_37EF5(*v23, ptr + 4, a7, 0LL, (__int64)ptr, 0LL, 1, 0, a8 & 0x2000) )
    {
      *a9 = ptr;
      result = 0LL;
    }
    else
    {
      lydict_remove(a1, ptr[3]);
      lydict_remove(a1, ptr[4]);
      free(ptr);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_fill_attr", v10, v12);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 72B0: using guessed type __int64 __fastcall lys_ext_instance_presence(_QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7400: using guessed type __int64 __fastcall ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD);
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000003AF7B) ----------------------------------------------------
signed __int64 __fastcall sub_3AF7B(_QWORD *a1, _QWORD *a2, char *a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  _DWORD *v8; // [rsp+0h] [rbp-30h]
  char *v9; // [rsp+8h] [rbp-28h]
  _QWORD *v10; // [rsp+10h] [rbp-20h]
  int v11; // [rsp+24h] [rbp-Ch]
  _QWORD *v12; // [rsp+28h] [rbp-8h]

  v10 = a2;
  v9 = a3;
  v8 = a4;
  v12 = 0LL;
  v11 = 0;
  while ( v10 )
  {
    v12 = 0LL;
    if ( !strcmp(*(const char **)(v10[2] + 16LL), "operation")
      && !strcmp(*(const char **)(*(_QWORD *)(v10[2] + 48LL) + 8LL), "ietf-netconf") )
    {
      if ( v11 & 0x10 )
      {
        sub_13937(a1, 14, 3u, v9, (__int64)"operation attributes", **(_QWORD **)v9, v8);
        return 0xFFFFFFFFLL;
      }
      v11 |= 0x10u;
      if ( *(_DWORD *)(v10[5] + 28LL) > 2 )
        v11 |= 0x20u;
    }
    else if ( *(_QWORD *)(v10[2] + 48LL) == *(_QWORD *)(a1[8] + 8LL)
           && !strcmp(*(const char **)(v10[2] + 16LL), "insert") )
    {
      if ( !(*(_WORD *)(*(_QWORD *)v9 + 24LL) & 0x100) )
      {
        sub_13937(a1, 52, 3u, v9, (__int64)"insert", a6, v8);
        return 0xFFFFFFFFLL;
      }
      if ( v11 & 1 )
      {
        sub_13937(a1, 14, 3u, v9, (__int64)"insert attributes", **(_QWORD **)v9, v8);
        return 0xFFFFFFFFLL;
      }
      v11 |= 1u;
      if ( *(_DWORD *)(v10[5] + 28LL) > 1 )
        v11 |= 2u;
      v12 = v10;
    }
    else if ( *(_QWORD *)(v10[2] + 48LL) == *(_QWORD *)(a1[8] + 8LL)
           && !strcmp(*(const char **)(v10[2] + 16LL), "value") )
    {
      if ( v11 & 4 )
      {
        sub_13937(a1, 14, 3u, v9, (__int64)"value attributes", **(_QWORD **)v9, v8);
        return 0xFFFFFFFFLL;
      }
      if ( *(_DWORD *)(*(_QWORD *)v9 + 56LL) & 0x10 )
      {
        sub_13937(a1, 52, 3u, v9, v10[3], a6, v8);
        return 0xFFFFFFFFLL;
      }
      v11 |= 4u;
      v12 = v10;
    }
    else if ( *(_QWORD *)(v10[2] + 48LL) == *(_QWORD *)(a1[8] + 8LL) && !strcmp(*(const char **)(v10[2] + 16LL), "key") )
    {
      if ( v11 & 8 )
      {
        sub_13937(a1, 14, 3u, v9, (__int64)"key attributes", **(_QWORD **)v9, v8);
        return 0xFFFFFFFFLL;
      }
      if ( *(_DWORD *)(*(_QWORD *)v9 + 56LL) & 8 )
      {
        sub_13937(a1, 52, 3u, v9, v10[3], a6, v8);
        return 0xFFFFFFFFLL;
      }
      v11 |= 8u;
      v12 = v10;
    }
    v10 = (_QWORD *)v10[1];
  }
  if ( !v12 || *(_DWORD *)(*(_QWORD *)v9 + 56LL) & 0x18 && *(_WORD *)(*(_QWORD *)v9 + 24LL) & 0x100 )
  {
    if ( v11 == 3 )
    {
      if ( *(_DWORD *)(*(_QWORD *)v9 + 56LL) & 0x10 )
        sub_13937(a1, 53, 3u, v9, (__int64)"key", **(_QWORD **)v9, v8);
      else
        sub_13937(a1, 53, 3u, v9, (__int64)"value", **(_QWORD **)v9, v8);
      result = 0xFFFFFFFFLL;
    }
    else if ( !(v11 & 0xC) || v11 & 2 )
    {
      if ( (v11 & 0x21) == 33 )
      {
        sub_13937(a1, 52, 3u, v9, (__int64)"insert", a6, v8);
        result = 0xFFFFFFFFLL;
      }
      else
      {
        if ( v8 )
          *v8 = v11;
        result = 0LL;
      }
    }
    else
    {
      if ( v11 & 4 )
        v7 = "value";
      else
        v7 = "key";
      sub_13937(a1, 52, 3u, v9, (__int64)v7, a6, v8);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_13937(a1, 52, 3u, v9, v12[3], a6, v8);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000003B4E8) ----------------------------------------------------
signed __int64 __fastcall sub_3B4E8(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int i; // [rsp+20h] [rbp-4h]

  for ( i = 0; i < a3; ++i )
  {
    if ( a1 == *(_QWORD *)(72LL * i + a2) )
      return 1LL;
  }
  return 0LL;
}

//----- (000000000003B53E) ----------------------------------------------------
signed __int64 __fastcall sub_3B53E(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  signed int i; // [rsp+14h] [rbp-Ch]
  __int64 v4; // [rsp+18h] [rbp-8h]

  if ( (unsigned int)sub_3B4E8(a1, *(_QWORD *)(a2 + 120), *(unsigned __int16 *)(a2 + 72)) )
  {
    sub_13937(*(void **)a2, 15, 0, 0LL, (__int64)"identity", a1, a2);
    result = 1LL;
  }
  else
  {
    v4 = lys_main_module(a2);
    for ( i = 0; i < *(unsigned __int8 *)(v4 + 70) && *(_QWORD *)(*(_QWORD *)(v4 + 104) + 48LL * i); ++i )
    {
      if ( (unsigned int)sub_3B4E8(
                           a1,
                           *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 104) + 48LL * i) + 120LL),
                           *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v4 + 104) + 48LL * i) + 72LL)) )
      {
        sub_13937(*(void **)a2, 15, 0, 0LL, (__int64)"identity", a1, a2);
        return 1LL;
      }
    }
    result = 0LL;
  }
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000003B6AA) ----------------------------------------------------
signed __int64 __fastcall sub_3B6AA(const char *a1, __int64 a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]
  int i; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  for ( i = 0; i < v4; ++i )
  {
    if ( !strcmp(a1, *(const char **)(((signed __int64)i << 7) + a2)) )
      return 1LL;
  }
  return 0LL;
}

//----- (000000000003B709) ----------------------------------------------------
signed __int64 __fastcall sub_3B709(const char *a1, __int64 a2)
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a2 + 76); ++i )
  {
    if ( !strcmp(a1, *(const char **)(((signed __int64)i << 6) + *(_QWORD *)(a2 + 128))) )
      return 1LL;
  }
  return 0LL;
}

//----- (000000000003B772) ----------------------------------------------------
signed __int64 __fastcall sub_3B772(const char *a1, __int64 a2)
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  if ( *(_QWORD *)(a2 + 16) && !strcmp(*(const char **)(a2 + 16), a1) )
    return 1LL;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 69); ++i )
  {
    if ( !strcmp(*(const char **)(*(_QWORD *)(a2 + 96) + 56LL * i + 8), a1) )
      return 1LL;
  }
  return 0LL;
}

//----- (000000000003B812) ----------------------------------------------------
signed __int64 __fastcall sub_3B812(void *a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r9
  int v8; // eax
  int v9; // eax
  __int64 v10; // [rsp+8h] [rbp-58h]
  __int64 v11; // [rsp+10h] [rbp-50h]
  unsigned int v12; // [rsp+1Ch] [rbp-44h]
  signed int i; // [rsp+34h] [rbp-2Ch]
  signed int ii; // [rsp+34h] [rbp-2Ch]
  signed int j; // [rsp+34h] [rbp-2Ch]
  signed int l; // [rsp+34h] [rbp-2Ch]
  signed int n; // [rsp+34h] [rbp-2Ch]
  signed int m; // [rsp+38h] [rbp-28h]
  const char **k; // [rsp+48h] [rbp-18h]
  __int64 v20; // [rsp+50h] [rbp-10h]
  __int64 v21; // [rsp+50h] [rbp-10h]
  __int64 v22; // [rsp+50h] [rbp-10h]
  __int64 v23; // [rsp+58h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  if ( !a1 || !a2 )
    __assert_fail("ctx && id", "/home/mantovan/Repositories/libyang/src/parser.c", 0x8E7u, "lyp_check_identifier");
  if ( (*a2 <= 64 || *a2 > 90) && (*a2 <= 96 || *a2 > 122) && *a2 != 95 )
  {
    sub_13937(a1, 8, 0, 0LL, (__int64)a2, (__int64)"invalid start character");
    return 1LL;
  }
  for ( i = 1; a2[i]; ++i )
  {
    if ( (a2[i] <= 64 || a2[i] > 90)
      && (a2[i] <= 96 || a2[i] > 122)
      && (a2[i] <= 47 || a2[i] > 57)
      && a2[i] != 95
      && a2[i] != 45
      && a2[i] != 46 )
    {
      sub_13937(a1, 8, 0, 0LL, (__int64)a2, (__int64)"invalid character");
      return 1LL;
    }
  }
  if ( i > 64 )
    sub_12222((__int64)a1, 1u, 0, "Identifier \"%s\" is long, you should use something shorter.", (__int64)a2, a6);
  switch ( (unsigned __int64)v12 )
  {
    case 1uLL:
      if ( !v11 )
        __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser.c", 0x94Du, "lyp_check_identifier");
      v21 = lys_main_module(v11);
      if ( (unsigned int)sub_3B709(a2, v11) )
      {
        sub_13937(a1, 15, 0, 0LL, (__int64)"feature", (__int64)a2);
        result = 1LL;
      }
      else
      {
        for ( j = 0; ; ++j )
        {
          if ( j >= *(unsigned __int8 *)(v21 + 70) || !*(_QWORD *)(*(_QWORD *)(v21 + 104) + 48LL * j) )
            return 0LL;
          if ( (unsigned int)sub_3B709(a2, *(_QWORD *)(*(_QWORD *)(v21 + 104) + 48LL * j)) )
            break;
        }
        sub_13937(a1, 15, 0, 0LL, (__int64)"feature", (__int64)a2);
        result = 1LL;
      }
      return result;
    case 3uLL:
      if ( !v11 )
        __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser.c", 0x909u, "lyp_check_identifier");
      v20 = lys_main_module(v11);
      if ( !strcmp(a2, "binary")
        || !strcmp(a2, "bits")
        || !strcmp(a2, "boolean")
        || !strcmp(a2, "decimal64")
        || !strcmp(a2, "empty")
        || !strcmp(a2, "enumeration")
        || !strcmp(a2, "identityref")
        || !strcmp(a2, "instance-identifier")
        || !strcmp(a2, "int8")
        || !strcmp(a2, "int16")
        || !strcmp(a2, "int32")
        || !strcmp(a2, "int64")
        || !strcmp(a2, "leafref")
        || !strcmp(a2, "string")
        || !strcmp(a2, "uint8")
        || !strcmp(a2, "uint16")
        || !strcmp(a2, "uint32")
        || !strcmp(a2, "uint64")
        || !strcmp(a2, "union") )
      {
        sub_13937(a1, 10, 0, 0LL, (__int64)a2, (__int64)"typedef");
        sub_13937(a1, -1, 0, 0LL, (__int64)"Typedef name duplicates a built-in type.", v7);
        return 1LL;
      }
      break;
    case 5uLL:
      if ( !v10 )
        return 0LL;
      for ( k = *(const char ***)(v10 + 72); ; k = (const char **)k[10] )
      {
        if ( !k )
          return 0LL;
        if ( a2 == *k )
          break;
      }
      sub_13937(a1, 8, 0, 0LL, (__int64)a2, (__int64)"name duplication");
      return 1LL;
    case 6uLL:
      if ( !v11 )
        __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser.c", 0x944u, "lyp_check_identifier");
      if ( !(unsigned int)sub_3B772(a2, v11) )
        return 0LL;
      sub_13937(a1, 15, 0, 0LL, (__int64)"prefix", (__int64)a2);
      return 1LL;
    case 7uLL:
      if ( !v11 )
        __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser.c", 0x961u, "lyp_check_identifier");
      v22 = lys_main_module(v11);
      for ( l = 0; l < *(unsigned __int8 *)(v22 + 79); ++l )
      {
        if ( a2 == *(const char **)(((signed __int64)l << 6) + *(_QWORD *)(v22 + 152)) )
        {
          sub_13937(a1, 15, 0, 0LL, (__int64)"extension", (__int64)a2);
          return 1LL;
        }
      }
      for ( m = 0; ; ++m )
      {
        if ( m >= *(unsigned __int8 *)(v22 + 70) || !*(_QWORD *)(*(_QWORD *)(v22 + 104) + 48LL * m) )
          return 0LL;
        v23 = *(_QWORD *)(*(_QWORD *)(v22 + 104) + 48LL * m);
        for ( n = 0; n < *(unsigned __int8 *)(v23 + 79); ++n )
        {
          if ( a2 == *(const char **)(((signed __int64)n << 6) + *(_QWORD *)(v23 + 152)) )
          {
            sub_13937(a1, 15, 0, 0LL, (__int64)"extension", (__int64)a2);
            return 1LL;
          }
        }
      }
    default:
      return 0LL;
  }
  while ( v10 )
  {
    v8 = *(_DWORD *)(v10 + 56);
    switch ( v8 )
    {
      case 16:
        v9 = sub_3B6AA(a2, *(_QWORD *)(v10 + 128), *(unsigned __int8 *)(v10 + 29));
        break;
      case 2048:
        v9 = sub_3B6AA(a2, *(_QWORD *)(v10 + 104), *(unsigned __int16 *)(v10 + 30));
        break;
      case 1:
        v9 = sub_3B6AA(a2, *(_QWORD *)(v10 + 128), *(unsigned __int16 *)(v10 + 30));
        break;
      default:
        goto LABEL_63;
    }
    if ( v9 )
    {
      sub_13937(a1, 15, 0, 0LL, (__int64)"typedef", (__int64)a2);
      return 1LL;
    }
LABEL_63:
    v10 = lys_parent(v10);
  }
  if ( (unsigned int)sub_3B6AA(a2, *(_QWORD *)(v11 + 112), *(unsigned __int16 *)(v11 + 74)) )
  {
    sub_13937(a1, 15, 0, 0LL, (__int64)"typedef", (__int64)a2);
    result = 1LL;
  }
  else
  {
    for ( ii = 0; ; ++ii )
    {
      if ( ii >= *(unsigned __int8 *)(v20 + 70) || !*(_QWORD *)(*(_QWORD *)(v20 + 104) + 48LL * ii) )
        return 0LL;
      if ( (unsigned int)sub_3B6AA(
                           a2,
                           *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v20 + 104) + 48LL * ii) + 112LL),
                           *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v20 + 104) + 48LL * ii) + 74LL)) )
        break;
    }
    sub_13937(a1, 15, 0, 0LL, (__int64)"typedef", (__int64)a2);
    result = 1LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000003C2C9) ----------------------------------------------------
signed __int64 __fastcall sub_3C2C9(void *a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed int i; // [rsp+14h] [rbp-8Ch]
  char *v8; // [rsp+18h] [rbp-88h]
  struct tm s; // [rsp+20h] [rbp-80h]
  struct tm tp; // [rsp+60h] [rbp-40h]
  unsigned __int64 v11; // [rsp+98h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  if ( !a2 )
    __assert_fail("date", "/home/mantovan/Repositories/libyang/src/parser.c", 0x989u, "lyp_check_date");
  for ( i = 0; i <= 9; ++i )
  {
    if ( i != 4 && i != 7 )
    {
      if ( !((*__ctype_b_loc())[a2[i]] & 0x800) )
        goto LABEL_15;
    }
    else if ( a2[i] != 45 )
    {
      goto LABEL_15;
    }
  }
  memset(&s, 0, 0x38uLL);
  v8 = strptime(a2, "%Y-%m-%d", &s);
  if ( v8 )
  {
    if ( v8 == a2 + 10 )
    {
      s.tm_hour = 12;
      tp = s;
      mktime(&tp);
      if ( s.tm_mday == tp.tm_mday )
        return 0LL;
    }
  }
LABEL_15:
  sub_13937(a1, 9, 0, 0LL, (__int64)a2, a6, a2);
  return 1LL;
}

//----- (000000000003C4A2) ----------------------------------------------------
__int64 __fastcall sub_3C4A2(__int64 a1)
{
  __int64 result; // rax
  signed int v2; // [rsp+14h] [rbp-Ch]

  v2 = 0;
  for ( result = lys_getnext(0LL, a1, 0LL, 369LL); result; result = lys_getnext(result, a1, 0LL, 369LL) )
  {
    if ( *(_DWORD *)(result + 56) == 4096 )
    {
      if ( !*(_QWORD *)(result + 128) )
        return a1;
    }
    else if ( *(_DWORD *)(result + 56) != 2 )
    {
      if ( *(_DWORD *)(result + 56) == 16 )
      {
        if ( *(_DWORD *)(result + 152) )
          v2 = 1;
      }
      else if ( *(_DWORD *)(result + 56) == 8 )
      {
        if ( *(_DWORD *)(result + 208) )
          v2 = 1;
      }
      else if ( *(_WORD *)(result + 24) & 0x40 )
      {
        v2 = 1;
      }
      if ( v2 )
        return result;
    }
  }
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000003C596) ----------------------------------------------------
signed __int64 __fastcall sub_3C596(__int64 *a1, __int64 a2)
{
  __int64 v3; // r9
  __int64 v4; // ST10_8
  __int64 *v5; // [rsp+18h] [rbp-8h]

  if ( a1[10] || *(_DWORD *)(a2 + 56) == 2 )
    return 0LL;
  v5 = (__int64 *)sub_3C4A2((__int64)a1);
  if ( !v5 )
    return 0LL;
  if ( v5 == a1 )
    return 1LL;
  sub_13937(**(void ***)(a2 + 48), 5, 0, 0LL, (__int64)"mandatory", v3, a2);
  sub_13937(
    **(void ***)(v4 + 48),
    -1,
    0,
    0LL,
    (__int64)"Mandatory node \"%s\" appears in augment of \"%s\" without when condition.",
    *v5,
    *a1);
  return 0xFFFFFFFFLL;
}

//----- (000000000003C679) ----------------------------------------------------
signed __int64 __fastcall sub_3C679(__int64 a1)
{
  __int64 v1; // r9
  __int64 *v3; // [rsp+10h] [rbp-10h]
  __int64 *v4; // [rsp+18h] [rbp-8h]

  v3 = *(__int64 **)(a1 + 112);
  v4 = (__int64 *)sub_3C4A2((__int64)v3);
  if ( !v4 )
    return 0LL;
  if ( v4 == v3 )
    return 1LL;
  sub_13937(**(void ***)(a1 + 48), 5, 0, 0LL, (__int64)"mandatory", v1);
  sub_13937(
    **(void ***)(a1 + 48),
    -1,
    0,
    0LL,
    (__int64)"Mandatory node \"%s\" is directly under the default case \"%s\" of the \"%s\" choice.",
    *v4,
    *v3,
    *(_QWORD *)a1);
  return 0xFFFFFFFFLL;
}

//----- (000000000003C749) ----------------------------------------------------
signed __int64 __fastcall sub_3C749(char a1, void **a2, __int64 a3, char a4, __int64 a5, __int64 a6, char *a7)
{
  signed __int16 v7; // ax
  unsigned __int16 v8; // ax
  __int64 v9; // rbx
  const char *v10; // rax
  const char *v11; // rdx
  unsigned int v12; // esi
  __int64 v14; // [rsp+8h] [rbp-48h]
  __int64 v15; // [rsp+10h] [rbp-40h]
  __int64 v16; // [rsp+18h] [rbp-38h]
  void **v17; // [rsp+20h] [rbp-30h]
  unsigned __int16 v18; // [rsp+3Ch] [rbp-14h]
  unsigned __int16 v19; // [rsp+3Eh] [rbp-12h]

  v17 = a2;
  v16 = a3;
  v15 = a5;
  v14 = a6;
  if ( a1 & 0x38 )
    v7 = a1 & 0x38;
  else
    v7 = 8;
  v18 = v7;
  if ( a4 & 0x38 )
    v8 = a4 & 0x38;
  else
    v8 = 8;
  v19 = v8;
  if ( v18 >= v8 )
    return 0LL;
  v9 = lys_main_module(a2);
  if ( v9 != lys_main_module(v15) )
    return 0LL;
  if ( v19 == 32 )
    v10 = "obsolete";
  else
    v10 = "deprecated";
  if ( v18 == 8 )
    v11 = "current";
  else
    v11 = "deprecated";
  if ( a7 )
    v12 = 2;
  else
    v12 = 0;
  sub_13937(*v17, 37, v12, a7, (__int64)v11, v16, "references", v10, v14);
  return 1LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000003C867) ----------------------------------------------------
signed __int64 __fastcall sub_3C867(_BYTE *a1, int a2)
{
  signed __int64 result; // rax
  unsigned __int8 i; // [rsp+17h] [rbp-9h]
  signed __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = *(_QWORD *)a1 + 48LL;
  if ( !a1 || a1[64] & 1 )
    __assert_fail("mod && !mod->type", "/home/mantovan/Repositories/libyang/src/parser.c", 0xA35u, "lyp_del_includedup");
  result = *(unsigned __int8 *)(*(_QWORD *)a1 + 89LL);
  if ( (_BYTE)result )
  {
    for ( i = *(_BYTE *)(*(_QWORD *)a1 + 89LL) - 1;
          *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)a1 + 80LL)) + 64LL) & 1;
          --i )
    {
      ;
    }
    result = *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)a1 + 80LL));
    if ( a1 == (_BYTE *)result )
    {
      if ( a2 )
      {
        for ( i = *(_BYTE *)(*(_QWORD *)a1 + 89LL) - 1;
              *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v4 + 32)) + 64LL) & 1;
              --i )
        {
          sub_A9496(*(_QWORD *)(8LL * i + *(_QWORD *)(v4 + 32)));
          sub_AA3F6(*(_QWORD *)(8LL * i + *(_QWORD *)(v4 + 32)));
          sub_A3E76(*(__int64 **)(8LL * i + *(_QWORD *)(v4 + 32)), 0LL);
        }
      }
      *(_BYTE *)(v4 + 41) = i;
      result = *(unsigned __int8 *)(v4 + 41);
      if ( !(_BYTE)result )
      {
        free(*(void **)(v4 + 32));
        result = v4;
        *(_QWORD *)(v4 + 32) = 0LL;
      }
    }
  }
  return result;
}

//----- (000000000003C9F7) ----------------------------------------------------
unsigned __int64 __fastcall sub_3C9F7(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // r9
  unsigned __int64 result; // rax
  _QWORD *v5; // rbx
  __int64 v6; // r9
  signed __int16 i; // [rsp+16h] [rbp-1Ah]
  signed __int64 v8; // [rsp+18h] [rbp-18h]

  v8 = *a1 + 48;
  if ( *(_BYTE *)(*a1 + 89) )
  {
    for ( i = *(unsigned __int8 *)(*a1 + 89) - 1; *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*a1 + 80)) + 64LL) & 1; --i )
      ;
  }
  else
  {
    i = -1;
  }
  if ( i == -1 || (v2 = *(_QWORD *)(8LL * i + *(_QWORD *)(*a1 + 80)), v2 != lys_main_module(a1)) )
  {
    *(_QWORD *)(v8 + 32) = sub_C422(*(void **)(v8 + 32), 8LL * (unsigned __int8)++*(_BYTE *)(v8 + 41));
    if ( !*(_QWORD *)(v8 + 32) )
      return sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_includedup", v3, a2);
    v5 = (_QWORD *)(*(_QWORD *)(v8 + 32) + 8LL * *(unsigned __int8 *)(v8 + 41) - 8);
    *v5 = lys_main_module(a1);
  }
  *(_QWORD *)(v8 + 32) = sub_C422(*(void **)(v8 + 32), 8LL * (unsigned __int8)++*(_BYTE *)(v8 + 41));
  if ( !*(_QWORD *)(v8 + 32) )
    return sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_includedup", v6, a2);
  result = a2;
  *(_QWORD *)(8LL * *(unsigned __int8 *)(v8 + 41) - 8 + *(_QWORD *)(v8 + 32)) = a2;
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000003CBF8) ----------------------------------------------------
signed __int64 __fastcall sub_3CBF8(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  signed __int64 result; // rax
  unsigned __int8 i; // [rsp+23h] [rbp-Dh]

  if ( a3 )
    v6 = 40;
  else
    v6 = 41;
  if ( a2 == *(_QWORD *)(a1 + 8) )
  {
    sub_13937(*(void **)a1, v6, 0, 0LL, a2, a6);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    for ( i = 0; i < *(_BYTE *)(*(_QWORD *)a1 + 88LL); ++i )
    {
      if ( a2 == *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)a1 + 72LL)) + 8LL) )
      {
        sub_13937(*(void **)a1, v6, 0, 0LL, a2, a6);
        return 0xFFFFFFFFLL;
      }
    }
    result = 0LL;
  }
  return result;
}

//----- (000000000003CCDF) ----------------------------------------------------
signed __int64 __fastcall sub_3CCDF(__int64 *a1)
{
  __int64 v1; // r9
  signed __int64 result; // rax
  signed __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = *a1 + 48;
  *(_QWORD *)(v3 + 24) = sub_C422(*(void **)(v3 + 24), 8LL * (unsigned __int8)++*(_BYTE *)(v3 + 40));
  if ( *(_QWORD *)(v3 + 24) )
  {
    *(_QWORD *)(8LL * *(unsigned __int8 *)(v3 + 40) - 8 + *(_QWORD *)(v3 + 24)) = a1;
    result = 0LL;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_check_circmod_add", v1);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000003CDA9) ----------------------------------------------------
unsigned __int64 __fastcall sub_3CDA9(__int64 a1)
{
  unsigned __int64 result; // rax

  if ( !*(_BYTE *)(a1 + 88) )
    return sub_12222(
             a1,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
             2709LL);
  result = (unsigned __int8)--*(_BYTE *)(a1 + 88);
  if ( !(_BYTE)result )
  {
    free(*(void **)(a1 + 72));
    result = a1;
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  return result;
}

//----- (000000000003CE2E) ----------------------------------------------------
signed __int64 __fastcall sub_3CE2E(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  signed __int64 result; // rax
  _QWORD *v5; // [rsp+0h] [rbp-30h]
  unsigned __int8 i; // [rsp+26h] [rbp-Ah]
  unsigned __int8 j; // [rsp+26h] [rbp-Ah]
  char v8; // [rsp+27h] [rbp-9h]
  __int64 v9; // [rsp+28h] [rbp-8h]

  v5 = a4;
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 80LL);
  v8 = *(_BYTE *)(*(_QWORD *)a1 + 89LL);
  if ( !a4 )
    __assert_fail("sub", "/home/mantovan/Repositories/libyang/src/parser.c", 0xAACu, "lyp_check_includedup");
  for ( i = 0; i < *(_BYTE *)(a1 + 70); ++i )
  {
    if ( a2 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i) + 8LL) )
    {
      sub_13937(*(void **)a1, 10, 0, 0LL, a2, (__int64)"include", a4);
      sub_13937(
        *(void **)a1,
        -1,
        0,
        0LL,
        (__int64)"Submodule \"%s\" included twice in the same module \"%s\".",
        a2,
        *(_QWORD *)(a1 + 8));
      return 0xFFFFFFFFLL;
    }
  }
  if ( v8 )
  {
    if ( *(_BYTE *)(*(_QWORD *)v9 + 64LL) & 1 )
      __assert_fail(
        "!parsed_sub[0]->type",
        "/home/mantovan/Repositories/libyang/src/parser.c",
        0xAB9u,
        "lyp_check_includedup");
    for ( j = v8 - 1; *(_BYTE *)(*(_QWORD *)(8LL * j + v9) + 64LL) & 1; --j )
    {
      if ( a2 == *(_QWORD *)(*(_QWORD *)(8LL * j + v9) + 8LL) )
      {
        if ( !*(_BYTE *)(a3 + 8)
          || *(_BYTE *)(*(_QWORD *)(8LL * j + v9) + 68LL)
          && !strcmp(*(const char **)(*(_QWORD *)(8LL * j + v9) + 88LL), (const char *)(a3 + 8)) )
        {
          *v5 = *(_QWORD *)(8LL * j + v9);
          result = 1LL;
        }
        else
        {
          sub_13937(*(void **)a1, 10, 0, 0LL, a2, (__int64)"include", v5);
          sub_13937(*(void **)a1, -1, 0, 0LL, (__int64)"Including multiple revisions of submodule \"%s\".", a2);
          result = 0xFFFFFFFFLL;
        }
        return result;
      }
    }
  }
  return 0LL;
}

//----- (000000000003D0D7) ----------------------------------------------------
signed __int64 __fastcall sub_3D0D7(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  signed __int64 result; // rax
  char *v7; // rcx
  __int64 v8; // rdi
  __int64 v9; // [rsp+0h] [rbp-30h]
  _QWORD *v10; // [rsp+8h] [rbp-28h]
  char *v11; // [rsp+10h] [rbp-20h]
  __int64 *v12; // [rsp+18h] [rbp-18h]
  int v13; // [rsp+2Ch] [rbp-4h]

  v12 = a1;
  v11 = (char *)a2;
  v10 = a3;
  v9 = a4;
  v13 = sub_3CE2E((__int64)a1, a2, (__int64)a3, a3);
  if ( v13 == -1 )
    return 0xFFFFFFFFLL;
  if ( v13 == 1 )
    return 0LL;
  if ( (unsigned int)sub_3CBF8((__int64)v12, (__int64)v11, 0, (__int64)v11, v4, v5) )
    return 0xFFFFFFFFLL;
  if ( *((_BYTE *)v10 + 8) )
    v7 = (char *)(v10 + 1);
  else
    v7 = 0LL;
  v8 = *v12;
  *v10 = sub_ECF1(*v12, v12, v11, v7, 1u, v9);
  if ( *v10 )
  {
    if ( *((_BYTE *)v10 + 8) && *(_BYTE *)(*v10 + 68LL) && strcmp((const char *)v10 + 8, *(const char **)(*v10 + 88LL)) )
    {
      sub_12222(
        *v12,
        0,
        5,
        "\"%s\" include of submodule \"%s\" in revision \"%s\" not found.",
        v12[1],
        (__int64)v11,
        v10 + 1);
      sub_2B768(*v10, (void ***)&v9, 0);
      sub_A9496(*v10);
      sub_AA3F6(*v10);
      sub_A3E76((__int64 *)*v10, 0LL);
      *v10 = 0LL;
      result = 0xFFFFFFFFLL;
    }
    else
    {
      sub_3C9F7(v12, *v10);
      result = 0LL;
    }
  }
  else
  {
    if ( *(_DWORD *)ly_errno_glob_address(v8) != 5 )
      sub_13937((void *)*v12, 10, 0, 0LL, (__int64)v11, (__int64)"include", v9);
    sub_12222(*v12, 0, 5, "Including \"%s\" module into \"%s\" failed.", (__int64)v11, v12[1], v9);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);

//----- (000000000003D333) ----------------------------------------------------
signed __int64 __fastcall sub_3D333(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // [rsp+0h] [rbp-30h]
  unsigned __int8 i; // [rsp+16h] [rbp-1Ah]
  unsigned __int8 j; // [rsp+17h] [rbp-19h]
  unsigned int v11; // [rsp+18h] [rbp-18h]
  int v12; // [rsp+1Ch] [rbp-14h]
  void *v13; // [rsp+20h] [rbp-10h]
  void *v14; // [rsp+28h] [rbp-8h]

  v8 = a2;
  v11 = 0;
  v13 = *(void **)a1;
  for ( i = 0; i < *(_BYTE *)(v8 + 70); ++i )
  {
    for ( j = 0;
          j < *(_BYTE *)(a1 + 70)
       && *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * j) != *(_QWORD *)(*(_QWORD *)(v8 + 104) + 48LL * i);
          ++j )
    {
      ;
    }
    if ( j == *(_BYTE *)(a1 + 70) )
    {
      if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
      {
        sub_12222(
          (__int64)v13,
          1u,
          0,
          "The main module \"%s\" misses include of the \"%s\" submodule used in another submodule \"%s\".",
          *(_QWORD *)(a1 + 8),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 104) + 48LL * i) + 8LL),
          *(_QWORD *)(v8 + 8));
        sub_12222(
          (__int64)v13,
          1u,
          0,
          "To avoid further issues, adding submodule \"%s\" into the main module \"%s\".",
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 104) + 48LL * i) + 8LL),
          *(_QWORD *)(a1 + 8),
          v8);
      }
      else
      {
        sub_13937(v13, 11, 0, 0LL, (__int64)"include", a6, v8);
        sub_13937(
          v13,
          -1,
          0,
          0LL,
          (__int64)"The main module \"%s\" misses include of the \"%s\" submodule used in another submodule \"%s\".",
          *(_QWORD *)(a1 + 8),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 104) + 48LL * i) + 8LL),
          *(_QWORD *)(v8 + 8));
        v11 = 1;
      }
      v14 = realloc(*(void **)(a1 + 104), 48LL * (unsigned __int8)++*(_BYTE *)(a1 + 70));
      if ( !v14 )
      {
        sub_12222(
          (__int64)v13,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"lyp_check_include_missing_recursive",
          v6);
        return 1LL;
      }
      *(_QWORD *)(a1 + 104) = v14;
      memset((void *)(*(_QWORD *)(a1 + 104) + 48LL * *(unsigned __int8 *)(a1 + 70) - 48), 0, 0x30uLL);
      memcpy(
        (void *)(*(_QWORD *)(a1 + 104) + 48LL * *(unsigned __int8 *)(a1 + 70) - 48 + 8),
        (const void *)(*(_QWORD *)(v8 + 104) + 48LL * i + 8),
        0xAuLL);
      *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * *(unsigned __int8 *)(a1 + 70) - 48) = *(_QWORD *)(48LL * i
                                                                                                 + *(_QWORD *)(v8 + 104));
    }
    v12 = sub_3D333(a1, *(_QWORD *)(*(_QWORD *)(v8 + 104) + 48LL * i));
    if ( !v11 )
    {
      if ( v12 )
        v11 = 1;
    }
  }
  return v11;
}

//----- (000000000003D700) ----------------------------------------------------
__int64 __fastcall sub_3D700(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int8 i; // [rsp+1Bh] [rbp-5h]
  unsigned int v8; // [rsp+1Ch] [rbp-4h]

  v8 = 0;
  for ( i = 0; i < *(_BYTE *)(a1 + 70); ++i )
  {
    if ( (unsigned int)sub_3D333(
                         a1,
                         *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i),
                         *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i),
                         *(_QWORD *)(a1 + 104),
                         a5,
                         a6) )
      v8 = 1;
  }
  return v8;
}

//----- (000000000003D76E) ----------------------------------------------------
signed __int64 __fastcall sub_3D76E(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v7; // rcx
  char *v8; // [rsp+8h] [rbp-38h]
  signed int i; // [rsp+2Ch] [rbp-14h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  void *v11; // [rsp+38h] [rbp-8h]

  v8 = (char *)a3;
  v10 = 0LL;
  v11 = *(void **)a1;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 69); ++i )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i)
      && a2 == *(char **)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i) + 8LL) )
    {
      if ( *(_BYTE *)(a3 + 16)
        && (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i) + 68LL)
         || strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i) + 88LL), (const char *)(a3 + 16))) )
      {
        sub_13937(v11, 10, 0, 0LL, (__int64)a2, (__int64)"import");
        sub_13937(v11, -1, 0, 0LL, (__int64)"Importing multiple revisions of module \"%s\".", (__int64)a2);
        return 0xFFFFFFFFLL;
      }
      if ( v8[16] )
      {
        *(_QWORD *)v8 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i);
        return 0LL;
      }
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i);
      break;
    }
  }
  if ( (unsigned int)sub_3CBF8(a1, (__int64)a2, 1, (__int64)a2, a5, a6) )
    return 0xFFFFFFFFLL;
  if ( v8[16] )
    v7 = v8 + 16;
  else
    v7 = 0LL;
  *(_QWORD *)v8 = sub_ECF1(*(_QWORD *)a1, 0LL, a2, v7, *(_DWORD *)(*(_QWORD *)a1 + 92LL) & 1, 0LL);
  if ( !*(_QWORD *)v8 )
  {
    sub_12222((__int64)v11, 0, 5, "Importing \"%s\" module into \"%s\" failed.", (__int64)a2, *(_QWORD *)(a1 + 8));
    return 0xFFFFFFFFLL;
  }
  if ( v8[16] && *(_BYTE *)(*(_QWORD *)v8 + 68LL) && strcmp(v8 + 16, *(const char **)(*(_QWORD *)v8 + 88LL)) )
  {
    sub_12222(
      (__int64)v11,
      0,
      5,
      "\"%s\" import of module \"%s\" in revision \"%s\" not found.",
      *(_QWORD *)(a1 + 8),
      (__int64)a2,
      v8 + 16);
    return 0xFFFFFFFFLL;
  }
  if ( v10 )
  {
    if ( v10 != *(_QWORD *)v8
      || *(_BYTE *)(v10 + 68) != *(_BYTE *)(*(_QWORD *)v8 + 68LL)
      && (!*(_BYTE *)(v10 + 68) || *(_BYTE *)(*(_QWORD *)v8 + 68LL))
      || *(_BYTE *)(v10 + 68) && strcmp(*(const char **)(v10 + 88), *(const char **)(*(_QWORD *)v8 + 88LL)) )
    {
      sub_13937(v11, 10, 0, 0LL, (__int64)a2, (__int64)"import");
      sub_13937(v11, -1, 0, 0LL, (__int64)"Importing multiple revisions of module \"%s\".", (__int64)a2);
      return 0xFFFFFFFFLL;
    }
    sub_12222(
      (__int64)v11,
      1u,
      0,
      "Module \"%s\" is imported by \"%s\" multiple times with different prefixes.",
      *(_QWORD *)(v10 + 8),
      *(_QWORD *)(a1 + 8));
  }
  return 0LL;
}

//----- (000000000003DBD2) ----------------------------------------------------
unsigned __int64 __fastcall sub_3DBD2(__int64 a1)
{
  unsigned __int8 v2; // [rsp+1Eh] [rbp-32h]
  unsigned __int8 v3; // [rsp+1Fh] [rbp-31h]
  char dest; // [rsp+20h] [rbp-30h]
  unsigned __int64 v5; // [rsp+48h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v2 = 1;
  v3 = 0;
  while ( v2 < *(_BYTE *)(a1 + 68) )
  {
    if ( strcmp((const char *)(*(_QWORD *)(a1 + 88) + 40LL * v2), (const char *)(*(_QWORD *)(a1 + 88) + 40LL * v3)) > 0 )
      v3 = v2;
    ++v2;
  }
  if ( v3 )
  {
    memcpy(&dest, *(const void **)(a1 + 88), 0x28uLL);
    memcpy(*(void **)(a1 + 88), (const void *)(40LL * v3 + *(_QWORD *)(a1 + 88)), 0x28uLL);
    memcpy((void *)(40LL * v3 + *(_QWORD *)(a1 + 88)), &dest, 0x28uLL);
  }
  return __readfsqword(0x28u) ^ v5;
}

//----- (000000000003DD01) ----------------------------------------------------
void __fastcall sub_3DD01(__int64 a1, void **a2, unsigned __int8 *a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // ST04_1
  unsigned __int8 *v5; // [rsp+8h] [rbp-28h]
  unsigned __int8 i; // [rsp+2Fh] [rbp-1h]

  v5 = a3;
  v4 = a4;
  sub_AAE3B(a1, *(void ****)(*((_QWORD *)*a2 + a4) + 32LL), *(unsigned __int8 *)(*((_QWORD *)*a2 + a4) + 26LL), 0LL);
  lydict_remove(a1, *(_QWORD *)(*((_QWORD *)*a2 + v4) + 16LL));
  free(*((void **)*a2 + v4));
  for ( i = v4 + 1; i < *v5; ++i )
    *((_QWORD *)*a2 + i - 1) = *((_QWORD *)*a2 + i);
  *((_QWORD *)*a2 + (*v5)-- - 1) = 0LL;
  if ( !*v5 )
    free(*a2);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000003DE4E) ----------------------------------------------------
signed __int64 __fastcall sub_3DE4E(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  int i; // eax
  __int64 v5; // r9
  __int64 v7; // r9
  __int64 v8; // rbx
  __int64 v9; // [rsp+0h] [rbp-50h]
  int v10; // [rsp+Ch] [rbp-44h]
  int v11; // [rsp+20h] [rbp-30h]
  int v12; // [rsp+24h] [rbp-2Ch]
  __int64 v13; // [rsp+28h] [rbp-28h]
  void *ptr; // [rsp+30h] [rbp-20h]
  void *v15; // [rsp+38h] [rbp-18h]

  v10 = a3;
  v9 = a4;
  v13 = **(_QWORD **)(a2 + 48);
  LOBYTE(v12) = -1;
  for ( i = sub_9EAFC(*(_QWORD *)(a1 + 32), *(_BYTE *)(a1 + 26), 0, a3);
        ;
        i = sub_9EAFC(*(_QWORD *)(a1 + 32), *(_BYTE *)(a1 + 26), (unsigned __int8)v11 + 1, v10) )
  {
    v11 = i;
    if ( i == -1 )
      break;
    if ( v10 || v9 == **(_QWORD **)(8LL * i + *(_QWORD *)(a1 + 32)) )
    {
      do
        v12 = sub_9EAFC(*(_QWORD *)(a2 + 32), *(_BYTE *)(a2 + 26), (unsigned __int8)v12 + 1, v10);
      while ( v12 != -1 && !v10 && v9 != **(_QWORD **)(8LL * v12 + *(_QWORD *)(a2 + 32)) );
      if ( v12 == -1 )
      {
        ptr = malloc(0x40uLL);
        if ( !ptr )
        {
          sub_12222(v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_rfn_apply_ext_", v5, v9);
          return 1LL;
        }
        v15 = realloc(*(void **)(a2 + 32), 8LL * (*(unsigned __int8 *)(a2 + 26) + 1));
        if ( !v15 )
        {
          sub_12222(v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_rfn_apply_ext_", v7, v9);
          free(ptr);
          return 1LL;
        }
        *(_QWORD *)(a2 + 32) = v15;
        v12 = (unsigned __int8)++*(_BYTE *)(a2 + 26) - 1;
        *(_QWORD *)(*(_QWORD *)(a2 + 32) + 8LL * v12) = ptr;
        *(_QWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 8LL) = a2;
        *(_BYTE *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 29LL) = 1;
        *(_WORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 24LL) = 0;
        *(_BYTE *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 28LL) = v10;
        *(_QWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 40LL) = 0LL;
        *(_DWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 56LL) = 0x10000;
        *(_QWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 48LL) = *(_QWORD *)(a2 + 48);
      }
      else
      {
        sub_AAE3B(
          v13,
          *(void ****)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 32LL),
          *(unsigned __int8 *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 26LL),
          0LL);
        lydict_remove(v13, *(_QWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 16LL));
      }
      **(_QWORD **)(8LL * v12 + *(_QWORD *)(a2 + 32)) = **(_QWORD **)(8LL * v11 + *(_QWORD *)(a1 + 32));
      v8 = *(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32));
      *(_QWORD *)(v8 + 16) = lydict_insert(v13, *(_QWORD *)(*(_QWORD *)(8LL * v11 + *(_QWORD *)(a1 + 32)) + 16LL), 0LL);
      *(_BYTE *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 26LL) = *(_BYTE *)(*(_QWORD *)(8LL * v11
                                                                                              + *(_QWORD *)(a1 + 32))
                                                                                  + 26LL);
      sub_9EB54(
        v13,
        *(_QWORD *)(a2 + 48),
        *(_QWORD *)(*(_QWORD *)(8LL * v11 + *(_QWORD *)(a1 + 32)) + 32LL),
        *(_BYTE *)(*(_QWORD *)(8LL * v11 + *(_QWORD *)(a1 + 32)) + 26LL),
        (void *)a2,
        1,
        (__int64 *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 32LL),
        0,
        0LL);
      *(_BYTE *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a2 + 32)) + 27LL) = *(_BYTE *)(*(_QWORD *)(8LL * v11
                                                                                              + *(_QWORD *)(a1 + 32))
                                                                                  + 27LL);
    }
  }
  while ( 1 )
  {
    v12 = sub_9EAFC(*(_QWORD *)(a2 + 32), *(_BYTE *)(a2 + 26), (unsigned __int8)v12 + 1, v10);
    if ( v12 == -1 )
      break;
    if ( v10 || v9 == **(_QWORD **)(8LL * v12 + *(_QWORD *)(a2 + 32)) )
    {
      sub_3DD01(v13, (void **)(a2 + 32), (unsigned __int8 *)(a2 + 26), v12);
      LOBYTE(v12) = v12 - 1;
    }
  }
  return 0LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000003E3AF) ----------------------------------------------------
signed __int64 __fastcall sub_3E3AF(__int64 a1)
{
  const char *v1; // rdi
  __int64 v3; // rbx
  __int64 v4; // rbx
  char v5; // al
  __int64 v6; // [rsp+8h] [rbp-78h]
  int v7; // [rsp+1Ch] [rbp-64h]
  unsigned int l; // [rsp+1Ch] [rbp-64h]
  signed int v9; // [rsp+20h] [rbp-60h]
  signed int k; // [rsp+24h] [rbp-5Ch]
  __int64 v11; // [rsp+28h] [rbp-58h]
  __int64 i; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  __int64 j; // [rsp+48h] [rbp-38h]
  __int64 v16; // [rsp+50h] [rbp-30h]
  __int64 v17; // [rsp+58h] [rbp-28h]
  __int64 v18; // [rsp+60h] [rbp-20h]
  unsigned __int64 v19; // [rsp+68h] [rbp-18h]

  v6 = a1;
  v19 = __readfsqword(0x28u);
  v9 = 0;
  for ( i = *(_QWORD *)(a1 + 168); ; i = v13 )
  {
    if ( i )
    {
      v13 = *(_QWORD *)(i + 80);
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    if ( !v5 )
      break;
    v14 = i;
    for ( j = i; j; j = v14 )
    {
      if ( *(_DWORD *)(j + 56) == 4096 )
      {
        v16 = j;
        for ( k = 0; k < *(unsigned __int8 *)(v16 + 30); ++k )
        {
          if ( *(_BYTE *)(*(_QWORD *)(v16 + 112) + 80LL * k + 26) )
          {
            v17 = *(_QWORD *)(v16 + 112) + 80LL * k;
            v11 = 0LL;
            v1 = *(const char **)v17;
            sub_1AF63(*(const char **)v17, *(_QWORD *)(v16 + 72), 49407, 0, &v11);
            if ( !v11 )
            {
              sub_12222(
                *(_QWORD *)v6,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
                3141LL);
              return 1LL;
            }
            v18 = ly_set_new(v1);
            LOBYTE(v7) = -1;
            while ( 1 )
            {
              v7 = sub_9EAFC(*(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26), (unsigned __int8)v7 + 1, 0);
              if ( v7 == -1 )
                break;
              ly_set_add(v18, **(_QWORD **)(8LL * v7 + *(_QWORD *)(v17 + 32)), 0LL);
            }
            for ( l = 0; *(_DWORD *)(v18 + 4) > l; ++l )
            {
              if ( (unsigned int)sub_3DE4E(v17, v11, 0, *(_QWORD *)(8LL * (signed int)l + *(_QWORD *)(v18 + 8))) )
              {
                ly_set_free(v18);
                return 1LL;
              }
            }
            ly_set_free(v18);
            if ( *(_QWORD *)(v17 + 8) && (unsigned int)sub_3DE4E(v17, v11, 6, 0LL) )
              return 1LL;
            if ( *(_QWORD *)(v17 + 16) && (unsigned int)sub_3DE4E(v17, v11, 15, 0LL) )
              return 1LL;
            if ( *(_WORD *)(v17 + 24) & 3 && *(_WORD *)(v11 + 24) & 3 && (unsigned int)sub_3DE4E(v17, v11, 23, 0LL) )
              return 1LL;
            if ( *(_BYTE *)(v17 + 31) && (unsigned int)sub_3DE4E(v17, v11, 5, 0LL) )
              return 1LL;
            if ( *(_WORD *)(v17 + 24) & 0xC0 && (unsigned int)sub_3DE4E(v17, v11, 24, 0LL) )
              return 1LL;
            if ( *(_DWORD *)(v11 + 56) & 1 && *(_QWORD *)(v17 + 72) && (unsigned int)sub_3DE4E(v17, v11, 14, 0LL) )
              return 1LL;
            if ( *(_WORD *)(v17 + 24) & 0x10 && (unsigned int)sub_3DE4E(v17, v11, 29, 0LL) )
              return 1LL;
            if ( *(_WORD *)(v17 + 24) & 8 && (unsigned int)sub_3DE4E(v17, v11, 28, 0LL) )
              return 1LL;
            if ( *(_BYTE *)(v11 + 26) )
            {
              v3 = v11;
              *(_QWORD *)(v3 + 32) = realloc(*(void **)(v11 + 32), 8LL * *(unsigned __int8 *)(v11 + 26));
            }
          }
        }
      }
      if ( *(_DWORD *)(j + 56) & 0x802C )
        v14 = 0LL;
      else
        v14 = *(_QWORD *)(j + 72);
      if ( !v14 )
      {
        if ( j == i )
          break;
        v14 = *(_QWORD *)(j + 80);
      }
      while ( !v14 )
      {
        j = *(_DWORD *)(*(_QWORD *)(j + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(j + 64) + 88LL) : *(_QWORD *)(j + 64);
        v4 = lys_parent(j);
        if ( v4 == lys_parent(i) )
          break;
        v14 = *(_QWORD *)(j + 80);
      }
    }
    if ( !v13 && v9 < *(unsigned __int8 *)(v6 + 77) )
      v13 = *(_QWORD *)(*(_QWORD *)(v6 + 136) + 104LL * v9++ + 72);
  }
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000003E959) ----------------------------------------------------
signed __int64 __fastcall sub_3E959(__int64 a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-14h]
  void *v4; // [rsp+20h] [rbp-10h]

  v4 = **(void ***)(a1 + 48);
  for ( i = 0; ; ++i )
  {
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 64) + 24LL * i) )
      return 0LL;
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 64) + 24LL * i + 16) && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 24LL * i + 16) != 3 )
    {
      if ( *(_DWORD *)(*(_QWORD *)(a1 + 64) + 24LL * i + 16) != 2 )
      {
        switch ( *(_DWORD *)(*(_QWORD *)(a1 + 64) + 24LL * i) )
        {
          case 0x14:
          case 0x15:
          case 0x1B:
            if ( *(_BYTE *)lys_ext_complex_get_substmt(*(unsigned int *)(*(_QWORD *)(a1 + 64) + 24LL * i), a1, 0LL) )
              continue;
            sub_13937(
              v4,
              12,
              0,
              0LL,
              (__int64)*(&off_3460E0 + *(signed int *)(*(_QWORD *)(a1 + 64) + 24LL * i)),
              a2,
              a2);
            return 1LL;
          case 0x17:
            if ( *(_WORD *)lys_ext_complex_get_substmt(*(unsigned int *)(*(_QWORD *)(a1 + 64) + 24LL * i), a1, 0LL) & 3 )
              continue;
            sub_13937(
              v4,
              12,
              0,
              0LL,
              (__int64)*(&off_3460E0 + *(signed int *)(*(_QWORD *)(a1 + 64) + 24LL * i)),
              a2,
              a2);
            return 1LL;
          case 0x18:
            if ( *(_WORD *)lys_ext_complex_get_substmt(*(unsigned int *)(*(_QWORD *)(a1 + 64) + 24LL * i), a1, 0LL) & 0xC0 )
              continue;
            sub_13937(
              v4,
              12,
              0,
              0LL,
              (__int64)*(&off_3460E0 + *(signed int *)(*(_QWORD *)(a1 + 64) + 24LL * i)),
              a2,
              a2);
            return 1LL;
          case 0x19:
            continue;
          case 0x1A:
            if ( *(_WORD *)lys_ext_complex_get_substmt(*(unsigned int *)(*(_QWORD *)(a1 + 64) + 24LL * i), a1, 0LL) & 0x38 )
              continue;
            sub_13937(
              v4,
              12,
              0,
              0LL,
              (__int64)*(&off_3460E0 + *(signed int *)(*(_QWORD *)(a1 + 64) + 24LL * i)),
              a2,
              a2);
            return 1LL;
          default:
            break;
        }
      }
      if ( !*(_QWORD *)lys_ext_complex_get_substmt(*(unsigned int *)(*(_QWORD *)(a1 + 64) + 24LL * i), a1, 0LL) )
        break;
    }
  }
  sub_13937(v4, 12, 0, 0LL, (__int64)*(&off_3460E0 + *(signed int *)(*(_QWORD *)(a1 + 64) + 24LL * i)), a2, a2);
  return 1LL;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 3460E0: using guessed type void *off_3460E0;

//----- (000000000003EDFE) ----------------------------------------------------
signed __int64 __fastcall sub_3EDFE(__int64 a1, __int64 **a2)
{
  void *ptr; // ST18_8
  int v4; // [rsp+10h] [rbp-10h]
  int v5; // [rsp+14h] [rbp-Ch]

  LOBYTE(v4) = -1;
  v5 = 0;
  while ( 1 )
  {
    v4 = sub_9EAFC(*(_QWORD *)(a1 + 32), *(_BYTE *)(a1 + 26), (unsigned __int8)v4 + 1, *((unsigned __int8 *)a2 + 28));
    if ( v4 == -1 )
      break;
    if ( **(__int64 ***)(8LL * v4 + *(_QWORD *)(a1 + 32)) == *a2
      && (!(*a2)[5] || *(__int64 **)(*(_QWORD *)(8LL * v4 + *(_QWORD *)(a1 + 32)) + 16LL) == a2[2]) )
    {
      ++v5;
      sub_3DD01(**(_QWORD **)(a1 + 48), (void **)(a1 + 32), (unsigned __int8 *)(a1 + 26), v4);
      LOBYTE(v4) = v4 - 1;
    }
  }
  if ( v5 )
    return 0LL;
  ptr = (void *)lys_path(a1, 1LL);
  sub_12222(
    **(_QWORD **)(a1 + 48),
    0,
    5,
    "Extension deviation: extension \"%s\" to delete not found in \"%s\".",
    **a2,
    (__int64)ptr,
    a2);
  free(ptr);
  return 1LL;
}
// 7680: using guessed type __int64 __fastcall lys_path(_QWORD, _QWORD);

//----- (000000000003EF69) ----------------------------------------------------
signed __int64 __fastcall sub_3EF69(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  int i; // eax
  __int64 v5; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // rbx
  __int64 v10; // [rsp+0h] [rbp-50h]
  int v11; // [rsp+Ch] [rbp-44h]
  int v12; // [rsp+20h] [rbp-30h]
  int v13; // [rsp+24h] [rbp-2Ch]
  void *ptr; // [rsp+28h] [rbp-28h]
  __int64 v15; // [rsp+30h] [rbp-20h]
  void *v16; // [rsp+38h] [rbp-18h]

  v11 = a3;
  v10 = a4;
  v15 = **(_QWORD **)(a2 + 48);
  LOBYTE(v13) = -1;
  for ( i = sub_9EAFC(*(_QWORD *)(a1 + 64), *(_BYTE *)(a1 + 6), 0, a3);
        ;
        i = sub_9EAFC(*(_QWORD *)(a1 + 64), *(_BYTE *)(a1 + 6), (unsigned __int8)v12 + 1, v11) )
  {
    v12 = i;
    if ( i == -1 )
      break;
    if ( v11 || v10 == **(_QWORD **)(8LL * i + *(_QWORD *)(a1 + 64)) )
    {
      if ( v11 || *(_DWORD *)a1 != 1 )
      {
        do
          v13 = sub_9EAFC(*(_QWORD *)(a2 + 32), *(_BYTE *)(a2 + 26), (unsigned __int8)v13 + 1, v11);
        while ( v13 != -1 && !v11 && v10 != **(_QWORD **)(8LL * v13 + *(_QWORD *)(a2 + 32)) );
      }
      else
      {
        do
          v13 = sub_9EAFC(*(_QWORD *)(a2 + 32), *(_BYTE *)(a2 + 26), (unsigned __int8)v13 + 1, 0);
        while ( v13 != -1
             && (v10 != **(_QWORD **)(8LL * v13 + *(_QWORD *)(a2 + 32))
              || !(*(_WORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 24LL) & 1)) );
      }
      if ( v13 == -1 )
      {
        ptr = malloc(0x40uLL);
        if ( !ptr )
        {
          sub_12222(v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_deviate_apply_ext", v5, v10);
          return 1LL;
        }
        v16 = realloc(*(void **)(a2 + 32), 8LL * (*(unsigned __int8 *)(a2 + 26) + 1));
        if ( !v16 )
        {
          sub_12222(v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_deviate_apply_ext", v7, v10);
          free(ptr);
          return 1LL;
        }
        *(_QWORD *)(a2 + 32) = v16;
        v13 = (unsigned __int8)++*(_BYTE *)(a2 + 26) - 1;
      }
      else
      {
        sub_AAE3B(
          v15,
          *(void ****)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 32LL),
          *(unsigned __int8 *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 26LL),
          0LL);
        lydict_remove(v15, *(_QWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 16LL));
        free(*(void **)(8LL * v13 + *(_QWORD *)(a2 + 32)));
        ptr = malloc(0x40uLL);
        if ( !ptr )
        {
          sub_12222(v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_deviate_apply_ext", v8, v10);
          return 1LL;
        }
      }
      *(_QWORD *)(*(_QWORD *)(a2 + 32) + 8LL * v13) = ptr;
      **(_QWORD **)(8LL * v13 + *(_QWORD *)(a2 + 32)) = **(_QWORD **)(8LL * v12 + *(_QWORD *)(a1 + 64));
      v9 = *(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32));
      *(_QWORD *)(v9 + 16) = lydict_insert(v15, *(_QWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a1 + 64)) + 16LL), 0LL);
      *(_WORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 24LL) = 0;
      *(_QWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 8LL) = a2;
      *(_BYTE *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 29LL) = 1;
      *(_BYTE *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 28LL) = v11;
      *(_BYTE *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 27LL) = *(_BYTE *)(*(_QWORD *)(8LL * v12
                                                                                              + *(_QWORD *)(a1 + 64))
                                                                                  + 27LL);
      *(_BYTE *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 26LL) = *(_BYTE *)(*(_QWORD *)(8LL * v12
                                                                                              + *(_QWORD *)(a1 + 64))
                                                                                  + 26LL);
      sub_9EB54(
        v15,
        *(_QWORD *)(a2 + 48),
        *(_QWORD *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a1 + 64)) + 32LL),
        *(_BYTE *)(*(_QWORD *)(8LL * v12 + *(_QWORD *)(a1 + 64)) + 26LL),
        (void *)a2,
        1,
        (__int64 *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 32LL),
        1,
        0LL);
      *(_DWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 56LL) = 0x10000;
      *(_QWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 48LL) = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 40LL) = 0LL;
    }
  }
  while ( 1 )
  {
    v13 = sub_9EAFC(*(_QWORD *)(a2 + 32), *(_BYTE *)(a2 + 26), (unsigned __int8)v13 + 1, v11);
    if ( v13 == -1 )
      break;
    if ( v11
      || v10 == **(_QWORD **)(8LL * v13 + *(_QWORD *)(a2 + 32))
      && (*(_DWORD *)a1 != 1 || *(_WORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(a2 + 32)) + 24LL) & 1) )
    {
      sub_3DD01(v15, (void **)(a2 + 32), (unsigned __int8 *)(a2 + 26), v13);
      LOBYTE(v13) = v13 - 1;
    }
  }
  return 0LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000003F5FE) ----------------------------------------------------
signed __int64 __fastcall sub_3F5FE(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // [rsp+8h] [rbp-38h]
  signed int i; // [rsp+14h] [rbp-2Ch]
  signed int j; // [rsp+18h] [rbp-28h]
  int v6; // [rsp+1Ch] [rbp-24h]
  int v7; // [rsp+1Ch] [rbp-24h]
  unsigned int k; // [rsp+1Ch] [rbp-24h]
  __int64 v9; // [rsp+20h] [rbp-20h]
  __int64 v10; // [rsp+28h] [rbp-18h]
  __int64 v11; // [rsp+30h] [rbp-10h]
  unsigned __int64 v12; // [rsp+38h] [rbp-8h]

  v3 = a1;
  v12 = __readfsqword(0x28u);
  for ( i = 0; i < *(unsigned __int8 *)(v3 + 78); ++i )
  {
    v10 = 0LL;
    v9 = 0LL;
    if ( (unsigned int)sub_1A193(*(char **)(*(_QWORD *)(v3 + 144) + 56LL * i), 0LL, v3, &v9, 0, 0) == -1 )
      return 1LL;
    if ( v9 )
    {
      v10 = **(_QWORD **)(v9 + 8);
      v2 = v9;
      ly_set_free(v9);
      for ( j = 0; j < *(unsigned __int8 *)(*(_QWORD *)(v3 + 144) + 56LL * i + 32); ++j )
      {
        v11 = *(_QWORD *)(*(_QWORD *)(v3 + 144) + 56LL * i + 40) + 72LL * j;
        if ( *(_BYTE *)(v11 + 6) )
        {
          if ( *(_DWORD *)v11 == 3 )
          {
            LOBYTE(v6) = -1;
            while ( 1 )
            {
              v2 = *(_QWORD *)(v11 + 64);
              v6 = sub_9EAFC(v2, *(_BYTE *)(v11 + 6), (unsigned __int8)v6 + 1, 0);
              if ( v6 == -1 )
                break;
              if ( (unsigned int)sub_3EDFE(v10, *(__int64 ***)(8LL * v6 + *(_QWORD *)(v11 + 64))) )
                return 1LL;
            }
          }
          else
          {
            v9 = ly_set_new(v2);
            LOBYTE(v7) = -1;
            while ( 1 )
            {
              v7 = sub_9EAFC(*(_QWORD *)(v11 + 64), *(_BYTE *)(v11 + 6), (unsigned __int8)v7 + 1, 0);
              if ( v7 == -1 )
                break;
              ly_set_add(v9, **(_QWORD **)(8LL * v7 + *(_QWORD *)(v11 + 64)), 0LL);
            }
            for ( k = 0; *(_DWORD *)(v9 + 4) > k; ++k )
            {
              if ( (unsigned int)sub_3EF69(v11, v10, 0, *(_QWORD *)(8LL * (signed int)k + *(_QWORD *)(v9 + 8))) )
              {
                ly_set_free(v9);
                return 1LL;
              }
            }
            v2 = v9;
            ly_set_free(v9);
            if ( *(_BYTE *)(v11 + 10) )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 31, 0LL) )
                return 1LL;
            }
            if ( *(_QWORD *)(v11 + 48) )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 17, 0LL) )
                return 1LL;
            }
            if ( *(_BYTE *)(v11 + 5) )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 5, 0LL) )
                return 1LL;
            }
            if ( *(_BYTE *)(v11 + 4) & 3 )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 23, 0LL) )
                return 1LL;
            }
            if ( *(_BYTE *)(v11 + 4) & 0xC0 )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 24, 0LL) )
                return 1LL;
            }
            if ( *(_BYTE *)(v11 + 7) )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 29, 0LL) )
                return 1LL;
            }
            if ( *(_BYTE *)(v11 + 7) )
            {
              v2 = v11;
              if ( (unsigned int)sub_3EF69(v11, v10, 28, 0LL) )
                return 1LL;
            }
          }
        }
      }
    }
    else
    {
      ly_set_free(0LL);
    }
  }
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000003FA66) ----------------------------------------------------
signed __int64 __fastcall sub_3FA66(__int64 a1)
{
  __int64 v1; // r9
  const char *v2; // rax
  const char *v4; // rax
  const char *v5; // rax
  signed int i; // [rsp+14h] [rbp-1Ch]
  signed int j; // [rsp+14h] [rbp-1Ch]
  signed int v8; // [rsp+18h] [rbp-18h]
  int v9; // [rsp+1Ch] [rbp-14h]
  char *s1; // [rsp+20h] [rbp-10h]
  __int64 v11; // [rsp+28h] [rbp-8h]

  v8 = -1;
  s1 = 0LL;
  if ( !a1 )
    __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser.c", 0xDD1u, "lyp_ctx_check_module");
  v9 = 0;
  v11 = *(_QWORD *)a1;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 68); ++i )
  {
    if ( !s1 || strcmp(s1, (const char *)(*(_QWORD *)(a1 + 88) + 40LL * i)) < 0 )
      s1 = (char *)(*(_QWORD *)(a1 + 88) + 40LL * i);
  }
  for ( j = 0; ; ++j )
  {
    if ( j >= *(_DWORD *)(v11 + 60) )
    {
      if ( !v9 )
        return 0LL;
      if ( (unsigned int)lys_set_implemented(*(_QWORD *)(8LL * v8 + *(_QWORD *)(v11 + 64))) )
        return 0xFFFFFFFFLL;
      return 1LL;
    }
    if ( strcmp(*(const char **)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 8LL), *(const char **)(a1 + 8)) )
    {
      if ( !strcmp(*(const char **)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 176LL), *(const char **)(a1 + 176)) )
      {
        sub_12222(
          v11,
          0,
          3,
          "Two different modules (\"%s\" and \"%s\") have the same namespace \"%s\".",
          *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 8LL),
          *(_QWORD *)(a1 + 8),
          *(_QWORD *)(a1 + 176));
        return 0xFFFFFFFFLL;
      }
      continue;
    }
    if ( !v9 )
      break;
    if ( j != v8 )
    {
      if ( s1 )
        v2 = s1;
      else
        v2 = "<latest>";
      sub_12222(
        v11,
        0,
        3,
        "Module \"%s@%s\" in another revision \"%s\" already implemented.",
        *(_QWORD *)(a1 + 8),
        (__int64)v2,
        *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 88LL));
      return 0xFFFFFFFFLL;
    }
LABEL_43:
    ;
  }
  if ( !*(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 68LL) && *(_BYTE *)(a1 + 68) )
  {
    sub_12222(v11, 0, 3, "Module \"%s\" without revision already in context.", *(_QWORD *)(a1 + 8), v1);
    return 0xFFFFFFFFLL;
  }
  if ( *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 68LL) && !*(_BYTE *)(a1 + 68) )
  {
    sub_12222(
      v11,
      0,
      3,
      "Module \"%s\" with revision \"%s\" already in context.",
      *(_QWORD *)(a1 + 8),
      *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 88LL));
    return 0xFFFFFFFFLL;
  }
  if ( !*(_BYTE *)(a1 + 68) && !*(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 68LL)
    || !strcmp(*(const char **)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 88LL), s1) )
  {
    if ( s1 )
      v4 = s1;
    else
      v4 = "<latest>";
    sub_12222(0LL, 2u, 0, "Module \"%s@%s\" already in context.", *(_QWORD *)(a1 + 8), (__int64)v4);
    if ( *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 64LL) & 0x40 )
      lys_set_enabled(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)));
    v9 = (unsigned __int8)(*(_BYTE *)(a1 + 64) >> 7);
    v8 = j;
    if ( *(_BYTE *)(a1 + 64) >= 0 || *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 64LL) < 0 )
      return 1LL;
    j = -1;
    goto LABEL_43;
  }
  if ( *(_BYTE *)(a1 + 64) >= 0 || *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 64LL) >= 0 )
    goto LABEL_43;
  if ( s1 )
    v5 = s1;
  else
    v5 = "<latest>";
  sub_12222(
    v11,
    0,
    3,
    "Module \"%s@%s\" in another revision \"%s\" already implemented.",
    *(_QWORD *)(a1 + 8),
    (__int64)v5,
    *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 64)) + 88LL));
  return 0xFFFFFFFFLL;
}
// 73C0: using guessed type __int64 __fastcall lys_set_enabled(_QWORD);
// 74B0: using guessed type __int64 __fastcall lys_set_implemented(_QWORD);

//----- (000000000003FFC3) ----------------------------------------------------
signed __int64 __fastcall sub_3FFC3(__int64 *a1)
{
  __int64 v1; // r9
  __int64 v3; // rsi
  int v4; // edx
  signed int i; // [rsp+10h] [rbp-10h]
  signed int j; // [rsp+10h] [rbp-10h]
  int l; // [rsp+10h] [rbp-10h]
  signed int k; // [rsp+14h] [rbp-Ch]
  _QWORD *v9; // [rsp+18h] [rbp-8h]

  if ( (unsigned int)sub_3FA66((__int64)a1) )
    __assert_fail(
      "!lyp_ctx_check_module(module)",
      "/home/mantovan/Repositories/libyang/src/parser.c",
      0xE1Fu,
      "lyp_ctx_add_module");
  for ( i = 0; i < *((unsigned __int8 *)a1 + 77); ++i )
  {
    if ( !*(_QWORD *)(a1[17] + 104LL * i + 88) )
      __assert_fail(
        "module->augment[i].target",
        "/home/mantovan/Repositories/libyang/src/parser.c",
        0xE25u,
        "lyp_ctx_add_module");
  }
  for ( j = 0; j < *((unsigned __int8 *)a1 + 70); ++j )
  {
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a1[13] + 48LL * j) + 77LL); ++k )
    {
      if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[13] + 48LL * j) + 136LL) + 104LL * k + 88) )
        __assert_fail(
          "module->inc[i].submodule->augment[j].target",
          "/home/mantovan/Repositories/libyang/src/parser.c",
          0xE29u,
          "lyp_ctx_add_module");
    }
  }
  if ( *(_DWORD *)(*a1 + 60) == *(_DWORD *)(*a1 + 56) )
  {
    v9 = realloc(*(void **)(*a1 + 64), 16LL * *(signed int *)(*a1 + 56));
    if ( !v9 )
    {
      sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_ctx_add_module", v1);
      return 0xFFFFFFFFLL;
    }
    for ( l = *(_DWORD *)(*a1 + 56); l < 2 * *(_DWORD *)(*a1 + 56); ++l )
      v9[l] = 0LL;
    *(_DWORD *)(*a1 + 56) *= 2;
    *(_QWORD *)(*a1 + 64) = v9;
  }
  v3 = *(_QWORD *)(*a1 + 64);
  v4 = *(_DWORD *)(*a1 + 60);
  *(_DWORD *)(*a1 + 60) = v4 + 1;
  *(_QWORD *)(v3 + 8LL * v4) = a1;
  ++*(_WORD *)(*a1 + 90);
  return 0LL;
}

//----- (0000000000040272) ----------------------------------------------------
signed __int64 __fastcall sub_40272(void *a1, _BYTE *a2, signed int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+Ch] [rbp-14h]

  v7 = a3;
  if ( a3 > 127 )
  {
    if ( a3 <= 2047 )
    {
      *a2 = (a3 >> 6) | 0xC0;
      a2[1] = a3 & 0x3F | 0x80;
      return 2LL;
    }
    if ( a3 > 65533 )
    {
      if ( a3 <= 1114109 && (a3 & 0xFFE) != 4094 )
      {
        *a2 = (a3 >> 18) | 0xF0;
        a2[1] = (a3 >> 12) & 0x3F | 0x80;
        a2[2] = (a3 >> 6) & 0x3F | 0x80;
        a2[3] = a3 & 0x3F | 0x80;
        return 4LL;
      }
    }
    else if ( (a3 & 0xF800) != 55296 && (a3 <= 64975 || a3 > 65007) )
    {
      *a2 = (a3 >> 12) | 0xE0;
      a2[1] = (a3 >> 6) & 0x3F | 0x80;
      a2[2] = a3 & 0x3F | 0x80;
      return 3LL;
    }
  }
  else if ( a3 > 31 || a3 == 9 || a3 == 10 || a3 == 13 )
  {
    *a2 = a3;
    return 1LL;
  }
  sub_13937(a1, 3, 0, 0LL, 0LL, a6);
  sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v7);
  return 0LL;
}

//----- (0000000000040445) ----------------------------------------------------
signed __int64 __fastcall sub_40445(void *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  char *v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+2Ch] [rbp-4h]
  unsigned int v9; // [rsp+2Ch] [rbp-4h]

  v7 = a3;
  if ( *a3 < 0 )
  {
    if ( *a3 & 0x20 )
    {
      if ( *a3 & 0x10 )
      {
        if ( *a3 & 8 )
        {
          sub_13937(a1, 3, 0, 0LL, (__int64)a3, a6);
          sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid UTF-8 leading byte 0x%02x", (unsigned int)*v7);
          result = 0LL;
        }
        else
        {
          v9 = (a3[2] << 6) & 0xFC0 | (a3[1] << 12) & 0x3F000 | (*a3 << 18) & 0x1C0000 | a3[3] & 0x3F;
          if ( (((a3[2] << 6) & 0xFC0 | (a3[1] << 12) & 0xF000 | a3[3] & 0x3F) & 0xFFE) == 4094 )
          {
            sub_13937(a1, 3, 0, 0LL, (__int64)a3, a6);
            sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v9);
            result = 0LL;
          }
          else
          {
            *(_WORD *)a2 = *(_WORD *)a3;
            *(_BYTE *)(a2 + 2) = a3[2];
            *(_BYTE *)(a2 + 3) = a3[3];
            result = 4LL;
          }
        }
      }
      else
      {
        v8 = (unsigned __int16)(*a3 << 12) | (a3[1] << 6) & 0xFC0 | a3[2] & 0x3F;
        if ( (v8 & 0xF800) != 55296 && (v8 <= 0xFDCF || v8 > 0xFDEF) && (v8 & 0xFFE) != 4094 )
        {
          *(_WORD *)a2 = *(_WORD *)a3;
          *(_BYTE *)(a2 + 2) = a3[2];
          result = 3LL;
        }
        else
        {
          sub_13937(a1, 3, 0, 0LL, (__int64)a3, a6);
          sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v8);
          result = 0LL;
        }
      }
    }
    else
    {
      *(_BYTE *)a2 = *a3;
      *(_BYTE *)(a2 + 1) = a3[1];
      result = 2LL;
    }
  }
  else if ( *a3 > 31 || *a3 == 9 || *a3 == 10 || *a3 == 13 )
  {
    *(_BYTE *)a2 = *a3;
    result = 1LL;
  }
  else
  {
    sub_13937(a1, 3, 0, 0LL, (__int64)a3, a6);
    sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%02x", (unsigned int)*v7);
    result = 0LL;
  }
  return result;
}

//----- (00000000000407F3) ----------------------------------------------------
__int64 __fastcall sub_407F3(__int64 *a1, const char *a2, int a3, char *a4, int a5, int a6)
{
  __int64 result; // rax
  __int64 v7; // r9
  int v8; // [rsp+Ch] [rbp-44h]
  char *s2; // [rsp+10h] [rbp-40h]
  int v10; // [rsp+18h] [rbp-38h]
  int v11; // [rsp+1Ch] [rbp-34h]
  signed int i; // [rsp+3Ch] [rbp-14h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  char *ptr; // [rsp+48h] [rbp-8h]

  v11 = a3;
  s2 = a4;
  v10 = a5;
  v8 = a6;
  if ( a2 && a4 )
    __assert_fail("!prefix || !name", "/home/mantovan/Repositories/libyang/src/parser.c", 0xECAu, "lyp_get_module");
  if ( a2 && !a3 )
    v11 = strlen(a2);
  if ( s2 && !v10 )
    v10 = strlen(s2);
  v13 = lys_main_module(a1);
  if ( (!a2
     || !(a1[8] & 1) && !strncmp(*(const char **)(v13 + 16), a2, v11) && !*(_BYTE *)(*(_QWORD *)(v13 + 16) + v11)
     || a1[8] & 1 && !strncmp((const char *)a1[2], a2, v11) && !*(_BYTE *)(a1[2] + v11))
    && (!s2 || !strncmp(*(const char **)(v13 + 8), s2, v10) && !*(_BYTE *)(*(_QWORD *)(v13 + 8) + v10)) )
  {
    return v13;
  }
  for ( i = 0; i < *((unsigned __int8 *)a1 + 69); ++i )
  {
    if ( (!a2
       || !strncmp(*(const char **)(a1[12] + 56LL * i + 8), a2, v11)
       && !*(_BYTE *)(*(_QWORD *)(a1[12] + 56LL * i + 8) + v11))
      && (!s2
       || !strncmp(*(const char **)(*(_QWORD *)(a1[12] + 56LL * i) + 8LL), s2, v10)
       && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1[12] + 56LL * i) + 8LL) + v10)) )
    {
      return *(_QWORD *)(a1[12] + 56LL * i);
    }
  }
  if ( !s2 )
    return 0LL;
  ptr = strndup(s2, v10);
  if ( ptr )
  {
    v14 = ly_ctx_get_module(*a1, ptr, 0LL, 0LL);
    if ( !v14 && v8 )
    {
      if ( *(_QWORD *)(*a1 + 112) )
        v14 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD, _QWORD, _QWORD))(*a1 + 112))(
                *a1,
                ptr,
                0LL,
                0LL,
                *(_QWORD *)(*a1 + 120));
    }
    free(ptr);
    result = v14;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_get_module", v7);
    result = 0LL;
  }
  return result;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000040BA1) ----------------------------------------------------
__int64 __fastcall sub_40BA1(__int64 a1, _BYTE *a2)
{
  signed int i; // [rsp+14h] [rbp-Ch]

  if ( !a1 || !a2 )
    __assert_fail(
      "module && ns",
      "/home/mantovan/Repositories/libyang/src/parser.c",
      0xEFFu,
      "lyp_get_import_module_ns");
  if ( *(_BYTE *)(a1 + 64) & 1 )
  {
    if ( (unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(a1 + 168) + 176LL), a2) )
      return *(_QWORD *)(a1 + 168);
  }
  else if ( (unsigned int)sub_C462(*(_BYTE **)(a1 + 176), a2) )
  {
    return a1;
  }
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 69); ++i )
  {
    if ( (unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i) + 176LL), a2) )
      return *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i);
  }
  return 0LL;
}

//----- (0000000000040CD4) ----------------------------------------------------
__int64 __fastcall sub_40CD4(_QWORD *a1)
{
  __int64 result; // rax
  __int64 i; // [rsp+18h] [rbp-8h]

  for ( i = lys_parent(*a1); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
    ;
  if ( i && *(_DWORD *)(i + 56) == 0x10000 && !strcmp(**(const char ***)i, "yang-data") )
    result = *(_QWORD *)(i + 16);
  else
    result = 0LL;
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (0000000000040D5F) ----------------------------------------------------
__int64 __fastcall sub_40D5F(__int64 a1, const char *a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-34h]
  signed int i; // [rsp+28h] [rbp-18h]
  signed int k; // [rsp+28h] [rbp-18h]
  signed int j; // [rsp+2Ch] [rbp-14h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v8 = 0LL;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 80); ++i )
  {
    if ( !strcmp(***(const char ****)(8LL * i + *(_QWORD *)(a1 + 160)), "yang-data")
      && !strncmp(*(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 160)) + 16LL), a2, v4)
      && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 160)) + 16LL) + v4) )
    {
      v8 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 160));
      break;
    }
  }
  for ( j = 0; !v8 && j < *(unsigned __int8 *)(a1 + 70); ++j )
  {
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * j);
    for ( k = 0; k < *(unsigned __int8 *)(v9 + 80); ++k )
    {
      if ( !strcmp(***(const char ****)(8LL * k + *(_QWORD *)(v9 + 160)), "yang-data")
        && !strncmp(*(const char **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 160)) + 16LL), a2, v4)
        && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 160)) + 16LL) + v4) )
      {
        v8 = *(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 160));
        break;
      }
    }
  }
  return v8;
}

//----- (0000000000040F96) ----------------------------------------------------
_BOOL8 __fastcall sub_40F96(__int64 a1, int a2, int a3, char a4, __int64 *a5, __int64 a6, __int64 *a7, char a8, __int64 a9)
{
  __int64 v9; // r9
  _BOOL8 result; // rax
  __int64 v11; // [rsp+8h] [rbp-38h]
  __int64 *v12; // [rsp+10h] [rbp-30h]
  char v13; // [rsp+1Ch] [rbp-24h]
  int v14; // [rsp+20h] [rbp-20h]
  _DWORD *v15; // [rsp+38h] [rbp-8h]

  v14 = a3;
  v12 = a5;
  v11 = a6;
  v13 = a4;
  v15 = malloc(0x30uLL);
  if ( v15 )
  {
    lyxml_unlink(*v12, v11);
    *(_QWORD *)v15 = v11;
    v15[2] = 2;
    *((_QWORD *)v15 + 2) = a1;
    *((_QWORD *)v15 + 3) = v12;
    v15[8] = a2;
    v15[9] = v14;
    *((_BYTE *)v15 + 40) = v13;
    *((_BYTE *)v15 + 41) = a8;
    result = (unsigned int)sub_2ABDE(v12, a9, a7, 0x10000u, (__int64 *)v15) == -1;
  }
  else
  {
    sub_12222(*v12, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_fill_ext", v9);
    result = 1LL;
  }
  return result;
}
// 7B70: using guessed type __int64 __fastcall lyxml_unlink(_QWORD, _QWORD);

//----- (00000000000410A7) ----------------------------------------------------
__int64 __fastcall sub_410A7(void *a1, __int64 a2, const char *a3)
{
  __int64 result; // rax
  int v4; // ST2C_4
  char *s2; // [rsp+8h] [rbp-28h]

  s2 = (char *)a3;
  if ( *(_QWORD *)(a2 + 24)
    && *(_QWORD *)(*(_QWORD *)(a2 + 24) + 48LL)
    && !strcmp(*(const char **)(*(_QWORD *)(a2 + 24) + 48LL), a3) )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a2 + 24) + 64LL) )
    {
      v4 = strlen(*(const char **)(*(_QWORD *)(a2 + 24) + 64LL));
      result = lydict_insert(a1, *(_QWORD *)(*(_QWORD *)(a2 + 24) + 64LL), v4);
    }
    else
    {
      result = lydict_insert(a1, &unk_10F10F, 0LL);
    }
  }
  else
  {
    sub_12222((__int64)a1, 0, 5, "Expected \"%s\" element in \"%s\" element.", (__int64)s2, *(_QWORD *)(a2 + 48));
    sub_13937(a1, 10, 0, 0LL, (__int64)s2, *(_QWORD *)(a2 + 48));
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000411CA) ----------------------------------------------------
signed __int64 __fastcall sub_411CA(__int64 *a1, __int64 a2, unsigned int a3, _QWORD *a4, int a5, __int64 a6, __int64 a7)
{
  const char *v7; // rax
  __int64 v9; // r9
  _BOOL4 v10; // eax
  char v11; // al
  char v12; // [rsp+Ch] [rbp-64h]
  _QWORD *v13; // [rsp+10h] [rbp-60h]
  int v14; // [rsp+18h] [rbp-58h]
  int v15; // [rsp+1Ch] [rbp-54h]
  _QWORD *v16; // [rsp+40h] [rbp-30h]
  _QWORD *v17; // [rsp+48h] [rbp-28h]
  void **v18; // [rsp+50h] [rbp-20h]
  char *v19; // [rsp+58h] [rbp-18h]
  const char *v20; // [rsp+60h] [rbp-10h]
  void *v21; // [rsp+68h] [rbp-8h]

  v15 = a3;
  v13 = a4;
  v14 = a5;
  v12 = a6;
  switch ( (unsigned __int64)a3 )
  {
    case 0uLL:
      v19 = (char *)(a2 + 80);
      v18 = (void **)(a2 + 160);
      if ( *(_BYTE *)(a2 + 64) & 1 )
        v7 = "submodule";
      else
        v7 = "module";
      v20 = v7;
      goto LABEL_24;
    case 1uLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = sub_8164(*(_DWORD *)(a2 + 56));
      goto LABEL_24;
    case 2uLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = " typedef";
      goto LABEL_24;
    case 3uLL:
      v19 = (char *)(a2 + 5);
      v18 = (void **)(a2 + 8);
      v20 = "type";
      goto LABEL_24;
    case 4uLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "bit";
      goto LABEL_24;
    case 5uLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "enum";
      goto LABEL_24;
    case 6uLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "feature";
      goto LABEL_24;
    case 7uLL:
      v19 = (char *)(a2 + 48);
      v18 = (void **)(a2 + 40);
      v20 = "YANG restriction";
      goto LABEL_24;
    case 8uLL:
      v19 = (char *)(a2 + 32);
      v18 = (void **)(a2 + 24);
      v20 = "when";
      goto LABEL_24;
    case 9uLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "identity";
      goto LABEL_24;
    case 0xAuLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "extension";
      goto LABEL_24;
    case 0xBuLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "extension instance";
      goto LABEL_24;
    case 0xCuLL:
      v19 = (char *)(a2 + 26);
      v18 = (void **)(a2 + 32);
      v20 = "refine";
      goto LABEL_24;
    case 0xDuLL:
      v19 = (char *)(a2 + 33);
      v18 = (void **)(a2 + 48);
      v20 = "deviation";
      goto LABEL_24;
    case 0xEuLL:
      v19 = (char *)(a2 + 6);
      v18 = (void **)(a2 + 64);
      v20 = "deviate";
      goto LABEL_24;
    case 0xFuLL:
      v19 = (char *)(a2 + 27);
      v18 = (void **)(a2 + 32);
      v20 = "import";
      goto LABEL_24;
    case 0x10uLL:
      v19 = (char *)(a2 + 19);
      v18 = (void **)(a2 + 24);
      v20 = "include";
      goto LABEL_24;
    case 0x11uLL:
      v19 = (char *)(a2 + 11);
      v18 = (void **)(a2 + 16);
      v20 = "revision";
LABEL_24:
      if ( v14 )
      {
        v17 = (_QWORD *)v13[3];
        goto LABEL_37;
      }
      v17 = v13;
      v16 = 0LL;
      break;
    default:
      sub_12222(*a1, 0, 4, "parent type %d", a3, a6);
      return 1LL;
  }
LABEL_30:
  if ( *v19 == -1 )
  {
    sub_12222(*a1, 0, 4, "Reached limit (%lu) for storing %s in %s statement.", 255LL, (__int64)"extension", v20);
    return 1LL;
  }
  v21 = realloc(*v18, 8LL * ((unsigned __int8)*v19 + 1));
  if ( !v21 )
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_subnode_ext", v9);
    return 1LL;
  }
  *v18 = v21;
  *((_QWORD *)*v18 + (unsigned __int8)*v19) = 0LL;
  v10 = sub_40F96(a2, v15, v14, v12, a1, (__int64)v17, (__int64 *)v18, *v19, a7);
  ++*v19;
  if ( v10 )
    return 1LL;
  while ( 1 )
  {
    v17 = v16;
LABEL_37:
    if ( v17 )
    {
      v16 = (_QWORD *)v17[4];
      v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    if ( !v11 )
      return 0LL;
    if ( !v17[7] )
    {
      sub_13937((void *)*a1, -1, 0, 0LL, (__int64)"Extension instance \"%s\" is missing namespace.", v17[6]);
      return 1LL;
    }
    if ( strcmp(*(const char **)(v17[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      goto LABEL_30;
  }
}

//----- (0000000000041746) ----------------------------------------------------
signed __int64 __fastcall sub_41746(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v6; // ST5C_4
  char v7; // al
  __int64 v8; // r9
  _BOOL4 v9; // eax
  char v10; // al
  __int64 v11; // [rsp+8h] [rbp-58h]
  __int64 v12; // [rsp+10h] [rbp-50h]
  __int64 v13; // [rsp+18h] [rbp-48h]
  int v14; // [rsp+38h] [rbp-28h]
  _QWORD *i; // [rsp+40h] [rbp-20h]
  __int64 j; // [rsp+40h] [rbp-20h]
  _QWORD *v17; // [rsp+48h] [rbp-18h]
  void *v18; // [rsp+50h] [rbp-10h]
  char *s; // [rsp+58h] [rbp-8h]
  char *sa; // [rsp+58h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v14 = 0;
  v18 = **(void ***)(a1 + 48);
  s = (char *)lyxml_get_attr(a3, "name", 0LL);
  if ( !s )
  {
    sub_13937(v18, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(v13 + 48));
    return 1LL;
  }
  if ( (*(_BYTE *)(lys_node_module(a1) + 64) & 0xE) != 4 && (*s == 40 || strchr(s, 32)) )
  {
    sub_13937(v18, 10, 0, 0LL, (__int64)s, (__int64)"if-feature");
    return 1LL;
  }
  sa = (char *)sub_A2CB(*(__int64 **)(a1 + 48), s);
  if ( !sa )
    return 1LL;
  v6 = sub_19120((__int64 *)v12, sa, a1, a2, v11);
  lydict_remove(v18, sa);
  if ( v6 )
    return 1LL;
  for ( i = *(_QWORD **)(v13 + 24); ; i = v17 )
  {
    if ( i )
    {
      v17 = (_QWORD *)i[4];
      v7 = 1;
    }
    else
    {
      v7 = 0;
    }
    if ( !v7 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        sub_13937(v18, 5, 0, 0LL, i[6], (__int64)"if-feature");
        return 1LL;
      }
      if ( v14 == 255 )
      {
        sub_12222(
          (__int64)v18,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "if-feature");
        return 1LL;
      }
      ++v14;
    }
    else
    {
      lyxml_free(v18, i);
    }
  }
  if ( v14 )
  {
    *(_QWORD *)(v12 + 24) = calloc(v14, 8uLL);
    if ( !*(_QWORD *)(v12 + 24) )
    {
      sub_12222((__int64)v18, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_iffeature", v8);
      return 1LL;
    }
    for ( j = *(_QWORD *)(v13 + 24); ; j = (__int64)v17 )
    {
      if ( j )
      {
        v17 = *(_QWORD **)(j + 32);
        v10 = 1;
      }
      else
      {
        v10 = 0;
      }
      if ( !v10 )
        break;
      v9 = sub_40F96(v12, 9, 0, 0, *(__int64 **)(a1 + 48), j, (__int64 *)(v12 + 24), *(_BYTE *)(v12 + 8), v11);
      ++*(_BYTE *)(v12 + 8);
      if ( v9 )
        return 1LL;
    }
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000041AE0) ----------------------------------------------------
signed __int64 __fastcall sub_41AE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  _BOOL4 v7; // eax
  int v8; // eax
  char v9; // al
  __int64 v11; // [rsp+0h] [rbp-60h]
  __int64 v12; // [rsp+8h] [rbp-58h]
  int v13; // [rsp+28h] [rbp-38h]
  int v14; // [rsp+2Ch] [rbp-34h]
  int v15; // [rsp+30h] [rbp-30h]
  _QWORD *i; // [rsp+38h] [rbp-28h]
  _QWORD *j; // [rsp+38h] [rbp-28h]
  _QWORD *v18; // [rsp+40h] [rbp-20h]
  void *v19; // [rsp+48h] [rbp-18h]
  __int64 v20; // [rsp+50h] [rbp-10h]
  const char *v21; // [rsp+50h] [rbp-10h]
  __int64 v22; // [rsp+50h] [rbp-10h]
  void *v23; // [rsp+58h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v19 = *(void **)a1;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v20 = lyxml_get_attr(a2, "name", 0LL);
  if ( !v20 )
  {
    sub_13937(v19, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(a2 + 48), v11);
    return 1LL;
  }
  *(_QWORD *)v12 = v20;
  if ( (unsigned int)sub_51597((__int64 *)a1, 0LL, v12, 9u, a2, 17, v11) || (unsigned int)sub_3B53E(*(_QWORD *)v12, a1) )
    return 1LL;
  for ( i = *(_QWORD **)(a2 + 24); i; i = (_QWORD *)i[4] )
  {
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "base") )
      {
        if ( v14 && ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
        {
          sub_13937(v19, 14, 0, 0LL, (__int64)"base", (__int64)"identity", v11);
          return 1LL;
        }
        if ( v14 == 255 )
        {
          sub_12222(
            (__int64)v19,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"bases",
            "identity");
          return 1LL;
        }
        if ( (unsigned int)sub_411CA((__int64 *)a1, v12, 9u, i, 2, (unsigned __int8)v14, v11) )
          return 1LL;
        ++v14;
      }
      else
      {
        if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)i[6], "if-feature") )
        {
          sub_13937(v19, 5, 0, 0LL, i[6], (__int64)"identity", v11);
          return 1LL;
        }
        if ( v13 == 255 )
        {
          sub_12222(
            (__int64)v19,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "identity");
          return 1LL;
        }
        ++v13;
      }
    }
    else
    {
      if ( v15 == 255 )
      {
        sub_12222(
          (__int64)v19,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "identity");
        return 1LL;
      }
      ++v15;
    }
  }
  if ( v14 )
  {
    *(_BYTE *)(v12 + 31) = 0;
    *(_QWORD *)(v12 + 56) = calloc(v14, 8uLL);
    if ( !*(_QWORD *)(v12 + 56) )
    {
      sub_12222((__int64)v19, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_identity", v4, v11);
      return 1LL;
    }
  }
  if ( v13 )
  {
    *(_QWORD *)(v12 + 40) = calloc(v13, 0x20uLL);
    if ( !*(_QWORD *)(v12 + 40) )
    {
      sub_12222((__int64)v19, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_identity", v5, v11);
      return 1LL;
    }
  }
  if ( v15 )
  {
    v23 = realloc(*(void **)(v12 + 32), 8LL * (*(unsigned __int8 *)(v12 + 26) + v15));
    if ( !v23 )
    {
      sub_12222((__int64)v19, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_identity", v6, v11);
      return 1LL;
    }
    *(_QWORD *)(v12 + 32) = v23;
    memset((void *)(*(_QWORD *)(v12 + 32) + 8LL * *(unsigned __int8 *)(v12 + 26)), 0, 8LL * v15);
  }
  for ( j = *(_QWORD **)(a2 + 24); ; j = v18 )
  {
    if ( j )
    {
      v18 = (_QWORD *)j[4];
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( !v9 )
      break;
    if ( !strcmp(*(const char **)(j[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)j[6], "base") )
      {
        v21 = (const char *)lyxml_get_attr(j, "name", 0LL);
        if ( !v21 )
        {
          sub_13937(v19, 13, 0, 0LL, (__int64)"name", j[6], v11);
          return 1LL;
        }
        v22 = sub_9BED((__int64 *)a1, v21);
        if ( !v22 )
          return 1LL;
        if ( (unsigned int)sub_2AB62((__int64 *)a1, v11, (__int64 *)v12, 0x100u, v22) == -1 )
        {
          lydict_remove(v19, v22);
          return 1LL;
        }
        lydict_remove(v19, v22);
      }
      else if ( !strcmp((const char *)j[6], "if-feature") )
      {
        v8 = sub_41746(v12, 0, (__int64)j, *(_QWORD *)(v12 + 40) + 32LL * *(unsigned __int8 *)(v12 + 27), v11);
        ++*(_BYTE *)(v12 + 27);
        if ( v8 )
          return 1LL;
      }
    }
    else
    {
      v7 = sub_40F96(v12, 9, 0, 0, (__int64 *)a1, (__int64)j, (__int64 *)(v12 + 32), *(_BYTE *)(v12 + 26), v11);
      ++*(_BYTE *)(v12 + 26);
      if ( v7 )
        return 1LL;
    }
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000421DA) ----------------------------------------------------
signed __int64 __fastcall sub_421DA(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // r9
  char v6; // al
  __int64 v7; // [rsp+0h] [rbp-40h]
  __int64 v8; // [rsp+8h] [rbp-38h]
  _QWORD *i; // [rsp+20h] [rbp-20h]
  _QWORD *v10; // [rsp+28h] [rbp-18h]
  void *v11; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v11 = (void *)*a1;
  for ( i = *(_QWORD **)(a3 + 24); ; i = v10 )
  {
    if ( i )
    {
      v10 = (_QWORD *)i[4];
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "description") )
        {
          if ( a2[1] )
          {
            sub_13937(v11, 14, 0, 0LL, i[6], *(_QWORD *)(v8 + 48), v7);
            return 1LL;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)a2, 7u, i, 6, 0LL, v7) )
            return 1LL;
          a2[1] = sub_410A7(v11, (__int64)i, "text");
          if ( !a2[1] )
            return 1LL;
        }
        else if ( !strcmp((const char *)i[6], "reference") )
        {
          if ( a2[2] )
          {
            sub_13937(v11, 14, 0, 0LL, i[6], *(_QWORD *)(v8 + 48), v7);
            return 1LL;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)a2, 7u, i, 15, 0LL, v7) )
            return 1LL;
          a2[2] = sub_410A7(v11, (__int64)i, "text");
          if ( !a2[2] )
            return 1LL;
        }
        else if ( !strcmp((const char *)i[6], "error-app-tag") )
        {
          if ( a2[3] )
          {
            sub_13937(v11, 14, 0, 0LL, i[6], *(_QWORD *)(v8 + 48), v7);
            return 1LL;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)a2, 7u, i, 7, 0LL, v7) )
            return 1LL;
          v12 = lyxml_get_attr(i, "value", 0LL);
          if ( !v12 )
          {
            sub_13937(v11, 13, 0, 0LL, (__int64)"value", i[6], v7);
            return 1LL;
          }
          a2[3] = lydict_insert(v11, v12, 0LL);
        }
        else
        {
          if ( strcmp((const char *)i[6], "error-message") )
          {
            sub_13937(v11, 5, 0, 0LL, i[6], v5, v7);
            return 1LL;
          }
          if ( a2[4] )
          {
            sub_13937(v11, 14, 0, 0LL, i[6], *(_QWORD *)(v8 + 48), v7);
            return 1LL;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)a2, 7u, i, 8, 0LL, v7) )
            return 1LL;
          a2[4] = sub_410A7(v11, (__int64)i, "value");
          if ( !a2[4] )
            return 1LL;
        }
      }
      else if ( (unsigned int)sub_411CA(a1, (__int64)a2, 7u, i, 0, 0LL, v7) )
      {
        return 1LL;
      }
    }
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000426E1) ----------------------------------------------------
signed __int64 __fastcall sub_426E1(__int64 a1, char *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  char v9; // al
  _BOOL4 v10; // eax
  char v11; // al
  char v12; // al
  __int64 v13; // r9
  __int64 v14; // r9
  size_t v15; // rax
  _QWORD *v16; // rbx
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // r9
  __int16 v20; // dx
  char v21; // al
  __int64 v22; // r9
  int v23; // eax
  __int64 v24; // r9
  _QWORD *v25; // rbx
  __int16 v26; // dx
  __int64 v27; // r9
  char v28; // al
  __int64 v29; // r9
  __int64 v30; // r9
  size_t v31; // rax
  _QWORD *v32; // rbx
  __int64 v33; // r9
  const unsigned __int16 *v34; // rbx
  __int64 v35; // r9
  __int16 v36; // dx
  char v37; // al
  __int64 v38; // r9
  int v39; // eax
  __int64 v40; // r9
  int v41; // ST60_4
  char v42; // al
  __int64 v43; // r9
  __int64 v44; // r9
  __int64 v45; // r9
  _QWORD *v46; // rbx
  __int16 v47; // dx
  __int64 v48; // r9
  __int64 v49; // r9
  _QWORD *v50; // rbx
  __int16 v51; // dx
  __int64 v52; // r9
  char v53; // al
  __int64 v54; // r9
  __int64 v55; // r9
  char v56; // al
  size_t v57; // ST110_8
  __int64 v58; // r9
  __int16 v59; // dx
  __int64 v60; // r9
  char v61; // al
  __int64 v62; // r9
  __int16 v63; // dx
  __int16 v64; // dx
  __int64 v65; // [rsp+0h] [rbp-190h]
  unsigned int v66; // [rsp+Ch] [rbp-184h]
  __int64 v67; // [rsp+10h] [rbp-180h]
  __int64 v68; // [rsp+18h] [rbp-178h]
  char v69; // [rsp+3Fh] [rbp-151h]
  int v70; // [rsp+40h] [rbp-150h]
  signed int v71; // [rsp+40h] [rbp-150h]
  signed int v72; // [rsp+44h] [rbp-14Ch]
  int v73; // [rsp+48h] [rbp-148h]
  int v74; // [rsp+48h] [rbp-148h]
  int v75; // [rsp+4Ch] [rbp-144h]
  unsigned int nmemb; // [rsp+50h] [rbp-140h]
  unsigned int nmemba; // [rsp+50h] [rbp-140h]
  unsigned int nmembb; // [rsp+50h] [rbp-140h]
  unsigned int nmembc; // [rsp+50h] [rbp-140h]
  unsigned int nmembd; // [rsp+50h] [rbp-140h]
  unsigned int nmembe; // [rsp+50h] [rbp-140h]
  unsigned int nmembf; // [rsp+50h] [rbp-140h]
  unsigned int nmemb_4; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4a; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4b; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4c; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4d; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4e; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4f; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4g; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4h; // [rsp+54h] [rbp-13Ch]
  unsigned int nmemb_4i; // [rsp+54h] [rbp-13Ch]
  unsigned int v93; // [rsp+58h] [rbp-138h]
  signed int v94; // [rsp+5Ch] [rbp-134h]
  char *nptr; // [rsp+60h] [rbp-130h]
  char *nptra; // [rsp+60h] [rbp-130h]
  char *nptrb; // [rsp+60h] [rbp-130h]
  char *nptrc; // [rsp+60h] [rbp-130h]
  char *nptrd; // [rsp+60h] [rbp-130h]
  char *nptre; // [rsp+60h] [rbp-130h]
  char *nptrf; // [rsp+60h] [rbp-130h]
  char *nptrg; // [rsp+60h] [rbp-130h]
  char *nptrh; // [rsp+60h] [rbp-130h]
  char *nptri; // [rsp+60h] [rbp-130h]
  char *nptrj; // [rsp+60h] [rbp-130h]
  char *nptrk; // [rsp+60h] [rbp-130h]
  char *nptrl; // [rsp+60h] [rbp-130h]
  char *nptrm; // [rsp+60h] [rbp-130h]
  char *nptrn; // [rsp+60h] [rbp-130h]
  char *s2; // [rsp+68h] [rbp-128h]
  char *s2a; // [rsp+68h] [rbp-128h]
  char *s2b; // [rsp+68h] [rbp-128h]
  char *s2c; // [rsp+68h] [rbp-128h]
  const char *v114; // [rsp+70h] [rbp-120h]
  __int64 i; // [rsp+78h] [rbp-118h]
  _QWORD *v116; // [rsp+80h] [rbp-110h]
  _QWORD *v117; // [rsp+80h] [rbp-110h]
  _QWORD *v118; // [rsp+80h] [rbp-110h]
  _QWORD *v119; // [rsp+88h] [rbp-108h]
  _QWORD *j; // [rsp+90h] [rbp-100h]
  __int64 k; // [rsp+90h] [rbp-100h]
  _QWORD *v122; // [rsp+90h] [rbp-100h]
  _QWORD *v123; // [rsp+90h] [rbp-100h]
  __int64 l; // [rsp+90h] [rbp-100h]
  _QWORD *v125; // [rsp+90h] [rbp-100h]
  _QWORD *v126; // [rsp+90h] [rbp-100h]
  _QWORD *v127; // [rsp+90h] [rbp-100h]
  __int64 n; // [rsp+90h] [rbp-100h]
  _QWORD *v129; // [rsp+90h] [rbp-100h]
  _QWORD *v130; // [rsp+90h] [rbp-100h]
  __int64 v131; // [rsp+90h] [rbp-100h]
  _QWORD *v132; // [rsp+90h] [rbp-100h]
  _QWORD *ii; // [rsp+90h] [rbp-100h]
  __int64 v134; // [rsp+90h] [rbp-100h]
  _QWORD *jj; // [rsp+90h] [rbp-100h]
  _QWORD *v136; // [rsp+90h] [rbp-100h]
  __int64 ll; // [rsp+90h] [rbp-100h]
  _QWORD *kk; // [rsp+98h] [rbp-F8h]
  void **v139; // [rsp+A0h] [rbp-F0h]
  signed __int64 v140; // [rsp+A8h] [rbp-E8h]
  signed __int64 v141; // [rsp+B0h] [rbp-E0h]
  signed __int64 v142; // [rsp+B8h] [rbp-D8h]
  signed __int64 v143; // [rsp+B8h] [rbp-D8h]
  signed __int64 m; // [rsp+B8h] [rbp-D8h]
  __int64 v145; // [rsp+C0h] [rbp-D0h]
  signed __int64 v146; // [rsp+C0h] [rbp-D0h]
  __int64 v147; // [rsp+C8h] [rbp-C8h]
  signed __int64 v148; // [rsp+D0h] [rbp-C0h]
  __int64 v149; // [rsp+D8h] [rbp-B8h]
  _DWORD *v150; // [rsp+E0h] [rbp-B0h]
  __int64 v151; // [rsp+E8h] [rbp-A8h]
  _BYTE *v152; // [rsp+F8h] [rbp-98h]
  char dest; // [rsp+100h] [rbp-90h]
  char s; // [rsp+130h] [rbp-60h]
  __int64 v155; // [rsp+148h] [rbp-48h]
  unsigned __int64 v156; // [rsp+178h] [rbp-18h]

  v68 = a3;
  v67 = a4;
  v66 = a5;
  v65 = a6;
  v156 = __readfsqword(0x28u);
  v114 = 0LL;
  v140 = 0LL;
  v141 = 0LL;
  v150 = *(_DWORD **)a1;
  v75 = 0;
  v93 = -1;
  v94 = 0;
  memset(&s, 0, 0x48uLL);
  nptr = (char *)lyxml_get_attr(v68, "name", 0LL);
  if ( !nptr )
  {
    sub_13937(v150, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(v68 + 48), v65);
    goto LABEL_535;
  }
  nptra = (char *)sub_9BED((__int64 *)a1, nptr);
  if ( !nptra )
    goto LABEL_535;
  nmemb = sub_16564(nptra);
  if ( !nmemb )
  {
    sub_13937(v150, 55, 0, 0LL, (unsigned int)*nptra, (__int64)nptra, v65);
    lydict_remove(v150, nptra);
    goto LABEL_535;
  }
  s2 = nptra;
  if ( nptra[nmemb] )
  {
    v114 = (const char *)lydict_insert(v150, nptra, nmemb);
    s2a = &nptra[nmemb];
    if ( *s2a != 58 || !(unsigned int)sub_16564(s2a + 1) )
    {
      sub_13937(v150, 55, 0, 0LL, (unsigned int)*s2a, (__int64)s2a, v65);
      lydict_remove(v150, v114);
      lydict_remove(v150, nptra);
      goto LABEL_535;
    }
    s2 = s2a + 1;
  }
  v70 = sub_1E65A(s2, v114, a1, (__int64)a2, (signed __int64 *)(v67 + 16));
  if ( v70 == -1 )
  {
    sub_13937(v150, 28, 0, 0LL, (__int64)v114, v6, v65);
    lydict_remove(v150, v114);
    lydict_remove(v150, nptra);
    goto LABEL_535;
  }
  if ( v70 == 1 )
  {
    sub_13937(v150, 46, 0, 0LL, (__int64)"type", (__int64)s2, v65);
    lydict_remove(v150, v114);
    lydict_remove(v150, nptra);
    v93 = 1;
    goto LABEL_535;
  }
  lydict_remove(v150, v114);
  lydict_remove(v150, nptra);
  if ( *(_BYTE *)(v67 + 4) < 0 )
  {
    for ( i = (__int64)a2; i && *(_DWORD *)(i + 56) != 2048; i = lys_parent(i) )
      ;
    if ( !i )
    {
      sub_12222(
        (__int64)v150,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yin.c",
        599LL,
        v65);
      goto LABEL_535;
    }
    if ( !*(_WORD *)(i + 28) )
      __assert_fail(
        "((struct lys_node_grp *)siter)->unres_count",
        "/home/mantovan/Repositories/libyang/src/parser_yin.c",
        0x254u,
        "fill_yin_type");
    --*(_WORD *)(i + 28);
    *(_BYTE *)(v67 + 4) &= 0x7Fu;
  }
  *(_DWORD *)v67 = *(_DWORD *)(*(_QWORD *)(v67 + 16) + 56LL);
  if ( (unsigned int)sub_3C749(
                       *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL),
                       *(void ***)(*(_QWORD *)(v67 + 24) + 48LL),
                       **(_QWORD **)(v67 + 24),
                       *(_WORD *)(*(_QWORD *)(v67 + 16) + 24LL),
                       *(_QWORD *)(*(_QWORD *)(v67 + 16) + 48LL),
                       **(_QWORD **)(v67 + 16),
                       a2) )
    return 0xFFFFFFFFLL;
  for ( j = *(_QWORD **)(v68 + 24); ; j = v116 )
  {
    if ( j )
    {
      v116 = (_QWORD *)j[4];
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( !v9 )
      break;
    if ( j[7] )
    {
      if ( strcmp(*(const char **)(j[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( v75 == 255 )
        {
          sub_12222(
            (__int64)v150,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            "type");
          goto LABEL_535;
        }
        sub_30B77((__int64)v150, j, 2);
        sub_3116F((__int64)v150, (__int64)&s, j);
        ++v75;
      }
    }
    else
    {
      lyxml_free(v150, j);
    }
  }
  if ( v75 )
  {
    *(_QWORD *)(v67 + 8) = calloc(v75, 8uLL);
    if ( !*(_QWORD *)(v67 + 8) )
    {
      sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v7, v65);
LABEL_535:
      lyxml_free_withsiblings(v150, v155);
      return v93;
    }
    for ( k = v155; ; k = (__int64)v116 )
    {
      if ( k )
      {
        v116 = *(_QWORD **)(k + 32);
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
      if ( !v11 )
        break;
      v10 = sub_40F96(v67, 3, 0, 0, (__int64 *)a1, k, (__int64 *)(v67 + 8), *(_BYTE *)(v67 + 5), v65);
      ++*(_BYTE *)(v67 + 5);
      if ( v10 )
        goto LABEL_535;
    }
  }
  switch ( *(_DWORD *)v67 )
  {
    case 1:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      if ( *(_DWORD *)v67 == 1 )
      {
        v139 = (void **)(v67 + 32);
        s2b = "length";
      }
      else
      {
        v139 = (void **)(v67 + 32);
        s2b = "range";
      }
      v131 = *(_QWORD *)(v68 + 24);
      while ( 2 )
      {
        if ( !v131 )
          goto LABEL_524;
        if ( !strcmp(*(const char **)(v131 + 48), s2b) )
        {
          if ( *v139 )
          {
            sub_13937(v150, 14, 0, 0LL, *(_QWORD *)(v131 + 48), *(_QWORD *)(v68 + 48), v65);
          }
          else
          {
            nptrj = (char *)lyxml_get_attr(v131, "value", 0LL);
            if ( nptrj )
            {
              if ( (unsigned int)sub_36896(v150, nptrj, (int *)v67) )
              {
                sub_13937(v150, 10, 0, 0LL, (__int64)nptrj, (__int64)s2b, v65);
              }
              else
              {
                *v139 = calloc(1uLL, 0x38uLL);
                if ( *v139 )
                {
                  v46 = *v139;
                  *v46 = lydict_insert(v150, nptrj, 0LL);
                  if ( !(unsigned int)sub_421DA((__int64 *)a1, *v139, v131, v65) )
                  {
                    for ( nmemb_4f = 0; ; ++nmemb_4f )
                    {
                      if ( nmemb_4f >= *((unsigned __int8 *)*v139 + 48) )
                        goto LABEL_358;
                      if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4f + *((_QWORD *)*v139 + 5)) + 24LL) & 8 )
                        break;
                    }
                    v47 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
                    HIBYTE(v47) |= 0x20u;
                    *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v47;
LABEL_358:
                    v131 = *(_QWORD *)(v131 + 32);
                    continue;
                  }
                }
                else
                {
                  sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v45, v65);
                }
              }
            }
            else
            {
              sub_13937(v150, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(v131 + 48), v65);
            }
          }
        }
        else
        {
          sub_13937(v150, 5, 0, 0LL, *(_QWORD *)(v131 + 48), v44, v65);
        }
        goto LABEL_535;
      }
    case 2:
      v122 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( v122 )
        {
          v116 = (_QWORD *)v122[4];
          v12 = 1;
        }
        else
        {
          v12 = 0;
        }
        if ( v12 )
        {
          if ( !strcmp((const char *)v122[6], "bit") )
          {
            if ( *(_DWORD *)(v67 + 40) != -1 )
            {
              ++*(_DWORD *)(v67 + 40);
              v122 = v116;
              continue;
            }
            sub_12222(
              (__int64)v150,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              0xFFFFFFFFLL,
              (__int64)"bits",
              "type");
            *(_DWORD *)(v67 + 40) = 0;
          }
          else
          {
            sub_13937(v150, 5, 0, 0LL, v122[6], v7, v65);
            *(_DWORD *)(v67 + 40) = 0;
          }
          goto LABEL_535;
        }
        break;
      }
      v142 = *(_QWORD *)(v67 + 16) + 56LL;
      if ( *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        while ( !*(_DWORD *)(v142 + 40) )
          v142 = *(_QWORD *)(v142 + 16) + 56LL;
        if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 && *(_DWORD *)(v67 + 40) )
        {
          sub_13937(v150, 5, 0, 0LL, (__int64)"bit", v7, v65);
          *(_DWORD *)(v67 + 40) = 0;
          goto LABEL_535;
        }
      }
      else if ( !*(_DWORD *)(v67 + 40) )
      {
        sub_13937(v150, 12, 0, 0LL, (__int64)"bit", (__int64)"type", v65);
        goto LABEL_535;
      }
      *(_QWORD *)(v67 + 32) = calloc(*(unsigned int *)(v67 + 40), 0x30uLL);
      if ( !*(_QWORD *)(v67 + 32) )
      {
        sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v13, v65);
        goto LABEL_535;
      }
      v148 = 0LL;
      nmemba = 0;
      v117 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( !v117 )
          goto LABEL_524;
        v73 = 0;
        nptrb = (char *)lyxml_get_attr(v117, "name", 0LL);
        if ( !nptrb )
        {
          sub_13937(v150, 13, 0, 0LL, (__int64)"name", v117[6], v65);
          goto LABEL_535;
        }
        if ( (unsigned int)sub_3B812(v150, nptrb, 0, 0LL, 0LL, v14) )
          goto LABEL_535;
        v15 = strlen(nptrb);
        v16 = (_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba);
        *v16 = lydict_insert(v150, nptrb, v15);
        if ( (unsigned int)sub_51597(
                             (__int64 *)a1,
                             0LL,
                             *(_QWORD *)(v67 + 32) + 48LL * nmemba,
                             4u,
                             (__int64)v117,
                             0,
                             v65) )
        {
          *(_DWORD *)(v67 + 40) = nmemba + 1;
          goto LABEL_535;
        }
        if ( *(_QWORD *)(v142 + 16) )
        {
          v140 = *(_QWORD *)(v142 + 32);
          for ( nmemb_4 = 0; nmemb_4 < *(_DWORD *)(v142 + 40) && nptrb != *(char **)(48LL * nmemb_4 + v140); ++nmemb_4 )
            ;
          if ( nmemb_4 == *(_DWORD *)(v142 + 40) )
          {
            sub_13937(v150, 25, 0, 0LL, (__int64)nptrb, v17, v65);
            *(_DWORD *)(v67 + 40) = nmemba + 1;
            goto LABEL_535;
          }
        }
        else
        {
          for ( nmemb_4 = 0; nmemb_4 < nmemba; ++nmemb_4 )
          {
            if ( !strcmp(
                    *(const char **)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4),
                    *(const char **)(*(_QWORD *)(v67 + 32) + 48LL * nmemba)) )
            {
              sub_13937(v150, 27, 0, 0LL, *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba), v18, v65);
              *(_DWORD *)(v67 + 40) = nmemba + 1;
              goto LABEL_535;
            }
          }
        }
        v149 = -1LL;
        v123 = (_QWORD *)v117[3];
LABEL_124:
        if ( v123 )
        {
          v119 = (_QWORD *)v123[4];
          v21 = 1;
        }
        else
        {
          v21 = 0;
        }
        if ( !v21 )
        {
          if ( *(_QWORD *)(v142 + 16) )
          {
            if ( v149 == -1 )
            {
              *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28) = *(_DWORD *)(48LL * nmemb_4 + v140 + 28);
              *(_WORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 24) |= 1u;
            }
            else if ( v149 != *(_DWORD *)(48LL * nmemb_4 + v140 + 28) )
            {
              sub_13937(
                v150,
                24,
                0,
                0LL,
                *(unsigned int *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28),
                *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba),
                *(unsigned int *)(48LL * nmemb_4 + v140 + 28));
              *(_DWORD *)(v67 + 40) = nmemba + 1;
              goto LABEL_535;
            }
          }
          else if ( v149 == -1 )
          {
            if ( v148 > 0xFFFFFFFFLL )
            {
              sub_13937(v150, 10, 0, 0LL, (__int64)"4294967295", (__int64)"bit/position", v65);
              *(_DWORD *)(v67 + 40) = nmemba + 1;
              goto LABEL_535;
            }
            *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28) = v148;
            *(_WORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 24) |= 1u;
            ++v148;
          }
          if ( v73 )
          {
            v140 = *(_QWORD *)(v67 + 32) + 48LL * nmemba;
            *(_QWORD *)(v140 + 40) = calloc(v73, 0x20uLL);
            if ( !*(_QWORD *)(v140 + 40) )
            {
              sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v22, v65);
              *(_DWORD *)(v67 + 40) = nmemba + 1;
              goto LABEL_535;
            }
            for ( l = v117[3]; l; l = *(_QWORD *)(l + 32) )
            {
              if ( !strcmp(*(const char **)(l + 48), "if-feature") )
              {
                v23 = sub_41746(
                        *(_QWORD *)(v67 + 24),
                        0,
                        l,
                        *(_QWORD *)(v140 + 40) + 32LL * *(unsigned __int8 *)(v140 + 27),
                        v65);
                ++*(_BYTE *)(v140 + 27);
                if ( v23 )
                {
                  *(_DWORD *)(v67 + 40) = nmemba + 1;
                  goto LABEL_535;
                }
              }
            }
          }
          for ( nmemb_4b = nmemba;
                nmemb_4b
             && *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * (nmemb_4b - 1) + 28) > *(_DWORD *)(*(_QWORD *)(v67 + 32)
                                                                                            + 48LL * nmemb_4b
                                                                                            + 28);
                --nmemb_4b )
          {
            memcpy(&dest, (const void *)(48LL * nmemb_4b + *(_QWORD *)(v67 + 32)), 0x30uLL);
            memcpy(
              (void *)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4b),
              (const void *)(*(_QWORD *)(v67 + 32) + 48LL * (nmemb_4b - 1)),
              0x30uLL);
            memcpy((void *)(*(_QWORD *)(v67 + 32) + 48LL * (nmemb_4b - 1)), &dest, 0x30uLL);
          }
          ++nmemba;
          v117 = (_QWORD *)v117[4];
          continue;
        }
        break;
      }
      if ( !v123[7] )
        goto LABEL_123;
      if ( !strcmp(*(const char **)(v123[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)v123[6], "position") )
        {
          if ( v149 != -1 )
          {
            sub_13937(v150, 14, 0, 0LL, v123[6], v117[6], v65);
            *(_DWORD *)(v67 + 40) = nmemba + 1;
            goto LABEL_535;
          }
          nptrc = (char *)lyxml_get_attr(v123, "value", 0LL);
          if ( !nptrc )
          {
            sub_13937(v150, 13, 0, 0LL, (__int64)"value", v123[6], v65);
            goto LABEL_535;
          }
          v149 = strtoll(nptrc, 0LL, 10);
          if ( v149 < 0 || v149 > 0xFFFFFFFFLL )
          {
            sub_13937(v150, 10, 0, 0LL, (__int64)nptrc, (__int64)"bit/position", v65);
            *(_DWORD *)(v67 + 40) = nmemba + 1;
            goto LABEL_535;
          }
          *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28) = v149;
          if ( !*(_QWORD *)(v142 + 16) )
          {
            if ( v148 > *(unsigned int *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28) )
            {
              for ( nmemb_4a = 0; nmemb_4a < nmemba; ++nmemb_4a )
              {
                if ( *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4a + 28) == *(_DWORD *)(*(_QWORD *)(v67 + 32)
                                                                                            + 48LL * nmemba
                                                                                            + 28) )
                {
                  sub_13937(
                    v150,
                    26,
                    0,
                    0LL,
                    *(unsigned int *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28),
                    *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba),
                    *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4a));
                  *(_DWORD *)(v67 + 40) = nmemba + 1;
                  goto LABEL_535;
                }
              }
            }
            else
            {
              v148 = *(unsigned int *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 28) + 1LL;
            }
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, *(_QWORD *)(v67 + 32) + 48LL * nmemba, 4u, v123, 30, 0LL, v65) )
            goto LABEL_535;
          for ( nmemb_4 = 0; ; ++nmemb_4 )
          {
            if ( nmemb_4 >= *(unsigned __int8 *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 26) )
              goto LABEL_123;
            if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4 + *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemba + 32)) + 24LL) & 8 )
              break;
          }
          v20 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
          HIBYTE(v20) |= 0x20u;
          *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v20;
        }
        else
        {
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)v123[6], "if-feature") )
          {
            sub_13937(v150, 5, 0, 0LL, v123[6], v19, v65);
            goto LABEL_535;
          }
          if ( v73 == 255 )
          {
            sub_12222(
              (__int64)v150,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"if-features",
              "bit");
            goto LABEL_535;
          }
          ++v73;
        }
      }
      else if ( (unsigned int)sub_411CA((__int64 *)a1, *(_QWORD *)(v67 + 32) + 48LL * nmemba, 4u, v123, 0, 0LL, v65) )
      {
        goto LABEL_535;
      }
LABEL_123:
      v123 = v119;
      goto LABEL_124;
    case 3:
    case 5:
      if ( !*(_QWORD *)(v68 + 24) )
        goto LABEL_524;
      sub_13937(v150, 5, 0, 0LL, *(_QWORD *)(*(_QWORD *)(v68 + 24) + 48LL), v7, v65);
      goto LABEL_535;
    case 4:
      v125 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( v125 )
        {
          if ( !strcmp((const char *)v125[6], "range") )
          {
            if ( *(_QWORD *)(v67 + 32) )
            {
              sub_13937(v150, 14, 0, 0LL, v125[6], *(_QWORD *)(v68 + 48), v65);
              goto LABEL_535;
            }
            nptra = (char *)lyxml_get_attr(v125, "value", 0LL);
            if ( !nptra )
            {
              sub_13937(v150, 13, 0, 0LL, (__int64)"value", v125[6], v65);
              goto LABEL_535;
            }
            *(_QWORD *)(v67 + 32) = calloc(1uLL, 0x38uLL);
            if ( !*(_QWORD *)(v67 + 32) )
            {
              sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v24, v65);
              goto LABEL_535;
            }
            v25 = *(_QWORD **)(v67 + 32);
            *v25 = lydict_insert(v150, nptra, 0LL);
            if ( (unsigned int)sub_421DA((__int64 *)a1, *(_QWORD **)(v67 + 32), (__int64)v125, v65) )
              goto LABEL_535;
            for ( nmemb_4c = 0; ; ++nmemb_4c )
            {
              if ( nmemb_4c >= *(unsigned __int8 *)(*(_QWORD *)(v67 + 32) + 48LL) )
                goto LABEL_182;
              if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4c + *(_QWORD *)(*(_QWORD *)(v67 + 32) + 40LL)) + 24LL) & 8 )
                break;
            }
            v26 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
            HIBYTE(v26) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v26;
          }
          else
          {
            if ( strcmp((const char *)v125[6], "fraction-digits") )
            {
              sub_13937(v150, 5, 0, 0LL, v125[6], v27, v65);
              goto LABEL_535;
            }
            if ( *(_BYTE *)(v67 + 40) )
            {
              sub_13937(v150, 14, 0, 0LL, v125[6], *(_QWORD *)(v68 + 48), v65);
              goto LABEL_535;
            }
            nptra = (char *)lyxml_get_attr(v125, "value", 0LL);
            if ( !nptra )
            {
              sub_13937(v150, 13, 0, 0LL, (__int64)"value", v125[6], v65);
              goto LABEL_535;
            }
            v145 = strtol(nptra, 0LL, 10);
            if ( v145 <= 0 || v145 > 18 )
            {
              sub_13937(v150, 10, 0, 0LL, (__int64)nptra, v125[6], v65);
              goto LABEL_535;
            }
            *(_BYTE *)(v67 + 40) = v145;
            *(_QWORD *)(v67 + 48) = 10LL;
            for ( nmembb = 1; v145 > nmembb; ++nmembb )
              *(_QWORD *)(v67 + 48) *= 10LL;
            if ( (unsigned int)sub_411CA((__int64 *)a1, v67, 3u, v125, 27, 0LL, v65) )
              goto LABEL_535;
          }
LABEL_182:
          v125 = (_QWORD *)v125[4];
          continue;
        }
        break;
      }
      if ( !*(_BYTE *)(v67 + 40) && !*(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        sub_13937(v150, 12, 0, 0LL, (__int64)"fraction-digits", (__int64)"type", v65);
        goto LABEL_535;
      }
      if ( *(_BYTE *)(v67 + 40) && *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        sub_13937(v150, 5, 0, 0LL, (__int64)"fraction-digits", v7, v65);
        goto LABEL_535;
      }
      if ( *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        *(_BYTE *)(v67 + 40) = *(_BYTE *)(*(_QWORD *)(v67 + 16) + 96LL);
        *(_QWORD *)(v67 + 48) = *(_QWORD *)(*(_QWORD *)(v67 + 16) + 104LL);
      }
      if ( *(_QWORD *)(v67 + 32) && (unsigned int)sub_36896(v150, **(char ***)(v67 + 32), (int *)v67) )
      {
        sub_13937(v150, 10, 0, 0LL, (__int64)nptra, (__int64)"range", v65);
        goto LABEL_535;
      }
LABEL_524:
      for ( nmemb_4i = 0; nmemb_4i < *(unsigned __int8 *)(v67 + 5); ++nmemb_4i )
      {
        if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4i + *(_QWORD *)(v67 + 8)) + 24LL) & 8 )
        {
          v63 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
          HIBYTE(v63) |= 0x20u;
          *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v63;
          break;
        }
      }
      for ( m = *(_QWORD *)(v67 + 16) + 56LL; *(_QWORD *)(m + 16); m = *(_QWORD *)(m + 16) + 56LL )
      {
        if ( *(_WORD *)(*(_QWORD *)(m + 24) + 24LL) & 0x2000 )
        {
          v64 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
          HIBYTE(v64) |= 0x20u;
          *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v64;
        }
      }
      return 0LL;
    case 6:
      v126 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( v126 )
        {
          v116 = (_QWORD *)v126[4];
          v28 = 1;
        }
        else
        {
          v28 = 0;
        }
        if ( v28 )
        {
          if ( !strcmp((const char *)v126[6], "enum") )
          {
            if ( *(_DWORD *)(v67 + 40) != -1 )
            {
              ++*(_DWORD *)(v67 + 40);
              v126 = v116;
              continue;
            }
            sub_12222(
              (__int64)v150,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              0xFFFFFFFFLL,
              (__int64)"enums",
              "type");
            *(_DWORD *)(v67 + 40) = 0;
          }
          else
          {
            sub_13937(v150, 5, 0, 0LL, v126[6], v7, v65);
            *(_DWORD *)(v67 + 40) = 0;
          }
          goto LABEL_535;
        }
        break;
      }
      v143 = *(_QWORD *)(v67 + 16) + 56LL;
      if ( *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        while ( !*(_DWORD *)(v143 + 40) )
          v143 = *(_QWORD *)(v143 + 16) + 56LL;
        if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 && *(_DWORD *)(v67 + 40) )
        {
          sub_13937(v150, 5, 0, 0LL, (__int64)"enum", v7, v65);
          *(_DWORD *)(v67 + 40) = 0;
          goto LABEL_535;
        }
      }
      else if ( !*(_DWORD *)(v67 + 40) )
      {
        sub_13937(v150, 12, 0, 0LL, (__int64)"enum", (__int64)"type", v65);
        goto LABEL_535;
      }
      *(_QWORD *)(v67 + 32) = calloc(*(unsigned int *)(v67 + 40), 0x30uLL);
      if ( !*(_QWORD *)(v67 + 32) )
      {
        sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v29, v65);
        goto LABEL_535;
      }
      v146 = 0LL;
      nmembc = 0;
      v118 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( !v118 )
          goto LABEL_524;
        v74 = 0;
        nptrd = (char *)lyxml_get_attr(v118, "name", 0LL);
        if ( !nptrd )
        {
          sub_13937(v150, 13, 0, 0LL, (__int64)"name", v118[6], v65);
          goto LABEL_535;
        }
        if ( !*nptrd )
        {
          sub_13937(v150, 10, 0, 0LL, (__int64)nptrd, (__int64)"enum name", v65);
          sub_13937(v150, -1, 0, 0LL, (__int64)"Enum name must not be empty.", v30);
          goto LABEL_535;
        }
        v31 = strlen(nptrd);
        v32 = (_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc);
        *v32 = lydict_insert(v150, nptrd, v31);
        if ( (unsigned int)sub_51597(
                             (__int64 *)a1,
                             0LL,
                             *(_QWORD *)(v67 + 32) + 48LL * nmembc,
                             5u,
                             (__int64)v118,
                             0,
                             v65) )
        {
          *(_DWORD *)(v67 + 40) = nmembc + 1;
          goto LABEL_535;
        }
        nptre = *(char **)(*(_QWORD *)(v67 + 32) + 48LL * nmembc);
        if ( (*__ctype_b_loc())[*nptre] & 0x2000 || (v34 = *__ctype_b_loc(), v34[nptre[strlen(nptre) - 1]] & 0x2000) )
        {
          sub_13937(v150, 23, 0, 0LL, (__int64)nptre, v33, v65);
          *(_DWORD *)(v67 + 40) = nmembc + 1;
          goto LABEL_535;
        }
        if ( *(_QWORD *)(v143 + 16) )
        {
          v141 = *(_QWORD *)(v143 + 32);
          for ( nmemb_4d = 0; nmemb_4d < *(_DWORD *)(v143 + 40) && nptre != *(char **)(48LL * nmemb_4d + v141); ++nmemb_4d )
            ;
          if ( nmemb_4d == *(_DWORD *)(v143 + 40) )
          {
            sub_13937(v150, 20, 0, 0LL, (__int64)nptre, v33, v65);
            *(_DWORD *)(v67 + 40) = nmembc + 1;
            goto LABEL_535;
          }
        }
        else
        {
          for ( nmemb_4d = 0; nmemb_4d < nmembc; ++nmemb_4d )
          {
            if ( nptre == *(char **)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4d) )
            {
              sub_13937(v150, 22, 0, 0LL, (__int64)nptre, v33, v65);
              *(_DWORD *)(v67 + 40) = nmembc + 1;
              goto LABEL_535;
            }
          }
        }
        v72 = 0;
        v127 = (_QWORD *)v118[3];
LABEL_275:
        if ( v127 )
        {
          v119 = (_QWORD *)v127[4];
          v37 = 1;
        }
        else
        {
          v37 = 0;
        }
        if ( !v37 )
        {
          if ( *(_QWORD *)(v143 + 16) )
          {
            if ( v72 )
            {
              if ( v147 != *(_DWORD *)(48LL * nmemb_4d + v141 + 28) )
              {
                sub_13937(
                  v150,
                  19,
                  0,
                  0LL,
                  *(unsigned int *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28),
                  *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc),
                  *(unsigned int *)(48LL * nmemb_4d + v141 + 28));
                *(_DWORD *)(v67 + 40) = nmembc + 1;
                goto LABEL_535;
              }
            }
            else
            {
              *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28) = *(_DWORD *)(48LL * nmemb_4d + v141 + 28);
              *(_WORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 24) |= 1u;
            }
          }
          else if ( !v72 )
          {
            if ( v146 > 0x7FFFFFFF )
            {
              sub_13937(v150, 10, 0, 0LL, (__int64)"2147483648", (__int64)"enum/value", v65);
              *(_DWORD *)(v67 + 40) = nmembc + 1;
              goto LABEL_535;
            }
            *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28) = v146;
            *(_WORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 24) |= 1u;
            ++v146;
          }
          if ( v74 )
          {
            v141 = *(_QWORD *)(v67 + 32) + 48LL * nmembc;
            *(_QWORD *)(v141 + 40) = calloc(v74, 0x20uLL);
            if ( !*(_QWORD *)(v141 + 40) )
            {
              sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v38, v65);
              *(_DWORD *)(v67 + 40) = nmembc + 1;
              goto LABEL_535;
            }
            for ( n = v118[3]; n; n = *(_QWORD *)(n + 32) )
            {
              if ( !strcmp(*(const char **)(n + 48), "if-feature") )
              {
                v39 = sub_41746(
                        *(_QWORD *)(v67 + 24),
                        0,
                        n,
                        *(_QWORD *)(v141 + 40) + 32LL * *(unsigned __int8 *)(v141 + 27),
                        v65);
                ++*(_BYTE *)(v141 + 27);
                if ( v39 )
                {
                  *(_DWORD *)(v67 + 40) = nmembc + 1;
                  goto LABEL_535;
                }
              }
            }
          }
          ++nmembc;
          v118 = (_QWORD *)v118[4];
          continue;
        }
        break;
      }
      if ( !v127[7] )
        goto LABEL_274;
      if ( !strcmp(*(const char **)(v127[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)v127[6], "value") )
        {
          if ( v72 )
          {
            sub_13937(v150, 14, 0, 0LL, v127[6], v118[6], v65);
            *(_DWORD *)(v67 + 40) = nmembc + 1;
            goto LABEL_535;
          }
          nptrf = (char *)lyxml_get_attr(v127, "value", 0LL);
          if ( !nptrf )
          {
            sub_13937(v150, 13, 0, 0LL, (__int64)"value", v127[6], v65);
            goto LABEL_535;
          }
          v147 = strtoll(nptrf, 0LL, 10);
          if ( v147 < -2147483648LL || v147 > 0x7FFFFFFF )
          {
            sub_13937(v150, 10, 0, 0LL, (__int64)nptrf, (__int64)"enum/value", v65);
            *(_DWORD *)(v67 + 40) = nmembc + 1;
            goto LABEL_535;
          }
          *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28) = v147;
          if ( !*(_QWORD *)(v143 + 16) )
          {
            if ( nmembc )
            {
              if ( v146 > *(signed int *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28) )
              {
                for ( nmemb_4e = 0; nmemb_4e < nmembc; ++nmemb_4e )
                {
                  if ( *(_DWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4e + 28) == *(_DWORD *)(*(_QWORD *)(v67 + 32)
                                                                                              + 48LL * nmembc
                                                                                              + 28) )
                  {
                    sub_13937(
                      v150,
                      21,
                      0,
                      0LL,
                      *(unsigned int *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28),
                      *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc),
                      *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmemb_4e));
                    *(_DWORD *)(v67 + 40) = nmembc + 1;
                    goto LABEL_535;
                  }
                }
              }
              else
              {
                v146 = *(signed int *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 28) + 1LL;
              }
            }
            else
            {
              v146 = *(signed int *)(*(_QWORD *)(v67 + 32) + 28LL) + 1LL;
            }
          }
          v72 = 1;
          if ( (unsigned int)sub_411CA((__int64 *)a1, *(_QWORD *)(v67 + 32) + 48LL * nmembc, 5u, v127, 18, 0LL, v65) )
            goto LABEL_535;
          for ( nmemb_4d = 0; ; ++nmemb_4d )
          {
            if ( nmemb_4d >= *(unsigned __int8 *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 26) )
              goto LABEL_274;
            if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4d + *(_QWORD *)(*(_QWORD *)(v67 + 32) + 48LL * nmembc + 32)) + 24LL) & 8 )
              break;
          }
          v36 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
          HIBYTE(v36) |= 0x20u;
          *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v36;
        }
        else
        {
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)v127[6], "if-feature") )
          {
            sub_13937(v150, 5, 0, 0LL, v127[6], v35, v65);
            goto LABEL_535;
          }
          if ( v74 == 255 )
          {
            sub_12222(
              (__int64)v150,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"if-features",
              "enum");
            goto LABEL_535;
          }
          ++v74;
        }
      }
      else if ( (unsigned int)sub_411CA((__int64 *)a1, *(_QWORD *)(v67 + 32) + 48LL * nmembc, 5u, v127, 0, 0LL, v65) )
      {
        goto LABEL_535;
      }
LABEL_274:
      v127 = v119;
      goto LABEL_275;
    case 7:
      v129 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( v129 )
        {
          v116 = (_QWORD *)v129[4];
          v42 = 1;
        }
        else
        {
          v42 = 0;
        }
        if ( v42 )
        {
          if ( !strcmp((const char *)v129[6], "base") )
          {
            nptrg = (char *)lyxml_get_attr(*(_QWORD *)(v68 + 24), "name", 0LL);
            if ( nptrg )
            {
              nptrh = (char *)sub_9BED((__int64 *)a1, nptrg);
              if ( nptrh )
              {
                v41 = sub_2AB62((__int64 *)a1, v65, (__int64 *)v67, 0x200u, (__int64)nptrh);
                lydict_remove(v150, nptrh);
                if ( v41 != -1 && !(unsigned int)sub_411CA((__int64 *)a1, v67, 3u, v129, 2, 0LL, v65) )
                {
                  v129 = v116;
                  continue;
                }
              }
            }
            else
            {
              sub_13937(v150, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(*(_QWORD *)(v68 + 24) + 48LL), v65);
            }
          }
          else
          {
            sub_13937(v150, 5, 0, 0LL, v129[6], v40, v65);
          }
          goto LABEL_535;
        }
        break;
      }
      if ( !*(_QWORD *)(v68 + 24) )
      {
        if ( *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
          goto LABEL_524;
        sub_13937(v150, 12, 0, 0LL, (__int64)"base", (__int64)"type", v65);
        goto LABEL_535;
      }
      if ( *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        sub_13937(v150, 5, 0, 0LL, (__int64)"base", v7, v65);
        goto LABEL_535;
      }
      if ( *(_QWORD *)(*(_QWORD *)(v68 + 24) + 32LL) )
      {
        sub_13937(
          v150,
          14,
          0,
          0LL,
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v68 + 24) + 32LL) + 48LL),
          *(_QWORD *)(v68 + 48),
          v65);
        goto LABEL_535;
      }
      goto LABEL_524;
    case 8:
      v130 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( !v130 )
          goto LABEL_524;
        if ( !strcmp((const char *)v130[6], "require-instance") )
        {
          if ( *(_BYTE *)(v67 + 32) )
          {
            sub_13937(v150, 14, 0, 0LL, v130[6], *(_QWORD *)(v68 + 48), v65);
            goto LABEL_535;
          }
          nptri = (char *)lyxml_get_attr(v130, "value", 0LL);
          if ( !nptri )
          {
            sub_13937(v150, 13, 0, 0LL, (__int64)"value", v130[6], v65);
            goto LABEL_535;
          }
          if ( !strcmp(nptri, "true") )
          {
            *(_BYTE *)(v67 + 32) = 1;
          }
          else
          {
            if ( strcmp(nptri, "false") )
            {
              sub_13937(v150, 10, 0, 0LL, (__int64)nptri, v130[6], v65);
              goto LABEL_535;
            }
            *(_BYTE *)(v67 + 32) = -1;
          }
          if ( !(unsigned int)sub_411CA((__int64 *)a1, v67, 3u, v130, 21, 0LL, v65) )
          {
            v130 = (_QWORD *)v130[4];
            continue;
          }
        }
        else
        {
          sub_13937(v150, 5, 0, 0LL, v130[6], v43, v65);
        }
        goto LABEL_535;
      }
    case 9:
      if ( !v66 && (unsigned int)sub_A3FB0((__int64)a2) )
        v66 = 1;
      v132 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( v132 )
        {
          if ( strcmp((const char *)v132[6], "path") || *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
          {
            if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1
              || strcmp((const char *)v132[6], "require-instance")
              || *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
            {
              sub_13937(v150, 5, 0, 0LL, v132[6], v48, v65);
              goto LABEL_535;
            }
            if ( *(_BYTE *)(v67 + 48) )
            {
              sub_13937(v150, 14, 0, 0LL, v132[6], *(_QWORD *)(v68 + 48), v65);
              goto LABEL_535;
            }
            nptrk = (char *)lyxml_get_attr(v132, "value", 0LL);
            if ( !nptrk )
            {
              sub_13937(v150, 13, 0, 0LL, (__int64)"value", v132[6], v65);
              goto LABEL_535;
            }
            if ( !strcmp(nptrk, "true") )
            {
              *(_BYTE *)(v67 + 48) = 1;
            }
            else
            {
              if ( strcmp(nptrk, "false") )
              {
                sub_13937(v150, 10, 0, 0LL, (__int64)nptrk, v132[6], v65);
                goto LABEL_535;
              }
              *(_BYTE *)(v67 + 48) = -1;
            }
            if ( (unsigned int)sub_411CA((__int64 *)a1, v67, 3u, v132, 21, 0LL, v65) )
              goto LABEL_535;
          }
          v132 = (_QWORD *)v132[4];
          continue;
        }
        break;
      }
      for ( ii = *(_QWORD **)(v68 + 24); ii; ii = (_QWORD *)ii[4] )
      {
        if ( !strcmp((const char *)ii[6], "path") && !*(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
        {
          if ( *(_QWORD *)(v67 + 32) )
          {
            sub_13937(v150, 14, 0, 0LL, ii[6], *(_QWORD *)(v68 + 48), v65);
            goto LABEL_535;
          }
          nptrl = (char *)lyxml_get_attr(ii, "value", 0LL);
          if ( !nptrl )
          {
            sub_13937(v150, 13, 0, 0LL, (__int64)"value", ii[6], v65);
            goto LABEL_535;
          }
          *(_QWORD *)(v67 + 32) = sub_9BED((__int64 *)a1, nptrl);
          if ( !*(_QWORD *)(v67 + 32)
            || !v66 && (unsigned int)sub_2ABDE((__int64 *)a1, v65, (__int64 *)v67, 0x20u, (__int64 *)a2) == -1
            || (unsigned int)sub_411CA((__int64 *)a1, v67, 3u, ii, 12, 0LL, v65) )
          {
            goto LABEL_535;
          }
          break;
        }
      }
      if ( *(_QWORD *)(v67 + 32) )
        goto LABEL_524;
      if ( !*(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
      {
        sub_13937(v150, 12, 0, 0LL, (__int64)"path", (__int64)"type", v65);
        goto LABEL_535;
      }
      *(_QWORD *)(v67 + 32) = lydict_insert(v150, *(_QWORD *)(*(_QWORD *)(v67 + 16) + 88LL), 0LL);
      *(_BYTE *)(v67 + 48) = *(_BYTE *)(*(_QWORD *)(v67 + 16) + 104LL);
      if ( !v66 && (unsigned int)sub_2ABDE((__int64 *)a1, v65, (__int64 *)v67, 0x20u, (__int64 *)a2) == -1 )
        goto LABEL_535;
      goto LABEL_524;
    case 0xA:
      nmembd = 0;
      v134 = *(_QWORD *)(v68 + 24);
      while ( 2 )
      {
        if ( v134 )
        {
          v116 = *(_QWORD **)(v134 + 32);
          v53 = 1;
        }
        else
        {
          v53 = 0;
        }
        if ( v53 )
        {
          if ( !strcmp(*(const char **)(v134 + 48), "length") )
          {
            if ( *(_QWORD *)(v67 + 32) )
            {
              sub_13937(v150, 14, 0, 0LL, *(_QWORD *)(v134 + 48), *(_QWORD *)(v68 + 48), v65);
              goto LABEL_535;
            }
            nptrm = (char *)lyxml_get_attr(v134, "value", 0LL);
            if ( !nptrm )
            {
              sub_13937(v150, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(v134 + 48), v65);
              goto LABEL_535;
            }
            if ( (unsigned int)sub_36896(v150, nptrm, (int *)v67) )
            {
              sub_13937(v150, 10, 0, 0LL, (__int64)nptrm, (__int64)"length", v65);
              goto LABEL_535;
            }
            *(_QWORD *)(v67 + 32) = calloc(1uLL, 0x38uLL);
            if ( !*(_QWORD *)(v67 + 32) )
            {
              sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v49, v65);
              goto LABEL_535;
            }
            v50 = *(_QWORD **)(v67 + 32);
            *v50 = lydict_insert(v150, nptrm, 0LL);
            if ( (unsigned int)sub_421DA((__int64 *)a1, *(_QWORD **)(v67 + 32), v134, v65) )
              goto LABEL_535;
            for ( nmemb_4g = 0; ; ++nmemb_4g )
            {
              if ( nmemb_4g >= *(unsigned __int8 *)(*(_QWORD *)(v67 + 32) + 48LL) )
                goto LABEL_420;
              if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4g + *(_QWORD *)(*(_QWORD *)(v67 + 32) + 40LL)) + 24LL) & 8 )
                break;
            }
            v51 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
            HIBYTE(v51) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v51;
LABEL_420:
            lyxml_free(v150, v134);
          }
          else
          {
            if ( strcmp(*(const char **)(v134 + 48), "pattern") )
            {
              sub_13937(v150, 5, 0, 0LL, *(_QWORD *)(v134 + 48), v52, v65);
              goto LABEL_535;
            }
            if ( nmembd == -1 )
            {
              sub_12222(
                (__int64)v150,
                0,
                4,
                "Reached limit (%lu) for storing %s in %s statement.",
                0xFFFFFFFFLL,
                (__int64)"patterns",
                "type");
              goto LABEL_535;
            }
            ++nmembd;
          }
          v134 = (__int64)v116;
          continue;
        }
        break;
      }
      if ( nmembd )
      {
        if ( !v66 && a2 && (unsigned int)sub_A3FB0((__int64)a2) )
          v94 = 1;
        *(_QWORD *)(v67 + 40) = calloc(nmembd, 0x38uLL);
        if ( !*(_QWORD *)(v67 + 40) )
        {
          sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v54, v65);
          goto LABEL_535;
        }
        if ( !v94 )
        {
          *(_QWORD *)(v67 + 56) = calloc(2 * nmembd, 8uLL);
          if ( !*(_QWORD *)(v67 + 56) )
          {
            sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v55, v65);
            goto LABEL_535;
          }
        }
        for ( jj = *(_QWORD **)(v68 + 24); jj; jj = (_QWORD *)jj[4] )
        {
          nptrn = (char *)lyxml_get_attr(jj, "value", 0LL);
          if ( !nptrn )
          {
            sub_13937(v150, 13, 0, 0LL, (__int64)"value", jj[6], v65);
            goto LABEL_535;
          }
          if ( v94 )
          {
            if ( !(v150[23] & 2) && (unsigned int)sub_36C95(v150, nptrn, 0LL) )
              goto LABEL_535;
          }
          else if ( (unsigned int)sub_372F0(
                                    v150,
                                    nptrn,
                                    (void **)(8LL * (unsigned int)(2 * *(_DWORD *)(v67 + 48)) + *(_QWORD *)(v67 + 56)),
                                    (_QWORD *)(*(_QWORD *)(v67 + 56)
                                             + 8LL * (unsigned int)(2 * *(_DWORD *)(v67 + 48) + 1))) )
          {
            goto LABEL_535;
          }
          v151 = *(_QWORD *)(v67 + 40) + 56LL * (unsigned int)(*(_DWORD *)(v67 + 48))++;
          v69 = 6;
          s2c = 0LL;
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 )
          {
            for ( kk = (_QWORD *)jj[3]; ; kk = v119 )
            {
              if ( kk )
              {
                v119 = (_QWORD *)kk[4];
                v56 = 1;
              }
              else
              {
                v56 = 0;
              }
              if ( !v56 )
                break;
              if ( kk[7]
                && !strcmp(*(const char **)(kk[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1")
                && !strcmp((const char *)kk[6], "modifier") )
              {
                if ( s2c )
                {
                  sub_13937(v150, 14, 0, 0LL, (__int64)"modifier", jj[6], v65);
                  goto LABEL_535;
                }
                s2c = (char *)lyxml_get_attr(kk, "value", 0LL);
                if ( !s2c )
                {
                  sub_13937(v150, 13, 0, 0LL, (__int64)"value", kk[6], v65);
                  goto LABEL_535;
                }
                if ( strcmp(s2c, "invert-match") )
                {
                  sub_13937(v150, 10, 0, 0LL, (__int64)s2c, (__int64)"modifier", v65);
                  goto LABEL_535;
                }
                v69 = 21;
                if ( (unsigned int)sub_411CA((__int64 *)a1, v151, 7u, kk, 20, 0LL, v65) )
                  goto LABEL_535;
                lyxml_free(v150, kk);
              }
            }
          }
          v57 = strlen(nptrn);
          v152 = malloc(v57 + 2);
          if ( !v152 )
          {
            sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v58, v65);
            goto LABEL_535;
          }
          *v152 = v69;
          strcpy(v152 + 1, nptrn);
          *(_QWORD *)v151 = lydict_insert_zc(v150, v152);
          if ( (unsigned int)sub_421DA((__int64 *)a1, (_QWORD *)v151, (__int64)jj, v65) )
            goto LABEL_535;
          for ( nmemb_4h = 0; nmemb_4h < *(unsigned __int8 *)(v151 + 48); ++nmemb_4h )
          {
            if ( *(_WORD *)(*(_QWORD *)(8LL * nmemb_4h + *(_QWORD *)(v151 + 40)) + 24LL) & 8 )
            {
              v59 = *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL);
              HIBYTE(v59) |= 0x20u;
              *(_WORD *)(*(_QWORD *)(v67 + 24) + 24LL) = v59;
              break;
            }
          }
        }
      }
      goto LABEL_524;
    case 0xB:
      nmembe = 0;
      v136 = *(_QWORD **)(v68 + 24);
      while ( 2 )
      {
        if ( v136 )
        {
          v116 = (_QWORD *)v136[4];
          v61 = 1;
        }
        else
        {
          v61 = 0;
        }
        if ( v61 )
        {
          if ( !strcmp((const char *)v136[6], "type") )
          {
            if ( *(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
            {
              sub_13937(v150, 6, 0, 0LL, (__int64)"type", (__int64)"derived type", v65);
            }
            else
            {
              if ( nmembe != -1 )
              {
                ++nmembe;
                v136 = v116;
                continue;
              }
              sub_12222(
                (__int64)v150,
                0,
                4,
                "Reached limit (%lu) for storing %s in %s statement.",
                0xFFFFFFFFLL,
                (__int64)"types",
                "type");
            }
          }
          else
          {
            sub_13937(v150, 5, 0, 0LL, v136[6], v60, v65);
          }
        }
        else
        {
          if ( !nmembe && !*(_QWORD *)(*(_QWORD *)(v67 + 16) + 72LL) )
          {
            sub_13937(v150, 12, 0, 0LL, (__int64)"type", (__int64)"(union) type", v65);
            goto LABEL_535;
          }
          if ( *(_DWORD *)(*(_QWORD *)(v67 + 16) + 56LL) == 11 && *(_DWORD *)(*(_QWORD *)(v67 + 16) + 100LL) )
            *(_DWORD *)(v67 + 44) = 1;
          if ( nmembe )
          {
            *(_QWORD *)(v67 + 32) = calloc(nmembe, 0x40uLL);
            if ( !*(_QWORD *)(v67 + 32) )
            {
              sub_12222((__int64)v150, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_type", v62, v65);
              goto LABEL_535;
            }
          }
          for ( ll = *(_QWORD *)(v68 + 24); ; ll = *(_QWORD *)(ll + 32) )
          {
            if ( !ll )
              goto LABEL_524;
            *(_QWORD *)(((unsigned __int64)*(unsigned int *)(v67 + 40) << 6) + *(_QWORD *)(v67 + 32) + 24) = *(_QWORD *)(v67 + 24);
            v71 = sub_426E1(
                    a1,
                    a2,
                    ll,
                    *(_QWORD *)(v67 + 32) + ((unsigned __int64)*(unsigned int *)(v67 + 40) << 6),
                    v66,
                    v65);
            if ( !v71 )
            {
              ++*(_DWORD *)(v67 + 40);
              if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
              {
                if ( *(_DWORD *)(*(_QWORD *)(v67 + 32)
                               + ((unsigned __int64)(unsigned int)(*(_DWORD *)(v67 + 40) - 1) << 6)) == 5 )
                {
                  sub_13937(v150, 10, 0, 0LL, (__int64)"empty", *(_QWORD *)(ll + 48), v65);
                  v71 = -1;
                }
                else if ( *(_DWORD *)(*(_QWORD *)(v67 + 32)
                                    + ((unsigned __int64)(unsigned int)(*(_DWORD *)(v67 + 40) - 1) << 6)) == 9 )
                {
                  sub_13937(v150, 10, 0, 0LL, (__int64)"leafref", *(_QWORD *)(ll + 48), v65);
                  v71 = -1;
                }
              }
              if ( *(_DWORD *)(*(_QWORD *)(v67 + 32) + ((unsigned __int64)(unsigned int)(*(_DWORD *)(v67 + 40) - 1) << 6)) == 8
                || *(_DWORD *)(*(_QWORD *)(v67 + 32) + ((unsigned __int64)(unsigned int)(*(_DWORD *)(v67 + 40) - 1) << 6)) == 9
                || *(_DWORD *)(*(_QWORD *)(v67 + 32) + ((unsigned __int64)(unsigned int)(*(_DWORD *)(v67 + 40) - 1) << 6)) == 11
                && *(_DWORD *)(*(_QWORD *)(v67 + 32)
                             + ((unsigned __int64)(unsigned int)(*(_DWORD *)(v67 + 40) - 1) << 6)
                             + 44) )
              {
                *(_DWORD *)(v67 + 44) = 1;
              }
            }
            if ( v71 )
              break;
          }
          for ( nmembf = 0; nmembf < *(_DWORD *)(v67 + 40); ++nmembf )
            sub_A1648((__int64)v150, *(_QWORD *)(v67 + 32) + ((unsigned __int64)nmembf << 6), 0LL);
          free(*(void **)(v67 + 32));
          *(_QWORD *)(v67 + 32) = 0LL;
          *(_DWORD *)(v67 + 40) = 0;
          *(_DWORD *)(v67 + 44) = 0;
          *(_QWORD *)(v67 + 16) = 0LL;
          *(_DWORD *)v67 = 0;
          if ( v71 == 1 )
            v93 = 1;
        }
        goto LABEL_535;
      }
    default:
      sub_12222(
        (__int64)v150,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yin.c",
        1605LL,
        v65);
      goto LABEL_535;
  }
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 75F0: using guessed type __int64 __fastcall lyxml_free_withsiblings(_QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000004778E) ----------------------------------------------------
signed __int64 __fastcall sub_4778E(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  size_t v6; // rax
  size_t v7; // rax
  __int64 v8; // r9
  size_t v9; // rax
  char v10; // al
  __int64 v11; // r9
  _BOOL4 v12; // eax
  char v13; // al
  __int16 v14; // ax
  __int64 v16; // [rsp+8h] [rbp-68h]
  __int64 v17; // [rsp+10h] [rbp-60h]
  __int64 v18; // [rsp+18h] [rbp-58h]
  signed int v19; // [rsp+38h] [rbp-38h]
  int v20; // [rsp+3Ch] [rbp-34h]
  signed int k; // [rsp+40h] [rbp-30h]
  char *s; // [rsp+48h] [rbp-28h]
  _QWORD *i; // [rsp+50h] [rbp-20h]
  __int64 j; // [rsp+50h] [rbp-20h]
  _QWORD *v25; // [rsp+58h] [rbp-18h]
  _DWORD *v26; // [rsp+60h] [rbp-10h]
  void *v27; // [rsp+68h] [rbp-8h]

  v18 = a3;
  v17 = a4;
  v16 = a5;
  v26 = (_DWORD *)*a1;
  v19 = 0;
  v20 = 0;
  s = (char *)lyxml_get_attr(a3, "name", 0LL);
  if ( !s )
  {
    sub_13937(v26, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(v18 + 48));
    return 1LL;
  }
  if ( (unsigned int)sub_3B812(v26, s, 3u, (__int64)a1, (__int64)a2, v5) )
    return 1LL;
  v6 = strlen(s);
  *(_QWORD *)v17 = lydict_insert(v26, s, v6);
  if ( (unsigned int)sub_51597(a1, 0LL, v17, 2u, v18, 16, v16) )
    return 1LL;
  for ( i = *(_QWORD **)(v18 + 24); ; i = v25 )
  {
    if ( i )
    {
      v25 = (_QWORD *)i[4];
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    if ( !v10 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "type") )
      {
        if ( v19 )
        {
          sub_13937(v26, 14, 0, 0LL, i[6], *(_QWORD *)(v18 + 48));
          return 1LL;
        }
        *(_QWORD *)(v17 + 72) = i;
        *(_QWORD *)(v17 + 80) = v17;
        if ( (unsigned int)sub_2ABDE(a1, v16, (__int64 *)(v17 + 56), 8u, a2) == -1 )
          return 1LL;
        v19 = 1;
      }
      else
      {
        if ( !strcmp((const char *)i[6], "default") )
        {
          if ( *(_QWORD *)(v17 + 120) )
          {
            sub_13937(v26, 14, 0, 0LL, i[6], *(_QWORD *)(v18 + 48));
            return 1LL;
          }
          s = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s )
          {
            sub_13937(v26, 13, 0, 0LL, (__int64)"value", i[6]);
            return 1LL;
          }
          v7 = strlen(s);
          *(_QWORD *)(v17 + 120) = lydict_insert(v26, s, v7);
          if ( (unsigned int)sub_411CA(a1, v17, 2u, i, 5, 0LL, v16) )
            return 1LL;
        }
        else
        {
          if ( strcmp((const char *)i[6], "units") )
          {
            sub_13937(v26, 5, 0, 0LL, (__int64)s, v8);
            return 1LL;
          }
          if ( *(_QWORD *)(v17 + 40) )
          {
            sub_13937(v26, 14, 0, 0LL, i[6], *(_QWORD *)(v18 + 48));
            return 1LL;
          }
          s = (char *)lyxml_get_attr(i, "name", 0LL);
          if ( !s )
          {
            sub_13937(v26, 13, 0, 0LL, (__int64)"name", i[6]);
            return 1LL;
          }
          v9 = strlen(s);
          *(_QWORD *)(v17 + 40) = lydict_insert(v26, s, v9);
          if ( (unsigned int)sub_411CA(a1, v17, 2u, i, 17, 0LL, v16) )
            return 1LL;
        }
        lyxml_free(v26, i);
      }
    }
    else
    {
      if ( v20 == 255 )
      {
        sub_12222(
          (__int64)v26,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "typedef");
        return 1LL;
      }
      ++v20;
    }
  }
  if ( !v19 )
  {
    sub_13937(v26, 12, 0, 0LL, (__int64)"type", *(_QWORD *)(v18 + 48));
    return 1LL;
  }
  if ( !(v26[23] & 2) && (unsigned int)sub_2ABDE(a1, v16, (__int64 *)(v17 + 56), 0x800u, (__int64 *)(v17 + 120)) == -1 )
    return 1LL;
  if ( v20 )
  {
    v27 = realloc(*(void **)(v17 + 32), 8LL * (*(unsigned __int8 *)(v17 + 26) + v20));
    if ( !v27 )
    {
      sub_12222((__int64)v26, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_typedef", v11);
      return 1LL;
    }
    *(_QWORD *)(v17 + 32) = v27;
    memset((void *)(*(_QWORD *)(v17 + 32) + 8LL * *(unsigned __int8 *)(v17 + 26)), 0, 8LL * v20);
    for ( j = *(_QWORD *)(v18 + 24); ; j = (__int64)v25 )
    {
      if ( j )
      {
        v25 = *(_QWORD **)(j + 32);
        v13 = 1;
      }
      else
      {
        v13 = 0;
      }
      if ( !v13 )
        break;
      v12 = sub_40F96(v17, 3, 0, 0, a1, j, (__int64 *)(v17 + 32), *(_BYTE *)(v17 + 26), v16);
      ++*(_BYTE *)(v17 + 26);
      if ( v12 )
        return 1LL;
    }
  }
  for ( k = 0; k < *(unsigned __int8 *)(v17 + 26); ++k )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v17 + 32)) + 24LL) & 8 )
    {
      v14 = *(_WORD *)(v17 + 24);
      HIBYTE(v14) |= 0x20u;
      *(_WORD *)(v17 + 24) = v14;
      return 0LL;
    }
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000047EF1) ----------------------------------------------------
signed __int64 __fastcall sub_47EF1(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  size_t v5; // rax
  size_t v6; // rax
  char v7; // al
  char v8; // al
  __int64 v9; // r9
  _BOOL4 v10; // eax
  char v11; // al
  char *v12; // rdx
  __int64 v14; // [rsp+0h] [rbp-60h]
  __int64 v15; // [rsp+8h] [rbp-58h]
  int v16; // [rsp+20h] [rbp-40h]
  _QWORD *j; // [rsp+28h] [rbp-38h]
  _QWORD *i; // [rsp+30h] [rbp-30h]
  __int64 k; // [rsp+30h] [rbp-30h]
  _QWORD *v20; // [rsp+38h] [rbp-28h]
  _QWORD *v21; // [rsp+40h] [rbp-20h]
  void *v22; // [rsp+48h] [rbp-18h]
  char *s; // [rsp+50h] [rbp-10h]
  char *sa; // [rsp+50h] [rbp-10h]
  char *sb; // [rsp+50h] [rbp-10h]
  void *v26; // [rsp+58h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v22 = (void *)*a1;
  v16 = 0;
  s = (char *)lyxml_get_attr(a2, "name", 0LL);
  if ( !s )
  {
    sub_13937(v22, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(a2 + 48), v14);
    return 1LL;
  }
  if ( (unsigned int)sub_3B812(v22, s, 7u, (__int64)a1, 0LL, v4) )
    return 1LL;
  v5 = strlen(s);
  *(_QWORD *)v15 = lydict_insert(v22, s, v5);
  if ( (unsigned int)sub_51597(a1, 0LL, v15, 0xAu, a2, 16, v14) )
    return 1LL;
  for ( i = *(_QWORD **)(a2 + 24); ; i = v20 )
  {
    if ( i )
    {
      v20 = (_QWORD *)i[4];
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    if ( !v8 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( strcmp((const char *)i[6], "argument") )
      {
        sub_13937(v22, 6, 0, 0LL, i[6], i[6], v14);
        return 1LL;
      }
      sa = (char *)lyxml_get_attr(i, "name", 0LL);
      if ( !sa )
      {
        sub_13937(v22, 13, 0, 0LL, (__int64)"name", i[6], v14);
        return 1LL;
      }
      v6 = strlen(sa);
      *(_QWORD *)(v15 + 40) = lydict_insert(v22, sa, v6);
      if ( (unsigned int)sub_411CA(a1, v15, 0xAu, i, 1, 0LL, v14) )
        return 1LL;
      for ( j = (_QWORD *)i[3]; ; j = v21 )
      {
        if ( j )
        {
          v21 = (_QWORD *)j[4];
          v7 = 1;
        }
        else
        {
          v7 = 0;
        }
        if ( !v7 )
          break;
        if ( j[7] == i[7] && !strcmp((const char *)j[6], "yin-element") )
        {
          sb = (char *)lyxml_get_attr(j, "value", 0LL);
          if ( !sb )
          {
            sub_13937(v22, 13, 0, 0LL, (__int64)"value", j[6], v14);
            return 1LL;
          }
          if ( (unsigned int)sub_C462(sb, "true") )
            *(_WORD *)(v15 + 24) |= 1u;
          if ( (unsigned int)sub_411CA(a1, v15, 0xAu, j, 22, 0LL, v14) )
            return 1LL;
        }
        else if ( j[7] )
        {
          sub_13937(v22, 6, 0, 0LL, j[6], j[6], v14);
          return 1LL;
        }
      }
      lyxml_free(v22, i);
    }
    else
    {
      if ( v16 == 255 )
      {
        sub_12222(
          (__int64)v22,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "extension");
        return 1LL;
      }
      ++v16;
    }
  }
  if ( v16 )
  {
    v26 = realloc(*(void **)(v15 + 32), 8LL * (*(unsigned __int8 *)(v15 + 26) + v16));
    if ( !v26 )
    {
      sub_12222((__int64)v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_extension", v9, v14);
      return 1LL;
    }
    *(_QWORD *)(v15 + 32) = v26;
    memset((void *)(*(_QWORD *)(v15 + 32) + 8LL * *(unsigned __int8 *)(v15 + 26)), 0, 8LL * v16);
    for ( k = *(_QWORD *)(a2 + 24); ; k = (__int64)v20 )
    {
      if ( k )
      {
        v20 = *(_QWORD **)(k + 32);
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
      if ( !v11 )
        break;
      v10 = sub_40F96(v15, 10, 0, 0, a1, k, (__int64 *)(v15 + 32), *(_BYTE *)(v15 + 26), v14);
      ++*(_BYTE *)(v15 + 26);
      if ( v10 )
        return 1LL;
    }
  }
  if ( *(_QWORD *)(*(_QWORD *)(v15 + 48) + 88LL) )
    v12 = *(char **)(*(_QWORD *)(v15 + 48) + 88LL);
  else
    v12 = 0LL;
  *(_QWORD *)(v15 + 56) = sub_C1405(*(const char **)v15, *(const char **)(*(_QWORD *)(v15 + 48) + 8LL), v12);
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000004852A) ----------------------------------------------------
signed __int64 __fastcall sub_4852A(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  size_t v5; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  _BOOL4 v9; // eax
  int v10; // eax
  char v11; // al
  __int64 v13; // [rsp+0h] [rbp-60h]
  __int64 v14; // [rsp+8h] [rbp-58h]
  int v15; // [rsp+2Ch] [rbp-34h]
  int v16; // [rsp+30h] [rbp-30h]
  _QWORD *i; // [rsp+38h] [rbp-28h]
  __int64 j; // [rsp+38h] [rbp-28h]
  __int64 v19; // [rsp+40h] [rbp-20h]
  void *v20; // [rsp+48h] [rbp-18h]
  char *s; // [rsp+50h] [rbp-10h]
  void *v22; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v20 = (void *)*a1;
  v15 = 0;
  v16 = 0;
  s = (char *)lyxml_get_attr(a2, "name", 0LL);
  if ( s )
  {
    if ( (unsigned int)sub_3B812(v20, s, 1u, (__int64)a1, 0LL, v4) )
      return 1LL;
    v5 = strlen(s);
    *(_QWORD *)v14 = lydict_insert(v20, s, v5);
    *(_QWORD *)(v14 + 48) = a1;
    if ( (unsigned int)sub_51597(a1, 0LL, v14, 6u, a2, 0, v13) )
      return 1LL;
    for ( i = *(_QWORD **)(a2 + 24); i; i = (_QWORD *)i[4] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( strcmp((const char *)i[6], "if-feature") )
        {
          sub_13937(v20, 5, 0, 0LL, i[6], v6, v13);
          return 1LL;
        }
        if ( v15 == 255 )
        {
          sub_12222(
            (__int64)v20,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-feature",
            "feature");
          return 1LL;
        }
        ++v15;
      }
      else
      {
        if ( v16 == 255 )
        {
          sub_12222(
            (__int64)v20,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            "feature");
          return 1LL;
        }
        ++v16;
      }
    }
    if ( !v15 || (*(_QWORD *)(v14 + 40) = calloc(v15, 0x20uLL)) != 0LL )
    {
      if ( v16 )
      {
        v22 = realloc(*(void **)(v14 + 32), 8LL * (*(unsigned __int8 *)(v14 + 26) + v16));
        if ( !v22 )
        {
          sub_12222((__int64)v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_feature", v8, v13);
          return 1LL;
        }
        *(_QWORD *)(v14 + 32) = v22;
        memset((void *)(*(_QWORD *)(v14 + 32) + 8LL * *(unsigned __int8 *)(v14 + 26)), 0, 8LL * v16);
      }
      for ( j = *(_QWORD *)(a2 + 24); ; j = v19 )
      {
        if ( j )
        {
          v19 = *(_QWORD *)(j + 32);
          v11 = 1;
        }
        else
        {
          v11 = 0;
        }
        if ( !v11 )
          break;
        if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
        {
          v10 = sub_41746(v14, 1, j, *(_QWORD *)(v14 + 40) + 32LL * *(unsigned __int8 *)(v14 + 27), v13);
          ++*(_BYTE *)(v14 + 27);
          if ( v10 )
            return 1LL;
        }
        else
        {
          v9 = sub_40F96(v14, 6, 0, 0, a1, j, (__int64 *)(v14 + 32), *(_BYTE *)(v14 + 26), v13);
          ++*(_BYTE *)(v14 + 26);
          if ( v9 )
            return 1LL;
        }
      }
      if ( !*(_BYTE *)(v14 + 27) || (unsigned int)sub_2ABDE(a1, v13, (__int64 *)v14, 0x400u, 0LL) != -1 )
        return 0LL;
    }
    else
    {
      sub_12222((__int64)v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_feature", v7, v13);
    }
  }
  else
  {
    sub_13937(v20, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(a2 + 48), v13);
  }
  return 1LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000489FC) ----------------------------------------------------
__int64 __fastcall sub_489FC(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  __int64 *v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  const char *v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v7 = 1;
  *a3 = 0LL;
  v8 = (const char *)lyxml_get_attr(a2, "condition", 0LL);
  if ( v8 )
  {
    *v6 = sub_9BED(a1, v8);
    if ( *v6 )
      v7 = sub_421DA(a1, v6, a2, v5);
  }
  else
  {
    sub_13937((void *)*a1, 13, 0, 0LL, (__int64)"condition", *(_QWORD *)(a2 + 48), v5);
  }
  if ( v7 )
  {
    lydict_remove(*a1, *v6);
    *v6 = 0LL;
  }
  return v7;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000048AF6) ----------------------------------------------------
signed __int64 __fastcall sub_48AF6(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r9
  char v8; // al
  __int64 v10; // [rsp+0h] [rbp-40h]
  _QWORD *dest; // [rsp+8h] [rbp-38h]
  _QWORD *v12; // [rsp+20h] [rbp-20h]
  _QWORD *i; // [rsp+28h] [rbp-18h]
  void *v14; // [rsp+30h] [rbp-10h]
  const char *src; // [rsp+38h] [rbp-8h]

  dest = a3;
  v10 = a4;
  v14 = (void *)*a1;
  src = (const char *)lyxml_get_attr(a2, "date", 0LL);
  if ( !src )
  {
    sub_13937(v14, 13, 0, 0LL, (__int64)"date", *(_QWORD *)(a2 + 48), v10);
    return 1LL;
  }
  if ( (unsigned int)sub_3C2C9(v14, src, (__int64)src, v4, v5, v6) )
    return 1LL;
  memcpy(dest, src, 0xAuLL);
  for ( i = *(_QWORD **)(a2 + 24); ; i = v12 )
  {
    if ( i )
    {
      v12 = (_QWORD *)i[4];
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    if ( !v8 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "description") )
        {
          if ( dest[3] )
          {
            sub_13937(v14, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v10);
            return 1LL;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)dest, 0x11u, i, 6, 0LL, v10) )
            return 1LL;
          dest[3] = sub_410A7(v14, (__int64)i, "text");
          if ( !dest[3] )
            return 1LL;
        }
        else
        {
          if ( strcmp((const char *)i[6], "reference") )
          {
            sub_13937(v14, 5, 0, 0LL, i[6], v7, v10);
            return 1LL;
          }
          if ( dest[4] )
          {
            sub_13937(v14, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v10);
            return 1LL;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)dest, 0x11u, i, 15, 0LL, v10) )
            return 1LL;
          dest[4] = sub_410A7(v14, (__int64)i, "text");
          if ( !dest[4] )
            return 1LL;
        }
      }
      else if ( (unsigned int)sub_411CA(a1, (__int64)dest, 0x11u, i, 0, 0LL, v10) )
      {
        return 1LL;
      }
    }
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (0000000000048E4C) ----------------------------------------------------
__int64 __fastcall sub_48E4C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 *v7; // rbx
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v11; // [rsp+8h] [rbp-78h]
  __int64 v12; // [rsp+10h] [rbp-70h]
  __int64 v13; // [rsp+18h] [rbp-68h]
  char v14; // [rsp+33h] [rbp-4Dh]
  signed int i; // [rsp+34h] [rbp-4Ch]
  signed int j; // [rsp+38h] [rbp-48h]
  unsigned int v17; // [rsp+3Ch] [rbp-44h]
  char *k; // [rsp+40h] [rbp-40h]
  const char *v19; // [rsp+48h] [rbp-38h]
  char *v20; // [rsp+48h] [rbp-38h]
  char *ptr; // [rsp+50h] [rbp-30h]
  void *v22; // [rsp+58h] [rbp-28h]
  char *s; // [rsp+60h] [rbp-20h]
  __int64 *v24; // [rsp+68h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v22 = (void *)*a1;
  v17 = 1;
  ptr = 0LL;
  s = (char *)lyxml_get_attr(a3, "tag", 0LL);
  if ( s )
  {
    v19 = strdup(s);
    k = (char *)v19;
    ptr = (char *)v19;
    if ( v19 )
    {
      while ( 1 )
      {
        v19 = strpbrk(v19, off_10F526);
        if ( !v19 )
          break;
        if ( *(_BYTE *)(v12 + 8) == -1 )
        {
          sub_12222(
            (__int64)v22,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"referenced items",
            "unique");
          *(_BYTE *)(v12 + 8) = 0;
          goto LABEL_36;
        }
        ++*(_BYTE *)(v12 + 8);
        while ( (*__ctype_b_loc())[*v19] & 0x2000 )
          ++v19;
      }
      *(_QWORD *)v12 = calloc((unsigned __int8)++*(_BYTE *)(v12 + 8), 8uLL);
      if ( *(_QWORD *)v12 )
      {
        for ( i = 0; i < *(unsigned __int8 *)(v12 + 8); ++i )
        {
          v20 = strpbrk(k, off_10F526);
          if ( v20 )
          {
            v14 = *v20;
            *v20 = 0;
          }
          v7 = (__int64 *)(*(_QWORD *)v12 + 8LL * i);
          *v7 = sub_9BED(a1, k);
          if ( v20 )
            *v20 = v14;
          for ( j = 0; j < i; ++j )
          {
            if ( *(_QWORD *)(8LL * j + *(_QWORD *)v12) == *(_QWORD *)(8LL * i + *(_QWORD *)v12) )
            {
              sub_13937(v22, 10, 0, 0LL, *(_QWORD *)(8LL * i + *(_QWORD *)v12), (__int64)"unique");
              sub_13937(v22, -1, 0, 0LL, (__int64)"The identifier is not unique", v8);
              goto LABEL_36;
            }
          }
          if ( v11 )
          {
            v24 = (__int64 *)malloc(0x18uLL);
            if ( !v24 )
            {
              sub_12222((__int64)v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_unique", v9);
              goto LABEL_36;
            }
            *v24 = a2;
            v24[1] = *(_QWORD *)(8LL * i + *(_QWORD *)v12);
            v24[2] = v12 + 9;
            if ( (unsigned int)sub_2ABDE(a1, v11, v24, 0x4000u, 0LL) == -1 )
              goto LABEL_36;
          }
          else if ( (unsigned int)sub_1F79E(a2, *(const char **)(8LL * i + *(_QWORD *)v12), (_BYTE *)(v12 + 9)) )
          {
            goto LABEL_36;
          }
          for ( k = v20; k && (*__ctype_b_loc())[*k] & 0x2000; ++k )
            ;
        }
        v17 = 0;
      }
      else
      {
        sub_12222((__int64)v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_unique", v6);
      }
    }
    else
    {
      sub_12222((__int64)v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_unique", v5);
    }
  }
  else
  {
    sub_13937(v22, 13, 0, 0LL, (__int64)"tag", *(_QWORD *)(v13 + 48));
  }
LABEL_36:
  free(ptr);
  return v17;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (00000000000492EA) ----------------------------------------------------
signed __int64 __fastcall sub_492EA(__int64 a1, __int64 a2, _DWORD *a3, int a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  int v12; // [rsp+4h] [rbp-5Ch]
  _DWORD *v13; // [rsp+8h] [rbp-58h]
  char *endptr; // [rsp+20h] [rbp-40h]
  char *s1; // [rsp+28h] [rbp-38h]
  unsigned __int64 v16; // [rsp+30h] [rbp-30h]
  _DWORD *v17; // [rsp+38h] [rbp-28h]
  _DWORD *v18; // [rsp+40h] [rbp-20h]
  _DWORD *v19; // [rsp+48h] [rbp-18h]
  void *v20; // [rsp+50h] [rbp-10h]
  unsigned __int64 v21; // [rsp+58h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v21 = __readfsqword(0x28u);
  v20 = **(void ***)(a1 + 48);
  if ( *a3 == 3 )
  {
    if ( a4 )
      v6 = "max-elements";
    else
      v6 = "min-elements";
    sub_13937(v20, 6, 0, 0LL, (__int64)v6, (__int64)"deviate delete");
    return 1LL;
  }
  if ( *(_DWORD *)(a1 + 56) == 8 )
  {
    v19 = (_DWORD *)(a1 + 212);
    v18 = (_DWORD *)(a1 + 208);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 56) != 16 )
    {
      sub_13937(v20, 5, 0, 0LL, *(_QWORD *)(a2 + 48), a6);
      sub_13937(v20, -1, 0, 0LL, (__int64)"Target node does not allow \"%s\" property.", *(_QWORD *)(a2 + 48));
      return 1LL;
    }
    v19 = (_DWORD *)(a1 + 156);
    v18 = (_DWORD *)(a1 + 152);
  }
  s1 = (char *)lyxml_get_attr(a2, "value", 0LL);
  if ( s1 )
  {
    while ( (*__ctype_b_loc())[*s1] & 0x2000 )
      ++s1;
    if ( v12 && !strcmp(s1, "unbounded") )
    {
      v16 = 0LL;
      v13[4] = 0;
      *((_BYTE *)v13 + 8) = 1;
      v17 = v19;
    }
    else
    {
      *__errno_location() = 0;
      endptr = 0LL;
      v16 = strtoul(s1, &endptr, 10);
      if ( *endptr || *s1 == 45 || *__errno_location() || v16 > 0xFFFFFFFF )
      {
        sub_13937(v20, 10, 0, 0LL, (__int64)s1, *(_QWORD *)(a2 + 48));
        return 1LL;
      }
      if ( v12 )
      {
        v13[4] = v16;
        *((_BYTE *)v13 + 8) = 1;
        v17 = v19;
      }
      else
      {
        v13[3] = v16;
        *((_BYTE *)v13 + 7) = 1;
        v17 = v18;
      }
    }
    if ( *v13 == 1 && *v17 )
    {
      sub_13937(v20, 5, 0, 0LL, *(_QWORD *)(a2 + 48), v7);
      sub_13937(v20, -1, 0, 0LL, (__int64)"Adding property that already exists.", v8);
    }
    else
    {
      *v17 = v16;
      if ( !*v19 || *v18 <= *v19 )
        return 0LL;
      if ( v12 )
      {
        sub_13937(v20, 10, 0, 0LL, (__int64)s1, (__int64)"max-elements");
        sub_13937(v20, -1, 0, 0LL, (__int64)"\"max-elements\" is smaller than \"min-elements\".", v9);
      }
      else
      {
        sub_13937(v20, 10, 0, 0LL, (__int64)s1, (__int64)"min-elements");
        sub_13937(v20, -1, 0, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v10);
      }
    }
  }
  else
  {
    sub_13937(v20, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(a2 + 48));
  }
  return 1LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (0000000000049735) ----------------------------------------------------
signed __int64 __fastcall sub_49735(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // r9
  __int64 v6; // r9
  char v7; // al
  __int64 v8; // r9
  __int64 v9; // r9
  _BOOL4 v10; // eax
  __int64 v11; // r9
  __int64 v12; // rax
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  const char *v16; // rax
  __int64 v17; // rax
  signed int v18; // eax
  __int64 v19; // r9
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // r9
  __int64 v23; // r9
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9
  __int64 v27; // r9
  __int16 v28; // ax
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // r9
  __int64 v34; // r9
  __int64 v35; // rax
  __int64 v36; // r9
  __int64 v37; // r9
  __int64 v38; // rax
  __int64 v39; // r9
  __int64 v40; // rax
  __int64 v41; // r9
  char v42; // al
  unsigned int v43; // eax
  __int64 v44; // r9
  __int16 v45; // ax
  __int64 v46; // r9
  __int64 v47; // r9
  void *v48; // rax
  __int64 v49; // r9
  const char *v50; // rax
  __int64 v51; // r9
  void *v52; // rax
  __int64 v53; // r9
  void *v54; // rax
  __int64 v55; // r9
  __int64 v56; // r9
  __int64 v57; // r9
  __int64 v58; // r9
  __int64 v59; // rbx
  __int64 v60; // rax
  __int64 v61; // r9
  __int64 v62; // rax
  int v63; // eax
  __int64 v64; // rdi
  unsigned __int8 v65; // al
  __int64 v66; // r9
  __int64 v67; // r9
  __int16 v68; // ax
  __int16 v69; // ax
  __int64 v70; // rax
  __int64 v71; // rax
  __int64 v72; // r9
  __int64 v73; // rdi
  unsigned __int8 v74; // al
  __int16 v75; // ax
  char v76; // al
  char v77; // al
  __int64 v79; // [rsp+0h] [rbp-160h]
  __int64 v80; // [rsp+8h] [rbp-158h]
  __int64 *v81; // [rsp+18h] [rbp-148h]
  int v82; // [rsp+28h] [rbp-138h]
  int v83; // [rsp+2Ch] [rbp-134h]
  int v84; // [rsp+30h] [rbp-130h]
  signed int v85; // [rsp+34h] [rbp-12Ch]
  int v86; // [rsp+38h] [rbp-128h]
  int v87; // [rsp+38h] [rbp-128h]
  signed int v88; // [rsp+3Ch] [rbp-124h]
  signed int v89; // [rsp+40h] [rbp-120h]
  signed int k; // [rsp+44h] [rbp-11Ch]
  signed int n; // [rsp+44h] [rbp-11Ch]
  signed int ii; // [rsp+44h] [rbp-11Ch]
  signed int jj; // [rsp+44h] [rbp-11Ch]
  signed int i1; // [rsp+44h] [rbp-11Ch]
  signed int i2; // [rsp+44h] [rbp-11Ch]
  int v96; // [rsp+44h] [rbp-11Ch]
  char m; // [rsp+48h] [rbp-118h]
  int v98; // [rsp+48h] [rbp-118h]
  signed int kk; // [rsp+48h] [rbp-118h]
  signed int ll; // [rsp+48h] [rbp-118h]
  int v101; // [rsp+48h] [rbp-118h]
  char mm; // [rsp+48h] [rbp-118h]
  int v103; // [rsp+48h] [rbp-118h]
  char nn; // [rsp+48h] [rbp-118h]
  int v105; // [rsp+48h] [rbp-118h]
  int v106; // [rsp+48h] [rbp-118h]
  signed int v107; // [rsp+48h] [rbp-118h]
  signed int i4; // [rsp+48h] [rbp-118h]
  signed int v109; // [rsp+4Ch] [rbp-114h]
  int v110; // [rsp+50h] [rbp-110h]
  unsigned int v111; // [rsp+54h] [rbp-10Ch]
  unsigned int i3; // [rsp+54h] [rbp-10Ch]
  __int64 v113; // [rsp+58h] [rbp-108h]
  __int64 v114; // [rsp+60h] [rbp-100h]
  char *s1; // [rsp+68h] [rbp-F8h]
  __int64 *v116; // [rsp+70h] [rbp-F0h]
  _QWORD *v117; // [rsp+78h] [rbp-E8h]
  _QWORD *v118; // [rsp+80h] [rbp-E0h]
  _QWORD *i; // [rsp+88h] [rbp-D8h]
  _QWORD *j; // [rsp+90h] [rbp-D0h]
  __int64 l; // [rsp+98h] [rbp-C8h]
  __int64 v122; // [rsp+A0h] [rbp-C0h]
  void *v123; // [rsp+A8h] [rbp-B8h]
  _BYTE *v124; // [rsp+B0h] [rbp-B0h]
  void **v125; // [rsp+B8h] [rbp-A8h]
  __int64 v126; // [rsp+C0h] [rbp-A0h]
  _DWORD *v127; // [rsp+C8h] [rbp-98h]
  __int64 v128; // [rsp+D0h] [rbp-90h]
  __int64 v129; // [rsp+D8h] [rbp-88h]
  __int64 v130; // [rsp+E0h] [rbp-80h]
  __int64 v131; // [rsp+E8h] [rbp-78h]
  __int64 v132; // [rsp+F0h] [rbp-70h]
  __int64 v133; // [rsp+F8h] [rbp-68h]
  void *v134; // [rsp+100h] [rbp-60h]
  __int64 v135; // [rsp+108h] [rbp-58h]
  _DWORD *v136; // [rsp+110h] [rbp-50h]
  void *v137; // [rsp+118h] [rbp-48h]
  char s; // [rsp+120h] [rbp-40h]
  int v139; // [rsp+140h] [rbp-20h]
  unsigned __int64 v140; // [rsp+148h] [rbp-18h]

  v81 = a1;
  v80 = a3;
  v79 = a4;
  v140 = __readfsqword(0x28u);
  v82 = 0;
  v86 = 0;
  v127 = (_DWORD *)*a1;
  v128 = 0LL;
  v129 = 0LL;
  v130 = 0LL;
  v131 = 0LL;
  v132 = ly_set_new(a1);
  v122 = 0LL;
  v133 = 0LL;
  v123 = 0LL;
  v124 = 0LL;
  v125 = 0LL;
  s1 = (char *)lyxml_get_attr(a2, "target-node", 0LL);
  if ( !s1 )
  {
    sub_13937(v127, 13, 0, 0LL, (__int64)"target-node", *(_QWORD *)(a2 + 48), v79);
    goto LABEL_455;
  }
  *(_QWORD *)v80 = sub_9BED(a1, s1);
  if ( !*(_QWORD *)v80 )
  {
LABEL_455:
    ly_set_free(v132);
    return 1LL;
  }
  if ( (unsigned int)sub_1A193(*(char **)v80, 0LL, (__int64)a1, &v114, 0, 1) == -1 )
  {
    sub_13937(v127, 10, 0, 0LL, *(_QWORD *)v80, *(_QWORD *)(a2 + 48), v79);
    ly_set_free(v114);
    goto LABEL_455;
  }
  v129 = **(_QWORD **)(v114 + 8);
  ly_set_free(v114);
  v4 = *(_QWORD *)(v129 + 48);
  if ( v4 == lys_main_module(a1) )
  {
    sub_13937(v127, 10, 0, 0LL, *(_QWORD *)v80, *(_QWORD *)(a2 + 48), v79);
    sub_13937(v127, -1, 0, 0LL, (__int64)"Deviating own module is not allowed.", v5);
    goto LABEL_455;
  }
  for ( i = *(_QWORD **)(a2 + 24); ; i = v117 )
  {
    if ( i )
    {
      v117 = (_QWORD *)i[4];
      v7 = 1;
    }
    else
    {
      v7 = 0;
    }
    if ( !v7 )
      break;
    if ( !i[7] )
    {
      lyxml_free(v127, i);
      continue;
    }
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "description") )
      {
        if ( *(_QWORD *)(v80 + 8) )
        {
          sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
          goto LABEL_455;
        }
        if ( (unsigned int)sub_411CA(a1, v80, 0xDu, i, 6, 0LL, v79) )
          goto LABEL_455;
        *(_QWORD *)(v80 + 8) = sub_410A7(v127, (__int64)i, "text");
        if ( !*(_QWORD *)(v80 + 8) )
          goto LABEL_455;
LABEL_32:
        lyxml_free(v127, i);
        continue;
      }
      if ( !strcmp((const char *)i[6], "reference") )
      {
        if ( *(_QWORD *)(v80 + 16) )
        {
          sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
          goto LABEL_455;
        }
        if ( (unsigned int)sub_411CA(a1, v80, 0xDu, i, 15, 0LL, v79) )
          goto LABEL_455;
        *(_QWORD *)(v80 + 16) = sub_410A7(v127, (__int64)i, "text");
        if ( !*(_QWORD *)(v80 + 16) )
          goto LABEL_455;
        goto LABEL_32;
      }
      if ( strcmp((const char *)i[6], "deviate") )
      {
        sub_13937(v127, 5, 0, 0LL, i[6], v6, v79);
        goto LABEL_455;
      }
      if ( v82 == 255 )
      {
        sub_12222(
          (__int64)v127,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"deviates",
          "deviation");
        goto LABEL_455;
      }
      ++v82;
    }
    else
    {
      if ( v86 == 255 )
      {
        sub_12222(
          (__int64)v127,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "deviation");
        goto LABEL_455;
      }
      ++v86;
    }
  }
  if ( !v82 )
  {
    sub_13937(v127, 12, 0, 0LL, (__int64)"deviate", (__int64)"deviation", v79);
    goto LABEL_455;
  }
  *(_QWORD *)(v80 + 40) = calloc(v82, 0x48uLL);
  if ( !*(_QWORD *)(v80 + 40) )
  {
    sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v8, v79);
    goto LABEL_455;
  }
  if ( v86 )
  {
    v134 = realloc(*(void **)(v80 + 48), 8LL * (*(unsigned __int8 *)(v80 + 33) + v86));
    if ( !v134 )
    {
      sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v9, v79);
      goto LABEL_455;
    }
    *(_QWORD *)(v80 + 48) = v134;
    memset((void *)(*(_QWORD *)(v80 + 48) + 8LL * *(unsigned __int8 *)(v80 + 33)), 0, 8LL * v86);
  }
  for ( j = *(_QWORD **)(a2 + 24); ; j = v117 )
  {
    if ( j )
    {
      v117 = (_QWORD *)j[4];
      v77 = 1;
    }
    else
    {
      v77 = 0;
    }
    if ( !v77 )
      break;
    if ( !strcmp(*(const char **)(j[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      v88 = 0;
      v89 = 0;
      v83 = 0;
      v84 = 0;
      v85 = 0;
      v87 = 0;
      s1 = (char *)lyxml_get_attr(j, "value", 0LL);
      if ( !s1 )
      {
        sub_13937(v127, 13, 0, 0LL, (__int64)"value", j[6], v79);
        goto LABEL_455;
      }
      if ( !strcmp(s1, "not-supported") )
      {
        *(_DWORD *)(*(_QWORD *)(v80 + 40) + 72LL * *(unsigned __int8 *)(v80 + 32)) = 0;
        if ( *(_BYTE *)(v80 + 32) || j[4] )
        {
          sub_13937(v127, 10, 0, 0LL, (__int64)s1, j[6], v79);
          sub_13937(
            v127,
            -1,
            0,
            0LL,
            (__int64)"\"not-supported\" deviation cannot be combined with any other deviation.",
            v11);
          goto LABEL_455;
        }
        if ( *(_DWORD *)(v129 + 56) == 4 && lys_parent(v129) && *(_DWORD *)(lys_parent(v129) + 56) == 16 )
        {
          for ( k = 0; k < *(unsigned __int8 *)(lys_parent(v129) + 30); ++k )
          {
            v12 = lys_parent(v129);
            if ( v129 == *(_QWORD *)(8LL * k + *(_QWORD *)(v12 + 136)) )
            {
              sub_13937(v127, 10, 0, 0LL, (__int64)s1, j[6], v79);
              sub_13937(v127, -1, 0, 0LL, (__int64)"\"not-supported\" deviation cannot remove a list key.", v13);
              goto LABEL_455;
            }
          }
        }
        l = *(_QWORD *)(v129 + 64);
        sub_9BBAC(v129);
        if ( l )
        {
          if ( *(_DWORD *)(l + 56) & 0x3000 )
          {
            *(_QWORD *)(v129 + 64) = l;
          }
          else if ( *(_DWORD *)(l + 56) & 0x4100 )
          {
            v136 = calloc(1uLL, 0x78uLL);
            if ( !v136 )
            {
              sub_12222(
                (__int64)v127,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"fill_yin_deviation",
                v15,
                v79);
              goto LABEL_455;
            }
            v136[14] = *(_DWORD *)(v129 + 56);
            if ( v136[14] == 512 )
              v16 = "input";
            else
              v16 = "output";
            v17 = lydict_insert(v127, v16, 0LL);
            *(_QWORD *)v136 = v17;
            *((_QWORD *)v136 + 6) = *(_QWORD *)(v129 + 48);
            *((_WORD *)v136 + 12) = 64;
            if ( !*(_QWORD *)(l + 72)
              || *(_QWORD *)(*(_QWORD *)(l + 72) + 80LL)
              || (v136[14] != 512 ? (v18 = 512) : (v18 = 1024), v18 != *(_DWORD *)(*(_QWORD *)(l + 72) + 56LL)) )
            {
              __assert_fail(
                "parent->child && !parent->child->next && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS"
                "_OUTPUT : LYS_INPUT))",
                "/home/mantovan/Repositories/libyang/src/parser_yin.c",
                0x93Bu,
                "fill_yin_deviation");
            }
            *(_QWORD *)(*(_QWORD *)(l + 72) + 80LL) = v136;
            *((_QWORD *)v136 + 11) = *(_QWORD *)(l + 72);
            *(_QWORD *)(*(_QWORD *)(l + 72) + 88LL) = v136;
            *((_QWORD *)v136 + 8) = l;
          }
        }
        *(_QWORD *)(v80 + 24) = v129;
      }
      else if ( !strcmp(s1, "add") )
      {
        *(_DWORD *)(*(_QWORD *)(v80 + 40) + 72LL * *(unsigned __int8 *)(v80 + 32)) = 1;
      }
      else if ( !strcmp(s1, "replace") )
      {
        *(_DWORD *)(*(_QWORD *)(v80 + 40) + 72LL * *(unsigned __int8 *)(v80 + 32)) = 2;
      }
      else
      {
        if ( strcmp(s1, "delete") )
        {
          sub_13937(v127, 10, 0, 0LL, (__int64)s1, j[6], v79);
          goto LABEL_455;
        }
        *(_DWORD *)(*(_QWORD *)(v80 + 40) + 72LL * *(unsigned __int8 *)(v80 + 32)) = 3;
      }
      v128 = *(_QWORD *)(v80 + 40) + 72LL * (unsigned __int8)(*(_BYTE *)(v80 + 32))++;
      if ( !*(_QWORD *)(v80 + 24) )
      {
        memset(&s, 0, 0x28uLL);
        *(_QWORD *)(v80 + 24) = sub_A60D4(*(__int64 **)(v129 + 48), 0LL, v129, (__int64)&s, 1u);
        if ( v139 )
        {
          sub_12222(
            (__int64)v127,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser_yin.c",
            2391LL,
            v79);
          goto LABEL_455;
        }
      }
      for ( i = (_QWORD *)j[3]; ; i = v118 )
      {
        if ( i )
        {
          v118 = (_QWORD *)i[4];
          v42 = 1;
        }
        else
        {
          v42 = 0;
        }
        if ( !v42 )
          break;
        if ( i[7] )
        {
          if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
          {
            if ( !*(_DWORD *)v128 )
            {
              sub_13937(v127, 5, 0, 0LL, i[6], v14, v79);
              goto LABEL_455;
            }
            if ( !strcmp((const char *)i[6], "config") )
            {
              if ( *(_BYTE *)(v128 + 4) & 3 )
              {
                sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
                goto LABEL_455;
              }
              s1 = (char *)lyxml_get_attr(i, "value", 0LL);
              if ( !s1 )
              {
                sub_13937(v127, 13, 0, 0LL, (__int64)"value", i[6], v79);
                goto LABEL_455;
              }
              if ( !strcmp(s1, "false") )
              {
                *(_BYTE *)(v128 + 4) |= 2u;
              }
              else
              {
                if ( strcmp(s1, "true") )
                {
                  sub_13937(v127, 10, 0, 0LL, (__int64)s1, i[6], v79);
                  goto LABEL_455;
                }
                *(_BYTE *)(v128 + 4) |= 1u;
              }
              if ( *(_DWORD *)v128 == 3 )
              {
                sub_13937(v127, 6, 0, 0LL, (__int64)"config", (__int64)"deviate delete", v79);
                goto LABEL_455;
              }
              *(_WORD *)(v129 + 24) &= 0xFFFCu;
              *(_WORD *)(v129 + 24) |= *(_BYTE *)(v128 + 4) & 3;
              if ( (unsigned int)sub_411CA(v81, v128, 0xEu, i, 23, 0LL, v79) )
                goto LABEL_455;
            }
            else if ( !strcmp((const char *)i[6], "default") )
            {
              if ( (unsigned int)sub_411CA(v81, v128, 0xEu, i, 5, (unsigned __int8)v85, v79) )
                goto LABEL_455;
              if ( v85 == 255 )
              {
                sub_12222(
                  (__int64)v127,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"defaults",
                  "deviate");
                goto LABEL_455;
              }
              ++v85;
              if ( ((*((_BYTE *)v81 + 64) >> 1) & 7u) <= 1 && *(_DWORD *)(v129 + 56) == 8 )
              {
                sub_13937(v127, 5, 0, 0LL, (__int64)"default", v14, v79);
                sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"default\" property.", v19);
                goto LABEL_455;
              }
              if ( v85 > 1 && *(_DWORD *)(v129 + 56) != 8 )
              {
                sub_13937(v127, 5, 0, 0LL, (__int64)"default", v14, v79);
                sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow multiple \"default\" properties.", v20);
                goto LABEL_455;
              }
              if ( v85 == 1 && !(*(_DWORD *)(v129 + 56) & 0xE) )
              {
                sub_13937(v127, 5, 0, 0LL, (__int64)"default", v14, v79);
                sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"default\" property.", v21);
                goto LABEL_455;
              }
            }
            else if ( !strcmp((const char *)i[6], "mandatory") )
            {
              if ( *(_BYTE *)(v128 + 4) & 0xC0 )
              {
                sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
                goto LABEL_455;
              }
              if ( !(*(_DWORD *)(v129 + 56) & 0x8026) )
              {
                sub_13937(v127, 5, 0, 0LL, i[6], v22, v79);
                sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"%s\" property.", i[6]);
                goto LABEL_455;
              }
              s1 = (char *)lyxml_get_attr(i, "value", 0LL);
              if ( !s1 )
              {
                sub_13937(v127, 13, 0, 0LL, (__int64)"value", i[6], v79);
                goto LABEL_455;
              }
              if ( !strcmp(s1, "false") )
              {
                *(_BYTE *)(v128 + 4) |= 0x80u;
              }
              else
              {
                if ( strcmp(s1, "true") )
                {
                  sub_13937(v127, 10, 0, 0LL, (__int64)s1, i[6], v79);
                  goto LABEL_455;
                }
                *(_BYTE *)(v128 + 4) |= 0x40u;
              }
              switch ( *(_DWORD *)v128 )
              {
                case 1:
                  if ( *(_WORD *)(v129 + 24) & 0xC0 )
                  {
                    sub_13937(v127, 5, 0, 0LL, i[6], v23, v79);
                    sub_13937(v127, -1, 0, 0LL, (__int64)"Adding property that already exists.", v24);
                    goto LABEL_455;
                  }
                  if ( *(_BYTE *)(v128 + 4) & 0x40 )
                  {
                    if ( *(_DWORD *)(v129 + 56) == 2 )
                    {
                      if ( *(_QWORD *)(v129 + 112) )
                      {
                        sub_13937(v127, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v79);
                        sub_13937(
                          v127,
                          -1,
                          0,
                          0LL,
                          (__int64)"Adding the \"mandatory\" statement is forbidden on choice with the \"default\" statement.",
                          v25);
                        goto LABEL_455;
                      }
                    }
                    else if ( *(_DWORD *)(v129 + 56) == 4 && *(_QWORD *)(v129 + 200) )
                    {
                      sub_13937(v127, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v79);
                      sub_13937(
                        v127,
                        -1,
                        0,
                        0LL,
                        (__int64)"Adding the \"mandatory\" statement is forbidden on leaf with the \"default\" statement.",
                        v26);
                      goto LABEL_455;
                    }
                  }
                  *(_WORD *)(v129 + 24) |= (unsigned __int8)(*(_BYTE *)(v128 + 4) & 0xC0);
                  break;
                case 2:
                  if ( !(*(_WORD *)(v129 + 24) & 0xC0) )
                  {
                    sub_13937(v127, 5, 0, 0LL, i[6], v23, v79);
                    sub_13937(v127, -1, 0, 0LL, (__int64)"Replacing a property that does not exist.", v27);
                    goto LABEL_455;
                  }
                  v28 = *(_WORD *)(v129 + 24);
                  LOBYTE(v28) = v28 & 0x3F;
                  *(_WORD *)(v129 + 24) = v28;
                  *(_WORD *)(v129 + 24) |= (unsigned __int8)(*(_BYTE *)(v128 + 4) & 0xC0);
                  break;
                case 3:
                  sub_13937(v127, 6, 0, 0LL, (__int64)"mandatory", (__int64)"deviate delete", v79);
                  goto LABEL_455;
              }
              for ( l = *(_QWORD *)(v129 + 64);
                    l && !(*(_DWORD *)(l + 56) & 0x4802) && (*(_DWORD *)(l + 56) != 1 || !*(_QWORD *)(l + 136));
                    l = *(_QWORD *)(l + 64) )
              {
                ;
              }
              if ( l && *(_DWORD *)(l + 56) == 2 && *(_QWORD *)(l + 112) && (unsigned int)sub_3C679(l)
                || (unsigned int)sub_411CA(v81, v128, 0xEu, i, 24, 0LL, v79) )
              {
                goto LABEL_455;
              }
            }
            else if ( !strcmp((const char *)i[6], "min-elements") )
            {
              if ( v88 )
              {
                sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
                goto LABEL_455;
              }
              v88 = 1;
              if ( (unsigned int)sub_492EA(v129, (__int64)i, (_DWORD *)v128, 0, v29, v30)
                || (unsigned int)sub_411CA(v81, v128, 0xEu, i, 29, 0LL, v79) )
              {
                goto LABEL_455;
              }
            }
            else if ( !strcmp((const char *)i[6], "max-elements") )
            {
              if ( v89 )
              {
                sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
                goto LABEL_455;
              }
              v89 = 1;
              if ( (unsigned int)sub_492EA(v129, (__int64)i, (_DWORD *)v128, 1, v31, v32)
                || (unsigned int)sub_411CA(v81, v128, 0xEu, i, 28, 0LL, v79) )
              {
                goto LABEL_455;
              }
            }
            else if ( !strcmp((const char *)i[6], "must") )
            {
              if ( v83 == 255 )
              {
                sub_12222(
                  (__int64)v127,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"musts",
                  "deviate");
                goto LABEL_455;
              }
              ++v83;
            }
            else if ( !strcmp((const char *)i[6], "type") )
            {
              if ( *(_QWORD *)(v128 + 40) )
              {
                sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
                goto LABEL_455;
              }
              if ( *(_DWORD *)v128 == 1 )
              {
                sub_13937(v127, 6, 0, 0LL, (__int64)"type", (__int64)"deviate add", v79);
                goto LABEL_455;
              }
              if ( *(_DWORD *)v128 == 3 )
              {
                sub_13937(v127, 6, 0, 0LL, (__int64)"type", (__int64)"deviate delete", v79);
                goto LABEL_455;
              }
              if ( *(_DWORD *)(v129 + 56) == 4 )
              {
                v123 = (void *)(v129 + 128);
                if ( *(_QWORD *)(v129 + 200) )
                  ly_set_add(v132, v129, 0LL);
              }
              else
              {
                if ( *(_DWORD *)(v129 + 56) != 8 )
                {
                  sub_13937(v127, 5, 0, 0LL, i[6], v33, v79);
                  sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"%s\" property.", i[6]);
                  goto LABEL_455;
                }
                v123 = (void *)(v129 + 128);
                if ( *(_QWORD *)(v129 + 200) )
                  ly_set_add(v132, v129, 0LL);
              }
              sub_A1648((__int64)v127, (__int64)v123, 0LL);
              memset(v123, 0, 0x40uLL);
              *((_QWORD *)v123 + 2) = i;
              *((_QWORD *)v123 + 3) = v129;
              if ( (unsigned int)sub_2ABDE(v81, v79, (__int64 *)v123, 4u, (__int64 *)v129) == -1 )
                goto LABEL_455;
              *(_QWORD *)(v128 + 40) = v123;
            }
            else if ( !strcmp((const char *)i[6], "unique") )
            {
              if ( (unsigned int)sub_411CA(v81, v128, 0xEu, i, 31, (unsigned __int8)v84, v79) )
                goto LABEL_455;
              if ( v84 == 255 )
              {
                sub_12222(
                  (__int64)v127,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"uniques",
                  "deviate");
                goto LABEL_455;
              }
              ++v84;
            }
            else
            {
              if ( strcmp((const char *)i[6], "units") )
              {
                sub_13937(v127, 5, 0, 0LL, i[6], v34, v79);
                goto LABEL_455;
              }
              if ( *(_QWORD *)(v128 + 48) )
              {
                sub_13937(v127, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v79);
                goto LABEL_455;
              }
              if ( *(_DWORD *)(v129 + 56) == 8 )
              {
                v116 = (__int64 *)(v129 + 192);
              }
              else
              {
                if ( *(_DWORD *)(v129 + 56) != 4 )
                {
                  sub_13937(v127, 5, 0, 0LL, i[6], v34, v79);
                  sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"%s\" property.", i[6]);
                  goto LABEL_455;
                }
                v116 = (__int64 *)(v129 + 192);
              }
              s1 = (char *)lyxml_get_attr(i, "name", 0LL);
              if ( !s1 )
              {
                sub_13937(v127, 13, 0, 0LL, (__int64)"name", i[6], v79);
                goto LABEL_455;
              }
              v35 = lydict_insert(v127, s1, 0LL);
              *(_QWORD *)(v128 + 48) = v35;
              switch ( *(_DWORD *)v128 )
              {
                case 1:
                  if ( *v116 )
                  {
                    sub_13937(v127, 5, 0, 0LL, i[6], v36, v79);
                    sub_13937(v127, -1, 0, 0LL, (__int64)"Adding property that already exists.", v37);
                    goto LABEL_455;
                  }
                  v38 = lydict_insert(v127, s1, 0LL);
                  *v116 = v38;
                  break;
                case 2:
                  if ( !*v116 )
                  {
                    sub_13937(v127, 5, 0, 0LL, i[6], v36, v79);
                    sub_13937(v127, -1, 0, 0LL, (__int64)"Replacing a property that does not exist.", v39);
                    goto LABEL_455;
                  }
                  lydict_remove(v127, *v116);
                  v40 = lydict_insert(v127, s1, 0LL);
                  *v116 = v40;
                  break;
                case 3:
                  if ( *v116 != *(_QWORD *)(v128 + 48) )
                  {
                    sub_13937(v127, 10, 0, 0LL, (__int64)s1, i[6], v79);
                    sub_13937(v127, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v41);
                    goto LABEL_455;
                  }
                  lydict_remove(v127, *v116);
                  *v116 = 0LL;
                  for ( m = -1; ; m = v98 - 1 )
                  {
                    v98 = sub_9EAFC(*(_QWORD *)(v129 + 32), *(_BYTE *)(v129 + 26), m + 1, 17);
                    if ( v98 == -1 )
                      break;
                    sub_3DD01((__int64)v127, (void **)(v129 + 32), (unsigned __int8 *)(v129 + 26), v98);
                  }
                  break;
              }
              if ( (unsigned int)sub_411CA(v81, v128, 0xEu, i, 17, 0LL, v79) )
                goto LABEL_455;
            }
          }
          else
          {
            if ( v87 == 255 )
            {
              sub_12222(
                (__int64)v127,
                0,
                4,
                "Reached limit (%lu) for storing %s in %s statement.",
                255LL,
                (__int64)"extensions",
                "deviate");
              goto LABEL_455;
            }
            ++v87;
          }
        }
        else
        {
          lyxml_free(v127, i);
        }
      }
      if ( v83 )
      {
        v43 = *(_DWORD *)(v129 + 56);
        if ( v43 == 8 )
        {
          v125 = (void **)(v129 + 120);
          v124 = (_BYTE *)(v129 + 31);
        }
        else if ( v43 > 8 )
        {
          if ( v43 == 32 || v43 == 32800 )
          {
            v125 = (void **)(v129 + 120);
            v124 = (_BYTE *)(v129 + 31);
          }
          else
          {
            if ( v43 != 16 )
            {
LABEL_253:
              sub_13937(v127, 5, 0, 0LL, (__int64)"must", v14, v79);
              sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"must\" property.", v44);
              goto LABEL_455;
            }
            v125 = (void **)(v129 + 120);
            v124 = (_BYTE *)(v129 + 28);
          }
        }
        else if ( v43 == 1 )
        {
          v125 = (void **)(v129 + 120);
          v124 = (_BYTE *)(v129 + 29);
        }
        else
        {
          if ( v43 != 4 )
            goto LABEL_253;
          v125 = (void **)(v129 + 120);
          v124 = (_BYTE *)(v129 + 31);
        }
        v45 = *(_WORD *)(v129 + 24);
        HIBYTE(v45) &= 0xF9u;
        *(_WORD *)(v129 + 24) = v45;
        if ( *(_DWORD *)v128 == 2 )
        {
          sub_13937(v127, 6, 0, 0LL, (__int64)"must", (__int64)"deviate replace", v79);
          goto LABEL_455;
        }
        if ( *(_DWORD *)v128 == 1 )
        {
          v137 = sub_C422(*v125, 56LL * ((unsigned __int8)*v124 + v83));
          if ( !v137 )
          {
            sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v46, v79);
            goto LABEL_455;
          }
          *v125 = v137;
          *(_QWORD *)(v128 + 24) = calloc(v83, 0x38uLL);
          *(_BYTE *)(v128 + 9) = v83;
        }
        else
        {
          *(_QWORD *)(v128 + 24) = calloc(v83, 0x38uLL);
        }
        if ( !*(_QWORD *)(v128 + 24) )
        {
          sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v14, v79);
          goto LABEL_455;
        }
      }
      if ( v84 )
      {
        if ( *(_DWORD *)v128 == 2 )
        {
          sub_13937(v127, 6, 0, 0LL, (__int64)"unique", (__int64)"deviate replace", v79);
          goto LABEL_455;
        }
        if ( *(_DWORD *)(v129 + 56) != 16 )
        {
          sub_13937(v127, 5, 0, 0LL, (__int64)"unique", v14, v79);
          sub_13937(v127, -1, 0, 0LL, (__int64)"Target node does not allow \"unique\" property.", v47);
          goto LABEL_455;
        }
        v122 = v129;
        if ( *(_DWORD *)v128 == 1 )
        {
          v48 = sub_C422(*(void **)(v122 + 144), 16LL * (*(unsigned __int8 *)(v122 + 31) + v84));
          *(_QWORD *)(v128 + 32) = v48;
          if ( !*(_QWORD *)(v128 + 32) )
          {
            sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v14, v79);
            goto LABEL_455;
          }
          *(_QWORD *)(v122 + 144) = *(_QWORD *)(v128 + 32);
          *(_QWORD *)(v128 + 32) = 16LL * *(unsigned __int8 *)(v122 + 31) + *(_QWORD *)(v122 + 144);
          *(_BYTE *)(v128 + 10) = v84;
        }
        else
        {
          *(_QWORD *)(v128 + 32) = calloc(v84, 0x10uLL);
          if ( !*(_QWORD *)(v128 + 32) )
          {
            sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v14, v79);
            goto LABEL_455;
          }
        }
      }
      if ( v85 )
      {
        if ( *(_DWORD *)v128 == 1 )
        {
          if ( *(_DWORD *)(v129 + 56) == 4 && *(_QWORD *)(v129 + 200)
            || *(_DWORD *)(v129 + 56) == 2 && *(_QWORD *)(v129 + 112) )
          {
            sub_13937(v127, 5, 0, 0LL, (__int64)"default", v14, v79);
            sub_13937(v127, -1, 0, 0LL, (__int64)"Adding property that already exists.", v49);
            goto LABEL_455;
          }
          if ( *(_WORD *)(v129 + 24) & 0x40 || *(_DWORD *)(v129 + 56) == 8 && *(_DWORD *)(v129 + 208) )
          {
            sub_13937(v127, 6, 0, 0LL, (__int64)"default", (__int64)"deviation", v79);
            if ( *(_WORD *)(v129 + 24) & 0x40 )
              v50 = "nodes with the \"mandatory\"";
            else
              v50 = "leaflists with non-zero \"min-elements\"";
            sub_13937(
              v127,
              -1,
              0,
              0LL,
              (__int64)"Adding the \"default\" statement is forbidden on %s statement.",
              (__int64)v50);
            goto LABEL_455;
          }
        }
        else if ( *(_DWORD *)v128 == 2
               && (*(_DWORD *)(v129 + 56) & 0xC && !*(_QWORD *)(v129 + 200)
                || *(_DWORD *)(v129 + 56) == 2 && !*(_QWORD *)(v129 + 112)) )
        {
          sub_13937(v127, 5, 0, 0LL, (__int64)"default", v14, v79);
          sub_13937(v127, -1, 0, 0LL, (__int64)"Replacing a property that does not exist.", v51);
          goto LABEL_455;
        }
        if ( *(_DWORD *)(v129 + 56) == 8 )
        {
          v133 = v129;
          if ( *(_DWORD *)v128 == 1 )
          {
            v52 = sub_C422(*(void **)(v133 + 200), 8LL * (*(unsigned __int8 *)(v133 + 30) + v85));
            *(_QWORD *)(v133 + 200) = v52;
            if ( !*(_QWORD *)(v133 + 200) )
            {
              sub_12222(
                (__int64)v127,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"fill_yin_deviation",
                v53,
                v79);
              goto LABEL_455;
            }
          }
          else if ( *(_DWORD *)v128 == 2 )
          {
            for ( n = 0; n < *(unsigned __int8 *)(v133 + 30); ++n )
              lydict_remove(v127, *(_QWORD *)(8LL * n + *(_QWORD *)(v133 + 200)));
            v54 = sub_C422(*(void **)(v133 + 200), 8LL * v85);
            *(_QWORD *)(v133 + 200) = v54;
            *(_BYTE *)(v133 + 30) = 0;
            if ( !*(_QWORD *)(v133 + 200) )
            {
              sub_12222(
                (__int64)v127,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"fill_yin_deviation",
                v55,
                v79);
              goto LABEL_455;
            }
          }
        }
        *(_QWORD *)(v128 + 56) = calloc(v85, 8uLL);
        if ( !*(_QWORD *)(v128 + 56) )
        {
          sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v56, v79);
          goto LABEL_455;
        }
      }
      if ( v87 )
      {
        v134 = realloc(*(void **)(v128 + 64), 8LL * (*(unsigned __int8 *)(v128 + 6) + v87));
        if ( !v134 )
        {
          sub_12222((__int64)v127, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_deviation", v57, v79);
          goto LABEL_455;
        }
        *(_QWORD *)(v128 + 64) = v134;
        memset((void *)(*(_QWORD *)(v128 + 64) + 8LL * *(unsigned __int8 *)(v128 + 6)), 0, 8LL * v87);
      }
      v126 = 0LL;
      for ( i = (_QWORD *)j[3]; ; i = v118 )
      {
        if ( i )
        {
          v118 = (_QWORD *)i[4];
          v76 = 1;
        }
        else
        {
          v76 = 0;
        }
        if ( !v76 )
          break;
        if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
        {
          if ( !strcmp((const char *)i[6], "must") )
          {
            if ( *(_DWORD *)v128 == 3 )
            {
              if ( (unsigned int)sub_489FC(
                                   v81,
                                   (__int64)i,
                                   (__int64 *)(*(_QWORD *)(v128 + 24) + 56LL * *(unsigned __int8 *)(v128 + 9)),
                                   v79) )
                goto LABEL_455;
              for ( ii = 0; ii < (unsigned __int8)*v124; ++ii )
              {
                if ( *(_QWORD *)(*(_QWORD *)(v128 + 24) + 56LL * *(unsigned __int8 *)(v128 + 9)) == *((_QWORD *)*v125 + 7 * ii) )
                {
                  sub_9F606((__int64)v127, (__int64)*v125 + 56 * ii, 0LL);
                  if ( ii != (unsigned __int8)--*v124 )
                  {
                    *((_QWORD *)*v125 + 7 * ii) = *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124);
                    *((_QWORD *)*v125 + 7 * ii + 1) = *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 1);
                    *((_QWORD *)*v125 + 7 * ii + 2) = *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 2);
                    *((_QWORD *)*v125 + 7 * ii + 3) = *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 3);
                    *((_QWORD *)*v125 + 7 * ii + 4) = *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 4);
                  }
                  if ( *v124 )
                  {
                    *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124) = 0LL;
                    *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 1) = 0LL;
                    *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 2) = 0LL;
                    *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 3) = 0LL;
                    *((_QWORD *)*v125 + 7 * (unsigned __int8)*v124 + 4) = 0LL;
                  }
                  else
                  {
                    free(*v125);
                    *v125 = 0LL;
                  }
                  ii = -1;
                  break;
                }
              }
              ++*(_BYTE *)(v128 + 9);
              if ( ii != -1 )
              {
                sub_13937(
                  v127,
                  10,
                  0,
                  0LL,
                  *(_QWORD *)(*(_QWORD *)(v128 + 24) + 56LL * *(unsigned __int8 *)(v128 + 9) - 56),
                  i[6],
                  v79);
                sub_13937(v127, -1, 0, 0LL, (__int64)"Value does not match any must from the target.", v58);
                goto LABEL_455;
              }
            }
            else
            {
              memset((char *)*v125 + 56 * (unsigned __int8)*v124, 0, 0x38uLL);
              if ( (unsigned int)sub_489FC(v81, (__int64)i, (__int64 *)*v125 + 7 * (unsigned __int8)*v124, v79) )
                goto LABEL_455;
              memcpy(
                (void *)(*(_QWORD *)(v128 + 24) + 56 * v126++),
                (char *)*v125 + 56 * (unsigned __int8)*v124,
                0x38uLL);
              ++*v124;
            }
            if ( *v124 && !(v127[23] & 2) && (unsigned int)sub_2ABDE(v81, v79, (__int64 *)v129, 0x20000u, 0LL) == -1 )
              goto LABEL_455;
          }
          else if ( !strcmp((const char *)i[6], "unique") )
          {
            if ( *(_DWORD *)v128 == 3 )
            {
              memset((void *)(*(_QWORD *)(v128 + 32) + 16LL * *(unsigned __int8 *)(v128 + 10)), 0, 0x10uLL);
              if ( (unsigned int)sub_48E4C(
                                   v81,
                                   v129,
                                   (__int64)i,
                                   *(_QWORD *)(v128 + 32) + 16LL * *(unsigned __int8 *)(v128 + 10),
                                   0LL) )
              {
                ++*(_BYTE *)(v128 + 10);
                goto LABEL_455;
              }
              for ( jj = 0; jj < *(unsigned __int8 *)(v122 + 31); ++jj )
              {
                if ( *(_BYTE *)(16LL * jj + *(_QWORD *)(v122 + 144) + 8) == *(_BYTE *)(*(_QWORD *)(v128 + 32)
                                                                                     + 16LL
                                                                                     * *(unsigned __int8 *)(v128 + 10)
                                                                                     + 8) )
                {
                  for ( kk = 0;
                        kk < *(unsigned __int8 *)(*(_QWORD *)(v128 + 32) + 16LL * *(unsigned __int8 *)(v128 + 10) + 8)
                     && *(_QWORD *)(8LL * kk + *(_QWORD *)(16LL * jj + *(_QWORD *)(v122 + 144))) == *(_QWORD *)(8LL * kk + *(_QWORD *)(*(_QWORD *)(v128 + 32) + 16LL * *(unsigned __int8 *)(v128 + 10)));
                        ++kk )
                  {
                    ;
                  }
                  if ( kk == *(unsigned __int8 *)(*(_QWORD *)(v128 + 32) + 16LL * *(unsigned __int8 *)(v128 + 10) + 8) )
                  {
                    for ( ll = 0; ll < *(unsigned __int8 *)(16LL * jj + *(_QWORD *)(v122 + 144) + 8); ++ll )
                      lydict_remove(v127, *(_QWORD *)(8LL * ll + *(_QWORD *)(16LL * jj + *(_QWORD *)(v122 + 144))));
                    free(*(void **)(16LL * jj + *(_QWORD *)(v122 + 144)));
                    if ( jj != (unsigned __int8)--*(_BYTE *)(v122 + 31) )
                    {
                      *(_BYTE *)(*(_QWORD *)(v122 + 144) + 16LL * jj + 8) = *(_BYTE *)(*(_QWORD *)(v122 + 144)
                                                                                     + 16LL
                                                                                     * *(unsigned __int8 *)(v122 + 31)
                                                                                     + 8);
                      *(_QWORD *)(*(_QWORD *)(v122 + 144) + 16LL * jj) = *(_QWORD *)(*(_QWORD *)(v122 + 144)
                                                                                   + 16LL
                                                                                   * *(unsigned __int8 *)(v122 + 31));
                    }
                    if ( *(_BYTE *)(v122 + 31) )
                    {
                      *(_BYTE *)(*(_QWORD *)(v122 + 144) + 16LL * *(unsigned __int8 *)(v122 + 31) + 8) = 0;
                      *(_QWORD *)(*(_QWORD *)(v122 + 144) + 16LL * *(unsigned __int8 *)(v122 + 31)) = 0LL;
                    }
                    else
                    {
                      free(*(void **)(v122 + 144));
                      *(_QWORD *)(v122 + 144) = 0LL;
                    }
                    v109 = jj;
                    jj = -1;
                    break;
                  }
                }
              }
              ++*(_BYTE *)(v128 + 10);
              if ( jj != -1 )
              {
                v59 = i[6];
                v60 = lyxml_get_attr(i, "tag", 0LL);
                sub_13937(v127, 10, 0, 0LL, v60, v59, v79);
                sub_13937(v127, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v61);
                goto LABEL_455;
              }
              LOBYTE(v101) = -1;
              while ( 1 )
              {
                v101 = sub_9EAFC(*(_QWORD *)(v129 + 32), *(_BYTE *)(v129 + 26), (unsigned __int8)v101 + 1, 31);
                if ( v101 == -1 )
                  break;
                if ( v109 == *(unsigned __int8 *)(*(_QWORD *)(8LL * v101 + *(_QWORD *)(v129 + 32)) + 27LL) )
                {
                  sub_3DD01((__int64)v127, (void **)(v129 + 32), (unsigned __int8 *)(v129 + 26), v101);
                  LOBYTE(v101) = v101 - 1;
                }
                else if ( v109 < *(unsigned __int8 *)(*(_QWORD *)(8LL * v101 + *(_QWORD *)(v129 + 32)) + 27LL) )
                {
                  v62 = *(_QWORD *)(8LL * v101 + *(_QWORD *)(v129 + 32));
                  --*(_BYTE *)(v62 + 27);
                }
              }
            }
            else
            {
              memset((void *)(*(_QWORD *)(v122 + 144) + 16LL * *(unsigned __int8 *)(v122 + 31)), 0, 0x10uLL);
              v63 = sub_48E4C(
                      v81,
                      v129,
                      (__int64)i,
                      *(_QWORD *)(v122 + 144) + 16LL * *(unsigned __int8 *)(v122 + 31),
                      0LL);
              ++*(_BYTE *)(v122 + 31);
              if ( v63 )
                goto LABEL_455;
            }
          }
          else if ( !strcmp((const char *)i[6], "default") )
          {
            s1 = (char *)lyxml_get_attr(i, "value", 0LL);
            if ( !s1 )
            {
              sub_13937(v127, 13, 0, 0LL, (__int64)"value", i[6], v79);
              goto LABEL_455;
            }
            v111 = strlen(s1);
            v64 = *(_QWORD *)(v128 + 56);
            v65 = *(_BYTE *)(v128 + 5);
            *(_BYTE *)(v128 + 5) = v65 + 1;
            *(_QWORD *)(v64 + 8LL * v65) = lydict_insert(v127, s1, v111);
            if ( *(_DWORD *)(v129 + 56) == 2 )
            {
              v130 = v129;
              if ( (unsigned int)sub_1B236(s1, *(_QWORD *)(v129 + 72), &v113) || !v113 )
              {
                sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
                goto LABEL_455;
              }
              if ( *(_DWORD *)v128 == 3 )
              {
                if ( !*(_QWORD *)(v130 + 112) || *(_QWORD *)(v130 + 112) != v113 )
                {
                  sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
                  sub_13937(v127, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v66);
                  goto LABEL_455;
                }
                *(_QWORD *)(v130 + 112) = 0LL;
                for ( mm = -1; ; mm = v103 - 1 )
                {
                  v103 = sub_9EAFC(*(_QWORD *)(v129 + 32), *(_BYTE *)(v129 + 26), mm + 1, 5);
                  if ( v103 == -1 )
                    break;
                  sub_3DD01((__int64)v127, (void **)(v129 + 32), (unsigned __int8 *)(v129 + 26), v103);
                }
              }
              else
              {
                *(_QWORD *)(v130 + 112) = v113;
                if ( !*(_QWORD *)(v130 + 112) )
                {
                  sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
                  goto LABEL_455;
                }
              }
            }
            else if ( *(_DWORD *)(v129 + 56) == 4 )
            {
              v131 = v129;
              if ( *(_DWORD *)v128 == 3 )
              {
                if ( !*(_QWORD *)(v131 + 200) || s1 != *(char **)(v131 + 200) )
                {
                  sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
                  sub_13937(v127, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v67);
                  goto LABEL_455;
                }
                lydict_remove(v127, *(_QWORD *)(v131 + 200));
                *(_QWORD *)(v131 + 200) = 0LL;
                v68 = *(_WORD *)(v131 + 24);
                HIBYTE(v68) &= 0xEFu;
                *(_WORD *)(v131 + 24) = v68;
                for ( nn = -1; ; nn = v105 - 1 )
                {
                  v105 = sub_9EAFC(*(_QWORD *)(v129 + 32), *(_BYTE *)(v129 + 26), nn + 1, 5);
                  if ( v105 == -1 )
                    break;
                  sub_3DD01((__int64)v127, (void **)(v129 + 32), (unsigned __int8 *)(v129 + 26), v105);
                }
              }
              else
              {
                lydict_remove(v127, *(_QWORD *)(v131 + 200));
                v69 = *(_WORD *)(v131 + 24);
                HIBYTE(v69) &= 0xEFu;
                *(_WORD *)(v131 + 24) = v69;
                v70 = lydict_insert(v127, s1, v111);
                *(_QWORD *)(v131 + 200) = v70;
                ly_set_add(v132, v129, 0LL);
              }
            }
            else
            {
              v133 = v129;
              if ( *(_DWORD *)v128 == 3 )
              {
                for ( i1 = 0; i1 < *(unsigned __int8 *)(v133 + 30); ++i1 )
                {
                  if ( *(_QWORD *)(8LL * i1 + *(_QWORD *)(v133 + 200))
                    && s1 == *(char **)(8LL * i1 + *(_QWORD *)(v133 + 200)) )
                  {
                    lydict_remove(v127, *(_QWORD *)(8LL * i1 + *(_QWORD *)(v133 + 200)));
                    *(_QWORD *)(8LL * i1 + *(_QWORD *)(v133 + 200)) = 0LL;
                    LOBYTE(v106) = -1;
                    while ( 1 )
                    {
                      v106 = sub_9EAFC(*(_QWORD *)(v129 + 32), *(_BYTE *)(v129 + 26), (unsigned __int8)v106 + 1, 5);
                      if ( v106 == -1 )
                        break;
                      if ( i1 == *(unsigned __int8 *)(*(_QWORD *)(8LL * v106 + *(_QWORD *)(v129 + 32)) + 27LL) )
                      {
                        sub_3DD01((__int64)v127, (void **)(v129 + 32), (unsigned __int8 *)(v129 + 26), v106);
                        LOBYTE(v106) = v106 - 1;
                      }
                      else if ( i1 < *(unsigned __int8 *)(*(_QWORD *)(8LL * v106 + *(_QWORD *)(v129 + 32)) + 27LL) )
                      {
                        v71 = *(_QWORD *)(8LL * v106 + *(_QWORD *)(v129 + 32));
                        --*(_BYTE *)(v71 + 27);
                      }
                    }
                    break;
                  }
                }
                if ( i1 == *(unsigned __int8 *)(v133 + 30) )
                {
                  sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
                  sub_13937(v127, -1, 0, 0LL, (__int64)"The default value to delete not found in the target node.", v72);
                  goto LABEL_455;
                }
              }
              else
              {
                for ( i2 = 0; i2 < *(unsigned __int8 *)(v133 + 30); ++i2 )
                {
                  if ( s1 == *(char **)(8LL * i2 + *(_QWORD *)(v133 + 200)) )
                  {
                    sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
                    sub_13937(v127, -1, 0, 0LL, (__int64)"Duplicated default value \"%s\".", (__int64)s1);
                    goto LABEL_455;
                  }
                }
                v73 = *(_QWORD *)(v133 + 200);
                v74 = *(_BYTE *)(v133 + 30);
                *(_BYTE *)(v133 + 30) = v74 + 1;
                *(_QWORD *)(v73 + 8LL * v74) = lydict_insert(v127, s1, v111);
                ly_set_add(v132, v129, 0LL);
                v75 = *(_WORD *)(v133 + 24);
                HIBYTE(v75) &= 0xEFu;
                *(_WORD *)(v133 + 24) = v75;
              }
            }
          }
        }
        else
        {
          if ( (unsigned int)sub_40F96(
                               v128,
                               14,
                               0,
                               0,
                               v81,
                               (__int64)i,
                               (__int64 *)(v128 + 64),
                               *(_BYTE *)(v128 + 6),
                               v79) )
            goto LABEL_455;
          ++*(_BYTE *)(v128 + 6);
        }
      }
      if ( v85 && *(_DWORD *)(v129 + 56) == 8 && *(_DWORD *)v128 == 3 )
      {
        v133 = v129;
        v107 = 0;
        v96 = 0;
        while ( v107 < *(unsigned __int8 *)(v133 + 30) )
        {
          *(_QWORD *)(*(_QWORD *)(v133 + 200) + 8LL * v96) = *(_QWORD *)(*(_QWORD *)(v133 + 200) + 8LL * v107);
          if ( *(_QWORD *)(8LL * v96 + *(_QWORD *)(v133 + 200)) )
            ++v96;
          ++v107;
        }
        *(_BYTE *)(v133 + 30) = v96 + 1;
      }
    }
    else
    {
      v10 = sub_40F96(v80, 13, 0, 0, v81, (__int64)j, (__int64 *)(v80 + 48), *(_BYTE *)(v80 + 33), v79);
      ++*(_BYTE *)(v80 + 33);
      if ( v10 )
        goto LABEL_455;
    }
  }
  if ( !(v127[23] & 2) )
  {
    for ( i3 = 0; i3 < *(_DWORD *)(v132 + 4); ++i3 )
    {
      s1 = 0LL;
      v110 = 0;
      if ( *(_DWORD *)(*(_QWORD *)(8LL * i3 + *(_QWORD *)(v132 + 8)) + 56LL) == 4 )
      {
        v131 = *(_QWORD *)(8LL * i3 + *(_QWORD *)(v132 + 8));
        s1 = *(char **)(v131 + 200);
        v110 = sub_2ABDE(v81, v79, (__int64 *)(v131 + 128), 0x1000u, (__int64 *)(v131 + 200));
      }
      else
      {
        v133 = *(_QWORD *)(8LL * i3 + *(_QWORD *)(v132 + 8));
        for ( i4 = 0; i4 < *(unsigned __int8 *)(v133 + 30); ++i4 )
        {
          v110 = sub_2ABDE(v81, v79, (__int64 *)(v133 + 128), 0x1000u, (__int64 *)(*(_QWORD *)(v133 + 200) + 8LL * i4));
          if ( v110 == -1 )
          {
            s1 = *(char **)(8LL * i4 + *(_QWORD *)(v133 + 200));
            break;
          }
        }
      }
      if ( v110 == -1 )
      {
        sub_13937(v127, 10, 0, 0LL, (__int64)s1, (__int64)"default", v79);
        sub_13937(
          v127,
          -1,
          0,
          0LL,
          (__int64)"The default value \"%s\" of the deviated node \"%s\" no longer matches its type.",
          *(_QWORD *)v80);
        goto LABEL_455;
      }
    }
  }
  for ( l = v129; l; l = lys_parent(l) )
  {
    v135 = lys_node_module(l);
    if ( v81 != (__int64 *)v135 )
    {
      *(_BYTE *)(v135 + 64) = *(_BYTE *)(v135 + 64) & 0xCF | 0x10;
      *(_BYTE *)(*(_QWORD *)(l + 48) + 64LL) = *(_BYTE *)(*(_QWORD *)(l + 48) + 64LL) & 0xCF | 0x10;
      if ( *(_BYTE *)(v135 + 64) >= 0 )
      {
        *(_BYTE *)(v135 + 64) |= 0x80u;
        if ( (unsigned int)sub_2ABDE((__int64 *)v135, v79, 0LL, 0x8000u, 0LL) == -1 )
          goto LABEL_455;
      }
    }
  }
  ly_set_free(v132);
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000004E308) ----------------------------------------------------
signed __int64 __fastcall sub_4E308(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // r9
  char v7; // al
  __int64 v8; // r9
  __int64 v9; // r9
  _BOOL4 v10; // eax
  int v11; // eax
  char v12; // al
  __int64 v14; // [rsp+0h] [rbp-70h]
  unsigned int v15; // [rsp+Ch] [rbp-64h]
  __int64 v16; // [rsp+10h] [rbp-60h]
  __int64 v17; // [rsp+18h] [rbp-58h]
  int v18; // [rsp+34h] [rbp-3Ch]
  int v19; // [rsp+38h] [rbp-38h]
  _QWORD *i; // [rsp+40h] [rbp-30h]
  __int64 j; // [rsp+40h] [rbp-30h]
  _QWORD *v22; // [rsp+48h] [rbp-28h]
  __int64 v23; // [rsp+50h] [rbp-20h]
  _DWORD *v24; // [rsp+58h] [rbp-18h]
  const char *v25; // [rsp+60h] [rbp-10h]
  void *v26; // [rsp+68h] [rbp-8h]

  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v24 = (_DWORD *)*a1;
  v18 = 0;
  v19 = 0;
  *(_DWORD *)(a4 + 56) = 0x2000;
  v25 = (const char *)lyxml_get_attr(a3, "target-node", 0LL);
  if ( v25 )
  {
    *(_QWORD *)v16 = sub_9BED(a1, v25);
    if ( !*(_QWORD *)v16 )
      return 1LL;
    *(_QWORD *)(v16 + 64) = a2;
    if ( (unsigned int)sub_51597(a1, 0LL, v16, 1u, v17, 16, v14) )
      return 1LL;
    for ( i = *(_QWORD **)(v17 + 24); ; i = v22 )
    {
      if ( i )
      {
        v22 = (_QWORD *)i[4];
        v7 = 1;
      }
      else
      {
        v7 = 0;
      }
      if ( !v7 )
        break;
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "if-feature") )
        {
          if ( v18 == 255 )
          {
            sub_12222(
              (__int64)v24,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"if-features",
              "augment");
            return 1LL;
          }
          ++v18;
        }
        else if ( !strcmp((const char *)i[6], "when") )
        {
          if ( *(_QWORD *)(v16 + 80) )
          {
            sub_13937(v24, 14, 0, 0LL, i[6], *(_QWORD *)(v17 + 48), v14);
            return 1LL;
          }
          *(_QWORD *)(v16 + 80) = sub_51F02(a1, (__int64)i, v14);
          if ( !*(_QWORD *)(v16 + 80) )
          {
            lyxml_free(v24, i);
            return 1LL;
          }
          lyxml_free(v24, i);
        }
        else
        {
          if ( !strcmp((const char *)i[6], "container") )
          {
            v23 = (__int64)sub_587B3(a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "leaf-list") )
          {
            v23 = sub_551D2((__int64)a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "leaf") )
          {
            v23 = (__int64)sub_54422(a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "list") )
          {
            v23 = (__int64)sub_56721(a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "uses") )
          {
            v23 = (__int64)sub_5CBDA(a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "choice") )
          {
            v23 = (__int64)sub_52E00((__int64)a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "case") )
          {
            v23 = (__int64)sub_522BA(a1, (char *)v16, (__int64)i, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "anyxml") )
          {
            v23 = (__int64)sub_53A72(a1, (char *)v16, (__int64)i, 32, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "anydata") )
          {
            v23 = (__int64)sub_53A72(a1, (char *)v16, (__int64)i, 32800, v15, v14);
          }
          else if ( !strcmp((const char *)i[6], "action") )
          {
            v23 = (__int64)sub_5C028((__int64)a1, (char *)v16, (__int64)i, v15, v14);
          }
          else
          {
            if ( strcmp((const char *)i[6], "notification") )
            {
              sub_13937(v24, 5, 0, 0LL, i[6], v6, v14);
              return 1LL;
            }
            v23 = (__int64)sub_5B1D8((__int64)a1, (char *)v16, (__int64)i, v15, v14, v6);
          }
          if ( !v23 )
            return 1LL;
          lyxml_free(v24, i);
        }
      }
      else
      {
        if ( v19 == 255 )
        {
          sub_12222(
            (__int64)v24,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            "augment");
          return 1LL;
        }
        ++v19;
      }
    }
    if ( !v18 || (*(_QWORD *)(v16 + 40) = calloc(v18, 0x20uLL)) != 0LL )
    {
      if ( v19 )
      {
        v26 = realloc(*(void **)(v16 + 32), 8LL * (*(unsigned __int8 *)(v16 + 26) + v19));
        if ( !v26 )
        {
          sub_12222((__int64)v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_augment", v9, v14);
          return 1LL;
        }
        *(_QWORD *)(v16 + 32) = v26;
        memset((void *)(*(_QWORD *)(v16 + 32) + 8LL * *(unsigned __int8 *)(v16 + 26)), 0, 8LL * v19);
      }
      for ( j = *(_QWORD *)(v17 + 24); ; j = (__int64)v22 )
      {
        if ( j )
        {
          v22 = *(_QWORD **)(j + 32);
          v12 = 1;
        }
        else
        {
          v12 = 0;
        }
        if ( !v12 )
          break;
        if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
        {
          if ( !strcmp(*(const char **)(j + 48), "if-feature") )
          {
            v11 = sub_41746(v16, 0, j, *(_QWORD *)(v16 + 40) + 32LL * *(unsigned __int8 *)(v16 + 27), v14);
            ++*(_BYTE *)(v16 + 27);
            if ( v11 )
              return 1LL;
            lyxml_free(v24, j);
          }
        }
        else
        {
          v10 = sub_40F96(v16, 1, 0, 0, a1, j, (__int64 *)(v16 + 32), *(_BYTE *)(v16 + 26), v14);
          ++*(_BYTE *)(v16 + 26);
          if ( v10 )
            return 1LL;
        }
      }
      if ( !a2 && (unsigned int)sub_2ABDE(a1, v14, (__int64 *)v16, 0x40u, 0LL) == -1 )
        return 1LL;
      if ( !(v24[23] & 2) && *(_QWORD *)(v16 + 80) )
      {
        if ( v15 & 4 )
        {
          if ( (unsigned int)sub_DDEA9(v16) )
            return 1LL;
        }
        else if ( (unsigned int)sub_2ABDE(a1, v14, (__int64 *)v16, 0x20000u, 0LL) == -1 )
        {
          return 1LL;
        }
      }
      return 0LL;
    }
    sub_12222((__int64)v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_augment", v8, v14);
  }
  else
  {
    sub_13937(v24, 13, 0, 0LL, (__int64)"target-node", *(_QWORD *)(v17 + 48), v14);
  }
  return 1LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);

//----- (000000000004EC3D) ----------------------------------------------------
signed __int64 __fastcall sub_4EC3D(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // r9
  __int16 v6; // ax
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  size_t v10; // rax
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // r9
  __int64 v17; // r9
  __int64 v18; // r9
  _BOOL4 v19; // eax
  int v20; // eax
  int v21; // eax
  size_t v22; // rdi
  __int64 v23; // rsi
  unsigned __int8 v24; // al
  char v25; // al
  __int64 v27; // [rsp+0h] [rbp-A0h]
  __int64 v28; // [rsp+8h] [rbp-98h]
  __int64 v29; // [rsp+18h] [rbp-88h]
  signed int v30; // [rsp+28h] [rbp-78h]
  signed int v31; // [rsp+2Ch] [rbp-74h]
  signed int v32; // [rsp+30h] [rbp-70h]
  int v33; // [rsp+34h] [rbp-6Ch]
  int v34; // [rsp+38h] [rbp-68h]
  int v35; // [rsp+3Ch] [rbp-64h]
  int v36; // [rsp+40h] [rbp-60h]
  signed int j; // [rsp+44h] [rbp-5Ch]
  char *endptr; // [rsp+48h] [rbp-58h]
  _QWORD *i; // [rsp+50h] [rbp-50h]
  _QWORD *v40; // [rsp+58h] [rbp-48h]
  char *s1; // [rsp+60h] [rbp-40h]
  void *v42; // [rsp+68h] [rbp-38h]
  __int64 v43; // [rsp+70h] [rbp-30h]
  void *v44; // [rsp+78h] [rbp-28h]
  unsigned __int64 v45; // [rsp+80h] [rbp-20h]
  unsigned __int64 v46; // [rsp+88h] [rbp-18h]

  v29 = a1;
  v28 = a3;
  v27 = a4;
  v46 = __readfsqword(0x28u);
  v42 = **(void ***)(a1 + 48);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  if ( !a1 )
    __assert_fail("uses", "/home/mantovan/Repositories/libyang/src/parser_yin.c", 0xCFFu, "fill_yin_refine");
  v43 = *(_QWORD *)(a1 + 48);
  s1 = (char *)lyxml_get_attr(a2, "target-node", 0LL);
  if ( !s1 )
  {
    sub_13937(v42, 13, 0, 0LL, (__int64)"target-node", *(_QWORD *)(a2 + 48), v27);
    return 1LL;
  }
  *(_QWORD *)v28 = sub_9BED((__int64 *)v43, s1);
  if ( !*(_QWORD *)v28 )
    return 1LL;
  for ( i = *(_QWORD **)(a2 + 24); ; i = v40 )
  {
    if ( i )
    {
      v40 = (_QWORD *)i[4];
      v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    if ( !v14 )
      break;
    if ( !i[7] )
      goto LABEL_139;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "description") )
      {
        if ( *(_QWORD *)(v28 + 8) )
        {
          sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
          return 1LL;
        }
        if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 6, 0LL, v27) )
          return 1LL;
        *(_QWORD *)(v28 + 8) = sub_410A7(v42, (__int64)i, "text");
        if ( !*(_QWORD *)(v28 + 8) )
          return 1LL;
LABEL_139:
        lyxml_free(v42, i);
        continue;
      }
      if ( !strcmp((const char *)i[6], "reference") )
      {
        if ( *(_QWORD *)(v28 + 16) )
        {
          sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
          return 1LL;
        }
        if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 15, 0LL, v27) )
          return 1LL;
        *(_QWORD *)(v28 + 16) = sub_410A7(v42, (__int64)i, "text");
        if ( !*(_QWORD *)(v28 + 16) )
          return 1LL;
        goto LABEL_139;
      }
      if ( !strcmp((const char *)i[6], "config") )
      {
        if ( *(_WORD *)(v28 + 24) & 3 )
        {
          sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
          return 1LL;
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937(v42, 13, 0, 0LL, (__int64)"value", i[6], v27);
          return 1LL;
        }
        if ( !strcmp(s1, "false") )
        {
          *(_WORD *)(v28 + 24) |= 2u;
        }
        else
        {
          if ( strcmp(s1, "true") )
          {
            sub_13937(v42, 10, 0, 0LL, (__int64)s1, i[6], v27);
            return 1LL;
          }
          *(_WORD *)(v28 + 24) |= 1u;
        }
        *(_WORD *)(v28 + 24) |= 4u;
        if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 23, 0LL, v27) )
          return 1LL;
        goto LABEL_139;
      }
      if ( !strcmp((const char *)i[6], "default") )
      {
        if ( *(_WORD *)(v28 + 28) )
        {
          if ( v35 )
          {
            if ( ((*(_BYTE *)(v43 + 64) >> 1) & 7u) <= 1 )
            {
              sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              return 1LL;
            }
            *(_WORD *)(v28 + 28) &= 8u;
          }
          else if ( ((*(_BYTE *)(v43 + 64) >> 1) & 7u) > 1 )
          {
            *(_WORD *)(v28 + 28) &= 0xEu;
          }
          else
          {
            *(_WORD *)(v28 + 28) &= 6u;
          }
          if ( !*(_WORD *)(v28 + 28) )
          {
            sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
            sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v4);
            return 1LL;
          }
        }
        else if ( ((*(_BYTE *)(v43 + 64) >> 1) & 7u) > 1 )
        {
          *(_WORD *)(v28 + 28) = 14;
        }
        else
        {
          *(_WORD *)(v28 + 28) = 6;
        }
        if ( v35 == 255 )
        {
          sub_12222(
            (__int64)v42,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"defaults",
            "refine");
          return 1LL;
        }
        if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 5, (unsigned __int8)v35, v27) )
          return 1LL;
        ++v35;
      }
      else
      {
        if ( !strcmp((const char *)i[6], "mandatory") )
        {
          if ( v30 )
          {
            sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
            return 1LL;
          }
          v30 = 1;
          if ( *(_WORD *)(v28 + 28) )
          {
            *(_WORD *)(v28 + 28) &= 0x8026u;
            if ( !*(_WORD *)(v28 + 28) )
            {
              sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v5);
              return 1LL;
            }
          }
          else
          {
            *(_WORD *)(v28 + 28) = -32730;
          }
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937(v42, 13, 0, 0LL, (__int64)"value", i[6], v27);
            return 1LL;
          }
          if ( !strcmp(s1, "true") )
          {
            *(_WORD *)(v28 + 24) |= 0x40u;
          }
          else
          {
            if ( strcmp(s1, "false") )
            {
              sub_13937(v42, 10, 0, 0LL, (__int64)s1, i[6], v27);
              return 1LL;
            }
            v6 = *(_WORD *)(v28 + 24);
            LOBYTE(v6) = v6 | 0x80;
            *(_WORD *)(v28 + 24) = v6;
          }
          if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 24, 0LL, v27) )
            return 1LL;
          goto LABEL_139;
        }
        if ( !strcmp((const char *)i[6], "min-elements") )
        {
          if ( v31 )
          {
            sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
            return 1LL;
          }
          v31 = 1;
          if ( *(_WORD *)(v28 + 28) )
          {
            *(_WORD *)(v28 + 28) &= 0x18u;
            if ( !*(_WORD *)(v28 + 28) )
            {
              sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v7);
              return 1LL;
            }
          }
          else
          {
            *(_WORD *)(v28 + 28) = 24;
          }
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937(v42, 13, 0, 0LL, (__int64)"value", i[6], v27);
            return 1LL;
          }
          while ( (*__ctype_b_loc())[*s1] & 0x2000 )
            ++s1;
          *__errno_location() = 0;
          endptr = 0LL;
          v45 = strtoul(s1, &endptr, 10);
          if ( *endptr || *s1 == 45 || *__errno_location() || v45 > 0xFFFFFFFF )
          {
            sub_13937(v42, 10, 0, 0LL, (__int64)s1, i[6], v27);
            return 1LL;
          }
          *(_DWORD *)(v28 + 72) = v45;
          *(_WORD *)(v28 + 24) |= 0x10u;
          if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 29, 0LL, v27) )
            return 1LL;
          goto LABEL_139;
        }
        if ( !strcmp((const char *)i[6], "max-elements") )
        {
          if ( v32 )
          {
            sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
            return 1LL;
          }
          v32 = 1;
          if ( *(_WORD *)(v28 + 28) )
          {
            *(_WORD *)(v28 + 28) &= 0x18u;
            if ( !*(_WORD *)(v28 + 28) )
            {
              sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v8);
              return 1LL;
            }
          }
          else
          {
            *(_WORD *)(v28 + 28) = 24;
          }
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937(v42, 13, 0, 0LL, (__int64)"value", i[6], v27);
            return 1LL;
          }
          while ( (*__ctype_b_loc())[*s1] & 0x2000 )
            ++s1;
          if ( !strcmp(s1, "unbounded") )
          {
            *(_DWORD *)(v28 + 76) = 0;
          }
          else
          {
            *__errno_location() = 0;
            endptr = 0LL;
            v45 = strtoul(s1, &endptr, 10);
            if ( *endptr || *s1 == 45 || *__errno_location() || !v45 || v45 > 0xFFFFFFFF )
            {
              sub_13937(v42, 10, 0, 0LL, (__int64)s1, i[6], v27);
              return 1LL;
            }
            *(_DWORD *)(v28 + 76) = v45;
          }
          *(_WORD *)(v28 + 24) |= 8u;
          if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 28, 0LL, v27) )
            return 1LL;
          goto LABEL_139;
        }
        if ( !strcmp((const char *)i[6], "presence") )
        {
          if ( *(_QWORD *)(v28 + 72) )
          {
            sub_13937(v42, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
            return 1LL;
          }
          if ( *(_WORD *)(v28 + 28) )
          {
            *(_WORD *)(v28 + 28) &= 1u;
            if ( !*(_WORD *)(v28 + 28) )
            {
              sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v9);
              return 1LL;
            }
          }
          else
          {
            *(_WORD *)(v28 + 28) = 1;
          }
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937(v42, 13, 0, 0LL, (__int64)"value", i[6], v27);
            return 1LL;
          }
          v10 = strlen(s1);
          *(_QWORD *)(v28 + 72) = lydict_insert(v42, s1, v10);
          if ( (unsigned int)sub_411CA((__int64 *)v43, v28, 0xCu, i, 14, 0LL, v27) )
            return 1LL;
          goto LABEL_139;
        }
        if ( !strcmp((const char *)i[6], "must") )
        {
          if ( *(_WORD *)(v28 + 28) )
          {
            *(_WORD *)(v28 + 28) &= 0x803Du;
            if ( !*(_WORD *)(v28 + 28) )
            {
              sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v12);
              return 1LL;
            }
          }
          else
          {
            *(_WORD *)(v28 + 28) = -32707;
          }
          if ( v33 == 255 )
          {
            sub_12222(
              (__int64)v42,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"musts",
              "refine");
            return 1LL;
          }
          ++v33;
        }
        else
        {
          if ( ((*(_BYTE *)(v43 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)i[6], "if-feature") )
          {
            sub_13937(v42, 5, 0, 0LL, i[6], v11, v27);
            return 1LL;
          }
          if ( *(_WORD *)(v28 + 28) )
          {
            *(_WORD *)(v28 + 28) &= 0x807Fu;
            if ( !*(_WORD *)(v28 + 28) )
            {
              sub_13937(v42, 12, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v27);
              sub_13937(v42, -1, 0, 0LL, (__int64)"Invalid refine target nodetype for the substatements.", v13);
              return 1LL;
            }
          }
          else
          {
            *(_WORD *)(v28 + 28) = -32641;
          }
          if ( v34 == 255 )
          {
            sub_12222(
              (__int64)v42,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"if-feature",
              "refine");
            return 1LL;
          }
          ++v34;
        }
      }
    }
    else
    {
      if ( v36 == 255 )
      {
        sub_12222(
          (__int64)v42,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "refine");
        return 1LL;
      }
      ++v36;
    }
  }
  if ( v33 )
  {
    *(_QWORD *)(v28 + 56) = calloc(v33, 0x38uLL);
    if ( !*(_QWORD *)(v28 + 56) )
    {
      sub_12222((__int64)v42, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_refine", v15, v27);
      return 1LL;
    }
  }
  if ( v34 )
  {
    *(_QWORD *)(v28 + 40) = calloc(v34, 0x20uLL);
    if ( !*(_QWORD *)(v28 + 40) )
    {
      sub_12222((__int64)v42, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_refine", v16, v27);
      return 1LL;
    }
  }
  if ( v35 )
  {
    *(_QWORD *)(v28 + 64) = calloc(v35, 8uLL);
    if ( !*(_QWORD *)(v28 + 64) )
    {
      sub_12222((__int64)v42, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_refine", v17, v27);
      return 1LL;
    }
  }
  if ( v36 )
  {
    v44 = realloc(*(void **)(v28 + 32), 8LL * (*(unsigned __int8 *)(v28 + 26) + v36));
    if ( !v44 )
    {
      sub_12222((__int64)v42, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_refine", v18, v27);
      return 1LL;
    }
    *(_QWORD *)(v28 + 32) = v44;
    memset((void *)(*(_QWORD *)(v28 + 32) + 8LL * *(unsigned __int8 *)(v28 + 26)), 0, 8LL * v36);
  }
  for ( i = *(_QWORD **)(a2 + 24); ; i = v40 )
  {
    if ( i )
    {
      v40 = (_QWORD *)i[4];
      v25 = 1;
    }
    else
    {
      v25 = 0;
    }
    if ( !v25 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "if-feature") )
      {
        v20 = sub_41746(v29, 0, (__int64)i, *(_QWORD *)(v28 + 40) + 32LL * *(unsigned __int8 *)(v28 + 27), v27);
        ++*(_BYTE *)(v28 + 27);
        if ( v20 )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        v21 = sub_489FC(
                (__int64 *)v43,
                (__int64)i,
                (__int64 *)(*(_QWORD *)(v28 + 56) + 56LL * *(unsigned __int8 *)(v28 + 30)),
                v27);
        ++*(_BYTE *)(v28 + 30);
        if ( v21 )
          return 1LL;
      }
      else
      {
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937(v42, 13, 0, 0LL, (__int64)"value", i[6], v27);
          return 1LL;
        }
        for ( j = 0; j < *(unsigned __int8 *)(v28 + 31); ++j )
        {
          if ( s1 == *(char **)(8LL * j + *(_QWORD *)(v28 + 64)) )
          {
            sub_13937(v42, 10, 0, 0LL, (__int64)s1, (__int64)"default", v27);
            sub_13937(v42, -1, 0, 0LL, (__int64)"Duplicated default value \"%s\".", (__int64)s1);
            return 1LL;
          }
        }
        v22 = strlen(s1);
        v23 = *(_QWORD *)(v28 + 64);
        v24 = *(_BYTE *)(v28 + 31);
        *(_BYTE *)(v28 + 31) = v24 + 1;
        *(_QWORD *)(v23 + 8LL * v24) = lydict_insert(v42, s1, v22);
      }
    }
    else
    {
      v19 = sub_40F96(v28, 12, 0, 0, (__int64 *)v43, (__int64)i, (__int64 *)(v28 + 32), *(_BYTE *)(v28 + 26), v27);
      ++*(_BYTE *)(v28 + 26);
      if ( v19 )
        return 1LL;
    }
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000505F3) ----------------------------------------------------
signed __int64 __fastcall sub_505F3(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  size_t v5; // rax
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  char v10; // al
  __int64 v11; // r9
  _BOOL4 v12; // eax
  char v13; // al
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v17; // [rsp+0h] [rbp-A0h]
  __int64 v18; // [rsp+8h] [rbp-98h]
  int v19; // [rsp+20h] [rbp-80h]
  _QWORD *i; // [rsp+28h] [rbp-78h]
  __int64 j; // [rsp+28h] [rbp-78h]
  _QWORD *v22; // [rsp+30h] [rbp-70h]
  void *v23; // [rsp+38h] [rbp-68h]
  void *v24; // [rsp+40h] [rbp-60h]
  char *v25; // [rsp+48h] [rbp-58h]
  char *v26; // [rsp+48h] [rbp-58h]
  char *v27; // [rsp+48h] [rbp-58h]
  char s; // [rsp+50h] [rbp-50h]
  __int64 v29; // [rsp+68h] [rbp-38h]
  unsigned __int64 v30; // [rsp+98h] [rbp-8h]

  v18 = a3;
  v17 = a4;
  v30 = __readfsqword(0x28u);
  v23 = *(void **)a1;
  v19 = 0;
  memset(&s, 0, 0x48uLL);
  for ( i = *(_QWORD **)(a2 + 24); ; i = v22 )
  {
    if ( i )
    {
      v22 = (_QWORD *)i[4];
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    if ( !v10 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "prefix") )
        {
          v25 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !v25 )
          {
            sub_13937(v23, 13, 0, 0LL, (__int64)"value", i[6], v17);
            goto LABEL_62;
          }
          if ( (unsigned int)sub_3B812(v23, v25, 6u, a1, 0LL, v4) )
            goto LABEL_62;
          v5 = strlen(v25);
          *(_QWORD *)(v18 + 8) = lydict_insert(v23, v25, v5);
          if ( (unsigned int)sub_411CA((__int64 *)a1, v18, 0xFu, i, 13, 0LL, v17) )
            goto LABEL_62;
        }
        else if ( !strcmp((const char *)i[6], "revision-date") )
        {
          if ( *(_BYTE *)(v18 + 16) )
          {
            sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v17);
            goto LABEL_62;
          }
          v26 = (char *)lyxml_get_attr(i, "date", 0LL);
          if ( !v26 )
          {
            sub_13937(v23, 13, 0, 0LL, (__int64)"date", i[6], v17);
            goto LABEL_62;
          }
          if ( (unsigned int)sub_3C2C9(v23, v26, (__int64)v26, v7, v8, v9) )
            goto LABEL_62;
          memcpy((void *)(v18 + 16), v26, 0xAuLL);
          if ( (unsigned int)sub_411CA((__int64 *)a1, v18, 0xFu, i, 16, 0LL, v17) )
            goto LABEL_62;
        }
        else if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 && !strcmp((const char *)i[6], "description") )
        {
          if ( *(_QWORD *)(v18 + 40) )
          {
            sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v17);
            goto LABEL_62;
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, v18, 0xFu, i, 6, 0LL, v17) )
            goto LABEL_62;
          *(_QWORD *)(v18 + 40) = sub_410A7(v23, (__int64)i, "text");
          if ( !*(_QWORD *)(v18 + 40) )
            goto LABEL_62;
        }
        else
        {
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)i[6], "reference") )
          {
            sub_13937(v23, 5, 0, 0LL, i[6], v6, v17);
            goto LABEL_62;
          }
          if ( *(_QWORD *)(v18 + 48) )
          {
            sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48), v17);
            goto LABEL_62;
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, v18, 0xFu, i, 15, 0LL, v17) )
            goto LABEL_62;
          *(_QWORD *)(v18 + 48) = sub_410A7(v23, (__int64)i, "text");
          if ( !*(_QWORD *)(v18 + 48) )
            goto LABEL_62;
        }
      }
      else
      {
        if ( v19 == 255 )
        {
          sub_12222(
            (__int64)v23,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            "import");
          goto LABEL_62;
        }
        ++v19;
        sub_30B77((__int64)v23, i, 2);
        sub_3116F((__int64)v23, (__int64)&s, i);
      }
    }
  }
  if ( *(_QWORD *)(v18 + 8) )
  {
    if ( v19 )
    {
      v24 = realloc(*(void **)(v18 + 32), 8LL * (*(unsigned __int8 *)(v18 + 27) + v19));
      if ( !v24 )
      {
        sub_12222((__int64)v23, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_import", v11, v17);
        goto LABEL_62;
      }
      *(_QWORD *)(v18 + 32) = v24;
      memset((void *)(*(_QWORD *)(v18 + 32) + 8LL * *(unsigned __int8 *)(v18 + 27)), 0, 8LL * v19);
      for ( j = v29; ; j = (__int64)v22 )
      {
        if ( j )
        {
          v22 = *(_QWORD **)(j + 32);
          v13 = 1;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
          break;
        v12 = sub_40F96(v18, 15, 0, 0, (__int64 *)a1, j, (__int64 *)(v18 + 32), *(_BYTE *)(v18 + 27), v17);
        ++*(_BYTE *)(v18 + 27);
        if ( v12 )
          goto LABEL_62;
      }
    }
    v27 = (char *)lyxml_get_attr(a2, "module", 0LL);
    if ( v27 )
      return sub_3D76E(a1, v27, v18, (__int64)v27, v14, v15);
    sub_13937(v23, 13, 0, 0LL, (__int64)"module", *(_QWORD *)(a2 + 48), v17);
  }
  else
  {
    sub_13937(v23, 12, 0, 0LL, (__int64)"prefix", *(_QWORD *)(a2 + 48), v17);
  }
LABEL_62:
  while ( v29 )
    lyxml_free(v23, v29);
  return 1LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000050E7D) ----------------------------------------------------
signed __int64 __fastcall sub_50E7D(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  char v9; // al
  __int64 v10; // r9
  _BOOL4 v11; // eax
  char v12; // al
  __int64 *v13; // rax
  __int64 v15; // [rsp+8h] [rbp-A8h]
  __int64 v16; // [rsp+10h] [rbp-A0h]
  __int64 v17; // [rsp+18h] [rbp-98h]
  int v18; // [rsp+30h] [rbp-80h]
  _QWORD *i; // [rsp+38h] [rbp-78h]
  __int64 j; // [rsp+38h] [rbp-78h]
  _QWORD *v21; // [rsp+40h] [rbp-70h]
  void *v22; // [rsp+48h] [rbp-68h]
  void *v23; // [rsp+50h] [rbp-60h]
  const char *src; // [rsp+58h] [rbp-58h]
  void *srca; // [rsp+58h] [rbp-58h]
  char s; // [rsp+60h] [rbp-50h]
  __int64 v27; // [rsp+78h] [rbp-38h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-8h]

  v17 = a3;
  v16 = a4;
  v15 = a5;
  v28 = __readfsqword(0x28u);
  v22 = *(void **)a1;
  v18 = 0;
  memset(&s, 0, 0x48uLL);
  for ( i = *(_QWORD **)(v17 + 24); ; i = v21 )
  {
    if ( i )
    {
      v21 = (_QWORD *)i[4];
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( !v9 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "revision-date") )
        {
          if ( *(_BYTE *)(v16 + 8) )
          {
            sub_13937(v22, 14, 0, 0LL, (__int64)"revision-date", *(_QWORD *)(v17 + 48));
            return 0xFFFFFFFFLL;
          }
          src = (const char *)lyxml_get_attr(i, "date", 0LL);
          if ( !src )
          {
            sub_13937(v22, 13, 0, 0LL, (__int64)"date", i[6]);
            return 0xFFFFFFFFLL;
          }
          if ( (unsigned int)sub_3C2C9(v22, src, (__int64)src, v6, v7, v8) )
            return 0xFFFFFFFFLL;
          memcpy((void *)(v16 + 8), src, 0xAuLL);
          if ( (unsigned int)sub_411CA((__int64 *)a1, v16, 0x10u, i, 16, 0LL, v15) )
            return 0xFFFFFFFFLL;
        }
        else if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 && !strcmp((const char *)i[6], "description") )
        {
          if ( *(_QWORD *)(v16 + 32) )
          {
            sub_13937(v22, 14, 0, 0LL, i[6], *(_QWORD *)(v17 + 48));
            return 0xFFFFFFFFLL;
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, v16, 0x10u, i, 6, 0LL, v15) )
            return 0xFFFFFFFFLL;
          *(_QWORD *)(v16 + 32) = sub_410A7(v22, (__int64)i, "text");
          if ( !*(_QWORD *)(v16 + 32) )
            return 0xFFFFFFFFLL;
        }
        else
        {
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)i[6], "reference") )
          {
            sub_13937(v22, 5, 0, 0LL, i[6], v5);
            return 0xFFFFFFFFLL;
          }
          if ( *(_QWORD *)(v16 + 40) )
          {
            sub_13937(v22, 14, 0, 0LL, i[6], *(_QWORD *)(v17 + 48));
            return 0xFFFFFFFFLL;
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, v16, 0x10u, i, 15, 0LL, v15) )
            return 0xFFFFFFFFLL;
          *(_QWORD *)(v16 + 40) = sub_410A7(v22, (__int64)i, "text");
          if ( !*(_QWORD *)(v16 + 40) )
            return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if ( v18 == 255 )
        {
          sub_12222(
            (__int64)v22,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            "include");
          return 0xFFFFFFFFLL;
        }
        ++v18;
        sub_30B77((__int64)v22, i, 2);
        sub_3116F((__int64)v22, (__int64)&s, i);
      }
    }
  }
  if ( v18 )
  {
    v23 = realloc(*(void **)(v16 + 24), 8LL * (*(unsigned __int8 *)(v16 + 19) + v18));
    if ( !v23 )
    {
      sub_12222((__int64)v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"fill_yin_include", v10);
      return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(v16 + 24) = v23;
    memset((void *)(*(_QWORD *)(v16 + 24) + 8LL * *(unsigned __int8 *)(v16 + 19)), 0, 8LL * v18);
    for ( j = v27; ; j = (__int64)v21 )
    {
      if ( j )
      {
        v21 = *(_QWORD **)(j + 32);
        v12 = 1;
      }
      else
      {
        v12 = 0;
      }
      if ( !v12 )
        break;
      v11 = sub_40F96(v16, 16, 0, 0, (__int64 *)a1, j, (__int64 *)(v16 + 24), *(_BYTE *)(v16 + 19), v15);
      ++*(_BYTE *)(v16 + 19);
      if ( v11 )
        return 0xFFFFFFFFLL;
    }
  }
  srca = (void *)lyxml_get_attr(v17, "module", 0LL);
  if ( !srca )
  {
    sub_13937(v22, 13, 0, 0LL, (__int64)"module", *(_QWORD *)(v17 + 48));
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
    v13 = a2;
  else
    v13 = (__int64 *)a1;
  return sub_3D0D7(v13, (__int64)srca, (_QWORD *)v16, v15);
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (0000000000051597) ----------------------------------------------------
signed __int64 __fastcall sub_51597(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5, char a6, __int64 a7)
{
  __int64 v7; // r9
  size_t v8; // rax
  char v9; // al
  __int64 v10; // ST88_8
  const char *v11; // rax
  int v12; // eax
  const char *v13; // rax
  __int64 v15; // [rsp+8h] [rbp-68h]
  char v16; // [rsp+10h] [rbp-60h]
  unsigned int v17; // [rsp+14h] [rbp-5Ch]
  __int64 v18; // [rsp+18h] [rbp-58h]
  _QWORD *i; // [rsp+38h] [rbp-38h]
  _QWORD *v20; // [rsp+40h] [rbp-30h]
  void *ptr; // [rsp+48h] [rbp-28h]
  __int64 v22; // [rsp+50h] [rbp-20h]
  void *v23; // [rsp+58h] [rbp-18h]
  char *s; // [rsp+60h] [rbp-10h]
  char *sa; // [rsp+60h] [rbp-10h]
  char *sb; // [rsp+60h] [rbp-10h]

  v18 = a3;
  v17 = a4;
  v15 = a5;
  v16 = a6;
  v22 = a3;
  v23 = (void *)*a1;
  if ( a6 & 0x10 )
    *(_QWORD *)(a3 + 48) = a1;
  if ( a6 & 1 )
  {
    s = (char *)lyxml_get_attr(a5, "name", 0LL);
    if ( !s )
    {
      sub_13937(v23, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(v15 + 48));
      return 1LL;
    }
    if ( (unsigned int)sub_3B812(v23, s, 5u, 0LL, 0LL, v7) )
      return 1LL;
    v8 = strlen(s);
    *(_QWORD *)v22 = lydict_insert(v23, s, v8);
  }
  for ( i = *(_QWORD **)(v15 + 24); ; i = v20 )
  {
    if ( i )
    {
      v20 = (_QWORD *)i[4];
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( !v9 )
      break;
    if ( !i[7] )
    {
      lyxml_free(v23, i);
      continue;
    }
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "description") )
      {
        if ( *(_QWORD *)(v22 + 8) )
        {
          sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(v15 + 48));
          return 1LL;
        }
        if ( (unsigned int)sub_411CA(a1, v18, v17, i, 6, 0LL, a7) )
          return 1LL;
        *(_QWORD *)(v22 + 8) = sub_410A7(v23, (__int64)i, "text");
        if ( !*(_QWORD *)(v22 + 8) )
          return 1LL;
LABEL_51:
        lyxml_free(v23, i);
        continue;
      }
      if ( !strcmp((const char *)i[6], "reference") )
      {
        if ( *(_QWORD *)(v22 + 16) )
        {
          sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(v15 + 48));
          return 1LL;
        }
        if ( (unsigned int)sub_411CA(a1, v18, v17, i, 15, 0LL, a7) )
          return 1LL;
        *(_QWORD *)(v22 + 16) = sub_410A7(v23, (__int64)i, "text");
        if ( !*(_QWORD *)(v22 + 16) )
          return 1LL;
        goto LABEL_51;
      }
      if ( !strcmp((const char *)i[6], "status") )
      {
        if ( *(_WORD *)(v22 + 24) & 0x38 )
        {
          sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(v15 + 48));
          return 1LL;
        }
        sa = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !sa )
        {
          sub_13937(v23, 13, 0, 0LL, (__int64)"value", i[6]);
          return 1LL;
        }
        if ( !strcmp(sa, "current") )
        {
          *(_WORD *)(v22 + 24) |= 8u;
        }
        else if ( !strcmp(sa, "deprecated") )
        {
          *(_WORD *)(v22 + 24) |= 0x10u;
        }
        else
        {
          if ( strcmp(sa, "obsolete") )
          {
            sub_13937(v23, 10, 0, 0LL, (__int64)sa, i[6]);
            return 1LL;
          }
          *(_WORD *)(v22 + 24) |= 0x20u;
        }
        if ( (unsigned int)sub_411CA(a1, v18, v17, i, 26, 0LL, a7) )
          return 1LL;
        goto LABEL_51;
      }
      if ( v16 & 0xA && !strcmp((const char *)i[6], "config") )
      {
        if ( v16 & 2 )
        {
          if ( *(_WORD *)(v22 + 24) & 3 )
          {
            sub_13937(v23, 14, 0, 0LL, i[6], *(_QWORD *)(v15 + 48));
            return 1LL;
          }
          sb = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !sb )
          {
            sub_13937(v23, 13, 0, 0LL, (__int64)"value", i[6]);
            return 1LL;
          }
          if ( !strcmp(sb, "false") )
          {
            *(_WORD *)(v22 + 24) |= 2u;
          }
          else
          {
            if ( strcmp(sb, "true") )
            {
              sub_13937(v23, 10, 0, 0LL, (__int64)sb, i[6]);
              return 1LL;
            }
            *(_WORD *)(v22 + 24) |= 1u;
          }
          *(_WORD *)(v22 + 24) |= 4u;
          if ( (unsigned int)sub_411CA(a1, v18, v17, i, 23, 0LL, a7) )
            return 1LL;
        }
        goto LABEL_51;
      }
    }
  }
  if ( v16 & 4 && !(*(_WORD *)(v22 + 24) & 3) )
  {
    if ( a2 )
      *(_WORD *)(v22 + 24) |= *((_WORD *)a2 + 12) & 3;
    else
      *(_WORD *)(v22 + 24) |= 1u;
  }
  if ( a2 && *((_WORD *)a2 + 12) & 0x30 )
  {
    if ( !(*(_WORD *)(v22 + 24) & 0x38) )
    {
      if ( v17 == 1 )
      {
        v10 = *(_QWORD *)(v22 + 64);
        *(_QWORD *)(v22 + 64) = a2;
        ptr = (void *)lys_path(v22, 1LL);
        *(_QWORD *)(v22 + 64) = v10;
      }
      else
      {
        ptr = (void *)lys_path(a2, 1LL);
      }
      if ( *((_WORD *)a2 + 12) & 0x10 )
        v11 = "deprecated";
      else
        v11 = "obsolete";
      sub_12222((__int64)v23, 1u, 0, "Missing status in %s subtree (%s), inheriting.", (__int64)v11, (__int64)ptr);
      free(ptr);
      *(_WORD *)(v22 + 24) |= *((_WORD *)a2 + 12) & 0x38;
      return 0LL;
    }
    if ( (*((_WORD *)a2 + 12) & 0x38) <= (*(_WORD *)(v22 + 24) & 0x38) )
      return 0LL;
    v12 = *(_WORD *)(v22 + 24) & 0x38;
    switch ( v12 )
    {
      case 8:
LABEL_76:
        if ( *((_WORD *)a2 + 12) & 0x10 )
          v13 = "deprecated";
        else
          v13 = "obsolete";
        sub_13937(v23, 37, 2u, a2, (__int64)"current", *(_QWORD *)(v15 + 48), "is child of", v13, *(_QWORD *)a2);
        break;
      case 16:
        sub_13937(
          v23,
          37,
          2u,
          a2,
          (__int64)"deprecated",
          *(_QWORD *)(v15 + 48),
          "is child of",
          "obsolete",
          *(_QWORD *)a2);
        break;
      case 0:
        goto LABEL_76;
    }
    return 1LL;
  }
  return 0LL;
}
// 7680: using guessed type __int64 __fastcall lys_path(_QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000051F02) ----------------------------------------------------
_QWORD *__fastcall sub_51F02(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v5; // r9
  char v6; // al
  __int64 v7; // [rsp+8h] [rbp-48h]
  _QWORD *i; // [rsp+28h] [rbp-28h]
  _QWORD *v9; // [rsp+30h] [rbp-20h]
  void *v10; // [rsp+38h] [rbp-18h]
  _QWORD *v11; // [rsp+40h] [rbp-10h]
  const char *v12; // [rsp+48h] [rbp-8h]

  v7 = a3;
  v10 = (void *)*a1;
  v11 = calloc(1uLL, 0x28uLL);
  if ( !v11 )
  {
    sub_12222((__int64)v10, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_when", v3);
    return 0LL;
  }
  v12 = (const char *)lyxml_get_attr(a2, "condition", 0LL);
  if ( !v12 )
  {
    sub_13937(v10, 13, 0, 0LL, (__int64)"condition", *(_QWORD *)(a2 + 48));
LABEL_30:
    sub_A1E16((__int64)v10, v11, 0LL);
    return 0LL;
  }
  *v11 = sub_9BED(a1, v12);
  if ( !*v11 )
    goto LABEL_30;
  for ( i = *(_QWORD **)(a2 + 24); ; i = v9 )
  {
    if ( i )
    {
      v9 = (_QWORD *)i[4];
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "description") )
        {
          if ( v11[1] )
          {
            sub_13937(v10, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48));
            goto LABEL_30;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)v11, 8u, i, 6, 0LL, v7) )
            goto LABEL_30;
          v11[1] = sub_410A7(v10, (__int64)i, "text");
          if ( !v11[1] )
            goto LABEL_30;
        }
        else
        {
          if ( strcmp((const char *)i[6], "reference") )
          {
            sub_13937(v10, 5, 0, 0LL, i[6], v5);
            goto LABEL_30;
          }
          if ( v11[2] )
          {
            sub_13937(v10, 14, 0, 0LL, i[6], *(_QWORD *)(a2 + 48));
            goto LABEL_30;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)v11, 8u, i, 15, 0LL, v7) )
            goto LABEL_30;
          v11[2] = sub_410A7(v10, (__int64)i, "text");
          if ( !v11[2] )
            goto LABEL_30;
        }
      }
      else if ( (unsigned int)sub_411CA(a1, (__int64)v11, 8u, i, 0, 0LL, v7) )
      {
        goto LABEL_30;
      }
    }
  }
  return v11;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (00000000000522BA) ----------------------------------------------------
unsigned __int8 *__fastcall sub_522BA(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  char v7; // di
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  __int64 v11; // r9
  char v12; // al
  __int64 v13; // r9
  __int64 v14; // r9
  _BOOL4 v15; // eax
  int v16; // eax
  char v17; // al
  char v18; // al
  __int64 v19; // [rsp+8h] [rbp-C8h]
  unsigned int v20; // [rsp+14h] [rbp-BCh]
  __int64 v21; // [rsp+18h] [rbp-B8h]
  __int64 *v22; // [rsp+28h] [rbp-A8h]
  int v23; // [rsp+3Ch] [rbp-94h]
  int v24; // [rsp+40h] [rbp-90h]
  _QWORD *i; // [rsp+48h] [rbp-88h]
  __int64 j; // [rsp+48h] [rbp-88h]
  __int64 k; // [rsp+48h] [rbp-88h]
  _QWORD *v28; // [rsp+50h] [rbp-80h]
  __int64 v29; // [rsp+58h] [rbp-78h]
  _DWORD *v30; // [rsp+60h] [rbp-70h]
  unsigned __int8 *v31; // [rsp+68h] [rbp-68h]
  void *v32; // [rsp+78h] [rbp-58h]
  char s; // [rsp+80h] [rbp-50h]
  __int64 v34; // [rsp+98h] [rbp-38h]
  unsigned __int64 v35; // [rsp+C8h] [rbp-8h]

  v22 = a1;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v35 = __readfsqword(0x28u);
  v30 = (_DWORD *)*a1;
  v29 = 0LL;
  v23 = 0;
  v24 = 0;
  memset(&s, 0, 0x48uLL);
  v31 = (unsigned __int8 *)calloc(1uLL, 0x70uLL);
  if ( !v31 )
  {
    sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_case", v5);
    return 0LL;
  }
  *((_DWORD *)v31 + 14) = 64;
  *((_QWORD *)v31 + 11) = v31;
  if ( v20 & 3 )
    v7 = 17;
  else
    v7 = 21;
  if ( (unsigned int)sub_51597(v22, a2, (__int64)v31, 1u, v21, v7, v19) )
    goto LABEL_91;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v21 + 48), *(_QWORD *)v31, v8, v9);
  v10 = (_QWORD *)lys_main_module(v22);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v31, v20) )
    goto LABEL_91;
  for ( i = *(_QWORD **)(v21 + 24); ; i = v28 )
  {
    if ( i )
    {
      v28 = (_QWORD *)i[4];
      v12 = 1;
    }
    else
    {
      v12 = 0;
    }
    if ( !v12 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "container")
        || !strcmp((const char *)i[6], "leaf-list")
        || !strcmp((const char *)i[6], "leaf")
        || !strcmp((const char *)i[6], "list")
        || !strcmp((const char *)i[6], "uses")
        || !strcmp((const char *)i[6], "choice")
        || !strcmp((const char *)i[6], "anyxml")
        || !strcmp((const char *)i[6], "anydata") )
      {
        sub_30B77((__int64)v30, i, 2);
        sub_3116F((__int64)v30, (__int64)&s, i);
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        if ( v23 == 255 )
        {
          sub_12222(
            (__int64)v30,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "case");
          goto LABEL_91;
        }
        ++v23;
      }
      else
      {
        if ( strcmp((const char *)i[6], "when") )
        {
          sub_13937(v30, 5, 2u, (char *)v31, i[6], v11);
          goto LABEL_91;
        }
        if ( *((_QWORD *)v31 + 13) )
        {
          sub_13937(v30, 14, 2u, (char *)v31, i[6], *(_QWORD *)(v21 + 48));
          goto LABEL_91;
        }
        *((_QWORD *)v31 + 13) = sub_51F02(v22, (__int64)i, v19);
        if ( !*((_QWORD *)v31 + 13) )
          goto LABEL_91;
        lyxml_free(v30, i);
      }
    }
    else
    {
      if ( v24 == 255 )
      {
        sub_12222(
          (__int64)v30,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "case");
        goto LABEL_91;
      }
      ++v24;
    }
  }
  if ( !v23 || (*((_QWORD *)v31 + 5) = calloc(v23, 0x20uLL)) != 0LL )
  {
    if ( v24 )
    {
      v32 = realloc(*((void **)v31 + 4), 8LL * (v31[26] + v24));
      if ( !v32 )
      {
        sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_case", v14);
        goto LABEL_91;
      }
      *((_QWORD *)v31 + 4) = v32;
      memset((void *)(*((_QWORD *)v31 + 4) + 8LL * v31[26]), 0, 8LL * v24);
    }
    for ( j = *(_QWORD *)(v21 + 24); ; j = (__int64)v28 )
    {
      if ( j )
      {
        v28 = *(_QWORD **)(j + 32);
        v17 = 1;
      }
      else
      {
        v17 = 0;
      }
      if ( !v17 )
        break;
      if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        v16 = sub_41746((__int64)v31, 0, j, *((_QWORD *)v31 + 5) + 32LL * v31[27], v19);
        ++v31[27];
        if ( v16 )
          goto LABEL_91;
      }
      else
      {
        v15 = sub_40F96((__int64)v31, 1, 0, 0, v22, j, (__int64 *)v31 + 4, v31[26], v19);
        ++v31[26];
        if ( v15 )
          goto LABEL_91;
      }
    }
    for ( k = v34; ; k = (__int64)v28 )
    {
      if ( k )
      {
        v28 = *(_QWORD **)(k + 32);
        v18 = 1;
      }
      else
      {
        v18 = 0;
      }
      if ( !v18 )
        break;
      if ( !strcmp(*(const char **)(k + 48), "container") )
      {
        v29 = (__int64)sub_587B3(v22, (char *)v31, k, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "leaf-list") )
      {
        v29 = sub_551D2((__int64)v22, (char *)v31, k, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "leaf") )
      {
        v29 = (__int64)sub_54422(v22, (char *)v31, k, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "list") )
      {
        v29 = (__int64)sub_56721(v22, (char *)v31, k, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "choice") )
      {
        v29 = (__int64)sub_52E00((__int64)v22, (char *)v31, k, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "uses") )
      {
        v29 = (__int64)sub_5CBDA(v22, (char *)v31, k, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "anyxml") )
      {
        v29 = (__int64)sub_53A72(v22, (char *)v31, k, 32, v20, v19);
      }
      else if ( !strcmp(*(const char **)(k + 48), "anydata") )
      {
        v29 = (__int64)sub_53A72(v22, (char *)v31, k, 32800, v20, v19);
      }
      if ( !v29 )
        goto LABEL_91;
      lyxml_free(v30, k);
    }
    if ( !(v30[23] & 2) && *((_QWORD *)v31 + 13) )
    {
      if ( v20 & 4 )
      {
        if ( (unsigned int)sub_DDEA9((__int64)v31) )
          goto LABEL_91;
      }
      else if ( (unsigned int)sub_2ABDE(v22, v19, (__int64 *)v31, 0x20000u, 0LL) == -1 )
      {
        goto LABEL_91;
      }
    }
    return v31;
  }
  sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_case", v13);
LABEL_91:
  while ( v34 )
    lyxml_free(v30, v34);
  sub_A33A0((_QWORD **)v31, 0LL, 0);
  return 0LL;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000052E00) ----------------------------------------------------
unsigned __int8 *__fastcall sub_52E00(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  unsigned __int8 *result; // rax
  char v7; // al
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  __int16 v11; // ax
  __int64 v12; // r9
  char v13; // al
  __int64 v14; // r9
  __int64 v15; // r9
  _BOOL4 v16; // eax
  int v17; // eax
  char v18; // al
  __int64 v19; // r9
  __int64 v20; // [rsp+8h] [rbp-88h]
  unsigned int v21; // [rsp+14h] [rbp-7Ch]
  __int64 v22; // [rsp+18h] [rbp-78h]
  signed int v23; // [rsp+38h] [rbp-58h]
  int v24; // [rsp+3Ch] [rbp-54h]
  int v25; // [rsp+40h] [rbp-50h]
  __int64 i; // [rsp+48h] [rbp-48h]
  __int64 j; // [rsp+48h] [rbp-48h]
  __int64 v28; // [rsp+50h] [rbp-40h]
  __int64 v29; // [rsp+58h] [rbp-38h]
  _DWORD *v30; // [rsp+60h] [rbp-30h]
  unsigned __int8 *v31; // [rsp+70h] [rbp-20h]
  void *v32; // [rsp+80h] [rbp-10h]
  char *s1; // [rsp+88h] [rbp-8h]
  char *s1a; // [rsp+88h] [rbp-8h]

  v22 = a3;
  v21 = a4;
  v20 = a5;
  v29 = 0LL;
  v30 = *(_DWORD **)a1;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v31 = (unsigned __int8 *)calloc(1uLL, 0x78uLL);
  if ( !v31 )
  {
    sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_choice", v5);
    return 0LL;
  }
  *((_DWORD *)v31 + 14) = 2;
  *((_QWORD *)v31 + 11) = v31;
  if ( v21 & 2 )
  {
    v7 = 25;
  }
  else if ( v21 & 1 )
  {
    v7 = 19;
  }
  else
  {
    v7 = 23;
  }
  if ( (unsigned int)sub_51597((__int64 *)a1, a2, (__int64)v31, 1u, v22, v7, v20) )
    goto LABEL_105;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v22 + 48), *(_QWORD *)v31, v8, v9);
  v10 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v31, v21) )
    goto LABEL_105;
  for ( i = *(_QWORD *)(v22 + 24); ; i = v28 )
  {
    if ( i )
    {
      v28 = *(_QWORD *)(i + 32);
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
    if ( !v13 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(i + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp(*(const char **)(i + 48), "container") )
      {
        if ( !sub_587B3((__int64 *)a1, (char *)v31, i, v21, v20) )
          goto LABEL_105;
LABEL_67:
        lyxml_free(v30, i);
        continue;
      }
      if ( !strcmp(*(const char **)(i + 48), "leaf-list") )
      {
        if ( !sub_551D2(a1, (char *)v31, i, v21, v20) )
          goto LABEL_105;
        goto LABEL_67;
      }
      if ( !strcmp(*(const char **)(i + 48), "leaf") )
      {
        if ( !sub_54422((__int64 *)a1, (char *)v31, i, v21, v20) )
          goto LABEL_105;
        goto LABEL_67;
      }
      if ( !strcmp(*(const char **)(i + 48), "list") )
      {
        if ( !sub_56721((__int64 *)a1, (char *)v31, i, v21, v20) )
          goto LABEL_105;
        goto LABEL_67;
      }
      if ( !strcmp(*(const char **)(i + 48), "case") )
      {
        if ( !sub_522BA((__int64 *)a1, (char *)v31, i, v21, v20) )
          goto LABEL_105;
        goto LABEL_67;
      }
      if ( !strcmp(*(const char **)(i + 48), "anyxml") )
      {
        if ( !sub_53A72((__int64 *)a1, (char *)v31, i, 32, v21, v20) )
          goto LABEL_105;
        goto LABEL_67;
      }
      if ( !strcmp(*(const char **)(i + 48), "anydata") )
      {
        if ( !sub_53A72((__int64 *)a1, (char *)v31, i, 32800, v21, v20) )
          goto LABEL_105;
        goto LABEL_67;
      }
      if ( !strcmp(*(const char **)(i + 48), "default") )
      {
        if ( v29 )
        {
          sub_13937(v30, 14, 2u, (char *)v31, *(_QWORD *)(i + 48), *(_QWORD *)(v22 + 48));
          goto LABEL_105;
        }
        if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v31, 1u, (_QWORD *)i, 5, 0LL, v20) )
          goto LABEL_105;
        v29 = i;
        sub_30B77((__int64)v30, (_QWORD *)i, 0);
      }
      else
      {
        if ( !strcmp(*(const char **)(i + 48), "mandatory") )
        {
          if ( v23 )
          {
            sub_13937(v30, 14, 2u, (char *)v31, *(_QWORD *)(i + 48), *(_QWORD *)(v22 + 48));
            goto LABEL_105;
          }
          v23 = 1;
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937(v30, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(i + 48));
            goto LABEL_105;
          }
          if ( !strcmp(s1, "true") )
          {
            *((_WORD *)v31 + 12) |= 0x40u;
          }
          else
          {
            if ( strcmp(s1, "false") )
            {
              sub_13937(v30, 10, 2u, (char *)v31, (__int64)s1, *(_QWORD *)(i + 48));
              goto LABEL_105;
            }
            v11 = *((_WORD *)v31 + 12);
            LOBYTE(v11) = v11 | 0x80;
            *((_WORD *)v31 + 12) = v11;
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v31, 1u, (_QWORD *)i, 24, 0LL, v20) )
            goto LABEL_105;
          goto LABEL_67;
        }
        if ( !strcmp(*(const char **)(i + 48), "when") )
        {
          if ( *((_QWORD *)v31 + 13) )
          {
            sub_13937(v30, 14, 2u, (char *)v31, *(_QWORD *)(i + 48), *(_QWORD *)(v22 + 48));
            goto LABEL_105;
          }
          *((_QWORD *)v31 + 13) = sub_51F02((__int64 *)a1, i, v20);
          if ( !*((_QWORD *)v31 + 13) )
            goto LABEL_105;
          goto LABEL_67;
        }
        if ( strcmp(*(const char **)(i + 48), "if-feature") )
        {
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp(*(const char **)(i + 48), "choice") )
          {
            sub_13937(v30, 5, 2u, (char *)v31, *(_QWORD *)(i + 48), v12);
            goto LABEL_105;
          }
          if ( !sub_52E00(a1, (char *)v31, i, v21, v20) )
            goto LABEL_105;
          goto LABEL_67;
        }
        if ( v24 == 255 )
        {
          sub_12222(
            (__int64)v30,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "choice");
          goto LABEL_105;
        }
        ++v24;
      }
    }
    else
    {
      if ( v25 == 255 )
      {
        sub_12222(
          (__int64)v30,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "choice");
        goto LABEL_105;
      }
      ++v25;
    }
  }
  if ( v24 )
  {
    *((_QWORD *)v31 + 5) = calloc(v24, 0x20uLL);
    if ( !*((_QWORD *)v31 + 5) )
    {
      sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_choice", v14);
      goto LABEL_105;
    }
  }
  if ( v25 )
  {
    v32 = realloc(*((void **)v31 + 4), 8LL * (v31[26] + v25));
    if ( !v32 )
    {
      sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_choice", v15);
      goto LABEL_105;
    }
    *((_QWORD *)v31 + 4) = v32;
    memset((void *)(*((_QWORD *)v31 + 4) + 8LL * v31[26]), 0, 8LL * v25);
  }
  for ( j = *(_QWORD *)(v22 + 24); ; j = v28 )
  {
    if ( j )
    {
      v28 = *(_QWORD *)(j + 32);
      v18 = 1;
    }
    else
    {
      v18 = 0;
    }
    if ( !v18 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      v17 = sub_41746((__int64)v31, 0, j, *((_QWORD *)v31 + 5) + 32LL * v31[27], v20);
      ++v31[27];
      if ( v17 )
        goto LABEL_105;
    }
    else
    {
      v16 = sub_40F96((__int64)v31, 1, 0, 0, (__int64 *)a1, j, (__int64 *)v31 + 4, v31[26], v20);
      ++v31[26];
      if ( v16 )
        goto LABEL_105;
    }
  }
  if ( v29 && *((_WORD *)v31 + 12) & 0x40 )
  {
    sub_13937(v30, 6, 2u, (char *)v31, (__int64)"default", (__int64)"choice");
    sub_13937(v30, -1, 5u, 0LL, (__int64)"The \"default\" statement is forbidden on choices with \"mandatory\".", v19);
    goto LABEL_105;
  }
  if ( v29 )
  {
    s1a = (char *)lyxml_get_attr(v29, "value", 0LL);
    if ( !s1a )
    {
      sub_13937(v30, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(v29 + 48));
      goto LABEL_105;
    }
    if ( (unsigned int)sub_2AB62((__int64 *)a1, v20, (__int64 *)v31, 0x80u, (__int64)s1a) != -1 )
    {
      lyxml_free(v30, v29);
      goto LABEL_98;
    }
LABEL_105:
    lyxml_free(v30, v29);
    sub_A33A0((_QWORD **)v31, 0LL, 0);
    result = 0LL;
  }
  else
  {
LABEL_98:
    if ( !(v30[23] & 2) && *((_QWORD *)v31 + 13) )
    {
      if ( v21 & 4 )
      {
        if ( (unsigned int)sub_DDEA9((__int64)v31) )
          goto LABEL_105;
      }
      else if ( (unsigned int)sub_2ABDE((__int64 *)a1, v20, (__int64 *)v31, 0x20000u, 0LL) == -1 )
      {
        goto LABEL_105;
      }
    }
    result = v31;
  }
  return result;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000053A72) ----------------------------------------------------
unsigned __int8 *__fastcall sub_53A72(__int64 *a1, char *a2, __int64 a3, int a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // r9
  char v8; // al
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *v11; // rax
  __int16 v12; // ax
  __int64 v13; // r9
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // r9
  __int64 v17; // r9
  _BOOL4 v18; // eax
  int v19; // eax
  int v20; // eax
  char v21; // al
  __int16 v22; // ax
  __int64 v23; // [rsp+8h] [rbp-78h]
  unsigned int v24; // [rsp+10h] [rbp-70h]
  int v25; // [rsp+14h] [rbp-6Ch]
  __int64 v26; // [rsp+18h] [rbp-68h]
  signed int k; // [rsp+34h] [rbp-4Ch]
  signed int v28; // [rsp+38h] [rbp-48h]
  int v29; // [rsp+3Ch] [rbp-44h]
  int v30; // [rsp+40h] [rbp-40h]
  int v31; // [rsp+44h] [rbp-3Ch]
  _QWORD *i; // [rsp+48h] [rbp-38h]
  __int64 j; // [rsp+48h] [rbp-38h]
  _QWORD *v34; // [rsp+50h] [rbp-30h]
  _DWORD *v35; // [rsp+58h] [rbp-28h]
  unsigned __int8 *v36; // [rsp+60h] [rbp-20h]
  void *v37; // [rsp+70h] [rbp-10h]
  char *s1; // [rsp+78h] [rbp-8h]

  v26 = a3;
  v25 = a4;
  v24 = a5;
  v23 = a6;
  v35 = (_DWORD *)*a1;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v36 = (unsigned __int8 *)calloc(1uLL, 0x80uLL);
  if ( !v36 )
  {
    sub_12222((__int64)v35, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_anydata", v6);
    return 0LL;
  }
  *((_DWORD *)v36 + 14) = v25;
  *((_QWORD *)v36 + 11) = v36;
  if ( v24 & 2 )
  {
    v8 = 25;
  }
  else if ( v24 & 1 )
  {
    v8 = 19;
  }
  else
  {
    v8 = 23;
  }
  if ( (unsigned int)sub_51597(a1, a2, (__int64)v36, 1u, v26, v8, v23) )
    goto LABEL_84;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v26 + 48), *(_QWORD *)v36, v9, v10);
  v11 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v11, (__int64)v36, v24) )
    goto LABEL_84;
  for ( i = *(_QWORD **)(v26 + 24); ; i = v34 )
  {
    if ( i )
    {
      v34 = (_QWORD *)i[4];
      v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    if ( !v14 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "mandatory") )
      {
        if ( v28 )
        {
          sub_13937(v35, 14, 2u, (char *)v36, i[6], *(_QWORD *)(v26 + 48));
          goto LABEL_84;
        }
        v28 = 1;
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937(v35, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_84;
        }
        if ( !strcmp(s1, "true") )
        {
          *((_WORD *)v36 + 12) |= 0x40u;
        }
        else
        {
          if ( strcmp(s1, "false") )
          {
            sub_13937(v35, 10, 2u, (char *)v36, (__int64)s1, i[6]);
            goto LABEL_84;
          }
          v12 = *((_WORD *)v36 + 12);
          LOBYTE(v12) = v12 | 0x80;
          *((_WORD *)v36 + 12) = v12;
        }
        if ( (unsigned int)sub_411CA(a1, (__int64)v36, 1u, i, 24, 0LL, v23) )
          goto LABEL_84;
        lyxml_free(v35, i);
      }
      else if ( !strcmp((const char *)i[6], "when") )
      {
        if ( *((_QWORD *)v36 + 14) )
        {
          sub_13937(v35, 14, 2u, (char *)v36, i[6], *(_QWORD *)(v26 + 48));
          goto LABEL_84;
        }
        *((_QWORD *)v36 + 14) = sub_51F02(a1, (__int64)i, v23);
        if ( !*((_QWORD *)v36 + 14) )
        {
          lyxml_free(v35, i);
          goto LABEL_84;
        }
        lyxml_free(v35, i);
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        if ( v29 == 255 )
        {
          sub_12222(
            (__int64)v35,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "anydata");
          goto LABEL_84;
        }
        ++v29;
      }
      else
      {
        if ( strcmp((const char *)i[6], "if-feature") )
        {
          sub_13937(v35, 5, 2u, (char *)v36, i[6], v13);
          goto LABEL_84;
        }
        if ( v30 == 255 )
        {
          sub_12222(
            (__int64)v35,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "anydata");
          goto LABEL_84;
        }
        ++v30;
      }
    }
    else
    {
      if ( v31 == 255 )
      {
        sub_12222(
          (__int64)v35,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "anydata");
        goto LABEL_84;
      }
      ++v31;
    }
  }
  if ( v29 )
  {
    *((_QWORD *)v36 + 15) = calloc(v29, 0x38uLL);
    if ( !*((_QWORD *)v36 + 15) )
    {
      sub_12222((__int64)v35, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_anydata", v15);
LABEL_84:
      sub_A33A0((_QWORD **)v36, 0LL, 0);
      return 0LL;
    }
  }
  if ( v30 )
  {
    *((_QWORD *)v36 + 5) = calloc(v30, 0x20uLL);
    if ( !*((_QWORD *)v36 + 5) )
    {
      sub_12222((__int64)v35, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_anydata", v16);
      goto LABEL_84;
    }
  }
  if ( v31 )
  {
    v37 = realloc(*((void **)v36 + 4), 8LL * (v36[26] + v31));
    if ( !v37 )
    {
      sub_12222((__int64)v35, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_anydata", v17);
      goto LABEL_84;
    }
    *((_QWORD *)v36 + 4) = v37;
    memset((void *)(*((_QWORD *)v36 + 4) + 8LL * v36[26]), 0, 8LL * v31);
  }
  for ( j = *(_QWORD *)(v26 + 24); ; j = (__int64)v34 )
  {
    if ( j )
    {
      v34 = *(_QWORD **)(j + 32);
      v21 = 1;
    }
    else
    {
      v21 = 0;
    }
    if ( !v21 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp(*(const char **)(j + 48), "must") )
      {
        v19 = sub_489FC(a1, j, (__int64 *)(*((_QWORD *)v36 + 15) + 56LL * v36[31]), v23);
        ++v36[31];
        if ( v19 )
          goto LABEL_84;
      }
      else if ( !strcmp(*(const char **)(j + 48), "if-feature") )
      {
        v20 = sub_41746((__int64)v36, 0, j, *((_QWORD *)v36 + 5) + 32LL * v36[27], v23);
        ++v36[27];
        if ( v20 )
          goto LABEL_84;
      }
    }
    else
    {
      v18 = sub_40F96((__int64)v36, 1, 0, 0, a1, j, (__int64 *)v36 + 4, v36[26], v23);
      ++v36[26];
      if ( v18 )
        goto LABEL_84;
    }
  }
  if ( !(v35[23] & 2) && (*((_QWORD *)v36 + 14) || *((_QWORD *)v36 + 15)) )
  {
    if ( v24 & 4 )
    {
      if ( (unsigned int)sub_DDEA9((__int64)v36) )
        goto LABEL_84;
    }
    else if ( (unsigned int)sub_2ABDE(a1, v23, (__int64 *)v36, 0x20000u, 0LL) == -1 )
    {
      goto LABEL_84;
    }
  }
  for ( k = 0; k < v36[26]; ++k )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * k + *((_QWORD *)v36 + 4)) + 24LL) & 8 )
    {
      v22 = *((_WORD *)v36 + 12);
      HIBYTE(v22) |= 0x20u;
      *((_WORD *)v36 + 12) = v22;
      return v36;
    }
  }
  return v36;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000054422) ----------------------------------------------------
unsigned __int8 *__fastcall sub_54422(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  char v7; // al
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  size_t v11; // rax
  size_t v12; // rax
  __int16 v13; // ax
  __int64 v14; // r9
  char v15; // al
  __int64 v16; // r9
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // r9
  _BOOL4 v20; // eax
  int v21; // eax
  int v22; // eax
  char v23; // al
  __int16 v24; // ax
  __int64 v25; // [rsp+8h] [rbp-78h]
  unsigned int v26; // [rsp+14h] [rbp-6Ch]
  __int64 v27; // [rsp+18h] [rbp-68h]
  signed int k; // [rsp+30h] [rbp-50h]
  signed int v29; // [rsp+34h] [rbp-4Ch]
  int v30; // [rsp+38h] [rbp-48h]
  int v31; // [rsp+3Ch] [rbp-44h]
  signed int v32; // [rsp+40h] [rbp-40h]
  int v33; // [rsp+44h] [rbp-3Ch]
  _QWORD *i; // [rsp+48h] [rbp-38h]
  __int64 j; // [rsp+48h] [rbp-38h]
  _QWORD *v36; // [rsp+50h] [rbp-30h]
  _DWORD *v37; // [rsp+58h] [rbp-28h]
  unsigned __int8 *v38; // [rsp+60h] [rbp-20h]
  void *v39; // [rsp+70h] [rbp-10h]
  char *s; // [rsp+78h] [rbp-8h]
  char *sa; // [rsp+78h] [rbp-8h]
  char *sb; // [rsp+78h] [rbp-8h]

  v27 = a3;
  v26 = a4;
  v25 = a5;
  v37 = (_DWORD *)*a1;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v38 = (unsigned __int8 *)calloc(1uLL, 0xD0uLL);
  if ( !v38 )
  {
    sub_12222((__int64)v37, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaf", v5);
    return 0LL;
  }
  *((_DWORD *)v38 + 14) = 4;
  *((_QWORD *)v38 + 11) = v38;
  if ( v26 & 2 )
  {
    v7 = 25;
  }
  else if ( v26 & 1 )
  {
    v7 = 19;
  }
  else
  {
    v7 = 23;
  }
  if ( (unsigned int)sub_51597(a1, a2, (__int64)v38, 1u, v27, v7, v25) )
    goto LABEL_110;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v27 + 48), *(_QWORD *)v38, v8, v9);
  v10 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v38, v26) )
    goto LABEL_110;
  for ( i = *(_QWORD **)(v27 + 24); ; i = v36 )
  {
    if ( i )
    {
      v36 = (_QWORD *)i[4];
      v15 = 1;
    }
    else
    {
      v15 = 0;
    }
    if ( !v15 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "type") )
      {
        if ( v29 )
        {
          sub_13937(v37, 14, 2u, (char *)v38, i[6], *(_QWORD *)(v27 + 48));
          goto LABEL_110;
        }
        *((_QWORD *)v38 + 18) = i;
        *((_QWORD *)v38 + 19) = v38;
        v29 = 1;
      }
      else if ( !strcmp((const char *)i[6], "default") )
      {
        if ( *((_QWORD *)v38 + 25) )
        {
          sub_13937(v37, 14, 2u, (char *)v38, i[6], *(_QWORD *)(v27 + 48));
          goto LABEL_110;
        }
        s = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s )
        {
          sub_13937(v37, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_110;
        }
        v11 = strlen(s);
        *((_QWORD *)v38 + 25) = lydict_insert(v37, s, v11);
        if ( (unsigned int)sub_411CA(a1, (__int64)v38, 1u, i, 5, 0LL, v25) )
          goto LABEL_110;
      }
      else if ( !strcmp((const char *)i[6], "units") )
      {
        if ( *((_QWORD *)v38 + 24) )
        {
          sub_13937(v37, 14, 2u, (char *)v38, i[6], *(_QWORD *)(v27 + 48));
          goto LABEL_110;
        }
        sa = (char *)lyxml_get_attr(i, "name", 0LL);
        if ( !sa )
        {
          sub_13937(v37, 13, 0, 0LL, (__int64)"name", i[6]);
          goto LABEL_110;
        }
        v12 = strlen(sa);
        *((_QWORD *)v38 + 24) = lydict_insert(v37, sa, v12);
        if ( (unsigned int)sub_411CA(a1, (__int64)v38, 1u, i, 17, 0LL, v25) )
          goto LABEL_110;
      }
      else if ( !strcmp((const char *)i[6], "mandatory") )
      {
        if ( v32 )
        {
          sub_13937(v37, 14, 2u, (char *)v38, i[6], *(_QWORD *)(v27 + 48));
          goto LABEL_110;
        }
        v32 = 1;
        sb = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !sb )
        {
          sub_13937(v37, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_110;
        }
        if ( !strcmp(sb, "true") )
        {
          *((_WORD *)v38 + 12) |= 0x40u;
        }
        else
        {
          if ( strcmp(sb, "false") )
          {
            sub_13937(v37, 10, 2u, (char *)v38, (__int64)sb, i[6]);
            goto LABEL_110;
          }
          v13 = *((_WORD *)v38 + 12);
          LOBYTE(v13) = v13 | 0x80;
          *((_WORD *)v38 + 12) = v13;
        }
        if ( (unsigned int)sub_411CA(a1, (__int64)v38, 1u, i, 24, 0LL, v25) )
          goto LABEL_110;
      }
      else if ( !strcmp((const char *)i[6], "when") )
      {
        if ( *((_QWORD *)v38 + 14) )
        {
          sub_13937(v37, 14, 2u, (char *)v38, i[6], *(_QWORD *)(v27 + 48));
          goto LABEL_110;
        }
        *((_QWORD *)v38 + 14) = sub_51F02(a1, (__int64)i, v25);
        if ( !*((_QWORD *)v38 + 14) )
          goto LABEL_110;
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        if ( v30 == 255 )
        {
          sub_12222(
            (__int64)v37,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "leaf");
          goto LABEL_110;
        }
        ++v30;
      }
      else
      {
        if ( strcmp((const char *)i[6], "if-feature") )
        {
          sub_13937(v37, 5, 2u, (char *)v38, i[6], v14);
          goto LABEL_110;
        }
        if ( v31 == 255 )
        {
          sub_12222(
            (__int64)v37,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "leaf");
          goto LABEL_110;
        }
        ++v31;
      }
    }
    else
    {
      if ( v33 == 255 )
      {
        sub_12222(
          (__int64)v37,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "leaf");
        goto LABEL_110;
      }
      ++v33;
    }
  }
  if ( !v29 )
  {
    sub_13937(v37, 12, 2u, (char *)v38, (__int64)"type", *(_QWORD *)(v27 + 48));
LABEL_110:
    sub_A33A0((_QWORD **)v38, 0LL, 0);
    return 0LL;
  }
  if ( *((_QWORD *)v38 + 25) && *((_WORD *)v38 + 12) & 0x40 )
  {
    sub_13937(v37, 6, 2u, (char *)v38, (__int64)"mandatory", (__int64)"leaf");
    sub_13937(
      v37,
      -1,
      5u,
      0LL,
      (__int64)"The \"mandatory\" statement is forbidden on leaf with the \"default\" statement.",
      v16);
    goto LABEL_110;
  }
  if ( v30 )
  {
    *((_QWORD *)v38 + 15) = calloc(v30, 0x38uLL);
    if ( !*((_QWORD *)v38 + 15) )
    {
      sub_12222((__int64)v37, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaf", v17);
      goto LABEL_110;
    }
  }
  if ( v31 )
  {
    *((_QWORD *)v38 + 5) = calloc(v31, 0x20uLL);
    if ( !*((_QWORD *)v38 + 5) )
    {
      sub_12222((__int64)v37, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaf", v18);
      goto LABEL_110;
    }
  }
  if ( v33 )
  {
    v39 = realloc(*((void **)v38 + 4), 8LL * (v38[26] + v33));
    if ( !v39 )
    {
      sub_12222((__int64)v37, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaf", v19);
      goto LABEL_110;
    }
    *((_QWORD *)v38 + 4) = v39;
    memset((void *)(*((_QWORD *)v38 + 4) + 8LL * v38[26]), 0, 8LL * v33);
  }
  for ( j = *(_QWORD *)(v27 + 24); ; j = (__int64)v36 )
  {
    if ( j )
    {
      v36 = *(_QWORD **)(j + 32);
      v23 = 1;
    }
    else
    {
      v23 = 0;
    }
    if ( !v23 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp(*(const char **)(j + 48), "must") )
      {
        v21 = sub_489FC(a1, j, (__int64 *)(*((_QWORD *)v38 + 15) + 56LL * v38[31]), v25);
        ++v38[31];
        if ( v21 )
          goto LABEL_110;
      }
      else if ( !strcmp(*(const char **)(j + 48), "if-feature") )
      {
        v22 = sub_41746((__int64)v38, 0, j, *((_QWORD *)v38 + 5) + 32LL * v38[27], v25);
        ++v38[27];
        if ( v22 )
          goto LABEL_110;
      }
    }
    else
    {
      v20 = sub_40F96((__int64)v38, 1, 0, 0, a1, j, (__int64 *)v38 + 4, v38[26], v25);
      ++v38[26];
      if ( v20 )
        goto LABEL_110;
    }
  }
  if ( (unsigned int)sub_2ABDE(a1, v25, (__int64 *)v38 + 16, 4u, (__int64 *)v38) == -1 )
  {
    *((_QWORD *)v38 + 18) = 0LL;
    goto LABEL_110;
  }
  if ( !(v37[23] & 2) && (unsigned int)sub_2ABDE(a1, v25, (__int64 *)v38 + 16, 0x1000u, (__int64 *)v38 + 25) == -1 )
    goto LABEL_110;
  if ( !(v37[23] & 2) && (*((_QWORD *)v38 + 14) || *((_QWORD *)v38 + 15)) )
  {
    if ( v26 & 4 )
    {
      if ( (unsigned int)sub_DDEA9((__int64)v38) )
        goto LABEL_110;
    }
    else if ( (unsigned int)sub_2ABDE(a1, v25, (__int64 *)v38, 0x20000u, 0LL) == -1 )
    {
      goto LABEL_110;
    }
  }
  for ( k = 0; k < v38[26]; ++k )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * k + *((_QWORD *)v38 + 4)) + 24LL) & 8 )
    {
      v24 = *((_WORD *)v38 + 12);
      HIBYTE(v24) |= 0x20u;
      *((_WORD *)v38 + 12) = v24;
      return v38;
    }
  }
  return v38;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000551D2) ----------------------------------------------------
__int64 __fastcall sub_551D2(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  char v7; // al
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  size_t v11; // rax
  __int64 v12; // rax
  __int16 v13; // ax
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  _QWORD *v17; // rax
  char v18; // al
  __int64 v19; // r9
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // r9
  _BOOL4 v23; // eax
  int v24; // eax
  int v25; // eax
  size_t v26; // rdi
  __int64 v27; // rsi
  unsigned __int8 v28; // al
  char v29; // al
  __int64 v30; // r9
  __int16 v31; // ax
  __int64 v32; // [rsp+8h] [rbp-B8h]
  unsigned int v33; // [rsp+14h] [rbp-ACh]
  __int64 v34; // [rsp+18h] [rbp-A8h]
  __int64 *v35; // [rsp+28h] [rbp-98h]
  signed int j; // [rsp+3Ch] [rbp-84h]
  signed int k; // [rsp+3Ch] [rbp-84h]
  signed int l; // [rsp+3Ch] [rbp-84h]
  signed int v39; // [rsp+40h] [rbp-80h]
  int v40; // [rsp+44h] [rbp-7Ch]
  int v41; // [rsp+48h] [rbp-78h]
  int v42; // [rsp+4Ch] [rbp-74h]
  int v43; // [rsp+50h] [rbp-70h]
  signed int v44; // [rsp+54h] [rbp-6Ch]
  signed int v45; // [rsp+58h] [rbp-68h]
  signed int v46; // [rsp+5Ch] [rbp-64h]
  char *endptr; // [rsp+60h] [rbp-60h]
  _QWORD *i; // [rsp+68h] [rbp-58h]
  _QWORD *v49; // [rsp+70h] [rbp-50h]
  char *s; // [rsp+78h] [rbp-48h]
  _DWORD *v51; // [rsp+80h] [rbp-40h]
  unsigned __int8 *v52; // [rsp+88h] [rbp-38h]
  unsigned __int8 *v53; // [rsp+90h] [rbp-30h]
  void *v54; // [rsp+98h] [rbp-28h]
  unsigned __int64 v55; // [rsp+A0h] [rbp-20h]
  unsigned __int64 v56; // [rsp+A8h] [rbp-18h]

  v35 = (__int64 *)a1;
  v34 = a3;
  v33 = a4;
  v32 = a5;
  v56 = __readfsqword(0x28u);
  v51 = *(_DWORD **)a1;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v52 = (unsigned __int8 *)calloc(1uLL, 0xD8uLL);
  if ( !v52 )
  {
    sub_12222((__int64)v51, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaflist", v5);
    return 0LL;
  }
  *((_DWORD *)v52 + 14) = 8;
  *((_QWORD *)v52 + 11) = v52;
  v53 = v52;
  if ( v33 & 2 )
  {
    v7 = 25;
  }
  else if ( v33 & 1 )
  {
    v7 = 19;
  }
  else
  {
    v7 = 23;
  }
  if ( (unsigned int)sub_51597((__int64 *)a1, a2, (__int64)v53, 1u, v34, v7, v32) )
    goto LABEL_163;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v34 + 48), *(_QWORD *)v53, v8, v9);
  v10 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v53, v33) )
    goto LABEL_163;
  for ( i = *(_QWORD **)(v34 + 24); ; i = v49 )
  {
    if ( i )
    {
      v49 = (_QWORD *)i[4];
      v18 = 1;
    }
    else
    {
      v18 = 0;
    }
    if ( !v18 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "type") )
      {
        if ( v39 )
        {
          sub_13937(v51, 14, 2u, (char *)v53, i[6], *(_QWORD *)(v34 + 48));
          goto LABEL_163;
        }
        *((_QWORD *)v52 + 18) = i;
        *((_QWORD *)v52 + 19) = v52;
        v39 = 1;
      }
      else if ( !strcmp((const char *)i[6], "units") )
      {
        if ( *((_QWORD *)v52 + 24) )
        {
          sub_13937(v51, 14, 2u, (char *)v53, i[6], *(_QWORD *)(v34 + 48));
          goto LABEL_163;
        }
        s = (char *)lyxml_get_attr(i, "name", 0LL);
        if ( !s )
        {
          sub_13937(v51, 13, 0, 0LL, (__int64)"name", i[6]);
          goto LABEL_163;
        }
        v11 = strlen(s);
        v12 = lydict_insert(v51, s, v11);
        *((_QWORD *)v52 + 24) = v12;
        if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v53, 1u, i, 17, 0LL, v32) )
          goto LABEL_163;
      }
      else if ( !strcmp((const char *)i[6], "ordered-by") )
      {
        if ( v44 )
        {
          sub_13937(v51, 14, 2u, (char *)v53, i[6], *(_QWORD *)(v34 + 48));
          goto LABEL_163;
        }
        v44 = 1;
        if ( *((_WORD *)v52 + 12) & 2 )
        {
          lyxml_free(v51, i);
        }
        else
        {
          s = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s )
          {
            sub_13937(v51, 13, 0, 0LL, (__int64)"value", i[6]);
            goto LABEL_163;
          }
          if ( !strcmp(s, "user") )
          {
            v13 = *((_WORD *)v52 + 12);
            HIBYTE(v13) |= 1u;
            *((_WORD *)v52 + 12) = v13;
          }
          else if ( strcmp(s, "system") )
          {
            sub_13937(v51, 10, 2u, (char *)v53, (__int64)s, i[6]);
            goto LABEL_163;
          }
          if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v53, 1u, i, 25, 0LL, v32) )
            goto LABEL_163;
        }
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        if ( v40 == 255 )
        {
          sub_12222(
            (__int64)v51,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "leaf-list");
          goto LABEL_163;
        }
        ++v40;
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        if ( v41 == 255 )
        {
          sub_12222(
            (__int64)v51,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "leaf-list");
          goto LABEL_163;
        }
        ++v41;
      }
      else if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 && !strcmp((const char *)i[6], "default") )
      {
        if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v53, 1u, i, 5, (unsigned __int8)v42, v32) )
          goto LABEL_163;
        if ( v42 == 255 )
        {
          sub_12222(
            (__int64)v51,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"defaults",
            "leaf-list");
          goto LABEL_163;
        }
        ++v42;
      }
      else if ( !strcmp((const char *)i[6], "min-elements") )
      {
        if ( v45 )
        {
          sub_13937(v51, 14, 2u, (char *)v53, i[6], *(_QWORD *)(v34 + 48));
          goto LABEL_163;
        }
        v45 = 1;
        s = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s )
        {
          sub_13937(v51, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_163;
        }
        while ( (*__ctype_b_loc())[*s] & 0x2000 )
          ++s;
        *__errno_location() = 0;
        endptr = 0LL;
        v55 = strtoul(s, &endptr, 10);
        if ( *endptr || *s == 45 || *__errno_location() || v55 > 0xFFFFFFFF )
        {
          sub_13937(v51, 10, 2u, (char *)v53, (__int64)s, i[6]);
          goto LABEL_163;
        }
        *((_DWORD *)v52 + 52) = v55;
        if ( *((_DWORD *)v52 + 53) && *((_DWORD *)v52 + 52) > *((_DWORD *)v52 + 53) )
        {
          sub_13937(v51, 10, 2u, (char *)v53, (__int64)s, i[6]);
          sub_13937(v51, -1, 5u, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v14);
          goto LABEL_163;
        }
        if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v53, 1u, i, 29, 0LL, v32) )
          goto LABEL_163;
      }
      else if ( !strcmp((const char *)i[6], "max-elements") )
      {
        if ( v46 )
        {
          sub_13937(v51, 14, 2u, (char *)v53, i[6], *(_QWORD *)(v34 + 48));
          goto LABEL_163;
        }
        v46 = 1;
        s = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s )
        {
          sub_13937(v51, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_163;
        }
        while ( (*__ctype_b_loc())[*s] & 0x2000 )
          ++s;
        if ( !strcmp(s, "unbounded") )
        {
          *((_DWORD *)v52 + 53) = 0;
        }
        else
        {
          *__errno_location() = 0;
          endptr = 0LL;
          v55 = strtoul(s, &endptr, 10);
          if ( *endptr || *s == 45 || *__errno_location() || !v55 || v55 > 0xFFFFFFFF )
          {
            sub_13937(v51, 10, 2u, (char *)v53, (__int64)s, i[6]);
            goto LABEL_163;
          }
          *((_DWORD *)v52 + 53) = v55;
          if ( *((_DWORD *)v52 + 52) > *((_DWORD *)v52 + 53) )
          {
            sub_13937(v51, 10, 2u, (char *)v53, (__int64)s, i[6]);
            sub_13937(v51, -1, 5u, 0LL, (__int64)"\"max-elements\" is smaller than \"min-elements\".", v15);
            goto LABEL_163;
          }
        }
        if ( (unsigned int)sub_411CA((__int64 *)a1, (__int64)v53, 1u, i, 28, 0LL, v32) )
          goto LABEL_163;
      }
      else
      {
        if ( strcmp((const char *)i[6], "when") )
        {
          sub_13937(v51, 5, 2u, (char *)v53, i[6], v16);
          goto LABEL_163;
        }
        if ( *((_QWORD *)v52 + 14) )
        {
          sub_13937(v51, 14, 2u, (char *)v53, i[6], *(_QWORD *)(v34 + 48));
          goto LABEL_163;
        }
        v17 = sub_51F02((__int64 *)a1, (__int64)i, v32);
        *((_QWORD *)v52 + 14) = v17;
        if ( !*((_QWORD *)v52 + 14) )
          goto LABEL_163;
      }
    }
    else
    {
      if ( v43 == 255 )
      {
        sub_12222(
          (__int64)v51,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "leaf-list");
        goto LABEL_163;
      }
      ++v43;
    }
  }
  if ( !v39 )
  {
    sub_13937(v51, 12, 2u, (char *)v53, (__int64)"type", *(_QWORD *)(v34 + 48));
LABEL_163:
    sub_A33A0((_QWORD **)v53, 0LL, 0);
    return 0LL;
  }
  if ( v40 )
  {
    *((_QWORD *)v52 + 15) = calloc(v40, 0x38uLL);
    if ( !*((_QWORD *)v52 + 15) )
    {
      sub_12222((__int64)v51, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaflist", v19);
      goto LABEL_163;
    }
  }
  if ( v41 )
  {
    *((_QWORD *)v52 + 5) = calloc(v41, 0x20uLL);
    if ( !*((_QWORD *)v52 + 5) )
    {
      sub_12222((__int64)v51, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaflist", v20);
      goto LABEL_163;
    }
  }
  if ( v42 )
  {
    *((_QWORD *)v52 + 25) = calloc(v42, 8uLL);
    if ( !*((_QWORD *)v52 + 25) )
    {
      sub_12222((__int64)v51, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaflist", v21);
      goto LABEL_163;
    }
  }
  if ( v43 )
  {
    v54 = realloc(*((void **)v53 + 4), 8LL * (v53[26] + v43));
    if ( !v54 )
    {
      sub_12222((__int64)v51, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_leaflist", v22);
      goto LABEL_163;
    }
    *((_QWORD *)v53 + 4) = v54;
    memset((void *)(*((_QWORD *)v53 + 4) + 8LL * v53[26]), 0, 8LL * v43);
  }
  for ( i = *(_QWORD **)(v34 + 24); ; i = v49 )
  {
    if ( i )
    {
      v49 = (_QWORD *)i[4];
      v29 = 1;
    }
    else
    {
      v29 = 0;
    }
    if ( !v29 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "must") )
      {
        v24 = sub_489FC(v35, (__int64)i, (__int64 *)(*((_QWORD *)v52 + 15) + 56LL * v52[31]), v32);
        ++v52[31];
        if ( v24 )
          goto LABEL_163;
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        v25 = sub_41746((__int64)v53, 0, (__int64)i, *((_QWORD *)v52 + 5) + 32LL * v52[27], v32);
        ++v52[27];
        if ( v25 )
          goto LABEL_163;
      }
      else if ( !strcmp((const char *)i[6], "default") )
      {
        s = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s )
        {
          sub_13937(v51, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_163;
        }
        if ( *((_WORD *)v52 + 12) & 1 )
        {
          for ( j = 0; j < v52[30]; ++j )
          {
            if ( s == *(char **)(8LL * j + *((_QWORD *)v52 + 25)) )
            {
              sub_13937(v51, 10, 2u, (char *)v53, (__int64)s, (__int64)"default");
              sub_13937(v51, -1, 5u, 0LL, (__int64)"Duplicated default value \"%s\".", (__int64)s);
              goto LABEL_163;
            }
          }
        }
        v26 = strlen(s);
        v27 = *((_QWORD *)v52 + 25);
        v28 = v52[30];
        v52[30] = v28 + 1;
        *(_QWORD *)(v27 + 8LL * v28) = lydict_insert(v51, s, v26);
      }
    }
    else
    {
      v23 = sub_40F96((__int64)v53, 1, 0, 0, v35, (__int64)i, (__int64 *)v53 + 4, v53[26], v32);
      ++v53[26];
      if ( v23 )
        goto LABEL_163;
    }
  }
  if ( (unsigned int)sub_2ABDE(v35, v32, (__int64 *)v52 + 16, 4u, (__int64 *)v53) == -1 )
  {
    *((_QWORD *)v52 + 18) = 0LL;
    goto LABEL_163;
  }
  if ( v52[30] && *((_DWORD *)v52 + 52) )
  {
    sub_13937(v51, 6, 2u, (char *)v53, (__int64)"min-elements", (__int64)"leaf-list");
    sub_13937(
      v51,
      -1,
      5u,
      0LL,
      (__int64)"The \"min-elements\" statement with non-zero value is forbidden on leaf-lists with the \"default\" statement.",
      v30);
    goto LABEL_163;
  }
  for ( k = 0; k < v52[30]; ++k )
  {
    if ( !(v51[23] & 2)
      && (unsigned int)sub_2ABDE(v35, v32, (__int64 *)v52 + 16, 0x1000u, (__int64 *)(*((_QWORD *)v52 + 25) + 8LL * k)) == -1 )
    {
      goto LABEL_163;
    }
  }
  if ( !(v51[23] & 2) && (*((_QWORD *)v52 + 14) || *((_QWORD *)v52 + 15)) )
  {
    if ( v33 & 4 )
    {
      if ( (unsigned int)sub_DDEA9((__int64)v53) )
        goto LABEL_163;
    }
    else if ( (unsigned int)sub_2ABDE(v35, v32, (__int64 *)v53, 0x20000u, 0LL) == -1 )
    {
      goto LABEL_163;
    }
  }
  for ( l = 0; l < v53[26]; ++l )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * l + *((_QWORD *)v53 + 4)) + 24LL) & 8 )
    {
      v31 = *((_WORD *)v53 + 12);
      HIBYTE(v31) |= 0x20u;
      *((_WORD *)v53 + 12) = v31;
      return (__int64)v53;
    }
  }
  return (__int64)v53;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000056721) ----------------------------------------------------
unsigned __int8 *__fastcall sub_56721(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  char v7; // al
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  __int64 v11; // rax
  __int64 v12; // r9
  __int16 v13; // ax
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  _QWORD *v17; // rax
  char v18; // al
  __int64 v19; // r9
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // r9
  _BOOL4 v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  char v27; // al
  __int64 v28; // r9
  char v29; // al
  __int64 v30; // r9
  int v31; // eax
  char v32; // al
  __int16 v33; // ax
  __int16 v34; // ax
  __int64 v35; // [rsp+8h] [rbp-148h]
  unsigned int v36; // [rsp+14h] [rbp-13Ch]
  __int64 v37; // [rsp+18h] [rbp-138h]
  signed int k; // [rsp+3Ch] [rbp-114h]
  int v39; // [rsp+40h] [rbp-110h]
  int v40; // [rsp+44h] [rbp-10Ch]
  int v41; // [rsp+48h] [rbp-108h]
  int v42; // [rsp+4Ch] [rbp-104h]
  int v43; // [rsp+50h] [rbp-100h]
  signed int v44; // [rsp+54h] [rbp-FCh]
  signed int v45; // [rsp+58h] [rbp-F8h]
  signed int v46; // [rsp+5Ch] [rbp-F4h]
  char *endptr; // [rsp+60h] [rbp-F0h]
  _QWORD *j; // [rsp+68h] [rbp-E8h]
  _QWORD *i; // [rsp+70h] [rbp-E0h]
  _QWORD *v50; // [rsp+78h] [rbp-D8h]
  char *s1; // [rsp+80h] [rbp-D0h]
  _DWORD *v52; // [rsp+88h] [rbp-C8h]
  _DWORD *v53; // [rsp+90h] [rbp-C0h]
  unsigned __int8 *v54; // [rsp+98h] [rbp-B8h]
  void *v55; // [rsp+A0h] [rbp-B0h]
  unsigned __int64 v56; // [rsp+A8h] [rbp-A8h]
  char s; // [rsp+B0h] [rbp-A0h]
  _QWORD *v58; // [rsp+C8h] [rbp-88h]
  char v59; // [rsp+100h] [rbp-50h]
  _QWORD *v60; // [rsp+118h] [rbp-38h]
  unsigned __int64 v61; // [rsp+148h] [rbp-8h]

  v37 = a3;
  v36 = a4;
  v35 = a5;
  v61 = __readfsqword(0x28u);
  v52 = (_DWORD *)*a1;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  memset(&s, 0, 0x48uLL);
  memset(&v59, 0, 0x48uLL);
  v53 = calloc(1uLL, 0xA8uLL);
  if ( !v53 )
  {
    sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v5);
    return 0LL;
  }
  v53[14] = 16;
  *((_QWORD *)v53 + 11) = v53;
  v54 = (unsigned __int8 *)v53;
  if ( v36 & 2 )
  {
    v7 = 25;
  }
  else if ( v36 & 1 )
  {
    v7 = 19;
  }
  else
  {
    v7 = 23;
  }
  if ( (unsigned int)sub_51597(a1, a2, (__int64)v54, 1u, v37, v7, v35) )
    goto LABEL_213;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v37 + 48), *(_QWORD *)v54, v8, v9);
  v10 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v54, v36) )
    goto LABEL_213;
  for ( i = *(_QWORD **)(v37 + 24); ; i = v50 )
  {
    if ( i )
    {
      v50 = (_QWORD *)i[4];
      v18 = 1;
    }
    else
    {
      v18 = 0;
    }
    if ( !v18 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "container")
        || !strcmp((const char *)i[6], "leaf-list")
        || !strcmp((const char *)i[6], "leaf")
        || !strcmp((const char *)i[6], "list")
        || !strcmp((const char *)i[6], "choice")
        || !strcmp((const char *)i[6], "uses")
        || !strcmp((const char *)i[6], "grouping")
        || !strcmp((const char *)i[6], "anyxml")
        || !strcmp((const char *)i[6], "anydata")
        || !strcmp((const char *)i[6], "action")
        || !strcmp((const char *)i[6], "notification") )
      {
        sub_30B77((__int64)v52, i, 2);
        sub_3116F((__int64)v52, (__int64)&s, i);
      }
      else if ( !strcmp((const char *)i[6], "key") )
      {
        if ( *((_BYTE *)v53 + 30) )
        {
          sub_13937(v52, 14, 2u, (char *)v54, i[6], *(_QWORD *)v53);
          goto LABEL_213;
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937(v52, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_213;
        }
        v11 = lydict_insert(v52, s1, 0LL);
        *((_QWORD *)v53 + 20) = v11;
        while ( 1 )
        {
          s1 = strpbrk(s1, off_10F526);
          if ( !s1 )
            break;
          ++*((_BYTE *)v53 + 30);
          while ( (*__ctype_b_loc())[*s1] & 0x2000 )
            ++s1;
        }
        *((_QWORD *)v53 + 17) = calloc((unsigned __int8)++*((_BYTE *)v53 + 30), 8uLL);
        if ( !*((_QWORD *)v53 + 17) )
        {
          sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v12);
          goto LABEL_213;
        }
        if ( (unsigned int)sub_411CA(a1, (__int64)v54, 1u, i, 9, 0LL, v35) )
          goto LABEL_213;
        lyxml_free(v52, i);
      }
      else if ( !strcmp((const char *)i[6], "unique") )
      {
        if ( v41 == 255 )
        {
          sub_12222(
            (__int64)v52,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"uniques",
            "list");
          goto LABEL_213;
        }
        ++v41;
        sub_30B77((__int64)v52, i, 2);
        sub_3116F((__int64)v52, (__int64)&v59, i);
      }
      else if ( !strcmp((const char *)i[6], "typedef") )
      {
        if ( v39 == 255 )
        {
          sub_12222(
            (__int64)v52,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"typedefs",
            "list");
          goto LABEL_213;
        }
        ++v39;
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        if ( v40 == 255 )
        {
          sub_12222(
            (__int64)v52,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "list");
          goto LABEL_213;
        }
        ++v40;
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        if ( v42 == 255 )
        {
          sub_12222(
            (__int64)v52,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "list");
          goto LABEL_213;
        }
        ++v42;
      }
      else if ( !strcmp((const char *)i[6], "ordered-by") )
      {
        if ( v44 )
        {
          sub_13937(v52, 14, 2u, (char *)v54, i[6], *(_QWORD *)(v37 + 48));
          goto LABEL_213;
        }
        v44 = 1;
        if ( v53[6] & 2 )
        {
          lyxml_free(v52, i);
        }
        else
        {
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937(v52, 13, 0, 0LL, (__int64)"value", i[6]);
            goto LABEL_213;
          }
          if ( !strcmp(s1, "user") )
          {
            v13 = *((_WORD *)v53 + 12);
            HIBYTE(v13) |= 1u;
            *((_WORD *)v53 + 12) = v13;
          }
          else if ( strcmp(s1, "system") )
          {
            sub_13937(v52, 10, 2u, (char *)v54, (__int64)s1, i[6]);
            goto LABEL_213;
          }
          if ( (unsigned int)sub_411CA(a1, (__int64)v54, 1u, i, 25, 0LL, v35) )
            goto LABEL_213;
          lyxml_free(v52, i);
        }
      }
      else if ( !strcmp((const char *)i[6], "min-elements") )
      {
        if ( v46 )
        {
          sub_13937(v52, 14, 2u, (char *)v54, i[6], *(_QWORD *)(v37 + 48));
          goto LABEL_213;
        }
        v46 = 1;
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937(v52, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_213;
        }
        while ( (*__ctype_b_loc())[*s1] & 0x2000 )
          ++s1;
        *__errno_location() = 0;
        endptr = 0LL;
        v56 = strtoul(s1, &endptr, 10);
        if ( *endptr || *s1 == 45 || *__errno_location() || v56 > 0xFFFFFFFF )
        {
          sub_13937(v52, 10, 2u, (char *)v54, (__int64)s1, i[6]);
          goto LABEL_213;
        }
        v53[38] = v56;
        if ( v53[39] && v53[38] > v53[39] )
        {
          sub_13937(v52, 10, 2u, (char *)v54, (__int64)s1, i[6]);
          sub_13937(v52, -1, 5u, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v14);
          lyxml_free(v52, i);
          goto LABEL_213;
        }
        if ( (unsigned int)sub_411CA(a1, (__int64)v54, 1u, i, 29, 0LL, v35) )
          goto LABEL_213;
        lyxml_free(v52, i);
      }
      else if ( !strcmp((const char *)i[6], "max-elements") )
      {
        if ( v45 )
        {
          sub_13937(v52, 14, 2u, (char *)v54, i[6], *(_QWORD *)(v37 + 48));
          goto LABEL_213;
        }
        v45 = 1;
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937(v52, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_213;
        }
        while ( (*__ctype_b_loc())[*s1] & 0x2000 )
          ++s1;
        if ( !strcmp(s1, "unbounded") )
        {
          v53[39] = 0;
        }
        else
        {
          *__errno_location() = 0;
          endptr = 0LL;
          v56 = strtoul(s1, &endptr, 10);
          if ( *endptr || *s1 == 45 || *__errno_location() || !v56 || v56 > 0xFFFFFFFF )
          {
            sub_13937(v52, 10, 2u, (char *)v54, (__int64)s1, i[6]);
            goto LABEL_213;
          }
          v53[39] = v56;
          if ( v53[38] > v53[39] )
          {
            sub_13937(v52, 10, 2u, (char *)v54, (__int64)s1, i[6]);
            sub_13937(v52, -1, 5u, 0LL, (__int64)"\"max-elements\" is smaller than \"min-elements\".", v15);
            goto LABEL_213;
          }
        }
        if ( (unsigned int)sub_411CA(a1, (__int64)v54, 1u, i, 28, 0LL, v35) )
          goto LABEL_213;
        lyxml_free(v52, i);
      }
      else
      {
        if ( strcmp((const char *)i[6], "when") )
        {
          sub_13937(v52, 5, 2u, (char *)v54, i[6], v16);
          goto LABEL_213;
        }
        if ( *((_QWORD *)v53 + 14) )
        {
          sub_13937(v52, 14, 2u, (char *)v54, i[6], *(_QWORD *)(v37 + 48));
          goto LABEL_213;
        }
        v17 = sub_51F02(a1, (__int64)i, v35);
        *((_QWORD *)v53 + 14) = v17;
        if ( !*((_QWORD *)v53 + 14) )
        {
          lyxml_free(v52, i);
          goto LABEL_213;
        }
        lyxml_free(v52, i);
      }
    }
    else
    {
      if ( v43 == 255 )
      {
        sub_12222(
          (__int64)v52,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "list");
        goto LABEL_213;
      }
      ++v43;
    }
  }
  for ( j = v54; j && !(j[7] & 0x12800); j = (_QWORD *)j[8] )
    ;
  if ( !j && v53[6] & 1 && !*((_QWORD *)v53 + 20) )
  {
    sub_13937(v52, 12, 2u, (char *)v54, (__int64)"key", (__int64)"list");
    goto LABEL_213;
  }
  if ( v39 )
  {
    *((_QWORD *)v53 + 16) = calloc(v39, 0x80uLL);
    if ( !*((_QWORD *)v53 + 16) )
    {
      sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v19);
      goto LABEL_213;
    }
  }
  if ( v40 )
  {
    *((_QWORD *)v53 + 15) = calloc(v40, 0x38uLL);
    if ( !*((_QWORD *)v53 + 15) )
    {
      sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v20);
      goto LABEL_213;
    }
  }
  if ( v42 )
  {
    *((_QWORD *)v53 + 5) = calloc(v42, 0x20uLL);
    if ( !*((_QWORD *)v53 + 5) )
    {
      sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v21);
      goto LABEL_213;
    }
  }
  if ( v43 )
  {
    v55 = realloc(*((void **)v54 + 4), 8LL * (v54[26] + v43));
    if ( !v55 )
    {
      sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v22);
      goto LABEL_213;
    }
    *((_QWORD *)v54 + 4) = v55;
    memset((void *)(*((_QWORD *)v54 + 4) + 8LL * v54[26]), 0, 8LL * v43);
  }
  for ( i = *(_QWORD **)(v37 + 24); ; i = v50 )
  {
    if ( i )
    {
      v50 = (_QWORD *)i[4];
      v27 = 1;
    }
    else
    {
      v27 = 0;
    }
    if ( !v27 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "typedef") )
      {
        v24 = sub_4778E(
                a1,
                (__int64 *)v54,
                (__int64)i,
                *((_QWORD *)v53 + 16) + ((unsigned __int64)*((unsigned __int8 *)v53 + 29) << 7),
                v35);
        ++*((_BYTE *)v53 + 29);
        if ( v24 )
          goto LABEL_213;
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        v25 = sub_41746((__int64)v54, 0, (__int64)i, *((_QWORD *)v53 + 5) + 32LL * *((unsigned __int8 *)v53 + 27), v35);
        ++*((_BYTE *)v53 + 27);
        if ( v25 )
          goto LABEL_213;
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        v26 = sub_489FC(a1, (__int64)i, (__int64 *)(*((_QWORD *)v53 + 15) + 56LL * *((unsigned __int8 *)v53 + 28)), v35);
        ++*((_BYTE *)v53 + 28);
        if ( v26 )
          goto LABEL_213;
      }
    }
    else
    {
      v23 = sub_40F96((__int64)v54, 1, 0, 0, a1, (__int64)i, (__int64 *)v54 + 4, v54[26], v35);
      ++v54[26];
      if ( v23 )
        goto LABEL_213;
    }
  }
  for ( i = v58; ; i = v50 )
  {
    if ( i )
    {
      v50 = (_QWORD *)i[4];
      v29 = 1;
    }
    else
    {
      v29 = 0;
    }
    if ( !v29 )
      break;
    if ( !strcmp((const char *)i[6], "container") )
    {
      j = sub_587B3(a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "leaf-list") )
    {
      j = (_QWORD *)sub_551D2((__int64)a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "leaf") )
    {
      j = sub_54422(a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "list") )
    {
      j = (_QWORD *)sub_56721(a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "choice") )
    {
      j = sub_52E00((__int64)a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "uses") )
    {
      j = sub_5CBDA(a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "grouping") )
    {
      j = sub_599C2(a1, (char *)v54, (__int64)i, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "anyxml") )
    {
      j = sub_53A72(a1, (char *)v54, (__int64)i, 32, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "anydata") )
    {
      j = sub_53A72(a1, (char *)v54, (__int64)i, 32800, v36, v35);
    }
    else if ( !strcmp((const char *)i[6], "action") )
    {
      j = sub_5C028((__int64)a1, (char *)v54, (__int64)i, v36, v35);
    }
    else
    {
      if ( strcmp((const char *)i[6], "notification") )
      {
        sub_12222(
          (__int64)v52,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser_yin.c",
          5484LL);
        goto LABEL_213;
      }
      j = sub_5B1D8((__int64)a1, (char *)v54, (__int64)i, v36, v35, v28);
    }
    if ( !j )
      goto LABEL_213;
    lyxml_free(v52, i);
  }
  if ( *((_QWORD *)v53 + 20) && (unsigned int)sub_2ABDE(a1, v35, (__int64 *)v53, 0x2000u, 0LL) == -1 )
    goto LABEL_213;
  if ( v41 )
  {
    *((_QWORD *)v53 + 18) = calloc(v41, 0x10uLL);
    if ( !*((_QWORD *)v53 + 18) )
    {
      sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_list", v30);
      goto LABEL_213;
    }
    for ( i = v60; ; i = v50 )
    {
      if ( i )
      {
        v50 = (_QWORD *)i[4];
        v32 = 1;
      }
      else
      {
        v32 = 0;
      }
      if ( !v32 )
        break;
      v31 = sub_48E4C(a1, (__int64)v54, (__int64)i, *((_QWORD *)v53 + 18) + 16LL * *((unsigned __int8 *)v53 + 31), v35);
      ++*((_BYTE *)v53 + 31);
      if ( v31 || (unsigned int)sub_411CA(a1, (__int64)v54, 1u, i, 31, (unsigned __int8)(*((_BYTE *)v53 + 31) - 1), v35) )
        goto LABEL_213;
      lyxml_free(v52, i);
    }
  }
  if ( !(v52[23] & 2) && (*((_QWORD *)v53 + 14) || *((_QWORD *)v53 + 15)) )
  {
    if ( v36 & 4 )
    {
      if ( (unsigned int)sub_DDEA9((__int64)v54) )
      {
LABEL_213:
        sub_A33A0((_QWORD **)v54, 0LL, 0);
        while ( v58 )
          lyxml_free(v52, v58);
        while ( v60 )
          lyxml_free(v52, v60);
        return 0LL;
      }
    }
    else if ( (unsigned int)sub_2ABDE(a1, v35, (__int64 *)v54, 0x20000u, 0LL) == -1 )
    {
      goto LABEL_213;
    }
  }
  for ( k = 0; k < v54[26]; ++k )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * k + *((_QWORD *)v54 + 4)) + 24LL) & 8 )
    {
      v33 = *((_WORD *)v54 + 12);
      HIBYTE(v33) |= 0x20u;
      *((_WORD *)v54 + 12) = v33;
      if ( *(_WORD *)(*(_QWORD *)(8LL * k + *((_QWORD *)v54 + 4)) + 24LL) & 0x10 )
      {
        v34 = *((_WORD *)v54 + 12);
        HIBYTE(v34) |= 0x40u;
        *((_WORD *)v54 + 12) = v34;
        return v54;
      }
    }
  }
  return v54;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000587B3) ----------------------------------------------------
unsigned __int8 *__fastcall sub_587B3(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  char v7; // al
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  size_t v11; // rax
  __int64 v12; // r9
  char v13; // al
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  __int64 v17; // r9
  _BOOL4 v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  char v22; // al
  __int64 v23; // r9
  char v24; // al
  __int16 v25; // ax
  __int16 v26; // ax
  __int64 v27; // [rsp+8h] [rbp-D8h]
  unsigned int v28; // [rsp+14h] [rbp-CCh]
  __int64 v29; // [rsp+18h] [rbp-C8h]
  signed int l; // [rsp+3Ch] [rbp-A4h]
  int v31; // [rsp+40h] [rbp-A0h]
  int v32; // [rsp+44h] [rbp-9Ch]
  int v33; // [rsp+48h] [rbp-98h]
  int v34; // [rsp+4Ch] [rbp-94h]
  _QWORD *i; // [rsp+50h] [rbp-90h]
  __int64 j; // [rsp+50h] [rbp-90h]
  __int64 k; // [rsp+50h] [rbp-90h]
  _QWORD *v38; // [rsp+58h] [rbp-88h]
  __int64 v39; // [rsp+60h] [rbp-80h]
  _DWORD *v40; // [rsp+68h] [rbp-78h]
  unsigned __int8 *v41; // [rsp+70h] [rbp-70h]
  void *v42; // [rsp+80h] [rbp-60h]
  char *v43; // [rsp+88h] [rbp-58h]
  char s; // [rsp+90h] [rbp-50h]
  __int64 v45; // [rsp+A8h] [rbp-38h]
  unsigned __int64 v46; // [rsp+D8h] [rbp-8h]

  v29 = a3;
  v28 = a4;
  v27 = a5;
  v46 = __readfsqword(0x28u);
  v40 = (_DWORD *)*a1;
  v39 = 0LL;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  memset(&s, 0, 0x48uLL);
  v41 = (unsigned __int8 *)calloc(1uLL, 0x90uLL);
  if ( !v41 )
  {
    sub_12222((__int64)v40, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_container", v5);
    return 0LL;
  }
  *((_DWORD *)v41 + 14) = 1;
  *((_QWORD *)v41 + 11) = v41;
  if ( v28 & 2 )
  {
    v7 = 25;
  }
  else if ( v28 & 1 )
  {
    v7 = 19;
  }
  else
  {
    v7 = 23;
  }
  if ( (unsigned int)sub_51597(a1, a2, (__int64)v41, 1u, v29, v7, v27) )
    goto LABEL_131;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v29 + 48), *(_QWORD *)v41, v8, v9);
  v10 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v41, v28) )
    goto LABEL_131;
  for ( i = *(_QWORD **)(v29 + 24); ; i = v38 )
  {
    if ( i )
    {
      v38 = (_QWORD *)i[4];
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
    if ( !v13 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "presence") )
      {
        if ( *((_QWORD *)v41 + 17) )
        {
          sub_13937(v40, 14, 2u, (char *)v41, i[6], *(_QWORD *)(v29 + 48));
          goto LABEL_131;
        }
        v43 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !v43 )
        {
          sub_13937(v40, 13, 0, 0LL, (__int64)"value", i[6]);
          goto LABEL_131;
        }
        v11 = strlen(v43);
        *((_QWORD *)v41 + 17) = lydict_insert(v40, v43, v11);
        if ( (unsigned int)sub_411CA(a1, (__int64)v41, 1u, i, 14, 0LL, v27) )
          goto LABEL_131;
        lyxml_free(v40, i);
      }
      else if ( !strcmp((const char *)i[6], "when") )
      {
        if ( *((_QWORD *)v41 + 14) )
        {
          sub_13937(v40, 14, 2u, (char *)v41, i[6], *(_QWORD *)(v29 + 48));
          goto LABEL_131;
        }
        *((_QWORD *)v41 + 14) = sub_51F02(a1, (__int64)i, v27);
        if ( !*((_QWORD *)v41 + 14) )
        {
          lyxml_free(v40, i);
          goto LABEL_131;
        }
        lyxml_free(v40, i);
      }
      else if ( !strcmp((const char *)i[6], "container")
             || !strcmp((const char *)i[6], "leaf-list")
             || !strcmp((const char *)i[6], "leaf")
             || !strcmp((const char *)i[6], "list")
             || !strcmp((const char *)i[6], "choice")
             || !strcmp((const char *)i[6], "uses")
             || !strcmp((const char *)i[6], "grouping")
             || !strcmp((const char *)i[6], "anyxml")
             || !strcmp((const char *)i[6], "anydata")
             || !strcmp((const char *)i[6], "action")
             || !strcmp((const char *)i[6], "notification") )
      {
        sub_30B77((__int64)v40, i, 2);
        sub_3116F((__int64)v40, (__int64)&s, i);
      }
      else if ( !strcmp((const char *)i[6], "typedef") )
      {
        if ( v31 == 0xFFFF )
        {
          sub_12222(
            (__int64)v40,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            0xFFFFLL,
            (__int64)"typedefs",
            "container");
          goto LABEL_131;
        }
        ++v31;
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        if ( v32 == 255 )
        {
          sub_12222(
            (__int64)v40,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "container");
          goto LABEL_131;
        }
        ++v32;
      }
      else
      {
        if ( strcmp((const char *)i[6], "if-feature") )
        {
          sub_13937(v40, 5, 2u, (char *)v41, i[6], v12);
          goto LABEL_131;
        }
        if ( v33 == 255 )
        {
          sub_12222(
            (__int64)v40,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "container");
          goto LABEL_131;
        }
        ++v33;
      }
    }
    else
    {
      if ( v34 == 255 )
      {
        sub_12222(
          (__int64)v40,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "container");
        goto LABEL_131;
      }
      ++v34;
    }
  }
  if ( v31 )
  {
    *((_QWORD *)v41 + 16) = calloc(v31, 0x80uLL);
    if ( !*((_QWORD *)v41 + 16) )
    {
      sub_12222((__int64)v40, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_container", v14);
      goto LABEL_131;
    }
  }
  if ( v32 )
  {
    *((_QWORD *)v41 + 15) = calloc(v32, 0x38uLL);
    if ( !*((_QWORD *)v41 + 15) )
    {
      sub_12222((__int64)v40, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_container", v15);
      goto LABEL_131;
    }
  }
  if ( v33 )
  {
    *((_QWORD *)v41 + 5) = calloc(v33, 0x20uLL);
    if ( !*((_QWORD *)v41 + 5) )
    {
      sub_12222((__int64)v40, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_container", v16);
      goto LABEL_131;
    }
  }
  if ( v34 )
  {
    v42 = realloc(*((void **)v41 + 4), 8LL * (v41[26] + v34));
    if ( !v42 )
    {
      sub_12222((__int64)v40, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_container", v17);
      goto LABEL_131;
    }
    *((_QWORD *)v41 + 4) = v42;
    memset((void *)(*((_QWORD *)v41 + 4) + 8LL * v41[26]), 0, 8LL * v34);
  }
  for ( j = *(_QWORD *)(v29 + 24); ; j = (__int64)v38 )
  {
    if ( j )
    {
      v38 = *(_QWORD **)(j + 32);
      v22 = 1;
    }
    else
    {
      v22 = 0;
    }
    if ( !v22 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp(*(const char **)(j + 48), "typedef") )
      {
        v19 = sub_4778E(
                a1,
                (__int64 *)v41,
                j,
                *((_QWORD *)v41 + 16) + ((unsigned __int64)*((unsigned __int16 *)v41 + 15) << 7),
                v27);
        ++*((_WORD *)v41 + 15);
        if ( v19 )
          goto LABEL_131;
      }
      else if ( !strcmp(*(const char **)(j + 48), "must") )
      {
        v20 = sub_489FC(a1, j, (__int64 *)(*((_QWORD *)v41 + 15) + 56LL * v41[29]), v27);
        ++v41[29];
        if ( v20 )
          goto LABEL_131;
      }
      else if ( !strcmp(*(const char **)(j + 48), "if-feature") )
      {
        v21 = sub_41746((__int64)v41, 0, j, *((_QWORD *)v41 + 5) + 32LL * v41[27], v27);
        ++v41[27];
        if ( v21 )
          goto LABEL_131;
      }
    }
    else
    {
      v18 = sub_40F96((__int64)v41, 1, 0, 0, a1, j, (__int64 *)v41 + 4, v41[26], v27);
      ++v41[26];
      if ( v18 )
        goto LABEL_131;
    }
  }
  for ( k = v45; ; k = (__int64)v38 )
  {
    if ( k )
    {
      v38 = *(_QWORD **)(k + 32);
      v24 = 1;
    }
    else
    {
      v24 = 0;
    }
    if ( !v24 )
      break;
    if ( !strcmp(*(const char **)(k + 48), "container") )
    {
      v39 = (__int64)sub_587B3(a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf-list") )
    {
      v39 = sub_551D2((__int64)a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf") )
    {
      v39 = (__int64)sub_54422(a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "list") )
    {
      v39 = (__int64)sub_56721(a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "choice") )
    {
      v39 = (__int64)sub_52E00((__int64)a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "uses") )
    {
      v39 = (__int64)sub_5CBDA(a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "grouping") )
    {
      v39 = (__int64)sub_599C2(a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anyxml") )
    {
      v39 = (__int64)sub_53A72(a1, (char *)v41, k, 32, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anydata") )
    {
      v39 = (__int64)sub_53A72(a1, (char *)v41, k, 32800, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "action") )
    {
      v39 = (__int64)sub_5C028((__int64)a1, (char *)v41, k, v28, v27);
    }
    else if ( !strcmp(*(const char **)(k + 48), "notification") )
    {
      v39 = (__int64)sub_5B1D8((__int64)a1, (char *)v41, k, v28, v27, v23);
    }
    if ( !v39 )
      goto LABEL_131;
    lyxml_free(v40, k);
  }
  if ( !(v40[23] & 2) && (*((_QWORD *)v41 + 14) || *((_QWORD *)v41 + 15)) )
  {
    if ( v28 & 4 )
    {
      if ( (unsigned int)sub_DDEA9((__int64)v41) )
      {
LABEL_131:
        sub_A33A0((_QWORD **)v41, 0LL, 0);
        while ( v45 )
          lyxml_free(v40, v45);
        return 0LL;
      }
    }
    else if ( (unsigned int)sub_2ABDE(a1, v27, (__int64 *)v41, 0x20000u, 0LL) == -1 )
    {
      goto LABEL_131;
    }
  }
  for ( l = 0; l < v41[26]; ++l )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * l + *((_QWORD *)v41 + 4)) + 24LL) & 8 )
    {
      v25 = *((_WORD *)v41 + 12);
      HIBYTE(v25) |= 0x20u;
      *((_WORD *)v41 + 12) = v25;
      if ( *(_WORD *)(*(_QWORD *)(8LL * l + *((_QWORD *)v41 + 4)) + 24LL) & 0x10 )
      {
        v26 = *((_WORD *)v41 + 12);
        HIBYTE(v26) |= 0x40u;
        *((_WORD *)v41 + 12) = v26;
        return v41;
      }
    }
  }
  return v41;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000599C2) ----------------------------------------------------
unsigned __int8 *__fastcall sub_599C2(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *v9; // rax
  __int64 v10; // r9
  char v11; // al
  __int64 v12; // r9
  _BOOL4 v13; // eax
  int v14; // eax
  char v15; // al
  __int64 v16; // r9
  char v17; // al
  __int64 v18; // [rsp+8h] [rbp-C8h]
  unsigned int v19; // [rsp+14h] [rbp-BCh]
  int v20; // [rsp+14h] [rbp-BCh]
  __int64 v21; // [rsp+18h] [rbp-B8h]
  int v22; // [rsp+3Ch] [rbp-94h]
  int v23; // [rsp+40h] [rbp-90h]
  _QWORD *i; // [rsp+48h] [rbp-88h]
  __int64 j; // [rsp+48h] [rbp-88h]
  __int64 k; // [rsp+48h] [rbp-88h]
  _QWORD *v27; // [rsp+50h] [rbp-80h]
  __int64 v28; // [rsp+58h] [rbp-78h]
  void *v29; // [rsp+60h] [rbp-70h]
  unsigned __int8 *v30; // [rsp+68h] [rbp-68h]
  void *v31; // [rsp+78h] [rbp-58h]
  char s; // [rsp+80h] [rbp-50h]
  __int64 v33; // [rsp+98h] [rbp-38h]
  unsigned __int64 v34; // [rsp+C8h] [rbp-8h]

  v21 = a3;
  v19 = a4;
  v18 = a5;
  v34 = __readfsqword(0x28u);
  v29 = (void *)*a1;
  v28 = 0LL;
  v22 = 0;
  v23 = 0;
  memset(&s, 0, 0x48uLL);
  v30 = (unsigned __int8 *)calloc(1uLL, 0x70uLL);
  if ( !v30 )
  {
    sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_grouping", v5);
    return 0LL;
  }
  *((_DWORD *)v30 + 14) = 2048;
  *((_QWORD *)v30 + 11) = v30;
  if ( (unsigned int)sub_51597(a1, a2, (__int64)v30, 1u, v21, 17, v18) )
    goto LABEL_81;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v21 + 48), *(_QWORD *)v30, v7, v8);
  v9 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v9, (__int64)v30, v19) )
    goto LABEL_81;
  for ( i = *(_QWORD **)(v21 + 24); ; i = v27 )
  {
    if ( i )
    {
      v27 = (_QWORD *)i[4];
      v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    if ( !v11 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "container")
        || !strcmp((const char *)i[6], "leaf-list")
        || !strcmp((const char *)i[6], "leaf")
        || !strcmp((const char *)i[6], "list")
        || !strcmp((const char *)i[6], "choice")
        || !strcmp((const char *)i[6], "uses")
        || !strcmp((const char *)i[6], "grouping")
        || !strcmp((const char *)i[6], "anyxml")
        || !strcmp((const char *)i[6], "anydata")
        || !strcmp((const char *)i[6], "action")
        || !strcmp((const char *)i[6], "notification") )
      {
        sub_30B77((__int64)v29, i, 2);
        sub_3116F((__int64)v29, (__int64)&s, i);
      }
      else
      {
        if ( strcmp((const char *)i[6], "typedef") )
        {
          sub_13937(v29, 5, 2u, (char *)v30, i[6], v10);
          goto LABEL_81;
        }
        if ( v22 == 0xFFFF )
        {
          sub_12222(
            (__int64)v29,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            0xFFFFLL,
            (__int64)"typedefs",
            "grouping");
          goto LABEL_81;
        }
        ++v22;
      }
    }
    else
    {
      if ( v23 == 255 )
      {
        sub_12222(
          (__int64)v29,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "grouping");
        goto LABEL_81;
      }
      ++v23;
    }
  }
  if ( v22 )
  {
    *((_QWORD *)v30 + 13) = calloc(v22, 0x80uLL);
    if ( !*((_QWORD *)v30 + 13) )
    {
      sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_grouping", v10);
      goto LABEL_81;
    }
  }
  if ( v23 )
  {
    v31 = realloc(*((void **)v30 + 4), 8LL * (v30[26] + v23));
    if ( !v31 )
    {
      sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_grouping", v12);
LABEL_81:
      sub_A33A0((_QWORD **)v30, 0LL, 0);
      while ( v33 )
        lyxml_free(v29, v33);
      return 0LL;
    }
    *((_QWORD *)v30 + 4) = v31;
    memset((void *)(*((_QWORD *)v30 + 4) + 8LL * v30[26]), 0, 8LL * v23);
  }
  for ( j = *(_QWORD *)(v21 + 24); ; j = (__int64)v27 )
  {
    if ( j )
    {
      v27 = *(_QWORD **)(j + 32);
      v15 = 1;
    }
    else
    {
      v15 = 0;
    }
    if ( !v15 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      v14 = sub_4778E(
              a1,
              (__int64 *)v30,
              j,
              *((_QWORD *)v30 + 13) + ((unsigned __int64)*((unsigned __int16 *)v30 + 15) << 7),
              v18);
      ++*((_WORD *)v30 + 15);
      if ( v14 )
        goto LABEL_81;
    }
    else
    {
      v13 = sub_40F96((__int64)v30, 1, 0, 0, a1, j, (__int64 *)v30 + 4, v30[26], v18);
      ++v30[26];
      if ( v13 )
        goto LABEL_81;
    }
  }
  if ( !v33 )
    sub_12222((__int64)v29, 1u, 0, "Grouping \"%s\" without children.", *(_QWORD *)v30, v10);
  v20 = v19 | 4;
  for ( k = v33; ; k = (__int64)v27 )
  {
    if ( k )
    {
      v27 = *(_QWORD **)(k + 32);
      v17 = 1;
    }
    else
    {
      v17 = 0;
    }
    if ( !v17 )
      break;
    if ( !strcmp(*(const char **)(k + 48), "container") )
    {
      v28 = (__int64)sub_587B3(a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf-list") )
    {
      v28 = sub_551D2((__int64)a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf") )
    {
      v28 = (__int64)sub_54422(a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "list") )
    {
      v28 = (__int64)sub_56721(a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "choice") )
    {
      v28 = (__int64)sub_52E00((__int64)a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "uses") )
    {
      v28 = (__int64)sub_5CBDA(a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "grouping") )
    {
      v28 = (__int64)sub_599C2(a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anyxml") )
    {
      v28 = (__int64)sub_53A72(a1, (char *)v30, k, 32, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anydata") )
    {
      v28 = (__int64)sub_53A72(a1, (char *)v30, k, 32800, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "action") )
    {
      v28 = (__int64)sub_5C028((__int64)a1, (char *)v30, k, v20, v18);
    }
    else if ( !strcmp(*(const char **)(k + 48), "notification") )
    {
      v28 = (__int64)sub_5B1D8((__int64)a1, (char *)v30, k, v20, v18, v16);
    }
    if ( !v28 )
      goto LABEL_81;
    lyxml_free(v29, k);
  }
  return v30;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000005A553) ----------------------------------------------------
unsigned __int8 *__fastcall sub_5A553(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *v9; // rax
  const char *v10; // rax
  __int64 v11; // r9
  const char *v12; // rax
  const char *v13; // rax
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // r9
  __int64 v17; // r9
  _BOOL4 v18; // eax
  int v19; // eax
  int v20; // eax
  char v21; // al
  char v22; // al
  __int64 v23; // [rsp+8h] [rbp-B8h]
  unsigned int v24; // [rsp+14h] [rbp-ACh]
  int v25; // [rsp+14h] [rbp-ACh]
  __int64 v26; // [rsp+18h] [rbp-A8h]
  int v27; // [rsp+30h] [rbp-90h]
  int v28; // [rsp+34h] [rbp-8Ch]
  int v29; // [rsp+38h] [rbp-88h]
  _QWORD *i; // [rsp+40h] [rbp-80h]
  __int64 j; // [rsp+40h] [rbp-80h]
  __int64 k; // [rsp+40h] [rbp-80h]
  _QWORD *v33; // [rsp+48h] [rbp-78h]
  __int64 v34; // [rsp+50h] [rbp-70h]
  _QWORD **v35; // [rsp+58h] [rbp-68h]
  _DWORD *v36; // [rsp+60h] [rbp-60h]
  unsigned __int8 *ptr; // [rsp+68h] [rbp-58h]
  char s; // [rsp+70h] [rbp-50h]
  __int64 v39; // [rsp+88h] [rbp-38h]
  unsigned __int64 v40; // [rsp+B8h] [rbp-8h]

  v26 = a3;
  v24 = a4;
  v23 = a5;
  v40 = __readfsqword(0x28u);
  v36 = *(_DWORD **)a1;
  v34 = 0LL;
  v35 = 0LL;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  memset(&s, 0, 0x48uLL);
  ptr = (unsigned __int8 *)calloc(1uLL, 0x78uLL);
  if ( !ptr )
  {
    sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_input_output", v5);
    return 0LL;
  }
  *((_QWORD *)ptr + 11) = ptr;
  if ( !strcmp(*(const char **)(v26 + 48), "input") )
  {
    *((_DWORD *)ptr + 14) = 512;
    *(_QWORD *)ptr = lydict_insert(v36, "input", 0LL);
  }
  else
  {
    if ( strcmp(*(const char **)(v26 + 48), "output") )
    {
      sub_12222(
        (__int64)v36,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yin.c",
        5949LL);
      free(ptr);
      goto LABEL_104;
    }
    *((_DWORD *)ptr + 14) = 1024;
    *(_QWORD *)ptr = lydict_insert(v36, "output", 0LL);
  }
  v35 = (_QWORD **)ptr;
  *((_QWORD *)ptr + 6) = a1;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v26 + 48), *(_QWORD *)ptr, v7, v8);
  v9 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637(a2, v9, (__int64)ptr, v24) )
  {
LABEL_104:
    sub_A33A0(v35, 0LL, 0);
    while ( v39 )
      lyxml_free(v36, v39);
    return 0LL;
  }
  for ( i = *(_QWORD **)(v26 + 24); ; i = v33 )
  {
    if ( i )
    {
      v33 = (_QWORD *)i[4];
      v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    if ( !v14 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "container")
          || !strcmp((const char *)i[6], "leaf-list")
          || !strcmp((const char *)i[6], "leaf")
          || !strcmp((const char *)i[6], "list")
          || !strcmp((const char *)i[6], "choice")
          || !strcmp((const char *)i[6], "uses")
          || !strcmp((const char *)i[6], "grouping")
          || !strcmp((const char *)i[6], "anyxml")
          || !strcmp((const char *)i[6], "anydata") )
        {
          sub_30B77((__int64)v36, i, 2);
          sub_3116F((__int64)v36, (__int64)&s, i);
        }
        else if ( !strcmp((const char *)i[6], "typedef") )
        {
          if ( v27 == 0xFFFF )
          {
            if ( *((_DWORD *)ptr + 14) == 512 )
              v12 = "input";
            else
              v12 = "output";
            sub_12222(
              (__int64)v36,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              0xFFFFLL,
              (__int64)"typedefs",
              v12);
            goto LABEL_104;
          }
          ++v27;
        }
        else
        {
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)i[6], "must") )
          {
            sub_13937(v36, 5, 2u, (char *)ptr, i[6], v11);
            goto LABEL_104;
          }
          if ( v28 == 255 )
          {
            if ( *((_DWORD *)ptr + 14) == 512 )
              v13 = "input";
            else
              v13 = "output";
            sub_12222(
              (__int64)v36,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"musts",
              v13);
            goto LABEL_104;
          }
          ++v28;
        }
      }
      else
      {
        if ( v29 == 255 )
        {
          if ( *((_DWORD *)ptr + 14) == 512 )
            v10 = "input";
          else
            v10 = "output";
          sub_12222(
            (__int64)v36,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            v10);
          goto LABEL_104;
        }
        ++v29;
      }
    }
    else
    {
      lyxml_free(v36, i);
    }
  }
  if ( v27 )
  {
    *((_QWORD *)ptr + 13) = calloc(v27, 0x80uLL);
    if ( !*((_QWORD *)ptr + 13) )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_input_output", v15);
      goto LABEL_104;
    }
  }
  if ( v28 )
  {
    *((_QWORD *)ptr + 14) = calloc(v28, 0x38uLL);
    if ( !*((_QWORD *)ptr + 14) )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_input_output", v16);
      goto LABEL_104;
    }
  }
  if ( v29 )
  {
    *((_QWORD *)ptr + 4) = calloc(v29, 8uLL);
    if ( !*((_QWORD *)ptr + 4) )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_input_output", v17);
      goto LABEL_104;
    }
  }
  for ( j = *(_QWORD *)(v26 + 24); ; j = (__int64)v33 )
  {
    if ( j )
    {
      v33 = *(_QWORD **)(j + 32);
      v21 = 1;
    }
    else
    {
      v21 = 0;
    }
    if ( !v21 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp(*(const char **)(j + 48), "must") )
      {
        v19 = sub_489FC((__int64 *)a1, j, (__int64 *)(*((_QWORD *)ptr + 14) + 56LL * ptr[29]), v23);
        ++ptr[29];
        if ( v19 )
          goto LABEL_104;
      }
      else
      {
        v20 = sub_4778E(
                (__int64 *)a1,
                (__int64 *)ptr,
                j,
                *((_QWORD *)ptr + 13) + ((unsigned __int64)*((unsigned __int16 *)ptr + 15) << 7),
                v23);
        ++*((_WORD *)ptr + 15);
        if ( v20 )
          goto LABEL_104;
      }
    }
    else
    {
      v18 = sub_40F96((__int64)ptr, 1, 0, 0, (__int64 *)a1, j, (__int64 *)ptr + 4, ptr[26], v23);
      ++ptr[26];
      if ( v18 )
        goto LABEL_104;
    }
  }
  v25 = v24 | 2;
  for ( k = v39; ; k = (__int64)v33 )
  {
    if ( k )
    {
      v33 = *(_QWORD **)(k + 32);
      v22 = 1;
    }
    else
    {
      v22 = 0;
    }
    if ( !v22 )
      break;
    if ( !strcmp(*(const char **)(k + 48), "container") )
    {
      v34 = (__int64)sub_587B3((__int64 *)a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf-list") )
    {
      v34 = sub_551D2(a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf") )
    {
      v34 = (__int64)sub_54422((__int64 *)a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "list") )
    {
      v34 = (__int64)sub_56721((__int64 *)a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "choice") )
    {
      v34 = (__int64)sub_52E00(a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "uses") )
    {
      v34 = (__int64)sub_5CBDA((__int64 *)a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "grouping") )
    {
      v34 = (__int64)sub_599C2((__int64 *)a1, (char *)ptr, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anyxml") )
    {
      v34 = (__int64)sub_53A72((__int64 *)a1, (char *)ptr, k, 32, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anydata") )
    {
      v34 = (__int64)sub_53A72((__int64 *)a1, (char *)ptr, k, 32800, v25, v23);
    }
    if ( !v34 )
      goto LABEL_104;
    lyxml_free(v36, k);
  }
  if ( !(v36[23] & 2) && *((_QWORD *)ptr + 14) )
  {
    if ( v25 & 4 )
    {
      if ( (unsigned int)sub_DDEA9((__int64)ptr) )
        goto LABEL_104;
    }
    else if ( (unsigned int)sub_2ABDE((__int64 *)a1, v23, (__int64 *)ptr, 0x20000u, 0LL) == -1 )
    {
      goto LABEL_104;
    }
  }
  return ptr;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000005B1D8) ----------------------------------------------------
unsigned __int8 *__fastcall sub_5B1D8(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  __int64 v11; // r9
  char v12; // al
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  _BOOL4 v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  char v21; // al
  char v22; // al
  __int64 v23; // [rsp+8h] [rbp-C8h]
  unsigned int v24; // [rsp+14h] [rbp-BCh]
  int v25; // [rsp+14h] [rbp-BCh]
  __int64 v26; // [rsp+18h] [rbp-B8h]
  int v27; // [rsp+34h] [rbp-9Ch]
  int v28; // [rsp+38h] [rbp-98h]
  int v29; // [rsp+3Ch] [rbp-94h]
  int v30; // [rsp+40h] [rbp-90h]
  _QWORD *i; // [rsp+48h] [rbp-88h]
  __int64 j; // [rsp+48h] [rbp-88h]
  __int64 k; // [rsp+48h] [rbp-88h]
  _QWORD *v34; // [rsp+50h] [rbp-80h]
  __int64 v35; // [rsp+58h] [rbp-78h]
  _DWORD *v36; // [rsp+60h] [rbp-70h]
  unsigned __int8 *v37; // [rsp+68h] [rbp-68h]
  void *v38; // [rsp+78h] [rbp-58h]
  char s; // [rsp+80h] [rbp-50h]
  __int64 v40; // [rsp+98h] [rbp-38h]
  unsigned __int64 v41; // [rsp+C8h] [rbp-8h]

  v26 = a3;
  v24 = a4;
  v23 = a5;
  v41 = __readfsqword(0x28u);
  v36 = *(_DWORD **)a1;
  v35 = 0LL;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  if ( a2 && ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
  {
    sub_13937(v36, 5, 2u, a2, (__int64)"notification", a6);
    return 0LL;
  }
  memset(&s, 0, 0x48uLL);
  v37 = (unsigned __int8 *)calloc(1uLL, 0x80uLL);
  if ( !v37 )
  {
    sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_notif", v7);
    return 0LL;
  }
  *((_DWORD *)v37 + 14) = 128;
  *((_QWORD *)v37 + 11) = v37;
  if ( (unsigned int)sub_51597((__int64 *)a1, a2, (__int64)v37, 1u, v26, 17, v23) )
    goto LABEL_104;
  sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v26 + 48), *(_QWORD *)v37, v8, v9);
  v10 = (_QWORD *)lys_main_module(a1);
  if ( (unsigned int)sub_9C637((__int64)a2, v10, (__int64)v37, v24) )
    goto LABEL_104;
  for ( i = *(_QWORD **)(v26 + 24); ; i = v34 )
  {
    if ( i )
    {
      v34 = (_QWORD *)i[4];
      v12 = 1;
    }
    else
    {
      v12 = 0;
    }
    if ( !v12 )
      break;
    if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp((const char *)i[6], "container")
        || !strcmp((const char *)i[6], "leaf-list")
        || !strcmp((const char *)i[6], "leaf")
        || !strcmp((const char *)i[6], "list")
        || !strcmp((const char *)i[6], "choice")
        || !strcmp((const char *)i[6], "uses")
        || !strcmp((const char *)i[6], "grouping")
        || !strcmp((const char *)i[6], "anyxml")
        || !strcmp((const char *)i[6], "anydata") )
      {
        sub_30B77((__int64)v36, i, 2);
        sub_3116F((__int64)v36, (__int64)&s, i);
      }
      else if ( !strcmp((const char *)i[6], "typedef") )
      {
        if ( v27 == 0xFFFF )
        {
          sub_12222(
            (__int64)v36,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            0xFFFFLL,
            (__int64)"typedefs",
            "notification");
          goto LABEL_104;
        }
        ++v27;
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        if ( v28 == 255 )
        {
          sub_12222(
            (__int64)v36,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"if-features",
            "notification");
          goto LABEL_104;
        }
        ++v28;
      }
      else
      {
        if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 || strcmp((const char *)i[6], "must") )
        {
          sub_13937(v36, 5, 2u, (char *)v37, i[6], v11);
          goto LABEL_104;
        }
        if ( v29 == 255 )
        {
          sub_12222(
            (__int64)v36,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"musts",
            "notification");
          goto LABEL_104;
        }
        ++v29;
      }
    }
    else
    {
      if ( v30 == 255 )
      {
        sub_12222(
          (__int64)v36,
          0,
          4,
          "Reached limit (%lu) for storing %s in %s statement.",
          255LL,
          (__int64)"extensions",
          "notification");
        goto LABEL_104;
      }
      ++v30;
    }
  }
  if ( v27 )
  {
    *((_QWORD *)v37 + 14) = calloc(v27, 0x80uLL);
    if ( !*((_QWORD *)v37 + 14) )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_notif", v13);
      goto LABEL_104;
    }
  }
  if ( v28 )
  {
    *((_QWORD *)v37 + 5) = calloc(v28, 0x20uLL);
    if ( !*((_QWORD *)v37 + 5) )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_notif", v14);
      goto LABEL_104;
    }
  }
  if ( v29 )
  {
    *((_QWORD *)v37 + 15) = calloc(v29, 0x38uLL);
    if ( !*((_QWORD *)v37 + 15) )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_notif", v15);
      goto LABEL_104;
    }
  }
  if ( v30 )
  {
    v38 = realloc(*((void **)v37 + 4), 8LL * (v37[26] + v30));
    if ( !v38 )
    {
      sub_12222((__int64)v36, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_notif", v16);
      goto LABEL_104;
    }
    *((_QWORD *)v37 + 4) = v38;
    memset((void *)(*((_QWORD *)v37 + 4) + 8LL * v37[26]), 0, 8LL * v30);
  }
  for ( j = *(_QWORD *)(v26 + 24); ; j = (__int64)v34 )
  {
    if ( j )
    {
      v34 = *(_QWORD **)(j + 32);
      v21 = 1;
    }
    else
    {
      v21 = 0;
    }
    if ( !v21 )
      break;
    if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( !strcmp(*(const char **)(j + 48), "typedef") )
      {
        v18 = sub_4778E(
                (__int64 *)a1,
                (__int64 *)v37,
                j,
                *((_QWORD *)v37 + 14) + ((unsigned __int64)*((unsigned __int16 *)v37 + 15) << 7),
                v23);
        ++*((_WORD *)v37 + 15);
        if ( v18 )
          goto LABEL_104;
      }
      else if ( !strcmp(*(const char **)(j + 48), "if-feature") )
      {
        v19 = sub_41746((__int64)v37, 0, j, *((_QWORD *)v37 + 5) + 32LL * v37[27], v23);
        ++v37[27];
        if ( v19 )
          goto LABEL_104;
      }
      else if ( !strcmp(*(const char **)(j + 48), "must") )
      {
        v20 = sub_489FC((__int64 *)a1, j, (__int64 *)(*((_QWORD *)v37 + 15) + 56LL * v37[29]), v23);
        ++v37[29];
        if ( v20 )
          goto LABEL_104;
      }
    }
    else
    {
      v17 = sub_40F96((__int64)v37, 1, 0, 0, (__int64 *)a1, j, (__int64 *)v37 + 4, v37[26], v23);
      ++v37[26];
      if ( v17 )
        goto LABEL_104;
    }
  }
  v25 = v24 | 2;
  for ( k = v40; ; k = (__int64)v34 )
  {
    if ( k )
    {
      v34 = *(_QWORD **)(k + 32);
      v22 = 1;
    }
    else
    {
      v22 = 0;
    }
    if ( !v22 )
      break;
    if ( !strcmp(*(const char **)(k + 48), "container") )
    {
      v35 = (__int64)sub_587B3((__int64 *)a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf-list") )
    {
      v35 = sub_551D2(a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "leaf") )
    {
      v35 = (__int64)sub_54422((__int64 *)a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "list") )
    {
      v35 = (__int64)sub_56721((__int64 *)a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "choice") )
    {
      v35 = (__int64)sub_52E00(a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "uses") )
    {
      v35 = (__int64)sub_5CBDA((__int64 *)a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "grouping") )
    {
      v35 = (__int64)sub_599C2((__int64 *)a1, (char *)v37, k, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anyxml") )
    {
      v35 = (__int64)sub_53A72((__int64 *)a1, (char *)v37, k, 32, v25, v23);
    }
    else if ( !strcmp(*(const char **)(k + 48), "anydata") )
    {
      v35 = (__int64)sub_53A72((__int64 *)a1, (char *)v37, k, 32800, v25, v23);
    }
    if ( !v35 )
      goto LABEL_104;
    lyxml_free(v36, k);
  }
  if ( v36[23] & 2 || !*((_QWORD *)v37 + 15) )
    return v37;
  if ( !(v25 & 4) )
  {
    if ( (unsigned int)sub_2ABDE((__int64 *)a1, v23, (__int64 *)v37, 0x20000u, 0LL) == -1 )
      goto LABEL_104;
    return v37;
  }
  if ( !(unsigned int)sub_DDEA9((__int64)v37) )
    return v37;
LABEL_104:
  sub_A33A0((_QWORD **)v37, 0LL, 0);
  while ( v40 )
    lyxml_free(v36, v40);
  return 0LL;
}
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000005C028) ----------------------------------------------------
unsigned __int8 *__fastcall sub_5C028(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  unsigned __int8 *result; // rax
  const char *v7; // rax
  __int64 v8; // r9
  signed int v9; // edx
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rax
  const char *v13; // rax
  const char *v14; // rax
  __int64 v15; // r9
  const char *v16; // rax
  char v17; // al
  __int64 v18; // r9
  __int64 v19; // r9
  __int64 v20; // r9
  _BOOL4 v21; // eax
  int v22; // eax
  int v23; // eax
  char v24; // al
  char v25; // al
  __int64 v26; // [rsp+8h] [rbp-C8h]
  unsigned int v27; // [rsp+14h] [rbp-BCh]
  __int64 v28; // [rsp+18h] [rbp-B8h]
  int v29; // [rsp+30h] [rbp-A0h]
  int v30; // [rsp+34h] [rbp-9Ch]
  signed int v31; // [rsp+38h] [rbp-98h]
  signed int v32; // [rsp+3Ch] [rbp-94h]
  int v33; // [rsp+40h] [rbp-90h]
  _QWORD *j; // [rsp+48h] [rbp-88h]
  __int64 k; // [rsp+48h] [rbp-88h]
  __int64 l; // [rsp+48h] [rbp-88h]
  _QWORD *v37; // [rsp+50h] [rbp-80h]
  _DWORD *i; // [rsp+58h] [rbp-78h]
  void *v39; // [rsp+60h] [rbp-70h]
  unsigned __int8 *v40; // [rsp+68h] [rbp-68h]
  void *v41; // [rsp+78h] [rbp-58h]
  char s; // [rsp+80h] [rbp-50h]
  __int64 v43; // [rsp+98h] [rbp-38h]
  unsigned __int64 v44; // [rsp+C8h] [rbp-8h]

  v28 = a3;
  v27 = a4;
  v26 = a5;
  v44 = __readfsqword(0x28u);
  v39 = *(void **)a1;
  i = 0LL;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  if ( !strcmp(*(const char **)(a3 + 48), "action") )
  {
    if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
    {
      sub_13937(v39, 5, 2u, a2, (__int64)"action", v5);
      return 0LL;
    }
    for ( i = a2; i; i = (_DWORD *)lys_parent(i) )
    {
      if ( i[14] & 0x4180 || i[14] == 16 && !*((_BYTE *)i + 30) )
      {
        v7 = sub_8164(i[14]);
        sub_13937(v39, 7, 2u, a2, (__int64)v7, (__int64)"action");
        return 0LL;
      }
    }
  }
  memset(&s, 0, 0x48uLL);
  v40 = (unsigned __int8 *)calloc(1uLL, 0x78uLL);
  if ( v40 )
  {
    if ( !strcmp(*(const char **)(v28 + 48), "rpc") )
      v9 = 256;
    else
      v9 = 0x4000;
    *((_DWORD *)v40 + 14) = v9;
    *((_QWORD *)v40 + 11) = v40;
    if ( (unsigned int)sub_51597((__int64 *)a1, a2, (__int64)v40, 1u, v28, 17, v26)
      || (sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v28 + 48), *(_QWORD *)v40, v10, v11),
          v12 = (_QWORD *)lys_main_module(a1),
          (unsigned int)sub_9C637((__int64)a2, v12, (__int64)v40, v27)) )
    {
LABEL_93:
      sub_A33A0((_QWORD **)v40, 0LL, 0);
      while ( v43 )
        lyxml_free(v39, v43);
      result = 0LL;
    }
    else
    {
      for ( j = *(_QWORD **)(v28 + 24); ; j = v37 )
      {
        if ( j )
        {
          v37 = (_QWORD *)j[4];
          v17 = 1;
        }
        else
        {
          v17 = 0;
        }
        if ( !v17 )
          break;
        if ( !strcmp(*(const char **)(j[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
        {
          if ( !strcmp((const char *)j[6], "input") )
          {
            if ( v31 )
            {
              sub_13937(v39, 14, 2u, (char *)v40, j[6], *(_QWORD *)(v28 + 48));
              goto LABEL_93;
            }
            v31 = 1;
            sub_30B77((__int64)v39, j, 2);
            sub_3116F((__int64)v39, (__int64)&s, j);
          }
          else if ( !strcmp((const char *)j[6], "output") )
          {
            if ( v32 )
            {
              sub_13937(v39, 14, 2u, (char *)v40, j[6], *(_QWORD *)(v28 + 48));
              goto LABEL_93;
            }
            v32 = 1;
            sub_30B77((__int64)v39, j, 2);
            sub_3116F((__int64)v39, (__int64)&s, j);
          }
          else if ( !strcmp((const char *)j[6], "grouping") )
          {
            sub_30B77((__int64)v39, j, 2);
            sub_3116F((__int64)v39, (__int64)&s, j);
          }
          else if ( !strcmp((const char *)j[6], "typedef") )
          {
            if ( v29 == 0xFFFF )
            {
              if ( *((_DWORD *)v40 + 14) == 256 )
                v14 = "rpc";
              else
                v14 = "action";
              sub_12222(
                (__int64)v39,
                0,
                4,
                "Reached limit (%lu) for storing %s in %s statement.",
                0xFFFFLL,
                (__int64)"typedefs",
                v14);
              goto LABEL_93;
            }
            ++v29;
          }
          else
          {
            if ( strcmp((const char *)j[6], "if-feature") )
            {
              sub_13937(v39, 5, 2u, (char *)v40, j[6], v15);
              goto LABEL_93;
            }
            if ( v30 == 255 )
            {
              if ( *((_DWORD *)v40 + 14) == 256 )
                v16 = "rpc";
              else
                v16 = "action";
              sub_12222(
                (__int64)v39,
                0,
                4,
                "Reached limit (%lu) for storing %s in %s statement.",
                255LL,
                (__int64)"if-features",
                v16);
              goto LABEL_93;
            }
            ++v30;
          }
        }
        else
        {
          if ( v33 == 255 )
          {
            if ( *((_DWORD *)v40 + 14) == 256 )
              v13 = "rpc";
            else
              v13 = "action";
            sub_12222(
              (__int64)v39,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"extensions",
              v13);
            goto LABEL_93;
          }
          ++v33;
        }
      }
      if ( v29 )
      {
        *((_QWORD *)v40 + 14) = calloc(v29, 0x80uLL);
        if ( !*((_QWORD *)v40 + 14) )
        {
          sub_12222((__int64)v39, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_rpc_action", v18);
          goto LABEL_93;
        }
      }
      if ( v30 )
      {
        *((_QWORD *)v40 + 5) = calloc(v30, 0x20uLL);
        if ( !*((_QWORD *)v40 + 5) )
        {
          sub_12222((__int64)v39, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_rpc_action", v19);
          goto LABEL_93;
        }
      }
      if ( v33 )
      {
        v41 = realloc(*((void **)v40 + 4), 8LL * (v40[26] + v33));
        if ( !v41 )
        {
          sub_12222((__int64)v39, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_rpc_action", v20);
          goto LABEL_93;
        }
        *((_QWORD *)v40 + 4) = v41;
        memset((void *)(*((_QWORD *)v40 + 4) + 8LL * v40[26]), 0, 8LL * v33);
      }
      for ( k = *(_QWORD *)(v28 + 24); ; k = (__int64)v37 )
      {
        if ( k )
        {
          v37 = *(_QWORD **)(k + 32);
          v24 = 1;
        }
        else
        {
          v24 = 0;
        }
        if ( !v24 )
          break;
        if ( !strcmp(*(const char **)(*(_QWORD *)(k + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
        {
          if ( !strcmp(*(const char **)(k + 48), "typedef") )
          {
            v22 = sub_4778E(
                    (__int64 *)a1,
                    (__int64 *)v40,
                    k,
                    *((_QWORD *)v40 + 14) + ((unsigned __int64)*((unsigned __int16 *)v40 + 15) << 7),
                    v26);
            ++*((_WORD *)v40 + 15);
            if ( v22 )
              goto LABEL_93;
          }
          else if ( !strcmp(*(const char **)(k + 48), "if-feature") )
          {
            v23 = sub_41746((__int64)v40, 0, k, *((_QWORD *)v40 + 5) + 32LL * v40[27], v26);
            ++v40[27];
            if ( v23 )
              goto LABEL_93;
          }
        }
        else
        {
          v21 = sub_40F96((__int64)v40, 1, 0, 0, (__int64 *)a1, k, (__int64 *)v40 + 4, v40[26], v26);
          ++v40[26];
          if ( v21 )
            goto LABEL_93;
        }
      }
      for ( l = v43; ; l = (__int64)v37 )
      {
        if ( l )
        {
          v37 = *(_QWORD **)(l + 32);
          v25 = 1;
        }
        else
        {
          v25 = 0;
        }
        if ( !v25 )
          break;
        if ( !strcmp(*(const char **)(l + 48), "grouping") )
        {
          i = sub_599C2((__int64 *)a1, (char *)v40, l, v27, v26);
        }
        else if ( !strcmp(*(const char **)(l + 48), "input") || !strcmp(*(const char **)(l + 48), "output") )
        {
          i = sub_5A553(a1, (__int64)v40, l, v27, v26);
        }
        if ( !i )
          goto LABEL_93;
        lyxml_free(v39, l);
      }
      result = v40;
    }
  }
  else
  {
    sub_12222((__int64)v39, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_rpc_action", v8);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000005CBDA) ----------------------------------------------------
unsigned __int8 *__fastcall sub_5CBDA(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *v9; // rax
  __int64 v10; // r9
  char v11; // al
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  _BOOL4 v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  char v20; // al
  __int64 v21; // [rsp+8h] [rbp-78h]
  unsigned int v22; // [rsp+14h] [rbp-6Ch]
  __int64 v23; // [rsp+18h] [rbp-68h]
  int v24; // [rsp+34h] [rbp-4Ch]
  int v25; // [rsp+38h] [rbp-48h]
  int v26; // [rsp+3Ch] [rbp-44h]
  int v27; // [rsp+40h] [rbp-40h]
  _QWORD *i; // [rsp+48h] [rbp-38h]
  __int64 j; // [rsp+48h] [rbp-38h]
  _QWORD *v30; // [rsp+50h] [rbp-30h]
  _DWORD *v31; // [rsp+58h] [rbp-28h]
  unsigned __int8 *v32; // [rsp+60h] [rbp-20h]
  __int64 v33; // [rsp+70h] [rbp-10h]
  void *v34; // [rsp+78h] [rbp-8h]

  v23 = a3;
  v22 = a4;
  v21 = a5;
  v31 = (_DWORD *)*a1;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v32 = (unsigned __int8 *)calloc(1uLL, 0x88uLL);
  if ( !v32 )
  {
    sub_12222((__int64)v31, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_uses", v5);
    return 0LL;
  }
  *((_DWORD *)v32 + 14) = 4096;
  *((_QWORD *)v32 + 11) = v32;
  v33 = lyxml_get_attr(v23, "name", 0LL);
  if ( v33 )
  {
    *(_QWORD *)v32 = lydict_insert(v31, v33, 0LL);
    if ( (unsigned int)sub_51597(a1, a2, (__int64)v32, 1u, v23, 16, v21) )
      goto LABEL_74;
    sub_12312(4u, (__int64)"parsing %s statement \"%s\"", *(_QWORD *)(v23 + 48), *(_QWORD *)v32, v7, v8);
    v9 = (_QWORD *)lys_main_module(a1);
    if ( (unsigned int)sub_9C637((__int64)a2, v9, (__int64)v32, v22) )
      goto LABEL_74;
    for ( i = *(_QWORD **)(v23 + 24); ; i = v30 )
    {
      if ( i )
      {
        v30 = (_QWORD *)i[4];
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
      if ( !v11 )
        break;
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( !strcmp((const char *)i[6], "refine") )
        {
          if ( v24 == 255 )
          {
            sub_12222(
              (__int64)v31,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"refines",
              "uses");
            goto LABEL_74;
          }
          ++v24;
        }
        else if ( !strcmp((const char *)i[6], "augment") )
        {
          if ( v25 == 255 )
          {
            sub_12222(
              (__int64)v31,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"augments",
              "uses");
            goto LABEL_74;
          }
          ++v25;
        }
        else if ( !strcmp((const char *)i[6], "if-feature") )
        {
          if ( v26 == 255 )
          {
            sub_12222(
              (__int64)v31,
              0,
              4,
              "Reached limit (%lu) for storing %s in %s statement.",
              255LL,
              (__int64)"if-features",
              "uses");
            goto LABEL_74;
          }
          ++v26;
        }
        else
        {
          if ( strcmp((const char *)i[6], "when") )
          {
            sub_13937(v31, 5, 2u, (char *)v32, i[6], v10);
            goto LABEL_74;
          }
          if ( *((_QWORD *)v32 + 13) )
          {
            sub_13937(v31, 14, 2u, (char *)v32, i[6], *(_QWORD *)(v23 + 48));
            goto LABEL_74;
          }
          *((_QWORD *)v32 + 13) = sub_51F02(a1, (__int64)i, v21);
          if ( !*((_QWORD *)v32 + 13) )
          {
            lyxml_free(v31, i);
            goto LABEL_74;
          }
          lyxml_free(v31, i);
        }
      }
      else
      {
        if ( v27 == 255 )
        {
          sub_12222(
            (__int64)v31,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extensions",
            "uses");
          goto LABEL_74;
        }
        ++v27;
      }
    }
    if ( !v24 || (*((_QWORD *)v32 + 14) = calloc(v24, 0x50uLL)) != 0LL )
    {
      if ( !v25 || (*((_QWORD *)v32 + 15) = calloc(v25, 0x68uLL)) != 0LL )
      {
        if ( !v26 || (*((_QWORD *)v32 + 5) = calloc(v26, 0x20uLL)) != 0LL )
        {
          if ( v27 )
          {
            v34 = realloc(*((void **)v32 + 4), 8LL * (v32[26] + v27));
            if ( !v34 )
            {
              sub_12222((__int64)v31, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_uses", v15);
              goto LABEL_74;
            }
            *((_QWORD *)v32 + 4) = v34;
            memset((void *)(*((_QWORD *)v32 + 4) + 8LL * v32[26]), 0, 8LL * v27);
          }
          for ( j = *(_QWORD *)(v23 + 24); ; j = (__int64)v30 )
          {
            if ( j )
            {
              v30 = *(_QWORD **)(j + 32);
              v20 = 1;
            }
            else
            {
              v20 = 0;
            }
            if ( !v20 )
              break;
            if ( !strcmp(*(const char **)(*(_QWORD *)(j + 56) + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
            {
              if ( !strcmp(*(const char **)(j + 48), "refine") )
              {
                v17 = sub_4EC3D((__int64)v32, j, *((_QWORD *)v32 + 14) + 80LL * v32[30], v21);
                ++v32[30];
                if ( v17 )
                  goto LABEL_74;
              }
              else if ( !strcmp(*(const char **)(j + 48), "augment") )
              {
                v18 = sub_4E308(a1, (__int64)v32, j, 104LL * v32[31] + *((_QWORD *)v32 + 15), v22, v21);
                ++v32[31];
                if ( v18 )
                  goto LABEL_74;
              }
              else if ( !strcmp(*(const char **)(j + 48), "if-feature") )
              {
                v19 = sub_41746((__int64)v32, 0, j, *((_QWORD *)v32 + 5) + 32LL * v32[27], v21);
                ++v32[27];
                if ( v19 )
                  goto LABEL_74;
              }
            }
            else
            {
              v16 = sub_40F96((__int64)v32, 1, 0, 0, a1, j, (__int64 *)v32 + 4, v32[26], v21);
              ++v32[26];
              if ( v16 )
                goto LABEL_74;
            }
          }
          if ( (unsigned int)sub_2ABDE(a1, v21, (__int64 *)v32, 1u, 0LL) == -1 )
            goto LABEL_74;
          if ( !(v31[23] & 2) && *((_QWORD *)v32 + 13) )
          {
            if ( v22 & 4 )
            {
              if ( (unsigned int)sub_DDEA9((__int64)v32) )
                goto LABEL_74;
            }
            else if ( (unsigned int)sub_2ABDE(a1, v21, (__int64 *)v32, 0x20000u, 0LL) == -1 )
            {
              goto LABEL_74;
            }
          }
          return v32;
        }
        sub_12222((__int64)v31, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_uses", v14);
      }
      else
      {
        sub_12222((__int64)v31, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_uses", v13);
      }
    }
    else
    {
      sub_12222((__int64)v31, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_yin_uses", v12);
    }
  }
  else
  {
    sub_13937(v31, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(v23 + 48));
  }
LABEL_74:
  sub_A33A0((_QWORD **)v32, 0LL, 0);
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000005D54B) ----------------------------------------------------
__int64 __fastcall sub_5D54B(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  const char *v7; // rax
  __int64 v8; // r9
  size_t v9; // rax
  __int64 v10; // r9
  __int64 v11; // r9
  size_t v12; // rax
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  size_t v16; // rax
  const char *v17; // rax
  __int64 v18; // r9
  const char *v19; // rax
  const char *v20; // rax
  const char *v21; // rax
  const char *v22; // rax
  const char *v23; // rax
  const char *v24; // rax
  __int64 v25; // r9
  __int64 v26; // r9
  __int64 v27; // r9
  __int64 v28; // r9
  __int64 v29; // r9
  __int64 v30; // r8
  __int64 v31; // r9
  const char *v32; // rax
  const char *v33; // rax
  char v34; // al
  __int64 v35; // r9
  __int64 v36; // r9
  __int64 v37; // r9
  __int64 v38; // r9
  __int64 v39; // r9
  __int64 v40; // r9
  __int64 v41; // r9
  __int64 v42; // r9
  __int64 v43; // r9
  int v44; // eax
  __int64 v45; // r9
  char v46; // al
  int v47; // eax
  int v48; // eax
  char v49; // al
  int v50; // eax
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  char v56; // al
  __int64 v57; // r9
  _BOOL4 v58; // eax
  char v59; // al
  char v60; // al
  __int64 v61; // r9
  char v62; // al
  int v63; // eax
  char v64; // al
  __int64 v66; // [rsp+0h] [rbp-230h]
  __int64 v67; // [rsp+8h] [rbp-228h]
  int k; // [rsp+24h] [rbp-20Ch]
  unsigned int v69; // [rsp+28h] [rbp-208h]
  signed int v70; // [rsp+2Ch] [rbp-204h]
  signed int v71; // [rsp+30h] [rbp-200h]
  int v72; // [rsp+34h] [rbp-1FCh]
  int v73; // [rsp+38h] [rbp-1F8h]
  int v74; // [rsp+3Ch] [rbp-1F4h]
  int v75; // [rsp+40h] [rbp-1F0h]
  int v76; // [rsp+44h] [rbp-1ECh]
  int v77; // [rsp+48h] [rbp-1E8h]
  int v78; // [rsp+4Ch] [rbp-1E4h]
  int v79; // [rsp+50h] [rbp-1E0h]
  int v80; // [rsp+54h] [rbp-1DCh]
  int v81; // [rsp+58h] [rbp-1D8h]
  _QWORD *v82; // [rsp+60h] [rbp-1D0h]
  _QWORD *i; // [rsp+68h] [rbp-1C8h]
  __int64 j; // [rsp+68h] [rbp-1C8h]
  __int64 l; // [rsp+68h] [rbp-1C8h]
  __int64 m; // [rsp+68h] [rbp-1C8h]
  __int64 n; // [rsp+68h] [rbp-1C8h]
  __int64 ii; // [rsp+68h] [rbp-1C8h]
  __int64 jj; // [rsp+68h] [rbp-1C8h]
  __int64 kk; // [rsp+68h] [rbp-1C8h]
  __int64 v91; // [rsp+70h] [rbp-1C0h]
  const char *v92; // [rsp+78h] [rbp-1B8h]
  void *v93; // [rsp+80h] [rbp-1B0h]
  __int64 v94; // [rsp+88h] [rbp-1A8h]
  void *v95; // [rsp+90h] [rbp-1A0h]
  char *s1; // [rsp+98h] [rbp-198h]
  char *s1a; // [rsp+98h] [rbp-198h]
  char *s1b; // [rsp+98h] [rbp-198h]
  char *s1c; // [rsp+98h] [rbp-198h]
  char *s1d; // [rsp+98h] [rbp-198h]
  char s; // [rsp+A0h] [rbp-190h]
  __int64 v102; // [rsp+B8h] [rbp-178h]
  char v103; // [rsp+F0h] [rbp-140h]
  __int64 v104; // [rsp+108h] [rbp-128h]
  char v105; // [rsp+140h] [rbp-F0h]
  __int64 v106; // [rsp+158h] [rbp-D8h]
  char v107; // [rsp+190h] [rbp-A0h]
  __int64 v108; // [rsp+1A8h] [rbp-88h]
  char v109; // [rsp+1E0h] [rbp-50h]
  __int64 v110; // [rsp+1F8h] [rbp-38h]
  unsigned __int64 v111; // [rsp+228h] [rbp-8h]

  v67 = a3;
  v66 = a4;
  v111 = __readfsqword(0x28u);
  v93 = *(void **)a1;
  v91 = 0LL;
  v69 = -1;
  v70 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  if ( a2 )
    v4 = a2;
  else
    v4 = a1;
  v94 = v4;
  memset(&s, 0, 0x48uLL);
  memset(&v103, 0, 0x48uLL);
  memset(&v105, 0, 0x48uLL);
  memset(&v109, 0, 0x48uLL);
  memset(&v107, 0, 0x48uLL);
  v71 = 0;
  v92 = 0LL;
  for ( i = *(_QWORD **)(v67 + 24); ; i = v82 )
  {
    if ( i )
    {
      v82 = (_QWORD *)i[4];
      v34 = 1;
    }
    else
    {
      v34 = 0;
    }
    if ( !v34 )
      break;
    if ( i[7] )
    {
      if ( !strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
      {
        if ( a2 || strcmp((const char *)i[6], "namespace") )
        {
          if ( a2 || strcmp((const char *)i[6], "prefix") )
          {
            if ( a2 && !strcmp((const char *)i[6], "belongs-to") )
            {
              if ( v71 > 0 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v13, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              if ( *(_QWORD *)(v94 + 16) )
              {
                sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
                goto LABEL_363;
              }
              s1b = (char *)lyxml_get_attr(i, "module", 0LL);
              if ( !s1b )
              {
                sub_13937(v93, 13, 0, 0LL, (__int64)"module", i[6], v66);
                goto LABEL_363;
              }
              if ( s1b != *(char **)(*(_QWORD *)(a2 + 168) + 8LL) )
              {
                sub_13937(v93, 10, 0, 0LL, (__int64)s1b, i[6], v66);
                goto LABEL_363;
              }
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 3, 0LL, v66) )
                goto LABEL_363;
              if ( !i[3] )
              {
                sub_13937(v93, 12, 0, 0LL, (__int64)"prefix", i[6], v66);
                goto LABEL_363;
              }
              if ( strcmp(*(const char **)(i[3] + 48LL), "prefix") )
              {
                sub_13937(v93, 5, 0, 0LL, *(_QWORD *)(i[3] + 48LL), v14, v66);
                goto LABEL_363;
              }
              if ( *(_QWORD *)(i[3] + 32LL) )
              {
                sub_13937(v93, 5, 0, 0LL, *(_QWORD *)(*(_QWORD *)(i[3] + 32LL) + 48LL), v14, v66);
                goto LABEL_363;
              }
              s1c = (char *)lyxml_get_attr(i[3], "value", 0LL);
              if ( !s1c )
              {
                sub_13937(v93, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(i[3] + 48LL), v66);
                goto LABEL_363;
              }
              if ( (unsigned int)sub_3B812(v93, s1c, 5u, 0LL, 0LL, v15) )
                goto LABEL_363;
              v16 = strlen(s1c);
              *(_QWORD *)(a2 + 16) = lydict_insert(v93, s1c, v16);
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, (_QWORD *)i[3], 13, 0LL, v66) )
                goto LABEL_363;
              lyxml_free(v93, i);
              v92 = "belongs-to";
            }
            else if ( !strcmp((const char *)i[6], "import") )
            {
              if ( v71 > 1 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v6, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 1;
              if ( v72 == 255 )
              {
                if ( a2 )
                  v17 = "submodule";
                else
                  v17 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"imports",
                  v17);
                goto LABEL_363;
              }
              ++v72;
              v92 = "import";
            }
            else if ( !strcmp((const char *)i[6], "revision") )
            {
              if ( v71 > 3 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v18, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 3;
              if ( v73 == 255 )
              {
                if ( a2 )
                  v19 = "submodule";
                else
                  v19 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"revisions",
                  v19);
                goto LABEL_363;
              }
              ++v73;
              sub_30B77((__int64)v93, i, 2);
              sub_3116F((__int64)v93, (__int64)&v107, i);
              v92 = "revision";
            }
            else if ( !strcmp((const char *)i[6], "typedef") )
            {
              v71 = 4;
              if ( v74 == 0xFFFF )
              {
                if ( a2 )
                  v20 = "submodule";
                else
                  v20 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  0xFFFFLL,
                  (__int64)"typedefs",
                  v20);
                goto LABEL_363;
              }
              ++v74;
              v92 = "typedef";
            }
            else if ( !strcmp((const char *)i[6], "identity") )
            {
              v71 = 4;
              if ( v75 == 0xFFFF )
              {
                if ( a2 )
                  v21 = "submodule";
                else
                  v21 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  0xFFFFLL,
                  (__int64)"identities",
                  v21);
                goto LABEL_363;
              }
              ++v75;
              v92 = "identity";
            }
            else if ( !strcmp((const char *)i[6], "include") )
            {
              if ( v71 > 1 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v6, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 1;
              if ( v76 == 255 )
              {
                if ( a2 )
                  v22 = "submodule";
                else
                  v22 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"includes",
                  v22);
                goto LABEL_363;
              }
              ++v76;
              v92 = "include";
            }
            else if ( !strcmp((const char *)i[6], "augment") )
            {
              v71 = 4;
              if ( v77 == 255 )
              {
                if ( a2 )
                  v23 = "submodule";
                else
                  v23 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"augments",
                  v23);
                goto LABEL_363;
              }
              ++v77;
              sub_30B77((__int64)v93, i, 2);
              sub_3116F((__int64)v93, (__int64)&v105, i);
              v92 = "augment";
            }
            else if ( !strcmp((const char *)i[6], "feature") )
            {
              v71 = 4;
              if ( v78 == 255 )
              {
                if ( a2 )
                  v24 = "submodule";
                else
                  v24 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"features",
                  v24);
                goto LABEL_363;
              }
              ++v78;
              v92 = "feature";
            }
            else if ( !strcmp((const char *)i[6], "container")
                   || !strcmp((const char *)i[6], "leaf-list")
                   || !strcmp((const char *)i[6], "leaf")
                   || !strcmp((const char *)i[6], "list")
                   || !strcmp((const char *)i[6], "choice")
                   || !strcmp((const char *)i[6], "uses")
                   || !strcmp((const char *)i[6], "anyxml")
                   || !strcmp((const char *)i[6], "anydata")
                   || !strcmp((const char *)i[6], "rpc")
                   || !strcmp((const char *)i[6], "notification") )
            {
              v71 = 4;
              sub_30B77((__int64)v93, i, 2);
              sub_3116F((__int64)v93, (__int64)&s, i);
              v92 = "data definition";
            }
            else if ( !strcmp((const char *)i[6], "grouping") )
            {
              v71 = 4;
              sub_30B77((__int64)v93, i, 2);
              sub_3116F((__int64)v93, (__int64)&v103, i);
              v92 = "grouping";
            }
            else if ( !strcmp((const char *)i[6], "description") )
            {
              if ( v71 > 2 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v25, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 2;
              if ( *(_QWORD *)(v94 + 24) )
              {
                sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
                goto LABEL_363;
              }
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 6, 0LL, v66) )
                goto LABEL_363;
              *(_QWORD *)(v94 + 24) = sub_410A7(v93, (__int64)i, "text");
              lyxml_free(v93, i);
              if ( !*(_QWORD *)(v94 + 24) )
                goto LABEL_363;
              v92 = "description";
            }
            else if ( !strcmp((const char *)i[6], "reference") )
            {
              if ( v71 > 2 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v26, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 2;
              if ( *(_QWORD *)(v94 + 32) )
              {
                sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
                goto LABEL_363;
              }
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 15, 0LL, v66) )
                goto LABEL_363;
              *(_QWORD *)(v94 + 32) = sub_410A7(v93, (__int64)i, "text");
              lyxml_free(v93, i);
              if ( !*(_QWORD *)(v94 + 32) )
                goto LABEL_363;
              v92 = "reference";
            }
            else if ( !strcmp((const char *)i[6], "organization") )
            {
              if ( v71 > 2 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v27, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 2;
              if ( *(_QWORD *)(v94 + 40) )
              {
                sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
                goto LABEL_363;
              }
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 11, 0LL, v66) )
                goto LABEL_363;
              *(_QWORD *)(v94 + 40) = sub_410A7(v93, (__int64)i, "text");
              lyxml_free(v93, i);
              if ( !*(_QWORD *)(v94 + 40) )
                goto LABEL_363;
              v92 = "organization";
            }
            else if ( !strcmp((const char *)i[6], "contact") )
            {
              if ( v71 > 2 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v28, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              v71 = 2;
              if ( *(_QWORD *)(v94 + 48) )
              {
                sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
                goto LABEL_363;
              }
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 4, 0LL, v66) )
                goto LABEL_363;
              *(_QWORD *)(v94 + 48) = sub_410A7(v93, (__int64)i, "text");
              lyxml_free(v93, i);
              if ( !*(_QWORD *)(v94 + 48) )
                goto LABEL_363;
              v92 = "contact";
            }
            else if ( !strcmp((const char *)i[6], "yang-version") )
            {
              if ( v71 > 0 )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v29, v66);
                sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
                goto LABEL_363;
              }
              if ( v70 )
              {
                sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
                goto LABEL_363;
              }
              s1d = (char *)lyxml_get_attr(i, "value", 0LL);
              if ( !s1d )
              {
                sub_13937(v93, 13, 0, 0LL, (__int64)"value", i[6], v66);
                goto LABEL_363;
              }
              if ( strcmp(s1d, "1") && strcmp(s1d, "1.1") )
              {
                sub_13937(v93, 10, 0, 0LL, (__int64)s1d, (__int64)"yang-version", v66);
                goto LABEL_363;
              }
              v70 = 1;
              if ( !strcmp(s1d, "1") )
              {
                if ( a2 )
                {
                  if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 )
                  {
                    sub_13937(v93, 42, 0, 0LL, v30, v31, v66);
                    goto LABEL_363;
                  }
                  *(_BYTE *)(a2 + 64) = *(_BYTE *)(a2 + 64) & 0xF1 | 2;
                }
                else
                {
                  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 64) & 0xF1 | 2;
                }
              }
              else if ( a2 )
              {
                if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
                {
                  sub_13937(v93, 42, 0, 0LL, v30, v31, v66);
                  goto LABEL_363;
                }
                *(_BYTE *)(a2 + 64) = *(_BYTE *)(a2 + 64) & 0xF1 | 4;
              }
              else
              {
                *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 64) & 0xF1 | 4;
              }
              if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 19, 0LL, v66) )
                goto LABEL_363;
              lyxml_free(v93, i);
              v92 = "yang-version";
            }
            else if ( !strcmp((const char *)i[6], "extension") )
            {
              v71 = 4;
              if ( v80 == 255 )
              {
                if ( a2 )
                  v32 = "submodule";
                else
                  v32 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"extensions",
                  v32);
                goto LABEL_363;
              }
              ++v80;
              v92 = "extension";
            }
            else
            {
              if ( strcmp((const char *)i[6], "deviation") )
              {
                sub_13937(v93, 5, 0, 0LL, i[6], v6, v66);
                goto LABEL_363;
              }
              v71 = 4;
              if ( v79 == 255 )
              {
                if ( a2 )
                  v33 = "submodule";
                else
                  v33 = "module";
                sub_12222(
                  (__int64)v93,
                  0,
                  4,
                  "Reached limit (%lu) for storing %s in %s statement.",
                  255LL,
                  (__int64)"deviations",
                  v33);
                goto LABEL_363;
              }
              ++v79;
              v92 = "deviation";
            }
          }
          else
          {
            if ( v71 > 0 )
            {
              sub_13937(v93, 5, 0, 0LL, i[6], v10, v66);
              sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
              goto LABEL_363;
            }
            if ( *(_QWORD *)(v94 + 16) )
            {
              sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
              goto LABEL_363;
            }
            s1a = (char *)lyxml_get_attr(i, "value", 0LL);
            if ( !s1a )
            {
              sub_13937(v93, 13, 0, 0LL, (__int64)"value", i[6], v66);
              goto LABEL_363;
            }
            if ( (unsigned int)sub_3B812(v93, s1a, 6u, v94, 0LL, v11) )
              goto LABEL_363;
            v12 = strlen(s1a);
            *(_QWORD *)(v94 + 16) = lydict_insert(v93, s1a, v12);
            if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 13, 0LL, v66) )
              goto LABEL_363;
            lyxml_free(v93, i);
            v92 = "prefix";
          }
        }
        else
        {
          if ( v71 > 0 )
          {
            sub_13937(v93, 5, 0, 0LL, i[6], v8, v66);
            sub_13937(v93, -1, 0, 0LL, (__int64)"Statement \"%s\" cannot appear after \"%s\" statement.", i[6], v92);
            goto LABEL_363;
          }
          if ( *(_QWORD *)(v94 + 176) )
          {
            sub_13937(v93, 14, 0, 0LL, i[6], *(_QWORD *)(v67 + 48), v66);
            goto LABEL_363;
          }
          s1 = (char *)lyxml_get_attr(i, "uri", 0LL);
          if ( !s1 )
          {
            sub_13937(v93, 13, 0, 0LL, (__int64)"uri", i[6], v66);
            goto LABEL_363;
          }
          v9 = strlen(s1);
          *(_QWORD *)(v94 + 176) = lydict_insert(v93, s1, v9);
          if ( (unsigned int)sub_411CA((__int64 *)v94, v94, 0, i, 10, 0LL, v66) )
            goto LABEL_363;
          lyxml_free(v93, i);
          v92 = "namespace";
        }
      }
      else
      {
        if ( v81 == 255 )
        {
          if ( a2 )
            v7 = "submodule";
          else
            v7 = "module";
          sub_12222(
            (__int64)v93,
            0,
            4,
            "Reached limit (%lu) for storing %s in %s statement.",
            255LL,
            (__int64)"extension instances",
            v7);
          goto LABEL_363;
        }
        sub_30B77((__int64)v93, i, 2);
        sub_3116F((__int64)v93, (__int64)&v109, i);
        ++v81;
      }
    }
    else
    {
      lyxml_free(v93, i);
    }
  }
  if ( a2 )
  {
    if ( !*(_QWORD *)(a2 + 16) )
    {
      sub_13937(v93, 12, 0, 0LL, (__int64)"belongs-to", (__int64)"submodule", v66);
      goto LABEL_363;
    }
    if ( !v70 && ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 )
    {
      sub_13937(v93, 42, 0, 0LL, v5, v6, v66);
      goto LABEL_363;
    }
  }
  else
  {
    if ( !*(_QWORD *)(v94 + 176) )
    {
      sub_13937(v93, 12, 0, 0LL, (__int64)"namespace", (__int64)"module", v66);
      goto LABEL_363;
    }
    if ( !*(_QWORD *)(v94 + 16) )
    {
      sub_13937(v93, 12, 0, 0LL, (__int64)"prefix", (__int64)"module", v66);
      goto LABEL_363;
    }
  }
  if ( v72 )
  {
    *(_QWORD *)(v94 + 96) = calloc(v72, 0x38uLL);
    if ( !*(_QWORD *)(v94 + 96) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v35, v66);
      goto LABEL_363;
    }
  }
  if ( v73 )
  {
    *(_QWORD *)(v94 + 88) = calloc(v73, 0x28uLL);
    if ( !*(_QWORD *)(v94 + 88) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v36, v66);
      goto LABEL_363;
    }
  }
  if ( v74 )
  {
    *(_QWORD *)(v94 + 112) = calloc(v74, 0x80uLL);
    if ( !*(_QWORD *)(v94 + 112) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v37, v66);
      goto LABEL_363;
    }
  }
  if ( v75 )
  {
    *(_QWORD *)(v94 + 120) = calloc(v75, 0x48uLL);
    if ( !*(_QWORD *)(v94 + 120) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v38, v66);
      goto LABEL_363;
    }
  }
  if ( v76 )
  {
    *(_QWORD *)(v94 + 104) = calloc(v76, 0x30uLL);
    if ( !*(_QWORD *)(v94 + 104) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v39, v66);
      goto LABEL_363;
    }
  }
  if ( v77 )
  {
    *(_QWORD *)(v94 + 136) = calloc(v77, 0x68uLL);
    if ( !*(_QWORD *)(v94 + 136) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v40, v66);
      goto LABEL_363;
    }
  }
  if ( v78 )
  {
    *(_QWORD *)(v94 + 128) = calloc(v78, 0x40uLL);
    if ( !*(_QWORD *)(v94 + 128) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v41, v66);
      goto LABEL_363;
    }
  }
  if ( v79 )
  {
    *(_QWORD *)(v94 + 144) = calloc(v79, 0x38uLL);
    if ( !*(_QWORD *)(v94 + 144) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v42, v66);
      goto LABEL_363;
    }
  }
  if ( v80 )
  {
    *(_QWORD *)(v94 + 152) = calloc(v80, 0x40uLL);
    if ( !*(_QWORD *)(v94 + 152) )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v43, v66);
      goto LABEL_363;
    }
  }
  for ( j = v108; ; j = (__int64)v82 )
  {
    if ( j )
    {
      v82 = *(_QWORD **)(j + 32);
      v46 = 1;
    }
    else
    {
      v46 = 0;
    }
    if ( !v46 )
      break;
    v44 = sub_48AF6((__int64 *)v94, j, (_QWORD *)(*(_QWORD *)(v94 + 88) + 40LL * *(unsigned __int8 *)(v94 + 68)), v66);
    ++*(_BYTE *)(v94 + 68);
    if ( v44 )
      goto LABEL_363;
    for ( k = 0; k < *(unsigned __int8 *)(v94 + 68) - 1; ++k )
    {
      if ( !strcmp(
              (const char *)(*(_QWORD *)(v94 + 88) + 40LL * k),
              (const char *)(*(_QWORD *)(v94 + 88) + 40LL * *(unsigned __int8 *)(v94 + 68) - 40)) )
      {
        sub_12222(
          (__int64)v93,
          1u,
          0,
          "Module's revisions are not unique (%s).",
          *(_QWORD *)(v94 + 88) + 40LL * *(unsigned __int8 *)(v94 + 68) - 40,
          v45,
          v66);
        break;
      }
    }
    lyxml_free(v93, j);
  }
  if ( !a2 )
  {
    v47 = sub_3FA66(a1);
    if ( v47 )
    {
      if ( v47 == 1 )
      {
        v69 = 1;
        goto LABEL_363;
      }
      if ( v47 == -1 )
      {
LABEL_363:
        while ( v102 )
          lyxml_free(v93, v102);
        while ( v104 )
          lyxml_free(v93, v104);
        while ( v106 )
          lyxml_free(v93, v106);
        while ( v108 )
          lyxml_free(v93, v108);
        while ( v110 )
          lyxml_free(v93, v110);
        return v69;
      }
    }
  }
  if ( v80 )
  {
    for ( l = *(_QWORD *)(v67 + 24); ; l = (__int64)v82 )
    {
      if ( l )
      {
        v82 = *(_QWORD **)(l + 32);
        v49 = 1;
      }
      else
      {
        v49 = 0;
      }
      if ( !v49 )
        break;
      if ( !strcmp(*(const char **)(l + 48), "extension") )
      {
        v48 = sub_47EF1(
                (__int64 *)v94,
                l,
                *(_QWORD *)(v94 + 152) + ((unsigned __int64)*(unsigned __int8 *)(v94 + 79) << 6),
                v66);
        ++*(_BYTE *)(v94 + 79);
        if ( v48 )
          goto LABEL_363;
      }
    }
  }
  for ( m = *(_QWORD *)(v67 + 24); ; m = (__int64)v82 )
  {
    if ( m )
    {
      v82 = *(_QWORD **)(m + 32);
      v56 = 1;
    }
    else
    {
      v56 = 0;
    }
    if ( !v56 )
      break;
    if ( !strcmp(*(const char **)(m + 48), "import") )
    {
      v50 = sub_505F3(v94, m, *(_QWORD *)(v94 + 96) + 56LL * *(unsigned __int8 *)(v94 + 69), v66);
      ++*(_BYTE *)(v94 + 69);
      if ( v50 )
        goto LABEL_363;
    }
    else if ( !strcmp(*(const char **)(m + 48), "include") )
    {
      v51 = sub_50E7D(a1, (__int64 *)a2, m, 48LL * *(unsigned __int8 *)(v94 + 70) + *(_QWORD *)(v94 + 104), v66);
      ++*(_BYTE *)(v94 + 70);
      if ( v51 )
        goto LABEL_363;
    }
    else if ( !strcmp(*(const char **)(m + 48), "typedef") )
    {
      v52 = sub_4778E(
              (__int64 *)v94,
              0LL,
              m,
              *(_QWORD *)(v94 + 112) + ((unsigned __int64)*(unsigned __int16 *)(v94 + 74) << 7),
              v66);
      ++*(_WORD *)(v94 + 74);
      if ( v52 )
        goto LABEL_363;
    }
    else if ( !strcmp(*(const char **)(m + 48), "identity") )
    {
      v53 = sub_41AE0(v94, m, *(_QWORD *)(v94 + 120) + 72LL * *(unsigned __int16 *)(v94 + 72), v66);
      ++*(_WORD *)(v94 + 72);
      if ( v53 )
        goto LABEL_363;
    }
    else if ( !strcmp(*(const char **)(m + 48), "feature") )
    {
      v54 = sub_4852A(
              (__int64 *)v94,
              m,
              *(_QWORD *)(v94 + 128) + ((unsigned __int64)*(unsigned __int8 *)(v94 + 76) << 6),
              v66);
      ++*(_BYTE *)(v94 + 76);
      if ( v54 )
        goto LABEL_363;
    }
    else if ( !strcmp(*(const char **)(m + 48), "deviation") )
    {
      *(_BYTE *)(v94 + 64) |= 0x80u;
      v55 = sub_49735((__int64 *)v94, m, *(_QWORD *)(v94 + 144) + 56LL * *(unsigned __int8 *)(v94 + 78), v66);
      ++*(_BYTE *)(v94 + 78);
      if ( v55 )
        goto LABEL_363;
    }
  }
  if ( v81 )
  {
    v95 = realloc(*(void **)(v94 + 160), 8LL * (*(unsigned __int8 *)(v94 + 80) + v81));
    if ( !v95 )
    {
      sub_12222((__int64)v93, 0, 1, "Memory allocation failed (%s()).", (__int64)"read_sub_module", v57, v66);
      goto LABEL_363;
    }
    *(_QWORD *)(v94 + 160) = v95;
    memset((void *)(*(_QWORD *)(v94 + 160) + 8LL * *(unsigned __int8 *)(v94 + 80)), 0, 8LL * v81);
    for ( n = v110; ; n = (__int64)v82 )
    {
      if ( n )
      {
        v82 = *(_QWORD **)(n + 32);
        v59 = 1;
      }
      else
      {
        v59 = 0;
      }
      if ( !v59 )
        break;
      v58 = sub_40F96(v94, 0, 0, 0, (__int64 *)v94, n, (__int64 *)(v94 + 160), *(_BYTE *)(v94 + 80), v66);
      ++*(_BYTE *)(v94 + 80);
      if ( v58 )
        goto LABEL_363;
    }
  }
  for ( ii = v104; ; ii = (__int64)v82 )
  {
    if ( ii )
    {
      v82 = *(_QWORD **)(ii + 32);
      v60 = 1;
    }
    else
    {
      v60 = 0;
    }
    if ( !v60 )
      break;
    v91 = (__int64)sub_599C2((__int64 *)v94, 0LL, ii, 0, v66);
    if ( !v91 )
      goto LABEL_363;
    lyxml_free(v93, ii);
  }
  for ( jj = v102; ; jj = (__int64)v82 )
  {
    if ( jj )
    {
      v82 = *(_QWORD **)(jj + 32);
      v62 = 1;
    }
    else
    {
      v62 = 0;
    }
    if ( !v62 )
      break;
    if ( !strcmp(*(const char **)(jj + 48), "container") )
    {
      v91 = (__int64)sub_587B3((__int64 *)v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "leaf-list") )
    {
      v91 = sub_551D2(v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "leaf") )
    {
      v91 = (__int64)sub_54422((__int64 *)v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "list") )
    {
      v91 = (__int64)sub_56721((__int64 *)v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "choice") )
    {
      v91 = (__int64)sub_52E00(v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "uses") )
    {
      v91 = (__int64)sub_5CBDA((__int64 *)v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "anyxml") )
    {
      v91 = (__int64)sub_53A72((__int64 *)v94, 0LL, jj, 32, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "anydata") )
    {
      v91 = (__int64)sub_53A72((__int64 *)v94, 0LL, jj, 32800, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "rpc") )
    {
      v91 = (__int64)sub_5C028(v94, 0LL, jj, 0, v66);
    }
    else if ( !strcmp(*(const char **)(jj + 48), "notification") )
    {
      v91 = (__int64)sub_5B1D8(v94, 0LL, jj, 0, v66, v61);
    }
    if ( !v91 )
      goto LABEL_363;
    lyxml_free(v93, jj);
  }
  for ( kk = v106; ; kk = (__int64)v82 )
  {
    if ( kk )
    {
      v82 = *(_QWORD **)(kk + 32);
      v64 = 1;
    }
    else
    {
      v64 = 0;
    }
    if ( !v64 )
      break;
    v63 = sub_4E308((__int64 *)v94, 0LL, kk, 104LL * *(unsigned __int8 *)(v94 + 77) + *(_QWORD *)(v94 + 136), 0, v66);
    ++*(_BYTE *)(v94 + 77);
    if ( v63 )
      goto LABEL_363;
    lyxml_free(v93, kk);
  }
  return 0LL;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000609BB) ----------------------------------------------------
_QWORD *__fastcall sub_609BB(void **a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  size_t v7; // rax
  __int64 v8; // r9
  __int64 v9; // r9
  int *v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rbx
  int *v14; // rax
  __int64 v15; // r9
  __int64 v16; // [rsp+8h] [rbp-48h]
  __int64 v17; // [rsp+10h] [rbp-40h]
  void **v18; // [rsp+18h] [rbp-38h]
  _QWORD *v19; // [rsp+20h] [rbp-30h]
  void *v20; // [rsp+28h] [rbp-28h]
  __int64 v21; // [rsp+30h] [rbp-20h]
  char *s; // [rsp+38h] [rbp-18h]

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v20 = *a1;
  v19 = 0LL;
  v21 = lyxml_parse_mem(v20, a2, 2LL);
  if ( !v21 )
    return 0LL;
  if ( *(_QWORD *)(v21 + 48) && !strcmp(*(const char **)(v21 + 48), "submodule") )
  {
    s = (char *)lyxml_get_attr(v21, "name", 0LL);
    if ( s )
    {
      if ( !(unsigned int)sub_3B812(v20, s, 5u, 0LL, 0LL, v5) )
      {
        v19 = calloc(1uLL, 0xB0uLL);
        if ( v19 )
        {
          *v19 = v20;
          v7 = strlen(s);
          v19[1] = lydict_insert(v20, s, v7);
          *((_BYTE *)v19 + 64) |= 1u;
          *((_BYTE *)v19 + 64) = (*((_BYTE *)v18 + 64) >> 7 << 7) | v19[8] & 0x7F;
          v19[21] = v18;
          if ( !(unsigned int)sub_3CCDF(v19) )
          {
            sub_12222(0LL, 2u, 0, "Reading submodule \"%s\".", v19[1], v8);
            if ( !(unsigned int)sub_5D54B((__int64)v18, (__int64)v19, v21, v16) )
            {
              sub_3DBD2((__int64)v19);
              lyxml_free(v20, v21);
              sub_3CDA9((__int64)v20);
              sub_12222(0LL, 2u, 0, "Submodule \"%s\" successfully parsed.", v19[1], v9);
              return v19;
            }
          }
        }
        else
        {
          sub_12222((__int64)v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_read_submodule", v6);
        }
      }
    }
    else
    {
      sub_13937(v20, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(v21 + 48));
    }
  }
  else
  {
    sub_13937(v20, 5, 0, 0LL, *(_QWORD *)(v21 + 48), v3);
  }
  lyxml_free(v20, v21);
  if ( v19 )
  {
    v13 = v19[1];
    v14 = (int *)ly_errno_glob_address(v20);
    sub_12222((__int64)v20, 0, *v14, "Submodule \"%s\" parsing failed.", v13, v15);
    sub_2B768((__int64)v19, (void ***)&v16, 0);
    sub_3CDA9((__int64)v20);
    sub_A9496((__int64)v19);
    sub_AA3F6((__int64)v19);
    sub_A3E76(v19, 0LL);
  }
  else
  {
    v10 = (int *)ly_errno_glob_address(v20);
    sub_12222((__int64)v20, 0, *v10, "Submodule parsing failed.", v11, v12);
  }
  return 0LL;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7510: using guessed type __int64 __fastcall lyxml_parse_mem(_QWORD, _QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000060D3A) ----------------------------------------------------
__int64 __fastcall sub_60D3A(void *a1, __int64 a2, char *a3, int a4)
{
  __int64 v4; // r9
  __int64 result; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  size_t v10; // rax
  __int64 v11; // r9
  __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  const char *v17; // rax
  void *v18; // rcx
  const char *v19; // rdx
  __int64 v20; // rdi
  int *v21; // rax
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rbx
  int *v25; // rax
  __int64 v26; // r9
  int v27; // [rsp+4h] [rbp-5Ch]
  const char *s1; // [rsp+8h] [rbp-58h]
  __int64 v29; // [rsp+10h] [rbp-50h]
  void *v30; // [rsp+18h] [rbp-48h]
  int v31; // [rsp+2Ch] [rbp-34h]
  __int128 v32; // [rsp+30h] [rbp-30h]
  char *s; // [rsp+40h] [rbp-20h]
  unsigned __int64 v34; // [rsp+48h] [rbp-18h]

  v30 = a1;
  v29 = a2;
  s1 = a3;
  v27 = a4;
  v34 = __readfsqword(0x28u);
  v32 = (unsigned __int64)calloc(1uLL, 0x28uLL);
  if ( !(_QWORD)v32 )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_read_module_", v4);
    return 0LL;
  }
  if ( !*(_QWORD *)(a2 + 48) || strcmp(*(const char **)(a2 + 48), "module") )
  {
    if ( (unsigned int)sub_C462("submodule", *(_BYTE **)(a2 + 48)) )
      sub_13937(a1, 43, 0, 0LL, v6, v7);
    else
      sub_13937(a1, 5, 0, 0LL, *(_QWORD *)(a2 + 48), v7);
    goto LABEL_45;
  }
  s = (char *)lyxml_get_attr(a2, "name", 0LL);
  if ( !s )
  {
    sub_13937(a1, 13, 0, 0LL, (__int64)"name", *(_QWORD *)(a2 + 48));
    goto LABEL_45;
  }
  if ( (unsigned int)sub_3B812(a1, s, 5u, 0LL, 0LL, v8) )
    goto LABEL_45;
  *((_QWORD *)&v32 + 1) = calloc(1uLL, 0xB8uLL);
  if ( !*((_QWORD *)&v32 + 1) )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_read_module_", v9);
    goto LABEL_45;
  }
  **((_QWORD **)&v32 + 1) = a1;
  v10 = strlen(s);
  *(_QWORD *)(*((_QWORD *)&v32 + 1) + 8LL) = lydict_insert(a1, s, v10);
  *(_BYTE *)(*((_QWORD *)&v32 + 1) + 64LL) &= 0xFEu;
  *(_BYTE *)(*((_QWORD *)&v32 + 1) + 64LL) = ((v27 != 0) << 7) | *(_BYTE *)(*((_QWORD *)&v32 + 1) + 64LL) & 0x7F;
  if ( (unsigned int)sub_3CCDF(*((__int64 **)&v32 + 1)) )
    goto LABEL_45;
  sub_12222(0LL, 2u, 0, "Reading module \"%s\".", *(_QWORD *)(*((_QWORD *)&v32 + 1) + 8LL), v11);
  v12 = 0LL;
  v31 = sub_5D54B(*((__int64 *)&v32 + 1), 0LL, v29, v32);
  if ( v31 == -1 )
    goto LABEL_45;
  if ( v31 == 1 )
  {
    if ( *(_DWORD *)(v32 + 32) )
      __assert_fail(
        "!unres->count",
        "/home/mantovan/Repositories/libyang/src/parser_yin.c",
        0x1CC8u,
        "yin_read_module_");
  }
  else
  {
    if ( !v27 && *(_BYTE *)(*((_QWORD *)&v32 + 1) + 64LL) < 0 )
    {
      v12 = v32;
      if ( (unsigned int)sub_2ABDE(*((__int64 **)&v32 + 1), v32, 0LL, 0x8000u, 0LL) == -1 )
        goto LABEL_45;
    }
    if ( *(_DWORD *)(v32 + 32) )
    {
      v12 = v32;
      if ( (unsigned int)sub_2A9F8(*((__int64 **)&v32 + 1), v32, v32, v14, v15, v16) )
        goto LABEL_45;
    }
    if ( (unsigned int)sub_3D700(*((__int64 *)&v32 + 1), v12, v13, v14, v15, v16) )
      goto LABEL_45;
  }
  sub_3DBD2(*((__int64 *)&v32 + 1));
  if ( (unsigned int)sub_3E3AF(*((__int64 *)&v32 + 1)) || (unsigned int)sub_3F5FE(*((__int64 *)&v32 + 1)) )
  {
LABEL_45:
    v20 = *((_QWORD *)&v32 + 1);
    sub_2B768(*((__int64 *)&v32 + 1), (void ***)&v32, 1);
    if ( *((_QWORD *)&v32 + 1) )
    {
      v24 = *(_QWORD *)(*((_QWORD *)&v32 + 1) + 8LL);
      v25 = (int *)ly_errno_glob_address(v20);
      sub_12222((__int64)v30, 0, *v25, "Module \"%s\" parsing failed.", v24, v26);
      sub_3CDA9((__int64)v30);
      sub_A9496(*((__int64 *)&v32 + 1));
      sub_3C867(*((_BYTE **)&v32 + 1), 1);
      sub_A67C8(*((unsigned __int8 **)&v32 + 1), 0LL, 0, 1);
      result = 0LL;
    }
    else
    {
      if ( (unsigned int)ly_vecode(v30) != 36 )
      {
        v21 = (int *)ly_errno_glob_address(v30);
        sub_12222((__int64)v30, 0, *v21, "Module parsing failed.", v22, v23);
      }
      result = 0LL;
    }
    return result;
  }
  if ( s1 && (!*(_BYTE *)(*((_QWORD *)&v32 + 1) + 68LL) || strcmp(s1, *(const char **)(*((_QWORD *)&v32 + 1) + 88LL))) )
  {
    sub_12222(
      0LL,
      2u,
      0,
      "Module \"%s\" parsed with the wrong revision (\"%s\" instead \"%s\").",
      *(_QWORD *)(*((_QWORD *)&v32 + 1) + 8LL),
      *(_QWORD *)(*((_QWORD *)&v32 + 1) + 88LL),
      s1);
    goto LABEL_45;
  }
  if ( v31 )
  {
    sub_A67C8(*((unsigned __int8 **)&v32 + 1), 0LL, 0, 0);
    *((_QWORD *)&v32 + 1) = ly_ctx_get_module(a1, s, s1, 0LL);
    if ( !*((_QWORD *)&v32 + 1) )
      __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser_yin.c", 0x1CF7u, "yin_read_module_");
  }
  else
  {
    if ( (unsigned int)sub_3FFC3(*((__int64 **)&v32 + 1)) )
      goto LABEL_45;
    sub_3C867(*((_BYTE **)&v32 + 1), 0);
  }
  sub_2B768(0LL, (void ***)&v32, 0);
  sub_3CDA9((__int64)a1);
  if ( *(_BYTE *)(*((_QWORD *)&v32 + 1) + 64LL) >= 0 )
    v17 = "imported";
  else
    v17 = "implemented";
  if ( *(_BYTE *)(*((_QWORD *)&v32 + 1) + 68LL) )
    v18 = *(void **)(*((_QWORD *)&v32 + 1) + 88LL);
  else
    v18 = &unk_10F10F;
  if ( *(_BYTE *)(*((_QWORD *)&v32 + 1) + 68LL) )
    v19 = "@";
  else
    v19 = (const char *)&unk_10F10F;
  sub_12222(
    0LL,
    2u,
    0,
    "Module \"%s%s%s\" successfully parsed as %s.",
    *(_QWORD *)(*((_QWORD *)&v32 + 1) + 8LL),
    (__int64)v19,
    v18,
    v17);
  return *((_QWORD *)&v32 + 1);
}
// 71B0: using guessed type __int64 __fastcall ly_vecode(_QWORD);
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000061383) ----------------------------------------------------
__int64 __fastcall sub_61383(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  int *v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // ST28_8
  int v9; // [rsp+4h] [rbp-2Ch]
  char *v10; // [rsp+8h] [rbp-28h]
  __int64 v11; // [rsp+20h] [rbp-10h]

  v10 = (char *)a3;
  v9 = a4;
  v11 = lyxml_parse_mem(a1, a2, 2LL);
  if ( v11 )
  {
    v8 = sub_60D3A((void *)a1, v11, v10, v9);
    lyxml_free(a1, v11);
    result = v8;
  }
  else
  {
    v4 = (int *)ly_errno_glob_address(a1);
    sub_12222(a1, 0, *v4, "Module parsing failed.", v5, v6);
    result = 0LL;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7510: using guessed type __int64 __fastcall lyxml_parse_mem(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);

//----- (000000000006141C) ----------------------------------------------------
signed __int64 __fastcall sub_6141C(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, char *a5, char *a6, __int64 a7)
{
  char *v8; // [rsp+10h] [rbp-50h]
  char *s1; // [rsp+18h] [rbp-48h]
  int v10; // [rsp+24h] [rbp-3Ch]
  __int64 v11; // [rsp+28h] [rbp-38h]
  char v12; // [rsp+40h] [rbp-20h]
  _BYTE *v13; // [rsp+48h] [rbp-18h]
  char *s2; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  s1 = a5;
  v8 = a6;
  v15 = __readfsqword(0x28u);
  v13 = (_BYTE *)lys_ext_complex_get_substmt(a4, a3, &v12);
  if ( !v13 )
  {
    sub_13937(*a1, 6, 0, 0LL, a2[6], *(_QWORD *)(a2[1] + 48LL));
    return 1LL;
  }
  if ( *v13 )
  {
    sub_13937(*a1, 14, 0, 0LL, a2[6], *(_QWORD *)(a2[1] + 48LL));
    return 1LL;
  }
  if ( (unsigned int)sub_411CA((__int64 *)a1, v11, 0xBu, a2, v10, 0LL, a7) )
    return 1LL;
  s2 = (char *)lyxml_get_attr(a2, "value", 0LL);
  if ( s2 )
  {
    if ( s1 && !strcmp(s1, s2) )
    {
      *v13 = 1;
    }
    else
    {
      if ( !v8 || strcmp(v8, s2) )
      {
        sub_13937(*a1, 10, 0, 0LL, (__int64)s2, a2[6]);
        return 1LL;
      }
      *v13 = 2;
    }
  }
  else
  {
    sub_13937(*a1, 13, 0, 0LL, (__int64)"value", a2[6]);
  }
  return 0LL;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (000000000006164E) ----------------------------------------------------
signed __int64 __fastcall sub_6164E(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, int a5, const char *a6, __int64 a7)
{
  __int64 v8; // r9
  void **v9; // rbx
  __int64 v10; // r9
  void **v11; // rbx
  __int64 v12; // r9
  __int64 *v13; // rbx
  _QWORD *v14; // rbx
  _QWORD *v15; // rbx
  __int64 v16; // r9
  _QWORD *v17; // rbx
  _QWORD *v18; // rbx
  __int64 v19; // rax
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // r9
  __int64 v23; // r9
  const char *v24; // [rsp+8h] [rbp-78h]
  int v25; // [rsp+10h] [rbp-70h]
  int v26; // [rsp+14h] [rbp-6Ch]
  __int64 v27; // [rsp+18h] [rbp-68h]
  int i; // [rsp+3Ch] [rbp-44h]
  __int64 v29; // [rsp+40h] [rbp-40h]
  __int128 v30; // [rsp+48h] [rbp-38h]
  _BYTE *v31; // [rsp+58h] [rbp-28h]
  void *v32; // [rsp+60h] [rbp-20h]
  unsigned __int64 v33; // [rsp+68h] [rbp-18h]

  v27 = a3;
  v26 = a4;
  v25 = a5;
  v24 = a6;
  v33 = __readfsqword(0x28u);
  v30 = (unsigned __int64)lys_ext_complex_get_substmt(a4, a3, &v29);
  if ( !(_QWORD)v30 )
  {
    sub_13937(*a1, 6, 0, 0LL, a2[6], *(_QWORD *)(a2[1] + 48LL), a7);
    return 1LL;
  }
  if ( *(_DWORD *)(v29 + 16) <= 1u && *(_QWORD *)v30 )
  {
    sub_13937(*a1, 14, 0, 0LL, a2[6], *(_QWORD *)(a2[1] + 48LL), a7);
    return 1LL;
  }
  i = 0;
  if ( *(_DWORD *)(v29 + 16) > 1u )
  {
    *((_QWORD *)&v30 + 1) = v30;
    if ( *(_QWORD *)v30 )
    {
      for ( i = 0; *(_QWORD *)(8LL * i + **((_QWORD **)&v30 + 1)); ++i )
        ;
    }
    else
    {
      **((_QWORD **)&v30 + 1) = malloc(0x10uLL);
      if ( !**((_QWORD **)&v30 + 1) )
      {
        sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_parse_extcomplex_str", v8, a7);
        return 1LL;
      }
      if ( v26 == 3 )
      {
        v9 = (void **)(*((_QWORD *)&v30 + 1) + 8LL);
        *v9 = malloc(0x10uLL);
        if ( !*(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL) )
        {
          sub_12222(
            (__int64)*a1,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"yin_parse_extcomplex_str",
            v10,
            a7);
          return 1LL;
        }
      }
      else if ( v26 == 1 )
      {
        v11 = (void **)(*((_QWORD *)&v30 + 1) + 8LL);
        *v11 = malloc(2uLL);
        if ( !*(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL) )
        {
          sub_12222(
            (__int64)*a1,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"yin_parse_extcomplex_str",
            v12,
            a7);
          return 1LL;
        }
      }
    }
    *(_QWORD *)&v30 = **((_QWORD **)&v30 + 1);
  }
  if ( (unsigned int)sub_411CA((__int64 *)a1, v27, 0xBu, a2, v26, (unsigned __int8)i, a7) )
    return 1LL;
  if ( v25 )
  {
    v13 = (__int64 *)(8LL * i + v30);
    *v13 = sub_410A7(*a1, (__int64)a2, v24);
    if ( !*(_QWORD *)(8LL * i + v30) )
      return 1LL;
  }
  else
  {
    v14 = (_QWORD *)(8LL * i + v30);
    *v14 = lyxml_get_attr(a2, v24, 0LL);
    if ( !*(_QWORD *)(8LL * i + v30) )
    {
      sub_13937(*a1, 13, 0, 0LL, (__int64)v24, a2[6], a7);
      return 1LL;
    }
    v15 = (_QWORD *)(8LL * i + v30);
    *v15 = lydict_insert(*a1, *v15, 0LL);
    if ( v26 == 3 )
    {
      if ( !a2[3] )
      {
        sub_13937(*a1, 12, 0, 0LL, (__int64)"prefix", a2[6], a7);
        return 1LL;
      }
      if ( strcmp(*(const char **)(a2[3] + 48LL), "prefix") )
      {
        sub_13937(*a1, 5, 0, 0LL, *(_QWORD *)(a2[3] + 48LL), v16, a7);
        return 1LL;
      }
      if ( *(_QWORD *)(a2[3] + 32LL) )
      {
        sub_13937(*a1, 5, 0, 0LL, *(_QWORD *)(*(_QWORD *)(a2[3] + 32LL) + 48LL), v16, a7);
        return 1LL;
      }
      if ( *((_QWORD *)&v30 + 1) )
        *(_QWORD *)&v30 = *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL);
      else
        *(_QWORD *)&v30 = v30 + 8;
      v17 = (_QWORD *)(8LL * i + v30);
      *v17 = lyxml_get_attr(a2[3], "value", 0LL);
      if ( !*(_QWORD *)(8LL * i + v30) )
      {
        sub_13937(*a1, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(a2[3] + 48LL), a7);
        return 1LL;
      }
      v18 = (_QWORD *)(8LL * i + v30);
      *v18 = lydict_insert(*a1, *v18, 0LL);
      if ( !*(_QWORD *)(8LL * i + v30)
        || (unsigned int)sub_411CA((__int64 *)a1, v27, 0xBu, (_QWORD *)a2[3], 13, (unsigned __int8)i, a7) )
      {
        return 1LL;
      }
    }
    else if ( v26 == 1 )
    {
      if ( *((_QWORD *)&v30 + 1) )
        v19 = *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL);
      else
        v19 = v30 + 8;
      *(_QWORD *)&v30 = v19;
      if ( a2[3] )
      {
        if ( strcmp(*(const char **)(a2[3] + 48LL), "yin-element") )
        {
          sub_13937(*a1, 5, 0, 0LL, *(_QWORD *)(a2[3] + 48LL), v20, a7);
          return 1LL;
        }
        if ( *(_QWORD *)(a2[3] + 32LL) )
        {
          sub_13937(*a1, 5, 0, 0LL, *(_QWORD *)(*(_QWORD *)(a2[3] + 32LL) + 48LL), v20, a7);
          return 1LL;
        }
        v31 = (_BYTE *)lyxml_get_attr(a2[3], "value", 0LL);
        if ( !v31 )
        {
          sub_13937(*a1, 13, 0, 0LL, (__int64)"value", *(_QWORD *)(a2[3] + 48LL), a7);
          return 1LL;
        }
        if ( (unsigned int)sub_C462(v31, "true") )
        {
          *(_BYTE *)(i + (_QWORD)v30) = 1;
        }
        else
        {
          if ( !(unsigned int)sub_C462(v31, "false") )
          {
            sub_13937(*a1, 10, 0, 0LL, v30, a2[6], a7);
            return 1LL;
          }
          *(_BYTE *)(i + (_QWORD)v30) = 2;
        }
        if ( (unsigned int)sub_411CA((__int64 *)a1, v27, 0xBu, (_QWORD *)a2[3], 22, (unsigned __int8)i, a7) )
          return 1LL;
      }
      else
      {
        *(_BYTE *)(i + (_QWORD)v30) = 2;
      }
    }
  }
  if ( *((_QWORD *)&v30 + 1) )
  {
    v32 = realloc(**((void ***)&v30 + 1), 8LL * (i + 2));
    if ( !v32 )
    {
      sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_parse_extcomplex_str", v21, a7);
      lydict_remove(*a1, *(_QWORD *)(8LL * i + **((_QWORD **)&v30 + 1)));
      *(_QWORD *)(8LL * i + **((_QWORD **)&v30 + 1)) = 0LL;
      return 1LL;
    }
    **((_QWORD **)&v30 + 1) = v32;
    *(_QWORD *)(8 * (i + 1LL) + **((_QWORD **)&v30 + 1)) = 0LL;
    if ( v26 == 3 )
    {
      v32 = realloc(*(void **)(*((_QWORD *)&v30 + 1) + 8LL), 8LL * (i + 2));
      if ( !v32 )
      {
        sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_parse_extcomplex_str", v22, a7);
        lydict_remove(*a1, *(_QWORD *)(8LL * i + *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL)));
        *(_QWORD *)(8LL * i + *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL)) = 0LL;
        return 1LL;
      }
      *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL) = v32;
      *(_QWORD *)(8 * (i + 1LL) + *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL)) = 0LL;
    }
    else if ( v26 == 1 )
    {
      v32 = realloc(*(void **)(*((_QWORD *)&v30 + 1) + 8LL), i + 2);
      if ( !v32 )
      {
        sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_parse_extcomplex_str", v23, a7);
        *(_BYTE *)(*(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL) + i) = 0;
        return 1LL;
      }
      *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL) = v32;
      *(_BYTE *)(i + 1LL + *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8LL)) = 0;
    }
  }
  return 0LL;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000062180) ----------------------------------------------------
_WORD *__fastcall sub_62180(__int64 a1, __int64 a2, unsigned int a3, unsigned __int16 a4)
{
  _WORD *result; // rax
  unsigned __int16 v5; // [rsp+8h] [rbp-38h]
  __int64 v6; // [rsp+28h] [rbp-18h]
  _WORD *v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v5 = a4;
  v8 = __readfsqword(0x28u);
  v7 = (_WORD *)lys_ext_complex_get_substmt(a3, a2, &v6);
  if ( v7 )
  {
    if ( *(_DWORD *)(v6 + 16) <= 1u && v5 & *v7 )
    {
      sub_13937(**(void ***)(a2 + 48), 14, 0, 0LL, *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL));
      result = 0LL;
    }
    else
    {
      result = v7;
    }
  }
  else
  {
    sub_13937(**(void ***)(a2 + 48), 6, 0, 0LL, *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL));
    result = 0LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000006228E) ----------------------------------------------------
_BOOL8 __fastcall sub_6228E(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, char *a5, char *a6, __int64 a7, __int16 a8, __int16 a9, __int64 a10)
{
  char *v11; // [rsp+10h] [rbp-40h]
  char *s1; // [rsp+18h] [rbp-38h]
  int v13; // [rsp+24h] [rbp-2Ch]
  __int64 v14; // [rsp+28h] [rbp-28h]
  _WORD *v15; // [rsp+40h] [rbp-10h]
  char *s2; // [rsp+48h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  s1 = a5;
  v11 = a6;
  v15 = sub_62180((__int64)a2, a3, a4, a7);
  if ( !v15 )
    return 1LL;
  s2 = (char *)lyxml_get_attr(a2, "value", 0LL);
  if ( s2 )
  {
    if ( !strcmp(s1, s2) )
    {
      *v15 |= a8;
    }
    else
    {
      if ( strcmp(v11, s2) )
      {
        sub_13937(*a1, 10, 0, 0LL, (__int64)s2, a2[6]);
        return 1LL;
      }
      *v15 |= a9;
    }
  }
  else
  {
    sub_13937(*a1, 13, 0, 0LL, (__int64)"value", a2[6]);
  }
  return (unsigned int)sub_411CA((__int64 *)a1, v14, 0xBu, a2, v13, 0LL, a10) != 0;
}
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);

//----- (0000000000062426) ----------------------------------------------------
__int64 *__fastcall sub_62426(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 *result; // rax
  unsigned int v4; // [rsp+Ch] [rbp-34h]
  __int64 v5; // [rsp+20h] [rbp-20h]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 *v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v8 = __readfsqword(0x28u);
  v7 = (__int64 *)lys_ext_complex_get_substmt(a3, a2, &v5);
  if ( v7 )
  {
    if ( *(_DWORD *)(v5 + 16) <= 1u )
    {
      for ( i = *v7; i; i = *(_QWORD *)(i + 80) )
      {
        if ( v4 == (unsigned int)sub_C1906(*(_DWORD *)(i + 56)) )
        {
          sub_13937(**(void ***)(a2 + 48), 14, 0, 0LL, *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL));
          return 0LL;
        }
      }
    }
    result = v7;
  }
  else
  {
    sub_13937(**(void ***)(a2 + 48), 6, 0, 0LL, *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL));
    result = 0LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (0000000000062554) ----------------------------------------------------
__int64 __fastcall sub_62554(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // r9
  __int64 v5; // r9
  int v6; // [rsp+24h] [rbp-2Ch]
  __int64 v7; // [rsp+28h] [rbp-28h]
  __int128 v8; // [rsp+30h] [rbp-20h]
  void *v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v8 = (unsigned __int64)lys_ext_complex_get_substmt(a3, a2, &v7);
  if ( !(_QWORD)v8 )
  {
    sub_13937(**(void ***)(a2 + 48), 6, 0, 0LL, *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL));
    return 0LL;
  }
  if ( *(_DWORD *)(v7 + 16) <= 1u && *(_QWORD *)v8 )
  {
    sub_13937(**(void ***)(a2 + 48), 14, 0, 0LL, *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL));
    return 0LL;
  }
  v6 = 0;
  if ( *(_DWORD *)(v7 + 16) > 1u )
  {
    *((_QWORD *)&v8 + 1) = v8;
    *(_QWORD *)&v8 = *(_QWORD *)v8;
    if ( (_QWORD)v8 )
    {
      v6 = 0;
      while ( *(_QWORD *)v8 )
      {
        *(_QWORD *)&v8 = v8 + 8;
        ++v6;
      }
    }
    else
    {
      *(_QWORD *)&v8 = malloc(0x10uLL);
      **((_QWORD **)&v8 + 1) = v8;
      if ( !(_QWORD)v8 )
      {
        sub_12222(
          **(_QWORD **)(a2 + 48),
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"yin_getplace_for_extcomplex_struct",
          v4);
        return 0LL;
      }
    }
  }
  if ( *((_QWORD *)&v8 + 1) )
  {
    v9 = realloc(**((void ***)&v8 + 1), 8LL * (v6 + 2));
    if ( !v9 )
    {
      sub_12222(
        **(_QWORD **)(a2 + 48),
        0,
        1,
        "Memory allocation failed (%s()).",
        (__int64)"yin_getplace_for_extcomplex_struct",
        v5);
      return 0LL;
    }
    **((_QWORD **)&v8 + 1) = v9;
    *(_QWORD *)&v8 = **((_QWORD **)&v8 + 1);
    *(_QWORD *)(8 * (v6 + 1LL) + v8) = 0LL;
  }
  return 8LL * v6 + v8;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000627C3) ----------------------------------------------------
_BOOL8 __fastcall sub_627C3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // r9
  __int64 v20; // r9
  __int64 v21; // rax
  __int64 v22; // r9
  _QWORD *v23; // rax
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9
  __int64 v27; // r9
  __int64 v28; // r9
  __int64 v29; // r9
  __int64 v30; // r9
  __int64 v31; // r9
  __int64 v32; // r9
  __int64 v33; // r9
  __int64 v34; // r9
  _QWORD *v35; // rbx
  __int64 v36; // r9
  __int64 v37; // r9
  __int64 v38; // r9
  __int64 v39; // r9
  size_t v40; // rax
  _QWORD *v41; // rbx
  __int64 v42; // r9
  __int64 v43; // r9
  const char *v44; // rdi
  __int64 v45; // r9
  __int64 v46; // r9
  _QWORD *v47; // rbx
  __int64 v48; // r9
  __int64 v49; // rbx
  int *v50; // rax
  __int64 v51; // r9
  char v52; // al
  __int64 v54; // [rsp+0h] [rbp-C0h]
  __int64 v55; // [rsp+8h] [rbp-B8h]
  __int64 *v56; // [rsp+18h] [rbp-A8h]
  char v57; // [rsp+2Fh] [rbp-91h]
  int j; // [rsp+30h] [rbp-90h]
  int k; // [rsp+30h] [rbp-90h]
  int l; // [rsp+30h] [rbp-90h]
  int m; // [rsp+30h] [rbp-90h]
  int n; // [rsp+30h] [rbp-90h]
  int ii; // [rsp+30h] [rbp-90h]
  int jj; // [rsp+30h] [rbp-90h]
  int ll; // [rsp+30h] [rbp-90h]
  int mm; // [rsp+30h] [rbp-90h]
  int nn; // [rsp+30h] [rbp-90h]
  int i2; // [rsp+30h] [rbp-90h]
  int kk; // [rsp+34h] [rbp-8Ch]
  char *endptr; // [rsp+38h] [rbp-88h]
  __int64 v71; // [rsp+40h] [rbp-80h]
  _QWORD *v72; // [rsp+48h] [rbp-78h]
  _QWORD *i; // [rsp+50h] [rbp-70h]
  _QWORD *i1; // [rsp+58h] [rbp-68h]
  __int64 *v75; // [rsp+60h] [rbp-60h]
  __int64 *v76; // [rsp+68h] [rbp-58h]
  char *s1; // [rsp+70h] [rbp-50h]
  char *v78; // [rsp+78h] [rbp-48h]
  unsigned __int64 v79; // [rsp+80h] [rbp-40h]
  void *v80; // [rsp+88h] [rbp-38h]
  __int64 v81; // [rsp+90h] [rbp-30h]
  __int64 v82; // [rsp+98h] [rbp-28h]
  __int64 **v83; // [rsp+A0h] [rbp-20h]
  unsigned __int64 v84; // [rsp+A8h] [rbp-18h]

  v56 = a1;
  v55 = a3;
  v54 = a4;
  v84 = __readfsqword(0x28u);
  for ( i = *(_QWORD **)(a3 + 24); ; i = v72 )
  {
    if ( i )
    {
      v72 = (_QWORD *)i[4];
      v52 = 1;
    }
    else
    {
      v52 = 0;
    }
    if ( !v52 )
      break;
    if ( !i[7] )
      goto LABEL_472;
    if ( i[7] == *(_QWORD *)(v55 + 56) && a2[3] & 1 && i[6] == *(_QWORD *)(*a2 + 40) )
    {
      if ( a2[2] )
      {
        sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(v55 + 48), v54);
        return 1LL;
      }
      a2[2] = i[8];
      i[8] = 0LL;
      goto LABEL_472;
    }
    if ( strcmp(*(const char **)(i[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
    {
      if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 0, 0LL, v54) )
        return 1LL;
LABEL_472:
      lyxml_free(*v56, i);
      continue;
    }
    if ( !strcmp((const char *)i[6], "description") )
    {
      if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 6u, 1, "text", v54) )
        return 1LL;
      goto LABEL_472;
    }
    if ( !strcmp((const char *)i[6], "reference") )
    {
      if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0xFu, 1, "text", v54) )
        return 1LL;
      goto LABEL_472;
    }
    if ( !strcmp((const char *)i[6], "units") )
    {
      if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0x11u, 0, "name", v54) )
        return 1LL;
      goto LABEL_472;
    }
    if ( strcmp((const char *)i[6], "type") )
    {
      if ( !strcmp((const char *)i[6], "typedef") )
      {
        v75 = (__int64 *)sub_62554((__int64)i, (__int64)a2, 0x2Fu);
        if ( !v75 )
          return 1LL;
        *v75 = (__int64)calloc(1uLL, 0x80uLL);
        if ( !*v75 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v5, v54);
          return 1LL;
        }
        if ( (unsigned int)sub_4778E(v56, a2, (__int64)i, *v75, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "if-feature") )
      {
        v75 = (__int64 *)sub_62554((__int64)i, (__int64)a2, 0x31u);
        if ( !v75 )
          return 1LL;
        *v75 = (__int64)calloc(1uLL, 0x20uLL);
        if ( !*v75 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v6, v54);
          return 1LL;
        }
        if ( (unsigned int)sub_41746((__int64)a2, 0, (__int64)i, *v75, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "status") )
      {
        v76 = (__int64 *)sub_62180((__int64)i, (__int64)a2, 0x1Au, 0x38u);
        if ( !v76 )
          return 1LL;
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        if ( !strcmp(s1, "current") )
        {
          *(_WORD *)v76 |= 8u;
        }
        else if ( !strcmp(s1, "deprecated") )
        {
          *(_WORD *)v76 |= 0x10u;
        }
        else
        {
          if ( strcmp(s1, "obsolete") )
          {
            sub_13937((void *)*v56, 10, 0, 0LL, (__int64)s1, i[6], v54);
            return 1LL;
          }
          *(_WORD *)v76 |= 0x20u;
        }
        if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 26, 0LL, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "config") )
      {
        if ( (unsigned int)sub_6228E((void **)v56, i, (__int64)a2, 0x18u, "true", "false", 3LL, 5, 6, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "argument") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 1u, 0, "name", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "default") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 5u, 0, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "mandatory") )
      {
        if ( (unsigned int)sub_6228E((void **)v56, i, (__int64)a2, 0x18u, "true", "false", 192LL, 64, 128, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "error-app-tag") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 7u, 0, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "error-message") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 8u, 1, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "prefix") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0xDu, 0, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "namespace") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0xAu, 0, "uri", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "presence") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0xEu, 0, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "revision-date") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0x10u, 0, "date", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "key") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 9u, 0, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "base") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 2u, 0, "name", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "ordered-by") )
      {
        if ( (unsigned int)sub_6228E((void **)v56, i, (__int64)a2, 0x19u, "user", "system", 256LL, 256, 0, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "belongs-to") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 3u, 0, "module", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "contact") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 4u, 1, "text", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "organization") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0xBu, 1, "text", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "path") )
      {
        if ( (unsigned int)sub_6164E((void **)v56, i, (__int64)a2, 0xCu, 0, "value", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "require-instance") )
      {
        if ( (unsigned int)sub_6141C((void **)v56, i, (__int64)a2, 0x15u, "true", "false", v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "modifier") )
      {
        if ( (unsigned int)sub_6141C((void **)v56, i, (__int64)a2, 0x14u, "invert-match", 0LL, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "fraction-digits") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(27LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *(_BYTE *)v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        j = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( j = 0; *(_BYTE *)(*v75 + j); ++j )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(2uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v7, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(*v75 + j);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        v82 = strtol(s1, 0LL, 10);
        if ( v82 <= 0 || v82 > 18 )
        {
          sub_13937((void *)*v56, 10, 0, 0LL, (__int64)s1, i[6], v54);
          return 1LL;
        }
        if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 26, (unsigned __int8)j, v54) )
          return 1LL;
        *(_BYTE *)v76 = v82;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (j + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v8, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_BYTE *)(j + 1LL + *v75) = 0;
        }
      }
      else if ( !strcmp((const char *)i[6], "max-elements") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(28LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        k = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( k = 0; *(_QWORD *)(8LL * k + *v75); ++k )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v9, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * k + *v75);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        while ( (*__ctype_b_loc())[*s1] & 0x2000 )
          ++s1;
        if ( !strcmp(s1, "unbounded") )
        {
          v79 = 0LL;
        }
        else
        {
          *__errno_location() = 0;
          endptr = 0LL;
          v79 = strtoul(s1, &endptr, 10);
          if ( *endptr || *s1 == 45 || *__errno_location() || !v79 || v79 > 0xFFFFFFFF )
          {
            sub_13937((void *)*v56, 10, 0, 0LL, (__int64)s1, i[6], v54);
            return 1LL;
          }
        }
        if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 28, (unsigned __int8)k, v54) )
          return 1LL;
        *v76 = (__int64)malloc(4uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v10, v54);
          return 1LL;
        }
        *(_DWORD *)*v76 = v79;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (k + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v11, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (k + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "min-elements") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(29LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        l = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( l = 0; *(_QWORD *)(8LL * l + *v75); ++l )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v12, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * l + *v75);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        while ( (*__ctype_b_loc())[*s1] & 0x2000 )
          ++s1;
        *__errno_location() = 0;
        endptr = 0LL;
        v79 = strtoul(s1, &endptr, 10);
        if ( *endptr || *s1 == 45 || *__errno_location() || v79 > 0xFFFFFFFF )
        {
          sub_13937((void *)*v56, 10, 0, 0LL, (__int64)s1, i[6], v54);
          return 1LL;
        }
        if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 28, (unsigned __int8)l, v54) )
          return 1LL;
        *v76 = (__int64)malloc(4uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v13, v54);
          return 1LL;
        }
        *(_DWORD *)*v76 = v79;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (l + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v14, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (l + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "value") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(18LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        m = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( m = 0; *(_QWORD *)(8LL * m + *v75); ++m )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v15, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * m + *v75);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        while ( (*__ctype_b_loc())[*s1] & 0x2000 )
          ++s1;
        v81 = strtoll(s1, 0LL, 10);
        if ( v81 < -2147483648LL || v81 > 0x7FFFFFFF )
        {
          sub_13937((void *)*v56, 10, 0, 0LL, (__int64)s1, i[6], v54);
          return 1LL;
        }
        if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 18, (unsigned __int8)m, v54) )
          return 1LL;
        *v76 = (__int64)malloc(4uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v16, v54);
          return 1LL;
        }
        *(_DWORD *)*v76 = v81;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (m + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v17, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (m + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "position") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(30LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        n = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( n = 0; *(_QWORD *)(8LL * n + *v75); ++n )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v18, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * n + *v75);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        v81 = strtoll(s1, 0LL, 10);
        if ( v81 < 0 || v81 > 0xFFFFFFFFLL )
        {
          sub_13937((void *)*v56, 10, 0, 0LL, (__int64)s1, i[6], v54);
          return 1LL;
        }
        if ( (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 30, (unsigned __int8)n, v54) )
          return 1LL;
        *v76 = (__int64)malloc(4uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v19, v54);
          return 1LL;
        }
        *(_DWORD *)*v76 = v81;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (n + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v20, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (n + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "module") )
      {
        v75 = (__int64 *)sub_62554((__int64)i, (__int64)a2, 0x20u);
        if ( !v75 )
          return 1LL;
        v21 = sub_60D3A((void *)*v56, (__int64)i, 0LL, (unsigned __int8)(*((_BYTE *)v56 + 64) >> 7));
        *v75 = v21;
        if ( !*v75 )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "when") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(54LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        ii = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( ii = 0; *(_QWORD *)(8LL * ii + *v75); ++ii )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v22, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * ii + *v75);
        }
        v23 = sub_51F02(v56, (__int64)i, v54);
        *v76 = (__int64)v23;
        if ( !*v76 )
          return 1LL;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (ii + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v24, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (ii + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "revision") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(55LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        jj = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( jj = 0; *(_QWORD *)(8LL * jj + *v75); ++jj )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v25, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * jj + *v75);
        }
        *v76 = (__int64)calloc(1uLL, 0x28uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v26, v54);
          return 1LL;
        }
        if ( (unsigned int)sub_48AF6(v56, (__int64)i, (_QWORD *)*v76, v54) )
          return 1LL;
        if ( v75 )
        {
          for ( kk = 0; kk < jj; ++kk )
          {
            if ( !strcmp(*(const char **)(8LL * kk + *v75), (const char *)*v76) )
              sub_12222(*v56, 1u, 0, "Module's revisions are not unique (%s).", *v76, v27, v54);
          }
        }
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (jj + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v28, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (jj + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "unique") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(31LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        ll = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( ll = 0; *(_QWORD *)(8LL * ll + *v75); ++ll )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v29, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * ll + *v75);
        }
        *v76 = (__int64)calloc(1uLL, 0x10uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v30, v54);
          return 1LL;
        }
        if ( (unsigned int)sub_48E4C(v56, (__int64)a2, (__int64)i, *v76, v54)
          || (unsigned int)sub_411CA(v56, (__int64)a2, 0xBu, i, 31, (unsigned __int8)ll, v54) )
        {
          return 1LL;
        }
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (ll + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v31, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (ll + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "action") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x21u);
        if ( !v75 || !sub_5C028((__int64)v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "anydata") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x22u);
        if ( !v75 || !sub_53A72(v56, (char *)a2, (__int64)i, 32800, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "anyxml") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x23u);
        if ( !v75 || !sub_53A72(v56, (char *)a2, (__int64)i, 32, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "case") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x24u);
        if ( !v75 || !sub_522BA(v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "choice") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x25u);
        if ( !v75 || !sub_52E00((__int64)v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "container") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x26u);
        if ( !v75 || !sub_587B3(v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "grouping") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x27u);
        if ( !v75 || !sub_599C2(v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "output") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x2Du);
        if ( !v75 || !sub_5A553((__int64)v56, (__int64)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "input") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x28u);
        if ( !v75 || !sub_5A553((__int64)v56, (__int64)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "leaf") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x29u);
        if ( !v75 || !sub_54422(v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "leaf-list") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x2Au);
        if ( !v75 || !sub_551D2((__int64)v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "list") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x2Bu);
        if ( !v75 || !sub_56721(v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "notification") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x2Cu);
        if ( !v75 || !sub_5B1D8((__int64)v56, (char *)a2, (__int64)i, 1u, v54, v32) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "uses") )
      {
        v75 = sub_62426((__int64)i, (__int64)a2, 0x2Eu);
        if ( !v75 || !sub_5CBDA(v56, (char *)a2, (__int64)i, 1u, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "length") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(50LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        mm = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( mm = 0; *(_QWORD *)(8LL * mm + *v75); ++mm )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v33, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * mm + *v75);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        *v76 = (__int64)calloc(1uLL, 0x38uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v34, v54);
          return 1LL;
        }
        v35 = (_QWORD *)*v76;
        *v35 = lydict_insert(*v56, s1, 0LL);
        if ( (unsigned int)sub_421DA(v56, (_QWORD *)*v76, (__int64)i, v54) )
          return 1LL;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (mm + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v36, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (mm + 1LL) + *v75) = 0LL;
        }
      }
      else if ( !strcmp((const char *)i[6], "must") )
      {
        v75 = (__int64 *)sub_62554((__int64)i, (__int64)a2, 0x33u);
        if ( !v75 )
          return 1LL;
        *v75 = (__int64)calloc(1uLL, 0x38uLL);
        if ( !*v75 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v37, v54);
          return 1LL;
        }
        if ( (unsigned int)sub_489FC(v56, (__int64)i, (__int64 *)*v75, v54) )
          return 1LL;
      }
      else if ( !strcmp((const char *)i[6], "pattern") )
      {
        v76 = (__int64 *)lys_ext_complex_get_substmt(52LL, a2, &v71);
        if ( !v76 )
        {
          sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
        {
          sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
          return 1LL;
        }
        v75 = 0LL;
        nn = 0;
        if ( *(_DWORD *)(v71 + 16) > 1u )
        {
          v75 = v76;
          if ( *v76 )
          {
            for ( nn = 0; *(_QWORD *)(8LL * nn + *v75); ++nn )
              ;
          }
          else
          {
            *v75 = (__int64)malloc(0x10uLL);
            if ( !*v75 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v38, v54);
              return 1LL;
            }
          }
          v76 = (__int64 *)(8LL * nn + *v75);
        }
        s1 = (char *)lyxml_get_attr(i, "value", 0LL);
        if ( !s1 )
        {
          sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
          return 1LL;
        }
        if ( (unsigned int)sub_36C95((void *)*v56, s1, 0LL) )
          return 1LL;
        *v76 = (__int64)calloc(1uLL, 0x38uLL);
        if ( !*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v39, v54);
          return 1LL;
        }
        v57 = 6;
        if ( ((*((_BYTE *)v56 + 64) >> 1) & 7u) > 1 )
        {
          v78 = 0LL;
          for ( i1 = (_QWORD *)i[3]; i1; i1 = (_QWORD *)i1[4] )
          {
            if ( i1[7]
              && !strcmp(*(const char **)(i1[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1")
              && !strcmp((const char *)i1[6], "modifier") )
            {
              if ( v78 )
              {
                sub_13937((void *)*v56, 14, 0, 0LL, (__int64)"modifier", i[6], v54);
                return 1LL;
              }
              v78 = (char *)lyxml_get_attr(i1, "value", 0LL);
              if ( !v78 )
              {
                sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i1[6], v54);
                return 1LL;
              }
              if ( strcmp(v78, "invert-match") )
              {
                sub_13937((void *)*v56, 10, 0, 0LL, (__int64)v78, (__int64)"modifier", v54);
                return 1LL;
              }
              v57 = 21;
              if ( (unsigned int)sub_411CA(v56, *v76, 7u, i1, 20, 0LL, v54) )
                return 1LL;
            }
          }
        }
        v40 = strlen(s1);
        v41 = (_QWORD *)*v76;
        *v41 = malloc(v40 + 2);
        if ( !*(_QWORD *)*v76 )
        {
          sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v42, v54);
          return 1LL;
        }
        **(_BYTE **)*v76 = v57;
        strcpy((char *)(*(_QWORD *)*v76 + 1LL), s1);
        lydict_insert_zc(*v56, *(_QWORD *)*v76);
        if ( (unsigned int)sub_421DA(v56, (_QWORD *)*v76, (__int64)i, v54) )
          return 1LL;
        if ( v75 )
        {
          v80 = realloc((void *)*v75, 8LL * (nn + 2));
          if ( !v80 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v43, v54);
            return 1LL;
          }
          *v75 = (__int64)v80;
          *(_QWORD *)(8 * (nn + 1LL) + *v75) = 0LL;
        }
      }
      else
      {
        v44 = (const char *)i[6];
        if ( !strcmp(v44, "range") )
        {
          v76 = (__int64 *)lys_ext_complex_get_substmt(53LL, a2, &v71);
          if ( !v76 )
          {
            sub_13937((void *)*v56, 6, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
            return 1LL;
          }
          if ( *(_DWORD *)(v71 + 16) <= 1u && *v76 )
          {
            sub_13937((void *)*v56, 14, 0, 0LL, i[6], *(_QWORD *)(i[1] + 48LL), v54);
            return 1LL;
          }
          v75 = 0LL;
          i2 = 0;
          if ( *(_DWORD *)(v71 + 16) > 1u )
          {
            v75 = v76;
            if ( *v76 )
            {
              for ( i2 = 0; *(_QWORD *)(8LL * i2 + *v75); ++i2 )
                ;
            }
            else
            {
              *v75 = (__int64)malloc(0x10uLL);
              if ( !*v75 )
              {
                sub_12222(
                  *v56,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"lyp_yin_parse_complex_ext",
                  v45,
                  v54);
                return 1LL;
              }
            }
            v76 = (__int64 *)(8LL * i2 + *v75);
          }
          s1 = (char *)lyxml_get_attr(i, "value", 0LL);
          if ( !s1 )
          {
            sub_13937((void *)*v56, 13, 0, 0LL, (__int64)"value", i[6], v54);
            return 1LL;
          }
          *v76 = (__int64)calloc(1uLL, 0x38uLL);
          if ( !*v76 )
          {
            sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v46, v54);
            return 1LL;
          }
          v47 = (_QWORD *)*v76;
          *v47 = lydict_insert(*v56, s1, 0LL);
          if ( (unsigned int)sub_421DA(v56, (_QWORD *)*v76, (__int64)i, v54) )
            return 1LL;
          if ( v75 )
          {
            v80 = realloc((void *)*v75, 8LL * (i2 + 2));
            if ( !v80 )
            {
              sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v48, v54);
              return 1LL;
            }
            *v75 = (__int64)v80;
            *(_QWORD *)(8 * (i2 + 1LL) + *v75) = 0LL;
          }
        }
        else
        {
          v49 = i[6];
          v50 = (int *)ly_errno_glob_address(v44);
          sub_12222(*v56, 0, *v50, "Extension's substatement \"%s\" not supported.", v49, v51, v54);
        }
      }
      goto LABEL_472;
    }
    v83 = (__int64 **)sub_62554((__int64)i, (__int64)a2, 0x30u);
    if ( !v83 )
      return 1LL;
    *v83 = (__int64 *)calloc(1uLL, 0x40uLL);
    if ( !*v83 )
    {
      sub_12222(*v56, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_yin_parse_complex_ext", v4, v54);
      return 1LL;
    }
    lyxml_unlink(*v56, i);
    (*v83)[2] = (__int64)i;
    (*v83)[3] = (__int64)a2;
    if ( (unsigned int)sub_2ABDE(v56, v54, *v83, 0x10u, 0LL) == -1 )
    {
      (*v83)[2] = 0LL;
      return 1LL;
    }
  }
  return a2[8] && (unsigned int)sub_3E959((__int64)a2, *(_QWORD *)(v55 + 48));
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7870: using guessed type __int64 __fastcall lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7B70: using guessed type __int64 __fastcall lyxml_unlink(_QWORD, _QWORD);

//----- (0000000000066992) ----------------------------------------------------
__int64 __fastcall sub_66992(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-24h]
  __int64 i; // [rsp+20h] [rbp-10h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  for ( i = a2; i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) != 2048
      && (*(_DWORD *)(i + 56) != 1024 || !(v4 & 0x10))
      && (*(_DWORD *)(i + 56) != 512 || !(v4 & 0x20)) )
    {
      if ( *(_DWORD *)(i + 56) & 0x1642 )
      {
        v6 = sub_66992(a1, *(_QWORD *)(i + 72), v4);
        if ( v6 )
          return v6;
      }
      else if ( *(_QWORD *)i == *(_QWORD *)(a1 + 48)
             && *(_QWORD *)(lys_main_module(*(_QWORD *)(i + 48)) + 176) == *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL) )
      {
        return i;
      }
    }
  }
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000066AA4) ----------------------------------------------------
_BOOL8 __fastcall sub_66AA4(char **a1, __int64 a2, char a3, int a4)
{
  int v5; // [rsp+8h] [rbp-28h]
  char v6; // [rsp+Ch] [rbp-24h]

  v6 = a3;
  v5 = a4;
  if ( !a1 || !(*((_DWORD *)*a1 + 14) & 0xC) || !a2 )
    __assert_fail(
      "node && (node->schema->nodetype & (LYS_LEAFLIST | LYS_LEAF)) && xml",
      "/home/mantovan/Repositories/libyang/src/parser_xml.c",
      0x52u,
      "xml_get_value");
  a1[7] = (char *)lydict_insert(**((_QWORD **)*a1 + 6), *(_QWORD *)(a2 + 64), 0LL);
  if ( !(v6 & 0x20) || !(*((_DWORD *)*a1 + 14) & 4) || a1[7] && *a1[7] )
    return sub_37EF5((signed __int64)(*a1 + 128), a1 + 7, a2, (__int64 **)a1, 0LL, 0LL, 1, 0, v5) == 0;
  *((_DWORD *)a1 + 18) = 20;
  return 0LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000066BD2) ----------------------------------------------------
signed __int64 __fastcall sub_66BD2(__int64 a1, __int64 a2, char *a3, char *a4, __int64 a5, __int64 a6, __int64 a7, char **a8, char **a9, const char *a10)
{
  int v11; // eax
  __int64 *v12; // rax
  void (__fastcall *v13)(__int64, _QWORD, __int64, signed __int64, __int64); // rbx
  __int64 v14; // r13
  __int64 v15; // r12
  __int64 v16; // rax
  __int64 v17; // r9
  char *v18; // rax
  unsigned int v19; // esi
  unsigned int v20; // eax
  size_t v21; // rax
  __int64 v22; // r9
  __int64 v23; // r9
  __int64 v24; // r9
  char *v25; // rsi
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // rcx
  const char *v30; // rax
  __int64 v31; // rbx
  int v32; // eax
  char *v33; // rbx
  const char *v34; // rax
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9
  __int64 v39; // r8
  __int64 v40; // r9
  char v41; // al
  char **v42; // rax
  char *s; // [rsp+0h] [rbp-110h]
  unsigned int v44; // [rsp+24h] [rbp-ECh]
  __int64 v45; // [rsp+28h] [rbp-E8h]
  char *v46; // [rsp+30h] [rbp-E0h]
  char *v47; // [rsp+38h] [rbp-D8h]
  __int64 v48; // [rsp+40h] [rbp-D0h]
  __int64 v49; // [rsp+48h] [rbp-C8h]
  unsigned __int8 v50; // [rsp+57h] [rbp-B9h]
  int v51; // [rsp+58h] [rbp-B8h]
  int j; // [rsp+5Ch] [rbp-B4h]
  int i; // [rsp+60h] [rbp-B0h]
  int v54; // [rsp+64h] [rbp-ACh]
  int v55; // [rsp+68h] [rbp-A8h]
  unsigned int v56; // [rsp+6Ch] [rbp-A4h]
  unsigned int v57; // [rsp+70h] [rbp-A0h]
  int v58; // [rsp+74h] [rbp-9Ch]
  __int64 **k; // [rsp+78h] [rbp-98h]
  __int64 v60; // [rsp+80h] [rbp-90h]
  __int64 v61; // [rsp+88h] [rbp-88h]
  __int64 **v62; // [rsp+90h] [rbp-80h]
  _QWORD *v63; // [rsp+98h] [rbp-78h]
  __int64 v64; // [rsp+A0h] [rbp-70h]
  _QWORD *m; // [rsp+A8h] [rbp-68h]
  __int64 l; // [rsp+B0h] [rbp-60h]
  char *ii; // [rsp+B8h] [rbp-58h]
  char *n; // [rsp+C0h] [rbp-50h]
  const char *v69; // [rsp+C8h] [rbp-48h]
  __int64 v70; // [rsp+D0h] [rbp-40h]
  __int64 v71; // [rsp+D8h] [rbp-38h]
  char *v72; // [rsp+E0h] [rbp-30h]
  unsigned __int64 v73; // [rsp+E8h] [rbp-28h]

  v49 = a1;
  v48 = a2;
  v47 = a3;
  v46 = a4;
  v45 = a5;
  v44 = a6;
  s = (char *)a10;
  v73 = __readfsqword(0x28u);
  v61 = 0LL;
  v63 = 0LL;
  v51 = 0;
  v55 = 0;
  v57 = 0;
  v69 = 0LL;
  if ( !a2 )
    __assert_fail("xml", "/home/mantovan/Repositories/libyang/src/parser_xml.c", 0x7Au, "xml_parse_data");
  if ( !a8 )
    __assert_fail("result", "/home/mantovan/Repositories/libyang/src/parser_xml.c", 0x7Bu, "xml_parse_data");
  *a8 = 0LL;
  if ( *(_BYTE *)v48 & 1 )
  {
    if ( !(a6 & 0x200) )
      return 0LL;
    sub_13937((void *)v49, 2, 1u, (char *)v48, (__int64)"XML element with mixed content", a6, a10);
    return 0xFFFFFFFFLL;
  }
  if ( !*(_QWORD *)(v48 + 56) || !*(_QWORD *)(*(_QWORD *)(v48 + 56) + 32LL) )
  {
    if ( !(a6 & 0x200) )
      return 0LL;
    sub_13937((void *)v49, 1, 1u, (char *)v48, (__int64)"element's", (__int64)"namespace", a10);
    return 0xFFFFFFFFLL;
  }
  if ( v47 )
  {
    v63 = (_QWORD *)sub_66992(v48, *(_QWORD *)(*(_QWORD *)v47 + 72LL), a6);
    if ( *(_QWORD *)(v49 + 112) )
    {
      if ( !v63 || *(_BYTE *)(lys_node_module(v63) + 64) & 0x80 )
      {
        if ( !v63
          && (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD))(v49 + 112))(
               v49,
               0LL,
               *(_QWORD *)(*(_QWORD *)(v48 + 56) + 32LL),
               0LL,
               *(_QWORD *)(v49 + 120)) )
        {
          v63 = (_QWORD *)sub_66992(v48, *(_QWORD *)(*(_QWORD *)v47 + 72LL), v44);
        }
      }
      else
      {
        v13 = *(void (__fastcall **)(__int64, _QWORD, __int64, signed __int64, __int64))(v49 + 112);
        v14 = *(_QWORD *)(v49 + 120);
        v15 = *(_QWORD *)(lys_node_module(v63) + 176);
        v16 = lys_node_module(v63);
        v13(v49, *(_QWORD *)(v16 + 8), v15, 1LL, v14);
      }
    }
  }
  else
  {
    v61 = ly_ctx_get_module_by_ns(v49, *(_QWORD *)(*(_QWORD *)(v48 + 56) + 32LL), 0LL, 0LL);
    if ( *(_QWORD *)(v49 + 112) )
    {
      if ( v61 )
      {
        if ( *(_BYTE *)(v61 + 64) >= 0 )
          v61 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v49 + 112))(
                  v49,
                  *(_QWORD *)(v61 + 8),
                  *(_QWORD *)(v61 + 176),
                  1LL,
                  *(_QWORD *)(v49 + 120));
      }
      else
      {
        v61 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD))(v49 + 112))(
                v49,
                0LL,
                *(_QWORD *)(*(_QWORD *)(v48 + 56) + 32LL),
                0LL,
                *(_QWORD *)(v49 + 120));
      }
    }
    if ( v61 && *(_BYTE *)(v61 + 64) < 0 && !(*(_BYTE *)(v61 + 64) & 0x40) )
    {
      if ( v44 & 0x1000000 )
      {
        if ( a10 )
        {
          v11 = strlen(a10);
          v71 = sub_40D5F(v61, a10, v11);
          if ( v71 )
          {
            v12 = (__int64 *)lys_ext_complex_get_substmt(38LL, v71, 0LL);
            v63 = (_QWORD *)sub_66992(v48, *v12, v44);
          }
        }
      }
      else
      {
        v63 = (_QWORD *)sub_66992(v48, *(_QWORD *)(v61 + 168), v44);
        if ( !v63 )
        {
          for ( i = 0; i < *(unsigned __int8 *)(v61 + 77); ++i )
          {
            v70 = *(_QWORD *)(v61 + 136) + 104LL * i;
            v64 = *(_QWORD *)(v70 + 88);
            if ( *(_DWORD *)(v64 + 56) & 0x42 )
            {
              while ( v64 && *(_DWORD *)(v64 + 56) & 0x1042 )
                v64 = lys_parent(v64);
              if ( !v64 )
              {
                do
                  v63 = (_QWORD *)lys_getnext(v63, v70, 0LL, 0LL);
                while ( v63 && *v63 != *(_QWORD *)(v48 + 48) );
              }
            }
            if ( v63 )
              break;
          }
        }
      }
    }
  }
  v61 = lys_node_module(v63);
  if ( !v61 || *(_BYTE *)(v61 + 64) >= 0 || *(_BYTE *)(v61 + 64) & 0x40 )
  {
    if ( !(v44 & 0x200) )
      return 0LL;
    if ( v47 )
      v18 = v47;
    else
      v18 = "/";
    if ( v47 )
      v19 = 3;
    else
      v19 = 4;
    sub_13937((void *)v49, 47, v19, v18, *(_QWORD *)(v48 + 48), v17, a10);
    return 0xFFFFFFFFLL;
  }
  v20 = *((_DWORD *)v63 + 14);
  if ( v20 == 32 )
    goto LABEL_91;
  if ( v20 > 0x20 )
  {
    if ( v20 == 256 )
      goto LABEL_77;
    if ( v20 <= 0x100 )
    {
      if ( v20 != 128 )
        goto LABEL_92;
      goto LABEL_77;
    }
    if ( v20 == 0x4000 )
    {
LABEL_77:
      for ( j = 0; *(_QWORD *)(v48 + 64) && *(_BYTE *)(*(_QWORD *)(v48 + 64) + j); ++j )
      {
        if ( *(_BYTE *)(*(_QWORD *)(v48 + 64) + j) != 32
          && *(_BYTE *)(*(_QWORD *)(v48 + 64) + j) != 9
          && *(_BYTE *)(*(_QWORD *)(v48 + 64) + j) != 10
          && *(_BYTE *)(*(_QWORD *)(v48 + 64) + j) != 13 )
        {
          v21 = strlen(*(const char **)(v48 + 64));
          v72 = (char *)malloc(v21 + 23);
          if ( v72 )
          {
            sprintf(v72, "node with text data \"%s\"", *(_QWORD *)(v48 + 64));
            sub_13937((void *)v49, 2, 1u, (char *)v48, (__int64)v72, v23, a10);
            free(v72);
          }
          else
          {
            sub_12222(v49, 0, 1, "Memory allocation failed (%s()).", (__int64)"xml_parse_data", v22, a10);
          }
          return 0xFFFFFFFFLL;
        }
      }
      *a8 = (char *)calloc(1uLL, 0x48uLL);
      v54 = 1;
      goto LABEL_93;
    }
    if ( v20 != 32800 )
      goto LABEL_92;
LABEL_91:
    *a8 = (char *)calloc(1uLL, 0x40uLL);
    v54 = 0;
    goto LABEL_93;
  }
  if ( v20 != 4 )
  {
    if ( v20 <= 4 )
    {
      if ( v20 != 1 )
      {
LABEL_92:
        sub_12222(
          v49,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser_xml.c",
          254LL,
          a10);
        return 0xFFFFFFFFLL;
      }
      goto LABEL_77;
    }
    if ( v20 != 8 )
    {
      if ( v20 != 16 )
        goto LABEL_92;
      goto LABEL_77;
    }
  }
  *a8 = (char *)calloc(1uLL, 0x50uLL);
  v54 = 0;
LABEL_93:
  if ( !*a8 )
  {
    sub_12222(v49, 0, 1, "Memory allocation failed (%s()).", (__int64)"xml_parse_data", v24, a10);
    return 0xFFFFFFFFLL;
  }
  *((_QWORD *)*a8 + 4) = *a8;
  *(_QWORD *)*a8 = v63;
  *((_QWORD *)*a8 + 5) = v47;
  k = 0LL;
  if ( *((_DWORD *)v63 + 14) == 4 && lys_is_key(v63, &v50) )
  {
    if ( !v47 )
      __assert_fail("parent", "/home/mantovan/Repositories/libyang/src/parser_xml.c", 0x109u, "xml_parse_data");
    j = 0;
    for ( k = (__int64 **)*((_QWORD *)v47 + 8);
          k && j < v50 && *((_DWORD *)*k + 14) == 4 && lys_is_key(*k, 0LL);
          k = (__int64 **)k[3] )
    {
      ++j;
    }
    if ( k )
    {
      if ( v44 & 0x200 )
      {
        sub_13937((void *)v49, 60, 3u, *a8, *v63, **k, a10);
        sub_13937(
          (void *)v49,
          -1,
          5u,
          0LL,
          (__int64)"Invalid position of the key \"%s\" in a list \"%s\".",
          *v63,
          **(_QWORD **)v47);
        free(*a8);
        *a8 = 0LL;
        return 0xFFFFFFFFLL;
      }
      sub_12222(v49, 1u, 0, "Invalid position of the key \"%s\" in a list \"%s\".", *v63, **(_QWORD **)v47, a10);
      if ( *((__int64 ***)v47 + 8) == k )
      {
        *((_QWORD *)v47 + 8) = *a8;
        v46 = *a8;
      }
      if ( k[4][3] )
        k[4][3] = (__int64)*a8;
      *((_QWORD *)*a8 + 4) = k[4];
      k[4] = (__int64 *)*a8;
      *((_QWORD *)*a8 + 3) = k;
    }
  }
  if ( !k )
  {
    if ( v47 && !*((_QWORD *)v47 + 8) )
      *((_QWORD *)v47 + 8) = *a8;
    if ( v45 )
    {
      *((_QWORD *)*a8 + 4) = v45;
      *(_QWORD *)(v45 + 24) = *a8;
      *((_QWORD *)v46 + 4) = *a8;
    }
    else
    {
      *((_QWORD *)*a8 + 4) = *a8;
      v46 = *a8;
    }
  }
  (*a8)[8] = sub_C3AB(*(_QWORD *)*a8);
  v25 = 0LL;
  if ( (unsigned int)sub_28290((__int64)v63, 0, 0LL) )
    (*a8)[9] = (*a8)[9] & 0xF1 | 8;
  for ( l = *(_QWORD *)(v48 + 16); l; l = *(_QWORD *)(l + 8) )
  {
    if ( *(_DWORD *)l != 1 )
      continue;
    if ( *(_QWORD *)(l + 16) )
    {
      v69 = *(const char **)(*(_QWORD *)(l + 16) + 32LL);
    }
    else
    {
      if ( *(_DWORD *)(*(_QWORD *)*a8 + 56LL) != 32
        || !(unsigned int)sub_C462(**(_BYTE ***)*a8, "filter")
        || !(unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(*(_QWORD *)*a8 + 48LL) + 8LL), "ietf-netconf")
        && !(unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(*(_QWORD *)*a8 + 48LL) + 8LL), "notifications") )
      {
        goto LABEL_133;
      }
      v69 = "urn:ietf:params:xml:ns:netconf:base:1.0";
      v55 = 1;
    }
    v25 = *a8;
    v58 = sub_3AB03(v49, *a8, (__int64)v69, 0LL, *(_BYTE **)(l + 24), *(_QWORD *)(l + 32), v48, v44, (char ***)&v60);
    if ( v58 == -1 )
      goto LABEL_248;
    if ( v58 == 1 )
    {
LABEL_133:
      if ( v44 & 0x200 )
      {
        sub_13937((void *)v49, 52, 3u, *a8, *(_QWORD *)(l + 24), v27, s);
        goto LABEL_248;
      }
      if ( *(_QWORD *)(l + 16) )
        v30 = *(const char **)(*(_QWORD *)(l + 16) + 24LL);
      else
        v30 = "<none>";
      v25 = (_BYTE *)(&size + 1);
      sub_12222(
        v49,
        1u,
        0,
        "Unknown \"%s:%s\" metadata with value \"%s\", ignoring.",
        (__int64)v30,
        *(_QWORD *)(l + 24),
        *(_QWORD *)(l + 32));
      continue;
    }
    if ( v55 )
    {
      v25 = "select";
      if ( !strcmp(*(const char **)(l + 24), "select") )
      {
        v31 = v60;
        *(_QWORD *)(v31 + 40) = sub_9A10(v49, *(const char **)(v60 + 32), (char *)v48, 0, 0);
        if ( !*(_QWORD *)(v60 + 40) )
        {
          v28 = *(_QWORD *)(v60 + 32);
          *(_QWORD *)(v60 + 40) = v28;
          goto LABEL_248;
        }
        v25 = *(char **)(v60 + 32);
        lydict_remove(v49, v25);
        *(_QWORD *)(v60 + 32) = *(_QWORD *)(v60 + 40);
      }
    }
    if ( *((_QWORD *)*a8 + 2) )
    {
      for ( m = (_QWORD *)*((_QWORD *)*a8 + 2); m[1]; m = (_QWORD *)m[1] )
        ;
      m[1] = v60;
    }
    else
    {
      *((_QWORD *)*a8 + 2) = v60;
    }
  }
  if ( !(v44 & 8) )
  {
    if ( !v55 )
      goto LABEL_194;
    v56 = 0;
    for ( m = (_QWORD *)*((_QWORD *)*a8 + 2); m; m = (_QWORD *)m[1] )
    {
      v25 = "type";
      if ( !strcmp((const char *)m[3], "type") )
      {
        if ( v56 == 1 || v56 == 2 || v56 == 4 )
        {
          sub_13937((void *)v49, 14, 3u, *a8, (__int64)"type", *(_QWORD *)(v48 + 48), s);
          goto LABEL_248;
        }
        v32 = *(_DWORD *)(m[5] + 28LL);
        if ( v32 )
        {
          if ( v32 != 1 )
          {
            sub_12222(
              v49,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/parser_xml.c",
              410LL,
              s);
            goto LABEL_248;
          }
          if ( v56 == 3 )
          {
            v56 = 4;
          }
          else
          {
            if ( v56 )
              __assert_fail("!found", "/home/mantovan/Repositories/libyang/src/parser_xml.c", 0x195u, "xml_parse_data");
            v56 = 2;
          }
        }
        else
        {
          if ( v56 == 3 )
          {
            sub_13937((void *)v49, 52, 3u, *a8, m[3], v27, s);
            goto LABEL_248;
          }
          if ( v56 )
            __assert_fail("!found", "/home/mantovan/Repositories/libyang/src/parser_xml.c", 0x18Du, "xml_parse_data");
          v56 = 1;
        }
      }
      else
      {
        v25 = "select";
        if ( !strcmp((const char *)m[3], "select") )
        {
          switch ( (unsigned __int64)v56 )
          {
            case 0uLL:
              v56 = 3;
              continue;
            case 1uLL:
              sub_13937((void *)v49, 52, 3u, *a8, m[3], v27, s);
              goto LABEL_248;
            case 2uLL:
              v56 = 4;
              continue;
            case 3uLL:
            case 4uLL:
              sub_13937((void *)v49, 14, 3u, *a8, (__int64)"select", *(_QWORD *)(v48 + 48), s);
              break;
            default:
              sub_12222(
                v49,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/parser_xml.c",
                429LL,
                s);
              break;
          }
          goto LABEL_248;
        }
      }
    }
    if ( v56 == 2 )
    {
      sub_13937((void *)v49, 53, 3u, *a8, (__int64)"select", *(_QWORD *)(v48 + 48), s);
      goto LABEL_248;
    }
    if ( (signed int)v56 > 2 )
    {
      if ( v56 == 3 )
      {
        sub_13937((void *)v49, 53, 3u, *a8, (__int64)"type", *(_QWORD *)(v48 + 48), s);
        goto LABEL_248;
      }
      if ( v56 == 4 )
        goto LABEL_194;
    }
    else if ( v56 == 1 )
    {
      goto LABEL_194;
    }
    sub_12222(
      v49,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser_xml.c",
      448LL,
      s);
LABEL_248:
    sub_BA11B(*a8, 2, v28, v29, v26, v27);
    goto LABEL_249;
  }
  v25 = (char *)*((_QWORD *)*a8 + 2);
  if ( (unsigned int)sub_3AF7B((_QWORD *)v49, v25, *a8, &v51, v26, v27) )
    goto LABEL_248;
LABEL_194:
  if ( !(v63[7] & 0xC) )
  {
    if ( v63[7] & 0x8020 )
    {
      if ( *(_QWORD *)(v48 + 24) )
      {
        ii = *(char **)(v48 + 24);
        *(_QWORD *)(v48 + 24) = 0LL;
        for ( n = ii; n; n = (char *)*((_QWORD *)n + 4) )
        {
          *((_QWORD *)n + 1) = 0LL;
          v25 = n;
          sub_30771(v49, n, 1, 1);
        }
        *((_DWORD *)*a8 + 13) = 8;
        *((_QWORD *)*a8 + 7) = ii;
      }
      else
      {
        *((_DWORD *)*a8 + 13) = 0;
        v33 = *a8;
        v25 = *(char **)(v48 + 64);
        *((_QWORD *)v33 + 7) = lydict_insert(v49, v25, 0LL);
      }
      goto LABEL_217;
    }
    if ( !(v63[7] & 0x4100) )
    {
      if ( *((_DWORD *)v63 + 14) == 128 )
      {
        if ( !(v44 & 0x40) || *a9 )
        {
          sub_13937((void *)v49, 47, 3u, *a8, *v63, v27, s);
          sub_13937((void *)v49, -1, 5u, 0LL, (__int64)"Unexpected notification node \"%s\".", *v63);
          goto LABEL_248;
        }
        *a9 = *a8;
      }
      goto LABEL_217;
    }
    if ( v44 & 0x10 && !*a9 )
    {
      *a9 = *a8;
      goto LABEL_217;
    }
    sub_13937((void *)v49, 47, 3u, *a8, *v63, v27, s);
    if ( *((_DWORD *)v63 + 14) == 256 )
      v34 = "rpc";
    else
      v34 = "action";
    sub_13937((void *)v49, -1, 5u, 0LL, (__int64)"Unexpected %s node \"%s\".", (__int64)v34, *v63);
    goto LABEL_248;
  }
  v25 = (char *)v48;
  if ( (unsigned int)sub_66AA4((char **)*a8, v48, v51, v44 & 0x2000) )
    goto LABEL_248;
LABEL_217:
  if ( *(_DWORD *)(*(_QWORD *)*a8 + 56LL) != 16 || !*(_BYTE *)(*(_QWORD *)*a8 + 30LL) )
  {
    sub_AC63C((const char **)*a8);
    sub_ACC62((unsigned int *)*a8, (__int64)v25, v35, v36, v37, v38);
  }
  if ( (unsigned int)sub_2DC82(*a8, v44, a7) )
    goto LABEL_249;
  if ( v54 && *(_QWORD *)(v48 + 24) )
  {
    v62 = 0LL;
    k = 0LL;
    for ( ii = *(char **)(v48 + 24); ; ii = n )
    {
      if ( ii )
      {
        n = (char *)*((_QWORD *)ii + 4);
        v41 = 1;
      }
      else
      {
        v41 = 0;
      }
      if ( !v41 )
        break;
      v58 = sub_66BD2(v49, (__int64)ii, (__int64)*a8, *((_QWORD *)*a8 + 8));
      if ( v58 )
        goto LABEL_249;
      if ( v44 & 0x400 )
        lyxml_free(v49, ii);
      if ( k && !k[3] )
        v62 = k;
    }
  }
  if ( *((_DWORD *)v63 + 14) == 1 && !*((_QWORD *)*a8 + 8) && !*((_QWORD *)*a8 + 2) && !v63[17] )
    (*a8)[9] |= 1u;
  if ( (unsigned int)sub_2F7BD(*a8, v44, a7, v44, v39, v40)
    || (!v45 ? (v42 = 0LL) : (v42 = &v46), (unsigned int)sub_3010D((__int64 *)*a8, 0LL, v42, 0, 0LL)) )
  {
LABEL_249:
    for ( j = *(_DWORD *)(a7 + 16) - 1; j >= 0; --j )
    {
      if ( *(char **)(8LL * j + *(_QWORD *)a7) == *a8 )
        sub_1FB5F(a7, j);
    }
    lyd_free(*a8);
    *a8 = 0LL;
    return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(*(_QWORD *)*a8 + 56LL) & 0x18 )
    (*a8)[8] |= 1u;
  return v57;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7400: using guessed type __int64 __fastcall ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD);
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7850: using guessed type __int64 __fastcall lys_is_key(_QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000006876C) ----------------------------------------------------
char *lyd_parse_xml(__int64 a1, _QWORD *a2, unsigned int a3, ...)
{
  __int64 v3; // r9
  __int64 v5; // r9
  const char *v6; // rsi
  __int64 v7; // r9
  __int64 **v8; // rax
  __int64 v9; // r9
  __int64 *v10; // rax
  const char **v11; // rax
  char v12; // al
  const char *v13; // rax
  unsigned int v14; // esi
  __int64 v15; // rax
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 *v19; // rax
  unsigned int v20; // [rsp+Ch] [rbp-164h]
  _QWORD *v21; // [rsp+10h] [rbp-160h]
  char *v22; // [rsp+30h] [rbp-140h]
  char *j; // [rsp+38h] [rbp-138h]
  char **v24; // [rsp+40h] [rbp-130h]
  __int64 v25; // [rsp+48h] [rbp-128h]
  char *v26; // [rsp+50h] [rbp-120h]
  __int64 *v27; // [rsp+58h] [rbp-118h]
  char *i; // [rsp+60h] [rbp-110h]
  char *v29; // [rsp+68h] [rbp-108h]
  __int64 k; // [rsp+70h] [rbp-100h]
  __int64 l; // [rsp+78h] [rbp-F8h]
  __int64 v32; // [rsp+80h] [rbp-F0h]
  __int64 v33; // [rsp+88h] [rbp-E8h]
  const char *v34; // [rsp+90h] [rbp-E0h]
  void *ptr; // [rsp+98h] [rbp-D8h]
  gcc_va_list va; // [rsp+A0h] [rbp-D0h]
  unsigned __int64 v37; // [rsp+B8h] [rbp-B8h]
  __int64 v38; // [rsp+D8h] [rbp-98h]
  __int64 v39; // [rsp+E0h] [rbp-90h]
  __int64 v40; // [rsp+E8h] [rbp-88h]

  va_start(va, a3);
  v38 = va_arg(va, _QWORD);
  v39 = va_arg(va, _QWORD);
  v40 = va_arg(va, _QWORD);
  va_end(va);
  v21 = a2;
  v20 = a3;
  v37 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&unk_110680, (__int64)"lyd_parse_xml", v38, v39, v40);
  ptr = 0LL;
  v27 = 0LL;
  v25 = 0LL;
  v22 = 0LL;
  i = 0LL;
  v29 = 0LL;
  v24 = 0LL;
  v33 = 0LL;
  v34 = 0LL;
  if ( !a1 || !a2 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_parse_xml", v3);
    return 0LL;
  }
  if ( (unsigned int)sub_34DD2(a1, v20, (__int64)"lyd_parse_xml") )
    return 0LL;
  if ( !*a2 && !(v20 & 0x20) )
  {
    if ( v20 & 0x50 )
    {
      sub_12222(a1, 0, 3, "%s: *root identifies RPC/Notification so it cannot be NULL.", (__int64)"lyd_parse_xml", v5);
      return 0LL;
    }
    if ( !(v20 & 0x20) )
    {
      lyd_validate(&v22, v20, a1);
      return v22;
    }
  }
  v6 = (const char *)&qword_28;
  ptr = calloc(1uLL, 0x28uLL);
  if ( !ptr )
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_parse_xml", v7);
    return 0LL;
  }
  va_start(va, a3);
  if ( !(v20 & 0x20) )
    goto LABEL_40;
  if ( va[0].gp_offset > 0x2F )
  {
    v8 = (__int64 **)va[0].overflow_arg_area;
    va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
  }
  else
  {
    v8 = (__int64 **)((char *)va[0].reg_save_area + va[0].gp_offset);
    va[0].gp_offset += 8;
  }
  v27 = *v8;
  if ( v27 && !v27[5] && *(_DWORD *)(*v27 + 56) & 0x111 )
  {
    if ( *(_DWORD *)(*v27 + 56) == 256 )
    {
      v6 = (const char *)*v27;
      i = sub_AE9DE(0LL, *v27, 0);
      v29 = i;
    }
    else
    {
      v6 = (_BYTE *)(&size + 1);
      v29 = (char *)lyd_dup(v27, 1LL);
      j = v29;
      for ( i = v29; i && *(_DWORD *)(*(_QWORD *)i + 56LL) != 0x4000; i = j )
      {
        if ( *(_DWORD *)(*(_QWORD *)i + 56LL) & 0x802C )
          j = 0LL;
        else
          j = (char *)*((_QWORD *)i + 8);
        if ( !j )
        {
          if ( i == v29 )
            break;
          j = (char *)*((_QWORD *)i + 3);
        }
        while ( !j )
        {
          i = (char *)*((_QWORD *)i + 5);
          if ( *((_QWORD *)i + 5) == *((_QWORD *)v29 + 5) )
            break;
          j = (char *)*((_QWORD *)i + 3);
        }
      }
      if ( !i )
      {
        sub_12222(
          a1,
          0,
          3,
          "%s: invalid variable parameter (const struct lyd_node *rpc_act).",
          (__int64)"lyd_parse_xml",
          v9);
        lyd_free_withsiblings(v29);
        goto LABEL_128;
      }
      lyd_free_withsiblings(*((_QWORD *)i + 8));
    }
LABEL_40:
    if ( v20 & 0x70 )
    {
      if ( va[0].gp_offset > 0x2F )
      {
        v10 = (__int64 *)va[0].overflow_arg_area;
        va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
      }
      else
      {
        v10 = (__int64 *)((char *)va[0].reg_save_area + va[0].gp_offset);
        va[0].gp_offset += 8;
      }
      v25 = *v10;
      if ( v25 )
      {
        if ( v20 & 0x8000 )
        {
          sub_12222(
            a1,
            0,
            3,
            "%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).",
            (__int64)"lyd_parse_xml",
            v7);
          goto LABEL_128;
        }
        for ( j = (char *)v25; j; j = (char *)*((_QWORD *)j + 3) )
        {
          if ( *((_QWORD *)j + 5) )
          {
            sub_12222(
              a1,
              0,
              3,
              "%s: invalid variable parameter (const struct lyd_node *data_tree).",
              (__int64)"lyd_parse_xml",
              v7);
            goto LABEL_128;
          }
        }
        while ( *(_QWORD *)(*(_QWORD *)(v25 + 32) + 24LL) )
          v25 = *(_QWORD *)(v25 + 32);
        if ( v20 & 0x1000 )
        {
          sub_12222(
            a1,
            0,
            3,
            "%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).",
            (__int64)"lyd_parse_xml",
            v7);
          goto LABEL_128;
        }
      }
    }
    if ( v20 & 0x1000000 )
    {
      if ( va[0].gp_offset > 0x2F )
      {
        v11 = (const char **)va[0].overflow_arg_area;
        va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
      }
      else
      {
        v11 = (const char **)((char *)va[0].reg_save_area + va[0].gp_offset);
        va[0].gp_offset += 8;
      }
      v34 = *v11;
    }
    if ( !*v21 || v20 & 0x1000 )
    {
      k = *v21;
    }
    else if ( *(_QWORD *)(*v21 + 8LL) )
    {
      k = *(_QWORD *)(*(_QWORD *)(*v21 + 8LL) + 24LL);
    }
    else
    {
      for ( k = *v21; *(_QWORD *)(*(_QWORD *)(k + 40) + 32LL); k = *(_QWORD *)(k + 40) )
        ;
    }
    if ( v20 & 0x10 )
    {
      v6 = "action";
      if ( !strcmp(*(const char **)(k + 48), "action") )
      {
        v6 = "urn:ietf:params:xml:ns:yang:1";
        if ( !strcmp(*(const char **)(*(_QWORD *)(k + 56) + 32LL), "urn:ietf:params:xml:ns:yang:1") )
        {
          k = *(_QWORD *)(k + 24);
          if ( v20 & 0x400 )
            v33 = *(_QWORD *)(k + 8);
        }
      }
    }
    v26 = 0LL;
    j = 0LL;
    for ( l = k; ; l = v32 )
    {
      if ( l )
      {
        v32 = *(_QWORD *)(l + 32);
        v12 = 1;
      }
      else
      {
        v12 = 0;
      }
      if ( !v12 )
        break;
      v6 = (const char *)l;
      if ( (unsigned int)sub_66BD2(a1, l, i, v22, (__int64)v26, v20, (__int64)ptr, &j, (char **)&v24, v34) )
      {
        if ( v29 )
          v22 = v29;
        goto LABEL_128;
      }
      if ( v20 & 0x400 )
      {
        v6 = (const char *)l;
        lyxml_free(a1, l);
        *v21 = v32;
      }
      if ( j )
      {
        v26 = j;
        if ( v20 & 0x20000 )
        {
          if ( *(_QWORD *)(*(_QWORD *)j + 48LL) == *(_QWORD *)(*(_QWORD *)(a1 + 64)
                                                             + 8LL * *(unsigned __int8 *)(a1 + 132)
                                                             - 8) )
            v20 &= 0xFFFDFFFF;
        }
      }
      if ( !v22 )
        v22 = j;
      if ( v20 & 0x1000 )
        break;
    }
    if ( v29 )
      v22 = v29;
    if ( v20 & 0x20 && *(_DWORD *)(*v27 + 56) != 256 )
    {
      v24 = (char **)i;
    }
    else if ( v20 & 0x50 && !v24 )
    {
      if ( v20 & 0x10 )
        v13 = "action";
      else
        v13 = "notification";
      if ( v22 )
        v14 = 3;
      else
        v14 = 0;
      sub_13937((void *)a1, 47, v14, v22, (__int64)v13, v7);
      goto LABEL_128;
    }
    if ( v20 & 0x20000 )
    {
      if ( v22 )
      {
        v15 = ly_ctx_info(a1, v6);
        if ( (unsigned int)lyd_merge(v22, v15, 1280LL) )
        {
          sub_12222(a1, 0, 4, "Adding ietf-yang-library data failed.", v16, v17);
          goto LABEL_128;
        }
      }
      else
      {
        v22 = (char *)ly_ctx_info(a1, v6);
      }
    }
    for ( j = v22; j; j = (char *)*((_QWORD *)j + 3) )
    {
      if ( *(_DWORD *)(*(_QWORD *)j + 56LL) & 0x18 && j[8] & 1 && (unsigned int)sub_2EE3F((__int64)j, (__int64)v22) )
        goto LABEL_128;
    }
    if ( !(unsigned int)sub_BF7F8((char ***)&v22, v20, a1, 0LL, 0LL, v25, v24, (__int64)ptr, 1) )
    {
      if ( v20 & 0x2080
        || (!v24 ? (v19 = (__int64 *)v22) : (v19 = (__int64 *)v24), !(unsigned int)sub_AD9B9(v19, a1, 0LL, 0, v20, v18)) )
      {
        if ( v33 )
          lyxml_free(a1, v33);
        free(*(void **)ptr);
        free(*((void **)ptr + 1));
        free(ptr);
        return v22;
      }
    }
    goto LABEL_128;
  }
  sub_12222(a1, 0, 3, "%s: invalid variable parameter (const struct lyd_node *rpc_act).", (__int64)"lyd_parse_xml", v7);
LABEL_128:
  lyd_free_withsiblings(v22);
  if ( v33 )
    lyxml_free(a1, v33);
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
  return 0LL;
}
// 28: using guessed type __int64;
// 7390: using guessed type __int64 __fastcall ly_ctx_info(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7880: using guessed type __int64 __fastcall lyd_dup(_QWORD, _QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 78B0: using guessed type __int64 __fastcall lyd_validate(_QWORD, _QWORD, _QWORD);
// 7B50: using guessed type __int64 __fastcall lyd_merge(_QWORD, _QWORD, _QWORD);

//----- (0000000000069481) ----------------------------------------------------
signed __int64 __fastcall sub_69481(signed int a1)
{
  if ( a1 == 13 )
    return 1LL;
  if ( a1 > 13 )
  {
    if ( a1 == 32 )
      return 1LL;
  }
  else if ( (unsigned int)(a1 - 9) <= 1 )
  {
    return 1LL;
  }
  return 0LL;
}

//----- (00000000000694B2) ----------------------------------------------------
__int64 __fastcall sub_694B2(__int64 a1)
{
  unsigned int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; *(_BYTE *)(i + a1) && (unsigned int)sub_69481(*(char *)(i + a1)); ++i )
    ;
  return i;
}

//----- (00000000000694FC) ----------------------------------------------------
char *__fastcall sub_694FC(void *a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  int v9; // eax
  int v10; // eax
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  _DWORD *v14; // [rsp+8h] [rbp-458h]
  int v15; // [rsp+2Ch] [rbp-434h]
  int v16; // [rsp+2Ch] [rbp-434h]
  int v17; // [rsp+30h] [rbp-430h]
  int v18; // [rsp+34h] [rbp-42Ch]
  int v19; // [rsp+34h] [rbp-42Ch]
  unsigned int v20; // [rsp+38h] [rbp-428h]
  signed int v21; // [rsp+3Ch] [rbp-424h]
  char *ptr; // [rsp+40h] [rbp-420h]
  char *v23; // [rsp+48h] [rbp-418h]
  char *v24; // [rsp+48h] [rbp-418h]
  char src[1032]; // [rsp+50h] [rbp-410h]
  unsigned __int64 v26; // [rsp+458h] [rbp-8h]

  v14 = a3;
  v26 = __readfsqword(0x28u);
  ptr = 0LL;
  v17 = 0;
  v15 = 0;
  *a3 = 0;
  while ( *(_BYTE *)((unsigned int)*v14 + a2) && *(_BYTE *)((unsigned int)*v14 + a2) != 34 )
  {
    if ( v15 > 1021 )
    {
      if ( ptr )
      {
        v17 += v15;
        v23 = (char *)sub_C422(ptr, v17 + 1);
        if ( !v23 )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyjson_parse_text", v6);
          return 0LL;
        }
        ptr = v23;
      }
      else
      {
        v17 = v15;
        ptr = (char *)malloc(v15 + 1);
        if ( !ptr )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyjson_parse_text", v8);
          return 0LL;
        }
      }
      memcpy(&ptr[v17 - v15], src, v15);
      v15 = 0;
    }
    if ( *(_BYTE *)((unsigned int)*v14 + a2) == 92 )
    {
      ++*v14;
      v20 = 1;
      switch ( *(char *)((unsigned int)*v14 + a2) )
      {
        case 34:
          v9 = sub_40272(a1, &src[v15], 34, (__int64)&src[v15], a5, a6);
          break;
        case 47:
          v9 = sub_40272(a1, &src[v15], 47, (__int64)&src[v15], a5, a6);
          break;
        case 92:
          v9 = sub_40272(a1, &src[v15], 92, (__int64)&src[v15], a5, a6);
          break;
        case 98:
          v9 = sub_40272(a1, &src[v15], 8, (__int64)&src[v15], a5, a6);
          break;
        case 102:
          v9 = sub_40272(a1, &src[v15], 12, (__int64)&src[v15], a5, a6);
          break;
        case 110:
          v9 = sub_40272(a1, &src[v15], 10, (__int64)&src[v15], a5, a6);
          break;
        case 114:
          v9 = sub_40272(a1, &src[v15], 13, (__int64)&src[v15], a5, a6);
          break;
        case 116:
          v9 = sub_40272(a1, &src[v15], 9, (__int64)&src[v15], a5, a6);
          break;
        case 117:
          ++*v14;
          v20 = 0;
          v21 = 0;
          while ( v20 <= 3 )
          {
            if ( (*__ctype_b_loc())[*(char *)(*v14 + v20 + a2)] & 0x800 )
            {
              v18 = *(char *)(*v14 + v20 + a2) - 48;
            }
            else
            {
              if ( *(_BYTE *)(*v14 + v20 + a2) <= 70 )
                v10 = *(char *)(*v14 + v20 + a2) - 55;
              else
                v10 = *(char *)(*v14 + v20 + a2) - 87;
              v18 = v10;
            }
            v21 = 16 * v21 + v18;
            ++v20;
          }
          v9 = sub_40272(a1, &src[v15], v21, (__int64)&src[v15], a5, a6);
          break;
        default:
          sub_13937(a1, 2, 0, 0LL, (__int64)"character escape sequence", a6);
          goto LABEL_54;
      }
      if ( !v9 )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"character UTF8 character", a6);
LABEL_54:
        free(ptr);
        return 0LL;
      }
      v16 = v15 + v9 - 1;
      *v14 += v20;
    }
    else
    {
      if ( *(_BYTE *)((unsigned int)*v14 + a2) <= 0x1Fu )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"control character (unescaped)", a6);
        goto LABEL_54;
      }
      v19 = sub_40445(a1, (__int64)&src[v15], (char *)(a2 + (unsigned int)*v14), (__int64)&src[v15], a5, a6);
      if ( !v19 )
        goto LABEL_54;
      v16 = v15 + v19 - 1;
      *v14 += v19;
    }
    v15 = v16 + 1;
  }
  if ( v15 )
  {
    if ( ptr )
    {
      v17 += v15;
      v24 = (char *)sub_C422(ptr, v17 + 1);
      if ( !v24 )
      {
        sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyjson_parse_text", v11);
        return 0LL;
      }
      ptr = v24;
    }
    else
    {
      v17 = v15;
      ptr = (char *)malloc(v15 + 1);
      if ( !ptr )
      {
        sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyjson_parse_text", v12);
        return 0LL;
      }
    }
    memcpy(&ptr[v17 - v15], src, v15);
  }
  if ( ptr )
  {
    ptr[v17] = 0;
  }
  else
  {
    ptr = strdup(byte_110942);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyjson_parse_text", v13);
      return 0LL;
    }
  }
  return ptr;
}
// 694FC: using guessed type char src[1032];

//----- (0000000000069CA9) ----------------------------------------------------
__int64 __fastcall sub_69CA9(void *a1, _BYTE *a2)
{
  __int64 v3; // r9
  unsigned int v4; // [rsp+1Ch] [rbp-4h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  v4 = 0;
  if ( *a2 == 45 )
    v4 = 1;
  if ( a2[v4] == 48 )
  {
    i = v4 + 1;
  }
  else
  {
    if ( !((*__ctype_b_loc())[(char)a2[v4]] & 0x800) )
    {
      sub_13937(
        a1,
        -1,
        0,
        0LL,
        (__int64)"Invalid character in JSON Number value ('%c').",
        (unsigned int)(char)a2[v4],
        a2);
      return 0LL;
    }
    for ( i = v4 + 1; (*__ctype_b_loc())[(char)a2[i]] & 0x800; ++i )
      ;
  }
  if ( a2[i] == 46 )
  {
    if ( !((*__ctype_b_loc())[(char)a2[++i]] & 0x800) )
    {
      if ( a2[i] )
        sub_13937(
          a1,
          -1,
          0,
          0LL,
          (__int64)"Invalid character in JSON Number value ('%c').",
          (unsigned int)(char)a2[i],
          a2);
      else
        sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid character in JSON Number value (EOF).", v3, a2);
      return 0LL;
    }
    while ( (*__ctype_b_loc())[(char)a2[i]] & 0x800 )
      ++i;
  }
  if ( a2[i] == 101 || a2[i] == 69 )
  {
    if ( a2[++i] == 43 || a2[i] == 45 )
      ++i;
    while ( (*__ctype_b_loc())[(char)a2[i]] & 0x800 )
      ++i;
  }
  if ( !a2[i] || a2[i] == 44 || a2[i] == 93 || a2[i] == 125 || (unsigned int)sub_69481((char)a2[i]) )
    return i;
  sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid character in JSON Number value ('%c').", (unsigned int)(char)a2[i], a2);
  return 0LL;
}

//----- (0000000000069FBF) ----------------------------------------------------
char *__fastcall sub_69FBF(void *a1, char *a2, unsigned int a3, char *a4)
{
  char *result; // rax
  __int64 v5; // r9
  signed int v6; // ecx
  char *v7; // rax
  size_t v8; // rax
  size_t v9; // rax
  size_t v10; // rax
  char *nptr; // [rsp+0h] [rbp-70h]
  char *nptra; // [rsp+0h] [rbp-70h]
  unsigned int v13; // [rsp+Ch] [rbp-64h]
  char *v14; // [rsp+10h] [rbp-60h]
  int v15; // [rsp+28h] [rbp-48h]
  int v16; // [rsp+28h] [rbp-48h]
  signed int v17; // [rsp+2Ch] [rbp-44h]
  signed int v18; // [rsp+30h] [rbp-40h]
  int v19; // [rsp+34h] [rbp-3Ch]
  char *endptr; // [rsp+38h] [rbp-38h]
  char *s; // [rsp+40h] [rbp-30h]
  char *v22; // [rsp+48h] [rbp-28h]
  __int64 v23; // [rsp+50h] [rbp-20h]
  unsigned __int64 v24; // [rsp+58h] [rbp-18h]

  v14 = a2;
  v13 = a3;
  nptr = a4;
  v24 = __readfsqword(0x28u);
  if ( *a2 == 45 )
  {
    v18 = 1;
    v14 = a2 + 1;
    v13 = a3 - 1;
  }
  else
  {
    v18 = 0;
  }
  v19 = (_DWORD)a4 - (_DWORD)v14;
  *__errno_location() = 0;
  nptra = nptr + 1;
  v23 = strtol(nptra, &endptr, 10);
  if ( *__errno_location() )
  {
    sub_13937(
      a1,
      -1,
      0,
      0LL,
      (__int64)"Exponent out-of-bounds in a JSON Number value (%.*s).",
      v13 - (nptra - v14),
      nptra);
    result = 0LL;
  }
  else if ( &v14[v13] == endptr )
  {
    endptr = sub_811F(v14, 46, v19);
    if ( endptr )
      v15 = (_DWORD)endptr - (_DWORD)v14;
    else
      v15 = v19;
    v16 = v23 + v15;
    if ( v16 > 0 )
    {
      if ( v16 >= v19 )
      {
        if ( endptr )
          v6 = 2;
        else
          v6 = 1;
        s = (char *)malloc((v18 != 0) + v16 - v6 + 1);
      }
      else
      {
        s = (char *)malloc(v19 + (v18 != 0) + (unsigned int)(endptr == 0LL) + 1);
      }
    }
    else
    {
      s = (char *)malloc((v18 != 0) - v16 + v19 - (unsigned int)(endptr != 0LL) + 3);
    }
    if ( s )
    {
      if ( v18 )
        *(_WORD *)s = 45;
      else
        *s = 0;
      if ( v16 <= 0 )
      {
        v7 = &s[strlen(s)];
        *(_WORD *)v7 = 11824;
        v7[2] = 0;
      }
      if ( v16 < 0 )
      {
        v8 = strlen(s);
        sprintf(&s[v8], "%0*d", (unsigned int)-v16, 0LL);
      }
      v17 = v16;
      v9 = strlen(s);
      endptr = &s[v9];
      v22 = v14;
      while ( v19 > (unsigned int)((_DWORD)v22 - (_DWORD)v14) )
      {
        if ( v17 )
        {
          if ( (*__ctype_b_loc())[*v22] & 0x800 )
          {
            *endptr++ = *v22++;
            if ( v17 > 0 )
              --v17;
          }
          else
          {
            if ( *v22 != 46 )
            {
              sub_12222(
                (__int64)a1,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/parser_json.c",
                335LL,
                nptra);
              free(s);
              return 0LL;
            }
            ++v22;
          }
        }
        else
        {
          *endptr++ = 46;
          v17 = -1;
        }
      }
      *endptr = 0;
      if ( v16 > v19 )
      {
        v10 = strlen(s);
        sprintf(&s[v10], "%0*d", (unsigned int)(v16 - v19), 0LL);
      }
      result = s;
    }
    else
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyjson_convert_enumber", v5, nptra);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(
      (__int64)a1,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser_json.c",
      282LL,
      nptra);
    result = 0LL;
  }
  return result;
}

//----- (000000000006A438) ----------------------------------------------------
__int64 __fastcall sub_6A438(void *a1, const char *a2)
{
  __int64 v2; // r9
  unsigned int v4; // [rsp+1Ch] [rbp-4h]

  v4 = 0;
  if ( !strncmp(a2, "false", 5uLL) )
  {
    v4 = 5;
  }
  else if ( !strncmp(a2, "true", 4uLL) )
  {
    v4 = 4;
  }
  if ( !a2[v4] || a2[v4] == 44 || a2[v4] == 93 || a2[v4] == 125 || (unsigned int)sub_69481(a2[v4]) )
    return v4;
  sub_13937(a1, 2, 0, 0LL, (__int64)"JSON literal value (expected true or false)", v2, a2);
  return 0LL;
}

//----- (000000000006A529) ----------------------------------------------------
__int64 __fastcall sub_6A529(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r9
  int v8; // eax
  int v9; // [rsp+10h] [rbp-20h]
  unsigned int v10; // [rsp+14h] [rbp-1Ch]
  void *v11; // [rsp+18h] [rbp-18h]
  void *ptr; // [rsp+20h] [rbp-10h]
  unsigned __int64 v13; // [rsp+28h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v11 = **(void ***)(*(_QWORD *)a1 + 48LL);
  v10 = 0;
  v9 = 0;
  if ( *a2 == 34 )
  {
    v10 = 1;
    ptr = sub_694FC(v11, (__int64)(a2 + 1), &v9, (__int64)(a2 + 1), a5, a6);
    if ( ptr )
    {
      if ( a2[v9 + v10] == 34 )
      {
        *(_QWORD *)(a1 + 56) = lydict_insert_zc(v11, ptr);
        *(_DWORD *)(a1 + 52) = 0;
        result = v9 + v10 + 1;
      }
      else
      {
        free(ptr);
        sub_13937(v11, 2, 3u, (char *)a1, (__int64)"JSON data (missing quotation-mark at the end of string)", v7, a2);
        result = 0LL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  else if ( a2[v10] == 123 )
  {
    v10 = 0;
    v9 = 0;
    do
    {
      v8 = (char)a2[v10];
      if ( v8 == 123 )
      {
        ++v9;
      }
      else if ( v8 == 125 )
      {
        --v9;
      }
      ++v10;
    }
    while ( a2[v10] && v9 );
    if ( v9 )
    {
      sub_13937(v11, 4, 3u, (char *)a1, a5, a6, a2);
      result = 0LL;
    }
    else
    {
      *(_DWORD *)(a1 + 52) = 2;
      *(_QWORD *)(a1 + 56) = lydict_insert(v11, a2, v10);
      result = v10;
    }
  }
  else
  {
    sub_13937(v11, 2, 3u, (char *)a1, (__int64)"anydata/anyxml content (not an object nor string)", a6, a2);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000006A75A) ----------------------------------------------------
__int64 __fastcall sub_6A75A(char *a1, char **a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // eax
  __int64 result; // rax
  int v8; // eax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  int v21; // eax
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r9
  int v26; // eax
  int v27; // eax
  __int64 v28; // [rsp+8h] [rbp-58h]
  unsigned int v29; // [rsp+14h] [rbp-4Ch]
  __int64 v30; // [rsp+18h] [rbp-48h]
  __int64 v31; // [rsp+28h] [rbp-38h]
  unsigned int i; // [rsp+30h] [rbp-30h]
  unsigned int v33; // [rsp+34h] [rbp-2Ch]
  char *v34; // [rsp+38h] [rbp-28h]
  void *v35; // [rsp+40h] [rbp-20h]
  _DWORD *v36; // [rsp+48h] [rbp-18h]
  _QWORD *v37; // [rsp+50h] [rbp-10h]
  unsigned __int64 v38; // [rsp+58h] [rbp-8h]

  v31 = (__int64)a1;
  v30 = a3;
  v29 = a4;
  v28 = a5;
  v38 = __readfsqword(0x28u);
  v33 = 0;
  if ( !a1 || !a3 )
    __assert_fail("leaf && data", "/home/mantovan/Repositories/libyang/src/parser_json.c", 0x1B0u, "json_get_value");
  v35 = **(void ***)(*(_QWORD *)a1 + 48LL);
  v36 = (_DWORD *)(*(_QWORD *)a1 + 128LL);
  if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) != 8 )
    goto LABEL_8;
  v6 = v33++;
  if ( *(_BYTE *)(v6 + a3) == 91 )
  {
    while ( 1 )
    {
      v8 = sub_694B2(v33 + v30);
      v33 += v8;
LABEL_8:
      *(_DWORD *)(v31 + 72) = *v36;
      if ( *(_BYTE *)(v33 + v30) == 34 )
      {
        ++v33;
        v34 = sub_694FC(v35, v33 + v30, &i, v33 + v30, a5, a6);
        if ( !v34 )
        {
          sub_13937(v35, -2, 3u, (char *)v31, v9, v10);
          return 0LL;
        }
        *(_QWORD *)(v31 + 56) = lydict_insert_zc(v35, v34);
        if ( *(_BYTE *)(i + v33 + v30) != 34 )
        {
          sub_13937(v35, 2, 3u, (char *)v31, (__int64)"JSON data (missing quotation-mark at the end of string)", v11);
          return 0LL;
        }
        v33 += i + 1;
      }
      else if ( *(_BYTE *)(v33 + v30) == 45 || (*__ctype_b_loc())[*(char *)(v33 + v30)] & 0x800 )
      {
        i = sub_69CA9(v35, (_BYTE *)(v30 + v33));
        if ( !i )
        {
          sub_13937(v35, -2, 3u, (char *)v31, v13, v14);
          return 0LL;
        }
        v34 = sub_811F((_BYTE *)(v30 + v33), 101, i);
        if ( v34 || (v34 = sub_811F((_BYTE *)(v30 + v33), 69, i)) != 0LL )
        {
          v34 = sub_69FBF(v35, (char *)(v33 + v30), i, v34);
          if ( !v34 )
            return 0LL;
          *(_QWORD *)(v31 + 56) = lydict_insert_zc(v35, v34);
        }
        else
        {
          *(_QWORD *)(v31 + 56) = lydict_insert(v35, v33 + v30, i);
        }
        v33 += i;
      }
      else if ( *(_BYTE *)(v33 + v30) != 102 && *(_BYTE *)(v33 + v30) != 116 )
      {
        if ( *(_BYTE *)(v33 + v30) != 91 )
          goto LABEL_58;
        for ( i = v33 + 1; (*__ctype_b_loc())[*(char *)(i + v30)] & 0x2000; ++i )
          ;
        if ( strncmp((const char *)(i + v30), "null", 4uLL) )
          goto LABEL_58;
        for ( i += 4; (*__ctype_b_loc())[*(char *)(i + v30)] & 0x2000; ++i )
          ;
        if ( *(_BYTE *)(i + v30) != 93 )
        {
LABEL_58:
          sub_13937(v35, 2, 3u, (char *)v31, (__int64)"JSON data (unexpected value)", v12);
          return 0LL;
        }
        *(_QWORD *)(v31 + 56) = lydict_insert(v35, byte_110942, 0LL);
        v33 = i + 1;
      }
      else
      {
        i = sub_6A438(v35, (const char *)(v30 + v33));
        if ( !i )
        {
          sub_13937(v35, -2, 3u, (char *)v31, v15, v16);
          return 0LL;
        }
        *(_QWORD *)(v31 + 56) = lydict_insert(v35, v33 + v30, i);
        v33 += i;
      }
      if ( !sub_37EF5(*(_QWORD *)v31 + 128LL, (char **)(v31 + 56), 0LL, (__int64 **)v31, 0LL, 0LL, 1, 0, v29 & 0x2000) )
        return 0LL;
      sub_AC63C((const char **)v31);
      sub_ACC62((unsigned int *)v31, v31 + 56, v17, v18, v19, v20);
      if ( *(_DWORD *)(*(_QWORD *)v31 + 56LL) != 8 )
        break;
      v21 = sub_694B2(v33 + v30);
      v33 += v21;
      if ( *(_BYTE *)(v33 + v30) != 44 )
      {
        if ( *(_BYTE *)(v33 + v30) != 93 )
        {
          sub_13937(v35, 2, 3u, (char *)v31, (__int64)"JSON data (expecting value-separator or end-array)", v22);
          return 0LL;
        }
        v26 = sub_694B2(++v33 + v30);
        v33 += v26;
        break;
      }
      if ( (unsigned int)sub_2DC82((char *)v31, v29 | 0x2000, v28)
        || (unsigned int)sub_2F7BD((char *)v31, v29, v28, v29, v23, v24)
        || (unsigned int)sub_3010D((__int64 *)v31, 0LL, a2, 0, 0LL) )
      {
        return 0LL;
      }
      v37 = calloc(1uLL, 0x50uLL);
      if ( !v37 )
      {
        sub_12222((__int64)v35, 0, 1, "Memory allocation failed (%s()).", (__int64)"json_get_value", v25);
        return 0LL;
      }
      v37[5] = *(_QWORD *)(v31 + 40);
      v37[4] = v31;
      *(_QWORD *)(v31 + 24) = v37;
      *((_BYTE *)v37 + 8) = *(_BYTE *)(v31 + 8);
      *((_BYTE *)v37 + 9) = 2 * ((*(_BYTE *)(v31 + 9) >> 1) & 7) | *((_BYTE *)v37 + 9) & 0xF1;
      *((_QWORD *)*a2 + 4) = v37;
      *v37 = *(_QWORD *)v31;
      v31 = (__int64)v37;
      ++v33;
    }
    v27 = sub_694B2(v33 + v30);
    v33 += v27;
    result = v33;
  }
  else
  {
    sub_13937(v35, 2, 3u, a1, (__int64)"JSON data (expected begin-array)", a6);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000006AF0B) ----------------------------------------------------
__int64 __fastcall sub_6AF0B(__int64 *a1, _QWORD *a2, __int64 a3, __int16 a4)
{
  __int64 v4; // r9
  int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  int v11; // eax
  __int64 v12; // r9
  int v13; // eax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r9
  int v17; // eax
  const char *v18; // rax
  __int64 v19; // r9
  int v20; // eax
  __int16 v21; // [rsp+4h] [rbp-7Ch]
  __int64 v22; // [rsp+8h] [rbp-78h]
  int v23; // [rsp+2Ch] [rbp-54h]
  unsigned int v24; // [rsp+30h] [rbp-50h]
  int v25; // [rsp+34h] [rbp-4Ch]
  __int64 v26; // [rsp+38h] [rbp-48h]
  char *s; // [rsp+40h] [rbp-40h]
  char *v28; // [rsp+48h] [rbp-38h]
  char *v29; // [rsp+50h] [rbp-30h]
  __int64 *v30; // [rsp+58h] [rbp-28h]
  __int64 v31; // [rsp+60h] [rbp-20h]
  void *v32; // [rsp+68h] [rbp-18h]
  void *ptr; // [rsp+70h] [rbp-10h]
  unsigned __int64 v34; // [rsp+78h] [rbp-8h]

  v22 = a3;
  v21 = a4;
  v34 = __readfsqword(0x28u);
  v32 = (void *)*a1;
  v24 = 0;
  s = 0LL;
  v29 = 0LL;
  v30 = a1;
  v31 = 0LL;
  *a2 = 0LL;
  if ( *(_BYTE *)(v24 + a3) == 123 )
  {
    do
    {
      v29 = 0LL;
      v6 = sub_694B2(++v24 + v22);
      v24 += v6;
      if ( *(_BYTE *)(v24 + v22) != 34 )
      {
        sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing quotation-mark at the beginning of string)", v8);
        return 0LL;
      }
      ++v24;
      s = sub_694FC(v32, v24 + v22, &v23, v24 + v22, v7, v8);
      if ( !v23 )
        goto LABEL_37;
      if ( *(_BYTE *)(v23 + v24 + v22) != 34 )
      {
        sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing quotation-mark at the end of string)", v9);
        goto LABEL_37;
      }
      v28 = strchr(s, 58);
      if ( v28 )
      {
        *v28++ = 0;
        v29 = s;
        v30 = (__int64 *)ly_ctx_get_module(*a1, s, 0LL, 0LL);
        if ( !v30 )
        {
          sub_13937(v32, 47, 0, 0LL, (__int64)v28, v10);
          goto LABEL_37;
        }
      }
      else
      {
        v28 = s;
      }
      v24 += v23 + 1;
      v11 = sub_694B2(v24 + v22);
      v24 += v11;
      if ( *(_BYTE *)(v24 + v22) != 58 )
      {
        sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing name-separator)", v12);
        goto LABEL_37;
      }
      v13 = sub_694B2(++v24 + v22);
      v24 += v13;
      if ( *(_BYTE *)(v24 + v22) != 34 )
      {
        sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing quotation-mark at the beginning of string)", v15);
        goto LABEL_37;
      }
      ++v24;
      ptr = sub_694FC(v32, v24 + v22, &v23, v24 + v22, v14, v15);
      if ( !v23 )
        goto LABEL_37;
      if ( *(_BYTE *)(v23 + v24 + v22) != 34 )
      {
        sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing quotation-mark at the end of string)", v16);
        free(ptr);
        goto LABEL_37;
      }
      v24 += v23 + 1;
      v17 = sub_694B2(v24 + v22);
      v24 += v17;
      v25 = sub_3AB03(*a1, 0LL, 0LL, (__int64)v29, v28, (__int64)ptr, 0LL, v21, (char ***)&v26);
      if ( v25 == -1 )
      {
        free(ptr);
        goto LABEL_37;
      }
      if ( v25 == 1 )
      {
        if ( v21 & 0x200 )
        {
          sub_13937(v32, 51, 0, 0LL, (__int64)v29, (__int64)v28, ptr);
          free(ptr);
          goto LABEL_37;
        }
        if ( v29 )
          v18 = v29;
        else
          v18 = "<none>";
        sub_12222(
          (__int64)v32,
          1u,
          0,
          "Unknown \"%s:%s\" metadata with value \"%s\", ignoring.",
          (__int64)v18,
          (__int64)v28,
          ptr);
        free(ptr);
      }
      else
      {
        free(ptr);
        if ( v31 )
        {
          *(_QWORD *)(v31 + 8) = v26;
          v31 = v26;
        }
        else
        {
          v31 = v26;
          *a2 = v26;
        }
      }
      free(s);
      s = 0LL;
    }
    while ( *(_BYTE *)(v24 + v22) == 44 );
    if ( *(_BYTE *)(v24 + v22) == 125 )
    {
      v20 = sub_694B2(++v24 + v22);
      v24 += v20;
      return v24;
    }
    sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing end-object)", v19);
  }
  else
  {
    if ( !strncmp((const char *)(v24 + a3), "null", 4uLL) )
      return (unsigned int)sub_694B2(v24 + 4 + v22) + v24 + 4;
    sub_13937(v32, 2, 0, 0LL, (__int64)"JSON data (missing begin-object)", v4);
  }
LABEL_37:
  free(s);
  if ( *a2 )
  {
    lyd_free_attr(*v30, 0LL, *a2, 1LL);
    *a2 = 0LL;
  }
  return 0LL;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 74E0: using guessed type __int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006B4DE) ----------------------------------------------------
signed __int64 __fastcall sub_6B4DE(_QWORD *a1, _QWORD *a2, __int64 a3, char a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  _QWORD *v8; // ST38_8
  char v9; // [rsp+4h] [rbp-3Ch]
  __int64 v10; // [rsp+8h] [rbp-38h]
  _QWORD *v11; // [rsp+10h] [rbp-30h]
  signed int v12; // [rsp+24h] [rbp-1Ch]
  __int64 i; // [rsp+28h] [rbp-18h]
  _QWORD *j; // [rsp+30h] [rbp-10h]
  _DWORD *ptr; // [rsp+38h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  v9 = a4;
  v12 = 0;
  while ( 2 )
  {
    if ( !v11 )
      return 0LL;
    ptr = v11;
    v11 = (_QWORD *)*v11;
    if ( ptr[6] )
      v12 = 1;
    for ( i = v10; i; i = *(_QWORD *)(i + 24) )
    {
      if ( *((_QWORD *)ptr + 2) == *(_QWORD *)i )
      {
        if ( !v12 || v12 == ptr[6] )
        {
          if ( *(_QWORD *)(i + 16) )
          {
            sub_13937(
              a1,
              2,
              3u,
              (char *)i,
              (__int64)"attribute (multiple attribute definitions belong to a single element)",
              a6);
            free(ptr);
            goto LABEL_25;
          }
          *(_QWORD *)(i + 16) = *((_QWORD *)ptr + 1);
          for ( j = (_QWORD *)*((_QWORD *)ptr + 1); j; j = (_QWORD *)j[1] )
            *j = i;
          break;
        }
        ++v12;
      }
    }
    if ( i )
    {
      free(ptr);
      if ( !(v9 & 8) || !(unsigned int)sub_3AF7B(a1, *(_QWORD **)(i + 16), (char *)i, 0LL, v6, a6) )
        continue;
    }
    else
    {
      sub_13937(a1, 1, 0, 0LL, (__int64)"element for the specified attribute", *(_QWORD *)(*((_QWORD *)ptr + 1) + 24LL));
      lyd_free_attr(**(_QWORD **)(*((_QWORD *)ptr + 2) + 48LL), 0LL, *((_QWORD *)ptr + 1), 1LL);
      free(ptr);
    }
    break;
  }
LABEL_25:
  while ( v11 )
  {
    v8 = v11;
    v11 = (_QWORD *)*v11;
    lyd_free_attr(a1, 0LL, v8[1], 1LL);
    free(v8);
  }
  return 0xFFFFFFFFLL;
}
// 74E0: using guessed type __int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006B70E) ----------------------------------------------------
signed __int64 __fastcall sub_6B70E(void *a1, char *a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed int v6; // eax
  signed int v8; // [rsp+24h] [rbp-Ch]
  int v9; // [rsp+28h] [rbp-8h]
  int v10; // [rsp+2Ch] [rbp-4h]

  v8 = 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    if ( !*(_BYTE *)((unsigned int)*a4 + a3) )
      return 0LL;
    v6 = *(char *)((unsigned int)*a4 + a3);
    if ( v6 == 91 )
    {
      if ( !v8 )
        ++v10;
    }
    else if ( v6 > 91 )
    {
      if ( v6 == 123 )
      {
        if ( !v8 )
          ++v9;
      }
      else if ( v6 == 125 )
      {
        if ( !v8 )
          --v9;
      }
      else if ( v6 == 93 && !v8 )
      {
        --v10;
      }
    }
    else if ( v6 == 34 )
    {
      if ( v8 )
      {
        if ( *(_BYTE *)((unsigned int)(*a4 - 1) + a3) != 92 )
          v8 = 0;
      }
      else
      {
        if ( *(_BYTE *)((unsigned int)(*a4 - 1) + a3) == 92 )
        {
          sub_13937(a1, 50, 3u, a2, (__int64)"JSON data (missing quotation mark for a string data) ", a6, a4);
          return 0xFFFFFFFFLL;
        }
        v8 = 1;
      }
    }
    else if ( v6 == 44 && !v8 && !v9 && !v10 )
    {
      return 0LL;
    }
    if ( v9 < 0 )
    {
      if ( !v10 )
        return 0LL;
      sub_13937(a1, 2, 3u, a2, (__int64)"JSON data (missing end-array)", a6, a4);
      return 0xFFFFFFFFLL;
    }
    if ( v10 < 0 )
      break;
    ++*a4;
  }
  if ( !v9 )
    return 0LL;
  sub_13937(a1, 2, 3u, a2, (__int64)"JSON data (missing end-object)", a6, a4);
  return 0xFFFFFFFFLL;
}

//----- (000000000006B929) ----------------------------------------------------
__int64 __fastcall sub_6B929(__int64 a1, _BYTE *a2, _QWORD *a3, char **a4, __int64 a5, __int64 a6, void **a7, unsigned int a8, __int64 a9, _QWORD *a10, const char *a11)
{
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // eax
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rax
  __int64 v21; // rbx
  __int64 v22; // r8
  __int64 v23; // r9
  unsigned int v24; // esi
  __int64 v25; // r8
  __int64 v26; // r9
  unsigned int v27; // eax
  __int64 v28; // r9
  char v29; // al
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  unsigned int v33; // eax
  int v34; // eax
  _BYTE *v35; // rsi
  __int64 v36; // rdx
  __int64 v37; // rcx
  __int64 v38; // r8
  __int64 v39; // r9
  int v40; // eax
  const char *v41; // rax
  __int64 v42; // rdx
  __int64 v43; // rcx
  __int64 v44; // r8
  __int64 v45; // r9
  __int64 v46; // r9
  int v47; // eax
  __int64 v48; // r9
  int v49; // eax
  __int64 v50; // r8
  __int64 v51; // r9
  int v52; // eax
  int v53; // eax
  __int64 v54; // r9
  int v55; // eax
  __int64 v56; // rsi
  __int64 v57; // r8
  __int64 v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // r8
  __int64 v62; // r9
  __int64 v63; // r9
  int v64; // eax
  __int64 v65; // r9
  __int64 v66; // r8
  __int64 v67; // r9
  char **v68; // rax
  int v69; // eax
  __int64 v70; // r8
  __int64 v71; // r9
  char **v72; // rax
  __int64 v73; // [rsp+20h] [rbp-C0h]
  _QWORD *v74; // [rsp+28h] [rbp-B8h]
  char **v75; // [rsp+30h] [rbp-B0h]
  _QWORD *v76; // [rsp+38h] [rbp-A8h]
  _BYTE *v77; // [rsp+40h] [rbp-A0h]
  __int64 v78; // [rsp+48h] [rbp-98h]
  unsigned __int8 v79; // [rsp+57h] [rbp-89h]
  unsigned int v80; // [rsp+58h] [rbp-88h]
  int v81; // [rsp+5Ch] [rbp-84h]
  int v82; // [rsp+60h] [rbp-80h]
  int j; // [rsp+64h] [rbp-7Ch]
  _QWORD *v84; // [rsp+68h] [rbp-78h]
  const char **v85; // [rsp+70h] [rbp-70h]
  char **v86; // [rsp+78h] [rbp-68h]
  void *ptr; // [rsp+80h] [rbp-60h]
  char *s2; // [rsp+88h] [rbp-58h]
  char *v89; // [rsp+90h] [rbp-50h]
  __int64 v90; // [rsp+98h] [rbp-48h]
  _QWORD *v91; // [rsp+A0h] [rbp-40h]
  _QWORD *i; // [rsp+A8h] [rbp-38h]
  char *s; // [rsp+B0h] [rbp-30h]
  __int64 v94; // [rsp+B8h] [rbp-28h]
  char *v95; // [rsp+C0h] [rbp-20h]
  unsigned __int64 v96; // [rsp+C8h] [rbp-18h]

  v78 = a1;
  v77 = a2;
  v76 = a3;
  v75 = a4;
  v74 = (_QWORD *)a5;
  v73 = a6;
  v96 = __readfsqword(0x28u);
  v80 = 0;
  v82 = 0;
  v89 = 0LL;
  s = 0LL;
  v90 = 0LL;
  v91 = 0LL;
  v94 = 0LL;
  v84 = 0LL;
  i = 0LL;
  if ( *a2 != 34 )
  {
    sub_13937(
      (void *)v78,
      2,
      3u,
      *v75,
      (__int64)"JSON data (missing quotation-mark at the beginning of string)",
      a6,
      a11);
    return 0LL;
  }
  ++v80;
  s = sub_694FC((void *)v78, (__int64)&v77[v80], &v81, (__int64)&v77[v80], a5, a6);
  if ( !v81 )
    goto LABEL_241;
  if ( v77[v80 + v81] != 34 )
  {
    sub_13937((void *)v78, 2, 3u, *v75, (__int64)"JSON data (missing quotation-mark at the end of string)", v12, a11);
    goto LABEL_241;
  }
  s2 = strchr(s, 58);
  if ( s2 )
  {
    *s2++ = 0;
    v89 = s;
    if ( *s == 64 )
      ++v89;
  }
  else
  {
    s2 = s;
    if ( *s == 64 )
      ++s2;
  }
  v80 += v81 + 1;
  v80 += sub_694B2((__int64)&v77[v80]);
  if ( v77[v80] != 58 )
  {
    sub_13937((void *)v78, 2, 3u, *v75, (__int64)"JSON data (missing name-separator)", v13, a11);
    goto LABEL_241;
  }
  v80 += (unsigned __int64)sub_694B2((__int64)&v77[v80 + 1]) + 1;
  if ( *s == 64 && !s[1] )
  {
    if ( *v75 )
    {
      v81 = sub_6AF0B(*(__int64 **)(*(_QWORD *)*v75 + 48LL), &v86, (__int64)&v77[v80], a8);
      if ( v81 )
      {
        v80 += v81;
        if ( *((_QWORD *)*v75 + 2) )
        {
          lyd_free_attr(v78, 0LL, v86, 1LL);
        }
        else
        {
          *((_QWORD *)*v75 + 2) = v86;
          while ( v86 )
          {
            *v86 = *v75;
            v86 = (char **)v86[1];
          }
        }
        if ( !(a8 & 8) || !(unsigned int)sub_3AF7B((_QWORD *)v78, *((_QWORD **)*v75 + 2), *v75, 0LL, v15, v16) )
        {
          free(s);
          return v80;
        }
      }
      else
      {
        sub_13937((void *)v78, -2, 3u, *v75, v15, v16, a11);
      }
    }
    else
    {
      sub_13937((void *)v78, 2, 0, 0LL, (__int64)"attribute with no corresponding element to belongs to", v14, a11);
    }
    goto LABEL_241;
  }
  if ( *v75 )
  {
    if ( v89 )
    {
      v90 = ly_ctx_get_module(v78, v89, 0LL, 1LL);
      if ( *(_QWORD *)(v78 + 112) )
      {
        if ( v90 )
        {
          if ( *(_BYTE *)(v90 + 64) >= 0 )
            (*(void (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v78 + 112))(
              v78,
              *(_QWORD *)(v90 + 8),
              *(_QWORD *)(v90 + 176),
              1LL,
              *(_QWORD *)(v78 + 120));
        }
        else
        {
          (*(void (__fastcall **)(__int64, char *, _QWORD, _QWORD, _QWORD))(v78 + 112))(
            v78,
            v89,
            0LL,
            0LL,
            *(_QWORD *)(v78 + 120));
        }
      }
    }
    if ( *(_DWORD *)(*(_QWORD *)*v75 + 56LL) == 256 || *(_DWORD *)(*(_QWORD *)*v75 + 56LL) == 0x4000 )
    {
      do
        v91 = (_QWORD *)lys_getnext(v91, *(_QWORD *)*v75, 0LL, 8LL);
      while ( v91 && (!(a8 & 0x10) || *((_DWORD *)v91 + 14) != 512) && (!(a8 & 0x20) || *((_DWORD *)v91 + 14) != 1024) );
      v76 = v91;
      v91 = 0LL;
    }
    if ( v76 )
    {
      while ( 1 )
      {
        v91 = (_QWORD *)lys_getnext(v91, v76, 0LL, 0LL);
        if ( !v91 )
          break;
        if ( !strcmp((const char *)*v91, s2) )
        {
          if ( v89 )
          {
            v18 = lys_node_module(v91);
            if ( !strcmp(*(const char **)(v18 + 8), v89) )
              break;
          }
          if ( !v89 )
          {
            v19 = lys_node_module(v91);
            if ( v19 == lys_node_module(v76) )
              break;
          }
        }
      }
    }
    else
    {
      while ( 1 )
      {
        v91 = (_QWORD *)lys_getnext(v91, *(_QWORD *)*v75, 0LL, 0LL);
        if ( !v91 )
          break;
        if ( !strcmp((const char *)*v91, s2) )
        {
          if ( v89 )
          {
            v20 = lys_node_module(v91);
            if ( !strcmp(*(const char **)(v20 + 8), v89) )
              break;
          }
          if ( !v89 )
          {
            v21 = lys_node_module(v91);
            if ( v21 == lyd_node_module(*v75) )
              break;
          }
        }
      }
    }
  }
  else
  {
    v90 = ly_ctx_get_module(v78, v89, 0LL, 0LL);
    if ( *(_QWORD *)(v78 + 112) )
    {
      if ( v90 )
      {
        if ( *(_BYTE *)(v90 + 64) >= 0 )
          v90 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v78 + 112))(
                  v78,
                  *(_QWORD *)(v90 + 8),
                  *(_QWORD *)(v90 + 176),
                  1LL,
                  *(_QWORD *)(v78 + 120));
      }
      else
      {
        v90 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD, _QWORD, _QWORD))(v78 + 112))(
                v78,
                v89,
                0LL,
                0LL,
                *(_QWORD *)(v78 + 120));
      }
    }
    if ( v90 && *(_BYTE *)(v90 + 64) < 0 )
    {
      if ( a11 )
      {
        v17 = strlen(a11);
        v94 = sub_40D5F(v90, a11, v17);
        v91 = 0LL;
        if ( v94 )
        {
          do
            v91 = (_QWORD *)lys_getnext(v91, v94, v90, 0LL);
          while ( v91 && strcmp((const char *)*v91, s2) );
        }
      }
      else
      {
        do
          v91 = (_QWORD *)lys_getnext(v91, 0LL, v90, 0LL);
        while ( v91 && strcmp((const char *)*v91, s2) );
      }
    }
  }
  v90 = lys_node_module(v91);
  if ( !v90 || *(_BYTE *)(v90 + 64) >= 0 || *(_BYTE *)(v90 + 64) & 0x40 )
  {
    if ( a8 & 0x200 )
    {
      if ( *v75 )
        v24 = 3;
      else
        v24 = 0;
      sub_13937((void *)v78, 47, v24, *v75, (__int64)s2, v23, a11);
    }
    else if ( !(unsigned int)sub_6B70E((void *)v78, *v75, (__int64)v77, &v80, v22, v23) )
    {
      free(s);
      return v80;
    }
    goto LABEL_241;
  }
  if ( *s != 64 )
  {
    v27 = *((_DWORD *)v91 + 14);
    if ( v27 != 32 )
    {
      if ( v27 <= 0x20 )
      {
        if ( v27 != 4 )
        {
          if ( v27 <= 4 )
          {
            if ( v27 != 1 )
            {
LABEL_119:
              sub_12222(
                v78,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/parser_json.c",
                1096LL,
                a11);
              goto LABEL_241;
            }
            goto LABEL_116;
          }
          if ( v27 != 8 )
          {
            if ( v27 != 16 )
              goto LABEL_119;
            goto LABEL_116;
          }
        }
        v84 = calloc(1uLL, 0x50uLL);
LABEL_120:
        if ( !v84 )
        {
          sub_12222(v78, 0, 1, "Memory allocation failed (%s()).", (__int64)"json_parse_data", v28, a11);
          goto LABEL_241;
        }
        v84[4] = v84;
        *v84 = v91;
        v84[5] = *v75;
        i = 0LL;
        if ( *((_DWORD *)v91 + 14) == 4 && lys_is_key(v91, &v79) )
        {
          if ( !*v75 )
            __assert_fail("*parent", "/home/mantovan/Repositories/libyang/src/parser_json.c", 0x453u, "json_parse_data");
          j = 0;
          for ( i = (_QWORD *)*((_QWORD *)*v75 + 8);
                i && j < v79 && *(_DWORD *)(*i + 56LL) == 4 && lys_is_key(*i, 0LL);
                i = (_QWORD *)i[3] )
          {
            ++j;
          }
          if ( i )
          {
            if ( i == *((_QWORD **)*v75 + 8) )
            {
              *((_QWORD *)*v75 + 8) = v84;
              v74 = v84;
            }
            if ( *(_QWORD *)(i[4] + 24LL) )
              *(_QWORD *)(i[4] + 24LL) = v84;
            v84[4] = i[4];
            i[4] = v84;
            v84[3] = i;
          }
        }
        if ( !i )
        {
          if ( *v75 && !*((_QWORD *)*v75 + 8) )
            *((_QWORD *)*v75 + 8) = v84;
          if ( v73 )
          {
            v84[4] = v73;
            *(_QWORD *)(v73 + 24) = v84;
            v74[4] = v84;
          }
          else
          {
            v84[4] = v84;
            v74 = v84;
          }
        }
        v29 = sub_C3AB(*v84);
        *((_BYTE *)v84 + 8) = v29;
        if ( (unsigned int)sub_28290((__int64)v91, 0, 0LL) )
          *((_BYTE *)v84 + 9) = *((_BYTE *)v84 + 9) & 0xF1 | 8;
        v33 = *((_DWORD *)v91 + 14);
        if ( v33 != 32 )
        {
          if ( v33 <= 0x20 )
          {
            if ( v33 != 4 )
            {
              if ( v33 <= 4 )
              {
                if ( v33 != 1 )
                {
LABEL_229:
                  sub_12222(
                    v78,
                    0,
                    4,
                    "Internal error (%s:%d).",
                    (__int64)"/home/mantovan/Repositories/libyang/src/parser_json.c",
                    1344LL,
                    a11);
                  goto LABEL_241;
                }
                goto LABEL_171;
              }
              if ( v33 != 8 )
              {
                if ( v33 == 16 )
                {
                  if ( v77[v80] == 91 )
                  {
                    v85 = (const char **)v84;
LABEL_203:
                    v53 = sub_694B2((__int64)&v77[++v80]);
                    v80 += v53;
                    if ( v77[v80] == 123 )
                    {
                      i = 0LL;
                      ptr = 0LL;
                      while ( 1 )
                      {
                        v55 = sub_694B2((__int64)&v77[++v80]);
                        v80 += v55;
                        v56 = (__int64)&v77[v80];
                        v81 = sub_6B929(v78, v56, 0, (__int64)&v85, (__int64)v85[8], (__int64)i);
                        if ( !v81 )
                          break;
                        v80 += v81;
                        if ( v85[8] )
                          i = (_QWORD *)*((_QWORD *)v85[8] + 4);
                        if ( v77[v80] != 44 )
                        {
                          if ( !(*v85)[30] )
                          {
                            sub_AC63C(v85);
                            sub_ACC62((unsigned int *)v85, v56, v59, v60, v61, v62);
                          }
                          if ( (unsigned int)sub_6B4DE((_QWORD *)v78, ptr, (__int64)v85[8], a8, v57, v58) )
                            goto LABEL_241;
                          if ( v77[v80] != 125 )
                          {
                            sub_13937(
                              (void *)v78,
                              2,
                              3u,
                              (char *)v84,
                              (__int64)"JSON data (missing list instance's end-object)",
                              v63,
                              a11);
                            goto LABEL_241;
                          }
                          v64 = sub_694B2((__int64)&v77[++v80]);
                          v80 += v64;
                          if ( v77[v80] == 44 )
                          {
                            if ( (unsigned int)sub_2DC82((char *)v85, a8 | 0x2000, a9)
                              || (unsigned int)sub_2F7BD((char *)v85, a8, a9, a8, v66, v67) )
                            {
                              goto LABEL_241;
                            }
                            v68 = (char **)(v73 ? &v74 : 0LL);
                            if ( (unsigned int)sub_3010D((__int64 *)v85, 0LL, v68, 0, 0LL) )
                              goto LABEL_241;
                            v95 = (char *)calloc(1uLL, 0x48uLL);
                            if ( !v95 )
                            {
                              sub_12222(
                                v78,
                                0,
                                1,
                                "Memory allocation failed (%s()).",
                                (__int64)"json_parse_data",
                                v65,
                                a11);
                              goto LABEL_241;
                            }
                            *((_QWORD *)v95 + 5) = v85[5];
                            *((_QWORD *)v95 + 4) = v85;
                            v85[3] = v95;
                            v95[8] = *((_BYTE *)v85 + 8);
                            v95[9] = 2 * ((*((_BYTE *)v85 + 9) >> 1) & 7) | v95[9] & 0xF1;
                            v74[4] = v95;
                            *(_QWORD *)v95 = *v85;
                            v85 = (const char **)v95;
                          }
                          if ( v77[v80] == 44 )
                            goto LABEL_203;
                          v84 = v85;
                          if ( v77[v80] != 93 )
                          {
                            sub_13937(
                              (void *)v78,
                              2,
                              3u,
                              (char *)v84,
                              (__int64)"JSON data (missing end-array)",
                              v65,
                              a11);
                            goto LABEL_241;
                          }
                          v69 = sub_694B2((__int64)&v77[++v80]);
                          v80 += v69;
                          goto LABEL_230;
                        }
                      }
                    }
                    else
                    {
                      sub_13937(
                        (void *)v78,
                        2,
                        3u,
                        (char *)v84,
                        (__int64)"JSON data (missing list instance's begin-object)",
                        v54,
                        a11);
                    }
                  }
                  else
                  {
                    sub_13937((void *)v78, 2, 3u, (char *)v84, (__int64)"JSON data (missing begin-array)", v32, a11);
                  }
                  goto LABEL_241;
                }
                goto LABEL_229;
              }
            }
            v81 = sub_6A75A((char *)v84, (char **)&v74, (__int64)&v77[v80], a8, a9, v32);
            if ( !v81 )
              goto LABEL_241;
            while ( v84[3] && *(_QWORD *)v84[3] == *v84 )
              v84 = (_QWORD *)v84[3];
            v80 += v81;
            v34 = sub_694B2((__int64)&v77[v80]);
            v80 += v34;
            goto LABEL_230;
          }
          if ( v33 == 256 )
            goto LABEL_171;
          if ( v33 <= 0x100 )
          {
            if ( v33 != 128 )
              goto LABEL_229;
            goto LABEL_171;
          }
          if ( v33 == 0x4000 )
          {
LABEL_171:
            if ( v91[7] & 0x4100 )
            {
              if ( !(a8 & 0x10) || *a10 )
              {
                sub_13937((void *)v78, 47, 3u, (char *)v84, *v91, v32, a11);
                if ( *((_DWORD *)v91 + 14) == 256 )
                  v41 = "rpc";
                else
                  v41 = "action";
                sub_13937((void *)v78, -1, 5u, 0LL, (__int64)"Unexpected %s node \"%s\".", (__int64)v41, *v91);
                goto LABEL_241;
              }
              *a10 = v84;
            }
            else if ( *((_DWORD *)v91 + 14) == 128 )
            {
              if ( !(a8 & 0x40) || *a10 )
              {
                sub_13937((void *)v78, 47, 3u, (char *)v84, *v91, v32, a11);
                sub_13937((void *)v78, -1, 5u, 0LL, (__int64)"Unexpected notification node \"%s\".", *v91);
                goto LABEL_241;
              }
              *a10 = v84;
            }
            sub_AC63C((const char **)v84);
            sub_ACC62((unsigned int *)v84, 0LL, v42, v43, v44, v45);
            if ( v77[v80] != 123 )
            {
              sub_13937((void *)v78, 2, 3u, (char *)v84, (__int64)"JSON data (missing begin-object)", v46, a11);
              goto LABEL_241;
            }
            v47 = sub_694B2((__int64)&v77[++v80]);
            v80 += v47;
            if ( v77[v80] != 125 )
            {
              --v80;
              i = 0LL;
              ptr = 0LL;
              while ( 1 )
              {
                v49 = sub_694B2((__int64)&v77[++v80]);
                v80 += v49;
                v81 = sub_6B929(v78, v80 + (unsigned int)v77, 0, (__int64)&v84, v84[8], (__int64)i);
                if ( !v81 )
                  goto LABEL_241;
                v80 += v81;
                if ( v84[8] )
                  i = *(_QWORD **)(v84[8] + 32LL);
                if ( v77[v80] != 44 )
                {
                  if ( (unsigned int)sub_6B4DE((_QWORD *)v78, ptr, v84[8], a8, v50, v51) )
                    goto LABEL_241;
                  break;
                }
              }
            }
            if ( v77[v80] != 125 )
            {
              sub_13937((void *)v78, 2, 3u, (char *)v84, (__int64)"JSON data (missing end-object)", v48, a11);
              goto LABEL_241;
            }
            v52 = sub_694B2((__int64)&v77[++v80]);
            v80 += v52;
            if ( *((_DWORD *)v91 + 14) == 1 && !v84[8] && !v84[2] && !v91[17] )
              *((_BYTE *)v84 + 9) |= 1u;
LABEL_230:
            if ( !(unsigned int)sub_2DC82((char *)v84, a8 | 0x2000, a9)
              && !(unsigned int)sub_2F7BD((char *)v84, a8, a9, a8, v70, v71) )
            {
              v72 = (char **)(v73 ? &v74 : 0LL);
              if ( !(unsigned int)sub_3010D(v84, 0LL, v72, 0, 0LL) )
              {
                if ( *(_DWORD *)(*v84 + 56LL) & 0x18 )
                  *((_BYTE *)v84 + 8) |= 1u;
                if ( !*v75 )
                  *v75 = (char *)v84;
                free(s);
                return v80;
              }
            }
LABEL_241:
            for ( j = *(_DWORD *)(a9 + 16) - 1; j >= 0; --j )
            {
              if ( *(_QWORD **)(8LL * j + *(_QWORD *)a9) == v84 )
                sub_1FB5F(a9, j);
            }
            while ( *a7 )
            {
              ptr = *a7;
              *a7 = *(void **)*a7;
              lyd_free_attr(v78, 0LL, *((_QWORD *)ptr + 1), 1LL);
              free(ptr);
            }
            lyd_free(v84);
            free(s);
            return 0LL;
          }
          if ( v33 != 32800 )
            goto LABEL_229;
        }
        v35 = &v77[v80];
        v81 = sub_6A529((__int64)v84, v35, (__int64)&v77[v80], v30, v31, v32);
        if ( !v81 )
          goto LABEL_241;
        sub_AC63C((const char **)v84);
        sub_ACC62((unsigned int *)v84, (__int64)v35, v36, v37, v38, v39);
        v80 += v81;
        v40 = sub_694B2((__int64)&v77[v80]);
        v80 += v40;
        goto LABEL_230;
      }
      if ( v27 == 256 )
        goto LABEL_116;
      if ( v27 <= 0x100 )
      {
        if ( v27 != 128 )
          goto LABEL_119;
        goto LABEL_116;
      }
      if ( v27 == 0x4000 )
      {
LABEL_116:
        v84 = calloc(1uLL, 0x48uLL);
        goto LABEL_120;
      }
      if ( v27 != 32800 )
        goto LABEL_119;
    }
    v84 = calloc(1uLL, 0x40uLL);
    goto LABEL_120;
  }
  if ( v77[v80] == 91 )
  {
    v82 = 1;
    v80 += (unsigned __int64)sub_694B2((__int64)&v77[v80 + 1]) + 1;
  }
  while ( 1 )
  {
    v81 = sub_6AF0B((__int64 *)v90, &v86, (__int64)&v77[v80], a8);
    if ( !v81 )
    {
      sub_13937((void *)v78, -2, 3u, *v75, v25, v26, a11);
      goto LABEL_241;
    }
    v80 += v81;
    if ( v86 )
    {
      ptr = malloc(0x20uLL);
      if ( !ptr )
      {
        sub_12222(v78, 0, 1, "Memory allocation failed (%s()).", (__int64)"json_parse_data", v26, a11);
        goto LABEL_241;
      }
      *((_QWORD *)ptr + 1) = v86;
      *((_DWORD *)ptr + 6) = v82;
      *((_QWORD *)ptr + 2) = v91;
      *(_QWORD *)ptr = *a7;
      *a7 = ptr;
    }
    if ( !v82 )
      break;
    if ( v77[v80] != 44 )
    {
      if ( v77[v80] != 93 )
      {
        sub_13937((void *)v78, 2, 3u, *v75, (__int64)"JSON data (missing end-array)", v26, a11);
        goto LABEL_241;
      }
      v80 += (unsigned __int64)sub_694B2((__int64)&v77[v80 + 1]) + 1;
      break;
    }
    v80 += (unsigned __int64)sub_694B2((__int64)&v77[v80 + 1]) + 1;
    ++v82;
  }
  free(s);
  return v80;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 74E0: using guessed type __int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD);
// 7850: using guessed type __int64 __fastcall lys_is_key(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (000000000006D5D5) ----------------------------------------------------
__int64 __fastcall sub_6D5D5(__int64 a1, __int64 a2, unsigned int a3, __int64 *a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  int v16; // ST6C_4
  _QWORD *v17; // rsi
  __int64 v18; // r8
  __int64 v19; // r9
  const char *v20; // rax
  __int64 v21; // rax
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r9
  __int64 *v25; // rax
  const char *v26; // [rsp+0h] [rbp-90h]
  __int64 v27; // [rsp+8h] [rbp-88h]
  __int64 *v28; // [rsp+10h] [rbp-80h]
  unsigned int v29; // [rsp+1Ch] [rbp-74h]
  unsigned int v30; // [rsp+3Ch] [rbp-54h]
  unsigned int v31; // [rsp+3Ch] [rbp-54h]
  unsigned int v32; // [rsp+3Ch] [rbp-54h]
  unsigned int v33; // [rsp+3Ch] [rbp-54h]
  unsigned int v34; // [rsp+3Ch] [rbp-54h]
  signed int v35; // [rsp+40h] [rbp-50h]
  int v36; // [rsp+44h] [rbp-4Ch]
  char *v37; // [rsp+48h] [rbp-48h]
  char **v38; // [rsp+50h] [rbp-40h]
  char **v39; // [rsp+58h] [rbp-38h]
  _QWORD *v40; // [rsp+60h] [rbp-30h]
  char *j; // [rsp+68h] [rbp-28h]
  char **i; // [rsp+70h] [rbp-20h]
  char **v43; // [rsp+78h] [rbp-18h]
  void *ptr; // [rsp+80h] [rbp-10h]
  unsigned __int64 v45; // [rsp+88h] [rbp-8h]

  v29 = a3;
  v28 = a4;
  v27 = a5;
  v26 = (const char *)a6;
  v45 = __readfsqword(0x28u);
  v37 = 0LL;
  i = 0LL;
  v43 = 0LL;
  v39 = 0LL;
  ptr = 0LL;
  v35 = 0;
  v40 = 0LL;
  if ( !a1 || !a2 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_parse_json", a6, a6);
    return 0LL;
  }
  v30 = sub_694B2(a2);
  if ( *(_BYTE *)(v30 + a2) != 123 )
  {
    sub_13937((void *)a1, 2, 0, 0LL, (__int64)"JSON data (missing top level begin-object)", v7, v26);
    return 0LL;
  }
  if ( *(_BYTE *)((unsigned int)sub_694B2(v30 + 1 + a2) + v30 + 1 + a2) == 125 )
  {
    if ( v29 & 0x20000 )
      v37 = (char *)ly_ctx_info(a1, a2);
    lyd_validate(&v37, v29, a1);
    return (__int64)v37;
  }
  ptr = calloc(1uLL, 0x28uLL);
  if ( !ptr )
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_parse_json", v8, v26);
    return 0LL;
  }
  if ( v28 )
  {
    if ( !(v29 & 0x20) )
      __assert_fail(
        "options & LYD_OPT_RPCREPLY",
        "/home/mantovan/Repositories/libyang/src/parser_json.c",
        0x596u,
        "lyd_parse_json");
    if ( *(_DWORD *)(*v28 + 56) == 256 )
    {
      i = (char **)sub_AE9DE(0LL, *v28, 0);
      v43 = i;
    }
    else
    {
      v43 = (char **)lyd_dup(v28, 1LL);
      j = (char *)v43;
      for ( i = v43; i && *((_DWORD *)*i + 14) != 0x4000; i = (char **)j )
      {
        if ( *((_DWORD *)*i + 14) & 0x802C )
          j = 0LL;
        else
          j = i[8];
        if ( !j )
        {
          if ( i == v43 )
            break;
          j = i[3];
        }
        while ( !j )
        {
          i = (char **)i[5];
          if ( i[5] == v43[5] )
            break;
          j = i[3];
        }
      }
      if ( !i )
      {
        sub_12222(
          a1,
          0,
          3,
          "%s: invalid variable parameter (const struct lyd_node *rpc_act).",
          (__int64)"lyd_parse_json",
          v9,
          v26);
        goto LABEL_100;
      }
      lyd_free_withsiblings(i[8]);
    }
  }
  j = 0LL;
  v38 = i;
  do
  {
    v31 = (unsigned __int64)sub_694B2(v30 + 1 + a2) + v30 + 1;
    if ( !v35 )
    {
      if ( !strncmp((const char *)(v31 + a2), "\"yang:action\"", 0xDuLL) )
      {
        v32 = (unsigned __int64)sub_694B2(v31 + 13 + a2) + v31 + 13;
        if ( *(_BYTE *)(v32 + a2) != 58 )
        {
          sub_13937((void *)a1, 2, 0, 0LL, (__int64)"JSON data (missing top-level begin-object)", v10, v26);
          goto LABEL_100;
        }
        v33 = (unsigned __int64)sub_694B2(v32 + 1 + a2) + v32 + 1;
        if ( *(_BYTE *)(v33 + a2) != 123 )
        {
          sub_13937((void *)a1, 2, 0, 0LL, (__int64)"JSON data (missing top level yang:action object)", v11, v26);
          goto LABEL_100;
        }
        v31 = (unsigned __int64)sub_694B2(v33 + 1 + a2) + v33 + 1;
        v35 = 1;
      }
      else
      {
        v35 = -1;
      }
    }
    v36 = sub_6B929(
            a1,
            (_BYTE *)(v31 + a2),
            0LL,
            (char **)&v38,
            (__int64)v37,
            (__int64)j,
            (void **)&v40,
            v29,
            (__int64)ptr,
            &v39,
            v26);
    if ( !v36 )
      goto LABEL_100;
    v30 = v36 + v31;
    if ( v37 )
    {
      j = (char *)*((_QWORD *)v37 + 4);
    }
    else if ( i )
    {
      v37 = v38[8];
      if ( v38[8] )
        v13 = *((_QWORD *)v38[8] + 4);
      else
        v13 = 0LL;
      j = (char *)v13;
    }
    else
    {
      for ( j = (char *)v38; j && *(_QWORD *)(*((_QWORD *)j + 4) + 24LL); j = (char *)*((_QWORD *)j + 4) )
        ;
      v37 = j;
      if ( j
        && v29 & 0x20000
        && *(_QWORD *)(*(_QWORD *)j + 48LL) == *(_QWORD *)(*(_QWORD *)(a1 + 64)
                                                         + 8LL * *(unsigned __int8 *)(a1 + 132)
                                                         - 8) )
      {
        v29 &= 0xFFFDFFFF;
      }
      j = (char *)v38;
    }
    if ( !i )
      v38 = 0LL;
  }
  while ( *(_BYTE *)(v30 + a2) == 44 );
  if ( *(_BYTE *)(v30 + a2) != 125 )
  {
    sub_13937((void *)a1, 2, 0, 0LL, (__int64)"JSON data (missing top-level end-object)", v12, v26);
    goto LABEL_100;
  }
  v34 = (unsigned __int64)sub_694B2(v30 + 1 + a2) + v30 + 1;
  if ( v35 == 1 )
  {
    if ( *(_BYTE *)(v34 + a2) != 125 )
    {
      sub_13937((void *)a1, 2, 0, 0LL, (__int64)"JSON data (missing top-level end-object)", v15, v26);
      goto LABEL_100;
    }
    v16 = (unsigned __int64)sub_694B2(v34 + 1 + a2) + v34 + 1;
  }
  v17 = v40;
  if ( !(unsigned int)sub_6B4DE((_QWORD *)a1, v40, (__int64)v37, v29, v14, v15) )
  {
    if ( v43 )
      v37 = (char *)v43;
    if ( v37 )
    {
      if ( !(v29 & 0x30) || (v17 = &size + 1, !(unsigned int)lyd_schema_sort(v37, 1LL)) )
      {
        if ( v29 & 0x20 && *(_DWORD *)(*v28 + 56) != 256 )
        {
          v39 = i;
        }
        else if ( v29 & 0x50 && !v39 )
        {
          if ( v29 & 0x10 )
            v20 = "action";
          else
            v20 = "notification";
          sub_13937((void *)a1, 49, 3u, v37, (__int64)v20, **(_QWORD **)v37, v26);
          goto LABEL_100;
        }
        if ( v29 & 0x20000 && (v21 = ly_ctx_info(a1, v17), (unsigned int)lyd_merge(v37, v21, 1280LL)) )
        {
          sub_12222(a1, 0, 4, "Adding ietf-yang-library data failed.", v22, v23, v26);
        }
        else
        {
          for ( j = v37; j; j = (char *)*((_QWORD *)j + 3) )
          {
            if ( *(_DWORD *)(*(_QWORD *)j + 56LL) & 0x18
              && j[8] & 1
              && (unsigned int)sub_2EE3F((__int64)j, (__int64)v37) )
            {
              goto LABEL_100;
            }
          }
          if ( !(unsigned int)sub_BF7F8((char ***)&v37, v29, a1, 0LL, 0LL, v27, v39, (__int64)ptr, 1) )
          {
            if ( v29 & 0x2080
              || (!v39 ? (v25 = (__int64 *)v37) : (v25 = (__int64 *)v39),
                  !(unsigned int)sub_AD9B9(v25, a1, 0LL, 0, v29, v24)) )
            {
              free(*(void **)ptr);
              free(*((void **)ptr + 1));
              free(ptr);
              return (__int64)v37;
            }
          }
        }
        goto LABEL_100;
      }
    }
    else
    {
      sub_12222(a1, 0, 5, "Model for the data to be linked with not found.", v18, v19, v26);
    }
  }
LABEL_100:
  lyd_free_withsiblings(v37);
  if ( v43 && v43 != (char **)v37 )
    lyd_free_withsiblings(v43);
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
  return 0LL;
}
// 71D0: using guessed type __int64 __fastcall lyd_schema_sort(_QWORD, _QWORD);
// 7390: using guessed type __int64 __fastcall ly_ctx_info(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7880: using guessed type __int64 __fastcall lyd_dup(_QWORD, _QWORD);
// 78B0: using guessed type __int64 __fastcall lyd_validate(_QWORD, _QWORD, _QWORD);
// 7B50: using guessed type __int64 __fastcall lyd_merge(_QWORD, _QWORD, _QWORD);

//----- (000000000006DF5C) ----------------------------------------------------
__int64 __fastcall sub_6DF5C(__int64 a1)
{
  return a1;
}

//----- (000000000006DF6A) ----------------------------------------------------
__int64 __fastcall sub_6DF6A(__int64 a1, char *a2, size_t a3, __int64 a4)
{
  __int16 v4; // ST46_2
  __int64 v6; // [rsp+0h] [rbp-50h]
  size_t v7; // [rsp+8h] [rbp-48h]
  char *dest; // [rsp+10h] [rbp-40h]
  unsigned int v9; // [rsp+2Ch] [rbp-24h]
  signed int i; // [rsp+30h] [rbp-20h]
  int j; // [rsp+30h] [rbp-20h]
  signed int v12; // [rsp+34h] [rbp-1Ch]
  size_t n; // [rsp+38h] [rbp-18h]

  dest = a2;
  v7 = a3;
  v6 = a4;
  v9 = 0;
  if ( !a1 || !a4 )
    __assert_fail("data && lybs", "/home/mantovan/Repositories/libyang/src/parser_lyb.c", 0x35u, "lyb_read");
  while ( 1 )
  {
    n = v7;
    v12 = -1;
    for ( i = 0; i < *(_DWORD *)(v6 + 24); ++i )
    {
      if ( n >= *(_QWORD *)(8LL * i + *(_QWORD *)v6) && *(_QWORD *)(8LL * i + *(_QWORD *)(v6 + 8)) )
      {
        n = *(_QWORD *)(8LL * i + *(_QWORD *)v6);
        v12 = i;
      }
    }
    if ( v12 == -1 && !v7 )
      break;
    if ( n )
    {
      if ( dest )
        memcpy(dest, (const void *)((signed int)v9 + a1), n);
      for ( j = 0; j < *(_DWORD *)(v6 + 24); ++j )
      {
        *(_QWORD *)(8LL * j + *(_QWORD *)v6) -= n;
        if ( *(_QWORD *)(8LL * j + *(_QWORD *)v6) > 0xFFuLL )
          __assert_fail(
            "lybs->written[i] <= LYB_SIZE_MAX",
            "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
            0x52u,
            "lyb_read");
      }
      v7 -= n;
      if ( dest )
        dest += n;
      v9 += n;
    }
    if ( v12 >= 0 )
    {
      v4 = *(_WORD *)((signed int)v9 + a1);
      *(_QWORD *)(*(_QWORD *)v6 + 8LL * v12) = (unsigned __int8)v4;
      *(_BYTE *)(v12 + *(_QWORD *)(v6 + 16)) = HIBYTE(v4);
      *(_QWORD *)(*(_QWORD *)(v6 + 8) + 8LL * v12) = *(_QWORD *)(8LL * v12 + *(_QWORD *)v6) == 255LL;
      v9 += 2;
    }
  }
  return v9;
}

//----- (000000000006E1EC) ----------------------------------------------------
signed __int64 __fastcall sub_6E1EC(_WORD *a1, unsigned __int64 a2, size_t a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+8h] [rbp-48h]
  unsigned int v7; // [rsp+3Ch] [rbp-14h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v6 = a5;
  v9 = __readfsqword(0x28u);
  v8 = 0LL;
  v7 = sub_6DF6A(a4, (char *)&v8, a3, a5);
  if ( (v7 & 0x80000000) != 0 )
    return 0xFFFFFFFFLL;
  v8 = sub_6DF5C(v8);
  if ( a2 == 2 )
  {
    *a1 = v8;
  }
  else if ( a2 > 2 )
  {
    if ( a2 == 4 )
    {
      *(_DWORD *)a1 = v8;
    }
    else
    {
      if ( a2 != 8 )
        goto LABEL_14;
      *(_QWORD *)a1 = v8;
    }
  }
  else
  {
    if ( a2 != 1 )
    {
LABEL_14:
      sub_12222(
        *(_QWORD *)(v6 + 48),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_lyb.c",
        135LL);
      return 0xFFFFFFFFLL;
    }
    *(_BYTE *)a1 = v8;
  }
  return v7;
}

//----- (000000000006E321) ----------------------------------------------------
signed __int64 __fastcall sub_6E321(_WORD *a1, unsigned int a2, __int64 a3, __int64 a4)
{
  size_t v5; // [rsp+28h] [rbp-8h]

  if ( a2 > 0xFF )
  {
    if ( a2 > 0xFFFF )
    {
      if ( a2 > 0xFFFFFF )
        v5 = 4LL;
      else
        v5 = 3LL;
    }
    else
    {
      v5 = 2LL;
    }
  }
  else
  {
    v5 = 1LL;
  }
  *(_QWORD *)a1 = 0LL;
  return sub_6E1EC(a1, 8uLL, v5, a3, a4);
}

//----- (000000000006E3A6) ----------------------------------------------------
signed __int64 __fastcall sub_6E3A6(__int64 a1, void **a2, int a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v6; // r9
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  _BOOL4 v10; // [rsp+2Ch] [rbp-24h]
  int v11; // [rsp+30h] [rbp-20h]
  unsigned int v12; // [rsp+30h] [rbp-20h]
  int v13; // [rsp+34h] [rbp-1Ch]
  int v14; // [rsp+34h] [rbp-1Ch]
  int v15; // [rsp+34h] [rbp-1Ch]
  size_t v16; // [rsp+38h] [rbp-18h]
  size_t v17; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v8 = a1;
  v7 = a4;
  v18 = __readfsqword(0x28u);
  v10 = 0;
  v11 = 0;
  v16 = 0LL;
  if ( a3 )
  {
    v13 = sub_6E1EC(&v16, 8uLL, 2uLL, a1, a4);
    v11 = v13;
    if ( v13 < 0 )
    {
LABEL_16:
      free(*a2);
      *a2 = 0LL;
      return 0xFFFFFFFFLL;
    }
    v8 = v13 + a1;
  }
  else
  {
    v16 = *(_QWORD *)(*(_QWORD *)a4 + 8LL * *(signed int *)(a4 + 24) - 8);
    if ( *(_QWORD *)(*(_QWORD *)(a4 + 8) + 8LL * *(signed int *)(a4 + 24) - 8) )
      v10 = 1;
  }
  *a2 = malloc(v16 + 1);
  if ( !*a2 )
  {
    sub_12222(*(_QWORD *)(v7 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_read_string", v4, v7);
    return 0xFFFFFFFFLL;
  }
  v14 = sub_6DF6A(v8, (char *)*a2, v16, v7);
  v12 = v14 + v11;
  if ( v14 < 0 )
    goto LABEL_16;
  v9 = v14 + v8;
  while ( v10 )
  {
    v17 = *(_QWORD *)(*(_QWORD *)v7 + 8LL * *(signed int *)(v7 + 24) - 8);
    v10 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8LL * *(signed int *)(v7 + 24) - 8) != 0LL;
    *a2 = sub_C422(*a2, v16 + v17 + 1);
    if ( !*a2 )
    {
      sub_12222(*(_QWORD *)(v7 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_read_string", v6, v7);
      return 0xFFFFFFFFLL;
    }
    v15 = sub_6DF6A(v9, (char *)*a2 + v16, v17, v7);
    v12 += v15;
    if ( v15 < 0 )
      goto LABEL_16;
    v9 += v15;
    v16 += v17;
  }
  *((_BYTE *)*a2 + v16) = 0;
  return v12;
}

//----- (000000000006E67A) ----------------------------------------------------
__int64 __fastcall sub_6E67A(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL * *(signed int *)(a1 + 24) - 8) )
    sub_12222(
      *(_QWORD *)(a1 + 48),
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser_lyb.c",
      215LL);
  result = a1;
  --*(_DWORD *)(a1 + 24);
  return result;
}

//----- (000000000006E6F0) ----------------------------------------------------
signed __int64 __fastcall sub_6E6F0(__int16 *a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 result; // rax
  __int16 v4; // ST16_2

  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 28)
    || (*(_DWORD *)(a2 + 28) += 4,
        *(_QWORD *)a2 = sub_C422(*(void **)a2, 8LL * *(signed int *)(a2 + 28)),
        *(_QWORD *)(a2 + 8) = sub_C422(*(void **)(a2 + 8), 8LL * *(signed int *)(a2 + 28)),
        *(_QWORD *)(a2 + 16) = sub_C422(*(void **)(a2 + 16), *(signed int *)(a2 + 28)),
        *(_QWORD *)a2)
    && *(_QWORD *)(a2 + 8)
    && *(_QWORD *)(a2 + 16) )
  {
    v4 = *a1;
    *(_QWORD *)(8LL * (signed int)++*(_DWORD *)(a2 + 24) - 8 + *(_QWORD *)a2) = (unsigned __int8)v4;
    *(_BYTE *)(*(signed int *)(a2 + 24) - 1LL + *(_QWORD *)(a2 + 16)) = HIBYTE(v4);
    *(_QWORD *)(8LL * *(signed int *)(a2 + 24) - 8 + *(_QWORD *)(a2 + 8)) = *(_QWORD *)(*(_QWORD *)a2
                                                                                      + 8LL * *(signed int *)(a2 + 24)
                                                                                      - 8) == 255LL;
    result = 2LL;
  }
  else
  {
    sub_12222(*(_QWORD *)(a2 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_read_start_subtree", v2, a2);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000006E8DA) ----------------------------------------------------
signed __int64 __fastcall sub_6E8DA(__int64 a1, __int64 a2, __int64 a3)
{
  char *v3; // rax
  const char *v4; // rdx
  char *v5; // rax
  const char *v6; // rdx
  __int64 v8; // [rsp+8h] [rbp-48h]
  unsigned __int16 v9; // [rsp+26h] [rbp-2Ah]
  unsigned int v10; // [rsp+28h] [rbp-28h]
  signed int v11[4]; // [rsp+2Ch] [rbp-24h]
  char s; // [rsp+3Dh] [rbp-13h]
  unsigned __int64 v13; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v13 = __readfsqword(0x28u);
  *(_QWORD *)&v11[1] = 0LL;
  *(_QWORD *)v11 = (unsigned int)sub_6E3A6(a1, (void **)&v11[1], 1, a3);
  v10 = v11[0];
  if ( v11[0] >= 0 )
  {
    v11[0] = sub_6E1EC(&v9, 2uLL, 2uLL, v11[0] + a1, v8);
    v10 += v11[0];
    if ( v11[0] >= 0 )
    {
      if ( v9 )
      {
        sprintf(&s, "%04u-%02u-%02u", (unsigned int)(v9 >> 9) + 2000, ((signed int)v9 >> 5) & 0xF, v9 & 0x1F);
        *(_QWORD *)a2 = ly_ctx_get_module(*(_QWORD *)(v8 + 48), *(_QWORD *)&v11[1], &s, 0LL);
      }
      else
      {
        *(_QWORD *)a2 = ly_ctx_get_module(*(_QWORD *)(v8 + 48), *(_QWORD *)&v11[1], 0LL, 0LL);
      }
      if ( *(_QWORD *)(*(_QWORD *)(v8 + 48) + 112LL) )
      {
        if ( *(_QWORD *)a2 )
        {
          if ( *(_BYTE *)(*(_QWORD *)a2 + 64LL) >= 0 )
            *(_QWORD *)a2 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, signed __int64, _QWORD))(*(_QWORD *)(v8 + 48) + 112LL))(
                              *(_QWORD *)(v8 + 48),
                              *(_QWORD *)&v11[1],
                              *(_QWORD *)(*(_QWORD *)a2 + 176LL),
                              1LL,
                              *(_QWORD *)(*(_QWORD *)(v8 + 48) + 120LL));
        }
        else
        {
          *(_QWORD *)a2 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v8 + 48)
                                                                                            + 112LL))(
                            *(_QWORD *)(v8 + 48),
                            *(_QWORD *)&v11[1],
                            0LL,
                            0LL,
                            *(_QWORD *)(*(_QWORD *)(v8 + 48) + 120LL));
        }
      }
      if ( *(_QWORD *)a2 )
      {
        if ( *(_BYTE *)(*(_QWORD *)a2 + 64LL) < 0 )
        {
          free(*(void **)&v11[1]);
          return v10;
        }
        if ( v9 )
          v5 = &s;
        else
          v5 = (char *)&unk_111298;
        if ( v9 )
          v6 = "@";
        else
          v6 = (const char *)&unk_111298;
        sub_12222(
          *(_QWORD *)(v8 + 48),
          0,
          3,
          "Invalid context for LYB data parsing, module \"%s%s%s\" not implemented.",
          *(__int64 *)&v11[1],
          (__int64)v6,
          v5);
      }
      else
      {
        if ( v9 )
          v3 = &s;
        else
          v3 = (char *)&unk_111298;
        if ( v9 )
          v4 = "@";
        else
          v4 = (const char *)&unk_111298;
        sub_12222(
          *(_QWORD *)(v8 + 48),
          0,
          3,
          "Invalid context for LYB data parsing, missing module \"%s%s%s\".",
          *(__int64 *)&v11[1],
          (__int64)v4,
          v3);
      }
    }
  }
  free(*(void **)&v11[1]);
  return 0xFFFFFFFFLL;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006EC05) ----------------------------------------------------
_BYTE *__fastcall sub_6EC05(__int64 a1)
{
  unsigned int v1; // eax
  __int64 v2; // r9
  _BYTE *result; // rax
  _BYTE *v4; // [rsp+18h] [rbp-8h]

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 != 32 )
  {
    if ( v1 <= 0x20 )
    {
      if ( v1 == 4 )
        goto LABEL_29;
      if ( v1 <= 4 )
      {
        if ( v1 != 1 )
          return 0LL;
        goto LABEL_17;
      }
      if ( v1 == 8 )
      {
LABEL_29:
        v4 = calloc(0x50uLL, 1uLL);
        if ( *(_DWORD *)(a1 + 128) == 9 )
          v4[8] |= 8u;
        goto LABEL_22;
      }
      if ( v1 != 16 )
        return 0LL;
      goto LABEL_17;
    }
    if ( v1 == 256 )
      goto LABEL_17;
    if ( v1 <= 0x100 )
    {
      if ( v1 != 128 )
        return 0LL;
      goto LABEL_17;
    }
    if ( v1 == 0x4000 )
    {
LABEL_17:
      v4 = calloc(0x48uLL, 1uLL);
      goto LABEL_22;
    }
    if ( v1 != 32800 )
      return 0LL;
  }
  v4 = calloc(0x40uLL, 1uLL);
LABEL_22:
  if ( v4 )
  {
    *(_QWORD *)v4 = a1;
    if ( (unsigned int)sub_28290(a1, 0, 0LL) )
      v4[9] = v4[9] & 0xF1 | 0xC;
    *((_QWORD *)v4 + 4) = v4;
    result = v4;
  }
  else
  {
    sub_12222(**(_QWORD **)(a1 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_new_node", v2);
    result = 0LL;
  }
  return result;
}

//----- (000000000006ED63) ----------------------------------------------------
signed __int64 __fastcall sub_6ED63(char *a1, __int64 a2, __int64 a3)
{
  int v4; // ST24_4
  int v5; // ST24_4
  __int64 v6; // rax
  __int64 v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+10h] [rbp-30h]
  int v9; // [rsp+20h] [rbp-20h]
  unsigned int v10; // [rsp+20h] [rbp-20h]
  int v11; // [rsp+24h] [rbp-1Ch]
  __int64 v12; // [rsp+28h] [rbp-18h]
  char *v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v14 = __readfsqword(0x28u);
  v12 = 0LL;
  v13 = a1;
  v11 = sub_6DF6A(a2, a1 + 52, 4uLL, a3);
  v9 = v11;
  if ( v11 < 0 )
    return 0xFFFFFFFFLL;
  v8 = v11 + a2;
  if ( *((_DWORD *)v13 + 13) == 16 )
  {
    sub_12222(
      **(_QWORD **)(*(_QWORD *)a1 + 48LL),
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser_lyb.c",
      346LL);
    return 0xFFFFFFFFLL;
  }
  if ( *((_DWORD *)v13 + 13) == 32 )
  {
    v4 = sub_6E3A6(v8, (void **)v13 + 7, 0, v7);
    v10 = v4 + v9;
    if ( v4 < 0 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v5 = sub_6E3A6(v8, (void **)&v12, 0, v7);
    v10 = v5 + v9;
    if ( v5 < 0 )
      return 0xFFFFFFFFLL;
    v6 = lydict_insert_zc(**(_QWORD **)(*(_QWORD *)a1 + 48LL), v12);
    *((_QWORD *)v13 + 7) = v6;
  }
  return v10;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000006EEF7) ----------------------------------------------------
signed __int64 __fastcall sub_6EEF7(signed __int64 a1, unsigned int a2, char a3, __int64 a4, _QWORD *a5, _WORD *a6, __int64 a7)
{
  signed __int64 result; // rax
  __int64 v8; // r9
  _QWORD *v9; // [rsp+8h] [rbp-58h]
  _QWORD *v10; // [rsp+10h] [rbp-50h]
  __int64 v11; // [rsp+18h] [rbp-48h]
  signed __int64 v12; // [rsp+28h] [rbp-38h]
  unsigned __int8 v13; // [rsp+37h] [rbp-29h]
  int v14; // [rsp+38h] [rbp-28h]
  int v15; // [rsp+3Ch] [rbp-24h]
  __int64 v16; // [rsp+40h] [rbp-20h]
  unsigned __int64 v17; // [rsp+48h] [rbp-18h]
  unsigned __int64 v18; // [rsp+50h] [rbp-10h]
  unsigned __int64 v19; // [rsp+58h] [rbp-8h]

  v12 = a1;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v19 = __readfsqword(0x28u);
  v16 = 0LL;
  if ( a3 & 2 )
  {
    v14 = sub_6E3A6(a4, (void **)&v16, 0, a7);
    if ( v14 >= 0 )
      *v10 = lydict_insert_zc(*(_QWORD *)(a7 + 48), v16);
    result = (unsigned int)v14;
  }
  else
  {
    if ( a2 == 2 )
    {
      while ( *(_DWORD *)v12 == 9 )
        v12 = *(_QWORD *)(v12 + 40) + 128LL;
      while ( !*(_DWORD *)(v12 + 40) )
        v12 = *(_QWORD *)(v12 + 16) + 56LL;
    }
    else if ( a2 == 6 )
    {
      while ( *(_DWORD *)v12 == 9 )
        v12 = *(_QWORD *)(v12 + 40) + 128LL;
      while ( !*(_DWORD *)(v12 + 40) )
        v12 = *(_QWORD *)(v12 + 16) + 56LL;
    }
    switch ( (unsigned __int64)a2 )
    {
      case 1uLL:
      case 0xAuLL:
      case 0x14uLL:
        v14 = sub_6E3A6(a4, (void **)&v16, 0, a7);
        if ( v14 >= 0 )
          *v9 = lydict_insert_zc(*(_QWORD *)(a7 + 48), v16);
        goto LABEL_48;
      case 2uLL:
        *(_QWORD *)a6 = calloc(*(unsigned int *)(v12 + 40), 8uLL);
        if ( !*v9 )
        {
          sub_12222(*(_QWORD *)(a7 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_parse_val_1", v8, a7);
          return 0xFFFFFFFFLL;
        }
        v14 = 0;
        v18 = 0LL;
        break;
      case 3uLL:
        v14 = sub_6DF6A(a4, (char *)&v13, 1uLL, a7);
        if ( v14 > 0 && v13 )
          *(_BYTE *)v9 = 1;
        goto LABEL_48;
      case 4uLL:
      case 0x12uLL:
      case 0x13uLL:
        v14 = sub_6E1EC(a6, 8uLL, 8uLL, a4, a7);
        goto LABEL_48;
      case 5uLL:
        v14 = 0;
        goto LABEL_48;
      case 6uLL:
        v17 = 0LL;
        v14 = sub_6E321(&v17, *(_DWORD *)(v12 + 40), a4, a7);
        if ( v14 > 0 )
        {
          if ( *(unsigned int *)(v12 + 40) <= v17 )
            __assert_fail(
              "num < type->info.enums.count",
              "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
              0x1C3u,
              "lyb_parse_val_1");
          *v9 = *(_QWORD *)(v12 + 32) + 48 * v17;
        }
        goto LABEL_48;
      case 7uLL:
      case 8uLL:
      case 0xBuLL:
        v14 = sub_6E3A6(a4, (void **)&v16, 0, a7);
        if ( v14 >= 0 )
          *v10 = lydict_insert_zc(*(_QWORD *)(a7 + 48), v16);
        goto LABEL_48;
      case 0xCuLL:
      case 0xDuLL:
        v14 = sub_6E1EC(a6, 1uLL, 1uLL, a4, a7);
        goto LABEL_48;
      case 0xEuLL:
      case 0xFuLL:
        v14 = sub_6E1EC(a6, 2uLL, 2uLL, a4, a7);
        goto LABEL_48;
      case 0x10uLL:
      case 0x11uLL:
        v14 = sub_6E1EC(a6, 4uLL, 4uLL, a4, a7);
        goto LABEL_48;
      default:
        return 0xFFFFFFFFLL;
    }
    while ( v18 < *(unsigned int *)(v12 + 40) )
    {
      if ( !(v18 & 7) )
      {
        v15 = sub_6DF6A(v14 + v11, (char *)&v13, 1uLL, a7);
        v14 += v15;
        if ( v15 < 0 )
          return 0xFFFFFFFFLL;
      }
      if ( ((signed int)v13 >> (v18 & 7)) & 1 )
        *(_QWORD *)(8 * v18 + *v9) = *(_QWORD *)(v12 + 32) + 48 * v18;
      ++v18;
    }
LABEL_48:
    result = (unsigned int)v14;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000006F3B4) ----------------------------------------------------
signed __int64 __fastcall sub_6F3B4(signed __int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // r9
  signed __int64 result; // rax
  int v7; // edi
  __int64 v8; // r9
  size_t v9; // rax
  __int64 v10; // r9
  const char *v11; // rax
  const char *v12; // rax
  const char *v13; // rax
  __int64 v14; // [rsp+0h] [rbp-B0h]
  __int64 v15; // [rsp+8h] [rbp-A8h]
  _DWORD *v16; // [rsp+18h] [rbp-98h]
  unsigned __int8 v17; // [rsp+2Bh] [rbp-85h]
  unsigned int v18; // [rsp+2Ch] [rbp-84h]
  unsigned int v19; // [rsp+30h] [rbp-80h]
  unsigned int v20; // [rsp+34h] [rbp-7Ch]
  __int64 v21; // [rsp+38h] [rbp-78h]
  __int64 *v22; // [rsp+40h] [rbp-70h]
  signed __int64 i; // [rsp+48h] [rbp-68h]
  _BYTE *v24; // [rsp+50h] [rbp-60h]
  signed __int64 v25; // [rsp+58h] [rbp-58h]
  _BYTE *v26; // [rsp+60h] [rbp-50h]
  char **v27; // [rsp+68h] [rbp-48h]
  unsigned int *v28; // [rsp+70h] [rbp-40h]
  __int64 v29; // [rsp+78h] [rbp-38h]
  char s; // [rsp+80h] [rbp-30h]
  unsigned __int64 v31; // [rsp+98h] [rbp-18h]

  v16 = (_DWORD *)a1;
  v15 = a3;
  v14 = a4;
  v31 = __readfsqword(0x28u);
  i = 0LL;
  if ( a2 )
  {
    v21 = **(_QWORD **)(*a2 + 48LL);
    v22 = (__int64 *)lys_node_module(*a2);
    v28 = (unsigned int *)(a2 + 8);
    v27 = (char **)(a2 + 7);
    v26 = (char *)a2 + 76;
    v20 = *((_DWORD *)a2 + 18);
  }
  else
  {
    v21 = **(_QWORD **)(*(_QWORD *)(a3 + 16) + 48LL);
    v22 = (__int64 *)lys_main_module(*(_QWORD *)(*(_QWORD *)(a3 + 16) + 48LL));
    v28 = (unsigned int *)(v15 + 40);
    v27 = (char **)(v15 + 32);
    v26 = (_BYTE *)(v15 + 52);
    v20 = *(_DWORD *)(v15 + 48);
  }
  if ( *v26 & 2 )
  {
    *v26 &= 0xFDu;
    if ( a2 )
      v4 = *((_BYTE *)a2 + 9) & 1;
    else
      v4 = 0;
    if ( sub_37EF5(a1, v27, 0LL, (__int64 **)a2, v15, 0LL, 1, v4, 1) )
    {
      if ( !(*v26 & 2) )
        sub_12222(
          v21,
          1u,
          0,
          "Value \"%s\" was stored as a user type, but it is not in the current context.",
          (__int64)v27,
          v5,
          v14);
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( (*(_DWORD *)a1 == 9 || *(_DWORD *)a1 == 8 || *(_DWORD *)a1 == 11 && *(_DWORD *)(a1 + 44))
      && (v20 == 8 || v20 == 7 || v20 == 11) )
    {
LABEL_87:
      if ( !*v27 )
        __assert_fail("*value_str", "/home/mantovan/Repositories/libyang/src/parser_lyb.c", 0x295u, "lyb_parse_val_2");
      if ( v15 )
      {
        sub_12222(
          v21,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser_lyb.c",
          665LL,
          v14);
        return 0xFFFFFFFFLL;
      }
      if ( *v16 == 8 )
      {
        if ( (unsigned int)sub_2CD1C(v14, (__int64)a2, (unsigned __int64)&loc_100000) )
          return 0xFFFFFFFFLL;
      }
      else if ( *v16 == 9 )
      {
        if ( (unsigned int)sub_2CD1C(v14, (__int64)a2, 0x80000) )
          return 0xFFFFFFFFLL;
      }
      else if ( (unsigned int)sub_2CD1C(v14, (__int64)a2, 0x1000000) )
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if ( v20 == 2 )
      {
        for ( i = a1; *(_DWORD *)i == 9; i = *(_QWORD *)(i + 40) + 128LL )
          ;
        while ( !*(_DWORD *)(i + 40) )
          i = *(_QWORD *)(i + 16) + 56LL;
      }
      else if ( v20 == 4 )
      {
        for ( i = a1; *(_DWORD *)i == 9; i = *(_QWORD *)(a1 + 40) + 128LL )
          ;
      }
      switch ( (unsigned __int64)v20 )
      {
        case 1uLL:
        case 0xAuLL:
        case 0x14uLL:
          *v27 = *(char **)v28;
          goto LABEL_83;
        case 2uLL:
          v24 = malloc(1uLL);
          if ( !v24 )
          {
            sub_12222(v21, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_parse_val_2", v8, v14);
            return 0xFFFFFFFFLL;
          }
          *v24 = 0;
          v19 = 0;
          v18 = 0;
          while ( 2 )
          {
            if ( v18 < *(_DWORD *)(i + 40) )
            {
              if ( *(_QWORD *)(8LL * v18 + *(_QWORD *)v28) )
              {
                v9 = v19 + strlen(**(const char ***)(8LL * v18 + *(_QWORD *)v28));
                v24 = sub_C422(v24, (v19 != 0) + v9 + 1);
                if ( !v24 )
                {
                  sub_12222(v21, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_parse_val_2", v10, v14);
                  return 0xFFFFFFFFLL;
                }
                if ( v19 )
                  v11 = " ";
                else
                  v11 = (const char *)&unk_111298;
                v19 += sprintf(&v24[v19], "%s%s", v11, **(_QWORD **)(8LL * v18 + *(_QWORD *)v28));
              }
              ++v18;
              continue;
            }
            break;
          }
          *v27 = (char *)lydict_insert_zc(v21, v24);
LABEL_83:
          if ( *v16 == 9 || *v16 == 8 || *v16 == 11 && v16[11] )
            goto LABEL_87;
          break;
        case 3uLL:
          if ( *(_BYTE *)v28 )
            v12 = "true";
          else
            v12 = "false";
          *v27 = (char *)lydict_insert(v21, v12, 0LL);
          goto LABEL_83;
        case 4uLL:
          v29 = *(_QWORD *)v28 / *(_QWORD *)(i + 48);
          v25 = *(_QWORD *)v28 % *(_QWORD *)(i + 48);
          v17 = *(_BYTE *)(i + 40);
          if ( v25 < 0 )
            v25 = -v25;
          while ( v17 > 1u
               && v25 == 10
                       * (((signed __int64)((unsigned __int128)(7378697629483820647LL * (signed __int128)v25) >> 64) >> 2)
                        - (v25 >> 63)) )
          {
            v25 = ((signed __int64)((unsigned __int128)(7378697629483820647LL * (signed __int128)v25) >> 64) >> 2)
                - (v25 >> 63);
            --v17;
          }
          if ( v29 || *(_QWORD *)v28 >= 0 )
            v13 = (const char *)&unk_111298;
          else
            v13 = "-";
          sprintf(&s, "%s%ld.%.*ld", v13, v29, v17, v25, v14);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 5uLL:
          *v27 = (char *)lydict_insert(v21, &unk_111298, 0LL);
          goto LABEL_83;
        case 6uLL:
          *v27 = (char *)lydict_insert(v21, **(_QWORD **)v28, 0LL);
          goto LABEL_83;
        case 7uLL:
          if ( a2 )
            v7 = *((_BYTE *)a2 + 9) & 1;
          else
            v7 = 0;
          *(_QWORD *)v28 = sub_26148((signed __int64)v16, *v27, (char *)a2, v22, v7);
          if ( *(_QWORD *)v28 )
            goto LABEL_83;
          return 0xFFFFFFFFLL;
        case 8uLL:
          *(_QWORD *)v28 = 0LL;
          goto LABEL_83;
        case 0xBuLL:
          if ( v15 )
          {
            sub_12222(
              v21,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/parser_lyb.c",
              592LL,
              v14);
            return 0xFFFFFFFFLL;
          }
          if ( !(unsigned int)sub_2C282((__int64)a2, (_DWORD *)a1, 1, 2, 0LL) )
            goto LABEL_83;
          return 0xFFFFFFFFLL;
        case 0xCuLL:
          sprintf(&s, "%d", (unsigned int)*(char *)v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0xDuLL:
          sprintf(&s, "%u", *(unsigned __int8 *)v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0xEuLL:
          sprintf(&s, "%d", (unsigned int)*(signed __int16 *)v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0xFuLL:
          sprintf(&s, "%u", *(unsigned __int16 *)v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0x10uLL:
          sprintf(&s, "%d", *v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0x11uLL:
          sprintf(&s, "%u", *v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0x12uLL:
          sprintf(&s, "%ld", *(_QWORD *)v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        case 0x13uLL:
          sprintf(&s, "%lu", *(_QWORD *)v28);
          *v27 = (char *)lydict_insert(v21, &s, 0LL);
          goto LABEL_83;
        default:
          return 0xFFFFFFFFLL;
      }
    }
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000006FED3) ----------------------------------------------------
signed __int64 __fastcall sub_6FED3(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-70h]
  __int64 v8; // [rsp+8h] [rbp-68h]
  __int64 v9; // [rsp+10h] [rbp-60h]
  __int64 v10; // [rsp+10h] [rbp-60h]
  __int64 v11; // [rsp+18h] [rbp-58h]
  char v12; // [rsp+3Fh] [rbp-31h]
  unsigned int v13; // [rsp+40h] [rbp-30h]
  int v14; // [rsp+44h] [rbp-2Ch]
  _QWORD *v15; // [rsp+48h] [rbp-28h]
  _WORD *v16; // [rsp+50h] [rbp-20h]
  unsigned int *v17; // [rsp+58h] [rbp-18h]
  char *v18; // [rsp+60h] [rbp-10h]
  unsigned __int64 v19; // [rsp+68h] [rbp-8h]

  v11 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v19 = __readfsqword(0x28u);
  v13 = 0;
  if ( !a2 && !a3 || a2 && a3 )
    __assert_fail(
      "(leaf || attr) && (!leaf || !attr)",
      "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
      0x2BBu,
      "lyb_parse_value");
  if ( a2 )
  {
    v15 = (_QWORD *)(a2 + 56);
    v16 = (_WORD *)(a2 + 64);
    v17 = (unsigned int *)(a2 + 72);
    v18 = (char *)(a2 + 76);
  }
  else
  {
    v15 = (_QWORD *)(a3 + 32);
    v16 = (_WORD *)(a3 + 40);
    v17 = (unsigned int *)(a3 + 48);
    v18 = (char *)(a3 + 52);
  }
  v14 = sub_6DF6A(a4, &v12, 1uLL, a6);
  v13 += v14;
  if ( v14 < 0 )
    return 0xFFFFFFFFLL;
  v10 = v14 + v9;
  *v17 = v12 & 0x1F;
  if ( v12 < 0 )
  {
    if ( !a2 )
      __assert_fail("leaf", "/home/mantovan/Repositories/libyang/src/parser_lyb.c", 0x2D0u, "lyb_parse_value");
    *(_BYTE *)(a2 + 9) |= 1u;
  }
  if ( v12 & 0x40 )
    *v18 |= 2u;
  if ( v12 & 0x20 )
    *v18 |= 1u;
  v14 = sub_6EEF7((signed __int64)a1, *v17, *v18, v10, v15, v16, v7);
  v13 += v14;
  if ( v14 < 0 )
    return 0xFFFFFFFFLL;
  if ( *a1 == 11 && !(*v18 & 2) )
  {
    if ( *v17 != 10 )
      __assert_fail(
        "*value_type == LY_TYPE_STRING",
        "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
        0x2DFu,
        "lyb_parse_value");
    *v15 = *(_QWORD *)v16;
    *(_QWORD *)v16 = 0LL;
    *v17 = 11;
  }
  v14 = sub_6F3B4((signed __int64)a1, (_QWORD *)a2, v11, v8);
  v13 += v14;
  if ( v14 >= 0 )
    result = v13;
  else
    result = 0xFFFFFFFFLL;
  return result;
}

//----- (000000000007018E) ----------------------------------------------------
signed __int64 __fastcall sub_7018E(__int64 a1, __int64 a2, _QWORD *a3, __int16 a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // rax
  __int16 v7; // [rsp+14h] [rbp-4Ch]
  _QWORD *v8; // [rsp+18h] [rbp-48h]
  int v9; // [rsp+30h] [rbp-30h]
  signed int i; // [rsp+34h] [rbp-2Ch]
  signed int k; // [rsp+34h] [rbp-2Ch]
  signed int j; // [rsp+38h] [rbp-28h]
  unsigned int v13; // [rsp+40h] [rbp-20h]
  int v14; // [rsp+44h] [rbp-1Ch]
  int v15; // [rsp+44h] [rbp-1Ch]
  void *ptr; // [rsp+48h] [rbp-18h]
  __int64 v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v18 = __readfsqword(0x28u);
  v17 = 0LL;
  ptr = 0LL;
  v13 = sub_6E3A6(a2, &ptr, 1, a5);
  if ( (v13 & 0x80000000) != 0 )
    return 0xFFFFFFFFLL;
  v9 = -1;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 80); i += v14 + 1 )
  {
    v14 = lys_ext_instance_presence(
            *(_QWORD *)(**(_QWORD **)(*(_QWORD *)a1 + 64LL) + 152LL),
            *(_QWORD *)(a1 + 160) + 8LL * i,
            (unsigned __int8)(*(_BYTE *)(a1 + 80) - i));
    if ( v14 == -1 )
      break;
    if ( (unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(8LL * (i + v14) + *(_QWORD *)(a1 + 160)) + 16LL), ptr) )
    {
      v9 = i + v14;
      break;
    }
  }
  if ( v9 == -1 )
  {
    for ( j = 0; j < *(unsigned __int8 *)(a1 + 70); ++j )
    {
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * j);
      for ( k = 0; k < *(unsigned __int8 *)(v17 + 80); k += v15 + 1 )
      {
        v15 = lys_ext_instance_presence(
                *(_QWORD *)(**(_QWORD **)(*(_QWORD *)a1 + 64LL) + 152LL),
                *(_QWORD *)(v17 + 160) + 8LL * k,
                (unsigned __int8)(*(_BYTE *)(v17 + 80) - k));
        if ( v15 == -1 )
          break;
        if ( (unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(8LL * (k + v15) + *(_QWORD *)(v17 + 160)) + 16LL), ptr) )
        {
          v9 = k + v15;
          break;
        }
      }
    }
  }
  if ( v9 == -1 )
  {
    *v8 = 0LL;
  }
  else
  {
    if ( v17 )
      v6 = *(_QWORD *)(v17 + 160);
    else
      v6 = *(_QWORD *)(a1 + 160);
    *v8 = *(_QWORD *)(8LL * v9 + v6);
  }
  if ( *v8 || !(v7 & 0x200) )
  {
    free(ptr);
    result = v13;
  }
  else
  {
    sub_13937(
      *(void **)a1,
      -1,
      0,
      0LL,
      (__int64)"Failed to find annotation \"%s\" in \"%s\".",
      (__int64)ptr,
      *(_QWORD *)(a1 + 8));
    free(ptr);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 72B0: using guessed type __int64 __fastcall lys_ext_instance_presence(_QWORD, _QWORD, _QWORD);

//----- (00000000000704EC) ----------------------------------------------------
signed __int64 __fastcall sub_704EC(__int64 a1, __int64 a2, __int16 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v9; // [rsp+8h] [rbp-68h]
  __int64 v10; // [rsp+10h] [rbp-60h]
  __int16 v11; // [rsp+1Ch] [rbp-54h]
  __int16 *v12; // [rsp+20h] [rbp-50h]
  __int64 v13; // [rsp+20h] [rbp-50h]
  unsigned __int8 v14; // [rsp+3Eh] [rbp-32h]
  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]
  unsigned int v16; // [rsp+40h] [rbp-30h]
  int v17; // [rsp+44h] [rbp-2Ch]
  __int64 v18; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  _QWORD *v20; // [rsp+58h] [rbp-18h]
  _DWORD **v21; // [rsp+60h] [rbp-10h]
  unsigned __int64 v22; // [rsp+68h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v22 = __readfsqword(0x28u);
  v16 = 0;
  v14 = 0;
  v20 = 0LL;
  v17 = sub_6DF6A(a2, (char *)&v14, 1uLL, a5);
  v16 += v17;
  if ( v17 >= 0 )
  {
    v12 = (__int16 *)(v17 + a2);
    for ( i = 0; ; ++i )
    {
      if ( i >= v14 )
        return v16;
      v17 = sub_6E6F0(v12, v9);
      v16 += v17;
      if ( v17 < 0 )
        goto LABEL_29;
      v13 = (__int64)v12 + v17;
      v17 = sub_6E8DA(v13, (__int64)&v18, v9);
      v16 += v17;
      if ( v17 < 0 )
        goto LABEL_29;
      v12 = (__int16 *)(v17 + v13);
      if ( v18 )
      {
        v17 = sub_7018E(v18, (__int64)v12, &v19, v11, v9);
        v16 += v17;
        if ( v17 < 0 )
          goto LABEL_29;
        v12 = (__int16 *)((char *)v12 + v17);
      }
      if ( !v18 || !v19 )
        break;
      if ( v20 )
      {
        v20[1] = calloc(1uLL, 0x38uLL);
        if ( !v20[1] )
        {
          sub_12222(*(_QWORD *)(v9 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_parse_attributes", v6);
          goto LABEL_29;
        }
        v20 = (_QWORD *)v20[1];
      }
      else
      {
        if ( *(_QWORD *)(a1 + 16) )
          __assert_fail(
            "!node->attr",
            "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
            0x34Eu,
            "lyb_parse_attributes");
        v20 = calloc(1uLL, 0x38uLL);
        if ( !v20 )
        {
          sub_12222(*(_QWORD *)(v9 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_parse_attributes", v5);
          goto LABEL_29;
        }
        *(_QWORD *)(a1 + 16) = v20;
      }
      v20[2] = v19;
      v7 = lydict_insert(*(_QWORD *)(v9 + 48), *(_QWORD *)(v20[2] + 16LL), 0LL);
      v20[3] = v7;
      v21 = (_DWORD **)lys_ext_complex_get_substmt(48LL, v20[2], 0LL);
      if ( !v21 )
        goto LABEL_29;
      if ( !*v21 )
        goto LABEL_29;
      v17 = sub_6FED3(*v21, 0LL, (__int64)v20, (__int64)v12, v10, v9);
      v16 += v17;
      if ( v17 < 0 )
        goto LABEL_29;
      v12 = (__int16 *)((char *)v12 + v17);
LABEL_26:
      sub_6E67A(v9);
    }
    while ( 1 )
    {
      v17 = sub_6DF6A((__int64)v12, 0LL, *(_QWORD *)(*(_QWORD *)v9 + 8LL * *(signed int *)(v9 + 24) - 8), v9);
      v16 += v17;
      if ( v17 < 0 )
        break;
      v12 = (__int16 *)((char *)v12 + v17);
      if ( !*(_QWORD *)(*(_QWORD *)v9 + 8LL * *(signed int *)(v9 + 24) - 8) )
        goto LABEL_26;
    }
  }
LABEL_29:
  lyd_free_attr(*(_QWORD *)(v9 + 48), a1, *(_QWORD *)(a1 + 16), 1LL);
  return 0xFFFFFFFFLL;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 74E0: using guessed type __int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000708AD) ----------------------------------------------------
signed __int64 __fastcall sub_708AD(const char **a1, __int64 a2, unsigned __int8 a3)
{
  unsigned __int8 v4; // [rsp+Ch] [rbp-24h]
  unsigned __int8 i; // [rsp+2Eh] [rbp-2h]

  v4 = a3;
  for ( i = 0; i < v4; ++i )
  {
    if ( (unsigned __int8)sub_C5A1(a1, i) != *(_BYTE *)(i + a2) )
      return 0LL;
  }
  return 1LL;
}

//----- (000000000007090B) ----------------------------------------------------
signed __int64 __fastcall sub_7090B(__int64 a1, __int64 a2, __int64 a3, char *a4, int a5, const char ***a6, __int64 a7)
{
  int v8; // eax
  __int64 k; // rax
  __int64 l; // rax
  const char ***v11; // [rsp+10h] [rbp-60h]
  int v12; // [rsp+1Ch] [rbp-54h]
  char *s; // [rsp+20h] [rbp-50h]
  __int64 v14; // [rsp+28h] [rbp-48h]
  __int64 v15; // [rsp+28h] [rbp-48h]
  __int64 v16; // [rsp+38h] [rbp-38h]
  unsigned __int8 i; // [rsp+4Eh] [rbp-22h]
  unsigned __int8 j; // [rsp+4Fh] [rbp-21h]
  unsigned int v19; // [rsp+50h] [rbp-20h]
  int v20; // [rsp+54h] [rbp-1Ch]
  int v21; // [rsp+54h] [rbp-1Ch]
  const char **v22; // [rsp+58h] [rbp-18h]
  char v23[7]; // [rsp+61h] [rbp-Fh]
  unsigned __int64 v24; // [rsp+68h] [rbp-8h]

  v16 = a1;
  v14 = a3;
  s = a4;
  v12 = a5;
  v11 = a6;
  v24 = __readfsqword(0x28u);
  if ( !a1 && !a2 || a1 && a2 )
    __assert_fail(
      "(sparent || mod) && (!sparent || !mod)",
      "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
      0x390u,
      "lyb_parse_schema_hash");
  v20 = sub_6DF6A(a3, v23, 1uLL, a7);
  v19 = v20;
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  v15 = v20 + v14;
  for ( i = 0; !((unsigned __int8)v23[0] & (128 >> i)); ++i )
  {
    if ( i > 8u )
      return 0xFFFFFFFFLL;
  }
  v23[i] = v23[0];
  for ( j = i; j; --j )
  {
    v21 = sub_6DF6A(v15, &v23[j - 1], 1uLL, a7);
    v19 += v21;
    if ( v21 < 0 )
      return 0xFFFFFFFFLL;
    v15 += v21;
    if ( !((128 >> (j - 1)) & (unsigned __int8)v23[j - 1]) )
      __assert_fail(
        "hash[j - 1] & (LYB_HASH_COLLISION_ID >> (j - 1))",
        "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
        0x3A6u,
        "lyb_parse_schema_hash");
    if ( (127 << (9 - j)) & (unsigned __int8)v23[j - 1] )
      __assert_fail(
        "!(hash[j - 1] & (LYB_HASH_MASK << (LYB_HASH_BITS - (j - 1))))",
        "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
        0x3A8u,
        "lyb_parse_schema_hash");
  }
  if ( v12 & 0x1000000 && s && a2 && (v8 = strlen(s), (v16 = sub_40D5F(a2, s, v8)) == 0) )
  {
    v22 = 0LL;
  }
  else
  {
    if ( v16 && *(_DWORD *)(v16 + 56) & 0x4100 )
    {
      for ( k = lys_getnext(0LL, v16, 0LL, 8LL); ; k = lys_getnext(k, v16, 0LL, 8LL) )
      {
        v22 = (const char **)k;
        if ( !k || *(_DWORD *)(k + 56) == 512 && v12 & 0x10 )
          break;
        if ( *(_DWORD *)(k + 56) == 1024 && v12 & 0x20 )
          break;
      }
      if ( !k )
        goto LABEL_43;
      v16 = k;
    }
    for ( l = lys_getnext(0LL, v16, a2, 0LL); ; l = lys_getnext(v22, v16, a2, 0LL) )
    {
      v22 = (const char **)l;
      if ( !l
        || (unsigned int)sub_C70A(l, *(_QWORD *)(a7 + 32), *(_DWORD *)(a7 + 40))
        && (unsigned int)sub_708AD(v22, (__int64)v23, i + 1) )
      {
        break;
      }
    }
  }
LABEL_43:
  *v11 = v22;
  if ( v22 || !(v12 & 0x200) )
    return v19;
  if ( a2 )
    sub_13937(
      *(void **)(a7 + 48),
      -1,
      0,
      0LL,
      (__int64)"Failed to find matching hash for a top-level node from \"%s\".",
      *(_QWORD *)(a2 + 8));
  else
    sub_13937(
      *(void **)(a7 + 48),
      -1,
      2u,
      (char *)v16,
      (__int64)"Failed to find matching hash for a child of \"%s\".",
      *(_QWORD *)v16);
  return 0xFFFFFFFFLL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7090B: using guessed type char var_F[7];

//----- (0000000000070D13) ----------------------------------------------------
signed __int64 __fastcall sub_70D13(__int64 a1, __int64 a2)
{
  int v2; // ST1C_4
  int v3; // ST18_4
  __int64 v5; // [rsp+8h] [rbp-18h]
  __int64 v6; // [rsp+8h] [rbp-18h]
  unsigned int v7; // [rsp+18h] [rbp-8h]
  int v8; // [rsp+1Ch] [rbp-4h]

  v5 = a1;
  v7 = 0;
  do
  {
    v2 = 2 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 16) + *(signed int *)(a2 + 24) - 1LL);
    v6 = v2 + v5;
    v3 = v2 + v7;
    v8 = sub_6DF6A(v6, 0LL, *(_QWORD *)(*(_QWORD *)a2 + 8LL * *(signed int *)(a2 + 24) - 8), a2);
    v7 = v8 + v3;
    if ( v8 < 0 )
      return 0xFFFFFFFFLL;
    v5 = v8 + v6;
  }
  while ( *(_QWORD *)(*(_QWORD *)a2 + 8LL * *(signed int *)(a2 + 24) - 8) );
  return v7;
}

//----- (0000000000070DDA) ----------------------------------------------------
signed __int64 __fastcall sub_70DDA(__int16 *a1, __int64 *a2, __int64 a3, char *a4, int a5, __int64 a6, __int64 a7)
{
  int v7; // ST50_4
  const char **v8; // rsi
  unsigned int v9; // eax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v15; // [rsp+10h] [rbp-60h]
  int v16; // [rsp+1Ch] [rbp-54h]
  char *v17; // [rsp+20h] [rbp-50h]
  __int64 v18; // [rsp+28h] [rbp-48h]
  __int64 *v19; // [rsp+30h] [rbp-40h]
  __int64 v20; // [rsp+38h] [rbp-38h]
  __int64 v21; // [rsp+38h] [rbp-38h]
  __int64 v22; // [rsp+38h] [rbp-38h]
  int v23; // [rsp+40h] [rbp-30h]
  int v24; // [rsp+40h] [rbp-30h]
  int v25; // [rsp+40h] [rbp-30h]
  int v26; // [rsp+40h] [rbp-30h]
  int v27; // [rsp+40h] [rbp-30h]
  int v28; // [rsp+40h] [rbp-30h]
  int v29; // [rsp+44h] [rbp-2Ch]
  int v30; // [rsp+44h] [rbp-2Ch]
  unsigned int v31; // [rsp+44h] [rbp-2Ch]
  __int64 v32; // [rsp+48h] [rbp-28h]
  __int64 v33; // [rsp+50h] [rbp-20h]
  const char **v34; // [rsp+58h] [rbp-18h]
  const char *i; // [rsp+60h] [rbp-10h]
  unsigned __int64 v36; // [rsp+68h] [rbp-8h]

  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v36 = __readfsqword(0x28u);
  v34 = 0LL;
  if ( (!a2 || a3) && (a2 || !a3) )
    __assert_fail(
      "(parent && !first_sibling) || (!parent && first_sibling)",
      "/home/mantovan/Repositories/libyang/src/parser_lyb.c",
      0x3FEu,
      "lyb_parse_subtree");
  v23 = sub_6E6F0(a1, a7);
  v29 = v23;
  if ( v23 < 0 )
    goto LABEL_62;
  v20 = (__int64)a1 + v23;
  if ( a2 )
  {
    v32 = lyd_node_module(a2);
    v24 = sub_7090B(*a2, 0LL, v20, 0LL, v16, (const char ***)&v33, a7);
  }
  else
  {
    v24 = sub_6E8DA(v20, (__int64)&v32, a7);
    v29 += v24;
    if ( v24 < 0 )
      goto LABEL_62;
    v20 += v24;
    if ( v32 )
      v24 = sub_7090B(0LL, v32, v20, v17, v16, (const char ***)&v33, a7);
  }
  v30 = v24 + v29;
  if ( v24 < 0 )
    goto LABEL_62;
  v21 = v24 + v20;
  if ( v32 && v33 )
  {
    v34 = (const char **)sub_6EC05(v33);
    if ( !v34 )
      goto LABEL_62;
    v8 = (const char **)v21;
    v25 = sub_704EC((__int64)v34, v21, v16, v15, a7);
    v31 = v25 + v30;
    if ( v25 < 0 )
      goto LABEL_62;
    v22 = v25 + v21;
    v9 = *(_DWORD *)(v33 + 56);
    if ( v9 != 32 )
    {
      if ( v9 <= 0x20 )
      {
        if ( v9 != 4 )
        {
          if ( v9 <= 4 )
          {
            if ( v9 != 1 )
              goto LABEL_62;
            goto LABEL_39;
          }
          if ( v9 != 8 )
          {
            if ( v9 != 16 )
              goto LABEL_62;
            goto LABEL_39;
          }
        }
        v8 = v34;
        v26 = sub_6FED3((_DWORD *)*v34 + 32, (__int64)v34, 0LL, v22, v15, a7);
        v31 += v26;
        if ( v26 < 0 )
          goto LABEL_62;
        v22 += v26;
LABEL_39:
        if ( v19 )
        {
          if ( v19[8] )
          {
            *(_QWORD *)(*(_QWORD *)(v19[8] + 32) + 24LL) = v34;
            v34[4] = *(const char **)(v19[8] + 32);
            *(_QWORD *)(v19[8] + 32) = v34;
          }
          else
          {
            v19[8] = (__int64)v34;
          }
          v34[5] = (const char *)v19;
        }
        else if ( *(_QWORD *)v18 )
        {
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v18 + 32LL) + 24LL) = v34;
          v34[4] = *(const char **)(*(_QWORD *)v18 + 32LL);
          *(_QWORD *)(*(_QWORD *)v18 + 32LL) = v34;
        }
        else
        {
          *(_QWORD *)v18 = v34;
        }
        while ( *(_QWORD *)(*(_QWORD *)a7 + 8LL * *(signed int *)(a7 + 24) - 8) )
        {
          v8 = v34;
          v28 = sub_70DDA(v22);
          v31 += v28;
          if ( v28 < 0 )
            goto LABEL_62;
          v22 += v28;
        }
        if ( *((_DWORD *)*v34 + 14) == 1 && !*((_QWORD *)*v34 + 17) )
        {
          for ( i = v34[8]; i && i[9] & 1; i = (const char *)*((_QWORD *)i + 3) )
            ;
          if ( !i )
            *((_BYTE *)v34 + 9) |= 1u;
        }
        if ( *((_DWORD *)*v34 + 14) != 16 || !(*v34)[30] )
        {
          sub_AC63C(v34);
          sub_ACC62((unsigned int *)v34, (__int64)v8, v10, v11, v12, v13);
        }
        goto LABEL_61;
      }
      if ( v9 == 256 )
        goto LABEL_39;
      if ( v9 <= 0x100 )
      {
        if ( v9 != 128 )
          goto LABEL_62;
        goto LABEL_39;
      }
      if ( v9 == 0x4000 )
        goto LABEL_39;
      if ( v9 != 32800 )
        goto LABEL_62;
    }
    v8 = (const char **)v22;
    v27 = sub_6ED63((char *)v34, v22, a7);
    v31 += v27;
    if ( v27 < 0 )
      goto LABEL_62;
    v22 += v27;
    goto LABEL_39;
  }
  v7 = sub_70D13(v21, a7);
  v31 = v7 + v30;
  if ( v7 >= 0 )
  {
LABEL_61:
    sub_6E67A(a7);
    return v31;
  }
LABEL_62:
  lyd_free(v34);
  if ( v18 )
  {
    if ( v34 == *(const char ***)v18 )
      *(_QWORD *)v18 = 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (000000000007133F) ----------------------------------------------------
signed __int64 __fastcall sub_7133F(__int64 a1, __int64 a2)
{
  __int64 v3; // r9
  __int64 v4; // [rsp+8h] [rbp-18h]
  int i; // [rsp+14h] [rbp-Ch]
  unsigned int v6; // [rsp+18h] [rbp-8h]
  int v7; // [rsp+1Ch] [rbp-4h]
  int v8; // [rsp+1Ch] [rbp-4h]

  v7 = sub_6E1EC((_WORD *)(a2 + 40), 4uLL, 2uLL, a1, a2);
  v6 = v7;
  if ( v7 < 0 )
    return 0xFFFFFFFFLL;
  v4 = v7 + a1;
  if ( *(_DWORD *)(a2 + 40) )
  {
    *(_QWORD *)(a2 + 32) = malloc(8LL * *(signed int *)(a2 + 40));
    if ( !*(_QWORD *)(a2 + 32) )
    {
      sub_12222(
        *(_QWORD *)(a2 + 48),
        0,
        1,
        "Memory allocation failed (%s()).",
        (__int64)"lyb_parse_data_models",
        v3,
        a2);
      return 0xFFFFFFFFLL;
    }
    for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
    {
      v8 = sub_6E8DA(v4, *(_QWORD *)(a2 + 32) + 8LL * i, a2);
      v6 += v8;
      if ( v8 < 0 )
        return 0xFFFFFFFFLL;
      v4 += v8;
    }
  }
  return v6;
}

//----- (0000000000071473) ----------------------------------------------------
signed __int64 __fastcall sub_71473(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 result; // rax
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // [rsp+8h] [rbp-28h]
  __int64 v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+8h] [rbp-28h]
  char v9; // [rsp+1Fh] [rbp-11h]
  unsigned int v10; // [rsp+20h] [rbp-10h]
  int v11; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v12; // [rsp+28h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  v10 = 0;
  v9 = 0;
  v11 = sub_6DF6A(a1, &v9, 1uLL, a2);
  v10 += v11;
  if ( v11 < 0 )
    return 0xFFFFFFFFLL;
  v6 = v11 + a1;
  if ( v9 == 108 )
  {
    v11 = sub_6DF6A(v6, &v9, 1uLL, a2);
    v10 += v11;
    if ( v11 >= 0 )
    {
      v7 = v11 + v6;
      if ( v9 == 121 )
      {
        v11 = sub_6DF6A(v7, &v9, 1uLL, a2);
        v10 += v11;
        if ( v11 >= 0 )
        {
          v8 = v11 + v7;
          if ( v9 == 98 )
          {
            result = v10;
          }
          else
          {
            sub_12222(
              *(_QWORD *)(a2 + 48),
              0,
              3,
              "Invalid third magic number byte \"0x%02x\".",
              (unsigned int)v9,
              v5,
              a2,
              v8);
            result = 0xFFFFFFFFLL;
          }
        }
        else
        {
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        sub_12222(*(_QWORD *)(a2 + 48), 0, 3, "Invalid second magic number byte \"0x%02x\".", (unsigned int)v9, v4, a2);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_12222(*(_QWORD *)(a2 + 48), 0, 3, "Invalid first magic number byte \"0x%02x\".", (unsigned int)v9, v2, a2);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000007162D) ----------------------------------------------------
__int64 __fastcall sub_7162D(__int64 a1, __int64 a2)
{
  int v2; // eax
  char v4; // [rsp+13h] [rbp-Dh]
  int v5; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+18h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v5 = 0;
  v4 = 0;
  v2 = sub_6DF6A(a1, &v4, 1uLL, a2);
  return (unsigned int)(v2 + v5);
}

//----- (000000000007168F) ----------------------------------------------------
char **__fastcall sub_7168F(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, char *a5, __int64 a6)
{
  char **result; // rax
  __int64 v7; // r9
  __int64 v8; // r9
  void **v9; // rsi
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  _DWORD *v13; // [rsp+0h] [rbp-B0h]
  char *v14; // [rsp+8h] [rbp-A8h]
  __int64 v15; // [rsp+10h] [rbp-A0h]
  unsigned int v16; // [rsp+1Ch] [rbp-94h]
  __int64 v17; // [rsp+20h] [rbp-90h]
  __int64 v18; // [rsp+20h] [rbp-90h]
  __int16 *i; // [rsp+20h] [rbp-90h]
  int v20; // [rsp+38h] [rbp-78h]
  int v21; // [rsp+3Ch] [rbp-74h]
  int v22; // [rsp+3Ch] [rbp-74h]
  int v23; // [rsp+3Ch] [rbp-74h]
  char **v24; // [rsp+40h] [rbp-70h]
  char **v25; // [rsp+48h] [rbp-68h]
  char **j; // [rsp+50h] [rbp-60h]
  void *v27; // [rsp+58h] [rbp-58h]
  void *ptr; // [rsp+60h] [rbp-50h]
  void *v29; // [rsp+68h] [rbp-48h]
  void *v30; // [rsp+70h] [rbp-40h]
  int v31; // [rsp+78h] [rbp-38h]
  int v32; // [rsp+7Ch] [rbp-34h]
  void *v33; // [rsp+80h] [rbp-30h]
  int v34; // [rsp+88h] [rbp-28h]
  __int64 v35; // [rsp+90h] [rbp-20h]
  unsigned __int64 v36; // [rsp+A8h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = (_DWORD *)a6;
  v36 = __readfsqword(0x28u);
  v20 = 0;
  v24 = 0LL;
  j = 0LL;
  v27 = 0LL;
  if ( a1 && a2 )
  {
    ptr = malloc(0x20uLL);
    v29 = malloc(0x20uLL);
    v30 = malloc(4uLL);
    if ( ptr && v29 && v30 )
    {
      v31 = 0;
      v32 = 4;
      v33 = 0LL;
      v34 = 0;
      v35 = a1;
      v27 = calloc(1uLL, 0x28uLL);
      if ( v27 )
      {
        v20 = sub_71473(a2, (__int64)&ptr);
        v21 = v20;
        if ( v20 >= 0 )
        {
          v17 = v20 + a2;
          v20 = sub_7162D(v17, (__int64)&ptr);
          v22 = v20 + v21;
          if ( v20 >= 0 )
          {
            v18 = v20 + v17;
            v9 = &ptr;
            v20 = sub_7133F(v18, (__int64)&ptr);
            v23 = v20 + v22;
            if ( v20 >= 0 )
            {
              for ( i = (__int16 *)(v20 + v18); *(_BYTE *)i; i = (__int16 *)((char *)i + v20) )
              {
                v9 = 0LL;
                v20 = sub_70DDA(i, 0LL, (__int64)&v24, v14, v16, (__int64)v27, (__int64)&ptr);
                v23 += v20;
                if ( v20 < 0 )
                {
                  lyd_free_withsiblings(v24);
                  v24 = 0LL;
                  goto LABEL_38;
                }
              }
              v20 = v23 + 1;
              if ( v16 & 0x20000 && (v10 = ly_ctx_info(a1, v9), (unsigned int)lyd_merge(v24, v10, 1280LL)) )
              {
                sub_12222(a1, 0, 4, "Adding ietf-yang-library data failed.", v11, v12, v13);
                lyd_free_withsiblings(v24);
                v24 = 0LL;
              }
              else if ( *((_DWORD *)v27 + 4) )
              {
                if ( v16 & 0x70 )
                {
                  v25 = v24;
                  for ( j = v24; j && !(*((_DWORD *)*j + 14) & 0x4180); j = v25 )
                  {
                    if ( *((_DWORD *)*j + 14) & 0x802C )
                      v25 = 0LL;
                    else
                      v25 = (char **)j[8];
                    if ( !v25 )
                    {
                      if ( j == v24 )
                        break;
                      v25 = (char **)j[3];
                    }
                    while ( !v25 )
                    {
                      j = (char **)j[5];
                      if ( j[5] == v24[5] )
                        break;
                      v25 = (char **)j[3];
                    }
                  }
                }
                if ( (unsigned int)sub_BF7F8(&v24, v16, a1, 0LL, 0LL, v15, j, (__int64)v27, 0) )
                {
                  lyd_free_withsiblings(v24);
                  v24 = 0LL;
                }
              }
            }
          }
        }
      }
      else
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_parse_lyb", v8, v13);
      }
    }
    else
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_parse_lyb", v7, v13);
    }
LABEL_38:
    free(ptr);
    free(v29);
    free(v30);
    free(v33);
    if ( v27 )
    {
      free(*(void **)v27);
      free(*((void **)v27 + 1));
      free(v27);
    }
    if ( v13 )
      *v13 = v20;
    result = v24;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_parse_lyb", a6, a6);
    result = 0LL;
  }
  return result;
}
// 7390: using guessed type __int64 __fastcall ly_ctx_info(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7B50: using guessed type __int64 __fastcall lyd_merge(_QWORD, _QWORD, _QWORD);

//----- (0000000000071B9E) ----------------------------------------------------
signed __int64 __fastcall lyd_lyb_data_length(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // [rsp+8h] [rbp-188h]
  __int64 v9; // [rsp+8h] [rbp-188h]
  __int16 *v10; // [rsp+8h] [rbp-188h]
  __int64 v11; // [rsp+8h] [rbp-188h]
  __int64 v12; // [rsp+8h] [rbp-188h]
  __int64 v13; // [rsp+8h] [rbp-188h]
  unsigned int v14; // [rsp+1Ch] [rbp-174h]
  int i; // [rsp+20h] [rbp-170h]
  int v16; // [rsp+24h] [rbp-16Ch]
  int v17; // [rsp+24h] [rbp-16Ch]
  int v18; // [rsp+24h] [rbp-16Ch]
  int v19; // [rsp+24h] [rbp-16Ch]
  int v20; // [rsp+24h] [rbp-16Ch]
  int v21; // [rsp+24h] [rbp-16Ch]
  int v22; // [rsp+24h] [rbp-16Ch]
  int v23; // [rsp+24h] [rbp-16Ch]
  size_t v24; // [rsp+28h] [rbp-168h]
  void *ptr; // [rsp+30h] [rbp-160h]
  void *v26; // [rsp+38h] [rbp-158h]
  void *v27; // [rsp+40h] [rbp-150h]
  int v28; // [rsp+48h] [rbp-148h]
  int v29; // [rsp+4Ch] [rbp-144h]
  void *v30; // [rsp+50h] [rbp-140h]
  int v31; // [rsp+58h] [rbp-138h]
  __int64 v32; // [rsp+60h] [rbp-130h]
  char v33; // [rsp+80h] [rbp-110h]
  unsigned __int64 v34; // [rsp+188h] [rbp-8h]

  v34 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_11171E, (__int64)"lyd_lyb_data_length", a4, a5, a6);
  v14 = 0;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  ptr = malloc(0x20uLL);
  v26 = malloc(0x20uLL);
  v27 = malloc(4uLL);
  if ( ptr && v26 && v27 )
  {
    v28 = 0;
    v29 = 4;
    v30 = 0LL;
    v31 = 0;
    v32 = 0LL;
    v16 = sub_71473(a1, (__int64)&ptr);
    v14 = v16;
    if ( v16 >= 0 )
    {
      v8 = v16 + a1;
      v17 = sub_7162D(v8, (__int64)&ptr);
      v14 += v17;
      if ( v17 >= 0 )
      {
        v9 = v17 + v8;
        v18 = sub_6E1EC(&v31, 4uLL, 2uLL, v9, (__int64)&ptr);
        v14 += v18;
        if ( v18 >= 0 )
        {
          v10 = (__int16 *)(v18 + v9);
          for ( i = 0; i < v31; ++i )
          {
            v24 = 0LL;
            v19 = sub_6E1EC(&v24, 8uLL, 2uLL, (__int64)v10, (__int64)&ptr);
            v14 += v19;
            if ( v19 < 0 )
              goto LABEL_22;
            v11 = (__int64)v10 + v19;
            v20 = sub_6DF6A(v11, &v33, v24, (__int64)&ptr);
            v14 += v20;
            if ( v20 < 0 )
              goto LABEL_22;
            v12 = v20 + v11;
            v21 = sub_6DF6A(v12, &v33, 2uLL, (__int64)&ptr);
            v14 += v21;
            if ( v21 < 0 )
              goto LABEL_22;
            v10 = (__int16 *)(v21 + v12);
          }
          while ( *(_BYTE *)v10 )
          {
            v22 = sub_6E6F0(v10, (__int64)&ptr);
            v14 += v22;
            if ( v22 < 0 )
              goto LABEL_22;
            v13 = (__int64)v10 + v22;
            v23 = sub_70D13(v13, (__int64)&ptr);
            v14 += v23;
            if ( v23 < 0 )
              goto LABEL_22;
            v10 = (__int16 *)(v23 + v13);
            sub_6E67A((__int64)&ptr);
          }
          ++v14;
        }
      }
    }
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_lyb_data_length", v7);
  }
LABEL_22:
  free(ptr);
  free(v26);
  free(v27);
  free(v30);
  return v14;
}
// 11171E: using guessed type void *__ptr32 off_11171E;

//----- (0000000000071FFF) ----------------------------------------------------
void __fastcall sub_71FFF(__int64 a1, signed int a2, void **a3, __int64 a4, __int64 a5, __int64 **a6)
{
  void *v6; // rax

  if ( a2 == 401 )
  {
    free(*a3);
  }
  else if ( a2 > 401 )
  {
    switch ( a2 )
    {
      case 430:
        sub_93CE2(**a6, (__int64)*a3);
        break;
      case 431:
        sub_93CE2(**a6, (__int64)*a3 + 56);
        break;
      case 405:
        free(*a3);
        break;
    }
  }
  else
  {
    switch ( a2 )
    {
      case 210:
        free(*a3);
        break;
      case 399:
        free(*a3);
        break;
      case 115:
        if ( *a3 )
          v6 = *(void **)*a3;
        else
          v6 = 0LL;
        free(v6);
        break;
    }
  }
}

//----- (000000000007212F) ----------------------------------------------------
#error "7212F: too big function (funcsize=0)"

//----- (0000000000085F41) ----------------------------------------------------
unsigned __int64 __fastcall sub_85F41(unsigned int *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // r9
  __int64 v6; // rax
  __int64 v7; // r9
  __int64 v8; // [rsp+8h] [rbp-C8h]

  v8 = a3;
  free(**(void ***)(a3 + 32));
  **(_QWORD **)(v8 + 32) = 0LL;
  result = *a1;
  if ( (_DWORD)result != -1 )
  {
    if ( **(_QWORD **)(v8 + 40) && **(_QWORD **)(v8 + 40) == **(_QWORD **)(v8 + 48) )
    {
      v4 = sub_8AF72(a2);
      result = sub_13937(**(void ***)v8, 5, 2u, **(char ***)(v8 + 40), v4, v5);
    }
    else
    {
      v6 = sub_8AF72(a2);
      result = sub_13937(**(void ***)v8, 5, 0, 0LL, v6, v7);
    }
  }
  return result;
}

//----- (0000000000086095) ----------------------------------------------------
signed __int64 __fastcall sub_86095(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  _QWORD *v3; // rbx
  __int16 v4; // ax
  signed __int64 result; // rax
  void *v6; // rax
  void *v7; // rax
  void *v8; // rax
  __int64 v9; // r9
  void *v10; // rax
  __int64 v11; // r9
  _BYTE *v12; // ST70_8
  _BYTE *v13; // ST70_8
  _BYTE *v14; // ST70_8
  void *v15; // rax
  void *v16; // rax
  unsigned int v17; // ebx
  void *v18; // rax
  int v19; // eax
  unsigned __int64 v20; // [rsp+8h] [rbp-98h]
  unsigned __int8 v21; // [rsp+2Fh] [rbp-71h]
  signed int v22; // [rsp+30h] [rbp-70h]
  unsigned int v23; // [rsp+34h] [rbp-6Ch]
  int v24; // [rsp+38h] [rbp-68h]
  int v25; // [rsp+3Ch] [rbp-64h]
  int v26; // [rsp+40h] [rbp-60h]
  int v27; // [rsp+44h] [rbp-5Ch]
  int i; // [rsp+48h] [rbp-58h]
  int v29; // [rsp+4Ch] [rbp-54h]
  signed int v30; // [rsp+50h] [rbp-50h]
  unsigned int v31; // [rsp+5Ch] [rbp-44h]
  unsigned int v32; // [rsp+5Ch] [rbp-44h]
  unsigned int v33; // [rsp+5Ch] [rbp-44h]
  unsigned int v34; // [rsp+5Ch] [rbp-44h]
  _BYTE *v35; // [rsp+70h] [rbp-30h]
  _BYTE *v36; // [rsp+78h] [rbp-28h]
  __int64 v37; // [rsp+80h] [rbp-20h]
  unsigned __int64 v38; // [rsp+88h] [rbp-18h]

  v20 = a3;
  v38 = a3;
  *(_QWORD *)(a3 + 144) = a1;
  *(_QWORD *)(a3 + 152) = a2;
  if ( !*(_DWORD *)(a3 + 72) )
  {
    *(_DWORD *)(a3 + 72) = 1;
    if ( !*(_DWORD *)(a3 + 76) )
      *(_DWORD *)(a3 + 76) = 1;
    if ( !*(_QWORD *)(a3 + 8) )
      *(_QWORD *)(a3 + 8) = stdin;
    if ( !*(_QWORD *)(a3 + 16) )
      *(_QWORD *)(a3 + 16) = stdout;
    if ( !*(_QWORD *)(a3 + 40) || !*(_QWORD *)(*(_QWORD *)(a3 + 40) + 8LL * *(_QWORD *)(a3 + 24)) )
    {
      sub_8AA59(a3);
      v3 = (_QWORD *)(*(_QWORD *)(v38 + 40) + 8LL * *(_QWORD *)(v38 + 24));
      *v3 = sub_8A526(*(FILE **)(v38 + 8), 0x4000, v20);
    }
    sub_8A47F(v20);
  }
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v37 = 0LL;
  v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
LABEL_13:
  v35 = *(_BYTE **)(v38 + 64);
  *v35 = *(_BYTE *)(v38 + 48);
  v36 = v35;
  v22 = *(_DWORD *)(v38 + 76);
  do
  {
LABEL_14:
    v21 = byte_119D20[(unsigned __int8)*v35];
    if ( word_1197E0[v22] )
    {
      *(_DWORD *)(v38 + 104) = v22;
      *(_QWORD *)(v38 + 112) = v35;
    }
    while ( v22 != *((signed __int16 *)&off_11CF20 + word_119E60[v22] + v21) )
    {
      v22 = word_11A3C0[v22];
      if ( v22 > 671 )
        v21 = byte_119E20[v21];
    }
    v22 = *((signed __int16 *)&off_11A920 + word_119E60[v22] + v21);
    ++v35;
  }
  while ( word_119E60[v22] != 4800 );
  while ( 2 )
  {
    v4 = word_1197E0[v22];
    v23 = v4;
    if ( !v4 )
    {
      v35 = *(_BYTE **)(v38 + 112);
      v23 = (signed __int16)word_1197E0[*(signed int *)(v38 + 104)];
    }
    *(_QWORD *)(v38 + 128) = v36;
    *(_DWORD *)(v38 + 56) = (_DWORD)v35 - (_DWORD)v36;
    *(_BYTE *)(v38 + 48) = *v35;
    *v35 = 0;
    *(_QWORD *)(v38 + 64) = v35;
LABEL_23:
    switch ( (unsigned __int64)v23 )
    {
      case 0uLL:
        *v35 = *(_BYTE *)(v38 + 48);
        v35 = *(_BYTE **)(v38 + 112);
        v22 = *(_DWORD *)(v38 + 104);
        continue;
      case 1uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 3;
        goto LABEL_13;
      case 2uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        goto LABEL_13;
      case 3uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = 0;
        goto LABEL_13;
      case 4uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 2 * v27 + 1;
        goto LABEL_13;
      case 5uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 5;
        goto LABEL_13;
      case 6uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 2 * v27 + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = 0;
        return 262LL;
      case 7uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 259LL;
      case 8uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 275LL;
      case 9uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 7;
        return 276LL;
      case 0xAuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 277LL;
      case 0xBuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 278LL;
      case 0xCuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 279LL;
      case 0xDuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 280LL;
      case 0xEuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 281LL;
      case 0xFuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 282LL;
      case 0x10uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 283LL;
      case 0x11uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 284LL;
      case 0x12uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 285LL;
      case 0x13uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 286LL;
      case 0x14uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 287LL;
      case 0x15uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 288LL;
      case 0x16uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 289LL;
      case 0x17uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 290LL;
      case 0x18uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 7;
        return 291LL;
      case 0x19uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 292LL;
      case 0x1AuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 293LL;
      case 0x1BuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 294LL;
      case 0x1CuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 295LL;
      case 0x1DuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 296LL;
      case 0x1EuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 297LL;
      case 0x1FuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 298LL;
      case 0x20uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 299LL;
      case 0x21uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 300LL;
      case 0x22uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 301LL;
      case 0x23uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 302LL;
      case 0x24uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 303LL;
      case 0x25uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 304LL;
      case 0x26uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 305LL;
      case 0x27uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 306LL;
      case 0x28uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 307LL;
      case 0x29uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 308LL;
      case 0x2AuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 309LL;
      case 0x2BuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 310LL;
      case 0x2CuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 311LL;
      case 0x2DuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 312LL;
      case 0x2EuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 313LL;
      case 0x2FuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 314LL;
      case 0x30uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 315LL;
      case 0x31uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 7;
        return 316LL;
      case 0x32uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 317LL;
      case 0x33uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 318LL;
      case 0x34uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 319LL;
      case 0x35uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 320LL;
      case 0x36uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 321LL;
      case 0x37uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 322LL;
      case 0x38uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 7;
        return 323LL;
      case 0x39uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 324LL;
      case 0x3AuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 325LL;
      case 0x3BuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 326LL;
      case 0x3CuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 327LL;
      case 0x3DuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 328LL;
      case 0x3EuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        if ( *(_DWORD *)(*(_QWORD *)(v38 + 152) + 8LL) )
          result = 357LL;
        else
          result = 329LL;
        return result;
      case 0x3FuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 330LL;
      case 0x40uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 331LL;
      case 0x41uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 7;
        return 332LL;
      case 0x42uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 333LL;
      case 0x43uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 334LL;
      case 0x44uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 335LL;
      case 0x45uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 336LL;
      case 0x46uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 337LL;
      case 0x47uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 338LL;
      case 0x48uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 339LL;
      case 0x49uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 340LL;
      case 0x4AuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 340LL;
      case 0x4BuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 341LL;
      case 0x4CuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 342LL;
      case 0x4DuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 343LL;
      case 0x4EuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 344LL;
      case 0x4FuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 345LL;
      case 0x50uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 346LL;
      case 0x51uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 347LL;
      case 0x52uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 348LL;
      case 0x53uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 349LL;
      case 0x54uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 350LL;
      case 0x55uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 351LL;
      case 0x56uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 352LL;
      case 0x57uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 353LL;
      case 0x58uLL:
      case 0x59uLL:
      case 0x5AuLL:
      case 0x5BuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return (unsigned int)**(char **)(v38 + 128);
      case 0x5CuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 9;
        v37 = *(_QWORD *)(v38 + 128);
        v26 = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL);
        goto LABEL_13;
      case 0x5DuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        ++v24;
        v25 += *(_DWORD *)(v38 + 56);
        goto LABEL_13;
      case 0x5EuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v25 += *(_DWORD *)(v38 + 56);
        goto LABEL_13;
      case 0x5FuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v25 += *(_DWORD *)(v38 + 56);
        goto LABEL_13;
      case 0x60uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = 0;
        ++v25;
        goto LABEL_13;
      case 0x61uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v31 = (*(char *)(*(_QWORD *)(v38 + 128) + 1LL) << 6) & 0xFC0 | (unsigned __int16)(**(char **)(v38 + 128) << 12) | *(_BYTE *)(*(_QWORD *)(v38 + 128) + 2LL) & 0x3F;
        if ( (v31 & 0xF800) == 55296 || v31 > 0xFDCF && v31 <= 0xFDEF || (v31 & 0xFFE) == 4094 )
        {
          v6 = (void *)sub_8AE48(v20);
          sub_13937(v6, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v31);
          **(_DWORD **)(v38 + 152) = -1;
          return 261LL;
        }
        v25 += 3;
        goto LABEL_13;
      case 0x62uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v32 = (*(char *)(*(_QWORD *)(v38 + 128) + 2LL) << 6) & 0xFC0 | (*(char *)(*(_QWORD *)(v38 + 128) + 1LL) << 12) & 0x3F000 | (**(char **)(v38 + 128) << 18) & 0x1C0000 | *(_BYTE *)(*(_QWORD *)(v38 + 128) + 3LL) & 0x3F;
        if ( (((*(char *)(*(_QWORD *)(v38 + 128) + 2LL) << 6) & 0xFC0 | (*(char *)(*(_QWORD *)(v38 + 128) + 1LL) << 12) & 0xF000 | *(_BYTE *)(*(_QWORD *)(v38 + 128) + 3LL) & 0x3F) & 0xFFE) == 4094 )
        {
          v7 = (void *)sub_8AE48(v20);
          sub_13937(v7, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v32);
          **(_DWORD **)(v38 + 152) = -1;
          return 261LL;
        }
        v25 += 4;
        goto LABEL_13;
      case 0x63uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        **(_DWORD **)(v38 + 144) = v24;
        *(_DWORD *)(v38 + 76) = 2 * v27 + 1;
        *(_QWORD *)(v38 + 128) = v37;
        *(_DWORD *)(v38 + 56) = v25 + 2;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = v26;
        return 263LL;
      case 0x64uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 11;
        v37 = *(_QWORD *)(v38 + 128);
        v26 = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL);
        goto LABEL_13;
      case 0x65uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v25 += *(_DWORD *)(v38 + 56);
        goto LABEL_13;
      case 0x66uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 2 * v27 + 1;
        *(_QWORD *)(v38 + 128) = v37;
        *(_DWORD *)(v38 + 56) = v25 + 2;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = v26;
        return 263LL;
      case 0x67uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 273LL;
      case 0x68uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 271LL;
      case 0x69uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 272LL;
      case 0x6AuLL:
      case 0x6BuLL:
      case 0x6CuLL:
      case 0x6DuLL:
      case 0x6EuLL:
      case 0x6FuLL:
      case 0x70uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return (unsigned int)**(char **)(v38 + 128);
      case 0x71uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 269LL;
      case 0x72uLL:
      case 0x73uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = 0;
        return 262LL;
      case 0x74uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 260LL;
      case 0x75uLL:
      case 0x76uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(v38 + 76) = 1;
        return (unsigned int)**(char **)(v38 + 128);
      case 0x77uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 9;
        v37 = *(_QWORD *)(v38 + 128);
        v26 = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL);
        goto LABEL_13;
      case 0x78uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 5;
        goto LABEL_13;
      case 0x79uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
        *(_DWORD *)(v38 + 76) = 3;
        goto LABEL_13;
      case 0x7AuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 265LL;
      case 0x7BuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 266LL;
      case 0x7CuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 267LL;
      case 0x7DuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 265LL;
      case 0x7EuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 266LL;
      case 0x7FuLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        if ( **(_BYTE **)(v38 + 128) == 47 && *(_BYTE *)(*(_QWORD *)(v38 + 128) + 1LL) == 47 )
        {
          v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
          *v35 = *(_BYTE *)(v38 + 48);
          *(_QWORD *)(v38 + 64) = v36 + 2;
          *(_QWORD *)(v38 + 128) = v36;
          *(_DWORD *)(v38 + 56) = 2;
          *(_BYTE *)(v38 + 48) = v36[2];
          v36[2] = 0;
          *(_QWORD *)(v38 + 64) = v36 + 2;
          *(_DWORD *)(v38 + 76) = 5;
          goto LABEL_13;
        }
        if ( **(_BYTE **)(v38 + 128) == 47 && *(_BYTE *)(*(_QWORD *)(v38 + 128) + 1LL) == 42 )
        {
          v27 = (*(_DWORD *)(v38 + 76) - 1) / 2;
          *v35 = *(_BYTE *)(v38 + 48);
          *(_QWORD *)(v38 + 64) = v36 + 2;
          *(_QWORD *)(v38 + 128) = v36;
          *(_DWORD *)(v38 + 56) = 2;
          *(_BYTE *)(v38 + 48) = v36[2];
          v36[2] = 0;
          *(_QWORD *)(v38 + 64) = v36 + 2;
          *(_DWORD *)(v38 + 76) = 3;
          goto LABEL_13;
        }
        for ( i = 0; ; ++i )
        {
          while ( 1 )
          {
            if ( i >= *(_DWORD *)(v38 + 56) )
              return 264LL;
            if ( *(_BYTE *)(*(_QWORD *)(v38 + 128) + i) >= 0 )
              break;
            if ( *(_BYTE *)(*(_QWORD *)(v38 + 128) + i) & 0x20 )
            {
              if ( *(_BYTE *)(*(_QWORD *)(v38 + 128) + i) & 0x10 )
              {
                v34 = (*(char *)(i + 2LL + *(_QWORD *)(v38 + 128)) << 6) & 0xFC0 | (*(char *)(i
                                                                                            + 1LL
                                                                                            + *(_QWORD *)(v38 + 128)) << 12) & 0x3F000 | (*(char *)(*(_QWORD *)(v38 + 128) + i) << 18) & 0x1C0000 | *(_BYTE *)(i + 3LL + *(_QWORD *)(v38 + 128)) & 0x3F;
                if ( (((*(char *)(i + 2LL + *(_QWORD *)(v38 + 128)) << 6) & 0xFC0 | (*(char *)(i
                                                                                             + 1LL
                                                                                             + *(_QWORD *)(v38 + 128)) << 12) & 0xF000 | *(_BYTE *)(i + 3LL + *(_QWORD *)(v38 + 128)) & 0x3F) & 0xFFE) == 4094 )
                {
                  v16 = (void *)sub_8AE48(v20);
                  sub_13937(v16, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v34);
                  **(_DWORD **)(v38 + 152) = -1;
                  return 261LL;
                }
                i += 4;
              }
              else
              {
                v33 = (*(char *)(i + 1LL + *(_QWORD *)(v38 + 128)) << 6) & 0xFC0 | (unsigned __int16)(*(char *)(*(_QWORD *)(v38 + 128) + i) << 12) | *(_BYTE *)(i + 2LL + *(_QWORD *)(v38 + 128)) & 0x3F;
                if ( (v33 & 0xF800) == 55296 || v33 > 0xFDCF && v33 <= 0xFDEF || (v33 & 0xFFE) == 4094 )
                {
                  v15 = (void *)sub_8AE48(v20);
                  sub_13937(v15, -1, 0, 0LL, (__int64)"Invalid UTF-8 value 0x%08x", v33);
                  **(_DWORD **)(v38 + 152) = -1;
                  return 261LL;
                }
                i += 3;
              }
            }
            else
            {
              i += 2;
            }
          }
          if ( *(_BYTE *)(*(_QWORD *)(v38 + 128) + i) != 47 )
            break;
          if ( *(_BYTE *)(i + 1LL + *(_QWORD *)(v38 + 128)) == 47 )
          {
            *v35 = *(_BYTE *)(v38 + 48);
            v12 = &v36[i];
            *(_QWORD *)(v38 + 64) = v12;
            *(_QWORD *)(v38 + 128) = v36;
            *(_DWORD *)(v38 + 56) = i;
            *(_BYTE *)(v38 + 48) = *v12;
            *v12 = 0;
            *(_QWORD *)(v38 + 64) = v12;
            return 264LL;
          }
          if ( *(_BYTE *)(i + 1LL + *(_QWORD *)(v38 + 128)) == 42 )
          {
            *v35 = *(_BYTE *)(v38 + 48);
            v13 = &v36[i];
            *(_QWORD *)(v38 + 64) = v13;
            *(_QWORD *)(v38 + 128) = v36;
            *(_DWORD *)(v38 + 56) = i;
            *(_BYTE *)(v38 + 48) = *v13;
            *v13 = 0;
            *(_QWORD *)(v38 + 64) = v13;
            return 264LL;
          }
LABEL_169:
          ;
        }
        if ( *(_BYTE *)(*(_QWORD *)(v38 + 128) + i) != 42 || *(_BYTE *)(i + 1LL + *(_QWORD *)(v38 + 128)) != 47 )
          goto LABEL_169;
        if ( i )
        {
          *v35 = *(_BYTE *)(v38 + 48);
          v14 = &v36[i];
          *(_QWORD *)(v38 + 64) = v14;
          *(_QWORD *)(v38 + 128) = v36;
          *(_DWORD *)(v38 + 56) = i;
          *(_BYTE *)(v38 + 48) = *v14;
          *v14 = 0;
          *(_QWORD *)(v38 + 64) = v14;
          result = 264LL;
        }
        else
        {
          *v35 = *(_BYTE *)(v38 + 48);
          *(_QWORD *)(v38 + 64) = v36 + 1;
          *(_QWORD *)(v38 + 128) = v36;
          *(_DWORD *)(v38 + 56) = 1;
          *(_BYTE *)(v38 + 48) = v36[1];
          v36[1] = 0;
          *(_QWORD *)(v38 + 64) = v36 + 1;
          result = 261LL;
        }
        return result;
      case 0x80uLL:
      case 0x81uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = 0;
        return 262LL;
      case 0x82uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        return 260LL;
      case 0x83uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        v17 = **(char **)(v38 + 128);
        v18 = (void *)sub_8AE48(v20);
        sub_13937(v18, -1, 0, 0LL, (__int64)"Invalid UTF-8 leading byte 0x%02x", v17);
        **(_DWORD **)(v38 + 152) = -1;
        return 261LL;
      case 0x84uLL:
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL) = *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) + 1;
        *(_DWORD *)(*(_QWORD *)(v38 + 152) + 12LL) = *(_DWORD *)(v38 + 56)
                                                   + *(_DWORD *)(*(_QWORD *)(v38 + 152) + 4LL)
                                                   - 1;
        fwrite(*(const void **)(v38 + 128), *(signed int *)(v38 + 56), 1uLL, *(FILE **)(v38 + 16));
        goto LABEL_13;
      case 0x85uLL:
        v29 = (_DWORD)v35 - *(unsigned __int64 *)(v38 + 128) - 1;
        *v35 = *(_BYTE *)(v38 + 48);
        if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v38 + 40) + 8LL * *(_QWORD *)(v38 + 24)) + 56LL) )
        {
          *(_DWORD *)(v38 + 52) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v38 + 40) + 8LL * *(_QWORD *)(v38 + 24)) + 28LL);
          **(_QWORD **)(*(_QWORD *)(v38 + 40) + 8LL * *(_QWORD *)(v38 + 24)) = *(_QWORD *)(v38 + 8);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v38 + 40) + 8LL * *(_QWORD *)(v38 + 24)) + 56LL) = 1;
        }
        if ( *(_QWORD *)(v38 + 64) <= (unsigned __int64)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v38 + 40)
                                                                               + 8LL * *(_QWORD *)(v38 + 24))
                                                                   + 8LL)
                                                       + *(signed int *)(v38 + 52)) )
        {
          *(_QWORD *)(v38 + 64) = v29 + *(_QWORD *)(v38 + 128);
          v22 = sub_8A031(v20);
          v30 = sub_8A175(v22, v20);
          v36 = *(_BYTE **)(v38 + 128);
          if ( v30 )
          {
            v35 = (_BYTE *)++*(_QWORD *)(v38 + 64);
            v22 = v30;
            goto LABEL_14;
          }
          v35 = *(_BYTE **)(v38 + 64);
          continue;
        }
        v19 = sub_89947(v20);
        if ( v19 == 1 )
        {
          *(_DWORD *)(v38 + 80) = 0;
          *(_QWORD *)(v38 + 64) = *(_QWORD *)(v38 + 128);
          v23 = (*(_DWORD *)(v38 + 76) - 1) / 2 + 134;
          goto LABEL_23;
        }
        if ( v19 == 2 )
        {
          *(_QWORD *)(v38 + 64) = *(signed int *)(v38 + 52)
                                + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v38 + 40) + 8LL * *(_QWORD *)(v38 + 24)) + 8LL);
          v22 = sub_8A031(v20);
          v35 = *(_BYTE **)(v38 + 64);
          v36 = *(_BYTE **)(v38 + 128);
          continue;
        }
        if ( v19 )
          goto LABEL_13;
        *(_QWORD *)(v38 + 64) = v29 + *(_QWORD *)(v38 + 128);
        v22 = sub_8A031(v20);
        v35 = *(_BYTE **)(v38 + 64);
        v36 = *(_BYTE **)(v38 + 128);
        goto LABEL_14;
      case 0x86uLL:
      case 0x87uLL:
      case 0x88uLL:
      case 0x89uLL:
        return 0LL;
      case 0x8AuLL:
        v8 = (void *)sub_8AE48(v20);
        sub_13937(v8, -1, 0, 0LL, (__int64)"Unterminated double-quoted string.", v9);
        **(_DWORD **)(v38 + 152) = -1;
        return 261LL;
      case 0x8BuLL:
        v10 = (void *)sub_8AE48(v20);
        sub_13937(v10, -1, 0, 0LL, (__int64)"Unterminated single-quoted string.", v11);
        **(_DWORD **)(v38 + 152) = -1;
        return 261LL;
      default:
        sub_8AE04((__int64)"fatal flex scanner internal error--no action found");
        return result;
    }
  }
}
// 11A920: using guessed type void *off_11A920;
// 11CF20: using guessed type void *off_11CF20;

//----- (0000000000089947) ----------------------------------------------------
signed __int64 __fastcall sub_89947(unsigned __int64 a1)
{
  signed __int64 result; // rax
  _BYTE *v2; // rdx
  _BYTE *v3; // rax
  int v4; // eax
  __int64 v5; // rbx
  int i; // [rsp+1Ch] [rbp-54h]
  unsigned int v7; // [rsp+20h] [rbp-50h]
  int j; // [rsp+24h] [rbp-4Ch]
  int v9; // [rsp+28h] [rbp-48h]
  int k; // [rsp+2Ch] [rbp-44h]
  int v11; // [rsp+30h] [rbp-40h]
  int v12; // [rsp+34h] [rbp-3Ch]
  int v13; // [rsp+3Ch] [rbp-34h]
  _BYTE *v14; // [rsp+40h] [rbp-30h]
  _BYTE *v15; // [rsp+48h] [rbp-28h]
  __int64 v16; // [rsp+58h] [rbp-18h]

  v14 = *(_BYTE **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL);
  v15 = *(_BYTE **)(a1 + 128);
  if ( *(_QWORD *)(a1 + 64) > (unsigned __int64)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40)
                                                                       + 8LL * *(_QWORD *)(a1 + 24))
                                                           + 8LL)
                                               + *(signed int *)(a1 + 52)
                                               + 1LL) )
    sub_8AE04((__int64)"fatal flex scanner internal error--end of buffer missed");
  if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 52LL) )
  {
    v11 = *(_DWORD *)(a1 + 64) - *(_DWORD *)(a1 + 128) - 1;
    for ( i = 0; i < v11; ++i )
    {
      v2 = v15++;
      v3 = v14++;
      *v3 = *v2;
    }
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 56LL) == 2 )
    {
      *(_DWORD *)(a1 + 52) = 0;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 28LL) = *(_DWORD *)(a1 + 52);
    }
    else
    {
      for ( j = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 24LL) - v11 - 1;
            j <= 0;
            j = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 24LL) - v11 - 1 )
      {
        v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
        v12 = *(_DWORD *)(a1 + 64) - *(_DWORD *)(v16 + 8);
        if ( *(_DWORD *)(v16 + 32) )
        {
          if ( 2 * *(_DWORD *)(v16 + 24) > 0 )
            *(_DWORD *)(v16 + 24) *= 2;
          else
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 24LL) += *(_DWORD *)(v16 + 24)
                                                                                                / 8;
          *(_QWORD *)(v16 + 8) = sub_8B50E(*(void **)(v16 + 8), *(_DWORD *)(v16 + 24) + 2);
        }
        else
        {
          *(_QWORD *)(v16 + 8) = 0LL;
        }
        if ( !*(_QWORD *)(v16 + 8) )
          sub_8AE04((__int64)"fatal error - scanner input buffer overflow");
        *(_QWORD *)(a1 + 64) = v12 + *(_QWORD *)(v16 + 8);
      }
      if ( j > 0x2000 )
        j = 0x2000;
      if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 36LL) )
      {
        v9 = 42;
        for ( k = 0; k < j; ++k )
        {
          v9 = _IO_getc(*(_IO_FILE **)(a1 + 8));
          if ( v9 == -1 || v9 == 10 )
            break;
          *(_BYTE *)(v11
                   + (signed __int64)k
                   + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL)) = v9;
        }
        if ( v9 == 10 )
        {
          v4 = k++;
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL)
                   + v11
                   + (signed __int64)v4) = 10;
        }
        if ( v9 == -1 && ferror(*(FILE **)(a1 + 8)) )
          sub_8AE04((__int64)"input in flex scanner failed");
        *(_DWORD *)(a1 + 52) = k;
      }
      else
      {
        *__errno_location() = 0;
        while ( 1 )
        {
          *(_DWORD *)(a1 + 52) = fread(
                                   (void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24))
                                                      + 8LL)
                                          + v11),
                                   1uLL,
                                   j,
                                   *(FILE **)(a1 + 8));
          if ( *(_DWORD *)(a1 + 52) || !ferror(*(FILE **)(a1 + 8)) )
            break;
          if ( *__errno_location() != 4 )
            sub_8AE04((__int64)"input in flex scanner failed");
          *__errno_location() = 0;
          clearerr(*(FILE **)(a1 + 8));
        }
      }
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 28LL) = *(_DWORD *)(a1 + 52);
    }
    if ( *(_DWORD *)(a1 + 52) )
    {
      v7 = 0;
    }
    else if ( v11 )
    {
      v7 = 2;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 56LL) = 2;
    }
    else
    {
      v7 = 1;
      sub_8A287(*(FILE **)(a1 + 8), a1);
    }
    if ( *(_DWORD *)(a1 + 52) + v11 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 24LL) )
    {
      v13 = v11 + *(_DWORD *)(a1 + 52) + (*(_DWORD *)(a1 + 52) >> 1);
      v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
      *(_QWORD *)(v5 + 8) = sub_8B50E(
                              *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL),
                              v13);
      if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL) )
        sub_8AE04((__int64)"out of dynamic memory in yy_get_next_buffer()");
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 24LL) = v13 - 2;
    }
    *(_DWORD *)(a1 + 52) += v11;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL)
             + *(signed int *)(a1 + 52)) = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL)
             + *(signed int *)(a1 + 52)
             + 1LL) = 0;
    *(_QWORD *)(a1 + 128) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 8LL);
    result = v7;
  }
  else if ( *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 128) == 1LL )
  {
    result = 1LL;
  }
  else
  {
    result = 2LL;
  }
  return result;
}

//----- (000000000008A031) ----------------------------------------------------
__int64 __fastcall sub_8A031(__int64 a1)
{
  char v1; // al
  unsigned __int8 v3; // [rsp+13h] [rbp-15h]
  signed int v4; // [rsp+14h] [rbp-14h]
  _BYTE *i; // [rsp+18h] [rbp-10h]

  v4 = *(_DWORD *)(a1 + 76);
  for ( i = *(_BYTE **)(a1 + 128); (unsigned __int64)i < *(_QWORD *)(a1 + 64); ++i )
  {
    if ( *i )
      v1 = byte_119D20[(unsigned __int8)*i];
    else
      v1 = 1;
    v3 = v1;
    if ( word_1197E0[v4] )
    {
      *(_DWORD *)(a1 + 104) = v4;
      *(_QWORD *)(a1 + 112) = i;
    }
    while ( v4 != *((signed __int16 *)&off_11CF20 + word_119E60[v4] + v3) )
    {
      v4 = word_11A3C0[v4];
      if ( v4 > 671 )
        v3 = byte_119E20[v3];
    }
    v4 = *((signed __int16 *)&off_11A920 + word_119E60[v4] + v3);
  }
  return (unsigned int)v4;
}
// 11A920: using guessed type void *off_11A920;
// 11CF20: using guessed type void *off_11CF20;

//----- (000000000008A175) ----------------------------------------------------
__int64 __fastcall sub_8A175(signed int a1, __int64 a2)
{
  __int64 result; // rax
  signed int v3; // [rsp+Ch] [rbp-24h]
  unsigned int v4; // [rsp+Ch] [rbp-24h]
  unsigned __int8 v5; // [rsp+1Bh] [rbp-15h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v3 = a1;
  v6 = *(_QWORD *)(a2 + 64);
  v5 = 1;
  if ( word_1197E0[a1] )
  {
    *(_DWORD *)(a2 + 104) = a1;
    *(_QWORD *)(a2 + 112) = v6;
  }
  while ( v3 != *((signed __int16 *)&off_11CF20 + word_119E60[v3] + v5) )
  {
    v3 = word_11A3C0[v3];
    if ( v3 > 671 )
      v5 = byte_119E20[v5];
  }
  v4 = *((signed __int16 *)&off_11A920 + word_119E60[v3] + v5);
  if ( v4 == 671 )
    result = 0LL;
  else
    result = v4;
  return result;
}
// 11A920: using guessed type void *off_11A920;
// 11CF20: using guessed type void *off_11CF20;

//----- (000000000008A287) ----------------------------------------------------
__int64 __fastcall sub_8A287(FILE *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rax

  if ( !*(_QWORD *)(a2 + 40) || !*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) )
  {
    sub_8AA59(a2);
    v2 = (_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
    *v2 = sub_8A526(*(FILE **)(a2 + 8), 0x4000, a2);
  }
  if ( *(_QWORD *)(a2 + 40) )
    v3 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
  else
    v3 = 0LL;
  sub_8A68F(v3, a1, a2);
  return sub_8A47F(a2);
}

//----- (000000000008A361) ----------------------------------------------------
unsigned __int64 __fastcall sub_8A361(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax

  sub_8AA59(a2);
  if ( *(_QWORD *)(a2 + 40) )
    result = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
  else
    result = 0LL;
  if ( result != a1 )
  {
    if ( *(_QWORD *)(a2 + 40) )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) )
      {
        **(_BYTE **)(a2 + 64) = *(_BYTE *)(a2 + 48);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) + 16LL) = *(_QWORD *)(a2 + 64);
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) + 28LL) = *(_DWORD *)(a2 + 52);
      }
    }
    *(_QWORD *)(8LL * *(_QWORD *)(a2 + 24) + *(_QWORD *)(a2 + 40)) = a1;
    sub_8A47F(a2);
    result = a2;
    *(_DWORD *)(a2 + 80) = 1;
  }
  return result;
}

//----- (000000000008A47F) ----------------------------------------------------
__int64 __fastcall sub_8A47F(__int64 a1)
{
  __int64 v1; // ST10_8
  __int64 result; // rax

  v1 = a1;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 28LL);
  *(_QWORD *)(v1 + 64) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 40) + 8LL * *(_QWORD *)(v1 + 24)) + 16LL);
  *(_QWORD *)(v1 + 128) = *(_QWORD *)(v1 + 64);
  *(_QWORD *)(a1 + 8) = **(_QWORD **)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
  result = a1;
  *(_BYTE *)(v1 + 48) = **(_BYTE **)(v1 + 64);
  return result;
}

//----- (000000000008A526) ----------------------------------------------------
_DWORD *__fastcall sub_8A526(FILE *a1, int a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  _DWORD *v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v5 = sub_8B4E8(0x40uLL);
  if ( !v5 )
    sub_8AE04((__int64)"out of dynamic memory in yy_create_buffer()");
  v5[6] = a2;
  *((_QWORD *)v5 + 1) = sub_8B4E8(v5[6] + 2);
  if ( !*((_QWORD *)v5 + 1) )
    sub_8AE04((__int64)"out of dynamic memory in yy_create_buffer()");
  v5[8] = 1;
  sub_8A68F((__int64)v5, a1, v4);
  return v5;
}

//----- (000000000008A5E0) ----------------------------------------------------
void __fastcall sub_8A5E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  if ( a1 )
  {
    if ( *(_QWORD *)(a2 + 40) )
      v2 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
    else
      v2 = 0LL;
    if ( v2 == a1 )
      *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) = 0LL;
    if ( *(_DWORD *)(a1 + 32) )
      sub_8B53F(*(void **)(a1 + 8));
    sub_8B53F((void *)a1);
  }
}

//----- (000000000008A68F) ----------------------------------------------------
__int64 __fastcall sub_8A68F(__int64 a1, FILE *a2, __int64 a3)
{
  __int64 v3; // rax
  int v4; // eax
  _BOOL4 v5; // edx
  int *v6; // rdx
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-28h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]

  v8 = a3;
  v9 = *__errno_location();
  sub_8A769(a1, v8);
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 52) = 1;
  if ( *(_QWORD *)(v8 + 40) )
    v3 = *(_QWORD *)(*(_QWORD *)(v8 + 40) + 8LL * *(_QWORD *)(v8 + 24));
  else
    v3 = 0LL;
  if ( v3 != a1 )
  {
    *(_DWORD *)(a1 + 44) = 1;
    *(_DWORD *)(a1 + 48) = 0;
  }
  v5 = 0;
  if ( a2 )
  {
    v4 = fileno(a2);
    if ( isatty(v4) > 0 )
      v5 = 1;
  }
  *(_DWORD *)(a1 + 36) = v5;
  v6 = __errno_location();
  result = v9;
  *v6 = v9;
  return result;
}

//----- (000000000008A769) ----------------------------------------------------
__int64 __fastcall sub_8A769(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 28) = 0;
    **(_BYTE **)(a1 + 8) = 0;
    *(_BYTE *)(*(_QWORD *)(a1 + 8) + 1LL) = 0;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 56) = 0;
    if ( *(_QWORD *)(a2 + 40) )
      result = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
    else
      result = 0LL;
    if ( result == a1 )
      result = sub_8A47F(a2);
  }
  return result;
}

//----- (000000000008A81C) ----------------------------------------------------
unsigned __int64 __fastcall sub_8A81C(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax

  result = a2;
  if ( a1 )
  {
    sub_8AA59(a2);
    if ( *(_QWORD *)(a2 + 40) && *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) )
    {
      **(_BYTE **)(a2 + 64) = *(_BYTE *)(a2 + 48);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) + 16LL) = *(_QWORD *)(a2 + 64);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) + 28LL) = *(_DWORD *)(a2 + 52);
    }
    if ( *(_QWORD *)(a2 + 40) )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) )
        ++*(_QWORD *)(a2 + 24);
    }
    *(_QWORD *)(8LL * *(_QWORD *)(a2 + 24) + *(_QWORD *)(a2 + 40)) = a1;
    sub_8A47F(a2);
    result = a2;
    *(_DWORD *)(a2 + 80) = 1;
  }
  return result;
}

//----- (000000000008A94D) ----------------------------------------------------
__int64 __fastcall sub_8A94D(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rax

  result = *(_QWORD *)(a1 + 40);
  if ( result )
  {
    result = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
    if ( result )
    {
      if ( *(_QWORD *)(a1 + 40) )
        v2 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
      else
        v2 = 0LL;
      sub_8A5E0(v2, a1);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) = 0LL;
      if ( *(_QWORD *)(a1 + 24) )
        --*(_QWORD *)(a1 + 24);
      result = *(_QWORD *)(a1 + 40);
      if ( result )
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
        if ( result )
        {
          sub_8A47F(a1);
          result = a1;
          *(_DWORD *)(a1 + 80) = 1;
        }
      }
    }
  }
  return result;
}

//----- (000000000008AA59) ----------------------------------------------------
unsigned __int64 __fastcall sub_8AA59(unsigned __int64 a1)
{
  unsigned __int64 result; // rax
  signed __int64 v2; // [rsp+28h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 40) )
  {
    result = *(_QWORD *)(a1 + 32) - 1LL;
    if ( *(_QWORD *)(a1 + 24) >= result )
    {
      v2 = *(_QWORD *)(a1 + 32) + 8LL;
      *(_QWORD *)(a1 + 40) = sub_8B50E(*(void **)(a1 + 40), 8 * v2);
      if ( !*(_QWORD *)(a1 + 40) )
        sub_8AE04((__int64)"out of dynamic memory in yyensure_buffer_stack()");
      memset((void *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 32)), 0, 0x40uLL);
      result = a1;
      *(_QWORD *)(a1 + 32) = v2;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 40) = sub_8B4E8(8uLL);
    if ( !*(_QWORD *)(a1 + 40) )
      sub_8AE04((__int64)"out of dynamic memory in yyensure_buffer_stack()");
    memset(*(void **)(a1 + 40), 0, 8uLL);
    *(_QWORD *)(a1 + 32) = 1LL;
    result = a1;
    *(_QWORD *)(a1 + 24) = 0LL;
  }
  return result;
}

//----- (000000000008ABCE) ----------------------------------------------------
_DWORD *__fastcall sub_8ABCE(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // [rsp+8h] [rbp-28h]
  _DWORD *v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( a2 <= 1 || *(_BYTE *)(a2 - 2 + a1) || *(_BYTE *)(a2 - 1 + a1) )
    return 0LL;
  v5 = sub_8B4E8(0x40uLL);
  if ( !v5 )
    sub_8AE04((__int64)"out of dynamic memory in yy_scan_buffer()");
  v5[6] = a2 - 2;
  *((_QWORD *)v5 + 1) = a1;
  *((_QWORD *)v5 + 2) = *((_QWORD *)v5 + 1);
  v5[8] = 0;
  *(_QWORD *)v5 = 0LL;
  v5[7] = v5[6];
  v5[9] = 0;
  v5[10] = 1;
  v5[13] = 0;
  v5[14] = 0;
  sub_8A361((__int64)v5, v4);
  return v5;
}

//----- (000000000008ACE3) ----------------------------------------------------
_DWORD *__fastcall sub_8ACE3(const char *a1, unsigned __int64 a2)
{
  int v2; // eax

  v2 = strlen(a1);
  return sub_8AD15((__int64)a1, v2, a2);
}

//----- (000000000008AD15) ----------------------------------------------------
_DWORD *__fastcall sub_8AD15(__int64 a1, int a2, unsigned __int64 a3)
{
  _BYTE *v3; // rax
  unsigned __int64 v5; // [rsp+8h] [rbp-38h]
  int i; // [rsp+24h] [rbp-1Ch]
  _BYTE *v7; // [rsp+30h] [rbp-10h]
  _DWORD *v8; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v7 = sub_8B4E8(a2 + 2);
  if ( !v7 )
    sub_8AE04((__int64)"out of dynamic memory in yy_scan_bytes()");
  for ( i = 0; i < a2; ++i )
    v7[i] = *(_BYTE *)(i + a1);
  v3 = &v7[a2 + 1];
  *v3 = 0;
  v7[a2] = *v3;
  v8 = sub_8ABCE((__int64)v7, a2 + 2, v5);
  if ( !v8 )
    sub_8AE04((__int64)"bad buffer in yy_scan_bytes()");
  v8[8] = 1;
  return v8;
}

//----- (000000000008AE04) ----------------------------------------------------
void __fastcall __noreturn sub_8AE04(__int64 a1)
{
  fprintf(stderr, off_11F9B7, a1);
  exit(2);
}

//----- (000000000008AE48) ----------------------------------------------------
__int64 __fastcall sub_8AE48(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000000008AE61) ----------------------------------------------------
__int64 __fastcall sub_8AE61(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 40) && *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) )
    result = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 44LL);
  else
    result = 0LL;
  return result;
}

//----- (000000000008AEC3) ----------------------------------------------------
__int64 __fastcall sub_8AEC3(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 40) && *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) )
    result = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) + 48LL);
  else
    result = 0LL;
  return result;
}

//----- (000000000008AF25) ----------------------------------------------------
__int64 __fastcall sub_8AF25(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000008AF3F) ----------------------------------------------------
__int64 __fastcall sub_8AF3F(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (000000000008AF59) ----------------------------------------------------
__int64 __fastcall sub_8AF59(__int64 a1)
{
  return *(unsigned int *)(a1 + 56);
}

//----- (000000000008AF72) ----------------------------------------------------
__int64 __fastcall sub_8AF72(__int64 a1)
{
  return *(_QWORD *)(a1 + 128);
}

//----- (000000000008AF8F) ----------------------------------------------------
_QWORD *__fastcall sub_8AF8F(__int64 a1, _QWORD *a2)
{
  _QWORD *result; // rax

  result = a2;
  *a2 = a1;
  return result;
}

//----- (000000000008AFB1) ----------------------------------------------------
__int64 __fastcall sub_8AFB1(int a1, __int64 a2)
{
  __int64 result; // rax

  if ( !*(_QWORD *)(a2 + 40) || !*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) )
    sub_8AE04((__int64)"yyset_lineno called with no buffer");
  result = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
  *(_DWORD *)(result + 44) = a1;
  return result;
}

//----- (000000000008B02A) ----------------------------------------------------
__int64 __fastcall sub_8B02A(int a1, __int64 a2)
{
  __int64 result; // rax

  if ( !*(_QWORD *)(a2 + 40) || !*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24)) )
    sub_8AE04((__int64)"yyset_column called with no buffer");
  result = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL * *(_QWORD *)(a2 + 24));
  *(_DWORD *)(result + 48) = a1;
  return result;
}

//----- (000000000008B0A3) ----------------------------------------------------
__int64 __fastcall sub_8B0A3(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(a2 + 8) = a1;
  return result;
}

//----- (000000000008B0C6) ----------------------------------------------------
__int64 __fastcall sub_8B0C6(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(a2 + 16) = a1;
  return result;
}

//----- (000000000008B0E9) ----------------------------------------------------
__int64 __fastcall sub_8B0E9(__int64 a1)
{
  return *(unsigned int *)(a1 + 124);
}

//----- (000000000008B102) ----------------------------------------------------
__int64 __fastcall sub_8B102(int a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_DWORD *)(a2 + 124) = a1;
  return result;
}

//----- (000000000008B122) ----------------------------------------------------
__int64 __fastcall sub_8B122(__int64 a1)
{
  return *(_QWORD *)(a1 + 144);
}

//----- (000000000008B13F) ----------------------------------------------------
__int64 __fastcall sub_8B13F(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(a2 + 144) = a1;
  return result;
}

//----- (000000000008B165) ----------------------------------------------------
__int64 __fastcall sub_8B165(__int64 a1)
{
  return *(_QWORD *)(a1 + 152);
}

//----- (000000000008B182) ----------------------------------------------------
__int64 __fastcall sub_8B182(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(a2 + 152) = a1;
  return result;
}

//----- (000000000008B1A8) ----------------------------------------------------
__int64 __fastcall sub_8B1A8(void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    *a1 = sub_8B4E8(0xA0uLL);
    if ( *a1 )
    {
      memset(*a1, 0, 0xA0uLL);
      result = sub_8B330((__int64)*a1);
    }
    else
    {
      *__errno_location() = 12;
      result = 1LL;
    }
  }
  else
  {
    *__errno_location() = 22;
    result = 1LL;
  }
  return result;
}

//----- (000000000008B22E) ----------------------------------------------------
__int64 __fastcall sub_8B22E(__int64 a1, void **a2)
{
  __int64 result; // rax
  char v3; // [rsp+10h] [rbp-B0h]
  unsigned __int64 v4; // [rsp+B8h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  sub_8AF8F(a1, &v3);
  if ( a2 )
  {
    *a2 = sub_8B4E8(0xA0uLL);
    if ( *a2 )
    {
      memset(*a2, 0, 0xA0uLL);
      sub_8AF8F(a1, *a2);
      result = sub_8B330((__int64)*a2);
    }
    else
    {
      *__errno_location() = 12;
      result = 1LL;
    }
  }
  else
  {
    *__errno_location() = 22;
    result = 1LL;
  }
  return result;
}

//----- (000000000008B330) ----------------------------------------------------
__int64 __fastcall sub_8B330(__int64 a1)
{
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  return 0LL;
}

//----- (000000000008B3C7) ----------------------------------------------------
__int64 __fastcall sub_8B3C7(__int64 a1)
{
  __int64 v1; // rax

  while ( *(_QWORD *)(a1 + 40) && *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) )
  {
    if ( *(_QWORD *)(a1 + 40) )
      v1 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24));
    else
      v1 = 0LL;
    sub_8A5E0(v1, a1);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8LL * *(_QWORD *)(a1 + 24)) = 0LL;
    sub_8A94D(a1);
  }
  sub_8B53F(*(void **)(a1 + 40));
  *(_QWORD *)(a1 + 40) = 0LL;
  sub_8B53F(*(void **)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0LL;
  sub_8B330(a1);
  sub_8B53F((void *)a1);
  return 0LL;
}

//----- (000000000008B4E8) ----------------------------------------------------
void *__fastcall sub_8B4E8(size_t a1)
{
  return malloc(a1);
}

//----- (000000000008B50E) ----------------------------------------------------
void *__fastcall sub_8B50E(void *a1, size_t a2)
{
  return realloc(a1, a2);
}

//----- (000000000008B53F) ----------------------------------------------------
void __fastcall sub_8B53F(void *a1)
{
  free(a1);
}

//----- (000000000008B566) ----------------------------------------------------
signed __int64 __fastcall sub_8B566(void **a1, _QWORD *a2, __int64 a3, __int64 a4, void *a5, char *a6)
{
  unsigned int v6; // edi
  signed __int64 result; // rax
  void *ptr; // [rsp+8h] [rbp-28h]
  void **v9; // [rsp+28h] [rbp-8h]

  v9 = a1;
  ptr = a5;
  if ( *a2 )
  {
    if ( a6 )
      v6 = 2;
    else
      v6 = 0;
    sub_13937(*v9, 14, v6, a6, a3, a4, a6);
    free(ptr);
    result = 1LL;
  }
  else
  {
    *a2 = lydict_insert_zc(*a1, a5);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008B60F) ----------------------------------------------------
__int64 __fastcall sub_8B60F(void **a1, void *a2, unsigned int a3)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h]

  v4 = 0;
  if ( a3 == 309 )
  {
    a1[1] = (void *)lydict_insert_zc(*a1, a2);
  }
  else if ( a3 > 0x135 )
  {
    if ( a3 == 311 )
    {
      v4 = sub_8B566(a1, a1 + 22, (__int64)"namespace", (__int64)"module", a2, 0LL);
    }
    else
    {
      if ( a3 != 314 )
        goto LABEL_12;
      v4 = sub_8B566(a1, a1 + 5, (__int64)"organization", (__int64)"module", a2, 0LL);
    }
  }
  else
  {
    if ( a3 != 283 )
    {
LABEL_12:
      free(a2);
      sub_12222(
        (__int64)*a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
        68LL);
      return 1;
    }
    v4 = sub_8B566(a1, a1 + 6, (__int64)"contact", (__int64)"module", a2, 0LL);
  }
  return v4;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008B770) ----------------------------------------------------
__int64 __fastcall sub_8B770(__int64 a1, __int64 a2, const char *a3, int a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  char *s1; // [rsp+8h] [rbp-28h]
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  s1 = (char *)a3;
  v10 = 0;
  if ( a4 )
  {
    sub_13937(*(void **)a1, 14, 0, 0LL, (__int64)"yang version", (__int64)"module");
    v10 = 1;
  }
  else if ( !strcmp(a3, "1") )
  {
    if ( a2 )
    {
      if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) > 1 )
      {
        sub_13937(*(void **)a1, 42, 0, 0LL, v4, v5);
        v10 = 1;
      }
      *(_BYTE *)(a2 + 64) = *(_BYTE *)(a2 + 64) & 0xF1 | 2;
    }
    else
    {
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 64) & 0xF1 | 2;
    }
  }
  else if ( !strcmp(s1, "1.1") )
  {
    if ( a2 )
    {
      if ( (*(_BYTE *)(a1 + 64) & 0xE) != 4 )
      {
        sub_13937(*(void **)a1, 42, 0, 0LL, v6, v7);
        v10 = 1;
      }
      *(_BYTE *)(a2 + 64) = *(_BYTE *)(a2 + 64) & 0xF1 | 4;
    }
    else
    {
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 64) & 0xF1 | 4;
    }
  }
  else
  {
    sub_13937(*(void **)a1, 10, 0, 0LL, (__int64)s1, (__int64)"yang-version");
    v10 = 1;
  }
  free(s1);
  return v10;
}

//----- (000000000008B91C) ----------------------------------------------------
signed __int64 __fastcall sub_8B91C(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  char *ptr; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+2Ch] [rbp-4h]

  ptr = (char *)a3;
  if ( a2 || !(unsigned int)sub_3B812(*(void **)a1, a3, 6u, a1, 0LL, a6) )
  {
    if ( a2 )
      v8 = sub_8B566((void **)a1, (_QWORD *)(a2 + 8), (__int64)"prefix", (__int64)"import", ptr, 0LL);
    else
      v8 = sub_8B566((void **)a1, (_QWORD *)(a1 + 16), (__int64)"prefix", (__int64)"module", ptr, 0LL);
    result = v8;
  }
  else
  {
    free(ptr);
    result = 1LL;
  }
  return result;
}

//----- (000000000008B9EC) ----------------------------------------------------
_BOOL8 __fastcall sub_8B9EC(__int64 *a1, __int64 a2, __int64 *a3, void *a4, __int64 a5, __int64 a6)
{
  char *v6; // ST38_8
  __int64 v7; // r8
  __int64 v8; // r9
  int v9; // ST34_4
  __int64 v11; // [rsp+8h] [rbp-38h]
  void *ptr; // [rsp+10h] [rbp-30h]
  __int64 *dest; // [rsp+18h] [rbp-28h]

  dest = a3;
  ptr = a4;
  v11 = a5;
  if ( !*(_QWORD *)(a2 + 8) )
  {
    sub_13937((void *)*a1, 12, 0, 0LL, (__int64)"prefix", (__int64)"import");
LABEL_8:
    free(ptr);
    lydict_remove(*a1, *(_QWORD *)(a2 + 40));
    lydict_remove(*a1, *(_QWORD *)(a2 + 48));
    lydict_remove(*a1, *(_QWORD *)(a2 + 8));
    sub_AAE3B(*a1, *(void ****)(a2 + 32), *(unsigned __int8 *)(a2 + 27), 0LL);
    return 1LL;
  }
  if ( (unsigned int)sub_3B812((void *)*a1, *(const char **)(a2 + 8), 6u, (__int64)a1, 0LL, a6) )
    goto LABEL_8;
  memcpy(dest, (const void *)a2, 0x38uLL);
  v6 = (char *)lydict_insert_zc(*a1, ptr);
  v9 = sub_3D76E((__int64)a1, v6, (__int64)dest, (__int64)v6, v7, v8);
  lydict_remove(*a1, v6);
  ++*((_BYTE *)a1 + 69);
  return v9 || (unsigned int)sub_9554F(a1, dest + 4, *((unsigned __int8 *)dest + 27), (__int64)dest, v11);
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000008BBC1) ----------------------------------------------------
__int64 __fastcall sub_8BBC1(__int64 a1, __int64 a2, void *a3, __int64 a4, unsigned int a5)
{
  unsigned int v6; // [rsp+34h] [rbp-Ch]

  if ( a5 == 309 )
  {
    v6 = sub_8B566((void **)a1, (_QWORD *)(a1 + 24), (__int64)"description", (__int64)"module", a3, 0LL);
  }
  else if ( a5 > 0x135 )
  {
    if ( a5 == 325 )
    {
      v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 24), (__int64)"description", a4, a3, 0LL);
    }
    else
    {
      if ( a5 != 355 )
        return (unsigned int)sub_8B566((void **)a1, (_QWORD *)(a2 + 8), (__int64)"description", a4, a3, 0LL);
      v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 8), (__int64)"description", a4, a3, (char *)a2);
    }
  }
  else if ( a5 == 298 )
  {
    v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 40), (__int64)"description", a4, a3, 0LL);
  }
  else
  {
    if ( a5 != 299 )
      return (unsigned int)sub_8B566((void **)a1, (_QWORD *)(a2 + 8), (__int64)"description", a4, a3, 0LL);
    v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 32), (__int64)"description", a4, a3, 0LL);
  }
  return v6;
}

//----- (000000000008BD50) ----------------------------------------------------
__int64 __fastcall sub_8BD50(__int64 a1, __int64 a2, void *a3, __int64 a4, unsigned int a5)
{
  unsigned int v6; // [rsp+34h] [rbp-Ch]

  if ( a5 == 309 )
  {
    v6 = sub_8B566((void **)a1, (_QWORD *)(a1 + 32), (__int64)"reference", (__int64)"module", a3, 0LL);
  }
  else if ( a5 > 0x135 )
  {
    if ( a5 == 325 )
    {
      v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 32), (__int64)"reference", a4, a3, 0LL);
    }
    else
    {
      if ( a5 != 355 )
        return (unsigned int)sub_8B566((void **)a1, (_QWORD *)(a2 + 16), (__int64)"reference", a4, a3, 0LL);
      v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 16), (__int64)"reference", a4, a3, (char *)a2);
    }
  }
  else if ( a5 == 298 )
  {
    v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 48), (__int64)"reference", a4, a3, 0LL);
  }
  else
  {
    if ( a5 != 299 )
      return (unsigned int)sub_8B566((void **)a1, (_QWORD *)(a2 + 16), (__int64)"reference", a4, a3, 0LL);
    v6 = sub_8B566((void **)a1, (_QWORD *)(a2 + 40), (__int64)"reference", a4, a3, 0LL);
  }
  return v6;
}

//----- (000000000008BEDF) ----------------------------------------------------
_BOOL8 __fastcall sub_8BEDF(__int64 *a1, __int64 *a2, __int64 a3, const char *a4, __int64 a5, int a6)
{
  _BOOL8 result; // rax
  int v7; // ST34_4
  int v8; // [rsp+4h] [rbp-3Ch]
  __int64 v9; // [rsp+8h] [rbp-38h]
  char *s; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  char *v12; // [rsp+38h] [rbp-8h]

  v11 = a3;
  s = (char *)a4;
  v9 = a5;
  v8 = a6;
  if ( (a1[8] & 0xE) != 4 && (*a4 == 40 || strchr(a4, 32)) )
  {
    sub_13937((void *)*a1, 10, 0, 0LL, (__int64)s, (__int64)"if-feature");
    free(s);
    result = 1LL;
  }
  else
  {
    v12 = (char *)sub_A2CB(a1, s);
    if ( v12 )
    {
      free(s);
      v7 = sub_19120(a2, v12, v11, v8, v9);
      lydict_remove(*a1, v12);
      result = v7 != 0;
    }
    else
    {
      free(s);
      result = 1LL;
    }
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000008BFF3) ----------------------------------------------------
signed __int64 __fastcall sub_8BFF3(__int64 *a1, __int64 *a2, const char *a3, __int64 a4)
{
  char *ptr; // ST08_8
  signed __int64 result; // rax
  __int64 v6; // [rsp+0h] [rbp-30h]
  __int64 v7; // [rsp+28h] [rbp-8h]

  ptr = (char *)a3;
  v6 = a4;
  v7 = sub_9BED(a1, a3);
  free(ptr);
  if ( !v7 )
    return 1LL;
  if ( (unsigned int)sub_2AB62(a1, v6, a2, 0x100u, v7) == -1 )
  {
    lydict_remove(*a1, v7);
    result = 1LL;
  }
  else
  {
    lydict_remove(*a1, v7);
    result = 0LL;
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000008C09B) ----------------------------------------------------
__int64 __fastcall sub_8C09B(void **a1, __int64 a2, void *a3, __int64 a4, int a5)
{
  unsigned int v6; // [rsp+3Ch] [rbp-4h]

  if ( a5 == 288 )
    v6 = sub_8B566(a1, (_QWORD *)(a2 + 24), (__int64)"error_app_tag", a4, a3, 0LL);
  else
    v6 = sub_8B566(a1, (_QWORD *)(a2 + 32), (__int64)"error_message", a4, a3, 0LL);
  return v6;
}

//----- (000000000008C12B) ----------------------------------------------------
signed __int64 __fastcall sub_8C12B(void **a1, __int64 a2, void *a3)
{
  signed __int64 result; // rax
  void *ptr; // [rsp+8h] [rbp-18h]

  ptr = a3;
  if ( *(_QWORD *)(a2 + 136) )
  {
    sub_13937(*a1, 14, 2u, (char *)a2, (__int64)"presence", (__int64)"container");
    free(ptr);
    result = 1LL;
  }
  else
  {
    *(_QWORD *)(a2 + 136) = lydict_insert_zc(*a1, a3);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008C1C0) ----------------------------------------------------
_QWORD *__fastcall sub_8C1C0(__int64 *a1, __int64 a2, int a3, char *a4)
{
  __int64 v4; // r9
  void *v5; // ST00_8
  _QWORD *result; // rax
  const char *v7; // rax
  char *ptr; // [rsp+0h] [rbp-30h]
  int v9; // [rsp+Ch] [rbp-24h]
  _QWORD *v10; // [rsp+28h] [rbp-8h]

  v9 = a3;
  ptr = a4;
  v10 = calloc(1uLL, 0x28uLL);
  if ( v10 )
  {
    *v10 = sub_9BED(a1, ptr);
    if ( *v10 )
    {
      switch ( v9 )
      {
        case 259:
        case 353:
          if ( !*(_QWORD *)(a2 + 112) )
          {
            *(_QWORD *)(a2 + 112) = v10;
            goto LABEL_36;
          }
          if ( v9 == 259 )
            v7 = "anyxml";
          else
            v7 = "anydata";
          sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)v7, ptr);
          goto LABEL_37;
        case 276:
          if ( *(_QWORD *)(a2 + 80) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"augment", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 80) = v10;
          goto LABEL_36;
        case 280:
          if ( *(_QWORD *)(a2 + 104) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"case", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 104) = v10;
          goto LABEL_36;
        case 281:
          if ( *(_QWORD *)(a2 + 104) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"choice", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 104) = v10;
          goto LABEL_36;
        case 284:
          if ( *(_QWORD *)(a2 + 112) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"container", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 112) = v10;
          goto LABEL_36;
        case 302:
          if ( *(_QWORD *)(a2 + 112) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"leaf", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 112) = v10;
          goto LABEL_36;
        case 303:
          if ( *(_QWORD *)(a2 + 112) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"leaflist", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 112) = v10;
          goto LABEL_36;
        case 305:
          if ( *(_QWORD *)(a2 + 112) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"list", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 112) = v10;
          goto LABEL_36;
        case 334:
          if ( *(_QWORD *)(a2 + 104) )
          {
            sub_13937((void *)*a1, 14, 2u, (char *)a2, (__int64)"when", (__int64)"uses", ptr);
            goto LABEL_37;
          }
          *(_QWORD *)(a2 + 104) = v10;
LABEL_36:
          free(ptr);
          result = v10;
          break;
        case 356:
          *(_QWORD *)a2 = v10;
          goto LABEL_36;
        default:
          goto LABEL_37;
      }
    }
    else
    {
LABEL_37:
      free(ptr);
      lydict_remove(*a1, *v10);
      free(v10);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_when", v4, ptr);
    free(v5);
    result = 0LL;
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000008C5FD) ----------------------------------------------------
_QWORD *__fastcall sub_8C5FD(__int64 *a1, __int64 a2, signed __int64 a3, void *a4, unsigned int a5, int a6)
{
  __int64 v6; // r9
  _QWORD *result; // rax
  const char *v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  signed __int64 v11; // rax
  unsigned int v12; // [rsp+Ch] [rbp-34h]
  void *ptr; // [rsp+10h] [rbp-30h]
  signed __int64 v14; // [rsp+18h] [rbp-28h]
  _QWORD *v15; // [rsp+30h] [rbp-10h]

  v14 = a3;
  ptr = a4;
  v12 = a5;
  v15 = calloc(1uLL, a6);
  if ( v15 )
  {
    v8 = sub_8164(v12);
    sub_12312(2u, (__int64)"parsing %s statement \"%s\"", (__int64)v8, (__int64)ptr, v9, v10);
    *v15 = lydict_insert_zc(*a1, ptr);
    v15[6] = a1;
    *((_DWORD *)v15 + 14) = v12;
    v15[8] = a2;
    if ( a2 )
      v11 = a2 + 72;
    else
      v11 = v14;
    if ( *(_QWORD *)v11 )
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v11 + 88LL) + 80LL) = v15;
      *(_QWORD *)(*(_QWORD *)v11 + 88LL) = v15;
    }
    else
    {
      *(_QWORD *)v11 = v15;
      v15[11] = v15;
    }
    result = v15;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_node", v6);
    free(ptr);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008C74E) ----------------------------------------------------
__int64 __fastcall sub_8C74E(void **a1, __int64 a2, void *a3, int a4)
{
  unsigned int v5; // [rsp+2Ch] [rbp-4h]

  if ( a4 == 302 )
  {
    v5 = sub_8B566(a1, (_QWORD *)(a2 + 200), (__int64)"default", (__int64)"leaf", a3, (char *)a2);
  }
  else if ( a4 == 331 )
  {
    v5 = sub_8B566(a1, (_QWORD *)(a2 + 120), (__int64)"default", (__int64)"typedef", a3, 0LL);
  }
  else
  {
    free(a3);
    sub_12222(
      (__int64)*a1,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
      431LL);
    v5 = 1;
  }
  return v5;
}

//----- (000000000008C82F) ----------------------------------------------------
__int64 __fastcall sub_8C82F(void **a1, __int64 a2, void *a3, int a4)
{
  unsigned int v5; // [rsp+2Ch] [rbp-4h]

  switch ( a4 )
  {
    case 302:
      v5 = sub_8B566(a1, (_QWORD *)(a2 + 192), (__int64)"units", (__int64)"leaf", a3, (char *)a2);
      break;
    case 303:
      v5 = sub_8B566(a1, (_QWORD *)(a2 + 192), (__int64)"units", (__int64)"leaflist", a3, (char *)a2);
      break;
    case 331:
      v5 = sub_8B566(a1, (_QWORD *)(a2 + 40), (__int64)"units", (__int64)"typedef", a3, 0LL);
      break;
    case 339:
    case 341:
    case 346:
      v5 = sub_8B566(a1, (_QWORD *)(a2 + 48), (__int64)"units", (__int64)"deviate", a3, 0LL);
      break;
    default:
      free(a3);
      sub_12222(
        (__int64)*a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
        460LL);
      v5 = 1;
      break;
  }
  return v5;
}

//----- (000000000008C9A3) ----------------------------------------------------
_BOOL8 __fastcall sub_8C9A3(__int64 *a1, __int64 a2, __int64 a3)
{
  char *i; // rax
  __int64 v4; // r9
  __int64 v6; // [rsp+8h] [rbp-28h]
  char *s; // [rsp+20h] [rbp-10h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v8 = *(_QWORD *)(a2 + 136);
  for ( i = strpbrk(*(const char **)(a2 + 136), off_11FDF0); ; i = strpbrk(s, off_11FDF0) )
  {
    s = i;
    if ( !i )
      break;
    ++*(_BYTE *)(a2 + 30);
    while ( (*__ctype_b_loc())[*s] & 0x2000 )
      ++s;
  }
  ++*(_BYTE *)(a2 + 30);
  *(_QWORD *)(a2 + 160) = lydict_insert_zc(*a1, v8);
  *(_QWORD *)(a2 + 136) = calloc(*(unsigned __int8 *)(a2 + 30), 8uLL);
  if ( *(_QWORD *)(a2 + 136) )
    return (unsigned int)sub_2ABDE(a1, v6, (__int64 *)a2, 0x2000u, 0LL) == -1;
  sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_key", v4);
  return 1LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008CB00) ----------------------------------------------------
signed __int64 __fastcall sub_8CB00(__int64 *a1, char *a2, __int64 a3, const char *a4, __int64 a5)
{
  char *i; // rax
  __int64 v6; // r9
  __int64 *v7; // rbx
  __int64 v8; // r9
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+8h] [rbp-58h]
  char *l; // [rsp+10h] [rbp-50h]
  __int64 v13; // [rsp+18h] [rbp-48h]
  char v14; // [rsp+37h] [rbp-29h]
  signed int j; // [rsp+38h] [rbp-28h]
  signed int k; // [rsp+3Ch] [rbp-24h]
  char *s; // [rsp+40h] [rbp-20h]
  char *sa; // [rsp+40h] [rbp-20h]
  __int64 *v19; // [rsp+48h] [rbp-18h]

  v13 = a3;
  l = (char *)a4;
  v11 = a5;
  for ( i = strpbrk(a4, off_11FDF0); ; i = strpbrk(s, off_11FDF0) )
  {
    s = i;
    if ( !i )
      break;
    ++*(_BYTE *)(v13 + 8);
    while ( (*__ctype_b_loc())[*s] & 0x2000 )
      ++s;
  }
  *(_QWORD *)v13 = calloc((unsigned __int8)++*(_BYTE *)(v13 + 8), 8uLL);
  if ( *(_QWORD *)v13 )
  {
    for ( j = 0; j < *(unsigned __int8 *)(v13 + 8); ++j )
    {
      sa = strpbrk(l, off_11FDF0);
      if ( sa )
      {
        v14 = *sa;
        *sa = 0;
      }
      v7 = (__int64 *)(*(_QWORD *)v13 + 8LL * j);
      *v7 = sub_9BED(a1, l);
      if ( !*(_QWORD *)(8LL * j + *(_QWORD *)v13) )
      {
        sub_13937((void *)*a1, 10, 2u, a2, (__int64)l, (__int64)&off_11FDF0[4]);
        goto LABEL_34;
      }
      if ( sa )
        *sa = v14;
      for ( k = 0; k < j; ++k )
      {
        if ( *(_QWORD *)(8LL * k + *(_QWORD *)v13) == *(_QWORD *)(8LL * j + *(_QWORD *)v13) )
        {
          sub_13937((void *)*a1, 10, 2u, a2, *(_QWORD *)(8LL * j + *(_QWORD *)v13), (__int64)&off_11FDF0[4]);
          sub_13937((void *)*a1, -1, 2u, a2, (__int64)"The identifier is not unique", v8);
          goto LABEL_34;
        }
      }
      if ( v11 )
      {
        v19 = (__int64 *)malloc(0x18uLL);
        if ( !v19 )
        {
          sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_fill_unique", v9);
          goto LABEL_34;
        }
        *v19 = (__int64)a2;
        v19[1] = *(_QWORD *)(8LL * j + *(_QWORD *)v13);
        v19[2] = v13 + 9;
        if ( (unsigned int)sub_2ABDE(a1, v11, v19, 0x4000u, 0LL) == -1 )
          goto LABEL_34;
      }
      else if ( (unsigned int)sub_1F79E((__int64)a2, *(const char **)(8LL * j + *(_QWORD *)v13), (_BYTE *)(v13 + 9)) )
      {
        goto LABEL_34;
      }
      for ( l = sa; l && (*__ctype_b_loc())[*l] & 0x2000; ++l )
        ;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_fill_unique", v6);
LABEL_34:
    result = 1LL;
  }
  return result;
}

//----- (000000000008CED8) ----------------------------------------------------
signed __int64 __fastcall sub_8CED8(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  unsigned __int8 i; // [rsp+27h] [rbp-9h]
  void *ptr; // [rsp+28h] [rbp-8h]

  v4 = a3;
  for ( i = 0; ; ++i )
  {
    if ( i >= *(_BYTE *)(a2 + 31) )
      return 0LL;
    ptr = *(void **)(16LL * i + *(_QWORD *)(a2 + 144));
    if ( (unsigned int)sub_8CB00(
                         a1,
                         (char *)a2,
                         *(_QWORD *)(a2 + 144) + 16LL * i,
                         *(const char **)(16LL * i + *(_QWORD *)(a2 + 144)),
                         v4) )
      break;
    free(ptr);
  }
  free(ptr);
  return 1LL;
}

//----- (000000000008CF89) ----------------------------------------------------
signed __int64 __fastcall sub_8CF89(void **a1, __int64 a2, void *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  void *ptr; // [rsp+8h] [rbp-28h]

  ptr = a3;
  if ( *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 4) != 9 )
  {
    sub_13937(*a1, 5, 0, 0LL, (__int64)"require-instance", a6);
  }
  else
  {
    if ( !*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) )
    {
      v6 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(v6 + 32) = lydict_insert_zc(*a1, a3);
      *(_DWORD *)(a2 + 4) = 9;
      return 0LL;
    }
    sub_13937(*a1, 14, 0, 0LL, (__int64)"path", (__int64)"type");
  }
  free(ptr);
  return 1LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008D071) ----------------------------------------------------
signed __int64 __fastcall sub_8D071(void *a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax

  if ( *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 4) != 9 )
  {
    sub_13937(a1, 5, 0, 0LL, (__int64)"require-instance", a6);
    result = 1LL;
  }
  else if ( *(_BYTE *)(*(_QWORD *)(a2 + 16) + 48LL) )
  {
    sub_13937(a1, 14, 0, 0LL, (__int64)"require-instance", (__int64)"type");
    result = 1LL;
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + 48LL) = a3;
    *(_DWORD *)(a2 + 4) = 9;
    result = 0LL;
  }
  return result;
}

//----- (000000000008D12E) ----------------------------------------------------
__int64 __fastcall sub_8D12E(__int64 a1, char *a2, __int64 a3, int *a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  const char *v8; // STA0_8
  __int16 v9; // dx
  __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-E0h]
  unsigned int v12; // [rsp+Ch] [rbp-D4h]
  int *v13; // [rsp+10h] [rbp-D0h]
  __int64 v14; // [rsp+18h] [rbp-C8h]
  char v15; // [rsp+3Fh] [rbp-A1h]
  unsigned int v16; // [rsp+40h] [rbp-A0h]
  unsigned int v17; // [rsp+44h] [rbp-9Ch]
  unsigned int n; // [rsp+44h] [rbp-9Ch]
  unsigned int j; // [rsp+44h] [rbp-9Ch]
  int l; // [rsp+44h] [rbp-9Ch]
  unsigned int jj; // [rsp+44h] [rbp-9Ch]
  unsigned int ii; // [rsp+48h] [rbp-98h]
  unsigned int k; // [rsp+48h] [rbp-98h]
  unsigned int m; // [rsp+48h] [rbp-98h]
  unsigned int v25; // [rsp+4Ch] [rbp-94h]
  int v26; // [rsp+50h] [rbp-90h]
  int v27; // [rsp+54h] [rbp-8Ch]
  const char *v28; // [rsp+58h] [rbp-88h]
  char *v29; // [rsp+58h] [rbp-88h]
  const char *v30; // [rsp+60h] [rbp-80h]
  __int64 i; // [rsp+68h] [rbp-78h]
  signed __int64 v32; // [rsp+70h] [rbp-70h]
  signed __int64 v33; // [rsp+70h] [rbp-70h]
  unsigned __int64 v34; // [rsp+70h] [rbp-70h]
  signed __int64 kk; // [rsp+70h] [rbp-70h]
  void *v36; // [rsp+78h] [rbp-68h]
  __int64 v37; // [rsp+80h] [rbp-60h]
  __int64 v38; // [rsp+88h] [rbp-58h]
  char *v39; // [rsp+90h] [rbp-50h]
  _QWORD *ptr; // [rsp+98h] [rbp-48h]
  char dest; // [rsp+A0h] [rbp-40h]
  unsigned __int64 v42; // [rsp+D8h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  v42 = __readfsqword(0x28u);
  v36 = *(void **)a1;
  v16 = -1;
  v30 = 0LL;
  v25 = 0;
  v39 = (char *)sub_9BED((__int64 *)a1, *(const char **)(a3 + 8));
  if ( !v39 )
  {
LABEL_186:
    if ( v25 )
      *v13 = v26;
    return v16;
  }
  v17 = sub_16564(v39);
  if ( !v17 )
  {
    sub_13937(v36, 55, 0, 0LL, (unsigned int)*v39, (__int64)v39, v11);
    lydict_remove(v36, v39);
    goto LABEL_186;
  }
  v28 = v39;
  if ( v39[v17] )
  {
    v30 = (const char *)lydict_insert(v36, v39, v17);
    v29 = &v39[v17];
    if ( *v29 != 58 || !(unsigned int)sub_16564(v29 + 1) )
    {
      sub_13937(v36, 55, 0, 0LL, (unsigned int)*v29, (__int64)v29, v11);
      lydict_remove(v36, v30);
      lydict_remove(v36, v39);
      goto LABEL_186;
    }
    v28 = v29 + 1;
  }
  v27 = sub_1E65A(v28, v30, a1, (__int64)a2, (signed __int64 *)v13 + 2);
  if ( v27 == -1 )
  {
    sub_13937(v36, 28, 0, 0LL, (__int64)v30, v6, v11);
    lydict_remove(v36, v30);
    lydict_remove(v36, v39);
    goto LABEL_186;
  }
  if ( v27 == 1 )
  {
    sub_13937(v36, 46, 0, 0LL, (__int64)"type", (__int64)v28, v11);
    lydict_remove(v36, v30);
    lydict_remove(v36, v39);
    v16 = 1;
    goto LABEL_186;
  }
  lydict_remove(v36, v30);
  lydict_remove(v36, v39);
  if ( *((_BYTE *)v13 + 4) < 0 )
  {
    for ( i = (__int64)a2; i && *(_DWORD *)(i + 56) != 2048; i = lys_parent(i) )
      ;
    if ( !i )
    {
      sub_12222(
        (__int64)v36,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
        687LL,
        v11);
      goto LABEL_186;
    }
    if ( !*(_WORD *)(i + 28) )
      __assert_fail(
        "((struct lys_node_grp *)siter)->unres_count",
        "/home/mantovan/Repositories/libyang/src/parser_yang.c",
        0x2ACu,
        "yang_check_type");
    --*(_WORD *)(i + 28);
    *((_BYTE *)v13 + 4) &= 0x7Fu;
  }
  if ( (unsigned int)sub_3C749(
                       *(_WORD *)(*((_QWORD *)v13 + 3) + 24LL),
                       *(void ***)(*((_QWORD *)v13 + 3) + 48LL),
                       **((_QWORD **)v13 + 3),
                       *(_WORD *)(*((_QWORD *)v13 + 2) + 24LL),
                       *(_QWORD *)(*((_QWORD *)v13 + 2) + 48LL),
                       **((_QWORD **)v13 + 2),
                       a2) )
    goto LABEL_186;
  v25 = *(_DWORD *)(v14 + 4);
  v26 = *v13;
  *v13 = *(_DWORD *)(*((_QWORD *)v13 + 2) + 56LL);
  if ( !v25 )
    v25 = *(_DWORD *)(*((_QWORD *)v13 + 2) + 56LL);
  switch ( (unsigned __int64)v25 )
  {
    case 2uLL:
      if ( *v13 != 2 )
      {
        sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
        goto LABEL_186;
      }
      v33 = *((_QWORD *)v13 + 2) + 56LL;
      if ( *(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
      {
        while ( !*(_DWORD *)(v33 + 40) )
          v33 = *(_QWORD *)(v33 + 16) + 56LL;
        if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 && v13[10] )
        {
          sub_13937(v36, 5, 0, 0LL, (__int64)"bit", v7, v11);
          goto LABEL_186;
        }
        v38 = *(_QWORD *)(v33 + 32);
        for ( j = 0; j < v13[10]; ++j )
        {
          for ( k = 0;
                k < *(_DWORD *)(v33 + 40) && *(_QWORD *)(48LL * k + v38) != *(_QWORD *)(*((_QWORD *)v13 + 4) + 48LL * j);
                ++k )
          {
            ;
          }
          if ( k == *(_DWORD *)(v33 + 40) )
          {
            sub_13937(v36, 25, 0, 0LL, *(_QWORD *)(*((_QWORD *)v13 + 4) + 48LL * j), v7, v11);
            goto LABEL_186;
          }
          if ( *(_WORD *)(*((_QWORD *)v13 + 4) + 48LL * j + 24) & 1 )
          {
            *(_DWORD *)(*((_QWORD *)v13 + 4) + 48LL * j + 28) = *(_DWORD *)(48LL * k + v38 + 28);
          }
          else if ( *(_DWORD *)(*((_QWORD *)v13 + 4) + 48LL * j + 28) != *(_DWORD *)(48LL * k + v38 + 28) )
          {
            sub_13937(
              v36,
              24,
              0,
              0LL,
              *(unsigned int *)(*((_QWORD *)v13 + 4) + 48LL * j + 28),
              *(_QWORD *)(*((_QWORD *)v13 + 4) + 48LL * j),
              *(unsigned int *)(48LL * k + v38 + 28));
            goto LABEL_186;
          }
        }
      }
      else if ( !v13[10] )
      {
        sub_13937(v36, 12, 0, 0LL, (__int64)"bit", (__int64)"type", v11);
        goto LABEL_186;
      }
      for ( l = v13[10]; l; --l )
      {
        for ( m = l - 1;
              m
           && *(_DWORD *)(*((_QWORD *)v13 + 4) + 48LL * (m - 1) + 28) > *(_DWORD *)(*((_QWORD *)v13 + 4) + 48LL * m + 28);
              --m )
        {
          memcpy(&dest, (const void *)(48LL * m + *((_QWORD *)v13 + 4)), 0x30uLL);
          memcpy(
            (void *)(*((_QWORD *)v13 + 4) + 48LL * m),
            (const void *)(*((_QWORD *)v13 + 4) + 48LL * (m - 1)),
            0x30uLL);
          memcpy((void *)(*((_QWORD *)v13 + 4) + 48LL * (m - 1)), &dest, 0x30uLL);
        }
      }
      goto LABEL_180;
    case 4uLL:
      if ( *v13 == 4 )
      {
        if ( !*((_BYTE *)v13 + 40) && !*(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
        {
          sub_13937(v36, 12, 0, 0LL, (__int64)"fraction-digits", (__int64)"type", v11);
          goto LABEL_186;
        }
        if ( *((_BYTE *)v13 + 40) && *(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
        {
          sub_13937(v36, 5, 0, 0LL, (__int64)"fraction-digits", v7, v11);
          goto LABEL_186;
        }
        if ( *(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
        {
          *((_BYTE *)v13 + 40) = *(_BYTE *)(*((_QWORD *)v13 + 2) + 96LL);
          *((_QWORD *)v13 + 6) = *(_QWORD *)(*((_QWORD *)v13 + 2) + 104LL);
        }
        if ( *((_QWORD *)v13 + 4) && (unsigned int)sub_36896(v36, **((char ***)v13 + 4), v13) )
        {
          sub_13937(v36, 10, 0, 0LL, **((_QWORD **)v13 + 4), (__int64)"range", v11);
          goto LABEL_186;
        }
      }
      else
      {
        if ( (unsigned int)*v13 <= 0xB || (unsigned int)*v13 > 0x13 )
        {
          sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
          goto LABEL_186;
        }
        if ( *((_BYTE *)v13 + 40) )
        {
          sub_13937(v36, -1, 0, 0LL, (__int64)"Numerical type could not include fraction statement.", v7, v11);
          goto LABEL_186;
        }
        *((_QWORD *)v13 + 4) = *((_QWORD *)v13 + 4);
        if ( *((_QWORD *)v13 + 4) && (unsigned int)sub_36896(v36, **((char ***)v13 + 4), v13) )
        {
          sub_13937(v36, 10, 0, 0LL, **((_QWORD **)v13 + 4), (__int64)"range", v11);
          goto LABEL_186;
        }
      }
      goto LABEL_180;
    case 6uLL:
      if ( *v13 != 6 )
      {
        sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
        goto LABEL_186;
      }
      v32 = *((_QWORD *)v13 + 2) + 56LL;
      if ( !*(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
      {
        if ( v13[10] )
          goto LABEL_180;
        sub_13937(v36, 12, 0, 0LL, (__int64)"enum", (__int64)"type", v11);
        goto LABEL_186;
      }
      while ( !*(_DWORD *)(v32 + 40) )
        v32 = *(_QWORD *)(v32 + 16) + 56LL;
      if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 && v13[10] )
      {
        sub_13937(v36, 5, 0, 0LL, (__int64)"enum", v7, v11);
        goto LABEL_186;
      }
      v37 = *(_QWORD *)(v32 + 32);
      for ( n = 0; n < v13[10]; ++n )
      {
        for ( ii = 0;
              ii < *(_DWORD *)(v32 + 40) && *(_QWORD *)(48LL * ii + v37) != *(_QWORD *)(*((_QWORD *)v13 + 4) + 48LL * n);
              ++ii )
        {
          ;
        }
        if ( ii == *(_DWORD *)(v32 + 40) )
        {
          sub_13937(v36, 20, 0, 0LL, *(_QWORD *)(*((_QWORD *)v13 + 4) + 48LL * n), v7, v11);
          goto LABEL_186;
        }
        if ( *(_WORD *)(*((_QWORD *)v13 + 4) + 48LL * n + 24) & 1 )
        {
          *(_DWORD *)(*((_QWORD *)v13 + 4) + 48LL * n + 28) = *(_DWORD *)(48LL * ii + v37 + 28);
        }
        else if ( *(_DWORD *)(*((_QWORD *)v13 + 4) + 48LL * n + 28) != *(_DWORD *)(48LL * ii + v37 + 28) )
        {
          sub_13937(
            v36,
            19,
            0,
            0LL,
            *(unsigned int *)(*((_QWORD *)v13 + 4) + 48LL * n + 28),
            *(_QWORD *)(*((_QWORD *)v13 + 4) + 48LL * n),
            *(unsigned int *)(48LL * ii + v37 + 28));
          goto LABEL_186;
        }
      }
      goto LABEL_180;
    case 7uLL:
      if ( *v13 != 7 )
      {
        sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
        goto LABEL_186;
      }
      if ( *(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
      {
        if ( !*((_QWORD *)v13 + 4) )
          goto LABEL_180;
        sub_13937(v36, 5, 0, 0LL, (__int64)"base", v7, v11);
      }
      else
      {
        if ( *((_QWORD *)v13 + 4) )
          goto LABEL_180;
        sub_13937(v36, 12, 0, 0LL, (__int64)"base", (__int64)"type", v11);
      }
      goto LABEL_186;
    case 9uLL:
      if ( *v13 == 8 )
      {
        if ( *((_QWORD *)v13 + 4) )
        {
          sub_13937(v36, 5, 0, 0LL, (__int64)"path", v7, v11);
          goto LABEL_186;
        }
        v15 = *((_BYTE *)v13 + 48);
        if ( v15 )
          *((_BYTE *)v13 + 32) = v15;
        goto LABEL_180;
      }
      if ( *v13 != 9 )
      {
        sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
        goto LABEL_186;
      }
      if ( *((_BYTE *)v13 + 48) && ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
      {
        sub_13937(v36, 5, 0, 0LL, (__int64)"require-instance", v7, v11);
        goto LABEL_186;
      }
      if ( !v12 && (unsigned int)sub_A3FB0((__int64)a2) )
        v12 = 1;
      if ( *(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
      {
        if ( *((_QWORD *)v13 + 4) )
        {
          sub_13937(v36, 5, 0, 0LL, (__int64)"path", v7, v11);
          goto LABEL_186;
        }
        if ( *((_BYTE *)v13 + 48) )
        {
          sub_13937(v36, 5, 0, 0LL, (__int64)"require-instance", v7, v11);
          goto LABEL_186;
        }
      }
      if ( *((_QWORD *)v13 + 4) )
      {
        v8 = (const char *)*((_QWORD *)v13 + 4);
        *((_QWORD *)v13 + 4) = sub_9BED((__int64 *)a1, v8);
        lydict_remove(v36, v8);
        if ( *((_QWORD *)v13 + 4)
          && (v12 || (unsigned int)sub_2ABDE((__int64 *)a1, v11, (__int64 *)v13, 0x20u, (__int64 *)a2) != -1) )
        {
          goto LABEL_180;
        }
      }
      else
      {
        if ( !*(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
        {
          sub_13937(v36, 12, 0, 0LL, (__int64)"path", (__int64)"type", v11);
          goto LABEL_186;
        }
        *((_QWORD *)v13 + 4) = lydict_insert(v36, *(_QWORD *)(*((_QWORD *)v13 + 2) + 88LL), 0LL);
        *((_BYTE *)v13 + 48) = *(_BYTE *)(*((_QWORD *)v13 + 2) + 104LL);
        if ( v12 || (unsigned int)sub_2ABDE((__int64 *)a1, v11, (__int64 *)v13, 0x20u, (__int64 *)a2) != -1 )
          goto LABEL_180;
      }
      goto LABEL_186;
    case 0xAuLL:
      if ( *v13 == 1 )
      {
        if ( v13[12] )
        {
          sub_13937(v36, -1, 0, 0LL, (__int64)"Binary type could not include pattern statement.", v7, v11);
          goto LABEL_186;
        }
        *((_QWORD *)v13 + 4) = *((_QWORD *)v13 + 4);
        if ( *((_QWORD *)v13 + 4) && (unsigned int)sub_36896(v36, **((char ***)v13 + 4), v13) )
        {
          sub_13937(v36, 10, 0, 0LL, **((_QWORD **)v13 + 4), (__int64)"length", v11);
          goto LABEL_186;
        }
      }
      else
      {
        if ( *v13 != 10 )
        {
          sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
          goto LABEL_186;
        }
        if ( *((_QWORD *)v13 + 4) && (unsigned int)sub_36896(v36, **((char ***)v13 + 4), v13) )
        {
          sub_13937(v36, 10, 0, 0LL, **((_QWORD **)v13 + 4), (__int64)"length", v11);
          goto LABEL_186;
        }
      }
      goto LABEL_180;
    case 0xBuLL:
      if ( *v13 != 11 )
      {
        sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
        goto LABEL_186;
      }
      if ( *((_QWORD *)v13 + 4) )
      {
        for ( jj = 0; jj < v13[10]; ++jj )
        {
          v34 = ((unsigned __int64)jj << 6) + *((_QWORD *)v13 + 4);
          if ( !*(_DWORD *)v34 )
          {
            ptr = *(_QWORD **)(v34 + 16);
            *(_QWORD *)(v34 + 16) = 0LL;
            *(_QWORD *)(v34 + 24) = *((_QWORD *)v13 + 3);
            if ( (unsigned int)sub_8D12E(a1, a2, ptr, v34, v12, v11) )
            {
              *(_QWORD *)(v34 + 16) = ptr;
              v16 = 1;
              *v13 = v26;
              v25 = 0;
              goto LABEL_186;
            }
            lydict_remove(v36, ptr[1]);
            free(ptr);
          }
          if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 )
          {
            if ( *(_DWORD *)v34 == 5 )
            {
              sub_13937(v36, 10, 0, 0LL, (__int64)"empty", *(_QWORD *)(v14 + 8), v11);
              goto LABEL_186;
            }
            if ( *(_DWORD *)v34 == 9 )
            {
              sub_13937(v36, 10, 0, 0LL, (__int64)"leafref", *(_QWORD *)(v14 + 8), v11);
              goto LABEL_186;
            }
          }
          if ( *(_DWORD *)v34 == 8 || *(_DWORD *)v34 == 9 || *(_DWORD *)v34 == 11 && *(_DWORD *)(v34 + 44) )
            v13[11] = 1;
        }
      }
      else
      {
        if ( !*(_QWORD *)(*((_QWORD *)v13 + 2) + 72LL) )
        {
          sub_13937(v36, 12, 0, 0LL, (__int64)"type", (__int64)"(union) type", v11);
          goto LABEL_186;
        }
        if ( *(_DWORD *)(*((_QWORD *)v13 + 2) + 56LL) != 11 )
          __assert_fail(
            "type->der->type.base == LY_TYPE_UNION",
            "/home/mantovan/Repositories/libyang/src/parser_yang.c",
            0x3CDu,
            "yang_check_type");
        v13[11] = *(_DWORD *)(*((_QWORD *)v13 + 2) + 100LL);
      }
      goto LABEL_180;
    default:
      if ( !v25 || v25 > 0x13 )
      {
        sub_12222(
          (__int64)v36,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
          1020LL,
          v11);
        goto LABEL_186;
      }
      if ( v25 != *v13 )
      {
        sub_13937(v36, -1, 0, 0LL, (__int64)"Invalid restriction in type \"%s\".", **((_QWORD **)v13 + 3), v11);
        goto LABEL_186;
      }
LABEL_180:
      for ( kk = *((_QWORD *)v13 + 2) + 56LL; *(_QWORD *)(kk + 16); kk = *(_QWORD *)(kk + 16) + 56LL )
      {
        if ( *(_WORD *)(*(_QWORD *)(kk + 24) + 24LL) & 0x2000 )
        {
          v9 = *(_WORD *)(*((_QWORD *)v13 + 3) + 24LL);
          HIBYTE(v9) |= 0x20u;
          *(_WORD *)(*((_QWORD *)v13 + 3) + 24LL) = v9;
        }
      }
      result = 0LL;
      break;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000008EB71) ----------------------------------------------------
__int64 __fastcall sub_8EB71(__int64 a1, __int64 a2)
{
  _DWORD *ptr; // ST28_8
  __int64 result; // rax
  unsigned int i; // [rsp+1Ch] [rbp-14h]
  unsigned __int64 v5; // [rsp+20h] [rbp-10h]

  for ( i = 0; ; ++i )
  {
    result = *(unsigned int *)(a2 + 40);
    if ( i >= (unsigned int)result )
      break;
    v5 = ((unsigned __int64)i << 6) + *(_QWORD *)(a2 + 32);
    if ( *(_DWORD *)v5 )
    {
      if ( *(_DWORD *)v5 == 11 )
        sub_8EB71(a1, v5);
    }
    else
    {
      ptr = *(_DWORD **)(v5 + 16);
      *(_DWORD *)v5 = ptr[1];
      lydict_remove(a1, *((_QWORD *)ptr + 1));
      free(ptr);
    }
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000008EC20) ----------------------------------------------------
_QWORD *__fastcall sub_8EC20(void *a1, __int64 a2, void *a3, unsigned int a4)
{
  __int64 v4; // r9
  __int64 v6; // r9
  unsigned int v7; // [rsp+4h] [rbp-2Ch]
  void *ptr; // [rsp+8h] [rbp-28h]
  _QWORD *v9; // [rsp+20h] [rbp-10h]

  ptr = a3;
  v7 = a4;
  v9 = calloc(1uLL, 0x18uLL);
  if ( !v9 )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_type", v4);
    return 0LL;
  }
  *(_BYTE *)v9 = -128;
  if ( v7 == 303 )
  {
    if ( *(_QWORD *)(a2 + 144) )
    {
      sub_13937(a1, 14, 2u, (char *)a2, (__int64)"type", (__int64)"leaf-list");
      goto LABEL_29;
    }
    *(_QWORD *)(a2 + 144) = v9;
    *(_QWORD *)(a2 + 152) = a2;
    v9[2] = a2 + 128;
LABEL_28:
    v9[1] = lydict_insert_zc(a1, ptr);
    return v9;
  }
  if ( v7 > 0x12F )
  {
    switch ( v7 )
    {
      case 0x15Au:
        if ( *(_QWORD *)(a2 + 40) )
        {
          sub_13937(a1, 14, 0, 0LL, (__int64)"type", (__int64)"deviation");
          goto LABEL_29;
        }
        *(_QWORD *)(a2 + 40) = calloc(1uLL, 0x40uLL);
        if ( !*(_QWORD *)(a2 + 40) )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_type", v6);
          goto LABEL_29;
        }
        *(_QWORD *)(*(_QWORD *)(a2 + 40) + 16LL) = v9;
        v9[2] = *(_QWORD *)(a2 + 40);
        break;
      case 0x164u:
        *(_QWORD *)(a2 + 16) = v9;
        v9[2] = a2;
        break;
      case 0x14Bu:
        if ( *(_QWORD *)(a2 + 72) )
        {
          sub_13937(a1, 14, 0, 0LL, (__int64)"type", (__int64)"typedef");
          goto LABEL_29;
        }
        *(_QWORD *)(a2 + 72) = v9;
        v9[2] = a2 + 56;
        break;
      default:
        goto LABEL_29;
    }
    goto LABEL_28;
  }
  if ( v7 == 258 )
  {
    *(_QWORD *)(a2 + 16) = v9;
    v9[2] = a2;
    goto LABEL_28;
  }
  if ( v7 != 302 )
    goto LABEL_29;
  if ( !*(_QWORD *)(a2 + 144) )
  {
    *(_QWORD *)(a2 + 144) = v9;
    *(_QWORD *)(a2 + 152) = a2;
    v9[2] = a2 + 128;
    goto LABEL_28;
  }
  sub_13937(a1, 14, 2u, (char *)a2, (__int64)"type", (__int64)"leaf");
LABEL_29:
  free(ptr);
  free(v9);
  return 0LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008EF69) ----------------------------------------------------
_QWORD *__fastcall sub_8EF69(void *a1, __int64 a2, void *a3, int a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 v7; // r9
  void *ptr; // [rsp+8h] [rbp-28h]
  _QWORD *v10; // [rsp+28h] [rbp-8h]

  ptr = a3;
  if ( a4 )
  {
    v10 = (_QWORD *)a2;
LABEL_12:
    *v10 = lydict_insert_zc(a1, ptr);
    return v10;
  }
  if ( *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 4) != 10 )
  {
    sub_13937(a1, -1, 0, 0LL, (__int64)"Unexpected length statement.", a6);
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 10;
    if ( *(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) )
    {
      sub_13937(a1, 14, 0, 0LL, (__int64)"length", (__int64)"type");
    }
    else
    {
      v6 = calloc(1uLL, 0x38uLL);
      v10 = v6;
      if ( v6 )
      {
        *(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) = v6;
        goto LABEL_12;
      }
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_length", v7);
    }
  }
  free(ptr);
  return 0LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008F0AF) ----------------------------------------------------
signed __int64 __fastcall sub_8F0AF(void *a1, _QWORD *a2, __int64 a3, const char *a4, char a5)
{
  signed __int64 result; // rax
  size_t v6; // ST30_8
  __int64 v7; // r9
  char v8; // [rsp+Ch] [rbp-34h]
  char *ptr; // [rsp+10h] [rbp-30h]
  _BYTE *v10; // [rsp+38h] [rbp-8h]

  ptr = (char *)a4;
  v8 = a5;
  if ( a3 && (unsigned int)sub_372F0(a1, a4, (void **)a3, (_QWORD *)(a3 + 8)) )
  {
    free(ptr);
    result = 1LL;
  }
  else
  {
    v6 = strlen(ptr);
    v10 = malloc(v6 + 2);
    if ( v10 )
    {
      *v10 = v8;
      strcpy(v10 + 1, ptr);
      free(ptr);
      *a2 = lydict_insert_zc(a1, v10);
      result = 0LL;
    }
    else
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_pattern", v7);
      free(ptr);
      result = 1LL;
    }
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008F1C2) ----------------------------------------------------
_QWORD *__fastcall sub_8F1C2(void *a1, __int64 a2, void *a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *ptr; // [rsp+8h] [rbp-28h]
  _QWORD *v9; // [rsp+28h] [rbp-8h]

  ptr = a3;
  if ( a4 )
  {
    v9 = (_QWORD *)a2;
LABEL_11:
    *v9 = lydict_insert_zc(a1, ptr);
    return v9;
  }
  if ( *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 4) != 4 )
  {
    sub_13937(a1, -1, 0, 0LL, (__int64)"Unexpected range statement.", a6);
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 4;
    if ( *(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) )
    {
      sub_13937(a1, 14, 0, 0LL, (__int64)"range", (__int64)"type");
    }
    else
    {
      v9 = calloc(1uLL, 0x38uLL);
      if ( v9 )
      {
        *(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) = v9;
        goto LABEL_11;
      }
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_range", v6);
    }
  }
  free(ptr);
  return 0LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008F306) ----------------------------------------------------
signed __int64 __fastcall sub_8F306(void *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  if ( *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 4) != 4 )
  {
    sub_13937(a1, -1, 0, 0LL, (__int64)"Unexpected fraction-digits statement.", a6);
    return 1LL;
  }
  *(_DWORD *)(a2 + 4) = 4;
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 16) + 40LL) )
  {
    sub_13937(a1, 14, 0, 0LL, (__int64)"fraction-digits", (__int64)"type");
    return 1LL;
  }
  if ( !a3 || a3 > 0x12 )
  {
    sub_13937(a1, -1, 0, 0LL, (__int64)"Invalid value \"%d\" of \"%s\".", a3, "fraction-digits");
    return 1LL;
  }
  *(_BYTE *)(*(_QWORD *)(a2 + 16) + 40LL) = a3;
  *(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) = 10LL;
  for ( i = 1; i < a3; ++i )
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) *= 10LL;
  return 0LL;
}

//----- (000000000008F45D) ----------------------------------------------------
signed __int64 __fastcall sub_8F45D(void *a1, __int64 a2, __int64 *a3, _BYTE *a4)
{
  __int64 v4; // r9
  void *v5; // ST00_8
  __int64 v6; // r9
  const unsigned __int16 *v7; // rbx
  __int64 v8; // r12
  void *ptr; // [rsp+0h] [rbp-40h]
  __int64 *v11; // [rsp+8h] [rbp-38h]
  int i; // [rsp+28h] [rbp-18h]

  v11 = a3;
  ptr = a4;
  *(_DWORD *)(a2 + 4) = 6;
  if ( !*a4 )
  {
    sub_13937(a1, 10, 0, 0LL, (__int64)a4, (__int64)"enum name", a4);
    sub_13937(a1, -1, 0, 0LL, (__int64)"Enum name must not be empty.", v4);
    free(v5);
    return 1LL;
  }
  *a3 = lydict_insert_zc(a1, a4);
  if ( (*__ctype_b_loc())[*(char *)*v11] & 0x2000
    || (v7 = *__ctype_b_loc(), v8 = *v11, v7[*(char *)(v8 + strlen((const char *)*v11) - 1)] & 0x2000) )
  {
    sub_13937(a1, 23, 0, 0LL, *v11, v6, ptr);
    return 1LL;
  }
  for ( i = 0; i < *(_DWORD *)(*(_QWORD *)(a2 + 16) + 40LL) - 1; ++i )
  {
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * i) == *v11 )
    {
      sub_13937(a1, 22, 0, 0LL, *v11, v6, ptr);
      return 1LL;
    }
  }
  return 0LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008F644) ----------------------------------------------------
signed __int64 __fastcall sub_8F644(void *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5)
{
  int i; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  if ( a5 )
  {
    if ( a3 == *(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) )
    {
      *a4 = *(signed int *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 28LL);
      ++*a4;
    }
  }
  else
  {
    if ( *a4 > 0x7FFFFFFFLL )
    {
      sub_13937(a1, 10, 0, 0LL, (__int64)"2147483648", (__int64)"enum/value");
      return 1LL;
    }
    *(_DWORD *)(a3 + 28) = *a4;
    *(_WORD *)(a3 + 24) |= 1u;
    ++*a4;
  }
  v7 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 40LL) - 1;
  for ( i = 0; i < v7; ++i )
  {
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * i + 28) == *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL)
                                                                                            + 48LL * v7
                                                                                            + 28) )
    {
      sub_13937(
        a1,
        21,
        0,
        0LL,
        *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * v7 + 28),
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * v7),
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * i));
      return 1LL;
    }
  }
  return 0LL;
}

//----- (000000000008F84B) ----------------------------------------------------
signed __int64 __fastcall sub_8F84B(void *a1, __int64 a2, const char **a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v7; // [rsp+0h] [rbp-30h]
  const char **v8; // [rsp+8h] [rbp-28h]
  int i; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  *(_DWORD *)(a2 + 4) = 2;
  *a3 = (const char *)lydict_insert_zc(a1, a4);
  if ( (unsigned int)sub_3B812(a1, *v8, 0, 0LL, 0LL, v4) )
    return 1LL;
  for ( i = 0; i < *(_DWORD *)(*(_QWORD *)(a2 + 16) + 40LL) - 1; ++i )
  {
    if ( *(const char **)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * i) == *v8 )
    {
      sub_13937(a1, 27, 0, 0LL, (__int64)*v8, v5, v7);
      return 1LL;
    }
  }
  return 0LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000008F948) ----------------------------------------------------
signed __int64 __fastcall sub_8F948(void *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5)
{
  int i; // [rsp+38h] [rbp-8h]

  if ( !a5 )
  {
    if ( *a4 > 0xFFFFFFFFLL )
    {
      sub_13937(a1, 10, 0, 0LL, (__int64)"4294967295", (__int64)"bit/position");
      return 1LL;
    }
    *(_DWORD *)(a3 + 28) = *a4;
    *(_WORD *)(a3 + 24) |= 1u;
    ++*a4;
  }
  for ( i = 0; i < *(_DWORD *)(*(_QWORD *)(a2 + 16) + 40LL) - 1; ++i )
  {
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * i + 28) == *(_DWORD *)(a3 + 28) )
    {
      sub_13937(
        a1,
        26,
        0,
        0LL,
        *(unsigned int *)(a3 + 28),
        *(_QWORD *)a3,
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32LL) + 48LL * i));
      return 1LL;
    }
  }
  return 0LL;
}

//----- (000000000008FAB4) ----------------------------------------------------
signed __int64 __fastcall sub_8FAB4(__int64 *a1, __int64 a2, __int64 a3, const char *a4)
{
  char *ptr; // ST00_8
  _QWORD *v6; // [rsp+8h] [rbp-18h]

  v6 = (_QWORD *)a3;
  ptr = (char *)a4;
  *(_DWORD *)(a3 + 56) = 0x2000;
  *(_QWORD *)a3 = sub_9BED(a1, a4);
  free(ptr);
  if ( !*v6 )
    return 1LL;
  v6[8] = a2;
  v6[6] = a1;
  return 0LL;
}

//----- (000000000008FB32) ----------------------------------------------------
__int64 __fastcall sub_8FB32(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r9

  if ( *(_BYTE *)(a2 + 32) )
  {
    sub_13937(
      a1,
      -1,
      0,
      0LL,
      (__int64)"\"not-supported\" deviation cannot be combined with any other deviation.",
      a6,
      a2);
    result = 0LL;
  }
  else
  {
    *(_QWORD *)(a2 + 40) = calloc(1uLL, 0x48uLL);
    if ( *(_QWORD *)(a2 + 40) )
    {
      *(_DWORD *)(*(_QWORD *)(a2 + 40) + 72LL * *(unsigned __int8 *)(a2 + 32)) = 0;
      *(_BYTE *)(a2 + 32) = 1;
      result = *(_QWORD *)(a2 + 40);
    }
    else
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_deviate_unsupported", v7, a2);
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000008FC12) ----------------------------------------------------
signed __int64 __fastcall sub_8FC12(void *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  __int64 v9; // rsi
  unsigned __int8 v10; // al
  int v11; // [rsp+Ch] [rbp-24h]
  __int64 v12; // [rsp+10h] [rbp-20h]
  char *v13; // [rsp+28h] [rbp-8h]

  v12 = a2;
  v11 = a3;
  if ( *(_BYTE *)(a2 + 32) && !**(_DWORD **)(a2 + 40) )
  {
    sub_13937(a1, 5, 0, 0LL, (__int64)"not-supported", a6);
    sub_13937(a1, -1, 0, 0LL, (__int64)"\"not-supported\" deviation cannot be combined with any other deviation.", v6);
    return 0LL;
  }
  if ( !(*(_BYTE *)(a2 + 32) & 7) )
  {
    v13 = (char *)realloc(*(void **)(a2 + 40), 72LL * (*(unsigned __int8 *)(a2 + 32) + 8));
    if ( !v13 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_deviate", v8);
      return 0LL;
    }
    memset(&v13[72 * *(unsigned __int8 *)(a2 + 32)], 0, 0x240uLL);
    *(_QWORD *)(a2 + 40) = v13;
  }
  *(_DWORD *)(*(_QWORD *)(a2 + 40) + 72LL * *(unsigned __int8 *)(a2 + 32)) = v11;
  v9 = *(_QWORD *)(a2 + 40);
  v10 = *(_BYTE *)(v12 + 32);
  *(_BYTE *)(v12 + 32) = v10 + 1;
  return v9 + 72LL * v10;
}

//----- (000000000008FDB8) ----------------------------------------------------
signed __int64 __fastcall sub_8FDB8(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v11; // [rsp+8h] [rbp-28h]
  char i; // [rsp+24h] [rbp-Ch]
  int v13; // [rsp+24h] [rbp-Ch]
  _QWORD *v14; // [rsp+28h] [rbp-8h]

  v11 = a3;
  if ( *(_DWORD *)(a3 + 56) == 8 )
  {
    v14 = (_QWORD *)(a3 + 192);
    goto LABEL_6;
  }
  if ( *(_DWORD *)(a3 + 56) == 4 )
  {
    v14 = (_QWORD *)(a3 + 192);
LABEL_6:
    if ( *(_DWORD *)a2 == 3 )
    {
      if ( *v14 != *(_QWORD *)(a2 + 48) )
      {
        sub_13937(a1, 10, 0, 0LL, *(_QWORD *)(a2 + 48), (__int64)"units");
        sub_13937(a1, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v7);
        return 1LL;
      }
      lydict_remove(a1, *v14);
      *v14 = 0LL;
      for ( i = -1; ; i = v13 - 1 )
      {
        v13 = sub_9EAFC(*(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26), i + 1, 17);
        if ( v13 == -1 )
          break;
        sub_3DD01((__int64)a1, (void **)(v11 + 32), (unsigned __int8 *)(v11 + 26), v13);
      }
    }
    else
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        if ( *v14 )
        {
          sub_13937(a1, 5, 0, 0LL, (__int64)"units", a6);
          sub_13937(a1, -1, 0, 0LL, (__int64)"Adding property that already exists.", v8);
          return 1LL;
        }
      }
      else if ( !*v14 )
      {
        sub_13937(a1, 5, 0, 0LL, (__int64)"units", a6);
        sub_13937(a1, -1, 0, 0LL, (__int64)"Replacing a property that does not exist.", v9);
        return 1LL;
      }
      lydict_remove(a1, *v14);
      *v14 = lydict_insert(a1, *(_QWORD *)(a2 + 48), 0LL);
    }
    return 0LL;
  }
  sub_13937(a1, 5, 0, 0LL, (__int64)"units", a6);
  sub_13937(a1, -1, 0, 0LL, (__int64)"Target node does not allow \"units\" property.", v6);
  return 1LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000090078) ----------------------------------------------------
signed __int64 __fastcall sub_90078(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  void *v9; // [rsp+18h] [rbp-18h]
  char *v10; // [rsp+28h] [rbp-8h]

  v9 = **(void ***)(a2 + 48);
  if ( *(_DWORD *)(a2 + 56) == 16 )
  {
    if ( *(_DWORD *)a1 == 1 )
    {
      v10 = (char *)sub_C422(
                      *(void **)(a2 + 144),
                      16LL * (*(unsigned __int8 *)(a1 + 10) + *(unsigned __int8 *)(a2 + 31)));
      if ( !v10 )
      {
        sub_12222((__int64)v9, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_deviate_unique", v7, a2);
        return 1LL;
      }
      *(_QWORD *)(a2 + 144) = v10;
      memset(&v10[16 * *(unsigned __int8 *)(a2 + 31)], 0, 16LL * *(unsigned __int8 *)(a1 + 10));
    }
    return 0LL;
  }
  sub_13937(v9, 5, 0, 0LL, (__int64)&off_11FDF0[4], a6, a2);
  sub_13937(v9, -1, 0, 0LL, (__int64)"Target node does not allow \"unique\" property.", v6);
  return 1LL;
}

//----- (00000000000901CF) ----------------------------------------------------
signed __int64 __fastcall sub_901CF(void *a1, _DWORD *a2, __int64 a3, __int64 a4, const char *a5)
{
  __int64 v5; // r9
  __int64 v6; // r9
  __int16 v7; // ax
  __int16 v8; // ax
  __int64 v9; // rax
  __int64 v10; // r9
  __int64 v11; // rdi
  unsigned __int8 v12; // al
  __int16 v13; // ax
  char *s; // [rsp+8h] [rbp-78h]
  __int64 v16; // [rsp+10h] [rbp-70h]
  __int64 v17; // [rsp+18h] [rbp-68h]
  void *v18; // [rsp+28h] [rbp-58h]
  signed int j; // [rsp+38h] [rbp-48h]
  signed int k; // [rsp+38h] [rbp-48h]
  char l; // [rsp+3Ch] [rbp-44h]
  int v22; // [rsp+3Ch] [rbp-44h]
  char i; // [rsp+3Ch] [rbp-44h]
  int v24; // [rsp+3Ch] [rbp-44h]
  int v25; // [rsp+3Ch] [rbp-44h]
  unsigned int v26; // [rsp+40h] [rbp-40h]
  __int64 v27; // [rsp+48h] [rbp-38h]
  __int64 v28; // [rsp+50h] [rbp-30h]
  __int64 v29; // [rsp+58h] [rbp-28h]
  __int64 v30; // [rsp+60h] [rbp-20h]
  unsigned __int64 v31; // [rsp+68h] [rbp-18h]

  v18 = a1;
  v17 = a3;
  v16 = a4;
  s = (char *)a5;
  v31 = __readfsqword(0x28u);
  v26 = strlen(a5);
  if ( *(_DWORD *)(v17 + 56) != 2 )
  {
    if ( *(_DWORD *)(v17 + 56) == 4 )
    {
      v29 = v17;
      if ( *a2 == 3 )
      {
        if ( !*(_QWORD *)(v29 + 200) || s != *(char **)(v29 + 200) )
        {
          sub_13937(a1, 10, 0, 0LL, (__int64)s, (__int64)"default");
          sub_13937(a1, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v6);
          return 1LL;
        }
        lydict_remove(a1, *(_QWORD *)(v29 + 200));
        *(_QWORD *)(v29 + 200) = 0LL;
        v7 = *(_WORD *)(v29 + 24);
        HIBYTE(v7) &= 0xEFu;
        *(_WORD *)(v29 + 24) = v7;
        for ( i = -1; ; i = v24 - 1 )
        {
          v24 = sub_9EAFC(*(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26), i + 1, 5);
          if ( v24 == -1 )
            break;
          sub_3DD01((__int64)a1, (void **)(v17 + 32), (unsigned __int8 *)(v17 + 26), v24);
        }
      }
      else
      {
        lydict_remove(a1, *(_QWORD *)(v29 + 200));
        v8 = *(_WORD *)(v29 + 24);
        HIBYTE(v8) &= 0xEFu;
        *(_WORD *)(v29 + 24) = v8;
        *(_QWORD *)(v29 + 200) = lydict_insert(a1, s, v26);
        ly_set_add(v16, v17, 0LL);
      }
    }
    else
    {
      v28 = v17;
      if ( *a2 == 3 )
      {
        for ( j = 0; j < *(unsigned __int8 *)(v28 + 30); ++j )
        {
          if ( *(_QWORD *)(8LL * j + *(_QWORD *)(v28 + 200)) && s == *(char **)(8LL * j + *(_QWORD *)(v28 + 200)) )
          {
            lydict_remove(**(_QWORD **)(v28 + 48), *(_QWORD *)(8LL * j + *(_QWORD *)(v28 + 200)));
            *(_QWORD *)(8LL * j + *(_QWORD *)(v28 + 200)) = 0LL;
            LOBYTE(v25) = -1;
            while ( 1 )
            {
              v25 = sub_9EAFC(*(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26), (unsigned __int8)v25 + 1, 5);
              if ( v25 == -1 )
                break;
              if ( j == *(unsigned __int8 *)(*(_QWORD *)(8LL * v25 + *(_QWORD *)(v17 + 32)) + 27LL) )
              {
                sub_3DD01((__int64)a1, (void **)(v17 + 32), (unsigned __int8 *)(v17 + 26), v25);
                LOBYTE(v25) = v25 - 1;
              }
              else if ( j < *(unsigned __int8 *)(*(_QWORD *)(8LL * v25 + *(_QWORD *)(v17 + 32)) + 27LL) )
              {
                v9 = *(_QWORD *)(8LL * v25 + *(_QWORD *)(v17 + 32));
                --*(_BYTE *)(v9 + 27);
              }
            }
            break;
          }
        }
        if ( j == *(unsigned __int8 *)(v28 + 30) )
        {
          sub_13937(a1, 10, 0, 0LL, (__int64)s, (__int64)"default");
          sub_13937(a1, -1, 0, 0LL, (__int64)"The default value to delete not found in the target node.", v10);
          return 1LL;
        }
      }
      else
      {
        for ( k = 0; k < *(unsigned __int8 *)(v28 + 30); ++k )
        {
          if ( s == *(char **)(8LL * k + *(_QWORD *)(v28 + 200)) )
          {
            sub_13937(a1, 10, 0, 0LL, (__int64)s, (__int64)"default");
            sub_13937(a1, -1, 0, 0LL, (__int64)"Duplicated default value \"%s\".", (__int64)s);
            return 1LL;
          }
        }
        v11 = *(_QWORD *)(v28 + 200);
        v12 = *(_BYTE *)(v28 + 30);
        *(_BYTE *)(v28 + 30) = v12 + 1;
        *(_QWORD *)(v11 + 8LL * v12) = lydict_insert(v18, s, v26);
        ly_set_add(v16, v17, 0LL);
        v13 = *(_WORD *)(v28 + 24);
        HIBYTE(v13) &= 0xEFu;
        *(_WORD *)(v28 + 24) = v13;
      }
    }
    return 0LL;
  }
  v30 = v17;
  if ( !(unsigned int)sub_1B236(s, *(_QWORD *)(v17 + 72), &v27) && v27 )
  {
    if ( *a2 == 3 )
    {
      if ( !*(_QWORD *)(v30 + 112) || *(_QWORD *)(v30 + 112) != v27 )
      {
        sub_13937(a1, 10, 0, 0LL, (__int64)s, (__int64)"default");
        sub_13937(a1, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v5);
        return 1LL;
      }
      *(_QWORD *)(v30 + 112) = 0LL;
      for ( l = -1; ; l = v22 - 1 )
      {
        v22 = sub_9EAFC(*(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26), l + 1, 5);
        if ( v22 == -1 )
          break;
        sub_3DD01((__int64)a1, (void **)(v17 + 32), (unsigned __int8 *)(v17 + 26), v22);
      }
    }
    else
    {
      *(_QWORD *)(v30 + 112) = v27;
      if ( !*(_QWORD *)(v30 + 112) )
      {
        sub_13937(a1, 10, 0, 0LL, (__int64)s, (__int64)"default");
        return 1LL;
      }
    }
    return 0LL;
  }
  sub_13937(a1, 10, 0, 0LL, (__int64)s, (__int64)"default");
  return 1LL;
}
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000908E4) ----------------------------------------------------
signed __int64 __fastcall sub_908E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  const char *v10; // rax
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v15; // [rsp+0h] [rbp-40h]
  __int64 v16; // [rsp+8h] [rbp-38h]
  signed int i; // [rsp+24h] [rbp-1Ch]
  signed int j; // [rsp+24h] [rbp-1Ch]
  void *v19; // [rsp+28h] [rbp-18h]
  void *v20; // [rsp+38h] [rbp-8h]
  void *v21; // [rsp+38h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v19 = *(void **)a1;
  if ( ((*(_BYTE *)(a1 + 64) >> 1) & 7u) <= 1 && *(_DWORD *)(a3 + 56) == 8 )
  {
    sub_13937(v19, 5, 0, 0LL, (__int64)"default", a6, a4);
    sub_13937(v19, -1, 0, 0LL, (__int64)"Target node does not allow \"default\" property.", v6);
    return 1LL;
  }
  if ( *(_BYTE *)(a2 + 5) > 1u && *(_DWORD *)(a3 + 56) != 8 )
  {
    sub_13937(v19, 5, 0, 0LL, (__int64)"default", a6, a4);
    sub_13937(v19, -1, 0, 0LL, (__int64)"Target node does not allow multiple \"default\" properties.", v7);
    return 1LL;
  }
  if ( !(*(_DWORD *)(a3 + 56) & 0xE) )
  {
    sub_13937(v19, 5, 0, 0LL, (__int64)"default", a6, a4);
    sub_13937(v19, -1, 0, 0LL, (__int64)"Target node does not allow \"default\" property.", v8);
    return 1LL;
  }
  if ( *(_DWORD *)a2 == 1 )
  {
    if ( *(_DWORD *)(a3 + 56) == 4 && *(_QWORD *)(a3 + 200) || *(_DWORD *)(a3 + 56) == 2 && *(_QWORD *)(a3 + 112) )
    {
      sub_13937(v19, 5, 0, 0LL, (__int64)"default", a6, a4);
      sub_13937(v19, -1, 0, 0LL, (__int64)"Adding property that already exists.", v9);
      return 1LL;
    }
    if ( *(_WORD *)(a3 + 24) & 0x40 || *(_DWORD *)(a3 + 56) == 8 && *(_DWORD *)(a3 + 208) )
    {
      sub_13937(v19, 6, 0, 0LL, (__int64)"default", (__int64)"deviation", a4);
      if ( *(_WORD *)(v16 + 24) & 0x40 )
        v10 = "nodes with the \"mandatory\"";
      else
        v10 = "leaflists with non-zero \"min-elements\"";
      sub_13937(
        v19,
        -1,
        0,
        0LL,
        (__int64)"Adding the \"default\" statement is forbidden on %s statement.",
        (__int64)v10);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)a2 == 2
         && (*(_DWORD *)(a3 + 56) & 0xC && !*(_QWORD *)(a3 + 200) || *(_DWORD *)(a3 + 56) == 2 && !*(_QWORD *)(a3 + 112)) )
  {
    sub_13937(v19, 5, 0, 0LL, (__int64)"default", a6, a4);
    sub_13937(v19, -1, 0, 0LL, (__int64)"Replacing a property that does not exist.", v11);
    return 1LL;
  }
  if ( *(_DWORD *)(a3 + 56) == 8 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v20 = realloc(*(void **)(a3 + 200), 8LL * (*(unsigned __int8 *)(a2 + 5) + *(unsigned __int8 *)(a3 + 30)));
      if ( !v20 )
      {
        sub_12222(
          (__int64)v19,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"yang_read_deviate_default",
          v12,
          v15);
        return 1LL;
      }
      *(_QWORD *)(v16 + 200) = v20;
    }
    else if ( *(_DWORD *)a2 == 2 )
    {
      for ( i = 0; i < *(unsigned __int8 *)(v16 + 30); ++i )
        lydict_remove(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(v16 + 200)));
      v21 = realloc(*(void **)(v16 + 200), 8LL * *(unsigned __int8 *)(a2 + 5));
      if ( !v21 )
      {
        sub_12222(
          (__int64)v19,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"yang_read_deviate_default",
          v13,
          v15);
        return 1LL;
      }
      *(_QWORD *)(v16 + 200) = v21;
      *(_BYTE *)(v16 + 30) = 0;
    }
  }
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 5); ++j )
  {
    if ( (unsigned int)sub_901CF(v19, (_DWORD *)a2, v16, v15, *(const char **)(8LL * j + *(_QWORD *)(a2 + 56))) )
      return 1LL;
  }
  return 0LL;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000090DFE) ----------------------------------------------------
signed __int64 __fastcall sub_90DFE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  __int16 v11; // ax
  __int64 i; // [rsp+10h] [rbp-10h]
  void *v14; // [rsp+18h] [rbp-8h]

  v14 = **(void ***)(a2 + 48);
  if ( *(_DWORD *)(a2 + 56) & 0x8026 )
  {
    if ( *(_DWORD *)a1 == 1 )
    {
      if ( *(_WORD *)(a2 + 24) & 0xC0 )
      {
        sub_13937(v14, 5, 0, 0LL, (__int64)"mandatory", a6, a2);
        sub_13937(v14, -1, 0, 0LL, (__int64)"Adding property that already exists.", v7);
        return 1LL;
      }
      if ( *(_DWORD *)(a2 + 56) == 4 && *(_QWORD *)(a2 + 200) )
      {
        sub_13937(v14, 6, 0, 0LL, (__int64)"mandatory", (__int64)"leaf", a2);
        sub_13937(v14, -1, 0, 0LL, (__int64)"The \"mandatory\" statement is forbidden on leaf with \"default\".", v8);
        return 1LL;
      }
      if ( *(_DWORD *)(a2 + 56) == 2 && *(_QWORD *)(a2 + 112) )
      {
        sub_13937(v14, 6, 0, 0LL, (__int64)"mandatory", (__int64)"choice", a2);
        sub_13937(v14, -1, 0, 0LL, (__int64)"The \"mandatory\" statement is forbidden on choices with \"default\".", v9);
        return 1LL;
      }
    }
    else if ( !(*(_WORD *)(a2 + 24) & 0xC0) )
    {
      sub_13937(v14, 5, 0, 0LL, (__int64)"mandatory", a6, a2);
      sub_13937(v14, -1, 0, 0LL, (__int64)"Replacing a property that does not exist.", v10);
      return 1LL;
    }
    v11 = *(_WORD *)(a2 + 24);
    LOBYTE(v11) = v11 & 0x3F;
    *(_WORD *)(a2 + 24) = v11;
    *(_WORD *)(a2 + 24) |= (unsigned __int8)(*(_BYTE *)(a1 + 4) & 0xC0);
    for ( i = *(_QWORD *)(a2 + 64);
          i && !(*(_DWORD *)(i + 56) & 0x4802) && (*(_DWORD *)(i + 56) != 1 || !*(_QWORD *)(i + 136));
          i = *(_QWORD *)(i + 64) )
    {
      ;
    }
    if ( !i || *(_DWORD *)(i + 56) != 2 || !*(_QWORD *)(i + 112) || !(unsigned int)sub_3C679(i) )
      return 0LL;
  }
  else
  {
    sub_13937(v14, 5, 0, 0LL, (__int64)"mandatory", a6, a2);
    sub_13937(v14, -1, 0, 0LL, (__int64)"Target node does not allow \"mandatory\" property.", v6);
  }
  return 1LL;
}

//----- (0000000000091116) ----------------------------------------------------
signed __int64 __fastcall sub_91116(_DWORD *a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  const char *v7; // rax
  unsigned int *v8; // rax
  const char *v9; // rax
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  int v14; // [rsp+8h] [rbp-38h]
  unsigned int *v15; // [rsp+20h] [rbp-20h]
  unsigned int *v16; // [rsp+28h] [rbp-18h]
  void *v17; // [rsp+30h] [rbp-10h]

  v14 = a4;
  v17 = **(void ***)(a2 + 48);
  if ( *(_DWORD *)(a2 + 56) == 8 )
  {
    v16 = (unsigned int *)(a2 + 212);
    v15 = (unsigned int *)(a2 + 208);
  }
  else
  {
    if ( *(_DWORD *)(a2 + 56) != 16 )
    {
      if ( a4 )
        v6 = "max-elements";
      else
        v6 = "min-elements";
      sub_13937(v17, 5, 0, 0LL, (__int64)v6, a6);
      if ( v14 )
        v7 = "max-elements";
      else
        v7 = "min-elements";
      sub_13937(v17, -1, 0, 0LL, (__int64)"Target node does not allow \"%s\" property.", (__int64)v7);
      return 1LL;
    }
    v16 = (unsigned int *)(a2 + 156);
    v15 = (unsigned int *)(a2 + 152);
  }
  if ( a4 )
    v8 = v16;
  else
    v8 = v15;
  if ( *a1 == 1 && *v8 )
  {
    if ( a4 )
      v9 = "max-elements";
    else
      v9 = "min-elements";
    sub_13937(v17, 5, 0, 0LL, (__int64)v9, a6);
    sub_13937(v17, -1, 0, 0LL, (__int64)"Adding property that already exists.", v10);
  }
  else
  {
    *v8 = a3;
    if ( !*v16 || *v15 <= *v16 )
      return 0LL;
    if ( a4 )
    {
      sub_13937(v17, -1, 0, 0LL, (__int64)"Invalid value \"%d\" of \"max-elements\".", a3);
      sub_13937(v17, -1, 0, 0LL, (__int64)"\"max-elements\" is smaller than \"min-elements\".", v11);
    }
    else
    {
      sub_13937(v17, -1, 0, 0LL, (__int64)"Invalid value \"%d\" of \"min-elements\".", a3);
      sub_13937(v17, -1, 0, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v12);
    }
  }
  return 1LL;
}

//----- (0000000000091380) ----------------------------------------------------
signed __int64 __fastcall sub_91380(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // eax
  __int64 v7; // r9
  __int16 v8; // ax
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 *v12; // [rsp+0h] [rbp-50h]
  __int64 v13; // [rsp+8h] [rbp-48h]
  signed int j; // [rsp+24h] [rbp-2Ch]
  signed int k; // [rsp+24h] [rbp-2Ch]
  signed int i; // [rsp+28h] [rbp-28h]
  signed int v17; // [rsp+2Ch] [rbp-24h]
  void **v18; // [rsp+30h] [rbp-20h]
  _BYTE *v19; // [rsp+38h] [rbp-18h]
  void *v20; // [rsp+40h] [rbp-10h]
  void *v21; // [rsp+48h] [rbp-8h]

  v13 = a3;
  v12 = (__int64 *)a4;
  v20 = (void *)*a1;
  v17 = 1;
  v6 = *(_DWORD *)(a4 + 56);
  if ( v6 == 8 )
  {
    v18 = (void **)(a4 + 120);
    v19 = (_BYTE *)(a4 + 31);
  }
  else if ( v6 > 8 )
  {
    if ( v6 == 32 || v6 == 32800 )
    {
      v18 = (void **)(a4 + 120);
      v19 = (_BYTE *)(a4 + 31);
    }
    else
    {
      if ( v6 != 16 )
        goto LABEL_15;
      v18 = (void **)(a4 + 120);
      v19 = (_BYTE *)(a4 + 28);
    }
  }
  else if ( v6 == 1 )
  {
    v18 = (void **)(a4 + 120);
    v19 = (_BYTE *)(a4 + 29);
  }
  else
  {
    if ( v6 != 4 )
    {
LABEL_15:
      sub_13937(v20, 5, 0, 0LL, (__int64)"must", a6, a4);
      sub_13937(v20, -1, 0, 0LL, (__int64)"Target node does not allow \"must\" property.", v7);
      goto LABEL_41;
    }
    v18 = (void **)(a4 + 120);
    v19 = (_BYTE *)(a4 + 31);
  }
  v8 = *(_WORD *)(a4 + 24);
  HIBYTE(v8) &= 0xF9u;
  *(_WORD *)(a4 + 24) = v8;
  if ( *(_DWORD *)a3 == 1 )
  {
    v21 = sub_C422(*v18, 56LL * (*(unsigned __int8 *)(a3 + 9) + (unsigned __int8)*v19));
    if ( !v21 )
    {
      sub_12222((__int64)v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_check_deviate_must", v9, v12);
      goto LABEL_41;
    }
    *v18 = v21;
    memcpy((char *)*v18 + 56 * (unsigned __int8)*v19, *(const void **)(v13 + 24), 56LL * *(unsigned __int8 *)(v13 + 9));
    *v19 += *(_BYTE *)(v13 + 9);
    v17 = 0;
  }
  else if ( *(_DWORD *)a3 == 3 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(v13 + 9); ++i )
    {
      for ( j = 0; j < (unsigned __int8)*v19; ++j )
      {
        if ( *(_QWORD *)(*(_QWORD *)(v13 + 24) + 56LL * i) == *((_QWORD *)*v18 + 7 * j) )
        {
          sub_9F606(*a1, (__int64)*v18 + 56 * j, 0LL);
          if ( j != (unsigned __int8)--*v19 )
            memcpy((char *)*v18 + 56 * j, (char *)*v18 + 56 * (unsigned __int8)*v19, 0x38uLL);
          if ( *v19 )
          {
            memset((char *)*v18 + 56 * (unsigned __int8)*v19, 0, 0x38uLL);
          }
          else
          {
            free(*v18);
            *v18 = 0LL;
          }
          j = -1;
          break;
        }
      }
      if ( j != -1 )
      {
        sub_13937(v20, 10, 0, 0LL, *(_QWORD *)(*(_QWORD *)(v13 + 24) + 56LL * i), (__int64)"must", v12);
        sub_13937(v20, -1, 0, 0LL, (__int64)"Value does not match any must from the target.", v10);
        goto LABEL_41;
      }
    }
  }
  if ( !(unsigned int)sub_96B86(a1, *(_QWORD *)(v13 + 24), *(unsigned __int8 *)(v13 + 9), a2)
    && (*(_DWORD *)(*a1 + 92) & 2 || !*v19 || (unsigned int)sub_2ABDE(a1, a2, v12, 0x20000u, 0LL) != -1) )
  {
    return 0LL;
  }
LABEL_41:
  if ( *(_DWORD *)v13 == 1 && v17 )
  {
    for ( k = 0; k < *(unsigned __int8 *)(v13 + 9); ++k )
      sub_9F606(*a1, 56LL * k + *(_QWORD *)(v13 + 24), 0LL);
    free(*(void **)(v13 + 24));
  }
  return 1LL;
}

//----- (00000000000918F3) ----------------------------------------------------
signed __int64 __fastcall sub_918F3(void **a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v5; // r9
  signed __int64 result; // rax
  __int64 v7; // rax
  __int64 v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  signed int i; // [rsp+3Ch] [rbp-14h]
  signed int j; // [rsp+40h] [rbp-10h]
  signed int k; // [rsp+40h] [rbp-10h]
  int v13; // [rsp+40h] [rbp-10h]
  signed int v14; // [rsp+44h] [rbp-Ch]
  void *v15; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a5;
  v15 = *a1;
  for ( i = 0; i < *(unsigned __int8 *)(a3 + 31); ++i )
  {
    if ( *(_BYTE *)(16LL * i + *(_QWORD *)(a3 + 144) + 8) == *(_BYTE *)(16LL * a4 + *(_QWORD *)(a2 + 32) + 8) )
    {
      for ( j = 0;
            j < *(unsigned __int8 *)(16LL * a4 + *(_QWORD *)(a2 + 32) + 8)
         && *(_QWORD *)(8LL * j + *(_QWORD *)(16LL * i + *(_QWORD *)(a3 + 144))) == *(_QWORD *)(8LL * j
                                                                                              + *(_QWORD *)(16LL * a4 + *(_QWORD *)(a2 + 32)));
            ++j )
      {
        ;
      }
      if ( j == *(unsigned __int8 *)(16LL * a4 + *(_QWORD *)(a2 + 32) + 8) )
      {
        for ( k = 0; k < *(unsigned __int8 *)(16LL * i + *(_QWORD *)(v9 + 144) + 8); ++k )
          lydict_remove(v15, *(_QWORD *)(8LL * k + *(_QWORD *)(16LL * i + *(_QWORD *)(v9 + 144))));
        free(*(void **)(16LL * i + *(_QWORD *)(v9 + 144)));
        if ( i != (unsigned __int8)--*(_BYTE *)(v9 + 31) )
        {
          *(_BYTE *)(*(_QWORD *)(v9 + 144) + 16LL * i + 8) = *(_BYTE *)(*(_QWORD *)(v9 + 144)
                                                                      + 16LL * *(unsigned __int8 *)(v9 + 31)
                                                                      + 8);
          *(_QWORD *)(*(_QWORD *)(v9 + 144) + 16LL * i) = *(_QWORD *)(*(_QWORD *)(v9 + 144)
                                                                    + 16LL * *(unsigned __int8 *)(v9 + 31));
        }
        if ( *(_BYTE *)(v9 + 31) )
        {
          *(_BYTE *)(*(_QWORD *)(v9 + 144) + 16LL * *(unsigned __int8 *)(v9 + 31) + 8) = 0;
          *(_QWORD *)(*(_QWORD *)(v9 + 144) + 16LL * *(unsigned __int8 *)(v9 + 31)) = 0LL;
        }
        else
        {
          free(*(void **)(v9 + 144));
          *(_QWORD *)(v9 + 144) = 0LL;
        }
        v14 = i;
        i = -1;
        break;
      }
    }
  }
  if ( i == -1 )
  {
    LOBYTE(v13) = -1;
    while ( 1 )
    {
      v13 = sub_9EAFC(*(_QWORD *)(v9 + 32), *(_BYTE *)(v9 + 26), (unsigned __int8)v13 + 1, 31);
      if ( v13 == -1 )
        break;
      if ( v14 == *(unsigned __int8 *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(v9 + 32)) + 27LL) )
      {
        sub_3DD01((__int64)v15, (void **)(v9 + 32), (unsigned __int8 *)(v9 + 26), v13);
        LOBYTE(v13) = v13 - 1;
      }
      else if ( v14 < *(unsigned __int8 *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)(v9 + 32)) + 27LL) )
      {
        v7 = *(_QWORD *)(8LL * v13 + *(_QWORD *)(v9 + 32));
        --*(_BYTE *)(v7 + 27);
      }
    }
    result = 0LL;
  }
  else
  {
    sub_13937(v15, 10, 0, 0LL, v8, (__int64)&off_11FDF0[4]);
    sub_13937(v15, -1, 0, 0LL, (__int64)"Value differs from the target being deleted.", v5);
    result = 1LL;
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000091D1B) ----------------------------------------------------
signed __int64 __fastcall sub_91D1B(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-38h]
  unsigned int j; // [rsp+24h] [rbp-1Ch]
  unsigned int i; // [rsp+24h] [rbp-1Ch]
  signed __int64 v10; // [rsp+28h] [rbp-18h]
  void *ptr; // [rsp+38h] [rbp-8h]

  v7 = a3;
  j = 0;
  v10 = 0LL;
  if ( (unsigned int)sub_90078(a2, a3, a3, a4, a5, a6) )
  {
LABEL_17:
    if ( *(_DWORD *)a2 == 1 )
    {
      for ( i = j + 1; i < *(unsigned __int8 *)(a2 + 10); ++i )
        free(*(void **)(16LL * i + *(_QWORD *)(a2 + 32)));
      free(*(void **)(a2 + 32));
      *(_QWORD *)(a2 + 32) = v10;
    }
    result = 1LL;
  }
  else
  {
    v10 = *(_QWORD *)(v7 + 144) + 16LL * *(unsigned __int8 *)(v7 + 31);
    for ( j = 0; j < *(unsigned __int8 *)(a2 + 10); ++j )
    {
      ptr = *(void **)(16LL * j + *(_QWORD *)(a2 + 32));
      if ( *(_DWORD *)a2 == 1 )
      {
        if ( (unsigned int)sub_8CB00(
                             a1,
                             (char *)v7,
                             *(_QWORD *)(v7 + 144) + 16LL * *(unsigned __int8 *)(v7 + 31),
                             (const char *)ptr,
                             0LL) )
        {
          free(ptr);
          goto LABEL_17;
        }
        ++*(_BYTE *)(v7 + 31);
      }
      else if ( *(_DWORD *)a2 == 3 )
      {
        if ( (unsigned int)sub_8CB00(a1, (char *)v7, *(_QWORD *)(a2 + 32) + 16LL * j, (const char *)ptr, 0LL) )
        {
          free(ptr);
          goto LABEL_17;
        }
        if ( (unsigned int)sub_918F3((void **)a1, a2, v7, j, (__int64)ptr) )
        {
          free(ptr);
          goto LABEL_17;
        }
      }
      free(ptr);
    }
    if ( *(_DWORD *)a2 == 1 )
    {
      free(*(void **)(a2 + 32));
      *(_QWORD *)(a2 + 32) = v10;
    }
    result = 0LL;
  }
  return result;
}

//----- (0000000000091F57) ----------------------------------------------------
__int64 __fastcall sub_91F57(__int64 *a1, __int64 a2, void ****a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  void ****src; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+20h] [rbp-10h]
  int v8; // [rsp+24h] [rbp-Ch]
  __int64 v9; // [rsp+28h] [rbp-8h]

  src = a3;
  v5 = a4;
  v7 = 0;
  v9 = lydict_insert_zc(*a1, a2);
  v8 = sub_3D0D7(a1, v9, src, v5);
  if ( v8 )
  {
    if ( v8 == -1 )
    {
      sub_AAE3B(*a1, src[3], *((unsigned __int8 *)src + 19), 0LL);
      v7 = -1;
    }
  }
  else
  {
    memcpy((void *)(48LL * *((unsigned __int8 *)a1 + 70) + a1[13]), src, 0x30uLL);
    if ( (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(a1[13] + 48LL * *((unsigned __int8 *)a1 + 70) + 24),
                         *(unsigned __int8 *)(a1[13] + 48LL * *((unsigned __int8 *)a1 + 70) + 19),
                         48LL * *((unsigned __int8 *)a1 + 70) + a1[13],
                         v5) )
      v7 = -1;
    ++*((_BYTE *)a1 + 70);
  }
  lydict_remove(*a1, v9);
  return v7;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000920E6) ----------------------------------------------------
_BYTE *__fastcall sub_920E6(__int64 a1, unsigned int a2, unsigned int a3)
{
  _BYTE *result; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // [rsp+0h] [rbp-40h]
  char v6; // [rsp+1Ch] [rbp-24h]
  void **v7; // [rsp+20h] [rbp-20h]
  _BYTE *v8; // [rsp+28h] [rbp-18h]
  _BYTE *ptr; // [rsp+30h] [rbp-10h]
  _QWORD *v10; // [rsp+38h] [rbp-8h]

  v5 = __PAIR__(a2, a3);
  switch ( a2 )
  {
    case 0x103u:
    case 0x114u:
    case 0x118u:
    case 0x119u:
    case 0x11Cu:
    case 0x127u:
    case 0x12Cu:
    case 0x12Eu:
    case 0x12Fu:
    case 0x131u:
    case 0x138u:
    case 0x13Bu:
    case 0x147u:
    case 0x14Eu:
    case 0x15Fu:
    case 0x161u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 1;
      goto LABEL_28;
    case 0x113u:
      if ( a3 )
      {
        v7 = (void **)(a1 + 32);
        v8 = (_BYTE *)(a1 + 26);
        v6 = 11;
      }
      else
      {
        v7 = (void **)(a1 + 32);
        v8 = (_BYTE *)(a1 + 26);
        v6 = 10;
      }
      goto LABEL_28;
    case 0x116u:
      if ( a3 )
      {
        v7 = (void **)(a1 + 32);
        v8 = (_BYTE *)(a1 + 26);
        v6 = 11;
      }
      else
      {
        v7 = (void **)(a1 + 160);
        v8 = (_BYTE *)(a1 + 80);
        v6 = 0;
      }
      goto LABEL_28;
    case 0x117u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 4;
      goto LABEL_28;
    case 0x11Fu:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 5;
      goto LABEL_28;
    case 0x122u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 10;
      goto LABEL_28;
    case 0x123u:
      v7 = (void **)(a1 + 48);
      v8 = (_BYTE *)(a1 + 33);
      v6 = 13;
      goto LABEL_28;
    case 0x125u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 6;
      goto LABEL_28;
    case 0x128u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 9;
      goto LABEL_28;
    case 0x129u:
      v7 = (void **)(a1 + 24);
      v8 = (_BYTE *)(a1 + 8);
      v6 = 18;
      goto LABEL_28;
    case 0x12Au:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 27);
      v6 = 15;
      goto LABEL_28;
    case 0x12Bu:
      v7 = (void **)(a1 + 24);
      v8 = (_BYTE *)(a1 + 19);
      v6 = 16;
      goto LABEL_28;
    case 0x130u:
    case 0x136u:
    case 0x13Du:
    case 0x141u:
      v7 = (void **)(a1 + 40);
      v8 = (_BYTE *)(a1 + 48);
      v6 = 7;
      goto LABEL_28;
    case 0x135u:
    case 0x149u:
      v7 = (void **)(a1 + 160);
      v8 = (_BYTE *)(a1 + 80);
      v6 = 0;
      goto LABEL_28;
    case 0x143u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 12;
      goto LABEL_28;
    case 0x145u:
      v7 = (void **)(a1 + 16);
      v8 = (_BYTE *)(a1 + 11);
      v6 = 17;
      goto LABEL_28;
    case 0x14Au:
      v7 = (void **)(*(_QWORD *)(a1 + 16) + 8LL);
      v8 = (_BYTE *)(*(_QWORD *)(a1 + 16) + 5LL);
      v6 = 3;
      goto LABEL_28;
    case 0x14Bu:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 2;
      goto LABEL_28;
    case 0x150u:
      v7 = (void **)(a1 + 24);
      v8 = (_BYTE *)(a1 + 32);
      v6 = 7;
      goto LABEL_28;
    case 0x153u:
    case 0x155u:
    case 0x158u:
    case 0x15Au:
      v7 = (void **)(a1 + 64);
      v8 = (_BYTE *)(a1 + 6);
      v6 = 14;
      goto LABEL_28;
    case 0x164u:
      v7 = (void **)(a1 + 32);
      v8 = (_BYTE *)(a1 + 26);
      v6 = 11;
LABEL_28:
      ptr = calloc(1uLL, 0x40uLL);
      if ( ptr && (ptr[29] = v6, (v10 = realloc(*v7, 8LL * ((unsigned __int8)*v8 + 1))) != 0LL) )
      {
        v10[(unsigned __int8)*v8] = ptr;
        *v7 = v10;
        ++*v8;
        result = ptr;
      }
      else
      {
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_ext_instance", v4, v5);
        free(ptr);
        result = 0LL;
      }
      break;
    default:
      sub_12222(
        0LL,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
        2237LL,
        __PAIR__(a2, a3));
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000092593) ----------------------------------------------------
_BYTE *__fastcall sub_92593(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  _BYTE *result; // rax
  int v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+10h] [rbp-40h]
  __int64 v10; // [rsp+18h] [rbp-38h]
  char v11; // [rsp+3Fh] [rbp-11h]
  unsigned int v12; // [rsp+40h] [rbp-10h]
  char v13; // [rsp+44h] [rbp-Ch]
  _BYTE *v14; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a6;
  v12 = 0;
  v11 = 0;
  if ( a6 == 354 )
  {
    if ( a5 == 275 )
    {
      v13 = 1;
      v12 = 1;
    }
    else if ( a5 == 278 )
    {
      v13 = 3;
      v12 = 3;
    }
    else
    {
      v13 = 0;
    }
    v14 = sub_920E6(a2, a5, a7);
LABEL_58:
    if ( v14 )
    {
      v14[28] = v13;
      v14[27] = v11;
      *((_WORD *)v14 + 12) |= 2u;
      *(_QWORD *)v14 = v10;
      *((_QWORD *)v14 + 2) = lydict_insert_zc(*a1, v9);
      if ( a7 && v12 && v14[29] == 11 )
        v14[27] = sub_9A401(a2, v12, v8);
      result = v14;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    switch ( a5 )
    {
      case 0x115u:
        v13 = 2;
        v12 = 2;
        if ( a6 == 296 )
        {
          v11 = *(_BYTE *)(a2 + 31);
        }
        else if ( a6 == 330 )
        {
          v11 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 40LL);
        }
        goto LABEL_51;
      case 0x11Au:
        v13 = 23;
        v12 = 23;
        goto LABEL_51;
      case 0x11Bu:
        v13 = 4;
        v12 = 4;
        goto LABEL_51;
      case 0x11Du:
        v13 = 5;
        v12 = 5;
        switch ( a6 )
        {
          case 0x143u:
            v11 = *(_BYTE *)(a2 + 31);
            break;
          case 0x153u:
            v11 = *(_BYTE *)(a2 + 5);
            break;
          case 0x12Fu:
            v11 = *(_BYTE *)(a2 + 30);
            break;
        }
        goto LABEL_51;
      case 0x11Eu:
        v13 = 6;
        v12 = 6;
        goto LABEL_51;
      case 0x120u:
        v13 = 7;
        v12 = 7;
        goto LABEL_51;
      case 0x121u:
        v13 = 8;
        v12 = 8;
        goto LABEL_51;
      case 0x126u:
        v13 = 27;
        v12 = 27;
        goto LABEL_51;
      case 0x12Du:
        v13 = 9;
        v12 = 9;
        goto LABEL_51;
      case 0x132u:
        v13 = 24;
        v12 = 24;
        goto LABEL_51;
      case 0x133u:
        v13 = 28;
        v12 = 28;
        goto LABEL_51;
      case 0x134u:
        v13 = 29;
        v12 = 29;
        goto LABEL_51;
      case 0x137u:
        v13 = 10;
        v12 = 10;
        goto LABEL_51;
      case 0x139u:
        v13 = 25;
        v12 = 25;
        goto LABEL_51;
      case 0x13Au:
        v13 = 11;
        v12 = 11;
        goto LABEL_51;
      case 0x13Cu:
        v13 = 12;
        v12 = 12;
        goto LABEL_51;
      case 0x13Eu:
        v13 = 30;
        v12 = 30;
        goto LABEL_51;
      case 0x13Fu:
        v13 = 13;
        v12 = 13;
        goto LABEL_51;
      case 0x140u:
        v13 = 14;
        v12 = 14;
        goto LABEL_51;
      case 0x142u:
        v13 = 15;
        v12 = 15;
        goto LABEL_51;
      case 0x144u:
        v13 = 21;
        v12 = 21;
        goto LABEL_51;
      case 0x146u:
        v13 = 16;
        v12 = 16;
        goto LABEL_51;
      case 0x148u:
        v13 = 26;
        v12 = 26;
        goto LABEL_51;
      case 0x14Cu:
        v13 = 31;
        v12 = 31;
        if ( a6 == 339 )
          goto LABEL_48;
        if ( a6 > 0x153 )
        {
          if ( a6 == 341 || a6 == 346 )
LABEL_48:
            v11 = *(_BYTE *)(a2 + 10);
        }
        else if ( a6 == 305 )
        {
          v11 = *(_BYTE *)(a2 + 31);
        }
        goto LABEL_51;
      case 0x14Du:
        v13 = 17;
        v12 = 17;
        goto LABEL_51;
      case 0x14Fu:
        v13 = 18;
        v12 = 18;
        goto LABEL_51;
      case 0x151u:
        v13 = 19;
        v12 = 19;
        goto LABEL_51;
      case 0x152u:
        v13 = 22;
        v12 = 22;
        goto LABEL_51;
      case 0x160u:
        v13 = 20;
        v12 = 20;
LABEL_51:
        v14 = sub_920E6(a2, a6, a7);
        goto LABEL_58;
      default:
        sub_12222(
          *a1,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
          2421LL);
        result = 0LL;
        break;
    }
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (0000000000092A28) ----------------------------------------------------
signed __int64 __fastcall sub_92A28(__int64 a1, __int64 *a2)
{
  const char *v3; // rax
  __int64 v4; // ST20_8
  int v5; // eax
  __int64 v6; // r12
  const char *v7; // rbx
  const char *v8; // rax
  __int64 v9; // rbx
  const char *v10; // rax
  void *v11; // [rsp+10h] [rbp-20h]
  void *ptr; // [rsp+18h] [rbp-18h]

  v11 = **(void ***)(a1 + 48);
  if ( *(_DWORD *)(a1 + 56) & 0x600 )
    return 0LL;
  if ( !a2 || !(a2[3] & 0x30) )
    return 0LL;
  if ( !(*(_WORD *)(a1 + 24) & 0x38) )
  {
    ptr = (void *)lys_path(a1, 1LL);
    if ( a2[3] & 0x10 )
      v3 = "deprecated";
    else
      v3 = "obsolete";
    sub_12222((__int64)v11, 1u, 0, "Missing status in %s subtree (%s), inheriting.", (__int64)v3, (__int64)ptr, a2);
    free(ptr);
    *(_WORD *)(a1 + 24) |= *(_WORD *)(v4 + 24) & 0x38;
    return 0LL;
  }
  if ( (a2[3] & 0x38) > (*(_WORD *)(a1 + 24) & 0x38) )
  {
    v5 = *(_WORD *)(a1 + 24) & 0x38;
    if ( v5 != 8 )
    {
      if ( v5 == 16 )
      {
        v9 = *a2;
        v10 = sub_8164(*(_DWORD *)(a1 + 56));
        sub_13937(v11, 37, 2u, (char *)a2, (__int64)"deprecated", (__int64)v10, "is child of", "obsolete", v9);
      }
      else if ( !v5 )
      {
        goto LABEL_14;
      }
      return 1LL;
    }
LABEL_14:
    v6 = *a2;
    if ( a2[3] & 0x10 )
      v7 = "deprecated";
    else
      v7 = "obsolete";
    v8 = sub_8164(*(_DWORD *)(a1 + 56));
    sub_13937(v11, 37, 2u, (char *)a2, (__int64)"current", (__int64)v8, "is child of", v7, v6);
    return 1LL;
  }
  return 0LL;
}
// 7680: using guessed type __int64 __fastcall lys_path(_QWORD, _QWORD);

//----- (0000000000092C65) ----------------------------------------------------
__int64 __fastcall sub_92C65(__int64 a1, char a2)
{
  unsigned int v2; // eax

  v2 = *(_DWORD *)(a1 + 56);
  if ( v2 == 8 )
    goto LABEL_13;
  if ( v2 <= 8 )
  {
    if ( v2 < 1 || v2 > 2 && v2 != 4 )
      return 0LL;
    goto LABEL_13;
  }
  if ( v2 == 32 )
  {
LABEL_13:
    if ( a2 & 2 )
    {
      *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24);
    }
    else if ( !(a2 & 1) && !(*(_WORD *)(a1 + 24) & 3) )
    {
      if ( *(_QWORD *)(a1 + 64) )
        *(_WORD *)(a1 + 24) |= *(_WORD *)(*(_QWORD *)(a1 + 64) + 24LL) & 3;
      else
        *(_WORD *)(a1 + 24) |= 1u;
    }
    return 0LL;
  }
  if ( v2 <= 0x20 )
  {
    if ( v2 != 16 )
      return 0LL;
    goto LABEL_13;
  }
  if ( v2 != 64 )
  {
    if ( v2 != 32800 )
      return 0LL;
    goto LABEL_13;
  }
  if ( !(a2 & 3) && !(*(_WORD *)(a1 + 24) & 3) )
  {
    if ( *(_QWORD *)(a1 + 64) )
      *(_WORD *)(a1 + 24) |= *(_WORD *)(*(_QWORD *)(a1 + 64) + 24LL) & 3;
    else
      *(_WORD *)(a1 + 24) |= 1u;
  }
  return 0LL;
}

//----- (0000000000092DC8) ----------------------------------------------------
__int64 __fastcall sub_92DC8(__int64 *a1, __int64 a2, __int64 a3, const char *a4, unsigned int a5, __int64 a6)
{
  unsigned int v6; // eax
  unsigned int v7; // ST34_4
  __int64 v8; // rax
  signed int v9; // eax
  __int64 v11; // [rsp+0h] [rbp-A0h]
  char *s; // [rsp+10h] [rbp-90h]
  __int64 v13; // [rsp+18h] [rbp-88h]
  unsigned int v14; // [rsp+30h] [rbp-70h]
  _QWORD *v15; // [rsp+38h] [rbp-68h]
  _DWORD *v16; // [rsp+40h] [rbp-60h]
  __int64 v17; // [rsp+48h] [rbp-58h]
  __int64 *v18; // [rsp+50h] [rbp-50h]
  __int64 v19; // [rsp+58h] [rbp-48h]
  __int64 v20; // [rsp+60h] [rbp-40h]
  __int64 v21; // [rsp+68h] [rbp-38h]
  char v22; // [rsp+88h] [rbp-18h]
  unsigned __int64 v23; // [rsp+98h] [rbp-8h]

  v13 = a3;
  s = (char *)a4;
  v11 = a6;
  v23 = __readfsqword(0x28u);
  v15 = 0LL;
  v14 = 0;
  if ( a5 )
    v6 = a5;
  else
    v6 = strlen(a4) + 2;
  v7 = v6;
  sub_8B1A8((void **)&v15);
  sub_8AF8F(*a1, v15);
  v16 = sub_8ABCE((__int64)s, v7, (unsigned __int64)v15);
  sub_8A361((__int64)v16, (unsigned __int64)v15);
  memset(&v18, 0, 0x40uLL);
  v18 = a1;
  v19 = a2;
  v20 = v13;
  v21 = v11;
  v22 |= 1u;
  if ( (unsigned int)sub_7212F(v15, &v18) )
  {
    if ( v22 & 1 )
    {
      if ( a2 )
        v8 = a2;
      else
        v8 = (__int64)a1;
      v17 = v8;
      sub_93FD3(*(_QWORD *)v8, *(_QWORD *)(v8 + 96), 0, *(_BYTE *)(v8 + 69));
      sub_94115(*(_QWORD *)v17, *(_QWORD *)(v17 + 104), 0, *(_BYTE *)(v17 + 70));
      *(_BYTE *)(v17 + 70) = 0;
      *(_BYTE *)(v17 + 69) = 0;
    }
    if ( v22 & 2 )
      v9 = 1;
    else
      v9 = -1;
    v14 = v9;
  }
  sub_8A5E0((__int64)v16, (__int64)v15);
  sub_8B3C7((__int64)v15);
  return v14;
}
// 7212F: using guessed type __int64 __fastcall sub_7212F(_QWORD, _QWORD);

//----- (0000000000092FC8) ----------------------------------------------------
__int64 __fastcall sub_92FC8(__int64 *a1, __int64 a2, const char *a3, __int64 a4, __int64 *a5)
{
  unsigned int v6; // ST34_4
  __int64 *v7; // [rsp+8h] [rbp-98h]
  __int64 v8; // [rsp+10h] [rbp-90h]
  char *s; // [rsp+18h] [rbp-88h]
  unsigned int v10; // [rsp+30h] [rbp-70h]
  unsigned __int64 v11; // [rsp+38h] [rbp-68h]
  unsigned __int8 *v12; // [rsp+40h] [rbp-60h]
  _DWORD *v13; // [rsp+48h] [rbp-58h]
  __int64 *v14; // [rsp+50h] [rbp-50h]
  __int64 v15; // [rsp+60h] [rbp-40h]
  unsigned __int8 **v16; // [rsp+68h] [rbp-38h]
  __int64 v17; // [rsp+78h] [rbp-28h]
  __int64 *v18; // [rsp+80h] [rbp-20h]
  char v19; // [rsp+88h] [rbp-18h]
  unsigned __int64 v20; // [rsp+98h] [rbp-8h]

  s = (char *)a3;
  v8 = a4;
  v7 = a5;
  v20 = __readfsqword(0x28u);
  v11 = 0LL;
  v10 = 0;
  v12 = 0LL;
  if ( !a3 )
    return 0LL;
  v6 = strlen(a3) + 2;
  sub_8B1A8((void **)&v11);
  v13 = sub_8ABCE((__int64)s, v6, v11);
  sub_8A361((__int64)v13, v11);
  memset(&v14, 0, 0x40uLL);
  v14 = a1;
  v15 = a2;
  v16 = &v12;
  v18 = v7;
  v17 = v8;
  v19 |= 4u;
  if ( (unsigned int)sub_7212F(v11, &v14) )
  {
    sub_94BFB(*a1, v12);
    v10 = -1;
  }
  else if ( v12 )
  {
    if ( (unsigned int)sub_980FB((__int64)a1, v7, (__int64)v12, 1u, a2) )
      v10 = -1;
  }
  sub_8A5E0((__int64)v13, v11);
  sub_8B3C7(v11);
  return v10;
}
// 7212F: using guessed type __int64 __fastcall sub_7212F(_QWORD, _QWORD);

//----- (000000000009316E) ----------------------------------------------------
void *__fastcall sub_9316E(__int64 a1, const char *a2, unsigned int a3, char *a4, int a5)
{
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  const char *v14; // rax
  void *v15; // rcx
  const char *v16; // rdx
  void *result; // rax
  void *v18; // rdi
  int *v19; // rax
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rbx
  int *v23; // rax
  __int64 v24; // r9
  int *v25; // rax
  __int64 v26; // r8
  __int64 v27; // r9
  const char *s1; // [rsp+0h] [rbp-60h]
  int v29; // [rsp+8h] [rbp-58h]
  unsigned int v30; // [rsp+Ch] [rbp-54h]
  __int64 v31; // [rsp+18h] [rbp-48h]
  int v32; // [rsp+24h] [rbp-3Ch]
  __int128 v33; // [rsp+28h] [rbp-38h]
  void *ptr; // [rsp+38h] [rbp-28h]
  unsigned __int8 *v35; // [rsp+40h] [rbp-20h]
  unsigned __int64 v36; // [rsp+48h] [rbp-18h]

  v31 = a1;
  v30 = a3;
  s1 = a4;
  v29 = a5;
  v36 = __readfsqword(0x28u);
  ptr = 0LL;
  v33 = 0uLL;
  *(_QWORD *)&v33 = calloc(1uLL, 0x28uLL);
  if ( !(_QWORD)v33 )
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_module", v5, s1);
    goto LABEL_43;
  }
  ptr = calloc(1uLL, 0xB8uLL);
  if ( !ptr )
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_module", v6, s1);
    goto LABEL_43;
  }
  *(_QWORD *)ptr = a1;
  *((_BYTE *)ptr + 64) &= 0xFEu;
  *((_BYTE *)ptr + 64) = ((v29 != 0) << 7) | *((_BYTE *)ptr + 64) & 0x7F;
  if ( (unsigned int)sub_3CCDF((__int64 *)ptr) )
    goto LABEL_43;
  v32 = sub_92DC8((__int64 *)ptr, 0LL, v33, a2, v30, (__int64)&v33 + 8);
  if ( v32 == -1 )
  {
    if ( (unsigned int)ly_vecode(a1) != 36 || *((_QWORD *)ptr + 1) )
    {
      sub_9534B((__int64 *)ptr, *((unsigned __int8 **)&v33 + 1));
    }
    else
    {
      sub_3CDA9(a1);
      free(ptr);
      ptr = 0LL;
    }
    goto LABEL_43;
  }
  if ( v32 == 1 )
  {
    if ( *(_DWORD *)(v33 + 32) )
      __assert_fail(
        "!unres->count",
        "/home/mantovan/Repositories/libyang/src/parser_yang.c",
        0xA62u,
        "yang_read_module");
  }
  else
  {
    v9 = v33;
    if ( (unsigned int)sub_9979D(ptr, v33, *((unsigned __int8 **)&v33 + 1), v33, v7, v8) )
      goto LABEL_43;
    if ( !v29 && *((_BYTE *)ptr + 64) < 0 )
    {
      v9 = v33;
      if ( (unsigned int)sub_A9962((__int64)ptr, v33) )
        goto LABEL_43;
    }
    if ( *(_DWORD *)(v33 + 32) )
    {
      v9 = v33;
      if ( (unsigned int)sub_2A9F8((__int64 *)ptr, v33, v33, v11, v12, v13) )
        goto LABEL_43;
    }
    if ( (unsigned int)sub_3D700((__int64)ptr, v9, v10, v11, v12, v13) )
      goto LABEL_43;
  }
  sub_3DBD2((__int64)ptr);
  if ( (unsigned int)sub_3E3AF((__int64)ptr) || (unsigned int)sub_3F5FE((__int64)ptr) )
    goto LABEL_43;
  if ( s1 && (!*((_BYTE *)ptr + 68) || strcmp(s1, *((const char **)ptr + 11))) )
  {
    sub_12222(
      0LL,
      2u,
      0,
      "Module \"%s\" parsed with the wrong revision (\"%s\" instead \"%s\").",
      *((_QWORD *)ptr + 1),
      *((_QWORD *)ptr + 11),
      s1);
    goto LABEL_43;
  }
  if ( v32 )
  {
    v35 = (unsigned __int8 *)ptr;
    ptr = (void *)ly_ctx_get_module(a1, *((_QWORD *)ptr + 1), s1, 0LL);
    if ( !ptr )
      __assert_fail("module", "/home/mantovan/Repositories/libyang/src/parser_yang.c", 0xA92u, "yang_read_module");
    sub_A67C8(v35, 0LL, 0, 0);
    goto LABEL_33;
  }
  if ( (unsigned int)sub_3FFC3((__int64 *)ptr) )
  {
LABEL_43:
    v18 = ptr;
    sub_2B768((__int64)ptr, (void ***)&v33, 1);
    if ( ptr )
    {
      if ( *((_QWORD *)ptr + 1) )
      {
        v22 = *((_QWORD *)ptr + 1);
        v23 = (int *)ly_errno_glob_address(v18);
        sub_12222(v31, 0, *v23, "Module \"%s\" parsing failed.", v22, v24, s1);
      }
      else
      {
        v25 = (int *)ly_errno_glob_address(v18);
        sub_12222(v31, 0, *v25, "Module parsing failed.", v26, v27, s1);
      }
      sub_3CDA9(v31);
      sub_A9496((__int64)ptr);
      sub_3C867(ptr, 1);
      sub_A67C8((unsigned __int8 *)ptr, 0LL, 0, 1);
      result = 0LL;
    }
    else
    {
      if ( (unsigned int)ly_vecode(v31) != 36 )
      {
        v19 = (int *)ly_errno_glob_address(v31);
        sub_12222(v31, 0, *v19, "Module parsing failed.", v20, v21, s1);
      }
      result = 0LL;
    }
    return result;
  }
  sub_3C867(ptr, 0);
LABEL_33:
  sub_2B768(0LL, (void ***)&v33, 0);
  sub_3CDA9(a1);
  if ( *((_BYTE *)ptr + 64) >= 0 )
    v14 = "imported";
  else
    v14 = "implemented";
  if ( *((_BYTE *)ptr + 68) )
    v15 = (void *)*((_QWORD *)ptr + 11);
  else
    v15 = &unk_1208B5;
  if ( *((_BYTE *)ptr + 68) )
    v16 = "@";
  else
    v16 = (const char *)&unk_1208B5;
  sub_12222(0LL, 2u, 0, "Module \"%s%s%s\" successfully parsed as %s.", *((_QWORD *)ptr + 1), (__int64)v16, v15, v14);
  return ptr;
}
// 71B0: using guessed type __int64 __fastcall ly_vecode(_QWORD);
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000093708) ----------------------------------------------------
void *__fastcall sub_93708(__int64 a1, const char *a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // r9
  void *v5; // rdi
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r9
  void *result; // rax
  void *v10; // rdi
  int *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rbx
  int *v15; // rax
  __int64 v16; // r9
  __int64 v17; // [rsp+0h] [rbp-50h]
  unsigned int v18; // [rsp+Ch] [rbp-44h]
  const char *v19; // [rsp+10h] [rbp-40h]
  __int64 v20; // [rsp+18h] [rbp-38h]
  unsigned __int8 *v21; // [rsp+28h] [rbp-28h]
  void *ptr; // [rsp+30h] [rbp-20h]
  unsigned __int64 v23; // [rsp+38h] [rbp-18h]

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v23 = __readfsqword(0x28u);
  v21 = 0LL;
  ptr = calloc(1uLL, 0xB0uLL);
  if ( ptr )
  {
    *(_QWORD *)ptr = *(_QWORD *)v20;
    *((_BYTE *)ptr + 64) |= 1u;
    *((_BYTE *)ptr + 64) = (*(_BYTE *)(v20 + 64) >> 7 << 7) | *((_BYTE *)ptr + 64) & 0x7F;
    *((_QWORD *)ptr + 21) = v20;
    v5 = ptr;
    if ( !(unsigned int)sub_3CCDF((__int64 *)ptr) )
    {
      if ( (unsigned int)sub_92DC8((__int64 *)v20, (__int64)ptr, v17, v19, v18, (__int64)&v21) )
      {
        v5 = ptr;
        sub_9534B((__int64 *)ptr, v21);
      }
      else
      {
        sub_3DBD2((__int64)ptr);
        v5 = ptr;
        if ( !(unsigned int)sub_9979D(ptr, v17, v21, v17, v6, v7) )
        {
          sub_3CDA9(*(_QWORD *)v20);
          sub_12222(0LL, 2u, 0, "Submodule \"%s\" successfully parsed.", *((_QWORD *)ptr + 1), v8, v17);
          return ptr;
        }
      }
    }
  }
  else
  {
    v5 = *(void **)v20;
    sub_12222(*(_QWORD *)v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_submodule", v4, v17);
  }
  if ( ptr && *((_QWORD *)ptr + 1) )
  {
    v14 = *((_QWORD *)ptr + 1);
    v15 = (int *)ly_errno_glob_address(v5);
    sub_12222(*(_QWORD *)v20, 0, *v15, "Submodule \"%s\" parsing failed.", v14, v16, v17);
    sub_2B768((__int64)ptr, (void ***)&v17, 0);
    sub_3CDA9(*(_QWORD *)v20);
    sub_A9496((__int64)ptr);
    sub_AA3F6((__int64)ptr);
    sub_A3E76((__int64 *)ptr, 0LL);
    result = 0LL;
  }
  else
  {
    v10 = ptr;
    free(ptr);
    v11 = (int *)ly_errno_glob_address(v10);
    sub_12222(*(_QWORD *)v20, 0, *v11, "Submodule parsing failed.", v12, v13, v17);
    result = 0LL;
  }
  return result;
}
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);

//----- (0000000000093982) ----------------------------------------------------
__int64 __fastcall sub_93982(__int64 a1, int a2, int a3, int a4, _DWORD *a5, __int64 a6)
{
  int v7; // [rsp+14h] [rbp-24h]
  int v8; // [rsp+30h] [rbp-8h]
  int i; // [rsp+34h] [rbp-4h]

  v7 = a4;
  v8 = 0;
  while ( v7 < a3 )
  {
    if ( *(_BYTE *)(v7 + a1) == 32 )
    {
      ++v8;
    }
    else
    {
      if ( *(_BYTE *)(v7 + a1) != 9 )
        return (unsigned int)(v7 - 1);
      v8 += 8;
    }
    ++v7;
    if ( v8 >= a2 )
    {
      for ( i = v8 - a2; i > 0; --i )
        *(_BYTE *)((signed int)++*a5 + a6) = 32;
      return (unsigned int)(v7 - 1);
    }
  }
  return (unsigned int)(v7 - 1);
}

//----- (0000000000093A2E) ----------------------------------------------------
_BYTE *__fastcall sub_93A2E(void *a1, __int64 a2, _BYTE *a3, int a4, int a5, __int64 a6)
{
  signed int v6; // eax
  __int64 v8; // r9
  int v9; // [rsp+Ch] [rbp-44h]
  int v10; // [rsp+14h] [rbp-3Ch]
  _BYTE *ptr; // [rsp+18h] [rbp-38h]
  int v12; // [rsp+3Ch] [rbp-14h]
  int v13; // [rsp+40h] [rbp-10h]
  int v14; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  ptr = a3;
  v10 = a4;
  v9 = a6;
  v15 = __readfsqword(0x28u);
  v13 = 0;
  v12 = a5;
  v14 = 0;
  while ( v13 < v10 )
  {
    v6 = *(char *)(v13 + a2);
    if ( v6 == 10 )
    {
      v12 -= v14;
      ptr[v12] = 10;
      v14 = 0;
      v13 = sub_93982(a2, v9, v10, v13 + 1, &v12, (__int64)ptr);
      goto LABEL_23;
    }
    if ( v6 <= 10 )
    {
      if ( v6 == 9 )
        goto LABEL_10;
LABEL_22:
      ptr[v12] = *(_BYTE *)(v13 + a2);
      v14 = 0;
      goto LABEL_23;
    }
    if ( v6 == 32 )
    {
LABEL_10:
      ptr[v12] = *(_BYTE *)(v13 + a2);
      ++v14;
      goto LABEL_23;
    }
    if ( v6 != 92 )
      goto LABEL_22;
    v14 = 0;
    switch ( *(_BYTE *)(v13 + 1LL + a2) )
    {
      case 0x6E:
        ptr[v12] = 10;
        break;
      case 0x74:
        ptr[v12] = 9;
        break;
      case 0x5C:
        ptr[v12] = 92;
        break;
      default:
        if ( v10 == v13 + 1 || *(_BYTE *)(v13 + 1LL + a2) != 34 )
        {
          sub_13937(a1, 3, 0, 0LL, a2 + v13, a6);
          return 0LL;
        }
        ptr[v12] = 34;
        break;
    }
    ++v13;
LABEL_23:
    ++v13;
    ++v12;
  }
  ptr[v12] = 0;
  if ( v10 == v12 )
    return ptr;
  ptr = realloc(ptr, v12 + 1);
  if ( ptr )
    return ptr;
  sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_string", v8);
  return 0LL;
}

//----- (0000000000093CE2) ----------------------------------------------------
void *__fastcall sub_93CE2(__int64 a1, __int64 a2)
{
  void *result; // rax
  unsigned int i; // [rsp+14h] [rbp-Ch]
  unsigned int j; // [rsp+14h] [rbp-Ch]
  _QWORD *ptr; // [rsp+18h] [rbp-8h]

  result = *(void **)(a2 + 16);
  ptr = *(_QWORD **)(a2 + 16);
  if ( ptr )
  {
    if ( !*(_DWORD *)a2 || *(_DWORD *)a2 == 11 )
    {
      lydict_remove(a1, ptr[1]);
      if ( *((_DWORD *)ptr + 1) == 7 && !(*(_BYTE *)ptr & 0x20) )
      {
        for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
          free(*(void **)(8LL * i + *(_QWORD *)(a2 + 32)));
      }
      if ( *((_DWORD *)ptr + 1) == 11 )
      {
        for ( j = 0; j < *(_DWORD *)(a2 + 40); ++j )
          sub_93CE2(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)j << 6));
        free(*(void **)(a2 + 32));
        *(_DWORD *)a2 = 0;
      }
      else
      {
        *(_DWORD *)a2 = *((_DWORD *)ptr + 1);
      }
      free(ptr);
      *(_QWORD *)(a2 + 16) = 0LL;
    }
    sub_A1648(a1, a2, 0LL);
    result = memset((void *)a2, 0, 0x40uLL);
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000093E46) ----------------------------------------------------
__int64 __fastcall sub_93E46(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned int a4)
{
  __int64 result; // rax
  unsigned __int16 v5; // [rsp+8h] [rbp-28h]
  unsigned __int16 i; // [rsp+2Eh] [rbp-2h]

  result = a4;
  v5 = a4;
  if ( !a1 )
    __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/parser_yang.c", 0xB60u, "yang_tpdf_free");
  if ( a2 )
  {
    for ( i = a3; ; ++i )
    {
      result = i;
      if ( i >= v5 )
        break;
      lydict_remove(a1, *(_QWORD *)(((unsigned __int64)i << 7) + a2));
      lydict_remove(a1, *(_QWORD *)(((unsigned __int64)i << 7) + a2 + 8));
      lydict_remove(a1, *(_QWORD *)(((unsigned __int64)i << 7) + a2 + 16));
      sub_93CE2(a1, ((unsigned __int64)i << 7) + a2 + 56);
      lydict_remove(a1, *(_QWORD *)(((unsigned __int64)i << 7) + a2 + 40));
      lydict_remove(a1, *(_QWORD *)(((unsigned __int64)i << 7) + a2 + 120));
      sub_AAE3B(
        a1,
        *(void ****)(((unsigned __int64)i << 7) + a2 + 32),
        *(unsigned __int8 *)(((unsigned __int64)i << 7) + a2 + 26),
        0LL);
    }
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000093FD3) ----------------------------------------------------
__int64 __fastcall sub_93FD3(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int64 result; // rax
  unsigned __int8 v5; // [rsp+8h] [rbp-28h]
  unsigned __int8 i; // [rsp+2Fh] [rbp-1h]

  v5 = a4;
  for ( i = a3; ; ++i )
  {
    result = i;
    if ( i >= v5 )
      break;
    free(*(void **)(56LL * i + a2));
    lydict_remove(a1, *(_QWORD *)(56LL * i + a2 + 8));
    lydict_remove(a1, *(_QWORD *)(56LL * i + a2 + 40));
    lydict_remove(a1, *(_QWORD *)(56LL * i + a2 + 48));
    sub_AAE3B(a1, *(void ****)(56LL * i + a2 + 32), *(unsigned __int8 *)(56LL * i + a2 + 27), 0LL);
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000094115) ----------------------------------------------------
__int64 __fastcall sub_94115(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int64 result; // rax
  unsigned __int8 v5; // [rsp+8h] [rbp-28h]
  unsigned __int8 i; // [rsp+2Fh] [rbp-1h]

  v5 = a4;
  for ( i = a3; ; ++i )
  {
    result = i;
    if ( i >= v5 )
      break;
    free(*(void **)(48LL * i + a2));
    lydict_remove(a1, *(_QWORD *)(48LL * i + a2 + 32));
    lydict_remove(a1, *(_QWORD *)(48LL * i + a2 + 40));
    sub_AAE3B(a1, *(void ****)(48LL * i + a2 + 24), *(unsigned __int8 *)(48LL * i + a2 + 19), 0LL);
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000094223) ----------------------------------------------------
__int64 __fastcall sub_94223(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 result; // rax
  unsigned int v4; // [rsp+0h] [rbp-20h]
  unsigned __int8 j; // [rsp+1Bh] [rbp-5h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  v4 = a3;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    for ( j = 0; j < *(_BYTE *)(72LL * i + a1 + 31); ++j )
      free(*(void **)(8LL * j + *(_QWORD *)(72LL * i + a1 + 56)));
  }
  return result;
}

//----- (00000000000942AF) ----------------------------------------------------
void __fastcall sub_942AF(__int64 a1, __int64 a2)
{
  sub_93E46(a1, *(_QWORD *)(a2 + 104), 0, *(unsigned __int16 *)(a2 + 30));
  free(*(void **)(a2 + 104));
}

//----- (00000000000942F8) ----------------------------------------------------
void __fastcall sub_942F8(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  sub_93E46(a1, *(_QWORD *)(a2 + 128), 0, *(unsigned __int16 *)(a2 + 30));
  free(*(void **)(a2 + 128));
  lydict_remove(a1, *(_QWORD *)(a2 + 136));
  for ( i = 0; i < *(_BYTE *)(a2 + 29); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), 0LL);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), 0LL);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000943D5) ----------------------------------------------------
__int64 __fastcall sub_943D5(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  for ( i = 0; i < *(_BYTE *)(a2 + 31); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), 0LL);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), 0LL);
  sub_93CE2(a1, a2 + 128);
  lydict_remove(a1, *(_QWORD *)(a2 + 192));
  return lydict_remove(a1, *(_QWORD *)(a2 + 200));
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000944B0) ----------------------------------------------------
__int64 __fastcall sub_944B0(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]
  unsigned __int8 j; // [rsp+1Fh] [rbp-1h]

  for ( i = 0; i < *(_BYTE *)(a2 + 31); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), 0LL);
  free(*(void **)(a2 + 120));
  for ( j = 0; j < *(_BYTE *)(a2 + 30); ++j )
    lydict_remove(a1, *(_QWORD *)(8LL * j + *(_QWORD *)(a2 + 200)));
  free(*(void **)(a2 + 200));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), 0LL);
  sub_93CE2(a1, a2 + 128);
  return lydict_remove(a1, *(_QWORD *)(a2 + 192));
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000945C9) ----------------------------------------------------
void __fastcall sub_945C9(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]
  unsigned __int8 j; // [rsp+1Fh] [rbp-1h]

  sub_93E46(a1, *(_QWORD *)(a2 + 128), 0, *(unsigned __int8 *)(a2 + 29));
  free(*(void **)(a2 + 128));
  for ( i = 0; i < *(_BYTE *)(a2 + 28); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), 0LL);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), 0LL);
  for ( j = 0; j < *(_BYTE *)(a2 + 31); ++j )
    free(*(void **)(16LL * j + *(_QWORD *)(a2 + 144)));
  free(*(void **)(a2 + 144));
  free(*(void **)(a2 + 136));
}

//----- (00000000000946EA) ----------------------------------------------------
void __fastcall sub_946EA(__int64 a1, __int64 a2)
{
  free(*(void **)(a2 + 112));
  sub_A1E16(a1, *(_QWORD **)(a2 + 104), 0LL);
}

//----- (0000000000094729) ----------------------------------------------------
void __fastcall sub_94729(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  for ( i = 0; i < *(_BYTE *)(a2 + 31); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), 0LL);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), 0LL);
}

//----- (00000000000947B0) ----------------------------------------------------
void __fastcall sub_947B0(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  sub_93E46(a1, *(_QWORD *)(a2 + 104), 0, *(unsigned __int16 *)(a2 + 30));
  free(*(void **)(a2 + 104));
  for ( i = 0; i < *(_BYTE *)(a2 + 29); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 112), 0LL);
  free(*(void **)(a2 + 112));
}

//----- (0000000000094851) ----------------------------------------------------
void __fastcall sub_94851(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  sub_93E46(a1, *(_QWORD *)(a2 + 112), 0, *(unsigned __int16 *)(a2 + 30));
  free(*(void **)(a2 + 112));
  for ( i = 0; i < *(_BYTE *)(a2 + 29); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), 0LL);
  free(*(void **)(a2 + 120));
}

//----- (00000000000948F2) ----------------------------------------------------
void __fastcall sub_948F2(__int64 a1, __int64 a2)
{
  signed int i; // [rsp+18h] [rbp-8h]
  signed int j; // [rsp+1Ch] [rbp-4h]
  signed int k; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a2 + 30); ++i )
  {
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i));
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 8));
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 16));
    for ( j = 0; j < *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 30); ++j )
      sub_9F606(a1, 56LL * j + *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 56), 0LL);
    free(*(void **)(*(_QWORD *)(a2 + 112) + 80LL * i + 56));
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 31); ++k )
      lydict_remove(a1, *(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 64)));
    free(*(void **)(*(_QWORD *)(a2 + 112) + 80LL * i + 64));
    if ( *(_WORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 28) & 1 )
      lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 72));
    sub_AAE3B(
      a1,
      *(void ****)(*(_QWORD *)(a2 + 112) + 80LL * i + 32),
      *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 26),
      0LL);
  }
  free(*(void **)(a2 + 112));
  sub_A1E16(a1, *(_QWORD **)(a2 + 104), 0LL);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000094BFB) ----------------------------------------------------
void __fastcall sub_94BFB(__int64 a1, unsigned __int8 *a2)
{
  unsigned int v2; // eax
  unsigned __int8 *ptr; // [rsp+18h] [rbp-18h]
  __int64 v4; // [rsp+20h] [rbp-10h]
  unsigned __int8 *v5; // [rsp+28h] [rbp-8h]

  if ( a2 )
  {
    for ( ptr = a2; ; ptr = v5 )
    {
      if ( !ptr )
        return;
      v4 = *((_QWORD *)ptr + 9);
      v5 = (unsigned __int8 *)*((_QWORD *)ptr + 10);
      lydict_remove(a1, *(_QWORD *)ptr);
      if ( !(*((_DWORD *)ptr + 14) & 0x600) )
      {
        lys_iffeature_free(a1, *((_QWORD *)ptr + 5), ptr[27], 0LL, 0LL);
        lydict_remove(a1, *((_QWORD *)ptr + 1));
        lydict_remove(a1, *((_QWORD *)ptr + 2));
      }
      v2 = *((_DWORD *)ptr + 14);
      if ( v2 == 128 )
      {
        sub_94851(a1, (__int64)ptr);
      }
      else if ( v2 > 0x80 )
      {
        if ( v2 == 2048 )
          goto LABEL_27;
        if ( v2 > 0x800 )
        {
          switch ( v2 )
          {
            case 0x4000u:
LABEL_27:
              sub_942AF(a1, (__int64)ptr);
              break;
            case 0x8020u:
LABEL_34:
              sub_94729(a1, (__int64)ptr);
              break;
            case 0x1000u:
              sub_948F2(a1, (__int64)ptr);
              break;
          }
        }
        else if ( v2 == 512 || v2 == 1024 )
        {
          sub_947B0(a1, (__int64)ptr);
        }
        else if ( v2 == 256 )
        {
          goto LABEL_27;
        }
      }
      else
      {
        if ( v2 == 8 )
        {
          sub_944B0(a1, (__int64)ptr);
          goto LABEL_38;
        }
        if ( v2 > 8 )
        {
          switch ( v2 )
          {
            case 0x20u:
              goto LABEL_34;
            case 0x40u:
              sub_A1E16(a1, *((_QWORD **)ptr + 13), 0LL);
              break;
            case 0x10u:
              sub_945C9(a1, (__int64)ptr);
              break;
          }
        }
        else
        {
          switch ( v2 )
          {
            case 2u:
              sub_946EA(a1, (__int64)ptr);
              break;
            case 4u:
              sub_943D5(a1, (__int64)ptr);
              break;
            case 1u:
              sub_942F8(a1, (__int64)ptr);
              break;
          }
        }
      }
LABEL_38:
      sub_AAE3B(a1, *((void ****)ptr + 4), ptr[26], 0LL);
      sub_94BFB(a1, v4);
      free(ptr);
    }
  }
}
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000094ECB) ----------------------------------------------------
void __fastcall sub_94ECB(__int64 a1, __int64 a2)
{
  __int64 v2; // ST00_8

  v2 = a2;
  lydict_remove(a1, *(_QWORD *)a2);
  lydict_remove(a1, *(_QWORD *)(a2 + 8));
  lydict_remove(a1, *(_QWORD *)(a2 + 16));
  lys_iffeature_free(a1, *(_QWORD *)(v2 + 40), *(unsigned __int8 *)(v2 + 27), 0LL, 0LL);
  sub_A1E16(a1, *(_QWORD **)(a2 + 80), 0LL);
  sub_94BFB(a1, *(unsigned __int8 **)(a2 + 72));
  sub_AAE3B(a1, *(void ****)(v2 + 32), *(unsigned __int8 *)(v2 + 26), 0LL);
}
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000094FA3) ----------------------------------------------------
__int64 __fastcall sub_94FA3(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int j; // [rsp+2Ch] [rbp-4h]
  unsigned int k; // [rsp+2Ch] [rbp-4h]
  unsigned int l; // [rsp+2Ch] [rbp-4h]

  for ( i = a3; ; ++i )
  {
    result = *(unsigned __int8 *)(a2 + 32);
    if ( i >= (unsigned int)result )
      break;
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * i + 48));
    if ( *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * i + 40) )
    {
      sub_93CE2(a1, *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * i + 40));
      free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * i + 40));
    }
    for ( j = 0; j < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * i + 5); ++j )
      lydict_remove(a1, *(_QWORD *)(8LL * j + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * i + 56)));
    free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * i + 56));
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * i + 9); ++k )
      sub_9F606(a1, 56LL * k + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * i + 24), 0LL);
    free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * i + 24));
    for ( l = 0; l < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * i + 10); ++l )
      free(*(void **)(16LL * l + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * i + 32)));
    free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * i + 32));
    sub_AAE3B(
      a1,
      *(void ****)(*(_QWORD *)(a2 + 40) + 72LL * i + 64),
      *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * i + 6),
      0LL);
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000952AD) ----------------------------------------------------
void __fastcall sub_952AD(void **a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    free(*a1);
    if ( a1[1] )
    {
      for ( i = 0; *((_QWORD *)a1[1] + i); ++i )
        free(*((void **)a1[1] + i));
      free(a1[1]);
    }
    free(a1);
  }
}

//----- (000000000009534B) ----------------------------------------------------
__int64 *__fastcall sub_9534B(__int64 *a1, unsigned __int8 *a2)
{
  __int64 *result; // rax
  unsigned int i; // [rsp+1Ch] [rbp-4h]
  unsigned int j; // [rsp+1Ch] [rbp-4h]

  sub_93E46(*a1, a1[14], 0, *((unsigned __int16 *)a1 + 37));
  *((_WORD *)a1 + 37) = 0;
  sub_94223(a1[15], 0, *((unsigned __int16 *)a1 + 36));
  sub_94BFB(*a1, a2);
  for ( i = 0; i < *((unsigned __int8 *)a1 + 77); ++i )
    sub_94ECB(*a1, a1[17] + 104LL * i);
  *((_BYTE *)a1 + 77) = 0;
  for ( j = 0; j < *((unsigned __int8 *)a1 + 78); ++j )
  {
    sub_94FA3(*a1, 56LL * j + a1[18], 0);
    free(*(void **)(a1[18] + 56LL * j + 40));
    lydict_remove(*a1, *(_QWORD *)(a1[18] + 56LL * j));
    lydict_remove(*a1, *(_QWORD *)(a1[18] + 56LL * j + 8));
    lydict_remove(*a1, *(_QWORD *)(a1[18] + 56LL * j + 16));
  }
  result = a1;
  *((_BYTE *)a1 + 78) = 0;
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000009554F) ----------------------------------------------------
signed __int64 __fastcall sub_9554F(__int64 *a1, __int64 *a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+1Ch] [rbp-24h]
  unsigned int i; // [rsp+34h] [rbp-Ch]
  _DWORD *v11; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  for ( i = 0; i < v9; ++i )
  {
    v11 = malloc(0x30uLL);
    if ( !v11 )
    {
      sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_check_ext_instance", v5);
      return 1LL;
    }
    *(_QWORD *)v11 = *(_QWORD *)(*(_QWORD *)(8LL * i + *a2) + 8LL);
    v11[2] = 1;
    *((_QWORD *)v11 + 2) = v8;
    *((_QWORD *)v11 + 3) = a1;
    v11[8] = *(unsigned __int8 *)(*(_QWORD *)(8LL * i + *a2) + 29LL);
    v11[9] = *(unsigned __int8 *)(*(_QWORD *)(8LL * i + *a2) + 28LL);
    *((_BYTE *)v11 + 40) = *(_BYTE *)(*(_QWORD *)(8LL * i + *a2) + 27LL);
    *((_BYTE *)v11 + 41) = i;
    if ( (unsigned int)sub_2ABDE(a1, v7, a2, 0x10000u, (__int64 *)v11) == -1 )
      return 1LL;
  }
  return 0LL;
}

//----- (00000000000956B5) ----------------------------------------------------
signed __int64 __fastcall sub_956B5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *v6; // ST28_8
  __int64 v7; // ST28_8
  unsigned __int8 v9; // [rsp+14h] [rbp-1Ch]
  unsigned __int8 j; // [rsp+14h] [rbp-1Ch]
  unsigned __int8 i; // [rsp+15h] [rbp-1Bh]
  unsigned __int8 v12; // [rsp+16h] [rbp-1Ah]
  unsigned __int8 v13; // [rsp+17h] [rbp-19h]
  void *v14; // [rsp+18h] [rbp-18h]
  void *ptr; // [rsp+20h] [rbp-10h]

  v9 = 0;
  i = 0;
  v14 = *(void **)(a1 + 96);
  v12 = *(_BYTE *)(a1 + 69);
  ptr = *(void **)(a1 + 104);
  v13 = *(_BYTE *)(a1 + 70);
  if ( v12 )
  {
    *(_QWORD *)(a1 + 96) = calloc(v12, 0x38uLL);
    *(_BYTE *)(a1 + 69) = 0;
    if ( !*(_QWORD *)(a1 + 96) )
    {
      sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_check_imports", a6, a2);
LABEL_18:
      sub_93FD3(*(_QWORD *)a1, (__int64)v14, i, v12);
      sub_94115(*(_QWORD *)a1, (__int64)ptr, v9, v13);
      free(v14);
      free(ptr);
      return 1LL;
    }
  }
  if ( v13 )
  {
    *(_QWORD *)(a1 + 104) = calloc(v13, 0x30uLL);
    *(_BYTE *)(a1 + 70) = 0;
    if ( !*(_QWORD *)(a1 + 104) )
    {
      sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_check_imports", a6, a2);
      goto LABEL_18;
    }
  }
  for ( i = 0; i < v12; ++i )
  {
    v6 = (void *)*((_QWORD *)v14 + 7 * i);
    *((_QWORD *)v14 + 7 * i) = 0LL;
    if ( (unsigned int)sub_8B9EC(
                         (__int64 *)a1,
                         (__int64)v14 + 56 * i,
                         (__int64 *)(*(_QWORD *)(a1 + 96) + 56LL * *(unsigned __int8 *)(a1 + 69)),
                         v6,
                         a2,
                         a6) )
    {
      ++i;
      goto LABEL_18;
    }
  }
  for ( j = 0; j < v13; ++j )
  {
    v7 = *((_QWORD *)ptr + 6 * j);
    *((_QWORD *)ptr + 6 * j) = 0LL;
    if ( (unsigned int)sub_91F57((__int64 *)a1, v7, (void ****)ptr + 6 * j, a2) )
    {
      v9 = j + 1;
      goto LABEL_18;
    }
  }
  free(ptr);
  free(v14);
  return 0LL;
}

//----- (00000000000959A9) ----------------------------------------------------
signed __int64 __fastcall sub_959A9(__int64 *a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  const char *v5; // ST48_8
  __int64 v7; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  unsigned __int8 v9; // [rsp+32h] [rbp-1Eh]
  unsigned __int8 i; // [rsp+33h] [rbp-1Dh]
  int v11; // [rsp+34h] [rbp-1Ch]
  __int64 v12; // [rsp+38h] [rbp-18h]
  unsigned __int8 *v13; // [rsp+40h] [rbp-10h]

  v8 = a3;
  v7 = a5;
  v11 = 0;
  switch ( a4 )
  {
    case 279:
      v12 = *(_QWORD *)(a2 + 40);
      v9 = *(_BYTE *)(a2 + 27);
      v13 = (unsigned __int8 *)(a2 + 27);
      break;
    case 287:
      v12 = *(_QWORD *)(a2 + 40);
      v9 = *(_BYTE *)(a2 + 27);
      v13 = (unsigned __int8 *)(a2 + 27);
      break;
    case 293:
      v12 = *(_QWORD *)(a3 + 40);
      v9 = *(_BYTE *)(a3 + 27);
      v13 = (unsigned __int8 *)(a3 + 27);
      v11 = 1;
      break;
    case 296:
      v12 = *(_QWORD *)(a3 + 40);
      v9 = *(_BYTE *)(a3 + 27);
      v13 = (unsigned __int8 *)(a3 + 27);
      break;
    case 323:
      v12 = *(_QWORD *)(a2 + 40);
      v9 = *(_BYTE *)(a2 + 27);
      v13 = (unsigned __int8 *)(a2 + 27);
      break;
    default:
      v12 = *(_QWORD *)(a3 + 40);
      v9 = *(_BYTE *)(a3 + 27);
      v13 = (unsigned __int8 *)(a3 + 27);
      break;
  }
  *v13 = 0;
  for ( i = 0; i < v9; ++i )
  {
    v5 = *(const char **)(32LL * i + v12 + 16);
    *(_QWORD *)(32LL * i + v12 + 16) = 0LL;
    if ( (unsigned int)sub_8BEDF(a1, (__int64 *)(32LL * i + v12), v8, v5, v7, v11) )
    {
      *v13 = v9;
      return 1LL;
    }
    if ( (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(32LL * i + v12 + 24),
                         *(unsigned __int8 *)(32LL * i + v12 + 8),
                         32LL * i + v12,
                         v7) )
    {
      *v13 = v9;
      return 1LL;
    }
    ++*v13;
  }
  return 0LL;
}

//----- (0000000000095C0C) ----------------------------------------------------
signed __int64 __fastcall sub_95C0C(__int64 *a1, __int64 a2, __int64 a3)
{
  void *ptr; // ST40_8
  int v4; // ST34_4
  __int64 v6; // [rsp+8h] [rbp-48h]
  unsigned int i; // [rsp+2Ch] [rbp-24h]
  unsigned int j; // [rsp+2Ch] [rbp-24h]
  unsigned int v9; // [rsp+30h] [rbp-20h]
  void *v10; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v10 = *(void **)(a2 + 32);
  v9 = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 32) = 0LL;
  **(_BYTE **)(a2 + 16) |= 0x20u;
  for ( i = 0; ; ++i )
  {
    if ( i >= v9 )
    {
      free(v10);
      return 0LL;
    }
    ptr = (void *)*((_QWORD *)v10 + i);
    v11 = sub_9BED(a1, *((const char **)v10 + i));
    free(ptr);
    if ( !v11 )
      break;
    v4 = sub_2AB62(a1, v6, (__int64 *)a2, 0x200u, v11);
    lydict_remove(*a1, v11);
    if ( v4 == -1 )
      break;
  }
  for ( j = i + 1; j < v9; ++j )
    free(*((void **)v10 + j));
  free(v10);
  return 1LL;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000095D5C) ----------------------------------------------------
signed __int64 __fastcall sub_95D5C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int64 result; // rax
  __int16 v6; // dx
  __int16 v7; // dx
  __int16 v8; // dx
  __int16 v9; // dx
  __int16 v10; // dx
  __int16 v11; // dx
  __int64 v12; // [rsp+8h] [rbp-38h]
  __int64 v13; // [rsp+10h] [rbp-30h]
  __int64 v14; // [rsp+18h] [rbp-28h]
  unsigned int m; // [rsp+38h] [rbp-8h]
  unsigned int j; // [rsp+38h] [rbp-8h]
  unsigned int jj; // [rsp+38h] [rbp-8h]
  unsigned int ll; // [rsp+38h] [rbp-8h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]
  unsigned int n; // [rsp+3Ch] [rbp-4h]
  unsigned int k; // [rsp+3Ch] [rbp-4h]
  unsigned int ii; // [rsp+3Ch] [rbp-4h]
  unsigned int kk; // [rsp+3Ch] [rbp-4h]
  unsigned int l; // [rsp+3Ch] [rbp-4h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  *(_QWORD *)(a2 + 24) = a4;
  if ( (unsigned int)sub_9554F(a1, (__int64 *)(a2 + 8), *(unsigned __int8 *)(a2 + 5), a2, a5) )
    return 1LL;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 5); ++i )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a2 + 8)) + 24LL) & 8 )
    {
      v6 = *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL);
      HIBYTE(v6) |= 0x20u;
      *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL) = v6;
      break;
    }
  }
  switch ( *(_DWORD *)(v14 + 4) )
  {
    case 2:
      for ( j = 0; ; ++j )
      {
        if ( j >= *(_DWORD *)(a2 + 40) )
          goto LABEL_70;
        if ( (unsigned int)sub_959A9(a1, *(_QWORD *)(a2 + 32) + 48LL * j, v13, 279, v12) )
          return 1LL;
        if ( (unsigned int)sub_9554F(
                             a1,
                             (__int64 *)(*(_QWORD *)(a2 + 32) + 48LL * j + 32),
                             *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * j + 26),
                             48LL * j + *(_QWORD *)(a2 + 32),
                             v12) )
          break;
        for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * j + 26); ++k )
        {
          if ( *(_WORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * j + 32)) + 24LL) & 8 )
          {
            v8 = *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL);
            HIBYTE(v8) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL) = v8;
            break;
          }
        }
      }
      result = 1LL;
      break;
    case 4:
      if ( !*(_QWORD *)(a2 + 32) )
        goto LABEL_70;
      if ( !(unsigned int)sub_9554F(
                            a1,
                            (__int64 *)(*(_QWORD *)(a2 + 32) + 40LL),
                            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL),
                            *(_QWORD *)(a2 + 32),
                            v12) )
      {
        for ( l = 0; l < *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL); ++l )
        {
          if ( *(_WORD *)(*(_QWORD *)(8LL * l + *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL)) + 24LL) & 8 )
          {
            v11 = *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL);
            HIBYTE(v11) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL) = v11;
            goto LABEL_70;
          }
        }
        goto LABEL_70;
      }
      result = 1LL;
      break;
    case 6:
      for ( m = 0; ; ++m )
      {
        if ( m >= *(_DWORD *)(a2 + 40) )
          goto LABEL_70;
        if ( (unsigned int)sub_959A9(a1, *(_QWORD *)(a2 + 32) + 48LL * m, v13, 287, v12) )
          return 1LL;
        if ( (unsigned int)sub_9554F(
                             a1,
                             (__int64 *)(*(_QWORD *)(a2 + 32) + 48LL * m + 32),
                             *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * m + 26),
                             48LL * m + *(_QWORD *)(a2 + 32),
                             v12) )
          break;
        for ( n = 0; n < *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * m + 26); ++n )
        {
          if ( *(_WORD *)(*(_QWORD *)(8LL * n + *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * m + 32)) + 24LL) & 8 )
          {
            v7 = *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL);
            HIBYTE(v7) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL) = v7;
            break;
          }
        }
      }
      result = 1LL;
      break;
    case 7:
      if ( !(unsigned int)sub_95C0C(a1, a2, v12) )
        goto LABEL_70;
      result = 1LL;
      break;
    case 0xA:
      if ( *(_QWORD *)(a2 + 32) )
      {
        if ( (unsigned int)sub_9554F(
                             a1,
                             (__int64 *)(*(_QWORD *)(a2 + 32) + 40LL),
                             *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL),
                             *(_QWORD *)(a2 + 32),
                             v12) )
          return 1LL;
        for ( ii = 0; ii < *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL); ++ii )
        {
          if ( *(_WORD *)(*(_QWORD *)(8LL * ii + *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL)) + 24LL) & 8 )
          {
            v9 = *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL);
            HIBYTE(v9) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL) = v9;
            break;
          }
        }
      }
      for ( jj = 0; ; ++jj )
      {
        if ( jj >= *(_DWORD *)(a2 + 48) )
          goto LABEL_70;
        if ( (unsigned int)sub_9554F(
                             a1,
                             (__int64 *)(*(_QWORD *)(a2 + 40) + 56LL * jj + 40),
                             *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 56LL * jj + 48),
                             56LL * jj + *(_QWORD *)(a2 + 40),
                             v12) )
          break;
        for ( kk = 0; kk < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 56LL * jj + 48); ++kk )
        {
          if ( *(_WORD *)(*(_QWORD *)(8LL * kk + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 56LL * jj + 40)) + 24LL) & 8 )
          {
            v10 = *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL);
            HIBYTE(v10) |= 0x20u;
            *(_WORD *)(*(_QWORD *)(a2 + 24) + 24LL) = v10;
            break;
          }
        }
      }
      result = 1LL;
      break;
    case 0xB:
      for ( ll = 0; ; ++ll )
      {
        if ( ll >= *(_DWORD *)(a2 + 40) )
          goto LABEL_70;
        if ( (unsigned int)sub_95D5C(
                             a1,
                             *(_QWORD *)(a2 + 32) + ((unsigned __int64)ll << 6),
                             *(_QWORD *)(((unsigned __int64)ll << 6) + *(_QWORD *)(a2 + 32) + 16),
                             v13,
                             v12) )
          break;
      }
      result = 1LL;
      break;
    default:
LABEL_70:
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000096496) ----------------------------------------------------
signed __int64 __fastcall sub_96496(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // eax
  __int16 v8; // dx
  __int64 v9; // [rsp+8h] [rbp-38h]
  unsigned __int16 j; // [rsp+22h] [rbp-1Eh]
  unsigned __int16 i; // [rsp+24h] [rbp-1Ch]
  unsigned __int16 v12; // [rsp+26h] [rbp-1Ah]
  __int64 v13; // [rsp+28h] [rbp-18h]
  _BYTE *v14; // [rsp+30h] [rbp-10h]
  unsigned __int16 *v15; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v14 = 0LL;
  v15 = 0LL;
  if ( !a2 )
  {
    v13 = a1[14];
    v15 = (unsigned __int16 *)((char *)a1 + 74);
    goto LABEL_23;
  }
  v6 = *(_DWORD *)(a2 + 56);
  if ( v6 == 256 )
    goto LABEL_19;
  if ( v6 > 0x100 )
  {
    if ( v6 == 1024 )
    {
LABEL_20:
      v13 = *(_QWORD *)(a2 + 104);
      v15 = (unsigned __int16 *)(a2 + 30);
      goto LABEL_23;
    }
    if ( v6 <= 0x400 )
    {
      if ( v6 != 512 )
        goto LABEL_22;
      goto LABEL_20;
    }
    if ( v6 == 2048 )
    {
      v13 = *(_QWORD *)(a2 + 104);
      v15 = (unsigned __int16 *)(a2 + 30);
      goto LABEL_23;
    }
    if ( v6 != 0x4000 )
      goto LABEL_22;
LABEL_19:
    v13 = *(_QWORD *)(a2 + 112);
    v15 = (unsigned __int16 *)(a2 + 30);
    goto LABEL_23;
  }
  switch ( v6 )
  {
    case 0x10u:
      v13 = *(_QWORD *)(a2 + 128);
      v14 = (_BYTE *)(a2 + 29);
      break;
    case 0x80u:
      v13 = *(_QWORD *)(a2 + 112);
      v15 = (unsigned __int16 *)(a2 + 30);
      break;
    case 1u:
      v13 = *(_QWORD *)(a2 + 128);
      v15 = (unsigned __int16 *)(a2 + 30);
      break;
    default:
LABEL_22:
      sub_12222(
        *a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
        3626LL);
      return 1LL;
  }
LABEL_23:
  if ( v15 )
  {
    v12 = *v15;
    *v15 = 0;
  }
  else
  {
    v12 = (unsigned __int8)*v14;
    *v14 = 0;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= v12 )
      return 0LL;
    if ( (unsigned int)sub_3B812(
                         (void *)*a1,
                         *(const char **)(((unsigned __int64)i << 7) + v13),
                         3u,
                         (__int64)a1,
                         a2,
                         a6)
      || (unsigned int)sub_95D5C(
                         a1,
                         ((unsigned __int64)i << 7) + v13 + 56,
                         *(_QWORD *)(((unsigned __int64)i << 7) + v13 + 72),
                         ((unsigned __int64)i << 7) + v13,
                         v9)
      || (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(((unsigned __int64)i << 7) + v13 + 32),
                         *(unsigned __int8 *)(((unsigned __int64)i << 7) + v13 + 26),
                         ((unsigned __int64)i << 7) + v13,
                         v9) )
    {
      break;
    }
    for ( j = 0; j < *(unsigned __int8 *)(((unsigned __int64)i << 7) + v13 + 26); ++j )
    {
      if ( *(_WORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(((unsigned __int64)i << 7) + v13 + 32)) + 24LL) & 8 )
      {
        v8 = *(_WORD *)(((unsigned __int64)i << 7) + v13 + 24);
        HIBYTE(v8) |= 0x20u;
        *(_WORD *)(((unsigned __int64)i << 7) + v13 + 24) = v8;
        break;
      }
    }
    if ( (unsigned int)sub_2ABDE(a1, v9, (__int64 *)(((unsigned __int64)i << 7) + v13 + 56), 8u, (__int64 *)a2) == -1 )
      break;
    if ( v15 )
      ++*v15;
    else
      ++*v14;
    if ( !(*(_DWORD *)(*a1 + 92) & 2)
      && (unsigned int)sub_2ABDE(
                         a1,
                         v9,
                         (__int64 *)(((unsigned __int64)i << 7) + v13 + 56),
                         0x800u,
                         (__int64 *)(((unsigned __int64)i << 7) + v13 + 120)) == -1 )
    {
      ++i;
      break;
    }
  }
  sub_93E46(*a1, v13, i, v12);
  return 1LL;
}

//----- (0000000000096903) ----------------------------------------------------
signed __int64 __fastcall sub_96903(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+13h] [rbp-Dh]
  unsigned int v4; // [rsp+14h] [rbp-Ch]
  unsigned int v5; // [rsp+18h] [rbp-8h]
  unsigned int v6; // [rsp+1Ch] [rbp-4h]

  v5 = *(unsigned __int16 *)(a1 + 72);
  *(_WORD *)(a1 + 72) = 0;
  v4 = 0;
  while ( 2 )
  {
    if ( v4 >= v5 )
      return 0LL;
    v6 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 31);
    *(_BYTE *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 31) = 0;
    for ( i = 0; v6 > i; ++i )
    {
      if ( (unsigned int)sub_8BFF3(
                           (__int64 *)a1,
                           (__int64 *)(*(_QWORD *)(a1 + 120) + 72LL * v4),
                           *(const char **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 56)),
                           a2) )
      {
        ++i;
        *(_WORD *)(a1 + 72) = v5;
        goto LABEL_15;
      }
    }
    ++*(_WORD *)(a1 + 72);
    if ( !(unsigned int)sub_959A9((__int64 *)a1, 0LL, *(_QWORD *)(a1 + 120) + 72LL * v4, 296, a2)
      && !(unsigned int)sub_9554F(
                          (__int64 *)a1,
                          (__int64 *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 32),
                          *(unsigned __int8 *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 26),
                          72LL * v4 + *(_QWORD *)(a1 + 120),
                          a2) )
    {
      ++v4;
      continue;
    }
    break;
  }
LABEL_15:
  while ( i < *(_BYTE *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 31) )
    free(*(void **)(8LL * i++ + *(_QWORD *)(*(_QWORD *)(a1 + 120) + 72LL * v4 + 56)));
  sub_94223(*(_QWORD *)(a1 + 120), v4 + 1, v5);
  return 1LL;
}

//----- (0000000000096B86) ----------------------------------------------------
signed __int64 __fastcall sub_96B86(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  v6 = a3;
  v5 = a4;
  for ( i = 0; i < v6; ++i )
  {
    if ( (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(56LL * i + a2 + 40),
                         *(unsigned __int8 *)(56LL * i + a2 + 48),
                         56LL * i + a2,
                         v5) )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000096C40) ----------------------------------------------------
signed __int64 __fastcall sub_96C40(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+14h] [rbp-1Ch]
  __int64 *v9; // [rsp+18h] [rbp-18h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( (unsigned int)sub_96496(a1, a2, a5, a2, a5, a6) || (unsigned int)sub_959A9(a1, 0LL, a2, 284, v7) )
    return 1LL;
  if ( !(unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, *v9, v8, v7) )
  {
    *v9 = 0LL;
    if ( *(_QWORD *)(a2 + 112)
      && (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(*(_QWORD *)(a2 + 112) + 24LL),
                         *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 32LL),
                         *(_QWORD *)(a2 + 112),
                         v7)
      || (unsigned int)sub_96B86(a1, *(_QWORD *)(a2 + 120), *(unsigned __int8 *)(a2 + 29), v7) )
    {
      return 1LL;
    }
    if ( !(*(_DWORD *)(*a1 + 92) & 2) && (*(_QWORD *)(a2 + 112) || *(_BYTE *)(a2 + 29)) )
    {
      if ( v8 & 4 )
      {
        if ( (unsigned int)sub_DDEA9(a2) )
          return 1LL;
      }
      else if ( (unsigned int)sub_2ABDE(a1, v7, (__int64 *)a2, 0x20000u, 0LL) == -1 )
      {
        return 1LL;
      }
    }
    return 0LL;
  }
  *v9 = 0LL;
  return 1LL;
}

//----- (0000000000096DDA) ----------------------------------------------------
signed __int64 __fastcall sub_96DDA(__int64 *a1, __int64 a2, char a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-20h]
  char v6; // [rsp+Ch] [rbp-14h]

  v6 = a3;
  v5 = a4;
  if ( (unsigned int)sub_95D5C(a1, a2 + 128, *(_QWORD *)(a2 + 144), a2, a4) )
  {
    sub_93CE2(*a1, a2 + 128);
  }
  else if ( (unsigned int)sub_959A9(a1, 0LL, a2, 302, v5) )
  {
    sub_93CE2(*a1, a2 + 128);
  }
  else
  {
    if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)(a2 + 128), 4u, (__int64 *)a2) != -1 )
    {
      if ( !(*(_DWORD *)(*a1 + 92) & 2)
        && (unsigned int)sub_2ABDE(a1, v5, (__int64 *)(a2 + 128), 0x1000u, (__int64 *)(a2 + 200)) == -1
        || *(_QWORD *)(a2 + 112)
        && (unsigned int)sub_9554F(
                           a1,
                           (__int64 *)(*(_QWORD *)(a2 + 112) + 24LL),
                           *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 32LL),
                           *(_QWORD *)(a2 + 112),
                           v5)
        || (unsigned int)sub_96B86(a1, *(_QWORD *)(a2 + 120), *(unsigned __int8 *)(a2 + 31), v5) )
      {
        return 1LL;
      }
      if ( !(*(_DWORD *)(*a1 + 92) & 2) && (*(_QWORD *)(a2 + 112) || *(_BYTE *)(a2 + 31)) )
      {
        if ( v6 & 4 )
        {
          if ( (unsigned int)sub_DDEA9(a2) )
            return 1LL;
        }
        else if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)a2, 0x20000u, 0LL) == -1 )
        {
          return 1LL;
        }
      }
      return 0LL;
    }
    sub_93CE2(*a1, a2 + 128);
  }
  return 1LL;
}

//----- (0000000000097015) ----------------------------------------------------
signed __int64 __fastcall sub_97015(__int64 *a1, __int64 a2, char a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  char v6; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+28h] [rbp-8h]
  int j; // [rsp+2Ch] [rbp-4h]

  v6 = a3;
  v5 = a4;
  if ( (unsigned int)sub_95D5C(a1, a2 + 128, *(_QWORD *)(a2 + 144), a2, a4) )
  {
    sub_93CE2(*a1, a2 + 128);
  }
  else if ( (unsigned int)sub_959A9(a1, 0LL, a2, 303, v5) )
  {
    sub_93CE2(*a1, a2 + 128);
  }
  else
  {
    if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)(a2 + 128), 4u, (__int64 *)a2) != -1 )
    {
      for ( i = 0; i < *(unsigned __int8 *)(a2 + 30); ++i )
      {
        if ( *(_WORD *)(a2 + 24) & 1 )
        {
          for ( j = i + 1; j < *(unsigned __int8 *)(a2 + 30); ++j )
          {
            if ( *(_QWORD *)(8LL * i + *(_QWORD *)(a2 + 200)) == *(_QWORD *)(8LL * j + *(_QWORD *)(a2 + 200)) )
            {
              sub_13937(
                (void *)*a1,
                10,
                2u,
                (char *)a2,
                *(_QWORD *)(8LL * i + *(_QWORD *)(a2 + 200)),
                (__int64)"default",
                v5);
              sub_13937(
                (void *)*a1,
                -1,
                2u,
                (char *)a2,
                (__int64)"Duplicated default value \"%s\".",
                *(_QWORD *)(8LL * i + *(_QWORD *)(a2 + 200)));
              return 1LL;
            }
          }
        }
        if ( !(*(_DWORD *)(*a1 + 92) & 2)
          && (unsigned int)sub_2ABDE(
                             a1,
                             v5,
                             (__int64 *)(a2 + 128),
                             0x1000u,
                             (__int64 *)(*(_QWORD *)(a2 + 200) + 8LL * i)) == -1 )
        {
          return 1LL;
        }
      }
      if ( *(_QWORD *)(a2 + 112)
        && (unsigned int)sub_9554F(
                           a1,
                           (__int64 *)(*(_QWORD *)(a2 + 112) + 24LL),
                           *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 32LL),
                           *(_QWORD *)(a2 + 112),
                           v5)
        || (unsigned int)sub_96B86(a1, *(_QWORD *)(a2 + 120), *(unsigned __int8 *)(a2 + 31), v5) )
      {
        return 1LL;
      }
      if ( !(*(_DWORD *)(*a1 + 92) & 2) && (*(_QWORD *)(a2 + 112) || *(_BYTE *)(a2 + 31)) )
      {
        if ( v6 & 4 )
        {
          if ( (unsigned int)sub_DDEA9(a2) )
            return 1LL;
        }
        else if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)a2, 0x20000u, 0LL) == -1 )
        {
          return 1LL;
        }
      }
      return 0LL;
    }
    sub_93CE2(*a1, a2 + 128);
  }
  return 1LL;
}

//----- (0000000000097396) ----------------------------------------------------
signed __int64 __fastcall sub_97396(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+14h] [rbp-2Ch]
  __int64 *v9; // [rsp+18h] [rbp-28h]
  __int64 i; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( (unsigned int)sub_96496(a1, a2, a5, a2, a5, a6) || (unsigned int)sub_959A9(a1, 0LL, a2, 305, v7) )
    return 1LL;
  if ( *(_WORD *)(a2 + 24) & 2 )
    *(_WORD *)(a2 + 24) &= 0x7Fu;
  for ( i = a2; i && !(*(_DWORD *)(i + 56) & 0x12800); i = *(_QWORD *)(i + 64) )
    ;
  if ( i || !(*(_WORD *)(a2 + 24) & 1) || *(_QWORD *)(a2 + 136) )
  {
    if ( !(unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, *v9, v8, v7) )
    {
      *v9 = 0LL;
      if ( *(_QWORD *)(a2 + 136) && (unsigned int)sub_8C9A3(a1, a2, v7)
        || (unsigned int)sub_8CED8(a1, a2, v7)
        || *(_QWORD *)(a2 + 112)
        && (unsigned int)sub_9554F(
                           a1,
                           (__int64 *)(*(_QWORD *)(a2 + 112) + 24LL),
                           *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 32LL),
                           *(_QWORD *)(a2 + 112),
                           v7)
        || (unsigned int)sub_96B86(a1, *(_QWORD *)(a2 + 120), *(unsigned __int8 *)(a2 + 28), v7) )
      {
        return 1LL;
      }
      if ( !(*(_DWORD *)(*a1 + 92) & 2) && (*(_QWORD *)(a2 + 112) || *(_BYTE *)(a2 + 28)) )
      {
        if ( v8 & 4 )
        {
          if ( (unsigned int)sub_DDEA9(a2) )
            return 1LL;
        }
        else if ( (unsigned int)sub_2ABDE(a1, v7, (__int64 *)a2, 0x20000u, 0LL) == -1 )
        {
          return 1LL;
        }
      }
      return 0LL;
    }
    *v9 = 0LL;
  }
  else
  {
    sub_13937((void *)*a1, 12, 2u, (char *)a2, (__int64)&unk_120A60, (__int64)"list");
  }
  return 1LL;
}

//----- (000000000009763D) ----------------------------------------------------
signed __int64 __fastcall sub_9763D(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5)
{
  __int64 v6; // [rsp+8h] [rbp-38h]
  unsigned int v7; // [rsp+14h] [rbp-2Ch]
  __int64 *v8; // [rsp+18h] [rbp-28h]
  void *ptr; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( (unsigned int)sub_959A9(a1, 0LL, a2, 281, a5) )
  {
    free(*(void **)(a2 + 112));
    *(_QWORD *)(a2 + 112) = 0LL;
  }
  else
  {
    if ( !(unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, *v8, v7, v6) )
    {
      *v8 = 0LL;
      if ( *(_QWORD *)(a2 + 112) )
      {
        ptr = *(void **)(a2 + 112);
        *(_QWORD *)(a2 + 112) = 0LL;
        if ( (unsigned int)sub_2AB62(a1, v6, (__int64 *)a2, 0x80u, (__int64)ptr) == -1 )
        {
          free(ptr);
          return 1LL;
        }
        free(ptr);
      }
      if ( *(_QWORD *)(a2 + 104)
        && (unsigned int)sub_9554F(
                           a1,
                           (__int64 *)(*(_QWORD *)(a2 + 104) + 24LL),
                           *(unsigned __int8 *)(*(_QWORD *)(a2 + 104) + 32LL),
                           *(_QWORD *)(a2 + 104),
                           v6) )
      {
        return 1LL;
      }
      if ( !(*(_DWORD *)(*a1 + 92) & 2) && *(_QWORD *)(a2 + 104) )
      {
        if ( v7 & 4 )
        {
          if ( (unsigned int)sub_DDEA9(a2) )
            return 1LL;
        }
        else if ( (unsigned int)sub_2ABDE(a1, v6, (__int64 *)a2, 0x20000u, 0LL) == -1 )
        {
          return 1LL;
        }
      }
      return 0LL;
    }
    *v8 = 0LL;
    free(*(void **)(a2 + 112));
    *(_QWORD *)(a2 + 112) = 0LL;
  }
  return 1LL;
}

//----- (0000000000097818) ----------------------------------------------------
signed __int64 __fastcall sub_97818(void **a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v8; // [rsp+8h] [rbp-38h]
  int v9; // [rsp+14h] [rbp-2Ch]
  __int64 *v10; // [rsp+18h] [rbp-28h]
  __int64 i; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( *(_DWORD *)(a2 + 56) == 0x4000 )
  {
    for ( i = *(_QWORD *)(a2 + 64); i; i = lys_parent(i) )
    {
      if ( *(_DWORD *)(i + 56) & 0x4180 || *(_DWORD *)(i + 56) == 16 && !*(_QWORD *)(i + 136) )
      {
        v6 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(*a1, 7, 2u, *(char **)(a2 + 64), (__int64)v6, (__int64)"action");
        return 1LL;
      }
    }
  }
  if ( !(unsigned int)sub_96496((__int64 *)a1, a2, v8, a2, a5, a6)
    && !(unsigned int)sub_959A9((__int64 *)a1, 0LL, a2, 327, v8) )
  {
    if ( !(unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, *v10, v9 | 2u, v8) )
    {
      *v10 = 0LL;
      return 0LL;
    }
    *v10 = 0LL;
  }
  return 1LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (000000000009797A) ----------------------------------------------------
signed __int64 __fastcall sub_9797A(__int64 *a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-28h]
  int v8; // [rsp+14h] [rbp-1Ch]
  __int64 *v9; // [rsp+18h] [rbp-18h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( (unsigned int)sub_96496(a1, a2, a5, a2, a5, a6) || (unsigned int)sub_959A9(a1, 0LL, a2, 312, v7) )
    return 1LL;
  if ( (unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, *v9, v8 | 2u, v7) )
  {
    *v9 = 0LL;
  }
  else
  {
    *v9 = 0LL;
    if ( !(unsigned int)sub_96B86(a1, *(_QWORD *)(a2 + 120), *(unsigned __int8 *)(a2 + 29), v7) )
    {
      if ( !(*(_DWORD *)(*a1 + 92) & 2) && *(_BYTE *)(a2 + 29) )
      {
        if ( v8 & 4 )
        {
          if ( (unsigned int)sub_DDEA9(a2) )
            return 1LL;
        }
        else if ( (unsigned int)sub_2ABDE(a1, v7, (__int64 *)a2, 0x20000u, 0LL) == -1 )
        {
          return 1LL;
        }
      }
      return 0LL;
    }
  }
  return 1LL;
}

//----- (0000000000097ABE) ----------------------------------------------------
signed __int64 __fastcall sub_97ABE(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned __int8 *v7; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v7 = *(unsigned __int8 **)(a2 + 72);
  *(_QWORD *)(a2 + 72) = 0LL;
  if ( !(unsigned int)sub_959A9(a1, 0LL, a2, 276, a4) )
  {
    if ( (unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, (__int64)v7, v6, v5)
      || (unsigned int)sub_9554F(a1, (__int64 *)(a2 + 32), *(unsigned __int8 *)(a2 + 26), a2, v5)
      || *(_QWORD *)(a2 + 80)
      && (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(*(_QWORD *)(a2 + 80) + 24LL),
                         *(unsigned __int8 *)(*(_QWORD *)(a2 + 80) + 32LL),
                         *(_QWORD *)(a2 + 80),
                         v5) )
    {
      return 1LL;
    }
    if ( !(*(_DWORD *)(*a1 + 92) & 2) && *(_QWORD *)(a2 + 80) )
    {
      if ( v6 & 4 )
      {
        if ( (unsigned int)sub_DDEA9(a2) )
          return 1LL;
      }
      else if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)a2, 0x20000u, 0LL) == -1 )
      {
        return 1LL;
      }
    }
    return 0LL;
  }
  sub_94BFB(*a1, v7);
  return 1LL;
}

//----- (0000000000097C42) ----------------------------------------------------
signed __int64 __fastcall sub_97C42(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int j; // [rsp+28h] [rbp-8h]
  unsigned int k; // [rsp+28h] [rbp-8h]
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  v6 = a3;
  v5 = a4;
  v10 = *(unsigned __int8 *)(a2 + 31);
  *(_BYTE *)(a2 + 31) = 0;
  if ( (unsigned int)sub_959A9(a1, 0LL, a2, 334, a4) )
    goto LABEL_22;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 30); ++i )
  {
    if ( (unsigned int)sub_959A9(a1, *(_QWORD *)(a2 + 112) + 80LL * i, a2, 323, v5)
      || (unsigned int)sub_96B86(
                         a1,
                         *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 56),
                         *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 30),
                         v5)
      || (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 32),
                         *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 26),
                         80LL * i + *(_QWORD *)(a2 + 112),
                         v5) )
    {
      goto LABEL_22;
    }
  }
  for ( j = 0; j < v10; ++j )
  {
    ++*(_BYTE *)(a2 + 31);
    if ( (unsigned int)sub_97ABE(a1, *(_QWORD *)(a2 + 120) + 104LL * j, v6, v5) )
      goto LABEL_22;
  }
  if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)a2, 1u, 0LL) == -1
    || *(_QWORD *)(a2 + 104)
    && (unsigned int)sub_9554F(
                       a1,
                       (__int64 *)(*(_QWORD *)(a2 + 104) + 24LL),
                       *(unsigned __int8 *)(*(_QWORD *)(a2 + 104) + 32LL),
                       *(_QWORD *)(a2 + 104),
                       v5) )
  {
    goto LABEL_22;
  }
  if ( *(_DWORD *)(*a1 + 92) & 2 || !*(_QWORD *)(a2 + 104) )
    return 0LL;
  if ( !(v6 & 4) )
  {
    if ( (unsigned int)sub_2ABDE(a1, v5, (__int64 *)a2, 0x20000u, 0LL) == -1 )
      goto LABEL_22;
    return 0LL;
  }
  if ( !(unsigned int)sub_DDEA9(a2) )
    return 0LL;
LABEL_22:
  for ( k = *(unsigned __int8 *)(a2 + 31); k < v10; ++k )
    sub_94ECB(*a1, *(_QWORD *)(a2 + 120) + 104LL * k);
  return 1LL;
}

//----- (0000000000097F83) ----------------------------------------------------
signed __int64 __fastcall sub_97F83(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5)
{
  __int64 v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+14h] [rbp-1Ch]
  __int64 *v8; // [rsp+18h] [rbp-18h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( (unsigned int)sub_959A9(a1, 0LL, a2, 353, a5) )
    return 1LL;
  if ( !(unsigned int)sub_980FB((__int64)a1, (__int64 *)a2, *v8, v7, v6) )
  {
    *v8 = 0LL;
    if ( *(_QWORD *)(a2 + 112)
      && (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(*(_QWORD *)(a2 + 112) + 24LL),
                         *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 32LL),
                         *(_QWORD *)(a2 + 112),
                         v6)
      || (unsigned int)sub_96B86(a1, *(_QWORD *)(a2 + 120), *(unsigned __int8 *)(a2 + 31), v6) )
    {
      return 1LL;
    }
    if ( !(*(_DWORD *)(*a1 + 92) & 2) && (*(_QWORD *)(a2 + 112) || *(_BYTE *)(a2 + 31)) )
    {
      if ( v7 & 4 )
      {
        if ( (unsigned int)sub_DDEA9(a2) )
          return 1LL;
      }
      else if ( (unsigned int)sub_2ABDE(a1, v6, (__int64 *)a2, 0x20000u, 0LL) == -1 )
      {
        return 1LL;
      }
    }
    return 0LL;
  }
  *v8 = 0LL;
  return 1LL;
}

//----- (00000000000980FB) ----------------------------------------------------
signed __int64 __fastcall sub_980FB(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  _QWORD *v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int16 v8; // ax
  __int16 v9; // ax
  unsigned int v10; // eax
  __int64 v12; // [rsp+8h] [rbp-58h]
  unsigned int v13; // [rsp+14h] [rbp-4Ch]
  signed int j; // [rsp+3Ch] [rbp-24h]
  unsigned __int8 *v15; // [rsp+40h] [rbp-20h]
  __int64 i; // [rsp+48h] [rbp-18h]
  unsigned __int8 *v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v13 = a4;
  v12 = a5;
  v18 = __readfsqword(0x28u);
  for ( i = a3; ; i = (__int64)v17 )
  {
    if ( !i )
      return 0LL;
    v17 = *(unsigned __int8 **)(i + 80);
    v15 = *(unsigned __int8 **)(i + 72);
    *(_QWORD *)(i + 80) = 0LL;
    *(_QWORD *)(i + 72) = 0LL;
    *(_QWORD *)(i + 64) = 0LL;
    *(_QWORD *)(i + 88) = i;
    if ( *(_BYTE *)(a1 + 64) & 1 )
      v5 = *(_QWORD **)(a1 + 168);
    else
      v5 = (_QWORD *)a1;
    if ( (unsigned int)sub_9C637((__int64)a2, v5, i, 0) || (unsigned int)sub_92A28(i, a2) )
    {
      sub_9BBAC(i);
      sub_94BFB(*(_QWORD *)a1, (unsigned __int8 *)i);
      goto LABEL_94;
    }
    if ( a2 != *(__int64 **)(i + 64) )
    {
      if ( a2 != *(__int64 **)(*(_QWORD *)(i + 64) + 64LL) )
        __assert_fail(
          "node->parent->parent == parent",
          "/home/mantovan/Repositories/libyang/src/parser_yang.c",
          0x109Du,
          "yang_check_nodes");
      if ( *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) != 64 || !(*(_WORD *)(*(_QWORD *)(i + 64) + 24LL) & 0x40) )
        __assert_fail(
          "(node->parent->nodetype == LYS_CASE) && (node->parent->flags & LYS_IMPLICIT)",
          "/home/mantovan/Repositories/libyang/src/parser_yang.c",
          0x109Eu,
          "yang_check_nodes");
      sub_92C65(*(_QWORD *)(i + 64), v13);
    }
    sub_92C65(i, v13);
    if ( (unsigned int)sub_9554F((__int64 *)a1, (__int64 *)(i + 32), *(unsigned __int8 *)(i + 26), i, v12) )
      goto LABEL_94;
    for ( j = 0; j < *(unsigned __int8 *)(i + 26); ++j )
    {
      if ( *(_WORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(i + 32)) + 24LL) & 8 )
      {
        v8 = *(_WORD *)(i + 24);
        HIBYTE(v8) |= 0x20u;
        *(_WORD *)(i + 24) = v8;
        if ( *(_WORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(i + 32)) + 24LL) & 0x10 )
        {
          v9 = *(_WORD *)(i + 24);
          HIBYTE(v9) |= 0x40u;
          *(_WORD *)(i + 24) = v9;
          break;
        }
      }
    }
    v10 = *(_DWORD *)(i + 56);
    if ( v10 == 128 )
    {
      if ( (unsigned int)sub_9797A((__int64 *)a1, i, &v15, v13, v12, v7) )
        goto LABEL_94;
      continue;
    }
    if ( v10 <= 0x80 )
    {
      if ( v10 == 8 )
      {
        if ( (unsigned int)sub_97015((__int64 *)a1, i, v13, v12) )
        {
          v15 = 0LL;
          goto LABEL_94;
        }
      }
      else if ( v10 > 8 )
      {
        switch ( v10 )
        {
          case 0x20u:
            goto LABEL_70;
          case 0x40u:
            if ( (unsigned int)sub_959A9((__int64 *)a1, 0LL, i, 280, v12) )
              goto LABEL_94;
            if ( (unsigned int)sub_980FB(a1, i, v15, v13, v12) )
            {
              v15 = 0LL;
              goto LABEL_94;
            }
            if ( *(_QWORD *)(i + 104) )
            {
              if ( (unsigned int)sub_9554F(
                                   (__int64 *)a1,
                                   (__int64 *)(*(_QWORD *)(i + 104) + 24LL),
                                   *(unsigned __int8 *)(*(_QWORD *)(i + 104) + 32LL),
                                   *(_QWORD *)(i + 104),
                                   v12) )
                goto LABEL_94;
              if ( *(_DWORD *)(*(_QWORD *)a1 + 92LL) & 2 || !(v13 & 4) )
              {
                if ( (unsigned int)sub_2ABDE((__int64 *)a1, v12, (__int64 *)i, 0x20000u, 0LL) == -1 )
                  goto LABEL_94;
              }
              else if ( (unsigned int)sub_DDEA9(i) )
              {
                goto LABEL_94;
              }
            }
            break;
          case 0x10u:
            if ( (unsigned int)sub_97396((__int64 *)a1, i, &v15, v13, v12, v7) )
              goto LABEL_94;
            break;
          default:
            goto LABEL_90;
        }
      }
      else
      {
        switch ( v10 )
        {
          case 2u:
            if ( (unsigned int)sub_9763D((__int64 *)a1, i, &v15, v13, v12) )
              goto LABEL_94;
            break;
          case 4u:
            if ( (unsigned int)sub_96DDA((__int64 *)a1, i, v13, v12) )
            {
              v15 = 0LL;
              goto LABEL_94;
            }
            break;
          case 1u:
            if ( (unsigned int)sub_96C40((__int64 *)a1, i, &v15, v13, v12, v7) )
              goto LABEL_94;
            break;
          default:
            goto LABEL_90;
        }
      }
      continue;
    }
    if ( v10 == 2048 )
    {
      if ( (unsigned int)sub_96496((__int64 *)a1, i, v12, i, v6, v7)
        || (unsigned int)sub_959A9((__int64 *)a1, 0LL, i, 295, v12) )
      {
        goto LABEL_94;
      }
      if ( (unsigned int)sub_980FB(a1, i, v15, v13 | 4, v12) )
      {
        v15 = 0LL;
        goto LABEL_94;
      }
      continue;
    }
    if ( v10 > 0x800 )
      break;
    if ( v10 != 512 && v10 != 1024 )
    {
      if ( v10 != 256 )
        goto LABEL_90;
LABEL_72:
      if ( (unsigned int)sub_97818((void **)a1, i, &v15, v13, v12, v7) )
        goto LABEL_94;
      continue;
    }
    if ( (unsigned int)sub_96496((__int64 *)a1, i, v12, i, v6, v7) )
      goto LABEL_94;
    if ( (unsigned int)sub_980FB(a1, i, v15, v13, v12) )
    {
      v15 = 0LL;
      goto LABEL_94;
    }
    if ( *(_BYTE *)(i + 29) )
    {
      if ( (unsigned int)sub_96B86((__int64 *)a1, *(_QWORD *)(i + 112), *(unsigned __int8 *)(i + 29), v12) )
        goto LABEL_94;
      if ( *(_DWORD *)(*(_QWORD *)a1 + 92LL) & 2 || !(v13 & 4) )
      {
        if ( (unsigned int)sub_2ABDE((__int64 *)a1, v12, (__int64 *)i, 0x20000u, 0LL) == -1 )
          goto LABEL_94;
      }
      else if ( (unsigned int)sub_DDEA9(i) )
      {
        goto LABEL_94;
      }
    }
LABEL_91:
    ;
  }
  switch ( v10 )
  {
    case 0x4000u:
      goto LABEL_72;
    case 0x8020u:
LABEL_70:
      if ( (unsigned int)sub_97F83((__int64 *)a1, i, &v15, v13, v12) )
        goto LABEL_94;
      goto LABEL_91;
    case 0x1000u:
      if ( (unsigned int)sub_97C42((__int64 *)a1, i, v13, v12) )
      {
        v15 = 0LL;
        goto LABEL_94;
      }
      goto LABEL_91;
  }
LABEL_90:
  sub_12222(
    *(_QWORD *)a1,
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
    4385LL);
LABEL_94:
  sub_94BFB(*(_QWORD *)a1, v17);
  sub_94BFB(*(_QWORD *)a1, v15);
  return 1LL;
}

//----- (00000000000988E7) ----------------------------------------------------
signed __int64 __fastcall sub_988E7(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD *v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // ST48_8
  __int64 v11; // [rsp+8h] [rbp-48h]
  __int64 v12; // [rsp+10h] [rbp-40h]
  __int64 v13; // [rsp+18h] [rbp-38h]
  int v14; // [rsp+30h] [rbp-20h]
  signed int v15; // [rsp+34h] [rbp-1Ch]
  __int64 *dest; // [rsp+38h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  if ( (unsigned int)sub_9554F(a1, (__int64 *)(v13 + 64), *(unsigned __int8 *)(a3 + 6), v13, a2)
    || *(_BYTE *)(v13 + 9) && (unsigned int)sub_91380(a1, a2, v13, v12, v6, v7)
    || *(_QWORD *)(v13 + 32) && (unsigned int)sub_91D1B(a1, v13, v12, v13, v6, v7) )
  {
    goto LABEL_35;
  }
  if ( *(_BYTE *)(v13 + 5) )
  {
    if ( (unsigned int)sub_908E4((__int64)a1, v13, v12, v11, v6, v7) )
      goto LABEL_35;
    if ( *(_DWORD *)(v12 + 56) == 8 && *(_DWORD *)v13 == 3 )
    {
      v15 = 0;
      v14 = 0;
      while ( v15 < *(unsigned __int8 *)(v12 + 30) )
      {
        v5 = (_QWORD *)(*(_QWORD *)(v12 + 200) + 8LL * v15);
        *(_QWORD *)(*(_QWORD *)(v12 + 200) + 8LL * v14) = *v5;
        if ( *(_QWORD *)(8LL * v14 + *(_QWORD *)(v12 + 200)) )
          ++v14;
        ++v15;
      }
      *(_BYTE *)(v12 + 30) = v14 + 1;
    }
  }
  if ( *(_BYTE *)(v13 + 8) && (unsigned int)sub_91116((_DWORD *)v13, v12, *(_DWORD *)(v13 + 16), 1, v6, v7)
    || *(_BYTE *)(v13 + 7) && (unsigned int)sub_91116((_DWORD *)v13, v12, *(_DWORD *)(v13 + 12), 0, v6, v7)
    || *(_QWORD *)(v13 + 48) && (unsigned int)sub_8FDB8((void *)*a1, v13, v12, v13, v6, v7) )
  {
    goto LABEL_35;
  }
  if ( *(_BYTE *)(v13 + 4) & 3 )
  {
    *(_WORD *)(v12 + 24) &= 0xFFFCu;
    *(_WORD *)(v12 + 24) |= *(_BYTE *)(v13 + 4) & 3;
  }
  if ( *(_BYTE *)(v13 + 4) & 0xC0 && (unsigned int)sub_90DFE(v13, v12, v12, (__int64)v5, v6, v7) )
    goto LABEL_35;
  if ( !*(_QWORD *)(v13 + 40) )
    return 0LL;
  if ( *(_DWORD *)(v12 + 56) == 4 )
  {
    dest = (__int64 *)(v12 + 128);
  }
  else
  {
    if ( *(_DWORD *)(v12 + 56) != 8 )
    {
      sub_13937((void *)*a1, 5, 0, 0LL, (__int64)"type", v7);
      sub_13937((void *)*a1, -1, 0, 0LL, (__int64)"Target node does not allow \"type\" property.", v8);
      goto LABEL_35;
    }
    dest = (__int64 *)(v12 + 128);
  }
  v9 = dest[3];
  sub_A1648(*a1, (__int64)dest, 0LL);
  memcpy(dest, *(const void **)(v13 + 40), 0x40uLL);
  free(*(void **)(v13 + 40));
  *(_QWORD *)(v13 + 40) = dest;
  *(_QWORD *)(*(_QWORD *)(v13 + 40) + 24LL) = v9;
  if ( !(unsigned int)sub_95D5C(a1, (__int64)dest, dest[2], v9, a2)
    && (unsigned int)sub_2ABDE(a1, a2, *(__int64 **)(v13 + 40), 4u, (__int64 *)v12) != -1 )
  {
    return 0LL;
  }
LABEL_35:
  if ( *(_QWORD *)(v13 + 40) )
  {
    sub_93CE2(*a1, *(_QWORD *)(v13 + 40));
    *(_QWORD *)(v13 + 40) = 0LL;
  }
  return 1LL;
}

//----- (0000000000098D32) ----------------------------------------------------
signed __int64 __fastcall sub_98D32(void **a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // r9
  const char *v8; // rax
  __int64 v9; // rax
  signed int v10; // eax
  __int64 v12; // [rsp+8h] [rbp-B8h]
  int v13; // [rsp+24h] [rbp-9Ch]
  unsigned int j; // [rsp+28h] [rbp-98h]
  unsigned int i; // [rsp+28h] [rbp-98h]
  unsigned int l; // [rsp+28h] [rbp-98h]
  unsigned int k; // [rsp+2Ch] [rbp-94h]
  __int64 v18; // [rsp+30h] [rbp-90h]
  __int64 m; // [rsp+38h] [rbp-88h]
  __int64 v20; // [rsp+40h] [rbp-80h]
  __int64 v21; // [rsp+48h] [rbp-78h]
  __int64 v22; // [rsp+50h] [rbp-70h]
  __int64 v23; // [rsp+58h] [rbp-68h]
  _DWORD *v24; // [rsp+60h] [rbp-60h]
  __int64 v25; // [rsp+68h] [rbp-58h]
  __int64 v26; // [rsp+70h] [rbp-50h]
  __int64 *v27; // [rsp+78h] [rbp-48h]
  char s; // [rsp+80h] [rbp-40h]
  int v29; // [rsp+A0h] [rbp-20h]
  unsigned __int64 v30; // [rsp+A8h] [rbp-18h]

  v12 = a3;
  v30 = __readfsqword(0x28u);
  v23 = 0LL;
  v20 = ly_set_new(a1);
  if ( (unsigned int)sub_1A193(*(char **)v12, 0LL, (__int64)a1, &v18, 0, 1) == -1 )
  {
    sub_13937(*a1, 10, 0, 0LL, *(_QWORD *)v12, (__int64)"deviation");
    ly_set_free(v18);
    j = 0;
    goto LABEL_66;
  }
  v23 = **(_QWORD **)(v18 + 8);
  ly_set_free(v18);
  v3 = *(_QWORD *)(v23 + 48);
  if ( v3 == lys_main_module(a1) )
  {
    sub_13937(*a1, 10, 0, 0LL, *(_QWORD *)v12, (__int64)"deviation");
    sub_13937(*a1, -1, 0, 0LL, (__int64)"Deviating own module is not allowed.", v5);
    j = 0;
    goto LABEL_66;
  }
  if ( !v20 )
  {
    sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_check_deviation", v4);
    j = 0;
    goto LABEL_66;
  }
  if ( **(_DWORD **)(v12 + 40) )
  {
    memset(&s, 0, 0x28uLL);
    *(_QWORD *)(v12 + 24) = sub_A60D4(*(__int64 **)(v23 + 48), 0LL, v23, (__int64)&s, 1u);
    if ( v29 )
    {
      sub_12222(
        (__int64)*a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
        4583LL);
      j = 0;
      goto LABEL_66;
    }
  }
  else
  {
    if ( *(_DWORD *)(v23 + 56) == 4 && *(_QWORD *)(v23 + 64) && *(_DWORD *)(*(_QWORD *)(v23 + 64) + 56LL) == 16 )
    {
      for ( i = 0; i < *(unsigned __int8 *)(*(_QWORD *)(v23 + 64) + 30LL); ++i )
      {
        if ( v23 == *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(v23 + 64) + 136LL)) )
        {
          sub_13937(*a1, 10, 0, 0LL, (__int64)"not-supported", (__int64)"deviation");
          sub_13937(*a1, -1, 0, 0LL, (__int64)"\"not-supported\" deviation cannot remove a list key.", v6);
          j = 0;
          goto LABEL_66;
        }
      }
    }
    m = *(_QWORD *)(v23 + 64);
    sub_9BBAC(v23);
    if ( m )
    {
      if ( *(_DWORD *)(m + 56) & 0x3000 )
      {
        *(_QWORD *)(v23 + 64) = m;
      }
      else if ( *(_DWORD *)(m + 56) & 0x4100 )
      {
        v24 = calloc(1uLL, 0x78uLL);
        if ( !v24 )
        {
          sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_check_deviation", v7);
LABEL_67:
          ly_set_free(v20);
          return 1LL;
        }
        v24[14] = *(_DWORD *)(v23 + 56);
        if ( v24[14] == 512 )
          v8 = "input";
        else
          v8 = "output";
        v9 = lydict_insert(*a1, v8, 0LL);
        *(_QWORD *)v24 = v9;
        *((_QWORD *)v24 + 6) = *(_QWORD *)(v23 + 48);
        *((_WORD *)v24 + 12) = 64;
        if ( !*(_QWORD *)(m + 72)
          || *(_QWORD *)(*(_QWORD *)(m + 72) + 80LL)
          || (v24[14] != 512 ? (v10 = 512) : (v10 = 1024), v10 != *(_DWORD *)(*(_QWORD *)(m + 72) + 56LL)) )
        {
          __assert_fail(
            "parent->child && !parent->child->next && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUT"
            "PUT : LYS_INPUT))",
            "/home/mantovan/Repositories/libyang/src/parser_yang.c",
            0x11D9u,
            "yang_check_deviation");
        }
        *(_QWORD *)(*(_QWORD *)(m + 72) + 80LL) = v24;
        *((_QWORD *)v24 + 11) = *(_QWORD *)(m + 72);
        *(_QWORD *)(*(_QWORD *)(m + 72) + 88LL) = v24;
        *((_QWORD *)v24 + 8) = m;
      }
    }
    *(_QWORD *)(v12 + 24) = v23;
  }
  if ( (unsigned int)sub_9554F((__int64 *)a1, (__int64 *)(v12 + 48), *(unsigned __int8 *)(v12 + 33), v12, a2) )
  {
LABEL_66:
    for ( j = 0; j < *(unsigned __int8 *)(v12 + 32); ++j )
    {
      if ( *(_QWORD *)(*(_QWORD *)(v12 + 40) + 72LL * j + 40) )
      {
        sub_93CE2((__int64)*a1, *(_QWORD *)(*(_QWORD *)(v12 + 40) + 72LL * j + 40));
        free(*(void **)(*(_QWORD *)(v12 + 40) + 72LL * j + 40));
        *(_QWORD *)(*(_QWORD *)(v12 + 40) + 72LL * j + 40) = 0LL;
      }
    }
    goto LABEL_67;
  }
  for ( j = 0; j < *(unsigned __int8 *)(v12 + 32); ++j )
  {
    if ( (unsigned int)sub_988E7((__int64 *)a1, a2, *(_QWORD *)(v12 + 40) + 72LL * j, v23, v20) )
    {
      sub_94FA3((__int64)*a1, v12, j + 1);
      *(_BYTE *)(v12 + 32) = j + 1;
      goto LABEL_66;
    }
  }
  for ( k = 0; k < *(_DWORD *)(v20 + 4); ++k )
  {
    v21 = 0LL;
    v13 = 0;
    if ( *(_DWORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v20 + 8)) + 56LL) == 4 )
    {
      v27 = *(__int64 **)(8LL * k + *(_QWORD *)(v20 + 8));
      v22 = *v27;
      v21 = v27[25];
      v13 = sub_2ABDE((__int64 *)a1, a2, v27 + 16, 0x1000u, v27 + 25);
    }
    else
    {
      v26 = *(_QWORD *)(8LL * k + *(_QWORD *)(v20 + 8));
      v22 = *(_QWORD *)v26;
      for ( l = 0; l < *(unsigned __int8 *)(v26 + 30); ++l )
      {
        v13 = sub_2ABDE(
                (__int64 *)a1,
                a2,
                (__int64 *)(v26 + 128),
                0x1000u,
                (__int64 *)(*(_QWORD *)(v26 + 200) + 8LL * l));
        if ( v13 == -1 )
        {
          v21 = *(_QWORD *)(8LL * l + *(_QWORD *)(v26 + 200));
          break;
        }
      }
    }
    if ( v13 == -1 )
    {
      sub_13937(*a1, 10, 0, 0LL, v21, (__int64)"default");
      sub_13937(
        *a1,
        -1,
        0,
        0LL,
        (__int64)"The default value \"%s\" of the deviated node \"%s\"no longer matches its type.",
        v22);
      goto LABEL_67;
    }
  }
  ly_set_free(v20);
  v20 = 0LL;
  for ( m = v23; m; m = lys_parent(m) )
  {
    v25 = lys_node_module(m);
    if ( a1 != (void **)v25 )
    {
      *(_BYTE *)(v25 + 64) = *(_BYTE *)(v25 + 64) & 0xCF | 0x10;
      *(_BYTE *)(*(_QWORD *)(m + 48) + 64LL) = *(_BYTE *)(*(_QWORD *)(m + 48) + 64LL) & 0xCF | 0x10;
      if ( *(_BYTE *)(v25 + 64) >= 0 )
      {
        *(_BYTE *)(v25 + 64) |= 0x80u;
        if ( (unsigned int)sub_2ABDE((__int64 *)v25, a2, 0LL, 0x8000u, 0LL) == -1 )
          goto LABEL_67;
      }
    }
  }
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000009979D) ----------------------------------------------------
signed __int64 __fastcall sub_9979D(_QWORD *a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  unsigned __int8 *v7; // [rsp+8h] [rbp-38h]
  unsigned int i; // [rsp+2Ch] [rbp-14h]
  unsigned int j; // [rsp+2Ch] [rbp-14h]
  unsigned int k; // [rsp+2Ch] [rbp-14h]
  unsigned int n; // [rsp+2Ch] [rbp-14h]
  unsigned int ii; // [rsp+2Ch] [rbp-14h]
  unsigned int l; // [rsp+2Ch] [rbp-14h]
  unsigned int m; // [rsp+2Ch] [rbp-14h]
  signed int v15; // [rsp+30h] [rbp-10h]
  signed int v16; // [rsp+34h] [rbp-Ch]
  unsigned int v17; // [rsp+38h] [rbp-8h]
  unsigned int v18; // [rsp+3Ch] [rbp-4h]

  v7 = a3;
  v15 = 1;
  v16 = 1;
  v18 = *((unsigned __int8 *)a1 + 77);
  *((_BYTE *)a1 + 77) = 0;
  v17 = *((unsigned __int8 *)a1 + 78);
  *((_BYTE *)a1 + 78) = 0;
  if ( (unsigned int)sub_96496(a1, 0LL, a2, a4, a5, a6)
    || (unsigned int)sub_9554F(a1, a1 + 20, *((unsigned __int8 *)a1 + 80), (__int64)a1, a2) )
  {
    goto LABEL_30;
  }
  for ( i = 0; i < *((unsigned __int8 *)a1 + 68); ++i )
  {
    if ( (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(a1[11] + 40LL * i + 16),
                         *(unsigned __int8 *)(a1[11] + 40LL * i + 11),
                         40LL * i + a1[11],
                         a2) )
      goto LABEL_30;
  }
  for ( j = 0; j < *((unsigned __int8 *)a1 + 79); ++j )
  {
    if ( (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(((unsigned __int64)j << 6) + a1[19] + 32),
                         *(unsigned __int8 *)(((unsigned __int64)j << 6) + a1[19] + 26),
                         a1[19] + ((unsigned __int64)j << 6),
                         a2) )
      goto LABEL_30;
  }
  for ( k = 0; k < *((unsigned __int8 *)a1 + 76); ++k )
  {
    if ( (unsigned int)sub_959A9(a1, 0LL, a1[16] + ((unsigned __int64)k << 6), 293, a2)
      || (unsigned int)sub_9554F(
                         a1,
                         (__int64 *)(((unsigned __int64)k << 6) + a1[16] + 32),
                         *(unsigned __int8 *)(((unsigned __int64)k << 6) + a1[16] + 26),
                         a1[16] + ((unsigned __int64)k << 6),
                         a2)
      || *(_BYTE *)(((unsigned __int64)k << 6) + a1[16] + 27)
      && (unsigned int)sub_2ABDE(a1, a2, (__int64 *)(a1[16] + ((unsigned __int64)k << 6)), 0x400u, 0LL) == -1 )
    {
      goto LABEL_30;
    }
  }
  v15 = 0;
  if ( (unsigned int)sub_96903((__int64)a1, a2)
    || (v16 = 0, (unsigned int)sub_980FB((__int64)a1, 0LL, (__int64)v7, 0, a2)) )
  {
LABEL_30:
    if ( v15 )
      sub_94223(a1[15], 0, *((unsigned __int16 *)a1 + 36));
    if ( v16 )
      sub_94BFB(*a1, v7);
    for ( l = *((unsigned __int8 *)a1 + 77); l < v18; ++l )
      sub_94ECB(*a1, a1[17] + 104LL * l);
    for ( m = *((unsigned __int8 *)a1 + 78); m < v17; ++m )
    {
      sub_94FA3(*a1, 56LL * m + a1[18], 0);
      free(*(void **)(a1[18] + 56LL * m + 40));
      lydict_remove(*a1, *(_QWORD *)(a1[18] + 56LL * m));
      lydict_remove(*a1, *(_QWORD *)(a1[18] + 56LL * m + 8));
      lydict_remove(*a1, *(_QWORD *)(a1[18] + 56LL * m + 16));
    }
    result = 1LL;
  }
  else
  {
    for ( n = 0; n < v17; ++n )
    {
      ++*((_BYTE *)a1 + 78);
      if ( (unsigned int)sub_98D32((void **)a1, a2, a1[18] + 56LL * n) )
        goto LABEL_30;
    }
    for ( ii = 0; ii < v18; ++ii )
    {
      ++*((_BYTE *)a1 + 77);
      if ( (unsigned int)sub_97ABE(a1, a1[17] + 104LL * ii, 0, a2)
        || (unsigned int)sub_2ABDE(a1, a2, (__int64 *)(a1[17] + 104LL * ii), 0x40u, 0LL) == -1 )
      {
        goto LABEL_30;
      }
    }
    result = 0LL;
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (0000000000099DD9) ----------------------------------------------------
signed __int64 __fastcall sub_99DD9(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, void **a5, int a6, unsigned int a7)
{
  void **v7; // rbx
  __int64 v8; // r9
  void **v9; // rbx
  __int64 v10; // r9
  void **v11; // rbx
  __int64 v12; // r9
  void **v13; // rbx
  __int64 v14; // r9
  __int64 v16; // r9
  __int64 v17; // r9
  void **v18; // [rsp+8h] [rbp-68h]
  __int64 v19; // [rsp+10h] [rbp-60h]
  __int64 v20; // [rsp+18h] [rbp-58h]
  int i; // [rsp+34h] [rbp-3Ch]
  __int64 v22; // [rsp+38h] [rbp-38h]
  void **v23; // [rsp+40h] [rbp-30h]
  void **v24; // [rsp+48h] [rbp-28h]
  void *v25; // [rsp+50h] [rbp-20h]
  unsigned __int64 v26; // [rsp+58h] [rbp-18h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v26 = __readfsqword(0x28u);
  v24 = 0LL;
  i = 0;
  if ( a7 == 13 && a6 == 3 )
  {
    v23 = (void **)lys_ext_complex_get_substmt(3LL, a2, &v22);
    if ( *(_DWORD *)(v22 + 16) > 1u )
    {
      v24 = v23;
      for ( i = 0; *((_QWORD *)*v24 + i + 1); ++i )
        ;
      v23 = (void **)v24[1];
    }
    else
    {
      ++v23;
    }
    v7 = &v23[i];
    *v7 = (void *)lydict_insert_zc(*a1, *v18);
    *v18 = 0LL;
    return 0LL;
  }
  v23 = (void **)lys_ext_complex_get_substmt(a7, a2, &v22);
  if ( v23 )
  {
    if ( *(_DWORD *)(v22 + 16) > 1u || !*v23 )
    {
      if ( *(_DWORD *)(v22 + 16) > 1u )
      {
        v24 = v23;
        if ( *v23 )
        {
          for ( i = 0; *((_QWORD *)*v24 + i); ++i )
            ;
        }
        else
        {
          *v24 = calloc(2uLL, 8uLL);
          if ( !*v24 )
          {
            sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_extcomplex_str", v8);
            goto LABEL_42;
          }
          if ( a7 == 3 )
          {
            v9 = v24 + 1;
            *v9 = calloc(2uLL, 8uLL);
            if ( !v24[1] )
            {
              sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_extcomplex_str", v10);
              goto LABEL_42;
            }
          }
          else if ( a7 == 1 )
          {
            v11 = v24 + 1;
            *v11 = calloc(2uLL, 1uLL);
            if ( !v24[1] )
            {
              sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_extcomplex_str", v12);
              goto LABEL_42;
            }
            *(_BYTE *)v24[1] = 2;
          }
        }
        v23 = (void **)*v24;
      }
      v13 = &v23[i];
      *v13 = (void *)lydict_insert_zc(*a1, *v18);
      *v18 = 0LL;
      if ( i )
      {
        v25 = realloc(*v24, 8LL * (i + 2));
        if ( !v25 )
        {
          sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_extcomplex_str", v14);
          lydict_remove(*a1, *((_QWORD *)*v24 + i));
          *((_QWORD *)*v24 + i) = 0LL;
          return 1LL;
        }
        *v24 = v25;
        *((_QWORD *)*v24 + i + 1) = 0LL;
        if ( a7 == 3 )
        {
          v25 = realloc(v24[1], 8LL * (i + 2));
          if ( !v25 )
          {
            sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_extcomplex_str", v16);
            lydict_remove(*a1, *((_QWORD *)v24[1] + i));
            *((_QWORD *)v24[1] + i) = 0LL;
            return 1LL;
          }
          v24[1] = v25;
          *((_QWORD *)v24[1] + i + 1) = 0LL;
        }
        else if ( a7 == 1 )
        {
          v25 = realloc(v24[1], i + 2);
          if ( !v25 )
          {
            sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_read_extcomplex_str", v17);
            *((_BYTE *)v24[1] + i) = 0;
            return 1LL;
          }
          v24[1] = v25;
          *((_BYTE *)v24[1] + i + 1) = 0;
        }
      }
      return 0LL;
    }
    sub_13937((void *)*a1, 14, 0, 0LL, v20, v19);
  }
  else
  {
    sub_13937((void *)*a1, 6, 0, 0LL, v20, v19);
  }
LABEL_42:
  free(*v18);
  *v18 = 0LL;
  return 1LL;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000009A401) ----------------------------------------------------
__int64 __fastcall sub_9A401(__int64 a1, unsigned int a2, int a3)
{
  unsigned int v4; // [rsp+4h] [rbp-3Ch]
  int i; // [rsp+18h] [rbp-28h]
  signed int v6; // [rsp+1Ch] [rbp-24h]
  __int64 v7; // [rsp+20h] [rbp-20h]
  _QWORD *v8; // [rsp+28h] [rbp-18h]
  _QWORD *v9; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v4 = a2;
  v10 = __readfsqword(0x28u);
  v6 = 0;
  v8 = 0LL;
  if ( a3 != 278 && a2 != 3 )
  {
    if ( a3 == 275 || a2 == 1 )
    {
      v4 = 1;
      v6 = -1;
    }
  }
  else
  {
    v4 = 3;
    v6 = -1;
  }
  v9 = (_QWORD *)lys_ext_complex_get_substmt(v4, a1, &v7);
  if ( !v9 || *(_DWORD *)(v7 + 16) <= 1u || !*v9 )
    return 0LL;
  v8 = v9;
  for ( i = 0; *(_QWORD *)(8LL * i + *v8); ++i )
    ;
  return (unsigned int)(i + v6);
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000009A502) ----------------------------------------------------
__int64 __fastcall sub_9A502(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // [rsp+10h] [rbp-60h]
  __int64 v9; // [rsp+18h] [rbp-58h]
  int v10; // [rsp+3Ch] [rbp-34h]
  __int64 v11; // [rsp+40h] [rbp-30h]
  __int128 v12; // [rsp+48h] [rbp-28h]
  void *v13; // [rsp+58h] [rbp-18h]
  void *v14; // [rsp+60h] [rbp-10h]
  unsigned __int64 v15; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v15 = __readfsqword(0x28u);
  v13 = **(void ***)(a1 + 48);
  v12 = (unsigned __int64)lys_ext_complex_get_substmt(a5, a1, &v11);
  if ( !(_QWORD)v12 )
  {
    sub_13937(v13, 6, 0, 0LL, v8, v9);
    return 0LL;
  }
  if ( *(_DWORD *)(v11 + 16) <= 1u && *(_QWORD *)v12 )
  {
    sub_13937(v13, 14, 0, 0LL, v8, v9);
    return 0LL;
  }
  v10 = 0;
  if ( *(_DWORD *)(v11 + 16) > 1u )
  {
    *((_QWORD *)&v12 + 1) = v12;
    *(_QWORD *)&v12 = *(_QWORD *)v12;
    if ( (_QWORD)v12 )
    {
      v10 = 0;
      while ( *(_QWORD *)v12 )
      {
        *(_QWORD *)&v12 = v12 + 8;
        ++v10;
      }
    }
    else
    {
      *(_QWORD *)&v12 = calloc(2uLL, 8uLL);
      **((_QWORD **)&v12 + 1) = v12;
      if ( !(_QWORD)v12 )
      {
        sub_12222(
          (__int64)v13,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"yang_getplace_for_extcomplex_struct",
          v6);
        return 0LL;
      }
    }
  }
  if ( v10 )
  {
    v14 = realloc(**((void ***)&v12 + 1), 8LL * (v10 + 2));
    if ( !v14 )
    {
      sub_12222(
        (__int64)v13,
        0,
        1,
        "Memory allocation failed (%s()).",
        (__int64)"yang_getplace_for_extcomplex_struct",
        v7);
      return 0LL;
    }
    **((_QWORD **)&v12 + 1) = v14;
    *(_QWORD *)&v12 = **((_QWORD **)&v12 + 1);
    *(_QWORD *)(8 * (v10 + 1LL) + v12) = 0LL;
  }
  if ( !a2 )
    return 8LL * v10 + v12;
  *a2 = v10;
  return v12;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000009A76F) ----------------------------------------------------
signed __int64 __fastcall sub_9A76F(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int16 a5, unsigned __int16 a6)
{
  signed __int64 result; // rax
  unsigned __int16 v7; // [rsp+Ch] [rbp-44h]
  __int16 v8; // [rsp+10h] [rbp-40h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  _WORD *v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a5;
  v7 = a6;
  v12 = __readfsqword(0x28u);
  v11 = (_WORD *)lys_ext_complex_get_substmt(a4, a1, &v10);
  if ( v11 )
  {
    if ( *(_DWORD *)(v10 + 16) <= 1u && v7 & *v11 )
    {
      sub_13937(**(void ***)(a1 + 48), 14, 0, 0LL, v9, a2);
      result = 1LL;
    }
    else
    {
      *v11 |= v8;
      result = 0LL;
    }
  }
  else
  {
    sub_13937(**(void ***)(a1 + 48), 6, 0, 0LL, v9, a2);
    result = 1LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000009A888) ----------------------------------------------------
signed __int64 __fastcall sub_9A888(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, char a5)
{
  __int64 v6; // r9
  __int64 v7; // r9
  char v8; // dl
  __int64 v9; // [rsp+0h] [rbp-60h]
  __int64 v10; // [rsp+8h] [rbp-58h]
  int i; // [rsp+2Ch] [rbp-34h]
  __int64 v12; // [rsp+30h] [rbp-30h]
  __int128 v13; // [rsp+38h] [rbp-28h]
  void *v14; // [rsp+48h] [rbp-18h]
  void *v15; // [rsp+50h] [rbp-10h]
  unsigned __int64 v16; // [rsp+58h] [rbp-8h]

  v10 = a3;
  HIDWORD(v9) = a4;
  LOBYTE(v9) = a5;
  v16 = __readfsqword(0x28u);
  v14 = **(void ***)(a1 + 48);
  i = 0;
  v13 = (unsigned __int64)lys_ext_complex_get_substmt(a4, a1, &v12);
  if ( !(_QWORD)v13 )
  {
    sub_13937(v14, 6, 0, 0LL, v10, a2, v9);
    return 1LL;
  }
  if ( HIDWORD(v9) == 27 )
  {
    if ( *(_DWORD *)(v12 + 16) <= 1u && *(_BYTE *)v13 )
    {
      sub_13937(v14, 14, 0, 0LL, v10, a2, v9);
      return 1LL;
    }
    if ( *(_DWORD *)(v12 + 16) > 1u )
    {
      *((_QWORD *)&v13 + 1) = v13;
      if ( *(_QWORD *)v13 )
      {
        for ( i = 0; *(_BYTE *)(**((_QWORD **)&v13 + 1) + i); ++i )
          ;
      }
      else
      {
        **((_QWORD **)&v13 + 1) = calloc(2uLL, 1uLL);
        if ( !**((_QWORD **)&v13 + 1) )
        {
          sub_12222(
            (__int64)v14,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"yang_fill_extcomplex_uint8",
            v6,
            v9);
          return 1LL;
        }
      }
      *(_QWORD *)&v13 = **((_QWORD **)&v13 + 1) + i;
    }
    *(_BYTE *)v13 = v9;
    if ( i )
    {
      v15 = realloc(**((void ***)&v13 + 1), i + 2);
      if ( !v15 )
      {
        sub_12222((__int64)v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_fill_extcomplex_uint8", v7, v9);
        return 1LL;
      }
      **((_QWORD **)&v13 + 1) = v15;
      *(_BYTE *)(i + 1LL + **((_QWORD **)&v13 + 1)) = 0;
    }
  }
  else
  {
    if ( *(_BYTE *)v13 )
    {
      sub_13937(v14, 14, 0, 0LL, v10, a2, v9);
      return 1LL;
    }
    if ( HIDWORD(v9) == 21 )
    {
      if ( (_BYTE)v9 == 1 )
        v8 = 1;
      else
        v8 = 2;
      *(_BYTE *)v13 = v8;
    }
    else
    {
      if ( HIDWORD(v9) != 20 )
      {
        sub_12222(
          (__int64)v14,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser_yang.c",
          5020LL,
          v9);
        return 1LL;
      }
      *(_BYTE *)v13 = 1;
    }
  }
  return 0LL;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000009AB89) ----------------------------------------------------
signed __int64 __fastcall sub_9AB89(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  signed __int64 result; // rax
  unsigned int v6; // [rsp+Ch] [rbp-44h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v12 = __readfsqword(0x28u);
  v11 = lys_ext_complex_get_substmt(a5, a1, &v9);
  if ( v11 )
  {
    if ( *(_DWORD *)(v9 + 16) <= 1u )
    {
      for ( i = v7; i; i = *(_QWORD *)(i + 80) )
      {
        if ( v6 == (unsigned int)sub_C1906(*(_DWORD *)(i + 56)) )
        {
          sub_13937(**(void ***)(a1 + 48), 14, 0, 0LL, v8, a2);
          return 1LL;
        }
      }
    }
    result = 0LL;
  }
  else
  {
    sub_13937(**(void ***)(a1 + 48), 6, 0, 0LL, v8, a2);
    result = 1LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000009ACA3) ----------------------------------------------------
signed __int64 __fastcall sub_9ACA3(void *a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  signed __int64 result; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  void **v8; // rbx
  int v9; // [rsp+Ch] [rbp-74h]
  __int64 v10; // [rsp+10h] [rbp-70h]
  __int64 v11; // [rsp+18h] [rbp-68h]
  int v12; // [rsp+38h] [rbp-48h]
  int i; // [rsp+3Ch] [rbp-44h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  void **v15; // [rsp+48h] [rbp-38h]
  void **v16; // [rsp+50h] [rbp-30h]
  void **v17; // [rsp+58h] [rbp-28h]
  void *v18; // [rsp+60h] [rbp-20h]
  unsigned __int64 v19; // [rsp+68h] [rbp-18h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v19 = __readfsqword(0x28u);
  if ( !a4 )
    return 0LL;
  v15 = (void **)lys_ext_complex_get_substmt(32LL, a2, &v14);
  v17 = v15;
  if ( v15 )
  {
    for ( i = 0; *(_QWORD *)(8LL * i + v10); ++i )
    {
      v12 = 0;
      if ( *(_DWORD *)(v14 + 16) <= 1u && *v15 )
      {
        sub_13937(a1, 14, 0, 0LL, (__int64)"module", v11);
        return 1LL;
      }
      if ( *(_DWORD *)(v14 + 16) > 1u )
      {
        v16 = v17;
        v15 = (void **)*v17;
        if ( v15 )
        {
          v12 = 0;
          while ( *v15 )
          {
            ++v15;
            ++v12;
          }
        }
        else
        {
          v15 = (void **)calloc(2uLL, 8uLL);
          *v16 = v15;
          if ( !*v16 )
          {
            sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_fill_extcomplex_module", v6);
            return 1LL;
          }
        }
      }
      if ( v12 )
      {
        v18 = realloc(*v16, 8LL * (v12 + 2));
        if ( !v18 )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_fill_extcomplex_module", v7);
          return 1LL;
        }
        *v16 = v18;
        v15 = (void **)*v16;
        v15[v12 + 1] = 0LL;
      }
      v8 = &v15[v12];
      *v8 = sub_9316E((__int64)a1, *(const char **)(8LL * i + v10), 0, 0LL, v9);
      if ( !v15[v12] )
        return 1LL;
    }
    result = 0LL;
  }
  else
  {
    sub_13937(a1, 6, 0, 0LL, (__int64)"module", v11);
    result = 1LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (000000000009AF99) ----------------------------------------------------
__int64 __fastcall lys_is_key(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int8 *v7; // [rsp+0h] [rbp-30h]
  unsigned __int8 i; // [rsp+1Fh] [rbp-11h]
  __int64 v9; // [rsp+20h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_is_key", a4, a5, a6, a2);
  v9 = a1;
  if ( !a1 || *(_DWORD *)(a1 + 56) != 4 )
    return 0LL;
  do
    v9 = lys_parent(v9);
  while ( v9 && *(_DWORD *)(v9 + 56) == 4096 );
  if ( !v9 || *(_DWORD *)(v9 + 56) != 16 )
    return 0LL;
  for ( i = 0; ; ++i )
  {
    if ( i >= *(_BYTE *)(v9 + 30) )
      return 0LL;
    if ( a1 == *(_QWORD *)(8LL * i + *(_QWORD *)(v9 + 136)) )
      break;
  }
  if ( v7 )
    *v7 = i;
  return v9;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009B08C) ----------------------------------------------------
__int64 __fastcall lys_is_disabled(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-18h]
  signed int i; // [rsp+1Ch] [rbp-4h]

  v7 = a1;
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_is_disabled", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  do
  {
    if ( *(_DWORD *)(v7 + 56) != 512 && *(_DWORD *)(v7 + 56) != 1024 )
    {
      for ( i = 0; i < *(unsigned __int8 *)(v7 + 27); ++i )
      {
        if ( !(unsigned int)sub_18D14(32LL * i + *(_QWORD *)(v7 + 40)) )
          return v7;
      }
    }
    if ( !a2 )
      return 0LL;
    if ( *(_DWORD *)(v7 + 56) == 0x2000 )
    {
      v7 = *(_QWORD *)(v7 + 88);
      if ( !v7 )
        return 0LL;
    }
    else
    {
      if ( *(_DWORD *)(v7 + 56) == 0x10000 )
        return 0LL;
      if ( !*(_QWORD *)(v7 + 64) )
        return 0LL;
      v7 = *(_QWORD *)(v7 + 64);
    }
  }
  while ( a2 != 2 || !(*(_DWORD *)(v7 + 56) & 0x1D) );
  return 0LL;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009B1BF) ----------------------------------------------------
__int64 __fastcall lys_iffeature_value(__int64 a1)
{
  return sub_18D14(a1);
}

//----- (000000000009B1D9) ----------------------------------------------------
unsigned __int64 __fastcall lys_getnext_union_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  _DWORD *v7; // [rsp+0h] [rbp-20h]
  int v8; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v9; // [rsp+18h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_getnext_union_type", a4, a5, a6, a2);
  v8 = 0;
  if ( v7 && *v7 == 11 )
    result = sub_3A9DE((signed __int64)v7, a1, &v8);
  else
    result = 0LL;
  return result;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009B262) ----------------------------------------------------
signed __int64 __fastcall sub_9B262(__int64 a1, const char *a2, int a3, char *a4, int a5, int a6, const char ***a7)
{
  __int64 k; // rax
  __int64 l; // rax
  int v10; // [rsp+Ch] [rbp-44h]
  char *s2; // [rsp+10h] [rbp-40h]
  int v12; // [rsp+18h] [rbp-38h]
  int v13; // [rsp+1Ch] [rbp-34h]
  __int64 v14; // [rsp+28h] [rbp-28h]
  __int64 i; // [rsp+30h] [rbp-20h]
  __int64 v16; // [rsp+30h] [rbp-20h]
  const char **v17; // [rsp+30h] [rbp-20h]
  __int64 j; // [rsp+38h] [rbp-18h]
  __int64 v19; // [rsp+40h] [rbp-10h]
  char *s1; // [rsp+48h] [rbp-8h]

  v14 = a1;
  v13 = a3;
  s2 = a4;
  v12 = a5;
  v10 = a6;
  v19 = 0LL;
  if ( !a1 || !a2 || !a4 )
    __assert_fail(
      "siblings && mod_name && name",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0xA0u,
      "lys_get_sibling");
  if ( a6 & 0x1800 )
    __assert_fail(
      "!(type & (LYS_USES | LYS_GROUPING))",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0xA1u,
      "lys_get_sibling");
  if ( !a3 )
    v13 = strlen(a2);
  if ( !v12 )
    v12 = strlen(s2);
  while ( v14 && *(_DWORD *)(v14 + 56) == 4096 )
    v14 = *(_QWORD *)(v14 + 72);
  if ( !v14 )
    return 1LL;
  if ( *(_DWORD *)(v14 + 56) == 2048 )
  {
    for ( i = v14; *(_DWORD *)(i + 56) == 2048 && v14 != *(_QWORD *)(i + 88); i = *(_QWORD *)(i + 88) )
      ;
    if ( *(_DWORD *)(i + 56) == 2048 )
      return 1LL;
    v14 = i;
  }
  for ( j = lys_parent(v14); j && *(_DWORD *)(j + 56) == 4096; j = lys_parent(j) )
    ;
  if ( !j )
  {
    v16 = v14;
    for ( k = lys_parent(v14); k && *(_DWORD *)(v16 + 56) == 4096; k = lys_parent(v16) )
      v16 = lys_parent(v16);
    v19 = lys_node_module(v16);
  }
  for ( l = lys_getnext(0LL, j, v19, 11LL); ; l = lys_getnext(v17, j, v19, 11LL) )
  {
    v17 = (const char **)l;
    if ( !l )
      return 1LL;
    if ( !v10 || v10 & *(_DWORD *)(l + 56) )
    {
      s1 = *(char **)(lys_node_module(l) + 8);
      if ( (s1 == a2 || !strncmp(s1, a2, v13) && !s1[v13]) && (s2 == *v17 || !strncmp(*v17, s2, v12) && !(*v17)[v12]) )
        break;
    }
  }
  if ( a7 )
    *a7 = v17;
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000009B536) ----------------------------------------------------
signed __int64 __fastcall sub_9B536(__int64 a1, __int64 a2, char *a3, int a4, int a5, unsigned int a6, const char ***a7)
{
  __int64 i; // rax
  __int64 v8; // rbx
  unsigned int v10; // [rsp+Ch] [rbp-44h]
  int v11; // [rsp+10h] [rbp-40h]
  int v12; // [rsp+14h] [rbp-3Ch]
  char *s2; // [rsp+18h] [rbp-38h]
  __int64 v14; // [rsp+28h] [rbp-28h]
  const char **v15; // [rsp+38h] [rbp-18h]

  v14 = a1;
  s2 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  if ( !a1 && !a2 || !a3 )
    __assert_fail(
      "(mod || parent) && name",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0xE8u,
      "lys_getnext_data");
  if ( a5 & 0x3E42 )
    __assert_fail(
      "!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT))",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0xE9u,
      "lys_getnext_data");
  if ( !a1 )
    v14 = lys_node_module(a2);
  for ( i = lys_getnext(0LL, a2, v14, v10); ; i = lys_getnext(v15, a2, v14, v10) )
  {
    v15 = (const char **)i;
    if ( !i )
      return 1LL;
    if ( !v11 || v11 & *(_DWORD *)(i + 56) )
    {
      v8 = lys_node_module(i);
      if ( v8 == lys_main_module(v14) && !strncmp(*v15, s2, v12) && !(*v15)[v12] )
        break;
    }
  }
  if ( a7 )
    *a7 = v15;
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000009B690) ----------------------------------------------------
__int64 __fastcall lys_getnext(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  unsigned int v8; // eax
  __int16 v9; // [rsp+4h] [rbp-3Ch]
  __int64 v10; // [rsp+8h] [rbp-38h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  __int64 v12; // [rsp+28h] [rbp-18h]
  __int64 v13; // [rsp+30h] [rbp-10h]
  signed __int64 v14; // [rsp+38h] [rbp-8h]

  v11 = a1;
  v10 = a3;
  v9 = a4;
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_getnext", a4, a5, a6);
  if ( !a2 && !v10 || v10 && *(_BYTE *)(v10 + 64) & 1 || a2 && *(_DWORD *)(a2 + 56) == 4096 && !(v9 & 0x80) )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_getnext", v6);
    return 0LL;
  }
  if ( !a1 )
  {
    if ( a2 )
    {
      v14 = sub_A75EB(a2, 0);
      if ( v14 && *(_QWORD *)v14 && (*(_DWORD *)(a2 + 56) != 0x2000 || a2 == *(_QWORD *)(*(_QWORD *)v14 + 64LL)) )
      {
        v11 = *(_QWORD *)v14;
        v12 = *(_QWORD *)v14;
        goto LABEL_27;
      }
      result = 0LL;
    }
    else
    {
      if ( v9 & 0x100 || !(*(_BYTE *)(v10 + 64) & 0x40) && *(_BYTE *)(v10 + 64) < 0 )
      {
        v11 = *(_QWORD *)(v10 + 168);
        v12 = *(_QWORD *)(v10 + 168);
        goto LABEL_27;
      }
      result = 0LL;
    }
    return result;
  }
  if ( *(_DWORD *)(a1 + 56) == 4096 && v9 & 0x20 && *(_QWORD *)(a1 + 72) )
    v12 = *(_QWORD *)(a1 + 72);
  else
    v12 = *(_QWORD *)(a1 + 80);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
LABEL_27:
            if ( a2 && *(_DWORD *)(a2 + 56) == 0x2000 && v12 )
            {
              v13 = *(_QWORD *)(v12 + 64);
              do
              {
                while ( v13 && *(_DWORD *)(v13 + 56) != 0x2000 )
                  v13 = *(_QWORD *)(v13 + 64);
                if ( v13 )
                {
                  if ( v13 == a2 )
                    break;
                  v13 = *(_QWORD *)(v13 + 88);
                }
              }
              while ( v13 );
              if ( v13 )
                goto LABEL_43;
              return 0LL;
            }
LABEL_43:
            while ( v12 && *(_DWORD *)(v12 + 56) == 2048 )
            {
              if ( v9 & 4 )
                return v12;
              v12 = *(_QWORD *)(v12 + 80);
            }
            if ( v12 )
              break;
            if ( !v11 || a2 == *(_QWORD *)(v11 + 64) || a2 == lys_parent(v11) )
              return 0LL;
            v11 = lys_parent(v11);
            v12 = *(_QWORD *)(v11 + 80);
          }
          v11 = v12;
          if ( v9 & 0x100 || !lys_is_disabled(v12, 0LL) )
            break;
          v12 = *(_QWORD *)(v12 + 80);
        }
        v8 = *(_DWORD *)(v12 + 56);
        if ( v8 != 64 )
          break;
        if ( v9 & 2 )
          return v12;
        if ( *(_QWORD *)(v12 + 72) )
          v12 = *(_QWORD *)(v12 + 72);
        else
          v12 = *(_QWORD *)(v12 + 80);
      }
      if ( v8 <= 0x40 )
        break;
      if ( v8 == 1024 )
        goto LABEL_75;
      if ( v8 > 0x400 )
      {
        if ( v8 == 0x4000 || v8 == 32800 )
          return v12;
        if ( v8 != 4096 )
          return 0LL;
        if ( v9 & 0x10 )
          return v12;
        if ( *(_QWORD *)(v12 + 72) )
          v12 = *(_QWORD *)(v12 + 72);
        else
          v12 = *(_QWORD *)(v12 + 80);
      }
      else
      {
        if ( v8 == 256 )
          return v12;
        if ( v8 != 512 )
        {
          if ( v8 != 128 )
            return 0LL;
          return v12;
        }
LABEL_75:
        if ( v9 & 8 )
          return v12;
        if ( *(_QWORD *)(v12 + 72) )
          v12 = *(_QWORD *)(v12 + 72);
        else
          v12 = *(_QWORD *)(v12 + 80);
      }
    }
    if ( v8 == 4 )
      return v12;
    if ( v8 > 4 )
      break;
    if ( v8 == 1 )
    {
      if ( *(_QWORD *)(v12 + 136) || !(v9 & 0x40) )
        return v12;
      if ( *(_QWORD *)(v12 + 72) )
        v12 = *(_QWORD *)(v12 + 72);
      else
        v12 = *(_QWORD *)(v12 + 80);
    }
    else
    {
      if ( v8 != 2 )
        return 0LL;
      if ( v9 & 1 )
        return v12;
      if ( *(_QWORD *)(v12 + 72) )
        v12 = *(_QWORD *)(v12 + 72);
      else
        v12 = *(_QWORD *)(v12 + 80);
    }
  }
  if ( v8 == 16 || v8 == 32 || v8 == 8 )
    return v12;
  return 0LL;
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009BBAC) ----------------------------------------------------
void __fastcall sub_9BBAC(__int64 a1)
{
  __int64 v1; // rax
  unsigned int v2; // eax
  __int64 v3; // [rsp+10h] [rbp-20h]
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 *v5; // [rsp+20h] [rbp-10h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = 0LL;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 48) )
    {
      v6 = lys_node_module(a1);
      if ( a1 == *(_QWORD *)(v6 + 168) )
        *(_QWORD *)(v6 + 168) = *(_QWORD *)(a1 + 80);
    }
    v3 = *(_QWORD *)(a1 + 64);
    if ( v3 && *(_DWORD *)(v3 + 56) == 0x2000 )
    {
      if ( a1 == *(_QWORD *)(v3 + 72) )
      {
        if ( *(_QWORD *)(a1 + 80) && v3 == *(_QWORD *)(*(_QWORD *)(a1 + 80) + 64LL) )
          v1 = *(_QWORD *)(a1 + 80);
        else
          v1 = 0LL;
        *(_QWORD *)(v3 + 72) = v1;
      }
      if ( *(_WORD *)(v3 + 24) & 1 )
        v3 = 0LL;
      else
        v3 = *(_QWORD *)(v3 + 88);
    }
    if ( v3 )
    {
      if ( *(_DWORD *)(v3 + 56) == 0x10000 )
      {
        v2 = sub_C1906(*(_DWORD *)(a1 + 56));
        v5 = (__int64 *)lys_ext_complex_get_substmt(v2, v3, 0LL);
        if ( a1 == *v5 )
          *v5 = *(_QWORD *)(a1 + 80);
      }
      else if ( a1 == *(_QWORD *)(v3 + 72) )
      {
        *(_QWORD *)(v3 + 72) = *(_QWORD *)(a1 + 80);
      }
      *(_QWORD *)(a1 + 64) = 0LL;
    }
    if ( a1 != *(_QWORD *)(a1 + 88) )
    {
      if ( *(_QWORD *)(a1 + 80) )
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 88LL) = *(_QWORD *)(a1 + 88);
      }
      else
      {
        if ( v3 )
        {
          if ( *(_DWORD *)(v3 + 56) == 0x10000 )
            i = *v5;
          else
            i = *(_QWORD *)(v3 + 72);
        }
        else
        {
          for ( i = a1; *(_QWORD *)(*(_QWORD *)(i + 88) + 80LL); i = *(_QWORD *)(i + 88) )
            ;
        }
        *(_QWORD *)(i + 88) = *(_QWORD *)(a1 + 88);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 88) + 80LL) )
        *(_QWORD *)(*(_QWORD *)(a1 + 88) + 80LL) = *(_QWORD *)(a1 + 80);
      *(_QWORD *)(a1 + 80) = 0LL;
      *(_QWORD *)(a1 + 88) = a1;
    }
  }
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (000000000009BDFE) ----------------------------------------------------
__int64 __fastcall sub_9BDFE(const char *a1, __int64 a2)
{
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  for ( i = a2; i; i = *(_QWORD *)(i + 64) )
  {
    if ( *(_QWORD *)(i + 64) )
    {
      if ( !*(_QWORD *)(*(_QWORD *)(i + 64) + 64LL) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
      {
        i = *(_QWORD *)(lys_main_module(*(_QWORD *)(*(_QWORD *)(i + 64) + 48LL)) + 168);
        if ( !i )
          break;
      }
    }
    if ( *(_DWORD *)(i + 56) == 0x10000 )
    {
      i = *(_QWORD *)(lys_main_module(*(_QWORD *)(i + 48)) + 168);
      if ( !i )
        return 0LL;
    }
    else if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) & 0x3042 )
    {
      continue;
    }
    v4 = i;
    v5 = 0LL;
    while ( v4 )
    {
      if ( v5 )
      {
        if ( v4 == v5 )
          break;
      }
      else
      {
        v5 = i;
      }
      if ( *(_DWORD *)(v4 + 56) == 2048 && !strcmp(a1, *(const char **)v4) )
        return v4;
      v4 = *(_QWORD *)(v4 + 88);
    }
  }
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000009BF66) ----------------------------------------------------
__int64 __fastcall sub_9BF66(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v3 = a1;
  if ( !a2 )
    __assert_fail("root", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x22Bu, "lys_get_next_grouping");
  if ( !a1 )
    v3 = a2;
  while ( 1 )
  {
    v4 = *(_DWORD *)(v3 + 56) & 0xE13 ? *(_QWORD *)(v3 + 72) : 0LL;
    if ( !v4 )
      break;
LABEL_15:
    while ( !v4 )
    {
      if ( a2 == lys_parent(v3) )
        return 0LL;
      v4 = *(_QWORD *)(v3 + 80);
      v3 = lys_parent(v3);
    }
    if ( *(_DWORD *)(v4 + 56) == 2048 )
      return v4;
    v3 = v4;
  }
  if ( v3 != a2 )
  {
    v4 = *(_QWORD *)(v3 + 80);
    goto LABEL_15;
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (000000000009C05E) ----------------------------------------------------
signed __int64 __fastcall sub_9C05E(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // eax
  _QWORD *j; // rax
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // [rsp+8h] [rbp-58h]
  __int64 v9; // [rsp+8h] [rbp-58h]
  signed int v10; // [rsp+28h] [rbp-38h]
  _BOOL4 v11; // [rsp+2Ch] [rbp-34h]
  __int64 v12; // [rsp+30h] [rbp-30h]
  __int64 v13; // [rsp+30h] [rbp-30h]
  __int64 v14; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+38h] [rbp-28h]
  __int64 v16; // [rsp+40h] [rbp-20h]
  __int64 v17; // [rsp+40h] [rbp-20h]
  signed __int64 v18; // [rsp+40h] [rbp-20h]
  __int64 i; // [rsp+40h] [rbp-20h]

  v8 = a3;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x25Au, "lys_check_id");
  if ( a2 )
  {
    v8 = *(_QWORD *)(a2 + 48);
  }
  else if ( !a3 )
  {
    __assert_fail("module", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x25Du, "lys_check_id");
  }
  v9 = lys_main_module(v8);
  v3 = *(_DWORD *)(a1 + 56);
  if ( v3 == 8 )
    goto LABEL_44;
  if ( v3 <= 8 )
  {
    if ( v3 < 1 || v3 > 2 && v3 != 4 )
      return 0LL;
LABEL_44:
    if ( !a2 )
    {
      v15 = 0LL;
      v18 = *(_QWORD *)(v9 + 168);
      goto LABEL_75;
    }
    v17 = a2;
    while ( v17 && *(_DWORD *)(v17 + 56) & 0x3042 )
    {
      if ( *(_DWORD *)(v17 + 56) == 0x2000 )
      {
        if ( !*(_QWORD *)(v17 + 88) )
          break;
        v17 = *(_QWORD *)(v17 + 88);
      }
      else
      {
        v17 = *(_QWORD *)(v17 + 64);
      }
    }
    if ( v17 )
    {
      if ( *(_DWORD *)(v17 + 56) == 0x10000 )
      {
        v15 = v17;
        v18 = sub_A75EB(v17, *(_DWORD *)(a1 + 56));
        if ( v18 )
          v18 = *(_QWORD *)v18;
      }
      else
      {
        v15 = v17;
        v18 = *(_QWORD *)(v17 + 72);
      }
    }
    else
    {
      v15 = 0LL;
      v18 = *(_QWORD *)(v9 + 168);
    }
LABEL_75:
    while ( v18 )
    {
      if ( *(_DWORD *)(v18 + 56) & 0x1040 )
      {
        v18 = *(_QWORD *)(v18 + 72);
      }
      else
      {
        if ( *(_DWORD *)(v18 + 56) & 0x803F
          && *(_QWORD *)(v18 + 48) == *(_QWORD *)(a1 + 48)
          && *(_QWORD *)v18 == *(_QWORD *)a1 )
        {
          v6 = *(_QWORD *)a1;
          v7 = sub_8164(*(_DWORD *)(a1 + 56));
          sub_13937(*(void **)v9, 15, 2u, (char *)a1, (__int64)v7, v6);
          return 1LL;
        }
        if ( *(_DWORD *)(v18 + 56) == 2 )
        {
          v18 = *(_QWORD *)(v18 + 72);
        }
        else
        {
          if ( !*(_QWORD *)(v18 + 80) )
          {
            while ( v15 != *(_QWORD *)(v18 + 64) )
            {
              v18 = lys_parent(v18);
              if ( v18 && *(_QWORD *)(v18 + 80) || v18 == v15 )
                goto LABEL_73;
            }
            v18 = v15;
LABEL_73:
            if ( v18 == v15 )
              return 0LL;
          }
          v18 = *(_QWORD *)(v18 + 80);
        }
      }
    }
    return 0LL;
  }
  if ( v3 == 64 )
  {
    if ( a2 )
      v13 = *(_QWORD *)sub_A75EB(a2, 0x40u);
    else
      v13 = *(_QWORD *)(v9 + 168);
    for ( i = v13; i; i = *(_QWORD *)(i + 80) )
    {
      if ( *(_DWORD *)(i + 56) & 0x807D && *(_QWORD *)(i + 48) == *(_QWORD *)(a1 + 48) && *(_QWORD *)i == *(_QWORD *)a1 )
      {
        sub_13937(*(void **)v9, 15, 2u, (char *)a1, (__int64)"case", *(_QWORD *)a1);
        return 1LL;
      }
    }
    return 0LL;
  }
  if ( v3 > 0x40 )
  {
    if ( v3 == 2048 )
    {
      if ( a2 )
      {
        v12 = *(_QWORD *)sub_A75EB(a2, 0x800u);
        if ( v12 )
        {
          v10 = 1;
        }
        else
        {
          v10 = 0;
          v12 = a2;
        }
        v11 = *(_DWORD *)(a2 + 56) != 0x10000;
      }
      else
      {
        v11 = 1;
        v10 = 1;
        v12 = *(_QWORD *)(v9 + 168);
      }
      if ( v11 && sub_9BDFE(*(const char **)a1, v12) )
      {
        sub_13937(*(void **)v9, 15, 2u, (char *)a1, (__int64)"grouping", *(_QWORD *)a1);
        return 1LL;
      }
      if ( v10 )
      {
        v16 = v12;
        v14 = 0LL;
        while ( v16 )
        {
          if ( v14 )
          {
            if ( v16 == v14 )
              return 0LL;
          }
          else
          {
            v14 = v12;
          }
          if ( *(_DWORD *)(v16 + 56) & 0xE13 )
          {
            for ( j = (_QWORD *)sub_9BF66(0LL, v16); j; j = (_QWORD *)sub_9BF66((__int64)j, v16) )
            {
              if ( *(_QWORD *)a1 == *j )
              {
                sub_13937(*(void **)v9, 15, 2u, (char *)a1, (__int64)"grouping", *(_QWORD *)a1);
                return 1LL;
              }
            }
          }
          v16 = *(_QWORD *)(v16 + 88);
        }
      }
    }
    else if ( v3 == 32800 )
    {
      goto LABEL_44;
    }
  }
  else if ( v3 == 16 )
  {
    goto LABEL_44;
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000009C637) ----------------------------------------------------
signed __int64 __fastcall sub_9C637(__int64 a1, _QWORD *a2, __int64 a3, unsigned int a4)
{
  const char *v4; // rbx
  const char *v5; // rax
  const char *v7; // rbx
  const char *v8; // rax
  const char *v9; // rax
  const char *v10; // rax
  const char *v11; // rax
  const char *v12; // rbx
  const char *v13; // rax
  const char *v14; // rax
  const char *v15; // rbx
  const char *v16; // rax
  const char *v17; // rax
  unsigned int v18; // eax
  __int64 v19; // rbx
  const char *v20; // rax
  __int64 v21; // rax
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 v24; // r9
  __int16 v25; // ax
  __int64 v26; // r9
  __int64 v27; // rax
  __int64 v28; // rax
  unsigned int v29; // [rsp+4h] [rbp-8Ch]
  __int64 v30; // [rsp+8h] [rbp-88h]
  _QWORD *v31; // [rsp+10h] [rbp-80h]
  __int64 v32; // [rsp+18h] [rbp-78h]
  signed int v33; // [rsp+20h] [rbp-70h]
  signed int v34; // [rsp+24h] [rbp-6Ch]
  __int64 v35; // [rsp+28h] [rbp-68h]
  __int64 i; // [rsp+30h] [rbp-60h]
  __int64 **v37; // [rsp+38h] [rbp-58h]
  void *v38; // [rsp+40h] [rbp-50h]
  __int64 **v39; // [rsp+48h] [rbp-48h]
  __int64 v40; // [rsp+50h] [rbp-40h]
  _WORD *v41; // [rsp+58h] [rbp-38h]
  __int64 v42; // [rsp+60h] [rbp-30h]
  void *ptr; // [rsp+68h] [rbp-28h]
  void *v44; // [rsp+70h] [rbp-20h]
  unsigned __int64 v45; // [rsp+78h] [rbp-18h]

  v32 = a1;
  v31 = a2;
  v30 = a3;
  v29 = a4;
  v45 = __readfsqword(0x28u);
  v38 = **(void ***)(a3 + 48);
  v34 = 0;
  v35 = 0LL;
  if ( !a3 )
    __assert_fail("child", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x30Cu, "lys_node_addchild");
  if ( a1 )
  {
    v33 = *(_DWORD *)(a1 + 56);
    v31 = *(_QWORD **)(a1 + 48);
    v37 = (__int64 **)a1;
    if ( v33 == 4096 )
    {
      while ( v37 && *((_DWORD *)v37 + 14) == 4096 )
      {
        if ( *((_DWORD *)v37 + 14) == 0x2000 )
        {
          v39 = v37;
          if ( !v37[11] )
            goto LABEL_70;
          v37 = (__int64 **)v39[11];
        }
        else
        {
          v37 = (__int64 **)v37[8];
        }
      }
      if ( v37 )
        v33 = *((_DWORD *)v37 + 14);
      else
        v33 = 0;
    }
  }
  else
  {
    if ( !a2 )
      __assert_fail("module", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x328u, "lys_node_addchild");
    if ( *(_DWORD *)(a3 + 56) & 0x600 )
      __assert_fail(
        "!(child->nodetype & (LYS_INPUT | LYS_OUTPUT))",
        "/home/mantovan/Repositories/libyang/src/tree_schema.c",
        0x329u,
        "lys_node_addchild");
    v33 = 0;
    v37 = 0LL;
  }
  if ( v33 == 128 )
    goto LABEL_53;
  if ( v33 <= 128 )
  {
    if ( v33 != 4 )
    {
      if ( v33 <= 4 )
      {
        if ( v33 != 1 )
        {
          if ( v33 == 2 )
          {
            if ( !(*(_DWORD *)(a3 + 56) & 0x807F) )
            {
              v9 = sub_8164(*(_DWORD *)(a3 + 56));
              sub_13937(v38, 6, 2u, (char *)v37, (__int64)v9, (__int64)"choice");
              return 1LL;
            }
            if ( *(_DWORD *)(a3 + 56) != 64 )
              v34 = 1;
          }
          else if ( !v33 && !(*(_DWORD *)(a3 + 56) & 0xB9BF) )
          {
            v17 = sub_8164(*(_DWORD *)(a3 + 56));
            sub_13937(v38, 6, 2u, (char *)v37, (__int64)v17, (__int64)"(sub)module");
            return 1LL;
          }
          goto LABEL_70;
        }
LABEL_51:
        if ( !(*(_DWORD *)(a3 + 56) & 0xD8BF) )
        {
          v4 = sub_8164(*((_DWORD *)v37 + 14));
          v5 = sub_8164(*(_DWORD *)(v30 + 56));
          sub_13937(v38, 6, 2u, (char *)v37, (__int64)v5, (__int64)v4);
          return 1LL;
        }
        goto LABEL_70;
      }
      if ( v33 == 16 )
        goto LABEL_51;
      if ( v33 > 16 )
      {
        if ( v33 != 32 )
        {
          if ( v33 == 64 && !(*(_DWORD *)(a3 + 56) & 0x903F) )
          {
            v10 = sub_8164(*(_DWORD *)(a3 + 56));
            sub_13937(v38, 6, 2u, (char *)v37, (__int64)v10, (__int64)"case");
            return 1LL;
          }
          goto LABEL_70;
        }
      }
      else if ( v33 != 8 )
      {
        goto LABEL_70;
      }
    }
LABEL_63:
    v12 = sub_8164(*((_DWORD *)v37 + 14));
    v13 = sub_8164(*(_DWORD *)(v30 + 56));
    sub_13937(v38, 6, 2u, (char *)v37, (__int64)v13, (__int64)v12);
    v14 = sub_8164(*((_DWORD *)v37 + 14));
    sub_13937(v38, -1, 5u, 0LL, (__int64)"The \"%s\" statement cannot have any data substatement.", (__int64)v14);
    return 1LL;
  }
  if ( v33 == 4096 )
    goto LABEL_51;
  if ( v33 <= 4096 )
  {
    if ( v33 != 512 )
    {
      if ( v33 <= 512 )
      {
        if ( v33 != 256 )
          goto LABEL_70;
        goto LABEL_61;
      }
      if ( v33 != 1024 )
      {
        if ( v33 != 2048 )
          goto LABEL_70;
        goto LABEL_51;
      }
    }
LABEL_53:
    if ( !(*(_DWORD *)(a3 + 56) & 0x983F) )
    {
      v7 = sub_8164(*((_DWORD *)v37 + 14));
      v8 = sub_8164(*(_DWORD *)(v30 + 56));
      sub_13937(v38, 6, 2u, (char *)v37, (__int64)v8, (__int64)v7);
      return 1LL;
    }
    goto LABEL_70;
  }
  if ( v33 == 0x4000 )
  {
LABEL_61:
    if ( !(*(_DWORD *)(a3 + 56) & 0xE00) )
    {
      v11 = sub_8164(*(_DWORD *)(a3 + 56));
      sub_13937(v38, 6, 2u, (char *)v37, (__int64)v11, (__int64)"rpc");
      return 1LL;
    }
    goto LABEL_70;
  }
  if ( v33 <= 0x4000 )
  {
    if ( v33 == 0x2000 && !(*(_DWORD *)(a3 + 56) & 0xD0FF) )
    {
      v15 = sub_8164(*((_DWORD *)v37 + 14));
      v16 = sub_8164(*(_DWORD *)(v30 + 56));
      sub_13937(v38, 6, 2u, (char *)v37, (__int64)v16, (__int64)v15);
      return 1LL;
    }
    goto LABEL_70;
  }
  if ( v33 == 32800 )
    goto LABEL_63;
  if ( v33 == 0x10000 )
  {
    v18 = sub_C1906(*(_DWORD *)(a3 + 56));
    v40 = lys_ext_complex_get_substmt(v18, v37, &v35);
    if ( !v40 )
    {
      v19 = **v37;
      v20 = sub_8164(*(_DWORD *)(v30 + 56));
      sub_13937(v38, 6, 2u, (char *)v37, (__int64)v20, v19);
      return 1LL;
    }
  }
LABEL_70:
  if ( !(*(_DWORD *)(*v31 + 92LL) & 2) && (unsigned int)sub_9C05E(v30, a1, (__int64)v31) )
    return 1LL;
  if ( *(_QWORD *)(v30 + 64) )
    sub_9BBAC(v30);
  if ( *(_DWORD *)(v30 + 56) & 0x600 && *(_DWORD *)(a1 + 56) != 0x10000 )
  {
    for ( i = *(_QWORD *)(a1 + 72); i && *(_DWORD *)(i + 56) != *(_DWORD *)(v30 + 56); i = *(_QWORD *)(i + 80) )
      ;
    if ( !i )
      __assert_fail("iter", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x393u, "lys_node_addchild");
    if ( i == *(_QWORD *)(a1 + 72) )
      *(_QWORD *)(a1 + 72) = v30;
    else
      *(_QWORD *)(*(_QWORD *)(i + 88) + 80LL) = v30;
    *(_QWORD *)(v30 + 88) = *(_QWORD *)(i + 88);
    *(_QWORD *)(v30 + 80) = *(_QWORD *)(i + 80);
    if ( *(_QWORD *)(i + 80) )
      v21 = *(_QWORD *)(i + 80);
    else
      v21 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(v21 + 88) = v30;
    *(_QWORD *)(v30 + 64) = a1;
    *(_QWORD *)(i + 80) = 0LL;
    *(_QWORD *)(i + 88) = i;
    *(_QWORD *)(i + 64) = 0LL;
    sub_A33A0((_QWORD **)i, 0LL, 0);
  }
  else
  {
    if ( v34 )
    {
      v41 = calloc(1uLL, 0x70uLL);
      if ( !v41 )
      {
        sub_12222((__int64)v38, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_addchild", v22);
        return 1LL;
      }
      v23 = lydict_insert(*v31, *(_QWORD *)v30, 0LL);
      *(_QWORD *)v41 = v23;
      v41[12] = 64;
      if ( !(v29 & 3) )
        v41[12] |= *(_WORD *)(a1 + 24) & 3;
      *((_QWORD *)v41 + 6) = v31;
      *((_DWORD *)v41 + 14) = 64;
      *((_QWORD *)v41 + 11) = v41;
      sub_9C637(a1, v31, v41, v29);
      v32 = (__int64)v41;
    }
    if ( v32 )
    {
      v42 = sub_A75EB(v32, *(_DWORD *)(v30 + 56));
      if ( !v42 )
        __assert_fail("pchild", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x3C8u, "lys_node_addchild");
      *(_QWORD *)(v30 + 64) = v32;
      if ( *(_QWORD *)v42 )
      {
        i = *(_QWORD *)(*(_QWORD *)v42 + 88LL);
        *(_QWORD *)(i + 80) = v30;
        *(_QWORD *)(v30 + 88) = i;
      }
      else
      {
        *(_QWORD *)v42 = v30;
        i = v30;
      }
      while ( *(_QWORD *)(i + 80) )
      {
        i = *(_QWORD *)(i + 80);
        *(_QWORD *)(i + 64) = v32;
      }
      *(_QWORD *)(*(_QWORD *)v42 + 88LL) = i;
    }
    else if ( v31[21] )
    {
      *(_QWORD *)(*(_QWORD *)(v31[21] + 88LL) + 80LL) = v30;
      *(_QWORD *)(v30 + 88) = *(_QWORD *)(v31[21] + 88LL);
      *(_QWORD *)(v31[21] + 88LL) = v30;
    }
    else
    {
      v31[21] = v30;
    }
  }
  for ( i = v32; i && !(*(_DWORD *)(i + 56) & 0x12800); i = *(_QWORD *)(i + 64) )
    ;
  if ( v32 && !i )
  {
    for ( i = v30; i && !(*(_DWORD *)(i + 56) & 0x780); i = *(_QWORD *)(i + 64) )
      ;
    if ( !i && *(_WORD *)(v32 + 24) & 2 && *(_WORD *)(v30 + 24) & 1 )
    {
      sub_13937(v38, 10, 2u, (char *)v30, (__int64)"true", (__int64)"config");
      sub_13937(v38, -1, 5u, 0LL, (__int64)"State nodes cannot have configuration nodes as children.", v24);
      return 1LL;
    }
  }
  if ( *(_DWORD *)(v30 + 56) & 0x803F && *(_WORD *)(v30 + 24) & 0x80 )
  {
    for ( i = v32; i; i = lys_parent(i) )
    {
      if ( *(_DWORD *)(i + 56) & 0x11 )
      {
        if ( *(_WORD *)(i + 24) & 0x80 )
          break;
        v25 = *(_WORD *)(i + 24);
        LOBYTE(v25) = v25 | 0x80;
        *(_WORD *)(i + 24) = v25;
      }
    }
  }
  if ( *(_DWORD *)(v30 + 56) & 0x4100 && !*(_QWORD *)(v30 + 72) )
  {
    ptr = calloc(1uLL, 0x78uLL);
    v44 = calloc(1uLL, 0x78uLL);
    if ( !ptr || !v44 )
    {
      sub_12222((__int64)v38, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_addchild", v26);
      free(ptr);
      free(v44);
      return 1LL;
    }
    *((_DWORD *)ptr + 14) = 512;
    v27 = lydict_insert(**(_QWORD **)(v30 + 48), "input", 5LL);
    *(_QWORD *)ptr = v27;
    *((_DWORD *)v44 + 14) = 1024;
    v28 = lydict_insert(**(_QWORD **)(v30 + 48), "output", 6LL);
    *(_QWORD *)v44 = v28;
    *((_QWORD *)v44 + 6) = *(_QWORD *)(v30 + 48);
    *((_QWORD *)ptr + 6) = *((_QWORD *)v44 + 6);
    *((_QWORD *)v44 + 8) = v30;
    *((_QWORD *)ptr + 8) = *((_QWORD *)v44 + 8);
    *((_WORD *)v44 + 12) = 64;
    *((_WORD *)ptr + 12) = *((_WORD *)v44 + 12);
    *((_QWORD *)ptr + 10) = v44;
    *((_QWORD *)ptr + 11) = v44;
    *((_QWORD *)v44 + 11) = ptr;
    *(_QWORD *)(v30 + 72) = ptr;
  }
  return 0LL;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000009D438) ----------------------------------------------------
__int64 __fastcall sub_9D438(__int64 a1, const char *a2, int a3, char *a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  char *v8; // rax
  unsigned int v9; // [rsp+Ch] [rbp-44h]
  char *v10; // [rsp+10h] [rbp-40h]
  int v11; // [rsp+1Ch] [rbp-34h]
  char *s; // [rsp+20h] [rbp-30h]
  unsigned int n; // [rsp+3Ch] [rbp-14h]
  char *n_4; // [rsp+40h] [rbp-10h]
  __int64 v15; // [rsp+48h] [rbp-8h]

  s = (char *)a2;
  v11 = a3;
  v10 = a4;
  v9 = a6;
  n_4 = 0LL;
  v15 = 0LL;
  if ( !a1 || !a2 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_parse_mem_", a6);
    return 0LL;
  }
  if ( !(_DWORD)a5 && a3 == 1 )
  {
    n = strlen(a2);
    n_4 = (char *)malloc(n + 2);
    if ( !n_4 )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_parse_mem_", v7);
      return 0LL;
    }
    memcpy(n_4, a2, n);
    v8 = &n_4[n + 1];
    *v8 = 0;
    n_4[n] = *v8;
    s = n_4;
  }
  if ( v11 == 1 )
  {
    v15 = (__int64)sub_9316E(a1, s, 0, v10, v9);
  }
  else if ( v11 == 2 )
  {
    v15 = sub_61383(a1, (__int64)s, (__int64)v10, v9);
  }
  else
  {
    sub_12222(a1, 0, 3, "Invalid schema input format.", a5, a6);
  }
  free(n_4);
  if ( !v15 || !(unsigned int)sub_C462(*(_BYTE **)(v15 + 8), "ietf-netconf") || !(unsigned int)sub_351D9(v15) )
    return v15;
  sub_A67C8((unsigned __int8 *)v15, 0LL, 1, 1);
  return 0LL;
}

//----- (000000000009D631) ----------------------------------------------------
__int64 __fastcall lys_parse_mem(__int64 a1, const char *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // ST0C_4

  v6 = a3;
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_parse_mem", a4, a5, a6);
  return sub_9D438(a1, a2, v6, 0LL, 0LL, 1LL);
}
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009D687) ----------------------------------------------------
void *__fastcall sub_9D687(__int64 *a1, const char *a2, int a3, __int64 a4)
{
  __int64 v4; // r9
  char *v6; // rax
  __int64 v7; // [rsp+0h] [rbp-40h]
  int v8; // [rsp+Ch] [rbp-34h]
  char *s; // [rsp+10h] [rbp-30h]
  void **v10; // [rsp+18h] [rbp-28h]
  unsigned int n; // [rsp+2Ch] [rbp-14h]
  char *n_4; // [rsp+30h] [rbp-10h]
  void *v13; // [rsp+38h] [rbp-8h]

  s = (char *)a2;
  v8 = a3;
  v7 = a4;
  n_4 = 0LL;
  if ( !a1 )
    __assert_fail("module", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x453u, "lys_sub_parse_mem");
  if ( !a2 )
    __assert_fail("data", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x454u, "lys_sub_parse_mem");
  if ( a3 == 1 )
  {
    n = strlen(a2);
    n_4 = (char *)malloc(n + 2);
    if ( !n_4 )
    {
      sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_sub_parse_mem", v4, v7);
      return 0LL;
    }
    memcpy(n_4, a2, n);
    v6 = &n_4[n + 1];
    *v6 = 0;
    n_4[n] = *v6;
    s = n_4;
  }
  v10 = (void **)lys_main_module(a1);
  if ( v8 == 1 )
  {
    v13 = sub_93708((__int64)v10, s, 0, v7);
  }
  else
  {
    if ( v8 != 2 )
      __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x46Bu, "lys_sub_parse_mem");
    v13 = sub_609BB(v10, (__int64)s, v7);
  }
  free(n_4);
  return v13;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000009D830) ----------------------------------------------------
__int64 __fastcall lys_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  int *v8; // rax
  char *v9; // rax
  char *v10; // rax
  const char *v11; // rdx
  __int64 v12; // rdx
  unsigned int v13; // [rsp+Ch] [rbp-1054h]
  unsigned int fd; // [rsp+24h] [rbp-103Ch]
  char *s; // [rsp+28h] [rbp-1038h]
  char *sa; // [rsp+28h] [rbp-1038h]
  __int64 v17; // [rsp+30h] [rbp-1030h]
  char *s2; // [rsp+38h] [rbp-1028h]
  char *s2a; // [rsp+38h] [rbp-1028h]
  char *v20; // [rsp+40h] [rbp-1020h]
  size_t n; // [rsp+48h] [rbp-1018h]
  char resolved; // [rsp+50h] [rbp-1010h]
  unsigned __int64 v23; // [rsp+1058h] [rbp-8h]

  v13 = a3;
  v23 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_parse_path", a4, a5, a6);
  if ( a1 && a2 )
  {
    fd = open(a2, 0);
    if ( fd == -1 )
    {
      v8 = __errno_location();
      v9 = strerror(*v8);
      sub_12222(a1, 0, 2, "Opening file \"%s\" failed (%s).", (__int64)a2, (__int64)v9);
      result = 0LL;
    }
    else
    {
      v17 = lys_parse_fd(a1, fd, v13);
      close(fd);
      if ( v17 )
      {
        s = strrchr(a2, 47);
        if ( s )
        {
          sa = s + 1;
          v10 = strchr(sa, 64);
        }
        else
        {
          sa = (char *)a2;
          v10 = strchr(a2, 64);
        }
        s2 = v10;
        v20 = strrchr(sa, 46);
        n = strlen(*(const char **)(v17 + 8));
        if ( strncmp(sa, *(const char **)(v17 + 8), n) || s2 && s2 != &sa[n] || !s2 && v20 != &sa[n] )
          sub_12222(a1, 1u, 0, "File name \"%s\" does not match module name \"%s\".", (__int64)sa, *(_QWORD *)(v17 + 8));
        if ( s2 )
        {
          s2a = s2 + 1;
          if ( !*(_BYTE *)(v17 + 68) || v20 - s2a != 10 || strncmp(*(const char **)(v17 + 88), s2a, 0xAuLL) )
          {
            if ( *(_BYTE *)(v17 + 68) )
              v11 = *(const char **)(v17 + 88);
            else
              v11 = "none";
            sub_12222(a1, 1u, 0, "File name \"%s\" does not match module revision \"%s\".", (__int64)sa, (__int64)v11);
          }
        }
        if ( !*(_QWORD *)(v17 + 56) )
        {
          if ( realpath(a2, &resolved) )
            v12 = lydict_insert(a1, &resolved, 0LL);
          else
            v12 = lydict_insert(a1, a2, 0LL);
          *(_QWORD *)(v17 + 56) = v12;
        }
        result = v17;
      }
      else
      {
        result = 0LL;
      }
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_parse_path", v6);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7B60: using guessed type __int64 __fastcall lys_parse_fd(_QWORD, _QWORD, _QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009DC26) ----------------------------------------------------
__int64 __fastcall lys_parse_fd(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  int v7; // ST00_4
  signed int v8; // ST04_4
  __int64 v9; // ST08_8

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_parse_fd", a4, a5, a6, __PAIR__(a2, a3), a1);
  return sub_9DD36(v9, v8, v7, 0LL, 1u, v6);
}
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009DC74) ----------------------------------------------------
unsigned __int64 __fastcall sub_9DC74(__int64 a1, _QWORD *a2, unsigned int a3)
{
  int v4; // [rsp+2Ch] [rbp-1034h]
  char s; // [rsp+30h] [rbp-1030h]
  char buf; // [rsp+50h] [rbp-1010h]
  unsigned __int64 v7; // [rsp+1058h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  sprintf(&s, "/proc/self/fd/%d", a3);
  v4 = readlink(&s, &buf, 0xFFFuLL);
  if ( v4 > 0 )
    *a2 = lydict_insert(a1, &buf, v4);
  return __readfsqword(0x28u) ^ v7;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000009DD36) ----------------------------------------------------
__int64 __fastcall sub_9DD36(__int64 a1, signed int a2, int a3, char *a4, unsigned int a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+4h] [rbp-3Ch]
  char *v10; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+10h] [rbp-30h]
  size_t v12; // [rsp+20h] [rbp-20h]
  char *v13; // [rsp+28h] [rbp-18h]
  __int64 v14; // [rsp+30h] [rbp-10h]
  unsigned __int64 v15; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v15 = __readfsqword(0x28u);
  if ( a1 && a2 >= 0 )
  {
    if ( (unsigned int)sub_34EE2(a1, a2, a3 == 1, &v12, (void **)&v13) )
    {
      sub_12222(a1, 0, 2, "Mapping file descriptor into memory failed (%s()).", (__int64)"lys_parse_fd_", v8);
      result = 0LL;
    }
    else if ( v13 )
    {
      v14 = sub_9D438(a1, v13, v11, v10, 1LL, v9);
      sub_351B4(v13, v12);
      if ( v14 )
      {
        if ( !*(_QWORD *)(v14 + 56) )
          sub_9DC74(a1, (_QWORD *)(v14 + 56), a2);
      }
      result = v14;
    }
    else
    {
      sub_12222(a1, 0, 3, "Empty schema file.", v7, v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_parse_fd_", a6);
    result = 0LL;
  }
  return result;
}

//----- (000000000009DEAC) ----------------------------------------------------
_QWORD *__fastcall sub_9DEAC(__int64 *a1, signed int a2, int a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+10h] [rbp-30h]
  __int64 *v9; // [rsp+18h] [rbp-28h]
  size_t v10; // [rsp+20h] [rbp-20h]
  char *v11; // [rsp+28h] [rbp-18h]
  _QWORD *v12; // [rsp+30h] [rbp-10h]
  unsigned __int64 v13; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v13 = __readfsqword(0x28u);
  if ( !a1 )
    __assert_fail("module", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x4F9u, "lys_sub_parse_fd");
  if ( a2 < 0 )
    __assert_fail("fd >= 0", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x4FAu, "lys_sub_parse_fd");
  if ( (unsigned int)sub_34EE2(*a1, a2, a3 == 1, &v10, (void **)&v11) )
  {
    sub_12222(*a1, 0, 2, "Mapping file descriptor into memory failed (%s()).", (__int64)"lys_sub_parse_fd", v5);
    return 0LL;
  }
  if ( !v11 )
  {
    sub_12222(*a1, 0, 3, "Empty submodule schema file.", v4, v5);
    return 0LL;
  }
  v9 = (__int64 *)lys_main_module(a1);
  if ( v8 == 1 )
  {
    v12 = sub_93708((__int64)v9, v11, 0, v7);
  }
  else
  {
    if ( v8 != 2 )
    {
      sub_12222(
        *v9,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
        1295LL);
      return 0LL;
    }
    v12 = sub_609BB((void **)v9, (__int64)v11, v7);
  }
  sub_351B4(v11, v10);
  if ( v12 )
  {
    if ( !v12[7] )
      sub_9DC74(*v9, v12 + 7, a2);
  }
  return v12;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (000000000009E0A8) ----------------------------------------------------
signed __int64 __fastcall lys_search_localfile(__int64 a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  int *v11; // rax
  char *v12; // rax
  __int64 v13; // r9
  int *v14; // rax
  char *v15; // rax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  size_t v19; // rax
  signed int *v20; // [rsp+0h] [rbp-140h]
  _QWORD *v21; // [rsp+8h] [rbp-138h]
  char *s1; // [rsp+10h] [rbp-130h]
  char *s; // [rsp+18h] [rbp-128h]
  int i; // [rsp+38h] [rbp-108h]
  signed int v25; // [rsp+3Ch] [rbp-104h]
  unsigned int v26; // [rsp+40h] [rbp-100h]
  signed int v27; // [rsp+44h] [rbp-FCh]
  signed int v28; // [rsp+48h] [rbp-F8h]
  unsigned int j; // [rsp+4Ch] [rbp-F4h]
  char *filename; // [rsp+50h] [rbp-F0h]
  size_t v31; // [rsp+58h] [rbp-E8h]
  void *ptr; // [rsp+60h] [rbp-E0h]
  DIR *dirp; // [rsp+68h] [rbp-D8h]
  void *v34; // [rsp+70h] [rbp-D0h]
  __int64 v35; // [rsp+78h] [rbp-C8h]
  size_t n; // [rsp+80h] [rbp-C0h]
  size_t v37; // [rsp+88h] [rbp-B8h]
  struct dirent *v38; // [rsp+90h] [rbp-B0h]
  size_t v39; // [rsp+98h] [rbp-A8h]
  struct stat stat_buf; // [rsp+A0h] [rbp-A0h]
  unsigned __int64 v41; // [rsp+138h] [rbp-8h]

  s = a3;
  s1 = (char *)a4;
  v21 = (_QWORD *)a5;
  v41 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_search_localfile", a4, a5, a6, a6);
  v31 = 0LL;
  v25 = 0;
  v26 = 1;
  filename = 0LL;
  dirp = 0LL;
  v34 = 0LL;
  v28 = 0;
  if ( !v21 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_search_localfile", v6);
    return 1LL;
  }
  v35 = ly_set_new(32LL);
  if ( !v35 )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_search_localfile", v8);
    return 1LL;
  }
  n = strlen(s);
  if ( a2 )
  {
    ptr = get_current_dir_name();
    if ( !ptr )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_search_localfile", v9);
      goto LABEL_61;
    }
    if ( (unsigned int)ly_set_add(v35, ptr, 0LL) == -1 )
      goto LABEL_61;
    v25 = 1;
  }
  if ( a1 )
  {
    for ( i = 0; ; ++i )
    {
      if ( !*(_QWORD *)(8LL * i + a1) )
        break;
      if ( v25 && !strcmp(**(const char ***)(v35 + 8), *(const char **)(8LL * i + a1)) )
      {
        v25 = 0;
      }
      else
      {
        ptr = strdup(*(const char **)(8LL * i + a1));
        if ( !ptr )
        {
          sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_search_localfile", v10);
          goto LABEL_61;
        }
        if ( (unsigned int)ly_set_add(v35, ptr, 0LL) == -1 )
          goto LABEL_61;
      }
    }
  }
  ptr = 0LL;
LABEL_57:
  while ( *(_DWORD *)(v35 + 4) )
  {
    free(ptr);
    free(filename);
    filename = 0LL;
    ptr = *(void **)(*(_QWORD *)(v35 + 8) + 8LL * (unsigned int)--*(_DWORD *)(v35 + 4));
    *(_QWORD *)(*(_QWORD *)(v35 + 8) + 8LL * *(unsigned int *)(v35 + 4)) = 0LL;
    sub_12222(0LL, 2u, 0, "Searching for \"%s\" in %s.", (__int64)s, (__int64)ptr);
    if ( dirp )
      closedir(dirp);
    dirp = opendir((const char *)ptr);
    v37 = strlen((const char *)ptr);
    if ( dirp )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          do
          {
            while ( 1 )
            {
              while ( 1 )
              {
                do
                {
                  v38 = readdir(dirp);
                  if ( !v38 )
                    goto LABEL_57;
                }
                while ( !strcmp(".", v38->d_name) || !strcmp("..", v38->d_name) );
                free(filename);
                if ( asprintf(&filename, "%s/%s", ptr, v38->d_name) == -1 )
                {
                  sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_search_localfile", v13);
                  goto LABEL_61;
                }
                if ( sub_107BF0(filename, &stat_buf) != -1 )
                  break;
                v14 = __errno_location();
                v15 = strerror(*v14);
                sub_12222(
                  0LL,
                  1u,
                  0,
                  "Unable to get information about \"%s\" file in \"%s\" when searching for (sub)modules (%s)",
                  (__int64)v38->d_name,
                  (__int64)ptr,
                  v15);
              }
              if ( (stat_buf.st_mode & 0xF000) != 0x4000 || !*(_DWORD *)(v35 + 4) && v25 )
                break;
              if ( (unsigned int)ly_set_add(v35, filename, 0LL) == -1 )
                goto LABEL_61;
              filename = 0LL;
            }
          }
          while ( (stat_buf.st_mode & 0xF000) != 0x8000
               || strncmp(s, v38->d_name, n)
               || v38->d_name[n] != 46 && v38->d_name[n] != 64 );
          v39 = strlen(v38->d_name);
          if ( strcmp((const char *)&v38->d_off + v39 + 7, ".yin") )
            break;
          v27 = 2;
LABEL_44:
          if ( s1 )
          {
            if ( v38->d_name[n] == 64 )
            {
              v19 = strlen(s1);
              if ( !strncmp(s1, &v38->d_name[n + 1], v19) )
              {
                free(v34);
                v34 = filename;
                filename = 0LL;
                v31 = v37 + n + 1;
                v28 = v27;
                goto LABEL_58;
              }
            }
            else
            {
              free(v34);
              v34 = filename;
              filename = 0LL;
              v31 = v37 + n + 1;
              v28 = v27;
            }
          }
          else
          {
            if ( !v34 )
              goto LABEL_55;
            if ( v38->d_name[n] == 64
              && !(unsigned int)sub_3C2C9(0LL, &v38->d_name[n + 1], n + 17, v16, v17, v18)
              && (*((_BYTE *)v34 + v31) != 64 || strncmp((const char *)v34 + v31 + 1, &v38->d_name[n + 1], 0xAuLL) < 0) )
            {
              free(v34);
LABEL_55:
              v34 = filename;
              filename = 0LL;
              v31 = v37 + n + 1;
              v28 = v27;
            }
          }
        }
        if ( !strcmp((const char *)&v38->d_off + v39 + 6, ".yang") )
        {
          v27 = 1;
          goto LABEL_44;
        }
      }
    }
    v11 = __errno_location();
    v12 = strerror(*v11);
    sub_12222(
      0LL,
      1u,
      0,
      "Unable to open directory \"%s\" for searching (sub)modules (%s).",
      (__int64)ptr,
      (__int64)v12);
  }
LABEL_58:
  *v21 = v34;
  v34 = 0LL;
  if ( v20 )
    *v20 = v28;
  v26 = 0;
LABEL_61:
  free(filename);
  free(ptr);
  if ( dirp )
    closedir(dirp);
  free(v34);
  for ( j = 0; j < *(_DWORD *)(v35 + 4); ++j )
    free(*(void **)(8LL * j + *(_QWORD *)(v35 + 8)));
  ly_set_free(v35);
  return v26;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009EAFC) ----------------------------------------------------
signed __int64 __fastcall sub_9EAFC(__int64 a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  unsigned int i; // [rsp+20h] [rbp-4h]

  for ( i = a3; i < a2; ++i )
  {
    if ( a4 == *(unsigned __int8 *)(*(_QWORD *)(8LL * i + a1) + 28LL) )
      return i;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000009EB54) ----------------------------------------------------
signed __int64 __fastcall sub_9EB54(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, void *a5, int a6, __int64 *a7, int a8, __int64 a9)
{
  signed __int64 result; // rax
  __int64 v10; // r9
  signed __int64 v11; // rdx
  void **v12; // rbx
  __int64 v13; // r9
  void **v14; // rbx
  __int64 v15; // r9
  void **v16; // rbx
  __int64 v17; // r9
  _QWORD *v18; // rax
  void *v19; // [rsp+8h] [rbp-68h]
  int v20; // [rsp+10h] [rbp-60h]
  unsigned __int8 v21; // [rsp+14h] [rbp-5Ch]
  __int64 v22; // [rsp+18h] [rbp-58h]
  void *v23; // [rsp+20h] [rbp-50h]
  __int64 v24; // [rsp+28h] [rbp-48h]
  unsigned __int8 i; // [rsp+3Bh] [rbp-35h]
  int v26; // [rsp+3Ch] [rbp-34h]
  void ***v27; // [rsp+40h] [rbp-30h]
  __int64 v28; // [rsp+48h] [rbp-28h]
  void *v29; // [rsp+50h] [rbp-20h]
  size_t size; // [rsp+58h] [rbp-18h]

  v24 = a1;
  v23 = (void *)a2;
  v22 = a3;
  v19 = a5;
  v20 = a6;
  v21 = a4;
  i = 0;
  if ( !a7 )
    __assert_fail("new", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x5FDu, "lys_ext_dup");
  if ( !a4 )
  {
    if ( v22 )
    {
      sub_12222(
        v24,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
        1537LL);
      result = 1LL;
    }
    else
    {
      *a7 = 0LL;
      result = 0LL;
    }
    return result;
  }
  v27 = (void ***)calloc(a4, 8uLL);
  *a7 = (__int64)v27;
  if ( !v27 )
  {
    sub_12222(v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_ext_dup", v10);
    return 1LL;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= v21 )
      return 0LL;
    if ( !*(_QWORD *)(8LL * i + v22) )
      break;
    v11 = 8LL * i;
    if ( *(_BYTE *)(*(_QWORD *)(v11 + v22) + 30LL) )
    {
      if ( *(_BYTE *)(*(_QWORD *)(v11 + v22) + 30LL) == 1 )
      {
        size = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(8LL * i + v22) + 56LL) + 48LL);
        v14 = (void **)&v27[i];
        *v14 = calloc(1uLL, size);
        if ( !v27[i] )
        {
          sub_12222(v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_ext_dup", v15);
          goto LABEL_32;
        }
        v27[i][8] = *(void **)(*(_QWORD *)(**(_QWORD **)(8LL * i + v22) + 56LL) + 40LL);
        memcpy(v27[i] + 8, (const void *)(*(_QWORD *)(8LL * i + v22) + 64LL), size - 64);
      }
    }
    else
    {
      v12 = (void **)&v27[i];
      *v12 = malloc(0x40uLL);
      if ( !v27[i] )
      {
        sub_12222(v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_ext_dup", v13);
        goto LABEL_32;
      }
    }
    *v27[i] = **(void ***)(8LL * i + v22);
    *((_WORD *)v27[i] + 12) = 4;
    v16 = v27[i];
    v16[2] = (void *)lydict_insert(v24, *(_QWORD *)(*(_QWORD *)(8LL * i + v22) + 16LL), 0LL);
    v27[i][1] = v19;
    *((_BYTE *)v27[i] + 29) = v20;
    *((_BYTE *)v27[i] + 28) = *(_BYTE *)(*(_QWORD *)(8LL * i + v22) + 28LL);
    *((_BYTE *)v27[i] + 27) = *(_BYTE *)(*(_QWORD *)(8LL * i + v22) + 27LL);
    *((_BYTE *)v27[i] + 30) = *(_BYTE *)(*(_QWORD *)(8LL * i + v22) + 30LL);
    v27[i][5] = 0LL;
    *((_DWORD *)v27[i] + 14) = 0x10000;
    v27[i][6] = v23;
    *((_BYTE *)v27[i] + 26) = *(_BYTE *)(*(_QWORD *)(8LL * i + v22) + 26LL);
    if ( (unsigned int)sub_9EB54(
                         v24,
                         (_DWORD)v23,
                         *(_QWORD *)(*(_QWORD *)(8LL * i + v22) + 32LL),
                         *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v22) + 26LL)) )
      goto LABEL_32;
    if ( a8 )
      v27[i][5] = *(void **)(*(_QWORD *)(8LL * i + v22) + 40LL);
LABEL_29:
    ;
  }
  v26 = sub_2B3F8(a9, -1, (__int64)&v22, 0x10000);
  if ( v26 == -1 )
  {
    sub_12222(
      v24,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
      1594LL);
    goto LABEL_32;
  }
  v28 = *(_QWORD *)(8LL * v26 + *(_QWORD *)(a9 + 16));
  v29 = malloc(0x30uLL);
  if ( v29 )
  {
    *((_DWORD *)v29 + 2) = *(_DWORD *)(v28 + 8);
    if ( *((_DWORD *)v29 + 2) == 2 )
    {
      v18 = sub_30929(v24, *(_QWORD *)v28, 0LL, 1u, 0);
      *(_QWORD *)v29 = v18;
    }
    *((_QWORD *)v29 + 2) = v19;
    *((_QWORD *)v29 + 3) = v23;
    *((_DWORD *)v29 + 8) = v20;
    *((_BYTE *)v29 + 41) = i;
    if ( (unsigned int)sub_2ABDE(*((__int64 **)v29 + 3), a9, a7, 0x10000u, (__int64 *)v29) == -1 )
      goto LABEL_32;
    goto LABEL_29;
  }
  sub_12222(v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_ext_dup", v17);
LABEL_32:
  *a7 = 0LL;
  sub_AAE3B(v24, v27, i, 0LL);
  return 1LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000009F26D) ----------------------------------------------------
_BYTE *__fastcall sub_9F26D(__int64 *a1, __int64 a2, int a3, unsigned int a4, __int64 a5)
{
  _BYTE *result; // rax
  __int64 v6; // r9
  __int64 v7; // [rsp+0h] [rbp-40h]
  unsigned __int64 v8; // [rsp+8h] [rbp-38h]
  int i; // [rsp+24h] [rbp-1Ch]
  _BYTE *v10; // [rsp+28h] [rbp-18h]

  v8 = __PAIR__(a3, a4);
  v7 = a5;
  if ( !a3 )
    return 0LL;
  v10 = calloc(a3, 0x38uLL);
  if ( v10 )
  {
    for ( i = 0; i < SHIDWORD(v8); ++i )
    {
      if ( (unsigned int)sub_2B3F8(v7, -1, 56LL * i + a2 + 40, 0x10000) == -1 )
      {
        v10[56 * i + 48] = *(_BYTE *)(56LL * i + a2 + 48);
        sub_9EB54(
          *a1,
          (__int64)a1,
          *(_QWORD *)(56LL * i + a2 + 40),
          *(_BYTE *)(56LL * i + a2 + 48),
          &v10[56 * i],
          7,
          (__int64 *)&v10[56 * i + 40],
          v8,
          v7);
      }
      *(_QWORD *)&v10[56 * i] = lydict_insert(*a1, *(_QWORD *)(56LL * i + a2), 0LL);
      *(_QWORD *)&v10[56 * i + 8] = lydict_insert(*a1, *(_QWORD *)(56LL * i + a2 + 8), 0LL);
      *(_QWORD *)&v10[56 * i + 16] = lydict_insert(*a1, *(_QWORD *)(56LL * i + a2 + 16), 0LL);
      *(_QWORD *)&v10[56 * i + 24] = lydict_insert(*a1, *(_QWORD *)(56LL * i + a2 + 24), 0LL);
      *(_QWORD *)&v10[56 * i + 32] = lydict_insert(*a1, *(_QWORD *)(56LL * i + a2 + 32), 0LL);
    }
    result = v10;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_restr_dup", v6, v7, v8);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000009F606) ----------------------------------------------------
__int64 __fastcall sub_9F606(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *))
{
  __int64 result; // rax

  if ( !a1 )
    __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x677u, "lys_restr_free");
  if ( a2 )
  {
    sub_AAE3B(a1, *(void ****)(a2 + 40), *(unsigned __int8 *)(a2 + 48), a3);
    lydict_remove(a1, *(_QWORD *)a2);
    lydict_remove(a1, *(_QWORD *)(a2 + 8));
    lydict_remove(a1, *(_QWORD *)(a2 + 16));
    lydict_remove(a1, *(_QWORD *)(a2 + 24));
    result = lydict_remove(a1, *(_QWORD *)(a2 + 32));
  }
  return result;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (000000000009F6E5) ----------------------------------------------------
void __fastcall lys_iffeature_free(__int64 a1, void ****a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void (__fastcall *v6)(void **, void *); // [rsp+0h] [rbp-30h]
  int v7; // [rsp+8h] [rbp-28h]
  unsigned __int8 v8; // [rsp+Ch] [rbp-24h]
  unsigned __int8 i; // [rsp+2Fh] [rbp-1h]

  v7 = a4;
  v8 = a3;
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_iffeature_free", a4, a5, a6, a5);
  for ( i = 0; i < v8; ++i )
  {
    sub_AAE3B(a1, a2[4 * i + 3], LOBYTE(a2[4 * i + 1]), v6);
    if ( !v7 )
    {
      free(a2[4 * i]);
      free(a2[4 * i + 2]);
    }
  }
  free(a2);
}
// 120FA0: using guessed type void *off_120FA0;

//----- (000000000009F7C7) ----------------------------------------------------
signed __int64 __fastcall sub_9F7C7(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, int a6, unsigned int a7, __int64 a8)
{
  __int64 v8; // r9
  _QWORD *v10; // rbx
  signed __int64 v11; // rbx
  signed __int64 v12; // rbx
  __int64 v13; // r9
  _QWORD *v14; // rbx
  signed __int64 v15; // rbx
  signed __int64 v16; // rbx
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // r9
  int v20; // [rsp+8h] [rbp-48h]
  __int64 v21; // [rsp+10h] [rbp-40h]
  __int64 v22; // [rsp+18h] [rbp-38h]
  int v23; // [rsp+38h] [rbp-18h]
  int v24; // [rsp+38h] [rbp-18h]
  unsigned int v25; // [rsp+3Ch] [rbp-14h]
  unsigned int v26; // [rsp+3Ch] [rbp-14h]
  unsigned int v27; // [rsp+3Ch] [rbp-14h]
  unsigned int v28; // [rsp+3Ch] [rbp-14h]

  v22 = a3;
  v21 = a4;
  v20 = a6;
  switch ( (unsigned __int64)a5 )
  {
    case 1uLL:
      if ( *(_QWORD *)(a4 + 32) )
        *(_QWORD *)(a3 + 32) = sub_9F26D(a1, *(_QWORD *)(a4 + 32), 1, a7, a8);
      return 0LL;
    case 2uLL:
      *(_DWORD *)(a3 + 40) = *(_DWORD *)(a4 + 40);
      if ( !*(_DWORD *)(a3 + 40) )
        return 0LL;
      *(_QWORD *)(a3 + 32) = calloc(*(unsigned int *)(a3 + 40), 0x30uLL);
      if ( !*(_QWORD *)(v22 + 32) )
      {
        sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"type_dup", v8);
        return 0xFFFFFFFFLL;
      }
      v25 = 0;
      while ( 2 )
      {
        if ( v25 >= *(_DWORD *)(v22 + 40) )
          return 0LL;
        v10 = (_QWORD *)(*(_QWORD *)(v22 + 32) + 48LL * v25);
        *v10 = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v25), 0LL);
        v11 = *(_QWORD *)(v22 + 32) + 48LL * v25;
        *(_QWORD *)(v11 + 8) = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v25 + 8), 0LL);
        v12 = *(_QWORD *)(v22 + 32) + 48LL * v25;
        *(_QWORD *)(v12 + 16) = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v25 + 16), 0LL);
        *(_WORD *)(*(_QWORD *)(v22 + 32) + 48LL * v25 + 24) = *(_WORD *)(48LL * v25 + *(_QWORD *)(v21 + 32) + 24);
        *(_DWORD *)(*(_QWORD *)(v22 + 32) + 48LL * v25 + 28) = *(_DWORD *)(48LL * v25 + *(_QWORD *)(v21 + 32) + 28);
        *(_BYTE *)(*(_QWORD *)(v22 + 32) + 48LL * v25 + 26) = *(_BYTE *)(48LL * v25 + *(_QWORD *)(v21 + 32) + 26);
        if ( !(unsigned int)sub_9EB54(
                              *a1,
                              (__int64)a1,
                              *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v25 + 32),
                              *(_BYTE *)(*(_QWORD *)(v21 + 32) + 48LL * v25 + 26),
                              (void *)(*(_QWORD *)(v22 + 32) + 48LL * v25),
                              4,
                              (__int64 *)(*(_QWORD *)(v22 + 32) + 48LL * v25 + 32),
                              a7,
                              a8) )
        {
          ++v25;
          continue;
        }
        break;
      }
      return 0xFFFFFFFFLL;
    case 4uLL:
      *(_BYTE *)(a3 + 40) = *(_BYTE *)(a4 + 40);
      *(_QWORD *)(a3 + 48) = *(_QWORD *)(a4 + 48);
      if ( *(_QWORD *)(a4 + 32) )
        *(_QWORD *)(a3 + 32) = sub_9F26D(a1, *(_QWORD *)(a4 + 32), 1, a7, a8);
      return 0LL;
    case 6uLL:
      *(_DWORD *)(a3 + 40) = *(_DWORD *)(a4 + 40);
      if ( !*(_DWORD *)(a3 + 40) )
        return 0LL;
      *(_QWORD *)(a3 + 32) = calloc(*(unsigned int *)(a3 + 40), 0x30uLL);
      if ( !*(_QWORD *)(v22 + 32) )
      {
        sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"type_dup", v13);
        return 0xFFFFFFFFLL;
      }
      v26 = 0;
      while ( 2 )
      {
        if ( v26 >= *(_DWORD *)(v22 + 40) )
          return 0LL;
        v14 = (_QWORD *)(*(_QWORD *)(v22 + 32) + 48LL * v26);
        *v14 = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v26), 0LL);
        v15 = *(_QWORD *)(v22 + 32) + 48LL * v26;
        *(_QWORD *)(v15 + 8) = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v26 + 8), 0LL);
        v16 = *(_QWORD *)(v22 + 32) + 48LL * v26;
        *(_QWORD *)(v16 + 16) = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v26 + 16), 0LL);
        *(_WORD *)(*(_QWORD *)(v22 + 32) + 48LL * v26 + 24) = *(_WORD *)(48LL * v26 + *(_QWORD *)(v21 + 32) + 24);
        *(_DWORD *)(*(_QWORD *)(v22 + 32) + 48LL * v26 + 28) = *(_DWORD *)(48LL * v26 + *(_QWORD *)(v21 + 32) + 28);
        *(_BYTE *)(*(_QWORD *)(v22 + 32) + 48LL * v26 + 26) = *(_BYTE *)(48LL * v26 + *(_QWORD *)(v21 + 32) + 26);
        if ( !(unsigned int)sub_9EB54(
                              *a1,
                              (__int64)a1,
                              *(_QWORD *)(*(_QWORD *)(v21 + 32) + 48LL * v26 + 32),
                              *(_BYTE *)(*(_QWORD *)(v21 + 32) + 48LL * v26 + 26),
                              (void *)(*(_QWORD *)(v22 + 32) + 48LL * v26),
                              5,
                              (__int64 *)(*(_QWORD *)(v22 + 32) + 48LL * v26 + 32),
                              a7,
                              a8) )
        {
          ++v26;
          continue;
        }
        break;
      }
      return 0xFFFFFFFFLL;
    case 7uLL:
      *(_DWORD *)(a3 + 40) = *(_DWORD *)(a4 + 40);
      if ( *(_DWORD *)(a4 + 40) )
      {
        *(_QWORD *)(a3 + 32) = malloc(8LL * *(unsigned int *)(a4 + 40));
        if ( !*(_QWORD *)(v22 + 32) )
        {
          sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"type_dup", v17);
          return 0xFFFFFFFFLL;
        }
        memcpy(*(void **)(v22 + 32), *(const void **)(v21 + 32), 8LL * *(unsigned int *)(v21 + 40));
      }
      else
      {
        v23 = -1;
        do
        {
          v24 = sub_2B3F8(a8, v23, v21, 512);
          if ( v24 != -1
            && (unsigned int)sub_2AB62(a1, a8, (__int64 *)v22, 0x200u, *(_QWORD *)(8LL * v24 + *(_QWORD *)(a8 + 16))) == -1 )
          {
            return 0xFFFFFFFFLL;
          }
          v23 = v24 - 1;
        }
        while ( v23 >= 0 );
      }
      return 0LL;
    case 8uLL:
      *(_BYTE *)(a3 + 32) = *(_BYTE *)(a4 + 32);
      return 0LL;
    case 9uLL:
      if ( !*(_QWORD *)(a4 + 32) )
        return 0LL;
      *(_QWORD *)(a3 + 32) = lydict_insert(*a1, *(_QWORD *)(a4 + 32), 0LL);
      *(_BYTE *)(v22 + 48) = *(_BYTE *)(v21 + 48);
      if ( v20 || (unsigned int)sub_2ABDE(a1, a8, (__int64 *)v22, 0x20u, a2) != -1 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0xAuLL:
      if ( *(_QWORD *)(a4 + 32) )
        *(_QWORD *)(a3 + 32) = sub_9F26D(a1, *(_QWORD *)(a4 + 32), 1, a7, a8);
      if ( !*(_DWORD *)(v21 + 48) )
        return 0LL;
      *(_QWORD *)(v22 + 40) = sub_9F26D(a1, *(_QWORD *)(v21 + 40), *(_DWORD *)(v21 + 48), a7, a8);
      *(_DWORD *)(v22 + 48) = *(_DWORD *)(v21 + 48);
      if ( v20 )
        return 0LL;
      *(_QWORD *)(v22 + 56) = malloc(8LL * (unsigned int)(2 * *(_DWORD *)(v22 + 48)));
      if ( !*(_QWORD *)(v22 + 56) )
      {
        sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"type_dup", v18);
        return 0xFFFFFFFFLL;
      }
      v27 = 0;
      while ( 2 )
      {
        if ( v27 >= *(_DWORD *)(v22 + 48) )
          return 0LL;
        if ( !(unsigned int)sub_372F0(
                              (void *)*a1,
                              (const char *)(*(_QWORD *)(*(_QWORD *)(v22 + 40) + 56LL * v27) + 1LL),
                              (void **)(*(_QWORD *)(v22 + 56) + 16LL * v27),
                              (_QWORD *)(*(_QWORD *)(v22 + 56) + 8LL * (2 * v27 + 1))) )
        {
          ++v27;
          continue;
        }
        break;
      }
      free(*(void **)(v22 + 56));
      *(_QWORD *)(v22 + 56) = 0LL;
      return 0xFFFFFFFFLL;
    case 0xBuLL:
      *(_DWORD *)(a3 + 44) = *(_DWORD *)(a4 + 44);
      *(_DWORD *)(a3 + 40) = *(_DWORD *)(a4 + 40);
      if ( !*(_DWORD *)(a3 + 40) )
        return 0LL;
      *(_QWORD *)(a3 + 32) = calloc(*(unsigned int *)(a3 + 40), 0x40uLL);
      if ( !*(_QWORD *)(v22 + 32) )
      {
        sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"type_dup", v19);
        return 0xFFFFFFFFLL;
      }
      v28 = 0;
      break;
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
      if ( *(_QWORD *)(a4 + 32) )
        *(_QWORD *)(a3 + 32) = sub_9F26D(a1, *(_QWORD *)(a4 + 32), 1, a7, a8);
      return 0LL;
    default:
      return 0LL;
  }
  while ( v28 < *(_DWORD *)(v22 + 40) )
  {
    if ( (unsigned int)sub_A1481(
                         a1,
                         a2,
                         *(_QWORD *)(v22 + 32) + ((unsigned __int64)v28 << 6),
                         *(_QWORD *)(v21 + 32) + ((unsigned __int64)v28 << 6),
                         v20,
                         a7,
                         a8) )
      return 0xFFFFFFFFLL;
    ++v28;
  }
  return 0LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000A03B6) ----------------------------------------------------
void *__fastcall sub_A03B6(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, int a5, unsigned int a6, __int64 a7)
{
  __int64 v7; // r9
  __int64 v9; // r9
  unsigned int v10; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+Ch] [rbp-34h]
  __int64 v12; // [rsp+10h] [rbp-30h]
  __int64 v13; // [rsp+18h] [rbp-28h]
  void *ptr; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  ptr = calloc(1uLL, 0x18uLL);
  if ( !ptr )
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_yang_type_dup", v7);
    return 0LL;
  }
  *(_BYTE *)ptr = *(_BYTE *)v13;
  *((_DWORD *)ptr + 1) = *(_DWORD *)(v13 + 4);
  *((_QWORD *)ptr + 1) = lydict_insert(*a1, *(_QWORD *)(v13 + 8), 0LL);
  *((_QWORD *)ptr + 2) = v12;
  if ( *((_QWORD *)ptr + 1) )
  {
    if ( !(unsigned int)sub_9F7C7(a1, a2, v12, *(_QWORD *)(v13 + 16), *((_DWORD *)ptr + 1), v11, v10, a7) )
      return ptr;
    **((_DWORD **)ptr + 2) = *((_DWORD *)ptr + 1);
    sub_A1648(*a1, *((_QWORD *)ptr + 2), 0LL);
    memset((void *)(*((_QWORD *)ptr + 2) + 32LL), 0, 0x20uLL);
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_yang_type_dup", v9);
  }
  free(ptr);
  return 0LL;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000A0555) ----------------------------------------------------
signed __int64 __fastcall sub_A0555(__int64 *a1, __int64 *a2, void *a3, int *a4, __int64 a5)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // [rsp+8h] [rbp-98h]
  int *v9; // [rsp+10h] [rbp-90h]
  void *dest; // [rsp+18h] [rbp-88h]
  unsigned __int8 v11; // [rsp+37h] [rbp-69h]
  unsigned int i; // [rsp+38h] [rbp-68h]
  signed int v13; // [rsp+3Ch] [rbp-64h]
  void *src; // [rsp+40h] [rbp-60h]
  void *v15; // [rsp+48h] [rbp-58h]
  int s; // [rsp+50h] [rbp-50h]
  __int64 *v17; // [rsp+68h] [rbp-38h]
  unsigned __int64 v18; // [rsp+98h] [rbp-8h]

  dest = a3;
  v9 = a4;
  v8 = a5;
  v18 = __readfsqword(0x28u);
  if ( a4 )
  {
    v13 = 0;
  }
  else
  {
    v13 = 1;
    memset(&s, 0, 0x40uLL);
    s = *(_DWORD *)dest;
    v17 = a2;
    v9 = &s;
  }
  if ( !*((_QWORD *)dest + 2) )
    __assert_fail(
      "type->der",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0x76Fu,
      "lys_copy_union_leafrefs");
  if ( *(_QWORD *)(*((_QWORD *)dest + 2) + 48LL) )
  {
    v11 = *((_BYTE *)dest + 5);
    if ( (unsigned int)sub_9EB54(
                         *a1,
                         (__int64)a1,
                         *((_QWORD *)dest + 1),
                         *((_BYTE *)dest + 5),
                         v9,
                         3,
                         (__int64 *)&src,
                         0,
                         v8) )
      return 0xFFFFFFFFLL;
    if ( *((_QWORD *)v9 + 1) )
    {
      v15 = realloc(*((void **)v9 + 1), 8LL * (*((unsigned __int8 *)v9 + 5) + v11));
      if ( !v15 )
      {
        sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_copy_union_leafrefs", v6);
        return 0xFFFFFFFFLL;
      }
      *((_QWORD *)v9 + 1) = v15;
      memcpy((void *)(8LL * *((unsigned __int8 *)v9 + 5) + *((_QWORD *)v9 + 1)), src, 8LL * v11);
      free(src);
      *((_BYTE *)v9 + 5) += v11;
    }
    else
    {
      *((_QWORD *)v9 + 1) = src;
      *((_BYTE *)v9 + 5) = v11;
    }
    if ( (unsigned int)sub_A0555(a1, a2, *((_QWORD *)dest + 2) + 56LL, v9, v8) )
      return 0xFFFFFFFFLL;
  }
  else if ( *(_DWORD *)dest == 11 )
  {
    v9[11] = *((_DWORD *)dest + 11);
    v9[10] = *((_DWORD *)dest + 10);
    if ( !v9[10] )
      __assert_fail(
        "prev_new->info.uni.count",
        "/home/mantovan/Repositories/libyang/src/tree_schema.c",
        0x78Eu,
        "lys_copy_union_leafrefs");
    *((_QWORD *)v9 + 4) = calloc((unsigned int)v9[10], 0x40uLL);
    if ( !*((_QWORD *)v9 + 4) )
    {
      sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_copy_union_leafrefs", v7);
      return 0xFFFFFFFFLL;
    }
    for ( i = 0; i < v9[10]; ++i )
    {
      if ( (unsigned int)sub_A0555(
                           a1,
                           a2,
                           *((_QWORD *)dest + 4) + ((unsigned __int64)i << 6),
                           *((_QWORD *)v9 + 4) + ((unsigned __int64)i << 6),
                           v8) )
        return 0xFFFFFFFFLL;
    }
    *((_QWORD *)v9 + 2) = *((_QWORD *)dest + 2);
  }
  else if ( (unsigned int)sub_A1481(a1, a2, (__int64)v9, (__int64)dest, 0, 0, v8) )
  {
    return 0xFFFFFFFFLL;
  }
  if ( v13 )
    memcpy(dest, v9, 0x40uLL);
  return 0LL;
}

//----- (00000000000A09CE) ----------------------------------------------------
signed __int64 __fastcall lys_ext_instance_substmt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  int v7; // eax

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_ext_instance_substmt", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  switch ( *(unsigned __int8 *)(a1 + 28) )
  {
    case 0u:
    case 0x13u:
    case 0x14u:
      result = 0LL;
      break;
    case 1u:
      if ( *(_BYTE *)(a1 + 29) != 10 )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
      break;
    case 2u:
      if ( *(_BYTE *)(a1 + 29) == 3 )
      {
        result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL) + 8LL * *(unsigned __int8 *)(a1 + 27));
      }
      else
      {
        if ( *(_BYTE *)(a1 + 29) != 9 )
          goto LABEL_140;
        result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 56LL) + 8LL * *(unsigned __int8 *)(a1 + 27));
      }
      break;
    case 3u:
      if ( *(_BYTE *)(a1 + 29) || !(*(_BYTE *)(*(_QWORD *)(a1 + 8) + 64LL) & 1) )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 168LL);
      break;
    case 4u:
      if ( *(_BYTE *)(a1 + 29) )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL);
      break;
    case 5u:
      switch ( *(_BYTE *)(a1 + 29) )
      {
        case 1:
          v7 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL);
          if ( v7 == 4 || v7 == 8 )
          {
            result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 200LL) + 8LL * *(unsigned __int8 *)(a1 + 27));
          }
          else
          {
            if ( v7 != 2 )
              goto LABEL_140;
            result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL);
          }
          break;
        case 2:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120LL);
          break;
        case 0xE:
          result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 56LL) + 8LL * *(unsigned __int8 *)(a1 + 27));
          break;
        case 0xC:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 64LL) + 8LL * *(unsigned __int8 *)(a1 + 27);
          break;
        default:
          goto LABEL_140;
      }
      break;
    case 6u:
      switch ( *(unsigned __int8 *)(a1 + 29) )
      {
        case 0u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL);
          break;
        case 1u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 2u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 4u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 5u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 6u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 7u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 8u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 9u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 0xAu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 0xCu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 0xDu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
          break;
        case 0xFu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL);
          break;
        case 0x10u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
          break;
        case 0x11u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL);
          break;
        default:
          goto LABEL_140;
      }
      break;
    case 7u:
      if ( *(_BYTE *)(a1 + 29) != 7 )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL);
      break;
    case 8u:
      if ( *(_BYTE *)(a1 + 29) != 7 )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
      break;
    case 9u:
      if ( *(_BYTE *)(a1 + 29) != 1 || *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) != 16 )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136LL);
      break;
    case 0xAu:
      if ( *(_BYTE *)(a1 + 29) || *(_BYTE *)(*(_QWORD *)(a1 + 8) + 64LL) & 1 )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 176LL);
      break;
    case 0xBu:
      if ( *(_BYTE *)(a1 + 29) )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL);
      break;
    case 0xCu:
      if ( *(_BYTE *)(a1 + 29) != 3 || **(_DWORD **)(a1 + 8) != 9 )
        goto LABEL_140;
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
      break;
    case 0xDu:
      if ( *(_BYTE *)(a1 + 29) )
      {
        if ( *(_BYTE *)(a1 + 29) != 15 )
          goto LABEL_140;
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
      }
      else
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
      }
      break;
    case 0xEu:
      if ( *(_BYTE *)(a1 + 29) != 1 || *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) != 1 )
      {
        if ( *(_BYTE *)(a1 + 29) != 12 )
          goto LABEL_140;
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 72LL);
      }
      else
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136LL);
      }
      break;
    case 0xFu:
      switch ( *(unsigned __int8 *)(a1 + 29) )
      {
        case 0u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
          break;
        case 1u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 2u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 4u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 5u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 6u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 7u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 8u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 9u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 0xAu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 0xCu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 0xDu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
          break;
        case 0xFu:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL);
          break;
        case 0x10u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL);
          break;
        case 0x11u:
          result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
          break;
        default:
          goto LABEL_140;
      }
      break;
    case 0x10u:
      if ( *(_BYTE *)(a1 + 29) == 15 )
      {
        result = *(_QWORD *)(a1 + 8) + 16LL;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 29) != 16 )
          goto LABEL_140;
        result = *(_QWORD *)(a1 + 8) + 8LL;
      }
      break;
    case 0x11u:
      if ( *(_BYTE *)(a1 + 29) == 1 && *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) & 0xC )
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 192LL);
      }
      else if ( *(_BYTE *)(a1 + 29) == 2 )
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL);
      }
      else
      {
        if ( *(_BYTE *)(a1 + 29) != 14 )
          goto LABEL_140;
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL);
      }
      break;
    case 0x12u:
      if ( *(_BYTE *)(a1 + 29) != 5 )
        goto LABEL_140;
      result = *(_QWORD *)(a1 + 8) + 28LL;
      break;
    case 0x15u:
      if ( *(_BYTE *)(a1 + 29) != 3 )
        goto LABEL_140;
      if ( **(_DWORD **)(a1 + 8) == 9 )
      {
        result = *(_QWORD *)(a1 + 8) + 48LL;
      }
      else
      {
        if ( **(_DWORD **)(a1 + 8) != 8 )
          goto LABEL_140;
        result = *(_QWORD *)(a1 + 8) + 32LL;
      }
      break;
    case 0x16u:
      if ( *(_BYTE *)(a1 + 29) != 10 )
        goto LABEL_140;
      result = *(_QWORD *)(a1 + 8) + 24LL;
      break;
    case 0x17u:
    case 0x18u:
      switch ( *(_BYTE *)(a1 + 29) )
      {
        case 1:
          result = *(_QWORD *)(a1 + 8) + 24LL;
          break;
        case 0xE:
          result = *(_QWORD *)(a1 + 8) + 4LL;
          break;
        case 0xC:
          result = *(_QWORD *)(a1 + 8) + 24LL;
          break;
        default:
          goto LABEL_140;
      }
      break;
    case 0x19u:
      if ( *(_BYTE *)(a1 + 29) != 1 || !(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) & 0x18) )
        goto LABEL_140;
      result = *(_QWORD *)(a1 + 8) + 24LL;
      break;
    case 0x1Au:
      switch ( *(unsigned __int8 *)(a1 + 29) )
      {
        case 1u:
        case 2u:
        case 4u:
        case 5u:
        case 6u:
        case 9u:
        case 0xAu:
          result = *(_QWORD *)(a1 + 8) + 24LL;
          break;
        default:
          goto LABEL_140;
      }
      break;
    case 0x1Bu:
      if ( *(_BYTE *)(a1 + 29) != 3 || **(_DWORD **)(a1 + 8) != 4 )
        goto LABEL_140;
      result = *(_QWORD *)(a1 + 8) + 40LL;
      break;
    case 0x1Cu:
      if ( *(_BYTE *)(a1 + 29) == 1 )
      {
        if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) == 16 )
        {
          result = *(_QWORD *)(a1 + 8) + 156LL;
        }
        else
        {
          if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) != 8 )
            goto LABEL_140;
          result = *(_QWORD *)(a1 + 8) + 212LL;
        }
      }
      else
      {
        if ( *(_BYTE *)(a1 + 29) != 12 )
          goto LABEL_140;
        result = *(_QWORD *)(a1 + 8) + 76LL;
      }
      break;
    case 0x1Du:
      if ( *(_BYTE *)(a1 + 29) == 1 )
      {
        if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) == 16 )
        {
          result = *(_QWORD *)(a1 + 8) + 152LL;
        }
        else
        {
          if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) != 8 )
            goto LABEL_140;
          result = *(_QWORD *)(a1 + 8) + 208LL;
        }
      }
      else
      {
        if ( *(_BYTE *)(a1 + 29) != 12 )
          goto LABEL_140;
        result = *(_QWORD *)(a1 + 8) + 72LL;
      }
      break;
    case 0x1Eu:
      if ( *(_BYTE *)(a1 + 29) != 4 )
        goto LABEL_140;
      result = *(_QWORD *)(a1 + 8) + 28LL;
      break;
    case 0x1Fu:
      if ( *(_BYTE *)(a1 + 29) == 14 )
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL) + 16LL * *(unsigned __int8 *)(a1 + 27);
      }
      else
      {
        if ( *(_BYTE *)(a1 + 29) != 1 || *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56LL) != 16 )
          goto LABEL_140;
        result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 144LL) + 16LL * *(unsigned __int8 *)(a1 + 27);
      }
      break;
    default:
LABEL_140:
      sub_12222(
        **(_QWORD **)(a1 + 48),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
        2244LL);
      result = 0LL;
      break;
  }
  return result;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A1481) ----------------------------------------------------
signed __int64 __fastcall sub_A1481(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, int a5, int a6, __int64 a7)
{
  signed __int64 result; // rax
  unsigned int v8; // [rsp+10h] [rbp-38h]
  int v9; // [rsp+14h] [rbp-34h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 *v11; // [rsp+20h] [rbp-28h]

  v11 = (__int64 *)a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  *(_DWORD *)a3 = *(_DWORD *)a4;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a3 + 24) = a2;
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a4 + 5);
  if ( (unsigned int)sub_9EB54(*a1, (__int64)a1, *(_QWORD *)(v10 + 8), *(_BYTE *)(v10 + 5), v11, 3, v11 + 1, a6, a7) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_2B3F8(a7, -1, v10, 4) == -1 )
    return sub_9F7C7(a1, a2, (__int64)v11, v10, *(_DWORD *)v11, v9, v8, a7);
  if ( **(_BYTE **)(v10 + 16) >= 0 )
    v11[2] = (__int64)sub_30929(*a1, *(_QWORD *)(v10 + 16), 0LL, 1u, 0);
  else
    v11[2] = (__int64)sub_A03B6(a1, a2, *(_QWORD *)(v10 + 16), (__int64)v11, v9, v8, a7);
  if ( v11[2] && (unsigned int)sub_2ABDE(a1, a7, v11, 4u, a2) != -1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}

//----- (00000000000A1648) ----------------------------------------------------
void __fastcall sub_A1648(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *))
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]
  unsigned int j; // [rsp+2Ch] [rbp-4h]
  unsigned int k; // [rsp+2Ch] [rbp-4h]
  unsigned int l; // [rsp+2Ch] [rbp-4h]

  v3 = a3;
  if ( !a1 )
    __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x8F0u, "lys_type_free");
  if ( a2 )
  {
    sub_AAE3B(a1, *(void ****)(a2 + 8), *(unsigned __int8 *)(a2 + 5), a3);
    switch ( *(_DWORD *)a2 )
    {
      case 1:
        sub_9F606(a1, *(_QWORD *)(a2 + 32), v3);
        free(*(void **)(a2 + 32));
        break;
      case 2:
        for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
        {
          lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i));
          lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 8));
          lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 16));
          lys_iffeature_free(
            a1,
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 40),
            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * i + 27),
            0LL,
            v3);
          sub_AAE3B(
            a1,
            *(void ****)(*(_QWORD *)(a2 + 32) + 48LL * i + 32),
            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * i + 26),
            v3);
        }
        free(*(void **)(a2 + 32));
        break;
      case 4:
        sub_9F606(a1, *(_QWORD *)(a2 + 32), v3);
        free(*(void **)(a2 + 32));
        break;
      case 6:
        for ( j = 0; j < *(_DWORD *)(a2 + 40); ++j )
        {
          lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * j));
          lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * j + 8));
          lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * j + 16));
          lys_iffeature_free(
            a1,
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * j + 40),
            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * j + 27),
            0LL,
            v3);
          sub_AAE3B(
            a1,
            *(void ****)(*(_QWORD *)(a2 + 32) + 48LL * j + 32),
            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * j + 26),
            v3);
        }
        free(*(void **)(a2 + 32));
        break;
      case 7:
        free(*(void **)(a2 + 32));
        break;
      case 9:
        lydict_remove(a1, *(_QWORD *)(a2 + 32));
        break;
      case 0xA:
        sub_9F606(a1, *(_QWORD *)(a2 + 32), v3);
        free(*(void **)(a2 + 32));
        for ( k = 0; k < *(_DWORD *)(a2 + 48); ++k )
        {
          sub_9F606(a1, 56LL * k + *(_QWORD *)(a2 + 40), v3);
          if ( *(_QWORD *)(a2 + 56) )
          {
            pcre_free(*(_QWORD *)(16LL * k + *(_QWORD *)(a2 + 56)));
            pcre_free_study(*(_QWORD *)(8LL * (2 * k + 1) + *(_QWORD *)(a2 + 56)));
          }
        }
        free(*(void **)(a2 + 40));
        free(*(void **)(a2 + 56));
        break;
      case 0xB:
        for ( l = 0; l < *(_DWORD *)(a2 + 40); ++l )
          sub_A1648(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)l << 6), v3);
        free(*(void **)(a2 + 32));
        break;
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
        sub_9F606(a1, *(_QWORD *)(a2 + 32), v3);
        free(*(void **)(a2 + 32));
        break;
      default:
        return;
    }
  }
}
// 78E0: using guessed type __int64 __fastcall pcre_free_study(_QWORD);
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 347390: using guessed type __int64 (__fastcall *pcre_free)(_QWORD);

//----- (00000000000A1BCA) ----------------------------------------------------
void __fastcall sub_A1BCA(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *))
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-18h]

  v3 = a3;
  if ( !a1 )
    __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x952u, "lys_tpdf_free");
  if ( a2 )
  {
    lydict_remove(a1, *(_QWORD *)a2);
    lydict_remove(a1, *(_QWORD *)(a2 + 8));
    lydict_remove(a1, *(_QWORD *)(a2 + 16));
    sub_A1648(a1, a2 + 56, v3);
    lydict_remove(a1, *(_QWORD *)(a2 + 40));
    lydict_remove(a1, *(_QWORD *)(a2 + 120));
    sub_AAE3B(a1, *(void ****)(a2 + 32), *(unsigned __int8 *)(a2 + 26), v3);
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A1CC4) ----------------------------------------------------
__int64 *__fastcall sub_A1CC4(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  __int64 *result; // rax
  __int64 v5; // r9
  __int64 v6; // [rsp+0h] [rbp-30h]
  int v7; // [rsp+Ch] [rbp-24h]
  __int64 *v8; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  if ( !a2 )
    return 0LL;
  v8 = (__int64 *)calloc(1uLL, 0x28uLL);
  if ( v8 )
  {
    *v8 = lydict_insert(*a1, *(_QWORD *)a2, 0LL);
    v8[1] = lydict_insert(*a1, *(_QWORD *)(a2 + 8), 0LL);
    v8[2] = lydict_insert(*a1, *(_QWORD *)(a2 + 16), 0LL);
    *((_BYTE *)v8 + 32) = *(_BYTE *)(a2 + 32);
    sub_9EB54(*a1, (__int64)a1, *(_QWORD *)(a2 + 24), *(_BYTE *)(a2 + 32), v8, 8, v8 + 3, v7, v6);
    result = v8;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_when_dup", v5, v6);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000A1E16) ----------------------------------------------------
void __fastcall sub_A1E16(__int64 a1, _QWORD *a2, __int64 a3)
{
  if ( a2 )
  {
    sub_AAE3B(a1, (void ***)a2[3], *((unsigned __int8 *)a2 + 32), (void (__fastcall *)(void **, void *))a3);
    lydict_remove(a1, *a2);
    lydict_remove(a1, a2[1]);
    lydict_remove(a1, a2[2]);
    free(a2);
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A1EA9) ----------------------------------------------------
void __fastcall sub_A1EA9(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // al
  void (__fastcall *v4)(void **, void *); // [rsp+8h] [rbp-28h]
  __int64 v5; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v4 = (void (__fastcall *)(void **, void *))a3;
  if ( !*(_QWORD *)(a2 + 88) || *(_WORD *)(a2 + 24) & 1 )
  {
    for ( i = *(_QWORD *)(a2 + 72); ; i = v5 )
    {
      if ( i )
      {
        v5 = *(_QWORD *)(i + 80);
        v3 = 1;
      }
      else
      {
        v3 = 0;
      }
      if ( !v3 )
        break;
      sub_A33A0((_QWORD **)i, (void (__fastcall *)(_QWORD **, _QWORD *))v4, 0);
    }
  }
  lydict_remove(a1, *(_QWORD *)a2);
  lydict_remove(a1, *(_QWORD *)(a2 + 8));
  lydict_remove(a1, *(_QWORD *)(a2 + 16));
  lys_iffeature_free(a1, *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v4);
  sub_AAE3B(a1, *(void ****)(a2 + 32), *(unsigned __int8 *)(a2 + 26), v4);
  sub_A1E16(a1, *(_QWORD **)(a2 + 80), (__int64)v4);
}
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A1FDD) ----------------------------------------------------
void __fastcall sub_A1FDD(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *))
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-18h]

  v3 = a3;
  if ( !a1 )
    __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x9A2u, "lys_ident_free");
  if ( a2 )
  {
    free(*(void **)(a2 + 56));
    ly_set_free(*(_QWORD *)(a2 + 64));
    lydict_remove(a1, *(_QWORD *)a2);
    lydict_remove(a1, *(_QWORD *)(a2 + 8));
    lydict_remove(a1, *(_QWORD *)(a2 + 16));
    lys_iffeature_free(a1, *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v3);
    sub_AAE3B(a1, *(void ****)(a2 + 32), *(unsigned __int8 *)(a2 + 26), v3);
  }
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A20D9) ----------------------------------------------------
void __fastcall sub_A20D9(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  for ( i = 0; i < *(unsigned __int16 *)(a2 + 30); ++i )
    sub_A1BCA(a1, *(_QWORD *)(a2 + 104) + ((signed __int64)i << 7), v3);
  free(*(void **)(a2 + 104));
}

//----- (00000000000A2146) ----------------------------------------------------
void __fastcall sub_A2146(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  for ( i = 0; i < *(unsigned __int16 *)(a2 + 30); ++i )
    sub_A1BCA(a1, *(_QWORD *)(a2 + 112) + ((signed __int64)i << 7), v3);
  free(*(void **)(a2 + 112));
}

//----- (00000000000A21B3) ----------------------------------------------------
void __fastcall sub_A21B3(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]
  signed int j; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  for ( i = 0; i < *(unsigned __int16 *)(a2 + 30); ++i )
    sub_A1BCA(a1, *(_QWORD *)(a2 + 104) + ((signed __int64)i << 7), v3);
  free(*(void **)(a2 + 104));
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 29); ++j )
    sub_9F606(a1, 56LL * j + *(_QWORD *)(a2 + 112), v3);
  free(*(void **)(a2 + 112));
}

//----- (00000000000A227F) ----------------------------------------------------
void __fastcall sub_A227F(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]
  signed int j; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 29); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), v3);
  free(*(void **)(a2 + 120));
  for ( j = 0; j < *(unsigned __int16 *)(a2 + 30); ++j )
    sub_A1BCA(a1, *(_QWORD *)(a2 + 112) + ((signed __int64)j << 7), v3);
  free(*(void **)(a2 + 112));
}

//----- (00000000000A234B) ----------------------------------------------------
void __fastcall sub_A234B(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 31); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), v3);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), (__int64)v3);
}

//----- (00000000000A23DC) ----------------------------------------------------
__int64 __fastcall sub_A23DC(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v4)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v4 = (void (__fastcall *)(void **, void *))a3;
  ly_set_free(*(_QWORD *)(a2 + 72));
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 31); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), v4);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), (__int64)v4);
  sub_A1648(a1, a2 + 128, v4);
  lydict_remove(a1, *(_QWORD *)(a2 + 192));
  return lydict_remove(a1, *(_QWORD *)(a2 + 200));
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A24CF) ----------------------------------------------------
__int64 __fastcall sub_A24CF(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v4)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]
  signed int j; // [rsp+2Ch] [rbp-4h]

  v4 = (void (__fastcall *)(void **, void *))a3;
  if ( *(_QWORD *)(a2 + 72) )
    ly_set_free(*(_QWORD *)(a2 + 72));
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 31); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), v4);
  free(*(void **)(a2 + 120));
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 30); ++j )
    lydict_remove(a1, *(_QWORD *)(8LL * j + *(_QWORD *)(a2 + 200)));
  free(*(void **)(a2 + 200));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), (__int64)v4);
  sub_A1648(a1, a2 + 128, v4);
  return lydict_remove(a1, *(_QWORD *)(a2 + 192));
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A260F) ----------------------------------------------------
__int64 __fastcall sub_A260F(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v4)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+28h] [rbp-8h]
  signed int j; // [rsp+28h] [rbp-8h]
  signed int k; // [rsp+28h] [rbp-8h]
  signed int l; // [rsp+2Ch] [rbp-4h]

  v4 = (void (__fastcall *)(void **, void *))a3;
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), a3);
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 28); ++i )
    sub_9F606(a1, 56LL * i + *(_QWORD *)(a2 + 120), v4);
  free(*(void **)(a2 + 120));
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 29); ++j )
    sub_A1BCA(a1, *(_QWORD *)(a2 + 128) + ((signed __int64)j << 7), v4);
  free(*(void **)(a2 + 128));
  free(*(void **)(a2 + 136));
  for ( k = 0; k < *(unsigned __int8 *)(a2 + 31); ++k )
  {
    for ( l = 0; l < *(unsigned __int8 *)(16LL * k + *(_QWORD *)(a2 + 144) + 8); ++l )
      lydict_remove(a1, *(_QWORD *)(8LL * l + *(_QWORD *)(16LL * k + *(_QWORD *)(a2 + 144))));
    free(*(void **)(16LL * k + *(_QWORD *)(a2 + 144)));
  }
  free(*(void **)(a2 + 144));
  return lydict_remove(a1, *(_QWORD *)(a2 + 160));
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A27EE) ----------------------------------------------------
void __fastcall sub_A27EE(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]
  signed int j; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  lydict_remove(a1, *(_QWORD *)(a2 + 136));
  for ( i = 0; i < *(unsigned __int16 *)(a2 + 30); ++i )
    sub_A1BCA(a1, *(_QWORD *)(a2 + 128) + ((signed __int64)i << 7), v3);
  free(*(void **)(a2 + 128));
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 29); ++j )
    sub_9F606(a1, 56LL * j + *(_QWORD *)(a2 + 120), v3);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 112), (__int64)v3);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A28F5) ----------------------------------------------------
void __fastcall sub_A28F5(__int64 a1, _QWORD *a2, void (__fastcall *a3)(void **, void *))
{
  _QWORD *v3; // ST10_8
  void (__fastcall *v4)(void **, void *); // ST08_8

  v3 = a2;
  v4 = a3;
  lydict_remove(a1, *a2);
  lydict_remove(a1, a2[1]);
  lydict_remove(a1, a2[2]);
  lys_iffeature_free(a1, v3[5], *((unsigned __int8 *)v3 + 27), 0LL, v4);
  ly_set_free(a2[7]);
  sub_AAE3B(a1, (void ***)v3[4], *((unsigned __int8 *)v3 + 26), v4);
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A29AE) ----------------------------------------------------
void __fastcall sub_A29AE(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, void *))
{
  void (__fastcall *v3)(void **, void *); // ST08_8

  v3 = a3;
  lydict_remove(a1, *(_QWORD *)a2);
  lydict_remove(a1, *(_QWORD *)(a2 + 8));
  lydict_remove(a1, *(_QWORD *)(a2 + 16));
  lydict_remove(a1, *(_QWORD *)(a2 + 40));
  sub_AAE3B(a1, *(void ****)(a2 + 32), *(unsigned __int8 *)(a2 + 26), v3);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A2A43) ----------------------------------------------------
void __fastcall sub_A2A43(__int64 *a1, __int64 a2, void (__fastcall *a3)(void **, void *))
{
  __int64 v3; // rax
  void (__fastcall *v4)(void **, void *); // [rsp+8h] [rbp-58h]
  signed int k; // [rsp+2Ch] [rbp-34h]
  signed int l; // [rsp+2Ch] [rbp-34h]
  signed int m; // [rsp+2Ch] [rbp-34h]
  signed int n; // [rsp+30h] [rbp-30h]
  signed int j; // [rsp+34h] [rbp-2Ch]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 i; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]

  v4 = a3;
  v12 = *a1;
  lydict_remove(*a1, *(_QWORD *)a2);
  lydict_remove(v12, *(_QWORD *)(a2 + 8));
  lydict_remove(v12, *(_QWORD *)(a2 + 16));
  sub_AAE3B(v12, *(void ****)(a2 + 48), *(unsigned __int8 *)(a2 + 33), v4);
  if ( *(_QWORD *)(a2 + 40) )
  {
    if ( *(_QWORD *)(a2 + 24) )
    {
      if ( **(_DWORD **)(a2 + 40) )
      {
        *(_QWORD *)(*(_QWORD *)(a2 + 24) + 48LL) = a1;
        sub_A33A0(*(_QWORD ***)(a2 + 24), 0LL, 1u);
      }
      else
      {
        for ( i = *(_QWORD *)(a2 + 24); i; i = v10 )
        {
          *(_QWORD *)(i + 48) = a1;
          if ( *(_DWORD *)(i + 56) & 0x802C )
            v10 = 0LL;
          else
            v10 = *(_QWORD *)(i + 72);
          if ( !v10 )
          {
            if ( i == *(_QWORD *)(a2 + 24) )
              break;
            v10 = *(_QWORD *)(i + 80);
          }
          while ( !v10 )
          {
            i = *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(i + 64) + 88LL) : *(_QWORD *)(i + 64);
            v3 = lys_parent(i);
            if ( v3 == lys_parent(*(_QWORD *)(a2 + 24)) )
              break;
            v10 = *(_QWORD *)(i + 80);
          }
        }
        sub_A33A0(*(_QWORD ***)(a2 + 24), 0LL, 0);
      }
    }
    for ( j = 0; j < *(unsigned __int8 *)(a2 + 32); ++j )
    {
      sub_AAE3B(
        v12,
        *(void ****)(*(_QWORD *)(a2 + 40) + 72LL * j + 64),
        *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * j + 6),
        v4);
      for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * j + 5); ++k )
        lydict_remove(v12, *(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j + 56)));
      free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * j + 56));
      lydict_remove(v12, *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j + 48));
      if ( *(_DWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j) == 3 )
      {
        for ( l = 0; l < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * j + 9); ++l )
          sub_9F606(v12, 56LL * l + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j + 24), v4);
        free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * j + 24));
        for ( m = 0; m < *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + 72LL * j + 10); ++m )
        {
          for ( n = 0; n < *(unsigned __int8 *)(16LL * m + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j + 32) + 8); ++n )
            lydict_remove(
              v12,
              *(_QWORD *)(8LL * n + *(_QWORD *)(16LL * m + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j + 32))));
          free(*(void **)(16LL * m + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 72LL * j + 32)));
        }
        free(*(void **)(*(_QWORD *)(a2 + 40) + 72LL * j + 32));
      }
    }
    free(*(void **)(a2 + 40));
  }
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A2FCB) ----------------------------------------------------
void __fastcall sub_A2FCB(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(void **, void *); // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+28h] [rbp-8h]
  signed int l; // [rsp+28h] [rbp-8h]
  signed int j; // [rsp+2Ch] [rbp-4h]
  signed int k; // [rsp+2Ch] [rbp-4h]

  v3 = (void (__fastcall *)(void **, void *))a3;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 30); ++i )
  {
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i));
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 8));
    lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 16));
    lys_iffeature_free(
      a1,
      *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 40),
      *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 27),
      0LL,
      v3);
    for ( j = 0; j < *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 30); ++j )
      sub_9F606(a1, 56LL * j + *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 56), v3);
    free(*(void **)(*(_QWORD *)(a2 + 112) + 80LL * i + 56));
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 31); ++k )
      lydict_remove(a1, *(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 64)));
    free(*(void **)(*(_QWORD *)(a2 + 112) + 80LL * i + 64));
    sub_AAE3B(
      a1,
      *(void ****)(*(_QWORD *)(a2 + 112) + 80LL * i + 32),
      *(unsigned __int8 *)(*(_QWORD *)(a2 + 112) + 80LL * i + 26),
      v3);
    if ( *(_WORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 28) & 1 )
      lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(a2 + 112) + 80LL * i + 72));
  }
  free(*(void **)(a2 + 112));
  for ( l = 0; l < *(unsigned __int8 *)(a2 + 31); ++l )
    sub_A1EA9(a1, 104LL * l + *(_QWORD *)(a2 + 120), (__int64)v3);
  free(*(void **)(a2 + 120));
  sub_A1E16(a1, *(_QWORD **)(a2 + 104), (__int64)v3);
}
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A33A0) ----------------------------------------------------
void __fastcall sub_A33A0(_QWORD **a1, void (__fastcall *a2)(_QWORD **, _QWORD *), unsigned int a3)
{
  char v3; // al
  unsigned int v4; // eax
  unsigned int v5; // [rsp+Ch] [rbp-34h]
  _QWORD *i; // [rsp+28h] [rbp-18h]
  _QWORD *v7; // [rsp+30h] [rbp-10h]
  __int64 v8; // [rsp+38h] [rbp-8h]

  v5 = a3;
  if ( a1 )
  {
    if ( !a1[6] )
      __assert_fail("node->module", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0xAEAu, "lys_node_free");
    if ( !*a1[6] )
      __assert_fail(
        "node->module->ctx",
        "/home/mantovan/Repositories/libyang/src/tree_schema.c",
        0xAEBu,
        "lys_node_free");
    v8 = *a1[6];
    if ( a1[12] && a2 )
      a2(a1, a1[12]);
    lydict_remove(v8, *a1);
    if ( !((_DWORD)a1[7] & 0x600) )
    {
      lys_iffeature_free(v8, a1[5], *((unsigned __int8 *)a1 + 27), v5, a2);
      lydict_remove(v8, a1[1]);
      lydict_remove(v8, a1[2]);
    }
    if ( !v5 && !((_DWORD)a1[7] & 0xC) )
    {
      for ( i = a1[9]; ; i = v7 )
      {
        if ( i )
        {
          v7 = (_QWORD *)i[10];
          v3 = 1;
        }
        else
        {
          v3 = 0;
        }
        if ( !v3 )
          break;
        sub_A33A0((_QWORD **)i, a2, 0);
      }
    }
    sub_AAE3B(v8, (void ***)a1[4], *((unsigned __int8 *)a1 + 26), (void (__fastcall *)(void **, void *))a2);
    v4 = *((_DWORD *)a1 + 14);
    if ( v4 == 128 )
    {
      sub_A227F(v8, (__int64)a1, (__int64)a2);
      goto LABEL_61;
    }
    if ( v4 <= 0x80 )
    {
      if ( v4 == 4 )
      {
        sub_A23DC(v8, (__int64)a1, (__int64)a2);
        goto LABEL_61;
      }
      if ( v4 <= 4 )
      {
        if ( v4 != 1 )
        {
          if ( v4 >= 1 )
          {
            if ( v4 == 2 )
              sub_A1E16(v8, a1[13], (__int64)a2);
            goto LABEL_61;
          }
LABEL_60:
          sub_12222(
            v8,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
            2866LL);
          goto LABEL_61;
        }
        sub_A27EE(v8, (__int64)a1, (__int64)a2);
LABEL_61:
        sub_9BBAC((__int64)a1);
        free(a1);
        return;
      }
      if ( v4 == 16 )
      {
        sub_A260F(v8, (__int64)a1, (__int64)a2);
        goto LABEL_61;
      }
      if ( v4 <= 0x10 )
      {
        if ( v4 == 8 )
          sub_A24CF(v8, (__int64)a1, (__int64)a2);
        goto LABEL_61;
      }
      if ( v4 != 32 )
      {
        if ( v4 == 64 )
          sub_A1E16(v8, a1[13], (__int64)a2);
        goto LABEL_61;
      }
LABEL_53:
      sub_A234B(v8, (__int64)a1, (__int64)a2);
      goto LABEL_61;
    }
    if ( v4 == 4096 )
    {
      sub_A2FCB(v8, (__int64)a1, (__int64)a2);
      goto LABEL_61;
    }
    if ( v4 <= 0x1000 )
    {
      if ( v4 != 512 )
      {
        if ( v4 <= 0x200 )
        {
          if ( v4 != 256 )
            goto LABEL_61;
          goto LABEL_57;
        }
        if ( v4 != 1024 )
        {
          if ( v4 == 2048 )
            sub_A20D9(v8, (__int64)a1, (__int64)a2);
          goto LABEL_61;
        }
      }
      sub_A21B3(v8, (__int64)a1, (__int64)a2);
      goto LABEL_61;
    }
    if ( v4 != 0x4000 )
    {
      if ( v4 <= 0x4000 )
        goto LABEL_61;
      if ( v4 != 32800 )
      {
        if ( v4 != 0x10000 )
          goto LABEL_61;
        goto LABEL_60;
      }
      goto LABEL_53;
    }
LABEL_57:
    sub_A2146(v8, (__int64)a1, (__int64)a2);
    goto LABEL_61;
  }
}
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A37F2) ----------------------------------------------------
__int64 *__fastcall lys_implemented_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int i; // [rsp+14h] [rbp-Ch]
  __int64 v8; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_implemented_module", a4, a5, a6);
  if ( !a1 || *((_BYTE *)a1 + 64) < 0 )
    return a1;
  v8 = *a1;
  for ( i = 0; i < *(_DWORD *)(v8 + 60); ++i )
  {
    if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v8 + 64)) + 64LL) < 0
      && a1[1] == *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v8 + 64)) + 8LL) )
    {
      return *(__int64 **)(8LL * i + *(_QWORD *)(v8 + 64));
    }
  }
  return a1;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A38CB) ----------------------------------------------------
__int64 __fastcall sub_A38CB(__int64 a1, void (__fastcall *a2)(void **, void *))
{
  char v2; // al
  unsigned int i; // [rsp+14h] [rbp-1Ch]
  unsigned int k; // [rsp+14h] [rbp-1Ch]
  unsigned int l; // [rsp+14h] [rbp-1Ch]
  unsigned int m; // [rsp+14h] [rbp-1Ch]
  unsigned int n; // [rsp+14h] [rbp-1Ch]
  unsigned int ii; // [rsp+14h] [rbp-1Ch]
  unsigned int jj; // [rsp+14h] [rbp-1Ch]
  unsigned int kk; // [rsp+14h] [rbp-1Ch]
  __int64 v12; // [rsp+18h] [rbp-18h]
  __int64 j; // [rsp+20h] [rbp-10h]
  __int64 v14; // [rsp+28h] [rbp-8h]

  if ( !*(_QWORD *)a1 )
    __assert_fail("module->ctx", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0xB61u, "module_free_common");
  v14 = *(_QWORD *)a1;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 69); ++i )
  {
    lydict_remove(v14, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i + 8));
    lydict_remove(v14, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i + 40));
    lydict_remove(v14, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i + 48));
    sub_AAE3B(
      v14,
      *(void ****)(*(_QWORD *)(a1 + 96) + 56LL * i + 32),
      *(unsigned __int8 *)(*(_QWORD *)(a1 + 96) + 56LL * i + 27),
      a2);
  }
  free(*(void **)(a1 + 96));
  if ( !(*(_BYTE *)(a1 + 64) & 1) )
  {
    for ( j = *(_QWORD *)(a1 + 168); ; j = v12 )
    {
      if ( j )
      {
        v12 = *(_QWORD *)(j + 80);
        v2 = 1;
      }
      else
      {
        v2 = 0;
      }
      if ( !v2 )
        break;
      sub_A33A0((_QWORD **)j, (void (__fastcall *)(_QWORD **, _QWORD *))a2, 0);
    }
  }
  lydict_remove(v14, *(_QWORD *)(a1 + 24));
  lydict_remove(v14, *(_QWORD *)(a1 + 32));
  lydict_remove(v14, *(_QWORD *)(a1 + 40));
  lydict_remove(v14, *(_QWORD *)(a1 + 48));
  lydict_remove(v14, *(_QWORD *)(a1 + 56));
  for ( k = 0; k < *(unsigned __int8 *)(a1 + 68); ++k )
  {
    sub_AAE3B(
      v14,
      *(void ****)(*(_QWORD *)(a1 + 88) + 40LL * k + 16),
      *(unsigned __int8 *)(*(_QWORD *)(a1 + 88) + 40LL * k + 11),
      a2);
    lydict_remove(v14, *(_QWORD *)(*(_QWORD *)(a1 + 88) + 40LL * k + 24));
    lydict_remove(v14, *(_QWORD *)(*(_QWORD *)(a1 + 88) + 40LL * k + 32));
  }
  free(*(void **)(a1 + 88));
  for ( l = 0; l < *(unsigned __int16 *)(a1 + 72); ++l )
    sub_A1FDD(v14, 72LL * l + *(_QWORD *)(a1 + 120), a2);
  *(_WORD *)(a1 + 72) = 0;
  free(*(void **)(a1 + 120));
  for ( m = 0; m < *(unsigned __int16 *)(a1 + 74); ++m )
    sub_A1BCA(v14, *(_QWORD *)(a1 + 112) + ((unsigned __int64)m << 7), a2);
  free(*(void **)(a1 + 112));
  sub_AAE3B(v14, *(void ****)(a1 + 160), *(unsigned __int8 *)(a1 + 80), a2);
  for ( n = 0; n < *(unsigned __int8 *)(a1 + 77); ++n )
    sub_A1EA9(v14, 104LL * n + *(_QWORD *)(a1 + 136), (__int64)a2);
  free(*(void **)(a1 + 136));
  for ( ii = 0; ii < *(unsigned __int8 *)(a1 + 76); ++ii )
    sub_A28F5(v14, (_QWORD *)(*(_QWORD *)(a1 + 128) + ((unsigned __int64)ii << 6)), a2);
  free(*(void **)(a1 + 128));
  for ( jj = 0; jj < *(unsigned __int8 *)(a1 + 78); ++jj )
    sub_A2A43((__int64 *)a1, 56LL * jj + *(_QWORD *)(a1 + 144), a2);
  free(*(void **)(a1 + 144));
  for ( kk = 0; kk < *(unsigned __int8 *)(a1 + 79); ++kk )
    sub_A29AE(v14, *(_QWORD *)(a1 + 152) + ((unsigned __int64)kk << 6), a2);
  free(*(void **)(a1 + 152));
  lydict_remove(v14, *(_QWORD *)(a1 + 8));
  return lydict_remove(v14, *(_QWORD *)(a1 + 16));
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A3E76) ----------------------------------------------------
void __fastcall sub_A3E76(__int64 *a1, void (__fastcall *a2)(void **, void *))
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    sub_A38CB((__int64)a1, a2);
    for ( i = 0; i < *((unsigned __int8 *)a1 + 70); ++i )
    {
      lydict_remove(*a1, *(_QWORD *)(a1[13] + 48LL * i + 32));
      lydict_remove(*a1, *(_QWORD *)(a1[13] + 48LL * i + 40));
      sub_AAE3B(*a1, *(void ****)(a1[13] + 48LL * i + 24), *(unsigned __int8 *)(a1[13] + 48LL * i + 19), a2);
    }
    free((void *)a1[13]);
    free(a1);
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A3FB0) ----------------------------------------------------
_BOOL8 __fastcall sub_A3FB0(__int64 a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0xBCCu, "lys_ingrouping");
  v2 = a1;
  while ( v2 && *(_DWORD *)(v2 + 56) != 2048 )
  {
    if ( *(_QWORD *)(v2 + 64)
      && *(_DWORD *)(*(_QWORD *)(v2 + 64) + 56LL) == 0x2000
      && *(_QWORD *)(*(_QWORD *)(v2 + 64) + 64LL) )
    {
      v2 = *(_QWORD *)(*(_QWORD *)(v2 + 64) + 64LL);
    }
    else
    {
      v2 = lys_parent(v2);
    }
  }
  return v2 != 0;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000A4070) ----------------------------------------------------
__int64 __fastcall sub_A4070(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6; // eax
  __int64 v7; // r9
  __int64 v9; // r9
  void **v10; // rbx
  __int64 v11; // r9
  signed __int64 v12; // rbx
  __int64 v13; // r9
  __int64 v14; // r9
  unsigned int v15; // eax
  __int64 *v16; // rax
  __int64 v17; // rax
  _BYTE *v18; // rax
  __int64 *v19; // rax
  const char ***v20; // r12
  char *v21; // rbx
  __int64 v22; // rax
  int v23; // eax
  __int64 v24; // rax
  const char *v25; // rbx
  __int64 *v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  _BYTE *v29; // rax
  __int64 *v30; // rax
  int v31; // eax
  __int64 v32; // rax
  _BYTE *v33; // rax
  __int64 v34; // r9
  _QWORD *v35; // rbx
  __int64 *v36; // rax
  _BYTE *v37; // rax
  __int64 v38; // r9
  __int64 v39; // rax
  __int64 v40; // r9
  void **v41; // rbx
  __int64 v42; // r9
  _QWORD *v43; // rbx
  __int64 v44; // r9
  __int64 *v45; // rax
  _BYTE *v46; // rax
  __int64 *v47; // rax
  __int64 *v48; // rax
  __int64 *v49; // rax
  unsigned int v50; // [rsp+8h] [rbp-128h]
  unsigned int v51; // [rsp+Ch] [rbp-124h]
  __int64 v52; // [rsp+10h] [rbp-120h]
  __int64 v53; // [rsp+18h] [rbp-118h]
  signed __int16 v54; // [rsp+3Ah] [rbp-F6h]
  int v55; // [rsp+3Ch] [rbp-F4h]
  unsigned int v56; // [rsp+40h] [rbp-F0h]
  size_t nmemb; // [rsp+44h] [rbp-ECh]
  unsigned int i; // [rsp+4Ch] [rbp-E4h]
  size_t size; // [rsp+50h] [rbp-E0h]
  __int64 v60; // [rsp+58h] [rbp-D8h]
  _QWORD *v61; // [rsp+60h] [rbp-D0h]
  __int64 j; // [rsp+68h] [rbp-C8h]
  __int64 v63; // [rsp+70h] [rbp-C0h]
  _QWORD *v64; // [rsp+78h] [rbp-B8h]
  _QWORD *v65; // [rsp+80h] [rbp-B0h]
  _QWORD *v66; // [rsp+88h] [rbp-A8h]
  _QWORD *v67; // [rsp+90h] [rbp-A0h]
  unsigned __int8 *v68; // [rsp+98h] [rbp-98h]
  _QWORD *v69; // [rsp+A0h] [rbp-90h]
  _QWORD *v70; // [rsp+A8h] [rbp-88h]
  _QWORD *v71; // [rsp+B0h] [rbp-80h]
  void *v72; // [rsp+B8h] [rbp-78h]
  __int64 v73; // [rsp+C0h] [rbp-70h]
  __int64 v74; // [rsp+C8h] [rbp-68h]
  __int64 v75; // [rsp+D0h] [rbp-60h]
  __int64 v76; // [rsp+D8h] [rbp-58h]
  __int64 v77; // [rsp+E0h] [rbp-50h]
  __int64 v78; // [rsp+E8h] [rbp-48h]
  _QWORD *v79; // [rsp+F0h] [rbp-40h]
  _QWORD *v80; // [rsp+F8h] [rbp-38h]
  _QWORD *v81; // [rsp+100h] [rbp-30h]
  __int64 v82; // [rsp+108h] [rbp-28h]
  _QWORD *v83; // [rsp+110h] [rbp-20h]
  unsigned __int64 v84; // [rsp+118h] [rbp-18h]

  v53 = a3;
  v52 = a4;
  v51 = a5;
  v50 = a6;
  v84 = __readfsqword(0x28u);
  v61 = 0LL;
  v72 = (void *)*a1;
  v64 = 0LL;
  v73 = a3;
  v65 = 0LL;
  v74 = a3;
  v66 = 0LL;
  v75 = a3;
  v67 = 0LL;
  v76 = a3;
  v68 = 0LL;
  v60 = a3;
  v69 = 0LL;
  v77 = a3;
  v70 = 0LL;
  v78 = a3;
  v79 = 0LL;
  v80 = 0LL;
  v81 = 0LL;
  v71 = 0LL;
  v82 = a3;
  v6 = *(_DWORD *)(a3 + 56);
  if ( v6 == 64 )
  {
    v71 = calloc(1uLL, 0x70uLL);
    v61 = v71;
    goto LABEL_34;
  }
  if ( v6 > 0x40 )
  {
    if ( v6 == 1024 )
      goto LABEL_31;
    if ( v6 > 0x400 )
    {
      if ( v6 != 0x4000 )
      {
        if ( v6 != 32800 )
        {
          if ( v6 != 4096 )
            goto LABEL_33;
          v70 = calloc(1uLL, 0x88uLL);
          v61 = v70;
          goto LABEL_34;
        }
        goto LABEL_27;
      }
    }
    else if ( v6 != 256 )
    {
      if ( v6 != 512 )
      {
        if ( v6 != 128 )
          goto LABEL_33;
        v81 = calloc(1uLL, 0x80uLL);
        v61 = v81;
        goto LABEL_34;
      }
LABEL_31:
      v80 = calloc(1uLL, 0x78uLL);
      v61 = v80;
      goto LABEL_34;
    }
    v79 = calloc(1uLL, 0x78uLL);
    v61 = v79;
    goto LABEL_34;
  }
  if ( v6 == 4 )
  {
    v66 = calloc(1uLL, 0xD0uLL);
    v61 = v66;
    goto LABEL_34;
  }
  if ( v6 > 4 )
  {
    if ( v6 == 16 )
    {
      v68 = (unsigned __int8 *)calloc(1uLL, 0xA8uLL);
      v61 = v68;
      goto LABEL_34;
    }
    if ( v6 != 32 )
    {
      if ( v6 != 8 )
        goto LABEL_33;
      v67 = calloc(1uLL, 0xD8uLL);
      v61 = v67;
LABEL_34:
      if ( !v61 )
      {
        sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v7);
        return 0LL;
      }
      *v61 = lydict_insert(v72, *(_QWORD *)v53, 0LL);
      v61[1] = lydict_insert(v72, *(_QWORD *)(v53 + 8), 0LL);
      v61[2] = lydict_insert(v72, *(_QWORD *)(v53 + 16), 0LL);
      *((_WORD *)v61 + 12) = *(_WORD *)(v53 + 24);
      v61[6] = a1;
      *((_DWORD *)v61 + 14) = *(_DWORD *)(v53 + 56);
      v61[11] = v61;
      if ( (unsigned int)sub_2B3F8(v52, -1, v53 + 32, 0x10000) == -1 )
      {
        *((_BYTE *)v61 + 26) = *(_BYTE *)(v53 + 26);
        if ( (unsigned int)sub_9EB54(
                             (__int64)v72,
                             (__int64)a1,
                             *(_QWORD *)(v53 + 32),
                             *(_BYTE *)(v53 + 26),
                             v61,
                             1,
                             v61 + 4,
                             v51,
                             v52) )
          goto LABEL_190;
      }
      if ( *(_BYTE *)(v53 + 27) )
      {
        *((_BYTE *)v61 + 27) = *(_BYTE *)(v53 + 27);
        v61[5] = calloc(*((unsigned __int8 *)v61 + 27), 0x20uLL);
        if ( !v61[5] )
        {
          sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v9);
          goto LABEL_190;
        }
      }
      if ( v51 )
      {
        memcpy((void *)v61[5], *(const void **)(v53 + 40), 32LL * *((unsigned __int8 *)v61 + 27));
      }
      else
      {
        for ( HIDWORD(nmemb) = 0; SHIDWORD(nmemb) < *(unsigned __int8 *)(v53 + 27); ++HIDWORD(nmemb) )
        {
          sub_1902D((__int64 *)(*(_QWORD *)(v53 + 40) + 32LL * SHIDWORD(nmemb)), (int *)&v56, &nmemb);
          if ( v56 )
          {
            LODWORD(size) = (v56 >> 2) + ((v56 & 3) != 0);
            v10 = (void **)(v61[5] + 32LL * SHIDWORD(nmemb));
            *v10 = malloc((unsigned int)size);
            if ( !*(_QWORD *)(32LL * SHIDWORD(nmemb) + v61[5]) )
            {
              sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v11);
              goto LABEL_190;
            }
            memcpy(
              *(void **)(32LL * SHIDWORD(nmemb) + v61[5]),
              *(const void **)(32LL * SHIDWORD(nmemb) + *(_QWORD *)(v53 + 40)),
              (unsigned int)size);
            v12 = v61[5] + 32LL * SHIDWORD(nmemb);
            *(_QWORD *)(v12 + 16) = calloc((unsigned int)nmemb, 8uLL);
            if ( !*(_QWORD *)(32LL * SHIDWORD(nmemb) + v61[5] + 16) )
            {
              sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v13);
              free(*(void **)(32LL * SHIDWORD(nmemb) + v61[5]));
              goto LABEL_190;
            }
            for ( i = 0; i < (unsigned int)nmemb; ++i )
            {
              HIDWORD(size) = sub_2B0C1(
                                a1,
                                v52,
                                *(_QWORD *)(32LL * SHIDWORD(nmemb) + *(_QWORD *)(v53 + 40) + 16) + 8LL * (signed int)i,
                                2u,
                                (_QWORD *)(*(_QWORD *)(32LL * SHIDWORD(nmemb) + v61[5] + 16) + 8LL * (signed int)i));
              if ( HIDWORD(size) == 1 )
              {
                *(_QWORD *)(*(_QWORD *)(32LL * SHIDWORD(nmemb) + v61[5] + 16) + 8LL * (signed int)i) = *(_QWORD *)(*(_QWORD *)(32LL * SHIDWORD(nmemb) + *(_QWORD *)(v53 + 40) + 16) + 8LL * (signed int)i);
              }
              else if ( HIDWORD(size) == -1 )
              {
                goto LABEL_190;
              }
            }
          }
          *(_BYTE *)(v61[5] + 32LL * SHIDWORD(nmemb) + 8) = *(_BYTE *)(*(_QWORD *)(v53 + 40) + 32LL * SHIDWORD(nmemb) + 8);
          if ( (unsigned int)sub_9EB54(
                               (__int64)v72,
                               (__int64)a1,
                               *(_QWORD *)(32LL * SHIDWORD(nmemb) + *(_QWORD *)(v53 + 40) + 24),
                               *(_BYTE *)(32LL * SHIDWORD(nmemb) + *(_QWORD *)(v53 + 40) + 8),
                               (void *)(v61[5] + 32LL * SHIDWORD(nmemb)),
                               18,
                               (__int64 *)(32LL * SHIDWORD(nmemb) + v61[5] + 24),
                               0,
                               v52) )
            goto LABEL_190;
        }
        v63 = a2;
        do
        {
          for ( j = v63; j && *(_DWORD *)(j + 56) == 4096; j = *(_QWORD *)(j + 64) )
            ;
          if ( !j )
            break;
          if ( *(_DWORD *)(j + 56) != 0x2000 )
            break;
          v63 = *(_QWORD *)(j + 88);
        }
        while ( v63 );
        if ( j )
          v54 = *(_WORD *)(j + 24) & 3;
        else
          v54 = 1;
        if ( v50 == 1 )
        {
          if ( v61[3] & 4 )
          {
            if ( v54 & 2 && v61[3] & 1 )
            {
              sub_13937(v72, 10, 2u, (char *)v61, (__int64)"true", (__int64)"config");
              sub_13937(v72, -1, 5u, 0LL, (__int64)"State nodes cannot have configuration nodes as children.", v14);
              goto LABEL_190;
            }
          }
          else
          {
            if ( *((_DWORD *)v61 + 14) != 4096 )
              *((_WORD *)v61 + 12) = v61[3] & 0xFFFC | v54;
            if ( (*(_WORD *)(a2 + 24) & 0x38) > ((_WORD)v61[3] & 0x38) )
            {
              *((_WORD *)v61 + 12) &= 0xFFC7u;
              *((_WORD *)v61 + 12) |= *(_WORD *)(a2 + 24) & 0x38;
            }
          }
        }
        else if ( v50 == 2 )
        {
          *((_WORD *)v61 + 12) &= 0xFFFCu;
          *((_WORD *)v61 + 12) &= 0xFFFBu;
        }
        if ( (unsigned int)sub_9C637(a2, (_QWORD *)v61[6], (__int64)v61, 0) )
          goto LABEL_190;
        if ( !(*(_DWORD *)(v53 + 56) & 0xC) )
        {
          for ( j = *(_QWORD *)(v53 + 72); j; j = *(_QWORD *)(j + 80) )
          {
            if ( !(*(_DWORD *)(j + 56) & 0x800) && !sub_A4070(a1, v61, j, v52, 0LL, v50) )
              goto LABEL_190;
          }
        }
        if ( v50 == 1 && *((_DWORD *)v61 + 14) == 16 && v61[3] & 1 && !*(_BYTE *)(v53 + 30) )
        {
          sub_13937(v72, 12, 2u, (char *)v61, (__int64)"key", (__int64)"list");
          goto LABEL_190;
        }
      }
      v15 = *(_DWORD *)(v53 + 56);
      if ( v15 == 64 )
      {
        if ( *(_QWORD *)(v82 + 104) )
        {
          v49 = sub_A1CC4(a1, *(_QWORD *)(v82 + 104), v51, v52);
          v71[13] = v49;
          if ( !v71[13] )
            goto LABEL_190;
        }
        return (__int64)v61;
      }
      if ( v15 > 0x40 )
      {
        if ( v15 == 1024 )
          return (__int64)v61;
        if ( v15 <= 0x400 )
        {
          if ( v15 != 256 && v15 != 512 && v15 != 128 )
            goto LABEL_188;
          return (__int64)v61;
        }
        if ( v15 == 0x4000 )
          return (__int64)v61;
        if ( v15 != 32800 )
        {
          if ( v15 != 4096 )
            goto LABEL_188;
          v70[16] = *(_QWORD *)(v78 + 128);
          if ( *(_QWORD *)(v78 + 104) )
          {
            v48 = sub_A1CC4(a1, *(_QWORD *)(v78 + 104), v51, v52);
            v70[13] = v48;
            if ( !v70[13] )
              goto LABEL_190;
          }
          return (__int64)v61;
        }
      }
      else
      {
        if ( v15 == 4 )
        {
          v23 = sub_A3FB0((__int64)v61);
          if ( (unsigned int)sub_A1481(a1, v61, (__int64)(v66 + 16), v75 + 128, v23, v51, v52) )
            goto LABEL_190;
          v24 = lydict_insert(*a1, *(_QWORD *)(v75 + 192), 0LL);
          v66[24] = v24;
          if ( *(_QWORD *)(v75 + 200) )
          {
            sub_141E4(0LL, 2u, &v55, 0LL);
            v25 = *(const char **)(v75 + 200);
            v26 = (__int64 *)lys_main_module(*(_QWORD *)(v75 + 48));
            v27 = sub_9BED(v26, v25);
            v66[25] = v27;
            sub_142D2(0LL, v55, 0LL, 0);
            if ( !v66[25] )
            {
              v28 = lydict_insert(v72, *(_QWORD *)(v75 + 200), 0LL);
              v66[25] = v28;
            }
          }
          if ( *(_QWORD *)(v75 + 120) )
          {
            v29 = sub_9F26D(a1, *(_QWORD *)(v75 + 120), *(unsigned __int8 *)(v75 + 31), v51, v52);
            v66[15] = v29;
            if ( !v66[15] )
              goto LABEL_190;
            *((_BYTE *)v66 + 31) = *(_BYTE *)(v75 + 31);
          }
          if ( *(_QWORD *)(v75 + 112) )
          {
            v30 = sub_A1CC4(a1, *(_QWORD *)(v75 + 112), v51, v52);
            v66[14] = v30;
            if ( !v66[14] )
              goto LABEL_190;
          }
          return (__int64)v61;
        }
        if ( v15 <= 4 )
        {
          if ( v15 == 1 )
          {
            if ( *(_QWORD *)(v73 + 112) )
            {
              v16 = sub_A1CC4(a1, *(_QWORD *)(v73 + 112), v51, v52);
              v64[14] = v16;
              if ( !v64[14] )
                goto LABEL_190;
            }
            v17 = lydict_insert(v72, *(_QWORD *)(v73 + 136), 0LL);
            v64[17] = v17;
            if ( *(_QWORD *)(v73 + 120) )
            {
              v18 = sub_9F26D(a1, *(_QWORD *)(v73 + 120), *(unsigned __int8 *)(v73 + 29), v51, v52);
              v64[15] = v18;
              if ( !v64[15] )
                goto LABEL_190;
              *((_BYTE *)v64 + 29) = *(_BYTE *)(v73 + 29);
            }
          }
          else
          {
            if ( v15 != 2 )
            {
LABEL_188:
              sub_12222(
                (__int64)v72,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
                3490LL);
              goto LABEL_190;
            }
            if ( *(_QWORD *)(v74 + 104) )
            {
              v19 = sub_A1CC4(a1, *(_QWORD *)(v74 + 104), v51, v52);
              v65[13] = v19;
              if ( !v65[13] )
                goto LABEL_190;
            }
            if ( v51 )
            {
              v65[14] = *(_QWORD *)(v74 + 112);
            }
            else if ( *(_QWORD *)(v74 + 112) )
            {
              v20 = (const char ***)(v65 + 14);
              v21 = **(char ***)(v74 + 112);
              v22 = lys_node_module(v61);
              HIDWORD(size) = sub_9B262(v65[9], *(const char **)(v22 + 8), 0, v21, 0, 32893, v20);
              if ( HIDWORD(size) )
              {
                if ( HIDWORD(size) == 1 )
                  sub_12222(
                    (__int64)v72,
                    0,
                    4,
                    "Internal error (%s:%d).",
                    (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
                    3318LL);
                goto LABEL_190;
              }
            }
            else
            {
              sub_2B0C1(a1, v52, v74, 0x80u, v65);
            }
          }
          return (__int64)v61;
        }
        if ( v15 == 16 )
        {
          *((_DWORD *)v68 + 38) = *(_DWORD *)(v60 + 152);
          *((_DWORD *)v68 + 39) = *(_DWORD *)(v60 + 156);
          if ( *(_QWORD *)(v60 + 120) )
          {
            v37 = sub_9F26D(a1, *(_QWORD *)(v60 + 120), *(unsigned __int8 *)(v60 + 28), v51, v52);
            *((_QWORD *)v68 + 15) = v37;
            if ( !*((_QWORD *)v68 + 15) )
              goto LABEL_190;
            v68[28] = *(_BYTE *)(v60 + 28);
          }
          if ( *(_BYTE *)(v60 + 30) )
          {
            *((_QWORD *)v68 + 17) = calloc(*(unsigned __int8 *)(v60 + 30), 8uLL);
            if ( !*((_QWORD *)v68 + 17) )
            {
              sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v38);
              goto LABEL_190;
            }
            v39 = lydict_insert(v72, *(_QWORD *)(v60 + 160), 0LL);
            *((_QWORD *)v68 + 20) = v39;
            v68[30] = *(_BYTE *)(v60 + 30);
            if ( v51 )
            {
              memcpy(*((void **)v68 + 17), *(const void **)(v60 + 136), 8LL * *(unsigned __int8 *)(v60 + 30));
            }
            else if ( (unsigned int)sub_2ABDE(a1, v52, (__int64 *)v68, 0x2000u, 0LL) == -1 )
            {
              goto LABEL_190;
            }
          }
          if ( *(_QWORD *)(v60 + 144) )
          {
            *((_QWORD *)v68 + 18) = malloc(16LL * *(unsigned __int8 *)(v60 + 31));
            if ( !*((_QWORD *)v68 + 18) )
            {
              sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v40);
              goto LABEL_190;
            }
            v68[31] = *(_BYTE *)(v60 + 31);
            for ( HIDWORD(nmemb) = 0; SHIDWORD(nmemb) < v68[31]; ++HIDWORD(nmemb) )
            {
              v41 = (void **)(*((_QWORD *)v68 + 18) + 16LL * SHIDWORD(nmemb));
              *v41 = malloc(8LL * *(unsigned __int8 *)(16LL * SHIDWORD(nmemb) + *(_QWORD *)(v60 + 144) + 8));
              if ( !*(_QWORD *)(16LL * SHIDWORD(nmemb) + *((_QWORD *)v68 + 18)) )
              {
                sub_12222(
                  (__int64)v72,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"lys_node_dup_recursion",
                  v42);
                goto LABEL_190;
              }
              *(_BYTE *)(*((_QWORD *)v68 + 18) + 16LL * SHIDWORD(nmemb) + 8) = *(_BYTE *)(*(_QWORD *)(v60 + 144)
                                                                                        + 16LL * SHIDWORD(nmemb)
                                                                                        + 8);
              for ( i = 0; (signed int)i < *(unsigned __int8 *)(16LL * SHIDWORD(nmemb) + *((_QWORD *)v68 + 18) + 8); ++i )
              {
                v43 = (_QWORD *)(*(_QWORD *)(16LL * SHIDWORD(nmemb) + *((_QWORD *)v68 + 18)) + 8LL * (signed int)i);
                *v43 = lydict_insert(
                         v72,
                         *(_QWORD *)(8LL * (signed int)i + *(_QWORD *)(16LL * SHIDWORD(nmemb) + *(_QWORD *)(v60 + 144))),
                         0LL);
                v83 = malloc(0x18uLL);
                if ( !v83 )
                {
                  sub_12222(
                    (__int64)v72,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"lys_node_dup_recursion",
                    v44);
                  goto LABEL_190;
                }
                *v83 = v68;
                v83[1] = *(_QWORD *)(8LL * (signed int)i + *(_QWORD *)(16LL * SHIDWORD(nmemb) + *((_QWORD *)v68 + 18)));
                v83[2] = 16LL * SHIDWORD(nmemb) + *((_QWORD *)v68 + 18) + 9;
                sub_2B0C1(a1, v52, (__int64)&v60, 0x4000u, v83);
              }
            }
          }
          if ( *(_QWORD *)(v60 + 112) )
          {
            v45 = sub_A1CC4(a1, *(_QWORD *)(v60 + 112), v51, v52);
            *((_QWORD *)v68 + 14) = v45;
            if ( !*((_QWORD *)v68 + 14) )
              goto LABEL_190;
          }
          return (__int64)v61;
        }
        if ( v15 != 32 )
        {
          if ( v15 != 8 )
            goto LABEL_188;
          v31 = sub_A3FB0((__int64)v61);
          if ( (unsigned int)sub_A1481(a1, v61, (__int64)(v67 + 16), v76 + 128, v31, v51, v52) )
            goto LABEL_190;
          v32 = lydict_insert(*a1, *(_QWORD *)(v76 + 192), 0LL);
          v67[24] = v32;
          *((_DWORD *)v67 + 52) = *(_DWORD *)(v76 + 208);
          *((_DWORD *)v67 + 53) = *(_DWORD *)(v76 + 212);
          if ( *(_QWORD *)(v76 + 120) )
          {
            v33 = sub_9F26D(a1, *(_QWORD *)(v76 + 120), *(unsigned __int8 *)(v76 + 31), v51, v52);
            v67[15] = v33;
            if ( !v67[15] )
              goto LABEL_190;
            *((_BYTE *)v67 + 31) = *(_BYTE *)(v76 + 31);
          }
          if ( *(_QWORD *)(v76 + 200) )
          {
            v67[25] = malloc(8LL * *(unsigned __int8 *)(v76 + 30));
            if ( !v67[25] )
            {
              sub_12222((__int64)v72, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_node_dup_recursion", v34);
              goto LABEL_190;
            }
            *((_BYTE *)v67 + 30) = *(_BYTE *)(v76 + 30);
            for ( HIDWORD(nmemb) = 0; SHIDWORD(nmemb) < *((unsigned __int8 *)v67 + 30); ++HIDWORD(nmemb) )
            {
              v35 = (_QWORD *)(v67[25] + 8LL * SHIDWORD(nmemb));
              *v35 = lydict_insert(v72, *(_QWORD *)(8LL * SHIDWORD(nmemb) + *(_QWORD *)(v76 + 200)), 0LL);
            }
          }
          if ( *(_QWORD *)(v76 + 112) )
          {
            v36 = sub_A1CC4(a1, *(_QWORD *)(v76 + 112), v51, v52);
            v67[14] = v36;
          }
          return (__int64)v61;
        }
      }
      if ( *(_QWORD *)(v77 + 120) )
      {
        v46 = sub_9F26D(a1, *(_QWORD *)(v77 + 120), *(unsigned __int8 *)(v77 + 31), v51, v52);
        v69[15] = v46;
        if ( !v69[15] )
          goto LABEL_190;
        *((_BYTE *)v69 + 31) = *(_BYTE *)(v77 + 31);
      }
      if ( *(_QWORD *)(v77 + 112) )
      {
        v47 = sub_A1CC4(a1, *(_QWORD *)(v77 + 112), v51, v52);
        v69[14] = v47;
        if ( !v69[14] )
          goto LABEL_190;
      }
      return (__int64)v61;
    }
LABEL_27:
    v69 = calloc(1uLL, 0x80uLL);
    v61 = v69;
    goto LABEL_34;
  }
  if ( v6 == 1 )
  {
    v64 = calloc(1uLL, 0x90uLL);
    v61 = v64;
    goto LABEL_34;
  }
  if ( v6 == 2 )
  {
    v65 = calloc(1uLL, 0x78uLL);
    v61 = v65;
    goto LABEL_34;
  }
LABEL_33:
  sub_12222(
    (__int64)v72,
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
    3137LL);
LABEL_190:
  sub_A33A0((_QWORD **)v61, 0LL, 0);
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000A5E40) ----------------------------------------------------
signed __int64 __fastcall sub_A5E40(__int64 a1)
{
  unsigned int v1; // eax

  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0xDB0u, "lys_has_xpath");
  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 == 64 )
  {
    if ( *(_QWORD *)(a1 + 104) )
      return 1LL;
    return 0LL;
  }
  if ( v1 <= 0x40 )
  {
    if ( v1 == 4 )
    {
      if ( *(_QWORD *)(a1 + 112) || *(_BYTE *)(a1 + 31) )
        return 1LL;
    }
    else if ( v1 > 4 )
    {
      if ( v1 == 8 )
      {
        if ( *(_QWORD *)(a1 + 112) || *(_BYTE *)(a1 + 31) )
          return 1LL;
      }
      else if ( v1 == 16 && (*(_QWORD *)(a1 + 112) || *(_BYTE *)(a1 + 28)) )
      {
        return 1LL;
      }
    }
    else if ( v1 == 1 )
    {
      if ( *(_QWORD *)(a1 + 112) || *(_BYTE *)(a1 + 29) )
        return 1LL;
    }
    else if ( v1 == 2 && *(_QWORD *)(a1 + 104) )
    {
      return 1LL;
    }
    return 0LL;
  }
  if ( v1 == 1024 )
    goto LABEL_52;
  if ( v1 > 0x400 )
  {
    if ( v1 == 0x2000 )
    {
      if ( *(_QWORD *)(a1 + 80) )
        return 1LL;
    }
    else if ( v1 == 32800 )
    {
      if ( *(_QWORD *)(a1 + 112) || *(_BYTE *)(a1 + 31) )
        return 1LL;
    }
    else if ( v1 == 4096 && *(_QWORD *)(a1 + 104) )
    {
      return 1LL;
    }
    return 0LL;
  }
  if ( v1 == 128 )
  {
    if ( *(_BYTE *)(a1 + 29) )
      return 1LL;
    return 0LL;
  }
  if ( v1 == 512 )
  {
LABEL_52:
    if ( *(_BYTE *)(a1 + 29) )
      return 1LL;
  }
  return 0LL;
}

//----- (00000000000A6074) ----------------------------------------------------
_BOOL8 __fastcall sub_A6074(__int64 a1)
{
  __int64 v2; // rbx

  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL) )
    return 1LL;
  v2 = lys_main_module(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL));
  return v2 == lys_main_module(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48LL));
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000A60D4) ----------------------------------------------------
__int64 __fastcall sub_A60D4(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  signed int v5; // eax
  __int64 v7; // rbx
  unsigned int v8; // [rsp+Ch] [rbp-64h]
  __int64 v9; // [rsp+10h] [rbp-60h]
  __int64 v10; // [rsp+18h] [rbp-58h]
  unsigned int v11; // [rsp+3Ch] [rbp-34h]
  __int64 i; // [rsp+40h] [rbp-30h]
  __int64 j; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v11 = 0;
  if ( !a5 )
  {
    for ( i = a2; i && !(*(_DWORD *)(i + 56) & 0x4F80); i = lys_parent(i) )
      ;
    if ( i )
    {
      if ( *(_DWORD *)(i + 56) == 2048 )
        v5 = 0;
      else
        v5 = 2;
    }
    else
    {
      v5 = 1;
    }
    v11 = v5;
  }
  v15 = sub_A4070(a1, a2, v10, v9, v8, v11);
  if ( v11 )
  {
    for ( j = v15; j; j = v14 )
    {
      if ( (unsigned int)sub_A5E40(j) && (unsigned int)sub_2ABDE(a1, v9, (__int64 *)j, 0x20000u, 0LL) == -1 )
        return 0LL;
      if ( *(_DWORD *)(j + 56) & 0x882C )
        v14 = 0LL;
      else
        v14 = *(_QWORD *)(j + 72);
      if ( !v14 )
      {
        if ( j == v15 )
          return v15;
        v14 = *(_QWORD *)(j + 80);
      }
      while ( !v14 )
      {
        j = lys_parent(j);
        v7 = lys_parent(j);
        if ( v7 == lys_parent(v15) )
          break;
        v14 = *(_QWORD *)(j + 80);
      }
    }
  }
  return v15;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000A6294) ----------------------------------------------------
unsigned __int64 __fastcall sub_A6294(__int64 a1, __int64 a2)
{
  void *v2; // rsp
  unsigned int v3; // eax
  unsigned int v4; // eax
  __int64 v6; // [rsp+0h] [rbp-50h]
  __int64 v7; // [rsp+8h] [rbp-48h]
  size_t n; // [rsp+10h] [rbp-40h]
  size_t v9; // [rsp+18h] [rbp-38h]
  __int64 v10; // [rsp+20h] [rbp-30h]
  void *dest; // [rsp+28h] [rbp-28h]
  __int64 v12; // [rsp+30h] [rbp-20h]
  unsigned __int64 v13; // [rsp+38h] [rbp-18h]

  v7 = a1;
  v6 = a2;
  v13 = __readfsqword(0x28u);
  v9 = 104LL;
  v10 = 103LL;
  v2 = alloca(112LL);
  dest = &v6;
  if ( *(_QWORD *)(a1 + 48) != *(_QWORD *)(a2 + 48)
    || *(_QWORD *)v7 != *(_QWORD *)v6
    || *(_DWORD *)(v7 + 56) != *(_DWORD *)(v6 + 56) )
  {
    __assert_fail(
      "(node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype)",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0xE47u,
      "lys_node_switch");
  }
  v12 = 24LL;
  n = 24LL;
  memcpy(dest, (const void *)(v7 + 24), 0x18uLL);
  memcpy((void *)(v7 + v12), (const void *)(v6 + v12), n);
  memcpy((void *)(v12 + v6), dest, n);
  v12 = 112LL;
  v3 = *(_DWORD *)(v7 + 56);
  if ( v3 == 64 )
  {
    n = 112 - v12;
    goto LABEL_36;
  }
  if ( v3 > 0x40 )
  {
    if ( v3 != 512 )
    {
      if ( v3 <= 0x200 )
      {
        if ( v3 == 128 )
        {
          n = 128 - v12;
          goto LABEL_36;
        }
        if ( v3 != 256 )
LABEL_35:
          __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0xEABu, "lys_node_switch");
LABEL_34:
        n = 120 - v12;
        goto LABEL_36;
      }
      if ( v3 == 0x4000 )
        goto LABEL_34;
      if ( v3 == 32800 )
        goto LABEL_30;
      if ( v3 != 1024 )
        goto LABEL_35;
    }
    n = 120 - v12;
    goto LABEL_36;
  }
  if ( v3 == 4 )
  {
    n = 208 - v12;
    goto LABEL_36;
  }
  if ( v3 > 4 )
  {
    if ( v3 == 16 )
    {
      n = 168 - v12;
      goto LABEL_36;
    }
    if ( v3 != 32 )
    {
      if ( v3 == 8 )
      {
        n = 216 - v12;
        goto LABEL_36;
      }
      goto LABEL_35;
    }
LABEL_30:
    n = 128 - v12;
    goto LABEL_36;
  }
  if ( v3 == 1 )
  {
    n = 144 - v12;
  }
  else
  {
    if ( v3 != 2 )
      goto LABEL_35;
    n = 120 - v12;
  }
LABEL_36:
  if ( n > v9 )
    __assert_fail(
      "size <= mem_size",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0xEAFu,
      "lys_node_switch");
  memcpy(dest, (const void *)(v7 + v12), n);
  memcpy((void *)(v7 + v12), (const void *)(v6 + v12), n);
  memcpy((void *)(v12 + v6), dest, n);
  v4 = *(_DWORD *)(v7 + 56);
  if ( v4 == 128 )
  {
    *(_WORD *)(v7 + 30) = *(_WORD *)(v6 + 30);
    *(_QWORD *)(v7 + 112) = *(_QWORD *)(v6 + 112);
    *(_WORD *)(v6 + 30) = 0;
    *(_QWORD *)(v6 + 112) = 0LL;
    return __readfsqword(0x28u) ^ v13;
  }
  if ( v4 > 0x80 )
  {
    if ( v4 != 512 )
    {
      if ( v4 <= 0x200 )
      {
        if ( v4 != 256 )
          return __readfsqword(0x28u) ^ v13;
        goto LABEL_56;
      }
      if ( v4 != 1024 )
      {
        if ( v4 != 0x4000 )
          return __readfsqword(0x28u) ^ v13;
LABEL_56:
        *(_WORD *)(v7 + 30) = *(_WORD *)(v6 + 30);
        *(_QWORD *)(v7 + 112) = *(_QWORD *)(v6 + 112);
        *(_WORD *)(v6 + 30) = 0;
        *(_QWORD *)(v6 + 112) = 0LL;
        return __readfsqword(0x28u) ^ v13;
      }
    }
    *(_WORD *)(v7 + 30) = *(_WORD *)(v6 + 30);
    *(_QWORD *)(v7 + 104) = *(_QWORD *)(v6 + 104);
    *(_WORD *)(v6 + 30) = 0;
    *(_QWORD *)(v6 + 104) = 0LL;
    return __readfsqword(0x28u) ^ v13;
  }
  if ( v4 == 4 )
    goto LABEL_63;
  if ( v4 <= 4 )
  {
    if ( v4 == 1 )
    {
      *(_WORD *)(v7 + 30) = *(_WORD *)(v6 + 30);
      *(_QWORD *)(v7 + 128) = *(_QWORD *)(v6 + 128);
      *(_WORD *)(v6 + 30) = 0;
      *(_QWORD *)(v6 + 128) = 0LL;
    }
    return __readfsqword(0x28u) ^ v13;
  }
  if ( v4 == 8 )
  {
LABEL_63:
    *(_QWORD *)(v7 + 152) = v7;
    *(_QWORD *)(v6 + 152) = v6;
    return __readfsqword(0x28u) ^ v13;
  }
  if ( v4 == 16 )
  {
    *(_BYTE *)(v7 + 29) = *(_BYTE *)(v6 + 29);
    *(_QWORD *)(v7 + 128) = *(_QWORD *)(v6 + 128);
    *(_BYTE *)(v6 + 29) = 0;
    *(_QWORD *)(v6 + 128) = 0LL;
  }
  return __readfsqword(0x28u) ^ v13;
}

//----- (00000000000A67C8) ----------------------------------------------------
void __fastcall sub_A67C8(unsigned __int8 *a1, void (__fastcall *a2)(void **, void *), int a3, int a4)
{
  int v4; // [rsp+Ch] [rbp-24h]
  int i; // [rsp+24h] [rbp-Ch]
  signed int j; // [rsp+24h] [rbp-Ch]
  __int64 v7; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( a1 )
  {
    v7 = *(_QWORD *)a1;
    if ( a4 && *(_DWORD *)(v7 + 60) )
    {
      for ( i = 0; i < *(_DWORD *)(v7 + 60); ++i )
      {
        if ( a1 == *(unsigned __int8 **)(8LL * i + *(_QWORD *)(v7 + 64)) )
        {
          memmove(
            (void *)(*(_QWORD *)(v7 + 64) + 8LL * i),
            *(const void **)(8 * (i + 1LL) + *(_QWORD *)(v7 + 64)),
            8LL * (--*(_DWORD *)(v7 + 60) - i));
          *(_QWORD *)(*(_QWORD *)(v7 + 64) + 8LL * *(signed int *)(v7 + 60)) = 0LL;
          break;
        }
      }
    }
    sub_A38CB((__int64)a1, a2);
    for ( j = 0; j < a1[70]; ++j )
    {
      lydict_remove(v7, *(_QWORD *)(*((_QWORD *)a1 + 13) + 48LL * j + 32));
      lydict_remove(v7, *(_QWORD *)(*((_QWORD *)a1 + 13) + 48LL * j + 40));
      sub_AAE3B(
        v7,
        *(void ****)(*((_QWORD *)a1 + 13) + 48LL * j + 24),
        *(unsigned __int8 *)(*((_QWORD *)a1 + 13) + 48LL * j + 19),
        a2);
      if ( v4 )
        sub_A3E76(*(__int64 **)(*((_QWORD *)a1 + 13) + 48LL * j), a2);
    }
    free(*((void **)a1 + 13));
    lydict_remove(v7, *((_QWORD *)a1 + 22));
    free(a1);
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000A6A3A) ----------------------------------------------------
__int64 __fastcall sub_A6A3A(__int64 a1)
{
  __int16 v1; // ax
  __int64 result; // rax
  unsigned int i; // [rsp+14h] [rbp-Ch]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v1 = *(_WORD *)(a1 + 24);
  HIBYTE(v1) &= 0xFEu;
  *(_WORD *)(a1 + 24) = v1;
  result = *(_QWORD *)(a1 + 56);
  if ( result )
  {
    for ( i = 0; ; ++i )
    {
      result = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4LL);
      if ( i >= (unsigned int)result )
        break;
      v4 = *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL));
      if ( *(_WORD *)(v4 + 24) & 0x100 )
        sub_A6A3A(v4);
    }
  }
  return result;
}

//----- (00000000000A6AC5) ----------------------------------------------------
_BOOL8 __fastcall sub_A6AC5(__int64 a1, const char *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  _BOOL8 result; // rax
  __int16 v7; // dx
  __int64 v8; // rax
  int v9; // [rsp+Ch] [rbp-44h]
  unsigned __int8 v10; // [rsp+27h] [rbp-29h]
  signed int v11; // [rsp+28h] [rbp-28h]
  signed int v12; // [rsp+2Ch] [rbp-24h]
  signed int i; // [rsp+30h] [rbp-20h]
  signed int j; // [rsp+34h] [rbp-1Ch]
  signed int v15; // [rsp+38h] [rbp-18h]
  signed int v16; // [rsp+3Ch] [rbp-14h]
  signed int v17; // [rsp+40h] [rbp-10h]
  unsigned int v18; // [rsp+44h] [rbp-Ch]
  __int64 v19; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v11 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( !strcmp(a2, "*") )
      v11 = 1;
    v18 = 1;
    v15 = 1;
    while ( v15 && v18 )
    {
      v12 = -1;
      v15 = 0;
      v18 = 0;
      while ( v12 < *(unsigned __int8 *)(a1 + 70) )
      {
        if ( v12 == -1 )
        {
          v10 = *(_BYTE *)(a1 + 76);
          v19 = *(_QWORD *)(a1 + 128);
        }
        else
        {
          v10 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 76LL);
          v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 128LL);
        }
        for ( i = 0; i < v10; ++i )
        {
          if ( v11 || !strcmp(*(const char **)(((signed __int64)i << 6) + v19), a2) )
          {
            if ( (!v9 || !(*(_WORD *)(((signed __int64)i << 6) + v19 + 24) & 0x100))
              && (v9 || *(_WORD *)(((signed __int64)i << 6) + v19 + 24) & 0x100) )
            {
              if ( v9 )
              {
                for ( j = 0; j < *(unsigned __int8 *)(((signed __int64)i << 6) + v19 + 27); ++j )
                {
                  if ( !(unsigned int)sub_18D14(32LL * j + *(_QWORD *)(((signed __int64)i << 6) + v19 + 40)) )
                  {
                    if ( !v11 )
                    {
                      sub_12222(
                        *(_QWORD *)a1,
                        0,
                        3,
                        "Feature \"%s\" is disabled by its %d. if-feature condition.",
                        *(_QWORD *)(((signed __int64)i << 6) + v19),
                        (unsigned int)(j + 1));
                      return 1LL;
                    }
                    v16 = v12;
                    v17 = i;
                    v18 = j + 1;
                    break;
                  }
                }
                if ( j == *(unsigned __int8 *)(((signed __int64)i << 6) + v19 + 27) )
                {
                  v7 = *(_WORD *)(((signed __int64)i << 6) + v19 + 24);
                  HIBYTE(v7) |= 1u;
                  *(_WORD *)(((signed __int64)i << 6) + v19 + 24) = v7;
                  ++v15;
                }
              }
              else
              {
                sub_A6A3A(((signed __int64)i << 6) + v19);
                ++v15;
              }
              if ( !v11 )
                return 0LL;
            }
            else if ( !v11 )
            {
              return 0LL;
            }
          }
        }
        ++v12;
      }
    }
    if ( v18 )
    {
      if ( v16 == -1 )
        v8 = *(_QWORD *)(a1 + 128);
      else
        v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v16) + 128LL);
      sub_12222(
        *(_QWORD *)a1,
        0,
        3,
        "Feature \"%s\" is disabled by its %d. if-feature condition.",
        *(_QWORD *)(((signed __int64)v17 << 6) + v8),
        v18);
      result = 1LL;
    }
    else
    {
      result = v11 == 0;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_features_change", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000A6ED2) ----------------------------------------------------
_BOOL8 __fastcall lys_features_enable(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  const char *v8; // ST00_8
  __int64 v9; // ST08_8

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_features_enable", a4, a5, a6, a2, a1);
  return sub_A6AC5(v9, v8, 1, (__int64)v8, v6, v7);
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A6F19) ----------------------------------------------------
_BOOL8 __fastcall lys_features_disable(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  const char *v8; // ST00_8
  __int64 v9; // ST08_8

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_features_disable", a4, a5, a6, a2, a1);
  return sub_A6AC5(v9, v8, 0, (__int64)v8, v6, v7);
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A6F60) ----------------------------------------------------
signed __int64 __fastcall lys_features_state(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *s1; // [rsp+0h] [rbp-20h]
  signed int i; // [rsp+18h] [rbp-8h]
  signed int k; // [rsp+18h] [rbp-8h]
  signed int j; // [rsp+1Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_features_state", a4, a5, a6, a2);
  if ( !a1 || !s1 )
    return 0xFFFFFFFFLL;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 76); ++i )
  {
    if ( !strcmp(s1, *(const char **)(((signed __int64)i << 6) + *(_QWORD *)(a1 + 128))) )
      return (*(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(a1 + 128) + 24) & 0x100) != 0;
  }
  for ( j = 0; j < *(unsigned __int8 *)(a1 + 70); ++j )
  {
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * j) + 76LL); ++k )
    {
      if ( !strcmp(
              s1,
              *(const char **)(((signed __int64)k << 6)
                             + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * j) + 128LL))) )
        return (*(_WORD *)(((signed __int64)k << 6)
                         + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * j) + 128LL)
                         + 24) & 0x100) != 0;
    }
  }
  return 0xFFFFFFFFLL;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A7136) ----------------------------------------------------
_QWORD *__fastcall lys_features_list(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax
  __int64 v7; // r9
  __int64 v8; // r9
  void **v9; // [rsp+0h] [rbp-30h]
  signed int i; // [rsp+1Ch] [rbp-14h]
  signed int j; // [rsp+1Ch] [rbp-14h]
  signed int l; // [rsp+1Ch] [rbp-14h]
  signed int k; // [rsp+20h] [rbp-10h]
  int v14; // [rsp+24h] [rbp-Ch]
  unsigned int v15; // [rsp+24h] [rbp-Ch]
  _QWORD *ptr; // [rsp+28h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_features_list", a4, a5, a6, a2);
  if ( !a1 )
    return 0LL;
  v14 = *(unsigned __int8 *)(a1 + 76);
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 70); ++i )
    v14 += *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i) + 76LL);
  ptr = malloc(8LL * (unsigned int)(v14 + 1));
  if ( ptr )
  {
    if ( !v9 || (*v9 = malloc((unsigned int)(v14 + 1))) != 0LL )
    {
      v15 = 0;
      for ( j = 0; j < *(unsigned __int8 *)(a1 + 76); ++j )
      {
        ptr[v15] = *(_QWORD *)(((signed __int64)j << 6) + *(_QWORD *)(a1 + 128));
        if ( v9 )
        {
          if ( *(_WORD *)(((signed __int64)j << 6) + *(_QWORD *)(a1 + 128) + 24) & 0x100 )
            *((_BYTE *)*v9 + v15) = 1;
          else
            *((_BYTE *)*v9 + v15) = 0;
        }
        ++v15;
      }
      for ( k = 0; k < *(unsigned __int8 *)(a1 + 70); ++k )
      {
        for ( l = 0; l < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * k) + 76LL); ++l )
        {
          ptr[v15] = *(_QWORD *)(((signed __int64)l << 6)
                               + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * k) + 128LL));
          if ( v9 )
          {
            if ( *(_WORD *)(((signed __int64)l << 6)
                          + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * k) + 128LL)
                          + 24) & 0x100 )
              *((_BYTE *)*v9 + v15) = 1;
            else
              *((_BYTE *)*v9 + v15) = 0;
          }
          ++v15;
        }
      }
      ptr[v15] = 0LL;
      result = ptr;
    }
    else
    {
      sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_features_list", v8);
      free(ptr);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_features_list", v7);
    result = 0LL;
  }
  return result;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A7489) ----------------------------------------------------
__int64 __fastcall lys_node_module(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_node_module", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 48) + 64LL) & 1 )
    return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 168LL);
  return *(_QWORD *)(a1 + 48);
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A74EE) ----------------------------------------------------
__int64 __fastcall lys_main_module(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_main_module", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  if ( *(_BYTE *)(a1 + 64) & 1 )
    return *(_QWORD *)(a1 + 168);
  return a1;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A7547) ----------------------------------------------------
__int64 __fastcall lys_parent(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_parent", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 56) == 0x10000 )
  {
    if ( *(_BYTE *)(a1 + 29) != 1 )
      return 0LL;
    v7 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    if ( !*(_QWORD *)(a1 + 64) )
      return 0LL;
    v7 = *(_QWORD *)(a1 + 64);
  }
  if ( *(_DWORD *)(v7 + 56) == 0x2000 )
    result = *(_QWORD *)(v7 + 88);
  else
    result = v7;
  return result;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A75EB) ----------------------------------------------------
signed __int64 __fastcall sub_A75EB(__int64 a1, unsigned int a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax
  __int64 v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x102Fu, "lys_child");
  if ( *(_DWORD *)(a1 + 56) == 0x10000 )
  {
    v2 = sub_C1906(a2);
    v4 = lys_ext_complex_get_substmt(v2, a1, 0LL);
    if ( v4 )
      result = v4;
    else
      result = 0LL;
  }
  else if ( *(_DWORD *)(a1 + 56) & 0x802C )
  {
    result = 0LL;
  }
  else
  {
    result = a1 + 72;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000A7686) ----------------------------------------------------
__int64 __fastcall lys_set_private(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // ST18_8
  __int64 v9; // [rsp+0h] [rbp-20h]

  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_set_private", a4, a5, a6, a2);
  if ( a1 )
  {
    v8 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 96) = v9;
    result = v8;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_set_private", v6);
    result = 0LL;
  }
  return result;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A7706) ----------------------------------------------------
signed __int64 __fastcall sub_A7706(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rbx
  const char *v8; // rax
  __int64 v9; // r9
  __int64 i; // [rsp+10h] [rbp-20h]
  void *v11; // [rsp+18h] [rbp-18h]

  v11 = **(void ***)(a1 + 48);
  if ( *(_DWORD *)(a1 + 56) & 0xC )
  {
    if ( *(_BYTE *)(a2 + 176) != -1 && *(_WORD *)(a2 + 24) & 1 && *(_WORD *)(a1 + 24) & 2 )
    {
      v7 = sub_8164(*(_DWORD *)(a1 + 56));
      v8 = sub_8164(*(_DWORD *)(a2 + 56));
      sub_13937(
        v11,
        -1,
        2u,
        (char *)a2,
        (__int64)"The leafref %s is config but refers to a non-config %s.",
        (__int64)v8,
        v7);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      for ( i = a1; i && *(_DWORD *)(i + 128) == 9; i = *(_QWORD *)(i + 168) )
      {
        if ( i == a2 )
        {
          sub_13937(v11, 38, 2u, (char *)a2, a5, a6, a2);
          return 0xFFFFFFFFLL;
        }
      }
      if ( *(_QWORD *)(a1 + 72) || (*(_QWORD *)(a1 + 72) = ly_set_new(a1)) != 0LL )
      {
        ly_set_add(*(_QWORD *)(a1 + 72), a2, 0LL);
        result = 0LL;
      }
      else
      {
        sub_12222(
          (__int64)v11,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"lys_leaf_add_leafref_target",
          v9,
          a2);
        result = 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    sub_12222(
      (__int64)v11,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
      4183LL,
      a2);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (00000000000A78EB) ----------------------------------------------------
__int64 __fastcall lys_xpath_atomize(__int64 a1, int a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // rax
  const char *v9; // [rsp+8h] [rbp-88h]
  int v10; // [rsp+10h] [rbp-80h]
  unsigned int v11; // [rsp+10h] [rbp-80h]
  __int64 v12; // [rsp+18h] [rbp-78h]
  unsigned int j; // [rsp+2Ch] [rbp-64h]
  __int64 i; // [rsp+30h] [rbp-60h]
  __int64 v15; // [rsp+38h] [rbp-58h]
  char s; // [rsp+40h] [rbp-50h]
  void *ptr; // [rsp+50h] [rbp-40h]
  unsigned int v18; // [rsp+60h] [rbp-30h]
  unsigned __int64 v19; // [rsp+88h] [rbp-8h]

  v12 = a1;
  v9 = a3;
  v10 = a4;
  v19 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_xpath_atomize", a4, a5, a6);
  if ( a1 && v9 )
  {
    if ( !a2 || a2 == 1 )
    {
      do
      {
        v8 = lys_node_module(v12);
        v12 = lys_getnext(0LL, 0LL, v8, 256LL);
      }
      while ( a2 == 1 && *(_WORD *)(v12 + 24) & 2 );
    }
    memset(&s, 0, 0x40uLL);
    for ( i = v12; i && *(_DWORD *)(i + 56) != 1024; i = lys_parent(i) )
      ;
    if ( i )
    {
      v11 = v10 & 0xFFFFFFFC | 0x20;
    }
    else if ( v10 & 1 )
    {
      v11 = v10 & 0xFFFFFFFE | 8;
    }
    else if ( v10 & 2 )
    {
      v11 = v10 & 0xFFFFFFFD | 0x10;
    }
    else
    {
      v11 = v10 | 4;
    }
    if ( (unsigned int)sub_DCFF7(v9, v12, a2, &s, v11, 0LL) )
    {
      free(ptr);
      sub_13937(
        **(void ***)(v12 + 48),
        -1,
        2u,
        (char *)v12,
        (__int64)"Resolving XPath expression \"%s\" failed.",
        (__int64)v9);
      result = 0LL;
    }
    else
    {
      v15 = ly_set_new(v9);
      for ( j = 0; j < v18; ++j )
      {
        if ( *((_DWORD *)ptr + 4 * j + 2) == 2 && (unsigned int)ly_set_add(v15, *((_QWORD *)ptr + 2 * j), 1LL) == -1 )
        {
          ly_set_free(v15);
          free(ptr);
          return 0LL;
        }
      }
      free(ptr);
      result = v15;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_xpath_atomize", v6);
    result = 0LL;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A7B62) ----------------------------------------------------
__int64 __fastcall lys_node_xpath_atomize(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 v6; // rdi
  __int64 v7; // r9
  __int64 result; // rax
  __int64 v9; // rax
  __int64 v10; // [rsp+8h] [rbp-98h]
  unsigned __int16 k; // [rsp+16h] [rbp-8Ah]
  __int64 v12; // [rsp+18h] [rbp-88h]
  __int64 j; // [rsp+20h] [rbp-80h]
  __int64 i; // [rsp+28h] [rbp-78h]
  __int64 l; // [rsp+30h] [rbp-70h]
  __int64 v16; // [rsp+38h] [rbp-68h]
  char v17; // [rsp+40h] [rbp-60h]
  void *ptr; // [rsp+50h] [rbp-50h]
  unsigned int v19; // [rsp+60h] [rbp-40h]
  unsigned __int64 v20; // [rsp+88h] [rbp-18h]

  v10 = a1;
  v20 = __readfsqword(0x28u);
  v6 = 32LL;
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_node_xpath_atomize", a4, a5, a6);
  if ( v10 )
  {
    for ( i = v10; i && !(*(_DWORD *)(i + 56) & 0x680); i = lys_parent(i) )
      v6 = i;
    if ( i )
    {
      v16 = ly_set_new(v6);
      if ( v16 )
      {
        for ( j = v10; j; j = v12 )
        {
          if ( !(a2 & 2) || *(_WORD *)(j + 24) & 0x600 )
          {
            if ( (unsigned int)sub_DD261(j, (void **)&v17, 0) )
            {
              ly_set_free(v16);
              free(ptr);
              return 0LL;
            }
            for ( k = 0; k < v19; ++k )
            {
              if ( *((_DWORD *)ptr + 4 * k + 2) == 2 )
              {
                if ( !(a2 & 2) )
                  goto LABEL_46;
                for ( l = *((_QWORD *)ptr + 2 * k); l && l != i; l = lys_parent(l) )
                  ;
                if ( !l )
                {
LABEL_46:
                  if ( (unsigned int)ly_set_add(v16, *((_QWORD *)ptr + 2 * k), 0LL) == -1 )
                  {
                    ly_set_free(v16);
                    free(ptr);
                    return 0LL;
                  }
                }
              }
            }
            free(ptr);
            if ( !(a2 & 1) )
              break;
          }
          if ( *(_DWORD *)(j + 56) & 0x802C )
            v12 = 0LL;
          else
            v12 = *(_QWORD *)(j + 72);
          if ( !v12 )
          {
            if ( j == v10 )
              break;
            v12 = *(_QWORD *)(j + 80);
          }
          while ( !v12 )
          {
            j = *(_DWORD *)(*(_QWORD *)(j + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(j + 64) + 88LL) : *(_QWORD *)(j + 64);
            v9 = lys_parent(j);
            if ( v9 == lys_parent(v10) )
              break;
            v12 = *(_QWORD *)(j + 80);
          }
        }
        result = v16;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_node_xpath_atomize", v7);
    result = 0LL;
  }
  return result;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000A7ED6) ----------------------------------------------------
signed __int64 __fastcall sub_A7ED6(__int64 a1, __int64 a2)
{
  __int64 v3; // r9
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 *v6; // rax
  __int64 v7; // rax
  __int64 v8; // ST20_8
  unsigned int k; // [rsp+18h] [rbp-48h]
  __int64 j; // [rsp+20h] [rbp-40h]
  __int64 l; // [rsp+20h] [rbp-40h]
  __int64 i; // [rsp+28h] [rbp-38h]
  __int64 v13; // [rsp+28h] [rbp-38h]
  __int64 *v14; // [rsp+30h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-28h]
  __int64 v16; // [rsp+40h] [rbp-20h]
  __int64 *v17; // [rsp+48h] [rbp-18h]

  if ( !*(_QWORD *)(a1 + 88) || !(*(_WORD *)(a1 + 24) & 1) )
    __assert_fail(
      "augment->target && (augment->flags & LYS_NOTAPPLIED)",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0x1146u,
      "apply_aug");
  if ( *(_QWORD *)(a1 + 72) )
  {
    for ( i = *(_QWORD *)(a1 + 88); i && !(*(_DWORD *)(i + 56) & 0x780); i = lys_parent(i) )
      ;
    for ( j = *(_QWORD *)(a1 + 72); j; j = *(_QWORD *)(j + 80) )
    {
      if ( (unsigned int)sub_22209(j, *(_WORD *)(*(_QWORD *)(a1 + 88) + 24LL) & 3, i != 0) )
        return 0xFFFFFFFFLL;
    }
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(a1 + 88) + 26LL); ++k )
    {
      v16 = *(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32LL));
      if ( v16 && *(_QWORD *)(*(_QWORD *)v16 + 56LL) && *(_WORD *)(*(_QWORD *)(*(_QWORD *)v16 + 56LL) + 4LL) & 1 )
      {
        v17 = (__int64 *)malloc(1uLL);
        if ( !v17 )
        {
          sub_12222(**(_QWORD **)(a1 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"apply_aug", v3, a2);
          return 0xFFFFFFFFLL;
        }
        *(_BYTE *)v17 = k;
        v4 = (__int64 *)(*(_QWORD *)(a1 + 88) + 32LL);
        v5 = (__int64 *)lys_main_module(*(_QWORD *)(a1 + 48));
        if ( (unsigned int)sub_2ABDE(v5, a2, v4, 0x40000u, v17) == -1 )
          return 0xFFFFFFFFLL;
      }
    }
    for ( l = a1; l; l = v13 )
    {
      if ( *(_DWORD *)(l + 56) & 0xC )
      {
        v14 = (__int64 *)(l + 128);
        if ( *(_DWORD *)(l + 128) == 9 )
        {
          if ( *(_QWORD *)(l + 168) )
          {
            v15 = lys_node_module(*(_QWORD *)(l + 168));
            if ( !(*(_BYTE *)(v15 + 64) & 0x80) )
            {
              *(_BYTE *)(v15 + 64) |= 0x80u;
              if ( (unsigned int)sub_2ABDE((__int64 *)v15, a2, 0LL, 0x8000u, 0LL) == -1 )
                return 0xFFFFFFFFLL;
            }
          }
          else if ( (signed int)sub_2B3F8(a2, -1, (__int64)v14, 32) >= 0 )
          {
            v6 = (__int64 *)lys_node_module(l);
            if ( (unsigned int)sub_2ABDE(v6, a2, v14, 0x20u, (__int64 *)l) == -1 )
              return 0xFFFFFFFFLL;
          }
        }
      }
      if ( *(_DWORD *)(l + 56) & 0x802C )
        v13 = 0LL;
      else
        v13 = *(_QWORD *)(l + 72);
      if ( !v13 )
      {
        if ( l == a1 )
          break;
        v13 = *(_QWORD *)(l + 80);
      }
      while ( !v13 )
      {
        l = *(_DWORD *)(*(_QWORD *)(l + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(l + 64) + 88LL) : *(_QWORD *)(l + 64);
        v7 = lys_parent(l);
        if ( v7 == lys_parent(a1) )
          break;
        v13 = *(_QWORD *)(l + 80);
      }
    }
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) )
    {
      v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) + 88LL);
      *(_QWORD *)(v8 + 80) = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) + 88LL) = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 88LL);
      *(_QWORD *)(*(_QWORD *)(a1 + 72) + 88LL) = v8;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) = *(_QWORD *)(a1 + 72);
    }
  }
  *(_WORD *)(a1 + 24) &= 0xFFFEu;
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000A835C) ----------------------------------------------------
__int64 __fastcall sub_A835C(__int64 a1)
{
  __int64 result; // rax
  __int64 i; // [rsp+8h] [rbp-10h]
  __int64 v3; // [rsp+10h] [rbp-8h]

  result = *(_WORD *)(a1 + 24) & 1;
  if ( !(_DWORD)result )
  {
    result = *(_QWORD *)(a1 + 88);
    if ( result )
    {
      v3 = *(_QWORD *)(a1 + 72);
      if ( v3 )
      {
        for ( i = *(_QWORD *)(a1 + 72);
              i && *(_QWORD *)(i + 80) && a1 == *(_QWORD *)(*(_QWORD *)(i + 80) + 64LL);
              i = *(_QWORD *)(i + 80) )
        {
          ;
        }
        if ( v3 == *(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) )
          *(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) = *(_QWORD *)(i + 80);
        if ( *(_QWORD *)(*(_QWORD *)(v3 + 88) + 80LL) )
          *(_QWORD *)(*(_QWORD *)(v3 + 88) + 80LL) = *(_QWORD *)(i + 80);
        if ( *(_QWORD *)(i + 80) )
        {
          *(_QWORD *)(*(_QWORD *)(i + 80) + 88LL) = *(_QWORD *)(v3 + 88);
        }
        else if ( *(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) )
        {
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72LL) + 88LL) = *(_QWORD *)(v3 + 88);
        }
        *(_QWORD *)(v3 + 88) = i;
        *(_QWORD *)(i + 80) = 0LL;
      }
      result = a1;
      *(_WORD *)(a1 + 24) |= 1u;
    }
  }
  return result;
}

//----- (00000000000A84A7) ----------------------------------------------------
unsigned __int64 __fastcall sub_A84A7(__int64 a1, __int64 *a2, __int64 a3)
{
  char *v3; // rax
  int v4; // ST2C_4
  __int64 v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // r9
  const char *v8; // rax
  __int64 v9; // rax
  signed int v10; // eax
  __int64 v12; // [rsp+8h] [rbp-68h]
  signed int v13; // [rsp+28h] [rbp-48h]
  __int64 v14; // [rsp+30h] [rbp-40h]
  __int64 v15; // [rsp+38h] [rbp-38h]
  __int64 v16; // [rsp+40h] [rbp-30h]
  _DWORD *v17; // [rsp+48h] [rbp-28h]
  void *ptr; // [rsp+50h] [rbp-20h]
  unsigned __int64 v19; // [rsp+58h] [rbp-18h]

  v12 = a3;
  v19 = __readfsqword(0x28u);
  v13 = 0;
  v15 = 0LL;
  if ( *(_QWORD *)(a1 + 40) )
  {
    if ( **(_DWORD **)(a1 + 40) )
    {
      if ( (unsigned int)sub_1A193(*(char **)a1, 0LL, (__int64)a2, &v14, 0, 1) == -1 )
      {
        sub_12222(
          *a2,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
          4657LL);
        ly_set_free(v14);
      }
      else
      {
        v15 = **(_QWORD **)(v14 + 8);
        ly_set_free(v14);
        sub_A6294(v15, *(_QWORD *)(a1 + 24));
      }
    }
    else if ( *(_QWORD *)(a1 + 24) )
    {
      if ( strrchr(*(const char **)a1, 47) == *(char **)a1 )
      {
        v5 = *(_QWORD *)(a1 + 24);
        v6 = (_QWORD *)lys_node_module(*(_QWORD *)(a1 + 24));
        sub_9C637(0LL, v6, v5, 0);
        goto LABEL_20;
      }
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 64LL);
      if ( v16 && *(_DWORD *)(v16 + 56) == 0x2000 )
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 24) + 64LL) = 0LL;
        if ( !(*(_WORD *)(v16 + 24) & 1) )
        {
          sub_A835C(v16);
          v13 = 1;
        }
        sub_9C637(v16, 0LL, *(_QWORD *)(a1 + 24), 0);
        if ( v13 )
        {
          if ( !(*(_BYTE *)(lys_node_module(v16) + 64) & 0x80) )
            __assert_fail(
              "lys_node_module(parent)->implemented",
              "/home/mantovan/Repositories/libyang/src/tree_schema.c",
              0x11E8u,
              "lys_switch_deviation");
          *(_WORD *)(v16 + 24) |= 1u;
          sub_A7ED6(v16, v12);
        }
        goto LABEL_20;
      }
      if ( v16 && *(_DWORD *)(v16 + 56) == 4096 )
      {
        sub_9C637(v16, 0LL, *(_QWORD *)(a1 + 24), 0);
LABEL_20:
        *(_QWORD *)(a1 + 24) = 0LL;
        return __readfsqword(0x28u) ^ v19;
      }
      v3 = strrchr(*(const char **)a1, 47);
      ptr = strndup(*(const char **)a1, (size_t)&v3[-*(_QWORD *)a1]);
      v4 = sub_1A193((char *)ptr, 0LL, (__int64)a2, &v14, 0, 1);
      free(ptr);
      if ( v4 != -1 )
      {
        v15 = **(_QWORD **)(v14 + 8);
        ly_set_free(v14);
        sub_9C637(v15, 0LL, *(_QWORD *)(a1 + 24), 0);
        goto LABEL_20;
      }
      sub_12222(
        *a2,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
        4597LL);
      ly_set_free(v14);
    }
    else
    {
      if ( (unsigned int)sub_1A193(*(char **)a1, 0LL, (__int64)a2, &v14, 0, 1) != -1 )
      {
        v15 = **(_QWORD **)(v14 + 8);
        ly_set_free(v14);
        v16 = *(_QWORD *)(v15 + 64);
        sub_9BBAC(v15);
        if ( v16 )
        {
          if ( *(_DWORD *)(v16 + 56) & 0x3000 )
          {
            *(_QWORD *)(v15 + 64) = v16;
          }
          else if ( *(_DWORD *)(v16 + 56) & 0x4100 )
          {
            v17 = calloc(1uLL, 0x78uLL);
            if ( !v17 )
            {
              sub_12222(*a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_switch_deviation", v7);
              return __readfsqword(0x28u) ^ v19;
            }
            v17[14] = *(_DWORD *)(v15 + 56);
            if ( v17[14] == 512 )
              v8 = "input";
            else
              v8 = "output";
            v9 = lydict_insert(*a2, v8, 0LL);
            *(_QWORD *)v17 = v9;
            *((_QWORD *)v17 + 6) = *(_QWORD *)(v15 + 48);
            *((_WORD *)v17 + 12) = 64;
            if ( !*(_QWORD *)(v16 + 72)
              || *(_QWORD *)(*(_QWORD *)(v16 + 72) + 80LL)
              || (v17[14] != 512 ? (v10 = 512) : (v10 = 1024), v10 != *(_DWORD *)(*(_QWORD *)(v16 + 72) + 56LL)) )
            {
              __assert_fail(
                "parent->child && !parent->child->next && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS"
                "_OUTPUT : LYS_INPUT))",
                "/home/mantovan/Repositories/libyang/src/tree_schema.c",
                0x1225u,
                "lys_switch_deviation");
            }
            *(_QWORD *)(*(_QWORD *)(v16 + 72) + 80LL) = v17;
            *((_QWORD *)v17 + 11) = *(_QWORD *)(v16 + 72);
            *(_QWORD *)(*(_QWORD *)(v16 + 72) + 88LL) = v17;
            *((_QWORD *)v17 + 8) = v16;
          }
        }
        *(_QWORD *)(a1 + 24) = v15;
        return __readfsqword(0x28u) ^ v19;
      }
      sub_12222(
        *a2,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
        4616LL);
      ly_set_free(v14);
    }
  }
  return __readfsqword(0x28u) ^ v19;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000A8A9A) ----------------------------------------------------
unsigned __int64 __fastcall sub_A8A9A(__int64 a1)
{
  __int64 v1; // r9
  size_t v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rdx
  int v8; // [rsp+18h] [rbp-28h]
  unsigned int i; // [rsp+1Ch] [rbp-24h]
  _DWORD *v10; // [rsp+20h] [rbp-20h]
  __int64 v11; // [rsp+28h] [rbp-18h]
  char *v12; // [rsp+30h] [rbp-10h]
  unsigned __int64 v13; // [rsp+38h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v8 = 0;
  if ( *(_BYTE *)(a1 + 64) & 0x30 )
  {
    v10 = calloc(1uLL, 0x28uLL);
    if ( v10 )
    {
      while ( 1 )
      {
        v11 = ly_ctx_get_module_iter(*(_QWORD *)a1, &v8);
        if ( !v11 )
          break;
        if ( v11 != a1 )
        {
          for ( i = 0; i < *(unsigned __int8 *)(v11 + 78); ++i )
          {
            v12 = strstr(*(const char **)(*(_QWORD *)(v11 + 144) + 56LL * i), *(const char **)(a1 + 8));
            if ( v12 )
            {
              v2 = strlen(*(const char **)(a1 + 8));
              if ( v12[v2] == 58 )
                sub_A84A7(*(_QWORD *)(v11 + 144) + 56LL * i, (__int64 *)v11, (__int64)v10);
            }
          }
        }
      }
      if ( (*(_BYTE *)(a1 + 64) & 0x30) != 32 )
        __assert_fail(
          "module->deviated == 2",
          "/home/mantovan/Repositories/libyang/src/tree_schema.c",
          0x1257u,
          "lys_enable_deviations");
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 64) & 0xCF | 0x10;
      for ( i = 0; i < *(unsigned __int8 *)(a1 + 70); ++i )
      {
        v3 = *(_QWORD *)(a1 + 104);
        if ( *(_BYTE *)(*(_QWORD *)(v3 + 48LL * i) + 64LL) & 0x30 )
        {
          v6 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i);
          v3 = 16 * ((*(_BYTE *)(a1 + 64) >> 4) & 3u);
          *(_BYTE *)(v6 + 64) = 16 * ((*(_BYTE *)(a1 + 64) >> 4) & 3) | *(_BYTE *)(v6 + 64) & 0xCF;
        }
      }
      if ( v10[8] )
        sub_2A9F8((__int64 *)a1, (__int64)v10, (__int64)v10, v3, v4, v5);
      sub_2B768(a1, (void ***)&v10, 1);
    }
    else
    {
      sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_enable_deviations", v1);
    }
  }
  return __readfsqword(0x28u) ^ v13;
}
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);

//----- (00000000000A8D1D) ----------------------------------------------------
unsigned __int64 __fastcall sub_A8D1D(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // r8
  __int64 v3; // r9
  int v4; // eax
  int v5; // eax
  __int64 v6; // rdx
  unsigned int v8; // [rsp+18h] [rbp-28h]
  unsigned int v9; // [rsp+1Ch] [rbp-24h]
  unsigned int i; // [rsp+1Ch] [rbp-24h]
  _DWORD *v11; // [rsp+20h] [rbp-20h]
  __int64 v12; // [rsp+28h] [rbp-18h]
  char *v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  if ( *(_BYTE *)(a1 + 64) & 0x30 )
  {
    v11 = calloc(1uLL, 0x28uLL);
    if ( v11 )
    {
      v8 = *(_DWORD *)(*(_QWORD *)a1 + 60LL);
      while ( 1 )
      {
        v5 = v8--;
        if ( !v5 )
          break;
        v12 = *(_QWORD *)(8LL * v8 + *(_QWORD *)(*(_QWORD *)a1 + 64LL));
        if ( v12 != a1 )
        {
          v9 = *(unsigned __int8 *)(v12 + 78);
          while ( 1 )
          {
            v4 = v9--;
            if ( !v4 )
              break;
            v13 = strstr(*(const char **)(*(_QWORD *)(v12 + 144) + 56LL * v9), *(const char **)(a1 + 8));
            if ( v13 && v13[strlen(*(const char **)(a1 + 8))] == 58 )
              sub_A84A7(*(_QWORD *)(v12 + 144) + 56LL * v9, (__int64 *)v12, (__int64)v11);
          }
        }
      }
      if ( (*(_BYTE *)(a1 + 64) & 0x30) != 16 )
        __assert_fail(
          "module->deviated == 1",
          "/home/mantovan/Repositories/libyang/src/tree_schema.c",
          0x1284u,
          "lys_disable_deviations");
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 64) & 0xCF | 0x20;
      for ( i = 0; i < *(unsigned __int8 *)(a1 + 70); ++i )
      {
        v1 = *(_QWORD *)(a1 + 104);
        if ( *(_BYTE *)(*(_QWORD *)(v1 + 48LL * i) + 64LL) & 0x30 )
        {
          v6 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i);
          v1 = 16 * ((*(_BYTE *)(a1 + 64) >> 4) & 3u);
          *(_BYTE *)(v6 + 64) = 16 * ((*(_BYTE *)(a1 + 64) >> 4) & 3) | *(_BYTE *)(v6 + 64) & 0xCF;
        }
      }
      if ( v11[8] )
        sub_2A9F8((__int64 *)a1, (__int64)v11, (__int64)v11, v1, v2, v3);
      sub_2B768(a1, (void ***)&v11, 1);
    }
    else
    {
      sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_disable_deviations", v3);
    }
  }
  return __readfsqword(0x28u) ^ v14;
}

//----- (00000000000A8FAF) ----------------------------------------------------
__int64 __fastcall sub_A8FAF(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax

  sub_A84A7(a1, a2, a3);
  if ( !*(_QWORD *)(a1 + 24) )
    __assert_fail("dev->orig_node", "/home/mantovan/Repositories/libyang/src/tree_schema.c", 0x1299u, "apply_dev");
  v3 = lys_node_module(*(_QWORD *)(a1 + 24));
  *(_BYTE *)(v3 + 64) = *(_BYTE *)(v3 + 64) & 0xCF | 0x10;
  result = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48LL);
  *(_BYTE *)(result + 64) = *(_BYTE *)(result + 64) & 0xCF | 0x10;
  return result;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000A903F) ----------------------------------------------------
unsigned __int64 __fastcall sub_A903F(__int64 a1, __int64 *a2, __int64 a3)
{
  size_t v3; // rax
  __int64 v5; // [rsp+8h] [rbp-48h]
  int v6; // [rsp+20h] [rbp-30h]
  unsigned int i; // [rsp+24h] [rbp-2Ch]
  __int64 v8; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  char *v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v12 = __readfsqword(0x28u);
  v6 = 0;
  if ( *(_QWORD *)(a1 + 24) )
  {
    v8 = lys_node_module(*(_QWORD *)(a1 + 24));
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48LL);
    sub_A84A7(a1, a2, v5);
    while ( 1 )
    {
      v10 = ly_ctx_get_module_iter(*a2, &v6);
      if ( !v10 )
        break;
      if ( (__int64 *)v10 != a2 && v10 != v8 )
      {
        for ( i = 0; i < *(unsigned __int8 *)(v10 + 78); ++i )
        {
          v11 = strstr(*(const char **)(*(_QWORD *)(v10 + 144) + 56LL * i), *(const char **)(v8 + 8));
          if ( v11 )
          {
            v3 = strlen(*(const char **)(v8 + 8));
            if ( v11[v3] == 58 )
              break;
          }
        }
        if ( i < *(unsigned __int8 *)(v10 + 78) )
          break;
      }
    }
    if ( !v10 )
    {
      *(_BYTE *)(v8 + 64) &= 0xCFu;
      *(_BYTE *)(v9 + 64) &= 0xCFu;
    }
  }
  else
  {
    sub_12222(
      *a2,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/tree_schema.c",
      4778LL);
  }
  return __readfsqword(0x28u) ^ v12;
}
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000A91FC) ----------------------------------------------------
unsigned __int64 __fastcall sub_A91FC(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned __int8 i; // [rsp+1Eh] [rbp-12h]
  unsigned __int8 j; // [rsp+1Eh] [rbp-12h]
  unsigned __int8 l; // [rsp+1Eh] [rbp-12h]
  unsigned __int8 m; // [rsp+1Eh] [rbp-12h]
  unsigned __int8 k; // [rsp+1Fh] [rbp-11h]
  _DWORD *v10; // [rsp+20h] [rbp-10h]
  unsigned __int64 v11; // [rsp+28h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  if ( *(_BYTE *)(a1 + 64) >= 0 )
    __assert_fail(
      "module->implemented",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0x12CEu,
      "lys_sub_module_apply_devs_augs");
  v10 = calloc(1uLL, 0x28uLL);
  if ( v10 )
  {
    for ( i = 0; i < *(_BYTE *)(a1 + 78); ++i )
      sub_A8FAF(*(_QWORD *)(a1 + 144) + 56LL * i, (__int64 *)a1, (__int64)v10);
    for ( j = 0; j < *(_BYTE *)(a1 + 77); ++j )
      sub_A7ED6(*(_QWORD *)(a1 + 136) + 104LL * j, (__int64)v10);
    for ( k = 0; k < *(_BYTE *)(a1 + 70); ++k )
    {
      for ( l = 0; l < *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * k) + 78LL); ++l )
        sub_A8FAF(
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * k) + 144LL) + 56LL * l,
          (__int64 *)a1,
          (__int64)v10);
      for ( m = 0; ; ++m )
      {
        v1 = *(_QWORD *)(a1 + 104);
        if ( m >= *(_BYTE *)(*(_QWORD *)(v1 + 48LL * k) + 77LL) )
          break;
        sub_A7ED6(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * k) + 136LL) + 104LL * m, (__int64)v10);
      }
    }
    if ( v10[8] )
      sub_2A9F8((__int64 *)a1, (__int64)v10, (__int64)v10, v1, v2, v3);
    sub_2B768(a1, (void ***)&v10, 1);
  }
  else
  {
    sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_sub_module_apply_devs_augs", v3);
  }
  return __readfsqword(0x28u) ^ v11;
}

//----- (00000000000A9496) ----------------------------------------------------
unsigned __int64 __fastcall sub_A9496(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned __int8 i; // [rsp+1Dh] [rbp-13h]
  unsigned __int8 k; // [rsp+1Dh] [rbp-13h]
  unsigned __int8 m; // [rsp+1Dh] [rbp-13h]
  unsigned __int8 ii; // [rsp+1Dh] [rbp-13h]
  unsigned __int8 j; // [rsp+1Eh] [rbp-12h]
  unsigned __int8 l; // [rsp+1Eh] [rbp-12h]
  unsigned __int8 n; // [rsp+1Fh] [rbp-11h]
  _DWORD *v12; // [rsp+20h] [rbp-10h]
  unsigned __int64 v13; // [rsp+28h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v12 = calloc(1uLL, 0x28uLL);
  if ( v12 )
  {
    for ( i = 0; i < *(_BYTE *)(a1 + 78); ++i )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 144) + 56LL * i + 24) )
        sub_A903F(*(_QWORD *)(a1 + 144) + 56LL * i, (__int64 *)a1, (__int64)v12);
      for ( j = 0; ; ++j )
      {
        v1 = *(_QWORD *)(a1 + 144);
        if ( j >= *(_BYTE *)(v1 + 56LL * i + 32) )
          break;
        if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 56LL * i + 40) + 72LL * j) == 1 )
          free(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 56LL * i + 40) + 72LL * j + 24));
      }
    }
    for ( k = 0; k < *(_BYTE *)(a1 + 77); ++k )
      sub_A835C(*(_QWORD *)(a1 + 136) + 104LL * k);
    for ( l = 0; l < *(_BYTE *)(a1 + 70); ++l )
    {
      v1 = *(_QWORD *)(a1 + 104);
      if ( !*(_QWORD *)(v1 + 48LL * l) )
        break;
      for ( m = 0; m < *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 78LL); ++m )
      {
        if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 144LL) + 56LL * m + 24) )
          sub_A903F(
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 144LL) + 56LL * m,
            (__int64 *)a1,
            (__int64)v12);
        for ( n = 0; n < *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 144LL) + 56LL * m + 32); ++n )
        {
          if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 144LL) + 56LL * m + 40)
                         + 72LL * n) == 1 )
            free(*(void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 144LL)
                                      + 56LL * m
                                      + 40)
                          + 72LL * n
                          + 24));
        }
      }
      for ( ii = 0; ; ++ii )
      {
        v1 = *(_QWORD *)(a1 + 104);
        if ( ii >= *(_BYTE *)(*(_QWORD *)(v1 + 48LL * l) + 77LL) )
          break;
        sub_A835C(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * l) + 136LL) + 104LL * ii);
      }
    }
    if ( v12[8] )
      sub_2A9F8((__int64 *)a1, (__int64)v12, (__int64)v12, v1, v2, v3);
    sub_2B768(a1, (void ***)&v12, 1);
  }
  else
  {
    sub_12222(*(_QWORD *)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_sub_module_remove_devs_augs", v3);
  }
  return __readfsqword(0x28u) ^ v13;
}

//----- (00000000000A9962) ----------------------------------------------------
signed __int64 __fastcall sub_A9962(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  __int128 v4; // di
  __int64 v5; // rax
  __int128 v6; // di
  __int64 v7; // rbx
  __int64 v8; // [rsp+0h] [rbp-50h]
  __int64 v9; // [rsp+8h] [rbp-48h]
  unsigned __int16 i; // [rsp+12h] [rbp-3Eh]
  unsigned __int16 j; // [rsp+12h] [rbp-3Eh]
  unsigned __int16 k; // [rsp+12h] [rbp-3Eh]
  unsigned __int16 m; // [rsp+12h] [rbp-3Eh]
  unsigned __int16 l; // [rsp+14h] [rbp-3Ch]
  unsigned __int16 n; // [rsp+14h] [rbp-3Ch]
  unsigned __int16 ii; // [rsp+14h] [rbp-3Ch]
  unsigned __int16 jj; // [rsp+16h] [rbp-3Ah]
  __int64 kk; // [rsp+18h] [rbp-38h]
  __int64 v19; // [rsp+20h] [rbp-30h]
  __int64 ll; // [rsp+28h] [rbp-28h]
  __int64 v21; // [rsp+30h] [rbp-20h]
  __int64 v22; // [rsp+38h] [rbp-18h]
  __int64 v23; // [rsp+38h] [rbp-18h]

  v9 = a1;
  v8 = a2;
  if ( *(_BYTE *)(a1 + 64) >= 0 )
    __assert_fail(
      "module->implemented",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0x132Fu,
      "lys_make_implemented_r");
  v21 = *(_QWORD *)a1;
  for ( i = 0; (signed int)i < *(_DWORD *)(v21 + 60); ++i )
  {
    if ( a1 != *(_QWORD *)(8LL * i + *(_QWORD *)(v21 + 64))
      && !strcmp(*(const char **)(a1 + 8), *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(v21 + 64)) + 8LL))
      && *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v21 + 64)) + 64LL) < 0 )
    {
      sub_12222(v21, 0, 3, "Module \"%s\" in another revision already implemented.", *(_QWORD *)(a1 + 8), v2, a2);
      return 1LL;
    }
  }
  for ( j = 0; j < *(unsigned __int8 *)(a1 + 77); ++j )
  {
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 136) + 104LL * j + 88) )
      __assert_fail(
        "module->augment[i].target",
        "/home/mantovan/Repositories/libyang/src/tree_schema.c",
        0x1340u,
        "lys_make_implemented_r");
    v22 = lys_node_module(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 104LL * j + 88));
    if ( !(*(_BYTE *)(v22 + 64) & 0x80) )
    {
      *(_BYTE *)(v22 + 64) |= 0x80u;
      if ( (unsigned int)sub_2ABDE((__int64 *)v22, a2, 0LL, 0x8000u, 0LL) == -1 )
        return 0xFFFFFFFFLL;
    }
    if ( *(_WORD *)(*(_QWORD *)(a1 + 136) + 104LL * j + 24) & 1
      && (unsigned int)sub_A7ED6(*(_QWORD *)(a1 + 136) + 104LL * j, a2) )
    {
      return 0xFFFFFFFFLL;
    }
  }
  for ( k = 0; k < *(_WORD *)(v9 + 72); ++k )
  {
    for ( l = 0; l < *(unsigned __int8 *)(*(_QWORD *)(v9 + 120) + 72LL * k + 31); ++l )
    {
      *((_QWORD *)&v4 + 1) = *(_QWORD *)(8LL * l + *(_QWORD *)(*(_QWORD *)(v9 + 120) + 72LL * k + 56));
      *(_QWORD *)&v4 = *(_QWORD *)(v9 + 120) + 72LL * k;
      sub_258B4(v4);
    }
  }
  for ( m = 0; m < *(unsigned __int8 *)(v9 + 70) && *(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m); ++m )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m);
    *(_BYTE *)(v5 + 64) |= 0x80u;
    for ( n = 0; n < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 77LL); ++n )
    {
      if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 136LL) + 104LL * n + 88) )
        __assert_fail(
          "module->inc[i].submodule->augment[j].target",
          "/home/mantovan/Repositories/libyang/src/tree_schema.c",
          0x135Du,
          "lys_make_implemented_r");
      v23 = lys_node_module(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 136LL)
                                      + 104LL * n
                                      + 88));
      if ( !(*(_BYTE *)(v23 + 64) & 0x80) )
      {
        *(_BYTE *)(v23 + 64) |= 0x80u;
        if ( (unsigned int)sub_2ABDE((__int64 *)v23, v8, 0LL, 0x8000u, 0LL) == -1 )
          return 0xFFFFFFFFLL;
      }
      if ( *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 136LL) + 104LL * n + 24) & 1
        && (unsigned int)sub_A7ED6(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 136LL) + 104LL * n, v8) )
      {
        return 0xFFFFFFFFLL;
      }
    }
    for ( ii = 0; ii < *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 72LL); ++ii )
    {
      for ( jj = 0;
            jj < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 120LL) + 72LL * ii + 31);
            ++jj )
      {
        *((_QWORD *)&v6 + 1) = *(_QWORD *)(8LL * jj
                                         + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 120LL)
                                                     + 72LL * ii
                                                     + 56));
        *(_QWORD *)&v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * m) + 120LL) + 72LL * ii;
        sub_258B4(v6);
      }
    }
  }
  for ( kk = *(_QWORD *)(v9 + 168); kk; kk = *(_QWORD *)(kk + 80) )
  {
    for ( ll = kk; ll; ll = v19 )
    {
      if ( *(_DWORD *)(ll + 56) == 2048 )
        goto LABEL_70;
      if ( *(_DWORD *)(ll + 56) & 0xC
        && *(_DWORD *)(ll + 128) == 9
        && (unsigned int)sub_2ABDE((__int64 *)v9, v8, (__int64 *)(ll + 128), 0x20u, (__int64 *)ll) == -1 )
      {
        return 0xFFFFFFFFLL;
      }
      v19 = *(_QWORD *)(ll + 72);
      if ( *(_DWORD *)(ll + 56) & 0x802C )
        v19 = 0LL;
      if ( !v19 )
      {
LABEL_70:
        if ( ll == kk )
          break;
        v19 = *(_QWORD *)(ll + 80);
      }
      while ( !v19 )
      {
        ll = lys_parent(ll);
        v7 = lys_parent(ll);
        if ( v7 == lys_parent(kk) )
          break;
        v19 = *(_QWORD *)(ll + 80);
      }
    }
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000AA19A) ----------------------------------------------------
signed __int64 __fastcall lys_set_implemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // r9
  void *v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  void *v13; // rdx
  const char *v14; // rax
  __int64 v15; // [rsp+8h] [rbp-28h]
  signed int v16; // [rsp+1Ch] [rbp-14h]
  void *v17; // [rsp+20h] [rbp-10h]
  unsigned __int64 v18; // [rsp+28h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_set_implemented", a4, a5, a6);
  v16 = 0;
  if ( a1 )
  {
    v15 = lys_main_module(a1);
    if ( *(_BYTE *)(v15 + 64) & 0x40 )
    {
      v16 = 1;
      lys_set_enabled(v15);
    }
    if ( *(_BYTE *)(v15 + 64) >= 0 )
    {
      v17 = calloc(1uLL, 0x28uLL);
      if ( v17 )
      {
        *(_BYTE *)(v15 + 64) |= 0x80u;
        v9 = v17;
        if ( (unsigned int)sub_A9962(v15, (__int64)v17)
          || *((_DWORD *)v17 + 8)
          && (v9 = v17, (unsigned int)sub_2A9F8((__int64 *)v15, (__int64)v17, (__int64)v17, v10, v11, v12)) )
        {
          if ( v16 )
            lys_set_disabled(v15, v9);
          *(_BYTE *)(v15 + 64) &= 0x7Fu;
          sub_2B768(v15, (void ***)&v17, 1);
          result = 1LL;
        }
        else
        {
          sub_2B768(0LL, (void ***)&v17, 0);
          if ( *(_BYTE *)(v15 + 68) )
            v13 = *(void **)(v15 + 88);
          else
            v13 = &unk_121924;
          if ( *(_BYTE *)(v15 + 68) )
            v14 = "@";
          else
            v14 = (const char *)&unk_121924;
          sub_12222(0LL, 2u, 0, "Module \"%s%s%s\" now implemented.", *(_QWORD *)(v15 + 8), (__int64)v14, v13);
          result = 0LL;
        }
      }
      else
      {
        sub_12222(*(_QWORD *)v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_set_implemented", v8);
        if ( v16 )
          lys_set_disabled(v15, 0LL);
        result = 1LL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_set_implemented", v6);
    result = 1LL;
  }
  return result;
}
// 73C0: using guessed type __int64 __fastcall lys_set_enabled(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7C70: using guessed type __int64 __fastcall lys_set_disabled(_QWORD, _QWORD);
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000AA3F6) ----------------------------------------------------
signed __int64 __fastcall sub_AA3F6(__int64 a1)
{
  signed __int64 result; // rax
  __int64 v2; // [rsp+10h] [rbp-10h]
  __int64 i; // [rsp+18h] [rbp-8h]

  for ( i = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 168LL); ; i = v2 )
  {
    if ( i )
    {
      v2 = *(_QWORD *)(i + 80);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
    if ( !(_BYTE)result )
      break;
    if ( a1 == *(_QWORD *)(i + 48) )
      sub_A33A0((_QWORD **)i, 0LL, 0);
  }
  return result;
}

//----- (00000000000AA46C) ----------------------------------------------------
__int64 __fastcall lys_path(char *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+10h] [rbp-10h]
  unsigned __int64 v9; // [rsp+18h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_path", a4, a5, a6);
  v8 = 0LL;
  if ( a1 )
  {
    if ( (unsigned int)sub_12B3E(2u, a1, (void **)&v8, (a2 & 1) == 0, 0) )
      result = 0LL;
    else
      result = v8;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_path", v6);
    result = 0LL;
  }
  return result;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000AA532) ----------------------------------------------------
char *__fastcall lys_data_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  const char *v9; // rbx
  void *v10; // rax
  __int64 v11; // r9
  __int64 v12; // [rsp+8h] [rbp-458h]
  __int64 i; // [rsp+10h] [rbp-450h]
  char *v14; // [rsp+18h] [rbp-448h]
  const char *v15; // [rsp+20h] [rbp-440h]
  const char **v16; // [rsp+28h] [rbp-438h]
  __int64 v17; // [rsp+30h] [rbp-430h]
  __int64 v18; // [rsp+38h] [rbp-428h]
  char s[1032]; // [rsp+40h] [rbp-420h]
  unsigned __int64 v20; // [rsp+448h] [rbp-18h]

  v12 = a1;
  v20 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_data_path", a4, a5, a6);
  v14 = 0LL;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_data_path", v6);
    return 0LL;
  }
  s[0] = 0;
  v18 = ly_set_new(32LL);
  if ( !v18 )
  {
    sub_12222(**(_QWORD **)(a1 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_data_path", v8);
    goto LABEL_25;
  }
  while ( v12 )
  {
    ly_set_add(v18, v12, 0LL);
    do
      v12 = lys_parent(v12);
    while ( v12 && *(_DWORD *)(v12 + 56) & 0x1642 );
  }
  v17 = 0LL;
  for ( i = (unsigned int)(*(_DWORD *)(v18 + 4) - 1); (signed int)i >= 0; LODWORD(i) = i - 1 )
  {
    v12 = *(_QWORD *)(8LL * (signed int)i + *(_QWORD *)(v18 + 8));
    if ( *(_DWORD *)(v12 + 56) == 0x10000 )
    {
      if ( strcmp(**(const char ***)v12, "yang-data") )
        continue;
      v16 = *(const char ***)(v12 + 16);
      v15 = ":#";
    }
    else
    {
      v16 = *(const char ***)v12;
      v15 = ":";
    }
    if ( v17 == lys_node_module(v12) )
      v9 = (const char *)&unk_121924;
    else
      v9 = v15;
    if ( v17 == lys_node_module(v12) )
      v10 = &unk_121924;
    else
      v10 = *(void **)(lys_node_module(v12) + 8);
    HIDWORD(i) += sprintf(&s[SHIDWORD(i)], "/%s%s%s", v10, v9, v16);
    v17 = lys_node_module(v12);
  }
  v14 = strdup(s);
  if ( !v14 )
    sub_12222(**(_QWORD **)(v12 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lys_data_path", v11);
LABEL_25:
  ly_set_free(v18);
  return v14;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 120FA0: using guessed type void *off_120FA0;
// AA532: using guessed type char s[1032];

//----- (00000000000AA881) ----------------------------------------------------
signed __int64 __fastcall sub_AA881(__int64 a1, __int64 a2, __int64 a3)
{
  signed int i; // [rsp+24h] [rbp-1Ch]
  signed int j; // [rsp+24h] [rbp-1Ch]
  signed int k; // [rsp+28h] [rbp-18h]
  _BOOL4 v7; // [rsp+2Ch] [rbp-14h]
  __int64 l; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  if ( !a2 || !a3 )
    __assert_fail(
      "mod && aug_target",
      "/home/mantovan/Repositories/libyang/src/tree_schema.c",
      0x1440u,
      "lys_getnext_target_aug");
  v7 = a1 == 0;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 77); ++i )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a2 + 136) + 104LL * i + 88)
      && a3 == *(_QWORD *)(*(_QWORD *)(a2 + 136) + 104LL * i + 88) )
    {
      if ( v7 )
        return *(_QWORD *)(a2 + 136) + 104LL * i;
      if ( a1 == *(_QWORD *)(a2 + 136) + 104LL * i )
        v7 = 1;
    }
  }
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 70); ++j )
  {
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 77LL); ++k )
    {
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 136LL) + 104LL * k + 88)
        && a3 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 136LL) + 104LL * k + 88) )
      {
        if ( v7 )
          return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 136LL) + 104LL * k;
        if ( a1 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 136LL) + 104LL * k )
          v7 = 1;
      }
    }
  }
  for ( l = *(_QWORD *)(a3 + 72); l; l = *(_QWORD *)(l + 80) )
  {
    if ( *(_DWORD *)(l + 56) == 2 )
    {
      v9 = sub_AA881(a1, a2, l);
      if ( v9 )
        return v9;
    }
  }
  return 0LL;
}

//----- (00000000000AABDA) ----------------------------------------------------
__int64 __fastcall lys_find_path(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v9 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_120FA0, (__int64)"lys_find_path", a4, a5, a6);
  if ( !a1 && !a2 || !v7 )
    return 0LL;
  if ( (unsigned int)sub_1A193(v7, a2, a1, &v8, 1, 1) == -1 )
    return 0LL;
  return v8;
}
// 120FA0: using guessed type void *off_120FA0;

//----- (00000000000AAC84) ----------------------------------------------------
unsigned __int64 __fastcall sub_AAC84(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-44h]
  int i; // [rsp+2Ch] [rbp-24h]
  int j; // [rsp+2Ch] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  void **v8; // [rsp+38h] [rbp-18h]
  void **v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v4 = a3;
  v10 = __readfsqword(0x28u);
  v8 = (void **)lys_ext_complex_get_substmt(a3, a2, &v7);
  if ( v8 && *v8 )
  {
    if ( *(_DWORD *)(v7 + 16) <= 1u )
    {
      lydict_remove(a1, *v8);
      if ( v4 == 3 )
        lydict_remove(a1, v8[1]);
    }
    else
    {
      v9 = v8;
      v8 = (void **)*v8;
      for ( i = 0; v8[i]; ++i )
        lydict_remove(a1, v8[i]);
      free(*v9);
      if ( v4 == 3 )
      {
        v8 = (void **)v9[1];
        for ( j = 0; v8[j]; ++j )
          lydict_remove(a1, v8[j]);
        free(v9[1]);
      }
      else if ( v4 == 1 )
      {
        free(v9[1]);
      }
    }
  }
  return __readfsqword(0x28u) ^ v10;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000AAE3B) ----------------------------------------------------
void __fastcall sub_AAE3B(__int64 a1, void ***a2, unsigned int a3, void (__fastcall *a4)(void **, void *))
{
  char v4; // al
  void (__fastcall *v5)(void **, void *); // [rsp+0h] [rbp-60h]
  unsigned int v6; // [rsp+Ch] [rbp-54h]
  unsigned int k; // [rsp+2Ch] [rbp-34h]
  unsigned int m; // [rsp+2Ch] [rbp-34h]
  unsigned int l; // [rsp+2Ch] [rbp-34h]
  int j; // [rsp+30h] [rbp-30h]
  unsigned int i; // [rsp+34h] [rbp-2Ch]
  __int64 *v12; // [rsp+38h] [rbp-28h]
  __int64 *v13; // [rsp+38h] [rbp-28h]
  __int64 *v14; // [rsp+38h] [rbp-28h]
  __int64 *v15; // [rsp+38h] [rbp-28h]
  _QWORD *v16; // [rsp+38h] [rbp-28h]
  _QWORD *v17; // [rsp+38h] [rbp-28h]
  void **v18; // [rsp+38h] [rbp-28h]
  __int64 *v19; // [rsp+38h] [rbp-28h]
  void ***v20; // [rsp+38h] [rbp-28h]
  void **v21; // [rsp+38h] [rbp-28h]
  __int64 *v22; // [rsp+38h] [rbp-28h]
  __int64 *v23; // [rsp+38h] [rbp-28h]
  _QWORD **v24; // [rsp+38h] [rbp-28h]
  _QWORD **v25; // [rsp+38h] [rbp-28h]
  void **v26; // [rsp+38h] [rbp-28h]
  void **v27; // [rsp+38h] [rbp-28h]
  __int64 n; // [rsp+40h] [rbp-20h]
  __int64 v29; // [rsp+48h] [rbp-18h]
  _DWORD *v30; // [rsp+50h] [rbp-10h]
  __int64 *ptr; // [rsp+58h] [rbp-8h]
  __int64 *ptra; // [rsp+58h] [rbp-8h]
  void *ptrb; // [rsp+58h] [rbp-8h]
  void **ptrc; // [rsp+58h] [rbp-8h]
  __int64 *ptrd; // [rsp+58h] [rbp-8h]
  void *ptre; // [rsp+58h] [rbp-8h]
  void **ptrf; // [rsp+58h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( a3 && a2 )
  {
    for ( i = 0; i < v6; ++i )
    {
      if ( a2[i] )
      {
        if ( !((_WORD)a2[i][3] & 1) )
        {
          if ( (_WORD)a2[i][3] & 2 )
          {
            free(*a2[i]);
            *a2[i] = 0LL;
            sub_952AD((void **)a2[i][1]);
          }
          if ( a2[i][5] && v5 )
            v5(a2[i], a2[i][5]);
          sub_AAE3B(a1, (void ***)a2[i][4], *((unsigned __int8 *)a2[i] + 26), v5);
          lydict_remove(a1, a2[i][2]);
        }
        if ( *a2[i] && *((_QWORD *)*a2[i] + 7) && **((_DWORD **)*a2[i] + 7) == 1 && !((_WORD)a2[i][3] & 4) )
        {
          v30 = a2[i][8];
          for ( j = 0; v30[6 * j]; ++j )
          {
            switch ( v30[6 * j] )
            {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
              case 0xD:
              case 0xE:
              case 0xF:
              case 0x10:
              case 0x11:
                sub_AAC84(a1, (__int64)a2[i], v30[6 * j]);
                break;
              case 0x12:
              case 0x1C:
              case 0x1D:
              case 0x1E:
                v18 = (void **)((char *)a2[i] + *(_QWORD *)&v30[6 * j + 2] + 72);
                if ( v30[6 * j + 4] > 1u && *v18 )
                {
                  for ( k = 0; *((_QWORD *)*v18 + k); ++k )
                    free(*((void **)*v18 + k));
                }
                free(*v18);
                break;
              case 0x1B:
                if ( v30[6 * j + 4] > 1u )
                  free(*(void **)((char *)a2[i] + *(_QWORD *)&v30[6 * j + 2] + 72));
                break;
              case 0x1F:
                v20 = (void ***)lys_ext_complex_get_substmt(31LL, a2[i], 0LL);
                if ( v20 && *v20 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    for ( l = 0; l < *((unsigned __int8 *)*v20 + 8); ++l )
                      lydict_remove(a1, *((_QWORD *)**v20 + l));
                    free(**v20);
                    free(*v20);
                  }
                  else
                  {
                    v21 = *v20;
                    ptrc = v21;
                    while ( *v21 )
                    {
                      for ( m = 0; m < *((unsigned __int8 *)*v21 + 8); ++m )
                        lydict_remove(a1, *(_QWORD *)(8LL * m + *(_QWORD *)*v21));
                      free(*(void **)*v21);
                      free(*v21);
                      ++v21;
                    }
                    free(ptrc);
                  }
                }
                break;
              case 0x20:
                if ( v30[6 * j + 4] > 1u )
                  free(*(void **)((char *)a2[i] + *(_QWORD *)&v30[6 * j + 2] + 72));
                break;
              case 0x21:
              case 0x22:
              case 0x23:
              case 0x24:
              case 0x25:
              case 0x26:
              case 0x27:
              case 0x28:
              case 0x29:
              case 0x2A:
              case 0x2B:
              case 0x2C:
              case 0x2D:
              case 0x2E:
              case 0x39:
                v19 = (__int64 *)((char *)a2[i] + *(_QWORD *)&v30[6 * j + 2] + 72);
                for ( n = *v19; ; n = v29 )
                {
                  if ( n )
                  {
                    v29 = *(_QWORD *)(n + 80);
                    v4 = 1;
                  }
                  else
                  {
                    v4 = 0;
                  }
                  if ( !v4 )
                    break;
                  sub_A33A0((_QWORD **)n, 0LL, 0);
                }
                *v19 = 0LL;
                break;
              case 0x2F:
                v14 = (__int64 *)lys_ext_complex_get_substmt(47LL, a2[i], 0LL);
                if ( v14 && *v14 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    sub_A1BCA(a1, *v14, v5);
                    free((void *)*v14);
                  }
                  else
                  {
                    v15 = (__int64 *)*v14;
                    ptra = v15;
                    while ( *v15 )
                    {
                      sub_A1BCA(a1, *v15, v5);
                      free((void *)*v15);
                      ++v15;
                    }
                    free(ptra);
                  }
                }
                break;
              case 0x30:
                v12 = (__int64 *)lys_ext_complex_get_substmt(48LL, a2[i], 0LL);
                if ( v12 && *v12 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    sub_A1648(a1, *v12, v5);
                    free((void *)*v12);
                  }
                  else
                  {
                    v13 = (__int64 *)*v12;
                    ptr = v13;
                    while ( *v13 )
                    {
                      sub_A1648(a1, *v13, v5);
                      free((void *)*v13);
                      ++v13;
                    }
                    free(ptr);
                  }
                }
                break;
              case 0x31:
                v16 = (_QWORD *)lys_ext_complex_get_substmt(49LL, a2[i], 0LL);
                if ( v16 && *v16 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    lys_iffeature_free(a1, *v16, 1LL, 0LL, v5);
                  }
                  else
                  {
                    v17 = (_QWORD *)*v16;
                    ptrb = v17;
                    while ( *v17 )
                    {
                      lys_iffeature_free(a1, *v17, 1LL, 0LL, v5);
                      ++v17;
                    }
                    free(ptrb);
                  }
                }
                break;
              case 0x32:
              case 0x33:
              case 0x34:
              case 0x35:
                v22 = (__int64 *)lys_ext_complex_get_substmt((unsigned int)v30[6 * j], a2[i], 0LL);
                if ( v22 && *v22 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    sub_9F606(a1, *v22, v5);
                    free((void *)*v22);
                  }
                  else
                  {
                    v23 = (__int64 *)*v22;
                    ptrd = v23;
                    while ( *v23 )
                    {
                      sub_9F606(a1, *v23, v5);
                      free((void *)*v23);
                      ++v23;
                    }
                    free(ptrd);
                  }
                }
                break;
              case 0x36:
                v24 = (_QWORD **)lys_ext_complex_get_substmt(54LL, a2[i], 0LL);
                if ( v24 && *v24 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    sub_A1E16(a1, *v24, (__int64)v5);
                  }
                  else
                  {
                    v25 = (_QWORD **)*v24;
                    ptre = v25;
                    while ( *v25 )
                    {
                      sub_A1E16(a1, *v25, (__int64)v5);
                      ++v25;
                    }
                    free(ptre);
                  }
                }
                break;
              case 0x37:
                v26 = (void **)lys_ext_complex_get_substmt(55LL, a2[i], 0LL);
                if ( v26 && *v26 )
                {
                  if ( v30[6 * j + 4] <= 1u )
                  {
                    lydict_remove(a1, *((_QWORD *)*v26 + 3));
                    lydict_remove(a1, *((_QWORD *)*v26 + 4));
                    sub_AAE3B(a1, *((void ****)*v26 + 2), *((unsigned __int8 *)*v26 + 11), v5);
                    free(*v26);
                  }
                  else
                  {
                    v27 = (void **)*v26;
                    ptrf = v27;
                    while ( *v27 )
                    {
                      lydict_remove(a1, *((_QWORD *)*v27 + 3));
                      lydict_remove(a1, *((_QWORD *)*v27 + 4));
                      sub_AAE3B(a1, *((void ****)*v27 + 2), *((unsigned __int8 *)*v27 + 11), v5);
                      free(*v27);
                      ++v27;
                    }
                    free(ptrf);
                  }
                }
                break;
              default:
                continue;
            }
          }
        }
        free(a2[i]);
      }
    }
    free(a2);
  }
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 79B0: using guessed type __int64 __fastcall lys_iffeature_free(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000ABBCE) ----------------------------------------------------
signed __int64 __fastcall sub_ABBCE(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  signed __int64 result; // rax
  _BYTE *v5; // [rsp+10h] [rbp-20h]
  _BYTE *v6; // [rsp+18h] [rbp-18h]
  _QWORD *v7; // [rsp+20h] [rbp-10h]
  unsigned __int64 v8; // [rsp+28h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  v5 = 0LL;
  v6 = 0LL;
  if ( !(*(_DWORD *)(*a1 + 56LL) & 0x8020) )
    __assert_fail(
      "first->schema->nodetype & LYS_ANYDATA",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x36u,
      "lyd_anydata_equal");
  if ( *(_DWORD *)(*a1 + 56LL) != *(_DWORD *)(*a2 + 56LL) )
    __assert_fail(
      "first->schema->nodetype == second->schema->nodetype",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x37u,
      "lyd_anydata_equal");
  v7 = a1;
  if ( !a1[7] )
  {
    lyxml_print_mem(&v5, v7[7], 16LL);
    v2 = lydict_insert_zc(**(_QWORD **)(*v7 + 48LL), v5);
    v7[7] = v2;
  }
  v5 = (_BYTE *)v7[7];
  v7 = a2;
  if ( !a2[7] )
  {
    lyxml_print_mem(&v6, v7[7], 16LL);
    v3 = lydict_insert_zc(**(_QWORD **)(*v7 + 48LL), v6);
    v7[7] = v3;
  }
  v6 = (_BYTE *)v7[7];
  if ( **(_QWORD **)(*a1 + 48LL) == **(_QWORD **)(*a2 + 48LL) )
    result = v5 == v6;
  else
    result = sub_C462(v5, v6);
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7990: using guessed type __int64 __fastcall lyxml_print_mem(_QWORD, _QWORD, _QWORD);

//----- (00000000000ABD8D) ----------------------------------------------------
_BOOL8 __fastcall sub_ABD8D(_QWORD *a1)
{
  signed int v2; // [rsp+1Ch] [rbp-14h]
  _QWORD *i; // [rsp+20h] [rbp-10h]
  __int64 v4; // [rsp+28h] [rbp-8h]

  if ( *(_DWORD *)(*a1 + 56LL) != 16 )
    __assert_fail(
      "list->schema->nodetype == LYS_LIST",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x56u,
      "lyd_list_has_keys");
  v4 = *a1;
  if ( !*(_BYTE *)(*a1 + 30LL) )
    return 1LL;
  v2 = 0;
  for ( i = (_QWORD *)a1[8]; i && v2 < *(unsigned __int8 *)(v4 + 30); i = (_QWORD *)i[3] )
  {
    if ( *i != *(_QWORD *)(8LL * v2 + *(_QWORD *)(v4 + 136)) )
      return 0LL;
    ++v2;
  }
  return v2 >= *(unsigned __int8 *)(v4 + 30);
}

//----- (00000000000ABE70) ----------------------------------------------------
signed __int64 __fastcall sub_ABE70(_BYTE **a1, _BYTE **a2, int a3)
{
  signed __int64 result; // rax

  if ( !(*((_DWORD *)*a1 + 14) & 0xC) )
    __assert_fail(
      "node1->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x77u,
      "lyd_leaf_val_equal");
  if ( *((_DWORD *)*a1 + 14) != *((_DWORD *)*a2 + 14) )
    __assert_fail(
      "node1->schema->nodetype == node2->schema->nodetype",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x78u,
      "lyd_leaf_val_equal");
  if ( a3 )
    result = sub_C462(a1[7], a2[7]);
  else
    result = a1[7] == a2[7];
  return result;
}

//----- (00000000000ABF28) ----------------------------------------------------
signed __int64 __fastcall sub_ABF28(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  int v10; // [rsp+Ch] [rbp-64h]
  signed int i; // [rsp+28h] [rbp-48h]
  int v12; // [rsp+2Ch] [rbp-44h]
  __int64 *v13; // [rsp+30h] [rbp-40h]
  __int64 **v14; // [rsp+30h] [rbp-40h]
  __int64 *v15; // [rsp+38h] [rbp-38h]
  __int64 v16; // [rsp+40h] [rbp-30h]
  __int64 j; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  __int64 v20; // [rsp+50h] [rbp-20h]
  __int64 v21; // [rsp+58h] [rbp-18h]

  v10 = a3;
  v21 = **(_QWORD **)(*(_QWORD *)a2 + 48LL);
  v12 = **(_QWORD **)(*(_QWORD *)a1 + 48LL) != **(_QWORD **)(*(_QWORD *)a2 + 48LL);
  v3 = *(_DWORD *)(*(_QWORD *)a2 + 56LL);
  if ( v3 == 8 )
  {
    if ( (unsigned int)sub_ABE70((_BYTE **)a1, (_BYTE **)a2, v12)
      && (!v10 || (*(_BYTE *)(a1 + 9) & 1) == (*(_BYTE *)(a2 + 9) & 1)) )
    {
      return 1LL;
    }
    return 0LL;
  }
  if ( v3 != 16 )
  {
    sub_12222(
      v21,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
      275LL);
    return 0xFFFFFFFFLL;
  }
  if ( *(_BYTE *)(*(_QWORD *)a1 + 30LL) )
  {
    v13 = *(__int64 **)(a1 + 64);
    v16 = *(_QWORD *)(a2 + 64);
    v19 = 0LL;
    for ( i = 0; i < *(unsigned __int8 *)(*(_QWORD *)a1 + 30LL); ++i )
    {
      if ( v12 && v13 )
      {
        if ( v19 )
        {
          v19 = *(_QWORD *)(v19 + 80);
        }
        else
        {
          v19 = sub_B28DB(v13, v21);
          if ( !v19 )
          {
            v4 = *(_QWORD *)*v13;
            v5 = lyd_node_module(v13);
            sub_12222(
              v21,
              0,
              3,
              "Target context does not contain a required schema node (%s:%s).",
              *(_QWORD *)(v5 + 8),
              v4);
            return 0xFFFFFFFFLL;
          }
        }
      }
      if ( !v13 || !v16 )
        break;
      v6 = v19 ? v19 : *v13;
      if ( v6 != *(_QWORD *)v16 || !(unsigned int)sub_ABE70((_BYTE **)v13, (_BYTE **)v16, v12) )
        break;
      v13 = (__int64 *)v13[3];
      v16 = *(_QWORD *)(v16 + 24);
    }
    if ( i == *(unsigned __int8 *)(*(_QWORD *)a1 + 30LL) )
      return 1LL;
    return 0LL;
  }
  if ( !*(_QWORD *)(a1 + 64) && !*(_QWORD *)(a2 + 64) )
    return 1LL;
  v14 = *(__int64 ***)(a1 + 64);
  for ( j = *(_QWORD *)(a2 + 64); v14 && j && *((_DWORD *)v14 + 12) == *(_DWORD *)(j + 48); j = v18 )
  {
    if ( v12 )
    {
      v20 = sub_B28DB((__int64 *)v14, v21);
      if ( !v20 )
      {
        v7 = **v14;
        v8 = lyd_node_module(v14);
        sub_12222(v21, 0, 3, "Target context does not contain a required schema node (%s:%s).", *(_QWORD *)(v8 + 8), v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v20 = (__int64)*v14;
    }
    if ( v20 != *(_QWORD *)j )
      break;
    if ( *(_DWORD *)(*(_QWORD *)j + 56LL) == 16 )
    {
      if ( !(unsigned int)sub_ABD8D(v14) && !(unsigned int)sub_ABD8D((_QWORD *)j) )
      {
        v15 = 0LL;
        v18 = 0LL;
        goto LABEL_51;
      }
    }
    else if ( *(_DWORD *)(*(_QWORD *)j + 56LL) & 0xC )
    {
      if ( !(unsigned int)sub_ABE70((_BYTE **)v14, (_BYTE **)j, v12)
        && (!v10 || (*((_BYTE *)v14 + 9) & 1) == (*(_BYTE *)(j + 9) & 1)) )
      {
        break;
      }
    }
    else if ( *(_DWORD *)(*(_QWORD *)j + 56LL) & 0x8020 && !(unsigned int)sub_ABBCE(v14, (_QWORD *)j) )
    {
      break;
    }
    if ( *(_DWORD *)(*(_QWORD *)j + 56LL) & 0x802C )
    {
      v15 = 0LL;
      v18 = 0LL;
    }
    else
    {
      v15 = v14[8];
      v18 = *(_QWORD *)(j + 64);
    }
LABEL_51:
    if ( !v15 )
      v15 = v14[3];
    if ( !v18 )
      v18 = *(_QWORD *)(j + 24);
    while ( !v15 )
    {
      v14 = (__int64 **)v14[5];
      if ( v14 == (__int64 **)a1 )
        break;
      v15 = v14[3];
    }
    while ( !v18 )
    {
      j = *(_QWORD *)(j + 40);
      if ( j == a2 )
        break;
      v18 = *(_QWORD *)(j + 24);
    }
    v14 = (__int64 **)v15;
  }
  if ( !v14 && !j )
    return 1LL;
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000AC44F) ----------------------------------------------------
signed __int64 __fastcall sub_AC44F(__int64 *a1, _QWORD **a2, int a3, __int64 a4)
{
  unsigned int v5; // eax
  __int64 v6; // [rsp+20h] [rbp-10h]
  _QWORD *v7; // [rsp+28h] [rbp-8h]

  v6 = *a1;
  v7 = *a2;
  if ( a3 )
    return v6 == (_QWORD)v7;
  if ( *(_QWORD *)v6 != *v7 )
    return 0LL;
  v5 = *(_DWORD *)(*(_QWORD *)v6 + 56LL);
  if ( v5 == 8 )
    return sub_ABF28(v6, (__int64)v7, 0);
  if ( v5 <= 8 )
  {
    if ( v5 != 1 && v5 != 4 )
      goto LABEL_16;
    return 1LL;
  }
  if ( v5 == 32 || v5 == 32800 )
    return 1LL;
  if ( v5 == 16 )
    return sub_ABF28(v6, (__int64)v7, 0);
LABEL_16:
  sub_12222(
    **(_QWORD **)(*(_QWORD *)v6 + 48LL),
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
    317LL,
    a4);
  return 0LL;
}

//----- (00000000000AC551) ----------------------------------------------------
void __fastcall sub_AC551(_QWORD *a1, unsigned int *a2)
{
  unsigned int v2; // eax
  _QWORD *i; // [rsp+8h] [rbp-8h]

  for ( i = a1; i; i = (_QWORD *)i[3] )
  {
    v2 = *(_DWORD *)(*i + 56LL);
    if ( v2 == 8 )
      goto LABEL_14;
    if ( v2 <= 8 )
    {
      if ( v2 == 1 )
      {
        sub_AC551(i[8], a2);
        continue;
      }
      if ( v2 != 4 )
        goto LABEL_15;
LABEL_14:
      *a2 = sub_1476E(*a2, (__int64)(i + 6), 4uLL);
      continue;
    }
    if ( v2 == 32 || v2 == 32800 )
      goto LABEL_14;
    if ( v2 != 16 )
LABEL_15:
      __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x156u, "lyd_hash_keyless_list_dfs");
    if ( (unsigned int)sub_ABD8D(i) )
      sub_AC551(i[8], a2);
  }
}

//----- (00000000000AC63C) ----------------------------------------------------
signed __int64 __fastcall sub_AC63C(const char **a1)
{
  __int64 v1; // rax
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rax
  signed int v8; // [rsp+14h] [rbp-1Ch]
  const char *v9; // [rsp+18h] [rbp-18h]

  if ( *((_DWORD *)a1 + 12) && (*((_DWORD *)*a1 + 14) != 16 || (*a1)[30]) )
    __assert_fail(
      "!node->hash || ((node->schema->nodetype == LYS_LIST) && !((struct lys_node_list *)node->schema)->keys_size)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x161u,
      "lyd_hash");
  if ( *((_DWORD *)*a1 + 14) == 16 && !(unsigned int)sub_ABD8D(a1) )
    return 1LL;
  v1 = lyd_node_module(a1);
  v2 = strlen(*(const char **)(v1 + 8));
  v3 = lyd_node_module(a1);
  *((_DWORD *)a1 + 12) = sub_1476E(0, *(_QWORD *)(v3 + 8), v2);
  v4 = strlen(*(const char **)*a1);
  *((_DWORD *)a1 + 12) = sub_1476E(*((_DWORD *)a1 + 12), *(_QWORD *)*a1, v4);
  if ( *((_DWORD *)*a1 + 14) == 8 )
  {
    v5 = strlen(a1[7]);
    *((_DWORD *)a1 + 12) = sub_1476E(*((_DWORD *)a1 + 12), (__int64)a1[7], v5);
  }
  else if ( *((_DWORD *)*a1 + 14) == 16 )
  {
    if ( (*a1)[30] )
    {
      v8 = 0;
      v9 = a1[8];
      while ( v8 < *((unsigned __int8 *)*a1 + 30) )
      {
        if ( !v9 )
          __assert_fail("iter", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x16Cu, "lyd_hash");
        v6 = strlen(*((const char **)v9 + 7));
        *((_DWORD *)a1 + 12) = sub_1476E(*((_DWORD *)a1 + 12), *((_QWORD *)v9 + 7), v6);
        ++v8;
        v9 = (const char *)*((_QWORD *)v9 + 3);
      }
    }
    else
    {
      sub_AC551(a1[8], (unsigned int *)a1 + 12);
    }
  }
  *((_DWORD *)a1 + 12) = sub_1476E(*((_DWORD *)a1 + 12), 0LL, 0LL);
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000AC884) ----------------------------------------------------
_QWORD *__fastcall sub_AC884(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax
  _QWORD *i; // [rsp+8h] [rbp-18h]
  int v8; // [rsp+1Ch] [rbp-4h]

  for ( i = a1; ; i = (_QWORD *)i[5] )
  {
    result = i;
    if ( !i )
      break;
    result = (_QWORD *)(*(_WORD *)(*i + 24LL) & 1);
    if ( (_DWORD)result )
      break;
    if ( *(_DWORD *)(*i + 56LL) == 16 )
    {
      if ( !*((_DWORD *)i + 12) || *(_BYTE *)(*i + 30LL) )
      {
        result = (_QWORD *)sub_ABD8D(i);
        if ( !(_DWORD)result )
          return result;
      }
      else
      {
        if ( i[5] )
        {
          if ( *(_QWORD *)(i[5] + 56LL) )
          {
            v8 = sub_15F8D(*(_QWORD *)(i[5] + 56LL), (__int64)&i, *((unsigned int *)i + 12), (__int64)&i, a5, a6);
            if ( v8 )
              __assert_fail(
                "!r",
                "/home/mantovan/Repositories/libyang/src/tree_data.c",
                0x187u,
                "lyd_keyless_list_hash_change");
          }
        }
        sub_AC63C((const char **)i);
        if ( i[5] && *(_QWORD *)(i[5] + 56LL) )
        {
          v8 = sub_15F55(*(_QWORD *)(i[5] + 56LL), &i, *((_DWORD *)i + 12), 0LL, a5, a6);
          if ( v8 )
            __assert_fail(
              "!r",
              "/home/mantovan/Repositories/libyang/src/tree_data.c",
              0x18Fu,
              "lyd_keyless_list_hash_change");
        }
      }
    }
  }
  return result;
}

//----- (00000000000AC9EF) ----------------------------------------------------
unsigned __int64 __fastcall sub_AC9EF(unsigned int *a1, unsigned int **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  int v8; // [rsp+4h] [rbp-3Ch]
  unsigned int *v9; // [rsp+8h] [rbp-38h]
  int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int *i; // [rsp+20h] [rbp-20h]
  unsigned __int64 v12; // [rsp+28h] [rbp-18h]

  v9 = a1;
  v8 = (signed int)a2;
  v12 = __readfsqword(0x28u);
  if ( *((_QWORD *)a1 + 5) && (*(_DWORD *)(*(_QWORD *)v9 + 56LL) != 16 || (unsigned int)sub_ABD8D(v9)) )
  {
    if ( *(_DWORD *)(*(_QWORD *)v9 + 56LL) == 4 )
    {
      a2 = 0LL;
      if ( lys_is_key(*(_QWORD *)v9, 0LL) )
      {
        if ( !(unsigned int)sub_AC63C(*((const char ***)v9 + 5)) )
        {
          a2 = 0LL;
          sub_AC9EF(*((_QWORD *)v9 + 5), 0LL);
        }
      }
    }
    if ( *(_QWORD *)(*((_QWORD *)v9 + 5) + 56LL) )
    {
      a2 = &v9;
      if ( (unsigned int)sub_15F55(*(_QWORD *)(*((_QWORD *)v9 + 5) + 56LL), &v9, v9[12], 0LL, a5, a6) )
        __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1C5u, "_lyd_insert_hash");
    }
    else
    {
      v10 = 0;
      for ( i = *(unsigned int **)(*((_QWORD *)v9 + 5) + 64LL); i; i = (unsigned int *)*((_QWORD *)i + 3) )
      {
        if ( *(_DWORD *)(*(_QWORD *)i + 56LL) == 16 && !(unsigned int)sub_ABD8D(i) )
          --v10;
        ++v10;
      }
      if ( v10 > 4 )
        __assert_fail(
          "i <= LY_CACHE_HT_MIN_CHILDREN",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0x1B4u,
          "_lyd_insert_hash");
      if ( v10 == 4 )
      {
        v6 = *((_QWORD *)v9 + 5);
        a2 = (unsigned int **)&byte_8;
        *(_QWORD *)(v6 + 56) = sub_14CB1(1u, 8, (__int64)sub_AC44F, 0LL, 1);
        for ( i = *(unsigned int **)(*((_QWORD *)v9 + 5) + 64LL); i; i = (unsigned int *)*((_QWORD *)i + 3) )
        {
          if ( *(_DWORD *)(*(_QWORD *)i + 56LL) != 16 || (unsigned int)sub_ABD8D(i) )
          {
            a2 = &i;
            if ( (unsigned int)sub_15F55(*(_QWORD *)(*((_QWORD *)v9 + 5) + 56LL), &i, i[12], 0LL, a5, a6) )
              __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1BFu, "_lyd_insert_hash");
          }
        }
      }
    }
    if ( v8 )
      sub_AC884(*((_QWORD **)v9 + 5), (__int64)a2, a3, a4, a5, a6);
  }
  return __readfsqword(0x28u) ^ v12;
}
// 8: using guessed type char;
// 7850: using guessed type __int64 __fastcall lys_is_key(_QWORD, _QWORD);

//----- (00000000000ACC62) ----------------------------------------------------
unsigned __int64 __fastcall sub_ACC62(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_AC9EF(a1, (unsigned int **)((char *)&size + 1), a3, a4, a5, a6);
}

//----- (00000000000ACC82) ----------------------------------------------------
void __fastcall sub_ACC82(_QWORD *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rsi
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int v11; // [rsp+Ch] [rbp-24h]
  __int64 v12; // [rsp+10h] [rbp-20h]
  _QWORD *v13; // [rsp+18h] [rbp-18h]
  _QWORD *i; // [rsp+28h] [rbp-8h]

  v13 = a1;
  v12 = a2;
  v11 = a3;
  if ( a3 && a2 )
  {
    for ( i = *(_QWORD **)(a2 + 64); i; i = (_QWORD *)i[3] )
    {
      if ( i == v13 )
        __assert_fail("iter != node", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1E1u, "_lyd_unlink_hash");
    }
  }
  if ( a2 && *((_DWORD *)v13 + 12) && (*(_DWORD *)(*v13 + 56LL) != 16 || (unsigned int)sub_ABD8D(v13)) )
  {
    if ( *(_QWORD *)(a2 + 56) )
    {
      if ( (unsigned int)sub_15F8D(
                           *(_QWORD *)(a2 + 56),
                           (__int64)&v13,
                           *((unsigned int *)v13 + 12),
                           (__int64)&v13,
                           a5,
                           a6) )
        __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1E9u, "_lyd_unlink_hash");
      if ( **(_DWORD **)(a2 + 56) <= 3u )
      {
        sub_14F6B(*(void ***)(a2 + 56));
        *(_QWORD *)(a2 + 56) = 0LL;
      }
    }
    v6 = 0LL;
    if ( lys_is_key(*v13, 0LL) && *(_DWORD *)(v12 + 48) )
    {
      if ( *(_DWORD *)(*(_QWORD *)v12 + 56LL) != 16 || (unsigned int)sub_ABD8D((_QWORD *)v12) )
        __assert_fail(
          "(orig_parent->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(orig_parent)",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0x1F5u,
          "_lyd_unlink_hash");
      v6 = *(_QWORD *)(v12 + 40);
      sub_ACC82(v12, v6, 0LL);
      *(_DWORD *)(v12 + 48) = 0;
    }
    if ( v11 )
      sub_AC884((_QWORD *)v12, v6, v7, v8, v9, v10);
  }
}
// 7850: using guessed type __int64 __fastcall lys_is_key(_QWORD, _QWORD);

//----- (00000000000ACE40) ----------------------------------------------------
void __fastcall sub_ACE40(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_ACC82(a1, a2, 1, a2, a5, a6);
}

//----- (00000000000ACE6B) ----------------------------------------------------
__int64 __fastcall sub_ACE6B(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  _QWORD *i; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a3 || *(_DWORD *)(a3 + 4) )
    __assert_fail(
      "set && !set->number",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x213u,
      "lyd_get_node_siblings");
  if ( !a2 )
    __assert_fail("schema", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x214u, "lyd_get_node_siblings");
  if ( !(*(_DWORD *)(a2 + 56) & 0xC1BD) )
    __assert_fail(
      "schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x216u,
      "lyd_get_node_siblings");
  if ( !a1 )
    return 0LL;
  for ( i = a1; i; i = (_QWORD *)i[3] )
  {
    if ( a2 == *i )
      ly_set_add(v4, i, 1LL);
  }
  return *(unsigned int *)(v4 + 4);
}
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (00000000000ACF5E) ----------------------------------------------------
signed __int64 __fastcall sub_ACF5E(_QWORD *a1, _QWORD *a2, __int64 a3, int a4)
{
  __int64 v4; // rax
  __int64 v6; // [rsp+8h] [rbp-38h]
  int v7; // [rsp+24h] [rbp-1Ch]
  _BYTE *i; // [rsp+28h] [rbp-18h]
  _BYTE *v9; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v10 = __readfsqword(0x28u);
  if ( !(a4 & 0x10000FF) || a4 & 0x1000071 )
  {
    v4 = a2 ? *a2 : 0LL;
    if ( (unsigned int)sub_28290(a3, 1, v4) )
    {
      if ( *(_DWORD *)(v6 + 56) == 2 )
        v6 = lys_getnext(0LL, v6, 0LL, 256LL);
      v9 = sub_B20A7(a1, a2, v6, 0LL, 0);
      if ( !v9 )
        return 0xFFFFFFFFLL;
      if ( !*((_QWORD *)v9 + 5) )
      {
        if ( a1 )
          lyd_insert_before(a1, v9);
      }
      for ( i = v9; i; i = (_BYTE *)*((_QWORD *)i + 8) )
      {
        sub_141E4(0LL, 2u, &v7, 0LL);
        sub_28399((__int64)i, 0, 0LL);
        sub_142D2(0LL, v7, 0LL, 0);
        if ( (i[9] >> 1) & 1 )
        {
          lyd_free(v9);
          return 1LL;
        }
        if ( *(_DWORD *)(*(_QWORD *)i + 56LL) & 0x802C )
          break;
      }
      lyd_free(v9);
    }
  }
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7560: using guessed type __int64 __fastcall lyd_insert_before(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000AD12C) ----------------------------------------------------
signed __int64 __fastcall sub_AD12C(_QWORD *a1, __int64 **a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  unsigned int v7; // eax
  __int64 v8; // rax
  int v9; // [rsp+Ch] [rbp-34h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  __int16 v12; // [rsp+32h] [rbp-Eh]
  unsigned int v13; // [rsp+34h] [rbp-Ch]
  unsigned int v14; // [rsp+34h] [rbp-Ch]
  unsigned int v15; // [rsp+34h] [rbp-Ch]
  unsigned int v16; // [rsp+34h] [rbp-Ch]
  void *v17; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v17 = **(void ***)(a4 + 48);
  if ( !*(_DWORD *)(a3 + 4) )
  {
    v12 = *(_WORD *)(a4 + 24) & 0x38;
    if ( lys_is_disabled(a4, 2LL) || v12 && v12 != 8 )
      return 0LL;
    if ( v9 & 0x2000 || v9 & 0x10000FF && *(_WORD *)(v10 + 24) & 2 )
      return 0LL;
    if ( (unsigned int)sub_ACF5E(a1, a2, v10, v9) )
      return 0LL;
  }
  v7 = *(_DWORD *)(v10 + 56);
  if ( v7 == 16 )
  {
    v13 = *(_DWORD *)(v10 + 152);
    if ( v13 && v13 > *(_DWORD *)(v11 + 4) )
    {
      sub_13937(v17, 62, 3u, (char *)a2, *(_QWORD *)v10, a6);
      return 1LL;
    }
    v14 = *(_DWORD *)(v10 + 156);
    if ( v14 && v14 < *(_DWORD *)(v11 + 4) )
    {
      sub_13937(v17, 63, 3u, *(char **)(8LL * v14 + *(_QWORD *)(v11 + 8)), *(_QWORD *)v10, a6);
      return 1LL;
    }
    return 0LL;
  }
  if ( v7 > 0x10 )
  {
    if ( v7 != 32 && v7 != 32800 )
LABEL_37:
      __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x2A1u, "lyd_check_mandatory_data");
  }
  else if ( v7 != 4 )
  {
    if ( v7 != 8 )
      goto LABEL_37;
    v15 = *(_DWORD *)(v10 + 208);
    if ( v15 && v15 > *(_DWORD *)(v11 + 4) )
    {
      sub_13937(v17, 62, 3u, (char *)a2, *(_QWORD *)v10, a6);
      return 1LL;
    }
    v16 = *(_DWORD *)(v10 + 212);
    if ( v16 && v16 < *(_DWORD *)(v11 + 4) )
    {
      sub_13937(v17, 63, 3u, *(char **)(8LL * v16 + *(_QWORD *)(v11 + 8)), *(_QWORD *)v10, a6);
      return 1LL;
    }
    return 0LL;
  }
  if ( !(*(_WORD *)(v10 + 24) & 0x40) || *(_DWORD *)(v11 + 4) )
    return 0LL;
  if ( a2 )
    v8 = **a2;
  else
    v8 = *(_QWORD *)(lys_node_module(v10) + 8);
  sub_13937(v17, 49, 3u, (char *)a2, *(_QWORD *)v10, v8);
  return 1LL;
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000AD45A) ----------------------------------------------------
__int64 __fastcall sub_AD45A(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  __int64 v6; // r9
  unsigned int v8; // eax
  char *v9; // rax
  __int64 v10; // rsi
  __int64 *v11; // rax
  __int64 v12; // r9
  unsigned int v13; // [rsp+8h] [rbp-58h]
  unsigned int v14; // [rsp+Ch] [rbp-54h]
  __int64 v15; // [rsp+10h] [rbp-50h]
  char *v16; // [rsp+18h] [rbp-48h]
  unsigned int l; // [rsp+38h] [rbp-28h]
  unsigned int v18; // [rsp+3Ch] [rbp-24h]
  __int64 v19; // [rsp+40h] [rbp-20h]
  __int64 m; // [rsp+40h] [rbp-20h]
  __int64 j; // [rsp+40h] [rbp-20h]
  __int64 i; // [rsp+40h] [rbp-20h]
  __int64 v23; // [rsp+48h] [rbp-18h]
  __int64 *k; // [rsp+50h] [rbp-10h]
  __int64 v25; // [rsp+58h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  v25 = 0LL;
  v18 = 1;
  if ( !a4 )
    __assert_fail(
      "schema",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x2C5u,
      "lyd_check_mandatory_subtree");
  if ( lys_is_disabled(a4, 0LL) )
    return 0LL;
  if ( *(_DWORD *)(v15 + 56) & 0x803D )
  {
    v25 = ly_set_new(v15);
    if ( !v25 )
      goto LABEL_91;
    if ( v14 && a1 || !v14 && a2 )
    {
      if ( v14 )
        sub_ACE6B(a1, v15, v25);
      else
        sub_ACE6B(*(_QWORD **)(a2 + 64), v15, v25);
    }
  }
  v8 = *(_DWORD *)(v15 + 56);
  if ( v8 == 32 )
    goto LABEL_33;
  if ( v8 > 0x20 )
  {
    if ( v8 != 512 )
    {
      if ( v8 > 0x200 )
      {
        if ( v8 != 4096 )
        {
          if ( v8 == 32800 )
            goto LABEL_33;
          if ( v8 != 1024 )
            goto LABEL_90;
        }
      }
      else if ( v8 != 64 && (v8 != 128 || !(v13 & 0x40)) )
      {
        goto LABEL_90;
      }
    }
    for ( i = *(_QWORD *)(v15 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( (unsigned int)sub_AD45A(a1, a2, v16, i, v14, v13) )
        goto LABEL_91;
    }
    goto LABEL_90;
  }
  if ( v8 == 4 )
    goto LABEL_33;
  if ( v8 <= 4 )
  {
    if ( v8 == 1 )
    {
      if ( *(_DWORD *)(v25 + 4) || !*(_QWORD *)(v15 + 136) )
      {
        for ( j = *(_QWORD *)(v15 + 72); j; j = *(_QWORD *)(j + 80) )
        {
          if ( *(_DWORD *)(v25 + 4) )
            v9 = **(char ***)(v25 + 8);
          else
            v9 = v16;
          if ( *(_DWORD *)(v25 + 4) )
            v10 = **(_QWORD **)(v25 + 8);
          else
            v10 = 0LL;
          if ( (unsigned int)sub_AD45A(a1, v10, v9, j, 0LL, v13) )
            goto LABEL_91;
        }
      }
    }
    else if ( v8 == 2 )
    {
      k = 0LL;
      if ( v14 && a1 || !v14 && a2 )
      {
        if ( v14 )
          v11 = a1;
        else
          v11 = *(__int64 **)(a2 + 64);
        for ( k = v11; k; k = (__int64 *)k[3] )
        {
          v19 = lys_parent(*k);
          v23 = *k;
          while ( v19 && *(_DWORD *)(v19 + 56) & 0x1042 && v19 != v15 )
          {
            v23 = v19;
            v19 = lys_parent(v19);
          }
          if ( v19 == v15 )
            break;
        }
      }
      if ( k )
      {
        if ( !v19 || !v23 )
          __assert_fail(
            "siter && siter_prev",
            "/home/mantovan/Repositories/libyang/src/tree_data.c",
            0x32Au,
            "lyd_check_mandatory_subtree");
        if ( (unsigned int)sub_AD45A(a1, a2, v16, v23, v14, v13) )
          goto LABEL_91;
        goto LABEL_90;
      }
      if ( !(unsigned int)sub_ACF5E(a1, v16, v15, v13) )
      {
        if ( *(_QWORD *)(v15 + 112) )
        {
          if ( (unsigned int)sub_AD45A(a1, a2, v16, *(_QWORD *)(v15 + 112), v14, v13) )
            goto LABEL_91;
          goto LABEL_90;
        }
        if ( *(_WORD *)(v15 + 24) & 0x40 )
        {
          sub_13937(**(void ***)(v15 + 48), 66, 3u, v16, *(_QWORD *)v15, v12);
          goto LABEL_91;
        }
      }
    }
LABEL_90:
    v18 = 0;
    goto LABEL_91;
  }
  if ( v8 == 8 )
  {
LABEL_33:
    if ( (unsigned int)sub_AD12C(a1, (__int64 **)v16, v25, v15, v13, v6) )
      goto LABEL_91;
    goto LABEL_90;
  }
  if ( v8 != 16 )
    goto LABEL_90;
  if ( !(unsigned int)sub_AD12C(a1, (__int64 **)v16, v25, v15, v13, v6) )
  {
    for ( l = 0; l < *(_DWORD *)(v25 + 4); ++l )
    {
      for ( m = *(_QWORD *)(v15 + 72); m; m = *(_QWORD *)(m + 80) )
      {
        if ( (unsigned int)sub_AD45A(
                             a1,
                             *(_QWORD *)(8LL * l + *(_QWORD *)(v25 + 8)),
                             *(_QWORD *)(8LL * l + *(_QWORD *)(v25 + 8)),
                             m,
                             0LL,
                             v13) )
          goto LABEL_91;
      }
    }
    goto LABEL_90;
  }
LABEL_91:
  ly_set_free(v25);
  return v18;
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);

//----- (00000000000AD9B9) ----------------------------------------------------
signed __int64 __fastcall sub_AD9B9(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v7; // [rsp+0h] [rbp-30h]
  __int64 v8; // [rsp+8h] [rbp-28h]
  __int64 v9; // [rsp+10h] [rbp-20h]
  __int64 v10; // [rsp+24h] [rbp-Ch]
  int k; // [rsp+24h] [rbp-Ch]
  __int64 j; // [rsp+28h] [rbp-8h]
  __int64 l; // [rsp+28h] [rbp-8h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v9 = a2;
  v8 = a3;
  v7 = __PAIR__(a4, (unsigned int)a5);
  if ( !a1 && !a2 )
    __assert_fail(
      "root || ctx",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x354u,
      "lyd_check_mandatory_tree");
  if ( a5 & 0x100 )
    __assert_fail(
      "!(options & LYD_OPT_ACT_NOTIF)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x355u,
      "lyd_check_mandatory_tree");
  if ( a5 & 0x200E )
    return 0LL;
  if ( !a2 )
    v9 = **(_QWORD **)(*a1 + 48);
  if ( a5 & 0x10000FF && !(a5 & 1) )
  {
    if ( a5 & 0x40 )
    {
      if ( !a1 || *(_DWORD *)(*a1 + 56) != 128 )
      {
        sub_12222(v9, 0, 3, "Subtree is not a single notification.", a5, a6, __PAIR__(a4, (unsigned int)a5));
        return 1LL;
      }
      if ( *(_QWORD *)(*a1 + 72) && (unsigned int)sub_AD45A(a1, (__int64)a1, (char *)a1, *a1, 0, a5) )
        return 1LL;
    }
    else if ( a5 & 0x30 )
    {
      if ( !a1 || !(*(_DWORD *)(*a1 + 56) & 0x4100) )
      {
        sub_12222(v9, 0, 3, "Subtree is not a single RPC/action/reply.", a5, a6, __PAIR__(a4, (unsigned int)a5));
        return 1LL;
      }
      if ( a5 & 0x10 )
      {
        for ( i = *(_QWORD *)(*a1 + 72); i && *(_DWORD *)(i + 56) != 512; i = *(_QWORD *)(i + 80) )
          ;
      }
      else
      {
        for ( i = *(_QWORD *)(*a1 + 72); i && *(_DWORD *)(i + 56) != 1024; i = *(_QWORD *)(i + 80) )
          ;
      }
      if ( i && (unsigned int)sub_AD45A(a1, (__int64)a1, (char *)a1, i, 0, a5) )
        return 1LL;
    }
    else
    {
      if ( !(a5 & 0x1000000) )
      {
        sub_12222(
          v9,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          923LL,
          __PAIR__(a4, (unsigned int)a5));
        return 1LL;
      }
      if ( a1 && (unsigned int)sub_AD45A(a1, 0LL, 0LL, *a1, 1u, a5) )
        return 1LL;
    }
  }
  else if ( a5 & 0x1000 )
  {
    if ( a1 && (unsigned int)sub_AD45A(a1, 0LL, 0LL, *a1, 1u, a5) )
      return 1LL;
  }
  else if ( a3 && a4 )
  {
    LODWORD(v10) = 0;
    while ( (signed int)v10 < SHIDWORD(v7) )
    {
      for ( j = *(_QWORD *)(*(_QWORD *)(8LL * (signed int)v10 + v8) + 168LL); j; j = *(_QWORD *)(j + 80) )
      {
        if ( !(*(_DWORD *)(j + 56) & 0x180) && (unsigned int)sub_AD45A(a1, 0LL, 0LL, j, 1u, v7) )
          return 1LL;
      }
      v10 = (unsigned int)(v10 + 1);
    }
  }
  else
  {
    for ( k = 0; k < *(_DWORD *)(v9 + 60); ++k )
    {
      if ( *(_BYTE *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 64)) + 64LL) < 0
        && !(*(_BYTE *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 64)) + 64LL) & 0x40)
        && (!(v7 & 0x10000)
         || strcmp(*(const char **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 64)) + 8LL), "ietf-yang-library")) )
      {
        for ( l = *(_QWORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v9 + 64)) + 168LL); l; l = *(_QWORD *)(l + 80) )
        {
          if ( !(*(_DWORD *)(l + 56) & 0x180) && (unsigned int)sub_AD45A(a1, 0LL, 0LL, l, 1u, v7) )
            return 1LL;
        }
      }
    }
  }
  return 0LL;
}

//----- (00000000000ADEE6) ----------------------------------------------------
__int64 __fastcall sub_ADEE6(__int64 a1, __int64 *a2, __int64 a3, int a4, unsigned int a5, __int64 a6, char *a7)
{
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-48h]
  unsigned int v9; // [rsp+10h] [rbp-40h]
  int v10; // [rsp+14h] [rbp-3Ch]
  __int64 v11; // [rsp+18h] [rbp-38h]
  unsigned int v12; // [rsp+34h] [rbp-1Ch]
  __int64 v13; // [rsp+38h] [rbp-18h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  v15 = __readfsqword(0x28u);
  v14 = 0LL;
  v12 = 1;
  if ( a1 && a3 )
  {
    if ( a5 & 0x1000 )
      v12 = 0;
    *(_DWORD *)ly_errno_glob_address(a1) = 0;
    switch ( v10 )
    {
      case 2:
        v14 = sub_6D5D5(a1, v11, v9, a2, v8, (__int64)a7);
        break;
      case 3:
        v14 = (__int64)sub_7168F(a1, v11, v9, v8, a7, 0LL);
        break;
      case 1:
        v13 = lyxml_parse_mem(a1, v11, v12);
        if ( !*(_DWORD *)ly_errno_glob_address(a1) )
        {
          v14 = lyd_parse_xml(a1, &v13, v9);
          lyxml_free_withsiblings(a1, v13);
        }
        break;
    }
    if ( *(_DWORD *)ly_errno_glob_address(a1) )
    {
      lyd_free_withsiblings(v14);
      result = 0LL;
    }
    else if ( v9 & 0x30 && (unsigned int)lyd_schema_sort(v14, 1LL) )
    {
      lyd_free_withsiblings(v14);
      result = 0LL;
    }
    else
    {
      result = v14;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_parse_", a6, a7);
    result = 0LL;
  }
  return result;
}
// 71D0: using guessed type __int64 __fastcall lyd_schema_sort(_QWORD, _QWORD);
// 7270: using guessed type __int64 __fastcall ly_errno_glob_address(_QWORD);
// 7510: using guessed type __int64 __fastcall lyxml_parse_mem(_QWORD, _QWORD, _QWORD);
// 75F0: using guessed type __int64 __fastcall lyxml_free_withsiblings(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7940: using guessed type __int64 __fastcall lyd_parse_xml(_QWORD, _QWORD, _QWORD);

//----- (00000000000AE151) ----------------------------------------------------
__int64 __fastcall sub_AE151(__int64 a1, __int64 a2, int a3, unsigned int a4, unsigned int *a5)
{
  __int64 v5; // r9
  __int64 result; // rax
  __int64 **v7; // rax
  __int64 *v8; // rax
  char **v9; // rax
  unsigned int *v10; // [rsp+0h] [rbp-40h]
  unsigned int v11; // [rsp+8h] [rbp-38h]
  int v12; // [rsp+Ch] [rbp-34h]
  __int64 *v13; // [rsp+20h] [rbp-20h]
  __int64 v14; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+30h] [rbp-10h]
  char *v16; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v13 = 0LL;
  v14 = 0LL;
  v16 = 0LL;
  if ( (unsigned int)sub_34DD2(a1, a4, (__int64)"lyd_parse_data_") )
    return 0LL;
  if ( v11 & 0x20 )
  {
    if ( *v10 > 0x2F )
    {
      v7 = (__int64 **)*((_QWORD *)v10 + 1);
      *((_QWORD *)v10 + 1) = v7 + 1;
    }
    else
    {
      v7 = (__int64 **)(*((_QWORD *)v10 + 2) + *v10);
      *v10 += 8;
    }
    v13 = *v7;
    if ( !*v7 || v13[5] || !(*(_DWORD *)(*v13 + 56) & 0x111) )
    {
      sub_12222(
        a1,
        0,
        3,
        "%s: invalid variable parameter (const struct lyd_node *rpc_act).",
        (__int64)"lyd_parse_data_",
        v5,
        v10);
      return 0LL;
    }
  }
  if ( !(v11 & 0x70) )
    goto LABEL_36;
  if ( *v10 > 0x2F )
  {
    v8 = (__int64 *)*((_QWORD *)v10 + 1);
    *((_QWORD *)v10 + 1) = v8 + 1;
  }
  else
  {
    v8 = (__int64 *)(*((_QWORD *)v10 + 2) + *v10);
    *v10 += 8;
  }
  v14 = *v8;
  if ( !*v8 )
    goto LABEL_36;
  if ( v11 & 0x8000 )
  {
    sub_12222(
      a1,
      0,
      3,
      "%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).",
      (__int64)"lyd_parse_data_",
      v5,
      v10);
    return 0LL;
  }
  for ( i = *v8; i; i = *(_QWORD *)(i + 24) )
  {
    if ( *(_QWORD *)(i + 40) )
    {
      sub_12222(
        a1,
        0,
        3,
        "%s: invalid variable parameter (const struct lyd_node *data_tree).",
        (__int64)"lyd_parse_data_",
        v5,
        v10);
      return 0LL;
    }
  }
  while ( *(_QWORD *)(*(_QWORD *)(v14 + 32) + 24LL) )
    v14 = *(_QWORD *)(v14 + 32);
  if ( v11 & 0x1000 )
  {
    sub_12222(
      a1,
      0,
      3,
      "%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).",
      (__int64)"lyd_parse_data_",
      v5,
      v10);
    result = 0LL;
  }
  else
  {
LABEL_36:
    if ( v11 & 0x1000000 )
    {
      if ( *v10 > 0x2F )
      {
        v9 = (char **)*((_QWORD *)v10 + 1);
        *((_QWORD *)v10 + 1) = v9 + 1;
      }
      else
      {
        v9 = (char **)(*((_QWORD *)v10 + 2) + *v10);
        *v10 += 8;
      }
      v16 = *v9;
    }
    result = sub_ADEE6(a1, v13, a2, v12, v11, v14, v16);
  }
  return result;
}

//----- (00000000000AE43F) ----------------------------------------------------
__int64 lyd_parse_mem(__int64 a1, __int64 a2, int a3, __int64 a4, ...)
{
  int v4; // ST0C_4
  unsigned int v5; // ST08_4
  gcc_va_list va; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v8; // [rsp+48h] [rbp-B8h]
  __int64 v9; // [rsp+70h] [rbp-90h]
  __int64 v10; // [rsp+78h] [rbp-88h]

  va_start(va, a4);
  v9 = va_arg(va, _QWORD);
  v10 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a4);
  v4 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_parse_mem", a4, v9, v10);
  return sub_AE151(a1, a2, v4, v5, (unsigned int *)va);
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AE545) ----------------------------------------------------
__int64 __fastcall sub_AE545(__int64 a1, int a2, int a3, unsigned int a4, unsigned int *a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r9
  unsigned int *v8; // [rsp+0h] [rbp-40h]
  unsigned int v9; // [rsp+Ch] [rbp-34h]
  int v10; // [rsp+10h] [rbp-30h]
  size_t v11; // [rsp+20h] [rbp-20h]
  void *v12; // [rsp+28h] [rbp-18h]
  __int64 v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v14 = __readfsqword(0x28u);
  if ( a1 && a2 != -1 )
  {
    if ( (unsigned int)sub_34EE2(a1, a2, 0LL, &v11, &v12) )
    {
      sub_12222(a1, 0, 2, "Mapping file descriptor into memory failed (%s()).", (__int64)"lyd_parse_fd_", v7, v8);
      result = 0LL;
    }
    else if ( v12 )
    {
      v13 = sub_AE151(a1, (__int64)v12, v10, v9, v8);
      sub_351B4(v12, v11);
      result = v13;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_parse_fd_", a6, a5);
    result = 0LL;
  }
  return result;
}

//----- (00000000000AE65F) ----------------------------------------------------
__int64 lyd_parse_fd(__int64 a1, int a2, int a3, __int64 a4, ...)
{
  int v4; // ST10_4
  unsigned int v5; // ST0C_4
  __int64 v6; // r9
  gcc_va_list va; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v9; // [rsp+48h] [rbp-B8h]
  __int64 v10; // [rsp+70h] [rbp-90h]
  __int64 v11; // [rsp+78h] [rbp-88h]

  va_start(va, a4);
  v10 = va_arg(va, _QWORD);
  v11 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a4);
  v4 = a3;
  v5 = a4;
  v9 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_parse_fd", a4, v10, v11);
  return sub_AE545(a1, a2, v4, v5, (unsigned int *)va, v6);
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AE763) ----------------------------------------------------
__int64 lyd_parse_path(__int64 a1, const char *a2, int a3, __int64 a4, ...)
{
  __int64 v4; // r9
  __int64 result; // rax
  __int64 v6; // r9
  int *v7; // rax
  char *v8; // rax
  __int64 v9; // ST28_8
  unsigned int v10; // [rsp+8h] [rbp-F8h]
  int v11; // [rsp+Ch] [rbp-F4h]
  int fd; // [rsp+24h] [rbp-DCh]
  gcc_va_list va; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v14; // [rsp+48h] [rbp-B8h]
  __int64 v15; // [rsp+70h] [rbp-90h]
  __int64 v16; // [rsp+78h] [rbp-88h]

  va_start(va, a4);
  v15 = va_arg(va, _QWORD);
  v16 = va_arg(va, _QWORD);
  va_end(va);
  v11 = a3;
  v10 = a4;
  v14 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_parse_path", a4, v15, v16);
  if ( a1 && a2 )
  {
    fd = open(a2, 0);
    if ( fd == -1 )
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      sub_12222(a1, 0, 2, "Failed to open data file \"%s\" (%s).", (__int64)a2, (__int64)v8);
      result = 0LL;
    }
    else
    {
      va_start(va, a4);
      v9 = sub_AE545(a1, fd, v11, v10, (unsigned int *)va, v6);
      close(fd);
      result = v9;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_parse_path", v4);
    result = 0LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AE92C) ----------------------------------------------------
__int64 __fastcall sub_AE92C(__int64 a1, __int64 a2, int a3)
{
  signed int v4; // edx
  signed int v5; // edx
  int v6; // [rsp+0h] [rbp-24h]
  __int64 v7; // [rsp+1Ch] [rbp-8h]

  v6 = a3;
  if ( !a1 )
    return *(_QWORD *)(a2 + 168);
  if ( !*(_QWORD *)a1 )
    return 0LL;
  v7 = *(_QWORD *)(*(_QWORD *)a1 + 72LL);
  if ( v7 )
  {
    v4 = a3 ? 512 : 1024;
    if ( v4 == *(_DWORD *)(v7 + 56) )
      v7 = *(_QWORD *)(v7 + 80);
  }
  if ( v7 )
  {
    if ( v6 )
      v5 = 1024;
    else
      v5 = 512;
    if ( v5 == *(_DWORD *)(v7 + 56) )
      v7 = *(_QWORD *)(v7 + 72);
  }
  return v7;
}

//----- (00000000000AE9DE) ----------------------------------------------------
_BYTE *__fastcall sub_AE9DE(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // r9
  _BYTE *result; // rax
  char v5; // [rsp+Ch] [rbp-24h]
  _BYTE *v6; // [rsp+28h] [rbp-8h]

  v5 = a3;
  v6 = calloc(1uLL, 0x48uLL);
  if ( v6 )
  {
    *(_QWORD *)v6 = a2;
    v6[8] = sub_C3AB(a2);
    if ( (unsigned int)sub_28290(a2, 0, 0LL) )
      v6[9] = v6[9] & 0xF1 | 8;
    *((_QWORD *)v6 + 4) = v6;
    v6[9] = v5 & 1 | v6[9] & 0xFE;
    sub_AC63C((const char **)v6);
    if ( a1 && (unsigned int)lyd_insert(a1, v6) )
    {
      lyd_free(v6);
      result = 0LL;
    }
    else
    {
      result = v6;
    }
  }
  else
  {
    sub_12222(**(_QWORD **)(a2 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"_lyd_new", v3);
    result = 0LL;
  }
  return result;
}
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000AEAFA) ----------------------------------------------------
_BYTE *__fastcall lyd_new(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  _BYTE *result; // rax
  __int64 v8; // r9
  int v9; // ebx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+28h] [rbp-28h]
  __int64 *v15; // [rsp+30h] [rbp-20h]
  unsigned __int64 v16; // [rsp+38h] [rbp-18h]

  s = a3;
  v16 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new", a4, a5, a6);
  v14 = 0LL;
  if ( (a1 || a2) && s )
  {
    v15 = (__int64 *)sub_AE92C(a1, a2, 0);
    if ( v15 )
    {
      v9 = strlen(s);
      v10 = lys_parent(v15);
      if ( !(unsigned int)sub_9B536(a2, v10, s, v9, 16785, 0, (const char ***)&v14) && v14 )
      {
        result = sub_AE9DE(a1, v14, 0);
      }
      else
      {
        v11 = *v15;
        v12 = lys_node_module(v15);
        sub_12222(
          *(_QWORD *)v15[6],
          0,
          3,
          "Failed to find \"%s\" as a sibling to \"%s:%s\".",
          (__int64)s,
          *(_QWORD *)(v12 + 8),
          v11);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new", v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new", v6);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AECBE) ----------------------------------------------------
_BYTE *__fastcall sub_AECBE(__int64 a1, void *a2, char a3)
{
  __int64 v3; // r9
  _BYTE *result; // rax
  void *v5; // rax
  char v6; // [rsp+Ch] [rbp-24h]
  _BYTE *v7; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v7 = calloc(1uLL, 0x50uLL);
  if ( v7 )
  {
    *(_QWORD *)v7 = a1;
    v7[8] = sub_C3AB(a1);
    if ( (unsigned int)sub_28290(a1, 0, 0LL) )
      v7[9] = v7[9] & 0xF1 | 8;
    *((_QWORD *)v7 + 4) = v7;
    *((_DWORD *)v7 + 18) = *(_DWORD *)(a1 + 128);
    if ( a2 )
      v5 = a2;
    else
      v5 = &unk_12274D;
    *((_QWORD *)v7 + 7) = lydict_insert(**(_QWORD **)(a1 + 48), v5, 0LL);
    v7[9] = v6 & 1 | v7[9] & 0xFE;
    sub_AC63C((const char **)v7);
    result = v7;
  }
  else
  {
    sub_12222(**(_QWORD **)(a1 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_create_leaf", v3);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000AEDF4) ----------------------------------------------------
char **__fastcall sub_AEDF4(__int64 a1, __int64 a2, void *a3, unsigned int a4, unsigned int a5)
{
  char **result; // rax
  unsigned __int64 v6; // [rsp+0h] [rbp-30h]
  void *v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+18h] [rbp-18h]
  char **v9; // [rsp+28h] [rbp-8h]

  v8 = a1;
  v7 = a3;
  v6 = __PAIR__(a4, a5);
  v9 = (char **)sub_AECBE(a2, a3, a4);
  if ( !v9 )
    return 0LL;
  if ( a1 && (unsigned int)lyd_insert(a1, v9) )
  {
    lyd_free(v9);
    result = 0LL;
  }
  else if ( !(_DWORD)v6 || *v9[7] )
  {
    if ( sub_37EF5((signed __int64)(*v9 + 128), v9 + 7, 0LL, (__int64 **)v9, 0LL, 0LL, 1, SHIDWORD(v6), 0) )
    {
      if ( *((_DWORD *)*v9 + 14) == 4 && *((_WORD *)*v9 + 12) & 0x100 )
      {
        while ( v8 && *(_DWORD *)(*(_QWORD *)v8 + 56LL) != 16 )
          v8 = *(_QWORD *)(v8 + 40);
        if ( v8 )
          *(_BYTE *)(v8 + 8) |= 2u;
        else
          sub_12222(
            **(_QWORD **)(a2 + 48),
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
            1268LL,
            v6,
            v7);
      }
      result = v9;
    }
    else
    {
      lyd_free(v9);
      result = 0LL;
    }
  }
  else
  {
    *((_DWORD *)v9 + 18) = 20;
    result = v9;
  }
  return result;
}
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000AEF9C) ----------------------------------------------------
char **__fastcall lyd_new_leaf(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  char **result; // rax
  __int64 v8; // r9
  int v9; // ebx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  void *v13; // [rsp+0h] [rbp-50h]
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v15; // [rsp+28h] [rbp-28h]
  __int64 *v16; // [rsp+30h] [rbp-20h]
  unsigned __int64 v17; // [rsp+38h] [rbp-18h]

  s = a3;
  v17 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_leaf", a4, a5, a6, a4);
  v15 = 0LL;
  if ( (a1 || a2) && s )
  {
    v16 = (__int64 *)sub_AE92C(a1, a2, 0);
    if ( v16 )
    {
      v9 = strlen(s);
      v10 = lys_parent(v16);
      if ( !(unsigned int)sub_9B536(a2, v10, s, v9, 12, 0, (const char ***)&v15) && v15 )
      {
        result = sub_AEDF4(a1, v15, v13, 0, 0);
      }
      else
      {
        v11 = *v16;
        v12 = lys_node_module(v16);
        sub_12222(
          *(_QWORD *)v16[6],
          0,
          3,
          "Failed to find \"%s\" as a sibling to \"%s:%s\".",
          (__int64)s,
          *(_QWORD *)(v12 + 8),
          v11);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_leaf", v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_leaf", v6);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AF16B) ----------------------------------------------------
__int64 __fastcall sub_AF16B(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+0h] [rbp-18h]
  _BYTE *i; // [rsp+8h] [rbp-10h]
  __int64 j; // [rsp+10h] [rbp-8h]

  v2 = a1;
  result = *(_QWORD *)(a1 + 40);
  for ( i = *(_BYTE **)(a1 + 40); i; i = *(_BYTE **)(v2 + 40) )
  {
    result = i[9] & 1;
    if ( (_BYTE)result )
      break;
    result = *(unsigned int *)(*(_QWORD *)i + 56LL);
    if ( (_DWORD)result != 1 )
      break;
    result = *(_QWORD *)(*(_QWORD *)i + 136LL);
    if ( result )
      break;
    for ( j = *(_QWORD *)(v2 + 32); j != v2 && *(_BYTE *)(j + 9) & 1; j = *(_QWORD *)(j + 32) )
      ;
    result = j;
    if ( j != v2 )
      break;
    result = *(_QWORD *)(v2 + 32);
    if ( v2 == result )
      break;
    v2 = *(_QWORD *)(v2 + 40);
    *(_BYTE *)(v2 + 9) |= 1u;
    result = *(_QWORD *)(v2 + 40);
  }
  return result;
}

//----- (00000000000AF24B) ----------------------------------------------------
unsigned __int64 __fastcall sub_AF24B(_QWORD *a1)
{
  unsigned __int64 result; // rax
  unsigned int j; // [rsp+1Ch] [rbp-34h]
  unsigned int k; // [rsp+20h] [rbp-30h]
  signed int v4; // [rsp+24h] [rbp-2Ch]
  _QWORD *i; // [rsp+28h] [rbp-28h]
  _QWORD *v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  __int64 v9; // [rsp+48h] [rbp-8h]

  v4 = 0;
  result = (unsigned __int64)a1;
  for ( i = a1; i; i = v6 )
  {
    if ( *(_DWORD *)(*i + 56LL) & 0xC && *(_QWORD *)(*i + 72LL) )
    {
      v7 = *(_QWORD *)(*i + 72LL);
      for ( j = 0; j < *(_DWORD *)(v7 + 4); ++j )
      {
        v8 = lyd_find_instance(i, *(_QWORD *)(8LL * j + *(_QWORD *)(v7 + 8)));
        if ( !v8 )
          return sub_12222(
                   **(_QWORD **)(*a1 + 48LL),
                   0,
                   4,
                   "Internal error (%s:%d).",
                   (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
                   1367LL);
        for ( k = 0; k < *(_DWORD *)(v8 + 4); ++k )
        {
          v9 = *(_QWORD *)(8LL * k + *(_QWORD *)(v8 + 8));
          *(_BYTE *)(v9 + 8) |= 8u;
          v4 = 1;
          if ( *(_DWORD *)(v9 + 72) == 9 )
            sub_37EF5(
              *(_QWORD *)v9 + 128LL,
              (char **)(v9 + 56),
              0LL,
              (__int64 **)v9,
              0LL,
              0LL,
              1,
              *(_BYTE *)(v9 + 9) & 1,
              0);
        }
        ly_set_free(v8);
      }
    }
    if ( *(_DWORD *)(*i + 56LL) & 0x802C )
      v6 = 0LL;
    else
      v6 = (_QWORD *)i[8];
    if ( !v6 )
    {
      result = (unsigned __int64)i;
      if ( i == a1 )
        break;
      v6 = (_QWORD *)i[3];
    }
    while ( !v6 )
    {
      i = (_QWORD *)i[5];
      if ( i[5] == a1[5] )
        break;
      v6 = (_QWORD *)i[3];
    }
    result = (unsigned __int64)v6;
  }
  if ( v4 )
  {
    result = a1[5];
    if ( result )
    {
      result = a1[5];
      *(_BYTE *)(result + 8) = *(_BYTE *)(a1[5] + 8LL) | 4;
    }
  }
  return result;
}
// 7380: using guessed type __int64 __fastcall lyd_find_instance(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);

//----- (00000000000AF4BC) ----------------------------------------------------
signed __int64 __fastcall lyd_change_leaf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  void *v8; // rax
  void *v9; // [rsp+0h] [rbp-30h]
  _BOOL4 v10; // [rsp+18h] [rbp-18h]
  signed int v11; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  __int64 j; // [rsp+20h] [rbp-10h]
  char *s1; // [rsp+28h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_change_leaf", a4, a5, a6, a2);
  if ( a1 && *(_DWORD *)(*(_QWORD *)a1 + 56LL) == 4 )
  {
    s1 = *(char **)(a1 + 56);
    if ( v9 )
      v8 = v9;
    else
      v8 = &unk_12274D;
    *(_QWORD *)(a1 + 56) = lydict_insert(**(_QWORD **)(*(_QWORD *)a1 + 48LL), v8, 0LL);
    if ( sub_37EF5(*(_QWORD *)a1 + 128LL, (char **)(a1 + 56), 0LL, (__int64 **)a1, 0LL, 0LL, 1, 0, 0) )
    {
      v10 = strcmp(s1, *(const char **)(a1 + 56)) != 0;
      lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), s1);
      if ( *(_BYTE *)(a1 + 9) & 1 )
      {
        for ( i = a1; i; i = *(_QWORD *)(i + 40) )
          *(_BYTE *)(i + 9) &= 0xFEu;
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
      if ( v10 )
      {
        *(_BYTE *)(a1 + 8) = sub_C3AB(*(_QWORD *)a1);
        sub_AF24B((_QWORD *)a1);
      }
      if ( v10 && *(_WORD *)(*(_QWORD *)a1 + 24LL) & 0x100 )
      {
        for ( j = *(_QWORD *)(a1 + 40); j && *(_DWORD *)(*(_QWORD *)j + 56LL) != 16; j = *(_QWORD *)(j + 40) )
          ;
        if ( j )
          *(_BYTE *)(j + 8) |= 2u;
      }
      result = !v10 && !v11;
    }
    else
    {
      lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), s1);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_change_leaf", v6);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AF724) ----------------------------------------------------
void *__fastcall sub_AF724(__int64 a1, __int64 a2, void *a3, unsigned int a4)
{
  __int64 v4; // r9
  void *result; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r9
  unsigned int v9; // [rsp+4h] [rbp-3Ch]
  void *src; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+2Ch] [rbp-14h]
  __int64 i; // [rsp+30h] [rbp-10h]
  void *ptr; // [rsp+38h] [rbp-8h]

  src = a3;
  v9 = a4;
  ptr = calloc(1uLL, 0x40uLL);
  if ( ptr )
  {
    *(_QWORD *)ptr = a2;
    *((_BYTE *)ptr + 8) = sub_C3AB(a2);
    if ( (unsigned int)sub_28290(a2, 0, 0LL) )
      *((_BYTE *)ptr + 9) = *((_BYTE *)ptr + 9) & 0xF1 | 8;
    *((_QWORD *)ptr + 4) = ptr;
    switch ( (unsigned __int64)v9 )
    {
      case 0uLL:
      case 2uLL:
      case 4uLL:
        *((_QWORD *)ptr + 7) = lydict_insert(**(_QWORD **)(a2 + 48), src, 0LL);
        goto LABEL_16;
      case 1uLL:
      case 3uLL:
      case 5uLL:
        *((_QWORD *)ptr + 7) = lydict_insert_zc(**(_QWORD **)(a2 + 48), src);
        v9 &= 0xFFFFFFFE;
        goto LABEL_16;
      case 8uLL:
        *((_QWORD *)ptr + 7) = src;
        goto LABEL_16;
      case 0x10uLL:
        *((_QWORD *)ptr + 7) = src;
        goto LABEL_16;
      case 0x20uLL:
        v11 = lyd_lyb_data_length(src, 0LL);
        if ( v11 == -1 )
        {
          sub_12222(**(_QWORD **)(a2 + 48), 0, 3, "Invalid LYB data.", v6, v7);
          return 0LL;
        }
        *((_QWORD *)ptr + 7) = malloc(v11);
        if ( !*((_QWORD *)ptr + 7) )
        {
          sub_12222(**(_QWORD **)(a2 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_create_anydata", v8);
          free(ptr);
          return 0LL;
        }
        memcpy(*((void **)ptr + 7), src, v11);
LABEL_16:
        *((_DWORD *)ptr + 13) = v9;
        sub_AC63C((const char **)ptr);
        if ( !a1 )
          goto LABEL_23;
        if ( (unsigned int)lyd_insert(a1, ptr) )
        {
          lyd_free(ptr);
          result = 0LL;
        }
        else
        {
          for ( i = a1; i && *(_BYTE *)(i + 9) & 1; i = *(_QWORD *)(i + 40) )
            *(_BYTE *)(i + 9) &= 0xFEu;
LABEL_23:
          result = ptr;
        }
        break;
      case 0x21uLL:
        *((_QWORD *)ptr + 7) = src;
        v9 &= 0xFFFFFFFE;
        goto LABEL_16;
      default:
        goto LABEL_16;
    }
  }
  else
  {
    sub_12222(**(_QWORD **)(a2 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_create_anydata", v4);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7320: using guessed type __int64 __fastcall lyd_lyb_data_length(_QWORD, _QWORD);
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000AF9FD) ----------------------------------------------------
void *__fastcall lyd_new_anydata(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *result; // rax
  __int64 v8; // r9
  int v9; // ebx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  unsigned int v13; // [rsp+Ch] [rbp-54h]
  void *v14; // [rsp+10h] [rbp-50h]
  char *s; // [rsp+18h] [rbp-48h]
  __int64 v16; // [rsp+38h] [rbp-28h]
  __int64 *v17; // [rsp+40h] [rbp-20h]
  unsigned __int64 v18; // [rsp+48h] [rbp-18h]

  s = a3;
  v14 = (void *)a4;
  v13 = a5;
  v18 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_anydata", a4, a5, a6);
  if ( (a1 || a2) && s )
  {
    v17 = (__int64 *)sub_AE92C(a1, a2, 0);
    if ( v17 )
    {
      v9 = strlen(s);
      v10 = lys_parent(v17);
      if ( !(unsigned int)sub_9B536(a2, v10, s, v9, 32800, 0, (const char ***)&v16) && v16 )
      {
        result = sub_AF724(a1, v16, v14, v13);
      }
      else
      {
        v11 = *v17;
        v12 = lys_node_module(v17);
        sub_12222(
          *(_QWORD *)v17[6],
          0,
          3,
          "Failed to find \"%s\" as a sibling to \"%s:%s\".",
          (__int64)s,
          *(_QWORD *)(v12 + 8),
          v11);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_anydata", v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_anydata", v6);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AFBC0) ----------------------------------------------------
_BYTE *__fastcall lyd_new_yangdata(__int64 *a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  _BYTE *result; // rax
  int v8; // eax
  __int64 v9; // r9
  int v10; // eax
  char *v11; // [rsp+8h] [rbp-38h]
  __int64 v12; // [rsp+28h] [rbp-18h]
  _QWORD *v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v14 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_yangdata", a4, a5, a6);
  v13 = 0LL;
  if ( a1 && a2 && v11 )
  {
    v8 = strlen(a2);
    v13 = (_QWORD *)sub_40D5F((__int64)a1, a2, v8);
    if ( v13 )
    {
      v10 = strlen(v11);
      if ( !(unsigned int)sub_9B536((__int64)a1, (__int64)v13, v11, v10, 1, 0, (const char ***)&v12) && v12 )
      {
        result = sub_AE9DE(0LL, v12, 0);
      }
      else
      {
        sub_12222(*a1, 0, 3, "Failed to find \"%s\" as a container child of \"%s:%s\".", (__int64)v11, a1[1], *v13);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(*a1, 0, 3, "Failed to find yang-data template \"%s\".", (__int64)a2, v9);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_yangdata", v6);
    result = 0LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AFD74) ----------------------------------------------------
_BYTE *__fastcall lyd_new_output(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  _BYTE *result; // rax
  __int64 v8; // r9
  int v9; // ebx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+28h] [rbp-28h]
  __int64 *v15; // [rsp+30h] [rbp-20h]
  unsigned __int64 v16; // [rsp+38h] [rbp-18h]

  s = a3;
  v16 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_output", a4, a5, a6);
  v14 = 0LL;
  if ( (a1 || a2) && s )
  {
    v15 = (__int64 *)sub_AE92C(a1, a2, 1);
    if ( v15 )
    {
      v9 = strlen(s);
      v10 = lys_parent(v15);
      if ( !(unsigned int)sub_9B536(a2, v10, s, v9, 16785, 0, (const char ***)&v14) && v14 )
      {
        result = sub_AE9DE(a1, v14, 0);
      }
      else
      {
        v11 = *v15;
        v12 = lys_node_module(v15);
        sub_12222(
          *(_QWORD *)v15[6],
          0,
          3,
          "Failed to find \"%s\" as a sibling to \"%s:%s\".",
          (__int64)s,
          *(_QWORD *)(v12 + 8),
          v11);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_output", v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_output", v6);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000AFF38) ----------------------------------------------------
char **__fastcall lyd_new_output_leaf(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  char **result; // rax
  __int64 v8; // r9
  int v9; // ebx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  void *v13; // [rsp+0h] [rbp-50h]
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v15; // [rsp+28h] [rbp-28h]
  __int64 *v16; // [rsp+30h] [rbp-20h]
  unsigned __int64 v17; // [rsp+38h] [rbp-18h]

  s = a3;
  v17 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_output_leaf", a4, a5, a6, a4);
  v15 = 0LL;
  if ( (a1 || a2) && s )
  {
    v16 = (__int64 *)sub_AE92C(a1, a2, 1);
    if ( v16 )
    {
      v9 = strlen(s);
      v10 = lys_parent(v16);
      if ( !(unsigned int)sub_9B536(a2, v10, s, v9, 12, 0, (const char ***)&v15) && v15 )
      {
        result = sub_AEDF4(a1, v15, v13, 0, 0);
      }
      else
      {
        v11 = *v16;
        v12 = lys_node_module(v16);
        sub_12222(
          *(_QWORD *)v16[6],
          0,
          3,
          "Failed to find \"%s\" as a sibling to \"%s:%s\".",
          (__int64)s,
          *(_QWORD *)(v12 + 8),
          v11);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_output_leaf", v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_output_leaf", v6);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B0107) ----------------------------------------------------
void *__fastcall lyd_new_output_anydata(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *result; // rax
  __int64 v8; // r9
  int v9; // ebx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  unsigned int v13; // [rsp+Ch] [rbp-54h]
  void *v14; // [rsp+10h] [rbp-50h]
  char *s; // [rsp+18h] [rbp-48h]
  __int64 v16; // [rsp+38h] [rbp-28h]
  __int64 *v17; // [rsp+40h] [rbp-20h]
  unsigned __int64 v18; // [rsp+48h] [rbp-18h]

  s = a3;
  v14 = (void *)a4;
  v13 = a5;
  v18 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_output_anydata", a4, a5, a6);
  if ( (a1 || a2) && s )
  {
    v17 = (__int64 *)sub_AE92C(a1, a2, 1);
    if ( v17 )
    {
      v9 = strlen(s);
      v10 = lys_parent(v17);
      if ( !(unsigned int)sub_9B536(a2, v10, s, v9, 32800, 0, (const char ***)&v16) && v16 )
      {
        result = sub_AF724(a1, v16, v14, v13);
      }
      else
      {
        v11 = *v17;
        v12 = lys_node_module(v17);
        sub_12222(
          *(_QWORD *)v17[6],
          0,
          3,
          "Failed to find \"%s\" as a sibling to \"%s:%s\".",
          (__int64)s,
          *(_QWORD *)(v12 + 8),
          v11);
        result = 0LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_output_anydata", v8);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_output_anydata", v6);
    result = 0LL;
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B02CA) ----------------------------------------------------
char *__fastcall sub_B02CA(__int64 a1, const char *a2, int a3)
{
  __int64 v3; // r9
  char *result; // rax
  __int64 v5; // r9
  char *ptr; // [rsp+20h] [rbp-10h]
  char *ptra; // [rsp+20h] [rbp-10h]
  const char **v8; // [rsp+28h] [rbp-8h]

  if ( !(*(_DWORD *)(a1 + 56) & 0xC) )
    __assert_fail(
      "schema->nodetype & (LYS_LEAF | LYS_LEAFLIST)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x67Du,
      "lyd_make_canonical");
  ptr = strndup(a2, a3);
  if ( ptr )
  {
    v8 = (const char **)sub_AECBE(a1, ptr, 0);
    free(ptr);
    if ( v8 )
    {
      if ( sub_37EF5((signed __int64)(*v8 + 128), (char **)v8 + 7, 0LL, (__int64 **)v8, 0LL, 0LL, 1, 0, 0) )
      {
        ptra = strdup(v8[7]);
        lyd_free(v8);
        if ( ptra )
        {
          result = ptra;
        }
        else
        {
          sub_12222(**(_QWORD **)(a1 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_make_canonical", v5);
          result = 0LL;
        }
      }
      else
      {
        lyd_free(v8);
        result = 0LL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(**(_QWORD **)(a1 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_make_canonical", v3);
    result = 0LL;
  }
  return result;
}
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000B045A) ----------------------------------------------------
signed __int64 __fastcall sub_B045A(__int64 *a1, __int64 a2, _BYTE *a3, _DWORD *a4)
{
  signed __int64 result; // rax
  __int64 v5; // r9
  __int64 v6; // rbx
  size_t v7; // r12
  char *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // r9
  __int64 v12; // r9
  _DWORD *v13; // [rsp+0h] [rbp-80h]
  _BYTE *v14; // [rsp+8h] [rbp-78h]
  int v15; // [rsp+20h] [rbp-60h]
  int v16; // [rsp+24h] [rbp-5Ch]
  int v17; // [rsp+28h] [rbp-58h]
  int v18; // [rsp+2Ch] [rbp-54h]
  int v19; // [rsp+30h] [rbp-50h]
  int v20; // [rsp+34h] [rbp-4Ch]
  char *s2; // [rsp+38h] [rbp-48h]
  char *s1; // [rsp+40h] [rbp-40h]
  char *src; // [rsp+48h] [rbp-38h]
  __int64 v24; // [rsp+50h] [rbp-30h]
  const char **v25; // [rsp+58h] [rbp-28h]
  char *dest; // [rsp+60h] [rbp-20h]
  unsigned __int64 v27; // [rsp+68h] [rbp-18h]

  v14 = a3;
  v13 = a4;
  v27 = __readfsqword(0x28u);
  v24 = *a1;
  v19 = sub_179A7(a3, &s2, (unsigned int *)&v15, &s1, (unsigned int *)&v16, &src, &v17, &v18);
  if ( v19 <= 0 || !strncmp(s1, ".", v16) )
  {
    sub_13937(**(void ***)(v24 + 48), 78, 0, 0LL, (unsigned int)(char)v14[-v19], (__int64)&v14[-v19], v13);
    result = 0xFFFFFFFFLL;
  }
  else if ( (*__ctype_b_loc())[*s1] & 0x800 )
  {
    *v13 += v19;
    result = 0LL;
  }
  else if ( *(_BYTE *)(v24 + 30) )
  {
    v20 = 0;
    while ( 1 )
    {
      v25 = *(const char ***)(8LL * v20 + *(_QWORD *)(v24 + 136));
      *v13 += v19;
      v14 += v19;
      if ( !src
        || !s2 && (v6 = lys_node_module(v25), v6 != lys_node_module(v24))
        || s2
        && ((v7 = v15, v8 = s2, v9 = lys_node_module(v25), strncmp(*(const char **)(v9 + 8), v8, v7))
         || (v10 = lys_node_module(v25), *(_BYTE *)(*(_QWORD *)(v10 + 8) + v15)))
        || strncmp(*v25, s1, v16)
        || (*v25)[v16] )
      {
        sub_13937(**(void ***)(v24 + 48), 82, 0, 0LL, (__int64)s1, v5, v13);
        return 0xFFFFFFFFLL;
      }
      dest = (char *)malloc(v17 + 1);
      if ( !dest )
      {
        sub_12222(
          **(_QWORD **)(v24 + 48),
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"lyd_new_path_list_predicate",
          v11,
          v13);
        return 0xFFFFFFFFLL;
      }
      strncpy(dest, src, v17);
      dest[v17] = 0;
      if ( !sub_AEDF4((__int64)a1, (__int64)v25, dest, 0, 0) )
      {
        free(dest);
        return 0xFFFFFFFFLL;
      }
      free(dest);
      if ( ++v20 >= *(unsigned __int8 *)(v24 + 30) )
        break;
      if ( !v18 )
      {
        sub_13937(**(void ***)(v24 + 48), 83, 0, 0LL, a2, v12, v13);
        return 0xFFFFFFFFLL;
      }
      v19 = sub_179A7(v14, &s2, (unsigned int *)&v15, &s1, (unsigned int *)&v16, &src, &v17, &v18);
      if ( v19 <= 0 || !strncmp(s1, ".", v16) )
      {
        sub_13937(**(void ***)(v24 + 48), 78, 0, 0LL, (unsigned int)(char)v14[-v19], (__int64)&v14[-v19], v13);
        return 0xFFFFFFFFLL;
      }
    }
    result = 0LL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000B08C4) ----------------------------------------------------
__int64 __fastcall sub_B08C4(__int64 a1, _BYTE *a2, unsigned int a3, int a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  int v11; // [rsp+8h] [rbp-38h]
  unsigned int v12; // [rsp+Ch] [rbp-34h]
  void *src; // [rsp+10h] [rbp-30h]
  int v14; // [rsp+2Ch] [rbp-14h]
  __int64 v15; // [rsp+30h] [rbp-10h]

  src = a2;
  v12 = a3;
  v11 = a4;
  v15 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  v6 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v6 != 32 && v6 != 32800 )
  {
    if ( v6 == 4 )
    {
      if ( a3 > 1 )
      {
        sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_path_update", a6);
        return 0LL;
      }
      if ( !(unsigned int)lyd_change_leaf(a1, a2) )
      {
        if ( v11 )
          *(_BYTE *)(a1 + 9) |= 1u;
        return a1;
      }
      if ( v11 )
      {
        *(_BYTE *)(a1 + 9) |= 1u;
        return a1;
      }
    }
    return 0LL;
  }
  if ( *(_DWORD *)(a1 + 52) > 1u || a3 > 1 )
  {
    if ( a3 == *(_DWORD *)(a1 + 52) && a2 == *(_BYTE **)(a1 + 56) )
      return 0LL;
  }
  else if ( (unsigned int)sub_C462(*(_BYTE **)(a1 + 56), a2) )
  {
    return 0LL;
  }
  switch ( *(_DWORD *)(a1 + 52) )
  {
    case 0:
    case 2:
    case 4:
      a2 = *(_BYTE **)(a1 + 56);
      lydict_remove(v15, a2);
      break;
    case 1:
    case 3:
    case 5:
    case 0x21:
      __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x72Du, "lyd_new_path_update");
      return result;
    case 8:
      a2 = *(_BYTE **)(a1 + 56);
      lyxml_free_withsiblings(v15, a2);
      break;
    case 0x10:
      lyd_free_withsiblings(*(_QWORD *)(a1 + 56));
      break;
    case 0x20:
      free(*(void **)(a1 + 56));
      break;
    default:
      break;
  }
  switch ( (unsigned __int64)v12 )
  {
    case 0uLL:
    case 2uLL:
    case 4uLL:
      *(_QWORD *)(a1 + 56) = lydict_insert(v15, src, 0LL);
      goto LABEL_36;
    case 1uLL:
    case 3uLL:
    case 5uLL:
      *(_QWORD *)(a1 + 56) = lydict_insert_zc(v15, src);
      goto LABEL_36;
    case 8uLL:
      *(_QWORD *)(a1 + 56) = src;
      goto LABEL_36;
    case 0x10uLL:
      *(_QWORD *)(a1 + 56) = src;
      goto LABEL_36;
    case 0x20uLL:
      v14 = lyd_lyb_data_length(src, a2);
      if ( v14 == -1 )
      {
        sub_12222(v15, 0, 3, "Invalid LYB data.", v8, v9);
        result = 0LL;
      }
      else
      {
        *(_QWORD *)(a1 + 56) = malloc(v14);
        if ( *(_QWORD *)(a1 + 56) )
        {
          memcpy(*(void **)(a1 + 56), src, v14);
LABEL_36:
          result = a1;
        }
        else
        {
          sub_12222(v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_new_path_update", v10);
          result = 0LL;
        }
      }
      break;
    case 0x21uLL:
      *(_QWORD *)(a1 + 56) = src;
      goto LABEL_36;
    default:
      goto LABEL_36;
  }
  return result;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7320: using guessed type __int64 __fastcall lyd_lyb_data_length(_QWORD, _QWORD);
// 7440: using guessed type __int64 __fastcall lyd_change_leaf(_QWORD, _QWORD);
// 75F0: using guessed type __int64 __fastcall lyxml_free_withsiblings(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000B0C1E) ----------------------------------------------------
__int64 *__fastcall lyd_new_path(__int64 *a1, void *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 *result; // rax
  void *v9; // rax
  void *v10; // rax
  void *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  unsigned int v21; // eax
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 **v24; // rax
  __int64 v25; // r9
  void *v26; // rax
  __int64 **v27; // rdi
  __int64 **v28; // rax
  signed int v29; // edx
  int v30; // [rsp+8h] [rbp-F8h]
  unsigned int v31; // [rsp+Ch] [rbp-F4h]
  _BYTE *v32; // [rsp+10h] [rbp-F0h]
  char *string; // [rsp+18h] [rbp-E8h]
  void *v34; // [rsp+20h] [rbp-E0h]
  __int64 *v35; // [rsp+28h] [rbp-D8h]
  int v36; // [rsp+30h] [rbp-D0h]
  int v37; // [rsp+34h] [rbp-CCh]
  int v38; // [rsp+38h] [rbp-C8h]
  int v39; // [rsp+3Ch] [rbp-C4h]
  int v40; // [rsp+40h] [rbp-C0h]
  int v41; // [rsp+44h] [rbp-BCh]
  int v42; // [rsp+48h] [rbp-B8h]
  int k; // [rsp+4Ch] [rbp-B4h]
  int v44; // [rsp+50h] [rbp-B0h]
  _BOOL4 v45; // [rsp+54h] [rbp-ACh]
  int v46; // [rsp+58h] [rbp-A8h]
  int v47; // [rsp+5Ch] [rbp-A4h]
  int v48; // [rsp+60h] [rbp-A0h]
  int v49; // [rsp+64h] [rbp-9Ch]
  char *s2; // [rsp+68h] [rbp-98h]
  char *v51; // [rsp+70h] [rbp-90h]
  _BYTE *v52; // [rsp+78h] [rbp-88h]
  char *v53; // [rsp+80h] [rbp-80h]
  void *ptr; // [rsp+88h] [rbp-78h]
  char *v55; // [rsp+90h] [rbp-70h]
  char *v56; // [rsp+98h] [rbp-68h]
  const char *v57; // [rsp+A0h] [rbp-60h]
  __int64 *v58; // [rsp+A8h] [rbp-58h]
  __int64 *i; // [rsp+B0h] [rbp-50h]
  __int64 **v60; // [rsp+B8h] [rbp-48h]
  __int64 v61; // [rsp+C0h] [rbp-40h]
  _QWORD *v62; // [rsp+C8h] [rbp-38h]
  __int64 j; // [rsp+D0h] [rbp-30h]
  __int64 v64; // [rsp+D8h] [rbp-28h]
  __int64 v65; // [rsp+E0h] [rbp-20h]
  char *s1; // [rsp+E8h] [rbp-18h]
  __int64 v67; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v68; // [rsp+F8h] [rbp-8h]

  v35 = a1;
  v34 = a2;
  string = a3;
  v32 = (_BYTE *)a4;
  v31 = a5;
  v30 = a6;
  v68 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_new_path", a4, a5, a6);
  v56 = 0LL;
  v57 = 0LL;
  v58 = 0LL;
  v60 = 0LL;
  v36 = 0;
  v41 = -1;
  v44 = 1;
  if ( !string || !a1 && !a2 || !a1 && *string != 47 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_new_path", v7);
    return 0LL;
  }
  if ( !a2 )
    v34 = **(void ***)(*a1 + 48);
  v55 = string;
  if ( a1 )
  {
    if ( *string == 47 )
    {
      for ( i = a1; !v36 && i; i = (__int64 *)i[3] )
      {
        if ( v31 > 1 )
          v9 = 0LL;
        else
          v9 = v32;
        v60 = sub_1C6D1(v55, v9, i, v30, &v36);
      }
      if ( !v36 )
      {
        for ( i = (__int64 *)a1[4]; !v36 && i[3]; i = (__int64 *)i[4] )
        {
          if ( v31 > 1 )
            v10 = 0LL;
          else
            v10 = v32;
          v60 = sub_1C6D1(v55, v10, i, v30, &v36);
        }
      }
    }
    else
    {
      if ( v31 > 1 )
        v11 = 0LL;
      else
        v11 = v32;
      v60 = sub_1C6D1(v55, v11, a1, v30, &v36);
    }
    if ( v36 == -1 )
      return 0LL;
    if ( v36 )
    {
      if ( !v60 )
        __assert_fail("parent", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x78Fu, "lyd_new_path");
      v41 = 1;
      v55 += v36;
      if ( !*v55 )
      {
        if ( v30 & 1 || *((_BYTE *)v60 + 9) & 1 && !(v30 & 8) )
        {
          if ( *((_BYTE *)v60 + 9) & 1 && v30 & 8 )
            result = 0LL;
          else
            result = (__int64 *)sub_B08C4((__int64)v60, v32, v31, v30 & 8, v6, v7);
        }
        else
        {
          sub_13937(v34, 85, 4u, string, v6, v7);
          result = 0LL;
        }
        return result;
      }
    }
  }
  v48 = v41;
  v49 = sub_17847(v55, &s2, (unsigned int *)&v37, &v51, (unsigned int *)&v38, &v41, 0LL, 0LL, 1);
  if ( v49 <= 0 )
  {
    sub_13937(v34, 78, 0, 0LL, (unsigned int)v55[-v49], (__int64)&v55[-v49]);
    return 0LL;
  }
  if ( *v51 == 35 )
  {
    if ( v41 )
    {
      sub_13937(v34, 78, 0, 0LL, 35LL, (__int64)v51);
      return 0LL;
    }
    v57 = v51 + 1;
    v47 = v38 - 1;
    v56 = s2;
    v46 = v37;
    v55 += v49;
  }
  else
  {
    v41 = v48;
  }
  v49 = sub_17847(v55, &s2, (unsigned int *)&v37, &v51, (unsigned int *)&v38, &v41, &v42, 0LL, 0);
  if ( v49 <= 0 )
  {
    sub_13937(v34, 78, 0, 0LL, (unsigned int)v55[-v49], (__int64)&v55[-v49]);
    return 0LL;
  }
  v55 += v49;
  if ( v56 )
  {
    s2 = v56;
    v37 = v46;
  }
  if ( v41 )
  {
    if ( !a1 )
    {
      sub_12222(
        (__int64)v34,
        0,
        3,
        "%s: provided relative path (%s) without context node.",
        (__int64)"lyd_new_path",
        (__int64)string);
      return 0LL;
    }
    if ( !v60 )
      v60 = (__int64 **)a1;
    v62 = *v60;
    v65 = lys_node_module(v62);
    v64 = v65;
  }
  else
  {
    if ( v60 )
      __assert_fail("!parent", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x7D4u, "lyd_new_path");
    if ( !s2 )
    {
      ptr = strndup(string, &v51[v38] - string);
      sub_13937(v34, 80, 4u, (char *)ptr, v12, v13);
      free(ptr);
      return 0LL;
    }
    v64 = sub_E085((__int64)v34, s2, v37, 0LL, 1);
    if ( !v64 )
    {
      ptr = strndup(string, &s2[v37] - string);
      sub_13937(v34, 79, 4u, (char *)ptr, v14, v15);
      free(ptr);
      return 0LL;
    }
    s2 = 0LL;
    v37 = 0;
    v65 = v64;
    v62 = 0LL;
    if ( v57 )
    {
      v62 = (_QWORD *)sub_40D5F(v64, v57, v47);
      if ( !v62 )
      {
        ptr = strndup(string, &v57[v47] - string);
        sub_13937(v34, 81, 4u, (char *)ptr, v16, v17);
        free(ptr);
        return 0LL;
      }
    }
  }
  while ( 2 )
  {
    v61 = 0LL;
    while ( 1 )
    {
      v61 = lys_getnext(v61, v62, v64, 0LL);
      if ( !v61 )
        break;
      if ( *(_DWORD *)(v61 + 56) & 0xC1BD )
      {
        if ( s2 )
        {
          s1 = *(char **)(lys_node_module(v61) + 8);
          if ( !strncmp(s1, s2, v37) && !s1[v37] )
            goto LABEL_78;
        }
        else
        {
          v18 = lys_node_module(v61);
          if ( v65 == v18 )
          {
LABEL_78:
            if ( !strncmp(*(const char **)v61, v51, v38) && !*(_BYTE *)(*(_QWORD *)v61 + v38) )
            {
              for ( j = lys_parent(v61); j && *(_DWORD *)(j + 56) == 4096; j = lys_parent(j) )
                ;
              if ( !j )
                break;
              if ( v30 & 4 )
              {
                if ( *(_DWORD *)(j + 56) != 512 )
                  break;
              }
              else if ( *(_DWORD *)(j + 56) != 1024 )
              {
                break;
              }
            }
          }
        }
      }
    }
    if ( !v61 )
    {
      ptr = strndup(string, &v51[v38] - string);
      sub_13937(v34, 81, 4u, (char *)ptr, v19, v20);
      free(ptr);
      lyd_free(v58);
      return 0LL;
    }
    v21 = *(_DWORD *)(v61 + 56);
    if ( v21 == 32 )
      goto LABEL_135;
    if ( v21 > 0x20 )
    {
      if ( v21 == 256 )
        goto LABEL_108;
      if ( v21 <= 0x100 )
      {
        if ( v21 == 128 )
          goto LABEL_108;
        goto LABEL_144;
      }
      if ( v21 == 0x4000 )
        goto LABEL_108;
      if ( v21 != 32800 )
        goto LABEL_144;
LABEL_135:
      if ( !*v55 )
      {
        if ( v31 <= 1 && !v32 )
        {
          v31 = 0;
          v32 = &unk_12274D;
        }
        if ( v41 )
          v28 = v60;
        else
          v28 = 0LL;
        i = (__int64 *)sub_AF724((__int64)v28, v61, v32, v31);
        goto LABEL_145;
      }
      sub_13937(v34, 78, 0, 0LL, (unsigned int)*v55, (__int64)v55);
      lyd_free(v58);
      return 0LL;
    }
    if ( v21 == 4 )
      goto LABEL_114;
    if ( v21 > 4 )
    {
      if ( v21 != 8 )
      {
        if ( v21 == 16 )
          goto LABEL_108;
LABEL_144:
        sub_12222(
          (__int64)v34,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          2155LL);
        i = 0LL;
        goto LABEL_145;
      }
LABEL_114:
      ptr = 0LL;
      if ( !v42 )
        goto LABEL_192;
      v49 = sub_179A7(v55, 0LL, 0LL, &v52, (unsigned int *)&v39, &v53, &v40, &v42);
      if ( v49 <= 0 )
      {
        sub_13937(v34, 78, 0, 0LL, (unsigned int)v55[-v49], (__int64)&v55[-v49]);
        lyd_free(v58);
        return 0LL;
      }
      v55 += v49;
      if ( *v52 != 46 || v39 != 1 )
      {
        sub_13937(v34, 78, 0, 0LL, (unsigned int)(char)*v52, (__int64)v52);
        lyd_free(v58);
        return 0LL;
      }
      ptr = strndup(v53, v40);
      if ( ptr )
      {
LABEL_192:
        if ( !*v55 )
        {
          v45 = v30 & 0x20 && *(_DWORD *)(v61 + 56) == 4;
          if ( ptr )
            v26 = ptr;
          else
            v26 = v32;
          if ( v41 )
            v27 = v60;
          else
            v27 = 0LL;
          i = (__int64 *)sub_AEDF4((__int64)v27, v61, v26, (v30 >> 3) & 1, v45);
          free(ptr);
          goto LABEL_145;
        }
        sub_13937(v34, 78, 0, 0LL, (unsigned int)*v55, (__int64)v55);
        free(ptr);
        lyd_free(v58);
        result = 0LL;
      }
      else
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_new_path", v25);
        lyd_free(v58);
        result = 0LL;
      }
      return result;
    }
    if ( v21 != 1 )
      goto LABEL_144;
LABEL_108:
    if ( v30 & 2 )
    {
      ptr = strndup(string, &v51[v38] - string);
      sub_13937(v34, 86, 4u, (char *)ptr, v22, v23);
      free(ptr);
      lyd_free(v58);
      return 0LL;
    }
    if ( v41 )
      v24 = v60;
    else
      v24 = 0LL;
    i = (__int64 *)sub_AE9DE((__int64)v24, v61, (v30 >> 3) & 1);
LABEL_145:
    if ( i )
    {
      if ( !v41 )
      {
        if ( v35 )
        {
          while ( v35[3] )
            v35 = (__int64 *)v35[3];
          if ( (unsigned int)lyd_insert_after(v35, i) )
          {
            lyd_free(v58);
            return 0LL;
          }
        }
        v41 = 1;
      }
      if ( v44 )
      {
        v62 = (_QWORD *)*i;
        do
        {
          v62 = (_QWORD *)lys_parent(v62);
          if ( !v62 )
            break;
          v29 = v30 & 4 ? 1024 : 512;
        }
        while ( v29 != *((_DWORD *)v62 + 14) );
        if ( v62 && (unsigned int)lyd_schema_sort(i, 0LL) )
        {
          lyd_free(v58);
          return 0LL;
        }
        v58 = i;
        v44 = 0;
      }
      v36 = 0;
      if ( *(_DWORD *)(v61 + 56) == 16 && v42 && (unsigned int)sub_B045A(i, (__int64)v51, v55, &v36) )
      {
        lyd_free(v58);
        result = 0LL;
      }
      else
      {
        v55 += v36;
        if ( *v55 )
        {
          v60 = (__int64 **)i;
          v62 = (_QWORD *)v61;
          v65 = lys_node_module(v61);
          v49 = sub_17847(v55, &s2, (unsigned int *)&v37, &v51, (unsigned int *)&v38, &v41, &v42, 0LL, 0);
          if ( v49 > 0 )
          {
            v55 += v49;
            if ( *(_DWORD *)(v61 + 56) == 16 && !s2 )
            {
              v67 = v61;
              for ( k = 0; k < *(unsigned __int8 *)(v67 + 30); ++k )
              {
                if ( !strncmp(**(const char ***)(8LL * k + *(_QWORD *)(v67 + 136)), v51, v38)
                  && !*(_BYTE *)(**(_QWORD **)(8LL * k + *(_QWORD *)(v67 + 136)) + v38) )
                {
                  if ( !*v55 )
                    return v58;
                  sub_13937(v34, 78, 0, 0LL, (unsigned int)*v55, (__int64)v55);
                  lyd_free(v58);
                  return 0LL;
                }
              }
            }
            continue;
          }
          sub_13937(v34, 78, 0, 0LL, (unsigned int)v55[-v49], (__int64)&v55[-v49]);
          lyd_free(v58);
          result = 0LL;
        }
        else if ( v30 & 0x10 )
        {
          result = i;
        }
        else
        {
          result = v58;
        }
      }
    }
    else
    {
      ptr = strndup(string, v55 - string);
      if ( v41 )
        sub_13937(
          v34,
          -1,
          4u,
          (char *)ptr,
          (__int64)"Failed to create node \"%s\" as a child of \"%s\".",
          *(_QWORD *)v61,
          **v60);
      else
        sub_13937(v34, -1, 4u, (char *)ptr, (__int64)"Failed to create node \"%s\".", *(_QWORD *)v61);
      free(ptr);
      lyd_free(v58);
      result = 0LL;
    }
    return result;
  }
}
// 71D0: using guessed type __int64 __fastcall lyd_schema_sort(_QWORD, _QWORD);
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7310: using guessed type __int64 __fastcall lyd_insert_after(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B2011) ----------------------------------------------------
__int64 __fastcall lyd_list_pos(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v7; // [rsp+8h] [rbp-18h]
  unsigned int v8; // [rsp+14h] [rbp-Ch]

  v7 = a1;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_list_pos", a4, a5, a6);
  if ( !a1 || *(_DWORD *)(*a1 + 56LL) != 16 && *(_DWORD *)(*a1 + 56LL) != 8 )
    return 0LL;
  v8 = 0;
  do
  {
    if ( *a1 == *v7 )
      ++v8;
    v7 = (_QWORD *)v7[4];
  }
  while ( v7[3] );
  return v8;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B20A7) ----------------------------------------------------
_BYTE *__fastcall sub_B20A7(_QWORD *a1, _QWORD *a2, __int64 a3, void *a4, unsigned int a5)
{
  __int64 v5; // r9
  unsigned int v7; // eax
  unsigned int v8; // [rsp+Ch] [rbp-54h]
  void *v9; // [rsp+10h] [rbp-50h]
  __int64 v10; // [rsp+18h] [rbp-48h]
  __int64 v11; // [rsp+20h] [rbp-40h]
  _QWORD *v12; // [rsp+28h] [rbp-38h]
  int v13; // [rsp+3Ch] [rbp-24h]
  __int64 i; // [rsp+40h] [rbp-20h]
  _QWORD *j; // [rsp+48h] [rbp-18h]
  _QWORD *k; // [rsp+48h] [rbp-18h]
  _BYTE *v17; // [rsp+48h] [rbp-18h]
  _BYTE *v18; // [rsp+50h] [rbp-10h]
  __int64 v19; // [rsp+58h] [rbp-8h]

  v12 = a1;
  v11 = (__int64)a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v18 = 0LL;
  if ( !a3 )
    __assert_fail("schema", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x8EAu, "lyd_new_dummy");
  if ( !(*(_DWORD *)(a3 + 56) & 0xC1BD) )
    __assert_fail(
      "schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x8ECu,
      "lyd_new_dummy");
  v19 = ly_set_new(a1);
  if ( !v19 )
  {
    sub_12222(**(_QWORD **)(v10 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_new_dummy", v5);
    return 0LL;
  }
  if ( !a2 && a1 )
  {
    while ( v12[5] )
      v12 = (_QWORD *)v12[5];
    while ( *(_QWORD *)(v12[4] + 24LL) )
      v12 = (_QWORD *)v12[4];
  }
  for ( i = v10; i && (!a2 || i != *a2); i = lys_parent(i) )
  {
    if ( *(_DWORD *)(i + 56) & 0xC1BD )
      ly_set_add(v19, i, 1LL);
  }
  if ( !*(_DWORD *)(v19 + 4) )
    __assert_fail("spath->number > 0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x908u, "lyd_new_dummy");
  v13 = *(_DWORD *)(v19 + 4);
  if ( !a2 && !(*(_DWORD *)(*(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)) + 56LL) & 8) )
  {
    for ( j = v12; j; j = (_QWORD *)j[3] )
    {
      if ( *j == *(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)) )
      {
        v11 = (__int64)j;
        --v13;
        break;
      }
    }
  }
  k = (_QWORD *)v11;
LABEL_37:
  while ( k && v13 && !(*(_DWORD *)(*(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)) + 56LL) & 8) )
  {
    for ( k = *(_QWORD **)(v11 + 64); k; k = (_QWORD *)k[3] )
    {
      if ( *k == *(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)) )
      {
        --v13;
        v11 = (__int64)k;
        goto LABEL_37;
      }
    }
  }
  while ( 1 )
  {
    if ( !v13 )
    {
      ly_set_free(v19);
      return v18;
    }
    v7 = *(_DWORD *)(*(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)) + 56LL);
    if ( v7 == 8 )
      goto LABEL_50;
    if ( v7 <= 8 )
    {
      if ( v7 == 1 )
        goto LABEL_56;
      if ( v7 != 4 )
        goto LABEL_65;
LABEL_50:
      if ( v9 )
      {
        v17 = sub_AEDF4(v11, *(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)), v9, v8, 0);
      }
      else
      {
        v17 = sub_AECBE(*(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)), 0LL, v8);
        if ( v17 && v11 && (unsigned int)lyd_insert(v11, v17) )
        {
          lyd_free(v17);
          goto LABEL_65;
        }
      }
      goto LABEL_58;
    }
    if ( v7 != 32 && v7 != 32800 )
    {
      if ( v7 != 16 )
        goto LABEL_65;
LABEL_56:
      v17 = sub_AE9DE(v11, *(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)), v8);
      goto LABEL_58;
    }
    v17 = sub_AF724(v11, *(_QWORD *)(8LL * (unsigned int)(v13 - 1) + *(_QWORD *)(v19 + 8)), &unk_12274D, 0);
LABEL_58:
    if ( !v17 )
      break;
    v17[8] = -128;
    if ( !v18 )
      v18 = v17;
    v11 = (__int64)v17;
    --v13;
  }
  sub_12222(
    **(_QWORD **)(v10 + 48),
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
    2365LL);
LABEL_65:
  ly_set_free(v19);
  lyd_free(v18);
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000B2578) ----------------------------------------------------
__int64 __fastcall sub_B2578(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // ST10_8
  __int64 v8; // rax
  int v9; // [rsp+18h] [rbp-48h]
  unsigned int v10; // [rsp+1Ch] [rbp-44h]
  __int64 v11; // [rsp+20h] [rbp-40h]
  __int64 v12; // [rsp+28h] [rbp-38h]
  __int64 v13; // [rsp+30h] [rbp-30h]
  __int64 i; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  __int64 v16; // [rsp+48h] [rbp-18h]
  __int64 *v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  v13 = 0LL;
  v15 = 0LL;
  v11 = 0LL;
  if ( !a2 || a2 == **(_QWORD **)(a1 + 48) )
    return a1;
  v16 = ly_set_new(a1);
  for ( i = a1; i; i = lys_parent(i) )
  {
    if ( *(_DWORD *)(i + 56) != 4096 )
      ly_set_add(v16, i, 1LL);
  }
  if ( !*(_DWORD *)(v16 + 4) )
    __assert_fail(
      "parents->number",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x96Fu,
      "lys_get_schema_inctx");
  v10 = *(_DWORD *)(v16 + 4) - 1;
  i = *(_QWORD *)(8LL * v10 + *(_QWORD *)(v16 + 8));
  if ( *(_DWORD *)(i + 56) == 0x10000 )
  {
    v17 = (__int64 *)lys_ext_complex_get_substmt(0xFFFFFFFFLL, i, 0LL);
    if ( !v17 )
    {
      ly_set_free(v16);
      return 0LL;
    }
    v15 = *v17;
    v3 = *(_QWORD *)(v16 + 8);
    i = *(_QWORD *)(8LL * --v10 + v3);
  }
  v9 = 0;
  do
  {
    v12 = ly_ctx_get_module_iter(a2, &v9);
    if ( !v12 )
      break;
    v13 = lys_node_module(i);
  }
  while ( strcmp(*(const char **)(v12 + 8), *(const char **)(v13 + 8))
       || (*(_BYTE *)(v12 + 68) || *(_BYTE *)(v13 + 68))
       && (!*(_BYTE *)(v12 + 68)
        || !*(_BYTE *)(v13 + 68)
        || strcmp(*(const char **)(v12 + 88), *(const char **)(v13 + 88))) );
  if ( !v12 && v13 && *(_QWORD *)(a2 + 112) )
  {
    sub_12312(
      2u,
      (__int64)"Attempting to load '%s' into context using callback ...",
      *(_QWORD *)(v13 + 8),
      v4,
      v5,
      v6,
      a2);
    v12 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD))(v7 + 112))(
            v7,
            *(_QWORD *)(v13 + 8),
            0LL,
            0LL,
            *(_QWORD *)(v7 + 120));
  }
  if ( v12 )
  {
    if ( !v15 )
      v15 = *(_QWORD *)(v12 + 168);
    while ( 1 )
    {
      sub_9B262(v15, *(const char **)(v13 + 8), 0, *(char **)i, 0, *(_DWORD *)(i + 56), (const char ***)&v11);
      if ( !v11 || !v10 )
        break;
      v15 = *(_QWORD *)(v11 + 72);
      v8 = *(_QWORD *)(v16 + 8);
      i = *(_QWORD *)(8LL * --v10 + v8);
      v11 = 0LL;
    }
    ly_set_free(v16);
    result = v11;
  }
  else
  {
    ly_set_free(v16);
    result = 0LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000B28DB) ----------------------------------------------------
__int64 __fastcall sub_B28DB(__int64 *a1, __int64 a2)
{
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x9B5u, "lyd_get_schema_inctx");
  return sub_B2578(*a1, a2);
}

//----- (00000000000B2929) ----------------------------------------------------
unsigned __int64 __fastcall sub_B2929(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // ST50_8
  __int64 v4; // rdx
  _QWORD *v5; // rdx
  _QWORD *v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  unsigned __int64 v10; // [rsp+0h] [rbp-40h]
  int v11; // [rsp+14h] [rbp-2Ch]
  __int64 v12; // [rsp+18h] [rbp-28h]

  v10 = a2;
  if ( !(*(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x8024) )
    __assert_fail(
      "target->schema->nodetype & (LYS_LEAF | LYS_ANYDATA)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x9C3u,
      "lyd_merge_node_update");
  v12 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  if ( v12 == **(_QWORD **)(*(_QWORD *)a2 + 48LL) )
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) == 4 )
    {
      lydict_remove(v12, *(_QWORD *)(a1 + 56));
      *(_QWORD *)(a1 + 56) = lydict_insert(v12, *(_QWORD *)(a2 + 56), 0LL);
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
      if ( *(_DWORD *)(a1 + 72) == 9 )
      {
        *(_BYTE *)(a1 + 8) |= 8u;
        sub_37EF5(
          *(_QWORD *)a1 + 128LL,
          (char **)(a1 + 56),
          0LL,
          (__int64 **)a1,
          0LL,
          0LL,
          1,
          *(_BYTE *)(a2 + 9) & 1,
          0);
      }
      else
      {
        sub_BBE52(
          *(void **)(a1 + 64),
          *(_DWORD *)(a1 + 72),
          *(_BYTE *)(a1 + 76),
          *(_QWORD *)a1 + 128LL,
          *(_QWORD *)(a1 + 56),
          0LL,
          0LL,
          0LL);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      }
      *(_BYTE *)(a1 + 9) = *(_BYTE *)(a2 + 9) & 1 | *(_BYTE *)(a1 + 9) & 0xFE;
      result = sub_AF24B((_QWORD *)a1);
    }
    else
    {
      switch ( *(_DWORD *)(a1 + 52) )
      {
        case 0:
        case 2:
        case 4:
          lydict_remove(v12, *(_QWORD *)(a1 + 56));
          break;
        case 1:
        case 3:
        case 5:
        case 0x21:
          __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x9F3u, "lyd_merge_node_update");
          return result;
        case 8:
          lyxml_free_withsiblings(v12, *(_QWORD *)(a1 + 56));
          break;
        case 0x10:
          lyd_free_withsiblings(*(_QWORD *)(a1 + 56));
          break;
        case 0x20:
          free(*(void **)(a1 + 56));
          break;
        default:
          break;
      }
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      *(_DWORD *)(a2 + 52) = 16;
      result = a2;
      *(_QWORD *)(a2 + 56) = 0LL;
    }
  }
  else if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) == 4 )
  {
    v3 = a1;
    lydict_remove(v12, *(_QWORD *)(a1 + 56));
    *(_QWORD *)(a1 + 56) = lydict_insert(v12, *(_QWORD *)(a2 + 56), 0LL);
    sub_BBE52(
      *(void **)(v3 + 64),
      *(_DWORD *)(v3 + 72),
      *(_BYTE *)(v3 + 76),
      *(_QWORD *)v3 + 128LL,
      *(_QWORD *)(v3 + 56),
      0LL,
      0LL,
      0LL);
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    *(_BYTE *)(v3 + 9) = *(_BYTE *)(a2 + 9) & 1 | *(_BYTE *)(v3 + 9) & 0xFE;
    switch ( *(_DWORD *)(a1 + 72) )
    {
      case 1:
      case 0xA:
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 56);
        break;
      case 2:
      case 6:
      case 7:
        sub_37EF5(
          *(_QWORD *)a1 + 128LL,
          (char **)(a1 + 56),
          0LL,
          (__int64 **)a1,
          0LL,
          0LL,
          1,
          *(_BYTE *)(a1 + 9) & 1,
          1);
        break;
      case 8:
        *(_QWORD *)(a1 + 64) = 0LL;
        break;
      case 9:
        *(_BYTE *)(a1 + 8) |= 8u;
        sub_37EF5(
          *(_QWORD *)a1 + 128LL,
          (char **)(a1 + 56),
          0LL,
          (__int64 **)a1,
          0LL,
          0LL,
          1,
          *(_BYTE *)(a1 + 9) & 1,
          0);
        break;
      case 0xB:
        *(_QWORD *)(a1 + 64) = lydict_insert(v12, *(_QWORD *)(a2 + 64), 0LL);
        break;
      default:
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        break;
    }
    result = sub_AF24B((_QWORD *)a1);
  }
  else
  {
    switch ( *(_DWORD *)(a1 + 52) )
    {
      case 0:
      case 2:
      case 4:
        a2 = *(_QWORD *)(a1 + 56);
        lydict_remove(v12, a2);
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
        __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0xA44u, "lyd_merge_node_update");
        return result;
      case 8:
        a2 = *(_QWORD *)(a1 + 56);
        lyxml_free_withsiblings(v12, a2);
        break;
      case 0x10:
        lyd_free_withsiblings(*(_QWORD *)(a1 + 56));
        break;
      case 0x20:
        free(*(void **)(a1 + 56));
        break;
      default:
        break;
    }
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v10 + 52);
    result = *(_QWORD *)(v10 + 56);
    if ( result )
    {
      result = *(unsigned int *)(a1 + 52);
      switch ( (_DWORD)result )
      {
        case 0:
        case 2:
        case 4:
          v4 = lydict_insert(v12, *(_QWORD *)(v10 + 56), 0LL);
          result = a1;
          *(_QWORD *)(a1 + 56) = v4;
          break;
        case 1:
        case 3:
        case 5:
        case 0x21:
          __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0xA66u, "lyd_merge_node_update");
          return result;
        case 8:
          v6 = sub_30929(v12, *(_QWORD *)(v10 + 56), 0LL, 1u, 1u);
          result = a1;
          *(_QWORD *)(a1 + 56) = v6;
          break;
        case 0x10:
          v5 = sub_BB4DB(*(_QWORD **)(v10 + 56), 1u, v12);
          result = a1;
          *(_QWORD *)(a1 + 56) = v5;
          break;
        case 0x20:
          v11 = lyd_lyb_data_length(*(_QWORD *)(v10 + 56), a2);
          if ( v11 == -1 )
          {
            result = sub_12222(v12, 0, 3, "Invalid LYB data.", v7, v8, v10);
          }
          else
          {
            *(_QWORD *)(a1 + 56) = malloc(v11);
            if ( *(_QWORD *)(a1 + 56) )
              result = (unsigned __int64)memcpy(*(void **)(a1 + 56), *(const void **)(v10 + 56), v11);
            else
              result = sub_12222(
                         v12,
                         0,
                         1,
                         "Memory allocation failed (%s()).",
                         (__int64)"lyd_merge_node_update",
                         v9,
                         v10);
          }
          break;
        default:
          return result;
      }
    }
  }
  return result;
}
// 7320: using guessed type __int64 __fastcall lyd_lyb_data_length(_QWORD, _QWORD);
// 75F0: using guessed type __int64 __fastcall lyxml_free_withsiblings(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000B308E) ----------------------------------------------------
signed __int64 __fastcall sub_B308E(__int64 *a1, __int64 a2)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // [rsp+18h] [rbp-18h]

  if ( **(_QWORD **)(*a1 + 48) == **(_QWORD **)(*(_QWORD *)a2 + 48LL) )
  {
    if ( *a1 != *(_QWORD *)a2 )
      return 0LL;
  }
  else
  {
    v5 = sub_B28DB(a1, **(_QWORD **)(*(_QWORD *)a2 + 48LL));
    if ( !v5 )
    {
      v3 = *(_QWORD *)*a1;
      v4 = lyd_node_module(a1);
      sub_12222(
        **(_QWORD **)(*(_QWORD *)a2 + 48LL),
        0,
        3,
        "Target context does not contain a required schema node (%s:%s).",
        *(_QWORD *)(v4 + 8),
        v3,
        a2);
      return 0xFFFFFFFFLL;
    }
    if ( v5 != *(_QWORD *)a2 )
      return 0LL;
  }
  return 1LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000B317C) ----------------------------------------------------
signed __int64 __fastcall sub_B317C(_BYTE *a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax
  unsigned int v4; // [rsp+1Ch] [rbp-4h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  v2 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v2 == 32 )
    return 1LL;
  if ( v2 > 0x20 )
  {
    if ( v2 != 256 )
    {
      if ( v2 > 0x100 )
      {
        if ( v2 != 0x4000 && v2 != 32800 )
          goto LABEL_33;
      }
      else if ( v2 != 128 )
      {
        goto LABEL_33;
      }
    }
    return 1LL;
  }
  if ( v2 == 4 )
    return 1LL;
  if ( v2 <= 4 )
  {
    if ( v2 != 1 )
    {
LABEL_33:
      sub_12222(
        **(_QWORD **)(*(_QWORD *)a2 + 48LL),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
        2744LL,
        a2);
      return 0xFFFFFFFFLL;
    }
    return 1LL;
  }
  if ( v2 == 8 )
  {
    if ( a1[8] >= 0 )
    {
      v4 = sub_ABF28((__int64)a1, a2, 1);
      if ( v4 == 1 && *(_WORD *)(*(_QWORD *)a1 + 24LL) & 2 )
      {
        a1[8] |= 0x80u;
        v4 = 2;
      }
      result = v4;
    }
    else
    {
      if ( !(*(_WORD *)(*(_QWORD *)a1 + 24LL) & 2) )
        __assert_fail(
          "node1->schema->flags & LYS_CONFIG_R",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0xA9Bu,
          "lyd_merge_node_equal");
      result = 0LL;
    }
  }
  else
  {
    if ( v2 != 16 )
      goto LABEL_33;
    if ( a1[8] >= 0 )
    {
      v5 = sub_ABF28((__int64)a1, a2, 1);
      if ( v5 == 1 && !*(_BYTE *)(*(_QWORD *)a1 + 30LL) )
      {
        a1[8] |= 0x80u;
        v5 = 2;
      }
      result = v5;
    }
    else
    {
      if ( *(_BYTE *)(*(_QWORD *)a1 + 30LL) )
        __assert_fail(
          "!((struct lys_node_list *)node1->schema)->keys_size",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0xAA9u,
          "lyd_merge_node_equal");
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000B3375) ----------------------------------------------------
signed __int64 __fastcall sub_B3375(__int64 a1, __int64 a2, __int16 a3)
{
  signed __int64 result; // rax
  char v4; // al
  __int16 v5; // [rsp+Ch] [rbp-74h]
  __int64 v6; // [rsp+10h] [rbp-70h]
  signed int v7; // [rsp+20h] [rbp-60h]
  signed int v8; // [rsp+24h] [rbp-5Ch]
  __int64 v9; // [rsp+28h] [rbp-58h]
  __int64 *j; // [rsp+30h] [rbp-50h]
  __int64 **v11; // [rsp+38h] [rbp-48h]
  __int64 *k; // [rsp+40h] [rbp-40h]
  __int64 i; // [rsp+48h] [rbp-38h]
  __int64 v14; // [rsp+50h] [rbp-30h]
  __int64 v15; // [rsp+58h] [rbp-28h]
  __int64 v16; // [rsp+60h] [rbp-20h]
  __int64 *v17; // [rsp+68h] [rbp-18h]
  __int64 v18; // [rsp+70h] [rbp-10h]
  unsigned __int64 v19; // [rsp+78h] [rbp-8h]

  v6 = a2;
  v5 = a3;
  v19 = __readfsqword(0x28u);
  v8 = 0;
  v18 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  for ( i = a2; ; i = v14 )
  {
    if ( i )
    {
      v14 = *(_QWORD *)(i + 24);
      v4 = 1;
    }
    else
    {
      v4 = 0;
    }
    if ( !v4 )
      break;
    v16 = i;
    v9 = i;
    k = (__int64 *)a1;
    while ( v9 )
    {
      if ( *(_BYTE *)(v9 + 9) & 1 && v5 & 0x100 )
      {
        if ( i == v9 )
          break;
        j = (__int64 *)(&size + 1);
      }
      else
      {
        v7 = 0;
        if ( !*(_DWORD *)(v9 + 48) )
          sub_AC63C((const char **)v9);
        if ( k[7] )
        {
          j = 0LL;
          if ( !(unsigned int)sub_154F1(k[7], (__int64)&v9, *(_DWORD *)(v9 + 48), &v11) )
          {
            if ( (j = *v11, v7 = 1, *(_DWORD *)(*j + 56) == 16) && !*(_BYTE *)(*j + 30)
              || *(_DWORD *)(*j + 56) == 8 && *(_WORD *)(*j + 24) & 2 )
            {
              if ( !(*(_WORD *)(*j + 24) & 2) )
                __assert_fail(
                  "trg_child->schema->flags & LYS_CONFIG_R",
                  "/home/mantovan/Repositories/libyang/src/tree_data.c",
                  0xAE6u,
                  "lyd_merge_parent_children");
              while ( j && *((_BYTE *)j + 8) < 0 )
              {
                if ( (unsigned int)sub_15669(k[7], (__int64)&j, *((_DWORD *)j + 12), &v11) )
                  j = 0LL;
                else
                  j = *v11;
              }
              if ( j )
              {
                *((_BYTE *)j + 8) |= 0x80u;
                v7 = 2;
              }
              else
              {
                v7 = 0;
              }
            }
          }
        }
        else
        {
          for ( j = (__int64 *)k[8]; j; j = (__int64 *)j[3] )
          {
            v7 = sub_B308E(j, v9);
            if ( v7 == 1 )
              v7 = sub_B317C(j, v9);
            if ( v7 )
              break;
          }
        }
        if ( v7 <= 0 )
        {
          if ( v7 == -1 )
          {
            lyd_free_withsiblings(v6);
            return 1LL;
          }
        }
        else if ( *(_DWORD *)(*j + 56) & 0x8024 )
        {
          sub_B2929((unsigned __int64)j, v9);
        }
        else if ( v7 == 2 )
        {
          v8 = 1;
        }
        v15 = v9;
        v17 = k;
        if ( (*(_DWORD *)(*(_QWORD *)v9 + 56LL) == 1
           || *(_DWORD *)(*(_QWORD *)v9 + 56LL) == 16 && *(_BYTE *)(*(_QWORD *)v9 + 30LL))
          && *(_QWORD *)(v9 + 64)
          && j )
        {
          v16 = *(_QWORD *)(v9 + 64);
LABEL_51:
          for ( k = j; !v16; k = (__int64 *)k[5] )
          {
            v9 = *(_QWORD *)(v9 + 40);
            if ( *(_QWORD *)(v9 + 40) == *(_QWORD *)(i + 40) )
              break;
            v16 = *(_QWORD *)(v9 + 24);
          }
          if ( j )
            goto LABEL_61;
          goto LABEL_53;
        }
      }
      if ( i != v9 )
      {
        v16 = *(_QWORD *)(v9 + 24);
        goto LABEL_51;
      }
      if ( j )
        break;
      v16 = 0LL;
LABEL_53:
      if ( v18 == **(_QWORD **)(*(_QWORD *)v15 + 48LL) )
        lyd_unlink(v15);
      else
        v15 = lyd_dup_to_ctx(v15, 1LL, v18);
      if ( v6 == v9 )
        v6 = *(_QWORD *)(v6 + 24);
      if ( (unsigned int)lyd_insert(v17, v15) )
      {
        sub_12222(
          v18,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          2895LL);
        lyd_free_withsiblings(v6);
        return 1LL;
      }
      if ( i == v9 )
        break;
LABEL_61:
      v9 = v16;
    }
  }
  lyd_free_withsiblings(v6);
  if ( v8 )
    result = 2LL;
  else
    result = 0LL;
  return result;
}
// 74F0: using guessed type __int64 __fastcall lyd_dup_to_ctx(_QWORD, _QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7840: using guessed type __int64 __fastcall lyd_unlink(_QWORD);
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);

//----- (00000000000B384E) ----------------------------------------------------
signed __int64 __fastcall sub_B384E(__int64 *a1, _QWORD *a2, __int16 a3)
{
  unsigned int v3; // eax
  signed __int64 result; // rax
  __int64 v5; // ST40_8
  char v6; // al
  __int16 v7; // [rsp+Ch] [rbp-44h]
  _QWORD *v8; // [rsp+10h] [rbp-40h]
  __int64 *v9; // [rsp+18h] [rbp-38h]
  int v10; // [rsp+20h] [rbp-30h]
  int v11; // [rsp+20h] [rbp-30h]
  signed int v12; // [rsp+24h] [rbp-2Ch]
  __int64 *j; // [rsp+28h] [rbp-28h]
  _QWORD *i; // [rsp+30h] [rbp-20h]
  _QWORD *v15; // [rsp+38h] [rbp-18h]
  __int64 v16; // [rsp+48h] [rbp-8h]

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v12 = 0;
  v16 = **(_QWORD **)(*a1 + 48);
  while ( *(_QWORD *)(v9[4] + 24) )
    v9 = (__int64 *)v9[4];
  for ( i = a2; ; i = v15 )
  {
    if ( i )
    {
      v15 = (_QWORD *)i[3];
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
      break;
    for ( j = v9; ; j = (__int64 *)j[3] )
    {
      if ( !j )
        goto LABEL_39;
      v10 = sub_B308E(j, (__int64)i);
      if ( v10 == 1 )
        v10 = sub_B317C(j, (__int64)i);
      if ( v10 > 0 )
        break;
      if ( v10 == -1 )
      {
        lyd_free_withsiblings(v8);
        return 1LL;
      }
    }
    if ( v10 == 2 )
      v12 = 1;
    v3 = *(_DWORD *)(*j + 56);
    if ( v3 == 32 )
      goto LABEL_27;
    if ( v3 > 0x20 )
    {
      if ( v3 != 512 )
      {
        if ( v3 > 0x200 )
        {
          if ( v3 != 1024 )
          {
            if ( v3 != 32800 )
              goto LABEL_32;
LABEL_27:
            sub_B2929((unsigned __int64)j, (unsigned __int64)i);
            goto LABEL_39;
          }
        }
        else if ( v3 != 128 && v3 != 256 )
        {
LABEL_32:
          sub_12222(
            v16,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
            2962LL);
          lyd_free_withsiblings(v8);
          return 1LL;
        }
      }
    }
    else
    {
      if ( v3 == 4 )
        goto LABEL_27;
      if ( v3 > 4 )
      {
        if ( v3 == 8 )
          goto LABEL_39;
        if ( v3 != 16 )
          goto LABEL_32;
      }
      else if ( v3 != 1 )
      {
        goto LABEL_32;
      }
    }
    v11 = sub_B3375((__int64)j, i[8], v7);
    if ( v11 == 2 )
    {
      v12 = 1;
    }
    else if ( v11 )
    {
      lyd_free_withsiblings(v8);
      return 1LL;
    }
LABEL_39:
    if ( !j )
    {
      if ( v16 == **(_QWORD **)(*i + 48LL) )
      {
        lyd_unlink(i);
        if ( i == v8 )
          v8 = v15;
        lyd_insert_after(v9[4], i);
      }
      else
      {
        v5 = lyd_dup_to_ctx(i, 1LL, v16);
        lyd_insert_after(v9[4], v5);
      }
    }
  }
  lyd_free_withsiblings(v8);
  if ( v12 )
    result = 2LL;
  else
    result = 0LL;
  return result;
}
// 7310: using guessed type __int64 __fastcall lyd_insert_after(_QWORD, _QWORD);
// 74F0: using guessed type __int64 __fastcall lyd_dup_to_ctx(_QWORD, _QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7840: using guessed type __int64 __fastcall lyd_unlink(_QWORD);

//----- (00000000000B3B03) ----------------------------------------------------
signed __int64 __fastcall lyd_merge_to_ctx(__int64 **a1, _QWORD *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 j; // rax
  __int64 v11; // rbx
  const char *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // ST40_8
  __int64 v17; // [rsp+0h] [rbp-90h]
  __int16 v18; // [rsp+Ch] [rbp-84h]
  _QWORD *v19; // [rsp+10h] [rbp-80h]
  int l; // [rsp+20h] [rbp-70h]
  int v21; // [rsp+24h] [rbp-6Ch]
  int v22; // [rsp+28h] [rbp-68h]
  signed int v23; // [rsp+2Ch] [rbp-64h]
  unsigned int v24; // [rsp+30h] [rbp-60h]
  char v25; // [rsp+34h] [rbp-5Ch]
  __int64 *v26; // [rsp+38h] [rbp-58h]
  __int64 *v27; // [rsp+38h] [rbp-58h]
  _QWORD *v28; // [rsp+38h] [rbp-58h]
  __int64 *ii; // [rsp+38h] [rbp-58h]
  __int64 v30; // [rsp+40h] [rbp-50h]
  _BYTE *v31; // [rsp+40h] [rbp-50h]
  __int64 v32; // [rsp+40h] [rbp-50h]
  _QWORD *n; // [rsp+40h] [rbp-50h]
  __int64 *v34; // [rsp+40h] [rbp-50h]
  __int64 *v35; // [rsp+48h] [rbp-48h]
  __int64 *v36; // [rsp+50h] [rbp-40h]
  _QWORD *v37; // [rsp+58h] [rbp-38h]
  _QWORD *k; // [rsp+60h] [rbp-30h]
  _QWORD *m; // [rsp+60h] [rbp-30h]
  __int64 v40; // [rsp+68h] [rbp-28h]
  __int64 v41; // [rsp+70h] [rbp-20h]
  __int64 i; // [rsp+78h] [rbp-18h]

  v19 = a2;
  v18 = a3;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_merge_to_ctx", a4, a5, a6, a4);
  v26 = 0LL;
  v37 = 0LL;
  v41 = 0LL;
  v25 = 1;
  if ( !a1 || !*a1 || !a2 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_merge_to_ctx", v6);
    return 0xFFFFFFFFLL;
  }
  v35 = *a1;
  for ( i = lys_parent(**a1); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( i && !sub_40CD4(v35) )
  {
    sub_12222(**(_QWORD **)(i + 48), 0, 3, "Target not a top-level data tree.", v8, v9);
    return 0xFFFFFFFFLL;
  }
  if ( v17 && v17 != **(_QWORD **)(*v35 + 48) )
  {
    while ( *(_QWORD *)(v35[4] + 24) )
      v35 = (__int64 *)v35[4];
    *a1 = v35;
    v27 = 0LL;
    while ( v35 )
    {
      v30 = lyd_dup_to_ctx(v35, 1LL, v17);
      if ( !v30 )
        goto LABEL_123;
      if ( v27 )
      {
        if ( (unsigned int)lyd_insert_after(v27[4], v30) )
          goto LABEL_123;
      }
      else
      {
        v27 = (__int64 *)v30;
      }
      v35 = (__int64 *)v35[3];
    }
    v35 = v27;
    v26 = 0LL;
  }
  else if ( **(_QWORD **)(*a2 + 48LL) == **(_QWORD **)(*v35 + 48) )
  {
    if ( v17 == **(_QWORD **)(*a2 + 48LL) )
      v17 = 0LL;
  }
  else
  {
    v17 = **(_QWORD **)(*v35 + 48);
  }
  v21 = 0;
  for ( j = lys_parent(*a2); j && *(_DWORD *)(j + 56) != 0x10000; j = lys_parent(j) )
    ++v21;
  v36 = v35;
  v22 = 0;
  v23 = 1;
  if ( !v21 )
    goto LABEL_42;
  if ( v18 & 0x1000 )
  {
    v25 = *((_BYTE *)a2 + 9) & 1;
  }
  else
  {
    for ( k = a2; ; k = (_QWORD *)k[3] )
    {
      if ( !k )
        goto LABEL_42;
      if ( !(*((_BYTE *)k + 9) & 1) )
        break;
    }
    v25 = 0;
  }
  while ( 1 )
  {
    do
    {
LABEL_42:
      v40 = *a2;
      for ( l = 0; l < v21 - v22; ++l )
        v40 = lys_parent(v40);
      ++v22;
    }
    while ( v40 != *a2 && *(_DWORD *)(v40 + 56) & 0x1042 );
    if ( v40 == *a2 )
      break;
    if ( *(_DWORD *)(v40 + 56) != 1 )
    {
      v11 = *(_QWORD *)v40;
      v12 = sub_8164(*(_DWORD *)(v40 + 56));
      sub_12222(v17, 0, 3, "Cannot create %s \"%s\" for the merge.", (__int64)v12, v11, v17);
      goto LABEL_123;
    }
    if ( v37 )
    {
      if ( v17 )
      {
        if ( !(v18 & 0x400) )
        {
          v40 = sub_B2578(v40, v17);
          if ( !v40 )
          {
            v15 = lys_node_module(0LL);
            sub_12222(
              v17,
              0,
              3,
              "Target context does not contain schema node for the data node being merged (%s:%s).",
              *(_QWORD *)(v15 + 8),
              size,
              v17);
            goto LABEL_123;
          }
        }
      }
    }
    else
    {
      if ( v23 )
      {
        v26 = v36;
        v23 = 0;
      }
      else
      {
        v26 = (__int64 *)v36[8];
      }
      while ( v26 )
      {
        if ( v17 )
        {
          v41 = sub_B2578(v40, v17);
          if ( !v41 )
          {
            v13 = *(_QWORD *)v40;
            v14 = lys_node_module(v40);
            sub_12222(
              v17,
              0,
              3,
              "Target context does not contain schema node for the data node being merged (%s:%s).",
              *(_QWORD *)(v14 + 8),
              v13,
              v17);
            goto LABEL_123;
          }
        }
        else
        {
          v41 = v40;
        }
        if ( v41 == *v26 )
        {
          v36 = v26;
          break;
        }
        v26 = (__int64 *)v26[3];
      }
      if ( !(v18 & 0x400) )
        v40 = v41;
    }
    if ( !v26 )
    {
      v31 = sub_AE9DE(0LL, v40, v25);
      if ( v37 )
      {
        if ( (unsigned int)lyd_insert(v31, v37) )
          goto LABEL_123;
        v37 = v31;
      }
      else
      {
        v37 = v31;
      }
    }
  }
  if ( v18 & 0x400 )
  {
    for ( m = a2; m; m = (_QWORD *)m[3] )
    {
      sub_AF24B(m);
      if ( v18 & 0x1000 )
        break;
    }
    v28 = a2;
    if ( a2 != (_QWORD *)a2[4] && v18 & 0x1000 )
    {
      v16 = a2[4];
      lyd_unlink(a2);
      lyd_free_withsiblings(v16);
    }
  }
  else
  {
    v28 = 0LL;
    while ( v19 )
    {
      v32 = lyd_dup_to_ctx(v19, 1LL, v17);
      if ( !v32 )
      {
        lyd_free_withsiblings(v28);
        goto LABEL_123;
      }
      if ( v28 )
      {
        if ( (unsigned int)lyd_insert_after(v28[4], v32) )
        {
          lyd_free_withsiblings(v28);
          goto LABEL_123;
        }
      }
      else
      {
        v28 = (_QWORD *)v32;
      }
      if ( v18 & 0x1000 )
        break;
      v19 = (_QWORD *)v19[3];
    }
  }
  if ( v37 )
  {
    for ( n = v37; n[8]; n = (_QWORD *)n[8] )
      ;
    n[8] = v28;
    while ( v28 )
    {
      v28[5] = n;
      v28 = (_QWORD *)v28[3];
    }
  }
  else
  {
    v37 = v28;
  }
  if ( v23 )
    v24 = sub_B384E(v36, v37, v18);
  else
    v24 = sub_B3375((__int64)v36, (__int64)v37, v18);
  v37 = 0LL;
  if ( v24 == 2 )
  {
    for ( ii = v35; ii; ii = v34 )
    {
      *((_BYTE *)ii + 8) &= 0x7Fu;
      if ( *(_DWORD *)(*ii + 56) & 0x802C )
        v34 = 0LL;
      else
        v34 = (__int64 *)ii[8];
      if ( !v34 )
      {
        if ( ii == v35 )
          break;
        v34 = (__int64 *)ii[3];
      }
      while ( !v34 )
      {
        ii = (__int64 *)ii[5];
        if ( ii[5] == v35[5] )
          break;
        v34 = (__int64 *)ii[3];
      }
    }
    v24 = 0;
  }
  else if ( v24 )
  {
LABEL_123:
    if ( v35 != *a1 )
      lyd_free_withsiblings(v35);
    lyd_free_withsiblings(v37);
    return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(*v35 + 56) == 256 )
    lyd_schema_sort(v35, 1LL);
  if ( v35 != *a1 )
  {
    lyd_free_withsiblings(*a1);
    *a1 = v35;
  }
  return v24;
}
// 71D0: using guessed type __int64 __fastcall lyd_schema_sort(_QWORD, _QWORD);
// 7310: using guessed type __int64 __fastcall lyd_insert_after(_QWORD, _QWORD);
// 74F0: using guessed type __int64 __fastcall lyd_dup_to_ctx(_QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7840: using guessed type __int64 __fastcall lyd_unlink(_QWORD);
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B4417) ----------------------------------------------------
__int64 __fastcall lyd_merge(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  unsigned int v8; // [rsp+Ch] [rbp-14h]
  __int64 v9; // [rsp+18h] [rbp-8h]

  v9 = a1;
  v8 = a3;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_merge", a4, a5, a6);
  if ( a1 && a2 )
    return lyd_merge_to_ctx(&v9, a2, v8, **(_QWORD **)(*(_QWORD *)v9 + 48LL));
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_merge", v6);
  return 0xFFFFFFFFLL;
}
// 75E0: using guessed type __int64 __fastcall lyd_merge_to_ctx(_QWORD, _QWORD, _QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B44A8) ----------------------------------------------------
void __fastcall lyd_free_diff(void **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_free_diff", a4, a5, a6);
  if ( a1 )
  {
    free(*a1);
    free(a1[1]);
    free(a1[2]);
    free(a1);
  }
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B4516) ----------------------------------------------------
signed __int64 __fastcall sub_B4516(void **a1, _DWORD *a2, unsigned int a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  unsigned int v11; // ST1C_4
  __int64 v12; // [rsp+8h] [rbp-38h]
  __int64 v13; // [rsp+10h] [rbp-30h]
  int v14; // [rsp+18h] [rbp-28h]
  unsigned int v15; // [rsp+1Ch] [rbp-24h]
  __int64 v16; // [rsp+30h] [rbp-10h]
  void *v17; // [rsp+38h] [rbp-8h]
  void *v18; // [rsp+38h] [rbp-8h]
  void *v19; // [rsp+38h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  if ( !a1 )
    __assert_fail("diff", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0xCDBu, "lyd_difflist_add");
  if ( !a2 || !*a2 )
    __assert_fail("size && *size", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0xCDCu, "lyd_difflist_add");
  if ( !a5 && !a6 )
    __assert_fail("first || second", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0xCDDu, "lyd_difflist_add");
  if ( a5 )
  {
    v6 = **(_QWORD **)(*(_QWORD *)a5 + 48LL);
  }
  else if ( a6 )
  {
    v6 = **(_QWORD **)(*(_QWORD *)a6 + 48LL);
  }
  else
  {
    v6 = 0LL;
  }
  v16 = v6;
  if ( a3 + 1 == *a2 )
  {
    *a2 += 16;
    v17 = realloc(*a1, 4LL * (unsigned int)*a2);
    if ( !v17 )
    {
      sub_12222(v16, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_difflist_add", v7);
      return 1LL;
    }
    *a1 = v17;
    v18 = realloc(a1[1], 8LL * (unsigned int)*a2);
    if ( !v18 )
    {
      sub_12222(v16, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_difflist_add", v9);
      return 1LL;
    }
    a1[1] = v18;
    v19 = realloc(a1[2], 8LL * (unsigned int)*a2);
    if ( !v19 )
    {
      sub_12222(v16, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_difflist_add", v10);
      return 1LL;
    }
    a1[2] = v19;
  }
  *((_DWORD *)*a1 + v15) = v14;
  *((_QWORD *)a1[1] + v15) = v13;
  *((_QWORD *)a1[2] + v15) = v12;
  v11 = v15 + 1;
  *((_DWORD *)*a1 + v11) = 0;
  *((_QWORD *)a1[1] + v11) = 0LL;
  *((_QWORD *)a1[2] + v11) = 0LL;
  return 0LL;
}

//----- (00000000000B47F2) ----------------------------------------------------
signed __int64 __fastcall sub_B47F2(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r9
  __int64 v4; // rax
  unsigned int i; // [rsp+1Ch] [rbp-14h]
  _QWORD *v6; // [rsp+20h] [rbp-10h]
  _QWORD *v7; // [rsp+28h] [rbp-8h]

  for ( i = 0; i < *(_DWORD *)(a2 + 4); ++i )
  {
    v6 = *(_QWORD **)(8LL * i + *(_QWORD *)(a2 + 8));
    if ( *v6 == *a1 && v6[1] == a1[5] )
      break;
  }
  if ( i == *(_DWORD *)(a2 + 4) )
  {
    v7 = calloc(1uLL, 0x30uLL);
    if ( !v7 )
    {
      sub_12222(
        **(_QWORD **)(*a1 + 48LL),
        0,
        1,
        "Memory allocation failed (%s()).",
        (__int64)"diff_ordset_insert",
        v2,
        a2);
      return 1LL;
    }
    *v7 = *a1;
    v7[1] = a1[5];
    ly_set_add(a2, v7, 1LL);
  }
  v4 = *(_QWORD *)(8LL * i + *(_QWORD *)(a2 + 8));
  ++*(_DWORD *)(v4 + 16);
  return 0LL;
}
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (00000000000B491E) ----------------------------------------------------
__int64 __fastcall sub_B491E(__int64 a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+10h] [rbp-10h]
  unsigned int j; // [rsp+14h] [rbp-Ch]
  void *ptr; // [rsp+18h] [rbp-8h]

  if ( a1 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
    {
      ptr = *(void **)(8LL * i + *(_QWORD *)(a1 + 8));
      for ( j = 0; j < *((_DWORD *)ptr + 4); ++j )
        free(*(void **)(*((_QWORD *)ptr + 3) + 24LL * j + 16));
      free(*((void **)ptr + 3));
      free(ptr);
    }
    result = ly_set_free(a1);
  }
  return result;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);

//----- (00000000000B49D8) ----------------------------------------------------
signed __int64 __fastcall sub_B49D8(_BYTE *a1, __int64 a2, char a3)
{
  signed __int64 result; // rax
  int v4; // [rsp+2Ch] [rbp-4h]

  if ( a1[9] & 1 && !(a3 & 1) )
    return 1LL;
  if ( !(*(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x18) )
    goto LABEL_14;
  if ( a1[8] < 0 )
    return 1LL;
  v4 = sub_ABF28((__int64)a1, a2, a3 & 1);
  if ( v4 == -1 )
    return 0xFFFFFFFFLL;
  if ( v4 )
LABEL_14:
    result = 0LL;
  else
    result = 1LL;
  return result;
}

//----- (00000000000B4A6E) ----------------------------------------------------
signed __int64 __fastcall sub_B4A6E(__int64 a1, __int64 a2, void **a3, _DWORD *a4, _DWORD *a5, __int64 a6, __int64 a7, char a8)
{
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v11; // eax
  __int64 v12; // [rsp+0h] [rbp-30h]
  _DWORD *v13; // [rsp+8h] [rbp-28h]
  _DWORD *v14; // [rsp+10h] [rbp-20h]
  void **v15; // [rsp+18h] [rbp-18h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v8 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v8 == 32 )
  {
LABEL_27:
    if ( !(unsigned int)sub_ABBCE((_QWORD *)a1, (_QWORD *)a2) )
    {
      v11 = (*v13)++;
      if ( (unsigned int)sub_B4516(v15, v14, v11, 2, a1, a2) )
        return 0xFFFFFFFFLL;
    }
    goto LABEL_31;
  }
  if ( v8 <= 0x20 )
  {
    if ( v8 == 4 )
    {
      if ( !(unsigned int)sub_ABE70((_BYTE **)a1, (_BYTE **)a2, 0)
        || a8 & 1 && (*(_BYTE *)(a1 + 9) & 1) != (*(_BYTE *)(a2 + 9) & 1) )
      {
        v9 = (*v13)++;
        if ( (unsigned int)sub_B4516(v15, v14, v9, 2, a1, a2) )
          return 0xFFFFFFFFLL;
      }
      goto LABEL_31;
    }
    if ( v8 > 4 )
    {
      if ( v8 != 8 && v8 != 16 )
        goto LABEL_30;
      if ( *(_WORD *)(*(_QWORD *)a1 + 24LL) & 0x100 )
        sub_B47F2((_QWORD *)a1, a7);
    }
    else if ( v8 != 1 )
    {
LABEL_30:
      sub_12222(
        **(_QWORD **)(*(_QWORD *)a1 + 48LL),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
        3474LL,
        a6);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_19;
  }
  if ( v8 != 256 )
  {
    if ( v8 <= 0x100 )
    {
      if ( v8 != 128 )
        goto LABEL_30;
      goto LABEL_19;
    }
    if ( v8 != 0x4000 )
    {
      if ( v8 != 32800 )
        goto LABEL_30;
      goto LABEL_27;
    }
  }
LABEL_19:
  if ( *(_BYTE *)(a2 + 8) < 0 )
    __assert_fail(
      "!(second->validity & LYD_VAL_INUSE)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0xD7Au,
      "lyd_diff_match");
  *(_BYTE *)(a2 + 8) |= 0x80u;
  ly_set_add(v12, a1, 1LL);
LABEL_31:
  if ( *(_BYTE *)(a1 + 8) < 0 )
    __assert_fail(
      "!(first->validity & LYD_VAL_INUSE)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0xD97u,
      "lyd_diff_match");
  *(_BYTE *)(a1 + 8) |= 0x80u;
  return 0LL;
}
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (00000000000B4CF2) ----------------------------------------------------
_BOOL8 __fastcall sub_B4CF2(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 i; // [rsp+18h] [rbp-8h]

  v3 = a1;
  for ( i = a2; v3 && i; i = *(_QWORD *)(i + 40) )
  {
    if ( **(_QWORD **)(*(_QWORD *)v3 + 48LL) == **(_QWORD **)(*(_QWORD *)i + 48LL) )
    {
      if ( *(_QWORD *)v3 != *(_QWORD *)i )
        return 0LL;
    }
    else if ( !(unsigned int)sub_C462(**(_BYTE ***)v3, **(_BYTE ***)i) )
    {
      return 0LL;
    }
    if ( *(_DWORD *)(*(_QWORD *)v3 + 56LL) == 16 && (unsigned int)sub_ABF28(v3, i, 0) != 1 )
      return 0LL;
    v3 = *(_QWORD *)(v3 + 40);
  }
  return v3 == i;
}

//----- (00000000000B4DF4) ----------------------------------------------------
signed __int64 __fastcall sub_B4DF4(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned int v3; // er12
  unsigned int v4; // ebx
  void *ptr; // ST50_8
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-68h]
  unsigned int v9; // [rsp+28h] [rbp-48h]
  int v10; // [rsp+2Ch] [rbp-44h]
  __int64 i; // [rsp+30h] [rbp-40h]
  __int64 *v12; // [rsp+38h] [rbp-38h]
  _QWORD *v13; // [rsp+40h] [rbp-30h]
  __int64 v14; // [rsp+48h] [rbp-28h]
  _QWORD *v15; // [rsp+58h] [rbp-18h]

  v8 = a3;
  v14 = **(_QWORD **)(*a2 + 48LL);
  v9 = 0;
  for ( i = a2[4]; *(_QWORD *)(i + 24); i = *(_QWORD *)(i + 32) )
  {
    if ( *(_BYTE *)(i + 8) < 0 && *(_QWORD *)i == *a2 )
      ++v9;
  }
  if ( v9 != *(_DWORD *)(a1 + 16) )
  {
    v3 = *(_DWORD *)(a1 + 16) - v9;
    v4 = *(_DWORD *)(a1 + 16);
    ptr = (void *)lyd_path(a2);
    sub_12312(0x10u, (__int64)"detected moved element \"%s\" from %d to %d (distance %d)", (__int64)ptr, v9, v4, v3);
    free(ptr);
  }
  v15 = calloc(1uLL, 0x10uLL);
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL * v9 + 16) = v15;
  if ( v15 )
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL * v9 + 16) + 8LL) = *(_DWORD *)(a1 + 16) - v9;
    v10 = abs(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL * v9 + 16) + 8LL));
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL * v9) = a2;
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL * v9 + 8) = v8;
    ++*(_DWORD *)(a1 + 16);
    v12 = *(__int64 **)(a1 + 32);
    v13 = 0LL;
    while ( v12 )
    {
      if ( v10 >= abs(*((_DWORD *)v12 + 2)) )
      {
        *v15 = v12;
        if ( v13 )
          *v13 = v15;
        break;
      }
      if ( *v12 == *(_QWORD *)(a1 + 32) )
      {
        *v15 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 40) = v15;
        break;
      }
      v13 = v12;
      v12 = (__int64 *)*v12;
    }
    if ( *v15 == *(_QWORD *)(a1 + 32) )
    {
      if ( v15 == *(_QWORD **)(a1 + 40) )
      {
        if ( !*(_QWORD *)(a1 + 32) )
        {
          *v15 = v15;
          *(_QWORD *)(a1 + 40) = v15;
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 40);
        }
      }
      else
      {
        *(_QWORD *)(a1 + 32) = v15;
        if ( *v15 )
        {
          **(_QWORD **)(a1 + 40) = v15;
        }
        else
        {
          *(_QWORD *)(a1 + 40) = v15;
          *v15 = v15;
        }
      }
    }
    result = 0LL;
  }
  else
  {
    sub_12222(v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff_move_preprocess", v6);
    result = 1LL;
  }
  return result;
}
// 7920: using guessed type __int64 __fastcall lyd_path(_QWORD);

//----- (00000000000B5143) ----------------------------------------------------
void **__fastcall sub_B5143(__int64 a1, _DWORD *a2)
{
  __int64 v2; // r9
  _DWORD *v3; // ST00_8
  void **result; // rax
  __int64 v5; // r9
  _DWORD *v6; // ST00_8
  void **ptr; // [rsp+18h] [rbp-8h]

  ptr = (void **)malloc(0x18uLL);
  if ( ptr )
  {
    *a2 = 1;
    *ptr = calloc((unsigned int)*a2, 4uLL);
    ptr[1] = calloc((unsigned int)*a2, 8uLL);
    ptr[2] = calloc((unsigned int)*a2, 8uLL);
    if ( *ptr && ptr[1] && ptr[2] )
    {
      result = ptr;
    }
    else
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff_init_difflist", v5, a2);
      free(ptr[2]);
      free(ptr[1]);
      free(*ptr);
      free(ptr);
      *v6 = 0;
      result = 0LL;
    }
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff_init_difflist", v2, a2);
    *v3 = 0;
    result = 0LL;
  }
  return result;
}

//----- (00000000000B52AF) ----------------------------------------------------
void **__fastcall lyd_diff(_QWORD *a1, _QWORD *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void **result; // rax
  unsigned int v8; // eax
  unsigned int *v9; // rsi
  unsigned int v10; // eax
  __int64 v11; // r9
  __int64 v12; // rdx
  unsigned int v13; // eax
  unsigned int v14; // eax
  __int64 v15; // r9
  __int64 v16; // r9
  unsigned int v17; // eax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rdx
  unsigned int v21; // eax
  __int64 v22; // r9
  __int64 v23; // r9
  __int64 v24; // r9
  __int16 v25; // [rsp+Ch] [rbp-E4h]
  _QWORD *v26; // [rsp+10h] [rbp-E0h]
  _QWORD *v27; // [rsp+18h] [rbp-D8h]
  unsigned int v28; // [rsp+28h] [rbp-C8h]
  char v29; // [rsp+2Ch] [rbp-C4h]
  unsigned int v30; // [rsp+30h] [rbp-C0h]
  unsigned int v31; // [rsp+34h] [rbp-BCh]
  unsigned int l; // [rsp+38h] [rbp-B8h]
  int m; // [rsp+3Ch] [rbp-B4h]
  unsigned int jj; // [rsp+40h] [rbp-B0h]
  int v35; // [rsp+44h] [rbp-ACh]
  _QWORD *j; // [rsp+48h] [rbp-A8h]
  _QWORD *i; // [rsp+50h] [rbp-A0h]
  _QWORD *n; // [rsp+58h] [rbp-98h]
  _QWORD *k; // [rsp+60h] [rbp-90h]
  __int64 v40; // [rsp+68h] [rbp-88h]
  _QWORD *v41; // [rsp+70h] [rbp-80h]
  _QWORD *v42; // [rsp+78h] [rbp-78h]
  void **v43; // [rsp+80h] [rbp-70h]
  void **v44; // [rsp+88h] [rbp-68h]
  void *v45; // [rsp+90h] [rbp-60h]
  __int64 v46; // [rsp+98h] [rbp-58h]
  __int64 ii; // [rsp+A0h] [rbp-50h]
  __int64 v48; // [rsp+A8h] [rbp-48h]
  __int64 v49; // [rsp+B0h] [rbp-40h]
  void *ptr; // [rsp+B8h] [rbp-38h]
  void *v51; // [rsp+C0h] [rbp-30h]
  __int64 v52; // [rsp+C8h] [rbp-28h]
  __int64 *dest; // [rsp+D0h] [rbp-20h]
  unsigned __int64 v54; // [rsp+E8h] [rbp-8h]

  v27 = a1;
  v26 = a2;
  v25 = a3;
  v54 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_diff", a4, a5, a6);
  v40 = 0LL;
  v44 = 0LL;
  v30 = 0;
  v31 = 0;
  v45 = 0LL;
  v46 = 0LL;
  if ( !a1 )
  {
    if ( a2 && a2[5] )
    {
      sub_12222(
        **(_QWORD **)(*a2 + 48LL),
        0,
        3,
        "%s: \"first\" parameter is NULL and \"second\" is not top level.",
        (__int64)"lyd_diff",
        v6);
      result = 0LL;
    }
    else
    {
      v43 = sub_B5143(0LL, &v28);
      for ( i = a2; i; i = (_QWORD *)i[3] )
      {
        if ( !(*((_BYTE *)i + 9) & 1) || v25 & 1 )
        {
          v8 = v30++;
          v9 = &v28;
          if ( (unsigned int)sub_B4516(v43, &v28, v8, 4, 0LL, (__int64)i) )
            goto LABEL_234;
        }
        if ( v25 & 0x800 )
          break;
      }
      result = v43;
    }
    return result;
  }
  if ( !a2 )
  {
    v43 = sub_B5143(**(_QWORD **)(*a1 + 48LL), &v28);
    for ( i = a1; i; i = (_QWORD *)i[3] )
    {
      if ( !(*((_BYTE *)i + 9) & 1) || v25 & 1 )
      {
        v10 = v30++;
        v9 = &v28;
        if ( (unsigned int)sub_B4516(v43, &v28, v10, 1, (__int64)i, 0LL) )
          goto LABEL_234;
      }
      if ( v25 & 0x800 )
        break;
    }
    return v43;
  }
  v48 = **(_QWORD **)(*a1 + 48LL);
  if ( v25 & 0x800 )
  {
    if ( *a1 != *a2 )
    {
      sub_12222(v48, 0, 3, "%s: incompatible trees to compare with LYD_OPT_NOSIBLINGS option.", (__int64)"lyd_diff", v6);
      return 0LL;
    }
    v27 = (_QWORD *)a1[8];
    v26 = (_QWORD *)a2[8];
  }
  else
  {
    if ( a1[5] )
    {
      v27 = *(_QWORD **)(a1[5] + 64LL);
    }
    else
    {
      while ( *(_QWORD *)(v27[4] + 24LL) )
        v27 = (_QWORD *)v27[4];
    }
    if ( a2[5] )
    {
      v26 = *(_QWORD **)(a2[5] + 64LL);
    }
    else
    {
      while ( *(_QWORD *)(v26[4] + 24LL) )
        v26 = (_QWORD *)v26[4];
    }
    if ( v27[5] && v26[5] && *(_QWORD *)v27[5] != *(_QWORD *)v26[5] || !v27[5] && v27[5] != v26[5] )
    {
      sub_12222(v48, 0, 3, "%s: incompatible trees with different parents.", (__int64)"lyd_diff", v6);
      return 0LL;
    }
  }
  if ( v27 == v26 )
  {
    sub_12222(v48, 0, 3, "%s: comparing the same tree does not make sense.", (__int64)"lyd_diff", v6);
    return 0LL;
  }
  v9 = &v28;
  v43 = sub_B5143(v48, &v28);
  if ( !v43 )
    goto LABEL_234;
  v9 = (unsigned int *)&v29;
  v44 = sub_B5143(v48, &v29);
  if ( !v44 )
    goto LABEL_234;
  v45 = malloc(0x18uLL);
  if ( !v45 )
  {
    v9 = 0LL;
    sub_12222(v48, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff", v11);
    goto LABEL_234;
  }
  *((_DWORD *)v45 + 4) = 0;
  *((_QWORD *)v45 + 1) = ly_set_new(24LL);
  *(_QWORD *)v45 = 0LL;
  v46 = ly_set_new(24LL);
  if ( !v46 )
  {
LABEL_234:
    while ( v45 )
    {
      ptr = v45;
      v45 = *(void **)v45;
      ly_set_free(*((_QWORD *)ptr + 1));
      free(ptr);
    }
    sub_B491E(v46);
    lyd_free_diff(v43, v9);
    lyd_free_diff(v44, v9);
    return 0LL;
  }
  v41 = v27;
  v42 = v26;
  for ( j = v26; j; j = v42 )
  {
    n = v41;
    if ( !(*((_BYTE *)j + 9) & 1) || v25 & 1 )
    {
      if ( n && n[5] && *(_QWORD *)(n[5] + 56LL) )
      {
        i = 0LL;
        v9 = (unsigned int *)&j;
        if ( !(unsigned int)sub_154F1(*(_QWORD *)(n[5] + 56LL), (__int64)&j, *((_DWORD *)j + 12), &dest) )
        {
          i = (_QWORD *)*dest;
          if ( *((_BYTE *)i + 9) & 1 && !(v25 & 1) )
            i = 0LL;
          while ( i && *((_BYTE *)i + 8) < 0 )
          {
            if ( !(*(_DWORD *)(*i + 56LL) & 0x18) || !(*(_WORD *)(*i + 24LL) & 2) )
              __assert_fail(
                "(iter->schema->nodetype & (LYS_LIST | LYS_LEAFLIST)) && (iter->schema->flags & LYS_CONFIG_R)",
                "/home/mantovan/Repositories/libyang/src/tree_data.c",
                0xEC1u,
                "lyd_diff");
            v9 = (unsigned int *)&i;
            if ( (unsigned int)sub_15669(*(_QWORD *)(n[5] + 56LL), (__int64)&i, *((_DWORD *)i + 12), &dest) )
              i = 0LL;
            else
              i = (_QWORD *)*dest;
          }
        }
      }
      else
      {
        for ( i = n; i; i = (_QWORD *)i[3] )
        {
          if ( *i == *j )
          {
            v9 = (unsigned int *)j;
            v35 = sub_B49D8(i, (__int64)j, v25);
            if ( v35 == -1 )
              goto LABEL_234;
            if ( !v35 )
              break;
          }
        }
      }
      if ( i )
      {
        v9 = (unsigned int *)j;
        if ( (unsigned int)sub_B4A6E((__int64)i, (__int64)j, v43, &v28, &v30, *((_QWORD *)v45 + 1), v46, v25) )
          goto LABEL_234;
      }
      if ( !i )
      {
        v12 = n ? n[5] : v40;
        v13 = v31++;
        v9 = (unsigned int *)&v29;
        if ( (unsigned int)sub_B4516(v44, &v29, v13, 4, v12, (__int64)j) )
          goto LABEL_234;
        if ( n && *(_WORD *)(*j + 24LL) & 0x100 )
        {
          for ( k = (_QWORD *)j[4]; k[3] && *k != *j; k = (_QWORD *)k[4] )
            ;
          if ( !k[3] )
            k = 0LL;
          v14 = v31++;
          v9 = (unsigned int *)&v29;
          if ( (unsigned int)sub_B4516(v44, &v29, v14, 5, (__int64)k, (__int64)j) )
            goto LABEL_234;
        }
      }
    }
    v41 = n;
    v42 = (_QWORD *)j[3];
    if ( v42 )
      goto LABEL_166;
    for ( l = *(_DWORD *)(v46 + 4); l; --l )
    {
      v49 = *(_QWORD *)(8LL * (l - 1) + *(_QWORD *)(v46 + 8));
      if ( *(_QWORD *)(v49 + 24) )
        break;
      v9 = (unsigned int *)&off_18;
      *(_QWORD *)(v49 + 24) = calloc(*(unsigned int *)(v49 + 16), 0x18uLL);
      if ( !*(_QWORD *)(v49 + 24) )
      {
        v9 = 0LL;
        sub_12222(v48, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff", v15);
        goto LABEL_234;
      }
      *(_QWORD *)(v49 + 32) = 0LL;
      *(_DWORD *)(v49 + 16) = 0;
    }
    if ( j[5] == v26[5] )
      j = v26;
    else
      j = *(_QWORD **)(j[5] + 64LL);
    for ( i = j; i; i = (_QWORD *)i[3] )
    {
      if ( *((_BYTE *)i + 8) < 0 )
      {
        if ( *((_DWORD *)v45 + 4) == *(_DWORD *)(*((_QWORD *)v45 + 1) + 4LL) )
        {
          if ( i != j )
          {
            v9 = 0LL;
            sub_12222(
              v48,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
              3886LL);
            goto LABEL_234;
          }
          i = 0LL;
          break;
        }
        *((_BYTE *)i + 8) &= 0x7Fu;
        if ( *(_DWORD *)(*i + 56LL) & 0x18 && *(_WORD *)(*i + 24LL) & 0x100 )
        {
          for ( m = *(_DWORD *)(v46 + 4); m; --m )
          {
            v49 = *(_QWORD *)(8LL * (unsigned int)(m - 1) + *(_QWORD *)(v46 + 8));
            if ( *(_QWORD *)v49 == *i )
            {
              v9 = (unsigned int *)i[5];
              if ( (unsigned int)sub_B4CF2(*(_QWORD *)(v49 + 8), (__int64)v9) )
              {
                v9 = *(unsigned int **)(*(_QWORD *)(*((_QWORD *)v45 + 1) + 8LL) + 8LL * *((unsigned int *)v45 + 4));
                sub_B4DF4(v49, v9, (__int64)i);
                break;
              }
            }
          }
        }
        if ( (*(_DWORD *)(*i + 56LL) == 1 || *(_DWORD *)(*i + 56LL) == 16 && *(_BYTE *)(*i + 30LL)) && i[8] )
        {
          while ( *((_DWORD *)v45 + 4) < *(_DWORD *)(*((_QWORD *)v45 + 1) + 4LL)
               && **(_QWORD **)(*(_QWORD *)(*((_QWORD *)v45 + 1) + 8LL) + 8LL * *((unsigned int *)v45 + 4)) != *i )
            ++*((_DWORD *)v45 + 4);
          if ( *((_DWORD *)v45 + 4) == *(_DWORD *)(*((_QWORD *)v45 + 1) + 4LL) )
          {
            v9 = 0LL;
            sub_12222(
              v48,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
              3912LL);
            goto LABEL_234;
          }
          v41 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v45 + 1) + 8LL) + 8LL * *((unsigned int *)v45 + 4))
                           + 64LL);
          if ( !v41 )
            v40 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v45 + 1) + 8LL) + 8LL * *((unsigned int *)v45 + 4));
          ++*((_DWORD *)v45 + 4);
          v42 = (_QWORD *)i[8];
          break;
        }
        ++*((_DWORD *)v45 + 4);
      }
    }
    if ( !i )
    {
      if ( v26 != j )
        goto LABEL_166;
      break;
    }
    ptr = malloc(0x18uLL);
    if ( !ptr )
    {
      v9 = 0LL;
      sub_12222(v48, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff", v16);
      goto LABEL_234;
    }
    *((_DWORD *)ptr + 4) = 0;
    *((_QWORD *)ptr + 1) = ly_set_new(24LL);
    *(_QWORD *)ptr = v45;
    v45 = ptr;
LABEL_166:
    if ( !v42 )
    {
      ly_set_clean(*((_QWORD *)v45 + 1));
      *((_DWORD *)v45 + 4) = 0;
      ptr = *(void **)v45;
      for ( i = *(_QWORD **)(j[5] + 24LL); ; i = (_QWORD *)i[3] )
      {
        if ( !i )
          goto LABEL_164;
        if ( *((_BYTE *)i + 8) < 0 )
        {
          if ( *((_DWORD *)ptr + 4) == *(_DWORD *)(*((_QWORD *)ptr + 1) + 4LL) )
          {
            if ( *(_QWORD **)(j[5] + 24LL) == i )
            {
              i = 0LL;
              goto LABEL_164;
            }
            v9 = 0LL;
            sub_12222(
              v48,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
              3965LL);
            goto LABEL_234;
          }
          *((_BYTE *)i + 8) &= 0x7Fu;
          if ( *(_DWORD *)(*i + 56LL) & 0x18 && *(_WORD *)(*i + 24LL) & 0x100 )
          {
            for ( m = *(_DWORD *)(v46 + 4); m; --m )
            {
              v49 = *(_QWORD *)(8LL * (unsigned int)(m - 1) + *(_QWORD *)(v46 + 8));
              if ( *(_QWORD *)v49 == *i )
              {
                v9 = (unsigned int *)i[5];
                if ( (unsigned int)sub_B4CF2(*(_QWORD *)(v49 + 8), (__int64)v9) )
                {
                  v9 = *(unsigned int **)(*(_QWORD *)(*((_QWORD *)ptr + 1) + 8LL) + 8LL * *((unsigned int *)ptr + 4));
                  sub_B4DF4(v49, v9, (__int64)i);
                  break;
                }
              }
            }
          }
          if ( (*(_DWORD *)(*i + 56LL) == 1 || *(_DWORD *)(*i + 56LL) == 16 && *(_BYTE *)(*i + 30LL)) && i[8] )
          {
            while ( *((_DWORD *)ptr + 4) < *(_DWORD *)(*((_QWORD *)ptr + 1) + 4LL)
                 && **(_QWORD **)(*(_QWORD *)(*((_QWORD *)ptr + 1) + 8LL) + 8LL * *((unsigned int *)ptr + 4)) != *i )
              ++*((_DWORD *)ptr + 4);
            if ( *((_DWORD *)ptr + 4) == *(_DWORD *)(*((_QWORD *)ptr + 1) + 4LL) )
            {
              v9 = 0LL;
              sub_12222(
                v48,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
                3991LL);
              goto LABEL_234;
            }
            v41 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + 1) + 8LL) + 8LL * *((unsigned int *)ptr + 4))
                             + 64LL);
            if ( !v41 )
              v40 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + 1) + 8LL) + 8LL * *((unsigned int *)ptr + 4));
            ++*((_DWORD *)ptr + 4);
            v42 = (_QWORD *)i[8];
LABEL_164:
            if ( !i )
            {
              j = (_QWORD *)j[5];
              ly_set_free(*((_QWORD *)v45 + 1));
              ptr = v45;
              v45 = *(void **)v45;
              free(ptr);
              if ( !*(_QWORD *)v45 )
                break;
            }
            goto LABEL_166;
          }
          ++*((_DWORD *)ptr + 4);
        }
      }
    }
  }
  ly_set_free(*((_QWORD *)v45 + 1));
  free(v45);
  v45 = 0LL;
  v41 = v27;
  for ( n = v27; n; n = v41 )
  {
    if ( *((_BYTE *)n + 8) >= 0 )
    {
      if ( !(*((_BYTE *)n + 9) & 1) || v25 & 1 )
      {
        v17 = v30++;
        v9 = &v28;
        if ( (unsigned int)sub_B4516(v43, &v28, v17, 1, (__int64)n, 0LL) )
          goto LABEL_234;
LABEL_182:
        v41 = (_QWORD *)n[3];
        goto LABEL_185;
      }
    }
    else
    {
      *((_BYTE *)n + 8) &= 0x7Fu;
    }
    if ( !(*(_DWORD *)(*n + 56LL) & 0x802C) && (*(_DWORD *)(*n + 56LL) != 16 || *(_BYTE *)(*n + 30LL)) )
      v41 = (_QWORD *)n[8];
    else
      v41 = 0LL;
    if ( !v41 )
      goto LABEL_182;
LABEL_185:
    while ( !v41 )
    {
      n = (_QWORD *)n[5];
      if ( n == (_QWORD *)v27[5] )
        break;
      v41 = (_QWORD *)n[3];
    }
  }
  for ( l = 0; l < *(_DWORD *)(v46 + 4); ++l )
  {
    v49 = *(_QWORD *)(8LL * l + *(_QWORD *)(v46 + 8));
    if ( *(_DWORD *)(*(_QWORD *)(v49 + 32) + 8LL) )
    {
      for ( ii = *(_QWORD *)(v49 + 32); ; ii = *(_QWORD *)ii )
      {
        v52 = ii;
        while ( !*(_DWORD *)(ii + 8) )
        {
          ii = *(_QWORD *)ii;
          if ( ii == v52 )
            goto LABEL_210;
        }
        for ( jj = 0; jj < *(_DWORD *)(v49 + 16) && ii != *(_QWORD *)(*(_QWORD *)(v49 + 24) + 24LL * jj + 16); ++jj )
          ;
        memcpy(&dest, (const void *)(24LL * jj + *(_QWORD *)(v49 + 24)), 0x18uLL);
        if ( *(_DWORD *)(ii + 8) <= 0 )
        {
          while ( *(_DWORD *)(ii + 8) )
          {
            memcpy(
              (void *)(*(_QWORD *)(v49 + 24) + 24LL * jj),
              (const void *)(*(_QWORD *)(v49 + 24) + 24LL * (jj - 1)),
              0x18uLL);
            v19 = *(_QWORD *)(*(_QWORD *)(v49 + 24) + 24LL * jj + 16);
            --*(_DWORD *)(v19 + 8);
            ++*(_DWORD *)(ii + 8);
            --jj;
          }
        }
        else
        {
          while ( *(_DWORD *)(ii + 8) )
          {
            memcpy(
              (void *)(*(_QWORD *)(v49 + 24) + 24LL * jj),
              (const void *)(*(_QWORD *)(v49 + 24) + 24LL * (jj + 1)),
              0x18uLL);
            v18 = *(_QWORD *)(*(_QWORD *)(v49 + 24) + 24LL * jj + 16);
            ++*(_DWORD *)(v18 + 8);
            --*(_DWORD *)(ii + 8);
            ++jj;
          }
        }
        memcpy((void *)(24LL * jj + *(_QWORD *)(v49 + 24)), &dest, 0x18uLL);
        v20 = jj ? *(_QWORD *)(*(_QWORD *)(v49 + 24) + 24LL * (jj - 1)) : 0LL;
        v21 = v30++;
        v9 = &v28;
        if ( (unsigned int)sub_B4516(v43, &v28, v21, 3, (__int64)dest, v20) )
          break;
      }
      goto LABEL_234;
    }
LABEL_210:
    ;
  }
  sub_B491E(v46);
  v46 = 0LL;
  if ( v31 )
  {
    if ( v30 + v31 + 1 >= v28 )
    {
      v28 = v30 + v31 + 1;
      v51 = realloc(*v43, 4LL * v28);
      if ( !v51 )
      {
        v9 = 0LL;
        sub_12222(v48, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff", v22);
        goto LABEL_234;
      }
      *v43 = v51;
      v51 = realloc(v43[1], 8LL * v28);
      if ( !v51 )
      {
        v9 = 0LL;
        sub_12222(v48, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff", v23);
        goto LABEL_234;
      }
      v43[1] = v51;
      v51 = realloc(v43[2], 8LL * v28);
      if ( !v51 )
      {
        v9 = 0LL;
        sub_12222(v48, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_diff", v24);
        goto LABEL_234;
      }
      v43[2] = v51;
    }
    memcpy((char *)*v43 + 4 * v30, *v44, 4LL * (v31 + 1));
    memcpy((char *)v43[1] + 8 * v30, v44[1], 8LL * (v31 + 1));
    v9 = (unsigned int *)v44[2];
    memcpy((char *)v43[2] + 8 * v30, v9, 8LL * (v31 + 1));
  }
  lyd_free_diff(v44, v9);
  return v43;
}
// 18: using guessed type __int64 (__fastcall *)();
// 7230: using guessed type __int64 __fastcall ly_set_clean(_QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7B30: using guessed type __int64 __fastcall lyd_free_diff(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B6CAE) ----------------------------------------------------
__int64 __fastcall sub_B6CAE(__int64 a1)
{
  __int64 result; // rax
  _QWORD *v2; // [rsp+18h] [rbp-18h]
  __int64 k; // [rsp+18h] [rbp-18h]
  _QWORD *j; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1066u, "lyd_insert_setinvalid");
  *(_BYTE *)(a1 + 8) = sub_C3AB(*(_QWORD *)a1);
  for ( i = *(_QWORD *)(a1 + 40); i && *(_DWORD *)(*(_QWORD *)i + 56LL) != 16; i = *(_QWORD *)(i + 40) )
    ;
  if ( i && !(*(_BYTE *)(i + 8) & 2) )
  {
    for ( j = (_QWORD *)a1; ; j = v2 )
    {
      if ( !j )
        break;
      if ( *(_DWORD *)(*j + 56LL) != 16 )
      {
        if ( *(_DWORD *)(*j + 56LL) == 4 && *(_WORD *)(*j + 24LL) & 0x100 )
        {
          *(_BYTE *)(i + 8) |= 2u;
          break;
        }
        if ( *(_DWORD *)(*j + 56LL) & 0x802C )
        {
          if ( j == (_QWORD *)a1 )
            break;
        }
        else
        {
          v2 = (_QWORD *)j[8];
          if ( v2 )
            goto LABEL_23;
        }
      }
      v2 = (_QWORD *)j[3];
      if ( !v2 && j == (_QWORD *)a1 )
        break;
LABEL_23:
      while ( !v2 )
      {
        j = (_QWORD *)j[5];
        if ( j[5] == *(_QWORD *)(a1 + 40) )
          break;
        v2 = *(_QWORD **)(j[5] + 24LL);
      }
    }
  }
  result = *(_QWORD *)(a1 + 40);
  if ( result )
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 8 && *(_DWORD *)(*(_QWORD *)a1 + 212LL) )
    {
      result = *(_QWORD *)(a1 + 40);
      *(_BYTE *)(result + 8) = *(_BYTE *)(*(_QWORD *)(a1 + 40) + 8LL) | 4;
    }
    else if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x10 && *(_DWORD *)(*(_QWORD *)a1 + 156LL) )
    {
      result = *(_QWORD *)(a1 + 40);
      *(_BYTE *)(result + 8) = *(_BYTE *)(*(_QWORD *)(a1 + 40) + 8LL) | 4;
    }
    else
    {
      result = *(_QWORD *)(a1 + 40);
      for ( k = *(_QWORD *)(a1 + 40); k; k = *(_QWORD *)(k + 40) )
      {
        if ( *(_WORD *)(*(_QWORD *)k + 24LL) & 0x2000 )
        {
          if ( *(_WORD *)(*(_QWORD *)k + 24LL) & 0x4000 )
            *(_BYTE *)(k + 8) |= 4u;
        }
        result = *(_QWORD *)(k + 40);
      }
    }
  }
  return result;
}

//----- (00000000000B6F47) ----------------------------------------------------
__int64 __fastcall sub_B6F47(_QWORD *a1, _QWORD *a2)
{
  _QWORD *j; // [rsp+10h] [rbp-10h]
  _QWORD *i; // [rsp+18h] [rbp-8h]

  if ( a2 )
  {
    if ( a2[5] || *(_QWORD *)(a2[4] + 24LL) )
    {
      a2[3] = 0LL;
      a2[4] = a2;
      i = a2;
    }
    else
    {
      for ( i = a2; i[3]; i = (_QWORD *)i[3] )
        i[5] = a1[5];
    }
    if ( a1[5] && a1 == *(_QWORD **)(a1[5] + 64LL) )
      *(_QWORD *)(a1[5] + 64LL) = a2;
    if ( a1 != (_QWORD *)a1[4] )
    {
      if ( *(_QWORD *)(a1[4] + 24LL) )
        *(_QWORD *)(a1[4] + 24LL) = a2;
      a2[4] = a1[4];
      a1[4] = a1;
      if ( a1[3] )
      {
        *(_QWORD *)(a1[3] + 32LL) = i;
        i[3] = a1[3];
        a1[3] = 0LL;
      }
      else if ( a2[5] )
      {
        *(_QWORD *)(*(_QWORD *)(a2[5] + 64LL) + 32LL) = i;
      }
      else
      {
        for ( j = a2; a1 != (_QWORD *)j[4]; j = (_QWORD *)j[4] )
          ;
        j[4] = i;
      }
    }
  }
  return lyd_free(a1);
}
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000B70F6) ----------------------------------------------------
signed __int64 __fastcall sub_B70F6(_QWORD *a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int v11; // edx
  const char *v12; // rdx
  const char *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // eax
  char v18; // al
  __int64 v19; // rax
  __int64 v20; // rsi
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  char v24; // al
  int v25; // [rsp+4h] [rbp-8Ch]
  __int64 *v26; // [rsp+8h] [rbp-88h]
  __int64 *v27; // [rsp+10h] [rbp-80h]
  _QWORD *v28; // [rsp+18h] [rbp-78h]
  unsigned __int8 v29; // [rsp+2Bh] [rbp-65h]
  unsigned int v30; // [rsp+2Ch] [rbp-64h]
  _BOOL4 v31; // [rsp+30h] [rbp-60h]
  int v32; // [rsp+34h] [rbp-5Ch]
  int v33; // [rsp+38h] [rbp-58h]
  int v34; // [rsp+3Ch] [rbp-54h]
  _QWORD *i; // [rsp+40h] [rbp-50h]
  __int64 j; // [rsp+48h] [rbp-48h]
  __int64 k; // [rsp+50h] [rbp-40h]
  __int64 v38; // [rsp+58h] [rbp-38h]
  _QWORD *m; // [rsp+60h] [rbp-30h]
  __int64 *l; // [rsp+68h] [rbp-28h]
  __int64 *v41; // [rsp+70h] [rbp-20h]
  _QWORD *v42; // [rsp+78h] [rbp-18h]
  __int64 v43; // [rsp+80h] [rbp-10h]
  unsigned __int64 v44; // [rsp+88h] [rbp-8h]

  v28 = a1;
  v27 = a2;
  v26 = a3;
  v25 = a4;
  v44 = __readfsqword(0x28u);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v43 = 0LL;
  v34 = 1536;
  if ( !a1 && !a2 )
    __assert_fail(
      "parent || sibling",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x10FEu,
      "lyd_insert_common");
  if ( a1 )
  {
    i = (_QWORD *)a1[8];
  }
  else
  {
    for ( i = (_QWORD *)*a2; *(_QWORD *)(i[4] + 24LL); i = (_QWORD *)i[4] )
      ;
  }
  if ( i )
  {
    if ( a1 && *(_DWORD *)(*a1 + 56LL) & 0x4100 )
    {
      j = *a1;
      v34 = 16640;
    }
    else
    {
      for ( j = lys_parent(*i); j && !(*(_DWORD *)(j + 56) & 0x691); j = lys_parent(j) )
        ;
    }
  }
  else
  {
    if ( !a1 )
    {
      if ( a3[5] || *(_QWORD *)(a3[4] + 24) )
        sub_BA11B(a3, 1, (__int64)a3, a4, a5, a6);
      *a2 = (__int64)v26;
      return 0LL;
    }
    j = *a1;
    if ( *(_DWORD *)(j + 56) & 0x4100 )
      v34 = 16640;
  }
  v7 = *v26;
  for ( k = lys_parent(*v26); k; k = lys_parent(k) )
  {
    v11 = v34;
    LOBYTE(v11) = v34 | 0x91;
    if ( v11 & *(_DWORD *)(k + 56) )
      break;
    v7 = k;
  }
  if ( j == k )
  {
    if ( v25 )
    {
      v7 = *v26;
      v31 = sub_34D50(*v26);
      v30 = v31;
      if ( !v28 || v28 != (_QWORD *)v26[5] || v31 )
        ++v30;
    }
    if ( v26[5] || *(_QWORD *)(v26[4] + 24) )
    {
      v7 = (__int64)v26;
      sub_BA11B(v26, v30, v30, v8, v9, v10);
    }
    v43 = ly_set_new(v7);
    for ( l = v26; ; l = v41 )
    {
      if ( l )
      {
        v41 = (__int64 *)l[3];
        v24 = 1;
      }
      else
      {
        v24 = 0;
      }
      if ( !v24 )
        break;
      if ( v30 == 1 && (unsigned int)sub_3010D(l, 0LL, (char **)&i, 1, 0LL) )
      {
        ly_set_free(v43);
        return 1LL;
      }
      l[4] = (__int64)l;
      l[3] = 0LL;
      m = 0LL;
      if ( !(*((_BYTE *)l + 9) & 1) )
        v32 = 1;
      if ( *((_BYTE *)l + 9) & 1 || *(_DWORD *)(*l + 56) != 4 || !lys_is_key(*l, &v29) )
      {
        if ( *(_DWORD *)(*l + 56) == 8 )
        {
          v33 = *(_DWORD *)(v43 + 4);
          v17 = ly_set_add(v43, *l, 0LL);
          if ( v33 != v17 || *((_BYTE *)l + 9) & 1 )
          {
            for ( m = i; ; m = v42 )
            {
              if ( m )
              {
                v42 = (_QWORD *)m[3];
                v18 = 1;
              }
              else
              {
                v18 = 0;
              }
              if ( !v18 )
                break;
              if ( *m == *l
                && (*((_BYTE *)l + 9) & 1
                 && (!(*((_BYTE *)m + 9) & 1)
                  || *(_WORD *)(*m + 24LL) & 1 && !strcmp((const char *)m[7], (const char *)l[7]))
                 || !(*((_BYTE *)l + 9) & 1) && *((_BYTE *)m + 9) & 1) )
              {
                if ( m == i )
                  i = v42;
                lyd_free(m);
              }
            }
          }
        }
        else if ( *(_DWORD *)(*l + 56) == 4 || *(_DWORD *)(*l + 56) == 1 && !*(_QWORD *)(*l + 136) )
        {
          for ( m = i; m; m = (_QWORD *)m[3] )
          {
            if ( *m == *l )
            {
              if ( *((_BYTE *)l + 9) & 1 || *((_BYTE *)m + 9) & 1 )
                sub_B6F47(m, l);
              else
                m = 0LL;
              break;
            }
          }
        }
      }
      else
      {
        v33 = 0;
        for ( m = (_QWORD *)v28[8]; m && v33 < v29 && *(_DWORD *)(*m + 56LL) == 4; m = (_QWORD *)m[3] )
          ++v33;
        if ( m )
        {
          if ( m == (_QWORD *)v28[8] )
            v28[8] = l;
          if ( *(_QWORD *)(m[4] + 24LL) )
            *(_QWORD *)(m[4] + 24LL) = l;
          l[4] = m[4];
          m[4] = l;
          l[3] = (__int64)m;
          if ( (_QWORD *)v28[8] != i )
            i = (_QWORD *)v28[8];
        }
      }
      if ( !m )
      {
        if ( i )
        {
          if ( v31 )
          {
            for ( j = *(_QWORD *)(*l + 64); !(*(_DWORD *)(j + 56) & 0x600); j = lys_parent(j) )
              ;
            v38 = 0LL;
            for ( m = i; m; m = (_QWORD *)m[3] )
            {
              do
              {
                v19 = lys_node_module(j);
                v38 = lys_getnext(v38, j, v19, 0LL);
              }
              while ( v38 && v38 != *m && v38 != *l );
              if ( v38 == *l )
              {
                if ( !(*(_DWORD *)(v38 + 56) & 0x18) || v38 != *m )
                  goto LABEL_145;
                while ( m && v38 == *m )
                  m = (_QWORD *)m[3];
                if ( m )
                {
LABEL_145:
                  if ( m == i )
                  {
                    i = l;
                    if ( v28 )
                      v28[8] = l;
                  }
                  else
                  {
                    *(_QWORD *)(m[4] + 24LL) = l;
                  }
                  l[4] = m[4];
                  m[4] = l;
                  l[3] = (__int64)m;
                }
                break;
              }
            }
            if ( !m )
            {
              *(_QWORD *)(i[4] + 24LL) = l;
              l[4] = i[4];
              i[4] = l;
            }
          }
          else
          {
            *(_QWORD *)(i[4] + 24LL) = l;
            l[4] = i[4];
            i[4] = l;
          }
        }
        else
        {
          i = l;
          if ( v28 )
            v28[8] = l;
        }
      }
      v20 = l[5];
      sub_ACE40(l, v20, l[5], v14, v15, v16);
      l[5] = (__int64)v28;
      sub_ACC62((unsigned int *)l, v20, (__int64)v28, v21, v22, v23);
      if ( v25 )
        sub_AF24B(l);
      if ( v30 )
        sub_B6CAE((__int64)l);
    }
    ly_set_free(v43);
    if ( v32 )
    {
      for ( m = v28; m && *((_BYTE *)m + 9) & 1; m = (_QWORD *)m[5] )
        *((_BYTE *)m + 9) &= 0xFEu;
    }
    if ( v27 )
      *v27 = (__int64)i;
    result = 0LL;
  }
  else
  {
    if ( k )
      v12 = *(const char **)k;
    else
      v12 = "<top-lvl>";
    if ( j )
      v13 = *(const char **)j;
    else
      v13 = "<top-lvl>";
    sub_12222(
      **(_QWORD **)(*v28 + 48LL),
      0,
      3,
      "Cannot insert, different parents (\"%s\" and \"%s\").",
      (__int64)v13,
      (__int64)v12);
    result = 1LL;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7850: using guessed type __int64 __fastcall lys_is_key(_QWORD, _QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000B7A60) ----------------------------------------------------
signed __int64 __fastcall lyd_insert(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 *v9; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_insert", a4, a5, a6, a2);
  if ( v9 && a1 && !(*(_DWORD *)(*a1 + 56LL) & 0x802C) )
    return sub_B70F6(a1, 0LL, v9, 1LL, v6, v7);
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_insert", v7);
  return 1LL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B7AF8) ----------------------------------------------------
signed __int64 __fastcall lyd_insert_sibling(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  signed __int64 result; // rax
  _QWORD *v9; // rax
  __int64 *v10; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_insert_sibling", a4, a5, a6, a2);
  if ( a1 && v10 )
  {
    if ( *a1 )
      v9 = *(_QWORD **)(*a1 + 40);
    else
      v9 = 0LL;
    result = sub_B70F6(v9, a1, v10, 1LL, v6, v7);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_insert_sibling", v7);
    result = 1LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B7B96) ----------------------------------------------------
signed __int64 __fastcall sub_B7B96(__int64 *a1, __int64 *a2, int a3, int a4)
{
  signed __int64 result; // rax
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  const char *v8; // rdx
  const char *v9; // rax
  __int64 v10; // rax
  __int64 v11; // r9
  char v12; // al
  __int64 v13; // r9
  char v14; // al
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rsi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  int v24; // [rsp+8h] [rbp-98h]
  int v25; // [rsp+Ch] [rbp-94h]
  unsigned int *v26; // [rsp+10h] [rbp-90h]
  unsigned int v27; // [rsp+2Ch] [rbp-74h]
  __int64 *l; // [rsp+30h] [rbp-70h]
  __int64 i; // [rsp+38h] [rbp-68h]
  __int64 j; // [rsp+40h] [rbp-60h]
  __int64 *k; // [rsp+48h] [rbp-58h]
  __int64 *m; // [rsp+50h] [rbp-50h]
  unsigned int *n; // [rsp+58h] [rbp-48h]
  __int64 *v34; // [rsp+60h] [rbp-40h]
  __int64 *v35; // [rsp+68h] [rbp-38h]
  __int64 v36; // [rsp+70h] [rbp-30h]
  __int64 v37; // [rsp+78h] [rbp-28h]
  __int64 v38; // [rsp+80h] [rbp-20h]
  void *v39; // [rsp+88h] [rbp-18h]
  void *ptr; // [rsp+90h] [rbp-10h]
  unsigned __int64 v41; // [rsp+98h] [rbp-8h]

  v26 = (unsigned int *)a2;
  v25 = a3;
  v24 = a4;
  v41 = __readfsqword(0x28u);
  l = 0LL;
  v36 = 0LL;
  v37 = 0LL;
  v38 = 0LL;
  v27 = 0;
  if ( !a1 )
    __assert_fail("sibling", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1210u, "lyd_insert_nextto");
  if ( !a2 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1211u, "lyd_insert_nextto");
  v39 = **(void ***)(*a1 + 48);
  if ( a1 == a2 )
    return 0LL;
  for ( i = lys_parent(*a1); i && !(*(_DWORD *)(i + 56) & 0x4691); i = lys_parent(i) )
    ;
  for ( j = lys_parent(*a2); j && !(*(_DWORD *)(j + 56) & 0x4691); j = lys_parent(j) )
    ;
  if ( i == j )
  {
    if ( v24 )
    {
      if ( a2[5] != a1[5] || (v27 = sub_34D50(*a2)) != 0 || !a2[5] )
      {
        if ( a2[5] || v27 )
        {
          ++v27;
        }
        else
        {
          for ( k = (__int64 *)a2[4]; k != a2 && k != a1; k = (__int64 *)k[4] )
            ;
          if ( k == a2 )
            v27 = 1;
        }
      }
    }
    if ( !v27 || a2[5] || *(_QWORD *)(a2[4] + 24) )
    {
      v36 = a2[5];
      if ( a2 != (__int64 *)a2[4] )
        v37 = a2[4];
      v38 = a2[3];
      a2 = (__int64 *)v27;
      sub_BA11B(v26, v27, v27, v5, v6, v7);
    }
    if ( a1[5] )
    {
      l = *(__int64 **)(a1[5] + 64);
    }
    else
    {
      for ( l = a1; *(_QWORD *)(l[4] + 24); l = (__int64 *)l[4] )
        ;
    }
    if ( v27 )
    {
      for ( m = (__int64 *)v26; ; m = (__int64 *)n )
      {
        if ( m )
        {
          n = (unsigned int *)m[3];
          v14 = 1;
        }
        else
        {
          v14 = 0;
        }
        if ( !v14 )
          break;
        sub_B6CAE((__int64)m);
        if ( v27 == 1 )
        {
          a2 = 0LL;
          if ( (unsigned int)sub_3010D(m, 0LL, (char **)&l, 1, (char *)a1) == 2 )
          {
            v10 = ly_errpath(v39, 0LL);
            sub_13937(
              v39,
              -1,
              3u,
              (char *)a1,
              (__int64)"Insert request refers node (%s) that is going to be auto-deleted.",
              v10);
LABEL_111:
            if ( v37 )
            {
              lyd_insert_after(v37, v26);
            }
            else if ( v38 )
            {
              lyd_insert_before(v38, v26);
            }
            else if ( v36 )
            {
              *(_QWORD *)(v36 + 64) = v26;
              *((_QWORD *)v26 + 5) = v36;
            }
            return 1LL;
          }
        }
        if ( *(_DWORD *)(*m + 56) == 8 )
        {
          for ( k = l; ; k = v34 )
          {
            if ( k )
            {
              v34 = (__int64 *)k[3];
              v12 = 1;
            }
            else
            {
              v12 = 0;
            }
            if ( !v12 )
              break;
            if ( *k == *m )
            {
              if ( *((_BYTE *)m + 9) & 1
                && (!(*((_BYTE *)k + 9) & 1)
                 || *(_WORD *)(*k + 24) & 1 && (a2 = (__int64 *)m[7], !strcmp((const char *)k[7], (const char *)a2)))
                || !(*((_BYTE *)m + 9) & 1) && *((_BYTE *)k + 9) & 1 )
              {
                if ( k == a1 )
                {
                  ptr = (void *)lyd_path(a1);
                  sub_12222(
                    (__int64)v39,
                    0,
                    3,
                    "Insert request refers node (%s) that is going to be auto-deleted.",
                    (__int64)ptr,
                    v11);
                  free(ptr);
                  goto LABEL_111;
                }
                if ( k == l )
                  l = v34;
                lyd_free(k);
              }
            }
          }
        }
        else if ( *(_DWORD *)(*m + 56) == 4 || *(_DWORD *)(*m + 56) == 1 && !*(_QWORD *)(*m + 136) )
        {
          for ( k = l; k; k = (__int64 *)k[3] )
          {
            if ( *k == *m )
            {
              if ( *((_BYTE *)k + 9) & 1 || *((_BYTE *)m + 9) & 1 )
              {
                if ( k == a1 )
                {
                  ptr = (void *)lyd_path(a1);
                  sub_12222(
                    (__int64)v39,
                    0,
                    3,
                    "Insert request refers node (%s) that is going to be auto-deleted.",
                    (__int64)ptr,
                    v13);
                  free(ptr);
                  goto LABEL_111;
                }
                if ( k == l )
                  l = (__int64 *)k[3];
                lyd_free(k);
              }
              break;
            }
          }
        }
        m[5] = a1[5];
        v35 = m;
      }
    }
    else
    {
      v35 = (__int64 *)v26;
      *((_QWORD *)v26 + 5) = a1[5];
    }
    if ( v25 )
    {
      if ( *(_QWORD *)(a1[4] + 24) )
      {
        *(_QWORD *)(a1[4] + 24) = v26;
      }
      else if ( a1[5] )
      {
        *(_QWORD *)(a1[5] + 64) = v26;
      }
      *((_QWORD *)v26 + 4) = a1[4];
      a1[4] = (__int64)v35;
      v15 = (__int64)a1;
      v35[3] = (__int64)a1;
    }
    else
    {
      if ( a1[3] )
      {
        v35[3] = a1[3];
        *(_QWORD *)(a1[3] + 32) = v35;
      }
      else
      {
        l[4] = (__int64)v35;
      }
      a1[3] = (__int64)v26;
      v15 = (__int64)a1;
      *((_QWORD *)v26 + 4) = a1;
    }
    sub_ACC62(v26, (__int64)a2, v15, v5, v6, v7);
    for ( k = (__int64 *)v26; k != v35; k = (__int64 *)k[3] )
    {
      v19 = k[5];
      sub_ACE40(k, v19, k[5], v16, v17, v18);
      sub_ACC62((unsigned int *)k, v19, v20, v21, v22, v23);
    }
    if ( v24 )
    {
      for ( n = v26; n; n = (unsigned int *)*((_QWORD *)n + 3) )
      {
        sub_AF24B(n);
        if ( n == (unsigned int *)v35 )
          break;
      }
    }
    result = 0LL;
  }
  else
  {
    if ( j )
      v8 = *(const char **)j;
    else
      v8 = "<top-lvl>";
    if ( i )
      v9 = *(const char **)i;
    else
      v9 = "<top-lvl>";
    sub_12222((__int64)v39, 0, 3, "Cannot insert, different parents (\"%s\" and \"%s\").", (__int64)v9, (__int64)v8);
    result = 1LL;
  }
  return result;
}
// 7310: using guessed type __int64 __fastcall lyd_insert_after(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7560: using guessed type __int64 __fastcall lyd_insert_before(_QWORD, _QWORD);
// 7920: using guessed type __int64 __fastcall lyd_path(_QWORD);
// 7A70: using guessed type __int64 __fastcall ly_errpath(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000B8475) ----------------------------------------------------
signed __int64 __fastcall lyd_insert_before(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 *v8; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_insert_before", a4, a5, a6, a2);
  if ( v8 && a1 )
    return sub_B7B96(a1, v8, 1, 1);
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_insert_before", v6);
  return 1LL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B84FA) ----------------------------------------------------
signed __int64 __fastcall lyd_insert_after(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 *v8; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_insert_after", a4, a5, a6, a2);
  if ( v8 && a1 )
    return sub_B7B96(a1, v8, 0, 1);
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_insert_after", v6);
  return 1LL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B857F) ----------------------------------------------------
__int64 __fastcall sub_B857F(__int64 *a1)
{
  int i; // [rsp+18h] [rbp-8h]
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v3 = 1;
  for ( i = 0; i < *(_DWORD *)(*a1 + 60); ++i )
  {
    if ( a1 == *(__int64 **)(8LL * i + *(_QWORD *)(*a1 + 64)) )
      return v3;
    ++v3;
  }
  sub_12222(
    *a1,
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
    4856LL);
  return 0LL;
}

//----- (00000000000B8611) ----------------------------------------------------
signed __int64 __fastcall sub_B8611(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 i; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  _DWORD *v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+28h] [rbp-18h]

  v7 = a3;
  v8 = 0LL;
  for ( i = lys_node_module(a1); ; i = lys_node_module(a1) )
  {
    v5 = i;
    v6 = lys_parent(a1);
    v8 = lys_getnext(v8, v6, v5, 256LL);
    if ( !v8 )
      break;
    ++*v7;
    if ( a2 == v8 )
      return 0LL;
  }
  sub_12222(
    **(_QWORD **)(a1 + 48),
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
    4873LL);
  return 1LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000B86CF) ----------------------------------------------------
signed __int64 __fastcall compar(const void *a1, const void *a2)
{
  __int64 v2; // rbx
  __int64 *v3; // rax
  unsigned int v4; // ST18_4
  __int64 *v5; // rax
  signed __int64 result; // rax

  v2 = lys_node_module(**(_QWORD **)a1);
  if ( v2 == lys_node_module(**(_QWORD **)a2) )
  {
    if ( *((_DWORD *)a1 + 2) <= *((_DWORD *)a2 + 2) )
    {
      if ( *((_DWORD *)a1 + 2) >= *((_DWORD *)a2 + 2) )
        result = 0LL;
      else
        result = 0xFFFFFFFFLL;
    }
    else
    {
      result = 1LL;
    }
  }
  else
  {
    v3 = (__int64 *)lys_node_module(**(_QWORD **)a1);
    v4 = sub_B857F(v3);
    v5 = (__int64 *)lys_node_module(**(_QWORD **)a2);
    if ( v4 <= (unsigned int)sub_B857F(v5) )
      result = 0xFFFFFFFFLL;
    else
      result = 1LL;
  }
  return result;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000B87AA) ----------------------------------------------------
signed __int64 __fastcall lyd_schema_sort(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  __int64 v9; // rbx
  __int64 j; // rax
  int v11; // eax
  __int64 v12; // [rsp+8h] [rbp-38h]
  unsigned int nmemb; // [rsp+10h] [rbp-30h]
  unsigned int nmemb_4; // [rsp+14h] [rbp-2Ch]
  unsigned int nmemb_4a; // [rsp+14h] [rbp-2Ch]
  __int64 i; // [rsp+18h] [rbp-28h]
  __int64 *v17; // [rsp+18h] [rbp-28h]
  _QWORD *k; // [rsp+18h] [rbp-28h]
  __int64 v19; // [rsp+20h] [rbp-20h]
  _DWORD *ptr; // [rsp+28h] [rbp-18h]

  v12 = a1;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_schema_sort", a4, a5, a6);
  v19 = 0LL;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_schema_sort", v6);
    return 0xFFFFFFFFLL;
  }
  if ( a1 == *(_QWORD *)(a1 + 32) )
    goto LABEL_38;
  v12 = lyd_first_sibling(a1);
  nmemb = 0;
  for ( i = v12; i; i = *(_QWORD *)(i + 24) )
    ++nmemb;
  ptr = malloc(16LL * nmemb);
  if ( !ptr )
  {
    sub_12222(
      **(_QWORD **)(*(_QWORD *)v12 + 48LL),
      0,
      1,
      "Memory allocation failed (%s()).",
      (__int64)"lyd_schema_sort",
      v8);
    return 0xFFFFFFFFLL;
  }
  nmemb_4 = 0;
  v17 = (__int64 *)v12;
  while ( nmemb_4 < nmemb )
  {
    ptr[4 * nmemb_4 + 2] = 0;
    if ( !v19 || (v9 = lyd_node_module(v17), v9 != lys_node_module(v19)) )
    {
      v19 = *v17;
      for ( j = lys_parent(*v17); j && *(_DWORD *)(lys_parent(v19) + 56) & 0x1042; j = lys_parent(v19) )
        v19 = lys_parent(v19);
      if ( lys_parent(v19) )
      {
        v19 = *(_QWORD *)(lys_parent(v19) + 72);
        v11 = sub_B8611(v19, *v17, &ptr[4 * nmemb_4 + 2]);
        goto LABEL_21;
      }
      while ( *(_QWORD *)(*(_QWORD *)(v19 + 88) + 80LL) )
        v19 = *(_QWORD *)(v19 + 88);
    }
    v11 = sub_B8611(v19, *v17, &ptr[4 * nmemb_4 + 2]);
LABEL_21:
    if ( v11 )
    {
      free(ptr);
      return 0xFFFFFFFFLL;
    }
    *(_QWORD *)&ptr[4 * nmemb_4++] = v17;
    v17 = (__int64 *)v17[3];
  }
  qsort(ptr, nmemb, 0x10uLL, (__compar_fn_t)compar);
  for ( nmemb_4a = 0; nmemb_4a < nmemb; ++nmemb_4a )
  {
    if ( !nmemb_4a )
    {
      v12 = *(_QWORD *)ptr;
      if ( *(_QWORD *)(*(_QWORD *)ptr + 40LL) )
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)ptr + 40LL) + 64LL) = *(_QWORD *)ptr;
    }
    if ( nmemb_4a )
      *(_QWORD *)(*(_QWORD *)&ptr[4 * nmemb_4a] + 32LL) = *(_QWORD *)&ptr[4 * nmemb_4a - 4];
    else
      *(_QWORD *)(*(_QWORD *)ptr + 32LL) = *(_QWORD *)&ptr[4 * nmemb - 4];
    if ( nmemb_4a >= nmemb - 1 )
      *(_QWORD *)(*(_QWORD *)&ptr[4 * nmemb_4a] + 24LL) = 0LL;
    else
      *(_QWORD *)(*(_QWORD *)&ptr[4 * nmemb_4a] + 24LL) = *(_QWORD *)&ptr[4 * nmemb_4a + 4];
  }
  free(ptr);
LABEL_38:
  if ( a2 )
  {
    for ( k = (_QWORD *)v12; k; k = (_QWORD *)k[3] )
    {
      if ( *(_DWORD *)(*k + 56LL) & 0x4191 && k[8] && (unsigned int)lyd_schema_sort(k[8], a2) )
        return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}
// 71D0: using guessed type __int64 __fastcall lyd_schema_sort(_QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77E0: using guessed type __int64 __fastcall lyd_first_sibling(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B8BF3) ----------------------------------------------------
signed __int64 __fastcall sub_B8BF3(char **a1, __int64 a2, void *a3, __int64 a4, unsigned int a5, _QWORD *a6, __int64 a7)
{
  signed __int64 v7; // rsi
  __int64 v8; // r9
  const char *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  char v14; // al
  const char *v15; // rax
  void *v16; // rax
  __int64 v17; // rax
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r9
  _QWORD *v21; // rbx
  _QWORD *v22; // rbx
  _QWORD *v23; // [rsp+0h] [rbp-80h]
  unsigned int v24; // [rsp+Ch] [rbp-74h]
  __int64 v25; // [rsp+10h] [rbp-70h]
  void *v26; // [rsp+18h] [rbp-68h]
  __int64 v27; // [rsp+20h] [rbp-60h]
  unsigned int v28; // [rsp+30h] [rbp-50h]
  unsigned int j; // [rsp+34h] [rbp-4Ch]
  unsigned int m; // [rsp+34h] [rbp-4Ch]
  unsigned int n; // [rsp+34h] [rbp-4Ch]
  char *i; // [rsp+38h] [rbp-48h]
  char *l; // [rsp+38h] [rbp-48h]
  char *v34; // [rsp+40h] [rbp-40h]
  char *v35; // [rsp+48h] [rbp-38h]
  char *k; // [rsp+50h] [rbp-30h]
  __int64 *v37; // [rsp+58h] [rbp-28h]
  char *ptr; // [rsp+60h] [rbp-20h]
  __int64 v39; // [rsp+68h] [rbp-18h]

  v27 = a2;
  v26 = a3;
  v25 = a4;
  v24 = a5;
  v23 = a6;
  v37 = 0LL;
  v28 = 1;
  v7 = 40LL;
  ptr = (char *)calloc(1uLL, 0x28uLL);
  if ( !ptr )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"_lyd_validate", v8, v23);
    return 1LL;
  }
  if ( v23 )
  {
    *((_DWORD *)ptr + 5) = 1;
    v7 = (signed __int64)(ptr + 32);
    *((_QWORD *)ptr + 3) = sub_B5143((__int64)v26, (_DWORD *)ptr + 8);
  }
  if ( a7 & 0x30 && *a1 && *(_DWORD *)(*(_QWORD *)*a1 + 56LL) != 256 )
    LODWORD(a7) = a7 | 0x100;
  if ( a7 & 0xC0 && *a1 && *(_DWORD *)(*(_QWORD *)*a1 + 56LL) != 128 )
    LODWORD(a7) = a7 | 0x100;
  for ( i = *a1; ; i = v34 )
  {
    if ( i )
    {
      v34 = (char *)*((_QWORD *)i + 3);
      v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    if ( !v14 )
      break;
    if ( !v25 )
      goto LABEL_113;
    for ( j = 0; j < v24 && lyd_node_module(i) != *(_QWORD *)(8LL * j + v25); ++j )
      ;
    if ( j != v24 )
    {
LABEL_113:
      for ( k = i; k; k = v35 )
      {
        if ( *((_QWORD *)k + 5) && *(_DWORD *)(*(_QWORD *)k + 56LL) & 0x4080 )
        {
          if ( !(a7 & 0x100) || v37 )
          {
            sub_13937(v26, 47, 3u, k, **(_QWORD **)k, v8, v23);
            if ( a7 & 0x10 )
              v10 = "action";
            else
              v10 = "notification";
            v7 = 0xFFFFFFFFLL;
            sub_13937(v26, -1, 5u, 0LL, (__int64)"Unexpected %s node \"%s\".", (__int64)v10, **(_QWORD **)k);
            goto LABEL_103;
          }
          v37 = (__int64 *)k;
        }
        v7 = (unsigned int)a7;
        if ( (unsigned int)sub_2DC82(k, a7, (__int64)ptr) )
          goto LABEL_103;
        v7 = (unsigned int)a7;
        if ( (unsigned int)sub_2F7BD(k, a7, (__int64)ptr, v11, v12, v13) )
          goto LABEL_103;
        if ( !(k[9] & 1)
          && *(_DWORD *)(*(_QWORD *)k + 56LL) == 1
          && !*((_QWORD *)k + 8)
          && !*(_QWORD *)(*(_QWORD *)k + 136LL)
          && !*((_QWORD *)k + 2) )
        {
          k[9] |= 1u;
        }
        if ( *(_DWORD *)(*(_QWORD *)k + 56LL) & 0x802C )
          v35 = 0LL;
        else
          v35 = (char *)*((_QWORD *)k + 8);
        if ( !v35 )
        {
          if ( k == i )
            break;
          v35 = (char *)*((_QWORD *)k + 3);
        }
        while ( !v35 )
        {
          k = (char *)*((_QWORD *)k + 5);
          if ( *((_QWORD *)k + 5) == *((_QWORD *)i + 5) )
            break;
          v35 = (char *)*((_QWORD *)k + 3);
        }
      }
      if ( a7 & 0x1000 )
        break;
    }
  }
  if ( a7 & 0x100 )
  {
    if ( !v37 )
    {
      if ( a7 & 0x10 )
        v15 = "action";
      else
        v15 = "notification";
      v7 = 49LL;
      sub_13937(v26, 49, 3u, *a1, (__int64)v15, **(_QWORD **)*a1, v23);
      goto LABEL_103;
    }
    LODWORD(a7) = a7 & 0xFFFFFEFF;
  }
  if ( *a1 )
  {
    if ( v26 )
      v16 = v26;
    else
      v16 = **(void ***)(*(_QWORD *)*a1 + 48LL);
    v7 = (signed __int64)"ietf-yang-library";
    v39 = ly_ctx_get_module(v16, "ietf-yang-library", 0LL, 1LL);
    for ( l = *a1; l; l = (char *)*((_QWORD *)l + 3) )
    {
      if ( a7 & 0x20000 && v39 && v39 == *(_QWORD *)(*(_QWORD *)l + 48LL) )
        LODWORD(a7) = a7 & 0xFFFDFFFF;
      if ( *(_DWORD *)(*(_QWORD *)l + 56LL) & 0x18 && l[8] & 1 )
      {
        if ( a7 & 0x2000 )
        {
          l[8] &= 0xFEu;
        }
        else
        {
          v7 = (signed __int64)*a1;
          if ( (unsigned int)sub_2EE3F((__int64)l, (__int64)*a1) )
            goto LABEL_103;
        }
      }
    }
  }
  if ( a7 & 0x20000 )
  {
    if ( *a1 )
    {
      v17 = ly_ctx_info(v26, v7);
      if ( (unsigned int)lyd_merge(*a1, v17, 1280LL) )
      {
        v7 = 0LL;
        sub_12222((__int64)v26, 0, 4, "Adding ietf-yang-library data failed.", v18, v19, v23);
        goto LABEL_103;
      }
    }
    else
    {
      *a1 = (char *)ly_ctx_info(v26, v7);
    }
  }
  v7 = (unsigned int)a7;
  if ( !(unsigned int)sub_BF7F8((char ***)a1, a7, (__int64)v26, v25, v24, v27, (char **)v37, (__int64)ptr, 1) )
  {
    if ( v37 )
    {
      v7 = (signed __int64)v26;
      if ( (unsigned int)sub_AD9B9(v37, (__int64)v26, v25, v24, (unsigned int)a7, v20) )
        goto LABEL_103;
LABEL_88:
      if ( !(a7 & 0x30) || !*a1 || (v7 = 1LL, !(unsigned int)lyd_schema_sort(*a1, 1LL)) )
      {
        if ( v23 )
        {
          if ( !*((_DWORD *)ptr + 5) )
            __assert_fail(
              "unres->store_diff",
              "/home/mantovan/Repositories/libyang/src/tree_data.c",
              0x141Au,
              "_lyd_validate");
          for ( m = 0; m < *((_DWORD *)ptr + 9); ++m )
          {
            if ( *(_DWORD *)(4LL * m + **((_QWORD **)ptr + 3)) == 4 )
            {
              if ( *(_QWORD *)(*(_QWORD *)(8LL * m + *(_QWORD *)(*((_QWORD *)ptr + 3) + 16LL)) + 40LL) )
              {
                v21 = (_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + 3) + 8LL) + 8LL * m);
                *v21 = lyd_path(*(_QWORD *)(*(_QWORD *)(8LL * m + *(_QWORD *)(*((_QWORD *)ptr + 3) + 16LL)) + 40LL));
              }
              v22 = (_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + 3) + 16LL) + 8LL * m);
              v7 = 1LL;
              *v22 = lyd_dup(*v22, 1LL);
            }
          }
          *v23 = *((_QWORD *)ptr + 3);
          *((_QWORD *)ptr + 3) = 0LL;
          *((_DWORD *)ptr + 9) = 0;
        }
        v28 = 0;
      }
      goto LABEL_103;
    }
    v7 = (signed __int64)v26;
    if ( !(unsigned int)sub_AD9B9((__int64 *)*a1, (__int64)v26, v25, v24, (unsigned int)a7, v20) )
      goto LABEL_88;
  }
LABEL_103:
  if ( ptr )
  {
    free(*(void **)ptr);
    free(*((void **)ptr + 1));
    for ( n = 0; n < *((_DWORD *)ptr + 9); ++n )
    {
      if ( *(_DWORD *)(4LL * n + **((_QWORD **)ptr + 3)) == 1 )
      {
        lyd_free_withsiblings(*(_QWORD *)(8LL * n + *(_QWORD *)(*((_QWORD *)ptr + 3) + 8LL)));
        free(*(void **)(8LL * n + *(_QWORD *)(*((_QWORD *)ptr + 3) + 16LL)));
      }
    }
    lyd_free_diff(*((_QWORD *)ptr + 3), v7);
    free(ptr);
  }
  return v28;
}
// 71D0: using guessed type __int64 __fastcall lyd_schema_sort(_QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7390: using guessed type __int64 __fastcall ly_ctx_info(_QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7880: using guessed type __int64 __fastcall lyd_dup(_QWORD, _QWORD);
// 7920: using guessed type __int64 __fastcall lyd_path(_QWORD);
// 7B30: using guessed type __int64 __fastcall lyd_free_diff(_QWORD, _QWORD);
// 7B50: using guessed type __int64 __fastcall lyd_merge(_QWORD, _QWORD, _QWORD);

//----- (00000000000B9484) ----------------------------------------------------
signed __int64 __fastcall lyd_validate(char **a1, unsigned int a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // r9
  _QWORD *v9; // [rsp+8h] [rbp-108h]
  unsigned int v10; // [rsp+14h] [rbp-FCh]
  _QWORD *i; // [rsp+20h] [rbp-F0h]
  __int64 v12; // [rsp+28h] [rbp-E8h]
  _QWORD *v13; // [rsp+30h] [rbp-E0h]
  void *v14; // [rsp+38h] [rbp-D8h]
  _QWORD *v15; // [rsp+78h] [rbp-98h]

  v10 = a2;
  v9 = a3;
  v15 = (_QWORD *)a4;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_validate", a4, a5, a6);
  v13 = 0LL;
  v14 = 0LL;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_validate", v6);
    return 1LL;
  }
  if ( (unsigned int)sub_34DD2(0LL, a2, (__int64)"lyd_validate") )
    return 1LL;
  v12 = (__int64)*a1;
  if ( a2 & 0x10000FF && !(a2 & 0xF) || *a1 )
  {
    if ( a2 & 0x70 )
    {
      if ( a2 & 0x1000 )
      {
        sub_12222(
          0LL,
          0,
          3,
          "%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).",
          (__int64)"lyd_validate",
          v8);
        return 1LL;
      }
      if ( !*a1 )
      {
        sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_validate", v8);
        return 1LL;
      }
      v12 = (__int64)v9;
      if ( v9 )
      {
        if ( a2 & 0x8000 )
        {
          sub_12222(
            0LL,
            0,
            3,
            "%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).",
            (__int64)"lyd_validate",
            v8);
          return 1LL;
        }
        for ( i = v9; i; i = (_QWORD *)i[3] )
        {
          if ( i[5] )
          {
            sub_12222(
              0LL,
              0,
              3,
              "%s: invalid variable parameter (const struct lyd_node *data_tree).",
              (__int64)"lyd_validate",
              v8);
            return 1LL;
          }
        }
        while ( *(_QWORD *)(*(_QWORD *)(v12 + 32) + 24LL) )
          v12 = *(_QWORD *)(v12 + 32);
      }
    }
    else if ( a2 & 0x1000000 && *a1 && (*(_QWORD *)(*((_QWORD *)*a1 + 4) + 24LL) || *((_QWORD *)*a1 + 3)) )
    {
      sub_12222(0LL, 0, 3, "%s: invalid variable parameter (struct lyd_node *node).", (__int64)"lyd_validate", v8);
      return 1LL;
    }
  }
  else
  {
    v14 = v9;
    if ( !v9 )
    {
      sub_12222(0LL, 0, 3, "%s: invalid variable parameter (struct ly_ctx *ctx).", (__int64)"lyd_validate", v8);
      return 1LL;
    }
    v10 = a2 & 0xFFFFEFFF;
  }
  if ( !(v10 & 0x40000) || (v13 = v15) != 0LL )
  {
    if ( *a1 )
    {
      if ( !v14 )
        v14 = **(void ***)(*(_QWORD *)*a1 + 48LL);
      if ( !(v10 & 0x1000) )
      {
        while ( *(_QWORD *)(*((_QWORD *)*a1 + 4) + 24LL) )
          *a1 = (char *)*((_QWORD *)*a1 + 4);
      }
    }
    result = sub_B8BF3(a1, v12, v14, 0LL, 0, v13, v10);
  }
  else
  {
    sub_12222(
      (__int64)v14,
      0,
      3,
      "%s: invalid variable parameter (struct lyd_difflist **).",
      (__int64)"lyd_validate",
      v8);
    result = 1LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B99B7) ----------------------------------------------------
signed __int64 __fastcall lyd_validate_modules(char **a1, void ***a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // r9
  unsigned int v9; // [rsp+8h] [rbp-F8h]
  unsigned int v10; // [rsp+Ch] [rbp-F4h]
  _QWORD *v11; // [rsp+20h] [rbp-E0h]
  void *v12; // [rsp+28h] [rbp-D8h]
  _QWORD *v13; // [rsp+70h] [rbp-90h]

  v13 = (_QWORD *)a5;
  v10 = a3;
  v9 = a4;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_validate_modules", a4, a5, a6);
  v11 = 0LL;
  if ( a1 && a2 && v10 )
  {
    v12 = **a2;
    if ( *a1 && !(v9 & 0x1000) )
    {
      while ( *(_QWORD *)(*((_QWORD *)*a1 + 4) + 24LL) )
        *a1 = (char *)*((_QWORD *)*a1 + 4);
    }
    if ( (unsigned int)sub_34DD2((__int64)v12, v9, (__int64)"lyd_validate_modules") )
    {
      result = 1LL;
    }
    else if ( !(v9 & 0x10000FF) || v9 & 0xF )
    {
      if ( !(v9 & 0x40000) || (v11 = v13) != 0LL )
      {
        result = sub_B8BF3(a1, (__int64)*a1, v12, (__int64)a2, v10, v11, v9);
      }
      else
      {
        sub_12222(
          (__int64)v12,
          0,
          3,
          "%s: invalid variable parameter (struct lyd_difflist **).",
          (__int64)"lyd_validate_modules",
          v8);
        result = 1LL;
      }
    }
    else
    {
      sub_12222(0LL, 0, 3, "%s: options include a forbidden data type.", (__int64)"lyd_validate_modules", v8);
      result = 1LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_validate_modules", v6);
    result = 1LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B9C96) ----------------------------------------------------
signed __int64 __fastcall lyd_validate_value(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  void *v8; // [rsp+0h] [rbp-80h]
  unsigned int v9; // [rsp+14h] [rbp-6Ch]
  __int64 v10; // [rsp+18h] [rbp-68h]
  __int64 s; // [rsp+20h] [rbp-60h]
  __int64 v12; // [rsp+58h] [rbp-28h]
  int v13; // [rsp+68h] [rbp-18h]
  unsigned __int64 v14; // [rsp+78h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_validate_value", a4, a5, a6, a2);
  v10 = a1;
  v9 = 0;
  if ( a1 && *(_DWORD *)(a1 + 56) & 0xC )
  {
    if ( !v8 )
      v8 = &unk_12274D;
    memset(&s, 0, 0x50uLL);
    v12 = lydict_insert(**(_QWORD **)(a1 + 48), v8, 0LL);
    while ( 1 )
    {
      v13 = *(_DWORD *)(v10 + 128);
      s = a1;
      if ( v13 != 9 )
        break;
      if ( !*(_QWORD *)(v10 + 168) )
      {
        sub_12222(
          **(_QWORD **)(a1 + 48),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          5351LL,
          v8);
        v9 = 1;
        goto LABEL_13;
      }
      v10 = *(_QWORD *)(v10 + 168);
    }
    if ( !sub_37EF5(v10 + 128, (char **)&v12, 0LL, (__int64 **)&s, 0LL, 0LL, 0, 0, 0) )
      v9 = 1;
LABEL_13:
    lydict_remove(**(_QWORD **)(a1 + 48), v12);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_validate_value", v6);
    result = 1LL;
  }
  return result;
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000B9E6F) ----------------------------------------------------
__int64 __fastcall sub_B9E6F(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 result; // rax
  signed __int64 *v5; // rax
  signed __int64 *v6; // rax
  __int64 v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+28h] [rbp-18h]

  v7 = a3;
  if ( *(_QWORD *)(a2 + 16) )
  {
    for ( i = *(_QWORD *)(a2 + 16); *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
      ;
    *(_QWORD *)(i + 8) = calloc(1uLL, 0x38uLL);
    v8 = *(_QWORD *)(i + 8);
  }
  else
  {
    *(_QWORD *)(a2 + 16) = malloc(0x38uLL);
    v8 = *(_QWORD *)(a2 + 16);
  }
  if ( v8 )
  {
    *(_OWORD *)v8 = a2;
    *(_QWORD *)(v8 + 16) = *(_QWORD *)(v7 + 16);
    *(_QWORD *)(v8 + 24) = lydict_insert(a1, *(_QWORD *)(v7 + 24), 0LL);
    *(_QWORD *)(v8 + 32) = lydict_insert(a1, *(_QWORD *)(v7 + 32), 0LL);
    *(_DWORD *)(v8 + 48) = *(_DWORD *)(v7 + 48);
    *(_BYTE *)(v8 + 52) = *(_BYTE *)(v7 + 52);
    switch ( *(_DWORD *)(v8 + 48) )
    {
      case 1:
      case 0xA:
        *(_QWORD *)(v8 + 40) = *(_QWORD *)(v8 + 32);
        break;
      case 2:
      case 6:
      case 7:
        v6 = (signed __int64 *)lys_ext_complex_get_substmt(48LL, *(_QWORD *)(v8 + 16), 0LL);
        sub_37EF5(*v6, (char **)(v8 + 32), 0LL, 0LL, v8, 0LL, 1, 0, 0);
        break;
      case 8:
        *(_QWORD *)(v8 + 40) = 0LL;
        break;
      case 9:
        v5 = (signed __int64 *)lys_ext_complex_get_substmt(48LL, *(_QWORD *)(v8 + 16), 0LL);
        sub_37EF5(*v5, (char **)(v8 + 32), 0LL, 0LL, v8, 0LL, 1, 0, 0);
        break;
      case 0xB:
        *(_QWORD *)(v8 + 40) = lydict_insert(a1, *(_QWORD *)(v7 + 40), 0LL);
        break;
      default:
        *(_QWORD *)(v8 + 40) = *(_QWORD *)(v7 + 40);
        break;
    }
    result = v8;
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_dup_attr", v3);
    result = 0LL;
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (00000000000BA11B) ----------------------------------------------------
signed __int64 __fastcall sub_BA11B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 i; // [rsp+18h] [rbp-8h]

  if ( a1 )
  {
    if ( a2 )
      sub_AF24B(a1);
    if ( *(_QWORD *)(a1[4] + 24LL) )
      *(_QWORD *)(a1[4] + 24LL) = a1[3];
    if ( a1[3] )
    {
      *(_QWORD *)(a1[3] + 32LL) = a1[4];
    }
    else
    {
      if ( a1[5] )
      {
        i = *(_QWORD *)(a1[5] + 64LL);
      }
      else
      {
        for ( i = a1[4]; a1 != *(_QWORD **)(i + 32); i = *(_QWORD *)(i + 32) )
          ;
      }
      *(_QWORD *)(i + 32) = a1[4];
    }
    if ( a1[5] )
    {
      if ( a1 == *(_QWORD **)(a1[5] + 64LL) )
        *(_QWORD *)(a1[5] + 64LL) = a1[3];
      if ( a2 != 2 )
        sub_ACE40(a1, a1[5], a1[5], a4, a5, a6);
      a1[5] = 0LL;
    }
    a1[3] = 0LL;
    a1[4] = a1;
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_unlink_internal", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000BA28E) ----------------------------------------------------
signed __int64 __fastcall lyd_unlink(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_unlink", a4, a5, a6);
  return sub_BA11B(a1, 1, v6, v7, v8, v9);
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BA2CA) ----------------------------------------------------
__int64 __fastcall sub_BA2CA(unsigned __int64 a1, __int64 a2, __int64 a3, char a4)
{
  char v5; // [rsp+4h] [rbp-2Ch]
  __int64 v6; // [rsp+8h] [rbp-28h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  *(_QWORD *)(a1 + 16) = 0LL;
  if ( !(a4 & 2) )
  {
    for ( i = *(_QWORD *)(a2 + 16); i; i = *(_QWORD *)(i + 8) )
      sub_B9E6F(v6, a1, i);
  }
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = a1;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_BYTE *)(a1 + 8) = sub_C3AB(*(_QWORD *)a1);
  *(_BYTE *)(a1 + 9) = *(_BYTE *)(a2 + 9) & 1 | *(_BYTE *)(a1 + 9) & 0xFE;
  if ( v5 & 0x10 )
    *(_BYTE *)(a1 + 9) = 2 * ((*(_BYTE *)(a2 + 9) >> 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
  else
    *(_BYTE *)(a1 + 9) = 2 * ((*(_BYTE *)(a2 + 9) >> 1) & 4) | *(_BYTE *)(a1 + 9) & 0xF1;
  if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) != 16 || (unsigned int)sub_ABD8D((_QWORD *)a1) )
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  return 0LL;
}

//----- (00000000000BA418) ----------------------------------------------------
_QWORD *__fastcall sub_BA418(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  unsigned int v4; // eax
  __int64 v5; // r9
  __int64 v6; // rsi
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  _QWORD *result; // rax
  char v13; // [rsp+4h] [rbp-5Ch]
  __int64 v14; // [rsp+8h] [rbp-58h]
  int v15; // [rsp+2Ch] [rbp-34h]
  int v16; // [rsp+2Ch] [rbp-34h]
  _QWORD *v17; // [rsp+30h] [rbp-30h]
  void *v18; // [rsp+40h] [rbp-20h]
  char *v19; // [rsp+48h] [rbp-18h]
  __int64 v20; // [rsp+50h] [rbp-10h]
  __int64 v21; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v17 = 0LL;
  v4 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v4 == 32 )
    goto LABEL_36;
  if ( v4 > 0x20 )
  {
    if ( v4 == 256 )
      goto LABEL_51;
    if ( v4 <= 0x100 )
    {
      if ( v4 != 128 )
        goto LABEL_55;
      goto LABEL_51;
    }
    if ( v4 == 0x4000 )
    {
LABEL_51:
      v17 = calloc(1uLL, 0x48uLL);
      if ( !v17 )
      {
        sub_12222(v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"_lyd_dup_node", v11);
        goto LABEL_57;
      }
      *v17 = a2;
      if ( (unsigned int)sub_BA2CA((unsigned __int64)v17, a1, v14, v13) )
        goto LABEL_57;
      return v17;
    }
    if ( v4 != 32800 )
      goto LABEL_55;
LABEL_36:
    v18 = calloc(1uLL, 0x40uLL);
    v17 = v18;
    if ( v18 )
    {
      *(_QWORD *)v18 = a2;
      if ( !(unsigned int)sub_BA2CA((unsigned __int64)v18, a1, v14, v13) )
      {
        *((_DWORD *)v18 + 13) = *(_DWORD *)(a1 + 52);
        if ( *(_QWORD *)(a1 + 56) )
        {
          switch ( *(_DWORD *)(a1 + 52) )
          {
            case 0:
            case 2:
            case 4:
              *((_QWORD *)v18 + 7) = lydict_insert(v14, *(_QWORD *)(a1 + 56), 0LL);
              return v17;
            case 1:
            case 3:
            case 5:
            case 0x21:
              __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1619u, "_lyd_dup_node");
              return result;
            case 8:
              *((_QWORD *)v18 + 7) = sub_30929(v14, *(_QWORD *)(a1 + 56), 0LL, 1u, 1u);
              return v17;
            case 0x10:
              *((_QWORD *)v18 + 7) = sub_BB4DB(*(_QWORD **)(a1 + 56), 1u, v14);
              return v17;
            case 0x20:
              v16 = lyd_lyb_data_length(*(_QWORD *)(a1 + 56), a1);
              if ( v16 == -1 )
              {
                sub_12222(v14, 0, 3, "Invalid LYB data.", v8, v9);
                goto LABEL_57;
              }
              *((_QWORD *)v18 + 7) = malloc(v16);
              if ( !*((_QWORD *)v18 + 7) )
              {
                sub_12222(v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"_lyd_dup_node", v10);
                goto LABEL_57;
              }
              memcpy(*((void **)v18 + 7), *(const void **)(a1 + 56), v16);
              break;
            default:
              return v17;
          }
        }
        return v17;
      }
    }
    else
    {
      sub_12222(v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"_lyd_dup_node", v7);
    }
    goto LABEL_57;
  }
  if ( v4 != 4 )
  {
    if ( v4 <= 4 )
    {
      if ( v4 != 1 )
      {
LABEL_55:
        sub_12222(
          a3,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          5675LL);
        goto LABEL_57;
      }
      goto LABEL_51;
    }
    if ( v4 != 8 )
    {
      if ( v4 != 16 )
        goto LABEL_55;
      goto LABEL_51;
    }
  }
  v19 = (char *)calloc(1uLL, 0x50uLL);
  v17 = v19;
  if ( v19 )
  {
    *(_QWORD *)v19 = a2;
    *((_QWORD *)v19 + 7) = lydict_insert(v14, *(_QWORD *)(a1 + 56), 0LL);
    *((_DWORD *)v19 + 18) = *(_DWORD *)(a1 + 72);
    v19[76] = *(_BYTE *)(a1 + 76);
    v6 = a1;
    if ( !(unsigned int)sub_BA2CA((unsigned __int64)v19, a1, v14, v13) )
    {
      v20 = *(_QWORD *)v19;
      switch ( *((_DWORD *)v19 + 18) )
      {
        case 1:
        case 0xA:
          *((_QWORD *)v19 + 8) = *((_QWORD *)v19 + 7);
          break;
        case 2:
        case 6:
        case 7:
          v6 = (__int64)(v19 + 56);
          if ( !sub_37EF5(v20 + 128, (char **)v19 + 7, 0LL, (__int64 **)v19, 0LL, 0LL, 1, *(_BYTE *)(a1 + 9) & 1, 0) )
            goto LABEL_57;
          break;
        case 8:
          *((_QWORD *)v19 + 8) = 0LL;
          break;
        case 9:
          v19[8] |= 8u;
          v6 = (__int64)(v19 + 56);
          sub_37EF5(v20 + 128, (char **)v19 + 7, 0LL, (__int64 **)v19, 0LL, 0LL, 1, *(_BYTE *)(a1 + 9) & 1, 0);
          break;
        case 0xB:
          v6 = *(_QWORD *)(a1 + 64);
          *((_QWORD *)v19 + 8) = lydict_insert(v14, v6, 0LL);
          break;
        default:
          *((_QWORD *)v19 + 8) = *(_QWORD *)(a1 + 64);
          break;
      }
      if ( !(v19[76] & 2) )
        return v17;
      v21 = lyd_leaf_type(v19, v6);
      if ( v21 && *(_QWORD *)(v21 + 16) && *(_QWORD *)(*(_QWORD *)(v21 + 16) + 48LL) )
      {
        v15 = sub_C1B58(
                *(__int64 **)(*(_QWORD *)(v21 + 16) + 48LL),
                **(_BYTE ***)(v21 + 16),
                (_QWORD *)v19 + 7,
                (__int64)(v19 + 64));
        if ( v15 != -1 )
        {
          if ( !v15 )
            return v17;
          sub_12222(
            v14,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
            5607LL);
        }
      }
      else
      {
        sub_12222(
          v14,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          5599LL);
      }
    }
  }
  else
  {
    sub_12222(v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"_lyd_dup_node", v5);
  }
LABEL_57:
  lyd_free(v17);
  return 0LL;
}
// 7210: using guessed type __int64 __fastcall lyd_leaf_type(_QWORD, _QWORD);
// 7320: using guessed type __int64 __fastcall lyd_lyb_data_length(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000BAAC6) ----------------------------------------------------
signed __int64 __fastcall sub_BAAC6(char *a1, __int64 a2, __int64 a3, void *a4, char a5, __int64 a6)
{
  __int64 v7; // r9
  char v8; // [rsp+Ch] [rbp-44h]
  void *v9; // [rsp+10h] [rbp-40h]
  __int64 v10; // [rsp+18h] [rbp-38h]
  unsigned __int16 v11; // [rsp+36h] [rbp-1Ah]
  _QWORD *v12; // [rsp+38h] [rbp-18h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  __int64 v14; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) != 16 )
    return 0LL;
  v13 = *(_QWORD *)a1;
  v12 = *(_QWORD **)(a2 + 64);
  v11 = 0;
  while ( v12 && v11 < *(unsigned __int8 *)(v13 + 30) )
  {
    if ( *v12 != *(_QWORD *)(8LL * v11 + *(_QWORD *)(v13 + 136)) )
    {
      sub_13937(v9, 82, 3u, a1, **(_QWORD **)(8LL * v11 + *(_QWORD *)(v13 + 136)), a6);
      return 0xFFFFFFFFLL;
    }
    if ( v10 != *v12 )
    {
      v14 = lyd_dup(v12, v8 & 2);
      if ( !v14 )
      {
        sub_12222((__int64)v9, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_dup_keys", v7);
        return 0xFFFFFFFFLL;
      }
      if ( (unsigned int)lyd_insert(a1, v14) )
      {
        lyd_free(v14);
        return 0xFFFFFFFFLL;
      }
    }
    ++v11;
    v12 = (_QWORD *)v12[3];
  }
  if ( v12 || v11 >= *(unsigned __int8 *)(v13 + 30) )
    return 0LL;
  sub_13937(v9, 82, 3u, a1, **(_QWORD **)(8LL * v11 + *(_QWORD *)(v13 + 136)), a6);
  return 0xFFFFFFFFLL;
}
// 7880: using guessed type __int64 __fastcall lyd_dup(_QWORD, _QWORD);
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000BACB4) ----------------------------------------------------
__int64 *__fastcall lyd_dup_to_ctx(__int64 *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 *result; // rax
  void *v8; // rax
  __int64 v9; // rax
  int v10; // ebx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // r9
  int v14; // ebx
  int v15; // eax
  __int64 v16; // rbx
  __int64 v17; // rax
  __int64 v18; // rbx
  __int64 v19; // rax
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // [rsp+8h] [rbp-78h]
  char v23; // [rsp+14h] [rbp-6Ch]
  const char **v24; // [rsp+20h] [rbp-60h]
  __int64 *v25; // [rsp+28h] [rbp-58h]
  __int64 *i; // [rsp+30h] [rbp-50h]
  __int64 *v27; // [rsp+38h] [rbp-48h]
  __int64 *v28; // [rsp+40h] [rbp-40h]
  char *v29; // [rsp+48h] [rbp-38h]
  void *v30; // [rsp+50h] [rbp-30h]
  __int64 v31; // [rsp+58h] [rbp-28h]
  __int64 v32; // [rsp+60h] [rbp-20h]
  unsigned __int64 v33; // [rsp+68h] [rbp-18h]

  v23 = a2;
  v22 = a3;
  v33 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_dup_to_ctx", a4, a5, a6);
  v29 = 0LL;
  if ( a1 )
  {
    if ( a2 & 1 && a2 & 8 )
      v23 = a2 & 0xF7;
    if ( v22 )
      v8 = (void *)v22;
    else
      v8 = **(void ***)(*a1 + 48);
    v30 = v8;
    if ( v22 == **(_QWORD **)(*a1 + 48) )
      v22 = 0LL;
    v27 = 0LL;
    v28 = 0LL;
    v25 = a1;
    for ( i = a1; ; i = v25 )
    {
      if ( !i )
        goto LABEL_47;
      if ( v22 )
      {
        v24 = 0LL;
        if ( v28 )
        {
          v9 = lyd_node_module(i);
          v10 = strlen(*(const char **)(v9 + 8));
          v11 = lyd_node_module(i);
          v31 = sub_407F3(*(__int64 **)(*v28 + 48), 0LL, 0, *(char **)(v11 + 8), v10, 1);
          if ( !v31 )
          {
            v12 = lyd_node_module(i);
            sub_12222(
              (__int64)v30,
              0,
              3,
              "Target context does not contain model for the data node being duplicated (%s).",
              *(_QWORD *)(v12 + 8),
              v13);
LABEL_60:
            lyd_free(v27);
            return 0LL;
          }
          v14 = *(_DWORD *)(*i + 56);
          v15 = strlen(*(const char **)*i);
          sub_9B536(v31, *v28, *(char **)*i, v15, v14, 0, &v24);
        }
        else
        {
          v24 = (const char **)sub_B28DB(i, v22);
        }
        if ( !v24 )
        {
          v32 = sub_40CD4(i);
          if ( v32 )
          {
            v16 = *(_QWORD *)*i;
            v17 = lyd_node_module(i);
            sub_12222(
              (__int64)v30,
              0,
              3,
              "Target context does not contain schema node for the data node being duplicated (%s:#%s/%s).",
              *(_QWORD *)(v17 + 8),
              v32,
              v16);
          }
          else
          {
            v18 = *(_QWORD *)*i;
            v19 = lyd_node_module(i);
            sub_12222(
              (__int64)v30,
              0,
              3,
              "Target context does not contain schema node for the data node being duplicated (%s:%s).",
              *(_QWORD *)(v19 + 8),
              v18);
          }
          goto LABEL_60;
        }
      }
      else
      {
        v24 = (const char **)*i;
      }
      v29 = (char *)sub_BA418((__int64)i, (__int64)v24, (__int64)v30, v23);
      if ( !v29 || v28 && (unsigned int)lyd_insert(v28, v29) )
        goto LABEL_60;
      if ( !v27 )
        v27 = (__int64 *)v29;
      if ( !(v23 & 9) )
        goto LABEL_47;
      if ( v23 & 8 )
        break;
      if ( *(_DWORD *)(*i + 56) & 0x802C )
        v25 = 0LL;
      else
        v25 = (__int64 *)i[8];
      if ( v25 )
      {
        v28 = (__int64 *)v29;
      }
      else
      {
        if ( i[5] == a1[5] )
          goto LABEL_47;
        v25 = (__int64 *)i[3];
      }
      v29 = 0LL;
      while ( !v25 )
      {
        i = (__int64 *)i[5];
        if ( i[5] == a1[5] )
          break;
        if ( !v28 )
        {
          sub_12222(
            (__int64)v30,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
            5846LL);
          goto LABEL_60;
        }
        v28 = (__int64 *)v28[5];
        v25 = (__int64 *)i[3];
      }
    }
    if ( (unsigned int)sub_BAAC6(v29, (__int64)i, 0LL, v30, v23, v20) )
      goto LABEL_60;
LABEL_47:
    if ( v23 & 4 )
    {
      v28 = v27;
      if ( lys_is_key(*v27, 0LL) )
        v24 = (const char **)*v27;
      else
        v24 = 0LL;
      for ( i = (__int64 *)a1[5]; i; i = (__int64 *)i[5] )
      {
        v29 = (char *)lyd_dup(i, v23 & 2);
        if ( !v29 )
        {
          sub_12222((__int64)v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_dup_to_ctx", v21);
          goto LABEL_60;
        }
        if ( (unsigned int)sub_BAAC6(v29, (__int64)i, (__int64)v24, v30, v23, v21) )
          goto LABEL_60;
        if ( (unsigned int)lyd_insert(v29, v28) )
        {
          v27 = v28;
          goto LABEL_60;
        }
        v28 = (__int64 *)v29;
      }
    }
    result = v27;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_dup_to_ctx", v6);
    result = 0LL;
  }
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7850: using guessed type __int64 __fastcall lys_is_key(_QWORD, _QWORD);
// 7880: using guessed type __int64 __fastcall lyd_dup(_QWORD, _QWORD);
// 79E0: using guessed type __int64 __fastcall lyd_insert(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BB274) ----------------------------------------------------
__int64 __fastcall lyd_dup(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_dup", a4, a5, a6);
  return lyd_dup_to_ctx(a1, a2, 0LL);
}
// 74F0: using guessed type __int64 __fastcall lyd_dup_to_ctx(_QWORD, _QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BB2B8) ----------------------------------------------------
_QWORD *__fastcall sub_BB2B8(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v10; // [rsp+0h] [rbp-40h]
  unsigned int v11; // [rsp+Ch] [rbp-34h]
  __int64 v12; // [rsp+10h] [rbp-30h]
  _QWORD *v13; // [rsp+20h] [rbp-20h]
  _QWORD *v14; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+30h] [rbp-10h]
  _QWORD *v16; // [rsp+38h] [rbp-8h]

  v12 = a2;
  v11 = a3;
  v10 = a4;
  v13 = 0LL;
  v14 = 0LL;
  if ( !a1 )
    __assert_fail("first", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x170Fu, "lyd_dup_withsiblings_r");
  for ( i = a1; ; i = *(_QWORD *)(i + 24) )
  {
    if ( !i )
    {
      if ( v14[3] )
        __assert_fail(
          "!prev_dup->next",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0x173Eu,
          "lyd_dup_withsiblings_r");
      v13[4] = v14;
      return v13;
    }
    v4 = *(_QWORD *)i;
    v16 = sub_BA418(i, *(_QWORD *)i, v10, v11);
    if ( !v16 )
      break;
    *((_BYTE *)v16 + 8) = *(_BYTE *)(i + 8);
    v7 = 2 * ((*(_BYTE *)(i + 9) >> 1) & 7u);
    *((_BYTE *)v16 + 9) = 2 * ((*(_BYTE *)(i + 9) >> 1) & 7) | *((_BYTE *)v16 + 9) & 0xF1;
    v16[5] = v12;
    if ( v13 )
    {
      if ( !v14 )
        __assert_fail(
          "prev_dup",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0x1724u,
          "lyd_dup_withsiblings_r");
      v14[3] = v16;
      v16[4] = v14;
    }
    else
    {
      v13 = v16;
      if ( v12 )
        *(_QWORD *)(v12 + 64) = v16;
    }
    if ( *(_DWORD *)(*v16 + 56LL) != 16 || (unsigned int)sub_ABD8D(v16) )
    {
      v8 = *(unsigned int *)(i + 48);
      *((_DWORD *)v16 + 12) = v8;
    }
    sub_ACC62((unsigned int *)v16, v4, v8, v7, v5, v6);
    if ( *(_DWORD *)(*(_QWORD *)i + 56LL) & 0x4191 )
    {
      if ( *(_QWORD *)(i + 64) && !sub_BB2B8(*(_QWORD *)(i + 64), v16, v11, v10) )
        break;
    }
    v14 = v16;
  }
  if ( v13 )
  {
    v13[5] = 0LL;
    lyd_free_withsiblings(v13);
  }
  return 0LL;
}
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);

//----- (00000000000BB4DB) ----------------------------------------------------
_QWORD *__fastcall sub_BB4DB(_QWORD *a1, unsigned int a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-38h]
  _QWORD *v5; // [rsp+18h] [rbp-28h]
  __int64 i; // [rsp+20h] [rbp-20h]
  __int64 v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  v5 = a1;
  v4 = a3;
  if ( !a1 )
    return 0LL;
  while ( *(_QWORD *)(v5[4] + 24LL) )
    v5 = (_QWORD *)v5[4];
  if ( !v5[5] )
    return sub_BB2B8((__int64)v5, 0LL, a2, a3);
  v7 = lyd_dup_to_ctx(v5, a2, a3);
  if ( !v7 )
    return 0LL;
  v8 = v7;
  for ( i = v5[3]; i; i = *(_QWORD *)(i + 24) )
  {
    v9 = lyd_dup_to_ctx(i, a2, v4);
    if ( !v9 )
    {
      lyd_free_withsiblings(v7);
      return 0LL;
    }
    if ( (unsigned int)lyd_insert_after(v8, v9) )
    {
      lyd_free_withsiblings(v7);
      return 0LL;
    }
    v8 = *(_QWORD *)(v8 + 24);
    if ( v8 != v9 )
      __assert_fail(
        "ret_iter == tmp",
        "/home/mantovan/Repositories/libyang/src/tree_data.c",
        0x176Fu,
        "lyd_dup_withsiblings_to_ctx");
  }
  return (_QWORD *)v7;
}
// 7310: using guessed type __int64 __fastcall lyd_insert_after(_QWORD, _QWORD);
// 74F0: using guessed type __int64 __fastcall lyd_dup_to_ctx(_QWORD, _QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);

//----- (00000000000BB640) ----------------------------------------------------
_QWORD *__fastcall lyd_dup_withsiblings(_QWORD *a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v7; // rax

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_dup_withsiblings", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  v7 = (__int64 *)lyd_node_module(a1);
  return sub_BB4DB(a1, a2, *v7);
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BB69C) ----------------------------------------------------
void __fastcall lyd_free_attr(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // [rsp+4h] [rbp-2Ch]
  _QWORD *ptr; // [rsp+8h] [rbp-28h]
  void *ptra; // [rsp+8h] [rbp-28h]
  __int64 i; // [rsp+20h] [rbp-10h]
  _QWORD *v10; // [rsp+20h] [rbp-10h]
  signed __int64 *v11; // [rsp+28h] [rbp-8h]

  ptr = a3;
  v6 = a4;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_free_attr", a4, a5, a6);
  if ( a1 && ptr )
  {
    if ( a2 )
    {
      if ( ptr == *(_QWORD **)(a2 + 16) )
      {
        if ( v6 )
          *(_QWORD *)(a2 + 16) = 0LL;
        else
          *(_QWORD *)(a2 + 16) = ptr[1];
      }
      else
      {
        for ( i = *(_QWORD *)(a2 + 16); ptr != *(_QWORD **)(i + 8); i = *(_QWORD *)(i + 8) )
          ;
        if ( *(_QWORD *)(i + 8) )
        {
          if ( v6 )
            *(_QWORD *)(i + 8) = 0LL;
          else
            *(_QWORD *)(i + 8) = ptr[1];
        }
      }
    }
    if ( !v6 )
      ptr[1] = 0LL;
    v10 = ptr;
    while ( v10 )
    {
      ptra = v10;
      v10 = (_QWORD *)v10[1];
      lydict_remove(a1, *((_QWORD *)ptra + 3));
      v11 = (signed __int64 *)lys_ext_complex_get_substmt(48LL, *((_QWORD *)ptra + 2), 0LL);
      if ( !v11 )
        __assert_fail("type", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x17AEu, "lyd_free_attr");
      sub_BBE52(
        *((void **)ptra + 5),
        *((_DWORD *)ptra + 12),
        *((_BYTE *)ptra + 52),
        *v11,
        *((_QWORD *)ptra + 4),
        0LL,
        0LL,
        0LL);
      lydict_remove(a1, *((_QWORD *)ptra + 4));
      free(ptra);
    }
  }
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BB881) ----------------------------------------------------
_QWORD *__fastcall sub_BB881(_QWORD *a1, __int64 a2)
{
  _QWORD *i; // [rsp+18h] [rbp-18h]
  _QWORD *v4; // [rsp+20h] [rbp-10h]
  __int64 j; // [rsp+28h] [rbp-8h]

  for ( i = a1; i; i = v4 )
  {
    for ( j = i[2]; j; j = *(_QWORD *)(j + 8) )
    {
      if ( j == a2 )
        return i;
    }
    if ( *(_DWORD *)(*i + 56LL) & 0x802C )
      v4 = 0LL;
    else
      v4 = (_QWORD *)i[8];
    if ( !v4 )
    {
      if ( i == a1 )
        return 0LL;
      v4 = (_QWORD *)i[3];
    }
    while ( !v4 )
    {
      i = (_QWORD *)i[5];
      if ( i[5] == a1[5] )
        break;
      v4 = (_QWORD *)i[3];
    }
  }
  return 0LL;
}

//----- (00000000000BB972) ----------------------------------------------------
void *__fastcall lyd_insert_attr(unsigned __int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  int v11; // eax
  __int64 v12; // r9
  signed __int64 *v13; // rax
  __int64 v14; // [rsp+0h] [rbp-70h]
  char *s; // [rsp+8h] [rbp-68h]
  signed int v16; // [rsp+28h] [rbp-48h]
  int v17; // [rsp+2Ch] [rbp-44h]
  __int64 i; // [rsp+30h] [rbp-40h]
  __int64 v19; // [rsp+38h] [rbp-38h]
  __int64 v20; // [rsp+40h] [rbp-30h]
  char *v21; // [rsp+48h] [rbp-28h]
  char *ptr; // [rsp+50h] [rbp-20h]
  void *v23; // [rsp+58h] [rbp-18h]

  s = a3;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_insert_attr", a4, a5, a6, a4);
  if ( !a1 || !s || !v14 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_insert_attr", v6);
    return 0LL;
  }
  v20 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  v21 = strchr(s, 58);
  if ( v21 )
  {
    ptr = strndup(s, v21 - s);
    if ( !ptr )
    {
      sub_12222(v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_insert_attr", v10);
      return 0LL;
    }
    v19 = ly_ctx_get_module(v20, ptr, 0LL, 1LL);
    free(ptr);
    s = v21 + 1;
    if ( !v19 )
    {
      sub_12222(v20, 0, 3, "Attribute prefix does not match any implemented schema in the context.", v8, v9);
      return 0LL;
    }
  }
  else if ( a2 )
  {
    v19 = a2;
  }
  else if ( (!strcmp(s, "type") || !strcmp(s, "select")) && !strcmp(**(const char ***)a1, "filter") )
  {
    v19 = ly_ctx_get_module(v20, "ietf-netconf", 0LL, 1LL);
    if ( !v19 )
    {
      sub_12222(v20, 0, 3, "Attribute prefix does not match any implemented schema in the context.", v8, v9);
      return 0LL;
    }
  }
  else
  {
    v19 = lyd_node_module(a1);
  }
  v16 = -1;
  do
  {
    if ( v16 + 1 >= (unsigned int)*(unsigned __int8 *)(v19 + 80) )
    {
      v16 = -1;
    }
    else
    {
      v17 = lys_ext_instance_presence(
              *(_QWORD *)(**(_QWORD **)(v20 + 64) + 152LL),
              *(_QWORD *)(v19 + 160) + 8 * (v16 + 1LL),
              (unsigned __int8)(*(_BYTE *)(v19 + 80) - v16 - 1));
      if ( v17 == -1 )
        v11 = -1;
      else
        v11 = v16 + 1 + v17;
      v16 = v11;
    }
    if ( v16 == -1 )
    {
      sub_12222(v20, 0, 3, "Attribute does not match any annotation instance definition.", v8, v9);
      return 0LL;
    }
  }
  while ( !(unsigned int)sub_C462(*(_BYTE **)(*(_QWORD *)(8LL * v16 + *(_QWORD *)(v19 + 160)) + 16LL), s) );
  v23 = calloc(1uLL, 0x38uLL);
  if ( v23 )
  {
    *(_OWORD *)v23 = a1;
    *((_QWORD *)v23 + 2) = *(_QWORD *)(8LL * v16 + *(_QWORD *)(v19 + 160));
    *((_QWORD *)v23 + 3) = lydict_insert(v20, s, 0LL);
    *((_QWORD *)v23 + 4) = lydict_insert(v20, v14, 0LL);
    v13 = (signed __int64 *)lys_ext_complex_get_substmt(48LL, *((_QWORD *)v23 + 2), 0LL);
    if ( sub_37EF5(*v13, (char **)v23 + 4, 0LL, 0LL, (__int64)v23, 0LL, 1, 0, 0) )
    {
      if ( *(_QWORD *)(a1 + 16) )
      {
        for ( i = *(_QWORD *)(a1 + 16); *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
          ;
        *(_QWORD *)(i + 8) = v23;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v23;
      }
      result = v23;
    }
    else
    {
      lyd_free_attr(v20, 0LL, v23, 0LL);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(v20, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_insert_attr", v12);
    result = 0LL;
  }
  return result;
}
// 72B0: using guessed type __int64 __fastcall lys_ext_instance_presence(_QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 74E0: using guessed type __int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BBE52) ----------------------------------------------------
void __fastcall sub_BBE52(void *a1, int a2, char a3, signed __int64 a4, __int64 a5, _QWORD *a6, _DWORD *a7, _BYTE *a8)
{
  if ( a6 )
  {
    *a6 = a1;
    *a7 = a2;
    *a8 = a3;
    return;
  }
  if ( a3 & 2 )
  {
    sub_C1CED(a4, (__int64)a1, a5);
    return;
  }
  switch ( a2 )
  {
    case 8:
      if ( !(a3 & 1) )
        return;
      goto LABEL_11;
    case 11:
LABEL_11:
      lydict_remove(**(_QWORD **)(*(_QWORD *)(a4 + 24) + 48LL), a1);
      return;
    case 2:
      if ( a1 )
        free(a1);
      break;
  }
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000BBF19) ----------------------------------------------------
void __fastcall sub_BBF19(__int64 a1)
{
  unsigned int v1; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
    if ( v1 != 32 )
    {
      if ( v1 <= 0x20 )
      {
        if ( v1 == 4 )
          goto LABEL_31;
        if ( v1 <= 4 )
        {
          if ( v1 != 1 )
            goto LABEL_27;
          goto LABEL_18;
        }
        if ( v1 == 8 )
        {
LABEL_31:
          sub_BBE52(
            *(void **)(a1 + 64),
            *(_DWORD *)(a1 + 72),
            *(_BYTE *)(a1 + 76),
            *(_QWORD *)a1 + 128LL,
            *(_QWORD *)(a1 + 56),
            0LL,
            0LL,
            0LL);
          lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), *(_QWORD *)(a1 + 56));
          goto LABEL_28;
        }
        if ( v1 != 16 )
LABEL_27:
          __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1878u, "_lyd_free_node");
LABEL_18:
        sub_14F6B(*(void ***)(a1 + 56));
LABEL_28:
        lyd_free_attr(**(_QWORD **)(*(_QWORD *)a1 + 48LL), a1, *(_QWORD *)(a1 + 16), 1LL);
        free((void *)a1);
        return;
      }
      if ( v1 == 256 )
        goto LABEL_18;
      if ( v1 <= 0x100 )
      {
        if ( v1 != 128 )
          goto LABEL_27;
        goto LABEL_18;
      }
      if ( v1 == 0x4000 )
        goto LABEL_18;
      if ( v1 != 32800 )
        goto LABEL_27;
    }
    switch ( *(_DWORD *)(a1 + 52) )
    {
      case 0:
      case 2:
      case 4:
        lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), *(_QWORD *)(a1 + 56));
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
        __assert_fail("0", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x186Cu, "_lyd_free_node");
        return;
      case 8:
        lyxml_free_withsiblings(**(_QWORD **)(*(_QWORD *)a1 + 48LL), *(_QWORD *)(a1 + 56));
        break;
      case 0x10:
        lyd_free_withsiblings(*(_QWORD *)(a1 + 56));
        break;
      case 0x20:
        free(*(void **)(a1 + 56));
        break;
      default:
        goto LABEL_28;
    }
    goto LABEL_28;
  }
}
// 74E0: using guessed type __int64 __fastcall lyd_free_attr(_QWORD, _QWORD, _QWORD, _QWORD);
// 75F0: using guessed type __int64 __fastcall lyxml_free_withsiblings(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000BC13E) ----------------------------------------------------
void __fastcall sub_BC13E(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 v6; // rdx
  char v7; // al
  __int64 v8; // [rsp+10h] [rbp-10h]
  __int64 i; // [rsp+18h] [rbp-8h]

  if ( a1 )
  {
    if ( a2 )
      v6 = 1LL;
    else
      v6 = 2LL;
    sub_BA11B(a1, v6, v6, a4, a5, a6);
    if ( !(*(_DWORD *)(*a1 + 56LL) & 0x802C) )
    {
      for ( i = a1[8]; ; i = v8 )
      {
        if ( i )
        {
          v8 = *(_QWORD *)(i + 24);
          v7 = 1;
        }
        else
        {
          v7 = 0;
        }
        if ( !v7 )
          break;
        sub_BC13E(i, 0LL);
      }
    }
    sub_BBF19((__int64)a1);
  }
}

//----- (00000000000BC1E6) ----------------------------------------------------
void __fastcall lyd_free(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_free", a4, a5, a6);
  sub_BC13E(a1, 1, v6, v7, v8, v9);
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BC223) ----------------------------------------------------
signed __int64 __fastcall sub_BC223(_QWORD *a1)
{
  signed __int64 result; // rax
  _QWORD *v2; // [rsp+10h] [rbp-10h]
  _QWORD *i; // [rsp+18h] [rbp-8h]

  for ( i = a1; ; i = v2 )
  {
    if ( i )
    {
      v2 = (_QWORD *)i[3];
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
    if ( !(_BYTE)result )
      break;
    if ( *(_DWORD *)(*i + 56LL) & 0x4191 )
      sub_BC223(i[8]);
    sub_BBF19((__int64)i);
  }
  return result;
}

//----- (00000000000BC296) ----------------------------------------------------
signed __int64 __fastcall lyd_free_withsiblings(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  _QWORD *v7; // [rsp+8h] [rbp-18h]
  _QWORD *i; // [rsp+10h] [rbp-10h]
  _QWORD *j; // [rsp+10h] [rbp-10h]
  _QWORD *v10; // [rsp+18h] [rbp-8h]

  v7 = a1;
  result = sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_free_withsiblings", a4, a5, a6);
  if ( a1 )
  {
    if ( a1[5] )
    {
      for ( i = (_QWORD *)a1[4]; i[3]; i = v10 )
      {
        v10 = (_QWORD *)i[4];
        lyd_free(i);
      }
      for ( j = a1; ; j = v10 )
      {
        if ( j )
        {
          v10 = (_QWORD *)j[3];
          result = 1LL;
        }
        else
        {
          result = 0LL;
        }
        if ( !(_BYTE)result )
          break;
        lyd_free(j);
      }
    }
    else
    {
      while ( *(_QWORD *)(v7[4] + 24LL) )
        v7 = (_QWORD *)v7[4];
      result = sub_BC223(v7);
    }
  }
  return result;
}
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BC387) ----------------------------------------------------
signed __int64 __fastcall sub_BC387(const char *a1, __int64 a2, _QWORD *a3)
{
  int v4; // eax
  _QWORD *v5; // [rsp+8h] [rbp-68h]
  int v6; // [rsp+20h] [rbp-50h]
  unsigned int v7; // [rsp+24h] [rbp-4Ch]
  __int64 j; // [rsp+28h] [rbp-48h]
  __int64 v9; // [rsp+30h] [rbp-40h]
  __int64 i; // [rsp+38h] [rbp-38h]
  __int64 v11; // [rsp+40h] [rbp-30h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  __int64 v13; // [rsp+50h] [rbp-20h]
  __int64 v14; // [rsp+58h] [rbp-18h]
  __int64 v15; // [rsp+60h] [rbp-10h]
  unsigned __int64 v16; // [rsp+68h] [rbp-8h]

  v5 = a3;
  v16 = __readfsqword(0x28u);
  v12 = **(_QWORD **)(*(_QWORD *)a2 + 48LL);
  v13 = 0LL;
  if ( !a1 || !a2 || !a3 )
    __assert_fail(
      "unique_expr && list && dflt",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x18DDu,
      "lyd_get_unique_default");
  *a3 = 0LL;
  if ( (unsigned int)sub_1AF63(a1, *(_QWORD *)(*(_QWORD *)a2 + 72LL), 4, 1, &j) || !j )
  {
    sub_12222(
      v12,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
      6370LL);
    return 0xFFFFFFFFLL;
  }
  v13 = j;
  if ( *(_QWORD *)(j + 200) )
  {
    *v5 = *(_QWORD *)(v13 + 200);
  }
  else if ( !(*(_WORD *)(v13 + 24) & 0x40) )
  {
    for ( i = *(_QWORD *)(v13 + 144); i && !*v5; i = *(_QWORD *)(i + 72) )
      *v5 = *(_QWORD *)(i + 120);
  }
  if ( !*v5 )
    return 0LL;
  v14 = ly_set_new(a1);
  for ( j = lys_parent(v13); *(_QWORD *)a2 != j; j = lys_parent(j) )
  {
    if ( !(*(_DWORD *)(j + 56) & 0x1043) )
    {
      sub_12222(
        v12,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
        6394LL);
      ly_set_free(v14);
      return 0xFFFFFFFFLL;
    }
    ly_set_add(v14, j, 1LL);
  }
  sub_141E4(0LL, 2u, &v6, 0LL);
  v7 = 0;
  v11 = a2;
  while ( v7 < *(_DWORD *)(v14 + 4) )
  {
    j = *(_QWORD *)(8LL * v7 + *(_QWORD *)(v14 + 8));
    v4 = *(_DWORD *)(j + 56);
    if ( v4 == 1 )
    {
      if ( v11 )
      {
        v15 = lyd_find_path(v11, *(_QWORD *)j);
        if ( !v15 || *(_DWORD *)(v15 + 4) > 1u )
        {
          ly_set_free(v15);
          *v5 = 0LL;
          break;
        }
        if ( *(_DWORD *)(v15 + 4) )
          v11 = **(_QWORD **)(v15 + 8);
        else
          v11 = 0LL;
        ly_set_free(v15);
      }
      if ( *(_QWORD *)(j + 136) )
      {
        *v5 = 0LL;
        break;
      }
    }
    else if ( v4 == 2 && v11 )
    {
      if ( v7 + 1 == *(_DWORD *)(v14 + 4) )
      {
        j = v13;
      }
      else
      {
        if ( *(_DWORD *)(*(_QWORD *)(8LL * (v7 + 1) + *(_QWORD *)(v14 + 8)) + 56LL) == 64
          && v7 + 2 < *(_DWORD *)(v14 + 4)
          && *(_DWORD *)(*(_QWORD *)(8LL * (v7 + 2) + *(_QWORD *)(v14 + 8)) + 56LL) == 2 )
        {
          ++v7;
          goto LABEL_46;
        }
        j = *(_QWORD *)(8LL * (v7 + 1) + *(_QWORD *)(v14 + 8));
      }
      v9 = *(_QWORD *)(v11 + 64);
      if ( (unsigned int)sub_3010D(0LL, j, (char **)&v9, 0, 0LL) )
      {
        *v5 = 0LL;
        break;
      }
    }
LABEL_46:
    ++v7;
  }
  sub_142D2(0LL, v6, 0LL, 0);
  ly_set_free(v14);
  return 0LL;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 75A0: using guessed type __int64 __fastcall lyd_find_path(_QWORD, _QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (00000000000BC7EE) ----------------------------------------------------
__int64 __fastcall lyd_path(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+10h] [rbp-10h]
  unsigned __int64 v9; // [rsp+18h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_path", a4, a5, a6);
  v8 = 0LL;
  if ( a1 )
  {
    if ( (unsigned int)sub_12B3E(3u, a1, (void **)&v8, 0, 0) )
      result = 0LL;
    else
      result = v8;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_path", v6);
    result = 0LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BC8A8) ----------------------------------------------------
signed __int64 __fastcall sub_BC8A8(__int64 *a1, __int64 *a2, const char *a3, __int64 a4)
{
  const char *v5; // rax
  int v6; // eax
  __int64 v7; // [rsp+0h] [rbp-60h]
  const char *v8; // [rsp+8h] [rbp-58h]
  int v9; // [rsp+24h] [rbp-3Ch]
  int v10; // [rsp+28h] [rbp-38h]
  int v11; // [rsp+2Ch] [rbp-34h]
  unsigned int v12; // [rsp+30h] [rbp-30h]
  int v13; // [rsp+34h] [rbp-2Ch]
  char *v14; // [rsp+38h] [rbp-28h]
  const char *v15; // [rsp+40h] [rbp-20h]
  const char **v16; // [rsp+48h] [rbp-18h]
  _QWORD *v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v18 = __readfsqword(0x28u);
  v12 = 0;
  v11 = -1;
  if ( !a3 || !a4 )
    __assert_fail(
      "schema_id && buf",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x195Du,
      "lyd_build_relative_data_path");
  v17 = (_QWORD *)*a2;
  while ( *v8 )
  {
    v13 = sub_17847(v8, &v14, (unsigned int *)&v9, &v15, (unsigned int *)&v10, &v11, 0LL, 0LL, 0);
    if ( v13 <= 0 )
    {
      sub_12222(
        *a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
        6498LL,
        v7);
      return 0xFFFFFFFFLL;
    }
    v8 += v13;
    v16 = 0LL;
    while ( 1 )
    {
      v16 = (const char **)lys_getnext(v16, v17, 0LL, 259LL);
      if ( !v16 )
        break;
      v13 = sub_19DE6(v16, a1, v14, v9, v15, v10);
      if ( !v13 )
      {
        v17 = v16;
        break;
      }
      if ( v13 != 1 )
        return 0xFFFFFFFFLL;
    }
    if ( !v16 || !*v8 && *((_DWORD *)v16 + 14) != 4 )
    {
      sub_12222(
        *a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
        6517LL,
        v7);
      return 0xFFFFFFFFLL;
    }
    if ( !((_DWORD)v16[7] & 0x42) )
    {
      if ( v12 )
        v5 = "/";
      else
        v5 = (const char *)&unk_12274D;
      v6 = sprintf((char *)((signed int)v12 + v7), "%s%s", v5, *v16);
      v12 += v6;
    }
  }
  return v12;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000BCAE7) ----------------------------------------------------
__int64 __fastcall lyd_find_path(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  void **v8; // rax
  void **v9; // rax
  void *v10; // rdi
  __int64 v11; // r9
  const char *v12; // [rsp+0h] [rbp-A0h]
  __int64 v13; // [rsp+8h] [rbp-98h]
  int v14; // [rsp+18h] [rbp-88h]
  int v15; // [rsp+1Ch] [rbp-84h]
  int v16; // [rsp+20h] [rbp-80h]
  unsigned int i; // [rsp+24h] [rbp-7Ch]
  char *s1; // [rsp+28h] [rbp-78h]
  _BYTE *v19; // [rsp+30h] [rbp-70h]
  __int64 v20; // [rsp+38h] [rbp-68h]
  char *s2; // [rsp+40h] [rbp-60h]
  void *ptr; // [rsp+48h] [rbp-58h]
  int s; // [rsp+50h] [rbp-50h]
  __int64 v24; // [rsp+60h] [rbp-40h]
  unsigned int v25; // [rsp+70h] [rbp-30h]
  unsigned __int64 v26; // [rsp+98h] [rbp-8h]

  v13 = (__int64)a1;
  v26 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_find_path", a4, a5, a6, a2);
  v16 = -1;
  if ( !a1 || !v12 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_find_path", v6);
    return 0LL;
  }
  if ( (signed int)sub_17847(v12, &s1, (unsigned int *)&v14, &v19, (unsigned int *)&v15, &v16, 0LL, 0LL, 1) > 0
    && *v19 == 35
    && !v16 )
  {
    s2 = *(char **)(lyd_node_module(a1) + 8);
    if ( strncmp(s1, s2, v14) || s2[v14] )
      return 0LL;
    v12 = &v19[v15];
  }
  v8 = (void **)lyd_node_module(a1);
  ptr = sub_B085(v8, v12);
  if ( !ptr )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  v9 = (void **)lyd_node_module(a1);
  if ( (unsigned int)sub_DC4B2((const char *)ptr, a1, 2, v9, &s, 0LL) )
  {
    free(ptr);
    result = 0LL;
  }
  else
  {
    v10 = ptr;
    free(ptr);
    v20 = ly_set_new(v10);
    if ( v20 )
    {
      if ( s == 1 )
      {
        for ( i = 0; i < v25; ++i )
        {
          if ( *(_DWORD *)(16LL * i + v24 + 8) == 2 && (signed int)ly_set_add(v20, *(_QWORD *)(16LL * i + v24), 1LL) < 0 )
          {
            ly_set_free(v20);
            v20 = 0LL;
            break;
          }
        }
      }
      sub_DC765((__int64)&s, 0, v13, 0LL, 0);
      result = v20;
    }
    else
    {
      sub_12222(
        **(_QWORD **)(*(_QWORD *)v13 + 48LL),
        0,
        1,
        "Memory allocation failed (%s()).",
        (__int64)"lyd_find_path",
        v11,
        v12);
      result = 0LL;
    }
  }
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BCDE8) ----------------------------------------------------
__int64 __fastcall lyd_find_instance(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 v6; // rdi
  __int64 v7; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // [rsp+0h] [rbp-40h]
  _QWORD *v12; // [rsp+8h] [rbp-38h]
  int j; // [rsp+10h] [rbp-30h]
  unsigned int k; // [rsp+14h] [rbp-2Ch]
  __int64 v15; // [rsp+18h] [rbp-28h]
  __int64 v16; // [rsp+20h] [rbp-20h]
  _QWORD *i; // [rsp+28h] [rbp-18h]
  _QWORD *l; // [rsp+28h] [rbp-18h]
  __int64 v19; // [rsp+30h] [rbp-10h]
  __int64 v20; // [rsp+38h] [rbp-8h]

  v12 = a1;
  v6 = 32LL;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_find_instance", a4, a5, a6, a2);
  if ( !v12 || !v11 || !(*(_DWORD *)(v11 + 56) & 0xC1BD) )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_find_instance", v7);
    return 0LL;
  }
  v15 = ly_set_new(32LL);
  v19 = ly_set_new(32LL);
  if ( !v15 || !v19 )
  {
    sub_12222(**(_QWORD **)(v11 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_find_instance", v9);
LABEL_41:
    ly_set_free(v15);
    ly_set_free(v19);
    return 0LL;
  }
  while ( v12[5] )
    v12 = (_QWORD *)v12[5];
  while ( *(_QWORD *)(v12[4] + 24LL) )
    v12 = (_QWORD *)v12[4];
  v16 = v11;
  while ( v16 )
  {
    if ( *(_DWORD *)(v16 + 56) == 0x2000 )
    {
      v16 = *(_QWORD *)(v16 + 88);
    }
    else
    {
      if ( *(_DWORD *)(v16 + 56) & 0xC1BD )
      {
        v6 = v19;
        ly_set_add(v19, v16, 1LL);
      }
      v16 = *(_QWORD *)(v16 + 64);
    }
  }
  if ( !*(_DWORD *)(v19 + 4) )
    goto LABEL_41;
  for ( i = v12; i; i = (_QWORD *)i[3] )
  {
    if ( *i == *(_QWORD *)(*(_QWORD *)(v19 + 8) + 8LL * (unsigned int)(*(_DWORD *)(v19 + 4) - 1)) )
    {
      v6 = v15;
      ly_set_add(v15, i, 1LL);
    }
  }
  for ( j = *(_DWORD *)(v19 + 4) - 1; j && *(_DWORD *)(v15 + 4); --j )
  {
    v20 = ly_set_new(v6);
    if ( !v20 )
    {
      sub_12222(**(_QWORD **)(v11 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyd_find_instance", v10);
      goto LABEL_41;
    }
    for ( k = 0; k < *(_DWORD *)(v15 + 4); ++k )
    {
      for ( l = *(_QWORD **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v15 + 8)) + 64LL); l; l = (_QWORD *)l[3] )
      {
        if ( *l == *(_QWORD *)(8LL * (unsigned int)(j - 1) + *(_QWORD *)(v19 + 8)) )
          ly_set_add(v20, l, 1LL);
      }
    }
    v6 = v15;
    ly_set_free(v15);
    v15 = v20;
  }
  ly_set_free(v19);
  return v15;
}
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD106) ----------------------------------------------------
__int64 __fastcall lyd_first_sibling(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 i; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_first_sibling", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 40) )
    return *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64LL);
  for ( i = a1; *(_QWORD *)(*(_QWORD *)(i + 32) + 24LL); i = *(_QWORD *)(i + 32) )
    ;
  return i;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD189) ----------------------------------------------------
void *__fastcall ly_set_new(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *v8; // [rsp+8h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_new", a4, a5, a6);
  v8 = calloc(1uLL, 0x10uLL);
  if ( v8 )
    return v8;
  sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_set_new", v6);
  return 0LL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD1FC) ----------------------------------------------------
void __fastcall ly_set_free(void **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_free", a4, a5, a6);
  if ( a1 )
  {
    free(a1[1]);
    free(a1);
  }
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD24D) ----------------------------------------------------
signed __int64 __fastcall ly_set_contains(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-20h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_contains", a4, a5, a6, a2);
  if ( !a1 )
    return 0xFFFFFFFFLL;
  for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
  {
    if ( v7 == *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 8)) )
      return i;
  }
  return 0xFFFFFFFFLL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD2C8) ----------------------------------------------------
_QWORD *__fastcall ly_set_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax
  __int64 v7; // r9
  __int64 v8; // r9
  _QWORD *ptr; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_dup", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  ptr = malloc(0x10uLL);
  if ( ptr )
  {
    *((_DWORD *)ptr + 1) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)ptr = *(_DWORD *)a1;
    ptr[1] = malloc(8LL * *(unsigned int *)ptr);
    if ( ptr[1] )
    {
      memcpy((void *)ptr[1], *(const void **)(a1 + 8), 8LL * *(unsigned int *)ptr);
      result = ptr;
    }
    else
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_set_dup", v8);
      free(ptr);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_set_dup", v7);
    result = 0LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD3F9) ----------------------------------------------------
signed __int64 __fastcall ly_set_add(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  __int64 v9; // rsi
  unsigned int v10; // eax
  char v11; // [rsp+Ch] [rbp-24h]
  __int64 v12; // [rsp+10h] [rbp-20h]
  unsigned int i; // [rsp+24h] [rbp-Ch]
  void *v14; // [rsp+28h] [rbp-8h]

  v12 = a2;
  v11 = a3;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_add", a4, a5, a6);
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_set_add", v6);
    return 0xFFFFFFFFLL;
  }
  if ( !(v11 & 1) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
    {
      if ( a2 == *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 8)) )
        return i;
    }
  }
  if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 4) )
  {
    v14 = realloc(*(void **)(a1 + 8), 8LL * (unsigned int)(*(_DWORD *)a1 + 8));
    if ( !v14 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_set_add", v8);
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)a1 += 8;
    *(_QWORD *)(a1 + 8) = v14;
  }
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = v10 + 1;
  *(_QWORD *)(v9 + 8LL * v10) = v12;
  return (unsigned int)(*(_DWORD *)(a1 + 4) - 1);
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD568) ----------------------------------------------------
signed __int64 __fastcall ly_set_merge(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  unsigned int v9; // ST24_4
  char v10; // [rsp+Ch] [rbp-24h]
  unsigned int v11; // [rsp+20h] [rbp-10h]
  void *v12; // [rsp+28h] [rbp-8h]

  v10 = a3;
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_merge", a4, a5, a6);
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_set_merge", v6);
    return 0xFFFFFFFFLL;
  }
  if ( !a2 )
    return 0LL;
  if ( !(v10 & 1) )
  {
    v11 = 0;
    while ( v11 < *(_DWORD *)(a2 + 4) )
    {
      if ( (signed int)ly_set_contains(a1, *(_QWORD *)(8LL * v11 + *(_QWORD *)(a2 + 8))) < 0 )
        ++v11;
      else
        ly_set_rm_index(a2, v11);
    }
  }
  if ( *(_DWORD *)a1 < (unsigned int)(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a2 + 4)) )
  {
    v12 = realloc(*(void **)(a1 + 8), 8LL * (unsigned int)(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a2 + 4)));
    if ( !v12 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_set_merge", v8);
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)a1 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a1 + 4);
    *(_QWORD *)(a1 + 8) = v12;
  }
  memcpy(
    (void *)(8LL * *(unsigned int *)(a1 + 4) + *(_QWORD *)(a1 + 8)),
    *(const void **)(a2 + 8),
    8LL * *(unsigned int *)(a2 + 4));
  v9 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 4) += v9;
  ly_set_free(a2);
  return v9;
}
// 72E0: using guessed type __int64 __fastcall ly_set_rm_index(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 74C0: using guessed type __int64 __fastcall ly_set_contains(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD755) ----------------------------------------------------
signed __int64 __fastcall ly_set_rm_index(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  signed __int64 v8; // rax
  signed __int64 v9; // rdx

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_rm_index", a4, a5, a6);
  if ( a1 && a2 + 1 <= *(_DWORD *)(a1 + 4) )
  {
    if ( a2 == *(_DWORD *)(a1 + 4) - 1 )
    {
      v8 = *(_QWORD *)(a1 + 8);
      v9 = 8LL * a2;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL * a2) = *(_QWORD *)(*(_QWORD *)(a1 + 8)
                                                              + 8LL * (unsigned int)(*(_DWORD *)(a1 + 4) - 1));
      v9 = *(_QWORD *)(a1 + 8);
      v8 = 8LL * (unsigned int)(*(_DWORD *)(a1 + 4) - 1);
    }
    *(_QWORD *)(v9 + v8) = 0LL;
    --*(_DWORD *)(a1 + 4);
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_set_rm_index", v6);
    result = 1LL;
  }
  return result;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD862) ----------------------------------------------------
__int64 __fastcall ly_set_rm(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+0h] [rbp-20h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_rm", a4, a5, a6, a2);
  if ( a1 && v8 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 4) && v8 != *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 8)); ++i )
      ;
    if ( i == *(_DWORD *)(a1 + 4) )
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_set_rm", v6);
      result = 1LL;
    }
    else
    {
      result = ly_set_rm_index(a1, i);
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_set_rm", v6);
    result = 1LL;
  }
  return result;
}
// 72E0: using guessed type __int64 __fastcall ly_set_rm_index(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD952) ----------------------------------------------------
signed __int64 __fastcall ly_set_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"ly_set_clean", a4, a5, a6);
  if ( !a1 )
    return 1LL;
  *(_DWORD *)(a1 + 4) = 0;
  return 0LL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BD99B) ----------------------------------------------------
signed __int64 __fastcall lyd_wd_default(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int8 v7; // [rsp+1Dh] [rbp-33h]
  unsigned __int8 v8; // [rsp+1Eh] [rbp-32h]
  unsigned __int8 k; // [rsp+1Fh] [rbp-31h]
  _QWORD *v10; // [rsp+20h] [rbp-30h]
  __int64 i; // [rsp+28h] [rbp-28h]
  __int64 j; // [rsp+28h] [rbp-28h]
  __int64 v13; // [rsp+30h] [rbp-20h]
  signed __int64 v14; // [rsp+38h] [rbp-18h]
  __int64 v15; // [rsp+40h] [rbp-10h]
  __int64 v16; // [rsp+48h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_wd_default", a4, a5, a6);
  v13 = 0LL;
  v14 = 0LL;
  v7 = 0;
  if ( !a1 || !(*(_DWORD *)(*a1 + 56LL) & 0xC) )
    return 0LL;
  if ( *((_BYTE *)a1 + 9) & 1 )
    return 1LL;
  if ( *(_DWORD *)(*a1 + 56LL) == 4 )
  {
    v16 = *a1;
    if ( *(_QWORD *)(*a1 + 200LL) )
    {
      v13 = *(_QWORD *)(v16 + 200);
    }
    else if ( !(*(_WORD *)(v16 + 24) & 0x40) )
    {
      for ( i = *(_QWORD *)(v16 + 144); i && !v13; i = *(_QWORD *)(i + 72) )
        v13 = *(_QWORD *)(i + 120);
    }
    if ( !v13 )
      return 0LL;
    if ( v13 != a1[7] )
      return 0LL;
  }
  else
  {
    if ( ((*(_BYTE *)(*(_QWORD *)(*a1 + 48LL) + 64LL) >> 1) & 7u) <= 1 )
      return 0LL;
    v15 = *a1;
    if ( *(_BYTE *)(*a1 + 30LL) )
    {
      v7 = *(_BYTE *)(v15 + 30);
      v14 = *(_QWORD *)(v15 + 200);
    }
    else if ( !*(_DWORD *)(v15 + 208) )
    {
      for ( j = *(_QWORD *)(v15 + 144); j; j = *(_QWORD *)(j + 72) )
      {
        if ( *(_QWORD *)(j + 120) )
        {
          v14 = j + 120;
          v7 = 1;
          break;
        }
      }
    }
    if ( !v7 )
      return 0LL;
    v10 = a1;
    if ( a1[5] )
    {
      v10 = *(_QWORD **)(a1[5] + 64LL);
    }
    else
    {
      while ( *(_QWORD *)(v10[4] + 24LL) )
        v10 = (_QWORD *)v10[4];
    }
    v8 = 0;
    while ( v10 )
    {
      if ( *v10 == *a1 )
      {
        if ( v8 == v7 )
          return 0LL;
        if ( *(_WORD *)(v15 + 24) & 0x100 )
        {
          if ( *(_QWORD *)(8LL * v8 + v14) != v10[7] )
            return 0LL;
        }
        else
        {
          for ( k = 0; k < v7 && *(_QWORD *)(8LL * k + v14) != v10[7]; ++k )
            ;
          if ( k == v7 )
            return 0LL;
        }
        ++v8;
      }
      v10 = (_QWORD *)v10[3];
    }
    if ( v8 != v7 )
      return 0LL;
  }
  return 1LL;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BDCC8) ----------------------------------------------------
signed __int64 __fastcall sub_BDCC8(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  unsigned int v4; // eax
  signed __int64 result; // rax
  __int64 *v6; // rax
  __int64 v7; // r9
  unsigned int v8; // eax
  __int64 v9; // [rsp+28h] [rbp-8h]

  v9 = 0LL;
  if ( a4 )
  {
    v4 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = v4 + 1;
    result = sub_B4516(*(void ***)(a1 + 24), (_DWORD *)(a1 + 32), v4, 4, 0LL, a2);
  }
  else if ( !a3 || (v9 = lyd_path(a3)) != 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = v8 + 1;
    result = sub_B4516(*(void ***)(a1 + 24), (_DWORD *)(a1 + 32), v8, 1, a2, v9);
  }
  else
  {
    v6 = (__int64 *)lyd_node_module(a2);
    sub_12222(*v6, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_data_diff_new", v7);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7920: using guessed type __int64 __fastcall lyd_path(_QWORD);

//----- (00000000000BDDC2) ----------------------------------------------------
__int64 __fastcall sub_BDDC2(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  if ( *(_DWORD *)(4LL * a2 + **(_QWORD **)(a1 + 24)) == 1 )
  {
    lyd_free_withsiblings(*(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL)));
    free(*(void **)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)));
  }
  if ( a2 < *(_DWORD *)(a1 + 36) - 1 )
  {
    *(_DWORD *)(**(_QWORD **)(a1 + 24) + 4LL * a2) = *(_DWORD *)(**(_QWORD **)(a1 + 24)
                                                               + 4LL * (unsigned int)(*(_DWORD *)(a1 + 36) - 1));
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) + 8LL * a2) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL)
                                                                                + 8LL
                                                                                * (unsigned int)(*(_DWORD *)(a1 + 36) - 1));
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL) + 8LL * a2) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24)
                                                                                             + 16LL)
                                                                                 + 8LL
                                                                                 * (unsigned int)(*(_DWORD *)(a1 + 36)
                                                                                                - 1));
  }
  if ( *(_DWORD *)(**(_QWORD **)(a1 + 24) + 4LL * *(unsigned int *)(a1 + 36)) )
    __assert_fail(
      "unres->diff->type[unres->diff_idx] == LYD_DIFF_END",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x1B94u,
      "unres_data_diff_rem");
  *(_DWORD *)(4LL * (unsigned int)(*(_DWORD *)(a1 + 36) - 1) + **(_QWORD **)(a1 + 24)) = *(_DWORD *)(**(_QWORD **)(a1 + 24) + 4LL * *(unsigned int *)(a1 + 36));
  result = a1;
  --*(_DWORD *)(a1 + 36);
  return result;
}
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);

//----- (00000000000BDF84) ----------------------------------------------------
unsigned __int64 __fastcall lyd_free_val_diff(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  int v7; // eax
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  result = sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_free_val_diff", a4, a5, a6);
  if ( a1 )
  {
    for ( i = 0; *(_DWORD *)(4LL * i + *a1); ++i )
    {
      v7 = *(_DWORD *)(4LL * i + *a1);
      if ( v7 == 1 )
      {
        lyd_free_withsiblings(*(_QWORD *)(8LL * i + a1[1]));
        free(*(void **)(8LL * i + a1[2]));
      }
      else if ( v7 == 4 )
      {
        free(*(void **)(8LL * i + a1[1]));
        lyd_free_withsiblings(*(_QWORD *)(8LL * i + a1[2]));
      }
    }
    result = lyd_free_diff(a1, &off_12268F);
  }
  return result;
}
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 7B30: using guessed type __int64 __fastcall lyd_free_diff(_QWORD, _QWORD);
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000BE08A) ----------------------------------------------------
signed __int64 __fastcall sub_BE08A(_QWORD **a1, _QWORD *a2, __int64 a3, __int64 a4, int a5)
{
  int v6; // [rsp+Ch] [rbp-54h]
  __int64 v7; // [rsp+10h] [rbp-50h]
  __int64 v8; // [rsp+18h] [rbp-48h]
  char v9; // [rsp+3Ch] [rbp-24h]
  __int64 j; // [rsp+40h] [rbp-20h]
  __int64 i; // [rsp+48h] [rbp-18h]
  void *v12; // [rsp+50h] [rbp-10h]
  _BYTE *v13; // [rsp+58h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v12 = 0LL;
  if ( *(_QWORD *)(a3 + 200) )
  {
    v12 = *(void **)(a3 + 200);
  }
  else if ( !(*(_WORD *)(a3 + 24) & 0x40) )
  {
    for ( i = *(_QWORD *)(a3 + 144); i && !v12; i = *(_QWORD *)(i + 72) )
      v12 = *(void **)(i + 120);
  }
  if ( !v12 )
    return 0LL;
  v13 = sub_B20A7(*a1, a2, a3, v12, 1u);
  if ( v13
    && (!*(_DWORD *)(v7 + 20) || !(unsigned int)sub_BDCC8(v7, (__int64)v13, 0LL, 1))
    && (*((_QWORD *)v13 + 5) || !*a1 || !(unsigned int)lyd_insert_sibling(a1, v13)) )
  {
    for ( j = (__int64)v13; ; j = *(_QWORD *)(j + 64) )
    {
      if ( v6 )
      {
        if ( (*(_BYTE *)(j + 9) >> 1) & 4 && (unsigned int)sub_2CD1C(v7, j, 0x200000) == -1 )
          break;
        if ( v6 == 2 )
        {
          v9 = sub_28087((_QWORD *)j);
          if ( v9 & 1 )
          {
            if ( (unsigned int)sub_2CD1C(v7, j, 0x400000) == -1 )
              break;
          }
          if ( v9 & 2 && (unsigned int)sub_2CD1C(v7, j, 0x800000) == -1 )
            break;
        }
      }
      *(_BYTE *)(j + 8) &= 0x7Fu;
      if ( v8 == *(_QWORD *)j )
      {
        sub_AF16B((__int64)v13);
        if ( *(_DWORD *)(j + 72) == 9 )
        {
          if ( (unsigned int)sub_2CD1C(v7, j, 0x80000) )
            break;
        }
        else if ( *(_DWORD *)(j + 72) == 8 && (unsigned int)sub_2CD1C(v7, j, (unsigned __int64)&loc_100000) )
        {
          break;
        }
        if ( !*a1 )
          *a1 = v13;
        return 0LL;
      }
    }
  }
  lyd_free(v13);
  return 1LL;
}
// 79D0: using guessed type __int64 __fastcall lyd_insert_sibling(_QWORD, _QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000BE34C) ----------------------------------------------------
signed __int64 __fastcall sub_BE34C(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int a5)
{
  int v6; // [rsp+Ch] [rbp-64h]
  __int64 v7; // [rsp+10h] [rbp-60h]
  __int64 v8; // [rsp+18h] [rbp-58h]
  unsigned __int8 v9; // [rsp+3Fh] [rbp-31h]
  signed int v10; // [rsp+40h] [rbp-30h]
  char v11; // [rsp+44h] [rbp-2Ch]
  __int64 j; // [rsp+48h] [rbp-28h]
  __int64 v13; // [rsp+50h] [rbp-20h]
  __int64 i; // [rsp+58h] [rbp-18h]
  signed __int64 v15; // [rsp+60h] [rbp-10h]
  _BYTE *v16; // [rsp+68h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v13 = 0LL;
  v15 = 0LL;
  v9 = 0;
  if ( ((*(_BYTE *)(*(_QWORD *)(a3 + 48) + 64LL) >> 1) & 7u) <= 1 )
    return 0LL;
  if ( *(_BYTE *)(a3 + 30) )
  {
    v9 = *(_BYTE *)(a3 + 30);
    v15 = *(_QWORD *)(a3 + 200);
  }
  else if ( !*(_DWORD *)(a3 + 208) )
  {
    for ( i = *(_QWORD *)(a3 + 144); i; i = *(_QWORD *)(i + 72) )
    {
      if ( *(_QWORD *)(i + 120) )
      {
        v15 = i + 120;
        v9 = 1;
        break;
      }
    }
  }
  if ( !v9 )
    return 0LL;
  v10 = 0;
  while ( 2 )
  {
    if ( v10 < v9 )
    {
      v16 = sub_B20A7((_QWORD *)*a1, a2, v8, *(void **)(8LL * v10 + v15), 1u);
      if ( !v16 || *(_DWORD *)(v7 + 20) && (unsigned int)sub_BDCC8(v7, (__int64)v16, 0LL, 1) )
        goto LABEL_47;
      if ( v13 )
      {
        if ( !*((_QWORD *)v16 + 5) )
        {
          *(_QWORD *)(*(_QWORD *)(v13 + 32) + 24LL) = v16;
          *((_QWORD *)v16 + 4) = *(_QWORD *)(v13 + 32);
          *(_QWORD *)(v13 + 32) = v16;
        }
      }
      else
      {
        v13 = (__int64)v16;
      }
      for ( j = (__int64)v16; ; j = *(_QWORD *)(j + 64) )
      {
        if ( v6 )
        {
          if ( (*(_BYTE *)(j + 9) >> 1) & 4 && (unsigned int)sub_2CD1C(v7, j, 0x200000) == -1 )
            goto LABEL_47;
          if ( v6 == 2 )
          {
            v11 = sub_28087((_QWORD *)j);
            if ( v11 & 1 )
            {
              if ( (unsigned int)sub_2CD1C(v7, j, 0x400000) == -1 )
                goto LABEL_47;
            }
            if ( v11 & 2 && (unsigned int)sub_2CD1C(v7, j, 0x800000) == -1 )
              goto LABEL_47;
          }
        }
        *(_BYTE *)(j + 8) &= 0x7Fu;
        if ( v8 == *(_QWORD *)j )
          break;
      }
      if ( *(_DWORD *)(j + 72) == 9 )
      {
        if ( (unsigned int)sub_2CD1C(v7, j, 0x80000) )
          goto LABEL_47;
      }
      else if ( *(_DWORD *)(j + 72) == 8 && (unsigned int)sub_2CD1C(v7, j, (unsigned __int64)&loc_100000) )
      {
        goto LABEL_47;
      }
      ++v10;
      continue;
    }
    break;
  }
  if ( !v13 || *(_QWORD *)(v13 + 40) || !*a1 )
  {
    if ( !*a1 )
      *a1 = v13;
    goto LABEL_46;
  }
  if ( !(unsigned int)lyd_insert_sibling(a1, v13) )
  {
LABEL_46:
    sub_AF16B(v13);
    return 0LL;
  }
LABEL_47:
  lyd_free_withsiblings(v13);
  return 1LL;
}
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 79D0: using guessed type __int64 __fastcall lyd_insert_sibling(_QWORD, _QWORD);

//----- (00000000000BE6C9) ----------------------------------------------------
__int64 __fastcall sub_BE6C9(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned int i; // [rsp+1Ch] [rbp-4h]
  unsigned int j; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    __assert_fail("set", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1C89u, "lyd_wd_leaflist_cleanup");
  for ( i = 0; i < *(_DWORD *)(a1 + 4) && *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 8)) + 9LL) & 1; ++i )
    ;
  result = *(unsigned int *)(a1 + 4);
  if ( i < (unsigned int)result )
  {
    for ( j = 0; ; ++j )
    {
      result = *(unsigned int *)(a1 + 4);
      if ( j >= (unsigned int)result )
        break;
      if ( *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(a1 + 8)) + 9LL) & 1 )
      {
        if ( *(_DWORD *)(a2 + 20) )
        {
          sub_BDCC8(
            a2,
            *(_QWORD *)(8LL * j + *(_QWORD *)(a1 + 8)),
            *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(a1 + 8)) + 40LL),
            0);
          lyd_unlink(*(_QWORD *)(8LL * j + *(_QWORD *)(a1 + 8)));
        }
        else
        {
          lyd_free(*(_QWORD *)(8LL * j + *(_QWORD *)(a1 + 8)));
        }
      }
    }
  }
  return result;
}
// 7840: using guessed type __int64 __fastcall lyd_unlink(_QWORD);
// 7BE0: using guessed type __int64 __fastcall lyd_free(_QWORD);

//----- (00000000000BE818) ----------------------------------------------------
signed __int64 __fastcall sub_BE818(__int64 *a1, __int64 *a2, _BYTE *a3, __int64 a4, int a5, int a6, __int64 a7)
{
  unsigned int v8; // eax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 *v11; // rax
  int v12; // [rsp+Ch] [rbp-54h]
  __int64 v13; // [rsp+10h] [rbp-50h]
  _BYTE *v14; // [rsp+18h] [rbp-48h]
  __int64 *v15; // [rsp+28h] [rbp-38h]
  int i; // [rsp+34h] [rbp-2Ch]
  char v17; // [rsp+34h] [rbp-2Ch]
  int m; // [rsp+34h] [rbp-2Ch]
  int n; // [rsp+34h] [rbp-2Ch]
  int jj; // [rsp+34h] [rbp-2Ch]
  int v21; // [rsp+38h] [rbp-28h]
  signed int v22; // [rsp+3Ch] [rbp-24h]
  __int64 v23; // [rsp+40h] [rbp-20h]
  __int64 j; // [rsp+48h] [rbp-18h]
  __int64 l; // [rsp+48h] [rbp-18h]
  __int64 v26; // [rsp+50h] [rbp-10h]
  _BYTE *ii; // [rsp+58h] [rbp-8h]
  _BYTE *kk; // [rsp+58h] [rbp-8h]
  __int64 *k; // [rsp+58h] [rbp-8h]

  v15 = a1;
  v14 = a3;
  v13 = a4;
  v12 = a5;
  v23 = 0LL;
  v22 = 0;
  if ( !a1 )
    __assert_fail("root", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1CBBu, "lyd_wd_add_subtree");
  if ( a6 & 0x10000FF && *(_WORD *)(a4 + 24) & 2 )
    return 0LL;
  if ( a6 & 0x8E )
  {
    v21 = 0;
  }
  else if ( a6 & 0x2000 )
  {
    v21 = 1;
  }
  else
  {
    v21 = 2;
  }
  if ( a5 && *(_DWORD *)(a4 + 56) & 0x1D )
  {
    v23 = ly_set_new(a1);
    if ( v23 )
    {
      if ( *a1 && (unsigned int)sub_ACE6B((_QWORD *)*a1, v13, v23) )
      {
        for ( i = 0; i < *(_DWORD *)(v23 + 4); ++i )
        {
          if ( *(_DWORD *)(v13 + 56) & 8 )
          {
            sub_BE6C9(v23, a7);
          }
          else if ( *(_DWORD *)(v13 + 56) != 4 && (unsigned int)sub_BE818((__int64)a1) )
          {
            goto LABEL_153;
          }
        }
        goto LABEL_25;
      }
      if ( !(unsigned int)sub_BE818((__int64)a1) )
      {
LABEL_25:
        ly_set_free(v23);
        return 0LL;
      }
    }
    goto LABEL_153;
  }
  if ( !a3 )
  {
    for ( j = *(_QWORD *)(a4 + 64); j && *(_DWORD *)(j + 56) & 0x1002; j = *(_QWORD *)(j + 64) )
    {
      if ( lys_is_disabled(j, 0LL) )
        return 0LL;
    }
    if ( j && *(_DWORD *)(j + 56) == 0x2000 && lys_is_disabled(j, 0LL) )
      return 0LL;
    a1 = (__int64 *)v13;
    if ( lys_is_disabled(v13, 0LL) )
      return 0LL;
  }
  v8 = *(_DWORD *)(v13 + 56);
  if ( v8 == 16 )
  {
    if ( !v14 )
      goto LABEL_152;
    goto LABEL_57;
  }
  if ( v8 > 0x10 )
  {
    if ( v8 != 512 )
    {
      if ( v8 > 0x200 )
      {
        if ( v8 != 1024 && v8 != 4096 )
          goto LABEL_152;
      }
      else if ( v8 != 64 && v8 != 128 )
      {
        goto LABEL_152;
      }
    }
    goto LABEL_77;
  }
  if ( v8 == 2 )
  {
    k = 0LL;
    if ( v12 && *v15 || !v12 && v14 )
    {
      if ( v12 )
        v11 = (__int64 *)*v15;
      else
        v11 = (__int64 *)*((_QWORD *)v14 + 8);
      for ( k = v11; k; k = (__int64 *)k[3] )
      {
        j = lys_parent(*k);
        v26 = *k;
        while ( j && *(_DWORD *)(j + 56) & 0x1042 && j != v13 )
        {
          v26 = j;
          j = lys_parent(j);
        }
        if ( j == v13 )
          break;
      }
    }
    if ( k )
    {
      if ( !j || !v26 )
        __assert_fail(
          "siter && siter_prev",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0x1DC0u,
          "lyd_wd_add_subtree");
      if ( !(unsigned int)sub_BE818((__int64)v15) )
        goto LABEL_152;
    }
    else if ( !*(_QWORD *)(v13 + 112) || !(unsigned int)sub_BE818((__int64)v15) )
    {
      goto LABEL_152;
    }
  }
  else
  {
    if ( v8 <= 2 )
    {
      if ( v8 != 1 )
        goto LABEL_152;
LABEL_57:
      if ( !v14 )
      {
        if ( !*(_QWORD *)(v13 + 136) )
        {
          a1 = a2;
          v14 = sub_AE9DE((__int64)a2, v13, 1);
          v14[8] &= 0xFBu;
          if ( *(_DWORD *)(a7 + 20) )
          {
            a1 = (__int64 *)a7;
            if ( (unsigned int)sub_BDCC8(a7, (__int64)v14, 0LL, 1) )
              goto LABEL_153;
            v22 = 1;
            *(_DWORD *)(a7 + 20) = 0;
          }
          if ( !a2 )
          {
            if ( *v15 )
            {
              a1 = *(__int64 **)(*v15 + 40);
              sub_B70F6(a1, v15, (__int64 *)v14, 0LL, v9, v10);
            }
            else
            {
              *v15 = (__int64)v14;
            }
          }
          if ( v21 )
          {
            if ( (v14[9] >> 1) & 4 )
            {
              a1 = (__int64 *)a7;
              if ( (unsigned int)sub_2CD1C(a7, (__int64)v14, 0x200000) == -1 )
                goto LABEL_153;
            }
            if ( v21 == 2 )
            {
              a1 = (__int64 *)v14;
              v17 = sub_28087(v14);
              if ( v17 & 1 )
              {
                a1 = (__int64 *)a7;
                if ( (unsigned int)sub_2CD1C(a7, (__int64)v14, 0x400000) == -1 )
                  goto LABEL_153;
              }
              if ( v17 & 2 )
              {
                a1 = (__int64 *)a7;
                if ( (unsigned int)sub_2CD1C(a7, (__int64)v14, 0x800000) == -1 )
                  goto LABEL_153;
              }
            }
          }
          goto LABEL_77;
        }
LABEL_152:
        ly_set_free(v23);
        return 0LL;
      }
      if ( !*(_QWORD *)(v13 + 136) )
        v14[9] |= 1u;
LABEL_77:
      v23 = ly_set_new(a1);
      if ( v23 )
      {
        for ( l = *(_QWORD *)(v13 + 72); l; l = *(_QWORD *)(l + 80) )
        {
          if ( *(_DWORD *)(l + 56) & 0x1002 )
          {
            if ( (unsigned int)sub_BE818((__int64)v15) )
              goto LABEL_153;
          }
          else if ( *(_DWORD *)(l + 56) & 0x803D )
          {
            if ( v14 && (unsigned int)sub_ACE6B(*((_QWORD **)v14 + 8), l, v23) )
            {
              if ( *(_DWORD *)(l + 56) & 8 )
              {
                sub_BE6C9(v23, a7);
              }
              else if ( *(_DWORD *)(l + 56) != 4 )
              {
                for ( m = 0; m < *(_DWORD *)(v23 + 4); ++m )
                {
                  if ( (unsigned int)sub_BE818((__int64)v15) )
                    goto LABEL_153;
                }
              }
              if ( v14[9] & 1 )
              {
                for ( n = 0; n < *(_DWORD *)(v23 + 4); ++n )
                {
                  if ( !(*(_BYTE *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v23 + 8)) + 9LL) & 1) )
                  {
                    for ( ii = v14; ii && ii[9] & 1; ii = (_BYTE *)*((_QWORD *)ii + 5) )
                      ii[9] &= 0xFEu;
                    break;
                  }
                }
              }
              ly_set_clean(v23);
            }
            else if ( (unsigned int)sub_BE818((__int64)v15) )
            {
              goto LABEL_153;
            }
          }
        }
        if ( v22 )
          *(_DWORD *)(a7 + 20) = 1;
        goto LABEL_152;
      }
      goto LABEL_153;
    }
    if ( v8 != 4 && v8 != 8 )
      goto LABEL_152;
    if ( v14 )
    {
      v23 = ly_set_new(a1);
      if ( !v23 )
        goto LABEL_153;
      sub_ACE6B(*((_QWORD **)v14 + 8), v13, v23);
      if ( *(_DWORD *)(v23 + 4) )
      {
        if ( v14[9] & 1 )
        {
          for ( jj = 0; jj < *(_DWORD *)(v23 + 4); ++jj )
          {
            if ( !(*(_BYTE *)(*(_QWORD *)(8LL * jj + *(_QWORD *)(v23 + 8)) + 9LL) & 1) )
            {
              for ( kk = v14; kk && kk[9] & 1; kk = (_BYTE *)*((_QWORD *)kk + 5) )
                kk[9] &= 0xFEu;
              goto LABEL_152;
            }
          }
        }
        goto LABEL_152;
      }
    }
    if ( *(_DWORD *)(v13 + 56) == 4 )
    {
      if ( (unsigned int)sub_BE08A((_QWORD **)v15, a2, v13, a7, v21) )
        return 1LL;
      goto LABEL_152;
    }
    if ( !(unsigned int)sub_BE34C(v15, a2, v13, a7, v21) )
      goto LABEL_152;
  }
LABEL_153:
  ly_set_free(v23);
  return 1LL;
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7230: using guessed type __int64 __fastcall ly_set_clean(_QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 77C0: using guessed type __int64 __fastcall ly_set_new(_QWORD);

//----- (00000000000BF27C) ----------------------------------------------------
signed __int64 __fastcall sub_BF27C(__int64 *a1, __int64 a2, __int64 a3, signed int a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+10h] [rbp-30h]
  signed int v9; // [rsp+14h] [rbp-2Ch]
  __int64 v10; // [rsp+18h] [rbp-28h]
  __int64 v11; // [rsp+20h] [rbp-20h]
  __int64 v12; // [rsp+34h] [rbp-Ch]
  int k; // [rsp+34h] [rbp-Ch]
  __int64 j; // [rsp+38h] [rbp-8h]
  __int64 l; // [rsp+38h] [rbp-8h]
  __int64 i; // [rsp+38h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  v9 = a4;
  v7 = a5;
  v8 = a6;
  if ( !a1 || a6 & 0x100 )
    __assert_fail(
      "root && !(options & LYD_OPT_ACT_NOTIF)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x1DE3u,
      "lyd_wd_add");
  if ( !*a1 && !a2 )
    __assert_fail("*root || ctx", "/home/mantovan/Repositories/libyang/src/tree_data.c", 0x1DE4u, "lyd_wd_add");
  if ( a6 & 0x1000 && !*a1 )
    __assert_fail(
      "!(options & LYD_OPT_NOSIBLINGS) || *root",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x1DE5u,
      "lyd_wd_add");
  if ( a6 & 0xE )
    return 0LL;
  if ( !a2 )
    v11 = **(_QWORD **)(*(_QWORD *)*a1 + 48LL);
  if ( a6 & 0x10000FF && !(a6 & 1) )
  {
    if ( a6 & 0x40 )
    {
      if ( !*a1 || *(_DWORD *)(*(_QWORD *)*a1 + 56LL) != 128 )
      {
        sub_12222(v11, 0, 3, "Subtree is not a single notification.", a5, a6);
        return 1LL;
      }
      if ( (unsigned int)sub_BE818(a1, (__int64 *)*a1, (_BYTE *)*a1, *(_QWORD *)*a1, 0, a6, a5) )
        return 1LL;
    }
    else if ( a6 & 0x30 )
    {
      if ( !*a1 || !(*(_DWORD *)(*(_QWORD *)*a1 + 56LL) & 0x4100) )
      {
        sub_12222(v11, 0, 3, "Subtree is not a single RPC/action/reply.", a5, a6);
        return 1LL;
      }
      if ( a6 & 0x10 )
      {
        for ( i = *(_QWORD *)(*(_QWORD *)*a1 + 72LL); i && *(_DWORD *)(i + 56) != 512; i = *(_QWORD *)(i + 80) )
          ;
      }
      else
      {
        for ( i = *(_QWORD *)(*(_QWORD *)*a1 + 72LL); i && *(_DWORD *)(i + 56) != 1024; i = *(_QWORD *)(i + 80) )
          ;
      }
      if ( i && (unsigned int)sub_BE818(a1, (__int64 *)*a1, (_BYTE *)*a1, i, 0, a6, a5) )
        return 1LL;
    }
    else
    {
      if ( !(a6 & 0x1000000) )
      {
        sub_12222(
          v11,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
          7726LL);
        return 1LL;
      }
      if ( (unsigned int)sub_BE818(a1, 0LL, 0LL, *(_QWORD *)*a1, 1, a6, a5) )
        return 1LL;
    }
  }
  else if ( a6 & 0x1000 )
  {
    if ( (unsigned int)sub_BE818(a1, 0LL, 0LL, *(_QWORD *)*a1, 1, a6, a5) )
      return 1LL;
  }
  else if ( a3 && a4 )
  {
    LODWORD(v12) = 0;
    while ( (signed int)v12 < v9 )
    {
      for ( j = *(_QWORD *)(*(_QWORD *)(8LL * (signed int)v12 + v10) + 168LL); j; j = *(_QWORD *)(j + 80) )
      {
        if ( *(_DWORD *)(j + 56) & 0x903F && (unsigned int)sub_BE818(a1, 0LL, 0LL, j, 1, v8, v7) )
          return 1LL;
      }
      v12 = (unsigned int)(v12 + 1);
    }
  }
  else
  {
    for ( k = 0; k < *(_DWORD *)(v11 + 60); ++k )
    {
      if ( *(_BYTE *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v11 + 64)) + 64LL) < 0
        && !(*(_BYTE *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v11 + 64)) + 64LL) & 0x40) )
      {
        for ( l = *(_QWORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v11 + 64)) + 168LL); l; l = *(_QWORD *)(l + 80) )
        {
          if ( *(_DWORD *)(l + 56) & 0x903F && (unsigned int)sub_BE818(a1, 0LL, 0LL, l, 1, v8, v7) )
            return 1LL;
        }
      }
    }
  }
  return 0LL;
}

//----- (00000000000BF7F8) ----------------------------------------------------
signed __int64 __fastcall sub_BF7F8(char ***a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char **a7, __int64 a8, int a9)
{
  char *v10; // rax
  __int64 *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  _QWORD *v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // [rsp+8h] [rbp-68h]
  void *v22; // [rsp+18h] [rbp-58h]
  unsigned int v23; // [rsp+24h] [rbp-4Ch]
  unsigned int v24; // [rsp+3Ch] [rbp-34h]
  char **i; // [rsp+40h] [rbp-30h]
  char **v26; // [rsp+48h] [rbp-28h]
  __int64 v27; // [rsp+50h] [rbp-20h]
  _QWORD *v28; // [rsp+58h] [rbp-18h]
  char *v29; // [rsp+60h] [rbp-10h]
  __int64 v30; // [rsp+68h] [rbp-8h]

  v23 = a2;
  v22 = (void *)a3;
  v21 = a6;
  i = 0LL;
  v26 = 0LL;
  v29 = 0LL;
  v24 = 1;
  if ( !a1 || !*a1 && !a3 || !a8 || a2 & 0x100 )
    __assert_fail(
      "root && (*root || ctx) && unres && !(options & LYD_OPT_ACT_NOTIF)",
      "/home/mantovan/Repositories/libyang/src/tree_data.c",
      0x1E3Fu,
      "lyd_defaults_add_unres");
  if ( !a3 )
    v22 = (void *)**((_QWORD **)**a1 + 6);
  if ( a2 & 0x1000 && !*a1 )
  {
    sub_12222(
      (__int64)v22,
      0,
      3,
      "Cannot add default values for one module (LYD_OPT_NOSIBLINGS) without any data.",
      a5,
      a6);
    return 1LL;
  }
  if ( a2 & 0x70 )
  {
    if ( !*a1 )
    {
      sub_12222(
        (__int64)v22,
        0,
        3,
        "Cannot add default values to RPC, RPC reply, and notification without at least the empty container.",
        a5,
        a6);
      return 1LL;
    }
    if ( a2 & 0x10 && !a7 && *((_DWORD *)**a1 + 14) != 256 )
    {
      sub_12222((__int64)v22, 0, 3, "Not valid RPC/action data.", a5, a6);
      return 1LL;
    }
    if ( a2 & 0x20 && !a7 && *((_DWORD *)**a1 + 14) != 256 )
    {
      sub_12222((__int64)v22, 0, 3, "Not valid reply data.", a5, a6);
      return 1LL;
    }
    if ( a2 & 0x40 && !a7 && *((_DWORD *)**a1 + 14) != 128 )
    {
      sub_12222((__int64)v22, 0, 3, "Not valid notification data.", a5, a6);
      return 1LL;
    }
    if ( a7 )
      v10 = *a7;
    else
      v10 = **a1;
    v29 = v10;
  }
  else if ( *a1 && (*a1)[5] )
  {
    v23 = a2 | 0x1000;
  }
  if ( a9 )
  {
    v11 = (__int64 *)(a7 ? &a7 : a1);
    if ( (unsigned int)sub_BF27C(v11, (__int64)v22, a4, a5, a8, v23) )
      return 1LL;
  }
  if ( a8 && *(_DWORD *)(a8 + 16) )
  {
    if ( !*a1 )
    {
      sub_12222(
        (__int64)v22,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/tree_data.c",
        7789LL);
      return 1LL;
    }
    if ( v21 && v23 & 0x70 )
    {
      v26 = 0LL;
      i = *a1;
      if ( a7 )
      {
        v28 = 0LL;
        v27 = v21;
        while ( v27 )
        {
          while ( v27 )
          {
            a3 = *(_QWORD *)v27;
            if ( *(char **)v27 == *i && (*((_DWORD *)*i + 14) != 16 || (unsigned int)sub_ABF28(v27, (__int64)i, 0)) )
              break;
            v27 = *(_QWORD *)(v27 + 24);
          }
          if ( v27 )
          {
            v28 = (_QWORD *)v27;
            v27 = *(_QWORD *)(v27 + 64);
            v26 = i;
            if ( !i[8] )
              __assert_fail(
                "msg_sibling->child",
                "/home/mantovan/Repositories/libyang/src/tree_data.c",
                0x1E8Eu,
                "lyd_defaults_add_unres");
            for ( i = (char **)i[8]; *((_DWORD *)*i + 14) == 4; i = (char **)i[3] )
            {
              if ( !i[3] )
                __assert_fail(
                  "msg_sibling->next",
                  "/home/mantovan/Repositories/libyang/src/tree_data.c",
                  0x1E92u,
                  "lyd_defaults_add_unres");
            }
            if ( *((_DWORD *)*i + 14) & 0x4080 )
            {
              if ( !a7[5] )
                __assert_fail(
                  "act_notif->parent",
                  "/home/mantovan/Repositories/libyang/src/tree_data.c",
                  0x1E96u,
                  "lyd_defaults_add_unres");
              a3 = *(_QWORD *)a7[5];
              if ( a3 != *v28 )
                __assert_fail(
                  "act_notif->parent->schema == data_tree_parent->schema",
                  "/home/mantovan/Repositories/libyang/src/tree_data.c",
                  0x1E97u,
                  "lyd_defaults_add_unres");
              if ( i != a7 )
                __assert_fail(
                  "msg_sibling == act_notif",
                  "/home/mantovan/Repositories/libyang/src/tree_data.c",
                  0x1E98u,
                  "lyd_defaults_add_unres");
              break;
            }
          }
        }
        if ( !v28 )
          v27 = v21;
      }
      else
      {
        v28 = 0LL;
        v27 = v21;
      }
      sub_BA11B(i, 0, a3, a4, a5, a6);
      if ( !v28 && !v27 )
        __assert_fail(
          "data_tree_parent || data_tree_sibling",
          "/home/mantovan/Repositories/libyang/src/tree_data.c",
          0x1EADu,
          "lyd_defaults_add_unres");
      if ( v28 )
      {
        if ( (unsigned int)sub_B70F6(v28, 0LL, (__int64 *)i, 0LL, v12, v13) )
        {
LABEL_100:
          if ( v21 && v23 & 0x70 )
          {
            sub_BA11B(i, 0, v14, v15, v16, v17);
            if ( v26 )
              sub_B70F6(v26, 0LL, (__int64 *)i, 0LL, v19, v20);
          }
          return v24;
        }
      }
      else
      {
        if ( *(_QWORD *)(v27 + 40) )
          __assert_fail(
            "!data_tree_sibling->parent",
            "/home/mantovan/Repositories/libyang/src/tree_data.c",
            0x1EB3u,
            "lyd_defaults_add_unres");
        if ( (unsigned int)sub_B7B96(*(__int64 **)(v27 + 32), (__int64 *)i, 0, 0) )
          goto LABEL_100;
      }
    }
    if ( !(unsigned int)sub_2D16B((__int64)v22, a8, (__int64)a1, v23) )
    {
      v24 = 0;
      if ( v23 & 0x70 )
      {
        v30 = 0LL;
        if ( v21 )
        {
          if ( v28 )
            v18 = v28;
          else
            v18 = (_QWORD *)v27;
          v30 = lyd_find_instance(v18, v29);
          if ( !v30 || *(_DWORD *)(v30 + 4) && *(_DWORD *)(v30 + 4) != 1 )
            __assert_fail(
              "set && ((set->number == 0) || (set->number == 1))",
              "/home/mantovan/Repositories/libyang/src/tree_data.c",
              0x1EC6u,
              "lyd_defaults_add_unres");
        }
        else if ( *a1 )
        {
          v30 = lyd_find_instance(*a1, v29);
          if ( !v30 || *(_DWORD *)(v30 + 4) && *(_DWORD *)(v30 + 4) != 1 )
            __assert_fail(
              "set && ((set->number == 0) || (set->number == 1))",
              "/home/mantovan/Repositories/libyang/src/tree_data.c",
              0x1EC9u,
              "lyd_defaults_add_unres");
        }
        if ( !v30 || !*(_DWORD *)(v30 + 4) )
        {
          sub_13937(
            v22,
            -1,
            2u,
            v29,
            (__int64)"Operation/notification not supported because of the current configuration.",
            v17);
          v24 = 1;
        }
        ly_set_free(v30);
      }
    }
    goto LABEL_100;
  }
  return 0;
}
// 7380: using guessed type __int64 __fastcall lyd_find_instance(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);

//----- (00000000000BFF9D) ----------------------------------------------------
__int64 __fastcall lyd_node_module(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_node_module", a4, a5, a6);
  if ( !a1 )
    return 0LL;
  if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 48LL) + 64LL) & 1 )
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48LL) + 168LL);
  return *(_QWORD *)(*(_QWORD *)a1 + 48LL);
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000C000B) ----------------------------------------------------
double __fastcall lyd_dec64_to_double(const char **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9

  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_dec64_to_double", a4, a5, a6);
  if ( a1 && *((_DWORD *)*a1 + 14) & 0xC && *((_DWORD *)*a1 + 32) == 4 )
    return atof(a1[7]);
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_dec64_to_double", v6);
  return 0.0;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000C00AE) ----------------------------------------------------
__int64 __fastcall lyd_leaf_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+10h] [rbp-10h]
  unsigned __int64 v8; // [rsp+18h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_12268F, (__int64)"lyd_leaf_type", a4, a5, a6);
  if ( !a1 || !(*(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC) )
    return 0LL;
  v7 = *(_QWORD *)a1 + 128LL;
  do
  {
    if ( *(_DWORD *)v7 == 9 )
    {
      v7 = *(_QWORD *)(v7 + 40) + 128LL;
    }
    else if ( *(_DWORD *)v7 == 11 )
    {
      if ( *(_DWORD *)(v7 + 44) && *(_BYTE *)(a1 + 8) )
      {
        sub_13937(
          **(void ***)(*(_QWORD *)a1 + 48LL),
          -1,
          3u,
          (char *)a1,
          (__int64)"Unable to determine the type of value \"%s\" from union type \"%s\" prior to validation.",
          *(_QWORD *)(a1 + 56),
          **(_QWORD **)(v7 + 16));
        return 0LL;
      }
      if ( (unsigned int)sub_2C282(a1, (_DWORD *)v7, 0, 0, &v7) )
        return 0LL;
    }
  }
  while ( *(_DWORD *)v7 == 9 );
  return v7;
}
// 12268F: using guessed type void *__ptr32 off_12268F;

//----- (00000000000C020B) ----------------------------------------------------
void *__fastcall ly_get_loaded_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_124340, (__int64)"ly_get_loaded_plugins", a4, a5, a6);
  return qword_3470C8;
}
// 124340: using guessed type void *off_124340;

//----- (00000000000C0235) ----------------------------------------------------
__int64 __fastcall ly_clean_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int i; // [rsp+8h] [rbp-8h]
  unsigned int j; // [rsp+8h] [rbp-8h]
  unsigned int v9; // [rsp+Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_124340, (__int64)"ly_clean_plugins", a4, a5, a6);
  v9 = 0;
  pthread_mutex_lock(&mutex);
  if ( --dword_3470D4 )
  {
    v9 = 1;
  }
  else if ( word_347068 || word_347078 )
  {
    free(ptr);
    ptr = 0LL;
    word_347068 = 0;
    free(qword_347070);
    qword_347070 = 0LL;
    word_347078 = 0;
    for ( i = 0; i < (unsigned __int16)word_3470D0; ++i )
      free(*((void **)qword_3470C8 + i));
    free(qword_3470C8);
    qword_3470C8 = 0LL;
    word_3470D0 = 0;
    for ( j = 0; j < dword_347084; ++j )
      dlclose(*((void **)qword_347088 + j));
    free(qword_347088);
    qword_347088 = 0LL;
    dword_347080 = 0;
    dword_347084 = 0;
  }
  pthread_mutex_unlock(&mutex);
  return v9;
}
// 124340: using guessed type void *off_124340;
// 347068: using guessed type __int16 word_347068;
// 347078: using guessed type __int16 word_347078;
// 347080: using guessed type int dword_347080;
// 347084: using guessed type int dword_347084;
// 3470D0: using guessed type __int16 word_3470D0;
// 3470D4: using guessed type int dword_3470D4;

//----- (00000000000C03C5) ----------------------------------------------------
__int64 __fastcall sub_C03C5(void *a1, const char *a2)
{
  __int64 result; // rax
  __int64 v3; // rax
  void *v4; // [rsp+18h] [rbp-18h]
  char *v5; // [rsp+20h] [rbp-10h]
  _DWORD *v6; // [rsp+28h] [rbp-8h]

  v4 = dlsym(a1, a2);
  v5 = dlerror();
  if ( v5 )
  {
    sub_12222(
      0LL,
      0,
      2,
      "Processing \"%s\" user type plugin failed, missing plugin list object (%s).",
      (__int64)a2,
      (__int64)v5,
      a2,
      a1);
    result = 1LL;
  }
  else
  {
    v6 = dlsym(a1, "lytype_api_version");
    if ( dlerror() || *v6 != 1 )
    {
      if ( v6 )
        v3 = (unsigned int)*v6;
      else
        v3 = 0LL;
      sub_12222(
        0LL,
        1u,
        0,
        "Processing \"%s\" user type plugin failed, wrong API version - %d expected, %d found.",
        (__int64)a2,
        1LL,
        v3);
      result = 1LL;
    }
    else
    {
      result = ly_register_types(v4, a2);
    }
  }
  return result;
}
// 7650: using guessed type __int64 __fastcall ly_register_types(_QWORD, _QWORD);

//----- (00000000000C04C6) ----------------------------------------------------
signed __int64 __fastcall ly_register_types(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *v6; // rcx
  const char *v7; // rdx
  signed __int64 result; // rax
  __int64 v9; // r9
  __int64 v10; // [rsp+0h] [rbp-20h]
  unsigned int v11; // [rsp+10h] [rbp-10h]
  unsigned int i; // [rsp+14h] [rbp-Ch]
  void *v13; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_124340, (__int64)"ly_register_types", a4, a5, a6, a2);
  v11 = 0;
LABEL_18:
  if ( *(_QWORD *)(40LL * v11 + a1 + 16) )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= (unsigned __int16)word_347078 )
      {
        ++v11;
        goto LABEL_18;
      }
      if ( !strcmp(*(const char **)(40LL * v11 + a1 + 16), *((const char **)qword_347070 + 5 * i + 2))
        && !strcmp(*(const char **)(40LL * v11 + a1), *((const char **)qword_347070 + 5 * i))
        && (!*(_QWORD *)(40LL * v11 + a1 + 8)
         || !*((_QWORD *)qword_347070 + 5 * i + 1)
         || !strcmp(*(const char **)(40LL * v11 + a1 + 8), *((const char **)qword_347070 + 5 * i + 1))) )
      {
        break;
      }
    }
    if ( *(_QWORD *)(40LL * v11 + a1 + 8) )
      v6 = *(void **)(40LL * v11 + a1 + 8);
    else
      v6 = &unk_1243FC;
    if ( *(_QWORD *)(40LL * v11 + a1 + 8) )
      v7 = "@";
    else
      v7 = (const char *)&unk_1243FC;
    sub_12222(
      0LL,
      0,
      2,
      "Processing \"%s\" extension plugin failed,implementation collision for extension %s from module %s%s%s.",
      v10,
      *(_QWORD *)(40LL * v11 + a1 + 16),
      *(_QWORD *)(40LL * v11 + a1),
      v7,
      v6);
    result = 1LL;
  }
  else
  {
    v13 = realloc(qword_347070, 40LL * ((unsigned __int16)word_347078 + v11));
    if ( v13 )
    {
      qword_347070 = v13;
      while ( v11 )
      {
        memcpy(
          (char *)qword_347070 + 40 * (unsigned __int16)word_347078,
          (const void *)(40LL * (v11 - 1) + a1),
          0x28uLL);
        ++word_347078;
        --v11;
      }
      result = 0LL;
    }
    else
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_register_types", v9);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 124340: using guessed type void *off_124340;
// 347078: using guessed type __int16 word_347078;

//----- (00000000000C0875) ----------------------------------------------------
__int64 __fastcall sub_C0875(void *a1, const char *a2)
{
  __int64 result; // rax
  __int64 v3; // rax
  void *v4; // [rsp+18h] [rbp-18h]
  char *v5; // [rsp+20h] [rbp-10h]
  _DWORD *v6; // [rsp+28h] [rbp-8h]

  v4 = dlsym(a1, a2);
  v5 = dlerror();
  if ( v5 )
  {
    sub_12222(
      0LL,
      0,
      2,
      "Processing \"%s\" extension plugin failed, missing plugin list object (%s).",
      (__int64)a2,
      (__int64)v5,
      a2,
      a1);
    result = 1LL;
  }
  else
  {
    v6 = dlsym(a1, "lyext_api_version");
    if ( dlerror() || *v6 != 1 )
    {
      if ( v6 )
        v3 = (unsigned int)*v6;
      else
        v3 = 0LL;
      sub_12222(
        0LL,
        1u,
        0,
        "Processing \"%s\" extension plugin failed, wrong API version - %d expected, %d found.",
        (__int64)a2,
        1LL,
        v3);
      result = 1LL;
    }
    else
    {
      result = ly_register_exts(v4, a2);
    }
  }
  return result;
}
// 7280: using guessed type __int64 __fastcall ly_register_exts(_QWORD, _QWORD);

//----- (00000000000C0976) ----------------------------------------------------
signed __int64 __fastcall ly_register_exts(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *v6; // rdx
  const char *v7; // rax
  signed __int64 result; // rax
  __int64 v9; // r9
  __int64 v10; // [rsp+0h] [rbp-30h]
  unsigned int i; // [rsp+18h] [rbp-18h]
  unsigned int j; // [rsp+1Ch] [rbp-14h]
  unsigned int k; // [rsp+1Ch] [rbp-14h]
  void *v14; // [rsp+20h] [rbp-10h]
  __int64 v15; // [rsp+28h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_124340, (__int64)"ly_register_exts", a4, a5, a6, a2);
  for ( i = 0; *(_QWORD *)(32LL * i + a1 + 16); ++i )
  {
    for ( j = 0; j < (unsigned __int16)word_347068; ++j )
    {
      if ( !strcmp(*(const char **)(32LL * i + a1 + 16), *((const char **)ptr + 4 * j + 2))
        && !strcmp(*(const char **)(32LL * i + a1), *((const char **)ptr + 4 * j))
        && (!*(_QWORD *)(32LL * i + a1 + 8)
         || !*((_QWORD *)ptr + 4 * j + 1)
         || !strcmp(*(const char **)(32LL * i + a1 + 8), *((const char **)ptr + 4 * j + 1))) )
      {
        if ( *(_QWORD *)(32LL * i + a1 + 8) )
          v6 = *(void **)(32LL * i + a1 + 8);
        else
          v6 = &unk_1243FC;
        if ( *(_QWORD *)(32LL * i + a1 + 8) )
          v7 = "@";
        else
          v7 = (const char *)&unk_1243FC;
        sub_12222(
          0LL,
          0,
          2,
          "Processing \"%s\" extension plugin failed,implementation collision for extension %s from module %s%s%s.",
          v10,
          *(_QWORD *)(32LL * i + a1 + 16),
          *(_QWORD *)(32LL * i + a1),
          v7,
          v6);
        return 1LL;
      }
    }
    if ( **(_DWORD **)(32LL * i + a1 + 24) == 1 && *(_QWORD *)(*(_QWORD *)(32LL * i + a1 + 24) + 40LL) )
    {
      v15 = *(_QWORD *)(32LL * i + a1 + 24);
      for ( k = 0; *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k); ++k )
      {
        if ( *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k) > 55
          || *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k) == 19
          || *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k) == 22 )
        {
          sub_12222(
            0LL,
            0,
            3,
            "Extension plugin \"%s\" (extension %s) allows not supported extension substatement (%s)",
            v10,
            *(_QWORD *)(32LL * i + a1 + 16),
            *(&off_3460E0 + *(signed int *)(*(_QWORD *)(v15 + 40) + 24LL * k)));
          return 1LL;
        }
        if ( *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k + 16) > 1u
          && *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k) > 19
          && *(_DWORD *)(*(_QWORD *)(v15 + 40) + 24LL * k) <= 26 )
        {
          sub_12222(
            0LL,
            0,
            3,
            "Extension plugin \"%s\" (extension %s) allows multiple instances on \"%s\" substatement, which is not supported.",
            v10,
            *(_QWORD *)(32LL * i + a1 + 16),
            *(&off_3460E0 + *(signed int *)(*(_QWORD *)(v15 + 40) + 24LL * k)));
          return 1LL;
        }
      }
    }
  }
  v14 = realloc(ptr, 32LL * ((unsigned __int16)word_347068 + i));
  if ( v14 )
  {
    ptr = v14;
    while ( i )
    {
      memcpy((char *)ptr + 32 * (unsigned __int16)word_347068, (const void *)(32LL * (i - 1) + a1), 0x20uLL);
      ++word_347068;
      --i;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_register_exts", v9);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 124340: using guessed type void *off_124340;
// 3460E0: using guessed type void *off_3460E0;
// 347068: using guessed type __int16 word_347068;

//----- (00000000000C0ED7) ----------------------------------------------------
_QWORD *__fastcall sub_C0ED7(void *a1)
{
  __int64 v1; // r9
  _QWORD *result; // rax

  qword_3470C8 = sub_C422(qword_3470C8, 8LL * ((unsigned __int16)word_3470D0 + 2));
  if ( qword_3470C8 )
  {
    *((_QWORD *)qword_3470C8 + (unsigned __int16)++word_3470D0 - 1) = a1;
    result = (char *)qword_3470C8 + 8 * (unsigned __int16)word_3470D0;
    *result = 0LL;
  }
  else
  {
    free(a1);
    result = (_QWORD *)sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_add_loaded_plugin", v1);
  }
  return result;
}
// 3470D0: using guessed type __int16 word_3470D0;

//----- (00000000000C0FA9) ----------------------------------------------------
unsigned __int64 __fastcall sub_C0FA9(DIR *a1, __int64 a2, int a3)
{
  struct dirent *i; // rax
  __int64 v4; // r9
  char *v5; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  int v10; // [rsp+Ch] [rbp-54h]
  int v11; // [rsp+2Ch] [rbp-34h]
  char *ptr; // [rsp+30h] [rbp-30h]
  struct dirent *v13; // [rsp+38h] [rbp-28h]
  size_t v14; // [rsp+40h] [rbp-20h]
  void *handle; // [rsp+48h] [rbp-18h]
  void *v16; // [rsp+50h] [rbp-10h]
  unsigned __int64 v17; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v17 = __readfsqword(0x28u);
  for ( i = readdir(a1); ; i = readdir(a1) )
  {
    v13 = i;
    if ( !i )
      break;
    v14 = strlen(v13->d_name);
    if ( v14 > 3 && !strcmp((const char *)&v13->d_reclen + v14, ".so") )
    {
      if ( asprintf(&ptr, "%s/%s", a2, v13->d_name) == -1 )
      {
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_load_plugins_dir", v4);
        return __readfsqword(0x28u) ^ v17;
      }
      handle = dlopen(ptr, 2);
      if ( handle )
      {
        if ( (unsigned int)ly_set_contains(&dword_347080, handle) == -1 )
        {
          dlerror();
          v16 = strndup(v13->d_name, v14 - 3);
          if ( !v16 )
          {
            sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_load_plugins_dir", v7);
            dlclose(handle);
            free(ptr);
            return __readfsqword(0x28u) ^ v17;
          }
          if ( v10 )
            v11 = sub_C0875(handle, (const char *)v16);
          else
            v11 = sub_C03C5(handle, (const char *)v16);
          if ( v11 )
          {
            free(v16);
            dlclose(handle);
          }
          else
          {
            sub_12222(0LL, 2u, 0, "Plugin \"%s\" successfully loaded.", (__int64)ptr, v8);
            sub_C0ED7(v16);
            ly_set_add(&dword_347080, handle, 1LL);
          }
          free(ptr);
          if ( v11 == -1 )
            return __readfsqword(0x28u) ^ v17;
        }
        else
        {
          sub_12222(0LL, 2u, 0, "Plugin \"%s\" already loaded.", (__int64)ptr, v6);
          free(ptr);
          dlclose(handle);
        }
      }
      else
      {
        v5 = dlerror();
        sub_12222(0LL, 0, 2, "Loading \"%s\" as a plugin failed (%s).", (__int64)ptr, (__int64)v5);
        free(ptr);
      }
    }
  }
  return __readfsqword(0x28u) ^ v17;
}
// 74C0: using guessed type __int64 __fastcall ly_set_contains(_QWORD, _QWORD);
// 7900: using guessed type __int64 __fastcall ly_set_add(_QWORD, _QWORD, _QWORD);
// 347080: using guessed type int dword_347080;

//----- (00000000000C1282) ----------------------------------------------------
int __fastcall ly_load_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int *v6; // rax
  char *v7; // rax
  int *v8; // rax
  char *v9; // rax
  const char *name; // [rsp+0h] [rbp-10h]
  const char *namea; // [rsp+0h] [rbp-10h]
  DIR *dirp; // [rsp+8h] [rbp-8h]
  DIR *dirpa; // [rsp+8h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_124340, (__int64)"ly_load_plugins", a4, a5, a6);
  pthread_mutex_lock(&mutex);
  ++dword_3470D4;
  name = getenv("LIBYANG_EXTENSIONS_PLUGINS_DIR");
  if ( !name )
    name = "/usr/local/lib/libyang/extensions";
  dirp = opendir(name);
  if ( dirp )
  {
    sub_C0FA9(dirp, (__int64)name, 1);
    closedir(dirp);
  }
  else
  {
    v6 = __errno_location();
    v7 = strerror(*v6);
    sub_12222(
      0LL,
      1u,
      0,
      "Failed to open libyang extensions plugins directory \"%s\" (%s).",
      (__int64)name,
      (__int64)v7,
      name);
  }
  namea = getenv("LIBYANG_USER_TYPES_PLUGINS_DIR");
  if ( !namea )
    namea = "/usr/local/lib/libyang/user_types";
  dirpa = opendir(namea);
  if ( dirpa )
  {
    sub_C0FA9(dirpa, (__int64)namea, 0);
    closedir(dirpa);
  }
  else
  {
    v8 = __errno_location();
    v9 = strerror(*v8);
    sub_12222(
      0LL,
      1u,
      0,
      "Failed to open libyang user types plugins directory \"%s\" (%s).",
      (__int64)namea,
      (__int64)v9,
      namea);
  }
  return pthread_mutex_unlock(&mutex);
}
// 124340: using guessed type void *off_124340;
// 3470D4: using guessed type int dword_3470D4;

//----- (00000000000C1405) ----------------------------------------------------
__int64 __fastcall sub_C1405(const char *a1, const char *a2, char *a3)
{
  char *v4; // [rsp+8h] [rbp-28h]
  unsigned __int16 i; // [rsp+2Eh] [rbp-2h]

  v4 = a3;
  if ( !a1 )
    __assert_fail("name", "/home/mantovan/Repositories/libyang/src/plugins.c", 0x1C8u, "ext_get_plugin");
  if ( !a2 )
    __assert_fail("module", "/home/mantovan/Repositories/libyang/src/plugins.c", 0x1C9u, "ext_get_plugin");
  for ( i = 0; i < (unsigned __int16)word_347068; ++i )
  {
    if ( !strcmp(a1, *((const char **)ptr + 4 * i + 2))
      && !strcmp(a2, *((const char **)ptr + 4 * i))
      && (!*((_QWORD *)ptr + 4 * i + 1) || !strcmp(v4, *((const char **)ptr + 4 * i + 1))) )
    {
      return *((_QWORD *)ptr + 4 * i + 3);
    }
  }
  return 0LL;
}
// 347068: using guessed type __int16 word_347068;

//----- (00000000000C1544) ----------------------------------------------------
signed __int64 __fastcall lys_ext_instance_presence(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  _BYTE *v8; // rbx
  __int64 v9; // rax
  unsigned __int8 v10; // [rsp+Ch] [rbp-34h]
  unsigned __int8 i; // [rsp+2Fh] [rbp-11h]

  v10 = a3;
  sub_12312(0x20u, (__int64)&off_124340, (__int64)"lys_ext_instance_presence", a4, a5, a6);
  if ( a1 && (!v10 || a2) )
  {
    for ( i = 0; i < v10; ++i )
    {
      if ( **(_QWORD **)(*(_QWORD *)(8LL * i + a2) + 48LL) == **(_QWORD **)(a1 + 48) )
      {
        if ( a1 == **(_QWORD **)(8LL * i + a2) )
          return i;
      }
      else if ( (unsigned int)sub_C462(***(_BYTE ****)(8LL * i + a2), *(_BYTE **)a1) )
      {
        v8 = *(_BYTE **)(lys_main_module(*(_QWORD *)(a1 + 48)) + 8);
        v9 = lys_main_module(*(_QWORD *)(**(_QWORD **)(8LL * i + a2) + 48LL));
        if ( (unsigned int)sub_C462(*(_BYTE **)(v9 + 8), v8) )
          return i;
      }
    }
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_ext_instance_presence", v6);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 124340: using guessed type void *off_124340;

//----- (00000000000C16C5) ----------------------------------------------------
signed __int64 __fastcall lys_ext_complex_get_substmt(int a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  _QWORD *v8; // [rsp+8h] [rbp-28h]
  int i; // [rsp+2Ch] [rbp-4h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_124340, (__int64)"lys_ext_complex_get_substmt", a4, a5, a6);
  if ( a2 && *a2 && *(_QWORD *)(*a2 + 56LL) && **(_DWORD **)(*a2 + 56LL) == 1 )
  {
    if ( a2[8] )
    {
      for ( i = 0; *(_DWORD *)(a2[8] + 24LL * i); ++i )
      {
        if ( a1 == -1 )
        {
          if ( *(_DWORD *)(a2[8] + 24LL * i) > 32 && *(_DWORD *)(a2[8] + 24LL * i) <= 46 )
          {
            if ( v8 )
              *v8 = a2[8] + 24LL * i;
            break;
          }
        }
        else if ( a1 == *(_DWORD *)(a2[8] + 24LL * i) )
        {
          if ( v8 )
            *v8 = a2[8] + 24LL * i;
          break;
        }
      }
      if ( *(_DWORD *)(a2[8] + 24LL * i) )
        result = (signed __int64)a2 + *(_QWORD *)(a2[8] + 24LL * i + 8) + 72;
      else
        result = 0LL;
    }
    else
    {
      if ( v8 )
        *v8 = 0LL;
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_ext_complex_get_substmt", v6);
    result = 0LL;
  }
  return result;
}
// 124340: using guessed type void *off_124340;

//----- (00000000000C1906) ----------------------------------------------------
signed __int64 __fastcall sub_C1906(unsigned int a1)
{
  if ( a1 == 128 )
    return 44LL;
  if ( a1 <= 0x80 )
  {
    if ( a1 == 8 )
      return 42LL;
    if ( a1 <= 8 )
    {
      switch ( a1 )
      {
        case 2u:
          return 37LL;
        case 4u:
          return 41LL;
        case 1u:
          return 38LL;
      }
      return 0xFFFFFFFFLL;
    }
    if ( a1 != 32 )
    {
      if ( a1 == 64 )
        return 36LL;
      if ( a1 == 16 )
        return 43LL;
      return 0xFFFFFFFFLL;
    }
    return 34LL;
  }
  if ( a1 == 2048 )
    return 39LL;
  if ( a1 <= 0x800 )
  {
    switch ( a1 )
    {
      case 0x200u:
        return 40LL;
      case 0x400u:
        return 45LL;
      case 0x100u:
        return 57LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( a1 == 0x2000 )
    return 61LL;
  if ( a1 <= 0x2000 )
  {
    if ( a1 == 4096 )
      return 46LL;
    return 0xFFFFFFFFLL;
  }
  if ( a1 == 0x4000 )
    return 33LL;
  if ( a1 == 32800 )
    return 34LL;
  return 0xFFFFFFFFLL;
}

//----- (00000000000C1A2B) ----------------------------------------------------
char *__fastcall sub_C1A2B(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v4; // [rsp+8h] [rbp-28h]
  unsigned __int16 i; // [rsp+2Eh] [rbp-2h]

  v4 = a3;
  for ( i = 0; i < (unsigned __int16)word_347078; ++i )
  {
    if ( (unsigned int)sub_C462(a1, *((_BYTE **)qword_347070 + 5 * i))
      && (!a2 && !*((_QWORD *)qword_347070 + 5 * i + 1)
       || a2 && (unsigned int)sub_C462(a2, *((_BYTE **)qword_347070 + 5 * i + 1)))
      && (unsigned int)sub_C462(v4, *((_BYTE **)qword_347070 + 5 * i + 2)) )
    {
      return (char *)qword_347070 + 40 * i;
    }
  }
  return 0LL;
}
// 347078: using guessed type __int16 word_347078;

//----- (00000000000C1B58) ----------------------------------------------------
signed __int64 __fastcall sub_C1B58(__int64 *a1, _BYTE *a2, _QWORD *a3, __int64 a4)
{
  _BYTE *v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // [rsp+0h] [rbp-40h]
  _QWORD *v9; // [rsp+8h] [rbp-38h]
  char *ptr; // [rsp+28h] [rbp-18h]
  char *v11; // [rsp+30h] [rbp-10h]
  unsigned __int64 v12; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v12 = __readfsqword(0x28u);
  ptr = 0LL;
  if ( !a1 || !a2 || !a3 || !a4 )
    __assert_fail(
      "mod && type_name && value_str && value",
      "/home/mantovan/Repositories/libyang/src/plugins.c",
      0x262u,
      "lytype_store");
  if ( *((_BYTE *)a1 + 68) )
    v4 = (_BYTE *)a1[11];
  else
    v4 = 0LL;
  v11 = sub_C1A2B((_BYTE *)a1[1], v4, a2);
  if ( !v11 )
    return 1LL;
  if ( !(*((unsigned int (__fastcall **)(__int64, _BYTE *, _QWORD *, __int64, char **))v11 + 3))(*a1, a2, v9, v8, &ptr) )
    return 0LL;
  if ( ptr || asprintf(&ptr, "Failed to store value \"%s\" of user type \"%s\".", *v9, a2) != -1 )
  {
    sub_12222(*a1, 0, 6, ptr, v5, v6, v8);
    free(ptr);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lytype_store", v6, v8);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000000C1CED) ----------------------------------------------------
unsigned __int64 __fastcall sub_C1CED(signed __int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 v6; // rdx
  _BYTE *v7; // rcx
  _BYTE *v8; // rsi
  __int64 v10; // [rsp+8h] [rbp-158h]
  __int64 v11; // [rsp+10h] [rbp-150h]
  signed __int64 v12; // [rsp+18h] [rbp-148h]
  __int64 v13; // [rsp+20h] [rbp-140h]
  char *v14; // [rsp+28h] [rbp-138h]
  const char **v15; // [rsp+30h] [rbp-130h]
  __int64 v16; // [rsp+68h] [rbp-F8h]
  __int64 v17; // [rsp+70h] [rbp-F0h]
  const char *s; // [rsp+80h] [rbp-E0h]
  __int64 *v19; // [rsp+B0h] [rbp-B0h]
  int v20; // [rsp+B8h] [rbp-A8h]
  __int64 v21; // [rsp+100h] [rbp-60h]
  __int64 v22; // [rsp+108h] [rbp-58h]
  __int64 v23; // [rsp+110h] [rbp-50h]
  __int64 v24; // [rsp+118h] [rbp-48h]
  __int64 v25; // [rsp+120h] [rbp-40h]
  __int64 v26; // [rsp+128h] [rbp-38h]
  __int64 v27; // [rsp+130h] [rbp-30h]
  __int64 v28; // [rsp+138h] [rbp-28h]
  unsigned __int64 v29; // [rsp+158h] [rbp-8h]

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v29 = __readfsqword(0x28u);
  memset(&s, 0, 0xD0uLL);
  memset(&v15, 0, 0x50uLL);
  while ( *(_DWORD *)v12 == 9 )
    v12 = *(_QWORD *)(v12 + 40) + 128LL;
  if ( *(_DWORD *)v12 != 11 )
    goto LABEL_19;
  v19 = *(__int64 **)(*(_QWORD *)(v12 + 24) + 48LL);
  s = "fake-leaf";
  v3 = *(_QWORD *)(v12 + 8);
  v21 = *(_QWORD *)v12;
  v22 = v3;
  v4 = *(_QWORD *)(v12 + 24);
  v23 = *(_QWORD *)(v12 + 16);
  v24 = v4;
  v5 = *(_QWORD *)(v12 + 40);
  v25 = *(_QWORD *)(v12 + 32);
  v26 = v5;
  v6 = *(_QWORD *)(v12 + 56);
  v27 = *(_QWORD *)(v12 + 48);
  v28 = v6;
  v20 = 4;
  v15 = &s;
  v17 = a2;
  v16 = v10;
  v12 = lyd_leaf_type(&v15, 0LL);
  if ( v12 )
  {
LABEL_19:
    v13 = *(_QWORD *)(*(_QWORD *)(v12 + 16) + 48LL);
    if ( v13 )
    {
      if ( *(_BYTE *)(v13 + 68) )
        v7 = *(_BYTE **)(v13 + 88);
      else
        v7 = 0LL;
      v8 = v7;
      v14 = sub_C1A2B(*(_BYTE **)(v13 + 8), v7, **(_BYTE ***)(v12 + 16));
      if ( v14 )
      {
        if ( *((_QWORD *)v14 + 4) )
          (*((void (__fastcall **)(__int64, _BYTE *))v14 + 4))(v11, v8);
      }
      else
      {
        sub_12222(
          *(_QWORD *)v13,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/plugins.c",
          675LL);
      }
    }
    else
    {
      sub_12222(
        **(_QWORD **)(*(_QWORD *)(v12 + 24) + 48LL),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/plugins.c",
        669LL);
    }
  }
  else
  {
    sub_12222(
      *v19,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/plugins.c",
      662LL);
  }
  return __readfsqword(0x28u) ^ v29;
}
// 7210: using guessed type __int64 __fastcall lyd_leaf_type(_QWORD, _QWORD);

//----- (00000000000C1FAD) ----------------------------------------------------
_BOOL8 __fastcall sub_C1FAD(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rbx

  v2 = lys_node_module(*a1);
  return v2 != lys_node_module(*a2);
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000C1FF7) ----------------------------------------------------
signed __int64 sub_C1FF7(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  unsigned int v6; // eax
  __int64 v7; // r9
  int v9; // eax
  int v10; // [rsp+1Ch] [rbp-E4h]
  char *ptr; // [rsp+20h] [rbp-E0h]
  void *v12; // [rsp+28h] [rbp-D8h]
  gcc_va_list arg; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v14; // [rsp+48h] [rbp-B8h]
  __int64 v15; // [rsp+60h] [rbp-A0h]
  __int64 v16; // [rsp+68h] [rbp-98h]
  __int64 v17; // [rsp+70h] [rbp-90h]
  __int64 v18; // [rsp+78h] [rbp-88h]

  va_start(arg, a6);
  v15 = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v14 = __readfsqword(0x28u);
  v10 = 0;
  ptr = 0LL;
  arg[0].gp_offset = 16;
  v6 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 1 )
  {
    v10 = vfprintf(*(FILE **)(a1 + 8), a2, arg);
  }
  else if ( v6 < 1 )
  {
    v10 = vdprintf(*(_DWORD *)(a1 + 8), a2, arg);
  }
  else if ( v6 == 2 )
  {
    v10 = vasprintf(&ptr, a2, arg);
    if ( (unsigned __int64)(*(_QWORD *)(a1 + 16) + v10 + 1LL) > *(_QWORD *)(a1 + 24) )
    {
      v12 = sub_C422(*(void **)(a1 + 8), *(_QWORD *)(a1 + 16) + v10 + 1LL);
      if ( !v12 )
      {
        *(_QWORD *)(a1 + 8) = 0LL;
        *(_QWORD *)(a1 + 16) = 0LL;
        *(_QWORD *)(a1 + 24) = 0LL;
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_print", v7, a2);
        return 0xFFFFFFFFLL;
      }
      *(_QWORD *)(a1 + 8) = v12;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + v10 + 1LL;
    }
    memcpy((void *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)), ptr, v10);
    *(_QWORD *)(a1 + 16) += v10;
    *(_BYTE *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)) = 0;
    free(ptr);
  }
  else if ( v6 == 3 )
  {
    v9 = vasprintf(&ptr, a2, arg);
    v10 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16), ptr, v9);
    if ( v10 >= 0 )
      *__errno_location() = 0;
    free(ptr);
  }
  return (unsigned int)v10;
}

//----- (00000000000C236C) ----------------------------------------------------
int __fastcall sub_C236C(__int64 a1)
{
  int result; // eax

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 1 )
    result = fflush(*(FILE **)(a1 + 8));
  return result;
}

//----- (00000000000C23A5) ----------------------------------------------------
__int64 __fastcall sub_C23A5(__int64 a1, const void *a2, size_t a3)
{
  __int64 v3; // r9
  __int64 result; // rax
  unsigned int v5; // eax
  __int64 v6; // r9
  size_t n; // [rsp+8h] [rbp-18h]

  n = a3;
  if ( *(_QWORD *)(a1 + 56) )
  {
    if ( a3 + *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 48) )
    {
      *(_QWORD *)(a1 + 32) = sub_C422(*(void **)(a1 + 32), a3 + *(_QWORD *)(a1 + 40));
      if ( !*(_QWORD *)(a1 + 32) )
      {
        *(_QWORD *)(a1 + 40) = 0LL;
        *(_QWORD *)(a1 + 48) = 0LL;
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_write", v3);
        return 0xFFFFFFFFLL;
      }
      *(_QWORD *)(a1 + 48) = n + *(_QWORD *)(a1 + 40);
    }
    memcpy((void *)(*(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40)), a2, n);
    *(_QWORD *)(a1 + 40) += n;
    result = n;
  }
  else
  {
    v5 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1 )
    {
      result = fwrite(a2, 1uLL, a3, *(FILE **)(a1 + 8));
    }
    else if ( v5 < 1 )
    {
      result = write(*(_DWORD *)(a1 + 8), a2, a3);
    }
    else if ( v5 == 2 )
    {
      if ( *(_QWORD *)(a1 + 16) + a3 + 1 > *(_QWORD *)(a1 + 24) )
      {
        *(_QWORD *)(a1 + 8) = sub_C422(*(void **)(a1 + 8), *(_QWORD *)(a1 + 16) + a3 + 1);
        if ( !*(_QWORD *)(a1 + 8) )
        {
          *(_QWORD *)(a1 + 16) = 0LL;
          *(_QWORD *)(a1 + 24) = 0LL;
          sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_write", v6);
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + n + 1;
      }
      memcpy((void *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)), a2, n);
      *(_QWORD *)(a1 + 16) += n;
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)) = 0;
      result = n;
    }
    else if ( v5 == 3 )
    {
      result = (*(__int64 (__fastcall **)(_QWORD, const void *, size_t))(a1 + 8))(*(_QWORD *)(a1 + 16), a2, a3);
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000C2676) ----------------------------------------------------
signed __int64 __fastcall sub_C2676(__int64 a1, __int64 a2, _QWORD *a3)
{
  unsigned int v3; // eax
  __int64 v4; // r9
  __int64 v6; // r9
  _QWORD *v7; // [rsp+8h] [rbp-18h]

  v7 = a3;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 2 )
  {
    if ( (unsigned __int64)(a2 + *(_QWORD *)(a1 + 16)) > *(_QWORD *)(a1 + 24) )
    {
      *(_QWORD *)(a1 + 8) = sub_C422(*(void **)(a1 + 8), a2 + *(_QWORD *)(a1 + 16));
      if ( !*(_QWORD *)(a1 + 8) )
      {
        *(_QWORD *)(a1 + 16) = 0LL;
        *(_QWORD *)(a1 + 24) = 0LL;
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_write_skip", v4);
        return 0xFFFFFFFFLL;
      }
      *(_QWORD *)(a1 + 24) = a2 + *(_QWORD *)(a1 + 16);
    }
    *v7 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) += a2;
  }
  else if ( v3 < 2 || v3 == 3 )
  {
    if ( (unsigned __int64)(a2 + *(_QWORD *)(a1 + 40)) > *(_QWORD *)(a1 + 48) )
    {
      *(_QWORD *)(a1 + 32) = sub_C422(*(void **)(a1 + 32), a2 + *(_QWORD *)(a1 + 40));
      if ( !*(_QWORD *)(a1 + 32) )
      {
        *(_QWORD *)(a1 + 40) = 0LL;
        *(_QWORD *)(a1 + 48) = 0LL;
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_write_skip", v6);
        return 0xFFFFFFFFLL;
      }
      *(_QWORD *)(a1 + 48) = a2 + *(_QWORD *)(a1 + 40);
    }
    *v7 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 40) += a2;
    ++*(_QWORD *)(a1 + 56);
  }
  return a2;
}

//----- (00000000000C2888) ----------------------------------------------------
signed __int64 __fastcall sub_C2888(__int64 a1, __int64 a2, const void *a3, size_t a4)
{
  unsigned int v4; // eax
  size_t n; // [rsp+0h] [rbp-20h]

  n = a4;
  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 2 )
  {
    memcpy((void *)(*(_QWORD *)(a1 + 8) + a2), a3, a4);
  }
  else if ( v4 < 2 || v4 == 3 )
  {
    if ( *(_QWORD *)(a1 + 40) < a2 + a4 )
    {
      sub_12222(
        0LL,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer.c",
        272LL,
        a4);
      return 0xFFFFFFFFLL;
    }
    memcpy((void *)(*(_QWORD *)(a1 + 32) + a2), a3, a4);
    if ( !--*(_QWORD *)(a1 + 56) )
    {
      n = (signed int)sub_C23A5(a1, *(const void **)(a1 + 32), *(_QWORD *)(a1 + 40));
      *(_QWORD *)(a1 + 40) = 0LL;
    }
  }
  return n;
}

//----- (00000000000C29AA) ----------------------------------------------------
__int64 __fastcall sub_C29AA(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, int *a5, signed int *a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rbx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rax
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r9
  void *v28; // rcx
  const char *v29; // rax
  const char *v30; // rsi
  _DWORD *v31; // ST00_8
  int v32; // ST40_4
  __int64 v33; // ST00_8
  __int64 v34; // r8
  __int64 v35; // r9
  const char *v36; // rax
  int v37; // ST40_4
  __int64 v38; // ST00_8
  __int64 v39; // rdx
  __int64 v40; // rcx
  __int64 v41; // r8
  __int64 v42; // r9
  signed int *v44; // [rsp+0h] [rbp-60h]
  int *v45; // [rsp+8h] [rbp-58h]
  unsigned int v46; // [rsp+14h] [rbp-4Ch]
  __int64 *v47; // [rsp+18h] [rbp-48h]
  _BYTE v48[5]; // [rsp+3Fh] [rbp-21h]
  int v49; // [rsp+40h] [rbp-20h]
  int v50; // [rsp+44h] [rbp-1Ch]
  __int64 v51; // [rsp+48h] [rbp-18h]

  v47 = a3;
  v46 = a4;
  v45 = a5;
  v44 = a6;
  v48[4] = 0;
  v50 = *a5;
  *(_DWORD *)v48 = (unsigned __int8)sub_18F95(*a3, *a5);
  v9 = (unsigned int)(*v45 + 1);
  *v45 = v9;
  if ( v48[0] == 1 )
  {
    if ( v50 && (*v45 <= 1 || (unsigned __int8)sub_18F95(*v47, *v45 - 2)) )
      v50 = 0;
  }
  else
  {
    if ( (signed int)v48[0] <= 1 )
    {
      if ( !v48[0] )
      {
        v32 = (unsigned __int64)sub_C1FF7(a1, "not ", v9, v6, v7, v8, v44) + *(_DWORD *)&v48[1];
        *(_DWORD *)&v48[1] = (unsigned __int64)sub_C29AA(a1, a2, v47, v46, v45, v33) + v32;
      }
      return *(unsigned int *)&v48[1];
    }
    if ( v48[0] != 2 )
    {
      if ( v48[0] == 3 )
      {
        v10 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v47[2] + 8LL * *v44) + 48LL));
        if ( v10 != lys_main_module(a2) )
        {
          if ( v46 )
          {
            switch ( v46 )
            {
              case 1u:
                v19 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v47[2] + 8LL * *v44) + 48LL));
                *(_DWORD *)&v48[1] += sub_C1FF7(a1, "%s:", *(_QWORD *)(v19 + 8), v20, v21, v22, v44);
                break;
              case 2u:
                v23 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v47[2] + 8LL * *v44) + 48LL));
                *(_DWORD *)&v48[1] += sub_C1FF7(a1, "%s:", *(_QWORD *)(v23 + 16), v24, v25, v26, v44);
                break;
              case 3u:
                v51 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v47[2] + 8LL * *v44) + 48LL));
                if ( *(_BYTE *)(v51 + 68) )
                  v28 = *(void **)(v51 + 88);
                else
                  v28 = &unk_124B7E;
                if ( *(_BYTE *)(v51 + 68) )
                  v29 = "@";
                else
                  v29 = (const char *)&unk_124B7E;
                *(_DWORD *)&v48[1] += sub_C1FF7(
                                        a1,
                                        "%s%s%s:",
                                        *(_QWORD *)(v51 + 8),
                                        (__int64)v29,
                                        (__int64)v28,
                                        v27,
                                        v44);
                break;
            }
          }
          else
          {
            v14 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v47[2] + 8LL * *v44) + 48LL));
            v15 = sub_831C(a2, *(const char **)(v14 + 8));
            *(_DWORD *)&v48[1] += sub_C1FF7(a1, "%s:", v15, v16, v17, v18, v44);
          }
        }
        v30 = **(const char ***)(v47[2] + 8LL * *v44);
        *(_DWORD *)&v48[1] += sub_C1FF7(a1, v30, (__int64)v30, v11, v12, v13, v44);
        ++*v31;
      }
      return *(unsigned int *)&v48[1];
    }
  }
  if ( v50 )
    *(_DWORD *)&v48[1] += sub_C1FF7(a1, "(", v9, v6, v7, v8, v44);
  v49 = (unsigned __int64)sub_C29AA(a1, a2, v47, v46, v45, v44) + *(_DWORD *)&v48[1];
  if ( v48[0] == 2 )
    v36 = "or";
  else
    v36 = "and";
  v37 = (unsigned __int64)sub_C1FF7(a1, " %s ", (__int64)v36, a1, v34, v35, v44) + v49;
  *(_DWORD *)&v48[1] = (unsigned __int64)sub_C29AA(a1, a2, v47, v46, v45, v38) + v37;
  if ( v50 )
    *(_DWORD *)&v48[1] += sub_C1FF7(a1, ")", v39, v40, v41, v42);
  return *(unsigned int *)&v48[1];
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000C2DA0) ----------------------------------------------------
__int64 __fastcall sub_C2DA0(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4)
{
  __int64 result; // rax
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  v5 = 0;
  v6 = 0;
  if ( *a3 )
    result = sub_C29AA(a1, a2, a3, a4, &v5, &v6);
  else
    result = 0LL;
  return result;
}

//----- (00000000000C2E22) ----------------------------------------------------
__int64 __fastcall sub_C2E22(_QWORD *a1, __int64 *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v10; // [rsp+3Ch] [rbp-4h]

  switch ( (unsigned __int64)a3 )
  {
    case 1uLL:
      sub_A8D1D((__int64)a2);
      v10 = sub_E5C7A((__int64)a1, (__int64)a2);
      sub_A8A9A((__int64)a2);
      break;
    case 2uLL:
      sub_A8D1D((__int64)a2);
      v10 = sub_F08B1((__int64)a1, (__int64)a2, (__int64)a2, v6, v7, v8);
      sub_A8A9A((__int64)a2);
      break;
    case 3uLL:
      v10 = sub_FDED1(a1, a2, (__int64)a4, a5, a6);
      break;
    case 4uLL:
      v10 = sub_102BC6((__int64)a1, (__int64)a2, a4, (__int64)a2, a5, a6);
      break;
    case 5uLL:
      v10 = sub_F97D5((__int64)a1, (__int64)a2, (__int64)a4, (__int64)a2, a5, a6);
      break;
    default:
      sub_12222(*a2, 0, 3, "Unknown output format.", a5, a6);
      v10 = 1;
      break;
  }
  return v10;
}

//----- (00000000000C2F61) ----------------------------------------------------
__int64 __fastcall lys_print_file(__int64 a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6)
{
  __int64 result; // rax
  unsigned int v7; // [rsp+Ch] [rbp-74h]
  const char *v8; // [rsp+10h] [rbp-70h]
  unsigned int v9; // [rsp+18h] [rbp-68h]
  unsigned int v10; // [rsp+1Ch] [rbp-64h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v12; // [rsp+38h] [rbp-48h]
  unsigned __int64 v13; // [rsp+78h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  v13 = __readfsqword(0x28u);
  if ( a1 && a2 )
  {
    memset(&s, 0, 0x40uLL);
    s = 1;
    v12 = a1;
    result = sub_C2E22(&s, a2, v10, v8, v9, v7);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_print_file", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C302A) ----------------------------------------------------
signed __int64 __fastcall lys_print_path(const char *a1, __int64 *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6)
{
  signed __int64 result; // rax
  int *v7; // rax
  char *v8; // rax
  unsigned int v9; // ST34_4
  unsigned int v10; // [rsp+Ch] [rbp-34h]
  __int64 v11; // [rsp+10h] [rbp-30h]
  unsigned int v12; // [rsp+18h] [rbp-28h]
  unsigned int v13; // [rsp+1Ch] [rbp-24h]
  FILE *stream; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a4;
  v12 = a5;
  v10 = a6;
  if ( a1 && a2 )
  {
    stream = fopen(a1, "w");
    if ( stream )
    {
      v9 = lys_print_file(stream, a2, v13, v11, v12, v10);
      fclose(stream);
      result = v9;
    }
    else
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      sub_12222(*a2, 0, 2, "Failed to open file \"%s\" (%s).", (__int64)a1, (__int64)v8);
      result = 1LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_print_path", a6);
    result = 1LL;
  }
  return result;
}
// 7A80: using guessed type __int64 __fastcall lys_print_file(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000C3125) ----------------------------------------------------
__int64 __fastcall lys_print_fd(int a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6)
{
  __int64 result; // rax
  unsigned __int64 v7; // [rsp+0h] [rbp-70h]
  const char *v8; // [rsp+8h] [rbp-68h]
  unsigned int v9; // [rsp+18h] [rbp-58h]
  int s; // [rsp+20h] [rbp-50h]
  int v11; // [rsp+28h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = __PAIR__(a5, (unsigned int)a6);
  v12 = __readfsqword(0x28u);
  if ( a1 >= 0 && a2 )
  {
    memset(&s, 0, 0x40uLL);
    s = 0;
    v11 = a1;
    result = sub_C2E22(&s, a2, v9, v8, HIDWORD(v7), (unsigned int)v7);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_print_fd", a6, __PAIR__(a5, (unsigned int)a6), a4);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C31EA) ----------------------------------------------------
signed __int64 __fastcall lys_print_mem(_QWORD *a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6)
{
  signed __int64 result; // rax
  unsigned int v7; // [rsp+Ch] [rbp-84h]
  const char *v8; // [rsp+10h] [rbp-80h]
  unsigned int v9; // [rsp+18h] [rbp-78h]
  unsigned int v10; // [rsp+1Ch] [rbp-74h]
  int s; // [rsp+40h] [rbp-50h]
  __int64 v12; // [rsp+48h] [rbp-48h]
  unsigned __int64 v13; // [rsp+88h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  v13 = __readfsqword(0x28u);
  if ( a1 && a2 )
  {
    memset(&s, 0, 0x40uLL);
    s = 2;
    LODWORD(result) = sub_C2E22(&s, a2, v10, v8, v9, v7);
    *a1 = v12;
    result = (unsigned int)result;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_print_mem", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C32C5) ----------------------------------------------------
__int64 __fastcall lys_print_clb(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, const char *a5, __int64 a6, unsigned int a7)
{
  __int64 result; // rax
  const char *v8; // [rsp+8h] [rbp-78h]
  unsigned int v9; // [rsp+10h] [rbp-70h]
  unsigned int v10; // [rsp+14h] [rbp-6Ch]
  __int64 *v11; // [rsp+18h] [rbp-68h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  unsigned __int64 v15; // [rsp+78h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v8 = a5;
  v9 = a6;
  v15 = __readfsqword(0x28u);
  if ( a1 && a3 )
  {
    memset(&s, 0, 0x40uLL);
    s = 3;
    v13 = a1;
    v14 = a2;
    result = sub_C2E22(&s, v11, v10, v8, v9, a7);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_print_clb", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C3393) ----------------------------------------------------
signed __int64 __fastcall sub_C3393(__int64 a1, __int64 a2, const char *a3, void (__fastcall *a4)(__int64, signed __int64, int *), void (__fastcall *a5)(__int64, signed __int64, int *), void (__fastcall *a6)(__int64, signed __int64, int *), void (__fastcall *a7)(__int64, __int64, int *), void (__fastcall *a8)(__int64, __int64, int *), void (__fastcall *a9)(__int64, __int64, int *), void (__fastcall *a10)(__int64, __int64, int *), void (__fastcall *a11)(__int64, __int64, int *), void (__fastcall *a12)(__int64, __int64, int *), void (__fastcall *a13)(__int64, __int64, int *), void (__fastcall *a14)(__int64, __int64, int *), void (__fastcall *a15)(__int64, __int64, int *), void (__fastcall *a16)(__int64, __int64, int *), void (__fastcall *a17)(__int64, __int64, int *), void (__fastcall *a18)(__int64, __int64, int *), void (__fastcall *a19)(__int64, __int64, int *), void (__fastcall *a20)(__int64, __int64, int *))
{
  const char *v20; // rax
  __int64 v21; // r9
  __int64 v22; // rax
  signed __int64 result; // rax
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  unsigned int v30; // eax
  __int64 v31; // rcx
  __int64 v32; // r8
  __int64 v33; // r9
  __int64 v34; // rdx
  __int64 v35; // rcx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // r8
  __int64 v39; // r9
  __int64 v40; // r8
  __int64 v41; // r9
  unsigned int v42; // eax
  const char *v43; // rax
  __int64 v44; // rcx
  __int64 v45; // r8
  __int64 v46; // r9
  void (__fastcall *v47)(__int64, signed __int64, int *); // [rsp+70h] [rbp-60h]
  void (__fastcall *v48)(__int64, signed __int64, int *); // [rsp+78h] [rbp-58h]
  void (__fastcall *v49)(__int64, signed __int64, int *); // [rsp+80h] [rbp-50h]
  char *s1; // [rsp+88h] [rbp-48h]
  char *s1a; // [rsp+88h] [rbp-48h]
  char *s1b; // [rsp+88h] [rbp-48h]
  unsigned __int8 v53; // [rsp+A3h] [rbp-2Dh]
  int v54; // [rsp+A4h] [rbp-2Ch]
  int v55; // [rsp+A8h] [rbp-28h]
  int i; // [rsp+ACh] [rbp-24h]
  __int64 v57; // [rsp+B0h] [rbp-20h]
  char *s2; // [rsp+B8h] [rbp-18h]
  __int64 v59; // [rsp+C0h] [rbp-10h]
  unsigned __int64 v60; // [rsp+C8h] [rbp-8h]

  s1 = (char *)a3;
  v49 = a4;
  v48 = a5;
  v47 = a6;
  v60 = __readfsqword(0x28u);
  v54 = 1;
  s2 = 0LL;
  v57 = 0LL;
  v59 = 0LL;
  v53 = 0;
  if ( *a3 == 47 || !strncmp(a3, "type/", 5uLL) )
  {
    if ( *s1 == 47 )
      v20 = s1;
    else
      v20 = s1 + 4;
    v55 = sub_1B39D(v20, (__int64 *)a2, 51199, &v57);
    if ( v55 || !v57 )
    {
      if ( *s1 == 47 )
        v22 = (__int64)s1;
      else
        v22 = (__int64)(s1 + 4);
      sub_12222(*(_QWORD *)a2, 0, 3, "Target %s could not be resolved.", v22, v21, a20);
      return 1LL;
    }
LABEL_66:
    if ( !strncmp(s1, "type/", 5uLL) )
    {
      if ( *(_DWORD *)(v57 + 56) & 0xC )
      {
        a7(a1, v57 + 128, &v54);
        result = 0LL;
      }
      else
      {
        sub_12222(*(_QWORD *)a2, 0, 3, "Target is not a leaf or a leaf-list.", v38, v39, a20);
        result = 1LL;
      }
      return result;
    }
    if ( !strncmp(s1, "grouping/", 9uLL) && !s2 )
    {
      a8(a1, v57, &v54);
      return 0LL;
    }
    if ( s2 )
    {
      v55 = sub_1AF63(s2, *(_QWORD *)(v57 + 72), 32895, 0, &v57);
      if ( v55 || !v57 )
      {
        sub_C1FF7(a1, "Grouping %s child \"%s\" not found.\n", (__int64)(s1 + 9), (__int64)s2, v40, v41, a20);
        return 1LL;
      }
      *--s2 = 47;
    }
    v42 = *(_DWORD *)(v57 + 56);
    if ( v42 == 64 )
    {
      a15(a1, v57, &v54);
      return 0LL;
    }
    if ( v42 > 0x40 )
    {
      if ( v42 == 512 )
      {
        a19(a1, v57, &v54);
        return 0LL;
      }
      if ( v42 <= 0x200 )
      {
        if ( v42 == 128 )
        {
          a16(a1, v57, &v54);
        }
        else
        {
          if ( v42 != 256 )
            goto LABEL_110;
          a17(a1, v57, &v54);
        }
        return 0LL;
      }
      if ( v42 == 0x4000 )
      {
        a18(a1, v57, &v54);
        return 0LL;
      }
      if ( v42 != 32800 )
      {
        if ( v42 != 1024 )
          goto LABEL_110;
        a20(a1, v57, &v54);
        return 0LL;
      }
    }
    else
    {
      if ( v42 == 4 )
      {
        a11(a1, v57, &v54);
        return 0LL;
      }
      if ( v42 <= 4 )
      {
        if ( v42 == 1 )
        {
          a9(a1, v57, &v54);
        }
        else
        {
          if ( v42 != 2 )
          {
LABEL_110:
            v43 = sub_8164(*(_DWORD *)(v57 + 56));
            sub_C1FF7(a1, "Nodetype %s not supported.\n", (__int64)v43, v44, v45, v46, a20);
            return 0LL;
          }
          a10(a1, v57, &v54);
        }
        return 0LL;
      }
      if ( v42 == 16 )
      {
        a13(a1, v57, &v54);
        return 0LL;
      }
      if ( v42 != 32 )
      {
        if ( v42 != 8 )
          goto LABEL_110;
        a12(a1, v57, &v54);
        return 0LL;
      }
    }
    a14(a1, v57, &v54);
    return 0LL;
  }
  if ( !strncmp(s1, "grouping/", 9uLL) )
  {
    s2 = strchr(s1 + 9, 47);
    if ( s2 )
      *s2++ = 0;
    v55 = sub_1B39D(s1 + 8, (__int64 *)a2, 2048, &v57);
    if ( v55 || !v57 )
    {
      sub_C1FF7(a1, "Grouping %s not found.\n", (__int64)(s1 + 8), v24, v25, v26, a20);
      return 1LL;
    }
    goto LABEL_66;
  }
  if ( !strncmp(s1, "typedef/", 8uLL) )
  {
    s2 = strrchr(s1 + 8, 47);
    if ( s2 )
    {
      *s2++ = 0;
      v55 = sub_1B39D(s1 + 7, (__int64 *)a2, 16785, &v57);
      if ( v55 || !v57 )
        v55 = sub_1B39D(s1 + 7, (__int64 *)a2, 2048, &v57);
      if ( !v55 && v57 )
      {
        v30 = *(_DWORD *)(v57 + 56);
        if ( v30 == 128 )
        {
          v59 = *(_QWORD *)(v57 + 112);
          v53 = *(_WORD *)(v57 + 30);
        }
        else if ( v30 > 0x80 )
        {
          if ( v30 == 2048 )
          {
            v59 = *(_QWORD *)(v57 + 104);
            v53 = *(_WORD *)(v57 + 30);
          }
          else
          {
            if ( v30 != 0x4000 && v30 != 256 )
              goto LABEL_39;
            v59 = *(_QWORD *)(v57 + 112);
            v53 = *(_WORD *)(v57 + 30);
          }
        }
        else if ( v30 == 1 )
        {
          v59 = *(_QWORD *)(v57 + 128);
          v53 = *(_WORD *)(v57 + 30);
        }
        else
        {
          if ( v30 != 16 )
          {
LABEL_39:
            sub_12222(
              *(_QWORD *)a2,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/printer.c",
              584LL,
              a20);
            return 1LL;
          }
          v59 = *(_QWORD *)(v57 + 128);
          v53 = *(_BYTE *)(v57 + 29);
        }
      }
    }
    else
    {
      s2 = s1 + 8;
      v59 = *(_QWORD *)(a2 + 112);
      v53 = *(_WORD *)(a2 + 74);
    }
    for ( i = 0; i < v53; ++i )
    {
      if ( !strcmp(*(const char **)(((signed __int64)i << 7) + v59), s2) )
      {
        v49(a1, ((signed __int64)i << 7) + v59, &v54);
        break;
      }
    }
    *--s2 = 47;
    if ( i == v53 )
    {
      sub_C1FF7(a1, "Typedef %s not found.\n", (__int64)s1, v27, v28, v29, a20);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else if ( !strncmp(s1, "identity/", 9uLL) )
  {
    s1a = s1 + 9;
    for ( i = 0; i < *(unsigned __int16 *)(a2 + 72) && strcmp(*(const char **)(*(_QWORD *)(a2 + 120) + 72LL * i), s1a); ++i )
      ;
    if ( i == *(unsigned __int16 *)(a2 + 72) )
    {
      sub_C1FF7(a1, "Identity %s not found.\n", (__int64)s1a, v31, v32, v33, a20);
      result = 1LL;
    }
    else
    {
      v48(a1, *(_QWORD *)(a2 + 120) + 72LL * i, &v54);
      result = 0LL;
    }
  }
  else if ( !strncmp(s1, "feature/", 8uLL) )
  {
    s1b = s1 + 8;
    for ( i = 0;
          i < *(unsigned __int8 *)(a2 + 76)
       && strcmp(*(const char **)(((signed __int64)i << 6) + *(_QWORD *)(a2 + 128)), s1b);
          ++i )
    {
      ;
    }
    if ( i == *(unsigned __int8 *)(a2 + 76) )
    {
      sub_C1FF7(a1, "Feature %s not found.\n", (__int64)s1b, v35, v36, v37, a20);
      result = 1LL;
    }
    else
    {
      v47(a1, *(_QWORD *)(a2 + 128) + ((signed __int64)i << 6), &v54);
      result = 0LL;
    }
  }
  else
  {
    sub_C1FF7(a1, "Target could not be resolved.\n", v34, v35, v36, v37, a20);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C3DD9) ----------------------------------------------------
signed __int64 __fastcall sub_C3DD9(_DWORD *a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6)
{
  switch ( a3 )
  {
    case 2:
      return sub_104C16((__int64)a1, a2, a4);
    case 3:
      return sub_1078FB((__int64)a1, a2, a4);
    case 1:
      return sub_FB855(a1, a2, a4);
  }
  sub_12222(**(_QWORD **)(*a2 + 48), 0, 3, "Unknown output format.", a5, a6);
  return 1LL;
}

//----- (00000000000C3E7C) ----------------------------------------------------
signed __int64 __fastcall lyd_print_file(__int64 a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // ST2C_4
  char v10; // [rsp+8h] [rbp-78h]
  int v11; // [rsp+Ch] [rbp-74h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  void *ptr; // [rsp+50h] [rbp-30h]
  unsigned __int64 v15; // [rsp+78h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v15 = __readfsqword(0x28u);
  if ( a1 )
  {
    memset(&s, 0, 0x40uLL);
    s = 1;
    v13 = a1;
    v9 = sub_C3DD9(&s, a2, v11, v10, v7, v8);
    free(ptr);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_print_file", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C3F39) ----------------------------------------------------
signed __int64 __fastcall lyd_print_path(const char *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r9
  unsigned int v8; // ST24_4
  unsigned int v9; // [rsp+8h] [rbp-28h]
  unsigned int v10; // [rsp+Ch] [rbp-24h]
  FILE *stream; // [rsp+28h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  if ( a1 )
  {
    stream = fopen(a1, "w");
    if ( stream )
    {
      v8 = lyd_print_file(stream, a2, v10, v9);
      fclose(stream);
      result = v8;
    }
    else
    {
      sub_12222(**(_QWORD **)(*(_QWORD *)a2 + 48LL), 0, 3, "Cannot open file \"%s\" for writing.", (__int64)a1, v7);
      result = 1LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_print_path", a6);
    result = 1LL;
  }
  return result;
}
// 79F0: using guessed type __int64 __fastcall lyd_print_file(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000C4009) ----------------------------------------------------
signed __int64 __fastcall lyd_print_fd(int a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // ST2C_4
  char v10; // [rsp+Ch] [rbp-74h]
  int v11; // [rsp+18h] [rbp-68h]
  int s; // [rsp+30h] [rbp-50h]
  int v13; // [rsp+38h] [rbp-48h]
  void *ptr; // [rsp+50h] [rbp-30h]
  unsigned __int64 v15; // [rsp+78h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v15 = __readfsqword(0x28u);
  if ( a1 >= 0 )
  {
    memset(&s, 0, 0x40uLL);
    s = 0;
    v13 = a1;
    v9 = sub_C3DD9(&s, a2, v11, v10, v7, v8);
    free(ptr);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_print_fd", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C40C2) ----------------------------------------------------
signed __int64 __fastcall lyd_print_mem(_QWORD *a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // ST2C_4
  char v10; // [rsp+8h] [rbp-78h]
  int v11; // [rsp+Ch] [rbp-74h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  void *ptr; // [rsp+50h] [rbp-30h]
  unsigned __int64 v15; // [rsp+78h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v15 = __readfsqword(0x28u);
  if ( a1 )
  {
    memset(&s, 0, 0x40uLL);
    s = 2;
    v9 = sub_C3DD9(&s, a2, v11, v10, v7, v8);
    *a1 = v13;
    free(ptr);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_print_mem", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000C4182) ----------------------------------------------------
signed __int64 __fastcall lyd_print_clb(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, unsigned int a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // ST2C_4
  unsigned __int64 v10; // [rsp+0h] [rbp-80h]
  __int64 *v11; // [rsp+8h] [rbp-78h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  void *ptr; // [rsp+50h] [rbp-30h]
  unsigned __int64 v16; // [rsp+78h] [rbp-8h]

  v11 = a3;
  v10 = __PAIR__(a4, a5);
  v16 = __readfsqword(0x28u);
  if ( a1 )
  {
    memset(&s, 0, 0x40uLL);
    s = 3;
    v13 = a1;
    v14 = a2;
    v9 = sub_C3DD9(&s, v11, SHIDWORD(v10), v10, v7, v8);
    free(ptr);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyd_print_clb", a6, __PAIR__(a4, a5));
    result = 1LL;
  }
  return result;
}

//----- (00000000000C424C) ----------------------------------------------------
signed __int64 __fastcall sub_C424C(__int64 a1, char a2)
{
  unsigned int v3; // eax
  signed int v4; // [rsp+14h] [rbp-1Ch]
  __int64 j; // [rsp+18h] [rbp-18h]
  _QWORD *v6; // [rsp+18h] [rbp-18h]
  _QWORD *v7; // [rsp+18h] [rbp-18h]
  __int64 v8; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]
  _QWORD *l; // [rsp+28h] [rbp-8h]
  _QWORD *k; // [rsp+28h] [rbp-8h]

  v4 = 0;
  if ( a2 & 0x10 )
  {
    if ( *(_BYTE *)(a1 + 9) & 1 )
      return 0LL;
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC )
    {
      if ( (unsigned int)lyd_wd_default(a1) )
        return 0LL;
      return 1LL;
    }
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 1 && !*(_QWORD *)(*(_QWORD *)a1 + 136LL) )
    {
      v8 = *(_QWORD *)(a1 + 64);
LABEL_43:
      if ( !v8 || v4 )
      {
        if ( !v4 )
          return 0LL;
        return 1LL;
      }
      for ( i = v8; ; i = j )
      {
        if ( !i )
        {
LABEL_42:
          v8 = *(_QWORD *)(v8 + 24);
          goto LABEL_43;
        }
        if ( !(*(_BYTE *)(i + 9) & 1) )
          break;
LABEL_35:
        if ( i == v8 )
          goto LABEL_42;
LABEL_39:
        for ( j = *(_QWORD *)(i + 24); !j; j = *(_QWORD *)(i + 24) )
        {
          i = *(_QWORD *)(i + 40);
          if ( *(_QWORD *)(i + 40) == *(_QWORD *)(v8 + 40) )
            break;
        }
      }
      v3 = *(_DWORD *)(*(_QWORD *)i + 56LL);
      if ( v3 != 16 )
      {
        if ( v3 <= 0x10 )
        {
          if ( v3 == 4 || v3 == 8 )
          {
            if ( !(unsigned int)lyd_wd_default(i) )
              v4 = 1;
          }
          else if ( v3 == 1 && *(_QWORD *)(*(_QWORD *)i + 136LL) )
          {
            v4 = 1;
          }
LABEL_30:
          if ( v4 )
            goto LABEL_42;
          if ( *(_DWORD *)(*(_QWORD *)i + 56LL) & 0x802C )
            j = 0LL;
          else
            j = *(_QWORD *)(i + 64);
          if ( j )
            goto LABEL_39;
          goto LABEL_35;
        }
        if ( v3 != 128 )
        {
          if ( v3 > 0x80 )
          {
            if ( v3 != 0x4000 && v3 != 32800 )
              goto LABEL_30;
          }
          else if ( v3 != 32 )
          {
            goto LABEL_30;
          }
        }
      }
      v4 = 1;
      goto LABEL_30;
    }
  }
  else if ( !(*(_BYTE *)(a1 + 9) & 1) || a2 & 0xF0 || *(_WORD *)(*(_QWORD *)a1 + 24LL) & 2 )
  {
    if ( *(_BYTE *)(a1 + 9) & 1 && *(_DWORD *)(*(_QWORD *)a1 + 56LL) == 1 && !(a2 & 4) )
    {
      for ( k = (_QWORD *)a1; k; k = v7 )
      {
        if ( *(_DWORD *)(*k + 56LL) != 1 )
        {
          v4 = 1;
          break;
        }
        if ( *(_DWORD *)(*k + 56LL) & 0x802C )
          v7 = 0LL;
        else
          v7 = (_QWORD *)k[8];
        if ( !v7 )
        {
          if ( k == (_QWORD *)a1 )
            break;
          v7 = (_QWORD *)k[3];
        }
        while ( !v7 )
        {
          k = (_QWORD *)k[5];
          if ( k[5] == *(_QWORD *)(a1 + 40) )
            break;
          v7 = (_QWORD *)k[3];
        }
      }
      if ( !v4 )
        return 0LL;
    }
  }
  else
  {
    for ( l = (_QWORD *)a1; l; l = v6 )
    {
      if ( *(_WORD *)(*l + 24LL) & 2 )
      {
        v4 = 1;
        break;
      }
      if ( *(_DWORD *)(*l + 56LL) & 0x802C )
        v6 = 0LL;
      else
        v6 = (_QWORD *)l[8];
      if ( !v6 )
      {
        if ( l == (_QWORD *)a1 )
          break;
        v6 = (_QWORD *)l[3];
      }
      while ( !v6 )
      {
        l = (_QWORD *)l[5];
        if ( l[5] == *(_QWORD *)(a1 + 40) )
          break;
        v6 = (_QWORD *)l[3];
      }
    }
    if ( !v4 )
      return 0LL;
  }
  return 1LL;
}
// 79C0: using guessed type __int64 __fastcall lyd_wd_default(_QWORD);

//----- (00000000000C46A7) ----------------------------------------------------
signed __int64 __fastcall sub_C46A7(_QWORD *a1, char a2)
{
  signed __int64 result; // rax
  __int64 *v3; // rax
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 j; // [rsp+18h] [rbp-18h]
  __int64 l; // [rsp+18h] [rbp-18h]
  _QWORD *k; // [rsp+20h] [rbp-10h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  if ( (unsigned int)sub_C424C((__int64)a1, a2) )
    return 1LL;
  for ( i = lys_parent(*a1); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( !i || *(_DWORD *)(i + 56) != 64 )
    return 0LL;
  v8 = i;
  for ( j = lys_parent(i); j && *(_DWORD *)(j + 56) == 4096; j = lys_parent(j) )
    ;
  if ( j && *(_DWORD *)(j + 56) == 2 )
  {
    if ( v8 == *(_QWORD *)(j + 112) )
    {
      result = 0LL;
    }
    else
    {
      for ( k = (_QWORD *)a1[4]; *(_QWORD *)(k[4] + 24LL); k = (_QWORD *)k[4] )
        ;
      while ( k )
      {
        if ( k != a1 )
        {
          for ( l = lys_parent(*k); l && *(_DWORD *)(l + 56) == 4096; l = lys_parent(l) )
            ;
          if ( l == v8 && (unsigned int)sub_C424C((__int64)k, a2) )
            return 0LL;
        }
        k = (_QWORD *)k[3];
      }
      result = 1LL;
    }
  }
  else
  {
    v3 = (__int64 *)lyd_node_module(a1);
    sub_12222(*v3, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/printer.c", 980LL);
    result = 0LL;
  }
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000C488D) ----------------------------------------------------
void __fastcall sub_C488D(__int64 a1)
{
  unsigned __int16 i; // [rsp+1Eh] [rbp-2h]

  if ( a1 )
  {
    free(*(void **)(a1 + 40));
    free(*(void **)a1);
    free(*(void **)(a1 + 8));
    free(*(void **)(a1 + 16));
    if ( *(_QWORD *)(a1 + 24) )
    {
      for ( i = 0; i < *(_WORD *)(a1 + 32); ++i )
        free(*(void **)(8LL * i + *(_QWORD *)(a1 + 24)));
    }
    free(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

//----- (00000000000C494A) ----------------------------------------------------
const char *__fastcall sub_C494A(_DWORD *a1)
{
  const char *result; // rax

  switch ( *a1 )
  {
    case 0:
      result = "empty";
      break;
    case 1:
      result = "node set";
      break;
    case 2:
      result = "schema node set";
      break;
    case 3:
      result = "boolean";
      break;
    case 4:
      result = "number";
      break;
    case 5:
      result = "string";
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000C49BD) ----------------------------------------------------
const char *__fastcall sub_C49BD(unsigned int a1)
{
  const char *result; // rax

  switch ( (unsigned __int64)a1 )
  {
    case 1uLL:
      result = (const char *)asc_124E90;
      break;
    case 2uLL:
      result = (const char *)&asc_124E90[1];
      break;
    case 3uLL:
      result = (const char *)&asc_124E90[2];
      break;
    case 4uLL:
      result = (const char *)&asc_124E90[3];
      break;
    case 5uLL:
      result = (const char *)&asc_124E90[4];
      break;
    case 6uLL:
      result = "..";
      break;
    case 7uLL:
      result = "@";
      break;
    case 8uLL:
      result = ",";
      break;
    case 9uLL:
      result = "NameTest";
      break;
    case 0xAuLL:
      result = "NodeType";
      break;
    case 0xBuLL:
      result = "FunctionName";
      break;
    case 0xCuLL:
      result = "Operator(Logic)";
      break;
    case 0xDuLL:
      result = "Operator(Comparison)";
      break;
    case 0xEuLL:
      result = "Operator(Math)";
      break;
    case 0xFuLL:
      result = "Operator(Union)";
      break;
    case 0x10uLL:
      result = "Operator(Path)";
      break;
    case 0x11uLL:
      result = "Literal";
      break;
    case 0x12uLL:
      result = "Number";
      break;
    default:
      sub_12222(0LL, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c", 149LL);
      result = byte_124F70;
      break;
  }
  return result;
}
// 124E90: using guessed type __int16 asc_124E90[5];

//----- (00000000000C4AE9) ----------------------------------------------------
unsigned __int64 __fastcall sub_C4AE9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r12
  unsigned int v7; // ebx
  const char *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  unsigned int v13; // ebx
  size_t v14; // rax
  unsigned int v15; // ebx
  size_t v16; // rax
  char *v17; // rdi
  bool v18; // zf
  __int64 v20; // [rsp+8h] [rbp-B8h]
  unsigned __int16 i; // [rsp+1Ch] [rbp-A4h]
  unsigned __int16 j; // [rsp+1Eh] [rbp-A2h]
  char s[136]; // [rsp+20h] [rbp-A0h]
  unsigned __int64 v24; // [rsp+A8h] [rbp-18h]

  v20 = a1;
  v24 = __readfsqword(0x28u);
  if ( a1 && (unsigned __int8)byte_3458A0 > 2u )
  {
    sub_12312(8u, (__int64)"expression \"%s\":", *(_QWORD *)(a1 + 40), a4, a5, a6);
    for ( i = 0; i < *(_WORD *)(v20 + 32); ++i )
    {
      v6 = *(_QWORD *)(v20 + 40) + *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v20 + 8));
      v7 = *(unsigned __int16 *)(2LL * i + *(_QWORD *)(v20 + 16));
      v8 = sub_C49BD(*(_DWORD *)(4LL * i + *(_QWORD *)v20));
      sprintf(s, "\ttoken %s, in expression \"%.*s\"", v8, v7, v6);
      v12 = 8LL * i;
      if ( *(_QWORD *)(v12 + *(_QWORD *)(v20 + 24)) )
      {
        v13 = **(_DWORD **)(8LL * i + *(_QWORD *)(v20 + 24));
        v14 = strlen(s);
        sprintf(&s[v14], " (repeat %d", v13);
        for ( j = 1; *(_DWORD *)(4LL * j + *(_QWORD *)(8LL * i + *(_QWORD *)(v20 + 24))); ++j )
        {
          v15 = *(_DWORD *)(4LL * j + *(_QWORD *)(8LL * i + *(_QWORD *)(v20 + 24)));
          v16 = strlen(s);
          sprintf(&s[v16], ", %d", v15);
        }
        v9 = -1LL;
        v17 = s;
        do
        {
          if ( !v9 )
            break;
          v18 = *v17++ == 0;
          --v9;
        }
        while ( !v18 );
        v12 = -v9 - 2;
        *(_WORD *)&s[v12] = 41;
      }
      sub_12312(8u, (__int64)s, v12, v9, v10, v11);
    }
  }
  return __readfsqword(0x28u) ^ v24;
}
// 3458A0: using guessed type char byte_3458A0;
// C4AE9: using guessed type char s[136];

//----- (00000000000C4D98) ----------------------------------------------------
unsigned __int64 __fastcall sub_C4D98(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  const char *v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // eax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  const char *v15; // rax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  char v22; // fps^1
  __int16 v24; // fps
  char v26; // fps^1
  __int16 v28; // fps
  signed __int64 v31; // [rsp+10h] [rbp-50h]
  unsigned int i; // [rsp+3Ch] [rbp-24h]
  unsigned int j; // [rsp+3Ch] [rbp-24h]
  char *ptr; // [rsp+40h] [rbp-20h]
  __int64 v35; // [rsp+48h] [rbp-18h]
  __int64 v36; // [rsp+50h] [rbp-10h]
  unsigned __int64 v37; // [rsp+58h] [rbp-8h]

  v37 = __readfsqword(0x28u);
  if ( (unsigned __int8)byte_3458A0 > 2u )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        sub_12312(8u, (__int64)"set EMPTY", a3, a4, a5, a6);
        break;
      case 1:
        sub_12312(8u, (__int64)"set NODE SET:", a3, a4, a5, a6);
        for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
        {
          v36 = 16LL * i + *(_QWORD *)(a1 + 16);
          switch ( *(_DWORD *)(v36 + 8) )
          {
            case 0:
              sub_12312(8u, (__int64)"\t%d (pos %u): ROOT", i + 1, *(unsigned int *)(v36 + 12), v6, v7);
              break;
            case 1:
              sub_12312(8u, (__int64)"\t%d (pos %u): ROOT CONFIG", i + 1, *(unsigned int *)(v36 + 12), v6, v7);
              break;
            case 2:
              if ( *(_DWORD *)(**(_QWORD **)v36 + 56LL) != 16
                || *(_DWORD *)(**(_QWORD **)(*(_QWORD *)v36 + 64LL) + 56LL) != 4 )
              {
                if ( *(_DWORD *)(**(_QWORD **)v36 + 56LL) == 8 )
                  sub_12312(
                    8u,
                    (__int64)"\t%d (pos %u): ELEM %s (val: %s)",
                    i + 1,
                    *(unsigned int *)(v36 + 12),
                    ***(_QWORD ***)v36,
                    *(_QWORD *)(*(_QWORD *)v36 + 56LL));
                else
                  sub_12312(
                    8u,
                    (__int64)"\t%d (pos %u): ELEM %s",
                    i + 1,
                    *(unsigned int *)(v36 + 12),
                    ***(_QWORD ***)v36,
                    v7);
              }
              else
              {
                sub_12312(
                  8u,
                  (__int64)"\t%d (pos %u): ELEM %s (1st child val: %s)",
                  i + 1,
                  *(unsigned int *)(v36 + 12),
                  ***(_QWORD ***)v36,
                  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v36 + 64LL) + 56LL));
              }
              break;
            case 3:
              if ( *(_DWORD *)(**(_QWORD **)v36 + 56LL) & 0x8020 )
              {
                if ( *(_DWORD *)(**(_QWORD **)v36 + 56LL) == 32 )
                  v8 = "anyxml";
                else
                  v8 = "anydata";
                sub_12312(8u, (__int64)"\t%d (pos %u): TEXT <%s>", i + 1, *(unsigned int *)(v36 + 12), (__int64)v8, v7);
              }
              else
              {
                sub_12312(
                  8u,
                  (__int64)"\t%d (pos %u): TEXT %s",
                  i + 1,
                  *(unsigned int *)(v36 + 12),
                  *(_QWORD *)(*(_QWORD *)v36 + 56LL),
                  v7);
              }
              break;
            case 4:
              sub_12312(
                8u,
                (__int64)"\t%d (pos %u): ATTR %s = %s",
                i + 1,
                *(unsigned int *)(v36 + 12),
                *(_QWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16)) + 24LL),
                *(_QWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16)) + 40LL));
              break;
            default:
              sub_12222(
                0LL,
                0,
                4,
                "Internal error (%s:%d).",
                (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
                244LL);
              break;
          }
        }
        break;
      case 2:
        sub_12312(8u, (__int64)"set SNODE SET:", a3, a4, a5, a6);
        for ( j = 0; j < *(_DWORD *)(a1 + 32); ++j )
        {
          v35 = 16LL * j + *(_QWORD *)(a1 + 16);
          v11 = *(_DWORD *)(v35 + 8);
          if ( v11 == 1 )
          {
            sub_12312(8u, (__int64)"\t%d (%u): ROOT CONFIG", j + 1, *(unsigned int *)(v35 + 12), v9, v10);
          }
          else if ( v11 < 1 )
          {
            sub_12312(8u, (__int64)"\t%d (%u): ROOT", j + 1, *(unsigned int *)(v35 + 12), v9, v10);
          }
          else if ( v11 == 2 )
          {
            sub_12312(8u, (__int64)"\t%d (%u): ELEM %s", j + 1, *(unsigned int *)(v35 + 12), **(_QWORD **)v35, v10);
          }
          else
          {
            sub_12222(
              0LL,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
              266LL);
          }
        }
        break;
      case 3:
        sub_12312(8u, (__int64)"set BOOLEAN", a3, a4, a5, a6);
        if ( *(_DWORD *)(a1 + 16) )
          v15 = "true";
        else
          v15 = "false";
        sub_12312(8u, (__int64)"\t%s", (__int64)v15, v12, v13, v14);
        break;
      case 4:
        sub_12312(8u, (__int64)"set NUMBER", a3, a4, a5, a6);
        if ( 0.0 != *(long double *)(a1 + 16) && 0.0 != *(long double *)(a1 + 16) )
        {
          _FST7 = *(long double *)(a1 + 16);
          __asm { fxam }
          if ( (v22 & 0x45) != 5 )
            goto LABEL_61;
          _FST7 = *(long double *)(a1 + 16);
          __asm { fxam }
          if ( v24 & 0x200 )
          {
LABEL_61:
            _FST7 = *(long double *)(a1 + 16);
            __asm { fxam }
            if ( (v26 & 0x45) != 5 )
              goto LABEL_62;
            _FST7 = *(long double *)(a1 + 16);
            __asm { fxam }
            if ( v28 & 0x200 )
            {
              ptr = strdup("-Infinity");
            }
            else
            {
LABEL_62:
              v31 = (signed __int64)*(long double *)(a1 + 16);
              if ( *(long double *)(a1 + 16) == (long double)v31 )
              {
                if ( asprintf(&ptr, "%lld", (signed __int64)*(long double *)(a1 + 16)) == -1 )
                  ptr = 0LL;
              }
              else if ( asprintf(&ptr, "%03.1Lf") == -1 )
              {
                ptr = 0LL;
              }
            }
          }
          else
          {
            ptr = strdup("Infinity");
          }
        }
        else
        {
          ptr = strdup("0");
        }
        if ( ptr )
        {
          sub_12312(8u, (__int64)"\t%s", (__int64)ptr, v19, v20, v21, v31);
          free(ptr);
        }
        else
        {
          sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"print_set_debug", v21, v31);
        }
        break;
      case 5:
        sub_12312(8u, (__int64)"set STRING", a3, a4, a5, a6);
        sub_12312(8u, (__int64)"\t%s", *(_QWORD *)(a1 + 16), v16, v17, v18);
        break;
      default:
        return __readfsqword(0x28u) ^ v37;
    }
  }
  return __readfsqword(0x28u) ^ v37;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (00000000000C54F2) ----------------------------------------------------
signed __int64 __fastcall sub_C54F2(__int64 a1, unsigned __int16 a2, void **a3, unsigned __int16 *a4, _WORD *a5, __int64 a6)
{
  __int64 v7; // r9
  void **v8; // [rsp+18h] [rbp-18h]

  v8 = a3;
  if ( (unsigned __int16)*a5 - *a4 >= a2 )
    return 0LL;
  do
  {
    if ( 0xFFFF - (unsigned __int16)*a5 <= 15 )
    {
      sub_12222(a1, 0, 3, "XPath string length limit (%u) reached.", 0xFFFFLL, a6);
      return 0xFFFFFFFFLL;
    }
    *a5 += 16;
  }
  while ( (unsigned __int16)*a5 - *a4 < a2 );
  *a3 = sub_C422(*a3, (unsigned __int16)*a5);
  if ( *v8 )
    return 0LL;
  sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"cast_string_realloc", v7);
  return 0xFFFFFFFFLL;
}

//----- (00000000000C5614) ----------------------------------------------------
signed __int64 __fastcall sub_C5614(__int64 a1, __int64 *a2, int a3, int a4, __int64 a5, void **a6, unsigned __int16 *a7, _WORD *a8)
{
  signed __int64 result; // rax
  unsigned int v9; // eax
  __int64 v10; // r9
  __int16 v11; // ax
  __int64 v12; // r9
  int v13; // ebx
  int v14; // edx
  int v15; // ebx
  __int64 v16; // r9
  __int64 v17; // r9
  __int16 v18; // ax
  __int64 v19; // r9
  unsigned __int16 v20; // bx
  void **v21; // [rsp+18h] [rbp-78h]
  unsigned __int16 v22; // [rsp+24h] [rbp-6Ch]
  int v23; // [rsp+2Ch] [rbp-64h]
  char *v24; // [rsp+48h] [rbp-48h]
  char *save_ptr; // [rsp+50h] [rbp-40h]
  char *src; // [rsp+58h] [rbp-38h]
  char *s; // [rsp+60h] [rbp-30h]
  __int64 i; // [rsp+68h] [rbp-28h]
  __int64 v29; // [rsp+70h] [rbp-20h]
  unsigned __int64 v30; // [rsp+78h] [rbp-18h]

  v23 = a3;
  v21 = a6;
  v22 = a5;
  v30 = __readfsqword(0x28u);
  if ( a4 == 1 && *(_WORD *)(*(_QWORD *)a1 + 24LL) & 2 )
    return 0LL;
  if ( a3 )
  {
    if ( (unsigned int)sub_C54F2(*a2, 1u, a6, a7, a8, (__int64)a6) )
      return 0xFFFFFFFFLL;
    *(_WORD *)((char *)*v21 + (*a7)++ - 1) = 10;
    ++v22;
  }
  v9 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v9 == 16 )
    goto LABEL_21;
  if ( v9 <= 0x10 )
  {
    if ( v9 == 4 || v9 == 8 )
    {
      s = *(char **)(a1 + 56);
      if ( !s )
        s = byte_124F70;
      v11 = strlen(s);
      if ( (unsigned int)sub_C54F2(*a2, 2 * v22 + v11 + 1, v21, a7, a8, v12) )
        return 0xFFFFFFFFLL;
      memset((char *)*v21 + *a7 - 1, 32, 2 * v22);
      *a7 += 2 * v22;
      if ( *a7 == 1 )
      {
        strcpy((char *)*v21 + *a7 - 1, s);
        v13 = *a7;
        v14 = v13 + strlen(s);
      }
      else
      {
        sprintf((char *)*v21 + *a7 - 1, off_125228, s);
        v15 = *a7;
        v14 = v15 + strlen(s) + 1;
      }
      *a7 = v14;
      goto LABEL_55;
    }
    if ( v9 != 1 )
    {
LABEL_54:
      sub_12222(*a2, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c", 479LL);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_21;
  }
  if ( v9 == 128 )
    goto LABEL_21;
  if ( v9 <= 0x80 )
  {
    if ( v9 != 32 )
      goto LABEL_54;
    goto LABEL_37;
  }
  if ( v9 == 256 )
  {
LABEL_21:
    if ( (unsigned int)sub_C54F2(*a2, 1u, v21, a7, a8, (__int64)a6) )
      return 0xFFFFFFFFLL;
    *(_WORD *)((char *)*v21 + (*a7)++ - 1) = 10;
    for ( i = *(_QWORD *)(a1 + 64); i; i = *(_QWORD *)(i + 24) )
    {
      if ( (unsigned int)sub_C5614(i, (__int64)a2) )
        return 0xFFFFFFFFLL;
    }
    goto LABEL_55;
  }
  if ( v9 != 32800 )
    goto LABEL_54;
LABEL_37:
  v29 = a1;
  if ( *(_QWORD *)(a1 + 56) )
  {
    switch ( *(_DWORD *)(v29 + 52) )
    {
      case 0:
      case 2:
      case 4:
        v24 = strdup(*(const char **)(v29 + 56));
        if ( v24 )
          goto LABEL_49;
        sub_12222(*a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"cast_string_recursive", v17);
        result = 0xFFFFFFFFLL;
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
        sub_12222(
          *a2,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          454LL);
        result = 0xFFFFFFFFLL;
        break;
      case 8:
        if ( (unsigned int)lyxml_print_mem(&v24, *(_QWORD *)(v29 + 56), 16LL) )
          goto LABEL_49;
        result = 0xFFFFFFFFLL;
        break;
      case 0x10:
        if ( !(unsigned int)lyd_print_mem(&v24, *(_QWORD *)(v29 + 56), 1LL, 1LL) )
          goto LABEL_49;
        result = 0xFFFFFFFFLL;
        break;
      case 0x20:
        sub_12222(*a2, 0, 3, "Cannot convert LYB anydata into string.", a5, (__int64)a6);
        result = 0xFFFFFFFFLL;
        break;
      default:
        goto LABEL_49;
    }
    return result;
  }
  v24 = strdup(byte_124F70);
  if ( !v24 )
  {
    sub_12222(*a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"cast_string_recursive", v16);
    return 0xFFFFFFFFLL;
  }
LABEL_49:
  src = strtok_r(v24, "\n", &save_ptr);
  do
  {
    v18 = strlen(src);
    if ( (unsigned int)sub_C54F2(*a2, 2 * v22 + v18 + 1, v21, a7, a8, v19) )
    {
      free(v24);
      return 0xFFFFFFFFLL;
    }
    memset((char *)*v21 + *a7 - 1, 32, 2 * v22);
    *a7 += 2 * v22;
    strcpy((char *)*v21 + *a7 - 1, src);
    v20 = *a7;
    *a7 = v20 + strlen(src);
    *(_WORD *)((char *)*v21 + (*a7)++ - 1) = 10;
    src = strtok_r(0LL, "\n", &save_ptr);
  }
  while ( src );
  free(v24);
LABEL_55:
  if ( v23 )
  {
    if ( (unsigned int)sub_C54F2(*a2, 1u, v21, a7, a8, v10) )
      return 0xFFFFFFFFLL;
    *(_WORD *)((char *)*v21 + (*a7)++ - 1) = 10;
  }
  return 0LL;
}
// 7960: using guessed type __int64 __fastcall lyd_print_mem(_QWORD, _QWORD, _QWORD, _QWORD);
// 7990: using guessed type __int64 __fastcall lyxml_print_mem(_QWORD, _QWORD, _QWORD);

//----- (00000000000C5D5B) ----------------------------------------------------
void *__fastcall sub_C5D5B(__int64 a1, __int64 *a2, int a3, int a4)
{
  __int64 v4; // r9
  void *result; // rax
  __int64 v6; // r9
  int v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+Ch] [rbp-34h]
  unsigned __int16 v9; // [rsp+2Ch] [rbp-14h]
  unsigned __int16 v10; // [rsp+2Eh] [rbp-12h]
  void *ptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v12; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v12 = __readfsqword(0x28u);
  ptr = malloc(0x40uLL);
  if ( ptr )
  {
    *(_BYTE *)ptr = 0;
    v9 = 1;
    v10 = 64;
    if ( (unsigned int)sub_C5614(a1, a2, v8, v7, 0LL, &ptr, &v9, &v10) )
    {
      free(ptr);
      result = 0LL;
    }
    else if ( v10 <= v9 || (ptr = sub_C422(ptr, v9)) != 0LL )
    {
      result = ptr;
    }
    else
    {
      free(0LL);
      sub_12222(*a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"cast_string_elem", v6);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(*a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"cast_string_elem", v4);
    result = 0LL;
  }
  return result;
}

//----- (00000000000C5EB1) ----------------------------------------------------
char *__fastcall sub_C5EB1(__int64 a1, __int64 a2, void **a3, int a4, __int64 a5, __int64 a6)
{
  char *result; // rax
  __int64 v7; // r9
  __int64 *v8; // [rsp+8h] [rbp-38h]
  int v9; // [rsp+2Ch] [rbp-14h]
  char *v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v8 = (__int64 *)a3;
  v11 = __readfsqword(0x28u);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8LL) == 4 || *(_BYTE *)(**(_QWORD **)(a1 + 16) + 8LL) >= 0 )
  {
    sub_D2AFF(a2, a4, &v9);
    switch ( *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8LL) )
    {
      case 0:
      case 1:
        result = (char *)sub_C5D5B(**(_QWORD **)(a1 + 16), v8, 1, v9);
        break;
      case 2:
      case 3:
        result = (char *)sub_C5D5B(**(_QWORD **)(a1 + 16), v8, 0, v9);
        break;
      case 4:
        v10 = strdup(*(const char **)(**(_QWORD **)(a1 + 16) + 32LL));
        if ( !v10 )
          sub_12222(*v8, 0, 1, "Memory allocation failed (%s()).", (__int64)"cast_node_set_to_string", v7);
        result = v10;
        break;
      default:
        sub_12222(
          *v8,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          569LL);
        result = 0LL;
        break;
    }
  }
  else
  {
    sub_13937(*a3, 76, 3u, **(char ***)(a1 + 16), ****(_QWORD ****)(a1 + 16), a6);
    result = 0LL;
  }
  return result;
}

//----- (00000000000C607E) ----------------------------------------------------
long double __fastcall sub_C607E(const char *a1)
{
  long double v1; // ST00_16
  char *endptr; // [rsp+28h] [rbp-28h]
  _TBYTE v4; // [rsp+30h] [rbp-20h]
  unsigned __int64 v5; // [rsp+48h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  *__errno_location() = 0;
  v1 = strtold(a1, &endptr);
  *(_QWORD *)&v4 = *(_QWORD *)&v1;
  *((_DWORD *)&v4 + 2) = DWORD2(v1);
  if ( *__errno_location() || *endptr )
    *(long double *)&v4 = 1.7845972430358476476e4932/*NaN*/;
  return *(long double *)&v4;
}

//----- (00000000000C6102) ----------------------------------------------------
_BOOL8 __fastcall sub_C6102(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

//----- (00000000000C6158) ----------------------------------------------------
unsigned __int64 __fastcall sub_C6158(__int64 a1, __int64 a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  __int64 v6; // r8
  __int64 v7; // r9
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int i; // [rsp+20h] [rbp-20h]
  __int64 v15; // [rsp+2Ch] [rbp-14h]
  int v16; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+38h] [rbp-8h]

  v17 = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 40) || *(_DWORD *)(a1 + 32) <= 3u )
  {
    if ( *(_QWORD *)(a1 + 40) )
    {
      if ( !a2 )
        __assert_fail("node", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x27Eu, "set_insert_node_hash");
      v15 = a2;
      v16 = a3;
      v8 = sub_1476E(0, (__int64)&v15, 8uLL);
      v9 = sub_1476E(v8, (__int64)&v16, 4uLL);
      v10 = sub_1476E(v9, 0LL, 0LL);
      if ( (unsigned int)sub_15F55(*(_QWORD *)(a1 + 40), &v15, v10, 0LL, v11, v12) )
        __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x289u, "set_insert_node_hash");
    }
  }
  else
  {
    *(_QWORD *)(a1 + 40) = sub_14CB1(1u, 12, (__int64)sub_C6102, 0LL, 1);
    for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
    {
      v15 = *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16));
      v16 = *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8);
      v3 = sub_1476E(0, (__int64)&v15, 8uLL);
      v4 = sub_1476E(v3, (__int64)&v16, 4uLL);
      v5 = sub_1476E(v4, 0LL, 0LL);
      if ( (unsigned int)sub_15F55(*(_QWORD *)(a1 + 40), &v15, v5, 0LL, v6, v7) )
        __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x27Au, "set_insert_node_hash");
    }
  }
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000C639B) ----------------------------------------------------
unsigned __int64 __fastcall sub_C639B(__int64 a1, __int64 a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // [rsp+2Ch] [rbp-14h]
  int v10; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 40) )
  {
    v9 = a2;
    v10 = a3;
    v3 = sub_1476E(0, (__int64)&v9, 8uLL);
    v4 = sub_1476E(v3, (__int64)&v10, 4uLL);
    v5 = sub_1476E(v4, 0LL, 0LL);
    if ( (unsigned int)sub_15F8D(*(_QWORD *)(a1 + 40), (__int64)&v9, v5, (__int64)&v9, v6, v7) )
      __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x29Eu, "set_remove_node_hash");
    if ( !**(_DWORD **)(a1 + 40) )
    {
      sub_14F6B(*(void ***)(a1 + 40));
      *(_QWORD *)(a1 + 40) = 0LL;
    }
  }
  return __readfsqword(0x28u) ^ v11;
}

//----- (00000000000C64AC) ----------------------------------------------------
signed __int64 __fastcall sub_C64AC(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v7; // [rsp+8h] [rbp-48h]
  int v8; // [rsp+2Ch] [rbp-24h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+3Ch] [rbp-14h]
  int v11; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v7 = a4;
  v12 = __readfsqword(0x28u);
  v10 = a2;
  v11 = a3;
  v4 = sub_1476E(0, (__int64)&v10, 8uLL);
  v5 = sub_1476E(v4, (__int64)&v11, 4uLL);
  v8 = sub_1476E(v5, 0LL, 0LL);
  if ( (unsigned int)sub_154F1(*(_QWORD *)(a1 + 40), (__int64)&v10, v8, &v9) )
    return 0LL;
  if ( v7 >= 0
    && *(_QWORD *)(16LL * v7 + *(_QWORD *)(a1 + 16)) == *(_QWORD *)v9
    && *(_DWORD *)(16LL * v7 + *(_QWORD *)(a1 + 16) + 8) == *(_DWORD *)(v9 + 8) )
  {
    v10 = *(_QWORD *)v9;
    v11 = *(_DWORD *)(v9 + 8);
    if ( (unsigned int)sub_15669(*(_QWORD *)(a1 + 40), (__int64)&v10, v8, &v9) )
      return 0LL;
  }
  return 1LL;
}

//----- (00000000000C65F5) ----------------------------------------------------
__int64 __fastcall sub_C65F5(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 1:
        free(*(void **)(a1 + 16));
        sub_14F6B(*(void ***)(a1 + 40));
        *(_QWORD *)(a1 + 40) = 0LL;
        break;
      case 2:
        free(*(void **)(a1 + 16));
        break;
      case 5:
        free(*(void **)(a1 + 16));
        break;
    }
    result = a1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

//----- (00000000000C6688) ----------------------------------------------------
void __fastcall sub_C6688(void *a1)
{
  if ( a1 )
  {
    sub_C65F5((__int64)a1);
    free(a1);
  }
}

//----- (00000000000C66B8) ----------------------------------------------------
void **__fastcall sub_C66B8(const char **a1)
{
  __int64 v2; // r9
  __int64 v3; // r9
  __int64 v4; // r9
  unsigned __int16 i; // [rsp+16h] [rbp-Ah]
  void **s; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  s = (void **)malloc(0x40uLL);
  if ( !s )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_copy", v2);
    return 0LL;
  }
  if ( *(_DWORD *)a1 == 2 )
  {
    memset(s, 0, 0x40uLL);
    *(_DWORD *)s = *(_DWORD *)a1;
    for ( i = 0; (unsigned int)i < *((_DWORD *)a1 + 8); ++i )
    {
      if ( *(_DWORD *)&a1[2][16 * i + 12] == 1
        && (unsigned int)sub_C765D((__int64)s, *(_QWORD *)&a1[2][16 * i], *(_DWORD *)&a1[2][16 * i + 8]) )
      {
        sub_C6688(s);
        return 0LL;
      }
    }
  }
  else if ( *(_DWORD *)a1 == 1 )
  {
    *(_DWORD *)s = *(_DWORD *)a1;
    s[2] = malloc(16LL * *((unsigned int *)a1 + 8));
    if ( !s[2] )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_copy", v3);
      free(s);
      return 0LL;
    }
    memcpy(s[2], a1[2], 16LL * *((unsigned int *)a1 + 8));
    *((_DWORD *)s + 9) = *((_DWORD *)a1 + 8);
    *((_DWORD *)s + 8) = *((_DWORD *)s + 9);
    *((_DWORD *)s + 12) = *((_DWORD *)a1 + 12);
    *((_DWORD *)s + 13) = *((_DWORD *)a1 + 13);
    s[5] = sub_14EB8((unsigned int *)a1[5]);
  }
  else
  {
    memcpy(s, a1, 0x40uLL);
    if ( *(_DWORD *)a1 == 5 )
    {
      s[2] = strdup(a1[2]);
      if ( !s[2] )
      {
        sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_copy", v4);
        free(s);
        return 0LL;
      }
    }
  }
  return s;
}

//----- (00000000000C6974) ----------------------------------------------------
__int64 __fastcall sub_C6974(__int64 a1, char *a2, unsigned __int16 a3)
{
  char *v3; // rdx
  __int64 result; // rax
  unsigned __int16 v5; // [rsp+Ch] [rbp-14h]
  char *string; // [rsp+10h] [rbp-10h]

  string = a2;
  v5 = a3;
  sub_C65F5(a1);
  *(_DWORD *)a1 = 5;
  if ( !v5 && *a2 )
    string = byte_124F70;
  v3 = strndup(string, v5);
  result = a1;
  *(_QWORD *)(a1 + 16) = v3;
  return result;
}

//----- (00000000000C69DE) ----------------------------------------------------
__int64 __fastcall sub_C69DE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int128 a7)
{
  __int64 result; // rax

  sub_C65F5(a1);
  *(_DWORD *)a1 = 4;
  result = a1;
  *(long double *)(a1 + 16) = *(long double *)&a7;
  return result;
}

//----- (00000000000C6A0D) ----------------------------------------------------
_DWORD *__fastcall sub_C6A0D(_DWORD *a1, int a2)
{
  _DWORD *result; // rax

  sub_C65F5((__int64)a1);
  *a1 = 3;
  result = a1;
  a1[4] = a2;
  return result;
}

//----- (00000000000C6A3F) ----------------------------------------------------
void __fastcall sub_C6A3F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  unsigned __int16 v7; // ax
  __int64 v8; // r9

  if ( a1 && a2 )
  {
    switch ( *(_DWORD *)a2 )
    {
      case 2:
        *(_DWORD *)a1 = 2;
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 32);
        *(_QWORD *)(a1 + 16) = sub_C422(*(void **)(a1 + 16), 16LL * *(unsigned int *)(a1 + 36));
        if ( *(_QWORD *)(a1 + 16) )
        {
          memcpy(*(void **)(a1 + 16), *(const void **)(a2 + 16), 16LL * *(unsigned int *)(a2 + 32));
        }
        else
        {
          sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_fill_set", v6, a2);
          memset((void *)a1, 0, 0x40uLL);
        }
        break;
      case 3:
        sub_C6A0D((_DWORD *)a1, *(_DWORD *)(a2 + 16));
        break;
      case 4:
        sub_C69DE(a1, a2, a3, a4, a5, a6, COERCE__INT128(*(long double *)(a2 + 16)));
        break;
      case 5:
        v7 = strlen(*(const char **)(a2 + 16));
        sub_C6974(a1, *(char **)(a2 + 16), v7);
        break;
      default:
        if ( *(_DWORD *)a1 == 1 )
        {
          free(*(void **)(a1 + 16));
        }
        else if ( *(_DWORD *)a1 == 5 )
        {
          free(*(void **)(a1 + 16));
        }
        if ( *(_DWORD *)a2 )
        {
          if ( *(_DWORD *)a2 != 1 )
            __assert_fail(
              "src->type == LYXP_SET_NODE_SET",
              "/home/mantovan/Repositories/libyang/src/xpath.c",
              0x378u,
              "set_fill_set");
          *(_DWORD *)a1 = 1;
          *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
          *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 32);
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
          *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
          *(_QWORD *)(a1 + 16) = malloc(16LL * *(unsigned int *)(a1 + 32));
          if ( *(_QWORD *)(a1 + 16) )
          {
            memcpy(*(void **)(a1 + 16), *(const void **)(a2 + 16), 16LL * *(unsigned int *)(a2 + 32));
            *(_QWORD *)(a1 + 40) = sub_14EB8(*(unsigned int **)(a2 + 40));
          }
          else
          {
            sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_fill_set", v8, a2);
            memset((void *)a1, 0, 0x40uLL);
          }
        }
        else
        {
          *(_DWORD *)a1 = 0;
        }
        break;
    }
  }
}

//----- (00000000000C6D49) ----------------------------------------------------
__int64 __fastcall sub_C6D49(__int64 a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    result = *(unsigned int *)(a1 + 32);
    if ( i >= (unsigned int)result )
      break;
    if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 1 )
      *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) = 0;
  }
  return result;
}

//----- (00000000000C6DA0) ----------------------------------------------------
void *__fastcall sub_C6DA0(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || *a1 != 1 )
    __assert_fail(
      "set && (set->type == LYXP_SET_NODE_SET)",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x3A2u,
      "set_remove_node");
  if ( a2 >= a1[8] )
    __assert_fail("idx < set->used", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x3A3u, "set_remove_node");
  sub_C639B((__int64)a1, *(_QWORD *)(16LL * a2 + *((_QWORD *)a1 + 2)), *(_DWORD *)(16LL * a2 + *((_QWORD *)a1 + 2) + 8));
  if ( --a1[8] )
    return memmove(
             (void *)(16LL * a2 + *((_QWORD *)a1 + 2)),
             (const void *)(*((_QWORD *)a1 + 2) + 16LL * (a2 + 1)),
             16LL * (a1[8] - a2));
  sub_C65F5((__int64)a1);
  return memset(a1, 0, 0x40uLL);
}

//----- (00000000000C6ECE) ----------------------------------------------------
void *__fastcall sub_C6ECE(unsigned int *a1)
{
  void *result; // rax
  unsigned __int16 v2; // [rsp+16h] [rbp-Ah]
  unsigned __int16 v3; // [rsp+18h] [rbp-8h]
  unsigned __int16 v4; // [rsp+1Ah] [rbp-6h]
  signed int v5; // [rsp+1Ch] [rbp-4h]

  if ( !a1 || *a1 != 1 )
    __assert_fail(
      "set && (set->type == LYXP_SET_NODE_SET)",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x3C1u,
      "set_remove_none_nodes");
  v4 = a1[8];
  a1[8] = 0;
  v2 = 0;
  while ( v2 < v4 )
  {
    v5 = -1;
    while ( *(_DWORD *)(16LL * v2 + *((_QWORD *)a1 + 2) + 8) != 5 && v5 == -1 )
    {
      v5 = v2;
LABEL_12:
      if ( ++v2 == v4 )
        v3 = v2;
      if ( v2 >= v4 )
        goto LABEL_15;
    }
    if ( v5 < 0 || *(_DWORD *)(16LL * v2 + *((_QWORD *)a1 + 2) + 8) != 5 )
      goto LABEL_12;
    v3 = v2++;
LABEL_15:
    if ( v5 >= 0 )
    {
      if ( a1[8] != v5 )
        memmove(
          (void *)(*((_QWORD *)a1 + 2) + 16LL * a1[8]),
          (const void *)(*((_QWORD *)a1 + 2) + 16LL * v5),
          16LL * (v3 - v5));
      a1[8] += v3 - v5;
    }
  }
  result = (void *)a1[8];
  if ( !(_DWORD)result )
  {
    sub_C65F5((__int64)a1);
    result = memset(a1, 0, 0x40uLL);
  }
  return result;
}

//----- (00000000000C705F) ----------------------------------------------------
signed __int64 __fastcall sub_C705F(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  if ( *(_QWORD *)(a1 + 40) )
    return sub_C64AC(a1, a2, a3, a4);
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    if ( (a4 < 0 || i != a4)
      && a2 == *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16))
      && a3 == *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8) )
    {
      return 1LL;
    }
  }
  return 0LL;
}

//----- (00000000000C7105) ----------------------------------------------------
signed __int64 __fastcall sub_C7105(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int i; // [rsp+24h] [rbp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    if ( (a4 < 0 || i != a4)
      && a2 == *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16))
      && a3 == *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8) )
    {
      return i;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (00000000000C7180) ----------------------------------------------------
unsigned __int64 __fastcall sub_C7180(unsigned int *a1, unsigned int *a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // r9
  __int64 *v4; // rdx
  _QWORD *v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rdx
  unsigned int i; // [rsp+14h] [rbp-Ch]
  unsigned int j; // [rsp+18h] [rbp-8h]
  unsigned int v10; // [rsp+1Ch] [rbp-4h]

  if ( *a1 != 2 && *a1 || *a2 != 2 && *a2 )
    __assert_fail(
      "((set1->type == LYXP_SET_SNODE_SET) || (set1->type == LYXP_SET_EMPTY)) && ((set2->type == LYXP_SET_SNODE_SET) || ("
      "set2->type == LYXP_SET_EMPTY))",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x41Fu,
      "set_snode_merge");
  result = *a2;
  if ( (_DWORD)result )
  {
    if ( *a1 )
    {
      if ( a2[8] + a1[8] <= a1[9]
        || (a1[9] = a2[8] + a1[8], (*((_QWORD *)a1 + 2) = sub_C422(*((void **)a1 + 2), 16LL * a1[9])) != 0LL) )
      {
        v10 = a1[8];
        for ( i = 0; i < a2[8]; ++i )
        {
          for ( j = 0;
                j < v10 && *(_QWORD *)(16LL * j + *((_QWORD *)a1 + 2)) != *(_QWORD *)(16LL * i + *((_QWORD *)a2 + 2));
                ++j )
          {
            ;
          }
          if ( j == v10 )
          {
            v4 = (__int64 *)(*((_QWORD *)a2 + 2) + 16LL * i);
            v5 = (_QWORD *)(16LL * a1[8] + *((_QWORD *)a1 + 2));
            v6 = *v4;
            v7 = v4[1];
            *v5 = v6;
            v5[1] = v7;
            ++a1[8];
          }
        }
        free(*((void **)a2 + 2));
        result = (unsigned __int64)memset(a2, 0, 0x40uLL);
      }
      else
      {
        result = sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_snode_merge", v3, a2);
      }
    }
    else
    {
      result = (unsigned __int64)memcpy(a1, a2, 0x40uLL);
    }
  }
  return result;
}

//----- (00000000000C7395) ----------------------------------------------------
unsigned __int64 __fastcall sub_C7395(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5)
{
  __int64 v5; // r9
  __int64 v7; // r9
  unsigned int v8; // [rsp+4h] [rbp-1Ch]
  int v9; // [rsp+8h] [rbp-18h]
  int v10; // [rsp+Ch] [rbp-14h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( !a1 || *(_DWORD *)a1 != 1 && *(_DWORD *)a1 )
    __assert_fail(
      "set && ((set->type == LYXP_SET_NODE_SET) || (set->type == LYXP_SET_EMPTY))",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x450u,
      "set_insert_node");
  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(a1 + 32) == *(_DWORD *)(a1 + 36) )
    {
      *(_QWORD *)(a1 + 16) = sub_C422(*(void **)(a1 + 16), 16LL * (unsigned int)(*(_DWORD *)(a1 + 36) + 2));
      if ( !*(_QWORD *)(a1 + 16) )
        return sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_insert_node", v7);
      *(_DWORD *)(a1 + 36) += 2;
    }
    if ( v8 > *(_DWORD *)(a1 + 32) )
    {
      sub_12222(
        0LL,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        1134LL);
      v8 = *(_DWORD *)(a1 + 32);
    }
    if ( v8 < *(_DWORD *)(a1 + 32) )
      memmove(
        (void *)(16LL * (v8 + 1) + *(_QWORD *)(a1 + 16)),
        (const void *)(*(_QWORD *)(a1 + 16) + 16LL * v8),
        16LL * (*(_DWORD *)(a1 + 32) - v8));
  }
  else
  {
    if ( a5 )
    {
      sub_12222(
        0LL,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        1110LL);
      v8 = 0;
    }
    *(_QWORD *)(a1 + 16) = malloc(0x20uLL);
    if ( !*(_QWORD *)(a1 + 16) )
      return sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"set_insert_node", v5);
    *(_DWORD *)a1 = 1;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = 2;
    *(_DWORD *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 52) = 1;
    *(_QWORD *)(a1 + 40) = 0LL;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v8) = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v8 + 8) = v9;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v8 + 12) = v10;
  ++*(_DWORD *)(a1 + 32);
  return sub_C6158(a1, a2, v9);
}

//----- (00000000000C765D) ----------------------------------------------------
signed __int64 __fastcall sub_C765D(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r9
  int v5; // [rsp+Ch] [rbp-24h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  v5 = a3;
  if ( *(_DWORD *)a1 != 2 )
    __assert_fail(
      "set->type == LYXP_SET_SNODE_SET",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x488u,
      "set_snode_insert_node");
  v6 = sub_C7105(a1, a2, a3, -1);
  if ( (v6 & 0x80000000) != 0 )
  {
    if ( *(_DWORD *)(a1 + 32) == *(_DWORD *)(a1 + 36) )
    {
      *(_QWORD *)(a1 + 16) = sub_C422(*(void **)(a1 + 16), 16LL * (unsigned int)(*(_DWORD *)(a1 + 36) + 2));
      if ( !*(_QWORD *)(a1 + 16) )
      {
        sub_12222(
          **(_QWORD **)(a2 + 48),
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"set_snode_insert_node",
          v3);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 36) += 2;
    }
    v6 = *(_DWORD *)(a1 + 32);
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * (signed int)v6) = a2;
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16LL * (signed int)v6 + 8) = v5;
    *(_DWORD *)(16LL * (signed int)v6 + *(_QWORD *)(a1 + 16) + 12) = 1;
    ++*(_DWORD *)(a1 + 32);
  }
  else
  {
    *(_DWORD *)(16LL * (signed int)v6 + *(_QWORD *)(a1 + 16) + 12) = 1;
  }
  return v6;
}

//----- (00000000000C77EE) ----------------------------------------------------
unsigned __int64 __fastcall sub_C77EE(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5)
{
  unsigned int v6; // [rsp+4h] [rbp-1Ch]
  int v7; // [rsp+8h] [rbp-18h]
  int v8; // [rsp+Ch] [rbp-14h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( !a1 || a5 >= *(_DWORD *)(a1 + 32) )
    __assert_fail(
      "set && (idx < set->used)",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x4AAu,
      "set_replace_node");
  sub_C639B(a1, *(_QWORD *)(16LL * a5 + *(_QWORD *)(a1 + 16)), *(_DWORD *)(16LL * a5 + *(_QWORD *)(a1 + 16) + 8));
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v6) = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v6 + 8) = v7;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v6 + 12) = v8;
  return sub_C6158(a1, *(_QWORD *)(16LL * v6 + *(_QWORD *)(a1 + 16)), *(_DWORD *)(16LL * v6 + *(_QWORD *)(a1 + 16) + 8));
}

//----- (00000000000C78F8) ----------------------------------------------------
__int64 __fastcall sub_C78F8(__int64 a1)
{
  unsigned int v2; // [rsp+18h] [rbp-8h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]
  unsigned int j; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)a1 != 2 )
    __assert_fail(
      "set->type == LYXP_SET_SNODE_SET",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x4BCu,
      "set_snode_new_in_ctx");
  v2 = 3;
LABEL_4:
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    if ( v2 <= *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) )
    {
      v2 = *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) + 1;
      goto LABEL_4;
    }
  }
  for ( j = 0; j < *(_DWORD *)(a1 + 32); ++j )
  {
    if ( *(_DWORD *)(16LL * j + *(_QWORD *)(a1 + 16) + 12) == 1 )
      *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16LL * j + 12) = v2;
  }
  return v2;
}

//----- (00000000000C79D5) ----------------------------------------------------
__int64 __fastcall sub_C79D5(_QWORD *a1, int a2, _QWORD *a3, int a4, _QWORD **a5, unsigned int *a6)
{
  __int64 result; // rax
  unsigned int v7; // [rsp+34h] [rbp-1Ch]
  signed __int64 v8; // [rsp+38h] [rbp-18h]
  _QWORD *j; // [rsp+40h] [rbp-10h]
  _QWORD *i; // [rsp+48h] [rbp-8h]

  v7 = 1;
  if ( !a5 || !a6 || *(_QWORD *)(a3[4] + 24LL) )
    __assert_fail(
      "prev && prev_pos && !root->prev->next",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x4E3u,
      "get_node_pos");
  if ( !a2 || a2 == 1 )
    return 0LL;
  if ( *a5 )
  {
    j = *a5;
    v7 = *a6;
    for ( i = *a5; i[5]; i = (_QWORD *)i[5] )
      ;
    goto LABEL_15;
  }
  for ( i = a3; i; i = (_QWORD *)i[3] )
  {
    for ( j = i; j; j = (_QWORD *)v8 )
    {
LABEL_15:
      if ( a4 == 1 && *(_WORD *)(*j + 24LL) & 2 )
        goto LABEL_40;
      if ( j == a1 )
        break;
      ++v7;
      v8 = *(_DWORD *)(*j + 56LL) & 0x802C ? 0LL : j[8];
      if ( !v8 )
      {
LABEL_40:
        if ( j == i )
        {
          j = 0LL;
          break;
        }
        v8 = j[3];
      }
      while ( !v8 && j[5] != i[5] )
      {
        j = (_QWORD *)j[5];
        v8 = j[3];
      }
    }
    if ( j )
      break;
  }
  if ( j )
  {
    *a5 = a1;
    *a6 = v7;
    result = v7;
  }
  else
  {
    if ( *a5 )
    {
      *a5 = 0LL;
      *a6 = 0;
      i = a3;
      j = a3;
      v7 = 1;
      goto LABEL_15;
    }
    sub_12222(
      **(_QWORD **)(*a1 + 48LL),
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
      1319LL);
    result = 0LL;
  }
  return result;
}

//----- (00000000000C7C5E) ----------------------------------------------------
signed __int64 __fastcall sub_C7C5E(__int64 a1, _QWORD *a2, int a3)
{
  unsigned int v3; // eax
  signed __int64 v5; // rbx
  int v6; // [rsp+Ch] [rbp-44h]
  int v7; // [rsp+20h] [rbp-30h]
  unsigned int i; // [rsp+24h] [rbp-2Ch]
  __int64 v9; // [rsp+28h] [rbp-28h]
  _QWORD *v10; // [rsp+30h] [rbp-20h]
  unsigned __int64 v11; // [rsp+38h] [rbp-18h]

  v6 = a3;
  v11 = __readfsqword(0x28u);
  v9 = 0LL;
  v7 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    if ( !*(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) )
    {
      v10 = 0LL;
      v3 = *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8);
      if ( v3 >= 2 )
      {
        if ( v3 > 3 )
        {
          if ( v3 != 4 )
            continue;
          v10 = sub_BB881(a2, *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16)));
          if ( !v10 )
          {
            sub_12222(
              **(_QWORD **)(*a2 + 48LL),
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
              1367LL);
            return 0xFFFFFFFFLL;
          }
        }
        if ( !v10 )
          v10 = *(_QWORD **)(16LL * i + *(_QWORD *)(a1 + 16));
        v5 = *(_QWORD *)(a1 + 16) + 16LL * i;
        *(_DWORD *)(v5 + 12) = sub_C79D5(v10, *(_DWORD *)(v5 + 8), a2, v6, (_QWORD **)&v9, (unsigned int *)&v7);
      }
    }
  }
  return 0LL;
}

//----- (00000000000C7E06) ----------------------------------------------------
__int64 __fastcall sub_C7E06(__int64 a1, __int64 a2)
{
  unsigned __int16 v3; // [rsp+16h] [rbp-Ah]
  __int64 i; // [rsp+18h] [rbp-8h]

  v3 = 0;
  for ( i = *(_QWORD *)(a2 + 16); i && i != a1; i = *(_QWORD *)(i + 8) )
    ++v3;
  if ( !i )
    __assert_fail("attr2", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x57Eu, "get_attr_pos");
  return v3;
}

//----- (00000000000C7E78) ----------------------------------------------------
signed __int64 __fastcall sub_C7E78(__int64 a1, __int64 a2, _QWORD *a3)
{
  signed __int64 result; // rax
  _QWORD *v4; // [rsp+8h] [rbp-28h]
  unsigned int v5; // [rsp+20h] [rbp-10h]
  unsigned int v6; // [rsp+24h] [rbp-Ch]
  _QWORD *v7; // [rsp+28h] [rbp-8h]
  _QWORD *v8; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v5 = 0;
  v6 = 0;
  if ( *(_DWORD *)(a1 + 12) < *(_DWORD *)(a2 + 12) )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 12) > *(_DWORD *)(a2 + 12) )
    return 1LL;
  if ( *(_QWORD *)a1 != *(_QWORD *)a2 || *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8) )
  {
    if ( *(_DWORD *)(a1 + 8) == 4 )
    {
      v7 = sub_BB881(a3, *(_QWORD *)a1);
      if ( !v7 )
      {
        sub_12222(
          **(_QWORD **)(*v4 + 48LL),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          1454LL);
        return 0xFFFFFFFFLL;
      }
      v5 = (unsigned __int16)sub_C7E06(*(_QWORD *)a1, (__int64)v7);
    }
    if ( *(_DWORD *)(a2 + 8) == 4 )
    {
      v8 = sub_BB881(v4, *(_QWORD *)a2);
      if ( !v8 )
      {
        sub_12222(
          **(_QWORD **)(*v4 + 48LL),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          1462LL);
        return 0xFFFFFFFFLL;
      }
      v6 = (unsigned __int16)sub_C7E06(*(_QWORD *)a2, (__int64)v8);
    }
    if ( *(_QWORD *)a1 == *(_QWORD *)a2 )
    {
      if ( *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(_DWORD *)(a1 + 8) == 4 && v5 != v6 )
        __assert_fail(
          "(item1->type == item2->type) && ((item1->type != LYXP_NODE_ATTR) || (attr_pos1 == attr_pos2))",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x5BFu,
          "set_sort_compare");
      result = 0LL;
    }
    else if ( *(_DWORD *)(a1 + 8) == 2 )
    {
      if ( *(_DWORD *)(a2 + 8) == 2 )
        __assert_fail(
          "item2->type != LYXP_NODE_ELEM",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x5C6u,
          "set_sort_compare");
      result = 0xFFFFFFFFLL;
    }
    else if ( (*(_DWORD *)(a1 + 8) != 3 || *(_DWORD *)(a2 + 8) != 2 && *(_DWORD *)(a2 + 8) != 4)
           && (*(_DWORD *)(a1 + 8) != 4 || *(_DWORD *)(a2 + 8) != 2)
           && (*(_DWORD *)(a1 + 8) != 4 || *(_DWORD *)(a2 + 8) != 4 || v5 <= v6) )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      result = 1LL;
    }
  }
  else if ( *(_DWORD *)(a1 + 8) == 2 )
  {
    if ( *(_DWORD *)(a2 + 8) != 3 )
      __assert_fail(
        "item2->type == LYXP_NODE_TEXT",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x5A2u,
        "set_sort_compare");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) != 3 || *(_DWORD *)(a2 + 8) != 2 )
      __assert_fail(
        "(item1->type == LYXP_NODE_TEXT) && (item2->type == LYXP_NODE_ELEM)",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x5A5u,
        "set_sort_compare");
    result = 1LL;
  }
  return result;
}

//----- (00000000000C81AC) ----------------------------------------------------
signed __int64 __fastcall sub_C81AC(void *a1, __int64 a2, int a3, __int64 a4, __int64 *a5, unsigned int a6, int a7)
{
  __int64 *v8; // [rsp+8h] [rbp-28h]
  __int64 v9; // [rsp+10h] [rbp-20h]
  unsigned int v10; // [rsp+18h] [rbp-18h]
  int v11; // [rsp+1Ch] [rbp-14h]

  v11 = a3;
  v9 = a4;
  v8 = a5;
  v10 = a6;
  if ( *(_DWORD *)a2 != 1 )
    __assert_fail(
      "src->type == LYXP_SET_NODE_SET",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x5DDu,
      "set_comp_cast");
  memset(a1, 0, 0x40uLL);
  sub_C7395(
    (__int64)a1,
    *(_QWORD *)(16LL * v10 + *(_QWORD *)(a2 + 16)),
    *(_DWORD *)(16LL * v10 + *(_QWORD *)(a2 + 16) + 12),
    *(_DWORD *)(16LL * v10 + *(_QWORD *)(a2 + 16) + 8),
    0);
  if ( !(unsigned int)sub_DC765((__int64)a1, v11, v9, v8, a7) )
    return 0LL;
  sub_C65F5((__int64)a1);
  return 0xFFFFFFFFLL;
}

//----- (00000000000C8295) ----------------------------------------------------
signed __int64 __fastcall sub_C8295(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 *v15; // rax
  __int64 v16; // rdx
  __int64 *v17; // rdx
  _QWORD *v18; // rcx
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rdx
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  int v29; // [rsp+24h] [rbp-5Ch]
  unsigned int i; // [rsp+28h] [rbp-58h]
  unsigned int j; // [rsp+2Ch] [rbp-54h]
  unsigned int v32; // [rsp+30h] [rbp-50h]
  int v33; // [rsp+34h] [rbp-4Ch]
  _BOOL4 v34; // [rsp+38h] [rbp-48h]
  int v35; // [rsp+3Ch] [rbp-44h]
  _QWORD *v36; // [rsp+40h] [rbp-40h]
  __int64 v37; // [rsp+48h] [rbp-38h]
  __int64 v38; // [rsp+54h] [rbp-2Ch]
  int v39; // [rsp+5Ch] [rbp-24h]
  __int64 v40; // [rsp+60h] [rbp-20h]
  __int64 v41; // [rsp+68h] [rbp-18h]
  unsigned __int64 v42; // [rsp+78h] [rbp-8h]

  v42 = __readfsqword(0x28u);
  v32 = 0;
  if ( *(_DWORD *)a1 != 1 || *(_DWORD *)(a1 + 32) == 1 )
    return 0LL;
  v36 = (_QWORD *)sub_D2AFF(a2, a3, &v29);
  if ( (unsigned int)sub_C7C5E(a1, v36, v29) )
    return 0xFFFFFFFFLL;
  sub_12312(8u, (__int64)"SORT BEGIN", v4, v5, v6, v7);
  sub_C4D98(a1, (__int64)"SORT BEGIN", v8, v9, v10, v11);
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    v34 = 0;
    v35 = 0;
    for ( j = 1; j < *(_DWORD *)(a1 + 32) - i; ++j )
    {
      if ( v34 )
        v33 = sub_C7E78(*(_QWORD *)(a1 + 16) + 16LL * j, *(_QWORD *)(a1 + 16) + 16LL * (j - 1), v36);
      else
        v33 = sub_C7E78(*(_QWORD *)(a1 + 16) + 16LL * (j - 1), *(_QWORD *)(a1 + 16) + 16LL * j, v36);
      if ( (!v34 || v33 >= 0) && (v34 || v33 <= 0) )
      {
        v34 = !v34;
      }
      else
      {
        v35 = 1;
        v15 = (__int64 *)(16LL * (j - 1) + *(_QWORD *)(a1 + 16));
        v16 = v15[1];
        v40 = *v15;
        v41 = v16;
        v17 = (__int64 *)(*(_QWORD *)(a1 + 16) + 16LL * j);
        v18 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * (j - 1));
        v19 = *v17;
        v20 = v17[1];
        *v18 = v19;
        v18[1] = v20;
        v12 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * j);
        v21 = v41;
        *v12 = v40;
        v12[1] = v21;
      }
    }
    ++v32;
    if ( !v35 )
      break;
  }
  sub_12312(8u, (__int64)"SORT END %d", v32, (__int64)v12, v13, v14);
  sub_C4D98(a1, (__int64)"SORT END %d", v22, v23, v24, v25);
  if ( *(_DWORD *)(a1 + 32) > 3u )
  {
    if ( !*(_QWORD *)(a1 + 40) )
      __assert_fail("set->ht", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x63Au, "set_sort");
    for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
    {
      v38 = *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16));
      v39 = *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8);
      v26 = sub_1476E(0, (__int64)&v38, 8uLL);
      v37 = v26;
      v27 = sub_1476E(v26, (__int64)&v39, 4uLL);
      v37 = v27;
      v28 = sub_1476E(v27, 0LL, 0LL);
      v37 = v28;
      if ( (unsigned int)sub_154F1(*(_QWORD *)(a1 + 40), (__int64)&v38, v28, 0LL) )
        __assert_fail(
          "!lyht_find(set->ht, &hnode, hash, NULL)",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x643u,
          "set_sort");
    }
  }
  return v32 - 1;
}

//----- (00000000000C863F) ----------------------------------------------------
__int64 __fastcall sub_C863F(__int64 a1)
{
  unsigned int v2; // [rsp+18h] [rbp-8h]
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v2 = 0;
  v3 = 0;
  if ( *(_DWORD *)(a1 + 32) > 1u )
  {
    while ( v2 < *(_DWORD *)(a1 + 32) - 1 )
    {
      if ( *(_QWORD *)(16LL * v2 + *(_QWORD *)(a1 + 16)) != *(_QWORD *)(16LL * (v2 + 1) + *(_QWORD *)(a1 + 16))
        || *(_DWORD *)(16LL * v2 + *(_QWORD *)(a1 + 16) + 8) != *(_DWORD *)(16LL * (v2 + 1) + *(_QWORD *)(a1 + 16) + 8) )
      {
        ++v2;
      }
      else
      {
        sub_C6DA0((_DWORD *)a1, v2 + 1);
        v3 = 1;
      }
    }
  }
  return v3;
}

//----- (00000000000C870E) ----------------------------------------------------
signed __int64 __fastcall sub_C870E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r9
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  int v32; // [rsp+4h] [rbp-4Ch]
  __int64 v33; // [rsp+8h] [rbp-48h]
  int v34; // [rsp+24h] [rbp-2Ch]
  unsigned int v35; // [rsp+28h] [rbp-28h]
  unsigned int v36; // [rsp+2Ch] [rbp-24h]
  unsigned int v37; // [rsp+30h] [rbp-20h]
  int v38; // [rsp+34h] [rbp-1Ch]
  unsigned int i; // [rsp+38h] [rbp-18h]
  int v40; // [rsp+3Ch] [rbp-14h]
  _QWORD *v41; // [rsp+40h] [rbp-10h]
  unsigned __int64 v42; // [rsp+48h] [rbp-8h]

  v33 = a3;
  v32 = a4;
  v42 = __readfsqword(0x28u);
  if ( *(_DWORD *)a1 != 1 && *(_DWORD *)a1 || *(_DWORD *)a2 != 1 && *(_DWORD *)a2 )
    return 0xFFFFFFFFLL;
  if ( !*(_DWORD *)a2 )
    return 0LL;
  if ( *(_DWORD *)a1 )
  {
    v41 = (_QWORD *)sub_D2AFF(a3, a4, &v34);
    if ( (unsigned int)sub_C7C5E(a1, v41, v34) || (unsigned int)sub_C7C5E(a2, v41, v34) )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      sub_12312(8u, (__int64)"MERGE target", v7, v8, v9, v10);
      sub_C4D98(a1, (__int64)"MERGE target", v11, v12, v13, v14);
      sub_12312(8u, (__int64)"MERGE source", v15, v16, v17, v18);
      sub_C4D98(a2, (__int64)"MERGE source", v19, v20, v21, v22);
      if ( (unsigned int)(*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(a2 + 32)
        || (*(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 32) + *(_DWORD *)(a1 + 32),
            (*(_QWORD *)(a1 + 16) = sub_C422(*(void **)(a1 + 16), 16LL * *(unsigned int *)(a1 + 36))) != 0LL) )
      {
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = 0;
LABEL_17:
        v40 = sub_C7E78(*(_QWORD *)(a2 + 16) + 16LL * v35, *(_QWORD *)(a1 + 16) + 16LL * v36, v41);
        if ( !v40 )
        {
          if ( v37 )
          {
            ++v37;
            ++v38;
          }
          ++v35;
          ++v36;
          goto LABEL_26;
        }
        if ( v40 < 0 )
        {
          ++v37;
          ++v35;
          sub_C6158(
            a1,
            *(_QWORD *)(16LL * (v35 - 1) + *(_QWORD *)(a2 + 16)),
            *(_DWORD *)(16LL * (v35 - 1) + *(_QWORD *)(a2 + 16) + 8));
          goto LABEL_26;
        }
        if ( !v37 )
        {
          ++v36;
          goto LABEL_26;
        }
        while ( 1 )
        {
          memmove(
            (void *)(*(_QWORD *)(a1 + 16) + 16LL * (v37 - v38 + v36)),
            (const void *)(*(_QWORD *)(a1 + 16) + 16LL * v36),
            16LL * (*(_DWORD *)(a1 + 32) - v36));
          memcpy(
            (void *)(*(_QWORD *)(a1 + 16) + 16LL * (v36 - v38)),
            (const void *)(16LL * (v35 - v37) + *(_QWORD *)(a2 + 16)),
            16LL * v37);
          v24 = v37 - v38 + *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 32) = v24;
          v36 += v37 - v38;
          v37 = 0;
          v38 = 0;
LABEL_26:
          if ( v35 < *(_DWORD *)(a2 + 32) && v36 < *(_DWORD *)(a1 + 32) )
            goto LABEL_17;
          if ( v35 >= *(_DWORD *)(a2 + 32) && !v37 )
            break;
          for ( i = v35; i < *(_DWORD *)(a2 + 32); ++i )
            sub_C6158(
              a1,
              *(_QWORD *)(16LL * i + *(_QWORD *)(a2 + 16)),
              *(_DWORD *)(16LL * i + *(_QWORD *)(a2 + 16) + 8));
          v37 += *(_DWORD *)(a2 + 32) - v35;
          v35 = *(_DWORD *)(a2 + 32);
        }
        if ( !*(_QWORD *)(a1 + 40) && *(_DWORD *)(a1 + 32) > 3u )
          sub_C6158(a1, 0LL, 0);
        sub_12312(8u, (__int64)"MERGE result", v24, v25, v26, v27);
        sub_C4D98(a1, (__int64)"MERGE result", v28, v29, v30, v31);
        sub_DC765(a2, 0, v33, 0LL, v32);
        result = 0LL;
      }
      else
      {
        sub_12222(
          **(_QWORD **)(*(_QWORD *)v33 + 48LL),
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"set_sorted_merge",
          v23);
        result = 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    sub_C6A3F(a1, a2, a2, a4, a5, a6);
    sub_DC765(a2, 0, v33, 0LL, v32);
    result = 0LL;
  }
  return result;
}

//----- (00000000000C8BDA) ----------------------------------------------------
signed __int64 __fastcall sub_C8BDA(int *a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // r9
  int v4; // eax
  int v5; // eax
  long double v7; // [rsp+10h] [rbp-50h]
  int v8; // [rsp+34h] [rbp-2Ch]
  char *ptr; // [rsp+38h] [rbp-28h]
  char *endptr; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+48h] [rbp-18h]
  char *nptr; // [rsp+50h] [rbp-10h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  if ( *(_DWORD *)a2 != 1 )
    __assert_fail(
      "set2->type == LYXP_SET_NODE_SET",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x703u,
      "set_canonize");
  if ( *(_DWORD *)(*(_QWORD *)(a2 + 16) + 8LL) != 2 || !(*(_DWORD *)(***(_QWORD ***)(a2 + 16) + 56LL) & 0xC) )
    return 0LL;
  v11 = ***(_QWORD ***)(a2 + 16);
  v2 = *a1;
  if ( *a1 == 4 )
  {
    if ( asprintf(&ptr, "%Lf") == -1 )
    {
      sub_12222(**(_QWORD **)(v11 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"set_canonize", v3);
      return 0xFFFFFFFFLL;
    }
    sub_141E4(0LL, 2u, &v8, 0LL);
    v4 = strlen(ptr);
    nptr = sub_B02CA(v11, ptr, v4);
    sub_142D2(0LL, v8, 0LL, 0);
    free(ptr);
    if ( nptr )
    {
      v7 = strtold(nptr, &endptr);
      *((_QWORD *)a1 + 2) = *(_QWORD *)&v7;
      a1[6] = DWORD2(v7);
      if ( *endptr )
      {
        free(nptr);
        sub_12222(
          **(_QWORD **)(v11 + 48),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          1824LL,
          *(_OWORD *)&v7);
        return 0xFFFFFFFFLL;
      }
      free(nptr);
    }
  }
  else if ( v2 == 5 )
  {
    sub_141E4(0LL, 2u, &v8, 0LL);
    v5 = strlen(*((const char **)a1 + 2));
    nptr = sub_B02CA(v11, *((const char **)a1 + 2), v5);
    sub_142D2(0LL, v8, 0LL, 0);
    if ( nptr )
    {
      free(*((void **)a1 + 2));
      *((_QWORD *)a1 + 2) = nptr;
    }
  }
  else if ( v2 != 3 )
  {
    sub_12222(
      **(_QWORD **)(v11 + 48),
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
      1844LL);
    return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (00000000000C8ED8) ----------------------------------------------------
signed __int64 __fastcall sub_C8ED8(__int64 a1, int a2, __int16 a3, __int16 a4)
{
  unsigned int v4; // ST2C_4
  signed __int64 result; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int16 v9; // [rsp+Ch] [rbp-24h]
  __int16 v10; // [rsp+10h] [rbp-20h]

  v10 = a3;
  v9 = a4;
  if ( *(_WORD *)(a1 + 32) != *(_WORD *)(a1 + 34) )
    goto LABEL_13;
  v4 = *(unsigned __int16 *)(a1 + 34);
  *(_WORD *)(a1 + 34) += 5;
  if ( v4 > *(unsigned __int16 *)(a1 + 34) )
  {
    sub_12222(0LL, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c", 1880LL);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)a1 = sub_C422(*(void **)a1, 4LL * *(unsigned __int16 *)(a1 + 34));
  if ( !*(_QWORD *)a1 )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"exp_add_token", v6);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 8) = sub_C422(*(void **)(a1 + 8), 2LL * *(unsigned __int16 *)(a1 + 34));
  if ( !*(_QWORD *)(a1 + 8) )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"exp_add_token", v7);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 16) = sub_C422(*(void **)(a1 + 16), 2LL * *(unsigned __int16 *)(a1 + 34));
  if ( *(_QWORD *)(a1 + 16) )
  {
LABEL_13:
    *(_DWORD *)(4LL * *(unsigned __int16 *)(a1 + 32) + *(_QWORD *)a1) = a2;
    *(_WORD *)(2LL * *(unsigned __int16 *)(a1 + 32) + *(_QWORD *)(a1 + 8)) = v10;
    *(_WORD *)(2LL * (unsigned __int16)(*(_WORD *)(a1 + 32))++ + *(_QWORD *)(a1 + 16)) = v9;
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"exp_add_token", v8);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000000C9129) ----------------------------------------------------
signed __int64 __fastcall sub_C9129(void *a1, __int64 a2, unsigned __int16 a3, int a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rbx
  const char *v8; // rax

  if ( a3 == *(_WORD *)(a2 + 32) )
  {
    if ( (_DWORD)a5 )
      sub_13937(a1, 68, 0, 0LL, a5, a6);
    result = 0xFFFFFFFFLL;
  }
  else if ( a4 && a4 != *(_DWORD *)(4LL * a3 + *(_QWORD *)a2) )
  {
    if ( (_DWORD)a5 )
    {
      v7 = *(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(2LL * a3 + *(_QWORD *)(a2 + 8));
      v8 = sub_C49BD(*(_DWORD *)(4LL * a3 + *(_QWORD *)a2));
      sub_13937(a1, 67, 0, 0LL, (__int64)v8, v7);
    }
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (00000000000C9229) ----------------------------------------------------
_DWORD *__fastcall sub_C9229(__int64 a1, unsigned __int16 a2, __int16 a3)
{
  void **v3; // rbx
  __int64 v4; // r9
  _DWORD *result; // rax
  void **v6; // rbx
  __int64 v7; // r9
  __int64 v8; // [rsp+0h] [rbp-30h]
  unsigned __int16 i; // [rsp+1Eh] [rbp-12h]

  WORD2(v8) = a2;
  LOWORD(v8) = a3;
  if ( *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 24)) )
  {
    for ( i = 0; *(_DWORD *)(4LL * i + *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 24))); ++i )
      ;
    v3 = (void **)(*(_QWORD *)(a1 + 24) + 8LL * a2);
    *v3 = realloc(*v3, 4LL * (i + 2));
    if ( *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 24)) )
    {
      *(_DWORD *)(*(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 24)) + 4LL * i) = (unsigned __int16)v8;
      result = (_DWORD *)(4 * (i + 1LL) + *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 24)));
      *result = 0;
    }
    else
    {
      result = (_DWORD *)sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"exp_repeat_push", v4, v8);
    }
  }
  else
  {
    v6 = (void **)(*(_QWORD *)(a1 + 24) + 8LL * a2);
    *v6 = calloc(2uLL, 4uLL);
    if ( *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 24)) )
    {
      result = *(_DWORD **)(8LL * a2 + *(_QWORD *)(a1 + 24));
      *result = (unsigned __int16)v8;
    }
    else
    {
      result = (_DWORD *)sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"exp_repeat_push", v7, v8);
    }
  }
  return result;
}

//----- (00000000000C940B) ----------------------------------------------------
signed __int64 __fastcall sub_C940B(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // r9
  unsigned __int16 *v10; // [rsp+8h] [rbp-18h]

  v10 = a3;
  if ( (unsigned int)sub_C9129(a1, a2, *a3, 3, 1LL, a6) )
    return 0xFFFFFFFFLL;
  ++*v10;
  if ( (unsigned int)sub_CB062(a1, (_QWORD *)a2, v10, a2, v6, v7) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_C9129(a1, a2, *v10, 4, 1LL, v9) )
    return 0xFFFFFFFFLL;
  ++*v10;
  return 0LL;
}

//----- (00000000000C94CA) ----------------------------------------------------
signed __int64 __fastcall sub_C94CA(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // rbx
  const char *v10; // rax
  __int64 v11; // r9
  __int64 v12; // rbx
  const char *v13; // rax
  unsigned __int16 *v14; // [rsp+8h] [rbp-28h]

  v14 = a3;
  if ( (unsigned int)sub_C9129(a1, a2, *a3, 0, 1LL, a6) )
    return 0xFFFFFFFFLL;
  while ( 1 )
  {
    switch ( *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14) )
    {
      case 5:
        ++*v14;
        goto LABEL_26;
      case 6:
        ++*v14;
        goto LABEL_26;
      case 7:
        if ( (unsigned int)sub_C9129(a1, a2, ++*v14, 0, 1LL, v7) )
          return 0xFFFFFFFFLL;
        if ( *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14) != 9 && *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14) != 10 )
        {
          v9 = *(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v14);
          v10 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14));
          sub_13937(a1, 67, 0, 0LL, (__int64)v10, v9);
          return 0xFFFFFFFFLL;
        }
LABEL_13:
        ++*v14;
        break;
      case 9:
        goto LABEL_13;
      case 0xA:
        if ( (unsigned int)sub_C9129(a1, a2, ++*v14, 1, 1LL, v7) )
          return 0xFFFFFFFFLL;
        if ( !(unsigned int)sub_C9129(a1, a2, ++*v14, 2, 1LL, v11) )
        {
          ++*v14;
          break;
        }
        return 0xFFFFFFFFLL;
      default:
        v12 = *(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v14);
        v13 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14));
        sub_13937(a1, 67, 0, 0LL, (__int64)v13, v12);
        return 0xFFFFFFFFLL;
    }
    while ( *(_WORD *)(a2 + 32) > *v14 && *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14) == 3 )
    {
      if ( (unsigned int)sub_C940B(a1, a2, v14, a2, v6, v7) )
        return 0xFFFFFFFFLL;
    }
LABEL_26:
    if ( *(_WORD *)(a2 + 32) <= *v14 )
      return 0LL;
    if ( *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v14) != 16 )
      return 0LL;
    if ( (unsigned int)sub_C9129(a1, a2, ++*v14, 0, 1LL, v7) )
      return 0xFFFFFFFFLL;
  }
}

//----- (00000000000C989E) ----------------------------------------------------
signed __int64 __fastcall sub_C989E(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // eax
  unsigned __int16 *v12; // [rsp+8h] [rbp-18h]

  v12 = a3;
  if ( (unsigned int)sub_C9129(a1, (__int64)a2, *a3, 16, 1LL, a6) )
    return 0xFFFFFFFFLL;
  if ( *(_WORD *)(a2[2] + 2LL * *v12) == 1 )
  {
    if ( (unsigned int)sub_C9129(a1, (__int64)a2, ++*v12, 0, 0LL, v7) )
      return 0LL;
    v11 = *(_DWORD *)(*a2 + 4LL * *v12);
    if ( v11 >= 5 && (v11 <= 7 || v11 - 9 <= 1) && (unsigned int)sub_C94CA(a1, (__int64)a2, v12, (__int64)a2, v9, v10) )
      return 0xFFFFFFFFLL;
  }
  else
  {
    ++*v12;
    if ( (unsigned int)sub_C94CA(a1, (__int64)a2, v12, (__int64)a2, v6, v7) )
      return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (00000000000C99D7) ----------------------------------------------------
signed __int64 __fastcall sub_C99D7(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned __int16 *v11; // [rsp+8h] [rbp-28h]
  unsigned __int16 v12; // [rsp+22h] [rbp-Eh]
  signed int v13; // [rsp+24h] [rbp-Ch]
  signed int v14; // [rsp+28h] [rbp-8h]
  signed int v15; // [rsp+2Ch] [rbp-4h]

  v11 = a3;
  v13 = -1;
  if ( (unsigned int)sub_C9129(a1, a2, *a3, 11, 1LL, a6) )
    return 0xFFFFFFFFLL;
  v12 = *v11;
  switch ( *(unsigned __int16 *)(*(_QWORD *)(a2 + 16) + 2LL * *v11) )
  {
    case 3u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "not",
              3uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "sum",
                   3uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      break;
    case 4u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "lang",
              4uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "last",
                   4uLL) )
      {
        v13 = 0;
        v14 = 0;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "name",
                   4uLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "true",
                   4uLL) )
      {
        v13 = 0;
        v14 = 0;
      }
      break;
    case 5u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "count",
              5uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "false",
                   5uLL) )
      {
        v13 = 0;
        v14 = 0;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "floor",
                   5uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "round",
                   5uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "deref",
                   5uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      break;
    case 6u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "concat",
              6uLL) )
      {
        v13 = 2;
        v14 = 0x7FFFFFFF;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "number",
                   6uLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "string",
                   6uLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      break;
    case 7u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "boolean",
              7uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "ceiling",
                   7uLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "current",
                   7uLL) )
      {
        v13 = 0;
        v14 = 0;
      }
      break;
    case 8u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "contains",
              8uLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "position",
                   8uLL) )
      {
        v13 = 0;
        v14 = 0;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "re-match",
                   8uLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    case 9u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "substring",
              9uLL) )
      {
        v13 = 2;
        v14 = 3;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "translate",
                   9uLL) )
      {
        v13 = 3;
        v14 = 3;
      }
      break;
    case 0xAu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "local-name",
              0xAuLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "enum-value",
                   0xAuLL) )
      {
        v13 = 1;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "bit-is-set",
                   0xAuLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    case 0xBu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "starts-with",
              0xBuLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    case 0xCu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "derived-from",
              0xCuLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    case 0xDu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "namespace-uri",
              0xDuLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "string-length",
                   0xDuLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      break;
    case 0xFu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "normalize-space",
              0xFuLL) )
      {
        v13 = 0;
        v14 = 1;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
                   "substring-after",
                   0xFuLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    case 0x10u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "substring-before",
              0x10uLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    case 0x14u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11)),
              "derived-from-or-self",
              0x14uLL) )
      {
        v13 = 2;
        v14 = 2;
      }
      break;
    default:
      break;
  }
  if ( v13 == -1 )
  {
    sub_13937(
      a1,
      73,
      0,
      0LL,
      *(unsigned __int16 *)(*(_QWORD *)(a2 + 16) + 2LL * *v11),
      *(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v11));
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_C9129(a1, a2, ++*v11, 1, 1LL, v6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    ++*v11;
    v15 = 0;
    if ( (unsigned int)sub_C9129(a1, a2, *v11, 0, 1LL, v8) )
    {
      result = 0xFFFFFFFFLL;
    }
    else if ( *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v11) != 2
           && (v15 = 1, (unsigned int)sub_CB062(a1, (_QWORD *)a2, v11, a2, v9, v10)) )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      while ( *(_WORD *)(a2 + 32) > *v11 && *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v11) == 8 )
      {
        ++*v11;
        ++v15;
        if ( (unsigned int)sub_CB062(a1, (_QWORD *)a2, v11, a2, v9, v10) )
          return 0xFFFFFFFFLL;
      }
      if ( (unsigned int)sub_C9129(a1, a2, *v11, 2, 1LL, v10) )
      {
        result = 0xFFFFFFFFLL;
      }
      else
      {
        ++*v11;
        if ( v15 >= v13 && v15 <= v14 )
        {
          result = 0LL;
        }
        else
        {
          sub_13937(
            a1,
            74,
            0,
            0LL,
            (unsigned int)v15,
            *(unsigned __int16 *)(2LL * v12 + *(_QWORD *)(a2 + 16)),
            *(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(2LL * v12 + *(_QWORD *)(a2 + 8)));
          result = 0xFFFFFFFFLL;
        }
      }
    }
  }
  return result;
}

//----- (00000000000CA839) ----------------------------------------------------
signed __int64 __fastcall sub_CA839(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  signed __int64 result; // rax
  __int64 v9; // r9
  __int64 v10; // rbx
  const char *v11; // rax
  unsigned __int16 *v12; // [rsp+8h] [rbp-28h]

  v12 = a3;
  if ( (unsigned int)sub_C9129(a1, a2, *a3, 0, 1LL, a6) )
    return 0xFFFFFFFFLL;
  switch ( *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v12) )
  {
    case 1:
      ++*v12;
      if ( (unsigned int)sub_CB062(a1, (_QWORD *)a2, v12, a2, v6, v7) )
        return 0xFFFFFFFFLL;
      if ( !(unsigned int)sub_C9129(a1, a2, *v12, 2, 1LL, v9) )
      {
        ++*v12;
        break;
      }
      return 0xFFFFFFFFLL;
    case 5:
    case 6:
    case 7:
    case 9:
    case 0xA:
      if ( !(unsigned int)sub_C94CA(a1, a2, v12, a2, v6, v7) )
        goto LABEL_18;
      return 0xFFFFFFFFLL;
    case 0xB:
      if ( !(unsigned int)sub_C99D7(a1, a2, v12, a2, v6, v7) )
        break;
      return 0xFFFFFFFFLL;
    case 0x10:
      if ( (unsigned int)sub_C989E(a1, (_QWORD *)a2, v12, a2, v6, v7) )
        result = 0xFFFFFFFFLL;
      else
LABEL_18:
        result = 0LL;
      return result;
    case 0x11:
      ++*v12;
      break;
    case 0x12:
      ++*v12;
      break;
    default:
      v10 = *(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v12);
      v11 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a2 + 4LL * *v12));
      sub_13937(a1, 67, 0, 0LL, (__int64)v11, v10);
      return 0xFFFFFFFFLL;
  }
  while ( *(_WORD *)(a2 + 32) > *v12 && *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v12) == 3 )
  {
    if ( (unsigned int)sub_C940B(a1, a2, v12, a2, v6, v7) )
      return 0xFFFFFFFFLL;
  }
  if ( *(_WORD *)(a2 + 32) > *v12
    && *(_DWORD *)(*(_QWORD *)a2 + 4LL * *v12) == 16
    && (++*v12, (unsigned int)sub_C94CA(a1, a2, v12, a2, v6, v7)) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (00000000000CAB46) ----------------------------------------------------
signed __int64 __fastcall sub_CAB46(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  int i; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  unsigned __int16 *v14; // [rsp+8h] [rbp-28h]
  unsigned __int16 v15; // [rsp+2Eh] [rbp-2h]
  unsigned __int16 v16; // [rsp+2Eh] [rbp-2h]

  v14 = a3;
  v15 = *a3;
  for ( i = sub_C9129(a1, a2, *a3, 14, 0LL, a6);
        !i && *(_BYTE *)(*(_QWORD *)(a2 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2LL * *v14)) == 45;
        i = sub_C9129(a1, a2, *v14, 14, 0LL, v9) )
  {
    sub_C9229(a2, v15, 7);
    ++*v14;
  }
  v16 = *v14;
  if ( (unsigned int)sub_CA839(a1, a2, v14, a2, v7, v8) )
    return 0xFFFFFFFFLL;
  while ( !(unsigned int)sub_C9129(a1, a2, *v14, 15, 0LL, v10) )
  {
    sub_C9229(a2, v16, 8);
    ++*v14;
    if ( (unsigned int)sub_CA839(a1, a2, v14, a2, v12, v13) )
      return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (00000000000CAC93) ----------------------------------------------------
signed __int64 __fastcall sub_CAC93(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  unsigned __int16 *v11; // [rsp+8h] [rbp-28h]
  unsigned __int16 v12; // [rsp+2Ch] [rbp-4h]
  unsigned __int16 v13; // [rsp+2Eh] [rbp-2h]

  v11 = a3;
  v12 = *a3;
  while ( 2 )
  {
    v13 = *v11;
    if ( (unsigned int)sub_CAB46(a1, (__int64)a2, v11, (__int64)a2, a5, a6) )
      return 0xFFFFFFFFLL;
    while ( !(unsigned int)sub_C9129(a1, (__int64)a2, *v11, 14, 0LL, v6)
         && (*(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 42 || *(_WORD *)(a2[2] + 2LL * *v11) == 3) )
    {
      sub_C9229((__int64)a2, v13, 6);
      ++*v11;
      if ( (unsigned int)sub_CAB46(a1, (__int64)a2, v11, (__int64)a2, v8, v9) )
        return 0xFFFFFFFFLL;
    }
    if ( !(unsigned int)sub_C9129(a1, (__int64)a2, *v11, 14, 0LL, v10)
      && (*(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 43
       || *(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 45) )
    {
      sub_C9229((__int64)a2, v12, 5);
      ++*v11;
      continue;
    }
    break;
  }
  return 0LL;
}

//----- (00000000000CAE73) ----------------------------------------------------
signed __int64 __fastcall sub_CAE73(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  unsigned __int16 *v11; // [rsp+8h] [rbp-28h]
  unsigned __int16 v12; // [rsp+2Ch] [rbp-4h]
  unsigned __int16 v13; // [rsp+2Eh] [rbp-2h]

  v11 = a3;
  v12 = *a3;
  while ( 2 )
  {
    v13 = *v11;
    if ( (unsigned int)sub_CAC93(a1, a2, v11, (__int64)a2, a5, a6) )
      return 0xFFFFFFFFLL;
    while ( !(unsigned int)sub_C9129(a1, (__int64)a2, *v11, 13, 0LL, v6)
         && (*(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 60
          || *(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 62) )
    {
      sub_C9229((__int64)a2, v13, 4);
      ++*v11;
      if ( (unsigned int)sub_CAC93(a1, a2, v11, (__int64)a2, v8, v9) )
        return 0xFFFFFFFFLL;
    }
    if ( !(unsigned int)sub_C9129(a1, (__int64)a2, *v11, 13, 0LL, v10)
      && (*(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 61
       || *(_BYTE *)(a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * *v11)) == 33) )
    {
      sub_C9229((__int64)a2, v12, 3);
      ++*v11;
      continue;
    }
    break;
  }
  return 0LL;
}

//----- (00000000000CB062) ----------------------------------------------------
signed __int64 __fastcall sub_CB062(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  unsigned __int16 *v11; // [rsp+8h] [rbp-28h]
  unsigned __int16 v12; // [rsp+2Ch] [rbp-4h]
  unsigned __int16 v13; // [rsp+2Eh] [rbp-2h]

  v11 = a3;
  v12 = *a3;
  while ( 2 )
  {
    v13 = *v11;
    if ( (unsigned int)sub_CAE73(a1, a2, v11, (__int64)a2, a5, a6) )
      return 0xFFFFFFFFLL;
    while ( !(unsigned int)sub_C9129(a1, (__int64)a2, *v11, 12, 0LL, v6) && *(_WORD *)(a2[2] + 2LL * *v11) == 3 )
    {
      sub_C9229((__int64)a2, v13, 2);
      ++*v11;
      if ( (unsigned int)sub_CAE73(a1, a2, v11, (__int64)a2, v8, v9) )
        return 0xFFFFFFFFLL;
    }
    if ( !(unsigned int)sub_C9129(a1, (__int64)a2, *v11, 12, 0LL, v10) && *(_WORD *)(a2[2] + 2LL * *v11) == 2 )
    {
      sub_C9229((__int64)a2, v12, 1);
      ++*v11;
      continue;
    }
    break;
  }
  return 0LL;
}

//----- (00000000000CB1CB) ----------------------------------------------------
__int64 __fastcall sub_CB1CB(void *a1, char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  unsigned __int16 v9; // [rsp+1Eh] [rbp-12h]
  int v10; // [rsp+20h] [rbp-10h]
  int v11; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v12; // [rsp+28h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  v9 = 0;
  v11 = sub_3127E(a1, a2, &v10, (__int64)a2, a5, a6);
  if ( (v11 <= 96 || v11 > 122)
    && v11 != 95
    && (v11 <= 64 || v11 > 90)
    && v11 != 58
    && (v11 <= 879 || v11 > 0x1FFF || v11 == 894)
    && (v11 <= 191 || v11 > 767 || v11 == 215 || v11 == 247)
    && v11 != 8204
    && v11 != 8205
    && (v11 <= 8303 || v11 > 8591)
    && (v11 <= 11263 || v11 > 12271)
    && (v11 <= 12288 || v11 > 55295)
    && (v11 <= 63743 || v11 > 64975)
    && (v11 <= 65007 || v11 > 65533)
    && (v11 <= 0xFFFF || v11 > (signed int)&loc_EFFFF)
    || v11 == 58 )
  {
    return 0LL;
  }
  do
  {
    v9 += v10;
    if ( !a2[v9] )
      break;
    v11 = sub_3127E(a1, &a2[v9], &v10, (__int64)&a2[v9], v6, v7);
    if ( (v11 <= 96 || v11 > 122)
      && v11 != 95
      && v11 != 45
      && (v11 <= 64 || v11 > 90)
      && (v11 <= 47 || v11 > 57)
      && v11 != 58
      && v11 != 46
      && v11 != 183
      && (v11 <= 879 || v11 > 0x1FFF || v11 == 894)
      && (v11 <= 191 || v11 > 767 || v11 == 215 || v11 == 247)
      && v11 != 8204
      && v11 != 8205
      && (v11 <= 767 || v11 > 879)
      && (v11 <= 8303 || v11 > 8591)
      && (v11 <= 131854 || v11 > 8256)
      && (v11 <= 11263 || v11 > 12271)
      && (v11 <= 12288 || v11 > 55295)
      && (v11 <= 63743 || v11 > 64975)
      && (v11 <= 65007 || v11 > 65533)
      && (v11 <= 0xFFFF || v11 > (signed int)&loc_EFFFF) )
    {
      break;
    }
  }
  while ( v11 != 58 );
  return v9;
}

//----- (00000000000CB4D2) ----------------------------------------------------
_QWORD *__fastcall sub_CB4D2(void *a1, const char *a2)
{
  __int64 v2; // r9
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  int v9; // eax
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  char *v16; // rsi
  __int64 v17; // r9
  char *s; // [rsp+0h] [rbp-30h]
  unsigned __int16 v19; // [rsp+1Ah] [rbp-16h]
  unsigned __int16 k; // [rsp+1Ch] [rbp-14h]
  unsigned __int16 i; // [rsp+1Ch] [rbp-14h]
  unsigned __int16 j; // [rsp+1Ch] [rbp-14h]
  unsigned __int16 v23; // [rsp+1Ch] [rbp-14h]
  unsigned __int16 v24; // [rsp+1Eh] [rbp-12h]
  __int16 v25; // [rsp+1Eh] [rbp-12h]
  int v26; // [rsp+20h] [rbp-10h]
  signed int v27; // [rsp+24h] [rbp-Ch]
  _QWORD *v28; // [rsp+28h] [rbp-8h]

  s = (char *)a2;
  v19 = 0;
  v27 = 0;
  if ( strlen(a2) > 0xFFFF )
  {
    sub_12222((__int64)a1, 0, 3, "XPath expression cannot be longer than %ud characters.", 0xFFFFLL, v2, a2);
    return 0LL;
  }
  v28 = calloc(1uLL, 0x30uLL);
  if ( !v28 )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_parse_expr", v4, a2);
LABEL_134:
    sub_C488D((__int64)v28);
    return 0LL;
  }
  v28[5] = strdup(a2);
  if ( !v28[5] )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_parse_expr", v5, a2);
    goto LABEL_134;
  }
  *((_WORD *)v28 + 16) = 0;
  *((_WORD *)v28 + 17) = 10;
  *v28 = malloc(4LL * *((unsigned __int16 *)v28 + 17));
  if ( !*v28 )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_parse_expr", v6, a2);
    goto LABEL_134;
  }
  v28[1] = malloc(2LL * *((unsigned __int16 *)v28 + 17));
  if ( !v28[1] )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_parse_expr", v7, a2);
    goto LABEL_134;
  }
  v28[2] = malloc(2LL * *((unsigned __int16 *)v28 + 17));
  if ( !v28[2] )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_parse_expr", v8, a2);
    goto LABEL_134;
  }
  while ( a2[v19] == 32 || a2[v19] == 9 || a2[v19] == 10 || a2[v19] == 13 )
    ++v19;
  do
  {
    switch ( s[v19] )
    {
      case 40:
        k = 1;
        v26 = 1;
        if ( v27 && *((_WORD *)v28 + 16) && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) == 9 )
        {
          if ( *(_WORD *)(v28[2] + 2LL * *((unsigned __int16 *)v28 + 16) - 2) == 4
            && (!strncmp(&s[*(unsigned __int16 *)(v28[1] + 2LL * *((unsigned __int16 *)v28 + 16) - 2)], "node", 4uLL)
             || !strncmp(&s[*(unsigned __int16 *)(v28[1] + 2LL * *((unsigned __int16 *)v28 + 16) - 2)], "text", 4uLL))
            || *(_WORD *)(v28[2] + 2LL * *((unsigned __int16 *)v28 + 16) - 2) == 7
            && !strncmp(&s[*(unsigned __int16 *)(v28[1] + 2LL * *((unsigned __int16 *)v28 + 16) - 2)], "comment", 7uLL) )
          {
            *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) = 10;
          }
          else
          {
            *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) = 11;
          }
          v27 = 0;
        }
        goto LABEL_122;
      case 41:
        k = 1;
        v9 = sub_C8ED8((__int64)v28, 2, v19, 1);
        goto LABEL_123;
      case 91:
        k = 1;
        v9 = sub_C8ED8((__int64)v28, 3, v19, 1);
        goto LABEL_123;
      case 93:
        k = 1;
        v9 = sub_C8ED8((__int64)v28, 4, v19, 1);
        goto LABEL_123;
    }
    if ( !strncmp(&s[v19], "..", 2uLL) )
    {
      k = 2;
      v9 = sub_C8ED8((__int64)v28, 6, v19, 2);
      goto LABEL_123;
    }
    if ( s[v19] == 46 && !((*__ctype_b_loc())[s[v19 + 1]] & 0x800) )
    {
      k = 1;
      v9 = sub_C8ED8((__int64)v28, 5, v19, 1);
      goto LABEL_123;
    }
    switch ( s[v19] )
    {
      case 64:
        k = 1;
        v9 = sub_C8ED8((__int64)v28, 7, v19, 1);
        goto LABEL_123;
      case 44:
        k = 1;
        v9 = sub_C8ED8((__int64)v28, 8, v19, 1);
        goto LABEL_123;
      case 39:
        for ( i = 1; s[v19 + i] && s[v19 + i] != 39; ++i )
          ;
        if ( !s[v19 + i] )
        {
          sub_13937(a1, 77, 0, 0LL, (unsigned int)s[v19], (__int64)&s[v19], s);
          goto LABEL_134;
        }
        k = i + 1;
        v26 = 17;
        goto LABEL_122;
      case 34:
        for ( j = 1; s[v19 + j] && s[v19 + j] != 34; ++j )
          ;
        if ( !s[v19 + j] )
        {
          sub_13937(a1, 77, 0, 0LL, (unsigned int)s[v19], (__int64)&s[v19], s);
          goto LABEL_134;
        }
        k = j + 1;
        v26 = 17;
        goto LABEL_122;
    }
    if ( s[v19] == 46 || (*__ctype_b_loc())[s[v19]] & 0x800 )
    {
      for ( k = 0; (*__ctype_b_loc())[s[v19 + k]] & 0x800; ++k )
        ;
      if ( s[v19 + k] == 46 )
      {
        ++k;
        while ( (*__ctype_b_loc())[s[v19 + k]] & 0x800 )
          ++k;
      }
      v9 = sub_C8ED8((__int64)v28, 18, v19, k);
    }
    else if ( s[v19] == 47 )
    {
      if ( !strncmp(&s[v19], "//", 2uLL) )
        k = 2;
      else
        k = 1;
      v9 = sub_C8ED8((__int64)v28, 16, v19, k);
    }
    else
    {
      if ( !strncmp(&s[v19], "!=", 2uLL) || !strncmp(&s[v19], "<=", 2uLL) || !strncmp(&s[v19], ">=", 2uLL) )
      {
        k = 2;
        v9 = sub_C8ED8((__int64)v28, 13, v19, 2);
        goto LABEL_123;
      }
      switch ( s[v19] )
      {
        case 124:
          k = 1;
          v9 = sub_C8ED8((__int64)v28, 15, v19, 1);
          goto LABEL_123;
        case 43:
        case 45:
          k = 1;
          v9 = sub_C8ED8((__int64)v28, 14, v19, 1);
          goto LABEL_123;
        case 61:
        case 60:
        case 62:
          k = 1;
          v9 = sub_C8ED8((__int64)v28, 13, v19, 1);
          goto LABEL_123;
      }
      if ( *((_WORD *)v28 + 16)
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 7
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 1
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 3
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 8
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 12
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 13
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 14
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 15
        && *(_DWORD *)(*v28 + 4LL * *((unsigned __int16 *)v28 + 16) - 4) != 16 )
      {
        if ( s[v19] == 42 )
        {
          k = 1;
          v9 = sub_C8ED8((__int64)v28, 14, v19, 1);
        }
        else if ( !strncmp(&s[v19], "or", 2uLL) )
        {
          k = 2;
          v9 = sub_C8ED8((__int64)v28, 12, v19, 2);
        }
        else if ( !strncmp(&s[v19], "and", 3uLL) )
        {
          k = 3;
          v9 = sub_C8ED8((__int64)v28, 12, v19, 3);
        }
        else
        {
          if ( strncmp(&s[v19], "mod", 3uLL) && strncmp(&s[v19], "div", 3uLL) )
          {
            sub_13937(a1, 55, 0, 0LL, (unsigned int)s[v19], (__int64)&s[v19], s);
            if ( v27 )
              sub_13937(
                a1,
                -1,
                5u,
                0LL,
                (__int64)"Perhaps \"%.*s\" is supposed to be a function call.",
                *(unsigned __int16 *)(v28[2] + 2LL * *((unsigned __int16 *)v28 + 16) - 2),
                v28[5] + *(unsigned __int16 *)(v28[1] + 2LL * *((unsigned __int16 *)v28 + 16) - 2));
            goto LABEL_134;
          }
          k = 3;
          v9 = sub_C8ED8((__int64)v28, 14, v19, 3);
        }
      }
      else
      {
        if ( s[v19] == 42 )
        {
          k = 1;
          v9 = sub_C8ED8((__int64)v28, 9, v19, 1);
          goto LABEL_123;
        }
        v24 = sub_CB1CB(a1, &s[v19], (__int64)&s[v19], v10, v11, v12);
        if ( !v24 )
        {
          sub_13937(a1, 55, 0, 0LL, (unsigned int)s[v19], (__int64)&s[v19], s);
          goto LABEL_134;
        }
        k = v24;
        if ( s[v19 + v24] != 58 )
        {
          v27 = 1;
          v26 = 9;
LABEL_122:
          v9 = sub_C8ED8((__int64)v28, v26, v19, k);
          goto LABEL_123;
        }
        v23 = v24 + 1;
        if ( s[v19 + (unsigned __int16)(v24 + 1)] == 42 )
        {
          k = v24 + 2;
        }
        else
        {
          v16 = &s[v19 + v23];
          v25 = sub_CB1CB(a1, v16, (__int64)v16, v13, v14, v15);
          if ( !v25 )
          {
            sub_13937(a1, 55, 0, 0LL, (unsigned int)s[v19], (__int64)&s[v19], s);
            goto LABEL_134;
          }
          k = v25 + v23;
        }
        v27 = 0;
        v9 = sub_C8ED8((__int64)v28, 9, v19, k);
      }
    }
LABEL_123:
    if ( v9 )
      goto LABEL_134;
    for ( v19 += k; s[v19] == 32 || s[v19] == 9 || s[v19] == 10 || s[v19] == 13; ++v19 )
      ;
  }
  while ( s[v19] );
  v28[3] = calloc(*((unsigned __int16 *)v28 + 17), 8uLL);
  if ( !v28[3] )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_parse_expr", v17, s);
    goto LABEL_134;
  }
  return v28;
}

//----- (00000000000CC407) ----------------------------------------------------
__int64 __fastcall sub_CC407(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-4h]

  if ( !a1 || *(_DWORD *)a1 != 2 )
    return 0LL;
  v2 = *(_DWORD *)(a1 + 32);
  do
  {
    if ( *(_DWORD *)(16LL * --v2 + *(_QWORD *)(a1 + 16) + 12) == 1 )
      return *(_QWORD *)(16LL * v2 + *(_QWORD *)(a1 + 16));
  }
  while ( v2 );
  return 0LL;
}

//----- (00000000000CC474) ----------------------------------------------------
__int64 __fastcall sub_CC474(signed __int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+10h] [rbp-20h]
  int v3; // [rsp+14h] [rbp-1Ch]
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 v5; // [rsp+20h] [rbp-10h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v5 = 0LL;
  v2 = 0;
  switch ( *(_DWORD *)a1 )
  {
    case 4:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      result = 1LL;
      break;
    case 9:
      if ( *(_QWORD *)(a1 + 40) )
      {
        result = sub_CC474(*(_QWORD *)(a1 + 40) + 128LL);
      }
      else
      {
        if ( a1 != *(_QWORD *)(a1 + 24) + 128LL )
          __assert_fail(
            "&((struct lys_node_leaf *)type->parent)->type == type",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0xBADu,
            "warn_is_numeric_type");
        for ( i = *(_QWORD *)(a1 + 24); i && *(_DWORD *)(i + 56) != 2048; i = *(_QWORD *)(i + 64) )
          ;
        if ( !i )
          sub_12222(
            **(_QWORD **)(*(_QWORD *)(a1 + 24) + 48LL),
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
            2992LL);
        result = 0LL;
      }
      break;
    case 0xB:
      while ( 1 )
      {
        v5 = sub_3A9DE(a1, v5, &v2);
        if ( !v5 )
          break;
        v2 = 0;
        v3 = sub_CC474(v5);
        if ( v3 )
          return 1LL;
      }
      result = 0LL;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000CC619) ----------------------------------------------------
__int64 __fastcall sub_CC619(signed __int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+18h] [rbp-18h]
  int v3; // [rsp+1Ch] [rbp-14h]
  __int64 v4; // [rsp+20h] [rbp-10h]
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v4 = 0LL;
  v2 = 0;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
    case 6:
    case 7:
    case 8:
    case 0xA:
      result = 1LL;
      break;
    case 9:
      if ( *(_QWORD *)(a1 + 40) )
        result = sub_CC619(*(_QWORD *)(a1 + 40) + 128LL);
      else
        result = 0LL;
      break;
    case 0xB:
      while ( 1 )
      {
        v4 = sub_3A9DE(a1, v4, &v2);
        if ( !v4 )
          break;
        v2 = 0;
        v3 = sub_CC619(v4);
        if ( v3 )
          return 1LL;
      }
      result = 0LL;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000CC70D) ----------------------------------------------------
__int64 __fastcall sub_CC70D(signed __int64 a1, unsigned int a2)
{
  __int64 result; // rax
  int v3; // [rsp+18h] [rbp-18h]
  int v4; // [rsp+1Ch] [rbp-14h]
  __int64 v5; // [rsp+20h] [rbp-10h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v5 = 0LL;
  v3 = 0;
  if ( a2 == *(_DWORD *)a1 )
    return 1LL;
  if ( *(_DWORD *)a1 == 11 )
  {
    while ( 1 )
    {
      v5 = sub_3A9DE(a1, v5, &v3);
      if ( !v5 )
        break;
      v3 = 0;
      v4 = sub_CC70D(v5, a2);
      if ( v4 )
        return 1LL;
    }
    result = 0LL;
  }
  else if ( *(_DWORD *)a1 == 9 )
  {
    if ( *(_QWORD *)(a1 + 40) )
      result = sub_CC70D(*(_QWORD *)(a1 + 40) + 128LL, a2);
    else
      result = 1LL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (00000000000CC805) ----------------------------------------------------
unsigned __int64 __fastcall sub_CC805(signed __int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax
  int v3; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v3 = 0;
  if ( *(_DWORD *)a1 == 9 )
  {
    if ( *(_QWORD *)(a1 + 40) )
      result = sub_CC805(*(_QWORD *)(a1 + 40) + 128LL, a2);
    else
      result = a1;
  }
  else if ( *(_DWORD *)a1 == 11 )
  {
    result = sub_3A9DE(a1, a2, &v3);
  }
  else if ( a2 )
  {
    if ( a1 != a2 )
      __assert_fail(
        "type == prev_type",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0xC16u,
        "warn_is_equal_type_next_type");
    result = 0LL;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (00000000000CC8D8) ----------------------------------------------------
signed __int64 __fastcall sub_CC8D8(signed __int64 a1, signed __int64 a2)
{
  _DWORD *i; // rax
  _DWORD *j; // rax
  _DWORD *v5; // [rsp+10h] [rbp-10h]

  for ( i = (_DWORD *)sub_CC805(a1, 0LL); ; i = (_DWORD *)sub_CC805(a1, (__int64)v5) )
  {
    v5 = i;
    if ( !i )
      break;
    if ( *i == 9 )
      return 1LL;
    for ( j = (_DWORD *)sub_CC805(a2, 0LL); j; j = (_DWORD *)sub_CC805(a2, (__int64)j) )
    {
      if ( *j == 9 )
        return 1LL;
      if ( *j == *v5 )
        return 1LL;
    }
  }
  return 0LL;
}

//----- (00000000000CC97E) ----------------------------------------------------
unsigned __int64 __fastcall sub_CC97E(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, unsigned __int16 a6)
{
  __int64 v6; // ST18_8
  unsigned __int64 result; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  __int64 v10; // r9
  __int64 v11; // rbx
  const char *v12; // rax
  __int64 v13; // r9
  __int64 v14; // [rsp+8h] [rbp-58h]
  unsigned __int16 v15; // [rsp+10h] [rbp-50h]
  int v16; // [rsp+14h] [rbp-4Ch]
  signed int v17; // [rsp+38h] [rbp-28h]
  signed int v18; // [rsp+3Ch] [rbp-24h]
  __int64 v19; // [rsp+40h] [rbp-20h]
  unsigned __int64 v20; // [rsp+48h] [rbp-18h]

  v6 = a3;
  v16 = a4;
  v14 = a5;
  v15 = a6;
  v17 = 1;
  v18 = 0;
  v19 = sub_CC407(a2);
  result = sub_CC407(v6);
  v20 = result;
  if ( v19 || result )
  {
    if ( v19 )
    {
      result = *(_DWORD *)(v19 + 56) & 0xC;
      if ( (_DWORD)result )
      {
        if ( v16 )
        {
          result = sub_CC474(v19 + 128);
          if ( !(_DWORD)result )
          {
            result = sub_12222(
                       a1,
                       1u,
                       0,
                       "Node \"%s\" is not of a numeric type, but used where it was expected.",
                       *(_QWORD *)v19,
                       v10);
            v18 = 1;
          }
        }
      }
      else
      {
        v8 = *(_QWORD *)v19;
        v9 = sub_8164(*(_DWORD *)(v19 + 56));
        result = sub_12222(a1, 1u, 0, "Node type %s \"%s\" used as operand.", (__int64)v9, v8);
        v18 = 1;
        v17 = 0;
      }
    }
    if ( v20 )
    {
      result = *(_DWORD *)(v20 + 56) & 0xC;
      if ( (_DWORD)result )
      {
        if ( v16 )
        {
          result = sub_CC474(v20 + 128);
          if ( !(_DWORD)result )
          {
            result = sub_12222(
                       a1,
                       1u,
                       0,
                       "Node \"%s\" is not of a numeric type, but used where it was expected.",
                       *(_QWORD *)v20,
                       v13);
            v18 = 1;
          }
        }
      }
      else
      {
        v11 = *(_QWORD *)v20;
        v12 = sub_8164(*(_DWORD *)(v20 + 56));
        result = sub_12222(a1, 1u, 0, "Node type %s \"%s\" used as operand.", (__int64)v12, v11);
        v18 = 1;
        v17 = 0;
      }
    }
    if ( v19 && v20 && v17 && !v16 )
    {
      if ( (unsigned int)sub_CC474(v19 + 128) && !(unsigned int)sub_CC474(v20 + 128)
        || !(unsigned int)sub_CC474(v19 + 128) && (unsigned int)sub_CC474(v20 + 128)
        || (result = sub_CC474(v19 + 128), !(_DWORD)result)
        && (result = sub_CC474(v20 + 128), !(_DWORD)result)
        && (result = sub_CC8D8(v19 + 128, v20 + 128), !(_DWORD)result) )
      {
        result = sub_12222(
                   a1,
                   1u,
                   0,
                   "Incompatible types of operands \"%s\" and \"%s\" for comparison.",
                   *(_QWORD *)v19,
                   *(_QWORD *)v20);
        v18 = 1;
      }
    }
    if ( v18 )
      result = sub_12222(a1, 1u, 0, "Previous warning generated by XPath subexpression[%u] \"%.20s\".", v15, v15 + v14);
  }
  return result;
}

//----- (00000000000CCC96) ----------------------------------------------------
unsigned __int64 __fastcall sub_CCC96(__int64 a1, _QWORD *a2, __int64 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int16 a6)
{
  __int64 v6; // r9
  unsigned __int16 v8; // [rsp+Ch] [rbp-44h]
  unsigned __int16 v9; // [rsp+10h] [rbp-40h]
  unsigned __int16 v10; // [rsp+14h] [rbp-3Ch]
  int v11; // [rsp+30h] [rbp-20h]
  int v12; // [rsp+34h] [rbp-1Ch]
  char *s; // [rsp+38h] [rbp-18h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v10 = a4;
  v9 = a5;
  v8 = a6;
  v15 = __readfsqword(0x28u);
  v14 = sub_CC407(a3);
  if ( v14 && *(_DWORD *)(v14 + 56) & 0xC && (*(_DWORD *)(4LL * v10 + *a2) == 17 || *(_DWORD *)(4LL * v10 + *a2) == 18) )
  {
    if ( *(_DWORD *)(4LL * v10 + *a2) == 17 )
      s = strndup(
            (const char *)(a2[5] + *(unsigned __int16 *)(2LL * v10 + a2[1]) + 1LL),
            *(unsigned __int16 *)(2LL * v10 + a2[2]) - 2);
    else
      s = strndup(
            (const char *)(a2[5] + *(unsigned __int16 *)(2LL * v10 + a2[1])),
            *(unsigned __int16 *)(2LL * v10 + a2[2]));
    if ( s )
    {
      if ( *(_DWORD *)(v14 + 128) == 7 && !strchr(s, 58) )
      {
        sub_12222(
          a1,
          1u,
          0,
          "Identityref \"%s\" comparison with identity \"%s\" without prefix, consider adding a prefix or best using \"de"
          "rived-from(-or-self)()\" functions.",
          *(_QWORD *)v14,
          (__int64)s);
        sub_12222(
          a1,
          1u,
          0,
          "Previous warning generated by XPath subexpression[%u] \"%.*s\".",
          *(unsigned __int16 *)(2LL * v9 + a2[1]),
          *(unsigned __int16 *)(2LL * v8 + a2[2])
        + *(unsigned __int16 *)(2LL * v8 + a2[1])
        - (unsigned int)*(unsigned __int16 *)(2LL * v9 + a2[1]),
          a2[5] + *(unsigned __int16 *)(2LL * v9 + a2[1]));
      }
      if ( *(_DWORD *)(v14 + 128) != 7 || *(_BYTE *)(lys_node_module(v14) + 64) & 0x80 )
      {
        sub_141E4(0LL, 3u, &v11, 0LL);
        v12 = lyd_validate_value(v14, s);
        sub_142D2(0LL, v11, 0LL, 0);
        if ( v12 )
          sub_12222(
            a1,
            1u,
            0,
            "Previous warning generated by XPath subexpression[%u] \"%.*s\".",
            *(unsigned __int16 *)(2LL * v9 + a2[1]),
            *(unsigned __int16 *)(2LL * v8 + a2[2])
          + *(unsigned __int16 *)(2LL * v8 + a2[1])
          - (unsigned int)*(unsigned __int16 *)(2LL * v9 + a2[1]),
            a2[5] + *(unsigned __int16 *)(2LL * v9 + a2[1]));
      }
      free(s);
    }
    else
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"warn_equality_value", v6);
    }
  }
  return __readfsqword(0x28u) ^ v15;
}
// 7720: using guessed type __int64 __fastcall lyd_validate_value(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000CD097) ----------------------------------------------------
signed __int64 __fastcall sub_CD097(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  const char *v11; // rax
  _DWORD *v12; // [rsp+8h] [rbp-58h]
  __int64 *v13; // [rsp+10h] [rbp-50h]
  int i; // [rsp+34h] [rbp-2Ch]
  unsigned int v15; // [rsp+38h] [rbp-28h]
  int v16; // [rsp+3Ch] [rbp-24h]
  _QWORD *v17; // [rsp+40h] [rbp-20h]
  __int64 v18; // [rsp+48h] [rbp-18h]
  __int64 v19; // [rsp+48h] [rbp-18h]

  v13 = a4;
  v12 = a5;
  v15 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v18 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v18 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v18 + 128, 2u) )
        {
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"bits\".",
            (__int64)"xpath_bit_is_set",
            *(_QWORD *)v18);
          v15 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v18;
        v7 = sub_8164(*(_DWORD *)(v18 + 56));
        sub_12222(*v13, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_bit_is_set", (__int64)v7, v6);
        v15 = 1;
      }
    }
    else
    {
      sub_12222(*v13, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_bit_is_set", a6);
      v15 = 1;
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v19 = sub_CC407(a1[1]);
      if ( v19 )
      {
        if ( *(_DWORD *)(v19 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v19 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_bit_is_set",
              *(_QWORD *)v19);
            v15 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v19;
          v9 = sub_8164(*(_DWORD *)(v19 + 56));
          sub_12222(*v13, 1u, 0, "Argument #2 of %s is a %s node \"%s\".", (__int64)"xpath_bit_is_set", (__int64)v9, v8);
          v15 = 1;
        }
      }
    }
    sub_C6D49((__int64)v12);
    result = v15;
  }
  else if ( *(_DWORD *)*a1 != 1 && *(_DWORD *)*a1 )
  {
    v11 = sub_C494A((_DWORD *)*a1);
    sub_13937((void *)*v13, 75, 0, 0LL, 1LL, (__int64)v11, "bit-is-set(node-set, string)");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_C6A0D(v12, 0);
    if ( *(_DWORD *)*a1 == 1 )
    {
      v17 = **(_QWORD ***)(*a1 + 16);
      if ( *(_DWORD *)(*v17 + 56LL) & 0xC )
      {
        if ( *(_DWORD *)(*v17 + 128LL) == 2 )
        {
          v16 = *(_DWORD *)(*v17 + 168LL);
          for ( i = 0; i < v16; ++i )
          {
            if ( *(_QWORD *)(8LL * i + v17[8])
              && (unsigned int)sub_C462(**(_BYTE ***)(8LL * i + v17[8]), *(_BYTE **)(a1[1] + 16)) )
            {
              sub_C6A0D(v12, 1);
              break;
            }
          }
        }
      }
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000CD490) ----------------------------------------------------
__int64 __fastcall sub_CD490(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, char a6)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // [rsp+8h] [rbp-28h]

  v10 = a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49(a5);
  }
  else
  {
    sub_DC765(*a1, 3, a3, a4, a6);
    sub_C6A3F(v10, *a1, *a1, v7, v8, v9);
  }
  return 0LL;
}

//----- (00000000000CD50E) ----------------------------------------------------
signed __int64 __fastcall sub_CD50E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  signed __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // [rsp+28h] [rbp-48h]
  __int64 *v14; // [rsp+30h] [rbp-40h]
  unsigned int v15; // [rsp+54h] [rbp-1Ch]
  __int64 v16; // [rsp+58h] [rbp-18h]

  v14 = a4;
  v13 = a5;
  v15 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v16 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v16 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v16 + 128, 4u) )
        {
          sub_12222(
            *v14,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"decimal64\".",
            (__int64)"xpath_ceiling",
            *(_QWORD *)v16);
          v15 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v16;
        v7 = sub_8164(*(_DWORD *)(v16 + 56));
        sub_12222(*v14, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_ceiling", (__int64)v7, v6);
        v15 = 1;
      }
    }
    else
    {
      sub_12222(*v14, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_ceiling", a6);
      v15 = 1;
    }
    sub_C6D49(v13);
    result = v15;
  }
  else if ( (unsigned int)sub_DC765(*a1, 4, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( *(long double *)(*a1 + 16) == (long double)(signed __int64)*(long double *)(*a1 + 16) )
      sub_C69DE(v13, 4LL, v9, v10, v11, v12, COERCE__INT128(*(long double *)(*a1 + 16)));
    else
      sub_C69DE(
        v13,
        4LL,
        v9,
        v10,
        v11,
        v12,
        COERCE__INT128((long double)((signed __int64)*(long double *)(*a1 + 16) + 1)));
    result = 0LL;
  }
  return result;
}

//----- (00000000000CD74E) ----------------------------------------------------
signed __int64 __fastcall sub_CD74E(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  signed __int64 result; // rax
  size_t v9; // rax
  __int64 v10; // r9
  __int64 v11; // [rsp+8h] [rbp-58h]
  __int64 *v12; // [rsp+10h] [rbp-50h]
  __int64 v13; // [rsp+18h] [rbp-48h]
  int v14; // [rsp+20h] [rbp-40h]
  unsigned __int16 i; // [rsp+32h] [rbp-2Eh]
  unsigned __int16 j; // [rsp+32h] [rbp-2Eh]
  unsigned int v17; // [rsp+34h] [rbp-2Ch]
  void *ptr; // [rsp+38h] [rbp-28h]
  signed __int64 v19; // [rsp+40h] [rbp-20h]
  __int64 v20; // [rsp+48h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v14 = a6;
  ptr = 0LL;
  v19 = 1LL;
  v17 = 0;
  if ( a6 & 0x3C )
  {
    for ( i = 0; i < a2; ++i )
    {
      if ( **(_DWORD **)(8LL * i + a1) == 2 )
      {
        v20 = sub_CC407(*(_QWORD *)(8LL * i + a1));
        if ( v20 )
        {
          if ( *(_DWORD *)(v20 + 56) & 0xC )
          {
            if ( !(unsigned int)sub_CC619(v20 + 128) )
            {
              sub_12222(
                *v12,
                1u,
                0,
                "Argument #%u of %s is node \"%s\", not of string-type.",
                (unsigned int)i + 1,
                (__int64)"xpath_concat",
                *(_QWORD *)v20);
              v17 = 1;
            }
          }
          else
          {
            v6 = *(_QWORD *)v20;
            v7 = sub_8164(*(_DWORD *)(v20 + 56));
            sub_12222(
              *v12,
              1u,
              0,
              "Argument #%u of %s is a %s node \"%s\".",
              (unsigned int)i + 1,
              (__int64)"xpath_concat",
              v7,
              v6);
            v17 = 1;
          }
        }
      }
    }
    sub_C6D49(v11);
    result = v17;
  }
  else
  {
    for ( j = 0; j < a2; ++j )
    {
      if ( (unsigned int)sub_DC765(*(_QWORD *)(8LL * j + a1), 5, v13, v12, v14) )
      {
        free(ptr);
        return 0xFFFFFFFFLL;
      }
      v9 = strlen(*(const char **)(*(_QWORD *)(8LL * j + a1) + 16LL));
      ptr = sub_C422(ptr, v19 + v9);
      if ( !ptr )
      {
        sub_12222(*v12, 0, 1, "Memory allocation failed (%s()).", (__int64)"xpath_concat", v10);
        return 0xFFFFFFFFLL;
      }
      strcpy((char *)ptr + v19 - 1, *(const char **)(*(_QWORD *)(8LL * j + a1) + 16LL));
      v19 += strlen(*(const char **)(*(_QWORD *)(8LL * j + a1) + 16LL));
    }
    sub_DC765(v11, 0, v13, v12, v14);
    *(_DWORD *)v11 = 5;
    *(_QWORD *)(v11 + 16) = ptr;
    result = 0LL;
  }
  return result;
}

//----- (00000000000CDA61) ----------------------------------------------------
signed __int64 __fastcall sub_CDA61(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  _DWORD *v11; // [rsp+8h] [rbp-48h]
  __int64 *v12; // [rsp+10h] [rbp-40h]
  __int64 v13; // [rsp+18h] [rbp-38h]
  int v14; // [rsp+20h] [rbp-30h]
  unsigned int v15; // [rsp+34h] [rbp-1Ch]
  __int64 v16; // [rsp+38h] [rbp-18h]
  __int64 v17; // [rsp+38h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v14 = a6;
  v15 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v16 = sub_CC407(*a1);
      if ( v16 )
      {
        if ( *(_DWORD *)(v16 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v16 + 128) )
          {
            sub_12222(
              *v12,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_contains",
              *(_QWORD *)v16);
            v15 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v16;
          v7 = sub_8164(*(_DWORD *)(v16 + 56));
          sub_12222(*v12, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_contains", (__int64)v7, v6);
          v15 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v17 = sub_CC407(a1[1]);
      if ( v17 )
      {
        if ( *(_DWORD *)(v17 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v17 + 128) )
          {
            sub_12222(
              *v12,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_contains",
              *(_QWORD *)v17);
            v15 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v17;
          v9 = sub_8164(*(_DWORD *)(v17 + 56));
          sub_12222(*v12, 1u, 0, "Argument #2 of %s is a %s node \"%s\".", (__int64)"xpath_contains", (__int64)v9, v8);
          v15 = 1;
        }
      }
    }
    sub_C6D49((__int64)v11);
    result = v15;
  }
  else if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, v13, v12, v14) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( strstr(*(const char **)(*a1 + 16), *(const char **)(a1[1] + 16)) )
      sub_C6A0D(v11, 1);
    else
      sub_C6A0D(v11, 0);
    result = 0LL;
  }
  return result;
}

//----- (00000000000CDD3F) ----------------------------------------------------
signed __int64 __fastcall sub_CDD3F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 *v9; // [rsp+20h] [rbp-30h]
  unsigned int v10; // [rsp+44h] [rbp-Ch]

  v9 = (__int64 *)a4;
  v8 = a5;
  v10 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 != 2 || !sub_CC407(*a1) )
    {
      sub_12222(*v9, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_count", a6);
      v10 = 1;
    }
    sub_C6D49(v8);
    result = v10;
  }
  else if ( *(_DWORD *)*a1 )
  {
    if ( *(_DWORD *)*a1 == 1 )
    {
      sub_C69DE(a5, a2, a3, a4, a5, a6, COERCE__INT128((long double)*(unsigned int *)(*a1 + 32)));
      result = 0LL;
    }
    else
    {
      v7 = sub_C494A((_DWORD *)*a1);
      sub_13937((void *)*v9, 75, 0, 0LL, 1LL, (__int64)v7, "count(node-set)");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_C69DE(a5, a2, a3, a4, a5, a6, COERCE__INT128(0.0));
    result = 0LL;
  }
  return result;
}

//----- (00000000000CDEAF) ----------------------------------------------------
signed __int64 __fastcall sub_CDEAF(__int64 a1, unsigned __int16 a2, __int64 a3, void **a4, __int64 a5, char a6)
{
  signed __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+18h] [rbp-18h]

  v8 = a3;
  v7 = a5;
  if ( a2 || a1 )
  {
    sub_13937(*a4, 74, 0, 0LL, a2, (__int64)"current()");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( a6 & 0x3C )
    {
      sub_C6D49(a5);
      sub_C765D(v7, v8, 2);
    }
    else
    {
      sub_DC765(a5, 0, a3, (__int64 *)a4, a6);
      sub_C7395(v7, v8, 0, 2, 0);
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000CDF8D) ----------------------------------------------------
signed __int64 __fastcall sub_CDF8D(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  signed __int64 result; // rax
  const char *v9; // rax
  __int64 v10; // r9
  __int64 v11; // [rsp+8h] [rbp-58h]
  __int64 *v12; // [rsp+10h] [rbp-50h]
  unsigned int v13; // [rsp+3Ch] [rbp-24h]
  __int64 v14; // [rsp+40h] [rbp-20h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  __int64 *v16; // [rsp+48h] [rbp-18h]

  v12 = a4;
  v11 = a5;
  v13 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v14 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v14 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v14 + 128, 9u) && !(unsigned int)sub_CC70D(v14 + 128, 8u) )
        {
          sub_12222(
            *v12,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"leafref\" neither \"instance-identifier\".",
            (__int64)"xpath_deref",
            *(_QWORD *)v14);
          v13 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v14;
        v7 = sub_8164(*(_DWORD *)(v14 + 56));
        sub_12222(*v12, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_deref", (__int64)v7, v6);
        v13 = 1;
      }
    }
    else
    {
      sub_12222(*v12, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_deref", a6);
      v13 = 1;
    }
    sub_C6D49(v11);
    if ( !v13 && *(_DWORD *)(v14 + 128) == 9 )
    {
      if ( !*(_QWORD *)(v14 + 168) )
        __assert_fail(
          "sleaf->type.info.lref.target",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0xE2Du,
          "xpath_deref");
      sub_C765D(v11, *(_QWORD *)(v14 + 168), 2);
    }
    result = v13;
  }
  else
  {
    if ( *(_DWORD *)*a1 != 1 && *(_DWORD *)*a1 )
    {
      v9 = sub_C494A((_DWORD *)*a1);
      sub_13937((void *)*v12, 75, 0, 0LL, 1LL, (__int64)v9, "deref(node-set)");
      return 0xFFFFFFFFLL;
    }
    sub_DC765(a5, 0, a3, a4, a6);
    if ( *(_DWORD *)*a1 )
    {
      v16 = **(__int64 ***)(*a1 + 16);
      v15 = *v16;
      if ( *(_DWORD *)(*v16 + 56) & 0xC )
      {
        if ( *(_DWORD *)(v15 + 128) == 9 || *(_DWORD *)(v15 + 128) == 8 )
        {
          if ( *((_BYTE *)v16 + 76) & 1 )
          {
            sub_13937(
              (void *)*v12,
              -1,
              3u,
              **(char ***)(*a1 + 16),
              (__int64)"Trying to dereference an unresolved leafref or instance-identifier.",
              v10);
            return 0xFFFFFFFFLL;
          }
          sub_C7395(v11, v16[8], 0, 2, 0);
        }
      }
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000CE2E0) ----------------------------------------------------
_BOOL8 __fastcall sub_CE2E0(__int64 a1, const char *a2)
{
  int v3; // [rsp+14h] [rbp-Ch]
  char *s2; // [rsp+18h] [rbp-8h]
  char *s2a; // [rsp+18h] [rbp-8h]

  s2 = strchr(a2, 58);
  if ( s2 )
  {
    if ( strncmp(*(const char **)(*(_QWORD *)(a1 + 48) + 8LL), a2, (signed int)s2 - (signed int)a2)
      || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL) + (signed int)s2 - (signed int)a2) )
    {
      return 1LL;
    }
    s2a = s2 + 1;
  }
  else
  {
    s2a = (char *)a2;
  }
  v3 = strlen(s2a);
  return strncmp(*(const char **)a1, s2a, v3) || *(_BYTE *)(*(_QWORD *)a1 + v3);
}

//----- (00000000000CE3C6) ----------------------------------------------------
signed __int64 __fastcall sub_CE3C6(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  const char *v11; // rax
  _DWORD *v12; // [rsp+8h] [rbp-58h]
  __int64 *v13; // [rsp+10h] [rbp-50h]
  unsigned __int16 i; // [rsp+30h] [rbp-30h]
  unsigned __int16 j; // [rsp+32h] [rbp-2Eh]
  unsigned int v16; // [rsp+34h] [rbp-2Ch]
  signed __int64 v17; // [rsp+38h] [rbp-28h]
  __int64 v18; // [rsp+40h] [rbp-20h]
  __int64 v19; // [rsp+48h] [rbp-18h]
  __int64 v20; // [rsp+48h] [rbp-18h]

  v13 = a4;
  v12 = a5;
  v16 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v19 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v19 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v19 + 128, 7u) )
        {
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"identityref\".",
            (__int64)"xpath_derived_from",
            *(_QWORD *)v19);
          v16 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v19;
        v7 = sub_8164(*(_DWORD *)(v19 + 56));
        sub_12222(*v13, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_derived_from", (__int64)v7, v6);
        v16 = 1;
      }
    }
    else
    {
      sub_12222(*v13, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_derived_from", a6);
      v16 = 1;
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v20 = sub_CC407(a1[1]);
      if ( v20 )
      {
        if ( *(_DWORD *)(v20 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v20 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_derived_from",
              *(_QWORD *)v20);
            v16 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v20;
          v9 = sub_8164(*(_DWORD *)(v20 + 56));
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #2 of %s is a %s node \"%s\".",
            (__int64)"xpath_derived_from",
            (__int64)v9,
            v8);
          v16 = 1;
        }
      }
    }
    sub_C6D49((__int64)v12);
    result = v16;
  }
  else if ( *(_DWORD *)*a1 != 1 && *(_DWORD *)*a1 )
  {
    v11 = sub_C494A((_DWORD *)*a1);
    sub_13937((void *)*v13, 75, 0, 0LL, 1LL, (__int64)v11, "derived-from(node-set, string)");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_C6A0D(v12, 0);
    if ( *(_DWORD *)*a1 )
    {
      for ( i = 0; (unsigned int)i < *(_DWORD *)(*a1 + 32); ++i )
      {
        v17 = 0LL;
        if ( *(_DWORD *)(16LL * i + *(_QWORD *)(*a1 + 16) + 8) == 2 )
        {
          v18 = *(_QWORD *)(16LL * i + *(_QWORD *)(*a1 + 16));
          if ( *(_DWORD *)(*(_QWORD *)v18 + 56LL) & 0xC && *(_DWORD *)(*(_QWORD *)v18 + 128LL) == 7 )
            v17 = v18 + 64;
        }
        else if ( *(_DWORD *)(16LL * i + *(_QWORD *)(*a1 + 16) + 8) == 4
               && *(_DWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(*a1 + 16)) + 48LL) == 7 )
        {
          v17 = *(_QWORD *)(16LL * i + *(_QWORD *)(*a1 + 16)) + 40LL;
        }
        if ( v17 )
        {
          for ( j = 0; j < *(unsigned __int8 *)(*(_QWORD *)v17 + 31LL); ++j )
          {
            if ( !(unsigned int)sub_CE2E0(
                                  *(_QWORD *)(8LL * j + *(_QWORD *)(*(_QWORD *)v17 + 56LL)),
                                  *(const char **)(a1[1] + 16)) )
            {
              sub_C6A0D(v12, 1);
              break;
            }
          }
          if ( j < *(unsigned __int8 *)(*(_QWORD *)v17 + 31LL) )
            break;
        }
      }
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000CE87B) ----------------------------------------------------
signed __int64 __fastcall sub_CE87B(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  const char *v11; // rax
  _DWORD *v12; // [rsp+8h] [rbp-58h]
  __int64 *v13; // [rsp+10h] [rbp-50h]
  unsigned __int16 i; // [rsp+30h] [rbp-30h]
  unsigned __int16 j; // [rsp+32h] [rbp-2Eh]
  unsigned int v16; // [rsp+34h] [rbp-2Ch]
  __int64 *v17; // [rsp+38h] [rbp-28h]
  __int64 *v18; // [rsp+40h] [rbp-20h]
  __int64 v19; // [rsp+48h] [rbp-18h]
  __int64 v20; // [rsp+48h] [rbp-18h]

  v13 = a4;
  v12 = a5;
  v16 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v19 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v19 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v19 + 128, 7u) )
        {
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"identityref\".",
            (__int64)"xpath_derived_from_or_self",
            *(_QWORD *)v19);
          v16 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v19;
        v7 = sub_8164(*(_DWORD *)(v19 + 56));
        sub_12222(
          *v13,
          1u,
          0,
          "Argument #1 of %s is a %s node \"%s\".",
          (__int64)"xpath_derived_from_or_self",
          (__int64)v7,
          v6);
        v16 = 1;
      }
    }
    else
    {
      sub_12222(*v13, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_derived_from_or_self", a6);
      v16 = 1;
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v20 = sub_CC407(a1[1]);
      if ( v20 )
      {
        if ( *(_DWORD *)(v20 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v20 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_derived_from_or_self",
              *(_QWORD *)v20);
            v16 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v20;
          v9 = sub_8164(*(_DWORD *)(v20 + 56));
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #2 of %s is a %s node \"%s\".",
            (__int64)"xpath_derived_from_or_self",
            (__int64)v9,
            v8);
          v16 = 1;
        }
      }
    }
    sub_C6D49((__int64)v12);
    result = v16;
  }
  else if ( *(_DWORD *)*a1 != 1 && *(_DWORD *)*a1 )
  {
    v11 = sub_C494A((_DWORD *)*a1);
    sub_13937((void *)*v13, 75, 0, 0LL, 1LL, (__int64)v11, "derived-from-or-self(node-set, string)");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_C6A0D(v12, 0);
    if ( *(_DWORD *)*a1 )
    {
      for ( i = 0; (unsigned int)i < *(_DWORD *)(*a1 + 32); ++i )
      {
        v17 = 0LL;
        if ( *(_DWORD *)(16LL * i + *(_QWORD *)(*a1 + 16) + 8) == 2 )
        {
          v18 = *(__int64 **)(16LL * i + *(_QWORD *)(*a1 + 16));
          if ( *(_DWORD *)(*v18 + 56) & 0xC && *(_DWORD *)(*v18 + 128) == 7 )
            v17 = v18 + 8;
        }
        else if ( *(_DWORD *)(16LL * i + *(_QWORD *)(*a1 + 16) + 8) == 4
               && *(_DWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(*a1 + 16)) + 48LL) == 7 )
        {
          v17 = (__int64 *)(*(_QWORD *)(16LL * i + *(_QWORD *)(*a1 + 16)) + 40LL);
        }
        if ( v17 )
        {
          if ( !(unsigned int)sub_CE2E0(*v17, *(const char **)(a1[1] + 16)) )
          {
            sub_C6A0D(v12, 1);
            break;
          }
          for ( j = 0; j < *(unsigned __int8 *)(*v17 + 31); ++j )
          {
            if ( !(unsigned int)sub_CE2E0(*(_QWORD *)(8LL * j + *(_QWORD *)(*v17 + 56)), *(const char **)(a1[1] + 16)) )
            {
              sub_C6A0D(v12, 1);
              break;
            }
          }
          if ( j < *(unsigned __int8 *)(*v17 + 31) )
            break;
        }
      }
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000CED6F) ----------------------------------------------------
signed __int64 __fastcall sub_CED6F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  signed __int64 result; // rax
  const char *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // [rsp+18h] [rbp-58h]
  __int64 *v15; // [rsp+20h] [rbp-50h]
  unsigned int v16; // [rsp+4Ch] [rbp-24h]
  _QWORD *v17; // [rsp+50h] [rbp-20h]
  __int64 v18; // [rsp+58h] [rbp-18h]

  v15 = (__int64 *)a4;
  v14 = a5;
  v16 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v18 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v18 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v18 + 128, 6u) )
        {
          sub_12222(
            *v15,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"enumeration\".",
            (__int64)"xpath_enum_value",
            *(_QWORD *)v18);
          v16 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v18;
        v7 = sub_8164(*(_DWORD *)(v18 + 56));
        sub_12222(*v15, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_enum_value", (__int64)v7, v6);
        v16 = 1;
      }
    }
    else
    {
      sub_12222(*v15, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_enum_value", a6);
      v16 = 1;
    }
    sub_C6D49(v14);
    result = v16;
  }
  else if ( *(_DWORD *)*a1 != 1 && *(_DWORD *)*a1 )
  {
    v9 = sub_C494A((_DWORD *)*a1);
    sub_13937((void *)*v15, 75, 0, 0LL, 1LL, (__int64)v9, "enum-value(node-set)");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_C69DE(a5, a2, a3, a4, a5, a6, COERCE__INT128(1.7845972430358476476e4932/*NaN*/));
    if ( *(_DWORD *)*a1 == 1 )
    {
      v17 = **(_QWORD ***)(*a1 + 16);
      if ( *(_DWORD *)(*v17 + 56LL) & 0xC )
      {
        if ( *(_DWORD *)(*v17 + 128LL) == 6 )
          sub_C69DE(v14, a2, v10, v11, v12, v13, COERCE__INT128((long double)*(signed int *)(v17[8] + 28LL)));
      }
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000CEFE0) ----------------------------------------------------
__int64 __fastcall sub_CEFE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, char a6)
{
  if ( a6 & 0x3C )
    sub_C6D49((__int64)a5);
  else
    sub_C6A0D(a5, 0);
  return 0LL;
}

//----- (00000000000CF037) ----------------------------------------------------
signed __int64 __fastcall sub_CF037(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // [rsp+28h] [rbp-28h]

  v11 = a5;
  if ( (unsigned int)sub_DC765(*a1, 4, a3, a4, a6) )
    return 0xFFFFFFFFLL;
  if ( 1.189731495357231765e4932 >= fabs(*(long double *)(*a1 + 16)) )
    sub_C69DE(v11, 4LL, v6, v7, v8, v9, COERCE__INT128((long double)(signed __int64)*(long double *)(*a1 + 16)));
  return 0LL;
}

//----- (00000000000CF0E9) ----------------------------------------------------
signed __int64 __fastcall sub_CF0E9(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  const char *v9; // rax
  unsigned int v10; // eax
  _QWORD *v11; // ST60_8
  int v12; // ebx
  __int64 v13; // [rsp+8h] [rbp-68h]
  __int64 *v14; // [rsp+10h] [rbp-60h]
  __int64 v15; // [rsp+18h] [rbp-58h]
  int v16; // [rsp+20h] [rbp-50h]
  int j; // [rsp+38h] [rbp-38h]
  unsigned int v18; // [rsp+3Ch] [rbp-34h]
  _QWORD *v19; // [rsp+40h] [rbp-30h]
  __int64 i; // [rsp+48h] [rbp-28h]
  __int64 v21; // [rsp+58h] [rbp-18h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v16 = a6;
  i = 0LL;
  v18 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v21 = sub_CC407(*a1);
      if ( v21 )
      {
        if ( *(_DWORD *)(v21 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v21 + 128) )
          {
            sub_12222(
              *v14,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_lang",
              *(_QWORD *)v21);
            v18 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v21;
          v7 = sub_8164(*(_DWORD *)(v21 + 56));
          sub_12222(*v14, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_lang", (__int64)v7, v6);
          v18 = 1;
        }
      }
    }
    sub_C6D49(v13);
    return v18;
  }
  if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
    return 0xFFFFFFFFLL;
  if ( !*(_DWORD *)v13 )
  {
    sub_C6A0D((_DWORD *)v13, 0);
    return 0LL;
  }
  if ( *(_DWORD *)v13 != 1 )
  {
    v9 = sub_C494A((_DWORD *)v13);
    sub_13937((void *)*v14, 71, 0, 0LL, (__int64)v9, (__int64)"lang(string)");
    return 0xFFFFFFFFLL;
  }
  v10 = *(_DWORD *)(*(_QWORD *)(v13 + 16) + 8LL);
  if ( v10 < 2 )
  {
LABEL_21:
    sub_C6A0D((_DWORD *)v13, 0);
    return 0LL;
  }
  if ( v10 <= 3 )
  {
    v19 = **(_QWORD ***)(v13 + 16);
  }
  else
  {
    if ( v10 != 4 )
      goto LABEL_21;
    v11 = (_QWORD *)sub_D2AFF(v15, v16, 0LL);
    v19 = sub_BB881(v11, **(_QWORD **)(v13 + 16));
  }
  while ( v19 )
  {
    for ( i = v19[2];
          i
       && (!*(_QWORD *)(i + 24)
        || strcmp(*(const char **)(i + 24), "lang")
        || strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)(i + 16) + 48LL) + 8LL), "xml"));
          i = *(_QWORD *)(i + 8) )
    {
      ;
    }
    if ( i )
      break;
    v19 = (_QWORD *)v19[5];
  }
  if ( i )
  {
    for ( j = 0; *(_BYTE *)(*(_QWORD *)(*a1 + 16) + j); ++j )
    {
      v12 = tolower(*(char *)(*(_QWORD *)(*a1 + 16) + j));
      if ( v12 != tolower(*(char *)(*(_QWORD *)(i + 32) + j)) )
      {
        sub_C6A0D((_DWORD *)v13, 0);
        break;
      }
    }
    if ( !*(_BYTE *)(*(_QWORD *)(*a1 + 16) + j) )
    {
      if ( *(_BYTE *)(*(_QWORD *)(i + 32) + j) && *(_BYTE *)(*(_QWORD *)(i + 32) + j) != 45 )
        sub_C6A0D((_DWORD *)v13, 0);
      else
        sub_C6A0D((_DWORD *)v13, 1);
    }
  }
  else
  {
    sub_C6A0D((_DWORD *)v13, 0);
  }
  return 0LL;
}

//----- (00000000000CF4F3) ----------------------------------------------------
signed __int64 __fastcall sub_CF4F3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  void **v8; // [rsp+20h] [rbp-20h]

  v8 = (void **)a4;
  if ( a6 & 0x3C )
  {
    sub_C6D49((__int64)a5);
    result = 0LL;
  }
  else if ( *a5 )
  {
    if ( *a5 == 1 )
    {
      sub_C69DE((__int64)a5, a2, a3, a4, (__int64)a5, a6, COERCE__INT128((long double)(unsigned int)a5[13]));
      result = 0LL;
    }
    else
    {
      v7 = sub_C494A(a5);
      sub_13937(*v8, 71, 0, 0LL, (__int64)v7, (__int64)"last()");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_C69DE((__int64)a5, a2, a3, a4, (__int64)a5, a6, COERCE__INT128(0.0));
    result = 0LL;
  }
  return result;
}

//----- (00000000000CF5DD) ----------------------------------------------------
signed __int64 __fastcall sub_CF5DD(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  const char *v8; // rax
  unsigned __int16 v9; // ax
  unsigned __int16 v10; // ax
  __int64 v11; // [rsp+8h] [rbp-38h]
  void **v12; // [rsp+10h] [rbp-30h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v12 = a4;
  v11 = (__int64)a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49((__int64)a5);
    return 0LL;
  }
  if ( a2 )
  {
    if ( !*(_DWORD *)*a1 )
    {
      sub_C6974((__int64)a5, byte_124F70, 0);
      return 0LL;
    }
    if ( *(_DWORD *)*a1 != 1 )
    {
      v7 = sub_C494A((_DWORD *)*a1);
      sub_13937(*v12, 75, 0, 0LL, 1LL, (__int64)v7, "local-name(node-set?)");
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)sub_C8295(*a1, a3, a6) )
      __assert_fail(
        "!set_sort(args[0], cur_node, options)",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1031u,
        "xpath_local_name");
    v13 = *(_QWORD *)(*a1 + 16);
  }
  else
  {
    if ( !*a5 )
    {
      sub_C6974((__int64)a5, byte_124F70, 0);
      return 0LL;
    }
    if ( *a5 != 1 )
    {
      v8 = sub_C494A(a5);
      sub_13937(*v12, 71, 0, 0LL, (__int64)v8, (__int64)"local-name(node-set?)");
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)sub_C8295((__int64)a5, a3, a6) )
      __assert_fail(
        "!set_sort(set, cur_node, options)",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x103Fu,
        "xpath_local_name");
    v13 = *(_QWORD *)(v11 + 16);
  }
  switch ( *(_DWORD *)(v13 + 8) )
  {
    case 0:
    case 1:
    case 3:
      sub_C6974(v11, byte_124F70, 0);
      goto LABEL_23;
    case 2:
      v9 = strlen(***(const char ****)v13);
      sub_C6974(v11, ***(char ****)v13, v9);
      goto LABEL_23;
    case 4:
      v10 = strlen(*(const char **)(*(_QWORD *)v13 + 24LL));
      sub_C6974(v11, *(char **)(*(_QWORD *)v13 + 24LL), v10);
LABEL_23:
      result = 0LL;
      break;
    default:
      sub_12222(
        (__int64)*v12,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        4177LL);
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

//----- (00000000000CF8C9) ----------------------------------------------------
signed __int64 __fastcall sub_CF8C9(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6)
{
  return sub_CF5DD(a1, a2, a3, a4, a5, a6);
}

//----- (00000000000CF913) ----------------------------------------------------
signed __int64 __fastcall sub_CF913(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  const char *v8; // rax
  __int64 v9; // rax
  __int64 v10; // ST48_8
  unsigned __int16 v11; // ax
  __int64 v12; // [rsp+8h] [rbp-38h]
  void **v13; // [rsp+10h] [rbp-30h]
  _DWORD *v14; // [rsp+30h] [rbp-10h]

  v13 = a4;
  v12 = (__int64)a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49((__int64)a5);
    return 0LL;
  }
  if ( a2 )
  {
    if ( !*(_DWORD *)*a1 )
    {
      sub_C6974((__int64)a5, byte_124F70, 0);
      return 0LL;
    }
    if ( *(_DWORD *)*a1 != 1 )
    {
      v7 = sub_C494A((_DWORD *)*a1);
      sub_13937(*v13, 75, 0, 0LL, 1LL, (__int64)v7, "namespace-uri(node-set?)");
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)sub_C8295(*a1, a3, a6) )
      __assert_fail(
        "!set_sort(args[0], cur_node, options)",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1093u,
        "xpath_namespace_uri");
    v14 = *(_DWORD **)(*a1 + 16);
  }
  else
  {
    if ( !*a5 )
    {
      sub_C6974((__int64)a5, byte_124F70, 0);
      return 0LL;
    }
    if ( *a5 != 1 )
    {
      v8 = sub_C494A(a5);
      sub_13937(*v13, 71, 0, 0LL, (__int64)v8, (__int64)"namespace-uri(node-set?)");
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)sub_C8295((__int64)a5, a3, a6) )
      __assert_fail(
        "!set_sort(set, cur_node, options)",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x10A1u,
        "xpath_namespace_uri");
    v14 = *(_DWORD **)(v12 + 16);
  }
  switch ( v14[2] )
  {
    case 0:
    case 1:
    case 3:
      sub_C6974(v12, byte_124F70, 0);
      goto LABEL_25;
    case 2:
    case 4:
      if ( v14[2] == 2 )
        v9 = lys_main_module(*(_QWORD *)(**(_QWORD **)v14 + 48LL));
      else
        v9 = lys_main_module(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 16LL) + 48LL));
      v10 = v9;
      v11 = strlen(*(const char **)(v9 + 176));
      sub_C6974(v12, *(char **)(v10 + 176), v11);
LABEL_25:
      result = 0LL;
      break;
    default:
      sub_12222(
        (__int64)*v13,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        4281LL);
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000CFC0C) ----------------------------------------------------
__int64 __fastcall sub_CFC0C(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, char a6)
{
  __int64 result; // rax

  if ( a6 & 0x3C )
  {
    sub_C6D49((__int64)a5);
    result = 0LL;
  }
  else
  {
    if ( *a5 != 1 )
      sub_DC765((__int64)a5, 0, a3, a4, a6);
    result = 0LL;
  }
  return result;
}

//----- (00000000000CFC7C) ----------------------------------------------------
signed __int64 __fastcall sub_CFC7C(__int64 *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  size_t v9; // rax
  __int64 v10; // r9
  char v11; // al
  __int64 v12; // r9
  __int64 v13; // [rsp+8h] [rbp-58h]
  __int64 *v14; // [rsp+10h] [rbp-50h]
  __int64 v15; // [rsp+18h] [rbp-48h]
  int v16; // [rsp+20h] [rbp-40h]
  unsigned __int16 i; // [rsp+30h] [rbp-30h]
  unsigned __int16 j; // [rsp+30h] [rbp-30h]
  unsigned __int16 v19; // [rsp+32h] [rbp-2Eh]
  signed int v20; // [rsp+34h] [rbp-2Ch]
  signed int v21; // [rsp+38h] [rbp-28h]
  signed int v22; // [rsp+38h] [rbp-28h]
  unsigned int v23; // [rsp+3Ch] [rbp-24h]
  _BYTE *v24; // [rsp+40h] [rbp-20h]
  _BYTE *v25; // [rsp+40h] [rbp-20h]
  __int64 v26; // [rsp+48h] [rbp-18h]

  v15 = a3;
  v14 = (__int64 *)a4;
  v13 = a5;
  v16 = a6;
  v20 = 0;
  v21 = 0;
  v23 = 0;
  if ( a6 & 0x3C )
  {
    if ( a2 )
    {
      if ( *(_DWORD *)*a1 == 2 )
      {
        v26 = sub_CC407(*a1);
        if ( v26 )
        {
          if ( *(_DWORD *)(v26 + 56) & 0xC )
          {
            if ( !(unsigned int)sub_CC619(v26 + 128) )
            {
              sub_12222(
                *v14,
                1u,
                0,
                "Argument #1 of %s is node \"%s\", not of string-type.",
                (__int64)"xpath_normalize_space",
                *(_QWORD *)v26);
              v23 = 1;
            }
          }
          else
          {
            v6 = *(_QWORD *)v26;
            v7 = sub_8164(*(_DWORD *)(v26 + 56));
            sub_12222(
              *v14,
              1u,
              0,
              "Argument #1 of %s is a %s node \"%s\".",
              (__int64)"xpath_normalize_space",
              (__int64)v7,
              v6);
            v23 = 1;
          }
        }
      }
    }
    sub_C6D49(v13);
    return v23;
  }
  if ( a2 )
    sub_C6A3F(a5, *a1, *a1, a4, a5, a6);
  if ( (unsigned int)sub_DC765(v13, 5, v15, v14, v16) )
    return 0xFFFFFFFFLL;
  for ( i = 0; *(_BYTE *)(*(_QWORD *)(v13 + 16) + i); ++i )
  {
    if ( *(_BYTE *)(*(_QWORD *)(v13 + 16) + i) != 32
      && *(_BYTE *)(*(_QWORD *)(v13 + 16) + i) != 9
      && *(_BYTE *)(*(_QWORD *)(v13 + 16) + i) != 10
      && *(_BYTE *)(*(_QWORD *)(v13 + 16) + i) != 13 )
    {
      v21 = 0;
    }
    else
    {
      if ( !i || v21 || !*(_BYTE *)(i + 1LL + *(_QWORD *)(v13 + 16)) )
      {
        v20 = 1;
        break;
      }
      v21 = 1;
    }
  }
  if ( !v20 )
    return 0LL;
  v9 = strlen(*(const char **)(v13 + 16));
  v24 = malloc(v9);
  if ( !v24 )
  {
    sub_12222(*v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"xpath_normalize_space", v10);
    return 0xFFFFFFFFLL;
  }
  v19 = 0;
  v22 = 0;
  for ( j = 0; *(_BYTE *)(*(_QWORD *)(v13 + 16) + j); ++j )
  {
    if ( *(_BYTE *)(*(_QWORD *)(v13 + 16) + j) != 32
      && *(_BYTE *)(*(_QWORD *)(v13 + 16) + j) != 9
      && *(_BYTE *)(*(_QWORD *)(v13 + 16) + j) != 10
      && *(_BYTE *)(*(_QWORD *)(v13 + 16) + j) != 13 )
    {
      v22 = 0;
    }
    else
    {
      if ( !j || v22 )
      {
        v22 = 1;
        continue;
      }
      v22 = 1;
    }
    if ( v22 )
      v11 = 32;
    else
      v11 = *(_BYTE *)(*(_QWORD *)(v13 + 16) + j);
    v24[v19++] = v11;
  }
  if ( v19 && (v24[v19 - 1] == 32 || v24[v19 - 1] == 9 || v24[v19 - 1] == 10 || v24[v19 - 1] == 13) )
    --v19;
  v25 = sub_C422(v24, v19 + 1);
  if ( !v25 )
  {
    sub_12222(*v14, 0, 1, "Memory allocation failed (%s()).", (__int64)"xpath_normalize_space", v12);
    return 0xFFFFFFFFLL;
  }
  v25[v19] = 0;
  free(*(void **)(v13 + 16));
  *(_QWORD *)(v13 + 16) = v25;
  return 0LL;
}

//----- (00000000000D010E) ----------------------------------------------------
__int64 __fastcall sub_D010E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, char a6)
{
  __int64 result; // rax
  _DWORD *v7; // [rsp+8h] [rbp-28h]

  v7 = (_DWORD *)a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49(a5);
    result = 0LL;
  }
  else
  {
    sub_DC765(*a1, 3, a3, a4, a6);
    if ( *(_DWORD *)(*a1 + 16) )
      sub_C6A0D(v7, 0);
    else
      sub_C6A0D(v7, 1);
    result = 0LL;
  }
  return result;
}

//----- (00000000000D01A8) ----------------------------------------------------
signed __int64 __fastcall sub_D01A8(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // [rsp+8h] [rbp-28h]

  v10 = a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49(a5);
    return 0LL;
  }
  if ( a2 )
  {
    if ( (unsigned int)sub_DC765(*a1, 4, a3, a4, a6) )
      return 0xFFFFFFFFLL;
    sub_C6A3F(v10, *a1, *a1, v7, v8, v9);
  }
  else if ( (unsigned int)sub_DC765(a5, 4, a3, a4, a6) )
  {
    return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (00000000000D0264) ----------------------------------------------------
signed __int64 __fastcall sub_D0264(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  void **v8; // [rsp+20h] [rbp-20h]

  v8 = (void **)a4;
  if ( a6 & 0x3C )
  {
    sub_C6D49((__int64)a5);
    result = 0LL;
  }
  else if ( *a5 )
  {
    if ( *a5 == 1 )
    {
      sub_C69DE((__int64)a5, a2, a3, a4, (__int64)a5, a6, COERCE__INT128((long double)(unsigned int)a5[12]));
      result = 0LL;
    }
    else
    {
      v7 = sub_C494A(a5);
      sub_13937(*v8, 71, 0, 0LL, (__int64)v7, (__int64)"position()");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_C69DE((__int64)a5, a2, a3, a4, (__int64)a5, a6, COERCE__INT128(0.0));
    result = 0LL;
  }
  return result;
}

//----- (00000000000D034E) ----------------------------------------------------
signed __int64 __fastcall sub_D034E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  unsigned int v11; // eax
  _DWORD *v12; // [rsp+8h] [rbp-58h]
  __int64 *v13; // [rsp+10h] [rbp-50h]
  __int64 v14; // [rsp+18h] [rbp-48h]
  int v15; // [rsp+20h] [rbp-40h]
  unsigned int v16; // [rsp+34h] [rbp-2Ch]
  void *ptr; // [rsp+38h] [rbp-28h]
  __int64 v18; // [rsp+40h] [rbp-20h]
  unsigned __int64 v19; // [rsp+48h] [rbp-18h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v15 = a6;
  v19 = __readfsqword(0x28u);
  v16 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v18 = sub_CC407(*a1);
      if ( v18 )
      {
        if ( *(_DWORD *)(v18 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v18 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_re_match",
              *(_QWORD *)v18);
            v16 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v18;
          v7 = sub_8164(*(_DWORD *)(v18 + 56));
          sub_12222(*v13, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_re_match", (__int64)v7, v6);
          v16 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v18 = sub_CC407(a1[1]);
      if ( v18 )
      {
        if ( *(_DWORD *)(v18 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v18 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_re_match",
              *(_QWORD *)v18);
            v16 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v18;
          v9 = sub_8164(*(_DWORD *)(v18 + 56));
          sub_12222(*v13, 1u, 0, "Argument #2 of %s is a %s node \"%s\".", (__int64)"xpath_re_match", (__int64)v9, v8);
          v16 = 1;
        }
      }
    }
    sub_C6D49((__int64)v12);
    result = v16;
  }
  else if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, v14, v13, v15) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_36C95((void *)*v13, *(const char **)(a1[1] + 16), &ptr) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v11 = strlen(*(const char **)(*a1 + 16));
    if ( (unsigned int)pcre_exec(ptr, 0LL, *(_QWORD *)(*a1 + 16), v11, 0LL, 0LL, 0LL, 0LL) )
      sub_C6A0D(v12, 0);
    else
      sub_C6A0D(v12, 1);
    free(ptr);
    result = 0LL;
  }
  return result;
}
// 7500: using guessed type __int64 __fastcall pcre_exec(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000D06AD) ----------------------------------------------------
signed __int64 __fastcall sub_D06AD(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  signed __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // [rsp+18h] [rbp-48h]
  __int64 *v18; // [rsp+20h] [rbp-40h]
  __int64 v19; // [rsp+28h] [rbp-38h]
  int v20; // [rsp+30h] [rbp-30h]
  unsigned int v21; // [rsp+44h] [rbp-1Ch]
  __int64 v22; // [rsp+48h] [rbp-18h]

  v19 = a3;
  v18 = a4;
  v17 = a5;
  v20 = a6;
  v21 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 && (v22 = sub_CC407(*a1)) != 0 )
    {
      if ( *(_DWORD *)(v22 + 56) & 0xC )
      {
        if ( !(unsigned int)sub_CC70D(v22 + 128, 4u) )
        {
          sub_12222(
            *v18,
            1u,
            0,
            "Argument #1 of %s is node \"%s\", not of type \"decimal64\".",
            (__int64)"xpath_round",
            *(_QWORD *)v22);
          v21 = 1;
        }
      }
      else
      {
        v6 = *(_QWORD *)v22;
        v7 = sub_8164(*(_DWORD *)(v22 + 56));
        sub_12222(*v18, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_round", (__int64)v7, v6);
        v21 = 1;
      }
    }
    else
    {
      sub_12222(*v18, 1u, 0, "Argument #1 of %s not a node-set as expected.", (__int64)"xpath_round", a6);
      v21 = 1;
    }
    sub_C6D49(v17);
    result = v21;
  }
  else
  {
    if ( (unsigned int)sub_DC765(*a1, 4, a3, a4, a6) )
      return 0xFFFFFFFFLL;
    if ( 0.0 != *(long double *)(*a1 + 16) && (*(long double *)(*a1 + 16) >= 0.0 || *(long double *)(*a1 + 16) < -0.5) )
    {
      *(long double *)(*a1 + 16) = *(long double *)(*a1 + 16) + 0.5;
      if ( (unsigned int)sub_CF037(a1, 1LL, v19, v18, *a1, v20) )
        return 0xFFFFFFFFLL;
      sub_C69DE(v17, 1LL, v13, v14, v15, v16, COERCE__INT128(*(long double *)(*a1 + 16)));
    }
    else
    {
      sub_C69DE(v17, 4LL, v9, v10, v11, v12, COERCE__INT128(-0.0));
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000D0925) ----------------------------------------------------
signed __int64 __fastcall sub_D0925(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  size_t v11; // rax
  _DWORD *v12; // [rsp+8h] [rbp-48h]
  __int64 *v13; // [rsp+10h] [rbp-40h]
  __int64 v14; // [rsp+18h] [rbp-38h]
  int v15; // [rsp+20h] [rbp-30h]
  unsigned int v16; // [rsp+34h] [rbp-1Ch]
  __int64 v17; // [rsp+38h] [rbp-18h]
  __int64 v18; // [rsp+38h] [rbp-18h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v15 = a6;
  v16 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v17 = sub_CC407(*a1);
      if ( v17 )
      {
        if ( *(_DWORD *)(v17 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v17 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_starts_with",
              *(_QWORD *)v17);
            v16 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v17;
          v7 = sub_8164(*(_DWORD *)(v17 + 56));
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #1 of %s is a %s node \"%s\".",
            (__int64)"xpath_starts_with",
            (__int64)v7,
            v6);
          v16 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v18 = sub_CC407(a1[1]);
      if ( v18 )
      {
        if ( *(_DWORD *)(v18 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v18 + 128) )
          {
            sub_12222(
              *v13,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_starts_with",
              *(_QWORD *)v18);
            v16 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v18;
          v9 = sub_8164(*(_DWORD *)(v18 + 56));
          sub_12222(
            *v13,
            1u,
            0,
            "Argument #2 of %s is a %s node \"%s\".",
            (__int64)"xpath_starts_with",
            (__int64)v9,
            v8);
          v16 = 1;
        }
      }
    }
    sub_C6D49((__int64)v12);
    result = v16;
  }
  else if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, v14, v13, v15) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v11 = strlen(*(const char **)(a1[1] + 16));
    if ( !strncmp(*(const char **)(*a1 + 16), *(const char **)(a1[1] + 16), v11) )
      sub_C6A0D(v12, 1);
    else
      sub_C6A0D(v12, 0);
    result = 0LL;
  }
  return result;
}

//----- (00000000000D0C1C) ----------------------------------------------------
signed __int64 __fastcall sub_D0C1C(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // [rsp+8h] [rbp-28h]

  v10 = a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49(a5);
    return 0LL;
  }
  if ( a2 )
  {
    if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
      return 0xFFFFFFFFLL;
    sub_C6A3F(v10, *a1, *a1, v7, v8, v9);
  }
  else if ( (unsigned int)sub_DC765(a5, 5, a3, a4, a6) )
  {
    return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (00000000000D0CD8) ----------------------------------------------------
signed __int64 __fastcall sub_D0CD8(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  __int128 v11; // fst7
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int128 v16; // fst7
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // [rsp+18h] [rbp-48h]
  __int64 *v22; // [rsp+20h] [rbp-40h]
  unsigned int v23; // [rsp+44h] [rbp-1Ch]
  __int64 v24; // [rsp+48h] [rbp-18h]
  __int64 v25; // [rsp+48h] [rbp-18h]

  v22 = a4;
  v21 = a5;
  v23 = 0;
  if ( a6 & 0x3C )
  {
    if ( a2 )
    {
      if ( *(_DWORD *)*a1 == 2 )
      {
        v24 = sub_CC407(*a1);
        if ( v24 )
        {
          if ( *(_DWORD *)(v24 + 56) & 0xC )
          {
            if ( !(unsigned int)sub_CC619(v24 + 128) )
            {
              sub_12222(
                *v22,
                1u,
                0,
                "Argument #1 of %s is node \"%s\", not of string-type.",
                (__int64)"xpath_string_length",
                *(_QWORD *)v24);
              v23 = 1;
            }
          }
          else
          {
            v6 = *(_QWORD *)v24;
            v7 = sub_8164(*(_DWORD *)(v24 + 56));
            sub_12222(
              *v22,
              1u,
              0,
              "Argument #1 of %s is a %s node \"%s\".",
              (__int64)"xpath_string_length",
              (__int64)v7,
              v6);
            v23 = 1;
          }
        }
      }
    }
    if ( !a2 && *(_DWORD *)v21 == 2 )
    {
      v25 = sub_CC407(v21);
      if ( v25 )
      {
        if ( *(_DWORD *)(v25 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v25 + 128) )
          {
            sub_12222(
              *v22,
              1u,
              0,
              "Argument #0 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_string_length",
              *(_QWORD *)v25);
            v23 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v25;
          v9 = sub_8164(*(_DWORD *)(v25 + 56));
          sub_12222(
            *v22,
            1u,
            0,
            "Argument #0 of %s is a %s node \"%s\".",
            (__int64)"xpath_string_length",
            (__int64)v9,
            v8);
          v23 = 1;
        }
      }
    }
    sub_C6D49(v21);
    result = v23;
  }
  else
  {
    if ( a2 )
    {
      if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
        return 0xFFFFFFFFLL;
      *(long double *)&v11 = (long double)strlen(*(const char **)(*a1 + 16));
      sub_C69DE(v21, 5LL, v12, v13, v14, v15, v11);
    }
    else
    {
      if ( (unsigned int)sub_DC765(a5, 5, a3, a4, a6) )
        return 0xFFFFFFFFLL;
      *(long double *)&v16 = (long double)strlen(*(const char **)(v21 + 16));
      sub_C69DE(v21, 5LL, v17, v18, v19, v20, v16);
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000D0FED) ----------------------------------------------------
signed __int64 __fastcall sub_D0FED(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  __int64 v10; // rbx
  const char *v11; // rax
  signed __int64 result; // rax
  char v13; // fps^1
  __int16 v15; // fps
  __int16 v17; // fps
  __int64 v19; // [rsp+8h] [rbp-58h]
  __int64 *v20; // [rsp+10h] [rbp-50h]
  __int64 v21; // [rsp+18h] [rbp-48h]
  unsigned int v22; // [rsp+20h] [rbp-40h]
  unsigned __int16 v23; // [rsp+36h] [rbp-2Ah]
  unsigned __int16 v24; // [rsp+38h] [rbp-28h]
  unsigned __int16 i; // [rsp+3Ah] [rbp-26h]
  signed int v26; // [rsp+3Ch] [rbp-24h]
  signed int v27; // [rsp+40h] [rbp-20h]
  unsigned int v28; // [rsp+44h] [rbp-1Ch]
  __int64 v29; // [rsp+48h] [rbp-18h]
  __int64 v30; // [rsp+48h] [rbp-18h]
  __int64 v31; // [rsp+48h] [rbp-18h]

  v21 = a3;
  v20 = a4;
  v19 = a5;
  v22 = a6;
  v28 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v29 = sub_CC407(*a1);
      if ( v29 )
      {
        if ( *(_DWORD *)(v29 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v29 + 128) )
          {
            sub_12222(
              *v20,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_substring",
              *(_QWORD *)v29);
            v28 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v29;
          v7 = sub_8164(*(_DWORD *)(v29 + 56));
          sub_12222(*v20, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_substring", (__int64)v7, v6);
          v28 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v30 = sub_CC407(a1[1]);
      if ( v30 )
      {
        if ( *(_DWORD *)(v30 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC474(v30 + 128) )
          {
            sub_12222(
              *v20,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of numeric type.",
              (__int64)"xpath_substring",
              *(_QWORD *)v30);
            v28 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v30;
          v9 = sub_8164(*(_DWORD *)(v30 + 56));
          sub_12222(*v20, 1u, 0, "Argument #2 of %s is a %s node \"%s\".", (__int64)"xpath_substring", (__int64)v9, v8);
          v28 = 1;
        }
      }
    }
    if ( a2 == 3 && *(_DWORD *)a1[2] == 2 )
    {
      v31 = sub_CC407(a1[2]);
      if ( v31 )
      {
        if ( *(_DWORD *)(v31 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC474(v31 + 128) )
          {
            sub_12222(
              *v20,
              1u,
              0,
              "Argument #3 of %s is node \"%s\", not of numeric type.",
              (__int64)"xpath_substring",
              *(_QWORD *)v31);
            v28 = 1;
          }
        }
        else
        {
          v10 = *(_QWORD *)v31;
          v11 = sub_8164(*(_DWORD *)(v31 + 56));
          sub_12222(
            *v20,
            1u,
            0,
            "Argument #3 of %s is a %s node \"%s\".",
            (__int64)"xpath_substring",
            (__int64)v11,
            v10);
          v28 = 1;
        }
      }
    }
    sub_C6D49(v19);
    result = v28;
  }
  else
  {
    if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
      return 0xFFFFFFFFLL;
    if ( (unsigned int)sub_D06AD(a1 + 1, 1LL, v21, v20, a1[1], v22) )
      return 0xFFFFFFFFLL;
    if ( 1.189731495357231765e4932 >= fabs(*(long double *)(a1[1] + 16)) )
    {
      v26 = (signed int)(*(long double *)(a1[1] + 16) - 1.0);
    }
    else
    {
      _FST7 = *(long double *)(a1[1] + 16);
      __asm { fxam }
      if ( (v13 & 0x45) != 5 )
        goto LABEL_51;
      _FST7 = *(long double *)(a1[1] + 16);
      __asm { fxam }
      if ( v15 & 0x200 )
        v26 = 2147483648;
      else
LABEL_51:
        v26 = 0x7FFFFFFF;
    }
    if ( a2 == 3 )
    {
      if ( (unsigned int)sub_D06AD(a1 + 2, 1LL, v21, v20, a1[2], v22) )
        return 0xFFFFFFFFLL;
      if ( 1.189731495357231765e4932 >= fabs(*(long double *)(a1[2] + 16)) )
      {
        v27 = (signed int)*(long double *)(a1[2] + 16);
      }
      else
      {
        _FST7 = *(long double *)(a1[2] + 16);
        __asm { fxam }
        if ( v17 & 0x200 )
          v27 = 0;
        else
          v27 = 0x7FFFFFFF;
      }
    }
    else
    {
      v27 = 0x7FFFFFFF;
    }
    v23 = 0;
    v24 = 0;
    for ( i = 0; *(_BYTE *)(*(_QWORD *)(*a1 + 16) + i); ++i )
    {
      if ( v26 <= i )
      {
        if ( i >= v26 + v27 )
          break;
        ++v24;
      }
      else
      {
        ++v23;
      }
    }
    sub_C6974(v19, (char *)(v23 + *(_QWORD *)(*a1 + 16)), v24);
    result = 0LL;
  }
  return result;
}

//----- (00000000000D1588) ----------------------------------------------------
signed __int64 __fastcall sub_D1588(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  size_t v11; // rax
  unsigned __int16 v12; // bx
  size_t v13; // rax
  __int64 v14; // [rsp+8h] [rbp-58h]
  __int64 *v15; // [rsp+10h] [rbp-50h]
  __int64 v16; // [rsp+18h] [rbp-48h]
  int v17; // [rsp+20h] [rbp-40h]
  unsigned int v18; // [rsp+3Ch] [rbp-24h]
  char *v19; // [rsp+40h] [rbp-20h]
  __int64 v20; // [rsp+48h] [rbp-18h]
  __int64 v21; // [rsp+48h] [rbp-18h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v17 = a6;
  v18 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v20 = sub_CC407(*a1);
      if ( v20 )
      {
        if ( *(_DWORD *)(v20 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v20 + 128) )
          {
            sub_12222(
              *v15,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_substring_after",
              *(_QWORD *)v20);
            v18 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v20;
          v7 = sub_8164(*(_DWORD *)(v20 + 56));
          sub_12222(
            *v15,
            1u,
            0,
            "Argument #1 of %s is a %s node \"%s\".",
            (__int64)"xpath_substring_after",
            (__int64)v7,
            v6);
          v18 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v21 = sub_CC407(a1[1]);
      if ( v21 )
      {
        if ( *(_DWORD *)(v21 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v21 + 128) )
          {
            sub_12222(
              *v15,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_substring_after",
              *(_QWORD *)v21);
            v18 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v21;
          v9 = sub_8164(*(_DWORD *)(v21 + 56));
          sub_12222(
            *v15,
            1u,
            0,
            "Argument #2 of %s is a %s node \"%s\".",
            (__int64)"xpath_substring_after",
            (__int64)v9,
            v8);
          v18 = 1;
        }
      }
    }
    sub_C6D49(v14);
    result = v18;
  }
  else if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, v16, v15, v17) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v19 = strstr(*(const char **)(*a1 + 16), *(const char **)(a1[1] + 16));
    if ( v19 )
    {
      v11 = strlen(*(const char **)(a1[1] + 16));
      v12 = strlen(&v19[v11]);
      v13 = strlen(*(const char **)(a1[1] + 16));
      sub_C6974(v14, &v19[v13], v12);
    }
    else
    {
      sub_C6974(v14, byte_124F70, 0);
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000D18C4) ----------------------------------------------------
signed __int64 __fastcall sub_D18C4(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  signed __int64 result; // rax
  __int64 v11; // [rsp+8h] [rbp-58h]
  __int64 *v12; // [rsp+10h] [rbp-50h]
  __int64 v13; // [rsp+18h] [rbp-48h]
  int v14; // [rsp+20h] [rbp-40h]
  unsigned int v15; // [rsp+3Ch] [rbp-24h]
  char *v16; // [rsp+40h] [rbp-20h]
  __int64 v17; // [rsp+48h] [rbp-18h]
  __int64 v18; // [rsp+48h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v14 = a6;
  v15 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v17 = sub_CC407(*a1);
      if ( v17 )
      {
        if ( *(_DWORD *)(v17 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v17 + 128) )
          {
            sub_12222(
              *v12,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_substring_before",
              *(_QWORD *)v17);
            v15 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v17;
          v7 = sub_8164(*(_DWORD *)(v17 + 56));
          sub_12222(
            *v12,
            1u,
            0,
            "Argument #1 of %s is a %s node \"%s\".",
            (__int64)"xpath_substring_before",
            (__int64)v7,
            v6);
          v15 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v18 = sub_CC407(a1[1]);
      if ( v18 )
      {
        if ( *(_DWORD *)(v18 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v18 + 128) )
          {
            sub_12222(
              *v12,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_substring_before",
              *(_QWORD *)v18);
            v15 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v18;
          v9 = sub_8164(*(_DWORD *)(v18 + 56));
          sub_12222(
            *v12,
            1u,
            0,
            "Argument #2 of %s is a %s node \"%s\".",
            (__int64)"xpath_substring_before",
            (__int64)v9,
            v8);
          v15 = 1;
        }
      }
    }
    sub_C6D49(v11);
    result = v15;
  }
  else if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, v13, v12, v14) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v16 = strstr(*(const char **)(*a1 + 16), *(const char **)(a1[1] + 16));
    if ( v16 )
      sub_C6974(v11, *(char **)(*a1 + 16), (_WORD)v16 - *(unsigned __int64 *)(*a1 + 16));
    else
      sub_C6974(v11, byte_124F70, 0);
    result = 0LL;
  }
  return result;
}

//----- (00000000000D1BD3) ----------------------------------------------------
signed __int64 __fastcall sub_D1BD3(_DWORD **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  signed __int64 result; // rax
  const char *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rax
  _QWORD *v13; // rcx
  __int64 v14; // rdx
  long double v15; // ST70_16
  __int64 v16; // [rsp+28h] [rbp-B8h]
  __int64 *v17; // [rsp+30h] [rbp-B0h]
  __int64 v18; // [rsp+38h] [rbp-A8h]
  int v19; // [rsp+40h] [rbp-A0h]
  unsigned __int16 i; // [rsp+5Ah] [rbp-86h]
  unsigned __int16 j; // [rsp+5Ah] [rbp-86h]
  unsigned int v22; // [rsp+5Ch] [rbp-84h]
  char *ptr; // [rsp+60h] [rbp-80h]
  __int64 v24; // [rsp+68h] [rbp-78h]
  int v25; // [rsp+80h] [rbp-60h]
  void *v26; // [rsp+90h] [rbp-50h]
  int v27; // [rsp+A0h] [rbp-40h]
  int v28; // [rsp+A4h] [rbp-3Ch]
  unsigned __int64 v29; // [rsp+C8h] [rbp-18h]

  v18 = a3;
  v17 = (__int64 *)a4;
  v16 = a5;
  v19 = a6;
  v29 = __readfsqword(0x28u);
  v22 = 0;
  if ( a6 & 0x3C )
  {
    if ( **a1 == 2 )
    {
      for ( i = 0; (unsigned int)i < (*a1)[8]; ++i )
      {
        if ( *(_DWORD *)(16LL * i + *((_QWORD *)*a1 + 2) + 12) == 1 )
        {
          v24 = *(_QWORD *)(16LL * i + *((_QWORD *)*a1 + 2));
          if ( *(_DWORD *)(v24 + 56) & 0xC )
          {
            if ( !(unsigned int)sub_CC474(v24 + 128) )
            {
              sub_12222(
                *v17,
                1u,
                0,
                "Argument #1 of %s is node \"%s\", not of numeric type.",
                (__int64)"xpath_sum",
                *(_QWORD *)v24);
              v22 = 1;
            }
          }
          else
          {
            v6 = *(_QWORD *)v24;
            v7 = sub_8164(*(_DWORD *)(v24 + 56));
            sub_12222(*v17, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_sum", (__int64)v7, v6);
            v22 = 1;
          }
        }
      }
    }
    sub_C6D49(v16);
    result = v22;
  }
  else
  {
    sub_C69DE(a5, a2, a3, a4, a5, a6, COERCE__INT128(0.0));
    if ( **a1 )
    {
      if ( **a1 == 1 )
      {
        v25 = 1;
        v26 = malloc(0x10uLL);
        if ( v26 )
        {
          v27 = 1;
          v28 = 1;
          for ( j = 0; (unsigned int)j < (*a1)[8]; ++j )
          {
            v12 = (_QWORD *)(16LL * j + *((_QWORD *)*a1 + 2));
            v13 = v26;
            v14 = v12[1];
            *(_QWORD *)v26 = *v12;
            v13[1] = v14;
            ptr = sub_C5EB1((__int64)&v25, v18, (void **)v17, v19, v10, v11);
            if ( !ptr )
              return 0xFFFFFFFFLL;
            v15 = sub_C607E(ptr);
            free(ptr);
            *(long double *)(v16 + 16) = *(long double *)(v16 + 16) + v15;
          }
          free(v26);
          result = 0LL;
        }
        else
        {
          sub_12222(*v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"xpath_sum", v11);
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        v9 = sub_C494A(*a1);
        sub_13937((void *)*v17, 75, 0, 0LL, 1LL, (__int64)v9, "sum(node-set)");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000D1FBB) ----------------------------------------------------
signed __int64 __fastcall sub_D1FBB(__int64 a1, __int64 a2, __int64 a3, void **a4, _DWORD *a5, __int64 a6)
{
  const char *v7; // rax
  _DWORD *v8; // [rsp+8h] [rbp-38h]
  void **v9; // [rsp+10h] [rbp-30h]
  unsigned int v10; // [rsp+3Ch] [rbp-4h]

  v9 = a4;
  v8 = a5;
  if ( a6 & 0x3C )
  {
    sub_C6D49((__int64)a5);
    return 0LL;
  }
  if ( !*a5 )
    return 0LL;
  if ( *a5 != 1 )
  {
    v7 = sub_C494A(a5);
    sub_13937(*v9, 71, 0, 0LL, (__int64)v7, (__int64)"text()");
    return 0xFFFFFFFFLL;
  }
  v10 = 0;
  while ( v10 < v8[8] )
  {
    switch ( *(_DWORD *)(16LL * v10 + *((_QWORD *)v8 + 2) + 8) )
    {
      case 0:
      case 1:
      case 3:
      case 4:
        goto LABEL_14;
      case 2:
        if ( *(_BYTE *)(*(_QWORD *)(16LL * v10 + *((_QWORD *)v8 + 2)) + 8LL) < 0 )
        {
          sub_13937(
            *v9,
            76,
            3u,
            *(char **)(16LL * v10 + *((_QWORD *)v8 + 2)),
            ***(_QWORD ***)(16LL * v10 + *((_QWORD *)v8 + 2)),
            a6);
          return 0xFFFFFFFFLL;
        }
        if ( *(_DWORD *)(**(_QWORD **)(16LL * v10 + *((_QWORD *)v8 + 2)) + 56LL) & 0xC
          && *(_QWORD *)(*(_QWORD *)(16LL * v10 + *((_QWORD *)v8 + 2)) + 56LL) )
        {
          *(_DWORD *)(16LL * v10++ + *((_QWORD *)v8 + 2) + 8) = 3;
        }
        else
        {
LABEL_14:
          sub_C6DA0(v8, v10);
        }
        break;
      default:
        sub_12222(
          (__int64)*v9,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          5143LL);
        return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (00000000000D21EC) ----------------------------------------------------
signed __int64 __fastcall sub_D21EC(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  const char *v7; // rax
  __int64 v8; // rbx
  const char *v9; // rax
  __int64 v10; // rbx
  const char *v11; // rax
  signed __int64 result; // rax
  size_t v13; // rax
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // [rsp+8h] [rbp-68h]
  __int64 *v17; // [rsp+10h] [rbp-60h]
  __int64 v18; // [rsp+18h] [rbp-58h]
  int v19; // [rsp+20h] [rbp-50h]
  unsigned __int16 i; // [rsp+3Eh] [rbp-32h]
  unsigned __int16 j; // [rsp+40h] [rbp-30h]
  int v22; // [rsp+42h] [rbp-2Eh]
  signed int v23; // [rsp+44h] [rbp-2Ch]
  signed int v24; // [rsp+48h] [rbp-28h]
  unsigned int v25; // [rsp+4Ch] [rbp-24h]
  _BYTE *v26; // [rsp+50h] [rbp-20h]
  __int64 v27; // [rsp+58h] [rbp-18h]
  __int64 v28; // [rsp+58h] [rbp-18h]
  __int64 v29; // [rsp+58h] [rbp-18h]

  v18 = a3;
  v17 = a4;
  v16 = a5;
  v19 = a6;
  v25 = 0;
  if ( a6 & 0x3C )
  {
    if ( *(_DWORD *)*a1 == 2 )
    {
      v27 = sub_CC407(*a1);
      if ( v27 )
      {
        if ( *(_DWORD *)(v27 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v27 + 128) )
          {
            sub_12222(
              *v17,
              1u,
              0,
              "Argument #1 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_translate",
              *(_QWORD *)v27);
            v25 = 1;
          }
        }
        else
        {
          v6 = *(_QWORD *)v27;
          v7 = sub_8164(*(_DWORD *)(v27 + 56));
          sub_12222(*v17, 1u, 0, "Argument #1 of %s is a %s node \"%s\".", (__int64)"xpath_translate", (__int64)v7, v6);
          v25 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[1] == 2 )
    {
      v28 = sub_CC407(a1[1]);
      if ( v28 )
      {
        if ( *(_DWORD *)(v28 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v28 + 128) )
          {
            sub_12222(
              *v17,
              1u,
              0,
              "Argument #2 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_translate",
              *(_QWORD *)v28);
            v25 = 1;
          }
        }
        else
        {
          v8 = *(_QWORD *)v28;
          v9 = sub_8164(*(_DWORD *)(v28 + 56));
          sub_12222(*v17, 1u, 0, "Argument #2 of %s is a %s node \"%s\".", (__int64)"xpath_translate", (__int64)v9, v8);
          v25 = 1;
        }
      }
    }
    if ( *(_DWORD *)a1[2] == 2 )
    {
      v29 = sub_CC407(a1[2]);
      if ( v29 )
      {
        if ( *(_DWORD *)(v29 + 56) & 0xC )
        {
          if ( !(unsigned int)sub_CC619(v29 + 128) )
          {
            sub_12222(
              *v17,
              1u,
              0,
              "Argument #3 of %s is node \"%s\", not of string-type.",
              (__int64)"xpath_translate",
              *(_QWORD *)v29);
            v25 = 1;
          }
        }
        else
        {
          v10 = *(_QWORD *)v29;
          v11 = sub_8164(*(_DWORD *)(v29 + 56));
          sub_12222(
            *v17,
            1u,
            0,
            "Argument #3 of %s is a %s node \"%s\".",
            (__int64)"xpath_translate",
            (__int64)v11,
            v10);
          v25 = 1;
        }
      }
    }
    sub_C6D49(v16);
    result = v25;
  }
  else if ( (unsigned int)sub_DC765(*a1, 5, a3, a4, a6) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[1], 5, v18, v17, v19) )
  {
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)sub_DC765(a1[2], 5, v18, v17, v19) )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v13 = strlen(*(const char **)(*a1 + 16));
    v26 = malloc(v13 + 1);
    if ( v26 )
    {
      LOWORD(v22) = 0;
      v24 = 0;
      for ( i = 0; *(_BYTE *)(*(_QWORD *)(*a1 + 16) + i); ++i )
      {
        v23 = 0;
        for ( j = 0; *(_BYTE *)(*(_QWORD *)(a1[1] + 16) + j); ++j )
        {
          if ( *(_BYTE *)(*(_QWORD *)(*a1 + 16) + i) == *(_BYTE *)(*(_QWORD *)(a1[1] + 16) + j) )
          {
            if ( j < strlen(*(const char **)(a1[2] + 16)) )
            {
              v26[(unsigned __int16)v22] = *(_BYTE *)(*(_QWORD *)(a1[2] + 16) + j);
              LOWORD(v22) = v22 + 1;
            }
            else
            {
              v24 = 1;
            }
            v23 = 1;
            break;
          }
        }
        if ( !v23 )
        {
          v26[(unsigned __int16)v22] = *(_BYTE *)(*(_QWORD *)(*a1 + 16) + i);
          v22 = (unsigned __int16)(v22 + 1);
        }
      }
      if ( !v24 || (v26 = sub_C422(v26, (unsigned __int16)v22 + 1)) != 0LL )
      {
        v26[(unsigned __int16)v22] = 0;
        sub_DC765(v16, 0, v18, v17, v19);
        *(_DWORD *)v16 = 5;
        *(_QWORD *)(v16 + 16) = v26;
        result = 0LL;
      }
      else
      {
        sub_12222(*v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"xpath_translate", v15);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      sub_12222(*v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"xpath_translate", v14);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (00000000000D27D8) ----------------------------------------------------
__int64 __fastcall sub_D27D8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, char a6)
{
  if ( a6 & 0x3C )
    sub_C6D49((__int64)a5);
  else
    sub_C6A0D(a5, 1);
  return 0LL;
}

//----- (00000000000D282F) ----------------------------------------------------
__int64 __fastcall sub_D282F(const char *a1, unsigned __int16 a2, __int64 a3, __int64 a4, int a5, int a6)
{
  __int64 v6; // rax
  const char *v7; // rax
  const char *v9; // rax
  const char *v10; // rax
  int v11; // [rsp+Ch] [rbp-44h]
  __int64 v12; // [rsp+18h] [rbp-38h]
  int v13; // [rsp+20h] [rbp-30h]
  unsigned __int16 i; // [rsp+36h] [rbp-1Ah]
  unsigned __int16 j; // [rsp+36h] [rbp-1Ah]
  __int64 v16; // [rsp+38h] [rbp-18h]
  __int64 v17; // [rsp+40h] [rbp-10h]
  char *s1; // [rsp+48h] [rbp-8h]
  char *s1a; // [rsp+48h] [rbp-8h]
  char *s1b; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v13 = a5;
  v11 = a6;
  if ( a4 )
  {
    if ( *(_BYTE *)(a3 + 88)
      && *(_QWORD *)(a4 + 48) != *(_QWORD *)(*(_QWORD *)(a3 + 72) + 8LL * *(unsigned __int8 *)(a3 + 88) - 8) )
    {
      v16 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 8LL * *(unsigned __int8 *)(a3 + 88) - 8);
      v6 = lys_main_module(v16);
    }
    else
    {
      v16 = *(_QWORD *)(a4 + 48);
      v6 = lys_main_module(v16);
    }
    v17 = v6;
    if ( v13 )
      v7 = *(const char **)(v6 + 8);
    else
      v7 = *(const char **)(v6 + 176);
    s1 = (char *)v7;
    if ( !strncmp(v7, a1, a2) && !s1[a2] )
      return v17;
    for ( i = 0; i < *(unsigned __int8 *)(v16 + 69); ++i )
    {
      if ( v13 )
        v9 = *(const char **)(*(_QWORD *)(*(_QWORD *)(v16 + 96) + 56LL * i) + 8LL);
      else
        v9 = *(const char **)(*(_QWORD *)(*(_QWORD *)(v16 + 96) + 56LL * i) + 176LL);
      s1a = (char *)v9;
      if ( !strncmp(v9, a1, a2) && !s1a[a2] )
        return *(_QWORD *)(*(_QWORD *)(v16 + 96) + 56LL * i);
    }
  }
  for ( j = 0; (signed int)j < *(_DWORD *)(v12 + 60); ++j )
  {
    if ( v11
      || *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v12 + 64)) + 64LL) < 0
      && !(*(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v12 + 64)) + 64LL) & 0x40) )
    {
      v10 = (const char *)(v13 ? *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v12 + 64)) + 8LL) : *(_QWORD *)(*(_QWORD *)(8LL * j + *(_QWORD *)(v12 + 64)) + 176LL));
      s1b = (char *)v10;
      if ( !strncmp(v10, a1, a2) && !s1b[a2] )
        return *(_QWORD *)(8LL * j + *(_QWORD *)(v12 + 64));
    }
  }
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000D2AFF) ----------------------------------------------------
__int64 __fastcall sub_D2AFF(__int64 a1, int a2, _DWORD *a3)
{
  __int64 result; // rax
  __int64 j; // [rsp+20h] [rbp-8h]
  __int64 i; // [rsp+20h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  if ( a2 )
  {
    if ( *(_WORD *)(*(_QWORD *)a1 + 24LL) & 1 )
      *a3 = 1;
    else
      *a3 = 0;
    for ( i = a1; *(_QWORD *)(i + 40); i = *(_QWORD *)(i + 40) )
      ;
    while ( *(_QWORD *)(*(_QWORD *)(i + 32) + 24LL) )
      i = *(_QWORD *)(i + 32);
    result = i;
  }
  else
  {
    for ( j = a1; *(_QWORD *)(j + 40); j = *(_QWORD *)(j + 40) )
      ;
    while ( *(_QWORD *)(*(_QWORD *)(j + 32) + 24LL) )
      j = *(_QWORD *)(j + 32);
    *a3 = 0;
    result = j;
  }
  return result;
}

//----- (00000000000D2BEA) ----------------------------------------------------
__int64 __fastcall sub_D2BEA(__int64 a1, char a2, _DWORD *a3)
{
  __int64 v3; // rax

  if ( !a1 || !a3 )
    __assert_fail(
      "cur_node && root_type",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x151Bu,
      "moveto_snode_get_root");
  if ( a2 & 4 )
  {
    *a3 = 0;
  }
  else if ( *(_WORD *)(a1 + 24) & 1 )
  {
    *a3 = 1;
  }
  else
  {
    *a3 = 0;
  }
  v3 = lys_node_module(a1);
  return lys_getnext(0LL, 0LL, v3, 256LL);
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000D2C95) ----------------------------------------------------
unsigned __int64 __fastcall sub_D2C95(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-34h]
  int v5; // [rsp+2Ch] [rbp-14h]
  __int64 v6; // [rsp+30h] [rbp-10h]
  unsigned __int64 v7; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v7 = __readfsqword(0x28u);
  if ( a1 )
  {
    v6 = sub_D2AFF(a2, a3, &v5);
    sub_DC765(a1, 0, a2, 0LL, v4);
    if ( v6 )
      sub_C7395(a1, v6, 0, v5, 0);
  }
  return __readfsqword(0x28u) ^ v7;
}

//----- (00000000000D2D37) ----------------------------------------------------
unsigned __int64 __fastcall sub_D2D37(__int64 a1, __int64 a2, char a3)
{
  int v4; // [rsp+2Ch] [rbp-14h]
  __int64 v5; // [rsp+30h] [rbp-10h]
  unsigned __int64 v6; // [rsp+38h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = sub_D2BEA(a2, a3, &v4);
      sub_C6D49(a1);
      sub_C765D(a1, v5, v4);
    }
    else
    {
      sub_12222(
        0LL,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        5456LL);
    }
  }
  return __readfsqword(0x28u) ^ v6;
}

//----- (00000000000D2DEA) ----------------------------------------------------
signed __int64 __fastcall sub_D2DEA(_BYTE *a1, int a2, char *a3, __int64 a4, char a5)
{
  char *s1; // [rsp+8h] [rbp-18h]
  char v7; // [rsp+10h] [rbp-10h]

  s1 = a3;
  v7 = a5;
  if ( a4 && a4 != lyd_node_module(a1) )
    return 0xFFFFFFFFLL;
  if ( a2 == 1 && *(_WORD *)(*(_QWORD *)a1 + 24LL) & 2 )
    return 0xFFFFFFFFLL;
  if ( strcmp(s1, "*") && s1 != **(char ***)a1 )
    return 0xFFFFFFFFLL;
  if ( v7 & 2 && (a1[9] >> 1) & 4 && !((a1[9] >> 1) & 3) )
    return 1LL;
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000D2EBE) ----------------------------------------------------
signed __int64 __fastcall sub_D2EBE(__int64 a1, int a2, char *a3, __int64 a4, char a5)
{
  __int64 v6; // [rsp+0h] [rbp-30h]
  char *s1; // [rsp+8h] [rbp-28h]
  char v8; // [rsp+10h] [rbp-20h]
  __int64 i; // [rsp+28h] [rbp-8h]

  s1 = a3;
  v6 = a4;
  v8 = a5;
  for ( i = lys_parent(a1); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( v8 & 0x20 )
  {
    if ( i && *(_DWORD *)(i + 56) == 512 )
      return 0xFFFFFFFFLL;
  }
  else if ( i && *(_DWORD *)(i + 56) == 1024 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( strcmp(s1, "*") && v6 != lys_node_module(a1) )
    return 0xFFFFFFFFLL;
  if ( a2 == 1 && *(_WORD *)(a1 + 24) & 2 )
    return 0xFFFFFFFFLL;
  if ( !strcmp(s1, "*") || s1 == *(char **)a1 )
    return 0LL;
  return 0xFFFFFFFFLL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000D2FD6) ----------------------------------------------------
signed __int64 __fastcall sub_D2FD6(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5)
{
  const char *v6; // rax
  __int64 v7; // [rsp+0h] [rbp-70h]
  char *v8; // [rsp+8h] [rbp-68h]
  int v9; // [rsp+2Ch] [rbp-44h]
  unsigned int v10; // [rsp+30h] [rbp-40h]
  int v11; // [rsp+34h] [rbp-3Ch]
  unsigned int v12; // [rsp+38h] [rbp-38h]
  int v13; // [rsp+3Ch] [rbp-34h]
  __int64 v14; // [rsp+40h] [rbp-30h]
  __int64 i; // [rsp+48h] [rbp-28h]
  char *v16; // [rsp+50h] [rbp-20h]
  void *v17; // [rsp+58h] [rbp-18h]
  _BYTE *v18; // [rsp+60h] [rbp-10h]
  unsigned __int64 v19; // [rsp+68h] [rbp-8h]

  v8 = a3;
  LODWORD(v7) = a5;
  WORD2(v7) = a4;
  v19 = __readfsqword(0x28u);
  v16 = 0LL;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( !a2 )
    __assert_fail("cur_node", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x15C0u, "moveto_node");
  v17 = **(void ***)(*(_QWORD *)a2 + 48LL);
  if ( *(_DWORD *)a1 != 1 )
  {
    v6 = sub_C494A((_DWORD *)a1);
    sub_13937(v17, 69, 0, 0LL, (__int64)"path operator", (__int64)v6, v7);
    return 0xFFFFFFFFLL;
  }
  sub_D2AFF(a2, a5, &v9);
  v18 = sub_811F(v8, 58, WORD2(v7));
  if ( v18 )
  {
    v12 = (_DWORD)v18 - (_DWORD)v8;
    v14 = sub_D282F(v8, (unsigned __int16)v18 - (unsigned __int16)v8, (__int64)v17, 0LL, 1, 0);
    if ( !v14 )
    {
      sub_13937(v17, 72, 0, 0LL, v12, (__int64)v8, v7);
      return 0xFFFFFFFFLL;
    }
    v8 += (signed int)v12 + 1;
    WORD2(v7) = WORD2(v7) - v12 - 1;
  }
  else if ( *v8 != 42 || WORD2(v7) != 1 )
  {
    v14 = lyd_node_module(a2);
  }
  else
  {
    v14 = 0LL;
  }
  v16 = (char *)lydict_insert(v17, v8, WORD2(v7));
  v10 = 0;
  while ( v10 < *(_DWORD *)(a1 + 32) )
  {
    v11 = 0;
    if ( *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 8) != 1 && *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 8) )
    {
      if ( *(_BYTE *)(*(_QWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16)) + 8LL) >= 0
        && !(*(_DWORD *)(**(_QWORD **)(16LL * v10 + *(_QWORD *)(a1 + 16)) + 56LL) & 0x802C) )
      {
        for ( i = *(_QWORD *)(*(_QWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16)) + 64LL); i; i = *(_QWORD *)(i + 24) )
        {
          v13 = sub_D2DEA((_BYTE *)i, v9, v16, v14, v7);
          if ( v13 )
          {
            if ( v13 == 1 )
            {
              lydict_remove(v17, v16);
              return 1LL;
            }
          }
          else
          {
            if ( v11 )
            {
              sub_C7395(a1, i, 0, 2, v10);
            }
            else
            {
              sub_C77EE(a1, i, 0, 2, v10);
              v11 = 1;
            }
            ++v10;
          }
        }
      }
    }
    else
    {
      for ( i = *(_QWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16)); i; i = *(_QWORD *)(i + 24) )
      {
        v13 = sub_D2DEA((_BYTE *)i, v9, v16, v14, v7);
        if ( v13 )
        {
          if ( v13 == 1 )
          {
            lydict_remove(v17, v16);
            return 1LL;
          }
        }
        else
        {
          if ( v11 )
          {
            sub_C7395(a1, i, 0, 2, v10);
          }
          else
          {
            sub_C77EE(a1, i, 0, 2, v10);
            v11 = 1;
          }
          ++v10;
        }
      }
    }
    if ( !v11 )
      sub_C6DA0((_DWORD *)a1, v10);
  }
  lydict_remove(v17, v16);
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000D345B) ----------------------------------------------------
signed __int64 __fastcall sub_D345B(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5)
{
  const char *v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // [rsp+0h] [rbp-90h]
  char *v10; // [rsp+8h] [rbp-88h]
  int v11; // [rsp+2Ch] [rbp-64h]
  int v12; // [rsp+30h] [rbp-60h]
  int i; // [rsp+34h] [rbp-5Ch]
  int v14; // [rsp+38h] [rbp-58h]
  unsigned int v15; // [rsp+3Ch] [rbp-54h]
  int v16; // [rsp+40h] [rbp-50h]
  int v17; // [rsp+44h] [rbp-4Ch]
  __int64 v18; // [rsp+48h] [rbp-48h]
  __int64 v19; // [rsp+50h] [rbp-40h]
  __int64 v20; // [rsp+58h] [rbp-38h]
  __int64 v21; // [rsp+60h] [rbp-30h]
  char *v22; // [rsp+68h] [rbp-28h]
  void *v23; // [rsp+70h] [rbp-20h]
  _BYTE *v24; // [rsp+78h] [rbp-18h]
  __int64 v25; // [rsp+80h] [rbp-10h]
  unsigned __int64 v26; // [rsp+88h] [rbp-8h]

  v10 = a3;
  LODWORD(v9) = a5;
  WORD2(v9) = a4;
  v26 = __readfsqword(0x28u);
  v14 = 0;
  v22 = 0LL;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  v23 = **(void ***)(a2 + 48);
  if ( *(_DWORD *)a1 != 2 )
  {
    v6 = sub_C494A((_DWORD *)a1);
    sub_13937(v23, 69, 0, 0LL, (__int64)"path operator", (__int64)v6, v9);
    return 0xFFFFFFFFLL;
  }
  sub_D2BEA(a2, a5, &v12);
  v24 = sub_811F(v10, 58, WORD2(v9));
  if ( v24 )
  {
    v15 = (_DWORD)v24 - (_DWORD)v10;
    v18 = sub_D282F(v10, (unsigned __int16)v24 - (unsigned __int16)v10, (__int64)v23, a2, 1, 1);
    if ( !v18 )
    {
      sub_13937(v23, 72, 0, 0LL, v15, (__int64)v10, v9);
      return 0xFFFFFFFFLL;
    }
    v10 += (signed int)v15 + 1;
    WORD2(v9) = WORD2(v9) - v15 - 1;
  }
  else if ( *v10 != 42 || WORD2(v9) != 1 )
  {
    v18 = lys_node_module(a2);
  }
  else
  {
    v18 = 0LL;
  }
  v22 = (char *)lydict_insert(v23, v10, WORD2(v9));
  v16 = *(_DWORD *)(a1 + 32);
  for ( i = 0; i < v16; ++i )
  {
    if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 1 )
    {
      *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) = 0;
      v25 = *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16));
      if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8) != 1 && *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8) )
      {
        if ( !(*(_DWORD *)(v25 + 56) & 0x802C) )
        {
          v21 = 0LL;
          v19 = 0LL;
          if ( v18 && *(_BYTE *)(v18 + 64) >= 0 || !v18 && !(*(_BYTE *)(lys_node_module(a2) + 64) & 0x80) )
          {
            if ( v18 )
              v19 = v18;
            else
              v19 = lys_node_module(a2);
            goto LABEL_39;
          }
          while ( 1 )
          {
            v20 = 0LL;
            while ( 1 )
            {
              v8 = v21 ? v21 : v25;
              v20 = lys_getnext(v20, v8, 0LL, 256LL);
              if ( !v20 )
                break;
              if ( v18 )
                v7 = v18;
              else
                v7 = lys_node_module(a2);
              if ( !(unsigned int)sub_D2EBE(v20, v12, v22, v7, v9) )
              {
                v17 = sub_C765D(a1, v20, 2);
                if ( v17 < v16 && v17 > i )
                {
                  *(_DWORD *)(16LL * v17 + *(_QWORD *)(a1 + 16) + 12) = 2;
                  v14 = 1;
                }
              }
            }
            if ( !v21 )
              break;
LABEL_39:
            v21 = sub_AA881(v21, v19, v25);
          }
        }
      }
      else
      {
        v11 = 0;
        while ( 1 )
        {
          if ( !v18 )
          {
            v18 = ly_ctx_get_module_iter(v23, &v11);
            if ( !v18 )
              break;
          }
          v20 = 0LL;
          while ( 1 )
          {
            v20 = lys_getnext(v20, 0LL, v18, 256LL);
            if ( !v20 )
              break;
            if ( !(unsigned int)sub_D2EBE(v20, v12, v22, v18, v9) )
            {
              v17 = sub_C765D(a1, v20, 2);
              if ( v17 < v16 && v17 > i )
              {
                *(_DWORD *)(16LL * v17 + *(_QWORD *)(a1 + 16) + 12) = 2;
                v14 = 1;
              }
            }
          }
          if ( !v11 )
            break;
          v18 = 0LL;
        }
      }
    }
  }
  lydict_remove(v23, v22);
  if ( v14 )
  {
    for ( i = 0; i < v16; ++i )
    {
      if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 2 )
        *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) = 1;
    }
  }
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000D3A01) ----------------------------------------------------
signed __int64 __fastcall sub_D3A01(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5)
{
  const char *v6; // rax
  int v7; // eax
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // [rsp+0h] [rbp-C0h]
  char *s2; // [rsp+8h] [rbp-B8h]
  int v12; // [rsp+28h] [rbp-98h]
  unsigned int i; // [rsp+2Ch] [rbp-94h]
  int v14; // [rsp+30h] [rbp-90h]
  int v15; // [rsp+34h] [rbp-8Ch]
  unsigned int v16; // [rsp+38h] [rbp-88h]
  unsigned int v17; // [rsp+3Ch] [rbp-84h]
  _BYTE *v18; // [rsp+40h] [rbp-80h]
  _BYTE *j; // [rsp+48h] [rbp-78h]
  __int64 v20; // [rsp+50h] [rbp-70h]
  _BYTE *v21; // [rsp+58h] [rbp-68h]
  char s; // [rsp+60h] [rbp-60h]
  unsigned int v23; // [rsp+80h] [rbp-40h]
  int v24; // [rsp+90h] [rbp-30h]
  int v25; // [rsp+94h] [rbp-2Ch]
  unsigned __int64 v26; // [rsp+A8h] [rbp-18h]

  s2 = a3;
  LODWORD(v10) = a5;
  WORD2(v10) = a4;
  v26 = __readfsqword(0x28u);
  v14 = 0;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 != 1 )
  {
    v6 = sub_C494A((_DWORD *)a1);
    sub_13937(**(void ***)(*(_QWORD *)a2 + 48LL), 69, 0, 0LL, (__int64)"path operator", (__int64)v6, v10);
    return 0xFFFFFFFFLL;
  }
  sub_D2AFF(a2, a5, &v12);
  if ( sub_811F(s2, 58, WORD2(v10)) && a2 )
  {
    v7 = (unsigned __int64)sub_811F(s2, 58, WORD2(v10));
    v16 = v7 - (_DWORD)s2;
    v20 = sub_D282F(s2, (unsigned __int16)v7 - (unsigned __int16)s2, **(_QWORD **)(*(_QWORD *)a2 + 48LL), 0LL, 1, 0);
    if ( !v20 )
    {
      sub_13937(**(void ***)(*(_QWORD *)a2 + 48LL), 72, 0, 0LL, v16, (__int64)s2, v10);
      return 0xFFFFFFFFLL;
    }
    s2 += (signed int)v16 + 1;
    WORD2(v10) = WORD2(v10) - v16 - 1;
  }
  else
  {
    v20 = 0LL;
  }
  v17 = sub_D2FD6(a1, a2, "*", 1, v10);
  if ( v17 )
    return v17;
  if ( WORD2(v10) == 1 && *s2 == 42 )
    v14 = 1;
  memset(&s, 0, 0x40uLL);
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    v21 = *(_BYTE **)(16LL * i + *(_QWORD *)(a1 + 16));
    v18 = v21;
    for ( j = v21; j; j = v18 )
    {
      if ( v10 & 2 && (j[9] >> 1) & 4 && !((j[9] >> 1) & 3) )
        return 1LL;
      if ( j[8] < 0 || v12 == 1 && *(_WORD *)(*(_QWORD *)j + 24LL) & 2 )
        goto LABEL_56;
      v15 = 1;
      if ( !v14 )
      {
        if ( v20 && (v8 = lys_node_module(*(_QWORD *)j), v20 != v8) )
        {
          v15 = 0;
        }
        else if ( !v20 )
        {
          v9 = lys_node_module(*(_QWORD *)j);
          if ( v9 != lyd_node_module(a2) )
            v15 = 0;
        }
      }
      if ( v15 && !v14 && (strncmp(**(const char ***)j, s2, WORD2(v10)) || *(_BYTE *)(**(_QWORD **)j + WORD2(v10))) )
        v15 = 0;
      if ( v15 && (sub_C7395((__int64)&s, (__int64)j, 0, 2, v23), (unsigned int)sub_C705F(a1, (__int64)j, 2, i))
        || (!(*(_DWORD *)(*(_QWORD *)j + 56LL) & 0x802C) ? (v18 = (_BYTE *)*((_QWORD *)j + 8)) : (v18 = 0LL), !v18) )
      {
LABEL_56:
        if ( j == v21 )
          break;
        v18 = (_BYTE *)*((_QWORD *)j + 3);
      }
      while ( !v18 && v21 != *((_BYTE **)j + 5) )
      {
        j = (_BYTE *)*((_QWORD *)j + 5);
        v18 = (_BYTE *)*((_QWORD *)j + 3);
      }
    }
  }
  v24 = *(_DWORD *)(a1 + 48);
  v25 = *(_DWORD *)(a1 + 52);
  sub_C65F5(a1);
  memcpy((void *)a1, &s, 0x40uLL);
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000D3F81) ----------------------------------------------------
signed __int64 __fastcall sub_D3F81(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5)
{
  const char *v6; // rax
  int v7; // eax
  unsigned int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // [rsp+0h] [rbp-80h]
  char *s2; // [rsp+8h] [rbp-78h]
  int v14; // [rsp+24h] [rbp-5Ch]
  int i; // [rsp+28h] [rbp-58h]
  int v16; // [rsp+2Ch] [rbp-54h]
  int v17; // [rsp+30h] [rbp-50h]
  unsigned int v18; // [rsp+34h] [rbp-4Ch]
  int v19; // [rsp+38h] [rbp-48h]
  int v20; // [rsp+3Ch] [rbp-44h]
  __int64 k; // [rsp+40h] [rbp-40h]
  __int64 j; // [rsp+48h] [rbp-38h]
  __int64 v23; // [rsp+50h] [rbp-30h]
  void *v24; // [rsp+58h] [rbp-28h]
  __int64 v25; // [rsp+60h] [rbp-20h]
  unsigned __int64 v26; // [rsp+68h] [rbp-18h]

  s2 = a3;
  LODWORD(v12) = a5;
  WORD2(v12) = a4;
  v26 = __readfsqword(0x28u);
  v16 = 0;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  v24 = **(void ***)(a2 + 48);
  if ( *(_DWORD *)a1 != 2 )
  {
    v6 = sub_C494A((_DWORD *)a1);
    sub_13937(v24, 69, 0, 0LL, (__int64)"path operator", (__int64)v6, v12);
    return 0xFFFFFFFFLL;
  }
  sub_D2BEA(a2, a5, &v14);
  if ( sub_811F(s2, 58, WORD2(v12)) )
  {
    v7 = (unsigned __int64)sub_811F(s2, 58, WORD2(v12));
    v18 = v7 - (_DWORD)s2;
    v23 = sub_D282F(s2, (unsigned __int16)v7 - (unsigned __int16)s2, (__int64)v24, a2, 1, 1);
    if ( !v23 )
    {
      sub_13937(v24, 72, 0, 0LL, v18, (__int64)s2, v12);
      return 0xFFFFFFFFLL;
    }
    s2 += (signed int)v18 + 1;
    WORD2(v12) = WORD2(v12) - v18 - 1;
  }
  else
  {
    v23 = 0LL;
  }
  if ( WORD2(v12) == 1 && *s2 == 42 )
    v16 = 1;
  v19 = *(_DWORD *)(a1 + 32);
  for ( i = 0; i < v19; ++i )
  {
    if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 1 )
    {
      *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) = 0;
      v25 = *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16));
      k = v25;
      for ( j = v25; ; j = k )
      {
        if ( !j )
          break;
        if ( v14 == 1 && *(_WORD *)(j + 24) & 2 )
          goto LABEL_55;
        v8 = *(_DWORD *)(j + 56);
        if ( v8 == 512 )
        {
          if ( !(v12 & 0x20) )
            goto LABEL_52;
          goto LABEL_55;
        }
        if ( v8 > 0x200 )
        {
          switch ( v8 )
          {
            case 0x800u:
              goto LABEL_55;
            case 0x1000u:
              goto LABEL_52;
            case 0x400u:
              if ( v12 & 0x20 )
                goto LABEL_52;
              goto LABEL_55;
          }
        }
        else if ( v8 == 2 || v8 == 64 )
        {
          goto LABEL_52;
        }
        v17 = 1;
        if ( j == v25 )
          v17 = 0;
        if ( v17 && !v16 )
        {
          if ( v23 && (v9 = lys_node_module(j), v23 != v9) )
          {
            v17 = 0;
          }
          else if ( !v23 )
          {
            v10 = lys_node_module(j);
            if ( v10 != lys_node_module(a2) )
              v17 = 0;
          }
        }
        if ( v17 && !v16 && (strncmp(*(const char **)j, s2, WORD2(v12)) || *(_BYTE *)(*(_QWORD *)j + WORD2(v12))) )
          v17 = 0;
        if ( !v17 )
          goto LABEL_52;
        v20 = sub_C7105(a1, j, 2, i);
        if ( v20 < 0 )
        {
          sub_C765D(a1, j, 2);
LABEL_52:
          k = *(_QWORD *)(j + 72);
          if ( *(_DWORD *)(j + 56) & 0x802C )
            k = 0LL;
          if ( k )
            goto LABEL_59;
          goto LABEL_55;
        }
        *(_DWORD *)(16LL * v20 + *(_QWORD *)(a1 + 16) + 12) = 1;
        if ( v20 <= i )
          goto LABEL_52;
LABEL_55:
        if ( j == v25 )
          break;
LABEL_59:
        for ( k = *(_QWORD *)(j + 80); !k; k = *(_QWORD *)(j + 80) )
        {
          v11 = lys_parent(j);
          if ( v25 == v11 )
            break;
          j = lys_parent(j);
        }
      }
    }
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000D4437) ----------------------------------------------------
signed __int64 __fastcall sub_D4437(__int64 a1, __int64 a2, char *a3, unsigned __int16 a4, int a5)
{
  const char *v6; // rax
  int v7; // eax
  __int64 v8; // [rsp+0h] [rbp-40h]
  char *s2; // [rsp+8h] [rbp-38h]
  unsigned int v10; // [rsp+20h] [rbp-20h]
  signed int v11; // [rsp+24h] [rbp-1Ch]
  signed int v12; // [rsp+28h] [rbp-18h]
  unsigned int v13; // [rsp+2Ch] [rbp-14h]
  __int64 v14; // [rsp+30h] [rbp-10h]
  __int64 i; // [rsp+38h] [rbp-8h]

  s2 = a3;
  LODWORD(v8) = a5;
  WORD2(v8) = a4;
  v12 = 0;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 != 1 )
  {
    v6 = sub_C494A((_DWORD *)a1);
    sub_13937(**(void ***)(*(_QWORD *)a2 + 48LL), 69, 0, 0LL, (__int64)"path operator", (__int64)v6, v8);
    return 0xFFFFFFFFLL;
  }
  if ( sub_811F(a3, 58, a4) && a2 )
  {
    v7 = (unsigned __int64)sub_811F(s2, 58, WORD2(v8));
    v13 = v7 - (_DWORD)s2;
    v14 = sub_D282F(s2, (unsigned __int16)v7 - (unsigned __int16)s2, **(_QWORD **)(*(_QWORD *)a2 + 48LL), 0LL, 1, 0);
    if ( !v14 )
    {
      sub_13937(**(void ***)(*(_QWORD *)a2 + 48LL), 72, 0, 0LL, v13, (__int64)s2, v8);
      return 0xFFFFFFFFLL;
    }
    s2 += (signed int)v13 + 1;
    WORD2(v8) = WORD2(v8) - v13 - 1;
  }
  else
  {
    v14 = 0LL;
  }
  if ( WORD2(v8) == 1 && *s2 == 42 )
    v12 = 1;
  v10 = 0;
  while ( v10 < *(_DWORD *)(a1 + 32) )
  {
    v11 = 0;
    if ( *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 8) == 2
      && *(_BYTE *)(*(_QWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16)) + 8LL) >= 0 )
    {
      for ( i = *(_QWORD *)(*(_QWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16)) + 16LL); i; i = *(_QWORD *)(i + 8) )
      {
        if ( (!v14 || v14 == *(_QWORD *)(*(_QWORD *)(i + 16) + 48LL))
          && (v12 || !strncmp(*(const char **)(i + 24), s2, WORD2(v8)) && !*(_BYTE *)(*(_QWORD *)(i + 24) + WORD2(v8))) )
        {
          if ( v11 )
          {
            sub_C7395(a1, i, *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 12), 4, v10 + 1);
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v10) = i;
            *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 8) = 4;
            v11 = 1;
          }
          ++v10;
        }
      }
    }
    if ( !v11 )
      sub_C6DA0((_DWORD *)a1, v10);
  }
  return 0LL;
}

//----- (00000000000D476C) ----------------------------------------------------
signed __int64 __fastcall sub_D476C(_DWORD *a1, _DWORD *a2, _QWORD **a3, int a4)
{
  void *v4; // rax
  const char *v5; // rbx
  const char *v6; // rax
  signed __int64 result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // [rsp+4h] [rbp-3Ch]
  __int64 v11; // [rsp+8h] [rbp-38h]
  void *v12; // [rsp+28h] [rbp-18h]

  v11 = (__int64)a3;
  v10 = a4;
  if ( a4 & 4 )
    v4 = (void *)*a3[6];
  else
    v4 = *(void **)(*a3)[6];
  v12 = v4;
  if ( *a1 != 1 && *a1 || *a2 != 1 && *a2 )
  {
    v5 = sub_C494A(a2);
    v6 = sub_C494A(a1);
    sub_13937(v12, 70, 0, 0LL, (__int64)"union", (__int64)v6, v5);
    result = 0xFFFFFFFFLL;
  }
  else if ( *a2 )
  {
    if ( *a1 )
    {
      if ( (unsigned int)sub_C8295((__int64)a1, (__int64)a3, a4) || (unsigned int)sub_C8295((__int64)a2, v11, v10) )
        __assert_fail(
          "!set_sort(set1, cur_node, options) && !set_sort(set2, cur_node, options)",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x182Au,
          "moveto_union");
      if ( (unsigned int)sub_C870E((__int64)a1, (__int64)a2, v11, v10, v8, v9) )
      {
        result = 0xFFFFFFFFLL;
      }
      else
      {
        if ( (unsigned int)sub_C8295((__int64)a1, v11, v10) )
          __assert_fail(
            "!set_sort(set1, cur_node, options)",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0x1832u,
            "moveto_union");
        result = 0LL;
      }
    }
    else
    {
      memcpy(a1, a2, 0x40uLL);
      *a2 = 0;
      result = 0LL;
    }
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (00000000000D4935) ----------------------------------------------------
signed __int64 __fastcall sub_D4935(__int64 a1, _QWORD **a2, char *a3, unsigned __int16 a4, int a5)
{
  signed __int64 result; // rax
  const char *v6; // rax
  int v7; // eax
  __int64 v8; // [rsp+0h] [rbp-50h]
  char *s2; // [rsp+8h] [rbp-48h]
  unsigned int v10; // [rsp+24h] [rbp-2Ch]
  signed int v11; // [rsp+28h] [rbp-28h]
  signed int v12; // [rsp+2Ch] [rbp-24h]
  unsigned int v13; // [rsp+30h] [rbp-20h]
  unsigned int v14; // [rsp+34h] [rbp-1Ch]
  __int64 i; // [rsp+38h] [rbp-18h]
  __int64 v16; // [rsp+40h] [rbp-10h]
  void **v17; // [rsp+48h] [rbp-8h]

  s2 = a3;
  LODWORD(v8) = a5;
  WORD2(v8) = a4;
  v12 = 0;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 != 1 )
  {
    v6 = sub_C494A((_DWORD *)a1);
    sub_13937(*(void **)(*a2)[6], 69, 0, 0LL, (__int64)"path operator", (__int64)v6, v8);
    return 0xFFFFFFFFLL;
  }
  if ( sub_811F(a3, 58, a4) )
  {
    v7 = (unsigned __int64)sub_811F(s2, 58, WORD2(v8));
    v13 = v7 - (_DWORD)s2;
    v16 = sub_D282F(s2, (unsigned __int16)v7 - (unsigned __int16)s2, *(_QWORD *)(*a2)[6], 0LL, 1, 0);
    if ( !v16 )
    {
      sub_13937(*(void **)(*a2)[6], 72, 0, 0LL, v13, (__int64)s2, v8);
      return 0xFFFFFFFFLL;
    }
    s2 += (signed int)v13 + 1;
    WORD2(v8) = WORD2(v8) - v13 - 1;
  }
  else
  {
    v16 = 0LL;
  }
  v17 = sub_C66B8((const char **)a1);
  v14 = sub_D3A01((__int64)v17, (__int64)a2, "*", 1, v8);
  if ( v14 )
  {
    sub_C6688(v17);
    result = v14;
  }
  else if ( (unsigned int)sub_D476C((_DWORD *)a1, v17, a2, v8) )
  {
    sub_C6688(v17);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_C6688(v17);
    if ( WORD2(v8) == 1 && *s2 == 42 )
      v12 = 1;
    v10 = 0;
    while ( v10 < *(_DWORD *)(a1 + 32) )
    {
      v11 = 0;
      if ( *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 8) == 2 )
      {
        for ( i = *(_QWORD *)(*(_QWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16)) + 16LL); i; i = *(_QWORD *)(i + 8) )
        {
          if ( (!v16 || v16 == *(_QWORD *)(*(_QWORD *)(i + 16) + 48LL))
            && (v12 || !strncmp(*(const char **)(i + 24), s2, WORD2(v8)) && !*(_BYTE *)(*(_QWORD *)(i + 24) + WORD2(v8))) )
          {
            if ( v11 )
            {
              sub_C7395(a1, i, *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 12), 4, v10 + 1);
            }
            else
            {
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL * v10) = i;
              *(_DWORD *)(16LL * v10 + *(_QWORD *)(a1 + 16) + 8) = 4;
              v11 = 1;
            }
            ++v10;
          }
        }
      }
      if ( !v11 )
        sub_C6DA0((_DWORD *)a1, v10);
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000D4CD2) ----------------------------------------------------
signed __int64 __fastcall sub_D4CD2(__int64 a1, int a2, unsigned int a3, __int64 a4, __int64 a5, int a6, char a7)
{
  __int64 *v7; // rax
  int v9; // [rsp+Ch] [rbp-34h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  unsigned int v12; // [rsp+34h] [rbp-Ch]
  unsigned int v13; // [rsp+34h] [rbp-Ch]
  __int64 i; // [rsp+38h] [rbp-8h]

  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( a3 <= 1 )
  {
    if ( !(unsigned int)sub_C705F(a5, a1, 2, -1) )
    {
      sub_C7395(v11, a1, 0, 2, *(_DWORD *)(v11 + 32));
      if ( !(*(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x8020) && *(_BYTE *)(a1 + 8) >= 0 )
      {
        v12 = sub_D4CD2(a1);
        if ( v12 )
          return v12;
      }
    }
  }
  else
  {
    if ( a3 != 2 )
    {
      v7 = (__int64 *)lyd_node_module(a1);
      sub_12222(
        *v7,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        6369LL);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC )
    {
      if ( *(_QWORD *)(a1 + 56) && !(unsigned int)sub_C705F(a5, a1, 3, -1) )
        sub_C7395(v11, a1, a2, 3, *(_DWORD *)(v11 + 32));
    }
    else
    {
      for ( i = *(_QWORD *)(a1 + 64); i; i = *(_QWORD *)(i + 24) )
      {
        if ( v9 != 1 || !(*(_WORD *)(*(_QWORD *)i + 24LL) & 2) )
        {
          if ( a7 & 2 && (*(_BYTE *)(i + 9) >> 1) & 4 && !((*(_BYTE *)(i + 9) >> 1) & 3) )
            return 1LL;
          if ( !(unsigned int)sub_C705F(v10, i, 2, -1) )
          {
            sub_C7395(v11, i, 0, 2, *(_DWORD *)(v11 + 32));
            if ( !(*(_DWORD *)(*(_QWORD *)i + 56LL) & 0x8020) && *(_BYTE *)(i + 8) >= 0 )
            {
              v13 = sub_D4CD2(i);
              if ( v13 )
                return v13;
            }
          }
        }
      }
    }
  }
  return 0LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000D4FB0) ----------------------------------------------------
signed __int64 __fastcall sub_D4FB0(_QWORD *a1, __int64 a2, int a3, char a4)
{
  signed __int64 result; // rax
  const char *v5; // rax
  char v6; // [rsp+8h] [rbp-78h]
  int v7; // [rsp+24h] [rbp-5Ch]
  unsigned int i; // [rsp+28h] [rbp-58h]
  unsigned int v9; // [rsp+2Ch] [rbp-54h]
  char s; // [rsp+30h] [rbp-50h]
  unsigned int v11; // [rsp+50h] [rbp-30h]
  int v12; // [rsp+60h] [rbp-20h]
  int v13; // [rsp+64h] [rbp-1Ch]
  unsigned __int64 v14; // [rsp+78h] [rbp-8h]

  v6 = a4;
  v14 = __readfsqword(0x28u);
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 == 1 )
  {
    if ( a3 )
    {
      sub_D2AFF(a2, a4, &v7);
      memset(&s, 0, 0x40uLL);
      for ( i = 0; i < *((_DWORD *)a1 + 8); ++i )
      {
        sub_C7395(
          (__int64)&s,
          *(_QWORD *)(16LL * i + a1[2]),
          *(_DWORD *)(16LL * i + a1[2] + 12),
          *(_DWORD *)(16LL * i + a1[2] + 8),
          v11);
        if ( *(_DWORD *)(16LL * i + a1[2] + 8) != 3
          && *(_DWORD *)(16LL * i + a1[2] + 8) != 4
          && !(*(_DWORD *)(**(_QWORD **)(16LL * i + a1[2]) + 56LL) & 0x8020)
          && *(_BYTE *)(*(_QWORD *)(16LL * i + a1[2]) + 8LL) >= 0 )
        {
          v9 = sub_D4CD2(
                 *(_QWORD *)(16LL * i + a1[2]),
                 *(_DWORD *)(16LL * i + a1[2] + 12),
                 *(_DWORD *)(16LL * i + a1[2] + 8),
                 (__int64)&s,
                 (__int64)a1,
                 v7,
                 v6);
          if ( v9 )
          {
            sub_C65F5((__int64)&s);
            return v9;
          }
        }
      }
      v12 = *((_DWORD *)a1 + 12);
      v13 = *((_DWORD *)a1 + 13);
      sub_C65F5((__int64)a1);
      memcpy(a1, &s, 0x40uLL);
      result = 0LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    v5 = sub_C494A(a1);
    sub_13937(**(void ***)(*(_QWORD *)a2 + 48LL), 69, 0, 0LL, (__int64)"path operator", (__int64)v5);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000000D5245) ----------------------------------------------------
signed __int64 __fastcall sub_D5245(__int64 a1, __int64 a2, int a3, char a4)
{
  const char *v5; // rax
  char v6; // [rsp+8h] [rbp-38h]
  int v7; // [rsp+28h] [rbp-18h]
  unsigned int i; // [rsp+2Ch] [rbp-14h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v6 = a4;
  v10 = __readfsqword(0x28u);
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 != 2 )
  {
    v5 = sub_C494A((_DWORD *)a1);
    sub_13937(**(void ***)(a2 + 48), 69, 0, 0LL, (__int64)"path operator", (__int64)v5);
    return 0xFFFFFFFFLL;
  }
  if ( !a3 )
    return 0LL;
  sub_D2BEA(a2, a4, &v7);
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 1
      && *(_DWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16)) + 56LL) & 0x11 )
    {
      v9 = 0LL;
      while ( 1 )
      {
        while ( 1 )
        {
          v9 = lys_getnext(v9, *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16)), 0LL, 256LL);
          if ( !v9 )
            goto LABEL_20;
          if ( !(v6 & 0x20) )
            break;
          if ( *(_DWORD *)(lys_parent(v9) + 56) != 512 )
            goto LABEL_16;
        }
        if ( *(_DWORD *)(lys_parent(v9) + 56) != 1024 )
        {
LABEL_16:
          if ( v7 != 1 || !(*(_WORD *)(v9 + 24) & 2) )
            sub_C765D(a1, v9, 2);
        }
      }
    }
LABEL_20:
    ;
  }
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000D5430) ----------------------------------------------------
signed __int64 __fastcall sub_D5430(__int64 a1, __int64 a2, int a3, int a4)
{
  const char *v5; // rax
  int v6; // [rsp+8h] [rbp-58h]
  int v7; // [rsp+28h] [rbp-38h]
  unsigned int v8; // [rsp+2Ch] [rbp-34h]
  int v9; // [rsp+30h] [rbp-30h]
  unsigned int v10; // [rsp+34h] [rbp-2Ch]
  _QWORD *v11; // [rsp+38h] [rbp-28h]
  _QWORD *v12; // [rsp+40h] [rbp-20h]
  void *v13; // [rsp+48h] [rbp-18h]
  _QWORD *v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v6 = a4;
  v15 = __readfsqword(0x28u);
  v13 = **(void ***)(*(_QWORD *)a2 + 48LL);
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 != 1 )
  {
    v5 = sub_C494A((_DWORD *)a1);
    sub_13937(v13, 69, 0, 0LL, (__int64)"path operator", (__int64)v5);
    return 0xFFFFFFFFLL;
  }
  if ( a3 )
  {
    v10 = sub_D4FB0((_QWORD *)a1, a2, 1, a4);
    if ( v10 )
      return v10;
  }
  v14 = (_QWORD *)sub_D2AFF(a2, v6, &v7);
  v8 = 0;
  while ( v8 < *(_DWORD *)(a1 + 32) )
  {
    v11 = *(_QWORD **)(16LL * v8 + *(_QWORD *)(a1 + 16));
    switch ( *(_DWORD *)(16LL * v8 + *(_QWORD *)(a1 + 16) + 8) )
    {
      case 2:
        v12 = (_QWORD *)v11[5];
        goto LABEL_18;
      case 3:
        v12 = v11;
        goto LABEL_18;
      case 4:
        v12 = sub_BB881(v14, *(_QWORD *)(16LL * v8 + *(_QWORD *)(a1 + 16)));
        if ( !v12 )
        {
          sub_12222(
            (__int64)v13,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
            6553LL);
          return 0xFFFFFFFFLL;
        }
LABEL_18:
        if ( v6 & 2 && v12 && (*((_BYTE *)v12 + 9) >> 1) & 4 && !((*((_BYTE *)v12 + 9) >> 1) & 3) )
          return 1LL;
        if ( v14 == v11 )
        {
          v9 = v6 && *(_WORD *)(*(_QWORD *)a2 + 24LL) & 1;
          v12 = v11;
        }
        else if ( v12 )
        {
          v9 = 2;
        }
        else
        {
          v9 = v6 && *(_WORD *)(*(_QWORD *)a2 + 24LL) & 1;
          while ( *(_QWORD *)(v11[4] + 24LL) )
            v11 = (_QWORD *)v11[4];
          if ( v11 != v14 )
            sub_12222(
              (__int64)v13,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
              6586LL);
          v12 = v14;
        }
        if ( v9 != 2 && (v9 != v7 || v12 != v14) )
          __assert_fail(
            "(new_type == LYXP_NODE_ELEM) || ((new_type == root_type) && (new_node == root))",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0x19C4u,
            "moveto_parent");
        if ( (unsigned int)sub_C705F(a1, (__int64)v12, v9, -1) )
          sub_C6DA0((_DWORD *)a1, v8);
        else
          sub_C77EE(a1, (__int64)v12, 0, v9, v8++);
        break;
      default:
        sub_C6DA0((_DWORD *)a1, v8);
        break;
    }
  }
  if ( (unsigned int)sub_C8295(a1, a2, v6) || (unsigned int)sub_C863F(a1) )
    __assert_fail(
      "!set_sort(set, cur_node, options) && !set_sorted_dup_node_clean(set)",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x19CEu,
      "moveto_parent");
  return 0LL;
}

//----- (00000000000D5851) ----------------------------------------------------
signed __int64 __fastcall sub_D5851(__int64 a1, __int64 a2, int a3, char a4)
{
  signed __int64 result; // rax
  const char *v5; // rax
  __int64 v6; // rax
  char v7; // [rsp+8h] [rbp-58h]
  int v8; // [rsp+28h] [rbp-38h]
  int i; // [rsp+2Ch] [rbp-34h]
  int v10; // [rsp+30h] [rbp-30h]
  int v11; // [rsp+34h] [rbp-2Ch]
  int v12; // [rsp+38h] [rbp-28h]
  int v13; // [rsp+3Ch] [rbp-24h]
  __int64 j; // [rsp+40h] [rbp-20h]
  __int64 v15; // [rsp+48h] [rbp-18h]
  __int64 v16; // [rsp+50h] [rbp-10h]
  unsigned __int64 v17; // [rsp+58h] [rbp-8h]

  v7 = a4;
  v17 = __readfsqword(0x28u);
  v10 = 0;
  if ( !a1 || !*(_DWORD *)a1 )
    return 0LL;
  if ( *(_DWORD *)a1 == 2 )
  {
    if ( a3 && (v12 = sub_D5245(a1, a2, 1, a4)) != 0 )
    {
      result = (unsigned int)v12;
    }
    else
    {
      v15 = sub_D2BEA(a2, v7, &v8);
      v13 = *(_DWORD *)(a1 + 32);
      for ( i = 0; i < v13; ++i )
      {
        if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 1 )
        {
          *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) = 0;
          v16 = *(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 16));
          if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 8) == 2 )
          {
            for ( j = lys_parent(v16); j && *(_DWORD *)(j + 56) & 0x1642; j = lys_parent(j) )
              ;
            if ( v15 == v16 )
            {
              v11 = v7 & 0x18 && *(_WORD *)(a2 + 24) & 1;
              j = v16;
            }
            else if ( j )
            {
              v11 = 2;
            }
            else
            {
              v11 = v7 & 0x18 && *(_WORD *)(a2 + 24) & 1;
              v6 = lys_node_module(v16);
              v16 = lys_getnext(0LL, 0LL, v6, 256LL);
              if ( v16 != v15 )
                sub_12222(
                  **(_QWORD **)(a2 + 48),
                  0,
                  4,
                  "Internal error (%s:%d).",
                  (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
                  6675LL);
              j = v15;
            }
            if ( v11 != 2 && (v11 != v8 || j != v15) )
              __assert_fail(
                "(new_type == LYXP_NODE_ELEM) || ((new_type == root_type) && (new_node == root))",
                "/home/mantovan/Repositories/libyang/src/xpath.c",
                0x1A1Du,
                "moveto_snode_parent");
            v12 = sub_C765D(a1, j, v11);
            if ( v12 < v13 && v12 > i )
            {
              *(_DWORD *)(16LL * v12 + *(_QWORD *)(a1 + 16) + 12) = 2;
              v10 = 1;
            }
          }
        }
      }
      if ( v10 )
      {
        for ( i = 0; i < v13; ++i )
        {
          if ( *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) == 2 )
            *(_DWORD *)(16LL * i + *(_QWORD *)(a1 + 16) + 12) = 1;
        }
      }
      result = 0LL;
    }
  }
  else
  {
    v5 = sub_C494A((_DWORD *)a1);
    sub_13937(**(void ***)(a2 + 48), 69, 0, 0LL, (__int64)"path operator", (__int64)v5);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000D5BFA) ----------------------------------------------------
signed __int64 __fastcall sub_D5BFA(long double *a1, long double *a2, _BYTE *a3, __int64 a4, __int64 *a5, int a6)
{
  signed __int64 result; // rax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  unsigned int v12; // [rsp+4h] [rbp-CCh]
  __int64 *v13; // [rsp+8h] [rbp-C8h]
  __int64 v14; // [rsp+10h] [rbp-C0h]
  _BYTE *v15; // [rsp+18h] [rbp-B8h]
  int v16; // [rsp+34h] [rbp-9Ch]
  signed __int64 i; // [rsp+38h] [rbp-98h]
  signed __int64 j; // [rsp+38h] [rbp-98h]
  int v19; // [rsp+40h] [rbp-90h]
  int v20; // [rsp+50h] [rbp-80h]
  char v21; // [rsp+80h] [rbp-50h]
  unsigned __int64 v22; // [rsp+C8h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v22 = __readfsqword(0x28u);
  v19 = 0;
  if ( !*(_DWORD *)a1 || !*(_DWORD *)a2 )
  {
    sub_C6A0D(a1, 0);
    return 0LL;
  }
  if ( *(_DWORD *)a1 != 1 && *(_DWORD *)a2 != 1 )
  {
    if ( *a3 != 61 && *a3 != 33 )
    {
      if ( (unsigned int)sub_DC765((__int64)a1, 4, a4, a5, a6) )
        return 0xFFFFFFFFLL;
      if ( (unsigned int)sub_DC765((__int64)a2, 4, v14, v13, v12) )
        return 0xFFFFFFFFLL;
    }
    else if ( *(_DWORD *)a1 != 3 && *(_DWORD *)a2 != 3 )
    {
      if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a2 == 4 )
      {
        if ( (unsigned int)sub_DC765((__int64)a1, 4, a4, a5, a6) )
          return 0xFFFFFFFFLL;
        if ( (unsigned int)sub_DC765((__int64)a2, 4, v14, v13, v12) )
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      sub_DC765((__int64)a1, 3, a4, a5, a6);
      sub_DC765((__int64)a2, 3, v14, v13, v12);
    }
    if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
      __assert_fail(
        "set1->type == set2->type",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1AD6u,
        "moveto_op_comp");
    if ( *v15 == 61 )
    {
      if ( *(_DWORD *)a1 == 3 )
      {
        v16 = *((_DWORD *)a1 + 4) == *((_DWORD *)a2 + 4);
      }
      else if ( *(_DWORD *)a1 == 4 )
      {
        v10 = 1;
        if ( a2[1] != a1[1] )
          v10 = 0;
        v16 = v10;
      }
      else
      {
        if ( *(_DWORD *)a1 != 5 )
          __assert_fail(
            "set1->type == LYXP_SET_STRING",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0x1ADFu,
            "moveto_op_comp");
        v16 = sub_C462(*((_BYTE **)a1 + 2), *((_BYTE **)a2 + 2));
      }
    }
    else if ( *v15 == 33 )
    {
      if ( *(_DWORD *)a1 == 3 )
      {
        v16 = *((_DWORD *)a1 + 4) != *((_DWORD *)a2 + 4);
      }
      else if ( *(_DWORD *)a1 == 4 )
      {
        v11 = 0;
        if ( a2[1] != a1[1] )
          v11 = 1;
        v16 = v11;
      }
      else
      {
        if ( *(_DWORD *)a1 != 5 )
          __assert_fail(
            "set1->type == LYXP_SET_STRING",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0x1AE8u,
            "moveto_op_comp");
        v16 = (unsigned __int64)sub_C462(*((_BYTE **)a1 + 2), *((_BYTE **)a2 + 2)) == 0;
      }
    }
    else
    {
      if ( *(_DWORD *)a1 != 4 )
        __assert_fail(
          "set1->type == LYXP_SET_NUMBER",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1AECu,
          "moveto_op_comp");
      if ( *v15 == 60 )
      {
        if ( v15[1] == 61 )
          v16 = a2[1] >= a1[1];
        else
          v16 = a2[1] > a1[1];
      }
      else if ( v15[1] == 61 )
      {
        v16 = a1[1] >= a2[1];
      }
      else
      {
        v16 = a1[1] > a2[1];
      }
    }
    if ( v16 )
      sub_C6A0D(a1, 1);
    else
      sub_C6A0D(a1, 0);
    result = 0LL;
  }
  else
  {
    if ( *(_DWORD *)a1 == 1 )
    {
      if ( *(_DWORD *)a2 != 1 && (unsigned int)sub_C8BDA((int *)a2, (__int64)a1) )
        return 0xFFFFFFFFLL;
      for ( i = 0LL; i < *((unsigned int *)a1 + 8); ++i )
      {
        if ( *(_DWORD *)a2 == 3 )
        {
          if ( (unsigned int)sub_C81AC(&v19, (__int64)a1, 3, v14, v13, i, v12) )
            return 0xFFFFFFFFLL;
        }
        else if ( *(_DWORD *)a2 == 4 )
        {
          if ( (unsigned int)sub_C81AC(&v19, (__int64)a1, 4, v14, v13, i, v12) )
            return 0xFFFFFFFFLL;
        }
        else if ( (unsigned int)sub_C81AC(&v19, (__int64)a1, 5, v14, v13, i, v12) )
        {
          return 0xFFFFFFFFLL;
        }
        if ( (unsigned int)sub_D5BFA(&v19, a2, v15, v14, v13, v12) )
        {
          sub_C65F5((__int64)&v19);
          return 0xFFFFFFFFLL;
        }
        if ( v20 )
        {
          sub_C6A0D(a1, 1);
          return 0LL;
        }
      }
    }
    else
    {
      if ( (unsigned int)sub_C8BDA((int *)a1, (__int64)a2) )
        return 0xFFFFFFFFLL;
      for ( j = 0LL; j < *((unsigned int *)a2 + 8); ++j )
      {
        if ( *(_DWORD *)a1 == 3 )
        {
          if ( (unsigned int)sub_C81AC(&v21, (__int64)a2, 3, v14, v13, j, v12) )
            return 0xFFFFFFFFLL;
        }
        else if ( *(_DWORD *)a1 == 4 )
        {
          if ( (unsigned int)sub_C81AC(&v21, (__int64)a2, 4, v14, v13, j, v12) )
            return 0xFFFFFFFFLL;
        }
        else if ( (unsigned int)sub_C81AC(&v21, (__int64)a2, 5, v14, v13, j, v12) )
        {
          return 0xFFFFFFFFLL;
        }
        sub_C6A3F((__int64)&v19, (__int64)a1, (__int64)a1, v7, v8, v9);
        if ( (unsigned int)sub_D5BFA(&v19, &v21, v15, v14, v13, v12) )
        {
          sub_C65F5((__int64)&v19);
          sub_C65F5((__int64)&v21);
          return 0xFFFFFFFFLL;
        }
        sub_C65F5((__int64)&v21);
        if ( v20 )
        {
          sub_C6A0D(a1, 1);
          return 0LL;
        }
      }
    }
    sub_C6A0D(a1, 0);
    result = 0LL;
  }
  return result;
}

//----- (00000000000D65EB) ----------------------------------------------------
signed __int64 __fastcall sub_D65EB(__int64 a1, long double *a2, _BYTE *a3, __int64 a4, __int64 *a5, int a6)
{
  signed int v7; // eax
  __int64 v8; // rax
  int v9; // [rsp+14h] [rbp-2Ch]
  __int64 *v10; // [rsp+18h] [rbp-28h]
  __int64 v11; // [rsp+20h] [rbp-20h]
  char *v12; // [rsp+28h] [rbp-18h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( !a2 && *a3 == 45 )
  {
    if ( (unsigned int)sub_DC765(a1, 4, a4, a5, a6) )
      return 0xFFFFFFFFLL;
    *(long double *)(a1 + 16) = -*(long double *)(a1 + 16);
    sub_C6688(a2);
    return 0LL;
  }
  if ( !a1 || !a2 )
    __assert_fail("set1 && set2", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x1B1Fu, "moveto_op_math");
  if ( (unsigned int)sub_DC765(a1, 4, a4, a5, a6) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_DC765((__int64)a2, 4, v11, v10, v9) )
    return 0xFFFFFFFFLL;
  v7 = *v12;
  if ( v7 == 45 )
  {
    *(long double *)(a1 + 16) = *(long double *)(a1 + 16) - a2[1];
    return 0LL;
  }
  if ( v7 > 45 )
  {
    if ( v7 == 100 )
    {
      *(long double *)(a1 + 16) = *(long double *)(a1 + 16) / a2[1];
    }
    else
    {
      if ( v7 != 109 )
        goto LABEL_26;
      *(long double *)(a1 + 16) = (long double)((signed __int64)*(long double *)(a1 + 16) % (signed __int64)a2[1]);
    }
    return 0LL;
  }
  if ( v7 == 42 )
  {
    *(long double *)(a1 + 16) = *(long double *)(a1 + 16) * a2[1];
    return 0LL;
  }
  if ( v7 == 43 )
  {
    *(long double *)(a1 + 16) = *(long double *)(a1 + 16) + a2[1];
    return 0LL;
  }
LABEL_26:
  if ( v10 )
    v8 = *v10;
  else
    v8 = 0LL;
  sub_12222(v8, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c", 6979LL);
  return 0xFFFFFFFFLL;
}

//----- (00000000000D6835) ----------------------------------------------------
_WORD *__fastcall sub_D6835(_QWORD *a1, _WORD *a2, __int64 a3)
{
  unsigned int v3; // ebx
  const char *v4; // rdx
  const char *v5; // rax
  _WORD *result; // rax
  __int64 v7; // [rsp+8h] [rbp-28h]

  v7 = a3;
  if ( a3 )
  {
    if ( *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2) == 2 )
      sub_C6974(a3, byte_124F70, 0);
    else
      sub_C6974(
        a3,
        (char *)(*(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2) + 1LL + a1[5]),
        *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2) - 2);
  }
  v3 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
  v4 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
  if ( v7 )
    v5 = "parsed";
  else
    v5 = "skipped";
  sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_literal", (__int64)v5, (__int64)v4, v3);
  result = a2;
  ++*a2;
  return result;
}

//----- (00000000000D6985) ----------------------------------------------------
signed __int64 __fastcall sub_D6985(_QWORD *a1, _WORD *a2, _QWORD **a3, __int64 *a4, int a5, int a6, __int64 a7, unsigned int a8)
{
  int v8; // eax
  void *ptr; // ST58_8
  unsigned int v11; // ebx
  const char *v12; // rdx
  const char *v13; // rax
  unsigned int v14; // ebx
  const char *v15; // rdx
  const char *v16; // rax
  unsigned int v17; // ebx
  const char *v18; // rdx
  const char *v19; // rax
  unsigned int v20; // ebx
  const char *v21; // rdx
  const char *v22; // rax
  __int64 v23; // rax
  __int64 *v24; // [rsp+10h] [rbp-40h]
  __int64 v25; // [rsp+18h] [rbp-38h]
  int i; // [rsp+30h] [rbp-20h]
  unsigned int v27; // [rsp+34h] [rbp-1Ch]

  v25 = (__int64)a3;
  v24 = a4;
  v27 = 0;
  v8 = *(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2);
  if ( v8 == 9 )
  {
    if ( a5 )
    {
      if ( a7 && a8 & 0x3C )
      {
        sub_C6D49(a7);
      }
      else if ( a6 )
      {
        v27 = sub_D4935(
                a7,
                a3,
                (char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2),
                a8);
      }
      else
      {
        v27 = sub_D4437(
                a7,
                (__int64)a3,
                (char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2),
                a8);
      }
    }
    else
    {
      if ( a6 )
      {
        if ( a7 && a8 & 0x3C )
          v27 = sub_D3F81(
                  a7,
                  (__int64)a3,
                  (char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                  *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2),
                  a8);
        else
          v27 = sub_D3A01(
                  a7,
                  (__int64)a3,
                  (char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                  *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2),
                  a8);
      }
      else if ( a7 && a8 & 0x3C )
      {
        v27 = sub_D345B(
                a7,
                (__int64)a3,
                (char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2),
                a8);
      }
      else
      {
        v27 = sub_D2FD6(
                a7,
                (__int64)a3,
                (char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2),
                a8);
      }
      if ( !v27 && a7 && a8 & 0x3C )
      {
        for ( i = *(_DWORD *)(a7 + 32) - 1; i >= 0 && !*(_DWORD *)(16LL * i + *(_QWORD *)(a7 + 16) + 12); --i )
          ;
        if ( i == -1 )
        {
          ptr = (void *)lys_path(v25, 1LL);
          sub_12222(
            *v24,
            1u,
            0,
            "Schema node \"%.*s\" not found (%.*s) with context node \"%s\".",
            *(unsigned __int16 *)(a1[2] + 2LL * (unsigned __int16)*a2),
            a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2),
            *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)
          + (unsigned int)*(unsigned __int16 *)(a1[2] + 2LL * (unsigned __int16)*a2),
            a1[5],
            ptr);
          free(ptr);
        }
      }
    }
    if ( v27 )
      return v27;
    v11 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
    v12 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
    if ( a7 )
      v13 = "parsed";
    else
      v13 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_node_test", (__int64)v13, (__int64)v12, v11);
    ++*a2;
    return 0LL;
  }
  if ( v8 == 10 )
  {
    if ( a7 )
    {
      if ( *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2) != 4 )
        __assert_fail(
          "exp->tok_len[*exp_idx] == 4",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1BB9u,
          "eval_node_test");
      if ( *(_DWORD *)a7 == 2 )
      {
        sub_C6D49(a7);
        a7 = 0LL;
      }
      else if ( !strncmp(
                   (const char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)),
                   "node",
                   4uLL) )
      {
        if ( (unsigned int)sub_CFC0C(0LL, 0LL, v25, v24, (_DWORD *)a7, a8) )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( strncmp((const char *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2)), "text", 4uLL) )
          __assert_fail(
            "!strncmp(&exp->expr[exp->expr_pos[*exp_idx]], \"text\", 4)",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0x1BC4u,
            "eval_node_test");
        if ( (unsigned int)sub_D1FBB(0LL, 0LL, v25, (void **)v24, (_DWORD *)a7, a8) )
          return 0xFFFFFFFFLL;
      }
    }
    v14 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
    v15 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
    if ( a7 )
      v16 = "parsed";
    else
      v16 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_node_test", (__int64)v16, (__int64)v15, v14);
    if ( *(_DWORD *)(*a1 + 4LL * (unsigned __int16)++*a2) != 1 )
      __assert_fail(
        "exp->tokens[*exp_idx] == LYXP_TOKEN_PAR1",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1BD0u,
        "eval_node_test");
    v17 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
    v18 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
    if ( a7 )
      v19 = "parsed";
    else
      v19 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_node_test", (__int64)v19, (__int64)v18, v17);
    if ( *(_DWORD *)(*a1 + 4LL * (unsigned __int16)++*a2) != 2 )
      __assert_fail(
        "exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1BD6u,
        "eval_node_test");
    v20 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
    v21 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
    if ( a7 )
      v22 = "parsed";
    else
      v22 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_node_test", (__int64)v22, (__int64)v21, v20);
    ++*a2;
    return 0LL;
  }
  if ( a4 )
    v23 = *a4;
  else
    v23 = 0LL;
  sub_12222(v23, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c", 7133LL);
  return 0xFFFFFFFFLL;
}
// 7680: using guessed type __int64 __fastcall lys_path(_QWORD, _QWORD);

//----- (00000000000D729A) ----------------------------------------------------
__int64 __fastcall sub_D729A(_QWORD *a1, __int16 *a2, __int64 a3, __int64 *a4, __int64 a5, int a6, int a7)
{
  unsigned int v7; // ebx
  const char *v8; // rdx
  const char *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int v14; // ebx
  const char *v15; // rdx
  const char *v16; // rax
  int v17; // [rsp+14h] [rbp-ACh]
  __int64 v18; // [rsp+18h] [rbp-A8h]
  __int64 *v19; // [rsp+20h] [rbp-A0h]
  _QWORD **v20; // [rsp+28h] [rbp-98h]
  unsigned __int16 i; // [rsp+44h] [rbp-7Ch]
  unsigned __int16 j; // [rsp+44h] [rbp-7Ch]
  unsigned __int16 k; // [rsp+44h] [rbp-7Ch]
  unsigned __int16 l; // [rsp+44h] [rbp-7Ch]
  __int16 v25; // [rsp+46h] [rbp-7Ah]
  __int16 v26; // [rsp+46h] [rbp-7Ah]
  signed int v27; // [rsp+48h] [rbp-78h]
  unsigned int v28; // [rsp+4Ch] [rbp-74h]
  unsigned int v29; // [rsp+4Ch] [rbp-74h]
  unsigned int v30; // [rsp+4Ch] [rbp-74h]
  unsigned int v31; // [rsp+4Ch] [rbp-74h]
  int v32; // [rsp+50h] [rbp-70h]
  unsigned int v33; // [rsp+54h] [rbp-6Ch]
  __int64 v34; // [rsp+58h] [rbp-68h]
  int s; // [rsp+60h] [rbp-60h]
  long double v36; // [rsp+70h] [rbp-50h]
  unsigned __int64 v37; // [rsp+90h] [rbp-30h]
  unsigned __int64 v38; // [rsp+A8h] [rbp-18h]

  v20 = (_QWORD **)a3;
  v19 = a4;
  v18 = a5;
  v17 = a6;
  v38 = __readfsqword(0x28u);
  v7 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
  v8 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
  if ( v18 )
    v9 = "parsed";
  else
    v9 = "skipped";
  sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_predicate", (__int64)v9, (__int64)v8, v7);
  ++*a2;
  if ( !v18 )
    goto LABEL_5;
  if ( *(_DWORD *)v18 == 1 )
  {
    if ( (unsigned int)sub_C8295(v18, (__int64)v20, v17) )
      __assert_fail(
        "!set_sort(set, cur_node, options)",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1C08u,
        "eval_predicate");
    if ( *(_DWORD *)(v18 + 32) )
    {
      v25 = *a2;
      v27 = 0;
      v33 = *(_DWORD *)(v18 + 32);
      v34 = 0LL;
      for ( i = 0; (unsigned int)i < *(_DWORD *)(v18 + 32); ++i )
      {
        memset(&s, 0, 0x40uLL);
        sub_C7395(
          (__int64)&s,
          *(_QWORD *)(16LL * i + *(_QWORD *)(v18 + 16)),
          *(_DWORD *)(16LL * i + *(_QWORD *)(v18 + 16) + 12),
          *(_DWORD *)(16LL * i + *(_QWORD *)(v18 + 16) + 8),
          0);
        if ( a7 && v34 != *(_QWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(v18 + 16)) + 40LL) )
        {
          v34 = *(_QWORD *)(*(_QWORD *)(16LL * i + *(_QWORD *)(v18 + 16)) + 40LL);
          v27 = 1;
        }
        else
        {
          ++v27;
        }
        v37 = __PAIR__(v33, v27);
        *a2 = v25;
        v29 = sub_DC160(a1, a2, 0, v20, v19, (unsigned int *)&s, v17);
        if ( v29 == -1 || v29 == 1 )
        {
          sub_DC765((__int64)&s, 0, (__int64)v20, v19, v17);
          return v29;
        }
        if ( s == 4 )
        {
          if ( (signed __int64)v36 == v27 )
            v36 = 1.0;
          else
            v36 = 0.0;
        }
        sub_DC765((__int64)&s, 3, (__int64)v20, v19, v17);
        if ( !LODWORD(v36) )
        {
          sub_C639B(
            v18,
            *(_QWORD *)(16LL * i + *(_QWORD *)(v18 + 16)),
            *(_DWORD *)(16LL * i + *(_QWORD *)(v18 + 16) + 8));
          *(_DWORD *)(16LL * i + *(_QWORD *)(v18 + 16) + 8) = 5;
        }
      }
      sub_C6ECE((unsigned int *)v18);
      goto LABEL_57;
    }
LABEL_5:
    v28 = sub_DC160(a1, a2, 0, v20, v19, 0LL, v17);
    if ( v28 == -1 || v28 == 1 )
      return v28;
    goto LABEL_57;
  }
  if ( *(_DWORD *)v18 == 2 )
  {
    for ( j = 0; (unsigned int)j < *(_DWORD *)(v18 + 32) && *(_DWORD *)(16LL * j + *(_QWORD *)(v18 + 16) + 12) != 1; ++j )
      ;
    if ( j != *(_DWORD *)(v18 + 32) )
    {
      v26 = *a2;
      v32 = sub_C78F8(v18);
      for ( k = 0; (unsigned int)k < *(_DWORD *)(v18 + 32); ++k )
      {
        if ( v32 == *(_DWORD *)(16LL * k + *(_QWORD *)(v18 + 16) + 12) )
        {
          *(_DWORD *)(16LL * k + *(_QWORD *)(v18 + 16) + 12) = 1;
          *a2 = v26;
          v30 = sub_DC160(a1, a2, 0, v20, v19, (unsigned int *)v18, v17);
          if ( v30 == -1 || v30 == 1 )
            return v30;
          *(_DWORD *)(*(_QWORD *)(v18 + 16) + 16LL * k + 12) = v32;
        }
      }
      for ( l = 0; (unsigned int)l < *(_DWORD *)(v18 + 32); ++l )
      {
        if ( *(_DWORD *)(16LL * l + *(_QWORD *)(v18 + 16) + 12) == 1 )
        {
          *(_DWORD *)(16LL * l + *(_QWORD *)(v18 + 16) + 12) = 0;
        }
        else if ( v32 == *(_DWORD *)(16LL * l + *(_QWORD *)(v18 + 16) + 12) )
        {
          *(_DWORD *)(16LL * l + *(_QWORD *)(v18 + 16) + 12) = 1;
        }
      }
      goto LABEL_57;
    }
    goto LABEL_5;
  }
  s = 0;
  sub_C6A3F((__int64)&s, v18, v18, v10, v11, v12);
  v31 = sub_DC160(a1, a2, 0, v20, v19, (unsigned int *)&s, v17);
  if ( v31 == -1 || v31 == 1 )
  {
    sub_DC765((__int64)&s, 0, (__int64)v20, v19, v17);
    return v31;
  }
  sub_DC765((__int64)&s, 3, (__int64)v20, v19, v17);
  if ( !LODWORD(v36) )
    sub_DC765(v18, 0, (__int64)v20, v19, v17);
  sub_DC765((__int64)&s, 0, (__int64)v20, v19, v17);
LABEL_57:
  if ( *(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2) != 4 )
    __assert_fail(
      "exp->tokens[*exp_idx] == LYXP_TOKEN_BRACK2",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x1C7Du,
      "eval_predicate");
  v14 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
  v15 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
  if ( v18 )
    v16 = "parsed";
  else
    v16 = "skipped";
  sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_predicate", (__int64)v16, (__int64)v15, v14);
  ++*a2;
  return 0LL;
}

//----- (00000000000D7B49) ----------------------------------------------------
signed __int64 __fastcall sub_D7B49(__int64 a1, __int16 *a2, _QWORD **a3, __int64 *a4, int a5, _QWORD *a6, unsigned int a7)
{
  unsigned int v7; // ebx
  const char *v8; // rdx
  const char *v9; // rax
  unsigned int v11; // ebx
  const char *v12; // rdx
  const char *v13; // rax
  unsigned int v14; // ebx
  const char *v15; // rdx
  const char *v16; // rax
  unsigned int v17; // ebx
  const char *v18; // rdx
  const char *v19; // rax
  __int64 v20; // rax
  _QWORD *v21; // [rsp+0h] [rbp-50h]
  int v22; // [rsp+Ch] [rbp-44h]
  __int64 *v23; // [rsp+10h] [rbp-40h]
  _QWORD **v24; // [rsp+18h] [rbp-38h]
  int v25; // [rsp+38h] [rbp-18h]
  unsigned int v26; // [rsp+3Ch] [rbp-14h]
  unsigned int v27; // [rsp+3Ch] [rbp-14h]
  unsigned int v28; // [rsp+3Ch] [rbp-14h]
  unsigned int v29; // [rsp+3Ch] [rbp-14h]

  v24 = a3;
  v23 = a4;
  v22 = a5;
  v21 = a6;
  while ( 1 )
  {
    v25 = 0;
    switch ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) )
    {
      case 5:
        if ( v21 && a7 & 0x3C )
          v26 = sub_D5245((__int64)v21, (__int64)v24, v22, a7);
        else
          v26 = sub_D4FB0(v21, (__int64)v24, v22, a7);
        if ( !v26 )
        {
          v11 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
          v12 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
          if ( v21 )
            v13 = "parsed";
          else
            v13 = "skipped";
          sub_12312(
            8u,
            (__int64)"%-27s %s %s[%u]",
            (__int64)"eval_relative_location_path",
            (__int64)v13,
            (__int64)v12,
            v11,
            v21);
          ++*a2;
          goto LABEL_47;
        }
        return v26;
      case 6:
        if ( v21 && a7 & 0x3C )
          v27 = sub_D5851((__int64)v21, (__int64)v24, v22, a7);
        else
          v27 = sub_D5430((__int64)v21, (__int64)v24, v22, a7);
        if ( !v27 )
        {
          v14 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
          v15 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
          if ( v21 )
            v16 = "parsed";
          else
            v16 = "skipped";
          sub_12312(
            8u,
            (__int64)"%-27s %s %s[%u]",
            (__int64)"eval_relative_location_path",
            (__int64)v16,
            (__int64)v15,
            v14,
            v21);
          ++*a2;
          goto LABEL_47;
        }
        return v27;
      case 7:
        v25 = 1;
        v17 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
        v18 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
        if ( v21 )
          v19 = "parsed";
        else
          v19 = "skipped";
        sub_12312(
          8u,
          (__int64)"%-27s %s %s[%u]",
          (__int64)"eval_relative_location_path",
          (__int64)v19,
          (__int64)v18,
          v17,
          v21);
        ++*a2;
        goto LABEL_36;
      case 9:
      case 0xA:
LABEL_36:
        v28 = sub_D6985((_QWORD *)a1, a2, v24, v23, v25, v22, (__int64)v21, a7);
        if ( v28 )
          return v28;
        break;
      default:
        if ( v23 )
          v20 = *v23;
        else
          v20 = 0LL;
        sub_12222(
          v20,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          7393LL,
          v21);
        return 0xFFFFFFFFLL;
    }
    while ( *(_WORD *)(a1 + 32) > (unsigned __int16)*a2 && *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) == 3 )
    {
      v29 = sub_D729A((_QWORD *)a1, a2, (__int64)v24, v23, (__int64)v21, a7, 1);
      if ( v29 )
        return v29;
    }
LABEL_47:
    if ( *(_WORD *)(a1 + 32) <= (unsigned __int16)*a2 )
      return 0LL;
    if ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) != 16 )
      return 0LL;
    if ( *(_WORD *)(*(_QWORD *)(a1 + 16) + 2LL * (unsigned __int16)*a2) == 1 )
    {
      v22 = 0;
    }
    else
    {
      if ( *(_WORD *)(*(_QWORD *)(a1 + 16) + 2LL * (unsigned __int16)*a2) != 2 )
        __assert_fail(
          "exp->tok_len[*exp_idx] == 2",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1CA0u,
          "eval_relative_location_path");
      v22 = 1;
    }
    v7 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
    v8 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
    if ( v21 )
      v9 = "parsed";
    else
      v9 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_relative_location_path", (__int64)v9, (__int64)v8, v7, v21);
    ++*a2;
  }
}

//----- (00000000000D8060) ----------------------------------------------------
__int64 __fastcall sub_D8060(_QWORD *a1, __int16 *a2, __int64 a3, void **a4, __int64 a5, int a6)
{
  unsigned int v6; // ebx
  const char *v7; // rdx
  const char *v8; // rax
  __int64 v9; // r9
  unsigned int v11; // eax
  unsigned int v12; // ebx
  const char *v13; // rdx
  const char *v14; // rax
  unsigned int v15; // [rsp+4h] [rbp-4Ch]
  _QWORD *v16; // [rsp+8h] [rbp-48h]
  void **v17; // [rsp+10h] [rbp-40h]
  _QWORD **v18; // [rsp+18h] [rbp-38h]
  unsigned int v19; // [rsp+3Ch] [rbp-14h]
  unsigned int v20; // [rsp+3Ch] [rbp-14h]

  v18 = (_QWORD **)a3;
  v17 = a4;
  v16 = (_QWORD *)a5;
  v15 = a6;
  if ( a5 )
  {
    if ( a6 & 0x3C )
      sub_D2D37(a5, a3, a6);
    else
      sub_D2C95(a5, a3, a6);
  }
  if ( *(_WORD *)(a1[2] + 2LL * (unsigned __int16)*a2) == 1 )
  {
    v6 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
    v7 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
    if ( v16 )
      v8 = "parsed";
    else
      v8 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_absolute_location_path", (__int64)v8, (__int64)v7, v6);
    if ( (unsigned int)sub_C9129(*v17, (__int64)a1, ++*a2, 0, 0LL, v9) )
      return 0LL;
    v11 = *(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2);
    if ( v11 >= 5 && (v11 <= 7 || v11 - 9 <= 1) )
    {
      v19 = sub_D7B49((__int64)a1, a2, v18, (__int64 *)v17, 0, v16, v15);
      if ( v19 )
        return v19;
    }
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
    v13 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
    if ( v16 )
      v14 = "parsed";
    else
      v14 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_absolute_location_path", (__int64)v14, (__int64)v13, v12);
    ++*a2;
    v20 = sub_D7B49((__int64)a1, a2, v18, (__int64 *)v17, 1, v16, v15);
    if ( v20 )
      return v20;
  }
  return 0LL;
}

//----- (00000000000D8307) ----------------------------------------------------
signed __int64 __fastcall sub_D8307(__int64 a1, unsigned __int16 *a2, __int64 a3, __int64 *a4, const char **a5, unsigned int a6)
{
  signed __int64 result; // rax
  unsigned int v7; // ebx
  const char *v8; // rdx
  const char *v9; // rax
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // r9
  unsigned int v14; // ebx
  const char *v15; // rdx
  const char *v16; // rax
  __int64 v17; // r9
  unsigned int v18; // ebx
  const char *v19; // rdx
  const char *v20; // rax
  unsigned int v21; // [rsp+4h] [rbp-6Ch]
  const char **v22; // [rsp+8h] [rbp-68h]
  __int64 *v23; // [rsp+10h] [rbp-60h]
  _QWORD **v24; // [rsp+18h] [rbp-58h]
  unsigned __int16 v25; // [rsp+3Eh] [rbp-32h]
  unsigned __int16 i; // [rsp+40h] [rbp-30h]
  unsigned __int16 j; // [rsp+40h] [rbp-30h]
  unsigned __int16 v28; // [rsp+42h] [rbp-2Eh]
  unsigned int v29; // [rsp+44h] [rbp-2Ch]
  void *v30; // [rsp+48h] [rbp-28h]
  unsigned int **ptr; // [rsp+50h] [rbp-20h]
  unsigned int **v32; // [rsp+58h] [rbp-18h]

  v24 = (_QWORD **)a3;
  v23 = a4;
  v22 = a5;
  v21 = a6;
  v29 = 1;
  v30 = 0LL;
  v25 = 0;
  v28 = *a2;
  ptr = 0LL;
  if ( !a5 )
    goto LABEL_124;
  switch ( *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2LL * *a2) )
  {
    case 3u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "not",
              3uLL) )
      {
        v30 = sub_D010E;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "sum",
                   3uLL) )
      {
        v30 = sub_D1BD3;
      }
      break;
    case 4u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "lang",
              4uLL) )
      {
        v30 = sub_CF0E9;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "last",
                   4uLL) )
      {
        v30 = sub_CF4F3;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "name",
                   4uLL) )
      {
        v30 = sub_CF8C9;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "true",
                   4uLL) )
      {
        v30 = sub_D27D8;
      }
      break;
    case 5u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "count",
              5uLL) )
      {
        v30 = sub_CDD3F;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "false",
                   5uLL) )
      {
        v30 = sub_CEFE0;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "floor",
                   5uLL) )
      {
        v30 = sub_CF037;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "round",
                   5uLL) )
      {
        v30 = sub_D06AD;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "deref",
                   5uLL) )
      {
        v30 = sub_CDF8D;
      }
      break;
    case 6u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "concat",
              6uLL) )
      {
        v30 = sub_CD74E;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "number",
                   6uLL) )
      {
        v30 = sub_D01A8;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "string",
                   6uLL) )
      {
        v30 = sub_D0C1C;
      }
      break;
    case 7u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "boolean",
              7uLL) )
      {
        v30 = sub_CD490;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "ceiling",
                   7uLL) )
      {
        v30 = sub_CD50E;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "current",
                   7uLL) )
      {
        v30 = sub_CDEAF;
      }
      break;
    case 8u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "contains",
              8uLL) )
      {
        v30 = sub_CDA61;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "position",
                   8uLL) )
      {
        v30 = sub_D0264;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "re-match",
                   8uLL) )
      {
        v30 = sub_D034E;
      }
      break;
    case 9u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "substring",
              9uLL) )
      {
        v30 = sub_D0FED;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "translate",
                   9uLL) )
      {
        v30 = sub_D21EC;
      }
      break;
    case 0xAu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "local-name",
              0xAuLL) )
      {
        v30 = sub_CF5DD;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "enum-value",
                   0xAuLL) )
      {
        v30 = sub_CED6F;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "bit-is-set",
                   0xAuLL) )
      {
        v30 = sub_CD097;
      }
      break;
    case 0xBu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "starts-with",
              0xBuLL) )
        v30 = sub_D0925;
      break;
    case 0xCu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "derived-from",
              0xCuLL) )
        v30 = sub_CE3C6;
      break;
    case 0xDu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "namespace-uri",
              0xDuLL) )
      {
        v30 = sub_CF913;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "string-length",
                   0xDuLL) )
      {
        v30 = sub_D0CD8;
      }
      break;
    case 0xFu:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "normalize-space",
              0xFuLL) )
      {
        v30 = sub_CFC7C;
      }
      else if ( !strncmp(
                   (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
                   "substring-after",
                   0xFuLL) )
      {
        v30 = sub_D1588;
      }
      break;
    case 0x10u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "substring-before",
              0x10uLL) )
        v30 = sub_D18C4;
      break;
    case 0x14u:
      if ( !strncmp(
              (const char *)(*(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2)),
              "derived-from-or-self",
              0x14uLL) )
        v30 = sub_CE87B;
      break;
    default:
      break;
  }
  if ( v30 )
  {
LABEL_124:
    v7 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2);
    v8 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * *a2));
    if ( v22 )
      v9 = "parsed";
    else
      v9 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_function_call", (__int64)v9, (__int64)v8, v7);
    if ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * ++*a2) != 1 )
      __assert_fail(
        "exp->tokens[*exp_idx] == LYXP_TOKEN_PAR1",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1DC4u,
        "eval_function_call");
    v10 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2);
    v11 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * *a2));
    if ( v22 )
      v12 = "parsed";
    else
      v12 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_function_call", (__int64)v12, (__int64)v11, v10);
    if ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * ++*a2) == 2 )
    {
LABEL_102:
      while ( *(_WORD *)(a1 + 32) > *a2 && *(_DWORD *)(*(_QWORD *)a1 + 4LL * *a2) == 8 )
      {
        v14 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2);
        v15 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * *a2));
        if ( v22 )
          v16 = "parsed";
        else
          v16 = "skipped";
        sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_function_call", (__int64)v16, (__int64)v15, v14);
        ++*a2;
        if ( v22 )
        {
          v32 = (unsigned int **)realloc(ptr, 8LL * ++v25);
          if ( !v32 )
          {
            --v25;
            sub_12222(*v23, 0, 1, "Memory allocation failed (%s()).", (__int64)"eval_function_call", v17);
            goto LABEL_118;
          }
          ptr = v32;
          v32[v25 - 1] = (unsigned int *)sub_C66B8(v22);
          if ( !v32[v25 - 1] )
            goto LABEL_118;
          v29 = sub_DC160((_QWORD *)a1, (__int16 *)a2, 0, v24, v23, v32[v25 - 1], v21);
          if ( v29 == -1 || v29 == 1 )
            goto LABEL_118;
        }
        else
        {
          v29 = sub_DC160((_QWORD *)a1, (__int16 *)a2, 0, v24, v23, 0LL, v21);
          if ( v29 == -1 || v29 == 1 )
            goto LABEL_118;
        }
      }
      if ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * *a2) != 2 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1DFBu,
          "eval_function_call");
      v18 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2);
      v19 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * *a2));
      if ( v22 )
        v20 = "parsed";
      else
        v20 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_function_call", (__int64)v20, (__int64)v19, v18);
      ++*a2;
      if ( v22 )
      {
        v29 = ((__int64 (__fastcall *)(unsigned int **, _QWORD, _QWORD **, __int64 *, const char **, _QWORD))v30)(
                ptr,
                v25,
                v24,
                v23,
                v22,
                v21);
        if ( v21 & 0x3C )
        {
          if ( v29 == 1 )
          {
            sub_12222(
              *v23,
              1u,
              0,
              "Previous warning generated by XPath function \"%.*s\".",
              *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2 - 2)
            - (unsigned int)*(unsigned __int16 *)(2LL * v28 + *(_QWORD *)(a1 + 8))
            + 1,
              *(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(2LL * v28 + *(_QWORD *)(a1 + 8)));
            v29 = 0;
          }
          for ( i = 0; i < v25; ++i )
          {
            sub_C6D49((__int64)ptr[i]);
            sub_C7180((unsigned int *)v22, ptr[i]);
          }
        }
      }
      else
      {
        v29 = 0;
      }
    }
    else if ( v22 )
    {
      ptr = (unsigned int **)malloc(8uLL);
      if ( ptr )
      {
        v25 = 1;
        *ptr = (unsigned int *)sub_C66B8(v22);
        if ( *ptr )
        {
          v29 = sub_DC160((_QWORD *)a1, (__int16 *)a2, 0, v24, v23, *ptr, v21);
          if ( v29 != -1 && v29 != 1 )
            goto LABEL_102;
        }
      }
      else
      {
        sub_12222(*v23, 0, 1, "Memory allocation failed (%s()).", (__int64)"eval_function_call", v13);
      }
    }
    else
    {
      v29 = sub_DC160((_QWORD *)a1, (__int16 *)a2, 0, v24, v23, 0LL, v21);
      if ( v29 != -1 && v29 != 1 )
        goto LABEL_102;
    }
LABEL_118:
    for ( j = 0; j < v25; ++j )
      sub_C6688(ptr[j]);
    free(ptr);
    result = v29;
  }
  else
  {
    sub_13937(
      (void *)*v23,
      67,
      0,
      0LL,
      (__int64)"Unknown",
      *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2) + *(_QWORD *)(a1 + 40));
    sub_13937(
      (void *)*v23,
      -1,
      0,
      0LL,
      (__int64)"Unknown XPath function \"%.*s\".",
      *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2LL * *a2),
      *(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * *a2));
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000000D9687) ----------------------------------------------------
signed __int64 __fastcall sub_D9687(void *a1, _QWORD *a2, _WORD *a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  int *v6; // rax
  char *v7; // rax
  char *v9; // rsi
  char *v10; // rcx
  __int64 v11; // rdx
  unsigned int v12; // ebx
  const char *v13; // rdx
  const char *v14; // rax
  long double v15; // [rsp+0h] [rbp-70h]
  __int64 v16; // [rsp+10h] [rbp-60h]
  _WORD *v17; // [rsp+18h] [rbp-58h]
  _QWORD *v18; // [rsp+20h] [rbp-50h]
  char *endptr; // [rsp+38h] [rbp-38h]
  __int128 v20; // [rsp+40h] [rbp-30h]
  unsigned __int64 v21; // [rsp+58h] [rbp-18h]

  v18 = a2;
  v17 = a3;
  v16 = a4;
  v21 = __readfsqword(0x28u);
  if ( a4 )
  {
    *__errno_location() = 0;
    v15 = strtold((const char *)(*(unsigned __int16 *)(a2[1] + 2LL * (unsigned __int16)*v17) + a2[5]), &endptr);
    *(_QWORD *)&v20 = *(_QWORD *)&v15;
    DWORD2(v20) = DWORD2(v15);
    if ( *__errno_location() )
    {
      sub_13937(
        a1,
        67,
        0,
        0LL,
        (__int64)"Unknown",
        *(unsigned __int16 *)(a2[1] + 2LL * (unsigned __int16)*v17) + a2[5],
        *(_OWORD *)&v15);
      v6 = __errno_location();
      v7 = strerror(*v6);
      sub_13937(
        a1,
        -1,
        0,
        0LL,
        (__int64)"Failed to convert \"%.*s\" into a long double (%s).",
        *(unsigned __int16 *)(a2[2] + 2LL * (unsigned __int16)*v17),
        a2[5] + *(unsigned __int16 *)(a2[1] + 2LL * (unsigned __int16)*v17),
        v7);
      return 0xFFFFFFFFLL;
    }
    v9 = &endptr[-a2[5] - *(unsigned __int16 *)(a2[1] + 2LL * (unsigned __int16)*v17)];
    v10 = &endptr[-v18[5] - *(unsigned __int16 *)(v18[1] + 2LL * (unsigned __int16)*v17)];
    v11 = v18[2];
    if ( v10 != (char *)*(unsigned __int16 *)(v11 + 2LL * (unsigned __int16)*v17) )
    {
      sub_13937(
        a1,
        67,
        0,
        0LL,
        (__int64)"Unknown",
        *(unsigned __int16 *)(v18[1] + 2LL * (unsigned __int16)*v17) + v18[5],
        *(_OWORD *)&v15);
      sub_13937(
        a1,
        -1,
        0,
        0LL,
        (__int64)"Failed to convert \"%.*s\" into a long double.",
        *(unsigned __int16 *)(v18[2] + 2LL * (unsigned __int16)*v17),
        v18[5] + *(unsigned __int16 *)(v18[1] + 2LL * (unsigned __int16)*v17));
      return 0xFFFFFFFFLL;
    }
    sub_C69DE(v16, (__int64)v9, v11, (__int64)v10, v4, v5, v20);
  }
  v12 = *(unsigned __int16 *)(v18[1] + 2LL * (unsigned __int16)*v17);
  v13 = sub_C49BD(*(_DWORD *)(*v18 + 4LL * (unsigned __int16)*v17));
  if ( v16 )
    v14 = "parsed";
  else
    v14 = "skipped";
  sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_number", (__int64)v14, (__int64)v13, v12, *(_OWORD *)&v15);
  ++*v17;
  return 0LL;
}

//----- (00000000000D99FD) ----------------------------------------------------
signed __int64 __fastcall sub_D99FD(__int64 a1, __int16 *a2, _QWORD **a3, __int64 *a4, _QWORD *a5, unsigned int a6)
{
  unsigned int v6; // ebx
  const char *v7; // rdx
  const char *v8; // rax
  signed __int64 result; // rax
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rbx
  const char *v14; // rax
  unsigned int v15; // ebx
  const char *v16; // rdx
  char *v17; // rax
  unsigned int v18; // [rsp+4h] [rbp-4Ch]
  unsigned int *v19; // [rsp+8h] [rbp-48h]
  __int64 *v20; // [rsp+10h] [rbp-40h]
  _QWORD **v21; // [rsp+18h] [rbp-38h]
  int v22; // [rsp+34h] [rbp-1Ch]
  unsigned int v23; // [rsp+38h] [rbp-18h]
  unsigned int v24; // [rsp+38h] [rbp-18h]
  unsigned int v25; // [rsp+38h] [rbp-18h]
  unsigned int v26; // [rsp+38h] [rbp-18h]
  unsigned int v27; // [rsp+38h] [rbp-18h]
  unsigned int v28; // [rsp+38h] [rbp-18h]
  unsigned int v29; // [rsp+38h] [rbp-18h]
  int v30; // [rsp+3Ch] [rbp-14h]

  v21 = a3;
  v20 = a4;
  v19 = (unsigned int *)a5;
  v18 = a6;
  switch ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) )
  {
    case 1:
      v6 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
      v7 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
      if ( v19 )
        v8 = "parsed";
      else
        v8 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_path_expr", (__int64)v8, (__int64)v7, v6);
      ++*a2;
      v23 = sub_DC160((_QWORD *)a1, a2, 0, v21, v20, v19, v18);
      if ( v23 != -1 && v23 != 1 )
      {
        if ( *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) != 2 )
          __assert_fail(
            "exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2",
            "/home/mantovan/Repositories/libyang/src/xpath.c",
            0x1E6Eu,
            "eval_path_expr");
        v10 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
        v11 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
        if ( v19 )
          v12 = "parsed";
        else
          v12 = "skipped";
        sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_path_expr", (__int64)v12, (__int64)v11, v10);
        ++*a2;
        v30 = 0;
        break;
      }
      return v23;
    case 5:
    case 6:
    case 7:
    case 9:
    case 0xA:
      v24 = sub_D7B49(a1, a2, a3, a4, 0, a5, a6);
      if ( !v24 )
        goto LABEL_41;
      return v24;
    case 0xB:
      if ( a5 )
        v25 = sub_D8307(a1, (unsigned __int16 *)a2, (__int64)a3, a4, (const char **)a5, a6);
      else
        v25 = sub_D8307(a1, (unsigned __int16 *)a2, (__int64)a3, a4, 0LL, a6);
      if ( !v25 )
      {
        v30 = 1;
        break;
      }
      return v25;
    case 0x10:
      v26 = sub_D8060((_QWORD *)a1, a2, (__int64)a3, (void **)a4, (__int64)a5, a6);
      if ( v26 )
        result = v26;
      else
LABEL_41:
        result = 0LL;
      return result;
    case 0x11:
      if ( a5 && !(a6 & 0x3C) )
      {
        sub_D6835((_QWORD *)a1, a2, (__int64)a5);
      }
      else
      {
        if ( a5 )
          sub_C6D49((__int64)a5);
        sub_D6835((_QWORD *)a1, a2, 0LL);
      }
      v30 = 1;
      break;
    case 0x12:
      if ( a5 && !(a6 & 0x3C) )
      {
        v27 = sub_D9687((void *)*a4, (_QWORD *)a1, a2, (__int64)a5);
      }
      else
      {
        if ( a5 )
          sub_C6D49((__int64)a5);
        v27 = sub_D9687((void *)*v20, (_QWORD *)a1, a2, 0LL);
      }
      if ( v27 )
        return v27;
      v30 = 1;
      break;
    default:
      v13 = *(_QWORD *)(a1 + 40) + *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
      v14 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
      sub_13937((void *)*v20, 67, 0, 0LL, (__int64)v14, v13);
      return 0xFFFFFFFFLL;
  }
  while ( *(_WORD *)(a1 + 32) > (unsigned __int16)*a2 && *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) == 3 )
  {
    v28 = sub_D729A((_QWORD *)a1, a2, (__int64)v21, v20, (__int64)v19, v18, v30);
    if ( v28 )
      return v28;
  }
  if ( *(_WORD *)(a1 + 32) <= (unsigned __int16)*a2 || *(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2) != 16 )
    goto LABEL_62;
  if ( *(_WORD *)(*(_QWORD *)(a1 + 16) + 2LL * (unsigned __int16)*a2) == 1 )
  {
    v22 = 0;
  }
  else
  {
    if ( *(_WORD *)(*(_QWORD *)(a1 + 16) + 2LL * (unsigned __int16)*a2) != 2 )
      __assert_fail(
        "exp->tok_len[*exp_idx] == 2",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1ECFu,
        "eval_path_expr");
    v22 = 1;
  }
  v15 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 2LL * (unsigned __int16)*a2);
  v16 = sub_C49BD(*(_DWORD *)(*(_QWORD *)a1 + 4LL * (unsigned __int16)*a2));
  v17 = v19 ? "parsed" : "skipped";
  sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_path_expr", (__int64)v17, (__int64)v16, v15);
  ++*a2;
  v29 = sub_D7B49(a1, a2, v21, v20, v22, v19, v18);
  if ( v29 )
    result = v29;
  else
LABEL_62:
    result = 0LL;
  return result;
}

//----- (00000000000DA06F) ----------------------------------------------------
__int64 __fastcall sub_DA06F(_QWORD *a1, _WORD *a2, unsigned __int16 a3, _QWORD **a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int *v17; // [rsp+0h] [rbp-E0h]
  __int64 *v18; // [rsp+8h] [rbp-D8h]
  _QWORD **v19; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v20; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+3Ah] [rbp-A6h]
  unsigned int v22; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  unsigned int v24[18]; // [rsp+80h] [rbp-60h]
  unsigned __int64 v25; // [rsp+C8h] [rbp-18h]

  v19 = a4;
  v18 = a5;
  v17 = a6;
  v20 = a3;
  v25 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x1EF5u, "eval_union_expr");
  memset(&s, 0, 0x40uLL);
  memset(v24, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v17, (__int64)v17, v7, v8, v9);
  v22 = sub_DC160(a1, a2, 8u, v19, v18, v17, a7);
  if ( !v22 )
  {
    for ( i = 0; i < v20; ++i )
    {
      if ( *(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2) != 15 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_UNI",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1F03u,
          "eval_union_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
      if ( v17 )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_union_expr", (__int64)v12, (__int64)v11, v10, v17);
      ++*a2;
      if ( v17 )
      {
        sub_C6A3F((__int64)v24, (__int64)&s, (__int64)&s, v13, v14, v15);
        v22 = sub_DC160(a1, a2, 8u, v19, v18, v24, a7);
        if ( v22 )
          break;
        if ( a7 & 0x3C )
        {
          sub_C7180(v17, v24);
        }
        else if ( (unsigned int)sub_D476C(v17, v24, v19, a7) )
        {
          v22 = -1;
          break;
        }
      }
      else
      {
        v22 = sub_DC160(a1, a2, 8u, v19, v18, 0LL, a7);
        if ( v22 )
          break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v19, v18, a7);
  sub_DC765((__int64)v24, 0, (__int64)v19, v18, a7);
  return v22;
}

//----- (00000000000DA41B) ----------------------------------------------------
signed __int64 __fastcall sub_DA41B(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, void **a5, __int64 a6, int a7)
{
  unsigned int v7; // ebx
  const char *v8; // rdx
  const char *v9; // rax
  unsigned int *v11; // [rsp+0h] [rbp-50h]
  void **v12; // [rsp+8h] [rbp-48h]
  _QWORD **v13; // [rsp+10h] [rbp-40h]
  unsigned __int16 v14; // [rsp+1Ch] [rbp-34h]
  unsigned __int16 i; // [rsp+38h] [rbp-18h]
  unsigned __int16 v16; // [rsp+3Ah] [rbp-16h]
  unsigned int v17; // [rsp+3Ch] [rbp-14h]

  v13 = (_QWORD **)a4;
  v12 = a5;
  v11 = (unsigned int *)a6;
  v14 = a3;
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x1F39u, "eval_unary_expr");
  v16 = *a2;
  for ( i = 0; i < v14; ++i )
  {
    if ( (unsigned int)sub_C9129(*v12, (__int64)a1, *a2, 14, 0LL, a6)
      || *(_BYTE *)(a1[5] + *(unsigned __int16 *)(a1[1] + 2LL * *a2)) != 45 )
    {
      __assert_fail(
        "!exp_check_token(local_mod->ctx, exp, *exp_idx, LYXP_TOKEN_OPERATOR_MATH, 0) && (exp->expr[exp->expr_pos[*exp_idx]] == '-')",
        "/home/mantovan/Repositories/libyang/src/xpath.c",
        0x1F3Eu,
        "eval_unary_expr");
    }
    v7 = *(unsigned __int16 *)(a1[1] + 2LL * *a2);
    v8 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * *a2));
    if ( v11 )
      v9 = "parsed";
    else
      v9 = "skipped";
    sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_unary_expr", (__int64)v9, (__int64)v8, v7, v11);
    ++*a2;
  }
  v17 = sub_DC160(a1, (__int16 *)a2, 7u, v13, (__int64 *)v12, v11, a7);
  if ( v17 )
    return v17;
  if ( v11 && v14 & 1 )
  {
    if ( a7 & 0x3C )
    {
      sub_CC97E((__int64)*v12, (__int64)v11, 0LL, 1, a1[5], *(_WORD *)(2LL * v16 + a1[1]));
    }
    else if ( (unsigned int)sub_D65EB(
                              (__int64)v11,
                              0LL,
                              (_BYTE *)(a1[5] + *(unsigned __int16 *)(2LL * v16 + a1[1])),
                              (__int64)v13,
                              (__int64 *)v12,
                              a7) )
    {
      return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (00000000000DA6A9) ----------------------------------------------------
__int64 __fastcall sub_DA6A9(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int *v17; // [rsp+0h] [rbp-E0h]
  __int64 *v18; // [rsp+8h] [rbp-D8h]
  _QWORD **v19; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v20; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+38h] [rbp-A8h]
  unsigned __int16 v22; // [rsp+3Ah] [rbp-A6h]
  unsigned int v23; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  long double v25[4]; // [rsp+80h] [rbp-60h]
  unsigned __int64 v26; // [rsp+C8h] [rbp-18h]

  v19 = (_QWORD **)a4;
  v18 = a5;
  v17 = a6;
  v20 = a3;
  v26 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x1F70u, "eval_multiplicative_expr");
  memset(&s, 0, 0x40uLL);
  memset(v25, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v17, (__int64)v17, v7, v8, v9);
  v23 = sub_DC160(a1, (__int16 *)a2, 6u, v19, v18, v17, a7);
  if ( !v23 )
  {
    for ( i = 0; i < v20; ++i )
    {
      v22 = *a2;
      if ( *(_DWORD *)(*a1 + 4LL * *a2) != 14 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_MATH",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1F80u,
          "eval_multiplicative_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * *a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * *a2));
      if ( v17 )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(
        8u,
        (__int64)"%-27s %s %s[%u]",
        (__int64)"eval_multiplicative_expr",
        (__int64)v12,
        (__int64)v11,
        v10,
        v17);
      ++*a2;
      if ( v17 )
      {
        sub_C6A3F((__int64)v25, (__int64)&s, (__int64)&s, v13, v14, v15);
        v23 = sub_DC160(a1, (__int16 *)a2, 6u, v19, v18, (unsigned int *)v25, a7);
        if ( v23 )
          break;
        if ( a7 & 0x3C )
        {
          sub_CC97E(*v18, (__int64)v17, (__int64)v25, 1, a1[5], *(_WORD *)(2LL * v22 - 2 + a1[1]));
          sub_C7180(v17, (unsigned int *)v25);
          sub_C6D49((__int64)v17);
        }
        else if ( (unsigned int)sub_D65EB(
                                  (__int64)v17,
                                  v25,
                                  (_BYTE *)(a1[5] + *(unsigned __int16 *)(2LL * v22 + a1[1])),
                                  (__int64)v19,
                                  v18,
                                  a7) )
        {
          v23 = -1;
          break;
        }
      }
      else
      {
        v23 = sub_DC160(a1, (__int16 *)a2, 6u, v19, v18, 0LL, a7);
        if ( v23 )
          break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v19, v18, a7);
  sub_DC765((__int64)v25, 0, (__int64)v19, v18, a7);
  return v23;
}

//----- (00000000000DAB0C) ----------------------------------------------------
__int64 __fastcall sub_DAB0C(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int *v17; // [rsp+0h] [rbp-E0h]
  __int64 *v18; // [rsp+8h] [rbp-D8h]
  _QWORD **v19; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v20; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+38h] [rbp-A8h]
  unsigned __int16 v22; // [rsp+3Ah] [rbp-A6h]
  unsigned int v23; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  long double v25[4]; // [rsp+80h] [rbp-60h]
  unsigned __int64 v26; // [rsp+C8h] [rbp-18h]

  v19 = (_QWORD **)a4;
  v18 = a5;
  v17 = a6;
  v20 = a3;
  v26 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x1FBEu, "eval_additive_expr");
  memset(&s, 0, 0x40uLL);
  memset(v25, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v17, (__int64)v17, v7, v8, v9);
  v23 = sub_DC160(a1, (__int16 *)a2, 5u, v19, v18, v17, a7);
  if ( !v23 )
  {
    for ( i = 0; i < v20; ++i )
    {
      v22 = *a2;
      if ( *(_DWORD *)(*a1 + 4LL * *a2) != 14 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_MATH",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x1FCEu,
          "eval_additive_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * *a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * *a2));
      if ( v17 )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_additive_expr", (__int64)v12, (__int64)v11, v10, v17);
      ++*a2;
      if ( v17 )
      {
        sub_C6A3F((__int64)v25, (__int64)&s, (__int64)&s, v13, v14, v15);
        v23 = sub_DC160(a1, (__int16 *)a2, 5u, v19, v18, (unsigned int *)v25, a7);
        if ( v23 )
          break;
        if ( a7 & 0x3C )
        {
          sub_CC97E(*v18, (__int64)v17, (__int64)v25, 1, a1[5], *(_WORD *)(2LL * v22 - 2 + a1[1]));
          sub_C7180(v17, (unsigned int *)v25);
          sub_C6D49((__int64)v17);
        }
        else if ( (unsigned int)sub_D65EB(
                                  (__int64)v17,
                                  v25,
                                  (_BYTE *)(a1[5] + *(unsigned __int16 *)(2LL * v22 + a1[1])),
                                  (__int64)v19,
                                  v18,
                                  a7) )
        {
          break;
        }
      }
      else
      {
        v23 = sub_DC160(a1, (__int16 *)a2, 5u, v19, v18, 0LL, a7);
        if ( v23 )
          break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v19, v18, a7);
  sub_DC765((__int64)v25, 0, (__int64)v19, v18, a7);
  return v23;
}

//----- (00000000000DAF68) ----------------------------------------------------
__int64 __fastcall sub_DAF68(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int *v17; // [rsp+0h] [rbp-E0h]
  __int64 *v18; // [rsp+8h] [rbp-D8h]
  _QWORD **v19; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v20; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+38h] [rbp-A8h]
  unsigned __int16 v22; // [rsp+3Ah] [rbp-A6h]
  unsigned int v23; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  long double v25[4]; // [rsp+80h] [rbp-60h]
  unsigned __int64 v26; // [rsp+C8h] [rbp-18h]

  v19 = (_QWORD **)a4;
  v18 = a5;
  v17 = a6;
  v20 = a3;
  v26 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x200Du, "eval_relational_expr");
  memset(&s, 0, 0x40uLL);
  memset(v25, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v17, (__int64)v17, v7, v8, v9);
  v23 = sub_DC160(a1, (__int16 *)a2, 4u, v19, v18, v17, a7);
  if ( !v23 )
  {
    for ( i = 0; i < v20; ++i )
    {
      v22 = *a2;
      if ( *(_DWORD *)(*a1 + 4LL * *a2) != 13 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_COMP",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x201Du,
          "eval_relational_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * *a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * *a2));
      if ( v17 )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_relational_expr", (__int64)v12, (__int64)v11, v10, v17);
      ++*a2;
      if ( v17 )
      {
        sub_C6A3F((__int64)v25, (__int64)&s, (__int64)&s, v13, v14, v15);
        v23 = sub_DC160(a1, (__int16 *)a2, 4u, v19, v18, (unsigned int *)v25, a7);
        if ( v23 )
          break;
        if ( a7 & 0x3C )
        {
          sub_CC97E(*v18, (__int64)v17, (__int64)v25, 1, a1[5], *(_WORD *)(2LL * v22 - 2 + a1[1]));
          sub_C7180(v17, (unsigned int *)v25);
          sub_C6D49((__int64)v17);
        }
        else if ( (unsigned int)sub_D5BFA(
                                  (long double *)v17,
                                  v25,
                                  (_BYTE *)(a1[5] + *(unsigned __int16 *)(2LL * v22 + a1[1])),
                                  (__int64)v19,
                                  v18,
                                  a7) )
        {
          v23 = -1;
          break;
        }
      }
      else
      {
        v23 = sub_DC160(a1, (__int16 *)a2, 4u, v19, v18, 0LL, a7);
        if ( v23 )
          break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v19, v18, a7);
  sub_DC765((__int64)v25, 0, (__int64)v19, v18, a7);
  return v23;
}

//----- (00000000000DB3CB) ----------------------------------------------------
__int64 __fastcall sub_DB3CB(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int *v17; // [rsp+0h] [rbp-E0h]
  __int64 *v18; // [rsp+8h] [rbp-D8h]
  _QWORD **v19; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v20; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+38h] [rbp-A8h]
  unsigned __int16 v22; // [rsp+3Ah] [rbp-A6h]
  unsigned int v23; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  long double v25[4]; // [rsp+80h] [rbp-60h]
  unsigned __int64 v26; // [rsp+C8h] [rbp-18h]

  v19 = (_QWORD **)a4;
  v18 = a5;
  v17 = a6;
  v20 = a3;
  v26 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x205Au, "eval_equality_expr");
  memset(&s, 0, 0x40uLL);
  memset(v25, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v17, (__int64)v17, v7, v8, v9);
  v23 = sub_DC160(a1, (__int16 *)a2, 3u, v19, v18, v17, a7);
  if ( !v23 )
  {
    for ( i = 0; i < v20; ++i )
    {
      v22 = *a2;
      if ( *(_DWORD *)(*a1 + 4LL * *a2) != 13 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_COMP",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x206Au,
          "eval_equality_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * *a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * *a2));
      if ( v17 )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_equality_expr", (__int64)v12, (__int64)v11, v10, v17);
      ++*a2;
      if ( v17 )
      {
        sub_C6A3F((__int64)v25, (__int64)&s, (__int64)&s, v13, v14, v15);
        v23 = sub_DC160(a1, (__int16 *)a2, 3u, v19, v18, (unsigned int *)v25, a7);
        if ( v23 )
          break;
        if ( a7 & 0x3C )
        {
          sub_CC97E(*v18, (__int64)v17, (__int64)v25, 0, a1[5], *(_WORD *)(2LL * v22 - 2 + a1[1]));
          sub_CCC96(*v18, a1, (__int64)v17, *a2 - 1, v22 - 1, *a2 - 1);
          sub_CCC96(*v18, a1, (__int64)v25, v22 - 1, v22 - 1, *a2 - 1);
          sub_C7180(v17, (unsigned int *)v25);
          sub_C6D49((__int64)v17);
        }
        else if ( (unsigned int)sub_D5BFA(
                                  (long double *)v17,
                                  v25,
                                  (_BYTE *)(a1[5] + *(unsigned __int16 *)(2LL * v22 + a1[1])),
                                  (__int64)v19,
                                  v18,
                                  a7) )
        {
          v23 = -1;
          break;
        }
      }
      else
      {
        v23 = sub_DC160(a1, (__int16 *)a2, 3u, v19, v18, 0LL, a7);
        if ( v23 )
          return v23;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v19, v18, a7);
  sub_DC765((__int64)v25, 0, (__int64)v19, v18, a7);
  return v23;
}

//----- (00000000000DB8DA) ----------------------------------------------------
__int64 __fastcall sub_DB8DA(_QWORD *a1, _WORD *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned int *v20; // [rsp+0h] [rbp-E0h]
  __int64 *v21; // [rsp+8h] [rbp-D8h]
  _QWORD **v22; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v23; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+3Ah] [rbp-A6h]
  unsigned int v25; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  char v27; // [rsp+80h] [rbp-60h]
  unsigned __int64 v28; // [rsp+C8h] [rbp-18h]

  v22 = (_QWORD **)a4;
  v21 = a5;
  v20 = a6;
  v23 = a3;
  v28 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x20A7u, "eval_and_expr");
  memset(&s, 0, 0x40uLL);
  memset(&v27, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v20, (__int64)v20, v7, v8, v9);
  v25 = sub_DC160(a1, a2, 2u, v22, v21, v20, a7);
  if ( !v25 )
  {
    if ( v20 && a7 & 0x3C )
      sub_C6D49((__int64)v20);
    else
      sub_DC765((__int64)v20, 3, (__int64)v22, v21, a7);
    for ( i = 0; i < v23; ++i )
    {
      if ( *(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2) != 12 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_LOG",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x20BCu,
          "eval_and_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
      if ( v20 && v20[4] )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_and_expr", (__int64)v12, (__int64)v11, v10, v20);
      ++*a2;
      if ( v20 && (*v20 != 3 || v20[4]) )
      {
        sub_C6A3F((__int64)&v27, (__int64)&s, (__int64)&s, v13, v14, v15);
        v25 = sub_DC160(a1, a2, 2u, v22, v21, (unsigned int *)&v27, a7);
        if ( v25 )
          break;
        if ( *v20 == 2 )
        {
          sub_C6D49((__int64)&v27);
          sub_C7180(v20, (unsigned int *)&v27);
        }
        else
        {
          sub_DC765((__int64)&v27, 3, (__int64)v22, v21, a7);
          sub_C6A3F((__int64)v20, (__int64)&v27, (__int64)&v27, v16, v17, v18);
        }
      }
      else
      {
        v25 = sub_DC160(a1, a2, 2u, v22, v21, 0LL, a7);
        if ( v25 )
          break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v22, v21, a7);
  sub_DC765((__int64)&v27, 0, (__int64)v22, v21, a7);
  return v25;
}

//----- (00000000000DBD1D) ----------------------------------------------------
__int64 __fastcall sub_DBD1D(_QWORD *a1, _WORD *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // ebx
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned int *v20; // [rsp+0h] [rbp-E0h]
  __int64 *v21; // [rsp+8h] [rbp-D8h]
  _QWORD **v22; // [rsp+10h] [rbp-D0h]
  unsigned __int16 v23; // [rsp+1Ch] [rbp-C4h]
  unsigned __int16 i; // [rsp+3Ah] [rbp-A6h]
  unsigned int v25; // [rsp+3Ch] [rbp-A4h]
  char s; // [rsp+40h] [rbp-A0h]
  char v27; // [rsp+80h] [rbp-60h]
  unsigned __int64 v28; // [rsp+C8h] [rbp-18h]

  v22 = (_QWORD **)a4;
  v21 = a5;
  v20 = a6;
  v23 = a3;
  v28 = __readfsqword(0x28u);
  if ( !a3 )
    __assert_fail("repeat", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x20F5u, "eval_or_expr");
  memset(&s, 0, 0x40uLL);
  memset(&v27, 0, 0x40uLL);
  sub_C6A3F((__int64)&s, (__int64)v20, (__int64)v20, v7, v8, v9);
  v25 = sub_DC160(a1, a2, 1u, v22, v21, v20, a7);
  if ( !v25 )
  {
    if ( v20 && a7 & 0x3C )
      sub_C6D49((__int64)v20);
    else
      sub_DC765((__int64)v20, 3, (__int64)v22, v21, a7);
    for ( i = 0; i < v23; ++i )
    {
      if ( *(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2) != 12 )
        __assert_fail(
          "exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_LOG",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x210Au,
          "eval_or_expr");
      v10 = *(unsigned __int16 *)(a1[1] + 2LL * (unsigned __int16)*a2);
      v11 = sub_C49BD(*(_DWORD *)(*a1 + 4LL * (unsigned __int16)*a2));
      if ( v20 && !v20[4] )
        v12 = "parsed";
      else
        v12 = "skipped";
      sub_12312(8u, (__int64)"%-27s %s %s[%u]", (__int64)"eval_or_expr", (__int64)v12, (__int64)v11, v10, v20);
      ++*a2;
      if ( v20 && (*v20 != 3 || !v20[4]) )
      {
        sub_C6A3F((__int64)&v27, (__int64)&s, (__int64)&s, v13, v14, v15);
        v25 = sub_DC160(a1, a2, 1u, v22, v21, (unsigned int *)&v27, a7);
        if ( v25 )
          break;
        if ( *v20 == 2 )
        {
          sub_C6D49((__int64)&v27);
          sub_C7180(v20, (unsigned int *)&v27);
        }
        else
        {
          sub_DC765((__int64)&v27, 3, (__int64)v22, v21, a7);
          sub_C6A3F((__int64)v20, (__int64)&v27, (__int64)&v27, v16, v17, v18);
        }
      }
      else
      {
        v25 = sub_DC160(a1, a2, 1u, v22, v21, 0LL, a7);
        if ( v25 )
          break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, (__int64)v22, v21, a7);
  sub_DC765((__int64)&v27, 0, (__int64)v22, v21, a7);
  return v25;
}

//----- (00000000000DC160) ----------------------------------------------------
__int64 __fastcall sub_DC160(_QWORD *a1, __int16 *a2, unsigned int a3, _QWORD **a4, __int64 *a5, unsigned int *a6, unsigned int a7)
{
  __int64 v7; // rax
  unsigned __int16 i; // [rsp+34h] [rbp-Ch]
  unsigned __int16 v10; // [rsp+36h] [rbp-Ah]
  unsigned int v11; // [rsp+38h] [rbp-8h]
  unsigned int v12; // [rsp+3Ch] [rbp-4h]

  if ( *(_QWORD *)(a1[3] + 8LL * (unsigned __int16)*a2) )
  {
    for ( i = 0; a3 < *(_DWORD *)(4LL * i + *(_QWORD *)(a1[3] + 8LL * (unsigned __int16)*a2)); ++i )
      ;
    if ( i )
    {
      v12 = *(_DWORD *)(4LL * i - 4 + *(_QWORD *)(a1[3] + 8LL * (unsigned __int16)*a2));
      v10 = 0;
      while ( i && v12 == *(_DWORD *)(4LL * i - 4 + *(_QWORD *)(a1[3] + 8LL * (unsigned __int16)*a2)) )
      {
        ++v10;
        --i;
      }
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = 0;
  }
  switch ( (unsigned __int64)v12 )
  {
    case 0uLL:
      v11 = sub_D99FD((__int64)a1, a2, a4, a5, a6, a7);
      break;
    case 1uLL:
      v11 = sub_DBD1D(a1, a2, v10, (__int64)a4, a5, a6, a7);
      break;
    case 2uLL:
      v11 = sub_DB8DA(a1, a2, v10, (__int64)a4, a5, a6, a7);
      break;
    case 3uLL:
      v11 = sub_DB3CB(a1, (unsigned __int16 *)a2, v10, (__int64)a4, a5, a6, a7);
      break;
    case 4uLL:
      v11 = sub_DAF68(a1, (unsigned __int16 *)a2, v10, (__int64)a4, a5, a6, a7);
      break;
    case 5uLL:
      v11 = sub_DAB0C(a1, (unsigned __int16 *)a2, v10, (__int64)a4, a5, a6, a7);
      break;
    case 6uLL:
      v11 = sub_DA6A9(a1, (unsigned __int16 *)a2, v10, (__int64)a4, a5, a6, a7);
      break;
    case 7uLL:
      v11 = sub_DA41B(a1, (unsigned __int16 *)a2, v10, (__int64)a4, (void **)a5, (__int64)a6, a7);
      break;
    case 8uLL:
      v11 = sub_DA06F(a1, a2, v10, a4, a5, a6, a7);
      break;
    default:
      v11 = -1;
      if ( a5 )
        v7 = *a5;
      else
        v7 = 0LL;
      sub_12222(
        v7,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
        8564LL,
        a6);
      break;
  }
  return v11;
}

//----- (00000000000DC4B2) ----------------------------------------------------
signed __int64 __fastcall sub_DC4B2(const char *a1, char *a2, int a3, void **a4, _DWORD *a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // r8
  __int64 v15; // r9
  _DWORD *s; // [rsp+8h] [rbp-48h]
  __int64 *v17; // [rsp+10h] [rbp-40h]
  unsigned int v18; // [rsp+18h] [rbp-38h]
  int v19; // [rsp+1Ch] [rbp-34h]
  char *v20; // [rsp+20h] [rbp-30h]
  unsigned __int16 v21; // [rsp+32h] [rbp-1Eh]
  unsigned int v22; // [rsp+34h] [rbp-1Ch]
  void *v23; // [rsp+38h] [rbp-18h]
  _QWORD *v24; // [rsp+40h] [rbp-10h]
  unsigned __int64 v25; // [rsp+48h] [rbp-8h]

  v20 = a2;
  v19 = a3;
  v17 = (__int64 *)a4;
  s = a5;
  v18 = a6;
  v25 = __readfsqword(0x28u);
  v21 = 0;
  v22 = -1;
  if ( a1 && a4 && a5 )
  {
    v23 = *a4;
    v24 = sub_CB4D2(v23, a1);
    if ( v24 )
    {
      v9 = v24;
      v22 = sub_CB062(v23, v24, &v21, (__int64)v24, v7, v8);
      if ( !v22 )
      {
        v13 = *((unsigned __int16 *)v24 + 16);
        if ( (unsigned __int16)v13 <= v21 )
        {
          sub_C4AE9((__int64)v24, (__int64)v9, v13, v10, v11, v12);
          v21 = 0;
          memset(s, 0, 0x40uLL);
          *s = 0;
          if ( v20 )
            sub_C7395((__int64)s, (__int64)v20, 0, v19, 0);
          v22 = sub_DC160(v24, (__int16 *)&v21, 0, (_QWORD **)v20, v17, s, v18);
          if ( v22 == 2 )
            v22 = 0;
          if ( v22 == -1 )
          {
            if ( v20 )
            {
              sub_13937(v23, -2, 3u, v20, v14, v15);
              sub_DC765((__int64)s, 0, (__int64)v20, v17, v18);
            }
          }
        }
        else
        {
          sub_13937(v23, 67, 0, 0LL, (__int64)"Unknown", *(unsigned __int16 *)(2LL * v21 + v24[1]) + v24[5]);
          sub_13937(
            v23,
            -1,
            0,
            0LL,
            (__int64)"Unparsed characters \"%s\" left at the end of an XPath expression.",
            *(unsigned __int16 *)(2LL * v21 + v24[1]) + v24[5]);
          v22 = -1;
        }
      }
    }
    else
    {
      v22 = -1;
    }
    sub_C488D((__int64)v24);
    result = v22;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyxp_eval", a6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000DC765) ----------------------------------------------------
signed __int64 __fastcall sub_DC765(__int64 a1, int a2, __int64 a3, __int64 *a4, int a5)
{
  unsigned int v6; // eax
  __int64 v7; // r9
  char v8; // fps^1
  __int16 v10; // fps
  __int64 v12; // r9
  char v13; // fps^1
  __int16 v15; // fps
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // r9
  char *v20; // rdx
  __int64 v21; // r9
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r9
  __int64 v25; // rax
  void *v26; // rax
  unsigned int v27; // eax
  void *v28; // rax
  long double v29; // [rsp+10h] [rbp-70h]
  void **v30; // [rsp+30h] [rbp-50h]
  __int64 v31; // [rsp+38h] [rbp-48h]
  int v32; // [rsp+40h] [rbp-40h]
  char *ptr; // [rsp+58h] [rbp-28h]
  _TBYTE v34; // [rsp+60h] [rbp-20h]
  unsigned __int64 v35; // [rsp+78h] [rbp-8h]

  v31 = a3;
  v30 = (void **)a4;
  v32 = a5;
  v35 = __readfsqword(0x28u);
  if ( !a1 || a2 == *(_DWORD *)a1 )
    return 0LL;
  if ( a2 == 1 || *(_DWORD *)a1 == 2 && a2 )
    __assert_fail(
      "(target != LYXP_SET_NODE_SET) && ((set->type != LYXP_SET_SNODE_SET) || (target == LYXP_SET_EMPTY))",
      "/home/mantovan/Repositories/libyang/src/xpath.c",
      0x2221u,
      "lyxp_set_cast");
  if ( *(_DWORD *)a1 == 2 )
  {
    sub_C65F5(a1);
    return 0xFFFFFFFFLL;
  }
  if ( a2 == 5 || a2 == 4 && (*(_DWORD *)a1 == 1 || !*(_DWORD *)a1) )
  {
    v6 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1 )
    {
      if ( !*(_DWORD *)(a1 + 32) )
        __assert_fail("set->used", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x2250u, "lyxp_set_cast");
      if ( (unsigned int)sub_C8295(a1, a3, a5) )
        __assert_fail(
          "!set_sort(set, cur_node, options)",
          "/home/mantovan/Repositories/libyang/src/xpath.c",
          0x2253u,
          "lyxp_set_cast");
      ptr = sub_C5EB1(a1, v31, v30, v32, v22, v23);
      if ( !ptr )
        return 0xFFFFFFFFLL;
      sub_C65F5(a1);
      *(_QWORD *)(a1 + 16) = ptr;
    }
    else if ( v6 < 1 )
    {
      *(_QWORD *)(a1 + 16) = strdup(byte_124F70);
      if ( !*(_QWORD *)(a1 + 16) )
      {
        sub_12222((__int64)*v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_set_cast", v24);
        return 0xFFFFFFFFLL;
      }
    }
    else if ( v6 == 3 )
    {
      if ( *(_DWORD *)(a1 + 16) )
        v20 = strdup("true");
      else
        v20 = strdup("false");
      *(_QWORD *)(a1 + 16) = v20;
      if ( !*(_QWORD *)(a1 + 16) )
      {
        sub_12222((__int64)*v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_set_cast", v21);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if ( v6 != 4 )
      {
        if ( a4 )
          v25 = *a4;
        else
          v25 = 0LL;
        sub_12222(
          v25,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          8801LL);
        return 0xFFFFFFFFLL;
      }
      if ( 0.0 != *(long double *)(a1 + 16) && 0.0 != *(long double *)(a1 + 16) )
      {
        _FST7 = *(long double *)(a1 + 16);
        __asm { fxam }
        if ( (v8 & 0x45) != 5 )
          goto LABEL_95;
        _FST7 = *(long double *)(a1 + 16);
        __asm { fxam }
        if ( v10 & 0x200 )
        {
LABEL_95:
          _FST7 = *(long double *)(a1 + 16);
          __asm { fxam }
          if ( (v13 & 0x45) != 5 )
            goto LABEL_96;
          _FST7 = *(long double *)(a1 + 16);
          __asm { fxam }
          if ( v15 & 0x200 )
          {
            *(_QWORD *)(a1 + 16) = strdup("-Infinity");
            if ( !*(_QWORD *)(a1 + 16) )
            {
              sub_12222((__int64)*v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_set_cast", v17);
              return 0xFFFFFFFFLL;
            }
          }
          else
          {
LABEL_96:
            *(_QWORD *)&v29 = (signed __int64)*(long double *)(a1 + 16);
            if ( *(long double *)(a1 + 16) == (long double)*(signed __int64 *)&v29 )
            {
              if ( asprintf(&ptr, "%lld", (signed __int64)*(long double *)(a1 + 16)) == -1 )
              {
                sub_12222(
                  (__int64)*v30,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"lyxp_set_cast",
                  v18,
                  *(_QWORD *)&v29);
                return 0xFFFFFFFFLL;
              }
              *(_QWORD *)(a1 + 16) = ptr;
            }
            else
            {
              if ( asprintf(&ptr, "%03.1Lf") == -1 )
              {
                sub_12222(
                  (__int64)*v30,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"lyxp_set_cast",
                  v19,
                  *(_QWORD *)&v29);
                return 0xFFFFFFFFLL;
              }
              *(_QWORD *)(a1 + 16) = ptr;
            }
          }
        }
        else
        {
          *(_QWORD *)(a1 + 16) = strdup("Infinity");
          if ( !*(_QWORD *)(a1 + 16) )
          {
            sub_12222((__int64)*v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_set_cast", v12);
            return 0xFFFFFFFFLL;
          }
        }
      }
      else
      {
        *(_QWORD *)(a1 + 16) = strdup("0");
        if ( !*(_QWORD *)(a1 + 16) )
        {
          sub_12222((__int64)*v30, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxp_set_cast", v7);
          return 0xFFFFFFFFLL;
        }
      }
    }
    *(_DWORD *)a1 = 5;
  }
  if ( a2 == 4 )
  {
    if ( *(_DWORD *)a1 == 3 )
    {
      if ( *(_DWORD *)(a1 + 16) )
        *(long double *)(a1 + 16) = 1.0;
      else
        *(long double *)(a1 + 16) = 0.0;
    }
    else
    {
      if ( *(_DWORD *)a1 != 5 )
      {
        if ( v30 )
          v26 = *v30;
        else
          v26 = 0LL;
        sub_12222(
          (__int64)v26,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          8823LL,
          *(_QWORD *)&v29);
        return 0xFFFFFFFFLL;
      }
      v29 = sub_C607E((const char *)*(_QWORD *)(a1 + 16));
      *(_QWORD *)&v34 = *(_QWORD *)&v29;
      *((_DWORD *)&v34 + 2) = DWORD2(v29);
      sub_C65F5(a1);
      *(long double *)(a1 + 16) = *(long double *)&v34;
    }
    *(_DWORD *)a1 = 4;
  }
  if ( a2 == 3 )
  {
    v27 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 1 )
    {
      sub_C65F5(a1);
      if ( !*(_DWORD *)(a1 + 32) )
        __assert_fail("set->used", "/home/mantovan/Repositories/libyang/src/xpath.c", 0x2293u, "lyxp_set_cast");
      *(_DWORD *)(a1 + 16) = 1;
    }
    else if ( v27 < 1 )
    {
      *(_DWORD *)(a1 + 16) = 0;
    }
    else if ( v27 == 4 )
    {
      *(_DWORD *)(a1 + 16) = 0.0 != *(long double *)(a1 + 16);
    }
    else
    {
      if ( v27 != 5 )
      {
        if ( v30 )
          v28 = *v30;
        else
          v28 = 0LL;
        sub_12222(
          (__int64)v28,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/xpath.c",
          8858LL,
          *(_OWORD *)&v29);
        return 0xFFFFFFFFLL;
      }
      if ( **(_BYTE **)(a1 + 16) )
      {
        sub_C65F5(a1);
        *(_DWORD *)(a1 + 16) = 1;
      }
      else
      {
        sub_C65F5(a1);
        *(_DWORD *)(a1 + 16) = 0;
      }
    }
    *(_DWORD *)a1 = 3;
  }
  if ( !a2 )
  {
    sub_C65F5(a1);
    *(_DWORD *)a1 = 0;
  }
  return 0LL;
}

//----- (00000000000DCFF7) ----------------------------------------------------
__int64 __fastcall sub_DCFF7(const char *a1, __int64 a2, int a3, _DWORD *a4, unsigned int a5, _QWORD *a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  _QWORD *v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  __int64 *v13; // rax
  _QWORD *v15; // [rsp+8h] [rbp-58h]
  _DWORD *s; // [rsp+10h] [rbp-50h]
  unsigned int v17; // [rsp+18h] [rbp-48h]
  int v18; // [rsp+1Ch] [rbp-44h]
  _QWORD **v19; // [rsp+20h] [rbp-40h]
  unsigned __int16 v20; // [rsp+3Eh] [rbp-22h]
  int v21; // [rsp+40h] [rbp-20h]
  unsigned int v22; // [rsp+44h] [rbp-1Ch]
  _QWORD **v23; // [rsp+48h] [rbp-18h]
  _QWORD *v24; // [rsp+50h] [rbp-10h]
  unsigned __int64 v25; // [rsp+58h] [rbp-8h]

  v19 = (_QWORD **)a2;
  v18 = a3;
  s = a4;
  v17 = a5;
  v15 = a6;
  v25 = __readfsqword(0x28u);
  v20 = 0;
  v22 = -1;
  v24 = sub_CB4D2(**(void ***)(a2 + 48), a1);
  if ( v24 )
  {
    v8 = v24;
    v22 = sub_CB062((void *)*v19[6], v24, &v20, (__int64)v24, v6, v7);
    if ( !v22 )
    {
      v12 = *((unsigned __int16 *)v24 + 16);
      if ( (unsigned __int16)v12 <= v20 )
      {
        sub_C4AE9((__int64)v24, (__int64)v8, v12, v9, v10, v11);
        if ( v17 & 0x10 )
        {
          sub_27A8D((__int64)v19, (__int64 *)&v23, &v21);
        }
        else
        {
          v23 = v19;
          v21 = v18;
        }
        if ( v15 )
          *v15 = v23;
        v20 = 0;
        memset(s, 0, 0x40uLL);
        *s = 2;
        sub_C765D((__int64)s, (__int64)v23, v21);
        v13 = (__int64 *)lys_node_module(v23);
        v22 = sub_DC160(v24, (__int16 *)&v20, 0, v23, v13, s, v17);
        if ( v22 == 2 )
          v22 = 0;
      }
      else
      {
        sub_13937((void *)*v19[6], 67, 0, 0LL, (__int64)"Unknown", *(unsigned __int16 *)(2LL * v20 + v24[1]) + v24[5]);
        sub_13937(
          (void *)*v19[6],
          -1,
          0,
          0LL,
          (__int64)"Unparsed characters \"%s\" left at the end of an XPath expression.",
          *(unsigned __int16 *)(2LL * v20 + v24[1]) + v24[5]);
        v22 = -1;
      }
    }
  }
  else
  {
    v22 = -1;
  }
  sub_C488D((__int64)v24);
  return v22;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000DD261) ----------------------------------------------------
__int64 __fastcall sub_DD261(__int64 a1, void **a2, int a3)
{
  unsigned int v3; // eax
  __int64 v4; // r13
  __int64 v5; // r14
  __int16 v6; // r12
  __int64 v7; // rbx
  void **v8; // rax
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // ax
  __int16 v12; // ax
  __int64 v13; // r13
  __int64 v14; // r14
  __int16 v15; // r12
  __int64 v16; // rbx
  void **v17; // rax
  __int16 v18; // cx
  __int16 v19; // ax
  __int16 v20; // cx
  __int16 v21; // ax
  int v23; // [rsp+Ch] [rbp-D4h]
  unsigned __int8 v24; // [rsp+2Fh] [rbp-B1h]
  unsigned int l; // [rsp+30h] [rbp-B0h]
  unsigned int j; // [rsp+34h] [rbp-ACh]
  unsigned int m; // [rsp+34h] [rbp-ACh]
  signed int v28; // [rsp+38h] [rbp-A8h]
  unsigned int v29; // [rsp+3Ch] [rbp-A4h]
  __int64 v30; // [rsp+40h] [rbp-A0h]
  __int64 i; // [rsp+48h] [rbp-98h]
  __int64 k; // [rsp+50h] [rbp-90h]
  __int64 v33; // [rsp+58h] [rbp-88h]
  __int64 v34; // [rsp+60h] [rbp-80h]
  void *v35; // [rsp+68h] [rbp-78h]
  unsigned int s[4]; // [rsp+70h] [rbp-70h]
  void *ptr; // [rsp+80h] [rbp-60h]
  unsigned int v38; // [rsp+90h] [rbp-50h]
  unsigned __int64 v39; // [rsp+B8h] [rbp-28h]

  v23 = a3;
  v39 = __readfsqword(0x28u);
  v30 = 0LL;
  v24 = 0;
  v29 = 0;
  v33 = 0LL;
  v34 = 0LL;
  v35 = 0LL;
  memset(s, 0, 0x40uLL);
  memset(a2, 0, 0x40uLL);
  v28 = 0;
  for ( i = a1; i && *(_DWORD *)(i + 56) != 1024; i = lys_parent(i) )
    ;
  if ( i )
    v28 = 32;
  v3 = *(_DWORD *)(a1 + 56);
  if ( v3 == 64 )
  {
    v33 = *(_QWORD *)(a1 + 104);
    goto LABEL_38;
  }
  if ( v3 <= 0x40 )
  {
    if ( v3 == 4 )
    {
      v33 = *(_QWORD *)(a1 + 112);
      v34 = *(_QWORD *)(a1 + 120);
      v24 = *(_BYTE *)(a1 + 31);
      goto LABEL_38;
    }
    if ( v3 <= 4 )
    {
      if ( v3 == 1 )
      {
        v33 = *(_QWORD *)(a1 + 112);
        v34 = *(_QWORD *)(a1 + 120);
        v24 = *(_BYTE *)(a1 + 29);
      }
      else if ( v3 == 2 )
      {
        v33 = *(_QWORD *)(a1 + 104);
      }
      goto LABEL_38;
    }
    if ( v3 == 16 )
    {
      v33 = *(_QWORD *)(a1 + 112);
      v34 = *(_QWORD *)(a1 + 120);
      v24 = *(_BYTE *)(a1 + 28);
      goto LABEL_38;
    }
    if ( v3 != 32 )
    {
      if ( v3 == 8 )
      {
        v33 = *(_QWORD *)(a1 + 112);
        v34 = *(_QWORD *)(a1 + 120);
        v24 = *(_BYTE *)(a1 + 31);
      }
      goto LABEL_38;
    }
LABEL_32:
    v33 = *(_QWORD *)(a1 + 112);
    v34 = *(_QWORD *)(a1 + 120);
    v24 = *(_BYTE *)(a1 + 31);
    goto LABEL_38;
  }
  if ( v3 == 1024 )
    goto LABEL_35;
  if ( v3 <= 0x400 )
  {
    if ( v3 == 128 )
    {
      v34 = *(_QWORD *)(a1 + 120);
      v24 = *(_BYTE *)(a1 + 29);
      goto LABEL_38;
    }
    if ( v3 != 512 )
      goto LABEL_38;
LABEL_35:
    v34 = *(_QWORD *)(a1 + 112);
    v24 = *(_BYTE *)(a1 + 29);
    goto LABEL_38;
  }
  switch ( v3 )
  {
    case 0x2000u:
      v33 = *(_QWORD *)(a1 + 80);
      break;
    case 0x8020u:
      goto LABEL_32;
    case 0x1000u:
      v33 = *(_QWORD *)(a1 + 104);
      break;
  }
LABEL_38:
  if ( v23 )
  {
    for ( i = a1; i && !(*(_DWORD *)(i + 56) & 0x4180); i = lys_parent(i) )
      ;
  }
  if ( v33 )
  {
    if ( (unsigned int)sub_DCFF7(*(const char **)v33, a1, 2, s, v28 | 0x10u, &v30) )
    {
      free(ptr);
      if ( v30 )
      {
        v35 = (void *)lys_path(v30, 1LL);
        sub_13937(
          **(void ***)(a1 + 48),
          -1,
          2u,
          (char *)a1,
          (__int64)"Invalid when condition \"%s\" with context node \"%s\".",
          *(_QWORD *)v33,
          v35);
      }
      else
      {
        sub_13937(**(void ***)(a1 + 48), -1, 2u, (char *)a1, (__int64)"Invalid when condition \"%s\".", *(_QWORD *)v33);
      }
      v29 = -1;
      goto LABEL_100;
    }
    if ( v23 )
    {
      for ( j = 0; j < v38; ++j )
      {
        if ( *((_DWORD *)ptr + 4 * j + 2) == 2 )
        {
          v4 = **((_QWORD **)ptr + 2 * j);
          v5 = lys_node_module(*((_QWORD *)ptr + 2 * j));
          v6 = *(_WORD *)(*((_QWORD *)ptr + 2 * j) + 24LL);
          v7 = *(_QWORD *)a1;
          v8 = (void **)lys_node_module(a1);
          if ( (unsigned int)sub_3C749(*(_WORD *)(a1 + 24), v8, v7, v6, v5, v4, (char *)a1) )
          {
            v29 = -1;
            goto LABEL_100;
          }
          if ( i )
          {
            for ( k = *((_QWORD *)ptr + 2 * j); k && k != i; k = lys_parent(k) )
              ;
            if ( !k )
            {
              if ( *(_WORD *)(*((_QWORD *)ptr + 2 * j) + 24LL) & 1 )
              {
                v9 = *(_WORD *)(v33 + 34);
                HIBYTE(v9) |= 2u;
                *(_WORD *)(v33 + 34) = v9;
                v10 = *(_WORD *)(a1 + 24);
                HIBYTE(v10) |= 2u;
                *(_WORD *)(a1 + 24) = v10;
              }
              else
              {
                if ( !(*(_WORD *)(*((_QWORD *)ptr + 2 * j) + 24LL) & 2) )
                  __assert_fail(
                    "tmp_set.val.snodes[j].snode->flags & LYS_CONFIG_R",
                    "/home/mantovan/Repositories/libyang/src/xpath.c",
                    0x2355u,
                    "lyxp_node_atomize");
                v11 = *(_WORD *)(v33 + 34);
                HIBYTE(v11) |= 4u;
                *(_WORD *)(v33 + 34) = v11;
                v12 = *(_WORD *)(a1 + 24);
                HIBYTE(v12) |= 4u;
                *(_WORD *)(a1 + 24) = v12;
              }
            }
          }
        }
      }
    }
    sub_C7180((unsigned int *)a2, s);
    memset(s, 0, 0x40uLL);
  }
  for ( l = 0; l < v24; ++l )
  {
    if ( (unsigned int)sub_DCFF7(*(const char **)(56LL * l + v34), a1, 2, s, v28 | 8u, &v30) )
    {
      free(ptr);
      if ( v30 )
      {
        v35 = (void *)lys_path(v30, 1LL);
        sub_13937(
          **(void ***)(a1 + 48),
          -1,
          2u,
          (char *)a1,
          (__int64)"Invalid must restriction \"%s\" with context node \"%s\".",
          *(_QWORD *)(56LL * l + v34),
          v35);
      }
      else
      {
        sub_13937(
          **(void ***)(a1 + 48),
          -1,
          2u,
          (char *)a1,
          (__int64)"Invalid must restriction \"%s\".",
          *(_QWORD *)(56LL * l + v34));
      }
      v29 = -1;
      break;
    }
    if ( v23 )
    {
      for ( m = 0; m < v38; ++m )
      {
        if ( *((_DWORD *)ptr + 4 * m + 2) == 2 )
        {
          v13 = **((_QWORD **)ptr + 2 * m);
          v14 = lys_node_module(*((_QWORD *)ptr + 2 * m));
          v15 = *(_WORD *)(*((_QWORD *)ptr + 2 * m) + 24LL);
          v16 = *(_QWORD *)a1;
          v17 = (void **)lys_node_module(a1);
          if ( (unsigned int)sub_3C749(*(_WORD *)(a1 + 24), v17, v16, v15, v14, v13, (char *)a1) )
          {
            v29 = -1;
            goto LABEL_100;
          }
          if ( i )
          {
            for ( k = *((_QWORD *)ptr + 2 * m); k && k != i; k = lys_parent(k) )
              ;
            if ( !k )
            {
              if ( *(_WORD *)(*((_QWORD *)ptr + 2 * m) + 24LL) & 1 )
              {
                v18 = *(_WORD *)(56LL * l + v34 + 50);
                HIBYTE(v18) |= 2u;
                *(_WORD *)(56LL * l + v34 + 50) = v18;
                v19 = *(_WORD *)(a1 + 24);
                HIBYTE(v19) |= 2u;
                *(_WORD *)(a1 + 24) = v19;
              }
              else if ( *(_WORD *)(*((_QWORD *)ptr + 2 * m) + 24LL) & 2 )
              {
                v20 = *(_WORD *)(56LL * l + v34 + 50);
                HIBYTE(v20) |= 4u;
                *(_WORD *)(56LL * l + v34 + 50) = v20;
                v21 = *(_WORD *)(a1 + 24);
                HIBYTE(v21) |= 4u;
                *(_WORD *)(a1 + 24) = v21;
              }
              else
              {
                for ( k = *((_QWORD *)ptr + 2 * m); k && *(_DWORD *)(k + 56) != 0x2000; k = *(_QWORD *)(k + 64) )
                  ;
                if ( !k || *(_BYTE *)(lys_node_module(k) + 64) & 0x80 )
                  __assert_fail(
                    "elem && !lys_node_module(elem)->implemented",
                    "/home/mantovan/Repositories/libyang/src/xpath.c",
                    0x238Cu,
                    "lyxp_node_atomize");
              }
            }
          }
        }
      }
    }
    sub_C7180((unsigned int *)a2, s);
    memset(s, 0, 0x40uLL);
  }
LABEL_100:
  if ( v29 )
  {
    free(a2[2]);
    memset(a2, 0, 0x40uLL);
  }
  free(v35);
  return v29;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7680: using guessed type __int64 __fastcall lys_path(_QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000DDEA9) ----------------------------------------------------
signed __int64 __fastcall sub_DDEA9(__int64 a1)
{
  unsigned int v1; // eax
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // rbx
  const char *v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rbx
  const char *v10; // rax
  unsigned __int8 v11; // [rsp+19h] [rbp-37h]
  unsigned __int16 v12; // [rsp+1Ah] [rbp-36h]
  unsigned int i; // [rsp+1Ch] [rbp-34h]
  const char **v14; // [rsp+20h] [rbp-30h]
  __int64 v15; // [rsp+28h] [rbp-28h]
  _QWORD *v16; // [rsp+30h] [rbp-20h]
  unsigned __int64 v17; // [rsp+38h] [rbp-18h]

  v17 = __readfsqword(0x28u);
  v11 = 0;
  v14 = 0LL;
  v15 = 0LL;
  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 == 64 )
  {
    v14 = *(const char ***)(a1 + 104);
    goto LABEL_32;
  }
  if ( v1 <= 0x40 )
  {
    if ( v1 == 4 )
    {
      v14 = *(const char ***)(a1 + 112);
      v15 = *(_QWORD *)(a1 + 120);
      v11 = *(_BYTE *)(a1 + 31);
      goto LABEL_32;
    }
    if ( v1 <= 4 )
    {
      if ( v1 == 1 )
      {
        v14 = *(const char ***)(a1 + 112);
        v15 = *(_QWORD *)(a1 + 120);
        v11 = *(_BYTE *)(a1 + 29);
      }
      else if ( v1 == 2 )
      {
        v14 = *(const char ***)(a1 + 104);
      }
      goto LABEL_32;
    }
    if ( v1 == 16 )
    {
      v14 = *(const char ***)(a1 + 112);
      v15 = *(_QWORD *)(a1 + 120);
      v11 = *(_BYTE *)(a1 + 28);
      goto LABEL_32;
    }
    if ( v1 != 32 )
    {
      if ( v1 == 8 )
      {
        v14 = *(const char ***)(a1 + 112);
        v15 = *(_QWORD *)(a1 + 120);
        v11 = *(_BYTE *)(a1 + 31);
      }
      goto LABEL_32;
    }
LABEL_26:
    v14 = *(const char ***)(a1 + 112);
    v15 = *(_QWORD *)(a1 + 120);
    v11 = *(_BYTE *)(a1 + 31);
    goto LABEL_32;
  }
  if ( v1 == 1024 )
    goto LABEL_29;
  if ( v1 <= 0x400 )
  {
    if ( v1 == 128 )
    {
      v15 = *(_QWORD *)(a1 + 120);
      v11 = *(_BYTE *)(a1 + 29);
      goto LABEL_32;
    }
    if ( v1 != 512 )
      goto LABEL_32;
LABEL_29:
    v15 = *(_QWORD *)(a1 + 112);
    v11 = *(_BYTE *)(a1 + 29);
    goto LABEL_32;
  }
  switch ( v1 )
  {
    case 0x2000u:
      v14 = *(const char ***)(a1 + 80);
      break;
    case 0x8020u:
      goto LABEL_26;
    case 0x1000u:
      v14 = *(const char ***)(a1 + 104);
      break;
  }
LABEL_32:
  if ( v14 )
  {
    v16 = sub_CB4D2(**(void ***)(a1 + 48), *v14);
    if ( !v16 )
      return 0xFFFFFFFFLL;
    v12 = 0;
    if ( (unsigned int)sub_CB062(**(void ***)(a1 + 48), v16, &v12, (__int64)v16, v2, v3) )
    {
      sub_C488D((__int64)v16);
      return 0xFFFFFFFFLL;
    }
    if ( *((_WORD *)v16 + 16) != v12 )
    {
      v5 = v16[5] + *(unsigned __int16 *)(2LL * v12 + v16[1]);
      v6 = sub_C49BD(*(_DWORD *)(4LL * v12 + *v16));
      sub_13937(**(void ***)(a1 + 48), 67, 0, 0LL, (__int64)v6, v5);
      sub_C488D((__int64)v16);
      return 0xFFFFFFFFLL;
    }
    sub_C488D((__int64)v16);
  }
  for ( i = 0; i < v11; ++i )
  {
    v16 = sub_CB4D2(**(void ***)(a1 + 48), *(const char **)(56LL * i + v15));
    if ( !v16 )
      return 0xFFFFFFFFLL;
    v12 = 0;
    if ( (unsigned int)sub_CB062(**(void ***)(a1 + 48), v16, &v12, (__int64)v16, v7, v8) )
    {
      sub_C488D((__int64)v16);
      return 0xFFFFFFFFLL;
    }
    if ( *((_WORD *)v16 + 16) != v12 )
    {
      v9 = v16[5] + *(unsigned __int16 *)(2LL * v12 + v16[1]);
      v10 = sub_C49BD(*(_DWORD *)(4LL * v12 + *v16));
      sub_13937(**(void ***)(a1 + 48), 67, 0, 0LL, (__int64)v10, v9);
      sub_C488D((__int64)v16);
      return 0xFFFFFFFFLL;
    }
    sub_C488D((__int64)v16);
  }
  return 0LL;
}

//----- (00000000000DE34B) ----------------------------------------------------
void __fastcall sub_DE34B(__int64 a1, const char *a2, int a3)
{
  signed int v3; // eax
  int v4; // [rsp+Ch] [rbp-34h]
  char v5; // [rsp+2Fh] [rbp-11h]
  int i; // [rsp+30h] [rbp-10h]
  int v7; // [rsp+34h] [rbp-Ch]
  const char *v8; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v5 = 0;
  if ( a3 )
  {
    if ( a3 < 0 )
      v4 = strlen(a2);
    v8 = a2;
    v7 = 0;
    for ( i = 0; ; ++i )
    {
      if ( i >= v4 )
      {
        sub_C23A5(a1, v8, v7);
        return;
      }
      v3 = a2[i];
      if ( v3 == 34 )
        break;
      if ( v3 > 34 )
      {
        if ( v3 == 92 )
          break;
      }
      else if ( (unsigned int)(v3 - 9) <= 1 )
      {
        break;
      }
      ++v7;
LABEL_12:
      if ( v5 )
      {
        sub_C23A5(a1, v8, v7);
        if ( v5 == 10 )
        {
          sub_C23A5(a1, &unk_127220, 2uLL);
        }
        else if ( v5 > 10 )
        {
          if ( v5 == 34 )
          {
            sub_C23A5(a1, &unk_127226, 2uLL);
          }
          else if ( v5 == 92 )
          {
            sub_C23A5(a1, &unk_127229, 2uLL);
          }
        }
        else if ( v5 == 9 )
        {
          sub_C23A5(a1, &unk_127223, 2uLL);
        }
        v8 += v7 + 1;
        v7 = 0;
        v5 = 0;
      }
    }
    v5 = a2[i];
    goto LABEL_12;
  }
}

//----- (00000000000DE4D3) ----------------------------------------------------
signed __int64 __fastcall sub_DE4D3(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax

  if ( a2 )
  {
    result = (unsigned int)*a2;
    if ( !(_DWORD)result )
    {
      *a2 = 1;
      result = sub_C1FF7(a1, (const char *)&off_12722C, a3, a4, a5, a6, a2);
    }
  }
  return result;
}
// 12722C: using guessed type void *__ptr32 off_12722C;

//----- (00000000000DE519) ----------------------------------------------------
signed __int64 __fastcall sub_DE519(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax

  if ( (_DWORD)a3 )
    result = sub_C1FF7(a1, "%*s}\n", 2 * a2, (__int64)&unk_127230, a5, a6, __PAIR__(a2, (unsigned int)a3));
  else
    result = sub_C1FF7(a1, ";\n", a3, a4, a5, a6, __PAIR__(a2, (unsigned __int8)a3));
  return result;
}

//----- (00000000000DE573) ----------------------------------------------------
signed __int64 __fastcall sub_DE573(__int64 a1, int a2, __int64 a3, const char *a4, int a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  char *i; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  int v15; // eax
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  signed __int64 result; // rax
  int v21; // [rsp+Ch] [rbp-34h]
  const char *v22; // [rsp+10h] [rbp-30h]
  int v23; // [rsp+24h] [rbp-1Ch]
  char *s; // [rsp+30h] [rbp-10h]
  char *v25; // [rsp+38h] [rbp-8h]

  v23 = a2;
  v22 = a4;
  v21 = a6;
  if ( a5 )
  {
    sub_C1FF7(a1, "%*s%s \"", (unsigned int)(2 * a2), (__int64)&unk_127230, a3, a6);
  }
  else
  {
    sub_C1FF7(a1, "%*s%s\n", (unsigned int)(2 * a2), (__int64)&unk_127230, a3, a6);
    v23 = a2 + 1;
    sub_C1FF7(a1, "%*s\"", (unsigned int)(2 * (a2 + 1)), (__int64)&unk_127230, v6, v7);
  }
  s = (char *)v22;
  for ( i = strchr(v22, 10); ; i = strchr(s, 10) )
  {
    v25 = i;
    if ( !i )
      break;
    sub_DE34B(a1, s, (_DWORD)i - (_DWORD)s);
    sub_C1FF7(a1, "\n", v9, v10, v11, v12);
    s = v25 + 1;
    if ( v25[1] != 10 )
      sub_C1FF7(a1, "%*s ", (unsigned int)(2 * v23), (__int64)&unk_127230, v13, v14);
  }
  v15 = strlen(s);
  sub_DE34B(a1, s, v15);
  if ( v21 )
    result = sub_C1FF7(a1, (const char *)&off_127255, v16, v17, v18, v19);
  else
    result = sub_C1FF7(a1, (const char *)&unk_127259, v16, v17, v18, v19);
  return result;
}
// 127255: using guessed type void *__ptr32 off_127255;

//----- (00000000000DE71C) ----------------------------------------------------
signed __int64 __fastcall sub_DE71C(__int64 a1, int a2, int a3, unsigned int a4, const char *a5, __int64 a6, __int64 a7, unsigned __int8 a8)
{
  signed __int64 result; // rax
  char *v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // [rsp+8h] [rbp-38h]
  const char *v17; // [rsp+10h] [rbp-30h]
  char v18; // [rsp+1Ch] [rbp-24h]
  int v19; // [rsp+20h] [rbp-20h]
  int v20; // [rsp+3Ch] [rbp-4h]

  v19 = a3;
  result = a4;
  v17 = a5;
  v16 = a6;
  v18 = a4;
  LOBYTE(v20) = -1;
  if ( a5 )
  {
    do
      v20 = sub_9EAFC(a7, a8, (unsigned __int8)v20 + 1, v19);
    while ( v20 != -1 && v18 != *(_BYTE *)(*(_QWORD *)(8LL * v20 + a7) + 27LL) );
    if ( *((_DWORD *)&unk_346320 + 6 * v19 + 4) & 2 )
    {
      v9 = v20 == -1 ? ";\n" : &unk_127230;
      result = sub_C1FF7(
                 a1,
                 "%*s%s %s%s",
                 (unsigned int)(2 * a2),
                 (__int64)&unk_127230,
                 *((_QWORD *)&unk_346320 + 3 * v19),
                 (__int64)v17,
                 v9);
    }
    else
    {
      result = sub_DE573(
                 a1,
                 a2,
                 *((_QWORD *)&unk_346320 + 3 * v19),
                 v17,
                 (*((_DWORD *)&unk_346320 + 6 * v19 + 4) & 1) == 0,
                 v20 == -1);
    }
    if ( v20 != -1 )
    {
      sub_C1FF7(a1, (const char *)&off_12722C, v10, v11, v12, v13);
      do
      {
        sub_E6059(a1, a2 + 1, v16, v19, v18, 8LL * v20 + a7, 1u);
        do
          v20 = sub_9EAFC(a7, a8, (unsigned __int8)v20 + 1, v19);
        while ( v20 != -1 && v18 != *(_BYTE *)(*(_QWORD *)(8LL * v20 + a7) + 27LL) );
      }
      while ( v20 != -1 );
      result = sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v14, v15);
    }
  }
  return result;
}
// 12722C: using guessed type void *__ptr32 off_12722C;

//----- (00000000000DE97F) ----------------------------------------------------
signed __int64 __fastcall sub_DE97F(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v13; // [rsp+0h] [rbp-20h]
  __int64 v14; // [rsp+8h] [rbp-18h]

  v14 = a3;
  sub_C1FF7(a1, "%*sif-feature \"", (unsigned int)(2 * a2), (__int64)&unk_127230, a5, a6, a4);
  sub_C2DA0(a1, v14, (__int64 *)v13, 0);
  if ( !*(_BYTE *)(v13 + 8) )
    return sub_C1FF7(a1, (const char *)&off_127255, v6, v7, v8, v9);
  sub_C1FF7(a1, "\" {\n", v6, v7, v8, v9);
  sub_E6059(a1, a2 + 1, v14, 0, 0, *(_QWORD *)(v13 + 24), *(unsigned __int8 *)(v13 + 8));
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v10, v11);
}
// 127255: using guessed type void *__ptr32 off_127255;

//----- (00000000000DEA7A) ----------------------------------------------------
__int64 __fastcall sub_DEA7A(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 result; // rax
  _DWORD *v9; // [rsp+8h] [rbp-38h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  char v12; // [rsp+20h] [rbp-20h]
  signed int i; // [rsp+34h] [rbp-Ch]
  int v14; // [rsp+34h] [rbp-Ch]
  const char *v15; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v12 = a6;
  v15 = 0LL;
  if ( a6 & 1 && *(_BYTE *)(a3 + 26) )
  {
    sub_DE4D3(a1, a5, (__int64)a5, a4, (__int64)a5, a6);
    sub_E6059(a1, a2, v10, 0, 0, *(_QWORD *)(v11 + 32), *(unsigned __int8 *)(v11 + 26));
  }
  if ( v12 & 2 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(v11 + 27); ++i )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE97F(a1, a2, v10, *(_QWORD *)(v11 + 40) + 32LL * i, v6, v7);
    }
  }
  if ( v12 & 4 )
  {
    v14 = sub_9EAFC(*(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26), 0, 23);
    if ( lys_parent(v11) )
    {
      if ( *(_WORD *)(v11 + 24) & 4 || v14 != -1 )
      {
        if ( *(_WORD *)(v11 + 24) & 1 )
        {
          sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
          sub_DE71C(a1, a2, 23, 0, "true", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
        }
        else if ( *(_WORD *)(v11 + 24) & 2 )
        {
          sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
          sub_DE71C(a1, a2, 23, 0, "false", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
        }
      }
    }
    else if ( *(_WORD *)(v11 + 24) & 2 )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE71C(a1, a2, 23, 0, "false", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else if ( v14 != -1 )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE71C(a1, a2, 23, 0, "true", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  if ( v12 & 8 && *(_DWORD *)(v11 + 56) & 0x8026 )
  {
    if ( *(_WORD *)(v11 + 24) & 0x40 )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE71C(a1, a2, 24, 0, "true", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else if ( *(_WORD *)(v11 + 24) & 0x80 )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE71C(a1, a2, 24, 0, "false", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  if ( v12 & 0x10 )
  {
    if ( *(_WORD *)(v11 + 24) & 8 )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE71C(a1, a2, 26, 0, "current", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else if ( *(_WORD *)(v11 + 24) & 0x10 )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_DE71C(a1, a2, 26, 0, "deprecated", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else
    {
      if ( *(_WORD *)(v11 + 24) & 0x20 )
      {
        sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
        v15 = "obsolete";
      }
      sub_DE71C(a1, a2, 26, 0, v15, v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  if ( v12 & 0x20 && *(_QWORD *)(v11 + 8) )
  {
    sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
    sub_DE71C(a1, a2, 6, 0, *(const char **)(v11 + 8), v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
  }
  result = v12 & 0x40;
  if ( v12 & 0x40 )
  {
    result = *(_QWORD *)(v11 + 16);
    if ( result )
    {
      sub_DE4D3(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      result = sub_DE71C(a1, a2, 15, 0, *(const char **)(v11 + 16), v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000DF01A) ----------------------------------------------------
unsigned __int64 __fastcall sub_DF01A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST08_8
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v10; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v11; // [rsp+28h] [rbp-8h]

  v6 = (__int64)a3;
  v11 = __readfsqword(0x28u);
  v10 = 0;
  sub_C1FF7(a1, "%*sfeature %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  sub_DEA7A(a1, a2 + 1, v6, *(_QWORD *)(v6 + 48), &v10, 115LL);
  sub_DE519(a1, a2, v10, a2, v7, v8);
  return __readfsqword(0x28u) ^ v11;
}

//----- (00000000000DF0C8) ----------------------------------------------------
unsigned __int64 __fastcall sub_DF0C8(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  const char *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v17; // [rsp+8h] [rbp-38h]
  unsigned int v18; // [rsp+14h] [rbp-2Ch]
  unsigned int v19; // [rsp+2Ch] [rbp-14h]
  unsigned int v20; // [rsp+30h] [rbp-10h]
  int i; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v22; // [rsp+38h] [rbp-8h]

  v17 = (__int64)a3;
  v22 = __readfsqword(0x28u);
  v19 = 0;
  v20 = 0;
  sub_C1FF7(a1, "%*sextension %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v18 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v17, *(_QWORD *)(v17 + 48), &v19, 1LL);
  if ( *(_QWORD *)(v17 + 40) )
  {
    sub_DE4D3(a1, &v19, (__int64)&v19, v6, v7, v8);
    sub_C1FF7(a1, "%*sargument %s", 2 * v18, (__int64)&unk_127230, *(_QWORD *)(v17 + 40), v9);
    for ( i = -1; ; sub_E6059(a1, a2 + 2, *(_QWORD *)(v17 + 48), 1, 0, *(_QWORD *)(v17 + 32) + 8LL * i, 1u) )
    {
      i = sub_9EAFC(*(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26), (unsigned __int8)i + 1, 1);
      if ( i == -1 )
        break;
      sub_DE4D3(a1, &v20, (__int64)&v20, v10, v11, v12);
    }
    if ( *(_WORD *)(v17 + 24) & 1 || (unsigned int)sub_9EAFC(*(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26), 0, 22) != -1 )
    {
      sub_DE4D3(a1, &v20, (__int64)&v20, v10, v11, v12);
      if ( *(_WORD *)(v17 + 24) & 1 )
        v13 = "true";
      else
        v13 = "false";
      sub_DE71C(a1, a2 + 2, 22, 0, v13, *(_QWORD *)(v17 + 48), *(_QWORD *)(v17 + 32), *(_BYTE *)(v17 + 26));
    }
    sub_DE519(a1, v18, v20, v18, v11, v12);
  }
  sub_DEA7A(a1, v18, v17, *(_QWORD *)(v17 + 48), &v19, 112LL);
  sub_DE519(a1, a2, v19, a2, v14, v15);
  return __readfsqword(0x28u) ^ v22;
}

//----- (00000000000DF35D) ----------------------------------------------------
unsigned __int64 __fastcall sub_DF35D(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // ST10_8
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v15; // [rsp+10h] [rbp-30h]
  __int64 v16; // [rsp+18h] [rbp-28h]
  unsigned int v17; // [rsp+24h] [rbp-1Ch]
  unsigned int v18; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v19; // [rsp+38h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v19 = __readfsqword(0x28u);
  v18 = 0;
  sub_C1FF7(a1, "%*s%s \"", 2 * a2, (__int64)&unk_127230, a5, a6, a6, a5);
  sub_DE34B(a1, v6, -1);
  sub_C1FF7(a1, (const char *)&unk_127259, v7, v8, v9, v10);
  v17 = a2 + 1;
  if ( *(_BYTE *)(v15 + 48) )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v11, v12, v13);
    sub_E6059(a1, v17, v16, 0, 0, *(_QWORD *)(v15 + 40), *(unsigned __int8 *)(v15 + 48));
  }
  if ( **(_BYTE **)v15 == 21 )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v11, v12, v13);
    sub_DE71C(a1, v17, 20, 0, "invert-match", v16, *(_QWORD *)(v15 + 40), *(_BYTE *)(v15 + 48));
  }
  if ( *(_QWORD *)(v15 + 32) )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v11, v12, v13);
    sub_DE71C(a1, v17, 8, 0, *(const char **)(v15 + 32), v16, *(_QWORD *)(v15 + 40), *(_BYTE *)(v15 + 48));
  }
  if ( *(_QWORD *)(v15 + 24) )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v11, v12, v13);
    sub_DE71C(a1, v17, 7, 0, *(const char **)(v15 + 24), v16, *(_QWORD *)(v15 + 40), *(_BYTE *)(v15 + 48));
  }
  if ( *(_QWORD *)(v15 + 8) )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v11, v12, v13);
    sub_DE71C(a1, v17, 6, 0, *(const char **)(v15 + 8), v16, *(_QWORD *)(v15 + 40), *(_BYTE *)(v15 + 48));
  }
  if ( *(_QWORD *)(v15 + 16) )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v11, v12, v13);
    sub_DE71C(a1, v17, 15, 0, *(const char **)(v15 + 16), v16, *(_QWORD *)(v15 + 40), *(_BYTE *)(v15 + 48));
  }
  sub_DE519(a1, a2, v18, a2, v12, v13);
  return __readfsqword(0x28u) ^ v19;
}

//----- (00000000000DF66E) ----------------------------------------------------
unsigned __int64 __fastcall sub_DF66E(__int64 a1, unsigned int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  const char **v16; // [rsp+0h] [rbp-40h]
  __int64 v17; // [rsp+0h] [rbp-40h]
  __int64 *v18; // [rsp+8h] [rbp-38h]
  unsigned int v19; // [rsp+14h] [rbp-2Ch]
  unsigned int v20; // [rsp+2Ch] [rbp-14h]
  const char *v21; // [rsp+30h] [rbp-10h]
  unsigned __int64 v22; // [rsp+38h] [rbp-8h]

  v18 = a3;
  v16 = a4;
  v22 = __readfsqword(0x28u);
  v20 = 0;
  v21 = (const char *)sub_9182(a3, *a4);
  if ( v21 )
  {
    sub_C1FF7(a1, "%*swhen \"", 2 * a2, (__int64)&unk_127230, v6, v7, v16);
    sub_DE34B(a1, v21, -1);
    sub_C1FF7(a1, (const char *)&unk_127259, v8, v9, v10, v11);
    lydict_remove(*v18, v21);
    v19 = a2 + 1;
    if ( *(_BYTE *)(v17 + 32) )
    {
      sub_DE4D3(a1, &v20, (__int64)&v20, v12, v13, v14);
      sub_E6059(a1, v19, (__int64)v18, 0, 0, *(_QWORD *)(v17 + 24), *(unsigned __int8 *)(v17 + 32));
    }
    if ( *(_QWORD *)(v17 + 8) )
    {
      sub_DE4D3(a1, &v20, (__int64)&v20, v12, v13, v14);
      sub_DE71C(a1, v19, 6, 0, *(const char **)(v17 + 8), (__int64)v18, *(_QWORD *)(v17 + 24), *(_BYTE *)(v17 + 32));
    }
    if ( *(_QWORD *)(v17 + 16) )
    {
      sub_DE4D3(a1, &v20, (__int64)&v20, v12, v13, v14);
      sub_DE71C(a1, v19, 15, 0, *(const char **)(v17 + 16), (__int64)v18, *(_QWORD *)(v17 + 24), *(_BYTE *)(v17 + 32));
    }
    sub_DE519(a1, a2, v20, a2, v13, v14);
  }
  else
  {
    sub_C1FF7(a1, "(!error!)", v4, v5, v6, v7, v16, v18);
  }
  return __readfsqword(0x28u) ^ v22;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000DF89A) ----------------------------------------------------
unsigned __int64 __fastcall sub_DF89A(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8)
{
  __int64 v8; // r9
  __int64 v10; // [rsp+8h] [rbp-38h]
  __int64 *v11; // [rsp+10h] [rbp-30h]
  unsigned __int8 v12; // [rsp+1Ch] [rbp-24h]
  int v13; // [rsp+20h] [rbp-20h]
  char *ptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v15; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a5;
  v10 = a6;
  v12 = a4;
  v15 = __readfsqword(0x28u);
  if ( asprintf(&ptr, off_1272F0, a8) == -1 )
  {
    sub_12222(*v11, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_print_unsigned", v8);
  }
  else
  {
    sub_DE71C(a1, a2, v13, v12, ptr, (__int64)v11, v10, a7);
    free(ptr);
  }
  return __readfsqword(0x28u) ^ v15;
}

//----- (00000000000DF961) ----------------------------------------------------
unsigned __int64 __fastcall sub_DF961(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8)
{
  __int64 v8; // r9
  __int64 v10; // [rsp+8h] [rbp-38h]
  __int64 *v11; // [rsp+10h] [rbp-30h]
  unsigned __int8 v12; // [rsp+1Ch] [rbp-24h]
  int v13; // [rsp+20h] [rbp-20h]
  char *ptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v15; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a5;
  v10 = a6;
  v12 = a4;
  v15 = __readfsqword(0x28u);
  if ( asprintf(&ptr, "%d", a8) == -1 )
  {
    sub_12222(*v11, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_print_signed", v8);
  }
  else
  {
    sub_DE71C(a1, a2, v13, v12, ptr, (__int64)v11, v10, a7);
    free(ptr);
  }
  return __readfsqword(0x28u) ^ v15;
}

//----- (00000000000DFA28) ----------------------------------------------------
unsigned __int64 __fastcall sub_DFA28(__int64 a1, int a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 v24; // rbx
  __int64 v25; // rax
  __int64 v26; // r9
  __int64 v27; // rcx
  __int64 v29; // [rsp+0h] [rbp-60h]
  __int64 v30; // [rsp+0h] [rbp-60h]
  __int64 *v31; // [rsp+8h] [rbp-58h]
  unsigned int v32; // [rsp+14h] [rbp-4Ch]
  int v33; // [rsp+14h] [rbp-4Ch]
  int v34; // [rsp+14h] [rbp-4Ch]
  unsigned int v35; // [rsp+24h] [rbp-3Ch]
  unsigned int v36; // [rsp+28h] [rbp-38h]
  unsigned int i; // [rsp+2Ch] [rbp-34h]
  char *ptr; // [rsp+30h] [rbp-30h]
  const char *v39; // [rsp+38h] [rbp-28h]
  __int64 v40; // [rsp+40h] [rbp-20h]
  unsigned __int64 v41; // [rsp+48h] [rbp-18h]

  v31 = a3;
  v29 = a4;
  v41 = __readfsqword(0x28u);
  v35 = 0;
  if ( (unsigned int)sub_A6074(a4) )
  {
    sub_C1FF7(a1, "%*stype %s", (unsigned int)(2 * a2), (__int64)&unk_127230, **(_QWORD **)(v29 + 16), v4, v29);
  }
  else
  {
    v5 = **(_QWORD **)(v29 + 16);
    v6 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v29 + 16) + 48LL));
    v7 = sub_831C((__int64)v31, *(const char **)(v6 + 8));
    sub_C1FF7(a1, "%*stype %s:%s", (unsigned int)(2 * a2), (__int64)&unk_127230, v7, v5, v29);
  }
  v32 = a2 + 1;
  if ( *(_BYTE *)(v30 + 5) )
  {
    sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
    sub_E6059(a1, v32, (__int64)v31, 0, 0, *(_QWORD *)(v30 + 8), *(unsigned __int8 *)(v30 + 5));
  }
  switch ( *(_DWORD *)v30 )
  {
    case 1:
      if ( *(_QWORD *)(v30 + 32) )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DF35D(a1, v32, (__int64)v31, *(_QWORD *)(v30 + 32), (__int64)"length", **(_QWORD **)(v30 + 32));
      }
      goto LABEL_56;
    case 2:
      for ( i = 0; i < *(_DWORD *)(v30 + 40); ++i )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_C1FF7(a1, "%*sbit %s", 2 * v32, (__int64)&unk_127230, *(_QWORD *)(*(_QWORD *)(v30 + 32) + 48LL * i), v11);
        v36 = 0;
        v33 = v32 + 1;
        sub_DEA7A(a1, v33, *(_QWORD *)(v30 + 32) + 48LL * i, (__int64)v31, &v36, 3LL);
        v14 = *(_QWORD *)(v30 + 32);
        if ( !(*(_WORD *)(v14 + 48LL * i + 24) & 1) )
        {
          sub_DE4D3(a1, &v36, (__int64)&v36, v14, v12, v13);
          sub_DF89A(
            a1,
            v33,
            30LL,
            0LL,
            v31,
            *(_QWORD *)(*(_QWORD *)(v30 + 32) + 48LL * i + 32),
            *(unsigned __int8 *)(*(_QWORD *)(v30 + 32) + 48LL * i + 26),
            *(_DWORD *)(*(_QWORD *)(v30 + 32) + 48LL * i + 28));
        }
        sub_DEA7A(a1, v33, *(_QWORD *)(v30 + 32) + 48LL * i, (__int64)v31, &v36, 112LL);
        v32 = v33 - 1;
        sub_DE519(a1, v32, v36, v32, v15, v16);
      }
      goto LABEL_56;
    case 4:
      if ( !*(_QWORD *)(*(_QWORD *)(v30 + 16) + 72LL) )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DF89A(
          a1,
          v32,
          27LL,
          0LL,
          v31,
          *(_QWORD *)(v30 + 8),
          *(unsigned __int8 *)(v30 + 5),
          *(unsigned __int8 *)(v30 + 40));
      }
      if ( *(_QWORD *)(v30 + 32) )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DF35D(a1, v32, (__int64)v31, *(_QWORD *)(v30 + 32), (__int64)"range", **(_QWORD **)(v30 + 32));
      }
      goto LABEL_56;
    case 6:
      for ( i = 0; i < *(_DWORD *)(v30 + 40); ++i )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_C1FF7(
          a1,
          "%*senum \"%s\"",
          2 * v32,
          (__int64)&unk_127230,
          *(_QWORD *)(*(_QWORD *)(v30 + 32) + 48LL * i),
          v17);
        v36 = 0;
        v34 = v32 + 1;
        sub_DEA7A(a1, v34, *(_QWORD *)(v30 + 32) + 48LL * i, (__int64)v31, &v36, 3LL);
        v20 = *(_QWORD *)(v30 + 32);
        if ( !(*(_WORD *)(v20 + 48LL * i + 24) & 1) )
        {
          sub_DE4D3(a1, &v36, (__int64)&v36, v20, v18, v19);
          sub_DF961(
            a1,
            v34,
            18LL,
            0LL,
            v31,
            *(_QWORD *)(*(_QWORD *)(v30 + 32) + 48LL * i + 32),
            *(unsigned __int8 *)(*(_QWORD *)(v30 + 32) + 48LL * i + 26),
            *(_DWORD *)(*(_QWORD *)(v30 + 32) + 48LL * i + 28));
        }
        sub_DEA7A(a1, v34, *(_QWORD *)(v30 + 32) + 48LL * i, (__int64)v31, &v36, 112LL);
        v32 = v34 - 1;
        sub_DE519(a1, v32, v36, v32, v21, v22);
      }
      goto LABEL_56;
    case 7:
      if ( !*(_DWORD *)(v30 + 40) )
        goto LABEL_56;
      sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
      i = 0;
      break;
    case 8:
      if ( *(_BYTE *)(v30 + 32) == 1 )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DE71C(a1, v32, 21, 0, "true", (__int64)v31, *(_QWORD *)(v30 + 8), *(_BYTE *)(v30 + 5));
      }
      else if ( *(_BYTE *)(v30 + 32) == -1 )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DE71C(a1, v32, 21, 0, "false", (__int64)v31, *(_QWORD *)(v30 + 8), *(_BYTE *)(v30 + 5));
      }
      goto LABEL_56;
    case 9:
      if ( (unsigned int)sub_C462(**(_BYTE ***)(v30 + 16), "leafref") )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v27, v9, v10);
        v39 = (const char *)sub_9182(v31, *(const char **)(v30 + 32));
        sub_DE71C(a1, v32, 12, 0, v39, (__int64)v31, *(_QWORD *)(v30 + 8), *(_BYTE *)(v30 + 5));
        lydict_remove(*v31, v39);
      }
      if ( *(_BYTE *)(v30 + 48) == 1 )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v27, v9, v10);
        sub_DE71C(a1, v32, 21, 0, "true", (__int64)v31, *(_QWORD *)(v30 + 8), *(_BYTE *)(v30 + 5));
      }
      else if ( *(_BYTE *)(v30 + 48) == -1 )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v27, v9, v10);
        sub_DE71C(a1, v32, 21, 0, "false", (__int64)v31, *(_QWORD *)(v30 + 8), *(_BYTE *)(v30 + 5));
      }
      goto LABEL_56;
    case 0xA:
      if ( *(_QWORD *)(v30 + 32) )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DF35D(a1, v32, (__int64)v31, *(_QWORD *)(v30 + 32), (__int64)"length", **(_QWORD **)(v30 + 32));
      }
      for ( i = 0; i < *(_DWORD *)(v30 + 48); ++i )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DF35D(
          a1,
          v32,
          (__int64)v31,
          56LL * i + *(_QWORD *)(v30 + 40),
          (__int64)"pattern",
          *(_QWORD *)(*(_QWORD *)(v30 + 40) + 56LL * i) + 1LL);
      }
      goto LABEL_56;
    case 0xB:
      for ( i = 0; i < *(_DWORD *)(v30 + 40); ++i )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DFA28(a1, v32, v31, *(_QWORD *)(v30 + 32) + ((unsigned __int64)i << 6));
      }
      goto LABEL_56;
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      if ( *(_QWORD *)(v30 + 32) )
      {
        sub_DE4D3(a1, &v35, (__int64)&v35, v8, v9, v10);
        sub_DF35D(a1, v32, (__int64)v31, *(_QWORD *)(v30 + 32), (__int64)"range", **(_QWORD **)(v30 + 32));
      }
      goto LABEL_56;
    default:
      goto LABEL_56;
  }
  while ( i < *(_DWORD *)(v30 + 40) )
  {
    v40 = lys_main_module(*(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v30 + 32)) + 48LL));
    v23 = lys_main_module(v31);
    if ( v40 == v23 )
    {
      sub_DE71C(
        a1,
        v32,
        2,
        0,
        **(const char ***)(8LL * i + *(_QWORD *)(v30 + 32)),
        (__int64)v31,
        *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v30 + 32)) + 32LL),
        *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v30 + 32)) + 26LL));
    }
    else
    {
      v24 = **(_QWORD **)(8LL * i + *(_QWORD *)(v30 + 32));
      v25 = sub_831C((__int64)v31, *(const char **)(v40 + 8));
      if ( asprintf(&ptr, "%s:%s", v25, v24) == -1 )
      {
        sub_12222(*v31, 0, 1, "Memory allocation failed (%s()).", (__int64)"yang_print_type", v26);
        return __readfsqword(0x28u) ^ v41;
      }
      sub_DE71C(
        a1,
        v32,
        2,
        0,
        ptr,
        (__int64)v31,
        *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v30 + 32)) + 32LL),
        *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v30 + 32)) + 26LL));
      free(ptr);
    }
    ++i;
  }
LABEL_56:
  sub_DE519(a1, v32 - 1, v35, v32 - 1, v9, v10);
  return __readfsqword(0x28u) ^ v41;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E0678) ----------------------------------------------------
signed __int64 __fastcall sub_E0678(__int64 a1, unsigned int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // [rsp+0h] [rbp-30h]
  __int64 *v10; // [rsp+8h] [rbp-28h]
  __int64 v11; // [rsp+28h] [rbp-8h]

  v10 = a3;
  v9 = (__int64)a4;
  v11 = sub_9182(a3, *a4);
  if ( !v11 )
    return sub_C1FF7(a1, "(!error!)", v4, v5, v6, v7, v9, v10);
  sub_DF35D(a1, a2, (__int64)v10, v9, (__int64)"must", v11);
  return lydict_remove(*v10, v11);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E0707) ----------------------------------------------------
signed __int64 __fastcall sub_E0707(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  __int64 v14; // [rsp+0h] [rbp-30h]
  __int64 *v15; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+24h] [rbp-Ch]
  __int64 v17; // [rsp+28h] [rbp-8h]

  v15 = a3;
  sub_C1FF7(a1, "%*sunique \"", (unsigned int)(2 * a2), (__int64)&unk_127230, a5, a6, a4);
  for ( i = 0; i < *(unsigned __int8 *)(v14 + 8); ++i )
  {
    v17 = sub_9182(v15, *(const char **)(8LL * i + *(_QWORD *)v14));
    if ( i + 1 >= *(unsigned __int8 *)(v14 + 8) )
      v12 = (const char *)&unk_127230;
    else
      v12 = " ";
    sub_C1FF7(a1, "%s%s", v17, (__int64)v12, v10, v11);
    lydict_remove(*v15, v17);
  }
  return sub_C1FF7(a1, (const char *)&unk_127259, v6, v7, v8, v9);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E0803) ----------------------------------------------------
unsigned __int64 __fastcall sub_E0803(__int64 a1, unsigned int a2, __int64 *a3, const char **a4)
{
  const char **v4; // ST10_8
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+0h] [rbp-40h]
  __int64 *v13; // [rsp+8h] [rbp-38h]
  unsigned int v14; // [rsp+14h] [rbp-2Ch]
  unsigned int v15; // [rsp+28h] [rbp-18h]
  int i; // [rsp+2Ch] [rbp-14h]
  __int64 v17; // [rsp+30h] [rbp-10h]
  unsigned __int64 v18; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v4 = a4;
  v18 = __readfsqword(0x28u);
  v15 = 0;
  v17 = sub_9182(a3, *a4);
  sub_C1FF7(a1, "%*srefine \"%s\"", 2 * a2, (__int64)&unk_127230, v17, v5, v4);
  lydict_remove(*v13, v17);
  v14 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v12, (__int64)v13, &v15, 3LL);
  for ( i = 0; i < *(unsigned __int8 *)(v12 + 30); ++i )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_E0678(a1, v14, v13, (const char **)(56LL * i + *(_QWORD *)(v12 + 56)));
  }
  if ( *(_WORD *)(v12 + 28) == 1 )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_DE71C(a1, v14, 14, 0, *(const char **)(v12 + 72), (__int64)v13, *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
  }
  for ( i = 0; i < *(unsigned __int8 *)(v12 + 31); ++i )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_DE71C(
      a1,
      v14,
      5,
      (unsigned __int8)i,
      *(const char **)(8LL * i + *(_QWORD *)(v12 + 64)),
      (__int64)v13,
      *(_QWORD *)(v12 + 32),
      *(_BYTE *)(v12 + 26));
  }
  if ( *(_WORD *)(v12 + 24) & 1 )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_DE71C(a1, v14, 23, 0, "true", (__int64)v13, *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
  }
  else if ( *(_WORD *)(v12 + 24) & 2 )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_DE71C(a1, v14, 23, 0, "false", (__int64)v13, *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
  }
  if ( *(_WORD *)(v12 + 24) & 0x40 )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_DE71C(a1, v14, 24, 0, "true", (__int64)v13, *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
  }
  else if ( *(_WORD *)(v12 + 24) & 0x80 )
  {
    sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
    sub_DE71C(a1, v14, 24, 0, "false", (__int64)v13, *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
  }
  if ( *(_WORD *)(v12 + 28) & 0x18 )
  {
    if ( *(_WORD *)(v12 + 24) & 0x10 )
    {
      sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
      sub_DF89A(a1, v14, 29LL, 0LL, v13, *(_QWORD *)(v12 + 32), *(unsigned __int8 *)(v12 + 26), *(_DWORD *)(v12 + 72));
    }
    if ( *(_WORD *)(v12 + 24) & 8 )
    {
      sub_DE4D3(a1, &v15, (__int64)&v15, v6, v7, v8);
      if ( *(_DWORD *)(v12 + 76) )
        sub_DF89A(a1, v14, 28LL, 0LL, v13, *(_QWORD *)(v12 + 32), *(unsigned __int8 *)(v12 + 26), *(_DWORD *)(v12 + 76));
      else
        sub_DE71C(a1, v14, 28, 0, "unbounded", (__int64)v13, *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
    }
  }
  sub_DEA7A(a1, v14, v12, (__int64)v13, &v15, 96LL);
  sub_DE519(a1, a2, v15, a2, v9, v10);
  return __readfsqword(0x28u) ^ v18;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E0D20) ----------------------------------------------------
signed __int64 __fastcall sub_E0D20(__int64 a1, int a2, __int64 *a3, const char **a4)
{
  const char **v4; // ST10_8
  __int64 v5; // ST48_8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v24; // [rsp+0h] [rbp-40h]
  __int64 *v25; // [rsp+8h] [rbp-38h]
  int v26; // [rsp+14h] [rbp-2Ch]
  int v27; // [rsp+14h] [rbp-2Ch]
  signed int i; // [rsp+2Ch] [rbp-14h]
  signed int j; // [rsp+30h] [rbp-10h]
  signed int k; // [rsp+30h] [rbp-10h]
  signed int l; // [rsp+30h] [rbp-10h]
  int v32; // [rsp+34h] [rbp-Ch]

  v25 = a3;
  v4 = a4;
  v5 = sub_9182(a3, *a4);
  sub_C1FF7(a1, "%*sdeviation \"%s\" {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v5, v6, v4);
  lydict_remove(*v25, v5);
  v26 = a2 + 1;
  if ( *(_BYTE *)(v24 + 33) )
    sub_E6059(a1, v26, (__int64)v25, 0, 0, *(_QWORD *)(v24 + 48), *(unsigned __int8 *)(v24 + 33));
  sub_DE71C(a1, v26, 6, 0, *(const char **)(v24 + 8), (__int64)v25, *(_QWORD *)(v24 + 48), *(_BYTE *)(v24 + 33));
  sub_DE71C(a1, v26, 15, 0, *(const char **)(v24 + 16), (__int64)v25, *(_QWORD *)(v24 + 48), *(_BYTE *)(v24 + 33));
  for ( i = 0; i < *(unsigned __int8 *)(v24 + 32); ++i )
  {
    sub_C1FF7(a1, "%*sdeviate ", (unsigned int)(2 * v26), (__int64)&unk_127230, v7, v8);
    if ( *(_DWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i) )
    {
      v12 = *(_QWORD *)(v24 + 40);
      if ( *(_DWORD *)(v12 + 72LL * i) == 1 )
      {
        sub_C1FF7(a1, "add {\n", i, v12, v9, v10);
      }
      else
      {
        v13 = *(_QWORD *)(v24 + 40);
        if ( *(_DWORD *)(v13 + 72LL * i) == 2 )
        {
          sub_C1FF7(a1, "replace {\n", i, v13, v9, v10);
        }
        else
        {
          v14 = *(_QWORD *)(v24 + 40);
          if ( *(_DWORD *)(v14 + 72LL * i) == 3 )
            sub_C1FF7(a1, "delete {\n", i, v14, v9, v10);
        }
      }
    }
    else
    {
      v11 = *(_QWORD *)(v24 + 40);
      if ( !*(_BYTE *)(v11 + 72LL * i + 6) )
      {
        sub_C1FF7(a1, "not-supported;\n", i, v11, v9, v10);
        continue;
      }
      sub_C1FF7(a1, "not-supported {\n", i, v11, v9, v10);
    }
    v27 = v26 + 1;
    if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6) )
      sub_E6059(
        a1,
        v27,
        (__int64)v25,
        0,
        0,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
        *(unsigned __int8 *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    if ( *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 40) )
      sub_DFA28(a1, v27, v25, *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 40));
    sub_DE71C(
      a1,
      v27,
      17,
      0,
      *(const char **)(*(_QWORD *)(v24 + 40) + 72LL * i + 48),
      (__int64)v25,
      *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
      *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    for ( j = 0; j < *(unsigned __int8 *)(*(_QWORD *)(v24 + 40) + 72LL * i + 9); ++j )
      sub_E0678(a1, v27, v25, (const char **)(56LL * j + *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 24)));
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(v24 + 40) + 72LL * i + 10); ++k )
    {
      sub_E0707(a1, v27, v25, *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 32) + 16LL * k, v15, v16);
      LOBYTE(v32) = -1;
      do
      {
        v32 = sub_9EAFC(
                *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
                *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6),
                (unsigned __int8)v32 + 1,
                31);
        if ( v32 == -1 )
          break;
        v18 = *(_QWORD *)(v24 + 40);
        v17 = 8LL * v32;
      }
      while ( k != *(unsigned __int8 *)(*(_QWORD *)(v17 + *(_QWORD *)(v18 + 72LL * i + 64)) + 27LL) );
      if ( v32 == -1 )
      {
        sub_C1FF7(a1, ";\n", v17, v18, v19, v20);
      }
      else
      {
        sub_C1FF7(a1, (const char *)&off_12722C, v17, v18, v19, v20);
        do
        {
          sub_E6059(
            a1,
            v27 + 1,
            (__int64)v25,
            31,
            k,
            *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64) + 8LL * v32,
            1u);
          do
            v32 = sub_9EAFC(
                    *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
                    *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6),
                    (unsigned __int8)v32 + 1,
                    31);
          while ( v32 != -1
               && k != *(unsigned __int8 *)(*(_QWORD *)(8LL * v32 + *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64))
                                          + 27LL) );
        }
        while ( v32 != -1 );
        sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * v27), (__int64)&unk_127230, v21, v22);
      }
    }
    for ( l = 0; l < *(unsigned __int8 *)(*(_QWORD *)(v24 + 40) + 72LL * i + 5); ++l )
      sub_DE71C(
        a1,
        v27,
        5,
        (unsigned __int8)l,
        *(const char **)(8LL * l + *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 56)),
        (__int64)v25,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
        *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 4) & 1 )
    {
      sub_DE71C(
        a1,
        v27,
        23,
        0,
        "true",
        (__int64)v25,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 64LL),
        *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    }
    else if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 4) & 2 )
    {
      sub_DE71C(
        a1,
        v27,
        23,
        0,
        "false",
        (__int64)v25,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 64LL),
        *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    }
    if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 4) & 0x40 )
    {
      sub_DE71C(
        a1,
        v27,
        24,
        0,
        "true",
        (__int64)v25,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
        *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    }
    else if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 4) < 0 )
    {
      sub_DE71C(
        a1,
        v27,
        24,
        0,
        "false",
        (__int64)v25,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
        *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    }
    if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 7) )
      sub_DF89A(
        a1,
        v27,
        29LL,
        0LL,
        v25,
        *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
        *(unsigned __int8 *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6),
        *(_DWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 12));
    if ( *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 8) )
    {
      if ( *(_DWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 16) )
        sub_DF89A(
          a1,
          v27,
          28LL,
          0LL,
          v25,
          *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
          *(unsigned __int8 *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6),
          *(_DWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 16));
      else
        sub_DE71C(
          a1,
          v27,
          28,
          0,
          "unbounded",
          (__int64)v25,
          *(_QWORD *)(*(_QWORD *)(v24 + 40) + 72LL * i + 64),
          *(_BYTE *)(*(_QWORD *)(v24 + 40) + 72LL * i + 6));
    }
    v26 = v27 - 1;
    sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * v26), (__int64)&unk_127230, v15, v16);
  }
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * (v26 - 1)), (__int64)&unk_127230, v7, v8);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);
// 12722C: using guessed type void *__ptr32 off_12722C;

//----- (00000000000E1A74) ----------------------------------------------------
signed __int64 __fastcall sub_E1A74(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // ST28_8
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // [rsp+8h] [rbp-28h]
  int v9; // [rsp+14h] [rbp-1Ch]
  __int64 i; // [rsp+20h] [rbp-10h]

  v8 = a3;
  v3 = sub_9182(*(__int64 **)(a3 + 48), *(const char **)a3);
  sub_C1FF7(a1, "%*saugment \"%s\" {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v3, v4);
  lydict_remove(**(_QWORD **)(v8 + 48), v3);
  v9 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v8, *(_QWORD *)(v8 + 48), 0LL, 1LL);
  if ( *(_QWORD *)(v8 + 80) )
    sub_DF66E(a1, v9, *(__int64 **)(v8 + 48), *(const char ***)(v8 + 80));
  sub_DEA7A(a1, v9, v8, *(_QWORD *)(v8 + 48), 0LL, 114LL);
  for ( i = *(_QWORD *)(v8 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( v8 == *(_QWORD *)(i + 64) )
      sub_E479A(a1, v9, i, 53503LL, v5, v6);
  }
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v5, v6);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E1BDF) ----------------------------------------------------
signed __int64 __fastcall sub_E1BDF(__int64 a1, int a2, __int64 *a3, __int64 *a4, __int64 a5, __int64 a6)
{
  char *v6; // rax
  char *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // [rsp+0h] [rbp-30h]
  __int64 *v12; // [rsp+8h] [rbp-28h]
  int v13; // [rsp+14h] [rbp-1Ch]
  const char *v14; // [rsp+28h] [rbp-8h]

  v12 = a3;
  sub_C1FF7(a1, "%*stypedef %s {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, *a4, a6, a4);
  v13 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v11, (__int64)v12, 0LL, 1LL);
  sub_DFA28(a1, a2 + 1, v12, v11 + 56);
  if ( *(_QWORD *)(v11 + 40) )
    sub_DE71C(a1, v13, 17, 0, *(const char **)(v11 + 40), (__int64)v12, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
  if ( *(_QWORD *)(v11 + 120) )
  {
    if ( *(_WORD *)(v11 + 24) & 0x1000 )
    {
      if ( !strchr(*(const char **)(v11 + 120), 58) )
        __assert_fail(
          "strchr(tpdf->dflt, ':')",
          "/home/mantovan/Repositories/libyang/src/printer_yang.c",
          0x380u,
          "yang_print_typedef");
      v6 = strchr(*(const char **)(v11 + 120), 58);
      if ( !strncmp(*(const char **)(v11 + 120), (const char *)v12[1], (size_t)&v6[-*(_QWORD *)(v11 + 120)]) )
      {
        v7 = strchr(*(const char **)(v11 + 120), 58);
        v14 = (const char *)lydict_insert(*v12, v7 + 1, 0LL);
      }
      else
      {
        v14 = (const char *)sub_9182(v12, *(const char **)(v11 + 120));
      }
      sub_DE71C(a1, v13, 5, 0, v14, (__int64)v12, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else
    {
      v14 = *(const char **)(v11 + 120);
      sub_DE71C(a1, v13, 5, 0, v14, (__int64)v12, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    if ( *(_WORD *)(v11 + 24) & 0x1000 )
      lydict_remove(*v12, v14);
  }
  sub_DEA7A(a1, v13, v11, (__int64)v12, 0LL, 112LL);
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v8, v9);
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E1E7A) ----------------------------------------------------
unsigned __int64 __fastcall sub_E1E7A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+8h] [rbp-48h]
  int v17; // [rsp+14h] [rbp-3Ch]
  unsigned int v18; // [rsp+20h] [rbp-30h]
  int i; // [rsp+24h] [rbp-2Ch]
  char *ptr; // [rsp+28h] [rbp-28h]
  __int64 v21; // [rsp+30h] [rbp-20h]
  unsigned __int64 v22; // [rsp+38h] [rbp-18h]

  v16 = (__int64)a3;
  v22 = __readfsqword(0x28u);
  v18 = 0;
  sub_C1FF7(a1, "%*sidentity %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v17 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v16, *(_QWORD *)(v16 + 48), &v18, 3LL);
  for ( i = 0; i < *(unsigned __int8 *)(v16 + 31); ++i )
  {
    sub_DE4D3(a1, &v18, (__int64)&v18, v6, v7, v8);
    v21 = lys_main_module(*(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v16 + 56)) + 48LL));
    v9 = lys_main_module(*(_QWORD *)(v16 + 48));
    if ( v21 == v9 )
    {
      sub_DE71C(
        a1,
        v17,
        2,
        (unsigned __int8)i,
        **(const char ***)(8LL * i + *(_QWORD *)(v16 + 56)),
        *(_QWORD *)(v16 + 48),
        *(_QWORD *)(v16 + 32),
        *(_BYTE *)(v16 + 26));
    }
    else
    {
      v10 = **(_QWORD **)(8LL * i + *(_QWORD *)(v16 + 56));
      v11 = sub_831C(*(_QWORD *)(v16 + 48), *(const char **)(v21 + 8));
      if ( asprintf(&ptr, "%s:%s", v11, v10) == -1 )
      {
        sub_12222(
          **(_QWORD **)(v16 + 48),
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"yang_print_identity",
          v12);
        return __readfsqword(0x28u) ^ v22;
      }
      sub_DE71C(a1, v17, 2, (unsigned __int8)i, ptr, *(_QWORD *)(v16 + 48), *(_QWORD *)(v16 + 32), *(_BYTE *)(v16 + 26));
      free(ptr);
    }
  }
  sub_DEA7A(a1, v17, v16, *(_QWORD *)(v16 + 48), &v18, 112LL);
  sub_DE519(a1, a2, v18, a2, v13, v14);
  return __readfsqword(0x28u) ^ v22;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000E2106) ----------------------------------------------------
unsigned __int64 __fastcall sub_E2106(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 *v25; // [rsp+8h] [rbp-38h]
  unsigned int v26; // [rsp+14h] [rbp-2Ch]
  unsigned int v27; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 *v30; // [rsp+30h] [rbp-10h]
  unsigned __int64 v31; // [rsp+38h] [rbp-8h]

  v25 = a3;
  v31 = __readfsqword(0x28u);
  v27 = 0;
  v30 = a3;
  sub_C1FF7(a1, "%*scontainer %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v26 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v25, v25[6], &v27, 1LL);
  if ( v30[14] )
  {
    sub_DE4D3(a1, &v27, (__int64)&v27, v6, v7, v8);
    sub_DF66E(a1, v26, (__int64 *)v25[6], (const char **)v30[14]);
  }
  for ( i = 0; i < *((unsigned __int8 *)v30 + 27); ++i )
  {
    sub_DE4D3(a1, &v27, (__int64)&v27, v6, v7, v8);
    sub_DE97F(a1, v26, v25[6], v30[5] + 32LL * i, v9, v10);
  }
  for ( i = 0; i < *((unsigned __int8 *)v30 + 29); ++i )
  {
    sub_DE4D3(a1, &v27, (__int64)&v27, v6, v7, v8);
    sub_E0678(a1, v26, (__int64 *)v25[6], (const char **)(56LL * i + v30[15]));
  }
  if ( v30[17] )
  {
    sub_DE4D3(a1, &v27, (__int64)&v27, v6, v7, v8);
    sub_DE71C(a1, v26, 14, 0, (const char *)v30[17], v25[6], v25[4], *((_BYTE *)v25 + 26));
  }
  sub_DEA7A(a1, v26, (__int64)v25, v25[6], &v27, 116LL);
  for ( i = 0; i < *((unsigned __int16 *)v30 + 15); ++i )
  {
    sub_DE4D3(a1, &v27, (__int64)&v27, v11, v12, v13);
    sub_E1BDF(a1, v26, (__int64 *)v25[6], (__int64 *)(v30[16] + ((signed __int64)i << 7)), v14, v15);
  }
  for ( j = v25[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v25 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v27, (__int64)&v27, v11, v12, v13);
      sub_E479A(a1, v26, j, 2048LL, v16, v17);
    }
  }
  for ( j = v25[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v25 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v27, (__int64)&v27, v11, v12, v13);
      sub_E479A(a1, v26, j, 36927LL, v18, v19);
    }
  }
  for ( j = v25[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v25 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v27, (__int64)&v27, v11, v12, v13);
      sub_E479A(a1, v26, j, 0x4000LL, v20, v21);
    }
  }
  for ( j = v25[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v25 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v27, (__int64)&v27, v11, v12, v13);
      sub_E479A(a1, v26, j, 128LL, v22, v23);
    }
  }
  sub_DE519(a1, a2, v27, a2, v12, v13);
  return __readfsqword(0x28u) ^ v31;
}

//----- (00000000000E252D) ----------------------------------------------------
unsigned __int64 __fastcall sub_E252D(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+8h] [rbp-38h]
  unsigned int v13; // [rsp+14h] [rbp-2Ch]
  unsigned int v14; // [rsp+24h] [rbp-1Ch]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 v16; // [rsp+30h] [rbp-10h]
  unsigned __int64 v17; // [rsp+38h] [rbp-8h]

  v13 = a2;
  v12 = a3;
  v17 = __readfsqword(0x28u);
  v14 = 0;
  v16 = a3;
  if ( *(_WORD *)(a3 + 24) & 0x40 )
  {
    v14 = 1;
  }
  else
  {
    sub_C1FF7(a1, "%*scase %s", 2 * a2, (__int64)&unk_127230, *(_QWORD *)v16, a6);
    v13 = a2 + 1;
    sub_DEA7A(a1, a2 + 1, v12, *(_QWORD *)(v12 + 48), &v14, 1LL);
    if ( *(_QWORD *)(v16 + 104) )
    {
      sub_DE4D3(a1, &v14, (__int64)&v14, v6, v7, v8);
      sub_DF66E(a1, v13, *(__int64 **)(v12 + 48), *(const char ***)(v16 + 104));
    }
    sub_DEA7A(a1, v13, v12, *(_QWORD *)(v12 + 48), &v14, 114LL);
  }
  for ( i = *(_QWORD *)(v12 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( v12 == *(_QWORD *)(i + 64) )
    {
      sub_DE4D3(a1, &v14, (__int64)&v14, a4, a5, a6);
      sub_E479A(a1, v13, i, 36927LL, v9, v10);
    }
  }
  if ( !(*(_WORD *)(v12 + 24) & 0x40) )
    sub_DE519(a1, v13 - 1, v14, v13 - 1, a5, a6);
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000E26DF) ----------------------------------------------------
unsigned __int64 __fastcall sub_E26DF(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 *v17; // [rsp+8h] [rbp-38h]
  unsigned int v18; // [rsp+14h] [rbp-2Ch]
  unsigned int v19; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 *v22; // [rsp+30h] [rbp-10h]
  unsigned __int64 v23; // [rsp+38h] [rbp-8h]

  v17 = a3;
  v23 = __readfsqword(0x28u);
  v19 = 0;
  v22 = a3;
  sub_C1FF7(a1, "%*schoice %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v18 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v17, v17[6], &v19, 1LL);
  if ( v22[13] )
  {
    sub_DE4D3(a1, &v19, (__int64)&v19, v6, v7, v8);
    sub_DF66E(a1, v18, (__int64 *)v17[6], (const char **)v22[13]);
  }
  for ( i = 0; i < *((unsigned __int8 *)v22 + 27); ++i )
  {
    sub_DE4D3(a1, &v19, (__int64)&v19, v6, v7, v8);
    sub_DE97F(a1, v18, v17[6], v22[5] + 32LL * i, v9, v10);
  }
  if ( v22[14] )
  {
    sub_DE4D3(a1, &v19, (__int64)&v19, v6, v7, v8);
    sub_DE71C(a1, v18, 5, 0, *(const char **)v22[14], v17[6], v17[4], *((_BYTE *)v17 + 26));
  }
  sub_DEA7A(a1, v18, (__int64)v17, v17[6], &v19, 124LL);
  for ( j = v17[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v17 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v19, (__int64)&v19, v11, v12, v13);
      sub_E479A(a1, v18, j, 32895LL, v14, v15);
    }
  }
  sub_DE519(a1, a2, v19, a2, v12, v13);
  return __readfsqword(0x28u) ^ v23;
}

//----- (00000000000E2926) ----------------------------------------------------
signed __int64 __fastcall sub_E2926(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  char *v8; // rbx
  __int64 v9; // rax
  char *v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 *v14; // [rsp+8h] [rbp-48h]
  int v15; // [rsp+14h] [rbp-3Ch]
  signed int i; // [rsp+2Ch] [rbp-24h]
  signed int j; // [rsp+2Ch] [rbp-24h]
  const char *v18; // [rsp+30h] [rbp-20h]
  __int64 *v19; // [rsp+38h] [rbp-18h]

  v14 = a3;
  v19 = a3;
  sub_C1FF7(a1, "%*sleaf %s {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, *a3, a6);
  v15 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v14, v14[6], 0LL, 1LL);
  if ( v19[14] )
    sub_DF66E(a1, v15, (__int64 *)v14[6], (const char **)v19[14]);
  for ( i = 0; i < *((unsigned __int8 *)v19 + 27); ++i )
    sub_DE97F(a1, v15, v14[6], v19[5] + 32LL * i, v6, v7);
  sub_DFA28(a1, v15, (__int64 *)v14[6], (__int64)(v19 + 16));
  sub_DE71C(a1, v15, 17, 0, (const char *)v19[24], v14[6], v14[4], *((_BYTE *)v14 + 26));
  for ( j = 0; j < *((unsigned __int8 *)v19 + 31); ++j )
    sub_E0678(a1, v15, (__int64 *)v14[6], (const char **)(56LL * j + v19[15]));
  if ( v19[25] )
  {
    if ( v19[3] & 0x1000 )
    {
      if ( !strchr((const char *)v19[25], 58) )
        __assert_fail(
          "strchr(leaf->dflt, ':')",
          "/home/mantovan/Repositories/libyang/src/printer_yang.c",
          0x470u,
          "yang_print_leaf");
      v8 = &strchr((const char *)v19[25], 58)[-v19[25]];
      v9 = lys_node_module(v14);
      if ( !strncmp((const char *)v19[25], *(const char **)(v9 + 8), (size_t)v8) )
      {
        v10 = strchr((const char *)v19[25], 58);
        v18 = (const char *)lydict_insert(*(_QWORD *)v14[6], v10 + 1, 0LL);
      }
      else
      {
        v18 = (const char *)sub_9182((__int64 *)v14[6], (const char *)v19[25]);
      }
      sub_DE71C(a1, v15, 5, 0, v18, v14[6], v14[4], *((_BYTE *)v14 + 26));
    }
    else
    {
      v18 = (const char *)v19[25];
      sub_DE71C(a1, v15, 5, 0, v18, v14[6], v14[4], *((_BYTE *)v14 + 26));
    }
    if ( v19[3] & 0x1000 )
      lydict_remove(*(_QWORD *)v14[6], v18);
  }
  sub_DEA7A(a1, v15, (__int64)v14, v14[6], 0LL, 124LL);
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v11, v12);
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E2CCF) ----------------------------------------------------
unsigned __int64 __fastcall sub_E2CCF(__int64 a1, unsigned int a2, __int64 a3)
{
  const char *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+8h] [rbp-38h]
  int v13; // [rsp+14h] [rbp-2Ch]
  unsigned int v14; // [rsp+28h] [rbp-18h]
  int i; // [rsp+2Ch] [rbp-14h]
  __int64 v16; // [rsp+30h] [rbp-10h]
  unsigned __int64 v17; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v17 = __readfsqword(0x28u);
  v14 = 0;
  v16 = a3;
  if ( lys_parent(a3)
    || strcmp(*(const char **)v12, "config")
    || strcmp(*(const char **)(*(_QWORD *)(v12 + 48) + 8LL), "ietf-netconf") )
  {
    if ( *(_DWORD *)(v16 + 56) == 32 )
      v3 = "anyxml";
    else
      v3 = "anydata";
    sub_C1FF7(a1, "%*s%s %s", 2 * a2, (__int64)&unk_127230, (__int64)v3, *(_QWORD *)v16);
    v13 = a2 + 1;
    sub_DEA7A(a1, a2 + 1, v12, *(_QWORD *)(v12 + 48), &v14, 1LL);
    if ( *(_QWORD *)(v16 + 112) )
    {
      sub_DE4D3(a1, &v14, (__int64)&v14, v4, v5, v6);
      sub_DF66E(a1, v13, *(__int64 **)(v12 + 48), *(const char ***)(v16 + 112));
    }
    for ( i = 0; i < *(unsigned __int8 *)(v16 + 27); ++i )
    {
      sub_DE4D3(a1, &v14, (__int64)&v14, v4, v5, v6);
      sub_DE97F(a1, v13, *(_QWORD *)(v12 + 48), *(_QWORD *)(v16 + 40) + 32LL * i, v7, v8);
    }
    for ( i = 0; i < *(unsigned __int8 *)(v16 + 31); ++i )
    {
      sub_DE4D3(a1, &v14, (__int64)&v14, v4, v5, v6);
      sub_E0678(a1, v13, *(__int64 **)(v12 + 48), (const char **)(56LL * i + *(_QWORD *)(v16 + 120)));
    }
    sub_DEA7A(a1, v13, v12, *(_QWORD *)(v12 + 48), &v14, 124LL);
    sub_DE519(a1, a2, v14, a2, v9, v10);
  }
  return __readfsqword(0x28u) ^ v17;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000E2F1F) ----------------------------------------------------
signed __int64 __fastcall sub_E2F1F(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  char *v8; // rbx
  __int64 v9; // rax
  char *v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 *v14; // [rsp+8h] [rbp-48h]
  int v15; // [rsp+14h] [rbp-3Ch]
  signed int i; // [rsp+2Ch] [rbp-24h]
  signed int j; // [rsp+2Ch] [rbp-24h]
  signed int k; // [rsp+2Ch] [rbp-24h]
  const char *v19; // [rsp+30h] [rbp-20h]
  __int64 *v20; // [rsp+38h] [rbp-18h]

  v14 = a3;
  v20 = a3;
  sub_C1FF7(a1, "%*sleaf-list %s {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, *a3, a6);
  v15 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v14, v14[6], 0LL, 1LL);
  if ( v20[14] )
    sub_DF66E(a1, v15, (__int64 *)v20[6], (const char **)v20[14]);
  for ( i = 0; i < *((unsigned __int8 *)v20 + 27); ++i )
    sub_DE97F(a1, v15, v14[6], v20[5] + 32LL * i, v6, v7);
  sub_DFA28(a1, v15, (__int64 *)v14[6], (__int64)(v20 + 16));
  sub_DE71C(a1, v15, 17, 0, (const char *)v20[24], v14[6], v14[4], *((_BYTE *)v14 + 26));
  for ( j = 0; j < *((unsigned __int8 *)v20 + 31); ++j )
    sub_E0678(a1, v15, (__int64 *)v14[6], (const char **)(56LL * j + v20[15]));
  for ( k = 0; k < *((unsigned __int8 *)v20 + 30); ++k )
  {
    if ( v20[3] & 0x1000 )
    {
      if ( !strchr(*(const char **)(8LL * k + v20[25]), 58) )
        __assert_fail(
          "strchr(llist->dflt[i], ':')",
          "/home/mantovan/Repositories/libyang/src/printer_yang.c",
          0x4BFu,
          "yang_print_leaflist");
      v8 = &strchr(*(const char **)(8LL * k + v20[25]), 58)[-*(_QWORD *)(8LL * k + v20[25])];
      v9 = lys_node_module(v14);
      if ( !strncmp(*(const char **)(8LL * k + v20[25]), *(const char **)(v9 + 8), (size_t)v8) )
      {
        v10 = strchr(*(const char **)(8LL * k + v20[25]), 58);
        v19 = (const char *)lydict_insert(*(_QWORD *)v14[6], v10 + 1, 0LL);
      }
      else
      {
        v19 = (const char *)sub_9182((__int64 *)v14[6], *(const char **)(8LL * k + v20[25]));
      }
      sub_DE71C(a1, v15, 5, (unsigned __int8)k, v19, v14[6], v14[4], *((_BYTE *)v14 + 26));
    }
    else
    {
      v19 = *(const char **)(8LL * k + v20[25]);
      sub_DE71C(a1, v15, 5, (unsigned __int8)k, v19, v14[6], v14[4], *((_BYTE *)v14 + 26));
    }
    if ( v20[3] & 0x1000 )
      lydict_remove(*(_QWORD *)v14[6], v19);
  }
  sub_DEA7A(a1, v15, (__int64)v14, v14[6], 0LL, 4LL);
  if ( *((_DWORD *)v20 + 52) )
    sub_DF89A(a1, v15, 29LL, 0LL, (__int64 *)v14[6], v14[4], *((unsigned __int8 *)v14 + 26), *((_DWORD *)v20 + 52));
  if ( *((_DWORD *)v20 + 53) )
    sub_DF89A(a1, v15, 28LL, 0LL, (__int64 *)v14[6], v14[4], *((unsigned __int8 *)v14 + 26), *((_DWORD *)v20 + 53));
  if ( v20[3] & 0x100 )
  {
    sub_DE71C(a1, v15, 25, 0, "user", v14[6], v14[4], *((_BYTE *)v14 + 26));
  }
  else if ( (unsigned int)sub_9EAFC(v14[4], *((_BYTE *)v14 + 26), 0, 25) != -1 )
  {
    sub_DE71C(a1, v15, 25, 0, "system", v14[6], v14[4], *((_BYTE *)v14 + 26));
  }
  sub_DEA7A(a1, v15, (__int64)v14, v14[6], 0LL, 112LL);
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v11, v12);
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000E34E4) ----------------------------------------------------
unsigned __int64 __fastcall sub_E34E4(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // r8
  __int64 v33; // r9
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 *v39; // [rsp+8h] [rbp-48h]
  unsigned int v40; // [rsp+14h] [rbp-3Ch]
  unsigned int v41; // [rsp+2Ch] [rbp-24h]
  int i; // [rsp+30h] [rbp-20h]
  int v43; // [rsp+34h] [rbp-1Ch]
  __int64 j; // [rsp+38h] [rbp-18h]
  __int64 *v45; // [rsp+40h] [rbp-10h]
  unsigned __int64 v46; // [rsp+48h] [rbp-8h]

  v39 = a3;
  v46 = __readfsqword(0x28u);
  v41 = 0;
  v45 = a3;
  sub_C1FF7(a1, "%*slist %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v40 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v39, v39[6], &v41, 1LL);
  if ( v45[14] )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v6, v7, v8);
    sub_DF66E(a1, v40, (__int64 *)v45[6], (const char **)v45[14]);
  }
  for ( i = 0; i < *((unsigned __int8 *)v45 + 27); ++i )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v6, v7, v8);
    sub_DE97F(a1, v40, v39[6], v45[5] + 32LL * i, v9, v10);
  }
  for ( i = 0; i < *((unsigned __int8 *)v45 + 28); ++i )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v6, v7, v8);
    sub_E0678(a1, v40, (__int64 *)v45[6], (const char **)(56LL * i + v45[15]));
  }
  if ( *((_BYTE *)v45 + 30) )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v6, v7, v8);
    sub_DE71C(a1, v40, 9, 0, (const char *)v45[20], v39[6], v39[4], *((_BYTE *)v39 + 26));
  }
  for ( i = 0; i < *((unsigned __int8 *)v45 + 31); ++i )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v6, v7, v8);
    sub_E0707(a1, v40, (__int64 *)v39[6], v45[18] + 16LL * i, v11, v12);
    v43 = -1;
    do
    {
      v43 = sub_9EAFC(v45[4], *((_BYTE *)v45 + 26), (unsigned __int8)v43 + 1, 31);
      if ( v43 == -1 )
        break;
      v13 = 8LL * v43;
    }
    while ( i != *(unsigned __int8 *)(*(_QWORD *)(v13 + v45[4]) + 27LL) );
    if ( v43 == -1 )
    {
      sub_C1FF7(a1, ";\n", v13, v14, v15, v16);
    }
    else
    {
      sub_C1FF7(a1, (const char *)&off_12722C, v13, v14, v15, v16);
      do
      {
        sub_E6059(a1, a2 + 2, v45[6], 31, i, v45[4] + 8LL * v43, 1u);
        do
          v43 = sub_9EAFC(v45[4], *((_BYTE *)v45 + 26), (unsigned __int8)v43 + 1, 31);
        while ( v43 != -1 && i != *(unsigned __int8 *)(*(_QWORD *)(8LL * v43 + v45[4]) + 27LL) );
      }
      while ( v43 != -1 );
      sub_C1FF7(a1, "%*s}\n", 2 * v40, (__int64)&unk_127230, v17, v18);
    }
  }
  sub_DEA7A(a1, v40, (__int64)v39, v39[6], &v41, 4LL);
  if ( *((_DWORD *)v45 + 38) )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v19, v20, v21);
    sub_DF89A(a1, v40, 29LL, 0LL, (__int64 *)v39[6], v39[4], *((unsigned __int8 *)v39 + 26), *((_DWORD *)v45 + 38));
  }
  if ( *((_DWORD *)v45 + 39) )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v19, v20, v21);
    sub_DF89A(a1, v40, 28LL, 0LL, (__int64 *)v39[6], v39[4], *((unsigned __int8 *)v39 + 26), *((_DWORD *)v45 + 39));
  }
  if ( v45[3] & 0x100 )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v19, v20, v21);
    sub_DE71C(a1, v40, 25, 0, "user", v39[6], v39[4], *((_BYTE *)v39 + 26));
  }
  else if ( (unsigned int)sub_9EAFC(v39[4], *((_BYTE *)v39 + 26), 0, 25) != -1 )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v22, v23, v24);
    sub_DE71C(a1, v40, 25, 0, "system", v39[6], v39[4], *((_BYTE *)v39 + 26));
  }
  sub_DEA7A(a1, v40, (__int64)v39, v39[6], &v41, 112LL);
  for ( i = 0; i < *((unsigned __int8 *)v45 + 29); ++i )
  {
    sub_DE4D3(a1, &v41, (__int64)&v41, v25, v26, v27);
    sub_E1BDF(a1, v40, (__int64 *)v45[6], (__int64 *)(v45[16] + ((signed __int64)i << 7)), v28, v29);
  }
  for ( j = v39[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v39 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v41, (__int64)&v41, v25, v26, v27);
      sub_E479A(a1, v40, j, 2048LL, v30, v31);
    }
  }
  for ( j = v39[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v39 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v41, (__int64)&v41, v25, v26, v27);
      sub_E479A(a1, v40, j, 36927LL, v32, v33);
    }
  }
  for ( j = v39[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v39 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v41, (__int64)&v41, v25, v26, v27);
      sub_E479A(a1, v40, j, 0x4000LL, v34, v35);
    }
  }
  for ( j = v39[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v39 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v41, (__int64)&v41, v25, v26, v27);
      sub_E479A(a1, v40, j, 128LL, v36, v37);
    }
  }
  sub_DE519(a1, a2, v41, a2, v26, v27);
  return __readfsqword(0x28u) ^ v46;
}
// 12722C: using guessed type void *__ptr32 off_12722C;

//----- (00000000000E3CC6) ----------------------------------------------------
unsigned __int64 __fastcall sub_E3CC6(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 *v20; // [rsp+8h] [rbp-38h]
  unsigned int v21; // [rsp+14h] [rbp-2Ch]
  unsigned int v22; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 *v25; // [rsp+30h] [rbp-10h]
  unsigned __int64 v26; // [rsp+38h] [rbp-8h]

  v20 = a3;
  v26 = __readfsqword(0x28u);
  v22 = 0;
  v25 = a3;
  sub_C1FF7(a1, "%*sgrouping %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v21 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v20, v20[6], &v22, 113LL);
  for ( i = 0; i < *((unsigned __int16 *)v25 + 15); ++i )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v6, v7, v8);
    sub_E1BDF(a1, v21, (__int64 *)v20[6], (__int64 *)(v25[13] + ((signed __int64)i << 7)), v9, v10);
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v6, v7, v8);
    sub_E479A(a1, v21, j, 2048LL, v11, v12);
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v6, v7, v8);
    sub_E479A(a1, v21, j, 36927LL, v13, v14);
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v6, v7, v8);
    sub_E479A(a1, v21, j, 0x4000LL, v15, v16);
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v6, v7, v8);
    sub_E479A(a1, v21, j, 128LL, v17, v18);
  }
  sub_DE519(a1, a2, v22, a2, v7, v8);
  return __readfsqword(0x28u) ^ v26;
}

//----- (00000000000E3F0E) ----------------------------------------------------
unsigned __int64 __fastcall sub_E3F0E(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v20; // [rsp+8h] [rbp-38h]
  int v21; // [rsp+14h] [rbp-2Ch]
  unsigned int v22; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 v24; // [rsp+28h] [rbp-18h]
  __int64 v25; // [rsp+30h] [rbp-10h]
  unsigned __int64 v26; // [rsp+38h] [rbp-8h]

  v20 = a3;
  v26 = __readfsqword(0x28u);
  v22 = 0;
  v24 = a3;
  sub_C1FF7(a1, "%*suses ", 2 * a2, (__int64)&unk_127230, a5, a6);
  if ( *(_QWORD *)(v20 + 72) )
  {
    v25 = lys_node_module(*(_QWORD *)(v20 + 72));
    if ( v25 != lys_node_module(v20) )
    {
      v9 = sub_831C(*(_QWORD *)(v20 + 48), *(const char **)(v25 + 8));
      sub_C1FF7(a1, "%s:", v9, v10, v11, v12);
    }
  }
  sub_C1FF7(a1, "%s", *(_QWORD *)v24, v6, v7, v8);
  v21 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v20, *(_QWORD *)(v20 + 48), &v22, 1LL);
  if ( *(_QWORD *)(v24 + 104) )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v13, v14, v15);
    sub_DF66E(a1, v21, *(__int64 **)(v20 + 48), *(const char ***)(v24 + 104));
  }
  sub_DEA7A(a1, v21, v20, *(_QWORD *)(v20 + 48), &v22, 114LL);
  for ( i = 0; i < *(unsigned __int8 *)(v24 + 30); ++i )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v16, v17, v18);
    sub_E0803(a1, v21, *(__int64 **)(v20 + 48), (const char **)(80LL * i + *(_QWORD *)(v24 + 112)));
  }
  for ( i = 0; i < *(unsigned __int8 *)(v24 + 31); ++i )
  {
    sub_DE4D3(a1, &v22, (__int64)&v22, v16, v17, v18);
    sub_E1A74(a1, v21, *(_QWORD *)(v24 + 120) + 104LL * i);
  }
  sub_DE519(a1, a2, v22, a2, v17, v18);
  return __readfsqword(0x28u) ^ v26;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000E417B) ----------------------------------------------------
signed __int64 __fastcall sub_E417B(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+14h] [rbp-2Ch]
  signed int i; // [rsp+2Ch] [rbp-14h]
  signed int j; // [rsp+2Ch] [rbp-14h]
  __int64 k; // [rsp+30h] [rbp-10h]
  __int64 l; // [rsp+30h] [rbp-10h]
  __int64 v16; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v16 = a3;
  if ( *(_DWORD *)(a3 + 56) == 512 )
    v6 = "input";
  else
    v6 = "output";
  sub_C1FF7(a1, "%*s%s {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, (__int64)v6, a6);
  v11 = a2 + 1;
  if ( *(_BYTE *)(v10 + 26) )
    sub_E6059(a1, v11, *(_QWORD *)(v10 + 48), 0, 0, *(_QWORD *)(v10 + 32), *(unsigned __int8 *)(v10 + 26));
  for ( i = 0; i < *(unsigned __int8 *)(v16 + 29); ++i )
    sub_E0678(a1, v11, *(__int64 **)(v10 + 48), (const char **)(56LL * i + *(_QWORD *)(v16 + 112)));
  for ( j = 0; j < *(unsigned __int16 *)(v16 + 30); ++j )
    sub_E1BDF(a1, v11, *(__int64 **)(v10 + 48), (__int64 *)(*(_QWORD *)(v16 + 104) + ((signed __int64)j << 7)), v7, v8);
  for ( k = *(_QWORD *)(v10 + 72); k; k = *(_QWORD *)(k + 80) )
  {
    if ( v10 == *(_QWORD *)(k + 64) )
      sub_E479A(a1, v11, k, 2048LL, v7, v8);
  }
  for ( l = *(_QWORD *)(v10 + 72); l; l = *(_QWORD *)(l + 80) )
  {
    if ( v10 == *(_QWORD *)(l + 64) )
      sub_E479A(a1, v11, l, 36927LL, v7, v8);
  }
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v7, v8);
}

//----- (00000000000E4386) ----------------------------------------------------
unsigned __int64 __fastcall sub_E4386(__int64 a1, unsigned int a2, __int64 a3)
{
  const char *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+8h] [rbp-38h]
  unsigned int v13; // [rsp+14h] [rbp-2Ch]
  unsigned int v14; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 v17; // [rsp+30h] [rbp-10h]
  unsigned __int64 v18; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v18 = __readfsqword(0x28u);
  v14 = 0;
  v17 = a3;
  if ( *(_DWORD *)(a3 + 56) == 256 )
    v3 = "rpc";
  else
    v3 = "action";
  sub_C1FF7(a1, "%*s%s %s", 2 * a2, (__int64)&unk_127230, (__int64)v3, *(_QWORD *)a3);
  v13 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, v12, *(_QWORD *)(v12 + 48), &v14, 115LL);
  for ( i = 0; i < *(unsigned __int16 *)(v17 + 30); ++i )
  {
    sub_DE4D3(a1, &v14, (__int64)&v14, v4, v5, v6);
    sub_E1BDF(a1, v13, *(__int64 **)(v12 + 48), (__int64 *)(*(_QWORD *)(v17 + 112) + ((signed __int64)i << 7)), v7, v8);
  }
  for ( j = *(_QWORD *)(v12 + 72); j; j = *(_QWORD *)(j + 80) )
  {
    if ( v12 == *(_QWORD *)(j + 64) && (!(*(_DWORD *)(j + 56) & 0x600) || !(*(_WORD *)(j + 24) & 0x40)) )
    {
      sub_DE4D3(a1, &v14, (__int64)&v14, v4, v5, v6);
      sub_E479A(a1, v13, j, 3584LL, v9, v10);
    }
  }
  sub_DE519(a1, a2, v14, a2, v5, v6);
  return __readfsqword(0x28u) ^ v18;
}

//----- (00000000000E453A) ----------------------------------------------------
unsigned __int64 __fastcall sub_E453A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 *v19; // [rsp+8h] [rbp-38h]
  unsigned int v20; // [rsp+14h] [rbp-2Ch]
  unsigned int v21; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 *v24; // [rsp+30h] [rbp-10h]
  unsigned __int64 v25; // [rsp+38h] [rbp-8h]

  v19 = a3;
  v25 = __readfsqword(0x28u);
  v21 = 0;
  v24 = a3;
  sub_C1FF7(a1, "%*snotification %s", 2 * a2, (__int64)&unk_127230, *a3, a6);
  v20 = a2 + 1;
  sub_DEA7A(a1, a2 + 1, (__int64)v19, v19[6], &v21, 3LL);
  for ( i = 0; i < *((unsigned __int8 *)v24 + 29); ++i )
  {
    sub_DE4D3(a1, &v21, (__int64)&v21, v6, v7, v8);
    sub_E0678(a1, v20, (__int64 *)v19[6], (const char **)(56LL * i + v24[15]));
  }
  sub_DEA7A(a1, v20, (__int64)v19, v19[6], &v21, 112LL);
  for ( i = 0; i < *((unsigned __int16 *)v24 + 15); ++i )
  {
    sub_DE4D3(a1, &v21, (__int64)&v21, v9, v10, v11);
    sub_E1BDF(a1, v20, (__int64 *)v19[6], (__int64 *)(v24[14] + ((signed __int64)i << 7)), v12, v13);
  }
  for ( j = v19[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v19 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v21, (__int64)&v21, v9, v10, v11);
      sub_E479A(a1, v20, j, 2048LL, v14, v15);
    }
  }
  for ( j = v19[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v19 == *(__int64 **)(j + 64) )
    {
      sub_DE4D3(a1, &v21, (__int64)&v21, v9, v10, v11);
      sub_E479A(a1, v20, j, 36927LL, v16, v17);
    }
  }
  sub_DE519(a1, a2, v21, a2, v10, v11);
  return __readfsqword(0x28u) ^ v25;
}

//----- (00000000000E479A) ----------------------------------------------------
signed __int64 __fastcall sub_E479A(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  signed __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-18h]
  unsigned int v9; // [rsp+10h] [rbp-10h]

  v8 = a3;
  v9 = a4;
  v6 = *(unsigned int *)(a3 + 56);
  if ( (unsigned int)v6 & (unsigned int)a4 )
  {
    if ( *(_DWORD *)(v8 + 56) & 0x600 )
    {
      result = *(_WORD *)(v8 + 24) & 0x40;
      if ( (_DWORD)result )
        return result;
    }
    if ( !*(_QWORD *)(v8 + 64)
      || *(_DWORD *)(*(_QWORD *)(v8 + 64) + 56LL) == 0x2000 && v8 != *(_QWORD *)(*(_QWORD *)(v8 + 64) + 72LL)
      || *(_DWORD *)(*(_QWORD *)(v8 + 64) + 56LL) != 0x2000 && *(_QWORD *)(*(_QWORD *)(v8 + 88) + 80LL) )
    {
      sub_C1FF7(a1, "\n", v6, a4, a5, a6);
    }
  }
  result = *(_DWORD *)(v8 + 56) & v9;
  if ( (_DWORD)result == 128 )
    return sub_E453A(a1, a2, (__int64 *)v8, a2, a5, a6);
  if ( (unsigned int)result <= 0x80 )
  {
    if ( (_DWORD)result == 8 )
      return sub_E2F1F(a1, a2, (__int64 *)v8, a2, a5, a6);
    if ( (unsigned int)result <= 8 )
    {
      switch ( (_DWORD)result )
      {
        case 2:
          return sub_E26DF(a1, a2, (__int64 *)v8, a2, a5, a6);
        case 4:
          return sub_E2926(a1, a2, (__int64 *)v8, a2, a5, a6);
        case 1:
          result = sub_E2106(a1, a2, (__int64 *)v8, a2, a5, a6);
          break;
      }
      return result;
    }
    if ( (_DWORD)result != 32 )
    {
      if ( (_DWORD)result == 64 )
        return sub_E252D(a1, a2, v8, a2, a5, a6);
      if ( (_DWORD)result == 16 )
        result = sub_E34E4(a1, a2, (__int64 *)v8, a2, a5, a6);
      return result;
    }
    return sub_E2CCF(a1, a2, v8);
  }
  if ( (_DWORD)result == 2048 )
    return sub_E3CC6(a1, a2, (__int64 *)v8, a2, a5, a6);
  if ( (unsigned int)result <= 0x800 )
  {
    if ( (_DWORD)result == 512 || (_DWORD)result == 1024 )
      return sub_E417B(a1, a2, v8, a2, a5, a6);
    if ( (_DWORD)result != 256 )
      return result;
    return sub_E4386(a1, a2, v8);
  }
  switch ( (_DWORD)result )
  {
    case 0x4000:
      return sub_E4386(a1, a2, v8);
    case 0x8020:
      return sub_E2CCF(a1, a2, v8);
    case 0x1000:
      result = sub_E3F0E(a1, a2, v8, a2, a5, a6);
      break;
  }
  return result;
}

//----- (00000000000E4A49) ----------------------------------------------------
signed __int64 __fastcall sub_E4A49(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST10_8
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // [rsp+8h] [rbp-18h]

  v10 = a3;
  if ( *(_OWORD *)(a4 + 24) == 0LL && !*(_BYTE *)(a4 + 11) )
    return sub_C1FF7(a1, "%*srevision %s;\n", (unsigned int)(2 * a2), (__int64)&unk_127230, a4, a6, a4, a3);
  sub_C1FF7(a1, "%*srevision %s {\n", (unsigned int)(2 * a2), (__int64)&unk_127230, a4, a6, a4);
  sub_E6059(a1, a2 + 1, v10, 0, 0, *(_QWORD *)(v6 + 16), *(unsigned __int8 *)(v6 + 11));
  sub_DE71C(a1, a2 + 1, 6, 0, *(const char **)(v6 + 24), v10, *(_QWORD *)(v6 + 16), *(_BYTE *)(v6 + 11));
  sub_DE71C(a1, a2 + 1, 15, 0, *(const char **)(v6 + 32), v10, *(_QWORD *)(v6 + 16), *(_BYTE *)(v6 + 11));
  return sub_C1FF7(a1, "%*s}\n", (unsigned int)(2 * a2), (__int64)&unk_127230, v7, v8);
}

//----- (00000000000E4BDA) ----------------------------------------------------
__int64 __fastcall sub_E4BDA(__int64 a1, int a2, __int64 a3)
{
  const char *v3; // rax
  __int64 v4; // r9
  const char *v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  const char *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rdx
  __int64 v39; // rcx
  __int64 v40; // r8
  __int64 v41; // r9
  __int64 v43; // [rsp+8h] [rbp-28h]
  unsigned int v44; // [rsp+14h] [rbp-1Ch]
  int v45; // [rsp+14h] [rbp-1Ch]
  int v46; // [rsp+14h] [rbp-1Ch]
  unsigned int i; // [rsp+20h] [rbp-10h]
  unsigned int j; // [rsp+20h] [rbp-10h]
  unsigned int k; // [rsp+20h] [rbp-10h]
  unsigned int l; // [rsp+20h] [rbp-10h]
  unsigned int m; // [rsp+20h] [rbp-10h]
  unsigned int n; // [rsp+20h] [rbp-10h]
  unsigned int ii; // [rsp+20h] [rbp-10h]
  unsigned int ll; // [rsp+20h] [rbp-10h]
  unsigned int i1; // [rsp+20h] [rbp-10h]
  int v56; // [rsp+24h] [rbp-Ch]
  __int64 jj; // [rsp+28h] [rbp-8h]
  __int64 kk; // [rsp+28h] [rbp-8h]
  __int64 mm; // [rsp+28h] [rbp-8h]
  __int64 nn; // [rsp+28h] [rbp-8h]

  v43 = a3;
  if ( *(_BYTE *)(a3 + 64) & 1 )
  {
    if ( (*(_BYTE *)(a3 + 64) & 0x30) == 16 )
      v3 = " // DEVIATED";
    else
      v3 = (const char *)&unk_127230;
    sub_C1FF7(
      a1,
      "%*ssubmodule %s {%s\n",
      (unsigned int)(2 * a2),
      (__int64)&unk_127230,
      *(_QWORD *)(a3 + 8),
      (__int64)v3);
    v44 = a2 + 1;
    if ( *(_BYTE *)(v43 + 64) & 0xE
      || (unsigned int)sub_9EAFC(*(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80), 0, 19) != -1 )
    {
      if ( (*(_BYTE *)(v43 + 64) & 0xE) == 4 )
        v5 = "1.1";
      else
        v5 = "1";
      sub_DE71C(a1, v44, 19, 0, v5, v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
    }
    sub_C1FF7(a1, "%*sbelongs-to %s {\n", 2 * v44, (__int64)&unk_127230, *(_QWORD *)(*(_QWORD *)(v43 + 168) + 8LL), v4);
    LOBYTE(v56) = -1;
    while ( 1 )
    {
      v56 = sub_9EAFC(*(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80), (unsigned __int8)v56 + 1, 3);
      if ( v56 == -1 )
        break;
      sub_E6059(a1, a2 + 2, v43, 3, 0, *(_QWORD *)(v43 + 160) + 8LL * v56, 1u);
    }
    sub_DE71C(a1, a2 + 2, 13, 0, *(const char **)(v43 + 16), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
    sub_C1FF7(a1, "%*s}\n", 2 * v44, (__int64)&unk_127230, v6, v7);
  }
  else
  {
    if ( (*(_BYTE *)(a3 + 64) & 0x30) == 16 )
      v12 = " // DEVIATED";
    else
      v12 = (const char *)&unk_127230;
    sub_C1FF7(a1, "%*smodule %s {%s\n", (unsigned int)(2 * a2), (__int64)&unk_127230, *(_QWORD *)(a3 + 8), (__int64)v12);
    v44 = a2 + 1;
    if ( *(_BYTE *)(v43 + 64) & 0xE )
    {
      if ( (*(_BYTE *)(v43 + 64) & 0xE) == 4 )
        v13 = "1.1";
      else
        v13 = "1";
      sub_DE71C(a1, v44, 19, 0, v13, v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
    }
    sub_DE71C(a1, v44, 10, 0, *(const char **)(v43 + 176), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
    sub_DE71C(a1, v44, 13, 0, *(const char **)(v43 + 16), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
  }
  for ( i = 0; i < *(unsigned __int8 *)(v43 + 69); ++i )
  {
    sub_C1FF7(
      a1,
      "\n%*simport %s {\n",
      2 * v44,
      (__int64)&unk_127230,
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 96) + 56LL * i) + 8LL),
      v11);
    v45 = v44 + 1;
    sub_E6059(
      a1,
      v45,
      v43,
      0,
      0,
      *(_QWORD *)(*(_QWORD *)(v43 + 96) + 56LL * i + 32),
      *(unsigned __int8 *)(*(_QWORD *)(v43 + 96) + 56LL * i + 27));
    sub_DE71C(
      a1,
      v45,
      13,
      0,
      *(const char **)(*(_QWORD *)(v43 + 96) + 56LL * i + 8),
      v43,
      *(_QWORD *)(*(_QWORD *)(v43 + 96) + 56LL * i + 32),
      *(_BYTE *)(*(_QWORD *)(v43 + 96) + 56LL * i + 27));
    if ( *(_BYTE *)(*(_QWORD *)(v43 + 96) + 56LL * i + 16) )
      sub_DE71C(
        a1,
        v45,
        16,
        0,
        (const char *)(*(_QWORD *)(v43 + 96) + 56LL * i + 16),
        v43,
        *(_QWORD *)(*(_QWORD *)(v43 + 96) + 56LL * i + 32),
        *(_BYTE *)(*(_QWORD *)(v43 + 96) + 56LL * i + 27));
    sub_DE71C(
      a1,
      v45,
      6,
      0,
      *(const char **)(*(_QWORD *)(v43 + 96) + 56LL * i + 40),
      v43,
      *(_QWORD *)(*(_QWORD *)(v43 + 96) + 56LL * i + 32),
      *(_BYTE *)(*(_QWORD *)(v43 + 96) + 56LL * i + 27));
    sub_DE71C(
      a1,
      v45,
      15,
      0,
      *(const char **)(*(_QWORD *)(v43 + 96) + 56LL * i + 48),
      v43,
      *(_QWORD *)(*(_QWORD *)(v43 + 96) + 56LL * i + 32),
      *(_BYTE *)(*(_QWORD *)(v43 + 96) + 56LL * i + 27));
    v44 = v45 - 1;
    sub_C1FF7(a1, "%*s}\n", 2 * v44, (__int64)&unk_127230, v14, v15);
  }
  for ( j = 0; j < *(unsigned __int8 *)(v43 + 70); ++j )
  {
    if ( *(_BYTE *)(*(_QWORD *)(v43 + 104) + 48LL * j + 8)
      || *(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j + 32)
      || *(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j + 40)
      || *(_BYTE *)(*(_QWORD *)(v43 + 104) + 48LL * j + 19) )
    {
      sub_C1FF7(
        a1,
        "\n%*sinclude %s {\n",
        2 * v44,
        (__int64)&unk_127230,
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j) + 8LL),
        v11);
      v46 = v44 + 1;
      sub_E6059(
        a1,
        v46,
        v43,
        0,
        0,
        *(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j + 24),
        *(unsigned __int8 *)(*(_QWORD *)(v43 + 104) + 48LL * j + 19));
      if ( *(_BYTE *)(*(_QWORD *)(v43 + 104) + 48LL * j + 8) )
        sub_DE71C(
          a1,
          v46,
          16,
          0,
          (const char *)(*(_QWORD *)(v43 + 104) + 48LL * j + 8),
          v43,
          *(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j + 24),
          *(_BYTE *)(*(_QWORD *)(v43 + 104) + 48LL * j + 19));
      sub_DE71C(
        a1,
        v46,
        6,
        0,
        *(const char **)(*(_QWORD *)(v43 + 104) + 48LL * j + 32),
        v43,
        *(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j + 24),
        *(_BYTE *)(*(_QWORD *)(v43 + 104) + 48LL * j + 19));
      sub_DE71C(
        a1,
        v46,
        15,
        0,
        *(const char **)(*(_QWORD *)(v43 + 104) + 48LL * j + 40),
        v43,
        *(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j + 24),
        *(_BYTE *)(*(_QWORD *)(v43 + 104) + 48LL * j + 19));
      v44 = v46 - 1;
      sub_C1FF7(a1, "%*s}\n", 2 * v44, (__int64)&unk_127230, v16, v17);
    }
    else
    {
      sub_C1FF7(
        a1,
        "\n%*sinclude \"%s\";\n",
        2 * v44,
        (__int64)&unk_127230,
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * j) + 8LL),
        v11);
    }
  }
  if ( *(_QWORD *)(v43 + 40) || *(_QWORD *)(v43 + 48) || *(_QWORD *)(v43 + 24) || *(_QWORD *)(v43 + 32) )
    sub_C1FF7(a1, "\n", v8, v9, v10, v11);
  sub_DE71C(a1, v44, 11, 0, *(const char **)(v43 + 40), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
  sub_DE71C(a1, v44, 4, 0, *(const char **)(v43 + 48), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
  sub_DE71C(a1, v44, 6, 0, *(const char **)(v43 + 24), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
  sub_DE71C(a1, v44, 15, 0, *(const char **)(v43 + 32), v43, *(_QWORD *)(v43 + 160), *(_BYTE *)(v43 + 80));
  if ( *(_BYTE *)(v43 + 68) )
    sub_C1FF7(a1, "\n", v18, v19, v20, v21);
  for ( k = 0; k < *(unsigned __int8 *)(v43 + 68); ++k )
    sub_E4A49(a1, v44, v43, 40LL * k + *(_QWORD *)(v43 + 88), v20, v21);
  for ( l = 0; l < *(unsigned __int8 *)(v43 + 79); ++l )
  {
    sub_C1FF7(a1, "\n", v18, v19, v20, v21);
    sub_DF0C8(a1, v44, (__int64 *)(*(_QWORD *)(v43 + 152) + ((unsigned __int64)l << 6)), v44, v22, v23);
  }
  if ( *(_BYTE *)(v43 + 80) )
  {
    sub_C1FF7(a1, "\n", v18, v19, v20, v21);
    sub_E6059(a1, v44, v43, 0, 0, *(_QWORD *)(v43 + 160), *(unsigned __int8 *)(v43 + 80));
  }
  for ( m = 0; m < *(unsigned __int8 *)(v43 + 76); ++m )
  {
    sub_C1FF7(a1, "\n", v18, v19, v20, v21);
    sub_DF01A(a1, v44, (__int64 *)(*(_QWORD *)(v43 + 128) + ((unsigned __int64)m << 6)), v44, v24, v25);
  }
  for ( n = 0; n < *(unsigned __int16 *)(v43 + 72); ++n )
  {
    sub_C1FF7(a1, "\n", v18, v19, v20, v21);
    sub_E1E7A(a1, v44, (__int64 *)(*(_QWORD *)(v43 + 120) + 72LL * n), v44, v26, v27);
  }
  for ( ii = 0; ii < *(unsigned __int16 *)(v43 + 74); ++ii )
  {
    sub_C1FF7(a1, "\n", v18, v19, v20, v21);
    sub_E1BDF(a1, v44, (__int64 *)v43, (__int64 *)(*(_QWORD *)(v43 + 112) + ((unsigned __int64)ii << 7)), v28, v29);
  }
  for ( jj = *(_QWORD *)(lys_main_module(v43) + 168); jj; jj = *(_QWORD *)(jj + 80) )
  {
    if ( v43 == *(_QWORD *)(jj + 48) )
      sub_E479A(a1, v44, jj, 2048LL, v30, v31);
  }
  for ( kk = *(_QWORD *)(lys_main_module(v43) + 168); kk; kk = *(_QWORD *)(kk + 80) )
  {
    if ( v43 == *(_QWORD *)(kk + 48) )
      sub_E479A(a1, v44, kk, 36927LL, v34, v35);
  }
  for ( ll = 0; ll < *(unsigned __int8 *)(v43 + 77); ++ll )
  {
    sub_C1FF7(a1, "\n", v32, v33, v34, v35);
    sub_E1A74(a1, v44, *(_QWORD *)(v43 + 136) + 104LL * ll);
  }
  for ( mm = *(_QWORD *)(lys_main_module(v43) + 168); mm; mm = *(_QWORD *)(mm + 80) )
  {
    if ( v43 == *(_QWORD *)(mm + 48) )
      sub_E479A(a1, v44, mm, 16640LL, v36, v37);
  }
  for ( nn = *(_QWORD *)(lys_main_module(v43) + 168); nn; nn = *(_QWORD *)(nn + 80) )
  {
    if ( v43 == *(_QWORD *)(nn + 48) )
      sub_E479A(a1, v44, nn, 128LL, v40, v41);
  }
  for ( i1 = 0; i1 < *(unsigned __int8 *)(v43 + 78); ++i1 )
  {
    sub_C1FF7(a1, "\n", v38, v39, v40, v41);
    sub_E0D20(a1, v44, (__int64 *)v43, (const char **)(56LL * i1 + *(_QWORD *)(v43 + 144)));
  }
  sub_C1FF7(a1, "%*s}\n", 2 * (v44 - 1), (__int64)&unk_127230, v40, v41);
  sub_C236C(a1);
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000E5C7A) ----------------------------------------------------
__int64 __fastcall sub_E5C7A(__int64 a1, __int64 a2)
{
  return sub_E4BDA(a1, 0, a2);
}

//----- (00000000000E5CA1) ----------------------------------------------------
unsigned __int64 __fastcall sub_E5CA1(__int64 a1, int a2, __int64 *a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, _DWORD *a8)
{
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v12; // [rsp+18h] [rbp-48h]
  __int64 v13; // [rsp+20h] [rbp-40h]
  __int64 *v14; // [rsp+28h] [rbp-38h]
  int v15; // [rsp+30h] [rbp-30h]
  char v16; // [rsp+48h] [rbp-18h]
  _BYTE *v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v15 = a5;
  v12 = (const char *)a6;
  v18 = __readfsqword(0x28u);
  v17 = (_BYTE *)lys_ext_complex_get_substmt(a5, a4, &v16);
  if ( v17 && *v17 )
  {
    sub_DE4D3(a1, a8, (__int64)a8, v8, v9, v10);
    if ( *v17 == 1 )
    {
      sub_DE71C(a1, a2, v15, 0, v12, (__int64)v14, *(_QWORD *)(v13 + 32), *(_BYTE *)(v13 + 26));
    }
    else if ( *v17 == 2 )
    {
      sub_DE71C(a1, a2, v15, 0, (const char *)a7, (__int64)v14, *(_QWORD *)(v13 + 32), *(_BYTE *)(v13 + 26));
    }
    else
    {
      sub_12222(
        *v14,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_yang.c",
        1833LL);
    }
  }
  return __readfsqword(0x28u) ^ v18;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000E5DFA) ----------------------------------------------------
unsigned __int64 __fastcall sub_E5DFA(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, _DWORD *a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  _DWORD *v10; // [rsp+8h] [rbp-48h]
  __int64 v11; // [rsp+10h] [rbp-40h]
  __int64 v12; // [rsp+18h] [rbp-38h]
  int v13; // [rsp+20h] [rbp-30h]
  int v14; // [rsp+34h] [rbp-1Ch]
  __int64 v15; // [rsp+38h] [rbp-18h]
  const char *v16; // [rsp+40h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v13 = a5;
  v10 = a6;
  v17 = __readfsqword(0x28u);
  v16 = (const char *)lys_ext_complex_get_substmt(a5, a4, &v15);
  if ( v16 && *(_QWORD *)v16 )
  {
    if ( *(_DWORD *)(v15 + 16) <= 1u )
    {
      sub_DE4D3(a1, v10, (__int64)v10, v6, v7, v8);
      sub_DE71C(a1, a2, v13, 0, *(const char **)v16, v12, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else
    {
      v16 = *(const char **)v16;
      v14 = 0;
      while ( *(_QWORD *)v16 )
      {
        sub_DE4D3(a1, v10, (__int64)v10, v6, v7, v8);
        sub_DE71C(
          a1,
          a2,
          v13,
          (unsigned __int8)v14,
          *(const char **)v16,
          v12,
          *(_QWORD *)(v11 + 32),
          *(_BYTE *)(v11 + 26));
        v16 += 8;
        ++v14;
      }
    }
  }
  return __readfsqword(0x28u) ^ v17;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000E5F4E) ----------------------------------------------------
_WORD *__fastcall sub_E5F4E(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, unsigned __int16 a8, unsigned __int16 a9, _DWORD *a10)
{
  _WORD *result; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // [rsp+8h] [rbp-38h]
  __int64 v15; // [rsp+10h] [rbp-30h]
  __int64 v16; // [rsp+18h] [rbp-28h]
  int v17; // [rsp+20h] [rbp-20h]
  const char *v18; // [rsp+30h] [rbp-10h]

  v16 = a3;
  v15 = a4;
  v17 = a5;
  v14 = a6;
  result = (_WORD *)lys_ext_complex_get_substmt(a5, a4, 0LL);
  if ( result )
  {
    if ( a8 & *result )
    {
      v18 = (const char *)v14;
    }
    else if ( a9 & *result )
    {
      v18 = (const char *)a7;
    }
    else
    {
      result = (_WORD *)sub_9EAFC(*(_QWORD *)(v15 + 32), *(_BYTE *)(v15 + 26), 0, v17);
      if ( (_DWORD)result == -1 )
        return result;
      v18 = (const char *)v14;
    }
    sub_DE4D3(a1, a10, (__int64)a10, v11, v12, v13);
    result = (_WORD *)sub_DE71C(a1, a2, v17, 0, v18, v16, *(_QWORD *)(v15 + 32), *(_BYTE *)(v15 + 26));
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000E6059) ----------------------------------------------------
unsigned __int64 __fastcall sub_E6059(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5, __int64 a6, unsigned int a7)
{
  __int64 v7; // rax
  size_t v8; // rbx
  size_t v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  signed __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  const char *v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  const char *v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  const char *v26; // rax
  __int64 v27; // rcx
  __int64 v28; // r9
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // r9
  __int64 v32; // r8
  __int64 v33; // r9
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // r8
  __int64 v39; // r9
  __int64 v40; // rcx
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rcx
  __int64 v46; // rcx
  __int64 v47; // rcx
  __int64 v48; // rcx
  __int64 v49; // rcx
  __int64 v50; // rcx
  __int64 v51; // rcx
  __int64 v52; // r8
  __int64 v53; // r9
  __int64 v54; // rcx
  __int64 v55; // r8
  __int64 v56; // r9
  __int64 v57; // r8
  __int64 v58; // r9
  __int64 v59; // rcx
  __int64 v60; // r8
  __int64 v61; // r9
  __int64 v62; // rcx
  unsigned int v63; // eax
  __int64 v64; // r8
  __int64 v65; // r9
  __int64 v66; // rcx
  __int64 v67; // rcx
  __int64 v68; // rcx
  __int64 v69; // rcx
  __int64 v70; // rcx
  __int64 v71; // rcx
  __int64 v72; // r8
  __int64 v73; // r9
  __int64 v74; // r8
  __int64 v75; // r9
  __int64 v77; // [rsp+8h] [rbp-A8h]
  char v78; // [rsp+14h] [rbp-9Ch]
  __int64 v79; // [rsp+18h] [rbp-98h]
  int v80; // [rsp+20h] [rbp-90h]
  unsigned int v81; // [rsp+24h] [rbp-8Ch]
  unsigned int v82; // [rsp+24h] [rbp-8Ch]
  unsigned int v83; // [rsp+34h] [rbp-7Ch]
  unsigned int v84; // [rsp+38h] [rbp-78h]
  unsigned int i; // [rsp+3Ch] [rbp-74h]
  unsigned int j; // [rsp+40h] [rbp-70h]
  int v87; // [rsp+44h] [rbp-6Ch]
  int k; // [rsp+48h] [rbp-68h]
  int l; // [rsp+4Ch] [rbp-64h]
  char *s; // [rsp+50h] [rbp-60h]
  const char *v91; // [rsp+58h] [rbp-58h]
  __int64 m; // [rsp+60h] [rbp-50h]
  __int64 n; // [rsp+68h] [rbp-48h]
  __int64 v94; // [rsp+70h] [rbp-40h]
  char *v95; // [rsp+78h] [rbp-38h]
  __int64 v96; // [rsp+80h] [rbp-30h]
  unsigned int **v97; // [rsp+88h] [rbp-28h]
  _WORD *v98; // [rsp+90h] [rbp-20h]
  unsigned __int64 v99; // [rsp+98h] [rbp-18h]

  v81 = a2;
  v79 = a3;
  v80 = a4;
  v77 = a6;
  v78 = a5;
  v99 = __readfsqword(0x28u);
  s = 0LL;
  for ( i = 0; i < a7; ++i )
  {
    if ( !(*(_WORD *)(*(_QWORD *)(8LL * i + v77) + 24LL) & 1)
      && v80 == *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 28LL)
      && v78 == *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 27LL)
      && (*(_QWORD *)(**(_QWORD **)(8LL * i + v77) + 48LL) != **(_QWORD **)(*(_QWORD *)v79 + 64LL)
       || strcmp(*(const char **)(*(_QWORD *)(8LL * i + v77) + 16LL), "operation")
       && strcmp(*(const char **)(*(_QWORD *)(8LL * i + v77) + 16LL), "select")
       && strcmp(*(const char **)(*(_QWORD *)(8LL * i + v77) + 16LL), "type")) )
    {
      v94 = lys_main_module(*(_QWORD *)(**(_QWORD **)(8LL * i + v77) + 48LL));
      v7 = lys_main_module(v79);
      if ( v94 == v7 )
      {
        s = *(char **)(v79 + 16);
      }
      else
      {
        for ( j = 0; j < *(unsigned __int8 *)(v79 + 69); ++j )
        {
          if ( v94 == *(_QWORD *)(*(_QWORD *)(v79 + 96) + 56LL * j) )
          {
            s = *(char **)(*(_QWORD *)(v79 + 96) + 56LL * j + 8);
            break;
          }
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 16LL) )
      {
        v8 = strlen(s);
        v9 = strlen(***(const char ****)(8LL * i + v77));
        v95 = (char *)malloc(v8 + v9 + 2);
        sprintf(v95, "%s:%s", s, ***(_QWORD ***)(8LL * i + v77));
        sub_DE573(a1, v81, (__int64)v95, *(const char **)(*(_QWORD *)(8LL * i + v77) + 16LL), 1, 0LL);
        free(v95);
      }
      else
      {
        sub_C1FF7(a1, "%*s%s:%s", 2 * v81, (__int64)&unk_127230, (__int64)s, ***(_QWORD ***)(8LL * i + v77));
      }
      v83 = 0;
      if ( *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL) )
      {
        sub_DE4D3(a1, &v83, (__int64)&v83, v10, v11, v12);
        sub_E6059(
          a1,
          v81 + 1,
          v79,
          0,
          0,
          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL));
      }
      v13 = 8LL * i;
      if ( *(_BYTE *)(*(_QWORD *)(v13 + v77) + 30LL) )
      {
        if ( *(_BYTE *)(*(_QWORD *)(v13 + v77) + 30LL) == 1 )
        {
          v96 = *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 64LL);
          if ( v96 )
          {
            v82 = v81 + 1;
            v87 = 0;
            while ( 2 )
            {
              if ( !*(_DWORD *)(24LL * v87 + v96) )
              {
                v81 = v82 - 1;
                break;
              }
              switch ( *(_DWORD *)(24LL * v87 + v96) )
              {
                case 1:
                  m = lys_ext_complex_get_substmt(1LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    sub_DE4D3(a1, &v83, (__int64)&v83, v14, v11, v12);
                    if ( *(_DWORD *)(v96 + 16) <= 1u )
                    {
                      v84 = 0;
                      sub_C1FF7(a1, "%*sargument %s", 2 * v82, (__int64)&unk_127230, *(_QWORD *)m, v12);
                      for ( k = -1;
                            ;
                            sub_E6059(
                              a1,
                              v82 + 1,
                              v79,
                              1,
                              0,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k,
                              1u) )
                      {
                        k = sub_9EAFC(
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                              *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                              (unsigned __int8)k + 1,
                              1);
                        if ( k == -1 )
                          break;
                        sub_DE4D3(a1, &v84, (__int64)&v84, v23, v24, v25);
                      }
                      if ( *(_BYTE *)(m + 8) == 1
                        || (unsigned int)sub_9EAFC(
                                           *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                                           *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                                           0,
                                           22) != -1 )
                      {
                        sub_DE4D3(a1, &v84, (__int64)&v84, v23, v24, v25);
                        if ( *(_BYTE *)(m + 8) == 1 )
                          v26 = "true";
                        else
                          v26 = "false";
                        sub_DE71C(
                          a1,
                          v82 + 1,
                          22,
                          0,
                          v26,
                          v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL));
                      }
                      sub_DE519(a1, v82, v84, v82, v24, v25);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)(8LL * l + *(_QWORD *)m); ++l )
                      {
                        v84 = 0;
                        sub_C1FF7(
                          a1,
                          "%*sargument %s",
                          2 * v82,
                          (__int64)&unk_127230,
                          *(_QWORD *)(8LL * l + *(_QWORD *)m),
                          v12);
                        k = -1;
                        while ( 1 )
                        {
                          k = sub_9EAFC(
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                                (unsigned __int8)k + 1,
                                1);
                          if ( k == -1 )
                            break;
                          if ( l == *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                   + *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL))
                                                       + 27LL) )
                          {
                            sub_DE4D3(a1, &v84, (__int64)&v84, v15, v16, v17);
                            sub_E6059(
                              a1,
                              v82 + 1,
                              v79,
                              1,
                              l,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k,
                              1u);
                          }
                        }
                        if ( *(_BYTE *)(*(_QWORD *)(m + 8) + l) == 1 )
                        {
                          sub_DE4D3(a1, &v84, (__int64)&v84, v15, v16, v17);
                          if ( *(_BYTE *)(*(_QWORD *)(m + 8) + l) == 1 )
                            v18 = "true";
                          else
                            v18 = "false";
                          sub_DE71C(
                            a1,
                            v82 + 1,
                            22,
                            (unsigned __int8)l,
                            v18,
                            v79,
                            *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                            *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL));
                        }
                        else
                        {
                          k = -1;
                          while ( 1 )
                          {
                            k = sub_9EAFC(
                                  *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                                  *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                                  (unsigned __int8)k + 1,
                                  22);
                            if ( k == -1 )
                              break;
                            if ( l == *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                     + *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL))
                                                         + 27LL) )
                            {
                              sub_DE4D3(a1, &v84, (__int64)&v84, v22, v19, v20);
                              if ( *(_BYTE *)(*(_QWORD *)(m + 8) + l) == 1 )
                                v21 = "true";
                              else
                                v21 = "false";
                              sub_DE71C(
                                a1,
                                v82 + 1,
                                22,
                                (unsigned __int8)l,
                                v21,
                                v79,
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k,
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL) - k);
                              break;
                            }
                          }
                        }
                        sub_DE519(a1, v82, v84, v82, v19, v20);
                      }
                    }
                  }
                  goto LABEL_237;
                case 2:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                case 0xD:
                case 0xE:
                case 0xF:
                case 0x10:
                case 0x11:
                  sub_E5DFA(a1, v82, v79, *(_QWORD *)(8LL * i + v77), *(_DWORD *)(24LL * v87 + v96), &v83);
                  goto LABEL_237;
                case 3:
                  m = lys_ext_complex_get_substmt(3LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v27, v11, v12);
                      sub_C1FF7(a1, "%*sbelongs-to %s {\n", 2 * v82, (__int64)&unk_127230, *(_QWORD *)m, v31);
                      for ( k = -1;
                            ;
                            sub_E6059(
                              a1,
                              v82 + 1,
                              v79,
                              3,
                              0,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k,
                              1u) )
                      {
                        k = sub_9EAFC(
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                              *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                              (unsigned __int8)k + 1,
                              3);
                        if ( k == -1 )
                          break;
                      }
                      sub_DE71C(
                        a1,
                        v82 + 1,
                        13,
                        0,
                        *(const char **)(m + 8),
                        v79,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                        *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL));
                      sub_C1FF7(a1, "%*s}\n", 2 * v82, (__int64)&unk_127230, v32, v33);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)(8LL * l + *(_QWORD *)m); ++l )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v27, v11, v12);
                        sub_C1FF7(
                          a1,
                          "%*sbelongs-to %s {\n",
                          2 * v82,
                          (__int64)&unk_127230,
                          *(_QWORD *)(8LL * l + *(_QWORD *)m),
                          v28);
                        for ( k = -1;
                              ;
                              sub_E6059(
                                a1,
                                v82 + 1,
                                v79,
                                3,
                                l,
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k,
                                1u) )
                        {
                          k = sub_9EAFC(
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                                (unsigned __int8)k + 1,
                                3);
                          if ( k == -1 )
                            break;
                        }
                        sub_DE71C(
                          a1,
                          v82 + 1,
                          13,
                          (unsigned __int8)l,
                          *(const char **)(8LL * l + *(_QWORD *)(m + 8)),
                          v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL));
                        sub_C1FF7(a1, "%*s}\n", 2 * v82, (__int64)&unk_127230, v29, v30);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x12:
                  v50 = *(_QWORD *)(8LL * i + v77);
                  v97 = (unsigned int **)(v50 + *(_QWORD *)(24LL * v87 + v96 + 8) + 64LL + 8);
                  if ( v97 && *v97 )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v50, v11, v12);
                      sub_DF961(
                        a1,
                        v82,
                        18LL,
                        0LL,
                        (__int64 *)v79,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                        **v97);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v97)[2 * l]; ++l )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v50, v11, v12);
                        sub_DF961(
                          a1,
                          v82,
                          18LL,
                          (unsigned __int8)l,
                          (__int64 *)v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                          **(_DWORD **)&(*v97)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x14:
                  sub_E5CA1(
                    a1,
                    v82,
                    (__int64 *)v79,
                    *(_QWORD *)(8LL * i + v77),
                    0x14u,
                    (__int64)"invert-match",
                    0LL,
                    &v83);
                  goto LABEL_237;
                case 0x15:
                  sub_E5CA1(
                    a1,
                    v82,
                    (__int64 *)v79,
                    *(_QWORD *)(8LL * i + v77),
                    *(_DWORD *)(24LL * v87 + v96),
                    (__int64)"true",
                    (__int64)"false",
                    &v83);
                  goto LABEL_237;
                case 0x17:
                  sub_E5F4E(
                    a1,
                    v82,
                    v79,
                    *(_QWORD *)(8LL * i + v77),
                    0x17u,
                    (__int64)"true",
                    (__int64)"false",
                    5u,
                    6u,
                    &v83);
                  goto LABEL_237;
                case 0x18:
                  sub_E5F4E(
                    a1,
                    v82,
                    v79,
                    *(_QWORD *)(8LL * i + v77),
                    0x18u,
                    (__int64)"false",
                    (__int64)"true",
                    0x80u,
                    0x40u,
                    &v83);
                  goto LABEL_237;
                case 0x19:
                  sub_E5F4E(
                    a1,
                    v82,
                    v79,
                    *(_QWORD *)(8LL * i + v77),
                    0x19u,
                    (__int64)"system",
                    (__int64)"user",
                    0,
                    0x100u,
                    &v83);
                  goto LABEL_237;
                case 0x1A:
                  v98 = (_WORD *)lys_ext_complex_get_substmt(26LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( !v98 || !*v98 )
                    goto LABEL_237;
                  if ( *v98 & 8 )
                  {
                    sub_DE4D3(a1, &v83, (__int64)&v83, v45, v11, v12);
                    v91 = "current";
                  }
                  else if ( *v98 & 0x10 )
                  {
                    sub_DE4D3(a1, &v83, (__int64)&v83, v45, v11, v12);
                    v91 = "deprecated";
                  }
                  else
                  {
                    if ( !(*v98 & 0x20) )
                    {
LABEL_237:
                      ++v87;
                      continue;
                    }
                    sub_DE4D3(a1, &v83, (__int64)&v83, v45, v11, v12);
                    v91 = "obsolete";
                  }
                  sub_DE71C(
                    a1,
                    v82,
                    26,
                    0,
                    v91,
                    v79,
                    *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                    *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL));
                  goto LABEL_237;
                case 0x1B:
                  v46 = *(_QWORD *)(8LL * i + v77);
                  v97 = (unsigned int **)(v46 + *(_QWORD *)(24LL * v87 + v96 + 8) + 64LL + 8);
                  if ( v97 )
                  {
                    if ( *(_DWORD *)(v96 + 16) > 1u && *v97 )
                    {
                      for ( l = 0; *((_BYTE *)*v97 + l); ++l )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v46, v11, v12);
                        sub_DF89A(
                          a1,
                          v82,
                          27LL,
                          (unsigned __int8)l,
                          (__int64 *)v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                          *((unsigned __int8 *)*v97 + l));
                      }
                    }
                    else if ( *(_BYTE *)v97 )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v46, v11, v12);
                      sub_DF89A(
                        a1,
                        v82,
                        27LL,
                        0LL,
                        (__int64 *)v79,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                        *(unsigned __int8 *)v97);
                    }
                  }
                  goto LABEL_237;
                case 0x1C:
                  v47 = *(_QWORD *)(8LL * i + v77);
                  v97 = (unsigned int **)(v47 + *(_QWORD *)(24LL * v87 + v96 + 8) + 64LL + 8);
                  if ( v97 && *v97 )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v47, v11, v12);
                      sub_DF89A(
                        a1,
                        v82,
                        28LL,
                        0LL,
                        (__int64 *)v79,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                        **v97);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v97)[2 * l]; ++l )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v47, v11, v12);
                        sub_DF89A(
                          a1,
                          v82,
                          28LL,
                          (unsigned __int8)l,
                          (__int64 *)v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                          **(_DWORD **)&(*v97)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x1D:
                  v48 = *(_QWORD *)(8LL * i + v77);
                  v97 = (unsigned int **)(v48 + *(_QWORD *)(24LL * v87 + v96 + 8) + 64LL + 8);
                  if ( v97 && *v97 )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v48, v11, v12);
                      sub_DF89A(
                        a1,
                        v82,
                        29LL,
                        0LL,
                        (__int64 *)v79,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                        **v97);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v97)[2 * l]; ++l )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v48, v11, v12);
                        sub_DF89A(
                          a1,
                          v82,
                          29LL,
                          (unsigned __int8)l,
                          (__int64 *)v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                          **(_DWORD **)&(*v97)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x1E:
                  v49 = *(_QWORD *)(8LL * i + v77);
                  v97 = (unsigned int **)(v49 + *(_QWORD *)(24LL * v87 + v96 + 8) + 64LL + 8);
                  if ( v97 && *v97 )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v49, v11, v12);
                      sub_DF89A(
                        a1,
                        v82,
                        30LL,
                        0LL,
                        (__int64 *)v79,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                        **v97);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v97)[2 * l]; ++l )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v49, v11, v12);
                        sub_DF89A(
                          a1,
                          v82,
                          30LL,
                          (unsigned __int8)l,
                          (__int64 *)v79,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                          **(_DWORD **)&(*v97)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x1F:
                  m = lys_ext_complex_get_substmt(31LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v51, v11, v12);
                      sub_E0707(a1, v82, (__int64 *)v79, *(_QWORD *)m, v57, v58);
                      k = -1;
                      v84 = 0;
                      while ( 1 )
                      {
                        k = sub_9EAFC(
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                              *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                              (unsigned __int8)k + 1,
                              31);
                        if ( k == -1 )
                          break;
                        sub_DE4D3(a1, &v84, (__int64)&v84, v59, v60, v61);
                        sub_E6059(a1, v82 + 1, v79, 31, 0, *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k, 1u);
                      }
                      sub_DE519(a1, v82, v84, v82, v60, v61);
                    }
                    else
                    {
                      m = *(_QWORD *)m;
                      l = 0;
                      while ( *(_QWORD *)m )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v51, v11, v12);
                        sub_E0707(a1, v82, (__int64 *)v79, *(_QWORD *)m, v52, v53);
                        k = -1;
                        v84 = 0;
                        do
                          k = sub_9EAFC(
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                                (unsigned __int8)k + 1,
                                31);
                        while ( k != -1
                             && l != *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                    + *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL))
                                                        + 27LL) );
                        if ( k != -1 )
                        {
                          sub_DE4D3(a1, &v84, (__int64)&v84, v54, v55, v56);
                          do
                          {
                            sub_E6059(
                              a1,
                              v82 + 1,
                              v79,
                              31,
                              l,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL) + 8LL * k,
                              1u);
                            do
                              k = sub_9EAFC(
                                    *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL),
                                    *(_BYTE *)(*(_QWORD *)(8LL * i + v77) + 26LL),
                                    (unsigned __int8)k + 1,
                                    31);
                            while ( k != -1
                                 && l != *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                        + *(_QWORD *)(*(_QWORD *)(8LL * i + v77) + 32LL))
                                                            + 27LL) );
                          }
                          while ( k != -1 );
                        }
                        sub_DE519(a1, v82, v84, v82, v55, v56);
                        m += 8LL;
                        ++l;
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x20:
                  m = lys_ext_complex_get_substmt(32LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v62, v11, v12);
                      sub_E4BDA(a1, v82, *(_QWORD *)m);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v62, v11, v12);
                        sub_E4BDA(a1, v82, *(_QWORD *)m);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x21:
                case 0x22:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                  m = lys_ext_complex_get_substmt(*(unsigned int *)(24LL * v87 + v96), *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    for ( n = *(_QWORD *)m; n; n = *(_QWORD *)(n + 80) )
                    {
                      v63 = sub_C1906(*(_DWORD *)(n + 56));
                      if ( v63 == *(_DWORD *)(24LL * v87 + v96) )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v63, v11, v12);
                        sub_E479A(a1, v82, n, 0xFFFFLL, v64, v65);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x2F:
                  m = lys_ext_complex_get_substmt(47LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v35, v11, v12);
                      sub_E1BDF(a1, v82, (__int64 *)v79, *(__int64 **)m, v38, v39);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v35, v11, v12);
                        sub_E1BDF(a1, v82, (__int64 *)v79, *(__int64 **)m, v36, v37);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x30:
                  m = lys_ext_complex_get_substmt(48LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v34, v11, v12);
                      sub_DFA28(a1, v82, (__int64 *)v79, *(_QWORD *)m);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v34, v11, v12);
                        sub_DFA28(a1, v82, (__int64 *)v79, *(_QWORD *)m);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x31:
                  m = lys_ext_complex_get_substmt(49LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v40, v11, v12);
                      sub_DE97F(a1, v82, v79, *(_QWORD *)m, v43, v44);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v40, v11, v12);
                        sub_DE97F(a1, v82, v79, *(_QWORD *)m, v41, v42);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x32:
                  m = lys_ext_complex_get_substmt(50LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v66, v11, v12);
                      sub_DF35D(a1, v82, v79, *(_QWORD *)m, (__int64)"length", **(_QWORD **)m);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v66, v11, v12);
                        sub_DF35D(a1, v82, v79, *(_QWORD *)m, (__int64)"length", **(_QWORD **)m);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x33:
                  m = lys_ext_complex_get_substmt(51LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v67, v11, v12);
                      sub_E0678(a1, v82, (__int64 *)v79, *(const char ***)m);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v67, v11, v12);
                        sub_E0678(a1, v82, (__int64 *)v79, *(const char ***)m);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x34:
                  m = lys_ext_complex_get_substmt(52LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v68, v11, v12);
                      sub_DF35D(a1, v82, v79, *(_QWORD *)m, (__int64)"pattern", **(_QWORD **)m + 1LL);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v68, v11, v12);
                        sub_DF35D(a1, v82, v79, *(_QWORD *)m, (__int64)"pattern", **(_QWORD **)m + 1LL);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x35:
                  m = lys_ext_complex_get_substmt(53LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v69, v11, v12);
                      sub_DF35D(a1, v82, v79, *(_QWORD *)m, (__int64)"range", **(_QWORD **)m);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v69, v11, v12);
                        sub_DF35D(a1, v82, v79, *(_QWORD *)m, (__int64)"range", **(_QWORD **)m);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x36:
                  m = lys_ext_complex_get_substmt(54LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v70, v11, v12);
                      sub_DF66E(a1, v82, (__int64 *)v79, *(const char ***)m);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v70, v11, v12);
                        sub_DF66E(a1, v82, (__int64 *)v79, *(const char ***)m);
                      }
                    }
                  }
                  goto LABEL_237;
                case 0x37:
                  m = lys_ext_complex_get_substmt(55LL, *(_QWORD *)(8LL * i + v77), 0LL);
                  if ( m && *(_QWORD *)m )
                  {
                    if ( *(_DWORD *)(24LL * v87 + v96 + 16) <= 1u )
                    {
                      sub_DE4D3(a1, &v83, (__int64)&v83, v71, v11, v12);
                      sub_E4A49(a1, v82, v79, *(_QWORD *)m, v74, v75);
                    }
                    else
                    {
                      for ( m = *(_QWORD *)m; *(_QWORD *)m; m += 8LL )
                      {
                        sub_DE4D3(a1, &v83, (__int64)&v83, v71, v11, v12);
                        sub_E4A49(a1, v82, v79, *(_QWORD *)m, v72, v73);
                      }
                    }
                  }
                  goto LABEL_237;
                default:
                  goto LABEL_237;
              }
            }
          }
        }
      }
      sub_DE519(a1, v81, v83, v81, v11, v12);
    }
  }
  return __readfsqword(0x28u) ^ v99;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000E8DAF) ----------------------------------------------------
signed __int64 __fastcall sub_E8DAF(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7)
{
  signed __int64 result; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  const char *v15; // rax
  const char *v16; // rax
  __int64 v17; // [rsp+0h] [rbp-30h]
  __int64 v18; // [rsp+8h] [rbp-28h]

  v18 = a5;
  if ( a3 )
    result = sub_C1FF7(a1, "%*s<%s:%s", (unsigned int)(2 * a2), (__int64)&unk_127870, a3, a4, a6);
  else
    result = sub_C1FF7(a1, "%*s<%s", (unsigned int)(2 * a2), (__int64)&unk_127870, a4, a6, a6);
  if ( v18 )
  {
    sub_C1FF7(a1, " %s=\"", v18, v8, v9, v10);
    sub_341EA(a1, v17, 1, v17, v11, v12);
    if ( a7 == -1 )
    {
      v15 = (const char *)&off_12788B;
    }
    else if ( a7 == 1 )
    {
      v15 = ">\n";
    }
    else
    {
      v15 = (const char *)&unk_127870;
    }
    result = sub_C1FF7(a1, (const char *)&unk_12788F, (__int64)v15, a1, v13, v14);
  }
  else if ( a7 )
  {
    if ( a7 == -1 )
      v16 = (const char *)&off_12788B;
    else
      v16 = ">\n";
    result = sub_C1FF7(a1, v16, a1, v8, v9, v10);
  }
  return result;
}
// 12788B: using guessed type void *__ptr32 off_12788B;

//----- (00000000000E8EE6) ----------------------------------------------------
signed __int64 __fastcall sub_E8EE6(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !(_DWORD)a5 )
    return sub_C1FF7(a1, (const char *)&off_12788B, a3, a4, a5, a6, a4);
  if ( a3 )
    return sub_C1FF7(a1, "%*s</%s:%s>\n", (unsigned int)(2 * a2), (__int64)&unk_127870, a3, a4, a4);
  return sub_C1FF7(a1, "%*s</%s>\n", (unsigned int)(2 * a2), (__int64)&unk_127870, a4, a6, a4);
}
// 12788B: using guessed type void *__ptr32 off_12788B;

//----- (00000000000E8F8C) ----------------------------------------------------
signed __int64 __fastcall sub_E8F8C(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax

  if ( a2 )
  {
    result = (unsigned int)*a2;
    if ( !(_DWORD)result )
    {
      *a2 = 1;
      result = sub_C1FF7(a1, ">\n", a3, a4, a5, a6, a2);
    }
  }
  return result;
}

//----- (00000000000E8FD2) ----------------------------------------------------
signed __int64 __fastcall sub_E8FD2(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST08_8
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // ST00_8
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  v6 = a3;
  sub_C1FF7(a1, "%*s<%s>", (unsigned int)(2 * a2), (__int64)&unk_127870, a3, a6, a4);
  sub_341EA(a1, v9, 2, v9, v7, v8);
  return sub_C1FF7(a1, "</%s>\n", v6, v10, v11, v12);
}

//----- (00000000000E904C) ----------------------------------------------------
unsigned __int64 __fastcall sub_E904C(__int64 a1, int a2, int a3, char a4, __int64 a5, __int64 a6, __int64 a7, unsigned __int8 a8)
{
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+8h] [rbp-38h]
  __int64 v13; // [rsp+10h] [rbp-30h]
  char v14; // [rsp+1Ch] [rbp-24h]
  int v15; // [rsp+20h] [rbp-20h]
  unsigned int v16; // [rsp+30h] [rbp-10h]
  int v17; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v18; // [rsp+38h] [rbp-8h]

  v15 = a3;
  v13 = a5;
  v12 = a6;
  v14 = a4;
  v18 = __readfsqword(0x28u);
  v16 = 0;
  if ( a5 )
  {
    if ( *((_DWORD *)&unk_346320 + 6 * a3 + 4) & 1 )
    {
      v16 = 1;
      sub_E8DAF(a1, a2, 0LL, *((_QWORD *)&unk_346320 + 3 * a3), 0LL, 0LL, 1);
    }
    else
    {
      sub_E8DAF(a1, a2, 0LL, *((_QWORD *)&unk_346320 + 3 * a3), *((_QWORD *)&unk_346320 + 3 * a3 + 1), a5, v16);
    }
    v17 = -1;
    do
      v17 = sub_9EAFC(a7, a8, (unsigned __int8)v17 + 1, v15);
    while ( v17 != -1 && v14 != *(_BYTE *)(*(_QWORD *)(8LL * v17 + a7) + 27LL) );
    if ( v17 != -1 )
    {
      sub_E8F8C(a1, &v16, (__int64)&v16, v8, v9, v10);
      do
      {
        sub_F0CAF(a1, a2 + 1, v12, v15, v14, 8LL * v17 + a7, 1u);
        do
          v17 = sub_9EAFC(a7, a8, (unsigned __int8)v17 + 1, v15);
        while ( v17 != -1 && v14 != *(_BYTE *)(*(_QWORD *)(8LL * v17 + a7) + 27LL) );
      }
      while ( v17 != -1 );
    }
    if ( *((_DWORD *)&unk_346320 + 6 * v15 + 4) & 1 )
      sub_E8FD2(a1, a2 + 1, *((_QWORD *)&unk_346320 + 3 * v15 + 1), v13, v9, v10);
    sub_E8EE6(a1, a2, 0LL, *((_QWORD *)&unk_346320 + 3 * v15), v16, v10);
  }
  return __readfsqword(0x28u) ^ v18;
}

//----- (00000000000E933F) ----------------------------------------------------
signed __int64 __fastcall sub_E933F(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v13; // [rsp+0h] [rbp-20h]
  __int64 v14; // [rsp+8h] [rbp-18h]

  v14 = a3;
  sub_C1FF7(a1, "%*s<if-feature name=\"", (unsigned int)(2 * a2), (__int64)&unk_127870, a5, a6, a4);
  sub_C2DA0(a1, v14, (__int64 *)v13, 0);
  if ( !*(_BYTE *)(v13 + 8) )
    return sub_C1FF7(a1, "\"/>\n", v6, v7, v8, v9);
  sub_C1FF7(a1, (const char *)&off_1278CF, v6, v7, v8, v9);
  sub_F0CAF(a1, a2 + 1, v14, 0, 0, *(_QWORD *)(v13 + 24), *(unsigned __int8 *)(v13 + 8));
  return sub_C1FF7(a1, "%*s</if-feature>\n", (unsigned int)(2 * a2), (__int64)&unk_127870, v10, v11);
}
// 1278CF: using guessed type void *__ptr32 off_1278CF;

//----- (00000000000E943A) ----------------------------------------------------
__int64 __fastcall sub_E943A(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 result; // rax
  _DWORD *v9; // [rsp+8h] [rbp-38h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  char v12; // [rsp+20h] [rbp-20h]
  signed int i; // [rsp+34h] [rbp-Ch]
  int v14; // [rsp+34h] [rbp-Ch]
  const char *v15; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v12 = a6;
  v15 = 0LL;
  if ( a6 & 1 && *(_BYTE *)(a3 + 26) )
  {
    sub_E8F8C(a1, a5, (__int64)a5, a4, (__int64)a5, a6);
    sub_F0CAF(a1, a2, v10, 0, 0, *(_QWORD *)(v11 + 32), *(unsigned __int8 *)(v11 + 26));
  }
  if ( v12 & 2 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(v11 + 27); ++i )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E933F(a1, a2, v10, *(_QWORD *)(v11 + 40) + 32LL * i, v6, v7);
    }
  }
  if ( v12 & 4 )
  {
    v14 = sub_9EAFC(*(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26), 0, 23);
    if ( lys_parent(v11) )
    {
      if ( *(_WORD *)(v11 + 24) & 4 || v14 != -1 )
      {
        if ( *(_WORD *)(v11 + 24) & 1 )
        {
          sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
          sub_E904C(a1, a2, 23, 0, (__int64)"true", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
        }
        else if ( *(_WORD *)(v11 + 24) & 2 )
        {
          sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
          sub_E904C(a1, a2, 23, 0, (__int64)"false", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
        }
      }
    }
    else if ( *(_WORD *)(v11 + 24) & 2 )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E904C(a1, a2, 23, 0, (__int64)"false", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else if ( v14 != -1 )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E904C(a1, a2, 23, 0, (__int64)"true", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  if ( v12 & 8 && *(_DWORD *)(v11 + 56) & 0x8026 )
  {
    if ( *(_WORD *)(v11 + 24) & 0x40 )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E904C(a1, a2, 24, 0, (__int64)"true", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else if ( *(_WORD *)(v11 + 24) & 0x80 )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E904C(a1, a2, 24, 0, (__int64)"false", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  if ( v12 & 0x10 )
  {
    if ( *(_WORD *)(v11 + 24) & 8 )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E904C(a1, a2, 26, 0, (__int64)"current", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else if ( *(_WORD *)(v11 + 24) & 0x10 )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      sub_E904C(a1, a2, 26, 0, (__int64)"deprecated", v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else
    {
      if ( *(_WORD *)(v11 + 24) & 0x20 )
      {
        sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
        v15 = "obsolete";
      }
      sub_E904C(a1, a2, 26, 0, (__int64)v15, v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  if ( v12 & 0x20 && *(_QWORD *)(v11 + 8) )
  {
    sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
    sub_E904C(a1, a2, 6, 0, *(_QWORD *)(v11 + 8), v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
  }
  result = v12 & 0x40;
  if ( v12 & 0x40 )
  {
    result = *(_QWORD *)(v11 + 16);
    if ( result )
    {
      sub_E8F8C(a1, v9, (__int64)v9, a4, (__int64)a5, a6);
      result = sub_E904C(a1, a2, 15, 0, *(_QWORD *)(v11 + 16), v10, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000E99DA) ----------------------------------------------------
unsigned __int64 __fastcall sub_E99DA(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  const char *v9; // rax
  __int64 v10; // r9
  __int64 v12; // [rsp+10h] [rbp-38h]
  int v13; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v14; // [rsp+34h] [rbp-14h]
  unsigned int v15; // [rsp+38h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-Ch]
  unsigned __int64 v17; // [rsp+40h] [rbp-8h]

  v12 = (__int64)a3;
  v17 = __readfsqword(0x28u);
  v14 = 0;
  v15 = 0;
  sub_E8DAF(a1, a2, 0LL, (__int64)"extension", (__int64)"name", *a3, 0);
  v13 = a2 + 1;
  sub_E943A(a1, a2 + 1, v12, *(_QWORD *)(v12 + 48), &v14, 1LL);
  if ( *(_QWORD *)(v12 + 40) )
  {
    sub_E8F8C(a1, &v14, (__int64)&v14, v3, v4, v5);
    sub_E8DAF(a1, v13, 0LL, (__int64)"argument", (__int64)"name", *(_QWORD *)(v12 + 40), v15);
    for ( i = -1; ; sub_F0CAF(a1, a2 + 2, *(_QWORD *)(v12 + 48), 1, 0, *(_QWORD *)(v12 + 32) + 8LL * i, 1u) )
    {
      i = sub_9EAFC(*(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26), (unsigned __int8)i + 1, 1);
      if ( i == -1 )
        break;
      sub_E8F8C(a1, &v15, (__int64)&v15, v6, v7, v8);
    }
    if ( *(_WORD *)(v12 + 24) & 1 || (unsigned int)sub_9EAFC(*(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26), 0, 22) != -1 )
    {
      sub_E8F8C(a1, &v15, (__int64)&v15, v6, v7, v8);
      if ( *(_WORD *)(v12 + 24) & 1 )
        v9 = "true";
      else
        v9 = "false";
      sub_E904C(a1, a2 + 2, 22, 0, (__int64)v9, *(_QWORD *)(v12 + 48), *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
    }
    sub_E8EE6(a1, v13, 0LL, (__int64)"argument", v15, v8);
  }
  sub_E943A(a1, v13, v12, *(_QWORD *)(v12 + 48), &v14, 112LL);
  sub_E8EE6(a1, a2, 0LL, (__int64)"extension", v14, v10);
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000E9C9B) ----------------------------------------------------
unsigned __int64 __fastcall sub_E9C9B(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6)
{
  unsigned __int64 result; // rax
  _DWORD *v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+10h] [rbp-20h]
  __int64 v9; // [rsp+18h] [rbp-18h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( *(_BYTE *)(a4 + 48) )
  {
    sub_E8F8C(a1, a5, (__int64)a5, a4, (__int64)a5, a6);
    sub_F0CAF(a1, a2, v9, 0, 0, *(_QWORD *)(v8 + 40), *(unsigned __int8 *)(v8 + 48));
  }
  if ( **(_BYTE **)v8 == 21 )
  {
    sub_E8F8C(a1, v7, (__int64)v7, a4, (__int64)a5, a6);
    sub_E904C(a1, a2, 20, 0, (__int64)"invert-match", v9, *(_QWORD *)(v8 + 40), *(_BYTE *)(v8 + 48));
  }
  if ( *(_QWORD *)(v8 + 32) )
  {
    sub_E8F8C(a1, v7, (__int64)v7, a4, (__int64)a5, a6);
    sub_E904C(a1, a2, 8, 0, *(_QWORD *)(v8 + 32), v9, *(_QWORD *)(v8 + 40), *(_BYTE *)(v8 + 48));
  }
  if ( *(_QWORD *)(v8 + 24) )
  {
    sub_E8F8C(a1, v7, (__int64)v7, a4, (__int64)a5, a6);
    sub_E904C(a1, a2, 7, 0, *(_QWORD *)(v8 + 24), v9, *(_QWORD *)(v8 + 40), *(_BYTE *)(v8 + 48));
  }
  if ( *(_QWORD *)(v8 + 8) )
  {
    sub_E8F8C(a1, v7, (__int64)v7, a4, (__int64)a5, a6);
    sub_E904C(a1, a2, 6, 0, *(_QWORD *)(v8 + 8), v9, *(_QWORD *)(v8 + 40), *(_BYTE *)(v8 + 48));
  }
  result = *(_QWORD *)(v8 + 16);
  if ( result )
  {
    sub_E8F8C(a1, v7, (__int64)v7, a4, (__int64)a5, a6);
    result = sub_E904C(a1, a2, 15, 0, *(_QWORD *)(v8 + 16), v9, *(_QWORD *)(v8 + 40), *(_BYTE *)(v8 + 48));
  }
  return result;
}

//----- (00000000000E9F06) ----------------------------------------------------
unsigned __int64 __fastcall sub_E9F06(__int64 a1, int a2, __int64 a3, _BYTE **a4, __int64 a5)
{
  _BYTE *v5; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v9; // [rsp+8h] [rbp-38h]
  _BYTE **v10; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  unsigned int v12; // [rsp+30h] [rbp-10h]
  int v13; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v14 = __readfsqword(0x28u);
  v12 = 0;
  v13 = 0;
  if ( **a4 == 6 || **a4 == 21 )
    v13 = 1;
  if ( v13 )
    v5 = *a4 + 1;
  else
    v5 = *a4;
  sub_E8DAF(a1, a2, 0LL, a5, (__int64)"value", (__int64)v5, v12);
  sub_E9C9B(a1, a2 + 1, v11, (__int64)v10, &v12, v6);
  sub_E8EE6(a1, a2, 0LL, v9, v12, v7);
  return __readfsqword(0x28u) ^ v14;
}

//----- (00000000000EA002) ----------------------------------------------------
unsigned __int64 __fastcall sub_EA002(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // ST18_8
  __int64 v4; // r9
  unsigned int v6; // [rsp+2Ch] [rbp-Ch]
  unsigned __int64 v7; // [rsp+30h] [rbp-8h]

  v3 = (__int64)a3;
  v7 = __readfsqword(0x28u);
  v6 = 0;
  sub_E8DAF(a1, a2, 0LL, (__int64)"feature", (__int64)"name", *a3, 0);
  sub_E943A(a1, a2 + 1, v3, *(_QWORD *)(v3 + 48), &v6, 115LL);
  sub_E8EE6(a1, a2, 0LL, (__int64)"feature", v6, v4);
  return __readfsqword(0x28u) ^ v7;
}

//----- (00000000000EA0C6) ----------------------------------------------------
unsigned __int64 __fastcall sub_EA0C6(__int64 a1, int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  const char **v18; // [rsp+0h] [rbp-40h]
  __int64 v19; // [rsp+0h] [rbp-40h]
  __int64 *v20; // [rsp+8h] [rbp-38h]
  int v21; // [rsp+14h] [rbp-2Ch]
  unsigned int v22; // [rsp+2Ch] [rbp-14h]
  __int64 v23; // [rsp+30h] [rbp-10h]
  unsigned __int64 v24; // [rsp+38h] [rbp-8h]

  v20 = a3;
  v18 = a4;
  v24 = __readfsqword(0x28u);
  v22 = 0;
  v23 = sub_9182(a3, *a4);
  if ( v23 )
  {
    sub_C1FF7(a1, "%*s<when condition=\"", (unsigned int)(2 * a2), (__int64)&unk_127870, v6, v7, v18);
    sub_341EA(a1, v23, 1, v23, v8, v9);
    sub_C1FF7(a1, "\"", v10, v11, v12, v13);
    lydict_remove(*v20, v23);
    v21 = a2 + 1;
    if ( *(_BYTE *)(v19 + 32) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v14, v15, v16);
      sub_F0CAF(a1, v21, (__int64)v20, 0, 0, *(_QWORD *)(v19 + 24), *(unsigned __int8 *)(v19 + 32));
    }
    if ( *(_QWORD *)(v19 + 8) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v14, v15, v16);
      sub_E904C(a1, v21, 6, 0, *(_QWORD *)(v19 + 8), (__int64)v20, *(_QWORD *)(v19 + 24), *(_BYTE *)(v19 + 32));
    }
    if ( *(_QWORD *)(v19 + 16) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v14, v15, v16);
      sub_E904C(a1, v21, 15, 0, *(_QWORD *)(v19 + 16), (__int64)v20, *(_QWORD *)(v19 + 24), *(_BYTE *)(v19 + 32));
    }
    sub_E8EE6(a1, a2, 0LL, (__int64)"when", v22, v16);
  }
  else
  {
    sub_C1FF7(a1, "(!error!)", v4, v5, v6, v7, v18, v20);
  }
  return __readfsqword(0x28u) ^ v24;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EA2FF) ----------------------------------------------------
unsigned __int64 __fastcall sub_EA2FF(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8)
{
  __int64 v8; // r9
  __int64 v10; // [rsp+8h] [rbp-38h]
  __int64 *v11; // [rsp+10h] [rbp-30h]
  char v12; // [rsp+1Ch] [rbp-24h]
  int v13; // [rsp+20h] [rbp-20h]
  char *ptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v15; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a5;
  v10 = a6;
  v12 = a4;
  v15 = __readfsqword(0x28u);
  if ( asprintf(&ptr, off_12796A, a8) == -1 )
  {
    sub_12222(*v11, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_print_unsigned", v8);
  }
  else
  {
    sub_E904C(a1, a2, v13, v12, (__int64)ptr, (__int64)v11, v10, a7);
    free(ptr);
  }
  return __readfsqword(0x28u) ^ v15;
}

//----- (00000000000EA3C7) ----------------------------------------------------
unsigned __int64 __fastcall sub_EA3C7(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8)
{
  __int64 v8; // r9
  __int64 v10; // [rsp+8h] [rbp-38h]
  __int64 *v11; // [rsp+10h] [rbp-30h]
  char v12; // [rsp+1Ch] [rbp-24h]
  int v13; // [rsp+20h] [rbp-20h]
  char *ptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v15; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a5;
  v10 = a6;
  v12 = a4;
  v15 = __readfsqword(0x28u);
  if ( asprintf(&ptr, "%d", a8) == -1 )
  {
    sub_12222(*v11, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_print_signed", v8);
  }
  else
  {
    sub_E904C(a1, a2, v13, v12, (__int64)ptr, (__int64)v11, v10, a7);
    free(ptr);
  }
  return __readfsqword(0x28u) ^ v15;
}

//----- (00000000000EA48F) ----------------------------------------------------
unsigned __int64 __fastcall sub_EA48F(__int64 a1, int a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rax
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v25; // [rsp+0h] [rbp-60h]
  __int64 *v26; // [rsp+8h] [rbp-58h]
  int v27; // [rsp+14h] [rbp-4Ch]
  unsigned int v28; // [rsp+24h] [rbp-3Ch]
  unsigned int v29; // [rsp+28h] [rbp-38h]
  unsigned int i; // [rsp+2Ch] [rbp-34h]
  char *ptr; // [rsp+30h] [rbp-30h]
  __int64 v32; // [rsp+38h] [rbp-28h]
  __int64 v33; // [rsp+40h] [rbp-20h]
  unsigned __int64 v34; // [rsp+48h] [rbp-18h]

  v26 = a3;
  v25 = a4;
  v34 = __readfsqword(0x28u);
  v28 = 0;
  v29 = 0;
  if ( (unsigned int)sub_A6074(a4) )
  {
    sub_E8DAF(a1, a2, 0LL, (__int64)"type", (__int64)"name", **(_QWORD **)(v25 + 16), v28);
  }
  else
  {
    v4 = **(_QWORD **)(v25 + 16);
    v5 = lys_main_module(*(_QWORD *)(*(_QWORD *)(v25 + 16) + 48LL));
    v6 = sub_831C((__int64)v26, *(const char **)(v5 + 8));
    sub_C1FF7(a1, "%*s<type name=\"%s:%s\"", (unsigned int)(2 * a2), (__int64)&unk_127870, v6, v4, v25);
  }
  v27 = a2 + 1;
  if ( *(_BYTE *)(v25 + 5) )
  {
    sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
    sub_F0CAF(a1, v27, (__int64)v26, 0, 0, *(_QWORD *)(v25 + 8), *(unsigned __int8 *)(v25 + 5));
  }
  switch ( *(_DWORD *)v25 )
  {
    case 1:
      if ( *(_QWORD *)(v25 + 32) )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E9F06(a1, v27, (__int64)v26, *(_BYTE ***)(v25 + 32), (__int64)"length");
      }
      break;
    case 2:
      for ( i = 0; i < *(_DWORD *)(v25 + 40); ++i )
      {
        v29 = 0;
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E8DAF(a1, v27, 0LL, (__int64)"bit", (__int64)"name", *(_QWORD *)(*(_QWORD *)(v25 + 32) + 48LL * i), v29);
        sub_E943A(a1, a2 + 2, *(_QWORD *)(v25 + 32) + 48LL * i, (__int64)v26, &v29, 3LL);
        v12 = *(_QWORD *)(v25 + 32);
        if ( !(*(_WORD *)(v12 + 48LL * i + 24) & 1) )
        {
          sub_E8F8C(a1, &v29, (__int64)&v29, v12, v10, v11);
          sub_EA2FF(
            a1,
            a2 + 2,
            30LL,
            0LL,
            v26,
            *(_QWORD *)(*(_QWORD *)(v25 + 32) + 48LL * i + 32),
            *(unsigned __int8 *)(*(_QWORD *)(v25 + 32) + 48LL * i + 26),
            *(_DWORD *)(*(_QWORD *)(v25 + 32) + 48LL * i + 28));
        }
        sub_E943A(a1, a2 + 2, *(_QWORD *)(v25 + 32) + 48LL * i, (__int64)v26, &v29, 112LL);
        sub_E8EE6(a1, v27, 0LL, (__int64)"bit", v29, v13);
      }
      break;
    case 4:
      if ( !*(_QWORD *)(*(_QWORD *)(v25 + 16) + 72LL) )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_EA2FF(
          a1,
          v27,
          27LL,
          0LL,
          v26,
          *(_QWORD *)(v25 + 8),
          *(unsigned __int8 *)(v25 + 5),
          *(unsigned __int8 *)(v25 + 40));
      }
      if ( *(_QWORD *)(v25 + 32) )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E9F06(a1, v27, (__int64)v26, *(_BYTE ***)(v25 + 32), (__int64)"range");
      }
      break;
    case 6:
      for ( i = 0; i < *(_DWORD *)(v25 + 40); ++i )
      {
        v29 = 0;
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E8DAF(a1, v27, 0LL, (__int64)"enum", (__int64)"name", *(_QWORD *)(*(_QWORD *)(v25 + 32) + 48LL * i), v29);
        sub_E943A(a1, a2 + 2, *(_QWORD *)(v25 + 32) + 48LL * i, (__int64)v26, &v29, 3LL);
        v16 = *(_QWORD *)(v25 + 32);
        if ( !(*(_WORD *)(v16 + 48LL * i + 24) & 1) )
        {
          sub_E8F8C(a1, &v29, (__int64)&v29, v16, v14, v15);
          sub_EA3C7(
            a1,
            a2 + 2,
            18LL,
            0LL,
            v26,
            *(_QWORD *)(*(_QWORD *)(v25 + 32) + 48LL * i + 32),
            *(unsigned __int8 *)(*(_QWORD *)(v25 + 32) + 48LL * i + 26),
            *(_DWORD *)(*(_QWORD *)(v25 + 32) + 48LL * i + 28));
        }
        sub_E943A(a1, a2 + 2, *(_QWORD *)(v25 + 32) + 48LL * i, (__int64)v26, &v29, 112LL);
        sub_E8EE6(a1, v27, 0LL, (__int64)"enum", v29, v17);
      }
      break;
    case 7:
      if ( *(_DWORD *)(v25 + 40) )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        for ( i = 0; i < *(_DWORD *)(v25 + 40); ++i )
        {
          v33 = lys_main_module(*(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 32)) + 48LL));
          v18 = lys_main_module(v26);
          if ( v33 == v18 )
          {
            sub_E904C(
              a1,
              v27,
              2,
              0,
              **(_QWORD **)(8LL * i + *(_QWORD *)(v25 + 32)),
              (__int64)v26,
              *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 32)) + 32LL),
              *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 32)) + 26LL));
          }
          else
          {
            v19 = **(_QWORD **)(8LL * i + *(_QWORD *)(v25 + 32));
            v20 = sub_831C((__int64)v26, *(const char **)(v33 + 8));
            if ( asprintf(&ptr, "%s:%s", v20, v19) == -1 )
            {
              sub_12222(*v26, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_print_type", v21, v25);
            }
            else
            {
              sub_E904C(
                a1,
                v27,
                2,
                0,
                (__int64)ptr,
                (__int64)v26,
                *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 32)) + 32LL),
                *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 32)) + 26LL));
              free(ptr);
            }
          }
        }
      }
      break;
    case 8:
      if ( *(_BYTE *)(v25 + 32) == 1 )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E904C(a1, v27, 21, 0, (__int64)"true", (__int64)v26, *(_QWORD *)(v25 + 8), *(_BYTE *)(v25 + 5));
      }
      else if ( *(_BYTE *)(v25 + 32) == -1 )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E904C(a1, v27, 21, 0, (__int64)"false", (__int64)v26, *(_QWORD *)(v25 + 8), *(_BYTE *)(v25 + 5));
      }
      break;
    case 9:
      if ( (unsigned int)sub_C462(**(_BYTE ***)(v25 + 16), "leafref") )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v22, v23, v9);
        v32 = sub_9182(v26, *(const char **)(v25 + 32));
        sub_E904C(a1, v27, 12, 0, v32, (__int64)v26, *(_QWORD *)(v25 + 8), *(_BYTE *)(v25 + 5));
        lydict_remove(*v26, v32);
      }
      if ( *(_BYTE *)(v25 + 48) == 1 )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v22, v23, v9);
        sub_E904C(a1, v27, 21, 0, (__int64)"true", (__int64)v26, *(_QWORD *)(v25 + 8), *(_BYTE *)(v25 + 5));
      }
      else if ( *(_BYTE *)(v25 + 48) == -1 )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v22, v23, v9);
        sub_E904C(a1, v27, 21, 0, (__int64)"false", (__int64)v26, *(_QWORD *)(v25 + 8), *(_BYTE *)(v25 + 5));
      }
      break;
    case 0xA:
      if ( *(_QWORD *)(v25 + 32) )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E9F06(a1, v27, (__int64)v26, *(_BYTE ***)(v25 + 32), (__int64)"length");
      }
      for ( i = 0; i < *(_DWORD *)(v25 + 48); ++i )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E9F06(a1, v27, (__int64)v26, (_BYTE **)(56LL * i + *(_QWORD *)(v25 + 40)), (__int64)"pattern");
      }
      break;
    case 0xB:
      for ( i = 0; i < *(_DWORD *)(v25 + 40); ++i )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_EA48F(a1, v27, v26, *(_QWORD *)(v25 + 32) + ((unsigned __int64)i << 6));
      }
      break;
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      if ( *(_QWORD *)(v25 + 32) )
      {
        sub_E8F8C(a1, &v28, (__int64)&v28, v7, v8, v9);
        sub_E9F06(a1, v27, (__int64)v26, *(_BYTE ***)(v25 + 32), (__int64)"range");
      }
      break;
    default:
      break;
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"type", v28, v9);
  return __readfsqword(0x28u) ^ v34;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EB0CE) ----------------------------------------------------
unsigned __int64 __fastcall sub_EB0CE(__int64 a1, int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // ST00_8
  __int64 v16; // r9
  const char **v18; // [rsp+0h] [rbp-40h]
  __int64 *v19; // [rsp+8h] [rbp-38h]
  unsigned int v20; // [rsp+2Ch] [rbp-14h]
  __int64 v21; // [rsp+30h] [rbp-10h]
  unsigned __int64 v22; // [rsp+38h] [rbp-8h]

  v19 = a3;
  v18 = a4;
  v22 = __readfsqword(0x28u);
  v20 = 0;
  v21 = sub_9182(a3, *a4);
  if ( v21 )
  {
    sub_C1FF7(a1, "%*s<must condition=\"", (unsigned int)(2 * a2), (__int64)&unk_127870, v6, v7, v18);
    sub_341EA(a1, v21, 1, v21, v8, v9);
    sub_C1FF7(a1, "\"", v10, v11, v12, v13);
    lydict_remove(*v19, v21);
    sub_E9C9B(a1, a2 + 1, (__int64)v19, v15, &v20, v14);
    sub_E8EE6(a1, a2, 0LL, (__int64)"must", v20, v16);
  }
  else
  {
    sub_C1FF7(a1, "(!error!)", v4, v5, v6, v7, v18, v19);
  }
  return __readfsqword(0x28u) ^ v22;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EB1FC) ----------------------------------------------------
signed __int64 __fastcall sub_EB1FC(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  __int64 v14; // [rsp+0h] [rbp-30h]
  __int64 *v15; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+24h] [rbp-Ch]
  __int64 v17; // [rsp+28h] [rbp-8h]

  v15 = a3;
  sub_C1FF7(a1, "%*s<unique tag=\"", (unsigned int)(2 * a2), (__int64)&unk_127870, a5, a6, a4);
  for ( i = 0; i < *(unsigned __int8 *)(v14 + 8); ++i )
  {
    v17 = sub_9182(v15, *(const char **)(8LL * i + *(_QWORD *)v14));
    if ( i + 1 >= *(unsigned __int8 *)(v14 + 8) )
      v12 = (const char *)&unk_127870;
    else
      v12 = " ";
    sub_C1FF7(a1, "%s%s", v17, (__int64)v12, v10, v11);
    lydict_remove(*v15, v17);
  }
  return sub_C1FF7(a1, "\"", v6, v7, v8, v9);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EB2F8) ----------------------------------------------------
unsigned __int64 __fastcall sub_EB2F8(__int64 a1, int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r9
  const char **v9; // [rsp+0h] [rbp-40h]
  __int64 *v10; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+14h] [rbp-2Ch]
  unsigned int v12; // [rsp+28h] [rbp-18h]
  int i; // [rsp+2Ch] [rbp-14h]
  __int64 v14; // [rsp+30h] [rbp-10h]
  unsigned __int64 v15; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v15 = __readfsqword(0x28u);
  v12 = 0;
  v14 = sub_912E(a3, *a4, 0, 0LL, 0LL, 0LL);
  sub_E8DAF(a1, a2, 0LL, (__int64)"refine", (__int64)"target-node", v14, 0);
  lydict_remove(*v10, v14);
  v11 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v9, (__int64)v10, &v12, 3LL);
  for ( i = 0; i < *((unsigned __int8 *)v9 + 30); ++i )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_EB0CE(a1, v11, v10, (const char **)&v9[7][56 * i]);
  }
  if ( *((_WORD *)v9 + 14) == 1 && v9[9] )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_E904C(a1, v11, 14, 0, (__int64)v9[9], (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
  }
  for ( i = 0; i < *((unsigned __int8 *)v9 + 31); ++i )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_E904C(a1, v11, 5, i, *(_QWORD *)&v9[8][8 * i], (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
  }
  if ( (_WORD)v9[3] & 1 )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_E904C(a1, v11, 23, 0, (__int64)"true", (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
  }
  else if ( (_WORD)v9[3] & 2 )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_E904C(a1, v11, 23, 0, (__int64)"false", (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
  }
  if ( (_WORD)v9[3] & 0x40 )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_E904C(a1, v11, 24, 0, (__int64)"true", (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
  }
  else if ( (_WORD)v9[3] & 0x80 )
  {
    sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
    sub_E904C(a1, v11, 24, 0, (__int64)"false", (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
  }
  if ( *((_WORD *)v9 + 14) & 0x18 )
  {
    if ( (_WORD)v9[3] & 0x10 )
    {
      sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
      sub_EA2FF(a1, v11, 29LL, 0LL, v10, (__int64)v9[4], *((unsigned __int8 *)v9 + 26), *((_DWORD *)v9 + 18));
    }
    if ( (_WORD)v9[3] & 8 )
    {
      sub_E8F8C(a1, &v12, (__int64)&v12, v4, v5, v6);
      if ( *((_DWORD *)v9 + 19) )
        sub_EA2FF(a1, v11, 28LL, 0LL, v10, (__int64)v9[4], *((unsigned __int8 *)v9 + 26), *((_DWORD *)v9 + 19));
      else
        sub_E904C(a1, v11, 28, 0, (__int64)"unbounded", (__int64)v10, (__int64)v9[4], *((_BYTE *)v9 + 26));
    }
  }
  sub_E943A(a1, v11, (__int64)v9, (__int64)v10, &v12, 96LL);
  sub_E8EE6(a1, a2, 0LL, (__int64)"refine", v12, v7);
  return __readfsqword(0x28u) ^ v15;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EB84B) ----------------------------------------------------
unsigned __int64 __fastcall sub_EB84B(__int64 a1, int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  const char **v18; // [rsp+0h] [rbp-40h]
  __int64 *v19; // [rsp+8h] [rbp-38h]
  int v20; // [rsp+14h] [rbp-2Ch]
  int v21; // [rsp+14h] [rbp-2Ch]
  unsigned int v22; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  int j; // [rsp+28h] [rbp-18h]
  int v25; // [rsp+2Ch] [rbp-14h]
  __int64 v26; // [rsp+30h] [rbp-10h]
  unsigned __int64 v27; // [rsp+38h] [rbp-8h]

  v19 = a3;
  v18 = a4;
  v27 = __readfsqword(0x28u);
  v26 = sub_9182(a3, *a4);
  sub_E8DAF(a1, a2, 0LL, (__int64)"deviation", (__int64)"target-node", v26, 1);
  lydict_remove(*v19, v26);
  v20 = a2 + 1;
  if ( *((_BYTE *)v18 + 33) )
    sub_F0CAF(a1, v20, (__int64)v19, 0, 0, (__int64)v18[6], *((unsigned __int8 *)v18 + 33));
  sub_E904C(a1, v20, 6, 0, (__int64)v18[1], (__int64)v19, (__int64)v18[6], *((_BYTE *)v18 + 33));
  sub_E904C(a1, v20, 15, 0, (__int64)v18[2], (__int64)v19, (__int64)v18[6], *((_BYTE *)v18 + 33));
  for ( i = 0; i < *((unsigned __int8 *)v18 + 32); ++i )
  {
    sub_C1FF7(a1, "%*s<deviate value=", (unsigned int)(2 * v20), (__int64)&unk_127870, v4, v5, v18);
    if ( *(_DWORD *)&v18[5][72 * i] )
    {
      v9 = (__int64)v18[5];
      if ( *(_DWORD *)(v9 + 72LL * i) == 1 )
      {
        sub_C1FF7(a1, "\"add\">\n", i, v9, v6, v7);
      }
      else
      {
        v10 = (__int64)v18[5];
        if ( *(_DWORD *)(v10 + 72LL * i) == 2 )
        {
          sub_C1FF7(a1, "\"replace\">\n", i, v10, v6, v7);
        }
        else
        {
          v11 = (__int64)v18[5];
          if ( *(_DWORD *)(v11 + 72LL * i) == 3 )
            sub_C1FF7(a1, "\"delete\">\n", i, v11, v6, v7);
        }
      }
    }
    else
    {
      v8 = (__int64)v18[5];
      if ( !*(_BYTE *)(v8 + 72LL * i + 6) )
      {
        sub_C1FF7(a1, "\"not-supported\"/>\n", i, v8, v6, v7);
        continue;
      }
      sub_C1FF7(a1, "\"not-supported\">\n", i, v8, v6, v7);
    }
    v21 = v20 + 1;
    if ( v18[5][72 * i + 6] )
      sub_F0CAF(a1, v21, (__int64)v19, 0, 0, *(_QWORD *)&v18[5][72 * i + 64], (unsigned __int8)v18[5][72 * i + 6]);
    if ( *(_QWORD *)&v18[5][72 * i + 40] )
      sub_EA48F(a1, v21, v19, *(_QWORD *)&v18[5][72 * i + 40]);
    sub_E904C(
      a1,
      v21,
      17,
      0,
      *(_QWORD *)&v18[5][72 * i + 48],
      (__int64)v19,
      *(_QWORD *)&v18[5][72 * i + 64],
      v18[5][72 * i + 6]);
    for ( j = 0; j < (unsigned __int8)v18[5][72 * i + 9]; ++j )
      sub_EB0CE(a1, v21, v19, (const char **)(56LL * j + *(_QWORD *)&v18[5][72 * i + 24]));
    for ( j = 0; j < (unsigned __int8)v18[5][72 * i + 10]; ++j )
    {
      sub_EB1FC(a1, v21, v19, *(_QWORD *)&v18[5][72 * i + 32] + 16LL * j, v12, v13);
      v22 = 0;
      v25 = -1;
      do
      {
        v25 = sub_9EAFC(*(_QWORD *)&v18[5][72 * i + 64], v18[5][72 * i + 6], (unsigned __int8)v25 + 1, 31);
        if ( v25 == -1 )
          break;
        v14 = (__int64)v18[5];
      }
      while ( j != *(unsigned __int8 *)(*(_QWORD *)(8LL * v25 + *(_QWORD *)(v14 + 72LL * i + 64)) + 27LL) );
      if ( v25 != -1 )
      {
        sub_E8F8C(a1, &v22, (__int64)&v22, v14, v15, v16);
        do
        {
          sub_F0CAF(a1, v21 + 1, (__int64)v19, 31, j, *(_QWORD *)&v18[5][72 * i + 64] + 8LL * v25, 1u);
          do
            v25 = sub_9EAFC(*(_QWORD *)&v18[5][72 * i + 64], v18[5][72 * i + 6], (unsigned __int8)v25 + 1, 31);
          while ( v25 != -1
               && j != *(unsigned __int8 *)(*(_QWORD *)(8LL * v25 + *(_QWORD *)&v18[5][72 * i + 64]) + 27LL) );
        }
        while ( v25 != -1 );
      }
      sub_E8EE6(a1, v21, 0LL, (__int64)"unique", v22, v16);
    }
    for ( j = 0; j < (unsigned __int8)v18[5][72 * i + 5]; ++j )
      sub_E904C(
        a1,
        v21,
        5,
        j,
        *(_QWORD *)(8LL * j + *(_QWORD *)&v18[5][72 * i + 56]),
        (__int64)v19,
        *(_QWORD *)&v18[5][72 * i + 64],
        v18[5][72 * i + 6]);
    if ( v18[5][72 * i + 4] & 1 )
    {
      sub_E904C(a1, v21, 23, 0, (__int64)"true", (__int64)v19, *((_QWORD *)v18[5] + 8), v18[5][72 * i + 6]);
    }
    else if ( v18[5][72 * i + 4] & 2 )
    {
      sub_E904C(a1, v21, 23, 0, (__int64)"false", (__int64)v19, *((_QWORD *)v18[5] + 8), v18[5][72 * i + 6]);
    }
    if ( v18[5][72 * i + 4] & 0x40 )
    {
      sub_E904C(a1, v21, 24, 0, (__int64)"true", (__int64)v19, *(_QWORD *)&v18[5][72 * i + 64], v18[5][72 * i + 6]);
    }
    else if ( v18[5][72 * i + 4] < 0 )
    {
      sub_E904C(a1, v21, 24, 0, (__int64)"false", (__int64)v19, *(_QWORD *)&v18[5][72 * i + 64], v18[5][72 * i + 6]);
    }
    if ( v18[5][72 * i + 7] )
      sub_EA2FF(
        a1,
        v21,
        29LL,
        0LL,
        v19,
        *(_QWORD *)&v18[5][72 * i + 64],
        (unsigned __int8)v18[5][72 * i + 6],
        *(_DWORD *)&v18[5][72 * i + 12]);
    if ( v18[5][72 * i + 8] )
    {
      if ( *(_DWORD *)&v18[5][72 * i + 16] )
        sub_EA2FF(
          a1,
          v21,
          28LL,
          0LL,
          v19,
          *(_QWORD *)&v18[5][72 * i + 64],
          (unsigned __int8)v18[5][72 * i + 6],
          *(_DWORD *)&v18[5][72 * i + 16]);
      else
        sub_E904C(
          a1,
          v21,
          28,
          0,
          (__int64)"unbounded",
          (__int64)v19,
          *(_QWORD *)&v18[5][72 * i + 64],
          v18[5][72 * i + 6]);
    }
    v20 = v21 - 1;
    sub_E8EE6(a1, v20, 0LL, (__int64)"deviate", 1LL, v13);
  }
  sub_E8EE6(a1, v20 - 1, 0LL, (__int64)"deviation", 1LL, v5);
  return __readfsqword(0x28u) ^ v27;
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EC5A5) ----------------------------------------------------
signed __int64 __fastcall sub_EC5A5(__int64 a1, int a2, __int64 *a3, const char **a4)
{
  __int64 v4; // ST38_8
  __int64 v5; // r8
  __int64 v6; // r9
  const char **v8; // [rsp+0h] [rbp-30h]
  __int64 *v9; // [rsp+8h] [rbp-28h]
  int v10; // [rsp+14h] [rbp-1Ch]
  __int64 i; // [rsp+20h] [rbp-10h]

  v9 = a3;
  v8 = a4;
  v4 = sub_9182(a3, *a4);
  sub_E8DAF(a1, a2, 0LL, (__int64)"augment", (__int64)"target-node", v4, 1);
  lydict_remove(*v9, v4);
  v10 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v8, (__int64)v8[6], 0LL, 1LL);
  if ( v8[10] )
    sub_EA0C6(a1, v10, v9, (const char **)v8[10]);
  sub_E943A(a1, v10, (__int64)v8, (__int64)v8[6], 0LL, 114LL);
  for ( i = (__int64)v8[9]; i; i = *(_QWORD *)(i + 80) )
  {
    if ( v8 == *(const char ***)(i + 64) )
      sub_EF3B4(a1, v10, i, 0xD0FFu, v5, v6);
  }
  return sub_E8EE6(a1, a2, 0LL, (__int64)"augment", 1LL, v6);
}
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EC70B) ----------------------------------------------------
signed __int64 __fastcall sub_EC70B(__int64 a1, int a2, __int64 *a3, __int64 *a4)
{
  char *v4; // rax
  char *v5; // rax
  __int64 v6; // r9
  __int64 *v8; // [rsp+8h] [rbp-30h]
  __int64 *v9; // [rsp+10h] [rbp-28h]
  int v10; // [rsp+1Ch] [rbp-1Ch]
  __int64 v11; // [rsp+30h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  sub_E8DAF(a1, a2, 0LL, (__int64)"typedef", (__int64)"name", *a4, 1);
  v10 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v8, (__int64)v9, 0LL, 1LL);
  sub_EA48F(a1, a2 + 1, v9, (__int64)(v8 + 7));
  if ( v8[5] )
    sub_E904C(a1, v10, 17, 0, v8[5], (__int64)v9, v8[4], *((_BYTE *)v8 + 26));
  if ( v8[15] )
  {
    if ( v8[3] & 0x1000 )
    {
      if ( !strchr((const char *)v8[15], 58) )
        __assert_fail(
          "strchr(tpdf->dflt, ':')",
          "/home/mantovan/Repositories/libyang/src/printer_yin.c",
          0x36Bu,
          "yin_print_typedef");
      v4 = strchr((const char *)v8[15], 58);
      if ( !strncmp((const char *)v8[15], (const char *)v9[1], (size_t)&v4[-v8[15]]) )
      {
        v5 = strchr((const char *)v8[15], 58);
        v11 = lydict_insert(*v9, v5 + 1, 0LL);
      }
      else
      {
        v11 = sub_9182(v9, (const char *)v8[15]);
      }
      sub_E904C(a1, v10, 5, 0, v11, (__int64)v9, v8[4], *((_BYTE *)v8 + 26));
    }
    else
    {
      v11 = v8[15];
      sub_E904C(a1, v10, 5, 0, v11, (__int64)v9, v8[4], *((_BYTE *)v8 + 26));
    }
    if ( v8[3] & 0x1000 )
      lydict_remove(*v9, v11);
  }
  sub_E943A(a1, v10, (__int64)v8, (__int64)v9, 0LL, 112LL);
  return sub_E8EE6(a1, a2, 0LL, (__int64)"typedef", 1LL, v6);
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EC9A9) ----------------------------------------------------
unsigned __int64 __fastcall sub_EC9A9(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v12; // [rsp+10h] [rbp-48h]
  int v13; // [rsp+1Ch] [rbp-3Ch]
  unsigned int v14; // [rsp+28h] [rbp-30h]
  int i; // [rsp+2Ch] [rbp-2Ch]
  char *ptr; // [rsp+30h] [rbp-28h]
  __int64 v17; // [rsp+38h] [rbp-20h]
  unsigned __int64 v18; // [rsp+40h] [rbp-18h]

  v12 = (__int64)a3;
  v18 = __readfsqword(0x28u);
  v14 = 0;
  sub_E8DAF(a1, a2, 0LL, (__int64)"identity", (__int64)"name", *a3, 0);
  v13 = a2 + 1;
  sub_E943A(a1, a2 + 1, v12, *(_QWORD *)(v12 + 48), &v14, 3LL);
  for ( i = 0; i < *(unsigned __int8 *)(v12 + 31); ++i )
  {
    sub_E8F8C(a1, &v14, (__int64)&v14, v3, v4, v5);
    v17 = lys_main_module(*(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v12 + 56)) + 48LL));
    v6 = lys_main_module(*(_QWORD *)(v12 + 48));
    if ( v17 == v6 )
    {
      sub_E904C(
        a1,
        v13,
        2,
        i,
        **(_QWORD **)(8LL * i + *(_QWORD *)(v12 + 56)),
        *(_QWORD *)(v12 + 48),
        *(_QWORD *)(v12 + 32),
        *(_BYTE *)(v12 + 26));
    }
    else
    {
      v7 = **(_QWORD **)(8LL * i + *(_QWORD *)(v12 + 56));
      v8 = sub_831C(*(_QWORD *)(v12 + 48), *(const char **)(v17 + 8));
      if ( asprintf(&ptr, "%s:%s", v8, v7) == -1 )
      {
        sub_12222(*(_QWORD *)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"yin_print_identity", v9);
      }
      else
      {
        sub_E904C(a1, v13, 2, i, (__int64)ptr, *(_QWORD *)(v12 + 48), *(_QWORD *)(v12 + 32), *(_BYTE *)(v12 + 26));
        free(ptr);
      }
    }
  }
  sub_E943A(a1, v13, v12, *(_QWORD *)(v12 + 48), &v14, 112LL);
  sub_E8EE6(a1, a2, 0LL, (__int64)"identity", v14, v10);
  return __readfsqword(0x28u) ^ v18;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000ECC45) ----------------------------------------------------
unsigned __int64 __fastcall sub_ECC45(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 *v20; // [rsp+10h] [rbp-38h]
  int v21; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v22; // [rsp+28h] [rbp-20h]
  int i; // [rsp+2Ch] [rbp-1Ch]
  __int64 j; // [rsp+30h] [rbp-18h]
  __int64 *v25; // [rsp+38h] [rbp-10h]
  unsigned __int64 v26; // [rsp+40h] [rbp-8h]

  v20 = a3;
  v26 = __readfsqword(0x28u);
  v22 = 0;
  v25 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"container", (__int64)"name", *a3, 0);
  v21 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v20, v20[6], &v22, 1LL);
  if ( v25[14] )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v3, v4, v5);
    sub_EA0C6(a1, v21, (__int64 *)v20[6], (const char **)v25[14]);
  }
  for ( i = 0; i < *((unsigned __int8 *)v25 + 27); ++i )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v3, v4, v5);
    sub_E933F(a1, v21, v20[6], v25[5] + 32LL * i, v6, v7);
  }
  for ( i = 0; i < *((unsigned __int8 *)v25 + 29); ++i )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v3, v4, v5);
    sub_EB0CE(a1, v21, (__int64 *)v20[6], (const char **)(56LL * i + v25[15]));
  }
  if ( v25[17] )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v3, v4, v5);
    sub_E904C(a1, v21, 14, 0, v25[17], v20[6], v20[4], *((_BYTE *)v20 + 26));
  }
  sub_E943A(a1, v21, (__int64)v20, v20[6], &v22, 116LL);
  for ( i = 0; i < *((unsigned __int16 *)v25 + 15); ++i )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v8, v9, v10);
    sub_EC70B(a1, v21, (__int64 *)v20[6], (__int64 *)(v25[16] + ((signed __int64)i << 7)));
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v20 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v8, v9, v10);
      sub_EF3B4(a1, v21, j, 0x800u, v11, v12);
    }
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v20 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v8, v9, v10);
      sub_EF3B4(a1, v21, j, 0x903Fu, v13, v14);
    }
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v20 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v8, v9, v10);
      sub_EF3B4(a1, v21, j, 0x4000u, v15, v16);
    }
  }
  for ( j = v20[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v20 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v22, (__int64)&v22, v8, v9, v10);
      sub_EF3B4(a1, v21, j, 0x80u, v17, v18);
    }
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"container", v22, v10);
  return __readfsqword(0x28u) ^ v26;
}

//----- (00000000000ED082) ----------------------------------------------------
unsigned __int64 __fastcall sub_ED082(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+8h] [rbp-38h]
  int v13; // [rsp+14h] [rbp-2Ch]
  unsigned int v14; // [rsp+24h] [rbp-1Ch]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 v16; // [rsp+30h] [rbp-10h]
  unsigned __int64 v17; // [rsp+38h] [rbp-8h]

  v13 = a2;
  v12 = a3;
  v17 = __readfsqword(0x28u);
  v14 = 0;
  v16 = a3;
  if ( *(_WORD *)(a3 + 24) & 0x40 )
  {
    v14 = 1;
  }
  else
  {
    sub_E8DAF(a1, a2, 0LL, (__int64)"case", (__int64)"name", *(_QWORD *)v16, v14);
    v13 = a2 + 1;
    sub_E943A(a1, a2 + 1, v12, *(_QWORD *)(v12 + 48), &v14, 1LL);
    if ( *(_QWORD *)(v16 + 104) )
    {
      sub_E8F8C(a1, &v14, (__int64)&v14, v6, v7, v8);
      sub_EA0C6(a1, v13, *(__int64 **)(v12 + 48), *(const char ***)(v16 + 104));
    }
    sub_E943A(a1, v13, v12, *(_QWORD *)(v12 + 48), &v14, 114LL);
  }
  for ( i = *(_QWORD *)(v12 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( v12 == *(_QWORD *)(i + 64) )
    {
      sub_E8F8C(a1, &v14, (__int64)&v14, a4, a5, a6);
      sub_EF3B4(a1, v13, i, 0x903Fu, v9, v10);
    }
  }
  if ( !(*(_WORD *)(v12 + 24) & 0x40) )
    sub_E8EE6(a1, v13 - 1, 0LL, (__int64)"case", v14, a6);
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000ED24A) ----------------------------------------------------
unsigned __int64 __fastcall sub_ED24A(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 *v14; // [rsp+10h] [rbp-38h]
  int v15; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v16; // [rsp+28h] [rbp-20h]
  int i; // [rsp+2Ch] [rbp-1Ch]
  __int64 j; // [rsp+30h] [rbp-18h]
  __int64 *v19; // [rsp+38h] [rbp-10h]
  unsigned __int64 v20; // [rsp+40h] [rbp-8h]

  v14 = a3;
  v20 = __readfsqword(0x28u);
  v16 = 0;
  v19 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"choice", (__int64)"name", *a3, 0);
  v15 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v14, v14[6], &v16, 1LL);
  if ( v19[13] )
  {
    sub_E8F8C(a1, &v16, (__int64)&v16, v3, v4, v5);
    sub_EA0C6(a1, v15, (__int64 *)v14[6], (const char **)v19[13]);
  }
  for ( i = 0; i < *((unsigned __int8 *)v19 + 27); ++i )
  {
    sub_E8F8C(a1, &v16, (__int64)&v16, v3, v4, v5);
    sub_E933F(a1, v15, v14[6], v19[5] + 32LL * i, v6, v7);
  }
  if ( v19[14] )
  {
    sub_E8F8C(a1, &v16, (__int64)&v16, v3, v4, v5);
    sub_E904C(a1, v15, 5, 0, *(_QWORD *)v19[14], v14[6], v14[4], *((_BYTE *)v14 + 26));
  }
  sub_E943A(a1, v15, (__int64)v14, v14[6], &v16, 124LL);
  for ( j = v14[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v14 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v16, (__int64)&v16, v8, v9, v10);
      sub_EF3B4(a1, v15, j, 0x807Fu, v11, v12);
    }
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"choice", v16, v10);
  return __readfsqword(0x28u) ^ v20;
}

//----- (00000000000ED4A7) ----------------------------------------------------
signed __int64 __fastcall sub_ED4A7(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  char *v5; // rbx
  __int64 v6; // rax
  char *v7; // rax
  __int64 v8; // r9
  __int64 *v10; // [rsp+10h] [rbp-48h]
  int v11; // [rsp+1Ch] [rbp-3Ch]
  signed int i; // [rsp+34h] [rbp-24h]
  signed int j; // [rsp+34h] [rbp-24h]
  __int64 v14; // [rsp+38h] [rbp-20h]
  __int64 *v15; // [rsp+40h] [rbp-18h]

  v10 = a3;
  v15 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"leaf", (__int64)"name", *a3, 1);
  v11 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v10, v10[6], 0LL, 1LL);
  if ( v15[14] )
    sub_EA0C6(a1, v11, (__int64 *)v10[6], (const char **)v15[14]);
  for ( i = 0; i < *((unsigned __int8 *)v15 + 27); ++i )
    sub_E933F(a1, v11, v10[6], v15[5] + 32LL * i, v3, v4);
  sub_EA48F(a1, v11, (__int64 *)v10[6], (__int64)(v15 + 16));
  sub_E904C(a1, v11, 17, 0, v15[24], v10[6], v10[4], *((_BYTE *)v10 + 26));
  for ( j = 0; j < *((unsigned __int8 *)v15 + 31); ++j )
    sub_EB0CE(a1, v11, (__int64 *)v10[6], (const char **)(56LL * j + v15[15]));
  if ( v15[25] )
  {
    if ( v15[3] & 0x1000 )
    {
      if ( !strchr((const char *)v15[25], 58) )
        __assert_fail(
          "strchr(leaf->dflt, ':')",
          "/home/mantovan/Repositories/libyang/src/printer_yin.c",
          0x45Fu,
          "yin_print_leaf");
      v5 = &strchr((const char *)v15[25], 58)[-v15[25]];
      v6 = lys_node_module(v10);
      if ( !strncmp((const char *)v15[25], *(const char **)(v6 + 8), (size_t)v5) )
      {
        v7 = strchr((const char *)v15[25], 58);
        v14 = lydict_insert(*(_QWORD *)v10[6], v7 + 1, 0LL);
      }
      else
      {
        v14 = sub_9182((__int64 *)v10[6], (const char *)v15[25]);
      }
      sub_E904C(a1, v11, 5, 0, v14, v10[6], v10[4], *((_BYTE *)v10 + 26));
    }
    else
    {
      v14 = v15[25];
      sub_E904C(a1, v11, 5, 0, v14, v10[6], v10[4], *((_BYTE *)v10 + 26));
    }
    if ( v15[3] & 0x1000 )
      lydict_remove(*(_QWORD *)v10[6], v14);
  }
  sub_E943A(a1, v11, (__int64)v10, v10[6], 0LL, 124LL);
  return sub_E8EE6(a1, a2, 0LL, (__int64)"leaf", 1LL, v8);
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000ED853) ----------------------------------------------------
unsigned __int64 __fastcall sub_ED853(__int64 a1, int a2, __int64 a3)
{
  const char *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v11; // [rsp+8h] [rbp-38h]
  int v12; // [rsp+14h] [rbp-2Ch]
  unsigned int v13; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 v15; // [rsp+28h] [rbp-18h]
  const char *v16; // [rsp+30h] [rbp-10h]
  unsigned __int64 v17; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v17 = __readfsqword(0x28u);
  v13 = 0;
  v15 = a3;
  if ( lys_parent(a3)
    || strcmp(*(const char **)v11, "config")
    || strcmp(*(const char **)(*(_QWORD *)(v11 + 48) + 8LL), "ietf-netconf") )
  {
    if ( *(_DWORD *)(v15 + 56) == 32 )
      v3 = "anyxml";
    else
      v3 = "anydata";
    v16 = v3;
    sub_E8DAF(a1, a2, 0LL, (__int64)v3, (__int64)"name", *(_QWORD *)v15, v13);
    v12 = a2 + 1;
    sub_E943A(a1, a2 + 1, v11, *(_QWORD *)(v11 + 48), &v13, 1LL);
    if ( *(_QWORD *)(v15 + 112) )
    {
      sub_E8F8C(a1, &v13, (__int64)&v13, v4, v5, v6);
      sub_EA0C6(a1, v12, *(__int64 **)(v11 + 48), *(const char ***)(v15 + 112));
    }
    for ( i = 0; i < *(unsigned __int8 *)(v15 + 27); ++i )
    {
      sub_E8F8C(a1, &v13, (__int64)&v13, v4, v5, v6);
      sub_E933F(a1, v12, *(_QWORD *)(v11 + 48), *(_QWORD *)(v15 + 40) + 32LL * i, v7, v8);
    }
    for ( i = 0; i < *(unsigned __int8 *)(v15 + 31); ++i )
    {
      sub_E8F8C(a1, &v13, (__int64)&v13, v4, v5, v6);
      sub_EB0CE(a1, v12, *(__int64 **)(v11 + 48), (const char **)(56LL * i + *(_QWORD *)(v15 + 120)));
    }
    sub_E943A(a1, v12, v11, *(_QWORD *)(v11 + 48), &v13, 124LL);
    sub_E8EE6(a1, a2, 0LL, (__int64)v16, v13, v9);
  }
  return __readfsqword(0x28u) ^ v17;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000EDABE) ----------------------------------------------------
signed __int64 __fastcall sub_EDABE(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  char *v5; // rbx
  __int64 v6; // rax
  char *v7; // rax
  __int64 v8; // r9
  __int64 *v10; // [rsp+10h] [rbp-48h]
  int v11; // [rsp+1Ch] [rbp-3Ch]
  signed int i; // [rsp+34h] [rbp-24h]
  signed int j; // [rsp+34h] [rbp-24h]
  signed int k; // [rsp+34h] [rbp-24h]
  __int64 v15; // [rsp+38h] [rbp-20h]
  __int64 *v16; // [rsp+40h] [rbp-18h]

  v10 = a3;
  v16 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"leaf-list", (__int64)"name", *a3, 1);
  v11 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v10, v10[6], 0LL, 1LL);
  if ( v16[14] )
    sub_EA0C6(a1, v11, (__int64 *)v16[6], (const char **)v16[14]);
  for ( i = 0; i < *((unsigned __int8 *)v16 + 27); ++i )
    sub_E933F(a1, v11, v10[6], v16[5] + 32LL * i, v3, v4);
  sub_EA48F(a1, v11, (__int64 *)v10[6], (__int64)(v16 + 16));
  sub_E904C(a1, v11, 17, 0, v16[24], v10[6], v10[4], *((_BYTE *)v10 + 26));
  for ( j = 0; j < *((unsigned __int8 *)v16 + 31); ++j )
    sub_EB0CE(a1, v11, (__int64 *)v10[6], (const char **)(56LL * j + v16[15]));
  for ( k = 0; k < *((unsigned __int8 *)v16 + 30); ++k )
  {
    if ( v16[3] & 0x1000 )
    {
      if ( !strchr(*(const char **)(8LL * k + v16[25]), 58) )
        __assert_fail(
          "strchr(llist->dflt[i], ':')",
          "/home/mantovan/Repositories/libyang/src/printer_yin.c",
          0x4B3u,
          "yin_print_leaflist");
      v5 = &strchr(*(const char **)(8LL * k + v16[25]), 58)[-*(_QWORD *)(8LL * k + v16[25])];
      v6 = lys_node_module(v10);
      if ( !strncmp(*(const char **)(8LL * k + v16[25]), *(const char **)(v6 + 8), (size_t)v5) )
      {
        v7 = strchr(*(const char **)(8LL * k + v16[25]), 58);
        v15 = lydict_insert(*(_QWORD *)v10[6], v7 + 1, 0LL);
      }
      else
      {
        v15 = sub_9182((__int64 *)v10[6], *(const char **)(8LL * k + v16[25]));
      }
      sub_E904C(a1, v11, 5, k, v15, v10[6], v10[4], *((_BYTE *)v10 + 26));
    }
    else
    {
      v15 = *(_QWORD *)(8LL * k + v16[25]);
      sub_E904C(a1, v11, 5, k, v15, v10[6], v10[4], *((_BYTE *)v10 + 26));
    }
    if ( v16[3] & 0x1000 )
      lydict_remove(*(_QWORD *)v10[6], v15);
  }
  sub_E943A(a1, v11, (__int64)v10, v10[6], 0LL, 4LL);
  if ( *((_DWORD *)v16 + 52) )
    sub_EA2FF(a1, v11, 29LL, 0LL, (__int64 *)v10[6], v10[4], *((unsigned __int8 *)v10 + 26), *((_DWORD *)v16 + 52));
  if ( *((_DWORD *)v16 + 53) )
    sub_EA2FF(a1, v11, 28LL, 0LL, (__int64 *)v10[6], v10[4], *((unsigned __int8 *)v10 + 26), *((_DWORD *)v16 + 53));
  if ( v16[3] & 0x100 )
  {
    sub_E904C(a1, v11, 25, 0, (__int64)"user", v10[6], v10[4], *((_BYTE *)v10 + 26));
  }
  else if ( (unsigned int)sub_9EAFC(v10[4], *((_BYTE *)v10 + 26), 0, 25) != -1 )
  {
    sub_E904C(a1, v11, 25, 0, (__int64)"system", v10[6], v10[4], *((_BYTE *)v10 + 26));
  }
  sub_E943A(a1, v11, (__int64)v10, v10[6], 0LL, 112LL);
  return sub_E8EE6(a1, a2, 0LL, (__int64)"leaf-list", 1LL, v8);
}
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000EE086) ----------------------------------------------------
unsigned __int64 __fastcall sub_EE086(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 *v31; // [rsp+10h] [rbp-48h]
  int v32; // [rsp+1Ch] [rbp-3Ch]
  unsigned int v33; // [rsp+30h] [rbp-28h]
  unsigned int v34; // [rsp+34h] [rbp-24h]
  int i; // [rsp+38h] [rbp-20h]
  int v36; // [rsp+3Ch] [rbp-1Ch]
  __int64 j; // [rsp+40h] [rbp-18h]
  __int64 *v38; // [rsp+48h] [rbp-10h]
  unsigned __int64 v39; // [rsp+50h] [rbp-8h]

  v31 = a3;
  v39 = __readfsqword(0x28u);
  v33 = 0;
  v38 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"list", (__int64)"name", *a3, 0);
  v32 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v31, v31[6], &v33, 1LL);
  if ( v38[14] )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v3, v4, v5);
    sub_EA0C6(a1, v32, (__int64 *)v38[6], (const char **)v38[14]);
  }
  for ( i = 0; i < *((unsigned __int8 *)v38 + 27); ++i )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v3, v4, v5);
    sub_E933F(a1, v32, v31[6], v38[5] + 32LL * i, v6, v7);
  }
  for ( i = 0; i < *((unsigned __int8 *)v38 + 28); ++i )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v3, v4, v5);
    sub_EB0CE(a1, v32, (__int64 *)v38[6], (const char **)(56LL * i + v38[15]));
  }
  if ( *((_BYTE *)v38 + 30) )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v3, v4, v5);
    sub_E904C(a1, v32, 9, 0, v38[20], v31[6], v31[4], *((_BYTE *)v31 + 26));
  }
  for ( i = 0; i < *((unsigned __int8 *)v38 + 31); ++i )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v3, v4, v5);
    sub_EB1FC(a1, v32, (__int64 *)v31[6], v38[18] + 16LL * i, v8, v9);
    v34 = 0;
    v36 = -1;
    do
      v36 = sub_9EAFC(v38[4], *((_BYTE *)v38 + 26), (unsigned __int8)v36 + 1, 31);
    while ( v36 != -1 && i != *(unsigned __int8 *)(*(_QWORD *)(8LL * v36 + v38[4]) + 27LL) );
    if ( v36 != -1 )
    {
      sub_E8F8C(a1, &v34, (__int64)&v34, v10, v11, v12);
      do
      {
        sub_F0CAF(a1, a2 + 2, v38[6], 31, i, v38[4] + 8LL * v36, 1u);
        do
          v36 = sub_9EAFC(v38[4], *((_BYTE *)v38 + 26), (unsigned __int8)v36 + 1, 31);
        while ( v36 != -1 && i != *(unsigned __int8 *)(*(_QWORD *)(8LL * v36 + v38[4]) + 27LL) );
      }
      while ( v36 != -1 );
    }
    sub_E8EE6(a1, v32, 0LL, (__int64)"unique", v34, v12);
  }
  sub_E943A(a1, v32, (__int64)v31, v31[6], &v33, 4LL);
  if ( *((_DWORD *)v38 + 38) )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v13, v14, v15);
    sub_EA2FF(a1, v32, 29LL, 0LL, (__int64 *)v31[6], v31[4], *((unsigned __int8 *)v31 + 26), *((_DWORD *)v38 + 38));
  }
  if ( *((_DWORD *)v38 + 39) )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v13, v14, v15);
    sub_EA2FF(a1, v32, 28LL, 0LL, (__int64 *)v31[6], v31[4], *((unsigned __int8 *)v31 + 26), *((_DWORD *)v38 + 39));
  }
  if ( v38[3] & 0x100 )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v13, v14, v15);
    sub_E904C(a1, v32, 25, 0, (__int64)"user", v31[6], v31[4], *((_BYTE *)v31 + 26));
  }
  else if ( (unsigned int)sub_9EAFC(v31[4], *((_BYTE *)v31 + 26), 0, 25) != -1 )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v16, v17, v18);
    sub_E904C(a1, v32, 25, 0, (__int64)"system", v31[6], v31[4], *((_BYTE *)v31 + 26));
  }
  sub_E943A(a1, v32, (__int64)v31, v31[6], &v33, 112LL);
  for ( i = 0; i < *((unsigned __int8 *)v38 + 29); ++i )
  {
    sub_E8F8C(a1, &v33, (__int64)&v33, v19, v20, v21);
    sub_EC70B(a1, v32, (__int64 *)v38[6], (__int64 *)(v38[16] + ((signed __int64)i << 7)));
  }
  for ( j = v31[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v31 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v33, (__int64)&v33, v19, v20, v21);
      sub_EF3B4(a1, v32, j, 0x800u, v22, v23);
    }
  }
  for ( j = v31[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v31 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v33, (__int64)&v33, v19, v20, v21);
      sub_EF3B4(a1, v32, j, 0x903Fu, v24, v25);
    }
  }
  for ( j = v31[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v31 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v33, (__int64)&v33, v19, v20, v21);
      sub_EF3B4(a1, v32, j, 0x4000u, v26, v27);
    }
  }
  for ( j = v31[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v31 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v33, (__int64)&v33, v19, v20, v21);
      sub_EF3B4(a1, v32, j, 0x80u, v28, v29);
    }
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"list", v33, v21);
  return __readfsqword(0x28u) ^ v39;
}

//----- (00000000000EE862) ----------------------------------------------------
unsigned __int64 __fastcall sub_EE862(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 *v15; // [rsp+10h] [rbp-38h]
  int v16; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v17; // [rsp+28h] [rbp-20h]
  int i; // [rsp+2Ch] [rbp-1Ch]
  __int64 j; // [rsp+30h] [rbp-18h]
  __int64 *v20; // [rsp+38h] [rbp-10h]
  unsigned __int64 v21; // [rsp+40h] [rbp-8h]

  v15 = a3;
  v21 = __readfsqword(0x28u);
  v17 = 0;
  v20 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"grouping", (__int64)"name", *a3, 0);
  v16 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v15, v15[6], &v17, 113LL);
  for ( i = 0; i < *((unsigned __int16 *)v20 + 15); ++i )
  {
    sub_E8F8C(a1, &v17, (__int64)&v17, v3, v4, v5);
    sub_EC70B(a1, v16, (__int64 *)v15[6], (__int64 *)(v20[13] + ((signed __int64)i << 7)));
  }
  for ( j = v15[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_E8F8C(a1, &v17, (__int64)&v17, v3, v4, v5);
    sub_EF3B4(a1, v16, j, 0x800u, v6, v7);
  }
  for ( j = v15[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_E8F8C(a1, &v17, (__int64)&v17, v3, v4, v5);
    sub_EF3B4(a1, v16, j, 0x903Fu, v8, v9);
  }
  for ( j = v15[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_E8F8C(a1, &v17, (__int64)&v17, v3, v4, v5);
    sub_EF3B4(a1, v16, j, 0x4000u, v10, v11);
  }
  for ( j = v15[9]; j; j = *(_QWORD *)(j + 80) )
  {
    sub_E8F8C(a1, &v17, (__int64)&v17, v3, v4, v5);
    sub_EF3B4(a1, v16, j, 0x80u, v12, v13);
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"grouping", v17, v5);
  return __readfsqword(0x28u) ^ v21;
}

//----- (00000000000EEAC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_EEAC0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v20; // [rsp+8h] [rbp-38h]
  int v21; // [rsp+14h] [rbp-2Ch]
  unsigned int v22; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 v24; // [rsp+28h] [rbp-18h]
  __int64 v25; // [rsp+30h] [rbp-10h]
  unsigned __int64 v26; // [rsp+38h] [rbp-8h]

  v20 = a3;
  v26 = __readfsqword(0x28u);
  v22 = 0;
  v24 = a3;
  sub_C1FF7(a1, "%*s<uses name=\"", (unsigned int)(2 * a2), (__int64)&unk_127870, a5, a6);
  if ( *(_QWORD *)(v20 + 72) )
  {
    v25 = lys_node_module(*(_QWORD *)(v20 + 72));
    if ( v25 != lys_node_module(v20) )
    {
      v9 = sub_831C(*(_QWORD *)(v20 + 48), *(const char **)(v25 + 8));
      sub_C1FF7(a1, "%s:", v9, v10, v11, v12);
    }
  }
  sub_C1FF7(a1, "%s\"", *(_QWORD *)v24, v6, v7, v8);
  v21 = a2 + 1;
  sub_E943A(a1, a2 + 1, v20, *(_QWORD *)(v20 + 48), &v22, 1LL);
  if ( *(_QWORD *)(v24 + 104) )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v13, v14, v15);
    sub_EA0C6(a1, v21, *(__int64 **)(v20 + 48), *(const char ***)(v24 + 104));
  }
  sub_E943A(a1, v21, v20, *(_QWORD *)(v20 + 48), &v22, 114LL);
  for ( i = 0; i < *(unsigned __int8 *)(v24 + 30); ++i )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v16, v17, v18);
    sub_EB2F8(a1, v21, *(__int64 **)(v20 + 48), (const char **)(80LL * i + *(_QWORD *)(v24 + 112)));
  }
  for ( i = 0; i < *(unsigned __int8 *)(v24 + 31); ++i )
  {
    sub_E8F8C(a1, &v22, (__int64)&v22, v16, v17, v18);
    sub_EC5A5(a1, v21, *(__int64 **)(v20 + 48), (const char **)(104LL * i + *(_QWORD *)(v24 + 120)));
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"uses", v22, v18);
  return __readfsqword(0x28u) ^ v26;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000EED3F) ----------------------------------------------------
signed __int64 __fastcall sub_EED3F(__int64 a1, int a2, __int64 a3)
{
  const char *v3; // rax
  __int64 v4; // r8
  __int64 v5; // r9
  const char *v6; // rax
  __int64 v8; // [rsp+8h] [rbp-38h]
  int v9; // [rsp+14h] [rbp-2Ch]
  signed int i; // [rsp+2Ch] [rbp-14h]
  signed int j; // [rsp+2Ch] [rbp-14h]
  __int64 k; // [rsp+30h] [rbp-10h]
  __int64 l; // [rsp+30h] [rbp-10h]
  __int64 v14; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v14 = a3;
  if ( *(_DWORD *)(a3 + 56) == 512 )
    v3 = "input";
  else
    v3 = "output";
  sub_E8DAF(a1, a2, 0LL, (__int64)v3, 0LL, 0LL, 1);
  v9 = a2 + 1;
  if ( *(_BYTE *)(v14 + 26) )
    sub_F0CAF(a1, v9, *(_QWORD *)(v8 + 48), 0, 0, *(_QWORD *)(v14 + 32), *(unsigned __int8 *)(v14 + 26));
  for ( i = 0; i < *(unsigned __int8 *)(v14 + 29); ++i )
    sub_EB0CE(a1, v9, *(__int64 **)(v8 + 48), (const char **)(56LL * i + *(_QWORD *)(v14 + 112)));
  for ( j = 0; j < *(unsigned __int16 *)(v14 + 30); ++j )
    sub_EC70B(a1, v9, *(__int64 **)(v8 + 48), (__int64 *)(*(_QWORD *)(v14 + 104) + ((signed __int64)j << 7)));
  for ( k = *(_QWORD *)(v8 + 72); k; k = *(_QWORD *)(k + 80) )
  {
    if ( v8 == *(_QWORD *)(k + 64) )
      sub_EF3B4(a1, v9, k, 0x800u, v4, v5);
  }
  for ( l = *(_QWORD *)(v8 + 72); l; l = *(_QWORD *)(l + 80) )
  {
    if ( v8 == *(_QWORD *)(l + 64) )
      sub_EF3B4(a1, v9, l, 0x903Fu, v4, v5);
  }
  if ( *(_DWORD *)(v14 + 56) == 512 )
    v6 = "input";
  else
    v6 = "output";
  return sub_E8EE6(a1, a2, 0LL, (__int64)v6, 1LL, v5);
}

//----- (00000000000EEF63) ----------------------------------------------------
unsigned __int64 __fastcall sub_EEF63(__int64 a1, int a2, __int64 a3)
{
  const char *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  const char *v9; // rax
  __int64 v11; // [rsp+8h] [rbp-38h]
  int v12; // [rsp+14h] [rbp-2Ch]
  unsigned int v13; // [rsp+20h] [rbp-20h]
  int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 v16; // [rsp+30h] [rbp-10h]
  unsigned __int64 v17; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v17 = __readfsqword(0x28u);
  v13 = 0;
  v16 = a3;
  if ( *(_DWORD *)(a3 + 56) == 256 )
    v3 = "rpc";
  else
    v3 = "action";
  sub_E8DAF(a1, a2, 0LL, (__int64)v3, (__int64)"name", *(_QWORD *)a3, 0);
  v12 = a2 + 1;
  sub_E943A(a1, a2 + 1, v11, *(_QWORD *)(v11 + 48), &v13, 115LL);
  for ( i = 0; i < *(unsigned __int16 *)(v16 + 30); ++i )
  {
    sub_E8F8C(a1, &v13, (__int64)&v13, v4, v5, v6);
    sub_EC70B(a1, v12, *(__int64 **)(v11 + 48), (__int64 *)(*(_QWORD *)(v16 + 112) + ((signed __int64)i << 7)));
  }
  for ( j = *(_QWORD *)(v11 + 72); j; j = *(_QWORD *)(j + 80) )
  {
    if ( v11 == *(_QWORD *)(j + 64) && (!(*(_DWORD *)(j + 56) & 0x600) || !(*(_WORD *)(j + 24) & 0x40)) )
    {
      sub_E8F8C(a1, &v13, (__int64)&v13, v4, v5, v6);
      sub_EF3B4(a1, v12, j, 0xE00u, v7, v8);
    }
  }
  if ( *(_DWORD *)(v11 + 56) == 256 )
    v9 = "rpc";
  else
    v9 = "action";
  sub_E8EE6(a1, a2, 0LL, (__int64)v9, v13, v6);
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000EF13E) ----------------------------------------------------
unsigned __int64 __fastcall sub_EF13E(__int64 a1, int a2, __int64 *a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 *v14; // [rsp+10h] [rbp-38h]
  int v15; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v16; // [rsp+28h] [rbp-20h]
  int i; // [rsp+2Ch] [rbp-1Ch]
  __int64 j; // [rsp+30h] [rbp-18h]
  __int64 *v19; // [rsp+38h] [rbp-10h]
  unsigned __int64 v20; // [rsp+40h] [rbp-8h]

  v14 = a3;
  v20 = __readfsqword(0x28u);
  v16 = 0;
  v19 = a3;
  sub_E8DAF(a1, a2, 0LL, (__int64)"notification", (__int64)"name", *a3, 0);
  v15 = a2 + 1;
  sub_E943A(a1, a2 + 1, (__int64)v14, v14[6], &v16, 3LL);
  for ( i = 0; i < *((unsigned __int8 *)v19 + 29); ++i )
  {
    sub_E8F8C(a1, &v16, (__int64)&v16, v3, v4, v5);
    sub_EB0CE(a1, v15, (__int64 *)v14[6], (const char **)(56LL * i + v19[15]));
  }
  sub_E943A(a1, v15, (__int64)v14, v14[6], &v16, 112LL);
  for ( i = 0; i < *((unsigned __int16 *)v19 + 15); ++i )
  {
    sub_E8F8C(a1, &v16, (__int64)&v16, v6, v7, v8);
    sub_EC70B(a1, v15, (__int64 *)v14[6], (__int64 *)(v19[14] + ((signed __int64)i << 7)));
  }
  for ( j = v14[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v14 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v16, (__int64)&v16, v6, v7, v8);
      sub_EF3B4(a1, v15, j, 0x800u, v9, v10);
    }
  }
  for ( j = v14[9]; j; j = *(_QWORD *)(j + 80) )
  {
    if ( v14 == *(__int64 **)(j + 64) )
    {
      sub_E8F8C(a1, &v16, (__int64)&v16, v6, v7, v8);
      sub_EF3B4(a1, v15, j, 0x903Fu, v11, v12);
    }
  }
  sub_E8EE6(a1, a2, 0LL, (__int64)"notification", v16, v8);
  return __readfsqword(0x28u) ^ v20;
}

//----- (00000000000EF3B4) ----------------------------------------------------
unsigned __int64 __fastcall sub_EF3B4(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax

  result = *(_DWORD *)(a3 + 56) & a4;
  if ( (_DWORD)result == 128 )
    return sub_EF13E(a1, a2, (__int64 *)a3);
  if ( (unsigned int)result <= 0x80 )
  {
    if ( (_DWORD)result == 8 )
      return sub_EDABE(a1, a2, (__int64 *)a3);
    if ( (unsigned int)result <= 8 )
    {
      switch ( (_DWORD)result )
      {
        case 2:
          return sub_ED24A(a1, a2, (__int64 *)a3);
        case 4:
          return sub_ED4A7(a1, a2, (__int64 *)a3);
        case 1:
          result = sub_ECC45(a1, a2, (__int64 *)a3);
          break;
      }
      return result;
    }
    if ( (_DWORD)result != 32 )
    {
      if ( (_DWORD)result == 64 )
        return sub_ED082(a1, a2, a3, a2, a5, a6);
      if ( (_DWORD)result == 16 )
        result = sub_EE086(a1, a2, (__int64 *)a3);
      return result;
    }
    return sub_ED853(a1, a2, a3);
  }
  if ( (_DWORD)result == 2048 )
    return sub_EE862(a1, a2, (__int64 *)a3);
  if ( (unsigned int)result <= 0x800 )
  {
    if ( (_DWORD)result == 512 || (_DWORD)result == 1024 )
      return sub_EED3F(a1, a2, a3);
    if ( (_DWORD)result != 256 )
      return result;
    return sub_EEF63(a1, a2, a3);
  }
  switch ( (_DWORD)result )
  {
    case 0x4000:
      return sub_EEF63(a1, a2, a3);
    case 0x8020:
      return sub_ED853(a1, a2, a3);
    case 0x1000:
      result = sub_EEAC0(a1, a2, a3, a2, a5, a6);
      break;
  }
  return result;
}

//----- (00000000000EF5BC) ----------------------------------------------------
signed __int64 __fastcall sub_EF5BC(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v6; // [rsp+0h] [rbp-20h]
  __int64 v7; // [rsp+8h] [rbp-18h]

  v7 = a3;
  v6 = a4;
  if ( *(_OWORD *)(a4 + 24) == 0LL && !*(_BYTE *)(a4 + 11) )
    return sub_E8DAF(a1, a2, 0LL, (__int64)"revision", (__int64)"date", a4, -1);
  sub_E8DAF(a1, a2, 0LL, (__int64)"revision", (__int64)"date", a4, 1);
  sub_F0CAF(a1, a2 + 1, v7, 0, 0, *(_QWORD *)(v6 + 16), *(unsigned __int8 *)(v6 + 11));
  sub_E904C(a1, a2 + 1, 6, 0, *(_QWORD *)(v6 + 24), v7, *(_QWORD *)(v6 + 16), *(_BYTE *)(v6 + 11));
  sub_E904C(a1, a2 + 1, 15, 0, *(_QWORD *)(v6 + 32), v7, *(_QWORD *)(v6 + 16), *(_BYTE *)(v6 + 11));
  return sub_E8EE6(a1, a2, 0LL, (__int64)"revision", 1LL, v4);
}

//----- (00000000000EF756) ----------------------------------------------------
__int64 __fastcall sub_EF756(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-20h]
  unsigned int i; // [rsp+18h] [rbp-8h]
  unsigned int v9; // [rsp+1Ch] [rbp-4h]

  if ( *(_BYTE *)(a2 + 64) & 1 )
    v9 = 11;
  else
    v9 = 8;
  sub_C1FF7(a1, "%*sxmlns=\"%s\"", v9, (__int64)&unk_127870, (__int64)"urn:ietf:params:xml:ns:yang:yin:1", a6, a2);
  if ( *(_BYTE *)(v7 + 64) & 1 )
    sub_C1FF7(
      a1,
      "\n%*sxmlns:%s=\"%s\"",
      v9,
      (__int64)&unk_127870,
      *(_QWORD *)(v7 + 16),
      *(_QWORD *)(*(_QWORD *)(v7 + 168) + 176LL));
  else
    sub_C1FF7(a1, "\n%*sxmlns:%s=\"%s\"", v9, (__int64)&unk_127870, *(_QWORD *)(v7 + 16), *(_QWORD *)(v7 + 176));
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(v7 + 69);
    if ( i >= (unsigned int)result )
      break;
    sub_C1FF7(
      a1,
      "\n%*sxmlns:%s=\"%s\"",
      v9,
      (__int64)&unk_127870,
      *(_QWORD *)(*(_QWORD *)(v7 + 96) + 56LL * i + 8),
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 96) + 56LL * i) + 176LL));
  }
  return result;
}

//----- (00000000000EF8CE) ----------------------------------------------------
__int64 __fastcall sub_EF8CE(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  const char *v13; // rax
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  const char *v22; // rax
  __int64 v23; // r9
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v34; // [rsp+8h] [rbp-28h]
  int v35; // [rsp+14h] [rbp-1Ch]
  int v36; // [rsp+14h] [rbp-1Ch]
  int v37; // [rsp+14h] [rbp-1Ch]
  int v38; // [rsp+14h] [rbp-1Ch]
  unsigned int i; // [rsp+20h] [rbp-10h]
  unsigned int j; // [rsp+20h] [rbp-10h]
  unsigned int k; // [rsp+20h] [rbp-10h]
  unsigned int l; // [rsp+20h] [rbp-10h]
  unsigned int m; // [rsp+20h] [rbp-10h]
  unsigned int n; // [rsp+20h] [rbp-10h]
  unsigned int ii; // [rsp+20h] [rbp-10h]
  unsigned int ll; // [rsp+20h] [rbp-10h]
  unsigned int i1; // [rsp+20h] [rbp-10h]
  int v48; // [rsp+24h] [rbp-Ch]
  __int64 jj; // [rsp+28h] [rbp-8h]
  __int64 kk; // [rsp+28h] [rbp-8h]
  __int64 mm; // [rsp+28h] [rbp-8h]
  __int64 nn; // [rsp+28h] [rbp-8h]

  v34 = a3;
  if ( (*(_BYTE *)(a3 + 64) & 0x30) == 16 )
    sub_C1FF7(a1, "<!-- DEVIATED -->\n", a3, a4, a5, a6);
  if ( *(_BYTE *)(v34 + 64) & 1 )
  {
    sub_C1FF7(a1, "%*s<submodule name=\"%s\"\n", (unsigned int)(2 * a2), (__int64)&unk_127870, *(_QWORD *)(v34 + 8), a6);
    sub_EF756(a1, v34, v34, v6, v7, v8);
    sub_C1FF7(a1, ">\n", v9, v10, v11, v12);
    v35 = a2 + 1;
    if ( *(_BYTE *)(v34 + 64) & 0xE )
    {
      if ( (*(_BYTE *)(v34 + 64) & 0xE) == 4 )
        v13 = "1.1";
      else
        v13 = "1";
      sub_E904C(a1, v35, 19, 0, (__int64)v13, v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
    }
    sub_E8DAF(a1, v35, 0LL, (__int64)"belongs-to", (__int64)"module", *(_QWORD *)(*(_QWORD *)(v34 + 168) + 8LL), 1);
    LOBYTE(v48) = -1;
    while ( 1 )
    {
      v48 = sub_9EAFC(*(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80), (unsigned __int8)v48 + 1, 3);
      if ( v48 == -1 )
        break;
      sub_F0CAF(a1, a2 + 2, v34, 3, 0, *(_QWORD *)(v34 + 160) + 8LL * v48, 1u);
    }
    sub_E904C(a1, a2 + 2, 13, 0, *(_QWORD *)(v34 + 16), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
    sub_E8EE6(a1, v35, 0LL, (__int64)"belongs-to", 1LL, v14);
  }
  else
  {
    sub_C1FF7(a1, "%*s<module name=\"%s\"\n", (unsigned int)(2 * a2), (__int64)&unk_127870, *(_QWORD *)(v34 + 8), a6);
    sub_EF756(a1, v34, v34, v15, v16, v17);
    sub_C1FF7(a1, ">\n", v18, v19, v20, v21);
    v35 = a2 + 1;
    if ( *(_BYTE *)(v34 + 64) & 0xE )
    {
      if ( (*(_BYTE *)(v34 + 64) & 0xE) == 4 )
        v22 = "1.1";
      else
        v22 = "1";
      sub_E904C(a1, v35, 19, 0, (__int64)v22, v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
    }
    sub_E904C(a1, v35, 10, 0, *(_QWORD *)(v34 + 176), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
    sub_E904C(a1, v35, 13, 0, *(_QWORD *)(v34 + 16), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
  }
  for ( i = 0; i < *(unsigned __int8 *)(v34 + 69); ++i )
  {
    sub_E8DAF(
      a1,
      v35,
      0LL,
      (__int64)"import",
      (__int64)"module",
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i) + 8LL),
      1);
    v36 = v35 + 1;
    sub_F0CAF(
      a1,
      v36,
      v34,
      0,
      0,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 32),
      *(unsigned __int8 *)(*(_QWORD *)(v34 + 96) + 56LL * i + 27));
    sub_E904C(
      a1,
      v36,
      13,
      0,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 8),
      v34,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 32),
      *(_BYTE *)(*(_QWORD *)(v34 + 96) + 56LL * i + 27));
    if ( *(_BYTE *)(*(_QWORD *)(v34 + 96) + 56LL * i + 16) )
      sub_E904C(
        a1,
        v36,
        16,
        0,
        *(_QWORD *)(v34 + 96) + 56LL * i + 16,
        v34,
        *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 32),
        *(_BYTE *)(*(_QWORD *)(v34 + 96) + 56LL * i + 27));
    sub_E904C(
      a1,
      v36,
      6,
      0,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 40),
      v34,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 32),
      *(_BYTE *)(*(_QWORD *)(v34 + 96) + 56LL * i + 27));
    sub_E904C(
      a1,
      v36,
      15,
      0,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 48),
      v34,
      *(_QWORD *)(*(_QWORD *)(v34 + 96) + 56LL * i + 32),
      *(_BYTE *)(*(_QWORD *)(v34 + 96) + 56LL * i + 27));
    v35 = v36 - 1;
    sub_E8EE6(a1, v35, 0LL, (__int64)"import", 1LL, v23);
  }
  for ( j = 0; j < *(unsigned __int8 *)(v34 + 70); ++j )
  {
    if ( *(_BYTE *)(*(_QWORD *)(v34 + 104) + 48LL * j + 8)
      || *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 32)
      || *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 40)
      || *(_BYTE *)(*(_QWORD *)(v34 + 104) + 48LL * j + 19) )
    {
      sub_E8DAF(
        a1,
        v35,
        0LL,
        (__int64)"include",
        (__int64)"module",
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 8LL),
        1);
      v37 = v35 + 1;
      sub_F0CAF(
        a1,
        v37,
        v34,
        0,
        0,
        *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 24),
        *(unsigned __int8 *)(*(_QWORD *)(v34 + 104) + 48LL * j + 19));
      if ( *(_BYTE *)(*(_QWORD *)(v34 + 104) + 48LL * j + 8) )
        sub_E904C(
          a1,
          v37,
          16,
          0,
          *(_QWORD *)(v34 + 104) + 48LL * j + 8,
          v34,
          *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 24),
          *(_BYTE *)(*(_QWORD *)(v34 + 104) + 48LL * j + 19));
      sub_E904C(
        a1,
        v37,
        6,
        0,
        *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 32),
        v34,
        *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 24),
        *(_BYTE *)(*(_QWORD *)(v34 + 104) + 48LL * j + 19));
      sub_E904C(
        a1,
        v37,
        15,
        0,
        *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 40),
        v34,
        *(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j + 24),
        *(_BYTE *)(*(_QWORD *)(v34 + 104) + 48LL * j + 19));
      v35 = v37 - 1;
      sub_E8EE6(a1, v35, 0LL, (__int64)"include", 1LL, v24);
    }
    else
    {
      sub_E8DAF(
        a1,
        v35,
        0LL,
        (__int64)"include",
        (__int64)"module",
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 8LL),
        -1);
    }
  }
  sub_E904C(a1, v35, 11, 0, *(_QWORD *)(v34 + 40), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
  sub_E904C(a1, v35, 4, 0, *(_QWORD *)(v34 + 48), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
  sub_E904C(a1, v35, 6, 0, *(_QWORD *)(v34 + 24), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
  sub_E904C(a1, v35, 15, 0, *(_QWORD *)(v34 + 32), v34, *(_QWORD *)(v34 + 160), *(_BYTE *)(v34 + 80));
  for ( k = 0; k < *(unsigned __int8 *)(v34 + 68); ++k )
    sub_EF5BC(a1, v35, v34, 40LL * k + *(_QWORD *)(v34 + 88));
  for ( l = 0; l < *(unsigned __int8 *)(v34 + 79); ++l )
    sub_E99DA(a1, v35, (__int64 *)(*(_QWORD *)(v34 + 152) + ((unsigned __int64)l << 6)));
  if ( *(_BYTE *)(v34 + 80) )
    sub_F0CAF(a1, v35, v34, 0, 0, *(_QWORD *)(v34 + 160), *(unsigned __int8 *)(v34 + 80));
  for ( m = 0; m < *(unsigned __int8 *)(v34 + 76); ++m )
    sub_EA002(a1, v35, (__int64 *)(*(_QWORD *)(v34 + 128) + ((unsigned __int64)m << 6)));
  for ( n = 0; n < *(unsigned __int16 *)(v34 + 72); ++n )
    sub_EC9A9(a1, v35, (__int64 *)(*(_QWORD *)(v34 + 120) + 72LL * n));
  for ( ii = 0; ii < *(unsigned __int16 *)(v34 + 74); ++ii )
    sub_EC70B(a1, v35, (__int64 *)v34, (__int64 *)(*(_QWORD *)(v34 + 112) + ((unsigned __int64)ii << 7)));
  for ( jj = *(_QWORD *)(lys_main_module(v34) + 168); jj; jj = *(_QWORD *)(jj + 80) )
  {
    if ( v34 == *(_QWORD *)(jj + 48) )
      sub_EF3B4(a1, v35, jj, 0x800u, v25, v26);
  }
  for ( kk = *(_QWORD *)(lys_main_module(v34) + 168); kk; kk = *(_QWORD *)(kk + 80) )
  {
    if ( v34 == *(_QWORD *)(kk + 48) )
      sub_EF3B4(a1, v35, kk, 0x903Fu, v27, v28);
  }
  for ( ll = 0; ll < *(unsigned __int8 *)(v34 + 77); ++ll )
    sub_EC5A5(a1, v35, (__int64 *)v34, (const char **)(104LL * ll + *(_QWORD *)(v34 + 136)));
  for ( mm = *(_QWORD *)(lys_main_module(v34) + 168); mm; mm = *(_QWORD *)(mm + 80) )
  {
    if ( v34 == *(_QWORD *)(mm + 48) )
      sub_EF3B4(a1, v35, mm, 0x4100u, v29, v30);
  }
  for ( nn = *(_QWORD *)(lys_main_module(v34) + 168); nn; nn = *(_QWORD *)(nn + 80) )
  {
    if ( v34 == *(_QWORD *)(nn + 48) )
      sub_EF3B4(a1, v35, nn, 0x80u, v31, v32);
  }
  for ( i1 = 0; i1 < *(unsigned __int8 *)(v34 + 78); ++i1 )
    sub_EB84B(a1, v35, (__int64 *)v34, (const char **)(56LL * i1 + *(_QWORD *)(v34 + 144)));
  v38 = v35 - 1;
  if ( *(_BYTE *)(v34 + 64) & 1 )
    sub_C1FF7(a1, "%*s</submodule>\n", (unsigned int)(2 * v38), (__int64)&unk_127870, v31, v32);
  else
    sub_C1FF7(a1, "%*s</module>\n", (unsigned int)(2 * v38), (__int64)&unk_127870, v31, v32);
  sub_C236C(a1);
  return 0LL;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F08B1) ----------------------------------------------------
__int64 __fastcall sub_F08B1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // ST00_8
  __int64 v9; // ST08_8

  sub_C1FF7(a1, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", a3, a4, a5, a6, a2, a1);
  return sub_EF8CE(v9, 0, v8, 0LL, v6, v7);
}

//----- (00000000000F08F7) ----------------------------------------------------
unsigned __int64 __fastcall sub_F08F7(__int64 a1, int a2, __int64 *a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, _DWORD *a8)
{
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+18h] [rbp-48h]
  __int64 v13; // [rsp+20h] [rbp-40h]
  __int64 *v14; // [rsp+28h] [rbp-38h]
  int v15; // [rsp+30h] [rbp-30h]
  char v16; // [rsp+48h] [rbp-18h]
  _BYTE *v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v15 = a5;
  v12 = a6;
  v18 = __readfsqword(0x28u);
  v17 = (_BYTE *)lys_ext_complex_get_substmt(a5, a4, &v16);
  if ( v17 && *v17 )
  {
    sub_E8F8C(a1, a8, (__int64)a8, v8, v9, v10);
    if ( *v17 == 1 )
    {
      sub_E904C(a1, a2, v15, 0, v12, (__int64)v14, *(_QWORD *)(v13 + 32), *(_BYTE *)(v13 + 26));
    }
    else if ( *v17 == 2 )
    {
      sub_E904C(a1, a2, v15, 0, a7, (__int64)v14, *(_QWORD *)(v13 + 32), *(_BYTE *)(v13 + 26));
    }
    else
    {
      sub_12222(
        *v14,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_yin.c",
        1841LL);
    }
  }
  return __readfsqword(0x28u) ^ v18;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000F0A50) ----------------------------------------------------
unsigned __int64 __fastcall sub_F0A50(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, _DWORD *a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  _DWORD *v10; // [rsp+8h] [rbp-48h]
  __int64 v11; // [rsp+10h] [rbp-40h]
  __int64 v12; // [rsp+18h] [rbp-38h]
  int v13; // [rsp+20h] [rbp-30h]
  int v14; // [rsp+34h] [rbp-1Ch]
  __int64 v15; // [rsp+38h] [rbp-18h]
  __int64 *v16; // [rsp+40h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v13 = a5;
  v10 = a6;
  v17 = __readfsqword(0x28u);
  v16 = (__int64 *)lys_ext_complex_get_substmt(a5, a4, &v15);
  if ( v16 && *v16 )
  {
    if ( *(_DWORD *)(v15 + 16) <= 1u )
    {
      sub_E8F8C(a1, v10, (__int64)v10, v6, v7, v8);
      sub_E904C(a1, a2, v13, 0, *v16, v12, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
    }
    else
    {
      v16 = (__int64 *)*v16;
      v14 = 0;
      while ( *v16 )
      {
        sub_E8F8C(a1, v10, (__int64)v10, v6, v7, v8);
        sub_E904C(a1, a2, v13, v14, *v16, v12, *(_QWORD *)(v11 + 32), *(_BYTE *)(v11 + 26));
        ++v16;
        ++v14;
      }
    }
  }
  return __readfsqword(0x28u) ^ v17;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000F0BA4) ----------------------------------------------------
_WORD *__fastcall sub_F0BA4(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, unsigned __int16 a8, unsigned __int16 a9, _DWORD *a10)
{
  _WORD *result; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // [rsp+8h] [rbp-38h]
  __int64 v15; // [rsp+10h] [rbp-30h]
  __int64 v16; // [rsp+18h] [rbp-28h]
  int v17; // [rsp+20h] [rbp-20h]
  __int64 v18; // [rsp+30h] [rbp-10h]

  v16 = a3;
  v15 = a4;
  v17 = a5;
  v14 = a6;
  result = (_WORD *)lys_ext_complex_get_substmt(a5, a4, 0LL);
  if ( result )
  {
    if ( a8 & *result )
    {
      v18 = v14;
    }
    else if ( a9 & *result )
    {
      v18 = a7;
    }
    else
    {
      result = (_WORD *)sub_9EAFC(*(_QWORD *)(v15 + 32), *(_BYTE *)(v15 + 26), 0, v17);
      if ( (_DWORD)result == -1 )
        return result;
      v18 = v14;
    }
    sub_E8F8C(a1, a10, (__int64)a10, v11, v12, v13);
    result = (_WORD *)sub_E904C(a1, a2, v17, 0, v18, v16, *(_QWORD *)(v15 + 32), *(_BYTE *)(v15 + 26));
  }
  return result;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (00000000000F0CAF) ----------------------------------------------------
unsigned __int64 __fastcall sub_F0CAF(__int64 a1, int a2, __int64 a3, int a4, char a5, __int64 a6, unsigned int a7)
{
  __int64 v7; // rax
  int v8; // ST44_4
  __int64 v9; // rsi
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  signed __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  const char *v22; // rax
  __int64 v23; // r9
  const char *v24; // rax
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  const char *v30; // rax
  __int64 v31; // rcx
  __int64 v32; // r9
  __int64 v33; // r9
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rcx
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 v44; // rcx
  __int64 v45; // rcx
  __int64 v46; // rcx
  __int64 v47; // rcx
  __int64 v48; // r8
  __int64 v49; // r9
  __int64 v50; // rcx
  __int64 v51; // r8
  __int64 v52; // r9
  __int64 v53; // r8
  __int64 v54; // r9
  __int64 v55; // rcx
  __int64 v56; // r8
  __int64 v57; // r9
  __int64 v58; // rcx
  __int64 v59; // r8
  __int64 v60; // r9
  __int64 v61; // r8
  __int64 v62; // r9
  unsigned int v63; // eax
  __int64 v64; // r8
  __int64 v65; // r9
  __int64 v66; // rcx
  __int64 v67; // rcx
  __int64 v68; // rcx
  __int64 v69; // rcx
  __int64 v70; // rcx
  __int64 v71; // rcx
  __int64 v73; // [rsp+8h] [rbp-98h]
  char v74; // [rsp+14h] [rbp-8Ch]
  __int64 v75; // [rsp+18h] [rbp-88h]
  int v76; // [rsp+20h] [rbp-80h]
  int v77; // [rsp+24h] [rbp-7Ch]
  unsigned int v78; // [rsp+24h] [rbp-7Ch]
  unsigned int v79; // [rsp+3Ch] [rbp-64h]
  unsigned int v80; // [rsp+40h] [rbp-60h]
  unsigned int i; // [rsp+44h] [rbp-5Ch]
  unsigned int j; // [rsp+48h] [rbp-58h]
  int v83; // [rsp+4Ch] [rbp-54h]
  int k; // [rsp+50h] [rbp-50h]
  int l; // [rsp+54h] [rbp-4Ch]
  __int64 v86; // [rsp+58h] [rbp-48h]
  const char *v87; // [rsp+60h] [rbp-40h]
  __int64 *m; // [rsp+68h] [rbp-38h]
  __int64 n; // [rsp+70h] [rbp-30h]
  __int64 v90; // [rsp+78h] [rbp-28h]
  __int64 v91; // [rsp+80h] [rbp-20h]
  unsigned int **v92; // [rsp+88h] [rbp-18h]
  _WORD *v93; // [rsp+90h] [rbp-10h]
  unsigned __int64 v94; // [rsp+98h] [rbp-8h]

  v77 = a2;
  v75 = a3;
  v76 = a4;
  v73 = a6;
  v74 = a5;
  v94 = __readfsqword(0x28u);
  v86 = 0LL;
  for ( i = 0; i < a7; ++i )
  {
    if ( !(*(_WORD *)(*(_QWORD *)(8LL * i + v73) + 24LL) & 1)
      && v76 == *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 28LL)
      && v74 == *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 27LL)
      && (*(_QWORD *)(**(_QWORD **)(8LL * i + v73) + 48LL) != **(_QWORD **)(*(_QWORD *)v75 + 64LL)
       || strcmp(*(const char **)(*(_QWORD *)(8LL * i + v73) + 16LL), "operation")
       && strcmp(*(const char **)(*(_QWORD *)(8LL * i + v73) + 16LL), "select")
       && strcmp(*(const char **)(*(_QWORD *)(8LL * i + v73) + 16LL), "type")) )
    {
      v90 = lys_main_module(*(_QWORD *)(**(_QWORD **)(8LL * i + v73) + 48LL));
      v7 = lys_main_module(v75);
      if ( v90 == v7 )
      {
        v86 = *(_QWORD *)(v75 + 16);
      }
      else
      {
        for ( j = 0; j < *(unsigned __int8 *)(v75 + 69); ++j )
        {
          if ( v90 == *(_QWORD *)(*(_QWORD *)(v75 + 96) + 56LL * j) )
          {
            v86 = *(_QWORD *)(*(_QWORD *)(v75 + 96) + 56LL * j + 8);
            break;
          }
        }
      }
      if ( !v86 )
        __assert_fail(
          "prefix",
          "/home/mantovan/Repositories/libyang/src/printer_yin.c",
          0x7C5u,
          "yin_print_extension_instances");
      v79 = 0;
      if ( *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 16LL) )
      {
        if ( *(_WORD *)(**(_QWORD **)(8LL * i + v73) + 24LL) & 1 )
        {
          v79 = 1;
          sub_E8DAF(a1, v77, v86, ***(_QWORD ***)(8LL * i + v73), 0LL, 0LL, 1);
          v8 = v77 + 1;
          sub_C1FF7(
            a1,
            "%*s<%s:%s>",
            (unsigned int)(2 * v8),
            (__int64)&unk_127870,
            v86,
            *(_QWORD *)(**(_QWORD **)(8LL * i + v73) + 40LL));
          v9 = *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 16LL);
          sub_341EA(a1, v9, 2, v9, v10, v11);
          sub_C1FF7(a1, "</%s:%s>\n", v86, *(_QWORD *)(**(_QWORD **)(8LL * i + v73) + 40LL), v12, v13);
          v77 = v8 - 1;
        }
        else
        {
          sub_E8DAF(
            a1,
            v77,
            v86,
            ***(_QWORD ***)(8LL * i + v73),
            *(_QWORD *)(**(_QWORD **)(8LL * i + v73) + 40LL),
            *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 16LL),
            v79);
        }
      }
      else
      {
        sub_E8DAF(a1, v77, v86, ***(_QWORD ***)(8LL * i + v73), 0LL, 0LL, v79);
      }
      if ( *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL) )
      {
        sub_E8F8C(a1, &v79, (__int64)&v79, v14, v15, v16);
        sub_F0CAF(
          a1,
          v77 + 1,
          v75,
          0,
          0,
          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL));
      }
      v17 = 8LL * i;
      if ( *(_BYTE *)(*(_QWORD *)(v17 + v73) + 30LL) )
      {
        if ( *(_BYTE *)(*(_QWORD *)(v17 + v73) + 30LL) == 1 )
        {
          v91 = *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 64LL);
          if ( v91 )
          {
            v78 = v77 + 1;
            v83 = 0;
            while ( 2 )
            {
              if ( !*(_DWORD *)(24LL * v83 + v91) )
              {
                v77 = v78 - 1;
                break;
              }
              switch ( *(_DWORD *)(24LL * v83 + v91) )
              {
                case 1:
                  m = (__int64 *)lys_ext_complex_get_substmt(1LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    sub_E8F8C(a1, &v79, (__int64)&v79, v18, v15, v16);
                    if ( *(_DWORD *)(v91 + 16) <= 1u )
                    {
                      v80 = 0;
                      sub_E8DAF(a1, v78, 0LL, (__int64)"argument", (__int64)"name", *m, 0);
                      for ( k = -1;
                            ;
                            sub_F0CAF(
                              a1,
                              v78 + 1,
                              v75,
                              1,
                              0,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k,
                              1u) )
                      {
                        k = sub_9EAFC(
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                              *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                              (unsigned __int8)k + 1,
                              1);
                        if ( k == -1 )
                          break;
                        sub_E8F8C(a1, &v80, (__int64)&v80, v27, v28, v29);
                      }
                      if ( *((_BYTE *)m + 8) == 1
                        || (unsigned int)sub_9EAFC(
                                           *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                                           *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                                           0,
                                           22) != -1 )
                      {
                        sub_E8F8C(a1, &v80, (__int64)&v80, v27, v28, v29);
                        if ( *((_BYTE *)m + 8) == 1 )
                          v30 = "true";
                        else
                          v30 = "false";
                        sub_E904C(
                          a1,
                          v78 + 1,
                          22,
                          0,
                          (__int64)v30,
                          v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL));
                      }
                      sub_E8EE6(a1, v78, 0LL, (__int64)"argument", v80, v29);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)(8LL * l + *m); ++l )
                      {
                        v80 = 0;
                        sub_E8DAF(a1, v78, 0LL, (__int64)"argument", (__int64)"name", *(_QWORD *)(8LL * l + *m), 0);
                        k = -1;
                        while ( 1 )
                        {
                          k = sub_9EAFC(
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                                (unsigned __int8)k + 1,
                                1);
                          if ( k == -1 )
                            break;
                          if ( l == *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                   + *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL))
                                                       + 27LL) )
                          {
                            sub_E8F8C(a1, &v80, (__int64)&v80, v19, v20, v21);
                            sub_F0CAF(
                              a1,
                              v78 + 1,
                              v75,
                              1,
                              l,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k,
                              1u);
                          }
                        }
                        if ( *(_BYTE *)(m[1] + l) == 1 )
                        {
                          sub_E8F8C(a1, &v80, (__int64)&v80, v19, v20, v21);
                          if ( *(_BYTE *)(m[1] + l) == 1 )
                            v22 = "true";
                          else
                            v22 = "false";
                          sub_E904C(
                            a1,
                            v78 + 1,
                            22,
                            l,
                            (__int64)v22,
                            v75,
                            *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                            *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL));
                        }
                        else
                        {
                          k = -1;
                          while ( 1 )
                          {
                            k = sub_9EAFC(
                                  *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                                  *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                                  (unsigned __int8)k + 1,
                                  22);
                            if ( k == -1 )
                              break;
                            if ( l == *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                     + *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL))
                                                         + 27LL) )
                            {
                              sub_E8F8C(a1, &v80, (__int64)&v80, v25, v26, v23);
                              if ( *(_BYTE *)(m[1] + l) == 1 )
                                v24 = "true";
                              else
                                v24 = "false";
                              sub_E904C(
                                a1,
                                v78 + 1,
                                22,
                                l,
                                (__int64)v24,
                                v75,
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k,
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL) - k);
                              break;
                            }
                          }
                        }
                        sub_E8EE6(a1, v78, 0LL, (__int64)"argument", v80, v23);
                      }
                    }
                  }
                  goto LABEL_241;
                case 2:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                case 0xD:
                case 0xE:
                case 0xF:
                case 0x10:
                case 0x11:
                  sub_F0A50(a1, v78, v75, *(_QWORD *)(8LL * i + v73), *(_DWORD *)(24LL * v83 + v91), &v79);
                  goto LABEL_241;
                case 3:
                  m = (__int64 *)lys_ext_complex_get_substmt(3LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v31, v15, v16);
                      sub_E8DAF(a1, v78, 0LL, (__int64)"belongs-to", (__int64)"module", *m, 1);
                      for ( k = -1;
                            ;
                            sub_F0CAF(
                              a1,
                              v78 + 1,
                              v75,
                              3,
                              0,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k,
                              1u) )
                      {
                        k = sub_9EAFC(
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                              *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                              (unsigned __int8)k + 1,
                              3);
                        if ( k == -1 )
                          break;
                      }
                      sub_E904C(
                        a1,
                        v78 + 1,
                        13,
                        0,
                        m[1],
                        v75,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                        *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL));
                      sub_E8EE6(a1, v78, 0LL, (__int64)"belongs-to", 1LL, v33);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)(8LL * l + *m); ++l )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v31, v15, v16);
                        sub_E8DAF(a1, v78, 0LL, (__int64)"belongs-to", (__int64)"module", *(_QWORD *)(8LL * l + *m), 1);
                        for ( k = -1;
                              ;
                              sub_F0CAF(
                                a1,
                                v78 + 1,
                                v75,
                                3,
                                l,
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k,
                                1u) )
                        {
                          k = sub_9EAFC(
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                                (unsigned __int8)k + 1,
                                3);
                          if ( k == -1 )
                            break;
                        }
                        sub_E904C(
                          a1,
                          v78 + 1,
                          13,
                          l,
                          *(_QWORD *)(8LL * l + m[1]),
                          v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL));
                        sub_E8EE6(a1, v78, 0LL, (__int64)"belongs-to", 1LL, v32);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x12:
                  v46 = *(_QWORD *)(8LL * i + v73);
                  v92 = (unsigned int **)(v46 + *(_QWORD *)(24LL * v83 + v91 + 8) + 64LL + 8);
                  if ( v92 && *v92 )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v46, v15, v16);
                      sub_EA3C7(
                        a1,
                        v78,
                        18LL,
                        0LL,
                        (__int64 *)v75,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                        **v92);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v92)[2 * l]; ++l )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v46, v15, v16);
                        sub_EA3C7(
                          a1,
                          v78,
                          18LL,
                          (unsigned __int8)l,
                          (__int64 *)v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                          **(_DWORD **)&(*v92)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x14:
                  sub_F08F7(
                    a1,
                    v78,
                    (__int64 *)v75,
                    *(_QWORD *)(8LL * i + v73),
                    0x14u,
                    (__int64)"invert-match",
                    0LL,
                    &v79);
                  goto LABEL_241;
                case 0x15:
                  sub_F08F7(
                    a1,
                    v78,
                    (__int64 *)v75,
                    *(_QWORD *)(8LL * i + v73),
                    *(_DWORD *)(24LL * v83 + v91),
                    (__int64)"true",
                    (__int64)"false",
                    &v79);
                  goto LABEL_241;
                case 0x17:
                  sub_F0BA4(
                    a1,
                    v78,
                    v75,
                    *(_QWORD *)(8LL * i + v73),
                    0x17u,
                    (__int64)"true",
                    (__int64)"false",
                    5u,
                    6u,
                    &v79);
                  goto LABEL_241;
                case 0x18:
                  sub_F0BA4(
                    a1,
                    v78,
                    v75,
                    *(_QWORD *)(8LL * i + v73),
                    0x18u,
                    (__int64)"false",
                    (__int64)"true",
                    0x80u,
                    0x40u,
                    &v79);
                  goto LABEL_241;
                case 0x19:
                  sub_F0BA4(
                    a1,
                    v78,
                    v75,
                    *(_QWORD *)(8LL * i + v73),
                    0x19u,
                    (__int64)"system",
                    (__int64)"user",
                    0,
                    0x100u,
                    &v79);
                  goto LABEL_241;
                case 0x1A:
                  v41 = *(_QWORD *)(8LL * i + v73);
                  v93 = (_WORD *)(v41 + *(_QWORD *)(24LL * v83 + v91 + 8) + 64LL + 8);
                  if ( !v93 || !*v93 )
                    goto LABEL_241;
                  if ( *v93 & 8 )
                  {
                    sub_E8F8C(a1, &v79, (__int64)&v79, v41, v15, v16);
                    v87 = "current";
                  }
                  else if ( *v93 & 0x10 )
                  {
                    sub_E8F8C(a1, &v79, (__int64)&v79, v41, v15, v16);
                    v87 = "deprecated";
                  }
                  else
                  {
                    if ( !(*v93 & 0x20) )
                    {
LABEL_241:
                      ++v83;
                      continue;
                    }
                    sub_E8F8C(a1, &v79, (__int64)&v79, v41, v15, v16);
                    v87 = "obsolete";
                  }
                  sub_E904C(
                    a1,
                    v78,
                    26,
                    0,
                    (__int64)v87,
                    v75,
                    *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                    *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL));
                  goto LABEL_241;
                case 0x1B:
                  v42 = *(_QWORD *)(8LL * i + v73);
                  v92 = (unsigned int **)(v42 + *(_QWORD *)(24LL * v83 + v91 + 8) + 64LL + 8);
                  if ( v92 )
                  {
                    if ( *(_DWORD *)(v91 + 16) > 1u && *v92 )
                    {
                      for ( l = 0; *((_BYTE *)*v92 + l); ++l )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v42, v15, v16);
                        sub_EA2FF(
                          a1,
                          v78,
                          27LL,
                          (unsigned __int8)l,
                          (__int64 *)v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                          *((unsigned __int8 *)*v92 + l));
                      }
                    }
                    else if ( *(_BYTE *)v92 )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v42, v15, v16);
                      sub_EA2FF(
                        a1,
                        v78,
                        27LL,
                        0LL,
                        (__int64 *)v75,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                        *(unsigned __int8 *)v92);
                    }
                  }
                  goto LABEL_241;
                case 0x1C:
                  v43 = *(_QWORD *)(8LL * i + v73);
                  v92 = (unsigned int **)(v43 + *(_QWORD *)(24LL * v83 + v91 + 8) + 64LL + 8);
                  if ( v92 && *v92 )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v43, v15, v16);
                      sub_EA2FF(
                        a1,
                        v78,
                        28LL,
                        0LL,
                        (__int64 *)v75,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                        **v92);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v92)[2 * l]; ++l )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v43, v15, v16);
                        sub_EA2FF(
                          a1,
                          v78,
                          28LL,
                          (unsigned __int8)l,
                          (__int64 *)v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                          **(_DWORD **)&(*v92)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x1D:
                  v44 = *(_QWORD *)(8LL * i + v73);
                  v92 = (unsigned int **)(v44 + *(_QWORD *)(24LL * v83 + v91 + 8) + 64LL + 8);
                  if ( v92 && *v92 )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v44, v15, v16);
                      sub_EA2FF(
                        a1,
                        v78,
                        29LL,
                        0LL,
                        (__int64 *)v75,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                        **v92);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v92)[2 * l]; ++l )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v44, v15, v16);
                        sub_EA2FF(
                          a1,
                          v78,
                          29LL,
                          (unsigned __int8)l,
                          (__int64 *)v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                          **(_DWORD **)&(*v92)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x1E:
                  v45 = *(_QWORD *)(8LL * i + v73);
                  v92 = (unsigned int **)(v45 + *(_QWORD *)(24LL * v83 + v91 + 8) + 64LL + 8);
                  if ( v92 && *v92 )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v45, v15, v16);
                      sub_EA2FF(
                        a1,
                        v78,
                        30LL,
                        0LL,
                        (__int64 *)v75,
                        *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                        *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                        **v92);
                    }
                    else
                    {
                      for ( l = 0; *(_QWORD *)&(*v92)[2 * l]; ++l )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v45, v15, v16);
                        sub_EA2FF(
                          a1,
                          v78,
                          30LL,
                          (unsigned __int8)l,
                          (__int64 *)v75,
                          *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                          *(unsigned __int8 *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                          **(_DWORD **)&(*v92)[2 * l]);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x1F:
                  m = (__int64 *)lys_ext_complex_get_substmt(31LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v47, v15, v16);
                      sub_EB1FC(a1, v78, (__int64 *)v75, *m, v53, v54);
                      k = -1;
                      v80 = 0;
                      while ( 1 )
                      {
                        k = sub_9EAFC(
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                              *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                              (unsigned __int8)k + 1,
                              31);
                        if ( k == -1 )
                          break;
                        sub_E8F8C(a1, &v80, (__int64)&v80, v55, v56, v57);
                        sub_F0CAF(a1, v78 + 1, v75, 31, 0, *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k, 1u);
                      }
                      sub_E8EE6(a1, v78, 0LL, (__int64)"unique", v80, v57);
                    }
                    else
                    {
                      m = (__int64 *)*m;
                      l = 0;
                      while ( *m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v47, v15, v16);
                        sub_EB1FC(a1, v78, (__int64 *)v75, *m, v48, v49);
                        k = -1;
                        v80 = 0;
                        do
                          k = sub_9EAFC(
                                *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                                (unsigned __int8)k + 1,
                                31);
                        while ( k != -1
                             && l != *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                    + *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL))
                                                        + 27LL) );
                        if ( k != -1 )
                        {
                          sub_E8F8C(a1, &v80, (__int64)&v80, v50, v51, v52);
                          do
                          {
                            sub_F0CAF(
                              a1,
                              v78 + 1,
                              v75,
                              31,
                              l,
                              *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL) + 8LL * k,
                              1u);
                            do
                              k = sub_9EAFC(
                                    *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL),
                                    *(_BYTE *)(*(_QWORD *)(8LL * i + v73) + 26LL),
                                    (unsigned __int8)k + 1,
                                    31);
                            while ( k != -1
                                 && l != *(unsigned __int8 *)(*(_QWORD *)(8LL * k
                                                                        + *(_QWORD *)(*(_QWORD *)(8LL * i + v73) + 32LL))
                                                            + 27LL) );
                          }
                          while ( k != -1 );
                        }
                        sub_E8EE6(a1, v78, 0LL, (__int64)"unique", v80, v52);
                        ++m;
                        ++l;
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x20:
                  m = (__int64 *)lys_ext_complex_get_substmt(32LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v58, v15, v16);
                      sub_EF8CE(a1, v78, *m, v78, v61, v62);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v58, v15, v16);
                        sub_EF8CE(a1, v78, *m, v78, v59, v60);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x21:
                case 0x22:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                  m = (__int64 *)lys_ext_complex_get_substmt(
                                   *(unsigned int *)(24LL * v83 + v91),
                                   *(_QWORD *)(8LL * i + v73),
                                   0LL);
                  if ( m && *m )
                  {
                    for ( n = *m; n; n = *(_QWORD *)(n + 80) )
                    {
                      v63 = sub_C1906(*(_DWORD *)(n + 56));
                      if ( v63 == *(_DWORD *)(24LL * v83 + v91) )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v63, v15, v16);
                        sub_EF3B4(a1, v78, n, 0xFFFFu, v64, v65);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x2F:
                  m = (__int64 *)lys_ext_complex_get_substmt(47LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v35, v15, v16);
                      sub_EC70B(a1, v78, (__int64 *)v75, (__int64 *)*m);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v35, v15, v16);
                        sub_EC70B(a1, v78, (__int64 *)v75, (__int64 *)*m);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x30:
                  m = (__int64 *)lys_ext_complex_get_substmt(48LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v34, v15, v16);
                      sub_EA48F(a1, v78, (__int64 *)v75, *m);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v34, v15, v16);
                        sub_EA48F(a1, v78, (__int64 *)v75, *m);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x31:
                  m = (__int64 *)lys_ext_complex_get_substmt(49LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v36, v15, v16);
                      sub_E933F(a1, v78, v75, *m, v39, v40);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v36, v15, v16);
                        sub_E933F(a1, v78, v75, *m, v37, v38);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x32:
                  m = (__int64 *)lys_ext_complex_get_substmt(50LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v66, v15, v16);
                      sub_E9F06(a1, v78, v75, (_BYTE **)*m, (__int64)"length");
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v66, v15, v16);
                        sub_E9F06(a1, v78, v75, (_BYTE **)*m, (__int64)"length");
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x33:
                  m = (__int64 *)lys_ext_complex_get_substmt(51LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v67, v15, v16);
                      sub_EB0CE(a1, v78, (__int64 *)v75, (const char **)*m);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v67, v15, v16);
                        sub_EB0CE(a1, v78, (__int64 *)v75, (const char **)*m);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x34:
                  m = (__int64 *)lys_ext_complex_get_substmt(52LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v68, v15, v16);
                      sub_E9F06(a1, v78, v75, (_BYTE **)*m, (__int64)"pattern");
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v68, v15, v16);
                        sub_E9F06(a1, v78, v75, (_BYTE **)*m, (__int64)"pattern");
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x35:
                  m = (__int64 *)lys_ext_complex_get_substmt(53LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v69, v15, v16);
                      sub_E9F06(a1, v78, v75, (_BYTE **)*m, (__int64)"range");
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v69, v15, v16);
                        sub_E9F06(a1, v78, v75, (_BYTE **)*m, (__int64)"range");
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x36:
                  m = (__int64 *)lys_ext_complex_get_substmt(54LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v70, v15, v16);
                      sub_EA0C6(a1, v78, (__int64 *)v75, (const char **)*m);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v70, v15, v16);
                        sub_EA0C6(a1, v78, (__int64 *)v75, (const char **)*m);
                      }
                    }
                  }
                  goto LABEL_241;
                case 0x37:
                  m = (__int64 *)lys_ext_complex_get_substmt(55LL, *(_QWORD *)(8LL * i + v73), 0LL);
                  if ( m && *m )
                  {
                    if ( *(_DWORD *)(24LL * v83 + v91 + 16) <= 1u )
                    {
                      sub_E8F8C(a1, &v79, (__int64)&v79, v71, v15, v16);
                      sub_EF5BC(a1, v78, v75, *m);
                    }
                    else
                    {
                      for ( m = (__int64 *)*m; *m; ++m )
                      {
                        sub_E8F8C(a1, &v79, (__int64)&v79, v71, v15, v16);
                        sub_EF5BC(a1, v78, v75, *m);
                      }
                    }
                  }
                  goto LABEL_241;
                default:
                  goto LABEL_241;
              }
            }
          }
        }
      }
      sub_E8EE6(a1, v77, v86, ***(_QWORD ***)(8LL * i + v73), v79, v16);
    }
  }
  return __readfsqword(0x28u) ^ v94;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F391A) ----------------------------------------------------
const char *__fastcall sub_F391A(unsigned int a1)
{
  if ( a1 == 64 )
    return "case";
  if ( a1 > 0x40 )
  {
    if ( a1 == 512 )
      return "input";
    if ( a1 > 0x200 )
    {
      switch ( a1 )
      {
        case 0x4000u:
          return "action";
        case 0x8020u:
          return "anydata";
        case 0x400u:
          return "output";
      }
    }
    else
    {
      if ( a1 == 128 )
        return "notification";
      if ( a1 == 256 )
        return "rpc";
    }
  }
  else
  {
    if ( a1 == 4 )
      return "leaf";
    if ( a1 > 4 )
    {
      switch ( a1 )
      {
        case 0x10u:
          return "list";
        case 0x20u:
          return "anyxml";
        case 8u:
          return "leaf-list";
      }
    }
    else
    {
      if ( a1 == 1 )
        return "container";
      if ( a1 == 2 )
        return "choice";
    }
  }
  return 0LL;
}

//----- (00000000000F3A17) ----------------------------------------------------
void __fastcall sub_F3A17(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, _DWORD *a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  _DWORD *v11; // [rsp+0h] [rbp-30h]
  int v12; // [rsp+Ch] [rbp-24h]
  __int64 v13; // [rsp+10h] [rbp-20h]

  v13 = a4;
  v12 = a5;
  if ( a4 )
  {
    if ( a6 && *a6 )
      v6 = (const char *)&unk_127F9E;
    else
      v6 = ",";
    sub_C1FF7(a1, "%s\"%s\":{\"%s\":", (__int64)v6, a2, a3, (__int64)a6, a6);
    sub_102CD8(a1, v13);
    if ( v12 )
      sub_C1FF7(a1, "}", v7, v8, v9, v10);
    if ( v11 )
      *v11 = 0;
  }
}

//----- (00000000000F3AD0) ----------------------------------------------------
void __fastcall sub_F3AD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, _DWORD *a6)
{
  const char *v6; // rdx
  const char *v7; // rax
  _DWORD *v8; // [rsp+0h] [rbp-30h]
  __int64 v9; // [rsp+18h] [rbp-18h]

  v9 = a3;
  v8 = a6;
  if ( a4 )
  {
    if ( a5 )
      v6 = "}";
    else
      v6 = (const char *)&unk_127F9E;
    if ( a6 && *a6 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"%s\":{\"%s\":\"%s\"%s", (__int64)v7, a2, v9, a4, v6);
    if ( v8 )
      *v8 = 0;
  }
}

//----- (00000000000F3B77) ----------------------------------------------------
void __fastcall sub_F3B77(__int64 a1, char a2, _DWORD *a3)
{
  if ( a2 & 0x38 )
  {
    if ( a2 & 0x20 )
    {
      sub_F3AD0(a1, (__int64)"status", (__int64)"value", (__int64)"obsolete", 1, a3);
    }
    else if ( a2 & 0x10 )
    {
      sub_F3AD0(a1, (__int64)"status", (__int64)"value", (__int64)"deprecated", 1, a3);
    }
    else
    {
      sub_F3AD0(a1, (__int64)"status", (__int64)"value", (__int64)"current", 1, a3);
    }
  }
}

//----- (00000000000F3C04) ----------------------------------------------------
void __fastcall sub_F3C04(__int64 a1, char a2, _DWORD *a3)
{
  const char *v3; // [rsp+28h] [rbp-8h]

  v3 = 0LL;
  if ( a2 & 3 )
  {
    if ( a2 & 2 )
    {
      sub_F3AD0(a1, (__int64)"config", (__int64)"value", (__int64)"false", 1, a3);
    }
    else
    {
      if ( a2 & 1 )
        v3 = "true";
      sub_F3AD0(a1, (__int64)"config", (__int64)"value", (__int64)v3, 1, a3);
    }
  }
}

//----- (00000000000F3C8C) ----------------------------------------------------
void __fastcall sub_F3C8C(__int64 a1, char a2, _DWORD *a3)
{
  const char *v3; // [rsp+28h] [rbp-8h]

  v3 = 0LL;
  if ( a2 & 0xC0 )
  {
    if ( a2 & 0x40 )
    {
      sub_F3AD0(a1, (__int64)"mandatory", (__int64)"value", (__int64)"true", 1, a3);
    }
    else
    {
      if ( a2 & 0x80 )
        v3 = "false";
      sub_F3AD0(a1, (__int64)"mandatory", (__int64)"value", (__int64)v3, 1, a3);
    }
  }
}

//----- (00000000000F3D18) ----------------------------------------------------
void __fastcall sub_F3D18(__int64 a1, __int16 a2, _DWORD *a3)
{
  if ( a2 & 0x100 )
    sub_F3AD0(a1, (__int64)"ordered-by", (__int64)"value", (__int64)"user", 1, a3);
  else
    sub_F3AD0(a1, (__int64)"ordered-by", (__int64)"value", (__int64)"system", 1, a3);
}

//----- (00000000000F3D9C) ----------------------------------------------------
signed __int64 __fastcall sub_F3D9C(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _DWORD *a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  _DWORD *v17; // [rsp+8h] [rbp-38h]
  unsigned __int8 v18; // [rsp+14h] [rbp-2Ch]
  __int64 v19; // [rsp+18h] [rbp-28h]
  signed int i; // [rsp+3Ch] [rbp-4h]

  v19 = a3;
  result = a4;
  v17 = a5;
  v18 = a4;
  if ( (_BYTE)a4 )
  {
    if ( a5 && *a5 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"if-features\":[", (__int64)v7, a1, (__int64)a5, a6);
    for ( i = 0; i < v18; ++i )
    {
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"", (__int64)v12, a1, v10, v11);
      sub_C2DA0(a1, a2, (__int64 *)(v19 + 32LL * i), 3u);
      sub_C1FF7(a1, "\"", v13, v14, v15, v16);
    }
    result = sub_C1FF7(a1, "]", v8, v9, v10, v11);
    if ( v17 )
    {
      result = (signed __int64)v17;
      *v17 = 0;
    }
  }
  return result;
}

//----- (00000000000F3EB4) ----------------------------------------------------
signed __int64 __fastcall sub_F3EB4(__int64 a1, __int64 *a2, _DWORD *a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  signed __int64 result; // rax

  if ( a2 )
  {
    sub_F3A17(a1, (__int64)"when", (__int64)"condition", *a2, 0, a3);
    sub_F3A17(a1, (__int64)"description", (__int64)"text", a2[1], 1, 0LL);
    sub_F3A17(a1, (__int64)"reference", (__int64)"text", a2[2], 1, 0LL);
    result = sub_C1FF7(a1, "}", v3, v4, v5, v6);
  }
  return result;
}

//----- (00000000000F3F83) ----------------------------------------------------
void __fastcall sub_F3F83(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  _BYTE *v6; // rax
  const char *v7; // rax
  _BYTE *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  _DWORD *v13; // [rsp+0h] [rbp-30h]
  _DWORD *v14; // [rsp+0h] [rbp-30h]
  signed int v15; // [rsp+2Ch] [rbp-4h]

  v13 = a4;
  v15 = 0;
  if ( a2 )
  {
    if ( *(_BYTE *)*a2 == 6 || *(_BYTE *)*a2 == 21 )
      v15 = 1;
    if ( a3 )
    {
      if ( v15 )
        v6 = (_BYTE *)(*a2 + 1);
      else
        v6 = (_BYTE *)*a2;
      sub_F3A17(a1, a3, (__int64)"value", (__int64)v6, 0, a4);
    }
    else
    {
      if ( a4 && *a4 )
        v7 = (const char *)&unk_127F9E;
      else
        v7 = ",";
      sub_C1FF7(a1, "%s{\"%s\":", (__int64)v7, (__int64)"value", a5, a6, a4);
      if ( v15 )
        v8 = (_BYTE *)(*a2 + 1);
      else
        v8 = (_BYTE *)*a2;
      sub_102CD8(a1, (__int64)v8);
    }
    if ( v15 && *(_BYTE *)*a2 == 21 )
      sub_F3AD0(a1, (__int64)"modifier", (__int64)"value", (__int64)"invert-match", 1, 0LL);
    sub_F3A17(a1, (__int64)"description", (__int64)"text", a2[1], 1, 0LL);
    sub_F3A17(a1, (__int64)"reference", (__int64)"text", a2[2], 1, 0LL);
    sub_F3AD0(a1, (__int64)"error-app-tag", (__int64)"value", a2[3], 1, 0LL);
    sub_F3A17(a1, (__int64)"error-message", (__int64)"value", a2[4], 1, 0LL);
    sub_C1FF7(a1, "}", v9, v10, v11, v12, v13);
    if ( v14 )
      *v14 = 0;
  }
}

//----- (00000000000F41B3) ----------------------------------------------------
unsigned __int64 __fastcall sub_F41B3(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned __int8 v12; // [rsp+Ch] [rbp-24h]
  int v13; // [rsp+20h] [rbp-10h]
  int i; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v15; // [rsp+28h] [rbp-8h]

  v12 = a3;
  v15 = __readfsqword(0x28u);
  if ( a3 )
  {
    if ( a4 && *a4 )
      v6 = (const char *)&unk_127F9E;
    else
      v6 = ",";
    sub_C1FF7(a1, "%s\"musts\":[", (__int64)v6, a1, a5, a6, a4);
    v13 = 1;
    for ( i = 0; i < v12; ++i )
      sub_F3F83(a1, (__int64 *)(56LL * i + a2), 0LL, &v13, v9, v10);
    sub_C1FF7(a1, "]", v7, v8, v9, v10);
  }
  return __readfsqword(0x28u) ^ v15;
}

//----- (00000000000F42A6) ----------------------------------------------------
unsigned __int64 __fastcall sub_F42A6(__int64 a1, __int64 a2, int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  const char *v26; // rax
  __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // r8
  __int64 v33; // r9
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  const char *v45; // rax
  __int64 v46; // r9
  __int64 v47; // rdx
  __int64 v48; // rcx
  __int64 v49; // r8
  __int64 v50; // r9
  __int64 v51; // rdx
  __int64 v52; // rcx
  __int64 v53; // r8
  __int64 v54; // r9
  void *v55; // rsi
  const char *v56; // rdx
  const char *v57; // rax
  const char *v58; // rax
  __int64 v59; // r8
  __int64 v60; // r9
  __int64 v61; // rdx
  __int64 v62; // rcx
  __int64 v63; // r8
  __int64 v64; // r9
  void *v65; // rcx
  const char *v66; // rax
  const char *v67; // rax
  __int64 v68; // r8
  __int64 v69; // r9
  __int64 v70; // rdx
  __int64 v71; // rcx
  __int64 v72; // r8
  __int64 v73; // r9
  __int64 v74; // rdx
  __int64 v75; // rcx
  __int64 v76; // r8
  __int64 v77; // r9
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 v80; // r8
  __int64 v81; // r9
  __int64 v82; // rcx
  __int64 v83; // r8
  __int64 v84; // r9
  void *v85; // rcx
  const char *v86; // rax
  _DWORD *v88; // [rsp+0h] [rbp-40h]
  __int64 v89; // [rsp+10h] [rbp-30h]
  int v90; // [rsp+20h] [rbp-20h]
  unsigned int i; // [rsp+24h] [rbp-1Ch]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 v93; // [rsp+30h] [rbp-10h]
  unsigned __int64 v94; // [rsp+38h] [rbp-8h]

  v89 = a2;
  v94 = __readfsqword(0x28u);
  if ( a2 )
  {
    if ( a3 )
    {
      if ( a4 && *a4 )
        v6 = (const char *)&unk_127F9E;
      else
        v6 = ",";
      sub_C1FF7(a1, "%s\"type\":{", (__int64)v6, a1, a5, a6, a4);
    }
    else
    {
      if ( a4 && *a4 )
        v11 = (const char *)&unk_127F9E;
      else
        v11 = ",";
      sub_C1FF7(a1, "%s{", (__int64)v11, a1, a5, a6, a4);
    }
    switch ( *(_DWORD *)a2 )
    {
      case 1:
        sub_C1FF7(a1, "\"basetype\":\"binary\"", v7, v8, v9, v10);
        sub_F3F83(a1, *(__int64 **)(a2 + 32), (__int64)"length", 0LL, v12, v13);
        break;
      case 2:
        sub_C1FF7(a1, "\"basetype\":\"bits\"", v7, v8, v9, v10);
        sub_C1FF7(a1, ",\"bits\":[", v18, v19, v20, v21);
        for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
        {
          if ( i )
            v26 = ",";
          else
            v26 = (const char *)&unk_127F9E;
          sub_C1FF7(
            a1,
            "%s{\"position\":\"%u\",\"name\":\"%s\"",
            (__int64)v26,
            *(unsigned int *)(*(_QWORD *)(a2 + 32) + 48LL * i + 28),
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i),
            v25);
          sub_F3A17(
            a1,
            (__int64)"description",
            (__int64)"text",
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 8),
            1,
            0LL);
          sub_F3A17(
            a1,
            (__int64)"reference",
            (__int64)"text",
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 16),
            1,
            0LL);
          sub_F3B77(a1, *(_WORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 24), 0LL);
          sub_F3D9C(
            a1,
            *(_QWORD *)(*(_QWORD *)(a2 + 24) + 48LL),
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 40),
            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * i + 27),
            0LL,
            v27);
          sub_C1FF7(a1, "}", v28, v29, v30, v31);
        }
        sub_C1FF7(a1, "]", v22, v23, v24, v25);
        break;
      case 3:
        sub_C1FF7(a1, "\"basetype\":\"boolean\"", v7, v8, v9, v10);
        break;
      case 4:
        sub_C1FF7(a1, "\"basetype\":\"decimal64\"", v7, v8, v9, v10);
        sub_F3F83(a1, *(__int64 **)(a2 + 32), (__int64)"range", 0LL, v32, v33);
        sub_C1FF7(a1, ",\"fraction-digits\":{\"value\":\"%u\"}", *(unsigned __int8 *)(a2 + 40), v34, v35, v36);
        break;
      case 5:
        sub_C1FF7(a1, "\"basetype\":\"empty\"", v7, v8, v9, v10);
        break;
      case 6:
        sub_C1FF7(a1, "\"basetype\":\"enumeration\"", v7, v8, v9, v10);
        sub_C1FF7(a1, ",\"enums\":[", v37, v38, v39, v40);
        for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
        {
          if ( i )
            v45 = ",";
          else
            v45 = (const char *)&unk_127F9E;
          sub_C1FF7(
            a1,
            "%s{\"value\":\"%d\",\"name\":\"%s\"",
            (__int64)v45,
            *(unsigned int *)(*(_QWORD *)(a2 + 32) + 48LL * i + 28),
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i),
            v44);
          sub_F3A17(
            a1,
            (__int64)"description",
            (__int64)"text",
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 8),
            1,
            0LL);
          sub_F3A17(
            a1,
            (__int64)"reference",
            (__int64)"text",
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 16),
            1,
            0LL);
          sub_F3B77(a1, *(_WORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 24), 0LL);
          sub_F3D9C(
            a1,
            *(_QWORD *)(*(_QWORD *)(a2 + 24) + 48LL),
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i + 40),
            *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + 48LL * i + 27),
            0LL,
            v46);
          sub_C1FF7(a1, "}", v47, v48, v49, v50);
        }
        sub_C1FF7(a1, "]", v41, v42, v43, v44);
        break;
      case 7:
        sub_C1FF7(a1, "\"basetype\":\"identityref\"", v7, v8, v9, v10);
        if ( *(_DWORD *)(a2 + 40) )
        {
          sub_C1FF7(a1, ",\"bases\":[", v14, v15, v16, v17);
          for ( i = 0; i < *(_DWORD *)(v89 + 40); ++i )
          {
            v93 = *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v89 + 32)) + 48LL);
            if ( *(_BYTE *)(v93 + 68) )
              v55 = *(void **)(v93 + 88);
            else
              v55 = &unk_127F9E;
            if ( *(_BYTE *)(v93 + 68) )
              v56 = "@";
            else
              v56 = (const char *)&unk_127F9E;
            if ( i )
              v57 = ",";
            else
              v57 = (const char *)&unk_127F9E;
            sub_C1FF7(
              a1,
              "%s\"%s%s%s:%s\"",
              (__int64)v57,
              *(_QWORD *)(v93 + 8),
              (__int64)v56,
              (__int64)v55,
              **(_QWORD **)(8LL * i + *(_QWORD *)(v89 + 32)));
          }
          sub_C1FF7(a1, "]", v51, v52, v53, v54);
        }
        break;
      case 8:
        sub_C1FF7(a1, "\"basetype\":\"instance-identifier\"", v7, v8, v9, v10);
        if ( *(_BYTE *)(a2 + 32) )
        {
          if ( *(_BYTE *)(a2 + 32) == -1 )
            v58 = "false";
          else
            v58 = "true";
          sub_F3AD0(a1, (__int64)"require-instance", (__int64)"value", (__int64)v58, 1, 0LL);
        }
        break;
      case 9:
        sub_C1FF7(a1, "\"basetype\":\"leafref\"", v7, v8, v9, v10);
        sub_F3A17(a1, (__int64)"path", (__int64)"value", *(_QWORD *)(a2 + 32), 0, 0LL);
        for ( j = *(_QWORD *)(a2 + 40); j && *(_QWORD *)(j + 64); j = lys_parent(j) )
          ;
        if ( j )
        {
          v93 = *(_QWORD *)(j + 48);
          if ( *(_BYTE *)(v93 + 68) )
            v65 = *(void **)(v93 + 88);
          else
            v65 = &unk_127F9E;
          if ( *(_BYTE *)(v93 + 68) )
            v66 = "@";
          else
            v66 = (const char *)&unk_127F9E;
          sub_C1FF7(a1, ",\"target-schema\":\"%s%s%s\"", *(_QWORD *)(v93 + 8), (__int64)v66, (__int64)v65, v64);
        }
        sub_C1FF7(a1, "}", v61, v62, v63, v64);
        if ( *(_BYTE *)(a2 + 48) )
        {
          if ( *(_BYTE *)(a2 + 48) == -1 )
            v67 = "false";
          else
            v67 = "true";
          sub_F3AD0(a1, (__int64)"require-instance", (__int64)"value", (__int64)v67, 1, 0LL);
        }
        break;
      case 0xA:
        sub_C1FF7(a1, "\"basetype\":\"string\"", v7, v8, v9, v10);
        sub_F3F83(a1, *(__int64 **)(a2 + 32), (__int64)"length", 0LL, v68, v69);
        if ( *(_DWORD *)(a2 + 48) )
        {
          sub_C1FF7(a1, ",\"patterns\":[", v14, v15, v16, v17);
          v90 = 1;
          for ( i = 0; i < *(_DWORD *)(a2 + 48); ++i )
            sub_F3F83(a1, (__int64 *)(*(_QWORD *)(a2 + 40) + 56LL * i), 0LL, &v90, v72, v73);
          sub_C1FF7(a1, "]", v70, v71, v72, v73);
        }
        break;
      case 0xB:
        sub_C1FF7(a1, "\"basetype\":\"union\"", v7, v8, v9, v10);
        sub_C1FF7(a1, ",\"types\":[", v74, v75, v76, v77);
        v90 = 1;
        for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
          sub_F42A6(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)i << 6), 0LL, &v90);
        sub_C1FF7(a1, "]", v78, v79, v80, v81);
        break;
      case 0xC:
        sub_C1FF7(a1, "\"basetype\":\"int8\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0xD:
        sub_C1FF7(a1, "\"basetype\":\"uint8\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0xE:
        sub_C1FF7(a1, "\"basetype\":\"int16\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0xF:
        sub_C1FF7(a1, "\"basetype\":\"uint16\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0x10:
        sub_C1FF7(a1, "\"basetype\":\"int32\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0x11:
        sub_C1FF7(a1, "\"basetype\":\"uint32\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0x12:
        sub_C1FF7(a1, "\"basetype\":\"int64\"", v7, v8, v9, v10);
        goto LABEL_59;
      case 0x13:
        sub_C1FF7(a1, "\"basetype\":\"uint64\"", v7, v8, v9, v10);
LABEL_59:
        sub_F3F83(a1, *(__int64 **)(a2 + 32), (__int64)"range", 0LL, v59, v60);
        break;
      default:
        sub_12222(
          **(_QWORD **)(*(_QWORD *)(a2 + 24) + 48LL),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/printer_json_schema.c",
          371LL);
        break;
    }
    if ( *(_QWORD *)(v89 + 16) )
    {
      sub_C1FF7(a1, ",\"derived-from\":", v14, v15, v16, v17);
      if ( *(_QWORD *)(*(_QWORD *)(v89 + 16) + 48LL) )
      {
        v93 = *(_QWORD *)(*(_QWORD *)(v89 + 16) + 48LL);
        if ( *(_BYTE *)(v93 + 68) )
          v85 = *(void **)(v93 + 88);
        else
          v85 = &unk_127F9E;
        if ( *(_BYTE *)(v93 + 68) )
          v86 = "@";
        else
          v86 = (const char *)&unk_127F9E;
        sub_C1FF7(a1, "\"%s%s%s:%s\"", *(_QWORD *)(v93 + 8), (__int64)v86, (__int64)v85, **(_QWORD **)(v89 + 16));
      }
      else
      {
        sub_C1FF7(a1, "\"%s\"", **(_QWORD **)(v89 + 16), v82, v83, v84);
      }
    }
    sub_C1FF7(a1, "}", v14, v15, v16, v17);
    if ( v88 )
      *v88 = 0;
  }
  return __readfsqword(0x28u) ^ v94;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000F4F54) ----------------------------------------------------
unsigned __int64 __fastcall sub_F4F54(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_F42A6(a1, a2, 1, a3, a5, a6);
}

//----- (00000000000F4F86) ----------------------------------------------------
unsigned __int64 __fastcall sub_F4F86(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  _DWORD *v14; // [rsp+8h] [rbp-28h]
  int v15; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v16; // [rsp+28h] [rbp-8h]

  v14 = a3;
  v16 = __readfsqword(0x28u);
  if ( a3 && *a3 )
    v6 = (const char *)&unk_127F9E;
  else
    v6 = ",";
  sub_C1FF7(a1, "%s\"%s\":{", (__int64)v6, *(_QWORD *)a2, a5, a6);
  v15 = 1;
  sub_F4F54(a1, a2 + 56, &v15, a2 + 56, v7, v8);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3AD0(a1, (__int64)"units", (__int64)"name", *(_QWORD *)(a2 + 40), 1, 0LL);
  sub_F3AD0(a1, (__int64)"default", (__int64)"value", *(_QWORD *)(a2 + 120), 1, 0LL);
  sub_C1FF7(a1, "}", v9, v10, v11, v12);
  if ( v14 )
    *v14 = 0;
  return __readfsqword(0x28u) ^ v16;
}

//----- (00000000000F5130) ----------------------------------------------------
signed __int64 __fastcall sub_F5130(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  _DWORD *v13; // [rsp+0h] [rbp-30h]
  unsigned __int8 v14; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  result = a3;
  v14 = a3;
  if ( (_BYTE)a3 )
  {
    if ( a4 && *a4 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"typedefs\":[", (__int64)v7, a1, a5, a6, a4);
    for ( i = 0; i < v14; ++i )
    {
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\"", (__int64)v12, *(_QWORD *)(((signed __int64)i << 7) + a2), v10, v11);
    }
    result = sub_C1FF7(a1, "]", v8, v9, v10, v11);
    if ( v13 )
    {
      result = (signed __int64)v13;
      *v13 = 0;
    }
  }
  return result;
}

//----- (00000000000F521A) ----------------------------------------------------
signed __int64 __fastcall sub_F521A(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax

  if ( a3 && *a3 )
    v6 = (const char *)&unk_127F9E;
  else
    v6 = ",";
  return sub_C1FF7(a1, "%s\"min-elements\":{\"value\":%u}", (__int64)v6, a2, a5, a6);
}

//----- (00000000000F526E) ----------------------------------------------------
signed __int64 __fastcall sub_F526E(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax

  if ( a3 && *a3 )
    v6 = (const char *)&unk_127F9E;
  else
    v6 = ",";
  return sub_C1FF7(a1, "%s\"max-elements\":{\"value\":%u}", (__int64)v6, a2, a5, a6);
}

//----- (00000000000F52C2) ----------------------------------------------------
signed __int64 __fastcall sub_F52C2(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  const char *v16; // rax
  __int64 v17; // rdx
  _DWORD *v18; // [rsp+0h] [rbp-30h]
  unsigned __int8 v19; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+28h] [rbp-8h]
  signed int j; // [rsp+2Ch] [rbp-4h]

  result = a3;
  v19 = a3;
  if ( (_BYTE)a3 )
  {
    if ( a4 && *a4 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"uniques\":[", (__int64)v7, a1, a5, a6, a4);
    for ( i = 0; i < v19; ++i )
    {
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s[", (__int64)v12, a1, v10, v11);
      for ( j = 0; ; ++j )
      {
        v17 = 16LL * i;
        if ( j >= *(unsigned __int8 *)(v17 + a2 + 8) )
          break;
        if ( j )
          v16 = ",";
        else
          v16 = (const char *)&unk_127F9E;
        sub_C1FF7(a1, "%s\"%s\"", (__int64)v16, *(_QWORD *)(8LL * j + *(_QWORD *)(16LL * i + a2)), v14, v15);
      }
      sub_C1FF7(a1, "]", v17, v13, v14, v15);
    }
    result = sub_C1FF7(a1, "]", v8, v9, v10, v11);
    if ( v18 )
    {
      result = (signed __int64)v18;
      *v18 = 0;
    }
  }
  return result;
}

//----- (00000000000F5438) ----------------------------------------------------
signed __int64 __fastcall sub_F5438(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  _DWORD *v13; // [rsp+0h] [rbp-30h]
  unsigned __int8 v14; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  result = a3;
  v14 = a3;
  if ( (_BYTE)a3 )
  {
    if ( a4 && *a4 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"defaults\":[", (__int64)v7, a1, a5, a6, a4);
    for ( i = 0; i < v14; ++i )
    {
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\"", (__int64)v12, *(_QWORD *)(8LL * i + a2), v10, v11);
    }
    result = sub_C1FF7(a1, "]", v8, v9, v10, v11);
    if ( v13 )
    {
      result = (signed __int64)v13;
      *v13 = 0;
    }
  }
  return result;
}

//----- (00000000000F5523) ----------------------------------------------------
unsigned __int64 __fastcall sub_F5523(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  _DWORD *v17; // [rsp+0h] [rbp-30h]
  unsigned __int8 v18; // [rsp+Ch] [rbp-24h]
  int v19; // [rsp+20h] [rbp-10h]
  int i; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v21; // [rsp+28h] [rbp-8h]

  v18 = a3;
  v21 = __readfsqword(0x28u);
  if ( a3 )
  {
    if ( a4 && *a4 )
      v6 = (const char *)&unk_127F9E;
    else
      v6 = ",";
    sub_C1FF7(a1, "%s\"revision\":{", (__int64)v6, a1, a5, a6, a4);
    for ( i = 0; i < v18; ++i )
    {
      if ( i )
        v11 = ",";
      else
        v11 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\":{", (__int64)v11, 40LL * i + a2, v9, v10);
      v19 = 1;
      sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(40LL * i + a2 + 24), 1, &v19);
      sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(40LL * i + a2 + 32), 1, &v19);
      sub_C1FF7(a1, "}", v12, v13, v14, v15);
    }
    sub_C1FF7(a1, "}", v7, v8, v9, v10);
    if ( v17 )
      *v17 = 0;
  }
  return __readfsqword(0x28u) ^ v21;
}

//----- (00000000000F56F9) ----------------------------------------------------
unsigned __int64 __fastcall sub_F56F9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, const char **a5, __int64 a6)
{
  const char *v6; // rdx
  const char *v7; // rax
  __int64 v8; // r9
  void *v9; // rcx
  const char *v10; // rax
  void *v11; // rdi
  const char *v12; // rdx
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  void **v19; // [rsp+8h] [rbp-48h]
  unsigned __int8 v20; // [rsp+14h] [rbp-3Ch]
  __int64 v21; // [rsp+18h] [rbp-38h]
  __int64 v22; // [rsp+28h] [rbp-28h]
  int v23; // [rsp+34h] [rbp-1Ch]
  int i; // [rsp+38h] [rbp-18h]
  int v25; // [rsp+3Ch] [rbp-14h]
  char *ptr; // [rsp+40h] [rbp-10h]
  unsigned __int64 v27; // [rsp+48h] [rbp-8h]

  v22 = a1;
  v21 = a3;
  v19 = (void **)a5;
  v20 = a4;
  v27 = __readfsqword(0x28u);
  v25 = 1;
  if ( (_BYTE)a4 && *a5 )
  {
    sub_C1FF7(a1, *a5, (__int64)*a5, a4, (__int64)a5, a6);
    free(*v19);
    *v19 = 0LL;
    v25 = 0;
  }
  for ( i = 0; i < v20; ++i )
  {
    if ( *(_BYTE *)(56LL * i + v21 + 16) )
      v6 = "@";
    else
      v6 = (const char *)&unk_127F9E;
    if ( i + v25 )
      v7 = ",";
    else
      v7 = (const char *)&unk_127F9E;
    sub_C1FF7(
      v22,
      "%s\"%s%s%s\":{",
      (__int64)v7,
      *(_QWORD *)(*(_QWORD *)(56LL * i + v21) + 8LL),
      (__int64)v6,
      56LL * i + v21 + 16);
    v23 = 1;
    sub_F3AD0(v22, (__int64)"prefix", (__int64)"value", *(_QWORD *)(56LL * i + v21 + 8), 1, &v23);
    sub_F3A17(v22, (__int64)"description", (__int64)"text", *(_QWORD *)(56LL * i + v21 + 40), 1, &v23);
    sub_F3A17(v22, (__int64)"reference", (__int64)"text", *(_QWORD *)(56LL * i + v21 + 48), 1, &v23);
    if ( a2 )
    {
      if ( *(_BYTE *)(a2 + 68) )
        v9 = *(void **)(a2 + 88);
      else
        v9 = &unk_127F9E;
      if ( *(_BYTE *)(a2 + 68) )
        v10 = "@";
      else
        v10 = (const char *)&unk_127F9E;
      sub_C1FF7(v22, ",\"from-submodule\":\"%s%s%s\"", *(_QWORD *)(a2 + 8), (__int64)v10, (__int64)v9, v8);
    }
    if ( *(_BYTE *)(*(_QWORD *)(56LL * i + v21) + 68LL) )
      v11 = *(void **)(*(_QWORD *)(56LL * i + v21) + 88LL);
    else
      v11 = &unk_127F9E;
    if ( *(_BYTE *)(*(_QWORD *)(56LL * i + v21) + 68LL) )
      v12 = "@";
    else
      v12 = (const char *)&unk_127F9E;
    if ( asprintf(&ptr, "%s%s%s", *(_QWORD *)(*(_QWORD *)(56LL * i + v21) + 8LL), v12, v11) == -1 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"jsons_print_imports_", v13);
      return __readfsqword(0x28u) ^ v27;
    }
    sub_F3A17(v22, (__int64)"resolves-to", (__int64)"module", (__int64)ptr, 1, &v23);
    free(ptr);
    sub_C1FF7(v22, "}", v14, v15, v16, v17);
  }
  return __readfsqword(0x28u) ^ v27;
}

//----- (00000000000F5B0E) ----------------------------------------------------
unsigned __int64 __fastcall sub_F5B0E(__int64 a1, __int64 a2, _DWORD *a3)
{
  const char *v3; // rax
  __int64 v4; // r9
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  _DWORD *v10; // [rsp+8h] [rbp-28h]
  char *ptr; // [rsp+20h] [rbp-10h]
  unsigned __int64 v12; // [rsp+28h] [rbp-8h]

  v10 = a3;
  v12 = __readfsqword(0x28u);
  if ( *(_BYTE *)(a2 + 69) || *(_BYTE *)(a2 + 70) )
  {
    if ( a3 && *a3 )
      v3 = (const char *)&unk_127F9E;
    else
      v3 = ",";
    if ( asprintf(&ptr, "%s\"import\":{", v3) == -1 )
    {
      sub_12222(*(_QWORD *)a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"jsons_print_imports", v4);
    }
    else
    {
      sub_F56F9(a1, 0LL, *(_QWORD *)(a2 + 96), *(unsigned __int8 *)(a2 + 69), (const char **)&ptr, v4);
      if ( ptr )
        free(ptr);
      else
        sub_C1FF7(a1, "}", v5, v6, v7, v8);
      if ( v10 )
        *v10 = 0;
    }
  }
  return __readfsqword(0x28u) ^ v12;
}

//----- (00000000000F5C40) ----------------------------------------------------
unsigned __int64 __fastcall sub_F5C40(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  _DWORD *v18; // [rsp+0h] [rbp-30h]
  unsigned __int8 v19; // [rsp+Ch] [rbp-24h]
  int v20; // [rsp+20h] [rbp-10h]
  int i; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v22; // [rsp+28h] [rbp-8h]

  v19 = a3;
  v22 = __readfsqword(0x28u);
  if ( a3 )
  {
    if ( a4 && *a4 )
      v6 = (const char *)&unk_127F9E;
    else
      v6 = ",";
    sub_C1FF7(a1, "%s\"include\":{", (__int64)v6, a1, a5, a6, a4);
    for ( i = 0; i < v19; ++i )
    {
      if ( *(_BYTE *)(48LL * i + a2 + 8) )
        v11 = "@";
      else
        v11 = (const char *)&unk_127F9E;
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(
        a1,
        "%s\"%s%s%s\":{",
        (__int64)v12,
        *(_QWORD *)(*(_QWORD *)(48LL * i + a2) + 8LL),
        (__int64)v11,
        48LL * i + a2 + 8);
      v20 = 1;
      sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(48LL * i + a2 + 32), 1, &v20);
      sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(48LL * i + a2 + 40), 1, &v20);
      sub_C1FF7(a1, "}", v13, v14, v15, v16);
    }
    sub_C1FF7(a1, "}", v7, v8, v9, v10);
    if ( v18 )
      *v18 = 0;
  }
  return __readfsqword(0x28u) ^ v22;
}

//----- (00000000000F5E70) ----------------------------------------------------
unsigned __int64 __fastcall sub_F5E70(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // rax
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  _DWORD *v28; // [rsp+0h] [rbp-30h]
  unsigned __int8 v29; // [rsp+Ch] [rbp-24h]
  int v30; // [rsp+20h] [rbp-10h]
  int i; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v32; // [rsp+28h] [rbp-8h]

  v29 = a3;
  v32 = __readfsqword(0x28u);
  if ( a3 )
  {
    if ( a4 && *a4 )
      v6 = (const char *)&unk_127F9E;
    else
      v6 = ",";
    sub_C1FF7(a1, "%s\"augment\":{", (__int64)v6, a1, a5, a6, a4);
    for ( i = 0; i < v29; ++i )
    {
      if ( i )
        v11 = ",";
      else
        v11 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\":{", (__int64)v11, *(_QWORD *)(104LL * i + a2), v9, v10);
      v30 = 1;
      sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(104LL * i + a2 + 8), 1, &v30);
      sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(104LL * i + a2 + 16), 1, &v30);
      sub_F3B77(a1, *(_WORD *)(104LL * i + a2 + 24), &v30);
      sub_F3D9C(
        a1,
        *(_QWORD *)(104LL * i + a2 + 48),
        *(_QWORD *)(104LL * i + a2 + 40),
        *(unsigned __int8 *)(104LL * i + a2 + 27),
        &v30,
        v12);
      sub_F3EB4(a1, *(__int64 **)(104LL * i + a2 + 80), &v30);
      sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), &v30, v13, v14);
      sub_F753F(a1, *(_QWORD *)(a2 + 72), (__int64)&v30, *(_QWORD *)(a2 + 72), v15, v16);
      sub_F7579(a1, *(_QWORD *)(a2 + 72), (__int64)&v30, *(_QWORD *)(a2 + 72), v17, v18);
      sub_C1FF7(a1, "}", v19, v20, v21, v22);
    }
    sub_C1FF7(a1, "}", v7, v8, v9, v10);
    if ( v28 )
      *v28 = 0;
    if ( v28 )
      sub_C1FF7(a1, "\n", v23, v24, v25, v26);
  }
  return __readfsqword(0x28u) ^ v32;
}

//----- (00000000000F61D6) ----------------------------------------------------
unsigned __int64 __fastcall sub_F61D6(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  const char *v16; // rax
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  const char *v20; // rax
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9
  const char *v25; // rax
  const char *v26; // rax
  __int64 v27; // rsi
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // rdx
  _DWORD *v38; // [rsp+0h] [rbp-40h]
  unsigned __int8 v39; // [rsp+Ch] [rbp-34h]
  __int64 v40; // [rsp+10h] [rbp-30h]
  int v41; // [rsp+28h] [rbp-18h]
  int v42; // [rsp+2Ch] [rbp-14h]
  int i; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v45; // [rsp+38h] [rbp-8h]

  v40 = a2;
  v39 = a3;
  v45 = __readfsqword(0x28u);
  if ( a3 )
  {
    if ( a4 && *a4 )
      v6 = (const char *)&unk_127F9E;
    else
      v6 = ",";
    sub_C1FF7(a1, "%s\"deviations\":{", (__int64)v6, a1, a5, a6, a4);
    for ( i = 0; i < v39; ++i )
    {
      if ( i )
        v11 = ",";
      else
        v11 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\":{", (__int64)v11, *(_QWORD *)(56LL * i + v40), v9, v10);
      v41 = 1;
      sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(56LL * i + v40 + 8), 1, &v41);
      sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(56LL * i + v40 + 16), 1, &v41);
      v15 = 56LL * i;
      if ( *(_BYTE *)(v15 + v40 + 32) )
      {
        if ( v41 )
          v16 = (const char *)&unk_127F9E;
        else
          v16 = ",";
        sub_C1FF7(a1, "%s\"deviates\":[", (__int64)v16, a1, v13, v14);
        v41 = 0;
        v42 = 1;
        for ( j = 0; ; ++j )
        {
          v36 = 56LL * i;
          if ( j >= *(unsigned __int8 *)(v36 + v40 + 32) )
            break;
          if ( j )
            v20 = (const char *)&unk_127F9E;
          else
            v20 = ",";
          sub_C1FF7(a1, "%s{", (__int64)v20, a1, v18, v19);
          sub_F3C04(a1, *(_BYTE *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 4), &v42);
          sub_F5438(
            a1,
            *(_QWORD *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 56),
            *(unsigned __int8 *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 5),
            &v42,
            v21,
            v22);
          sub_F3C8C(a1, *(_BYTE *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 4), &v42);
          if ( *(_BYTE *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 7) )
          {
            if ( v42 )
              v25 = (const char *)&unk_127F9E;
            else
              v25 = ",";
            sub_C1FF7(
              a1,
              "%s\"min-elements\":{\"value\":%u}",
              (__int64)v25,
              *(unsigned int *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 12),
              v23,
              v24);
            v42 = 0;
          }
          if ( *(_BYTE *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 8) )
          {
            if ( v42 )
              v26 = (const char *)&unk_127F9E;
            else
              v26 = ",";
            sub_C1FF7(
              a1,
              "%s\"max-elements\":{\"value\":%u}",
              (__int64)v26,
              *(unsigned int *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 16),
              v23,
              v24);
            v42 = 0;
          }
          sub_F41B3(
            a1,
            *(_QWORD *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 24),
            *(_BYTE *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 9),
            &v42,
            v23,
            v24);
          v27 = *(_QWORD *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 40);
          sub_F4F54(a1, v27, &v42, v27, v28, v29);
          sub_F52C2(
            a1,
            *(_QWORD *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 32),
            *(unsigned __int8 *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 10),
            &v42,
            v30,
            v31);
          sub_F3A17(
            a1,
            (__int64)"units",
            (__int64)"name",
            *(_QWORD *)(*(_QWORD *)(56LL * i + v40 + 40) + 72LL * j + 48),
            1,
            &v42);
          sub_C1FF7(a1, "}", v32, v33, v34, v35);
        }
        sub_C1FF7(a1, "]", v36, v17, v18, v19);
      }
      sub_C1FF7(a1, "}", v15, v12, v13, v14);
    }
    sub_C1FF7(a1, "}", v7, v8, v9, v10);
    if ( v38 )
      *v38 = 0;
  }
  return __readfsqword(0x28u) ^ v45;
}

//----- (00000000000F6930) ----------------------------------------------------
unsigned __int64 __fastcall sub_F6930(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  void *v15; // rsi
  const char *v16; // rdx
  const char *v17; // rax
  __int64 v18; // r9
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  _DWORD *v24; // [rsp+8h] [rbp-38h]
  __int64 v25; // [rsp+10h] [rbp-30h]
  int v26; // [rsp+28h] [rbp-18h]
  int i; // [rsp+2Ch] [rbp-14h]
  __int64 v28; // [rsp+30h] [rbp-10h]
  unsigned __int64 v29; // [rsp+38h] [rbp-8h]

  v25 = a2;
  v24 = a3;
  v29 = __readfsqword(0x28u);
  v26 = 1;
  if ( a3 && *a3 )
    v6 = (const char *)&unk_127F9E;
  else
    v6 = ",";
  sub_C1FF7(a1, "%s\"%s\":{", (__int64)v6, *(_QWORD *)a2, a5, a6);
  if ( *(_BYTE *)(a2 + 31) )
  {
    sub_C1FF7(a1, "\"bases\":[", v7, v8, v9, v10);
    v26 = 0;
    for ( i = 0; i < *(unsigned __int8 *)(v25 + 31); ++i )
    {
      v28 = *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 56)) + 48LL);
      if ( *(_BYTE *)(v28 + 68) )
        v15 = *(void **)(v28 + 88);
      else
        v15 = &unk_127F9E;
      if ( *(_BYTE *)(v28 + 68) )
        v16 = "@";
      else
        v16 = (const char *)&unk_127F9E;
      if ( i )
        v17 = ",";
      else
        v17 = (const char *)&unk_127F9E;
      sub_C1FF7(
        a1,
        "%s\"%s%s%s:%s\"",
        (__int64)v17,
        *(_QWORD *)(v28 + 8),
        (__int64)v16,
        (__int64)v15,
        **(_QWORD **)(8LL * i + *(_QWORD *)(v25 + 56)));
    }
    sub_C1FF7(a1, "]", v11, v12, v13, v14);
  }
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(v25 + 8), 1, &v26);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(v25 + 16), 1, &v26);
  sub_F3B77(a1, *(_WORD *)(v25 + 24), &v26);
  sub_F3D9C(a1, *(_QWORD *)(v25 + 48), *(_QWORD *)(v25 + 40), *(unsigned __int8 *)(v25 + 27), &v26, v18);
  sub_C1FF7(a1, "}", v19, v20, v21, v22);
  if ( v24 )
    *v24 = 0;
  return __readfsqword(0x28u) ^ v29;
}

//----- (00000000000F6BB4) ----------------------------------------------------
signed __int64 __fastcall sub_F6BB4(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  _DWORD *v13; // [rsp+0h] [rbp-30h]
  unsigned __int16 v14; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  result = a3;
  v14 = a3;
  if ( (_WORD)a3 )
  {
    if ( a4 && *a4 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"identities\":[", (__int64)v7, a1, a5, a6, a4);
    for ( i = 0; i < v14; ++i )
    {
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\"", (__int64)v12, *(_QWORD *)(72LL * i + a2), v10, v11);
    }
    result = sub_C1FF7(a1, "]", v8, v9, v10, v11);
    if ( v13 )
    {
      result = (signed __int64)v13;
      *v13 = 0;
    }
  }
  return result;
}

//----- (00000000000F6CAB) ----------------------------------------------------
unsigned __int64 __fastcall sub_F6CAB(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  const char *v17; // rax
  _DWORD *v19; // [rsp+8h] [rbp-28h]
  int v20; // [rsp+20h] [rbp-10h]
  unsigned int i; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v22; // [rsp+28h] [rbp-8h]

  v19 = a3;
  v22 = __readfsqword(0x28u);
  v20 = 1;
  if ( a3 && *a3 )
    v6 = (const char *)&unk_127F9E;
  else
    v6 = ",";
  sub_C1FF7(a1, "%s\"%s\":{", (__int64)v6, *(_QWORD *)a2, a5, a6);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, &v20);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, &v20);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), &v20);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), &v20, v7);
  if ( *(_QWORD *)(a2 + 56) && *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4LL) )
  {
    if ( v20 )
      v12 = (const char *)&unk_127F9E;
    else
      v12 = ",";
    sub_C1FF7(a1, "%s\"depending-features\":[", (__int64)v12, a1, v10, v11);
    for ( i = 0; i < *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4LL); ++i )
    {
      if ( i )
        v17 = ",";
      else
        v17 = (const char *)&unk_127F9E;
      sub_C1FF7(
        a1,
        "%s\"%s\"",
        (__int64)v17,
        **(_QWORD **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a2 + 56) + 8LL)),
        v15,
        v16);
    }
    sub_C1FF7(a1, "]", v13, v14, v15, v16);
  }
  sub_C1FF7(a1, "}", v8, v9, v10, v11);
  if ( v19 )
    *v19 = 0;
  return __readfsqword(0x28u) ^ v22;
}

//----- (00000000000F6EDF) ----------------------------------------------------
signed __int64 __fastcall sub_F6EDF(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  _DWORD *v13; // [rsp+0h] [rbp-30h]
  unsigned __int8 v14; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  result = a3;
  v14 = a3;
  if ( (_BYTE)a3 )
  {
    if ( a4 && *a4 )
      v7 = (const char *)&unk_127F9E;
    else
      v7 = ",";
    sub_C1FF7(a1, "%s\"features\":[", (__int64)v7, a1, a5, a6, a4);
    for ( i = 0; i < v14; ++i )
    {
      if ( i )
        v12 = ",";
      else
        v12 = (const char *)&unk_127F9E;
      sub_C1FF7(a1, "%s\"%s\"", (__int64)v12, *(_QWORD *)(((signed __int64)i << 6) + a2), v10, v11);
    }
    result = sub_C1FF7(a1, "]", v8, v9, v10, v11);
    if ( v13 )
    {
      result = (signed __int64)v13;
      *v13 = 0;
    }
  }
  return result;
}

//----- (00000000000F6FC9) ----------------------------------------------------
__int64 __fastcall sub_F6FC9(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 result; // rax
  __int64 v5; // rbx
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // r12
  __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // r9
  _DWORD *v15; // [rsp+0h] [rbp-40h]
  __int64 v16; // [rsp+8h] [rbp-38h]
  __int64 i; // [rsp+28h] [rbp-18h]

  v16 = a3;
  v15 = a4;
  result = a3;
  for ( i = a3; i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) & 0x907F )
    {
      if ( *(_DWORD *)(i + 56) & 0x1000 )
      {
        sub_F6FC9(a1, a2, *(_QWORD *)(i + 72), v15);
      }
      else
      {
        v5 = lys_main_module(a2);
        if ( v5 == lys_main_module(*(_QWORD *)(i + 48)) )
        {
          v6 = sub_F391A(*(_DWORD *)(i + 56));
          sub_F3AD0(a1, *(_QWORD *)i, (__int64)"nodetype", (__int64)v6, 0, v15);
          if ( *(_BYTE *)(*(_QWORD *)(i + 48) + 64LL) & 1 )
            sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(i + 48) + 8LL), v8, v9, v10, v15, v16);
          sub_C1FF7(a1, "}", v7, v8, v9, v10, v15, v16);
        }
        else
        {
          v11 = sub_F391A(*(_DWORD *)(i + 56));
          v12 = *(_QWORD *)i;
          v13 = lys_main_module(*(_QWORD *)(i + 48));
          sub_C1FF7(a1, "\"%s:%s\":{\"nodetype\":\"%s\"}", *(_QWORD *)(v13 + 8), v12, (__int64)v11, v14, v15, v16);
          *v15 = 0;
        }
      }
    }
    result = *(_QWORD *)(i + 80);
  }
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F7166) ----------------------------------------------------
unsigned __int64 __fastcall sub_F7166(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  _DWORD *v12; // [rsp+0h] [rbp-30h]
  __int64 v13; // [rsp+8h] [rbp-28h]
  int v14; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v15; // [rsp+28h] [rbp-8h]

  v13 = a3;
  v15 = __readfsqword(0x28u);
  if ( a4 && *a4 )
    v6 = (const char *)&unk_127F9E;
  else
    v6 = ",";
  sub_C1FF7(a1, "%s\"data\":{", (__int64)v6, a1, a5, a6, a4);
  v14 = 1;
  sub_F6FC9(a1, a2, v13, &v14);
  sub_C1FF7(a1, "}", v7, v8, v9, v10);
  if ( v12 )
    *v12 = 0;
  return __readfsqword(0x28u) ^ v15;
}

//----- (00000000000F7228) ----------------------------------------------------
__int64 __fastcall sub_F7228(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  const char *v7; // rax
  const char *v8; // rax
  _DWORD *v9; // [rsp+0h] [rbp-40h]
  _DWORD *v10; // [rsp+8h] [rbp-38h]
  unsigned int v11; // [rsp+14h] [rbp-2Ch]
  __int64 v12; // [rsp+18h] [rbp-28h]
  __int64 i; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = (_DWORD *)a5;
  v9 = (_DWORD *)a6;
  result = a2;
  for ( i = a2; i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) & v11 )
    {
      if ( *(_DWORD *)(i + 56) & 0x1000 )
      {
        sub_F7228(a1, *(_QWORD *)(i + 72), v12, v11, v10, v9);
      }
      else
      {
        if ( *v9 )
        {
          if ( v10 && *v10 )
            v7 = (const char *)&unk_127F9E;
          else
            v7 = ",";
          sub_C1FF7(a1, "%s\"%s\":[", (__int64)v7, v12, a5, a6, v9);
        }
        if ( *v9 )
          v8 = (const char *)&unk_127F9E;
        else
          v8 = ",";
        sub_C1FF7(a1, "%s\"%s\"", (__int64)v8, *(_QWORD *)i, a5, a6, v9);
        *v9 = 0;
      }
    }
    result = *(_QWORD *)(i + 80);
  }
  return result;
}

//----- (00000000000F7353) ----------------------------------------------------
unsigned __int64 __fastcall sub_F7353(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax
  const char *v7; // rax
  _DWORD *v9; // [rsp+8h] [rbp-48h]
  unsigned int v10; // [rsp+14h] [rbp-3Ch]
  __int64 v11; // [rsp+18h] [rbp-38h]
  int v12; // [rsp+3Ch] [rbp-14h]
  __int64 i; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = (_DWORD *)a5;
  v14 = __readfsqword(0x28u);
  v12 = 1;
  for ( i = a2; i; i = *(_QWORD *)(i + 80) )
  {
    a3 = *(unsigned int *)(i + 56);
    if ( (unsigned int)a3 & v10 )
    {
      if ( *(_DWORD *)(i + 56) & 0x1000 )
      {
        sub_F7228(a1, *(_QWORD *)(i + 72), v11, v10, (__int64)v9, (__int64)&v12);
      }
      else
      {
        if ( v12 )
        {
          if ( v9 && *v9 )
            v6 = (const char *)&unk_127F9E;
          else
            v6 = ",";
          sub_C1FF7(a1, "%s\"%s\":[", (__int64)v6, v11, a5, a6);
        }
        if ( v12 )
          v7 = (const char *)&unk_127F9E;
        else
          v7 = ",";
        sub_C1FF7(a1, "%s\"%s\"", (__int64)v7, *(_QWORD *)i, a5, a6);
        v12 = 0;
      }
    }
  }
  if ( !v12 )
  {
    sub_C1FF7(a1, "]", a3, a4, a5, a6);
    if ( v9 )
      *v9 = 0;
  }
  return __readfsqword(0x28u) ^ v14;
}

//----- (00000000000F74CB) ----------------------------------------------------
unsigned __int64 __fastcall sub_F74CB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_F7353(a1, a2, (__int64)"groupings", 2048LL, a3, a6);
}

//----- (00000000000F7505) ----------------------------------------------------
unsigned __int64 __fastcall sub_F7505(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_F7353(a1, a2, (__int64)"rpcs", 256LL, a3, a6);
}

//----- (00000000000F753F) ----------------------------------------------------
unsigned __int64 __fastcall sub_F753F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_F7353(a1, a2, (__int64)"actions", 0x4000LL, a3, a6);
}

//----- (00000000000F7579) ----------------------------------------------------
unsigned __int64 __fastcall sub_F7579(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_F7353(a1, a2, (__int64)"notifications", 128LL, a3, a6);
}

//----- (00000000000F75B3) ----------------------------------------------------
signed __int64 __fastcall sub_F75B3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9
  __int64 v40; // [rsp+0h] [rbp-10h]

  sub_C1FF7(a1, "{\"%s\":{", *(_QWORD *)(a2 + 8), a4, a5, a6, a2);
  sub_C1FF7(a1, "\"namespace\":\"%s\"", *(_QWORD *)(v40 + 176), v6, v7, v8);
  sub_C1FF7(a1, ",\"prefix\":\"%s\"", *(_QWORD *)(v40 + 16), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(v40 + 24), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(v40 + 32), 1, 0LL);
  sub_F3A17(a1, (__int64)"organization", (__int64)"text", *(_QWORD *)(v40 + 40), 1, 0LL);
  sub_F3A17(a1, (__int64)"contact", (__int64)"text", *(_QWORD *)(v40 + 48), 1, 0LL);
  if ( (*(_BYTE *)(v40 + 64) & 0xE) == 4 )
    v12 = "1.1";
  else
    v12 = "1.0";
  sub_F3AD0(a1, (__int64)"yang-version", (__int64)"value", (__int64)v12, 1, 0LL);
  sub_F5523(a1, *(_QWORD *)(v40 + 88), *(_BYTE *)(v40 + 68), 0LL, v13, v14);
  sub_F5C40(a1, *(_QWORD *)(v40 + 104), *(_BYTE *)(v40 + 70), 0LL, v15, v16);
  sub_F5B0E(a1, v40, 0LL);
  sub_F5130(a1, *(_QWORD *)(v40 + 112), (unsigned __int8)*(_WORD *)(v40 + 74), 0LL, v17, v18);
  sub_F6BB4(a1, *(_QWORD *)(v40 + 120), *(unsigned __int16 *)(v40 + 72), 0LL, v19, v20);
  sub_F6EDF(a1, *(_QWORD *)(v40 + 128), *(unsigned __int8 *)(v40 + 76), 0LL, v21, v22);
  sub_F5E70(a1, *(_QWORD *)(v40 + 136), *(_BYTE *)(v40 + 77), 0LL, v23, v24);
  sub_F61D6(a1, *(_QWORD *)(v40 + 144), *(_BYTE *)(v40 + 78), 0LL, v25, v26);
  sub_F74CB(a1, *(_QWORD *)(v40 + 168), 0LL, *(_QWORD *)(v40 + 168), v27, v28);
  sub_F7166(a1, v40, *(_QWORD *)(v40 + 168), 0LL, v29, v30);
  sub_F7505(a1, *(_QWORD *)(v40 + 168), 0LL, *(_QWORD *)(v40 + 168), v31, v32);
  sub_F7579(a1, *(_QWORD *)(v40 + 168), 0LL, *(_QWORD *)(v40 + 168), v33, v34);
  return sub_C1FF7(a1, "}}", v35, v36, v37, v38);
}

//----- (00000000000F78E4) ----------------------------------------------------
signed __int64 __fastcall sub_F78E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  const char *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v29; // [rsp+0h] [rbp-10h]

  sub_C1FF7(a1, "{\"%s\":{", *(_QWORD *)(a2 + 8), a4, a5, a6, a2);
  sub_C1FF7(a1, "\"belongs-to\":\"%s\"", *(_QWORD *)(*(_QWORD *)(v29 + 168) + 8LL), v6, v7, v8);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(v29 + 24), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(v29 + 32), 1, 0LL);
  sub_F3A17(a1, (__int64)"organization", (__int64)"text", *(_QWORD *)(v29 + 40), 1, 0LL);
  sub_F3A17(a1, (__int64)"contact", (__int64)"text", *(_QWORD *)(v29 + 48), 1, 0LL);
  if ( (*(_BYTE *)(v29 + 64) & 0xE) == 4 )
    v9 = "1.1";
  else
    v9 = "1.0";
  sub_F3AD0(a1, (__int64)"yang-version", (__int64)"value", (__int64)v9, 1, 0LL);
  sub_F5523(a1, *(_QWORD *)(v29 + 88), *(_BYTE *)(v29 + 68), 0LL, v10, v11);
  sub_F5C40(a1, *(_QWORD *)(v29 + 104), *(_BYTE *)(v29 + 70), 0LL, v12, v13);
  sub_F5B0E(a1, v29, 0LL);
  sub_F5130(a1, *(_QWORD *)(v29 + 112), (unsigned __int8)*(_WORD *)(v29 + 74), 0LL, v14, v15);
  sub_F6BB4(a1, *(_QWORD *)(v29 + 120), *(unsigned __int16 *)(v29 + 72), 0LL, v16, v17);
  sub_F6EDF(a1, *(_QWORD *)(v29 + 128), *(unsigned __int8 *)(v29 + 76), 0LL, v18, v19);
  sub_F5E70(a1, *(_QWORD *)(v29 + 136), *(_BYTE *)(v29 + 77), 0LL, v20, v21);
  sub_F61D6(a1, *(_QWORD *)(v29 + 144), *(_BYTE *)(v29 + 78), 0LL, v22, v23);
  return sub_C1FF7(a1, "}}", v24, v25, v26, v27);
}

//----- (00000000000F7B7C) ----------------------------------------------------
signed __int64 __fastcall sub_F7B7C(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3A17(a1, (__int64)"presence", (__int64)"value", *(_QWORD *)(a2 + 136), 1, 0LL);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v12);
  sub_F3EB4(a1, *(__int64 **)(a2 + 112), 0LL);
  sub_F41B3(a1, *(_QWORD *)(a2 + 120), *(_BYTE *)(a2 + 29), 0LL, v13, v14);
  sub_F5130(a1, *(_QWORD *)(a2 + 128), (unsigned __int8)*(_WORD *)(a2 + 30), 0LL, v15, v16);
  sub_F74CB(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v17, v18);
  sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), 0LL, v19, v20);
  sub_F753F(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v21, v22);
  sub_F7579(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v23, v24);
  return sub_C1FF7(a1, "}", v25, v26, v27, v28);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F7E29) ----------------------------------------------------
signed __int64 __fastcall sub_F7E29(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3C8C(a1, *(_WORD *)(a2 + 24), 0LL);
  if ( *(_QWORD *)(a2 + 112) )
    sub_F5438(a1, *(_QWORD *)(a2 + 112), 1u, 0LL, v12, v13);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v13);
  sub_F3EB4(a1, *(__int64 **)(a2 + 104), 0LL);
  sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), 0LL, v14, v15);
  return sub_C1FF7(a1, "}", v16, v17, v18, v19);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F804F) ----------------------------------------------------
signed __int64 __fastcall sub_F804F(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3C8C(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F4F54(a1, a2 + 128, 0LL, a2 + 128, v12, v13);
  sub_F3A17(a1, (__int64)"units", (__int64)"name", *(_QWORD *)(a2 + 192), 1, 0LL);
  if ( *(_QWORD *)(a2 + 200) )
    sub_F5438(a1, a2 + 200, 1u, 0LL, v14, v15);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v15);
  sub_F3EB4(a1, *(__int64 **)(a2 + 112), 0LL);
  sub_F41B3(a1, *(_QWORD *)(a2 + 120), *(_BYTE *)(a2 + 31), 0LL, v16, v17);
  return sub_C1FF7(a1, "}", v18, v19, v20, v21);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F82CE) ----------------------------------------------------
signed __int64 __fastcall sub_F82CE(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3D18(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F4F54(a1, a2 + 128, 0LL, a2 + 128, v12, v13);
  sub_F3A17(a1, (__int64)"units", (__int64)"name", *(_QWORD *)(a2 + 192), 1, 0LL);
  sub_F5438(a1, *(_QWORD *)(a2 + 200), *(unsigned __int8 *)(a2 + 30), 0LL, v14, v15);
  if ( *(_DWORD *)(a2 + 208) )
    sub_F521A(a1, *(_DWORD *)(a2 + 208), 0LL, *(unsigned int *)(a2 + 208), v16, v17);
  if ( *(_DWORD *)(a2 + 212) )
    sub_F526E(a1, *(_DWORD *)(a2 + 212), 0LL, *(unsigned int *)(a2 + 212), v16, v17);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v17);
  sub_F3EB4(a1, *(__int64 **)(a2 + 112), 0LL);
  sub_F41B3(a1, *(_QWORD *)(a2 + 120), *(_BYTE *)(a2 + 31), 0LL, v18, v19);
  return sub_C1FF7(a1, "}", v20, v21, v22, v23);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F8599) ----------------------------------------------------
signed __int64 __fastcall sub_F8599(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  const char *v24; // rax
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  unsigned __int8 i; // [rsp+27h] [rbp-9h]

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3D18(a1, *(_WORD *)(a2 + 24), 0LL);
  if ( *(_DWORD *)(a2 + 152) )
    sub_F521A(a1, *(_DWORD *)(a2 + 152), 0LL, *(unsigned int *)(a2 + 152), v12, v13);
  if ( *(_DWORD *)(a2 + 156) )
    sub_F526E(a1, *(_DWORD *)(a2 + 156), 0LL, *(unsigned int *)(a2 + 156), v12, v13);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v13);
  sub_F3EB4(a1, *(__int64 **)(a2 + 112), 0LL);
  sub_F41B3(a1, *(_QWORD *)(a2 + 120), *(_BYTE *)(a2 + 28), 0LL, v14, v15);
  sub_C1FF7(a1, ",\"keys\":[", v16, v17, v18, v19);
  for ( i = 0; i < *(_BYTE *)(a2 + 30); ++i )
  {
    if ( i )
      v24 = ",";
    else
      v24 = (const char *)&unk_127F9E;
    sub_C1FF7(a1, "%s\"%s\"", (__int64)v24, **(_QWORD **)(8LL * i + *(_QWORD *)(a2 + 136)), v22, v23);
  }
  sub_C1FF7(a1, "]", v20, v21, v22, v23);
  sub_F52C2(a1, *(_QWORD *)(a2 + 144), *(unsigned __int8 *)(a2 + 31), 0LL, v25, v26);
  sub_F5130(a1, *(_QWORD *)(a2 + 128), *(unsigned __int8 *)(a2 + 29), 0LL, v27, v28);
  sub_F74CB(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v29, v30);
  sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), 0LL, v31, v32);
  sub_F753F(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v33, v34);
  sub_F7579(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v35, v36);
  return sub_C1FF7(a1, "}", v37, v38, v39, v40);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F8941) ----------------------------------------------------
int __fastcall sub_F8941(__int64 a1, __int64 a2, _DWORD *a3)
{
  int result; // eax
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  _DWORD *v19; // [rsp+8h] [rbp-28h]

  v19 = a3;
  if ( lys_parent(a2)
    || strcmp(*(const char **)a2, "config")
    || (result = strcmp(*(const char **)(*(_QWORD *)(a2 + 48) + 8LL), "ietf-netconf")) != 0 )
  {
    v4 = sub_F391A(*(_DWORD *)(a2 + 56));
    sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v19);
    v5 = lys_main_module(*(_QWORD *)(a2 + 48));
    sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
    if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
      sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
    sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
    sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
    sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
    sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
    sub_F3C8C(a1, *(_WORD *)(a2 + 24), 0LL);
    sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v12);
    sub_F3EB4(a1, *(__int64 **)(a2 + 112), 0LL);
    sub_F41B3(a1, *(_QWORD *)(a2 + 120), *(_BYTE *)(a2 + 31), 0LL, v13, v14);
    result = sub_C1FF7(a1, "}", v15, v16, v17, v18);
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F8B8C) ----------------------------------------------------
signed __int64 __fastcall sub_F8B8C(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9

  v3 = a3;
  v4 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"module", *(_QWORD *)(v4 + 8), 0, v3);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v5, v6, v7);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F5130(a1, *(_QWORD *)(a2 + 104), (unsigned __int8)*(_WORD *)(a2 + 30), 0LL, v8, v9);
  sub_F74CB(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v10, v11);
  sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), 0LL, v12, v13);
  sub_F753F(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v14, v15);
  sub_F7579(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v16, v17);
  return sub_C1FF7(a1, "}", v18, v19, v20, v21);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F8D51) ----------------------------------------------------
signed __int64 __fastcall sub_F8D51(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3C04(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v12);
  sub_F3EB4(a1, *(__int64 **)(a2 + 104), 0LL);
  sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), 0LL, v13, v14);
  return sub_C1FF7(a1, "}", v15, v16, v17, v18);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F8F2B) ----------------------------------------------------
signed __int64 __fastcall sub_F8F2B(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  __int64 v4; // ST28_8
  __int64 v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9

  v3 = a3;
  v4 = a2;
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_F3AD0(a1, (__int64)"input", (__int64)"module", *(_QWORD *)(v5 + 8), 0, v3);
  sub_F5130(a1, *(_QWORD *)(v4 + 104), (unsigned __int8)*(_WORD *)(v4 + 30), 0LL, v6, v7);
  sub_F41B3(a1, *(_QWORD *)(v4 + 112), *(_BYTE *)(v4 + 29), 0LL, v8, v9);
  sub_F74CB(a1, *(_QWORD *)(v4 + 72), 0LL, *(_QWORD *)(v4 + 72), v10, v11);
  sub_F7166(a1, *(_QWORD *)(v4 + 48), *(_QWORD *)(v4 + 72), 0LL, v12, v13);
  return sub_C1FF7(a1, "}", v14, v15, v16, v17);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F9025) ----------------------------------------------------
signed __int64 __fastcall sub_F9025(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  __int64 v4; // ST28_8
  __int64 v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9

  v3 = a3;
  v4 = a2;
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_F3AD0(a1, (__int64)"output", (__int64)"module", *(_QWORD *)(v5 + 8), 0, v3);
  sub_F5130(a1, *(_QWORD *)(v4 + 104), (unsigned __int8)*(_WORD *)(v4 + 30), 0LL, v6, v7);
  sub_F41B3(a1, *(_QWORD *)(v4 + 112), *(_BYTE *)(v4 + 29), 0LL, v8, v9);
  sub_F74CB(a1, *(_QWORD *)(v4 + 72), 0LL, *(_QWORD *)(v4 + 72), v10, v11);
  sub_F7166(a1, *(_QWORD *)(v4 + 48), *(_QWORD *)(v4 + 72), 0LL, v12, v13);
  return sub_C1FF7(a1, "}", v14, v15, v16, v17);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F911F) ----------------------------------------------------
signed __int64 __fastcall sub_F911F(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v12);
  sub_F5130(a1, *(_QWORD *)(a2 + 112), (unsigned __int8)*(_WORD *)(a2 + 30), 0LL, v13, v14);
  sub_F41B3(a1, *(_QWORD *)(a2 + 120), *(_BYTE *)(a2 + 29), 0LL, v15, v16);
  sub_F74CB(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v17, v18);
  sub_F7166(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), 0LL, v19, v20);
  return sub_C1FF7(a1, "}", v21, v22, v23, v24);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F9323) ----------------------------------------------------
signed __int64 __fastcall sub_F9323(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 i; // [rsp+20h] [rbp-10h]
  __int64 j; // [rsp+20h] [rbp-10h]

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v12);
  sub_F5130(a1, *(_QWORD *)(a2 + 112), (unsigned __int8)*(_WORD *)(a2 + 30), 0LL, v13, v14);
  sub_F74CB(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v15, v16);
  for ( i = *(_QWORD *)(a2 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) & 0x200 )
    {
      sub_F8F2B(a1, i, 0LL);
      break;
    }
  }
  for ( j = *(_QWORD *)(a2 + 72); j; j = *(_QWORD *)(j + 80) )
  {
    if ( *(_DWORD *)(j + 56) & 0x400 )
    {
      sub_F9025(a1, j, 0LL);
      return sub_C1FF7(a1, "}", v17, v18, v19, v20);
    }
  }
  return sub_C1FF7(a1, "}", v17, v18, v19, v20);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F957C) ----------------------------------------------------
signed __int64 __fastcall sub_F957C(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // ST08_8
  const char *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 i; // [rsp+20h] [rbp-10h]
  __int64 j; // [rsp+20h] [rbp-10h]

  v3 = a3;
  v4 = sub_F391A(*(_DWORD *)(a2 + 56));
  sub_F3AD0(a1, *(_QWORD *)a2, (__int64)"nodetype", (__int64)v4, 0, v3);
  v5 = lys_main_module(*(_QWORD *)(a2 + 48));
  sub_C1FF7(a1, ",\"module\":\"%s\"", *(_QWORD *)(v5 + 8), v6, v7, v8);
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + 64LL) & 1 )
    sub_C1FF7(a1, ",\"included-from\":\"%s\"", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v9, v10, v11);
  sub_F3A17(a1, (__int64)"description", (__int64)"text", *(_QWORD *)(a2 + 8), 1, 0LL);
  sub_F3A17(a1, (__int64)"reference", (__int64)"text", *(_QWORD *)(a2 + 16), 1, 0LL);
  sub_F3B77(a1, *(_WORD *)(a2 + 24), 0LL);
  sub_F3D9C(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 40), *(unsigned __int8 *)(a2 + 27), 0LL, v12);
  sub_F5130(a1, *(_QWORD *)(a2 + 112), (unsigned __int8)*(_WORD *)(a2 + 30), 0LL, v13, v14);
  sub_F74CB(a1, *(_QWORD *)(a2 + 72), 0LL, *(_QWORD *)(a2 + 72), v15, v16);
  for ( i = *(_QWORD *)(a2 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) & 0x200 )
    {
      sub_F8F2B(a1, i, 0LL);
      break;
    }
  }
  for ( j = *(_QWORD *)(a2 + 72); j; j = *(_QWORD *)(j + 80) )
  {
    if ( *(_DWORD *)(j + 56) & 0x400 )
    {
      sub_F9025(a1, j, 0LL);
      return sub_C1FF7(a1, "}", v17, v18, v19, v20);
    }
  }
  return sub_C1FF7(a1, "}", v17, v18, v19, v20);
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F97D5) ----------------------------------------------------
__int64 __fastcall sub_F97D5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  const char *v11; // [rsp+8h] [rbp-28h]
  unsigned int v12; // [rsp+2Ch] [rbp-4h]

  v11 = (const char *)a3;
  v12 = 0;
  if ( a3 )
  {
    sub_C1FF7(a1, "{", a3, a4, a5, a6);
    v12 = sub_C3393(
            a1,
            a2,
            v11,
            (void (__fastcall *)(__int64, signed __int64, int *))sub_F4F86,
            (void (__fastcall *)(__int64, signed __int64, int *))sub_F6930,
            (void (__fastcall *)(__int64, signed __int64, int *))sub_F6CAB,
            (void (__fastcall *)(__int64, __int64, int *))sub_F4F54,
            (void (__fastcall *)(__int64, __int64, int *))sub_F8B8C,
            (void (__fastcall *)(__int64, __int64, int *))sub_F7B7C,
            (void (__fastcall *)(__int64, __int64, int *))sub_F7E29,
            (void (__fastcall *)(__int64, __int64, int *))sub_F804F,
            (void (__fastcall *)(__int64, __int64, int *))sub_F82CE,
            (void (__fastcall *)(__int64, __int64, int *))sub_F8599,
            (void (__fastcall *)(__int64, __int64, int *))sub_F8941,
            (void (__fastcall *)(__int64, __int64, int *))sub_F8D51,
            (void (__fastcall *)(__int64, __int64, int *))sub_F911F,
            (void (__fastcall *)(__int64, __int64, int *))sub_F9323,
            (void (__fastcall *)(__int64, __int64, int *))sub_F957C,
            (void (__fastcall *)(__int64, __int64, int *))sub_F8F2B,
            (void (__fastcall *)(__int64, __int64, int *))sub_F9025);
    sub_C1FF7(a1, "}", v6, v7, v8, v9);
  }
  else if ( *(_BYTE *)(a2 + 64) & 1 )
  {
    sub_F78E4(a1, a2, a2, a4, a5, a6);
  }
  else
  {
    sub_F75B3(a1, a2, a2, a4, a5, a6);
  }
  sub_C236C(a1);
  return v12;
}

//----- (00000000000F9917) ----------------------------------------------------
signed __int64 __fastcall sub_F9917(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // r9
  _QWORD *i; // [rsp+18h] [rbp-8h]
  _QWORD *v5; // [rsp+18h] [rbp-8h]

  for ( i = (_QWORD *)*a1; i && a2 != (__int64 *)i[1]; i = (_QWORD *)*i )
    ;
  if ( !i )
  {
    v5 = malloc(0x18uLL);
    if ( !v5 )
    {
      sub_12222(*a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"modlist_add", v2, a2);
      return 1LL;
    }
    *v5 = *a1;
    v5[1] = a2;
    *((_BYTE *)v5 + 16) = 0;
    *a1 = v5;
  }
  return 0LL;
}

//----- (00000000000F99DA) ----------------------------------------------------
_QWORD *__fastcall sub_F99DA(_QWORD **a1)
{
  _QWORD *ptr; // ST18_8
  _QWORD *result; // rax

  while ( 1 )
  {
    result = *a1;
    if ( !*a1 )
      break;
    ptr = *a1;
    *a1 = (_QWORD *)**a1;
    free(ptr);
  }
  return result;
}

//----- (00000000000F9A1C) ----------------------------------------------------
__int64 *__fastcall sub_F9A1C(__int64 a1, __int64 a2, __int64 **a3, char a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  unsigned int v7; // eax
  __int64 *v8; // rax
  __int64 *result; // rax
  char v10; // [rsp+4h] [rbp-5Ch]
  __int64 **v11; // [rsp+8h] [rbp-58h]
  __int64 k; // [rsp+30h] [rbp-30h]
  __int64 v13; // [rsp+38h] [rbp-28h]
  __int64 j; // [rsp+40h] [rbp-20h]
  __int64 i; // [rsp+48h] [rbp-18h]
  __int64 l; // [rsp+48h] [rbp-18h]
  __int64 *m; // [rsp+50h] [rbp-10h]
  __int64 *v18; // [rsp+58h] [rbp-8h]
  __int64 *v19; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  if ( !a1 )
    __assert_fail("out", "/home/mantovan/Repositories/libyang/src/printer_xml.c", 0x54u, "xml_print_ns");
  if ( !a2 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/printer_xml.c", 0x55u, "xml_print_ns");
  for ( i = *(_QWORD *)(a2 + 16); i; i = *(_QWORD *)(i + 8) )
  {
    if ( strcmp(**(const char ***)a2, "filter")
      || strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a2 + 48LL) + 8LL), "ietf-netconf")
      && strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a2 + 48LL) + 8LL), "notifications") )
    {
      v6 = (__int64 *)lys_main_module(*(_QWORD *)(*(_QWORD *)(i + 16) + 48LL));
      if ( (unsigned int)sub_F9917(v11, v6) )
        goto LABEL_51;
    }
  }
  v7 = *(_DWORD *)(*(_QWORD *)a2 + 56LL);
  if ( v7 != 16 )
  {
    if ( v7 > 0x10 )
    {
      if ( v7 != 256 && v7 != 0x4000 && v7 != 128 )
        goto LABEL_51;
    }
    else
    {
      if ( v7 == 4 || v7 == 8 )
      {
        if ( *(_BYTE *)(a2 + 9) & 1 )
        {
          if ( v10 & 0xC0 )
          {
            v18 = (__int64 *)ly_ctx_get_module(
                               **(_QWORD **)(*(_QWORD *)a2 + 48LL),
                               "ietf-netconf-with-defaults",
                               0LL,
                               1LL);
            if ( v18 )
              sub_F9917(v11, v18);
          }
        }
        goto LABEL_51;
      }
      if ( v7 != 1 )
        goto LABEL_51;
    }
  }
  if ( !(v10 & 0xC0)
    || (v19 = (__int64 *)ly_ctx_get_module(**(_QWORD **)(*(_QWORD *)a2 + 48LL), "ietf-netconf-with-defaults", 0LL, 1LL)) == 0LL
    || !(unsigned int)sub_F9917(v11, v19) )
  {
    for ( j = *(_QWORD *)(a2 + 64); j; j = *(_QWORD *)(j + 24) )
    {
      for ( k = j; k; k = v13 )
      {
        for ( l = *(_QWORD *)(k + 16); l; l = *(_QWORD *)(l + 8) )
        {
          if ( strcmp(**(const char ***)k, "filter")
            || strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)k + 48LL) + 8LL), "ietf-netconf")
            && strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)k + 48LL) + 8LL), "notifications") )
          {
            v8 = (__int64 *)lys_main_module(*(_QWORD *)(*(_QWORD *)(l + 16) + 48LL));
            if ( (unsigned int)sub_F9917(v11, v8) )
              goto LABEL_51;
          }
        }
        if ( *(_DWORD *)(*(_QWORD *)k + 56LL) & 0x802C )
          v13 = 0LL;
        else
          v13 = *(_QWORD *)(k + 64);
        if ( !v13 )
        {
          if ( k == j )
            break;
          v13 = *(_QWORD *)(k + 24);
        }
        while ( !v13 )
        {
          k = *(_QWORD *)(k + 40);
          if ( *(_QWORD *)(k + 40) == *(_QWORD *)(j + 40) )
            break;
          v13 = *(_QWORD *)(k + 24);
        }
      }
    }
  }
LABEL_51:
  result = *v11;
  for ( m = *v11; m; m = (__int64 *)*m )
  {
    if ( !*((_BYTE *)m + 16) )
    {
      sub_C1FF7(a1, " xmlns:%s=\"%s\"", *(_QWORD *)(m[1] + 16), *(_QWORD *)(m[1] + 176), a5, a6);
      *((_BYTE *)m + 16) = 1;
    }
    result = (__int64 *)*m;
  }
  return result;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (00000000000F9E66) ----------------------------------------------------
signed __int64 __fastcall sub_F9E66(__int64 a1, _BYTE *a2, char a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9
  int *v25; // rax
  char *v26; // rax
  __int64 v27; // r9
  char v28; // [rsp+Ch] [rbp-74h]
  unsigned int v29; // [rsp+2Ch] [rbp-54h]
  unsigned int i; // [rsp+30h] [rbp-50h]
  int v31; // [rsp+34h] [rbp-4Ch]
  void *ptr; // [rsp+38h] [rbp-48h]
  void *v33; // [rsp+40h] [rbp-40h]
  __int64 v34; // [rsp+48h] [rbp-38h]
  __int64 v35; // [rsp+50h] [rbp-30h]
  __int64 v36; // [rsp+58h] [rbp-28h]
  char *v37; // [rsp+60h] [rbp-20h]
  size_t n; // [rsp+68h] [rbp-18h]
  char *s2; // [rsp+70h] [rbp-10h]
  unsigned __int64 v40; // [rsp+78h] [rbp-8h]

  v28 = a3;
  v40 = __readfsqword(0x28u);
  v35 = 0LL;
  v31 = 0;
  v36 = 0LL;
  *__errno_location() = 0;
  if ( *(_DWORD *)(*(_QWORD *)a2 + 56LL) & 0xC
    && (a2[9] & 1 && v28 & 0xC0 || !(a2[9] & 1) && v28 & 0x40 && (unsigned int)lyd_wd_default(a2)) )
  {
    v36 = ly_ctx_get_module(**(_QWORD **)(*(_QWORD *)a2 + 48LL), "ietf-netconf-with-defaults", 0LL, 1LL);
    if ( v36 )
      sub_C1FF7(a1, " %s:default=\"true\"", *(_QWORD *)(v36 + 16), v3, v4, v5);
  }
  if ( !strcmp(**(const char ***)a2, "filter")
    && (!strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a2 + 48LL) + 8LL), "ietf-netconf")
     || !strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a2 + 48LL) + 8LL), "notifications")) )
  {
    v31 = 1;
  }
  v34 = *((_QWORD *)a2 + 2);
  while ( v34 )
  {
    if ( v31 )
    {
      if ( !strcmp(*(const char **)(v34 + 24), "select") )
      {
        v35 = sub_912E(*(__int64 **)(*(_QWORD *)a2 + 48LL), *(const char **)(v34 + 32), 0, &ptr, &v33, &v29);
        if ( !v35 )
          return 1LL;
        for ( i = 0; i < v29; ++i )
          sub_C1FF7(a1, " xmlns:%s=\"%s\"", *((_QWORD *)ptr + i), *((_QWORD *)v33 + i), v11, v12);
        free(ptr);
        free(v33);
      }
      sub_C1FF7(a1, " %s=\"", *(_QWORD *)(v34 + 24), v8, v9, v10);
    }
    else
    {
      sub_C1FF7(
        a1,
        " %s:%s=\"",
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 16) + 48LL) + 16LL),
        *(_QWORD *)(v34 + 24),
        v6,
        v7);
    }
    switch ( *(_DWORD *)(v34 + 48) )
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 6:
      case 0xA:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
        if ( *(_QWORD *)(v34 + 32) )
        {
          if ( v35 )
            v18 = v35;
          else
            v18 = *(_QWORD *)(v34 + 32);
          sub_341EA(a1, v18, 1, a1, v16, v17);
        }
        goto LABEL_43;
      case 5:
        goto LABEL_43;
      case 7:
        if ( !*(_QWORD *)(v34 + 32) )
          goto LABEL_43;
        v37 = strchr(*(const char **)(v34 + 32), 58);
        if ( !v37 )
          __assert_fail("p", "/home/mantovan/Repositories/libyang/src/printer_xml.c", 0xF3u, "xml_print_attrs");
        n = (size_t)&v37[-*(_QWORD *)(v34 + 32)];
        s2 = *(char **)(*(_QWORD *)(*(_QWORD *)(v34 + 16) + 48LL) + 8LL);
        if ( strncmp(*(const char **)(v34 + 32), s2, n) || s2[n] )
          goto LABEL_36;
        ++v37;
        sub_341EA(a1, (__int64)v37, 1, (__int64)v37, v19, v20);
        goto LABEL_43;
      case 8:
LABEL_36:
        v35 = sub_912E(*(__int64 **)(*(_QWORD *)a2 + 48LL), *((const char **)a2 + 7), 1, &ptr, &v33, &v29);
        if ( !v35 )
          return 1LL;
        for ( i = 0; i < v29; ++i )
          sub_C1FF7(a1, " xmlns:%s=\"%s\"", *((_QWORD *)ptr + i), *((_QWORD *)v33 + i), v21, v22);
        free(ptr);
        free(v33);
        sub_341EA(a1, v35, 1, v35, v23, v24);
        lydict_remove(**(_QWORD **)(*(_QWORD *)a2 + 48LL), v35);
LABEL_43:
        sub_C1FF7(a1, "\"", v14, v15, v16, v17);
        if ( v35 )
          lydict_remove(**(_QWORD **)(*(_QWORD *)a2 + 48LL), v35);
        v34 = *(_QWORD *)(v34 + 8);
        break;
      default:
        sub_12222(
          **(_QWORD **)(*(_QWORD *)a2 + 48LL),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/printer_xml.c",
          278LL);
        return 1LL;
    }
  }
  if ( !*__errno_location() )
    return 0LL;
  v25 = __errno_location();
  v26 = strerror(*v25);
  sub_12222(**(_QWORD **)(*(_QWORD *)a2 + 48LL), 0, 2, "Print error (%s).", (__int64)v26, v27);
  return 1LL;
}
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 79C0: using guessed type __int64 __fastcall lyd_wd_default(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000FA42C) ----------------------------------------------------
signed __int64 __fastcall sub_FA42C(__int64 a1, int a2, __int64 a3, int a4, char a5)
{
  __int64 v5; // r9
  __int64 v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  char *v10; // rsi
  char *v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  int *v41; // rax
  char *v42; // rax
  __int64 v43; // r9
  char v44; // [rsp+4h] [rbp-9Ch]
  __int64 v45; // [rsp+8h] [rbp-98h]
  int v46; // [rsp+10h] [rbp-90h]
  int v47; // [rsp+14h] [rbp-8Ch]
  unsigned int v48; // [rsp+28h] [rbp-78h]
  unsigned int v49; // [rsp+2Ch] [rbp-74h]
  unsigned int i; // [rsp+30h] [rbp-70h]
  unsigned int v51; // [rsp+34h] [rbp-6Ch]
  void *ptr; // [rsp+38h] [rbp-68h]
  void *v53; // [rsp+40h] [rbp-60h]
  __int64 v54; // [rsp+48h] [rbp-58h]
  __int64 j; // [rsp+50h] [rbp-50h]
  __int64 k; // [rsp+58h] [rbp-48h]
  __int64 v57; // [rsp+60h] [rbp-40h]
  __int64 v58; // [rsp+68h] [rbp-38h]
  __int64 v59; // [rsp+70h] [rbp-30h]
  _BYTE *v60; // [rsp+78h] [rbp-28h]
  char *v61; // [rsp+80h] [rbp-20h]
  size_t n; // [rsp+88h] [rbp-18h]
  char *s2; // [rsp+90h] [rbp-10h]
  unsigned __int64 v64; // [rsp+98h] [rbp-8h]

  v47 = a2;
  v45 = a3;
  v46 = a4;
  v44 = a5;
  v64 = __readfsqword(0x28u);
  v57 = a3;
  v54 = 0LL;
  *__errno_location() = 0;
  if ( v46 || !*(_QWORD *)(v45 + 40) || (unsigned int)sub_C1FAD((_QWORD *)v45, *(_QWORD **)(v45 + 40)) )
  {
    v58 = *(_QWORD *)(lyd_node_module(v45) + 176);
    if ( a2 )
      v6 = (unsigned int)(2 * (a2 - 1));
    else
      v6 = 0LL;
    sub_C1FF7(a1, "%*s<%s xmlns=\"%s\"", v6, (__int64)&unk_12884C, **(_QWORD **)v45, v58);
  }
  else
  {
    if ( a2 )
      v9 = (unsigned int)(2 * (a2 - 1));
    else
      v9 = 0LL;
    sub_C1FF7(a1, "%*s<%s", v9, (__int64)&unk_12884C, **(_QWORD **)v45, v5);
  }
  if ( v46 )
  {
    sub_F9A1C(a1, v45, (__int64 **)&v54, v44, v7, v8);
    sub_F99DA((_QWORD **)&v54);
  }
  v10 = (char *)v45;
  if ( (unsigned int)sub_F9E66(a1, (_BYTE *)v45, v44) )
    return 1LL;
  v51 = *(_DWORD *)(v57 + 72);
  while ( 2 )
  {
    switch ( (unsigned __int64)v51 )
    {
      case 1uLL:
      case 2uLL:
      case 3uLL:
      case 4uLL:
      case 6uLL:
      case 0xBuLL:
      case 0xCuLL:
      case 0xDuLL:
      case 0xEuLL:
      case 0xFuLL:
      case 0x10uLL:
      case 0x11uLL:
      case 0x12uLL:
      case 0x13uLL:
        goto LABEL_26;
      case 5uLL:
      case 0x14uLL:
        sub_C1FF7(a1, "/>", (__int64)v11, v12, v13, v14);
        goto LABEL_59;
      case 7uLL:
        if ( !*(_QWORD *)(v57 + 56) || !**(_BYTE **)(v57 + 56) )
        {
          sub_C1FF7(a1, "/>", (__int64)v11, v12, v13, v14);
          goto LABEL_59;
        }
        v61 = strchr(*(const char **)(v57 + 56), 58);
        if ( !v61 )
          __assert_fail("p", "/home/mantovan/Repositories/libyang/src/printer_xml.c", 0x177u, "xml_print_leaf");
        n = (size_t)&v61[-*(_QWORD *)(v57 + 56)];
        s2 = *(char **)(*(_QWORD *)(*(_QWORD *)v57 + 48LL) + 8LL);
        v10 = s2;
        if ( strncmp(*(const char **)(v57 + 56), s2, n) || (v11 = s2, s2[n]) )
        {
          v51 = 8;
          continue;
        }
        sub_C1FF7(a1, ">", (__int64)s2, v12, v13, v14);
        ++v61;
        sub_341EA(a1, (__int64)v61, 2, (__int64)v61, v25, v26);
        sub_C1FF7(a1, "</%s>", **(_QWORD **)v45, v27, v28, v29);
LABEL_59:
        if ( v47 )
          sub_C1FF7(a1, "\n", v16, v17, v18, v19);
        if ( !*__errno_location() )
          return 0LL;
        v41 = __errno_location();
        v42 = strerror(*v41);
        sub_12222(**(_QWORD **)(*(_QWORD *)v45 + 48LL), 0, 2, "Print error (%s).", (__int64)v42, v43);
        return 1LL;
      case 8uLL:
        v60 = (_BYTE *)sub_912E(*(__int64 **)(*(_QWORD *)v45 + 48LL), *(const char **)(v45 + 56), 1, &ptr, &v53, &v48);
        if ( !v60 )
          return 1LL;
        for ( i = 0; i < v48; ++i )
          sub_C1FF7(a1, " xmlns:%s=\"%s\"", *((_QWORD *)ptr + i), *((_QWORD *)v53 + i), v30, v31);
        free(ptr);
        free(v53);
        if ( *v60 )
        {
          sub_C1FF7(a1, ">", v32, v33, v34, v35);
          sub_341EA(a1, (__int64)v60, 2, (__int64)v60, v36, v37);
          sub_C1FF7(a1, "</%s>", **(_QWORD **)v45, v38, v39, v40);
        }
        else
        {
          sub_C1FF7(a1, "/>", v32, v33, v34, v35);
        }
        lydict_remove(**(_QWORD **)(*(_QWORD *)v45 + 48LL), v60);
        goto LABEL_59;
      case 9uLL:
        for ( j = *(_QWORD *)(v57 + 64); j && *(_DWORD *)(j + 72) == 9; j = *(_QWORD *)(j + 64) )
          ;
        if ( j )
        {
          v51 = *(_DWORD *)(j + 72);
        }
        else
        {
          v59 = lyd_leaf_type(v57, v10);
          if ( !v59 )
            return 1LL;
          v51 = *(_DWORD *)v59;
        }
        continue;
      case 0xAuLL:
        sub_141E4(0LL, 2u, &v49, 0LL);
        v59 = lyd_leaf_type(v57, 2LL);
        v10 = (char *)v49;
        sub_142D2(0LL, v49, 0LL, 0);
        if ( !v59 )
          goto LABEL_26;
        for ( k = *(_QWORD *)(v59 + 16); *(_QWORD *)(k + 48); k = *(_QWORD *)(k + 72) )
        {
          v10 = "xpath1.0";
          if ( !strcmp(*(const char **)k, "xpath1.0") )
          {
            v10 = "ietf-yang-types";
            if ( !strcmp(*(const char **)(*(_QWORD *)(k + 48) + 8LL), "ietf-yang-types") )
              break;
          }
        }
        if ( !*(_QWORD *)(k + 48) )
        {
LABEL_26:
          if ( *(_QWORD *)(v57 + 56) && **(_BYTE **)(v57 + 56) )
          {
            sub_C1FF7(a1, ">", (__int64)v11, v12, v13, v14);
            sub_341EA(a1, *(_QWORD *)(v57 + 56), 2, *(_QWORD *)(v57 + 56), v20, v21);
            sub_C1FF7(a1, "</%s>", **(_QWORD **)v45, v22, v23, v24);
          }
          else
          {
            sub_C1FF7(a1, "/>", (__int64)v11, v12, v13, v14);
          }
          goto LABEL_59;
        }
        v51 = 8;
        continue;
      default:
        sub_12222(
          **(_QWORD **)(*(_QWORD *)v45 + 48LL),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/printer_xml.c",
          438LL);
        return 1LL;
    }
  }
}
// 7210: using guessed type __int64 __fastcall lyd_leaf_type(_QWORD, _QWORD);
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000FAB93) ----------------------------------------------------
signed __int64 __fastcall sub_FAB93(__int64 a1, int a2, __int64 a3, int a4, unsigned int a5)
{
  __int64 v5; // r9
  __int64 v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v13; // rax
  const char *v14; // rax
  int v15; // esi
  const char *v16; // rax
  __int64 v17; // rdx
  int *v18; // rax
  char *v19; // rax
  __int64 v20; // r9
  unsigned int v21; // [rsp+4h] [rbp-3Ch]
  __int64 v22; // [rsp+8h] [rbp-38h]
  int v23; // [rsp+10h] [rbp-30h]
  int v24; // [rsp+14h] [rbp-2Ch]
  __int64 v25; // [rsp+20h] [rbp-20h]
  _QWORD *i; // [rsp+28h] [rbp-18h]
  __int64 v27; // [rsp+30h] [rbp-10h]
  unsigned __int64 v28; // [rsp+38h] [rbp-8h]

  v24 = a2;
  v22 = a3;
  v23 = a4;
  v21 = a5;
  v28 = __readfsqword(0x28u);
  v25 = 0LL;
  *__errno_location() = 0;
  if ( v23 || !*(_QWORD *)(v22 + 40) || (unsigned int)sub_C1FAD((_QWORD *)v22, *(_QWORD **)(v22 + 40)) )
  {
    v27 = *(_QWORD *)(lyd_node_module(v22) + 176);
    if ( a2 )
      v6 = (unsigned int)(2 * (a2 - 1));
    else
      v6 = 0LL;
    sub_C1FF7(a1, "%*s<%s xmlns=\"%s\"", v6, (__int64)&unk_12884C, **(_QWORD **)v22, v27);
  }
  else
  {
    if ( a2 )
      v9 = (unsigned int)(2 * (a2 - 1));
    else
      v9 = 0LL;
    sub_C1FF7(a1, "%*s<%s", v9, (__int64)&unk_12884C, **(_QWORD **)v22, v5);
  }
  if ( v23 )
  {
    sub_F9A1C(a1, v22, (__int64 **)&v25, v21, v7, v8);
    sub_F99DA((_QWORD **)&v25);
  }
  if ( (unsigned int)sub_F9E66(a1, (_BYTE *)v22, v21) )
    return 1LL;
  if ( *(_QWORD *)(v22 + 64) )
  {
    if ( a2 )
      v14 = "\n";
    else
      v14 = (const char *)&unk_12884C;
    sub_C1FF7(a1, ">%s", (__int64)v14, a1, v10, v11);
    for ( i = *(_QWORD **)(v22 + 64); i; i = (_QWORD *)i[3] )
    {
      if ( v24 )
        v15 = v24 + 1;
      else
        v15 = 0;
      if ( (unsigned int)sub_FB69D(a1, v15, i, 0, v21) )
        return 1LL;
    }
    if ( v24 )
      v16 = "\n";
    else
      v16 = (const char *)&unk_12884C;
    if ( v24 )
      v17 = (unsigned int)(2 * (v24 - 1));
    else
      v17 = 0LL;
    sub_C1FF7(a1, "%*s</%s>%s", v17, (__int64)&unk_12884C, **(_QWORD **)v22, (__int64)v16);
  }
  else
  {
    if ( a2 )
      v13 = "\n";
    else
      v13 = (const char *)&unk_12884C;
    sub_C1FF7(a1, "/>%s", (__int64)v13, a1, v10, v11);
  }
  if ( !*__errno_location() )
    return 0LL;
  v18 = __errno_location();
  v19 = strerror(*v18);
  sub_12222(**(_QWORD **)(*(_QWORD *)v22 + 48LL), 0, 2, "Print error (%s).", (__int64)v19, v20);
  return 1LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000FAE83) ----------------------------------------------------
signed __int64 __fastcall sub_FAE83(__int64 a1, int a2, __int64 a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // ST10_4
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // r9
  const char *v15; // rax
  const char *v16; // rax
  int v17; // esi
  const char *v18; // rax
  __int64 v19; // rdx
  int *v20; // rax
  char *v21; // rax
  __int64 v22; // r9
  unsigned __int64 v23; // [rsp+0h] [rbp-40h]
  __int64 v24; // [rsp+8h] [rbp-38h]
  int v25; // [rsp+14h] [rbp-2Ch]
  __int64 v26; // [rsp+20h] [rbp-20h]
  _QWORD *i; // [rsp+28h] [rbp-18h]
  __int64 v28; // [rsp+30h] [rbp-10h]
  unsigned __int64 v29; // [rsp+38h] [rbp-8h]

  v25 = a2;
  v24 = a3;
  v6 = a4;
  v23 = __PAIR__(a5, a6);
  v29 = __readfsqword(0x28u);
  v26 = 0LL;
  *__errno_location() = 0;
  if ( v6 )
  {
    if ( HIDWORD(v23) || !*(_QWORD *)(v24 + 40) || (unsigned int)sub_C1FAD((_QWORD *)v24, *(_QWORD **)(v24 + 40)) )
    {
      v28 = *(_QWORD *)(lyd_node_module(v24) + 176);
      if ( a2 )
        v8 = (unsigned int)(2 * (a2 - 1));
      else
        v8 = 0LL;
      sub_C1FF7(a1, "%*s<%s xmlns=\"%s\"", v8, (__int64)&unk_12884C, **(_QWORD **)v24, v28, v23);
    }
    else
    {
      if ( a2 )
        v11 = (unsigned int)(2 * (a2 - 1));
      else
        v11 = 0LL;
      sub_C1FF7(a1, "%*s<%s", v11, (__int64)&unk_12884C, **(_QWORD **)v24, v7, v23);
    }
    if ( HIDWORD(v23) )
    {
      sub_F9A1C(a1, v24, (__int64 **)&v26, v23, v9, v10);
      sub_F99DA((_QWORD **)&v26);
    }
    if ( (unsigned int)sub_F9E66(a1, (_BYTE *)v24, v23) )
      return 1LL;
    if ( *(_QWORD *)(v24 + 64) )
    {
      if ( a2 )
        v16 = "\n";
      else
        v16 = (const char *)&unk_12884C;
      sub_C1FF7(a1, ">%s", (__int64)v16, a1, v12, v13);
      for ( i = *(_QWORD **)(v24 + 64); i; i = (_QWORD *)i[3] )
      {
        if ( v25 )
          v17 = v25 + 1;
        else
          v17 = 0;
        if ( (unsigned int)sub_FB69D(a1, v17, i, 0, v23) )
          return 1LL;
      }
      if ( v25 )
        v18 = "\n";
      else
        v18 = (const char *)&unk_12884C;
      if ( v25 )
        v19 = (unsigned int)(2 * (v25 - 1));
      else
        v19 = 0LL;
      sub_C1FF7(a1, "%*s</%s>%s", v19, (__int64)&unk_12884C, **(_QWORD **)v24, (__int64)v18);
    }
    else
    {
      if ( a2 )
        v15 = "\n";
      else
        v15 = (const char *)&unk_12884C;
      sub_C1FF7(a1, "/>%s", (__int64)v15, a1, v12, v13);
    }
  }
  else
  {
    sub_FA42C(a1, a2, v24, SHIDWORD(v23), v23);
  }
  if ( !*__errno_location() )
    return 0LL;
  v20 = __errno_location();
  v21 = strerror(*v20);
  sub_12222(**(_QWORD **)(*(_QWORD *)v24 + 48LL), 0, 2, "Print error (%s).", (__int64)v21, v22, v23);
  return 1LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000000FB19F) ----------------------------------------------------
signed __int64 __fastcall sub_FB19F(__int64 a1, int a2, __int64 a3, int a4, int a5)
{
  __int64 v5; // r9
  __int64 v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  _QWORD *v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  signed __int64 result; // rax
  const char *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  int v20; // esi
  signed __int64 v21; // rdx
  __int64 v22; // r8
  __int64 v23; // r9
  const char *v24; // rax
  const char *v25; // rax
  int *v26; // rax
  char *v27; // rax
  __int64 v28; // r9
  int v29; // [rsp+4h] [rbp-4Ch]
  __int64 v30; // [rsp+8h] [rbp-48h]
  int v31; // [rsp+10h] [rbp-40h]
  int v32; // [rsp+14h] [rbp-3Ch]
  void *ptr; // [rsp+20h] [rbp-30h]
  __int64 v34; // [rsp+28h] [rbp-28h]
  _QWORD *i; // [rsp+30h] [rbp-20h]
  __int64 v36; // [rsp+38h] [rbp-18h]
  __int64 v37; // [rsp+40h] [rbp-10h]
  unsigned __int64 v38; // [rsp+48h] [rbp-8h]

  v32 = a2;
  v30 = a3;
  v31 = a4;
  v29 = a5;
  v38 = __readfsqword(0x28u);
  v36 = a3;
  v34 = 0LL;
  *__errno_location() = 0;
  if ( v31 || !*(_QWORD *)(v30 + 40) || (unsigned int)sub_C1FAD((_QWORD *)v30, *(_QWORD **)(v30 + 40)) )
  {
    v37 = *(_QWORD *)(lyd_node_module(v30) + 176);
    if ( a2 )
      v6 = (unsigned int)(2 * (a2 - 1));
    else
      v6 = 0LL;
    sub_C1FF7(a1, "%*s<%s xmlns=\"%s\"", v6, (__int64)&unk_12884C, **(_QWORD **)v30, v37);
  }
  else
  {
    if ( a2 )
      v9 = (unsigned int)(2 * (a2 - 1));
    else
      v9 = 0LL;
    sub_C1FF7(a1, "%*s<%s", v9, (__int64)&unk_12884C, **(_QWORD **)v30, v5);
  }
  if ( v31 )
    sub_F9A1C(a1, v30, (__int64 **)&v34, v29, v7, v8);
  if ( (unsigned int)sub_F9E66(a1, (_BYTE *)v30, v29) )
    return 1LL;
  if ( *(_QWORD *)(v36 + 56) && (*(_DWORD *)(v36 + 52) || **(_BYTE **)(v36 + 56)) )
  {
    if ( *(_DWORD *)(v36 + 52) == 32 )
    {
      i = (_QWORD *)j_lyd_parse_mem(**(_QWORD **)(*(_QWORD *)v30 + 48LL), *(_QWORD *)(v36 + 56), 3LL, 8704LL);
      if ( i )
      {
        free(*(void **)(v36 + 56));
        *(_DWORD *)(v36 + 52) = 16;
        v10 = i;
        *(_QWORD *)(v36 + 56) = i;
      }
    }
    if ( *(_DWORD *)(v36 + 52) == 16 )
    {
      for ( i = *(_QWORD **)(v36 + 56); i; i = (_QWORD *)i[3] )
        sub_F9A1C(a1, (__int64)i, (__int64 **)&v34, v29, v12, v13);
    }
    sub_C1FF7(a1, ">", (__int64)v10, v11, v12, v13);
    sub_F99DA((_QWORD **)&v34);
    switch ( *(_DWORD *)(v36 + 52) )
    {
      case 0:
        sub_341EA(a1, *(_QWORD *)(v36 + 56), 2, *(_QWORD *)(v36 + 56), v18, v19);
        goto LABEL_54;
      case 1:
      case 3:
      case 5:
      case 0x21:
        __assert_fail("0", "/home/mantovan/Repositories/libyang/src/printer_xml.c", 0x274u, "xml_print_anydata");
        return result;
      case 2:
      case 0x20:
        sub_12222(
          **(_QWORD **)(*(_QWORD *)v30 + 48LL),
          1u,
          0,
          "Unable to print anydata content (type %d) as XML.",
          *(unsigned int *)(v36 + 52),
          v19);
        goto LABEL_54;
      case 4:
        sub_C1FF7(a1, (const char *)&off_1288F9, *(_QWORD *)(v36 + 56), v17, v18, v19);
        goto LABEL_54;
      case 8:
        if ( a2 )
          v21 = 50LL;
        else
          v21 = 16LL;
        lyxml_print_mem(&ptr, *(_QWORD *)(v36 + 56), v21);
        if ( a2 )
          v24 = "\n";
        else
          v24 = (const char *)&unk_12884C;
        sub_C1FF7(a1, "%s%s", (__int64)v24, (__int64)ptr, v22, v23);
        free(ptr);
        goto LABEL_54;
      case 0x10:
        if ( !*(_QWORD *)(v36 + 56) )
          goto LABEL_54;
        if ( a2 )
          sub_C1FF7(a1, "\n", v16, v17, v18, v19);
        i = *(_QWORD **)(v36 + 56);
        break;
      default:
        goto LABEL_54;
    }
    while ( i )
    {
      if ( v32 )
        v20 = v32 + 1;
      else
        v20 = 0;
      if ( (unsigned int)sub_FB69D(a1, v20, i, 0, v29 & 0xFFFFFEFE) )
        return 1LL;
      i = (_QWORD *)i[3];
    }
LABEL_54:
    if ( v32 )
      v25 = "\n";
    else
      v25 = (const char *)&unk_12884C;
    sub_C1FF7(a1, "</%s>%s", **(_QWORD **)v30, (__int64)v25, v18, v19);
  }
  else
  {
    if ( a2 )
      v15 = "\n";
    else
      v15 = (const char *)&unk_12884C;
    sub_C1FF7(a1, "/>%s", (__int64)v15, a1, v12, v13);
  }
  if ( !*__errno_location() )
    return 0LL;
  v26 = __errno_location();
  v27 = strerror(*v26);
  sub_12222(**(_QWORD **)(*(_QWORD *)v30 + 48LL), 0, 2, "Print error (%s).", (__int64)v27, v28);
  return 1LL;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7990: using guessed type __int64 __fastcall lyxml_print_mem(_QWORD, _QWORD, _QWORD);
// 7C80: using guessed type __int64 __fastcall j_lyd_parse_mem(_QWORD, _QWORD, _QWORD, _QWORD);
// 1288F9: using guessed type void *__ptr32 off_1288F9;

//----- (00000000000FB69D) ----------------------------------------------------
__int64 __fastcall sub_FB69D(__int64 a1, int a2, _QWORD *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6; // eax
  unsigned int v7; // [rsp+4h] [rbp-2Ch]
  __int64 v8; // [rsp+8h] [rbp-28h]
  unsigned int v9; // [rsp+10h] [rbp-20h]
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  v8 = (__int64)a3;
  v9 = a4;
  v7 = a5;
  if ( !(unsigned int)sub_C46A7(a3, a5) )
    return 0LL;
  v6 = *(_DWORD *)(*(_QWORD *)v8 + 56LL);
  if ( v6 == 32 )
    return (unsigned int)sub_FB19F(a1, a2, v8, v9, v7);
  if ( v6 > 0x20 )
  {
    if ( v6 == 256 )
      return (unsigned int)sub_FAB93(a1, a2, v8, v9, v7);
    if ( v6 <= 0x100 )
    {
      if ( v6 != 128 )
        goto LABEL_24;
      return (unsigned int)sub_FAB93(a1, a2, v8, v9, v7);
    }
    if ( v6 == 0x4000 )
      return (unsigned int)sub_FAB93(a1, a2, v8, v9, v7);
    if ( v6 != 32800 )
      goto LABEL_24;
    return (unsigned int)sub_FB19F(a1, a2, v8, v9, v7);
  }
  if ( v6 == 4 )
    return (unsigned int)sub_FA42C(a1, a2, v8, v9, v7);
  if ( v6 <= 4 )
  {
    if ( v6 != 1 )
    {
LABEL_24:
      sub_12222(
        **(_QWORD **)(*(_QWORD *)v8 + 48LL),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_xml.c",
        670LL);
      return 1;
    }
    return (unsigned int)sub_FAB93(a1, a2, v8, v9, v7);
  }
  if ( v6 == 8 )
  {
    v10 = sub_FAE83(a1, a2, v8, 0, v9, v7);
  }
  else
  {
    if ( v6 != 16 )
      goto LABEL_24;
    v10 = sub_FAE83(a1, a2, v8, 1, v9, v7);
  }
  return v10;
}

//----- (00000000000FB855) ----------------------------------------------------
signed __int64 __fastcall sub_FB855(_DWORD *a1, _QWORD *a2, signed int a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  char *v7; // rax
  __int64 v8; // rdx
  const char *v10; // rax
  __int64 v11; // rdx
  int *v12; // rax
  char *v13; // rax
  __int64 v14; // r9
  signed int v15; // [rsp+Ch] [rbp-34h]
  _QWORD *v16; // [rsp+10h] [rbp-30h]
  int v17; // [rsp+20h] [rbp-20h]
  signed int v18; // [rsp+24h] [rbp-1Ch]
  _QWORD *i; // [rsp+28h] [rbp-18h]
  _QWORD *k; // [rsp+28h] [rbp-18h]
  _QWORD *v21; // [rsp+30h] [rbp-10h]
  __int64 j; // [rsp+38h] [rbp-8h]

  v16 = a2;
  v15 = a3;
  j = 0LL;
  v18 = 0;
  *__errno_location() = 0;
  if ( a2 )
  {
    v17 = (v15 >> 1) & 1;
    if ( v15 & 0x100 )
    {
      if ( *(_DWORD *)(*a2 + 56LL) == 256 )
      {
        i = a2;
      }
      else
      {
        for ( i = a2; i && *(_DWORD *)(*i + 56LL) != 0x4000; i = v21 )
        {
          if ( *(_DWORD *)(*i + 56LL) & 0x802C )
            v21 = 0LL;
          else
            v21 = (_QWORD *)i[8];
          if ( !v21 )
          {
            if ( i == a2 )
              break;
            v21 = (_QWORD *)i[3];
          }
          while ( !v21 )
          {
            i = (_QWORD *)i[5];
            if ( i[5] == a2[5] )
              break;
            v21 = (_QWORD *)i[3];
          }
        }
      }
      if ( i )
      {
        if ( *(_DWORD *)(*i + 56LL) & 0x4191 && i[8] )
        {
          for ( j = lys_parent(*(_QWORD *)i[8]); j && *(_DWORD *)(j + 56) == 4096; j = lys_parent(j) )
            ;
        }
        if ( j && *(_DWORD *)(j + 56) == 1024 )
        {
          v16 = (_QWORD *)i[8];
        }
        else if ( *(_DWORD *)(*i + 56LL) == 0x4000 )
        {
          v18 = 1;
        }
      }
    }
    if ( v18 )
    {
      v7 = v17 ? "\n" : &unk_12884C;
      v8 = v17 ? (unsigned __int64)(unsigned int)(2 * (v17 - 1)) : 0LL;
      sub_C1FF7(
        (__int64)a1,
        "%*s<action xmlns=\"%s\">%s",
        v8,
        (__int64)&unk_12884C,
        (__int64)"urn:ietf:params:xml:ns:yang:1",
        (__int64)v7);
      if ( v17 )
        ++v17;
    }
    for ( k = v16; k; k = (_QWORD *)k[3] )
    {
      if ( (unsigned int)sub_FB69D((__int64)a1, v17, k, 1u, v15) )
        return 1LL;
      if ( !(v15 & 1) )
        break;
    }
    if ( v18 )
    {
      if ( v17 )
        --v17;
      if ( v17 )
        v10 = "\n";
      else
        v10 = (const char *)&unk_12884C;
      if ( v17 )
        v11 = (unsigned int)(2 * (v17 - 1));
      else
        v11 = 0LL;
      sub_C1FF7((__int64)a1, "%*s</action>%s", v11, (__int64)&unk_12884C, (__int64)v10, v6);
    }
  }
  else if ( *a1 == 2 || *a1 == 3 )
  {
    sub_C1FF7((__int64)a1, (const char *)&unk_12884C, v3, v4, v5, v6);
  }
  sub_C236C((__int64)a1);
  if ( !*__errno_location() )
    return 0LL;
  v12 = __errno_location();
  v13 = strerror(*v12);
  sub_12222(0LL, 0, 2, "Print error (%s).", (__int64)v13, v14);
  return 1LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000FBBCD) ----------------------------------------------------
__int64 __fastcall sub_FBBCD(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v8; // [rsp+8h] [rbp-28h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  v8 = a3;
  v10 = 0;
  if ( *(_BYTE *)(a3 + 8) )
    v10 = sub_C1FF7(a1, "%*s", *(unsigned __int8 *)(a3 + 8), (__int64)" ", a5, a6);
  for ( i = 0; (signed int)i < a2; ++i )
  {
    v6 = *(_QWORD *)(v8 + 16);
    if ( v6 & (1 << i) )
      v10 += sub_C1FF7(a1, "|  ", v6, i, a5, a6);
    else
      v10 += sub_C1FF7(a1, "   ", v6, i, a5, a6);
  }
  return v10;
}

//----- (00000000000FBC92) ----------------------------------------------------
__int64 __fastcall sub_FBC92(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // [rsp+0h] [rbp-40h]
  __int64 v10; // [rsp+8h] [rbp-38h]
  unsigned int v11; // [rsp+10h] [rbp-30h]
  __int64 i; // [rsp+20h] [rbp-20h]
  __int64 j; // [rsp+28h] [rbp-18h]

  v10 = a3;
  v9 = a4;
  v11 = a5;
  if ( a4 && *(_DWORD *)(a4 + 56) != 0x2000 )
    __assert_fail(
      "!aug_parent || (aug_parent->nodetype == LYS_AUGMENT)",
      "/home/mantovan/Repositories/libyang/src/printer_tree.c",
      0x4Fu,
      "tree_sibling_is_valid_child");
  if ( !a1 )
    return 0LL;
  if ( !lys_parent(a1)
    && !strcmp(*(const char **)a1, "config")
    && !strcmp(*(const char **)(*(_QWORD *)(a1 + 48) + 8LL), "ietf-netconf") )
  {
    return 0LL;
  }
  if ( a2 )
    v6 = a1;
  else
    v6 = *(_QWORD *)(a1 + 80);
  for ( i = v6; i; i = *(_QWORD *)(i + 80) )
  {
    if ( v9 && v9 != *(_QWORD *)(i + 64) )
      return 0LL;
    if ( *(_BYTE *)(v10 + 64) & 1 )
    {
      v7 = lys_main_module(v10);
      if ( v7 != lys_node_module(i) )
        continue;
    }
    if ( !lys_is_disabled(i, 0LL) )
    {
      if ( *(_DWORD *)(i + 56) == 4096 || *(_DWORD *)(i + 56) == 64 && *(_WORD *)(i + 24) & 0x40 )
      {
        if ( (unsigned int)sub_FBC92(*(_QWORD *)(i + 72), 1LL, v10, 0LL, v11) )
          return 1LL;
      }
      else
      {
        switch ( v11 )
        {
          case 0x100u:
            if ( *(_DWORD *)(i + 56) == 256 )
              return 1LL;
            break;
          case 0x800u:
            if ( *(_DWORD *)(i + 56) == 2048 )
              return 0LL;
            break;
          case 0x80u:
            if ( *(_DWORD *)(i + 56) == 128 )
              return 1LL;
            break;
          default:
            if ( *(_DWORD *)(i + 56) & 0xC07F )
              return 1LL;
            if ( *(_DWORD *)(i + 56) & 0x600 && *(_QWORD *)(i + 72) )
              return 1LL;
            if ( *(_DWORD *)(i + 56) == 128 )
            {
              for ( j = lys_parent(i); j && *(_DWORD *)(j + 56) == 4096; j = lys_parent(j) )
                ;
              if ( j )
                return 1LL;
            }
            break;
        }
      }
    }
  }
  if ( !lys_parent(a1) || *(_DWORD *)(lys_parent(a1) + 56) != 4096 )
    return 0LL;
  v8 = lys_parent(a1);
  return sub_FBC92(v8, 0LL, v10, 0LL, v11);
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000FBFBE) ----------------------------------------------------
__int64 __fastcall sub_FBFBE(signed int a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 result; // rax
  __int64 *v5; // [rsp+0h] [rbp-30h]
  __int64 v6; // [rsp+8h] [rbp-28h]
  signed int v7; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v7 = 0;
  if ( a1 > 64 )
    return sub_12222(
             **(_QWORD **)(a2 + 48),
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/printer_tree.c",
             157LL,
             a4,
             a3);
  a4[2] &= ~(1LL << ((unsigned __int8)a1 - 1));
  if ( *(_DWORD *)(a2 + 56) != 64
    && lys_parent(a2)
    && *(_DWORD *)(lys_parent(a2) + 56) & 0x42
    && *(_QWORD *)(a2 + 80)
    && lys_parent(*(_QWORD *)(a2 + 80))
    && *(_DWORD *)(lys_parent(*(_QWORD *)(a2 + 80)) + 56) == 2 )
  {
    v7 = 1;
  }
  result = sub_FBC92(a2, 0, *v5, v6, *(_DWORD *)(a2 + 56));
  if ( (_DWORD)result )
  {
    if ( !v7 )
    {
      result = (__int64)v5;
      v5[2] |= 1LL << ((unsigned __int8)a1 - 1);
    }
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000FC11E) ----------------------------------------------------
__int64 __fastcall sub_FC11E(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v6; // [rsp+0h] [rbp-40h]
  unsigned int v7; // [rsp+Ch] [rbp-34h]
  unsigned int v8; // [rsp+28h] [rbp-18h]
  unsigned int v9; // [rsp+2Ch] [rbp-14h]
  int v10; // [rsp+2Ch] [rbp-14h]
  __int64 i; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v8 = 0;
  for ( i = a1; i; i = *(_QWORD *)(i + 80) )
  {
    if ( (!(*(_BYTE *)(*(_QWORD *)v6 + 64LL) & 1) || *(_QWORD *)(i + 48) == *(_QWORD *)v6)
      && (!a2 || a2 == *(_QWORD *)(i + 64))
      && *(_DWORD *)(i + 56) & v7 )
    {
      if ( *(_DWORD *)(i + 56) == 4096 && !(*(_DWORD *)(v6 + 32) & 4) )
      {
        v9 = (unsigned __int16)sub_FC11E(*(_QWORD *)(i + 72), 0LL, v7, v6);
        goto LABEL_29;
      }
      v12 = lys_node_module(i);
      v9 = strlen(*(const char **)i);
      if ( v12 != lys_main_module(*(_QWORD *)v6) )
      {
        v10 = v9 + 1;
        if ( *(_DWORD *)(v6 + 32) & 1 )
          v9 = strlen(*(const char **)(v12 + 16)) + v10;
        else
          v9 = strlen(*(const char **)(v12 + 8)) + v10;
      }
      v4 = *(_DWORD *)(i + 56);
      if ( v4 != 8 )
      {
        if ( v4 > 8 )
        {
          if ( v4 != 32 )
          {
            if ( v4 > 0x20 )
            {
              if ( v4 != 64 && v4 != 32800 )
                goto LABEL_29;
            }
            else if ( v4 != 16 )
            {
              goto LABEL_29;
            }
          }
        }
        else
        {
          if ( v4 == 2 )
          {
            v9 += 2;
            if ( !(*(_WORD *)(i + 24) & 0x40) )
              ++v9;
            goto LABEL_29;
          }
          if ( v4 != 4 && v4 != 1 )
          {
LABEL_29:
            if ( v9 > v8 )
              v8 = v9;
            continue;
          }
        }
      }
      ++v9;
      goto LABEL_29;
    }
  }
  return v8;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000FC2E9) ----------------------------------------------------
signed __int64 __fastcall sub_FC2E9(__int64 a1)
{
  unsigned __int16 j; // [rsp+1Eh] [rbp-12h]
  __int64 i; // [rsp+20h] [rbp-10h]

  for ( i = lys_parent(a1); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( i && *(_DWORD *)(i + 56) == 16 )
  {
    for ( j = 0; j < *(unsigned __int8 *)(i + 30); ++j )
    {
      if ( a1 == *(_QWORD *)(8LL * j + *(_QWORD *)(i + 136)) )
        return 1LL;
    }
  }
  return 0LL;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000FC398) ----------------------------------------------------
__int64 __fastcall sub_FC398(__int64 a1, unsigned int a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // ST00_8
  int v10; // ST10_4
  __int64 v11; // r8
  __int64 v12; // r9
  int v14; // [rsp+10h] [rbp-10h]
  unsigned int v15; // [rsp+10h] [rbp-10h]

  v14 = a3;
  if ( *(_WORD *)(a6 + 24)
    && (v6 = (unsigned __int16)a5 + a3 + (unsigned int)(unsigned __int8)a4,
        (signed int)v6 > *(unsigned __int16 *)(a6 + 24)) )
  {
    sub_C1FF7(a1, "\n", v6, a4, a5, a6, a6);
    v10 = sub_FBBCD(a1, a2, v9, a2, v7, v8);
    v15 = (unsigned __int64)sub_C1FF7(a1, "%*s", 5LL, (__int64)&unk_128B1B, v11, v12) + v10;
  }
  else
  {
    v15 = (unsigned __int64)sub_C1FF7(a1, "%*s", (unsigned __int8)a4, (__int64)&unk_128B1B, a5, a6, a6) + v14;
  }
  return v15;
}

//----- (00000000000FC46B) ----------------------------------------------------
__int64 __fastcall sub_FC46B(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // [rsp+8h] [rbp-28h]
  unsigned __int16 v8; // [rsp+26h] [rbp-Ah]
  __int64 v9; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v8 = 0;
  v9 = lys_node_module(a2);
  if ( v9 != lys_main_module(*(_QWORD *)v7) )
  {
    if ( *(_DWORD *)(v7 + 32) & 1 )
      v8 = sub_C1FF7(a1, "%s:", *(_QWORD *)(v9 + 16), v3, v4, v5);
    else
      v8 = sub_C1FF7(a1, "%s:", *(_QWORD *)(v9 + 8), v3, v4, v5);
  }
  return v8;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000000FC508) ----------------------------------------------------
__int64 __fastcall sub_FC508(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  int v9; // eax
  __int64 v10; // r9
  int v12; // eax
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  int v19; // ebx
  int v20; // eax
  __int64 v21; // r9
  int v22; // ebx
  int v23; // eax
  __int64 v24; // r9
  _QWORD *v25; // [rsp+0h] [rbp-50h]
  char v26; // [rsp+Ch] [rbp-44h]
  int v27; // [rsp+24h] [rbp-2Ch]
  __int64 *v28; // [rsp+28h] [rbp-28h]
  char *v29; // [rsp+30h] [rbp-20h]
  char *v30; // [rsp+30h] [rbp-20h]
  char *v31; // [rsp+30h] [rbp-20h]
  char *v32; // [rsp+30h] [rbp-20h]
  char *s; // [rsp+38h] [rbp-18h]
  char *sa; // [rsp+38h] [rbp-18h]

  v26 = a3;
  v25 = a4;
  v28 = *(__int64 **)(*(_QWORD *)(a2 + 24) + 48LL);
  if ( *(_DWORD *)a2 != 9 || *(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) )
  {
    if ( (unsigned int)sub_A6074(a2) )
    {
      if ( v25 )
      {
        v27 = strlen(**(const char ***)(a2 + 16));
        *v25 = lydict_insert(*v28, **(_QWORD **)(a2 + 16), v27);
      }
      else
      {
        v27 = sub_C1FF7(a1, "%s", **(_QWORD **)(a2 + 16), v14, v15, v16, 0LL);
      }
    }
    else if ( v26 & 1 )
    {
      sa = (char *)sub_831C((__int64)v28, *(const char **)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) + 8LL));
      if ( v25 )
      {
        v19 = strlen(sa);
        v20 = strlen(**(const char ***)(a2 + 16));
        v27 = v19 + v20 + 1;
        v31 = (char *)malloc(v19 + v20 + 2);
        if ( !v31 )
        {
          sub_12222(*v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"tree_print_type", v21, v25);
          return 0LL;
        }
        sprintf(v31, "%s:%s", sa, **(_QWORD **)(a2 + 16));
        *v25 = lydict_insert_zc(*v28, v31);
      }
      else
      {
        v27 = sub_C1FF7(a1, "%s:%s", (__int64)sa, **(_QWORD **)(a2 + 16), v17, v18, 0LL);
      }
    }
    else if ( v25 )
    {
      v22 = strlen(*(const char **)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) + 8LL));
      v23 = strlen(**(const char ***)(a2 + 16));
      v27 = v22 + v23 + 1;
      v32 = (char *)malloc(v22 + v23 + 2);
      if ( !v32 )
      {
        sub_12222(*v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"tree_print_type", v24, v25);
        return 0LL;
      }
      sprintf(v32, "%s:%s", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) + 8LL), **(_QWORD **)(a2 + 16));
      *v25 = lydict_insert_zc(*v28, v32);
    }
    else
    {
      v27 = sub_C1FF7(
              a1,
              "%s:%s",
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) + 8LL),
              **(_QWORD **)(a2 + 16),
              v15,
              v16,
              0LL);
    }
  }
  else if ( a3 & 8 )
  {
    if ( a4 )
    {
      v27 = 7;
      *a4 = lydict_insert(*v28, "leafref", 7LL);
    }
    else
    {
      v27 = sub_C1FF7(a1, "leafref", a3, 0LL, a5, a6, 0LL);
    }
  }
  else if ( a3 & 1 )
  {
    s = (char *)sub_9182(v28, *(const char **)(a2 + 32));
    if ( v25 )
    {
      v9 = strlen(s);
      v27 = v9 + 3;
      v29 = (char *)malloc(v9 + 4);
      if ( !v29 )
      {
        sub_12222(*v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"tree_print_type", v10, v25);
        return 0LL;
      }
      sprintf(v29, "-> %s", s);
      *v25 = lydict_insert_zc(*v28, v29);
    }
    else
    {
      v27 = sub_C1FF7(a1, "-> %s", (__int64)s, v6, v7, v8, 0LL);
    }
    lydict_remove(*v28, s);
  }
  else if ( a4 )
  {
    v12 = strlen(*(const char **)(a2 + 32));
    v27 = v12 + 3;
    v30 = (char *)malloc(v12 + 4);
    if ( !v30 )
    {
      sub_12222(*v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"tree_print_type", v13, v25);
      return 0LL;
    }
    sprintf(v30, "-> %s", *(_QWORD *)(a2 + 32));
    *v25 = lydict_insert_zc(*v28, v30);
  }
  else
  {
    v27 = sub_C1FF7(a1, "-> %s", *(_QWORD *)(a2 + 32), 0LL, a5, a6, 0LL);
  }
  return (unsigned int)v27;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7A00: using guessed type __int64 __fastcall lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000FCA87) ----------------------------------------------------
signed __int64 __fastcall sub_FCA87(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // eax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  const char *v12; // rax
  unsigned int v13; // [rsp+2Ch] [rbp-4h]

  v6 = *(_DWORD *)(a2 + 56);
  if ( v6 == 256 )
    return sub_C1FF7(a1, "-x ", a3, a4, a5, a6);
  if ( v6 > 0x100 )
  {
    if ( v6 == 4096 )
      return sub_C1FF7(a1, "-u ", a3, a4, a5, a6);
    if ( v6 != 0x4000 )
      goto LABEL_12;
    return sub_C1FF7(a1, "-x ", a3, a4, a5, a6);
  }
  if ( v6 == 64 )
    return sub_C1FF7(a1, ":(", a3, a4, a5, a6);
  if ( v6 == 128 )
    return sub_C1FF7(a1, "-n ", a3, a4, a5, a6);
LABEL_12:
  if ( (_DWORD)a3 == 1 )
  {
    v13 = sub_C1FF7(a1, "-w ", a3, a4, a5, a6);
  }
  else if ( (_DWORD)a3 == 2 )
  {
    v13 = sub_C1FF7(a1, "ro ", a3, a4, a5, a6);
  }
  else
  {
    if ( *(_WORD *)(a2 + 24) & 1 )
    {
      v12 = "rw";
    }
    else if ( *(_WORD *)(a2 + 24) & 2 )
    {
      v12 = "ro";
    }
    else
    {
      v12 = "--";
    }
    v13 = sub_C1FF7(a1, "%s ", (__int64)v12, a1, a5, a6);
  }
  if ( *(_DWORD *)(a2 + 56) == 2 )
    v13 += sub_C1FF7(a1, (const char *)asc_128B7C, v8, v9, v10, v11);
  return v13;
}
// 128B7C: using guessed type __int16 asc_128B7C[3];

//----- (00000000000FCC11) ----------------------------------------------------
__int64 __fastcall sub_FCC11(_QWORD *a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6, _QWORD *a7)
{
  unsigned __int8 v7; // al
  __int64 v8; // rdx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  _QWORD **v16; // [rsp+8h] [rbp-38h]
  __int64 v17; // [rsp+10h] [rbp-30h]
  unsigned __int8 v18; // [rsp+18h] [rbp-28h]
  unsigned __int8 v19; // [rsp+1Ch] [rbp-24h]
  signed int i; // [rsp+30h] [rbp-10h]
  signed int j; // [rsp+30h] [rbp-10h]
  int v22; // [rsp+34h] [rbp-Ch]
  unsigned int v23; // [rsp+34h] [rbp-Ch]
  _QWORD *ptr; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v17 = a4;
  v8 = (unsigned int)a5;
  v16 = (_QWORD **)a6;
  v19 = v7;
  v18 = a5;
  if ( !v7 && !(_BYTE)a5 )
    return 0LL;
  if ( a7 )
  {
    ptr = malloc(0x40uLL);
    if ( !ptr )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"tree_print_features", a6);
      return 0LL;
    }
    *(_DWORD *)ptr = 2;
    ptr[1] = 0LL;
    ptr[2] = 0LL;
    ptr[3] = 0LL;
  }
  else
  {
    ptr = a1;
  }
  v22 = sub_C1FF7((__int64)ptr, (const char *)&asc_128B7C[1], v8, a4, a5, a6);
  for ( i = 0; i < v19; ++i )
  {
    if ( i > 0 )
      v22 += sub_C1FF7((__int64)ptr, (const char *)&asc_128B7C[2], v10, v11, v12, v13);
    if ( (_DWORD)v16[4] & 1 )
      v14 = 2;
    else
      v14 = 1;
    v22 += sub_C2DA0((__int64)ptr, (__int64)*v16, (__int64 *)(a2 + 32LL * i), v14);
  }
  for ( j = 0; j < v18; ++j )
  {
    if ( j > 0 )
      v22 += sub_C1FF7((__int64)ptr, (const char *)&asc_128B7C[2], v10, v11, v12, v13);
    if ( (_DWORD)v16[4] & 1 )
      v15 = 2;
    else
      v15 = 1;
    v22 += sub_C2DA0((__int64)ptr, (__int64)*v16, (__int64 *)(v17 + 32LL * j), v15);
  }
  v23 = (unsigned __int64)sub_C1FF7((__int64)ptr, "}?", v10, v11, v12, v13) + v22;
  if ( a7 )
  {
    *a7 = lydict_insert_zc(**v16, ptr[1]);
    free(ptr);
  }
  return v23;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 128B7C: using guessed type __int16 asc_128B7C[3];

//----- (00000000000FCE3A) ----------------------------------------------------
__int64 __fastcall sub_FCE3A(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  const char *v9; // rax
  _QWORD *v10; // [rsp+8h] [rbp-38h]
  _QWORD **v11; // [rsp+10h] [rbp-30h]
  unsigned __int8 v12; // [rsp+1Ch] [rbp-24h]
  signed int i; // [rsp+30h] [rbp-10h]
  unsigned int v14; // [rsp+34h] [rbp-Ch]
  _QWORD *ptr; // [rsp+38h] [rbp-8h]

  v11 = (_QWORD **)a4;
  v10 = (_QWORD *)a5;
  v12 = a3;
  if ( !(_BYTE)a3 )
    return 0LL;
  if ( a5 )
  {
    ptr = malloc(0x40uLL);
    if ( !ptr )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"tree_print_keys", a6);
      return 0LL;
    }
    *(_DWORD *)ptr = 2;
    ptr[1] = 0LL;
    ptr[2] = 0LL;
    ptr[3] = 0LL;
  }
  else
  {
    ptr = a1;
  }
  v14 = sub_C1FF7((__int64)ptr, "[", a3, a4, a5, a6);
  for ( i = 0; i < v12; ++i )
  {
    if ( i + 1 >= v12 )
      v9 = "]";
    else
      v9 = " ";
    v14 += sub_C1FF7((__int64)ptr, "%s%s", **(_QWORD **)(8LL * i + a2), (__int64)v9, v7, v8);
  }
  if ( v10 )
  {
    *v10 = lydict_insert_zc(**v11, ptr[1]);
    free(ptr);
  }
  return v14;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);

//----- (00000000000FCFB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_FCFB0(_QWORD *a1, unsigned int a2, unsigned __int16 a3, __int64 a4, int a5, __int64 a6, int a7, __int64 a8)
{
  _BOOL4 v8; // edx
  __int64 v9; // r8
  __int64 v10; // r9
  int v11; // eax
  __int64 v12; // r8
  __int64 v13; // r9
  const char *v14; // rax
  int v15; // ST4C_4
  __int64 v16; // r8
  __int64 v17; // r9
  int v18; // ST50_4
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rdx
  unsigned int v26; // eax
  __int64 v27; // rdx
  __int64 v28; // rdx
  unsigned int v29; // eax
  unsigned __int8 v30; // ST48_1
  int v31; // ST4C_4
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  int v35; // ST4C_4
  __int64 v36; // rdx
  __int64 v37; // rcx
  __int64 v38; // r8
  __int64 v39; // r9
  int v40; // ST4C_4
  __int64 v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  int v45; // ST4C_4
  __int64 v46; // rcx
  __int64 v47; // r8
  __int64 v48; // r9
  int v49; // eax
  __int16 v50; // ax
  int v51; // ST4C_4
  __int64 v52; // rcx
  __int64 v53; // r8
  __int64 v54; // r9
  __int16 v55; // ax
  int v56; // ST4C_4
  __int64 v57; // rcx
  __int64 v58; // r8
  __int64 v59; // r9
  __int64 v60; // rdx
  unsigned int v61; // eax
  int v62; // ST4C_4
  __int64 v63; // rcx
  __int64 v64; // r8
  __int64 v65; // r9
  int v66; // ST4C_4
  int v67; // eax
  unsigned int v68; // eax
  int v69; // eax
  __int64 *v71; // [rsp+0h] [rbp-60h]
  __int64 v72; // [rsp+8h] [rbp-58h]
  int v73; // [rsp+14h] [rbp-4Ch]
  __int64 v74; // [rsp+18h] [rbp-48h]
  unsigned __int16 v75; // [rsp+20h] [rbp-40h]
  int v76; // [rsp+24h] [rbp-3Ch]
  unsigned __int8 v77; // [rsp+38h] [rbp-28h]
  unsigned __int8 v78; // [rsp+38h] [rbp-28h]
  unsigned __int16 v79; // [rsp+3Ah] [rbp-26h]
  int v80; // [rsp+3Ch] [rbp-24h]
  int v81; // [rsp+3Ch] [rbp-24h]
  int v82; // [rsp+3Ch] [rbp-24h]
  int v83; // [rsp+40h] [rbp-20h]
  signed int v84; // [rsp+44h] [rbp-1Ch]
  char *s; // [rsp+48h] [rbp-18h]
  __int64 i; // [rsp+50h] [rbp-10h]
  unsigned __int64 v87; // [rsp+58h] [rbp-8h]

  v76 = a2;
  v74 = a4;
  v73 = a5;
  v72 = a6;
  v75 = a3;
  v71 = (__int64 *)a8;
  v87 = __readfsqword(0x28u);
  v8 = *(_QWORD *)(a4 + 64) && *(_DWORD *)(*(_QWORD *)(a4 + 64) + 56LL) == 0x2000;
  if ( lys_is_disabled(a4, (unsigned int)v8)
    || !(*(_DWORD *)(v74 + 56) & v73)
    || (unsigned __int16)*(_DWORD *)(v74 + 56) & (unsigned __int16)v73 & 0x640
    && *(_WORD *)(v74 + 24) & 0x40
    && (*(_DWORD *)(v74 + 56) != 64 || lys_is_disabled(*(_QWORD *)(v74 + 72), 0LL)) )
  {
    return __readfsqword(0x28u) ^ v87;
  }
  v11 = *(_DWORD *)(v74 + 56) & v73;
  if ( v11 != 2048 )
  {
    if ( v11 == 4096 )
    {
      if ( !(*(_DWORD *)(a8 + 32) & 4) )
        goto LABEL_108;
    }
    else if ( v11 == 32
           && !lys_parent(v74)
           && !strcmp(*(const char **)v74, "config")
           && !strcmp(*(const char **)(*(_QWORD *)(v74 + 48) + 8LL), "ietf-netconf") )
    {
      return __readfsqword(0x28u) ^ v87;
    }
    v80 = sub_FBBCD((__int64)a1, a2, a8, a2, v9, v10);
    if ( *(_WORD *)(v74 + 24) & 0x10 )
    {
      v14 = "x";
    }
    else if ( *(_WORD *)(v74 + 24) & 0x20 )
    {
      v14 = "o";
    }
    else
    {
      v14 = "+";
    }
    v15 = (unsigned __int64)sub_C1FF7((__int64)a1, "%s--", (__int64)v14, (__int64)a1, v12, v13, a8) + v80;
    v81 = (unsigned __int64)sub_FCA87((__int64)a1, v74, *((unsigned int *)v71 + 7), v74, v16, v17) + v15;
    v18 = sub_FC46B((__int64)a1, v74, (__int64)v71);
    v83 = (unsigned __int64)sub_C1FF7((__int64)a1, *(const char **)v74, *(_QWORD *)v74, v19, v20, v21) + v18;
    v25 = *(unsigned int *)(v74 + 56);
    v26 = v25 & v73;
    if ( ((unsigned int)v25 & v73) == 8 )
      goto LABEL_45;
    if ( v26 <= 8 )
    {
      if ( v26 == 2 )
      {
        v83 += sub_C1FF7((__int64)a1, ")", v25, v22, v23, v24);
        if ( !(*(_WORD *)(v74 + 24) & 0x40) )
          v83 += sub_C1FF7((__int64)a1, "?", v28, v22, v23, v24);
      }
      else if ( v26 == 4 )
      {
        if ( !(*(_WORD *)(v74 + 24) & 0x40) && !(unsigned int)sub_FC2E9(v74) )
          v83 += sub_C1FF7((__int64)a1, "?", v27, v22, v23, v24);
      }
      else if ( v26 == 1 && *(_QWORD *)(v74 + 136) )
      {
        v83 += sub_C1FF7((__int64)a1, "!", v25, v22, v23, v24);
      }
      goto LABEL_49;
    }
    if ( v26 == 32 )
      goto LABEL_153;
    if ( v26 <= 0x20 )
    {
      if ( v26 != 16 )
        goto LABEL_49;
LABEL_45:
      v83 += sub_C1FF7((__int64)a1, "*", v25, v22, v23, v24);
      goto LABEL_49;
    }
    if ( v26 == 64 )
    {
      v83 += sub_C1FF7((__int64)a1, ")", v25, v22, v23, v24);
      goto LABEL_49;
    }
    if ( v26 == 32800 )
    {
LABEL_153:
      if ( !(*(_WORD *)(v74 + 24) & 0x40) )
        v83 += sub_C1FF7((__int64)a1, "?", v25, v22, v23, v24);
    }
LABEL_49:
    v82 = v83 + v81;
    v76 = a2 + 1;
    if ( !a7 )
      sub_FBFBE(v76, v74, v72, v71);
    v29 = *(_DWORD *)(v74 + 56) & v73;
    if ( v29 == 16 )
    {
      v77 = sub_FCE3A(a1, *(_QWORD *)(v74 + 136), *(unsigned __int8 *)(v74 + 30), (__int64)v71, (__int64)&s, v24);
      if ( v77 )
      {
        v45 = sub_FC398((__int64)a1, v76, v82, 1LL, v77, (__int64)v71);
        v82 = (unsigned __int64)sub_C1FF7((__int64)a1, s, (__int64)s, v46, v47, v48) + v45;
        lydict_remove(*(_QWORD *)*v71, s);
      }
    }
    else if ( v29 > 0x10 )
    {
      if ( v29 == 32 )
      {
        if ( !v75 )
          __assert_fail(
            "max_name_len",
            "/home/mantovan/Repositories/libyang/src/printer_tree.c",
            0x26Au,
            "tree_print_snode");
        v40 = sub_FC398((__int64)a1, v76, v82, (unsigned __int8)(v75 - v83 + 3), 6LL, (__int64)v71);
        v82 = (unsigned __int64)sub_C1FF7((__int64)a1, "anyxml", v41, v42, v43, v44) + v40;
      }
      else if ( v29 == 32800 )
      {
        if ( !v75 )
          __assert_fail(
            "max_name_len",
            "/home/mantovan/Repositories/libyang/src/printer_tree.c",
            0x264u,
            "tree_print_snode");
        v35 = sub_FC398((__int64)a1, v76, v82, (unsigned __int8)(v75 - v83 + 3), 7LL, (__int64)v71);
        v82 = (unsigned __int64)sub_C1FF7((__int64)a1, "anydata", v36, v37, v38, v39) + v35;
      }
    }
    else if ( v29 == 4 || v29 == 8 )
    {
      if ( !v75 )
        __assert_fail(
          "max_name_len",
          "/home/mantovan/Repositories/libyang/src/printer_tree.c",
          0x25Cu,
          "tree_print_snode");
      v30 = sub_FC508((__int64)a1, v74 + 128, *((unsigned int *)v71 + 8), &s, v23, v24);
      v31 = sub_FC398((__int64)a1, v76, v82, (unsigned __int8)(v75 - v83 + 3), v30, (__int64)v71);
      v82 = (unsigned __int64)sub_C1FF7((__int64)a1, s, (__int64)s, v32, v33, v34) + v31;
      lydict_remove(*(_QWORD *)*v71, s);
    }
    if ( !(v71[4] & 1) )
    {
      v49 = *(_DWORD *)(v74 + 56) & v73;
      if ( v49 == 2 )
      {
        i = *(_QWORD *)(v74 + 112);
        if ( i )
        {
          v55 = strlen(*(const char **)i);
          v56 = sub_FC398((__int64)a1, v76, v82, 1LL, (unsigned __int16)(v55 + 2), (__int64)v71);
          v82 = (unsigned __int64)sub_C1FF7((__int64)a1, "<%s>", *(_QWORD *)i, v57, v58, v59) + v56;
        }
      }
      else if ( v49 == 4 )
      {
        s = *(char **)(v74 + 200);
        if ( s )
        {
          v50 = strlen(s);
          v51 = sub_FC398((__int64)a1, v76, v82, 1LL, (unsigned __int16)(v50 + 2), (__int64)v71);
          v82 = (unsigned __int64)sub_C1FF7((__int64)a1, "<%s>", (__int64)s, v52, v53, v54) + v51;
        }
      }
    }
    v60 = *(unsigned int *)(v74 + 56);
    v61 = v60 & v73;
    if ( ((unsigned int)v60 & v73) == 32 )
      goto LABEL_94;
    if ( v61 > 0x20 )
    {
      if ( v61 != 256 )
      {
        if ( v61 > 0x100 )
        {
          if ( v61 != 0x4000 && v61 != 32800 && v61 != 4096 )
            goto LABEL_100;
        }
        else if ( v61 != 64 && v61 != 128 )
        {
          goto LABEL_100;
        }
      }
    }
    else if ( v61 != 4 )
    {
      if ( v61 <= 4 )
      {
        if ( v61 - 1 <= 1 )
          goto LABEL_94;
LABEL_100:
        sub_C1FF7((__int64)a1, "\n", v60, v22, v23, v24);
        if ( a7 == 1 || (*(_DWORD *)(v74 + 56) & v73) == 4096 )
          return __readfsqword(0x28u) ^ v87;
        v67 = *(_DWORD *)(v74 + 56) & v73;
        if ( v67 == 512 )
        {
          *((_DWORD *)v71 + 7) = 1;
        }
        else if ( v67 == 1024 || v67 == 128 )
        {
          *((_DWORD *)v71 + 7) = 2;
        }
        goto LABEL_108;
      }
      if ( v61 != 8 && v61 != 16 )
        goto LABEL_100;
    }
LABEL_94:
    if ( *(_QWORD *)(v74 + 64) && *(_DWORD *)(*(_QWORD *)(v74 + 64) + 56LL) == 0x2000 )
      v78 = sub_FCC11(
              a1,
              *(_QWORD *)(v74 + 40),
              *(_BYTE *)(v74 + 27),
              *(_QWORD *)(*(_QWORD *)(v74 + 64) + 40LL),
              *(unsigned __int8 *)(*(_QWORD *)(v74 + 64) + 27LL),
              (__int64)v71,
              &s);
    else
      v78 = sub_FCC11(a1, *(_QWORD *)(v74 + 40), *(_BYTE *)(v74 + 27), 0LL, 0LL, (__int64)v71, &s);
    if ( v78 )
    {
      v62 = sub_FC398((__int64)a1, v76, v82, 1LL, v78, (__int64)v71);
      v66 = (unsigned __int64)sub_C1FF7((__int64)a1, s, (__int64)s, v63, v64, v65) + v62;
      lydict_remove(*(_QWORD *)*v71, s);
    }
    goto LABEL_100;
  }
LABEL_108:
  v68 = *(_DWORD *)(v74 + 56) & v73;
  if ( v68 == 128 )
    goto LABEL_133;
  if ( v68 <= 0x80 )
  {
    if ( v68 != 8 )
    {
      if ( v68 <= 8 )
      {
        if ( v68 == 2 )
        {
          v84 = 32893;
          v79 = sub_FC11E(*(_QWORD *)(v74 + 72), 0LL, 0x807Du, (__int64)v71);
          goto LABEL_138;
        }
        if ( v68 != 4 )
        {
          if ( v68 != 1 )
          {
LABEL_137:
            v84 = 0;
            v79 = 0;
            sub_12222(
              **(_QWORD **)(v74 + 48),
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/printer_tree.c",
              754LL,
              v71,
              v72);
            goto LABEL_138;
          }
          goto LABEL_136;
        }
        goto LABEL_130;
      }
      if ( v68 != 32 )
      {
        if ( v68 != 64 )
        {
          if ( v68 != 16 )
            goto LABEL_137;
          goto LABEL_136;
        }
LABEL_133:
        v84 = 36927;
        v79 = sub_FC11E(*(_QWORD *)(v74 + 72), 0LL, 0x903Fu, (__int64)v71);
        goto LABEL_138;
      }
    }
LABEL_130:
    v84 = 0;
    v79 = 0;
    goto LABEL_138;
  }
  if ( v68 == 2048 )
  {
LABEL_136:
    v84 = 53439;
    v79 = sub_FC11E(*(_QWORD *)(v74 + 72), 0LL, 0xD0BFu, (__int64)v71);
    goto LABEL_138;
  }
  if ( v68 <= 0x800 )
  {
    if ( v68 == 512 || v68 == 1024 )
    {
      v84 = 36927;
      v79 = sub_FC11E(*(_QWORD *)(v74 + 72), 0LL, 0x903Fu, (__int64)v71);
      goto LABEL_138;
    }
    if ( v68 != 256 )
      goto LABEL_137;
    goto LABEL_131;
  }
  if ( v68 == 0x4000 )
  {
LABEL_131:
    v84 = 1536;
    v79 = 0;
    goto LABEL_138;
  }
  if ( v68 == 32800 )
    goto LABEL_130;
  if ( v68 != 4096 )
    goto LABEL_137;
  v84 = 53439;
  v79 = v75;
LABEL_138:
  if ( v84 )
  {
    for ( i = *(_QWORD *)(v74 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_BYTE *)(*v71 + 64) & 1) || v74 == *(_QWORD *)(i + 64) || *(_QWORD *)(i + 48) == *v71 )
        sub_FCFB0((_DWORD)a1, v76, v79);
    }
  }
  v69 = *(_DWORD *)(v74 + 56) & v73;
  if ( v69 == 512 || v69 == 1024 || v69 == 128 )
    *((_DWORD *)v71 + 7) = 0;
  return __readfsqword(0x28u) ^ v87;
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000FDC13) ----------------------------------------------------
unsigned __int64 __fastcall sub_FDC13(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 i; // rax
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+28h] [rbp-18h]
  unsigned int v9; // [rsp+2Ch] [rbp-14h]
  unsigned int j; // [rsp+30h] [rbp-10h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  __int64 v12; // [rsp+38h] [rbp-8h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v11 = 0;
  v8 = 0;
  v12 = a2;
  for ( i = lys_parent(a2); i; i = lys_parent(v12) )
  {
    if ( *(_DWORD *)(lys_parent(v12) + 56) != 4096 )
      ++v8;
    v12 = lys_parent(v12);
  }
  if ( *(_DWORD *)(v12 + 56) == 256 )
  {
    sub_C1FF7((__int64)a1, "\n%*srpcs:\n", 2LL, (__int64)&unk_128B1B, v4, v5);
    *(_BYTE *)(v7 + 8) = 4;
  }
  else if ( *(_DWORD *)(v12 + 56) == 128 )
  {
    sub_C1FF7((__int64)a1, "\n%*snotifications:\n", 2LL, (__int64)&unk_128B1B, v4, v5);
    *(_BYTE *)(v7 + 8) = 4;
  }
  if ( v8 )
  {
    v9 = v8;
    do
    {
      v13 = a2;
      for ( j = 0; j < v9; ++j )
      {
        do
          v13 = lys_parent(v13);
        while ( *(_DWORD *)(v13 + 56) == 4096 );
      }
      sub_FCFB0(a1, v11++, 0, v13, 18321, 0LL, 1, v7);
      --v9;
    }
    while ( v9 );
  }
  return sub_FCFB0(a1, v11, 0, a2, 0xFFFF, 0LL, 2, v7);
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000000FDDA8) ----------------------------------------------------
__int64 __fastcall sub_FDDA8(__int64 a1, unsigned int a2, unsigned __int8 a3, char *a4, __int64 a5)
{
  __int64 v5; // r8
  __int64 v6; // r9
  const char *v7; // rax
  __int64 v9; // [rsp+0h] [rbp-40h]
  char *v10; // [rsp+8h] [rbp-38h]
  unsigned __int8 v11; // [rsp+10h] [rbp-30h]
  unsigned int v12; // [rsp+24h] [rbp-1Ch]
  signed int v13; // [rsp+28h] [rbp-18h]
  unsigned int v14; // [rsp+2Ch] [rbp-14h]
  char *s; // [rsp+30h] [rbp-10h]
  char *v16; // [rsp+38h] [rbp-8h]

  v10 = a4;
  v9 = a5;
  v11 = a3;
  v12 = a2;
  s = a4;
  do
  {
    v16 = strchr(s + 1, 47);
    if ( v16 )
    {
      v14 = (_DWORD)v16 - (_DWORD)s;
      v13 = 0;
    }
    else
    {
      v14 = strlen(s) + 1;
      v13 = 1;
    }
    if ( *(_WORD *)(v9 + 24) && s != v10 && (signed int)(v14 + v12) > *(unsigned __int16 *)(v9 + 24) )
      v12 = (unsigned __int64)sub_C1FF7(a1, "\n%*s", a2 + v11, (__int64)&unk_128B1B, v5, v6, v9) - 1;
    if ( v13 )
      v7 = ":";
    else
      v7 = (const char *)&unk_128B1B;
    v12 += sub_C1FF7(a1, "%.*s%s", v14, (__int64)s, (__int64)v7, v6, v9);
    s = v16;
  }
  while ( !v13 );
  return v12;
}

//----- (00000000000FDED1) ----------------------------------------------------
signed __int64 __fastcall sub_FDED1(_QWORD *a1, __int64 *a2, __int64 a3, unsigned int a4, unsigned int a5)
{
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  int v19; // eax
  char *v20; // ST70_8
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r9
  unsigned __int64 v26; // [rsp+0h] [rbp-A0h]
  char v27; // [rsp+0h] [rbp-A0h]
  __int64 v28; // [rsp+8h] [rbp-98h]
  unsigned __int16 v29; // [rsp+2Ah] [rbp-76h]
  unsigned __int16 v30; // [rsp+2Ah] [rbp-76h]
  int v31; // [rsp+2Ch] [rbp-74h]
  int v32; // [rsp+30h] [rbp-70h]
  int v33; // [rsp+34h] [rbp-6Ch]
  signed int v34; // [rsp+38h] [rbp-68h]
  signed int j; // [rsp+3Ch] [rbp-64h]
  unsigned int v36; // [rsp+44h] [rbp-5Ch]
  __int64 v37; // [rsp+48h] [rbp-58h]
  __int64 i; // [rsp+48h] [rbp-58h]
  __int64 k; // [rsp+48h] [rbp-58h]
  __int64 l; // [rsp+48h] [rbp-58h]
  __int64 m; // [rsp+48h] [rbp-58h]
  __int64 n; // [rsp+48h] [rbp-58h]
  __int64 v43; // [rsp+50h] [rbp-50h]
  __int64 v44; // [rsp+58h] [rbp-48h]
  __int64 v45; // [rsp+68h] [rbp-38h]
  __int64 *s; // [rsp+70h] [rbp-30h]
  char v47; // [rsp+78h] [rbp-28h]
  __int16 v48; // [rsp+88h] [rbp-18h]
  int v49; // [rsp+90h] [rbp-10h]
  unsigned __int64 v50; // [rsp+98h] [rbp-8h]

  v28 = a3;
  v26 = __PAIR__(a4, a5);
  v50 = __readfsqword(0x28u);
  v37 = 0LL;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  memset(&s, 0, 0x28uLL);
  s = a2;
  v48 = WORD2(v26);
  v49 = v26;
  if ( v28 )
  {
    v44 = lys_find_path(a2, 0LL, v28);
    if ( !v44 )
      return 1LL;
    if ( *(_DWORD *)(v44 + 4) != 1 )
    {
      sub_13937((void *)*a2, 81, 0, 0LL, v8, v9, v26);
      if ( *(_DWORD *)(v44 + 4) )
        sub_13937((void *)*a2, -1, 5u, 0LL, (__int64)"Schema path \"%s\" matched more nodes.", v28);
      else
        sub_13937((void *)*a2, -1, 5u, 0LL, (__int64)"Schema path \"%s\" did not match any nodes.", v28);
      ly_set_free(v44);
      return 1LL;
    }
    v37 = **(_QWORD **)(v44 + 8);
    ly_set_free(v44);
  }
  if ( a2[8] & 1 )
  {
    sub_C1FF7((__int64)a1, "submodule: %s", a2[1], v5, v6, v7, v26);
    v43 = *(_QWORD *)(a2[21] + 168);
    if ( v27 & 1 )
      sub_C1FF7((__int64)a1, "\n", v11, v12, v13, v14);
    else
      sub_C1FF7((__int64)a1, " (belongs-to %s)\n", *(_QWORD *)(a2[21] + 8), v12, v13, v14);
  }
  else
  {
    sub_C1FF7((__int64)a1, "module: %s\n", a2[1], v5, v6, v7, v26);
    v43 = a2[21];
  }
  if ( v28 )
  {
    v47 = 2;
    sub_FDC13(a1, v37, (__int64)&s);
    result = 0LL;
  }
  else
  {
    v47 = 2;
    v29 = sub_FC11E(v43, 0LL, 0x903Fu, (__int64)&s);
    for ( i = v43; i; i = *(_QWORD *)(i + 80) )
    {
      if ( s[8] & 1 )
      {
        v15 = *(_QWORD *)(i + 48);
        if ( (__int64 *)v15 != s )
          continue;
      }
      v19 = *(_DWORD *)(i + 56);
      switch ( v19 )
      {
        case 256:
          if ( !lys_is_disabled(i, 0LL) )
            ++v31;
          break;
        case 2048:
          if ( v27 & 2 && !lys_is_disabled(i, 0LL) )
            ++v33;
          break;
        case 128:
          if ( !lys_is_disabled(i, 0LL) )
            ++v32;
          break;
        default:
          sub_FCFB0(a1, 0, v29, i, 36927, 0LL, 0, (__int64)&s);
          break;
      }
    }
    v47 = 4;
    for ( j = 0; j < *((unsigned __int8 *)a2 + 77); ++j )
    {
      if ( a2[8] & 1 )
      {
        v16 = a2[17];
        v15 = j;
        if ( a2 == *(__int64 **)(*(_QWORD *)(v16 + 104LL * j + 88) + 48LL) )
          continue;
      }
      if ( (a2[8] & 1 || a2 != (__int64 *)lys_node_module(*(_QWORD *)(a2[17] + 104LL * j + 88)))
        && !lys_is_disabled(a2[17] + 104LL * j, 0LL) )
      {
        if ( !v34 )
        {
          sub_C1FF7((__int64)a1, "\n", v15, v16, v17, v18);
          v34 = 1;
        }
        v36 = sub_C1FF7((__int64)a1, "%*saugment ", 2LL, (__int64)&unk_128B1B, v17, v18);
        if ( v27 & 1 )
        {
          v20 = (char *)sub_9182(a2, *(const char **)(a2[17] + 104LL * j));
          sub_FDDA8((__int64)a1, v36, 2u, v20, (__int64)&s);
          lydict_remove(*a2, v20);
        }
        else
        {
          sub_FDDA8((__int64)a1, v36, 2u, *(char **)(a2[17] + 104LL * j), (__int64)&s);
        }
        sub_C1FF7((__int64)a1, "\n", v21, v22, v23, v24);
        v45 = a2[17] + 104LL * j;
        v30 = sub_FC11E(*(_QWORD *)(v45 + 72), v45, 0xD0FFu, (__int64)&s);
        for ( k = *(_QWORD *)(v45 + 72); k; k = *(_QWORD *)(k + 80) )
        {
          if ( v45 == *(_QWORD *)(k + 64) )
            sub_FCFB0(a1, 0, v30, k, 53503, v45, 0, (__int64)&s);
        }
      }
    }
    if ( v31 )
    {
      sub_C1FF7((__int64)a1, "\n%*srpcs:\n", 2LL, (__int64)&unk_128B1B, v17, v18);
      for ( l = v43; l; l = *(_QWORD *)(l + 80) )
        sub_FCFB0(a1, 0, 0, l, 256, 0LL, 0, (__int64)&s);
    }
    if ( v32 )
    {
      sub_C1FF7((__int64)a1, "\n%*snotifications:\n", 2LL, (__int64)&unk_128B1B, v17, v18);
      for ( m = v43; m; m = *(_QWORD *)(m + 80) )
        sub_FCFB0(a1, 0, 0, m, 128, 0LL, 0, (__int64)&s);
    }
    if ( v27 & 2 && v33 )
    {
      sub_C1FF7((__int64)a1, "\n", v15, v16, v17, v18);
      for ( n = v43; n; n = *(_QWORD *)(n + 80) )
      {
        if ( *(_DWORD *)(n + 56) == 2048 )
        {
          sub_C1FF7((__int64)a1, "%*sgrouping %s:\n", 2LL, (__int64)&unk_128B1B, *(_QWORD *)n, v25);
          sub_FCFB0(a1, 0, 0, n, 2048, 0LL, 0, (__int64)&s);
        }
      }
    }
    sub_C236C((__int64)a1);
    result = 0LL;
  }
  return result;
}
// 71F0: using guessed type __int64 __fastcall lys_is_disabled(_QWORD, _QWORD);
// 7470: using guessed type __int64 __fastcall ly_set_free(_QWORD);
// 7800: using guessed type __int64 __fastcall lys_find_path(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 7C00: using guessed type __int64 __fastcall lydict_remove(_QWORD, _QWORD);

//----- (00000000000FE7ED) ----------------------------------------------------
signed __int64 __fastcall sub_FE7ED(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  char *i; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  signed int v15; // [rsp+2Ch] [rbp-14h]
  char *s; // [rsp+30h] [rbp-10h]
  const char *v17; // [rsp+38h] [rbp-8h]

  v15 = 1;
  result = sub_C1FF7(a1, "%-*s", 11LL, a3, a5, a6);
  if ( a2 )
  {
    s = (char *)a2;
    for ( i = strchr(a2, 10); i; i = strchr(v17, 10) )
    {
      v17 = i + 1;
      if ( v15 )
      {
        sub_C1FF7(a1, "%.*s", (unsigned int)((_DWORD)v17 - (_DWORD)s), (__int64)s, v13, v14);
        v15 = 0;
      }
      else
      {
        sub_C1FF7(a1, "%*s%.*s", 11LL, (__int64)&unk_128D19, (unsigned int)((_DWORD)v17 - (_DWORD)s), (__int64)s);
      }
      s = (char *)v17;
    }
    if ( v15 )
    {
      result = sub_C1FF7(a1, (const char *)&off_128D15, (__int64)s, v12, v13, v14);
      v15 = 0;
    }
    else
    {
      result = sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, (__int64)s, v14);
    }
  }
  if ( v15 )
    result = sub_C1FF7(a1, "\n", v7, v8, v9, v10);
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FE96A) ----------------------------------------------------
signed __int64 __fastcall sub_FE96A(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  const char *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r9
  const char *v18; // rax
  signed __int64 result; // rax
  const char *v20; // rax
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  const char *v25; // rax
  char *s; // [rsp+0h] [rbp-20h]
  __int64 v27; // [rsp+8h] [rbp-18h]
  __int64 i; // [rsp+8h] [rbp-18h]

  v27 = a3;
  s = (char *)a4;
  if ( strlen(a4) > 9 )
    __assert_fail(
      "strlen(label) < INDENT_LEN-1",
      "/home/mantovan/Repositories/libyang/src/printer_info.c",
      0x43u,
      "info_print_snode");
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)s, v4, v5, s);
  if ( !v27 )
    return sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  if ( *(_QWORD *)v27 )
  {
    v10 = sub_8164(*(_DWORD *)(v27 + 56));
    sub_C1FF7(a1, "%s \"", (__int64)v10, v11, v12, v13);
    if ( a2 != lys_parent(v27) )
      sub_C1FF7(a1, "%s:", *(_QWORD *)(*(_QWORD *)(v27 + 48) + 16LL), v14, v15, v16);
    sub_C1FF7(a1, "%s\"\n", *(_QWORD *)v27, v14, v15, v16);
  }
  else
  {
    if ( *(_DWORD *)(v27 + 56) == 512 )
      v18 = "input";
    else
      v18 = "output";
    sub_C1FF7(a1, (const char *)&off_128D15, (__int64)v18, a1, v8, v9);
  }
  result = *(_QWORD *)(v27 + 80);
  for ( i = *(_QWORD *)(v27 + 80); i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_QWORD *)i )
    {
      v20 = sub_8164(*(_DWORD *)(i + 56));
      sub_C1FF7(a1, "%*s%s \"", 11LL, (__int64)&unk_128D19, (__int64)v20, v21);
      if ( a2 != lys_parent(i) )
        sub_C1FF7(a1, "%s:", *(_QWORD *)(*(_QWORD *)(i + 48) + 16LL), v22, v23, v24);
      sub_C1FF7(a1, "%s\"\n", *(_QWORD *)i, v22, v23, v24);
    }
    else
    {
      if ( *(_DWORD *)(i + 56) == 512 )
        v25 = "input";
      else
        v25 = "output";
      sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, (__int64)v25, v17);
    }
    result = *(_QWORD *)(i + 80);
  }
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FEBD1) ----------------------------------------------------
signed __int64 __fastcall sub_FEBD1(__int64 a1, __int16 a2, __int16 a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  signed __int64 result; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  int v27; // [rsp+Ch] [rbp-14h]
  __int16 v28; // [rsp+10h] [rbp-10h]

  v27 = a4;
  v28 = a3;
  if ( a3 & 3 )
  {
    sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Config: ", a5, a6);
    if ( a2 & 2 )
      sub_C1FF7(a1, "read-only\n", v6, v7, v8, v9);
    else
      sub_C1FF7(a1, "read-write\n", v6, v7, v8, v9);
  }
  if ( v28 & 0x38 )
  {
    sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Status: ", a5, a6);
    if ( a2 & 0x10 )
    {
      sub_C1FF7(a1, "deprecated\n", v10, v11, v12, v13);
    }
    else if ( a2 & 0x20 )
    {
      sub_C1FF7(a1, "obsolete\n", v10, v11, v12, v13);
    }
    else
    {
      sub_C1FF7(a1, "current\n", v10, v11, v12, v13);
    }
  }
  result = (unsigned __int8)v28 & 0xC0;
  if ( v28 & 0xC0 )
  {
    sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Mandatory: ", a5, a6);
    if ( a2 & 0x40 )
      result = sub_C1FF7(a1, "yes\n", v15, v16, v17, v18);
    else
      result = sub_C1FF7(a1, (const char *)&off_128E00, v15, v16, v17, v18);
  }
  if ( v27 )
  {
    result = v28 & 0x100;
    if ( v28 & 0x100 )
    {
      sub_C1FF7(a1, "%-*s", 11LL, (__int64)&off_128E00 + 4, a5, a6);
      if ( a2 & 0x100 )
        result = sub_C1FF7(a1, "user-ordered\n", v19, v20, v21, v22);
      else
        result = sub_C1FF7(a1, "system-ordered\n", v19, v20, v21, v22);
    }
  }
  if ( !v27 )
  {
    result = v28 & 0x100;
    if ( v28 & 0x100 )
    {
      sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Enabled: ", a5, a6);
      if ( a2 & 0x100 )
        result = sub_C1FF7(a1, "yes\n", v23, v24, v25, v26);
      else
        result = sub_C1FF7(a1, (const char *)&off_128E00, v23, v24, v25, v26);
    }
  }
  return result;
}
// 128E00: using guessed type void *off_128E00;

//----- (00000000000FEE4A) ----------------------------------------------------
signed __int64 __fastcall sub_FEE4A(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  signed __int64 result; // rax
  unsigned __int8 v21; // [rsp+4h] [rbp-2Ch]
  __int64 *v22; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v22 = a3;
  v21 = a4;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"If-feats: ", a5, a6);
  if ( !v21 )
    return sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  sub_C2DA0(a1, a2, v22, 1u);
  sub_C1FF7(a1, "\n", v10, v11, v12, v13);
  for ( i = 1; ; ++i )
  {
    result = v21;
    if ( i >= v21 )
      break;
    sub_C1FF7(a1, "%*s", 11LL, (__int64)&unk_128D19, v14, v15);
    sub_C2DA0(a1, a2, &v22[4 * i], 1u);
    sub_C1FF7(a1, "\n", v16, v17, v18, v19);
  }
  return result;
}

//----- (00000000000FEF59) ----------------------------------------------------
signed __int64 __fastcall sub_FEF59(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 *v11; // [rsp+0h] [rbp-10h]

  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"When: ", a5, a6, a2);
  if ( v11 )
    result = sub_C1FF7(a1, (const char *)&off_128D15, *v11, v7, v8, v9);
  else
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FEFD0) ----------------------------------------------------
signed __int64 __fastcall sub_FEFD0(__int64 a1, __int64 *a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  signed __int64 result; // rax
  unsigned __int8 v12; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v12 = a3;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Must: ", a5, a6);
  if ( !v12 )
    return sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  sub_C1FF7(a1, (const char *)&off_128D15, *a2, v7, v8, v9);
  for ( i = 1; ; ++i )
  {
    result = v12;
    if ( i >= v12 )
      break;
    sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, a2[7 * i], v10);
  }
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FF0A9) ----------------------------------------------------
signed __int64 __fastcall sub_FF0A9(__int64 a1, __int64 *a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  signed __int64 result; // rax
  unsigned __int8 v12; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v12 = a3;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Typedefs: ", a5, a6);
  if ( !v12 )
    return sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  sub_C1FF7(a1, (const char *)&off_128D15, *a2, v7, v8, v9);
  for ( i = 1; ; ++i )
  {
    result = v12;
    if ( i >= v12 )
      break;
    sub_C1FF7(a1, "%*s%s", 11LL, (__int64)&unk_128D19, a2[16 * (signed __int64)i], v10);
  }
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FF177) ----------------------------------------------------
signed __int64 __fastcall sub_FF177(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int i; // [rsp+14h] [rbp-Ch]
  signed int j; // [rsp+14h] [rbp-Ch]
  signed int v14; // [rsp+18h] [rbp-8h]
  signed int v15; // [rsp+1Ch] [rbp-4h]

  v15 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Typedefs: ", a5, a6, a2);
  if ( *(_WORD *)(v11 + 74) )
  {
    sub_C1FF7(a1, (const char *)&off_128D15, **(_QWORD **)(v11 + 112), v7, v8, v9);
    v15 = 0;
    for ( i = 1; i < *(unsigned __int16 *)(v11 + 74); ++i )
      sub_C1FF7(
        a1,
        "%*s%s\n",
        11LL,
        (__int64)&unk_128D19,
        *(_QWORD *)(((signed __int64)i << 7) + *(_QWORD *)(v11 + 112)),
        v9);
  }
  for ( j = 0; ; ++j )
  {
    result = *(unsigned __int8 *)(v11 + 70);
    if ( j >= (signed int)result )
      break;
    v7 = *(_QWORD *)(v11 + 104);
    v6 = j;
    if ( *(_WORD *)(*(_QWORD *)(v7 + 48LL * j) + 74LL) )
    {
      if ( v15 )
      {
        sub_C1FF7(
          a1,
          "%s (%s)\n",
          **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * j) + 112LL),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * j) + 8LL),
          v8,
          v9);
        v14 = 1;
      }
      else
      {
        v14 = 0;
      }
      v15 = 0;
      while ( 1 )
      {
        v7 = *(_QWORD *)(v11 + 104);
        v6 = j;
        if ( v14 >= *(unsigned __int16 *)(*(_QWORD *)(v7 + 48LL * j) + 74LL) )
          break;
        sub_C1FF7(
          a1,
          "%*s%s (%s)\n",
          11LL,
          (__int64)&unk_128D19,
          *(_QWORD *)(((signed __int64)v14++ << 7) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * j) + 112LL)),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * j) + 8LL));
      }
    }
  }
  if ( v15 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FF3FC) ----------------------------------------------------
signed __int64 __fastcall sub_FF3FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  const char *v10; // rax
  const char *v11; // rax
  const char *v12; // rax
  const char *v13; // rax
  const char *v14; // rax
  const char *v15; // rax
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  const char *v22; // rax
  const char *v23; // rdx
  __int64 v24; // r9
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  int v33; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+24h] [rbp-Ch]
  unsigned int k; // [rsp+24h] [rbp-Ch]
  unsigned int l; // [rsp+24h] [rbp-Ch]
  unsigned int m; // [rsp+24h] [rbp-Ch]
  unsigned int n; // [rsp+24h] [rbp-Ch]
  signed __int64 j; // [rsp+28h] [rbp-8h]

  v33 = a3;
  if ( (_DWORD)a3 )
    sub_C1FF7(a1, "  ", a3, a4, a5, a6);
  switch ( *(_DWORD *)a2 )
  {
    case 1:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"binary", a6);
      if ( !v33 )
      {
        if ( *(_QWORD *)(a2 + 32) )
          v10 = **(const char ***)(a2 + 32);
        else
          v10 = 0LL;
        sub_FE7ED(a1, v10, (__int64)"Length: ", a1, v8, v9);
      }
      break;
    case 2:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"bits", a6);
      if ( !*(_DWORD *)(a2 + 40) )
        __assert_fail(
          "type->info.bits.count",
          "/home/mantovan/Repositories/libyang/src/printer_info.c",
          0x114u,
          "info_print_type_detail_");
      if ( !v33 )
      {
        sub_C1FF7(
          a1,
          "%-*s%u %s\n",
          11LL,
          (__int64)"Bits: ",
          *(unsigned int *)(*(_QWORD *)(a2 + 32) + 28LL),
          **(_QWORD **)(a2 + 32));
        for ( i = 1; i < *(_DWORD *)(a2 + 40); ++i )
          sub_C1FF7(
            a1,
            "%*s%u %s\n",
            11LL,
            (__int64)&unk_128D19,
            *(unsigned int *)(*(_QWORD *)(a2 + 32) + 48LL * i + 28),
            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 48LL * i));
      }
      break;
    case 3:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"boolean", a6);
      break;
    case 4:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"decimal64", a6);
      if ( !v33 )
      {
        if ( *(_QWORD *)(a2 + 32) )
          v11 = **(const char ***)(a2 + 32);
        else
          v11 = 0LL;
        sub_FE7ED(a1, v11, (__int64)"Range: ", a1, v8, v9);
        if ( !*(_BYTE *)(a2 + 40) )
          __assert_fail(
            "type->info.dec64.dig",
            "/home/mantovan/Repositories/libyang/src/printer_info.c",
            0x124u,
            "info_print_type_detail_");
        if ( *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72LL) )
          v12 = " (derived)";
        else
          v12 = (const char *)&unk_128D19;
        sub_C1FF7(a1, "%-*s%u%s\n", 11LL, (__int64)"Frac dig: ", *(unsigned __int8 *)(a2 + 40), (__int64)v12);
      }
      break;
    case 5:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"empty", a6);
      break;
    case 6:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"enumeration", a6);
      for ( j = a2; !*(_DWORD *)(j + 40); j = *(_QWORD *)(j + 16) + 56LL )
        ;
      if ( !v33 )
      {
        sub_C1FF7(
          a1,
          "%-*s%s (%d)\n",
          11LL,
          (__int64)"Values: ",
          **(_QWORD **)(j + 32),
          *(unsigned int *)(*(_QWORD *)(j + 32) + 28LL));
        for ( k = 1; k < *(_DWORD *)(j + 40); ++k )
          sub_C1FF7(
            a1,
            "%*s%s (%d)\n",
            11LL,
            (__int64)&unk_128D19,
            *(_QWORD *)(*(_QWORD *)(j + 32) + 48LL * k),
            *(unsigned int *)(*(_QWORD *)(j + 32) + 48LL * k + 28));
      }
      break;
    case 7:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"identityref", a6);
      if ( !v33 && *(_DWORD *)(a2 + 40) )
      {
        sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Idents:   ", ***(_QWORD ***)(a2 + 32), v9);
        for ( l = 1; l < *(_DWORD *)(a2 + 40); ++l )
          sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, **(_QWORD **)(8LL * l + *(_QWORD *)(a2 + 32)), v9);
      }
      break;
    case 8:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"instance-identifier", a6);
      if ( !v33 )
      {
        if ( *(_BYTE *)(a2 + 32) > 0 )
          v13 = "yes";
        else
          v13 = "no";
        sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Required: ", (__int64)v13, v9);
      }
      break;
    case 9:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"leafref", a6);
      if ( !v33 )
        sub_FE7ED(a1, *(const char **)(a2 + 32), (__int64)"Path: ", *(_QWORD *)(a2 + 32), v8, v9);
      break;
    case 0xA:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"string", a6);
      if ( !v33 )
      {
        if ( *(_QWORD *)(a2 + 32) )
          v15 = **(const char ***)(a2 + 32);
        else
          v15 = 0LL;
        sub_FE7ED(a1, v15, (__int64)"Length: ", a1, v8, v9);
        sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Pattern: ", v16, v17);
        if ( *(_DWORD *)(a2 + 48) )
        {
          if ( ***(_BYTE ***)(a2 + 40) == 21 )
            v22 = " (invert-match)";
          else
            v22 = (const char *)&unk_128D19;
          sub_C1FF7(a1, "%s%s\n", **(_QWORD **)(a2 + 40) + 1LL, (__int64)v22, v20, v21);
          for ( m = 1; m < *(_DWORD *)(a2 + 48); ++m )
          {
            if ( **(_BYTE **)(*(_QWORD *)(a2 + 40) + 56LL * m) == 21 )
              v23 = " (invert-match)";
            else
              v23 = (const char *)&unk_128D19;
            sub_C1FF7(
              a1,
              "%*s%s%s\n",
              11LL,
              (__int64)&unk_128D19,
              *(_QWORD *)(*(_QWORD *)(a2 + 40) + 56LL * m) + 1LL,
              (__int64)v23);
          }
        }
        else
        {
          sub_C1FF7(a1, "\n", v18, v19, v20, v21);
        }
      }
      break;
    case 0xB:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"union", a6);
      if ( !v33 )
      {
        for ( n = 0; n < *(_DWORD *)(a2 + 40); ++n )
          sub_FF3FC(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)n << 6), 1LL);
      }
      break;
    case 0xC:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"int8", a6);
      goto LABEL_55;
    case 0xD:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"uint8", a6);
      goto LABEL_55;
    case 0xE:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"int16", a6);
      goto LABEL_55;
    case 0xF:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"uint16", a6);
      goto LABEL_55;
    case 0x10:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"int32", a6);
      goto LABEL_55;
    case 0x11:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"uint32", a6);
      goto LABEL_55;
    case 0x12:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"int64", a6);
      goto LABEL_55;
    case 0x13:
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"uint64", a6);
LABEL_55:
      if ( !v33 )
      {
        if ( *(_QWORD *)(a2 + 32) )
          v14 = **(const char ***)(a2 + 32);
        else
          v14 = 0LL;
        sub_FE7ED(a1, v14, (__int64)"Range: ", a1, v8, v9);
      }
      break;
    default:
      sub_12222(
        **(_QWORD **)(*(_QWORD *)(a2 + 24) + 48LL),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_info.c",
        395LL);
      sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Base type: ", (__int64)"UNKNOWN", v24);
      break;
  }
  if ( v33 )
    sub_C1FF7(a1, "  ", v6, v7, v8, v9);
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Superior: ", v8, v9);
  if ( !*(_QWORD *)(a2 + 16) )
    return sub_C1FF7(a1, "\n", v25, v26, v27, v28);
  if ( !(unsigned int)sub_A6074(a2) )
    sub_C1FF7(a1, "%s:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 48LL) + 8LL), v29, v30, v31);
  return sub_C1FF7(a1, (const char *)&off_128D15, **(_QWORD **)(a2 + 16), v29, v30, v31);
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000000FFF2C) ----------------------------------------------------
signed __int64 __fastcall sub_FFF2C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_FF3FC(a1, a2, 0LL, a2, a5, a6);
}

//----- (00000000000FFF5A) ----------------------------------------------------
signed __int64 __fastcall sub_FFF5A(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  unsigned int v11; // [rsp+0h] [rbp-10h]

  sub_C1FF7(a1, "%-*s%u..", 11LL, (__int64)"Elements: ", a2, a6, __PAIR__(a2, a3));
  if ( v11 )
    result = sub_C1FF7(a1, (const char *)&off_12909C, v11, v7, v8, v9);
  else
    result = sub_C1FF7(a1, "unbounded\n", v6, v7, v8, v9);
  return result;
}
// 12909C: using guessed type void *__ptr32 off_12909C;

//----- (00000000000FFFD4) ----------------------------------------------------
signed __int64 __fastcall sub_FFFD4(__int64 a1, __int64 **a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  signed __int64 result; // rax
  unsigned __int8 v12; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+28h] [rbp-8h]
  signed int j; // [rsp+2Ch] [rbp-4h]

  v12 = a3;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Unique: ", a5, a6);
  if ( !v12 )
    return sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  sub_C1FF7(a1, (const char *)&off_128D15, **a2, v7, v8, v9);
  for ( i = 0; ; ++i )
  {
    result = v12;
    if ( i >= v12 )
      break;
    for ( j = i == 0; j < LOBYTE(a2[2 * i + 1]); ++j )
      sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, a2[2 * i][j], v10);
  }
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000001000F2) ----------------------------------------------------
signed __int64 __fastcall sub_1000F2(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  signed __int64 result; // rax
  unsigned __int8 v12; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+2Ch] [rbp-4h]

  v12 = a3;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Revisions: ", a5, a6);
  if ( !v12 )
    return sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  sub_C1FF7(a1, (const char *)&off_128D15, a2, v7, v8, v9);
  for ( i = 1; ; ++i )
  {
    result = v12;
    if ( i >= v12 )
      break;
    sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, 40LL * i + a2, v10);
  }
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (00000000001001C8) ----------------------------------------------------
signed __int64 __fastcall sub_1001C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int v12; // [rsp+14h] [rbp-Ch]
  signed int v13; // [rsp+18h] [rbp-8h]
  signed int v14; // [rsp+18h] [rbp-8h]
  signed int i; // [rsp+1Ch] [rbp-4h]

  v12 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Imports: ", a5, a6, a2);
  if ( *(_BYTE *)(v11 + 69) )
  {
    sub_C1FF7(
      a1,
      "%s:%s\n",
      *(_QWORD *)(*(_QWORD *)(v11 + 96) + 8LL),
      *(_QWORD *)(**(_QWORD **)(v11 + 96) + 8LL),
      v8,
      v9);
    v13 = 1;
    v12 = 0;
    while ( v13 < *(unsigned __int8 *)(v11 + 69) )
    {
      sub_C1FF7(
        a1,
        "%*s%s:%s\n",
        11LL,
        (__int64)&unk_128D19,
        *(_QWORD *)(*(_QWORD *)(v11 + 96) + 56LL * v13 + 8),
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 96) + 56LL * v13) + 8LL));
      ++v13;
    }
  }
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(v11 + 70);
    if ( i >= (signed int)result )
      break;
    v7 = *(_QWORD *)(v11 + 104);
    v6 = i;
    if ( *(_BYTE *)(*(_QWORD *)(v7 + 48LL * i) + 69LL) )
    {
      if ( v12 )
      {
        sub_C1FF7(
          a1,
          "%s:%s (%s)\n",
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 96LL) + 8LL),
          *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 96LL) + 8LL),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 8LL),
          v9);
        v14 = 1;
      }
      else
      {
        v14 = 0;
      }
      v12 = 0;
      while ( 1 )
      {
        v7 = *(_QWORD *)(v11 + 104);
        v6 = i;
        if ( v14 >= *(unsigned __int8 *)(*(_QWORD *)(v7 + 48LL * i) + 69LL) )
          break;
        sub_C1FF7(
          a1,
          "%*s%s:%s (%s)\n",
          11LL,
          (__int64)&unk_128D19,
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 96LL) + 56LL * v14 + 8),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 96LL) + 56LL * v14) + 8LL),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 8LL));
        ++v14;
      }
    }
  }
  if ( v12 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}

//----- (000000000010051E) ----------------------------------------------------
signed __int64 __fastcall sub_10051E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int v12; // [rsp+18h] [rbp-8h]
  signed int v13; // [rsp+1Ch] [rbp-4h]

  v12 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Includes: ", a5, a6, a2);
  result = *(unsigned __int8 *)(v11 + 70);
  if ( (_BYTE)result )
  {
    sub_C1FF7(a1, (const char *)&off_128D15, *(_QWORD *)(**(_QWORD **)(v11 + 104) + 8LL), v7, v8, v9);
    v13 = 1;
    v12 = 0;
    while ( 1 )
    {
      result = *(unsigned __int8 *)(v11 + 70);
      if ( v13 >= (signed int)result )
        break;
      sub_C1FF7(
        a1,
        "%*s%s\n",
        11LL,
        (__int64)&unk_128D19,
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * v13++) + 8LL),
        v9);
    }
  }
  if ( v12 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (0000000000100621) ----------------------------------------------------
signed __int64 __fastcall sub_100621(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int v12; // [rsp+18h] [rbp-8h]
  signed int v13; // [rsp+1Ch] [rbp-4h]

  v12 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Augments: ", a5, a6, a2);
  result = *(unsigned __int8 *)(v11 + 77);
  if ( (_BYTE)result )
  {
    sub_C1FF7(a1, "\"%s\"\n", **(_QWORD **)(v11 + 136), v7, v8, v9);
    v13 = 1;
    v12 = 0;
    while ( 1 )
    {
      result = *(unsigned __int8 *)(v11 + 77);
      if ( v13 >= (signed int)result )
        break;
      sub_C1FF7(a1, "%*s\"%s\"\n", 11LL, (__int64)&unk_128D19, *(_QWORD *)(*(_QWORD *)(v11 + 136) + 104LL * v13++), v9);
    }
  }
  if ( v12 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}

//----- (0000000000100729) ----------------------------------------------------
signed __int64 __fastcall sub_100729(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int v12; // [rsp+18h] [rbp-8h]
  signed int v13; // [rsp+1Ch] [rbp-4h]

  v12 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Deviation: ", a5, a6, a2);
  result = *(unsigned __int8 *)(v11 + 78);
  if ( (_BYTE)result )
  {
    sub_C1FF7(a1, "\"%s\"\n", **(_QWORD **)(v11 + 144), v7, v8, v9);
    v13 = 1;
    v12 = 0;
    while ( 1 )
    {
      result = *(unsigned __int8 *)(v11 + 78);
      if ( v13 >= (signed int)result )
        break;
      sub_C1FF7(a1, "%*s\"%s\"\n", 11LL, (__int64)&unk_128D19, *(_QWORD *)(*(_QWORD *)(v11 + 144) + 56LL * v13++), v9);
    }
  }
  if ( v12 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}

//----- (000000000010082B) ----------------------------------------------------
signed __int64 __fastcall sub_10082B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int v12; // [rsp+14h] [rbp-Ch]
  signed int v13; // [rsp+18h] [rbp-8h]
  signed int v14; // [rsp+18h] [rbp-8h]
  signed int i; // [rsp+1Ch] [rbp-4h]

  v12 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Idents: ", a5, a6, a2);
  if ( *(_WORD *)(v11 + 72) )
  {
    sub_C1FF7(a1, (const char *)&off_128D15, **(_QWORD **)(v11 + 120), v7, v8, v9);
    v13 = 1;
    v12 = 0;
    while ( v13 < *(unsigned __int16 *)(v11 + 72) )
      sub_C1FF7(a1, "%*s%s\n", 11LL, (__int64)&unk_128D19, *(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * v13++), v9);
  }
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(v11 + 70);
    if ( i >= (signed int)result )
      break;
    v7 = *(_QWORD *)(v11 + 104);
    v6 = i;
    if ( *(_WORD *)(*(_QWORD *)(v7 + 48LL * i) + 72LL) )
    {
      if ( v12 )
      {
        sub_C1FF7(
          a1,
          "%s (%s)\n",
          **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 120LL),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 8LL),
          v8,
          v9);
        v14 = 1;
      }
      else
      {
        v14 = 0;
      }
      v12 = 0;
      while ( 1 )
      {
        v7 = *(_QWORD *)(v11 + 104);
        v6 = i;
        if ( v14 >= *(unsigned __int16 *)(*(_QWORD *)(v7 + 48LL * i) + 72LL) )
          break;
        sub_C1FF7(
          a1,
          "%*s%s (%s)\n",
          11LL,
          (__int64)&unk_128D19,
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 120LL) + 72LL * v14++),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 8LL));
      }
    }
  }
  if ( v12 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (0000000000100AC4) ----------------------------------------------------
signed __int64 __fastcall sub_100AC4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  signed __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-20h]
  signed int v12; // [rsp+14h] [rbp-Ch]
  signed int v13; // [rsp+18h] [rbp-8h]
  signed int v14; // [rsp+18h] [rbp-8h]
  signed int i; // [rsp+1Ch] [rbp-4h]

  v12 = 1;
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Features: ", a5, a6, a2);
  if ( *(_BYTE *)(v11 + 76) )
  {
    sub_C1FF7(a1, (const char *)&off_128D15, **(_QWORD **)(v11 + 128), v7, v8, v9);
    v13 = 1;
    v12 = 0;
    while ( v13 < *(unsigned __int8 *)(v11 + 76) )
      sub_C1FF7(
        a1,
        "%*s%s\n",
        11LL,
        (__int64)&unk_128D19,
        *(_QWORD *)(((signed __int64)v13++ << 6) + *(_QWORD *)(v11 + 128)),
        v9);
  }
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(v11 + 70);
    if ( i >= (signed int)result )
      break;
    v7 = *(_QWORD *)(v11 + 104);
    v6 = i;
    if ( *(_BYTE *)(*(_QWORD *)(v7 + 48LL * i) + 76LL) )
    {
      if ( v12 )
      {
        sub_C1FF7(
          a1,
          "%s (%s)\n",
          **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 128LL),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 8LL),
          v8,
          v9);
        v14 = 1;
      }
      else
      {
        v14 = 0;
      }
      v12 = 0;
      while ( 1 )
      {
        v7 = *(_QWORD *)(v11 + 104);
        v6 = i;
        if ( v14 >= *(unsigned __int8 *)(*(_QWORD *)(v7 + 48LL * i) + 76LL) )
          break;
        sub_C1FF7(
          a1,
          "%*s%s (%s)\n",
          11LL,
          (__int64)&unk_128D19,
          *(_QWORD *)(((signed __int64)v14++ << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 128LL)),
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 104) + 48LL * i) + 8LL));
      }
    }
  }
  if ( v12 )
    result = sub_C1FF7(a1, "\n", v6, v7, v8, v9);
  return result;
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (0000000000100D53) ----------------------------------------------------
signed __int64 __fastcall sub_100D53(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  signed __int64 result; // rax
  const char *v9; // rbx
  void *v10; // r13
  const char *v11; // r12
  const char *v12; // r14
  const char *v13; // rax
  const char *v14; // r13
  void *v15; // r12
  const char *v16; // rbx
  __int64 v17; // r14
  const char *v18; // rax
  __int64 v19; // [rsp+0h] [rbp-50h]
  signed int v20; // [rsp+18h] [rbp-38h]
  signed int v21; // [rsp+1Ch] [rbp-34h]
  __int64 i; // [rsp+20h] [rbp-30h]
  __int64 v23; // [rsp+28h] [rbp-28h]

  v20 = 1;
  v23 = lys_main_module(a2);
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Data: ", v2, v3, a2);
  result = *(_QWORD *)(v23 + 168);
  if ( result )
  {
    result = *(_QWORD *)(v23 + 168);
    for ( i = *(_QWORD *)(v23 + 168); ; i = *(_QWORD *)(i + 80) )
    {
      if ( !i )
        break;
      if ( v19 == *(_QWORD *)(i + 48) )
      {
        v21 = 0;
      }
      else
      {
        if ( v23 != v19 )
          goto LABEL_31;
        v21 = 1;
      }
      if ( lys_parent(i)
        || strcmp(*(const char **)i, "config")
        || strcmp(*(const char **)(*(_QWORD *)(i + 48) + 8LL), "ietf-netconf") )
      {
        if ( v20 )
        {
          if ( v21 )
            v9 = ")";
          else
            v9 = (const char *)&unk_128D19;
          if ( v21 )
            v10 = *(void **)(*(_QWORD *)(i + 48) + 8LL);
          else
            v10 = &unk_128D19;
          if ( v21 )
            v11 = " (";
          else
            v11 = (const char *)&unk_128D19;
          v12 = *(const char **)i;
          v13 = sub_8164(*(_DWORD *)(i + 56));
          sub_C1FF7(a1, "%s \"%s\"%s%s%s\n", (__int64)v13, (__int64)v12, (__int64)v11, (__int64)v10, v9);
          v20 = 0;
        }
        else
        {
          if ( v21 )
            v14 = ")";
          else
            v14 = (const char *)&unk_128D19;
          if ( v21 )
            v15 = *(void **)(*(_QWORD *)(i + 48) + 8LL);
          else
            v15 = &unk_128D19;
          if ( v21 )
            v16 = " (";
          else
            v16 = (const char *)&unk_128D19;
          v17 = *(_QWORD *)i;
          v18 = sub_8164(*(_DWORD *)(i + 56));
          sub_C1FF7(a1, "%*s%s \"%s\"%s%s%s\n", 11LL, (__int64)&unk_128D19, (__int64)v18, v17, v16, v15, v14);
        }
      }
LABEL_31:
      result = *(_QWORD *)(i + 80);
    }
  }
  if ( v20 )
    result = sub_C1FF7(a1, "\n", v4, v5, v6, v7);
  return result;
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);

//----- (0000000000100FC5) ----------------------------------------------------
signed __int64 __fastcall sub_100FC5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char **v6; // ST10_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9

  v6 = (const char **)a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Typedef: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, v6[1], (__int64)"Desc: ", (__int64)v6[1], v8, v9);
  sub_FE7ED(a1, v6[2], (__int64)"Reference: ", (__int64)v6[2], v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 56, 0, v12, v13);
  sub_FF3FC(a1, (__int64)(v6 + 7), 0LL, (__int64)(v6 + 7), v14, v15);
  sub_FE7ED(a1, v6[5], (__int64)"Units: ", (__int64)v6[5], v16, v17);
  return sub_FE7ED(a1, v6[15], (__int64)"Default: ", (__int64)v6[15], v18, v19);
}

//----- (00000000001010F2) ----------------------------------------------------
signed __int64 __fastcall sub_1010F2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned int v19; // esi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  signed __int64 result; // rax
  unsigned int v25; // esi
  __int64 v26; // [rsp+10h] [rbp-20h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]
  unsigned int j; // [rsp+2Ch] [rbp-4h]

  v26 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Identity: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v6);
  sub_FE7ED(a1, *(const char **)(v26 + 8), (__int64)"Desc: ", *(_QWORD *)(v26 + 8), v7, v8);
  sub_FE7ED(a1, *(const char **)(v26 + 16), (__int64)"Reference: ", *(_QWORD *)(v26 + 16), v9, v10);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 56, 0, v11, v12);
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Base: ", v13, v14);
  for ( i = 0; i < *(unsigned __int8 *)(v26 + 31); ++i )
  {
    if ( i )
      v19 = 11;
    else
      v19 = 0;
    sub_C1FF7(a1, "%*s%s\n", v19, (__int64)&unk_128D19, **(_QWORD **)(8LL * i + *(_QWORD *)(v26 + 56)), v18);
  }
  if ( !i )
    sub_C1FF7(a1, "\n", v15, v16, v17, v18);
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Derived: ", v17, v18);
  result = *(_QWORD *)(v26 + 64);
  if ( result )
  {
    for ( j = 0; ; ++j )
    {
      result = *(unsigned int *)(*(_QWORD *)(v26 + 64) + 4LL);
      if ( j >= (unsigned int)result )
        break;
      if ( j )
        v25 = 11;
      else
        v25 = 0;
      sub_C1FF7(
        a1,
        "%*s%s\n",
        v25,
        (__int64)&unk_128D19,
        **(_QWORD **)(8LL * j + *(_QWORD *)(*(_QWORD *)(v26 + 64) + 8LL)),
        v23);
    }
    if ( !j )
      result = sub_C1FF7(a1, "\n", v20, v21, v22, v23);
  }
  return result;
}

//----- (0000000000101336) ----------------------------------------------------
signed __int64 __fastcall sub_101336(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST10_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Feature: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 312, 0, v12, v13);
  return sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v14, v15);
}

//----- (0000000000101432) ----------------------------------------------------
signed __int64 __fastcall sub_101432(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r9
  const char *v17; // rax
  __int64 v18; // r9
  const char *v19; // rax
  __int64 v20; // r9
  const char *v21; // rax
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rcx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rcx
  __int64 v42; // r8
  __int64 v43; // r9
  __int64 v44; // rcx
  __int64 v45; // r8
  __int64 v46; // r9
  __int64 v48; // [rsp+0h] [rbp-10h]

  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(a2 + 8), a6, a2);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Namespace: ", *(_QWORD *)(v48 + 176), v6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Prefix: ", *(_QWORD *)(v48 + 16), v7);
  sub_FE7ED(a1, *(const char **)(v48 + 24), (__int64)"Desc: ", *(_QWORD *)(v48 + 24), v8, v9);
  sub_FE7ED(a1, *(const char **)(v48 + 32), (__int64)"Reference: ", *(_QWORD *)(v48 + 32), v10, v11);
  sub_FE7ED(a1, *(const char **)(v48 + 40), (__int64)"Org: ", *(_QWORD *)(v48 + 40), v12, v13);
  sub_FE7ED(a1, *(const char **)(v48 + 48), (__int64)"Contact: ", *(_QWORD *)(v48 + 48), v14, v15);
  if ( (*(_BYTE *)(v48 + 64) & 0xE) == 4 )
    v17 = "1.1";
  else
    v17 = "1.0";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"YANG ver: ", (__int64)v17, v16);
  if ( *(_BYTE *)(v48 + 64) & 0x30 )
    v19 = "yes";
  else
    v19 = "no";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Deviated: ", (__int64)v19, v18);
  if ( *(_BYTE *)(v48 + 64) >= 0 )
    v21 = "no";
  else
    v21 = "yes";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Implement: ", (__int64)v21, v20);
  sub_FE7ED(a1, *(const char **)(v48 + 56), (__int64)"URI: file://", *(_QWORD *)(v48 + 56), v22, v23);
  sub_1000F2(a1, *(_QWORD *)(v48 + 88), *(_BYTE *)(v48 + 68), *(_QWORD *)(v48 + 88), v24, v25);
  sub_10051E(a1, v48, v48, v26, v27, v28);
  sub_1001C8(a1, v48, v48, v29, v30, v31);
  sub_FF177(a1, v48, v48, v32, v33, v34);
  sub_10082B(a1, v48, v48, v35, v36, v37);
  sub_100AC4(a1, v48, v48, v38, v39, v40);
  sub_100621(a1, v48, v48, v41, v42, v43);
  sub_100729(a1, v48, v48, v44, v45, v46);
  return sub_100D53(a1, v48);
}

//----- (00000000001016EE) ----------------------------------------------------
signed __int64 __fastcall sub_1016EE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r9
  const char *v17; // rax
  __int64 v18; // r9
  const char *v19; // rax
  __int64 v20; // r9
  const char *v21; // rax
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rcx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rcx
  __int64 v42; // r8
  __int64 v43; // r9
  __int64 v44; // rcx
  __int64 v45; // r8
  __int64 v46; // r9
  __int64 v48; // [rsp+0h] [rbp-10h]

  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Submodule: ", *(_QWORD *)(a2 + 8), a6, a2);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Parent: ", *(_QWORD *)(*(_QWORD *)(v48 + 168) + 8LL), v6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Prefix: ", *(_QWORD *)(v48 + 16), v7);
  sub_FE7ED(a1, *(const char **)(v48 + 24), (__int64)"Desc: ", *(_QWORD *)(v48 + 24), v8, v9);
  sub_FE7ED(a1, *(const char **)(v48 + 32), (__int64)"Reference: ", *(_QWORD *)(v48 + 32), v10, v11);
  sub_FE7ED(a1, *(const char **)(v48 + 40), (__int64)"Org: ", *(_QWORD *)(v48 + 40), v12, v13);
  sub_FE7ED(a1, *(const char **)(v48 + 48), (__int64)"Contact: ", *(_QWORD *)(v48 + 48), v14, v15);
  if ( (*(_BYTE *)(v48 + 64) & 0xE) == 4 )
    v17 = "1.1";
  else
    v17 = "1.0";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"YANG ver: ", (__int64)v17, v16);
  if ( *(_BYTE *)(v48 + 64) & 0x30 )
    v19 = "yes";
  else
    v19 = "no";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Deviated: ", (__int64)v19, v18);
  if ( *(_BYTE *)(v48 + 64) >= 0 )
    v21 = "no";
  else
    v21 = "yes";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Implement: ", (__int64)v21, v20);
  sub_FE7ED(a1, *(const char **)(v48 + 56), (__int64)"URI: file://", *(_QWORD *)(v48 + 56), v22, v23);
  sub_1000F2(a1, *(_QWORD *)(v48 + 88), *(_BYTE *)(v48 + 68), *(_QWORD *)(v48 + 88), v24, v25);
  sub_10051E(a1, v48, v48, v26, v27, v28);
  sub_1001C8(a1, v48, v48, v29, v30, v31);
  sub_FF177(a1, v48, v48, v32, v33, v34);
  sub_10082B(a1, v48, v48, v35, v36, v37);
  sub_100AC4(a1, v48, v48, v38, v39, v40);
  sub_100621(a1, v48, v48, v41, v42, v43);
  sub_100729(a1, v48, v48, v44, v45, v46);
  return sub_100D53(a1, v48);
}

//----- (00000000001019AE) ----------------------------------------------------
signed __int64 __fastcall sub_1019AE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Container: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 59, 0, v12, v13);
  sub_FE7ED(a1, *(const char **)(v6 + 136), (__int64)"Presence: ", *(_QWORD *)(v6 + 136), v14, v15);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v16, v17);
  sub_FEF59(a1, *(_QWORD *)(v6 + 112), *(_QWORD *)(v6 + 112), v18, v19, v20);
  sub_FEFD0(a1, *(__int64 **)(v6 + 120), *(_BYTE *)(v6 + 29), *(_QWORD *)(v6 + 120), v21, v22);
  sub_FF0A9(a1, *(__int64 **)(v6 + 128), *(_WORD *)(v6 + 30), *(_QWORD *)(v6 + 128), v23, v24);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Children:");
}

//----- (0000000000101B50) ----------------------------------------------------
signed __int64 __fastcall sub_101B50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Choice: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 251, 0, v12, v13);
  sub_C1FF7(a1, "%-*s", 11LL, (__int64)"Default: ", v14, v15);
  if ( *(_QWORD *)(a2 + 112) )
    sub_C1FF7(a1, (const char *)&off_128D15, **(_QWORD **)(a2 + 112), v17, v18, v19);
  else
    sub_C1FF7(a1, "\n", v16, v17, v18, v19);
  sub_FEE4A(a1, *(_QWORD *)(a2 + 48), *(__int64 **)(a2 + 40), *(_BYTE *)(a2 + 27), v20, v21);
  sub_FEF59(a1, *(_QWORD *)(a2 + 104), *(_QWORD *)(a2 + 104), v22, v23, v24);
  return sub_FE96A(a1, a2, *(_QWORD *)(a2 + 72), "Cases:");
}
// 128D15: using guessed type void *__ptr32 off_128D15;

//----- (0000000000101CF8) ----------------------------------------------------
signed __int64 __fastcall sub_101CF8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Leaf: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 251, 0, v12, v13);
  sub_FE7ED(a1, **(const char ***)(v6 + 144), (__int64)"Type: ", **(_QWORD **)(v6 + 144), v14, v15);
  sub_FE7ED(a1, *(const char **)(v6 + 192), (__int64)"Units: ", *(_QWORD *)(v6 + 192), v16, v17);
  sub_FE7ED(a1, *(const char **)(v6 + 200), (__int64)"Default: ", *(_QWORD *)(v6 + 200), v18, v19);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v20, v21);
  sub_FEF59(a1, *(_QWORD *)(v6 + 112), *(_QWORD *)(v6 + 112), v22, v23, v24);
  return sub_FEFD0(a1, *(__int64 **)(v6 + 120), *(_BYTE *)(v6 + 31), *(_QWORD *)(v6 + 120), v25, v26);
}

//----- (0000000000101E9B) ----------------------------------------------------
signed __int64 __fastcall sub_101E9B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Leaflist: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 315, 1, v12, v13);
  sub_FE7ED(a1, **(const char ***)(v6 + 144), (__int64)"Type: ", **(_QWORD **)(v6 + 144), v14, v15);
  sub_FE7ED(a1, *(const char **)(v6 + 192), (__int64)"Units: ", *(_QWORD *)(v6 + 192), v16, v17);
  sub_FFF5A(a1, *(_DWORD *)(v6 + 208), *(_DWORD *)(v6 + 212), *(unsigned int *)(v6 + 208), v18, v19);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v20, v21);
  sub_FEF59(a1, *(_QWORD *)(v6 + 112), *(_QWORD *)(v6 + 112), v22, v23, v24);
  return sub_FEFD0(a1, *(__int64 **)(v6 + 120), *(_BYTE *)(v6 + 31), *(_QWORD *)(v6 + 120), v25, v26);
}

//----- (000000000010203F) ----------------------------------------------------
signed __int64 __fastcall sub_10203F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r8
  __int64 v28; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"List: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 315, 1, v12, v13);
  sub_FFF5A(a1, *(_DWORD *)(v6 + 152), *(_DWORD *)(v6 + 156), *(unsigned int *)(v6 + 152), v14, v15);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v16, v17);
  sub_FEF59(a1, *(_QWORD *)(v6 + 112), *(_QWORD *)(v6 + 112), v18, v19, v20);
  sub_FEFD0(a1, *(__int64 **)(v6 + 120), *(_BYTE *)(v6 + 28), *(_QWORD *)(v6 + 120), v21, v22);
  sub_FE7ED(a1, *(const char **)(v6 + 160), (__int64)"Keys: ", *(_QWORD *)(v6 + 160), v23, v24);
  sub_FFFD4(a1, *(__int64 ***)(v6 + 144), *(_BYTE *)(v6 + 31), *(_QWORD *)(v6 + 144), v25, v26);
  sub_FF0A9(a1, *(__int64 **)(v6 + 128), *(_BYTE *)(v6 + 29), *(_QWORD *)(v6 + 128), v27, v28);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Children:");
}

//----- (0000000000102228) ----------------------------------------------------
signed __int64 __fastcall sub_102228(__int64 a1, __int64 a2)
{
  const char *v2; // rax
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9

  if ( *(_DWORD *)(a2 + 56) == 32 )
    v2 = "Anyxml";
  else
    v2 = "Anydata";
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"%s: ", (__int64)v2, *(_QWORD *)a2);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v3);
  sub_FE7ED(a1, *(const char **)(a2 + 8), (__int64)"Desc: ", *(_QWORD *)(a2 + 8), v4, v5);
  sub_FE7ED(a1, *(const char **)(a2 + 16), (__int64)"Reference: ", *(_QWORD *)(a2 + 16), v6, v7);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 251, 0, v8, v9);
  sub_FEE4A(a1, *(_QWORD *)(a2 + 48), *(__int64 **)(a2 + 40), *(_BYTE *)(a2 + 27), v10, v11);
  sub_FEF59(a1, *(_QWORD *)(a2 + 112), *(_QWORD *)(a2 + 112), v12, v13, v14);
  return sub_FEFD0(a1, *(__int64 **)(a2 + 120), *(_BYTE *)(a2 + 31), *(_QWORD *)(a2 + 120), v15, v16);
}

//----- (0000000000102381) ----------------------------------------------------
signed __int64 __fastcall sub_102381(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Grouping: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 56, 0, v12, v13);
  sub_FF0A9(a1, *(__int64 **)(v6 + 104), *(_WORD *)(v6 + 30), *(_QWORD *)(v6 + 104), v14, v15);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Children:");
}

//----- (000000000010249F) ----------------------------------------------------
signed __int64 __fastcall sub_10249F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Case: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 59, 0, v12, v13);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v14, v15);
  sub_FEF59(a1, *(_QWORD *)(v6 + 104), *(_QWORD *)(v6 + 104), v16, v17, v18);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Children:");
}

//----- (00000000001025D9) ----------------------------------------------------
signed __int64 __fastcall sub_1025D9(__int64 a1, __int64 a2)
{
  __int64 *v2; // rax
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9

  if ( !lys_parent(a2) || *(_DWORD *)(lys_parent(a2) + 56) != 256 )
    __assert_fail(
      "lys_parent(node) && lys_parent(node)->nodetype == LYS_RPC",
      "/home/mantovan/Repositories/libyang/src/printer_info.c",
      0x3B0u,
      "info_print_input");
  v2 = (__int64 *)lys_parent(a2);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Input of: ", *v2, v3);
  sub_FF0A9(a1, *(__int64 **)(a2 + 104), *(_WORD *)(a2 + 30), *(_QWORD *)(a2 + 104), v4, v5);
  sub_FEFD0(a1, *(__int64 **)(a2 + 112), *(_BYTE *)(a2 + 29), *(_QWORD *)(a2 + 112), v6, v7);
  return sub_FE96A(a1, a2, *(_QWORD *)(a2 + 72), "Children:");
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000001026D7) ----------------------------------------------------
signed __int64 __fastcall sub_1026D7(__int64 a1, __int64 a2)
{
  __int64 *v2; // rax
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9

  if ( !lys_parent(a2) || *(_DWORD *)(lys_parent(a2) + 56) != 256 )
    __assert_fail(
      "lys_parent(node) && lys_parent(node)->nodetype == LYS_RPC",
      "/home/mantovan/Repositories/libyang/src/printer_info.c",
      0x3BEu,
      "info_print_output");
  v2 = (__int64 *)lys_parent(a2);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Output of: ", *v2, v3);
  sub_FF0A9(a1, *(__int64 **)(a2 + 104), *(_WORD *)(a2 + 30), *(_QWORD *)(a2 + 104), v4, v5);
  sub_FEFD0(a1, *(__int64 **)(a2 + 112), *(_BYTE *)(a2 + 29), *(_QWORD *)(a2 + 112), v6, v7);
  return sub_FE96A(a1, a2, *(_QWORD *)(a2 + 72), "Children:");
}
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (00000000001027D5) ----------------------------------------------------
signed __int64 __fastcall sub_1027D5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Notif: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 56, 0, v12, v13);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v14, v15);
  sub_FF0A9(a1, *(__int64 **)(v6 + 112), *(_WORD *)(v6 + 30), *(_QWORD *)(v6 + 112), v16, v17);
  sub_FEFD0(a1, *(__int64 **)(v6 + 120), *(_BYTE *)(v6 + 29), *(_QWORD *)(v6 + 120), v18, v19);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Params:");
}

//----- (000000000010293C) ----------------------------------------------------
signed __int64 __fastcall sub_10293C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"RPC: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 56, 0, v12, v13);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v14, v15);
  sub_FF0A9(a1, *(__int64 **)(v6 + 112), *(_WORD *)(v6 + 30), *(_QWORD *)(v6 + 112), v16, v17);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Data:");
}

//----- (0000000000102A81) ----------------------------------------------------
signed __int64 __fastcall sub_102A81(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST28_8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9

  v6 = a2;
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Action: ", *(_QWORD *)a2, a6);
  sub_C1FF7(a1, "%-*s%s\n", 11LL, (__int64)"Module: ", *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL), v7);
  sub_FE7ED(a1, *(const char **)(v6 + 8), (__int64)"Desc: ", *(_QWORD *)(v6 + 8), v8, v9);
  sub_FE7ED(a1, *(const char **)(v6 + 16), (__int64)"Reference: ", *(_QWORD *)(v6 + 16), v10, v11);
  sub_FEBD1(a1, *(_WORD *)(a2 + 24), 56, 0, v12, v13);
  sub_FEE4A(a1, *(_QWORD *)(v6 + 48), *(__int64 **)(v6 + 40), *(_BYTE *)(v6 + 27), v14, v15);
  sub_FF0A9(a1, *(__int64 **)(v6 + 112), *(_WORD *)(v6 + 30), *(_QWORD *)(v6 + 112), v16, v17);
  return sub_FE96A(a1, v6, *(_QWORD *)(v6 + 72), "Data:");
}

//----- (0000000000102BC6) ----------------------------------------------------
__int64 __fastcall sub_102BC6(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  v7 = 0;
  if ( a3 )
  {
    v7 = sub_C3393(
           a1,
           a2,
           a3,
           (void (__fastcall *)(__int64, signed __int64, int *))sub_100FC5,
           (void (__fastcall *)(__int64, signed __int64, int *))sub_1010F2,
           (void (__fastcall *)(__int64, signed __int64, int *))sub_101336,
           (void (__fastcall *)(__int64, __int64, int *))sub_FFF2C,
           (void (__fastcall *)(__int64, __int64, int *))sub_102381,
           (void (__fastcall *)(__int64, __int64, int *))sub_1019AE,
           (void (__fastcall *)(__int64, __int64, int *))sub_101B50,
           (void (__fastcall *)(__int64, __int64, int *))sub_101CF8,
           (void (__fastcall *)(__int64, __int64, int *))sub_101E9B,
           (void (__fastcall *)(__int64, __int64, int *))sub_10203F,
           (void (__fastcall *)(__int64, __int64, int *))sub_102228,
           (void (__fastcall *)(__int64, __int64, int *))sub_10249F,
           (void (__fastcall *)(__int64, __int64, int *))sub_1027D5,
           (void (__fastcall *)(__int64, __int64, int *))sub_10293C,
           (void (__fastcall *)(__int64, __int64, int *))sub_102A81,
           (void (__fastcall *)(__int64, __int64, int *))sub_1025D9,
           (void (__fastcall *)(__int64, __int64, int *))sub_1026D7);
  }
  else if ( *(_BYTE *)(a2 + 64) & 1 )
  {
    sub_1016EE(a1, a2, a2, a4, a5, a6);
  }
  else
  {
    sub_101432(a1, a2, a2, a4, a5, a6);
  }
  sub_C236C(a1);
  return v7;
}

//----- (0000000000102CD8) ----------------------------------------------------
__int64 __fastcall sub_102CD8(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // [rsp+0h] [rbp-20h]
  unsigned __int8 v7; // [rsp+17h] [rbp-9h]
  unsigned int i; // [rsp+18h] [rbp-8h]
  int v9; // [rsp+1Ch] [rbp-4h]

  v6 = a2;
  if ( !a2 )
    return 0LL;
  sub_C23A5(a1, "\"", 1uLL);
  v9 = 0;
  for ( i = 0; *(_BYTE *)(i + v6); ++i )
  {
    v7 = *(_BYTE *)(i + v6);
    if ( v7 > 0x1Fu )
    {
      if ( v7 == 34 )
      {
        v9 += sub_C1FF7(a1, "\\\"", i, v3, v4, v5, v6);
      }
      else if ( v7 == 92 )
      {
        v9 += sub_C1FF7(a1, "\\\\", i, v3, v4, v5, v6);
      }
      else
      {
        sub_C23A5(a1, (const void *)(i + v6), 1uLL);
        ++v9;
      }
    }
    else
    {
      v9 += sub_C1FF7(a1, "\\u%.4X", v7, v3, v4, v5, v6);
    }
  }
  sub_C23A5(a1, "\"", 1uLL);
  return (unsigned int)(v9 + 2);
}

//----- (0000000000102E00) ----------------------------------------------------
signed __int64 __fastcall sub_102E00(__int64 a1, int a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  const char *v7; // rdx
  const char *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  const char *v17; // rax
  signed __int64 result; // rax
  const char *v19; // rdx
  const char *v20; // rax
  int *v21; // rax
  char *v22; // rax
  __int64 v23; // r9
  __int64 v24; // [rsp+0h] [rbp-50h]
  _QWORD *v25; // [rsp+8h] [rbp-48h]
  __int64 i; // [rsp+28h] [rbp-28h]
  char *v27; // [rsp+30h] [rbp-20h]
  size_t n; // [rsp+38h] [rbp-18h]

  v25 = a3;
  v24 = a4;
  *__errno_location() = 0;
  if ( v24 )
  {
    sub_C1FF7(
      a1,
      "%*s\"%s:default\":\"true\"",
      (unsigned int)(2 * a2),
      (__int64)&unk_1293DF,
      *(_QWORD *)(v24 + 8),
      v4,
      v24);
    if ( a2 )
      v7 = "\n";
    else
      v7 = (const char *)&unk_1293DF;
    if ( v25[2] )
      v8 = ",";
    else
      v8 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%s%s", (__int64)v8, (__int64)v7, v5, v6);
  }
  for ( i = v25[2]; ; i = *(_QWORD *)(i + 8) )
  {
    if ( !i )
    {
      if ( !*__errno_location() )
        return 0LL;
      v21 = __errno_location();
      v22 = strerror(*v21);
      sub_12222(**(_QWORD **)(*v25 + 48LL), 0, 2, "Print error (%s).", (__int64)v22, v23, v24);
      return 1LL;
    }
    if ( *(_QWORD *)(i + 16) )
      break;
LABEL_35:
    ;
  }
  v9 = lys_main_module(*(_QWORD *)(*(_QWORD *)(i + 16) + 48LL));
  if ( v9 == lys_main_module(*(_QWORD *)(*v25 + 48LL)) )
    sub_C1FF7(a1, "%*s\"%s\":", (unsigned int)(2 * a2), (__int64)&unk_1293DF, *(_QWORD *)(i + 24), v10, v24);
  else
    sub_C1FF7(
      a1,
      "%*s\"%s:%s\":",
      (unsigned int)(2 * a2),
      (__int64)&unk_1293DF,
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(i + 16) + 48LL) + 8LL),
      *(_QWORD *)(i + 24),
      v24);
  switch ( *(_DWORD *)(i + 48) )
  {
    case 1:
    case 2:
    case 4:
    case 6:
    case 8:
    case 0xA:
    case 0x12:
    case 0x13:
      sub_102CD8(a1, *(_QWORD *)(i + 32));
      goto LABEL_28;
    case 3:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
      if ( **(_BYTE **)(i + 32) )
        v17 = *(const char **)(i + 32);
      else
        v17 = "null";
      sub_C1FF7(a1, (const char *)&off_12941A, (__int64)v17, a1, v13, v14);
      goto LABEL_28;
    case 5:
      sub_C1FF7(a1, "[null]", v11, v12, v13, v14);
      goto LABEL_28;
    case 7:
      v27 = strchr(*(const char **)(i + 32), 58);
      if ( !v27 )
        __assert_fail("p", "/home/mantovan/Repositories/libyang/src/printer_json.c", 0x73u, "json_print_attrs");
      n = (size_t)&v27[-*(_QWORD *)(i + 32)];
      if ( strncmp(
             *(const char **)(i + 32),
             *(const char **)(*(_QWORD *)(*(_QWORD *)(i + 16) + 48LL) + 8LL),
             (size_t)&v27[-*(_QWORD *)(i + 32)])
        || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(i + 16) + 48LL) + 8LL) + n) )
      {
        sub_102CD8(a1, *(_QWORD *)(i + 32));
      }
      else
      {
        sub_102CD8(a1, (__int64)(v27 + 1));
      }
LABEL_28:
      if ( a2 )
        v19 = "\n";
      else
        v19 = (const char *)&unk_1293DF;
      if ( *(_QWORD *)(i + 8) )
        v20 = ",";
      else
        v20 = (const char *)&unk_1293DF;
      sub_C1FF7(a1, "%s%s", (__int64)v20, (__int64)v19, v15, v16);
      goto LABEL_35;
    default:
      sub_12222(
        **(_QWORD **)(*v25 + 48LL),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_json.c",
        132LL);
      result = 1LL;
      break;
  }
  return result;
}
// 7950: using guessed type __int64 __fastcall lys_main_module(_QWORD);
// 12941A: using guessed type void *__ptr32 off_12941A;

//----- (00000000001031F1) ----------------------------------------------------
signed __int64 __fastcall sub_1031F1(__int64 a1, const char *a2, _QWORD **a3, int a4, unsigned int a5, unsigned int a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  const char *v10; // rax
  const char *v11; // rax
  const char *v12; // rax
  const char *v14; // rcx
  const char *v15; // rdx
  const char *v16; // rax
  const char *v17; // rcx
  const char *v18; // rdx
  const char *v19; // rax
  int v20; // eax
  __int64 v21; // r8
  __int64 v22; // r9
  int *v23; // rax
  char *v24; // rax
  __int64 v25; // r9
  unsigned __int64 v26; // [rsp+0h] [rbp-70h]
  _QWORD **v27; // [rsp+8h] [rbp-68h]
  int v28; // [rsp+10h] [rbp-60h]
  int v29; // [rsp+14h] [rbp-5Ch]
  unsigned int v30; // [rsp+2Ch] [rbp-44h]
  _QWORD *i; // [rsp+30h] [rbp-40h]
  __int64 v32; // [rsp+38h] [rbp-38h]
  __int64 v33; // [rsp+40h] [rbp-30h]
  _QWORD **v34; // [rsp+48h] [rbp-28h]
  unsigned int *v35; // [rsp+50h] [rbp-20h]
  char *v36; // [rsp+58h] [rbp-18h]
  size_t n; // [rsp+60h] [rbp-10h]
  char *s2; // [rsp+68h] [rbp-8h]

  v29 = (signed int)a2;
  v27 = a3;
  v28 = a4;
  v26 = __PAIR__(a5, a6);
  v34 = a3;
  v32 = 0LL;
  v33 = 0LL;
  *__errno_location() = 0;
  if ( *((_BYTE *)v27 + 9) & 1 && v26 & 0xC0
    || !(*((_BYTE *)v27 + 9) & 1) && v26 & 0x40 && (unsigned int)lyd_wd_default(v34) )
  {
    a2 = "ietf-netconf-with-defaults";
    v33 = ly_ctx_get_module(*(_QWORD *)(*v27)[6], "ietf-netconf-with-defaults", 0LL, 1LL);
  }
  if ( !v28 )
  {
    if ( HIDWORD(v26) || !v27[5] || (unsigned int)sub_C1FAD(v27, v27[5]) )
    {
      v32 = *(_QWORD *)(lys_node_module(*v27) + 8);
      if ( v29 )
        v10 = " ";
      else
        v10 = (const char *)&unk_1293DF;
      a2 = "%*s\"%s:%s\":%s";
      sub_C1FF7(a1, "%*s\"%s:%s\":%s", (unsigned int)(2 * v29), (__int64)&unk_1293DF, v32, **v27, v10);
    }
    else
    {
      if ( v29 )
        v11 = " ";
      else
        v11 = (const char *)&unk_1293DF;
      a2 = "%*s\"%s\":%s";
      sub_C1FF7(a1, "%*s\"%s\":%s", (unsigned int)(2 * v29), (__int64)&unk_1293DF, **v27, (__int64)v11, v26);
    }
  }
  v30 = *((_DWORD *)v34 + 18);
  while ( 2 )
  {
    switch ( (unsigned __int64)v30 )
    {
      case 1uLL:
      case 2uLL:
      case 4uLL:
      case 6uLL:
      case 8uLL:
      case 0xAuLL:
      case 0xBuLL:
      case 0x12uLL:
      case 0x13uLL:
        sub_102CD8(a1, (__int64)v34[7]);
        goto LABEL_43;
      case 3uLL:
      case 0xCuLL:
      case 0xDuLL:
      case 0xEuLL:
      case 0xFuLL:
      case 0x10uLL:
      case 0x11uLL:
        if ( *(_BYTE *)v34[7] )
          v12 = (const char *)v34[7];
        else
          v12 = "null";
        sub_C1FF7(a1, (const char *)&off_12941A, (__int64)v12, a1, v8, v9, v26);
        goto LABEL_43;
      case 5uLL:
        sub_C1FF7(a1, "[null]", v6, v7, v8, v9, v26);
        goto LABEL_43;
      case 7uLL:
        v36 = strchr((const char *)v34[7], 58);
        if ( !v36 )
          __assert_fail("p", "/home/mantovan/Repositories/libyang/src/printer_json.c", 0xC6u, "json_print_leaf");
        n = v36 - (char *)v34[7];
        s2 = *(char **)((*v34)[6] + 8LL);
        if ( strncmp((const char *)v34[7], s2, n) || s2[n] )
          sub_102CD8(a1, (__int64)v34[7]);
        else
          sub_102CD8(a1, (__int64)(v36 + 1));
LABEL_43:
        if ( v28 || !v27[2] && !v33 )
          goto LABEL_73;
        if ( v32 )
        {
          if ( v29 )
            v14 = "\n";
          else
            v14 = (const char *)&unk_1293DF;
          if ( v29 )
            v15 = " ";
          else
            v15 = (const char *)&unk_1293DF;
          if ( v29 )
            v16 = "\n";
          else
            v16 = (const char *)&unk_1293DF;
          sub_C1FF7(
            a1,
            ",%s%*s\"@%s:%s\":%s{%s",
            (__int64)v16,
            (unsigned int)(2 * v29),
            (__int64)&unk_1293DF,
            v32,
            **v27,
            v15,
            v14);
        }
        else
        {
          if ( v29 )
            v17 = "\n";
          else
            v17 = (const char *)&unk_1293DF;
          if ( v29 )
            v18 = " ";
          else
            v18 = (const char *)&unk_1293DF;
          if ( v29 )
            v19 = "\n";
          else
            v19 = (const char *)&unk_1293DF;
          sub_C1FF7(
            a1,
            ",%s%*s\"@%s\":%s{%s",
            (__int64)v19,
            (unsigned int)(2 * v29),
            (__int64)&unk_1293DF,
            **v27,
            v18,
            v17);
        }
        if ( v29 )
          v20 = v29 + 1;
        else
          v20 = 0;
        if ( (unsigned int)sub_102E00(a1, v20, v27, v33) )
          return 1LL;
        sub_C1FF7(a1, "%*s}", (unsigned int)(2 * v29), (__int64)&unk_1293DF, v21, v22, v26);
LABEL_73:
        if ( !*__errno_location() )
          return 0LL;
        v23 = __errno_location();
        v24 = strerror(*v23);
        sub_12222(*(_QWORD *)(*v27)[6], 0, 2, "Print error (%s).", (__int64)v24, v25, v26);
        return 1LL;
      case 9uLL:
        for ( i = v34[8]; i && *((_DWORD *)i + 18) == 9; i = (_QWORD *)i[8] )
          ;
        if ( i )
        {
          v30 = *((_DWORD *)i + 18);
          continue;
        }
        v35 = (unsigned int *)lyd_leaf_type(v34, a2);
        if ( v35 )
        {
          v30 = *v35;
          continue;
        }
        return 1LL;
      default:
        sub_12222(
          *(_QWORD *)(*v27)[6],
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/printer_json.c",
          233LL,
          v26);
        return 1LL;
    }
  }
}
// 7210: using guessed type __int64 __fastcall lyd_leaf_type(_QWORD, _QWORD);
// 7330: using guessed type __int64 __fastcall ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 79C0: using guessed type __int64 __fastcall lyd_wd_default(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12941A: using guessed type void *__ptr32 off_12941A;

//----- (00000000001037A1) ----------------------------------------------------
signed __int64 __fastcall sub_1037A1(__int64 a1, unsigned int a2, __int64 **a3, int a4, unsigned int a5)
{
  int v5; // ST20_4
  const char *v6; // rdx
  const char *v7; // rax
  const char *v8; // rax
  const char *v9; // rdx
  const char *v10; // rdx
  const char *v11; // rax
  int v12; // eax
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  const char *v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  int *v21; // rax
  char *v22; // rax
  __int64 v23; // r9
  unsigned int v24; // [rsp+4h] [rbp-2Ch]
  __int64 **v25; // [rsp+8h] [rbp-28h]
  unsigned int v26; // [rsp+14h] [rbp-1Ch]
  __int64 v27; // [rsp+28h] [rbp-8h]

  v26 = a2;
  v25 = a3;
  v5 = a4;
  v24 = a5;
  *__errno_location() = 0;
  if ( v5 || !v25[5] || (unsigned int)sub_C1FAD(v25, v25[5]) )
  {
    v27 = *(_QWORD *)(lys_node_module(*v25) + 8);
    if ( a2 )
      v6 = "\n";
    else
      v6 = (const char *)&unk_1293DF;
    if ( a2 )
      v7 = " ";
    else
      v7 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%*s\"%s:%s\":%s{%s", 2 * a2, (__int64)&unk_1293DF, v27, **v25, v7, v6);
  }
  else
  {
    if ( a2 )
      v8 = "\n";
    else
      v8 = (const char *)&unk_1293DF;
    if ( a2 )
      v9 = " ";
    else
      v9 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%*s\"%s\":%s{%s", 2 * a2, (__int64)&unk_1293DF, **v25, (__int64)v9, v8);
  }
  if ( a2 )
    v26 = a2 + 1;
  if ( v25[2] )
  {
    if ( v26 )
      v10 = "\n";
    else
      v10 = (const char *)&unk_1293DF;
    if ( v26 )
      v11 = " ";
    else
      v11 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%*s\"@\":%s{%s", 2 * v26, (__int64)&unk_1293DF, (__int64)v11, (__int64)v10);
    if ( v26 )
      v12 = v26 + 1;
    else
      v12 = 0;
    if ( (unsigned int)sub_102E00(a1, v12, v25, 0LL) )
      return 1LL;
    sub_C1FF7(a1, "%*s}", 2 * v26, (__int64)&unk_1293DF, v13, v14);
    if ( v25[8] )
    {
      if ( v26 )
        v18 = "\n";
      else
        v18 = (const char *)&unk_1293DF;
      sub_C1FF7(a1, ",%s", (__int64)v18, a1, v16, v17);
    }
  }
  if ( (unsigned int)sub_104827(a1, v26, v25[8], 1, 0, v24) )
    return 1LL;
  if ( v26 )
    --v26;
  sub_C1FF7(a1, "%*s}", 2 * v26, (__int64)&unk_1293DF, v19, v20);
  if ( !*__errno_location() )
    return 0LL;
  v21 = __errno_location();
  v22 = strerror(*v21);
  sub_12222(*(_QWORD *)(*v25)[6], 0, 2, "Print error (%s).", (__int64)v22, v23);
  return 1LL;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000103AA8) ----------------------------------------------------
signed __int64 __fastcall sub_103AA8(__int64 a1, unsigned int a2, __int64 **a3, int a4, unsigned int a5, unsigned int a6)
{
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  const char *v10; // rax
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  const char *v15; // rax
  const char *v16; // rdx
  const char *v17; // rax
  int v18; // eax
  __int64 v19; // r8
  __int64 v20; // r9
  const char *v22; // rax
  __int64 v23; // r8
  __int64 v24; // r9
  const char *v25; // rax
  const char *v26; // rax
  const char *v27; // rcx
  const char *v28; // rdx
  const char *v29; // rax
  __int64 v30; // r8
  __int64 v31; // r9
  const char *v32; // rcx
  const char *v33; // rdx
  const char *v34; // rax
  const char *v35; // rax
  __int64 v36; // r8
  __int64 v37; // r9
  const char *v38; // rax
  const char *v39; // rax
  int *v40; // rax
  char *v41; // rax
  __int64 v42; // r9
  unsigned __int64 v43; // [rsp+0h] [rbp-40h]
  unsigned int v44; // [rsp+0h] [rbp-40h]
  unsigned int v45; // [rsp+4h] [rbp-3Ch]
  __int64 **v46; // [rsp+8h] [rbp-38h]
  int v47; // [rsp+10h] [rbp-30h]
  unsigned int v48; // [rsp+14h] [rbp-2Ch]
  signed int v49; // [rsp+28h] [rbp-18h]
  signed int v50; // [rsp+2Ch] [rbp-14h]
  __int64 v51; // [rsp+30h] [rbp-10h]
  __int64 **i; // [rsp+38h] [rbp-8h]
  __int64 **j; // [rsp+38h] [rbp-8h]

  v48 = a2;
  v46 = a3;
  v47 = a4;
  v43 = __PAIR__(a5, a6);
  v51 = 0LL;
  i = a3;
  v49 = 0;
  v50 = 0;
  *__errno_location() = 0;
  if ( v47 && !i[8] )
    v49 = 1;
  if ( HIDWORD(v43) || !v46[5] || (unsigned int)sub_C1FAD(v46, v46[5]) )
  {
    v7 = lys_node_module(*v46);
    v51 = *(_QWORD *)(v7 + 8);
    sub_C1FF7(a1, "%*s\"%s:%s\":", 2 * a2, (__int64)&unk_1293DF, *(_QWORD *)(v7 + 8), **v46, v43);
  }
  else
  {
    sub_C1FF7(a1, "%*s\"%s\":", 2 * a2, (__int64)&unk_1293DF, **v46, v6, v43);
  }
  if ( v49 )
  {
    if ( a2 )
      v10 = " ";
    else
      v10 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%snull", (__int64)v10, a1, v8, v9);
  }
  else
  {
    if ( a2 )
      v11 = "\n";
    else
      v11 = (const char *)&unk_1293DF;
    if ( a2 )
      v12 = " ";
    else
      v12 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%s[%s", (__int64)v12, (__int64)v11, v8, v9);
    if ( !v47 && a2 )
      v48 = a2 + 1;
    while ( i )
    {
      if ( v47 )
      {
        if ( v48 )
          ++v48;
        if ( v48 )
          v15 = "\n";
        else
          v15 = (const char *)&unk_1293DF;
        sub_C1FF7(a1, "%*s{%s", 2 * v48, (__int64)&unk_1293DF, (__int64)v15, v14);
        if ( v48 )
          ++v48;
        if ( i[2] )
        {
          if ( v48 )
            v16 = "\n";
          else
            v16 = (const char *)&unk_1293DF;
          if ( v48 )
            v17 = " ";
          else
            v17 = (const char *)&unk_1293DF;
          sub_C1FF7(a1, "%*s\"@\":%s{%s", 2 * v48, (__int64)&unk_1293DF, (__int64)v17, (__int64)v16);
          if ( v48 )
            v18 = v48 + 1;
          else
            v18 = 0;
          if ( (unsigned int)sub_102E00(a1, v18, i, 0LL) )
            return 1LL;
          if ( i[8] )
          {
            if ( v48 )
              v22 = "\n";
            else
              v22 = (const char *)&unk_1293DF;
            sub_C1FF7(a1, "%*s},%s", 2 * v48, (__int64)&unk_1293DF, (__int64)v22, v20);
          }
          else
          {
            sub_C1FF7(a1, "%*s}", 2 * v48, (__int64)&unk_1293DF, v19, v20);
          }
        }
        if ( (unsigned int)sub_104827(a1, v48, i[8], 1, 0, v44) )
          return 1LL;
        if ( v48 )
          --v48;
        sub_C1FF7(a1, "%*s}", 2 * v48, (__int64)&unk_1293DF, v23, v24);
        if ( v48 )
          --v48;
      }
      else
      {
        sub_C1FF7(a1, "%*s", 2 * v48, (__int64)&unk_1293DF, v13, v14);
        if ( (unsigned int)sub_1031F1(a1, (const char *)v48, i, 1, v45, v44) )
          return 1LL;
        if ( i[2] )
          v50 = 1;
      }
      if ( v45 && !(v44 & 1) )
        break;
      for ( i = (__int64 **)i[3]; i && *i != *v46; i = (__int64 **)i[3] )
        ;
      if ( i )
      {
        if ( v48 )
          v25 = "\n";
        else
          v25 = (const char *)&unk_1293DF;
        sub_C1FF7(a1, ",%s", (__int64)v25, a1, v13, v14);
      }
    }
    if ( !v47 && v48 )
      --v48;
    if ( v48 )
      v26 = "\n";
    else
      v26 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%s%*s]", (__int64)v26, 2 * v48, (__int64)&unk_1293DF, v14);
    if ( !v47 && v50 )
    {
      if ( v51 )
      {
        if ( v48 )
          v27 = "\n";
        else
          v27 = (const char *)&unk_1293DF;
        if ( v48 )
          v28 = " ";
        else
          v28 = (const char *)&unk_1293DF;
        if ( v48 )
          v29 = "\n";
        else
          v29 = (const char *)&unk_1293DF;
        sub_C1FF7(a1, ",%s%*s\"@%s:%s\":%s[%s", (__int64)v29, 2 * v48, (__int64)&unk_1293DF, v51, **v46, v28, v27);
      }
      else
      {
        if ( v48 )
          v32 = "\n";
        else
          v32 = (const char *)&unk_1293DF;
        if ( v48 )
          v33 = " ";
        else
          v33 = (const char *)&unk_1293DF;
        if ( v48 )
          v34 = "\n";
        else
          v34 = (const char *)&unk_1293DF;
        sub_C1FF7(a1, ",%s%*s\"@%s\":%s[%s", (__int64)v34, 2 * v48, (__int64)&unk_1293DF, **v46, v33, v32);
      }
      if ( v48 )
        ++v48;
      j = v46;
      while ( j )
      {
        if ( j[2] )
        {
          if ( v48 )
            v35 = " ";
          else
            v35 = (const char *)&unk_1293DF;
          sub_C1FF7(a1, "%*s{%s", 2 * v48, (__int64)&unk_1293DF, (__int64)v35, v31);
          if ( (unsigned int)sub_102E00(a1, 0, j, 0LL) )
            return 1LL;
          sub_C1FF7(a1, "%*s}", 2 * v48, (__int64)&unk_1293DF, v36, v37);
        }
        else
        {
          sub_C1FF7(a1, "%*snull", 2 * v48, (__int64)&unk_1293DF, v30, v31);
        }
        for ( j = (__int64 **)j[3]; j && *j != *v46; j = (__int64 **)j[3] )
          ;
        if ( j )
        {
          if ( v48 )
            v38 = "\n";
          else
            v38 = (const char *)&unk_1293DF;
          sub_C1FF7(a1, ",%s", (__int64)v38, a1, v30, v31);
        }
      }
      if ( v48 )
        --v48;
      if ( v48 )
        v39 = "\n";
      else
        v39 = (const char *)&unk_1293DF;
      sub_C1FF7(a1, "%s%*s]", (__int64)v39, 2 * v48, (__int64)&unk_1293DF, v31);
    }
  }
  if ( !*__errno_location() )
    return 0LL;
  v40 = __errno_location();
  v41 = strerror(*v40);
  sub_12222(*(_QWORD *)(*v46)[6], 0, 2, "Print error (%s).", (__int64)v41, v42);
  return 1LL;
}
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000104282) ----------------------------------------------------
signed __int64 __fastcall sub_104282(__int64 a1, unsigned int a2, __int64 a3, int a4, int a5)
{
  int v5; // ST30_4
  __int64 v6; // r9
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // rdx
  const char *v12; // rax
  __int64 v14; // rbx
  signed __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  const char *v20; // rcx
  const char *v21; // rdx
  const char *v22; // rax
  const char *v23; // rcx
  const char *v24; // rdx
  const char *v25; // rax
  int v26; // eax
  __int64 v27; // r8
  __int64 v28; // r9
  int *v29; // rax
  char *v30; // rax
  __int64 v31; // r9
  int v32; // [rsp+4h] [rbp-5Ch]
  __int64 **v33; // [rsp+8h] [rbp-58h]
  unsigned int v34; // [rsp+14h] [rbp-4Ch]
  signed int v35; // [rsp+2Ch] [rbp-34h]
  void *ptr; // [rsp+30h] [rbp-30h]
  __int64 v37; // [rsp+38h] [rbp-28h]
  __int64 v38; // [rsp+40h] [rbp-20h]
  unsigned __int64 v39; // [rsp+48h] [rbp-18h]

  v34 = a2;
  v33 = (__int64 **)a3;
  v5 = a4;
  v32 = a5;
  v39 = __readfsqword(0x28u);
  v38 = a3;
  v35 = 0;
  v37 = 0LL;
  *__errno_location() = 0;
  if ( v5 || !v33[5] || (unsigned int)sub_C1FAD(v33, v33[5]) )
  {
    v37 = *(_QWORD *)(lys_node_module(*v33) + 8);
    sub_C1FF7(a1, "%*s\"%s:%s\":", 2 * a2, (__int64)&unk_1293DF, v37, **v33);
  }
  else
  {
    sub_C1FF7(a1, "%*s\"%s\":", 2 * a2, (__int64)&unk_1293DF, **v33, v6);
  }
  if ( a2 )
    v34 = a2 + 1;
  switch ( *(_DWORD *)(v38 + 52) )
  {
    case 0:
    case 4:
      if ( v34 )
        sub_C1FF7(a1, " ", v7, v8, v9, v10);
      if ( *(_QWORD *)(v38 + 56) )
        sub_102CD8(a1, *(_QWORD *)(v38 + 56));
      else
        sub_C1FF7(a1, "\"\"", v7, v8, v9, v10);
      goto LABEL_37;
    case 1:
    case 3:
    case 5:
    case 0x20:
    case 0x21:
      sub_12222(
        *(_QWORD *)(*v33)[6],
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_json.c",
        489LL);
      return 1LL;
    case 2:
      if ( v34 )
        sub_C1FF7(a1, "\n", v7, v8, v9, v10);
      if ( *(_QWORD *)(v38 + 56) )
        sub_C1FF7(a1, (const char *)&off_12941A, *(_QWORD *)(v38 + 56), v8, v9, v10);
      if ( v34 )
      {
        if ( !*(_QWORD *)(v38 + 56)
          || (v14 = *(_QWORD *)(v38 + 56), *(_BYTE *)(v14 + strlen(*(const char **)(v38 + 56)) - 1) != 10) )
        {
          sub_C1FF7(a1, "\n", v7, v8, v9, v10);
        }
      }
      goto LABEL_37;
    case 8:
      if ( v34 )
        v15 = 50LL;
      else
        v15 = 16LL;
      lyxml_print_mem(&ptr, *(_QWORD *)(v38 + 56), v15);
      if ( v34 )
        sub_C1FF7(a1, " ", v16, v17, v18, v19);
      sub_102CD8(a1, (__int64)ptr);
      free(ptr);
      goto LABEL_37;
    case 0x10:
      v35 = 1;
      if ( v34 )
        v11 = "\n";
      else
        v11 = (const char *)&unk_1293DF;
      if ( v34 )
        v12 = " ";
      else
        v12 = (const char *)&unk_1293DF;
      sub_C1FF7(a1, "%s{%s", (__int64)v12, (__int64)v11, v9, v10);
      if ( !(unsigned int)sub_104827(a1, v34, *(__int64 **)(v38 + 56), 1, 0, v32 & 0xFFFFFEFE | 1) )
        goto LABEL_37;
      return 1LL;
    default:
LABEL_37:
      if ( !v33[2] )
        goto LABEL_65;
      if ( v37 )
      {
        if ( v34 )
          v20 = "\n";
        else
          v20 = (const char *)&unk_1293DF;
        if ( v34 )
          v21 = " ";
        else
          v21 = (const char *)&unk_1293DF;
        if ( v34 )
          v22 = "\n";
        else
          v22 = (const char *)&unk_1293DF;
        sub_C1FF7(a1, ",%s%*s\"@%s:%s\":%s{%s", (__int64)v22, 2 * v34, (__int64)&unk_1293DF, v37, **v33, v21, v20);
      }
      else
      {
        if ( v34 )
          v23 = "\n";
        else
          v23 = (const char *)&unk_1293DF;
        if ( v34 )
          v24 = " ";
        else
          v24 = (const char *)&unk_1293DF;
        if ( v34 )
          v25 = "\n";
        else
          v25 = (const char *)&unk_1293DF;
        sub_C1FF7(a1, ",%s%*s\"@%s\":%s{%s", (__int64)v25, 2 * v34, (__int64)&unk_1293DF, **v33, v24, v23);
      }
      if ( v34 )
        v26 = v34 + 1;
      else
        v26 = 0;
      if ( (unsigned int)sub_102E00(a1, v26, v33, 0LL) )
        return 1LL;
      sub_C1FF7(a1, "%*s}", 2 * v34, (__int64)&unk_1293DF, v27, v28);
LABEL_65:
      if ( v34 )
        --v34;
      if ( v35 )
        sub_C1FF7(a1, "%*s}", 2 * v34, (__int64)&unk_1293DF, v9, v10);
      if ( !*__errno_location() )
        return 0LL;
      v29 = __errno_location();
      v30 = strerror(*v29);
      sub_12222(*(_QWORD *)(*v33)[6], 0, 2, "Print error (%s).", (__int64)v30, v31);
      return 1LL;
  }
}
// 7990: using guessed type __int64 __fastcall lyxml_print_mem(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);
// 12941A: using guessed type void *__ptr32 off_12941A;

//----- (0000000000104827) ----------------------------------------------------
signed __int64 __fastcall sub_104827(__int64 a1, unsigned int a2, __int64 *a3, int a4, unsigned int a5, unsigned int a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // eax
  const char *v11; // rax
  const char *v13; // rax
  const char *v14; // rax
  const char *v15; // rax
  int *v16; // rax
  char *v17; // rdx
  __int64 v18; // r9
  __int64 v19; // rax
  unsigned __int64 v20; // [rsp+0h] [rbp-40h]
  __int64 *v21; // [rsp+8h] [rbp-38h]
  int v22; // [rsp+10h] [rbp-30h]
  signed int v23; // [rsp+2Ch] [rbp-14h]
  __int64 *i; // [rsp+30h] [rbp-10h]
  __int64 *j; // [rsp+38h] [rbp-8h]

  v21 = a3;
  v22 = a4;
  v20 = __PAIR__(a5, a6);
  v23 = 0;
  *__errno_location() = 0;
  for ( i = v21; i; i = (__int64 *)i[3] )
  {
    if ( !(unsigned int)sub_C46A7(i, v20) )
      continue;
    v10 = *(_DWORD *)(*i + 56);
    if ( v10 == 32 )
      goto LABEL_48;
    if ( v10 > 0x20 )
    {
      if ( v10 != 256 )
      {
        if ( v10 > 0x100 )
        {
          if ( v10 != 0x4000 )
          {
            if ( v10 != 32800 )
              goto LABEL_55;
LABEL_48:
            if ( v23 )
            {
              if ( a2 )
                v15 = "\n";
              else
                v15 = (const char *)&unk_1293DF;
              sub_C1FF7(a1, ",%s", (__int64)v15, a1, v8, v9, v20);
            }
            if ( (unsigned int)sub_104282(a1, a2, (__int64)i, SHIDWORD(v20), v20) )
              return 1LL;
            goto LABEL_56;
          }
        }
        else if ( v10 != 128 )
        {
          goto LABEL_55;
        }
      }
    }
    else
    {
      if ( v10 == 4 )
      {
        if ( v23 )
        {
          if ( a2 )
            v13 = "\n";
          else
            v13 = (const char *)&unk_1293DF;
          sub_C1FF7(a1, ",%s", (__int64)v13, a1, v8, v9, v20);
        }
        if ( (unsigned int)sub_1031F1(a1, (const char *)a2, (_QWORD **)i, 0, HIDWORD(v20), v20) )
          return 1LL;
        goto LABEL_56;
      }
      if ( v10 > 4 )
      {
        if ( v10 != 8 && v10 != 16 )
        {
LABEL_55:
          sub_12222(
            **(_QWORD **)(*i + 48),
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/printer_json.c",
            589LL,
            v20);
          return 1LL;
        }
        for ( j = (__int64 *)i[4]; j[3]; j = (__int64 *)j[4] )
        {
          if ( i == v21 )
            break;
          if ( j != i )
          {
            v6 = *j;
            if ( *j == *i )
              break;
          }
        }
        if ( !j[3] || i == v21 )
        {
          if ( v23 )
          {
            if ( a2 )
              v14 = "\n";
            else
              v14 = (const char *)&unk_1293DF;
            sub_C1FF7(a1, ",%s", (__int64)v14, a1, v8, v9, v20);
          }
          if ( (unsigned int)sub_103AA8(a1, a2, (__int64 **)i, *(_DWORD *)(*i + 56) == 16, HIDWORD(v20), v20) )
            return 1LL;
        }
        goto LABEL_56;
      }
      if ( v10 != 1 )
        goto LABEL_55;
    }
    if ( v23 )
    {
      if ( a2 )
        v11 = "\n";
      else
        v11 = (const char *)&unk_1293DF;
      sub_C1FF7(a1, ",%s", (__int64)v11, a1, v8, v9, v20);
    }
    if ( (unsigned int)sub_1037A1(a1, a2, (__int64 **)i, SHIDWORD(v20), v20) )
      return 1LL;
LABEL_56:
    if ( !v22 )
      break;
    v23 = 1;
  }
  if ( v21 && a2 )
    sub_C1FF7(a1, "\n", v6, v7, v8, v9, v20);
  if ( !*__errno_location() )
    return 0LL;
  v16 = __errno_location();
  v17 = strerror(*v16);
  if ( v21 )
    v19 = **(_QWORD **)(*v21 + 48);
  else
    v19 = 0LL;
  sub_12222(v19, 0, 2, "Print error (%s).", (__int64)v17, v18, v20);
  return 1LL;
}

//----- (0000000000104C16) ----------------------------------------------------
signed __int64 __fastcall sub_104C16(__int64 a1, __int64 *a2, unsigned int a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  const char *v5; // rax
  char *v6; // rdx
  char *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  const char *v11; // rax
  const char *v12; // rax
  int *v13; // rax
  char *v14; // rax
  __int64 v15; // r9
  unsigned int v16; // [rsp+Ch] [rbp-34h]
  __int64 *v17; // [rsp+10h] [rbp-30h]
  unsigned int v18; // [rsp+28h] [rbp-18h]
  signed int v19; // [rsp+2Ch] [rbp-14h]
  __int64 *i; // [rsp+30h] [rbp-10h]
  __int64 *v21; // [rsp+38h] [rbp-8h]

  v17 = a2;
  v16 = a3;
  v18 = 0;
  v19 = 0;
  *__errno_location() = 0;
  if ( v16 & 2 )
    v18 = 1;
  if ( v16 & 0x100 )
  {
    if ( *(_DWORD *)(*a2 + 56) == 256 )
    {
      i = a2;
    }
    else
    {
      for ( i = a2; i && *(_DWORD *)(*i + 56) != 0x4000; i = v21 )
      {
        if ( *(_DWORD *)(*i + 56) & 0x802C )
          v21 = 0LL;
        else
          v21 = (__int64 *)i[8];
        if ( !v21 )
        {
          if ( i == a2 )
            break;
          v21 = (__int64 *)i[3];
        }
        while ( !v21 )
        {
          i = (__int64 *)i[5];
          if ( i[5] == a2[5] )
            break;
          v21 = (__int64 *)i[3];
        }
      }
    }
    if ( i && *(_DWORD *)(*i + 56) & 0x4100 )
    {
      if ( i[8] && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)i[8] + 64LL) + 56LL) == 1024 )
      {
        v17 = (__int64 *)i[8];
      }
      else if ( *(_DWORD *)(*i + 56) == 0x4000 )
      {
        v19 = 1;
      }
    }
  }
  if ( v18 )
    v5 = "\n";
  else
    v5 = (const char *)&unk_1293DF;
  sub_C1FF7(a1, (const char *)&unk_1296A8, (__int64)v5, a1, v3, v4);
  if ( v19 )
  {
    v6 = v18 ? "\n" : &unk_1293DF;
    v7 = v18 ? " " : &unk_1293DF;
    sub_C1FF7(a1, "%*s\"yang:action\":%s{%s", 2 * v18, (__int64)&unk_1293DF, (__int64)v7, (__int64)v6);
    if ( v18 )
      ++v18;
  }
  if ( (unsigned int)sub_104827(a1, v18, v17, v16 & 1, 1u, v16) )
    return 1LL;
  if ( v19 )
  {
    if ( v18 )
      --v18;
    if ( v18 )
      v11 = "\n";
    else
      v11 = (const char *)&unk_1293DF;
    sub_C1FF7(a1, "%*s}%s", 2 * v18, (__int64)&unk_1293DF, (__int64)v11, v9);
  }
  if ( v18 )
    v12 = "\n";
  else
    v12 = (const char *)&unk_1293DF;
  sub_C1FF7(a1, "}%s", (__int64)v12, a1, v8, v9);
  sub_C236C(a1);
  if ( !*__errno_location() )
    return 0LL;
  v13 = __errno_location();
  v14 = strerror(*v13);
  sub_12222(0LL, 0, 2, "Print error (%s).", (__int64)v14, v15);
  return 1LL;
}

//----- (0000000000104F44) ----------------------------------------------------
__int64 __fastcall sub_104F44(__int64 a1)
{
  return a1;
}

//----- (0000000000104F52) ----------------------------------------------------
signed __int64 sub_104F52()
{
  return 1LL;
}

//----- (0000000000104F6C) ----------------------------------------------------
_BOOL8 __fastcall sub_104F6C(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

//----- (0000000000104FAD) ----------------------------------------------------
signed __int64 __fastcall sub_104FAD(__int64 a1, const char **a2, unsigned __int8 a3, int a4)
{
  unsigned __int8 v4; // al
  char v6; // bl
  unsigned __int8 v7; // al
  int v8; // [rsp+8h] [rbp-48h]
  unsigned __int8 v9; // [rsp+Ch] [rbp-44h]
  const char **v10; // [rsp+10h] [rbp-40h]
  __int64 v11; // [rsp+18h] [rbp-38h]
  int i; // [rsp+2Ch] [rbp-24h]
  const char ***v13; // [rsp+30h] [rbp-20h]
  unsigned __int64 v14; // [rsp+38h] [rbp-18h]

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  v14 = __readfsqword(0x28u);
  v4 = sub_C5A1(a2, a3);
  if ( (unsigned int)sub_154F1(a1, (__int64)&v10, v4, &v13) )
    return 0LL;
  sub_14E64(v11, (__int64)sub_104F6C);
  do
  {
    for ( i = v8; i >= 0; --i )
    {
      v6 = sub_C5A1(v10, i);
      if ( v6 != (unsigned __int8)sub_C5A1(*v13, i) )
        break;
    }
    if ( i == -1 )
    {
      sub_14E64(v11, (__int64)sub_104F52);
      return 1LL;
    }
    v7 = sub_C5A1(*v13, v9);
  }
  while ( !(unsigned int)sub_15669(v11, (__int64)v13, v7, &v13) );
  sub_14E64(v11, (__int64)sub_104F52);
  return 0LL;
}

//----- (00000000001050EE) ----------------------------------------------------
signed __int64 __fastcall sub_1050EE(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rax
  __int64 v5; // [rsp+8h] [rbp-48h]
  unsigned __int8 v6; // [rsp+26h] [rbp-2Ah]
  unsigned __int8 v7; // [rsp+27h] [rbp-29h]
  signed int j; // [rsp+28h] [rbp-28h]
  int v9; // [rsp+2Ch] [rbp-24h]
  __int64 v10; // [rsp+30h] [rbp-20h]
  __int64 v11; // [rsp+38h] [rbp-18h]
  __int64 v12; // [rsp+40h] [rbp-10h]
  unsigned __int64 v13; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v13 = __readfsqword(0x28u);
  v11 = 0LL;
  v12 = 0LL;
  for ( i = lys_getnext(0LL, a2, *(_QWORD *)(a2 + 48), 0LL); ; i = lys_getnext(v10, a2, *(_QWORD *)(a2 + 48), 0LL) )
  {
    v10 = i;
    if ( !i )
      break;
    v11 = 0LL;
    while ( 1 )
    {
      v11 = lys_getnext(v11, v5, *(_QWORD *)(v5 + 48), 0LL);
      if ( !v11 )
        break;
      v9 = 0;
      for ( j = 0; j <= 7; ++j )
      {
        v6 = sub_C5A1((const char **)v10, j);
        v7 = sub_C5A1((const char **)v11, j);
        if ( !v6 || !v7 )
        {
          sub_12222(
            **(_QWORD **)(a2 + 48),
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
            120LL);
          return 0LL;
        }
        if ( v6 == v7 )
        {
          ++v9;
          v12 = sub_14E64(a1, (__int64)sub_104F6C);
          if ( !(unsigned int)sub_154F1(a1, (__int64)&v10, v6, 0LL)
            || !(unsigned int)sub_154F1(a1, (__int64)&v11, v7, 0LL) )
          {
            sub_12222(
              **(_QWORD **)(a2 + 48),
              1u,
              0,
              "Augmentations from modules \"%s\" and \"%s\" have fatal hash collision.",
              *(_QWORD *)(*(_QWORD *)(v10 + 48) + 8LL),
              *(_QWORD *)(*(_QWORD *)(v11 + 48) + 8LL));
            sub_12222(
              **(_QWORD **)(a2 + 48),
              1u,
              0,
              "It will cause no errors if module \"%s\" is always loaded before \"%s\".",
              *(_QWORD *)(*(_QWORD *)(v10 + 48) + 8LL),
              *(_QWORD *)(*(_QWORD *)(v11 + 48) + 8LL));
            sub_14E64(a1, v12);
            return 1LL;
          }
          sub_14E64(a1, v12);
        }
      }
      if ( v9 == 8 )
      {
        sub_12222(
          **(_QWORD **)(a2 + 48),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
          137LL);
        return 1LL;
      }
    }
  }
  return 0LL;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000001053BB) ----------------------------------------------------
void __fastcall sub_1053BB(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  __int64 v3; // rbx
  __int64 v4; // r9
  signed int v5; // [rsp+1Ch] [rbp-44h]
  int v6; // [rsp+20h] [rbp-40h]
  int i; // [rsp+24h] [rbp-3Ch]
  int j; // [rsp+24h] [rbp-3Ch]
  int k; // [rsp+28h] [rbp-38h]
  signed int v10; // [rsp+2Ch] [rbp-34h]
  __int64 v11; // [rsp+30h] [rbp-30h]
  _QWORD *ptr; // [rsp+38h] [rbp-28h]
  __int64 *v13; // [rsp+40h] [rbp-20h]
  _QWORD *v14; // [rsp+48h] [rbp-18h]

  v11 = 0LL;
  v5 = 1;
  v6 = 0;
  if ( !a1 )
    __assert_fail("parent", "/home/mantovan/Repositories/libyang/src/printer_lyb.c", 0x99u, "lyb_check_augments");
  v13 = (__int64 *)lys_node_module(a1);
  ptr = malloc(8uLL);
  if ( ptr )
  {
    while ( 1 )
    {
      v11 = lys_getnext(v11, a1, 0LL, 0LL);
      if ( !v11 )
        break;
      if ( *(_DWORD *)(*(_QWORD *)(v11 + 64) + 56LL) == 0x2000
        && v13 != (__int64 *)lys_node_module(*(_QWORD *)(v11 + 64)) )
      {
        v10 = 0;
        for ( i = 0; i < v6; ++i )
        {
          v3 = lys_node_module(ptr[i]);
          if ( v3 == lys_node_module(v11) )
          {
            v10 = 1;
            break;
          }
        }
        if ( !v10 )
        {
          if ( v5 == v6 )
          {
            v5 *= 2;
            v14 = realloc(ptr, 8LL * v5);
            if ( !v14 )
            {
              sub_12222(*v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_check_augments", v4, a2);
              free(ptr);
              return;
            }
            ptr = v14;
          }
          ptr[v6++] = v11;
        }
      }
    }
    for ( j = 0; j < v6; ++j )
    {
      for ( k = j + 1; k < v6; ++k )
      {
        if ( (unsigned int)sub_1050EE(a2, *(_QWORD *)(ptr[j] + 64LL), *(_QWORD *)(ptr[k] + 64LL)) )
        {
          free(ptr);
          return;
        }
      }
    }
    free(ptr);
  }
  else
  {
    sub_12222(*v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_check_augments", v2, a2);
  }
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (0000000000105659) ----------------------------------------------------
void **__fastcall sub_105659(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r9
  void **result; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int8 v7; // al
  __int64 v8; // r9
  unsigned __int8 v9; // al
  __int64 v10; // r8
  __int64 v11; // r9
  int v12; // [rsp+Ch] [rbp-44h]
  __int64 v13; // [rsp+18h] [rbp-38h]
  int j; // [rsp+24h] [rbp-2Ch]
  int k; // [rsp+28h] [rbp-28h]
  int v16; // [rsp+2Ch] [rbp-24h]
  __int64 i; // [rsp+30h] [rbp-20h]
  __int64 v18; // [rsp+38h] [rbp-18h]
  void **v19; // [rsp+40h] [rbp-10h]
  __int64 v20; // [rsp+48h] [rbp-8h]

  v13 = a1;
  v12 = a3;
  v16 = 0;
  v18 = 0LL;
  v19 = (void **)sub_14CB1(1u, 8, (__int64)sub_104F52, 0LL, 1);
  if ( v19 )
  {
    for ( i = lys_parent(v13); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
      ;
    v20 = lys_node_module(v13);
    v13 = 0LL;
    while ( 1 )
    {
      v13 = lys_getnext(v13, i, v20, 256LL);
      if ( !v13 )
        break;
      if ( !a2 || (unsigned int)sub_C70A(v13, a2, v12) )
      {
        if ( *(_QWORD *)(v13 + 64) )
        {
          if ( *(_DWORD *)(*(_QWORD *)(v13 + 64) + 56LL) == 0x2000 )
          {
            v5 = lys_node_module(*(_QWORD *)(v13 + 64));
            if ( v20 != v5 )
            {
              if ( v18 )
              {
                v6 = lys_node_module(*(_QWORD *)(v13 + 64));
                if ( v18 != v6 )
                  v16 = 1;
              }
              v18 = lys_node_module(v13);
            }
          }
        }
        for ( j = 0; j <= 7; ++j )
        {
          for ( k = j - 1; k >= 0 && !(unsigned int)sub_104FAD((__int64)v19, (const char **)v13, k, j); --k )
            ;
          if ( k < 0 )
          {
            v7 = sub_C5A1((const char **)v13, j);
            if ( !(unsigned int)sub_15BA6((__int64)v19, &v13, v7, (__int64)sub_104F6C, 0LL, v8) )
              break;
            if ( j && !(unsigned int)sub_104FAD((__int64)v19, (const char **)v13, j, j) )
            {
              sub_14E64((__int64)v19, (__int64)sub_104F6C);
              v9 = sub_C5A1((const char **)v13, j);
              if ( (unsigned int)sub_15F55((__int64)v19, &v13, v9, 0LL, v10, v11) )
              {
                sub_14E64((__int64)v19, (__int64)sub_104F52);
                sub_12222(
                  **(_QWORD **)(v13 + 48),
                  0,
                  4,
                  "Internal error (%s:%d).",
                  (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
                  262LL);
                sub_14F6B(v19);
                return 0LL;
              }
              sub_14E64((__int64)v19, (__int64)sub_104F52);
              break;
            }
          }
        }
        if ( j == 8 )
        {
          sub_12222(
            **(_QWORD **)(v13 + 48),
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
            274LL);
          sub_14F6B(v19);
          return 0LL;
        }
      }
    }
    if ( v16 )
      sub_1053BB(i, (__int64)v19);
    sub_14E64((__int64)v19, (__int64)sub_104F6C);
    result = v19;
  }
  else
  {
    sub_12222(**(_QWORD **)(v13 + 48), 0, 1, "Memory allocation failed (%s()).", (__int64)"lyb_hash_siblings", v3);
    result = 0LL;
  }
  return result;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000001059E6) ----------------------------------------------------
__int64 __fastcall sub_1059E6(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+0h] [rbp-20h]
  __int64 v4; // [rsp+8h] [rbp-18h]
  unsigned __int8 v5; // [rsp+1Bh] [rbp-5h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  v4 = a1;
  v3 = a2;
  for ( i = 0; i <= 7; ++i )
  {
    v5 = sub_C5A1((const char **)v3, i);
    if ( !v5 )
    {
      sub_12222(
        **(_QWORD **)(v3 + 48),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
        301LL,
        v3);
      return 0LL;
    }
    if ( !(unsigned int)sub_154F1(v4, (__int64)&v3, v5, 0LL) )
      break;
  }
  if ( i != 8 )
    return v5;
  sub_12222(
    **(_QWORD **)(v3 + 48),
    0,
    4,
    "Internal error (%s:%d).",
    (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
    312LL,
    v3);
  return 0LL;
}

//----- (0000000000105AD0) ----------------------------------------------------
signed __int64 __fastcall sub_105AD0(__int64 a1, char *a2, size_t a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-50h]
  size_t v6; // [rsp+8h] [rbp-48h]
  char *v7; // [rsp+10h] [rbp-40h]
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  signed int i; // [rsp+28h] [rbp-28h]
  int j; // [rsp+28h] [rbp-28h]
  signed int k; // [rsp+28h] [rbp-28h]
  signed int v12; // [rsp+2Ch] [rbp-24h]
  size_t v13; // [rsp+30h] [rbp-20h]
  size_t v14; // [rsp+38h] [rbp-18h]
  unsigned __int64 v15; // [rsp+38h] [rbp-18h]
  char v16; // [rsp+46h] [rbp-Ah]
  char v17; // [rsp+47h] [rbp-9h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v7 = a2;
  v6 = a3;
  v5 = a4;
  v18 = __readfsqword(0x28u);
  v8 = 0;
  if ( !a1 || !a4 )
    __assert_fail("out && lybs", "/home/mantovan/Repositories/libyang/src/printer_lyb.c", 0x147u, "lyb_write");
  while ( 1 )
  {
    v13 = v6;
    v12 = -1;
    for ( i = 0; i < *(_DWORD *)(v5 + 24); ++i )
    {
      if ( *(_QWORD *)(8LL * i + *(_QWORD *)v5) + v13 > 0xFE )
      {
        v13 = 255LL - *(_QWORD *)(8LL * i + *(_QWORD *)v5);
        v12 = i;
      }
    }
    if ( v12 == -1 && !v6 )
      break;
    if ( v13 )
    {
      v14 = (signed int)sub_C23A5(a1, v7, v13);
      if ( v14 < v13 )
        return 0xFFFFFFFFLL;
      for ( j = 0; j < *(_DWORD *)(v5 + 24); ++j )
      {
        *(_QWORD *)(8LL * j + *(_QWORD *)v5) += v14;
        if ( *(_QWORD *)(8LL * j + *(_QWORD *)v5) > 0xFFuLL )
          __assert_fail(
            "lybs->written[i] <= LYB_SIZE_MAX",
            "/home/mantovan/Repositories/libyang/src/printer_lyb.c",
            0x164u,
            "lyb_write");
      }
      v6 -= v14;
      v7 += v14;
      v8 += v14;
    }
    if ( v12 >= 0 )
    {
      v16 = *(_QWORD *)(8LL * v12 + *(_QWORD *)v5);
      v17 = *(_BYTE *)(*(_QWORD *)(v5 + 16) + v12);
      if ( (unsigned __int64)(signed int)sub_C2888(a1, *(_QWORD *)(8LL * v12 + *(_QWORD *)(v5 + 8)), &v16, 2uLL) <= 1 )
        return 0xFFFFFFFFLL;
      *(_QWORD *)(8LL * v12 + *(_QWORD *)v5) = 0LL;
      *(_BYTE *)(*(_QWORD *)(v5 + 16) + v12) = 0;
      v15 = (signed int)sub_C2676(a1, 2LL, (_QWORD *)(*(_QWORD *)(v5 + 8) + 8LL * v12));
      if ( v15 <= 1 )
        return 0xFFFFFFFFLL;
      v8 += v15;
      for ( k = 0; k < v12; ++k )
      {
        if ( *(_BYTE *)(*(_QWORD *)(v5 + 16) + k) == -1 )
        {
          sub_12222(
            *(_QWORD *)(v5 + 48),
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
            390LL,
            v5);
          return 0xFFFFFFFFLL;
        }
        ++*(_BYTE *)(*(_QWORD *)(v5 + 16) + k);
      }
    }
  }
  return v8;
}

//----- (0000000000105E36) ----------------------------------------------------
signed __int64 __fastcall sub_105E36(__int64 a1, __int64 a2)
{
  char v3; // [rsp+16h] [rbp-Ah]
  char v4; // [rsp+17h] [rbp-9h]
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v3 = *(_QWORD *)(*(_QWORD *)a2 + 8LL * *(signed int *)(a2 + 24) - 8);
  v4 = *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(signed int *)(a2 + 24) - 1LL);
  if ( (signed int)sub_C2888(a1, *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8LL * *(signed int *)(a2 + 24) - 8), &v3, 2uLL) <= 1 )
    return 0xFFFFFFFFLL;
  --*(_DWORD *)(a2 + 24);
  return 0LL;
}

//----- (0000000000105F04) ----------------------------------------------------
signed __int64 __fastcall sub_105F04(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 28)
    || (*(_DWORD *)(a2 + 28) += 4,
        *(_QWORD *)a2 = sub_C422(*(void **)a2, 8LL * *(signed int *)(a2 + 28)),
        *(_QWORD *)(a2 + 8) = sub_C422(*(void **)(a2 + 8), 8LL * *(signed int *)(a2 + 28)),
        *(_QWORD *)(a2 + 16) = sub_C422(*(void **)(a2 + 16), *(signed int *)(a2 + 28)),
        *(_QWORD *)a2)
    && *(_QWORD *)(a2 + 8)
    && *(_QWORD *)(a2 + 16) )
  {
    *(_QWORD *)(*(_QWORD *)a2 + 8LL * (signed int)++*(_DWORD *)(a2 + 24) - 8) = 0LL;
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(signed int *)(a2 + 24) - 1LL) = 0;
    for ( i = 0; i < *(_DWORD *)(a2 + 24) - 1; ++i )
    {
      if ( *(_BYTE *)(*(_QWORD *)(a2 + 16) + i) == -1 )
      {
        sub_12222(
          *(_QWORD *)(a2 + 48),
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
          440LL,
          a2);
        return 0xFFFFFFFFLL;
      }
      ++*(_BYTE *)(*(_QWORD *)(a2 + 16) + i);
    }
    result = sub_C2676(a1, 2LL, (_QWORD *)(8LL * *(signed int *)(a2 + 24) - 8 + *(_QWORD *)(a2 + 8)));
  }
  else
  {
    sub_12222(
      *(_QWORD *)(a2 + 48),
      0,
      1,
      "Memory allocation failed (%s()).",
      (__int64)"lyb_write_start_subtree",
      v2,
      a2);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000010611E) ----------------------------------------------------
signed __int64 __fastcall sub_10611E(__int64 a1, size_t a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST08_8
  __int64 v5; // ST00_8
  __int64 v7; // [rsp+18h] [rbp-8h]

  v4 = a3;
  v5 = a4;
  v7 = sub_104F44(a1);
  return sub_105AD0(v4, (char *)&v7, a2, v5);
}

//----- (0000000000106160) ----------------------------------------------------
signed __int64 __fastcall sub_106160(unsigned int a1, unsigned int a2, __int64 a3, __int64 a4)
{
  if ( a1 >= a2 )
    __assert_fail("enum_idx < count", "/home/mantovan/Repositories/libyang/src/printer_lyb.c", 0x1CFu, "lyb_write_enum");
  if ( a2 <= 0xFF )
    return sub_10611E(a1, 1uLL, a3, a4);
  if ( a2 <= 0xFFFF )
    return sub_10611E(a1, 2uLL, a3, a4);
  if ( a2 > 0xFFFFFF )
    return sub_10611E(a1, 4uLL, a3, a4);
  return sub_10611E(a1, 3uLL, a3, a4);
}

//----- (00000000001061F7) ----------------------------------------------------
signed __int64 __fastcall sub_1061F7(char *a1, size_t a2, int a3, __int64 a4, __int64 a5)
{
  signed __int64 result; // rax
  int v6; // ST3C_4
  __int64 v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+10h] [rbp-30h]
  int v9; // [rsp+1Ch] [rbp-24h]
  size_t v10; // [rsp+20h] [rbp-20h]
  int v11; // [rsp+38h] [rbp-8h]
  unsigned int v12; // [rsp+38h] [rbp-8h]

  v10 = a2;
  v9 = a3;
  v8 = a4;
  v7 = a5;
  v11 = 0;
  if ( !a2 )
    v10 = strlen(a1);
  if ( !v9 )
    goto LABEL_13;
  if ( v10 > 0xFFFF )
  {
    sub_12222(
      *(_QWORD *)(v7 + 48),
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/printer_lyb.c",
      490LL);
    return 0xFFFFFFFFLL;
  }
  v11 = sub_10611E(v10, 2uLL, v8, v7);
  if ( v11 < 0 )
    return 0xFFFFFFFFLL;
LABEL_13:
  v6 = sub_105AD0(v8, a1, v10, v7);
  v12 = v6 + v11;
  if ( v6 >= 0 )
    result = v12;
  else
    result = 0xFFFFFFFFLL;
  return result;
}

//----- (00000000001062DC) ----------------------------------------------------
signed __int64 __fastcall sub_1062DC(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int16 v4; // ST26_2
  __int16 v5; // ST26_2
  int v6; // ST2C_4
  __int64 v7; // [rsp+8h] [rbp-28h]
  unsigned __int16 v8; // [rsp+26h] [rbp-Ah]
  int v9; // [rsp+28h] [rbp-8h]
  unsigned int v10; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v9 = sub_1061F7(*(char **)(a2 + 8), 0LL, 1, a1, a3);
  if ( v9 < 0 )
    return 0xFFFFFFFFLL;
  v8 = 0;
  if ( *(_BYTE *)(a2 + 68) )
  {
    v4 = ((unsigned __int16)atoi(*(const char **)(a2 + 88)) - 2000) << 9;
    v5 = 32 * atoi((const char *)(*(_QWORD *)(a2 + 88) + 5LL)) | v4;
    v8 = atoi((const char *)(*(_QWORD *)(a2 + 88) + 8LL)) | v5;
  }
  v6 = sub_10611E(v8, 2uLL, a1, v7);
  v10 = v6 + v9;
  if ( v6 >= 0 )
    result = v10;
  else
    result = 0xFFFFFFFFLL;
  return result;
}

//----- (00000000001063FB) ----------------------------------------------------
signed __int64 __fastcall sub_1063FB(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 i; // [rsp+20h] [rbp-8h]

  for ( i = 0LL; i < a2; ++i )
  {
    if ( a3 == *(_QWORD *)(8 * i + a1) )
      return 1LL;
  }
  return 0LL;
}

//----- (000000000010644E) ----------------------------------------------------
signed __int64 __fastcall sub_10644E(__int64 *a1, unsigned __int64 *a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // [rsp+8h] [rbp-18h]

  v4 = a3;
  result = sub_1063FB(*a1, *a2, a3);
  if ( !(_DWORD)result )
  {
    *a1 = (__int64)sub_C422((void *)*a1, 8 * ++*a2);
    result = v4;
    *(_QWORD *)(8 * *a2 - 8 + *a1) = v4;
  }
  return result;
}

//----- (00000000001064E5) ----------------------------------------------------
__int64 __fastcall sub_1064E5(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  int v7; // eax
  int v8; // eax
  __int64 v10; // [rsp+8h] [rbp-58h]
  int v11; // [rsp+20h] [rbp-40h]
  unsigned int v12; // [rsp+24h] [rbp-3Ch]
  unsigned int j; // [rsp+28h] [rbp-38h]
  unsigned int k; // [rsp+2Ch] [rbp-34h]
  void *ptr; // [rsp+30h] [rbp-30h]
  unsigned __int64 v16; // [rsp+38h] [rbp-28h]
  __int64 i; // [rsp+40h] [rbp-20h]
  __int64 v18; // [rsp+48h] [rbp-18h]
  __int64 v19; // [rsp+50h] [rbp-10h]
  unsigned __int64 v20; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v20 = __readfsqword(0x28u);
  v12 = 0;
  ptr = 0LL;
  v16 = 0LL;
  v11 = 0;
  for ( i = a2; i; i = *(_QWORD *)(i + 24) )
  {
    v18 = lyd_node_module(i);
    sub_10644E((__int64 *)&ptr, &v16, v18);
  }
  if ( a2 )
  {
    v11 = ly_ctx_internal_modules_count(**(_QWORD **)(*(_QWORD *)a2 + 48LL));
LABEL_33:
    while ( 1 )
    {
      v18 = ly_ctx_get_module_iter(**(_QWORD **)(*(_QWORD *)a2 + 48LL), &v11);
      if ( !v18 )
        break;
      if ( *(_BYTE *)(v18 + 64) < 0 )
      {
        for ( j = 0; j < *(unsigned __int8 *)(v18 + 78); ++j )
        {
          if ( *(_QWORD *)(*(_QWORD *)(v18 + 144) + 56LL * j + 24) )
          {
            v3 = lys_node_module(*(_QWORD *)(*(_QWORD *)(v18 + 144) + 56LL * j + 24));
            if ( (unsigned int)sub_1063FB((__int64)ptr, v16, v3) )
            {
              sub_10644E((__int64 *)&ptr, &v16, v18);
              goto LABEL_33;
            }
          }
        }
        for ( j = 0; j < *(unsigned __int8 *)(v18 + 77); ++j )
        {
          v4 = lys_node_module(*(_QWORD *)(*(_QWORD *)(v18 + 136) + 104LL * j + 88));
          if ( (unsigned int)sub_1063FB((__int64)ptr, v16, v4) )
          {
            sub_10644E((__int64 *)&ptr, &v16, v18);
            goto LABEL_33;
          }
        }
        for ( k = 0; k < *(unsigned __int8 *)(v18 + 70); ++k )
        {
          v19 = *(_QWORD *)(*(_QWORD *)(v18 + 104) + 48LL * k);
          for ( j = 0; j < *(unsigned __int8 *)(v19 + 78); ++j )
          {
            if ( *(_QWORD *)(*(_QWORD *)(v19 + 144) + 56LL * j + 24) )
            {
              v5 = lys_node_module(*(_QWORD *)(*(_QWORD *)(v19 + 144) + 56LL * j + 24));
              if ( (unsigned int)sub_1063FB((__int64)ptr, v16, v5) )
              {
                sub_10644E((__int64 *)&ptr, &v16, v18);
                goto LABEL_33;
              }
            }
          }
          for ( j = 0; j < *(unsigned __int8 *)(v19 + 77); ++j )
          {
            v6 = lys_node_module(*(_QWORD *)(*(_QWORD *)(v19 + 136) + 104LL * j + 88));
            if ( (unsigned int)sub_1063FB((__int64)ptr, v16, v6) )
            {
              sub_10644E((__int64 *)&ptr, &v16, v18);
              goto LABEL_33;
            }
          }
        }
      }
    }
  }
  v7 = sub_10611E(v16, 2uLL, a1, v10);
  v12 += v7;
  for ( j = 0; j < v16; ++j )
  {
    v8 = sub_1062DC(a1, *((_QWORD *)ptr + j), v10);
    v12 += v8;
  }
  free(ptr);
  return v12;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 75C0: using guessed type __int64 __fastcall ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7B20: using guessed type __int64 __fastcall ly_ctx_internal_modules_count(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000001068FD) ----------------------------------------------------
__int64 __fastcall sub_1068FD(__int64 a1)
{
  char v2; // [rsp+14h] [rbp-Ch]
  char v3; // [rsp+15h] [rbp-Bh]
  char v4; // [rsp+16h] [rbp-Ah]
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v2 = 108;
  v3 = 121;
  v4 = 98;
  return sub_C23A5(a1, &v2, 3uLL);
}

//----- (0000000000106963) ----------------------------------------------------
__int64 __fastcall sub_106963(__int64 a1)
{
  int v1; // eax
  char v3; // [rsp+13h] [rbp-Dh]
  int v4; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v4 = 0;
  v3 = 0;
  v1 = sub_C23A5(a1, &v3, 1uLL);
  return (unsigned int)(v1 + v4);
}

//----- (00000000001069BD) ----------------------------------------------------
signed __int64 __fastcall sub_1069BD(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+28h] [rbp-18h]
  unsigned int v9; // [rsp+28h] [rbp-18h]
  int v10; // [rsp+2Ch] [rbp-14h]
  __int64 v11; // [rsp+30h] [rbp-10h]
  unsigned __int64 v12; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v12 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 52) == 8 )
  {
    lyxml_print_mem(&v11, *(_QWORD *)(a1 + 56), 16LL);
    lyxml_free(**(_QWORD **)(*(_QWORD *)a1 + 48LL), *(_QWORD *)(a1 + 56));
    *(_DWORD *)(a1 + 52) = 0;
    *(_QWORD *)(a1 + 56) = lydict_insert_zc(**(_QWORD **)(*(_QWORD *)a1 + 48LL), v11);
  }
  else if ( *(_DWORD *)(a1 + 52) == 16 )
  {
    lyd_print_mem(&v11, *(_QWORD *)(a1 + 56), 3LL, 1LL);
    lyd_free_withsiblings(*(_QWORD *)(a1 + 56));
    *(_DWORD *)(a1 + 52) = 32;
    *(_QWORD *)(a1 + 56) = v11;
  }
  else if ( *(_DWORD *)(a1 + 52) & 1 )
  {
    sub_12222(*(_QWORD *)(a3 + 48), 0, 4, "Unsupported anydata value type to print.", a5, a6);
    return 0xFFFFFFFFLL;
  }
  v8 = sub_105AD0(a2, (char *)(a1 + 52), 4uLL, v7);
  if ( *(_DWORD *)(a1 + 52) == 32 )
  {
    v10 = lyd_lyb_data_length(*(_QWORD *)(a1 + 56), a1 + 52);
    if ( v10 < 0 )
      v9 = v10;
    else
      v9 = (unsigned __int64)sub_1061F7(*(char **)(a1 + 56), v10, 0, a2, v7) + v8;
  }
  else
  {
    v9 = (unsigned __int64)sub_1061F7(*(char **)(a1 + 56), 0LL, 0, a2, v7) + v8;
  }
  return v9;
}
// 71A0: using guessed type __int64 __fastcall lydict_insert_zc(_QWORD, _QWORD);
// 7320: using guessed type __int64 __fastcall lyd_lyb_data_length(_QWORD, _QWORD);
// 7670: using guessed type __int64 __fastcall lyd_free_withsiblings(_QWORD);
// 78A0: using guessed type __int64 __fastcall lyxml_free(_QWORD, _QWORD);
// 7960: using guessed type __int64 __fastcall lyd_print_mem(_QWORD, _QWORD, _QWORD, _QWORD);
// 7990: using guessed type __int64 __fastcall lyxml_print_mem(_QWORD, _QWORD, _QWORD);

//----- (0000000000106BBB) ----------------------------------------------------
__int64 __fastcall sub_106BBB(signed __int64 a1, char *a2, __int64 a3, signed int a4, char a5, char a6, __int64 a7, __int64 a8)
{
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  __int64 result; // rax
  char v19; // [rsp+20h] [rbp-50h]
  signed int v20; // [rsp+24h] [rbp-4Ch]
  __int64 v21; // [rsp+28h] [rbp-48h]
  signed __int64 v22; // [rsp+38h] [rbp-38h]
  char v23; // [rsp+47h] [rbp-29h]
  unsigned int v24; // [rsp+48h] [rbp-28h]
  unsigned int v25; // [rsp+4Ch] [rbp-24h]
  __int64 i; // [rsp+50h] [rbp-20h]
  unsigned __int64 j; // [rsp+58h] [rbp-18h]
  __int64 v28; // [rsp+60h] [rbp-10h]
  unsigned __int64 v29; // [rsp+68h] [rbp-8h]

  v22 = a1;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v29 = __readfsqword(0x28u);
  v24 = 0;
  v23 = 0;
  if ( a6 )
    v23 |= 0x80u;
  if ( a5 & 2 )
    v23 |= 0x40u;
  if ( a5 & 1 )
    v23 |= 0x20u;
  if ( a4 != (a4 & 0x1F) )
    __assert_fail(
      "(value_type & 0x1f) == value_type",
      "/home/mantovan/Repositories/libyang/src/printer_lyb.c",
      0x2E1u,
      "lyb_print_value");
  while ( *(_DWORD *)v22 == 9 )
    v22 = *(_QWORD *)(v22 + 40) + 128LL;
  if ( a5 & 2 || *(_DWORD *)v22 == 11 )
  {
    v20 = 10;
  }
  else
  {
    while ( v20 == 9 )
    {
      if ( a5 & 1 )
        __assert_fail(
          "!(value_flags & LY_VALUE_UNRES)",
          "/home/mantovan/Repositories/libyang/src/printer_lyb.c",
          0x2EBu,
          "lyb_print_value");
      v20 = *(_DWORD *)(v21 + 72);
      v21 = *(_QWORD *)(v21 + 64);
    }
  }
  v23 |= v20 & 0x1F;
  v8 = sub_105AD0(a7, &v23, 1uLL, a8);
  v24 += v8;
  if ( v19 & 2 )
    v25 = 10;
  else
    v25 = v20;
  switch ( (unsigned __int64)v25 )
  {
    case 1uLL:
    case 7uLL:
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0x14uLL:
      v9 = sub_1061F7(a2, 0LL, 0, a7, a8);
      v24 += v9;
      goto LABEL_51;
    case 2uLL:
      while ( !*(_DWORD *)(v22 + 40) )
        v22 = *(_QWORD *)(v22 + 16) + 56LL;
      v28 = 0LL;
      for ( i = (unsigned int)(*(_DWORD *)(v22 + 40) >> 3); i; --i )
      {
        v23 = 0;
        for ( j = 0LL; j <= 7; ++j )
        {
          if ( *(_QWORD *)(8 * (v28 + j) + v21) )
            v23 |= 1 << j;
        }
        v10 = sub_105AD0(a7, &v23, 1uLL, a8);
        v24 += v10;
        v28 += 8LL;
      }
      if ( *(_DWORD *)(v22 + 40) & 7 )
      {
        v23 = 0;
        for ( j = 0LL; j < (*(_DWORD *)(v22 + 40) & 7u); ++j )
        {
          if ( *(_QWORD *)(8 * (v28 + j) + v21) )
            v23 |= 1 << j;
        }
        v11 = sub_105AD0(a7, &v23, 1uLL, a8);
        v24 += v11;
      }
      goto LABEL_51;
    case 3uLL:
      v23 = 0;
      if ( (_BYTE)v21 )
        v23 = 1;
      v12 = sub_105AD0(a7, &v23, 1uLL, a8);
      v24 += v12;
      goto LABEL_51;
    case 4uLL:
    case 0x12uLL:
    case 0x13uLL:
      v17 = sub_10611E(v21, 8uLL, a7, a8);
      v24 += v17;
      goto LABEL_51;
    case 5uLL:
      goto LABEL_51;
    case 6uLL:
      while ( !*(_DWORD *)(v22 + 40) )
        v22 = *(_QWORD *)(v22 + 16) + 56LL;
      j = -6148914691236517205LL * ((v21 - *(_QWORD *)(v22 + 32)) >> 4);
      v13 = sub_106160(j, *(_DWORD *)(v22 + 40), a7, a8);
      v24 += v13;
      goto LABEL_51;
    case 0xCuLL:
    case 0xDuLL:
      v14 = sub_10611E((unsigned __int8)v21, 1uLL, a7, a8);
      v24 += v14;
      goto LABEL_51;
    case 0xEuLL:
    case 0xFuLL:
      v15 = sub_10611E((unsigned __int16)v21, 2uLL, a7, a8);
      v24 += v15;
      goto LABEL_51;
    case 0x10uLL:
    case 0x11uLL:
      v16 = sub_10611E((unsigned int)v21, 4uLL, a7, a8);
      v24 += v16;
LABEL_51:
      result = v24;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000107027) ----------------------------------------------------
signed __int64 __fastcall sub_107027(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+8h] [rbp-48h]
  char v8; // [rsp+2Fh] [rbp-21h]
  unsigned int v9; // [rsp+30h] [rbp-20h]
  char v10[12]; // [rsp+34h] [rbp-1Ch]
  signed __int64 *v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v7 = a3;
  v12 = __readfsqword(0x28u);
  v9 = 0;
  v8 = 0;
  for ( *(_QWORD *)&v10[4] = a2; *(_QWORD *)&v10[4]; *(_QWORD *)&v10[4] = *(_QWORD *)(*(_QWORD *)&v10[4] + 8LL) )
  {
    if ( v8 == -1 )
    {
      sub_12222(*(_QWORD *)(a3 + 48), 0, 4, "Maximum supported number of data node attributes is %u.", 255LL, a6);
      return 0xFFFFFFFFLL;
    }
    ++v8;
  }
  *(_QWORD *)v10 = (unsigned int)sub_105AD0(a1, &v8, 1uLL, a3);
  v9 += *(_DWORD *)v10;
  if ( *(_DWORD *)v10 < 0 )
    return 0xFFFFFFFFLL;
  for ( *(_QWORD *)&v10[4] = a2; *(_QWORD *)&v10[4]; *(_QWORD *)&v10[4] = *(_QWORD *)(*(_QWORD *)&v10[4] + 8LL) )
  {
    *(_DWORD *)v10 = sub_105F04(a1, v7);
    v9 += *(_DWORD *)v10;
    if ( *(_DWORD *)v10 < 0 )
      return 0xFFFFFFFFLL;
    *(_DWORD *)v10 = sub_1062DC(a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)&v10[4] + 16LL) + 48LL), v7);
    v9 += *(_DWORD *)v10;
    if ( *(_DWORD *)v10 < 0 )
      return 0xFFFFFFFFLL;
    *(_DWORD *)v10 = sub_1061F7(*(char **)(*(_QWORD *)(*(_QWORD *)&v10[4] + 16LL) + 16LL), 0LL, 1, a1, v7);
    v9 += *(_DWORD *)v10;
    if ( *(_DWORD *)v10 < 0 )
      return 0xFFFFFFFFLL;
    v11 = (signed __int64 *)lys_ext_complex_get_substmt(48LL, *(_QWORD *)(*(_QWORD *)&v10[4] + 16LL), 0LL);
    if ( !v11 || !*v11 )
      return 0xFFFFFFFFLL;
    *(_DWORD *)v10 = sub_106BBB(
                       *v11,
                       *(char **)(*(_QWORD *)&v10[4] + 32LL),
                       *(_QWORD *)(*(_QWORD *)&v10[4] + 40LL),
                       *(_DWORD *)(*(_QWORD *)&v10[4] + 48LL),
                       *(_BYTE *)(*(_QWORD *)&v10[4] + 52LL),
                       0,
                       a1,
                       v7);
    v9 += *(_DWORD *)v10;
    if ( *(_DWORD *)v10 < 0 )
      return 0xFFFFFFFFLL;
    *(_DWORD *)v10 = sub_105E36(a1, v7);
    v9 += *(_DWORD *)v10;
    if ( *(_DWORD *)v10 < 0 )
      return 0xFFFFFFFFLL;
  }
  return v9;
}
// 7410: using guessed type __int64 __fastcall lys_ext_complex_get_substmt(_QWORD, _QWORD, _QWORD);

//----- (0000000000107293) ----------------------------------------------------
signed __int64 __fastcall sub_107293(__int64 a1, const char **a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v6; // r9
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 *v8; // [rsp+8h] [rbp-48h]
  unsigned __int8 v9; // [rsp+23h] [rbp-2Dh]
  int j; // [rsp+24h] [rbp-2Ch]
  unsigned int v11; // [rsp+28h] [rbp-28h]
  int k; // [rsp+2Ch] [rbp-24h]
  __int64 i; // [rsp+30h] [rbp-20h]
  __int64 v14; // [rsp+38h] [rbp-18h]
  void *v15; // [rsp+40h] [rbp-10h]
  unsigned __int64 v16; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v16 = __readfsqword(0x28u);
  v11 = 0;
  if ( !*a3 )
  {
    for ( i = lys_parent(a2); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
      ;
    v4 = lys_node_module(a2);
    v14 = lys_getnext(0LL, i, v4, 0LL);
    for ( j = 0; j < *(_DWORD *)(v7 + 64); ++j )
    {
      if ( v14 == *(_QWORD *)(16LL * j + *(_QWORD *)(v7 + 56)) )
      {
        *v8 = *(_QWORD *)(16LL * j + *(_QWORD *)(v7 + 56) + 8);
        break;
      }
    }
    if ( !*v8 )
    {
      *v8 = (__int64)sub_105659(v14, 0LL, 0);
      if ( !*v8 )
        return 0xFFFFFFFFLL;
      v15 = realloc(*(void **)(v7 + 56), 16LL * (signed int)++*(_DWORD *)(v7 + 64));
      if ( !v15 )
      {
        sub_12222(
          *(_QWORD *)(v7 + 48),
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"lyb_print_schema_hash",
          v6,
          v7);
        return 0xFFFFFFFFLL;
      }
      *(_QWORD *)(v7 + 56) = v15;
      *(_QWORD *)(16LL * *(signed int *)(v7 + 64) - 16 + *(_QWORD *)(v7 + 56)) = v14;
      *(_QWORD *)(16LL * *(signed int *)(v7 + 64) - 16 + *(_QWORD *)(v7 + 56) + 8) = *v8;
    }
  }
  v9 = sub_1059E6(*v8, (__int64)a2);
  if ( !v9 )
    return 0xFFFFFFFFLL;
  j = sub_105AD0(a1, (char *)&v9, 1uLL, v7);
  v11 += j;
  if ( j < 0 )
    return 0xFFFFFFFFLL;
  if ( (v9 & 0x80u) != 0 )
    return v11;
  for ( k = 0; !(v9 & (128 >> k)); ++k )
    ;
  while ( k )
  {
    v9 = sub_C5A1(a2, (unsigned __int8)k - 1);
    if ( !v9 )
      return 0xFFFFFFFFLL;
    if ( !((128 >> (k - 1)) & v9) )
      __assert_fail(
        "hash & (LYB_HASH_COLLISION_ID >> (i - 1))",
        "/home/mantovan/Repositories/libyang/src/printer_lyb.c",
        0x3D3u,
        "lyb_print_schema_hash");
    j = sub_105AD0(a1, (char *)&v9, 1uLL, v7);
    v11 += j;
    if ( j < 0 )
      return 0xFFFFFFFFLL;
    --k;
  }
  return v11;
}
// 71E0: using guessed type __int64 __fastcall lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);
// 7BB0: using guessed type __int64 __fastcall lys_node_module(_QWORD);

//----- (00000000001075FD) ----------------------------------------------------
signed __int64 __fastcall sub_1075FD(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int a5)
{
  signed __int64 result; // rax
  __int64 v6; // rax
  int v7; // ST40_4
  __int64 v8; // r8
  __int64 v9; // r9
  int v10; // ST40_4
  __int64 v11; // r8
  __int64 v12; // r9
  int v13; // ST40_4
  unsigned int v14; // eax
  int v15; // ST40_4
  int v16; // ST40_4
  int v17; // ST40_4
  int v18; // [rsp+Ch] [rbp-44h]
  __int64 v19; // [rsp+10h] [rbp-40h]
  __int64 *v20; // [rsp+18h] [rbp-38h]
  __int64 i; // [rsp+20h] [rbp-30h]
  int v22; // [rsp+30h] [rbp-20h]
  int v23; // [rsp+34h] [rbp-1Ch]
  int v24; // [rsp+34h] [rbp-1Ch]
  int v25; // [rsp+34h] [rbp-1Ch]
  unsigned int v26; // [rsp+34h] [rbp-1Ch]
  __int64 v27; // [rsp+38h] [rbp-18h]
  __int64 v28; // [rsp+40h] [rbp-10h]
  unsigned __int64 v29; // [rsp+48h] [rbp-8h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v29 = __readfsqword(0x28u);
  v27 = 0LL;
  v23 = sub_105F04(a1, a4);
  if ( v23 < 0 )
    return 0xFFFFFFFFLL;
  if ( v18 )
  {
    v6 = lyd_node_module(a2);
    v7 = sub_1062DC(a1, v6, v19);
    v23 += v7;
    if ( v7 < 0 )
      return 0xFFFFFFFFLL;
  }
  v10 = sub_107293(a1, *(const char ***)a2, v20, v19);
  v24 = v10 + v23;
  if ( v10 < 0 )
    return 0xFFFFFFFFLL;
  v13 = sub_107027(a1, *(_QWORD *)(a2 + 16), v19, *(_QWORD *)(a2 + 16), v8, v9);
  v25 = v13 + v24;
  if ( v13 < 0 )
    return 0xFFFFFFFFLL;
  v14 = *(_DWORD *)(*(_QWORD *)a2 + 56LL);
  if ( v14 == 32 )
    goto LABEL_28;
  if ( v14 > 0x20 )
  {
    if ( v14 == 256 )
      goto LABEL_31;
    if ( v14 <= 0x100 )
    {
      if ( v14 != 128 )
        return 0xFFFFFFFFLL;
      goto LABEL_31;
    }
    if ( v14 == 0x4000 )
      goto LABEL_31;
    if ( v14 != 32800 )
      return 0xFFFFFFFFLL;
LABEL_28:
    v16 = sub_1069BD(a2, a1, v19, a1, v11, v12);
    v25 += v16;
    if ( v16 < 0 )
      return 0xFFFFFFFFLL;
    goto LABEL_31;
  }
  if ( v14 == 4 )
    goto LABEL_26;
  if ( v14 > 4 )
  {
    if ( v14 != 8 )
    {
      if ( v14 != 16 )
        return 0xFFFFFFFFLL;
      goto LABEL_31;
    }
LABEL_26:
    v28 = a2;
    v15 = sub_106BBB(
            *(_QWORD *)a2 + 128LL,
            *(char **)(a2 + 56),
            *(_QWORD *)(a2 + 64),
            *(_DWORD *)(a2 + 72),
            *(_BYTE *)(a2 + 76),
            *(_BYTE *)(a2 + 9) & 1,
            a1,
            v19);
    v25 += v15;
    if ( v15 < 0 )
      return 0xFFFFFFFFLL;
    goto LABEL_31;
  }
  if ( v14 != 1 )
    return 0xFFFFFFFFLL;
LABEL_31:
  v22 = 0;
  if ( *(_DWORD *)(*(_QWORD *)a2 + 56LL) & 0x4191 )
  {
    for ( i = *(_QWORD *)(a2 + 64); i; i = *(_QWORD *)(i + 24) )
    {
      v22 = sub_1075FD(a1, i, &v27, v19, 0LL);
      v25 += v22;
      if ( v22 < 0 )
        break;
    }
  }
  if ( v22 < 0 )
    return 0xFFFFFFFFLL;
  v17 = sub_105E36(a1, v19);
  v26 = v17 + v25;
  if ( v17 >= 0 )
    result = v26;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);

//----- (00000000001078FB) ----------------------------------------------------
signed __int64 __fastcall sub_1078FB(__int64 a1, _QWORD *a2, char a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  signed __int64 result; // rax
  __int64 v6; // rax
  char v7; // [rsp+Ch] [rbp-94h]
  __int64 v8; // [rsp+10h] [rbp-90h]
  char v9; // [rsp+2Bh] [rbp-75h]
  int j; // [rsp+2Ch] [rbp-74h]
  int v11; // [rsp+30h] [rbp-70h]
  unsigned int v12; // [rsp+34h] [rbp-6Ch]
  __int64 v13; // [rsp+38h] [rbp-68h]
  __int64 v14; // [rsp+40h] [rbp-60h]
  __int64 i; // [rsp+48h] [rbp-58h]
  void *s; // [rsp+50h] [rbp-50h]
  void *ptr; // [rsp+58h] [rbp-48h]
  void *v18; // [rsp+60h] [rbp-40h]
  __int64 v19; // [rsp+80h] [rbp-20h]
  void *v20; // [rsp+88h] [rbp-18h]
  int v21; // [rsp+90h] [rbp-10h]
  unsigned __int64 v22; // [rsp+98h] [rbp-8h]

  v8 = (__int64)a2;
  v7 = a3;
  v22 = __readfsqword(0x28u);
  v11 = 0;
  v12 = 0;
  v9 = 0;
  v13 = 0LL;
  v14 = 0LL;
  memset(&s, 0, 0x48uLL);
  if ( !a2 )
    goto LABEL_30;
  v19 = *(_QWORD *)lyd_node_module(a2);
  for ( i = lys_parent(*a2); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( i && *(_DWORD *)(i + 56) != 0x10000 )
  {
    sub_12222(v19, 0, 3, "LYB printer supports only printing top-level nodes.", v3, v4);
    result = 1LL;
  }
  else
  {
LABEL_30:
    j = sub_1068FD(a1);
    v11 += j;
    if ( j >= 0 )
    {
      j = sub_106963(a1);
      v11 += j;
      if ( j >= 0 )
      {
        j = sub_1064E5(a1, (__int64)a2, (__int64)&s);
        v11 += j;
        if ( j >= 0 )
        {
          while ( v8 )
          {
            v6 = lyd_node_module(v8);
            if ( v14 != v6 )
            {
              v13 = 0LL;
              v14 = lyd_node_module(v8);
            }
            j = sub_1075FD(a1, v8, &v13, (__int64)&s, 1);
            v11 += j;
            if ( j < 0 )
            {
              v12 = 1;
              goto LABEL_24;
            }
            if ( !(v7 & 1) )
              break;
            v8 = *(_QWORD *)(v8 + 24);
          }
          j = sub_105AD0(a1, &v9, 1uLL, (__int64)&s);
          v11 += j;
          if ( j < 0 )
            v12 = 1;
        }
        else
        {
          v12 = 1;
        }
      }
      else
      {
        v12 = 1;
      }
    }
    else
    {
      v12 = 1;
    }
LABEL_24:
    free(s);
    free(ptr);
    free(v18);
    for ( j = 0; j < v21; ++j )
      sub_14F6B(*((void ***)v20 + 2 * j + 1));
    free(v20);
    result = v12;
  }
  return result;
}
// 73D0: using guessed type __int64 __fastcall lyd_node_module(_QWORD);
// 7550: using guessed type __int64 __fastcall lys_parent(_QWORD);

//----- (0000000000107BF0) ----------------------------------------------------
int __fastcall sub_107BF0(char *filename, struct stat *stat_buf)
{
  return __xstat(1, filename, stat_buf);
}

//----- (0000000000107C00) ----------------------------------------------------
int __fastcall sub_107C00(int fildes, struct stat *stat_buf)
{
  return __fxstat(1, fildes, stat_buf);
}

//----- (0000000000107C10) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 1201 function(s)"
