#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <emmintrin.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


// Global variables


QWORD edata;
QWORD __cxa_finalize;
QWORD off_3365A0;
QWORD off_107C20;
QWORD qword_335FE0;
QWORD stru_335FC0;
QWORD unk_107E6B;
QWORD unk_107EEB;
QWORD off_1083D1;
QWORD off_3457F0;
QWORD unk_3457FC;
QWORD unk_3457F8;
QWORD unk_1086CA;
QWORD byte_3458A0;
QWORD byte_3458A1;
QWORD dword_347048;
//qword_347050 = (__int64 ( *)(_QWORD, _QWORD, _QWORD))a
__int64 (*qword_347050)(_QWORD, _QWORD, _QWORD);
//__int64 ( *)(_QWORD, _QWORD, _QWORD) qword_347050;
QWORD dword_3458A4;
QWORD v9;
QWORD off_108D8F;
QWORD unk_10A000;
QWORD off_3458E0;
QWORD v2;
QWORD unk_10A3C1;
QWORD unk_10AA7C;
QWORD loc_17E00;
QWORD loc_100000;
QWORD off_10CCE0;
QWORD loc_EFFFF;
QWORD unk_10DE4F;



//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_7180();
// char *getenv(const char *name);
// void free(void *ptr);
// int *__errno_location(void);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// char *strcpy(char *dest, const char *src);
// int ferror(FILE *stream);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int isatty(int fd);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// double atof(const char *nptr);
// ssize_t readlink(const char *path, char *buf, size_t len);
// ssize_t write(int fd, const void *buf, size_t n);
// int vasprintf(char **ptr, const char *f, __gnuc_va_list arg);
// int fclose(FILE *stream);
// DIR *opendir(const char *name);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// char *strrchr(const char *s, int c);
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// void *memset(void *s, int c, size_t n);
// int close(int fd);
// int closedir(DIR *dirp);
// char *strtok_r(char *s, const char *delim, char **save_ptr);
// char *strndup(const char *string, size_t n);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// void *calloc(size_t nmemb, size_t size);
// int strcmp(const char *s1, const char *s2);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int fprintf(FILE *stream, const char *format, ...);
// __int64 strtol(const char *nptr, char **endptr, int base);
// void clearerr(FILE *stream);
// char *realpath(const char *name, char *resolved);
// void *memcpy(void *dest, const void *src, size_t n);
// int fileno(FILE *stream);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// struct dirent *readdir(DIR *dirp);
// void *dlopen(const char *file, int mode);
// int tolower(int c);
// char *get_current_dir_name(void);
// void *pthread_getspecific(pthread_key_t key);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *malloc(size_t size);
// int fflush(FILE *stream);
// int _IO_getc(_IO_FILE *fp);
// int __fxstat(int ver, int fildes, struct stat *stat_buf);
// time_t mktime(struct tm *tp);
// char *strpbrk(const char *s, const char *accept);
// int dlclose(void *handle);
// void *realloc(void *ptr, size_t size);
// int asprintf(char **ptr, const char *fmt, ...);
// int munmap(void *addr, size_t len);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// void *memmove(void *dest, const void *src, size_t n);
// long double strtold(const char *nptr, char **endptr);
 int open(const char *file, int oflag, ...);
// int vdprintf(int fd, const char *fmt, __gnuc_va_list arg);
// int access(const char *name, int type);
// FILE *fopen(const char *filename, const char *modes);
// __int64 sysconf(int name);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// unsigned __int64 strtoul(const char *nptr, char **endptr, int base);
// int atoi(const char *nptr);
// int pthread_key_delete(pthread_key_t key);
// int sprintf(char *s, const char *format, ...);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strdup(const char *s);
// char *strerror(int errnum);
// void *dlsym(void *handle, const char *name);
// char *strptime(const char *s, const char *fmt, struct tm *tp);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// char *strstr(const char *haystack, const char *needle);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// char *dlerror(void);
// const unsigned __int16 **__ctype_b_loc(void);
char *start();
__int64 sub_7CD0();
char *sub_7D20();
__int64 sub_7D60();
__int64  ly_errno_glob_address(__int64 a1);
__int64  ly_vecode(__int64 a1);
__int64  ly_errmsg(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_errpath(__int64 a1, __int64 a2);
__int64  ly_errapptag(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void * ly_err_first(__int64 a1);
void  destr_function(void *a1);
__int64  ly_err_clean(__int64 a1, __int64 a2);
_BYTE * sub_80BC(_BYTE *a1, _BYTE *a2, int a3);
_BYTE * sub_811F(_BYTE *a1, char a2, int a3);
const char * sub_8164(unsigned int a1);
__int64  sub_831C(__int64 a1, const char *a2);
signed __int64  sub_83E9(_QWORD *a1, const char *a2, void **a3, __int64 *a4, size_t *a5, int a6, int a7, void **a8, void **a9, unsigned int *a10);
__int64  sub_8F60(__int64 *a1, const char *a2, int a3, int a4, void **a5, void **a6, unsigned int *a7);
__int64  sub_912E(__int64 *a1, const char *a2, int a3, void **a4, void **a5, unsigned int *a6);
__int64  sub_9182(__int64 *a1, const char *a2);
signed __int64  sub_91C4(__int64 a1, const char *a2, void **a3, __int64 *a4, size_t *a5, char *a6, int a7, int a8);
__int64  sub_9A10(__int64 a1, const char *a2, char *a3, unsigned int a4, unsigned int a5);
char * ly_path_xml2json(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_9BED(__int64 *a1, const char *a2);
__int64  sub_A2CB(__int64 *a1, const char *a2);
signed __int64  sub_A671(void **a1, __int64 a2, __int64 a3, _DWORD *a4, int a5, void **a6, __int64 *a7, size_t *a8);
void * sub_B085(void **a1, const char *a2);
signed __int64  sub_B202(__int64 a1, _QWORD *a2, unsigned __int16 a3, void **a4, _WORD *a5);
signed __int64  sub_B369(void *a1, const char **a2, __int64 a3, _QWORD *a4, unsigned __int16 *a5, void **a6, _WORD *a7);
void * ly_path_data2schema(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_C3AB(__int64 a1);
void * sub_C422(void *a1, size_t a2);
signed __int64  sub_C462(_BYTE *a1, _BYTE *a2);
signed __int64  sub_C4C9(unsigned __int8 a1);
signed __int64  sub_C508(signed __int64 a1, unsigned __int8 a2, signed __int64 a3, unsigned __int8 a4);
__int64  sub_C5A1(const char **a1, unsigned __int8 a2);
signed __int64  sub_C70A(__int64 a1, __int64 a2, int a3);
size_t  sub_C76D(const char *a1);
__int64  ly_ctx_internal_modules_count(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
pthread_key_t * ly_ctx_new(const char *a1, pthread_key_t a2);
signed __int64  sub_CB4C(__int64 a1, __int64 a2);
__int64  sub_CD97(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 ( *a5)(__int64, __int64, _QWORD, _QWORD, _QWORD));
__int64  ly_ctx_new_ylpath(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_new_ylmem(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_D149(__int64 a1, int a2);
__int64  sub_D173(__int64 a1, int a2);
__int64  ly_ctx_set_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_unset_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_set_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_unset_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_set_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_unset_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_set_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_unset_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_set_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_unset_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_get_options(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  ly_ctx_set_searchdir(__int64 a1, __int64 a2);
__int64  ly_ctx_get_searchdirs(__int64 a1);
__int64  ly_ctx_unset_searchdirs(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  ly_ctx_destroy(__int64 a1, __int64 a2);
__int64  ly_ctx_get_submodule2(__int64 a1, __int64 a2);
__int64  ly_ctx_get_submodule(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_DCEF(__int64 a1, const char *a2, size_t a3, int a4, char *a5, __int64 a6, int a7);
__int64  ly_ctx_get_module_by_ns(__int64 a1, const char *a2, char *a3, __int64 a4);
__int64  ly_ctx_get_module(__int64 a1, const char *a2, char *a3, __int64 a4);
__int64  sub_E085(__int64 a1, const char *a2, size_t a3, char *a4, int a5);
__int64  ly_ctx_get_module_older(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  ly_ctx_set_module_imp_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_get_module_imp_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  ly_ctx_set_module_data_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_get_module_data_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_E447(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6);
__int64  sub_EB1C(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
__int64  sub_ECF1(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6);
__int64  ly_ctx_load_module(__int64 a1, char *a2, char *a3);
__int64  sub_F0B0(__int64 a1, __int64 a2);
__int64  sub_F559(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lys_set_disabled(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_FD3F(__int64 a1, __int64 a2);
signed __int64  lys_set_enabled(__int64 a1);
signed __int64  ly_ctx_remove_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  ly_ctx_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_get_module_iter(__int64 a1, __int64 a2);
__int64  ly_ctx_get_disabled_module_iter(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_10999(__int64 a1, __int64 a2);
signed __int64  sub_10B6F(__int64 a1, __int64 a2, int a3);
signed __int64  sub_10D68(__int64 a1, __int64 a2, int a3);
__int64  ly_ctx_get_module_set_id(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_info(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_ctx_get_node(void *a1, __int64 a2, char *a3, __int64 a4);
__int64  ly_ctx_find_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_verb(char a1);
__int64  ly_log_options(char a1);
__int64  ly_verb_dbg(unsigned int a1);
__int64  ly_set_log_clb(__int64 a1, unsigned int a2);
__int64 ( *ly_get_log_clb())(_QWORD, _QWORD, _QWORD);
__int64  sub_11BDA(void *a1, unsigned int a2, int a3, int a4, void *a5, void *a6, void *a7);
unsigned __int64  sub_11EB0(void *a1, unsigned int a2, int a3, int a4, void *a5, char *a6, void *a7);
unsigned __int64 sub_12222(__int64 a1, unsigned int a2, int a3, char *a4, __int64 a5, __int64 a6, ...);
unsigned __int64 sub_12312(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...);
unsigned __int64 lyext_log(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...);
unsigned __int64 lyext_vlog(void *a1, int a2, __int64 a3, __int64 a4, int a5, char *a6, __int64 a7, ...);
signed __int64  sub_129CF(void **a1, unsigned __int16 *a2, void *a3, unsigned __int16 a4, unsigned __int16 *a5);
signed __int64  sub_12B3E(unsigned int a1, char *a2, void **a3, int a4, int a5);
unsigned __int64 sub_13937(void *a1, int a2, unsigned int a3, char *a4, __int64 a5, __int64 a6, ...);
unsigned __int64 sub_13C4A(void *a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6, ...);
int  ly_err_print(unsigned int *a1);
__int64  sub_13FA5(__int64 a1, __int64 a2);
__int64  sub_1404C(__int64 a1, __int64 a2);
void  sub_1409D(__int64 a1, __int64 a2, int a3);
__int64  sub_141E4(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4);
void  sub_142D2(__int64 a1, int a2, __int64 a3, int a4);
__int64  sub_14407(__int64 a1, const char *a2);
_BOOL4  sub_1446B(const char **a1, char **a2, __int64 a3, size_t *a4, __int64 a5, __int64 a6);
int  sub_14546(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
int  sub_145FF(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_14701(__int64 a1, unsigned __int64 a2);
__int64  sub_1476E(unsigned int a1, __int64 a2, unsigned __int64 a3);
unsigned __int64  lydict_remove(__int64 a1, __int64 a2);
__int64  sub_149A6(__int64 *a1, void *a2, size_t a3, int a4);
__int64  lydict_insert(__int64 a1, char *a2, size_t a3);
__int64  lydict_insert_zc(__int64 a1, __int64 a2);
__int64  sub_14C8D(__int64 a1, unsigned __int16 a2, int a3);
_QWORD * sub_14CB1(unsigned int a1, __int16 a2, __int64 a3, __int64 a4, int a5);
__int64  sub_14E64(__int64 a1, __int64 a2);
__int64  sub_14E8E(__int64 a1, __int64 a2);
_QWORD * sub_14EB8(unsigned int *a1);
void  sub_14F6B(void **a1);
signed __int64  sub_14F9D(__int64 a1, int a2);
signed __int64  sub_1510F(__int64 a1, int a2, _QWORD *a3);
signed __int64  sub_152D5(__int64 a1, const void **a2, const void *a3);
signed __int64  sub_154F1(__int64 a1, __int64 a2, int a3, _QWORD *a4);
signed __int64  sub_15669(__int64 a1, __int64 a2, int a3, _QWORD *a4);
char * sub_15881(__int64 a1, int a2, unsigned __int16 a3);
unsigned __int64  sub_15936(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  sub_15B2B(__int64 a1, unsigned int a2, unsigned __int16 a3, __int64 a4);
signed __int64  sub_15BA6(__int64 a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_15F55(__int64 a1, const void *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_15F8D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_16271(_QWORD *a1, unsigned __int8 a2, _QWORD *a3);
__int64  sub_16564(_BYTE *a1);
__int64  sub_16637(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, int a7);
__int64  sub_169E9(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8);
__int64  sub_16CF6(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, signed int *a6);
__int64  sub_17055(__int64 a1, const char *a2, const char **a3, unsigned int *a4, _QWORD *a5, unsigned int *a6, signed int *a7, _DWORD *a8);
__int64  sub_1729D(_BYTE *a1, signed __int64 *a2, unsigned int *a3, signed __int64 *a4, unsigned int *a5, _DWORD *a6);
__int64  sub_17401(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8);
__int64  sub_17847(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, int a9);
__int64  sub_179A7(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8);
_BOOL4  sub_17DBA(const char **a1, const char ***a2, int a3, __int64 a4);
__int64  sub_181E5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9);
signed __int64  sub_1844C(char *a1, unsigned __int16 a2, __int64 a3, _QWORD *a4);
__int64  sub_18B8D(__int64 a1);
__int64  sub_18BF1(__int64 *a1, int *a2, _DWORD *a3);
__int64  sub_18D14(__int64 a1);
signed __int64  sub_18D8D(signed int *a1, char a2);
__int64  sub_18E56(__int64 a1);
void  sub_18E88(__int64 a1);
__int64  sub_18EB1(__int64 a1, unsigned __int8 a2, int a3);
__int64  sub_18F95(__int64 a1, int a2);
__int64  sub_1902D(__int64 *a1, int *a2, _DWORD *a3);
signed __int64  sub_19120(__int64 *a1, char *a2, __int64 a3, int a4, __int64 a5);
__int64 * sub_19BA2(const char *a1, __int64 *a2);
signed __int64  sub_19DE6(const char **a1, __int64 *a2, char *a3, int a4, const char *a5, int a6);
signed __int64  sub_19ED6(_BYTE *a1, __int64 a2, void **a3, _DWORD *a4);
signed __int64  sub_1A193(char *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5, int a6);
signed __int64  sub_1AF63(const char *a1, __int64 a2, int a3, int a4, _QWORD *a5);
signed __int64  sub_1B236(const char *a1, __int64 a2, _QWORD *a3);
signed __int64  sub_1B28A(_BYTE *a1, __int64 a2, __int64 *a3);
signed __int64  sub_1B39D(const char *a1, __int64 *a2, int a3, _QWORD *a4);
__int64  sub_1B647(_BYTE *a1, __int64 a2, _DWORD *a3);
__int64  sub_1B854(char *a1, void *a2, __int64 a3, int a4);
signed __int64  sub_1C23B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9);
__int64 ** sub_1C6D1(const char *a1, void *a2, __int64 *a3, char a4, _DWORD *a5);
signed __int64  sub_1D702(void *a1, char *a2, __int64 a3, void **a4);
signed __int64  sub_1E592(signed __int64 a1);
signed __int64  sub_1E65A(const char *a1, const char *a2, __int64 a3, __int64 a4, signed __int64 *a5);
__int64  sub_1EAAF(_QWORD *a1, const char **a2, void **a3, int a4);
signed __int64  sub_1F3F0(__int64 a1, int a2, const char *a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_1F79E(__int64 a1, const char *a2, _BYTE *a3);
__int64  sub_1FB5F(__int64 a1, unsigned int a2);
signed __int64  sub_1FBFE(__int64 *a1, const char *a2, int a3, __int64 a4, __int64 a5);
signed __int64  sub_1FEA6(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64  sub_1FF4C(_BYTE *a1, __int64 a2, char *a3, __int64 a4);
__int64  sub_20624(__int64 a1);
__int64  sub_20BE2(__int64 *a1, __int64 a2, __int64 a3);
__int64  sub_21572(__int64 a1, __int64 a2, int a3, char *a4);
signed __int64  sub_2170F(__int64 a1, __int64 a2, __int64 **a3, int a4);
signed __int64  sub_21FB6(__int64 a1, int a2);
signed __int64  sub_220D4(__int64 a1, __int64 a2);
signed __int64  sub_22209(__int64 a1, unsigned int a2, unsigned int a3);
signed __int64  sub_2245A(__int64 a1, __int64 a2, __int64 a3);
signed __int64  sub_22CDC(_QWORD *a1, __int64 **a2, __int64 a3);
__int64  sub_23C04(__int64 a1, __int64 a2);
signed __int64  sub_23C91(__int64 a1, __int64 a2);
__int64  sub_258B4(__int128 a1);
signed __int64  sub_25971(__int64 a1, _QWORD *a2, char *a3, __int64 a4, signed __int64 *a5);
signed __int64  sub_25CE3(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_260D0(__int64 a1, __int64 a2);
__int64  sub_26148(signed __int64 a1, char *a2, char *a3, __int64 *a4, int a5);
signed __int64  sub_26D87(_BYTE **a1, __int64 a2);
signed __int64  sub_271C8(__int64 a1, char *a2);
signed __int64  sub_275C3(char *a1, unsigned int a2, unsigned int a3);
__int64 * sub_27A8D(__int64 a1, __int64 *a2, _DWORD *a3);
signed __int64  sub_27B5A(_QWORD *a1, __int64 a2, _QWORD *a3, _DWORD *a4);
signed __int64  sub_27CDB(__int64 a1, __int64 *a2, __int64 *a3, unsigned int a4, __int64 a5);
signed __int64  sub_27FD3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_28087(_QWORD *a1);
__int64  sub_281C9(__int64 a1);
signed __int64  sub_28290(__int64 a1, int a2, __int64 a3);
__int64  sub_28399(__int64 a1, int a2, __int64 *a3);
signed __int64  sub_28E3C(__int64 a1);
signed __int64  sub_28EDE(void **a1, __int64 a2, unsigned int a3, unsigned __int8 *a4, __int64 a5);
unsigned __int64  sub_2A1A7(__int64 *a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_2A690(__int64 a1, int a2, __int64 a3, int a4, int a5, _DWORD *a6);
signed __int64  sub_2A9F8(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_2AB62(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 a5);
signed __int64  sub_2ABDE(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 *a5);
signed __int64  sub_2B0C1(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5);
signed __int64  sub_2B3F8(__int64 a1, int a2, __int64 a3, int a4);
_DWORD * sub_2B4F8(__int64 a1, _QWORD *a2, unsigned int a3);
void * sub_2B768(__int64 a1, void ***a2, int a3);
signed __int64  sub_2B8E0(__int64 a1, const char *a2);
signed __int64  sub_2BAA8(char *a1, __int64 a2, int a3, _QWORD *a4);
signed __int64  sub_2C0A6(__int64 a1, const char *a2, int a3, _QWORD *a4);
signed __int64  sub_2C282(__int64 a1, _DWORD *a2, int a3, int a4, _QWORD *a5);
signed __int64  sub_2C85B(char *a1, unsigned int a2, unsigned int a3, __int64 *a4);
signed __int64  sub_2CD1C(__int64 a1, __int64 a2, int a3);
_QWORD * sub_2CEE7(__int64 a1, unsigned int a2);
signed __int64  sub_2D16B(__int64 a1, __int64 a2, __int64 a3, __int16 a4);
signed __int64  sub_2DB2D(char *a1);
signed __int64  sub_2DC82(char *a1, __int16 a2, __int64 a3);
signed __int64  sub_2E0DF(__int64 ***a1, __int64 *a2, __int64 a3, int a4);
signed __int64  sub_2E5BD(char *a1);
signed __int64  sub_2EB38(_QWORD **a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_2EE3F(__int64 a1, __int64 a2);
__int64  sub_2F1BE(__int64 a1, unsigned int a2);
signed __int64  sub_2F304(__int64 a1, unsigned __int8 a2, __int64 a3);
signed __int64  sub_2F3D1(__int64 a1, __int64 a2, unsigned int a3);
signed __int64  sub_2F7BD(char *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_3010D(__int64 *a1, __int64 a2, char **a3, int a4, char *a5);
__int64  lyxml_get_ns(__int64 a1, __int64 a2);
unsigned int * sub_304CF(__int64 a1, unsigned int *a2, __int64 a3, int a4);
unsigned int * sub_305D2(__int64 a1, __int64 a2, __int64 a3);
_QWORD * sub_30771(__int64 a1, _QWORD *a2, int a3, int a4);
_QWORD * sub_30929(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5);
_QWORD * lyxml_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD * sub_30B77(__int64 a1, _QWORD *a2, int a3);
unsigned __int64  lyxml_unlink(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  sub_30D07(__int64 a1, __int64 a2, _QWORD *a3);
_QWORD * sub_30DDD(__int64 a1, __int64 a2);
void  sub_30E67(__int64 a1, _QWORD *a2);
void  lyxml_free(__int64 a1, __int64 a2);
unsigned __int64  lyxml_free_withsiblings(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyxml_get_attr(__int64 a1, const char *a2, char *a3);
__int64  sub_3116F(__int64 a1, __int64 a2, _QWORD *a3);
__int64  sub_3127E(void *a1, char *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_31603(void *a1, const char *a2, const char *a3, _DWORD *a4);
char * sub_316C2(void *a1, __int64 a2, char a3, _DWORD *a4, __int64 a5, __int64 a6);
void * sub_3223C(void *a1, char *a2, _DWORD *a3, __int64 a4);
char * sub_32A07(void *a1, void *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
char * lyxml_parse_mem(void *a1, char *a2, unsigned int a3);
__int64  lyxml_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_341EA(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_3430E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_34926(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyxml_print_file(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyxml_print_fd(int a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyxml_print_mem(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyxml_print_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL4  sub_34D50(__int64 a1);
signed __int64  sub_34DD2(__int64 a1, unsigned int a2, __int64 a3);
signed __int64  sub_34EE2(__int64 a1, int a2, __int64 a3, size_t *a4, void **a5);
int  sub_351B4(void *a1, size_t a2);
_BOOL4  sub_351D9(__int64 a1);
signed __int64  sub_35CB4(const char *a1, __int64 a2, __int64 a3, int a4, __int64 *a5, char *a6);
signed __int64  sub_35E42(const char *a1, unsigned __int64 a2, int a3, unsigned __int64 *a4, char *a5);
signed __int64  sub_35FD9(char a1, unsigned __int64 a2, signed __int64 a3, signed __int64 a4, unsigned __int8 a5, __int64 a6, void *a7, char *a8);
signed __int64  sub_363C2(void *a1, char *a2, __int64 a3, char *a4);
char ** sub_36760(char *a1, char **a2, int a3);
__int64  sub_36896(void *a1, char *a2, int *a3);
signed __int64  sub_36C95(void *a1, const char *a2, void **a3);
signed __int64  sub_372F0(void *a1, const char *a2, void **a3, _QWORD *a4);
signed __int64  sub_373C5(void *a1, unsigned int a2, const char **a3, char *a4, int *a5);
__int64  sub_37D41(__int64 a1, __int64 a2, __int64 a3);
signed __int64  sub_37EF5(signed __int64 a1, char **a2, __int64 a3, __int64 **a4, __int64 a5, __int64 *a6, int a7, int a8, int a9);
unsigned __int64  sub_3A9DE(signed __int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_3AB03(__int64 a1, char *a2, __int64 a3, __int64 a4, _BYTE *a5, __int64 a6, __int64 a7, __int16 a8, char ***a9);
signed __int64  sub_3AF7B(_QWORD *a1, _QWORD *a2, char *a3, _DWORD *a4, __int64 a5, __int64 a6);
signed __int64  sub_3B4E8(__int64 a1, __int64 a2, unsigned int a3);
signed __int64  sub_3B53E(__int64 a1, __int64 a2);
signed __int64  sub_3B6AA(const char *a1, __int64 a2, int a3);
signed __int64  sub_3B709(const char *a1, __int64 a2);
signed __int64  sub_3B772(const char *a1, __int64 a2);
signed __int64  sub_3B812(void *a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_3C2C9(void *a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_3C4A2(__int64 a1);
signed __int64  sub_3C596(__int64 *a1, __int64 a2);
signed __int64  sub_3C679(__int64 a1);
signed __int64  sub_3C749(char a1, void **a2, __int64 a3, char a4, __int64 a5, __int64 a6, char *a7);
signed __int64  sub_3C867(_BYTE *a1, int a2);
unsigned __int64  sub_3C9F7(__int64 *a1, unsigned __int64 a2);
signed __int64  sub_3CBF8(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_3CCDF(__int64 *a1);
unsigned __int64  sub_3CDA9(__int64 a1);
signed __int64  sub_3CE2E(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64  sub_3D0D7(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4);
signed __int64  sub_3D333(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_3D700(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_3D76E(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_3DBD2(__int64 a1);
void  sub_3DD01(__int64 a1, void **a2, unsigned __int8 *a3, unsigned __int8 a4);
signed __int64  sub_3DE4E(__int64 a1, __int64 a2, int a3, __int64 a4);
signed __int64  sub_3E3AF(__int64 a1);
signed __int64  sub_3E959(__int64 a1, __int64 a2);
signed __int64  sub_3EDFE(__int64 a1, __int64 **a2);
signed __int64  sub_3EF69(__int64 a1, __int64 a2, int a3, __int64 a4);
signed __int64  sub_3F5FE(__int64 a1);
signed __int64  sub_3FA66(__int64 a1);
signed __int64  sub_3FFC3(__int64 *a1);
signed __int64  sub_40272(void *a1, _BYTE *a2, signed int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_40445(void *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_407F3(__int64 *a1, const char *a2, int a3, char *a4, int a5, int a6);
__int64  sub_40BA1(__int64 a1, _BYTE *a2);
__int64  sub_40CD4(_QWORD *a1);
__int64  sub_40D5F(__int64 a1, const char *a2, int a3);
_BOOL4  sub_40F96(__int64 a1, int a2, int a3, char a4, __int64 *a5, __int64 a6, __int64 *a7, char a8, __int64 a9);
__int64  sub_410A7(void *a1, __int64 a2, const char *a3);
signed __int64  sub_411CA(__int64 *a1, __int64 a2, unsigned int a3, _QWORD *a4, int a5, __int64 a6, __int64 a7);
signed __int64  sub_41746(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_41AE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64  sub_421DA(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4);
signed __int64  sub_426E1(__int64 a1, char *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
signed __int64  sub_4778E(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_47EF1(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64  sub_4852A(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64  sub_489FC(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4);
signed __int64  sub_48AF6(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64  sub_48E4C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_492EA(__int64 a1, __int64 a2, _DWORD *a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_49735(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64  sub_4E308(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
signed __int64  sub_4EC3D(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64  sub_505F3(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64  sub_50E7D(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_51597(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5, char a6, __int64 a7);
_QWORD * sub_51F02(__int64 *a1, __int64 a2, __int64 a3);
unsigned __int8 * sub_522BA(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_52E00(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_53A72(__int64 *a1, char *a2, __int64 a3, int a4, unsigned int a5, __int64 a6);
unsigned __int8 * sub_54422(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
__int64  sub_551D2(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_56721(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_587B3(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_599C2(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_5A553(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_5B1D8(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
unsigned __int8 * sub_5C028(__int64 a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
unsigned __int8 * sub_5CBDA(__int64 *a1, char *a2, __int64 a3, unsigned int a4, __int64 a5);
__int64  sub_5D54B(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD * sub_609BB(void **a1, __int64 a2, __int64 a3);
__int64  sub_60D3A(void *a1, __int64 a2, char *a3, int a4);
__int64  sub_61383(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
signed __int64  sub_6141C(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, char *a5, char *a6, __int64 a7);
signed __int64  sub_6164E(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, int a5, const char *a6, __int64 a7);
_WORD * sub_62180(__int64 a1, __int64 a2, unsigned int a3, unsigned __int16 a4);
_BOOL4  sub_6228E(void **a1, _QWORD *a2, __int64 a3, unsigned int a4, char *a5, char *a6, __int64 a7, __int16 a8, __int16 a9, __int64 a10);
__int64 * sub_62426(__int64 a1, __int64 a2, unsigned int a3);
__int64  sub_62554(__int64 a1, __int64 a2, unsigned int a3);
_BOOL4  sub_627C3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4);
__int64  sub_66992(__int64 a1, __int64 a2, unsigned int a3);
_BOOL4  sub_66AA4(char **a1, __int64 a2, char a3, int a4);
signed __int64  sub_66BD2(__int64 a1, __int64 a2, char *a3, char *a4, __int64 a5, __int64 a6, __int64 a7, char **a8, char **a9, const char *a10);
char *lyd_parse_xml(__int64 a1, _QWORD *a2, unsigned int a3, ...);
signed __int64  sub_69481(signed int a1);
__int64  sub_694B2(__int64 a1);
char * sub_694FC(void *a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_69CA9(void *a1, _BYTE *a2);
char * sub_69FBF(void *a1, char *a2, unsigned int a3, char *a4);
__int64  sub_6A438(void *a1, const char *a2);
__int64  sub_6A529(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_6A75A(char *a1, char **a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
__int64  sub_6AF0B(__int64 *a1, _QWORD *a2, __int64 a3, __int16 a4);
signed __int64  sub_6B4DE(_QWORD *a1, _QWORD *a2, __int64 a3, char a4, __int64 a5, __int64 a6);
signed __int64  sub_6B70E(void *a1, char *a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64  sub_6B929(__int64 a1, _BYTE *a2, _QWORD *a3, char **a4, __int64 a5, __int64 a6, void **a7, unsigned int a8, __int64 a9, _QWORD *a10, const char *a11);
__int64  sub_6D5D5(__int64 a1, __int64 a2, unsigned int a3, __int64 *a4, __int64 a5, __int64 a6);
__int64  sub_6DF5C(__int64 a1);
__int64  sub_6DF6A(__int64 a1, char *a2, size_t a3, __int64 a4);
signed __int64  sub_6E1EC(_WORD *a1, unsigned __int64 a2, size_t a3, __int64 a4, __int64 a5);
signed __int64  sub_6E321(_WORD *a1, unsigned int a2, __int64 a3, __int64 a4);
signed __int64  sub_6E3A6(__int64 a1, void **a2, int a3, __int64 a4);
__int64  sub_6E67A(__int64 a1);
signed __int64  sub_6E6F0(__int16 *a1, __int64 a2);
signed __int64  sub_6E8DA(__int64 a1, __int64 a2, __int64 a3);
_BYTE * sub_6EC05(__int64 a1);
signed __int64  sub_6ED63(char *a1, __int64 a2, __int64 a3);
signed __int64  sub_6EEF7(signed __int64 a1, unsigned int a2, char a3, __int64 a4, _QWORD *a5, _WORD *a6, __int64 a7);
signed __int64  sub_6F3B4(signed __int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
signed __int64  sub_6FED3(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_7018E(__int64 a1, __int64 a2, _QWORD *a3, __int16 a4, __int64 a5);
signed __int64  sub_704EC(__int64 a1, __int64 a2, __int16 a3, __int64 a4, __int64 a5);
signed __int64  sub_708AD(const char **a1, __int64 a2, unsigned __int8 a3);
signed __int64  sub_7090B(__int64 a1, __int64 a2, __int64 a3, char *a4, int a5, const char ***a6, __int64 a7);
signed __int64  sub_70D13(__int64 a1, __int64 a2);
signed __int64  sub_70DDA(__int16 *a1, __int64 *a2, __int64 a3, char *a4, int a5, __int64 a6, __int64 a7);
signed __int64  sub_7133F(__int64 a1, __int64 a2);
signed __int64  sub_71473(__int64 a1, __int64 a2);
__int64  sub_7162D(__int64 a1, __int64 a2);
char ** sub_7168F(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, char *a5, __int64 a6);
signed __int64  lyd_lyb_data_length(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  sub_71FFF(__int64 a1, signed int a2, void **a3, __int64 a4, __int64 a5, __int64 **a6);
unsigned __int64  sub_85F41(unsigned int *a1, __int64 a2, __int64 a3);
signed __int64  sub_86095(__int64 a1, __int64 a2, unsigned __int64 a3);
signed __int64  sub_89947(unsigned __int64 a1);
__int64  sub_8A031(__int64 a1);
__int64  sub_8A175(signed int a1, __int64 a2);
__int64  sub_8A287(FILE *a1, unsigned __int64 a2);
unsigned __int64  sub_8A361(__int64 a1, unsigned __int64 a2);
__int64  sub_8A47F(__int64 a1);
_DWORD * sub_8A526(FILE *a1, int a2, __int64 a3);
void  sub_8A5E0(__int64 a1, __int64 a2);
__int64  sub_8A68F(__int64 a1, FILE *a2, __int64 a3);
__int64  sub_8A769(__int64 a1, __int64 a2);
unsigned __int64  sub_8A81C(__int64 a1, unsigned __int64 a2);
__int64  sub_8A94D(__int64 a1);
unsigned __int64  sub_8AA59(unsigned __int64 a1);
_DWORD * sub_8ABCE(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
_DWORD * sub_8ACE3(const char *a1, unsigned __int64 a2);
_DWORD * sub_8AD15(__int64 a1, int a2, unsigned __int64 a3);
void  __noreturn sub_8AE04(__int64 a1);
__int64  sub_8AE48(__int64 a1);
__int64  sub_8AE61(__int64 a1);
__int64  sub_8AEC3(__int64 a1);
__int64  sub_8AF25(__int64 a1);
__int64  sub_8AF3F(__int64 a1);
__int64  sub_8AF59(__int64 a1);
__int64  sub_8AF72(__int64 a1);
_QWORD * sub_8AF8F(__int64 a1, _QWORD *a2);
__int64  sub_8AFB1(int a1, __int64 a2);
__int64  sub_8B02A(int a1, __int64 a2);
__int64  sub_8B0A3(__int64 a1, __int64 a2);
__int64  sub_8B0C6(__int64 a1, __int64 a2);
__int64  sub_8B0E9(__int64 a1);
__int64  sub_8B102(int a1, __int64 a2);
__int64  sub_8B122(__int64 a1);
__int64  sub_8B13F(__int64 a1, __int64 a2);
__int64  sub_8B165(__int64 a1);
__int64  sub_8B182(__int64 a1, __int64 a2);
__int64  sub_8B1A8(void **a1);
__int64  sub_8B22E(__int64 a1, void **a2);
__int64  sub_8B330(__int64 a1);
__int64  sub_8B3C7(__int64 a1);
void * sub_8B4E8(size_t a1);
void * sub_8B50E(void *a1, size_t a2);
void  sub_8B53F(void *a1);
signed __int64  sub_8B566(void **a1, _QWORD *a2, __int64 a3, __int64 a4, void *a5, char *a6);
__int64  sub_8B60F(void **a1, void *a2, unsigned int a3);
__int64  sub_8B770(__int64 a1, __int64 a2, const char *a3, int a4);
signed __int64  sub_8B91C(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL4  sub_8B9EC(__int64 *a1, __int64 a2, __int64 *a3, void *a4, __int64 a5, __int64 a6);
__int64  sub_8BBC1(__int64 a1, __int64 a2, void *a3, __int64 a4, unsigned int a5);
__int64  sub_8BD50(__int64 a1, __int64 a2, void *a3, __int64 a4, unsigned int a5);
_BOOL4  sub_8BEDF(__int64 *a1, __int64 *a2, __int64 a3, const char *a4, __int64 a5, int a6);
signed __int64  sub_8BFF3(__int64 *a1, __int64 *a2, const char *a3, __int64 a4);
__int64  sub_8C09B(void **a1, __int64 a2, void *a3, __int64 a4, int a5);
signed __int64  sub_8C12B(void **a1, __int64 a2, void *a3);
_QWORD * sub_8C1C0(__int64 *a1, __int64 a2, int a3, char *a4);
_QWORD * sub_8C5FD(__int64 *a1, __int64 a2, signed __int64 a3, void *a4, unsigned int a5, int a6);
__int64  sub_8C74E(void **a1, __int64 a2, void *a3, int a4);
__int64  sub_8C82F(void **a1, __int64 a2, void *a3, int a4);
_BOOL4  sub_8C9A3(__int64 *a1, __int64 a2, __int64 a3);
signed __int64  sub_8CB00(__int64 *a1, char *a2, __int64 a3, const char *a4, __int64 a5);
signed __int64  sub_8CED8(__int64 *a1, __int64 a2, __int64 a3);
signed __int64  sub_8CF89(void **a1, __int64 a2, void *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_8D071(void *a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_8D12E(__int64 a1, char *a2, __int64 a3, int *a4, unsigned int a5, __int64 a6);
__int64  sub_8EB71(__int64 a1, __int64 a2);
_QWORD * sub_8EC20(void *a1, __int64 a2, void *a3, unsigned int a4);
_QWORD * sub_8EF69(void *a1, __int64 a2, void *a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_8F0AF(void *a1, _QWORD *a2, __int64 a3, const char *a4, char a5);
_QWORD * sub_8F1C2(void *a1, __int64 a2, void *a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_8F306(void *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_8F45D(void *a1, __int64 a2, __int64 *a3, _BYTE *a4);
signed __int64  sub_8F644(void *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5);
signed __int64  sub_8F84B(void *a1, __int64 a2, const char **a3, __int64 a4);
signed __int64  sub_8F948(void *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5);
signed __int64  sub_8FAB4(__int64 *a1, __int64 a2, __int64 a3, const char *a4);
__int64  sub_8FB32(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_8FC12(void *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_8FDB8(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_90078(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_901CF(void *a1, _DWORD *a2, __int64 a3, __int64 a4, const char *a5);
signed __int64  sub_908E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_90DFE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_91116(_DWORD *a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_91380(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_918F3(void **a1, __int64 a2, __int64 a3, int a4, __int64 a5);
signed __int64  sub_91D1B(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_91F57(__int64 *a1, __int64 a2, void ****a3, __int64 a4);
_BYTE * sub_920E6(__int64 a1, unsigned int a2, unsigned int a3);
_BYTE * sub_92593(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7);
signed __int64  sub_92A28(__int64 a1, __int64 *a2);
__int64  sub_92C65(__int64 a1, char a2);
__int64  sub_92DC8(__int64 *a1, __int64 a2, __int64 a3, const char *a4, unsigned int a5, __int64 a6);
__int64  sub_92FC8(__int64 *a1, __int64 a2, const char *a3, __int64 a4, __int64 *a5);
void * sub_9316E(__int64 a1, const char *a2, unsigned int a3, char *a4, int a5);
void * sub_93708(__int64 a1, const char *a2, unsigned int a3, __int64 a4);
__int64  sub_93982(__int64 a1, int a2, int a3, int a4, _DWORD *a5, __int64 a6);
_BYTE * sub_93A2E(void *a1, __int64 a2, _BYTE *a3, int a4, int a5, __int64 a6);
void * sub_93CE2(__int64 a1, __int64 a2);
__int64  sub_93E46(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned int a4);
__int64  sub_93FD3(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4);
__int64  sub_94115(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4);
__int64  sub_94223(__int64 a1, unsigned int a2, unsigned int a3);
void  sub_942AF(__int64 a1, __int64 a2);
void  sub_942F8(__int64 a1, __int64 a2);
__int64  sub_943D5(__int64 a1, __int64 a2);
__int64  sub_944B0(__int64 a1, __int64 a2);
void  sub_945C9(__int64 a1, __int64 a2);
void  sub_946EA(__int64 a1, __int64 a2);
void  sub_94729(__int64 a1, __int64 a2);
void  sub_947B0(__int64 a1, __int64 a2);
void  sub_94851(__int64 a1, __int64 a2);
void  sub_948F2(__int64 a1, __int64 a2);
void  sub_94BFB(__int64 a1, unsigned __int8 *a2);
void  sub_94ECB(__int64 a1, __int64 a2);
__int64  sub_94FA3(__int64 a1, __int64 a2, unsigned int a3);
void  sub_952AD(void **a1);
__int64 * sub_9534B(__int64 *a1, unsigned __int8 *a2);
signed __int64  sub_9554F(__int64 *a1, __int64 *a2, unsigned int a3, __int64 a4, __int64 a5);
signed __int64  sub_956B5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_959A9(__int64 *a1, __int64 a2, __int64 a3, int a4, __int64 a5);
signed __int64  sub_95C0C(__int64 *a1, __int64 a2, __int64 a3);
signed __int64  sub_95D5C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_96496(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_96903(__int64 a1, __int64 a2);
signed __int64  sub_96B86(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64  sub_96C40(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64  sub_96DDA(__int64 *a1, __int64 a2, char a3, __int64 a4);
signed __int64  sub_97015(__int64 *a1, __int64 a2, char a3, __int64 a4);
signed __int64  sub_97396(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64  sub_9763D(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5);
signed __int64  sub_97818(void **a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_9797A(__int64 *a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_97ABE(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64  sub_97C42(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64  sub_97F83(__int64 *a1, __int64 a2, _QWORD *a3, unsigned int a4, __int64 a5);
signed __int64  sub_980FB(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4, __int64 a5);
signed __int64  sub_988E7(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_98D32(void **a1, __int64 a2, __int64 a3);
signed __int64  sub_9979D(_QWORD *a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_99DD9(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, void **a5, int a6, unsigned int a7);
__int64  sub_9A401(__int64 a1, unsigned int a2, int a3);
__int64  sub_9A502(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, unsigned int a5);
signed __int64  sub_9A76F(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int16 a5, unsigned __int16 a6);
signed __int64  sub_9A888(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, char a5);
signed __int64  sub_9AB89(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
signed __int64  sub_9ACA3(void *a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64  lys_is_key(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lys_is_disabled(__int64 a1, int a2);
__int64  lys_iffeature_value(__int64 a1);
unsigned __int64  lys_getnext_union_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_9B262(__int64 a1, const char *a2, int a3, char *a4, int a5, int a6, const char ***a7);
signed __int64  sub_9B536(__int64 a1, __int64 a2, char *a3, int a4, int a5, unsigned int a6, const char ***a7);
__int64  lys_getnext(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void  sub_9BBAC(__int64 a1);
__int64  sub_9BDFE(const char *a1, __int64 a2);
__int64  sub_9BF66(__int64 a1, __int64 a2);
signed __int64  sub_9C05E(__int64 a1, __int64 a2, __int64 a3);
signed __int64  sub_9C637(__int64 a1, _QWORD *a2, __int64 a3, unsigned int a4);
__int64  sub_9D438(__int64 a1, const char *a2, int a3, char *a4, __int64 a5, __int64 a6);
__int64  lys_parse_mem(__int64 a1, const char *a2, int a3);
void * sub_9D687(__int64 *a1, const char *a2, int a3, __int64 a4);
__int64  lys_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lys_parse_fd(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_9DC74(__int64 a1, _QWORD *a2, unsigned int a3);
__int64  sub_9DD36(__int64 a1, signed int a2, int a3, char *a4, unsigned int a5, __int64 a6);
_QWORD * sub_9DEAC(__int64 *a1, signed int a2, int a3, __int64 a4);
signed __int64  lys_search_localfile(__int64 a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_9EAFC(__int64 a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
signed __int64  sub_9EB54(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, void *a5, int a6, __int64 *a7, int a8, __int64 a9);
_BYTE * sub_9F26D(__int64 *a1, __int64 a2, int a3, unsigned int a4, __int64 a5);
__int64  sub_9F606(__int64 a1, __int64 a2, void ( *a3)(void **, void *));
void  lys_iffeature_free(__int64 a1, void ****a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_9F7C7(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, int a6, unsigned int a7, __int64 a8);
void * sub_A03B6(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, int a5, unsigned int a6, __int64 a7);
signed __int64  sub_A0555(__int64 *a1, __int64 *a2, void *a3, int *a4, __int64 a5);
signed __int64  lys_ext_instance_substmt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_A1481(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, int a5, int a6, __int64 a7);
void  sub_A1648(__int64 a1, __int64 a2, void ( *a3)(void **, void *));
void  sub_A1BCA(__int64 a1, __int64 a2, void ( *a3)(void **, void *));
__int64 * sub_A1CC4(__int64 *a1, __int64 a2, int a3, __int64 a4);
void  sub_A1E16(__int64 a1, _QWORD *a2, __int64 a3);
void  sub_A1EA9(__int64 a1, __int64 a2, __int64 a3);
void  sub_A1FDD(__int64 a1, __int64 a2, void ( *a3)(void **, void *));
void  sub_A20D9(__int64 a1, __int64 a2, __int64 a3);
void  sub_A2146(__int64 a1, __int64 a2, __int64 a3);
void  sub_A21B3(__int64 a1, __int64 a2, __int64 a3);
void  sub_A227F(__int64 a1, __int64 a2, __int64 a3);
void  sub_A234B(__int64 a1, __int64 a2, __int64 a3);
__int64  sub_A23DC(__int64 a1, __int64 a2, __int64 a3);
__int64  sub_A24CF(__int64 a1, __int64 a2, __int64 a3);
__int64  sub_A260F(__int64 a1, __int64 a2, __int64 a3);
void  sub_A27EE(__int64 a1, __int64 a2, __int64 a3);
void  sub_A28F5(__int64 a1, _QWORD *a2, void ( *a3)(void **, void *));
void  sub_A29AE(__int64 a1, __int64 a2, void ( *a3)(void **, void *));
void  sub_A2A43(__int64 *a1, __int64 a2, void ( *a3)(void **, void *));
void  sub_A2FCB(__int64 a1, __int64 a2, __int64 a3);
void  sub_A33A0(_QWORD **a1, void ( *a2)(_QWORD **, _QWORD *), unsigned int a3);
__int64 * lys_implemented_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_A38CB(__int64 a1, void ( *a2)(void **, void *));
void  sub_A3E76(__int64 *a1, void ( *a2)(void **, void *));
_BOOL4  sub_A3FB0(__int64 a1);
__int64  sub_A4070(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6);
signed __int64  sub_A5E40(__int64 a1);
_BOOL4  sub_A6074(__int64 a1);
__int64  sub_A60D4(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
unsigned __int64  sub_A6294(__int64 a1, __int64 a2);
void  sub_A67C8(unsigned __int8 *a1, void ( *a2)(void **, void *), int a3, int a4);
__int64  sub_A6A3A(__int64 a1);
_BOOL4  sub_A6AC5(__int64 a1, const char *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL4  lys_features_enable(__int64 a1, __int64 a2);
_BOOL4  lys_features_disable(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lys_features_state(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD * lys_features_list(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lys_node_module(__int64 a1);
__int64  lys_main_module(__int64 a1);
__int64  lys_parent(__int64 a1);
signed __int64  sub_A75EB(__int64 a1, unsigned int a2);
__int64  lys_set_private(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_A7706(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lys_xpath_atomize(__int64 a1, int a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lys_node_xpath_atomize(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_A7ED6(__int64 a1, __int64 a2);
__int64  sub_A835C(__int64 a1);
unsigned __int64  sub_A84A7(__int64 a1, __int64 *a2, __int64 a3);
unsigned __int64  sub_A8A9A(__int64 a1);
unsigned __int64  sub_A8D1D(__int64 a1);
__int64  sub_A8FAF(__int64 a1, __int64 *a2, __int64 a3);
unsigned __int64  sub_A903F(__int64 a1, __int64 *a2, __int64 a3);
unsigned __int64  sub_A91FC(__int64 a1);
unsigned __int64  sub_A9496(__int64 a1);
signed __int64  sub_A9962(__int64 a1, __int64 a2);
signed __int64  lys_set_implemented(__int64 a1);
signed __int64  sub_AA3F6(__int64 a1);
__int64  lys_path(char *a1, char a2);
char * lys_data_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_AA881(__int64 a1, __int64 a2, __int64 a3);
__int64  lys_find_path(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_AAC84(__int64 a1, __int64 a2, unsigned int a3);
void  sub_AAE3B(__int64 a1, void ***a2, unsigned int a3, void ( *a4)(void **, void *));
signed __int64  sub_ABBCE(_QWORD *a1, _QWORD *a2);
_BOOL4  sub_ABD8D(_QWORD *a1);
signed __int64  sub_ABE70(_BYTE **a1, _BYTE **a2, int a3);
signed __int64  sub_ABF28(__int64 a1, __int64 a2, int a3);
signed __int64  sub_AC44F(__int64 *a1, _QWORD **a2, int a3, __int64 a4);
void  sub_AC551(_QWORD *a1, unsigned int *a2);
signed __int64  sub_AC63C(const char **a1);
_QWORD * sub_AC884(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_AC9EF(unsigned int *a1, unsigned int **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_ACC62(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  sub_ACC82(_QWORD *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6);
void  sub_ACE40(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_ACE6B(_QWORD *a1, __int64 a2, __int64 a3);
signed __int64  sub_ACF5E(_QWORD *a1, _QWORD *a2, __int64 a3, int a4);
signed __int64  sub_AD12C(_QWORD *a1, __int64 **a2, __int64 a3, __int64 a4, int a5, __int64 a6);
__int64  sub_AD45A(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned int a5, unsigned int a6);
signed __int64  sub_AD9B9(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
__int64  sub_ADEE6(__int64 a1, __int64 *a2, __int64 a3, int a4, unsigned int a5, __int64 a6, char *a7);
__int64  sub_AE151(__int64 a1, __int64 a2, int a3, unsigned int a4, unsigned int *a5);
__int64 lyd_parse_mem(__int64 a1, __int64 a2, int a3, __int64 a4, ...);
__int64  sub_AE545(__int64 a1, int a2, int a3, unsigned int a4, unsigned int *a5, __int64 a6);
__int64 lyd_parse_fd(__int64 a1, int a2, int a3, __int64 a4, ...);
__int64 lyd_parse_path(__int64 a1, const char *a2, int a3, __int64 a4, ...);
__int64  sub_AE92C(__int64 a1, __int64 a2, int a3);
_BYTE * sub_AE9DE(__int64 a1, __int64 a2, char a3);
_BYTE * lyd_new(__int64 a1, __int64 a2, char *a3);
_BYTE * sub_AECBE(__int64 a1, void *a2, char a3);
char ** sub_AEDF4(__int64 a1, __int64 a2, void *a3, unsigned int a4, unsigned int a5);
char ** lyd_new_leaf(__int64 a1, __int64 a2, char *a3, __int64 a4);
__int64  sub_AF16B(__int64 a1);
unsigned __int64  sub_AF24B(_QWORD *a1);
signed __int64  lyd_change_leaf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void * sub_AF724(__int64 a1, __int64 a2, void *a3, unsigned int a4);
void * lyd_new_anydata(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE * lyd_new_yangdata(__int64 *a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
_BYTE * lyd_new_output(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
char ** lyd_new_output_leaf(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
void * lyd_new_output_anydata(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
char * sub_B02CA(__int64 a1, const char *a2, int a3);
signed __int64  sub_B045A(__int64 *a1, __int64 a2, _BYTE *a3, _DWORD *a4);
__int64  sub_B08C4(__int64 a1, _BYTE *a2, unsigned int a3, int a4, __int64 a5, __int64 a6);
__int64 * lyd_new_path(__int64 *a1, void *a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyd_list_pos(_QWORD *a1);
_BYTE * sub_B20A7(_QWORD *a1, _QWORD *a2, __int64 a3, void *a4, unsigned int a5);
__int64  sub_B2578(__int64 a1, __int64 a2);
__int64  sub_B28DB(__int64 *a1, __int64 a2);
unsigned __int64  sub_B2929(unsigned __int64 a1, unsigned __int64 a2);
signed __int64  sub_B308E(__int64 *a1, __int64 a2);
signed __int64  sub_B317C(_BYTE *a1, __int64 a2);
signed __int64  sub_B3375(__int64 a1, __int64 a2, __int16 a3);
signed __int64  sub_B384E(__int64 *a1, _QWORD *a2, __int16 a3);
signed __int64  lyd_merge_to_ctx(__int64 **a1, _QWORD *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyd_merge(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
void  lyd_free_diff(void **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_B4516(void **a1, _DWORD *a2, unsigned int a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_B47F2(_QWORD *a1, __int64 a2);
__int64  sub_B491E(__int64 a1);
signed __int64  sub_B49D8(_BYTE *a1, __int64 a2, char a3);
signed __int64  sub_B4A6E(__int64 a1, __int64 a2, void **a3, _DWORD *a4, _DWORD *a5, __int64 a6, __int64 a7, char a8);
_BOOL4  sub_B4CF2(__int64 a1, __int64 a2);
signed __int64  sub_B4DF4(__int64 a1, _QWORD *a2, __int64 a3);
void ** sub_B5143(__int64 a1, _DWORD *a2);
void ** lyd_diff(_QWORD *a1, _QWORD *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_B6CAE(__int64 a1);
__int64  sub_B6F47(_QWORD *a1, _QWORD *a2);
signed __int64  sub_B70F6(_QWORD *a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lyd_insert(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lyd_insert_sibling(__int64 *a1, __int64 a2);
signed __int64  sub_B7B96(__int64 *a1, __int64 *a2, int a3, int a4);
signed __int64  lyd_insert_before(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lyd_insert_after(__int64 *a1, __int64 a2);
__int64  sub_B857F(__int64 *a1);
signed __int64  sub_B8611(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  compar(const void *a1, const void *a2);
signed __int64  lyd_schema_sort(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_B8BF3(char **a1, __int64 a2, void *a3, __int64 a4, unsigned int a5, _QWORD *a6, __int64 a7);
signed __int64  lyd_validate(char **a1, unsigned int a2, _QWORD *a3);
signed __int64  lyd_validate_modules(char **a1, void ***a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lyd_validate_value(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_B9E6F(__int64 a1, unsigned __int64 a2, __int64 a3);
signed __int64  sub_BA11B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  lyd_unlink(_QWORD *a1);
__int64  sub_BA2CA(unsigned __int64 a1, __int64 a2, __int64 a3, char a4);
_QWORD * sub_BA418(__int64 a1, __int64 a2, __int64 a3, char a4);
signed __int64  sub_BAAC6(char *a1, __int64 a2, __int64 a3, void *a4, char a5, __int64 a6);
__int64 * lyd_dup_to_ctx(__int64 *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyd_dup(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD * sub_BB2B8(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
_QWORD * sub_BB4DB(_QWORD *a1, unsigned int a2, __int64 a3);
_QWORD * lyd_dup_withsiblings(_QWORD *a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  lyd_free_attr(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD * sub_BB881(_QWORD *a1, __int64 a2);
void * lyd_insert_attr(unsigned __int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
void  sub_BBE52(void *a1, int a2, char a3, signed __int64 a4, __int64 a5, _QWORD *a6, _DWORD *a7, _BYTE *a8);
void  sub_BBF19(__int64 a1);
void  sub_BC13E(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void  lyd_free(_QWORD *a1);
signed __int64  sub_BC223(_QWORD *a1);
signed __int64  lyd_free_withsiblings(_QWORD *a1);
signed __int64  sub_BC387(const char *a1, __int64 a2, _QWORD *a3);
__int64  lyd_path(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_BC8A8(__int64 *a1, __int64 *a2, const char *a3, __int64 a4);
__int64  lyd_find_path(char *a1, __int64 a2);
__int64  lyd_find_instance(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyd_first_sibling(__int64 a1);
void * ly_set_new(__int64 a1);
void  ly_set_free(void **a1);
signed __int64  ly_set_contains(__int64 a1, __int64 a2);
_QWORD * ly_set_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  ly_set_add(__int64 a1, __int64 a2, char a3);
signed __int64  ly_set_merge(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  ly_set_rm_index(__int64 a1, unsigned int a2);
__int64  ly_set_rm(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  ly_set_clean(__int64 a1);
signed __int64  lyd_wd_default(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_BDCC8(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64  sub_BDDC2(__int64 a1, unsigned int a2);
unsigned __int64  lyd_free_val_diff(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_BE08A(_QWORD **a1, _QWORD *a2, __int64 a3, __int64 a4, int a5);
signed __int64  sub_BE34C(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, int a5);
__int64  sub_BE6C9(__int64 a1, __int64 a2);
signed __int64  sub_BE818(__int64 *a1, __int64 *a2, _BYTE *a3, __int64 a4, int a5, int a6, __int64 a7);
signed __int64  sub_BF27C(__int64 *a1, __int64 a2, __int64 a3, signed int a4, __int64 a5, __int64 a6);
signed __int64  sub_BF7F8(char ***a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char **a7, __int64 a8, int a9);
__int64  lyd_node_module(__int64 a1);
double  lyd_dec64_to_double(const char **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  lyd_leaf_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void * ly_get_loaded_plugins(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  ly_clean_plugins(__int64 a1);
__int64  sub_C03C5(void *a1, const char *a2);
signed __int64  ly_register_types(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_C0875(void *a1, const char *a2);
signed __int64  ly_register_exts(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD * sub_C0ED7(void *a1);
unsigned __int64  sub_C0FA9(DIR *a1, __int64 a2, int a3);
int  ly_load_plugins(__int64 a1);
__int64  sub_C1405(const char *a1, const char *a2, char *a3);
signed __int64  lys_ext_instance_presence(__int64 a1, __int64 a2, unsigned __int8 a3);
signed __int64  lys_ext_complex_get_substmt(int a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_C1906(unsigned int a1);
char * sub_C1A2B(_BYTE *a1, _BYTE *a2, _BYTE *a3);
signed __int64  sub_C1B58(__int64 *a1, _BYTE *a2, _QWORD *a3, __int64 a4);
unsigned __int64  sub_C1CED(signed __int64 a1, __int64 a2, __int64 a3);
_BOOL4  sub_C1FAD(_QWORD *a1, _QWORD *a2);
signed __int64 sub_C1FF7(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...);
int  sub_C236C(__int64 a1);
__int64  sub_C23A5(__int64 a1, const void *a2, size_t a3);
signed __int64  sub_C2676(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64  sub_C2888(__int64 a1, __int64 a2, const void *a3, size_t a4);
__int64  sub_C29AA(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, int *a5, signed int *a6);
__int64  sub_C2DA0(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4);
__int64  sub_C2E22(_QWORD *a1, __int64 *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
__int64  lys_print_file(__int64 a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6);
signed __int64  lys_print_path(const char *a1, __int64 *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6);
__int64  lys_print_fd(int a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6);
signed __int64  lys_print_mem(_QWORD *a1, __int64 *a2, unsigned int a3, const char *a4, unsigned int a5, __int64 a6);
__int64  lys_print_clb(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, const char *a5, __int64 a6, unsigned int a7);
signed __int64  sub_C3393(__int64 a1, __int64 a2, const char *a3, void ( *a4)(__int64, signed __int64, int *), void ( *a5)(__int64, signed __int64, int *), void ( *a6)(__int64, signed __int64, int *), void ( *a7)(__int64, __int64, int *), void ( *a8)(__int64, __int64, int *), void ( *a9)(__int64, __int64, int *), void ( *a10)(__int64, __int64, int *), void ( *a11)(__int64, __int64, int *), void ( *a12)(__int64, __int64, int *), void ( *a13)(__int64, __int64, int *), void ( *a14)(__int64, __int64, int *), void ( *a15)(__int64, __int64, int *), void ( *a16)(__int64, __int64, int *), void ( *a17)(__int64, __int64, int *), void ( *a18)(__int64, __int64, int *), void ( *a19)(__int64, __int64, int *), void ( *a20)(__int64, __int64, int *));
signed __int64  sub_C3DD9(_DWORD *a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64  lyd_print_file(__int64 a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64  lyd_print_path(const char *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64  lyd_print_fd(int a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64  lyd_print_mem(_QWORD *a1, __int64 *a2, int a3, char a4, __int64 a5, __int64 a6);
signed __int64  lyd_print_clb(__int64 a1, __int64 a2, __int64 *a3, unsigned int a4, unsigned int a5, __int64 a6);
signed __int64  sub_C424C(__int64 a1, char a2);
signed __int64  sub_C46A7(_QWORD *a1, char a2);
void  sub_C488D(__int64 a1);
const char * sub_C494A(_DWORD *a1);
const char * sub_C49BD(unsigned int a1);
unsigned __int64  sub_C4AE9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_C4D98(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_C54F2(__int64 a1, unsigned __int16 a2, void **a3, unsigned __int16 *a4, _WORD *a5, __int64 a6);
signed __int64  sub_C5614(__int64 a1, __int64 *a2, int a3, int a4, __int64 a5, void **a6, unsigned __int16 *a7, _WORD *a8);
void * sub_C5D5B(__int64 a1, __int64 *a2, int a3, int a4);
char * sub_C5EB1(__int64 a1, __int64 a2, void **a3, int a4, __int64 a5, __int64 a6);
long double  sub_C607E(const char *a1);
_BOOL4  sub_C6102(__int64 a1, __int64 a2);
unsigned __int64  sub_C6158(__int64 a1, __int64 a2, int a3);
unsigned __int64  sub_C639B(__int64 a1, __int64 a2, int a3);
signed __int64  sub_C64AC(__int64 a1, __int64 a2, int a3, int a4);
__int64  sub_C65F5(__int64 a1);
void  sub_C6688(void *a1);
void ** sub_C66B8(const char **a1);
__int64  sub_C6974(__int64 a1, char *a2, unsigned __int16 a3);
__int64  sub_C69DE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int128 a7);
_DWORD * sub_C6A0D(_DWORD *a1, int a2);
void  sub_C6A3F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_C6D49(__int64 a1);
void * sub_C6DA0(_DWORD *a1, unsigned int a2);
void * sub_C6ECE(unsigned int *a1);
signed __int64  sub_C705F(__int64 a1, __int64 a2, int a3, int a4);
signed __int64  sub_C7105(__int64 a1, __int64 a2, int a3, int a4);
unsigned __int64  sub_C7180(unsigned int *a1, unsigned int *a2);
unsigned __int64  sub_C7395(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5);
signed __int64  sub_C765D(__int64 a1, __int64 a2, int a3);
unsigned __int64  sub_C77EE(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5);
__int64  sub_C78F8(__int64 a1);
__int64  sub_C79D5(_QWORD *a1, int a2, _QWORD *a3, int a4, _QWORD **a5, unsigned int *a6);
signed __int64  sub_C7C5E(__int64 a1, _QWORD *a2, int a3);
__int64  sub_C7E06(__int64 a1, __int64 a2);
signed __int64  sub_C7E78(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64  sub_C81AC(void *a1, __int64 a2, int a3, __int64 a4, __int64 *a5, unsigned int a6, int a7);
signed __int64  sub_C8295(__int64 a1, __int64 a2, int a3);
__int64  sub_C863F(__int64 a1);
signed __int64  sub_C870E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_C8BDA(int *a1, __int64 a2);
signed __int64  sub_C8ED8(__int64 a1, int a2, __int16 a3, __int16 a4);
signed __int64  sub_C9129(void *a1, __int64 a2, unsigned __int16 a3, int a4, __int64 a5, __int64 a6);
_DWORD * sub_C9229(__int64 a1, unsigned __int16 a2, __int16 a3);
signed __int64  sub_C940B(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_C94CA(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_C989E(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_C99D7(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_CA839(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_CAB46(void *a1, __int64 a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_CAC93(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_CAE73(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_CB062(void *a1, _QWORD *a2, unsigned __int16 *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_CB1CB(void *a1, char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD * sub_CB4D2(void *a1, const char *a2);
__int64  sub_CC407(__int64 a1);
__int64  sub_CC474(signed __int64 a1);
__int64  sub_CC619(signed __int64 a1);
__int64  sub_CC70D(signed __int64 a1, unsigned int a2);
unsigned __int64  sub_CC805(signed __int64 a1, __int64 a2);
signed __int64  sub_CC8D8(signed __int64 a1, signed __int64 a2);
unsigned __int64  sub_CC97E(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, unsigned __int16 a6);
unsigned __int64  sub_CCC96(__int64 a1, _QWORD *a2, __int64 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int16 a6);
signed __int64  sub_CD097(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6);
__int64  sub_CD490(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64  sub_CD50E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
signed __int64  sub_CD74E(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64  sub_CDA61(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6);
signed __int64  sub_CDD3F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_CDEAF(__int64 a1, unsigned __int16 a2, __int64 a3, void **a4, __int64 a5, char a6);
signed __int64  sub_CDF8D(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
_BOOL4  sub_CE2E0(__int64 a1, const char *a2);
signed __int64  sub_CE3C6(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6);
signed __int64  sub_CE87B(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, __int64 a6);
signed __int64  sub_CED6F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_CEFE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, char a6);
signed __int64  sub_CF037(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64  sub_CF0E9(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64  sub_CF4F3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
signed __int64  sub_CF5DD(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6);
signed __int64  sub_CF8C9(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6);
signed __int64  sub_CF913(__int64 *a1, __int16 a2, __int64 a3, void **a4, _DWORD *a5, char a6);
__int64  sub_CFC0C(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, char a6);
signed __int64  sub_CFC7C(__int64 *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_D010E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64  sub_D01A8(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64  sub_D0264(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
signed __int64  sub_D034E(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6);
signed __int64  sub_D06AD(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
signed __int64  sub_D0925(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, _DWORD *a5, int a6);
signed __int64  sub_D0C1C(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64  sub_D0CD8(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, char a6);
signed __int64  sub_D0FED(__int64 *a1, __int16 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64  sub_D1588(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64  sub_D18C4(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
signed __int64  sub_D1BD3(_DWORD **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_D1FBB(__int64 a1, __int64 a2, __int64 a3, void **a4, _DWORD *a5, __int64 a6);
signed __int64  sub_D21EC(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, int a6);
__int64  sub_D27D8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, char a6);
__int64  sub_D282F(const char *a1, unsigned __int16 a2, __int64 a3, __int64 a4, int a5, int a6);
__int64  sub_D2AFF(__int64 a1, int a2, _DWORD *a3);
__int64  sub_D2BEA(__int64 a1, char a2, _DWORD *a3);
unsigned __int64  sub_D2C95(__int64 a1, __int64 a2, int a3);
unsigned __int64  sub_D2D37(__int64 a1, __int64 a2, char a3);
signed __int64  sub_D2DEA(_BYTE *a1, int a2, char *a3, __int64 a4, char a5);
signed __int64  sub_D2EBE(__int64 a1, int a2, char *a3, __int64 a4, char a5);
signed __int64  sub_D2FD6(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64  sub_D345B(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64  sub_D3A01(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64  sub_D3F81(__int64 a1, __int64 a2, char *a3, __int16 a4, int a5);
signed __int64  sub_D4437(__int64 a1, __int64 a2, char *a3, unsigned __int16 a4, int a5);
signed __int64  sub_D476C(_DWORD *a1, _DWORD *a2, _QWORD **a3, int a4);
signed __int64  sub_D4935(__int64 a1, _QWORD **a2, char *a3, unsigned __int16 a4, int a5);
signed __int64  sub_D4CD2(__int64 a1, int a2, unsigned int a3, __int64 a4, __int64 a5, int a6, char a7);
signed __int64  sub_D4FB0(_QWORD *a1, __int64 a2, int a3, char a4);
signed __int64  sub_D5245(__int64 a1, __int64 a2, int a3, char a4);
signed __int64  sub_D5430(__int64 a1, __int64 a2, int a3, int a4);
signed __int64  sub_D5851(__int64 a1, __int64 a2, int a3, char a4);
signed __int64  sub_D5BFA(long double *a1, long double *a2, _BYTE *a3, __int64 a4, __int64 *a5, int a6);
signed __int64  sub_D65EB(__int64 a1, long double *a2, _BYTE *a3, __int64 a4, __int64 *a5, int a6);
_WORD * sub_D6835(_QWORD *a1, _WORD *a2, __int64 a3);
signed __int64  sub_D6985(_QWORD *a1, _WORD *a2, _QWORD **a3, __int64 *a4, int a5, int a6, __int64 a7, unsigned int a8);
__int64  sub_D729A(_QWORD *a1, __int16 *a2, __int64 a3, __int64 *a4, __int64 a5, int a6, int a7);
signed __int64  sub_D7B49(__int64 a1, __int16 *a2, _QWORD **a3, __int64 *a4, int a5, _QWORD *a6, unsigned int a7);
__int64  sub_D8060(_QWORD *a1, __int16 *a2, __int64 a3, void **a4, __int64 a5, int a6);
signed __int64  sub_D8307(__int64 a1, unsigned __int16 *a2, __int64 a3, __int64 *a4, const char **a5, unsigned int a6);
signed __int64  sub_D9687(void *a1, _QWORD *a2, _WORD *a3, __int64 a4);
signed __int64  sub_D99FD(__int64 a1, __int16 *a2, _QWORD **a3, __int64 *a4, _QWORD *a5, unsigned int a6);
__int64  sub_DA06F(_QWORD *a1, _WORD *a2, unsigned __int16 a3, _QWORD **a4, __int64 *a5, unsigned int *a6, int a7);
signed __int64  sub_DA41B(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, void **a5, __int64 a6, int a7);
__int64  sub_DA6A9(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64  sub_DAB0C(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64  sub_DAF68(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64  sub_DB3CB(_QWORD *a1, unsigned __int16 *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64  sub_DB8DA(_QWORD *a1, _WORD *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64  sub_DBD1D(_QWORD *a1, _WORD *a2, unsigned __int16 a3, __int64 a4, __int64 *a5, unsigned int *a6, int a7);
__int64  sub_DC160(_QWORD *a1, __int16 *a2, unsigned int a3, _QWORD **a4, __int64 *a5, unsigned int *a6, unsigned int a7);
signed __int64  sub_DC4B2(const char *a1, char *a2, int a3, void **a4, _DWORD *a5, __int64 a6);
signed __int64  sub_DC765(__int64 a1, int a2, __int64 a3, __int64 *a4, int a5);
__int64  sub_DCFF7(const char *a1, __int64 a2, int a3, _DWORD *a4, unsigned int a5, _QWORD *a6);
__int64  sub_DD261(__int64 a1, void **a2, int a3);
signed __int64  sub_DDEA9(__int64 a1);
void  sub_DE34B(__int64 a1, const char *a2, int a3);
signed __int64  sub_DE4D3(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_DE519(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_DE573(__int64 a1, int a2, __int64 a3, const char *a4, int a5, __int64 a6);
signed __int64  sub_DE71C(__int64 a1, int a2, int a3, unsigned int a4, const char *a5, __int64 a6, __int64 a7, unsigned __int8 a8);
signed __int64  sub_DE97F(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_DEA7A(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
unsigned __int64  sub_DF01A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_DF0C8(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_DF35D(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_DF66E(__int64 a1, unsigned int a2, __int64 *a3, const char **a4);
unsigned __int64  sub_DF89A(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64  sub_DF961(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64  sub_DFA28(__int64 a1, int a2, __int64 *a3, __int64 a4);
signed __int64  sub_E0678(__int64 a1, unsigned int a2, __int64 *a3, const char **a4);
signed __int64  sub_E0707(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E0803(__int64 a1, unsigned int a2, __int64 *a3, const char **a4);
signed __int64  sub_E0D20(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64  sub_E1A74(__int64 a1, int a2, __int64 a3);
signed __int64  sub_E1BDF(__int64 a1, int a2, __int64 *a3, __int64 *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E1E7A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E2106(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E252D(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E26DF(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_E2926(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E2CCF(__int64 a1, unsigned int a2, __int64 a3);
signed __int64  sub_E2F1F(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E34E4(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E3CC6(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E3F0E(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_E417B(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E4386(__int64 a1, unsigned int a2, __int64 a3);
unsigned __int64  sub_E453A(__int64 a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_E479A(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_E4A49(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_E4BDA(__int64 a1, int a2, __int64 a3);
__int64  sub_E5C7A(__int64 a1, __int64 a2);
unsigned __int64  sub_E5CA1(__int64 a1, int a2, __int64 *a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, _DWORD *a8);
unsigned __int64  sub_E5DFA(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, _DWORD *a6);
_WORD * sub_E5F4E(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, unsigned __int16 a8, unsigned __int16 a9, _DWORD *a10);
unsigned __int64  sub_E6059(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5, __int64 a6, unsigned int a7);
signed __int64  sub_E8DAF(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7);
signed __int64  sub_E8EE6(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_E8F8C(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_E8FD2(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_E904C(__int64 a1, int a2, int a3, char a4, __int64 a5, __int64 a6, __int64 a7, unsigned __int8 a8);
signed __int64  sub_E933F(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_E943A(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
unsigned __int64  sub_E99DA(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_E9C9B(__int64 a1, int a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6);
unsigned __int64  sub_E9F06(__int64 a1, int a2, __int64 a3, _BYTE **a4, __int64 a5);
unsigned __int64  sub_EA002(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_EA0C6(__int64 a1, int a2, __int64 *a3, const char **a4);
unsigned __int64  sub_EA2FF(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64  sub_EA3C7(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6, __int64 a7, unsigned int a8);
unsigned __int64  sub_EA48F(__int64 a1, int a2, __int64 *a3, __int64 a4);
unsigned __int64  sub_EB0CE(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64  sub_EB1FC(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_EB2F8(__int64 a1, int a2, __int64 *a3, const char **a4);
unsigned __int64  sub_EB84B(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64  sub_EC5A5(__int64 a1, int a2, __int64 *a3, const char **a4);
signed __int64  sub_EC70B(__int64 a1, int a2, __int64 *a3, __int64 *a4);
unsigned __int64  sub_EC9A9(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_ECC45(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_ED082(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_ED24A(__int64 a1, int a2, __int64 *a3);
signed __int64  sub_ED4A7(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_ED853(__int64 a1, int a2, __int64 a3);
signed __int64  sub_EDABE(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_EE086(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_EE862(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_EEAC0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_EED3F(__int64 a1, int a2, __int64 a3);
unsigned __int64  sub_EEF63(__int64 a1, int a2, __int64 a3);
unsigned __int64  sub_EF13E(__int64 a1, int a2, __int64 *a3);
unsigned __int64  sub_EF3B4(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
signed __int64  sub_EF5BC(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64  sub_EF756(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_EF8CE(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_F08B1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F08F7(__int64 a1, int a2, __int64 *a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, _DWORD *a8);
unsigned __int64  sub_F0A50(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, _DWORD *a6);
_WORD * sub_F0BA4(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, unsigned __int16 a8, unsigned __int16 a9, _DWORD *a10);
unsigned __int64  sub_F0CAF(__int64 a1, int a2, __int64 a3, int a4, char a5, __int64 a6, unsigned int a7);
const char * sub_F391A(unsigned int a1);
void  sub_F3A17(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, _DWORD *a6);
void  sub_F3AD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, _DWORD *a6);
void  sub_F3B77(__int64 a1, char a2, _DWORD *a3);
void  sub_F3C04(__int64 a1, char a2, _DWORD *a3);
void  sub_F3C8C(__int64 a1, char a2, _DWORD *a3);
void  sub_F3D18(__int64 a1, __int16 a2, _DWORD *a3);
signed __int64  sub_F3D9C(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _DWORD *a5, __int64 a6);
signed __int64  sub_F3EB4(__int64 a1, __int64 *a2, _DWORD *a3);
void  sub_F3F83(__int64 a1, __int64 *a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F41B3(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F42A6(__int64 a1, __int64 a2, int a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F4F54(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F4F86(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F5130(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
signed __int64  sub_F521A(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F526E(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F52C2(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
signed __int64  sub_F5438(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F5523(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F56F9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, const char **a5, __int64 a6);
unsigned __int64  sub_F5B0E(__int64 a1, __int64 a2, _DWORD *a3);
unsigned __int64  sub_F5C40(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F5E70(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F61D6(__int64 a1, __int64 a2, unsigned __int8 a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F6930(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F6BB4(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F6CAB(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F6EDF(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64  sub_F6FC9(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4);
unsigned __int64  sub_F7166(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64  sub_F7228(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F7353(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F74CB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F7505(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F753F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_F7579(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F75B3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F78E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F7B7C(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F7E29(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F804F(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F82CE(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F8599(__int64 a1, __int64 a2, _DWORD *a3);
int  sub_F8941(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F8B8C(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F8D51(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F8F2B(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F9025(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F911F(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F9323(__int64 a1, __int64 a2, _DWORD *a3);
signed __int64  sub_F957C(__int64 a1, __int64 a2, _DWORD *a3);
__int64  sub_F97D5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_F9917(_QWORD *a1, __int64 *a2);
_QWORD * sub_F99DA(_QWORD **a1);
__int64 * sub_F9A1C(__int64 a1, __int64 a2, __int64 **a3, char a4, __int64 a5, __int64 a6);
signed __int64  sub_F9E66(__int64 a1, _BYTE *a2, char a3);
signed __int64  sub_FA42C(__int64 a1, int a2, __int64 a3, int a4, char a5);
signed __int64  sub_FAB93(__int64 a1, int a2, __int64 a3, int a4, unsigned int a5);
signed __int64  sub_FAE83(__int64 a1, int a2, __int64 a3, int a4, unsigned int a5, unsigned int a6);
signed __int64  sub_FB19F(__int64 a1, int a2, __int64 a3, int a4, int a5);
__int64  sub_FB69D(__int64 a1, int a2, _QWORD *a3, unsigned int a4, unsigned int a5);
signed __int64  sub_FB855(_DWORD *a1, _QWORD *a2, signed int a3);
__int64  sub_FBBCD(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_FBC92(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned int a5);
__int64  sub_FBFBE(signed int a1, __int64 a2, __int64 a3, __int64 *a4);
__int64  sub_FC11E(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64  sub_FC2E9(__int64 a1);
__int64  sub_FC398(__int64 a1, unsigned int a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_FC46B(__int64 a1, __int64 a2, __int64 a3);
__int64  sub_FC508(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, __int64 a6);
signed __int64  sub_FCA87(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_FCC11(_QWORD *a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6, _QWORD *a7);
__int64  sub_FCE3A(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64  sub_FCFB0(_QWORD *a1, unsigned int a2, unsigned __int16 a3, __int64 a4, int a5, __int64 a6, int a7, __int64 a8);
unsigned __int64  sub_FDC13(_QWORD *a1, __int64 a2, __int64 a3);
__int64  sub_FDDA8(__int64 a1, unsigned int a2, unsigned __int8 a3, char *a4, __int64 a5);
signed __int64  sub_FDED1(_QWORD *a1, __int64 *a2, __int64 a3, unsigned int a4, unsigned int a5);
signed __int64  sub_FE7ED(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FE96A(__int64 a1, __int64 a2, __int64 a3, const char *a4);
signed __int64  sub_FEBD1(__int64 a1, __int16 a2, __int16 a3, int a4, __int64 a5, __int64 a6);
signed __int64  sub_FEE4A(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 a4, __int64 a5, __int64 a6);
signed __int64  sub_FEF59(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FEFD0(__int64 a1, __int64 *a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FF0A9(__int64 a1, __int64 *a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FF177(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FF3FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FFF2C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FFF5A(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_FFFD4(__int64 a1, __int64 **a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_1000F2(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_1001C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_10051E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_100621(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_100729(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_10082B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_100AC4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_100D53(__int64 a1, __int64 a2);
signed __int64  sub_100FC5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_1010F2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_101336(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_101432(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_1016EE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_1019AE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_101B50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_101CF8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_101E9B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_10203F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_102228(__int64 a1, __int64 a2);
signed __int64  sub_102381(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_10249F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_1025D9(__int64 a1, __int64 a2);
signed __int64  sub_1026D7(__int64 a1, __int64 a2);
signed __int64  sub_1027D5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_10293C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_102A81(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_102BC6(__int64 a1, __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_102CD8(__int64 a1, __int64 a2);
signed __int64  sub_102E00(__int64 a1, int a2, _QWORD *a3, __int64 a4);
signed __int64  sub_1031F1(__int64 a1, const char *a2, _QWORD **a3, int a4, unsigned int a5, unsigned int a6);
signed __int64  sub_1037A1(__int64 a1, unsigned int a2, __int64 **a3, int a4, unsigned int a5);
signed __int64  sub_103AA8(__int64 a1, unsigned int a2, __int64 **a3, int a4, unsigned int a5, unsigned int a6);
signed __int64  sub_104282(__int64 a1, unsigned int a2, __int64 a3, int a4, int a5);
signed __int64  sub_104827(__int64 a1, unsigned int a2, __int64 *a3, int a4, unsigned int a5, unsigned int a6);
signed __int64  sub_104C16(__int64 a1, __int64 *a2, unsigned int a3);
__int64  sub_104F44(__int64 a1);
signed __int64 sub_104F52();
_BOOL4  sub_104F6C(_QWORD *a1, _QWORD *a2);
signed __int64  sub_104FAD(__int64 a1, const char **a2, unsigned __int8 a3, int a4);
signed __int64  sub_1050EE(__int64 a1, __int64 a2, __int64 a3);
void  sub_1053BB(__int64 a1, __int64 a2);
void ** sub_105659(__int64 a1, __int64 a2, int a3);
__int64  sub_1059E6(__int64 a1, __int64 a2);
signed __int64  sub_105AD0(__int64 a1, char *a2, size_t a3, __int64 a4);
signed __int64  sub_105E36(__int64 a1, __int64 a2);
signed __int64  sub_105F04(__int64 a1, __int64 a2);
signed __int64  sub_10611E(__int64 a1, size_t a2, __int64 a3, __int64 a4);
signed __int64  sub_106160(unsigned int a1, unsigned int a2, __int64 a3, __int64 a4);
signed __int64  sub_1061F7(char *a1, size_t a2, int a3, __int64 a4, __int64 a5);
signed __int64  sub_1062DC(__int64 a1, __int64 a2, __int64 a3);
signed __int64  sub_1063FB(__int64 a1, unsigned __int64 a2, __int64 a3);
signed __int64  sub_10644E(__int64 *a1, unsigned __int64 *a2, __int64 a3);
__int64  sub_1064E5(__int64 a1, __int64 a2, __int64 a3);
__int64  sub_1068FD(__int64 a1);
__int64  sub_106963(__int64 a1);
signed __int64  sub_1069BD(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_106BBB(signed __int64 a1, char *a2, __int64 a3, signed int a4, char a5, char a6, __int64 a7, __int64 a8);
signed __int64  sub_107027(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_107293(__int64 a1, const char **a2, __int64 *a3, __int64 a4);
signed __int64  sub_1075FD(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int a5);
signed __int64  sub_1078FB(__int64 a1, _QWORD *a2, char a3);
int  sub_107BF0(char *filename, struct stat *stat_buf);
int  sub_107C00(int fildes, struct stat *stat_buf);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

size_t size = 282584257676671uLL; // idb
unsigned __int8 byte_107F80[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  1u,
  1u
}; // idb
_DWORD dword_109EA0[88] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  5,
  6,
  7,
  8,
  9,
  10,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  17,
  18,
  19,
  20,
  21,
  20,
  21,
  22,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  37,
  38,
  39,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77
}; // idb
char off_10A3EA[] = { '%', 'u', '\0', '\0' }; // idb
char accept[] = { ' ', '\t', '\n', '\0' }; // idb
char byte_10CE4D = '\0'; // idb
char off_10F526[] = { ' ', '\t', '\n', '\0' }; // idb
char byte_110942[2] = { '\0', '\0' }; // idb
_WORD word_1197E0[672] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  133,
  131,
  130,
  128,
  131,
  127,
  92,
  100,
  91,
  127,
  127,
  103,
  105,
  90,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  88,
  89,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  2,
  3,
  2,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  6,
  116,
  114,
  131,
  119,
  110,
  111,
  112,
  131,
  106,
  117,
  109,
  122,
  107,
  108,
  122,
  118,
  93,
  96,
  94,
  99,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  131,
  101,
  102,
  131,
  130,
  129,
  127,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  104,
  1,
  5,
  127,
  105,
  125,
  127,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  116,
  115,
  113,
  121,
  120,
  122,
  0,
  122,
  95,
  93,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  94,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  101,
  104,
  127,
  105,
  126,
  125,
  72,
  125,
  125,
  125,
  125,
  125,
  12,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  34,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  60,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  127,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  123,
  122,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  127,
  105,
  126,
  125,
  125,
  125,
  125,
  125,
  10,
  125,
  13,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  20,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  35,
  125,
  38,
  125,
  125,
  125,
  125,
  125,
  43,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  49,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  82,
  63,
  125,
  125,
  125,
  84,
  67,
  125,
  69,
  125,
  125,
  127,
  2,
  123,
  122,
  95,
  0,
  0,
  0,
  98,
  127,
  105,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  77,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  33,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  54,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  66,
  68,
  125,
  125,
  122,
  95,
  127,
  85,
  125,
  7,
  125,
  125,
  125,
  14,
  15,
  125,
  125,
  125,
  125,
  75,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  31,
  125,
  125,
  37,
  125,
  125,
  125,
  125,
  42,
  125,
  125,
  125,
  125,
  125,
  125,
  48,
  125,
  125,
  52,
  125,
  125,
  56,
  125,
  125,
  125,
  61,
  125,
  81,
  125,
  125,
  65,
  125,
  125,
  122,
  127,
  87,
  125,
  9,
  125,
  16,
  125,
  73,
  18,
  125,
  125,
  25,
  125,
  125,
  125,
  125,
  26,
  125,
  125,
  125,
  125,
  32,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  50,
  125,
  125,
  125,
  80,
  125,
  125,
  125,
  64,
  125,
  125,
  125,
  74,
  127,
  8,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  28,
  29,
  125,
  125,
  125,
  125,
  125,
  86,
  125,
  125,
  125,
  79,
  125,
  125,
  51,
  53,
  125,
  125,
  58,
  125,
  125,
  125,
  125,
  127,
  125,
  17,
  125,
  125,
  24,
  125,
  125,
  23,
  125,
  125,
  36,
  39,
  125,
  125,
  44,
  125,
  125,
  125,
  125,
  55,
  125,
  125,
  62,
  83,
  125,
  125,
  124,
  11,
  76,
  125,
  125,
  125,
  125,
  30,
  125,
  125,
  125,
  125,
  46,
  125,
  125,
  125,
  125,
  125,
  19,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  125,
  71,
  125,
  125,
  125,
  40,
  41,
  125,
  45,
  47,
  125,
  125,
  70,
  21,
  22,
  125,
  78,
  125,
  59,
  125,
  125,
  27,
  125,
  57,
  0
}; // idb
_BYTE byte_119D20[256] =
{
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  3,
  1,
  1,
  4,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  5,
  6,
  7,
  6,
  6,
  6,
  6,
  8,
  9,
  10,
  11,
  12,
  6,
  13,
  14,
  15,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  19,
  6,
  20,
  6,
  6,
  6,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  23,
  24,
  6,
  21,
  6,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  21,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  6,
  51,
  6,
  6,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  52,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  53,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  54,
  55,
  55,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  56,
  57,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  58,
  59,
  60,
  60,
  61,
  62,
  62,
  62,
  63,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55,
  55
}; // idb
_BYTE byte_119E20[64] =
{
  0,
  1,
  2,
  2,
  2,
  2,
  3,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  3,
  4,
  4,
  5,
  2,
  3,
  6,
  3,
  3,
  3,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  2,
  2,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3
}; // idb
signed __int16 word_119E60[688] =
{
  0,
  0,
  0,
  61,
  122,
  62,
  63,
  185,
  0,
  248,
  311,
  374,
  437,
  504,
  4800,
  65,
  4800,
  474,
  19,
  4800,
  4800,
  27,
  78,
  490,
  81,
  88,
  4800,
  548,
  606,
  117,
  128,
  225,
  231,
  236,
  254,
  289,
  294,
  312,
  351,
  366,
  371,
  414,
  432,
  437,
  475,
  426,
  481,
  483,
  501,
  4800,
  4800,
  48,
  421,
  54,
  16,
  57,
  40,
  74,
  420,
  4800,
  4800,
  429,
  77,
  360,
  95,
  99,
  110,
  114,
  231,
  359,
  4800,
  168,
  4800,
  393,
  4800,
  4800,
  4800,
  4800,
  376,
  245,
  4800,
  4800,
  314,
  4800,
  4800,
  249,
  4800,
  4800,
  4800,
  4800,
  4800,
  362,
  234,
  245,
  275,
  237,
  290,
  243,
  294,
  242,
  4800,
  4800,
  298,
  274,
  4800,
  259,
  305,
  203,
  308,
  284,
  333,
  301,
  348,
  119,
  432,
  309,
  398,
  471,
  520,
  537,
  664,
  548,
  556,
  604,
  701,
  703,
  612,
  721,
  709,
  727,
  739,
  745,
  747,
  765,
  771,
  786,
  791,
  616,
  801,
  812,
  814,
  831,
  832,
  833,
  852,
  850,
  874,
  851,
  876,
  894,
  899,
  902,
  915,
  923,
  934,
  943,
  954,
  962,
  972,
  980,
  993,
  993,
  999,
  1014,
  1019,
  1022,
  1038,
  1038,
  1055,
  1057,
  1068,
  1076,
  1089,
  1095,
  487,
  534,
  542,
  549,
  583,
  662,
  665,
  4800,
  4800,
  707,
  768,
  853,
  856,
  876,
  940,
  996,
  378,
  4800,
  4800,
  4800,
  4800,
  141,
  0,
  274,
  4800,
  4800,
  1017,
  103,
  1075,
  364,
  1088,
  430,
  1091,
  60,
  4800,
  1094,
  1097,
  1100,
  1103,
  1106,
  1109,
  1112,
  4800,
  1156,
  1159,
  1166,
  1178,
  1176,
  1178,
  1184,
  1205,
  1216,
  1227,
  1235,
  1247,
  1253,
  1259,
  1263,
  1282,
  1287,
  1293,
  1305,
  1311,
  1317,
  1329,
  1340,
  1335,
  1350,
  1358,
  1371,
  1377,
  1379,
  1387,
  1389,
  1400,
  1409,
  1420,
  1421,
  1437,
  1435,
  1456,
  1458,
  1476,
  1478,
  1496,
  1501,
  1519,
  1521,
  1539,
  1544,
  1547,
  1561,
  1572,
  1580,
  1593,
  1601,
  1609,
  1622,
  1628,
  1630,
  1648,
  1659,
  1670,
  1681,
  1692,
  1700,
  1712,
  1720,
  1731,
  1739,
  1750,
  1758,
  435,
  1126,
  1213,
  1264,
  4800,
  1357,
  1438,
  1455,
  0,
  438,
  1473,
  1482,
  1501,
  1521,
  1545,
  1625,
  1628,
  4800,
  1652,
  1663,
  1678,
  612,
  1790,
  1802,
  1791,
  1806,
  1812,
  1839,
  1841,
  1859,
  1861,
  1867,
  1879,
  1885,
  1900,
  1905,
  1911,
  1923,
  1934,
  1942,
  1957,
  1962,
  1968,
  1980,
  1986,
  1991,
  2006,
  2006,
  2022,
  2024,
  2043,
  2045,
  2051,
  2063,
  2069,
  2074,
  2089,
  2094,
  2100,
  2104,
  2112,
  2120,
  2128,
  2136,
  2144,
  2152,
  2165,
  2171,
  2173,
  2191,
  2193,
  2199,
  2211,
  2222,
  2233,
  2241,
  2252,
  2263,
  2275,
  2275,
  2294,
  2296,
  2314,
  2319,
  2325,
  2337,
  2343,
  2337,
  2353,
  2355,
  2372,
  2373,
  2386,
  2394,
  451,
  4800,
  0,
  114,
  4800,
  1736,
  1744,
  1784,
  4800,
  1942,
  1957,
  2407,
  2413,
  2407,
  2429,
  2435,
  2450,
  2455,
  2470,
  2475,
  2490,
  2490,
  2507,
  2513,
  2528,
  2536,
  2547,
  2548,
  2559,
  2558,
  2578,
  2580,
  2598,
  2609,
  2617,
  2628,
  2636,
  2588,
  2636,
  2644,
  2655,
  2663,
  2671,
  2682,
  2684,
  2703,
  2705,
  2723,
  2728,
  2743,
  2751,
  2762,
  2774,
  2782,
  2793,
  2804,
  2815,
  2826,
  2834,
  2845,
  2857,
  2857,
  2876,
  2878,
  2896,
  2901,
  2907,
  2919,
  2925,
  2919,
  2935,
  495,
  4800,
  1976,
  2937,
  2948,
  2956,
  2969,
  2975,
  2969,
  2985,
  2987,
  2998,
  3007,
  3018,
  3026,
  3037,
  3048,
  3049,
  3066,
  3068,
  3067,
  3085,
  3087,
  3106,
  3108,
  3126,
  3131,
  3137,
  3149,
  3157,
  3168,
  3186,
  3191,
  3197,
  3209,
  3215,
  3209,
  3230,
  3235,
  3253,
  3255,
  3261,
  3273,
  3281,
  3279,
  3299,
  3301,
  3307,
  3325,
  3330,
  3345,
  3319,
  3350,
  3365,
  3365,
  3371,
  3386,
  3391,
  3397,
  363,
  728,
  3409,
  3415,
  3420,
  3438,
  3440,
  3458,
  3463,
  3469,
  3481,
  3489,
  3500,
  3508,
  3508,
  3525,
  3527,
  3538,
  3547,
  3558,
  3566,
  3578,
  3584,
  3578,
  3599,
  3605,
  3611,
  3617,
  3623,
  3627,
  3638,
  3646,
  3657,
  3659,
  3670,
  3679,
  3690,
  3698,
  3709,
  3717,
  3728,
  3729,
  3740,
  3748,
  3761,
  3767,
  73,
  2230,
  3769,
  3787,
  3792,
  3798,
  3810,
  3818,
  3818,
  3826,
  3839,
  3845,
  3847,
  3865,
  3867,
  3873,
  3885,
  3891,
  3909,
  3903,
  3914,
  3929,
  3934,
  3952,
  3957,
  3963,
  3975,
  3981,
  3986,
  4001,
  4013,
  4019,
  4024,
  4032,
  4040,
  2256,
  4048,
  4059,
  4068,
  4079,
  4087,
  4098,
  4099,
  4110,
  4109,
  4129,
  4134,
  4140,
  4152,
  4158,
  4160,
  4178,
  4180,
  4198,
  4200,
  4220,
  4222,
  4228,
  4240,
  4246,
  4252,
  4264,
  506,
  4270,
  4272,
  4290,
  4292,
  4312,
  4314,
  4332,
  4334,
  4352,
  4357,
  4375,
  4377,
  4395,
  4385,
  4410,
  4399,
  4418,
  4429,
  4437,
  4450,
  4463,
  4461,
  4474,
  4482,
  4495,
  4501,
  4503,
  4521,
  4526,
  4532,
  4544,
  4550,
  4556,
  4568,
  4574,
  4576,
  4594,
  4596,
  4602,
  4620,
  4614,
  4625,
  4640,
  4645,
  4663,
  4665,
  4671,
  4675,
  4691,
  4696,
  4702,
  4714,
  4800,
  4758,
  4764,
  4770,
  4774,
  4778,
  4781,
  4786,
  65,
  4790,
  4793,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
signed __int16 word_11A3C0[688] =
{
  0,
  671,
  1,
  672,
  672,
  4,
  4,
  671,
  7,
  673,
  673,
  674,
  674,
  671,
  671,
  671,
  671,
  671,
  675,
  671,
  671,
  675,
  675,
  675,
  23,
  23,
  671,
  676,
  676,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  677,
  671,
  671,
  677,
  671,
  671,
  671,
  671,
  671,
  678,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  23,
  23,
  23,
  28,
  671,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  133,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  133,
  133,
  28,
  133,
  28,
  28,
  28,
  133,
  28,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  677,
  679,
  677,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  23,
  680,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  23,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  681,
  677,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  680,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  23,
  671,
  681,
  677,
  671,
  671,
  671,
  671,
  671,
  23,
  23,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  677,
  671,
  23,
  133,
  133,
  133,
  28,
  28,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  677,
  23,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  28,
  28,
  677,
  23,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  23,
  133,
  133,
  28,
  28,
  28,
  28,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  23,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  133,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  28,
  133,
  28,
  28,
  28,
  28,
  0,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  671,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char off_11F9B7[] = { '%', 's', '\n', '\0' }; // idb
char off_11FDF0[] = { ' ', '\t', '\n', '\0', 'u', 'n', 'i', 'q' }; // idb
char byte_124F70[4] = { '\0', '\0', '\0', '\0' }; // idb
char off_125228[] = { '%', 's', '\n', '\0', '\0', '\0', '\0', '\0' }; // idb
char off_1272F0[] = { '%', 'u', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char off_12796A[] = { '%', 'u', '\0', '\0' }; // idb
_DWORD dword_3458B0[12] = { 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0 }; // idb
char *off_345BA0[166] =
{
  "BasicLatin",
  "[\\x{0000}-\\x{007F}]",
  "Latin-1Supplement",
  "[\\x{0080}-\\x{00FF}]",
  "LatinExtended-A",
  "[\\x{0100}-\\x{017F}]",
  "LatinExtended-B",
  "[\\x{0180}-\\x{024F}]",
  "IPAExtensions",
  "[\\x{0250}-\\x{02AF}]",
  "SpacingModifierLetters",
  "[\\x{02B0}-\\x{02FF}]",
  "CombiningDiacriticalMarks",
  "[\\x{0300}-\\x{036F}]",
  "Greek",
  "[\\x{0370}-\\x{03FF}]",
  "Cyrillic",
  "[\\x{0400}-\\x{04FF}]",
  "Armenian",
  "[\\x{0530}-\\x{058F}]",
  "Hebrew",
  "[\\x{0590}-\\x{05FF}]",
  "Arabic",
  "[\\x{0600}-\\x{06FF}]",
  "Syriac",
  "[\\x{0700}-\\x{074F}]",
  "Thaana",
  "[\\x{0780}-\\x{07BF}]",
  "Devanagari",
  "[\\x{0900}-\\x{097F}]",
  "Bengali",
  "[\\x{0980}-\\x{09FF}]",
  "Gurmukhi",
  "[\\x{0A00}-\\x{0A7F}]",
  "Gujarati",
  "[\\x{0A80}-\\x{0AFF}]",
  "Oriya",
  "[\\x{0B00}-\\x{0B7F}]",
  "Tamil",
  "[\\x{0B80}-\\x{0BFF}]",
  "Telugu",
  "[\\x{0C00}-\\x{0C7F}]",
  "Kannada",
  "[\\x{0C80}-\\x{0CFF}]",
  "Malayalam",
  "[\\x{0D00}-\\x{0D7F}]",
  "Sinhala",
  "[\\x{0D80}-\\x{0DFF}]",
  "Thai",
  "[\\x{0E00}-\\x{0E7F}]",
  "Lao",
  "[\\x{0E80}-\\x{0EFF}]",
  "Tibetan",
  "[\\x{0F00}-\\x{0FFF}]",
  "Myanmar",
  "[\\x{1000}-\\x{109F}]",
  "Georgian",
  "[\\x{10A0}-\\x{10FF}]",
  "HangulJamo",
  "[\\x{1100}-\\x{11FF}]",
  "Ethiopic",
  "[\\x{1200}-\\x{137F}]",
  "Cherokee",
  "[\\x{13A0}-\\x{13FF}]",
  "UnifiedCanadianAboriginalSyllabics",
  "[\\x{1400}-\\x{167F}]",
  "Ogham",
  "[\\x{1680}-\\x{169F}]",
  "Runic",
  "[\\x{16A0}-\\x{16FF}]",
  "Khmer",
  "[\\x{1780}-\\x{17FF}]",
  "Mongolian",
  "[\\x{1800}-\\x{18AF}]",
  "LatinExtendedAdditional",
  "[\\x{1E00}-\\x{1EFF}]",
  "GreekExtended",
  "[\\x{1F00}-\\x{1FFF}]",
  "GeneralPunctuation",
  "[\\x{2000}-\\x{206F}]",
  "SuperscriptsandSubscripts",
  "[\\x{2070}-\\x{209F}]",
  "CurrencySymbols",
  "[\\x{20A0}-\\x{20CF}]",
  "CombiningMarksforSymbols",
  "[\\x{20D0}-\\x{20FF}]",
  "LetterlikeSymbols",
  "[\\x{2100}-\\x{214F}]",
  "NumberForms",
  "[\\x{2150}-\\x{218F}]",
  "Arrows",
  "[\\x{2190}-\\x{21FF}]",
  "MathematicalOperators",
  "[\\x{2200}-\\x{22FF}]",
  "MiscellaneousTechnical",
  "[\\x{2300}-\\x{23FF}]",
  "ControlPictures",
  "[\\x{2400}-\\x{243F}]",
  "OpticalCharacterRecognition",
  "[\\x{2440}-\\x{245F}]",
  "EnclosedAlphanumerics",
  "[\\x{2460}-\\x{24FF}]",
  "BoxDrawing",
  "[\\x{2500}-\\x{257F}]",
  "BlockElements",
  "[\\x{2580}-\\x{259F}]",
  "GeometricShapes",
  "[\\x{25A0}-\\x{25FF}]",
  "MiscellaneousSymbols",
  "[\\x{2600}-\\x{26FF}]",
  "Dingbats",
  "[\\x{2700}-\\x{27BF}]",
  "BraillePatterns",
  "[\\x{2800}-\\x{28FF}]",
  "CJKRadicalsSupplement",
  "[\\x{2E80}-\\x{2EFF}]",
  "KangxiRadicals",
  "[\\x{2F00}-\\x{2FDF}]",
  "IdeographicDescriptionCharacters",
  "[\\x{2FF0}-\\x{2FFF}]",
  "CJKSymbolsandPunctuation",
  "[\\x{3000}-\\x{303F}]",
  "Hiragana",
  "[\\x{3040}-\\x{309F}]",
  "Katakana",
  "[\\x{30A0}-\\x{30FF}]",
  "Bopomofo",
  "[\\x{3100}-\\x{312F}]",
  "HangulCompatibilityJamo",
  "[\\x{3130}-\\x{318F}]",
  "Kanbun",
  "[\\x{3190}-\\x{319F}]",
  "BopomofoExtended",
  "[\\x{31A0}-\\x{31BF}]",
  "EnclosedCJKLettersandMonths",
  "[\\x{3200}-\\x{32FF}]",
  "CJKCompatibility",
  "[\\x{3300}-\\x{33FF}]",
  "CJKUnifiedIdeographsExtensionA",
  "[\\x{3400}-\\x{4DB5}]",
  "CJKUnifiedIdeographs",
  "[\\x{4E00}-\\x{9FFF}]",
  "YiSyllables",
  "[\\x{A000}-\\x{A48F}]",
  "YiRadicals",
  "[\\x{A490}-\\x{A4CF}]",
  "HangulSyllables",
  "[\\x{AC00}-\\x{D7A3}]",
  "PrivateUse",
  "[\\x{E000}-\\x{F8FF}]",
  "CJKCompatibilityIdeographs",
  "[\\x{F900}-\\x{FAFF}]",
  "AlphabeticPresentationForms",
  "[\\x{FB00}-\\x{FB4F}]",
  "ArabicPresentationForms-A",
  "[\\x{FB50}-\\x{FDFF}]",
  "CombiningHalfMarks",
  "[\\x{FE20}-\\x{FE2F}]",
  "CJKCompatibilityForms",
  "[\\x{FE30}-\\x{FE4F}]",
  "SmallFormVariants",
  "[\\x{FE50}-\\x{FE6F}]",
  "ArabicPresentationForms-B",
  "[\\x{FE70}-\\x{FEFE}]",
  "HalfwidthandFullwidthForms",
  "[\\x{FF00}-\\x{FFEF}]"
};
char *off_345BA8[165] =
{
  "[\\x{0000}-\\x{007F}]",
  "Latin-1Supplement",
  "[\\x{0080}-\\x{00FF}]",
  "LatinExtended-A",
  "[\\x{0100}-\\x{017F}]",
  "LatinExtended-B",
  "[\\x{0180}-\\x{024F}]",
  "IPAExtensions",
  "[\\x{0250}-\\x{02AF}]",
  "SpacingModifierLetters",
  "[\\x{02B0}-\\x{02FF}]",
  "CombiningDiacriticalMarks",
  "[\\x{0300}-\\x{036F}]",
  "Greek",
  "[\\x{0370}-\\x{03FF}]",
  "Cyrillic",
  "[\\x{0400}-\\x{04FF}]",
  "Armenian",
  "[\\x{0530}-\\x{058F}]",
  "Hebrew",
  "[\\x{0590}-\\x{05FF}]",
  "Arabic",
  "[\\x{0600}-\\x{06FF}]",
  "Syriac",
  "[\\x{0700}-\\x{074F}]",
  "Thaana",
  "[\\x{0780}-\\x{07BF}]",
  "Devanagari",
  "[\\x{0900}-\\x{097F}]",
  "Bengali",
  "[\\x{0980}-\\x{09FF}]",
  "Gurmukhi",
  "[\\x{0A00}-\\x{0A7F}]",
  "Gujarati",
  "[\\x{0A80}-\\x{0AFF}]",
  "Oriya",
  "[\\x{0B00}-\\x{0B7F}]",
  "Tamil",
  "[\\x{0B80}-\\x{0BFF}]",
  "Telugu",
  "[\\x{0C00}-\\x{0C7F}]",
  "Kannada",
  "[\\x{0C80}-\\x{0CFF}]",
  "Malayalam",
  "[\\x{0D00}-\\x{0D7F}]",
  "Sinhala",
  "[\\x{0D80}-\\x{0DFF}]",
  "Thai",
  "[\\x{0E00}-\\x{0E7F}]",
  "Lao",
  "[\\x{0E80}-\\x{0EFF}]",
  "Tibetan",
  "[\\x{0F00}-\\x{0FFF}]",
  "Myanmar",
  "[\\x{1000}-\\x{109F}]",
  "Georgian",
  "[\\x{10A0}-\\x{10FF}]",
  "HangulJamo",
  "[\\x{1100}-\\x{11FF}]",
  "Ethiopic",
  "[\\x{1200}-\\x{137F}]",
  "Cherokee",
  "[\\x{13A0}-\\x{13FF}]",
  "UnifiedCanadianAboriginalSyllabics",
  "[\\x{1400}-\\x{167F}]",
  "Ogham",
  "[\\x{1680}-\\x{169F}]",
  "Runic",
  "[\\x{16A0}-\\x{16FF}]",
  "Khmer",
  "[\\x{1780}-\\x{17FF}]",
  "Mongolian",
  "[\\x{1800}-\\x{18AF}]",
  "LatinExtendedAdditional",
  "[\\x{1E00}-\\x{1EFF}]",
  "GreekExtended",
  "[\\x{1F00}-\\x{1FFF}]",
  "GeneralPunctuation",
  "[\\x{2000}-\\x{206F}]",
  "SuperscriptsandSubscripts",
  "[\\x{2070}-\\x{209F}]",
  "CurrencySymbols",
  "[\\x{20A0}-\\x{20CF}]",
  "CombiningMarksforSymbols",
  "[\\x{20D0}-\\x{20FF}]",
  "LetterlikeSymbols",
  "[\\x{2100}-\\x{214F}]",
  "NumberForms",
  "[\\x{2150}-\\x{218F}]",
  "Arrows",
  "[\\x{2190}-\\x{21FF}]",
  "MathematicalOperators",
  "[\\x{2200}-\\x{22FF}]",
  "MiscellaneousTechnical",
  "[\\x{2300}-\\x{23FF}]",
  "ControlPictures",
  "[\\x{2400}-\\x{243F}]",
  "OpticalCharacterRecognition",
  "[\\x{2440}-\\x{245F}]",
  "EnclosedAlphanumerics",
  "[\\x{2460}-\\x{24FF}]",
  "BoxDrawing",
  "[\\x{2500}-\\x{257F}]",
  "BlockElements",
  "[\\x{2580}-\\x{259F}]",
  "GeometricShapes",
  "[\\x{25A0}-\\x{25FF}]",
  "MiscellaneousSymbols",
  "[\\x{2600}-\\x{26FF}]",
  "Dingbats",
  "[\\x{2700}-\\x{27BF}]",
  "BraillePatterns",
  "[\\x{2800}-\\x{28FF}]",
  "CJKRadicalsSupplement",
  "[\\x{2E80}-\\x{2EFF}]",
  "KangxiRadicals",
  "[\\x{2F00}-\\x{2FDF}]",
  "IdeographicDescriptionCharacters",
  "[\\x{2FF0}-\\x{2FFF}]",
  "CJKSymbolsandPunctuation",
  "[\\x{3000}-\\x{303F}]",
  "Hiragana",
  "[\\x{3040}-\\x{309F}]",
  "Katakana",
  "[\\x{30A0}-\\x{30FF}]",
  "Bopomofo",
  "[\\x{3100}-\\x{312F}]",
  "HangulCompatibilityJamo",
  "[\\x{3130}-\\x{318F}]",
  "Kanbun",
  "[\\x{3190}-\\x{319F}]",
  "BopomofoExtended",
  "[\\x{31A0}-\\x{31BF}]",
  "EnclosedCJKLettersandMonths",
  "[\\x{3200}-\\x{32FF}]",
  "CJKCompatibility",
  "[\\x{3300}-\\x{33FF}]",
  "CJKUnifiedIdeographsExtensionA",
  "[\\x{3400}-\\x{4DB5}]",
  "CJKUnifiedIdeographs",
  "[\\x{4E00}-\\x{9FFF}]",
  "YiSyllables",
  "[\\x{A000}-\\x{A48F}]",
  "YiRadicals",
  "[\\x{A490}-\\x{A4CF}]",
  "HangulSyllables",
  "[\\x{AC00}-\\x{D7A3}]",
  "PrivateUse",
  "[\\x{E000}-\\x{F8FF}]",
  "CJKCompatibilityIdeographs",
  "[\\x{F900}-\\x{FAFF}]",
  "AlphabeticPresentationForms",
  "[\\x{FB00}-\\x{FB4F}]",
  "ArabicPresentationForms-A",
  "[\\x{FB50}-\\x{FDFF}]",
  "CombiningHalfMarks",
  "[\\x{FE20}-\\x{FE2F}]",
  "CJKCompatibilityForms",
  "[\\x{FE30}-\\x{FE4F}]",
  "SmallFormVariants",
  "[\\x{FE50}-\\x{FE6F}]",
  "ArabicPresentationForms-B",
  "[\\x{FE70}-\\x{FEFE}]",
  "HalfwidthandFullwidthForms",
  "[\\x{FF00}-\\x{FFEF}]"
};
const char **qword_346FA0[1] = { &size }; // idb
void *ptr; // idb
void *qword_347070; // idb
void *qword_347088; // idb
pthread_mutex_t mutex; // idb
void *qword_3470C8; // idb
// extern struct _IO_FILE *stdout;
// extern struct _IO_FILE *stdin;
// extern struct _IO_FILE *stderr;


////----- (0000000000007160) ----------------------------------------------------
//__int64 (**init_proc())(void)
//{
//  __int64 (**result)(void); // rax
//
//  result = &_gmon_start__;
//  if ( &_gmon_start__ )
//    result = (__int64 (**)(void))_gmon_start__();
//  return result;
//}
//// 3473E0: using guessed type __int64 _gmon_start__(void);
//
////----- (0000000000007180) ----------------------------------------------------
//void sub_7180()
//{
//  JUMPOUT(&size);
//}
//
////----- (0000000000007C90) ----------------------------------------------------
//char *start()
//{
//  char *result; // rax
//
//  result = &edata;
//  if ( &edata != &edata )
//  {
//    result = (char *)&ITM_deregisterTMCloneTable;
//    if ( &ITM_deregisterTMCloneTable )
//      result = (char *)ITM_deregisterTMCloneTable();
//  }
//  return result;
//}
//// 347040: using guessed type char edata;
//// 3473D8: using guessed type __int64 ITM_deregisterTMCloneTable(void);
//
////----- (0000000000007CD0) ----------------------------------------------------
//__int64 sub_7CD0()
//{
//  return 0LL;
//}
//
////----- (0000000000007D20) ----------------------------------------------------
//char *sub_7D20()
//{
//  char *result; // rax
//
//  if ( !edata )
//  {
//    if ( &__cxa_finalize )
//      _cxa_finalize(off_3365A0);
//    result = start();
//    edata = 1;
//  }
//  return result;
//}
// 7C88: using guessed type __int64  _cxa_finalize(_QWORD);
// 3365A0: using guessed type void *off_3365A0;
// 347040: using guessed type char edata;

//----- (0000000000007D60) ----------------------------------------------------
__int64 sub_7D60()
{
  return sub_7CD0();
}

//----- (0000000000007D6A) ----------------------------------------------------
__int64  ly_errno_glob_address(__int64 a1)
{
  return __tls_get_addr(&qword_335FE0);
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 107C20: using guessed type void *off_107C20;
// 335FE0: using guessed type __int64 qword_335FE0;

//----- (0000000000007D9D) ----------------------------------------------------
__int64  ly_vecode(__int64 a1)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]


  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(unsigned int *)(*(_QWORD *)(v7 + 48) + 8LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007DF1) ----------------------------------------------------
__int64  ly_errmsg(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_errmsg", a4, a5, a6);
  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 16LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007E46) ----------------------------------------------------
__int64  ly_errpath(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 24LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007E9B) ----------------------------------------------------
__int64  ly_errapptag(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+18h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_errapptag", a4, a5, a6);
  v7 = ly_err_first(a1);
  if ( v7 )
    result = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 32LL);
  else
    result = 0LL;
  return result;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007EF0) ----------------------------------------------------
void * ly_err_first(__int64 a1)
{
  void *result; // rax

  //sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_err_first", a4, a5, a6);
  if ( a1 )
    result = pthread_getspecific(*(_DWORD *)(a1 + 128));
  else
    result = 0LL;
  return result;
}
// 107C20: using guessed type void *off_107C20;

//----- (0000000000007F3A) ----------------------------------------------------
void  destr_function(void *a1)
{
  void *v1; // ST18_8
  void *ptr; // [rsp+10h] [rbp-10h]

  for ( ptr = a1; ptr; ptr = v1 )
  {
    v1 = (void *)*((_QWORD *)ptr + 5);
    free(*((void **)ptr + 2));
    free(*((void **)ptr + 3));
    free(*((void **)ptr + 4));
    free(ptr);
  }
}

//----- (0000000000007FAA) ----------------------------------------------------
__int64  ly_err_clean(__int64 a1, __int64 a2)
{
  _DWORD *v6; // rdx
  __int64 result; // rax
  __int64 v8; // rdi
  _QWORD *v9; // [rsp+0h] [rbp-20h]
  _QWORD *i; // [rsp+10h] [rbp-10h]
  _QWORD *v11; // [rsp+18h] [rbp-8h]

  v11 = (_QWORD *)ly_err_first(a1);
  if ( v11 == v9 )
    v9 = 0LL;
  if ( v9 )
  {
    for ( i = v11; i && v9 != (_QWORD *)i[5]; i = (_QWORD *)i[5] )
      ;
    if ( !i )
      __assert_fail("i", "/home/mantovan/Repositories/libyang/src/common.c", 0x91u, "ly_err_clean");
    i[5] = 0LL;
    v11[6] = i;
    destr_function(v9);
    v6 = (_DWORD *)ly_errno_glob_address(v9);
    result = *((unsigned int *)i + 1);
    *v6 = result;
  }
  else
  {
    destr_function(v11);
    v8 = *(unsigned int *)(a1 + 128);
    pthread_setspecific(v8, 0LL);
    result = ly_errno_glob_address(v8);
    *(_DWORD *)result = 0;
  }
  return result;
}
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (00000000000080BC) ----------------------------------------------------
_BYTE * sub_80BC(_BYTE *a1, _BYTE *a2, int a3)
{
  int i; // [rsp+0h] [rbp-24h]
  _BYTE *v5; // [rsp+Ch] [rbp-18h]
  _BYTE *j; // [rsp+1Ch] [rbp-8h]

  v5 = a1;
  for ( i = a3; *v5 && i; --i )
  {
    for ( j = a2; *j; ++j )
    {
      if ( *v5 == *j )
        return v5;
    }
    --v5;
  }
  return v5;
}

//----- (000000000000811F) ----------------------------------------------------
_BYTE * sub_811F(_BYTE *a1, char a2, int a3)
{
  int v4; // [rsp+0h] [rbp-10h]
  _BYTE *v5; // [rsp+8h] [rbp-8h]

  v5 = a1;
  v4 = a3;
  while ( *v5 != a2 )
  {
    if ( !*v5 || !v4 )
      return 0LL;
    ++v5;
    --v4;
  }
  return v5;
}

//----- (0000000000008164) ----------------------------------------------------
const char * sub_8164(unsigned int a1)
{
  if ( a1 == 128 )
    return "notification";
  if ( a1 > 0x80 )
  {
    if ( a1 == 4096 )
      return "uses";
    if ( a1 > 0x1000 )
    {
      if ( a1 == 0x4000 )
        return "action";
      if ( a1 > 0x4000 )
      {
        if ( a1 == 32800 )
          return "anydata";
        if ( a1 == 0x10000 )
          return "extension instance";
      }
      else if ( a1 == 0x2000 )
      {
        return "augment";
      }
    }
    else
    {
      if ( a1 == 512 )
        return "input";
      if ( a1 > 0x200 )
      {
        if ( a1 == 1024 )
          return "output";
        if ( a1 == 2048 )
          return "grouping";
      }
      else if ( a1 == 256 )
      {
        return "rpc";
      }
    }
  }
  else
  {
    if ( a1 == 4 )
      return "leaf";
    if ( a1 > 4 )
    {
      if ( a1 == 16 )
        return "list";
      if ( a1 > 0x10 )
      {
        if ( a1 == 32 )
          return "anyxml";
        if ( a1 == 64 )
          return "case";
      }
      else if ( a1 == 8 )
      {
        return "leaf-list";
      }
    }
    else
    {
      if ( a1 == 1 )
        return "container";
      if ( a1 < 1 )
        return 0LL;
      if ( a1 == 2 )
        return "choice";
    }
  }
  return 0LL;
}

//----- (000000000000831C) ----------------------------------------------------
__int64  sub_831C(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  unsigned __int16 i; // [rsp+1Eh] [rbp-2h]

  if ( !a2 )
    return 0LL;
  v3 = lys_main_module(a1);
  if ( !strcmp(*(const char **)(v3 + 8), a2) )
    return *(_QWORD *)(a1 + 16);
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 69); ++i )
  {
    if ( !strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i) + 8LL), a2) )
      return *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56LL * i + 8);
  }
  return 0LL;
}
// 7950: using guessed type __int64  lys_main_module(_QWORD);

//----- (00000000000083E9) ----------------------------------------------------
signed __int64  sub_83E9(_QWORD *a1, const char *a2, void **a3, __int64 *a4, size_t *a5, int a6, int a7, void **a8, void **a9, unsigned int *a10)
{
  __int64 v11; // r9
  __int64 v12; // r9
  size_t v13; // rbx
  size_t v14; // rax
  __int64 v15; // r9
  __int64 v16; // rbx
  int v17; // [rsp+24h] [rbp-ACh]
  size_t *v18; // [rsp+28h] [rbp-A8h]
  __int64 *v19; // [rsp+30h] [rbp-A0h]
  void **v20; // [rsp+38h] [rbp-98h]
  int v21; // [rsp+5Ch] [rbp-74h]
  unsigned int i; // [rsp+60h] [rbp-70h]
  unsigned int j; // [rsp+64h] [rbp-6Ch]
  char *src; // [rsp+68h] [rbp-68h]
  char *s; // [rsp+70h] [rbp-60h]
  size_t n; // [rsp+78h] [rbp-58h]
  __int64 v27; // [rsp+80h] [rbp-50h]
  __int64 v28; // [rsp+88h] [rbp-48h]
  void *v29; // [rsp+90h] [rbp-40h]
  _QWORD *v30; // [rsp+98h] [rbp-38h]
  char *string; // [rsp+A0h] [rbp-30h]
  void *ptr; // [rsp+A8h] [rbp-28h]
  char *v33; // [rsp+B0h] [rbp-20h]
  unsigned __int64 v34; // [rsp+B8h] [rbp-18h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v17 = a6;
  v34 = __readfsqword(0x28u);
  v27 = 0LL;
  v28 = 0LL;
  v29 = (void *)*a1;
  if ( !a1 || !a2 || (a8 || a9 || a10) && (!a8 || !a9 || !a10) )
    __assert_fail(
      "module && expr && ((!prefixes && !namespaces && !ns_count) || (prefixes && namespaces && ns_count))",
      "/home/mantovan/Repositories/libyang/src/common.c",
      0x11Eu,
      "_transform_json2xml_subexp");
  v30 = sub_CB4D2(v29, a2);
  if ( !v30 )
    return 1LL;
  for ( i = 0; ; ++i )
  {
    if ( i >= *((unsigned __int16 *)v30 + 16) )
    {
      sub_C488D((__int64)v30);
      return 0LL;
    }
    string = (char *)(v30[5] + *(unsigned __int16 *)(2LL * i + v30[1]));
    if ( i )
    {
      src = (char *)(v30[5]
                   + *(unsigned __int16 *)(2LL * (i - 1) + v30[1])
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * (i - 1) + v30[2]));
      if ( src != string )
      {
        strncpy((char *)*v20 + *v19, src, string - src);
        *v19 += string - src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *v30) == 9 )
    {
      src = sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v30[2]));
      if ( src || a7 )
        break;
    }
    if ( *(_DWORD *)(4LL * i + *v30) == 17
      && (src = sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v30[2]))) != 0LL )
    {
      *((_BYTE *)*v20 + (*v19)++) = *string;
      v33 = (char *)lydict_insert(*a1, string + 1, *(unsigned __int16 *)(2LL * i + v30[2]) - 2);
      sub_141E4(0LL, 2u, &v21, 0LL);
      if (a1)
      {
        strncpy((char *)*v20 + *v19, v33, *(unsigned __int16 *)(2LL * i + v30[2]) - 2);
        *v19 += *(unsigned __int16 *)(2LL * i + v30[2]) - 2;
      }
      sub_142D2(0LL, v21, 0LL, 0);
      lydict_remove(*a1, v33);
      *((_BYTE *)*v20 + (*v19)++) = string[*(unsigned __int16 *)(2LL * i + v30[2]) - 1];
    }
    else
    {
      strncpy(
        (char *)*v20 + *v19,
        (const char *)(v30[5] + *(unsigned __int16 *)(2LL * i + v30[1])),
        *(unsigned __int16 *)(2LL * i + v30[2]));
      *v19 += *(unsigned __int16 *)(2LL * i + v30[2]);
    }
LABEL_61:
    ;
  }
  if ( v17 )
  {
    if ( src )
    {
      n = src - string;
    }
    else
    {
      n = strlen(string);
      src = string;
    }
    ptr = strndup(string, n);
    s = (char *)sub_831C((__int64)a1, (const char *)ptr);
    free(ptr);
    if ( !s )
    {
      sub_13937(v29, 29, 0, 0LL, n, (__int64)string);
      goto LABEL_64;
    }
  }
  else
  {
    if ( src )
    {
      n = src - string;
      ptr = strndup(string, src - string);
      v27 = ly_ctx_get_module(*a1, ptr, 0LL, 0LL);
      if ( *(_QWORD *)(*a1 + 112LL) )
      {
        if ( v27 )
        {
          if ( *(_BYTE *)(v27 + 64) >= 0 )
            v27 = (*(__int64 ( **)(_QWORD, void *, _QWORD, signed __int64, _QWORD))(*a1 + 112LL))(
                    *a1,
                    ptr,
                    *(_QWORD *)(v27 + 176),
                    1LL,
                    *(_QWORD *)(*a1 + 120LL));
        }
        else
        {
          v27 = (*(__int64 ( **)(_QWORD, void *, _QWORD, _QWORD, _QWORD))(*a1 + 112LL))(
                  *a1,
                  ptr,
                  0LL,
                  0LL,
                  *(_QWORD *)(*a1 + 120LL));
        }
      }
      free(ptr);
      if ( !v27 )
      {
        sub_13937(v29, 29, 0, 0LL, n, (__int64)string);
        goto LABEL_64;
      }
      v28 = v27;
    }
    else
    {
      v27 = v28;
      if ( !v28 )
      {
        sub_12222(
          (__int64)v29,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/common.c",
          323LL);
        goto LABEL_64;
      }
      n = 0LL;
      src = string;
    }
    s = *(char **)(v27 + 16);
  }
  if ( !v17 && a10 )
  {
    for ( j = 0; j < *a10 && *((_QWORD *)*a9 + j) != *(_QWORD *)(v27 + 176); ++j )
      ;
    if ( j == *a10 )
    {
      *a8 = sub_C422(*a8, 8LL * ++*a10);
      if ( !*a8 )
      {
        sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml_subexp", v11);
        goto LABEL_64;
      }
      *a9 = sub_C422(*a9, 8LL * *a10);
      if ( !*a9 )
      {
        sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml_subexp", v12);
        goto LABEL_64;
      }
      *((_QWORD *)*a8 + *a10 - 1) = *(_QWORD *)(v27 + 16);
      *((_QWORD *)*a9 + *a10 - 1) = *(_QWORD *)(v27 + 176);
    }
  }
  v13 = *v18;
  v14 = strlen(s);
  *v18 = v13 + v14 - n + 1;
  *v20 = sub_C422(*v20, *v18);
  if ( *v20 )
  {
    strcpy((char *)*v20 + *v19, s);
    v16 = *v19;
    *v19 = v16 + strlen(s);
    if ( !n )
      *((_BYTE *)*v20 + (*v19)++) = 58;
    strncpy((char *)*v20 + *v19, src, *(unsigned __int16 *)(2LL * i + v30[2]) - n);
    *v19 += *(unsigned __int16 *)(2LL * i + v30[2]) - n;
    goto LABEL_61;
  }
  sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml_subexp", v15);
LABEL_64:
  if ( !v17 )
  {
    if ( a10 )
    {
      free(*a8);
      free(*a9);
    }
  }
  sub_C488D((__int64)v30);
  return 1LL;
}
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000008F60) ----------------------------------------------------
__int64  sub_8F60(__int64 *a1, const char *a2, int a3, int a4, void **a5, void **a6, unsigned int *a7)
{
  __int64 result; // rax
  __int64 v8; // r9
  void **v9; // [rsp+8h] [rbp-58h]
  void **v10; // [rsp+10h] [rbp-50h]
  int v11; // [rsp+18h] [rbp-48h]
  int v12; // [rsp+1Ch] [rbp-44h]
  void *ptr; // [rsp+40h] [rbp-20h]
  size_t size; // [rsp+48h] [rbp-18h]
  __int64 v15; // [rsp+50h] [rbp-10h]
  unsigned __int64 v16; // [rsp+58h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v16 = __readfsqword(0x28u);
  if ( !a1 || !a2 || (a5 || a6 || a7) && (!a5 || !a6 || !a7) )
    __assert_fail(
      "module && expr && ((!prefixes && !namespaces && !ns_count) || (prefixes && namespaces && ns_count))",
      "/home/mantovan/Repositories/libyang/src/common.c",
      0x1ADu,
      "_transform_json2xml");
  if ( a7 )
  {
    *a7 = 0;
    *a5 = 0LL;
    *a6 = 0LL;
  }
  if ( !*a2 )
    return lydict_insert(*a1, a2, 0LL);
  size = strlen(a2) + 1;
  ptr = malloc(size);
  if ( ptr )
  {
    v15 = 0LL;
    if ( (unsigned int)sub_83E9(a1, a2, &ptr, &v15, &size, v12, v11, v10, v9, a7) )
    {
      free(ptr);
      result = 0LL;
    }
    else
    {
      *((_BYTE *)ptr + v15) = 0;
      result = lydict_insert_zc(*a1, ptr);
    }
  }
  else
  {
    sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"_transform_json2xml", v8, a7);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000000912E) ----------------------------------------------------
__int64  sub_912E(__int64 *a1, const char *a2, int a3, void **a4, void **a5, unsigned int *a6)
{
  return sub_8F60(a1, a2, 0, a3, a4, a5, a6);
}

//----- (0000000000009182) ----------------------------------------------------
__int64  sub_9182(__int64 *a1, const char *a2)
{
  return sub_8F60(a1, a2, 1, 0, 0LL, 0LL, 0LL);
}

//----- (00000000000091C4) ----------------------------------------------------
signed __int64  sub_91C4(__int64 a1, const char *a2, void **a3, __int64 *a4, size_t *a5, char *a6, int a7, int a8)
{
  __int64 v8; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  size_t v13; // rbx
  __int64 v14; // r9
  __int64 v15; // rbx
  __int64 v16; // r9
  char *v17; // [rsp+0h] [rbp-90h]
  size_t *v18; // [rsp+8h] [rbp-88h]
  __int64 *v19; // [rsp+10h] [rbp-80h]
  void **v20; // [rsp+18h] [rbp-78h]
  unsigned __int16 i; // [rsp+32h] [rbp-5Eh]
  int v22; // [rsp+34h] [rbp-5Ch]
  char *src; // [rsp+38h] [rbp-58h]
  char *srca; // [rsp+38h] [rbp-58h]
  __int64 n; // [rsp+40h] [rbp-50h]
  __int64 v26; // [rsp+48h] [rbp-48h]
  __int64 v27; // [rsp+50h] [rbp-40h]
  _QWORD *v28; // [rsp+58h] [rbp-38h]
  char *string; // [rsp+60h] [rbp-30h]
  char *ptr; // [rsp+68h] [rbp-28h]
  __int64 v31; // [rsp+70h] [rbp-20h]
  char *v32; // [rsp+78h] [rbp-18h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v17 = a6;
  v27 = 0LL;
  v28 = sub_CB4D2((void *)a1, a2);
  if ( !v28 )
    return 1LL;
  for ( i = 0; ; ++i )
  {
    if ( i >= *((_WORD *)v28 + 16) )
    {
      sub_C488D((__int64)v28);
      return 0LL;
    }
    string = (char *)(v28[5] + *(unsigned __int16 *)(2LL * i + v28[1]));
    if ( i )
    {
      src = (char *)(v28[5]
                   + *(unsigned __int16 *)(2LL * i - 2 + v28[1])
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + v28[2]));
      if ( src != string )
      {
        strncpy((char *)*v20 + *v19, src, string - src);
        *v19 += string - src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *v28) != 9 )
      break;
    srca = sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v28[2]));
    if ( !srca )
      break;
    n = srca - string;
    ptr = strndup(string, srca - string);
    if ( !ptr )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_xml2json_subexp", v10, v17);
      goto LABEL_40;
    }
    v31 = lyxml_get_ns(v17, ptr);
    free(ptr);
    if ( !v31 )
    {
      sub_13937((void *)a1, 2, 1u, v17, (__int64)"namespace prefix", v11, v17);
      sub_13937((void *)a1, -1, 5u, 0LL, (__int64)"XML namespace with prefix \"%.*s\" not defined.", n, string);
      goto LABEL_40;
    }
    v26 = ly_ctx_get_module_by_ns(a1, *(_QWORD *)(v31 + 32), 0LL, 0LL);
    if ( a8 && *(_QWORD *)(a1 + 112) )
    {
      if ( v26 )
      {
        if ( *(_BYTE *)(v26 + 64) >= 0 )
          v26 = (*(__int64 ( **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(a1 + 112))(
                  a1,
                  *(_QWORD *)(v26 + 8),
                  *(_QWORD *)(v26 + 176),
                  1LL,
                  *(_QWORD *)(a1 + 120));
      }
      else
      {
        v26 = (*(__int64 ( **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 112))(
                a1,
                0LL,
                *(_QWORD *)(v31 + 32),
                0LL,
                *(_QWORD *)(a1 + 120));
      }
    }
    if ( !v26 )
    {
      sub_13937((void *)a1, 2, 1u, v17, (__int64)"module namespace", v12, v17);
      sub_13937(
        (void *)a1,
        -1,
        5u,
        0LL,
        (__int64)"Module with the namespace \"%s\" could not be found.",
        *(_QWORD *)(v31 + 32));
      goto LABEL_40;
    }
    if ( a7 && v26 == v27 )
    {
      ++srca;
      ++n;
    }
    else
    {
      v13 = *v18;
      *v18 = v13 + strlen(*(const char **)(v26 + 8)) - n;
      *v20 = sub_C422(*v20, *v18);
      if ( !*v20 )
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_xml2json_subexp", v14, v17);
        goto LABEL_40;
      }
      strcpy((char *)*v20 + *v19, *(const char **)(v26 + 8));
      v15 = *v19;
      *v19 = v15 + strlen(*(const char **)(v26 + 8));
    }
    v27 = v26;
    strncpy((char *)*v20 + *v19, srca, *(unsigned __int16 *)(2LL * i + v28[2]) - n);
    *v19 += *(unsigned __int16 *)(2LL * i + v28[2]) - n;
LABEL_37:
    ;
  }
  if ( *(_DWORD *)(4LL * i + *v28) != 9 || !a7 )
  {
    if ( *(_DWORD *)(4LL * i + *v28) == 17 && sub_811F(string, 58, *(unsigned __int16 *)(2LL * i + v28[2])) )
    {
      *((_BYTE *)*v20 + (*v19)++) = *string;
      v32 = (char *)lydict_insert(a1, string + 1, *(unsigned __int16 *)(2LL * i + v28[2]) - 2);
      v22 = *(_DWORD *)__tls_get_addr(&stru_335FC0);
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = 2;
      if (a1)
      {
        strncpy((char *)*v20 + *v19, v32, *(unsigned __int16 *)(2LL * i + v28[2]) - 2);
        *v19 += *(unsigned __int16 *)(2LL * i + v28[2]) - 2;
      }
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = v22;
      lydict_remove(a1, v32);
      *((_BYTE *)*v20 + (*v19)++) = string[*(unsigned __int16 *)(2LL * i + v28[2]) - 1];
    }
    else
    {
      strncpy(
        (char *)*v20 + *v19,
        (const char *)(v28[5] + *(unsigned __int16 *)(2LL * i + v28[1])),
        *(unsigned __int16 *)(2LL * i + v28[2]));
      *v19 += *(unsigned __int16 *)(2LL * i + v28[2]);
    }
    goto LABEL_37;
  }
  sub_13937((void *)a1, 2, 1u, v17, (__int64)"namespace prefix", v8, v17);
  sub_13937((void *)a1, -1, 5u, 0LL, (__int64)"Node name is missing module prefix.", v16);
LABEL_40:
  sub_C488D((__int64)v28);
  return 1LL;
}
// 7400: using guessed type __int64  ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD);
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 7890: using guessed type __int64  lyxml_get_ns(_QWORD, _QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (0000000000009A10) ----------------------------------------------------
__int64  sub_9A10(__int64 a1, const char *a2, char *a3, unsigned int a4, unsigned int a5)
{
  __int64 v5; // r9
  __int64 result; // rax
  unsigned __int64 v7; // [rsp+0h] [rbp-50h]
  char *v8; // [rsp+8h] [rbp-48h]
  void *ptr; // [rsp+30h] [rbp-20h]
  size_t size; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = __PAIR__(a4, a5);
  v12 = __readfsqword(0x28u);
  size = strlen(a2) + 1;
  ptr = malloc(size);
  if ( ptr )
  {
    v11 = 0LL;
    if ( (unsigned int)sub_91C4(a1, a2, &ptr, &v11, &size, v8, SHIDWORD(v7), v7) )
    {
      free(ptr);
      result = 0LL;
    }
    else
    {
      *((_BYTE *)ptr + v11) = 0;
      result = lydict_insert_zc(a1, ptr);
    }
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_xml2json", v5, v7, v8, a2);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);

//----- (0000000000009B1E) ----------------------------------------------------
char * ly_path_xml2json(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  char *result; // rax
  char *v8; // [rsp+8h] [rbp-28h]
  char *v9; // [rsp+20h] [rbp-10h]
  char *s; // [rsp+28h] [rbp-8h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_path_xml2json", a4, a5, a6);
  v9 = 0LL;
  if ( a1 && a2 && v8 )
  {
    s = (char *)sub_9A10(a1, a2, v8, 0, 1u);
    if ( s )
    {
      v9 = strdup(s);
      lydict_remove(a1, s);
    }
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_path_xml2json", v6);
    result = 0LL;
  }
  return result;
}
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (0000000000009BED) ----------------------------------------------------
__int64  sub_9BED(__int64 *a1, const char *a2)
{
  __int64 v2; // r9
  __int64 result; // rax
  __int64 v4; // r9
  size_t v5; // ST38_8
  __int64 v6; // r9
  signed __int64 v7; // ST38_8
  size_t v8; // ST38_8
  unsigned __int16 i; // [rsp+1Eh] [rbp-52h]
  const char *j; // [rsp+20h] [rbp-50h]
  __int128 ptr; // [rsp+28h] [rbp-48h]
  char *v12; // [rsp+38h] [rbp-38h]
  void *v13; // [rsp+40h] [rbp-30h]
  _QWORD *v14; // [rsp+48h] [rbp-28h]
  char *v15; // [rsp+50h] [rbp-20h]
  char *src; // [rsp+58h] [rbp-18h]
  char *srca; // [rsp+58h] [rbp-18h]
  char *srcb; // [rsp+58h] [rbp-18h]
  __int64 v19; // [rsp+60h] [rbp-10h]
  __int64 v20; // [rsp+68h] [rbp-8h]
  __int64 v21; // [rsp+68h] [rbp-8h]

  v13 = (void *)*a1;
  *((_QWORD *)&ptr + 1) = strlen(a2) + 1;
  *(_QWORD *)&ptr = malloc(*((size_t *)&ptr + 1));
  if ( (_QWORD)ptr )
  {
    v12 = 0LL;
    v14 = sub_CB4D2(v13, a2);
    if ( v14 )
    {
      for ( i = 0; i < *((_WORD *)v14 + 16); ++i )
      {
        v15 = (char *)(v14[5] + *(unsigned __int16 *)(2LL * i + v14[1]));
        if ( i )
        {
          src = (char *)(v14[5]
                       + *(unsigned __int16 *)(2LL * i - 2 + v14[1])
                       + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + v14[2]));
          if ( src != v15 )
          {
            strncpy(&v12[ptr], src, v15 - src);
            v12 += v15 - src;
          }
        }
        if ( *(_DWORD *)(4LL * i + *v14) == 9
          && (srca = sub_811F(v15, 58, *(unsigned __int16 *)(2LL * i + v14[2]))) != 0LL )
        {
          v19 = srca - v15;
          v20 = sub_407F3(a1, v15, (signed int)srca - (signed int)v15, 0LL, 0, 0);
          if ( !v20 )
          {
            sub_13937(v13, 29, 0, 0LL, v19, (__int64)v15, a2);
            goto LABEL_32;
          }
          *((_QWORD *)&ptr + 1) += strlen(*(const char **)(v20 + 8)) - v19;
          *(_QWORD *)&ptr = sub_C422((void *)ptr, *((size_t *)&ptr + 1));
          if ( !(_QWORD)ptr )
          {
            sub_12222((__int64)v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_schema2json", v4, a2);
            goto LABEL_32;
          }
          strcpy(&v12[ptr], *(const char **)(v20 + 8));
          v5 = (size_t)&v12[strlen(*(const char **)(v20 + 8))];
          strncpy((char *)(v5 + ptr), srca, *(unsigned __int16 *)(2LL * i + v14[2]) - v19);
          v12 = (char *)(*(unsigned __int16 *)(2LL * i + v14[2]) - v19 + v5);
        }
        else if ( *(_DWORD *)(4LL * i + *v14) == 17
               && (srcb = sub_811F(v15, 58, *(unsigned __int16 *)(2LL * i + v14[2]))) != 0LL )
        {
          for ( j = srcb; (*__ctype_b_loc())[*(j - 1)] & 8 || *(j - 1) == 95 || *(j - 1) == 45 || *(j - 1) == 46; --j )
            ;
          v21 = sub_407F3(a1, j, (signed int)srcb - (signed int)j, 0LL, 0, 0);
          if ( v21 )
          {
            *((_QWORD *)&ptr + 1) += strlen(*(const char **)(v21 + 8)) - (srcb - j);
            *(_QWORD *)&ptr = sub_C422((void *)ptr, *((size_t *)&ptr + 1));
            if ( !(_QWORD)ptr )
            {
              sub_12222(
                (__int64)v13,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"transform_schema2json",
                v6,
                a2);
              goto LABEL_32;
            }
            strncpy(&v12[ptr], v15, j - v15);
            v7 = (signed __int64)&v12[j - v15];
            strcpy((char *)(ptr + v7), *(const char **)(v21 + 8));
            v8 = strlen(*(const char **)(v21 + 8)) + v7;
            strncpy((char *)(v8 + ptr), srcb, (size_t)&v15[*(unsigned __int16 *)(2LL * i + v14[2]) - (_QWORD)srcb]);
            v12 = &v15[*(unsigned __int16 *)(2LL * i + v14[2]) - (_QWORD)srcb + v8];
          }
          else
          {
            strncpy(
              &v12[ptr],
              (const char *)(v14[5] + *(unsigned __int16 *)(2LL * i + v14[1])),
              *(unsigned __int16 *)(2LL * i + v14[2]));
            v12 += *(unsigned __int16 *)(2LL * i + v14[2]);
          }
        }
        else
        {
          strncpy(
            &v12[ptr],
            (const char *)(v14[5] + *(unsigned __int16 *)(2LL * i + v14[1])),
            *(unsigned __int16 *)(2LL * i + v14[2]));
          v12 += *(unsigned __int16 *)(2LL * i + v14[2]);
        }
      }
      v12[ptr] = 0;
      sub_C488D((__int64)v14);
      result = lydict_insert_zc(*a1, ptr);
    }
    else
    {
LABEL_32:
      free((void *)ptr);
      sub_C488D((__int64)v14);
      result = 0LL;
    }
  }
  else
  {
    sub_12222((__int64)v13, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_schema2json", v2, a2);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000000A2CB) ----------------------------------------------------
__int64  sub_A2CB(__int64 *a1, const char *a2)
{
  __int64 v2; // r9
  __int64 result; // rax
  char *i; // rax
  __int64 v5; // r9
  signed __int64 v6; // ST40_8
  size_t v7; // ST40_8
  char *s; // [rsp+10h] [rbp-50h]
  char *v9; // [rsp+18h] [rbp-48h]
  __int128 ptr; // [rsp+20h] [rbp-40h]
  signed __int64 v11; // [rsp+30h] [rbp-30h]
  void *v12; // [rsp+38h] [rbp-28h]
  char *v13; // [rsp+40h] [rbp-20h]
  __int64 v14; // [rsp+48h] [rbp-18h]
  unsigned __int64 v15; // [rsp+50h] [rbp-10h]
  __int64 v16; // [rsp+58h] [rbp-8h]

  v12 = (void *)*a1;
  s = (char *)a2;
  *((_QWORD *)&ptr + 1) = strlen(a2) + 1;
  *(_QWORD *)&ptr = malloc(*((size_t *)&ptr + 1));
  if ( (_QWORD)ptr )
  {
    v11 = 0LL;
    for ( i = strchr(a2, 58); ; i = strchr(v13 + 1, 58) )
    {
      v13 = i;
      if ( !i )
        break;
      v9 = sub_80BC(i - 1, &unk_107E6B, (signed int)i - (signed int)s - 1);
      if ( *v9 == 32 || *v9 == 12 || *v9 == 10 || *v9 == 13 || *v9 == 9 || *v9 == 11 || *v9 == 40 )
        ++v9;
      v14 = v13 - v9;
      v15 = (unsigned int)sub_16564(v9);
      if ( v15 < v13 - v9 )
      {
        sub_13937(v12, 55, 0, 0LL, (unsigned int)v9[v15], (__int64)&v9[v15], a2, a1);
        free((void *)ptr);
        return 0LL;
      }
      v16 = sub_407F3(a1, v9, v14, 0LL, 0, 0);
      if ( !v16 )
      {
        sub_13937(v12, -1, 0, 0LL, (__int64)"Module prefix \"%.*s\" is unknown.", v14, v9);
        free((void *)ptr);
        return 0LL;
      }
      *((_QWORD *)&ptr + 1) += strlen(*(const char **)(v16 + 8)) - v14;
      *(_QWORD *)&ptr = sub_C422((void *)ptr, *((size_t *)&ptr + 1));
      if ( !(_QWORD)ptr )
      {
        sub_12222(
          (__int64)v12,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"transform_iffeat_schema2json",
          v5,
          a2);
        return 0LL;
      }
      strncpy((char *)(ptr + v11), s, v9 - s);
      v6 = v9 - s + v11;
      strcpy((char *)(ptr + v6), *(const char **)(v16 + 8));
      v7 = strlen(*(const char **)(v16 + 8)) + v6;
      *(_BYTE *)(ptr + v7) = 58;
      v11 = v7 + 1;
      s = v13 + 1;
    }
    strcpy((char *)(v11 + ptr), s);
    if ( *((_QWORD *)&ptr + 1) != strlen(s) + v11 + 1 )
      __assert_fail(
        "out_size == out_used",
        "/home/mantovan/Repositories/libyang/src/common.c",
        0x2F1u,
        "transform_iffeat_schema2json");
    result = lydict_insert_zc(v12, ptr);
  }
  else
  {
    sub_12222(
      (__int64)v12,
      0,
      1,
      "Memory allocation failed (%s()).",
      (__int64)"transform_iffeat_schema2json",
      v2,
      a2,
      a1);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);

//----- (000000000000A671) ----------------------------------------------------
signed __int64  sub_A671(void **a1, __int64 a2, __int64 a3, _DWORD *a4, int a5, void **a6, __int64 *a7, size_t *a8)
{
  __int64 v9; // r8
  __int64 v10; // r9
  char *ptr; // ST70_8
  __int64 v12; // rax
  size_t v13; // rbx
  __int64 v14; // r9
  __int64 v15; // rbx
  char *v16; // ST70_8
  size_t v17; // rbx
  __int64 v18; // r9
  __int64 v19; // rbx
  void **v20; // [rsp+0h] [rbp-80h]
  int v21; // [rsp+Ch] [rbp-74h]
  _DWORD *v22; // [rsp+10h] [rbp-70h]
  __int64 v23; // [rsp+18h] [rbp-68h]
  __int64 v24; // [rsp+20h] [rbp-60h]
  char *src; // [rsp+38h] [rbp-48h]
  char *srca; // [rsp+38h] [rbp-48h]
  char *srcb; // [rsp+38h] [rbp-48h]
  char *srcc; // [rsp+38h] [rbp-48h]
  char *i; // [rsp+40h] [rbp-40h]
  size_t n; // [rsp+48h] [rbp-38h]
  size_t na; // [rsp+48h] [rbp-38h]
  void *v32; // [rsp+50h] [rbp-30h]
  char *string; // [rsp+58h] [rbp-28h]
  __int64 v34; // [rsp+68h] [rbp-18h]

  v24 = a2;
  v23 = a3;
  v22 = a4;
  v21 = a5;
  v20 = a6;
  v32 = *a1;
  while ( 1 )
  {
    if ( *v22 >= (unsigned int)*(unsigned __int16 *)(v23 + 32) )
      return 0LL;
    if ( v21 == *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) )
      return 0LL;
    string = (char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22));
    if ( *v22 )
    {
      src = (char *)(*(_QWORD *)(v23 + 40)
                   + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)(*v22 - 1))
                   + (unsigned __int64)*(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)(*v22 - 1)));
      if ( src != string )
      {
        strncpy((char *)*v20 + *a7, src, string - src);
        *a7 += string - src;
      }
    }
    if ( *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) == 3 )
    {
      strncpy(
        (char *)*v20 + *a7,
        (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
        *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
      *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)(*v22)++);
      if (a1)
        return 0xFFFFFFFFLL;
      if ( *v22 >= (unsigned int)*(unsigned __int16 *)(v23 + 32) )
      {
        sub_13937(v32, 68, 0, 0LL, v9, v10, v20);
        return 0xFFFFFFFFLL;
      }
      strncpy(
        (char *)*v20 + *a7,
        (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
        *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
      *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
      goto LABEL_45;
    }
    if ( *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) == 9 )
      break;
    if ( *(_DWORD *)(*(_QWORD *)v23 + 4LL * (unsigned int)*v22) == 17
      && (srcc = sub_811F(string, 58, *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22))) != 0LL )
    {
      for ( i = srcc; (*__ctype_b_loc())[*(i - 1)] & 8 || *(i - 1) == 95 || *(i - 1) == 45 || *(i - 1) == 46; --i )
        ;
      v16 = strndup(i, srcc - i);
      v34 = ly_ctx_get_module(v32, v16, 0LL, 1LL);
      free(v16);
      if ( v34 && (void **)v34 != a1 )
      {
        v17 = *a8;
        *a8 = v17 + strlen(*(const char **)(v34 + 8)) - (srcc - i);
        *v20 = sub_C422(*v20, *a8);
        if ( !*v20 )
        {
          sub_12222(
            (__int64)v32,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"transform_json2xpath_subexpr",
            v18,
            v20);
          return 0xFFFFFFFFLL;
        }
        strncpy((char *)*v20 + *a7, string, i - string);
        *a7 += i - string;
        strcpy((char *)*v20 + *a7, *(const char **)(v34 + 8));
        v19 = *a7;
        *a7 = v19 + strlen(*(const char **)(v34 + 8));
        strncpy(
          (char *)*v20 + *a7,
          srcc,
          (size_t)&string[*(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - (_QWORD)srcc]);
        *a7 += (__int64)&string[*(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - (_QWORD)srcc];
      }
      else
      {
        strncpy(
          (char *)*v20 + *a7,
          (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
          *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
        *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
      }
    }
    else
    {
      strncpy(
        (char *)*v20 + *a7,
        (const char *)(*(_QWORD *)(v23 + 40) + *(unsigned __int16 *)(*(_QWORD *)(v23 + 8) + 2LL * (unsigned int)*v22)),
        *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
      *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
    }
LABEL_45:
    ++*v22;
  }
  srca = sub_811F(string, 58, *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22));
  if ( !srca )
  {
    srcb = string;
    na = 0LL;
    goto LABEL_22;
  }
  n = srca - string;
  ptr = strndup(string, srca - string);
  v24 = ly_ctx_get_module(v32, ptr, 0LL, 1LL);
  free(ptr);
  if ( v24 )
  {
    srcb = srca + 1;
    na = n + 1;
LABEL_22:
    if ( (void **)v24 != a1 && *srcb != 42 || na && *srcb == 42 )
    {
      v13 = *a8;
      *a8 = v13 + strlen(*(const char **)(v24 + 8)) - na + 1;
      *v20 = sub_C422(*v20, *a8);
      if ( !*v20 )
      {
        sub_12222(
          (__int64)v32,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"transform_json2xpath_subexpr",
          v14,
          v20);
        return 0xFFFFFFFFLL;
      }
      strcpy((char *)*v20 + *a7, *(const char **)(v24 + 8));
      v15 = *a7;
      *a7 = v15 + strlen(*(const char **)(v24 + 8));
      *((_BYTE *)*v20 + (*a7)++) = 58;
    }
    strncpy((char *)*v20 + *a7, srcb, *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - na);
    *a7 += *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22) - na;
    goto LABEL_45;
  }
  if ( n )
    v12 = srca - string;
  else
    v12 = *(unsigned __int16 *)(*(_QWORD *)(v23 + 16) + 2LL * (unsigned int)*v22);
  sub_13937(v32, 29, 0, 0LL, v12, (__int64)string, v20);
  return 0xFFFFFFFFLL;
}
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000B085) ----------------------------------------------------
void * sub_B085(void **a1, const char *a2)
{
  __int64 v2; // r9
  void *result; // rax
  int v4; // [rsp+14h] [rbp-2Ch]
  void *ptr; // [rsp+18h] [rbp-28h]
  size_t size; // [rsp+20h] [rbp-20h]
  __int64 v7; // [rsp+28h] [rbp-18h]
  _QWORD *v8; // [rsp+30h] [rbp-10h]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  if ( !a1 || !a2 )
    __assert_fail(
      "cur_module && expr",
      "/home/mantovan/Repositories/libyang/src/common.c",
      0x3A7u,
      "transform_json2xpath");
  size = strlen(a2) + 1;
  ptr = malloc(size);
  if ( ptr )
  {
    v7 = 0LL;
    v8 = sub_CB4D2(*a1, a2);
    if ( v8 )
    {
      v4 = 0;
      if ( (unsigned int)sub_A671(a1, (__int64)a1, (__int64)v8, &v4, 0, &ptr, &v7, &size) )
      {
        free(ptr);
        sub_C488D((__int64)v8);
        result = 0LL;
      }
      else
      {
        *((_BYTE *)ptr + v7) = 0;
        sub_C488D((__int64)v8);
        result = ptr;
      }
    }
    else
    {
      free(ptr);
      result = 0LL;
    }
  }
  else
  {
    sub_12222((__int64)*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"transform_json2xpath", v2, a2);
    result = 0LL;
  }
  return result;
}

//----- (000000000000B202) ----------------------------------------------------
signed __int64  sub_B202(__int64 a1, _QWORD *a2, unsigned __int16 a3, void **a4, _WORD *a5)
{
  __int64 v5; // r9
  signed __int64 result; // rax
  _WORD *v7; // [rsp+8h] [rbp-38h]
  void **v8; // [rsp+10h] [rbp-30h]
  unsigned __int16 v9; // [rsp+1Ch] [rbp-24h]
  unsigned __int16 i; // [rsp+3Eh] [rbp-2h]

  v8 = a4;
  v7 = a5;
  v9 = a3;
  for ( i = *(_WORD *)(2LL * a3 + a2[2]);
        (*__ctype_b_loc())[*(char *)(a2[5] + *(unsigned __int16 *)(2LL * v9 + a2[1]) + i)] & 0x2000;
        ++i )
  {
    ;
  }
  *v8 = sub_C422(*v8, (unsigned __int16)*v7 + i);
  if ( *v8 )
  {
    sprintf((char *)*v8 + (unsigned __int16)*v7 - 1, "%.*s", i, a2[5] + *(unsigned __int16 *)(2LL * v9 + a2[1]));
    *v7 += i;
    result = 0LL;
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema_copy_token", v5);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000000B369) ----------------------------------------------------
signed __int64  sub_B369(void *a1, const char **a2, __int64 a3, _QWORD *a4, unsigned __int16 *a5, void **a6, _WORD *a7)
{
  int v7; // eax
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 i; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  const char *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rax
  int v21; // ebx
  __int64 v22; // r9
  const char *v23; // rbx
  __int64 v24; // rdx
  const char *v25; // rax
  __int64 v26; // r9
  const char *v27; // rax
  char *v28; // rax
  __int64 v29; // r9
  void **v31; // [rsp+0h] [rbp-80h]
  unsigned __int16 *v32; // [rsp+8h] [rbp-78h]
  _QWORD *v33; // [rsp+10h] [rbp-70h]
  __int64 v34; // [rsp+18h] [rbp-68h]
  __int16 v35; // [rsp+34h] [rbp-4Ch]
  __int16 v36; // [rsp+36h] [rbp-4Ah]
  unsigned __int16 v37; // [rsp+38h] [rbp-48h]
  unsigned __int16 v38; // [rsp+38h] [rbp-48h]
  unsigned __int16 j; // [rsp+38h] [rbp-48h]
  unsigned __int16 v40; // [rsp+3Ah] [rbp-46h]
  signed int v41; // [rsp+3Ch] [rbp-44h]
  _BOOL4 v42; // [rsp+40h] [rbp-40h]
  signed int v43; // [rsp+44h] [rbp-3Ch]
  char *s; // [rsp+48h] [rbp-38h]
  char *s2; // [rsp+50h] [rbp-30h]
  const char **v46; // [rsp+58h] [rbp-28h]
  __int64 v47; // [rsp+60h] [rbp-20h]
  const char **v48; // [rsp+60h] [rbp-20h]
  const char **v49; // [rsp+68h] [rbp-18h]

  v34 = a3;
  v33 = a4;
  v32 = a5;
  v31 = a6;
  s = 0LL;
  v41 = 0;
  v7 = *(_DWORD *)(*a4 + 4LL * *a5);
  switch ( v7 )
  {
    case 3:
      v41 = 4;
      if ( (unsigned int)sub_B202((__int64)a1, a4, *a5, a6, a7) )
        goto LABEL_108;
      ++*v32;
      v42 = 0;
      break;
    case 16:
      v42 = a2 == 0LL;
      break;
    case 1:
      v41 = 2;
      if ( (unsigned int)sub_B202((__int64)a1, a4, *a5, a6, a7) )
        goto LABEL_108;
      ++*v32;
      v42 = 0;
      break;
    default:
      v42 = 1;
      break;
  }
  v43 = 0;
  v49 = a2;
  while ( 2 )
  {
    if ( *v32 >= *((_WORD *)v33 + 16) )
    {
      if ( !v41 )
        return 0LL;
      sub_13937(a1, 68, 0, 0LL, (__int64)a5, (__int64)a6, v31);
      return 0xFFFFFFFFLL;
    }
    switch ( *(_DWORD *)(*v33 + 4LL * *v32) )
    {
      case 1:
      case 3:
        if ( a1 )
          goto LABEL_108;
        goto LABEL_103;
      case 5:
      case 6:
      case 9:
        if ( v43 )
        {
          if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
            goto LABEL_108;
          goto LABEL_103;
        }
        s = strndup(
              (const char *)(v33[5] + *(unsigned __int16 *)(v33[1] + 2LL * *v32)),
              *(unsigned __int16 *)(v33[2] + 2LL * *v32));
        if ( !s )
        {
          sub_12222(
            (__int64)a1,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"ly_path_data2schema_subexp",
            v8,
            v31);
          goto LABEL_108;
        }
        s2 = strchr(s, 58);
        if ( s2 )
          *s2++ = 0;
        if ( v42 )
        {
          if ( !s2 )
          {
            sub_13937(a1, 80, 0, 0LL, v9, v10, v31);
            goto LABEL_108;
          }
          v34 = ly_ctx_get_module(a1, s, 0LL, 0LL);
          if ( !v34 )
          {
            sub_13937(a1, 79, 4u, s, v11, v12, v31);
            goto LABEL_108;
          }
          v42 = 0;
        }
        if ( s2 )
        {
          if ( *s2 == 46 )
            goto LABEL_33;
        }
        else if ( *s == 46 )
        {
          goto LABEL_33;
        }
        if ( s2 )
        {
          if ( *s2 == 42 )
            goto LABEL_33;
        }
        else if ( *s == 42 )
        {
LABEL_33:
          free(s);
          s = 0LL;
          if ( v41 )
          {
            sub_12222((__int64)a1, 0, 3, "Invalid path used (%s in a subexpression).", 0LL, v13, v31);
            goto LABEL_108;
          }
          v43 = 1;
          if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
            goto LABEL_108;
          goto LABEL_103;
        }
        for ( i = lys_getnext(0LL, v49, v34, 256LL); ; i = lys_getnext(v46, v49, v34, 256LL) )
        {
          v46 = (const char **)i;
          if ( !i )
            break;
          if ( s2 )
            v17 = s2;
          else
            v17 = s;
          if ( !strcmp(*v46, v17) )
          {
            if ( !s2 || (v18 = lys_node_module(v46), !strcmp(*(const char **)(v18 + 8), s)) )
            {
              if ( s2 || (v19 = lys_node_module(v46), v19 == lys_node_module(v49)) )
              {
                v35 = 0;
                v47 = (__int64)v46;
                while ( (const char **)v47 != v49 )
                {
                  v47 = lys_parent(v47);
                  if ( !v47 || *(_DWORD *)(v47 + 56) != 4096 )
                    ++v35;
                }
                v40 = 0;
                while ( 1 )
                {
                  if ( !v35 )
                    goto LABEL_77;
                  v36 = v35 - 1;
                  v48 = v46;
                  while ( v36 )
                  {
                    v48 = (const char **)lys_parent(v48);
                    if ( !v48 )
                      __assert_fail(
                        "node2",
                        "/home/mantovan/Repositories/libyang/src/common.c",
                        0x44Bu,
                        "ly_path_data2schema_subexp");
                    if ( *((_DWORD *)v48 + 14) != 4096 )
                      --v36;
                  }
                  if ( v34 == lys_node_module(v48) && v49 )
                  {
                    v38 = strlen(*v48) + v40;
                    *v31 = sub_C422(*v31, (unsigned __int16)*a7 + v38);
                    if ( !*v31 )
                    {
                      sub_12222(
                        (__int64)a1,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"ly_path_data2schema_subexp",
                        v26,
                        v31);
                      goto LABEL_108;
                    }
                    if ( v40 )
                      v27 = "/";
                    else
                      v27 = (const char *)&unk_107EEB;
                    sprintf((char *)*v31 + (unsigned __int16)*a7 - 1, "%s%s", v27, *v48);
                    *a7 += v38;
                  }
                  else
                  {
                    v20 = lys_node_module(v48);
                    v21 = strlen(*(const char **)(v20 + 8)) + v40;
                    v37 = v21 + strlen(*v48) + 1;
                    *v31 = sub_C422(*v31, (unsigned __int16)*a7 + v37);
                    if ( !*v31 )
                    {
                      sub_12222(
                        (__int64)a1,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"ly_path_data2schema_subexp",
                        v22,
                        v31);
                      goto LABEL_108;
                    }
                    v23 = *v48;
                    v24 = *(_QWORD *)(lys_node_module(v48) + 8);
                    if ( v40 )
                      v25 = "/";
                    else
                      v25 = (const char *)&unk_107EEB;
                    sprintf((char *)*v31 + (unsigned __int16)*a7 - 1, "%s%s:%s", v25, v24, v23);
                    *a7 += v37;
                  }
                  v40 = 1;
                  --v35;
                }
              }
            }
          }
        }
LABEL_77:
        if ( v46 )
        {
          for ( j = 0;
                (*__ctype_b_loc())[*(char *)(v33[5]
                                           + *(unsigned __int16 *)(v33[2] + 2LL * *v32)
                                           + *(unsigned __int16 *)(v33[1] + 2LL * *v32)
                                           + j)] & 0x2000;
                ++j )
          {
            ;
          }
          if ( j )
          {
            *v31 = sub_C422(*v31, (unsigned __int16)*a7 + j);
            if ( !*v31 )
            {
              sub_12222(
                (__int64)a1,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"ly_path_data2schema_subexp",
                v29,
                v31);
              goto LABEL_108;
            }
            sprintf((char *)*v31 + (unsigned __int16)*a7 - 1, "%*s", j, " ");
            *a7 += j;
          }
          free(s);
          s = 0LL;
          v49 = v46;
LABEL_103:
          ++*v32;
          continue;
        }
        if ( s2 )
          v28 = s2;
        else
          v28 = s;
        sub_13937(a1, 81, 4u, v28, v15, v16, v31);
LABEL_108:
        free(s);
        return 0xFFFFFFFFLL;
      case 8:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
        v42 = 1;
        v43 = 0;
        v49 = a2;
        goto LABEL_91;
      case 0xA:
      case 0xB:
      case 0x11:
      case 0x12:
        goto LABEL_94;
      case 0x10:
LABEL_91:
        if ( *(_DWORD *)(*v33 + 4LL * *v32) == 16 && *(_WORD *)(v33[2] + 2LL * *v32) == 2 )
          v43 = 1;
LABEL_94:
        if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
          goto LABEL_108;
        goto LABEL_103;
      default:
        if ( !v41 || v41 != *(_DWORD *)(*v33 + 4LL * *v32) )
        {
          sub_12222(
            (__int64)a1,
            0,
            3,
            "Invalid token used (%.*s).",
            *(unsigned __int16 *)(v33[2] + 2LL * *v32),
            v33[5] + *(unsigned __int16 *)(v33[1] + 2LL * *v32),
            v31);
          goto LABEL_108;
        }
        if ( (unsigned int)sub_B202((__int64)a1, v33, *v32, v31, a7) )
          goto LABEL_108;
        return 0LL;
    }
  }
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000000BE5A) ----------------------------------------------------
void * ly_path_data2schema(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  void *result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  char *string; // [rsp+0h] [rbp-70h]
  unsigned __int16 v18; // [rsp+1Ch] [rbp-54h]
  __int16 v19; // [rsp+1Eh] [rbp-52h]
  int v20; // [rsp+20h] [rbp-50h]
  int v21; // [rsp+24h] [rbp-4Ch]
  int v22; // [rsp+28h] [rbp-48h]
  int v23; // [rsp+2Ch] [rbp-44h]
  void *dest; // [rsp+30h] [rbp-40h]
  char *v25; // [rsp+38h] [rbp-38h]
  const char *v26; // [rsp+40h] [rbp-30h]
  __int64 v27; // [rsp+48h] [rbp-28h]
  const char **v28; // [rsp+50h] [rbp-20h]
  void *ptr; // [rsp+58h] [rbp-18h]
  _QWORD *v30; // [rsp+60h] [rbp-10h]
  unsigned __int64 v31; // [rsp+68h] [rbp-8h]

  v31 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_107C20, (__int64)"ly_path_data2schema", a4, a5, a6, a2);
  v19 = 0;
  v22 = -1;
  v27 = 0LL;
  v28 = 0LL;
  if ( !a1 || !string )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_path_data2schema", v6);
    return 0LL;
  }
  v23 = sub_17847(string, &v25, (unsigned int *)&v20, &v26, (unsigned int *)&v21, &v22, 0LL, 0LL, 1);
  if ( v23 <= 0 )
  {
    sub_13937(a1, 78, 0, 0LL, (unsigned int)string[-v23], (__int64)&string[-v23]);
    return 0LL;
  }
  if ( *v26 == 35 )
  {
    if ( v22 )
    {
      sub_13937(a1, 78, 0, 0LL, 35LL, (__int64)v26);
      return 0LL;
    }
    ++v26;
    --v21;
    if ( !v25 )
    {
      ptr = strndup(string, &v26[v21] - string);
      sub_13937(a1, 80, 4u, (char *)ptr, v8, v9);
      free(ptr);
      return 0LL;
    }
    ptr = strndup(v25, v20);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema", v10);
      return 0LL;
    }
    v27 = ly_ctx_get_module(a1, ptr, 0LL, 1LL);
    free(ptr);
    if ( !v27 )
    {
      ptr = strndup(string, &v25[v20] - string);
      sub_13937(a1, 79, 4u, (char *)ptr, v11, v12);
      free(ptr);
      return 0LL;
    }
    v28 = (const char **)sub_40D5F(v27, v26, v21);
    if ( !v28 )
    {
      ptr = strndup(string, &v26[v21] - string);
      sub_13937(a1, 81, 4u, (char *)ptr, v13, v14);
      free(ptr);
      return 0LL;
    }
    v18 = (_WORD)v26 + v21 - (_WORD)string + 1;
    dest = malloc(v18);
    if ( !dest )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema", v15);
      return 0LL;
    }
    memcpy(dest, string, v18 - 1);
    string += v23;
  }
  else
  {
    v18 = 1;
    dest = malloc(1uLL);
    if ( !dest )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_path_data2schema", v16);
      return 0LL;
    }
  }
  v30 = sub_CB4D2(a1, string);
  if ( v30 )
  {
    if ( v28 )
    {
      if ( (unsigned int)sub_B369(a1, v28, v27, v30, (unsigned __int16 *)&v19, &dest, &v18) )
      {
        free(dest);
        dest = 0LL;
      }
    }
    else if ( (unsigned int)sub_B369(a1, 0LL, 0LL, v30, (unsigned __int16 *)&v19, &dest, &v18) )
    {
      free(dest);
      dest = 0LL;
    }
    sub_C488D((__int64)v30);
    result = dest;
  }
  else
  {
    free(dest);
    result = 0LL;
  }
  return result;
}
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 107C20: using guessed type void *off_107C20;

//----- (000000000000C3AB) ----------------------------------------------------
__int64  sub_C3AB(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-4h]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 56) & 0xC && *(_DWORD *)(a1 + 128) == 9 )
    v2 = 8;
  if ( *(_DWORD *)(a1 + 56) & 0x18 )
    v2 |= 1u;
  if ( *(_DWORD *)(a1 + 56) == 16 && *(_BYTE *)(a1 + 31) )
    v2 |= 2u;
  if ( *(_DWORD *)(a1 + 56) & 0xC1BD )
    v2 |= 4u;
  return v2;
}

//----- (000000000000C422) ----------------------------------------------------
void * sub_C422(void *a1, size_t a2)
{
  void *v3; // [rsp+18h] [rbp-8h]

  v3 = realloc(a1, a2);
  if ( !v3 )
    free(a1);
  return v3;
}

//----- (000000000000C462) ----------------------------------------------------
signed __int64  sub_C462(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v3; // [rsp+0h] [rbp-10h]
  _BYTE *v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 1LL;
  if ( !a1 || !a2 )
    return 0LL;
  while ( *v4 == *v3 )
  {
    if ( !*v4 )
      return 1LL;
    ++v4;
    ++v3;
  }
  return 0LL;
}

//----- (000000000000C4C9) ----------------------------------------------------
signed __int64  sub_C4C9(unsigned __int8 a1)
{
  unsigned __int8 i; // [rsp+Bh] [rbp-9h]
  signed __int64 v3; // [rsp+Ch] [rbp-8h]

  v3 = 1LL;
  for ( i = 0; i < a1; ++i )
    v3 *= 10LL;
  return v3;
}

//----- (000000000000C508) ----------------------------------------------------
signed __int64  sub_C508(signed __int64 a1, unsigned __int8 a2, signed __int64 a3, unsigned __int8 a4)
{
  signed __int64 v5; // [rsp+0h] [rbp-18h]
  signed __int64 v6; // [rsp+10h] [rbp-8h]

  v6 = a1;
  v5 = a3;
  if ( a2 >= a4 )
  {
    if ( a2 > a4 )
      v6 = a1 / sub_C4C9(a2 - a4);
  }
  else
  {
    v5 = a3 / sub_C4C9(a4 - a2);
  }
  if ( v6 == v5 )
    return 0LL;
  if ( v6 <= v5 )
    return 0xFFFFFFFFLL;
  return 1LL;
}

//----- (000000000000C5A1) ----------------------------------------------------
__int64  sub_C5A1(const char **a1, unsigned __int8 a2)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rax
  unsigned int v5; // ST24_4
  unsigned __int64 v6; // rax
  unsigned __int8 v7; // [rsp+1Fh] [rbp-21h]
  int v8; // [rsp+20h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-1Ch]
  __int64 v10; // [rsp+28h] [rbp-18h]

  if ( a2 <= 3u && *((_BYTE *)a1 + a2 + 104) )
    return *((unsigned __int8 *)a1 + a2 + 104);
  v3 = lys_node_module(a1);
  v10 = v3;
  v4 = strlen(*(const char **)(v3 + 8));
  v5 = sub_1476E(0, *(_QWORD *)(v10 + 8), v4);
  v6 = strlen(*a1);
  v9 = sub_1476E(v5, (__int64)*a1, v6);
  if ( a2 )
  {
    if ( a2 <= strlen(*(const char **)(v10 + 8)) )
      v8 = a2;
    else
      v8 = strlen(*(const char **)(v10 + 8));
    v9 = sub_1476E(v9, *(_QWORD *)(v10 + 8), v8);
  }
  v7 = (128 >> a2) | (127 >> a2) & (unsigned __int64)sub_1476E(v9, 0LL, 0LL);
  if ( a2 <= 3u )
    *((_BYTE *)a1 + a2 + 104) = v7;
  return v7;
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000000C70A) ----------------------------------------------------
signed __int64  sub_C70A(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]
  int i; // [rsp+24h] [rbp-Ch]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v6 = lys_node_module(a1);
  for ( i = 0; i < v4; ++i )
  {
    if ( v6 == *(_QWORD *)(8LL * i + a2) )
      return 1LL;
  }
  return 0LL;
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000000C76D) ----------------------------------------------------
size_t  sub_C76D(const char *a1)
{
  size_t v2; // [rsp+18h] [rbp-18h]
  const char *i; // [rsp+20h] [rbp-10h]
  size_t v4; // [rsp+28h] [rbp-8h]

  v2 = 0LL;
  v4 = strlen(a1);
  for ( i = a1; *i && v2 < v4; i += byte_107F80[*(unsigned __int8 *)i] )
    ++v2;
  return v2;
}

//----- (000000000000C7DA) ----------------------------------------------------
__int64  ly_ctx_internal_modules_count(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_internal_modules_count", a4, a5, a6);
  if ( a1 )
    result = *(unsigned __int8 *)(a1 + 132);
  else
    result = 0LL;
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000C821) ----------------------------------------------------
pthread_key_t * ly_ctx_new(const char *a1, pthread_key_t a2)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  char *i; // rax
  int v16; // [rsp+10h] [rbp-30h]
  signed int j; // [rsp+14h] [rbp-2Ch]
  char *v18; // [rsp+18h] [rbp-28h]
  pthread_key_t *ptr; // [rsp+20h] [rbp-20h]
  char *v20; // [rsp+28h] [rbp-18h]
  char *v21; // [rsp+30h] [rbp-10h]
  __int64 v22; // [rsp+38h] [rbp-8h]

  v16 = 0;
  ptr = (pthread_key_t *)calloc(1uLL, 0x88uLL);
  if ( !ptr )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_new", v9);
    return 0LL;
  }
  sub_14546((__int64)ptr, 136LL, v6, v7, v8, v9);
  ly_load_plugins(ptr);
  if ( pthread_key_create(ptr + 32, (void (*)(void *))destr_function) )
  {
    sub_12222(0LL, 0, 2, "pthread_key_create() in ly_ctx_new() failed", v11, v12);
LABEL_26:
    ly_ctx_destroy(ptr, 0LL);
    return 0LL;
  }
  *((_QWORD *)ptr + 8) = calloc(0x10uLL, 8uLL);
  if ( !*((_QWORD *)ptr + 8) )
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_new", v13);
    free(ptr);
    return 0LL;
  }
  ptr[23] = a2;
  ptr[15] = 0;
  ptr[14] = 16;
  if ( a1 )
  {
    v20 = strdup(a1);
    if ( !v20 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_new", v14);
      goto LABEL_26;
    }
    v18 = v20;
    for ( i = strchr(v20, 58); ; i = strchr(v21 + 1, 58) )
    {
      v21 = i;
      if ( !i || v16 )
        break;
      *i = 0;
      v16 = ly_ctx_set_searchdir(ptr, v18);
      v18 = v21 + 1;
    }
    if ( *v18 && !v16 )
      v16 = ly_ctx_set_searchdir(ptr, v18);
    free(v20);
    if ( v16 )
      goto LABEL_26;
  }
  *((_WORD *)ptr + 45) = 1;
  if ( a2 & 4 )
    *((_BYTE *)ptr + 132) = 4;
  else
    *((_BYTE *)ptr + 132) = 6;
  for ( j = 0; j < *((unsigned __int8 *)ptr + 132); ++j )
  {
    v22 = lys_parse_mem(ptr, (&off_3457F0)[4 * j], *((unsigned int *)&unk_3457FC + 8 * j));
    if ( !v22 )
      goto LABEL_26;
    *(_BYTE *)(v22 + 64) = ((*((_BYTE *)&unk_3457F8 + 32 * j) & 1) << 7) | *(_BYTE *)(v22 + 64) & 0x7F;
  }
  return ptr;
}
// 7620: using guessed type __int64  ly_ctx_set_searchdir(_QWORD, _QWORD);
// 76E0: using guessed type __int64  ly_ctx_destroy(_QWORD, _QWORD);
// 77F0: using guessed type __int64  lys_parse_mem(_QWORD, _QWORD, _QWORD);
// 7C60: using guessed type __int64  ly_load_plugins(_QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;
// 3457F0: using guessed type char *off_3457F0;

//----- (000000000000CB4C) ----------------------------------------------------
signed __int64  sub_CB4C(__int64 a1, __int64 a2)
{
  __int64 v3; // ST40_8
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int i; // [rsp+18h] [rbp-58h]
  unsigned int k; // [rsp+1Ch] [rbp-54h]
  __int64 j; // [rsp+20h] [rbp-50h]
  __int64 v9; // [rsp+28h] [rbp-48h]
  __int64 v10; // [rsp+30h] [rbp-40h]
  __int64 v11; // [rsp+38h] [rbp-38h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  int v13; // [rsp+50h] [rbp-20h]
  unsigned int v14; // [rsp+54h] [rbp-1Ch]
  __int64 v15; // [rsp+58h] [rbp-18h]
  unsigned __int64 v16; // [rsp+68h] [rbp-8h]

  v16 = __readfsqword(0x28u);
  v13 = 0;
  v14 = 0;
  v15 = 0LL;
  v11 = lyd_find_path(a2, "/ietf-yang-library:yang-library/modules-state/module");
  if ( !v11 )
    return 1LL;
  for ( i = 0; i < *(_DWORD *)(v11 + 4); ++i )
  {
    v3 = *(_QWORD *)(8LL * i + *(_QWORD *)(v11 + 8));
    v9 = 0LL;
    v10 = 0LL;
    ly_set_clean(&v13);
    for ( j = *(_QWORD *)(v3 + 64); j; j = *(_QWORD *)(j + 24) )
    {
      if ( !strcmp(**(const char ***)j, "name") )
      {
        v9 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "revision") )
      {
        v10 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "feature") )
      {
        ly_set_add(&v13, j, 1LL);
      }
      else
      {
        strcmp(**(const char ***)j, "conformance-type");
      }
    }
    v12 = ly_ctx_load_module(a1, v9, v10);
    if ( !v12 )
    {
      sub_12222(a1, 0, 3, "Unable to load module specified by yang library data.", v4, v5);
      ly_set_free(v11);
      return 1LL;
    }
    for ( k = 0; k < v14; ++k )
      lys_features_enable(v12, *(_QWORD *)(*(_QWORD *)(8LL * k + v15) + 56LL));
  }
  ly_set_free(v11);
  return 0LL;
}
// 7230: using guessed type __int64  ly_set_clean(_QWORD);
// 7460: using guessed type __int64  lys_features_enable(_QWORD, _QWORD);
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 75A0: using guessed type __int64  lyd_find_path(_QWORD, _QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BF0: using guessed type __int64  ly_ctx_load_module(_QWORD, _QWORD, _QWORD);

//----- (000000000000CD97) ----------------------------------------------------
__int64  sub_CD97(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 ( *a5)(__int64, __int64, _QWORD, _QWORD, _QWORD))
{
  __int64 v5; // ST60_8
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 ( *v9)(__int64, __int64, _QWORD, _QWORD, _QWORD); // [rsp+0h] [rbp-90h]
  unsigned int v10; // [rsp+Ch] [rbp-84h]
  unsigned int i; // [rsp+24h] [rbp-6Ch]
  unsigned int k; // [rsp+28h] [rbp-68h]
  signed int v13; // [rsp+2Ch] [rbp-64h]
  __int64 j; // [rsp+30h] [rbp-60h]
  __int64 v15; // [rsp+38h] [rbp-58h]
  __int64 v16; // [rsp+40h] [rbp-50h]
  __int64 v17; // [rsp+48h] [rbp-48h]
  __int64 v18; // [rsp+50h] [rbp-40h]
  __int64 v19; // [rsp+58h] [rbp-38h]
  __int64 v20; // [rsp+68h] [rbp-28h]
  int v21; // [rsp+70h] [rbp-20h]
  unsigned int v22; // [rsp+74h] [rbp-1Ch]
  __int64 v23; // [rsp+78h] [rbp-18h]
  unsigned __int64 v24; // [rsp+88h] [rbp-8h]

  v10 = a3;
  v9 = a5;
  v24 = __readfsqword(0x28u);
  v21 = 0;
  v22 = 0;
  v23 = 0LL;
  v17 = 0LL;
  v19 = 0LL;
  v13 = 0;
  v18 = ly_ctx_new(a1, a4);
  if ( !v18
    || (v17 = v9(v18, a2, v10, 0LL, 0LL)) == 0
    || (v19 = lyd_find_path(v17, "/ietf-yang-library:yang-library/module-set[1]/module")) == 0 )
  {
LABEL_25:
    v13 = 1;
    goto LABEL_26;
  }
  if ( !*(_DWORD *)(v19 + 4) )
  {
    if ( !(unsigned int)sub_CB4C(v18, v17) )
      goto LABEL_26;
    goto LABEL_25;
  }
  for ( i = 0; i < *(_DWORD *)(v19 + 4); ++i )
  {
    v5 = *(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 8));
    v15 = 0LL;
    v16 = 0LL;
    ly_set_clean(&v21);
    for ( j = *(_QWORD *)(v5 + 64); j; j = *(_QWORD *)(j + 24) )
    {
      if ( !strcmp(**(const char ***)j, "name") )
      {
        v15 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "revision") )
      {
        v16 = *(_QWORD *)(j + 56);
      }
      else if ( !strcmp(**(const char ***)j, "feature") )
      {
        ly_set_add(&v21, j, 1LL);
      }
    }
    v20 = ly_ctx_load_module(v18, v15, v16);
    if ( !v20 )
    {
      sub_12222(0LL, 0, 3, "Unable to load module specified by yang library data.", v6, v7);
      goto LABEL_25;
    }
    for ( k = 0; k < v22; ++k )
      lys_features_enable(v20, *(_QWORD *)(*(_QWORD *)(8LL * k + v23) + 56LL));
  }
LABEL_26:
  if ( v17 )
    lyd_free_withsiblings(v17);
  if ( v19 )
    ly_set_free(v19);
  if ( v13 )
  {
    ly_ctx_destroy(v18, 0LL);
    v18 = 0LL;
  }
  return v18;
}
// 7230: using guessed type __int64  ly_set_clean(_QWORD);
// 7460: using guessed type __int64  lys_features_enable(_QWORD, _QWORD);
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 75A0: using guessed type __int64  lyd_find_path(_QWORD, _QWORD);
// 7670: using guessed type __int64  lyd_free_withsiblings(_QWORD);
// 76E0: using guessed type __int64  ly_ctx_destroy(_QWORD, _QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BF0: using guessed type __int64  ly_ctx_load_module(_QWORD, _QWORD, _QWORD);
// 7C30: using guessed type __int64  ly_ctx_new(_QWORD, _QWORD);

//----- (000000000000D09F) ----------------------------------------------------
__int64  ly_ctx_new_ylpath(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // ST0C_4
  unsigned int v7; // ST08_4

  v6 = a3;
  v7 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_new_ylpath", a4, a5, a6);
  return sub_CD97(a1, a2, v6, v7, (__int64 ( *)(__int64, __int64, _QWORD, _QWORD, _QWORD))lyd_parse_path);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D0F4) ----------------------------------------------------
__int64  ly_ctx_new_ylmem(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // ST0C_4
  unsigned int v7; // ST08_4

  v6 = a3;
  v7 = a4;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_new_ylmem", a4, a5, a6);
  return sub_CD97(a1, a2, v6, v7, (__int64 ( *)(__int64, __int64, _QWORD, _QWORD, _QWORD))lyd_parse_mem);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D149) ----------------------------------------------------
__int64  sub_D149(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 92) |= a2;
  }
  return result;
}

//----- (000000000000D173) ----------------------------------------------------
__int64  sub_D173(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 92) &= ~a2;
  }
  return result;
}

//----- (000000000000D19F) ----------------------------------------------------
__int64  ly_ctx_set_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_disable_searchdirs", a4, a5, a6);
  return sub_D149(a1, 8);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D1DC) ----------------------------------------------------
__int64  ly_ctx_unset_disable_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_disable_searchdirs", a4, a5, a6);
  return sub_D173(a1, 8);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D219) ----------------------------------------------------
__int64  ly_ctx_set_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_disable_searchdir_cwd", a4, a5, a6);
  return sub_D149(a1, 16);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D256) ----------------------------------------------------
__int64  ly_ctx_unset_disable_searchdir_cwd(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_disable_searchdir_cwd", a4, a5, a6);
  return sub_D173(a1, 16);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D293) ----------------------------------------------------
__int64  ly_ctx_set_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_prefer_searchdirs", a4, a5, a6);
  return sub_D149(a1, 32);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D2D0) ----------------------------------------------------
__int64  ly_ctx_unset_prefer_searchdirs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_prefer_searchdirs", a4, a5, a6);
  return sub_D173(a1, 32);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D30D) ----------------------------------------------------
__int64  ly_ctx_set_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_allimplemented", a4, a5, a6);
  return sub_D149(a1, 1);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D34A) ----------------------------------------------------
__int64  ly_ctx_unset_allimplemented(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_allimplemented", a4, a5, a6);
  return sub_D173(a1, 1);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D387) ----------------------------------------------------
__int64  ly_ctx_set_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_trusted", a4, a5, a6);
  return sub_D149(a1, 2);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D3C4) ----------------------------------------------------
__int64  ly_ctx_unset_trusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_trusted", a4, a5, a6);
  return sub_D173(a1, 2);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D401) ----------------------------------------------------
__int64  ly_ctx_get_options(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_options", a4, a5, a6);
  return *(unsigned int *)(a1 + 92);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D433) ----------------------------------------------------
signed __int64  ly_ctx_set_searchdir(__int64 a1, __int64 a2)
{
  __int64 v6; // r9
  int *v8; // rax
  char *v9; // rax
  int *v10; // rax
  char *v11; // rax
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  char *name; // [rsp+0h] [rbp-30h]
  int i; // [rsp+18h] [rbp-18h]
  unsigned int v17; // [rsp+1Ch] [rbp-14h]
  char *s1; // [rsp+20h] [rbp-10h]
  void *v19; // [rsp+28h] [rbp-8h]


  v17 = 1;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_set_searchdir", v6);
    return 1LL;
  }
  if ( !name )
    return 0LL;
  if ( access(name, 5) )
  {
    v8 = __errno_location();
    v9 = strerror(*v8);
    sub_12222(a1, 0, 2, "Unable to use search directory \"%s\" (%s)", (__int64)name, (__int64)v9);
    return 1LL;
  }
  s1 = realpath(name, 0LL);
  if ( s1 )
  {
    if ( *(_QWORD *)(a1 + 48) )
    {
      for ( i = 0; *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)); ++i )
      {
        if ( !strcmp(s1, *(const char **)(8LL * i + *(_QWORD *)(a1 + 48))) )
          goto LABEL_20;
      }
      v19 = realloc(*(void **)(a1 + 48), 8LL * (i + 2));
      if ( !v19 )
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_set_searchdir", v14);
        goto LABEL_22;
      }
      *(_QWORD *)(a1 + 48) = v19;
    }
    else
    {
      *(_QWORD *)(a1 + 48) = malloc(0x10uLL);
      if ( !*(_QWORD *)(a1 + 48) )
      {
        sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_set_searchdir", v13);
        goto LABEL_22;
      }
      i = 0;
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL * i) = s1;
    s1 = 0LL;
    *(_QWORD *)(8 * (i + 1LL) + *(_QWORD *)(a1 + 48)) = 0LL;
LABEL_20:
    v17 = 0;
    goto LABEL_22;
  }
  v10 = __errno_location();
  v11 = strerror(*v10);
  sub_12222(a1, 0, 2, "realpath() call failed (%s).", (__int64)v11, v12);
LABEL_22:
  free(s1);
  return v17;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D6FB) ----------------------------------------------------
__int64  ly_ctx_get_searchdirs(__int64 a1)
{
  __int64 v6; // r9

  if ( a1 )
    return *(_QWORD *)(a1 + 48);
  sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_searchdirs", v6);
  return 0LL;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D763) ----------------------------------------------------
__int64  ly_ctx_unset_searchdirs(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_unset_searchdirs", a4, a5, a6);
  result = *(_QWORD *)(a1 + 48);
  if ( result )
  {
    for ( i = 0; *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)); ++i )
    {
      if ( a2 >= 0 && a2 != i )
      {
        if ( i > a2 )
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL * i - 8) = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL * i);
          *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)) = 0LL;
        }
      }
      else
      {
        free(*(void **)(8LL * i + *(_QWORD *)(a1 + 48)));
        *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)) = 0LL;
      }
    }
    if ( a2 < 0 || (result = **(_QWORD **)(a1 + 48)) == 0 )
    {
      free(*(void **)(a1 + 48));
      result = a1;
      *(_QWORD *)(a1 + 48) = 0LL;
    }
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000D8AD) ----------------------------------------------------
void  ly_ctx_destroy(__int64 a1, __int64 a2)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  void ( *v10)(void **, void *); // [rsp+0h] [rbp-20h]
  int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    while ( *(_DWORD *)(a1 + 60) > 0 )
    {
      sub_A9496(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8));
      sub_A67C8(*(unsigned __int8 **)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8), v10, 1, 0);
      --*(_DWORD *)(a1 + 60);
    }
    if ( *(_QWORD *)(a1 + 48) )
    {
      for ( i = 0; *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 48)); ++i )
        free(*(void **)(8LL * i + *(_QWORD *)(a1 + 48)));
      free(*(void **)(a1 + 48));
    }
    free(*(void **)(a1 + 64));
    ly_err_clean(a1, 0LL);
    pthread_key_delete(*(_DWORD *)(a1 + 128));
    sub_145FF(a1, 0LL, v6, v7, v8, v9);
    ly_clean_plugins(a1);
    free((void *)a1);
  }
}
// 7530: using guessed type __int64  ly_clean_plugins(_QWORD);
// 77D0: using guessed type __int64  ly_err_clean(_QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000DA1A) ----------------------------------------------------
__int64  ly_ctx_get_submodule2(__int64 a1, __int64 a2)
{
  __int64 v6; // r9
  __int64 result; // rax
  _BYTE *v8; // [rsp+0h] [rbp-20h]
  signed int i; // [rsp+14h] [rbp-Ch]
  __int64 v10; // [rsp+18h] [rbp-8h]

  if ( a1 && v8 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(a1 + 70); ++i )
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * i);
      if ( (unsigned int)sub_C462(v8, *(_BYTE **)(v10 + 8)) )
        return v10;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_submodule2", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000DAED) ----------------------------------------------------
__int64  ly_ctx_get_submodule(__int64 a1, const char *a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  char *v8; // [rsp+8h] [rbp-58h]
  __int64 v9; // [rsp+10h] [rbp-50h]
  char *s1; // [rsp+18h] [rbp-48h]
  int v11; // [rsp+3Ch] [rbp-24h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  s1 = a3;
  v9 = a4;
  v8 = (char *)a5;
  v15 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_submodule", a4, a5, a6);
  v12 = 0LL;
  v11 = 0;
  if ( a1 && v9 && (!s1 || a2) )
  {
    while ( 1 )
    {
      v13 = ly_ctx_get_module_iter(a1, &v11);
      if ( !v13 )
        break;
      if ( (!a2 || !strcmp(*(const char **)(v13 + 8), a2))
        && (!s1 || *(_QWORD *)(v13 + 88) && !strcmp(s1, *(const char **)(v13 + 88))) )
      {
        v14 = ly_ctx_get_submodule2(v13, v9);
        if ( v14 )
        {
          if ( v8 )
          {
            if ( *(_QWORD *)(v14 + 88) && !strcmp(v8, *(const char **)(v14 + 88)) )
            {
              v12 = v14;
              break;
            }
          }
          else if ( v12 )
          {
            if ( *(_QWORD *)(v14 + 88)
              && (!*(_QWORD *)(v12 + 88) || strcmp(*(const char **)(v14 + 88), *(const char **)(v12 + 88)) > 0) )
            {
              v12 = v14;
            }
          }
          else
          {
            v12 = v14;
          }
        }
      }
    }
    result = v12;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_submodule", v6);
    result = 0LL;
  }
  return result;
}
// 75C0: using guessed type __int64  ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7AB0: using guessed type __int64  ly_ctx_get_submodule2(_QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000DCEF) ----------------------------------------------------
__int64  sub_DCEF(__int64 a1, const char *a2, size_t a3, int a4, char *a5, __int64 a6, int a7)
{
  __int64 result; // rax
  char *v8; // [rsp+8h] [rbp-48h]
  int v9; // [rsp+10h] [rbp-40h]
  int v10; // [rsp+14h] [rbp-3Ch]
  size_t n; // [rsp+18h] [rbp-38h]
  int i; // [rsp+3Ch] [rbp-14h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  char *s2; // [rsp+48h] [rbp-8h]

  n = a3;
  v10 = a4;
  v8 = a5;
  v9 = a6;
  v13 = 0LL;
  if ( a1 && a2 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
    {
      if ( v9 || !(*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) & 0x40) )
      {
        s2 = *(char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + v10);
        if ( *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64))
          && (n || !strcmp(a2, s2))
          && (!n || !strncmp(a2, s2, n) && !s2[n]) )
        {
          if ( v8 )
          {
            if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL)
              && !strcmp(v8, *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 88LL)) )
            {
              v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
              break;
            }
          }
          else if ( !v13
                 || *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL)
                 && (!*(_BYTE *)(v13 + 68)
                  || strcmp(
                       *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 88LL),
                       *(const char **)(v13 + 88)) >= 0) )
          {
            if ( a7 )
            {
              if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) < 0 )
              {
                v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
                break;
              }
            }
            else
            {
              v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
            }
          }
        }
      }
    }
    result = v13;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_by", a6);
    result = 0LL;
  }
  return result;
}

//----- (000000000000DFB3) ----------------------------------------------------
__int64  ly_ctx_get_module_by_ns(__int64 a1, const char *a2, char *a3, __int64 a4)
{
  char *v6; // ST18_8
  int v7; // ST14_4

  v6 = a3;
  v7 = a4;
  return sub_DCEF(a1, a2, 0LL, 176, v6, 0LL, v7);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E01C) ----------------------------------------------------
__int64  ly_ctx_get_module(__int64 a1, const char *a2, char *a3, __int64 a4)
{
  char *v6; // ST18_8
  int v7; // ST14_4

  v6 = a3;
  v7 = a4;
  return sub_DCEF(a1, a2, 0LL, 8, v6, 0LL, v7);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E085) ----------------------------------------------------
__int64  sub_E085(__int64 a1, const char *a2, size_t a3, char *a4, int a5)
{
  return sub_DCEF(a1, a2, a3, 8, a4, 0LL, a5);
}

//----- (000000000000E0D5) ----------------------------------------------------
__int64  ly_ctx_get_module_older(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+0h] [rbp-30h]
  int i; // [rsp+1Ch] [rbp-14h]
  __int64 v10; // [rsp+20h] [rbp-10h]
  __int64 v11; // [rsp+28h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_older", a4, a5, a6, a2);
  v10 = 0LL;
  if ( a1 && v8 && *(_BYTE *)(v8 + 68) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
    {
      v11 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
      if ( !(*(_BYTE *)(v11 + 64) & 0x40)
        && v11 != v8
        && *(_BYTE *)(v11 + 68)
        && (unsigned int)sub_C462(*(_BYTE **)(v8 + 8), *(_BYTE **)(v11 + 8))
        && strcmp(*(const char **)(v11 + 88), *(const char **)(v8 + 88)) < 0 )
      {
        if ( v10 )
        {
          if ( strcmp(*(const char **)(v11 + 88), *(const char **)(v10 + 88)) > 0 )
            v10 = v11;
        }
        else
        {
          v10 = v11;
        }
      }
    }
    result = v10;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_older", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E24D) ----------------------------------------------------
unsigned __int64  ly_ctx_set_module_imp_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  unsigned __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-18h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_module_imp_clb", a4, a5, a6);
  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_set_module_imp_clb", v6);
  *(_QWORD *)(a1 + 96) = a2;
  result = a1;
  *(_QWORD *)(a1 + 104) = v8;
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E2C8) ----------------------------------------------------
__int64  ly_ctx_get_module_imp_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  _QWORD *v8; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_imp_clb", a4, a5, a6, a2);
  if ( a1 )
  {
    if ( v8 )
      *v8 = *(_QWORD *)(a1 + 104);
    result = *(_QWORD *)(a1 + 96);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_imp_clb", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E34A) ----------------------------------------------------
unsigned __int64  ly_ctx_set_module_data_clb(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  unsigned __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-18h]

  v8 = a3;
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_set_module_data_clb", a4, a5, a6);
  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_set_module_data_clb", v6);
  *(_QWORD *)(a1 + 112) = a2;
  result = a1;
  *(_QWORD *)(a1 + 120) = v8;
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E3C5) ----------------------------------------------------
__int64  ly_ctx_get_module_data_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  _QWORD *v8; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_data_clb", a4, a5, a6, a2);
  if ( a1 )
  {
    if ( v8 )
      *v8 = *(_QWORD *)(a1 + 120);
    result = *(_QWORD *)(a1 + 112);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_data_clb", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000E447) ----------------------------------------------------
__int64  sub_E447(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6)
{
  _BOOL4 v6; // ebx
  __int64 v7; // rax
  __int64 v8; // r9
  size_t v10; // rax
  __int64 v11; // r9
  int *v12; // rax
  char *v13; // rax
  const char *v14; // rdx
  __int64 v15; // rax
  __int64 v16; // [rsp+0h] [rbp-1090h]
  unsigned int v17; // [rsp+Ch] [rbp-1084h]
  char *v18; // [rsp+10h] [rbp-1080h]
  char *s1; // [rsp+18h] [rbp-1078h]
  int v20; // [rsp+34h] [rbp-105Ch]
  int i; // [rsp+38h] [rbp-1058h]
  int fd; // [rsp+3Ch] [rbp-1054h]
  const char *s; // [rsp+40h] [rbp-1050h]
  char *v24; // [rsp+48h] [rbp-1048h]
  __int64 v25; // [rsp+50h] [rbp-1040h]
  char *v26; // [rsp+58h] [rbp-1038h]
  char *s2; // [rsp+60h] [rbp-1030h]
  size_t n; // [rsp+68h] [rbp-1028h]
  char resolved; // [rsp+70h] [rbp-1020h]
  unsigned __int64 v30; // [rsp+1078h] [rbp-18h]

  s1 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v30 = __readfsqword(0x28u);
  s = 0LL;
  v25 = 0LL;
  v6 = (*(_DWORD *)(a1 + 92) & 0x10) == 0;
  v7 = ly_ctx_get_searchdirs(a1);
  if ( (unsigned int)lys_search_localfile(v7, (unsigned int)v6, s1, v18, &s, &v20) )
  {
LABEL_51:
    free(s);
    return v25;
  }
  if ( s )
  {
    sub_12222(0LL, 2u, 0, "Loading schema from \"%s\" file.", (__int64)s, v8);
    v26 = strrchr(s, 46);
    v26[1] = 0;
    if ( !v18 )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
      {
        if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL) )
        {
          if ( !strcmp(s1, *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 8LL)) )
          {
            v10 = strlen(s);
            if ( !strncmp(s, *(const char **)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL), v10) )
            {
              v25 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
              if ( v17 && *(_BYTE *)(v25 + 64) >= 0 )
              {
                if ( (unsigned int)lys_set_implemented(v25) )
                  v25 = 0LL;
              }
              else if ( *(_BYTE *)(v25 + 64) & 0x40 )
              {
                lys_set_enabled(v25);
              }
              goto LABEL_51;
            }
          }
        }
      }
    }
    v26[1] = 121;
    fd = open(s, 0);
    if ( fd >= 0 )
    {
      if ( a2 )
        v25 = (__int64)sub_9DEAC(a2, fd, v20, v16);
      else
        v25 = sub_9DD36(a1, fd, v20, v18, v17, v11);
      close(fd);
      if ( v25 )
      {
        v24 = strrchr(s, 47);
        if ( v24 )
          ++v24;
        else
          v24 = s;
        s2 = strchr(v24, 64);
        n = strlen(*(const char **)(v25 + 8));
        if ( strncmp(v24, *(const char **)(v25 + 8), n) || s2 && s2 != &v24[n] || !s2 && v26 != &v24[n] )
          sub_12222(
            a1,
            1u,
            0,
            "File name \"%s\" does not match module name \"%s\".",
            (__int64)v24,
            *(_QWORD *)(v25 + 8));
        if ( s2 )
        {
          n = v26 - ++s2;
          if ( !*(_BYTE *)(v25 + 68) || n != 10 || strncmp(*(const char **)(v25 + 88), s2, 0xAuLL) )
          {
            if ( *(_BYTE *)(v25 + 68) )
              v14 = *(const char **)(v25 + 88);
            else
              v14 = "none";
            sub_12222(a1, 1u, 0, "File name \"%s\" does not match module revision \"%s\".", (__int64)v24, (__int64)v14);
          }
        }
        if ( !*(_QWORD *)(v25 + 56) )
        {
          if ( realpath(s, &resolved) )
            v15 = lydict_insert(a1, &resolved, 0LL);
          else
            v15 = lydict_insert(a1, s, 0LL);
          *(_QWORD *)(v25 + 56) = v15;
        }
      }
    }
    else
    {
      v12 = __errno_location();
      v13 = strerror(*v12);
      sub_12222(a1, 0, 2, "Unable to open data model file \"%s\" (%s).", (__int64)s, (__int64)v13);
    }
    goto LABEL_51;
  }
  if ( !a2 && !v18 )
    v25 = ly_ctx_get_module(a1, s1, 0LL, 0LL);
  if ( !v25 )
    sub_12222(a1, 0, 2, "Data model \"%s\" not found.", (__int64)s1, v8);
  return v25;
}
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 73C0: using guessed type __int64  lys_set_enabled(_QWORD);
// 73E0: using guessed type __int64  lys_search_localfile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 74B0: using guessed type __int64  lys_set_implemented(_QWORD);
// 79A0: using guessed type __int64  ly_ctx_get_searchdirs(_QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000000EB1C) ----------------------------------------------------
__int64  sub_EB1C(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 ( *v6)(__int64, __int64, __int64, __int64, __int64, int *, void ( **)(_QWORD, _QWORD)); // rax
  __int64 v7; // r8
  __int64 v8; // r10
  __int64 v9; // rdi
  int *v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-60h]
  unsigned int v15; // [rsp+Ch] [rbp-54h]
  __int64 v16; // [rsp+10h] [rbp-50h]
  __int64 v17; // [rsp+18h] [rbp-48h]
  __int64 v18; // [rsp+28h] [rbp-38h]
  int v19; // [rsp+3Ch] [rbp-24h]
  void ( *v20)(const char *, _QWORD); // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  const char *v22; // [rsp+50h] [rbp-10h]
  unsigned __int64 v23; // [rsp+58h] [rbp-8h]

  v18 = a1;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v23 = __readfsqword(0x28u);
  v21 = 0LL;
  v22 = 0LL;
  v19 = 0;
  v20 = 0LL;
  *(_DWORD *)ly_errno_glob_address(a1) = 0;
  if ( a2 )
  {
    v21 = lys_main_module(a2);
    v6 = *(__int64 ( **)(__int64, __int64, __int64, __int64, __int64, int *, void ( **)(_QWORD, _QWORD)))(a1 + 96);
    v7 = *(_QWORD *)(a1 + 104);
    if ( *(_BYTE *)(v21 + 68) )
      v8 = *(_QWORD *)(v21 + 88);
    else
      v8 = 0LL;
    v9 = *(_QWORD *)(v21 + 8);
    v22 = (const char *)v6(v9, v8, v17, v16, v7, &v19, (void ( **)(_QWORD, _QWORD))&v20);
  }
  else
  {
    v9 = v17;
    v22 = (const char *)(*(__int64 ( **)(__int64, __int64, _QWORD, _QWORD, _QWORD, int *, void ( **)(const char *, _QWORD)))(v18 + 96))(
                          v17,
                          v16,
                          0LL,
                          0LL,
                          *(_QWORD *)(v18 + 104),
                          &v19,
                          &v20);
  }
  if ( v22 || !*(_DWORD *)ly_errno_glob_address(v9) )
  {
    if ( v22 )
    {
      if ( a2 )
        v21 = (__int64)sub_9D687(a2, v22, v19, v14);
      else
        v21 = sub_9D438(v18, v22, v19, 0LL, 0LL, v15);
      if ( v20 )
        v20(v22, *(_QWORD *)(v18 + 104));
    }
    result = v21;
  }
  else
  {
    v10 = (int *)ly_errno_glob_address(v9);
    sub_12222(v18, 0, *v10, "User module retrieval callback failed!", v11, v12, v14);
    result = 0LL;
  }
  return result;
}
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);
// 7950: using guessed type __int64  lys_main_module(_QWORD);

//----- (000000000000ECF1) ----------------------------------------------------
__int64  sub_ECF1(__int64 a1, __int64 *a2, char *a3, char *a4, unsigned int a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-50h]
  unsigned int v8; // [rsp+Ch] [rbp-44h]
  char *s1; // [rsp+10h] [rbp-40h]
  char *v10; // [rsp+18h] [rbp-38h]
  signed int v11[3]; // [rsp+3Ch] [rbp-14h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  s1 = a4;
  v8 = a5;
  v7 = a6;
  *(_QWORD *)&v11[1] = 0LL;
  v12 = 0LL;
  if ( a2 )
    goto LABEL_53;
  v11[0] = 0;
  *(_QWORD *)&v11[1] = 0LL;
  while ( v11[0] < *(_DWORD *)(a1 + 60) )
  {
    *(_QWORD *)&v11[1] = *(_QWORD *)(8LL * v11[0] + *(_QWORD *)(a1 + 64));
    if ( (unsigned int)sub_C462(v10, *(_BYTE **)(*(_QWORD *)&v11[1] + 8LL)) )
    {
      if ( v12 )
      {
        if ( *(_BYTE *)(*(_QWORD *)&v11[1] + 68LL)
          && *(_BYTE *)(v12 + 68)
          && strcmp(*(const char **)(*(_QWORD *)&v11[1] + 88LL), *(const char **)(v12 + 88)) > 0 )
        {
          v12 = *(_QWORD *)&v11[1];
        }
      }
      else
      {
        v12 = *(_QWORD *)&v11[1];
      }
      if ( s1 && *(_BYTE *)(*(_QWORD *)&v11[1] + 68LL) && !strcmp(s1, *(const char **)(*(_QWORD *)&v11[1] + 88LL))
        || !s1 && *(_BYTE *)(*(_QWORD *)&v11[1] + 65LL) & 1
        || v8 && *(_BYTE *)(*(_QWORD *)&v11[1] + 64LL) < 0 && !s1 )
      {
        break;
      }
    }
    v11[2] = 0;
    *(_QWORD *)v11 = (unsigned int)(v11[0] + 1);
  }
  if ( !*(_QWORD *)&v11[1] )
  {
LABEL_53:
    if ( !*(_QWORD *)(a1 + 96) || *(_DWORD *)(a1 + 92) & 0x20 )
      goto LABEL_33;
    do
    {
      if ( *(_QWORD *)(a1 + 96) )
        *(_QWORD *)&v11[1] = sub_EB1C(a1, a2, (__int64)v10, (__int64)s1, v8, v7);
      if ( *(_QWORD *)&v11[1] || *(_DWORD *)(a1 + 92) & 0x20 )
        break;
LABEL_33:
      if ( !(*(_DWORD *)(a1 + 92) & 8) )
        *(_QWORD *)&v11[1] = sub_E447(a1, a2, v10, s1, v8, v7);
    }
    while ( !*(_QWORD *)&v11[1] && *(_DWORD *)(a1 + 92) & 0x20 );
    if ( *(_QWORD *)&v11[1]
      && !s1
      && v12
      && *(_BYTE *)(*(_QWORD *)&v11[1] + 68LL)
      && *(_BYTE *)(v12 + 68)
      && strcmp(*(const char **)(*(_QWORD *)&v11[1] + 88LL), *(const char **)(v12 + 88)) < 0 )
    {
      sub_A67C8(*(unsigned __int8 **)&v11[1], 0LL, 1, 1);
      *(_QWORD *)&v11[1] = 0LL;
    }
    if ( !*(_QWORD *)&v11[1] && v12 )
      *(_QWORD *)&v11[1] = v12;
    if ( !s1 && *(_QWORD *)&v11[1] )
      *(_BYTE *)(*(_QWORD *)&v11[1] + 65LL) |= 1u;
    result = *(_QWORD *)&v11[1];
  }
  else
  {
    if ( *(_BYTE *)(*(_QWORD *)&v11[1] + 64LL) & 0x40 )
      lys_set_enabled(*(_QWORD *)&v11[1]);
    if ( v8 )
    {
      if ( (unsigned int)lys_set_implemented(*(_QWORD *)&v11[1]) )
        *(_QWORD *)&v11[1] = 0LL;
    }
    result = *(_QWORD *)&v11[1];
  }
  return result;
}
// 73C0: using guessed type __int64  lys_set_enabled(_QWORD);
// 74B0: using guessed type __int64  lys_set_implemented(_QWORD);

//----- (000000000000F003) ----------------------------------------------------
__int64  ly_ctx_load_module(__int64 a1, char *a2, char *a3)
{
  __int64 v6; // r9
  __int64 result; // rax
  char *v8; // rax
  char *v9; // [rsp+8h] [rbp-18h]

  v9 = a3;

  if ( a1 && a2 )
  {
    if ( v9 && *v9 )
      v8 = v9;
    else
      v8 = 0LL;
    result = sub_ECF1(a1, 0LL, a2, v8, 1u, 0LL);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_load_module", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000F0B0) ----------------------------------------------------
__int64  sub_F0B0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int8 j; // [rsp+13h] [rbp-2Dh]
  int i; // [rsp+14h] [rbp-2Ch]
  unsigned int l; // [rsp+18h] [rbp-28h]
  unsigned int k; // [rsp+1Ch] [rbp-24h]
  unsigned int m; // [rsp+1Ch] [rbp-24h]
  unsigned int ii; // [rsp+1Ch] [rbp-24h]
  __int64 n; // [rsp+20h] [rbp-20h]
  __int64 v10; // [rsp+28h] [rbp-18h]
  __int64 v11; // [rsp+30h] [rbp-10h]

  for ( i = *(unsigned __int8 *)(a1 + 132) - 1; ; ++i )
  {
    result = *(unsigned int *)(a1 + 60);
    if ( i >= (signed int)result )
      break;
    v11 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64));
    for ( j = 0; j < *(_BYTE *)(v11 + 76); ++j )
    {
      if ( *(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) )
      {
        for ( k = 0; k < *(_DWORD *)(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) + 4LL); ++k )
        {
          if ( !a2
            || (unsigned int)ly_set_contains(
                               a2,
                               *(_QWORD *)(*(_QWORD *)(8LL * k
                                                     + *(_QWORD *)(*(_QWORD *)(((unsigned __int64)j << 6)
                                                                             + *(_QWORD *)(v11 + 128)
                                                                             + 56)
                                                                 + 8LL))
                                         + 48LL)) != -1 )
          {
            ly_set_rm_index(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56), k--);
          }
        }
        if ( !*(_DWORD *)(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) + 4LL) )
        {
          ly_set_free(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56));
          *(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v11 + 128) + 56) = 0LL;
        }
      }
    }
    for ( l = 0; l < *(unsigned __int16 *)(v11 + 72); ++l )
    {
      if ( *(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) )
      {
        for ( m = 0; m < *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) + 4LL); ++m )
        {
          if ( !a2
            || (unsigned int)ly_set_contains(
                               a2,
                               *(_QWORD *)(*(_QWORD *)(8LL * m
                                                     + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64)
                                                                 + 8LL))
                                         + 48LL)) != -1 )
          {
            ly_set_rm_index(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64), m--);
          }
        }
        if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) + 4LL) )
        {
          ly_set_free(*(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64));
          *(_QWORD *)(*(_QWORD *)(v11 + 120) + 72LL * l + 64) = 0LL;
        }
      }
    }
    for ( n = *(_QWORD *)(v11 + 168); n; n = v10 )
    {
      if ( *(_DWORD *)(n + 56) & 0xC && *(_QWORD *)(n + 72) )
      {
        if ( a2 )
        {
          for ( ii = 0; ii < *(_DWORD *)(*(_QWORD *)(n + 72) + 4LL); ++ii )
          {
            if ( (unsigned int)ly_set_contains(
                                 a2,
                                 *(_QWORD *)(*(_QWORD *)(8LL * ii + *(_QWORD *)(*(_QWORD *)(n + 72) + 8LL)) + 48LL)) != -1 )
              ly_set_rm_index(*(_QWORD *)(n + 72), ii--);
          }
          if ( !*(_DWORD *)(*(_QWORD *)(n + 72) + 4LL) )
          {
            ly_set_free(*(_QWORD *)(n + 72));
            *(_QWORD *)(n + 72) = 0LL;
          }
        }
        else
        {
          ly_set_free(*(_QWORD *)(n + 72));
          *(_QWORD *)(n + 72) = 0LL;
        }
      }
      v10 = *(_QWORD *)(n + 72);
      if ( *(_DWORD *)(n + 56) & 0x882C )
        v10 = 0LL;
      if ( !v10 )
        v10 = *(_QWORD *)(n + 80);
      while ( !v10 )
      {
        n = lys_parent(n);
        if ( !n )
          break;
        v10 = *(_QWORD *)(n + 80);
      }
    }
  }
  return result;
}
// 72E0: using guessed type __int64  ly_set_rm_index(_QWORD, _QWORD);
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 74C0: using guessed type __int64  ly_set_contains(_QWORD, _QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (000000000000F559) ----------------------------------------------------
__int64  sub_F559(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int128 v6; // di
  __int64 *v7; // rdi
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rbx
  __int64 v12; // [rsp+8h] [rbp-58h]
  unsigned int v13; // [rsp+10h] [rbp-50h]
  unsigned int i; // [rsp+14h] [rbp-4Ch]
  unsigned int j; // [rsp+18h] [rbp-48h]
  unsigned int k; // [rsp+1Ch] [rbp-44h]
  __int64 v17; // [rsp+20h] [rbp-40h]
  __int64 l; // [rsp+28h] [rbp-38h]
  __int64 v19; // [rsp+30h] [rbp-30h]
  __int64 v20; // [rsp+38h] [rbp-28h]
  __int64 v21; // [rsp+40h] [rbp-20h]
  unsigned __int64 v22; // [rsp+48h] [rbp-18h]

  v12 = a1;
  v22 = __readfsqword(0x28u);
  for ( i = 0; i < *(_DWORD *)(v12 + 4); ++i )
  {
    v19 = *(_QWORD *)(8LL * i + *(_QWORD *)(v12 + 8));
    if ( *(_BYTE *)(v19 + 64) < 0 )
    {
      for ( j = 0; j < *(unsigned __int16 *)(v19 + 72); ++j )
      {
        for ( k = 0; ; ++k )
        {
          a4 = *(_QWORD *)(v19 + 120);
          if ( k >= *(unsigned __int8 *)(a4 + 72LL * j + 31) )
            break;
          *((_QWORD *)&v6 + 1) = *(_QWORD *)(8LL * k + *(_QWORD *)(*(_QWORD *)(v19 + 120) + 72LL * j + 56));
          *(_QWORD *)&v6 = *(_QWORD *)(v19 + 120) + 72LL * j;
          sub_258B4(v6);
        }
      }
    }
    for ( j = 0; j < *(unsigned __int8 *)(v19 + 76); ++j )
    {
      for ( k = 0; k < *(unsigned __int8 *)(((unsigned __int64)j << 6) + *(_QWORD *)(v19 + 128) + 27); ++k )
      {
        v7 = (__int64 *)(*(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v19 + 128) + 40) + 32LL * k);
        sub_1902D(v7, 0LL, &v13);
        while ( 1 )
        {
          v9 = v13--;
          if ( !v9 )
            break;
          v21 = *(_QWORD *)(8LL * v13
                          + *(_QWORD *)(32LL * k
                                      + *(_QWORD *)(((unsigned __int64)j << 6) + *(_QWORD *)(v19 + 128) + 40)
                                      + 16));
          if ( !*(_QWORD *)(v21 + 56) )
          {
            v8 = ly_set_new(v7);
            *(_QWORD *)(v21 + 56) = v8;
          }
          v7 = *(__int64 **)(v21 + 56);
          ly_set_add(v7, *(_QWORD *)(v19 + 128) + ((unsigned __int64)j << 6), 1LL);
        }
      }
    }
    v17 = *(_QWORD *)(v19 + 168);
    for ( l = v17; l; l = v17 )
    {
      if ( *(_DWORD *)(l + 56) == 2048 )
        goto LABEL_40;
      if ( *(_DWORD *)(l + 56) & 0xC )
      {
        v20 = l + 128;
        if ( *(_DWORD *)(l + 128) == 9 )
          sub_A7706(*(_QWORD *)(v20 + 40), l, l, a4, a5, a6);
      }
      v17 = *(_QWORD *)(l + 72);
      if ( *(_DWORD *)(l + 56) & 0x802C )
        v17 = 0LL;
      if ( !v17 )
      {
LABEL_40:
        if ( l == *(_QWORD *)(v19 + 168) )
          break;
        v17 = *(_QWORD *)(l + 80);
      }
      while ( !v17 )
      {
        l = lys_parent(l);
        v10 = lys_parent(l);
        if ( v10 == lys_parent(*(_QWORD *)(v19 + 168)) )
          break;
        v17 = *(_QWORD *)(l + 80);
      }
    }
  }
  return 0LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000000F8D0) ----------------------------------------------------
signed __int64  lys_set_disabled(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rax
  unsigned __int8 k; // [rsp+16h] [rbp-2Ah]
  unsigned __int8 n; // [rsp+16h] [rbp-2Ah]
  char v13; // [rsp+17h] [rbp-29h]
  signed int i; // [rsp+18h] [rbp-28h]
  int j; // [rsp+18h] [rbp-28h]
  int m; // [rsp+1Ch] [rbp-24h]
  unsigned int l; // [rsp+20h] [rbp-20h]
  unsigned int ii; // [rsp+20h] [rbp-20h]
  unsigned int jj; // [rsp+20h] [rbp-20h]
  unsigned int kk; // [rsp+20h] [rbp-20h]
  unsigned int ll; // [rsp+24h] [rbp-1Ch]
  __int64 v22; // [rsp+28h] [rbp-18h]
  __int64 v23; // [rsp+28h] [rbp-18h]
  __int64 v24; // [rsp+30h] [rbp-10h]
  __int64 v25; // [rsp+38h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"lys_set_disabled", a4, a5, a6);
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 64) & 0x40 )
    {
      result = 0LL;
    }
    else
    {
      v24 = *(_QWORD *)a1;
      for ( i = 0; i < *(unsigned __int8 *)(v24 + 132); ++i )
      {
        if ( a1 == *(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 64)) )
        {
          sub_12222(v24, 0, 3, "Internal module \"%s\" cannot be disabled.", *(_QWORD *)(a1 + 8), v6);
          return 1LL;
        }
      }
      *(_BYTE *)(a1 + 64) |= 0x40u;
      v25 = ly_set_new(32LL);
      ly_set_add(v25, a1, 0LL);
LABEL_11:
      for ( j = *(unsigned __int8 *)(v24 + 132); j < *(_DWORD *)(v24 + 60); ++j )
      {
        v22 = *(_QWORD *)(8LL * j + *(_QWORD *)(v24 + 64));
        if ( !(*(_BYTE *)(v22 + 64) & 0x40) )
        {
          for ( k = 0; k < *(_BYTE *)(v22 + 69); ++k )
          {
            for ( l = 0; l < *(_DWORD *)(v25 + 4); ++l )
            {
              if ( *(_QWORD *)(*(_QWORD *)(v22 + 96) + 56LL * k) == *(_QWORD *)(8LL * l + *(_QWORD *)(v25 + 8)) )
              {
                *(_BYTE *)(v22 + 64) |= 0x40u;
                ly_set_add(v25, v22, 0LL);
                goto LABEL_11;
              }
            }
          }
          if ( *(_BYTE *)(v22 + 64) >= 0 )
          {
            v13 = 0;
            for ( m = *(unsigned __int8 *)(v24 + 132); m < *(_DWORD *)(v24 + 60); ++m )
            {
              if ( !(*(_BYTE *)(*(_QWORD *)(8LL * m + *(_QWORD *)(v24 + 64)) + 64LL) & 0x40) )
              {
                for ( n = 0; n < *(_BYTE *)(*(_QWORD *)(8LL * m + *(_QWORD *)(v24 + 64)) + 69LL); ++n )
                {
                  if ( v22 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(8LL * m + *(_QWORD *)(v24 + 64)) + 96LL) + 56LL * n) )
                  {
                    v13 = 1;
                    goto LABEL_31;
                  }
                }
              }
            }
LABEL_31:
            if ( !v13 )
            {
              *(_BYTE *)(v22 + 64) |= 0x40u;
              ly_set_add(v25, v22, 0LL);
              if ( *(_BYTE *)(v22 + 69) )
                goto LABEL_11;
            }
          }
        }
      }
      for ( ii = 0; ii < *(_DWORD *)(v25 + 4); ++ii )
      {
        v8 = *(_QWORD *)(8LL * ii + *(_QWORD *)(v25 + 8));
        *(_BYTE *)(v8 + 64) &= 0xBFu;
      }
      sub_F0B0(v24, v25);
      for ( jj = *(_DWORD *)(v25 + 4); ; sub_A9496(*(_QWORD *)(8LL * jj + *(_QWORD *)(v25 + 8))) )
      {
        v9 = jj--;
        if ( !v9 )
          break;
      }
      for ( kk = 0; kk < *(_DWORD *)(v25 + 4); ++kk )
      {
        v23 = *(_QWORD *)(8LL * kk + *(_QWORD *)(v25 + 8));
        *(_BYTE *)(v23 + 64) |= 0x40u;
        for ( ll = 0; ll < *(unsigned __int8 *)(v23 + 70); ++ll )
        {
          v10 = *(_QWORD *)(*(_QWORD *)(v23 + 104) + 48LL * ll);
          *(_BYTE *)(v10 + 64) |= 0x40u;
        }
      }
      ly_set_free(v25);
      ++*(_WORD *)(v24 + 90);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_set_disabled", v6);
    result = 1LL;
  }
  return result;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (000000000000FD3F) ----------------------------------------------------
__int64  sub_FD3F(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  unsigned int i; // [rsp+1Ch] [rbp-4h]
  unsigned int j; // [rsp+1Ch] [rbp-4h]

  ly_set_add(a1, a2, 0LL);
  *(_BYTE *)(a2 + 64) &= 0xBFu;
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 70); ++i )
  {
    v2 = *(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i);
    *(_BYTE *)(v2 + 64) &= 0xBFu;
  }
  for ( j = 0; ; ++j )
  {
    result = *(unsigned __int8 *)(a2 + 69);
    if ( j >= (unsigned int)result )
      break;
    if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 96) + 56LL * j) + 64LL) & 0x40 )
      sub_FD3F(a1, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 56LL * j));
  }
  return result;
}
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000000FE35) ----------------------------------------------------
signed __int64  lys_set_enabled(__int64 a1)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  signed int i; // [rsp+10h] [rbp-30h]
  int j; // [rsp+10h] [rbp-30h]
  unsigned int k; // [rsp+14h] [rbp-2Ch]
  unsigned int v17; // [rsp+14h] [rbp-2Ch]
  unsigned int l; // [rsp+18h] [rbp-28h]
  unsigned int n; // [rsp+18h] [rbp-28h]
  unsigned int m; // [rsp+1Ch] [rbp-24h]
  __int64 v21; // [rsp+20h] [rbp-20h]
  __int64 v22; // [rsp+28h] [rbp-18h]
  __int64 v23; // [rsp+30h] [rbp-10h]
  __int64 v24; // [rsp+38h] [rbp-8h]

  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 64) & 0x40 )
    {
      v22 = *(_QWORD *)a1;
      for ( i = 0; i < *(unsigned __int8 *)(v22 + 132); ++i )
      {
        if ( a1 == *(_QWORD *)(8LL * i + *(_QWORD *)(v22 + 64)) )
        {
          sub_12222(v22, 0, 3, "Internal module \"%s\" cannot be removed.", *(_QWORD *)(a1 + 8), v6);
          return 1LL;
        }
      }
      v23 = ly_set_new(32LL);
      v24 = ly_set_new(32LL);
      v8 = a1;
      sub_FD3F(v23, a1);
LABEL_11:
      for ( j = *(unsigned __int8 *)(v22 + 132); j < *(_DWORD *)(v22 + 60); ++j )
      {
        v9 = 8LL * j;
        v21 = *(_QWORD *)(v9 + *(_QWORD *)(v22 + 64));
        if ( *(_BYTE *)(v21 + 64) & 0x40 )
        {
          v8 = *(_QWORD *)(v9 + *(_QWORD *)(v22 + 64));
          if ( (unsigned int)ly_set_contains(v24, v21) == -1 )
          {
            for ( k = 0; k < *(unsigned __int8 *)(v21 + 69); ++k )
            {
              v10 = *(_QWORD *)(v21 + 96);
              v9 = k;
              if ( *(_BYTE *)(*(_QWORD *)(v10 + 56LL * k) + 64LL) & 0x40 )
                break;
            }
            if ( k >= *(unsigned __int8 *)(v21 + 69) )
            {
              v17 = 0;
LABEL_29:
              if ( v17 < *(unsigned __int8 *)(v21 + 69) )
              {
                for ( l = 0; ; ++l )
                {
                  if ( l >= *(_DWORD *)(v23 + 4) )
                  {
                    ++v17;
                    goto LABEL_29;
                  }
                  if ( *(_QWORD *)(*(_QWORD *)(v21 + 96) + 56LL * v17) == *(_QWORD *)(8LL * l + *(_QWORD *)(v23 + 8)) )
                    break;
                }
                *(_BYTE *)(v21 + 64) &= 0xBFu;
                v8 = v21;
                ly_set_add(v23, v21, 0LL);
                for ( m = 0; m < *(unsigned __int8 *)(v21 + 70); ++m )
                {
                  v10 = *(_QWORD *)(v21 + 104);
                  v13 = *(_QWORD *)(v10 + 48LL * m);
                  v9 = *(_BYTE *)(v13 + 64) & 0xBF;
                  *(_BYTE *)(v13 + 64) &= 0xBFu;
                }
                goto LABEL_11;
              }
              v8 = v21;
              ly_set_add(v24, v21, 0LL);
            }
          }
        }
      }
      sub_F559(v23, v8, v9, v10, v11, v12);
      for ( n = 0; n < *(_DWORD *)(v23 + 4); ++n )
      {
        if ( *(_BYTE *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v23 + 8)) + 64LL) < 0 )
          sub_A91FC(*(_QWORD *)(8LL * n + *(_QWORD *)(v23 + 8)));
      }
      ly_set_free(v23);
      ly_set_free(v24);
      ++*(_WORD *)(v22 + 90);
      result = 0LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lys_set_enabled", v6);
    result = 1LL;
  }
  return result;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 74C0: using guessed type __int64  ly_set_contains(_QWORD, _QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000101CE) ----------------------------------------------------
signed __int64  ly_ctx_remove_module(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  void ( *v8)(void **, void *); // [rsp+0h] [rbp-40h]
  unsigned __int8 l; // [rsp+1Ah] [rbp-26h]
  unsigned __int8 ii; // [rsp+1Ah] [rbp-26h]
  char v11; // [rsp+1Bh] [rbp-25h]
  signed int i; // [rsp+1Ch] [rbp-24h]
  int j; // [rsp+1Ch] [rbp-24h]
  int k; // [rsp+1Ch] [rbp-24h]
  int jj; // [rsp+1Ch] [rbp-24h]
  int n; // [rsp+20h] [rbp-20h]
  int v17; // [rsp+20h] [rbp-20h]
  unsigned int m; // [rsp+24h] [rbp-1Ch]
  unsigned int kk; // [rsp+24h] [rbp-1Ch]
  __int64 v20; // [rsp+28h] [rbp-18h]
  __int64 v21; // [rsp+30h] [rbp-10h]
  __int64 v22; // [rsp+38h] [rbp-8h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_remove_module", a4, a5, a6, a2);
  if ( a1 )
  {
    v21 = *a1;
    for ( i = 0; i < *(unsigned __int8 *)(v21 + 132); ++i )
    {
      if ( a1 == *(__int64 **)(8LL * i + *(_QWORD *)(v21 + 64)) )
      {
        sub_12222(v21, 0, 3, "Internal module \"%s\" cannot be removed.", a1[1], v6);
        return 1LL;
      }
    }
    for ( j = *(unsigned __int8 *)(v21 + 132); j < *(_DWORD *)(v21 + 60); ++j )
    {
      if ( a1 == *(__int64 **)(8LL * j + *(_QWORD *)(v21 + 64)) )
      {
        *(_QWORD *)(8LL * j + *(_QWORD *)(v21 + 64)) = 0LL;
        break;
      }
    }
    v22 = ly_set_new(32LL);
    ly_set_add(v22, a1, 0LL);
LABEL_14:
    for ( k = *(unsigned __int8 *)(v21 + 132); k < *(_DWORD *)(v21 + 60); ++k )
    {
      v20 = *(_QWORD *)(8LL * k + *(_QWORD *)(v21 + 64));
      if ( v20 )
      {
        for ( l = 0; l < *(_BYTE *)(v20 + 69); ++l )
        {
          for ( m = 0; m < *(_DWORD *)(v22 + 4); ++m )
          {
            if ( *(_QWORD *)(*(_QWORD *)(v20 + 96) + 56LL * l) == *(_QWORD *)(8LL * m + *(_QWORD *)(v22 + 8)) )
            {
              ly_set_add(v22, v20, 0LL);
              *(_QWORD *)(8LL * k + *(_QWORD *)(v21 + 64)) = 0LL;
              goto LABEL_14;
            }
          }
        }
        if ( *(_BYTE *)(v20 + 64) >= 0 )
        {
          v11 = 0;
          for ( n = *(unsigned __int8 *)(v21 + 132); n < *(_DWORD *)(v21 + 60); ++n )
          {
            if ( *(_QWORD *)(8LL * n + *(_QWORD *)(v21 + 64)) )
            {
              for ( ii = 0; ii < *(_BYTE *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v21 + 64)) + 69LL); ++ii )
              {
                if ( v20 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(8LL * n + *(_QWORD *)(v21 + 64)) + 96LL) + 56LL * ii) )
                {
                  v11 = 1;
                  goto LABEL_34;
                }
              }
            }
          }
LABEL_34:
          if ( !v11 )
          {
            ly_set_add(v22, v20, 0LL);
            *(_QWORD *)(8LL * k + *(_QWORD *)(v21 + 64)) = 0LL;
            if ( *(_BYTE *)(v20 + 69) )
              goto LABEL_14;
          }
        }
      }
    }
    v17 = *(unsigned __int8 *)(v21 + 132);
    for ( jj = *(unsigned __int8 *)(v21 + 132); jj < *(_DWORD *)(v21 + 60); ++jj )
    {
      if ( *(_QWORD *)(8LL * v17 + *(_QWORD *)(v21 + 64)) )
      {
        ++v17;
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(v21 + 64) + 8LL * v17) = *(_QWORD *)(*(_QWORD *)(v21 + 64) + 8LL * jj);
        *(_QWORD *)(8LL * jj + *(_QWORD *)(v21 + 64)) = 0LL;
      }
    }
    while ( !*(_QWORD *)(8LL * v17 + *(_QWORD *)(v21 + 64)) )
      --v17;
    *(_DWORD *)(v21 + 60) = v17 + 1;
    ++*(_WORD *)(v21 + 90);
    sub_F0B0(v21, v22);
    for ( kk = 0; kk < *(_DWORD *)(v22 + 4); ++kk )
    {
      sub_A9496(*(_QWORD *)(8LL * kk + *(_QWORD *)(v22 + 8)));
      sub_A67C8(*(unsigned __int8 **)(8LL * kk + *(_QWORD *)(v22 + 8)), v8, 1, 0);
    }
    ly_set_free(v22);
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_remove_module", v6);
    result = 1LL;
  }
  return result;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000106CA) ----------------------------------------------------
unsigned __int64  ly_ctx_clean(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  void ( *v7)(void **, void *); // [rsp+0h] [rbp-10h]

  result = sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_clean", a4, a5, a6, a2);
  if ( a1 )
  {
    while ( *(_DWORD *)(a1 + 60) > (signed int)*(unsigned __int8 *)(a1 + 132) )
    {
      sub_A9496(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8));
      sub_A67C8(*(unsigned __int8 **)(*(_QWORD *)(a1 + 64) + 8LL * *(signed int *)(a1 + 60) - 8), v7, 1, 0);
      *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * (signed int)(*(_DWORD *)(a1 + 60))-- - 8) = 0LL;
    }
    ++*(_WORD *)(a1 + 90);
    result = sub_F0B0(a1, 0LL);
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000107DD) ----------------------------------------------------
__int64  ly_ctx_get_module_iter(__int64 a1, __int64 a2)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // rsi
  unsigned int v9; // eax
  _DWORD *v10; // [rsp+0h] [rbp-10h]

  if ( a1 && v10 )
  {
    while ( *v10 < *(_DWORD *)(a1 + 60) )
    {
      if ( !(*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * (unsigned int)*v10) + 64LL) & 0x40) )
      {
        v8 = *(_QWORD *)(a1 + 64);
        v9 = (*v10)++;
        return *(_QWORD *)(v8 + 8LL * v9);
      }
      ++*v10;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_module_iter", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000108BB) ----------------------------------------------------
__int64  ly_ctx_get_disabled_module_iter(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  __int64 v8; // rsi
  unsigned int v9; // eax
  _DWORD *v10; // [rsp+0h] [rbp-10h]

  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_disabled_module_iter", a4, a5, a6, a2);
  if ( a1 && v10 )
  {
    while ( *v10 < *(_DWORD *)(a1 + 60) )
    {
      if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL * (unsigned int)*v10) + 64LL) & 0x40 )
      {
        v8 = *(_QWORD *)(a1 + 64);
        v9 = (*v10)++;
        return *(_QWORD *)(v8 + 8LL * v9);
      }
      ++*v10;
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_disabled_module_iter", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000010999) ----------------------------------------------------
signed __int64  sub_10999(__int64 a1, __int64 a2)
{
  signed int i; // [rsp+18h] [rbp-8h]
  signed int j; // [rsp+18h] [rbp-8h]
  signed int k; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a2 + 76); ++i )
  {
    if ( *(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(a2 + 128) + 24) & 0x100
      && !lyd_new_leaf(a1, 0LL, "feature", *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(a2 + 128))) )
    {
      return 1LL;
    }
  }
  for ( j = 0; j < *(unsigned __int8 *)(a2 + 70) && *(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j); ++j )
  {
    for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 76LL); ++k )
    {
      if ( *(_WORD *)(((signed __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 128LL) + 24) & 0x100
        && !lyd_new_leaf(
              a1,
              0LL,
              "feature",
              *(_QWORD *)(((signed __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * j) + 128LL))) )
      {
        return 1LL;
      }
    }
  }
  return 0LL;
}
// 7260: using guessed type __int64  lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000010B6F) ----------------------------------------------------
signed __int64  sub_10B6F(__int64 a1, __int64 a2, int a3)
{
  size_t v3; // rax
  void *v5; // rax
  int v6; // [rsp+Ch] [rbp-44h]
  int v7; // [rsp+28h] [rbp-28h]
  unsigned int i; // [rsp+2Ch] [rbp-24h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  char *v10; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v12 = __readfsqword(0x28u);
  v7 = 0;
  if ( *(_BYTE *)(a2 + 64) & 0x30 )
  {
LABEL_21:
    while ( 1 )
    {
      v9 = ly_ctx_get_module_iter(*(_QWORD *)a2, &v7);
      if ( !v9 )
        break;
      if ( v9 != a2 )
      {
        for ( i = 0; i < *(unsigned __int8 *)(v9 + 78); ++i )
        {
          v10 = strstr(*(const char **)(*(_QWORD *)(v9 + 144) + 56LL * i), *(const char **)(a2 + 8));
          if ( v10 )
          {
            v3 = strlen(*(const char **)(a2 + 8));
            if ( v10[v3] == 58 )
            {
              if ( v6 )
              {
                if ( lyd_new_leaf(a1, 0LL, "deviation", *(_QWORD *)(v9 + 8)) )
                  goto LABEL_21;
                return 1LL;
              }
              v11 = lyd_new(a1, 0LL, "deviation");
              if ( !v11 )
                return 1LL;
              if ( !lyd_new_leaf(v11, 0LL, "name", *(_QWORD *)(v9 + 8)) )
                return 1LL;
              if ( *(_BYTE *)(v9 + 68) )
                v5 = *(void **)(v9 + 88);
              else
                v5 = &unk_1086CA;
              if ( !lyd_new_leaf(v11, 0LL, "revision", v5) )
                return 1LL;
              goto LABEL_21;
            }
          }
        }
      }
    }
  }
  return 0LL;
}
// 7260: using guessed type __int64  lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);
// 75C0: using guessed type __int64  ly_ctx_get_module_iter(_QWORD, _QWORD);
// 7AE0: using guessed type __int64  lyd_new(_QWORD, _QWORD, _QWORD);

//----- (0000000000010D68) ----------------------------------------------------
signed __int64  sub_10D68(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rax
  __int64 v5; // r9
  const char *v6; // rax
  int v7; // [rsp+Ch] [rbp-34h]
  signed int i; // [rsp+24h] [rbp-1Ch]
  char *ptr; // [rsp+28h] [rbp-18h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v11 = __readfsqword(0x28u);
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 70) && *(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i); ++i )
  {
    v10 = lyd_new(a1, 0LL, "submodule");
    if ( !v10 )
      return 1LL;
    if ( !lyd_new_leaf(v10, 0LL, "name", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 8LL)) )
      return 1LL;
    if ( !v7 || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 68LL) )
    {
      v4 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 68LL) ? *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i)
                                                                                        + 88LL) : &unk_1086CA;
      if ( !lyd_new_leaf(v10, 0LL, "revision", v4) )
        return 1LL;
    }
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 56LL) )
    {
      if ( asprintf(&ptr, "file://%s", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 48LL * i) + 56LL)) == -1 )
      {
        sub_12222(*(_QWORD *)a2, 0, 1, "Memory allocation failed (%s()).", (__int64)"ylib_submodules", v5);
        return 1LL;
      }
      if ( v7 )
        v6 = "location";
      else
        v6 = "schema";
      if ( !lyd_new_leaf(v10, 0LL, v6, ptr) )
      {
        free(ptr);
        return 1LL;
      }
      free(ptr);
    }
  }
  return 0LL;
}
// 7260: using guessed type __int64  lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);
// 7AE0: using guessed type __int64  lyd_new(_QWORD, _QWORD, _QWORD);

//----- (0000000000011010) ----------------------------------------------------
__int64  ly_ctx_get_module_set_id(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_get_module_set_id", a4, a5, a6);
  return *(unsigned __int16 *)(a1 + 90);
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000011043) ----------------------------------------------------
__int64  ly_ctx_info(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // r9
  char *v12; // rax
  __int64 v13; // r9
  int i; // [rsp+18h] [rbp-48h]
  signed int v15; // [rsp+1Ch] [rbp-44h]
  char *ptr; // [rsp+20h] [rbp-40h]
  __int64 v17; // [rsp+28h] [rbp-38h]
  __int64 v18; // [rsp+30h] [rbp-30h]
  __int64 v19; // [rsp+38h] [rbp-28h]
  __int64 v20; // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  char s; // [rsp+50h] [rbp-10h]
  unsigned __int64 v23; // [rsp+58h] [rbp-8h]

  v23 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_info", a4, a5, a6);
  v18 = 0LL;
  v19 = 0LL;
  v20 = 0LL;
  if ( !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_info", v6);
    return 0LL;
  }
  v21 = ly_ctx_get_module(a1, "ietf-yang-library", 0LL, 1LL);
  if ( !v21 || !*(_QWORD *)(v21 + 168) )
  {
    sub_12222(a1, 0, 3, "ietf-yang-library is not implemented.", v8, v9);
    return 0LL;
  }
  if ( *(_QWORD *)(v21 + 88) && !strcmp(*(const char **)(v21 + 88), "2016-04-09") )
  {
    v15 = 0;
  }
  else
  {
    if ( !*(_QWORD *)(v21 + 88) || strcmp(*(const char **)(v21 + 88), "2019-01-04") )
    {
      sub_12222(a1, 0, 3, "Incompatible ietf-yang-library version in context.", v8, v9);
      return 0LL;
    }
    v15 = 1;
  }
  v17 = lyd_new(0LL, v21, "modules-state");
  if ( !v17 )
    return 0LL;
  if ( v15 )
  {
    v18 = lyd_new(0LL, v21, "yang-library");
    if ( !v18 )
      goto LABEL_71;
    v20 = lyd_new(v18, 0LL, "module-set");
    if ( !v20 || !lyd_new_leaf(v20, 0LL, "name", "complete") )
      goto LABEL_71;
  }
  for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
  {
    if ( !(*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) & 0x40) )
    {
      v19 = lyd_new(v17, 0LL, "module");
      if ( !v19 || !lyd_new_leaf(v19, 0LL, "name", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 8LL)) )
        goto LABEL_71;
      v10 = *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL) ? *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64))
                                                                                       + 88LL) : &unk_1086CA;
      if ( !lyd_new_leaf(v19, 0LL, "revision", v10) )
        goto LABEL_71;
      if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL) )
      {
        if ( asprintf(&ptr, "file://%s", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL)) == -1 )
        {
          sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_info", v11);
          goto LABEL_71;
        }
        if ( !lyd_new_leaf(v19, 0LL, "schema", ptr) )
        {
          free(ptr);
          goto LABEL_71;
        }
        free(ptr);
      }
      if ( !lyd_new_leaf(v19, 0LL, "namespace", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 176LL))
        || (unsigned int)sub_10999(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)))
        || (unsigned int)sub_10B6F(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 0) )
      {
        goto LABEL_71;
      }
      v12 = *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) >= 0 ? "import" : "implement";
      if ( !lyd_new_leaf(v19, 0LL, "conformance-type", v12)
        || (unsigned int)sub_10D68(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 0) )
      {
        goto LABEL_71;
      }
      if ( v15 )
      {
        if ( *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) >= 0 )
        {
          v19 = lyd_new(v20, 0LL, "import-only-module");
          if ( !v19 )
            goto LABEL_71;
        }
        else
        {
          v19 = lyd_new(v20, 0LL, "module");
          if ( !v19 )
            goto LABEL_71;
        }
        if ( !lyd_new_leaf(v19, 0LL, "name", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 8LL))
          || (*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) >= 0
           || *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 68LL))
          && !lyd_new_leaf(v19, 0LL, "revision", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 88LL))
          || !lyd_new_leaf(v19, 0LL, "namespace", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 176LL)) )
        {
          goto LABEL_71;
        }
        if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL) )
        {
          if ( asprintf(&ptr, "file://%s", *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 56LL)) == -1 )
          {
            sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_ctx_info", v13);
            goto LABEL_71;
          }
          if ( !lyd_new_leaf(v19, 0LL, "location", ptr) )
          {
            free(ptr);
            goto LABEL_71;
          }
          free(ptr);
        }
        if ( (unsigned int)sub_10D68(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 1)
          || *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 64LL) < 0
          && ((unsigned int)sub_10999(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)))
           || (unsigned int)sub_10B6F(v19, *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)), 1)) )
        {
          goto LABEL_71;
        }
      }
    }
  }
  sprintf(&s, "%u", *(unsigned __int16 *)(a1 + 90));
  if ( !lyd_new_leaf(v17, 0LL, "module-set-id", &s) || v15 && !lyd_new_leaf(v18, 0LL, "content-id", &s) )
    goto LABEL_71;
  if ( v18 )
  {
    if ( (unsigned int)lyd_insert_sibling(&v18, v17) )
      goto LABEL_71;
    v17 = v18;
    v18 = 0LL;
  }
  if ( !(unsigned int)lyd_validate(&v17, 4096LL, 0LL) )
    return v17;
LABEL_71:
  lyd_free_withsiblings(v17);
  lyd_free_withsiblings(v18);
  return 0LL;
}
// 7260: using guessed type __int64  lyd_new_leaf(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7670: using guessed type __int64  lyd_free_withsiblings(_QWORD);
// 78B0: using guessed type __int64  lyd_validate(_QWORD, _QWORD, _QWORD);
// 79D0: using guessed type __int64  lyd_insert_sibling(_QWORD, _QWORD);
// 7AE0: using guessed type __int64  lyd_new(_QWORD, _QWORD, _QWORD);
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (00000000000119D0) ----------------------------------------------------
__int64  ly_ctx_get_node(void *a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v6; // r9
  __int64 result; // rax
  int v8; // [rsp+4h] [rbp-2Ch]
  char *v9; // [rsp+8h] [rbp-28h]
  void *v10; // [rsp+18h] [rbp-18h]

  v10 = a1;
  v9 = a3;
  v8 = a4;
  if ( (a1 || a2) && v9 && (*v9 == 47 || a2) )
  {
    if ( !a1 )
      v10 = **(void ***)(a2 + 48);
    result = sub_1B854(v9, v10, a2, v8);
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_get_node", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000011A90) ----------------------------------------------------
__int64  ly_ctx_find_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 result; // rax
  char *v8; // [rsp+0h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-10h]
  unsigned __int64 v10; // [rsp+18h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_1083D1, (__int64)"ly_ctx_find_path", a4, a5, a6, a2);
  v9 = 0LL;
  if ( a1 && v8 )
  {
    sub_1A193(v8, 0LL, **(_QWORD **)(a1 + 64), &v9, 1, 1);
    result = v9;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"ly_ctx_find_path", v6);
    result = 0LL;
  }
  return result;
}
// 1083D1: using guessed type void *__ptr32 off_1083D1;

//----- (0000000000011B56) ----------------------------------------------------
__int64  ly_verb(char a1)
{
  unsigned int v1; // ST14_4

  v1 = (unsigned __int8)byte_3458A0;
  byte_3458A0 = a1;
  return v1;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000011B78) ----------------------------------------------------
__int64  ly_log_options(char a1)
{
  unsigned __int8 v1; // ST17_1

  v1 = byte_3458A1;
  byte_3458A1 = a1;
  return v1;
}
// 3458A1: using guessed type char byte_3458A1;

//----- (0000000000011B98) ----------------------------------------------------
__int64  ly_verb_dbg(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  dword_347048 = a1;
  return result;
}
// 347048: using guessed type int dword_347048;

//----- (0000000000011BAB) ----------------------------------------------------
__int64  ly_set_log_clb(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  qword_347050 = (__int64 ( *)(_QWORD, _QWORD, _QWORD))a1;
  result = a2;
  dword_3458A4 = a2;
  return result;
}
// 3458A4: using guessed type int dword_3458A4;
// 347050: using guessed type __int64 ( *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000011BCD) ----------------------------------------------------
__int64 ( *ly_get_log_clb())(_QWORD, _QWORD, _QWORD)
{
  return qword_347050;
}
// 347050: using guessed type __int64 ( *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000011BDA) ----------------------------------------------------
__int64  sub_11BDA(void *a1, unsigned int a2, int a3, int a4, void *a5, void *a6, void *a7)
{
  __int64 v7; // r9
  void *v9; // [rsp+8h] [rbp-38h]
  void *ptr; // [rsp+10h] [rbp-30h]
  int v11; // [rsp+1Ch] [rbp-24h]
  int v12; // [rsp+20h] [rbp-20h]
  _DWORD *pointer; // [rsp+30h] [rbp-10h]
  void *pointera; // [rsp+30h] [rbp-10h]
  __int64 v15; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  ptr = a5;
  v9 = a6;
  if ( !a1 || a2 > 1 )
    __assert_fail("ctx && (level < LY_LLVRB)", "/home/mantovan/Repositories/libyang/src/log.c", 0x55u, "log_store");
  pointer = pthread_getspecific(*((_DWORD *)a1 + 32));
  if ( !pointer )
  {
    if ( !ptr )
      __assert_fail("msg", "/home/mantovan/Repositories/libyang/src/log.c", 0x5Au, "log_store");
    pointer = malloc(0x38uLL);
    if ( pointer )
    {
      *((_QWORD *)pointer + 6) = pointer;
      *((_QWORD *)pointer + 5) = 0LL;
      pthread_setspecific(*((_DWORD *)a1 + 32), pointer);
LABEL_22:
      *pointer = a2;
      pointer[1] = v12;
      pointer[2] = v11;
      *((_QWORD *)pointer + 2) = ptr;
      *((_QWORD *)pointer + 3) = v9;
      *((_QWORD *)pointer + 4) = a7;
      return 0LL;
    }
LABEL_23:
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"log_store", v7);
    free(ptr);
    free(v9);
    free(a7);
    return 0xFFFFFFFFLL;
  }
  if ( ptr )
  {
    if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 && (byte_3458A1 & 6) == 6 )
    {
      free(*((void **)pointer + 2));
      free(*((void **)pointer + 3));
      free(*((void **)pointer + 4));
      goto LABEL_22;
    }
    v15 = *((_QWORD *)pointer + 6);
    *((_QWORD *)pointer + 6) = malloc(0x38uLL);
    if ( *((_QWORD *)pointer + 6) )
    {
      pointer = (_DWORD *)*((_QWORD *)pointer + 6);
      *((_QWORD *)pointer + 6) = v15;
      *((_QWORD *)pointer + 5) = 0LL;
      *(_QWORD *)(v15 + 40) = pointer;
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  if ( !v9 )
    __assert_fail("path", "/home/mantovan/Repositories/libyang/src/log.c", 0x65u, "log_store");
  pointera = (void *)*((_QWORD *)pointer + 6);
  while ( *(_DWORD *)pointera )
  {
    pointera = (void *)*((_QWORD *)pointera + 6);
    if ( !*(_QWORD *)(*((_QWORD *)pointera + 6) + 40LL) )
      __assert_fail("0", "/home/mantovan/Repositories/libyang/src/log.c", 0x73u, "log_store");
  }
  free(*((void **)pointera + 3));
  *((_QWORD *)pointera + 3) = v9;
  return 0LL;
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;
// 3458A1: using guessed type char byte_3458A1;

//----- (0000000000011EB0) ----------------------------------------------------
unsigned __int64  sub_11EB0(void *a1, unsigned int a2, int a3, int a4, void *a5, char *a6, void *a7)
{
  __int64 v7; // r9
  __int64 v8; // r9
  void *v9; // rax
  const char *f; // [rsp+8h] [rbp-48h]
  void *ptr; // [rsp+10h] [rbp-40h]
  int v13; // [rsp+1Ch] [rbp-34h]
  int v14; // [rsp+20h] [rbp-30h]
  unsigned int v15; // [rsp+24h] [rbp-2Ch]
  signed int v16; // [rsp+3Ch] [rbp-14h]
  char *v17; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v15 = a2;
  v14 = a3;
  v13 = a4;
  ptr = a5;
  f = a6;
  v18 = __readfsqword(0x28u);
  v17 = 0LL;
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) == 3 && !a2 )
    v15 = 1;
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) == 2 || v15 > (unsigned __int8)byte_3458A0 )
  {
    free(ptr);
    return __readfsqword(0x28u) ^ v18;
  }
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 && v14 )
    *(_DWORD *)ly_errno_glob_address(&stru_335FC0) = v14;
  if ( v14 == 5 && !v13 )
    v13 = ly_vecode(a1);
  if ( v15 > 1 || !a1 || !(byte_3458A1 & 2) && *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
  {
    if ( vasprintf(&v17, f, a7) == -1 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"log_vprintf", v8, a7);
      free(ptr);
      return __readfsqword(0x28u) ^ v18;
    }
    v16 = 1;
    goto LABEL_29;
  }
  if ( f )
  {
    if ( vasprintf(&v17, f, a7) == -1 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"log_vprintf", v7, a7);
      free(ptr);
      return __readfsqword(0x28u) ^ v18;
    }
    if ( (unsigned int)sub_11BDA(a1, v15, v14, v13, v17, ptr, 0LL) )
      return __readfsqword(0x28u) ^ v18;
    goto LABEL_25;
  }
  if ( !ptr )
    __assert_fail("path", "/home/mantovan/Repositories/libyang/src/log.c", 0xB7u, "log_vprintf");
  if ( !(unsigned int)sub_11BDA(a1, v15, v14, v13, 0LL, ptr, 0LL) )
  {
    v17 = "Path is related to the previous error message.";
LABEL_25:
    v16 = 0;
LABEL_29:
    if ( byte_3458A1 & 1 && *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
    {
      if ( qword_347050 )
      {
	qword_347050 = (__int64 ( *)(_QWORD, _QWORD, _QWORD))a1;
        qword_347050(v15, v17, ptr);
      }
      else
      {
        if ( ptr )
          v9 = &off_108D8F;
        else
          v9 = (void *)((char *)&off_108D8F + 2);
        fprintf(stderr, "libyang[%d]: %s%s", v15, v17, v9);
        if ( ptr )
          fprintf(stderr, "(path: %s)\n", ptr);
      }
    }
    if ( v16 )
    {
      free(ptr);
      free(v17);
    }
  }
  return __readfsqword(0x28u) ^ v18;
}
// 71B0: using guessed type __int64  ly_vecode(_QWORD);
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 108D8F: using guessed type void *__ptr32 off_108D8F;
// 335FC0: using guessed type tls_index_local stru_335FC0;
// 3458A0: using guessed type char byte_3458A0;
// 3458A1: using guessed type char byte_3458A1;
// 347050: using guessed type __int64 ( *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000012222) ----------------------------------------------------
unsigned __int64 sub_12222(__int64 a1, unsigned int a2, int a3, char *a4, __int64 a5, __int64 a6, ...)
{
  _G_va_list va; // [rsp+20h] [rbp-D0h]
  unsigned __int64 v8; // [rsp+38h] [rbp-B8h]
  __int64 v9; // [rsp+60h] [rbp-90h]
  __int64 v10; // [rsp+68h] [rbp-88h]

  va_start(va, a6);
  v9 = a5;
  v10 = a6;
  v8 = __readfsqword(0x28u);
  va[0].gp_offset = 32;
  sub_11EB0((void *)a1, a2, a3, 0, 0LL, a4, va);
  return __readfsqword(0x28u) ^ v8;
}

//----- (0000000000012312) ----------------------------------------------------
unsigned __int64 sub_12312(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  __int64 v6; // r9
  char *ptr; // [rsp+10h] [rbp-E0h]
  const char *v9; // [rsp+18h] [rbp-D8h]
  _G_va_list va; // [rsp+20h] [rbp-D0h]
  unsigned __int64 v11; // [rsp+38h] [rbp-B8h]
  __int64 v12; // [rsp+50h] [rbp-A0h]
  __int64 v13; // [rsp+58h] [rbp-98h]
  __int64 v14; // [rsp+60h] [rbp-90h]
  __int64 v15; // [rsp+68h] [rbp-88h]

  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  v11 = __readfsqword(0x28u);
  if ( a1 & dword_347048 )
  {
    switch ( (unsigned __int64)a1 )
    {
      case 1uLL:
        v9 = "DICT";
        goto LABEL_11;
      case 2uLL:
        v9 = "YANG";
        goto LABEL_11;
      case 4uLL:
        v9 = "YIN";
        goto LABEL_11;
      case 8uLL:
        v9 = "XPATH";
        goto LABEL_11;
      case 0x10uLL:
        v9 = "DIFF";
        goto LABEL_11;
      case 0x20uLL:
        v9 = "API";
        goto LABEL_11;
      case 0x40uLL:
        v9 = "HASH";
LABEL_11:
        if ( asprintf(&ptr, "%s: %s", v9, a2) == -1 )
        {
          sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_log_dbg", v6, a2);
        }
        else
        {
          va[0].gp_offset = 16;
          va_start(va, a6);
          sub_11EB0(0LL, 3u, 0, 0, 0LL, ptr, va);
          free(ptr);
        }
        break;
      default:
        sub_12222(
          0LL,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/log.c",
          273LL,
          a2);
        break;
    }
  }
  return __readfsqword(0x28u) ^ v11;
}
// 347048: using guessed type int dword_347048;

//----- (0000000000012554) ----------------------------------------------------
unsigned __int64 lyext_log(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  __int64 v6; // r9
  int v7; // edi
  void *v9; // [rsp+28h] [rbp-E8h]
  int v10; // [rsp+34h] [rbp-DCh]
  char *ptr; // [rsp+38h] [rbp-D8h]
  _G_va_list va; // [rsp+40h] [rbp-D0h]
  unsigned __int64 v13; // [rsp+58h] [rbp-B8h]
  __int64 v14; // [rsp+88h] [rbp-88h]

  v9 = (void *)a1;
  v14 = a6;
  v13 = __readfsqword(0x28u);
  if ( a2 <= (unsigned __int8)byte_3458A0 )
  {
    if ( a3 )
      v10 = asprintf(&ptr, "%s (reported by plugin %s, %s())", a5, a3, a4);
    else
      v10 = asprintf(&ptr, "%s", a5);
    if ( v10 == -1 )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyext_log", v6);
    }
    else
    {
      va[0].gp_offset = 40;
      va_start(va, a6);
      if ( a2 )
        v7 = 0;
      else
        v7 = 6;
      sub_11EB0(v9, a2, v7, 0, 0LL, ptr, va);
      free(ptr);
    }
  }
  return __readfsqword(0x28u) ^ v13;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000012724) ----------------------------------------------------
unsigned __int64 lyext_vlog(void *a1, int a2, __int64 a3, __int64 a4, int a5, char *a6, __int64 a7, ...)
{
  __int64 v7; // r9
  __int64 v9; // [rsp+10h] [rbp-110h]
  __int64 v10; // [rsp+18h] [rbp-108h]
  int v11; // [rsp+30h] [rbp-F0h]
  unsigned int v12; // [rsp+34h] [rbp-ECh]
  char *ptr; // [rsp+38h] [rbp-E8h]
  void *v14; // [rsp+40h] [rbp-E0h]
  __int64 v15; // [rsp+48h] [rbp-D8h]
  _G_va_list va; // [rsp+50h] [rbp-D0h]
  unsigned __int64 v17; // [rsp+68h] [rbp-B8h]

  v10 = a3;
  v9 = a4;
  v17 = __readfsqword(0x28u);
  v12 = dword_3458B0[a5];
  v14 = 0LL;
  if ( dword_3458A4 && v12 )
  {
    if ( v12 == 5 )
    {
      v15 = ly_err_first(a1);
      if ( v15 && *(_QWORD *)(*(_QWORD *)(v15 + 48) + 24LL) )
        v14 = strdup(*(const char **)(*(_QWORD *)(v15 + 48) + 24LL));
    }
    else if ( a6 )
    {
      sub_12B3E(v12, a6, &v14, 0, 0);
    }
    else
    {
      v14 = strdup("/");
    }
  }
  if ( v10 )
    v11 = asprintf(&ptr, "%s (reported by plugin %s, %s())", a7, v10, v9);
  else
    v11 = asprintf(&ptr, "%s", a7);
  if ( v11 == -1 )
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyext_vlog", v7, a7);
    free(v14);
  }
  else
  {
    va_start(va, a7);
    sub_11EB0(a1, 0, 5, a2, v14, ptr, va);
    free(ptr);
  }
  return __readfsqword(0x28u) ^ v17;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 3458A4: using guessed type int dword_3458A4;

//----- (00000000000129CF) ----------------------------------------------------
signed __int64  sub_129CF(void **a1, unsigned __int16 *a2, void *a3, unsigned __int16 a4, unsigned __int16 *a5)
{
  unsigned __int16 v5; // ax
  __int64 v6; // r9
  _WORD *v8; // [rsp+8h] [rbp-38h]
  unsigned __int16 v9; // [rsp+14h] [rbp-2Ch]
  void *src; // [rsp+18h] [rbp-28h]
  unsigned __int16 v11; // [rsp+36h] [rbp-Ah]
  void *v12; // [rsp+38h] [rbp-8h]

  src = a3;
  v8 = a5;
  v9 = a4;
  if ( a4 > *a2 )
  {
    v5 = 128;
    if ( a4 >= 0x80u )
      v5 = a4;
    v11 = v5;
    v12 = realloc(*a1, *a2 + *a5 + v5 + 1);
    if ( !v12 )
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_vlog_build_path_print", v6);
      return 0xFFFFFFFFLL;
    }
    *a1 = v12;
    memmove((char *)*a1 + *a2 + v11, (char *)*a1 + *a2, (unsigned __int16)*v8);
    *a2 += v11;
  }
  *a2 -= v9;
  memcpy((char *)*a1 + *a2, src, v9);
  *v8 += v9;
  return 0LL;
}

//----- (0000000000012B3E) ----------------------------------------------------
signed __int64  sub_12B3E(unsigned int a1, char *a2, void **a3, int a4, int a5)
{
  __int64 v5; // r9
  signed __int64 result; // rax
  char *v7; // rax
  __int64 v8; // rax
  unsigned __int16 v9; // ax
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rax
  unsigned __int16 v13; // bx
  __int64 v14; // rax
  __int64 v15; // r9
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // ax
  unsigned __int16 v18; // ax
  int v19; // [rsp+4h] [rbp-ACh]
  void **v20; // [rsp+8h] [rbp-A8h]
  char *v21; // [rsp+10h] [rbp-A0h]
  int v22; // [rsp+18h] [rbp-98h]
  unsigned __int16 v23; // [rsp+28h] [rbp-88h]
  unsigned __int16 v24; // [rsp+2Ah] [rbp-86h]
  int j; // [rsp+2Ch] [rbp-84h]
  int v26; // [rsp+30h] [rbp-80h]
  int v27; // [rsp+34h] [rbp-7Ch]
  char *i; // [rsp+38h] [rbp-78h]
  __int64 k; // [rsp+40h] [rbp-70h]
  __int64 v30; // [rsp+48h] [rbp-68h]
  char *s; // [rsp+50h] [rbp-60h]
  char *v32; // [rsp+58h] [rbp-58h]
  char *v33; // [rsp+60h] [rbp-50h]
  char *v34; // [rsp+68h] [rbp-48h]
  size_t v35; // [rsp+70h] [rbp-40h]
  char *v36; // [rsp+78h] [rbp-38h]
  char *v37; // [rsp+80h] [rbp-30h]
  char *v38; // [rsp+88h] [rbp-28h]
  char *v39; // [rsp+90h] [rbp-20h]
  unsigned __int64 v40; // [rsp+98h] [rbp-18h]

  v21 = a2;
  v20 = a3;
  v22 = a4;
  v19 = a5;
  v40 = __readfsqword(0x28u);
  v27 = 0;
  i = 0LL;
  v30 = 0LL;
  v32 = 0LL;
  v23 = 0;
  *a3 = malloc(1uLL);
  if ( *v20 )
  {
    v24 = 0;
    while ( v21 )
    {
      if ( a1 == 2 )
      {
        if ( !v30 )
        {
          for ( i = v21; lys_parent(i); i = (char *)lys_parent(i) )
            ;
          v30 = lys_node_module(i);
        }
        for ( i = (char *)lys_parent(v21); i && *((_DWORD *)i + 14) == 4096; i = (char *)lys_parent(i) )
          ;
        if ( i && (v8 = lys_node_module(v21), v30 == v8) && !v22 )
          v32 = 0LL;
        else
          v32 = *(char **)(lys_node_module(v21) + 8);
        if ( *((_DWORD *)v21 + 14) & 0x2800 )
        {
          if ( (unsigned int)sub_129CF(v20, &v24, &unk_10A000, 1u, &v23) )
            return 0xFFFFFFFFLL;
          s = *(char **)v21;
          v9 = strlen(s);
          if ( (unsigned int)sub_129CF(v20, &v24, s, v9, &v23) )
            return 0xFFFFFFFFLL;
          if ( *((_DWORD *)v21 + 14) == 2048 )
            s = "{grouping}[";
          else
            s = "{augment}[";
        }
        else if ( *((_DWORD *)v21 + 14) == 0x10000 )
        {
          s = **(char ***)v21;
          if ( !strcmp(s, "yang-data") )
          {
            v27 = 1;
            s = (char *)*((_QWORD *)v21 + 2);
            v32 = *(char **)(lys_node_module(v21) + 8);
          }
        }
        else
        {
          s = *(char **)v21;
        }
        if ( *((_DWORD *)v21 + 14) == 0x10000 )
        {
          if ( v21[29] == 1 )
          {
            v21 = (char *)*((_QWORD *)v21 + 1);
          }
          else
          {
            i = 0LL;
            v21 = 0LL;
          }
        }
        else
        {
          do
          {
            i = (char *)*((_QWORD *)v21 + 8);
            v21 = (char *)lys_parent(v21);
          }
          while ( v21 && *((_DWORD *)v21 + 14) == 4096 );
        }
      }
      else if ( a1 > 2 )
      {
        if ( a1 != 3 )
        {
          if ( a1 != 4 )
          {
LABEL_116:
            sub_12222(
              0LL,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/log.c",
              814LL);
            return 0xFFFFFFFFLL;
          }
          v35 = strlen(v21);
          if ( (unsigned int)sub_129CF(v20, &v24, v21, v35, &v23) )
            return 0xFFFFFFFFLL;
          break;
        }
        s = **(char ***)v21;
        if ( *((_QWORD *)v21 + 5) && (v10 = lyd_node_module(v21), v10 == lyd_node_module(*((_QWORD *)v21 + 5))) )
          v32 = 0LL;
        else
          v32 = *(char **)(lyd_node_module(v21) + 8);
        if ( !v19 || v24 )
        {
          if ( *(_DWORD *)(*(_QWORD *)v21 + 56LL) == 16 )
          {
            v36 = v21;
            v37 = *(char **)v21;
            if ( v37[30] )
            {
              for ( j = (unsigned __int8)v37[30] - 1; j >= 0; --j )
              {
                for ( k = *((_QWORD *)v36 + 8);
                      k && *(_QWORD *)k != *(_QWORD *)(8LL * j + *((_QWORD *)v37 + 17));
                      k = *(_QWORD *)(k + 24) )
                {
                  ;
                }
                if ( k && *(_QWORD *)(k + 56) )
                {
                  if ( strchr(*(const char **)(k + 56), 39) )
                  {
                    v34 = "=\"";
                    v33 = "\"]";
                  }
                  else
                  {
                    v34 = "='";
                    v33 = "']";
                  }
                  if ( (unsigned int)sub_129CF(v20, &v24, v33, 2u, &v23) )
                    return 0xFFFFFFFFLL;
                  v35 = strlen(*(const char **)(k + 56));
                  if ( (unsigned int)sub_129CF(v20, &v24, *(void **)(k + 56), v35, &v23) )
                    return 0xFFFFFFFFLL;
                  if ( (unsigned int)sub_129CF(v20, &v24, v34, 2u, &v23) )
                    return 0xFFFFFFFFLL;
                  v35 = strlen(**(const char ***)k);
                  if ( (unsigned int)sub_129CF(v20, &v24, **(void ***)k, v35, &v23) )
                    return 0xFFFFFFFFLL;
                  v11 = lyd_node_module(v36);
                  if ( v11 != lyd_node_module(k) )
                  {
                    if ( (unsigned int)sub_129CF(v20, &v24, ":", 1u, &v23) )
                      return 0xFFFFFFFFLL;
                    v12 = lyd_node_module(k);
                    v35 = strlen(*(const char **)(v12 + 8));
                    v13 = v35;
                    v14 = lyd_node_module(k);
                    if ( (unsigned int)sub_129CF(v20, &v24, *(void **)(v14 + 8), v13, &v23) )
                      return 0xFFFFFFFFLL;
                  }
                  if ( (unsigned int)sub_129CF(v20, &v24, "[", 1u, &v23) )
                    return 0xFFFFFFFFLL;
                }
              }
            }
            else
            {
              v26 = lyd_list_pos(v36);
              j = v26;
              v35 = 1LL;
              while ( v26 > 9 )
              {
                ++v35;
                v26 /= 10;
              }
              if ( (unsigned int)sub_129CF(v20, &v24, &unk_10A000, 1u, &v23) )
                return 0xFFFFFFFFLL;
              v38 = (char *)malloc(v35 + 1);
              if ( !v38 )
              {
                sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_vlog_build_path", v15);
                return 0xFFFFFFFFLL;
              }
              sprintf(v38, "%d", (unsigned int)j);
              if ( (unsigned int)sub_129CF(v20, &v24, v38, v35, &v23) )
              {
                free(v38);
                return 0xFFFFFFFFLL;
              }
              free(v38);
              if ( (unsigned int)sub_129CF(v20, &v24, "[", 1u, &v23) )
                return 0xFFFFFFFFLL;
            }
          }
          else if ( *(_DWORD *)(*(_QWORD *)v21 + 56LL) == 8 && *((_QWORD *)v21 + 7) )
          {
            if ( strchr(*((const char **)v21 + 7), 39) )
            {
              v34 = "[.=\"";
              v33 = "\"]";
            }
            else
            {
              v34 = "[.='";
              v33 = "']";
            }
            if ( (unsigned int)sub_129CF(v20, &v24, v33, 2u, &v23) )
              return 0xFFFFFFFFLL;
            v35 = strlen(*((const char **)v21 + 7));
            if ( (unsigned int)sub_129CF(v20, &v24, *((void **)v21 + 7), v35, &v23) )
              return 0xFFFFFFFFLL;
            if ( (unsigned int)sub_129CF(v20, &v24, v34, 4u, &v23) )
              return 0xFFFFFFFFLL;
          }
        }
        if ( !*((_QWORD *)v21 + 5) )
        {
          v39 = (char *)sub_40CD4(v21);
          if ( v39 )
          {
            v16 = strlen(s);
            if ( (unsigned int)sub_129CF(v20, &v24, s, v16, &v23) )
              return 0xFFFFFFFFLL;
            if ( (unsigned int)sub_129CF(v20, &v24, "/", 1u, &v23) )
              return 0xFFFFFFFFLL;
            v27 = 1;
            s = v39;
          }
        }
        v21 = (char *)*((_QWORD *)v21 + 5);
      }
      else
      {
        if ( a1 != 1 )
          goto LABEL_116;
        s = (char *)*((_QWORD *)v21 + 6);
        if ( *((_QWORD *)v21 + 7) )
          v7 = *(char **)(*((_QWORD *)v21 + 7) + 24LL);
        else
          v7 = 0LL;
        v32 = v7;
        v21 = (char *)*((_QWORD *)v21 + 1);
      }
      if ( s )
      {
        v17 = strlen(s);
        if ( (unsigned int)sub_129CF(v20, &v24, s, v17, &v23) )
          return 0xFFFFFFFFLL;
        if ( v32 )
        {
          if ( v27 && (unsigned int)sub_129CF(v20, &v24, "#", 1u, &v23) )
            return 0xFFFFFFFFLL;
          if ( (unsigned int)sub_129CF(v20, &v24, ":", 1u, &v23) )
            return 0xFFFFFFFFLL;
          v18 = strlen(v32);
          if ( (unsigned int)sub_129CF(v20, &v24, v32, v18, &v23) )
            return 0xFFFFFFFFLL;
        }
      }
      if ( (unsigned int)sub_129CF(v20, &v24, "/", 1u, &v23) )
        return 0xFFFFFFFFLL;
      if ( a1 == 2 && !v21 )
      {
        if ( i )
        {
          if ( *((_DWORD *)i + 14) == 0x2000 )
          {
            v35 = strlen(*(const char **)i);
            if ( (unsigned int)sub_129CF(v20, &v24, *(void **)i, v35, &v23) )
              return 0xFFFFFFFFLL;
          }
        }
      }
    }
    memmove(*v20, (char *)*v20 + v24, v23);
    *((_BYTE *)*v20 + v23) = 0;
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"ly_vlog_build_path", v5);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7360: using guessed type __int64  lyd_list_pos(_QWORD);
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000013937) ----------------------------------------------------
unsigned __int64 sub_13937(void *a1, int a2, unsigned int a3, char *a4, __int64 a5, __int64 a6, ...)
{
  char **v6; // rax
  char *v8; // [rsp+28h] [rbp-E8h]
  __int64 v9; // [rsp+30h] [rbp-E0h]
  char *v10; // [rsp+38h] [rbp-D8h]
  _G_va_list va; // [rsp+40h] [rbp-D0h]
  unsigned __int64 v12; // [rsp+58h] [rbp-B8h]
  __int64 v13; // [rsp+80h] [rbp-90h]
  __int64 v14; // [rsp+88h] [rbp-88h]

  v13 = a5;
  v14 = a6;
  v12 = __readfsqword(0x28u);
  v8 = 0LL;
  if ( a2 != -2 || dword_3458A4 )
  {
    if ( dword_3458A4 && a3 )
    {
      if ( a3 == 5 )
      {
        v9 = ly_err_first(a1);
        if ( v9 && *(_QWORD *)(*(_QWORD *)(v9 + 48) + 24LL) )
          v8 = strdup(*(const char **)(*(_QWORD *)(v9 + 48) + 24LL));
      }
      else if ( a4 )
      {
        sub_12B3E(a3, a4, (void **)&v8, 0, 0);
      }
      else
      {
        v8 = strdup("/");
      }
    }
    va[0].gp_offset = 32;
    va_start(va, a6);
    if ( a2 == -2 )
    {
      if ( !v8 )
        __assert_fail("path", "/home/mantovan/Repositories/libyang/src/log.c", 0x378u, "ly_vlog");
      sub_11EB0(a1, 0, 5, 0, v8, 0LL, va);
    }
    else if ( a2 == -1 )
    {
      if ( va[0].gp_offset > 0x2F )
      {
        v6 = (char **)va[0].overflow_arg_area;
        va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
      }
      else
      {
        v6 = (char **)((char *)va[0].reg_save_area + va[0].gp_offset);
        va[0].gp_offset += 8;
      }
      v10 = *v6;
      sub_11EB0(a1, 0, 5, 0, v8, v10, va);
    }
    else
    {
      sub_11EB0(a1, 0, 5, dword_109EA0[a2], v8, (char *)*(&off_3458E0 + a2), va);
    }
  }
  return __readfsqword(0x28u) ^ v12;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 3458A4: using guessed type int dword_3458A4;
// 3458E0: using guessed type void *off_3458E0;

//----- (0000000000013C4A) ----------------------------------------------------
unsigned __int64 sub_13C4A(void *a1, int a2, char *a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  size_t v6; // rax
  size_t v7; // rax
  char *s; // [rsp+8h] [rbp-108h]
  char *v10; // [rsp+20h] [rbp-F0h]
  char *dest; // [rsp+28h] [rbp-E8h]
  char *i; // [rsp+30h] [rbp-E0h]
  __int64 v13; // [rsp+38h] [rbp-D8h]
  _G_va_list va; // [rsp+40h] [rbp-D0h]
  unsigned __int64 v15; // [rsp+58h] [rbp-B8h]
  __int64 v16; // [rsp+78h] [rbp-98h]
  __int64 v17; // [rsp+80h] [rbp-90h]
  __int64 v18; // [rsp+88h] [rbp-88h]

  s = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v15 = __readfsqword(0x28u);
  v10 = 0LL;
  if ( a2 && a2 != 5 )
    __assert_fail(
      "(elem_type == LY_VLOG_NONE) || (elem_type == LY_VLOG_PREV)",
      "/home/mantovan/Repositories/libyang/src/log.c",
      0x389u,
      "ly_vlog_str");
  if ( a2 == 5 )
  {
    v13 = ly_err_first(a1);
    if ( v13 )
    {
      if ( *(_QWORD *)(*(_QWORD *)(v13 + 48) + 24LL) )
        v10 = strdup(*(const char **)(*(_QWORD *)(v13 + 48) + 24LL));
    }
  }
  if ( strchr(s, 37) )
  {
    v6 = strlen(s);
    dest = (char *)malloc(2 * v6 + 1);
    strcpy(dest, s);
    for ( i = strchr(dest, 37); i; i = strchr(i + 2, 37) )
    {
      v7 = strlen(i);
      memmove(i + 1, i, v7 + 1);
      *i = 37;
    }
  }
  else
  {
    dest = strdup(s);
  }
  va[0].gp_offset = 24;
  va_start(va, a6);
  sub_11EB0(a1, 0, 5, 0, v10, dest, va);
  free(dest);
  return __readfsqword(0x28u) ^ v15;
}
// 7710: using guessed type __int64  ly_err_first(_QWORD);

//----- (0000000000013ED6) ----------------------------------------------------
int  ly_err_print(unsigned int *a1)
{
  __int64 v1; // rax
  void *v2; // rax

  LODWORD(v1) = byte_3458A1 & 1;
  if ( byte_3458A1 & 1 )
  {
    if ( qword_347050 )
    {
      LODWORD(v1) = qword_347050(*a1, *((_QWORD *)a1 + 2), *((_QWORD *)a1 + 3));
    }
    else
    {
      if ( *((_QWORD *)a1 + 3) )
        v2 = &off_108D8F;
      else
        v2 = (void *)((char *)&off_108D8F + 2);
      fprintf(stderr, "libyang[%d]: %s%s", *a1, *((_QWORD *)a1 + 2), v2);
      v1 = *((_QWORD *)a1 + 3);
      if ( v1 )
        LODWORD(v1) = fprintf(stderr, "(path: %s)\n", *((_QWORD *)a1 + 3));
    }
  }
  return v1;
}
// 347050: invalid function type has been ignored
// 108D8F: using guessed type void *__ptr32 off_108D8F;
// 3458A1: using guessed type char byte_3458A1;
// 347050: using guessed type __int64 ( *qword_347050)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013FA5) ----------------------------------------------------
__int64  sub_13FA5(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _DWORD *v3; // [rsp+0h] [rbp-10h]

  if ( a2 )
    v3 = *(_DWORD **)(a2 + 40);
  else
    v3 = pthread_getspecific(*(_DWORD *)(a1 + 128));
  result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
  if ( (_DWORD)result != 1 )
  {
    result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
    if ( (_DWORD)result != 2 )
    {
      while ( v3 )
      {
        ly_err_print(v3);
        if ( !*v3 )
          *(_DWORD *)ly_errno_glob_address(v3) = v3[1];
        result = *((_QWORD *)v3 + 5);
        v3 = (_DWORD *)*((_QWORD *)v3 + 5);
      }
    }
  }
  return result;
}
// 7200: using guessed type __int64  ly_err_print(_QWORD);
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (000000000001404C) ----------------------------------------------------
__int64  sub_1404C(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( !a2 )
    return ly_err_clean(a1, 0LL);
  result = *(_QWORD *)(a2 + 40);
  if ( result )
    result = ly_err_clean(a1, *(_QWORD *)(a2 + 40));
  return result;
}
// 77D0: using guessed type __int64  ly_err_clean(_QWORD, _QWORD);

//----- (000000000001409D) ----------------------------------------------------
void  sub_1409D(__int64 a1, __int64 a2, int a3)
{
  int v3; // [rsp+Ch] [rbp-24h]
  const void **pointer; // [rsp+10h] [rbp-20h]
  const void **v5; // [rsp+28h] [rbp-8h]

  v3 = a3;
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
  {
    if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 2 && v3 && byte_3458A1 & 2 )
    {
      if ( (byte_3458A1 & 6) == 6 )
      {
        v5 = (const void **)pthread_getspecific(*(_DWORD *)(a1 + 128));
        if ( v5 )
        {
          pointer = (const void **)v5[6];
          pthread_setspecific(*(_DWORD *)(a1 + 128), v5[6]);
          if ( *((_QWORD *)pointer[6] + 5) && pointer != *((const void ***)pointer[6] + 5) )
            __assert_fail(
              "!prev_eitem->prev->next || (prev_eitem->prev->next == prev_eitem)",
              "/home/mantovan/Repositories/libyang/src/log.c",
              0x3F7u,
              "err_clean");
          *((_QWORD *)pointer[6] + 5) = 0LL;
          pointer[6] = pointer;
          if ( pointer != v5 )
            destr_function(v5);
        }
      }
    }
    else
    {
      sub_1404C(a1, a2);
    }
  }
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;
// 3458A1: using guessed type char byte_3458A1;

//----- (00000000000141E4) ----------------------------------------------------
__int64  sub_141E4(__int64 a1, unsigned int a2, _DWORD *a3, __int64 a4)
{
  __int64 result; // rax
  unsigned int *v5; // rdx
  __int64 v6; // [rsp+0h] [rbp-20h]

  v6 = a4;
  if ( !a3 )
    __assert_fail("prev_ilo", "/home/mantovan/Repositories/libyang/src/log.c", 0x405u, "ly_ilo_change");
  *a3 = *(_DWORD *)__tls_get_addr(&stru_335FC0);
  if ( a2 == 1 )
  {
    if ( !a1 || !v6 )
      __assert_fail("ctx && prev_last_eitem", "/home/mantovan/Repositories/libyang/src/log.c", 0x40Au, "ly_ilo_change");
    *(_QWORD *)v6 = ly_err_first(a1);
    if ( *(_QWORD *)v6 )
      *(_QWORD *)v6 = *(_QWORD *)(*(_QWORD *)v6 + 48LL);
  }
  result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
  if ( (_DWORD)result != 2 )
  {
    v5 = (unsigned int *)__tls_get_addr(&stru_335FC0);
    result = a2;
    *v5 = a2;
  }
  return result;
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (00000000000142D2) ----------------------------------------------------
void  sub_142D2(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v4; // [rsp+8h] [rbp-18h]
  int v5; // [rsp+10h] [rbp-10h]

  v4 = a3;
  v5 = a4;
  if ( !*(_DWORD *)__tls_get_addr(&stru_335FC0) )
    __assert_fail("log_opt != ILO_LOG", "/home/mantovan/Repositories/libyang/src/log.c", 0x419u, "ly_ilo_restore");
  if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) == 1 )
  {
    if ( !a1 )
      __assert_fail("ctx", "/home/mantovan/Repositories/libyang/src/log.c", 0x421u, "ly_ilo_restore");
    *(_DWORD *)__tls_get_addr(&stru_335FC0) = a2;
    if ( v5 )
      sub_13FA5(a1, v4);
    sub_1409D(a1, v4, v5);
  }
  else
  {
    if ( a2 != *(_DWORD *)__tls_get_addr(&stru_335FC0) && (a1 || v4 || v5) )
      __assert_fail(
        "log_opt == prev_ilo || (!ctx && !prev_last_eitem && !keep_and_print)",
        "/home/mantovan/Repositories/libyang/src/log.c",
        0x41Cu,
        "ly_ilo_restore");
    *(_DWORD *)__tls_get_addr(&stru_335FC0) = a2;
  }
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (0000000000014407) ----------------------------------------------------
__int64  sub_14407(__int64 a1, const char *a2)
{
  __int64 result; // rax
  __int64 v3; // ST18_8
  char *v4; // rdx

  result = *(unsigned int *)__tls_get_addr(&stru_335FC0);
  if ( (_DWORD)result != 2 )
  {
    result = ly_err_first(a1);
    if ( result )
    {
      v3 = *(_QWORD *)(result + 48);
      v4 = strdup(a2);
      result = v3;
      *(_QWORD *)(v3 + 32) = v4;
    }
  }
  return result;
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 7710: using guessed type __int64  ly_err_first(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (000000000001446B) ----------------------------------------------------
_BOOL4  sub_1446B(const char **a1, char **a2, __int64 a3, size_t *a4, __int64 a5, __int64 a6)
{
  _BOOL4 result; // rax
  char *s2; // [rsp+28h] [rbp-8h]

  if ( a1 && a2 )
  {
    s2 = *a2;
    if ( *a1 && s2 && a4 )
    {
      result = strncmp(*a1, s2, *a4) == 0;
    }
    else
    {
      sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_val_eq", a6, a4);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_val_eq", a6, a4);
    result = 0LL;
  }
  return result;
}

//----- (0000000000014546) ----------------------------------------------------
int  sub_14546(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int result; // eax

  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_init", a6);
  *(_QWORD *)a1 = sub_14CB1(0x400u, 12, (__int64)sub_1446B, 0LL, 1);
  if ( *(_QWORD *)a1 )
    result = pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0LL);
  else
    result = sub_12222(
               0LL,
               0,
               4,
               "Internal error (%s:%d).",
               (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
               57LL);
  return result;
}

//----- (00000000000145FF) ----------------------------------------------------
int  sub_145FF(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int i; // [rsp+1Ch] [rbp-14h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lydict_clean", a6);
  for ( i = 0; i < *(_DWORD *)(*(_QWORD *)a1 + 4LL); ++i )
  {
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 32LL) + i * *(unsigned __int16 *)(*(_QWORD *)a1 + 26LL);
    if ( *(_DWORD *)(v8 + 4) == 1 )
      sub_12222(
        0LL,
        1u,
        0,
        "String \"%s\" not freed from the dictionary, refcount %d",
        *(_QWORD *)(v8 + 8),
        *(unsigned int *)(v8 + 16));
  }
  sub_14F6B(*(void ***)a1);
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
}

//----- (0000000000014701) ----------------------------------------------------
__int64  sub_14701(__int64 a1, unsigned __int64 a2)
{
  unsigned int v2; // ST18_4
  int v4; // [rsp+18h] [rbp-8h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  v5 = 0;
  v4 = 0;
  while ( a2 > v5 )
  {
    v2 = 1025 * (*(char *)(v5 + a1) + v4);
    v4 = (v2 >> 6) ^ v2;
    ++v5;
  }
  return 32769 * (((unsigned int)(9 * v4) >> 11) ^ 9 * v4);
}

//----- (000000000001476E) ----------------------------------------------------
__int64  sub_1476E(unsigned int a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int v3; // ST14_4
  unsigned int v5; // [rsp+14h] [rbp-14h]
  unsigned int i; // [rsp+24h] [rbp-4h]

  v5 = a1;
  if ( a2 )
  {
    for ( i = 0; a3 > i; ++i )
    {
      v3 = 1025 * (*(char *)(i + a2) + v5);
      v5 = (v3 >> 6) ^ v3;
    }
  }
  else
  {
    v5 = 32769 * ((9 * a1 >> 11) ^ 9 * a1);
  }
  return v5;
}

//----- (00000000000147E1) ----------------------------------------------------
unsigned __int64  lydict_remove(__int64 a1, __int64 a2)
{
  __int64 v6; // r8
  __int64 v7; // r9
  int v8; // ST1C_4
  char *s; // [rsp+0h] [rbp-50h]
  unsigned int v11; // [rsp+18h] [rbp-38h]
  unsigned __int64 v12; // [rsp+20h] [rbp-30h]
  __int64 v13; // [rsp+28h] [rbp-28h]
  void *ptr; // [rsp+30h] [rbp-20h]
  char *v15; // [rsp+3Ch] [rbp-14h]
  int v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v17 = __readfsqword(0x28u);
  v13 = 0LL;
  if ( s && a1 )
  {
    v12 = strlen(s);
    v11 = sub_14701((__int64)s, v12);
    v15 = s;
    v16 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
    sub_14E8E(*(_QWORD *)a1, (__int64)&v12);
    if ( !(unsigned int)sub_154F1(*(_QWORD *)a1, (__int64)&v15, v11, &v13) )
    {
      if ( v13 )
      {
        if ( !--*(_DWORD *)(v13 + 8) )
        {
          ptr = *(void **)v13;
          v8 = sub_15F8D(*(_QWORD *)a1, (__int64)&v15, v11, (__int64)&v15, v6, v7);
          free(ptr);
          if ( v8 )
            sub_12222(
              a1,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
              186LL);
        }
      }
      else
      {
        sub_12222(
          a1,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
          173LL);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  }
  return __readfsqword(0x28u) ^ v17;
}

//----- (00000000000149A6) ----------------------------------------------------
__int64  sub_149A6(__int64 *a1, void *a2, size_t a3, int a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  void **v9; // rbx
  __int64 v10; // r9
  int v12; // [rsp+4h] [rbp-5Ch]
  size_t n; // [rsp+8h] [rbp-58h]
  void *ptr; // [rsp+10h] [rbp-50h]
  __int64 *v15; // [rsp+18h] [rbp-48h]
  int v16; // [rsp+28h] [rbp-38h]
  unsigned int v17[4]; // [rsp+2Ch] [rbp-34h]
  void *v18; // [rsp+3Ch] [rbp-24h]
  int v19; // [rsp+44h] [rbp-1Ch]
  unsigned __int64 v20; // [rsp+48h] [rbp-18h]

  v15 = a1;
  ptr = a2;
  n = a3;
  v12 = a4;
  v20 = __readfsqword(0x28u);
  *(_QWORD *)&v17[1] = 0LL;
  v16 = 0;
  *(_QWORD *)v17 = (unsigned int)sub_14701((__int64)a2, a3);
  sub_14E8E(*a1, (__int64)&n);
  v18 = ptr;
  v19 = 1;
  sub_12312(1u, (__int64)"inserting \"%s\"", (__int64)ptr, v4, v5, v6);
  v16 = sub_15F55(*v15, &v18, v17[0], (__int64)&v17[1], v7, v8);
  if ( v16 == 1 )
  {
    ++*(_DWORD *)(*(_QWORD *)&v17[1] + 8LL);
    if ( v12 )
      free(ptr);
  }
  else
  {
    if ( v16 )
    {
      sub_12222(
        (__int64)v15,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
        228LL);
      return 0LL;
    }
    if ( !v12 )
    {
      v9 = *(void ***)&v17[1];
      *v9 = malloc(n + 1);
      if ( !**(_QWORD **)&v17[1] )
      {
        sub_12222((__int64)v15, 0, 1, "Memory allocation failed (%s()).", (__int64)"dict_insert", v10);
        return 0LL;
      }
      memcpy(**(void ***)&v17[1], ptr, n);
      *(_BYTE *)(**(_QWORD **)&v17[1] + n) = 0;
    }
  }
  return **(_QWORD **)&v17[1];
}

//----- (0000000000014B6B) ----------------------------------------------------
__int64  lydict_insert(__int64 a1, char *a2, size_t a3)
{
  __int64 v7; // ST28_8
  size_t v8; // [rsp+8h] [rbp-28h]

  v8 = a3;
  if ( !a2 )
    return 0LL;
  if ( !v8 )
    v8 = strlen(a2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v7 = sub_149A6((__int64 *)a1, a2, v8, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  return v7;
}

//----- (0000000000014C04) ----------------------------------------------------
__int64  lydict_insert_zc(__int64 a1, __int64 a2)
{
  size_t v7; // rax
  __int64 v8; // ST18_8
  char *s; // [rsp+0h] [rbp-20h]


  if ( !s )
    return 0LL;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v7 = strlen(s);
  v8 = sub_149A6((__int64 *)a1, s, v7, 1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  return v8;
}

//----- (0000000000014C8D) ----------------------------------------------------
__int64  sub_14C8D(__int64 a1, unsigned __int16 a2, int a3)
{
  return a3 * (unsigned int)a2 + a1;
}

//----- (0000000000014CB1) ----------------------------------------------------
_QWORD * sub_14CB1(unsigned int a1, __int16 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // r9
  _QWORD *result; // rax
  __int64 v7; // r9
  __int16 v8; // [rsp+4h] [rbp-2Ch]
  __int64 v9; // [rsp+8h] [rbp-28h]
  __int64 v10; // [rsp+10h] [rbp-20h]
  unsigned int nmemb; // [rsp+1Ch] [rbp-14h]
  _QWORD *ptr; // [rsp+28h] [rbp-8h]

  nmemb = a1;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( !a1 || a1 & (a1 - 1) )
    __assert_fail(
      "size && !(size & (size - 1))",
      "/home/mantovan/Repositories/libyang/src/hash_table.c",
      0x11Fu,
      "lyht_new");
  if ( !a3 || !a2 )
    __assert_fail("val_equal && val_size", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x120u, "lyht_new");
  if ( a5 && a5 != 1 )
    __assert_fail(
      "resize == 0 || resize == 1",
      "/home/mantovan/Repositories/libyang/src/hash_table.c",
      0x121u,
      "lyht_new");
  if ( a1 <= 7 )
    nmemb = 8;
  ptr = malloc(0x28uLL);
  if ( ptr )
  {
    *(_DWORD *)ptr = 0;
    *((_DWORD *)ptr + 1) = nmemb;
    ptr[1] = v10;
    ptr[2] = v9;
    *((_WORD *)ptr + 12) = v8;
    *((_WORD *)ptr + 13) = a2 + 8;
    ptr[4] = calloc(nmemb, *((unsigned __int16 *)ptr + 13));
    if ( ptr[4] )
    {
      result = ptr;
    }
    else
    {
      free(ptr);
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyht_new", v7);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyht_new", v5);
    result = 0LL;
  }
  return result;
}

//----- (0000000000014E64) ----------------------------------------------------
__int64  sub_14E64(__int64 a1, __int64 a2)
{
  __int64 v2; // ST18_8

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
  return v2;
}

//----- (0000000000014E8E) ----------------------------------------------------
__int64  sub_14E8E(__int64 a1, __int64 a2)
{
  __int64 v2; // ST18_8

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2;
  return v2;
}

//----- (0000000000014EB8) ----------------------------------------------------
_QWORD * sub_14EB8(unsigned int *a1)
{
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v2 = sub_14CB1(a1[1], *((_WORD *)a1 + 13) - 8, *((_QWORD *)a1 + 1), *((_QWORD *)a1 + 2), *((_WORD *)a1 + 12) != 0);
  if ( !v2 )
    return 0LL;
  memcpy((void *)v2[4], *((const void **)a1 + 4), *((unsigned __int16 *)a1 + 13) * (unsigned __int64)*a1);
  *(_DWORD *)v2 = *a1;
  return v2;
}

//----- (0000000000014F6B) ----------------------------------------------------
void  sub_14F6B(void **a1)
{
  if ( a1 )
  {
    free(a1[4]);
    free(a1);
  }
}

//----- (0000000000014F9D) ----------------------------------------------------
signed __int64  sub_14F9D(__int64 a1, int a2)
{
  int v2; // edx
  __int64 v3; // r9
  signed __int64 result; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned int i; // [rsp+14h] [rbp-1Ch]
  unsigned int v8; // [rsp+18h] [rbp-18h]
  void *ptr; // [rsp+20h] [rbp-10h]
  unsigned int *v10; // [rsp+28h] [rbp-8h]

  ptr = *(void **)(a1 + 32);
  v8 = *(_DWORD *)(a1 + 4);
  if ( a2 )
    v2 = 2 * *(_DWORD *)(a1 + 4);
  else
    v2 = *(_DWORD *)(a1 + 4) >> 1;
  *(_DWORD *)(a1 + 4) = v2;
  *(_QWORD *)(a1 + 32) = calloc(*(unsigned int *)(a1 + 4), *(unsigned __int16 *)(a1 + 26));
  if ( *(_QWORD *)(a1 + 32) )
  {
    *(_DWORD *)a1 = 0;
    for ( i = 0; i < v8; ++i )
    {
      v10 = (unsigned int *)sub_14C8D((__int64)ptr, *(_WORD *)(a1 + 26), i);
      if ( (signed int)v10[1] > 0 )
      {
        if ( (unsigned int)sub_15F55(a1, v10 + 2, *v10, 0LL, v5, v6) )
          __assert_fail("!ret", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x186u, "lyht_resize");
      }
    }
    free(ptr);
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyht_resize", v3);
    *(_QWORD *)(a1 + 32) = ptr;
    *(_DWORD *)(a1 + 4) = v8;
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000001510F) ----------------------------------------------------
signed __int64  sub_1510F(__int64 a1, int a2, _QWORD *a3)
{
  signed __int64 result; // rax
  _DWORD *v4; // rax
  _QWORD *v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  _DWORD *src; // [rsp+30h] [rbp-10h]
  void *dest; // [rsp+38h] [rbp-8h]

  v5 = a3;
  dest = 0LL;
  if ( a3 )
    *a3 = 0LL;
  v6 = a2 & (*(_DWORD *)(a1 + 4) - 1);
  v7 = a2 & (*(_DWORD *)(a1 + 4) - 1);
  for ( src = (_DWORD *)sub_14C8D(
                          *(_QWORD *)(a1 + 32),
                          *(_WORD *)(a1 + 26),
                          a2 & (unsigned int)(*(_DWORD *)(a1 + 4) - 1));
        ;
        src = (_DWORD *)sub_14C8D(*(_QWORD *)(a1 + 32), *(_WORD *)(a1 + 26), v6) )
  {
    if ( !src[1] || src[1] != -1 && v7 == (*src & (*(_DWORD *)(a1 + 4) - 1)) )
    {
      if ( src[1] )
      {
        if ( dest )
        {
          memcpy(dest, src, *(unsigned __int16 *)(a1 + 26));
          src[1] = -1;
          src = dest;
        }
        if ( v5 )
          *v5 = src;
        result = 0LL;
      }
      else
      {
        if ( v5 )
        {
          if ( dest )
            v4 = dest;
          else
            v4 = src;
          *v5 = v4;
        }
        result = 1LL;
      }
      return result;
    }
    if ( src[1] == -1 && !dest )
      dest = src;
    v6 = (unsigned int)(v6 + 1) % *(_DWORD *)(a1 + 4);
    if ( v6 == v7 )
      break;
  }
  if ( !dest )
    __assert_fail("inval_rec", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x1A9u, "lyht_find_first");
  if ( v5 )
    *v5 = dest;
  return 1LL;
}

//----- (00000000000152D5) ----------------------------------------------------
signed __int64  sub_152D5(__int64 a1, const void **a2, const void *a3)
{
  signed __int64 result; // rax
  const void *v4; // [rsp+8h] [rbp-28h]
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  void *dest; // [rsp+28h] [rbp-8h]

  v4 = a3;
  dest = 0LL;
  if ( !a2 || !*a2 )
    __assert_fail(
      "last && *last",
      "/home/mantovan/Repositories/libyang/src/hash_table.c",
      0x1D7u,
      "lyht_find_collision");
  v6 = *(_DWORD *)*a2 & (*(_DWORD *)(a1 + 4) - 1);
  v5 = (_QWORD)((_QWORD)*a2 - *(_QWORD *)(a1 + 32)) / *(unsigned __int16 *)(a1 + 26);
  do
  {
    v5 = (unsigned int)(v5 + 1) % *(_DWORD *)(a1 + 4);
    *a2 = (const void *)sub_14C8D(*(_QWORD *)(a1 + 32), *(_WORD *)(a1 + 26), v5);
    if ( v4 == *a2 )
    {
      if ( !dest )
        __assert_fail(
          "inval_rec",
          "/home/mantovan/Repositories/libyang/src/hash_table.c",
          0x1E2u,
          "lyht_find_collision");
      *a2 = dest;
      return 1LL;
    }
    if ( *((_DWORD *)*a2 + 1) == -1 && !dest )
      dest = (void *)*a2;
  }
  while ( *((_DWORD *)*a2 + 1) && (*((_DWORD *)*a2 + 1) == -1 || v6 != (*(_DWORD *)*a2 & (*(_DWORD *)(a1 + 4) - 1))) );
  if ( *((_DWORD *)*a2 + 1) <= 0 )
  {
    if ( dest )
      *a2 = dest;
    result = 1LL;
  }
  else
  {
    if ( *((_DWORD *)*a2 + 1) != 1 )
      __assert_fail(
        "(*last)->hits == 1",
        "/home/mantovan/Repositories/libyang/src/hash_table.c",
        0x1EEu,
        "lyht_find_collision");
    if ( dest )
    {
      memcpy(dest, *a2, *(unsigned __int16 *)(a1 + 26));
      *((_DWORD *)*a2 + 1) = -1;
      *a2 = dest;
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000154F1) ----------------------------------------------------
signed __int64  sub_154F1(__int64 a1, __int64 a2, int a3, _QWORD *a4)
{
  signed __int64 result; // rax
  _QWORD *v5; // [rsp+0h] [rbp-50h]
  int v6; // [rsp+Ch] [rbp-44h]
  unsigned int i; // [rsp+2Ch] [rbp-24h]
  unsigned int v8; // [rsp+30h] [rbp-20h]
  _DWORD *v9; // [rsp+38h] [rbp-18h]
  const void *v10; // [rsp+40h] [rbp-10h]
  unsigned __int64 v11; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v11 = __readfsqword(0x28u);
  if ( (unsigned int)sub_1510F(a1, a3, &v9) )
    return 1LL;
  if ( v6 == *v9
    && (*(unsigned int ( **)(__int64, _DWORD *, _QWORD, _QWORD))(a1 + 8))(
         a2,
         v9 + 2,
         0LL,
         *(_QWORD *)(a1 + 16)) )
  {
    if ( v5 )
      *v5 = v9 + 2;
    result = 0LL;
  }
  else
  {
    v10 = v9;
    v8 = v9[1];
    for ( i = 1; ; ++i )
    {
      if ( i >= v8 )
        return 1LL;
      if ( (unsigned int)sub_152D5(a1, (const void **)&v9, v10) )
        __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x216u, "lyht_find");
      if ( v6 == *v9
        && (*(unsigned int ( **)(__int64, _DWORD *, _QWORD, _QWORD))(a1 + 8))(
             a2,
             v9 + 2,
             0LL,
             *(_QWORD *)(a1 + 16)) )
      {
        break;
      }
    }
    if ( v5 )
      *v5 = v9 + 2;
    result = 0LL;
  }
  return result;
}

//----- (0000000000015669) ----------------------------------------------------
signed __int64  sub_15669(__int64 a1, __int64 a2, int a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-50h]
  int v6; // [rsp+Ch] [rbp-44h]
  unsigned int i; // [rsp+28h] [rbp-28h]
  signed int v8; // [rsp+2Ch] [rbp-24h]
  unsigned int v9; // [rsp+30h] [rbp-20h]
  _DWORD *v10; // [rsp+38h] [rbp-18h]
  const void *v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  v8 = 0;
  if ( (unsigned int)sub_1510F(a1, a3, &v10) )
    __assert_fail("0", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x22Fu, "lyht_find_next");
  if ( v6 == *v10
    && (*(unsigned int ( **)(__int64, _DWORD *, signed __int64, _QWORD))(a1 + 8))(
         a2,
         v10 + 2,
         1LL,
         *(_QWORD *)(a1 + 16)) )
  {
    v8 = 1;
  }
  if ( v10[1] == 1 )
  {
    if ( v6 != *v10 )
      __assert_fail(
        "rec->hash == hash",
        "/home/mantovan/Repositories/libyang/src/hash_table.c",
        0x239u,
        "lyht_find_next");
    if ( !v8 )
      __assert_fail("found", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x23Au, "lyht_find_next");
    return 1LL;
  }
  v11 = v10;
  v9 = v10[1];
  for ( i = 1; ; ++i )
  {
    if ( i >= v9 )
    {
      if ( !v8 )
        __assert_fail("found", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x25Du, "lyht_find_next");
      return 1LL;
    }
    if ( (unsigned int)sub_152D5(a1, (const void **)&v10, v11) )
      __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x243u, "lyht_find_next");
    if ( v6 == *v10 )
      break;
LABEL_22:
    ;
  }
  if ( !v8 )
  {
    if ( (*(unsigned int ( **)(__int64, _DWORD *, signed __int64, _QWORD))(a1 + 8))(
           a2,
           v10 + 2,
           1LL,
           *(_QWORD *)(a1 + 16)) )
    {
      v8 = 1;
    }
    goto LABEL_22;
  }
  if ( v5 )
    *v5 = v10 + 2;
  return 0LL;
}

//----- (0000000000015881) ----------------------------------------------------
char * sub_15881(__int64 a1, int a2, unsigned __int16 a3)
{
  char *v3; // rax
  int v5; // [rsp+1Ch] [rbp-14h]
  int v6; // [rsp+20h] [rbp-10h]
  int v7; // [rsp+24h] [rbp-Ch]
  char *v8; // [rsp+28h] [rbp-8h]

  v7 = a3 - 8;
  v8 = (char *)malloc(2 * v7 + 1);
  v5 = 0;
  v6 = v7 - 1;
  while ( v5 < v7 )
  {
    if ( a2 <= 0 )
    {
      v3 = &v8[2 * v5];
      *(_WORD *)v3 = 8224;
      v3[2] = 0;
    }
    else
    {
      sprintf(&v8[2 * v5], "%02x", *(unsigned __int8 *)(v6 + a1));
    }
    ++v5;
    --v6;
  }
  return v8;
}

//----- (0000000000015936) ----------------------------------------------------
unsigned __int64  sub_15936(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // r9
  __int64 v8; // ST20_8
  char *v9; // ST40_8
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  unsigned int i; // [rsp+18h] [rbp-18h]
  unsigned int v15; // [rsp+1Ch] [rbp-14h]
  char *s; // [rsp+20h] [rbp-10h]
  unsigned int *v17; // [rsp+28h] [rbp-8h]

  result = (unsigned __int8)byte_3458A0;
  if ( (unsigned __int8)byte_3458A0 > 2u )
  {
    sub_12312(0x40u, (__int64)&unk_10A3C1, a3, a4, a5, a6, a2);
    sub_12312(0x40u, (__int64)"hash table %s (used %u, size %u):", v8, *a1, a1[1], v7);
    v9 = (char *)malloc(0xBuLL);
    sprintf(v9, off_10A3EA, a1[1]);
    v15 = strlen(v9);
    free(v9);
    for ( i = 0; i < a1[1]; ++i )
    {
      v17 = (unsigned int *)sub_14C8D(*((_QWORD *)a1 + 4), *((_WORD *)a1 + 13), i);
      s = sub_15881((__int64)(v17 + 2), v17[1], *((_WORD *)a1 + 13));
      if ( (signed int)v17[1] <= 0 )
        sub_12312(
          0x40u,
          (__int64)"[%*u] val  %s  hash  %10s %% %*s  hits  %2d",
          v15,
          i,
          (__int64)s,
          (__int64)&unk_10A3C1,
          v15,
          &unk_10A3C1,
          v17[1]);
      else
        sub_12312(
          0x40u,
          (__int64)"[%*u] val  %s  hash  %10u %% %*u  hits  %2d",
          v15,
          i,
          (__int64)s,
          *v17,
          v15,
          (a1[1] - 1) & *v17,
          v17[1]);
      free(s);
    }
    result = sub_12312(0x40u, (__int64)&unk_10A3C1, v10, v11, v12, v13);
  }
  return result;
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000015B2B) ----------------------------------------------------
void  sub_15B2B(__int64 a1, unsigned int a2, unsigned __int16 a3, __int64 a4)
{
  char *ptr; // ST28_8
  __int64 v5; // r9
  __int64 v6; // [rsp+8h] [rbp-28h]

  v6 = a4;
  if ( (unsigned __int8)byte_3458A0 > 2u )
  {
    ptr = sub_15881(a1, 1, a3);
    sub_12312(0x40u, (__int64)"%s value %s with hash %u", v6, (__int64)ptr, a2, v5);
    free(ptr);
  }
}
// 3458A0: using guessed type char byte_3458A0;

//----- (0000000000015BA6) ----------------------------------------------------
signed __int64  sub_15BA6(__int64 a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  _QWORD *v11; // [rsp+8h] [rbp-58h]
  __int64 v12; // [rsp+10h] [rbp-50h]
  unsigned int v13; // [rsp+1Ch] [rbp-44h]
  signed int i; // [rsp+34h] [rbp-2Ch]
  unsigned int v15; // [rsp+38h] [rbp-28h]
  signed int v16; // [rsp+3Ch] [rbp-24h]
  unsigned int *v17; // [rsp+40h] [rbp-20h]
  unsigned int *v18; // [rsp+48h] [rbp-18h]
  __int64 v19; // [rsp+50h] [rbp-10h]
  unsigned __int64 v20; // [rsp+58h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = (_QWORD *)a5;
  v20 = __readfsqword(0x28u);
  v18 = 0LL;
  sub_15936((unsigned int *)a1, (__int64)"before", a3, a4, a5, a6);
  sub_15B2B((__int64)a2, v13, *(_WORD *)(a1 + 26), (__int64)"inserting");
  if ( (unsigned int)sub_1510F(a1, v13, &v17) )
  {
LABEL_19:
    if ( (signed int)v17[1] > 0 )
      __assert_fail(
        "rec->hits < 1",
        "/home/mantovan/Repositories/libyang/src/hash_table.c",
        0x2CFu,
        "lyht_insert_with_resize_cb");
    *v17 = v13;
    v17[1] = 1;
    memcpy(v17 + 2, a2, *(unsigned __int16 *)(a1 + 26) - 8LL);
    if ( v11 )
      *v11 = v17 + 2;
    if ( v18 )
    {
      if ( v18[1] == 0x7FFFFFFF )
        sub_12222(
          0LL,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/hash_table.c",
          730LL);
      ++v18[1];
    }
    v15 = 0;
    v10 = (unsigned int)(*(_DWORD *)a1 + 1);
    *(_DWORD *)a1 = v10;
    if ( *(_WORD *)(a1 + 24) )
    {
      v7 = *(unsigned int *)(a1 + 4);
      v10 = 100 * *(_DWORD *)a1 % (unsigned int)v7;
      v16 = 100 * *(_DWORD *)a1 / (unsigned int)v7;
      if ( *(_WORD *)(a1 + 24) == 1 && v16 > 49 )
        *(_WORD *)(a1 + 24) = 2;
      if ( *(_WORD *)(a1 + 24) == 2 && v16 > 74 )
      {
        if ( v12 )
          v19 = sub_14E64(a1, v12);
        v15 = sub_14F9D(a1, 1);
        if ( !v15 && v11 )
          sub_154F1(a1, (__int64)a2, v13, v11);
        if ( v12 )
          sub_14E64(a1, v19);
      }
    }
    sub_15936((unsigned int *)a1, (__int64)"after", v10, v7, v8, v9);
    result = v15;
  }
  else if ( v13 == *v17
         && (*(unsigned int ( **)(const void *, unsigned int *, signed __int64, _QWORD))(a1 + 8))(
              a2,
              v17 + 2,
              1LL,
              *(_QWORD *)(a1 + 16)) )
  {
    if ( v11 )
      *v11 = v17 + 2;
    result = 1LL;
  }
  else
  {
    v18 = v17;
    for ( i = 1; ; ++i )
    {
      if ( i >= (signed int)v18[1] )
      {
        if ( !(unsigned int)sub_152D5(a1, (const void **)&v17, v18) )
          __assert_fail(
            "r",
            "/home/mantovan/Repositories/libyang/src/hash_table.c",
            0x2CBu,
            "lyht_insert_with_resize_cb");
        goto LABEL_19;
      }
      if ( (unsigned int)sub_152D5(a1, (const void **)&v17, v18) )
        __assert_fail(
          "!r",
          "/home/mantovan/Repositories/libyang/src/hash_table.c",
          0x2BEu,
          "lyht_insert_with_resize_cb");
      if ( v13 == *v17
        && (*(unsigned int ( **)(const void *, unsigned int *, signed __int64, _QWORD))(a1 + 8))(
             a2,
             v17 + 2,
             1LL,
             *(_QWORD *)(a1 + 16)) )
      {
        break;
      }
    }
    if ( v11 )
      *v11 = v17 + 2;
    result = 1LL;
  }
  return result;
}

//----- (0000000000015F55) ----------------------------------------------------
signed __int64  sub_15F55(__int64 a1, const void *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_15BA6(a1, a2, a3, 0LL, a4, a6);
}

//----- (0000000000015F8D) ----------------------------------------------------
signed __int64  sub_15F8D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // rdx
  unsigned int v12; // [rsp+Ch] [rbp-44h]
  signed int i; // [rsp+28h] [rbp-28h]
  signed int v14; // [rsp+2Ch] [rbp-24h]
  unsigned int v15; // [rsp+30h] [rbp-20h]
  void *src; // [rsp+38h] [rbp-18h]
  void *dest; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v18 = __readfsqword(0x28u);
  v14 = 0;
  sub_15936((unsigned int *)a1, (__int64)"before", a3, a4, a5, a6);
  sub_15B2B(a2, v12, *(_WORD *)(a1 + 26), (__int64)"removing");
  if ( (unsigned int)sub_1510F(a1, v12, &src) )
  {
    sub_12312(0x40u, (__int64)"remove failed", v6, v7, v8, v9);
    return 1LL;
  }
  if ( v12 == *(_DWORD *)src
    && (*(unsigned int ( **)(__int64, char *, signed __int64, _QWORD))(a1 + 8))(
         a2,
         (char *)src + 8,
         1LL,
         *(_QWORD *)(a1 + 16)) )
  {
    v14 = 1;
  }
  dest = src;
  for ( i = 1; i < *((_DWORD *)dest + 1); ++i )
  {
    if ( (unsigned int)sub_152D5(a1, (const void **)&src, dest) )
      __assert_fail("!r", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x31Cu, "lyht_remove");
    if ( !v14
      && v12 == *(_DWORD *)src
      && (*(unsigned int ( **)(__int64, char *, signed __int64, _QWORD))(a1 + 8))(
           a2,
           (char *)src + 8,
           1LL,
           *(_QWORD *)(a1 + 16)) )
    {
      break;
    }
  }
  if ( i >= *((_DWORD *)dest + 1) )
  {
    if ( !v14 )
    {
      sub_12312(0x40u, (__int64)"remove failed", v6, v7, v8, v9);
      return 1LL;
    }
    if ( dest != src )
    {
      *((_DWORD *)src + 1) = *((_DWORD *)dest + 1) - 1;
      memcpy(dest, src, *(unsigned __int16 *)(a1 + 26));
    }
    *((_DWORD *)src + 1) = -1;
  }
  else
  {
    if ( v14 )
      __assert_fail("!first_matched", "/home/mantovan/Repositories/libyang/src/hash_table.c", 0x326u, "lyht_remove");
    --*((_DWORD *)dest + 1);
    *((_DWORD *)src + 1) = -1;
  }
  v15 = 0;
  v11 = (unsigned int)(*(_DWORD *)a1 - 1);
  *(_DWORD *)a1 = v11;
  if ( *(_WORD *)(a1 + 24) == 2 )
  {
    v7 = *(unsigned int *)(a1 + 4);
    v11 = 100 * *(_DWORD *)a1 % (unsigned int)v7;
    if ( (signed int)(100 * *(_DWORD *)a1 / (unsigned int)v7) <= 24 && *(_DWORD *)(a1 + 4) > 8u )
      v15 = sub_14F9D(a1, 0);
  }
  sub_15936((unsigned int *)a1, (__int64)"after", v11, v7, v8, v9);
  return v15;
}

//----- (0000000000016271) ----------------------------------------------------
signed __int64  sub_16271(_QWORD *a1, unsigned __int8 a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-38h]
  char v5; // [rsp+21h] [rbp-1Fh]
  signed __int16 v6; // [rsp+22h] [rbp-1Eh]
  signed int v7; // [rsp+24h] [rbp-1Ch]
  __int128 v8; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+38h] [rbp-8h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v7 = 0;
  v6 = 255;
  v8 = (unsigned __int64)*a1;
  if ( *(_BYTE *)v8 == 45 )
  {
    v7 = 1;
    *(_QWORD *)&v8 = v8 + 1;
  }
  else if ( *(_BYTE *)v8 == 43 )
  {
    *(_QWORD *)&v8 = v8 + 1;
  }
  if ( !((*__ctype_b_loc())[*(char *)v8] & 0x800) )
    return 1LL;
  v5 = 0;
  while ( (*__ctype_b_loc())[*(char *)v8] & 0x800 || *(_BYTE *)v8 == 46 && (v6 & 0x80u) != 0 )
  {
    if ( v5 > 18 )
      return 1LL;
    if ( *(_BYTE *)v8 == 46 )
    {
      if ( *(_BYTE *)(v8 + 1) == 46 )
        break;
      LOBYTE(v6) = v6 + 1;
    }
    else
    {
      v9 = *((_QWORD *)&v8 + 1);
      if ( v7 )
      {
        *((_QWORD *)&v8 + 1) = 10LL * *((_QWORD *)&v8 + 1) - (*(char *)v8 - 48);
        if ( *((_QWORD *)&v8 + 1) > v9 )
          return 1LL;
      }
      else
      {
        *((_QWORD *)&v8 + 1) = 10LL * *((_QWORD *)&v8 + 1) + *(char *)v8 - 48;
        if ( *((_QWORD *)&v8 + 1) < v9 )
          return 1LL;
      }
      if ( (v6 & 0x80u) == 0 )
      {
        LOBYTE(v6) = v6 + 1;
        if ( *(_BYTE *)v8 == 48 )
          ++HIBYTE(v6);
        else
          HIBYTE(v6) = 0;
      }
      ++v5;
    }
    *(_QWORD *)&v8 = v8 + 1;
  }
  if ( !(_BYTE)v6 )
    return 1LL;
  if ( (_BYTE)v6 == -1 )
    LOBYTE(v6) = 0;
  if ( HIBYTE(v6) )
  {
    LOBYTE(v6) = v6 - HIBYTE(v6);
    v5 -= HIBYTE(v6);
    *((_QWORD *)&v8 + 1) /= sub_C4C9(HIBYTE(v6));
  }
  if ( (char)v6 >= (signed int)a2 )
    goto LABEL_46;
  if ( v5 - 1 + a2 - (signed int)(char)v6 > 18 )
    return 1LL;
  v10 = *((_QWORD *)&v8 + 1);
  *((_QWORD *)&v8 + 1) *= sub_C4C9(a2 - (unsigned __int8)v6);
  if ( v7 )
  {
    if ( *((_QWORD *)&v8 + 1) > v10 )
      return 1LL;
  }
  if ( !v7 && *((_QWORD *)&v8 + 1) < v10 )
    return 1LL;
LABEL_46:
  if ( (char)v6 > (signed int)a2 )
    return 1LL;
  *a1 = v8;
  *v4 = *((_QWORD *)&v8 + 1);
  return 0LL;
}

//----- (0000000000016564) ----------------------------------------------------
__int64  sub_16564(_BYTE *a1)
{
  _BYTE *i; // [rsp+8h] [rbp-18h]
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x9Fu, "parse_identifier");
  if ( !((*__ctype_b_loc())[(char)*a1] & 0x400) && *a1 != 95 )
    return 0LL;
  v3 = 1;
  for ( i = a1 + 1; (*__ctype_b_loc())[(char)*i] & 8 || *i == 95 || *i == 45 || *i == 46; ++i )
    ++v3;
  return v3;
}

//----- (0000000000016637) ----------------------------------------------------
__int64  sub_16637(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, int a7)
{
  __int64 result; // rax
  unsigned int *v8; // [rsp+8h] [rbp-48h]
  _QWORD *v9; // [rsp+10h] [rbp-40h]
  unsigned int *v10; // [rsp+18h] [rbp-38h]
  _BYTE *v11; // [rsp+28h] [rbp-28h]
  _BYTE *v12; // [rsp+28h] [rbp-28h]
  int v13; // [rsp+38h] [rbp-18h]
  int v14; // [rsp+38h] [rbp-18h]
  int v15; // [rsp+38h] [rbp-18h]
  unsigned int v16; // [rsp+38h] [rbp-18h]
  int v17; // [rsp+38h] [rbp-18h]
  signed int v18; // [rsp+3Ch] [rbp-14h]
  int v19; // [rsp+40h] [rbp-10h]
  int v20; // [rsp+40h] [rbp-10h]
  unsigned int v21; // [rsp+44h] [rbp-Ch]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v18 = 0;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0xC7u, "parse_node_identifier");
  if ( (!a2 || !a3) && (a2 || a3) )
    __assert_fail(
      "(mod_name && mod_name_len) || (!mod_name && !mod_name_len)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0xC8u,
      "parse_node_identifier");
  if ( (!a4 || !a5) && (a4 || a5) )
    __assert_fail(
      "(name && nam_len) || (!name && !nam_len)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0xC9u,
      "parse_node_identifier");
  if ( a2 )
  {
    *a2 = 0LL;
    *a3 = 0;
  }
  if ( a4 )
  {
    *a4 = 0LL;
    *a5 = 0;
  }
  if ( !a7 )
    goto LABEL_47;
  if ( *a1 == 47 )
  {
    if ( a6 )
      *a6 = 1;
    v18 = 1;
  }
  else if ( a6 )
  {
    *a6 = 0;
  }
  v13 = sub_16564(&a1[v18]);
  if ( v13 <= 0 )
  {
    v14 = v18;
  }
  else
  {
    if ( a1[v18 + v13] != 58 )
      goto LABEL_47;
    if ( a2 )
    {
      *a2 = &a1[v18];
      *v10 = v13;
    }
    v14 = v18 + 1 + v13;
  }
  switch ( a1[v14] )
  {
    case 0x2A:
      if ( v9 )
      {
        *v9 = &a1[v14];
        *v8 = 1;
      }
      return (unsigned int)(v14 + 1);
    case 0x2E:
      if ( !v18 )
        return (unsigned int)-v14;
      if ( v9 )
      {
        *v9 = &a1[v14];
        *v8 = 1;
      }
      return (unsigned int)(v14 + 1);
    case 0x23:
      if ( v18 || !v14 )
        return 0LL;
      v19 = v14 + 1;
      v15 = sub_16564(&a1[v14 + 1]);
      if ( v15 <= 0 )
        return (unsigned int)(v15 - v19);
      *v9 = &a1[v19 - 1];
      *v8 = v15 + 1;
      return (unsigned int)(v19 + v15);
  }
LABEL_47:
  v16 = sub_16564(a1);
  if ( (signed int)v16 <= 0 )
    return v16;
  v21 = v16;
  v11 = &a1[v16];
  if ( *v11 == 58 )
  {
    v20 = v16 + 1;
    v12 = v11 + 1;
    v17 = sub_16564(v12);
    if ( v17 > 0 )
    {
      if ( a2 )
      {
        *a2 = a1;
        *v10 = v21;
      }
      if ( v9 )
      {
        *v9 = v12;
        *v8 = v17;
      }
      result = (unsigned int)(v20 + v17);
    }
    else
    {
      result = (unsigned int)(v17 - v20);
    }
  }
  else
  {
    if ( v9 )
    {
      *v9 = a1;
      *v8 = v16;
    }
    result = v16;
  }
  return result;
}

//----- (00000000000169E9) ----------------------------------------------------
__int64  sub_169E9(_BYTE *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8)
{
  char **v9; // [rsp+0h] [rbp-40h]
  unsigned int *v10; // [rsp+8h] [rbp-38h]
  _QWORD *v11; // [rsp+10h] [rbp-30h]
  unsigned int *v12; // [rsp+18h] [rbp-28h]
  char *s; // [rsp+28h] [rbp-18h]
  char *sa; // [rsp+28h] [rbp-18h]
  char *sb; // [rsp+28h] [rbp-18h]
  char *sc; // [rsp+28h] [rbp-18h]
  signed int v17; // [rsp+30h] [rbp-10h]
  int v18; // [rsp+30h] [rbp-10h]
  int v19; // [rsp+30h] [rbp-10h]
  int v20; // [rsp+30h] [rbp-10h]
  int v21; // [rsp+34h] [rbp-Ch]
  int v22; // [rsp+34h] [rbp-Ch]
  char *v23; // [rsp+38h] [rbp-8h]
  char *i; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x15Eu, "parse_path_predicate");
  if ( a2 )
    *a2 = 0LL;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0LL;
  if ( a5 )
    *a5 = 0;
  if ( a6 )
    *a6 = 0LL;
  if ( a7 )
    *a7 = 0;
  if ( a8 )
    *a8 = 0;
  if ( *a1 != 91 )
    return 0LL;
  v17 = 1;
  for ( s = a1 + 1; (*__ctype_b_loc())[*s] & 0x2000; ++s )
    ++v17;
  v21 = sub_16637(s, a2, v12, v11, v10, 0LL, 0);
  if ( v21 <= 0 )
    return (unsigned int)(v21 - v17);
  v18 = v21 + v17;
  for ( sa = &s[v21]; (*__ctype_b_loc())[*sa] & 0x2000; ++sa )
    ++v18;
  if ( *sa != 61 )
    return (unsigned int)-v18;
  v19 = v18 + 1;
  for ( sb = sa + 1; (*__ctype_b_loc())[*sb] & 0x2000; ++sb )
    ++v19;
  v23 = strchr(sb, 93);
  if ( !v23 )
    return (unsigned int)-v19;
  for ( i = v23 - 1; (*__ctype_b_loc())[*i] & 0x2000; --i )
    ;
  v22 = (_DWORD)i + 1 - (_DWORD)sb;
  if ( v9 )
    *v9 = sb;
  if ( a7 )
    *a7 = v22;
  v20 = v22 + v19;
  for ( sc = &sb[v22]; (*__ctype_b_loc())[*sc] & 0x2000; ++sc )
    ++v20;
  if ( *sc != 93 )
    __assert_fail("id[0] == ']'", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1B3u, "parse_path_predicate");
  if ( sc[1] == 91 )
    *a8 = 1;
  return (unsigned int)(v20 + 1);
}

//----- (0000000000016CF6) ----------------------------------------------------
__int64  sub_16CF6(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, signed int *a6)
{
  __int64 result; // rax
  signed int *v7; // [rsp+0h] [rbp-40h]
  unsigned int *v8; // [rsp+8h] [rbp-38h]
  _QWORD *v9; // [rsp+10h] [rbp-30h]
  unsigned int *v10; // [rsp+18h] [rbp-28h]
  char *s1; // [rsp+28h] [rbp-18h]
  char *s1a; // [rsp+28h] [rbp-18h]
  char *s1b; // [rsp+28h] [rbp-18h]
  char *s1c; // [rsp+28h] [rbp-18h]
  char *s1d; // [rsp+28h] [rbp-18h]
  int v16; // [rsp+34h] [rbp-Ch]
  signed int v17; // [rsp+34h] [rbp-Ch]
  int v18; // [rsp+34h] [rbp-Ch]
  int v19; // [rsp+34h] [rbp-Ch]
  int v20; // [rsp+34h] [rbp-Ch]
  signed int v21; // [rsp+38h] [rbp-8h]
  int v22; // [rsp+3Ch] [rbp-4h]

  s1 = (char *)a1;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v16 = 0;
  v21 = 0;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1D7u, "parse_path_key_expr");
  if ( !a6 )
    __assert_fail("parent_times", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1D8u, "parse_path_key_expr");
  if ( a2 )
    *a2 = 0LL;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0LL;
  if ( a5 )
    *a5 = 0;
  if ( !*a6 )
  {
    if ( strncmp(a1, "current()", 9uLL) )
      return 0LL;
    v17 = 9;
    for ( s1a = (char *)(a1 + 9); (*__ctype_b_loc())[*s1a] & 0x2000; ++s1a )
      ++v17;
    if ( *s1a != 47 )
      return (unsigned int)-v17;
    v18 = v17 + 1;
    for ( s1b = s1a + 1; (*__ctype_b_loc())[*s1b] & 0x2000; ++s1b )
      ++v18;
    if ( strncmp(s1b, "..", 2uLL) )
      return (unsigned int)-v18;
    v21 = 1;
    v16 = v18 + 2;
    for ( s1 = s1b + 2; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
      ++v16;
  }
  if ( *s1 != 47 )
    return (unsigned int)-v16;
  v19 = v16 + 1;
  for ( s1c = s1 + 1; (*__ctype_b_loc())[*s1c] & 0x2000; ++s1c )
    ++v19;
  while ( !strncmp(s1c, "..", 2uLL) && !*v7 )
  {
    ++v21;
    v20 = v19 + 2;
    for ( s1d = s1c + 2; (*__ctype_b_loc())[*s1d] & 0x2000; ++s1d )
      ++v20;
    if ( *s1d != 47 )
      return (unsigned int)-v20;
    v19 = v20 + 1;
    for ( s1c = s1d + 1; (*__ctype_b_loc())[*s1c] & 0x2000; ++s1c )
      ++v19;
  }
  if ( !*v7 )
    *v7 = v21;
  v22 = sub_16637(s1c, a2, v10, v9, v8, 0LL, 0);
  if ( v22 > 0 )
    result = (unsigned int)(v22 + v19);
  else
    result = (unsigned int)(v22 - v19);
  return result;
}

//----- (0000000000017055) ----------------------------------------------------
__int64  sub_17055(__int64 a1, const char *a2, const char **a3, unsigned int *a4, _QWORD *a5, unsigned int *a6, signed int *a7, _DWORD *a8)
{
  unsigned int *v9; // [rsp+0h] [rbp-40h]
  _QWORD *v10; // [rsp+8h] [rbp-38h]
  unsigned int *v11; // [rsp+10h] [rbp-30h]
  const char **v12; // [rsp+18h] [rbp-28h]
  char *s1; // [rsp+20h] [rbp-20h]
  char *s1a; // [rsp+20h] [rbp-20h]
  char *s1b; // [rsp+20h] [rbp-20h]
  signed int v16; // [rsp+34h] [rbp-Ch]
  int v17; // [rsp+34h] [rbp-Ch]
  unsigned int v18; // [rsp+34h] [rbp-Ch]
  signed int v19; // [rsp+38h] [rbp-8h]
  int v20; // [rsp+3Ch] [rbp-4h]

  s1 = (char *)a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v16 = 0;
  v19 = 0;
  if ( !a2 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x261u, "parse_path_arg");
  if ( !a7 )
    __assert_fail("parent_times", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x262u, "parse_path_arg");
  if ( a3 )
    *a3 = 0LL;
  if ( a4 )
    *a4 = 0;
  if ( a5 )
    *a5 = 0LL;
  if ( a6 )
    *a6 = 0;
  if ( a8 )
    *a8 = 0;
  if ( !*a7 && !strncmp(a2, "..", 2uLL) )
  {
    v19 = 1;
    v16 = 2;
    for ( s1 = (char *)(a2 + 2); !strncmp(s1, "/..", 3uLL); s1 += 3 )
    {
      ++v19;
      v16 += 3;
    }
  }
  if ( !*a7 )
  {
    if ( v19 )
      *a7 = v19;
    else
      *a7 = -1;
  }
  if ( *s1 != 47 )
    return (unsigned int)-v16;
  v17 = v16 + 1;
  s1a = s1 + 1;
  v20 = sub_16637(s1a, v12, v11, v10, v9, 0LL, 0);
  if ( v20 <= 0 )
    return (unsigned int)(v20 - v17);
  if ( v12 && !*v12 )
  {
    *v12 = *(const char **)(lys_main_module(a1) + 8);
    *v11 = strlen(*v12);
  }
  v18 = v20 + v17;
  s1b = &s1a[v20];
  if ( *s1b == 47 || !*s1b )
    return v18;
  if ( *s1b != 91 )
    return -v18;
  if ( a8 )
    *a8 = 1;
  return v18;
}
// 7950: using guessed type __int64  lys_main_module(_QWORD);

//----- (000000000001729D) ----------------------------------------------------
__int64  sub_1729D(_BYTE *a1, signed __int64 *a2, unsigned int *a3, signed __int64 *a4, unsigned int *a5, _DWORD *a6)
{
  _DWORD *v7; // [rsp+0h] [rbp-40h]
  unsigned int *v8; // [rsp+8h] [rbp-38h]
  signed __int64 *v9; // [rsp+10h] [rbp-30h]
  unsigned int *v10; // [rsp+18h] [rbp-28h]
  signed __int64 v11; // [rsp+28h] [rbp-18h]
  _BYTE *v12; // [rsp+28h] [rbp-18h]
  _BYTE *v13; // [rsp+28h] [rbp-18h]
  unsigned int v14; // [rsp+38h] [rbp-8h]
  int v15; // [rsp+38h] [rbp-8h]
  unsigned int v16; // [rsp+3Ch] [rbp-4h]
  unsigned int v17; // [rsp+3Ch] [rbp-4h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    __assert_fail(
      "id && model && mod_len && name && nam_len",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x2C2u,
      "parse_instance_identifier");
  if ( a6 )
    *a6 = 0;
  if ( *a1 != 47 )
    return 0LL;
  v11 = (signed __int64)(a1 + 1);
  v16 = sub_16564(a1 + 1);
  if ( (signed int)v16 <= 0 )
    return v16;
  *v9 = v11;
  *v8 = v16;
  v14 = v16 + 1;
  v12 = (_BYTE *)((signed int)v16 + v11);
  if ( *v12 == 58 )
  {
    *a2 = *v9;
    *v10 = *v8;
    v15 = v16 + 2;
    v13 = v12 + 1;
    v17 = sub_16564(v13);
    if ( (signed int)v17 <= 0 )
      return v17;
    *v9 = (signed __int64)v13;
    *v8 = v17;
    v14 = v17 + v15;
    v12 = &v13[v17];
  }
  if ( *v12 == 91 )
  {
    if ( v7 )
      *v7 = 1;
  }
  return v14;
}

//----- (0000000000017401) ----------------------------------------------------
__int64  sub_17401(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8)
{
  char v9; // ST4F_1
  char **v10; // [rsp+0h] [rbp-50h]
  unsigned int *v11; // [rsp+8h] [rbp-48h]
  char **v12; // [rsp+10h] [rbp-40h]
  unsigned int *v13; // [rsp+18h] [rbp-38h]
  char *s; // [rsp+28h] [rbp-28h]
  char *sa; // [rsp+28h] [rbp-28h]
  char *sb; // [rsp+28h] [rbp-28h]
  char *sc; // [rsp+28h] [rbp-28h]
  int v18; // [rsp+40h] [rbp-10h]
  int v19; // [rsp+40h] [rbp-10h]
  int v20; // [rsp+40h] [rbp-10h]
  int v21; // [rsp+40h] [rbp-10h]
  unsigned int v22; // [rsp+40h] [rbp-10h]
  int v23; // [rsp+44h] [rbp-Ch]
  int v24; // [rsp+44h] [rbp-Ch]
  char *v25; // [rsp+48h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x312u, "parse_predicate");
  if ( a2 )
  {
    if ( !a3 )
      __assert_fail("mod_len", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x314u, "parse_predicate");
    *a2 = 0LL;
    *a3 = 0;
  }
  if ( a4 )
  {
    if ( !a5 )
      __assert_fail("nam_len", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x319u, "parse_predicate");
    *a4 = 0LL;
    *a5 = 0;
  }
  if ( a6 )
  {
    if ( !a7 )
      __assert_fail("val_len", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x31Eu, "parse_predicate");
    *a6 = 0LL;
    *a7 = 0;
  }
  if ( a8 )
    *a8 = 0;
  if ( *a1 != 91 )
    return 0LL;
  v18 = 1;
  for ( s = a1 + 1; (*__ctype_b_loc())[*s] & 0x2000; ++s )
    ++v18;
  if ( (*__ctype_b_loc())[*s] & 0x800 )
  {
    if ( v12 )
      *v12 = s;
    if ( *s == 48 )
      return (unsigned int)-v18;
    while ( (*__ctype_b_loc())[*s] & 0x800 )
    {
      ++v18;
      ++s;
    }
    if ( v11 )
      *v11 = (_DWORD)s - *(_DWORD *)v12;
  }
  else
  {
    if ( *s == 46 )
    {
      if ( v12 )
        *v12 = s;
      if ( v11 )
        *v11 = 1;
      v19 = v18 + 1;
      sa = s + 1;
    }
    else
    {
      v23 = sub_16637(s, a2, v13, v12, v11, 0LL, 0);
      if ( v23 <= 0 )
        return (unsigned int)(v23 - v18);
      v19 = v23 + v18;
      sa = &s[v23];
    }
    while ( (*__ctype_b_loc())[*sa] & 0x2000 )
    {
      ++v19;
      ++sa;
    }
    if ( *sa != 61 )
      return (unsigned int)-v19;
    v20 = v19 + 1;
    for ( sb = sa + 1; (*__ctype_b_loc())[*sb] & 0x2000; ++sb )
      ++v20;
    if ( *sb != 34 && *sb != 39 )
      return (unsigned int)-v20;
    v9 = *sb;
    v21 = v20 + 1;
    sc = sb + 1;
    v25 = strchr(sc, v9);
    if ( !v25 )
      return (unsigned int)-v21;
    v24 = (_DWORD)v25 - (_DWORD)sc;
    if ( v10 )
      *v10 = sc;
    if ( a7 )
      *a7 = v24;
    v18 = v24 + 1 + v21;
    s = &sc[v24 + 1];
  }
  while ( (*__ctype_b_loc())[*s] & 0x2000 )
  {
    ++v18;
    ++s;
  }
  if ( *s != 93 )
    return (unsigned int)-v18;
  v22 = v18 + 1;
  if ( s[1] == 91 )
  {
    if ( a8 )
      *a8 = 1;
  }
  return v22;
}

//----- (0000000000017847) ----------------------------------------------------
__int64  sub_17847(const char *a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, int a9)
{
  unsigned int *v10; // [rsp+8h] [rbp-38h]
  _QWORD *v11; // [rsp+10h] [rbp-30h]
  unsigned int *v12; // [rsp+18h] [rbp-28h]
  char *s1; // [rsp+28h] [rbp-18h]
  signed int v14; // [rsp+38h] [rbp-8h]
  unsigned int v15; // [rsp+38h] [rbp-8h]
  int v16; // [rsp+3Ch] [rbp-4h]

  s1 = (char *)a1;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v14 = 0;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x3B7u, "parse_schema_nodeid");
  if ( !a6 )
    __assert_fail("is_relative", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x3B8u, "parse_schema_nodeid");
  if ( a7 )
    *a7 = 0;
  if ( *a1 == 47 )
  {
    if ( *a6 == -1 )
      *a6 = 0;
    v14 = 1;
    s1 = (char *)(a1 + 1);
  }
  else
  {
    if ( *a6 != -1 )
      return 0LL;
    *a6 = 1;
    if ( !strncmp(a1, "./", 2uLL) )
    {
      v14 = 2;
      s1 = (char *)(a1 + 2);
    }
  }
  v16 = sub_16637(s1, a2, v12, v11, v10, a8, a9);
  if ( v16 <= 0 )
    return (unsigned int)(v16 - v14);
  v15 = v16 + v14;
  if ( s1[v16] == 91 )
  {
    if ( a7 )
      *a7 = 1;
  }
  return v15;
}

//----- (00000000000179A7) ----------------------------------------------------
__int64  sub_179A7(_BYTE *a1, _QWORD *a2, unsigned int *a3, char **a4, unsigned int *a5, char **a6, int *a7, _DWORD *a8)
{
  char v9; // ST4F_1
  char **v10; // [rsp+0h] [rbp-50h]
  unsigned int *v11; // [rsp+8h] [rbp-48h]
  char **v12; // [rsp+10h] [rbp-40h]
  unsigned int *v13; // [rsp+18h] [rbp-38h]
  char *s; // [rsp+28h] [rbp-28h]
  char *sa; // [rsp+28h] [rbp-28h]
  char *sb; // [rsp+28h] [rbp-28h]
  char *sc; // [rsp+28h] [rbp-28h]
  signed int v18; // [rsp+40h] [rbp-10h]
  int v19; // [rsp+40h] [rbp-10h]
  int v20; // [rsp+40h] [rbp-10h]
  int v21; // [rsp+40h] [rbp-10h]
  unsigned int v22; // [rsp+40h] [rbp-10h]
  signed int i; // [rsp+44h] [rbp-Ch]
  int v24; // [rsp+44h] [rbp-Ch]
  char *v25; // [rsp+48h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  if ( !a1 )
    __assert_fail("id", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x3F8u, "parse_schema_json_predicate");
  if ( a2 )
    *a2 = 0LL;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0LL;
  if ( a5 )
    *a5 = 0;
  if ( a6 )
    *a6 = 0LL;
  if ( a7 )
    *a7 = 0;
  if ( a8 )
    *a8 = 0;
  if ( *a1 != 91 )
    return 0LL;
  v18 = 1;
  for ( s = a1 + 1; (*__ctype_b_loc())[*s] & 0x2000; ++s )
    ++v18;
  if ( *s == 46 )
  {
    i = 1;
    if ( v12 )
      *v12 = s;
    if ( v11 )
      *v11 = 1;
  }
  else if ( (*__ctype_b_loc())[*s] & 0x800 )
  {
    if ( *s == 48 )
      return (unsigned int)-v18;
    for ( i = 1; (*__ctype_b_loc())[s[i]] & 0x800; ++i )
      ;
    if ( v12 )
      *v12 = s;
    if ( v11 )
      *v11 = i;
  }
  else
  {
    i = sub_16637(s, a2, v13, v12, v11, 0LL, 0);
    if ( i <= 0 )
      return (unsigned int)(i - v18);
  }
  v19 = i + v18;
  for ( sa = &s[i]; (*__ctype_b_loc())[*sa] & 0x2000; ++sa )
    ++v19;
  if ( *sa == 61 )
  {
    if ( v12 && (*__ctype_b_loc())[**v12] & 0x800 )
      return (unsigned int)-v19;
    v20 = v19 + 1;
    for ( sb = sa + 1; (*__ctype_b_loc())[*sb] & 0x2000; ++sb )
      ++v20;
    if ( *sb != 34 && *sb != 39 )
      return (unsigned int)-v20;
    v9 = *sb;
    v21 = v20 + 1;
    sc = sb + 1;
    v25 = strchr(sc, v9);
    if ( !v25 )
      return (unsigned int)-v21;
    v24 = (_DWORD)v25 - (_DWORD)sc;
    if ( v10 )
      *v10 = sc;
    if ( a7 )
      *a7 = v24;
    v19 = v24 + 1 + v21;
    for ( sa = &sc[v24 + 1]; (*__ctype_b_loc())[*sa] & 0x2000; ++sa )
      ++v19;
  }
  if ( *sa != 93 )
    return (unsigned int)-v19;
  v22 = v19 + 1;
  if ( sa[1] == 91 )
  {
    if ( a8 )
      *a8 = 1;
  }
  return v22;
}

//----- (0000000000017DBA) ----------------------------------------------------
_BOOL4  sub_17DBA(const char **a1, const char ***a2, int a3, __int64 a4)
{
  _BOOL4 result; // rax
  unsigned int v5; // eax
  size_t v6; // r12
  const char *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rbx
  signed int i; // [rsp+24h] [rbp-4Ch]
  const char *v11; // [rsp+28h] [rbp-48h]
  const char **v12; // [rsp+30h] [rbp-40h]
  char *s1; // [rsp+38h] [rbp-38h]
  char *s1a; // [rsp+38h] [rbp-38h]
  const char *v15; // [rsp+40h] [rbp-30h]
  const char *v16; // [rsp+48h] [rbp-28h]
  const char *v17; // [rsp+50h] [rbp-20h]

  if ( a3 )
    __assert_fail("!mod", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x485u, "resolve_hash_table_find_equal");
  v15 = *a1;
  v16 = a1[1];
  v17 = a1[2];
  v12 = *a2;
  if ( **a2 != *a1 )
    return 0LL;
  v5 = *((_DWORD *)*v12 + 14);
  if ( v5 == 8 )
  {
    s1 = (char *)v12[7];
    result = !strncmp(v12[7], *((const char **)v17 + 4), *((signed int *)v17 + 10)) && !s1[*((signed int *)v17 + 10)];
  }
  else
  {
    if ( v5 <= 8 )
    {
      if ( v5 != 1 && v5 != 4 )
        goto LABEL_37;
      return 1LL;
    }
    if ( v5 == 32 || v5 == 32800 )
      return 1LL;
    if ( v5 != 16 )
    {
LABEL_37:
      sub_12222(
        **((_QWORD **)*v12 + 6),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        1221LL,
        a4);
      return 0LL;
    }
    if ( !(*v12)[30] )
      __assert_fail(
        "((struct lys_node_list *)val2->schema)->keys_size",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x49Cu,
        "resolve_hash_table_find_equal");
    if ( *((unsigned __int8 *)*v12 + 30) != (_DWORD)v16 )
      __assert_fail(
        "((struct lys_node_list *)val2->schema)->keys_size == pp.len",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x49Du,
        "resolve_hash_table_find_equal");
    v11 = v12[8];
    for ( i = 0; v11 && i < (signed int)v16; ++i )
    {
      if ( *(_QWORD *)&v17[48 * i] )
      {
        v6 = *(signed int *)&v17[48 * i + 8];
        v7 = *(const char **)&v17[48 * i];
        v8 = lyd_node_module(v11);
        if ( strncmp(*(const char **)(v8 + 8), v7, v6)
          || *(_BYTE *)(*(_QWORD *)(lyd_node_module(v11) + 8) + *(signed int *)&v17[48 * i + 8]) )
        {
          break;
        }
      }
      else
      {
        v9 = lyd_node_module(v11);
        if ( v9 != lys_node_module(v15) )
          break;
      }
      if ( strncmp(**(const char ***)v11, *(const char **)&v17[48 * i + 16], *(signed int *)&v17[48 * i + 24]) )
        break;
      if ( *(_BYTE *)(**(_QWORD **)v11 + *(signed int *)&v17[48 * i + 24]) )
        break;
      s1a = (char *)*((_QWORD *)v11 + 7);
      if ( strncmp(*((const char **)v11 + 7), *(const char **)&v17[48 * i + 32], *(signed int *)&v17[48 * i + 40])
        || s1a[*(signed int *)&v17[48 * i + 40]] )
      {
        break;
      }
      v11 = (const char *)*((_QWORD *)v11 + 3);
    }
    result = i == (_DWORD)v16;
  }
  return result;
}
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (00000000000181E5) ----------------------------------------------------
__int64  sub_181E5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9)
{
  __int64 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11; // rax
  unsigned int v12; // ST10_4
  unsigned __int64 v13; // rax
  unsigned int v14; // ST10_4
  int v15; // eax
  __int64 result; // rax
  unsigned int v17; // [rsp+10h] [rbp-30h]
  int i; // [rsp+14h] [rbp-2Ch]
  int v19; // [rsp+14h] [rbp-2Ch]
  __int64 *v20; // [rsp+18h] [rbp-28h]
  __int64 v21; // [rsp+20h] [rbp-20h]
  unsigned __int64 v22; // [rsp+28h] [rbp-18h]

  v22 = __readfsqword(0x28u);
  v20 = 0LL;
  if ( !a1 || !*(_DWORD *)(a1 + 48) )
    __assert_fail(
      "parent && parent->hash",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x4D1u,
      "resolve_json_data_node_hash");
  v21 = sub_14E64(*(_QWORD *)(a1 + 56), (__int64)sub_17DBA);
  v9 = lys_node_module(a7);
  v10 = strlen(*(const char **)(v9 + 8));
  v11 = lys_node_module(a7);
  v12 = sub_1476E(0, *(_QWORD *)(v11 + 8), v10);
  v13 = strlen(*(const char **)a7);
  v17 = sub_1476E(v12, *(_QWORD *)a7, v13);
  if ( *(_DWORD *)(a7 + 56) == 8 )
  {
    if ( a8 != 1 || **(_BYTE **)(a9 + 16) != 46 || *(_DWORD *)(a9 + 24) != 1 )
      __assert_fail(
        "(pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1)",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x4DAu,
        "resolve_json_data_node_hash");
    v14 = sub_1476E(v17, *(_QWORD *)(a9 + 32), *(signed int *)(a9 + 40));
    v15 = sub_1476E(v14, 0LL, 0LL);
  }
  else
  {
    if ( *(_DWORD *)(a7 + 56) == 16 )
    {
      for ( i = 0; i < a8; ++i )
        v17 = sub_1476E(v17, *(_QWORD *)(a9 + 48LL * i + 32), *(signed int *)(a9 + 48LL * i + 40));
    }
    v15 = sub_1476E(v17, 0LL, 0LL);
  }
  v19 = sub_154F1(*(_QWORD *)(a1 + 56), (__int64)&a7, v15, &v20);
  if ( !v19 && !*v20 )
    __assert_fail(
      "i || *ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x4E7u,
      "resolve_json_data_node_hash");
  sub_14E64(*(_QWORD *)(a1 + 56), v21);
  if ( v19 )
    result = 0LL;
  else
    result = *v20;
  return result;
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000001844C) ----------------------------------------------------
signed __int64  sub_1844C(char *a1, unsigned __int16 a2, __int64 a3, _QWORD *a4)
{
  signed __int64 result; // rax
  int v5; // er12
  char *v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rax
  __int64 v9; // r14
  __int64 v10; // r13
  __int16 v11; // r12
  __int64 v12; // rbx
  void **v13; // rax
  __int64 v14; // r14
  __int64 v15; // r13
  __int16 v16; // r12
  __int64 v17; // rbx
  void **v18; // rax
  __int64 v19; // r14
  __int64 v20; // r13
  __int16 v21; // r12
  __int64 v22; // rbx
  void **v23; // rax
  _QWORD *v24; // [rsp+0h] [rbp-80h]
  __int64 v25; // [rsp+8h] [rbp-78h]
  unsigned int v26; // [rsp+28h] [rbp-58h]
  int v27; // [rsp+2Ch] [rbp-54h]
  int v28; // [rsp+30h] [rbp-50h]
  int i; // [rsp+34h] [rbp-4Ch]
  char *v30; // [rsp+38h] [rbp-48h]
  char *s1; // [rsp+40h] [rbp-40h]
  __int64 v32; // [rsp+48h] [rbp-38h]
  void *ptr; // [rsp+50h] [rbp-30h]
  unsigned __int64 v34; // [rsp+58h] [rbp-28h]

  v25 = a3;
  v24 = a4;
  v34 = __readfsqword(0x28u);
  if ( !a4 )
    __assert_fail("feature", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x504u, "resolve_feature");
  v28 = sub_16637(a1, &v30, &v26, &s1, (unsigned int *)&v27, 0LL, 0);
  if ( v28 > 0 )
  {
    v5 = v26;
    v6 = v30;
    v7 = (__int64 *)lys_node_module(v25);
    v32 = sub_407F3(v7, 0LL, 0, v6, v5, 0);
    if ( v32 )
    {
      if ( v32 != *(_QWORD *)(v25 + 48) )
      {
        v8 = lys_node_module(v25);
        if ( v32 == v8 )
        {
          for ( i = 0; i < *(unsigned __int8 *)(*(_QWORD *)(v25 + 48) + 76LL); ++i )
          {
            if ( !strncmp(
                    s1,
                    *(const char **)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL)),
                    v27)
              && !*(_BYTE *)(*(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL)) + v27) )
            {
              v9 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL));
              v10 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL) + 48);
              v11 = *(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL) + 24);
              v12 = *(_QWORD *)v25;
              v13 = (void **)lys_node_module(v25);
              if ( (unsigned int)sub_3C749(*(_WORD *)(v25 + 24), v13, v12, v11, v10, v9, 0LL) )
                return 0xFFFFFFFFLL;
              *v24 = *(_QWORD *)(*(_QWORD *)(v25 + 48) + 128LL) + ((signed __int64)i << 6);
              return 0LL;
            }
          }
        }
      }
      for ( i = 0; i < *(unsigned __int8 *)(v32 + 76); ++i )
      {
        if ( !strncmp(s1, *(const char **)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128)), v27)
          && !*(_BYTE *)(*(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128)) + v27) )
        {
          v14 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128));
          v15 = *(_QWORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128) + 48);
          v16 = *(_WORD *)(((signed __int64)i << 6) + *(_QWORD *)(v32 + 128) + 24);
          v17 = *(_QWORD *)v25;
          v18 = (void **)lys_node_module(v25);
          if ( (unsigned int)sub_3C749(*(_WORD *)(v25 + 24), v18, v17, v16, v15, v14, 0LL) )
            return 0xFFFFFFFFLL;
          *v24 = *(_QWORD *)(v32 + 128) + ((signed __int64)i << 6);
          return 0LL;
        }
      }
      v28 = 0;
LABEL_35:
      if ( v28 < *(unsigned __int8 *)(v32 + 70) && *(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) )
      {
        for ( i = 0; ; ++i )
        {
          if ( i >= *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 76LL) )
          {
            ++v28;
            goto LABEL_35;
          }
          if ( !strncmp(
                  s1,
                  *(const char **)(((signed __int64)i << 6)
                                 + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL)),
                  v27)
            && !*(_BYTE *)(*(_QWORD *)(((signed __int64)i << 6)
                                     + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL))
                         + v27) )
          {
            break;
          }
        }
        v19 = *(_QWORD *)(((signed __int64)i << 6)
                        + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL));
        v20 = *(_QWORD *)(((signed __int64)i << 6)
                        + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL)
                        + 48);
        v21 = *(_WORD *)(((signed __int64)i << 6)
                       + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL)
                       + 24);
        v22 = *(_QWORD *)v25;
        v23 = (void **)lys_node_module(v25);
        if ( (unsigned int)sub_3C749(*(_WORD *)(v25 + 24), v23, v22, v21, v20, v19, 0LL) )
        {
          result = 0xFFFFFFFFLL;
        }
        else
        {
          *v24 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 104) + 48LL * v28) + 128LL) + ((signed __int64)i << 6);
          result = 0LL;
        }
      }
      else
      {
        ptr = strndup(a1, a2);
        sub_13937(**(void ***)(v25 + 48), 36, 0, 0LL, (__int64)"feature", (__int64)ptr, v24);
        free(ptr);
        result = 1LL;
      }
    }
    else
    {
      sub_13937(**(void ***)(v25 + 48), 29, 0, 0LL, v26, (__int64)v30, v24);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_13937(**(void ***)(v25 + 48), 55, 0, 0LL, (unsigned int)a1[-v28], (__int64)&a1[-v28], v24);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000018B8D) ----------------------------------------------------
__int64  sub_18B8D(__int64 a1)
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a1 + 27); ++i )
  {
    if ( !(unsigned int)sub_18D14(32LL * i + *(_QWORD *)(a1 + 40)) )
      return 0LL;
  }
  return ((signed int)*(unsigned __int16 *)(a1 + 24) >> 8) & 1;
}

//----- (0000000000018BF1) ----------------------------------------------------
__int64  sub_18BF1(__int64 *a1, int *a2, _DWORD *a3)
{
  __int64 v3; // rsi
  int v4; // eax
  __int64 result; // rax
  _DWORD *v6; // [rsp+8h] [rbp-28h]
  unsigned __int8 v7; // [rsp+27h] [rbp-9h]
  int v8; // [rsp+28h] [rbp-8h]
  int v9; // [rsp+2Ch] [rbp-4h]

  v6 = a3;
  v7 = sub_18F95(*a1, *a2);
  ++*a2;
  if ( (signed int)v7 > 2 )
  {
    if ( v7 == 3 )
    {
      v3 = a1[2];
      v4 = (*v6)++;
      return sub_18B8D(*(_QWORD *)(v3 + 8LL * v4));
    }
    return 0LL;
  }
  if ( (signed int)v7 < 1 )
  {
    if ( !v7 )
      return (unsigned int)sub_18BF1(a1, a2, v6) == 0;
    return 0LL;
  }
  v8 = sub_18BF1(a1, a2, v6);
  v9 = sub_18BF1(a1, a2, v6);
  if ( v7 == 1 )
    result = v8 && v9;
  else
    result = v8 || v9;
  return result;
}

//----- (0000000000018D14) ----------------------------------------------------
__int64  sub_18D14(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+10h] [rbp-10h]
  int v3; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v2 = 0;
  v3 = 0;
  if ( *(_QWORD *)a1 && **(_QWORD **)(a1 + 16) )
    result = sub_18BF1((__int64 *)a1, &v2, &v3);
  else
    result = 0LL;
  return result;
}

//----- (0000000000018D8D) ----------------------------------------------------
signed __int64  sub_18D8D(signed int *a1, char a2)
{
  __int64 v2; // r9
  signed __int64 result; // rax
  __int64 v4; // rsi
  signed int v5; // eax
  char v6; // [rsp+4h] [rbp-Ch]

  v6 = a2;
  if ( a1[1] != *a1 || (*a1 += 4, (*((_QWORD *)a1 + 1) = sub_C422(*((void **)a1 + 1), *a1)) != 0LL) )
  {
    v4 = *((_QWORD *)a1 + 1);
    v5 = a1[1];
    a1[1] = v5 + 1;
    *(_BYTE *)(v4 + v5) = v6;
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"iff_stack_push", v2);
    *a1 = 0;
    result = 1LL;
  }
  return result;
}

//----- (0000000000018E56) ----------------------------------------------------
__int64  sub_18E56(__int64 a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + (signed int)--*(_DWORD *)(a1 + 4));
}

//----- (0000000000018E88) ----------------------------------------------------
void  sub_18E88(__int64 a1)
{
  *(_DWORD *)a1 = 0;
  free(*(void **)(a1 + 8));
}

//----- (0000000000018EB1) ----------------------------------------------------
__int64  sub_18EB1(__int64 a1, unsigned __int8 a2, int a3)
{
  _BYTE *v3; // ST18_8
  __int64 result; // rax

  if ( a3 < 0 )
    __assert_fail("pos >= 0", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5AAu, "iff_setop");
  if ( a2 > 3u )
    __assert_fail("op <= 3", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5ABu, "iff_setop");
  v3 = (_BYTE *)(a3 / 4 + a1);
  *v3 &= ~(unsigned __int8)(3 << 2 * ((char)a3 % 4));
  result = a3 / 4 + a1;
  *v3 |= a2 << 2 * (a3 % 4);
  return result;
}

//----- (0000000000018F95) ----------------------------------------------------
__int64  sub_18F95(__int64 a1, int a2)
{
  if ( a2 < 0 )
    __assert_fail("pos >= 0", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5B9u, "iff_getop");
  return (signed int)(unsigned __int8)(*(_BYTE *)(a2 / 4 + a1) & (3 << 2 * ((char)a2 % 4))) >> 2 * (a2 % 4);
}

//----- (000000000001902D) ----------------------------------------------------
__int64  sub_1902D(__int64 *a1, int *a2, _DWORD *a3)
{
  __int64 result; // rax
  int v4; // eax
  _DWORD *v5; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+24h] [rbp-Ch]
  int v7; // [rsp+28h] [rbp-8h]
  signed int v8; // [rsp+2Ch] [rbp-4h]

  v5 = a3;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( !a1 )
    __assert_fail("iffeat", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x5D0u, "resolve_iffeature_getsizes");
  result = *a1;
  if ( *a1 )
  {
    do
    {
      v4 = v6++;
      result = (unsigned __int8)sub_18F95(*a1, v4);
      if ( (signed int)result > 2 )
      {
        if ( (_DWORD)result == 3 )
        {
          ++v7;
          if ( v8 )
            --v8;
        }
      }
      else if ( (signed int)result >= 1 )
      {
        if ( v8 )
          ++v8;
        else
          v8 = 2;
      }
      else if ( !(_DWORD)result && !v8 )
      {
        v8 = 1;
      }
    }
    while ( v8 );
  }
  if ( a2 )
  {
    result = (__int64)a2;
    *a2 = v6;
  }
  if ( v5 )
  {
    result = (__int64)v5;
    *v5 = v7;
  }
  return result;
}

//----- (0000000000019120) ----------------------------------------------------
signed __int64  sub_19120(__int64 *a1, char *a2, __int64 a3, int a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  int v8; // eax
  unsigned __int8 v9; // ST33_1
  int v10; // eax
  unsigned __int8 v11; // ST33_1
  int v12; // eax
  int v13; // eax
  __int64 v14; // r9
  int v15; // ST34_4
  unsigned __int8 v16; // ST33_1
  int v17; // eax
  __int64 v18; // [rsp+8h] [rbp-88h]
  int v19; // [rsp+14h] [rbp-7Ch]
  __int64 v20; // [rsp+18h] [rbp-78h]
  unsigned __int8 v21; // [rsp+33h] [rbp-5Dh]
  signed int v22; // [rsp+34h] [rbp-5Ch]
  unsigned int v23; // [rsp+38h] [rbp-58h]
  int i; // [rsp+3Ch] [rbp-54h]
  int j; // [rsp+3Ch] [rbp-54h]
  int v26; // [rsp+40h] [rbp-50h]
  int v27; // [rsp+40h] [rbp-50h]
  signed int v28; // [rsp+44h] [rbp-4Ch]
  signed int v29; // [rsp+48h] [rbp-48h]
  size_t nmemb; // [rsp+4Ch] [rbp-44h]
  unsigned int nmemba; // [rsp+4Ch] [rbp-44h]
  int nmemb_4; // [rsp+50h] [rbp-40h]
  signed int v33; // [rsp+54h] [rbp-3Ch]
  void *v34; // [rsp+60h] [rbp-30h]
  _QWORD *ptr; // [rsp+68h] [rbp-28h]
  int v36; // [rsp+70h] [rbp-20h]
  int v37; // [rsp+74h] [rbp-1Ch]
  _BYTE *v38; // [rsp+78h] [rbp-18h]
  unsigned __int64 v39; // [rsp+88h] [rbp-8h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v39 = __readfsqword(0x28u);
  v23 = 1;
  v29 = 0;
  nmemb = 0LL;
  v33 = 1;
  v36 = 0;
  v37 = 0;
  v38 = 0LL;
  v34 = **(void ***)(a3 + 48);
  if ( !a2 )
    __assert_fail("c", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x605u, "resolve_iffeature_compile");
  if ( (*__ctype_b_loc())[*a2] & 0x2000 )
  {
    sub_13937(v34, 55, 0, 0LL, (unsigned int)*a2, (__int64)a2);
    result = 1LL;
  }
  else
  {
    v28 = 0;
    v26 = 0;
    for ( i = 0; a2[i]; ++i )
    {
      if ( a2[i] == 40 )
      {
        v29 = 1;
        ++v26;
      }
      else if ( a2[i] == 41 )
      {
        --v26;
      }
      else if ( !((*__ctype_b_loc())[a2[i]] & 0x2000) )
      {
        v22 = 3;
        if ( !strncmp(&a2[i], "not", 3uLL)
          || (v22 = 3, !strncmp(&a2[i], "and", 3uLL))
          || (v22 = 2, !strncmp(&a2[i], "or", 2uLL)) )
        {
          if ( !a2[i + v22] )
          {
            sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
            return 1LL;
          }
          if ( (*__ctype_b_loc())[a2[i + v22]] & 0x2000 )
          {
            if ( a2[i] == 110 )
            {
              if ( v28 )
              {
                HIDWORD(nmemb) -= 2;
                v28 = 0;
              }
              else
              {
                v28 = 1;
              }
            }
            else
            {
              ++v33;
              v28 = 0;
            }
          }
          else
          {
            v28 = 0;
            LODWORD(nmemb) = nmemb + 1;
          }
          i += v22;
        }
        else
        {
          LODWORD(nmemb) = nmemb + 1;
          v28 = 0;
        }
        ++HIDWORD(nmemb);
        while ( !((*__ctype_b_loc())[a2[i]] & 0x2000) )
        {
          if ( a2[i] == 40 )
          {
            sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
            return 1LL;
          }
          if ( !a2[i] || a2[i] == 41 )
          {
            --i;
            break;
          }
          ++i;
        }
      }
    }
    if ( v26 || v33 != (_DWORD)nmemb )
    {
      sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
      result = 1LL;
    }
    else if ( (v29 || HIDWORD(nmemb) > 1) && (*(_BYTE *)(*(_QWORD *)(v20 + 48) + 64LL) & 0xE) != 4 )
    {
      sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
      sub_13937(v34, -1, 0, 0LL, (__int64)"YANG 1.1 if-feature expression found in 1.0 module.", v6);
      result = 1LL;
    }
    else
    {
      *a1 = (__int64)calloc((HIDWORD(nmemb) >> 2) + ((nmemb & 0x300000000LL) != 0), 1uLL);
      a1[2] = (__int64)calloc((unsigned int)nmemb, 8uLL);
      v38 = malloc(HIDWORD(nmemb));
      if ( v38 && *a1 && a1[2] )
      {
        v36 = HIDWORD(nmemb);
        LODWORD(nmemb) = nmemb - 1;
        nmemb_4 = HIDWORD(nmemb) - 1;
        for ( j = i - 1; j >= 0; --j )
        {
          if ( a2[j] == 41 )
          {
            sub_18D8D(&v36, 8);
          }
          else if ( a2[j] == 40 )
          {
            while ( 1 )
            {
              v21 = sub_18E56((__int64)&v36);
              if ( v21 == 8 )
                break;
              v8 = nmemb_4--;
              sub_18EB1(*a1, v21, v8);
            }
          }
          else if ( !((*__ctype_b_loc())[a2[j]] & 0x2000) )
          {
            v27 = j + 1;
            while ( j >= 0 && !((*__ctype_b_loc())[a2[j]] & 0x2000) && a2[j] != 40 )
              --j;
            if ( !strncmp(&a2[++j], "not", 3uLL) && (*__ctype_b_loc())[a2[j + 3]] & 0x2000 )
            {
              if ( !v37 || v38[v37 - 1] )
                sub_18D8D(&v36, 0);
              else
                sub_18E56((__int64)&v36);
            }
            else if ( !strncmp(&a2[j], "and", 3uLL) && (*__ctype_b_loc())[a2[j + 3]] & 0x2000 )
            {
              while ( v37 && v38[v37 - 1] <= 1u )
              {
                v9 = sub_18E56((__int64)&v36);
                v10 = nmemb_4--;
                sub_18EB1(*a1, v9, v10);
              }
              sub_18D8D(&v36, 1);
            }
            else if ( !strncmp(&a2[j], "or", 2uLL) && (*__ctype_b_loc())[a2[j + 2]] & 0x2000 )
            {
              while ( v37 && v38[v37 - 1] <= 2u )
              {
                v11 = sub_18E56((__int64)&v36);
                v12 = nmemb_4--;
                sub_18EB1(*a1, v11, v12);
              }
              sub_18D8D(&v36, 2);
            }
            else
            {
              v13 = nmemb_4--;
              sub_18EB1(*a1, 3u, v13);
              ptr = malloc(0x18uLL);
              if ( !ptr )
              {
                sub_12222(
                  (__int64)v34,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"resolve_iffeature_compile",
                  v14);
                goto LABEL_93;
              }
              *ptr = v20;
              ptr[1] = lydict_insert(**(_QWORD **)(v20 + 48), &a2[j], v27 - j);
              *((_DWORD *)ptr + 4) = v19;
              v15 = sub_2ABDE(*(__int64 **)(v20 + 48), v18, (__int64 *)(a1[2] + 8LL * nmemba--), 2u, ptr);
              if ( v15 == -1 )
              {
                lydict_remove(**(_QWORD **)(v20 + 48), ptr[1]);
                free(ptr);
                goto LABEL_93;
              }
            }
          }
        }
        while ( v37 )
        {
          v16 = sub_18E56((__int64)&v36);
          v17 = nmemb_4--;
          sub_18EB1(*a1, v16, v17);
        }
        if ( nmemb_4 == -1 && nmemba == -1 )
        {
          v23 = 0;
        }
        else
        {
          sub_13937(v34, 10, 0, 0LL, (__int64)a2, (__int64)"if-feature");
          v23 = 1;
        }
      }
      else
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_iffeature_compile", v7);
      }
LABEL_93:
      sub_18E88((__int64)&v36);
      result = v23;
    }
  }
  return result;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000019BA2) ----------------------------------------------------
__int64 * sub_19BA2(const char *a1, __int64 *a2)
{
  __int64 v3; // r9
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 *v6; // rax
  __int64 v7; // [rsp+18h] [rbp-38h]
  char *v8; // [rsp+20h] [rbp-30h]
  __int64 *v9; // [rsp+28h] [rbp-28h]
  __int64 *i; // [rsp+30h] [rbp-20h]
  void *ptr; // [rsp+38h] [rbp-18h]
  char *v12; // [rsp+40h] [rbp-10h]
  unsigned __int64 v13; // [rsp+48h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = 0LL;
  v7 = 0LL;
  if ( !a1 || !a2 )
    __assert_fail(
      "nodeid && start",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x6BFu,
      "resolve_data_descendant_schema_nodeid");
  if ( *a1 == 47 )
    return 0LL;
  v8 = strdup(a1);
  ptr = v8;
  if ( !v8 )
  {
    sub_12222(
      **(_QWORD **)(*a2 + 48),
      0,
      1,
      "Memory allocation failed (%s()).",
      (__int64)"resolve_data_descendant_schema_nodeid",
      v3,
      a2);
    return 0LL;
  }
  while ( v8 )
  {
    v12 = v8;
    v8 = strchr(v8, 47);
    if ( v8 )
      *v8++ = 0;
    if ( !v8 )
    {
      if ( v7 )
        v5 = *(_QWORD *)(v7 + 72);
      else
        v5 = *a2;
      if ( (unsigned int)sub_1AF63(v12, v5, 4, 0, &v7) || !v7 )
      {
        v9 = 0LL;
        break;
      }
      goto LABEL_25;
    }
    if ( v7 )
      v4 = *(_QWORD *)(v7 + 72);
    else
      v4 = *a2;
    if ( (unsigned int)sub_1AF63(v12, v4, 71, 0, &v7) || !v7 )
    {
      v9 = 0LL;
      break;
    }
    if ( !(*(_DWORD *)(v7 + 56) & 0x42) )
    {
LABEL_25:
      if ( v9 )
        v6 = (__int64 *)v9[8];
      else
        v6 = a2;
      for ( i = v6; i; i = (__int64 *)i[3] )
      {
        if ( *i == v7 )
        {
          v9 = i;
          break;
        }
      }
      if ( !i )
      {
        v9 = 0LL;
        break;
      }
    }
  }
  free(ptr);
  return v9;
}

//----- (0000000000019DE6) ----------------------------------------------------
signed __int64  sub_19DE6(const char **a1, __int64 *a2, char *a3, int a4, const char *a5, int a6)
{
  int v7; // [rsp+10h] [rbp-30h]
  int v8; // [rsp+14h] [rbp-2Ch]
  char *v9; // [rsp+18h] [rbp-28h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a6;
  if ( *a5 == 42 )
    return 2LL;
  if ( *a5 == 46 )
    return 3LL;
  if ( strncmp(a5, *a1, a6) || (*a1)[v7] )
    return 1LL;
  if ( v9 )
  {
    v10 = sub_407F3(a2, 0LL, 0, v9, v8, 0);
    if ( !v10 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v10 = (__int64)a2;
  }
  return v10 != lys_node_module(a1);
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000019ED6) ----------------------------------------------------
signed __int64  sub_19ED6(_BYTE *a1, __int64 a2, void **a3, _DWORD *a4)
{
  size_t v5; // r12
  char *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rax
  _DWORD *v9; // [rsp+0h] [rbp-70h]
  void **v10; // [rsp+8h] [rbp-68h]
  _BYTE *v11; // [rsp+18h] [rbp-58h]
  int v12; // [rsp+2Ch] [rbp-44h]
  int v13; // [rsp+30h] [rbp-40h]
  int v14; // [rsp+34h] [rbp-3Ch]
  int i; // [rsp+38h] [rbp-38h]
  int v16; // [rsp+3Ch] [rbp-34h]
  char *v17; // [rsp+40h] [rbp-30h]
  char *s2; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  unsigned __int64 v20; // [rsp+58h] [rbp-18h]

  v11 = a1;
  v10 = a3;
  v9 = a4;
  v20 = __readfsqword(0x28u);
  if ( !(*(_DWORD *)(a2 + 56) & 0x18) )
    return 1LL;
  v19 = a2;
  while ( 1 )
  {
    v16 = sub_179A7(v11, &v17, (unsigned int *)&v12, &s2, (unsigned int *)&v13, 0LL, 0LL, &v14);
    if ( v16 <= 0 )
    {
      sub_13937(*v10, 78, 0, 0LL, (unsigned int)(char)v11[v16], (__int64)&v11[v16], v9);
      return 0xFFFFFFFFLL;
    }
    v11 += v16;
    if ( *(_DWORD *)(a2 + 56) == 8 )
      break;
    for ( i = 0; i < *(unsigned __int8 *)(v19 + 30); ++i )
    {
      if ( !strncmp(**(const char ***)(8LL * i + *(_QWORD *)(v19 + 136)), s2, v13)
        && !*(_BYTE *)(**(_QWORD **)(8LL * i + *(_QWORD *)(v19 + 136)) + v13) )
      {
        if ( v17 )
        {
          v5 = v12;
          v6 = v17;
          v7 = lys_node_module(*(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 136)));
          if ( !strncmp(*(const char **)(v7 + 8), v6, v5) )
          {
            v8 = lys_node_module(*(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 136)));
            if ( !*(_BYTE *)(*(_QWORD *)(v8 + 8) + v12) )
              break;
          }
        }
        else if ( v10 == (void **)lys_node_module(*(_QWORD *)(8LL * i + *(_QWORD *)(v19 + 136))) )
        {
          break;
        }
      }
    }
    if ( i == *(unsigned __int8 *)(v19 + 30) )
      return 1LL;
    if ( !v14 )
      goto LABEL_25;
  }
  if ( v17 || !s2 || *s2 != 46 || v14 )
    return 1LL;
LABEL_25:
  if ( !*v11 )
    *v9 = 1;
  return 0LL;
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000001A193) ----------------------------------------------------
signed __int64  sub_1A193(char *a1, __int64 a2, __int64 a3, _QWORD *a4, int a5, int a6)
{
  signed __int64 result; // rax
  int *v7; // rax
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  int v13; // eax
  __int64 v14; // r8
  __int64 v15; // r9
  char *v16; // rdi
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 v19; // rbx
  __int64 v20; // r9
  __int64 v21; // rbx
  __int64 v22; // rax
  __int64 v23; // r8
  __int64 v24; // r9
  int *v25; // rax
  int v26; // [rsp+8h] [rbp-D8h]
  int v27; // [rsp+Ch] [rbp-D4h]
  _QWORD *v28; // [rsp+10h] [rbp-D0h]
  __int64 v29; // [rsp+18h] [rbp-C8h]
  __int64 v30; // [rsp+20h] [rbp-C0h]
  char *v31; // [rsp+28h] [rbp-B8h]
  int v32; // [rsp+3Ch] [rbp-A4h]
  int v33; // [rsp+40h] [rbp-A0h]
  int v34; // [rsp+44h] [rbp-9Ch]
  int v35; // [rsp+48h] [rbp-98h]
  int v36; // [rsp+4Ch] [rbp-94h]
  int v37; // [rsp+50h] [rbp-90h]
  int v38; // [rsp+54h] [rbp-8Ch]
  int v39; // [rsp+58h] [rbp-88h]
  int v40; // [rsp+5Ch] [rbp-84h]
  const char *v41; // [rsp+60h] [rbp-80h]
  char *string; // [rsp+68h] [rbp-78h]
  char *s; // [rsp+70h] [rbp-70h]
  char *v44; // [rsp+78h] [rbp-68h]
  const char *v45; // [rsp+80h] [rbp-60h]
  __int64 v46; // [rsp+88h] [rbp-58h]
  __int64 v47; // [rsp+90h] [rbp-50h]
  __int64 i; // [rsp+98h] [rbp-48h]
  __int64 v49; // [rsp+A0h] [rbp-40h]
  __int64 v50; // [rsp+A8h] [rbp-38h]
  __int64 v51; // [rsp+B0h] [rbp-30h]
  void *v52; // [rsp+B8h] [rbp-28h]
  void *ptr; // [rsp+C0h] [rbp-20h]
  unsigned __int64 v54; // [rsp+C8h] [rbp-18h]

  v31 = a1;
  v30 = a2;
  v29 = a3;
  v28 = a4;
  v27 = a5;
  v26 = a6;
  v54 = __readfsqword(0x28u);
  v44 = 0LL;
  v45 = 0LL;
  v33 = 0;
  v34 = -1;
  v37 = 0;
  v40 = 0;
  v51 = 0LL;
  if ( !a1 || !a2 && !a3 || !a4 )
    __assert_fail(
      "nodeid && (start_parent || cur_module) && ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x766u,
      "resolve_schema_nodeid");
  *a4 = 0LL;
  if ( !a3 )
    v29 = lys_node_module(a2);
  v52 = *(void **)v29;
  s = a1;
  v38 = sub_17847(a1, &string, (unsigned int *)&v33, &v41, (unsigned int *)&v32, &v34, 0LL, 0LL, 1);
  if ( v38 <= 0 )
  {
    sub_13937(v52, 78, 0, 0LL, (unsigned int)s[-v38], (__int64)&s[-v38]);
    return 0xFFFFFFFFLL;
  }
  if ( *v41 == 35 )
  {
    if ( v34 )
    {
      sub_13937(v52, 78, 0, 0LL, 35LL, (__int64)v41);
      return 0xFFFFFFFFLL;
    }
    v45 = v41 + 1;
    v39 = v32 - 1;
    v44 = string;
    v40 = v33;
    s += v38;
  }
  else
  {
    v34 = -1;
  }
  if ( v27 )
    v7 = &v35;
  else
    v7 = 0LL;
  v38 = sub_17847(s, &string, (unsigned int *)&v33, &v41, (unsigned int *)&v32, &v34, &v36, v7, v27);
  if ( v38 <= 0 )
  {
    sub_13937(v52, 78, 0, 0LL, (unsigned int)s[-v38], (__int64)&s[-v38]);
    return 0xFFFFFFFFLL;
  }
  s += v38;
  if ( v44 )
  {
    string = v44;
    v33 = v40;
  }
  if ( v34 && !a2 )
  {
    sub_13937(v52, -1, 4u, a1, (__int64)"Starting node must be provided for relative paths.", v8);
    return 0xFFFFFFFFLL;
  }
  if ( v34 )
  {
    v50 = lys_node_module(a2);
    v29 = v50;
  }
  else
  {
    v50 = sub_407F3((__int64 *)v29, 0LL, 0, string, v33, 0);
    if ( !v50 )
    {
      ptr = strndup(string, v33);
      sub_13937(v52, 79, 4u, (char *)ptr, v9, v10);
      free(ptr);
      return 0xFFFFFFFFLL;
    }
    v30 = 0LL;
    if ( v45 )
    {
      v30 = sub_40D5F(v50, v45, v39);
      if ( !v30 )
      {
        ptr = strndup(a1, &v45[v39] - a1);
        sub_13937(v52, 81, 4u, (char *)ptr, v11, v12);
        free(ptr);
        return 0xFFFFFFFFLL;
      }
    }
  }
  while ( 2 )
  {
    v46 = 0LL;
    v49 = 0LL;
    if ( !v30 )
      goto LABEL_111;
    if ( !string
      || !strncmp(string, *(const char **)(v29 + 8), v33) && (v13 = strlen(*(const char **)(v29 + 8)), v13 == v33) )
    {
      v51 = v29;
    }
    else
    {
      v51 = sub_407F3((__int64 *)v29, 0LL, 0, string, v33, 0);
      if ( !v51 )
      {
        ptr = strndup(string, v33);
        sub_13937(v52, 79, 4u, (char *)ptr, v14, v15);
        free(ptr);
        return 0xFFFFFFFFLL;
      }
    }
    if ( v27 )
      goto LABEL_111;
    while ( 2 )
    {
      v49 = sub_AA881(v49, v51, v30);
LABEL_111:
      while ( 1 )
      {
        v22 = v49 ? v49 : v30;
        v46 = lys_getnext(v46, v22, v50, 395LL);
        if ( !v46 )
          break;
        v16 = (char *)v46;
        v38 = sub_19DE6((const char **)v46, (__int64 *)v29, string, v33, v41, v32);
        if ( !v27 || v38 && v38 != 2 && v38 != 3 || !v36 )
        {
          if ( !*s )
            v37 = 1;
          goto LABEL_51;
        }
        v16 = s;
        v38 = sub_19ED6(s, v46, (void **)v29, &v37);
        if ( v38 != 1 )
        {
          if ( v38 == -1 )
            return 0xFFFFFFFFLL;
LABEL_51:
          if ( !v38 )
          {
            if ( v37 )
            {
              *v28 = ly_set_new(v16);
              if ( !*v28 )
              {
                sub_12222((__int64)v52, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_schema_nodeid", v17);
                return 0xFFFFFFFFLL;
              }
              ly_set_add(*v28, v46, 1LL);
            }
            else
            {
              if ( *(_DWORD *)(v46 + 56) & 0x802C )
                return 0xFFFFFFFFLL;
              v30 = v46;
            }
            break;
          }
          if ( v38 != 1 )
          {
            if ( v38 == 2 )
            {
              if ( !*v28 )
              {
                *v28 = ly_set_new(v16);
                if ( !*v28 )
                {
                  sub_12222(
                    (__int64)v52,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"resolve_schema_nodeid",
                    v18);
                  return 0xFFFFFFFFLL;
                }
              }
              ly_set_add(*v28, v46, 1LL);
              if ( v35 )
              {
                v47 = v46;
                for ( i = v46; i; i = v47 )
                {
                  if ( i != v46 )
                    ly_set_add(*v28, i, 1LL);
                  if ( *(_DWORD *)(i + 56) & 0x802C )
                    v47 = 0LL;
                  else
                    v47 = *(_QWORD *)(i + 72);
                  if ( !v47 )
                  {
                    if ( i == v46 )
                      goto LABEL_111;
                    v47 = *(_QWORD *)(i + 80);
                  }
                  while ( !v47 )
                  {
                    i = *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(i + 64) + 88LL) : *(_QWORD *)(i + 64);
                    v19 = lys_parent(i);
                    if ( v19 == lys_parent(v46) )
                      break;
                    v47 = *(_QWORD *)(i + 80);
                  }
                }
              }
            }
            else
            {
              if ( v38 != 3 )
              {
                sub_12222(
                  (__int64)v52,
                  0,
                  4,
                  "Internal error (%s:%d).",
                  (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
                  2062LL);
                return 0xFFFFFFFFLL;
              }
              if ( !*v28 )
              {
                *v28 = ly_set_new(v16);
                if ( !*v28 )
                {
                  sub_12222(
                    (__int64)v52,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"resolve_schema_nodeid",
                    v20);
                  return 0xFFFFFFFFLL;
                }
                if ( v30 )
                  ly_set_add(*v28, v30, 1LL);
              }
              ly_set_add(*v28, v46, 1LL);
              if ( v35 )
              {
                v47 = v46;
                for ( i = v46; i; i = v47 )
                {
                  if ( i != v46 )
                    ly_set_add(*v28, i, 1LL);
                  if ( *(_DWORD *)(i + 56) & 0x802C )
                    v47 = 0LL;
                  else
                    v47 = *(_QWORD *)(i + 72);
                  if ( !v47 )
                  {
                    if ( i == v46 )
                      goto LABEL_111;
                    v47 = *(_QWORD *)(i + 80);
                  }
                  while ( !v47 )
                  {
                    i = *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 ? *(_QWORD *)(*(_QWORD *)(i + 64) + 88LL) : *(_QWORD *)(i + 64);
                    v21 = lys_parent(i);
                    if ( v21 == lys_parent(v46) )
                      break;
                    v47 = *(_QWORD *)(i + 80);
                  }
                }
              }
            }
          }
        }
      }
      if ( v27 && v36 )
      {
        while ( *s == 91 )
        {
          s = strchr(s, 93);
          if ( !s )
          {
            sub_12222(
              (__int64)v52,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              2072LL);
            return 0xFFFFFFFFLL;
          }
          ++s;
        }
      }
      if ( v37 && (!v38 || v38 == 2 || v38 == 3) )
        return 0LL;
      if ( !v46 )
      {
        if ( !v49 )
        {
          if ( v26 )
          {
            ptr = strndup(v31, v41 - v31 + v32);
            sub_13937(v52, 81, 4u, (char *)ptr, v23, v24);
            free(ptr);
            result = 0xFFFFFFFFLL;
          }
          else
          {
            *v28 = 0LL;
            result = 0LL;
          }
          return result;
        }
        continue;
      }
      break;
    }
    if ( v27 )
      v25 = &v35;
    else
      v25 = 0LL;
    v38 = sub_17847(s, &string, (unsigned int *)&v33, &v41, (unsigned int *)&v32, &v34, &v36, v25, v27);
    if ( v38 > 0 )
    {
      s += v38;
      continue;
    }
    break;
  }
  sub_13937(v52, 78, 0, 0LL, (unsigned int)s[-v38], (__int64)&s[-v38]);
  return 0xFFFFFFFFLL;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000001AF63) ----------------------------------------------------
signed __int64  sub_1AF63(const char *a1, __int64 a2, int a3, int a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-70h]
  int v7; // [rsp+8h] [rbp-68h]
  int v8; // [rsp+Ch] [rbp-64h]
  int v9; // [rsp+28h] [rbp-48h]
  int v10; // [rsp+2Ch] [rbp-44h]
  int v11; // [rsp+30h] [rbp-40h]
  int v12; // [rsp+34h] [rbp-3Ch]
  const char *v13; // [rsp+38h] [rbp-38h]
  char *v14; // [rsp+40h] [rbp-30h]
  const char *v15; // [rsp+48h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp-20h]
  __int64 i; // [rsp+58h] [rbp-18h]
  __int64 *v18; // [rsp+60h] [rbp-10h]
  unsigned __int64 v19; // [rsp+68h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v19 = __readfsqword(0x28u);
  v11 = -1;
  if ( !a1 || !a5 )
    __assert_fail(
      "nodeid && ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x850u,
      "resolve_descendant_schema_nodeid");
  if ( a3 & 0x3800 )
    __assert_fail(
      "!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x851u,
      "resolve_descendant_schema_nodeid");
  if ( !a2 )
    return 0LL;
  v15 = a1;
  v18 = (__int64 *)lys_node_module(a2);
  v12 = sub_17847(a1, &v14, (unsigned int *)&v10, &v13, (unsigned int *)&v9, &v11, 0LL, 0LL, 0);
  if ( v12 <= 0 )
    return (unsigned int)((_DWORD)v15 - (_DWORD)a1 - v12 + 1);
  v15 += v12;
  if ( !v11 )
    return 0xFFFFFFFFLL;
  for ( i = lys_parent(a2); *(_DWORD *)(i + 56) == 4096 && lys_parent(i); i = lys_parent(i) )
    ;
  while ( 1 )
  {
    v16 = 0LL;
    while ( 1 )
    {
      v16 = lys_getnext(v16, i, v18, 387LL);
      if ( !v16 )
        break;
      v12 = sub_19DE6((const char **)v16, v18, v14, v10, v13, v9);
      if ( v12 )
      {
        if ( v12 != 1 )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( *v15 )
        {
          i = v16;
          break;
        }
        if ( *(_DWORD *)(v16 + 56) & v8 )
        {
          *v6 = v16;
          return 0LL;
        }
      }
    }
    if ( !v16 )
    {
      *v6 = 0LL;
      return 0LL;
    }
    if ( v7 && *(_DWORD *)(v16 + 56) == 16 )
    {
      *v6 = 0LL;
      return 4294967294LL;
    }
    v12 = sub_17847(v15, &v14, (unsigned int *)&v10, &v13, (unsigned int *)&v9, &v11, 0LL, 0LL, 0);
    if ( v12 <= 0 )
      return (unsigned int)((_DWORD)v15 - (_DWORD)a1 - v12 + 1);
    v15 += v12;
  }
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000001B236) ----------------------------------------------------
signed __int64  sub_1B236(const char *a1, __int64 a2, _QWORD *a3)
{
  signed __int64 result; // rax
  _QWORD *v4; // [rsp+8h] [rbp-18h]

  v4 = a3;
  if ( strchr(a1, 47) )
    result = 0xFFFFFFFFLL;
  else
    result = sub_1AF63(a1, a2, 32895, 0, v4);
  return result;
}

//----- (000000000001B28A) ----------------------------------------------------
signed __int64  sub_1B28A(_BYTE *a1, __int64 a2, __int64 *a3)
{
  __int64 v4; // rax
  __int64 *v5; // [rsp+10h] [rbp-48h]
  __int64 v6; // [rsp+18h] [rbp-40h]
  int v7; // [rsp+2Ch] [rbp-2Ch]
  char v8; // [rsp+30h] [rbp-28h]
  int v9; // [rsp+34h] [rbp-24h]
  const char *v10; // [rsp+38h] [rbp-20h]
  const char *v11; // [rsp+40h] [rbp-18h]
  __int64 v12; // [rsp+48h] [rbp-10h]
  unsigned __int64 v13; // [rsp+50h] [rbp-8h]

  v6 = a2;
  v5 = a3;
  v13 = __readfsqword(0x28u);
  v9 = sub_16637(a1, &v10, (unsigned int *)&v7, &v11, (unsigned int *)&v8, 0LL, 0);
  if ( v9 <= 0 || a1[v9] )
    return (unsigned int)(1 - v9);
  v12 = sub_407F3(*(__int64 **)(a2 + 48), v10, v7, 0LL, 0, 0);
  if ( !v12 )
    return 0xFFFFFFFFLL;
  v4 = lys_main_module(*(_QWORD *)(a2 + 48));
  if ( v12 != v4 )
    v6 = *(_QWORD *)(v12 + 168);
  *v5 = sub_9BDFE(v11, v6);
  return 0LL;
}
// 7950: using guessed type __int64  lys_main_module(_QWORD);

//----- (000000000001B39D) ----------------------------------------------------
signed __int64  sub_1B39D(const char *a1, __int64 *a2, int a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-70h]
  int v6; // [rsp+Ch] [rbp-64h]
  int v7; // [rsp+28h] [rbp-48h]
  int v8; // [rsp+2Ch] [rbp-44h]
  int v9; // [rsp+30h] [rbp-40h]
  int v10; // [rsp+34h] [rbp-3Ch]
  const char *v11; // [rsp+38h] [rbp-38h]
  char *v12; // [rsp+40h] [rbp-30h]
  const char *v13; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  __int64 v16; // [rsp+60h] [rbp-10h]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v17 = __readfsqword(0x28u);
  v9 = -1;
  if ( !a1 || !a2 || !a4 )
    __assert_fail(
      "nodeid && module && ret",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x8C3u,
      "resolve_absolute_schema_nodeid");
  if ( a3 & 0x3000 || a3 != 2048 && a3 & 0x800 )
    __assert_fail(
      "!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x8C4u,
      "resolve_absolute_schema_nodeid");
  v13 = a1;
  v15 = 0LL;
  v10 = sub_17847(a1, &v12, (unsigned int *)&v8, &v11, (unsigned int *)&v7, &v9, 0LL, 0LL, 0);
  if ( v10 <= 0 )
    return (unsigned int)((_DWORD)v13 - (_DWORD)a1 - v10 + 1);
  v13 += v10;
  if ( v9 )
    return 0xFFFFFFFFLL;
  v16 = sub_407F3(a2, 0LL, 0, v12, v8, 0);
  if ( !v16 )
    return 0xFFFFFFFFLL;
  while ( 1 )
  {
    v14 = 0LL;
    while ( 1 )
    {
      v14 = lys_getnext(v14, v15, v16, 271LL);
      if ( !v14 )
        break;
      v10 = sub_19DE6((const char **)v14, a2, v12, v8, v11, v7);
      if ( v10 )
      {
        if ( v10 != 1 )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( *v13 )
        {
          v15 = v14;
          break;
        }
        if ( *(_DWORD *)(v14 + 56) & v6 )
        {
          *v5 = v14;
          return 0LL;
        }
      }
    }
    if ( !v14 )
    {
      *v5 = 0LL;
      return 0LL;
    }
    v10 = sub_17847(v13, &v12, (unsigned int *)&v8, &v11, (unsigned int *)&v7, &v9, 0LL, 0LL, 0);
    if ( v10 <= 0 )
      return (unsigned int)((_DWORD)v13 - (_DWORD)a1 - v10 + 1);
    v13 += v10;
  }
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001B647) ----------------------------------------------------
__int64  sub_1B647(_BYTE *a1, __int64 a2, _DWORD *a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  _DWORD *v5; // [rsp+8h] [rbp-48h]
  _BYTE *v6; // [rsp+18h] [rbp-38h]
  char v7; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  int v9; // [rsp+28h] [rbp-28h]
  int i; // [rsp+2Ch] [rbp-24h]
  char v11; // [rsp+30h] [rbp-20h]
  char *s1; // [rsp+38h] [rbp-18h]
  const char **v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v14 = __readfsqword(0x28u);
  i = sub_179A7(a1, &v11, (unsigned int *)&v7, &s1, (unsigned int *)&v8, 0LL, 0LL, &v9);
  if ( i <= 0 || !strncmp(s1, ".", v8) )
  {
    sub_13937(**(void ***)(a2 + 48), 78, 0, 0LL, (unsigned int)(char)a1[-i], (__int64)&a1[-i]);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v6 = &a1[i];
    *v5 += i;
    if ( (*__ctype_b_loc())[*s1] & 0x800 )
      goto LABEL_17;
    for ( i = 0; i < *(unsigned __int8 *)(a2 + 30); ++i )
    {
      v13 = *(const char ***)(8LL * i + *(_QWORD *)(a2 + 136));
      if ( !strncmp(*v13, s1, v8) && !(*v13)[v8] )
        break;
    }
    if ( i != *(unsigned __int8 *)(a2 + 30) )
    {
LABEL_17:
      if ( v9 )
        result = sub_1B647(v6, a2, v5);
      else
        result = 0LL;
    }
    else
    {
      sub_13937(**(void ***)(a2 + 48), 82, 0, 0LL, (__int64)s1, v4);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000001B854) ----------------------------------------------------
__int64  sub_1B854(char *a1, void *a2, __int64 a3, int a4)
{
  __int64 result; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // [rsp+4h] [rbp-ACh]
  __int64 v18; // [rsp+8h] [rbp-A8h]
  void *v19; // [rsp+10h] [rbp-A0h]
  int v20; // [rsp+2Ch] [rbp-84h]
  int v21; // [rsp+30h] [rbp-80h]
  int v22; // [rsp+34h] [rbp-7Ch]
  int v23; // [rsp+38h] [rbp-78h]
  int v24; // [rsp+3Ch] [rbp-74h]
  int v25; // [rsp+40h] [rbp-70h]
  int v26; // [rsp+44h] [rbp-6Ch]
  char *s1; // [rsp+48h] [rbp-68h]
  char *v28; // [rsp+50h] [rbp-60h]
  char *v29; // [rsp+58h] [rbp-58h]
  char *v30; // [rsp+60h] [rbp-50h]
  const char *v31; // [rsp+68h] [rbp-48h]
  __int64 v32; // [rsp+70h] [rbp-40h]
  __int64 i; // [rsp+78h] [rbp-38h]
  __int64 j; // [rsp+80h] [rbp-30h]
  __int64 v35; // [rsp+88h] [rbp-28h]
  __int64 v36; // [rsp+90h] [rbp-20h]
  __int64 v37; // [rsp+98h] [rbp-18h]
  void *ptr; // [rsp+A0h] [rbp-10h]
  unsigned __int64 v39; // [rsp+A8h] [rbp-8h]

  v19 = a2;
  v18 = a3;
  v17 = a4;
  v39 = __readfsqword(0x28u);
  v30 = 0LL;
  v31 = 0LL;
  v23 = -1;
  if ( !a1 || !a2 && !a3 )
    __assert_fail(
      "nodeid && (ctx || start)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x931u,
      "resolve_json_nodeid");
  if ( !a2 )
    v19 = **(void ***)(a3 + 48);
  v29 = a1;
  v20 = sub_17847(a1, &v28, (unsigned int *)&v22, &s1, (unsigned int *)&v21, &v23, 0LL, 0LL, 1);
  if ( v20 <= 0 )
  {
    sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
    return 0LL;
  }
  if ( *s1 == 35 )
  {
    if ( v23 )
    {
      sub_13937(v19, 78, 0, 0LL, 35LL, (__int64)s1);
      return 0LL;
    }
    v31 = s1 + 1;
    v25 = v21 - 1;
    v30 = v28;
    v26 = v22;
    v29 += v20;
  }
  else
  {
    v23 = -1;
  }
  v20 = sub_17847(v29, &v28, (unsigned int *)&v22, &s1, (unsigned int *)&v21, &v23, &v24, 0LL, 0);
  if ( v20 <= 0 )
  {
    sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
    return 0LL;
  }
  v29 += v20;
  if ( v30 )
  {
    v28 = v30;
    v22 = v26;
  }
  if ( v23 )
  {
    if ( !v18 )
      __assert_fail("start", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x957u, "resolve_json_nodeid");
    for ( i = v18; i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
      ;
    v36 = *(_QWORD *)(v18 + 48);
  }
  else
  {
    if ( !v28 )
    {
      ptr = strndup(a1, &s1[v21] - a1);
      sub_13937(v19, 80, 4u, a1, v5, v6);
      free(ptr);
      return 0LL;
    }
    ptr = strndup(v28, v22);
    v36 = ly_ctx_get_module(v19, ptr, 0LL, 1LL);
    free(ptr);
    if ( !v36 )
    {
      ptr = strndup(a1, &v28[v22] - a1);
      sub_13937(v19, 79, 4u, (char *)ptr, v7, v8);
      free(ptr);
      return 0LL;
    }
    i = 0LL;
    if ( v31 )
    {
      i = sub_40D5F(v36, v31, v25);
      if ( !i )
      {
        ptr = strndup(a1, &v31[v25] - a1);
        sub_13937(v19, 81, 4u, (char *)ptr, v9, v10);
        free(ptr);
        return 0LL;
      }
    }
    v28 = 0LL;
    v22 = 0;
  }
  v37 = v36;
  while ( 2 )
  {
    v32 = 0LL;
    while ( 1 )
    {
      v32 = lys_getnext(v32, i, v36, 0LL);
      if ( !v32 )
        break;
      if ( *(_QWORD *)v32 && !strncmp(s1, *(const char **)v32, v21) && !*(_BYTE *)(*(_QWORD *)v32 + v21) )
      {
        for ( j = lys_parent(v32); j && !(*(_DWORD *)(j + 56) & 0x600); j = lys_parent(j) )
          ;
        if ( !j || (!v17 || *(_DWORD *)(j + 56) != 512) && (v17 || *(_DWORD *)(j + 56) != 1024) )
        {
          if ( v28 )
          {
            v35 = sub_E085((__int64)v19, v28, v22, 0LL, 1);
            if ( !v35 )
            {
              ptr = strndup(a1, &v28[v22] - a1);
              sub_13937(v19, 79, 4u, (char *)ptr, v11, v12);
              free(ptr);
              return 0LL;
            }
          }
          else
          {
            v35 = v37;
          }
          v13 = lys_node_module(v32);
          if ( v35 == v13 )
          {
            if ( v24 )
            {
              v20 = 0;
              if ( *(_DWORD *)(v32 + 56) & 0xC )
              {
                v20 = sub_179A7(v29, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, &v24);
                if ( v20 <= 0 )
                {
                  sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
                  return 0LL;
                }
              }
              else
              {
                if ( *(_DWORD *)(v32 + 56) != 16 )
                {
                  sub_13937(v19, 78, 0, 0LL, (unsigned int)*v29, (__int64)v29);
                  return 0LL;
                }
                if ( (unsigned int)sub_1B647(v29, v32, &v20) )
                  return 0LL;
              }
              v29 += v20;
            }
            if ( !*v29 )
              return v32;
            if ( *(_DWORD *)(v32 + 56) & 0x802C )
            {
              sub_13937(v19, 78, 0, 0LL, (unsigned int)*v29, (__int64)v29);
              return 0LL;
            }
            i = v32;
            if ( *(_QWORD *)(v32 + 72) )
              v14 = lys_node_module(*(_QWORD *)(i + 72));
            else
              v14 = v36;
            v37 = v14;
            break;
          }
        }
      }
    }
    if ( v32 )
    {
      v20 = sub_17847(v29, &v28, (unsigned int *)&v22, &s1, (unsigned int *)&v21, &v23, &v24, 0LL, 0);
      if ( v20 > 0 )
      {
        v29 += v20;
        continue;
      }
      sub_13937(v19, 78, 0, 0LL, (unsigned int)v29[-v20], (__int64)&v29[-v20]);
      result = 0LL;
    }
    else
    {
      ptr = strndup(a1, &s1[v21] - a1);
      sub_13937(v19, 81, 4u, (char *)ptr, v15, v16);
      free(ptr);
      result = 0LL;
    }
    break;
  }
  return result;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000001C23B) ----------------------------------------------------
signed __int64  sub_1C23B(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9)
{
  __int64 v10; // r9
  size_t v11; // r12
  const char *v12; // rbx
  __int64 v13; // rax
  __int64 v14; // r9
  __int64 v15; // rbx
  __int64 v16; // r9
  __int64 v17; // rbx
  __int64 v18; // r9
  unsigned __int16 i; // [rsp+1Eh] [rbp-32h]
  __int64 v20; // [rsp+20h] [rbp-30h]
  void *v21; // [rsp+28h] [rbp-28h]
  __int64 v22; // [rsp+30h] [rbp-20h]
  char *s2; // [rsp+38h] [rbp-18h]

  if ( !a1 )
    __assert_fail(
      "node",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x9E4u,
      "resolve_partial_json_data_list_predicate");
  if ( *(_DWORD *)(*a1 + 56LL) != 16 )
    __assert_fail(
      "node->schema->nodetype == LYS_LIST",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x9E5u,
      "resolve_partial_json_data_list_predicate");
  if ( !a8 )
    __assert_fail(
      "pp.len",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x9E6u,
      "resolve_partial_json_data_list_predicate");
  v21 = **(void ***)(*a1 + 48LL);
  v22 = *a1;
  if ( (*__ctype_b_loc())[**(char **)(a9 + 16)] & 0x800 )
    return a2 != atoi(*(const char **)(a9 + 16));
  v20 = a1[8];
  if ( !v20 )
    return 1LL;
  for ( i = 0; i < *(unsigned __int8 *)(v22 + 30); ++i )
  {
    if ( strncmp(**(const char ***)v20, *(const char **)(a9 + 48LL * i + 16), *(signed int *)(a9 + 48LL * i + 24))
      || *(_BYTE *)(**(_QWORD **)v20 + *(signed int *)(a9 + 48LL * i + 24)) )
    {
      sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v10);
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(a9 + 48LL * i) )
    {
      v11 = *(signed int *)(a9 + 48LL * i + 8);
      v12 = *(const char **)(a9 + 48LL * i);
      v13 = lyd_node_module(v20);
      if ( strncmp(*(const char **)(v13 + 8), v12, v11)
        || *(_BYTE *)(*(_QWORD *)(lyd_node_module(v20) + 8) + *(signed int *)(a9 + 48LL * i + 8)) )
      {
        sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v14);
        return 0xFFFFFFFFLL;
      }
      v15 = lyd_node_module(v20);
      if ( v15 == lyd_node_module(a1) )
      {
        sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v16);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v17 = lyd_node_module(v20);
      if ( v17 != lyd_node_module(a1) )
      {
        sub_13937(v21, 82, 0, 0LL, *(_QWORD *)(a9 + 48LL * i + 16), v18);
        return 0xFFFFFFFFLL;
      }
    }
    s2 = sub_B02CA(*(_QWORD *)v20, *(const char **)(a9 + 48LL * i + 32), *(_DWORD *)(a9 + 48LL * i + 40));
    if ( !s2 )
      return 0xFFFFFFFFLL;
    if ( strcmp(*(const char **)(v20 + 56), s2) )
    {
      free(s2);
      return 1LL;
    }
    free(s2);
    v20 = *(_QWORD *)(v20 + 24);
  }
  return 0LL;
}
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);

//----- (000000000001C6D1) ----------------------------------------------------
__int64 ** sub_1C6D1(const char *a1, void *a2, __int64 *a3, char a4, _DWORD *a5)
{
  __int64 *v5; // rax
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  void *v14; // rax
  const unsigned __int16 **v15; // rax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rax
  size_t v20; // rbx
  __int64 v21; // rax
  __int64 *v22; // rbx
  __int64 v23; // rax
  __int64 *v24; // rbx
  __int64 v25; // rax
  __int64 v26; // r9
  _DWORD *v27; // [rsp+8h] [rbp-E8h]
  char v28; // [rsp+14h] [rbp-DCh]
  __int64 *v29; // [rsp+18h] [rbp-D8h]
  void *v30; // [rsp+20h] [rbp-D0h]
  int v31; // [rsp+34h] [rbp-BCh]
  int v32; // [rsp+38h] [rbp-B8h]
  int v33; // [rsp+3Ch] [rbp-B4h]
  int v34; // [rsp+40h] [rbp-B0h]
  int i; // [rsp+44h] [rbp-ACh]
  unsigned int v36; // [rsp+48h] [rbp-A8h]
  int v37; // [rsp+4Ch] [rbp-A4h]
  int v38; // [rsp+50h] [rbp-A0h]
  int v39; // [rsp+54h] [rbp-9Ch]
  char *v40; // [rsp+58h] [rbp-98h]
  const char *v41; // [rsp+60h] [rbp-90h]
  char *v42; // [rsp+68h] [rbp-88h]
  char *s2; // [rsp+70h] [rbp-80h]
  char *s1; // [rsp+78h] [rbp-78h]
  __int64 **j; // [rsp+80h] [rbp-70h]
  __int64 **v46; // [rsp+88h] [rbp-68h]
  __int64 *v47; // [rsp+90h] [rbp-60h]
  __int64 v48; // [rsp+98h] [rbp-58h]
  void *v49; // [rsp+A0h] [rbp-50h]
  __int64 v50; // [rsp+A8h] [rbp-48h]
  __int64 v51; // [rsp+B0h] [rbp-40h]
  __int64 **v52; // [rsp+B8h] [rbp-38h]
  __int64 s; // [rsp+C0h] [rbp-30h]
  __int64 v54; // [rsp+C8h] [rbp-28h]
  void *ptr; // [rsp+D0h] [rbp-20h]
  unsigned __int64 v56; // [rsp+D8h] [rbp-18h]

  v30 = a2;
  v29 = a3;
  v28 = a4;
  v27 = a5;
  v56 = __readfsqword(0x28u);
  v33 = -1;
  v37 = 0;
  v46 = 0LL;
  if ( !a1 || !a3 || !a5 )
    __assert_fail(
      "nodeid && start && parsed",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0xA43u,
      "resolve_partial_json_data_nodeid");
  memset(&s, 0, 0x18uLL);
  v49 = **(void ***)(*v29 + 48);
  v42 = (char *)a1;
  i = sub_17847(a1, &v40, (unsigned int *)&v31, &v41, (unsigned int *)&v32, &v33, 0LL, 0LL, 1);
  if ( i <= 0 )
  {
    sub_13937(v49, 78, 0, 0LL, (unsigned int)v42[-i], (__int64)&v42[-i]);
    goto LABEL_132;
  }
  if ( *v41 == 35 )
  {
    if ( v33 )
    {
      sub_13937(v49, 78, 0, 0LL, 35LL, (__int64)v41);
      goto LABEL_132;
    }
    v42 += i;
    v37 = i;
  }
  else
  {
    v33 = -1;
  }
  i = sub_17847(v42, &v40, (unsigned int *)&v31, &v41, (unsigned int *)&v32, &v33, &v34, 0LL, 0);
  if ( i <= 0 )
  {
    sub_13937(v49, 78, 0, 0LL, (unsigned int)v42[-i], (__int64)&v42[-i]);
    goto LABEL_132;
  }
  v42 += i;
  v37 += i;
  if ( v33 )
  {
    v47 = (__int64 *)lyd_node_module(v29);
    if ( *(_DWORD *)(*v29 + 56) & 0x4191 )
      v5 = (__int64 *)v29[8];
    else
      v5 = 0LL;
    v29 = v5;
  }
  else
  {
    while ( v29[5] )
      v29 = (__int64 *)v29[5];
    v47 = (__int64 *)lyd_node_module(v29);
  }
  if ( !v29 )
    return 0LL;
  while ( 2 )
  {
    free(ptr);
    s = 0LL;
    LODWORD(v54) = 0;
    ptr = 0LL;
    while ( v34 )
    {
      LODWORD(v54) = v54 + 1;
      ptr = sub_C422(ptr, 48LL * (signed int)v54);
      if ( !ptr )
      {
        sub_12222(
          (__int64)v49,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"resolve_partial_json_data_nodeid",
          v26);
        goto LABEL_132;
      }
      i = sub_179A7(
            v42,
            (_QWORD *)ptr + 6 * (signed int)v54 - 6,
            (unsigned int *)ptr + 12 * (signed int)v54 - 10,
            (char **)ptr + 6 * (signed int)v54 - 4,
            (unsigned int *)ptr + 12 * (signed int)v54 - 6,
            (char **)ptr + 6 * (signed int)v54 - 2,
            (int *)ptr + 12 * (signed int)v54 - 2,
            &v34);
      if ( i <= 0 )
      {
        sub_13937(v49, 78, 0, 0LL, (unsigned int)*v42, (__int64)v42);
        goto LABEL_132;
      }
      v42 += i;
      v37 += i;
    }
    v48 = 0LL;
    if ( v29 && v29[5] )
      v7 = *(_QWORD *)v29[5];
    else
      v7 = 0LL;
    v50 = v7;
    while ( 1 )
    {
      v8 = v50;
      v48 = lys_getnext(v48, v50, v47, 0LL);
      if ( !v48 )
        break;
      if ( !v50 || !(*(_DWORD *)(v50 + 56) & 0x4100) )
        goto LABEL_34;
      if ( v28 & 4 )
      {
        if ( *(_DWORD *)(lys_parent(v48) + 56) != 512 )
        {
LABEL_34:
          v8 = (__int64)v47;
          if ( !(unsigned int)sub_19DE6((const char **)v48, v47, v40, v31, v41, v32) )
            break;
        }
      }
      else if ( *(_DWORD *)(lys_parent(v48) + 56) != 1024 )
      {
        goto LABEL_34;
      }
    }
    if ( !v48 )
    {
      free(ptr);
      return v46;
    }
    s = v48;
    if ( !*v42 && !(_DWORD)v54 && *(_DWORD *)(v48 + 56) == 8 )
    {
      LODWORD(v54) = 1;
      v8 = 48LL;
      ptr = calloc(1uLL, 0x30uLL);
      if ( !ptr )
      {
        sub_12222(
          (__int64)v49,
          0,
          1,
          "Memory allocation failed (%s()).",
          (__int64)"resolve_partial_json_data_nodeid",
          v13);
        goto LABEL_132;
      }
      *((_QWORD *)ptr + 2) = ".";
      *((_DWORD *)ptr + 6) = 1;
      if ( v30 )
        v14 = v30;
      else
        v14 = &unk_10AA7C;
      *((_QWORD *)ptr + 4) = v14;
      v9 = strlen(*((const char **)ptr + 4));
      *((_DWORD *)ptr + 10) = v9;
    }
    if ( !(*(_DWORD *)(v48 + 56) & 0xC) )
    {
      if ( *(_DWORD *)(v48 + 56) == 16 )
      {
        v51 = v48;
        if ( !(_DWORD)v54 )
          return v46;
        v15 = __ctype_b_loc();
        v9 = (__int64)*v15;
        if ( (*v15)[**((char **)ptr + 2)] & 0x800 )
          goto LABEL_74;
        if ( (signed int)v54 <= *(unsigned __int8 *)(v51 + 30) )
        {
          v9 = (unsigned int)v54;
          if ( (signed int)v54 >= *(unsigned __int8 *)(v51 + 30) )
          {
            for ( i = 0; i < (signed int)v54; ++i )
            {
              v9 = 8LL * i;
              if ( *(_DWORD *)(*(_QWORD *)(v9 + *(_QWORD *)(v51 + 136)) + 128LL) == 7 )
              {
                v8 = 58LL;
                if ( !sub_811F(*((_BYTE **)ptr + 6 * i + 4), 58, *((_DWORD *)ptr + 12 * i + 10)) )
                {
                  sub_13937(
                    v49,
                    84,
                    2u,
                    *(char **)(8LL * i + *(_QWORD *)(v51 + 136)),
                    *((unsigned int *)ptr + 12 * i + 10),
                    *((_QWORD *)ptr + 6 * i + 4));
                  goto LABEL_132;
                }
              }
            }
            goto LABEL_74;
          }
          sub_13937(v49, 83, 0, 0LL, **(_QWORD **)(8LL * (signed int)v54 + *(_QWORD *)(v51 + 136)), v12);
        }
        else
        {
          sub_13937(v49, 87, 0, 0LL, v11, v12);
        }
      }
      else
      {
        if ( !ptr )
          goto LABEL_74;
        sub_13937(v49, 87, 0, 0LL, v11, v12);
      }
      goto LABEL_132;
    }
    if ( (signed int)v54 > 1 )
    {
      sub_13937(v49, 87, 0, 0LL, v11, v12);
      goto LABEL_132;
    }
    if ( (_DWORD)v54 )
    {
      if ( **((_BYTE **)ptr + 2) != 46 || *((_DWORD *)ptr + 6) != 1 )
      {
        sub_13937(v49, 78, 0, 0LL, (unsigned int)**((char **)ptr + 2), *((_QWORD *)ptr + 2));
        goto LABEL_132;
      }
      if ( *(_DWORD *)(v48 + 128) == 7 )
      {
        v8 = 58LL;
        if ( !sub_811F(*((_BYTE **)ptr + 4), 58, *((_DWORD *)ptr + 10)) )
        {
          sub_13937(v49, 84, 2u, (char *)v48, *((unsigned int *)ptr + 10), *((_QWORD *)ptr + 4));
          goto LABEL_132;
        }
      }
    }
LABEL_74:
    if ( v29[5]
      && *(_QWORD *)(v29[5] + 56)
      && (*(_DWORD *)(s + 56) != 16 || *(_BYTE *)(s + 30))
      && (*(_DWORD *)(s + 56) != 8 || *(_WORD *)(s + 24) & 1) )
    {
      j = (__int64 **)sub_181E5(v29[5], v8, v9, v10, v11, v12, s, v54, (__int64)ptr);
    }
    else
    {
      v36 = 0;
      for ( j = (__int64 **)v29; j; j = (__int64 **)j[3] )
      {
        if ( lys_parent(*j) )
        {
          if ( v28 & 4 )
          {
            if ( *(_DWORD *)(lys_parent(*j) + 56) == 512 )
            {
              sub_12222((__int64)v49, 0, 3, "Provided data tree includes some RPC input nodes (%s).", **j, v18);
              goto LABEL_132;
            }
          }
          else if ( *(_DWORD *)(lys_parent(*j) + 56) == 1024 )
          {
            sub_12222((__int64)v49, 0, 3, "Provided data tree includes some RPC output nodes (%s).", **j, v18);
            goto LABEL_132;
          }
        }
        if ( (__int64 *)v48 == *j )
        {
          if ( *(_DWORD *)(v48 + 56) == 8 )
          {
            if ( !(*(_WORD *)(v48 + 24) & 2) )
            {
              v52 = j;
              s1 = 0LL;
              v38 = 0;
              if ( ptr )
              {
                s1 = (char *)*((_QWORD *)ptr + 4);
                v38 = *((_DWORD *)ptr + 10);
              }
              if ( s1
                && !strchr(s1, 58)
                && (_DWORD)v52[9] & 7
                && (v19 = lyd_node_module(j),
                    v20 = strlen(*(const char **)(v19 + 8)),
                    v21 = lyd_node_module(j),
                    !strncmp((const char *)v52[7], *(const char **)(v21 + 8), v20))
                && (v22 = v52[7], v23 = lyd_node_module(j), *((_BYTE *)v22 + strlen(*(const char **)(v23 + 8))) == 58) )
              {
                v24 = v52[7];
                v25 = lyd_node_module(j);
                s2 = (char *)v24 + strlen(*(const char **)(v25 + 8)) + 1;
              }
              else
              {
                s2 = (char *)v52[7];
              }
              if ( (s1 || !s2 || !*s2) && (!s1 || !strncmp(s1, s2, v38) && !s2[v38]) )
                break;
            }
          }
          else
          {
            if ( *(_DWORD *)(v48 + 56) != 16 )
              break;
            ++v36;
            v39 = sub_1C23B(j, v36, v36, v16, v17, v18, s, v54, (__int64)ptr);
            if ( v39 == -1 )
              goto LABEL_132;
            if ( v39 != 1 )
              break;
          }
        }
      }
    }
    if ( !j )
    {
      free(ptr);
      return v46;
    }
    *v27 += v37;
    v46 = j;
    v47 = (__int64 *)lyd_node_module(j);
    if ( !*v42 )
    {
      free(ptr);
      return v46;
    }
    if ( *(_DWORD *)(v48 + 56) & 0x802C )
    {
      sub_13937(v49, 78, 0, 0LL, (unsigned int)*v42, (__int64)v42);
      goto LABEL_132;
    }
    if ( !j[8] )
    {
      free(ptr);
      return v46;
    }
    v29 = j[8];
    i = sub_17847(v42, &v40, (unsigned int *)&v31, &v41, (unsigned int *)&v32, &v33, &v34, 0LL, 0);
    if ( i > 0 )
    {
      v42 += i;
      v37 = i;
      continue;
    }
    break;
  }
  sub_13937(v49, 78, 0, 0LL, (unsigned int)v42[-i], (__int64)&v42[-i]);
LABEL_132:
  *v27 = -1;
  free(ptr);
  return 0LL;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (000000000001D702) ----------------------------------------------------
signed __int64  sub_1D702(void *a1, char *a2, __int64 a3, void **a4)
{
  __int64 v5; // r9
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rax
  __int64 v9; // rax
  void **v10; // [rsp+0h] [rbp-90h]
  __int64 v11; // [rsp+8h] [rbp-88h]
  char *v12; // [rsp+10h] [rbp-80h]
  unsigned __int8 v13; // [rsp+23h] [rbp-6Dh]
  signed int v14; // [rsp+24h] [rbp-6Ch]
  char *nptr; // [rsp+28h] [rbp-68h]
  void *ptr; // [rsp+30h] [rbp-60h]
  __int128 v17; // [rsp+38h] [rbp-58h]
  __int128 v18; // [rsp+48h] [rbp-48h]
  __int128 v19; // [rsp+58h] [rbp-38h]
  char *s; // [rsp+68h] [rbp-28h]
  void *v21; // [rsp+70h] [rbp-20h]
  char *v22; // [rsp+78h] [rbp-18h]
  signed __int64 *i; // [rsp+80h] [rbp-10h]
  unsigned __int64 v24; // [rsp+88h] [rbp-8h]

  v12 = a2;
  v11 = a3;
  v10 = a4;
  v24 = __readfsqword(0x28u);
  v17 = 0uLL;
  *((_QWORD *)&v19 + 1) = 0LL;
  v13 = 0;
  v21 = 0LL;
  v22 = 0LL;
  ptr = 0LL;
  switch ( *(_DWORD *)a3 )
  {
    case 1:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = -1LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 4:
      v14 = 2;
      *(_QWORD *)&v18 = 0x8000000000000000LL;
      *((_QWORD *)&v18 + 1) = 0x7FFFFFFFFFFFFFFFLL;
      v13 = *(_BYTE *)(a3 + 40);
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xA:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = -1LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xC:
      v14 = 1;
      *(_QWORD *)&v17 = -128LL;
      *((_QWORD *)&v17 + 1) = 127LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xD:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = 255LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xE:
      v14 = 1;
      *(_QWORD *)&v17 = -32768LL;
      *((_QWORD *)&v17 + 1) = 0x7FFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0xF:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = 0xFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x10:
      v14 = 1;
      *(_QWORD *)&v17 = -2147483648LL;
      *((_QWORD *)&v17 + 1) = 0x7FFFFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x11:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = 0xFFFFFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x12:
      v14 = 1;
      *(_QWORD *)&v17 = 0x8000000000000000LL;
      *((_QWORD *)&v17 + 1) = 0x7FFFFFFFFFFFFFFFLL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
      goto LABEL_36;
    case 0x13:
      v14 = 0;
      *(_QWORD *)&v19 = 0LL;
      *((_QWORD *)&v19 + 1) = -1LL;
      if ( !a2 && *(_QWORD *)(a3 + 32) )
        v12 = **(char ***)(a3 + 32);
LABEL_36:
      if ( !*(_QWORD *)(a3 + 16) )
        goto LABEL_42;
      if ( (unsigned int)sub_1D702(a1, 0LL, *(_QWORD *)(a3 + 16) + 56LL, &ptr) )
        return 0xFFFFFFFFLL;
      if ( ptr && v14 != *(unsigned __int8 *)ptr )
        __assert_fail(
          "!intv || (intv->kind == kind)",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0xBDFu,
          "resolve_len_ran_interval");
LABEL_42:
      if ( !v12 )
      {
        *v10 = ptr;
        return 0LL;
      }
      if ( ptr )
      {
        i = (signed __int64 *)ptr;
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            *(_QWORD *)&v17 = i[1];
          }
          else if ( v14 == 2 )
          {
            *(_QWORD *)&v18 = i[1];
          }
        }
        else
        {
          *(_QWORD *)&v19 = i[1];
        }
        while ( i[4] )
          i = (signed __int64 *)i[4];
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            *((_QWORD *)&v17 + 1) = i[2];
          }
          else if ( v14 == 2 )
          {
            *((_QWORD *)&v18 + 1) = i[2];
          }
        }
        else
        {
          *((_QWORD *)&v19 + 1) = i[2];
        }
      }
      s = v12;
      i = 0LL;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  while ( 1 )
  {
    if ( v22 )
    {
      *((_QWORD *)v22 + 4) = malloc(0x28uLL);
      v22 = (char *)*((_QWORD *)v22 + 4);
    }
    else
    {
      if ( v21 )
        __assert_fail(
          "!local_intv",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0xC06u,
          "resolve_len_ran_interval");
      v21 = malloc(0x28uLL);
      v22 = (char *)v21;
    }
    if ( !v22 )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_len_ran_interval", v5, v10);
      goto LABEL_191;
    }
    *v22 = v14;
    *((_QWORD *)v22 + 3) = v11;
    *((_QWORD *)v22 + 4) = 0LL;
    for ( nptr = s; (*__ctype_b_loc())[*nptr] & 0x2000; ++nptr )
      ;
    if ( (*__ctype_b_loc())[*nptr] & 0x800 || *nptr == 43 || *nptr == 45 )
    {
      if ( v14 )
      {
        if ( v14 == 1 )
        {
          v7 = strtoll(nptr, &nptr, 10);
          *((_QWORD *)v22 + 1) = v7;
        }
        else if ( v14 == 2 && (unsigned int)sub_16271(&nptr, v13, (_QWORD *)v22 + 1) )
        {
          sub_13937(a1, 10, 0, 0LL, (__int64)nptr, (__int64)"range", v10);
          goto LABEL_191;
        }
      }
      else
      {
        v6 = strtoull(nptr, &nptr, 10);
        *((_QWORD *)v22 + 1) = v6;
      }
    }
    else if ( !strncmp(nptr, "min", 3uLL) )
    {
      if ( v14 )
      {
        if ( v14 == 1 )
        {
          *((_QWORD *)v22 + 1) = v17;
        }
        else if ( v14 == 2 )
        {
          *((_QWORD *)v22 + 1) = v18;
        }
      }
      else
      {
        *((_QWORD *)v22 + 1) = v19;
      }
      nptr += 3;
    }
    else
    {
      if ( strncmp(nptr, "max", 3uLL) )
        goto LABEL_191;
      if ( v14 )
      {
        if ( v14 == 1 )
        {
          *((_QWORD *)v22 + 1) = *((_QWORD *)&v17 + 1);
        }
        else if ( v14 == 2 )
        {
          *((_QWORD *)v22 + 1) = *((_QWORD *)&v18 + 1);
        }
      }
      else
      {
        *((_QWORD *)v22 + 1) = *((_QWORD *)&v19 + 1);
      }
      nptr += 3;
    }
    while ( (*__ctype_b_loc())[*nptr] & 0x2000 )
      ++nptr;
    if ( *nptr != 124 && *nptr )
    {
      if ( strncmp(nptr, "..", 2uLL) )
        goto LABEL_191;
      for ( nptr += 2; (*__ctype_b_loc())[*nptr] & 0x2000; ++nptr )
        ;
      if ( (*__ctype_b_loc())[*nptr] & 0x800 || *nptr == 43 || *nptr == 45 )
      {
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            v9 = strtoll(nptr, &nptr, 10);
            *((_QWORD *)v22 + 2) = v9;
          }
          else if ( v14 == 2 && (unsigned int)sub_16271(&nptr, v13, (_QWORD *)v22 + 2) )
          {
            sub_13937(a1, 10, 0, 0LL, (__int64)nptr, (__int64)"range", v10);
            goto LABEL_191;
          }
        }
        else
        {
          v8 = strtoull(nptr, &nptr, 10);
          *((_QWORD *)v22 + 2) = v8;
        }
      }
      else
      {
        if ( strncmp(nptr, "max", 3uLL) )
          goto LABEL_191;
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            *((_QWORD *)v22 + 2) = *((_QWORD *)&v17 + 1);
          }
          else if ( v14 == 2 )
          {
            *((_QWORD *)v22 + 2) = *((_QWORD *)&v18 + 1);
          }
        }
        else
        {
          *((_QWORD *)v22 + 2) = *((_QWORD *)&v19 + 1);
        }
      }
    }
    else if ( v14 )
    {
      if ( v14 == 1 )
      {
        *((_QWORD *)v22 + 2) = *((_QWORD *)v22 + 1);
      }
      else if ( v14 == 2 )
      {
        *((_QWORD *)v22 + 2) = *((_QWORD *)v22 + 1);
      }
    }
    else
    {
      *((_QWORD *)v22 + 2) = *((_QWORD *)v22 + 1);
    }
    if ( v14 )
    {
      if ( v14 == 1 )
      {
        if ( *((_QWORD *)v22 + 1) > *((_QWORD *)v22 + 2)
          || (signed __int64)v17 > *((_QWORD *)v22 + 1)
          || *((_QWORD *)&v17 + 1) < *((_QWORD *)v22 + 2)
          || i && i[2] >= *((_QWORD *)v22 + 1) )
        {
          goto LABEL_191;
        }
      }
      else if ( v14 == 2
             && (*((_QWORD *)v22 + 1) > *((_QWORD *)v22 + 2)
              || (signed __int64)v18 > *((_QWORD *)v22 + 1)
              || *((_QWORD *)&v18 + 1) < *((_QWORD *)v22 + 2)
              || i && i[2] >= *((_QWORD *)v22 + 1)) )
      {
        goto LABEL_191;
      }
    }
    else if ( *((_QWORD *)v22 + 1) > *((_QWORD *)v22 + 2)
           || (unsigned __int64)v19 > *((_QWORD *)v22 + 1)
           || *((_QWORD *)&v19 + 1) < *((_QWORD *)v22 + 2)
           || i && (unsigned __int64)i[2] >= *((_QWORD *)v22 + 1) )
    {
      goto LABEL_191;
    }
    s = strchr(s, 124);
    if ( !s )
      break;
    ++s;
    i = (signed __int64 *)v22;
  }
  if ( !ptr )
    goto LABEL_171;
  i = (signed __int64 *)ptr;
  v22 = (char *)v21;
LABEL_168:
  while ( v22 && i )
  {
    if ( v14 )
    {
      if ( v14 == 1 )
      {
        v17 = *(QWORD *)(v22 + 8);
        if ( (signed __int64)v17 < i[1] || (signed __int64)v17 > i[2] )
          goto LABEL_167;
        if ( *((_QWORD *)&v17 + 1) > i[2] )
          goto LABEL_191;
        v22 = (char *)*((_QWORD *)v22 + 4);
      }
      else
      {
        if ( v14 != 2
          || (v18 = *(QWORD *)(v22 + 8), (signed int)sub_C508(v18, v13, i[1], v13) < 0)
          || (signed int)sub_C508(v18, v13, i[2], v13) > 0 )
        {
LABEL_167:
          i = (signed __int64 *)i[4];
          goto LABEL_168;
        }
        if ( (signed int)sub_C508(*((signed __int64 *)&v18 + 1), v13, i[2], v13) > 0 )
          goto LABEL_191;
        v22 = (char *)*((_QWORD *)v22 + 4);
      }
    }
    else
    {
      v19 = *(QWORD *)(v22 + 8);
      if ( (unsigned __int64)v19 < i[1] || (unsigned __int64)v19 > i[2] )
        goto LABEL_167;
      if ( *((_QWORD *)&v19 + 1) > (unsigned __int64)i[2] )
        goto LABEL_191;
      v22 = (char *)*((_QWORD *)v22 + 4);
    }
  }
  if ( v22 )
  {
LABEL_191:
    while ( ptr )
    {
      i = (signed __int64 *)*((_QWORD *)ptr + 4);
      free(ptr);
      ptr = i;
    }
    while ( v21 )
    {
      v22 = (char *)*((_QWORD *)v21 + 4);
      free(v21);
      v21 = v22;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_171:
  if ( ptr )
  {
    for ( i = (signed __int64 *)ptr; i[4]; i = (signed __int64 *)i[4] )
      ;
    i[4] = (signed __int64)v21;
  }
  else
  {
    ptr = v21;
  }
  *v10 = ptr;
  return 0LL;
}

//----- (000000000001E592) ----------------------------------------------------
signed __int64  sub_1E592(signed __int64 a1)
{
  signed __int64 v2; // [rsp+8h] [rbp-18h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  v2 = a1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      return 1LL;
    case 0xB:
      for ( i = 0; i < *(_DWORD *)(a1 + 40); ++i )
      {
        if ( (unsigned int)sub_1E592(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 32)) )
          return 1LL;
      }
      break;
    case 9:
      while ( !*(_QWORD *)(v2 + 32) )
      {
        if ( !*(_QWORD *)(v2 + 16) )
          __assert_fail(
            "type->der",
            "/home/mantovan/Repositories/libyang/src/resolve.c",
            0xCFDu,
            "resolve_superior_type_check");
        v2 = *(_QWORD *)(v2 + 16) + 56LL;
      }
      break;
  }
  return 0LL;
}

//----- (000000000001E65A) ----------------------------------------------------
signed __int64  sub_1E65A(const char *a1, const char *a2, __int64 a3, __int64 a4, signed __int64 *a5)
{
  unsigned int v6; // eax
  signed __int64 *v7; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+10h] [rbp-40h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  char *s1; // [rsp+20h] [rbp-30h]
  signed int i; // [rsp+34h] [rbp-1Ch]
  int j; // [rsp+34h] [rbp-1Ch]
  signed int k; // [rsp+34h] [rbp-1Ch]
  signed int l; // [rsp+34h] [rbp-1Ch]
  signed int m; // [rsp+38h] [rbp-18h]
  int v16; // [rsp+3Ch] [rbp-14h]
  __int64 v17; // [rsp+40h] [rbp-10h]
  signed __int64 v18; // [rsp+48h] [rbp-8h]

  s1 = (char *)a2;
  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( a2 )
  {
    if ( !strcmp(a2, *(const char **)(a3 + 8)) )
      s1 = 0LL;
  }
  else
  {
    for ( i = 1; i <= 19; ++i )
    {
      if ( !strcmp(*qword_346FA0[i], a1) )
      {
        if ( v7 )
          *v7 = (signed __int64)qword_346FA0[i];
        return 0LL;
      }
    }
  }
  if ( !s1 && v8 )
  {
    while ( 1 )
    {
LABEL_41:
      if ( !v8 )
        goto LABEL_45;
      v6 = *(_DWORD *)(v8 + 56);
      if ( v6 == 256 )
        goto LABEL_31;
      if ( v6 > 0x100 )
      {
        if ( v6 == 1024 )
          goto LABEL_33;
        if ( v6 > 0x400 )
        {
          if ( v6 == 2048 )
          {
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 104);
            goto LABEL_35;
          }
          if ( v6 == 0x4000 )
          {
LABEL_31:
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 112);
            goto LABEL_35;
          }
        }
        else if ( v6 == 512 )
        {
LABEL_33:
          v16 = *(unsigned __int16 *)(v8 + 30);
          v17 = *(_QWORD *)(v8 + 104);
LABEL_35:
          for ( j = 0; ; ++j )
          {
            if ( j >= v16 )
            {
              v8 = lys_parent(v8);
              goto LABEL_41;
            }
            if ( !strcmp(*(const char **)(((signed __int64)j << 7) + v17), a1) )
              break;
          }
          v18 = ((signed __int64)j << 7) + v17;
LABEL_60:
          if ( (unsigned int)sub_1E592(v18 + 56) )
            return 1LL;
          if ( v7 )
            *v7 = v18;
          return 0LL;
        }
      }
      else
      {
        switch ( v6 )
        {
          case 0x10u:
            v16 = *(unsigned __int8 *)(v8 + 29);
            v17 = *(_QWORD *)(v8 + 128);
            goto LABEL_35;
          case 0x80u:
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 112);
            goto LABEL_35;
          case 1u:
            v16 = *(unsigned __int16 *)(v8 + 30);
            v17 = *(_QWORD *)(v8 + 128);
            goto LABEL_35;
        }
      }
      v8 = lys_parent(v8);
    }
  }
  v9 = sub_407F3((__int64 *)v9, 0LL, 0, s1, 0, 0);
  if ( !v9 )
    return 0xFFFFFFFFLL;
LABEL_45:
  for ( k = 0; k < *(unsigned __int16 *)(v9 + 74); ++k )
  {
    if ( !strcmp(*(const char **)(((signed __int64)k << 7) + *(_QWORD *)(v9 + 112)), a1) )
    {
      v18 = ((signed __int64)k << 7) + *(_QWORD *)(v9 + 112);
      goto LABEL_60;
    }
  }
  for ( l = 0; l < *(unsigned __int8 *)(v9 + 70) && *(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l); ++l )
  {
    for ( m = 0; m < *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l) + 74LL); ++m )
    {
      if ( !strcmp(
              *(const char **)(((signed __int64)m << 7)
                             + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l) + 112LL)),
              a1) )
      {
        v18 = ((signed __int64)m << 7) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 104) + 48LL * l) + 112LL);
        goto LABEL_60;
      }
    }
  }
  return 1LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (000000000001EAAF) ----------------------------------------------------
__int64  sub_1EAAF(_QWORD *a1, const char **a2, void **a3, int a4)
{
  const char *v4; // rbx
  __int64 v5; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  int v11; // [rsp+4h] [rbp-BCh]
  void **v12; // [rsp+8h] [rbp-B8h]
  unsigned int v13; // [rsp+28h] [rbp-98h]
  const char *v14; // [rsp+30h] [rbp-90h]
  char *ptr; // [rsp+38h] [rbp-88h]
  _QWORD *i; // [rsp+40h] [rbp-80h]
  void *v17; // [rsp+48h] [rbp-78h]
  char **s; // [rsp+50h] [rbp-70h]
  const char *v19; // [rsp+88h] [rbp-38h]
  void *v20; // [rsp+90h] [rbp-30h]
  int v21; // [rsp+98h] [rbp-28h]
  char v22; // [rsp+9Ch] [rbp-24h]
  unsigned __int64 v23; // [rsp+A8h] [rbp-18h]

  v12 = a3;
  v11 = a4;
  v23 = __readfsqword(0x28u);
  i = 0LL;
  v14 = 0LL;
  v13 = 0;
  v17 = *a3;
  if ( !a2 )
    __assert_fail("value", "/home/mantovan/Repositories/libyang/src/resolve.c", 0xD96u, "check_default");
  memset(&s, 0, 0x50uLL);
  if ( *(_DWORD *)a1 )
  {
    if ( v11 || *((_BYTE *)v12 + 64) < 0 )
    {
      if ( v11 && *((_BYTE *)v12 + 64) >= 0 && *(_DWORD *)a1 == 7 )
      {
        if ( *a2 )
        {
          if ( strchr(*a2, 58) )
          {
            v14 = (const char *)sub_9BED((__int64 *)v12, *a2);
          }
          else
          {
            v4 = *a2;
            v5 = lys_main_module(v12);
            if ( asprintf(&ptr, "%s:%s", *(_QWORD *)(v5 + 8), v4) == -1 )
            {
              sub_12222((__int64)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_default", v6);
              v13 = -1;
              goto LABEL_69;
            }
            v14 = (const char *)lydict_insert_zc(v17, ptr);
          }
          lydict_remove(v17, *a2);
          *a2 = v14;
          v14 = 0LL;
          goto LABEL_69;
        }
      }
      else if ( *(_DWORD *)a1 != 9 || !v11 )
      {
        v14 = (const char *)lydict_insert(v17, *a2, 0LL);
        if ( v14 )
        {
          if ( *(_DWORD *)a1 == 5 )
          {
            sub_13937(v17, 6, 0, 0LL, (__int64)"default", *(_QWORD *)a1[3]);
            sub_13937(v17, -1, 0, 0LL, (__int64)"The \"empty\" data type cannot have a default value.", v7);
            v13 = -1;
          }
          else
          {
LABEL_45:
            memset(&s, 0, 0x50uLL);
            v19 = (const char *)lydict_insert(v17, v14, 0LL);
            v21 = *(_DWORD *)a1;
            if ( v11 )
            {
              s = (char **)calloc(1uLL, 0xD0uLL);
              if ( !s )
              {
                sub_12222((__int64)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_default", v8);
                v13 = -1;
                goto LABEL_69;
              }
              if ( asprintf(s, "typedef-%s-default", *(_QWORD *)a1[3]) == -1 )
              {
                sub_12222((__int64)v17, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_default", v9);
                v13 = -1;
                goto LABEL_69;
              }
              s[6] = (char *)v12;
              memcpy(s + 16, a1, 0x40uLL);
            }
            else
            {
              s = (char **)a1[3];
            }
            if ( *(_DWORD *)a1 == 9 )
            {
              if ( a1[5] )
              {
                v13 = sub_1EAAF(a1[5] + 128LL, &v14, v12, 0LL);
                if ( !v13 && *a2 )
                {
                  lydict_remove(v17, *a2);
                  *a2 = v14;
                  v14 = 0LL;
                }
              }
              else
              {
                v13 = 1;
                sub_13937(
                  v17,
                  -1,
                  0,
                  0LL,
                  (__int64)"Default value \"%s\" cannot be checked in an unresolved leafref.",
                  (__int64)v14);
              }
            }
            else if ( sub_37EF5((signed __int64)a1, (char **)&v19, 0LL, (__int64 **)&s, 0LL, (__int64 *)v12, 1, 1, 0) )
            {
              if ( v19 != v14 )
              {
                if ( *a2 != v14 )
                  __assert_fail(
                    "ly_strequal(dflt, *value, 1)",
                    "/home/mantovan/Repositories/libyang/src/resolve.c",
                    0xE4Bu,
                    "check_default");
                lydict_remove(v17, *a2);
                *a2 = v19;
                v19 = 0LL;
              }
            }
            else
            {
              v13 = 1;
              if ( i
                && (*(_DWORD *)a1 == 2 && *(_QWORD *)(a1[2] + 72LL) || *(_DWORD *)a1 == 6 && *(_QWORD *)(a1[2] + 72LL)) )
              {
                sub_13937(
                  v17,
                  -1,
                  0,
                  0LL,
                  (__int64)"Invalid value \"%s\" of the default statement inherited to \"%s\" from \"%s\" base type.",
                  (__int64)v14,
                  *(_QWORD *)a1[3],
                  *i);
              }
            }
          }
        }
        else
        {
          for ( i = (_QWORD *)a1[2]; i[9]; i = (_QWORD *)i[9] )
          {
            if ( i[15] )
            {
              v14 = (const char *)lydict_insert(v17, i[15], 0LL);
              break;
            }
          }
          if ( v14 )
          {
            switch ( *(_DWORD *)a1 )
            {
              case 1:
                if ( a1[4] )
                  goto LABEL_45;
                break;
              case 2:
                if ( *((_DWORD *)a1 + 10) )
                  goto LABEL_45;
                break;
              case 3:
              case 5:
              case 8:
              case 9:
                break;
              case 4:
                if ( a1[4] )
                  goto LABEL_45;
                break;
              case 6:
                if ( *((_DWORD *)a1 + 10) )
                  goto LABEL_45;
                break;
              case 7:
                if ( *(_BYTE *)(lys_main_module(*(_QWORD *)(i[10] + 48LL)) + 64) & 0x80 )
                  break;
                v12 = (void **)i[6];
                goto LABEL_45;
              case 0xA:
                if ( a1[4] || a1[5] )
                  goto LABEL_45;
                break;
              case 0xB:
                goto LABEL_45;
              case 0xC:
              case 0xD:
              case 0xE:
              case 0xF:
              case 0x10:
              case 0x11:
              case 0x12:
              case 0x13:
                if ( a1[4] )
                  goto LABEL_45;
                break;
              default:
                sub_12222(
                  (__int64)v17,
                  0,
                  4,
                  "Internal error (%s:%d).",
                  (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
                  3589LL);
                v13 = -1;
                break;
            }
          }
        }
      }
    }
  }
  else
  {
    v13 = 1;
  }
LABEL_69:
  sub_BBE52(v20, v21, v22, (signed __int64)a1, (__int64)v19, 0LL, 0LL, 0LL);
  lydict_remove(v17, v19);
  if ( v11 && s )
  {
    free(*s);
    free(s);
  }
  lydict_remove(v17, v14);
  return v13;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);
// 7950: using guessed type __int64  lys_main_module(_QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (000000000001F3F0) ----------------------------------------------------
signed __int64  sub_1F3F0(__int64 a1, int a2, const char *a3, int a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // r9
  const char *v8; // rax
  const char *v9; // rax
  char *s; // [rsp+8h] [rbp-38h]
  int v11; // [rsp+10h] [rbp-30h]
  int i; // [rsp+24h] [rbp-1Ch]
  signed int v13; // [rsp+24h] [rbp-1Ch]
  char *ptr; // [rsp+28h] [rbp-18h]
  __int64 v15; // [rsp+30h] [rbp-10h]
  void *v16; // [rsp+38h] [rbp-8h]

  s = (char *)a3;
  v11 = a4;
  v15 = *(_QWORD *)(8LL * a2 + *(_QWORD *)(a1 + 136));
  ptr = 0LL;
  v16 = **(void ***)(a1 + 48);
  if ( v15 )
  {
    for ( i = a2 - 1; i >= 0; --i )
    {
      if ( v15 == *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) )
      {
        sub_13937(v16, 34, 2u, (char *)a1, *(_QWORD *)v15, a6);
        return 0xFFFFFFFFLL;
      }
    }
    if ( *(_DWORD *)(v15 + 56) != 4 )
    {
      sub_13937(v16, 30, 2u, (char *)a1, *(_QWORD *)v15, a6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(v15 + 128) == 5 && ((*(_BYTE *)(*(_QWORD *)(v15 + 48) + 64LL) >> 1) & 7u) <= 1 )
    {
      sub_13937(v16, 31, 2u, (char *)a1, *(_QWORD *)v15, a6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_WORD *)(v15 + 24) & 3
      && *(_WORD *)(a1 + 24) & 3
      && ((unsigned __int8)*(_WORD *)(a1 + 24) ^ (unsigned __int8)*(_WORD *)(v15 + 24)) & 3 )
    {
      sub_13937(v16, 32, 2u, (char *)a1, *(_QWORD *)v15, a6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(*(_QWORD *)(v15 + 64) + 56LL) == 0x2000 )
    {
      sub_13937(v16, 33, 2u, (char *)v15, *(_QWORD *)v15, a6);
      sub_13937(v16, -1, 5u, 0LL, (__int64)"Key inserted from augment.", v7);
      return 0xFFFFFFFFLL;
    }
    v13 = 0;
    if ( !*(_QWORD *)(v15 + 112) )
    {
      if ( !*(_BYTE *)(v15 + 27) )
        return 0LL;
      v13 = 1;
    }
    if ( v13 )
      v8 = "if-feature";
    else
      v8 = "when";
    sub_13937(v16, 6, 2u, (char *)v15, (__int64)v8, (__int64)"leaf");
    if ( v13 )
      v9 = "if-feature";
    else
      v9 = "when";
    sub_13937(v16, -1, 5u, 0LL, (__int64)"Key definition cannot depend on a \"%s\" condition.", (__int64)v9);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( a3[a4] )
    {
      ptr = strdup(a3);
      if ( !ptr )
      {
        sub_12222((__int64)v16, 0, 1, "Memory allocation failed (%s()).", (__int64)"check_key", a6);
        return 0xFFFFFFFFLL;
      }
      ptr[v11] = 0;
      s = ptr;
    }
    sub_13937(v16, 33, 2u, (char *)a1, (__int64)s, a6);
    free(ptr);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000001F79E) ----------------------------------------------------
signed __int64  sub_1F79E(__int64 a1, const char *a2, _BYTE *a3)
{
  __int64 *v3; // rax
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  const char *v8; // rdx
  const char *v9; // rax
  __int16 v10; // dx
  _BYTE *v11; // [rsp+8h] [rbp-38h]
  int v12; // [rsp+24h] [rbp-1Ch]
  unsigned int v13; // [rsp+24h] [rbp-1Ch]
  __int64 v14; // [rsp+28h] [rbp-18h]
  void *v15; // [rsp+30h] [rbp-10h]
  unsigned __int64 v16; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v16 = __readfsqword(0x28u);
  v14 = 0LL;
  v15 = **(void ***)(a1 + 48);
  v3 = (__int64 *)sub_A75EB(a1, 4u);
  v12 = sub_1AF63(a2, *v3, 4, 1, &v14);
  if ( !v12 && v14 )
  {
    if ( *(_DWORD *)(v14 + 56) != 4 )
    {
      sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
      sub_13937(v15, -1, 5u, 0LL, (__int64)"Target is not a leaf.", v6);
      return 0xFFFFFFFFLL;
    }
    if ( *(_DWORD *)(a1 + 56) != 0x10000
      && (unsigned int)sub_3C749(
                         *(_WORD *)(a1 + 24),
                         *(void ***)(a1 + 48),
                         *(_QWORD *)a1,
                         *(_WORD *)(v14 + 24),
                         *(_QWORD *)(v14 + 48),
                         *(_QWORD *)v14,
                         (char *)v14) )
    {
      return 0xFFFFFFFFLL;
    }
    if ( *v11 )
    {
      if ( *v11 == 1 && *(_WORD *)(v14 + 24) & 2 || *v11 == 2 && *(_WORD *)(v14 + 24) & 1 )
      {
        sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
        if ( *v11 == 1 )
          v8 = "true";
        else
          v8 = "false";
        if ( *v11 == 1 )
          v9 = "false";
        else
          v9 = "true";
        sub_13937(
          v15,
          -1,
          5u,
          0LL,
          (__int64)"Leaf \"%s\" referenced in unique statement is config %s, but previous referenced leaf is config %s.",
          (__int64)a2,
          v9,
          v8);
        return 0xFFFFFFFFLL;
      }
    }
    else if ( *(_WORD *)(v14 + 24) & 1 )
    {
      *v11 = 1;
    }
    else
    {
      *v11 = 2;
    }
    v10 = *(_WORD *)(v14 + 24);
    HIBYTE(v10) |= 1u;
    *(_WORD *)(v14 + 24) = v10;
    return 0LL;
  }
  if ( v12 )
  {
    sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
    if ( v12 <= 0 )
    {
      if ( v12 == -2 )
        sub_13937(v15, -1, 5u, 0LL, (__int64)"Unique argument references list.", v4);
    }
    else
    {
      sub_13937(v15, 55, 5u, 0LL, (unsigned int)a2[v12 - 1], (__int64)&a2[v12 - 1]);
    }
    v13 = -1;
  }
  else
  {
    sub_13937(v15, 10, 2u, (char *)a1, (__int64)a2, (__int64)"unique");
    sub_13937(v15, -1, 5u, 0LL, (__int64)"Target leaf not found.", v5);
    v13 = 1;
  }
  return v13;
}

//----- (000000000001FB5F) ----------------------------------------------------
__int64  sub_1FB5F(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  if ( a2 + 1 >= *(_DWORD *)(a1 + 16) )
  {
    if ( !a2 )
    {
      free(*(void **)a1);
      *(_QWORD *)a1 = 0LL;
    }
  }
  else
  {
    memmove(
      (void *)(8LL * a2 + *(_QWORD *)a1),
      (const void *)(*(_QWORD *)a1 + 8LL * (a2 + 1)),
      8LL * (*(_DWORD *)(a1 + 16) - a2 - 1));
  }
  result = a1;
  --*(_DWORD *)(a1 + 16);
  return result;
}

//----- (000000000001FBFE) ----------------------------------------------------
signed __int64  sub_1FBFE(__int64 *a1, const char *a2, int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9
  __int64 v7; // rax
  __int64 v8; // r9
  __int64 v9; // [rsp+8h] [rbp-38h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  int v11; // [rsp+1Ch] [rbp-24h]
  signed int v12; // [rsp+30h] [rbp-10h]
  unsigned int v13; // [rsp+34h] [rbp-Ch]
  __int64 i; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  if ( !*(_DWORD *)(a5 + 16) )
  {
    *(_DWORD *)(a5 + 16) = 1;
    *(_QWORD *)a5 = malloc(8uLL);
    if ( !*(_QWORD *)v9 )
    {
      sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_data", v5);
      return 0xFFFFFFFFLL;
    }
    **(_QWORD **)v9 = 0LL;
  }
  v13 = 0;
  while ( v13 < *(_DWORD *)(v9 + 16) )
  {
    if ( *(_QWORD *)(8LL * v13 + *(_QWORD *)v9) && *(_DWORD *)(**(_QWORD **)(8LL * v13 + *(_QWORD *)v9) + 56LL) & 0x802C )
    {
      ++v13;
    }
    else
    {
      v12 = 0;
      if ( *(_QWORD *)(8LL * v13 + *(_QWORD *)v9) )
        v7 = *(_QWORD *)(*(_QWORD *)(8LL * v13 + *(_QWORD *)v9) + 64LL);
      else
        v7 = v10;
      for ( i = v7; i; i = *(_QWORD *)(i + 24) )
      {
        if ( a1 == (__int64 *)lyd_node_module(i)
          && !strncmp(**(const char ***)i, a2, v11)
          && !*(_BYTE *)(**(_QWORD **)i + v11) )
        {
          if ( v12 )
          {
            *(_QWORD *)v9 = sub_C422(*(void **)v9, 8LL * (unsigned int)++*(_DWORD *)(v9 + 16));
            if ( !*(_QWORD *)v9 )
            {
              sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_data", v8);
              return 1LL;
            }
            *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(v9 + 16) - 1) + *(_QWORD *)v9) = i;
            ++v13;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)v9 + 8LL * v13) = i;
            v12 = 1;
          }
        }
      }
      if ( v12 )
        ++v13;
      else
        sub_1FB5F(v9, v13);
    }
  }
  return *(_DWORD *)(v9 + 16) == 0;
}
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);

//----- (000000000001FEA6) ----------------------------------------------------
signed __int64  sub_1FEA6(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+4h] [rbp-2Ch]
  __int64 v6; // [rsp+8h] [rbp-28h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( a1 )
  {
    if ( lys_parent(a1) )
    {
      if ( v5 )
        return 1LL;
      for ( i = v6; i && i != a1; i = lys_parent(i) )
        ;
      if ( !i )
        return 1LL;
    }
    else if ( a1 != v6 )
    {
      return 1LL;
    }
  }
  else if ( a2 != lys_node_module(a3) )
  {
    return 1LL;
  }
  return 0LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000001FF4C) ----------------------------------------------------
__int64  sub_1FF4C(_BYTE *a1, __int64 a2, char *a3, __int64 a4)
{
  int v5; // er12
  char *v6; // rbx
  __int64 *v7; // rax
  int v8; // er12
  char *v9; // rbx
  __int64 *v10; // rax
  __int64 v11; // rax
  const char *v12; // rbx
  const char *v13; // rax
  __int64 v14; // [rsp+0h] [rbp-C0h]
  char *v15; // [rsp+8h] [rbp-B8h]
  _BYTE *v16; // [rsp+18h] [rbp-A8h]
  int v17; // [rsp+24h] [rbp-9Ch]
  int v18; // [rsp+28h] [rbp-98h]
  int v19; // [rsp+2Ch] [rbp-94h]
  int v20; // [rsp+30h] [rbp-90h]
  int v21; // [rsp+34h] [rbp-8Ch]
  int v22; // [rsp+38h] [rbp-88h]
  int v23; // [rsp+3Ch] [rbp-84h]
  int v24; // [rsp+40h] [rbp-80h]
  unsigned int v25; // [rsp+44h] [rbp-7Ch]
  int v26; // [rsp+48h] [rbp-78h]
  int v27; // [rsp+4Ch] [rbp-74h]
  __int64 v28; // [rsp+50h] [rbp-70h]
  char *i; // [rsp+58h] [rbp-68h]
  const char *v30; // [rsp+60h] [rbp-60h]
  char *v31; // [rsp+68h] [rbp-58h]
  char *v32; // [rsp+70h] [rbp-50h]
  char *v33; // [rsp+78h] [rbp-48h]
  char *v34; // [rsp+80h] [rbp-40h]
  __int64 v35; // [rsp+88h] [rbp-38h]
  __int64 v36; // [rsp+90h] [rbp-30h]
  void *v37; // [rsp+98h] [rbp-28h]
  __int64 v38; // [rsp+A0h] [rbp-20h]
  unsigned __int64 v39; // [rsp+A8h] [rbp-18h]

  v16 = a1;
  v15 = a3;
  v14 = a4;
  v39 = __readfsqword(0x28u);
  v25 = 0;
  v37 = **(void ***)(a2 + 48);
  do
  {
    v26 = sub_169E9(v16, &v32, (unsigned int *)&v19, &v31, (unsigned int *)&v18, (char **)&v30, &v17, &v22);
    if ( v26 <= 0 )
    {
      sub_13937(v37, 55, 2u, v15, (unsigned int)(char)v16[-v26], (__int64)&v16[-v26], v14);
      return v26 - v25;
    }
    v25 += v26;
    v16 += v26;
    if ( v32 )
    {
      v5 = v19;
      v6 = v32;
      v7 = (__int64 *)lys_node_module(v15);
      v35 = sub_407F3(v7, 0LL, 0, v6, v5, 0);
    }
    else
    {
      v35 = lys_node_module(v15);
    }
    v27 = sub_9B536(v35, a2, v31, v18, 12, 0x100u, (const char ***)&v28);
    if ( v27 )
    {
      sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)&v16[-v25], v14);
      return 0LL;
    }
    v23 = 0;
    v24 = 0;
    v26 = sub_16CF6(v30, &v34, (unsigned int *)&v21, &v33, (unsigned int *)&v20, &v23);
    if ( v26 <= 0 )
    {
      sub_13937(v37, 55, 2u, v15, (unsigned int)v30[-v26], (__int64)&v30[-v26], v14);
      return -v25;
    }
    v24 += v26;
    v26 = 0;
    i = v15;
    while ( v26 < v23 )
    {
      if ( !i )
      {
        sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)v30, v14);
        return 0LL;
      }
      if ( *((_QWORD *)i + 8)
        && *(_DWORD *)(*((_QWORD *)i + 8) + 56LL) == 0x2000
        && !*(_QWORD *)(*((_QWORD *)i + 8) + 88LL) )
      {
        sub_13937(
          v37,
          -1,
          2u,
          *((char **)i + 8),
          (__int64)"Cannot resolve leafref predicate \"%s\" because it is in an unresolved augment.",
          (__int64)v30,
          v14);
        return 0LL;
      }
      for ( i = (char *)lys_parent(i); i && !(*((_DWORD *)i + 14) & 0x4191); i = (char *)lys_parent(i) )
        ;
      ++v26;
    }
    while ( 1 )
    {
      v36 = 0LL;
      if ( v34 )
      {
        v8 = v21;
        v9 = v34;
        v10 = (__int64 *)lys_node_module(v15);
        v35 = sub_407F3(v10, 0LL, 0, v9, v8, 0);
      }
      else
      {
        v35 = lys_node_module(v15);
      }
      if ( *(_BYTE *)(v35 + 64) >= 0 && i )
        goto LABEL_29;
      while ( 2 )
      {
        if ( v36 )
          v11 = v36;
        else
          v11 = (__int64)i;
        v38 = v11;
        v27 = sub_9B536(v35, v11, v33, v20, 21, 0x100u, (const char ***)&i);
        if ( v27 )
        {
          if ( !v36 )
          {
            sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)v30, v14);
            return 0LL;
          }
          i = *(char **)(v36 + 88);
LABEL_29:
          v36 = sub_AA881(v36, v35, (__int64)i);
          continue;
        }
        break;
      }
      if ( v24 == v17 )
        break;
      v26 = sub_16CF6(&v30[v24], &v34, (unsigned int *)&v21, &v33, (unsigned int *)&v20, &v23);
      if ( v26 <= 0 )
      {
        sub_13937(
          v37,
          55,
          2u,
          v15,
          (unsigned int)v30[v24 + (signed __int64)-v26],
          (__int64)&v30[v24 - (signed __int64)v26],
          v14);
        return -v25;
      }
      v24 += v26;
    }
    if ( *((_DWORD *)i + 14) != *(_DWORD *)(v28 + 56) )
    {
      sub_13937(v37, 46, 2u, v15, (__int64)"leafref predicate", (__int64)&v16[-v25], v14);
      v12 = sub_8164(*((_DWORD *)i + 14));
      v13 = sub_8164(*(_DWORD *)(v28 + 56));
      sub_13937(v37, -1, 5u, 0LL, (__int64)"Destination node is not a %s, but a %s.", (__int64)v13, v12);
      return -v25;
    }
    ly_set_add(v14, i, 0LL);
    ly_set_add(v14, v28, 0LL);
  }
  while ( v22 );
  return v25;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000020624) ----------------------------------------------------
__int64  sub_20624(__int64 a1)
{
  unsigned int v1; // eax
  int v3; // [rsp+14h] [rbp-4Ch]
  unsigned int j; // [rsp+18h] [rbp-48h]
  unsigned int k; // [rsp+1Ch] [rbp-44h]
  unsigned int v6; // [rsp+20h] [rbp-40h]
  unsigned int v7; // [rsp+24h] [rbp-3Ch]
  __int64 i; // [rsp+28h] [rbp-38h]
  void *v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  v9 = **(void ***)(*(_QWORD *)(a1 + 24) + 48LL);
  v6 = 0;
  if ( !*(_QWORD *)(a1 + 24) )
    __assert_fail("type->parent", "/home/mantovan/Repositories/libyang/src/resolve.c", 0xFF7u, "check_leafref_features");
  v10 = ly_set_new(a1);
  v11 = ly_set_new(a1);
  v12 = ly_set_new(a1);
  for ( i = *(_QWORD *)(a1 + 24); i; i = lys_parent(i) )
  {
    if ( !(*(_DWORD *)(i + 56) & 0x600) )
    {
      if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
      {
        v13 = *(_QWORD *)(i + 64);
        if ( *(_BYTE *)(*(_QWORD *)(v13 + 48) + 64LL) < 0 && *(_WORD *)(v13 + 24) & 1 || !*(_QWORD *)(v13 + 88) )
        {
          sub_13937(
            v9,
            -1,
            2u,
            (char *)v13,
            (__int64)"Cannot check leafref \"%s\" if-feature consistency because of an unresolved augment.",
            *(_QWORD *)(a1 + 32));
          v6 = 1;
          goto LABEL_52;
        }
        ly_set_add(v10, v13, 1LL);
      }
      ly_set_add(v10, i, 1LL);
    }
  }
  for ( i = *(_QWORD *)(a1 + 40); i; i = lys_parent(i) )
  {
    if ( !(*(_DWORD *)(i + 56) & 0x600) )
    {
      if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
      {
        if ( (v13 = *(_QWORD *)(i + 64), *(_BYTE *)(*(_QWORD *)(v13 + 48) + 64LL) < 0) && *(_WORD *)(v13 + 24) & 1
          || !*(_QWORD *)(v13 + 88) )
        {
          sub_13937(
            v9,
            -1,
            2u,
            (char *)v13,
            (__int64)"Cannot check leafref \"%s\" if-feature consistency because of an unresolved augment.",
            *(_QWORD *)(a1 + 32));
          v6 = 1;
          goto LABEL_52;
        }
      }
      ly_set_add(v11, i, 1LL);
    }
  }
  for ( j = 0; j < *(_DWORD *)(v10 + 4); ++j )
  {
    i = *(_QWORD *)(8LL * j + *(_QWORD *)(v10 + 8));
    if ( *(_BYTE *)(i + 27) )
    {
      for ( k = 0; k < *(unsigned __int8 *)(i + 27); ++k )
      {
        sub_1902D((__int64 *)(*(_QWORD *)(i + 40) + 32LL * k), 0LL, &v3);
        while ( v3 )
        {
          if ( !*(_QWORD *)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)) )
          {
            v6 = 1;
            goto LABEL_52;
          }
          ly_set_add(
            v12,
            *(_QWORD *)(8LL * (unsigned int)(v3-- - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)),
            0LL);
        }
      }
    }
  }
  v7 = *(_DWORD *)(v12 + 4);
  for ( j = 0; j < *(_DWORD *)(v11 + 4); ++j )
  {
    i = *(_QWORD *)(8LL * j + *(_QWORD *)(v11 + 8));
    if ( *(_BYTE *)(i + 27) )
    {
      for ( k = 0; k < *(unsigned __int8 *)(i + 27); ++k )
      {
        sub_1902D((__int64 *)(*(_QWORD *)(i + 40) + 32LL * k), 0LL, &v3);
        while ( v3 )
        {
          if ( !*(_QWORD *)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)) )
          {
            v6 = 1;
            goto LABEL_52;
          }
          v1 = ly_set_add(
                 v12,
                 *(_QWORD *)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)),
                 0LL);
          if ( v7 <= v1 )
          {
            sub_13937(v9, 46, 2u, *(char **)(a1 + 24), (__int64)"leafref", *(_QWORD *)(a1 + 32));
            sub_13937(
              v9,
              -1,
              5u,
              0LL,
              (__int64)"Leafref is not conditional based on \"%s\" feature as its target.",
              **(_QWORD **)(8LL * (unsigned int)(v3 - 1) + *(_QWORD *)(32LL * k + *(_QWORD *)(i + 40) + 16)));
            v6 = -1;
            goto LABEL_52;
          }
          --v3;
        }
      }
    }
  }
LABEL_52:
  ly_set_free(v12);
  ly_set_free(v10);
  ly_set_free(v11);
  return v6;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (0000000000020BE2) ----------------------------------------------------
__int64  sub_20BE2(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  int v8; // ebx
  __int64 v9; // rax
  __int16 v10; // ax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 *v14; // rax
  __int64 v15; // [rsp+8h] [rbp-A8h]
  int v16; // [rsp+28h] [rbp-88h]
  int v17; // [rsp+2Ch] [rbp-84h]
  int v18; // [rsp+30h] [rbp-80h]
  int v19; // [rsp+34h] [rbp-7Ch]
  int l; // [rsp+38h] [rbp-78h]
  int v21; // [rsp+3Ch] [rbp-74h]
  char *v22; // [rsp+40h] [rbp-70h]
  char *s2; // [rsp+48h] [rbp-68h]
  __int64 i; // [rsp+50h] [rbp-60h]
  __int64 j; // [rsp+58h] [rbp-58h]
  __int64 k; // [rsp+60h] [rbp-50h]
  __int64 v27; // [rsp+68h] [rbp-48h]
  char *v28; // [rsp+70h] [rbp-40h]
  void *v29; // [rsp+78h] [rbp-38h]
  __int64 v30; // [rsp+80h] [rbp-30h]
  __int64 *v31; // [rsp+88h] [rbp-28h]
  __int64 *v32; // [rsp+90h] [rbp-20h]
  unsigned __int64 v33; // [rsp+98h] [rbp-18h]

  v15 = a3;
  v33 = __readfsqword(0x28u);
  j = 0LL;
  v29 = **(void ***)(a2 + 48);
  for ( i = a2; lys_parent(i); i = lys_parent(i) )
    ;
  if ( *(_QWORD *)(i + 64) && *(_DWORD *)(*(_QWORD *)(i + 64) + 56LL) == 0x2000 )
  {
    sub_13937(
      v29,
      -1,
      2u,
      *(char **)(i + 64),
      (__int64)"Cannot resolve leafref \"%s\" because it is in an unresolved augment.",
      a1[4]);
    return 1LL;
  }
  v21 = 1;
  v18 = 0;
  v28 = (char *)a1[4];
  v30 = ly_set_new(i);
  if ( !v30 )
  {
    sub_12222((__int64)v29, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_schema_leafref", v4);
    return 0xFFFFFFFFLL;
  }
  for ( j = lys_parent(a2); j && !(*(_DWORD *)(j + 56) & 0x4180); j = lys_parent(j) )
    ;
  v31 = (__int64 *)lys_node_module(a2);
  do
  {
    l = sub_17055((__int64)v31, v28, (const char **)&v22, (unsigned int *)&v16, &s2, (unsigned int *)&v17, &v18, &v19);
    if ( l <= 0 )
    {
      sub_13937(v29, 55, 2u, (char *)a2, (unsigned int)v28[-l], (__int64)&v28[-l]);
      ly_set_free(v30);
      return 0xFFFFFFFFLL;
    }
    v28 += l;
    if ( v22 )
      v5 = (__int64 *)sub_407F3(v31, 0LL, 0, v22, v16, 0);
    else
      v5 = v31;
    v32 = v5;
    if ( !v5 )
    {
      sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
      ly_set_free(v30);
      return 1LL;
    }
    v27 = 0LL;
    if ( v21 )
    {
      if ( v18 == -1 )
      {
        i = 0LL;
      }
      else
      {
        if ( v18 <= 0 )
        {
          sub_12222(
            (__int64)v29,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            4274LL);
          ly_set_free(v30);
          return 0xFFFFFFFFLL;
        }
        l = 0;
        i = a2;
        while ( l < v18 )
        {
          for ( i = lys_parent(i); i && !(*(_DWORD *)(i + 56) & 0x4191); i = lys_parent(i) )
            ;
          if ( !i )
          {
            if ( l != v18 - 1 )
            {
              sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
              ly_set_free(v30);
              return 1LL;
            }
            break;
          }
          ++l;
        }
      }
    }
    if ( *((_BYTE *)v32 + 64) >= 0 && i )
      goto LABEL_39;
    while ( 2 )
    {
      if ( v27 )
        v6 = v27;
      else
        v6 = i;
      k = v6;
      i = 0LL;
      do
      {
        i = lys_getnext(i, k, v32, 256LL);
        if ( !i )
          break;
        v7 = lys_node_module(i);
      }
      while ( v7 != lys_main_module(v32) || strncmp(*(const char **)i, s2, v17) || *(_BYTE *)(*(_QWORD *)i + v17) );
      if ( !i )
      {
        if ( !v27 )
        {
          sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
          ly_set_free(v30);
          return 1LL;
        }
        i = *(_QWORD *)(v27 + 88);
LABEL_39:
        v27 = sub_AA881(v27, (__int64)v32, i);
        continue;
      }
      break;
    }
    if ( v21 )
    {
      for ( k = a2; lys_parent(k); k = lys_parent(k) )
        ;
      v8 = v18 == -1;
      v9 = lys_node_module(k);
      if ( (unsigned int)sub_1FEA6(j, v9, i, v8) )
      {
        v10 = *(_WORD *)(a2 + 24);
        HIBYTE(v10) |= 8u;
        *(_WORD *)(a2 + 24) = v10;
      }
      v21 = 0;
    }
    if ( v19 )
    {
      if ( *(_DWORD *)(i + 56) != 16 )
      {
        sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
        ly_set_free(v30);
        return 0xFFFFFFFFLL;
      }
      l = sub_1FF4C(v28, i, (char *)a2, v30);
      if ( !l )
      {
        ly_set_free(v30);
        return 1LL;
      }
      if ( l < 0 )
      {
        ly_set_free(v30);
        return 0xFFFFFFFFLL;
      }
      v28 += l;
      v19 = 0;
    }
  }
  while ( *v28 );
  if ( *(_DWORD *)(i + 56) == 4 || *(_DWORD *)(i + 56) == 8 )
  {
    if ( (unsigned int)sub_3C749(
                         *(_WORD *)(a2 + 24),
                         *(void ***)(a2 + 48),
                         *(_QWORD *)a2,
                         *(_WORD *)(i + 24),
                         *(_QWORD *)(i + 48),
                         *(_QWORD *)i,
                         (char *)i) )
    {
      ly_set_free(v30);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      a1[5] = i;
      ly_set_add(v30, i, 0LL);
      for ( i = a2; lys_parent(i); i = lys_parent(i) )
        ;
      if ( *(_BYTE *)(lys_node_module(i) + 64) & 0x80 )
      {
        for ( l = 0; *(_DWORD *)(v30 + 4) > (unsigned int)l; ++l )
        {
          for ( i = *(_QWORD *)(8LL * l + *(_QWORD *)(v30 + 8)); i; i = lys_parent(i) )
          {
            if ( !(*(_BYTE *)(lys_node_module(i) + 64) & 0x80) )
            {
              v13 = lys_node_module(i);
              *(_BYTE *)(v13 + 64) |= 0x80u;
              v14 = (__int64 *)lys_node_module(i);
              if ( (unsigned int)sub_2ABDE(v14, v15, 0LL, 0x8000u, 0LL) == -1 )
              {
                ly_set_free(v30);
                return 0xFFFFFFFFLL;
              }
            }
          }
          if ( (unsigned int)sub_A7706(*(_QWORD *)(8LL * l + *(_QWORD *)(v30 + 8)), a1[3], a1[3], 8LL * l, v11, v12) )
          {
            ly_set_free(v30);
            return 0xFFFFFFFFLL;
          }
        }
      }
      ly_set_free(v30);
      result = sub_20624((__int64)a1);
    }
  }
  else
  {
    sub_13937(v29, 46, 2u, (char *)a2, (__int64)"leafref", a1[4]);
    sub_13937(v29, -1, 5u, 0LL, (__int64)"Leafref target \"%s\" is not a leaf nor a leaf-list.", a1[4]);
    ly_set_free(v30);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 7950: using guessed type __int64  lys_main_module(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000021572) ----------------------------------------------------
__int64  sub_21572(__int64 a1, __int64 a2, int a3, char *a4)
{
  int v4; // ST2C_4
  char *s2; // [rsp+0h] [rbp-90h]
  unsigned int v7; // [rsp+24h] [rbp-6Ch]
  __int64 v8; // [rsp+28h] [rbp-68h]
  __int64 s; // [rsp+30h] [rbp-60h]
  char *s1; // [rsp+68h] [rbp-28h]
  int v11; // [rsp+78h] [rbp-18h]
  unsigned __int64 v12; // [rsp+88h] [rbp-8h]

  v4 = a3;
  s2 = a4;
  v12 = __readfsqword(0x28u);
  v8 = a1;
  memset(&s, 0, 0x50uLL);
  s1 = (char *)lydict_insert(**(_QWORD **)(a1 + 48), a2, v4);
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + 128);
    s = a1;
    if ( v11 != 9 )
      break;
    if ( !*(_QWORD *)(v8 + 168) )
    {
      sub_12222(
        **(_QWORD **)(a1 + 48),
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        4421LL,
        s2);
      v7 = -1;
      goto LABEL_9;
    }
    v8 = *(_QWORD *)(v8 + 168);
  }
  if ( sub_37EF5(v8 + 128, &s1, 0LL, (__int64 **)&s, 0LL, 0LL, 0, 0, 0) )
    v7 = strcmp(s1, s2) == 0;
  else
    v7 = -1;
LABEL_9:
  lydict_remove(**(_QWORD **)(a1 + 48), s1);
  return v7;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (000000000002170F) ----------------------------------------------------
signed __int64  sub_2170F(__int64 a1, __int64 a2, __int64 **a3, int a4)
{
  __int64 v5; // rbx
  const char *v6; // rax
  __int64 v7; // rbx
  const char *v8; // rax
  __int64 v9; // rbx
  const char *v10; // rax
  __int64 v11; // r9
  int v12; // [rsp+4h] [rbp-8Ch]
  __int64 **v13; // [rsp+8h] [rbp-88h]
  unsigned int v14; // [rsp+28h] [rbp-68h]
  unsigned int v15; // [rsp+2Ch] [rbp-64h]
  int v16; // [rsp+30h] [rbp-60h]
  int v17; // [rsp+34h] [rbp-5Ch]
  int i; // [rsp+38h] [rbp-58h]
  unsigned int v19; // [rsp+3Ch] [rbp-54h]
  char *s2; // [rsp+40h] [rbp-50h]
  char *nptr; // [rsp+48h] [rbp-48h]
  __int64 v22; // [rsp+50h] [rbp-40h]
  __int64 j; // [rsp+58h] [rbp-38h]
  void *ptr; // [rsp+60h] [rbp-30h]
  __int64 v25; // [rsp+68h] [rbp-28h]
  void *v26; // [rsp+70h] [rbp-20h]
  unsigned __int64 v27; // [rsp+78h] [rbp-18h]

  v13 = a3;
  v12 = a4;
  v27 = __readfsqword(0x28u);
  ptr = 0LL;
  v25 = 0LL;
  v26 = *(void **)a1;
  if ( !a2 || !a3 || !*a3 )
    __assert_fail(
      "pred && node && *node",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1175u,
      "resolve_instid_predicate");
  v19 = 0;
  do
  {
    i = sub_17401((_BYTE *)((signed int)v19 + a2), &s2, &v14, &nptr, &v15, (char **)&v22, &v16, &v17);
    if ( i <= 0 )
      return i - v19;
    v19 += i;
    if ( *v13 )
    {
      if ( *nptr == 46 )
      {
        if ( *(_DWORD *)(**v13 + 56) != 8 )
        {
          v5 = *(_QWORD *)**v13;
          v6 = sub_8164(*(_DWORD *)(**v13 + 56));
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects leaf-list, but have %s \"%s\".",
            (__int64)v6,
            v5);
          v19 = -1;
          goto LABEL_62;
        }
        if ( !(unsigned int)sub_21572(**v13, v22, v16, (char *)(*v13)[7]) )
        {
          *v13 = 0LL;
          goto LABEL_62;
        }
      }
      else if ( (*__ctype_b_loc())[*nptr] & 0x800 )
      {
        if ( v22 )
          __assert_fail(
            "!value",
            "/home/mantovan/Repositories/libyang/src/resolve.c",
            0x1194u,
            "resolve_instid_predicate");
        if ( *(_DWORD *)(**v13 + 56) != 16 )
        {
          v7 = *(_QWORD *)**v13;
          v8 = sub_8164(*(_DWORD *)(**v13 + 56));
          sub_13937(v26, -1, 0, 0LL, (__int64)"Instance identifier expects list, but have %s \"%s\".", (__int64)v8, v7);
          v19 = -1;
          goto LABEL_62;
        }
        if ( *(_QWORD *)(**v13 + 136) )
        {
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects list without keys, but have list \"%s\".",
            *(_QWORD *)**v13);
          v19 = -1;
          goto LABEL_62;
        }
        if ( v12 != atoi(nptr) )
        {
          *v13 = 0LL;
          goto LABEL_62;
        }
      }
      else
      {
        if ( *(_DWORD *)(**v13 + 56) != 16 )
        {
          v9 = *(_QWORD *)**v13;
          v10 = sub_8164(*(_DWORD *)(**v13 + 56));
          sub_13937(v26, -1, 0, 0LL, (__int64)"Instance identifier expects list, but have %s \"%s\".", (__int64)v10, v9);
          v19 = -1;
          goto LABEL_62;
        }
        v25 = **v13;
        if ( !ptr )
        {
          ptr = malloc(8LL * *(unsigned __int8 *)(v25 + 30));
          if ( !ptr )
          {
            sub_12222((__int64)v26, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_instid_predicate", v11);
            return 0xFFFFFFFFLL;
          }
          for ( i = 0; i < *(unsigned __int8 *)(v25 + 30); ++i )
            *((_QWORD *)ptr + i) = *(_QWORD *)(8LL * i + *(_QWORD *)(v25 + 136));
        }
        for ( i = 0;
              i < *(unsigned __int8 *)(v25 + 30)
           && (!*((_QWORD *)ptr + i)
            || strncmp(**((const char ***)ptr + i), nptr, (signed int)v15)
            || *(_BYTE *)(**((_QWORD **)ptr + i) + (signed int)v15));
              ++i )
        {
          ;
        }
        if ( i == *(unsigned __int8 *)(v25 + 30) )
        {
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects list with the key \"%.*s\", but list \"%s\" does not define it.",
            v15,
            nptr,
            *(_QWORD *)v25);
          v19 = -1;
          goto LABEL_62;
        }
        if ( s2 )
        {
          if ( strncmp(*(const char **)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL), s2, (signed int)v14)
            || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL) + (signed int)v14) )
          {
            sub_13937(
              v26,
              -1,
              0,
              0LL,
              (__int64)"Instance identifier expects key \"%s\" from module \"%.*s\", not \"%s\".",
              **((_QWORD **)ptr + i),
              s2,
              v14,
              *(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL));
            v19 = -1;
            goto LABEL_62;
          }
        }
        else if ( a1 != *(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) )
        {
          sub_13937(
            v26,
            -1,
            0,
            0LL,
            (__int64)"Instance identifier expects key \"%s\" from module \"%s\", not \"%s\".",
            **((_QWORD **)ptr + i),
            *(_QWORD *)(a1 + 8),
            *(_QWORD *)(*(_QWORD *)(*((_QWORD *)ptr + i) + 48LL) + 8LL));
          v19 = -1;
          goto LABEL_62;
        }
        for ( j = (*v13)[8]; j && *(_QWORD *)j != *((_QWORD *)ptr + i); j = *(_QWORD *)(j + 24) )
          ;
        if ( !j )
        {
          sub_12222(
            (__int64)v26,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            4581LL);
          v19 = -1;
          goto LABEL_62;
        }
        if ( (unsigned int)sub_21572(*(_QWORD *)j, v22, v16, *(char **)(j + 56)) )
          *((_QWORD *)ptr + i) = 0LL;
        else
          *v13 = 0LL;
      }
    }
  }
  while ( v17 );
  if ( *v13 && ptr )
  {
    for ( i = 0; i < *(unsigned __int8 *)(v25 + 30); ++i )
    {
      if ( *((_QWORD *)ptr + i) )
      {
        sub_13937(v26, -1, 0, 0LL, (__int64)"Instance identifier is missing list key \"%s\".", **((_QWORD **)ptr + i));
        v19 = -1;
        break;
      }
    }
  }
LABEL_62:
  free(ptr);
  return v19;
}

//----- (0000000000021FB6) ----------------------------------------------------
signed __int64  sub_21FB6(__int64 a1, int a2)
{
  int v3; // [rsp+14h] [rbp-5Ch]
  __int64 v4; // [rsp+18h] [rbp-58h]
  char s; // [rsp+20h] [rbp-50h]
  void *ptr; // [rsp+30h] [rbp-40h]
  unsigned __int64 v7; // [rsp+68h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  if ( a2 )
  {
    v4 = a1;
    while ( v4 )
    {
      if ( *(_DWORD *)(v4 + 56) == 2048 )
        return 0LL;
      if ( *(_DWORD *)(v4 + 56) == 0x2000 )
      {
        if ( !*(_QWORD *)(v4 + 88) )
          return 1LL;
        v4 = *(_QWORD *)(v4 + 88);
      }
      else
      {
        v4 = *(_QWORD *)(v4 + 64);
      }
    }
  }
  memset(&s, 0, 0x40uLL);
  sub_141E4(0LL, 3u, &v3, 0LL);
  sub_DD261(a1, (void **)&s, 1);
  sub_142D2(0LL, v3, 0LL, 0);
  if ( ptr )
    free(ptr);
  return 0LL;
}

//----- (00000000000220D4) ----------------------------------------------------
signed __int64  sub_220D4(__int64 a1, __int64 a2)
{
  const char *v2; // rbx
  const char *v3; // rax
  unsigned int i; // [rsp+1Ch] [rbp-14h]

  if ( *(_DWORD *)a2 == 9 )
  {
    if ( *(_WORD *)(a1 + 24) & 1
      && *(_QWORD *)(a2 + 40)
      && *(_BYTE *)(a2 + 48) != -1
      && *(_WORD *)(*(_QWORD *)(a2 + 40) + 24LL) & 2 )
    {
      v2 = sub_8164(*(_DWORD *)(*(_QWORD *)(a2 + 40) + 56LL));
      v3 = sub_8164(*(_DWORD *)(a1 + 56));
      sub_13937(
        **(void ***)(a1 + 48),
        -1,
        2u,
        (char *)a1,
        (__int64)"The leafref %s is config but refers to a non-config %s.",
        (__int64)v3,
        v2);
      return 0xFFFFFFFFLL;
    }
  }
  else if ( *(_DWORD *)a2 == 11 )
  {
    for ( i = 0; i < *(_DWORD *)(a2 + 40); ++i )
    {
      if ( (unsigned int)sub_220D4(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)i << 6)) )
        return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (0000000000022209) ----------------------------------------------------
signed __int64  sub_22209(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 v4; // r9
  unsigned __int64 v5; // [rsp+0h] [rbp-20h]
  __int64 v6; // [rsp+8h] [rbp-18h]
  void *v7; // [rsp+10h] [rbp-10h]

  v6 = a1;
  v5 = __PAIR__(a2, a3);
  if ( !a1 )
    return 0LL;
  if ( a2 & 0xFFFFFFFC )
    __assert_fail(
      "!(flags ^ (flags & LYS_CONFIG_MASK))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x125Bu,
      "inherit_config_flag");
  v7 = **(void ***)(a1 + 48);
  while ( v6 )
  {
    if ( (_DWORD)v5 )
    {
      *(_WORD *)(v6 + 24) &= 0xFFFCu;
      *(_WORD *)(v6 + 24) &= 0xFFFBu;
    }
    else
    {
      if ( *(_WORD *)(v6 + 24) & 4 )
      {
        if ( v5 & 0x200000000LL && *(_WORD *)(v6 + 24) & 1 )
        {
          sub_13937(v7, 10, 2u, (char *)v6, (__int64)"true", (__int64)"config", v5);
          sub_13937(v7, -1, 5u, 0LL, (__int64)"State nodes cannot have configuration nodes as children.", v4);
          return 0xFFFFFFFFLL;
        }
        goto LABEL_23;
      }
      if ( !(*(_DWORD *)(v6 + 56) & 0x1800) )
      {
        *(_WORD *)(v6 + 24) = *(_WORD *)(v6 + 24) & 0xFFFC | WORD2(v5);
        if ( *(_DWORD *)(v6 + 56) == 16 && *(_WORD *)(v6 + 24) & 1 && !*(_BYTE *)(v6 + 30) )
        {
          sub_13937(v7, 12, 2u, (char *)v6, (__int64)"key", (__int64)"list", v5);
          return 0xFFFFFFFFLL;
        }
      }
    }
    if ( *(_DWORD *)(v6 + 56) & 0x802C )
    {
      if ( *(_DWORD *)(v6 + 56) & 0xC && (unsigned int)sub_220D4(v6, v6 + 128) )
        return 0xFFFFFFFFLL;
    }
    else if ( (unsigned int)sub_22209(*(_QWORD *)(v6 + 72), a2, (unsigned int)v5) )
    {
      return 0xFFFFFFFFLL;
    }
LABEL_23:
    v6 = *(_QWORD *)(v6 + 80);
  }
  return 0LL;
}

//----- (000000000002245A) ----------------------------------------------------
signed __int64  sub_2245A(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v4; // rdi
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rax
  __int64 *v9; // rax
  __int64 v10; // rbx
  const char *v11; // rax
  const char *v12; // rbx
  const char *v13; // rax
  const char *v14; // rax
  const char *v15; // rbx
  const char *v16; // rax
  const char *v17; // rax
  const char *v18; // rbx
  const char *v19; // rax
  const char *v20; // rax
  __int64 v21; // r9
  __int64 v22; // rax
  void *v23; // rax
  __int64 v24; // rax
  char v25; // al
  __int64 v26; // [rsp+8h] [rbp-68h]
  __int64 v27; // [rsp+18h] [rbp-58h]
  unsigned int v28; // [rsp+24h] [rbp-4Ch]
  __int64 v29; // [rsp+28h] [rbp-48h]
  __int64 i; // [rsp+30h] [rbp-40h]
  __int64 v31; // [rsp+38h] [rbp-38h]
  __int64 v32; // [rsp+40h] [rbp-30h]
  void *v33; // [rsp+48h] [rbp-28h]
  _WORD *v34; // [rsp+50h] [rbp-20h]
  unsigned __int64 v35; // [rsp+58h] [rbp-18h]

  v27 = a1;
  v26 = a3;
  v35 = __readfsqword(0x28u);
  if ( !a1 )
    __assert_fail("aug", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1299u, "resolve_augment");
  v32 = lys_main_module(*(_QWORD *)(a1 + 48));
  v33 = *(void **)v32;
  *(_WORD *)(a1 + 24) |= 1u;
  if ( !*(_QWORD *)(a1 + 88) )
  {
    if ( a2 )
      v4 = 0LL;
    else
      v4 = lys_node_module(a1);
    if ( (unsigned int)sub_1A193(*(char **)v27, a2, v4, &v29, 0, 0) == -1 )
    {
      sub_13937(v33, -2, 2u, (char *)v27, v5, v6);
      return 0xFFFFFFFFLL;
    }
    if ( !v29 )
    {
      sub_13937(v33, 36, 2u, (char *)v27, (__int64)"augment", *(_QWORD *)v27);
      return 1LL;
    }
    *(_QWORD *)(v27 + 88) = **(_QWORD **)(v29 + 8);
    ly_set_free(v29);
  }
  if ( *(_BYTE *)(v32 + 64) < 0 && !(*(_BYTE *)(lys_node_module(*(_QWORD *)(v27 + 88)) + 64) & 0x80) )
  {
    v8 = lys_node_module(*(_QWORD *)(v27 + 88));
    *(_BYTE *)(v8 + 64) |= 0x80u;
    v9 = (__int64 *)lys_node_module(*(_QWORD *)(v27 + 88));
    if ( (unsigned int)sub_2ABDE(v9, v26, 0LL, 0x8000u, 0LL) == -1 )
      return 0xFFFFFFFFLL;
  }
  if ( !*(_QWORD *)(v27 + 64) )
  {
    v10 = lys_node_module(v27);
    if ( v10 != lys_node_module(*(_QWORD *)(v27 + 88)) )
    {
      v28 = sub_3C596((__int64 *)v27, *(_QWORD *)(v27 + 88));
      if ( v28 )
        return v28;
    }
  }
  if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) & 0x11 )
  {
    for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_DWORD *)(i + 56) & 0xD0BF) )
      {
        v11 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(v33, 6, 2u, (char *)v27, (__int64)v11, (__int64)"augment");
        v12 = sub_8164(*(_DWORD *)(i + 56));
        v13 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
        sub_13937(v33, -1, 5u, 0LL, (__int64)"Cannot augment \"%s\" with a \"%s\".", (__int64)v13, v12);
        return 0xFFFFFFFFLL;
      }
    }
  }
  else if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) & 0x6C0 )
  {
    for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_DWORD *)(i + 56) & 0x903F) )
      {
        v14 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(v33, 6, 2u, (char *)v27, (__int64)v14, (__int64)"augment");
        v15 = sub_8164(*(_DWORD *)(i + 56));
        v16 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
        sub_13937(v33, -1, 5u, 0LL, (__int64)"Cannot augment \"%s\" with a \"%s\".", (__int64)v16, v15);
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) != 2 )
    {
      sub_13937(v33, 10, 2u, (char *)v27, *(_QWORD *)v27, (__int64)"target-node");
      v20 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
      sub_13937(v33, -1, 5u, 0LL, (__int64)"Invalid augment target node type \"%s\".", (__int64)v20);
      return 0xFFFFFFFFLL;
    }
    for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
    {
      if ( !(*(_DWORD *)(i + 56) & 0x807D) )
      {
        v17 = sub_8164(*(_DWORD *)(i + 56));
        sub_13937(v33, 6, 2u, (char *)v27, (__int64)v17, (__int64)"augment");
        v18 = sub_8164(*(_DWORD *)(i + 56));
        v19 = sub_8164(*(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL));
        sub_13937(v33, -1, 5u, 0LL, (__int64)"Cannot augment \"%s\" with a \"%s\".", (__int64)v19, v18);
        return 0xFFFFFFFFLL;
      }
    }
  }
  for ( i = *(_QWORD *)(v27 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( (unsigned int)sub_9C05E(i, *(_QWORD *)(v27 + 88), 0LL) )
      return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(*(_QWORD *)(v27 + 88) + 56LL) == 2 )
  {
    for ( i = *(_QWORD *)(v27 + 72); ; i = v31 )
    {
      if ( i )
      {
        v31 = *(_QWORD *)(i + 80);
        v25 = 1;
      }
      else
      {
        v25 = 0;
      }
      if ( !v25 )
        break;
      if ( *(_DWORD *)(i + 56) != 64 )
      {
        v34 = calloc(1uLL, 0x70uLL);
        if ( !v34 )
        {
          sub_12222((__int64)v33, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_augment", v21);
          return 1LL;
        }
        v22 = lydict_insert(v33, *(_QWORD *)i, 0LL);
        *(_QWORD *)v34 = v22;
        v34[12] = *(_WORD *)(i + 24) & 3 | 0x40;
        *((_QWORD *)v34 + 6) = *(_QWORD *)(i + 48);
        *((_DWORD *)v34 + 14) = 64;
        *((_QWORD *)v34 + 8) = *(_QWORD *)(i + 64);
        if ( i == *(_QWORD *)(i + 88) )
          v23 = v34;
        else
          v23 = *(void **)(i + 88);
        *((_QWORD *)v34 + 11) = v23;
        if ( *(_QWORD *)(*((_QWORD *)v34 + 11) + 80LL) )
          *(_QWORD *)(*((_QWORD *)v34 + 11) + 80LL) = v34;
        else
          *(_QWORD *)(*((_QWORD *)v34 + 8) + 72LL) = v34;
        *((_QWORD *)v34 + 10) = *(_QWORD *)(i + 80);
        if ( *((_QWORD *)v34 + 10) )
          v24 = *((_QWORD *)v34 + 10);
        else
          v24 = *(_QWORD *)(*((_QWORD *)v34 + 8) + 72LL);
        *(_QWORD *)(v24 + 88) = v34;
        *((_QWORD *)v34 + 9) = i;
        *(_QWORD *)(i + 88) = i;
        *(_QWORD *)(i + 80) = 0LL;
        *(_QWORD *)(i + 64) = v34;
      }
    }
  }
  if ( *(_QWORD *)(v27 + 72) )
  {
    if ( (*(_QWORD *)(v27 + 64) || *(_BYTE *)(v32 + 64) < 0) && (unsigned int)sub_A7ED6(v27, v26) )
      return 0xFFFFFFFFLL;
  }
  else
  {
    sub_12222((__int64)v33, 1u, 0, "Augment \"%s\" without children.", *(_QWORD *)v27, v3);
    *(_WORD *)(v27 + 24) &= 0xFFFEu;
  }
  return 0LL;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 7950: using guessed type __int64  lys_main_module(_QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000022CDC) ----------------------------------------------------
signed __int64  sub_22CDC(_QWORD *a1, __int64 **a2, __int64 a3)
{
  unsigned int v3; // eax
  __int64 v4; // r9
  int v6; // edx
  __int16 v7; // ax
  __int64 *v8; // rbx
  __int64 *v9; // rbx
  __int64 *v10; // rbx
  char v11; // al
  __int16 v12; // dx
  char v13; // al
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 v16; // r9
  int v17; // edx
  __int16 v18; // ax
  __int16 v19; // dx
  __int64 v20; // r9
  __int64 v21; // [rsp+8h] [rbp-88h]
  unsigned int v22; // [rsp+20h] [rbp-70h]
  unsigned int i; // [rsp+24h] [rbp-6Ch]
  unsigned int k; // [rsp+24h] [rbp-6Ch]
  unsigned int n; // [rsp+24h] [rbp-6Ch]
  unsigned int jj; // [rsp+24h] [rbp-6Ch]
  unsigned int j; // [rsp+28h] [rbp-68h]
  unsigned int ii; // [rsp+28h] [rbp-68h]
  int v29; // [rsp+2Ch] [rbp-64h]
  int v30; // [rsp+2Ch] [rbp-64h]
  char *v31; // [rsp+30h] [rbp-60h]
  unsigned __int64 v32; // [rsp+38h] [rbp-58h]
  unsigned __int64 v33; // [rsp+38h] [rbp-58h]
  _QWORD *v34; // [rsp+40h] [rbp-50h]
  _QWORD *l; // [rsp+48h] [rbp-48h]
  _QWORD *m; // [rsp+48h] [rbp-48h]
  void *v37; // [rsp+50h] [rbp-40h]
  void *v38; // [rsp+50h] [rbp-40h]
  char *s; // [rsp+58h] [rbp-38h]
  char *v40; // [rsp+60h] [rbp-30h]
  _BYTE *v41; // [rsp+68h] [rbp-28h]
  _QWORD *v42; // [rsp+70h] [rbp-20h]
  __int64 v43; // [rsp+70h] [rbp-20h]
  __int64 *v44; // [rsp+78h] [rbp-18h]

  v21 = a3;
  v3 = *((_DWORD *)a1 + 8);
  if ( v3 == 1 )
  {
    v31 = (char *)a1[2];
    v22 = 2;
  }
  else if ( v3 >= 1 && v3 - 15 > 1 )
  {
    v31 = 0LL;
    v22 = 0;
  }
  else
  {
    v31 = 0LL;
    v22 = 2;
  }
  if ( *((_DWORD *)a1 + 2) == 2 )
  {
    v42 = (_QWORD *)sub_40BA1(a1[3], *(_BYTE **)(*(_QWORD *)(*a1 + 56LL) + 32LL));
    if ( !v42 )
    {
      sub_13937(0LL, 5, v22, v31, *(_QWORD *)(*a1 + 48LL), v4);
      return 1LL;
    }
    v37 = (void *)*v42;
    v32 = 0LL;
    for ( i = 0; i < *((unsigned __int8 *)v42 + 79); ++i )
    {
      if ( *(_QWORD *)(((unsigned __int64)i << 6) + v42[19]) == *(_QWORD *)(*a1 + 48LL) )
      {
        v32 = ((unsigned __int64)i << 6) + v42[19];
        break;
      }
    }
    for ( j = 0; !v32 && j < *((unsigned __int8 *)v42 + 70); ++j )
    {
      for ( k = 0; k < *(unsigned __int8 *)(*(_QWORD *)(v42[13] + 48LL * j) + 79LL); ++k )
      {
        if ( *(_QWORD *)(((unsigned __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(v42[13] + 48LL * j) + 152LL)) == *(_QWORD *)(*a1 + 48LL) )
        {
          v32 = ((unsigned __int64)k << 6) + *(_QWORD *)(*(_QWORD *)(v42[13] + 48LL * j) + 152LL);
          break;
        }
      }
    }
    if ( !v32 )
    {
      sub_13937(v37, 5, v22, v31, *(_QWORD *)(*a1 + 48LL), v4);
      return 1LL;
    }
    if ( *(_QWORD *)(v32 + 56)
      && *(_QWORD *)(*(_QWORD *)(v32 + 56) + 8LL)
      && (*(unsigned int ( **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v32 + 56) + 8LL))(
           a1[2],
           *((unsigned int *)a1 + 8),
           *((unsigned int *)a1 + 9)) )
    {
      sub_13937(v37, 5, v22, v31, *(_QWORD *)v32, v4);
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(v32 + 56) )
      v29 = **(_DWORD **)(v32 + 56);
    else
      v29 = 0;
    if ( v29 )
    {
      if ( v29 == 1 )
      {
        *a2 = (__int64 *)calloc(1uLL, *(_QWORD *)(*(_QWORD *)(v32 + 56) + 48LL));
      }
      else if ( v29 == -1 )
      {
        sub_12222(
          (__int64)v37,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
          4983LL);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      *a2 = (__int64 *)calloc(1uLL, 0x40uLL);
    }
    if ( !*a2 )
    {
      sub_12222((__int64)v37, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_extension", v4);
      return 0xFFFFFFFFLL;
    }
    **a2 = v32;
    (*a2)[1] = a1[2];
    *((_BYTE *)*a2 + 29) = *((_DWORD *)a1 + 8);
    *((_BYTE *)*a2 + 28) = *((_DWORD *)a1 + 9);
    *((_BYTE *)*a2 + 27) = *((_BYTE *)a1 + 40);
    if ( *(_QWORD *)(v32 + 56) )
      v6 = **(_DWORD **)(v32 + 56);
    else
      LOBYTE(v6) = 0;
    *((_BYTE *)*a2 + 30) = v6;
    if ( *(_QWORD *)(v32 + 56) )
      v7 = *(_WORD *)(*(_QWORD *)(v32 + 56) + 4LL);
    else
      v7 = 0;
    *((_WORD *)*a2 + 12) |= v7;
    if ( *(_QWORD *)(v32 + 40) )
    {
      if ( *(_WORD *)(v32 + 24) & 1 )
      {
        for ( l = *(_QWORD **)(*a1 + 24LL); ; l = v34 )
        {
          if ( l )
          {
            v34 = (_QWORD *)l[4];
            v11 = 1;
          }
          else
          {
            v11 = 0;
          }
          if ( !v11 )
            break;
          if ( l[6] == *(_QWORD *)(v32 + 40) )
          {
            v10 = *a2;
            v10[2] = lydict_insert(*v42, l[8], 0LL);
            lyxml_free(*v42, l);
            break;
          }
        }
      }
      else
      {
        v8 = *a2;
        v8[2] = lyxml_get_attr(*a1, *(_QWORD *)(v32 + 40), 0LL);
        if ( !(*a2)[2] )
        {
          sub_13937(v37, 13, 0, 0LL, *(_QWORD *)(v32 + 40), *(_QWORD *)(*a1 + 48LL));
          return 0xFFFFFFFFLL;
        }
        v9 = *a2;
        v9[2] = lydict_insert(*v42, (*a2)[2], 0LL);
      }
    }
    if ( (*a2)[3] & 8 && (*((_DWORD *)a1 + 8) == 1 || *((_DWORD *)a1 + 8) == 2) )
    {
      v12 = *(_WORD *)(a1[2] + 24LL);
      HIBYTE(v12) |= 0x20u;
      *(_WORD *)(a1[2] + 24LL) = v12;
    }
    *((_DWORD *)*a2 + 14) = 0x10000;
    (*a2)[6] = a1[3];
    if ( v29 )
    {
      if ( v29 == 1 )
      {
        (*a2)[8] = *(_QWORD *)(*(_QWORD *)(v32 + 56) + 40LL);
        if ( (unsigned int)sub_627C3((__int64 *)a1[3], *a2, *a1, v21) )
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      for ( m = *(_QWORD **)(*a1 + 24LL); ; m = v34 )
      {
        if ( m )
        {
          v34 = (_QWORD *)m[4];
          v13 = 1;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
          break;
        if ( m[7] )
        {
          if ( !strcmp(*(const char **)(m[7] + 32LL), "urn:ietf:params:xml:ns:yang:yin:1") )
          {
            sub_13937(v37, 6, v22, v31, m[6], *(_QWORD *)(*a1 + 48LL));
            return 0xFFFFFFFFLL;
          }
          if ( m[7] == *(_QWORD *)(*a1 + 56LL) && *(_WORD *)(v32 + 24) & 1 && m[6] == *(_QWORD *)(v32 + 40) )
          {
            if ( (*a2)[2] )
            {
              sub_13937(v37, 14, v22, v31, m[6], *(_QWORD *)(*a1 + 48LL));
              return 0xFFFFFFFFLL;
            }
            (*a2)[2] = m[8];
            m[8] = 0LL;
            lyxml_free(*v42, m);
          }
          else if ( (unsigned int)sub_411CA((__int64 *)a1[3], (__int64)*a2, 0xBu, m, 0, 0LL, v21) )
          {
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          lyxml_free(*v42, m);
        }
      }
    }
    return 0LL;
  }
  s = (char *)**a2;
  v40 = strchr(s, 58);
  if ( v40 )
  {
    v41 = v40 + 1;
    v43 = sub_407F3((__int64 *)a1[3], s, (signed int)v40 - (signed int)s, 0LL, 0, 0);
    if ( !v43 )
    {
      sub_13937(0LL, 5, v22, v31, (__int64)s, v15);
      return 1LL;
    }
    v38 = *(void **)v43;
    v33 = 0LL;
    for ( n = 0; n < *(unsigned __int8 *)(v43 + 79); ++n )
    {
      if ( (unsigned int)sub_C462(*(_BYTE **)(((unsigned __int64)n << 6) + *(_QWORD *)(v43 + 152)), v41) )
      {
        v33 = ((unsigned __int64)n << 6) + *(_QWORD *)(v43 + 152);
        break;
      }
    }
    for ( ii = 0; !v33 && ii < *(unsigned __int8 *)(v43 + 70); ++ii )
    {
      for ( jj = 0; jj < *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * ii) + 79LL); ++jj )
      {
        if ( (unsigned int)sub_C462(
                             *(_BYTE **)(((unsigned __int64)jj << 6)
                                       + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * ii) + 152LL)),
                             v41) )
        {
          v33 = ((unsigned __int64)jj << 6) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 104) + 48LL * ii) + 152LL);
          break;
        }
      }
    }
    if ( !v33 )
    {
      sub_13937(v38, 5, v22, v31, (__int64)s, v15);
      return 1LL;
    }
    *((_WORD *)*a2 + 12) &= 0xFFFDu;
    **a2 = 0LL;
    if ( *(_QWORD *)(v33 + 56)
      && *(_QWORD *)(*(_QWORD *)(v33 + 56) + 8LL)
      && (*(unsigned int ( **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v33 + 56) + 8LL))(
           a1[2],
           *((unsigned int *)a1 + 8),
           *((unsigned int *)a1 + 9)) )
    {
      sub_13937(v38, 5, v22, v31, *(_QWORD *)v33, v16);
    }
    else if ( !*(_QWORD *)(v33 + 40) || (*a2)[2] )
    {
      **a2 = v33;
      (*a2)[1] = a1[2];
      if ( *(_QWORD *)(v33 + 56) )
        v17 = **(_DWORD **)(v33 + 56);
      else
        LOBYTE(v17) = 0;
      *((_BYTE *)*a2 + 30) = v17;
      if ( *(_QWORD *)(v33 + 56) )
        v18 = *(_WORD *)(*(_QWORD *)(v33 + 56) + 4LL);
      else
        v18 = 0;
      *((_WORD *)*a2 + 12) |= v18;
      if ( (*a2)[3] & 8 && (*((_DWORD *)a1 + 8) == 1 || *((_DWORD *)a1 + 8) == 2) )
      {
        v19 = *(_WORD *)(a1[2] + 24LL);
        HIBYTE(v19) |= 0x20u;
        *(_WORD *)(a1[2] + 24LL) = v19;
      }
      (*a2)[6] = a1[3];
      *((_DWORD *)*a2 + 14) = 0x10000;
      if ( *(_QWORD *)(v33 + 56) )
        v30 = **(_DWORD **)(v33 + 56);
      else
        v30 = 0;
      if ( v30 )
      {
        if ( v30 == 1 )
        {
          v44 = (__int64 *)realloc(*a2, *(_QWORD *)(*(_QWORD *)(v33 + 56) + 48LL));
          if ( !v44 )
          {
            sub_12222((__int64)v38, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_extension", v20);
            goto LABEL_145;
          }
          memset(v44 + 9, 0, *(_QWORD *)(*(_QWORD *)(v33 + 56) + 48LL) - 72LL);
          *a2 = v44;
          (*a2)[8] = *(_QWORD *)(*(_QWORD *)(v33 + 56) + 40LL);
          if ( *a1 )
          {
            *v40 = 58;
            if ( (unsigned int)sub_92FC8((__int64 *)a1[3], v21, *(const char **)*a1, (__int64)s, *a2)
              || (unsigned int)sub_9ACA3(
                                 *(void **)a1[3],
                                 (__int64)*a2,
                                 (__int64)s,
                                 *(_QWORD *)(*a1 + 8LL),
                                 (unsigned __int8)(*(_BYTE *)(a1[3] + 64LL) >> 7)) )
            {
              goto LABEL_145;
            }
          }
          if ( (unsigned int)sub_3E959((__int64)*a2, (__int64)s) )
            goto LABEL_145;
        }
        else if ( v30 == -1 )
        {
          sub_12222(
            (__int64)v38,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            5180LL);
          goto LABEL_145;
        }
      }
      if ( !(unsigned int)sub_9554F((__int64 *)a1[3], *a2 + 4, *((unsigned __int8 *)*a2 + 26), (__int64)*a2, v21) )
      {
        free(s);
        return 0LL;
      }
    }
    else
    {
      sub_13937(v38, 13, 0, 0LL, *(_QWORD *)(v33 + 40), (__int64)v41);
    }
  }
  else
  {
    sub_13937(0LL, 5, v22, v31, (__int64)s, v14);
  }
LABEL_145:
  free(s);
  return 0xFFFFFFFFLL;
}
// 7870: using guessed type __int64  lyxml_get_attr(_QWORD, _QWORD, _QWORD);
// 78A0: using guessed type __int64  lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000023C04) ----------------------------------------------------
__int64  sub_23C04(__int64 a1, __int64 a2)
{
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  for ( i = *(_QWORD *)(a1 + 72); i; i = *(_QWORD *)(i + 80) )
  {
    if ( *(_DWORD *)(i + 56) == 4096 )
    {
      v4 = sub_23C04(i, a2);
      if ( v4 )
        return v4;
    }
    if ( a2 == *(_QWORD *)i && *(_DWORD *)(i + 56) & 0x807F )
      return i;
  }
  return 0LL;
}

//----- (0000000000023C91) ----------------------------------------------------
signed __int64  sub_23C91(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  __int64 v3; // rax
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rbx
  __int16 v11; // dx
  __int64 v12; // rbx
  unsigned int v13; // eax
  __int64 v14; // r9
  _QWORD *v15; // rbx
  signed __int64 v16; // rbx
  signed __int64 v17; // rbx
  signed __int64 v18; // rbx
  signed __int64 v19; // rbx
  __int64 v20; // r9
  void **v21; // rbx
  __int64 v22; // r9
  signed __int64 v23; // rbx
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9
  __int64 v27; // rbx
  __int64 v28; // r9
  __int64 v29; // r9
  const char *v30; // rax
  __int64 v31; // r9
  const char *v32; // rax
  __int64 v33; // r9
  char v35; // al
  unsigned __int8 v36; // [rsp+1Bh] [rbp-B5h]
  unsigned __int8 v37; // [rsp+1Bh] [rbp-B5h]
  unsigned int v38; // [rsp+1Ch] [rbp-B4h]
  unsigned int v39; // [rsp+20h] [rbp-B0h]
  int l; // [rsp+24h] [rbp-ACh]
  int m; // [rsp+28h] [rbp-A8h]
  int v42; // [rsp+2Ch] [rbp-A4h]
  int v43; // [rsp+30h] [rbp-A0h]
  char size[12]; // [rsp+34h] [rbp-9Ch]
  __int64 v45; // [rsp+40h] [rbp-90h]
  __int64 k; // [rsp+48h] [rbp-88h]
  void *ptr; // [rsp+50h] [rbp-80h]
  __int64 i; // [rsp+58h] [rbp-78h]
  __int64 n; // [rsp+60h] [rbp-70h]
  __int64 j; // [rsp+68h] [rbp-68h]
  void **v51; // [rsp+70h] [rbp-60h]
  unsigned __int8 *v52; // [rsp+78h] [rbp-58h]
  void *v53; // [rsp+80h] [rbp-50h]
  __int64 v54; // [rsp+88h] [rbp-48h]
  __int64 v55; // [rsp+90h] [rbp-40h]
  __int64 v56; // [rsp+98h] [rbp-38h]
  _BYTE *v57; // [rsp+A0h] [rbp-30h]
  _QWORD *v58; // [rsp+A8h] [rbp-28h]
  _QWORD *v59; // [rsp+B0h] [rbp-20h]
  unsigned __int64 v60; // [rsp+B8h] [rbp-18h]

  v60 = __readfsqword(0x28u);
  v53 = **(void ***)(a1 + 48);
  *(_QWORD *)&size[4] = 0LL;
  ptr = 0LL;
  if ( !*(_QWORD *)(a1 + 128) )
    __assert_fail("uses->grp", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1481u, "resolve_uses");
  if ( *(_WORD *)(*(_QWORD *)(a1 + 128) + 28LL) )
    __assert_fail(
      "!uses->grp->unres_count",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1484u,
      "resolve_uses");
  for ( i = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 72LL); i; i = *(_QWORD *)(i + 80) )
  {
    if ( !(*(_DWORD *)(i + 56) & 0x800) )
    {
      *(_QWORD *)&size[4] = sub_A60D4(*(__int64 **)(a1 + 48), a1, i, a2, 0);
      if ( !*(_QWORD *)&size[4] )
      {
        sub_13937(v53, 10, 2u, (char *)a1, **(_QWORD **)(a1 + 128), (__int64)"uses", a2);
        sub_13937(v53, -1, 5u, 0LL, (__int64)"Copying data from grouping failed.", v2);
        goto LABEL_188;
      }
      if ( *(_QWORD *)(a1 + 64) )
        v3 = *(_QWORD *)sub_A75EB(*(_QWORD *)(a1 + 64), 0x1000u);
      else
        v3 = *(_QWORD *)(lys_main_module(*(_QWORD *)(a1 + 48)) + 168);
      for ( j = v3; j; j = *(_QWORD *)(j + 80) )
      {
        if ( !(*(_DWORD *)(j + 56) & 0x1840) && *(_QWORD *)j == *(_QWORD *)i )
          goto LABEL_188;
      }
    }
  }
  if ( *(_BYTE *)(a1 + 30) )
  {
    ptr = malloc(8LL * *(unsigned __int8 *)(a1 + 30));
    if ( !ptr )
    {
      sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v4, a2);
LABEL_188:
      for ( k = *(_QWORD *)(a1 + 72); ; k = v45 )
      {
        if ( k )
        {
          v45 = *(_QWORD *)(k + 80);
          v35 = 1;
        }
        else
        {
          v35 = 0;
        }
        if ( !v35 )
          break;
        sub_A33A0((_QWORD **)k, 0LL, 0);
      }
      free(ptr);
      return 0xFFFFFFFFLL;
    }
  }
  for ( l = 0; l < *(unsigned __int8 *)(a1 + 30); ++l )
  {
    v54 = *(_QWORD *)(a1 + 112) + 80LL * l;
    v43 = sub_1AF63(*(const char **)v54, *(_QWORD *)(a1 + 72), 49407, 0, &size[4]);
    if ( v43 || !*(_QWORD *)&size[4] )
    {
      sub_13937(v53, 10, 2u, (char *)a1, *(_QWORD *)v54, (__int64)"refine", a2);
      goto LABEL_188;
    }
    if ( *(_WORD *)(v54 + 28) && !(*(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & *(unsigned __int16 *)(v54 + 28)) )
    {
      sub_13937(v53, 10, 2u, (char *)a1, *(_QWORD *)v54, (__int64)"refine", a2);
      sub_13937(v53, -1, 5u, 0LL, (__int64)"Refine substatements not applicable to the target-node.", v6);
      goto LABEL_188;
    }
    *((_QWORD *)ptr + l) = *(_QWORD *)&size[4];
    if ( *(_QWORD *)(v54 + 8) )
    {
      lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 8LL));
      v7 = *(_QWORD *)&size[4];
      *(_QWORD *)(v7 + 8) = lydict_insert(v53, *(_QWORD *)(v54 + 8), 0LL);
    }
    if ( *(_QWORD *)(v54 + 16) )
    {
      lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 16LL));
      v8 = *(_QWORD *)&size[4];
      *(_QWORD *)(v8 + 16) = lydict_insert(v53, *(_QWORD *)(v54 + 16), 0LL);
    }
    if ( *(_WORD *)(v54 + 24) & 3 && *(_WORD *)(*(_QWORD *)&size[4] + 24LL) & 3 )
    {
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) &= 0xFFFCu;
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) |= *(_WORD *)(v54 + 24) & 3;
    }
    if ( *(_BYTE *)(v54 + 31) )
    {
      if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 4 )
      {
        v55 = *(_QWORD *)&size[4];
        lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 200LL));
        v9 = lydict_insert(v53, **(_QWORD **)(v54 + 64), 0LL);
        *(_QWORD *)(v55 + 200) = v9;
        if ( (unsigned int)sub_2ABDE(
                             *(__int64 **)(v55 + 48),
                             a2,
                             (__int64 *)(v55 + 128),
                             0x1000u,
                             (__int64 *)(v55 + 200)) == -1 )
          goto LABEL_188;
      }
      else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8 )
      {
        v56 = *(_QWORD *)&size[4];
        for ( m = 0; m < *(unsigned __int8 *)(v56 + 30); ++m )
          lydict_remove(v53, *(_QWORD *)(8LL * m + *(_QWORD *)(v56 + 200)));
        free(*(void **)(v56 + 200));
        *(_QWORD *)(v56 + 200) = malloc(8LL * *(unsigned __int8 *)(v54 + 31));
        if ( !*(_QWORD *)(v56 + 200) )
        {
          sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v5, a2);
          goto LABEL_188;
        }
        *(_BYTE *)(v56 + 30) = *(_BYTE *)(v54 + 31);
        for ( m = 0; m < *(unsigned __int8 *)(v56 + 30); ++m )
        {
          v10 = (_QWORD *)(*(_QWORD *)(v56 + 200) + 8LL * m);
          *v10 = lydict_insert(v53, *(_QWORD *)(8LL * m + *(_QWORD *)(v54 + 64)), 0LL);
        }
        for ( m = 0; m < *(unsigned __int8 *)(v56 + 30); ++m )
        {
          if ( (unsigned int)sub_2ABDE(
                               *(__int64 **)(v56 + 48),
                               a2,
                               (__int64 *)(v56 + 128),
                               0x1000u,
                               (__int64 *)(*(_QWORD *)(v56 + 200) + 8LL * m)) == -1 )
            goto LABEL_188;
        }
      }
    }
    if ( *(_WORD *)(v54 + 24) & 0xC0 )
    {
      v11 = *(_WORD *)(*(_QWORD *)&size[4] + 24LL);
      LOBYTE(v11) = v11 & 0x3F;
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) = v11;
      *(_WORD *)(*(_QWORD *)&size[4] + 24LL) |= *(_WORD *)(v54 + 24) & 0xC0;
      if ( *(_WORD *)(v54 + 24) & 0x40 )
      {
        if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & 4 && *(_QWORD *)(*(_QWORD *)&size[4] + 200LL) )
        {
          sub_13937(
            v53,
            -1,
            2u,
            (char *)a1,
            (__int64)"The \"mandatory\" statement is forbidden on leaf with \"default\".",
            v5,
            a2);
          goto LABEL_188;
        }
        if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & 2 && *(_QWORD *)(*(_QWORD *)&size[4] + 112LL) )
        {
          sub_13937(
            v53,
            -1,
            2u,
            (char *)a1,
            (__int64)"The \"mandatory\" statement is forbidden on choices with \"default\".",
            v5,
            a2);
          goto LABEL_188;
        }
      }
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) & 1 && *(_QWORD *)(v54 + 72) )
    {
      lydict_remove(v53, *(_QWORD *)(*(_QWORD *)&size[4] + 136LL));
      v12 = *(_QWORD *)&size[4];
      *(_QWORD *)(v12 + 136) = lydict_insert(v53, *(_QWORD *)(v54 + 72), 0LL);
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 16 )
    {
      if ( *(_WORD *)(v54 + 24) & 0x10 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 152LL) = *(_DWORD *)(v54 + 72);
      if ( *(_WORD *)(v54 + 24) & 8 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 156LL) = *(_DWORD *)(v54 + 76);
    }
    else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8 )
    {
      if ( *(_WORD *)(v54 + 24) & 0x10 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 208LL) = *(_DWORD *)(v54 + 72);
      if ( *(_WORD *)(v54 + 24) & 8 )
        *(_DWORD *)(*(_QWORD *)&size[4] + 212LL) = *(_DWORD *)(v54 + 76);
    }
    if ( *(_BYTE *)(v54 + 30) )
    {
      v13 = *(_DWORD *)(*(_QWORD *)&size[4] + 56LL);
      if ( v13 == 8 )
      {
        v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 31LL);
        v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
      }
      else if ( v13 > 8 )
      {
        if ( v13 == 32 || v13 == 32800 )
        {
          v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 31LL);
          v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
        }
        else
        {
          if ( v13 != 16 )
          {
LABEL_89:
            sub_12222(
              (__int64)v53,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              5432LL,
              a2);
            goto LABEL_188;
          }
          v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 28LL);
          v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
        }
      }
      else if ( v13 == 1 )
      {
        v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 29LL);
        v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
      }
      else
      {
        if ( v13 != 4 )
          goto LABEL_89;
        v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 31LL);
        v51 = (void **)(*(_QWORD *)&size[4] + 120LL);
      }
      v36 = *v52 + *(_BYTE *)(v54 + 30);
      v57 = realloc(*v51, 56LL * v36);
      if ( !v57 )
      {
        sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v14, a2);
        goto LABEL_188;
      }
      v42 = 0;
      m = *v52;
      while ( v42 < *(unsigned __int8 *)(v54 + 30) )
      {
        v57[56 * m + 48] = *(_BYTE *)(56LL * v42 + *(_QWORD *)(v54 + 56) + 48);
        sub_9EB54(
          (__int64)v53,
          *(_QWORD *)(v54 + 48),
          *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 40),
          *(_BYTE *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 48),
          (void *)(*(_QWORD *)(v54 + 56) + 56LL * v42),
          7,
          (__int64 *)&v57[56 * m + 40],
          0,
          a2);
        v15 = &v57[56 * m];
        *v15 = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42), 0LL);
        v16 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v16 + 8) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 8), 0LL);
        v17 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v17 + 16) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 16), 0LL);
        v18 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v18 + 24) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 24), 0LL);
        v19 = (signed __int64)&v57[56 * m];
        *(_QWORD *)(v19 + 32) = lydict_insert(v53, *(_QWORD *)(*(_QWORD *)(v54 + 56) + 56LL * v42 + 32), 0LL);
        *(_WORD *)&v57[56 * m++ + 50] = *(_WORD *)(56LL * v42++ + *(_QWORD *)(v54 + 56) + 50);
      }
      *v51 = v57;
      *v52 = v36;
      if ( (unsigned int)sub_2ABDE(*(__int64 **)(*(_QWORD *)&size[4] + 48LL), a2, *(__int64 **)&size[4], 0x20000u, 0LL) == -1 )
        goto LABEL_188;
    }
    if ( *(_BYTE *)(v54 + 27) )
    {
      v52 = (unsigned __int8 *)(*(_QWORD *)&size[4] + 27LL);
      v58 = (_QWORD *)(*(_QWORD *)&size[4] + 40LL);
      v37 = *(_BYTE *)(*(_QWORD *)&size[4] + 27LL) + *(_BYTE *)(v54 + 27);
      v59 = realloc(*(void **)(*(_QWORD *)&size[4] + 40LL), 32LL * v37);
      if ( !v59 )
      {
        sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v20, a2);
        goto LABEL_188;
      }
      *v58 = v59;
      v42 = 0;
      m = *v52;
      while ( v42 < *(unsigned __int8 *)(v54 + 27) )
      {
        sub_1902D((__int64 *)(*(_QWORD *)(v54 + 40) + 32LL * v42), (int *)&v38, &v39);
        if ( v38 )
        {
          *(_DWORD *)size = (v38 >> 2) + (v38 & 3) != 0;
          v21 = (void **)&v59[4 * m];
          *v21 = malloc((v38 >> 2) + (v38 & 3) != 0);
          if ( !v59[4 * m] )
          {
            sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v22, a2);
            goto LABEL_188;
          }
          memcpy((void *)v59[4 * m], *(const void **)(32LL * v42 + *(_QWORD *)(v54 + 40)), *(unsigned int *)size);
          v23 = (signed __int64)&v59[4 * m];
          *(_QWORD *)(v23 + 16) = malloc(8LL * v39);
          if ( !v59[4 * m] )
          {
            sub_12222((__int64)v53, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_uses", v24, a2);
            goto LABEL_188;
          }
          memcpy((void *)v59[4 * m + 2], *(const void **)(32LL * v42 + *(_QWORD *)(v54 + 40) + 16), 8LL * v39);
          LOBYTE(v59[4 * m + 1]) = *(_BYTE *)(32LL * v42 + *(_QWORD *)(v54 + 40) + 8);
          sub_9EB54(
            (__int64)v53,
            *(_QWORD *)(v54 + 48),
            *(_QWORD *)(32LL * v42 + *(_QWORD *)(v54 + 40) + 24),
            *(_BYTE *)(32LL * v42 + *(_QWORD *)(v54 + 40) + 8),
            (void *)(*(_QWORD *)(v54 + 40) + 32LL * v42),
            18,
            &v59[4 * m + 3],
            0,
            a2);
        }
        ++*v52;
        ++v42;
        ++m;
      }
      if ( v37 != *v52 )
        __assert_fail("*old_size == size", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1574u, "resolve_uses");
    }
  }
  for ( l = 0; l < *(unsigned __int8 *)(a1 + 31); ++l )
  {
    v43 = sub_2245A(104LL * l + *(_QWORD *)(a1 + 120), a1, a2);
    if ( v43 )
      goto LABEL_188;
  }
  for ( l = 0; l < *(unsigned __int8 *)(a1 + 30); ++l )
  {
    *(_QWORD *)&size[4] = *((_QWORD *)ptr + l);
    v54 = *(_QWORD *)(a1 + 112) + 80LL * l;
    if ( *(_WORD *)(v54 + 24) & 3 && *(_WORD *)(*(_QWORD *)&size[4] + 24LL) & 3 )
    {
      for ( n = lys_parent(*(_QWORD *)&size[4]); n && *(_DWORD *)(n + 56) == 4096; n = lys_parent(n) )
        ;
      if ( n
        && *(_DWORD *)(n + 56) != 2048
        && *(_WORD *)(n + 24) & 3
        && ((unsigned __int8)*(_WORD *)(n + 24) ^ (unsigned __int8)*(_WORD *)(v54 + 24)) & 3
        && *(_WORD *)(v54 + 24) & 1 )
      {
        sub_13937(v53, 10, 2u, (char *)a1, (__int64)"config", (__int64)"refine", a2);
        sub_13937(
          v53,
          -1,
          5u,
          0LL,
          (__int64)"changing config from 'false' to 'true' is prohibited while the target's parent is still config 'false'.",
          v25);
        goto LABEL_188;
      }
      v45 = *(_QWORD *)(*(_QWORD *)&size[4] + 72LL);
      k = v45;
      while ( 2 )
      {
        if ( !k )
          goto LABEL_146;
        if ( *(_WORD *)(v54 + 24) & 1 )
        {
          if ( *(_WORD *)(k + 24) & 4 )
          {
            v45 = 0LL;
LABEL_139:
            if ( !v45 )
              v45 = *(_QWORD *)(k + 80);
            while ( !v45 )
            {
              k = lys_parent(k);
              if ( k == *(_QWORD *)&size[4] )
                break;
              v45 = *(_QWORD *)(k + 80);
            }
            k = v45;
            continue;
          }
        }
        else if ( *(_WORD *)(k + 24) & 4 && *(_WORD *)(k + 24) & 1 )
        {
          sub_13937(v53, 10, 2u, (char *)a1, (__int64)"config", (__int64)"refine", a2);
          sub_13937(
            v53,
            -1,
            5u,
            0LL,
            (__int64)"changing config from 'true' to 'false' is prohibited while the target has still a children with exp"
                     "licit config 'true'.",
            v26);
          goto LABEL_188;
        }
        break;
      }
      *(_WORD *)(k + 24) &= 0xFFFCu;
      *(_WORD *)(k + 24) |= *(_WORD *)(v54 + 24) & 3;
      if ( *(_DWORD *)(k + 56) & 0x802C )
        v45 = 0LL;
      else
        v45 = *(_QWORD *)(k + 72);
      goto LABEL_139;
    }
LABEL_146:
    if ( *(_BYTE *)(v54 + 31) && *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 2 )
    {
      v27 = *(_QWORD *)&size[4];
      *(_QWORD *)(v27 + 112) = sub_23C04(*(__int64 *)&size[4], **(_QWORD **)(v54 + 64));
      if ( !*(_QWORD *)(*(_QWORD *)&size[4] + 112LL) )
      {
        sub_13937(v53, 10, 2u, (char *)a1, **(_QWORD **)(v54 + 64), (__int64)"default", a2);
        goto LABEL_188;
      }
      if ( (unsigned int)sub_3C679(*(__int64 *)&size[4]) )
        goto LABEL_188;
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 16 && *(_DWORD *)(*(_QWORD *)&size[4] + 156LL) )
    {
      if ( *(_DWORD *)(*(_QWORD *)&size[4] + 152LL) > *(_DWORD *)(*(_QWORD *)&size[4] + 156LL) )
      {
        sub_13937(
          v53,
          -1,
          2u,
          (char *)a1,
          (__int64)"Invalid value \"%d\" of \"%s\".",
          *(unsigned int *)(v54 + 72),
          "min-elements");
        sub_13937(v53, -1, 5u, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v28, a2);
        goto LABEL_188;
      }
    }
    else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8
           && *(_DWORD *)(*(_QWORD *)&size[4] + 212LL)
           && *(_DWORD *)(*(_QWORD *)&size[4] + 208LL) > *(_DWORD *)(*(_QWORD *)&size[4] + 212LL) )
    {
      sub_13937(
        v53,
        -1,
        2u,
        (char *)a1,
        (__int64)"Invalid value \"%d\" of \"%s\".",
        *(unsigned int *)(v54 + 72),
        "min-elements");
      sub_13937(v53, -1, 5u, 0LL, (__int64)"\"min-elements\" is bigger than \"max-elements\".", v29, a2);
      goto LABEL_188;
    }
    if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 8 )
    {
      v56 = *(_QWORD *)&size[4];
      if ( *(_BYTE *)(*(_QWORD *)&size[4] + 30LL) && *(_DWORD *)(v56 + 208) )
      {
        if ( *(_BYTE *)(v54 + 31) )
          v30 = "default";
        else
          v30 = "min-elements";
        sub_13937(v53, 6, 2u, (char *)a1, (__int64)v30, (__int64)"refine", a2);
        sub_13937(
          v53,
          -1,
          5u,
          0LL,
          (__int64)"The \"min-elements\" statement with non-zero value is forbidden on leaf-lists with the \"default\" statement.",
          v31);
        goto LABEL_188;
      }
    }
    else if ( *(_DWORD *)(*(_QWORD *)&size[4] + 56LL) == 4 )
    {
      v55 = *(_QWORD *)&size[4];
      if ( *(_QWORD *)(*(_QWORD *)&size[4] + 200LL) )
      {
        if ( *(_WORD *)(v55 + 24) & 0x40 )
        {
          if ( *(_BYTE *)(v54 + 31) )
            v32 = "default";
          else
            v32 = "mandatory";
          sub_13937(v53, 6, 2u, (char *)a1, (__int64)v32, (__int64)"refine", a2);
          sub_13937(
            v53,
            -1,
            5u,
            0LL,
            (__int64)"The \"mandatory\" statement is forbidden on leafs with the \"default\" statement.",
            v33);
          goto LABEL_188;
        }
      }
    }
    if ( *(_WORD *)(v54 + 24) & 0x40 || *(_DWORD *)(v54 + 72) )
    {
      for ( n = *(_QWORD *)(*(_QWORD *)&size[4] + 64LL);
            n && !(*(_DWORD *)(n + 56) & 0x5802) && (*(_DWORD *)(n + 56) != 1 || !*(_QWORD *)(n + 136));
            n = *(_QWORD *)(n + 64) )
      {
        ;
      }
      if ( n && *(_DWORD *)(n + 56) == 2 && *(_QWORD *)(n + 112) && (unsigned int)sub_3C679(n) )
        goto LABEL_188;
    }
  }
  free(ptr);
  return 0LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7950: using guessed type __int64  lys_main_module(_QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (00000000000258B4) ----------------------------------------------------
__int64  sub_258B4(__int128 a1)
{
  __int64 result; // rax
  signed int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 == 0 )
    __assert_fail(
      "der && base",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1618u,
      "resolve_identity_backlink_update");
  if ( !*(_QWORD *)(*((_QWORD *)&a1 + 1) + 64LL) )
    *(_QWORD *)(*((_QWORD *)&a1 + 1) + 64LL) = ly_set_new(a1);
  ly_set_add(*(_QWORD *)(*((_QWORD *)&a1 + 1) + 64LL), a1, 1LL);
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(*((_QWORD *)&a1 + 1) + 31LL);
    if ( i >= (signed int)result )
      break;
    sub_258B4(a1);
  }
  return result;
}
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (0000000000025971) ----------------------------------------------------
signed __int64  sub_25971(__int64 a1, _QWORD *a2, char *a3, __int64 a4, signed __int64 *a5)
{
  signed __int64 *v6; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  char *s1; // [rsp+18h] [rbp-38h]
  unsigned int i; // [rsp+38h] [rbp-18h]
  unsigned int j; // [rsp+38h] [rbp-18h]
  unsigned int k; // [rsp+38h] [rbp-18h]
  unsigned int v12; // [rsp+3Ch] [rbp-14h]
  signed __int64 v13; // [rsp+40h] [rbp-10h]
  void *v14; // [rsp+48h] [rbp-8h]

  s1 = a3;
  v7 = a4;
  v6 = a5;
  v13 = 0LL;
  v14 = *(void **)a1;
  if ( !a5 )
    __assert_fail("ret", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1639u, "resolve_base_ident_sub");
  for ( i = 0; ; ++i )
  {
    if ( i >= *(unsigned __int16 *)(a1 + 72) )
    {
      v12 = 0;
LABEL_19:
      if ( v12 < *(unsigned __int8 *)(a1 + 70) && *(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) )
      {
        for ( j = 0; ; ++j )
        {
          if ( j >= *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 72LL) )
          {
            ++v12;
            goto LABEL_19;
          }
          if ( !strcmp(
                  s1,
                  *(const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 120LL) + 72LL * j)) )
            break;
        }
        if ( !a2 )
        {
          *v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 120LL) + 72LL * j;
          return 0LL;
        }
        v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 48LL * v12) + 120LL) + 72LL * j;
      }
      goto LABEL_21;
    }
    if ( !strcmp(s1, *(const char **)(*(_QWORD *)(a1 + 120) + 72LL * i)) )
      break;
  }
  if ( !a2 )
  {
    *v6 = *(_QWORD *)(a1 + 120) + 72LL * i;
    return 0LL;
  }
  v13 = *(_QWORD *)(a1 + 120) + 72LL * i;
LABEL_21:
  if ( !v13 )
    return 1LL;
  for ( k = 0; ; ++k )
  {
    if ( k >= *(_DWORD *)(v7 + 32) )
    {
      *v6 = v13;
      return 0LL;
    }
    if ( v13 == *(_QWORD *)(8LL * k + *(_QWORD *)v7) && *(_DWORD *)(4LL * k + *(_QWORD *)(v7 + 8)) == 256 )
      break;
  }
  if ( *(_QWORD *)(8LL * k + *(_QWORD *)(v7 + 16)) != *a2 )
    return 1LL;
  sub_13937(v14, 10, 0, 0LL, (__int64)s1, (__int64)"base");
  sub_13937(v14, -1, 0, 0LL, (__int64)"Circular reference of \"%s\" identity.", (__int64)s1);
  return 0xFFFFFFFFLL;
}

//----- (0000000000025CE3) ----------------------------------------------------
signed __int64  sub_25CE3(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  signed __int64 result; // rax
  char *v8; // rax
  __int64 v9; // r9
  __int16 v10; // dx
  const char *v11; // rax
  __int64 v12; // rsi
  unsigned __int8 v13; // al
  __int128 v14; // di
  __int64 v15; // [rsp+0h] [rbp-70h]
  __int64 v16; // [rsp+8h] [rbp-68h]
  __int64 v17; // [rsp+10h] [rbp-60h]
  char *s; // [rsp+18h] [rbp-58h]
  __int64 v19; // [rsp+20h] [rbp-50h]
  __int64 v20; // [rsp+28h] [rbp-48h]
  __int16 v21; // [rsp+36h] [rbp-3Ah]
  int v22; // [rsp+38h] [rbp-38h]
  unsigned int v23; // [rsp+3Ch] [rbp-34h]
  char v24; // [rsp+40h] [rbp-30h]
  char *v25; // [rsp+48h] [rbp-28h]
  signed __int64 *v26; // [rsp+50h] [rbp-20h]
  void **v27; // [rsp+58h] [rbp-18h]
  void *v28; // [rsp+60h] [rbp-10h]
  unsigned __int64 v29; // [rsp+68h] [rbp-8h]

  v19 = a2;
  s = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v29 = __readfsqword(0x28u);
  v22 = 0;
  v28 = *(void **)a1;
  if ( (!a2 || a5) && (a2 || !a5) )
    __assert_fail(
      "(ident && !type) || (!ident && type)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x168Fu,
      "resolve_base_ident");
  if ( a5 )
  {
    *(_QWORD *)(a5 + 32) = sub_C422(*(void **)(a5 + 32), 8LL * (unsigned int)++*(_DWORD *)(a5 + 40));
    if ( !*(_QWORD *)(v16 + 32) )
    {
      sub_12222((__int64)v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_base_ident", v6, v15);
      return 0xFFFFFFFFLL;
    }
    v26 = (signed __int64 *)(*(_QWORD *)(v16 + 32) + 8LL * (unsigned int)(*(_DWORD *)(v16 + 40) - 1));
    v21 = *(_WORD *)(*(_QWORD *)(v16 + 24) + 24LL);
    v27 = *(void ***)(*(_QWORD *)(v16 + 24) + 48LL);
  }
  else
  {
    v26 = (signed __int64 *)&v24;
    v21 = *(_WORD *)(a2 + 24);
    v27 = *(void ***)(a2 + 48);
  }
  *v26 = 0LL;
  v25 = strchr(s, 58);
  if ( v25 )
  {
    v22 = (_DWORD)v25++ - (_DWORD)s;
    if ( !strncmp(s, *(const char **)(a1 + 8), v22) && !*(_BYTE *)(*(_QWORD *)(a1 + 8) + v22) )
      v22 = 0;
  }
  else
  {
    v25 = s;
  }
  if ( v22 )
    v8 = s;
  else
    v8 = 0LL;
  v20 = sub_407F3((__int64 *)a1, 0LL, 0, v8, v22, 0);
  if ( v20 )
  {
    v23 = sub_25971(v20, (_QWORD *)a2, v25, v15, v26);
    if ( v23 )
    {
      if ( v23 == 1 )
      {
        sub_13937(v28, 36, 0, 0LL, v17, (__int64)s, v15);
        if ( v16 )
          --*(_DWORD *)(v16 + 40);
      }
    }
    else
    {
      if ( !*v26 )
        __assert_fail("*ret", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x16BCu, "resolve_base_ident");
      v10 = *(_WORD *)(*v26 + 24);
      if ( a2 )
        v11 = *(const char **)a2;
      else
        v11 = "of type";
      if ( (unsigned int)sub_3C749(v21, v27, (__int64)v11, v10, *(_QWORD *)(*v26 + 48), *(_QWORD *)*v26, 0LL) )
      {
        v23 = -1;
      }
      else if ( a2 )
      {
        v12 = *(_QWORD *)(a2 + 56);
        v13 = *(_BYTE *)(v19 + 31);
        *(_BYTE *)(v19 + 31) = v13 + 1;
        *(_QWORD *)(v12 + 8LL * v13) = *v26;
        if ( *(_BYTE *)(lys_main_module(v27) + 64) & 0x80 )
        {
          *((_QWORD *)&v14 + 1) = *v26;
          *(_QWORD *)&v14 = v19;
          sub_258B4(v14);
        }
      }
    }
    result = v23;
  }
  else
  {
    sub_13937(v28, 28, 0, 0LL, (__int64)s, v9, v15);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7950: using guessed type __int64  lys_main_module(_QWORD);

//----- (00000000000260D0) ----------------------------------------------------
signed __int64  sub_260D0(__int64 a1, __int64 a2)
{
  signed int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 == a2 )
    return 1LL;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 31); ++i )
  {
    if ( (unsigned int)sub_260D0(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 56)), a2) == 1 )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000026148) ----------------------------------------------------
__int64  sub_26148(signed __int64 a1, char *a2, char *a3, __int64 *a4, int a5)
{
  __int64 result; // rax
  unsigned int v6; // ecx
  unsigned int v7; // esi
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // esi
  __int64 v11; // r9
  unsigned int v12; // esi
  __int64 v13; // rax
  unsigned int v14; // esi
  __int64 v15; // rdi
  __int64 v16; // r12
  __int64 v17; // rbx
  int *v18; // rax
  __int64 v19; // rax
  int v20; // [rsp+Ch] [rbp-A4h]
  __int64 *v21; // [rsp+10h] [rbp-A0h]
  char *v22; // [rsp+18h] [rbp-98h]
  char *s; // [rsp+20h] [rbp-90h]
  signed __int64 v24; // [rsp+28h] [rbp-88h]
  int v25; // [rsp+38h] [rbp-78h]
  char v26; // [rsp+3Ch] [rbp-74h]
  int v27; // [rsp+40h] [rbp-70h]
  unsigned int i; // [rsp+44h] [rbp-6Ch]
  unsigned int j; // [rsp+48h] [rbp-68h]
  int v30; // [rsp+4Ch] [rbp-64h]
  char *s1; // [rsp+50h] [rbp-60h]
  char *s2; // [rsp+58h] [rbp-58h]
  __int64 v33; // [rsp+60h] [rbp-50h]
  __int64 v34; // [rsp+68h] [rbp-48h]
  __int64 v35; // [rsp+70h] [rbp-40h]
  __int64 v36; // [rsp+78h] [rbp-38h]
  __int64 v37; // [rsp+80h] [rbp-30h]
  void *ptr; // [rsp+88h] [rbp-28h]
  __int64 v39; // [rsp+90h] [rbp-20h]
  unsigned __int64 v40; // [rsp+98h] [rbp-18h]

  v24 = a1;
  s = a2;
  v22 = a3;
  v21 = a4;
  v20 = a5;
  v40 = __readfsqword(0x28u);
  v27 = 0;
  v34 = 0LL;
  if ( !a1 || !a2 || !a4 )
    __assert_fail(
      "type && ident_name && mod",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1702u,
      "resolve_identref");
  v35 = *a4;
  if ( !a1 || !*(_DWORD *)(a1 + 40) && !*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL) || !a2 )
    return 0LL;
  v30 = sub_16637(a2, &s1, (unsigned int *)&v25, &s2, (unsigned int *)&v26, 0LL, 0);
  if ( v30 > 0 )
  {
    v8 = strlen(a2);
    if ( v30 >= v8 )
    {
      v36 = lys_main_module(v21);
      if ( s1 && (strncmp(s1, *(const char **)(v36 + 8), v25) || *(_BYTE *)(*(_QWORD *)(v36 + 8) + v25)) )
      {
        if ( v20 )
        {
          for ( i = 0; i < *((unsigned __int8 *)v21 + 69); ++i )
          {
            if ( !strncmp(s1, *(const char **)(*(_QWORD *)(v21[12] + 56LL * i) + 8LL), v25)
              && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v21[12] + 56LL * i) + 8LL) + v25) )
            {
              v34 = *(_QWORD *)(v21[12] + 56LL * i);
              break;
            }
          }
          if ( !v34 && a1 && *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL) )
          {
            v37 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL);
            for ( i = 0; i < *(unsigned __int8 *)(v37 + 69); ++i )
            {
              if ( !strncmp(s1, *(const char **)(*(_QWORD *)(*(_QWORD *)(v37 + 96) + 56LL * i) + 8LL), v25)
                && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v37 + 96) + 56LL * i) + 8LL) + v25) )
              {
                v34 = *(_QWORD *)(*(_QWORD *)(v37 + 96) + 56LL * i);
                break;
              }
            }
          }
          if ( !v34 )
          {
            ptr = strndup(s1, v25);
            v34 = ly_ctx_get_module(v35, ptr, 0LL, 1LL);
            free(ptr);
          }
        }
        else
        {
          for ( i = 0; i < *(_DWORD *)(*v21 + 60); ++i )
          {
            v34 = *(_QWORD *)(8LL * i + *(_QWORD *)(*v21 + 64));
            if ( !strncmp(s1, *(const char **)(v34 + 8), v25) && !*(_BYTE *)(*(_QWORD *)(v34 + 8) + v25) )
              break;
            v34 = 0LL;
          }
          if ( !v34 && *(_BYTE *)(*v21 + 88) )
          {
            for ( i = 0; i < *(unsigned __int8 *)(*v21 + 88); ++i )
            {
              v34 = *(_QWORD *)(8LL * i + *(_QWORD *)(*v21 + 72));
              if ( !(*(_BYTE *)(v34 + 64) & 1) )
              {
                if ( !strncmp(s1, *(const char **)(v34 + 8), v25) && !*(_BYTE *)(*(_QWORD *)(v34 + 8) + v25) )
                  break;
                v34 = 0LL;
              }
            }
          }
        }
      }
      else
      {
        v34 = v36;
      }
      if ( !v20 && (!v34 || *(_BYTE *)(v34 + 64) >= 0) && *(_QWORD *)(v35 + 112) )
      {
        if ( v34 )
        {
          (*(void ( **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v35 + 112))(
            v35,
            *(_QWORD *)(v34 + 8),
            *(_QWORD *)(v34 + 176),
            1LL,
            *(_QWORD *)(v35 + 120));
        }
        else if ( s1 )
        {
          ptr = strndup(s1, v25);
          v34 = (*(__int64 ( **)(__int64, void *, _QWORD, _QWORD, _QWORD))(v35 + 112))(
                  v35,
                  ptr,
                  0LL,
                  0LL,
                  *(_QWORD *)(v35 + 120));
          free(ptr);
        }
      }
      if ( v34 )
      {
        if ( v36 == v34 && v21 == (__int64 *)lys_main_module(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48LL))
          || *(_BYTE *)(v34 + 64) < 0 )
        {
          while ( *(_QWORD *)(v24 + 16) )
          {
            for ( i = 0; i < *(_DWORD *)(v24 + 40); ++i )
            {
              v33 = *(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 32));
              if ( *(_QWORD *)(v33 + 64) )
              {
                for ( j = 0; j < *(_DWORD *)(*(_QWORD *)(v33 + 64) + 4LL); ++j )
                {
                  v39 = *(_QWORD *)(8LL * j + *(_QWORD *)(*(_QWORD *)(v33 + 64) + 8LL));
                  if ( !strcmp(*(const char **)v39, s2) )
                  {
                    v13 = lys_main_module(*(_QWORD *)(v39 + 48));
                    if ( v34 == v13 )
                    {
                      v33 = v39;
LABEL_111:
                      for ( i = 0; i < *(unsigned __int8 *)(v33 + 27); ++i )
                      {
                        if ( !(unsigned int)sub_18D14(32LL * i + *(_QWORD *)(v33 + 40)) )
                        {
                          if ( v22 )
                            sub_13937((void *)v35, 50, 3u, v22, *(_QWORD *)v33, **(_QWORD **)v22);
                          sub_13937(
                            (void *)v35,
                            -1,
                            5u,
                            0LL,
                            (__int64)"Identity \"%s\" is disabled by its if-feature condition.",
                            *(_QWORD *)v33);
                          return 0LL;
                        }
                      }
                      if ( v27 )
                      {
                        if ( !v20 )
                        {
                          v19 = lys_main_module(*(_QWORD *)(v33 + 48));
                          sub_13937(
                            (void *)v35,
                            -1,
                            0,
                            0LL,
                            (__int64)"Identity found, but in a non-implemented module \"%s\".",
                            *(_QWORD *)(v19 + 8));
                          goto LABEL_107;
                        }
                        sub_12222(
                          0LL,
                          2u,
                          0,
                          "Making \"%s\" module implemented because of identityref default value \"%s\" used in the imple"
                          "mented \"%s\" module",
                          *(_QWORD *)(v34 + 8),
                          *(_QWORD *)v33,
                          v21[1]);
                        v15 = v34;
                        if ( (unsigned int)lys_set_implemented(v34) )
                        {
                          v16 = *(_QWORD *)v33;
                          v17 = *(_QWORD *)(v34 + 8);
                          v18 = (int *)ly_errno_glob_address(v15);
                          sub_12222(
                            v35,
                            0,
                            *v18,
                            "Setting the module \"%s\" implemented because of used default identity \"%s\" failed.",
                            v17,
                            v16);
                          goto LABEL_107;
                        }
                      }
                      return v33;
                    }
                  }
                }
              }
            }
            v24 = *(_QWORD *)(v24 + 16) + 56LL;
          }
        }
        else
        {
          v33 = 0LL;
          for ( i = 0; i < *(unsigned __int16 *)(v34 + 72); ++i )
          {
            if ( !strcmp(s2, *(const char **)(*(_QWORD *)(v34 + 120) + 72LL * i)) )
            {
              v33 = *(_QWORD *)(v34 + 120) + 72LL * i;
              break;
            }
          }
          if ( v33 )
            goto LABEL_126;
          for ( j = 0; j < *(unsigned __int8 *)(v34 + 70); ++j )
          {
            for ( i = 0; i < *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 72LL); ++i )
            {
              if ( !strcmp(
                      s2,
                      *(const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 120LL) + 72LL * i)) )
              {
                v33 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 104) + 48LL * j) + 120LL) + 72LL * i;
                break;
              }
            }
          }
          if ( v33 )
          {
LABEL_126:
            while ( *(_QWORD *)(v24 + 16) )
            {
              for ( i = 0; i < *(_DWORD *)(v24 + 40); ++i )
              {
                if ( (unsigned int)sub_260D0(v33, *(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 32))) )
                {
                  v27 = 1;
                  goto LABEL_111;
                }
              }
              v24 = *(_QWORD *)(v24 + 16) + 56LL;
            }
            if ( v22 )
              v12 = 3;
            else
              v12 = 0;
            sub_13937((void *)v35, -1, v12, v22, (__int64)"Identity used as identityref value is not implemented.", v11);
          }
        }
      }
LABEL_107:
      if ( v22 )
        v14 = 3;
      else
        v14 = 0;
      sub_13937((void *)v35, 36, v14, v22, (__int64)"identityref", (__int64)s);
      result = 0LL;
    }
    else
    {
      v9 = a2[v30];
      if ( v22 )
        v10 = 3;
      else
        v10 = 0;
      sub_13937((void *)v35, 55, v10, v22, v9, (__int64)&s[v30]);
      result = 0LL;
    }
  }
  else
  {
    v6 = a2[-v30];
    if ( v22 )
      v7 = 3;
    else
      v7 = 0;
    sub_13937((void *)v35, 55, v7, v22, v6, (__int64)&s[-v30]);
    result = 0LL;
  }
  return result;
}
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);
// 74B0: using guessed type __int64  lys_set_implemented(_QWORD);
// 7950: using guessed type __int64  lys_main_module(_QWORD);

//----- (0000000000026D87) ----------------------------------------------------
signed __int64  sub_26D87(_BYTE **a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  signed __int64 result; // rax
  int v5; // [rsp+1Ch] [rbp-14h]
  unsigned int v6; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  void *v8; // [rsp+28h] [rbp-8h]

  v8 = *(void **)a1[6];
  for ( i = lys_parent(a1); i && *(_DWORD *)(i + 56) != 2048; i = lys_parent(i) )
    ;
  if ( i && *(_BYTE **)i == *a1 )
  {
    sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
    return 0xFFFFFFFFLL;
  }
  if ( a1[16] )
    goto LABEL_40;
  v5 = sub_1B28A(*a1, (__int64)a1, (__int64 *)a1 + 16);
  if ( v5 == -1 )
  {
    sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
    return 0xFFFFFFFFLL;
  }
  if ( v5 > 0 )
  {
    sub_13937(v8, 55, 2u, (char *)a1, (unsigned int)(char)(*a1)[v5 - 1], (__int64)&(*a1)[v5 - 1], a2);
    return 0xFFFFFFFFLL;
  }
  if ( a1[16] )
  {
LABEL_40:
    if ( *((_WORD *)a1[16] + 14) )
    {
      if ( !i || (_WORD)a1[3] & 1 )
      {
        a1[16] = 0LL;
      }
      else
      {
        if ( !++*(_WORD *)(i + 28) )
        {
          sub_12222((__int64)v8, 0, 4, "Too many unresolved items (uses) inside a grouping.", v2, v3, a2);
          return 0xFFFFFFFFLL;
        }
        *((_WORD *)a1 + 12) |= 1u;
      }
      sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
      result = 1LL;
    }
    else
    {
      v6 = sub_23C91((__int64)a1, a2);
      if ( v6 )
      {
        result = v6;
      }
      else
      {
        if ( i && (_WORD)a1[3] & 1 )
        {
          if ( !*(_WORD *)(i + 28) )
            __assert_fail(
              "((struct lys_node_grp *)par_grp)->unres_count",
              "/home/mantovan/Repositories/libyang/src/resolve.c",
              0x17FFu,
              "resolve_unres_schema_uses");
          --*(_WORD *)(i + 28);
          *((_WORD *)a1 + 12) &= 0xFFFEu;
        }
        if ( (unsigned int)sub_3C749(
                             *((_WORD *)a1 + 12),
                             (void **)a1[6],
                             (__int64)"of uses",
                             *((_WORD *)a1[16] + 12),
                             *((_QWORD *)a1[16] + 6),
                             *(_QWORD *)a1[16],
                             (char *)a1) )
          result = 0xFFFFFFFFLL;
        else
          result = 0LL;
      }
    }
  }
  else
  {
    if ( i && !((_WORD)a1[3] & 1) )
    {
      if ( !++*(_WORD *)(i + 28) )
      {
        sub_12222((__int64)v8, 0, 4, "Too many unresolved items (uses) inside a grouping.", v2, v3, a2);
        return 0xFFFFFFFFLL;
      }
      *((_WORD *)a1 + 12) |= 1u;
    }
    sub_13937(v8, 36, 2u, (char *)a1, (__int64)"uses", (__int64)*a1, a2);
    result = 1LL;
  }
  return result;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (00000000000271C8) ----------------------------------------------------
signed __int64  sub_271C8(__int64 a1, char *a2)
{
  const char ***v3; // rbx
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  void *ptr; // ST40_8
  char *s; // [rsp+0h] [rbp-50h]
  int i; // [rsp+1Ch] [rbp-34h]
  int v10; // [rsp+20h] [rbp-30h]
  char *v11; // [rsp+28h] [rbp-28h]
  void *v12; // [rsp+38h] [rbp-18h]

  s = a2;
  v12 = **(void ***)(a1 + 48);
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 30); ++i )
  {
    if ( !s )
      __assert_fail("keys_str", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1822u, "resolve_list_keys");
    if ( !*(_QWORD *)(a1 + 72) )
    {
      sub_13937(v12, 36, 2u, (char *)a1, (__int64)"list keys", (__int64)s, s);
      return 1LL;
    }
    v11 = strpbrk(s, accept);
    if ( v11 )
    {
      v10 = (_DWORD)v11 - (_DWORD)s;
      while ( (*__ctype_b_loc())[*v11] & 0x2000 )
        ++v11;
    }
    else
    {
      v10 = strlen(s);
    }
    v3 = (const char ***)(*(_QWORD *)(a1 + 136) + 8LL * i);
    v4 = lys_node_module(a1);
    if ( (unsigned int)sub_9B536(v4, a1, s, v10, 4, 0x100u, v3) )
    {
      sub_13937(v12, 36, 2u, (char *)a1, (__int64)"list key", (__int64)s, s);
      return 1LL;
    }
    if ( (unsigned int)sub_1F3F0(a1, i, s, v10, v5, v6) )
      return 0xFFFFFFFFLL;
    if ( (unsigned int)sub_3C749(
                         *(_WORD *)(a1 + 24),
                         *(void ***)(a1 + 48),
                         *(_QWORD *)a1,
                         *(_WORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 24LL),
                         *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 48LL),
                         **(_QWORD **)(8LL * i + *(_QWORD *)(a1 + 136)),
                         *(char **)(8LL * i + *(_QWORD *)(a1 + 136))) )
      return 0xFFFFFFFFLL;
    if ( *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 200LL) )
    {
      if ( *(_DWORD *)__tls_get_addr(&stru_335FC0) != 1 )
        __assert_fail(
          "log_opt == ILO_STORE",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x184Bu,
          "resolve_list_keys");
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = 0;
      ptr = (void *)lys_path(a1, 1LL);
      sub_12222(
        (__int64)v12,
        1u,
        0,
        "Default value \"%s\" in the list key \"%s\" is ignored. (%s)",
        *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 136)) + 200LL),
        **(_QWORD **)(8LL * i + *(_QWORD *)(a1 + 136)),
        ptr);
      *(_DWORD *)__tls_get_addr(&stru_335FC0) = 1;
      free(ptr);
    }
    while ( v11 && (*__ctype_b_loc())[*v11] & 0x2000 )
      ++v11;
    s = v11;
  }
  return 0LL;
}
// 75D0: using guessed type __int64  __tls_get_addr(_QWORD);
// 7680: using guessed type __int64  lys_path(_QWORD, _QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);
// 335FC0: using guessed type tls_index_local stru_335FC0;

//----- (00000000000275C3) ----------------------------------------------------
signed __int64  sub_275C3(char *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // eax
  void **v5; // rax
  __int64 *v6; // rax
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned __int64 v11; // [rsp+0h] [rbp-80h]
  char *v12; // [rsp+8h] [rbp-78h]
  unsigned __int8 j; // [rsp+16h] [rbp-6Ah]
  unsigned __int8 v14; // [rsp+17h] [rbp-69h]
  __int64 i; // [rsp+18h] [rbp-68h]
  __int64 v16; // [rsp+20h] [rbp-60h]
  void *v17; // [rsp+28h] [rbp-58h]
  char s; // [rsp+30h] [rbp-50h]
  int v19; // [rsp+40h] [rbp-40h]
  unsigned __int64 v20; // [rsp+78h] [rbp-8h]

  v12 = a1;
  v11 = __PAIR__(a2, a3);
  v20 = __readfsqword(0x28u);
  v17 = **(void ***)(*(_QWORD *)a1 + 48LL);
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x186Fu, "resolve_must");
  memset(&s, 0, 0x40uLL);
  if ( a2 )
  {
    for ( i = lys_parent(*(_QWORD *)a1); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
      ;
    if ( !i || !(*(_DWORD *)(i + 56) & 0x600) )
    {
      sub_12222(
        (__int64)v17,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        6263LL,
        v11);
      return 0xFFFFFFFFLL;
    }
    v14 = *(_BYTE *)(i + 29);
    v16 = *(_QWORD *)(i + 112);
    v12 = (char *)*((_QWORD *)a1 + 5);
    if ( !(*(_DWORD *)(*(_QWORD *)v12 + 56LL) & 0x4100) )
    {
      sub_12222(
        (__int64)v17,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        6272LL,
        v11);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_30;
  }
  v4 = *(_DWORD *)(*(_QWORD *)a1 + 56LL);
  if ( v4 == 16 )
  {
    v14 = *(_BYTE *)(*(_QWORD *)a1 + 28LL);
    v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
  }
  else if ( v4 > 0x10 )
  {
    if ( v4 == 128 )
    {
      v14 = *(_BYTE *)(*(_QWORD *)a1 + 29LL);
      v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
    }
    else
    {
      if ( v4 != 32800 && v4 != 32 )
        goto LABEL_29;
      v14 = *(_BYTE *)(*(_QWORD *)a1 + 31LL);
      v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
    }
  }
  else
  {
    switch ( v4 )
    {
      case 4u:
        v14 = *(_BYTE *)(*(_QWORD *)a1 + 31LL);
        v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
        break;
      case 8u:
        v14 = *(_BYTE *)(*(_QWORD *)a1 + 31LL);
        v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
        break;
      case 1u:
        v14 = *(_BYTE *)(*(_QWORD *)a1 + 29LL);
        v16 = *(_QWORD *)(*(_QWORD *)a1 + 120LL);
        break;
      default:
LABEL_29:
        v14 = 0;
        break;
    }
  }
LABEL_30:
  for ( j = 0; ; ++j )
  {
    if ( j >= v14 )
      return 0LL;
    v5 = (void **)lyd_node_module(v12);
    if ( (unsigned int)sub_DC4B2(*(const char **)(56LL * j + v16), v12, 2, v5, &s, 1LL) )
      return 0xFFFFFFFFLL;
    v6 = (__int64 *)lyd_node_module(v12);
    sub_DC765((__int64)&s, 3, (__int64)v12, v6, 1);
    if ( !v19 )
      break;
LABEL_43:
    ;
  }
  if ( (_DWORD)v11 == 1 || *(_WORD *)(56LL * j + v16 + 50) & 0x600 && (_DWORD)v11 == 2 )
  {
    sub_12222(
      0LL,
      2u,
      0,
      "Must condition \"%s\" not satisfied, but it is not required.",
      *(_QWORD *)(56LL * j + v16),
      v7,
      v11);
    goto LABEL_43;
  }
  sub_13937(v17, 58, 3u, v12, *(_QWORD *)(56LL * j + v16), v7, v11);
  if ( *(_QWORD *)(56LL * j + v16 + 32) )
    sub_13C4A(v17, 5, *(char **)(56LL * j + v16 + 32), v8, v9, v10);
  if ( *(_QWORD *)(56LL * j + v16 + 24) )
    sub_14407((__int64)v17, *(const char **)(56LL * j + v16 + 24));
  return 1LL;
}
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (0000000000027A8D) ----------------------------------------------------
__int64 * sub_27A8D(__int64 a1, __int64 *a2, _DWORD *a3)
{
  __int64 v3; // rax
  __int64 *result; // rax
  __int64 v5; // [rsp+18h] [rbp-18h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a1;
  *a3 = 2;
  while ( *(_DWORD *)(v5 + 56) & 0x3642 )
  {
    if ( *(_DWORD *)(v5 + 56) == 0x2000 )
      v6 = *(_QWORD *)(v5 + 88);
    else
      v6 = *(_QWORD *)(v5 + 64);
    if ( !v6 )
    {
      if ( *(_WORD *)(v5 + 24) & 1 )
        *a3 = 1;
      else
        *a3 = 0;
      v3 = lys_node_module(v5);
      v5 = lys_getnext(0LL, 0LL, v3, 256LL);
      break;
    }
    v5 = v6;
  }
  result = a2;
  *a2 = v5;
  return result;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000027B5A) ----------------------------------------------------
signed __int64  sub_27B5A(_QWORD *a1, __int64 a2, _QWORD *a3, _DWORD *a4)
{
  __int64 v4; // rax
  _DWORD *v6; // [rsp+0h] [rbp-50h]
  _QWORD *v7; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+10h] [rbp-40h]
  _QWORD *v9; // [rsp+18h] [rbp-38h]
  unsigned __int16 i; // [rsp+2Eh] [rbp-22h]
  unsigned __int16 v11; // [rsp+30h] [rbp-20h]
  unsigned __int16 v12; // [rsp+32h] [rbp-1Eh]
  int v13; // [rsp+34h] [rbp-1Ch]
  _QWORD *v14; // [rsp+38h] [rbp-18h]
  __int64 v15; // [rsp+40h] [rbp-10h]
  unsigned __int64 v16; // [rsp+48h] [rbp-8h]

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v16 = __readfsqword(0x28u);
  sub_27A8D(a2, &v8, &v13);
  if ( v13 == 2 )
  {
    v14 = v9;
    v11 = 0;
    while ( v14 )
    {
      v14 = (_QWORD *)v14[5];
      ++v11;
    }
    v15 = v8;
    v12 = 0;
    while ( v15 )
    {
      if ( *(_DWORD *)(v15 + 56) & 0x81BD )
        ++v12;
      if ( *(_DWORD *)(v15 + 56) == 0x2000 )
        v4 = *(_QWORD *)(v15 + 88);
      else
        v4 = *(_QWORD *)(v15 + 64);
      v15 = v4;
    }
    if ( v11 < v12 )
      return 0xFFFFFFFFLL;
    for ( i = 0; i < v11 - v12; ++i )
      v9 = (_QWORD *)v9[5];
    if ( *v9 != v8 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    while ( v9[5] )
      v9 = (_QWORD *)v9[5];
    while ( *(_QWORD *)(v9[4] + 24LL) )
      v9 = (_QWORD *)v9[4];
  }
  *v7 = v9;
  *v6 = v13;
  return 0LL;
}

//----- (0000000000027CDB) ----------------------------------------------------
signed __int64  sub_27CDB(__int64 a1, __int64 *a2, __int64 *a3, unsigned int a4, __int64 a5)
{
  unsigned int v5; // eax
  __int64 i; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  char v12; // al
  __int64 v13; // [rsp+8h] [rbp-48h]
  unsigned int v14; // [rsp+14h] [rbp-3Ch]
  __int64 *v15; // [rsp+18h] [rbp-38h]
  _QWORD *v16; // [rsp+30h] [rbp-20h]
  _QWORD *j; // [rsp+38h] [rbp-18h]
  __int64 v18; // [rsp+40h] [rbp-10h]
  __int64 v19; // [rsp+48h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v19 = **(_QWORD **)(a1 + 48);
  v5 = *(_DWORD *)(a1 + 56);
  if ( v5 != 16 )
  {
    if ( v5 <= 0x10 )
    {
      if ( v5 != 2 )
      {
        if ( v5 > 2 )
        {
          if ( v5 != 4 && v5 != 8 )
            goto LABEL_49;
        }
        else if ( v5 != 1 )
        {
LABEL_49:
          sub_12222(
            v19,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            6527LL);
          return 0xFFFFFFFFLL;
        }
        goto LABEL_25;
      }
LABEL_18:
      for ( i = lys_getnext(0LL, a1, 0LL, 128LL); ; i = lys_getnext(v18, a1, 0LL, 128LL) )
      {
        v18 = i;
        if ( !i )
          break;
        if ( !(*(_DWORD *)(i + 56) & 0x4080) && (unsigned int)sub_27CDB(i, a2, v15, v14, v13) )
          return 0xFFFFFFFFLL;
      }
      return 0LL;
    }
    if ( v5 == 4096 )
      goto LABEL_18;
    if ( v5 > 0x1000 )
    {
      if ( v5 == 0x2000 )
        goto LABEL_18;
      if ( v5 != 32800 )
        goto LABEL_49;
    }
    else if ( v5 != 32 )
    {
      if ( v5 != 64 )
        goto LABEL_49;
      goto LABEL_18;
    }
  }
LABEL_25:
  for ( j = (_QWORD *)lyd_first_sibling(*a2); ; j = v16 )
  {
    if ( j )
    {
      v16 = (_QWORD *)j[3];
      v12 = 1;
    }
    else
    {
      v12 = 0;
    }
    if ( !v12 )
      break;
    if ( a1 == *j )
    {
      if ( j == (_QWORD *)*v15 )
      {
        if ( v14 == 2 )
        {
          sub_12222(
            v19,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            6484LL);
          return 0xFFFFFFFFLL;
        }
        if ( j == (_QWORD *)j[4] )
        {
          *v15 = 0LL;
        }
        else
        {
          v8 = j[4];
          *v15 = v8;
        }
      }
      else if ( j == (_QWORD *)*a2 )
      {
        v8 = *(_QWORD *)(*a2 + 32);
        if ( v8 == *a2 )
        {
          *a2 = 0LL;
        }
        else
        {
          v8 = *(_QWORD *)(*a2 + 32);
          *a2 = v8;
        }
      }
      sub_BA11B(j, 0, v8, v9, v10, v11);
      if ( *(_QWORD *)v13 )
      {
        if ( (unsigned int)lyd_insert_after(*(_QWORD *)(*(_QWORD *)v13 + 32LL), j) )
        {
          sub_12222(
            v19,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            6512LL);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        v8 = (__int64)j;
        *(_QWORD *)v13 = j;
      }
      if ( *(_DWORD *)(a1 + 56) & 0x8025 )
        return 0LL;
    }
  }
  return 0LL;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7310: using guessed type __int64  lyd_insert_after(_QWORD, _QWORD);
// 77E0: using guessed type __int64  lyd_first_sibling(_QWORD);

//----- (0000000000027FD3) ----------------------------------------------------
signed __int64  sub_27FD3(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  char v9; // al
  int v10; // [rsp+Ch] [rbp-24h]
  __int64 *v11; // [rsp+10h] [rbp-20h]
  __int64 *i; // [rsp+28h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  for ( i = a2; ; i = v11 )
  {
    if ( i )
    {
      v11 = (__int64 *)i[3];
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( !v9 )
      break;
    sub_BA11B(i, 0, a3, a4, a5, a6);
    if ( v10 == 2 )
    {
      if ( (unsigned int)sub_B70F6(a1, 0LL, i, 0LL, v6, v7) )
        return 0xFFFFFFFFLL;
    }
    else if ( (unsigned int)sub_B7B96(a1, i, 0, 0) )
    {
      return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (0000000000028087) ----------------------------------------------------
__int64  sub_28087(_QWORD *a1)
{
  unsigned int v1; // eax
  char v3; // [rsp+1Bh] [rbp-15h]
  unsigned int v4; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  _BYTE *v6; // [rsp+28h] [rbp-8h]

  v4 = 0;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x19ADu, "resolve_applies_must");
  v6 = (_BYTE *)*a1;
  v1 = *(_DWORD *)(*a1 + 56LL);
  if ( v1 == 16 )
  {
    v3 = v6[28];
    goto LABEL_20;
  }
  if ( v1 > 0x10 )
  {
    if ( v1 == 128 )
    {
      v3 = v6[29];
      goto LABEL_20;
    }
    if ( v1 == 32800 || v1 == 32 )
    {
      v3 = v6[31];
      goto LABEL_20;
    }
  }
  else
  {
    switch ( v1 )
    {
      case 4u:
        v3 = v6[31];
        goto LABEL_20;
      case 8u:
        v3 = v6[31];
        goto LABEL_20;
      case 1u:
        v3 = v6[29];
        goto LABEL_20;
    }
  }
  v3 = 0;
LABEL_20:
  if ( v3 )
    v4 = 1;
  if ( !*(_QWORD *)(a1[4] + 24LL) )
  {
    for ( i = lys_parent(v6); i && *(_DWORD *)(i + 56) & 0x1042; i = lys_parent(i) )
      ;
    if ( i && *(_DWORD *)(i + 56) & 0x600 )
      v4 += 2;
  }
  return v4;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (00000000000281C9) ----------------------------------------------------
__int64  sub_281C9(__int64 a1)
{
  unsigned int v1; // eax

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 == 16 )
    return *(_QWORD *)(a1 + 112);
  if ( v1 <= 0x10 )
  {
    if ( v1 == 2 )
      return *(_QWORD *)(a1 + 104);
    if ( v1 > 2 )
    {
      if ( v1 == 4 )
        return *(_QWORD *)(a1 + 112);
      if ( v1 == 8 )
        return *(_QWORD *)(a1 + 112);
    }
    else if ( v1 == 1 )
    {
      return *(_QWORD *)(a1 + 112);
    }
    return 0LL;
  }
  if ( v1 == 4096 )
    return *(_QWORD *)(a1 + 104);
  if ( v1 <= 0x1000 )
  {
    if ( v1 != 32 )
    {
      if ( v1 == 64 )
        return *(_QWORD *)(a1 + 104);
      return 0LL;
    }
    return *(_QWORD *)(a1 + 112);
  }
  if ( v1 == 0x2000 )
    return *(_QWORD *)(a1 + 80);
  if ( v1 == 32800 )
    return *(_QWORD *)(a1 + 112);
  return 0LL;
}

//----- (0000000000028290) ----------------------------------------------------
signed __int64  sub_28290(__int64 a1, int a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 )
    __assert_fail("schema", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x19FBu, "resolve_applies_when");
  if ( !(*(_DWORD *)(a1 + 56) & 0x180) && sub_281C9(a1) )
    return 1LL;
  v5 = a1;
  while ( 1 )
  {
    if ( *(_QWORD *)(v5 + 64) && *(_DWORD *)(*(_QWORD *)(v5 + 64) + 56LL) == 0x2000 && sub_281C9(*(_QWORD *)(v5 + 64)) )
      return 1LL;
    v5 = lys_parent(v5);
    if ( !v5 )
      break;
    if ( a2 )
    {
      if ( v5 == v4 )
        return 0LL;
    }
    else if ( !(*(_DWORD *)(v5 + 56) & 0x1042) )
    {
      return 0LL;
    }
    if ( sub_281C9(v5) )
      return 1LL;
  }
  return 0LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (0000000000028399) ----------------------------------------------------
__int64  sub_28399(__int64 a1, int a2, __int64 *a3)
{
  void **v3; // rbx
  const char **v4; // rax
  __int64 *v5; // rax
  __int64 v6; // r9
  __int64 *v7; // rax
  __int64 *v8; // rax
  __int64 v9; // r9
  __int64 *v10; // rax
  __int64 v11; // r9
  __int64 *v12; // rax
  void **v13; // r13
  int v14; // er12
  char *v15; // rbx
  const char **v16; // rax
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 *v19; // rax
  __int64 v20; // r9
  __int64 *v21; // rax
  __int64 *v22; // rax
  __int64 v23; // r9
  __int64 *v24; // rax
  __int64 v25; // r9
  __int64 *v26; // rax
  void **v27; // r13
  int v28; // er12
  char *v29; // rbx
  const char **v30; // rax
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 *v33; // rax
  __int64 v34; // r9
  __int64 *v35; // rax
  __int64 *v36; // rax
  __int64 v37; // r9
  __int64 *v38; // rax
  __int64 v39; // r9
  __int64 *v40; // rax
  __int64 v41; // rax
  __int64 *v43; // [rsp+8h] [rbp-B8h]
  unsigned int v44; // [rsp+20h] [rbp-A0h]
  char v45[12]; // [rsp+24h] [rbp-9Ch]
  __int64 *v46; // [rsp+30h] [rbp-90h]
  __int64 v47; // [rsp+38h] [rbp-88h]
  __int64 v48; // [rsp+40h] [rbp-80h]
  void *v49; // [rsp+48h] [rbp-78h]
  char s; // [rsp+50h] [rbp-70h]
  int v51; // [rsp+60h] [rbp-60h]
  unsigned __int64 v52; // [rsp+98h] [rbp-28h]

  v43 = a3;
  v52 = __readfsqword(0x28u);
  *(_QWORD *)&v45[4] = 0LL;
  v49 = **(void ***)(*(_QWORD *)a1 + 48LL);
  *(_DWORD *)v45 = 0;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1A38u, "resolve_when");
  memset(&s, 0, 0x40uLL);
  if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x4180 || !sub_281C9(*(_QWORD *)a1) )
    goto LABEL_16;
  *(_BYTE *)(a1 + 8) |= 0x80u;
  v3 = (void **)lyd_node_module(a1);
  v4 = (const char **)sub_281C9(*(_QWORD *)a1);
  *(_DWORD *)v45 = sub_DC4B2(*v4, (char *)a1, 2, v3, &s, 2LL);
  *(_BYTE *)(a1 + 8) &= 0x7Fu;
  if ( *(_DWORD *)v45 )
  {
    if ( *(_DWORD *)v45 == 1 )
    {
      v5 = (__int64 *)sub_281C9(*(_QWORD *)a1);
      sub_13937(v49, 61, 3u, (char *)a1, *v5, v6);
    }
    goto LABEL_62;
  }
  v7 = (__int64 *)lyd_node_module(a1);
  sub_DC765((__int64)&s, 3, a1, v7, 2);
  if ( v51 )
  {
LABEL_15:
    v12 = (__int64 *)lyd_node_module(a1);
    sub_DC765((__int64)&s, 0, a1, v12, 0);
LABEL_16:
    v48 = *(_QWORD *)a1;
    while ( 1 )
    {
      if ( *(_QWORD *)(v48 + 64)
        && *(_DWORD *)(*(_QWORD *)(v48 + 64) + 56LL) == 0x2000
        && sub_281C9(*(_QWORD *)(v48 + 64)) )
      {
        if ( !*(_QWORD *)&v45[4] )
        {
          *(_QWORD *)v45 = (unsigned int)sub_27B5A((_QWORD *)a1, *(_QWORD *)(v48 + 64), &v45[4], &v44);
          if ( *(_DWORD *)v45 )
          {
            sub_12222(
              (__int64)v49,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              6811LL);
            goto LABEL_62;
          }
        }
        v46 = 0LL;
        v47 = a1;
        *(_DWORD *)v45 = sub_27CDB(*(_QWORD *)(v48 + 64), &v47, (__int64 *)&v45[4], v44, (__int64)&v46);
        if ( *(_DWORD *)v45 )
          goto LABEL_62;
        v27 = (void **)lys_node_module(*(_QWORD *)(v48 + 64));
        v28 = v44;
        v29 = *(char **)&v45[4];
        v30 = (const char **)sub_281C9(*(_QWORD *)(v48 + 64));
        *(_DWORD *)v45 = sub_DC4B2(*v30, v29, v28, v27, &s, 2LL);
        if ( v46
          && *(_QWORD *)&v45[4]
          && (unsigned int)sub_27FD3(*(__int64 **)&v45[4], v46, v44, (__int64)v46, v31, v32) )
        {
          *(_DWORD *)v45 = -1;
          goto LABEL_62;
        }
        if ( *(_DWORD *)v45 )
        {
          if ( *(_DWORD *)v45 == 1 )
          {
            v33 = (__int64 *)sub_281C9(*(_QWORD *)(v48 + 64));
            sub_13937(v49, 61, 3u, (char *)a1, *v33, v34);
          }
          goto LABEL_62;
        }
        v35 = (__int64 *)lys_node_module(*(_QWORD *)(v48 + 64));
        sub_DC765((__int64)&s, 3, *(__int64 *)&v45[4], v35, 2);
        if ( !v51 )
        {
          *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
          if ( a2 != 1 && (!(*(_WORD *)(sub_281C9(*(_QWORD *)(v48 + 64)) + 34) & 0x600) || a2 != 2) )
          {
            v38 = (__int64 *)sub_281C9(*(_QWORD *)(v48 + 64));
            sub_13937(v49, 59, 3u, (char *)a1, *v38, v39);
            if ( v43 )
              *v43 = sub_281C9(*(_QWORD *)(v48 + 64));
            goto LABEL_62;
          }
          v36 = (__int64 *)sub_281C9(*(_QWORD *)(v48 + 64));
          sub_12222(0LL, 2u, 0, "When condition \"%s\" is not satisfied, but it is not required.", *v36, v37);
        }
        v40 = (__int64 *)lys_node_module(*(_QWORD *)(v48 + 64));
        sub_DC765((__int64)&s, 0, *(__int64 *)&v45[4], v40, 0);
      }
      v48 = lys_parent(v48);
      if ( !v48 || !(*(_DWORD *)(v48 + 56) & 0x1042) )
      {
        *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 2) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
        goto LABEL_62;
      }
      if ( sub_281C9(v48) )
      {
        if ( !*(_QWORD *)&v45[4] )
        {
          *(_QWORD *)v45 = (unsigned int)sub_27B5A((_QWORD *)a1, v48, &v45[4], &v44);
          if ( *(_DWORD *)v45 )
          {
            sub_12222(
              (__int64)v49,
              0,
              4,
              "Internal error (%s:%d).",
              (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
              6757LL);
            goto LABEL_62;
          }
        }
        v46 = 0LL;
        v47 = a1;
        *(_DWORD *)v45 = sub_27CDB(v48, &v47, (__int64 *)&v45[4], v44, (__int64)&v46);
        if ( *(_DWORD *)v45 )
          goto LABEL_62;
        v13 = (void **)lys_node_module(v48);
        v14 = v44;
        v15 = *(char **)&v45[4];
        v16 = (const char **)sub_281C9(v48);
        *(_DWORD *)v45 = sub_DC4B2(*v16, v15, v14, v13, &s, 2LL);
        if ( v46
          && *(_QWORD *)&v45[4]
          && (unsigned int)sub_27FD3(*(__int64 **)&v45[4], v46, v44, (__int64)v46, v17, v18) )
        {
          *(_DWORD *)v45 = -1;
          goto LABEL_62;
        }
        if ( *(_DWORD *)v45 )
        {
          if ( *(_DWORD *)v45 == 1 )
          {
            v19 = (__int64 *)sub_281C9(v48);
            sub_13937(v49, 61, 3u, (char *)a1, *v19, v20);
          }
          goto LABEL_62;
        }
        v21 = (__int64 *)lys_node_module(v48);
        sub_DC765((__int64)&s, 3, *(__int64 *)&v45[4], v21, 2);
        if ( !v51 )
        {
          if ( a2 != 1 && (!(*(_WORD *)(sub_281C9(v48) + 34) & 0x600) || a2 != 2) )
          {
            *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
            v24 = (__int64 *)sub_281C9(v48);
            sub_13937(v49, 59, 3u, (char *)a1, *v24, v25);
            if ( v43 )
              *v43 = sub_281C9(v48);
            goto LABEL_62;
          }
          v22 = (__int64 *)sub_281C9(v48);
          sub_12222(0LL, 2u, 0, "When condition \"%s\" is not satisfied, but it is not required.", *v22, v23);
        }
        v26 = (__int64 *)lys_node_module(v48);
        sub_DC765((__int64)&s, 0, *(__int64 *)&v45[4], v26, 0);
      }
    }
  }
  *(_BYTE *)(a1 + 9) = 2 * (((*(_BYTE *)(a1 + 9) >> 1) & 7 | 1) & 7) | *(_BYTE *)(a1 + 9) & 0xF1;
  if ( a2 == 1 || *(_WORD *)(sub_281C9(*(_QWORD *)a1) + 34) & 0x600 && a2 == 2 )
  {
    v8 = (__int64 *)sub_281C9(*(_QWORD *)a1);
    sub_12222(0LL, 2u, 0, "When condition \"%s\" is not satisfied, but it is not required.", *v8, v9);
    goto LABEL_15;
  }
  v10 = (__int64 *)sub_281C9(*(_QWORD *)a1);
  sub_13937(v49, 59, 3u, (char *)a1, *v10, v11);
  if ( v43 )
    *v43 = sub_281C9(*(_QWORD *)a1);
LABEL_62:
  if ( *(_QWORD *)&v45[4] )
    v41 = *(_QWORD *)&v45[4];
  else
    v41 = a1;
  sub_DC765((__int64)&s, 0, v41, 0LL, 0);
  return *(unsigned int *)v45;
}
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (0000000000028E3C) ----------------------------------------------------
signed __int64  sub_28E3C(__int64 a1)
{
  int v1; // eax
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  if ( *(_DWORD *)a1 != 11 || !*(_DWORD *)(a1 + 40) )
    return *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 28LL);
  for ( i = 0; (unsigned int)i < *(_DWORD *)(a1 + 40); ++i )
  {
    v1 = *(_DWORD *)(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 32));
    if ( v1 == 9 )
      return 1LL;
    if ( v1 == 11 && (unsigned int)sub_28E3C(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 32)) )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000028EDE) ----------------------------------------------------
signed __int64  sub_28EDE(void **a1, __int64 a2, unsigned int a3, unsigned __int8 *a4, __int64 a5)
{
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // rbx
  unsigned __int16 v11; // ax
  char *v12; // rdi
  __int64 v13; // r9
  int v14; // eax
  __int64 v15; // r9
  unsigned int v16; // eax
  __int64 v17; // r9
  void **v18; // rbx
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // [rsp+8h] [rbp-108h]
  unsigned __int8 *v23; // [rsp+10h] [rbp-100h]
  unsigned int v24; // [rsp+1Ch] [rbp-F4h]
  int v25; // [rsp+30h] [rbp-E0h]
  unsigned int v26; // [rsp+34h] [rbp-DCh]
  int v27; // [rsp+38h] [rbp-D8h]
  unsigned int v28; // [rsp+3Ch] [rbp-D4h]
  int i; // [rsp+40h] [rbp-D0h]
  int v30; // [rsp+44h] [rbp-CCh]
  unsigned __int8 *v31; // [rsp+48h] [rbp-C8h]
  unsigned __int8 *k; // [rsp+50h] [rbp-C0h]
  unsigned __int8 *j; // [rsp+58h] [rbp-B8h]
  void *v34; // [rsp+60h] [rbp-B0h]
  void *v35; // [rsp+68h] [rbp-A8h]
  void *src; // [rsp+70h] [rbp-A0h]
  __int64 v37; // [rsp+78h] [rbp-98h]
  __int64 v38; // [rsp+80h] [rbp-90h]
  __int64 **v39; // [rsp+88h] [rbp-88h]
  void *v40; // [rsp+90h] [rbp-80h]
  __int64 v41; // [rsp+98h] [rbp-78h]
  __int64 v42; // [rsp+A0h] [rbp-70h]
  __int64 *v43; // [rsp+A8h] [rbp-68h]
  __int64 v44; // [rsp+B0h] [rbp-60h]
  __int64 v45; // [rsp+B8h] [rbp-58h]
  __int64 v46; // [rsp+C0h] [rbp-50h]
  unsigned __int8 *v47; // [rsp+C8h] [rbp-48h]
  __int64 v48; // [rsp+D0h] [rbp-40h]
  __int64 v49; // [rsp+D8h] [rbp-38h]
  _BYTE *v50; // [rsp+E0h] [rbp-30h]
  void *ptr; // [rsp+E8h] [rbp-28h]
  void *v52; // [rsp+F0h] [rbp-20h]
  unsigned __int64 v53; // [rsp+F8h] [rbp-18h]

  v24 = a3;
  v23 = a4;
  v22 = a5;
  v53 = __readfsqword(0x28u);
  v26 = -1;
  v27 = 0;
  v28 = 0;
  v34 = *a1;
  if ( a3 == 512 )
  {
    v47 = a4;
    v27 = 1;
    v42 = a2;
    v26 = sub_25CE3((__int64)a1, 0LL, (char *)a4, (__int64)"type", a2, a5);
    goto LABEL_162;
  }
  if ( a3 > 0x200 )
  {
    if ( a3 == 0x4000 )
    {
      v41 = a2;
      v26 = sub_1F79E(*(_QWORD *)a2, *(const char **)(a2 + 8), *(_BYTE **)(a2 + 16));
      goto LABEL_162;
    }
    if ( a3 <= 0x4000 )
    {
      if ( a3 == 2048 )
      {
        ++v28;
      }
      else
      {
        if ( a3 <= 0x800 )
        {
          if ( a3 == 1024 )
          {
            v43 = (__int64 *)a2;
            if ( *(_BYTE *)(a2 + 27) )
            {
              v44 = ly_set_new(a1);
              v45 = ly_set_new(a1);
              ly_set_add(v45, v43, 0LL);
              while ( *(_DWORD *)(v45 + 4) )
              {
                v46 = *(_QWORD *)(*(_QWORD *)(v45 + 8) + 8LL * (unsigned int)(*(_DWORD *)(v45 + 4) - 1));
                ly_set_rm_index(v45, (unsigned int)(*(_DWORD *)(v45 + 4) - 1));
                for ( i = 0; i < *(unsigned __int8 *)(v46 + 27); ++i )
                {
                  sub_1902D((__int64 *)(*(_QWORD *)(v46 + 40) + 32LL * i), 0LL, &v25);
                  while ( v25 )
                  {
                    if ( !*(_QWORD *)(8LL * (unsigned int)(v25 - 1) + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)) )
                    {
                      v26 = 1;
                      goto LABEL_93;
                    }
                    if ( v43 == *(__int64 **)(8LL * (unsigned int)(v25 - 1)
                                            + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)) )
                    {
                      sub_13937(v34, 39, 0, 0LL, *v43, v13);
                      goto LABEL_93;
                    }
                    if ( *(_BYTE *)(*(_QWORD *)(8LL * (unsigned int)(v25 - 1)
                                              + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16))
                                  + 27LL) )
                    {
                      v30 = *(_DWORD *)(v44 + 4);
                      v14 = ly_set_add(
                              v44,
                              *(_QWORD *)(8LL * (unsigned int)(v25 - 1)
                                        + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)),
                              0LL);
                      if ( v30 == v14 )
                        ly_set_add(
                          v45,
                          *(_QWORD *)(8LL * (unsigned int)(v25 - 1) + *(_QWORD *)(32LL * i + *(_QWORD *)(v46 + 40) + 16)),
                          0LL);
                    }
                    --v25;
                  }
                }
              }
              v26 = 0;
LABEL_93:
              ly_set_free(v44);
              ly_set_free(v45);
            }
            goto LABEL_162;
          }
          goto LABEL_161;
        }
        if ( a3 != 4096 )
        {
          if ( a3 != 0x2000 )
            goto LABEL_161;
          v26 = sub_271C8(a2, *(char **)(a2 + 160));
          goto LABEL_162;
        }
      }
      v42 = a2;
      v26 = sub_1EAAF((_QWORD *)a2, (const char **)a4, a1, v28);
      if ( v26 == 1 && !v28 && *(_DWORD *)v42 == 9 )
      {
        for ( j = *(unsigned __int8 **)(v42 + 24); j && *((_DWORD *)j + 14) != 2048; j = (unsigned __int8 *)lys_parent(j) )
          ;
        if ( j )
          v26 = 0;
      }
      goto LABEL_162;
    }
    if ( a3 == 0x10000 )
    {
      v40 = a4;
      v39 = (__int64 **)(*(_QWORD *)a2 + 8LL * a4[41]);
      v26 = sub_22CDC(a4, v39, a5);
      if ( !v26 )
      {
        v37 = *(_QWORD *)(**v39 + 56);
        if ( v37 )
        {
          if ( *(_QWORD *)(v37 + 16) || *(_WORD *)(v37 + 4) & 1 )
          {
            v35 = malloc(1uLL);
            if ( !v35 )
            {
              sub_12222(
                (__int64)v34,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"resolve_unres_schema_item",
                v15);
              return 0xFFFFFFFFLL;
            }
            *(_BYTE *)v35 = *((_BYTE *)v40 + 41);
            if ( (unsigned int)sub_2ABDE((__int64 *)a1, v22, (__int64 *)a2, 0x40000u, (__int64 *)v35) == -1 )
              return 0xFFFFFFFFLL;
          }
        }
      }
      if ( !v26 || v26 == -1 )
      {
        if ( *((_DWORD *)v40 + 2) == 2 )
          lyxml_free(v34, *(_QWORD *)v40);
        else
          sub_952AD(*(void ***)v40);
        free(v40);
      }
      goto LABEL_162;
    }
    if ( a3 <= 0x10000 )
    {
      if ( a3 != 0x8000 )
        goto LABEL_161;
      v26 = sub_A9962((__int64)a1, a5);
      goto LABEL_162;
    }
    if ( a3 == 0x20000 )
    {
      k = (unsigned __int8 *)a2;
      v26 = sub_21FB6(a2, 1);
      goto LABEL_162;
    }
    if ( a3 != 0x40000 )
      goto LABEL_161;
    v35 = a4;
    src = *(void **)(*(_QWORD *)a2 + 8LL * *a4);
    free(a4);
    v37 = *(_QWORD *)(*(_QWORD *)src + 56LL);
    if ( !(*(_WORD *)(v37 + 4) & 1)
      || *((_BYTE *)src + 29) != 1
      || (v38 = *((_QWORD *)src + 1), *(_DWORD *)(v38 + 56) & 0x802C) )
    {
LABEL_157:
      if ( *(_QWORD *)(v37 + 16) && (*(unsigned int ( **)(void *))(v37 + 16))(src) )
      {
        sub_12222((__int64)v34, 0, 6, "Resolving extension failed.", v20, v21);
        return 0xFFFFFFFFLL;
      }
      v26 = 0;
      goto LABEL_162;
    }
    v31 = *(unsigned __int8 **)(v38 + 72);
    for ( k = v31; ; k = v31 )
    {
      if ( !k )
        goto LABEL_157;
      if ( (unsigned int)lys_ext_instance_presence(*(_QWORD *)src, *((_QWORD *)k + 4), k[26]) == -1
        && (v38 == *((_QWORD *)k + 8)
         || *(_DWORD *)(*((_QWORD *)k + 8) + 56LL) != 0x2000
         || (unsigned int)lys_ext_instance_presence(
                            *(_QWORD *)src,
                            *(_QWORD *)(*((_QWORD *)k + 8) + 32LL),
                            *(unsigned __int8 *)(*((_QWORD *)k + 8) + 26LL)) == -1) )
      {
        if ( !*(_QWORD *)(v37 + 24) )
          goto LABEL_142;
        v16 = (*(__int64 ( **)(void *, unsigned __int8 *))(v37 + 24))(src, k);
        v26 = v16;
        if ( v16 != 1 )
          break;
      }
LABEL_151:
      v31 = (unsigned __int8 *)*((_QWORD *)k + 10);
LABEL_154:
      while ( !v31 )
      {
        k = (unsigned __int8 *)lys_parent(k);
        if ( k == (unsigned __int8 *)v38 )
          break;
        v31 = (unsigned __int8 *)*((_QWORD *)k + 10);
      }
    }
    if ( v16 != 2 )
    {
      if ( v16 )
        sub_12222(
          (__int64)v34,
          0,
          4,
          "Plugin's (%s:%s) check_inherit callback returns invalid value (%d),",
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)src + 48LL) + 8LL),
          **(_QWORD **)src,
          v26);
LABEL_142:
      v39 = (__int64 **)realloc(*((void **)k + 4), 8LL * (k[26] + 1));
      if ( !v39 )
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_unres_schema_item", v17);
        return 0xFFFFFFFFLL;
      }
      v18 = (void **)&v39[k[26]];
      *v18 = malloc(0x40uLL);
      if ( !v39[k[26]] )
      {
        sub_12222((__int64)v34, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_unres_schema_item", v19);
        *((_QWORD *)k + 4) = v39;
        return 0xFFFFFFFFLL;
      }
      memcpy(v39[k[26]], src, 0x40uLL);
      *((_WORD *)v39[k[26]] + 12) |= 1u;
      *((_QWORD *)k + 4) = v39;
      ++k[26];
    }
    if ( *((_DWORD *)k + 14) & 0x802C )
      v31 = 0LL;
    else
      v31 = (unsigned __int8 *)*((_QWORD *)k + 9);
    if ( v31 )
      goto LABEL_154;
    goto LABEL_151;
  }
  if ( a3 == 16 )
  {
    ++v28;
    goto LABEL_39;
  }
  if ( a3 > 0x10 )
  {
    if ( a3 == 64 )
    {
      v26 = sub_2245A(a2, 0LL, a5);
    }
    else if ( a3 > 0x40 )
    {
      if ( a3 == 128 )
      {
        v47 = a4;
        v27 = 1;
        v49 = a2;
        if ( !*(_QWORD *)(a2 + 112) )
          *(_QWORD *)(v49 + 112) = sub_23C04(v49, (__int64)v47);
        if ( *(_QWORD *)(v49 + 112) )
          v26 = sub_3C679(v49);
        else
          v26 = 1;
        goto LABEL_162;
      }
      if ( a3 != 256 )
        goto LABEL_161;
      v47 = a4;
      v27 = 1;
      v48 = a2;
      v26 = sub_25CE3((__int64)a1, a2, (char *)a4, (__int64)"identity", 0LL, a5);
    }
    else
    {
      if ( a3 != 32 )
        goto LABEL_161;
      k = a4;
      v42 = a2;
      v26 = sub_20BE2((__int64 *)a2, (__int64)a4, a5);
    }
    goto LABEL_162;
  }
  if ( a3 == 2 )
  {
    v52 = a4;
    v10 = *(_QWORD *)a4;
    v11 = strlen(*((const char **)a4 + 1));
    v12 = (char *)*((_QWORD *)v23 + 1);
    v26 = sub_1844C(v12, v11, v10, (_QWORD *)a2);
    if ( !v26 )
    {
      if ( *((_DWORD *)v52 + 4) )
      {
        v43 = *(__int64 **)a2;
        if ( !v43[7] )
          v43[7] = ly_set_new(v12);
        ly_set_add(v43[7], *(_QWORD *)v52, 1LL);
      }
      lydict_remove(v34, *((_QWORD *)v52 + 1));
      free(v52);
    }
    goto LABEL_162;
  }
  if ( a3 > 2 )
  {
    if ( a3 == 4 )
      goto LABEL_40;
    if ( a3 != 8 )
      goto LABEL_161;
LABEL_39:
    ++v28;
LABEL_40:
    k = a4;
    v42 = a2;
    v50 = *(_BYTE **)(a2 + 16);
    *(_QWORD *)(a2 + 16) = 0LL;
    if ( *v50 >= 0 )
    {
      v26 = sub_426E1((__int64)a1, (char *)k, (__int64)v50, v42, v28, a5);
      if ( v26 && v26 != -1 )
        *(_QWORD *)(v42 + 16) = v50;
      else
        lyxml_free(v34, v50);
    }
    else
    {
      ptr = v50;
      v26 = sub_8D12E((__int64)a1, (char *)k, (__int64)v50, (int *)v42, v28, a5);
      if ( v26 )
      {
        *(_QWORD *)(v42 + 16) = ptr;
      }
      else
      {
        lydict_remove(v34, *((_QWORD *)ptr + 1));
        free(ptr);
      }
    }
    if ( v26 )
    {
      if ( v26 == 1 && *(_BYTE *)(v42 + 4) >= 0 )
      {
        for ( j = k; j && *((_DWORD *)j + 14) != 2048; j = (unsigned __int8 *)lys_parent(j) )
          ;
        if ( j )
        {
          if ( !++*((_WORD *)j + 14) )
          {
            sub_12222((__int64)v34, 0, 4, "Too many unresolved items (type) inside a grouping.", v5, v6);
            return 0xFFFFFFFFLL;
          }
          *(_BYTE *)(v42 + 4) |= 0x80u;
        }
      }
    }
    else
    {
      if ( !v28 && *((_DWORD *)k + 14) == 8 && *(_DWORD *)v42 == 5 )
        sub_12222(
          (__int64)v34,
          1u,
          0,
          "The leaf-list \"%s\" is of \"empty\" type, which does not make sense.",
          *(_QWORD *)k,
          v6);
      if ( v24 != 8 || *(_DWORD *)v42 != 11 )
      {
        if ( v24 == 4
          && *(_BYTE *)(*(_QWORD *)(v42 + 16) + 28LL)
          && (unsigned int)sub_A0555((__int64 *)a1, (__int64 *)k, (void *)v42, 0LL, v22) )
        {
          sub_12222((__int64)v34, 0, 4, "Failed to duplicate type.", v7, v8);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)(v42 + 24) + 28LL) = sub_28E3C(v42);
      }
    }
    goto LABEL_162;
  }
  if ( a3 != 1 )
  {
LABEL_161:
    sub_12222(
      (__int64)v34,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
      7267LL);
    goto LABEL_162;
  }
  v26 = sub_26D87((_BYTE **)a2, a5);
LABEL_162:
  if ( v27 )
  {
    if ( !v26 )
      lydict_remove(v34, v23);
  }
  return v26;
}
// 72B0: using guessed type __int64  lys_ext_instance_presence(_QWORD, _QWORD, _QWORD);
// 72E0: using guessed type __int64  ly_set_rm_index(_QWORD, _QWORD);
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 78A0: using guessed type __int64  lyxml_free(_QWORD, _QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (000000000002A1A7) ----------------------------------------------------
unsigned __int64  sub_2A1A7(__int64 *a1, unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // rax
  __int64 i; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+40h] [rbp-10h]

  v9 = 0LL;
  if ( a2 == 256 )
    return sub_12222(
             0LL,
             2u,
             0,
             "Resolving %s \"%s\" failed, it will be attempted later.",
             (__int64)"identity",
             (__int64)a3);
  if ( a2 <= 0x100 )
  {
    if ( a2 == 8 )
      goto LABEL_32;
    if ( a2 <= 8 )
    {
      if ( a2 == 2 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"if-feature",
                 a3[1]);
      if ( a2 != 4 )
      {
        if ( a2 == 1 )
          return sub_12222(0LL, 2u, 0, "Resolving %s \"%s\" failed, it will be attempted later.", (__int64)"uses", *a1);
        return sub_12222(
                 0LL,
                 0,
                 4,
                 "Internal error (%s:%d).",
                 (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
                 7360LL);
      }
      goto LABEL_32;
    }
    if ( a2 == 32 )
      return sub_12222(0LL, 2u, 0, "Resolving %s \"%s\" failed, it will be attempted later.", (__int64)"leafref", a1[4]);
    if ( a2 > 0x20 )
    {
      if ( a2 == 64 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"augment target",
                 *a1);
      if ( a2 == 128 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"choice default",
                 (__int64)a3);
      return sub_12222(
               0LL,
               0,
               4,
               "Internal error (%s:%d).",
               (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
               7360LL);
    }
    if ( a2 == 16 )
    {
LABEL_32:
      v10 = a1[2];
      if ( *(_BYTE *)v10 < 0 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"derived type",
                 *(_QWORD *)(v10 + 8));
      for ( i = *(_QWORD *)(v10 + 16); i; i = *(_QWORD *)(i + 8) )
      {
        if ( *(_DWORD *)i == 1 && !strcmp(*(const char **)(i + 24), "name") )
        {
          v9 = *(_QWORD *)(i + 32);
          break;
        }
      }
      if ( !i )
        __assert_fail(
          "attr",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x1C92u,
          "print_unres_schema_item_fail");
      return sub_12222(
               0LL,
               2u,
               0,
               "Resolving %s \"%s\" failed, it will be attempted later.",
               (__int64)"derived type",
               v9);
    }
    return sub_12222(
             0LL,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
             7360LL);
  }
  if ( a2 == 4096 )
  {
LABEL_47:
    result = *a3;
    if ( *a3 )
      result = sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"type default",
                 *a3);
    return result;
  }
  if ( a2 <= 0x1000 )
  {
    if ( a2 == 1024 )
      return sub_12222(
               0LL,
               2u,
               0,
               "There are unresolved if-features for \"%s\" feature circular dependency check, it will be attempted later",
               *a1,
               a6);
    if ( a2 != 2048 )
    {
      if ( a2 == 512 )
        return sub_12222(
                 0LL,
                 2u,
                 0,
                 "Resolving %s \"%s\" failed, it will be attempted later.",
                 (__int64)"identityref",
                 (__int64)a3);
      return sub_12222(
               0LL,
               0,
               4,
               "Internal error (%s:%d).",
               (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
               7360LL);
    }
    goto LABEL_47;
  }
  if ( a2 == 0x4000 )
    return sub_12222(
             0LL,
             2u,
             0,
             "Resolving %s \"%s\" failed, it will be attempted later.",
             (__int64)"list unique",
             (__int64)a3);
  if ( a2 <= 0x4000 )
  {
    if ( a2 == 0x2000 )
      return sub_12222(
               0LL,
               2u,
               0,
               "Resolving %s \"%s\" failed, it will be attempted later.",
               (__int64)"list keys",
               (__int64)a3);
    return sub_12222(
             0LL,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
             7360LL);
  }
  if ( a2 != 0x10000 )
  {
    if ( a2 == 0x20000 )
      return sub_12222(
               0LL,
               2u,
               0,
               "Resolving %s \"%s\" failed, it will be attempted later.",
               (__int64)"XPath expressions of",
               *a1);
    return sub_12222(
             0LL,
             0,
             4,
             "Internal error (%s:%d).",
             (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
             7360LL);
  }
  if ( *((_DWORD *)a3 + 2) == 2 )
    v7 = *(_QWORD *)(*a3 + 48);
  else
    v7 = 0LL;
  return sub_12222(0LL, 2u, 0, "Resolving extension \"%s\" failed, it will be attempted later.", v7, a6);
}

//----- (000000000002A690) ----------------------------------------------------
signed __int64  sub_2A690(__int64 a1, int a2, __int64 a3, int a4, int a5, _DWORD *a6)
{
  signed __int64 result; // rax
  _DWORD *v7; // rax
  _DWORD *v8; // [rsp+8h] [rbp-58h]
  int v9; // [rsp+14h] [rbp-4Ch]
  __int64 v10; // [rsp+18h] [rbp-48h]
  int v11; // [rsp+20h] [rbp-40h]
  int v12; // [rsp+34h] [rbp-2Ch]
  unsigned int i; // [rsp+38h] [rbp-28h]
  unsigned int v14; // [rsp+3Ch] [rbp-24h]
  unsigned int v15; // [rsp+40h] [rbp-20h]
  unsigned int v16; // [rsp+44h] [rbp-1Ch]
  int v17; // [rsp+48h] [rbp-18h]
  int v18; // [rsp+4Ch] [rbp-14h]
  __int64 v19; // [rsp+50h] [rbp-10h]
  unsigned __int64 v20; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v11 = a4;
  v9 = a5;
  v8 = a6;
  v20 = __readfsqword(0x28u);
  v16 = 0;
  if ( a4 )
  {
    v17 = *(_DWORD *)ly_errno_glob_address(a1);
    sub_141E4(v10, 1u, &v12, (__int64)&v19);
  }
  while ( 2 )
  {
    v14 = 0;
    v15 = 0;
    for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
    {
      if ( a2 & *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) )
      {
        ++v14;
        v18 = sub_28EDE(
                *(void ***)(8LL * i + *(_QWORD *)(a1 + 24)),
                *(_QWORD *)(8LL * i + *(_QWORD *)a1),
                *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)),
                *(unsigned __int8 **)(8LL * i + *(_QWORD *)(a1 + 16)),
                a1);
        if ( *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) == 0x40000 )
          *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) = 0x4000000;
        if ( v18 && *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) != 0x20000 )
        {
          if ( v18 == 1 && v11 )
          {
            sub_1404C(v10, v19);
          }
          else
          {
            if ( !v9 )
            {
              if ( v11 )
                sub_142D2(v10, v12, v19, 1);
              return 0xFFFFFFFFLL;
            }
            ++v15;
            v16 = -1;
          }
        }
        else
        {
          if ( *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) == 0x4000 )
            free(*(void **)(8LL * i + *(_QWORD *)a1));
          *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) = 0x4000000;
          ++*v8;
          ++v15;
        }
      }
    }
    if ( v15 && v15 < v14 )
      continue;
    break;
  }
  if ( v15 >= v14 )
  {
    if ( v11 )
    {
      sub_142D2(v10, v12, v19, 0);
      v7 = (_DWORD *)ly_errno_glob_address(v10);
      *v7 = v17;
    }
    result = v16;
  }
  else
  {
    if ( !v11 )
      __assert_fail(
        "forward_ref",
        "/home/mantovan/Repositories/libyang/src/resolve.c",
        0x1D00u,
        "resolve_unres_schema_types");
    sub_142D2(v10, v12, v19, 0);
    for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
    {
      if ( a2 & *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)) )
        sub_28EDE(
          *(void ***)(8LL * i + *(_QWORD *)(a1 + 24)),
          *(_QWORD *)(8LL * i + *(_QWORD *)a1),
          *(_DWORD *)(4LL * i + *(_QWORD *)(a1 + 8)),
          *(unsigned __int8 **)(8LL * i + *(_QWORD *)(a1 + 16)),
          a1);
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);

//----- (000000000002A9F8) ----------------------------------------------------
signed __int64  sub_2A9F8(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // [rsp+0h] [rbp-20h]
  int v9; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v10; // [rsp+18h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v9 = 0;
  if ( !a2 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x1D22u, "resolve_unres_schema");
  sub_12222(0LL, 2u, 0, "Resolving \"%s\" unresolved schema nodes and their constraints...", a1[1], a6, a2);
  if ( (unsigned int)sub_2A690(v8, 33263, *a1, 1, 0, &v9) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_2A690(v8, (unsigned __int64)&loc_17E00, *a1, 1, 0, &v9) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_2A690(v8, 393216, *a1, 0, 1, &v9) )
    return 0xFFFFFFFFLL;
  sub_12222(0LL, 2u, 0, "All \"%s\" schema nodes and constraints resolved.", a1[1], v7);
  *(_DWORD *)(v8 + 32) = 0;
  return 0LL;
}

//----- (000000000002AB62) ----------------------------------------------------
__int64  sub_2AB62(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 a5)
{
  __int64 *v5; // ST18_8
  unsigned int v6; // ST14_4
  unsigned int v8; // [rsp+34h] [rbp-Ch]
  __int64 *v9; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v6 = a4;
  v9 = (__int64 *)lydict_insert(*a1, a5, 0LL);
  v8 = sub_2ABDE(a1, a2, v5, v6, v9);
  if ( (v8 & 0x80000000) != 0 )
    lydict_remove(*a1, v9);
  return v8;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (000000000002ABDE) ----------------------------------------------------
signed __int64  sub_2ABDE(__int64 *a1, __int64 a2, __int64 *a3, unsigned int a4, __int64 *a5)
{
  signed __int64 result; // rax
  __int64 v6; // rdi
  _DWORD *v7; // rax
  __int64 v8; // rdi
  _DWORD *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  __int64 *v16; // [rsp+8h] [rbp-58h]
  unsigned int v17; // [rsp+14h] [rbp-4Ch]
  __int64 *ptr; // [rsp+18h] [rbp-48h]
  __int64 *v19; // [rsp+28h] [rbp-38h]
  int v20; // [rsp+30h] [rbp-30h]
  unsigned int v21; // [rsp+34h] [rbp-2Ch]
  unsigned int i; // [rsp+38h] [rbp-28h]
  int v23; // [rsp+3Ch] [rbp-24h]
  __int64 v24; // [rsp+40h] [rbp-20h]
  __int64 v25; // [rsp+48h] [rbp-18h]
  _QWORD *v26; // [rsp+50h] [rbp-10h]
  unsigned __int64 v27; // [rsp+58h] [rbp-8h]

  v19 = a1;
  ptr = a3;
  v17 = a4;
  v16 = a5;
  v27 = __readfsqword(0x28u);
  v25 = *a1;
  if ( !a2 || !a3 && a4 != 0x8000 || a4 == 0x80000 || a4 == (_DWORD)&loc_100000 || a4 == 0x200000 || a4 == 0x400000 )
    __assert_fail(
      "unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type !="
      " UNRES_WHEN) && (type != UNRES_MUST))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1D72u,
      "unres_schema_add_node");
  for ( i = 0; i < *(_DWORD *)(a2 + 32); ++i )
  {
    if ( a4 == *(_DWORD *)(4LL * i + *(_QWORD *)(a2 + 8))
      && a3 == *(__int64 **)(8LL * i + *(_QWORD *)a2)
      && a5 == *(__int64 **)(8LL * i + *(_QWORD *)(a2 + 16))
      && a1 == *(__int64 **)(8LL * i + *(_QWORD *)(a2 + 24)) )
    {
      return 1LL;
    }
  }
  if ( a4 == 0x40000 || a4 == 0x20000 || a4 == 0x8000 )
  {
    v21 = 1;
LABEL_34:
    *(_QWORD *)a2 = sub_C422(*(void **)a2, 8LL * (unsigned int)++*(_DWORD *)(a2 + 32));
    if ( *(_QWORD *)a2 )
    {
      *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)a2) = ptr;
      *(_QWORD *)(a2 + 8) = sub_C422(*(void **)(a2 + 8), 4LL * *(unsigned int *)(a2 + 32));
      if ( *(_QWORD *)(a2 + 8) )
      {
        *(_DWORD *)(4LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)(a2 + 8)) = v17;
        *(_QWORD *)(a2 + 16) = sub_C422(*(void **)(a2 + 16), 8LL * *(unsigned int *)(a2 + 32));
        if ( *(_QWORD *)(a2 + 16) )
        {
          *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)(a2 + 16)) = v16;
          *(_QWORD *)(a2 + 24) = sub_C422(*(void **)(a2 + 24), 8LL * *(unsigned int *)(a2 + 32));
          if ( *(_QWORD *)(a2 + 24) )
          {
            *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a2 + 32) - 1) + *(_QWORD *)(a2 + 24)) = v19;
            result = v21;
          }
          else
          {
            sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v15);
            result = 0xFFFFFFFFLL;
          }
        }
        else
        {
          sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v14);
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v13);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      sub_12222(v25, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_add_node", v12);
      result = 0xFFFFFFFFLL;
    }
    return result;
  }
  v23 = *(_DWORD *)ly_errno_glob_address(a1);
  sub_141E4(v25, 1u, &v20, (__int64)&v24);
  v21 = sub_28EDE((void **)a1, (__int64)ptr, v17, (unsigned __int8 *)v16, a2);
  if ( v21 == 1 )
  {
    v8 = v25;
    sub_142D2(v25, v20, v24, 0);
    v9 = (_DWORD *)ly_errno_glob_address(v8);
    *v9 = v23;
    sub_2A1A7(ptr, v17, v16, v17, v10, v11);
    if ( v17 == 4 || v17 == 8 )
    {
      v26 = (_QWORD *)ptr[2];
      if ( *(_BYTE *)v26 >= 0 )
      {
        sub_30B77(*v19, v26, 1);
        ptr[2] = (__int64)v26;
      }
    }
    goto LABEL_34;
  }
  v6 = v25;
  sub_142D2(v25, v20, v24, v21 == -1);
  if ( v21 != -1 )
  {
    v7 = (_DWORD *)ly_errno_glob_address(v6);
    *v7 = v23;
  }
  if ( v17 == 0x4000 )
  {
    free(ptr);
  }
  else if ( v21 == -1 && v17 == 2 )
  {
    free((void *)*ptr);
  }
  return v21;
}
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);

//----- (000000000002B0C1) ----------------------------------------------------
signed __int64  sub_2B0C1(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5)
{
  signed __int64 result; // rax
  __int64 v6; // r9
  void *ptr; // [rsp+8h] [rbp-58h]
  unsigned int v8; // [rsp+14h] [rbp-4Ch]
  __int64 *v9; // [rsp+18h] [rbp-48h]
  int v10; // [rsp+34h] [rbp-2Ch]
  _QWORD *v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = (__int64 *)a3;
  v8 = a4;
  ptr = a5;
  v14 = __readfsqword(0x28u);
  if ( !a3 || !a5 || a4 == 0x80000 || a4 == (_DWORD)&loc_100000 || a4 == 0x200000 )
    __assert_fail(
      "item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN))",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1DCDu,
      "unres_schema_dup");
  if ( a4 == 0x4000 )
  {
    v12 = a3;
    v13 = a5[1];
    v9 = &v12;
  }
  v10 = sub_2B3F8(a2, -1, (__int64)v9, a4);
  if ( v10 == -1 )
  {
    if ( v8 == 0x4000 )
      free(ptr);
    result = 1LL;
  }
  else
  {
    if ( v8 != 32 && v8 != 1 && v8 != 4096 && v8 != 1024 && v8 != 0x4000 )
    {
      if ( v8 == 2 )
      {
        v11 = malloc(0x18uLL);
        if ( !v11 )
        {
          sub_12222(*a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_schema_dup", v6);
          return 0xFFFFFFFFLL;
        }
        v11[1] = lydict_insert(*a1, *(_QWORD *)(*(_QWORD *)(8LL * v10 + *(_QWORD *)(a2 + 16)) + 8LL), 0LL);
        *v11 = **(_QWORD **)(8LL * v10 + *(_QWORD *)(a2 + 16));
        *((_DWORD *)v11 + 4) = *(_DWORD *)(*(_QWORD *)(8LL * v10 + *(_QWORD *)(a2 + 16)) + 16LL);
        if ( (unsigned int)sub_2ABDE(a1, a2, (__int64 *)ptr, 2u, v11) == -1 )
        {
          sub_12222(
            *a1,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
            7660LL);
          return 0xFFFFFFFFLL;
        }
      }
      else if ( (unsigned int)sub_2AB62(a1, a2, (__int64 *)ptr, v8, *(_QWORD *)(8LL * v10 + *(_QWORD *)(a2 + 16))) == -1 )
      {
        sub_12222(
          *a1,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
          7665LL);
        return 0xFFFFFFFFLL;
      }
    }
    else if ( (unsigned int)sub_2ABDE(a1, a2, (__int64 *)ptr, v8, *(__int64 **)(8LL * v10 + *(_QWORD *)(a2 + 16))) == -1 )
    {
      sub_12222(
        *a1,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
        7649LL);
      return 0xFFFFFFFFLL;
    }
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (000000000002B3F8) ----------------------------------------------------
signed __int64  sub_2B3F8(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+10h] [rbp-30h]
  int v7; // [rsp+2Ch] [rbp-14h]
  __int64 v8; // [rsp+30h] [rbp-10h]

  v5 = a3;
  v6 = a4;
  if ( !*(_DWORD *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  if ( a2 < 0 )
    v7 = *(_DWORD *)(a1 + 32) - 1;
  else
    v7 = a2;
  while ( v7 >= 0 )
  {
    if ( v6 == *(_DWORD *)(4LL * v7 + *(_QWORD *)(a1 + 8)) )
    {
      if ( v6 == 0x4000 )
      {
        v8 = *(_QWORD *)(8LL * v7 + *(_QWORD *)a1);
        if ( *(_QWORD *)v8 == *(_QWORD *)v5 && (unsigned int)sub_C462(*(_BYTE **)(v8 + 8), *(_BYTE **)(v5 + 8)) )
          return (unsigned int)v7;
      }
      else if ( v5 == *(_QWORD *)(8LL * v7 + *(_QWORD *)a1) )
      {
        return (unsigned int)v7;
      }
    }
    --v7;
  }
  return (unsigned int)v7;
}

//----- (000000000002B4F8) ----------------------------------------------------
_DWORD * sub_2B4F8(__int64 a1, _QWORD *a2, unsigned int a3)
{
  unsigned int v3; // eax
  _DWORD *result; // rax
  unsigned int v5; // [rsp+Ch] [rbp-34h]
  _BYTE *v6; // [rsp+28h] [rbp-18h]

  v5 = a3;
  v3 = *(_DWORD *)(4LL * a3 + a2[1]);
  if ( v3 == 256 )
    goto LABEL_23;
  if ( v3 > 0x100 )
  {
    if ( v3 == 0x4000 )
    {
      free(*(void **)(8LL * a3 + *a2));
      goto LABEL_27;
    }
    if ( v3 > 0x4000 )
    {
      if ( v3 == 0x10000 )
      {
        free(*(void **)(8LL * a3 + a2[2]));
      }
      else if ( v3 == 0x40000 )
      {
        free(*(void **)(8LL * a3 + a2[2]));
      }
      goto LABEL_27;
    }
    if ( v3 != 512 && v3 != 0x2000 )
      goto LABEL_27;
LABEL_23:
    lydict_remove(a1, *(_QWORD *)(8LL * a3 + a2[2]));
    goto LABEL_27;
  }
  if ( v3 != 4 )
  {
    if ( v3 <= 4 )
    {
      if ( v3 == 2 )
      {
        lydict_remove(a1, *(_QWORD *)(*(_QWORD *)(8LL * a3 + a2[2]) + 8LL));
        free(*(void **)(8LL * v5 + a2[2]));
      }
      goto LABEL_27;
    }
    if ( v3 != 8 )
    {
      if ( v3 != 128 )
        goto LABEL_27;
      goto LABEL_23;
    }
  }
  v6 = *(_BYTE **)(*(_QWORD *)(8LL * a3 + *a2) + 16LL);
  if ( *v6 >= 0 )
  {
    lyxml_free(a1, v6);
  }
  else
  {
    **(_DWORD **)(8LL * a3 + *a2) = *((_DWORD *)v6 + 1);
    lydict_remove(a1, *((_QWORD *)v6 + 1));
    free(v6);
    if ( **(_DWORD **)(8LL * v5 + *a2) == 11 )
      sub_8EB71(a1, *(_QWORD *)(8LL * v5 + *a2));
  }
LABEL_27:
  result = (_DWORD *)(4LL * v5 + a2[1]);
  *result = 0x4000000;
  return result;
}
// 78A0: using guessed type __int64  lyxml_free(_QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (000000000002B768) ----------------------------------------------------
void * sub_2B768(__int64 a1, void ***a2, int a3)
{
  void *result; // rax
  int v4; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  v6 = 0;
  if ( a2 )
  {
    result = *a2;
    if ( *a2 )
    {
      if ( !a1 && *((_DWORD *)*a2 + 8) )
        __assert_fail(
          "module || ((*unres)->count == 0)",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x1E57u,
          "unres_schema_free");
      for ( i = 0; ; ++i )
      {
        result = (void *)*((unsigned int *)*a2 + 8);
        if ( i >= (unsigned int)result )
          break;
        if ( v4 || a1 == *((_QWORD *)(*a2)[3] + i) )
        {
          sub_2B4F8(*(_QWORD *)a1, *a2, i);
        }
        else if ( *((_DWORD *)(*a2)[1] + i) != 0x4000000 )
        {
          ++v6;
        }
      }
      if ( !a1 || v4 || !v6 && (result = (void *)(*(_BYTE *)(a1 + 64) & 1), !(_BYTE)result) )
      {
        free(**a2);
        free((*a2)[1]);
        free((*a2)[2]);
        free((*a2)[3]);
        free(*a2);
        result = a2;
        *a2 = 0LL;
      }
    }
  }
  return result;
}

//----- (000000000002B8E0) ----------------------------------------------------
signed __int64  sub_2B8E0(__int64 a1, const char *a2)
{
  __int64 v3; // rdx
  __int64 v4; // rbx
  int v5; // [rsp+14h] [rbp-3Ch]
  __int64 i; // [rsp+18h] [rbp-38h]
  char *v7; // [rsp+20h] [rbp-30h]
  void *ptr; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  unsigned __int64 v10; // [rsp+38h] [rbp-18h]

  v10 = __readfsqword(0x28u);
  if ( !a2 || !*a2 )
    return 0LL;
  for ( i = lys_parent(a1); i && !(*(_DWORD *)(i + 56) & 0x4180); i = lys_parent(i) )
    ;
  if ( i && lys_parent(i) )
    return 1LL;
  v7 = strchr(a2 + 1, 47);
  if ( v7 )
    v3 = v7 - a2;
  else
    v3 = strlen(a2);
  ptr = strndup(a2, v3);
  if ( !ptr )
    return 0LL;
  sub_141E4(0LL, 2u, &v5, 0LL);
  v9 = ly_ctx_get_node(0LL, a1, ptr, 0LL);
  sub_142D2(0LL, v5, 0LL, 0);
  free(ptr);
  if ( !v9 )
    return 1LL;
  if ( i )
  {
    if ( i != v9 )
      return 1LL;
  }
  else
  {
    v4 = lys_node_module(a1);
    if ( v4 != lys_node_module(v9) )
      return 1LL;
  }
  return 0LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 78D0: using guessed type __int64  ly_ctx_get_node(_QWORD, _QWORD, _QWORD, _QWORD);
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000002BAA8) ----------------------------------------------------
signed __int64  sub_2BAA8(char *a1, __int64 a2, int a3, _QWORD *a4)
{
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // r9
  unsigned int v7; // eax
  signed __int64 result; // rax
  _QWORD *v9; // [rsp+0h] [rbp-B0h]
  int v10; // [rsp+Ch] [rbp-A4h]
  int v11; // [rsp+24h] [rbp-8Ch]
  unsigned int v12; // [rsp+28h] [rbp-88h]
  int v13; // [rsp+2Ch] [rbp-84h]
  int v14; // [rsp+30h] [rbp-80h]
  unsigned int j; // [rsp+34h] [rbp-7Ch]
  int v16; // [rsp+38h] [rbp-78h]
  int v17; // [rsp+3Ch] [rbp-74h]
  __int64 v18; // [rsp+40h] [rbp-70h]
  char *string; // [rsp+48h] [rbp-68h]
  const char *v20; // [rsp+50h] [rbp-60h]
  __int64 v21; // [rsp+58h] [rbp-58h]
  __int64 v22; // [rsp+60h] [rbp-50h]
  char *i; // [rsp+68h] [rbp-48h]
  __int64 v24; // [rsp+70h] [rbp-40h]
  void *ptr; // [rsp+78h] [rbp-38h]
  _QWORD *s; // [rsp+80h] [rbp-30h]
  unsigned int v27; // [rsp+90h] [rbp-20h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v28 = __readfsqword(0x28u);
  v14 = 0;
  v22 = 0LL;
  v24 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  string = 0LL;
  memset(&s, 0, 0x28uLL);
  *v9 = 0LL;
  for ( i = a1; *((_QWORD *)i + 5); i = (char *)*((_QWORD *)i + 5) )
    ;
  if ( *((_QWORD *)i + 4) )
  {
    while ( *(_QWORD *)(*((_QWORD *)i + 4) + 24LL) )
      i = (char *)*((_QWORD *)i + 4);
  }
  while ( *(_BYTE *)(v14 + a2) )
  {
    j = sub_1729D(
          (_BYTE *)(v14 + a2),
          (signed __int64 *)&string,
          (unsigned int *)&v11,
          (signed __int64 *)&v20,
          &v12,
          &v13);
    if ( (signed int)j <= 0 )
    {
      sub_13937(
        (void *)v24,
        55,
        3u,
        a1,
        (unsigned int)*(char *)((signed int)(v14 - j) + a2),
        (signed int)(v14 - j) + a2,
        v9);
LABEL_54:
      free(s);
      return 0xFFFFFFFFLL;
    }
    v14 += j;
    if ( string )
    {
      ptr = strndup(string, v11);
      if ( !ptr )
      {
        sub_12222(v24, 0, 1, "Memory allocation failed (%s()).", (__int64)"resolve_instid", v5, v9);
        goto LABEL_54;
      }
      v21 = ly_ctx_get_module(v24, ptr, 0LL, 1LL);
      if ( *(_QWORD *)(v24 + 112) )
      {
        if ( v21 )
        {
          if ( *(_BYTE *)(v21 + 64) >= 0 )
            v21 = (*(__int64 ( **)(__int64, _QWORD, _QWORD, signed __int64, _QWORD))(v24 + 112))(
                    v24,
                    *(_QWORD *)(v21 + 8),
                    *(_QWORD *)(v21 + 176),
                    1LL,
                    *(_QWORD *)(v24 + 120));
        }
        else
        {
          v21 = (*(__int64 ( **)(__int64, void *, _QWORD, _QWORD, _QWORD))(v24 + 112))(
                  v24,
                  ptr,
                  0LL,
                  0LL,
                  *(_QWORD *)(v24 + 120));
        }
      }
      free(ptr);
      if ( !v21 || *(_BYTE *)(v21 + 64) >= 0 || *(_BYTE *)(v21 + 64) & 0x40 )
        break;
    }
    else
    {
      if ( !v22 )
      {
        sub_13937((void *)v24, 48, 3u, a1, v12, (__int64)v20, v9);
        sub_13937((void *)v24, -1, 5u, 0LL, (__int64)"Instance-identifier is missing prefix in the first node.", v6);
        goto LABEL_54;
      }
      v21 = v22;
    }
    if ( (unsigned int)sub_1FBFE((__int64 *)v21, v20, v12, (__int64)i, (__int64)&s) )
      break;
    if ( v13 )
    {
      j = 0;
      v16 = 0;
      v17 = 1;
      while ( (signed int)j < (signed int)v27 )
      {
        v18 = s[j];
        v16 = sub_2170F(v21, v14 + a2, (__int64 **)&v18, v17);
        if ( v16 <= 0 )
        {
          sub_13937((void *)v24, 56, 3u, a1, v14 - v16 + a2, v4, v9);
          goto LABEL_54;
        }
        if ( v18 )
          ++j;
        else
          sub_1FB5F((__int64)&s, j);
        ++v17;
      }
      v14 += v16;
    }
    else if ( v27 )
    {
      for ( j = 0; v27 > j; ++j )
      {
        if ( *(_DWORD *)(*(_QWORD *)s[j] + 56LL) == 16 )
        {
          v7 = j--;
          sub_1FB5F((__int64)&s, v7);
        }
      }
      if ( !v27 )
        sub_13937((void *)v24, -1, 3u, a1, (__int64)"Instance identifier is missing list keys.", v4, v9);
    }
    v22 = v21;
  }
  if ( v27 )
  {
    if ( v27 <= 1 )
    {
      *v9 = *s;
      free(s);
      return 0LL;
    }
    sub_13937((void *)v24, 14, 3u, a1, a2, (__int64)"data tree", v9);
    goto LABEL_54;
  }
  if ( v10 < 0 )
  {
    sub_12222(0LL, 2u, 0, "There is no instance of \"%s\", but it is not required.", a2, v4, v9);
    result = 0LL;
  }
  else
  {
    sub_13937((void *)v24, 64, 3u, a1, a2, v4, v9);
    result = 1LL;
  }
  return result;
}
// 7330: using guessed type __int64  ly_ctx_get_module(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002C0A6) ----------------------------------------------------
signed __int64  sub_2C0A6(__int64 a1, const char *a2, int a3, _QWORD *a4)
{
  void **v4; // rax
  _QWORD *v6; // [rsp+0h] [rbp-80h]
  int v7; // [rsp+Ch] [rbp-74h]
  unsigned int i; // [rsp+2Ch] [rbp-54h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v10; // [rsp+40h] [rbp-40h]
  unsigned int v11; // [rsp+50h] [rbp-30h]
  unsigned __int64 v12; // [rsp+78h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v12 = __readfsqword(0x28u);
  memset(&s, 0, 0x40uLL);
  *v6 = 0LL;
  v4 = (void **)lyd_node_module(a1);
  if ( (unsigned int)sub_DC4B2(a2, (char *)a1, 2, v4, &s, 0LL) )
    return 0xFFFFFFFFLL;
  if ( s == 1 )
  {
    for ( i = 0; i < v11; ++i )
    {
      if ( *(_DWORD *)(16LL * i + v10 + 8) == 2
        && *(_DWORD *)(**(_QWORD **)(16LL * i + v10) + 56LL) & 0xC
        && *(_QWORD *)(a1 + 56) == *(_QWORD *)(*(_QWORD *)(16LL * i + v10) + 56LL) )
      {
        *v6 = *(_QWORD *)(16LL * i + v10);
        break;
      }
    }
  }
  sub_DC765((__int64)&s, 0, a1, 0LL, 0);
  if ( !*v6 )
  {
    if ( v7 >= 0 )
    {
      sub_13937(**(void ***)(*(_QWORD *)a1 + 48LL), 65, 3u, (char *)a1, (__int64)a2, *(_QWORD *)(a1 + 56), v6);
      return 1LL;
    }
    sub_12222(
      0LL,
      2u,
      0,
      "There is no leafref \"%s\" with the value \"%s\", but it is not required.",
      (__int64)a2,
      *(_QWORD *)(a1 + 56),
      v6);
  }
  return 0LL;
}
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);

//----- (000000000002C282) ----------------------------------------------------
signed __int64  sub_2C282(__int64 a1, _DWORD *a2, int a3, int a4, _QWORD *a5)
{
  const char *v6; // rax
  __int64 v7; // rax
  void *v8; // rax
  _QWORD *v9; // [rsp+0h] [rbp-60h]
  int v10; // [rsp+8h] [rbp-58h]
  int v11; // [rsp+Ch] [rbp-54h]
  int v12; // [rsp+24h] [rbp-3Ch]
  int v13; // [rsp+28h] [rbp-38h]
  int v14; // [rsp+2Ch] [rbp-34h]
  int v15; // [rsp+30h] [rbp-30h]
  int v16; // [rsp+34h] [rbp-2Ch]
  __int64 v17; // [rsp+38h] [rbp-28h]
  __int64 v18; // [rsp+40h] [rbp-20h]
  const char *v19; // [rsp+48h] [rbp-18h]
  void *v20; // [rsp+50h] [rbp-10h]
  unsigned __int64 v21; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v21 = __readfsqword(0x28u);
  v20 = **(void ***)(*(_QWORD *)a1 + 48LL);
  v14 = 0;
  v19 = 0LL;
  if ( *a2 != 11 )
    __assert_fail(
      "type->base == LY_TYPE_UNION",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x1F6Cu,
      "resolve_union");
  if ( *(_DWORD *)(a1 + 72) == 11 || *(_DWORD *)(a1 + 72) == 8 && *(_BYTE *)(a1 + 76) & 1 )
    v19 = (const char *)lydict_insert(v20, *(_QWORD *)(a1 + 64), 0LL);
  if ( v11 )
  {
    sub_BBE52(
      *(void **)(a1 + 64),
      *(_DWORD *)(a1 + 72),
      *(_BYTE *)(a1 + 76),
      *(_QWORD *)a1 + 128LL,
      *(_QWORD *)(a1 + 56),
      0LL,
      0LL,
      0LL);
    memset((void *)(a1 + 64), 0, 8uLL);
  }
  sub_141E4(0LL, 2u, &v12, 0LL);
  v18 = 0LL;
  v13 = 0;
  while ( 1 )
  {
    v18 = sub_3A9DE((signed __int64)a2, v18, &v13);
    if ( !v18 )
      break;
    v13 = 0;
    if ( *(_DWORD *)v18 == 8 )
    {
      if ( v19 )
        v6 = v19;
      else
        v6 = *(const char **)(a1 + 56);
      v16 = sub_2B8E0(*(_QWORD *)a1, v6);
      if ( v10 == 1 || v16 && v10 == 2 )
        v15 = -1;
      else
        v15 = *(char *)(v18 + 32);
      if ( v19 )
        v7 = (__int64)v19;
      else
        v7 = *(_QWORD *)(a1 + 56);
      if ( !(unsigned int)sub_2BAA8((char *)a1, v7, v15, &v17) )
      {
        if ( v11 )
        {
          if ( !v17 || v16 )
          {
            if ( v19 )
            {
              *(_QWORD *)(a1 + 64) = v19;
              v19 = 0LL;
            }
            else
            {
              *(_QWORD *)(a1 + 64) = 0LL;
            }
            *(_DWORD *)(a1 + 72) = 8;
            *(_BYTE *)(a1 + 76) |= 1u;
          }
          else
          {
            *(_QWORD *)(a1 + 64) = v17;
            *(_DWORD *)(a1 + 72) = 8;
            if ( v19 )
            {
              lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), *(_QWORD *)(a1 + 56));
              *(_QWORD *)(a1 + 56) = v19;
              v19 = 0LL;
            }
          }
        }
        v14 = 1;
      }
    }
    else if ( *(_DWORD *)v18 == 9 )
    {
      if ( v10 == 1 || *(_WORD *)(*(_QWORD *)a1 + 24LL) & 0x800 && v10 == 2 )
        v15 = -1;
      else
        v15 = *(char *)(v18 + 48);
      if ( !(unsigned int)sub_2C0A6(a1, *(const char **)(v18 + 32), v15, &v17) )
      {
        if ( v11 )
        {
          if ( !v17 || *(_WORD *)(*(_QWORD *)a1 + 24LL) & 0x800 )
          {
            sub_142D2(0LL, v12, 0LL, 0);
            if ( !sub_37EF5(v18, (char **)(a1 + 56), 0LL, (__int64 **)a1, 0LL, 0LL, 1, 0, 0) )
              return 0xFFFFFFFFLL;
            sub_141E4(0LL, 2u, &v12, 0LL);
          }
          else
          {
            *(_QWORD *)(a1 + 64) = v17;
            *(_DWORD *)(a1 + 72) = 9;
          }
        }
        v14 = 1;
      }
    }
    else if ( sub_37EF5(v18, (char **)(a1 + 56), 0LL, (__int64 **)a1, 0LL, 0LL, v11, 0, 0) )
    {
      v14 = 1;
    }
    if ( v14 )
      break;
    if ( v11 )
    {
      sub_BBE52(
        *(void **)(a1 + 64),
        *(_DWORD *)(a1 + 72),
        *(_BYTE *)(a1 + 76),
        v18,
        *(_QWORD *)(a1 + 56),
        0LL,
        0LL,
        0LL);
      memset((void *)(a1 + 64), 0, 8uLL);
    }
  }
  sub_142D2(0LL, v12, 0LL, 0);
  if ( v19 )
  {
    if ( v14 )
    {
      lydict_remove(**(_QWORD **)(*(_QWORD *)a1 + 48LL), v19);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 72) != 11 )
        __assert_fail(
          "leaf->value_type == LY_TYPE_UNION",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x1FD9u,
          "resolve_union");
      *(_QWORD *)(a1 + 64) = v19;
    }
  }
  if ( v14 )
  {
    if ( v9 )
      *v9 = v18;
    return 0LL;
  }
  if ( v10 && a2[11] )
    return 0LL;
  if ( *(_QWORD *)(a1 + 56) )
    v8 = *(void **)(a1 + 56);
  else
    v8 = &unk_10AA7C;
  sub_13937(v20, 50, 3u, (char *)a1, (__int64)v8, **(_QWORD **)a1, v9);
  return 1LL;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (000000000002C85B) ----------------------------------------------------
signed __int64  sub_2C85B(char *a1, unsigned int a2, unsigned int a3, __int64 *a4)
{
  unsigned int v5; // [rsp+10h] [rbp-40h]
  unsigned int v6; // [rsp+24h] [rbp-2Ch]
  unsigned int v7; // [rsp+24h] [rbp-2Ch]
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  unsigned int v9; // [rsp+24h] [rbp-2Ch]
  unsigned int v10; // [rsp+24h] [rbp-2Ch]
  int v11; // [rsp+28h] [rbp-28h]
  int v12; // [rsp+28h] [rbp-28h]
  int v13; // [rsp+2Ch] [rbp-24h]
  __int64 v14; // [rsp+30h] [rbp-20h]
  char *v15; // [rsp+38h] [rbp-18h]
  __int64 v16; // [rsp+40h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v17 = __readfsqword(0x28u);
  v15 = a1;
  v16 = *(_QWORD *)a1;
  if ( a2 == 0x400000 )
  {
    v9 = sub_275C3(a1, 0, a3);
    if ( v9 )
      return v9;
    return 0LL;
  }
  if ( a2 <= 0x400000 )
  {
    if ( a2 == (_DWORD)&loc_100000 )
    {
      if ( *(_DWORD *)(v16 + 128) != 8 )
        __assert_fail(
          "sleaf->type.base == LY_TYPE_INST",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x202Bu,
          "resolve_unres_data_item");
      v13 = sub_2B8E0(*(_QWORD *)v15, *((const char **)v15 + 7));
      if ( v13 == -1 )
        return 0xFFFFFFFFLL;
      if ( v5 )
        v12 = -1;
      else
        v12 = *(char *)(v16 + 160);
      if ( v13 && v5 == 2 )
      {
        v7 = 0;
        v14 = 0LL;
      }
      else
      {
        v7 = sub_2BAA8(a1, *((_QWORD *)v15 + 7), v12, &v14);
      }
      if ( v7 )
        return v7;
      if ( !v14 || v13 )
      {
        *((_QWORD *)v15 + 8) = 0LL;
        *((_DWORD *)v15 + 18) = 8;
        v15[76] |= 1u;
      }
      else
      {
        *((_QWORD *)v15 + 8) = v14;
        *((_DWORD *)v15 + 18) = 8;
        v15[76] &= 0xFEu;
      }
    }
    else if ( a2 == 0x200000 )
    {
      v8 = sub_28399((__int64)a1, a3, a4);
      if ( v8 )
        return v8;
    }
    else
    {
      if ( a2 != 0x80000 )
      {
LABEL_61:
        sub_12222(
          0LL,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/resolve.c",
          8299LL);
        return 0xFFFFFFFFLL;
      }
      if ( *(_DWORD *)(v16 + 128) != 9 )
        __assert_fail(
          "sleaf->type.base == LY_TYPE_LEAFREF",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x2005u,
          "resolve_unres_data_item");
      if ( !(v15[8] & 8) )
        __assert_fail(
          "leaf->validity & LYD_VAL_LEAFREF",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x2006u,
          "resolve_unres_data_item");
      if ( a3 )
        v11 = -1;
      else
        v11 = *(char *)(v16 + 176);
      if ( *(_WORD *)(*(_QWORD *)v15 + 24LL) & 0x800 && a3 == 2 )
      {
        v6 = 0;
        v14 = 0LL;
      }
      else
      {
        v6 = sub_2C0A6((__int64)v15, *(const char **)(v16 + 160), v11, &v14);
      }
      if ( v6 )
        return v6;
      if ( !v14 || *(_WORD *)(*(_QWORD *)v15 + 24LL) & 0x800 )
      {
        if ( !(v15[76] & 1) && !sub_37EF5(v16 + 128, (char **)v15 + 7, 0LL, (__int64 **)v15, 0LL, 0LL, 1, 0, 0) )
          return 0xFFFFFFFFLL;
      }
      else
      {
        if ( *((_DWORD *)v15 + 18) == 2 )
          free(*((void **)v15 + 8));
        *((_QWORD *)v15 + 8) = v14;
        *((_DWORD *)v15 + 18) = 9;
        v15[76] &= 0xFEu;
      }
      v15[8] &= 0xF7u;
    }
    return 0LL;
  }
  if ( a2 != 0x1000000 )
  {
    if ( a2 == 0x2000000 )
    {
      if ( (unsigned int)sub_2E5BD(a1) )
        return 0xFFFFFFFFLL;
    }
    else
    {
      if ( a2 != 0x800000 )
        goto LABEL_61;
      v10 = sub_275C3(a1, 1u, a3);
      if ( v10 )
        return v10;
    }
    return 0LL;
  }
  if ( *(_DWORD *)(v16 + 128) != 11 )
    __assert_fail(
      "sleaf->type.base == LY_TYPE_UNION",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x204Fu,
      "resolve_unres_data_item");
  return sub_2C282((__int64)v15, (_DWORD *)(v16 + 128), 1, a3, 0LL);
}

//----- (000000000002CD1C) ----------------------------------------------------
signed __int64  sub_2CD1C(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r9
  signed __int64 result; // rax
  __int64 v5; // r9
  int v6; // [rsp+Ch] [rbp-14h]

  v6 = a3;
  if ( !a1 || !a2 )
    __assert_fail("unres && node", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x207Du, "unres_data_add");
  if ( a3 != 0x80000
    && a3 != (_DWORD)&loc_100000
    && a3 != 0x200000
    && a3 != 0x400000
    && a3 != 0x800000
    && a3 != 0x1000000
    && a3 != 0x2000000 )
  {
    __assert_fail(
      "(type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST) || (type == UNRE"
      "S_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES)",
      "/home/mantovan/Repositories/libyang/src/resolve.c",
      0x207Fu,
      "unres_data_add");
  }
  *(_QWORD *)a1 = sub_C422(*(void **)a1, 8LL * (unsigned int)++*(_DWORD *)(a1 + 16));
  if ( *(_QWORD *)a1 )
  {
    *(_QWORD *)(8LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 1) + *(_QWORD *)a1) = a2;
    *(_QWORD *)(a1 + 8) = sub_C422(*(void **)(a1 + 8), 4LL * *(unsigned int *)(a1 + 16));
    if ( *(_QWORD *)(a1 + 8) )
    {
      *(_DWORD *)(4LL * (unsigned int)(*(_DWORD *)(a1 + 16) - 1) + *(_QWORD *)(a1 + 8)) = v6;
      result = 0LL;
    }
    else
    {
      sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_data_add", v5);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_12222(0LL, 0, 1, "Memory allocation failed (%s()).", (__int64)"unres_data_add", v3);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000002CEE7) ----------------------------------------------------
_QWORD * sub_2CEE7(__int64 a1, unsigned int a2)
{
  _QWORD *result; // rax
  unsigned int i; // [rsp+14h] [rbp-1Ch]
  _QWORD *v4; // [rsp+18h] [rbp-18h]
  _QWORD *k; // [rsp+20h] [rbp-10h]
  __int64 j; // [rsp+28h] [rbp-8h]

  for ( i = 0; i < *(_DWORD *)(a1 + 36); ++i )
  {
    if ( *(_DWORD *)(4LL * i + **(_QWORD **)(a1 + 24)) != 1 )
    {
      if ( *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) == *(_QWORD *)(8LL * a2 + *(_QWORD *)a1) )
        return (_QWORD *)sub_BDDC2(a1, i);
      for ( j = *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) + 40LL);
            j && j != *(_QWORD *)(8LL * a2 + *(_QWORD *)a1);
            j = *(_QWORD *)(j + 40) )
      {
        ;
      }
      if ( j )
      {
        sub_BDDC2(a1, i);
        break;
      }
      for ( k = *(_QWORD **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)); k; k = v4 )
      {
        result = *(_QWORD **)(8LL * a2 + *(_QWORD *)a1);
        if ( k == result )
          return result;
        if ( *(_DWORD *)(*k + 56LL) & 0x802C )
          v4 = 0LL;
        else
          v4 = (_QWORD *)k[8];
        if ( !v4 )
        {
          if ( k == *(_QWORD **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) )
            break;
          v4 = (_QWORD *)k[3];
        }
        while ( !v4 )
        {
          k = (_QWORD *)k[5];
          if ( k[5] == *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL)) + 40LL) )
            break;
          v4 = (_QWORD *)k[3];
        }
      }
    }
  }
  sub_BDCC8(a1, *(_QWORD *)(8LL * a2 + *(_QWORD *)a1), *(_QWORD *)(*(_QWORD *)(8LL * a2 + *(_QWORD *)a1) + 40LL), 0);
  lyd_unlink(*(_QWORD *)(8LL * a2 + *(_QWORD *)a1));
  result = (_QWORD *)(8LL * a2 + *(_QWORD *)a1);
  *result = 0LL;
  return result;
}
// 7840: using guessed type __int64  lyd_unlink(_QWORD);

//----- (000000000002D16B) ----------------------------------------------------
signed __int64  sub_2D16B(__int64 a1, __int64 a2, __int64 a3, __int16 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rax
  _DWORD *v13; // rax
  _DWORD *v14; // rax
  __int16 v15; // [rsp+4h] [rbp-7Ch]
  __int64 v16; // [rsp+8h] [rbp-78h]
  __int64 v17; // [rsp+10h] [rbp-70h]
  char v18; // [rsp+23h] [rbp-5Dh]
  int v19; // [rsp+24h] [rbp-5Ch]
  unsigned int i; // [rsp+28h] [rbp-58h]
  unsigned int k; // [rsp+2Ch] [rbp-54h]
  int v22; // [rsp+30h] [rbp-50h]
  unsigned int v23; // [rsp+34h] [rbp-4Ch]
  int v24; // [rsp+38h] [rbp-48h]
  unsigned int v25; // [rsp+3Ch] [rbp-44h]
  int v26; // [rsp+40h] [rbp-40h]
  unsigned int v27; // [rsp+44h] [rbp-3Ch]
  int v28; // [rsp+48h] [rbp-38h]
  int v29; // [rsp+4Ch] [rbp-34h]
  __int64 v30; // [rsp+50h] [rbp-30h]
  __int64 v31; // [rsp+58h] [rbp-28h]
  __int64 j; // [rsp+60h] [rbp-20h]
  unsigned __int64 v33; // [rsp+68h] [rbp-18h]

  v17 = a2;
  v16 = a3;
  v15 = a4;
  v33 = __readfsqword(0x28u);
  v28 = *(_DWORD *)ly_errno_glob_address(a1);
  if ( !v16 )
    __assert_fail("root", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x20DFu, "resolve_unres_data");
  if ( !a2 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x20E0u, "resolve_unres_data");
  if ( !*(_DWORD *)(a2 + 16) )
    return 0LL;
  if ( v15 & 0x8E )
  {
    v27 = 1;
  }
  else if ( v15 & 0x8000 )
  {
    v27 = 2;
  }
  else
  {
    v27 = 0;
  }
  sub_12222(0LL, 2u, 0, "Resolving unresolved data nodes and their constraints...", v4, v5);
  if ( !v27 )
    sub_141E4(a1, 1u, &v19, (__int64)&v30);
  v22 = 1;
  v25 = 0;
  v23 = 0;
  v24 = 0;
  while ( 2 )
  {
    if ( !v27 )
      sub_1404C(a1, v30);
    v26 = 0;
    for ( i = 0; i < *(_DWORD *)(v17 + 16); ++i )
    {
      if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x200000 )
      {
        if ( v22 )
          ++v25;
        for ( j = *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 40LL);
              j && (!((*(_BYTE *)(j + 9) >> 1) & 4) || (*(_BYTE *)(j + 9) >> 1) & 3);
              j = *(_QWORD *)(j + 40) )
        {
          if ( !*(_QWORD *)(j + 40) && (*(_BYTE *)(j + 9) >> 1) & 1 )
          {
            v9 = *(_QWORD *)(8LL * i + *(_QWORD *)v17);
            *(_BYTE *)(v9 + 9) = 2 * (((*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) >> 1) & 7 | 1) & 7) | *(_BYTE *)(v9 + 9) & 0xF1;
            *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
            ++v23;
            break;
          }
        }
        if ( !j )
        {
          v18 = (*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) >> 1) & 7;
          v10 = *(unsigned int *)(4LL * i + *(_QWORD *)(v17 + 8));
          v29 = sub_2C85B(*(char **)(8LL * i + *(_QWORD *)v17), v10, v27, &v31);
          if ( v29 )
          {
            if ( v29 == -1 )
              goto LABEL_111;
          }
          else
          {
            if ( !((*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) >> 1) & 1)
              || *(_WORD *)(v31 + 34) & 0x600 && v15 & 0x8000 )
            {
              *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
            }
            else
            {
              if ( (!(v18 & 2) || !(v15 & 0x4000)) && !(*(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)v17) + 9LL) & 1) )
                goto LABEL_111;
              v11 = *(_QWORD *)v31;
              v12 = ly_errpath(a1, v10);
              sub_12222(0LL, 2u, 0, "Auto-deleting node \"%s\" due to when condition (%s)", v12, v11);
              for ( j = *(_QWORD *)(8LL * i + *(_QWORD *)v17);
                    *(_QWORD *)(j + 40)
                 && *(_DWORD *)(**(_QWORD **)(j + 40) + 56LL) == 1
                 && !*(_QWORD *)(**(_QWORD **)(j + 40) + 136LL)
                 && !*(_QWORD *)(j + 24)
                 && j == *(_QWORD *)(j + 32);
                    j = *(_QWORD *)(j + 40) )
              {
                ;
              }
              *(_QWORD *)(*(_QWORD *)v17 + 8LL * i) = j;
              if ( *(_QWORD *)v16 && *(_QWORD *)v16 == *(_QWORD *)(8LL * i + *(_QWORD *)v17) )
                *(_QWORD *)v16 = *(_QWORD *)(*(_QWORD *)v16 + 24LL);
              *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x8000000;
              ++v24;
              for ( k = 0; k < *(_DWORD *)(v17 + 16); ++k )
              {
                if ( *(_DWORD *)(4LL * k + *(_QWORD *)(v17 + 8)) != 0x4000000
                  && *(_DWORD *)(4LL * k + *(_QWORD *)(v17 + 8)) != 0x8000000 )
                {
                  for ( j = *(_QWORD *)(8LL * k + *(_QWORD *)v17); j; j = *(_QWORD *)(j + 40) )
                  {
                    if ( j == *(_QWORD *)(8LL * i + *(_QWORD *)v17) )
                    {
                      *(_DWORD *)(4LL * k + *(_QWORD *)(v17 + 8)) = 0x4000000;
                      ++v23;
                      break;
                    }
                  }
                }
              }
            }
            if ( !v27 )
              sub_1404C(a1, v30);
            ++v23;
            v26 = 1;
          }
        }
      }
    }
    v22 = 0;
    if ( v26 && v23 < v25 )
      continue;
    break;
  }
  if ( v25 > v23 )
    goto LABEL_111;
  for ( i = 0; v24 && i < *(_DWORD *)(v17 + 16); ++i )
  {
    if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x8000000 )
    {
      if ( *(_QWORD *)(8LL * i + *(_QWORD *)v17) )
      {
        if ( *(_DWORD *)(v17 + 20) )
          sub_2CEE7(v17, i);
        lyd_free(*(_QWORD *)(8LL * i + *(_QWORD *)v17));
        *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
        --v24;
      }
      else
      {
        *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
        --v24;
      }
    }
  }
  if ( v15 & 0x2000 )
  {
    if ( v27 )
      __assert_fail("!ignore_fail", "/home/mantovan/Repositories/libyang/src/resolve.c", 0x2182u, "resolve_unres_data");
    v27 = 1;
    sub_142D2(a1, v19, v30, 0);
    v13 = (_DWORD *)ly_errno_glob_address(a1);
    *v13 = v28;
  }
  v22 = 1;
  v25 = 0;
  v23 = 0;
  do
  {
    v26 = 0;
    for ( i = 0; i < *(_DWORD *)(v17 + 16); ++i )
    {
      if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x80000 )
      {
        if ( v22 )
          ++v25;
        v29 = sub_2C85B(*(char **)(8LL * i + *(_QWORD *)v17), *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)), v27, 0LL);
        if ( v29 )
        {
          if ( v29 == -1 )
            goto LABEL_111;
        }
        else
        {
          *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
          if ( !v27 )
            sub_1404C(a1, v30);
          ++v23;
          v26 = 1;
        }
      }
    }
    v22 = 0;
  }
  while ( v26 && v23 < v25 );
  if ( v25 > v23 )
  {
LABEL_111:
    if ( !v27 )
      sub_142D2(a1, v19, v30, 1);
    return 0xFFFFFFFFLL;
  }
  if ( !v27 )
  {
    sub_142D2(a1, v19, v30, 0);
    v14 = (_DWORD *)ly_errno_glob_address(a1);
    *v14 = v28;
  }
  for ( i = 0; i < *(_DWORD *)(v17 + 16); ++i )
  {
    if ( *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) != 0x4000000 )
    {
      if ( v15 & 0x2000
        && (*(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x400000
         || *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) == 0x800000) )
      {
        __assert_fail(
          "!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT))",
          "/home/mantovan/Repositories/libyang/src/resolve.c",
          0x21B7u,
          "resolve_unres_data");
      }
      v29 = sub_2C85B(*(char **)(8LL * i + *(_QWORD *)v17), *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)), v27, 0LL);
      if ( v29 )
        return 0xFFFFFFFFLL;
      *(_DWORD *)(4LL * i + *(_QWORD *)(v17 + 8)) = 0x4000000;
    }
  }
  sub_12222(0LL, 2u, 0, "All data nodes and constraints resolved.", v7, v8);
  *(_DWORD *)(v17 + 16) = 0;
  return 0LL;
}
// 7270: using guessed type __int64  ly_errno_glob_address(_QWORD);
// 7A70: using guessed type __int64  ly_errpath(_QWORD, _QWORD);
// 7BE0: using guessed type __int64  lyd_free(_QWORD);

//----- (000000000002DB2D) ----------------------------------------------------
signed __int64  sub_2DB2D(char *a1)
{
  __int64 v1; // r9
  signed int v3; // [rsp+1Ch] [rbp-14h]
  __int64 i; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = *(_QWORD *)a1;
  v3 = 0;
  for ( i = *((_QWORD *)a1 + 8); ; i = *(_QWORD *)(i + 24) )
  {
    if ( v3 >= *(unsigned __int8 *)(v5 + 30) )
      return 0LL;
    if ( !i || *(_QWORD *)i != *(_QWORD *)(8LL * v3 + *(_QWORD *)(v5 + 136)) )
      break;
    ++v3;
  }
  sub_13937(**(void ***)(v5 + 48), 49, 3u, a1, **(_QWORD **)(8LL * v3 + *(_QWORD *)(v5 + 136)), *(_QWORD *)v5);
  while ( i )
  {
    if ( *(_QWORD *)i == *(_QWORD *)(8LL * v3 + *(_QWORD *)(v5 + 136)) )
    {
      sub_13937(**(void ***)(v5 + 48), -1, 3u, (char *)i, (__int64)"Invalid position of the key element.", v1);
      return 1LL;
    }
    i = *(_QWORD *)(i + 24);
  }
  return 1LL;
}

//----- (000000000002DC82) ----------------------------------------------------
signed __int64  sub_2DC82(char *a1, __int16 a2, __int64 a3)
{
  __int64 v3; // r9
  signed __int64 result; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // [rsp+8h] [rbp-48h]
  __int64 *k; // [rsp+28h] [rbp-28h]
  __int64 j; // [rsp+30h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-18h]
  void *v11; // [rsp+48h] [rbp-8h]

  v7 = a3;
  v11 = **(void ***)(*(_QWORD *)a1 + 48LL);
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/validation.c", 0x3Bu, "lyv_data_context");
  if ( !a3 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/validation.c", 0x3Cu, "lyv_data_context");
  if ( lys_is_disabled(*(_QWORD *)a1, 2LL) )
  {
    sub_13937(v11, 47, 3u, a1, **(_QWORD **)a1, v3);
    return 1LL;
  }
  for ( i = *(_QWORD *)a1; i && !(*(_DWORD *)(i + 56) & 0x4180); i = lys_parent(i) )
    ;
  if ( a2 & 0x8E || a2 & 0x50 && !i )
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC )
      a1[8] &= 0xF7u;
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0xC )
    {
      if ( *(_DWORD *)(*(_QWORD *)a1 + 128LL) == 11 && *(_DWORD *)(*(_QWORD *)a1 + 172LL) )
      {
        if ( (unsigned int)sub_2CD1C(v7, (__int64)a1, 0x1000000) )
          return 1LL;
      }
      else if ( *(_DWORD *)(*(_QWORD *)a1 + 128LL) == 9 && (a1[8] & 8 || a1[76] & 1) )
      {
        a1[76] &= 0xFEu;
        a1[8] |= 8u;
        if ( (unsigned int)sub_2CD1C(v7, (__int64)a1, 0x80000) )
          return 1LL;
      }
      else if ( *(_DWORD *)(*(_QWORD *)a1 + 128LL) == 8
             && (unsigned int)sub_2CD1C(v7, (__int64)a1, (unsigned __int64)&loc_100000) )
      {
        return 1LL;
      }
    }
    if ( ((unsigned __int8)a1[9] >> 1) & 4 && (unsigned int)sub_2CD1C(v7, (__int64)a1, 0x200000) )
      return 1LL;
  }
  if ( a2 & 0xD && *(_WORD *)(*(_QWORD *)a1 + 24LL) & 2 )
  {
    sub_13937(v11, 47, 3u, a1, **(_QWORD **)a1, v3);
    result = 1LL;
  }
  else
  {
    if ( !(a2 & 0x2080)
      && a2 & 0x30
      && a1[8] & 4
      && i
      && a1 != *((char **)a1 + 4)
      && *(_QWORD *)(*((_QWORD *)a1 + 4) + 24LL) )
    {
      for ( j = lys_parent(*(_QWORD *)a1); j && *(_DWORD *)(j + 56) & 0x1042; j = lys_parent(j) )
        ;
      v5 = lyd_node_module(a1);
      for ( k = (__int64 *)lys_getnext(*(_QWORD *)a1, j, v5, 0LL); k; k = (__int64 *)lys_getnext(k, j, v6, 0LL) )
      {
        if ( k == **((__int64 ***)a1 + 4) )
        {
          sub_13937(v11, 60, 3u, a1, **(_QWORD **)a1, *k);
          return 1LL;
        }
        v6 = lyd_node_module(a1);
      }
    }
    result = 0LL;
  }
  return result;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 71F0: using guessed type __int64  lys_is_disabled(_QWORD, _QWORD);
// 73D0: using guessed type __int64  lyd_node_module(_QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (000000000002E0DF) ----------------------------------------------------
signed __int64  sub_2E0DF(__int64 ***a1, __int64 *a2, __int64 a3, int a4)
{
  unsigned __int16 v5; // ax
  char *v6; // r12
  const char *v7; // rbx
  __int64 *v8; // rax
  int v9; // [rsp+0h] [rbp-A0h]
  unsigned __int16 v10; // [rsp+26h] [rbp-7Ah]
  int i; // [rsp+28h] [rbp-78h]
  signed int j; // [rsp+2Ch] [rbp-74h]
  signed int k; // [rsp+2Ch] [rbp-74h]
  int v14; // [rsp+34h] [rbp-6Ch]
  __int64 v15; // [rsp+38h] [rbp-68h]
  __int64 v16; // [rsp+40h] [rbp-60h]
  void *ptr; // [rsp+48h] [rbp-58h]
  void *v18; // [rsp+50h] [rbp-50h]
  __int64 **v19; // [rsp+58h] [rbp-48h]
  __int64 v20; // [rsp+60h] [rbp-40h]
  void *v21; // [rsp+68h] [rbp-38h]
  __int64 *v22; // [rsp+70h] [rbp-30h]
  __int64 *v23; // [rsp+78h] [rbp-28h]
  void *v24; // [rsp+80h] [rbp-20h]
  unsigned __int64 v25; // [rsp+88h] [rbp-18h]

  v9 = a4;
  v25 = __readfsqword(0x28u);
  if ( !a1 || !a2 )
    __assert_fail(
      "val1_p && val2_p",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x9Bu,
      "lyv_list_uniq_equal");
  v19 = *a1;
  v20 = *a2;
  if ( !v19 || *((_DWORD *)*v19 + 14) != 16 )
    __assert_fail(
      "first && (first->schema->nodetype == LYS_LIST)",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0xA1u,
      "lyv_list_uniq_equal");
  if ( !v20 || *(__int64 **)v20 != *v19 )
    __assert_fail(
      "second && (second->schema == first->schema)",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0xA2u,
      "lyv_list_uniq_equal");
  v21 = *(void **)(*v19)[6];
  v22 = *v19;
  if ( a4 > 0 )
  {
    i = a4 - 1;
    if ( a4 - 1 < *((unsigned __int8 *)v22 + 31) )
      goto LABEL_13;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= *((unsigned __int8 *)v22 + 31) )
      return 0LL;
LABEL_13:
    for ( j = 0; j < *(unsigned __int8 *)(16LL * i + v22[18] + 8); ++j )
    {
      v23 = sub_19BA2(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), v19[8]);
      if ( v23 )
      {
        v15 = v23[7];
      }
      else if ( (unsigned int)sub_BC387(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), (__int64)v19, &v15) )
      {
        return 1LL;
      }
      v23 = sub_19BA2(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), *(__int64 **)(v20 + 64));
      if ( v23 )
      {
        v16 = v23[7];
      }
      else if ( (unsigned int)sub_BC387(*(const char **)(8LL * j + *(_QWORD *)(16LL * i + v22[18])), v20, &v16) )
      {
        return 1LL;
      }
      if ( !v15 || !v16 || v15 != v16 )
        break;
    }
    if ( j && j == *(unsigned __int8 *)(16LL * i + v22[18] + 8) )
      break;
    if ( v9 > 0 )
      return 0LL;
  }
  sub_12B3E(3u, (char *)v19, &ptr, 0, 0);
  sub_12B3E(3u, (char *)v20, &v18, 0, 0);
  v24 = malloc(0x400uLL);
  v10 = 0;
  for ( k = 0; k < *(unsigned __int8 *)(16LL * i + v22[18] + 8); ++k )
  {
    if ( k )
    {
      v5 = v10++;
      *((_BYTE *)v24 + v5) = 32;
    }
    v6 = (char *)v24 + v10;
    v7 = *(const char **)(8LL * k + *(_QWORD *)(16LL * i + v22[18]));
    v8 = (__int64 *)lys_node_module(v22);
    v14 = sub_BC8A8(v8, (__int64 *)v19, v7, (__int64)v6);
    if ( v14 == -1 )
      goto LABEL_36;
    v10 += v14;
  }
  sub_13937(v21, 18, 3u, (char *)v20, (__int64)v24, (__int64)ptr, v18);
LABEL_36:
  free(ptr);
  free(v18);
  free(v24);
  return 1LL;
}
// 7BB0: using guessed type __int64  lys_node_module(_QWORD);

//----- (000000000002E5BD) ----------------------------------------------------
signed __int64  sub_2E5BD(char *a1)
{
  __int64 v2; // r9
  _QWORD *v3; // rbx
  __int64 v4; // r9
  unsigned __int64 v5; // rax
  unsigned int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int i; // [rsp+14h] [rbp-6Ch]
  unsigned int n; // [rsp+14h] [rbp-6Ch]
  unsigned int k; // [rsp+18h] [rbp-68h]
  unsigned int m; // [rsp+18h] [rbp-68h]
  unsigned int ii; // [rsp+18h] [rbp-68h]
  unsigned int v14; // [rsp+1Ch] [rbp-64h]
  unsigned int v15; // [rsp+20h] [rbp-60h]
  unsigned int v16; // [rsp+24h] [rbp-5Ch]
  signed int j; // [rsp+28h] [rbp-58h]
  unsigned int l; // [rsp+28h] [rbp-58h]
  char *s; // [rsp+30h] [rbp-50h]
  void *ptr; // [rsp+38h] [rbp-48h]
  void *v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h]
  __int64 v23; // [rsp+50h] [rbp-30h]
  __int64 v24; // [rsp+58h] [rbp-28h]
  __int64 *v25; // [rsp+60h] [rbp-20h]
  unsigned __int64 v26; // [rsp+68h] [rbp-18h]

  v26 = __readfsqword(0x28u);
  v14 = 0;
  v15 = 0;
  v21 = 0LL;
  v22 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  if ( !(a1[8] & 2) )
    return 0LL;
  v23 = *(_QWORD *)a1;
  if ( (unsigned int)sub_12B3E(3u, a1, &ptr, 0, 1) )
    return 0xFFFFFFFFLL;
  v24 = lyd_find_path(a1, ptr);
  free(ptr);
  if ( !v24 )
    return 0xFFFFFFFFLL;
  for ( i = 0; i < *(_DWORD *)(v24 + 4); ++i )
    *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(v24 + 8)) + 8LL) &= 0xFDu;
  if ( *(_DWORD *)(v24 + 4) == 2 )
  {
    if ( (unsigned int)sub_2E0DF(*(__int64 ****)(v24 + 8), (__int64 *)(*(_QWORD *)(v24 + 8) + 8LL), 0LL, 0) )
    {
      ly_set_free(v24);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)(v24 + 4) > 2u )
  {
    for ( j = 31; j && *(_DWORD *)(v24 + 4) << j >> j != *(_DWORD *)(v24 + 4); --j )
      ;
    if ( j )
    {
      v14 = *(unsigned __int8 *)(v23 + 31);
      v21 = malloc(8LL * *(unsigned __int8 *)(v23 + 31));
      if ( v21 )
      {
        for ( k = 0; k < v14; ++k )
        {
          v3 = (char *)v21 + 8 * k;
          *v3 = sub_14CB1(1 << (32 - j), 8, (__int64)sub_2E0DF, k + 1LL, 0);
          if ( !*((_QWORD *)v21 + k) )
          {
            sub_12222(v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyv_data_unique", v4);
            v15 = -1;
            goto LABEL_44;
          }
        }
        for ( l = 0; l < *(_DWORD *)(v24 + 4); ++l )
        {
          for ( m = 0; m < v14; ++m )
          {
            s = 0LL;
            v16 = 0;
            for ( n = 0; n < *(unsigned __int8 *)(16LL * m + *(_QWORD *)(v23 + 144) + 8); ++n )
            {
              v25 = sub_19BA2(
                      *(const char **)(8LL * n + *(_QWORD *)(16LL * m + *(_QWORD *)(v23 + 144))),
                      *(__int64 **)(*(_QWORD *)(8LL * l + *(_QWORD *)(v24 + 8)) + 64LL));
              if ( v25 )
              {
                s = (char *)v25[7];
              }
              else if ( (unsigned int)sub_BC387(
                                        *(const char **)(8LL * n + *(_QWORD *)(16LL * m + *(_QWORD *)(v23 + 144))),
                                        *(_QWORD *)(8LL * l + *(_QWORD *)(v24 + 8)),
                                        &s) )
              {
                v15 = -1;
                goto LABEL_44;
              }
              if ( !s )
                break;
              v5 = strlen(s);
              v16 = sub_1476E(v16, (__int64)s, v5);
            }
            if ( s )
            {
              v6 = sub_1476E(v16, 0LL, 0LL);
              if ( (unsigned int)sub_15F55(
                                   *((_QWORD *)v21 + m),
                                   (const void *)(*(_QWORD *)(v24 + 8) + 8LL * l),
                                   v6,
                                   0LL,
                                   v7,
                                   v8) )
              {
                v15 = 1;
                goto LABEL_44;
              }
            }
          }
        }
      }
      else
      {
        sub_12222(v22, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyv_data_unique", v2);
        v15 = -1;
        v14 = 0;
      }
    }
    else
    {
      sub_12222(
        v22,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/validation.c",
        296LL);
      v15 = -1;
    }
  }
LABEL_44:
  ly_set_free(v24);
  for ( ii = 0; ii < v14 && *((_QWORD *)v21 + ii); ++ii )
    sub_14F6B(*((void ***)v21 + ii));
  free(v21);
  return v15;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 75A0: using guessed type __int64  lyd_find_path(_QWORD, _QWORD);

//----- (000000000002EB38) ----------------------------------------------------
signed __int64  sub_2EB38(_QWORD **a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  signed __int64 result; // rax
  signed int i; // [rsp+2Ch] [rbp-44h]
  _QWORD *j; // [rsp+30h] [rbp-40h]
  _QWORD *k; // [rsp+30h] [rbp-40h]
  __int64 v11; // [rsp+38h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-30h]
  __int64 v13; // [rsp+48h] [rbp-28h]
  _QWORD *v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  void *v16; // [rsp+60h] [rbp-10h]
  __int64 v17; // [rsp+68h] [rbp-8h]

  if ( !a1 || !a2 )
    __assert_fail("val1_p && val2_p", "/home/mantovan/Repositories/libyang/src/validation.c", 0x17Fu, "lyv_list_equal");
  v14 = *a1;
  v15 = *a2;
  if ( !*a1 || !(*(_DWORD *)(*v14 + 56LL) & 0x18) )
    __assert_fail(
      "first && (first->schema->nodetype & (LYS_LIST | LYS_LEAFLIST))",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x184u,
      "lyv_list_equal");
  if ( !v15 || *(_QWORD *)v15 != *v14 )
    __assert_fail(
      "second && (second->schema == first->schema)",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x185u,
      "lyv_list_equal");
  v16 = **(void ***)(*v14 + 48LL);
  v6 = *(_DWORD *)(*v14 + 56LL);
  if ( v6 == 8 )
  {
    if ( *(_WORD *)(*v14 + 24LL) & 2 && ((*(_BYTE *)(*(_QWORD *)(*v14 + 48LL) + 64LL) >> 1) & 7u) > 1 )
    {
      result = 0LL;
    }
    else if ( v14[7] == *(_QWORD *)(v15 + 56) )
    {
      sub_13937(v16, 16, 3u, (char *)v15, **(_QWORD **)v15, *(_QWORD *)(v15 + 56), a4);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else if ( v6 == 16 )
  {
    v17 = *v14;
    if ( *(_BYTE *)(*v14 + 30LL) )
    {
      for ( i = 0; i < *(unsigned __int8 *)(v17 + 30); ++i )
      {
        v13 = *(_QWORD *)(8LL * i + *(_QWORD *)(v17 + 136));
        v12 = 0LL;
        v11 = 0LL;
        for ( j = (_QWORD *)v14[8]; j; j = (_QWORD *)j[3] )
        {
          if ( v13 == *j )
          {
            v11 = j[7];
            break;
          }
        }
        for ( k = *(_QWORD **)(v15 + 64); k; k = (_QWORD *)k[3] )
        {
          if ( v13 == *k )
          {
            v12 = k[7];
            break;
          }
        }
        if ( v11 != v12 )
          return 0LL;
      }
      sub_13937(v16, 17, 3u, (char *)v15, **(_QWORD **)v15, a6, a4);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    sub_12222(
      (__int64)v16,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/validation.c",
      440LL,
      a4);
    result = 1LL;
  }
  return result;
}

//----- (000000000002EE3F) ----------------------------------------------------
signed __int64  sub_2EE3F(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // r9
  char *s; // ST58_8
  unsigned __int64 v7; // rax
  unsigned int v8; // ST24_4
  unsigned int v9; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  char *v12; // ST58_8
  unsigned __int64 v13; // rax
  __int64 v14; // [rsp+0h] [rbp-60h]
  signed int v15; // [rsp+1Ch] [rbp-44h]
  unsigned int v16; // [rsp+20h] [rbp-40h]
  unsigned int v17; // [rsp+24h] [rbp-3Ch]
  signed int j; // [rsp+28h] [rbp-38h]
  unsigned int k; // [rsp+28h] [rbp-38h]
  __int64 i; // [rsp+30h] [rbp-30h]
  __int64 v21; // [rsp+38h] [rbp-28h]
  void **v22; // [rsp+40h] [rbp-20h]
  __int64 v23; // [rsp+48h] [rbp-18h]
  __int64 v24; // [rsp+50h] [rbp-10h]

  v14 = a2;
  v16 = 0;
  v22 = 0LL;
  v23 = **(_QWORD **)(*(_QWORD *)a1 + 48LL);
  if ( !a2 )
    v14 = lyd_first_sibling(a1);
  v24 = ly_set_new(a1);
  for ( i = v14; i; i = *(_QWORD *)(i + 24) )
  {
    if ( *(_QWORD *)i == *(_QWORD *)a1 )
    {
      *(_BYTE *)(i + 8) &= 0xFEu;
      ly_set_add(v24, i, 1LL);
    }
  }
  if ( *(_DWORD *)(v24 + 4) == 2 )
  {
    if ( (unsigned int)sub_2EB38(*(_QWORD ***)(v24 + 8), (__int64 *)(*(_QWORD *)(v24 + 8) + 8LL), 0LL, 0LL, v2, v3) )
    {
      ly_set_free(v24);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)(v24 + 4) > 2u )
  {
    for ( j = 31; j && *(_DWORD *)(v24 + 4) << j >> j != *(_DWORD *)(v24 + 4); --j )
      ;
    if ( j )
    {
      v22 = (void **)sub_14CB1(1 << (32 - j), 8, (__int64)sub_2EB38, 0LL, 0);
      if ( v22 )
      {
        for ( k = 0; k < *(_DWORD *)(v24 + 4); ++k )
        {
          if ( *(_DWORD *)(*(_QWORD *)a1 + 56LL) == 8 )
          {
            s = *(char **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v24 + 8)) + 56LL);
            v7 = strlen(*(const char **)(*(_QWORD *)(8LL * k + *(_QWORD *)(v24 + 8)) + 56LL));
            v8 = sub_1476E(0, (__int64)s, v7);
            v9 = sub_1476E(v8, 0LL, 0LL);
          }
          else
          {
            v15 = 0;
            v17 = 0;
            v21 = *(_QWORD *)(*(_QWORD *)(8LL * k + *(_QWORD *)(v24 + 8)) + 64LL);
            while ( v15 < *(unsigned __int8 *)(**(_QWORD **)(8LL * k + *(_QWORD *)(v24 + 8)) + 30LL) )
            {
              v12 = *(char **)(v21 + 56);
              v13 = strlen(*(const char **)(v21 + 56));
              v17 = sub_1476E(v17, (__int64)v12, v13);
              ++v15;
              v21 = *(_QWORD *)(v21 + 24);
            }
            v9 = sub_1476E(v17, 0LL, 0LL);
          }
          if ( (unsigned int)sub_15F55((__int64)v22, (const void *)(*(_QWORD *)(v24 + 8) + 8LL * k), v9, 0LL, v10, v11) )
          {
            v16 = 1;
            break;
          }
        }
      }
      else
      {
        sub_12222(v23, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyv_data_dup", v5, v14);
        v16 = 1;
      }
    }
    else
    {
      sub_12222(
        v23,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/validation.c",
        494LL,
        v14);
      v16 = 1;
    }
  }
  ly_set_free(v24);
  sub_14F6B(v22);
  return v16;
}
// 7470: using guessed type __int64  ly_set_free(_QWORD);
// 77C0: using guessed type __int64  ly_set_new(_QWORD);
// 77E0: using guessed type __int64  lyd_first_sibling(_QWORD);
// 7900: using guessed type __int64  ly_set_add(_QWORD, _QWORD, _QWORD);

//----- (000000000002F1BE) ----------------------------------------------------
__int64  sub_2F1BE(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  int j; // [rsp+1Ch] [rbp-24h]
  __int64 i; // [rsp+20h] [rbp-20h]
  __int64 v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+30h] [rbp-10h]
  unsigned __int64 v7; // [rsp+38h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  for ( i = a1; *(_QWORD *)(*(_QWORD *)(i + 16) + 72LL); i = *(_QWORD *)(i + 16) + 56LL )
    ;
  if ( a2 == *(_DWORD *)i )
    return i;
  if ( *(_DWORD *)i != 9 || *(_BYTE *)(i + 4) & 1 )
  {
    if ( *(_DWORD *)i == 11 )
    {
      v5 = 0LL;
      for ( j = 0; ; j = 0 )
      {
        v5 = sub_3A9DE(i, v5, &j);
        if ( !v5 )
          break;
        v6 = sub_2F1BE(v5, a2);
        if ( v6 )
          return v6;
      }
    }
    result = 0LL;
  }
  else
  {
    if ( !*(_QWORD *)(i + 40) )
      __assert_fail(
        "type->info.lref.target",
        "/home/mantovan/Repositories/libyang/src/validation.c",
        0x229u,
        "find_orig_type");
    result = sub_2F1BE(*(_QWORD *)(i + 40) + 128LL, a2);
  }
  return result;
}

//----- (000000000002F304) ----------------------------------------------------
signed __int64  sub_2F304(__int64 a1, unsigned __int8 a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-28h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  for ( i = 0; i < a2; ++i )
  {
    if ( *(_WORD *)(*(_QWORD *)(8LL * i + a1) + 24LL) & 8
      && *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(8LL * i + a1) + 56LL) + 32LL)
      && (*(unsigned int ( **)(_QWORD, __int64))(*(_QWORD *)(**(_QWORD **)(8LL * i + a1) + 56LL) + 32LL))(
           *(_QWORD *)(8LL * i + a1),
           v4) )
    {
      return 1LL;
    }
  }
  return 0LL;
}

//----- (000000000002F3D1) ----------------------------------------------------
signed __int64  sub_2F3D1(__int64 a1, __int64 a2, unsigned int a3)
{
  signed __int64 result; // rax
  __int64 v4; // [rsp+10h] [rbp-20h]
  unsigned int j; // [rsp+24h] [rbp-Ch]
  unsigned int i; // [rsp+24h] [rbp-Ch]
  unsigned int k; // [rsp+24h] [rbp-Ch]

  v4 = a2;
  switch ( *(_DWORD *)a2 )
  {
    case 2:
      if ( !a3 )
        goto LABEL_35;
      v4 = sub_2F1BE(*(_QWORD *)a1 + 128LL, 2u);
      for ( i = 0; ; ++i )
      {
        if ( i >= *(_DWORD *)(v4 + 40) )
          goto LABEL_35;
        if ( *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64))
          && (unsigned int)sub_2F304(
                             *(_QWORD *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 32LL),
                             *(_BYTE *)(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 64)) + 26LL),
                             a1) )
        {
          break;
        }
      }
      result = 1LL;
      break;
    case 4:
      if ( !*(_QWORD *)(a2 + 32)
        || !(unsigned int)sub_2F304(
                            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL),
                            *(_BYTE *)(*(_QWORD *)(a2 + 32) + 48LL),
                            a1) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    case 6:
      if ( !a3
        || !(unsigned int)sub_2F304(
                            *(_QWORD *)(*(_QWORD *)(a1 + 64) + 32LL),
                            *(_BYTE *)(*(_QWORD *)(a1 + 64) + 26LL),
                            a1) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    case 0xA:
      if ( *(_QWORD *)(a2 + 32)
        && (unsigned int)sub_2F304(
                           *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL),
                           *(_BYTE *)(*(_QWORD *)(a2 + 32) + 48LL),
                           a1) )
      {
        result = 1LL;
      }
      else
      {
        for ( j = 0; ; ++j )
        {
          if ( j >= *(_DWORD *)(a2 + 48) )
            goto LABEL_35;
          if ( (unsigned int)sub_2F304(
                               *(_QWORD *)(*(_QWORD *)(a2 + 40) + 56LL * j + 40),
                               *(_BYTE *)(*(_QWORD *)(a2 + 40) + 56LL * j + 48),
                               a1) )
            break;
        }
        result = 1LL;
      }
      break;
    case 0xB:
      for ( k = 0;
            k < *(_DWORD *)(a2 + 40)
         && *(_DWORD *)(((unsigned __int64)k << 6) + *(_QWORD *)(a2 + 32)) != *(_DWORD *)(a1 + 72);
            ++k )
      {
        ;
      }
      if ( k >= *(_DWORD *)(a2 + 40)
        || !(unsigned int)sub_2F3D1(a1, *(_QWORD *)(a2 + 32) + ((unsigned __int64)k << 6), a3) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      if ( !*(_QWORD *)(a2 + 32)
        || !(unsigned int)sub_2F304(
                            *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40LL),
                            *(_BYTE *)(*(_QWORD *)(a2 + 32) + 48LL),
                            a1) )
      {
        goto LABEL_35;
      }
      result = 1LL;
      break;
    default:
LABEL_35:
      if ( (unsigned int)sub_2F304(*(_QWORD *)(v4 + 8), *(_BYTE *)(v4 + 5), a1) )
      {
        result = 1LL;
      }
      else
      {
        while ( *(_QWORD *)(*(_QWORD *)(v4 + 16) + 72LL) )
        {
          v4 = *(_QWORD *)(v4 + 16) + 56LL;
          if ( *(_WORD *)(*(_QWORD *)(v4 + 24) + 24LL) & 0x2000
            && ((unsigned int)sub_2F3D1(a1, v4, 0LL)
             || (unsigned int)sub_2F304(
                                *(_QWORD *)(*(_QWORD *)(v4 + 24) + 32LL),
                                *(_BYTE *)(*(_QWORD *)(v4 + 24) + 26LL),
                                a1)) )
          {
            return 1LL;
          }
        }
        result = 0LL;
      }
      break;
  }
  return result;
}

//----- (000000000002F7BD) ----------------------------------------------------
signed __int64  sub_2F7BD(char *a1, __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  const char *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 l; // rax
  int v11; // eax
  __int64 v12; // [rsp+8h] [rbp-98h]
  __int16 v13; // [rsp+14h] [rbp-8Ch]
  unsigned __int8 v14; // [rsp+2Fh] [rbp-71h]
  unsigned int ii; // [rsp+30h] [rbp-70h]
  char v16; // [rsp+30h] [rbp-70h]
  unsigned int n; // [rsp+34h] [rbp-6Ch]
  __int64 v18; // [rsp+38h] [rbp-68h]
  __int64 v19; // [rsp+38h] [rbp-68h]
  _QWORD *i; // [rsp+40h] [rbp-60h]
  char *j; // [rsp+40h] [rbp-60h]
  __int64 m; // [rsp+40h] [rbp-60h]
  __int64 k; // [rsp+48h] [rbp-58h]
  __int64 v24; // [rsp+50h] [rbp-50h]
  __int64 v25; // [rsp+58h] [rbp-48h]
  const char *v26; // [rsp+60h] [rbp-40h]
  __int64 v27; // [rsp+68h] [rbp-38h]
  __int64 v28; // [rsp+78h] [rbp-28h]
  void *v29; // [rsp+80h] [rbp-20h]
  __int64 v30; // [rsp+88h] [rbp-18h]

  v13 = a2;
  v12 = a3;
  v24 = 0LL;
  n = 0;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/validation.c", 0x2B2u, "lyv_data_content");
  if ( !*(_QWORD *)a1 )
    __assert_fail("node->schema", "/home/mantovan/Repositories/libyang/src/validation.c", 0x2B3u, "lyv_data_content");
  if ( !a3 )
    __assert_fail("unres", "/home/mantovan/Repositories/libyang/src/validation.c", 0x2B4u, "lyv_data_content");
  v28 = *(_QWORD *)a1;
  v29 = **(void ***)(*(_QWORD *)a1 + 48LL);
  if ( !(*(_DWORD *)(*(_QWORD *)a1 + 56LL) & 0x4180) )
  {
    for ( i = (_QWORD *)*((_QWORD *)a1 + 5); i && !(*(_DWORD *)(*i + 56LL) & 0x4180); i = (_QWORD *)i[5] )
      ;
    if ( !i && a2 & 0x50 )
      v13 = a2 | 0x2000;
  }
  if ( a1[8] & 4 )
  {
    if ( !(v13 & 0x2080) )
    {
      if ( *(_DWORD *)(v28 + 56) == 16 && !(v13 & 6) && (unsigned int)sub_2DB2D(a1) )
        return 1LL;
      if ( *(_DWORD *)(v28 + 56) & 0x8025 )
      {
        for ( j = (char *)lyd_first_sibling(a1); j; j = (char *)*((_QWORD *)j + 3) )
        {
          if ( v28 == *(_QWORD *)j && j != a1 )
          {
            v30 = lys_parent(v28);
            if ( v30 )
            {
              if ( *(_DWORD *)(v30 + 56) == 0x10000 )
                v7 = *(const char **)(v30 + 16);
              else
                v7 = *(const char **)v30;
            }
            else
            {
              v7 = "data tree";
            }
            sub_13937(v29, 14, 3u, a1, *(_QWORD *)v28, (__int64)v7);
            return 1LL;
          }
        }
      }
      if ( v13 & 0x800 )
      {
        v18 = *(_QWORD *)a1;
        do
        {
          if ( (*(_WORD *)(v18 + 24) & 0x38) == 32 && v13 & 0x800 )
          {
            sub_13937(v29, 44, 3u, a1, *(_QWORD *)v28, a6);
            return 1LL;
          }
          v18 = lys_parent(v18);
        }
        while ( v18 && !(*(_DWORD *)(v18 + 56) & 0x803D) );
        if ( *(_DWORD *)(v28 + 56) & 0xC )
        {
          if ( v13 & 0x800 )
          {
            for ( k = *(_QWORD *)(*(_QWORD *)a1 + 144LL); k; k = *(_QWORD *)(k + 72) )
            {
              if ( (*(_WORD *)(k + 24) & 0x38) == 32 )
              {
                sub_13937(v29, 45, 3u, a1, *(_QWORD *)v28, *(_QWORD *)k);
                return 1LL;
              }
            }
          }
          if ( *((_DWORD *)a1 + 18) == 7
            && (unsigned int)sub_3C749(
                               *(_WORD *)(v28 + 24),
                               *(void ***)(v28 + 48),
                               *(_QWORD *)v28,
                               *(_WORD *)(*((_QWORD *)a1 + 8) + 24LL),
                               *(_QWORD *)(*((_QWORD *)a1 + 8) + 48LL),
                               **((_QWORD **)a1 + 8),
                               0LL) )
          {
            sub_13937(v29, -2, 3u, a1, v8, v9);
            return 1LL;
          }
        }
      }
    }
    if ( *(_WORD *)(v28 + 24) & 0x2000 )
    {
      if ( (unsigned int)sub_2F304(*(_QWORD *)(v28 + 32), *(_BYTE *)(v28 + 26), (__int64)a1) )
        return 1LL;
      if ( *(_DWORD *)(v28 + 56) & 0xC )
      {
        v24 = v28 + 128;
        if ( (unsigned int)sub_2F3D1((__int64)a1, v28 + 128, 1u) )
          return 1LL;
      }
    }
    a1[8] &= 0xFBu;
  }
  if ( *(_DWORD *)(v28 + 56) & 0x4191 )
  {
    for ( l = lys_getnext(0LL, v28, 0LL, 0LL); ; l = lys_getnext(v19, v28, 0LL, 0LL) )
    {
      v19 = l;
      if ( !l )
        break;
      if ( *(_DWORD *)(l + 56) & 0x18 )
      {
        for ( m = *((_QWORD *)a1 + 8); m; m = *(_QWORD *)(m + 24) )
        {
          if ( l == *(_QWORD *)m && *(_BYTE *)(m + 8) & 1 )
          {
            if ( v13 & 0x2006 )
            {
              *(_BYTE *)(m + 8) &= 0xFEu;
              break;
            }
            if ( !(unsigned int)sub_2EE3F(m, *((_QWORD *)a1 + 8)) )
              break;
            return 1LL;
          }
        }
      }
    }
  }
  if ( a1[8] & 2 )
  {
    if ( v13 & 0x2000 )
    {
      a1[8] &= 0xFDu;
    }
    else if ( (unsigned int)sub_2CD1C(v12, (__int64)a1, 0x2000000) )
    {
      return 1LL;
    }
  }
  if ( *(_DWORD *)(v28 + 56) & 0xC )
  {
    v11 = *((_DWORD *)a1 + 18);
    switch ( v11 )
    {
      case 6:
        v26 = "Enum";
        v27 = *((_QWORD *)a1 + 7);
        v14 = *(_BYTE *)(*((_QWORD *)a1 + 8) + 27LL);
        v25 = *(_QWORD *)(*((_QWORD *)a1 + 8) + 40LL);
        break;
      case 7:
        v26 = "Identity";
        v27 = *((_QWORD *)a1 + 7);
        v14 = *(_BYTE *)(*((_QWORD *)a1 + 8) + 27LL);
        v25 = *(_QWORD *)(*((_QWORD *)a1 + 8) + 40LL);
        break;
      case 2:
        v26 = "Bit";
        v24 = sub_2F1BE(*(_QWORD *)a1 + 128LL, 2u);
        v14 = 0;
        for ( n = 0; n < *(_DWORD *)(v24 + 40); ++n )
        {
          if ( *(_QWORD *)(8LL * n + *((_QWORD *)a1 + 8)) )
          {
            v27 = **(_QWORD **)(8LL * n + *((_QWORD *)a1 + 8));
            v14 = *(_BYTE *)(*(_QWORD *)(8LL * n + *((_QWORD *)a1 + 8)) + 27LL);
            v25 = *(_QWORD *)(*(_QWORD *)(8LL * n + *((_QWORD *)a1 + 8)) + 40LL);
            goto LABEL_90;
          }
LABEL_84:
          ;
        }
        break;
      default:
        v14 = 0;
        break;
    }
LABEL_90:
    if ( v14 )
    {
      for ( ii = 0; ii < v14; ++ii )
      {
        if ( !(unsigned int)sub_18D14(32LL * ii + v25) )
        {
          sub_13937(v29, 50, 3u, a1, *((_QWORD *)a1 + 7), *(_QWORD *)v28);
          sub_13937(v29, -1, 5u, 0LL, (__int64)"%s \"%s\" is disabled by its if-feature condition.", (__int64)v26, v27);
          return 1LL;
        }
      }
      if ( *((_DWORD *)a1 + 18) == 2 )
      {
        v14 = 0;
        goto LABEL_84;
      }
    }
  }
  if ( v13 & 0x208E )
    goto LABEL_107;
  v16 = sub_28087(a1);
  if ( v16 & 1 && (unsigned int)sub_2CD1C(v12, (__int64)a1, 0x400000) )
    return 1LL;
  if ( v16 & 2 && (unsigned int)sub_2CD1C(v12, (__int64)a1, 0x800000) )
    result = 1LL;
  else
LABEL_107:
    result = 0LL;
  return result;
}
// 71E0: using guessed type __int64  lys_getnext(_QWORD, _QWORD, _QWORD, _QWORD);
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 77E0: using guessed type __int64  lyd_first_sibling(_QWORD);

//----- (000000000003010D) ----------------------------------------------------
signed __int64  sub_3010D(__int64 *a1, __int64 a2, char **a3, int a4, char *a5)
{
  __int64 v6; // r9
  char v7; // al
  char *v8; // [rsp+8h] [rbp-58h]
  int v9; // [rsp+14h] [rbp-4Ch]
  char **v10; // [rsp+18h] [rbp-48h]
  __int64 v11; // [rsp+20h] [rbp-40h]
  __int64 i; // [rsp+30h] [rbp-30h]
  __int64 k; // [rsp+30h] [rbp-30h]
  __int64 *v14; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  char *v16; // [rsp+48h] [rbp-18h]
  char *j; // [rsp+50h] [rbp-10h]
  __int64 v18; // [rsp+58h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  if ( !a1 && !a2 )
    __assert_fail(
      "node || schemanode",
      "/home/mantovan/Repositories/libyang/src/validation.c",
      0x382u,
      "lyv_multicases");
  if ( !a1 )
    v11 = *a1;
  for ( i = lys_parent(v11); i && *(_DWORD *)(i + 56) == 4096; i = lys_parent(i) )
    ;
  if ( !i || !(*(_DWORD *)(i + 56) & 0x42) )
    return 0LL;
  if ( !v10 || !*v10 )
    return 0LL;
  if ( *(_DWORD *)(i + 56) == 2 )
  {
    v14 = (__int64 *)i;
    v15 = v11;
  }
  else
  {
    v14 = (__int64 *)lys_parent(i);
    v15 = i;
  }
  while ( 1 )
  {
    for ( j = *v10; ; j = v16 )
    {
      if ( j )
      {
        v15 = (char *)*((_QWORD *)j + 3);
        v7 = 1;
      }
      else
      {
        v7 = 0;
      }
      if ( !v7 )
        break;
      if ( v11 != *(_QWORD *)j )
      {
        for ( k = lys_parent(*(_QWORD *)j); k && *(_DWORD *)(k + 56) == 4096; k = lys_parent(k) )
          ;
        if ( k
          && (*(_DWORD *)(k + 56) == 2 && (__int64 *)k == v14
           || *(_DWORD *)(k + 56) == 64 && k != v15 && v14 == (__int64 *)lys_parent(k)) )
        {
          if ( !v9 )
          {
            sub_13937(**(void ***)(v11 + 48), 57, 3u, j, *v14, v6);
            return 1LL;
          }
          if ( j == v8 )
          {
            sub_13936(**(void ***)(v11 + 48), 57, 3u, j, *v14, v6);
            return 2LL;
          }
          if ( j == *v10 )
            *v10 = v16;
          lyd_free(j);
        }
      }
    }
    if ( !*v10 )
      break;
    v18 = lys_parent(v14);
    if ( !v18 || !(*(_DWORD *)(v18 + 56) & 0x40) )
      break;
    v14 = (__int64 *)lys_parent(v18);
    v15 = v18;
  }
  return 0LL;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);
// 7BE0: using guessed type __int64  lyd_free(_QWORD);

//----- (00000000000303F5) ----------------------------------------------------
__int64  lyxml_get_ns(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  char *s2; // [rsp+0h] [rbp-20h]
  __int64 i; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  for ( i = *(_QWORD *)(a1 + 16); ; i = *(_QWORD *)(i + 8) )
  {
    if ( !i )
      return lyxml_get_ns(*(_QWORD *)(a1 + 8), s2);
    if ( *(_DWORD *)i == 2 )
      break;
LABEL_13:
    ;
  }
  if ( *(_QWORD *)(i + 24) )
  {
    if ( s2 && !strcmp(*(const char **)(i + 24), s2) )
      return i;
    goto LABEL_13;
  }
  if ( s2 )
    goto LABEL_13;
  if ( *(_QWORD *)(i + 32) )
    result = i;
  else
    result = 0LL;
  return result;
}
// 7890: using guessed type __int64  lyxml_get_ns(_QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (00000000000304CF) ----------------------------------------------------
unsigned int * sub_304CF(__int64 a1, unsigned int *a2, __int64 a3, int a4)
{
  unsigned int *result; // rax
  unsigned int *v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 j; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  result = (unsigned int *)*a2;
  if ( (_DWORD)result != 2 )
  {
    result = (unsigned int *)*((_QWORD *)a2 + 2);
    if ( result )
    {
      for ( i = a3; *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
        ;
      for ( j = *(_QWORD *)(*((_QWORD *)a2 + 2) + 16LL); *(_QWORD *)(j + 8); j = *(_QWORD *)(j + 8) )
        ;
      result = (unsigned int *)j;
      if ( j != i )
      {
        if ( a4 )
        {
          v9 = *((_QWORD *)a2 + 2);
          *((_QWORD *)a2 + 2) = lyxml_get_ns(a3, *(_QWORD *)(v9 + 24));
          result = (unsigned int *)*((_QWORD *)a2 + 2);
          if ( !result )
          {
            v5 = sub_305D2(a1, v6, v9);
            result = a2;
            *((_QWORD *)a2 + 2) = v5;
          }
        }
        else
        {
          result = a2;
          *((_QWORD *)a2 + 2) = 0LL;
        }
      }
    }
  }
  return result;
}
// 7890: using guessed type __int64  lyxml_get_ns(_QWORD, _QWORD);

//----- (00000000000305D2) ----------------------------------------------------
unsigned int * sub_305D2(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *result; // rax
  __int64 v4; // r9
  __int64 v5; // [rsp+8h] [rbp-28h]
  unsigned int *v6; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v5 = a3;
  if ( !a3 || !a2 )
    return 0LL;
  v6 = (unsigned int *)calloc(1uLL, 0x28uLL);
  if ( v6 )
  {
    *((_QWORD *)v6 + 4) = lydict_insert(a1, *(_QWORD *)(v5 + 32), 0LL);
    *((_QWORD *)v6 + 3) = lydict_insert(a1, *(_QWORD *)(v5 + 24), 0LL);
    *v6 = *(_DWORD *)v5;
    if ( *v6 == 1 && *(_QWORD *)(v5 + 16) )
    {
      *((_QWORD *)v6 + 2) = *(_QWORD *)(v5 + 16);
      sub_304CF(a1, v6, a2, 1);
    }
    if ( *v6 == 2 )
      *((_QWORD *)v6 + 2) = a2;
    if ( *(_QWORD *)(a2 + 16) )
    {
      for ( i = *(_QWORD *)(a2 + 16); *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
        ;
      *(_QWORD *)(i + 8) = v6;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = v6;
    }
    result = v6;
  }
  else
  {
    sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_dup_attr", v4);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000030771) ----------------------------------------------------
_QWORD * sub_30771(__int64 a1, _QWORD *a2, int a3, int a4)
{
  _QWORD *result; // rax
  int v5; // [rsp+8h] [rbp-48h]
  int v6; // [rsp+Ch] [rbp-44h]
  _QWORD *j; // [rsp+20h] [rbp-30h]
  __int64 l; // [rsp+28h] [rbp-28h]
  _QWORD *v9; // [rsp+30h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-18h]
  __int64 k; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  for ( i = (__int64)a2; *(_QWORD *)(i + 8); i = *(_QWORD *)(i + 8) )
    ;
  result = a2;
  for ( j = a2; j; j = v9 )
  {
    if ( j[7] )
    {
      for ( k = *(_QWORD *)(j[7] + 16LL); k; k = *(_QWORD *)(k + 8) )
        ;
      if ( 0 != i )
      {
        if ( v6 )
        {
          v12 = j[7];
          j[7] = lyxml_get_ns(j, *(_QWORD *)(v12 + 24));
          if ( !j[7] )
            j[7] = sub_305D2(a1, (__int64)j, v12);
        }
        else
        {
          j[7] = 0LL;
        }
      }
    }
    if ( v5 )
    {
      for ( l = j[2]; l; l = *(_QWORD *)(l + 8) )
        sub_304CF(a1, (unsigned int *)l, i, v6);
    }
    v9 = (_QWORD *)j[3];
    if ( !v9 )
    {
      result = j;
      if ( j == a2 )
        return result;
      v9 = (_QWORD *)j[4];
    }
    while ( !v9 )
    {
      j = (_QWORD *)j[1];
      if ( j[1] == a2[1] )
        break;
      v9 = (_QWORD *)j[4];
    }
    result = v9;
  }
  return result;
}
// 7890: using guessed type __int64  lyxml_get_ns(_QWORD, _QWORD);

//----- (0000000000030929) ----------------------------------------------------
_QWORD * sub_30929(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5)
{
  __int64 v6; // r9
  unsigned __int64 v7; // [rsp+0h] [rbp-40h]
  __int64 v8; // [rsp+8h] [rbp-38h]
  __int64 v9; // [rsp+10h] [rbp-30h]
  _QWORD *v10; // [rsp+28h] [rbp-18h]
  __int64 i; // [rsp+30h] [rbp-10h]
  _QWORD *v12; // [rsp+38h] [rbp-8h]

  v9 = a2;
  v8 = a3;
  v7 = __PAIR__(a4, a5);
  v10 = 0LL;
  if ( !a2 )
    return 0LL;
  while ( v9 )
  {
    v12 = calloc(1uLL, 0x48uLL);
    if ( !v12 )
    {
      sub_12222(a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_dup_elem", v6, v7);
      return 0LL;
    }
    v12[8] = lydict_insert(a1, *(_QWORD *)(v9 + 64), 0LL);
    v12[6] = lydict_insert(a1, *(_QWORD *)(v9 + 48), 0LL);
    *(_BYTE *)v12 = *(_BYTE *)v9;
    v12[5] = v12;
    if ( v8 )
    {
      sub_3116F(a1, v8, v12);
    }
    else if ( v10 )
    {
      v12[5] = v10[5];
      *(_QWORD *)(v12[5] + 32LL) = v12;
      v10[5] = v12;
    }
    v12[7] = *(_QWORD *)(v9 + 56);
    for ( i = *(_QWORD *)(v9 + 16); i; i = *(_QWORD *)(i + 8) )
      sub_305D2(a1, (__int64)v12, i);
    sub_30771(a1, v12, 1, 0);
    if ( HIDWORD(v7) )
      sub_30929(a1, *(_QWORD *)(v9 + 24), v12, 1LL, 1LL);
    if ( !v10 )
      v10 = v12;
    if ( !(_DWORD)v7 )
      break;
    v9 = *(_QWORD *)(v9 + 32);
  }
  return v10;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000030B28) ----------------------------------------------------
_QWORD * lyxml_dup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // ST00_8
  __int64 v7; // ST08_8

  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_dup", a4, a5, a6, a2, a1);
  return sub_30929(v7, v6, 0LL, 1u, 0);
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000030B77) ----------------------------------------------------
_QWORD * sub_30B77(__int64 a1, _QWORD *a2, int a3)
{
  _QWORD *result; // rax
  _QWORD *i; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  if ( a2 )
  {
    v5 = a2[1];
    if ( v5 )
    {
      if ( a2 == *(_QWORD **)(v5 + 24) )
        *(_QWORD *)(v5 + 24) = a2[4];
      a2[1] = 0LL;
    }
    if ( a3 <= 1 )
      sub_30771(a1, a2, a3, 1);
    result = (_QWORD *)a2[5];
    if ( a2 != result )
    {
      if ( a2[4] )
      {
        *(_QWORD *)(a2[4] + 40LL) = a2[5];
      }
      else
      {
        if ( v5 )
        {
          i = *(_QWORD **)(v5 + 24);
        }
        else
        {
          for ( i = a2; *(_QWORD *)(i[5] + 32LL); i = (_QWORD *)i[5] )
            ;
        }
        i[5] = a2[5];
      }
      if ( *(_QWORD *)(a2[5] + 32LL) )
        *(_QWORD *)(a2[5] + 32LL) = a2[4];
      a2[4] = 0LL;
      result = a2;
      a2[5] = a2;
    }
  }
  return result;
}

//----- (0000000000030CB6) ----------------------------------------------------
unsigned __int64  lyxml_unlink(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  _QWORD *v7; // [rsp+0h] [rbp-10h]

  result = sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_unlink", a4, a5, a6, a2);
  if ( v7 )
    result = (unsigned __int64)sub_30B77(a1, v7, 1);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000030D07) ----------------------------------------------------
void  sub_30D07(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *ptr; // [rsp+8h] [rbp-28h]
  _QWORD *i; // [rsp+20h] [rbp-10h]
  _QWORD *v5; // [rsp+28h] [rbp-8h]

  ptr = a3;
  if ( a3 )
  {
    if ( !a2 )
    {
LABEL_11:
      lydict_remove(a1, a3[3]);
      lydict_remove(a1, ptr[4]);
      free(ptr);
      return;
    }
    v5 = 0LL;
    for ( i = *(_QWORD **)(a2 + 16); i && i != a3; i = (_QWORD *)i[1] )
      v5 = i;
    if ( i )
    {
      if ( v5 )
        v5[1] = a3[1];
      else
        *(_QWORD *)(a2 + 16) = a3[1];
      goto LABEL_11;
    }
  }
}
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000030DDD) ----------------------------------------------------
_QWORD * sub_30DDD(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  _QWORD *v3; // ST18_8
  _QWORD *ptr; // [rsp+10h] [rbp-10h]

  if ( a2 )
  {
    result = *(_QWORD **)(a2 + 16);
    if ( result )
    {
      ptr = *(_QWORD **)(a2 + 16);
      do
      {
        v3 = (_QWORD *)ptr[1];
        lydict_remove(a1, ptr[3]);
        lydict_remove(a1, ptr[4]);
        free(ptr);
        result = v3;
        ptr = v3;
      }
      while ( v3 );
    }
  }
  return result;
}
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000030E67) ----------------------------------------------------
void  sub_30E67(__int64 a1, _QWORD *a2)
{
  char v2; // al
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  if ( a2 )
  {
    sub_30DDD(a1, (__int64)a2);
    for ( i = a2[3]; ; i = v4 )
    {
      if ( i )
      {
        v4 = *(_QWORD *)(i + 32);
        v2 = 1;
      }
      else
      {
        v2 = 0;
      }
      if ( !v2 )
        break;
      sub_30E67(a1, i);
    }
    lydict_remove(a1, a2[6]);
    lydict_remove(a1, a2[8]);
    free(a2);
  }
}
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000030F20) ----------------------------------------------------
void  lyxml_free(__int64 a1, __int64 a2)
{
  _QWORD *v6; // [rsp+0h] [rbp-10h]

  if ( v6 )
  {
    sub_30B77(a1, v6, 2);
    sub_30E67(a1, v6);
  }
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000030F84) ----------------------------------------------------
unsigned __int64  lyxml_free_withsiblings(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-20h]
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 j; // [rsp+10h] [rbp-10h]
  __int64 v10; // [rsp+18h] [rbp-8h]

  result = sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_free_withsiblings", a4, a5, a6, a2);
  if ( v7 )
  {
    for ( i = *(_QWORD *)(v7 + 40); *(_QWORD *)(i + 32); i = v10 )
    {
      v10 = *(_QWORD *)(i + 40);
      lyxml_free(a1, i);
    }
    for ( j = v7; ; j = v10 )
    {
      if ( j )
      {
        v10 = *(_QWORD *)(j + 32);
        result = 1LL;
      }
      else
      {
        result = 0LL;
      }
      if ( !(_BYTE)result )
        break;
      lyxml_free(a1, j);
    }
  }
  return result;
}
// 78A0: using guessed type __int64  lyxml_free(_QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (000000000003104B) ----------------------------------------------------
__int64  lyxml_get_attr(__int64 a1, const char *a2, char *a3)
{
  char *v7; // [rsp+8h] [rbp-28h]
  __int64 i; // [rsp+28h] [rbp-8h]

  v7 = a3;
  if ( !a1 )
    __assert_fail("elem", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1BCu, "lyxml_get_attr");
  if ( !a2 )
    __assert_fail("name", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1BDu, "lyxml_get_attr");
  for ( i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(i + 8) )
  {
    if ( *(_DWORD *)i == 1
      && !strcmp(a2, *(const char **)(i + 24))
      && (!v7 && !*(_QWORD *)(i + 16)
       || v7 && *(_QWORD *)(i + 16) && !strcmp(v7, *(const char **)(*(_QWORD *)(i + 16) + 32LL))) )
    {
      return *(_QWORD *)(i + 32);
    }
  }
  return 0LL;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (000000000003116F) ----------------------------------------------------
__int64  sub_3116F(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // ST28_8
  _QWORD *v5; // [rsp+8h] [rbp-28h]

  v5 = a3;
  if ( !a2 )
    __assert_fail("parent", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1D3u, "lyxml_add_child");
  if ( !a3 )
    __assert_fail("elem", "/home/mantovan/Repositories/libyang/src/xml.c", 0x1D4u, "lyxml_add_child");
  if ( a3[1] )
    sub_30B77(a1, a3, 1);
  v5[1] = a2;
  if ( *(_QWORD *)(a2 + 24) )
  {
    v3 = *(_QWORD *)(a2 + 24);
    v5[5] = *(_QWORD *)(v3 + 40);
    v5[4] = 0LL;
    *(_QWORD *)(v5[5] + 32LL) = v5;
    *(_QWORD *)(v3 + 40) = v5;
  }
  else
  {
    *(_QWORD *)(a2 + 24) = v5;
    v5[5] = v5;
    v5[4] = 0LL;
  }
  return 0LL;
}

//----- (000000000003127E) ----------------------------------------------------
__int64  sub_3127E(void *a1, char *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v7; // ST2C_1
  char v8; // ST2C_1
  char v9; // ST2C_1
  int v10; // [rsp+24h] [rbp-Ch]
  signed int i; // [rsp+28h] [rbp-8h]
  signed int j; // [rsp+28h] [rbp-8h]

  v10 = *a2;
  *a3 = 0;
  if ( !v10 )
  {
    sub_13937(a1, 4, 0, 0LL, a5, a6);
    return 0LL;
  }
  *a3 = 1;
  if ( (v10 & 0xF8) == 240 )
  {
    *a3 = 4;
    v10 &= 7u;
    for ( i = 1; i <= 3; ++i )
    {
      v7 = a2[i];
      if ( (v7 & 0xC0) != 128 )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
        return 0LL;
      }
      v10 = (v10 << 6) | a2[i] & 0x3F;
    }
    if ( v10 <= 4095 || v10 > 1114111 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  else if ( (v10 & 0xF0) == 224 )
  {
    *a3 = 3;
    v10 &= 0xFu;
    for ( j = 1; j <= 2; ++j )
    {
      v8 = a2[j];
      if ( (v8 & 0xC0) != 128 )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
        return 0LL;
      }
      v10 = (v10 << 6) | a2[j] & 0x3F;
    }
    if ( v10 <= 2047 || v10 > 55295 && v10 <= 57343 || v10 > 65533 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  else if ( (v10 & 0xE0) == 192 )
  {
    *a3 = 2;
    v9 = a2[1];
    if ( (v9 & 0xC0) != 128 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
    v10 = ((_WORD)v10 << 6) & 0x7C0 | a2[1] & 0x3F;
    if ( v10 <= 127 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  else
  {
    if ( v10 & 0x80 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
    if ( v10 <= 31 && v10 != 9 && v10 != 10 && v10 != 13 )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"input character", a6);
      return 0LL;
    }
  }
  return (unsigned int)v10;
}

//----- (0000000000031603) ----------------------------------------------------
signed __int64  sub_31603(void *a1, const char *a2, const char *a3, _DWORD *a4)
{
  signed __int64 result; // rax
  _DWORD *v5; // [rsp+0h] [rbp-30h]
  char *s; // [rsp+8h] [rbp-28h]
  unsigned int n; // [rsp+24h] [rbp-Ch]
  const char *n_4; // [rsp+28h] [rbp-8h]

  s = (char *)a3;
  v5 = a4;
  n_4 = a2;
  n = strlen(a3);
  while ( *n_4 && strncmp(n_4, s, n) )
    ++n_4;
  if ( *n_4 )
  {
    *v5 = n + (_DWORD)n_4 - (_DWORD)a2;
    result = 0LL;
  }
  else
  {
    sub_13937(a1, 1, 0, 0LL, (__int64)"closing sequence", (__int64)s, v5);
    result = 1LL;
  }
  return result;
}

//----- (00000000000316C2) ----------------------------------------------------
char * sub_316C2(void *a1, __int64 a2, char a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned int v12; // eax
  int v13; // eax
  __int64 v14; // r9
  __int64 v15; // r9
  _DWORD *v16; // [rsp+0h] [rbp-460h]
  char v17; // [rsp+Ch] [rbp-454h]
  int v18; // [rsp+2Ch] [rbp-434h]
  int v19; // [rsp+2Ch] [rbp-434h]
  int v20; // [rsp+2Ch] [rbp-434h]
  int v21; // [rsp+30h] [rbp-430h]
  int v22; // [rsp+34h] [rbp-42Ch]
  signed int v23; // [rsp+38h] [rbp-428h]
  signed int v24; // [rsp+3Ch] [rbp-424h]
  char *ptr; // [rsp+40h] [rbp-420h]
  char src[1032]; // [rsp+50h] [rbp-410h]
  unsigned __int64 v27; // [rsp+458h] [rbp-8h]

  v16 = a4;
  v17 = a3;
  v27 = __readfsqword(0x28u);
  ptr = 0LL;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  *a4 = 0;
  while ( v23 || v17 != *(_BYTE *)((unsigned int)*v16 + a2) )
  {
    if ( !*(_BYTE *)((unsigned int)*v16 + a2) || !v23 && !strncmp((const char *)((unsigned int)*v16 + a2), "]]>", 3uLL) )
    {
      sub_13937(a1, 2, 0, 0LL, (__int64)"element content, \"]]>\" found", a6, v16);
LABEL_75:
      *v16 = 0;
      free(ptr);
      return 0LL;
    }
LABEL_6:
    if ( v21 > 1020 )
    {
      if ( ptr )
      {
        v22 += v21;
        ptr = (char *)sub_C422(ptr, v22 + 1);
      }
      else
      {
        v22 = v21;
        ptr = (char *)malloc(v21 + 1);
      }
      if ( !ptr )
      {
        sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_text", v6, v16);
        return 0LL;
      }
      memcpy(&ptr[v22 - v21], src, v21);
      v21 = 0;
    }
    if ( v23 || !strncmp((const char *)((unsigned int)*v16 + a2), "<![CDATA[", 9uLL) )
    {
      if ( !v23 )
      {
        v23 = 1;
        *v16 += 9;
      }
      if ( *(_BYTE *)((unsigned int)*v16 + a2) && !strncmp((const char *)((unsigned int)*v16 + a2), "]]>", 3uLL) )
      {
        *v16 += 3;
        v23 = 0;
        --v21;
      }
      else
      {
        src[v21] = *(_BYTE *)((unsigned int)(*v16)++ + a2);
      }
    }
    else if ( *(_BYTE *)((unsigned int)*v16 + a2) == 38 )
    {
      if ( *(_BYTE *)((unsigned int)++*v16 + a2) == 35 )
      {
        if ( (*__ctype_b_loc())[*(char *)((unsigned int)++*v16 + a2)] & 0x800 )
        {
          v24 = 0;
          while ( (*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x800 )
            v24 = 10 * v24 + *(char *)((unsigned int)(*v16)++ + a2) - 48;
          if ( *(_BYTE *)((unsigned int)*v16 + a2) != 59 )
          {
            sub_13937(a1, 2, 0, 0LL, (__int64)"character reference, missing semicolon", v11, v16);
            goto LABEL_75;
          }
        }
        else
        {
          v12 = (*v16)++;
          if ( *(_BYTE *)(v12 + a2) != 120 || !((*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x1000) )
          {
            sub_13937(a1, 2, 0, 0LL, (__int64)"character reference", v9, v16);
            goto LABEL_75;
          }
          v24 = 0;
          while ( (*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x1000 )
          {
            if ( (*__ctype_b_loc())[*(char *)((unsigned int)*v16 + a2)] & 0x800 )
            {
              v18 = *(char *)((unsigned int)*v16 + a2) - 48;
            }
            else
            {
              if ( *(char *)((unsigned int)*v16 + a2) <= 70 )
                v13 = *(char *)((unsigned int)*v16 + a2) - 55;
              else
                v13 = *(char *)((unsigned int)*v16 + a2) - 87;
              v18 = v13;
            }
            v24 = 16 * v24 + v18;
            ++*v16;
          }
        }
        v19 = sub_40272(a1, &src[v21], v24, (__int64)&src[v21], v10, v11);
        if ( !v19 )
        {
          sub_13937(a1, 2, 0, 0LL, (__int64)"character reference value", a6, v16);
          goto LABEL_75;
        }
        v21 = v21 + v19 - 1;
        ++*v16;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "lt;", 3uLL) )
      {
        src[v21] = 60;
        *v16 += 3;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "gt;", 3uLL) )
      {
        src[v21] = 62;
        *v16 += 3;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "amp;", 4uLL) )
      {
        src[v21] = 38;
        *v16 += 4;
      }
      else if ( !strncmp((const char *)((unsigned int)*v16 + a2), "apos;", 5uLL) )
      {
        src[v21] = 39;
        *v16 += 5;
      }
      else
      {
        if ( strncmp((const char *)((unsigned int)*v16 + a2), "quot;", 5uLL) )
        {
          sub_13937(a1, 2, 0, 0LL, (__int64)"entity reference (only predefined references are supported)", a6, v16);
          goto LABEL_75;
        }
        src[v21] = 34;
        *v16 += 5;
      }
    }
    else
    {
      v20 = sub_40445(a1, (__int64)&src[v21], (char *)(a2 + (unsigned int)*v16), (__int64)&src[v21], v8, a6);
      if ( !v20 )
        goto LABEL_75;
      v21 = v21 + v20 - 1;
      *v16 += v20;
    }
    ++v21;
  }
  if ( v17 == 60 && !strncmp((const char *)((unsigned int)*v16 + a2), "<![CDATA[", 9uLL) )
    goto LABEL_6;
  if ( v21 )
  {
    if ( ptr )
    {
      v22 += v21;
      ptr = (char *)realloc(ptr, v22 + 1);
    }
    else
    {
      v22 = v21;
      ptr = (char *)malloc(v21 + 1);
    }
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_text", v14, v16);
      return 0LL;
    }
    memcpy(&ptr[v22 - v21], src, v21);
  }
  if ( ptr )
  {
    ptr[v22] = 0;
  }
  else
  {
    ptr = strdup(&byte_10CE4D);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_text", v15, v16);
      return 0LL;
    }
  }
  return ptr;
}
// 316C2: using guessed type char src[1032];

//----- (000000000003223C) ----------------------------------------------------
void * sub_3223C(void *a1, char *a2, _DWORD *a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // rax
  __int64 v13; // rax
  char v14; // dl
  __int64 v15; // rax
  __int64 v16; // [rsp+0h] [rbp-70h]
  _DWORD *v17; // [rsp+8h] [rbp-68h]
  char v18; // [rsp+27h] [rbp-49h]
  unsigned int v19; // [rsp+28h] [rbp-48h]
  int i; // [rsp+2Ch] [rbp-44h]
  char *s1; // [rsp+30h] [rbp-40h]
  char *v22; // [rsp+38h] [rbp-38h]
  void *dest; // [rsp+40h] [rbp-30h]
  void *ptr; // [rsp+48h] [rbp-28h]
  __int64 j; // [rsp+50h] [rbp-20h]
  char *v26; // [rsp+58h] [rbp-18h]
  char *v27; // [rsp+60h] [rbp-10h]
  unsigned __int64 v28; // [rsp+68h] [rbp-8h]

  v17 = a3;
  v16 = a4;
  v28 = __readfsqword(0x28u);
  s1 = a2;
  dest = 0LL;
  ptr = 0LL;
  if ( !strncmp(a2, "xmlns", 5uLL) )
  {
    ptr = calloc(1uLL, 0x28uLL);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_attr", v5, v16);
      return 0LL;
    }
    *(_DWORD *)ptr = 2;
    *((_QWORD *)ptr + 2) = v16;
    s1 += 5;
    if ( *s1 != 58 )
      goto LABEL_92;
    ++s1;
  }
  else
  {
    ptr = calloc(1uLL, 0x28uLL);
    if ( !ptr )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_attr", v5, v16);
      return 0LL;
    }
    *(_DWORD *)ptr = 1;
  }
  v22 = s1;
  i = sub_3127E(a1, s1, &v19, (__int64)s1, v4, v5);
  if ( (i <= 96 || i > 122)
    && i != 95
    && (i <= 64 || i > 90)
    && i != 58
    && (i <= 879 || i > 0x1FFF || i == 894)
    && (i <= 191 || i > 767 || i == 215 || i == 247)
    && i != 8204
    && i != 8205
    && (i <= 8303 || i > 8591)
    && (i <= 11263 || i > 12271)
    && (i <= 12288 || i > 55295)
    && (i <= 63743 || i > 64975)
    && (i <= 65007 || i > 65533)
    && (i <= 0xFFFF || i > (signed int)&loc_EFFFF) )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"NameStartChar of the attribute", v8, v16);
    free(ptr);
    return 0LL;
  }
  v18 = 4;
  if ( *s1 == 120 )
    v18 = 1;
  s1 += v19;
  for ( i = sub_3127E(a1, s1, &v19, (__int64)s1, v7, v8);
        i > 96 && i <= 122
     || i == 95
     || i == 45
     || i > 64 && i <= 90
     || i > 47 && i <= 57
     || i == 58
     || i == 46
     || i == 183
     || i > 879 && i <= 0x1FFF && i != 894
     || i > 191 && i <= 767 && i != 215 && i != 247
     || i == 8204
     || i == 8205
     || i > 767 && i <= 879
     || i > 8303 && i <= 8591
     || i > 131854 && i <= 8256
     || i > 11263 && i <= 12271
     || i > 12288 && i <= 55295
     || i > 63743 && i <= 64975
     || i > 65007 && i <= 65533
     || i > 0xFFFF && i <= (signed int)&loc_EFFFF;
        i = sub_3127E(a1, s1, &v19, (__int64)s1, v9, v10) )
  {
    if ( *(_DWORD *)ptr == 1 )
    {
      if ( *s1 != 58 || v18 == 3 )
      {
        if ( (*s1 != 109 || v18 != 1) && (*s1 != 108 || v18 != 2) )
          v18 = 4;
        else
          ++v18;
      }
      else
      {
        v22 = s1 + 1;
        dest = malloc(s1 - a2 + 1);
        if ( !dest )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"parse_attr", v11, v16);
          goto LABEL_117;
        }
        memcpy(dest, a2, s1 - a2);
        void* d = dest + (int)s1 - (int)a2;
	d = 0;
        v12 = lyxml_get_ns(v16, dest);
        *((_QWORD *)ptr + 2) = v12;
      }
    }
    s1 += v19;
  }
  v19 = (_DWORD)s1 - (_DWORD)v22;
  v13 = lydict_insert(a1, v22, (unsigned int)((_DWORD)s1 - (_DWORD)v22));
  *((_QWORD *)ptr + 3) = v13;
LABEL_92:
  while ( *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13 )
    ++s1;
  if ( *s1 != 61 )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"attribute definition, \"=\" expected", v5, v16);
LABEL_117:
    sub_30D07((__int64)a1, 0LL, ptr);
    free(dest);
    return 0LL;
  }
  ++s1;
  while ( *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13 )
    ++s1;
  if ( !*s1 || *s1 != 34 && *s1 != 39 )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"attribute value, \" or ' expected", v5, v16);
    goto LABEL_117;
  }
  v26 = s1;
  v14 = *s1++;
  v27 = sub_316C2(a1, (__int64)s1, v14, &v19, v4, v5);
  if ( !v27 && !v19 )
    goto LABEL_117;
  v15 = lydict_insert_zc(a1, v27);
  *((_QWORD *)ptr + 4) = v15;
  *v17 = v19 + 1 + (_DWORD)s1 - (_DWORD)a2;
  if ( *(_QWORD *)(v16 + 16) )
  {
    for ( j = *(_QWORD *)(v16 + 16); *(_QWORD *)(j + 8); j = *(_QWORD *)(j + 8) )
      ;
    *(_QWORD *)(j + 8) = ptr;
  }
  else
  {
    *(_QWORD *)(v16 + 16) = ptr;
  }
  free(dest);
  return ptr;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);
// 7890: using guessed type __int64  lyxml_get_ns(_QWORD, _QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000032A07) ----------------------------------------------------
char * sub_32A07(void *a1, void *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r9
  __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v24; // r9
  __int64 v25; // rax
  __int64 v26; // r9
  __int64 v27; // r9
  void *v28; // rax
  __int64 v29; // rax
  unsigned int v30; // [rsp+Ch] [rbp-A4h]
  __int64 v31; // [rsp+10h] [rbp-A0h]
  _DWORD *v32; // [rsp+18h] [rbp-98h]
  size_t v33; // [rsp+3Ch] [rbp-74h]
  size_t n; // [rsp+44h] [rbp-6Ch]
  int v35; // [rsp+4Ch] [rbp-64h]
  void *src; // [rsp+50h] [rbp-60h]
  char *v37; // [rsp+58h] [rbp-58h]
  void *v38; // [rsp+60h] [rbp-50h]
  void *dest; // [rsp+68h] [rbp-48h]
  char *v40; // [rsp+70h] [rbp-40h]
  void *v41; // [rsp+78h] [rbp-38h]
  _QWORD *v42; // [rsp+80h] [rbp-30h]
  void *s1; // [rsp+88h] [rbp-28h]
  void *v44; // [rsp+90h] [rbp-20h]
  unsigned __int64 v45; // [rsp+98h] [rbp-18h]

  v32 = a3;
  v31 = a4;
  v30 = a5;
  v45 = __readfsqword(0x28u);
  src = a2;
  dest = 0LL;
  n = 0LL;
  v40 = 0LL;
  v35 = 0;
  *a3 = 0;
  if ( *(_BYTE *)src != 60 )
    return 0LL;
  src = (char *)src + 1;
  v37 = (char *)src;
  HIDWORD(v33) = sub_3127E(a1, (char *)src, &v33, (__int64)src, a5, a6);
  if ( (SHIDWORD(v33) <= 96 || SHIDWORD(v33) > 122)
    && HIDWORD(v33) != 95
    && (SHIDWORD(v33) <= 64 || SHIDWORD(v33) > 90)
    && HIDWORD(v33) != 58
    && (SHIDWORD(v33) <= 879 || SHIDWORD(v33) > 0x1FFF || HIDWORD(v33) == 894)
    && (SHIDWORD(v33) <= 191 || SHIDWORD(v33) > 767 || HIDWORD(v33) == 215 || HIDWORD(v33) == 247)
    && HIDWORD(v33) != 8204
    && HIDWORD(v33) != 8205
    && (SHIDWORD(v33) <= 8303 || SHIDWORD(v33) > 8591)
    && (SHIDWORD(v33) <= 11263 || SHIDWORD(v33) > 12271)
    && (SHIDWORD(v33) <= 12288 || SHIDWORD(v33) > 55295)
    && (SHIDWORD(v33) <= 63743 || SHIDWORD(v33) > 64975)
    && (SHIDWORD(v33) <= 65007 || SHIDWORD(v33) > 65533)
    && (SHIDWORD(v33) <= 0xFFFF || SHIDWORD(v33) > (signed int)&loc_EFFFF) )
  {
    sub_13937(a1, 2, 0, 0LL, (__int64)"NameStartChar of the element", v8);
    return 0LL;
  }
  v37 += (unsigned int)v33;
  for ( HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v7, v8);
        SHIDWORD(v33) > 96 && SHIDWORD(v33) <= 122
     || HIDWORD(v33) == 95
     || HIDWORD(v33) == 45
     || SHIDWORD(v33) > 64 && SHIDWORD(v33) <= 90
     || SHIDWORD(v33) > 47 && SHIDWORD(v33) <= 57
     || HIDWORD(v33) == 58
     || HIDWORD(v33) == 46
     || HIDWORD(v33) == 183
     || SHIDWORD(v33) > 879 && SHIDWORD(v33) <= 0x1FFF && HIDWORD(v33) != 894
     || SHIDWORD(v33) > 191 && SHIDWORD(v33) <= 767 && HIDWORD(v33) != 215 && HIDWORD(v33) != 247
     || HIDWORD(v33) == 8204
     || HIDWORD(v33) == 8205
     || SHIDWORD(v33) > 767 && SHIDWORD(v33) <= 879
     || SHIDWORD(v33) > 8303 && SHIDWORD(v33) <= 8591
     || SHIDWORD(v33) > 131854 && SHIDWORD(v33) <= 8256
     || SHIDWORD(v33) > 11263 && SHIDWORD(v33) <= 12271
     || SHIDWORD(v33) > 12288 && SHIDWORD(v33) <= 55295
     || SHIDWORD(v33) > 63743 && SHIDWORD(v33) <= 64975
     || SHIDWORD(v33) > 65007 && SHIDWORD(v33) <= 65533
     || SHIDWORD(v33) > 0xFFFF && SHIDWORD(v33) <= (signed int)&loc_EFFFF;
        HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v9, v10) )
  {
    if ( *v37 == 58 )
    {
      if ( (_DWORD)n )
      {
        sub_13937(a1, 2, 0, 0LL, (__int64)"element name, multiple colons found", v10);
        goto LABEL_257;
      }
      v44 = v37 + 1;
      LODWORD(n) = (_DWORD)v37 - (_DWORD)src;
      if ( dest )
      {
        sub_13937(a1, 3, 0, 0LL, (__int64)v37, v10);
        goto LABEL_257;
      }
      dest = malloc((unsigned int)(n + 1));
      if ( !dest )
      {
        sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v11);
        goto LABEL_257;
      }
      memcpy(dest, src, (unsigned int)n);
      *((_BYTE *)dest + (unsigned int)n) = 0;
      src = v44;
    }
    v37 += (unsigned int)v33;
  }
  if ( !*v37 )
  {
    sub_13937(a1, 4, 0, 0LL, v9, v10);
    free(dest);
    return 0LL;
  }
  v40 = (char *)calloc(1uLL, 0x48uLL);
  if ( !v40 )
  {
    free(dest);
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v12);
    return 0LL;
  }
  *((_QWORD *)v40 + 4) = 0LL;
  *((_QWORD *)v40 + 5) = v40;
  if ( v31 )
    sub_3116F((__int64)a1, v31, v40);
  v13 = lydict_insert(a1, src, v37 - (char *)src);
  *((_QWORD *)v40 + 6) = v13;
  src = v37;
  while ( 1 )
  {
    while ( *(_BYTE *)src == 32 || *(_BYTE *)src == 9 || *(_BYTE *)src == 10 || *(_BYTE *)src == 13 )
      src = (char *)src + 1;
    if ( !strncmp("/>", (const char *)src, 2uLL) )
      break;
    if ( *(_BYTE *)src == 62 )
    {
      src = (char *)src + 1;
      v38 = 0LL;
      while ( 1 )
      {
        if ( !*(_BYTE *)src )
          goto LABEL_247;
        if ( !strncmp((const char *)src, "</", 2uLL) )
        {
          if ( !v38 || *((_QWORD *)v40 + 3) )
          {
            src = (char *)src + 2;
            v37 = (char *)src;
            HIDWORD(v33) = sub_3127E(a1, (char *)src, &v33, (__int64)src, v15, v16);
            if ( (SHIDWORD(v33) <= 96 || SHIDWORD(v33) > 122)
              && HIDWORD(v33) != 95
              && (SHIDWORD(v33) <= 64 || SHIDWORD(v33) > 90)
              && HIDWORD(v33) != 58
              && (SHIDWORD(v33) <= 879 || SHIDWORD(v33) > 0x1FFF || HIDWORD(v33) == 894)
              && (SHIDWORD(v33) <= 191 || SHIDWORD(v33) > 767 || HIDWORD(v33) == 215 || HIDWORD(v33) == 247)
              && HIDWORD(v33) != 8204
              && HIDWORD(v33) != 8205
              && (SHIDWORD(v33) <= 8303 || SHIDWORD(v33) > 8591)
              && (SHIDWORD(v33) <= 11263 || SHIDWORD(v33) > 12271)
              && (SHIDWORD(v33) <= 12288 || SHIDWORD(v33) > 55295)
              && (SHIDWORD(v33) <= 63743 || SHIDWORD(v33) > 64975)
              && (SHIDWORD(v33) <= 65007 || SHIDWORD(v33) > 65533)
              && (SHIDWORD(v33) <= 0xFFFF || SHIDWORD(v33) > (signed int)&loc_EFFFF) )
            {
              sub_13937(a1, 2, 1u, v40, (__int64)"NameStartChar of the element", v18);
              goto LABEL_257;
            }
            v37 += (unsigned int)v33;
            for ( HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v17, v18);
                  SHIDWORD(v33) > 96 && SHIDWORD(v33) <= 122
               || HIDWORD(v33) == 95
               || HIDWORD(v33) == 45
               || SHIDWORD(v33) > 64 && SHIDWORD(v33) <= 90
               || SHIDWORD(v33) > 47 && SHIDWORD(v33) <= 57
               || HIDWORD(v33) == 58
               || HIDWORD(v33) == 46
               || HIDWORD(v33) == 183
               || SHIDWORD(v33) > 879 && SHIDWORD(v33) <= 0x1FFF && HIDWORD(v33) != 894
               || SHIDWORD(v33) > 191 && SHIDWORD(v33) <= 767 && HIDWORD(v33) != 215 && HIDWORD(v33) != 247
               || HIDWORD(v33) == 8204
               || HIDWORD(v33) == 8205
               || SHIDWORD(v33) > 767 && SHIDWORD(v33) <= 879
               || SHIDWORD(v33) > 8303 && SHIDWORD(v33) <= 8591
               || SHIDWORD(v33) > 131854 && SHIDWORD(v33) <= 8256
               || SHIDWORD(v33) > 11263 && SHIDWORD(v33) <= 12271
               || SHIDWORD(v33) > 12288 && SHIDWORD(v33) <= 55295
               || SHIDWORD(v33) > 63743 && SHIDWORD(v33) <= 64975
               || SHIDWORD(v33) > 65007 && SHIDWORD(v33) <= 65533
               || SHIDWORD(v33) > 0xFFFF && SHIDWORD(v33) <= (signed int)&loc_EFFFF;
                  HIDWORD(v33) = sub_3127E(a1, v37, &v33, (__int64)v37, v19, v20) )
            {
              if ( *v37 == 58 )
              {
                v44 = v37 + 1;
                if ( !dest || memcmp(dest, src, v37 - (char *)src) )
                {
                  sub_13937(
                    a1,
                    -1,
                    1u,
                    v40,
                    (__int64)"Invalid (different namespaces) opening (%s) and closing element tags.",
                    *((_QWORD *)v40 + 6));
                  goto LABEL_257;
                }
                src = v44;
              }
              v37 += (unsigned int)v33;
            }
            if ( !*v37 )
            {
              sub_13937(a1, 4, 0, 0LL, v19, v20);
              goto LABEL_257;
            }
            LODWORD(v33) = (_DWORD)v37 - (_DWORD)src;
            s1 = malloc((unsigned int)((_DWORD)v37 - (_DWORD)src + 1));
            if ( !s1 )
            {
              sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v21);
              goto LABEL_257;
            }
            memcpy(s1, src, v37 - (char *)src);
            v22 = (unsigned int)v33;
            if ( v22 != strlen(*((const char **)v40 + 6)) || memcmp(s1, *((const void **)v40 + 6), (unsigned int)v33) )
            {
              sub_13937(
                a1,
                -1,
                1u,
                v40,
                (__int64)"Invalid (mixed names) opening (%s) and closing (%s) element tags.",
                *((_QWORD *)v40 + 6),
                s1);
              free(s1);
              goto LABEL_257;
            }
            free(s1);
            for ( src = v37;
                  *(_BYTE *)src == 32 || *(_BYTE *)src == 9 || *(_BYTE *)src == 10 || *(_BYTE *)src == 13;
                  src = (char *)src + 1 )
            {
              ;
            }
            if ( *(_BYTE *)src != 62 )
            {
              sub_13937(a1, -1, 1u, v40, (__int64)"Data after closing element tag \"%s\".", *((_QWORD *)v40 + 6));
              goto LABEL_257;
            }
            src = (char *)src + 1;
            if ( !(*v40 & 1) && !*((_QWORD *)v40 + 8) )
            {
              v23 = lydict_insert(a1, &byte_10CE4D, 0LL);
              *((_QWORD *)v40 + 8) = v23;
            }
            v35 = 1;
            goto LABEL_247;
          }
LABEL_221:
          if ( v38 )
          {
            src = v38;
            v38 = 0LL;
          }
          s1 = sub_316C2(a1, (__int64)src, 60, &v33, v15, v16);
          if ( !s1 && !(_DWORD)v33 )
            goto LABEL_257;
          v25 = lydict_insert_zc(a1, s1);
          *((_QWORD *)v40 + 8) = v25;
          src = (char *)src + (unsigned int)v33;
          if ( *((_QWORD *)v40 + 3) )
          {
            if ( v30 & 2 )
            {
              sub_13937(a1, 2, 1u, v40, (__int64)"XML element with mixed content", v26);
              goto LABEL_257;
            }
            v42 = calloc(1uLL, 0x48uLL);
            if ( !v42 )
            {
              sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v27);
              goto LABEL_257;
            }
            v42[8] = *((_QWORD *)v40 + 8);
            *((_QWORD *)v40 + 8) = 0LL;
            sub_3116F((__int64)a1, (__int64)v40, v42);
            *v40 |= 1u;
          }
        }
        else if ( !strncmp((const char *)src, "<?", 2uLL) )
        {
          if ( v38 )
            v38 = 0LL;
          src = (char *)src + 2;
          if ( (unsigned int)sub_31603(a1, (const char *)src, "?>", &v33) )
            goto LABEL_257;
          src = (char *)src + (unsigned int)v33;
        }
        else if ( !strncmp((const char *)src, "<!--", 4uLL) )
        {
          if ( v38 )
            v38 = 0LL;
          src = (char *)src + 4;
          if ( (unsigned int)sub_31603(a1, (const char *)src, "-->", &v33) )
            goto LABEL_257;
          src = (char *)src + (unsigned int)v33;
        }
        else
        {
          if ( !strncmp((const char *)src, "<![CDATA[", 9uLL) )
            goto LABEL_221;
          if ( *(_BYTE *)src == 60 )
          {
            if ( v38 )
            {
              if ( *v40 & 1 )
                goto LABEL_221;
              v38 = 0LL;
            }
            if ( *((_QWORD *)v40 + 8) )
            {
              if ( v30 & 2 )
              {
                sub_13937(a1, 2, 1u, v40, (__int64)"XML element with mixed content", v16);
                goto LABEL_257;
              }
              v42 = calloc(1uLL, 0x48uLL);
              if ( !v42 )
              {
                sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyxml_parse_elem", v24);
                goto LABEL_257;
              }
              v42[8] = *((_QWORD *)v40 + 8);
              *((_QWORD *)v40 + 8) = 0LL;
              sub_3116F((__int64)a1, (__int64)v40, v42);
              *v40 |= 1u;
            }
            v42 = (_QWORD *)sub_32A07(a1, src, &v33, v40, v30, 0);
            if ( !v42 )
              goto LABEL_257;
            src = (char *)src + (unsigned int)v33;
          }
          else
          {
            if ( *(_BYTE *)src != 32 && *(_BYTE *)src != 9 && *(_BYTE *)src != 10 && *(_BYTE *)src != 13 )
              goto LABEL_221;
            v38 = src;
            while ( *(_BYTE *)src == 32 || *(_BYTE *)src == 9 || *(_BYTE *)src == 10 || *(_BYTE *)src == 13 )
              src = (char *)src + 1;
          }
        }
      }
    }
    v41 = sub_3223C(a1, (char *)src, &v33, (__int64)v40);
    if ( !v41 )
      goto LABEL_257;
    src = (char *)src + (unsigned int)v33;
    if ( *(_DWORD *)v41 == 2 )
    {
      if ( dest && *(_BYTE *)dest || *((_QWORD *)v41 + 3) )
      {
        if ( dest
          && *(_BYTE *)dest
          && *((_QWORD *)v41 + 3)
          && !strncmp(*((const char **)v41 + 3), (const char *)dest, (unsigned int)(n + 1)) )
        {
          *((_QWORD *)v40 + 7) = v41;
        }
      }
      else if ( *((_QWORD *)v41 + 4) )
      {
        *((_QWORD *)v40 + 7) = v41;
      }
      else
      {
        HIDWORD(n) = 1;
      }
    }
  }
  src = (char *)src + 2;
  v14 = lydict_insert(a1, &byte_10CE4D, 0LL);
  *((_QWORD *)v40 + 8) = v14;
  v35 = 1;
LABEL_247:
  *v32 = (_DWORD)src - (_DWORD)a2;
  if ( v35 )
  {
    if ( !*((_QWORD *)v40 + 7) && !HIDWORD(n) && v31 )
    {
      if ( (_DWORD)n )
        v28 = dest;
      else
        v28 = 0LL;
      v29 = lyxml_get_ns(v31, v28);
      *((_QWORD *)v40 + 7) = v29;
    }
    free(dest);
    result = v40;
  }
  else
  {
    sub_13937(a1, 1, 1u, v40, (__int64)"closing element tag", *((_QWORD *)v40 + 6));
LABEL_257:
    lyxml_free(a1, v40);
    free(dest);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);
// 7890: using guessed type __int64  lyxml_get_ns(_QWORD, _QWORD);
// 78A0: using guessed type __int64  lyxml_free(_QWORD, _QWORD);
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000033CCB) ----------------------------------------------------
char * lyxml_parse_mem(void *a1, char *a2, unsigned int a3)
{
  __int64 v6; // r9
  char *result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  char v11; // al
  unsigned int v12; // [rsp+Ch] [rbp-44h]
  unsigned int v13; // [rsp+24h] [rbp-2Ch]
  char *s1; // [rsp+28h] [rbp-28h]
  char *i; // [rsp+30h] [rbp-20h]
  char *v16; // [rsp+38h] [rbp-18h]
  char *v17; // [rsp+40h] [rbp-10h]
  unsigned __int64 v18; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v18 = __readfsqword(0x28u);
  s1 = a2;
  v16 = 0LL;
  if ( a1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( !*s1 )
              return v16;
            if ( *s1 != 32 && *s1 != 9 && *s1 != 10 && *s1 != 13 )
              break;
            while ( *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13 )
              ++s1;
          }
          if ( strncmp(s1, "<?", 2uLL) )
            break;
          s1 += 2;
          if ( (unsigned int)sub_31603(a1, s1, "?>", &v13) )
            goto LABEL_40;
          s1 += v13;
        }
        if ( strncmp(s1, "<!--", 4uLL) )
          break;
        s1 += 2;
        if ( (unsigned int)sub_31603(a1, s1, "-->", &v13) )
          goto LABEL_40;
        s1 += v13;
      }
      if ( !strncmp(s1, "<!", 2uLL) )
      {
        sub_12222((__int64)a1, 0, 3, "DOCTYPE not supported in XML documents.", v8, v9);
        goto LABEL_40;
      }
      if ( *s1 != 60 )
        break;
      i = sub_32A07(a1, s1, &v13, 0LL, v12, v9);
      if ( !i )
        goto LABEL_40;
      if ( v16 )
      {
        *(_QWORD *)(*((_QWORD *)v16 + 5) + 32LL) = i;
        *((_QWORD *)i + 5) = *((_QWORD *)v16 + 5);
        *((_QWORD *)v16 + 5) = i;
      }
      else
      {
        v16 = i;
      }
      for ( s1 += v13; *s1 == 32 || *s1 == 9 || *s1 == 10 || *s1 == 13; ++s1 )
        ;
      if ( !*s1 )
        return v16;
      if ( !(v12 & 1) )
      {
        sub_12222((__int64)a1, 1u, 0, "There are some not parsed data:\n%s", (__int64)s1, v10);
        return v16;
      }
    }
    sub_13937(a1, 3, 0, 0LL, (__int64)s1, v9);
LABEL_40:
    for ( i = v16; ; i = v17 )
    {
      if ( i )
      {
        v17 = (char *)*((_QWORD *)i + 4);
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
      if ( !v11 )
        break;
      lyxml_free(a1, i);
    }
    result = 0LL;
  }
  else
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyxml_parse_mem", v6);
    result = 0LL;
  }
  return result;
}
// 78A0: using guessed type __int64  lyxml_free(_QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (000000000003404F) ----------------------------------------------------
__int64  lyxml_parse_path(__int64 a1, const char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r9
  __int64 v8; // r9
  __int64 v9; // r9
  unsigned int v10; // [rsp+Ch] [rbp-44h]
  int fd; // [rsp+2Ch] [rbp-24h]
  size_t v12; // [rsp+30h] [rbp-20h]
  void *v13; // [rsp+38h] [rbp-18h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v15 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_parse_path", a4, a5, a6);
  v14 = 0LL;
  if ( !a2 || !a1 )
  {
    sub_12222(0LL, 0, 3, "Invalid arguments (%s()).", (__int64)"lyxml_parse_path", v6);
    return 0LL;
  }
  fd = open(a2, 0);
  if ( fd == -1 )
  {
    sub_12222(a1, 0, 3, "Opening file \"%s\" failed.", (__int64)a2, v8);
    return 0LL;
  }
  if ( (unsigned int)sub_34EE2(a1, fd, 0LL, &v12, &v13) )
  {
    sub_12222(a1, 0, 2, "Mapping file descriptor into memory failed (%s()).", (__int64)"lyxml_parse_path", v9);
  }
  else if ( v13 )
  {
    v14 = lyxml_parse_mem(a1, v13, v10);
    sub_351B4(v13, v12);
    close(fd);
    return v14;
  }
  if ( fd != -1 )
    close(fd);
  return 0LL;
}
// 7510: using guessed type __int64  lyxml_parse_mem(_QWORD, _QWORD, _QWORD);
// 10CCE0: using guessed type void *off_10CCE0;

//----- (00000000000341EA) ----------------------------------------------------
__int64  sub_341EA(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed int v7; // eax
  int v8; // [rsp+Ch] [rbp-24h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  v8 = a3;
  if ( !a2 )
    return 0LL;
  v10 = 0;
  for ( i = 0; *(_BYTE *)(i + a2); ++i )
  {
    v7 = *(char *)(i + a2);
    if ( v7 == 38 )
    {
      v10 += sub_C1FF7(a1, "&amp;", i, a4, a5, a6);
      continue;
    }
    if ( v7 > 38 )
    {
      if ( v7 == 60 )
      {
        v10 += sub_C1FF7(a1, "&lt;", i, a4, a5, a6);
        continue;
      }
      if ( v7 == 62 )
      {
        v10 += sub_C1FF7(a1, "&gt;", i, a4, a5, a6);
        continue;
      }
    }
    else if ( v7 == 34 && v8 == 1 )
    {
      v10 += sub_C1FF7(a1, "&quot;", i, a4, a5, a6);
      continue;
    }
    sub_C23A5(a1, (const void *)(i + a2), 1uLL);
    ++v10;
  }
  return v10;
}

//----- (000000000003430E) ----------------------------------------------------
__int64  sub_3430E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  char *v7; // rax
  char *v8; // rax
  char *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  char v14; // [rsp+8h] [rbp-48h]
  unsigned int v15; // [rsp+Ch] [rbp-44h]
  unsigned int v16; // [rsp+28h] [rbp-28h]
  int v17; // [rsp+28h] [rbp-28h]
  unsigned int v18; // [rsp+28h] [rbp-28h]
  unsigned int v19; // [rsp+28h] [rbp-28h]
  unsigned int v20; // [rsp+2Ch] [rbp-24h]
  __int64 i; // [rsp+30h] [rbp-20h]
  __int64 j; // [rsp+38h] [rbp-18h]
  char *v23; // [rsp+40h] [rbp-10h]
  char *v24; // [rsp+48h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v16 = 0;
  if ( !*(_QWORD *)(a2 + 48) )
  {
    if ( *(_QWORD *)(a2 + 64) )
      result = sub_341EA(a1, *(_QWORD *)(a2 + 64), 2, *(_QWORD *)(a2 + 64), a5, a6);
    else
      result = 0LL;
    return result;
  }
  if ( a4 & 2 )
    v7 = "\n";
  else
    v7 = &byte_10CE4D;
  v24 = v7;
  v23 = v7;
  v20 = 2 * a3;
  if ( *(_BYTE *)a2 & 1 || *(_QWORD *)(a2 + 8) && **(_BYTE **)(a2 + 8) & 1 )
    v23 = &byte_10CE4D;
  if ( *(_QWORD *)(a2 + 8) && **(_BYTE **)(a2 + 8) & 1 )
  {
    v24 = &byte_10CE4D;
    v20 = 0;
  }
  if ( (_DWORD)a5 && a4 & 0x20 )
    v24 = &byte_10CE4D;
  if ( a4 & 0xD && !(a4 & 1) )
  {
    if ( a4 & 4 )
    {
      v20 = 0;
      goto LABEL_67;
    }
  }
  else if ( *(_QWORD *)(a2 + 56) && *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL) )
  {
    v16 = sub_C1FF7(
            a1,
            "%*s<%s:%s",
            v20,
            (__int64)&byte_10CE4D,
            *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL),
            *(_QWORD *)(a2 + 48));
  }
  else
  {
    v16 = sub_C1FF7(a1, "%*s<%s", v20, (__int64)&byte_10CE4D, *(_QWORD *)(a2 + 48), a6);
  }
  for ( i = *(_QWORD *)(a2 + 16); i; i = *(_QWORD *)(i + 8) )
  {
    if ( *(_DWORD *)i == 2 )
    {
      if ( *(_QWORD *)(i + 24) )
      {
        if ( *(_QWORD *)(i + 32) )
          v8 = *(char **)(i + 32);
        else
          v8 = &byte_10CE4D;
        v16 += sub_C1FF7(a1, " xmlns:%s=\"%s\"", *(_QWORD *)(i + 24), (__int64)v8, a5, a6);
      }
      else
      {
        if ( *(_QWORD *)(i + 32) )
          v9 = *(char **)(i + 32);
        else
          v9 = &byte_10CE4D;
        v16 += sub_C1FF7(a1, " xmlns=\"%s\"", (__int64)v9, a1, a5, a6);
      }
    }
    else if ( *(_QWORD *)(i + 16) && *(_QWORD *)(*(_QWORD *)(i + 16) + 24LL) )
    {
      v16 += sub_C1FF7(
               a1,
               " %s:%s=\"%s\"",
               *(_QWORD *)(*(_QWORD *)(i + 16) + 24LL),
               *(_QWORD *)(i + 24),
               *(_QWORD *)(i + 32),
               a6);
    }
    else
    {
      v16 += sub_C1FF7(a1, " %s=\"%s\"", *(_QWORD *)(i + 24), *(_QWORD *)(i + 32), a5, a6);
    }
  }
  if ( v14 & 4 && v14 & 1 )
    return (unsigned int)sub_C1FF7(a1, "/>%s", (__int64)v23, a4, a5, a6) + v16;
  if ( v14 & 1 )
  {
    sub_C1FF7(a1, ">", a3, a4, a5, a6);
    return v16 + 1;
  }
  if ( v14 & 8 )
    return v16;
  if ( !*(_QWORD *)(a2 + 24) && (!*(_QWORD *)(a2 + 64) || !**(_BYTE **)(a2 + 64)) )
    return (unsigned int)sub_C1FF7(a1, "/>%s", (__int64)v23, a4, a5, a6) + v16;
  if ( *(_QWORD *)(a2 + 64) && **(_BYTE **)(a2 + 64) )
  {
    sub_C1FF7(a1, ">", a3, a4, a5, a6);
    v17 = (unsigned __int64)sub_341EA(a1, *(_QWORD *)(a2 + 64), 2, *(_QWORD *)(a2 + 64), v10, v11) + v16 + 1;
    if ( *(_QWORD *)(a2 + 56) && *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL) )
      v18 = (unsigned __int64)sub_C1FF7(
                                a1,
                                "</%s:%s>%s",
                                *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL),
                                *(_QWORD *)(a2 + 48),
                                (__int64)v23,
                                v13)
          + v17;
    else
      v18 = (unsigned __int64)sub_C1FF7(a1, "</%s>%s", *(_QWORD *)(a2 + 48), (__int64)v23, v12, v13) + v17;
    return v18;
  }
  v16 += sub_C1FF7(a1, ">%s", (__int64)v23, a4, a5, a6);
  for ( j = *(_QWORD *)(a2 + 24); j; j = *(_QWORD *)(j + 32) )
  {
    if ( v14 & 2 )
      v16 += sub_3430E(a1, j, v15 + 1, 2LL, 0LL, 0LL);
    else
      v16 += sub_3430E(a1, j, v15, 0LL, 0LL, 0LL);
  }
LABEL_67:
  if ( *(_QWORD *)(a2 + 56) && *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL) )
    v19 = (unsigned __int64)sub_C1FF7(
                              a1,
                              "%*s</%s:%s>%s",
                              v20,
                              (__int64)&byte_10CE4D,
                              *(_QWORD *)(*(_QWORD *)(a2 + 56) + 24LL),
                              *(_QWORD *)(a2 + 48),
                              v24)
        + v16;
  else
    v19 = (unsigned __int64)sub_C1FF7(a1, "%*s</%s>%s", v20, (__int64)&byte_10CE4D, *(_QWORD *)(a2 + 48), (__int64)v24)
        + v16;
  return v19;
}

//----- (0000000000034926) ----------------------------------------------------
__int64  sub_34926(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // al
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  unsigned int v9; // [rsp+24h] [rbp-1Ch]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 j; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v9 = 0;
  if ( *(_QWORD *)(a2 + 8) )
  {
    i = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24LL);
  }
  else
  {
    for ( i = a2; *(_QWORD *)(i + 40) && *(_QWORD *)(*(_QWORD *)(i + 40) + 32LL); i = *(_QWORD *)(i + 40) )
      ;
  }
  for ( j = i; ; j = v12 )
  {
    if ( j )
    {
      v12 = *(_QWORD *)(j + 32);
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
      break;
    v9 += sub_3430E(a1, j, 0LL, v8, v12 == 0, a6);
  }
  return v9;
}

//----- (00000000000349F8) ----------------------------------------------------
__int64  lyxml_print_file(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+Ch] [rbp-64h]
  int s; // [rsp+20h] [rbp-50h]
  __int64 v11; // [rsp+28h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v12 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_file", a4, a5, a6);
  if ( !a1 || !a2 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 1;
  v11 = a1;
  if ( v9 & 0x10 )
    result = sub_34926((__int64)&s, a2, v9, a2, v7, v8);
  else
    result = sub_3430E((__int64)&s, a2, 0LL, v9, 1LL, v8);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034AC9) ----------------------------------------------------
__int64  lyxml_print_fd(int a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // [rsp+0h] [rbp-60h]
  unsigned int v10; // [rsp+8h] [rbp-58h]
  int s; // [rsp+10h] [rbp-50h]
  int v12; // [rsp+18h] [rbp-48h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v13 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_fd", a4, a5, a6, a2);
  if ( a1 < 0 || !v9 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 0;
  v12 = a1;
  if ( v10 & 0x10 )
    result = sub_34926((__int64)&s, v9, v10, v9, v7, v8);
  else
    result = sub_3430E((__int64)&s, v9, 0LL, v10, 1LL, v8);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034B96) ----------------------------------------------------
__int64  lyxml_print_mem(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+Ch] [rbp-74h]
  unsigned int v10; // [rsp+2Ch] [rbp-54h]
  int s; // [rsp+30h] [rbp-50h]
  __int64 v12; // [rsp+38h] [rbp-48h]
  unsigned __int64 v13; // [rsp+78h] [rbp-8h]

  v9 = a3;
  v13 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_mem", a4, a5, a6);
  if ( !a1 || !a2 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 2;
  if ( v9 & 0x10 )
    v10 = sub_34926((__int64)&s, a2, v9, a2, v7, v8);
  else
    v10 = sub_3430E((__int64)&s, a2, 0LL, v9, 1LL, v8);
  *a1 = v12;
  return v10;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034C73) ----------------------------------------------------
__int64  lyxml_print_clb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+4h] [rbp-6Ch]
  __int64 v10; // [rsp+8h] [rbp-68h]
  int s; // [rsp+20h] [rbp-50h]
  __int64 v12; // [rsp+28h] [rbp-48h]
  __int64 v13; // [rsp+30h] [rbp-40h]
  unsigned __int64 v14; // [rsp+68h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v14 = __readfsqword(0x28u);
  sub_12312(0x20u, (__int64)&off_10CCE0, (__int64)"lyxml_print_clb", a4, a5, a6);
  if ( !a1 || !v10 )
    return 0LL;
  memset(&s, 0, 0x40uLL);
  s = 3;
  v12 = a1;
  v13 = a2;
  if ( v9 & 0x10 )
    result = sub_34926((__int64)&s, v10, v9, v10, v7, v8);
  else
    result = sub_3430E((__int64)&s, v10, 0LL, v9, 1LL, v8);
  return result;
}
// 10CCE0: using guessed type void *off_10CCE0;

//----- (0000000000034D50) ----------------------------------------------------
_BOOL4  sub_34D50(__int64 a1)
{
  __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = a1;
  if ( !a1 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/parser.c", 0xCCu, "lyp_is_rpc_action");
  do
  {
    if ( !lys_parent(v2) )
      break;
    v2 = lys_parent(v2);
  }
  while ( *(_DWORD *)(v2 + 56) != 0x4000 );
  return (*(_DWORD *)(v2 + 56) & 0x4100) != 0;
}
// 7550: using guessed type __int64  lys_parent(_QWORD);

//----- (0000000000034DD2) ----------------------------------------------------
signed __int64  sub_34DD2(__int64 a1, unsigned int a2, __int64 a3)
{
  signed __int64 result; // rax
  unsigned int v4; // [rsp+14h] [rbp-1Ch]
  int v5; // [rsp+2Ch] [rbp-4h]

  v4 = a2;
  v5 = a2 & 0x10000FF;
  if ( a2 & 0x4000 && (v5 == 8 || v5 == 128) )
  {
    sub_12222(
      a1,
      0,
      3,
      "%s: Invalid options 0x%x (LYD_OPT_DATA_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG)",
      a3,
      a2);
    result = 1LL;
  }
  else if ( v4 & 0x30000 && v5 )
  {
    sub_12222(a1, 0, 3, "%s: Invalid options 0x%x (LYD_OPT_DATA_*_YANGLIB can be used only with LYD_OPT_DATA)", a3, a2);
    result = 1LL;
  }
  else if ( v5 && (!v5 || v5 & (v5 - 1)) )
  {
    sub_12222(a1, 0, 3, "%s: Invalid options 0x%x (multiple data type flags set).", a3, a2);
    result = 1LL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (0000000000034EE2) ----------------------------------------------------
signed __int64  sub_34EE2(__int64 a1, int a2, __int64 a3, size_t *a4, void **a5)
{
  __int64 v5; // r8
  __int64 v6; // r9
  int *v7; // rax
  char *v8; // rax
  __int64 v9; // r9
  signed __int64 result; // rax
  int *v11; // rax
  char *v12; // rax
  __int64 v13; // r9
  void **v14; // [rsp+8h] [rbp-D8h]
  size_t *v15; // [rsp+10h] [rbp-D0h]
  __int64 v16; // [rsp+18h] [rbp-C8h]
  unsigned __int64 v17; // [rsp+18h] [rbp-C8h]
  __int64 v18; // [rsp+30h] [rbp-B0h]
  struct stat stat_buf; // [rsp+40h] [rbp-A0h]
  unsigned __int64 v20; // [rsp+D8h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v20 = __readfsqword(0x28u);
  if ( a2 < 0 )
    __assert_fail("fd >= 0", "/home/mantovan/Repositories/libyang/src/parser.c", 0x102u, "lyp_mmap");
  if ( sub_107C00(a2, &stat_buf) == -1 )
  {
    v7 = __errno_location();
    v8 = strerror(*v7);
    sub_12222(a1, 0, 2, "Failed to stat the file descriptor (%s) for the mmap().", (__int64)v8, v9);
    result = 1LL;
  }
  else if ( (stat_buf.st_mode & 0xF000) == 0x8000 )
  {
    if ( stat_buf.st_size )
    {
      v18 = sysconf(30);
      v17 = v16 + 1;
      if ( stat_buf.st_size % v18 && v17 <= v18 - stat_buf.st_size % v18 )
      {
        *v15 = v17 + stat_buf.st_size;
        *v14 = mmap(0LL, *v15, 3, 2, a2, 0LL);
      }
      else
      {
        *v15 = stat_buf.st_size + v18;
        *v14 = mmap(0LL, *v15, 3, 34, -1, 0LL);
        *v14 = mmap(*v14, stat_buf.st_size, 3, 18, a2, 0LL);
      }
      if ( *v14 == (void *)-1LL )
      {
        v11 = __errno_location();
        v12 = strerror(*v11);
        sub_12222(a1, 0, 2, "mmap() failed (%s).", (__int64)v12, v13);
        result = 1LL;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      *v14 = 0LL;
      result = 0LL;
    }
  }
  else
  {
    sub_12222(a1, 0, 3, "File to mmap() is not a regular file.", v5, v6);
    result = 1LL;
  }
  return result;
}

//----- (00000000000351B4) ----------------------------------------------------
int  sub_351B4(void *a1, size_t a2)
{
  return munmap(a1, a2);
}

//----- (00000000000351D9) ----------------------------------------------------
_BOOL4  sub_351D9(__int64 a1)
{
  __int64 v1; // r9
  _BOOL4 result; // rax
  __int64 v3; // r9
  __int64 v4; // r9
  __int64 v5; // rbx
  __int64 v6; // r9
  _QWORD *v7; // rbx
  _QWORD *v8; // rbx
  _QWORD *v9; // rbx
  _QWORD *v10; // rbx
  _QWORD *v11; // rbx
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // rbx
  __int64 v15; // r9
  _QWORD *v16; // rbx
  _QWORD *v17; // rbx
  signed __int64 v18; // rbx
  __int64 v19; // r9
  void **v20; // rbx
  __int64 v21; // r9
  __int64 v22; // rbx
  __int64 v23; // r9
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9
  int i; // [rsp+14h] [rbp-3Ch]
  __int64 v28; // [rsp+18h] [rbp-38h]
  void *v29; // [rsp+20h] [rbp-30h]
  _QWORD *v30; // [rsp+28h] [rbp-28h]
  _QWORD *v31; // [rsp+28h] [rbp-28h]
  _QWORD *v32; // [rsp+28h] [rbp-28h]
  signed __int64 v33; // [rsp+30h] [rbp-20h]
  signed __int64 v34; // [rsp+30h] [rbp-20h]
  signed __int64 v35; // [rsp+30h] [rbp-20h]
  _DWORD *v36; // [rsp+38h] [rbp-18h]

  v28 = *(_QWORD *)a1;
  v29 = realloc(*(void **)(a1 + 160), 8LL * (*(unsigned __int8 *)(a1 + 80) + 3));
  if ( v29 )
  {
    *(_QWORD *)(a1 + 160) = v29;
    v30 = calloc(1uLL, 0x79uLL);
    if ( v30 )
    {
      *(_QWORD *)(8LL * *(unsigned __int8 *)(a1 + 80) + *(_QWORD *)(a1 + 160)) = v30;
      v30[2] = lydict_insert(v28, "operation", 9LL);
      *v30 = *(_QWORD *)(**(_QWORD **)(v28 + 64) + 152LL);
      *((_BYTE *)v30 + 30) = 1;
      v30[1] = a1;
      v30[6] = v30[1];
      *((_BYTE *)v30 + 29) = 0;
      v30[8] = *(_QWORD *)(*(_QWORD *)(*v30 + 56LL) + 40LL);
      *((_DWORD *)v30 + 14) = 0x10000;
      v33 = (signed __int64)(v30 + 9);
      v30[9] = calloc(1uLL, 0x40uLL);
      if ( v30[9] )
      {
        **(_DWORD **)v33 = 6;
        *(_QWORD *)(*(_QWORD *)v33 + 16LL) = qword_346FA0[6];
        *(_QWORD *)(*(_QWORD *)v33 + 24LL) = v30;
        *(_DWORD *)(*(_QWORD *)v33 + 40LL) = 5;
        v5 = *(_QWORD *)v33;
        *(_QWORD *)(v5 + 32) = calloc(5uLL, 0x30uLL);
        if ( *(_QWORD *)(*(_QWORD *)v33 + 32LL) )
        {
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 28LL) = 0;
          v7 = *(_QWORD **)(*(_QWORD *)v33 + 32LL);
          *v7 = lydict_insert(v28, "merge", 5LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 76LL) = 1;
          v8 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 48LL);
          *v8 = lydict_insert(v28, "replace", 7LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 124LL) = 2;
          v9 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 96LL);
          *v9 = lydict_insert(v28, "create", 6LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 172LL) = 3;
          v10 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 144LL);
          *v10 = lydict_insert(v28, "delete", 6LL);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 220LL) = 4;
          v11 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v33 + 32LL) + 192LL);
          *v11 = lydict_insert(v28, "remove", 6LL);
          ++*(_BYTE *)(a1 + 80);
          v31 = calloc(1uLL, 0x79uLL);
          if ( v31 )
          {
            *(_QWORD *)(8LL * *(unsigned __int8 *)(a1 + 80) + *(_QWORD *)(a1 + 160)) = v31;
            v31[2] = lydict_insert(v28, "type", 4LL);
            *v31 = *(_QWORD *)(**(_QWORD **)(v28 + 64) + 152LL);
            *((_BYTE *)v31 + 30) = 1;
            v31[1] = a1;
            v31[6] = v31[1];
            *((_BYTE *)v31 + 29) = 0;
            v31[8] = *(_QWORD *)(*(_QWORD *)(*v31 + 56LL) + 40LL);
            *((_DWORD *)v31 + 14) = 0x10000;
            v34 = (signed __int64)(v31 + 9);
            v31[9] = calloc(1uLL, 0x40uLL);
            if ( v31[9] )
            {
              **(_DWORD **)v34 = 6;
              *(_QWORD *)(*(_QWORD *)v34 + 16LL) = qword_346FA0[6];
              *(_QWORD *)(*(_QWORD *)v34 + 24LL) = v31;
              *(_DWORD *)(*(_QWORD *)v34 + 40LL) = 2;
              v14 = *(_QWORD *)v34;
              *(_QWORD *)(v14 + 32) = calloc(2uLL, 0x30uLL);
              if ( *(_QWORD *)(*(_QWORD *)v34 + 32LL) )
              {
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 28LL) = 0;
                v16 = *(_QWORD **)(*(_QWORD *)v34 + 32LL);
                *v16 = lydict_insert(v28, "subtree", 7LL);
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 76LL) = 1;
                v17 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 48LL);
                *v17 = lydict_insert(v28, "xpath", 5LL);
                for ( i = *(unsigned __int8 *)(a1 + 76); i > 0; --i )
                {
                  if ( !strcmp(*(const char **)(((signed __int64)i << 6) - 64 + *(_QWORD *)(a1 + 128)), "xpath") )
                  {
                    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 75LL) = 1;
                    v18 = *(_QWORD *)(*(_QWORD *)v34 + 32LL) + 48LL;
                    *(_QWORD *)(v18 + 40) = calloc(1uLL, 0x40uLL);
                    if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) )
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v19);
                      return 1LL;
                    }
                    v20 = *(void ***)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL);
                    *v20 = malloc(1uLL);
                    if ( !**(_QWORD **)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) )
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v21);
                      return 1LL;
                    }
                    ***(_BYTE ***)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) = 3;
                    v22 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL);
                    *(_QWORD *)(v22 + 16) = malloc(8uLL);
                    if ( !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) + 16LL) )
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v23);
                      return 1LL;
                    }
                    **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v34 + 32LL) + 88LL) + 16LL) = ((signed __int64)i << 6)
                                                                                                 - 64
                                                                                                 + *(_QWORD *)(a1 + 128);
                    break;
                  }
                }
                ++*(_BYTE *)(a1 + 80);
                v32 = calloc(1uLL, 0x79uLL);
                if ( v32 )
                {
                  *(_QWORD *)(8LL * *(unsigned __int8 *)(a1 + 80) + *(_QWORD *)(a1 + 160)) = v32;
                  v32[2] = lydict_insert(v28, "select", 6LL);
                  *v32 = *(_QWORD *)(**(_QWORD **)(v28 + 64) + 152LL);
                  *((_BYTE *)v32 + 30) = 1;
                  v32[1] = a1;
                  v32[6] = v32[1];
                  *((_BYTE *)v32 + 29) = 0;
                  v32[8] = *(_QWORD *)(*(_QWORD *)(*v32 + 56LL) + 40LL);
                  *((_DWORD *)v32 + 14) = 0x10000;
                  v35 = (signed __int64)(v32 + 9);
                  v32[9] = calloc(1uLL, 0x40uLL);
                  if ( v32[9] )
                  {
                    **(_DWORD **)v35 = 10;
                    *(_QWORD *)(*(_QWORD *)v35 + 16LL) = qword_346FA0[10];
                    *(_QWORD *)(*(_QWORD *)v35 + 24LL) = v32;
                    ++*(_BYTE *)(a1 + 80);
                    v36 = calloc(1uLL, 0x80uLL);
                    if ( v36 )
                    {
                      v36[14] = 32;
                      *((_QWORD *)v36 + 11) = v36;
                      *(_QWORD *)v36 = lydict_insert(v28, "config", 0LL);
                      *((_QWORD *)v36 + 6) = a1;
                      *((_WORD *)v36 + 12) = 1;
                      result = (unsigned int)sub_9C637(0LL, (_QWORD *)a1, (__int64)v36, 0) != 0;
                    }
                    else
                    {
                      sub_12222(
                        v28,
                        0,
                        1,
                        "Memory allocation failed (%s()).",
                        (__int64)"lyp_add_ietf_netconf_annotations_config",
                        v26);
                      result = 1LL;
                    }
                  }
                  else
                  {
                    sub_12222(
                      v28,
                      0,
                      1,
                      "Memory allocation failed (%s()).",
                      (__int64)"lyp_add_ietf_netconf_annotations_config",
                      v25);
                    result = 1LL;
                  }
                }
                else
                {
                  sub_12222(
                    v28,
                    0,
                    1,
                    "Memory allocation failed (%s()).",
                    (__int64)"lyp_add_ietf_netconf_annotations_config",
                    v24);
                  result = 1LL;
                }
              }
              else
              {
                sub_12222(
                  v28,
                  0,
                  1,
                  "Memory allocation failed (%s()).",
                  (__int64)"lyp_add_ietf_netconf_annotations_config",
                  v15);
                result = 1LL;
              }
            }
            else
            {
              sub_12222(
                v28,
                0,
                1,
                "Memory allocation failed (%s()).",
                (__int64)"lyp_add_ietf_netconf_annotations_config",
                v13);
              result = 1LL;
            }
          }
          else
          {
            sub_12222(
              v28,
              0,
              1,
              "Memory allocation failed (%s()).",
              (__int64)"lyp_add_ietf_netconf_annotations_config",
              v12);
            result = 1LL;
          }
        }
        else
        {
          sub_12222(
            v28,
            0,
            1,
            "Memory allocation failed (%s()).",
            (__int64)"lyp_add_ietf_netconf_annotations_config",
            v6);
          result = 1LL;
        }
      }
      else
      {
        sub_12222(v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_ietf_netconf_annotations_config", v4);
        result = 1LL;
      }
    }
    else
    {
      sub_12222(v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_ietf_netconf_annotations_config", v3);
      result = 1LL;
    }
  }
  else
  {
    sub_12222(v28, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_add_ietf_netconf_annotations_config", v1);
    result = 1LL;
  }
  return result;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);

//----- (0000000000035CB4) ----------------------------------------------------
signed __int64  sub_35CB4(const char *a1, __int64 a2, __int64 a3, int a4, __int64 *a5, char *a6)
{
  const char *v7; // rax
  char *v8; // [rsp+0h] [rbp-40h]
  __int64 *v9; // [rsp+8h] [rbp-38h]
  int base; // [rsp+14h] [rbp-2Ch]
  __int64 v11; // [rsp+18h] [rbp-28h]
  char *endptr; // [rsp+30h] [rbp-10h]
  unsigned __int64 v13; // [rsp+38h] [rbp-8h]

  v11 = a3;
  base = a4;
  v9 = a5;
  v8 = a6;
  v13 = __readfsqword(0x28u);
  if ( !a6 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/parser.c", 0x1B0u, "parse_int");
  if ( a1 )
  {
    if ( *a1 )
    {
      *__errno_location() = 0;
      endptr = 0LL;
      *v9 = strtoll(a1, &endptr, base);
      if ( !*__errno_location() && a2 <= *v9 && v11 >= *v9 )
      {
        if ( !endptr || !*endptr )
          return 0LL;
        while ( (*__ctype_b_loc())[*endptr] & 0x2000 )
          ++endptr;
        if ( !*endptr )
          return 0LL;
      }
    }
  }
  if ( a1 )
    v7 = a1;
  else
    v7 = (const char *)&unk_10DE4F;
  sub_13937(**(void ***)(*(_QWORD *)v8 + 48LL), 50, 3u, v8, (__int64)v7, **(_QWORD **)v8, v8);
  return 1LL;
}

//----- (0000000000035E42) ----------------------------------------------------
signed __int64  sub_35E42(const char *a1, unsigned __int64 a2, int a3, unsigned __int64 *a4, char *a5)
{
  const char *v6; // rax
  char *v7; // [rsp+8h] [rbp-48h]
  unsigned __int64 *v8; // [rsp+10h] [rbp-40h]
  int base; // [rsp+1Ch] [rbp-34h]
  char *endptr; // [rsp+38h] [rbp-18h]
  unsigned __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  base = a3;
  v8 = a4;
  v7 = a5;
  v12 = __readfsqword(0x28u);
  if ( !a5 )
    __assert_fail("node", "/home/mantovan/Repositories/libyang/src/parser.c", 0x1D8u, "parse_uint");
  if ( !a1 )
    goto LABEL_17;
  if ( !*a1 )
    goto LABEL_17;
  *__errno_location() = 0;
  endptr = 0LL;
  v11 = strtoull(a1, &endptr, base);
  if ( *__errno_location() || v11 > a2 )
    goto LABEL_17;
  if ( endptr && *endptr )
  {
    while ( (*__ctype_b_loc())[*endptr] & 0x2000 )
      ++endptr;
    if ( *endptr )
      goto LABEL_17;
LABEL_16:
    *v8 = v11;
    return 0LL;
  }
  if ( !v11 || *a1 != 45 )
    goto LABEL_16;
LABEL_17:
  if ( a1 )
    v6 = a1;
  else
    v6 = (const char *)&unk_10DE4F;
  sub_13937(**(void ***)(*(_QWORD *)v7 + 48LL), 50, 3u, v7, (__int64)v6, **(_QWORD **)v7);
  return 1LL;
}

//----- (0000000000035FD9) ----------------------------------------------------
signed __int64  sub_35FD9(char a1, unsigned __int64 a2, signed __int64 a3, signed __int64 a4, unsigned __int8 a5, __int64 a6, void *a7, char *a8)
{
  signed __int64 result; // rax
  void *v9; // rdx
  void *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  signed __int64 v14; // [rsp+20h] [rbp-60h]
  signed __int64 v15; // [rsp+28h] [rbp-58h]
  unsigned __int8 v16; // [rsp+38h] [rbp-48h]
  signed int v17; // [rsp+4Ch] [rbp-34h]
  void *ptr; // [rsp+50h] [rbp-30h]
  __int64 v19; // [rsp+58h] [rbp-28h]
  signed __int64 *v20; // [rsp+60h] [rbp-20h]
  __int64 v21; // [rsp+68h] [rbp-18h]
  void *v22; // [rsp+70h] [rbp-10h]
  unsigned __int64 v23; // [rsp+78h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v16 = a5;
  v23 = __readfsqword(0x28u);
  v19 = 0LL;
  ptr = 0LL;
  v22 = **(void ***)(*(_QWORD *)(a6 + 24) + 48LL);
  if ( (unsigned int)sub_1D702(v22, 0LL, a6, &ptr) )
  {
    sub_12222(
      (__int64)v22,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
      518LL);
    result = 1LL;
  }
  else if ( ptr )
  {
    v20 = (signed __int64 *)ptr;
    v21 = *((_QWORD *)ptr + 3);
    do
    {
      v17 = 0;
      while ( v20 && v21 == v20[3] )
      {
        if ( !v17 )
        {
          if ( !a1 && a2 < v20[1]
            || a1 == 1 && v15 < v20[1]
            || a1 == 2 && (signed int)sub_C508(v14, v16, v20[1], *(_BYTE *)(v21 + 40)) < 0 )
          {
            break;
          }
          if ( !a1 && a2 >= v20[1] && a2 <= v20[2]
            || a1 == 1 && v15 >= v20[1] && v15 <= v20[2]
            || a1 == 2
            && (signed int)sub_C508(v14, v16, v20[1], *(_BYTE *)(v21 + 40)) >= 0
            && (signed int)sub_C508(v14, v16, v20[2], *(_BYTE *)(v21 + 40)) <= 0 )
          {
            v17 = 1;
          }
        }
        v20 = (signed __int64 *)v20[4];
      }
      if ( !v17 )
        break;
      if ( v20 )
        v21 = v20[3];
    }
    while ( v20 );
    while ( ptr )
    {
      v20 = (signed __int64 *)*((_QWORD *)ptr + 4);
      free(ptr);
      ptr = v20;
    }
    if ( v17 )
    {
      result = 0LL;
    }
    else
    {
      switch ( *(_DWORD *)v21 )
      {
        case 1:
          v19 = *(_QWORD *)(v21 + 32);
          goto LABEL_42;
        case 4:
          v19 = *(_QWORD *)(v21 + 32);
          goto LABEL_42;
        case 0xA:
          v19 = *(_QWORD *)(v21 + 32);
          goto LABEL_42;
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
          v19 = *(_QWORD *)(v21 + 32);
LABEL_42:
          if ( v19 )
            v9 = *(void **)v19;
          else
            v9 = &unk_10DE4F;
          if ( a7 )
            v10 = a7;
          else
            v10 = &unk_10DE4F;
          sub_13937(v22, 54, 3u, a8, (__int64)v10, (__int64)v9);
          if ( v19 && *(_QWORD *)(v19 + 32) )
            sub_13C4A(v22, 5, *(char **)(v19 + 32), v11, v12, v13);
          if ( v19 )
          {
            if ( *(_QWORD *)(v19 + 24) )
              sub_14407((__int64)v22, *(const char **)(v19 + 24));
          }
          result = 1LL;
          break;
        default:
          sub_12222(
            (__int64)v22,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
            585LL);
          result = 1LL;
          break;
      }
    }
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (00000000000363C2) ----------------------------------------------------
signed __int64  sub_363C2(void *a1, char *a2, __int64 a3, char *a4)
{
  __int64 v5; // r9
  unsigned int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  char *v9; // [rsp+0h] [rbp-30h]
  __int64 v10; // [rsp+8h] [rbp-28h]
  char *s; // [rsp+10h] [rbp-20h]
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int j; // [rsp+28h] [rbp-8h]
  int v14; // [rsp+2Ch] [rbp-4h]

  s = a2;
  v10 = a3;
  v9 = a4;
  if ( !a1 || *(_DWORD *)a3 != 10 )
    __assert_fail(
      "ctx && (type->base == LY_TYPE_STRING)",
      "/home/mantovan/Repositories/libyang/src/parser.c",
      0x263u,
      "validate_pattern");
  if ( !a2 )
    s = (char *)&unk_10DE4F;
  if ( *(_QWORD *)(a3 + 16) && (unsigned int)sub_363C2(a1, s, *(_QWORD *)(a3 + 16) + 56LL, a4) )
    return 1LL;
  if ( !*(_QWORD *)(v10 + 56) && *(_DWORD *)(v10 + 48) )
  {
    *(_QWORD *)(v10 + 56) = malloc(8LL * (unsigned int)(2 * *(_DWORD *)(v10 + 48)));
    if ( !*(_QWORD *)(v10 + 56) )
    {
      sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"validate_pattern", v5, v9);
      return 0xFFFFFFFFLL;
    }
    for ( i = 0; i < *(_DWORD *)(v10 + 48); ++i )
    {
      if ( (unsigned int)sub_372F0(
                           a1,
                           (const char *)(*(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * i) + 1LL),
                           (void **)(*(_QWORD *)(v10 + 56) + 16LL * i),
                           (_QWORD *)(*(_QWORD *)(v10 + 56) + 8LL * (2 * i + 1))) )
        return 1LL;
    }
  }
  for ( j = 0; ; ++j )
  {
    if ( j >= *(_DWORD *)(v10 + 48) )
      return 0LL;
    v6 = strlen(s);
    v14 = pcre_exec(
            *(_QWORD *)(16LL * j + *(_QWORD *)(v10 + 56)),
            *(_QWORD *)(8LL * (2 * j + 1) + *(_QWORD *)(v10 + 56)),
            s,
            v6,
            0LL,
            0LL,
            0LL,
            0LL);
    if ( v14 )
    {
      if ( **(_BYTE **)(*(_QWORD *)(v10 + 40) + 56LL * j) == 6 )
        break;
    }
    if ( !v14 && **(_BYTE **)(*(_QWORD *)(v10 + 40) + 56LL * j) == 21 )
      break;
  }
  sub_13937(a1, 54, 3u, v9, (__int64)s, *(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * j) + 1LL, v9);
  if ( *(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * j + 32) )
    sub_13C4A(a1, 5, *(char **)(*(_QWORD *)(v10 + 40) + 56LL * j + 32), *(_QWORD *)(v10 + 40), v7, v8);
  if ( *(_QWORD *)(*(_QWORD *)(v10 + 40) + 56LL * j + 24) )
    sub_14407((__int64)a1, *(const char **)(*(_QWORD *)(v10 + 40) + 56LL * j + 24));
  return 1LL;
}
// 7500: using guessed type __int64  pcre_exec(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000036760) ----------------------------------------------------
char ** sub_36760(char *a1, char **a2, int a3)
{
  char **result; // rax
  int v4; // [rsp+Ch] [rbp-14h]
  char *v5; // [rsp+18h] [rbp-8h]
  char *i; // [rsp+18h] [rbp-8h]

  v5 = a1;
  v4 = a3;
  if ( (*__ctype_b_loc())[*a1] & 0x800 || *a1 == 45 || *a1 == 43 )
  {
    if ( *a1 == 45 || *a1 == 43 )
      v5 = a1 + 1;
    while ( (*__ctype_b_loc())[*v5] & 0x800 )
      ++v5;
    if ( v4 == 4 && *v5 == 46 && (*__ctype_b_loc())[v5[1]] & 0x800 )
    {
      for ( i = v5 + 1; (*__ctype_b_loc())[*i] & 0x800; ++i )
        ;
      result = a2;
      *a2 = i;
    }
    else
    {
      result = a2;
      *a2 = v5;
    }
  }
  else
  {
    result = a2;
    *a2 = a1;
  }
  return result;
}

//----- (0000000000036896) ----------------------------------------------------
__int64  sub_36896(void *a1, char *a2, int *a3)
{
  int *v4; // [rsp+8h] [rbp-48h]
  unsigned int v5; // [rsp+20h] [rbp-30h]
  signed int v6; // [rsp+24h] [rbp-2Ch]
  void *ptr; // [rsp+28h] [rbp-28h]
  char *v8; // [rsp+30h] [rbp-20h]
  char *s1; // [rsp+38h] [rbp-18h]
  void *v10; // [rsp+40h] [rbp-10h]
  unsigned __int64 v11; // [rsp+48h] [rbp-8h]

  v4 = a3;
  v11 = __readfsqword(0x28u);
  ptr = 0LL;
  s1 = a2;
  v5 = 1;
  v6 = 1;
  if ( !a2 )
    __assert_fail("expr", "/home/mantovan/Repositories/libyang/src/parser.c", 0x2C4u, "lyp_check_length_range");
  while ( 1 )
  {
    while ( (*__ctype_b_loc())[*s1] & 0x2000 )
      ++s1;
    if ( !strncmp(s1, "max", 3uLL) )
      break;
    if ( !strncmp(s1, "min", 3uLL) )
    {
      if ( !v6 )
        goto LABEL_55;
      v6 = 0;
      for ( s1 += 3; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
        ;
      if ( *s1 != 124 )
      {
        if ( !*s1 )
          goto LABEL_44;
        if ( strncmp(s1, "..", 2uLL) )
          goto LABEL_55;
        goto LABEL_21;
      }
      ++s1;
    }
    else
    {
      if ( !((*__ctype_b_loc())[*s1] & 0x800) && *s1 != 45 && *s1 != 43 )
        goto LABEL_55;
      sub_36760(s1, &v8, *v4);
      if ( s1 == v8 )
        goto LABEL_55;
      for ( s1 = v8; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
        ;
      if ( *s1 == 124 )
      {
        ++s1;
      }
      else
      {
        if ( !*s1 || strncmp(s1, "..", 2uLL) )
          goto LABEL_44;
LABEL_21:
        for ( s1 += 2; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
          ;
        if ( !*s1 )
          goto LABEL_55;
        if ( !strncmp(s1, "max", 3uLL) )
          break;
        sub_36760(s1, &v8, *v4);
        if ( s1 == v8 )
          goto LABEL_55;
        for ( s1 = v8; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
          ;
        if ( !*s1 )
          goto LABEL_44;
        if ( *s1 != 124 )
          goto LABEL_55;
        ++s1;
      }
    }
  }
  for ( s1 += 3; (*__ctype_b_loc())[*s1] & 0x2000; ++s1 )
    ;
  if ( *s1 )
    goto LABEL_55;
LABEL_44:
  if ( !(unsigned int)sub_1D702(a1, a2, (__int64)v4, &ptr) )
    v5 = 0;
LABEL_55:
  while ( ptr )
  {
    v10 = (void *)*((_QWORD *)ptr + 4);
    free(ptr);
    ptr = v10;
  }
  return v5;
}

//----- (0000000000036C95) ----------------------------------------------------
signed __int64  sub_36C95(void *a1, const char *a2, void **a3)
{
  size_t v3; // rax
  __int64 v4; // r9
  signed __int64 result; // rax
  size_t v6; // rax
  __int64 v7; // rax
  size_t v8; // rax
  __int64 v9; // rax
  size_t v10; // rax
  __int64 v11; // r9
  size_t v12; // rax
  size_t v13; // rax
  size_t v14; // rax
  void **v15; // [rsp+8h] [rbp-68h]
  int v16; // [rsp+28h] [rbp-48h]
  int j; // [rsp+2Ch] [rbp-44h]
  int v18; // [rsp+30h] [rbp-40h]
  int v19; // [rsp+34h] [rbp-3Ch]
  int v20; // [rsp+38h] [rbp-38h]
  int v21; // [rsp+3Ch] [rbp-34h]
  __int64 v22; // [rsp+40h] [rbp-30h]
  __int128 ptr; // [rsp+48h] [rbp-28h]
  const char *i; // [rsp+58h] [rbp-18h]
  void *v25; // [rsp+60h] [rbp-10h]
  unsigned __int64 v26; // [rsp+68h] [rbp-8h]

  v15 = a3;
  v26 = __readfsqword(0x28u);
  v19 = 0;
  for ( *((_QWORD *)&ptr + 1) = strchr(a2, 36);
        *((_QWORD *)&ptr + 1);
        *((_QWORD *)&ptr + 1) = strchr((const char *)(*((_QWORD *)&ptr + 1) + 1LL), 36) )
  {
    ++v19;
  }
  v3 = strlen(a2);
  ptr = (unsigned __int64)malloc(v3 + v19 + 4);
  if ( (_QWORD)ptr )
  {
    *(_BYTE *)ptr = 0;
    *((_QWORD *)&ptr + 1) = ptr;
    v6 = strlen(a2);
    if ( strncmp(&a2[v6 - 2], ".*", 2uLL) )
    {
      **((_BYTE **)&ptr + 1) = 40;
      ++*((_QWORD *)&ptr + 1);
    }
    for ( i = a2; *i; ++i )
    {
      if ( *i == 36 )
      {
        v7 = *((_QWORD *)&ptr + 1);
        **((_WORD **)&ptr + 1) = 9308;
        *(_BYTE *)(v7 + 2) = 0;
        *((_QWORD *)&ptr + 1) += 2LL;
      }
      else
      {
        **((_BYTE **)&ptr + 1) = *i;
        ++*((_QWORD *)&ptr + 1);
      }
    }
    v8 = strlen(a2);
    if ( !strncmp(&a2[v8 - 2], ".*", 2uLL) )
    {
      **((_BYTE **)&ptr + 1) = 0;
      ++*((_QWORD *)&ptr + 1);
    }
    else
    {
      v9 = *((_QWORD *)&ptr + 1);
      **((_WORD **)&ptr + 1) = 9257;
      *(_BYTE *)(v9 + 2) = 0;
      *((_QWORD *)&ptr + 1) += 2LL;
    }
    while ( 1 )
    {
      *((_QWORD *)&ptr + 1) = strstr((const char *)ptr, "\\p{Is");
      if ( !*((_QWORD *)&ptr + 1) )
        break;
      v20 = DWORD2(ptr) - ptr;
      *((_QWORD *)&ptr + 1) = strchr(*((const char **)&ptr + 1), 125);
      if ( !*((_QWORD *)&ptr + 1) )
      {
        sub_13937(a1, 35, 0, 0LL, (__int64)a2, v20 + 2LL + ptr, "unterminated character property");
        free((void *)ptr);
        return 1LL;
      }
      v21 = DWORD2(ptr) - ptr + 1;
      if ( v21 - v20 <= 18 )
      {
        v10 = strlen((const char *)ptr);
        *(_QWORD *)&ptr = sub_C422((void *)ptr, v10 + 19 - (v21 - v20) + 1);
        if ( !(_QWORD)ptr )
        {
          sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_check_pattern", v11);
          free(0LL);
          return 1LL;
        }
      }
      for ( j = 0; off_345BA0[2 * j]; ++j )
      {
        v12 = strlen(off_345BA0[2 * j]);
        if ( !strncmp((const char *)(ptr + v20 + 5LL), off_345BA0[2 * j], v12) )
          break;
      }
      if ( !off_345BA0[2 * j] )
      {
        sub_13937(a1, 35, 0, 0LL, (__int64)a2, v20 + 5LL + ptr, "unknown block name");
        free((void *)ptr);
        return 1LL;
      }
      v18 = 0;
      v19 = 0;
      while ( v18 < v20 )
      {
        if ( *(_BYTE *)(v18 + (_QWORD)ptr) == 91 && (!v18 || *(_BYTE *)(v18 - 1LL + ptr) != 92) )
          ++v19;
        if ( *(_BYTE *)(v18 + (_QWORD)ptr) == 93 && (!v18 || *(_BYTE *)(v18 - 1LL + ptr) != 92) )
          --v19;
        ++v18;
      }
      if ( v19 )
      {
        v13 = strlen((const char *)(v21 + (_QWORD)ptr));
        memmove((void *)(v20 + 17LL + ptr), (const void *)(ptr + v21), v13 + 1);
        memcpy((void *)(v20 + (_QWORD)ptr), off_345BA8[2 * j] + 1, 0x11uLL);
      }
      else
      {
        v14 = strlen((const char *)(v21 + (_QWORD)ptr));
        memmove((void *)(v20 + 19LL + ptr), (const void *)(ptr + v21), v14 + 1);
        memcpy((void *)(ptr + v20), off_345BA8[2 * j], 0x13uLL);
      }
    }
    v25 = (void *)pcre_compile(ptr, 4144LL, &v22, &v16, 0LL);
    if ( v25 )
    {
      free((void *)ptr);
      if ( v15 )
        *v15 = v25;
      else
        free(v25);
      result = 0LL;
    }
    else
    {
      sub_13937(a1, 35, 0, 0LL, (__int64)a2, v16 + (_QWORD)ptr, v22);
      free((void *)ptr);
      result = 1LL;
    }
  }
  else
  {
    sub_12222((__int64)a1, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_check_pattern", v4);
    result = 1LL;
  }
  return result;
}
// 7780: using guessed type __int64  pcre_compile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 345BA0: using guessed type char *off_345BA0[166];
// 345BA8: using guessed type char *off_345BA8[165];

//----- (00000000000372F0) ----------------------------------------------------
signed __int64  sub_372F0(void *a1, const char *a2, void **a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-30h]
  void **v6; // [rsp+8h] [rbp-28h]
  __int64 v7; // [rsp+20h] [rbp-10h]
  unsigned __int64 v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  v7 = 0LL;
  if ( (unsigned int)sub_36C95(a1, a2, a3) )
    return 1LL;
  if ( v5 && v6 )
  {
    *v5 = pcre_study(*v6, 0LL, &v7);
    if ( v7 )
      sub_12222((__int64)a1, 1u, 0, "Studying pattern \"%s\" failed (%s).", (__int64)a2, v7, v5);
  }
  return 0LL;
}
// 7A10: using guessed type __int64  pcre_study(_QWORD, _QWORD, _QWORD);

//----- (00000000000373C5) ----------------------------------------------------
signed __int64  sub_373C5(void *a1, unsigned int a2, const char **a3, char *a4, int *a5)
{
  void *v5; // rsp
  __int64 v6; // rbx
  char *v7; // r12
  size_t v8; // rax
  signed __int64 result; // rax
  unsigned int v10; // eax
  __int64 v11; // rax
  __int64 v12; // [rsp+0h] [rbp-B0h]
  int *v13; // [rsp+8h] [rbp-A8h]
  char *v14; // [rsp+10h] [rbp-A0h]
  const char **v15; // [rsp+18h] [rbp-98h]
  unsigned int v16; // [rsp+24h] [rbp-8Ch]
  void *v17; // [rsp+28h] [rbp-88h]
  unsigned __int8 v18; // [rsp+31h] [rbp-7Fh]
  unsigned __int16 v19; // [rsp+32h] [rbp-7Eh]
  int i; // [rsp+34h] [rbp-7Ch]
  int v21; // [rsp+38h] [rbp-78h]
  int v22; // [rsp+3Ch] [rbp-74h]
  char *s2; // [rsp+40h] [rbp-70h]
  __int64 v24; // [rsp+48h] [rbp-68h]
  char *s; // [rsp+50h] [rbp-60h]
  char *v26; // [rsp+58h] [rbp-58h]
  __int64 v27; // [rsp+60h] [rbp-50h]
  __int64 v28; // [rsp+68h] [rbp-48h]
  _QWORD *v29; // [rsp+70h] [rbp-40h]
  char *s1; // [rsp+78h] [rbp-38h]
  char *src; // [rsp+80h] [rbp-30h]
  unsigned __int64 v32; // [rsp+88h] [rbp-28h]

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v32 = __readfsqword(0x28u);
  v19 = 511;
  v24 = 511LL;
  v5 = alloca(512LL);
  s = (char *)&v12;
  v26 = 0LL;
  switch ( (unsigned __int64)a2 )
  {
    case 2uLL:
      v26 = v14;
      v22 = *v13;
      *s = 0;
      for ( i = 0; i < v22; ++i )
      {
        if ( *(_QWORD *)&v26[8 * i] )
        {
          if ( *s )
          {
            v6 = **(_QWORD **)&v26[8 * i];
            v7 = s;
            v8 = strlen(s);
            sprintf(&v7[v8], " %s", v6);
          }
          else
          {
            strcpy(s, **(const char ***)&v26[8 * i]);
          }
        }
      }
      goto LABEL_60;
    case 4uLL:
      v28 = *(_QWORD *)v14;
      v18 = *(_BYTE *)v13;
      if ( v28 )
      {
        v22 = sprintf(s, "%ld ", v28, a4, a5, 512LL);
        if ( v28 > 0 && v22 - 1 <= v18 || v22 - 2 <= v18 )
        {
          if ( v28 <= 0 )
            v10 = v18 + 2;
          else
            v10 = v18 + 1;
          v22 = sprintf(s, "%0*ld ", v10, v28);
        }
        i = v18;
        v21 = 1;
        while ( i > 0 )
        {
          if ( v21 && i > 1 && s[v22 - 2] == 48 )
          {
            s[v22 - 1] = 0;
          }
          else
          {
            v21 = 0;
            s[v22 - 1] = s[v22 - 2];
          }
          --v22;
          --i;
        }
        s[v22 - 1] = 46;
      }
      else
      {
        *(_DWORD *)s = 3157552;
      }
      goto LABEL_60;
    case 7uLL:
      s2 = v14;
      if ( strchr(*v15, 58) )
        strcpy(s, *v15);
      else
        sprintf(s, "%s:%s", s2, *v15);
      goto LABEL_60;
    case 8uLL:
      v29 = sub_CB4D2(v17, *v15);
      if ( !v29 )
      {
        sub_12222(
          (__int64)v17,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
          1028LL);
        return 0LL;
      }
      s2 = 0LL;
      v22 = 0;
      i = 0;
      break;
    case 0xCuLL:
    case 0xEuLL:
    case 0x10uLL:
    case 0x12uLL:
      v28 = *(_QWORD *)v14;
      sprintf(s, "%ld", v28, a4, a5, 512LL);
      goto LABEL_60;
    case 0xDuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x13uLL:
      v27 = *(_QWORD *)v14;
      sprintf(s, "%lu", v27, a4, a5, 512LL);
      goto LABEL_60;
    default:
      return 0LL;
  }
  while ( *((unsigned __int16 *)v29 + 16) > (unsigned int)i )
  {
    s1 = (char *)(v29[5] + *(unsigned __int16 *)(2LL * i + v29[1]));
    if ( i )
    {
      src = (char *)(v29[5]
                   + *(unsigned __int16 *)(2LL * i - 2 + v29[1])
                   + (unsigned __int64)*(unsigned __int16 *)(2LL * i - 2 + v29[2]));
      if ( src != s1 )
      {
        if ( v22 + s1 - src > v19 )
        {
          sub_12222(
            (__int64)v17,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
            1038LL);
          sub_C488D((__int64)v29);
          return 0LL;
        }
        strncpy(&s[v22], src, s1 - src);
        v22 += (_DWORD)s1 - (_DWORD)src;
      }
    }
    if ( *(_DWORD *)(4LL * i + *v29) == 9 && (src = sub_811F(s1, 58, *(unsigned __int16 *)(2LL * i + v29[2]))) != 0LL )
    {
      v21 = (_DWORD)++src - (_DWORD)s1;
      if ( !s2 || strncmp(s1, s2, v21) )
      {
        if ( v21 + v22 > v19 )
        {
          sub_12222(
            (__int64)v17,
            0,
            4,
            "Internal error (%s:%d).",
            (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
            1054LL);
          sub_C488D((__int64)v29);
          return 0LL;
        }
        strncpy(&s[v22], s1, v21);
        v22 += v21;
      }
      s2 = s1;
      if ( v22 + *(unsigned __int16 *)(2LL * i + v29[2]) - v21 > v19 )
      {
        sub_12222(
          (__int64)v17,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
          1065LL);
        sub_C488D((__int64)v29);
        return 0LL;
      }
      strncpy(&s[v22], src, *(unsigned __int16 *)(2LL * i + v29[2]) - v21);
      v22 += *(unsigned __int16 *)(2LL * i + v29[2]) - v21;
    }
    else
    {
      if ( v22 + *(unsigned __int16 *)(2LL * i + v29[2]) > v19 )
      {
        sub_12222(
          (__int64)v17,
          0,
          4,
          "Internal error (%s:%d).",
          (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
          1073LL);
        sub_C488D((__int64)v29);
        return 0LL;
      }
      strncpy(
        &s[v22],
        (const char *)(v29[5] + *(unsigned __int16 *)(2LL * i + v29[1])),
        *(unsigned __int16 *)(2LL * i + v29[2]));
      v22 += *(unsigned __int16 *)(2LL * i + v29[2]);
    }
    ++i;
  }
  if ( v22 <= v19 )
  {
    s[v22] = 0;
    sub_C488D((__int64)v29);
LABEL_60:
    if ( !strcmp(s, *v15) )
    {
      result = 0LL;
    }
    else
    {
      lydict_remove(v17, *v15);
      v11 = lydict_insert(v17, s, 0LL);
      *v15 = (const char *)v11;
      result = 1LL;
    }
  }
  else
  {
    sub_12222(
      (__int64)v17,
      0,
      4,
      "Internal error (%s:%d).",
      (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
      1082LL);
    sub_C488D((__int64)v29);
    result = 0LL;
  }
  return result;
}
// 7A00: using guessed type __int64  lydict_insert(_QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000037D41) ----------------------------------------------------
__int64  sub_37D41(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  __int64 v5; // [rsp+8h] [rbp-38h]
  __int64 v6; // [rsp+10h] [rbp-30h]
  char *ptr; // [rsp+20h] [rbp-20h]
  __int64 i; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v6 = a2;
  v5 = a3;
  v10 = __readfsqword(0x28u);
  do
  {
    for ( i = *(_QWORD *)(v6 + 16); i && (*(_DWORD *)i != 2 || *(_QWORD *)(i + 24)); i = *(_QWORD *)(i + 8) )
      ;
    if ( !i )
      v6 = *(_QWORD *)(v6 + 8);
  }
  while ( !i && v6 );
  if ( i )
  {
    v9 = ly_ctx_get_module_by_ns(a3, *(_QWORD *)(i + 32), 0LL, 1LL);
    if ( v9 )
    {
      if ( asprintf(&ptr, "%s:%s", *(_QWORD *)(v9 + 8), a1) == -1 )
      {
        sub_12222(v5, 0, 1, "Memory allocation failed (%s()).", (__int64)"ident_val_add_module_prefix", v4);
        result = 0LL;
      }
      else
      {
        lydict_remove(v5, a1);
        result = lydict_insert_zc(v5, ptr);
      }
    }
    else
    {
      sub_12222(
        v5,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
        1179LL);
      result = 0LL;
    }
  }
  else
  {
    sub_12222(a3, 0, 4, "Internal error (%s:%d).", (__int64)"/home/mantovan/Repositories/libyang/src/parser.c", 1172LL);
    result = 0LL;
  }
  return result;
}
// 71A0: using guessed type __int64  lydict_insert_zc(_QWORD, _QWORD);
// 7400: using guessed type __int64  ly_ctx_get_module_by_ns(_QWORD, _QWORD, _QWORD, _QWORD);
// 7C00: using guessed type __int64  lydict_remove(_QWORD, _QWORD);

//----- (0000000000037EF5) ----------------------------------------------------
signed __int64  sub_37EF5(signed __int64 a1, char **a2, __int64 a3, __int64 **a4, __int64 a5, __int64 *a6, int a7, int a8, int a9)
{
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // r9
  char *v12; // rax
  char *v13; // rax
  char *v14; // rax
  char *v15; // rax
  __int16 v16; // dx
  __int64 v17; // rax
  __int16 v18; // dx
  char *v19; // rbx
  unsigned __int64 v20; // rsi
  char *v21; // rax
  int v22; // esi
  int v23; // esi
  int v24; // esi
  int v25; // esi
  int v26; // esi
  int v27; // esi
  int v28; // esi
  int v29; // esi
  __int64 v30; // rax
  __int64 v31; // rax
  char *v32; // rax
  __int64 *v34; // [rsp+0h] [rbp-100h]
  int v35; // [rsp+8h] [rbp-F8h]
  __int64 **v36; // [rsp+10h] [rbp-F0h]
  __int64 v37; // [rsp+18h] [rbp-E8h]
  __int64 *v38; // [rsp+20h] [rbp-E0h]
  signed __int64 v39; // [rsp+28h] [rbp-D8h]
  char v40; // [rsp+33h] [rbp-CDh]
  int v41; // [rsp+34h] [rbp-CCh]
  int v42; // [rsp+38h] [rbp-C8h]
  int v43; // [rsp+3Ch] [rbp-C4h]
  int v44; // [rsp+40h] [rbp-C0h]
  int v45; // [rsp+44h] [rbp-BCh]
  unsigned int v46; // [rsp+48h] [rbp-B8h]
  unsigned int k; // [rsp+4Ch] [rbp-B4h]
  __int64 v48; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v49; // [rsp+58h] [rbp-A8h]
  char *s; // [rsp+60h] [rbp-A0h]
  char *s1; // [rsp+68h] [rbp-98h]
  void *v52; // [rsp+70h] [rbp-90h]
  __int64 v53; // [rsp+78h] [rbp-88h]
  __int64 l; // [rsp+80h] [rbp-80h]
  unsigned __int64 i; // [rsp+88h] [rbp-78h]
  size_t j; // [rsp+90h] [rbp-70h]
  __int64 v57; // [rsp+98h] [rbp-68h]
  __int64 v58; // [rsp+A0h] [rbp-60h]
  void *ptr; // [rsp+A8h] [rbp-58h]
  void *v60; // [rsp+B0h] [rbp-50h]
  int *v61; // [rsp+B8h] [rbp-48h]
  char *v62; // [rsp+C0h] [rbp-40h]
  char *v63; // [rsp+C8h] [rbp-38h]
  __int64 v64; // [rsp+D0h] [rbp-30h]
  void *v65; // [rsp+D8h] [rbp-28h]
  __int64 v66; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v67; // [rsp+E8h] [rbp-18h]

  v39 = a1;
  v38 = (__int64 *)a2;
  v37 = a3;
  v36 = a4;
  v35 = a5;
  v34 = a6;
  v67 = __readfsqword(0x28u);
  v64 = 0LL;
  v42 = 0;
  j = 0LL;
  s1 = *a2;
  v58 = 0LL;
  ptr = 0LL;
  v65 = **(void ***)(*(_QWORD *)(a1 + 24) + 48LL);
  if ( !a4 && !a5 )
    __assert_fail("leaf || attr", "/home/mantovan/Repositories/libyang/src/parser.c", 0x4C6u, "lyp_parse_value");
  if ( a4 )
  {
    if ( a5 )
      __assert_fail("!attr", "/home/mantovan/Repositories/libyang/src/parser.c", 0x4C9u, "lyp_parse_value");
    if ( !a6 )
      v34 = (__int64 *)(*a4)[6];
    v60 = a4 + 8;
    v61 = (int *)(a4 + 9);
    v62 = (char *)a4 + 76;
    v63 = (char *)a4;
    v57 = **a4;
  }
  else
  {
    if ( !a6 )
      v34 = *(__int64 **)(*(_QWORD *)(a5 + 16) + 48LL);
    v60 = (void *)(a5 + 40);
    v61 = (int *)(a5 + 48);
    v62 = (char *)(a5 + 52);
    v63 = *(char **)a5;
    v57 = *(_QWORD *)(a5 + 24);
  }
  if ( a7 )
  {
    v58 = lydict_insert(v65, *a2, 0LL);
    sub_BBE52(*(void **)v60, *v61, *v62, a1, v58, &v52, &v43, &v40);
    *v62 &= 0xFEu;
  }
  switch ( *(_DWORD *)a1 )
  {
    case 1:
      v49 = 0LL;
      s = 0LL;
      if ( s1 )
      {
        for ( i = 0LL; (*__ctype_b_loc())[s1[i]] & 0x2000; ++i )
          ;
        s = &s1[i];
        for ( j = strlen(&s1[i]); j && (*__ctype_b_loc())[s[j - 1]] & 0x2000; --j )
          ;
        v49 = j;
        for ( i = 0LL; i < j; ++i )
        {
          if ( s[i] == 10 )
          {
            --v49;
          }
          else if ( s[i] <= 46 && s[i] != 43 || s[i] > 57 && s[i] <= 64 || s[i] > 90 && s[i] <= 96 || s[i] > 122 )
          {
            if ( s[i] == 61 )
            {
              if ( i != j - 2 || s[i + 1] != 61 )
              {
                if ( i == j - 1 )
                  v42 = 1;
              }
              else
              {
                v42 = 2;
                ++i;
              }
            }
            if ( !v42 )
            {
              sub_13937(v65, 55, 3u, v63, (unsigned int)s[i], (__int64)&s[i], v34);
              sub_13937(v65, -1, 5u, 0LL, (__int64)"Invalid Base64 character.", v9);
              goto LABEL_349;
            }
          }
        }
      }
      if ( v49 & 3 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
        sub_13937(v65, -1, 5u, 0LL, (__int64)"Base64 encoded value length must be divisible by 4.", v10, v34);
        goto LABEL_349;
      }
      v45 = 3 * (v49 >> 2) - v42;
      if ( !a9 && (unsigned int)sub_35FD9(0, v45, 0LL, 0LL, 0, a1, s1, v63) )
        goto LABEL_349;
      if ( s1 && (s != s1 || s[j]) )
      {
        s = (char *)lydict_insert(v65, s, j);
        lydict_remove(v65, *a2);
        *a2 = s;
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = s1;
        *v61 = 1;
      }
      goto LABEL_340;
    case 2:
      while ( !*(_DWORD *)(v39 + 40) )
        v39 = *(_QWORD *)(v39 + 16) + 56LL;
      if ( s1 || a7 )
      {
        ptr = calloc(*(unsigned int *)(v39 + 40), 8uLL);
        if ( !ptr )
        {
          sub_12222((__int64)v65, 0, 1, "Memory allocation failed (%s()).", (__int64)"lyp_parse_value", v11, v34);
          goto LABEL_349;
        }
      }
      if ( s1 )
      {
        v44 = 0;
        v46 = 0;
        while ( 1 )
        {
          if ( !s1[v44] )
            goto LABEL_354;
          while ( (*__ctype_b_loc())[s1[v44]] & 0x2000 )
            ++v44;
          if ( !s1[v44] )
          {
LABEL_354:
            sub_373C5(v65, 2u, (const char **)a2, (char *)ptr, (int *)(v39 + 40));
            if ( a7 )
            {
              *(_QWORD *)v60 = ptr;
              *v61 = 2;
            }
            else
            {
              free(ptr);
            }
            goto LABEL_340;
          }
          v45 = 0;
          while ( s1[v44] && !((*__ctype_b_loc())[s1[v44]] & 0x2000) )
          {
            ++v44;
            ++v45;
          }
          v44 -= v45;
          v46 = 0;
          v42 = 0;
          while ( 1 )
          {
            if ( v46 >= *(_DWORD *)(v39 + 40) )
              goto LABEL_94;
            if ( !strncmp(*(const char **)(*(_QWORD *)(v39 + 32) + 48LL * v46), &s1[v44], v45)
              && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46) + v45) )
            {
              break;
            }
            ++v46;
          }
          for ( k = 0; !a9 && k < *(unsigned __int8 *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 27); ++k )
          {
            if ( !(unsigned int)sub_18D14(32LL * k + *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 40)) )
            {
              if ( v36 )
                sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
              else
                sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
              sub_13937(
                v65,
                -1,
                5u,
                0LL,
                (__int64)"Bit \"%s\" is disabled by its %d. if-feature condition.",
                *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46),
                k + 1);
              free(ptr);
              goto LABEL_349;
            }
          }
          if ( *((_QWORD *)ptr + v46) )
          {
            if ( v36 )
              sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
            else
              sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
            sub_13937(
              v65,
              -1,
              5u,
              0LL,
              (__int64)"Bit \"%s\" used multiple times.",
              *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46),
              v34);
            free(ptr);
            goto LABEL_349;
          }
          *((_QWORD *)ptr + v46) = *(_QWORD *)(v39 + 32) + 48LL * v46;
          v42 = 1;
LABEL_94:
          if ( !v42 )
          {
            if ( v36 )
              sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
            else
              sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
            free(ptr);
            goto LABEL_349;
          }
          v44 += v45;
        }
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = ptr;
        *v61 = 2;
      }
LABEL_340:
      if ( !a7 || !*(_QWORD *)(v39 + 16) || !*(_QWORD *)(*(_QWORD *)(v39 + 16) + 48LL) )
        goto LABEL_346;
      v44 = sub_C1B58(*(__int64 **)(*(_QWORD *)(v39 + 16) + 48LL), **(_BYTE ***)(v39 + 16), v38, (__int64)v60);
      if ( v44 == -1 )
        goto LABEL_349;
      if ( !v44 )
        *v62 |= 2u;
LABEL_346:
      if ( a7 )
      {
        sub_BBE52(v52, v43, v40, v39, v58, 0LL, 0LL, 0LL);
        lydict_remove(v65, v58);
      }
      return v39;
    case 3:
      if ( s1 && !strcmp(s1, "true") )
      {
        if ( a7 )
          *(_BYTE *)v60 = 1;
      }
      else
      {
        if ( !s1 || strcmp(s1, "false") )
        {
          if ( v36 )
          {
            if ( s1 )
              v12 = s1;
            else
              v12 = (char *)&unk_10DE4F;
            sub_13937(v65, 50, 3u, v63, (__int64)v12, v57, v34);
          }
          else
          {
            if ( s1 )
              v13 = s1;
            else
              v13 = (char *)&unk_10DE4F;
            sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, v13);
          }
          goto LABEL_349;
        }
        if ( a7 )
          *(_BYTE *)v60 = 0;
      }
      if ( a7 )
        *v61 = 3;
      goto LABEL_340;
    case 4:
      if ( !s1 || !*s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      s = s1;
      if ( (unsigned int)sub_16271(&s, *(_BYTE *)(a1 + 40), &v48) || *s )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
        goto LABEL_349;
      }
      if ( !a9 && (unsigned int)sub_35FD9(2, 0LL, 0LL, v48, *(_BYTE *)(a1 + 40), a1, s1, v63) )
        goto LABEL_349;
      sub_373C5(v65, 4u, (const char **)a2, (char *)&v48, (int *)(a1 + 40));
      if ( a7 )
      {
        *(_QWORD *)v60 = v48;
        *v61 = 4;
      }
      goto LABEL_340;
    case 5:
      if ( s1 && *s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
        goto LABEL_349;
      }
      if ( a7 )
        *v61 = 5;
      goto LABEL_340;
    case 6:
      while ( !*(_DWORD *)(v39 + 40) )
        v39 = *(_QWORD *)(v39 + 16) + 56LL;
      v42 = 0;
      v46 = 0;
      while ( 2 )
      {
        if ( v46 >= *(_DWORD *)(v39 + 40) )
          goto LABEL_163;
        if ( !s1 || strcmp(s1, *(const char **)(*(_QWORD *)(v39 + 32) + 48LL * v46)) )
        {
          ++v46;
          continue;
        }
        break;
      }
      k = 0;
      while ( 2 )
      {
        if ( !a9 && k < *(unsigned __int8 *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 27) )
        {
          if ( (unsigned int)sub_18D14(32LL * k + *(_QWORD *)(*(_QWORD *)(v39 + 32) + 48LL * v46 + 40)) )
          {
            ++k;
            continue;
          }
          if ( v36 )
            sub_13937(v65, 50, 3u, v63, (__int64)s1, v57, v34);
          else
            sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, s1);
          sub_13937(
            v65,
            -1,
            5u,
            0LL,
            (__int64)"Enum \"%s\" is disabled by its %d. if-feature condition.",
            (__int64)s1,
            k + 1);
          goto LABEL_349;
        }
        break;
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = *(_QWORD *)(v39 + 32) + 48LL * v46;
        *v61 = 6;
      }
      v42 = 1;
LABEL_163:
      if ( !v42 )
      {
        if ( v36 )
        {
          if ( s1 )
            v14 = s1;
          else
            v14 = (char *)&unk_10DE4F;
          sub_13937(v65, 50, 3u, v63, (__int64)v14, v57, v34);
        }
        else
        {
          if ( s1 )
            v15 = s1;
          else
            v15 = (char *)&unk_10DE4F;
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, v15);
        }
        goto LABEL_349;
      }
      goto LABEL_340;
    case 7:
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      if ( !v37 )
      {
        if ( a8 )
        {
          sub_141E4(0LL, 2u, &v41, 0LL);
          s1 = (char *)sub_9BED(v34, s1);
          sub_142D2(0LL, v41, 0LL, 0);
          if ( !s1 )
            s1 = (char *)lydict_insert(v65, *a2, 0LL);
        }
        else
        {
          s1 = (char *)lydict_insert(v65, *a2, 0LL);
        }
LABEL_190:
        v66 = sub_26148(a1, s1, v63, v34, a8);
        if ( !v66 )
        {
          lydict_remove(v65, s1);
          goto LABEL_349;
        }
        if ( a7 )
        {
          *(_QWORD *)v60 = v66;
          *v61 = 7;
        }
        if ( a8 )
        {
          v16 = *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL);
          HIBYTE(v16) |= 0x10u;
          *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL) = v16;
        }
        v17 = lys_main_module(v34);
        sub_373C5(v65, 7u, (const char **)&s1, *(char **)(v17 + 8), 0LL);
        lydict_remove(v65, *a2);
        *a2 = s1;
        goto LABEL_340;
      }
      sub_141E4(0LL, 2u, &v41, 0LL);
      s1 = (char *)sub_9A10((__int64)v65, s1, (char *)v37, 0, 0);
      sub_142D2(0LL, v41, 0LL, 0);
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)*a2, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *a2);
        goto LABEL_349;
      }
      if ( strchr(s1, 58) )
        goto LABEL_190;
      if ( !*(_QWORD *)(*(_QWORD *)(v37 + 56) + 24LL) )
        goto LABEL_190;
      s1 = (char *)sub_37D41((__int64)s1, v37, (__int64)v65);
      if ( s1 )
        goto LABEL_190;
LABEL_349:
      if ( a7 )
      {
        *(_QWORD *)v60 = v52;
        *v61 = v43;
        *v62 = v40;
        lydict_remove(v65, v58);
      }
      return 0LL;
    case 8:
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      if ( v37 )
      {
        sub_141E4(0LL, 2u, &v41, 0LL);
        s1 = (char *)sub_9A10((__int64)v65, s1, (char *)v37, 1u, 1u);
        sub_142D2(0LL, v41, 0LL, 0);
        if ( !s1 )
        {
          if ( v36 )
            sub_13937(v65, 50, 3u, v63, (__int64)*a2, v57, v34);
          else
            sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *a2);
          goto LABEL_349;
        }
        if ( *a2 == s1 )
          lydict_remove(v65, s1);
      }
      else if ( a8 )
      {
        sub_141E4(0LL, 2u, &v41, 0LL);
        s1 = (char *)sub_9BED(v34, s1);
        if ( s1 )
        {
          if ( *a2 == s1 )
            lydict_remove(v65, s1);
        }
        else
        {
          s1 = *a2;
        }
        sub_142D2(0LL, v41, 0LL, 0);
      }
      else if ( (unsigned int)sub_373C5(v65, 8u, (const char **)&s1, 0LL, 0LL) )
      {
        *a2 = s1;
      }
      if ( a7 )
      {
        *(_QWORD *)v60 = 0LL;
        *v61 = 8;
        *v62 |= 1u;
      }
      if ( *a2 != s1 )
      {
        lydict_remove(v65, *a2);
        *a2 = s1;
        if ( a8 )
        {
          v18 = *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL);
          HIBYTE(v18) |= 0x10u;
          *(_WORD *)(*(_QWORD *)(a1 + 24) + 24LL) = v18;
        }
      }
      goto LABEL_340;
    case 9:
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, (__int64)&unk_10DE4F, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, &unk_10DE4F);
        goto LABEL_349;
      }
      v53 = sub_37EF5(*(_DWORD *)(a1 + 40) + 128, (_DWORD)a2, v37, (_DWORD)v36, v35, 0, 0, 0, 0);
      s1 = *a2;
      if ( !v53 )
        goto LABEL_349;
      if ( a7 )
        *v62 |= 1u;
      v39 = v53;
      goto LABEL_340;
    case 0xA:
      if ( !a9 )
      {
        v19 = s1;
        v20 = s1 ? sub_C76D(s1) : 0LL;
        if ( (unsigned int)sub_35FD9(0, v20, 0LL, 0LL, 0, a1, v19, v63) )
          goto LABEL_349;
      }
      if ( !a9 && (unsigned int)sub_363C2(v65, s1, a1, v63) )
        goto LABEL_349;
      for ( l = *(_QWORD *)(a1 + 16);
            *(_QWORD *)(l + 48)
         && (strcmp(*(const char **)l, "xpath1.0")
          || strcmp(*(const char **)(*(_QWORD *)(l + 48) + 8LL), "ietf-yang-types"));
            l = *(_QWORD *)(l + 72) )
      {
        ;
      }
      if ( !*(_QWORD *)(l + 48) || !v37 )
        goto LABEL_252;
      if ( s1 )
        v21 = s1;
      else
        v21 = (char *)&unk_10DE4F;
      s1 = (char *)sub_9A10((__int64)v65, v21, (char *)v37, 1u, 1u);
      if ( !s1 )
      {
        if ( v36 )
          sub_13937(v65, 50, 3u, v63, *v38, v57, v34);
        else
          sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *v38);
        goto LABEL_349;
      }
      if ( (char *)*v38 != s1 )
      {
        lydict_remove(v65, *v38);
        *v38 = (__int64)s1;
      }
LABEL_252:
      if ( a7 )
      {
        *(_QWORD *)v60 = s1;
        *v61 = 10;
      }
      goto LABEL_340;
    case 0xB:
      if ( a7 )
      {
        memset(v60, 0, 8uLL);
        *v61 = 11;
      }
      if ( *(_DWORD *)(a1 + 44) )
      {
        if ( v37 )
        {
          sub_141E4(0LL, 2u, &v41, 0LL);
          v30 = sub_9A10((__int64)v65, s1, (char *)v37, 1u, 1u);
          *(_QWORD *)v60 = v30;
          sub_142D2(0LL, v41, 0LL, 0);
          if ( !*(_QWORD *)v60 )
          {
            v31 = lydict_insert(v65, s1, 0LL);
            *(_QWORD *)v60 = v31;
          }
        }
        goto LABEL_340;
      }
      v53 = 0LL;
      v42 = 0;
      sub_141E4(0LL, 2u, &v41, 0LL);
      while ( 2 )
      {
        v53 = sub_3A9DE(a1, v53, &v42);
        if ( v53 )
        {
          v42 = 0;
          v64 = sub_37EF5(v53, (_DWORD)a2, v37, (_DWORD)v36, v35, 0, 0, 0, 0);
          if ( !v64 )
          {
            if ( a7 )
            {
              sub_BBE52(*(void **)v60, *v61, *v62, v53, (__int64)*a2, 0LL, 0LL, 0LL);
              memset(v60, 0, 8uLL);
            }
            continue;
          }
          v39 = v64;
        }
        break;
      }
      sub_142D2(0LL, v41, 0LL, 0);
      if ( v53 )
        goto LABEL_340;
      if ( a7 )
        *v61 = 0;
      if ( v36 )
      {
        if ( *a2 )
          v32 = *a2;
        else
          v32 = (char *)&unk_10DE4F;
        sub_13937(v65, 50, 3u, v63, (__int64)v32, v57, v34);
      }
      else
      {
        sub_13937(v65, 51, 3u, v63, (__int64)"<none>", v57, *a2);
      }
      goto LABEL_349;
    case 0xC:
      if ( a8 )
        v22 = 0;
      else
        v22 = 10;
      if ( (unsigned int)sub_35CB4(s1, -128LL, 127LL, v22, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xCu, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_BYTE *)v60 = v48;
        *v61 = 12;
      }
      goto LABEL_340;
    case 0xD:
      if ( a8 )
        v26 = 0;
      else
        v26 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFuLL, v26, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xDu, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_BYTE *)v60 = v49;
        *v61 = 13;
      }
      goto LABEL_340;
    case 0xE:
      if ( a8 )
        v23 = 0;
      else
        v23 = 10;
      if ( (unsigned int)sub_35CB4(s1, -32768LL, 0x7FFFLL, v23, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xEu, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_WORD *)v60 = v48;
        *v61 = 14;
      }
      goto LABEL_340;
    case 0xF:
      if ( a8 )
        v27 = 0;
      else
        v27 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFFFuLL, v27, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0xFu, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_WORD *)v60 = v49;
        *v61 = 15;
      }
      goto LABEL_340;
    case 0x10:
      if ( a8 )
        v24 = 0;
      else
        v24 = 10;
      if ( (unsigned int)sub_35CB4(s1, -2147483648LL, 0x7FFFFFFFLL, v24, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x10u, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_DWORD *)v60 = v48;
        *v61 = 16;
      }
      goto LABEL_340;
    case 0x11:
      if ( a8 )
        v28 = 0;
      else
        v28 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFFFFFFFuLL, v28, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x11u, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_DWORD *)v60 = v49;
        *v61 = 17;
      }
      goto LABEL_340;
    case 0x12:
      if ( a8 )
        v25 = 0;
      else
        v25 = 10;
      if ( (unsigned int)sub_35CB4(s1, 0x8000000000000000LL, 0x7FFFFFFFFFFFFFFFLL, v25, &v48, v63)
        || !a9 && (unsigned int)sub_35FD9(1, 0LL, v48, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x12u, (const char **)v38, (char *)&v48, 0LL);
      if ( a7 )
      {
        *(_QWORD *)v60 = v48;
        *v61 = 18;
      }
      goto LABEL_340;
    case 0x13:
      if ( a8 )
        v29 = 0;
      else
        v29 = 10;
      if ( (unsigned int)sub_35E42(s1, 0xFFFFFFFFFFFFFFFFLL, v29, &v49, v63)
        || !a9 && (unsigned int)sub_35FD9(0, v49, 0LL, 0LL, 0, a1, s1, v63) )
      {
        goto LABEL_349;
      }
      sub_373C5(v65, 0x13u, (const char **)v38, (char *)&v49, 0LL);
      if ( a7 )
      {
        *(_QWORD *)v60 = v49;
        *v61 = 19;
      }
      goto LABEL_340;
    default:
      sub_12222(
        (__int64)v65,
        0,
        4,
        "Internal error (%s:%d).",
        (__int64)"/home/mantovan/Repositories/libyang/src/parser.c",
        1930LL,
        v34);
      goto LABEL_349;
  }
}
// 7950: using guessed type __int64  lys_main_module(_QWORD);
