/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_4B00();
__int64 __fastcall libssh2_channel_eof(_QWORD); // weak
// void *memset(void *s, int c, size_t n);
// __int64 DSA_new(void); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// __int64 __fastcall EVP_aes_128_ecb(_QWORD); weak
// int close(int fd);
// __int64 __fastcall inflateEnd(_QWORD); weak
// void *memchr(const void *s, int c, size_t n);
__int64 __fastcall libssh2_channel_free(_QWORD); // weak
// __int64 __fastcall EVP_PKEY_free(_QWORD, _QWORD); weak
__int64 __fastcall libssh2_agent_disconnect(_QWORD); // weak
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// __int64 __fastcall DSA_do_verify(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall deflate(_QWORD, _QWORD); weak
// __int64 __fastcall deflateInit_(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_CIPHER_CTX_init(_QWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void *malloc(size_t size);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
__int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD); // weak
// __int64 OPENSSL_add_all_algorithms_noconf(void); weak
// __int64 RSA_new(void); weak
// __int64 __fastcall RSA_free(_QWORD); weak
// __int64 __fastcall HMAC_CTX_cleanup(_QWORD); weak
// __int64 __fastcall EVP_ripemd160(_QWORD, _QWORD); weak
// char *fgets(char *s, int n, FILE *stream);
// __int64 __fastcall EVP_CipherInit(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_CIPHER_CTX_get_app_data(_QWORD); weak
// __int64 __fastcall BN_new(_QWORD, _QWORD); weak
// __int64 __fastcall PEM_read_bio_PrivateKey(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall DSA_do_sign(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall inflate(_QWORD, _QWORD); weak
// __int64 __fastcall EVP_PKEY_get1_DSA(_QWORD); weak
// void free(void *ptr);
// size_t strlen(const char *s);
// __int64 __fastcall HMAC_Init(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall deflateEnd(_QWORD); weak
__int64 __fastcall libssh2_publickey_list_free(_QWORD, _QWORD); // weak
__int64 __fastcall libssh2_sha1(_QWORD, _QWORD, _QWORD); // weak
// const unsigned __int16 **__ctype_b_loc(void);
// __int64 __fastcall EVP_PKEY_get1_RSA(_QWORD); weak
__int64 __fastcall libssh2_hostkey_methods(_QWORD); // weak
// __int64 __fastcall DSA_free(_QWORD); weak
// int sprintf(char *s, const char *format, ...);
// char *strrchr(const char *s, int c);
// __int64 __fastcall HMAC_Final(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall libssh2_keepalive_send(_QWORD, _QWORD); // weak
// __int64 __fastcall EVP_EncryptInit(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall BN_bn2bin(_QWORD, _QWORD); weak
__int64 __fastcall libssh2_session_block_directions(_QWORD); // weak
__int64 __fastcall libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD); // weak
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// __int64 __fastcall EVP_get_digestbyname(_QWORD); weak
// void rewind(FILE *stream);
__int64 __fastcall libssh2_channel_handle_extended_data2(_QWORD, _QWORD); // weak
// __int64 __fastcall EVP_EncryptUpdate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall EVP_DigestFinal(_QWORD, _QWORD, _QWORD); weak
// __int64 strtol(const char *nptr, char **endptr, int base);
__int64 __fastcall libssh2_session_banner_set(_QWORD, _QWORD); // weak
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __int64 __fastcall EVP_sha1(_QWORD, _QWORD); weak
// __int64 __fastcall RSA_size(_QWORD); weak
// __int64 __fastcall EVP_DigestInit(_QWORD, _QWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// char *strchr(const char *s, int c);
// int socket(int domain, int type, int protocol);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// __int64 __fastcall BN_rand(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall BIO_ctrl(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall DSA_SIG_free(_QWORD); weak
// int *__errno_location(void);
// __int64 __fastcall RAND_bytes(_QWORD, _QWORD); weak
// __int64 __fastcall BIO_free(_QWORD); weak
// __int64 __fastcall BIO_new_file(_QWORD, _QWORD); weak
// __int64 BN_CTX_new(void); weak
// __int64 __fastcall EVP_aes_256_ecb(_QWORD); weak
// __int64 __fastcall BN_CTX_free(_QWORD, _QWORD); weak
// int strcmp(const char *s1, const char *s2);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
__int64 __fastcall libssh2_crypt_methods(_QWORD); // weak
// __int64 __fastcall inflateInit_(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall BN_set_word(_QWORD, _QWORD); weak
// __int64 __fastcall EVP_Cipher(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_CIPHER_CTX_set_padding(_QWORD, _QWORD); weak
// __int64 __fastcall BN_clear_free(_QWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// __int64 __fastcall HMAC_Update(_QWORD, _QWORD, _QWORD); weak
// int feof(FILE *stream);
// __int64 __fastcall EVP_CIPHER_CTX_set_app_data(_QWORD, _QWORD); weak
// __int64 __fastcall EVP_md5(_QWORD, _QWORD); weak
// int fclose(FILE *stream);
__int64 __fastcall libssh2_init(_QWORD); // weak
// char *strncpy(char *dest, const char *src, size_t n);
// double difftime(time_t time1, time_t time0);
// __int64 __fastcall BN_num_bits(_QWORD); weak
// __int64 __fastcall RSA_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_CIPHER_CTX_cleanup(_QWORD); weak
// __int64 __fastcall EVP_get_cipherbyname(_QWORD, _QWORD); weak
// __int64 __fastcall BN_mod_exp(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 strtoll(const char *nptr, char **endptr, int base);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
__int64 __fastcall libssh2_poll_channel_read(_QWORD, _QWORD); // weak
// void *realloc(void *ptr, size_t size);
__int64 __fastcall libssh2_sftp_seek64(_QWORD, _QWORD); // weak
// __int64 __cdecl OpenSSL_add_all_ciphers(_QWORD); weak
// __int64 __fastcall RSA_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall libssh2_session_handshake(_QWORD, _QWORD); // weak
// __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_aes_192_ecb(_QWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int fcntl(int fd, int cmd, ...);
__int64 __fastcall libssh2_knownhost_readline(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// time_t time(time_t *timer);
// __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall _cxa_finalize(_QWORD); weak
char *start();
__int64 sub_52D0();
char *sub_5320();
__int64 sub_5360();
__int64 __fastcall sub_536A(__int64 a1);
__int64 __fastcall sub_53DD(__int64 a1, int a2);
__int64 __fastcall sub_54A5(size_t a1, const void *a2, unsigned int a3, int a4, int a5, void *a6, size_t a7);
__int64 __fastcall libssh2_channel_open_ex(size_t a1, const void *a2, unsigned int a3, int a4, int a5, void *a6, unsigned int a7);
__int64 __fastcall sub_5D16(size_t a1, const char *a2, int a3, char *a4, int a5);
__int64 __fastcall libssh2_channel_direct_tcpip_ex(size_t a1, const char *a2, int a3, char *a4, int a5);
void *__fastcall sub_5FE6(size_t a1, char *a2, int a3, _DWORD *a4, int a5);
void *__fastcall libssh2_channel_forward_listen_ex(size_t a1, char *a2, int a3, _DWORD *a4, int a5);
signed __int64 __fastcall sub_660F(__int64 a1);
signed __int64 __fastcall libssh2_channel_forward_cancel(__int64 a1);
_QWORD *__fastcall sub_692E(__int64 a1);
_QWORD *__fastcall libssh2_channel_forward_accept(__int64 a1, time_t a2);
signed __int64 __fastcall sub_6A90(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5);
signed __int64 __fastcall libssh2_channel_setenv_ex(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5);
__int64 __fastcall sub_6E9D(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6, int a7, int a8, int a9);
signed __int64 __fastcall libssh2_channel_request_pty_ex(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6, int a7, int a8, int a9);
__int64 __fastcall sub_7290(__int64 a1, int a2, int a3, int a4, int a5);
signed __int64 __fastcall libssh2_channel_request_pty_size_ex(__int64 a1, int a2, int a3, int a4, int a5);
__int64 __fastcall sub_7521(__int64 a1, int a2, const char *a3, char *a4, int a5);
signed __int64 __fastcall libssh2_channel_x11_req_ex(__int64 a1, int a2, const char *a3, char *a4, int a5);
__int64 __fastcall sub_7A37(__int64 a1, const void *a2, size_t a3, void *a4, size_t a5);
signed __int64 __fastcall libssh2_channel_process_startup(__int64 a1, const void *a2, unsigned int a3, void *a4, unsigned int a5);
__int64 __fastcall libssh2_channel_set_blocking(__int64 a1, int a2);
signed __int64 __fastcall sub_7E8C(__int64 a1, int a2);
signed __int64 __fastcall libssh2_channel_flush_ex(__int64 a1, int a2);
__int64 __fastcall libssh2_channel_get_exit_status(__int64 a1);
__int64 __fastcall libssh2_channel_get_exit_signal(__int64 a1, void **a2, size_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7);
__int64 __fastcall sub_82CF(__int64 a1, int a2, char a3, _DWORD *a4);
signed __int64 __fastcall libssh2_channel_receive_window_adjust(__int64 a1, int a2, char a3);
signed __int64 __fastcall libssh2_channel_receive_window_adjust2(__int64 a1, int a2, char a3, _DWORD *a4);
signed __int64 __fastcall sub_85E1(__int64 a1, int a2);
signed __int64 __fastcall libssh2_channel_handle_extended_data2(__int64 a1, int a2);
__int64 __fastcall libssh2_channel_handle_extended_data(__int64 a1, unsigned int a2);
__int64 __fastcall sub_86FF(__int64 a1, int a2, __int64 a3, int a4);
signed __int64 __fastcall libssh2_channel_read_ex(__int64 a1, int a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_8B22(__int64 a1, int a2);
signed __int64 __fastcall sub_8C41(__int64 a1, int a2, void *a3, unsigned __int64 a4);
signed __int64 __fastcall libssh2_channel_write_ex(__int64 a1, int a2, void *a3, unsigned __int64 a4);
__int64 __fastcall sub_8FF8(__int64 a1);
signed __int64 __fastcall libssh2_channel_send_eof(__int64 a1);
signed __int64 __fastcall libssh2_channel_eof(__int64 a1);
__int64 __fastcall sub_91E8(__int64 a1);
signed __int64 __fastcall libssh2_channel_wait_eof(__int64 a1);
__int64 __fastcall sub_92FA(__int64 a1);
signed __int64 __fastcall libssh2_channel_close(__int64 a1);
__int64 __fastcall sub_955A(__int64 a1);
signed __int64 __fastcall libssh2_channel_wait_closed(__int64 a1);
signed __int64 __fastcall sub_967C(__int64 a1);
signed __int64 __fastcall libssh2_channel_free(__int64 a1);
__int64 __fastcall libssh2_channel_window_read_ex(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall libssh2_channel_window_write_ex(__int64 a1, _QWORD *a2);
__int64 sub_9A7C();
__int64 __fastcall sub_9A9F(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_9AD8(__int64 a1, int a2, int a3);
__int64 __fastcall sub_9B11(__int64 a1, __int64 a2);
__int64 __fastcall sub_9B44(__int64 a1, int a2, _QWORD *a3);
__int64 __fastcall sub_9C4F(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, int a5, __int64 *a6);
__int64 __fastcall sub_9D04(__int64 a1, __int64 *a2, _QWORD *a3, int a4, __int64 a5, int a6, __int64 *a7);
__int64 __fastcall sub_A13A(__int64 a1, int a2, _QWORD *a3);
char ***__fastcall sub_A1A9(__int64 a1);
signed __int64 __fastcall sub_A1CE(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8);
_BOOL8 __fastcall sub_A29F(__int64 a1, void *a2, unsigned int **a3);
__int64 __fastcall sub_A2E2(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_A34D(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8);
char ***libssh2_crypt_methods();
signed __int64 __fastcall sub_A421(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_A57D(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_A61C(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 *a6);
signed __int64 __fastcall sub_A672(__int64 a1, _QWORD *a2, _QWORD *a3, int a4, __int64 a5, __int64 *a6);
__int64 __fastcall sub_A796(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_A7CF(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_A966(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_AA05(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6);
signed __int64 __fastcall sub_AA75(__int64 a1, void **a2, _QWORD *a3, int a4, __int64 a5, __int64 *a6);
__int64 __fastcall sub_AC01(__int64 a1, _QWORD *a2);
char ***libssh2_hostkey_methods();
signed __int64 __fastcall libssh2_hostkey_hash(__int64 a1, int a2);
signed __int64 __fastcall sub_AC80(const void *a1, unsigned __int64 a2);
__int64 __fastcall libssh2_session_hostkey(__int64 a1, _QWORD *a2, _DWORD *a3);
signed __int64 __fastcall sub_ADF9(size_t a1, signed __int64 a2, __int64 a3, unsigned int a4, char a5, unsigned __int8 a6, __int64 a7, __int64 a8, __int64 a9);
signed __int64 __fastcall sub_D237(size_t a1, __int64 a2);
signed __int64 __fastcall sub_D361(size_t a1, __int64 a2);
signed __int64 __fastcall sub_D48B(size_t a1, __int64 a2);
signed __int64 __fastcall sub_D7D9(const char ***a1);
signed __int64 __fastcall sub_D855(_BYTE *a1, __int64 a2, const char ***a3);
signed __int64 __fastcall sub_D912(__int64 a1);
char *__fastcall sub_E1C8(const char *a1, size_t a2, const char *a3, size_t a4);
const char **__fastcall sub_E2D9(const char *a1, size_t a2, const char ***a3);
signed __int64 __fastcall sub_E349(__int64 a1, char a2, const char *a3, size_t a4);
signed __int64 __fastcall sub_E553(__int64 a1, const char *a2, size_t a3, const char *a4, size_t a5);
signed __int64 __fastcall sub_E79F(__int64 a1, __int64 a2, const char *a3, size_t a4);
signed __int64 __fastcall sub_E92B(__int64 a1, __int64 a2, const char *a3, size_t a4);
signed __int64 __fastcall sub_EAB7(__int64 a1, __int64 a2, const char *a3, size_t a4);
signed __int64 __fastcall sub_EC4A(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_EFB4(size_t a1, int a2, _DWORD *a3);
__int64 __fastcall libssh2_session_method_pref(__int64 a1, unsigned int a2, const char *a3);
__int64 __fastcall libssh2_session_supported_algs(__int64 a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall sub_FA3B(__int64 a1, __int64 a2, _DWORD *a3, _QWORD *a4);
__int64 __fastcall sub_FA6B(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_FAB4(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64 __fastcall sub_FBED(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64 __fastcall sub_FC80(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64 __fastcall sub_FDB9(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64 __fastcall sub_FE4C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
char ***sub_FF85();
__int64 __fastcall sub_FF92(__int64 a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall sub_FFC2(int a1, void *a2, size_t a3, int a4);
ssize_t __fastcall sub_10024(int a1, const void *a2, size_t a3, int a4);
__int64 __fastcall sub_10071(unsigned int *a1);
unsigned __int64 __fastcall sub_100C0(unsigned __int8 *a1);
signed __int64 __fastcall sub_1017A(_BYTE *a1, int a2);
_QWORD *__fastcall sub_101C7(_BYTE **a1, int a2);
_QWORD *__fastcall sub_101FF(void **a1, const void *a2, size_t a3);
__int64 __fastcall libssh2_base64_decode(__int64 a1, _QWORD *a2, _DWORD *a3, unsigned __int8 *a4, int a5);
size_t __fastcall sub_104AE(__int64 a1, const char *a2, size_t a3, char **a4);
__int64 __fastcall libssh2_free(__int64 a1, __int64 a2);
__int64 libssh2_trace();
__int64 libssh2_trace_sethandler();
_QWORD *__fastcall sub_107E8(_QWORD *a1);
_QWORD *__fastcall sub_1080D(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_10877(__int64 a1);
__int64 __fastcall sub_10889(__int64 a1);
__int64 __fastcall sub_1089A(__int64 a1);
_QWORD *__fastcall sub_108AC(__int64 a1);
__int64 __fastcall sub_1091F(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_10F0B(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_113E1(size_t a1, unsigned __int8 *a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_12289(size_t n, char a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t na);
signed __int64 __fastcall sub_1238D(size_t a1, const char *a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t a7);
signed __int64 __fastcall sub_12422(size_t a1, unsigned __int8 a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t a7, __int64 a8);
signed __int64 __fastcall sub_1259A(size_t a1, _DWORD *a2);
signed __int64 __fastcall sub_12797(size_t a1, const char *a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t a7, time_t *a8);
__int64 __fastcall sub_12917(__int64 a1, __int64 a2, signed int a3);
signed __int64 __fastcall sub_129A0(__int64 a1, _QWORD *a2, _QWORD *a3);
signed __int64 __fastcall sub_12B89(unsigned int **a1, unsigned __int64 a2);
signed __int64 __fastcall sub_12C4E(__int64 a1);
__int64 __fastcall sub_12DB3(size_t a1);
__int64 __fastcall libssh2_publickey_init(size_t a1, time_t a2);
signed __int64 __fastcall libssh2_publickey_add_ex(__int64 a1, const void *a2, size_t a3, void *a4, size_t a5, char a6, unsigned __int64 a7, __int64 a8);
signed __int64 __fastcall libssh2_publickey_remove_ex(__int64 a1, const void *a2, size_t a3, void *a4, size_t a5);
__int64 __fastcall libssh2_publickey_list_fetch(__int64 a1, unsigned __int64 *a2, __int64 *a3);
__int64 __fastcall libssh2_publickey_list_free(__int64 a1, _QWORD *a2);
signed __int64 __fastcall libssh2_publickey_shutdown(__int64 *a1);
_BYTE *__fastcall sub_1523A(char *a1, _BYTE *a2, int a3);
__int64 __fastcall sub_15528(size_t a1, char *a2, void *a3);
__int64 __fastcall libssh2_scp_recv(size_t a1, char *a2, void *a3);
__int64 __fastcall sub_16592(size_t a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall libssh2_scp_send_ex(size_t a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall libssh2_scp_send64(size_t a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall sub_1708C(size_t a1);
void __fastcall sub_170AA(void *a1);
void *__fastcall sub_170C9(void *a1, size_t a2);
__int64 __fastcall sub_170F2(__int64 a1);
signed __int64 __fastcall sub_173B4(__int64 a1);
int __fastcall sub_17555(int a1, int a2);
signed __int64 __fastcall sub_175C1(int a1);
__int64 __fastcall libssh2_session_banner_set(__int64 a1, const char *a2);
__int64 __fastcall libssh2_banner_set(__int64 a1, __int64 a2);
void *__fastcall libssh2_session_init_ex(void *(__fastcall *a1)(size_t a1), void (__fastcall *a2)(void *a1), void *(__fastcall *a3)(void *a1, size_t a2), __int64 a4);
__int64 __fastcall libssh2_session_callback_set(_QWORD *a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall sub_179AF(__int64 a1, time_t a2);
signed __int64 __fastcall sub_17B9B(size_t a1, int a2);
__int64 __fastcall libssh2_session_handshake(size_t a1, int a2);
__int64 __fastcall libssh2_session_startup(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_18026(__int64 a1);
__int64 __fastcall libssh2_session_free(__int64 a1);
__int64 __fastcall sub_18ADA(__int64 a1, int a2, const char *a3, char *a4);
__int64 __fastcall libssh2_session_disconnect_ex(__int64 a1, int a2, const char *a3, char *a4);
void *__fastcall libssh2_session_methods(_QWORD *a1, unsigned int a2);
__int64 __fastcall libssh2_session_abstract(__int64 a1);
__int64 __fastcall libssh2_session_last_error(__int64 a1, void **a2, _DWORD *a3, int a4);
__int64 __fastcall libssh2_session_last_errno(__int64 a1);
signed __int64 __fastcall libssh2_session_flag(__int64 a1, int a2, int a3);
__int64 __fastcall sub_18FD5(__int64 a1, int a2);
__int64 __fastcall libssh2_session_set_blocking(__int64 a1, int a2);
__int64 __fastcall libssh2_session_get_blocking(__int64 a1);
__int64 __fastcall libssh2_session_set_timeout(__int64 a1, __int64 a2);
__int64 __fastcall libssh2_session_get_timeout(__int64 a1);
signed __int64 __fastcall libssh2_poll_channel_read(__int64 a1, int a2);
_BOOL8 __fastcall sub_19137(__int64 a1);
_BOOL8 __fastcall sub_19150(__int64 a1);
signed __int64 __fastcall libssh2_poll(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall libssh2_session_block_directions(__int64 a1);
__int64 __fastcall libssh2_session_banner_get(__int64 a1);
__int64 __fastcall sub_19B3E(char a1);
_QWORD *__fastcall sub_19B73(_BYTE **a1, __int64 a2);
__int64 __fastcall sub_19C36(__int64 a1, int a2);
__int64 __fastcall sub_19C87(__int64 a1, int a2);
__int64 __fastcall sub_19CE8(_QWORD *a1, int a2);
__int64 __fastcall sub_19D77(_QWORD *a1, unsigned __int8 *a2, __int64 a3);
signed __int64 __fastcall sub_19ECA(__int64 a1);
unsigned __int64 __fastcall sub_1A25F(__int64 a1);
signed __int64 __fastcall sub_1A3A2(__int64 a1, char a2, int a3, _QWORD *a4, _QWORD *a5);
signed __int64 __fastcall sub_1A483(__int64 a1, char a2, int a3, _QWORD *a4, _QWORD *a5);
signed __int64 __fastcall sub_1A52F(_QWORD *a1, int a2, __int64 a3, int a4, _QWORD *a5, _QWORD *a6);
__int64 __fastcall sub_1A681(_BYTE *a1, _QWORD *a2);
signed __int64 __fastcall sub_1A7DD(_QWORD *a1, unsigned int *a2);
__int64 __fastcall libssh2_sftp_dtor(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
void *__fastcall sub_1A9AA(size_t a1);
void *__fastcall libssh2_sftp_init(size_t a1, time_t a2);
__int64 __fastcall sub_1B092(__int64 *a1);
signed __int64 __fastcall libssh2_sftp_shutdown(__int64 *a1);
void *__fastcall sub_1B420(__int64 a1, const void *a2, size_t a3, int a4, __int64 a5, int a6);
void *__fastcall libssh2_sftp_open_ex(__int64 a1, const void *a2, unsigned int a3, int a4, __int64 a5, int a6);
size_t __fastcall sub_1BC9E(_QWORD *a1, void *a2, unsigned __int64 a3);
signed __int64 __fastcall libssh2_sftp_read(__int64 a1, void *a2, unsigned __int64 a3);
size_t __fastcall sub_1C5A0(__int64 a1, void *a2, unsigned __int64 a3, void *a4, unsigned __int64 a5, void *a6);
signed __int64 __fastcall libssh2_sftp_readdir_ex(__int64 a1, void *a2, unsigned __int64 a3, void *a4, unsigned __int64 a5, void *a6);
__int64 __fastcall sub_1CCE9(_QWORD *a1, char *a2, unsigned __int64 a3);
signed __int64 __fastcall libssh2_sftp_write(__int64 a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_1D343(_QWORD *a1, _QWORD *a2, int a3);
signed __int64 __fastcall libssh2_sftp_fstat_ex(__int64 a1, _QWORD *a2, int a3);
__int64 __fastcall libssh2_sftp_seek64(__int64 a1, __int64 a2);
__int64 __fastcall libssh2_sftp_seek(__int64 a1, __int64 a2);
__int64 __fastcall libssh2_sftp_tell(__int64 a1);
__int64 __fastcall libssh2_sftp_tell64(__int64 a1);
__int64 __fastcall sub_1D8FE(__int64 a1);
signed __int64 __fastcall sub_1D9F2(__int64 a1);
signed __int64 __fastcall libssh2_sftp_close_handle(__int64 a1);
__int64 __fastcall sub_1DE7B(__int64 a1, const void *a2, size_t a3);
signed __int64 __fastcall libssh2_sftp_unlink_ex(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall sub_1E200(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6);
signed __int64 __fastcall libssh2_sftp_rename_ex(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6);
signed __int64 __fastcall sub_1E6D4(_QWORD *a1, unsigned __int64 *a2);
signed __int64 __fastcall libssh2_sftp_fstatvfs(__int64 a1, unsigned __int64 *a2);
signed __int64 __fastcall sub_1EBD4(__int64 a1, const void *a2, unsigned int a3, unsigned __int64 *a4);
signed __int64 __fastcall libssh2_sftp_statvfs(__int64 a1, const void *a2, unsigned int a3, unsigned __int64 *a4);
__int64 __fastcall sub_1F0C7(__int64 a1, const void *a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall libssh2_sftp_mkdir_ex(__int64 a1, const void *a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_1F4FB(__int64 a1, const void *a2, unsigned int a3);
signed __int64 __fastcall libssh2_sftp_rmdir_ex(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall sub_1F881(__int64 a1, const void *a2, unsigned int a3, int a4, _QWORD *a5);
signed __int64 __fastcall libssh2_sftp_stat_ex(__int64 a1, const void *a2, unsigned int a3, int a4, _QWORD *a5);
signed __int64 __fastcall sub_1FCF8(__int64 a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, int a6);
signed __int64 __fastcall libssh2_sftp_symlink_ex(__int64 a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, int a6);
__int64 __fastcall libssh2_sftp_last_error(__int64 a1);
__int64 __fastcall libssh2_sftp_get_channel(__int64 *a1);
__int64 __fastcall sub_2024F(size_t a1, const void *a2, unsigned int a3);
__int64 __fastcall libssh2_userauth_list(size_t a1, const void *a2, unsigned int a3);
__int64 __fastcall libssh2_userauth_authenticated(__int64 a1);
__int64 __fastcall sub_206BA(size_t a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, void (__fastcall *a6)(size_t, size_t, size_t, size_t));
__int64 __fastcall libssh2_userauth_password_ex(size_t a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, void (__fastcall *a6)(size_t, size_t, size_t, size_t));
__int64 __fastcall sub_20F51(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, const char *a6);
__int64 __fastcall sub_212F3(__int64 a1, __int64 a2, _QWORD *a3, char *a4, int a5, __int64 a6, __int64 a7);
signed __int64 __fastcall sub_21402(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 **a6);
signed __int64 __fastcall sub_21541(size_t a1, const void *a2, size_t a3, const char *a4, __int64 a5, __int64 a6, const void *a7, size_t a8, const void *a9, size_t a10);
__int64 __fastcall libssh2_userauth_hostbased_fromfile_ex(size_t a1, const void *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6, const void *a7, unsigned int a8, const void *a9, unsigned int a10);
__int64 __fastcall sub_221CD(size_t a1, const void *a2, unsigned int a3, unsigned int *a4, unsigned __int64 a5, __int64 (__fastcall *a6)(size_t, const void **, size_t *, void *, signed __int64, __int64), __int64 a7);
__int64 __fastcall sub_22FBA(size_t a1, const void *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
__int64 __fastcall libssh2_userauth_publickey_fromfile_ex(size_t a1, const void *a2, unsigned int a3, const char *a4, __int64 a5, void *a6);
signed __int64 __fastcall libssh2_userauth_publickey(size_t a1, const char *a2, __int64 a3, __int64 a4, __int64 (__fastcall *a5)(size_t, const void **, size_t *, void *, signed __int64, __int64), __int64 a6);
signed __int64 __fastcall sub_23296(size_t a1, const void *a2, unsigned int a3, void (__fastcall *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, size_t));
__int64 __fastcall libssh2_userauth_keyboard_interactive_ex(size_t a1, const void *a2, unsigned int a3, void (__fastcall *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, size_t));
signed __int64 __fastcall sub_24087(__int64 a1, char *a2, char *a3, int a4);
__int64 __fastcall sub_24182(size_t a1, int a2);
signed __int64 __fastcall sub_2445D(size_t a1);
signed __int64 __fastcall sub_24BF5(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_24D86(__int64 a1, const void *a2, __int64 a3, void *a4, size_t a5);
const char *__fastcall libssh2_version(signed int a1);
__int64 __fastcall sub_2534B(__int64 a1, _QWORD *a2);
__int64 *__fastcall libssh2_knownhost_init(__int64 a1);
signed __int64 __fastcall sub_25492(__int64 a1);
__int64 __fastcall sub_25506(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, void *a6, __int64 a7, __int64 a8, signed __int64 *a9);
__int64 __fastcall libssh2_knownhost_add(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, unsigned int a6, signed __int64 *a7);
__int64 __fastcall libssh2_knownhost_addc(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, void *a6, __int64 a7, unsigned int a8, signed __int64 *a9);
signed __int64 __fastcall sub_25A13(__int64 *a1, char *a2, unsigned int a3, const char *a4, size_t a5, int a6, signed __int64 *a7);
signed __int64 __fastcall libssh2_knownhost_check(__int64 *a1, char *a2, const char *a3, size_t a4, int a5, signed __int64 *a6);
signed __int64 __fastcall libssh2_knownhost_checkp(__int64 *a1, char *a2, unsigned int a3, const char *a4, size_t a5, int a6, signed __int64 *a7);
__int64 __fastcall libssh2_knownhost_del(__int64 *a1, _QWORD *a2);
__int64 __fastcall libssh2_knownhost_free(__int64 *a1);
__int64 __fastcall sub_26051(__int64 *a1, char *a2, __int64 a3, char *a4, size_t a5, int a6, void *a7, __int64 a8);
__int64 __fastcall sub_26258(__int64 *a1, __int64 a2, __int64 a3, char *a4, size_t a5, int a6, void *a7, __int64 a8);
__int64 __fastcall sub_264AB(__int64 *a1, char *a2, unsigned __int64 a3, const char *a4, unsigned __int64 a5);
__int64 __fastcall libssh2_knownhost_readline(__int64 *a1, char *a2, unsigned __int64 a3, int a4);
__int64 __fastcall libssh2_knownhost_readfile(__int64 *a1, const char *a2, unsigned int a3);
__int64 __fastcall sub_26A02(__int64 *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6);
__int64 __fastcall libssh2_knownhost_writeline(__int64 *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6);
__int64 __fastcall libssh2_knownhost_writefile(__int64 *a1, const char *a2, int a3);
signed __int64 __fastcall libssh2_knownhost_get(__int64 a1, signed __int64 *a2, __int64 a3);
__int64 __fastcall sub_270EC(__int64 a1);
signed __int64 __fastcall sub_2722D(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_274E1(__int64 a1);
__int64 __fastcall sub_27528(__int64 a1, void **a2, size_t *a3, const void *a4, size_t a5, __int64 *a6);
__int64 __fastcall sub_27925(_QWORD *a1);
_QWORD *__fastcall sub_27CE5(_QWORD *a1);
signed __int64 __fastcall sub_27DAB(__int64 a1);
__int64 *__fastcall libssh2_agent_init(__int64 a1);
__int64 __fastcall libssh2_agent_connect(__int64 a1);
__int64 __fastcall libssh2_agent_list_identities(_QWORD *a1);
signed __int64 __fastcall libssh2_agent_get_identity(__int64 a1, signed __int64 *a2, __int64 a3);
__int64 __fastcall libssh2_agent_userauth(size_t *a1, const char *a2, _QWORD *a3);
__int64 __fastcall libssh2_agent_disconnect(__int64 a1);
__int64 __fastcall libssh2_agent_free(_QWORD *a1);
__int64 __fastcall sub_2815F(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, unsigned int a13, __int64 a14, unsigned int a15, __int64 a16, unsigned int a17);
signed __int64 __fastcall sub_2831E(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_283B8(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, __int64 a8, unsigned int a9, __int64 a10, __int64 a11);
signed __int64 __fastcall sub_284E6(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_285C3(__int64 a1, __int64 (*a2)(void), __int64 a3, __int64 a4, unsigned int a5);
_BOOL8 __fastcall sub_28618(__int64 a1, __int64 a2, __int64 a3, void *a4);
signed __int64 __fastcall sub_286B1(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_287D2(__int64 a1, _BYTE *a2, char *a3, __int64 a4);
signed __int64 __fastcall sub_2891D(__int64 a1);
__int64 __fastcall sub_28990(int a1, __int64 a2);
void *sub_289F2();
void *sub_28A1C();
void *sub_28A46();
void *sub_28A70();
__int64 __fastcall sub_28A86(void *a1, int a2, __int64 a3, const char *a4);
signed __int64 __fastcall sub_28AED(_QWORD *a1, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD, __int64), __int64 a3, __int64 a4);
signed __int64 __fastcall sub_28B82(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_28BC4(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_28C06(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5, _QWORD *a6);
signed __int64 __fastcall sub_28CF7(__int64 a1, __int64 a2, __int64 a3, char *a4);
unsigned __int64 __fastcall libssh2_sha1(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall libssh2_md5(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_28F3E(_BYTE *a1, __int64 a2, int a3);
_BYTE *__fastcall sub_28FD0(__int64 a1, __int64 a2, _QWORD *a3);
_BYTE *__fastcall sub_290FF(__int64 a1, __int64 *a2, _QWORD *a3);
__int64 __fastcall sub_292C2(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6);
__int64 __fastcall sub_2941D(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6);
__int64 __fastcall sub_29578(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6, __int64 a7);
__int64 __fastcall libssh2_keepalive_config(__int64 a1, int a2, int a3);
__int64 __fastcall libssh2_keepalive_send(__int64 a1, _DWORD *a2);
__int64 __fastcall libssh2_init(int a1);
__int64 libssh2_exit();
__int64 sub_29922();
void term_proc();
// __int64 _gmon_start__(void); weak
// __int64 ITM_deregisterTMCloneTable(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
__int64 qword_108 = 36LL; // weak
_UNKNOWN loc_10403; // weak
_UNKNOWN loc_13880; // weak
void *off_2A240 = (void *)0x6463LL; // weak
_UNKNOWN unk_2A8A0; // weak
_UNKNOWN unk_2A920; // weak
_WORD word_2AAE0[256] =
{
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  62,
  65535,
  65535,
  65535,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535
}; // idb
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
_UNKNOWN unk_2AE89; // weak
_UNKNOWN unk_2B716; // weak
_UNKNOWN unk_2BDCB; // weak
void *__ptr32 off_2C8AA = &loc_6566; // weak
_UNKNOWN unk_2CEE8; // weak
_UNKNOWN unk_2D527; // weak
_UNKNOWN unk_231960; // weak
char *off_2319C8[3] = { "success", &byte_7, (char *)1LL }; // idb
void *off_2323E0 = &off_2323E0; // weak
char **off_2323F0[2] = { &off_2316C0, &off_231680 }; // weak
char **off_232410 = &off_231680; // weak
char **off_232420[12] =
{
  &off_231AC0,
  &off_231B00,
  &off_231B40,
  &off_231C00,
  &off_231C40,
  &off_231BC0,
  &off_231B80,
  &off_231C80,
  &off_231D00,
  &off_231CC0,
  &off_231D40,
  &off_231D80
}; // weak
char **off_232490[2] = { &off_231700, &off_231740 }; // weak
char **off_2324C0[3] = { &off_2317A0, &off_2317C0, &off_231780 }; // weak
char **off_2324E0[6] = { &off_2317E0, &off_231820, &off_231860, &off_2318A0, &off_2318E0, &off_231920 }; // weak
char *off_232540 = "Unix"; // weak
__int64 (__fastcall *(*off_232548)[3])() = &off_232520; // weak
char byte_232560; // weak
_UNKNOWN unk_232580; // weak
int dword_232588; // weak
_UNKNOWN unk_2325E0; // weak
int dword_2325E8; // weak
_UNKNOWN unk_232640; // weak
int dword_232648; // weak
int dword_232698; // weak
int dword_23269C; // weak
// extern _UNKNOWN __cxa_finalize; weak
// extern _UNKNOWN PEM_read_bio_DSAPrivateKey; weak
// extern _UNKNOWN PEM_read_bio_RSAPrivateKey; weak


//----- (0000000000004AE0) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 232A10: using guessed type __int64 _gmon_start__(void);

//----- (0000000000004B00) ----------------------------------------------------
void sub_4B00()
{
  JUMPOUT(&dword_0);
}
// 0: using guessed type int dword_0;

//----- (0000000000005290) ----------------------------------------------------
char *start()
{
  char *result; // rax

  result = &byte_232560;
  if ( &byte_232560 != &byte_232560 )
  {
    result = (char *)&ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (char *)ITM_deregisterTMCloneTable();
  }
  return result;
}
// 232560: using guessed type char byte_232560;
// 232A18: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (00000000000052D0) ----------------------------------------------------
__int64 sub_52D0()
{
  return 0LL;
}

//----- (0000000000005320) ----------------------------------------------------
char *sub_5320()
{
  char *result; // rax

  if ( !byte_232560 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_2323E0);
    result = start();
    byte_232560 = 1;
  }
  return result;
}
// 5280: using guessed type __int64 __fastcall _cxa_finalize(_QWORD);
// 2323E0: using guessed type void *off_2323E0;
// 232560: using guessed type char byte_232560;

//----- (0000000000005360) ----------------------------------------------------
__int64 sub_5360()
{
  return sub_52D0();
}

//----- (000000000000536A) ----------------------------------------------------
__int64 __fastcall sub_536A(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  __int64 i; // [rsp+18h] [rbp-8h]

  v2 = *(_DWORD *)(a1 + 480);
  for ( i = sub_10877(a1 + 464); i; i = sub_10889(i) )
  {
    if ( v2 < *(_DWORD *)(i + 48) )
      v2 = *(_DWORD *)(i + 48);
  }
  *(_DWORD *)(a1 + 480) = v2 + 1;
  return v2;
}

//----- (00000000000053DD) ----------------------------------------------------
__int64 __fastcall sub_53DD(__int64 a1, int a2)
{
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 k; // [rsp+10h] [rbp-10h]
  __int64 j; // [rsp+18h] [rbp-8h]

  for ( i = sub_10877(a1 + 464); i; i = sub_10889(i) )
  {
    if ( a2 == *(_DWORD *)(i + 48) )
      return i;
  }
  for ( j = sub_10877(a1 + 488); j; j = sub_10889(j) )
  {
    for ( k = sub_10877(j + 48); k; k = sub_10889(k) )
    {
      if ( a2 == *(_DWORD *)(k + 48) )
        return k;
    }
  }
  return 0LL;
}

//----- (00000000000054A5) ----------------------------------------------------
__int64 __fastcall sub_54A5(size_t a1, const void *a2, unsigned int a3, int a4, int a5, void *a6, size_t a7)
{
  __int64 v8; // rbx
  _BYTE *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v13; // rbx
  void *v14; // [rsp+8h] [rbp-58h]
  int v15; // [rsp+14h] [rbp-4Ch]
  int v16; // [rsp+18h] [rbp-48h]
  unsigned int n; // [rsp+1Ch] [rbp-44h]
  unsigned int v18; // [rsp+34h] [rbp-2Ch]
  int v19; // [rsp+34h] [rbp-2Ch]
  _BYTE *v20; // [rsp+38h] [rbp-28h]
  char v21; // [rsp+44h] [rbp-1Ch]
  unsigned __int64 v22; // [rsp+48h] [rbp-18h]

  n = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v22 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53408) )
  {
    *(_QWORD *)(a1 + 53424) = 0LL;
    *(_QWORD *)(a1 + 53432) = 0LL;
    *(_QWORD *)(a1 + 53448) = 0LL;
    *(_QWORD *)(a1 + 53440) = a3 + 17;
    *(_DWORD *)(a1 + 53464) = sub_536A(a1);
    memset((void *)(a1 + 53416), 0, 8uLL);
    *(_QWORD *)(a1 + 53424) = (*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(688LL, a1);
    if ( !*(_QWORD *)(a1 + 53424) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate space for channel data");
      return 0LL;
    }
    memset(*(void **)(a1 + 53424), 0, 0x2B0uLL);
    *(_DWORD *)(*(_QWORD *)(a1 + 53424) + 32LL) = n;
    v8 = *(_QWORD *)(a1 + 53424);
    *(_QWORD *)(v8 + 24) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(n, a1);
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 53424) + 24LL) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Failed allocating memory for channel type name");
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53424), a1);
      *(_QWORD *)(a1 + 53424) = 0LL;
      return 0LL;
    }
    memcpy(*(void **)(*(_QWORD *)(a1 + 53424) + 24LL), a2, n);
    *(_DWORD *)(*(_QWORD *)(a1 + 53424) + 48LL) = *(_DWORD *)(a1 + 53464);
    *(_DWORD *)(*(_QWORD *)(a1 + 53424) + 76LL) = v16;
    *(_DWORD *)(*(_QWORD *)(a1 + 53424) + 72LL) = v16;
    *(_DWORD *)(*(_QWORD *)(a1 + 53424) + 80LL) = v15;
    *(_QWORD *)(*(_QWORD *)(a1 + 53424) + 96LL) = a1;
    sub_1080D((_QWORD *)(a1 + 464), *(_QWORD **)(a1 + 53424));
    *(_QWORD *)(a1 + 53432) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53440), a1);
    v20 = *(_BYTE **)(a1 + 53432);
    if ( !*(_QWORD *)(a1 + 53432) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate temporary space for packet");
      goto LABEL_23;
    }
    v9 = v20++;
    *v9 = 90;
    sub_101FF((void **)&v20, a2, n);
    sub_101C7(&v20, *(_DWORD *)(a1 + 53464));
    sub_101C7(&v20, v16);
    sub_101C7(&v20, v15);
    *(_DWORD *)(a1 + 53408) = 2;
  }
  if ( *(_DWORD *)(a1 + 53408) == 2 )
  {
    v18 = sub_24D86(a1, *(const void **)(a1 + 53432), *(_QWORD *)(a1 + 53440), v14, a7);
    if ( v18 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending channel-open request");
      return 0LL;
    }
    if ( v18 )
    {
      sub_FF92(a1, v18, (__int64)"Unable to send channel-open request");
      goto LABEL_23;
    }
    *(_DWORD *)(a1 + 53408) = 3;
  }
  if ( *(_DWORD *)(a1 + 53408) == 3 )
  {
    v19 = sub_12797(
            a1,
            "[\\",
            (_QWORD *)(a1 + 53448),
            (_QWORD *)(a1 + 53456),
            1,
            (void *)(*(_QWORD *)(a1 + 53432) + n + 5LL),
            4uLL,
            (time_t *)(a1 + 53416));
    if ( v19 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
      return 0LL;
    }
    if ( !v19 )
    {
      if ( **(_BYTE **)(a1 + 53448) == 91 )
      {
        v10 = *(_QWORD *)(a1 + 53424);
        *(_DWORD *)(v10 + 68) = sub_10071((unsigned int *)(*(_QWORD *)(a1 + 53448) + 5LL));
        v11 = *(_QWORD *)(a1 + 53424);
        *(_DWORD *)(v11 + 56) = sub_10071((unsigned int *)(*(_QWORD *)(a1 + 53448) + 9LL));
        v12 = *(_QWORD *)(a1 + 53424);
        *(_DWORD *)(v12 + 52) = sub_10071((unsigned int *)(*(_QWORD *)(a1 + 53448) + 9LL));
        v13 = *(_QWORD *)(a1 + 53424);
        *(_DWORD *)(v13 + 60) = sub_10071((unsigned int *)(*(_QWORD *)(a1 + 53448) + 13LL));
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
        *(_QWORD *)(a1 + 53432) = 0LL;
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53448), a1);
        *(_QWORD *)(a1 + 53448) = 0LL;
        *(_DWORD *)(a1 + 53408) = 0;
        return *(_QWORD *)(a1 + 53424);
      }
      if ( **(_BYTE **)(a1 + 53448) == 92 )
        sub_FF92(a1, 0xFFFFFFEB, (__int64)"Channel open failure");
    }
  }
LABEL_23:
  if ( *(_QWORD *)(a1 + 53448) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53448), a1);
    *(_QWORD *)(a1 + 53448) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 53432) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
    *(_QWORD *)(a1 + 53432) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 53424) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 53424) + 24LL), a1);
    sub_108AC(*(_QWORD *)(a1 + 53424));
    sub_1017A(&v21, *(_DWORD *)(*(_QWORD *)(a1 + 53424) + 48LL));
    while ( (signed int)sub_12289(a1, 94, (_QWORD *)(a1 + 53448), (_QWORD *)(a1 + 53456), 1, &v21, 4uLL) >= 0
         || (signed int)sub_12289(a1, 95, (_QWORD *)(a1 + 53448), (_QWORD *)(a1 + 53456), 1, &v21, 4uLL) >= 0 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53448), a1);
      *(_QWORD *)(a1 + 53448) = 0LL;
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53424), a1);
    *(_QWORD *)(a1 + 53424) = 0LL;
  }
  *(_DWORD *)(a1 + 53408) = 0;
  return 0LL;
}

//----- (0000000000005C63) ----------------------------------------------------
__int64 __fastcall libssh2_channel_open_ex(size_t a1, const void *a2, unsigned int a3, int a4, int a5, void *a6, unsigned int a7)
{
  void *v8; // [rsp+8h] [rbp-48h]
  int v9; // [rsp+14h] [rbp-3Ch]
  int v10; // [rsp+18h] [rbp-38h]
  unsigned int v11; // [rsp+1Ch] [rbp-34h]
  time_t v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  if ( !a1 )
    return 0LL;
  v12 = time(0LL);
  do
    v13 = sub_54A5(a1, a2, v11, v10, v9, v8, a7);
  while ( *(_DWORD *)(a1 + 148)
       && !v13
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v12) );
  return v13;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000005D16) ----------------------------------------------------
__int64 __fastcall sub_5D16(size_t a1, const char *a2, int a3, char *a4, int a5)
{
  __int64 result; // rax
  char *v6; // [rsp+0h] [rbp-40h]
  int v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+Ch] [rbp-34h]
  __int64 v9; // [rsp+28h] [rbp-18h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  v11 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53468) )
  {
    *(_QWORD *)(a1 + 53480) = strlen(a2);
    *(_QWORD *)(a1 + 53488) = strlen(v6);
    *(_QWORD *)(a1 + 53496) = *(_QWORD *)(a1 + 53480) + *(_QWORD *)(a1 + 53488) + 16LL;
    *(_QWORD *)(a1 + 53472) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53496), a1);
    v9 = *(_QWORD *)(a1 + 53472);
    if ( !*(_QWORD *)(a1 + 53472) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for direct-tcpip connection");
      return 0LL;
    }
    sub_101FF((void **)&v9, a2, *(_QWORD *)(a1 + 53480));
    sub_101C7((_BYTE **)&v9, v8);
    sub_101FF((void **)&v9, v6, *(_QWORD *)(a1 + 53488));
    sub_101C7((_BYTE **)&v9, v7);
  }
  v10 = sub_54A5(a1, "direct-tcpip", 0xCu, 0x40000, 0x8000, *(void **)(a1 + 53472), *(_QWORD *)(a1 + 53496));
  if ( v10 || (unsigned int)libssh2_session_last_errno(a1, "direct-tcpip") != -37 )
  {
    *(_DWORD *)(a1 + 53468) = 0;
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53472), a1);
    *(_QWORD *)(a1 + 53472) = 0LL;
    result = v10;
  }
  else
  {
    *(_DWORD *)(a1 + 53468) = 2;
    result = 0LL;
  }
  return result;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000005F46) ----------------------------------------------------
__int64 __fastcall libssh2_channel_direct_tcpip_ex(size_t a1, const char *a2, int a3, char *a4, int a5)
{
  char *v6; // [rsp+0h] [rbp-40h]
  int v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+Ch] [rbp-34h]
  time_t v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 0LL;
  v9 = time(0LL);
  do
    v10 = sub_5D16(a1, a2, v8, v6, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v10
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v9) );
  return v10;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000005FE6) ----------------------------------------------------
void *__fastcall sub_5FE6(size_t a1, char *a2, int a3, _DWORD *a4, int a5)
{
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  __int64 v8; // rax
  const char *v9; // rax
  int v10; // eax
  _DWORD *v11; // [rsp+0h] [rbp-50h]
  int v12; // [rsp+8h] [rbp-48h]
  int v13; // [rsp+Ch] [rbp-44h]
  char *s; // [rsp+10h] [rbp-40h]
  int v15; // [rsp+24h] [rbp-2Ch]
  int v16; // [rsp+24h] [rbp-2Ch]
  _BYTE *v17; // [rsp+28h] [rbp-28h]
  __int64 v18; // [rsp+30h] [rbp-20h]
  unsigned __int64 v19; // [rsp+38h] [rbp-18h]
  void *v20; // [rsp+40h] [rbp-10h]
  unsigned __int64 v21; // [rsp+48h] [rbp-8h]

  s = a2;
  v13 = a3;
  v11 = a4;
  v12 = a5;
  v21 = __readfsqword(0x28u);
  if ( !a2 )
    s = "0.0.0.0";
  if ( !*(_DWORD *)(a1 + 53504) )
  {
    *(_DWORD *)(a1 + 53520) = strlen(s);
    *(_DWORD *)(a1 + 53524) = *(_DWORD *)(a1 + 53520) + 27;
    memset((void *)(a1 + 53528), 0, 8uLL);
    *(_QWORD *)(a1 + 53512) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(unsigned int *)(a1 + 53524), a1);
    v17 = *(_BYTE **)(a1 + 53512);
    if ( !*(_QWORD *)(a1 + 53512) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memeory for setenv packet");
      return 0LL;
    }
    v6 = v17++;
    *v6 = 80;
    sub_101FF((void **)&v17, "tcpip-forward", 0xDuLL);
    v7 = v17++;
    *v7 = 1;
    sub_101FF((void **)&v17, s, *(unsigned int *)(a1 + 53520));
    sub_101C7(&v17, v13);
    *(_DWORD *)(a1 + 53504) = 2;
  }
  if ( *(_DWORD *)(a1 + 53504) == 2 )
  {
    v15 = sub_24D86(a1, *(const void **)(a1 + 53512), *(unsigned int *)(a1 + 53524), 0LL, 0LL);
    if ( v15 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending global-request packet for forward listen request");
      return 0LL;
    }
    if ( v15 )
    {
      sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send global-request packet for forward listen request");
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53512), a1);
      *(_QWORD *)(a1 + 53512) = 0LL;
      *(_DWORD *)(a1 + 53504) = 0;
      return 0LL;
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53512), a1);
    *(_QWORD *)(a1 + 53512) = 0LL;
    *(_DWORD *)(a1 + 53504) = 3;
  }
  if ( *(_DWORD *)(a1 + 53504) != 3 )
  {
LABEL_35:
    *(_DWORD *)(a1 + 53504) = 0;
    return 0LL;
  }
  v16 = sub_12797(a1, "QR", &v18, &v19, 0, 0LL, 0LL, (time_t *)(a1 + 53528));
  if ( v16 == -37 )
  {
    sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
    return 0LL;
  }
  if ( v16 )
  {
    sub_FF92(a1, 0xFFFFFFF2, (__int64)"Unknown");
    *(_DWORD *)(a1 + 53504) = 0;
    return 0LL;
  }
  if ( *(_BYTE *)v18 != 81 )
  {
    if ( *(_BYTE *)v18 == 82 )
    {
      (*(void (__fastcall **)(__int64, size_t))(a1 + 24))(v18, a1);
      sub_FF92(a1, 0xFFFFFFE0, (__int64)"Unable to complete request for forward-listen");
      *(_DWORD *)(a1 + 53504) = 0;
      return 0LL;
    }
    goto LABEL_35;
  }
  v20 = (void *)(*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(96LL, a1);
  if ( v20 )
  {
    memset(v20, 0, 0x60uLL);
    v8 = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))((unsigned int)(*(_DWORD *)(a1 + 53520) + 1), a1);
    *((_QWORD *)v20 + 4) = v8;
    if ( *((_QWORD *)v20 + 4) )
    {
      *((_QWORD *)v20 + 3) = a1;
      if ( s )
        v9 = s;
      else
        v9 = "0.0.0.0";
      memcpy(*((void **)v20 + 4), v9, *(unsigned int *)(a1 + 53520));
      *(_BYTE *)(*((_QWORD *)v20 + 4) + *(unsigned int *)(a1 + 53520)) = 0;
      if ( v19 <= 4 || v13 )
      {
        *((_DWORD *)v20 + 10) = v13;
      }
      else
      {
        v10 = sub_10071((unsigned int *)(v18 + 1));
        *((_DWORD *)v20 + 10) = v10;
      }
      *((_DWORD *)v20 + 16) = 0;
      *((_DWORD *)v20 + 17) = v12;
      sub_1080D((_QWORD *)(a1 + 488), v20);
      if ( v11 )
        *v11 = *((_DWORD *)v20 + 10);
    }
    else
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for listener queue");
      (*(void (__fastcall **)(void *, size_t))(a1 + 24))(v20, a1);
      v20 = 0LL;
    }
  }
  else
  {
    sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for listener queue");
  }
  (*(void (__fastcall **)(__int64, size_t))(a1 + 24))(v18, a1);
  *(_DWORD *)(a1 + 53504) = 0;
  return v20;
}

//----- (000000000000656F) ----------------------------------------------------
void *__fastcall libssh2_channel_forward_listen_ex(size_t a1, char *a2, int a3, _DWORD *a4, int a5)
{
  _DWORD *v6; // [rsp+0h] [rbp-40h]
  int v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+Ch] [rbp-34h]
  time_t v9; // [rsp+30h] [rbp-10h]
  void *v10; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 0LL;
  v9 = time(0LL);
  do
    v10 = sub_5FE6(a1, a2, v8, v6, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v10
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v9) );
  return v10;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000000660F) ----------------------------------------------------
signed __int64 __fastcall sub_660F(__int64 a1)
{
  char *v2; // rax
  char *v3; // rax
  int v4; // [rsp+1Ch] [rbp-44h]
  char *v5; // [rsp+20h] [rbp-40h]
  __int64 i; // [rsp+28h] [rbp-38h]
  char *v7; // [rsp+30h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-28h]
  size_t v9; // [rsp+40h] [rbp-20h]
  __int64 v10; // [rsp+48h] [rbp-18h]
  __int64 v11; // [rsp+50h] [rbp-10h]
  unsigned __int64 v12; // [rsp+58h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  v8 = *(_QWORD *)(a1 + 24);
  v9 = strlen(*(const char **)(a1 + 32));
  v10 = v9 + 34;
  if ( *(_DWORD *)(a1 + 72) )
  {
    v7 = *(char **)(a1 + 80);
  }
  else
  {
    v7 = (char *)(*(__int64 (__fastcall **)(__int64, __int64))(v8 + 8))(v10, v8);
    v5 = v7;
    if ( !v7 )
    {
      sub_FF92(v8, 0xFFFFFFFA, (__int64)"Unable to allocate memeory for setenv packet");
      return 4294967290LL;
    }
    v2 = v5++;
    *v2 = 80;
    sub_101FF((void **)&v5, "cancel-tcpip-forward", 0x14uLL);
    v3 = v5++;
    *v3 = 0;
    sub_101FF((void **)&v5, *(const void **)(a1 + 32), v9);
    sub_101C7(&v5, *(_DWORD *)(a1 + 40));
    *(_DWORD *)(a1 + 72) = 2;
  }
  if ( *(_DWORD *)(a1 + 72) == 2 )
  {
    v4 = sub_24D86(v8, v7, v10, 0LL, 0LL);
    if ( v4 == -37 )
    {
      sub_FF92(v8, 0xFFFFFFDB, (__int64)"Would block sending forward request");
      *(_QWORD *)(a1 + 80) = v7;
      return 4294967259LL;
    }
    if ( v4 )
    {
      sub_FF92(v8, 0xFFFFFFF9, (__int64)"Unable to send global-request packet for forward listen request");
      (*(void (__fastcall **)(char *, __int64))(v8 + 24))(v7, v8);
      *(_DWORD *)(a1 + 72) = 0;
      return 4294967289LL;
    }
    (*(void (__fastcall **)(char *, __int64))(v8 + 24))(v7, v8);
    *(_DWORD *)(a1 + 72) = 3;
  }
  for ( i = sub_10877(a1 + 48); i; i = v11 )
  {
    v11 = sub_10889(i);
    if ( (unsigned int)sub_967C(i) == -37 )
      return 4294967259LL;
  }
  (*(void (__fastcall **)(_QWORD, __int64))(v8 + 24))(*(_QWORD *)(a1 + 32), v8);
  sub_108AC(a1);
  (*(void (__fastcall **)(__int64, __int64))(v8 + 24))(a1, v8);
  *(_DWORD *)(a1 + 72) = 0;
  return 0LL;
}

//----- (00000000000068BA) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_forward_cancel(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_660F(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 24) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(a1 + 24), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (000000000000692E) ----------------------------------------------------
_QWORD *__fastcall sub_692E(__int64 a1)
{
  _QWORD *v1; // ST18_8
  _QWORD *result; // rax
  int v3; // [rsp+14h] [rbp-Ch]

  do
    v3 = sub_2445D(*(_QWORD *)(a1 + 24));
  while ( v3 > 0 );
  if ( sub_10877(a1 + 48) )
  {
    v1 = (_QWORD *)sub_10877(a1 + 48);
    sub_108AC((__int64)v1);
    --*(_DWORD *)(a1 + 64);
    sub_1080D((_QWORD *)(v1[12] + 464LL), v1);
    result = v1;
  }
  else
  {
    if ( v3 == -37 )
      sub_FF92(*(_QWORD *)(a1 + 24), 0xFFFFFFDB, (__int64)"Would block waiting for packet");
    else
      sub_FF92(*(_QWORD *)(a1 + 24), 0xFFFFFFE9, (__int64)"Channel not found");
    result = 0LL;
  }
  return result;
}

//----- (0000000000006A04) ----------------------------------------------------
_QWORD *__fastcall libssh2_channel_forward_accept(__int64 a1, time_t a2)
{
  time_t v3; // [rsp+20h] [rbp-10h]
  _QWORD *v4; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v3 = time(0LL);
  do
  {
    v4 = sub_692E(a1);
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 24) + 148LL) )
      break;
    if ( v4 )
      break;
    if ( (unsigned int)libssh2_session_last_errno(*(_QWORD *)(a1 + 24), a2) != -37 )
      break;
    a2 = v3;
  }
  while ( !(unsigned int)sub_179AF(*(_QWORD *)(a1 + 24), v3) );
  return v4;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000006A90) ----------------------------------------------------
signed __int64 __fastcall sub_6A90(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5)
{
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  const void *v8; // [rsp+0h] [rbp-50h]
  unsigned int v9; // [rsp+8h] [rbp-48h]
  unsigned int v10; // [rsp+Ch] [rbp-44h]
  int v11; // [rsp+24h] [rbp-2Ch]
  unsigned int v12; // [rsp+24h] [rbp-2Ch]
  _BYTE *v13; // [rsp+28h] [rbp-28h]
  _BYTE *v14; // [rsp+30h] [rbp-20h]
  char v15; // [rsp+38h] [rbp-18h]
  size_t v16; // [rsp+40h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v17 = __readfsqword(0x28u);
  v16 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 120) )
  {
    *(_QWORD *)(a1 + 136) = a3 + a5 + 21;
    memset((void *)(a1 + 152), 0, 8uLL);
    *(_QWORD *)(a1 + 128) = (*(__int64 (__fastcall **)(_QWORD, size_t))(v16 + 8))(*(_QWORD *)(a1 + 136), v16);
    v13 = *(_BYTE **)(a1 + 128);
    if ( !*(_QWORD *)(a1 + 128) )
      return sub_FF92(v16, 0xFFFFFFFA, (__int64)"Unable to allocate memeory for setenv packet");
    v6 = v13++;
    *v6 = 98;
    sub_101C7(&v13, *(_DWORD *)(a1 + 68));
    sub_101FF((void **)&v13, "env", 3uLL);
    v7 = v13++;
    *v7 = 1;
    sub_101FF((void **)&v13, a2, v10);
    sub_101FF((void **)&v13, v8, v9);
    *(_DWORD *)(a1 + 120) = 2;
  }
  if ( *(_DWORD *)(a1 + 120) == 2 )
  {
    v11 = sub_24D86(v16, *(const void **)(a1 + 128), *(_QWORD *)(a1 + 136), 0LL, 0LL);
    if ( v11 == -37 )
    {
      sub_FF92(v16, 0xFFFFFFDB, (__int64)"Would block sending setenv request");
      return 4294967259LL;
    }
    if ( v11 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(v16 + 24))(*(_QWORD *)(a1 + 128), v16);
      *(_QWORD *)(a1 + 128) = 0LL;
      *(_DWORD *)(a1 + 120) = 0;
      return sub_FF92(v16, 0xFFFFFFF9, (__int64)"Unable to send channel-request packet for setenv request");
    }
    (*(void (__fastcall **)(_QWORD, size_t))(v16 + 24))(*(_QWORD *)(a1 + 128), v16);
    *(_QWORD *)(a1 + 128) = 0LL;
    sub_1017A((_BYTE *)(a1 + 144), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 120) = 3;
  }
  if ( *(_DWORD *)(a1 + 120) == 3 )
  {
    v12 = sub_12797(v16, "cd", &v14, &v15, 1, (void *)(a1 + 144), 4uLL, (time_t *)(a1 + 152));
    if ( v12 == -37 )
      return 4294967259LL;
    if ( v12 )
    {
      *(_DWORD *)(a1 + 120) = 0;
      return v12;
    }
    if ( *v14 == 99 )
    {
      (*(void (__fastcall **)(_BYTE *, size_t))(v16 + 24))(v14, v16);
      *(_DWORD *)(a1 + 120) = 0;
      return 0LL;
    }
    (*(void (__fastcall **)(_BYTE *, size_t))(v16 + 24))(v14, v16);
  }
  *(_DWORD *)(a1 + 120) = 0;
  return sub_FF92(v16, 0xFFFFFFEA, (__int64)"Unable to complete request for channel-setenv");
}

//----- (0000000000006E09) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_setenv_ex(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5)
{
  const void *v6; // [rsp+0h] [rbp-30h]
  unsigned int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_6A90(a1, a2, v8, v6, v7);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = sub_179AF(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}

//----- (0000000000006E9D) ----------------------------------------------------
__int64 __fastcall sub_6E9D(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6, int a7, int a8, int a9)
{
  __int64 result; // rax
  _BYTE *v10; // rax
  int v11; // ST43_4
  int v12; // [rsp+Ch] [rbp-54h]
  const void *v13; // [rsp+10h] [rbp-50h]
  unsigned int v14; // [rsp+18h] [rbp-48h]
  unsigned int v15; // [rsp+1Ch] [rbp-44h]
  unsigned int v16; // [rsp+34h] [rbp-2Ch]
  int v17; // [rsp+34h] [rbp-2Ch]
  _BYTE *v18; // [rsp+38h] [rbp-28h]
  unsigned __int8 *v19; // [rsp+40h] [rbp-20h]
  char v20; // [rsp+48h] [rbp-18h]
  size_t v21; // [rsp+50h] [rbp-10h]
  unsigned __int64 v22; // [rsp+58h] [rbp-8h]

  v15 = a3;
  v13 = a4;
  v14 = a5;
  v12 = a6;
  v22 = __readfsqword(0x28u);
  v21 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 160) )
  {
    if ( a3 + a5 > 0x100 )
      return sub_FF92(v21, 0xFFFFFFDE, (__int64)"term + mode lengths too large");
    *(_QWORD *)(a1 + 464) = a3 + a5 + 41;
    memset((void *)(a1 + 480), 0, 8uLL);
    v18 = (_BYTE *)(a1 + 165);
    *(_BYTE *)(a1 + 164) = 98;
    sub_101C7(&v18, *(_DWORD *)(a1 + 68));
    sub_101FF((void **)&v18, "pty-req", 7uLL);
    v10 = v18++;
    *v10 = 1;
    sub_101FF((void **)&v18, a2, v15);
    sub_101C7(&v18, v12);
    sub_101C7(&v18, a7);
    sub_101C7(&v18, a8);
    sub_101C7(&v18, a9);
    sub_101FF((void **)&v18, v13, v14);
    *(_DWORD *)(a1 + 160) = 2;
  }
  if ( *(_DWORD *)(a1 + 160) == 2 )
  {
    v16 = sub_24D86(v21, (const void *)(a1 + 164), *(_QWORD *)(a1 + 464), 0LL, 0LL);
    if ( v16 == -37 )
    {
      sub_FF92(v21, 0xFFFFFFDB, (__int64)"Would block sending pty request");
      return 4294967259LL;
    }
    if ( v16 )
    {
      *(_DWORD *)(a1 + 160) = 0;
      return sub_FF92(v21, v16, (__int64)"Unable to send pty-request packet");
    }
    sub_1017A((_BYTE *)(a1 + 472), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 160) = 3;
  }
  if ( *(_DWORD *)(a1 + 160) != 3 )
    goto LABEL_21;
  v17 = sub_12797(v21, "cd", &v19, &v20, 1, (void *)(a1 + 472), 4uLL, (time_t *)(a1 + 480));
  if ( v17 == -37 )
    return 4294967259LL;
  if ( v17 )
  {
    *(_DWORD *)(a1 + 160) = 0;
    return sub_FF92(v21, 0xFFFFFFF2, (__int64)"Failed to require the PTY package");
  }
  v11 = *v19;
  (*(void (__fastcall **)(unsigned __int8 *, size_t))(v21 + 24))(v19, v21);
  *(_DWORD *)(a1 + 160) = 0;
  if ( (_BYTE)v11 != 99 )
LABEL_21:
    result = sub_FF92(v21, 0xFFFFFFEA, (__int64)"Unable to complete request for channel request-pty");
  else
    result = 0LL;
  return result;
}

//----- (00000000000071E2) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_request_pty_ex(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6, int a7, int a8, int a9)
{
  int v10; // [rsp+Ch] [rbp-34h]
  const void *v11; // [rsp+10h] [rbp-30h]
  unsigned int v12; // [rsp+18h] [rbp-28h]
  unsigned int v13; // [rsp+1Ch] [rbp-24h]
  unsigned int v14; // [rsp+34h] [rbp-Ch]
  time_t v15; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a4;
  v12 = a5;
  v10 = a6;
  if ( !a1 )
    return 4294967257LL;
  v15 = time(0LL);
  do
  {
    v14 = sub_6E9D(a1, a2, v13, v11, v12, v10, a7, a8, a9);
    if ( v14 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v14 = sub_179AF(*(_QWORD *)(a1 + 96), v15);
  }
  while ( !v14 );
  return v14;
}

//----- (0000000000007290) ----------------------------------------------------
__int64 __fastcall sub_7290(__int64 a1, int a2, int a3, int a4, int a5)
{
  _BYTE *v5; // rax
  int v7; // [rsp+8h] [rbp-38h]
  int v8; // [rsp+Ch] [rbp-34h]
  int v9; // [rsp+10h] [rbp-30h]
  unsigned int v10; // [rsp+20h] [rbp-20h]
  unsigned int v11; // [rsp+24h] [rbp-1Ch]
  _BYTE *v12; // [rsp+28h] [rbp-18h]
  __int64 v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  v13 = *(_QWORD *)(a1 + 96);
  v10 = -14;
  if ( !*(_DWORD *)(a1 + 160) )
  {
    *(_QWORD *)(a1 + 464) = 39LL;
    memset((void *)(a1 + 480), 0, 8uLL);
    v12 = (_BYTE *)(a1 + 165);
    *(_BYTE *)(a1 + 164) = 98;
    sub_101C7(&v12, *(_DWORD *)(a1 + 68));
    sub_101FF((void **)&v12, "window-change", 0xDuLL);
    v5 = v12++;
    *v5 = 0;
    sub_101C7(&v12, a2);
    sub_101C7(&v12, v9);
    sub_101C7(&v12, v8);
    sub_101C7(&v12, v7);
    *(_DWORD *)(a1 + 160) = 2;
  }
  if ( *(_DWORD *)(a1 + 160) == 2 )
  {
    v11 = sub_24D86(v13, (const void *)(a1 + 164), *(_QWORD *)(a1 + 464), 0LL, 0LL);
    if ( v11 == -37 )
    {
      sub_FF92(v13, 0xFFFFFFDB, (__int64)"Would block sending window-change request");
      return 4294967259LL;
    }
    if ( v11 )
    {
      *(_DWORD *)(a1 + 160) = 0;
      return sub_FF92(v13, v11, (__int64)"Unable to send window-change packet");
    }
    sub_1017A((_BYTE *)(a1 + 472), *(_DWORD *)(a1 + 48));
    v10 = 0;
  }
  *(_DWORD *)(a1 + 160) = 0;
  return v10;
}

//----- (0000000000007491) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_request_pty_size_ex(__int64 a1, int a2, int a3, int a4, int a5)
{
  int v6; // [rsp+8h] [rbp-28h]
  int v7; // [rsp+Ch] [rbp-24h]
  int v8; // [rsp+10h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_7290(a1, a2, v8, v7, v6);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = sub_179AF(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}

//----- (0000000000007521) ----------------------------------------------------
__int64 __fastcall sub_7521(__int64 a1, int a2, const char *a3, char *a4, int a5)
{
  size_t v5; // rax
  size_t v6; // rax
  __int64 result; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  const char *v11; // rax
  char v12; // ST37_1
  char *v13; // [rsp+0h] [rbp-80h]
  char *s; // [rsp+8h] [rbp-78h]
  int v15; // [rsp+10h] [rbp-70h]
  signed int i; // [rsp+28h] [rbp-58h]
  unsigned int v17; // [rsp+2Ch] [rbp-54h]
  unsigned int v18; // [rsp+2Ch] [rbp-54h]
  void *dest; // [rsp+30h] [rbp-50h]
  char v20; // [rsp+38h] [rbp-48h]
  char *v21; // [rsp+40h] [rbp-40h]
  size_t v22; // [rsp+48h] [rbp-38h]
  size_t v23; // [rsp+50h] [rbp-30h]
  size_t n; // [rsp+58h] [rbp-28h]
  char v25[24]; // [rsp+60h] [rbp-20h]
  unsigned __int64 v26; // [rsp+78h] [rbp-8h]

  s = (char *)a3;
  v13 = a4;
  v15 = a5;
  v26 = __readfsqword(0x28u);
  v22 = *(_QWORD *)(a1 + 96);
  if ( a3 )
    v5 = strlen(a3);
  else
    v5 = 18LL;
  v23 = v5;
  if ( v13 )
    v6 = strlen(v13);
  else
    v6 = 32LL;
  n = v6;
  if ( !*(_DWORD *)(a1 + 488) )
  {
    *(_QWORD *)(a1 + 504) = v23 + n + 30;
    memset((void *)(a1 + 520), 0, 8uLL);
    *(_QWORD *)(a1 + 496) = (*(__int64 (__fastcall **)(_QWORD, size_t))(v22 + 8))(*(_QWORD *)(a1 + 504), v22);
    dest = *(void **)(a1 + 496);
    if ( !*(_QWORD *)(a1 + 496) )
      return sub_FF92(v22, 0xFFFFFFFA, (__int64)"Unable to allocate memory for pty-request");
    v8 = dest;
    dest = (char *)dest + 1;
    *v8 = 98;
    sub_101C7((_BYTE **)&dest, *(_DWORD *)(a1 + 68));
    sub_101FF(&dest, "x11-req", 7uLL);
    v9 = dest;
    dest = (char *)dest + 1;
    *v9 = 1;
    v10 = dest;
    dest = (char *)dest + 1;
    *v10 = a2 != 0;
    if ( s )
      v11 = s;
    else
      v11 = "MIT-MAGIC-COOKIE-1";
    sub_101FF(&dest, v11, v23);
    sub_101C7((_BYTE **)&dest, n);
    if ( v13 )
    {
      memcpy(dest, v13, n);
    }
    else
    {
      RAND_bytes(v25, 16LL);
      for ( i = 0; i <= 15; ++i )
        sprintf((char *)dest + 2 * i, "%02X", (unsigned __int8)v25[i]);
    }
    dest = (char *)dest + n;
    sub_101C7((_BYTE **)&dest, v15);
    *(_DWORD *)(a1 + 488) = 2;
  }
  if ( *(_DWORD *)(a1 + 488) == 2 )
  {
    v17 = sub_24D86(v22, *(const void **)(a1 + 496), *(_QWORD *)(a1 + 504), 0LL, 0LL);
    if ( v17 == -37 )
    {
      sub_FF92(v22, 0xFFFFFFDB, (__int64)"Would block sending X11-req packet");
      return 4294967259LL;
    }
    if ( v17 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(v22 + 24))(*(_QWORD *)(a1 + 496), v22);
      *(_QWORD *)(a1 + 496) = 0LL;
      *(_DWORD *)(a1 + 488) = 0;
      return sub_FF92(v22, v17, (__int64)"Unable to send x11-req packet");
    }
    (*(void (__fastcall **)(_QWORD, size_t))(v22 + 24))(*(_QWORD *)(a1 + 496), v22);
    *(_QWORD *)(a1 + 496) = 0LL;
    sub_1017A((_BYTE *)(a1 + 512), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 488) = 3;
  }
  if ( *(_DWORD *)(a1 + 488) != 3 )
    goto LABEL_35;
  v18 = sub_12797(v22, "cd", &v21, &v20, 1, (void *)(a1 + 512), 4uLL, (time_t *)(a1 + 520));
  if ( v18 == -37 )
    return 4294967259LL;
  if ( v18 )
  {
    *(_DWORD *)(a1 + 488) = 0;
    return sub_FF92(v22, v18, (__int64)"waiting for x11-req response packet");
  }
  v12 = *v21;
  (*(void (__fastcall **)(char *, size_t))(v22 + 24))(v21, v22);
  *(_DWORD *)(a1 + 488) = 0;
  if ( v12 != 99 )
LABEL_35:
    result = sub_FF92(v22, 0xFFFFFFEA, (__int64)"Unable to complete request for channel x11-req");
  else
    result = 0LL;
  return result;
}
// 4FC0: using guessed type __int64 __fastcall RAND_bytes(_QWORD, _QWORD);
// 7521: using guessed type char var_20[24];

//----- (00000000000079A3) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_x11_req_ex(__int64 a1, int a2, const char *a3, char *a4, int a5)
{
  char *v6; // [rsp+0h] [rbp-30h]
  const char *v7; // [rsp+8h] [rbp-28h]
  int v8; // [rsp+10h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v8 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_7521(a1, a2, v7, v6, v8);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = sub_179AF(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}

//----- (0000000000007A37) ----------------------------------------------------
__int64 __fastcall sub_7A37(__int64 a1, const void *a2, size_t a3, void *a4, size_t a5)
{
  __int64 result; // rax
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  int v8; // ST43_4
  size_t v9; // [rsp+8h] [rbp-58h]
  void *v10; // [rsp+10h] [rbp-50h]
  size_t v11; // [rsp+18h] [rbp-48h]
  unsigned int v12; // [rsp+34h] [rbp-2Ch]
  unsigned int v13; // [rsp+34h] [rbp-2Ch]
  _BYTE *v14; // [rsp+38h] [rbp-28h]
  unsigned __int8 *v15; // [rsp+40h] [rbp-20h]
  char v16; // [rsp+48h] [rbp-18h]
  size_t v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v18 = __readfsqword(0x28u);
  v17 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 528) )
  {
    *(_QWORD *)(a1 + 544) = a3 + 10;
    memset((void *)(a1 + 560), 0, 8uLL);
    if ( v10 )
      *(_QWORD *)(a1 + 544) += 4LL;
    *(_QWORD *)(a1 + 536) = (*(__int64 (__fastcall **)(_QWORD, size_t))(v17 + 8))(*(_QWORD *)(a1 + 544), v17);
    v14 = *(_BYTE **)(a1 + 536);
    if ( !*(_QWORD *)(a1 + 536) )
      return sub_FF92(v17, 0xFFFFFFFA, (__int64)"Unable to allocate memory for channel-process request");
    v6 = v14++;
    *v6 = 98;
    sub_101C7(&v14, *(_DWORD *)(a1 + 68));
    sub_101FF((void **)&v14, a2, v11);
    v7 = v14++;
    *v7 = 1;
    if ( v10 )
      sub_101C7(&v14, v9);
    *(_DWORD *)(a1 + 528) = 2;
  }
  if ( *(_DWORD *)(a1 + 528) == 2 )
  {
    v12 = sub_24D86(v17, *(const void **)(a1 + 536), *(_QWORD *)(a1 + 544), v10, v9);
    if ( v12 == -37 )
    {
      sub_FF92(v17, 0xFFFFFFDB, (__int64)"Would block sending channel request");
      return 4294967259LL;
    }
    if ( v12 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(v17 + 24))(*(_QWORD *)(a1 + 536), v17);
      *(_QWORD *)(a1 + 536) = 0LL;
      *(_DWORD *)(a1 + 528) = 0;
      return sub_FF92(v17, v12, (__int64)"Unable to send channel request");
    }
    (*(void (__fastcall **)(_QWORD, size_t))(v17 + 24))(*(_QWORD *)(a1 + 536), v17);
    *(_QWORD *)(a1 + 536) = 0LL;
    sub_1017A((_BYTE *)(a1 + 552), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 528) = 3;
  }
  if ( *(_DWORD *)(a1 + 528) != 3 )
    goto LABEL_25;
  v13 = sub_12797(v17, (const char *)&off_2A240, &v15, &v16, 1, (void *)(a1 + 552), 4uLL, (time_t *)(a1 + 560));
  if ( v13 == -37 )
    return 4294967259LL;
  if ( v13 )
  {
    *(_DWORD *)(a1 + 528) = 0;
    return sub_FF92(v17, v13, (__int64)"Failed waiting for channel success");
  }
  v8 = *v15;
  (*(void (__fastcall **)(unsigned __int8 *, size_t))(v17 + 24))(v15, v17);
  *(_DWORD *)(a1 + 528) = 0;
  if ( (_BYTE)v8 != 99 )
LABEL_25:
    result = sub_FF92(v17, 0xFFFFFFEA, (__int64)"Unable to complete request for channel-process-startup");
  else
    result = 0LL;
  return result;
}
// 2A240: using guessed type void *off_2A240;

//----- (0000000000007DCA) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_process_startup(__int64 a1, const void *a2, unsigned int a3, void *a4, unsigned int a5)
{
  void *v6; // [rsp+0h] [rbp-30h]
  unsigned int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_7A37(a1, a2, v8, v6, v7);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = sub_179AF(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}

//----- (0000000000007E5E) ----------------------------------------------------
__int64 __fastcall libssh2_channel_set_blocking(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
    result = sub_18FD5(*(_QWORD *)(a1 + 96), a2);
  return result;
}

//----- (0000000000007E8C) ----------------------------------------------------
signed __int64 __fastcall sub_7E8C(__int64 a1, int a2)
{
  signed __int64 v2; // rax
  int v3; // ST20_4
  char v5; // [rsp+1Fh] [rbp-21h]
  __int64 v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]

  if ( !*(_DWORD *)(a1 + 568) )
  {
    v6 = sub_10877(*(_QWORD *)(a1 + 96) + 448LL);
    *(_QWORD *)(a1 + 576) = 0LL;
    *(_QWORD *)(a1 + 584) = 0LL;
    while ( v6 )
    {
      v7 = sub_10889(v6);
      v5 = **(_BYTE **)(v6 + 24);
      if ( (v5 == 94 || v5 == 95)
        && (unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(v6 + 24) + 1LL)) == *(_DWORD *)(a1 + 48) )
      {
        v2 = v5 == 94 ? 0LL : (unsigned __int64)(unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(v6 + 24) + 5LL));
        if ( a2 == -2 || v5 == 95 && (a2 == -1 || v2 == a2) || v5 == 94 && !a2 )
        {
          v3 = *(unsigned __int64 *)(v6 + 32) - *(unsigned __int64 *)(v6 + 40);
          *(_QWORD *)(a1 + 576) = *(_QWORD *)(a1 + 576) + *(_QWORD *)(v6 + 32) - 13LL;
          *(_QWORD *)(a1 + 584) += v3;
          (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 96) + 24LL))(
            *(_QWORD *)(v6 + 24),
            *(_QWORD *)(a1 + 96));
          sub_108AC(v6);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 96) + 24LL))(v6, *(_QWORD *)(a1 + 96));
        }
      }
      v6 = v7;
    }
    *(_DWORD *)(a1 + 568) = 2;
  }
  if ( *(_QWORD *)(a1 + 576) && (unsigned int)sub_82CF(a1, *(_QWORD *)(a1 + 576), 1, 0LL) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 568) = 0;
  return *(_QWORD *)(a1 + 584);
}

//----- (00000000000080C4) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_flush_ex(__int64 a1, int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v4 = time(0LL);
  do
  {
    v3 = sub_7E8C(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v3 = sub_179AF(*(_QWORD *)(a1 + 96), v4);
  }
  while ( !v3 );
  return v3;
}

//----- (0000000000008140) ----------------------------------------------------
__int64 __fastcall libssh2_channel_get_exit_status(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(unsigned int *)(a1 + 36);
  else
    result = 0LL;
  return result;
}

//----- (000000000000815F) ----------------------------------------------------
__int64 __fastcall libssh2_channel_get_exit_signal(__int64 a1, void **a2, size_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  _QWORD *v8; // [rsp+0h] [rbp-40h]
  _QWORD *v9; // [rsp+8h] [rbp-38h]
  _QWORD *v10; // [rsp+10h] [rbp-30h]
  size_t *v11; // [rsp+18h] [rbp-28h]
  __int64 v12; // [rsp+30h] [rbp-10h]
  size_t n; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  v12 = *(_QWORD *)(a1 + 96);
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 40) )
    {
      n = strlen(*(const char **)(a1 + 40));
      if ( a2 )
      {
        *a2 = (void *)(*(__int64 (__fastcall **)(size_t, __int64))(v12 + 8))(n + 1, v12);
        if ( !*a2 )
          return sub_FF92(v12, 0xFFFFFFFA, (__int64)"Unable to allocate memory for signal name");
        memcpy(*a2, *(const void **)(a1 + 40), n);
        *((_BYTE *)*a2 + n) = 0;
      }
      if ( v11 )
        *v11 = n;
    }
    else
    {
      if ( a2 )
        *a2 = 0LL;
      if ( a3 )
        *a3 = 0LL;
    }
    if ( v10 )
      *v10 = 0LL;
    if ( v9 )
      *v9 = 0LL;
    if ( v8 )
      *v8 = 0LL;
    if ( a7 )
      *a7 = 0LL;
  }
  return 0LL;
}

//----- (00000000000082CF) ----------------------------------------------------
__int64 __fastcall sub_82CF(__int64 a1, int a2, char a3, _DWORD *a4)
{
  __int64 result; // rax
  _DWORD *v5; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+14h] [rbp-1Ch]
  int v7; // [rsp+2Ch] [rbp-4h]

  v6 = a2;
  v5 = a4;
  if ( !*(_DWORD *)(a1 + 592) )
  {
    if ( !a3 && (unsigned int)(*(_DWORD *)(a1 + 88) + a2) <= 0x3FF )
    {
      *(_DWORD *)(a1 + 88) += a2;
      if ( a4 )
        *a4 = *(_DWORD *)(a1 + 76);
      return 0LL;
    }
    if ( !a2 && !*(_DWORD *)(a1 + 88) )
    {
      if ( a4 )
        *a4 = *(_DWORD *)(a1 + 76);
      return 0LL;
    }
    v6 = *(_DWORD *)(a1 + 88) + a2;
    *(_DWORD *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 596) = 93;
    sub_1017A((_BYTE *)(a1 + 597), *(_DWORD *)(a1 + 68));
    sub_1017A((_BYTE *)(a1 + 601), v6);
    *(_DWORD *)(a1 + 592) = 2;
  }
  v7 = sub_24D86(*(_QWORD *)(a1 + 96), (const void *)(a1 + 596), 9LL, 0LL, 0LL);
  if ( v7 == -37 )
  {
    sub_FF92(*(_QWORD *)(a1 + 96), 0xFFFFFFDB, (__int64)"Would block sending window adjust");
    result = 4294967259LL;
  }
  else if ( v7 )
  {
    *(_DWORD *)(a1 + 88) = v6;
    result = sub_FF92(
               *(_QWORD *)(a1 + 96),
               0xFFFFFFF9,
               (__int64)"Unable to send transfer-window adjustment packet, deferring");
  }
  else
  {
    *(_DWORD *)(a1 + 76) += v6;
    *(_DWORD *)(a1 + 592) = 0;
    if ( v5 )
      *v5 = *(_DWORD *)(a1 + 76);
    result = 0LL;
  }
  return result;
}

//----- (0000000000008493) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_receive_window_adjust(__int64 a1, int a2, char a3)
{
  signed __int64 result; // rax
  char v4; // [rsp+Ch] [rbp-34h]
  unsigned int v5; // [rsp+28h] [rbp-18h]
  int v6; // [rsp+2Ch] [rbp-14h]
  time_t v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v8 = __readfsqword(0x28u);
  if ( !a1 )
    return -39LL;
  v7 = time(0LL);
  do
  {
    v6 = sub_82CF(a1, a2, v4, &v5);
    if ( v6 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v6 = sub_179AF(*(_QWORD *)(a1 + 96), v7);
  }
  while ( !v6 );
  if ( v6 )
    result = v6;
  else
    result = v5;
  return result;
}

//----- (0000000000008552) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_receive_window_adjust2(__int64 a1, int a2, char a3, _DWORD *a4)
{
  _DWORD *v5; // [rsp+0h] [rbp-30h]
  char v6; // [rsp+Ch] [rbp-24h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v5 = a4;
  v6 = a3;
  if ( !a1 )
    return 4294967257LL;
  v8 = time(0LL);
  do
  {
    v7 = sub_82CF(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v7 = sub_179AF(*(_QWORD *)(a1 + 96), v8);
  }
  while ( !v7 );
  return v7;
}

//----- (00000000000085E1) ----------------------------------------------------
signed __int64 __fastcall sub_85E1(__int64 a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 680) )
  {
    *(_BYTE *)(a1 + 86) = a2;
    *(_DWORD *)(a1 + 680) = 2;
  }
  if ( !*(_DWORD *)(a1 + 680) && a2 == 1 && (unsigned int)sub_7E8C(a1, -1) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 680) = 0;
  return 0LL;
}

//----- (0000000000008660) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_handle_extended_data2(__int64 a1, int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v4 = time(0LL);
  do
  {
    v3 = sub_85E1(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v3 = sub_179AF(*(_QWORD *)(a1 + 96), v4);
  }
  while ( !v3 );
  return v3;
}

//----- (00000000000086DC) ----------------------------------------------------
__int64 __fastcall libssh2_channel_handle_extended_data(__int64 a1, unsigned int a2)
{
  return libssh2_channel_handle_extended_data2(a1, a2);
}
// 4E90: using guessed type __int64 __fastcall libssh2_channel_handle_extended_data2(_QWORD, _QWORD);

//----- (00000000000086FF) ----------------------------------------------------
__int64 __fastcall sub_86FF(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 result; // rax
  int v5; // [rsp+0h] [rbp-50h]
  __int64 v6; // [rsp+8h] [rbp-48h]
  signed int i; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  int v9; // [rsp+28h] [rbp-28h]
  signed int v10; // [rsp+2Ch] [rbp-24h]
  _QWORD *j; // [rsp+30h] [rbp-20h]
  size_t v12; // [rsp+38h] [rbp-18h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v12 = *(_QWORD *)(a1 + 96);
  v8 = 0;
  if ( !*(_DWORD *)(a1 + 608) )
    *(_DWORD *)(a1 + 608) = 2;
  for ( i = 1; i > 0; i = sub_2445D(v12) )
    ;
  if ( i < 0 && i != -37 )
    return (signed int)sub_FF92(v12, i, (__int64)"transport read");
  for ( j = (_QWORD *)sub_10877(v12 + 448); j && v8 < v5; j = (_QWORD *)v13 )
  {
    v13 = sub_10889((__int64)j);
    *(_DWORD *)(a1 + 612) = sub_10071((unsigned int *)(j[3] + 1LL));
    if ( a2
      && *(_BYTE *)j[3] == 95
      && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 612)
      && a2 == (unsigned int)sub_10071((unsigned int *)(j[3] + 5LL))
      || !a2 && *(_BYTE *)j[3] == 94 && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 612)
      || !a2 && *(_BYTE *)j[3] == 95 && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 612) && *(_BYTE *)(a1 + 86) == 2 )
    {
      v9 = v5 - v8;
      v10 = 0;
      if ( v5 - v8 >= (signed int)(j[4] - j[5]) )
      {
        v9 = j[4] - j[5];
        v10 = 1;
      }
      memcpy((void *)(v6 + v8), (const void *)(j[3] + j[5]), v9);
      j[5] += v9;
      v8 += v9;
      if ( v10 )
      {
        sub_108AC((__int64)j);
        (*(void (__fastcall **)(_QWORD, size_t))(v12 + 24))(j[3], v12);
        (*(void (__fastcall **)(_QWORD *, size_t))(v12 + 24))(j, v12);
      }
    }
  }
  if ( v8 )
  {
    *(_DWORD *)(a1 + 608) = 2;
    result = v8;
  }
  else
  {
    *(_DWORD *)(a1 + 608) = 0;
    if ( *(_BYTE *)(a1 + 85) || *(_BYTE *)(a1 + 84) )
    {
      result = 0LL;
    }
    else if ( i == -37 )
    {
      result = (signed int)sub_FF92(v12, 0xFFFFFFDB, (__int64)"would block");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000008A08) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_read_ex(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  int v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  int v7; // [rsp+24h] [rbp-1Ch]
  time_t v8; // [rsp+30h] [rbp-10h]
  time_t v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( !a1 )
    return -39LL;
  if ( a4 > libssh2_channel_window_read_ex(a1, 0LL, 0LL) )
  {
    v8 = time(0LL);
    while ( (unsigned int)sub_82CF(a1, v5, 1, 0LL) == -37
         && *(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL)
         && !(unsigned int)sub_179AF(*(_QWORD *)(a1 + 96), v8) )
      ;
  }
  v9 = time(0LL);
  do
  {
    v7 = sub_86FF(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v7 = sub_179AF(*(_QWORD *)(a1 + 96), v9);
  }
  while ( !v7 );
  return v7;
}
// 4E50: using guessed type __int64 __fastcall libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD);

//----- (0000000000008B22) ----------------------------------------------------
__int64 __fastcall sub_8B22(__int64 a1, int a2)
{
  int v3; // [rsp+1Ch] [rbp-14h]
  _QWORD *v4; // [rsp+20h] [rbp-10h]

  v4 = (_QWORD *)sub_10877(*(_QWORD *)(a1 + 96) + 448LL);
  if ( !v4 )
    return 0LL;
  while ( v4 )
  {
    v3 = sub_10071((unsigned int *)(v4[3] + 1LL));
    if ( a2
      && *(_BYTE *)v4[3] == 95
      && v3 == *(_DWORD *)(a1 + 48)
      && a2 == (unsigned int)sub_10071((unsigned int *)(v4[3] + 5LL))
      || !a2 && *(_BYTE *)v4[3] == 94 && v3 == *(_DWORD *)(a1 + 48)
      || !a2 && *(_BYTE *)v4[3] == 95 && v3 == *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 86) == 2 )
    {
      return v4[4] - v4[5];
    }
    v4 = (_QWORD *)sub_10889((__int64)v4);
  }
  return 0LL;
}

//----- (0000000000008C41) ----------------------------------------------------
signed __int64 __fastcall sub_8C41(__int64 a1, int a2, void *a3, unsigned __int64 a4)
{
  signed __int64 result; // rax
  char v5; // cl
  char *v6; // rax
  signed __int64 v7; // [rsp+0h] [rbp-50h]
  void *v8; // [rsp+8h] [rbp-48h]
  int v9; // [rsp+2Ch] [rbp-24h]
  unsigned int v10; // [rsp+2Ch] [rbp-24h]
  char *v11; // [rsp+30h] [rbp-20h]
  size_t v12; // [rsp+38h] [rbp-18h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v14 = __readfsqword(0x28u);
  v12 = *(_QWORD *)(a1 + 96);
  v13 = 0LL;
  if ( a4 > 0x7FBC )
    v7 = 32700LL;
  if ( !*(_DWORD *)(a1 + 616) )
  {
    v11 = (char *)(a1 + 620);
    if ( *(_BYTE *)(a1 + 64) )
      return (signed int)sub_FF92(*(_QWORD *)(a1 + 96), 0xFFFFFFE6, (__int64)"We've already closed this channel");
    if ( *(_BYTE *)(a1 + 65) )
      return (signed int)sub_FF92(
                           *(_QWORD *)(a1 + 96),
                           0xFFFFFFE5,
                           (__int64)"EOF has already been received, data might be ignored");
    do
      v9 = sub_2445D(v12);
    while ( v9 > 0 );
    if ( v9 < 0 && v9 != -37 )
      return v9;
    if ( !*(_DWORD *)(a1 + 56) )
    {
      if ( v9 == -37 )
        result = -37LL;
      else
        result = 0LL;
      return result;
    }
    *(_QWORD *)(a1 + 648) = v7;
    if ( a2 )
      v5 = 95;
    else
      v5 = 94;
    v6 = v11++;
    *v6 = v5;
    sub_101C7(&v11, *(_DWORD *)(a1 + 68));
    if ( a2 )
      sub_101C7(&v11, a2);
    if ( *(_QWORD *)(a1 + 648) > (unsigned __int64)*(unsigned int *)(a1 + 56) )
      *(_QWORD *)(a1 + 648) = *(unsigned int *)(a1 + 56);
    if ( *(_QWORD *)(a1 + 648) > (unsigned __int64)*(unsigned int *)(a1 + 60) )
      *(_QWORD *)(a1 + 648) = *(unsigned int *)(a1 + 60);
    sub_101C7(&v11, *(_QWORD *)(a1 + 648));
    *(_QWORD *)(a1 + 640) = &v11[-a1 - 620];
    *(_DWORD *)(a1 + 616) = 2;
  }
  if ( *(_DWORD *)(a1 + 616) != 2 )
    return -34LL;
  v10 = sub_24D86(v12, (const void *)(a1 + 620), *(_QWORD *)(a1 + 640), v8, *(_QWORD *)(a1 + 648));
  if ( v10 == -37 )
    return (signed int)sub_FF92(v12, 0xFFFFFFDB, (__int64)"Unable to send channel data");
  if ( v10 )
  {
    *(_DWORD *)(a1 + 616) = 0;
    result = (signed int)sub_FF92(v12, v10, (__int64)"Unable to send channel data");
  }
  else
  {
    *(_DWORD *)(a1 + 56) -= *(_QWORD *)(a1 + 648);
    v13 += *(_QWORD *)(a1 + 648);
    *(_DWORD *)(a1 + 616) = 0;
    result = v13;
  }
  return result;
}

//----- (0000000000008F65) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_write_ex(__int64 a1, int a2, void *a3, unsigned __int64 a4)
{
  int v5; // eax
  unsigned __int64 v6; // [rsp+0h] [rbp-30h]
  void *v7; // [rsp+8h] [rbp-28h]
  signed __int64 v8; // [rsp+20h] [rbp-10h]
  time_t v9; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  if ( !a1 )
    return -39LL;
  v9 = time(0LL);
  do
  {
    v8 = sub_8C41(a1, a2, v7, v6);
    if ( v8 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v5 = sub_179AF(*(_QWORD *)(a1 + 96), v9);
    v8 = v5;
  }
  while ( !v5 );
  return v8;
}

//----- (0000000000008FF8) ----------------------------------------------------
__int64 __fastcall sub_8FF8(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+14h] [rbp-1Ch]
  __int64 v3; // [rsp+18h] [rbp-18h]
  char v4; // [rsp+23h] [rbp-Dh]
  int v5; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v3 = *(_QWORD *)(a1 + 96);
  v4 = 96;
  sub_1017A(&v5, *(_DWORD *)(a1 + 68));
  v2 = sub_24D86(v3, &v4, 5LL, 0LL, 0LL);
  if ( v2 == -37 )
  {
    sub_FF92(v3, 0xFFFFFFDB, (__int64)"Would block sending EOF");
    result = 4294967259LL;
  }
  else if ( v2 )
  {
    result = sub_FF92(v3, 0xFFFFFFF9, (__int64)"Unable to send EOF on channel");
  }
  else
  {
    *(_BYTE *)(a1 + 65) = 1;
    result = 0LL;
  }
  return result;
}

//----- (00000000000090C5) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_send_eof(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_8FF8(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (0000000000009139) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_eof(__int64 a1)
{
  int v2; // ebx
  __int64 i; // [rsp+10h] [rbp-20h]

  if ( !a1 )
    return 4294967257LL;
  for ( i = sub_10877(*(_QWORD *)(a1 + 96) + 448LL); i; i = sub_10889(i) )
  {
    if ( **(_BYTE **)(i + 24) == 94 || **(_BYTE **)(i + 24) == 95 )
    {
      v2 = *(_DWORD *)(a1 + 48);
      if ( v2 == (unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(i + 24) + 1LL)) )
        return 0LL;
    }
  }
  return (unsigned int)*(char *)(a1 + 85);
}

//----- (00000000000091E8) ----------------------------------------------------
__int64 __fastcall sub_91E8(__int64 a1)
{
  signed int v2; // [rsp+14h] [rbp-Ch]
  size_t v3; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 668) )
    *(_DWORD *)(a1 + 668) = 2;
  while ( !*(_BYTE *)(a1 + 85) )
  {
    v2 = sub_2445D(v3);
    if ( v2 == -37 )
      return 4294967259LL;
    if ( v2 < 0 )
    {
      *(_DWORD *)(a1 + 668) = 0;
      return sub_FF92(v3, v2, (__int64)"_libssh2_transport_read() bailed out!");
    }
  }
  *(_DWORD *)(a1 + 668) = 0;
  return 0LL;
}

//----- (0000000000009286) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_wait_eof(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_91E8(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (00000000000092FA) ----------------------------------------------------
__int64 __fastcall sub_92FA(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // [rsp+10h] [rbp-10h]
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  unsigned int v4; // [rsp+14h] [rbp-Ch]
  size_t v5; // [rsp+18h] [rbp-8h]

  v5 = *(_QWORD *)(a1 + 96);
  v2 = 0;
  if ( *(_BYTE *)(a1 + 64) )
  {
    *(_DWORD *)(a1 + 656) = 0;
    return 0LL;
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    v3 = sub_8FF8(a1);
    if ( v3 )
      return v3;
  }
  if ( !*(_DWORD *)(a1 + 656) )
  {
    *(_BYTE *)(a1 + 660) = 97;
    sub_1017A((_BYTE *)(a1 + 661), *(_DWORD *)(a1 + 68));
    *(_DWORD *)(a1 + 656) = 2;
  }
  if ( *(_DWORD *)(a1 + 656) == 2 )
  {
    v4 = sub_24D86(v5, (const void *)(a1 + 660), 5LL, 0LL, 0LL);
    if ( v4 == -37 )
    {
      sub_FF92(v5, 0, (__int64)"Would block sending close-channel");
      return 4294967259LL;
    }
    if ( v4 )
    {
      *(_DWORD *)(a1 + 656) = 0;
      return sub_FF92(v5, v4, (__int64)"Unable to send close-channel request");
    }
    *(_DWORD *)(a1 + 656) = 3;
  }
  if ( *(_DWORD *)(a1 + 656) == 3 )
  {
    while ( !*(_BYTE *)(a1 + 84) && !v2 && *(_DWORD *)(v5 + 508) != -1 )
      v2 = sub_2445D(v5);
  }
  if ( v2 != -37 )
  {
    *(_BYTE *)(a1 + 64) = 1;
    if ( *(_QWORD *)(a1 + 112) )
      (*(void (__fastcall **)(size_t, size_t, __int64, __int64))(a1 + 112))(v5, v5, a1, a1 + 104);
    *(_DWORD *)(a1 + 656) = 0;
  }
  result = 0LL;
  if ( (signed int)v2 <= 0 )
    result = v2;
  return result;
}

//----- (00000000000094E6) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_close(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_92FA(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (000000000000955A) ----------------------------------------------------
__int64 __fastcall sub_955A(__int64 a1)
{
  signed int v2; // [rsp+14h] [rbp-Ch]
  size_t v3; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 96);
  if ( !(unsigned int)libssh2_channel_eof(a1) )
    return sub_FF92(v3, 0xFFFFFFDE, (__int64)"libssh2_channel_wait_closed() invoked when channel is not in EOF state");
  if ( !*(_DWORD *)(a1 + 672) )
    *(_DWORD *)(a1 + 672) = 2;
  if ( !*(_BYTE *)(a1 + 84) )
  {
    do
      v2 = sub_2445D(v3);
    while ( !*(_BYTE *)(a1 + 84) && v2 > 0 );
    if ( v2 < 0 )
      return (unsigned int)v2;
  }
  *(_DWORD *)(a1 + 672) = 0;
  return 0LL;
}
// 4B10: using guessed type __int64 __fastcall libssh2_channel_eof(_QWORD);

//----- (0000000000009608) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_wait_closed(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_955A(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (000000000000967C) ----------------------------------------------------
signed __int64 __fastcall sub_967C(__int64 a1)
{
  __int64 v2; // [rsp+18h] [rbp-28h]
  char v3; // [rsp+20h] [rbp-20h]
  size_t n; // [rsp+28h] [rbp-18h]
  char v5; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+38h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  n = *(_QWORD *)(a1 + 96);
  if ( !n )
    __assert_fail("session", "channel.c", 0x96Fu, "_libssh2_channel_free");
  if ( !*(_DWORD *)(a1 + 676) )
    *(_DWORD *)(a1 + 676) = 2;
  if ( !*(_BYTE *)(a1 + 64) && !*(_DWORD *)(n + 508) && (unsigned int)sub_92FA(a1) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 676) = 0;
  if ( *(_QWORD *)(a1 + 40) )
    (*(void (__fastcall **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 40), n);
  sub_1017A(&v5, *(_DWORD *)(a1 + 48));
  while ( (signed int)sub_12289(n, 94, &v2, &v3, 1, &v5, 4uLL) >= 0
       || (signed int)sub_12289(n, 95, &v2, &v3, 1, &v5, 4uLL) >= 0 )
    (*(void (__fastcall **)(__int64, size_t))(n + 24))(v2, n);
  if ( *(_QWORD *)(a1 + 24) )
    (*(void (__fastcall **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 24), n);
  sub_108AC(a1);
  if ( *(_QWORD *)(a1 + 128) )
    (*(void (__fastcall **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 128), n);
  if ( *(_QWORD *)(a1 + 496) )
    (*(void (__fastcall **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 496), n);
  if ( *(_QWORD *)(a1 + 536) )
    (*(void (__fastcall **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 536), n);
  (*(void (__fastcall **)(__int64, size_t))(n + 24))(a1, n);
  return 0LL;
}

//----- (00000000000098DF) ----------------------------------------------------
signed __int64 __fastcall libssh2_channel_free(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_967C(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (0000000000009953) ----------------------------------------------------
__int64 __fastcall libssh2_channel_window_read_ex(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  char v4; // [rsp+2Fh] [rbp-11h]
  __int64 v5; // [rsp+30h] [rbp-10h]
  __int64 i; // [rsp+38h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  if ( a3 )
    *a3 = *(unsigned int *)(a1 + 72);
  if ( a2 )
  {
    v5 = 0LL;
    for ( i = sub_10877(*(_QWORD *)(a1 + 96) + 448LL); i; i = sub_10889(i) )
    {
      v4 = **(_BYTE **)(i + 24);
      if ( (v4 == 94 || v4 == 95)
        && (unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(i + 24) + 1LL)) == *(_DWORD *)(a1 + 48) )
      {
        v5 += *(_QWORD *)(i + 32) - *(_QWORD *)(i + 40);
      }
    }
    *a2 = v5;
  }
  return *(unsigned int *)(a1 + 76);
}

//----- (0000000000009A40) ----------------------------------------------------
__int64 __fastcall libssh2_channel_window_write_ex(__int64 a1, _QWORD *a2)
{
  if ( !a1 )
    return 0LL;
  if ( a2 )
    *a2 = *(unsigned int *)(a1 + 52);
  return *(unsigned int *)(a1 + 56);
}

//----- (0000000000009A7C) ----------------------------------------------------
__int64 sub_9A7C()
{
  return 0LL;
}

//----- (0000000000009A9F) ----------------------------------------------------
__int64 __fastcall sub_9A9F(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  *a2 = a5;
  *a3 = a6;
  return 0LL;
}

//----- (0000000000009AD8) ----------------------------------------------------
__int64 __fastcall sub_9AD8(__int64 a1, int a2, int a3)
{
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))((unsigned int)(a3 * a2), a1);
}

//----- (0000000000009B11) ----------------------------------------------------
__int64 __fastcall sub_9B11(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(a1 + 24))(a2, a1);
}

//----- (0000000000009B44) ----------------------------------------------------
__int64 __fastcall sub_9B44(__int64 a1, int a2, _QWORD *a3)
{
  __int64 result; // rax
  _QWORD *v4; // [rsp+8h] [rbp-28h]
  int v5; // [rsp+24h] [rbp-Ch]
  _QWORD *s; // [rsp+28h] [rbp-8h]

  v4 = a3;
  s = (_QWORD *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(112LL, a1);
  if ( !s )
    return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for zlib compression/decompression");
  memset(s, 0, 0x70uLL);
  s[10] = a1;
  s[8] = sub_9AD8;
  s[9] = sub_9B11;
  if ( a2 )
    v5 = deflateInit_(s, 0xFFFFFFFFLL, "1.2.11", 112LL);
  else
    v5 = inflateInit_(s, "1.2.11", 112LL);
  if ( v5 )
  {
    (*(void (__fastcall **)(_QWORD *, __int64))(a1 + 24))(s, a1);
    result = 4294967256LL;
  }
  else
  {
    *v4 = s;
    result = 0LL;
  }
  return result;
}
// 4C00: using guessed type __int64 __fastcall deflateInit_(_QWORD, _QWORD, _QWORD, _QWORD);
// 5060: using guessed type __int64 __fastcall inflateInit_(_QWORD, _QWORD, _QWORD);

//----- (0000000000009C4F) ----------------------------------------------------
__int64 __fastcall sub_9C4F(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, int a5, __int64 *a6)
{
  _QWORD *v7; // [rsp+18h] [rbp-28h]
  int v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v9 = *a6;
  v8 = *a3;
  *(_QWORD *)v9 = a4;
  *(_DWORD *)(v9 + 8) = a5;
  *(_QWORD *)(v9 + 24) = a2;
  *(_DWORD *)(v9 + 32) = v8;
  if ( (unsigned int)deflate(v9, 1LL) )
    return sub_FF92(a1, 0xFFFFFFE3, (__int64)"compression failure");
  *v7 = (unsigned int)(v8 - *(_DWORD *)(v9 + 32));
  return 0LL;
}
// 4BF0: using guessed type __int64 __fastcall deflate(_QWORD, _QWORD);

//----- (0000000000009D04) ----------------------------------------------------
__int64 __fastcall sub_9D04(__int64 a1, __int64 *a2, _QWORD *a3, int a4, __int64 a5, int a6, __int64 *a7)
{
  int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rax
  int v11; // [rsp+10h] [rbp-60h]
  _QWORD *v12; // [rsp+18h] [rbp-58h]
  int v13; // [rsp+38h] [rbp-38h]
  int v14; // [rsp+3Ch] [rbp-34h]
  int v15; // [rsp+40h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-28h]
  __int64 v17; // [rsp+50h] [rbp-20h]
  __int64 v18; // [rsp+58h] [rbp-18h]
  __int64 v19; // [rsp+60h] [rbp-10h]

  v12 = a3;
  v11 = a4;
  v17 = *a7;
  v13 = 8 * a6;
  v14 = 0;
  if ( !*a7 )
    return sub_FF92(a1, 0xFFFFFFD8, (__int64)"decompression unitilized");
  if ( v13 <= 24 )
    v13 = 25;
  if ( v13 > a4 )
    v13 = a4;
  *(_QWORD *)v17 = a5;
  *(_DWORD *)(v17 + 8) = a6;
  *(_QWORD *)(v17 + 24) = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v13, a1);
  v16 = *(_QWORD *)(v17 + 24);
  *(_DWORD *)(v17 + 32) = v13;
  if ( !*(_QWORD *)(v17 + 24) )
    return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate decompression buffer");
  while ( *(_DWORD *)(v17 + 8) )
  {
    if ( (unsigned int)inflate(v17, 1LL) )
    {
      (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v16, a1);
      return sub_FF92(a1, 0xFFFFFFE3, (__int64)"decompression failure");
    }
    if ( *(_DWORD *)(v17 + 8) )
    {
      v19 = (unsigned int)(v13 - *(_DWORD *)(v17 + 32));
      v13 += 8 * *(_DWORD *)(v17 + 8);
      if ( v13 > v11 )
      {
        v8 = v14++;
        if ( v8 )
        {
          (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v16, a1);
          return sub_FF92(a1, 0xFFFFFFE3, (__int64)"Excessive growth in decompression phase");
        }
      }
      if ( v16 )
        v9 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(a1 + 16))(v16, v13, a1);
      else
        v9 = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v13, a1);
      if ( !v9 )
      {
        (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v16, a1);
        return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to expand decompression buffer");
      }
      v16 = v9;
      *(_QWORD *)(v17 + 24) = v19 + v9;
      *(_DWORD *)(v17 + 32) += 8 * *(_DWORD *)(v17 + 8);
    }
    else
    {
      while ( !*(_DWORD *)(v17 + 32) )
      {
        v15 = 2048;
        if ( v13 >= v11 )
        {
          (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v16, a1);
          return sub_FF92(a1, 0xFFFFFFE3, (__int64)"Excessive growth in decompression phase");
        }
        if ( v11 - v13 < 2048 )
          v15 = v11 - v13;
        v13 += v15;
        *(_DWORD *)(v17 + 32) = v15;
        if ( v16 )
          v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(a1 + 16))(v16, v13, a1);
        else
          v10 = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v13, a1);
        v18 = v10;
        if ( !v10 )
        {
          (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v16, a1);
          return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to expand final decompress buffer");
        }
        v16 = v10;
        *(_QWORD *)(v17 + 24) = v10 + v13 - (signed __int64)v15;
        if ( (unsigned int)inflate(v17, 1LL) )
        {
          (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v18, a1);
          return sub_FF92(a1, 0xFFFFFFE3, (__int64)"decompression failure");
        }
      }
    }
  }
  *a2 = v16;
  *v12 = (unsigned int)(v13 - *(_DWORD *)(v17 + 32));
  return 0LL;
}
// 4D20: using guessed type __int64 __fastcall inflate(_QWORD, _QWORD);

//----- (000000000000A13A) ----------------------------------------------------
__int64 __fastcall sub_A13A(__int64 a1, int a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-28h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v5 = *a3;
  if ( *a3 )
  {
    if ( a2 )
      deflateEnd(v5);
    else
      inflateEnd(v5);
    (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v5, a1);
  }
  *v4 = 0LL;
  return 0LL;
}
// 4B70: using guessed type __int64 __fastcall inflateEnd(_QWORD);
// 4D70: using guessed type __int64 __fastcall deflateEnd(_QWORD);

//----- (000000000000A1A9) ----------------------------------------------------
char ***__fastcall sub_A1A9(__int64 a1)
{
  char ***result; // rax

  if ( *(_DWORD *)(a1 + 112) )
    result = off_2323F0;
  else
    result = &off_232410;
  return result;
}
// 2323F0: using guessed type char **off_2323F0[2];
// 232410: using guessed type char **off_232410;

//----- (000000000000A1CE) ----------------------------------------------------
signed __int64 __fastcall sub_A1CE(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8)
{
  signed __int64 result; // rax
  _DWORD *v9; // [rsp+0h] [rbp-40h]
  __int64 v10; // [rsp+8h] [rbp-38h]
  _DWORD *v11; // [rsp+10h] [rbp-30h]
  __int64 v12; // [rsp+18h] [rbp-28h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v13 = (*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(184LL, a1);
  if ( !v13 )
    return 4294967290LL;
  *(_DWORD *)v13 = a7;
  *(_QWORD *)(v13 + 8) = *(_QWORD *)(a2 + 56);
  if ( (unsigned int)sub_285C3(v13 + 16, *(__int64 (**)(void))(v13 + 8), v12, v10, a7) )
  {
    (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v13, a1);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    *a8 = v13;
    *v11 = 1;
    *v9 = 1;
    result = 0LL;
  }
  return result;
}

//----- (000000000000A29F) ----------------------------------------------------
_BOOL8 __fastcall sub_A29F(__int64 a1, void *a2, unsigned int **a3)
{
  return sub_28618((__int64)(*a3 + 4), *((_QWORD *)*a3 + 1), **a3, a2);
}

//----- (000000000000A2E2) ----------------------------------------------------
__int64 __fastcall sub_A2E2(__int64 a1, _QWORD *a2)
{
  if ( a2 && *a2 )
  {
    EVP_CIPHER_CTX_cleanup(*a2 + 16LL);
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
    *a2 = 0LL;
  }
  return 0LL;
}
// 5160: using guessed type __int64 __fastcall EVP_CIPHER_CTX_cleanup(_QWORD);

//----- (000000000000A34D) ----------------------------------------------------
__int64 __fastcall sub_A34D(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8)
{
  unsigned int v9; // [rsp+4Ch] [rbp-24h]
  signed __int64 i; // [rsp+50h] [rbp-20h]
  unsigned int *v11; // [rsp+58h] [rbp-18h]
  char v12; // [rsp+60h] [rbp-10h]
  unsigned __int64 v13; // [rsp+68h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = sub_A1CE(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( !v9 )
  {
    v11 = (unsigned int *)*a8;
    for ( i = 1536LL; i; i -= 8LL )
      sub_28618((__int64)(v11 + 4), *((_QWORD *)v11 + 1), *v11, &v12);
  }
  return v9;
}

//----- (000000000000A414) ----------------------------------------------------
char ***libssh2_crypt_methods()
{
  return off_232420;
}
// 232420: using guessed type char **off_232420[12];

//----- (000000000000A421) ----------------------------------------------------
signed __int64 __fastcall sub_A421(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  unsigned int v5; // eax
  _QWORD *v6; // [rsp+0h] [rbp-60h]
  __int64 v7; // [rsp+20h] [rbp-40h]
  char *s1; // [rsp+28h] [rbp-38h]
  __int64 v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  char *v11; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  char *v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v6 = a4;
  v14 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_A796(a1, a4);
    *v6 = 0LL;
  }
  v9 = (unsigned int)sub_10071((unsigned int *)a2);
  s1 = (char *)(a2 + 4);
  if ( v9 != 7 || strncmp(s1, "ssh-rsa", 7uLL) )
    return 0xFFFFFFFFLL;
  s1 += 7;
  v10 = (unsigned int)sub_10071((unsigned int *)s1);
  s1 += 4;
  v11 = s1;
  s1 += v10;
  v5 = sub_10071((unsigned int *)s1);
  v12 = v5;
  s1 += 4;
  v13 = s1;
  if ( (unsigned int)sub_2815F(
                       &v7,
                       (__int64)v11,
                       v10,
                       (__int64)s1,
                       v5,
                       0LL,
                       0LL,
                       0LL,
                       0LL,
                       0LL,
                       0LL,
                       0LL,
                       0,
                       0LL,
                       0,
                       0LL,
                       0) )
    return 0xFFFFFFFFLL;
  *v6 = v7;
  return 0LL;
}

//----- (000000000000A57D) ----------------------------------------------------
signed __int64 __fastcall sub_A57D(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_A796(a1, a4);
    *v5 = 0LL;
  }
  if ( (unsigned int)sub_28B82(&v7, a1, a2, v6) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}

//----- (000000000000A61C) ----------------------------------------------------
signed __int64 __fastcall sub_A61C(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 *a6)
{
  return sub_2831E(*a6, a2 + 15, a3 - 15, a4, a5);
}

//----- (000000000000A672) ----------------------------------------------------
signed __int64 __fastcall sub_A672(__int64 a1, _QWORD *a2, _QWORD *a3, int a4, __int64 a5, __int64 *a6)
{
  __int64 v6; // rax
  signed __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-88h]
  int v9; // [rsp+14h] [rbp-7Ch]
  _QWORD *v10; // [rsp+18h] [rbp-78h]
  int i; // [rsp+30h] [rbp-60h]
  __int64 v12; // [rsp+38h] [rbp-58h]
  char v13; // [rsp+40h] [rbp-50h]
  char v14; // [rsp+70h] [rbp-20h]
  unsigned __int64 v15; // [rsp+88h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v15 = __readfsqword(0x28u);
  v12 = *a6;
  v6 = EVP_get_digestbyname("sha1");
  EVP_DigestInit(&v13, v6);
  for ( i = 0; i < v9; ++i )
    EVP_DigestUpdate(&v13, *(_QWORD *)(16LL * i + v8), *(_QWORD *)(16LL * i + v8 + 8));
  EVP_DigestFinal(&v13, &v14, 0LL);
  if ( (unsigned int)sub_28C06(a1, v12, (__int64)&v14, 0x14u, a2, v10) )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}
// 4E70: using guessed type __int64 __fastcall EVP_get_digestbyname(_QWORD);
// 4EC0: using guessed type __int64 __fastcall EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 4F20: using guessed type __int64 __fastcall EVP_DigestInit(_QWORD, _QWORD);
// 5270: using guessed type __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);

//----- (000000000000A796) ----------------------------------------------------
__int64 __fastcall sub_A796(__int64 a1, _QWORD *a2)
{
  RSA_free(*a2);
  *a2 = 0LL;
  return 0LL;
}
// 4C90: using guessed type __int64 __fastcall RSA_free(_QWORD);

//----- (000000000000A7CF) ----------------------------------------------------
signed __int64 __fastcall sub_A7CF(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  _QWORD *v9; // [rsp+0h] [rbp-80h]
  __int64 v10; // [rsp+20h] [rbp-60h]
  char *s1; // [rsp+28h] [rbp-58h]
  __int64 v12; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  char *v14; // [rsp+40h] [rbp-40h]
  __int64 v15; // [rsp+48h] [rbp-38h]
  char *v16; // [rsp+50h] [rbp-30h]
  __int64 v17; // [rsp+58h] [rbp-28h]
  char *v18; // [rsp+60h] [rbp-20h]
  __int64 v19; // [rsp+68h] [rbp-18h]
  char *v20; // [rsp+70h] [rbp-10h]
  unsigned __int64 v21; // [rsp+78h] [rbp-8h]

  v9 = a4;
  v21 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_AC01(a1, a4);
    *v9 = 0LL;
  }
  v12 = (unsigned int)sub_10071((unsigned int *)a2);
  s1 = (char *)(a2 + 4);
  if ( v12 != 7 || strncmp(s1, "ssh-dss", 7uLL) )
    return 0xFFFFFFFFLL;
  s1 += 7;
  v5 = sub_10071((unsigned int *)s1);
  v13 = v5;
  s1 += 4;
  v14 = s1;
  s1 += v5;
  v6 = sub_10071((unsigned int *)s1);
  v15 = v6;
  s1 += 4;
  v16 = s1;
  s1 += v6;
  v7 = sub_10071((unsigned int *)s1);
  v17 = v7;
  s1 += 4;
  v18 = s1;
  s1 += v7;
  v8 = sub_10071((unsigned int *)s1);
  v19 = v8;
  s1 += 4;
  v20 = s1;
  sub_283B8(&v10, (__int64)v14, v13, (__int64)v16, v15, (__int64)v18, v17, (__int64)s1, v8, 0LL, 0LL);
  *v9 = v10;
  return 0LL;
}

//----- (000000000000A966) ----------------------------------------------------
signed __int64 __fastcall sub_A966(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_AC01(a1, a4);
    *v5 = 0LL;
  }
  if ( (unsigned int)sub_28BC4(&v7, a1, a2, v6) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}

//----- (000000000000AA05) ----------------------------------------------------
signed __int64 __fastcall sub_AA05(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6)
{
  signed __int64 result; // rax

  if ( a3 == 55 )
    result = sub_284E6(*a6, a2 + 15, a4, a5);
  else
    result = sub_FF92(a1, 0xFFFFFFF2, (__int64)"Invalid DSS signature length");
  return result;
}

//----- (000000000000AA75) ----------------------------------------------------
signed __int64 __fastcall sub_AA75(__int64 a1, void **a2, _QWORD *a3, int a4, __int64 a5, __int64 *a6)
{
  __int64 v7; // rax
  __int64 v8; // [rsp+8h] [rbp-88h]
  int v9; // [rsp+14h] [rbp-7Ch]
  _QWORD *v10; // [rsp+18h] [rbp-78h]
  int i; // [rsp+34h] [rbp-5Ch]
  __int64 v12; // [rsp+38h] [rbp-58h]
  char v13; // [rsp+40h] [rbp-50h]
  char v14; // [rsp+70h] [rbp-20h]
  unsigned __int64 v15; // [rsp+88h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v15 = __readfsqword(0x28u);
  v12 = *a6;
  *a2 = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(40LL, a1);
  if ( !*a2 )
    return 0xFFFFFFFFLL;
  *v10 = 40LL;
  memset(*a2, 0, 0x28uLL);
  v7 = EVP_get_digestbyname("sha1");
  EVP_DigestInit(&v13, v7);
  for ( i = 0; i < v9; ++i )
    EVP_DigestUpdate(&v13, *(_QWORD *)(16LL * i + v8), *(_QWORD *)(16LL * i + v8 + 8));
  EVP_DigestFinal(&v13, &v14, 0LL);
  if ( !(unsigned int)sub_28CF7(v12, (__int64)&v14, 20LL, (char *)*a2) )
    return 0LL;
  (*(void (__fastcall **)(void *, __int64))(a1 + 24))(*a2, a1);
  return 0xFFFFFFFFLL;
}
// 4E70: using guessed type __int64 __fastcall EVP_get_digestbyname(_QWORD);
// 4EC0: using guessed type __int64 __fastcall EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 4F20: using guessed type __int64 __fastcall EVP_DigestInit(_QWORD, _QWORD);
// 5270: using guessed type __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);

//----- (000000000000AC01) ----------------------------------------------------
__int64 __fastcall sub_AC01(__int64 a1, _QWORD *a2)
{
  DSA_free(*a2);
  *a2 = 0LL;
  return 0LL;
}
// 4DD0: using guessed type __int64 __fastcall DSA_free(_QWORD);

//----- (000000000000AC3A) ----------------------------------------------------
char ***libssh2_hostkey_methods()
{
  return off_232490;
}
// 232490: using guessed type char **off_232490[2];

//----- (000000000000AC47) ----------------------------------------------------
signed __int64 __fastcall libssh2_hostkey_hash(__int64 a1, int a2)
{
  if ( a2 == 1 )
    return a1 + 188;
  if ( a2 == 2 )
    return a1 + 204;
  return 0LL;
}

//----- (000000000000AC80) ----------------------------------------------------
signed __int64 __fastcall sub_AC80(const void *a1, unsigned __int64 a2)
{
  char s1; // [rsp+12h] [rbp-1Eh]
  char v4; // [rsp+13h] [rbp-1Dh]
  char v5; // [rsp+14h] [rbp-1Ch]
  char v6; // [rsp+15h] [rbp-1Bh]
  char v7; // [rsp+16h] [rbp-1Ah]
  char v8; // [rsp+17h] [rbp-19h]
  char v9; // [rsp+18h] [rbp-18h]
  char v10; // [rsp+19h] [rbp-17h]
  char v11; // [rsp+1Ah] [rbp-16h]
  char v12; // [rsp+1Bh] [rbp-15h]
  char v13; // [rsp+1Ch] [rbp-14h]
  char v14; // [rsp+1Dh] [rbp-13h]
  char v15; // [rsp+1Eh] [rbp-12h]
  char v16; // [rsp+1Fh] [rbp-11h]
  char v17; // [rsp+20h] [rbp-10h]
  char v18; // [rsp+21h] [rbp-Fh]
  char v19; // [rsp+22h] [rbp-Eh]
  char v20; // [rsp+23h] [rbp-Dh]
  char v21; // [rsp+24h] [rbp-Ch]
  char v22; // [rsp+25h] [rbp-Bh]
  char v23; // [rsp+26h] [rbp-Ah]
  char v24; // [rsp+27h] [rbp-9h]
  unsigned __int64 v25; // [rsp+28h] [rbp-8h]

  v25 = __readfsqword(0x28u);
  s1 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 7;
  v7 = 115;
  v8 = 115;
  v9 = 104;
  v10 = 45;
  v11 = 114;
  v12 = 115;
  v13 = 97;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 7;
  v18 = 115;
  v19 = 115;
  v20 = 104;
  v21 = 45;
  v22 = 100;
  v23 = 115;
  v24 = 115;
  if ( a2 <= 0xA )
    return 0LL;
  if ( !memcmp(&s1, a1, 0xBuLL) )
    return 1LL;
  if ( !memcmp(&v14, a1, 0xBuLL) )
    return 2LL;
  return 0LL;
}

//----- (000000000000AD66) ----------------------------------------------------
__int64 __fastcall libssh2_session_hostkey(__int64 a1, _QWORD *a2, _DWORD *a3)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 184) )
  {
    if ( a2 )
      *a2 = *(unsigned int *)(a1 + 184);
    if ( a3 )
      *a3 = sub_AC80(*(const void **)(a1 + 176), *(unsigned int *)(a1 + 184));
    result = *(_QWORD *)(a1 + 176);
  }
  else
  {
    if ( a2 )
      *a2 = 0LL;
    result = 0LL;
  }
  return result;
}

//----- (000000000000ADF9) ----------------------------------------------------
signed __int64 __fastcall sub_ADF9(size_t a1, signed __int64 a2, __int64 a3, unsigned int a4, char a5, unsigned __int8 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  int v13; // eax
  size_t v14; // rax
  int v15; // eax
  size_t v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  unsigned __int8 v23; // [rsp+1Ch] [rbp-E4h]
  char v24; // [rsp+20h] [rbp-E0h]
  unsigned int v25; // [rsp+24h] [rbp-DCh]
  __int64 v26; // [rsp+28h] [rbp-D8h]
  int v27; // [rsp+4Ch] [rbp-B4h]
  int v28; // [rsp+50h] [rbp-B0h]
  unsigned int v29; // [rsp+54h] [rbp-ACh]
  unsigned int v30; // [rsp+58h] [rbp-A8h]
  int v31; // [rsp+5Ch] [rbp-A4h]
  __int128 s; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v33; // [rsp+70h] [rbp-90h]
  unsigned __int64 v34; // [rsp+78h] [rbp-88h]
  __int128 v35; // [rsp+80h] [rbp-80h]
  unsigned __int64 v36; // [rsp+90h] [rbp-70h]
  unsigned __int64 v37; // [rsp+98h] [rbp-68h]
  __int128 v38; // [rsp+A0h] [rbp-60h]
  __int128 v39; // [rsp+B0h] [rbp-50h]
  char v40; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v41; // [rsp+F8h] [rbp-8h]

  v26 = a3;
  v25 = a4;
  v24 = a5;
  v23 = a6;
  v41 = __readfsqword(0x28u);
  v29 = 0;
  if ( !*(_DWORD *)a9 )
  {
    *(_QWORD *)(a9 + 8) = 0LL;
    *(_QWORD *)(a9 + 16) = 0LL;
    *(_QWORD *)(a9 + 136) = 0LL;
    *(_QWORD *)(a9 + 80) = BN_CTX_new();
    *(_QWORD *)(a9 + 88) = BN_new(a1, a2);
    *(_QWORD *)(a9 + 96) = BN_new(a1, a2);
    *(_QWORD *)(a9 + 104) = BN_new(a1, a2);
    *(_QWORD *)(a9 + 112) = BN_new(a1, a2);
    memset((void *)(a9 + 224), 0, 0x10uLL);
    BN_rand(*(_QWORD *)(a9 + 88), v25, 0LL, 0xFFFFFFFFLL);
    BN_mod_exp(*(_QWORD *)(a9 + 96), a2, *(_QWORD *)(a9 + 88), v26, *(_QWORD *)(a9 + 80));
    *(_QWORD *)(a9 + 56) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a9 + 96)) + 7) / 8 + 6;
    if ( BN_num_bits(*(_QWORD *)(a9 + 96)) & 7 )
      --*(_QWORD *)(a9 + 56);
    *(_QWORD *)(a9 + 8) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a9 + 56), a1);
    if ( !*(_QWORD *)(a9 + 8) )
    {
      a2 = 4294967290LL;
      v29 = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Out of memory error");
      goto LABEL_165;
    }
    **(_BYTE **)(a9 + 8) = v24;
    sub_1017A((_BYTE *)(*(_QWORD *)(a9 + 8) + 1LL), *(unsigned __int64 *)(a9 + 56) - 5);
    if ( BN_num_bits(*(_QWORD *)(a9 + 96)) & 7 )
    {
      a2 = *(_QWORD *)(a9 + 8) + 5LL;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a9 + 8) + 5LL) = 0;
      a2 = *(_QWORD *)(a9 + 8) + 6LL;
    }
    BN_bn2bin(*(_QWORD *)(a9 + 96), a2);
    *(_DWORD *)a9 = 2;
  }
  if ( *(_DWORD *)a9 == 2 )
  {
    a2 = *(_QWORD *)(a9 + 8);
    v30 = sub_24D86(a1, (const void *)a2, *(_QWORD *)(a9 + 56), 0LL, 0LL);
    if ( v30 == -37 )
      return 4294967259LL;
    if ( v30 )
    {
      a2 = v30;
      v29 = sub_FF92(a1, v30, (__int64)"Unable to send KEX init message");
      goto LABEL_165;
    }
    *(_DWORD *)a9 = 3;
  }
  if ( *(_DWORD *)a9 == 3 )
  {
    if ( *(_BYTE *)(a1 + 128) & 1 )
    {
      a2 = a9 + 240;
      v31 = sub_1259A(a1, (_DWORD *)(a9 + 240));
      if ( v31 == -37 )
        return 4294967259LL;
      if ( v31 <= 0 )
      {
        v29 = v31;
        goto LABEL_165;
      }
      *(_BYTE *)(a1 + 128) &= 0xFEu;
    }
    *(_DWORD *)a9 = 4;
  }
  if ( *(_DWORD *)a9 == 4 )
  {
    v30 = sub_12422(a1, v23, (_QWORD *)(a9 + 16), (_QWORD *)(a9 + 64), 0, 0LL, 0LL, a9 + 224);
    if ( v30 == -37 )
      return 4294967259LL;
    if ( v30 )
    {
      a2 = 4294967287LL;
      v29 = sub_FF92(a1, 0xFFFFFFF7, (__int64)"Timed out waiting for KEX reply");
      goto LABEL_165;
    }
    *(_QWORD *)(a9 + 120) = *(_QWORD *)(a9 + 16) + 1LL;
    *(_DWORD *)(a1 + 184) = sub_10071(*(unsigned int **)(a9 + 120));
    *(_QWORD *)(a9 + 120) += 4LL;
    *(_QWORD *)(a1 + 176) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(unsigned int *)(a1 + 184), a1);
    if ( !*(_QWORD *)(a1 + 176) )
    {
      a2 = 4294967290LL;
      v29 = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for a copy of the host key");
      goto LABEL_165;
    }
    memcpy(*(void **)(a1 + 176), *(const void **)(a9 + 120), *(unsigned int *)(a1 + 184));
    *(_QWORD *)(a9 + 120) += *(unsigned int *)(a1 + 184);
    v10 = EVP_get_digestbyname("md5");
    EVP_DigestInit(&v40, v10);
    EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
    EVP_DigestFinal(&v40, a1 + 188, 0LL);
    v11 = EVP_get_digestbyname("sha1");
    EVP_DigestInit(&v40, v11);
    EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
    EVP_DigestFinal(&v40, a1 + 204, 0LL);
    if ( (*(unsigned int (__fastcall **)(size_t, _QWORD, _QWORD, size_t))(*(_QWORD *)(a1 + 160) + 16LL))(
           a1,
           *(_QWORD *)(a1 + 176),
           *(unsigned int *)(a1 + 184),
           a1 + 168) )
    {
      a2 = 4294967286LL;
      v29 = sub_FF92(a1, 0xFFFFFFF6, (__int64)"Unable to initialize hostkey importer");
      goto LABEL_165;
    }
    *(_QWORD *)(a9 + 152) = (unsigned int)sub_10071(*(unsigned int **)(a9 + 120));
    *(_QWORD *)(a9 + 120) += 4LL;
    *(_QWORD *)(a9 + 128) = *(_QWORD *)(a9 + 120);
    *(_QWORD *)(a9 + 120) += *(_QWORD *)(a9 + 152);
    BN_bin2bn(*(_QWORD *)(a9 + 128), (unsigned int)*(_QWORD *)(a9 + 152), *(_QWORD *)(a9 + 104));
    *(_QWORD *)(a9 + 168) = (unsigned int)sub_10071(*(unsigned int **)(a9 + 120));
    *(_QWORD *)(a9 + 120) += 4LL;
    *(_QWORD *)(a9 + 144) = *(_QWORD *)(a9 + 120);
    BN_mod_exp(*(_QWORD *)(a9 + 112), *(_QWORD *)(a9 + 104), *(_QWORD *)(a9 + 88), v26, *(_QWORD *)(a9 + 80));
    *(_QWORD *)(a9 + 160) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a9 + 112)) + 7) / 8 + 5;
    if ( BN_num_bits(*(_QWORD *)(a9 + 112)) & 7 )
      --*(_QWORD *)(a9 + 160);
    *(_QWORD *)(a9 + 136) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a9 + 160), a1);
    if ( !*(_QWORD *)(a9 + 136) )
    {
      a2 = 4294967290LL;
      v29 = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate buffer for K");
      goto LABEL_165;
    }
    sub_1017A(*(_BYTE **)(a9 + 136), *(unsigned __int64 *)(a9 + 160) - 4);
    if ( BN_num_bits(*(_QWORD *)(a9 + 112)) & 7 )
    {
      BN_bn2bin(*(_QWORD *)(a9 + 112), *(_QWORD *)(a9 + 136) + 4LL);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a9 + 136) + 4LL) = 0;
      BN_bn2bin(*(_QWORD *)(a9 + 112), *(_QWORD *)(a9 + 136) + 5LL);
    }
    v12 = EVP_get_digestbyname("sha1");
    EVP_DigestInit(a9 + 176, v12);
    if ( *(_QWORD *)(a1 + 336) )
    {
      v13 = strlen(*(const char **)(a1 + 336));
      sub_1017A((_BYTE *)(a9 + 32), v13 - 2);
      EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
      v14 = strlen(*(const char **)(a1 + 336));
      EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a1 + 336), v14 - 2);
    }
    else
    {
      sub_1017A((_BYTE *)(a9 + 32), 25);
      EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
      EVP_DigestUpdate(a9 + 176, "SSH-2.0-libssh2_1.4.3_DEV", 25LL);
    }
    v15 = strlen(*(const char **)(a1 + 224));
    sub_1017A((_BYTE *)(a9 + 32), v15);
    EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
    v16 = strlen(*(const char **)(a1 + 224));
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a1 + 224), v16);
    sub_1017A((_BYTE *)(a9 + 32), *(_QWORD *)(a1 + 352));
    EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 352));
    sub_1017A((_BYTE *)(a9 + 32), *(_QWORD *)(a1 + 240));
    EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a1 + 232), *(_QWORD *)(a1 + 240));
    sub_1017A((_BYTE *)(a9 + 32), *(_DWORD *)(a1 + 184));
    EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
    if ( v24 == 32 )
    {
      sub_1017A((_BYTE *)(a9 + 32), 1024);
      sub_1017A((_BYTE *)(a9 + 36), 1536);
      sub_1017A((_BYTE *)(a9 + 40), 2048);
      EVP_DigestUpdate(a9 + 176, a9 + 32, 12LL);
    }
    if ( a7 )
      EVP_DigestUpdate(a9 + 176, a7, a8);
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a9 + 8) + 1LL, *(_QWORD *)(a9 + 56) - 1LL);
    sub_1017A((_BYTE *)(a9 + 32), *(_QWORD *)(a9 + 152));
    EVP_DigestUpdate(a9 + 176, a9 + 32, 4LL);
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a9 + 128), *(_QWORD *)(a9 + 152));
    EVP_DigestUpdate(a9 + 176, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
    EVP_DigestFinal(a9 + 176, a9 + 32, 0LL);
    a2 = *(_QWORD *)(a9 + 144);
    if ( (*(unsigned int (__fastcall **)(size_t, signed __int64, _QWORD, __int64, signed __int64, size_t))(*(_QWORD *)(a1 + 160) + 32LL))(
           a1,
           a2,
           *(_QWORD *)(a9 + 168),
           a9 + 32,
           20LL,
           a1 + 168) )
    {
      a2 = 4294967285LL;
      v29 = sub_FF92(a1, 0xFFFFFFF5, (__int64)"Unable to verify hostkey signature");
      goto LABEL_165;
    }
    *(_BYTE *)(a9 + 52) = 21;
    *(_DWORD *)a9 = 5;
  }
  if ( *(_DWORD *)a9 == 5 )
  {
    a2 = a9 + 52;
    v30 = sub_24D86(a1, (const void *)(a9 + 52), 1LL, 0LL, 0LL);
    if ( v30 == -37 )
      return 4294967259LL;
    if ( v30 )
    {
      a2 = v30;
      v29 = sub_FF92(a1, v30, (__int64)"Unable to send NEWKEYS message");
      goto LABEL_165;
    }
    *(_DWORD *)a9 = 6;
  }
  if ( *(_DWORD *)a9 == 6 )
  {
    v30 = sub_12422(a1, 0x15u, (_QWORD *)(a9 + 24), (_QWORD *)(a9 + 72), 0, 0LL, 0LL, a9 + 224);
    if ( v30 == -37 )
      return 4294967259LL;
    if ( !v30 )
    {
      *(_DWORD *)(a1 + 104) |= 2u;
      a2 = a1;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a9 + 24), a1);
      if ( !*(_QWORD *)(a1 + 136) )
      {
        *(_QWORD *)(a1 + 136) = (*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(20LL, a1);
        if ( !*(_QWORD *)(a1 + 136) )
        {
          a2 = 4294967290LL;
          v29 = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate buffer for SHA digest");
          goto LABEL_165;
        }
        a2 = a9 + 32;
        memcpy(*(void **)(a1 + 136), (const void *)(a9 + 32), 0x14uLL);
        *(_DWORD *)(a1 + 144) = 20;
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 360) + 48LL) )
      {
        a2 = a1 + 368;
        (*(void (__fastcall **)(size_t, size_t))(*(_QWORD *)(a1 + 360) + 48LL))(a1, a1 + 368);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 360) + 32LL) )
      {
        *(_QWORD *)&s = 0LL;
        v27 = 0;
        v28 = 0;
        v33 = 0LL;
        a2 = a1;
        s = (unsigned __int64)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                *(_DWORD *)(*(_QWORD *)(a1 + 360) + 12LL) + 20,
                                a1);
        if ( (_QWORD)s )
        {
          while ( v33 < *(signed int *)(*(_QWORD *)(a1 + 360) + 12LL) )
          {
            v17 = EVP_get_digestbyname("sha1");
            EVP_DigestInit(&v40, v17);
            EVP_DigestUpdate(&v40, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
            EVP_DigestUpdate(&v40, a9 + 32, 20LL);
            if ( v33 )
            {
              EVP_DigestUpdate(&v40, s, v33);
            }
            else
            {
              EVP_DigestUpdate(&v40, "A", 1LL);
              EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = s + v33;
            EVP_DigestFinal(&v40, s + v33, 0LL);
            v33 += 20LL;
          }
        }
        if ( !(_QWORD)s )
        {
          v29 = -1;
          goto LABEL_165;
        }
        v34 = 0LL;
        if ( !*((_QWORD *)&s + 1) )
          *((_QWORD *)&s + 1) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 360) + 16LL) + 20,
                                  a1);
        if ( *((_QWORD *)&s + 1) )
        {
          while ( v34 < *(signed int *)(*(_QWORD *)(a1 + 360) + 16LL) )
          {
            v18 = EVP_get_digestbyname("sha1");
            EVP_DigestInit(&v40, v18);
            EVP_DigestUpdate(&v40, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
            EVP_DigestUpdate(&v40, a9 + 32, 20LL);
            if ( v34 )
            {
              EVP_DigestUpdate(&v40, *((_QWORD *)&s + 1), v34);
            }
            else
            {
              EVP_DigestUpdate(&v40, "C", 1LL);
              EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(&v40, *((_QWORD *)&s + 1) + v34, 0LL);
            v34 += 20LL;
          }
        }
        if ( !*((_QWORD *)&s + 1) )
        {
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(s, a1);
          v29 = -5;
          goto LABEL_165;
        }
        a2 = *(_QWORD *)(a1 + 360);
        if ( (*(unsigned int (__fastcall **)(size_t, signed __int64, _QWORD, int *, _QWORD, int *, signed __int64, size_t))(*(_QWORD *)(a1 + 360) + 32LL))(
               a1,
               a2,
               s,
               &v27,
               *((_QWORD *)&s + 1),
               &v28,
               1LL,
               a1 + 368) )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(s, a1);
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*((_QWORD *)&s + 1), a1);
          v29 = -5;
          goto LABEL_165;
        }
        if ( v27 )
        {
          memset((void *)s, 0, *(signed int *)(*(_QWORD *)(a1 + 360) + 12LL));
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(s, a1);
        }
        if ( v28 )
        {
          memset(*((void **)&s + 1), 0, *(signed int *)(*(_QWORD *)(a1 + 360) + 16LL));
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*((_QWORD *)&s + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 248) + 48LL) )
      {
        a2 = a1 + 256;
        (*(void (__fastcall **)(size_t, size_t))(*(_QWORD *)(a1 + 248) + 48LL))(a1, a1 + 256);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 248) + 32LL) )
      {
        *(_QWORD *)&v35 = 0LL;
        v27 = 0;
        v28 = 0;
        v36 = 0LL;
        a2 = a1;
        v35 = (unsigned __int64)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 248) + 12LL) + 20,
                                  a1);
        if ( (_QWORD)v35 )
        {
          while ( v36 < *(signed int *)(*(_QWORD *)(a1 + 248) + 12LL) )
          {
            v19 = EVP_get_digestbyname("sha1");
            EVP_DigestInit(&v40, v19);
            EVP_DigestUpdate(&v40, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
            EVP_DigestUpdate(&v40, a9 + 32, 20LL);
            if ( v36 )
            {
              EVP_DigestUpdate(&v40, v35, v36);
            }
            else
            {
              EVP_DigestUpdate(&v40, "B", 1LL);
              EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v35 + v36;
            EVP_DigestFinal(&v40, v35 + v36, 0LL);
            v36 += 20LL;
          }
        }
        if ( !(_QWORD)v35 )
        {
          v29 = -5;
          goto LABEL_165;
        }
        v37 = 0LL;
        if ( !*((_QWORD *)&v35 + 1) )
          *((_QWORD *)&v35 + 1) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 248) + 16LL) + 20,
                                    a1);
        if ( *((_QWORD *)&v35 + 1) )
        {
          while ( v37 < *(signed int *)(*(_QWORD *)(a1 + 248) + 16LL) )
          {
            v20 = EVP_get_digestbyname("sha1");
            EVP_DigestInit(&v40, v20);
            EVP_DigestUpdate(&v40, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
            EVP_DigestUpdate(&v40, a9 + 32, 20LL);
            if ( v37 )
            {
              EVP_DigestUpdate(&v40, *((_QWORD *)&v35 + 1), v37);
            }
            else
            {
              EVP_DigestUpdate(&v40, "D", 1LL);
              EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(&v40, *((_QWORD *)&v35 + 1) + v37, 0LL);
            v37 += 20LL;
          }
        }
        if ( !*((_QWORD *)&v35 + 1) )
        {
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(v35, a1);
          v29 = -5;
          goto LABEL_165;
        }
        a2 = *(_QWORD *)(a1 + 248);
        if ( (*(unsigned int (__fastcall **)(size_t, signed __int64, _QWORD, int *, _QWORD, int *, _QWORD, size_t))(*(_QWORD *)(a1 + 248) + 32LL))(
               a1,
               a2,
               v35,
               &v27,
               *((_QWORD *)&v35 + 1),
               &v28,
               0LL,
               a1 + 256) )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(v35, a1);
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*((_QWORD *)&v35 + 1), a1);
          v29 = -5;
          goto LABEL_165;
        }
        if ( v27 )
        {
          memset((void *)v35, 0, *(signed int *)(*(_QWORD *)(a1 + 248) + 12LL));
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(v35, a1);
        }
        if ( v28 )
        {
          memset(*((void **)&v35 + 1), 0, *(signed int *)(*(_QWORD *)(a1 + 248) + 16LL));
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*((_QWORD *)&v35 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 376) + 32LL) )
      {
        a2 = a1 + 392;
        (*(void (__fastcall **)(size_t, size_t))(*(_QWORD *)(a1 + 376) + 32LL))(a1, a1 + 392);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 376) + 16LL) )
      {
        *(_QWORD *)&v38 = 0LL;
        v28 = 0;
        a2 = a1;
        v38 = (unsigned __int64)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 376) + 12LL) + 20,
                                  a1);
        if ( (_QWORD)v38 )
        {
          while ( *((_QWORD *)&v38 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 376) + 12LL) )
          {
            v21 = EVP_get_digestbyname("sha1");
            EVP_DigestInit(&v40, v21);
            EVP_DigestUpdate(&v40, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
            EVP_DigestUpdate(&v40, a9 + 32, 20LL);
            if ( *((_QWORD *)&v38 + 1) )
            {
              EVP_DigestUpdate(&v40, v38, *((_QWORD *)&v38 + 1));
            }
            else
            {
              EVP_DigestUpdate(&v40, "E", 1LL);
              EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v38 + *((_QWORD *)&v38 + 1);
            EVP_DigestFinal(&v40, v38 + *((_QWORD *)&v38 + 1), 0LL);
            *((_QWORD *)&v38 + 1) += 20LL;
          }
        }
        if ( !(_QWORD)v38 )
        {
          v29 = -5;
          goto LABEL_165;
        }
        a2 = v38;
        (*(void (__fastcall **)(size_t, _QWORD, int *, size_t))(*(_QWORD *)(a1 + 376) + 16LL))(a1, v38, &v28, a1 + 392);
        if ( v28 )
        {
          memset((void *)v38, 0, *(signed int *)(*(_QWORD *)(a1 + 376) + 12LL));
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(v38, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 264) + 32LL) )
      {
        a2 = a1 + 280;
        (*(void (__fastcall **)(size_t, size_t))(*(_QWORD *)(a1 + 264) + 32LL))(a1, a1 + 280);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 264) + 16LL) )
      {
        *(_QWORD *)&v39 = 0LL;
        v28 = 0;
        a2 = a1;
        v39 = (unsigned __int64)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 264) + 12LL) + 20,
                                  a1);
        if ( (_QWORD)v39 )
        {
          while ( *((_QWORD *)&v39 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 264) + 12LL) )
          {
            v22 = EVP_get_digestbyname("sha1");
            EVP_DigestInit(&v40, v22);
            EVP_DigestUpdate(&v40, *(_QWORD *)(a9 + 136), *(_QWORD *)(a9 + 160));
            EVP_DigestUpdate(&v40, a9 + 32, 20LL);
            if ( *((_QWORD *)&v39 + 1) )
            {
              EVP_DigestUpdate(&v40, v39, *((_QWORD *)&v39 + 1));
            }
            else
            {
              EVP_DigestUpdate(&v40, "F", 1LL);
              EVP_DigestUpdate(&v40, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v39 + *((_QWORD *)&v39 + 1);
            EVP_DigestFinal(&v40, v39 + *((_QWORD *)&v39 + 1), 0LL);
            *((_QWORD *)&v39 + 1) += 20LL;
          }
        }
        if ( !(_QWORD)v39 )
        {
          v29 = -5;
          goto LABEL_165;
        }
        a2 = v39;
        (*(void (__fastcall **)(size_t, _QWORD, int *, size_t))(*(_QWORD *)(a1 + 264) + 16LL))(a1, v39, &v28, a1 + 280);
        if ( v28 )
        {
          memset((void *)v39, 0, *(signed int *)(*(_QWORD *)(a1 + 264) + 12LL));
          a2 = a1;
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(v39, a1);
        }
      }
      if ( *(_QWORD *)(a1 + 400) && *(_QWORD *)(*(_QWORD *)(a1 + 400) + 40LL) )
      {
        a2 = 1LL;
        (*(void (__fastcall **)(size_t, signed __int64, size_t))(*(_QWORD *)(a1 + 400) + 40LL))(a1, 1LL, a1 + 408);
      }
      if ( *(_QWORD *)(a1 + 400)
        && *(_QWORD *)(*(_QWORD *)(a1 + 400) + 16LL)
        && (a2 = 1LL,
            (*(unsigned int (__fastcall **)(size_t, signed __int64, size_t))(*(_QWORD *)(a1 + 400) + 16LL))(
              a1,
              1LL,
              a1 + 408)) )
      {
        v29 = -5;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 288) && *(_QWORD *)(*(_QWORD *)(a1 + 288) + 40LL) )
        {
          a2 = 0LL;
          (*(void (__fastcall **)(size_t, _QWORD, size_t))(*(_QWORD *)(a1 + 288) + 40LL))(a1, 0LL, a1 + 296);
        }
        if ( *(_QWORD *)(a1 + 288) )
        {
          if ( *(_QWORD *)(*(_QWORD *)(a1 + 288) + 16LL) )
          {
            a2 = 0LL;
            if ( (*(unsigned int (__fastcall **)(size_t, _QWORD, size_t))(*(_QWORD *)(a1 + 288) + 16LL))(
                   a1,
                   0LL,
                   a1 + 296) )
            {
              v29 = -5;
            }
          }
        }
      }
      goto LABEL_165;
    }
    a2 = v30;
    v29 = sub_FF92(a1, v30, (__int64)"Timed out waiting for NEWKEYS");
  }
LABEL_165:
  BN_clear_free(*(_QWORD *)(a9 + 88));
  *(_QWORD *)(a9 + 88) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 96));
  *(_QWORD *)(a9 + 96) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 104));
  *(_QWORD *)(a9 + 104) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 112));
  *(_QWORD *)(a9 + 112) = 0LL;
  BN_CTX_free(*(_QWORD *)(a9 + 80), a2);
  *(_QWORD *)(a9 + 80) = 0LL;
  if ( *(_QWORD *)(a9 + 8) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a9 + 8), a1);
    *(_QWORD *)(a9 + 8) = 0LL;
  }
  if ( *(_QWORD *)(a9 + 16) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a9 + 16), a1);
    *(_QWORD *)(a9 + 16) = 0LL;
  }
  if ( *(_QWORD *)(a9 + 136) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a9 + 136), a1);
    *(_QWORD *)(a9 + 136) = 0LL;
  }
  *(_DWORD *)a9 = 0;
  return v29;
}
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 4E30: using guessed type __int64 __fastcall BN_bn2bin(_QWORD, _QWORD);
// 4E70: using guessed type __int64 __fastcall EVP_get_digestbyname(_QWORD);
// 4EC0: using guessed type __int64 __fastcall EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 4F20: using guessed type __int64 __fastcall EVP_DigestInit(_QWORD, _QWORD);
// 4F80: using guessed type __int64 __fastcall BN_rand(_QWORD, _QWORD, _QWORD, _QWORD);
// 4FF0: using guessed type __int64 BN_CTX_new(void);
// 5020: using guessed type __int64 __fastcall BN_CTX_free(_QWORD, _QWORD);
// 50A0: using guessed type __int64 __fastcall BN_clear_free(_QWORD);
// 5140: using guessed type __int64 __fastcall BN_num_bits(_QWORD);
// 5180: using guessed type __int64 __fastcall BN_mod_exp(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 5270: using guessed type __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);

//----- (000000000000D237) ----------------------------------------------------
signed __int64 __fastcall sub_D237(size_t a1, __int64 a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    BN_set_word(*(_QWORD *)(a2 + 280), 2LL);
    BN_bin2bn(&unk_2A8A0, 128LL, *(_QWORD *)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v3 = sub_ADF9(a1, *(_QWORD *)(a2 + 280), *(_QWORD *)(a2 + 272), 0x80u, 30, 0x1Fu, 0LL, 0LL, a2 + 24);
  if ( v3 == -37 )
    return 4294967259LL;
  BN_clear_free(*(_QWORD *)(a2 + 272));
  *(_QWORD *)(a2 + 272) = 0LL;
  BN_clear_free(*(_QWORD *)(a2 + 280));
  *(_QWORD *)(a2 + 280) = 0LL;
  *(_DWORD *)a2 = 0;
  return v3;
}
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 5070: using guessed type __int64 __fastcall BN_set_word(_QWORD, _QWORD);
// 50A0: using guessed type __int64 __fastcall BN_clear_free(_QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);

//----- (000000000000D361) ----------------------------------------------------
signed __int64 __fastcall sub_D361(size_t a1, __int64 a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    BN_set_word(*(_QWORD *)(a2 + 280), 2LL);
    BN_bin2bn(&unk_2A920, 256LL, *(_QWORD *)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v3 = sub_ADF9(a1, *(_QWORD *)(a2 + 280), *(_QWORD *)(a2 + 272), 0x100u, 30, 0x1Fu, 0LL, 0LL, a2 + 24);
  if ( v3 == -37 )
    return 4294967259LL;
  *(_DWORD *)a2 = 0;
  BN_clear_free(*(_QWORD *)(a2 + 272));
  *(_QWORD *)(a2 + 272) = 0LL;
  BN_clear_free(*(_QWORD *)(a2 + 280));
  *(_QWORD *)(a2 + 280) = 0LL;
  return v3;
}
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 5070: using guessed type __int64 __fastcall BN_set_word(_QWORD, _QWORD);
// 50A0: using guessed type __int64 __fastcall BN_clear_free(_QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);

//----- (000000000000D48B) ----------------------------------------------------
signed __int64 __fastcall sub_D48B(size_t a1, __int64 a2)
{
  unsigned int *v3; // ST38_8
  __int64 v4; // ST40_8
  unsigned int *v5; // ST38_8
  __int64 v6; // ST48_8
  unsigned int v7; // [rsp+10h] [rbp-20h]
  unsigned int v8; // [rsp+14h] [rbp-1Ch]
  unsigned int v9; // [rsp+14h] [rbp-1Ch]

  v7 = 0;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    *(_BYTE *)(a2 + 288) = 34;
    sub_1017A((_BYTE *)(a2 + 289), 1024);
    sub_1017A((_BYTE *)(a2 + 293), 1536);
    sub_1017A((_BYTE *)(a2 + 297), 2048);
    *(_QWORD *)(a2 + 312) = 13LL;
    *(_DWORD *)a2 = 2;
  }
  if ( *(_DWORD *)a2 == 2 )
  {
    v8 = sub_24D86(a1, (const void *)(a2 + 288), *(_QWORD *)(a2 + 312), 0LL, 0LL);
    if ( v8 == -37 )
      return 4294967259LL;
    if ( v8 )
    {
      v7 = sub_FF92(a1, v8, (__int64)"Unable to send Group Exchange Request");
      goto LABEL_19;
    }
    *(_DWORD *)a2 = 3;
  }
  if ( *(_DWORD *)a2 == 3 )
  {
    v9 = sub_12422(a1, 0x1Fu, (_QWORD *)(a2 + 304), (_QWORD *)(a2 + 320), 0, 0LL, 0LL, a2 + 8);
    if ( v9 == -37 )
      return 4294967259LL;
    if ( v9 )
    {
      v7 = sub_FF92(a1, v9, (__int64)"Timeout waiting for GEX_GROUP reply");
      goto LABEL_19;
    }
    *(_DWORD *)a2 = 4;
  }
  if ( *(_DWORD *)a2 == 4 )
  {
    v3 = (unsigned int *)(*(_QWORD *)(a2 + 304) + 1LL);
    v4 = (unsigned int)sub_10071(v3);
    ++v3;
    BN_bin2bn(v3, v4, *(_QWORD *)(a2 + 272));
    v5 = (unsigned int *)((char *)v3 + v4);
    v6 = (unsigned int)sub_10071(v5);
    BN_bin2bn(v5 + 1, v6, *(_QWORD *)(a2 + 280));
    v7 = sub_ADF9(
           a1,
           *(_QWORD *)(a2 + 280),
           *(_QWORD *)(a2 + 272),
           v4,
           32,
           0x21u,
           *(_QWORD *)(a2 + 304) + 1LL,
           *(_QWORD *)(a2 + 320) - 1LL,
           a2 + 24);
    if ( v7 == -37 )
      return 4294967259LL;
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a2 + 304), a1);
  }
LABEL_19:
  *(_DWORD *)a2 = 0;
  BN_clear_free(*(_QWORD *)(a2 + 280));
  *(_QWORD *)(a2 + 280) = 0LL;
  BN_clear_free(*(_QWORD *)(a2 + 272));
  *(_QWORD *)(a2 + 272) = 0LL;
  return v7;
}
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 50A0: using guessed type __int64 __fastcall BN_clear_free(_QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);

//----- (000000000000D7D9) ----------------------------------------------------
signed __int64 __fastcall sub_D7D9(const char ***a1)
{
  const char ***v2; // [rsp+8h] [rbp-18h]
  __int64 v3; // [rsp+18h] [rbp-8h]

  v2 = a1;
  v3 = 0LL;
  if ( !a1 || !*a1 )
    return 0LL;
  while ( *v2 && **v2 )
  {
    v3 += strlen(**v2) + 1;
    ++v2;
  }
  return v3 - 1;
}

//----- (000000000000D855) ----------------------------------------------------
signed __int64 __fastcall sub_D855(_BYTE *a1, __int64 a2, const char ***a3)
{
  int v4; // ST2C_4
  char *v5; // rax
  const char ***v6; // [rsp+8h] [rbp-28h]
  char *dest; // [rsp+18h] [rbp-18h]

  v6 = a3;
  sub_1017A(a1, a2);
  dest = a1 + 4;
  if ( !v6 || !*v6 )
    return 4LL;
  while ( *v6 && **v6 )
  {
    v4 = strlen(**v6);
    memcpy(dest, **v6, v4);
    v5 = &dest[v4];
    dest = v5 + 1;
    *v5 = 44;
    ++v6;
  }
  return a2 + 4;
}

//----- (000000000000D912) ----------------------------------------------------
signed __int64 __fastcall sub_D912(__int64 a1)
{
  const char *v1; // rdi
  size_t v2; // rax
  char *v3; // rdi
  size_t v4; // rax
  char *v5; // rdi
  size_t v6; // rax
  size_t v7; // rax
  const char ***v8; // rax
  size_t v9; // rax
  char ***v10; // rax
  size_t v11; // rax
  char ***v12; // rax
  size_t v13; // rax
  char ***v14; // rax
  size_t v15; // rax
  char ***v16; // rax
  size_t v17; // rax
  size_t v18; // rax
  signed __int64 result; // rax
  signed __int64 v20; // rdi
  char *v21; // ST28_8
  char *v22; // rdi
  const char ***v23; // rax
  char *v24; // ST28_8
  char *v25; // rdi
  const char ***v26; // rax
  char *v27; // ST28_8
  const char ***v28; // rax
  char *v29; // ST28_8
  char ***v30; // rax
  char *v31; // ST28_8
  char ***v32; // rax
  char *v33; // ST28_8
  char ***v34; // rax
  char *v35; // ST28_8
  char ***v36; // rax
  char *v37; // ST28_8
  char *v38; // ST28_8
  __int64 v39; // [rsp+8h] [rbp-78h]
  unsigned int v40; // [rsp+14h] [rbp-6Ch]
  __int64 v41; // [rsp+18h] [rbp-68h]
  _BYTE *v42; // [rsp+20h] [rbp-60h]
  _BYTE *dest; // [rsp+28h] [rbp-58h]
  char *desta; // [rsp+28h] [rbp-58h]
  char *destb; // [rsp+28h] [rbp-58h]
  char *destc; // [rsp+28h] [rbp-58h]
  char *destd; // [rsp+28h] [rbp-58h]
  char *deste; // [rsp+28h] [rbp-58h]
  char *destf; // [rsp+28h] [rbp-58h]
  char *destg; // [rsp+28h] [rbp-58h]
  char *desth; // [rsp+28h] [rbp-58h]
  char *desti; // [rsp+28h] [rbp-58h]
  char *destj; // [rsp+28h] [rbp-58h]
  size_t v54; // [rsp+30h] [rbp-50h]
  size_t n; // [rsp+38h] [rbp-48h]
  size_t v56; // [rsp+40h] [rbp-40h]
  size_t v57; // [rsp+48h] [rbp-38h]
  size_t v58; // [rsp+50h] [rbp-30h]
  size_t v59; // [rsp+58h] [rbp-28h]
  size_t v60; // [rsp+60h] [rbp-20h]
  size_t v61; // [rsp+68h] [rbp-18h]
  size_t v62; // [rsp+70h] [rbp-10h]
  size_t v63; // [rsp+78h] [rbp-8h]

  v39 = a1;
  if ( *(_DWORD *)(a1 + 52288) )
  {
    v42 = *(_BYTE **)(a1 + 52296);
    v41 = *(_QWORD *)(a1 + 52304);
    *(_QWORD *)(a1 + 52296) = 0LL;
    *(_QWORD *)(a1 + 52304) = 0LL;
  }
  else
  {
    if ( *(_QWORD *)(a1 + 88) )
    {
      v1 = *(const char **)(a1 + 88);
      v2 = strlen(v1);
    }
    else
    {
      v1 = (const char *)off_2324C0;
      v2 = sub_D7D9((const char ***)off_2324C0);
    }
    n = v2;
    if ( *(_QWORD *)(v39 + 96) )
    {
      v3 = *(char **)(v39 + 96);
      v4 = strlen(v3);
    }
    else
    {
      v3 = (char *)libssh2_hostkey_methods(v1);
      v4 = sub_D7D9((const char ***)v3);
    }
    v54 = v4;
    if ( *(_QWORD *)(v39 + 416) )
    {
      v5 = *(char **)(v39 + 416);
      v6 = strlen(v5);
    }
    else
    {
      v5 = (char *)libssh2_crypt_methods(v3);
      v6 = sub_D7D9((const char ***)v5);
    }
    v56 = v6;
    if ( *(_QWORD *)(v39 + 304) )
    {
      v7 = strlen(*(const char **)(v39 + 304));
    }
    else
    {
      v8 = (const char ***)libssh2_crypt_methods(v5);
      v7 = sub_D7D9(v8);
    }
    v57 = v7;
    if ( *(_QWORD *)(v39 + 424) )
    {
      v9 = strlen(*(const char **)(v39 + 424));
    }
    else
    {
      v10 = sub_FF85();
      v9 = sub_D7D9((const char ***)v10);
    }
    v58 = v9;
    if ( *(_QWORD *)(v39 + 312) )
    {
      v11 = strlen(*(const char **)(v39 + 312));
    }
    else
    {
      v12 = sub_FF85();
      v11 = sub_D7D9((const char ***)v12);
    }
    v59 = v11;
    if ( *(_QWORD *)(v39 + 432) )
    {
      v13 = strlen(*(const char **)(v39 + 432));
    }
    else
    {
      v14 = sub_A1A9(v39);
      v13 = sub_D7D9((const char ***)v14);
    }
    v60 = v13;
    if ( *(_QWORD *)(v39 + 320) )
    {
      v15 = strlen(*(const char **)(v39 + 320));
    }
    else
    {
      v16 = sub_A1A9(v39);
      v15 = sub_D7D9((const char ***)v16);
    }
    v61 = v15;
    if ( *(_QWORD *)(v39 + 440) )
      v17 = strlen(*(const char **)(v39 + 440));
    else
      v17 = sub_D7D9(0LL);
    v62 = v17;
    if ( *(_QWORD *)(v39 + 328) )
      v18 = strlen(*(const char **)(v39 + 328));
    else
      v18 = sub_D7D9(0LL);
    v63 = v18;
    v41 = v62 + v59 + v58 + v61 + v60 + v57 + v56 + v54 + n + v18 + 62;
    v42 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, __int64))(v39 + 8))(v41, v39);
    if ( !v42 )
      return sub_FF92(v39, 0xFFFFFFFA, (__int64)"Unable to allocate memory");
    *v42 = 20;
    RAND_bytes(v42 + 1, 16LL);
    dest = v42 + 17;
    if ( *(_QWORD *)(v39 + 88) )
    {
      sub_1017A(dest, n);
      v20 = (signed __int64)(v42 + 21);
      memcpy(v42 + 21, *(const void **)(v39 + 88), n);
      desta = &v42[n + 21];
    }
    else
    {
      v20 = (signed __int64)(v42 + 17);
      desta = &dest[sub_D855(dest, n, (const char ***)off_2324C0)];
    }
    if ( *(_QWORD *)(v39 + 96) )
    {
      sub_1017A(desta, v54);
      v21 = desta + 4;
      v22 = v21;
      memcpy(v21, *(const void **)(v39 + 96), v54);
      destb = &v21[v54];
    }
    else
    {
      v23 = (const char ***)libssh2_hostkey_methods(v20);
      v22 = desta;
      destb = &desta[sub_D855(desta, v54, v23)];
    }
    if ( *(_QWORD *)(v39 + 416) )
    {
      sub_1017A(destb, v56);
      v24 = destb + 4;
      v25 = v24;
      memcpy(v24, *(const void **)(v39 + 416), v56);
      destc = &v24[v56];
    }
    else
    {
      v26 = (const char ***)libssh2_crypt_methods(v22);
      v25 = destb;
      destc = &destb[sub_D855(destb, v56, v26)];
    }
    if ( *(_QWORD *)(v39 + 304) )
    {
      sub_1017A(destc, v57);
      v27 = destc + 4;
      memcpy(v27, *(const void **)(v39 + 304), v57);
      destd = &v27[v57];
    }
    else
    {
      v28 = (const char ***)libssh2_crypt_methods(v25);
      destd = &destc[sub_D855(destc, v57, v28)];
    }
    if ( *(_QWORD *)(v39 + 424) )
    {
      sub_1017A(destd, v58);
      v29 = destd + 4;
      memcpy(v29, *(const void **)(v39 + 424), v58);
      deste = &v29[v58];
    }
    else
    {
      v30 = sub_FF85();
      deste = &destd[sub_D855(destd, v58, (const char ***)v30)];
    }
    if ( *(_QWORD *)(v39 + 312) )
    {
      sub_1017A(deste, v59);
      v31 = deste + 4;
      memcpy(v31, *(const void **)(v39 + 312), v59);
      destf = &v31[v59];
    }
    else
    {
      v32 = sub_FF85();
      destf = &deste[sub_D855(deste, v59, (const char ***)v32)];
    }
    if ( *(_QWORD *)(v39 + 432) )
    {
      sub_1017A(destf, v60);
      v33 = destf + 4;
      memcpy(v33, *(const void **)(v39 + 432), v60);
      destg = &v33[v60];
    }
    else
    {
      v34 = sub_A1A9(v39);
      destg = &destf[sub_D855(destf, v60, (const char ***)v34)];
    }
    if ( *(_QWORD *)(v39 + 320) )
    {
      sub_1017A(destg, v61);
      v35 = destg + 4;
      memcpy(v35, *(const void **)(v39 + 320), v61);
      desth = &v35[v61];
    }
    else
    {
      v36 = sub_A1A9(v39);
      desth = &destg[sub_D855(destg, v61, (const char ***)v36)];
    }
    if ( *(_QWORD *)(v39 + 440) )
    {
      sub_1017A(desth, v62);
      v37 = desth + 4;
      memcpy(v37, *(const void **)(v39 + 440), v62);
      desti = &v37[v62];
    }
    else
    {
      desti = &desth[sub_D855(desth, v62, 0LL)];
    }
    if ( *(_QWORD *)(v39 + 328) )
    {
      sub_1017A(desti, v63);
      v38 = desti + 4;
      memcpy(v38, *(const void **)(v39 + 328), v63);
      destj = &v38[v63];
    }
    else
    {
      destj = &desti[sub_D855(desti, v63, 0LL)];
    }
    *destj = 0;
    sub_1017A(destj + 1, 0);
    *(_DWORD *)(v39 + 52288) = 2;
  }
  v40 = sub_24D86(v39, v42, v41, 0LL, 0LL);
  if ( v40 == -37 )
  {
    *(_QWORD *)(v39 + 52296) = v42;
    *(_QWORD *)(v39 + 52304) = v41;
    result = 4294967259LL;
  }
  else if ( v40 )
  {
    (*(void (__fastcall **)(_BYTE *, __int64))(v39 + 24))(v42, v39);
    *(_DWORD *)(v39 + 52288) = 0;
    result = sub_FF92(v39, v40, (__int64)"Unable to send KEXINIT packet to remote host");
  }
  else
  {
    if ( *(_QWORD *)(v39 + 344) )
      (*(void (__fastcall **)(_QWORD, __int64))(v39 + 24))(*(_QWORD *)(v39 + 344), v39);
    *(_QWORD *)(v39 + 344) = v42;
    *(_QWORD *)(v39 + 352) = v41;
    *(_DWORD *)(v39 + 52288) = 0;
    result = 0LL;
  }
  return result;
}
// 4DC0: using guessed type __int64 __fastcall libssh2_hostkey_methods(_QWORD);
// 4FC0: using guessed type __int64 __fastcall RAND_bytes(_QWORD, _QWORD);
// 5050: using guessed type __int64 __fastcall libssh2_crypt_methods(_QWORD);
// 2324C0: using guessed type char **off_2324C0[3];

//----- (000000000000E1C8) ----------------------------------------------------
char *__fastcall sub_E1C8(const char *a1, size_t a2, const char *a3, size_t a4)
{
  char *i; // rax
  size_t n; // [rsp+0h] [rbp-30h]
  char *s2; // [rsp+8h] [rbp-28h]
  char *s; // [rsp+28h] [rbp-8h]

  s2 = (char *)a3;
  n = a4;
  if ( a2 < a4 )
    return 0LL;
  if ( !strncmp(a1, a3, a4) && (n == a2 || a1[n] == 44) )
    return (char *)a1;
  for ( i = strchr(a1, 44); i && n < a2 - (i - a1); i = strchr(s, 44) )
  {
    s = i + 1;
    if ( !strncmp(i + 1, s2, n) && (a2 == s - a1 + n || s[n] == 44) )
      return s;
  }
  return 0LL;
}

//----- (000000000000E2D9) ----------------------------------------------------
const char **__fastcall sub_E2D9(const char *a1, size_t a2, const char ***a3)
{
  const char ***i; // [rsp+8h] [rbp-18h]

  for ( i = a3; *i; ++i )
  {
    if ( a2 == strlen(**i) && !strncmp(**i, a1, a2) )
      return *i;
  }
  return 0LL;
}

//----- (000000000000E349) ----------------------------------------------------
signed __int64 __fastcall sub_E349(__int64 a1, char a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  const char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = (const char ***)libssh2_hostkey_methods(a1);
  if ( *(_QWORD *)(a1 + 96) )
  {
    for ( s = *(char **)(a1 + 96); s && *s; s = (char *)v6 )
    {
      v12 = strchr(s, 44);
      if ( v12 )
        v4 = v12 - s;
      else
        v4 = strlen(s);
      v13 = v4;
      if ( sub_E1C8(v9, v8, s, v4) )
      {
        v14 = sub_E2D9(s, v13, v10);
        if ( !v14 )
          return 0xFFFFFFFFLL;
        if ( (!(a2 & 1) || v14[6]) && (!(a2 & 2) || v14[4]) )
        {
          *(_QWORD *)(a1 + 160) = v14;
          return 0LL;
        }
      }
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    result = 0xFFFFFFFFLL;
  }
  else
  {
    while ( v10 && *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_E1C8(v9, v8, **v10, v7) && (!(a2 & 1) || (*v10)[6]) && (!(a2 & 2) || (*v10)[4]) )
      {
        *(_QWORD *)(a1 + 160) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 4DC0: using guessed type __int64 __fastcall libssh2_hostkey_methods(_QWORD);

//----- (000000000000E553) ----------------------------------------------------
signed __int64 __fastcall sub_E553(__int64 a1, const char *a2, size_t a3, const char *a4, size_t a5)
{
  size_t v5; // rax
  signed __int64 result; // rax
  signed __int64 v7; // rax
  size_t v8; // rax
  size_t v9; // [rsp+8h] [rbp-58h]
  const char *v10; // [rsp+10h] [rbp-50h]
  size_t v11; // [rsp+18h] [rbp-48h]
  const char ***v12; // [rsp+30h] [rbp-30h]
  char *s; // [rsp+38h] [rbp-28h]
  char *sa; // [rsp+38h] [rbp-28h]
  char *v15; // [rsp+40h] [rbp-20h]
  size_t v16; // [rsp+48h] [rbp-18h]
  char *v17; // [rsp+50h] [rbp-10h]
  const char **v18; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v12 = (const char ***)off_2324C0;
  if ( *(_QWORD *)(a1 + 88) )
  {
    for ( s = *(char **)(a1 + 88); ; s = (char *)v7 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v15 = strchr(s, 44);
      v5 = v15 ? v15 - s : strlen(s);
      v16 = v5;
      v17 = sub_E1C8(a2, v11, s, v5);
      if ( v17 )
      {
        v18 = sub_E2D9(s, v16, (const char ***)off_2324C0);
        if ( !v18 )
          return 0xFFFFFFFFLL;
        if ( !(unsigned int)sub_E349(a1, (unsigned __int64)v18[2], v10, v9) )
          break;
      }
      if ( v15 )
        v7 = (signed __int64)(v15 + 1);
      else
        v7 = 0LL;
    }
    *(_QWORD *)(a1 + 120) = v18;
    if ( *(_BYTE *)(a1 + 128) & 1 )
    {
      if ( a2 == v17 )
        *(_BYTE *)(a1 + 128) &= 0xFEu;
    }
    result = 0LL;
  }
  else
  {
    while ( 1 )
    {
      if ( !*v12 || !**v12 )
        return 0xFFFFFFFFLL;
      v8 = strlen(**v12);
      sa = sub_E1C8(a2, v11, **v12, v8);
      if ( sa )
      {
        if ( !(unsigned int)sub_E349(a1, (unsigned __int64)(*v12)[2], v10, v9) )
          break;
      }
      ++v12;
    }
    *(_QWORD *)(a1 + 120) = *v12;
    if ( *(_BYTE *)(a1 + 128) & 1 && a2 == sa )
      *(_BYTE *)(a1 + 128) &= 0xFEu;
    result = 0LL;
  }
  return result;
}
// 2324C0: using guessed type char **off_2324C0[3];

//----- (000000000000E79F) ----------------------------------------------------
signed __int64 __fastcall sub_E79F(__int64 a1, __int64 a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  const char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = (const char ***)libssh2_crypt_methods(a1);
  if ( *(_QWORD *)(a2 + 80) )
  {
    for ( s = *(char **)(a2 + 80); ; s = (char *)v6 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v12 = strchr(s, 44);
      v4 = v12 ? v12 - s : strlen(s);
      v13 = v4;
      if ( sub_E1C8(v9, v8, s, v4) )
        break;
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    v14 = sub_E2D9(s, v13, v10);
    if ( v14 )
    {
      *(_QWORD *)(a2 + 24) = v14;
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    while ( *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_E1C8(v9, v8, **v10, v7) )
      {
        *(_QWORD *)(a2 + 24) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 5050: using guessed type __int64 __fastcall libssh2_crypt_methods(_QWORD);

//----- (000000000000E92B) ----------------------------------------------------
signed __int64 __fastcall sub_E92B(__int64 a1, __int64 a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = sub_FF85();
  if ( *(_QWORD *)(a2 + 88) )
  {
    for ( s = *(char **)(a2 + 88); ; s = (char *)v6 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v12 = strchr(s, 44);
      v4 = v12 ? v12 - s : strlen(s);
      v13 = v4;
      if ( sub_E1C8(v9, v8, s, v4) )
        break;
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    v14 = sub_E2D9(s, v13, (const char ***)v10);
    if ( v14 )
    {
      *(_QWORD *)(a2 + 40) = v14;
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    while ( *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_E1C8(v9, v8, **v10, v7) )
      {
        *(_QWORD *)(a2 + 40) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000000EAB7) ----------------------------------------------------
signed __int64 __fastcall sub_EAB7(__int64 a1, __int64 a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = sub_A1A9(a1);
  if ( *(_QWORD *)(a2 + 96) )
  {
    for ( s = *(char **)(a2 + 96); ; s = (char *)v6 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v12 = strchr(s, 44);
      v4 = v12 ? v12 - s : strlen(s);
      v13 = v4;
      if ( sub_E1C8(v9, v8, s, v4) )
        break;
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    v14 = sub_E2D9(s, v13, (const char ***)v10);
    if ( v14 )
    {
      *(_QWORD *)(a2 + 64) = v14;
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    while ( *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_E1C8(v9, v8, **v10, v7) )
      {
        *(_QWORD *)(a2 + 64) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000000EC4A) ----------------------------------------------------
signed __int64 __fastcall sub_EC4A(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // ST0C_4
  unsigned int *v4; // ST28_8
  unsigned int *v5; // ST28_8
  unsigned int *v6; // ST28_8
  unsigned int *v7; // ST28_8
  unsigned int *v8; // ST28_8
  unsigned int *v9; // ST28_8
  signed __int64 v11; // [rsp+28h] [rbp-88h]
  size_t v12; // [rsp+30h] [rbp-80h]
  size_t v13; // [rsp+40h] [rbp-70h]
  const char *v14; // [rsp+48h] [rbp-68h]
  size_t v15; // [rsp+50h] [rbp-60h]
  const char *v16; // [rsp+58h] [rbp-58h]
  size_t v17; // [rsp+60h] [rbp-50h]
  const char *v18; // [rsp+68h] [rbp-48h]
  size_t v19; // [rsp+70h] [rbp-40h]
  const char *v20; // [rsp+78h] [rbp-38h]
  size_t v21; // [rsp+80h] [rbp-30h]
  const char *v22; // [rsp+88h] [rbp-28h]
  size_t v23; // [rsp+90h] [rbp-20h]
  const char *v24; // [rsp+98h] [rbp-18h]
  size_t v25; // [rsp+A0h] [rbp-10h]

  v3 = a3;
  v12 = (unsigned int)sub_10071((unsigned int *)(a2 + 17));
  v4 = (unsigned int *)(v12 + 4 + a2 + 17);
  v13 = (unsigned int)sub_10071(v4);
  v14 = (const char *)(v4 + 1);
  v5 = (unsigned int *)((char *)v4 + v13 + 4);
  v15 = (unsigned int)sub_10071(v5);
  v16 = (const char *)(v5 + 1);
  v6 = (unsigned int *)((char *)v5 + v15 + 4);
  v17 = (unsigned int)sub_10071(v6);
  v18 = (const char *)(v6 + 1);
  v7 = (unsigned int *)((char *)v6 + v17 + 4);
  v19 = (unsigned int)sub_10071(v7);
  v20 = (const char *)(v7 + 1);
  v8 = (unsigned int *)((char *)v7 + v19 + 4);
  v21 = (unsigned int)sub_10071(v8);
  v22 = (const char *)(v8 + 1);
  v9 = (unsigned int *)((char *)v8 + v21 + 4);
  v23 = (unsigned int)sub_10071(v9);
  v24 = (const char *)(v9 + 1);
  v11 = (signed __int64)v9 + v23 + 4;
  v25 = (unsigned int)sub_10071((unsigned int *)v11);
  *(_BYTE *)(a1 + 128) = ((char)(*(_BYTE *)v11 << 7) >> 7) & 1 | *(_BYTE *)(a1 + 128) & 0xFE;
  if ( v3 < (signed int)v11 + 1 - (signed int)a2 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_E553(a1, (const char *)(a2 + 21), v12, v14, v13) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_E79F(a1, a1 + 336, v16, v15) || (unsigned int)sub_E79F(a1, a1 + 224, v18, v17) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_E92B(a1, a1 + 336, v20, v19) || (unsigned int)sub_E92B(a1, a1 + 224, v22, v21) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_EAB7(a1, a1 + 336, v24, v23)
    || (unsigned int)sub_EAB7(a1, a1 + 224, (const char *)(v11 + 4), v25) )
  {
    return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (000000000000EFB4) ----------------------------------------------------
signed __int64 __fastcall sub_EFB4(size_t a1, int a2, _DWORD *a3)
{
  _DWORD *v4; // [rsp+8h] [rbp-28h]
  unsigned int v5; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]
  int v7; // [rsp+2Ch] [rbp-4h]
  int v8; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  v5 = 0;
  *(_DWORD *)(a1 + 104) |= 8u;
  if ( !*a3 )
  {
    *(_DWORD *)(a1 + 104) |= 1u;
    if ( a2 )
    {
      *(_QWORD *)(a1 + 120) = 0LL;
      if ( *(_QWORD *)(a1 + 160) && *(_QWORD *)(*(_QWORD *)(a1 + 160) + 56LL) )
        (*(void (__fastcall **)(size_t, size_t))(*(_QWORD *)(a1 + 160) + 56LL))(a1, a1 + 168);
      *(_QWORD *)(a1 + 160) = 0LL;
    }
    *v4 = 2;
  }
  if ( *(_QWORD *)(a1 + 120) && *(_QWORD *)(a1 + 160) )
  {
    *v4 = 5;
  }
  else
  {
    if ( *v4 == 2 )
    {
      *((_QWORD *)v4 + 46) = *(_QWORD *)(a1 + 344);
      *((_QWORD *)v4 + 47) = *(_QWORD *)(a1 + 352);
      *(_QWORD *)(a1 + 344) = 0LL;
      *v4 = 3;
    }
    if ( *v4 == 3 )
    {
      v6 = sub_D912(a1);
      if ( v6 == -37 )
      {
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        return 4294967259LL;
      }
      if ( v6 )
      {
        *(_QWORD *)(a1 + 344) = *((_QWORD *)v4 + 46);
        *(_QWORD *)(a1 + 352) = *((_QWORD *)v4 + 47);
        *v4 = 0;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
        return 0xFFFFFFFFLL;
      }
      *v4 = 4;
    }
    if ( *v4 == 4 )
    {
      v7 = sub_12422(a1, 0x14u, (_QWORD *)v4 + 44, (_QWORD *)v4 + 45, 0, 0LL, 0LL, (__int64)(v4 + 2));
      if ( v7 == -37 )
      {
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        return 4294967259LL;
      }
      if ( v7 )
      {
        if ( *(_QWORD *)(a1 + 344) )
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 344), a1);
        *(_QWORD *)(a1 + 344) = *((_QWORD *)v4 + 46);
        *(_QWORD *)(a1 + 352) = *((_QWORD *)v4 + 47);
        *v4 = 0;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
        return 0xFFFFFFFFLL;
      }
      if ( *(_QWORD *)(a1 + 232) )
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 232), a1);
      *(_QWORD *)(a1 + 232) = *((_QWORD *)v4 + 44);
      *(_QWORD *)(a1 + 240) = *((_QWORD *)v4 + 45);
      if ( (unsigned int)sub_EC4A(a1, *((_QWORD *)v4 + 44), *((_QWORD *)v4 + 45)) )
        v5 = -5;
      *v4 = 5;
    }
  }
  if ( !v5 && *v4 == 5 )
  {
    v8 = (*(__int64 (__fastcall **)(size_t, _DWORD *))(*(_QWORD *)(a1 + 120) + 8LL))(a1, v4 + 6);
    if ( v8 == -37 )
    {
      *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
      return 4294967259LL;
    }
    if ( v8 )
      v5 = sub_FF92(a1, 0xFFFFFFF8, (__int64)"Unrecoverable error exchanging keys");
  }
  if ( *(_QWORD *)(a1 + 344) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 344), a1);
    *(_QWORD *)(a1 + 344) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 232) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 232), a1);
    *(_QWORD *)(a1 + 232) = 0LL;
  }
  *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
  *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
  *v4 = 0;
  return v5;
}

//----- (000000000000F47B) ----------------------------------------------------
__int64 __fastcall libssh2_session_method_pref(__int64 a1, unsigned int a2, const char *a3)
{
  const char *v3; // rdi
  __int64 result; // rax
  int v5; // eax
  size_t v6; // rax
  signed __int64 v7; // rax
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  int v10; // [rsp+20h] [rbp-30h]
  int v11; // [rsp+24h] [rbp-2Ch]
  char **v12; // [rsp+28h] [rbp-28h]
  char *dest; // [rsp+30h] [rbp-20h]
  char ***v14; // [rsp+38h] [rbp-18h]
  char *v15; // [rsp+40h] [rbp-10h]
  char *v16; // [rsp+48h] [rbp-8h]

  v9 = a1;
  s = (char *)a3;
  v3 = a3;
  v10 = strlen(a3);
  switch ( (unsigned __int64)a2 )
  {
    case 0uLL:
      v12 = (char **)(v9 + 88);
      v14 = off_2324C0;
      goto LABEL_13;
    case 1uLL:
      v12 = (char **)(v9 + 96);
      v14 = (char ***)libssh2_hostkey_methods(v3);
      goto LABEL_13;
    case 2uLL:
      v12 = (char **)(v9 + 416);
      v14 = (char ***)libssh2_crypt_methods(v3);
      goto LABEL_13;
    case 3uLL:
      v12 = (char **)(v9 + 304);
      v14 = (char ***)libssh2_crypt_methods(v3);
      goto LABEL_13;
    case 4uLL:
      v12 = (char **)(v9 + 424);
      v14 = sub_FF85();
      goto LABEL_13;
    case 5uLL:
      v12 = (char **)(v9 + 312);
      v14 = sub_FF85();
      goto LABEL_13;
    case 6uLL:
      v12 = (char **)(v9 + 432);
      v14 = sub_A1A9(v9);
      goto LABEL_13;
    case 7uLL:
      v12 = (char **)(v9 + 320);
      v14 = sub_A1A9(v9);
      goto LABEL_13;
    case 8uLL:
      v12 = (char **)(v9 + 440);
      v14 = 0LL;
      goto LABEL_13;
    case 9uLL:
      v12 = (char **)(v9 + 328);
      v14 = 0LL;
LABEL_13:
      v15 = (char *)(*(__int64 (__fastcall **)(_QWORD, __int64))(v9 + 8))(v10 + 1, v9);
      dest = v15;
      if ( v15 )
      {
        memcpy(v15, s, v10 + 1);
        while ( dest && *dest )
        {
          v16 = strchr(dest, 44);
          if ( v16 )
            v5 = (_DWORD)v16 - (_DWORD)dest;
          else
            v5 = strlen(dest);
          v11 = v5;
          if ( !sub_E2D9(dest, v5, (const char ***)v14) )
          {
            if ( v16 )
            {
              v6 = strlen(dest);
              memcpy(dest, v16 + 1, v6 - v11);
            }
            else
            {
              if ( dest > v15 )
                --dest;
              *dest = 0;
            }
          }
          if ( v16 )
            v7 = (signed __int64)(v16 + 1);
          else
            v7 = 0LL;
          dest = (char *)v7;
        }
        if ( *v15 )
        {
          if ( *v12 )
            (*(void (__fastcall **)(char *, __int64))(v9 + 24))(*v12, v9);
          *v12 = v15;
          result = 0LL;
        }
        else
        {
          (*(void (__fastcall **)(char *, __int64))(v9 + 24))(v15, v9);
          result = sub_FF92(v9, 0xFFFFFFDF, (__int64)"The requested method(s) are not currently supported");
        }
      }
      else
      {
        result = sub_FF92(v9, 0xFFFFFFFA, (__int64)"Error allocated space for method preferences");
      }
      break;
    default:
      result = sub_FF92(v9, 0xFFFFFFDE, (__int64)"Invalid parameter specified for method_type");
      break;
  }
  return result;
}
// 4DC0: using guessed type __int64 __fastcall libssh2_hostkey_methods(_QWORD);
// 5050: using guessed type __int64 __fastcall libssh2_crypt_methods(_QWORD);
// 2324C0: using guessed type char **off_2324C0[3];

//----- (000000000000F7C1) ----------------------------------------------------
__int64 __fastcall libssh2_session_supported_algs(__int64 a1, unsigned int a2, _QWORD *a3)
{
  __int64 result; // rax
  unsigned int v4; // eax
  _QWORD *v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+2Ch] [rbp-14h]
  int v7; // [rsp+2Ch] [rbp-14h]
  unsigned int v8; // [rsp+30h] [rbp-10h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]
  char ***v10; // [rsp+38h] [rbp-8h]

  v5 = a3;
  if ( !a3 )
    return sub_FF92(a1, 0xFFFFFFD9, (__int64)"algs must not be NULL");
  switch ( (unsigned __int64)a2 )
  {
    case 0uLL:
      v10 = off_2324C0;
      goto LABEL_10;
    case 1uLL:
      v10 = (char ***)libssh2_hostkey_methods(a1);
      goto LABEL_10;
    case 2uLL:
    case 3uLL:
      v10 = (char ***)libssh2_crypt_methods(a1);
      goto LABEL_10;
    case 4uLL:
    case 5uLL:
      v10 = sub_FF85();
      goto LABEL_10;
    case 6uLL:
    case 7uLL:
      v10 = sub_A1A9(a1);
LABEL_10:
      if ( v10 )
      {
        v6 = 0;
        v9 = 0;
        while ( v10[v6] )
        {
          if ( *v10[v6] )
            ++v9;
          ++v6;
        }
        if ( v9 )
        {
          *v5 = (*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(8LL * v9, a1);
          if ( *v5 )
          {
            v7 = 0;
            v8 = 0;
            while ( v10[v7] && v8 < v9 )
            {
              if ( *v10[v7] )
              {
                v4 = v8++;
                *(_QWORD *)(*v5 + 8LL * v4) = *v10[v7];
              }
              ++v7;
            }
            if ( v8 == v9 )
            {
              result = v9;
            }
            else
            {
              (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*v5, a1);
              *v5 = 0LL;
              result = sub_FF92(a1, 0xFFFFFFD9, (__int64)"Internal error");
            }
          }
          else
          {
            result = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Memory allocation failed");
          }
        }
        else
        {
          result = sub_FF92(a1, 0xFFFFFFDE, (__int64)"No algorithm found");
        }
      }
      else
      {
        result = sub_FF92(a1, 0xFFFFFFDE, (__int64)"No algorithm found");
      }
      break;
    default:
      result = sub_FF92(a1, 0xFFFFFFDF, (__int64)"Unknown method type");
      break;
  }
  return result;
}
// 4DC0: using guessed type __int64 __fastcall libssh2_hostkey_methods(_QWORD);
// 5050: using guessed type __int64 __fastcall libssh2_crypt_methods(_QWORD);
// 2324C0: using guessed type char **off_2324C0[3];

//----- (000000000000FA3B) ----------------------------------------------------
__int64 __fastcall sub_FA3B(__int64 a1, __int64 a2, _DWORD *a3, _QWORD *a4)
{
  *a4 = a2;
  *a3 = 0;
  return 0LL;
}

//----- (000000000000FA6B) ----------------------------------------------------
__int64 __fastcall sub_FA6B(__int64 a1, _QWORD *a2)
{
  if ( *a2 )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
  *a2 = 0LL;
  return 0LL;
}

//----- (000000000000FAB4) ----------------------------------------------------
__int64 __fastcall sub_FAB4(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-158h]
  __int64 v14; // [rsp+20h] [rbp-140h]
  char v15; // [rsp+30h] [rbp-130h]
  char v16; // [rsp+154h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+158h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  sub_1017A(&v16, a3);
  v11 = EVP_sha1(&v16, v10);
  HMAC_Init(&v15, *a8, 20LL, v11);
  HMAC_Update(&v15, &v16, 4LL);
  HMAC_Update(&v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(&v15, v13, a7);
  HMAC_Final(&v15, v14, 0LL);
  HMAC_CTX_cleanup(&v15);
  return 0LL;
}
// 4CA0: using guessed type __int64 __fastcall HMAC_CTX_cleanup(_QWORD);
// 4D60: using guessed type __int64 __fastcall HMAC_Init(_QWORD, _QWORD, _QWORD, _QWORD);
// 4E00: using guessed type __int64 __fastcall HMAC_Final(_QWORD, _QWORD, _QWORD);
// 4F00: using guessed type __int64 __fastcall EVP_sha1(_QWORD, _QWORD);
// 50C0: using guessed type __int64 __fastcall HMAC_Update(_QWORD, _QWORD, _QWORD);

//----- (000000000000FBED) ----------------------------------------------------
__int64 __fastcall sub_FBED(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  char src; // [rsp+30h] [rbp-20h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  sub_FAB4(a1, (__int64)&src, a3, a4, a5, a6, a7, a8);
  memcpy(a2, &src, 0xCuLL);
  return 0LL;
}

//----- (000000000000FC80) ----------------------------------------------------
__int64 __fastcall sub_FC80(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-158h]
  __int64 v14; // [rsp+20h] [rbp-140h]
  char v15; // [rsp+30h] [rbp-130h]
  char v16; // [rsp+154h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+158h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  sub_1017A(&v16, a3);
  v11 = EVP_md5(&v16, v10);
  HMAC_Init(&v15, *a8, 16LL, v11);
  HMAC_Update(&v15, &v16, 4LL);
  HMAC_Update(&v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(&v15, v13, a7);
  HMAC_Final(&v15, v14, 0LL);
  HMAC_CTX_cleanup(&v15);
  return 0LL;
}
// 4CA0: using guessed type __int64 __fastcall HMAC_CTX_cleanup(_QWORD);
// 4D60: using guessed type __int64 __fastcall HMAC_Init(_QWORD, _QWORD, _QWORD, _QWORD);
// 4E00: using guessed type __int64 __fastcall HMAC_Final(_QWORD, _QWORD, _QWORD);
// 50C0: using guessed type __int64 __fastcall HMAC_Update(_QWORD, _QWORD, _QWORD);
// 50F0: using guessed type __int64 __fastcall EVP_md5(_QWORD, _QWORD);

//----- (000000000000FDB9) ----------------------------------------------------
__int64 __fastcall sub_FDB9(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  char src; // [rsp+30h] [rbp-20h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  sub_FC80(a1, (__int64)&src, a3, a4, a5, a6, a7, a8);
  memcpy(a2, &src, 0xCuLL);
  return 0LL;
}

//----- (000000000000FE4C) ----------------------------------------------------
__int64 __fastcall sub_FE4C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-158h]
  __int64 v14; // [rsp+20h] [rbp-140h]
  char v15; // [rsp+30h] [rbp-130h]
  char v16; // [rsp+154h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+158h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  sub_1017A(&v16, a3);
  v11 = EVP_ripemd160(&v16, v10);
  HMAC_Init(&v15, *a8, 20LL, v11);
  HMAC_Update(&v15, &v16, 4LL);
  HMAC_Update(&v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(&v15, v13, a7);
  HMAC_Final(&v15, v14, 0LL);
  HMAC_CTX_cleanup(&v15);
  return 0LL;
}
// 4CA0: using guessed type __int64 __fastcall HMAC_CTX_cleanup(_QWORD);
// 4CB0: using guessed type __int64 __fastcall EVP_ripemd160(_QWORD, _QWORD);
// 4D60: using guessed type __int64 __fastcall HMAC_Init(_QWORD, _QWORD, _QWORD, _QWORD);
// 4E00: using guessed type __int64 __fastcall HMAC_Final(_QWORD, _QWORD, _QWORD);
// 50C0: using guessed type __int64 __fastcall HMAC_Update(_QWORD, _QWORD, _QWORD);

//----- (000000000000FF85) ----------------------------------------------------
char ***sub_FF85()
{
  return off_2324E0;
}
// 2324E0: using guessed type char **off_2324E0[6];

//----- (000000000000FF92) ----------------------------------------------------
__int64 __fastcall sub_FF92(__int64 a1, unsigned int a2, __int64 a3)
{
  *(_QWORD *)(a1 + 520) = a3;
  *(_DWORD *)(a1 + 528) = a2;
  return a2;
}

//----- (000000000000FFC2) ----------------------------------------------------
signed __int64 __fastcall sub_FFC2(int a1, void *a2, size_t a3, int a4)
{
  ssize_t v5; // [rsp+28h] [rbp-8h]

  v5 = recv(a1, a2, a3, a4);
  if ( v5 >= 0 )
    return v5;
  if ( *__errno_location() == 2 )
    return -11LL;
  return -*__errno_location();
}

//----- (0000000000010024) ----------------------------------------------------
ssize_t __fastcall sub_10024(int a1, const void *a2, size_t a3, int a4)
{
  ssize_t result; // rax
  ssize_t v5; // [rsp+28h] [rbp-8h]

  v5 = send(a1, a2, a3, a4);
  if ( v5 >= 0 )
    result = v5;
  else
    result = -*__errno_location();
  return result;
}

//----- (0000000000010071) ----------------------------------------------------
__int64 __fastcall sub_10071(unsigned int *a1)
{
  return _byteswap_ulong(*a1);
}

//----- (00000000000100C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_100C0(unsigned __int8 *a1)
{
  return ((unsigned __int64)a1[6] << 8) | ((unsigned __int64)a1[5] << 16) | ((unsigned __int64)a1[4] << 24) | a1[7] | ((((unsigned __int64)a1[2] << 8) | ((unsigned __int64)a1[1] << 16) | ((unsigned __int64)*a1 << 24) | a1[3]) << 32);
}

//----- (000000000001017A) ----------------------------------------------------
signed __int64 __fastcall sub_1017A(_BYTE *a1, int a2)
{
  signed __int64 result; // rax

  *a1 = HIBYTE(a2);
  a1[1] = BYTE2(a2);
  a1[2] = BYTE1(a2);
  result = (signed __int64)(a1 + 3);
  a1[3] = a2;
  return result;
}

//----- (00000000000101C7) ----------------------------------------------------
_QWORD *__fastcall sub_101C7(_BYTE **a1, int a2)
{
  _QWORD *result; // rax

  sub_1017A(*a1, a2);
  result = a1;
  *result += 4LL;
  return result;
}

//----- (00000000000101FF) ----------------------------------------------------
_QWORD *__fastcall sub_101FF(void **a1, const void *a2, size_t a3)
{
  _QWORD *result; // rax
  size_t n; // [rsp+8h] [rbp-18h]

  n = a3;
  result = sub_101C7((_BYTE **)a1, a3);
  if ( n )
  {
    memcpy(*a1, a2, n);
    result = a1;
    *a1 = (char *)*a1 + n;
  }
  return result;
}

//----- (0000000000010260) ----------------------------------------------------
__int64 __fastcall libssh2_base64_decode(__int64 a1, _QWORD *a2, _DWORD *a3, unsigned __int8 *a4, int a5)
{
  __int64 result; // rax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // [rsp+Ch] [rbp-44h]
  unsigned __int8 *v11; // [rsp+10h] [rbp-40h]
  _DWORD *v12; // [rsp+18h] [rbp-38h]
  __int16 v13; // [rsp+36h] [rbp-1Ah]
  int v14; // [rsp+38h] [rbp-18h]
  int v15; // [rsp+3Ch] [rbp-14h]
  unsigned __int8 *i; // [rsp+40h] [rbp-10h]
  __int64 v17; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v14 = 0;
  v15 = 0;
  *a2 = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(((unsigned int)(3 * a5) >> 2) + 1, a1);
  v17 = *a2;
  if ( !*a2 )
    return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for base64 decoding");
  for ( i = v11; i < &v11[v10]; ++i )
  {
    v13 = word_2AAE0[*i];
    if ( v13 >= 0 )
    {
      v6 = v14 % 4;
      if ( v14 % 4 == 1 )
      {
        v7 = v15++;
        *(_BYTE *)(v7 + v17) |= v13 >> 4;
        *(_BYTE *)(v15 + v17) = 16 * v13;
      }
      else if ( v6 > 1 )
      {
        if ( v6 == 2 )
        {
          v8 = v15++;
          *(_BYTE *)(v8 + v17) |= v13 >> 2;
          *(_BYTE *)(v15 + v17) = (_BYTE)v13 << 6;
        }
        else if ( v6 == 3 )
        {
          v9 = v15++;
          *(_BYTE *)(v9 + v17) |= v13;
        }
      }
      else if ( !v6 )
      {
        *(_BYTE *)(v15 + v17) = 4 * v13;
      }
      ++v14;
    }
  }
  if ( v14 % 4 == 1 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
    result = sub_FF92(a1, 0xFFFFFFDE, (__int64)"Invalid base64");
  }
  else
  {
    *v12 = v15;
    result = 0LL;
  }
  return result;
}

//----- (00000000000104AE) ----------------------------------------------------
size_t __fastcall sub_104AE(__int64 a1, const char *a2, size_t a3, char **a4)
{
  char **v5; // [rsp+0h] [rbp-50h]
  size_t v6; // [rsp+8h] [rbp-48h]
  signed int i; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  char *v9; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v11; // [rsp+38h] [rbp-18h]
  unsigned __int8 v12; // [rsp+41h] [rbp-Fh]
  unsigned __int8 v13; // [rsp+42h] [rbp-Eh]
  unsigned __int8 v14; // [rsp+43h] [rbp-Dh]
  unsigned __int8 v15; // [rsp+44h] [rbp-Ch]
  unsigned __int8 v16; // [rsp+45h] [rbp-Bh]
  unsigned __int8 v17; // [rsp+46h] [rbp-Ah]
  unsigned __int8 v18; // [rsp+47h] [rbp-9h]
  unsigned __int64 v19; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v19 = __readfsqword(0x28u);
  s = (char *)a2;
  *a4 = 0LL;
  if ( !a3 )
    v6 = strlen(a2);
  v9 = (char *)(*(__int64 (__fastcall **)(unsigned __int64, __int64))(a1 + 8))(
                 ((unsigned __int64)(0xAAAAAAAAAAAAAAABLL * (unsigned __int128)(4 * v6) >> 64) >> 1) + 4,
                 a1);
  v11 = v9;
  if ( !v9 )
    return 0LL;
  while ( v6 )
  {
    v8 = 0;
    for ( i = 0; i <= 2; ++i )
    {
      if ( v6 )
      {
        ++v8;
        *(&v12 + i) = *s++;
        --v6;
      }
      else
      {
        *(&v12 + i) = 0;
      }
    }
    v15 = v12 >> 2;
    v16 = 16 * v12 & 0x30 | (v13 >> 4);
    v17 = 4 * v13 & 0x3C | (v14 >> 6);
    v18 = v14 & 0x3F;
    if ( v8 == 1 )
    {
      snprintf(v9, 5uLL, "%c%c==", (unsigned int)aAbcdefghijklmn[v15], (unsigned int)aAbcdefghijklmn[v16]);
    }
    else if ( v8 == 2 )
    {
      snprintf(
        v9,
        5uLL,
        "%c%c%c=",
        (unsigned int)aAbcdefghijklmn[v15],
        (unsigned int)aAbcdefghijklmn[v16],
        (unsigned int)aAbcdefghijklmn[v17],
        v5);
    }
    else
    {
      snprintf(
        v9,
        5uLL,
        "%c%c%c%c",
        (unsigned int)aAbcdefghijklmn[v15],
        (unsigned int)aAbcdefghijklmn[v16],
        (unsigned int)aAbcdefghijklmn[v17],
        (unsigned int)aAbcdefghijklmn[v18]);
    }
    v9 += 4;
  }
  *v9 = 0;
  *v5 = v11;
  return strlen(v11);
}

//----- (0000000000010794) ----------------------------------------------------
__int64 __fastcall libssh2_free(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(a1 + 24))(a2, a1);
}

//----- (00000000000107BF) ----------------------------------------------------
__int64 libssh2_trace()
{
  return 0LL;
}

//----- (00000000000107D1) ----------------------------------------------------
__int64 libssh2_trace_sethandler()
{
  return 0LL;
}

//----- (00000000000107E8) ----------------------------------------------------
_QWORD *__fastcall sub_107E8(_QWORD *a1)
{
  _QWORD *result; // rax

  *a1 = 0LL;
  result = a1;
  result[1] = *result;
  return result;
}

//----- (000000000001080D) ----------------------------------------------------
_QWORD *__fastcall sub_1080D(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  a2[2] = a1;
  *a2 = 0LL;
  a2[1] = *a1;
  *a1 = a2;
  if ( a2[1] )
  {
    result = (_QWORD *)a2[1];
    *result = a2;
  }
  else
  {
    result = a1;
    a1[1] = a2;
  }
  return result;
}

//----- (0000000000010877) ----------------------------------------------------
__int64 __fastcall sub_10877(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000010889) ----------------------------------------------------
__int64 __fastcall sub_10889(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000000001089A) ----------------------------------------------------
__int64 __fastcall sub_1089A(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (00000000000108AC) ----------------------------------------------------
_QWORD *__fastcall sub_108AC(__int64 a1)
{
  _QWORD *result; // rax

  if ( *(_QWORD *)(a1 + 8) )
    **(_QWORD **)(a1 + 8) = *(_QWORD *)a1;
  else
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8LL) = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    result = *(_QWORD **)a1;
    *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)(a1 + 8);
  }
  else
  {
    result = *(_QWORD **)(a1 + 16);
    *result = *(_QWORD *)(a1 + 8);
  }
  return result;
}

//----- (000000000001091F) ----------------------------------------------------
__int64 __fastcall sub_1091F(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  int v5; // eax
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-60h]
  char v8; // [rsp+2Bh] [rbp-35h]
  unsigned int v9; // [rsp+2Ch] [rbp-34h]
  unsigned int v10; // [rsp+2Ch] [rbp-34h]
  _BYTE *v11; // [rsp+30h] [rbp-30h]
  __int64 v12; // [rsp+38h] [rbp-28h]
  __int64 v13; // [rsp+40h] [rbp-20h]
  unsigned int *v14; // [rsp+48h] [rbp-18h]
  void *s; // [rsp+50h] [rbp-10h]
  unsigned __int64 v16; // [rsp+58h] [rbp-8h]

  v7 = a4;
  v16 = __readfsqword(0x28u);
  v13 = 38LL;
  v12 = sub_10877(a1 + 488);
  v8 = 1;
  if ( !*(_DWORD *)v7 )
  {
    v14 = (unsigned int *)(a2 + 20);
    *(_DWORD *)(v7 + 64) = sub_10071((unsigned int *)(a2 + 20));
    ++v14;
    *(_DWORD *)(v7 + 68) = sub_10071(v14);
    ++v14;
    *(_DWORD *)(v7 + 72) = sub_10071(v14);
    ++v14;
    *(_DWORD *)(v7 + 84) = sub_10071(v14);
    ++v14;
    *(_QWORD *)(v7 + 48) = v14;
    v14 = (unsigned int *)((char *)v14 + *(unsigned int *)(v7 + 84));
    *(_DWORD *)(v7 + 76) = sub_10071(v14);
    ++v14;
    *(_DWORD *)(v7 + 88) = sub_10071(v14);
    ++v14;
    *(_QWORD *)(v7 + 56) = v14;
    v14 = (unsigned int *)((char *)v14 + *(unsigned int *)(v7 + 88));
    *(_DWORD *)(v7 + 80) = sub_10071(v14);
    *(_DWORD *)v7 = 1;
  }
  if ( *(_DWORD *)v7 == 3 )
  {
LABEL_26:
    v11 = (_BYTE *)(v7 + 5);
    *(_BYTE *)(v7 + 4) = 92;
    sub_101C7(&v11, *(_DWORD *)(v7 + 64));
    sub_101C7(&v11, v8);
    sub_101FF((void **)&v11, "Forward not requested", 0x15uLL);
    sub_1017A(v11, 0);
    v10 = sub_24D86(a1, (const void *)(v7 + 4), v13, 0LL, 0LL);
    if ( v10 == -37 )
    {
      result = 4294967259LL;
    }
    else if ( v10 )
    {
      *(_DWORD *)v7 = 0;
      result = sub_FF92(a1, v10, (__int64)"Unable to send open failure");
    }
    else
    {
      *(_DWORD *)v7 = 0;
      result = 0LL;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( !v12 )
        goto LABEL_25;
      if ( *(_DWORD *)(v12 + 40) == *(_DWORD *)(v7 + 76)
        && strlen(*(const char **)(v12 + 32)) == *(_DWORD *)(v7 + 84)
        && !memcmp(*(const void **)(v12 + 32), *(const void **)(v7 + 48), *(unsigned int *)(v7 + 84)) )
      {
        s = 0LL;
        *(_QWORD *)(v7 + 96) = 0LL;
        if ( *(_DWORD *)v7 == 1 )
        {
          if ( *(_DWORD *)(v12 + 68) && *(_DWORD *)(v12 + 68) <= *(_DWORD *)(v12 + 64) )
          {
            v8 = 4;
            *(_DWORD *)v7 = 3;
LABEL_25:
            *(_DWORD *)v7 = 3;
            goto LABEL_26;
          }
          s = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(688LL, a1);
          if ( !s )
          {
            sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate a channel for new connection");
            v8 = 4;
            *(_DWORD *)v7 = 3;
            goto LABEL_25;
          }
          *(_QWORD *)(v7 + 96) = s;
          memset(s, 0, 0x2B0uLL);
          *((_QWORD *)s + 12) = a1;
          *((_DWORD *)s + 8) = 15;
          v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))((unsigned int)(*((_DWORD *)s + 8) + 1), a1);
          *((_QWORD *)s + 3) = v4;
          if ( !*((_QWORD *)s + 3) )
          {
            sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate a channel for new connection");
            (*(void (__fastcall **)(void *, __int64))(a1 + 24))(s, a1);
            v8 = 4;
            *(_DWORD *)v7 = 3;
            goto LABEL_25;
          }
          memcpy(*((void **)s + 3), "forwarded-tcpip", (unsigned int)(*((_DWORD *)s + 8) + 1));
          *((_DWORD *)s + 17) = *(_DWORD *)(v7 + 64);
          *((_DWORD *)s + 18) = 0x40000;
          *((_DWORD *)s + 19) = 0x40000;
          *((_DWORD *)s + 20) = 0x8000;
          v5 = sub_536A(a1);
          *((_DWORD *)s + 12) = v5;
          *((_DWORD *)s + 13) = *(_DWORD *)(v7 + 68);
          *((_DWORD *)s + 14) = *(_DWORD *)(v7 + 68);
          *((_DWORD *)s + 15) = *(_DWORD *)(v7 + 72);
          v11 = (_BYTE *)(v7 + 5);
          *(_BYTE *)(v7 + 4) = 91;
          sub_101C7(&v11, *((_DWORD *)s + 17));
          sub_101C7(&v11, *((_DWORD *)s + 12));
          sub_101C7(&v11, *((_DWORD *)s + 18));
          sub_101C7(&v11, *((_DWORD *)s + 20));
          *(_DWORD *)v7 = 2;
        }
        if ( *(_DWORD *)v7 == 2 )
          break;
      }
      v12 = sub_10889(v12);
    }
    v9 = sub_24D86(a1, (const void *)(v7 + 4), 17LL, 0LL, 0LL);
    if ( v9 == -37 )
    {
      result = 4294967259LL;
    }
    else if ( v9 )
    {
      *(_DWORD *)v7 = 0;
      result = sub_FF92(a1, v9, (__int64)"Unable to send channel open confirmation");
    }
    else
    {
      sub_1080D((_QWORD *)(v12 + 48), *(_QWORD **)(v7 + 96));
      ++*(_DWORD *)(v12 + 64);
      *(_DWORD *)v7 = 0;
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000010F0B) ----------------------------------------------------
__int64 __fastcall sub_10F0B(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-50h]
  int v6; // [rsp+20h] [rbp-30h]
  int v7; // [rsp+24h] [rbp-2Ch]
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  _BYTE *v9; // [rsp+28h] [rbp-28h]
  void *s; // [rsp+30h] [rbp-20h]
  __int64 v11; // [rsp+38h] [rbp-18h]
  unsigned int *v12; // [rsp+40h] [rbp-10h]
  unsigned __int64 v13; // [rsp+48h] [rbp-8h]

  v5 = a4;
  v13 = __readfsqword(0x28u);
  v6 = 2;
  v11 = 40LL;
  s = *(void **)(a4 + 80);
  if ( !*(_DWORD *)a4 )
  {
    v12 = (unsigned int *)(a2 + 8);
    *(_DWORD *)(a4 + 56) = sub_10071((unsigned int *)(a2 + 8));
    ++v12;
    *(_DWORD *)(v5 + 60) = sub_10071(v12);
    ++v12;
    *(_DWORD *)(v5 + 64) = sub_10071(v12);
    ++v12;
    *(_DWORD *)(v5 + 72) = sub_10071(v12);
    ++v12;
    *(_QWORD *)(v5 + 48) = v12;
    v12 = (unsigned int *)((char *)v12 + *(unsigned int *)(v5 + 72));
    *(_DWORD *)(v5 + 68) = sub_10071(v12);
    *(_DWORD *)v5 = 1;
  }
  if ( !*(_QWORD *)(a1 + 64) )
  {
    v6 = 4;
    goto LABEL_17;
  }
  if ( *(_DWORD *)v5 == 1 )
  {
    s = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(688LL, a1);
    if ( !s )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"allocate a channel for new connection");
      v6 = 4;
      goto LABEL_17;
    }
    memset(s, 0, 0x2B0uLL);
    *((_QWORD *)s + 12) = a1;
    *((_DWORD *)s + 8) = 3;
    *((_QWORD *)s + 3) = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(
                           (unsigned int)(*((_DWORD *)s + 8) + 1),
                           a1);
    if ( !*((_QWORD *)s + 3) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"allocate a channel for new connection");
      (*(void (__fastcall **)(void *, __int64))(a1 + 24))(s, a1);
      v6 = 4;
      goto LABEL_17;
    }
    memcpy(*((void **)s + 3), "x11", (unsigned int)(*((_DWORD *)s + 8) + 1));
    *((_DWORD *)s + 17) = *(_DWORD *)(v5 + 56);
    *((_DWORD *)s + 18) = 0x40000;
    *((_DWORD *)s + 19) = 0x40000;
    *((_DWORD *)s + 20) = 0x8000;
    *((_DWORD *)s + 12) = sub_536A(a1);
    *((_DWORD *)s + 13) = *(_DWORD *)(v5 + 60);
    *((_DWORD *)s + 14) = *(_DWORD *)(v5 + 60);
    *((_DWORD *)s + 15) = *(_DWORD *)(v5 + 64);
    v9 = (_BYTE *)(v5 + 5);
    *(_BYTE *)(v5 + 4) = 91;
    sub_101C7(&v9, *((_DWORD *)s + 17));
    sub_101C7(&v9, *((_DWORD *)s + 12));
    sub_101C7(&v9, *((_DWORD *)s + 18));
    sub_101C7(&v9, *((_DWORD *)s + 20));
    *(_DWORD *)v5 = 2;
  }
  if ( *(_DWORD *)v5 != 2 )
  {
LABEL_17:
    v9 = (_BYTE *)(v5 + 5);
    *(_BYTE *)(v5 + 4) = 92;
    sub_101C7(&v9, *(_DWORD *)(v5 + 56));
    sub_101C7(&v9, v6);
    sub_101FF((void **)&v9, "X11 Forward Unavailable", 0x17uLL);
    sub_1017A(v9, 0);
    v8 = sub_24D86(a1, (const void *)(v5 + 4), v11, 0LL, 0LL);
    if ( v8 == -37 )
      return 4294967259LL;
    if ( v8 )
    {
      *(_DWORD *)v5 = 0;
      result = sub_FF92(a1, v8, (__int64)"Unable to send open failure");
    }
    else
    {
      *(_DWORD *)v5 = 0;
      result = 0LL;
    }
    return result;
  }
  v7 = sub_24D86(a1, (const void *)(v5 + 4), 17LL, 0LL, 0LL);
  if ( v7 == -37 )
    return 4294967259LL;
  if ( v7 )
  {
    *(_DWORD *)v5 = 0;
    result = sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send channel open confirmation");
  }
  else
  {
    sub_1080D((_QWORD *)(a1 + 464), s);
    (*(void (__fastcall **)(_QWORD, void *, _QWORD, _QWORD, _QWORD))(*((_QWORD *)s + 12) + 64LL))(
      *((_QWORD *)s + 12),
      s,
      *(_QWORD *)(v5 + 48),
      *(unsigned int *)(v5 + 68),
      *((_QWORD *)s + 12));
    *(_DWORD *)v5 = 0;
    result = 0LL;
  }
  return result;
}

//----- (00000000000113E1) ----------------------------------------------------
signed __int64 __fastcall sub_113E1(size_t a1, unsigned __int8 *a2, unsigned __int64 a3, int a4)
{
  signed __int64 result; // rax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned __int64 v9; // [rsp+8h] [rbp-88h]
  char v10; // [rsp+20h] [rbp-70h]
  unsigned __int8 v11; // [rsp+21h] [rbp-6Fh]
  unsigned __int8 v12; // [rsp+22h] [rbp-6Eh]
  char v13[5]; // [rsp+23h] [rbp-6Dh]
  int v14; // [rsp+28h] [rbp-68h]
  unsigned int v15; // [rsp+2Ch] [rbp-64h]
  size_t n; // [rsp+30h] [rbp-60h]
  int v17; // [rsp+38h] [rbp-58h]
  unsigned int v18; // [rsp+3Ch] [rbp-54h]
  unsigned __int8 *v19; // [rsp+40h] [rbp-50h]
  unsigned __int8 *v20; // [rsp+48h] [rbp-48h]
  unsigned __int64 v21; // [rsp+50h] [rbp-40h]
  unsigned __int64 v22; // [rsp+58h] [rbp-38h]
  __int64 v23; // [rsp+60h] [rbp-30h]
  unsigned __int64 v24; // [rsp+68h] [rbp-28h]
  __int64 v25; // [rsp+70h] [rbp-20h]
  _QWORD *v26; // [rsp+78h] [rbp-18h]
  char v27; // [rsp+83h] [rbp-Dh]
  int v28; // [rsp+84h] [rbp-Ch]
  unsigned __int64 v29; // [rsp+88h] [rbp-8h]

  v9 = a3;
  v29 = __readfsqword(0x28u);
  *(_DWORD *)&v13[1] = 0;
  v19 = 0LL;
  v20 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  *(_DWORD *)v13 = *a2;
  switch ( *(_DWORD *)(a1 + 53608) )
  {
    case 0:
      if ( a4 != -1
        || *(_QWORD *)(a1 + 56)
        && !(*(unsigned int (__fastcall **)(size_t, unsigned __int8 *, _QWORD, size_t))(a1 + 56))(
              a1,
              a2,
              (unsigned int)a3,
              a1) )
      {
        *(_DWORD *)(a1 + 53608) = 1;
        goto LABEL_7;
      }
      (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
      return sub_FF92(a1, 0xFFFFFFFC, (__int64)"Invalid MAC received");
    case 0xB:
LABEL_48:
      *(_DWORD *)(a1 + 53608) = 11;
      if ( (unsigned int)sub_82CF(*(_QWORD *)(a1 + 53616), (signed int)v9 - 13, 1, 0LL) == -37 )
        return 4294967259LL;
      *(_DWORD *)(a1 + 53608) = 0;
      return 0LL;
    case 0xC:
LABEL_94:
      *(_DWORD *)(a1 + 53608) = 12;
      *(_DWORD *)&v13[1] = sub_1091F(a1, (__int64)a2, v9, a1 + 53624);
      goto LABEL_100;
    case 0xD:
LABEL_99:
      *(_DWORD *)(a1 + 53608) = 13;
      *(_DWORD *)&v13[1] = sub_10F0B(a1, (__int64)a2, v9, a1 + 53728);
LABEL_100:
      if ( *(_DWORD *)&v13[1] == -37 )
        return 4294967259LL;
      (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
      *(_DWORD *)(a1 + 53608) = 0;
      return *(unsigned int *)&v13[1];
    case 0xE:
LABEL_81:
      *(_DWORD *)(a1 + 53608) = 14;
      v27 = 100;
      v28 = *(_DWORD *)(a2 + 1);
      *(_DWORD *)&v13[1] = sub_24D86(a1, &v27, 5LL, 0LL, 0LL);
      if ( *(_DWORD *)&v13[1] == -37 )
        return 4294967259LL;
LABEL_83:
      (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
      *(_DWORD *)(a1 + 53608) = 0;
      return *(unsigned int *)&v13[1];
    case 0xF:
LABEL_37:
      *(_DWORD *)(a1 + 53608) = 15;
      *(_DWORD *)&v13[1] = sub_24D86(a1, &v10, 1LL, 0LL, 0LL);
      if ( *(_DWORD *)&v13[1] == -37 )
        return 4294967259LL;
LABEL_39:
      (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
      *(_DWORD *)(a1 + 53608) = 0;
      return 0LL;
    default:
LABEL_7:
      if ( *(_DWORD *)(a1 + 53608) == 1 )
      {
        switch ( v13[0] )
        {
          case 1:
            if ( v9 > 4 )
            {
              v25 = (unsigned int)sub_10071((unsigned int *)(a2 + 1));
              if ( v9 > 8 )
              {
                v21 = (unsigned int)sub_10071((unsigned int *)(a2 + 5));
                if ( v21 >= v9 - 13 )
                {
                  v21 = 0LL;
                }
                else
                {
                  v19 = a2 + 9;
                  v22 = (unsigned int)sub_10071((unsigned int *)&a2[v21 + 9]);
                  v20 = &a2[v21 + 13];
                  if ( v22 > v9 - v21 - 13 )
                  {
                    v19 = 0LL;
                    v20 = 0LL;
                    v21 = 0LL;
                    v22 = 0LL;
                  }
                }
              }
              if ( *(_QWORD *)(a1 + 48) )
                (*(void (__fastcall **)(size_t, _QWORD, unsigned __int8 *, _QWORD, unsigned __int8 *, _QWORD, size_t))(a1 + 48))(
                  a1,
                  (unsigned int)v25,
                  v19,
                  (unsigned int)v21,
                  v20,
                  (unsigned int)v22,
                  a1);
            }
            (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 508) = -1;
            *(_DWORD *)(a1 + 53608) = 0;
            return sub_FF92(a1, 0xFFFFFFF3, (__int64)"socket disconnect");
          case 2:
            if ( v9 <= 1 )
            {
              if ( *(_QWORD *)(a1 + 32) )
                (*(void (__fastcall **)(size_t, void *, _QWORD, size_t))(a1 + 32))(a1, &unk_2AE89, 0LL, a1);
            }
            else if ( *(_QWORD *)(a1 + 32) )
            {
              (*(void (__fastcall **)(size_t, unsigned __int8 *, _QWORD, size_t))(a1 + 32))(
                a1,
                a2 + 1,
                (unsigned int)(v9 - 1),
                a1);
            }
            (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53608) = 0;
            return 0LL;
          case 4:
            if ( v9 > 1 )
            {
              v18 = a2[1];
              if ( v9 > 5 )
              {
                v21 = (unsigned int)sub_10071((unsigned int *)(a2 + 2));
                if ( v21 <= v9 - 10 )
                {
                  v19 = a2 + 6;
                  v22 = (unsigned int)sub_10071((unsigned int *)&a2[v21 + 6]);
                  if ( v22 <= v9 - v21 - 10 )
                    v20 = &a2[v21 + 10];
                }
              }
              if ( *(_QWORD *)(a1 + 40) )
                (*(void (__fastcall **)(size_t, _QWORD, unsigned __int8 *, _QWORD, unsigned __int8 *, _QWORD, size_t))(a1 + 40))(
                  a1,
                  v18,
                  v19,
                  (unsigned int)v21,
                  v20,
                  (unsigned int)v22,
                  a1);
            }
            (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53608) = 0;
            return 0LL;
          case 0x50:
            if ( v9 <= 4 )
              goto LABEL_39;
            v11 = 0;
            v17 = sub_10071((unsigned int *)(a2 + 1));
            if ( v9 >= (unsigned int)(v17 + 6) )
              v11 = a2[v17 + 5];
            if ( !v11 )
              goto LABEL_39;
            v10 = 82;
            goto LABEL_37;
          case 0x5A:
            if ( v9 <= 0x10 )
              goto LABEL_100;
            if ( v9 > 0x13
              && (unsigned int)sub_10071((unsigned int *)(a2 + 1)) == 15
              && !memcmp(a2 + 5, "forwarded-tcpip", 0xFuLL) )
            {
              memset((void *)(a1 + 53624), 0, 0x68uLL);
              goto LABEL_94;
            }
            if ( v9 <= 7 || (unsigned int)sub_10071((unsigned int *)(a2 + 1)) != 3 || memcmp(a2 + 5, "x11", 3uLL) )
              goto LABEL_100;
            memset((void *)(a1 + 53728), 0, 0x58uLL);
            goto LABEL_99;
          case 0x5D:
            if ( v9 > 8 )
            {
              HIDWORD(n) = sub_10071((unsigned int *)(a2 + 5));
              v8 = sub_10071((unsigned int *)(a2 + 1));
              v23 = sub_53DD(a1, v8);
              if ( v23 )
                *(_DWORD *)(v23 + 56) += HIDWORD(n);
            }
            (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53608) = 0;
            return 0LL;
          case 0x5E:
            goto LABEL_41;
          case 0x5F:
            v24 += 4LL;
LABEL_41:
            v24 += 9LL;
            if ( v9 >= v24 )
            {
              v5 = sub_10071((unsigned int *)(a2 + 1));
              v23 = sub_53DD(a1, v5);
            }
            if ( !v23 )
            {
              sub_FF92(a1, 0xFFFFFFE9, (__int64)"Packet received for unknown channel");
              (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
              *(_DWORD *)(a1 + 53608) = 0;
              return 0LL;
            }
            if ( *(_BYTE *)(v23 + 86) == 1 && v13[0] == 95 )
            {
              (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
              *(_QWORD *)(a1 + 53616) = v23;
              goto LABEL_48;
            }
            if ( *(unsigned int *)(v23 + 80) < v9 - v24 )
            {
              sub_FF92(a1, 0xFFFFFFE7, (__int64)"Packet contains more data than we offered to receive, truncating");
              v9 = *(unsigned int *)(v23 + 80) + v24;
            }
            if ( !*(_DWORD *)(v23 + 76) )
            {
              sub_FF92(a1, 0xFFFFFFE8, (__int64)"The current receive window is full, data ignored");
              (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
              *(_DWORD *)(a1 + 53608) = 0;
              return 0LL;
            }
            *(_BYTE *)(v23 + 85) = 0;
            if ( v9 - v24 <= *(unsigned int *)(v23 + 76) )
            {
              *(_DWORD *)(v23 + 76) += v24 - v9;
            }
            else
            {
              sub_FF92(a1, 0xFFFFFFE8, (__int64)"Remote sent more data than current window allows, truncating");
              v9 = *(unsigned int *)(v23 + 76) + v24;
              *(_DWORD *)(v23 + 76) = 0;
            }
LABEL_107:
            *(_DWORD *)(a1 + 53608) = 3;
            break;
          case 0x60:
            if ( v9 > 4 )
            {
              v6 = sub_10071((unsigned int *)(a2 + 1));
              v23 = sub_53DD(a1, v6);
            }
            if ( v23 )
              *(_BYTE *)(v23 + 85) = 1;
            (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53608) = 0;
            return 0LL;
          case 0x61:
            if ( v9 > 4 )
            {
              v7 = sub_10071((unsigned int *)(a2 + 1));
              v23 = sub_53DD(a1, v7);
            }
            if ( v23 )
            {
              *(_BYTE *)(v23 + 84) = 1;
              *(_BYTE *)(v23 + 85) = 1;
            }
            (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53608) = 0;
            return 0LL;
          case 0x62:
            if ( v9 > 8 )
            {
              v14 = sub_10071((unsigned int *)(a2 + 1));
              v15 = sub_10071((unsigned int *)(a2 + 5));
              v12 = 1;
              if ( v15 < v9 - 10 )
                v12 = a2[v15 + 9];
              if ( v15 == 11 && !memcmp("exit-status", a2 + 9, 0xBuLL) )
              {
                if ( v9 > 0x13 )
                  v23 = sub_53DD(a1, v14);
                if ( v23 )
                  *(_DWORD *)(v23 + 36) = sub_10071((unsigned int *)(a2 + 21));
              }
              else if ( v15 == 11 && !memcmp("exit-signal", a2 + 9, 0xBuLL) )
              {
                if ( v9 > 0x13 )
                  v23 = sub_53DD(a1, v14);
                if ( v23 )
                {
                  LODWORD(n) = sub_10071((unsigned int *)(a2 + 21));
                  *(_QWORD *)(v23 + 40) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                            (unsigned int)(n + 1),
                                            a1);
                  if ( *(_QWORD *)(v23 + 40) )
                  {
                    memcpy(*(void **)(v23 + 40), a2 + 25, (unsigned int)n);
                    *(_BYTE *)(*(_QWORD *)(v23 + 40) + (unsigned int)n) = 0;
                  }
                  else
                  {
                    *(_DWORD *)&v13[1] = sub_FF92(a1, 0xFFFFFFFA, (__int64)"memory for signal name");
                  }
                }
              }
              if ( v12 )
                goto LABEL_81;
            }
            goto LABEL_83;
          default:
            goto LABEL_107;
        }
      }
      if ( *(_DWORD *)(a1 + 53608) != 3 )
        goto LABEL_112;
      v26 = (_QWORD *)(*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(48LL, a1);
      if ( v26 )
      {
        v26[3] = a2;
        v26[4] = v9;
        v26[5] = v24;
        sub_1080D((_QWORD *)(a1 + 448), v26);
        *(_DWORD *)(a1 + 53608) = 4;
LABEL_112:
        if ( (v13[0] != 20 || *(_DWORD *)(a1 + 104) & 1) && *(_DWORD *)(a1 + 53608) != 5 )
          goto LABEL_122;
        if ( *(_DWORD *)(a1 + 53608) == 4 )
          *(_DWORD *)(a1 + 53608) = 5;
        *(_DWORD *)(a1 + 53056) = 0;
        *(_QWORD *)(a1 + 16960) = 0LL;
        *(_DWORD *)(a1 + 53608) = 0;
        *(_DWORD *)(a1 + 53816) = 0;
        memset((void *)(a1 + 52384), 0, 0x180uLL);
        if ( (unsigned int)sub_EFB4(a1, 1, (_DWORD *)(a1 + 52384)) != -37 )
        {
LABEL_122:
          *(_DWORD *)(a1 + 53608) = 0;
          result = 0LL;
        }
        else
        {
          result = 4294967259LL;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 53608) = 0;
        result = 4294967290LL;
      }
      return result;
  }
}

//----- (0000000000012289) ----------------------------------------------------
__int64 __fastcall sub_12289(size_t n, char a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t na)
{
  void *s2; // [rsp+8h] [rbp-38h]
  _QWORD *v9; // [rsp+10h] [rbp-30h]
  _QWORD *v10; // [rsp+18h] [rbp-28h]
  int v11; // [rsp+20h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v11 = a5;
  s2 = a6;
  for ( i = sub_10877(n + 448); i; i = sub_10889(i) )
  {
    if ( a2 == **(_BYTE **)(i + 24)
      && *(_QWORD *)(i + 32) >= v11 + na
      && (!s2 || !memcmp((const void *)(*(_QWORD *)(i + 24) + v11), s2, na)) )
    {
      *v10 = *(_QWORD *)(i + 24);
      *v9 = *(_QWORD *)(i + 32);
      sub_108AC(i);
      (*(void (__fastcall **)(__int64, size_t))(n + 24))(i, n);
      return 0LL;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000001238D) ----------------------------------------------------
signed __int64 __fastcall sub_1238D(size_t a1, const char *a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t a7)
{
  void *v8; // [rsp+0h] [rbp-40h]
  int v9; // [rsp+Ch] [rbp-34h]
  _QWORD *v10; // [rsp+10h] [rbp-30h]
  _QWORD *v11; // [rsp+18h] [rbp-28h]
  int i; // [rsp+38h] [rbp-8h]
  int v13; // [rsp+3Ch] [rbp-4h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  v13 = strlen(a2);
  for ( i = 0; i < v13; ++i )
  {
    if ( !(unsigned int)sub_12289(a1, a2[i], v11, v10, v9, v8, a7) )
      return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000012422) ----------------------------------------------------
signed __int64 __fastcall sub_12422(size_t a1, unsigned __int8 a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t a7, __int64 a8)
{
  signed __int64 result; // rax
  void *v9; // [rsp+8h] [rbp-38h]
  _QWORD *v10; // [rsp+10h] [rbp-30h]
  _QWORD *v11; // [rsp+18h] [rbp-28h]
  int v12; // [rsp+20h] [rbp-20h]
  unsigned int v13; // [rsp+34h] [rbp-Ch]

  v11 = a3;
  v10 = a4;
  v12 = a5;
  v9 = a6;
  if ( *(_QWORD *)(a8 + 8) )
  {
    do
    {
LABEL_15:
      if ( *(_DWORD *)(a1 + 508) )
        return 4294967283LL;
      v13 = sub_2445D(a1);
      if ( v13 == -37 )
        return 4294967259LL;
      if ( (v13 & 0x80000000) != 0 )
      {
        *(_QWORD *)(a8 + 8) = 0LL;
        return v13;
      }
      if ( v13 == a2 )
      {
        LODWORD(result) = sub_12289(a1, a2, v11, v10, v12, v9, a7);
        *(_QWORD *)(a8 + 8) = 0LL;
        return (unsigned int)result;
      }
    }
    while ( v13 );
    if ( 60 - (time(0LL) - *(_QWORD *)(a8 + 8)) > 0 )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      *(_QWORD *)(a8 + 8) = 0LL;
      result = 4294967287LL;
    }
  }
  else
  {
    if ( (unsigned int)sub_12289(a1, a2, a3, a4, a5, a6, a7) )
    {
      *(_QWORD *)(a8 + 8) = time(0LL);
      goto LABEL_15;
    }
    result = 0LL;
  }
  return result;
}

//----- (000000000001259A) ----------------------------------------------------
signed __int64 __fastcall sub_1259A(size_t a1, _DWORD *a2)
{
  unsigned int v2; // ST28_4
  signed __int64 result; // rax
  signed int i; // [rsp+18h] [rbp-128h]
  unsigned int v5; // [rsp+1Ch] [rbp-124h]
  unsigned __int8 *v6; // [rsp+20h] [rbp-120h]
  char v7; // [rsp+28h] [rbp-118h]
  char v8[264]; // [rsp+30h] [rbp-110h]
  unsigned __int64 v9; // [rsp+138h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  if ( *a2 )
  {
LABEL_15:
    while ( !*(_DWORD *)(a1 + 508) )
    {
      v5 = sub_2445D(a1);
      if ( v5 == -37 )
        return 4294967259LL;
      if ( (v5 & 0x80000000) != 0 )
      {
        *a2 = 0;
        return v5;
      }
      if ( v5 && !(unsigned int)sub_12289(a1, v5, &v6, &v7, 0, 0LL, 0LL) )
      {
        (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(v6, a1);
        *a2 = 0;
        return v5;
      }
    }
    result = 4294967283LL;
  }
  else
  {
    for ( i = 1; i <= 255; ++i )
      v8[i - 1] = i;
    if ( (unsigned int)sub_1238D(a1, v8, &v6, &v7, 0, 0LL, 0LL) )
    {
      *a2 = 2;
      goto LABEL_15;
    }
    v2 = *v6;
    (*(void (__fastcall **)(unsigned __int8 *, size_t))(a1 + 24))(v6, a1);
    result = v2;
  }
  return result;
}
// 1259A: using guessed type char var_110[264];

//----- (0000000000012797) ----------------------------------------------------
signed __int64 __fastcall sub_12797(size_t a1, const char *a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t a7, time_t *a8)
{
  signed __int64 result; // rax
  void *v9; // [rsp+8h] [rbp-40h]
  int v10; // [rsp+14h] [rbp-34h]
  _QWORD *v11; // [rsp+18h] [rbp-30h]
  _QWORD *v12; // [rsp+20h] [rbp-28h]
  int c; // [rsp+3Ch] [rbp-Ch]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( (unsigned int)sub_1238D(a1, a2, a3, a4, a5, a6, a7) )
  {
    if ( !*a8 )
      *a8 = time(0LL);
    while ( *(_DWORD *)(a1 + 508) != -1 )
    {
      c = sub_2445D(a1);
      if ( c < 0 && c != -37 )
      {
        *a8 = 0LL;
        return (unsigned int)c;
      }
      if ( c <= 0 )
      {
        if ( 60 - (time(0LL) - *a8) <= 0 )
        {
          *a8 = 0LL;
          return 4294967287LL;
        }
        if ( c == -37 )
          return 4294967259LL;
      }
      if ( strchr(a2, c) )
        return sub_1238D(a1, a2, v12, v11, v10, v9, a7);
    }
    *a8 = 0LL;
    result = 4294967283LL;
  }
  else
  {
    *a8 = 0LL;
    result = 0LL;
  }
  return result;
}

//----- (0000000000012917) ----------------------------------------------------
__int64 __fastcall sub_12917(__int64 a1, __int64 a2, signed int a3)
{
  __int64 result; // rax
  signed int v4; // [rsp+Ch] [rbp-24h]

  v4 = a3;
  if ( a3 == 6 && a1 && *(_DWORD *)(a1 + 8) == 1 )
    v4 = 7;
  if ( v4 >= 0 && v4 <= 8 )
    result = sub_FF92(a2, 0xFFFFFFDC, (__int64)off_2319C8[3 * v4]);
  else
    result = sub_FF92(a2, 0xFFFFFFDC, (__int64)"unknown");
  return result;
}

//----- (00000000000129A0) ----------------------------------------------------
signed __int64 __fastcall sub_129A0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-48h]
  int v5; // [rsp+2Ch] [rbp-24h]
  int v6; // [rsp+2Ch] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  __int64 v8; // [rsp+38h] [rbp-18h]
  char v9; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v4 = a3;
  v10 = __readfsqword(0x28u);
  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !*(_DWORD *)(a1 + 12) )
  {
    v5 = sub_86FF(v7, 0, (__int64)&v9, 4);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 != 4 )
      return sub_FF92(v8, 0xFFFFFFDC, (__int64)"Invalid response from publickey subsystem");
    *(_QWORD *)(a1 + 24) = (unsigned int)sub_10071((unsigned int *)&v9);
    *(_QWORD *)(a1 + 16) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v8 + 8))(*(_QWORD *)(a1 + 24), v8);
    if ( !*(_QWORD *)(a1 + 16) )
      return sub_FF92(v8, 0xFFFFFFFA, (__int64)"Unable to allocate publickey response buffer");
    *(_DWORD *)(a1 + 12) = 3;
  }
  if ( *(_DWORD *)(a1 + 12) == 3 )
  {
    v6 = sub_86FF(v7, 0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v6 != (unsigned int)*(_QWORD *)(a1 + 24) )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v8 + 24))(*(_QWORD *)(a1 + 16), v8);
      *(_QWORD *)(a1 + 16) = 0LL;
      *(_DWORD *)(a1 + 12) = 0;
      return sub_FF92(v8, 0xFFFFFFE2, (__int64)"Timeout waiting for publickey subsystem response packet");
    }
    *a2 = *(_QWORD *)(a1 + 16);
    *v4 = *(_QWORD *)(a1 + 24);
  }
  *(_DWORD *)(a1 + 12) = 0;
  return 0LL;
}

//----- (0000000000012B89) ----------------------------------------------------
signed __int64 __fastcall sub_12B89(unsigned int **a1, unsigned __int64 a2)
{
  const char **v3; // [rsp+18h] [rbp-18h]
  unsigned int *s2; // [rsp+20h] [rbp-10h]
  char *s2a; // [rsp+20h] [rbp-10h]
  unsigned __int64 n; // [rsp+28h] [rbp-8h]

  s2 = *a1;
  v3 = (const char **)&unk_231960;
  if ( a2 <= 3 )
    return 0xFFFFFFFFLL;
  n = (unsigned int)sub_10071(s2);
  s2a = (char *)(s2 + 1);
  if ( a2 - 4 < n )
    return 0xFFFFFFFFLL;
  while ( v3[1] )
  {
    if ( n == *((_DWORD *)v3 + 4) && !strncmp(v3[1], s2a, n) )
    {
      *a1 = (unsigned int *)&s2a[n];
      return *(unsigned int *)v3;
    }
    v3 += 3;
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000012C4E) ----------------------------------------------------
signed __int64 __fastcall sub_12C4E(__int64 a1)
{
  int v2; // [rsp+18h] [rbp-38h]
  int v3; // [rsp+1Ch] [rbp-34h]
  unsigned int *v4; // [rsp+20h] [rbp-30h]
  unsigned int *v5; // [rsp+28h] [rbp-28h]
  unsigned __int64 v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v7 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  while ( 1 )
  {
    v2 = sub_129A0(a1, &v4, &v6);
    if ( v2 == -37 )
      return 4294967259LL;
    if ( v2 )
      return sub_FF92(v7, 0xFFFFFFE2, (__int64)"Timeout waiting for response from publickey subsystem");
    v5 = v4;
    v3 = sub_12B89(&v5, v6);
    if ( !v3 )
      break;
    (*(void (__fastcall **)(unsigned int *, __int64))(v7 + 24))(v4, v7);
    if ( v3 < 0 )
      return sub_FF92(v7, 0xFFFFFFDC, (__int64)"Invalid publickey subsystem response");
    sub_FF92(v7, 0xFFFFFFDC, (__int64)"Unexpected publickey subsystem response");
    v4 = 0LL;
  }
  v8 = (unsigned int)sub_10071(v5);
  (*(void (__fastcall **)(unsigned int *, __int64))(v7 + 24))(v4, v7);
  if ( !v8 )
    return 0LL;
  sub_12917(a1, v7, v8);
  return 0xFFFFFFFFLL;
}

//----- (0000000000012DB3) ----------------------------------------------------
__int64 __fastcall sub_12DB3(size_t a1)
{
  __int64 result; // rax
  __int64 v2; // rbx
  int v3; // [rsp+18h] [rbp-48h]
  unsigned int v4; // [rsp+18h] [rbp-48h]
  int v5; // [rsp+18h] [rbp-48h]
  int v6; // [rsp+1Ch] [rbp-44h]
  unsigned int *v7; // [rsp+20h] [rbp-40h]
  void *dest; // [rsp+28h] [rbp-38h]
  __int64 v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  unsigned __int64 v12; // [rsp+48h] [rbp-18h]

  v12 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53536) )
  {
    *(_QWORD *)(a1 + 53560) = 0LL;
    *(_QWORD *)(a1 + 53544) = 0LL;
    *(_QWORD *)(a1 + 53552) = 0LL;
    *(_DWORD *)(a1 + 53536) = 1;
  }
  if ( *(_DWORD *)(a1 + 53536) == 1 )
  {
    *(_QWORD *)(a1 + 53552) = sub_54A5(a1, "session", 7u, 0x40000, 0x8000, 0LL, 0LL);
    if ( !*(_QWORD *)(a1 + 53552) )
    {
      if ( (unsigned int)libssh2_session_last_errno(a1, "session") == -37 )
        return 0LL;
      sub_FF92(a1, 0xFFFFFFEB, (__int64)"Unable to startup channel");
      goto LABEL_45;
    }
    *(_DWORD *)(a1 + 53536) = 3;
  }
  if ( *(_DWORD *)(a1 + 53536) == 3 )
  {
    v3 = sub_7A37(*(_QWORD *)(a1 + 53552), "subsystem", 9uLL, "publickey", 9uLL);
    if ( v3 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block starting publickey subsystem");
      return 0LL;
    }
    if ( v3 )
    {
      sub_FF92(a1, 0xFFFFFFEB, (__int64)"Unable to request publickey subsystem");
LABEL_45:
      *(_DWORD *)(a1 + 53536) = 7;
      if ( *(_QWORD *)(a1 + 53552) && (unsigned int)sub_92FA(*(_QWORD *)(a1 + 53552)) == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block closing channel");
        result = 0LL;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 53544) )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53544), a1);
          *(_QWORD *)(a1 + 53544) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 53560) )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
          *(_QWORD *)(a1 + 53560) = 0LL;
        }
        *(_DWORD *)(a1 + 53536) = 0;
        result = 0LL;
      }
      return result;
    }
    *(_DWORD *)(a1 + 53536) = 4;
  }
  if ( *(_DWORD *)(a1 + 53536) == 4 )
  {
    if ( (unsigned int)sub_85E1(*(_QWORD *)(a1 + 53552), 1) == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block starting publickey subsystem");
      return 0LL;
    }
    *(_QWORD *)(a1 + 53544) = (*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(128LL, a1);
    if ( !*(_QWORD *)(a1 + 53544) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate a new publickey structure");
      goto LABEL_45;
    }
    memset(*(void **)(a1 + 53544), 0, 0x80uLL);
    **(_QWORD **)(a1 + 53544) = *(_QWORD *)(a1 + 53552);
    *(_DWORD *)(*(_QWORD *)(a1 + 53544) + 8LL) = 0;
    sub_1017A((_BYTE *)(a1 + 53576), 15);
    sub_1017A((_BYTE *)(a1 + 53580), 7);
    memcpy((void *)(a1 + 53584), "version", 7uLL);
    dest = (void *)(a1 + 53591);
    sub_1017A((_BYTE *)(a1 + 53591), 2);
    *(_QWORD *)(a1 + 53600) = 0LL;
    *(_DWORD *)(a1 + 53536) = 5;
  }
  if ( *(_DWORD *)(a1 + 53536) == 5 )
  {
    v4 = sub_8C41(*(_QWORD *)(a1 + 53552), 0, (void *)(a1 + 53576), 19LL - *(_QWORD *)(a1 + 53600));
    if ( v4 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending publickey version packet");
      return 0LL;
    }
    if ( v4 )
    {
      sub_FF92(a1, v4, (__int64)"Unable to send publickey version packet");
      goto LABEL_45;
    }
    *(_QWORD *)(a1 + 53600) = *(_QWORD *)(a1 + 53600);
    if ( *(_QWORD *)(a1 + 53600) <= 0x12uLL )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Need to be called again to complete this");
      return 0LL;
    }
    *(_DWORD *)(a1 + 53536) = 6;
  }
  if ( *(_DWORD *)(a1 + 53536) != 6 )
    goto LABEL_45;
  while ( 1 )
  {
    v5 = sub_129A0(*(_QWORD *)(a1 + 53544), (_QWORD *)(a1 + 53560), (_QWORD *)(a1 + 53568));
    if ( v5 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting for response from publickey subsystem");
      return 0LL;
    }
    if ( v5 )
    {
      sub_FF92(a1, 0xFFFFFFE2, (__int64)"Timeout waiting for response from publickey subsystem");
      goto LABEL_45;
    }
    v7 = *(unsigned int **)(a1 + 53560);
    v6 = sub_12B89(&v7, *(_QWORD *)(a1 + 53568));
    if ( v6 < 0 )
    {
      sub_FF92(a1, 0xFFFFFFDC, (__int64)"Invalid publickey subsystem response code");
      goto LABEL_45;
    }
    if ( !v6 )
    {
      v9 = (unsigned int)sub_10071(v7);
      ++v7;
      v10 = (unsigned int)sub_10071(v7);
      ++v7;
      v7 = (unsigned int *)((char *)v7 + v10);
      v11 = (unsigned int)sub_10071(v7);
      ++v7;
      v7 = (unsigned int *)((char *)v7 + v11);
      if ( *(_QWORD *)(a1 + 53568) + *(_QWORD *)(a1 + 53560) >= (unsigned __int64)v7 )
        sub_12917(0LL, a1, v9);
      else
        sub_FF92(a1, 0xFFFFFFDC, (__int64)"Malformed publickey subsystem packet");
      goto LABEL_45;
    }
    if ( v6 == 1 )
      break;
    sub_FF92(a1, 0xFFFFFFDC, (__int64)"Unexpected publickey subsystem response, ignoring");
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
    *(_QWORD *)(a1 + 53560) = 0LL;
  }
  v2 = *(_QWORD *)(a1 + 53544);
  *(_DWORD *)(v2 + 8) = sub_10071(v7);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 53544) + 8LL) > 2u )
    *(_DWORD *)(*(_QWORD *)(a1 + 53544) + 8LL) = 2;
  (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
  *(_QWORD *)(a1 + 53560) = 0LL;
  *(_DWORD *)(a1 + 53536) = 0;
  return *(_QWORD *)(a1 + 53544);
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000001356A) ----------------------------------------------------
__int64 __fastcall libssh2_publickey_init(size_t a1, time_t a2)
{
  time_t v3; // [rsp+20h] [rbp-10h]
  __int64 v4; // [rsp+28h] [rbp-8h]

  v3 = time(0LL);
  do
  {
    v4 = sub_12DB3(a1);
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    if ( v4 )
      break;
    if ( (unsigned int)libssh2_session_last_errno(a1, a2) != -37 )
      break;
    a2 = v3;
  }
  while ( !(unsigned int)sub_179AF(a1, v3) );
  return v4;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (00000000000135DC) ----------------------------------------------------
signed __int64 __fastcall libssh2_publickey_add_ex(__int64 a1, const void *a2, size_t a3, void *a4, size_t a5, char a6, unsigned __int64 a7, __int64 a8)
{
  bool *v9; // rax
  bool v10; // si
  bool *v11; // rax
  char v12; // [rsp+4h] [rbp-6Ch]
  size_t v13; // [rsp+8h] [rbp-68h]
  void *v14; // [rsp+10h] [rbp-60h]
  size_t v15; // [rsp+18h] [rbp-58h]
  int v16; // [rsp+3Ch] [rbp-34h]
  unsigned int v17; // [rsp+3Ch] [rbp-34h]
  unsigned __int64 i; // [rsp+40h] [rbp-30h]
  unsigned __int64 j; // [rsp+40h] [rbp-30h]
  unsigned __int64 k; // [rsp+40h] [rbp-30h]
  signed __int64 v21; // [rsp+48h] [rbp-28h]
  signed __int64 v22; // [rsp+48h] [rbp-28h]
  void *src; // [rsp+50h] [rbp-20h]
  size_t n; // [rsp+58h] [rbp-18h]
  __int64 v25; // [rsp+60h] [rbp-10h]
  __int64 v26; // [rsp+68h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v21 = a3 + a5 + 19;
  src = 0LL;
  n = 0LL;
  if ( !a1 )
    return 4294967257LL;
  v25 = *(_QWORD *)a1;
  v26 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !*(_DWORD *)(a1 + 32) )
  {
    *(_QWORD *)(a1 + 40) = 0LL;
    if ( *(_DWORD *)(a1 + 8) == 1 )
    {
      for ( i = 0LL; i < a7; ++i )
      {
        if ( *(_QWORD *)(40 * i + a8 + 8) == 7LL && !strncmp(*(const char **)(40 * i + a8), "comment", 7uLL) )
        {
          src = *(void **)(40 * i + a8 + 16);
          n = *(_QWORD *)(40 * i + a8 + 24);
          break;
        }
      }
      v22 = n + v21 + 4;
    }
    else
    {
      v22 = a3 + a5 + 24;
      for ( j = 0LL; j < a7; ++j )
        v22 += *(_QWORD *)(40 * j + a8 + 8) + *(_QWORD *)(40 * j + a8 + 24) + 9LL;
    }
    *(_QWORD *)(a1 + 40) = (*(__int64 (__fastcall **)(signed __int64, __int64))(v26 + 8))(v22, v26);
    if ( !*(_QWORD *)(a1 + 40) )
      return sub_FF92(v26, 0xFFFFFFFA, (__int64)"Unable to allocate memory for publickey \"add\" packet");
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40);
    sub_1017A(*(_BYTE **)(a1 + 48), v22 - 4);
    *(_QWORD *)(a1 + 48) += 4LL;
    sub_1017A(*(_BYTE **)(a1 + 48), 3);
    *(_QWORD *)(a1 + 48) += 4LL;
    memcpy(*(void **)(a1 + 48), "add", 3uLL);
    *(_QWORD *)(a1 + 48) += 3LL;
    if ( *(_DWORD *)(a1 + 8) == 1 )
    {
      sub_1017A(*(_BYTE **)(a1 + 48), n);
      *(_QWORD *)(a1 + 48) += 4LL;
      if ( src )
      {
        memcpy(*(void **)(a1 + 48), src, n);
        *(_QWORD *)(a1 + 48) += n;
      }
      sub_1017A(*(_BYTE **)(a1 + 48), v15);
      *(_QWORD *)(a1 + 48) += 4LL;
      memcpy(*(void **)(a1 + 48), a2, v15);
      *(_QWORD *)(a1 + 48) += v15;
      sub_1017A(*(_BYTE **)(a1 + 48), v13);
      *(_QWORD *)(a1 + 48) += 4LL;
      memcpy(*(void **)(a1 + 48), v14, v13);
      *(_QWORD *)(a1 + 48) += v13;
    }
    else
    {
      sub_1017A(*(_BYTE **)(a1 + 48), v15);
      *(_QWORD *)(a1 + 48) += 4LL;
      memcpy(*(void **)(a1 + 48), a2, v15);
      *(_QWORD *)(a1 + 48) += v15;
      sub_1017A(*(_BYTE **)(a1 + 48), v13);
      *(_QWORD *)(a1 + 48) += 4LL;
      memcpy(*(void **)(a1 + 48), v14, v13);
      *(_QWORD *)(a1 + 48) += v13;
      v9 = *(bool **)(a1 + 48);
      *(_QWORD *)(a1 + 48) = v9 + 1;
      *v9 = v12 != 0;
      sub_1017A(*(_BYTE **)(a1 + 48), a7);
      *(_QWORD *)(a1 + 48) += 4LL;
      for ( k = 0LL; k < a7; ++k )
      {
        sub_1017A(*(_BYTE **)(a1 + 48), *(_QWORD *)(40 * k + a8 + 8));
        *(_QWORD *)(a1 + 48) += 4LL;
        memcpy(*(void **)(a1 + 48), *(const void **)(40 * k + a8), *(_QWORD *)(40 * k + a8 + 8));
        *(_QWORD *)(a1 + 48) += *(_QWORD *)(40 * k + a8 + 8);
        sub_1017A(*(_BYTE **)(a1 + 48), *(_QWORD *)(40 * k + a8 + 24));
        *(_QWORD *)(a1 + 48) += 4LL;
        memcpy(*(void **)(a1 + 48), *(const void **)(40 * k + a8 + 16), *(_QWORD *)(40 * k + a8 + 24));
        *(_QWORD *)(a1 + 48) += *(_QWORD *)(40 * k + a8 + 24);
        v10 = *(_BYTE *)(40 * k + a8 + 32) != 0;
        v11 = *(bool **)(a1 + 48);
        *(_QWORD *)(a1 + 48) = v11 + 1;
        *v11 = v10;
      }
    }
    *(_DWORD *)(a1 + 32) = 2;
  }
  if ( *(_DWORD *)(a1 + 32) == 2 )
  {
    v16 = sub_8C41(v25, 0, *(void **)(a1 + 40), *(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40));
    if ( v16 == -37 )
      return 4294967259LL;
    if ( *(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40) != v16 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v26 + 24))(*(_QWORD *)(a1 + 40), v26);
      *(_QWORD *)(a1 + 40) = 0LL;
      return sub_FF92(v26, 0xFFFFFFF9, (__int64)"Unable to send publickey add packet");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v26 + 24))(*(_QWORD *)(a1 + 40), v26);
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_DWORD *)(a1 + 32) = 3;
  }
  v17 = sub_12C4E(a1);
  if ( v17 != -37 )
    *(_DWORD *)(a1 + 32) = 0;
  return v17;
}

//----- (0000000000013E07) ----------------------------------------------------
signed __int64 __fastcall libssh2_publickey_remove_ex(__int64 a1, const void *a2, size_t a3, void *a4, size_t a5)
{
  size_t v6; // [rsp+8h] [rbp-48h]
  void *v7; // [rsp+10h] [rbp-40h]
  size_t n; // [rsp+18h] [rbp-38h]
  int v9; // [rsp+34h] [rbp-1Ch]
  unsigned int v10; // [rsp+34h] [rbp-1Ch]
  signed __int64 v11; // [rsp+38h] [rbp-18h]
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  n = a3;
  v7 = a4;
  v6 = a5;
  v11 = a3 + a5 + 22;
  if ( !a1 )
    return 4294967257LL;
  v12 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !*(_DWORD *)(a1 + 56) )
  {
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 64) = (*(__int64 (__fastcall **)(signed __int64, __int64))(v13 + 8))(v11, v13);
    if ( !*(_QWORD *)(a1 + 64) )
      return sub_FF92(v13, 0xFFFFFFFA, (__int64)"Unable to allocate memory for publickey \"remove\" packet");
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 64);
    sub_1017A(*(_BYTE **)(a1 + 72), v11 - 4);
    *(_QWORD *)(a1 + 72) += 4LL;
    sub_1017A(*(_BYTE **)(a1 + 72), 6);
    *(_QWORD *)(a1 + 72) += 4LL;
    memcpy(*(void **)(a1 + 72), "remove", 6uLL);
    *(_QWORD *)(a1 + 72) += 6LL;
    sub_1017A(*(_BYTE **)(a1 + 72), n);
    *(_QWORD *)(a1 + 72) += 4LL;
    memcpy(*(void **)(a1 + 72), a2, n);
    *(_QWORD *)(a1 + 72) += n;
    sub_1017A(*(_BYTE **)(a1 + 72), v6);
    *(_QWORD *)(a1 + 72) += 4LL;
    memcpy(*(void **)(a1 + 72), v7, v6);
    *(_QWORD *)(a1 + 72) += v6;
    *(_DWORD *)(a1 + 56) = 2;
  }
  if ( *(_DWORD *)(a1 + 56) == 2 )
  {
    v9 = sub_8C41(v12, 0, *(void **)(a1 + 64), *(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64));
    if ( v9 == -37 )
      return 4294967259LL;
    if ( *(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64) != v9 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v13 + 24))(*(_QWORD *)(a1 + 64), v13);
      *(_QWORD *)(a1 + 64) = 0LL;
      *(_DWORD *)(a1 + 56) = 0;
      return sub_FF92(v13, 0xFFFFFFF9, (__int64)"Unable to send publickey remove packet");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v13 + 24))(*(_QWORD *)(a1 + 64), v13);
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_DWORD *)(a1 + 56) = 3;
  }
  v10 = sub_12C4E(a1);
  if ( v10 != -37 )
    *(_DWORD *)(a1 + 56) = 0;
  return v10;
}

//----- (0000000000014143) ----------------------------------------------------
__int64 __fastcall libssh2_publickey_list_fetch(__int64 a1, unsigned __int64 *a2, __int64 *a3)
{
  __int64 result; // rax
  __int64 v4; // ST80_8
  __int64 v5; // ST88_8
  __int64 v6; // rax
  __int64 *v7; // [rsp+8h] [rbp-98h]
  int v8; // [rsp+28h] [rbp-78h]
  int v9; // [rsp+28h] [rbp-78h]
  int v10; // [rsp+2Ch] [rbp-74h]
  __int64 v11; // [rsp+30h] [rbp-70h]
  unsigned __int64 v12; // [rsp+38h] [rbp-68h]
  unsigned __int64 v13; // [rsp+40h] [rbp-60h]
  unsigned __int64 i; // [rsp+48h] [rbp-58h]
  __int64 v15; // [rsp+58h] [rbp-48h]
  __int64 v16; // [rsp+60h] [rbp-40h]
  __int64 v17; // [rsp+70h] [rbp-30h]
  __int64 v18; // [rsp+78h] [rbp-28h]

  v7 = a3;
  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  if ( !a1 )
    return 4294967257LL;
  v15 = *(_QWORD *)a1;
  v16 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !*(_DWORD *)(a1 + 80) )
  {
    *(_QWORD *)(a1 + 112) = 0LL;
    *(_QWORD *)(a1 + 88) = a1 + 96;
    sub_1017A(*(_BYTE **)(a1 + 88), 8);
    *(_QWORD *)(a1 + 88) += 4LL;
    sub_1017A(*(_BYTE **)(a1 + 88), 4);
    *(_QWORD *)(a1 + 88) += 4LL;
    memcpy(*(void **)(a1 + 88), "list", 4uLL);
    *(_QWORD *)(a1 + 88) += 4LL;
    *(_DWORD *)(a1 + 80) = 2;
  }
  if ( *(_DWORD *)(a1 + 80) == 2 )
  {
    v8 = sub_8C41(v15, 0, (void *)(a1 + 96), *(_QWORD *)(a1 + 88) - (a1 + 96));
    if ( v8 == -37 )
    {
      result = 4294967259LL;
    }
    else
    {
      if ( *(_QWORD *)(a1 + 88) - (a1 + 96) == v8 )
      {
        *(_DWORD *)(a1 + 80) = 3;
        goto LABEL_11;
      }
      *(_DWORD *)(a1 + 80) = 0;
      result = sub_FF92(v16, 0xFFFFFFF9, (__int64)"Unable to send publickey list packet");
    }
  }
  else
  {
    while ( 1 )
    {
LABEL_11:
      v9 = sub_129A0(a1, (_QWORD *)(a1 + 112), (_QWORD *)(a1 + 120));
      if ( v9 == -37 )
        return 4294967259LL;
      if ( v9 )
      {
        sub_FF92(v16, 0xFFFFFFE2, (__int64)"Timeout waiting for response from publickey subsystem");
        goto LABEL_49;
      }
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a1 + 112);
      v10 = sub_12B89((unsigned int **)(a1 + 88), *(_QWORD *)(a1 + 120));
      if ( v10 < 0 )
      {
        sub_FF92(v16, 0xFFFFFFDC, (__int64)"Invalid publickey subsystem response code");
        goto LABEL_49;
      }
      if ( !v10 )
        break;
      if ( v10 == 2 )
      {
        if ( v12 >= v13 )
        {
          v13 += 8LL;
          if ( v11 )
            v6 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64))(v16 + 16))(v11, 56 * (v13 + 1), v16);
          else
            v6 = (*(__int64 (__fastcall **)(unsigned __int64, __int64))(v16 + 8))(56 * (v13 + 1), v16);
          if ( !v6 )
          {
            sub_FF92(v16, 0xFFFFFFFA, (__int64)"Unable to allocate memory for publickey list");
            goto LABEL_49;
          }
          v11 = v6;
        }
        if ( *(_DWORD *)(a1 + 8) == 1 )
        {
          v17 = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( v17 )
          {
            *(_QWORD *)(56 * v12 + v11 + 40) = 1LL;
            *(_QWORD *)(56 * v12 + v11 + 48) = (*(__int64 (__fastcall **)(signed __int64, __int64))(v16 + 8))(40LL, v16);
            if ( !*(_QWORD *)(56 * v12 + v11 + 48) )
            {
              sub_FF92(v16, 0xFFFFFFFA, (__int64)"Unable to allocate memory for publickey attributes");
              goto LABEL_49;
            }
            **(_QWORD **)(56 * v12 + v11 + 48) = "comment";
            *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 8LL) = 7LL;
            *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 16LL) = *(_QWORD *)(a1 + 88);
            *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 24LL) = v17;
            *(_BYTE *)(*(_QWORD *)(56 * v12 + v11 + 48) + 32LL) = 0;
            *(_QWORD *)(a1 + 88) += v17;
          }
          else
          {
            *(_QWORD *)(56 * v12 + v11 + 40) = 0LL;
            *(_QWORD *)(56 * v12 + v11 + 48) = 0LL;
          }
          *(_QWORD *)(56 * v12 + v11 + 16) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          *(_QWORD *)(v11 + 56 * v12 + 8) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v12 + v11 + 16);
          *(_QWORD *)(56 * v12 + v11 + 32) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          *(_QWORD *)(v11 + 56 * v12 + 24) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v12 + v11 + 32);
        }
        else
        {
          *(_QWORD *)(56 * v12 + v11 + 16) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          *(_QWORD *)(v11 + 56 * v12 + 8) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v12 + v11 + 16);
          *(_QWORD *)(56 * v12 + v11 + 32) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          *(_QWORD *)(v11 + 56 * v12 + 24) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v12 + v11 + 32);
          *(_QWORD *)(56 * v12 + v11 + 40) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( *(_QWORD *)(56 * v12 + v11 + 40) )
          {
            *(_QWORD *)(56 * v12 + v11 + 48) = (*(__int64 (__fastcall **)(signed __int64, __int64))(v16 + 8))(
                                                 40LL * *(_QWORD *)(56 * v12 + v11 + 40),
                                                 v16);
            if ( !*(_QWORD *)(56 * v12 + v11 + 48) )
            {
              sub_FF92(v16, 0xFFFFFFFA, (__int64)"Unable to allocate memory for publickey attributes");
              goto LABEL_49;
            }
            for ( i = 0LL; i < *(_QWORD *)(56 * v12 + v11 + 40); ++i )
            {
              *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i + 8) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
              *(_QWORD *)(a1 + 88) += 4LL;
              *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i) = *(_QWORD *)(a1 + 88);
              *(_QWORD *)(a1 + 88) += *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i + 8);
              *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i + 24) = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
              *(_QWORD *)(a1 + 88) += 4LL;
              *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i + 16) = *(_QWORD *)(a1 + 88);
              *(_QWORD *)(a1 + 88) += *(_QWORD *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i + 24);
              *(_BYTE *)(*(_QWORD *)(56 * v12 + v11 + 48) + 40 * i + 32) = 0;
            }
          }
          else
          {
            *(_QWORD *)(56 * v12 + v11 + 48) = 0LL;
          }
        }
        *(_QWORD *)(v11 + 56 * v12++) = *(_QWORD *)(a1 + 112);
        *(_QWORD *)(56 * v12 + v11) = 0LL;
        *(_QWORD *)(a1 + 112) = 0LL;
      }
      else
      {
        sub_FF92(v16, 0xFFFFFFDC, (__int64)"Unexpected publickey subsystem response");
        (*(void (__fastcall **)(_QWORD, __int64))(v16 + 24))(*(_QWORD *)(a1 + 112), v16);
        *(_QWORD *)(a1 + 112) = 0LL;
      }
    }
    v18 = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
    *(_QWORD *)(a1 + 88) += 4LL;
    v4 = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
    *(_QWORD *)(a1 + 88) += 4LL;
    *(_QWORD *)(a1 + 88) += v4;
    v5 = (unsigned int)sub_10071(*(unsigned int **)(a1 + 88));
    *(_QWORD *)(a1 + 88) += 4LL;
    *(_QWORD *)(a1 + 88) += v5;
    if ( *(_QWORD *)(a1 + 88) <= *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
    {
      if ( !v18 )
      {
        (*(void (__fastcall **)(_QWORD, __int64))(v16 + 24))(*(_QWORD *)(a1 + 112), v16);
        *(_QWORD *)(a1 + 112) = 0LL;
        *v7 = v11;
        *a2 = v12;
        *(_DWORD *)(a1 + 80) = 0;
        return 0LL;
      }
      sub_12917(a1, v16, v18);
    }
    else
    {
      sub_FF92(v16, 0xFFFFFFDC, (__int64)"Malformed publickey subsystem packet");
    }
LABEL_49:
    if ( *(_QWORD *)(a1 + 112) )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v16 + 24))(*(_QWORD *)(a1 + 112), v16);
      *(_QWORD *)(a1 + 112) = 0LL;
    }
    if ( v11 )
      libssh2_publickey_list_free(a1, v11);
    *(_DWORD *)(a1 + 80) = 0;
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 4D80: using guessed type __int64 __fastcall libssh2_publickey_list_free(_QWORD, _QWORD);

//----- (000000000001504D) ----------------------------------------------------
__int64 __fastcall libssh2_publickey_list_free(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  _QWORD *v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  result = (__int64)a2;
  v3 = a2;
  if ( a1 && a2 )
  {
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
    while ( *v3 )
    {
      if ( v3[6] )
        (*(void (__fastcall **)(_QWORD, __int64))(v4 + 24))(v3[6], v4);
      (*(void (__fastcall **)(_QWORD, __int64))(v4 + 24))(*v3, v4);
      v3 += 7;
    }
    result = (*(__int64 (__fastcall **)(_QWORD *, __int64))(v4 + 24))(a2, v4);
  }
  return result;
}

//----- (00000000000150FE) ----------------------------------------------------
signed __int64 __fastcall libssh2_publickey_shutdown(__int64 *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v2 = *(_QWORD *)(*a1 + 96);
  if ( a1[2] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[2], v2);
    a1[2] = 0LL;
  }
  if ( a1[5] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[5], v2);
    a1[5] = 0LL;
  }
  if ( a1[8] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[8], v2);
    a1[8] = 0LL;
  }
  if ( a1[14] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[14], v2);
    a1[14] = 0LL;
  }
  if ( (unsigned int)sub_967C(*a1) == -37 )
    return 4294967259LL;
  (*(void (__fastcall **)(__int64 *, __int64))(v2 + 24))(a1, v2);
  return 0LL;
}

//----- (000000000001523A) ----------------------------------------------------
_BYTE *__fastcall sub_1523A(char *a1, _BYTE *a2, int a3)
{
  int v3; // eax
  _BYTE *v5; // rax
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  _BYTE *v11; // rax
  char *v12; // rax
  char v13; // cl
  _BYTE *v14; // rax
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  unsigned int v17; // [rsp+18h] [rbp-1Ch]
  char *v18; // [rsp+1Ch] [rbp-18h]
  _BYTE *v19; // [rsp+24h] [rbp-10h]
  unsigned __int64 v20; // [rsp+2Ch] [rbp-8h]

  v17 = 0;
  v20 = (unsigned __int64)&a2[a3];
  v18 = a1;
  v19 = a2;
  while ( *v18 && (unsigned __int64)v19 < v20 - 1 )
  {
    v3 = *v18;
    if ( v3 == 33 )
    {
      if ( v17 == 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 2) )
          return 0LL;
        *v19 = 39;
        v9 = v19 + 1;
        v19 += 2;
        *v9 = 92;
      }
      else if ( v17 < 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 1) )
          return 0LL;
        v7 = v19++;
        *v7 = 92;
      }
      else if ( v17 == 2 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 2) )
          return 0LL;
        *v19 = 34;
        v8 = v19 + 1;
        v19 += 2;
        *v8 = 92;
      }
      v17 = 0;
    }
    else if ( v3 == 39 )
    {
      if ( v17 == 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 2) )
          return 0LL;
        *v19 = 39;
        v6 = v19 + 1;
        v19 += 2;
        *v6 = 34;
      }
      else if ( v17 < 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 1) )
          return 0LL;
        v5 = v19++;
        *v5 = 34;
      }
      v17 = 2;
    }
    else
    {
      if ( v17 != 1 )
      {
        if ( v17 < 1 )
        {
          if ( v20 <= (unsigned __int64)(v19 + 1) )
            return 0LL;
          v10 = v19++;
          *v10 = 39;
        }
        else if ( v17 == 2 )
        {
          if ( v20 <= (unsigned __int64)(v19 + 2) )
            return 0LL;
          *v19 = 34;
          v11 = v19 + 1;
          v19 += 2;
          *v11 = 39;
        }
      }
      v17 = 1;
    }
    if ( v20 <= (unsigned __int64)(v19 + 1) )
      return 0LL;
    v12 = v18++;
    v13 = *v12;
    v14 = v19++;
    *v14 = v13;
  }
  if ( v17 == 1 )
  {
    if ( v20 <= (unsigned __int64)(v19 + 1) )
      return 0LL;
    v16 = v19++;
    *v16 = 39;
  }
  else if ( v17 >= 1 && v17 == 2 )
  {
    if ( v20 <= (unsigned __int64)(v19 + 1) )
      return 0LL;
    v15 = v19++;
    *v15 = 34;
  }
  if ( v20 <= (unsigned __int64)(v19 + 1) )
    return 0LL;
  *v19 = 0;
  return (_BYTE *)(v19 - a2);
}

//----- (0000000000015528) ----------------------------------------------------
__int64 __fastcall sub_15528(size_t a1, char *a2, void *a3)
{
  const char *v4; // rax
  int v5; // ST3C_4
  char *v6; // rax
  char *v7; // rax
  void *v8; // [rsp+8h] [rbp-78h]
  int v9; // [rsp+30h] [rbp-50h]
  int v10; // [rsp+30h] [rbp-50h]
  signed int v11; // [rsp+30h] [rbp-50h]
  int v12; // [rsp+30h] [rbp-50h]
  signed int v13; // [rsp+30h] [rbp-50h]
  int v14; // [rsp+30h] [rbp-50h]
  int v15; // [rsp+34h] [rbp-4Ch]
  char *endptr; // [rsp+38h] [rbp-48h]
  char *nptr; // [rsp+40h] [rbp-40h]
  char *v18; // [rsp+48h] [rbp-38h]
  __int64 v19; // [rsp+50h] [rbp-30h]
  __int64 v20; // [rsp+58h] [rbp-28h]
  char *v21; // [rsp+60h] [rbp-20h]
  char *v22; // [rsp+68h] [rbp-18h]
  __int64 v23; // [rsp+70h] [rbp-10h]
  unsigned __int64 v24; // [rsp+78h] [rbp-8h]

  v8 = a3;
  v24 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53872) )
  {
    *(_QWORD *)(a1 + 54160) = 0LL;
    *(_QWORD *)(a1 + 54168) = 0LL;
    *(_QWORD *)(a1 + 54176) = 0LL;
    *(_QWORD *)(a1 + 54184) = 0LL;
    *(_QWORD *)(a1 + 53888) = (a3 != 0LL) + 3 * strlen(a2) + 10;
    *(_QWORD *)(a1 + 53880) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53888), a1);
    if ( !*(_QWORD *)(a1 + 53880) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate a command buffer for SCP session");
      return 0LL;
    }
    if ( v8 )
      v4 = "p";
    else
      v4 = (const char *)&unk_2B716;
    snprintf(*(char **)(a1 + 53880), *(_QWORD *)(a1 + 53888), "scp -%sf ", v4);
    v5 = strlen(*(const char **)(a1 + 53880));
    sub_1523A(a2, (_BYTE *)(v5 + *(_QWORD *)(a1 + 53880)), *(unsigned __int64 *)(a1 + 53888) - v5);
    *(_DWORD *)(a1 + 53872) = 2;
  }
  if ( *(_DWORD *)(a1 + 53872) == 2 )
  {
    *(_QWORD *)(a1 + 54192) = sub_54A5(a1, "session", 7u, 0x40000, 0x8000, 0LL, 0LL);
    if ( !*(_QWORD *)(a1 + 54192) )
    {
      if ( (unsigned int)libssh2_session_last_errno(a1, "session") == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block starting up channel");
      }
      else
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53880), a1);
        *(_QWORD *)(a1 + 53880) = 0LL;
        *(_DWORD *)(a1 + 53872) = 0;
      }
      return 0LL;
    }
    *(_DWORD *)(a1 + 53872) = 3;
  }
  if ( *(_DWORD *)(a1 + 53872) == 3 )
  {
    v9 = sub_7A37(*(_QWORD *)(a1 + 54192), "exec", 4uLL, *(void **)(a1 + 53880), *(_QWORD *)(a1 + 53888));
    if ( v9 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block requesting SCP startup");
      return 0LL;
    }
    if ( v9 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53880), a1);
      *(_QWORD *)(a1 + 53880) = 0LL;
      goto LABEL_126;
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53880), a1);
    *(_QWORD *)(a1 + 53880) = 0LL;
    *(_BYTE *)(a1 + 53896) = 0;
    *(_DWORD *)(a1 + 53872) = 4;
  }
  if ( *(_DWORD *)(a1 + 53872) == 4 )
  {
    v10 = sub_8C41(*(_QWORD *)(a1 + 54192), 0, (void *)(a1 + 53896), 1uLL);
    if ( v10 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending initial wakeup");
      return 0LL;
    }
    if ( v10 != 1 )
      goto LABEL_126;
    *(_QWORD *)(a1 + 54152) = 0LL;
    *(_DWORD *)(a1 + 53872) = 5;
  }
  if ( *(_DWORD *)(a1 + 53872) != 5 && *(_DWORD *)(a1 + 53872) != 6 )
    goto LABEL_73;
  while ( v8 && *(_QWORD *)(a1 + 54152) <= 0xFFuLL )
  {
    if ( *(_DWORD *)(a1 + 53872) == 5 )
    {
      v11 = sub_86FF(*(_QWORD *)(a1 + 54192), 0, *(_QWORD *)(a1 + 54152) + a1 + 53896, 1);
      if ( v11 == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting for SCP response");
        return 0LL;
      }
      if ( v11 < 0 )
      {
        sub_FF92(a1, v11, (__int64)"Failed reading SCP response");
        goto LABEL_126;
      }
      if ( !v11 )
      {
LABEL_123:
        if ( (unsigned int)libssh2_channel_eof(*(_QWORD *)(a1 + 54192)) )
        {
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Unexpected channel close");
          goto LABEL_126;
        }
        return *(_QWORD *)(a1 + 54192);
      }
      ++*(_QWORD *)(a1 + 54152);
      if ( *(_BYTE *)(a1 + 53896) != 84 )
      {
        v19 = sub_8B22(*(_QWORD *)(a1 + 54192), 0);
        v20 = (*(__int64 (__fastcall **)(__int64, size_t))(a1 + 8))(v19 + 1, a1);
        if ( v20 )
        {
          sub_86FF(*(_QWORD *)(a1 + 54192), 0, v20, v19);
          *(_BYTE *)(v20 + v19) = 0;
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Failed to recv file");
          (*(void (__fastcall **)(__int64, size_t))(a1 + 24))(v20, a1);
        }
        else
        {
          sub_FF92(a1, 0xFFFFFFFA, (__int64)"Failed to get memory ");
        }
        goto LABEL_126;
      }
      if ( *(_QWORD *)(a1 + 54152) > 1uLL
        && (*(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) <= 0x2Fu
         || *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) > 0x39u)
        && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) != 32
        && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) != 13
        && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) != 10 )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid data in SCP response");
        goto LABEL_126;
      }
      if ( *(_QWORD *)(a1 + 54152) > 8uLL && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) == 10 )
      {
        while ( *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) == 13
             || *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) == 10 )
          --*(_QWORD *)(a1 + 54152);
        *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) + 53896) = 0;
        if ( *(_QWORD *)(a1 + 54152) <= 7uLL )
        {
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, too short");
          goto LABEL_126;
        }
        nptr = (char *)(a1 + 53897);
        v18 = strchr((const char *)(a1 + 53897), 32);
        if ( !v18 || v18 - nptr <= 0 )
        {
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, malformed mtime");
          goto LABEL_126;
        }
        v6 = v18++;
        *v6 = 0;
        *(_QWORD *)(a1 + 54176) = strtol(nptr, 0LL, 10);
        nptr = strchr(v18, 32);
        if ( !nptr || nptr - v18 <= 0 )
        {
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, malformed mtime.usec");
          goto LABEL_126;
        }
        v18 = strchr(++nptr, 32);
        if ( !v18 || v18 - nptr <= 0 )
        {
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, too short or malformed");
          goto LABEL_126;
        }
        *v18 = 0;
        *(_QWORD *)(a1 + 54184) = strtol(nptr, 0LL, 10);
        *(_BYTE *)(a1 + 53896) = 0;
        *(_DWORD *)(a1 + 53872) = 6;
        goto LABEL_65;
      }
      if ( *(_QWORD *)(a1 + 54152) == 256LL )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Unterminated response from SCP server");
        goto LABEL_126;
      }
    }
    else
    {
LABEL_65:
      if ( *(_DWORD *)(a1 + 53872) == 6 )
      {
        v12 = sub_8C41(*(_QWORD *)(a1 + 54192), 0, (void *)(a1 + 53896), 1uLL);
        if ( v12 == -37 )
        {
          sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting to send SCP ACK");
          return 0LL;
        }
        if ( v12 != 1 )
          goto LABEL_126;
        break;
      }
    }
  }
  *(_DWORD *)(a1 + 53872) = 7;
LABEL_73:
  if ( *(_DWORD *)(a1 + 53872) == 7 )
  {
    *(_QWORD *)(a1 + 54152) = 0LL;
    *(_DWORD *)(a1 + 53872) = 8;
  }
  if ( *(_DWORD *)(a1 + 53872) != 8 && *(_DWORD *)(a1 + 53872) != 9 )
  {
LABEL_120:
    if ( v8 )
    {
      memset(v8, 0, 0x90uLL);
      *((_QWORD *)v8 + 11) = *(_QWORD *)(a1 + 54176);
      *((_QWORD *)v8 + 9) = *(_QWORD *)(a1 + 54184);
      *((_QWORD *)v8 + 6) = *(_QWORD *)(a1 + 54168);
      *((_DWORD *)v8 + 6) = *(_QWORD *)(a1 + 54160);
    }
    *(_DWORD *)(a1 + 53872) = 0;
    return *(_QWORD *)(a1 + 54192);
  }
  while ( 1 )
  {
LABEL_118:
    if ( *(_QWORD *)(a1 + 54152) > 0xFFuLL )
      goto LABEL_119;
    endptr = 0LL;
    if ( *(_DWORD *)(a1 + 53872) != 8 )
      break;
    v13 = sub_86FF(*(_QWORD *)(a1 + 54192), 0, *(_QWORD *)(a1 + 54152) + a1 + 53896, 1);
    if ( v13 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting for SCP response");
      return 0LL;
    }
    if ( v13 < 0 )
    {
      sub_FF92(a1, v13, (__int64)"Failed reading SCP response");
      goto LABEL_126;
    }
    if ( !v13 )
      goto LABEL_123;
    ++*(_QWORD *)(a1 + 54152);
    if ( *(_BYTE *)(a1 + 53896) != 67 )
    {
      sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server");
      goto LABEL_126;
    }
    if ( *(_QWORD *)(a1 + 54152) > 1uLL
      && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) != 13
      && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) != 10
      && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) <= 0x1Fu )
    {
      sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid data in SCP response");
      goto LABEL_126;
    }
    if ( *(_QWORD *)(a1 + 54152) > 6uLL && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) == 10 )
    {
      while ( *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) == 13
           || *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) - 1LL + 53896) == 10 )
        --*(_QWORD *)(a1 + 54152);
      *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54152) + 53896) = 0;
      if ( *(_QWORD *)(a1 + 54152) <= 5uLL )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, too short");
        goto LABEL_126;
      }
      v21 = (char *)(a1 + 53897);
      v22 = strchr((const char *)(a1 + 53897), 32);
      if ( !v22 || v22 - v21 <= 0 )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, malformed mode");
        goto LABEL_126;
      }
      v7 = v22++;
      *v7 = 0;
      *(_QWORD *)(a1 + 54160) = strtol(v21, &endptr, 8);
      if ( endptr && *endptr )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, invalid mode");
        goto LABEL_126;
      }
      v21 = strchr(v22, 32);
      if ( !v21 || v21 - v22 <= 0 )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, too short or malformed");
        goto LABEL_126;
      }
      *v21 = 0;
      *(_QWORD *)(a1 + 54168) = strtoll(v22, &endptr, 10);
      if ( endptr && *endptr )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid response from SCP server, invalid size");
        goto LABEL_126;
      }
      *(_BYTE *)(a1 + 53896) = 0;
      *(_DWORD *)(a1 + 53872) = 9;
      break;
    }
    if ( *(_QWORD *)(a1 + 54152) == 256LL )
    {
      sub_FF92(a1, 0xFFFFFFE4, (__int64)"Unterminated response from SCP server");
      goto LABEL_126;
    }
  }
  if ( *(_DWORD *)(a1 + 53872) != 9 )
    goto LABEL_118;
  v14 = sub_8C41(*(_QWORD *)(a1 + 54192), 0, (void *)(a1 + 53896), 1uLL);
  if ( v14 == -37 )
  {
    sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending SCP ACK");
    return 0LL;
  }
  if ( v14 == 1 )
  {
LABEL_119:
    *(_DWORD *)(a1 + 53872) = 10;
    goto LABEL_120;
  }
LABEL_126:
  v15 = *(_DWORD *)(a1 + 528);
  v23 = *(_QWORD *)(a1 + 520);
  while ( (unsigned int)libssh2_channel_free(*(_QWORD *)(a1 + 54192)) == -37 )
    ;
  *(_DWORD *)(a1 + 528) = v15;
  *(_QWORD *)(a1 + 520) = v23;
  *(_QWORD *)(a1 + 54192) = 0LL;
  *(_DWORD *)(a1 + 53872) = 0;
  return 0LL;
}
// 4B10: using guessed type __int64 __fastcall libssh2_channel_eof(_QWORD);
// 4B90: using guessed type __int64 __fastcall libssh2_channel_free(_QWORD);
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000001650D) ----------------------------------------------------
__int64 __fastcall libssh2_scp_recv(size_t a1, char *a2, void *a3)
{
  void *v4; // [rsp+8h] [rbp-38h]
  time_t v5; // [rsp+30h] [rbp-10h]
  __int64 v6; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v5 = time(0LL);
  do
    v6 = sub_15528(a1, a2, v4);
  while ( *(_DWORD *)(a1 + 148)
       && !v6
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v5) );
  return v6;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000016592) ----------------------------------------------------
__int64 __fastcall sub_16592(size_t a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  size_t v6; // rax
  _BOOL8 v7; // rdx
  const char *v9; // rax
  int v10; // ST44_4
  __int64 v11; // [rsp+0h] [rbp-60h]
  __int64 v12; // [rsp+8h] [rbp-58h]
  __int64 v13; // [rsp+10h] [rbp-50h]
  unsigned int v14; // [rsp+1Ch] [rbp-44h]
  int v15; // [rsp+38h] [rbp-28h]
  signed int v16; // [rsp+38h] [rbp-28h]
  int v17; // [rsp+38h] [rbp-28h]
  signed int v18; // [rsp+38h] [rbp-28h]
  int v19; // [rsp+38h] [rbp-28h]
  int v20; // [rsp+38h] [rbp-28h]
  int v21; // [rsp+3Ch] [rbp-24h]
  char *v22; // [rsp+40h] [rbp-20h]
  signed __int64 v23; // [rsp+40h] [rbp-20h]
  __int64 v24; // [rsp+48h] [rbp-18h]
  __int64 v25; // [rsp+50h] [rbp-10h]
  __int64 v26; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  if ( !*(_DWORD *)(a1 + 54200) )
  {
    v6 = 3 * strlen(a2);
    v7 = v12 || v11;
    *(_QWORD *)(a1 + 54216) = v7 + v6 + 10;
    *(_QWORD *)(a1 + 54208) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 54216), a1);
    if ( !*(_QWORD *)(a1 + 54208) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate a command buffer for scp session");
      return 0LL;
    }
    if ( v12 || v11 )
      v9 = "p";
    else
      v9 = (const char *)&unk_2B716;
    snprintf(*(char **)(a1 + 54208), *(_QWORD *)(a1 + 54216), "scp -%st ", v9);
    v10 = strlen(*(const char **)(a1 + 54208));
    sub_1523A(a2, (_BYTE *)(v10 + *(_QWORD *)(a1 + 54208)), *(unsigned __int64 *)(a1 + 54216) - v10);
    *(_BYTE *)(*(_QWORD *)(a1 + 54208) + *(_QWORD *)(a1 + 54216) - 1LL) = 0;
    *(_DWORD *)(a1 + 54200) = 2;
  }
  if ( *(_DWORD *)(a1 + 54200) != 2 )
  {
LABEL_20:
    if ( *(_DWORD *)(a1 + 54200) == 3 )
    {
      v15 = sub_7A37(*(_QWORD *)(a1 + 54488), "exec", 4uLL, *(void **)(a1 + 54208), *(_QWORD *)(a1 + 54216));
      if ( v15 == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block requesting SCP startup");
        return 0LL;
      }
      if ( v15 )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
        *(_QWORD *)(a1 + 54208) = 0LL;
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Unknown error while getting error string");
        goto LABEL_84;
      }
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
      *(_QWORD *)(a1 + 54208) = 0LL;
      *(_DWORD *)(a1 + 54200) = 4;
    }
    if ( *(_DWORD *)(a1 + 54200) == 4 )
    {
      v16 = sub_86FF(*(_QWORD *)(a1 + 54488), 0, a1 + 54224, 1);
      if ( v16 == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting for response from remote");
        return 0LL;
      }
      if ( v16 < 0 )
      {
        sub_FF92(a1, v16, (__int64)"SCP failure");
        goto LABEL_84;
      }
      if ( !v16 )
        goto LABEL_81;
      if ( *(_BYTE *)(a1 + 54224) )
      {
        sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid ACK response from remote");
        goto LABEL_84;
      }
      if ( v12 || v11 )
        *(_QWORD *)(a1 + 54480) = snprintf((char *)(a1 + 54224), 0x100uLL, "T%ld 0 %ld 0\n", v12, v11);
      *(_DWORD *)(a1 + 54200) = 5;
    }
    if ( v12 || v11 )
    {
      if ( *(_DWORD *)(a1 + 54200) == 5 )
      {
        v17 = sub_8C41(*(_QWORD *)(a1 + 54488), 0, (void *)(a1 + 54224), *(_QWORD *)(a1 + 54480));
        if ( v17 == -37 )
        {
          sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending time data for SCP file");
          return 0LL;
        }
        if ( v17 != (unsigned int)*(_QWORD *)(a1 + 54480) )
        {
          sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send time data for SCP file");
          goto LABEL_84;
        }
        *(_DWORD *)(a1 + 54200) = 6;
      }
      if ( *(_DWORD *)(a1 + 54200) == 6 )
      {
        v18 = sub_86FF(*(_QWORD *)(a1 + 54488), 0, a1 + 54224, 1);
        if ( v18 == -37 )
        {
          sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting for response");
          return 0LL;
        }
        if ( v18 < 0 )
        {
          sub_FF92(a1, v18, (__int64)"SCP failure");
          goto LABEL_84;
        }
        if ( !v18 )
          goto LABEL_81;
        if ( *(_BYTE *)(a1 + 54224) )
        {
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid SCP ACK response");
          goto LABEL_84;
        }
        *(_DWORD *)(a1 + 54200) = 7;
      }
    }
    else if ( *(_DWORD *)(a1 + 54200) == 5 )
    {
      *(_DWORD *)(a1 + 54200) = 7;
    }
    if ( *(_DWORD *)(a1 + 54200) == 7 )
    {
      v22 = strrchr(a2, 47);
      if ( v22 )
        v23 = (signed __int64)(v22 + 1);
      else
        v23 = (signed __int64)a2;
      *(_QWORD *)(a1 + 54480) = snprintf((char *)(a1 + 54224), 0x100uLL, "C0%o %lld %s\n", v14, v13, v23, v11);
      *(_DWORD *)(a1 + 54200) = 8;
    }
    if ( *(_DWORD *)(a1 + 54200) == 8 )
    {
      v19 = sub_8C41(*(_QWORD *)(a1 + 54488), 0, (void *)(a1 + 54224), *(_QWORD *)(a1 + 54480));
      if ( v19 == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block send core file data for SCP file");
        return 0LL;
      }
      if ( v19 != (unsigned int)*(_QWORD *)(a1 + 54480) )
      {
        sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send core file data for SCP file");
        goto LABEL_84;
      }
      *(_DWORD *)(a1 + 54200) = 9;
    }
    if ( *(_DWORD *)(a1 + 54200) != 9 )
    {
LABEL_80:
      *(_DWORD *)(a1 + 54200) = 0;
      return *(_QWORD *)(a1 + 54488);
    }
    v20 = sub_86FF(*(_QWORD *)(a1 + 54488), 0, a1 + 54224, 1);
    if ( v20 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting for response");
      return 0LL;
    }
    if ( v20 < 0 )
    {
      sub_FF92(a1, 0xFFFFFFE4, (__int64)"Invalid ACK response from remote");
LABEL_84:
      v21 = *(_DWORD *)(a1 + 528);
      v26 = *(_QWORD *)(a1 + 520);
      while ( (unsigned int)libssh2_channel_free(*(_QWORD *)(a1 + 54488)) == -37 )
        ;
      *(_DWORD *)(a1 + 528) = v21;
      *(_QWORD *)(a1 + 520) = v26;
      *(_QWORD *)(a1 + 54488) = 0LL;
      *(_DWORD *)(a1 + 54200) = 0;
      return 0LL;
    }
    if ( v20 )
    {
      if ( *(_BYTE *)(a1 + 54224) )
      {
        v24 = sub_8B22(*(_QWORD *)(a1 + 54488), 0);
        v25 = (*(__int64 (__fastcall **)(__int64, size_t))(a1 + 8))(v24 + 1, a1);
        if ( v25 )
        {
          if ( (signed int)sub_86FF(*(_QWORD *)(a1 + 54488), 0, v25, v24) > 0 )
            *(_BYTE *)(v25 + v24) = 0;
          (*(void (__fastcall **)(__int64, size_t))(a1 + 24))(v25, a1);
          sub_FF92(a1, 0xFFFFFFE4, (__int64)"failed to send file");
        }
        else
        {
          sub_FF92(a1, 0xFFFFFFFA, (__int64)"failed to get memory");
        }
        goto LABEL_84;
      }
      goto LABEL_80;
    }
LABEL_81:
    if ( !(unsigned int)libssh2_channel_eof(*(_QWORD *)(a1 + 54488)) )
      return *(_QWORD *)(a1 + 54488);
    sub_FF92(a1, 0xFFFFFFE4, (__int64)"Unexpected channel close");
    goto LABEL_84;
  }
  *(_QWORD *)(a1 + 54488) = sub_54A5(a1, "session", 7u, 0x40000, 0x8000, 0LL, 0LL);
  if ( *(_QWORD *)(a1 + 54488) )
  {
    *(_DWORD *)(a1 + 54200) = 3;
    goto LABEL_20;
  }
  if ( (unsigned int)libssh2_session_last_errno(a1, "session") == -37 )
  {
    sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block starting up channel");
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
    *(_QWORD *)(a1 + 54208) = 0LL;
    *(_DWORD *)(a1 + 54200) = 0;
  }
  return 0LL;
}
// 4B10: using guessed type __int64 __fastcall libssh2_channel_eof(_QWORD);
// 4B90: using guessed type __int64 __fastcall libssh2_channel_free(_QWORD);
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000016F50) ----------------------------------------------------
__int64 __fastcall libssh2_scp_send_ex(size_t a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+10h] [rbp-40h]
  unsigned int v10; // [rsp+1Ch] [rbp-34h]
  time_t v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v11 = time(0LL);
  do
    v12 = sub_16592(a1, a2, v10, v9, v8, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v12
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v11) );
  return v12;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (0000000000016FEE) ----------------------------------------------------
__int64 __fastcall libssh2_scp_send64(size_t a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+10h] [rbp-40h]
  unsigned int v10; // [rsp+1Ch] [rbp-34h]
  time_t v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v11 = time(0LL);
  do
    v12 = sub_16592(a1, a2, v10, v9, v8, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v12
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v11) );
  return v12;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000001708C) ----------------------------------------------------
void *__fastcall sub_1708C(size_t a1)
{
  return malloc(a1);
}

//----- (00000000000170AA) ----------------------------------------------------
void __fastcall sub_170AA(void *a1)
{
  free(a1);
}

//----- (00000000000170C9) ----------------------------------------------------
void *__fastcall sub_170C9(void *a1, size_t a2)
{
  return realloc(a1, a2);
}

//----- (00000000000170F2) ----------------------------------------------------
__int64 __fastcall sub_170F2(__int64 a1)
{
  unsigned int v1; // er9
  __int64 result; // rax
  int v3; // eax
  char v4; // [rsp+1Fh] [rbp-11h]
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 52016) )
  {
    v5 = *(_QWORD *)(a1 + 52280);
  }
  else
  {
    v5 = 0;
    *(_DWORD *)(a1 + 52016) = 2;
  }
  while ( v5 <= 255 && (!v5 || *(_BYTE *)(a1 + v5 - 1 + 52020) != 10) )
  {
    v4 = 0;
    *(_DWORD *)(a1 + 512) &= 0xFFFFFFFE;
    if ( *(_DWORD *)(a1 + 108) )
      v1 = 0;
    else
      v1 = 0x4000;
    v6 = (*(__int64 (__fastcall **)(_QWORD, char *, signed __int64, _QWORD, __int64))(a1 + 80))(
           *(unsigned int *)(a1 + 504),
           &v4,
           1LL,
           v1,
           a1);
    if ( v6 < 0 )
    {
      if ( v6 == -11 )
      {
        *(_DWORD *)(a1 + 512) = 1;
        *(_QWORD *)(a1 + 52280) = v5;
        result = 4294967259LL;
      }
      else
      {
        *(_DWORD *)(a1 + 52016) = 0;
        *(_QWORD *)(a1 + 52280) = 0LL;
        result = 4294967253LL;
      }
      return result;
    }
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 508) = -1;
      return 4294967283LL;
    }
    if ( !v4 )
    {
      *(_DWORD *)(a1 + 52016) = 0;
      *(_QWORD *)(a1 + 52280) = 0LL;
      return 4294967294LL;
    }
    v3 = v5++;
    *(_BYTE *)(a1 + v3 + 52020) = v4;
  }
  while ( v5 && (*(_BYTE *)(a1 + v5 - 1 + 52020) == 10 || *(_BYTE *)(a1 + v5 - 1 + 52020) == 13) )
    --v5;
  *(_DWORD *)(a1 + 52016) = 0;
  *(_QWORD *)(a1 + 52280) = 0LL;
  if ( !v5 )
    return 4294967294LL;
  *(_QWORD *)(a1 + 224) = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v5 + 1, a1);
  if ( !*(_QWORD *)(a1 + 224) )
    return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Error allocating space for remote banner");
  memcpy(*(void **)(a1 + 224), (const void *)(a1 + 52020), v5);
  *(_BYTE *)(*(_QWORD *)(a1 + 224) + v5) = 0;
  return 0LL;
}

//----- (00000000000173B4) ----------------------------------------------------
signed __int64 __fastcall sub_173B4(__int64 a1)
{
  unsigned int v1; // er9
  signed __int64 result; // rax
  signed int v3; // [rsp+1Ch] [rbp-14h]
  const char *v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = "SSH-2.0-libssh2_1.4.3_DEV\r\n";
  v3 = 27;
  if ( !*(_DWORD *)(a1 + 52016) )
  {
    if ( *(_QWORD *)(a1 + 336) )
    {
      v3 = strlen(*(const char **)(a1 + 336));
      v4 = *(const char **)(a1 + 336);
    }
    *(_DWORD *)(a1 + 52016) = 2;
  }
  *(_DWORD *)(a1 + 512) &= 0xFFFFFFFD;
  if ( *(_DWORD *)(a1 + 108) )
    v1 = 0;
  else
    v1 = 0x4000;
  v5 = (*(__int64 (__fastcall **)(_QWORD, const char *, _QWORD, _QWORD, __int64))(a1 + 72))(
         *(unsigned int *)(a1 + 504),
         &v4[*(_QWORD *)(a1 + 52280)],
         v3 - *(_QWORD *)(a1 + 52280),
         v1,
         a1);
  if ( v5 == v3 - *(_QWORD *)(a1 + 52280) )
  {
    *(_DWORD *)(a1 + 52016) = 0;
    *(_QWORD *)(a1 + 52280) = 0LL;
    result = 0LL;
  }
  else if ( v5 < 0 && v5 != -11 )
  {
    *(_DWORD *)(a1 + 52016) = 0;
    *(_QWORD *)(a1 + 52280) = 0LL;
    result = 4294967253LL;
  }
  else
  {
    *(_DWORD *)(a1 + 512) = 2;
    if ( v5 > 0 )
      *(_QWORD *)(a1 + 52280) += v5;
    result = 4294967259LL;
  }
  return result;
}

//----- (0000000000017555) ----------------------------------------------------
int __fastcall sub_17555(int a1, int a2)
{
  unsigned int v2; // eax
  int v4; // [rsp+1Ch] [rbp-4h]

  v4 = fcntl(a1, 3, 0LL);
  if ( a2 )
  {
    v2 = v4;
    BYTE1(v2) |= 8u;
  }
  else
  {
    v2 = v4;
    BYTE1(v2) &= 0xF7u;
  }
  return fcntl(a1, 4, v2);
}

//----- (00000000000175C1) ----------------------------------------------------
signed __int64 __fastcall sub_175C1(int a1)
{
  signed __int64 result; // rax
  int v2; // [rsp+1Ch] [rbp-4h]

  v2 = fcntl(a1, 3, 0LL);
  if ( v2 == -1 )
    result = 1LL;
  else
    result = v2 & 0x800;
  return result;
}

//----- (00000000000175FF) ----------------------------------------------------
__int64 __fastcall libssh2_session_banner_set(__int64 a1, const char *a2)
{
  size_t v2; // rax
  signed __int64 v4; // rax
  size_t n; // [rsp+18h] [rbp-8h]

  if ( a2 )
    v2 = strlen(a2);
  else
    v2 = 0LL;
  n = v2;
  if ( *(_QWORD *)(a1 + 336) )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 336), a1);
    *(_QWORD *)(a1 + 336) = 0LL;
  }
  if ( !n )
    return 0LL;
  *(_QWORD *)(a1 + 336) = (*(__int64 (__fastcall **)(size_t, __int64))(a1 + 8))(n + 3, a1);
  if ( !*(_QWORD *)(a1 + 336) )
    return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for local banner");
  memcpy(*(void **)(a1 + 336), a2, n);
  *(_BYTE *)(*(_QWORD *)(a1 + 336) + n) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 336) + n) = 13;
  v4 = n + 1;
  *(_BYTE *)(*(_QWORD *)(a1 + 336) + v4) = 10;
  *(_BYTE *)(*(_QWORD *)(a1 + 336) + v4 + 1) = 0;
  return 0LL;
}

//----- (000000000001775C) ----------------------------------------------------
__int64 __fastcall libssh2_banner_set(__int64 a1, __int64 a2)
{
  return libssh2_session_banner_set(a1, a2);
}
// 4EE0: using guessed type __int64 __fastcall libssh2_session_banner_set(_QWORD, _QWORD);

//----- (0000000000017781) ----------------------------------------------------
void *__fastcall libssh2_session_init_ex(void *(__fastcall *a1)(size_t a1), void (__fastcall *a2)(void *a1), void *(__fastcall *a3)(void *a1, size_t a2), __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-40h]
  void *(__fastcall *v6)(void *, size_t); // [rsp+8h] [rbp-38h]
  void (__fastcall *v7)(void *); // [rsp+10h] [rbp-30h]
  void *(__fastcall *v8)(size_t); // [rsp+18h] [rbp-28h]
  void *(__fastcall *v9)(size_t); // [rsp+20h] [rbp-20h]
  void (__fastcall *v10)(void *); // [rsp+28h] [rbp-18h]
  void *(__fastcall *v11)(void *, size_t); // [rsp+30h] [rbp-10h]
  void *s; // [rsp+38h] [rbp-8h]

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5 = a4;
  v9 = sub_1708C;
  v10 = sub_170AA;
  v11 = sub_170C9;
  if ( a1 )
    v9 = v8;
  if ( v7 )
    v10 = v7;
  if ( v6 )
    v11 = v6;
  s = (void *)((__int64 (__fastcall *)(signed __int64, __int64 *))v9)(54512LL, &v5);
  if ( s )
  {
    memset(s, 0, 0xD4F0uLL);
    *((_QWORD *)s + 1) = v9;
    *((_QWORD *)s + 3) = v10;
    *((_QWORD *)s + 2) = v11;
    *((_QWORD *)s + 9) = sub_10024;
    *((_QWORD *)s + 10) = sub_FFC2;
    *(_QWORD *)s = v5;
    *((_QWORD *)s + 19) = 0LL;
    *((_DWORD *)s + 37) = 1;
    sub_29922();
  }
  return s;
}

//----- (0000000000017893) ----------------------------------------------------
__int64 __fastcall libssh2_session_callback_set(_QWORD *a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // ST20_8
  __int64 result; // rax
  __int64 v5; // ST20_8
  __int64 v6; // ST20_8
  __int64 v7; // ST20_8
  __int64 v8; // ST20_8
  __int64 v9; // ST20_8
  __int64 v10; // ST20_8

  switch ( (unsigned __int64)a2 )
  {
    case 0uLL:
      v3 = a1[4];
      a1[4] = a3;
      result = v3;
      break;
    case 1uLL:
      v5 = a1[5];
      a1[5] = a3;
      result = v5;
      break;
    case 2uLL:
      v6 = a1[6];
      a1[6] = a3;
      result = v6;
      break;
    case 3uLL:
      v7 = a1[7];
      a1[7] = a3;
      result = v7;
      break;
    case 4uLL:
      v8 = a1[8];
      a1[8] = a3;
      result = v8;
      break;
    case 5uLL:
      v9 = a1[9];
      a1[9] = a3;
      result = v9;
      break;
    case 6uLL:
      v10 = a1[10];
      a1[10] = a3;
      result = v10;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000179AF) ----------------------------------------------------
signed __int64 __fastcall sub_179AF(__int64 a1, time_t a2)
{
  int v3; // edx
  int v4; // [rsp+18h] [rbp-38h]
  _BOOL4 v5; // [rsp+1Ch] [rbp-34h]
  int v6; // [rsp+20h] [rbp-30h]
  int v7; // [rsp+24h] [rbp-2Ch]
  __int64 v8; // [rsp+28h] [rbp-28h]
  time_t time0; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  struct pollfd fds; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  v8 = 0LL;
  *(_DWORD *)(a1 + 528) = 0;
  v6 = libssh2_keepalive_send(a1, &v4);
  if ( v6 < 0 )
    return (unsigned int)v6;
  v8 = 1000 * v4;
  v7 = libssh2_session_block_directions(a1);
  if ( !v7 )
    v8 = 1000LL;
  if ( *(_QWORD *)(a1 + 152) <= 0LL || v4 && (signed __int64)v4 <= *(_QWORD *)(a1 + 152) )
  {
    v5 = v8 > 0;
  }
  else
  {
    time0 = time(0LL);
    v10 = (unsigned int)(signed int)(1000.0 * difftime(a2, time0));
    if ( v10 > *(_QWORD *)(a1 + 152) )
    {
      *(_DWORD *)(a1 + 528) = -9;
      return 4294967287LL;
    }
    v8 = *(_QWORD *)(a1 + 152) - v10;
    v5 = 1;
  }
  fds.fd = *(_DWORD *)(a1 + 504);
  fds.events = 0;
  fds.revents = 0;
  if ( v7 & 1 )
    fds.events |= 1u;
  if ( v7 & 2 )
    fds.events |= 4u;
  if ( v5 )
    v3 = v8;
  else
    v3 = -1;
  v6 = poll(&fds, 1uLL, v3);
  if ( v6 > 0 )
    return 0LL;
  *(_DWORD *)(a1 + 528) = -9;
  return 4294967287LL;
}
// 4E10: using guessed type __int64 __fastcall libssh2_keepalive_send(_QWORD, _QWORD);
// 4E40: using guessed type __int64 __fastcall libssh2_session_block_directions(_QWORD);

//----- (0000000000017B9B) ----------------------------------------------------
signed __int64 __fastcall sub_17B9B(size_t a1, int a2)
{
  signed __int64 result; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-4h]
  unsigned int v4; // [rsp+1Ch] [rbp-4h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]
  unsigned int v6; // [rsp+1Ch] [rbp-4h]
  unsigned int v7; // [rsp+1Ch] [rbp-4h]

  if ( !*(_DWORD *)(a1 + 52312) )
  {
    if ( a2 == -1 )
      return sub_FF92(a1, 0xFFFFFFD3, (__int64)"Bad socket provided");
    *(_DWORD *)(a1 + 504) = a2;
    *(_DWORD *)(a1 + 516) = (unsigned __int64)sub_175C1(*(_DWORD *)(a1 + 504)) == 0;
    if ( *(_DWORD *)(a1 + 516) )
      sub_17555(*(_DWORD *)(a1 + 504), 1);
    *(_DWORD *)(a1 + 52312) = 2;
  }
  if ( *(_DWORD *)(a1 + 52312) == 2 )
  {
    v3 = sub_173B4(a1);
    if ( v3 )
      return sub_FF92(a1, v3, (__int64)"Failed sending banner");
    *(_DWORD *)(a1 + 52312) = 3;
    *(_DWORD *)(a1 + 52016) = 0;
  }
  if ( *(_DWORD *)(a1 + 52312) == 3 )
  {
    do
    {
      v4 = sub_170F2(a1);
      if ( v4 )
        return sub_FF92(a1, v4, (__int64)"Failed getting banner");
    }
    while ( strncmp("SSH-", *(const char **)(a1 + 224), 4uLL) );
    *(_DWORD *)(a1 + 52312) = 4;
  }
  if ( *(_DWORD *)(a1 + 52312) == 4 )
  {
    v5 = sub_EFB4(a1, 0, (_DWORD *)(a1 + 52384));
    if ( v5 )
      return sub_FF92(a1, v5, (__int64)"Unable to exchange encryption keys");
    *(_DWORD *)(a1 + 52312) = 5;
  }
  if ( *(_DWORD *)(a1 + 52312) == 5 )
  {
    *(_BYTE *)(a1 + 52336) = 5;
    sub_1017A((_BYTE *)(a1 + 52337), 12);
    memcpy((void *)(a1 + 52341), "ssh-userauth", 0xCuLL);
    *(_DWORD *)(a1 + 52312) = 6;
  }
  if ( *(_DWORD *)(a1 + 52312) == 6 )
  {
    v6 = sub_24D86(a1, (const void *)(a1 + 52336), 17LL, 0LL, 0LL);
    if ( v6 )
      return sub_FF92(a1, v6, (__int64)"Unable to ask for ssh-userauth service");
    *(_DWORD *)(a1 + 52312) = 7;
  }
  if ( *(_DWORD *)(a1 + 52312) != 7 )
    return 4294967262LL;
  v7 = sub_12422(a1, 6u, (_QWORD *)(a1 + 52320), (_QWORD *)(a1 + 52328), 0, 0LL, 0LL, a1 + 52368);
  if ( v7 )
    return v7;
  *(_QWORD *)(a1 + 52360) = (unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(a1 + 52320) + 1LL));
  if ( *(_QWORD *)(a1 + 52360) == 12LL
    && !strncmp("ssh-userauth", (const char *)(*(_QWORD *)(a1 + 52320) + 5LL), *(_QWORD *)(a1 + 52360)) )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 52320), a1);
    *(_QWORD *)(a1 + 52320) = 0LL;
    *(_DWORD *)(a1 + 52312) = 0;
    result = 0LL;
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 52320), a1);
    *(_QWORD *)(a1 + 52320) = 0LL;
    result = sub_FF92(a1, 0xFFFFFFF2, (__int64)"Invalid response received from server");
  }
  return result;
}

//----- (0000000000017F9E) ----------------------------------------------------
__int64 __fastcall libssh2_session_handshake(size_t a1, int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  v4 = time(0LL);
  do
  {
    v3 = sub_17B9B(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v3 = sub_179AF(a1, v4);
  }
  while ( !v3 );
  return v3;
}

//----- (0000000000018004) ----------------------------------------------------
__int64 __fastcall libssh2_session_startup(__int64 a1, unsigned int a2)
{
  return libssh2_session_handshake(a1, a2);
}
// 5200: using guessed type __int64 __fastcall libssh2_session_handshake(_QWORD, _QWORD);

//----- (0000000000018026) ----------------------------------------------------
signed __int64 __fastcall sub_18026(__int64 a1)
{
  int v2; // [rsp+10h] [rbp-20h]
  __int64 v3; // [rsp+18h] [rbp-18h]
  __int64 v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v2 = 0;
  if ( !*(_DWORD *)(a1 + 52768) )
    *(_DWORD *)(a1 + 104) = 2;
  if ( *(_DWORD *)(a1 + 52768) == 2 )
  {
    while ( 1 )
    {
      v3 = sub_10877(a1 + 464);
      if ( !v3 )
        break;
      if ( (unsigned int)sub_967C(v3) == -37 )
        return 4294967259LL;
    }
    *(_DWORD *)(a1 + 104) = 3;
  }
  if ( *(_DWORD *)(a1 + 104) == 3 )
  {
    while ( 1 )
    {
      v4 = sub_10877(a1 + 488);
      if ( !v4 )
        break;
      if ( (unsigned int)sub_660F(v4) == -37 )
        return 4294967259LL;
    }
    *(_DWORD *)(a1 + 104) = 4;
  }
  if ( *(_DWORD *)(a1 + 104) & 2 )
  {
    if ( *(_QWORD *)(a1 + 160) && *(_QWORD *)(*(_QWORD *)(a1 + 160) + 56LL) )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 160) + 56LL))(a1, a1 + 168);
    if ( *(_QWORD *)(a1 + 360) && *(_QWORD *)(*(_QWORD *)(a1 + 360) + 48LL) )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 360) + 48LL))(a1, a1 + 368);
    if ( *(_QWORD *)(a1 + 400) && *(_QWORD *)(*(_QWORD *)(a1 + 400) + 40LL) )
      (*(void (__fastcall **)(__int64, signed __int64, __int64))(*(_QWORD *)(a1 + 400) + 40LL))(a1, 1LL, a1 + 408);
    if ( *(_QWORD *)(a1 + 376) && *(_QWORD *)(*(_QWORD *)(a1 + 376) + 32LL) )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 376) + 32LL))(a1, a1 + 392);
    if ( *(_QWORD *)(a1 + 248) && *(_QWORD *)(*(_QWORD *)(a1 + 248) + 48LL) )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 248) + 48LL))(a1, a1 + 256);
    if ( *(_QWORD *)(a1 + 288) && *(_QWORD *)(*(_QWORD *)(a1 + 288) + 40LL) )
      (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)(a1 + 288) + 40LL))(a1, 0LL, a1 + 296);
    if ( *(_QWORD *)(a1 + 264) && *(_QWORD *)(*(_QWORD *)(a1 + 264) + 32LL) )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 264) + 32LL))(a1, a1 + 280);
    if ( *(_QWORD *)(a1 + 136) )
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 136), a1);
  }
  if ( *(_QWORD *)(a1 + 224) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 224), a1);
  if ( *(_QWORD *)(a1 + 336) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 336), a1);
  if ( *(_QWORD *)(a1 + 88) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 88), a1);
  if ( *(_QWORD *)(a1 + 96) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 96), a1);
  if ( *(_QWORD *)(a1 + 344) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 344), a1);
  if ( *(_QWORD *)(a1 + 416) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 416), a1);
  if ( *(_QWORD *)(a1 + 424) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 424), a1);
  if ( *(_QWORD *)(a1 + 432) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 432), a1);
  if ( *(_QWORD *)(a1 + 440) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 440), a1);
  if ( *(_QWORD *)(a1 + 232) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 232), a1);
  if ( *(_QWORD *)(a1 + 304) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 304), a1);
  if ( *(_QWORD *)(a1 + 312) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 312), a1);
  if ( *(_QWORD *)(a1 + 320) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 320), a1);
  if ( *(_QWORD *)(a1 + 328) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 328), a1);
  if ( *(_QWORD *)(a1 + 52296) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 52296), a1);
  if ( *(_QWORD *)(a1 + 52320) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 52320), a1);
  if ( *(_QWORD *)(a1 + 53072) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53072), a1);
  if ( *(_QWORD *)(a1 + 53104) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
  if ( *(_QWORD *)(a1 + 53128) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53128), a1);
  if ( *(_QWORD *)(a1 + 53176) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53176), a1);
  if ( *(_QWORD *)(a1 + 53192) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53192), a1);
  if ( *(_QWORD *)(a1 + 53160) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53160), a1);
  if ( *(_QWORD *)(a1 + 53232) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53232), a1);
  if ( *(_QWORD *)(a1 + 53248) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
  if ( *(_QWORD *)(a1 + 53264) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
  if ( *(_QWORD *)(a1 + 53312) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
  if ( *(_QWORD *)(a1 + 53328) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53328), a1);
  if ( *(_QWORD *)(a1 + 53368) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53368), a1);
  if ( *(_QWORD *)(a1 + 53432) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
  if ( *(_QWORD *)(a1 + 53448) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53448), a1);
  if ( *(_QWORD *)(a1 + 53472) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53472), a1);
  if ( *(_QWORD *)(a1 + 53512) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53512), a1);
  if ( *(_QWORD *)(a1 + 53560) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
  if ( *(_QWORD *)(a1 + 53880) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53880), a1);
  if ( *(_QWORD *)(a1 + 54208) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
  while ( 1 )
  {
    v5 = sub_10877(a1 + 448);
    if ( !v5 )
      break;
    ++v2;
    sub_108AC(v5);
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v5 + 24), a1);
    (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v5, a1);
  }
  if ( *(_DWORD *)(a1 + 516) )
    sub_17555(*(_DWORD *)(a1 + 504), 0);
  if ( *(_QWORD *)(a1 + 176) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 176), a1);
  (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(a1, a1);
  return 0LL;
}

//----- (0000000000018A7C) ----------------------------------------------------
__int64 __fastcall libssh2_session_free(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  v3 = time(0LL);
  do
  {
    v2 = sub_18026(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v2 = sub_179AF(a1, v3);
  }
  while ( !v2 );
  return v2;
}

//----- (0000000000018ADA) ----------------------------------------------------
__int64 __fastcall sub_18ADA(__int64 a1, int a2, const char *a3, char *a4)
{
  char *v5; // [rsp+0h] [rbp-50h]
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  unsigned __int64 v8; // [rsp+38h] [rbp-18h]
  size_t v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  s = (char *)a3;
  v5 = a4;
  v10 = __readfsqword(0x28u);
  v8 = 0LL;
  v9 = 0LL;
  if ( !*(_DWORD *)(a1 + 52772) )
  {
    if ( a3 )
      v8 = strlen(a3);
    if ( v5 )
      v9 = strlen(v5);
    if ( v8 > 0x100 )
      return sub_FF92(a1, 0xFFFFFFDE, (__int64)"too long description");
    *(_QWORD *)(a1 + 53048) = v8 + v9 + 13;
    v7 = a1 + 52777;
    *(_BYTE *)(a1 + 52776) = 1;
    sub_101C7((_BYTE **)&v7, a2);
    sub_101FF((void **)&v7, s, v8);
    sub_101C7((_BYTE **)&v7, v9);
    *(_DWORD *)(a1 + 52772) = 2;
  }
  if ( (unsigned int)sub_24D86(a1, (const void *)(a1 + 52776), *(_QWORD *)(a1 + 53048), v5, v9) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 52772) = 0;
  return 0LL;
}

//----- (0000000000018C5C) ----------------------------------------------------
__int64 __fastcall libssh2_session_disconnect_ex(__int64 a1, int a2, const char *a3, char *a4)
{
  char *v5; // [rsp+0h] [rbp-30h]
  const char *v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = time(0LL);
  do
  {
    v7 = sub_18ADA(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v7 = sub_179AF(a1, v8);
  }
  while ( !v7 );
  return v7;
}

//----- (0000000000018CD0) ----------------------------------------------------
void *__fastcall libssh2_session_methods(_QWORD *a1, unsigned int a2)
{
  void *result; // rax
  void **v3; // [rsp+18h] [rbp-8h]

  switch ( (unsigned __int64)a2 )
  {
    case 0uLL:
      v3 = (void **)a1[15];
      goto LABEL_13;
    case 1uLL:
      v3 = (void **)a1[20];
      goto LABEL_13;
    case 2uLL:
      v3 = (void **)a1[45];
      goto LABEL_13;
    case 3uLL:
      v3 = (void **)a1[31];
      goto LABEL_13;
    case 4uLL:
      v3 = (void **)a1[47];
      goto LABEL_13;
    case 5uLL:
      v3 = (void **)a1[33];
      goto LABEL_13;
    case 6uLL:
      v3 = (void **)a1[50];
      goto LABEL_13;
    case 7uLL:
      v3 = (void **)a1[36];
LABEL_13:
      if ( v3 )
      {
        result = *v3;
      }
      else
      {
        sub_FF92((__int64)a1, 0xFFFFFFEF, (__int64)"No method negotiated");
        result = 0LL;
      }
      break;
    case 8uLL:
      result = &unk_2BDCB;
      break;
    case 9uLL:
      result = &unk_2BDCB;
      break;
    default:
      sub_FF92((__int64)a1, 0xFFFFFFDE, (__int64)"Invalid parameter specified for method_type");
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000018E03) ----------------------------------------------------
__int64 __fastcall libssh2_session_abstract(__int64 a1)
{
  return a1;
}

//----- (0000000000018E11) ----------------------------------------------------
__int64 __fastcall libssh2_session_last_error(__int64 a1, void **a2, _DWORD *a3, int a4)
{
  __int64 result; // rax
  const char *v5; // rax
  int v6; // [rsp+4h] [rbp-2Ch]
  _DWORD *v7; // [rsp+8h] [rbp-28h]
  size_t n; // [rsp+20h] [rbp-10h]
  char *s; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  LODWORD(n) = 0;
  if ( *(_DWORD *)(a1 + 528) )
  {
    if ( a2 )
    {
      if ( *(_QWORD *)(a1 + 520) )
        v5 = *(const char **)(a1 + 520);
      else
        v5 = (const char *)&unk_2BDCB;
      s = (char *)v5;
      n = strlen(v5);
      if ( v6 )
      {
        *a2 = (void *)(*(__int64 (__fastcall **)(size_t, __int64))(a1 + 8))(n + 1, a1);
        if ( *a2 )
        {
          memcpy(*a2, s, n);
          *((_BYTE *)*a2 + n) = 0;
        }
      }
      else
      {
        *a2 = s;
      }
    }
    if ( v7 )
      *v7 = n;
    result = *(unsigned int *)(a1 + 528);
  }
  else
  {
    if ( a2 )
    {
      if ( a4 )
      {
        *a2 = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(1LL, a1);
        if ( *a2 )
          *(_BYTE *)*a2 = 0;
      }
      else
      {
        *a2 = &unk_2BDCB;
      }
    }
    if ( v7 )
      *v7 = 0;
    result = 0LL;
  }
  return result;
}

//----- (0000000000018F7E) ----------------------------------------------------
__int64 __fastcall libssh2_session_last_errno(__int64 a1)
{
  return *(unsigned int *)(a1 + 528);
}

//----- (0000000000018F92) ----------------------------------------------------
signed __int64 __fastcall libssh2_session_flag(__int64 a1, int a2, int a3)
{
  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 108) = a3;
  }
  else
  {
    if ( a2 != 2 )
      return 4294967262LL;
    *(_DWORD *)(a1 + 112) = a3;
  }
  return 0LL;
}

//----- (0000000000018FD5) ----------------------------------------------------
__int64 __fastcall sub_18FD5(__int64 a1, int a2)
{
  unsigned int v2; // ST1C_4

  v2 = *(_DWORD *)(a1 + 148);
  *(_DWORD *)(a1 + 148) = a2;
  return v2;
}

//----- (0000000000018FFF) ----------------------------------------------------
__int64 __fastcall libssh2_session_set_blocking(__int64 a1, int a2)
{
  return sub_18FD5(a1, a2);
}

//----- (0000000000019022) ----------------------------------------------------
__int64 __fastcall libssh2_session_get_blocking(__int64 a1)
{
  return *(unsigned int *)(a1 + 148);
}

//----- (0000000000019036) ----------------------------------------------------
__int64 __fastcall libssh2_session_set_timeout(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 152) = a2;
  return result;
}

//----- (0000000000019054) ----------------------------------------------------
__int64 __fastcall libssh2_session_get_timeout(__int64 a1)
{
  return *(_QWORD *)(a1 + 152);
}

//----- (0000000000019069) ----------------------------------------------------
signed __int64 __fastcall libssh2_poll_channel_read(__int64 a1, int a2)
{
  int v3; // ebx
  __int64 i; // [rsp+10h] [rbp-20h]

  if ( !a1 )
    return 4294967257LL;
  for ( i = sub_10877(*(_QWORD *)(a1 + 96) + 448LL); i; i = sub_10889(i) )
  {
    v3 = *(_DWORD *)(a1 + 48);
    if ( v3 == (unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(i + 24) + 1LL)) )
    {
      if ( a2 == 1 && (**(_BYTE **)(i + 24) == 95 || **(_BYTE **)(i + 24) == 94) )
        return 1LL;
      if ( !a2 && **(_BYTE **)(i + 24) == 94 )
        return 1LL;
    }
  }
  return 0LL;
}

//----- (0000000000019137) ----------------------------------------------------
_BOOL8 __fastcall sub_19137(__int64 a1)
{
  return *(_DWORD *)(a1 + 56) != 0;
}

//----- (0000000000019150) ----------------------------------------------------
_BOOL8 __fastcall sub_19150(__int64 a1)
{
  return sub_10877(a1 + 48) != 0;
}

//----- (0000000000019177) ----------------------------------------------------
signed __int64 __fastcall libssh2_poll(__int64 a1, unsigned int a2, __int64 a3)
{
  void *v3; // rsp
  int v4; // eax
  int v6; // eax
  int v7; // eax
  signed int v8; // esi
  signed int v9; // esi
  __int64 v10; // rdx
  __int64 v11; // rdx
  _BOOL4 v12; // eax
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // [rsp+8h] [rbp-78h]
  unsigned int nfds[6]; // [rsp+14h] [rbp-6Ch]
  unsigned int i; // [rsp+2Ch] [rbp-54h]
  unsigned int v20; // [rsp+30h] [rbp-50h]
  int v21; // [rsp+34h] [rbp-4Ch]
  int timeout[2]; // [rsp+38h] [rbp-48h]
  __int64 v23; // [rsp+40h] [rbp-40h]
  struct pollfd *fds; // [rsp+48h] [rbp-38h]
  struct timeval tv; // [rsp+50h] [rbp-30h]
  struct timeval v26; // [rsp+60h] [rbp-20h]
  unsigned __int64 v27; // [rsp+78h] [rbp-8h]

  *(_QWORD *)&nfds[1] = a1;
  nfds[0] = a2;
  v17 = a3;
  v27 = __readfsqword(0x28u);
  v23 = 0LL;
  v3 = alloca(16 * ((8 * (unsigned __int64)a2 + 30) / 0x10));
  fds = (struct pollfd *)(16 * (((unsigned __int64)&v17 + 7) >> 4));
  for ( i = 0; ; ++i )
  {
    if ( i >= nfds[0] )
    {
      *(_QWORD *)timeout = v17;
      do
      {
        v20 = 0;
        for ( i = 0; i < nfds[0]; ++i )
        {
          if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 16) != *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) )
          {
            v6 = *(unsigned __int8 *)(32LL * i + *(_QWORD *)&nfds[1]);
            if ( v6 == 2 )
            {
              if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 16) & 1LL
                && !(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) & 1LL) )
              {
                v7 = libssh2_poll_channel_read(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8), 0LL);
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) |= v7 != 0;
              }
              if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 16) & 2LL
                && !(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) & 2LL) )
              {
                if ( (unsigned int)libssh2_poll_channel_read(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8), 1LL) )
                  v8 = 2;
                else
                  v8 = 0;
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) |= v8;
              }
              if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 16) & 4LL
                && !(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) & 4LL) )
              {
                if ( (unsigned int)sub_19137(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8)) )
                  v9 = 4;
                else
                  v9 = 0;
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) |= v9;
              }
              if ( *(_BYTE *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 84LL)
                || *(_BYTE *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 64LL) )
              {
                v10 = *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24);
                LOBYTE(v10) = v10 | 0x80;
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = v10;
              }
              if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 96LL) + 508LL) == -1 )
              {
                v11 = *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24);
                LOBYTE(v11) = v11 | 0x90;
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = v11;
              }
            }
            else if ( v6 == 3 )
            {
              if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 16) & 1LL
                && !(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) & 1LL) )
              {
                v12 = sub_19150(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8));
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) |= v12;
              }
              if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 24LL) + 508LL) == -1 )
              {
                v13 = *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24);
                LOBYTE(v13) = v13 | 0x90;
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = v13;
              }
            }
          }
          if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) )
            ++v20;
        }
        if ( v20 )
          *(_QWORD *)timeout = 0LL;
        gettimeofday(&tv, 0LL);
        v21 = poll(fds, nfds[0], timeout[0]);
        gettimeofday(&v26, 0LL);
        *(_QWORD *)timeout += -1000 * (v26.tv_sec - tv.tv_sec);
        *(_QWORD *)timeout += ((v26.tv_usec - tv.tv_usec) >> 63)
                            - ((signed __int64)((unsigned __int128)(2361183241434822607LL
                                                                  * (signed __int128)(v26.tv_usec - tv.tv_usec)) >> 64) >> 7);
        if ( v21 > 0 )
        {
          for ( i = 0; i < nfds[0]; ++i )
          {
            v14 = *(unsigned __int8 *)(32LL * i + *(_QWORD *)&nfds[1]);
            switch ( v14 )
            {
              case 2:
                if ( fds[i].events & 1 )
                {
                  while ( (signed int)sub_2445D(*(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 96LL)) > 0 )
                    ;
                }
                if ( fds[i].revents & 0x10 )
                {
                  v15 = *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24);
                  LOBYTE(v15) = v15 | 0x90;
                  *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = v15;
                }
                fds[i].revents = 0;
                break;
              case 3:
                if ( fds[i].events & 1 )
                {
                  while ( (signed int)sub_2445D(*(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 24LL)) > 0 )
                    ;
                }
                if ( fds[i].revents & 0x10 )
                {
                  v16 = *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24);
                  LOBYTE(v16) = v16 | 0x90;
                  *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = v16;
                }
                fds[i].revents = 0;
                break;
              case 1:
                *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = fds[i].revents;
                fds[i].revents = 0;
                if ( *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) )
                  ++v20;
                break;
            }
          }
        }
      }
      while ( *(_QWORD *)timeout > 0LL && !v20 );
      return v20;
    }
    *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 24) = 0LL;
    v4 = *(unsigned __int8 *)(32LL * i + *(_QWORD *)&nfds[1]);
    if ( v4 != 2 )
      break;
    fds[i].fd = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 96LL) + 504LL);
    fds[i].events = 1;
    fds[i].revents = 0;
    if ( !v23 )
      v23 = *(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 96LL);
LABEL_13:
    ;
  }
  if ( v4 == 3 )
  {
    fds[i].fd = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 24LL) + 504LL);
    fds[i].events = 1;
    fds[i].revents = 0;
    if ( !v23 )
      v23 = *(_QWORD *)(*(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8) + 24LL);
    goto LABEL_13;
  }
  if ( v4 == 1 )
  {
    fds[i].fd = *(_DWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 8);
    fds[i].events = *(_QWORD *)(32LL * i + *(_QWORD *)&nfds[1] + 16);
    fds[i].revents = 0;
    goto LABEL_13;
  }
  if ( v23 )
    sub_FF92(v23, 0xFFFFFFDD, (__int64)"Invalid descriptor passed to libssh2_poll()");
  return 0xFFFFFFFFLL;
}
// 51B0: using guessed type __int64 __fastcall libssh2_poll_channel_read(_QWORD, _QWORD);

//----- (0000000000019AF0) ----------------------------------------------------
__int64 __fastcall libssh2_session_block_directions(__int64 a1)
{
  return *(unsigned int *)(a1 + 512);
}

//----- (0000000000019B04) ----------------------------------------------------
__int64 __fastcall libssh2_session_banner_get(__int64 a1)
{
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 224) )
    return *(_QWORD *)(a1 + 224);
  return 0LL;
}

//----- (0000000000019B3E) ----------------------------------------------------
__int64 __fastcall sub_19B3E(char a1)
{
  return (a1 & 4) + (4 * a1 & 8) + (8 * a1 & 8) + 4 + (a1 & 8u);
}

//----- (0000000000019B73) ----------------------------------------------------
_QWORD *__fastcall sub_19B73(_BYTE **a1, __int64 a2)
{
  _BYTE *v2; // ST18_8
  _QWORD *result; // rax

  v2 = *a1;
  *v2 = HIBYTE(a2);
  v2[1] = BYTE6(a2);
  v2[2] = BYTE5(a2);
  v2[3] = BYTE4(a2);
  v2[4] = BYTE3(a2);
  v2[5] = BYTE2(a2);
  v2[6] = BYTE1(a2);
  v2[7] = a2;
  result = a1;
  *result += 8LL;
  return result;
}

//----- (0000000000019C36) ----------------------------------------------------
__int64 __fastcall sub_19C36(__int64 a1, int a2)
{
  __int64 i; // [rsp+18h] [rbp-8h]

  for ( i = sub_10877(a1 + 32); i && a2 != *(_DWORD *)(i + 24); i = sub_10889(i) )
    ;
  return i;
}

//----- (0000000000019C87) ----------------------------------------------------
__int64 __fastcall sub_19C87(__int64 a1, int a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  result = sub_19C36(a1, a2);
  v4 = result;
  if ( result )
  {
    sub_108AC(result);
    result = (*(__int64 (__fastcall **)(__int64, __int64))(v3 + 24))(v4, v3);
  }
  return result;
}

//----- (0000000000019CE8) ----------------------------------------------------
__int64 __fastcall sub_19CE8(_QWORD *a1, int a2)
{
  __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(*a1 + 96LL);
  v4 = (*(__int64 (__fastcall **)(signed __int64, _QWORD))(*(_QWORD *)(*a1 + 96LL) + 8LL))(
         32LL,
         *(_QWORD *)(*a1 + 96LL));
  if ( !v4 )
    return sub_FF92(v3, 0xFFFFFFFA, (__int64)"malloc fail for zombie request  ID");
  *(_DWORD *)(v4 + 24) = a2;
  sub_1080D(a1 + 4, (_QWORD *)v4);
  return 0LL;
}

//----- (0000000000019D77) ----------------------------------------------------
__int64 __fastcall sub_19D77(_QWORD *a1, unsigned __int8 *a2, __int64 a3)
{
  signed int v3; // eax
  __int64 result; // rax
  __int64 v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+2Ch] [rbp-14h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  __int64 v8; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v7 = *(_QWORD *)(*a1 + 96LL);
  v3 = *a2;
  if ( v3 <= 105 )
  {
    if ( v3 >= 101 || (unsigned int)(v3 - 1) <= 0x13 )
      goto LABEL_7;
    return sub_FF92(v7, 0xFFFFFFE1, (__int64)"Out of sync with the world");
  }
  if ( (unsigned int)(v3 - 200) > 1 )
    return sub_FF92(v7, 0xFFFFFFE1, (__int64)"Out of sync with the world");
LABEL_7:
  v6 = sub_10071((unsigned int *)(a2 + 1));
  if ( (*a2 == 101 || *a2 == 103) && sub_19C36((__int64)a1, v6) )
  {
    (*(void (__fastcall **)(unsigned __int8 *, __int64))(v7 + 24))(a2, v7);
    sub_19C87((__int64)a1, v6);
    result = 0LL;
  }
  else
  {
    v8 = (*(__int64 (__fastcall **)(signed __int64, __int64))(v7 + 8))(48LL, v7);
    if ( v8 )
    {
      *(_QWORD *)(v8 + 32) = a2;
      *(_QWORD *)(v8 + 40) = v5;
      *(_DWORD *)(v8 + 24) = v6;
      sub_1080D(a1 + 2, (_QWORD *)v8);
      result = 0LL;
    }
    else
    {
      result = sub_FF92(v7, 0xFFFFFFFA, (__int64)"Unable to allocate datablock for SFTP packet");
    }
  }
  return result;
}

//----- (0000000000019ECA) ----------------------------------------------------
signed __int64 __fastcall sub_19ECA(__int64 a1)
{
  int v1; // eax
  signed int v3; // edx
  int v4; // eax
  unsigned int v5; // [rsp+14h] [rbp-2Ch]
  unsigned __int8 *v6; // [rsp+18h] [rbp-28h]
  __int64 v7; // [rsp+20h] [rbp-20h]
  __int64 v8; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  __int64 v11; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+30h] [rbp-10h]

  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v6 = 0LL;
  v1 = *(_DWORD *)(a1 + 152);
  if ( v1 == 3 )
  {
    *(_DWORD *)(a1 + 152) = 0;
    v6 = *(unsigned __int8 **)(a1 + 80);
LABEL_18:
    if ( libssh2_channel_window_read_ex(v7, 0LL, 0LL) >= (unsigned __int64)*(unsigned int *)(a1 + 88) )
      goto LABEL_29;
    v10 = (signed int)sub_82CF(v7, 2 * *(_DWORD *)(a1 + 88), 1, 0LL);
    v3 = v10 == -37 ? 3 : 0;
    *(_DWORD *)(a1 + 152) = v3;
    if ( v10 != -37 )
      goto LABEL_29;
    return -37LL;
  }
  if ( v1 == 4 )
  {
    *(_DWORD *)(a1 + 152) = 0;
    v6 = *(unsigned __int8 **)(a1 + 80);
  }
  if ( !v6 )
  {
    v9 = sub_86FF(v7, 0, *(_QWORD *)(a1 + 72) + 64LL + a1 + 4, 4 - *(_DWORD *)(a1 + 72));
    if ( v9 == -37 )
      return -37LL;
    if ( v9 < 0 )
      return sub_FF92(v8, v9, (__int64)"channel read");
    *(_QWORD *)(a1 + 72) += v9;
    if ( *(_QWORD *)(a1 + 72) != 4LL )
      return 4294967259LL;
    *(_DWORD *)(a1 + 88) = sub_10071((unsigned int *)(a1 + 68));
    if ( *(_DWORD *)(a1 + 88) > (unsigned int)&loc_13880 )
      return sub_FF92(v8, 0xFFFFFFE7, (__int64)"SFTP packet too large");
    v6 = (unsigned __int8 *)(*(__int64 (__fastcall **)(_QWORD, __int64))(v8 + 8))(*(unsigned int *)(a1 + 88), v8);
    if ( !v6 )
      return sub_FF92(v8, 0xFFFFFFFA, (__int64)"Unable to allocate SFTP packet");
    *(_QWORD *)(a1 + 72) = 0LL;
    *(_QWORD *)(a1 + 96) = 0LL;
    *(_QWORD *)(a1 + 80) = v6;
    goto LABEL_18;
  }
LABEL_29:
  while ( (unsigned __int64)*(unsigned int *)(a1 + 88) > *(_QWORD *)(a1 + 96) )
  {
    v11 = sub_86FF(v7, 0, (__int64)&v6[*(_QWORD *)(a1 + 96)], *(_DWORD *)(a1 + 88) - *(_DWORD *)(a1 + 96));
    if ( v11 == -37 )
    {
      *(_DWORD *)(a1 + 152) = 4;
      return -37LL;
    }
    if ( v11 < 0 )
    {
      (*(void (__fastcall **)(unsigned __int8 *, __int64))(v8 + 24))(v6, v8);
      *(_QWORD *)(a1 + 80) = 0LL;
      return sub_FF92(v8, v11, (__int64)"Error waiting for SFTP packet");
    }
    *(_QWORD *)(a1 + 96) += v11;
  }
  *(_QWORD *)(a1 + 80) = 0LL;
  v5 = *v6;
  v4 = sub_19D77((_QWORD *)a1, v6, *(unsigned int *)(a1 + 88));
  v12 = v4;
  if ( !v4 )
    return v5;
  (*(void (__fastcall **)(unsigned __int8 *, __int64))(v8 + 24))(v6, v8);
  return v12;
}
// 4E50: using guessed type __int64 __fastcall libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD);

//----- (000000000001A25F) ----------------------------------------------------
unsigned __int64 __fastcall sub_1A25F(__int64 a1)
{
  int v2; // [rsp+14h] [rbp-3Ch]
  __int64 v3; // [rsp+18h] [rbp-38h]
  char v4; // [rsp+20h] [rbp-30h]
  __int64 i; // [rsp+28h] [rbp-28h]
  _QWORD *v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v6 = *(_QWORD **)(a1 + 24);
  v7 = *(_QWORD *)(*v6 + 96LL);
  for ( i = sub_10877(a1 + 376); i; i = v8 )
  {
    v8 = sub_10889(i);
    v2 = sub_1A3A2((__int64)v6, 101, *(_DWORD *)(i + 48), &v3, &v4);
    if ( v2 )
      v2 = sub_1A3A2((__int64)v6, 103, *(_DWORD *)(i + 48), &v3, &v4);
    if ( v2 )
    {
      if ( *(_QWORD *)(i + 32) )
        sub_19CE8(v6, *(_DWORD *)(i + 48));
    }
    else
    {
      (*(void (__fastcall **)(__int64, __int64))(v7 + 24))(v3, v7);
    }
    sub_108AC(i);
    (*(void (__fastcall **)(__int64, __int64))(v7 + 24))(i, v7);
  }
  return __readfsqword(0x28u) ^ v9;
}

//----- (000000000001A3A2) ----------------------------------------------------
signed __int64 __fastcall sub_1A3A2(__int64 a1, char a2, int a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-30h]
  _QWORD *v7; // [rsp+8h] [rbp-28h]
  int v8; // [rsp+10h] [rbp-20h]
  __int64 v9; // [rsp+20h] [rbp-10h]
  __int64 v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v9 = sub_10877(a1 + 16);
  if ( !v9 )
    return 0xFFFFFFFFLL;
  while ( v9 )
  {
    if ( a2 == **(_BYTE **)(v9 + 32) && (a2 == 2 || v8 == *(_DWORD *)(v9 + 24)) )
    {
      *v7 = *(_QWORD *)(v9 + 32);
      *v6 = *(_QWORD *)(v9 + 40);
      sub_108AC(v9);
      (*(void (__fastcall **)(__int64, __int64))(v10 + 24))(v9, v10);
      return 0LL;
    }
    v9 = sub_10889(v9);
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000001A483) ----------------------------------------------------
signed __int64 __fastcall sub_1A483(__int64 a1, char a2, int a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-30h]
  _QWORD *v7; // [rsp+8h] [rbp-28h]
  int v8; // [rsp+10h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  __int64 v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !(unsigned int)sub_1A3A2(a1, a2, a3, a4, a5) )
    return 0LL;
  while ( !*(_DWORD *)(v10 + 508) )
  {
    v9 = sub_19ECA(a1);
    if ( (v9 & 0x80000000) != 0 )
      return v9;
    if ( !(unsigned int)sub_1A3A2(a1, a2, v8, v7, v6) )
      return 0LL;
  }
  return 4294967283LL;
}

//----- (000000000001A52F) ----------------------------------------------------
signed __int64 __fastcall sub_1A52F(_QWORD *a1, int a2, __int64 a3, int a4, _QWORD *a5, _QWORD *a6)
{
  _QWORD *v7; // [rsp+8h] [rbp-38h]
  _QWORD *v8; // [rsp+10h] [rbp-30h]
  __int64 v9; // [rsp+18h] [rbp-28h]
  int v10; // [rsp+20h] [rbp-20h]
  int i; // [rsp+30h] [rbp-10h]
  signed int v12; // [rsp+34h] [rbp-Ch]

  v9 = a3;
  v10 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a1[13] )
    a1[13] = time(0LL);
  while ( !*(_DWORD *)(*(_QWORD *)(*a1 + 96LL) + 508LL) )
  {
    for ( i = 0; i < a2; ++i )
    {
      if ( !(unsigned int)sub_1A3A2((__int64)a1, *(_BYTE *)(i + v9), v10, v8, v7) )
      {
        a1[13] = 0LL;
        return 0LL;
      }
    }
    v12 = sub_19ECA((__int64)a1);
    if ( v12 < 0 && v12 != -37 )
    {
      a1[13] = 0LL;
      return (unsigned int)v12;
    }
    if ( v12 <= 0 )
    {
      if ( 60 - (time(0LL) - a1[13]) <= 0 )
      {
        a1[13] = 0LL;
        return 4294967287LL;
      }
      if ( v12 == -37 )
        return 4294967259LL;
    }
  }
  a1[13] = 0LL;
  return 4294967283LL;
}

//----- (000000000001A681) ----------------------------------------------------
__int64 __fastcall sub_1A681(_BYTE *a1, _QWORD *a2)
{
  __int64 result; // rax
  _BYTE *v3; // [rsp+20h] [rbp-10h]
  unsigned __int64 v4; // [rsp+28h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v3 = a1;
  if ( a2 )
  {
    sub_101C7(&v3, *a2 & 0xF);
    if ( *a2 & 1LL )
      sub_19B73(&v3, a2[1]);
    if ( *a2 & 2LL )
    {
      sub_101C7(&v3, a2[2]);
      sub_101C7(&v3, a2[3]);
    }
    if ( *a2 & 4LL )
      sub_101C7(&v3, a2[4]);
    if ( *a2 & 8LL )
    {
      sub_101C7(&v3, a2[5]);
      sub_101C7(&v3, a2[6]);
    }
    result = v3 - a1;
  }
  else
  {
    sub_1017A(v3, 0);
    result = 4LL;
  }
  return result;
}

//----- (000000000001A7DD) ----------------------------------------------------
signed __int64 __fastcall sub_1A7DD(_QWORD *a1, unsigned int *a2)
{
  unsigned int *v2; // ST18_8
  unsigned int *v3; // ST18_8
  unsigned __int8 *v5; // [rsp+18h] [rbp-8h]

  memset(a1, 0, 0x38uLL);
  *a1 = (unsigned int)sub_10071(a2);
  v5 = (unsigned __int8 *)(a2 + 1);
  if ( *a1 & 1LL )
  {
    a1[1] = sub_100C0(v5);
    v5 = (unsigned __int8 *)(a2 + 3);
  }
  if ( *a1 & 2LL )
  {
    a1[2] = (unsigned int)sub_10071((unsigned int *)v5);
    v2 = (unsigned int *)(v5 + 4);
    a1[3] = (unsigned int)sub_10071(v2);
    v5 = (unsigned __int8 *)(v2 + 1);
  }
  if ( *a1 & 4LL )
  {
    a1[4] = (unsigned int)sub_10071((unsigned int *)v5);
    v5 += 4;
  }
  if ( *a1 & 8LL )
  {
    a1[5] = (unsigned int)sub_10071((unsigned int *)v5);
    v3 = (unsigned int *)(v5 + 4);
    a1[6] = (unsigned int)sub_10071(v3);
    v5 = (unsigned __int8 *)(v3 + 1);
  }
  return v5 - (unsigned __int8 *)a2;
}

//----- (000000000001A914) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_dtor(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = *a4;
  if ( *(_QWORD *)(*a4 + 80) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v5 + 80), a1);
  if ( *(_QWORD *)(v5 + 168) )
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v5 + 168), a1);
  return (*(__int64 (__fastcall **)(__int64, __int64))(a1 + 24))(v5, a1);
}

//----- (000000000001A9AA) ----------------------------------------------------
void *__fastcall sub_1A9AA(size_t a1)
{
  int v2; // eax
  int v3; // [rsp+1Ch] [rbp-44h]
  __int64 v4; // [rsp+20h] [rbp-40h]
  unsigned __int64 v5; // [rsp+28h] [rbp-38h]
  unsigned int *v6; // [rsp+30h] [rbp-30h]
  void *s; // [rsp+38h] [rbp-28h]
  __int64 v8; // [rsp+40h] [rbp-20h]
  __int64 v9; // [rsp+48h] [rbp-18h]
  __int64 v10; // [rsp+50h] [rbp-10h]
  unsigned __int64 v11; // [rsp+58h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53836) )
  {
    if ( *(_QWORD *)(a1 + 53840) )
      __assert_fail("session->sftpInit_sftp == NULL", "sftp.c", 0x2D8u, "sftp_init");
    *(_QWORD *)(a1 + 53840) = 0LL;
    *(_DWORD *)(a1 + 53836) = 2;
  }
  s = *(void **)(a1 + 53840);
  if ( *(_DWORD *)(a1 + 53836) == 2 )
  {
    *(_QWORD *)(a1 + 53848) = sub_54A5(a1, "session", 7u, 0x40000, 0x8000, 0LL, 0LL);
    if ( !*(_QWORD *)(a1 + 53848) )
    {
      if ( (unsigned int)libssh2_session_last_errno(a1, "session") == -37 )
      {
        sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block starting up channel");
      }
      else
      {
        sub_FF92(a1, 0xFFFFFFEB, (__int64)"Unable to startup channel");
        *(_DWORD *)(a1 + 53836) = 0;
      }
      return 0LL;
    }
    *(_DWORD *)(a1 + 53836) = 3;
  }
  if ( *(_DWORD *)(a1 + 53836) == 3 )
  {
    v3 = sub_7A37(*(_QWORD *)(a1 + 53848), "subsystem", 9uLL, "sftp", 4uLL);
    if ( v3 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block to request SFTP subsystem");
      return 0LL;
    }
    if ( v3 )
    {
      sub_FF92(a1, 0xFFFFFFEB, (__int64)"Unable to request SFTP subsystem");
LABEL_42:
      while ( (unsigned int)sub_967C(*(_QWORD *)(a1 + 53848)) == -37 )
        ;
      *(_QWORD *)(a1 + 53848) = 0LL;
      if ( *(_QWORD *)(a1 + 53840) )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53840), a1);
        *(_QWORD *)(a1 + 53840) = 0LL;
      }
      *(_DWORD *)(a1 + 53836) = 0;
      return 0LL;
    }
    *(_DWORD *)(a1 + 53836) = 4;
  }
  if ( *(_DWORD *)(a1 + 53836) == 4 )
  {
    v8 = (signed int)sub_85E1(*(_QWORD *)(a1 + 53848), 1);
    if ( v8 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block requesting handle extended data");
      return 0LL;
    }
    *(_QWORD *)(a1 + 53840) = (*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(336LL, a1);
    s = *(void **)(a1 + 53840);
    if ( !s )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate a new SFTP structure");
      goto LABEL_42;
    }
    memset(s, 0, 0x150uLL);
    *(_QWORD *)s = *(_QWORD *)(a1 + 53848);
    *((_DWORD *)s + 2) = 0;
    sub_1017A((_BYTE *)(a1 + 53856), 5);
    *(_BYTE *)(a1 + 53860) = 1;
    sub_1017A((_BYTE *)(a1 + 53861), 3);
    *(_DWORD *)(a1 + 53868) = 0;
    *(_DWORD *)(a1 + 53836) = 5;
  }
  if ( *(_DWORD *)(a1 + 53836) == 5 )
  {
    v8 = sub_8C41(
           *(_QWORD *)(a1 + 53848),
           0,
           (void *)(a1 + 53856 + *(signed int *)(a1 + 53868)),
           9 - *(_DWORD *)(a1 + 53868));
    if ( v8 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block sending SSH_FXP_INIT");
      return 0LL;
    }
    if ( v8 < 0 )
    {
      sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send SSH_FXP_INIT");
      goto LABEL_42;
    }
    *(_DWORD *)(a1 + 53868) += v8;
    if ( *(_DWORD *)(a1 + 53868) == 9 )
      *(_DWORD *)(a1 + 53836) = 6;
  }
  v8 = (signed int)sub_1A483((__int64)s, 2, 0, &v4, &v5);
  if ( v8 == -37 )
    return 0LL;
  if ( v8 )
  {
    sub_FF92(a1, v8, (__int64)"Timeout waiting for response from SFTP subsystem");
    goto LABEL_42;
  }
  if ( v5 <= 4 )
  {
    sub_FF92(a1, 0xFFFFFFE1, (__int64)"Invalid SSH_FXP_VERSION response");
    goto LABEL_42;
  }
  v6 = (unsigned int *)(v4 + 1);
  v2 = sub_10071((unsigned int *)(v4 + 1));
  *((_DWORD *)s + 3) = v2;
  ++v6;
  if ( *((_DWORD *)s + 3) > 3u )
    *((_DWORD *)s + 3) = 3;
  while ( (unsigned __int64)v6 < v4 + v5 )
  {
    v9 = (unsigned int)sub_10071(v6);
    ++v6;
    v6 = (unsigned int *)((char *)v6 + v9);
    v10 = (unsigned int)sub_10071(v6);
    ++v6;
    v6 = (unsigned int *)((char *)v6 + v10);
  }
  (*(void (__fastcall **)(__int64, size_t))(a1 + 24))(v4, a1);
  *(_QWORD *)(*(_QWORD *)s + 104LL) = s;
  *(_QWORD *)(*(_QWORD *)s + 112LL) = libssh2_sftp_dtor;
  *(_DWORD *)(a1 + 53836) = 0;
  *(_QWORD *)(a1 + 53840) = 0LL;
  *(_QWORD *)(a1 + 53848) = 0LL;
  sub_107E8((_QWORD *)s + 6);
  return s;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000001AFE2) ----------------------------------------------------
void *__fastcall libssh2_sftp_init(size_t a1, time_t a2)
{
  void *result; // rax
  time_t v3; // [rsp+20h] [rbp-10h]
  void *v4; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 104) & 4 )
  {
    v3 = time(0LL);
    do
    {
      v4 = sub_1A9AA(a1);
      if ( !*(_DWORD *)(a1 + 148) )
        break;
      if ( v4 )
        break;
      if ( (unsigned int)libssh2_session_last_errno(a1, a2) != -37 )
        break;
      a2 = v3;
    }
    while ( !(unsigned int)sub_179AF(a1, v3) );
    result = v4;
  }
  else
  {
    sub_FF92(a1, 0xFFFFFFDE, (__int64)"session not authenticated yet");
    result = 0LL;
  }
  return result;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000001B092) ----------------------------------------------------
__int64 __fastcall sub_1B092(__int64 *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = *(_QWORD *)(*a1 + 96);
  if ( a1[10] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[10], v2);
    a1[10] = 0LL;
  }
  if ( a1[15] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[15], v2);
    a1[15] = 0LL;
  }
  if ( a1[21] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[21], v2);
    a1[21] = 0LL;
  }
  if ( a1[23] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[23], v2);
    a1[23] = 0LL;
  }
  if ( a1[25] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[25], v2);
    a1[25] = 0LL;
  }
  if ( a1[27] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[27], v2);
    a1[27] = 0LL;
  }
  if ( a1[30] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[30], v2);
    a1[30] = 0LL;
  }
  if ( a1[32] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[32], v2);
    a1[32] = 0LL;
  }
  if ( a1[34] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[34], v2);
    a1[34] = 0LL;
  }
  if ( a1[36] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[36], v2);
    a1[36] = 0LL;
  }
  if ( a1[38] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[38], v2);
    a1[38] = 0LL;
  }
  if ( a1[40] )
  {
    (*(void (__fastcall **)(__int64, __int64))(v2 + 24))(a1[40], v2);
    a1[40] = 0LL;
  }
  sub_1D8FE((__int64)a1);
  return (unsigned int)sub_967C(*a1);
}

//----- (000000000001B3A6) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_shutdown(__int64 *a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_1B092(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*a1 + 96) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(*a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (000000000001B420) ----------------------------------------------------
void *__fastcall sub_1B420(__int64 a1, const void *a2, size_t a3, int a4, __int64 a5, int a6)
{
  int v6; // edx
  void *result; // rax
  signed __int64 v8; // rax
  char v9; // cl
  char *v10; // rax
  __int64 v11; // rax
  unsigned int v12; // eax
  __int64 v13; // [rsp+8h] [rbp-A8h]
  int v14; // [rsp+14h] [rbp-9Ch]
  size_t v15; // [rsp+18h] [rbp-98h]
  signed int v16; // [rsp+30h] [rbp-80h]
  _BOOL4 v17; // [rsp+34h] [rbp-7Ch]
  char *v18; // [rsp+38h] [rbp-78h]
  unsigned __int64 v19; // [rsp+40h] [rbp-70h]
  __int64 v20; // [rsp+48h] [rbp-68h]
  __int64 v21; // [rsp+50h] [rbp-60h]
  __int64 v22; // [rsp+58h] [rbp-58h]
  __int64 v23; // [rsp+60h] [rbp-50h]
  void *s; // [rsp+68h] [rbp-48h]
  __int64 v25; // [rsp+70h] [rbp-40h]
  __int64 v26; // [rsp+78h] [rbp-38h]
  __int64 v27; // [rsp+80h] [rbp-30h]
  __int64 v28; // [rsp+88h] [rbp-28h]
  __int64 v29; // [rsp+90h] [rbp-20h]
  __int64 v30; // [rsp+98h] [rbp-18h]
  __int64 v31; // [rsp+A0h] [rbp-10h]
  unsigned __int64 v32; // [rsp+A8h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v32 = __readfsqword(0x28u);
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD *)(v21 + 96);
  v25 = 4LL;
  v26 = 0LL;
  v27 = 0LL;
  v28 = 0LL;
  v29 = 0LL;
  v30 = 0LL;
  v31 = 0LL;
  v17 = a6 == 0;
  if ( !*(_DWORD *)(a1 + 112) )
  {
    if ( a6 == 0 )
      v6 = (unsigned __int64)sub_19B3E(4) + 4;
    else
      v6 = 0;
    *(_DWORD *)(a1 + 128) = v6 + v15 + 13;
    *(_QWORD *)(a1 + 136) = 0LL;
    *(_QWORD *)(a1 + 120) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v22 + 8))(*(unsigned int *)(a1 + 128), v22);
    v18 = *(char **)(a1 + 120);
    if ( !*(_QWORD *)(a1 + 120) )
    {
      sub_FF92(v22, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_OPEN or FXP_OPENDIR packet");
      return 0LL;
    }
    if ( v17 )
      v8 = 0x8000LL;
    else
      v8 = 0x4000LL;
    v29 = v13 | v8;
    sub_101C7(&v18, *(_DWORD *)(a1 + 128) - 4);
    if ( v17 )
      v9 = 3;
    else
      v9 = 11;
    v10 = v18++;
    *v10 = v9;
    LODWORD(v10) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v10 + 1;
    *(_DWORD *)(a1 + 144) = (_DWORD)v10;
    sub_101C7(&v18, *(_DWORD *)(a1 + 144));
    sub_101FF((void **)&v18, a2, v15);
    if ( v17 )
    {
      sub_101C7(&v18, v14);
      v11 = sub_1A681(v18, &v25);
      v18 += v11;
    }
    *(_DWORD *)(a1 + 112) = 2;
  }
  if ( *(_DWORD *)(a1 + 112) == 2 )
  {
    v23 = sub_8C41(
            v21,
            0,
            (void *)(*(_QWORD *)(a1 + 136) + *(_QWORD *)(a1 + 120)),
            *(unsigned int *)(a1 + 128) - *(_QWORD *)(a1 + 136));
    if ( v23 == -37 )
    {
      sub_FF92(v22, 0xFFFFFFDB, (__int64)"Would block sending FXP_OPEN or FXP_OPENDIR command");
      return 0LL;
    }
    if ( v23 < 0 )
    {
      sub_FF92(v22, v23, (__int64)"Unable to send FXP_OPEN*");
      (*(void (__fastcall **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 120), v22);
      *(_QWORD *)(a1 + 120) = 0LL;
      *(_DWORD *)(a1 + 112) = 0;
      return 0LL;
    }
    *(_QWORD *)(a1 + 136) += v23;
    if ( *(_DWORD *)(a1 + 128) == *(_QWORD *)(a1 + 136) )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 120), v22);
      *(_QWORD *)(a1 + 120) = 0LL;
      *(_DWORD *)(a1 + 112) = 3;
    }
  }
  if ( *(_DWORD *)(a1 + 112) != 3 )
    return 0LL;
  v23 = (signed int)sub_1A52F((_QWORD *)a1, 2, (__int64)&off_2C8AA, *(_DWORD *)(a1 + 144), &v20, &v19);
  if ( v23 == -37 )
  {
    sub_FF92(v22, 0xFFFFFFDB, (__int64)"Would block waiting for status message");
    return 0LL;
  }
  *(_DWORD *)(a1 + 112) = 0;
  if ( v23 )
  {
    sub_FF92(v22, v23, (__int64)"Timeout waiting for status message");
    return 0LL;
  }
  if ( *(_BYTE *)v20 != 101 )
    goto LABEL_50;
  v16 = 1;
  if ( v19 <= 8 )
  {
    sub_FF92(v22, 0xFFFFFFE1, (__int64)"Too small FXP_STATUS");
    (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
    return 0LL;
  }
  *(_DWORD *)(a1 + 64) = sub_10071((unsigned int *)(v20 + 5));
  if ( !*(_DWORD *)(a1 + 64) )
  {
    (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
    v23 = (signed int)sub_1A483(a1, 102, *(_DWORD *)(a1 + 144), &v20, &v19);
    if ( v23 == -37 )
    {
      *(_DWORD *)(a1 + 112) = 3;
      return 0LL;
    }
    if ( !v23 )
      v16 = 0;
  }
  if ( v16 )
  {
    sub_FF92(v22, 0xFFFFFFE1, (__int64)"Failed opening remote file");
    (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
    result = 0LL;
  }
  else
  {
LABEL_50:
    if ( v19 > 9 )
    {
      s = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(v22 + 8))(392LL, v22);
      if ( s )
      {
        memset(s, 0, 0x188uLL);
        *((_DWORD *)s + 74) = !v17;
        v12 = sub_10071((unsigned int *)(v20 + 5));
        *((_QWORD *)s + 36) = v12;
        if ( *((_QWORD *)s + 36) > 0x100uLL )
          *((_QWORD *)s + 36) = 256LL;
        if ( *((_QWORD *)s + 36) > v19 - 9 )
          *((_QWORD *)s + 36) = v19 - 9;
        memcpy((char *)s + 32, (const void *)(v20 + 9), *((_QWORD *)s + 36));
        (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
        sub_1080D((_QWORD *)(a1 + 48), s);
        *((_QWORD *)s + 3) = a1;
        *((_QWORD *)s + 38) = 0LL;
        *((_QWORD *)s + 39) = 0LL;
        result = s;
      }
      else
      {
        sub_FF92(v22, 0xFFFFFFFA, (__int64)"Unable to allocate new SFTP handle structure");
        (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
        result = 0LL;
      }
    }
    else
    {
      sub_FF92(v22, 0xFFFFFFE1, (__int64)"Too small FXP_HANDLE");
      (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
      result = 0LL;
    }
  }
  return result;
}
// 2C8AA: using guessed type void *__ptr32 off_2C8AA;

//----- (000000000001BBD1) ----------------------------------------------------
void *__fastcall libssh2_sftp_open_ex(__int64 a1, const void *a2, unsigned int a3, int a4, __int64 a5, int a6)
{
  __int64 v7; // [rsp+8h] [rbp-48h]
  int v8; // [rsp+10h] [rbp-40h]
  int v9; // [rsp+18h] [rbp-38h]
  unsigned int v10; // [rsp+1Ch] [rbp-34h]
  time_t v11; // [rsp+40h] [rbp-10h]
  void *v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v7 = a5;
  v9 = a6;
  if ( !a1 )
    return 0LL;
  v11 = time(0LL);
  do
    v12 = sub_1B420(a1, a2, v10, v8, v7, v9);
  while ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL)
       && !v12
       && (unsigned int)libssh2_session_last_errno(*(_QWORD *)(*(_QWORD *)a1 + 96LL), a2) == -37
       && !(unsigned int)sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v11) );
  return v12;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (000000000001BC9E) ----------------------------------------------------
size_t __fastcall sub_1BC9E(_QWORD *a1, void *a2, unsigned __int64 a3)
{
  int v3; // eax
  size_t v4; // rax
  size_t result; // rax
  signed int v6; // eax
  _BYTE *v7; // rax
  int v8; // eax
  unsigned __int64 v9; // [rsp+8h] [rbp-A8h]
  int v10; // [rsp+28h] [rbp-88h]
  unsigned int v11; // [rsp+28h] [rbp-88h]
  unsigned int v12; // [rsp+2Ch] [rbp-84h]
  unsigned int v13; // [rsp+30h] [rbp-80h]
  unsigned __int8 *v14; // [rsp+38h] [rbp-78h]
  _BYTE *v15; // [rsp+40h] [rbp-70h]
  unsigned __int64 v16; // [rsp+48h] [rbp-68h]
  __int64 i; // [rsp+50h] [rbp-60h]
  unsigned __int64 v18; // [rsp+58h] [rbp-58h]
  __int64 v19; // [rsp+60h] [rbp-50h]
  __int64 v20; // [rsp+68h] [rbp-48h]
  __int64 v21; // [rsp+70h] [rbp-40h]
  _QWORD *v22; // [rsp+78h] [rbp-38h]
  unsigned __int64 v23; // [rsp+80h] [rbp-30h]
  unsigned __int64 v24; // [rsp+88h] [rbp-28h]
  __int64 v25; // [rsp+90h] [rbp-20h]
  size_t n; // [rsp+98h] [rbp-18h]
  __int64 v27; // [rsp+A0h] [rbp-10h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-8h]

  v9 = a3;
  v28 = __readfsqword(0x28u);
  v19 = a1[3];
  v20 = *(_QWORD *)v19;
  v21 = *(_QWORD *)(v20 + 96);
  v16 = 0LL;
  v22 = a1 + 38;
  v3 = *(_DWORD *)(v19 + 148);
  if ( v3 == 3 )
  {
LABEL_30:
    *(_DWORD *)(v19 + 148) = 0;
    for ( i = sub_10877((__int64)(a1 + 47)); i; i = sub_10889(i) )
    {
      if ( *(_QWORD *)(i + 40) )
      {
        v25 = sub_8C41(v20, 0, (void *)(*(_QWORD *)(i + 32) + 48LL + i + 4), *(_QWORD *)(i + 40));
        if ( v25 < 0 )
        {
          *(_DWORD *)(v19 + 148) = 3;
          return v25;
        }
        *(_QWORD *)(i + 40) -= v25;
        *(_QWORD *)(i + 32) += v25;
        if ( *(_QWORD *)(i + 40) )
          goto LABEL_37;
      }
    }
    goto LABEL_37;
  }
  if ( v3 != 5 )
  {
    if ( v3 )
      __assert_fail("!\"State machine error; unrecognised read state\"", "sftp.c", 0x610u, "sftp_read");
    if ( v22[5] )
    {
      v4 = v22[5];
      if ( a3 <= v4 )
        v4 = a3;
      n = v4;
      memcpy(a2, (const void *)(v22[3] + v22[4] - v22[5]), v4);
      v22[5] -= n;
      *v22 += n;
      if ( !v22[5] )
      {
        (*(void (__fastcall **)(_QWORD, __int64))(v21 + 24))(v22[3], v21);
        v22[3] = 0LL;
      }
      return n;
    }
    if ( !*((_BYTE *)v22 + 48) )
    {
      v23 = v22[1] - *v22;
      v18 = 4 * a3;
      if ( 4 * a3 > 0x100000 )
        v18 = 0x100000LL;
      if ( v18 > v23 )
        v16 = v18 - v23;
      v24 = libssh2_channel_window_read_ex(*(_QWORD *)v19, 0LL, 0LL);
      if ( v18 > v24 )
      {
        v25 = (signed int)sub_82CF(*(_QWORD *)v19, 8 * (signed int)v18, 1, 0LL);
        if ( v25 == -37 && v22[5] )
          __assert_fail("rc != LIBSSH2_ERROR_EAGAIN || !filep->data_left", "sftp.c", 0x546u, "sftp_read");
        if ( v25 == -37 && *((_BYTE *)v22 + 48) )
          __assert_fail("rc != LIBSSH2_ERROR_EAGAIN || !filep->eof", "sftp.c", 0x547u, "sftp_read");
        if ( v25 )
          return v25;
      }
    }
    while ( v16 )
    {
      v6 = 2000;
      if ( v16 <= 0x7D0 )
        v6 = v16;
      v12 = v6;
      v13 = a1[36] + 25;
      i = (*(__int64 (__fastcall **)(signed __int64, __int64))(v21 + 8))(v13 + 56LL, v21);
      if ( !i )
        return (signed int)sub_FF92(v21, 0xFFFFFFFA, (__int64)"malloc fail for FXP_WRITE");
      *(_QWORD *)(i + 24) = v12;
      *(_QWORD *)(i + 40) = v13;
      *(_QWORD *)(i + 32) = 0LL;
      v15 = (_BYTE *)(i + 52);
      sub_101C7(&v15, v13 - 4);
      v7 = v15++;
      *v7 = 5;
      LODWORD(v7) = *(_DWORD *)(v19 + 8);
      *(_DWORD *)(v19 + 8) = (_DWORD)v7 + 1;
      *(_DWORD *)(i + 48) = (_DWORD)v7;
      sub_101C7(&v15, (int)v7);
      sub_101FF((void **)&v15, a1 + 4, a1[36]);
      sub_19B73(&v15, v22[1]);
      v22[1] += v12;
      sub_101C7(&v15, v12);
      sub_1080D(a1 + 47, (_QWORD *)i);
      v16 -= v12;
    }
    goto LABEL_30;
  }
LABEL_37:
  *(_DWORD *)(v19 + 148) = 0;
  for ( i = sub_10877((__int64)(a1 + 47)); ; i = v27 )
  {
    if ( !i || *(_QWORD *)(i + 40) )
      return 0LL;
    v25 = (signed int)sub_1A52F((_QWORD *)v19, 2, (__int64)"geheieiehe", *(_DWORD *)(i + 48), &v14, &v15);
    if ( v25 < 0 )
    {
      *(_DWORD *)(v19 + 148) = 5;
      return v25;
    }
    v8 = *v14;
    if ( v8 == 101 )
      break;
    if ( v8 != 103 )
      return (signed int)sub_FF92(v21, 0xFFFFFFE1, (__int64)"SFTP Protocol badness: unrecognised read request response");
    v11 = sub_10071((unsigned int *)(v14 + 5));
    if ( v11 > (unsigned __int64)(v15 - 9) )
      return (signed int)sub_FF92(v21, 0xFFFFFFE1, (__int64)"SFTP Protocol badness");
    if ( v11 != *(_QWORD *)(i + 24) )
      v22[1] += v11 - *(_QWORD *)(i + 24);
    if ( v9 >= v11 )
    {
      v22[4] = 0LL;
    }
    else
    {
      v22[5] = v11 - v9;
      v11 = v9;
      v22[3] = v14;
      v22[4] = v15;
    }
    memcpy(a2, v14 + 9, v11);
    *v22 += v11;
    if ( !v22[4] )
      (*(void (__fastcall **)(unsigned __int8 *, __int64))(v21 + 24))(v14, v21);
    v27 = sub_10889(i);
    sub_108AC(i);
    (*(void (__fastcall **)(__int64, __int64))(v21 + 24))(i, v21);
    i = 0LL;
    if ( v11 )
      return v11;
  }
  v27 = sub_10889(i);
  sub_108AC(i);
  (*(void (__fastcall **)(__int64, __int64))(v21 + 24))(i, v21);
  sub_1A25F((__int64)a1);
  v10 = sub_10071((unsigned int *)(v14 + 5));
  (*(void (__fastcall **)(unsigned __int8 *, __int64))(v21 + 24))(v14, v21);
  if ( v10 == 1 )
  {
    *((_BYTE *)v22 + 48) = 1;
    result = 0LL;
  }
  else
  {
    *(_DWORD *)(v19 + 64) = v10;
    result = (signed int)sub_FF92(v21, 0xFFFFFFE1, (__int64)"SFTP READ error");
  }
  return result;
}
// 4E50: using guessed type __int64 __fastcall libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD);

//----- (000000000001C502) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_read(__int64 a1, void *a2, unsigned __int64 a3)
{
  int v4; // eax
  unsigned __int64 v5; // [rsp+8h] [rbp-28h]
  size_t v6; // [rsp+20h] [rbp-10h]
  time_t v7; // [rsp+28h] [rbp-8h]

  v5 = a3;
  if ( !a1 )
    return -39LL;
  v7 = time(0LL);
  do
  {
    v6 = sub_1BC9E((_QWORD *)a1, a2, v5);
    if ( v6 != -37LL )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v4 = sub_179AF(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v7);
    v6 = v4;
  }
  while ( !v4 );
  return v6;
}

//----- (000000000001C5A0) ----------------------------------------------------
size_t __fastcall sub_1C5A0(__int64 a1, void *a2, unsigned __int64 a3, void *a4, unsigned __int64 a5, void *a6)
{
  unsigned int v6; // eax
  __int64 *v7; // rax
  size_t result; // rax
  _BYTE *v9; // rax
  void *s; // [rsp+0h] [rbp-D0h]
  unsigned __int64 v11; // [rsp+8h] [rbp-C8h]
  void *v12; // [rsp+10h] [rbp-C0h]
  unsigned __int64 v13; // [rsp+18h] [rbp-B8h]
  unsigned int v14; // [rsp+38h] [rbp-98h]
  int v15; // [rsp+3Ch] [rbp-94h]
  char v16; // [rsp+40h] [rbp-90h]
  void *src; // [rsp+48h] [rbp-88h]
  size_t n; // [rsp+50h] [rbp-80h]
  __int64 v19; // [rsp+58h] [rbp-78h]
  __int64 v20; // [rsp+60h] [rbp-70h]
  __int64 v21; // [rsp+68h] [rbp-68h]
  __int64 v22; // [rsp+70h] [rbp-60h]
  size_t v23; // [rsp+78h] [rbp-58h]
  size_t v24; // [rsp+80h] [rbp-50h]
  __int64 v25; // [rsp+88h] [rbp-48h]
  __int64 v26; // [rsp+90h] [rbp-40h]
  unsigned __int64 v27; // [rsp+C8h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  s = a6;
  v27 = __readfsqword(0x28u);
  v19 = *(_QWORD *)(a1 + 24);
  v20 = *(_QWORD *)v19;
  v21 = *(_QWORD *)(v20 + 96);
  v14 = *(unsigned __int64 *)(a1 + 288) + 13;
  if ( !*(_DWORD *)(v19 + 160) )
  {
    if ( *(_DWORD *)(a1 + 304) )
    {
      src = *(void **)(a1 + 320);
      v6 = sub_10071((unsigned int *)src);
      v22 = v6;
      src = (char *)src + 4;
      n = v6;
      if ( v6 >= v13 )
      {
        n = -38LL;
LABEL_16:
        if ( !--*(_DWORD *)(a1 + 304) )
          (*(void (__fastcall **)(_QWORD, __int64))(v21 + 24))(*(_QWORD *)(a1 + 312), v21);
        return n;
      }
      memcpy(a2, src, n);
      *((_BYTE *)a2 + n) = 0;
      src = (char *)src + v22;
      v23 = (unsigned int)sub_10071((unsigned int *)src);
      src = (char *)src + 4;
      if ( v12 && v11 > 1 )
      {
        v24 = v23;
        if ( v23 >= v11 )
        {
          n = -38LL;
          goto LABEL_16;
        }
        memcpy(v12, src, v24);
        *((_BYTE *)v12 + v24) = 0;
      }
      src = (char *)src + v23;
      if ( s )
        memset(s, 0, 0x38uLL);
      if ( s )
        v7 = (__int64 *)s;
      else
        v7 = &v26;
      src = (char *)src + (signed int)sub_1A7DD(v7, (unsigned int *)src);
      *(_QWORD *)(a1 + 320) = src;
      goto LABEL_16;
    }
    *(_QWORD *)(v19 + 168) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v21 + 8))(v14, v21);
    src = *(void **)(v19 + 168);
    if ( !*(_QWORD *)(v19 + 168) )
      return (signed int)sub_FF92(v21, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_READDIR packet");
    sub_101C7((_BYTE **)&src, v14 - 4);
    v9 = src;
    src = (char *)src + 1;
    *v9 = 12;
    LODWORD(v9) = *(_DWORD *)(v19 + 8);
    *(_DWORD *)(v19 + 8) = (_DWORD)v9 + 1;
    *(_DWORD *)(v19 + 176) = (_DWORD)v9;
    sub_101C7((_BYTE **)&src, *(_DWORD *)(v19 + 176));
    sub_101FF(&src, (const void *)(a1 + 32), *(_QWORD *)(a1 + 288));
    *(_DWORD *)(v19 + 160) = 2;
  }
  if ( *(_DWORD *)(v19 + 160) == 2 )
  {
    v25 = sub_8C41(v20, 0, *(void **)(v19 + 168), v14);
    if ( v25 == -37 )
      return -37LL;
    if ( v25 != v14 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v21 + 24))(*(_QWORD *)(v19 + 168), v21);
      *(_QWORD *)(v19 + 168) = 0LL;
      *(_DWORD *)(v19 + 160) = 0;
      return (signed int)sub_FF92(v21, 0xFFFFFFF9, (__int64)"_libssh2_channel_write() failed");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v21 + 24))(*(_QWORD *)(v19 + 168), v21);
    *(_QWORD *)(v19 + 168) = 0LL;
    *(_DWORD *)(v19 + 160) = 3;
  }
  v25 = (signed int)sub_1A52F((_QWORD *)v19, 2, (__int64)"heieiehe", *(_DWORD *)(v19 + 176), &v26, &v16);
  if ( v25 == -37 )
    return -37LL;
  if ( v25 )
  {
    *(_DWORD *)(v19 + 160) = 0;
    result = (signed int)sub_FF92(v21, v25, (__int64)"Timeout waiting for status message");
  }
  else if ( *(_BYTE *)v26 == 101 )
  {
    v25 = (unsigned int)sub_10071((unsigned int *)(v26 + 5));
    (*(void (__fastcall **)(__int64, __int64))(v21 + 24))(v26, v21);
    if ( v25 == 1 )
    {
      *(_DWORD *)(v19 + 160) = 0;
      result = 0LL;
    }
    else
    {
      *(_DWORD *)(v19 + 64) = v25;
      *(_DWORD *)(v19 + 160) = 0;
      result = (signed int)sub_FF92(v21, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
    }
  }
  else
  {
    *(_DWORD *)(v19 + 160) = 0;
    v15 = sub_10071((unsigned int *)(v26 + 5));
    if ( v15 )
    {
      *(_DWORD *)(a1 + 304) = v15;
      *(_QWORD *)(a1 + 312) = v26;
      *(_QWORD *)(a1 + 320) = v26 + 9;
      result = sub_1C5A0(a1, a2, v13, v12, v11, s);
    }
    else
    {
      (*(void (__fastcall **)(__int64, __int64))(v21 + 24))(v26, v21);
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000001CC36) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_readdir_ex(__int64 a1, void *a2, unsigned __int64 a3, void *a4, unsigned __int64 a5, void *a6)
{
  void *v7; // [rsp+0h] [rbp-40h]
  unsigned __int64 v8; // [rsp+8h] [rbp-38h]
  void *v9; // [rsp+10h] [rbp-30h]
  unsigned __int64 v10; // [rsp+18h] [rbp-28h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v11 = sub_1C5A0(a1, a2, v10, v9, v8, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v11 = sub_179AF(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v12);
  }
  while ( !v11 );
  return v11;
}

//----- (000000000001CCE9) ----------------------------------------------------
__int64 __fastcall sub_1CCE9(_QWORD *a1, char *a2, unsigned __int64 a3)
{
  signed int v3; // eax
  _BYTE *v5; // rax
  int v6; // ST2C_4
  __int64 v7; // rax
  unsigned __int64 v8; // [rsp+8h] [rbp-98h]
  char *v9; // [rsp+10h] [rbp-90h]
  unsigned int v10; // [rsp+20h] [rbp-80h]
  unsigned int v11; // [rsp+24h] [rbp-7Ch]
  char v12; // [rsp+30h] [rbp-70h]
  _BYTE *v13; // [rsp+38h] [rbp-68h]
  __int64 v14; // [rsp+40h] [rbp-60h]
  __int64 i; // [rsp+48h] [rbp-58h]
  unsigned __int64 v16; // [rsp+50h] [rbp-50h]
  __int64 v17; // [rsp+58h] [rbp-48h]
  __int64 v18; // [rsp+60h] [rbp-40h]
  __int64 v19; // [rsp+68h] [rbp-38h]
  unsigned __int64 v20; // [rsp+70h] [rbp-30h]
  unsigned __int64 v21; // [rsp+78h] [rbp-28h]
  __int64 v22; // [rsp+80h] [rbp-20h]
  __int64 v23; // [rsp+88h] [rbp-18h]
  __int64 v24; // [rsp+90h] [rbp-10h]
  unsigned __int64 v25; // [rsp+98h] [rbp-8h]

  v9 = a2;
  v25 = __readfsqword(0x28u);
  v17 = a1[3];
  v18 = *(_QWORD *)v17;
  v19 = *(_QWORD *)(v18 + 96);
  v16 = 0LL;
  v20 = a3;
  if ( *(_DWORD *)(v17 + 156) != 3 )
  {
    v21 = a1[39] - a1[38] + a1[40];
    if ( a3 < v21 )
    {
      v8 = 0LL;
    }
    else
    {
      v9 = &a2[v21];
      v8 = a3 - v21;
    }
    *(_DWORD *)(v17 + 156) = 0;
    while ( v8 )
    {
      v3 = 30000;
      if ( v8 <= 0x7530 )
        v3 = v8;
      v10 = v3;
      v11 = a1[36] + v3 + 25;
      i = (*(__int64 (__fastcall **)(signed __int64, __int64))(v19 + 8))(v11 + 56LL, v19);
      if ( !i )
        return (signed int)sub_FF92(v19, 0xFFFFFFFA, (__int64)"malloc fail for FXP_WRITE");
      *(_QWORD *)(i + 24) = v10;
      *(_QWORD *)(i + 32) = 0LL;
      *(_QWORD *)(i + 40) = v11;
      v13 = (_BYTE *)(i + 52);
      sub_101C7(&v13, v11 - 4);
      v5 = v13++;
      *v5 = 6;
      LODWORD(v5) = *(_DWORD *)(v17 + 8);
      *(_DWORD *)(v17 + 8) = (_DWORD)v5 + 1;
      *(_DWORD *)(i + 48) = (_DWORD)v5;
      sub_101C7(&v13, (int)v5);
      sub_101FF((void **)&v13, a1 + 4, a1[36]);
      sub_19B73(&v13, a1[39]);
      a1[39] += v10;
      sub_101FF((void **)&v13, v9, v10);
      sub_1080D(a1 + 47, (_QWORD *)i);
      v9 += v10;
      v8 -= v10;
    }
    for ( i = sub_10877((__int64)(a1 + 47)); i; i = sub_10889(i) )
    {
      if ( *(_QWORD *)(i + 40) )
      {
        v22 = sub_8C41(v18, 0, (void *)(*(_QWORD *)(i + 32) + 48LL + i + 4), *(_QWORD *)(i + 40));
        if ( v22 < 0 )
          return v22;
        *(_QWORD *)(i + 40) -= v22;
        *(_QWORD *)(i + 32) += v22;
        if ( *(_QWORD *)(i + 40) )
          break;
      }
    }
  }
  *(_DWORD *)(v17 + 156) = 0;
  for ( i = sub_10877((__int64)(a1 + 47)); ; i = v23 )
  {
    if ( !i || *(_QWORD *)(i + 40) || v16 )
    {
      v16 += a1[40];
      if ( !v16 )
        return 0LL;
      v7 = v16;
      if ( v20 <= v16 )
        v7 = v20;
      v24 = v7;
      a1[40] = v16 - v7;
      return v24;
    }
    v22 = (signed int)sub_1A483(v17, 101, *(_DWORD *)(i + 48), &v14, &v12);
    if ( v22 < 0 )
      break;
    v6 = sub_10071((unsigned int *)(v14 + 5));
    (*(void (__fastcall **)(__int64, __int64))(v19 + 24))(v14, v19);
    *(_DWORD *)(v17 + 64) = v6;
    if ( v6 )
    {
      sub_1A25F((__int64)a1);
      a1[38] -= a1[40];
      a1[39] = a1[38];
      a1[40] = 0LL;
      return (signed int)sub_FF92(v19, 0xFFFFFFE1, (__int64)"FXP write failed");
    }
    v16 += *(_QWORD *)(i + 24);
    a1[38] += *(_QWORD *)(i + 24);
    v23 = sub_10889(i);
    sub_108AC(i);
    (*(void (__fastcall **)(__int64, __int64))(v19 + 24))(i, v19);
  }
  if ( v22 == -37 )
    *(_DWORD *)(v17 + 156) = 3;
  return v22;
}

//----- (000000000001D2A5) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_write(__int64 a1, char *a2, unsigned __int64 a3)
{
  int v4; // eax
  unsigned __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+20h] [rbp-10h]
  time_t v7; // [rsp+28h] [rbp-8h]

  v5 = a3;
  if ( !a1 )
    return -39LL;
  v7 = time(0LL);
  do
  {
    v6 = sub_1CCE9((_QWORD *)a1, a2, v5);
    if ( v6 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v4 = sub_179AF(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v7);
    v6 = v4;
  }
  while ( !v4 );
  return v6;
}

//----- (000000000001D343) ----------------------------------------------------
__int64 __fastcall sub_1D343(_QWORD *a1, _QWORD *a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  __int64 result; // rax
  char v6; // cl
  char *v7; // rax
  __int64 v8; // rax
  const char *v9; // rax
  int v10; // [rsp+Ch] [rbp-74h]
  unsigned int v11; // [rsp+28h] [rbp-58h]
  int v12; // [rsp+2Ch] [rbp-54h]
  char v13; // [rsp+30h] [rbp-50h]
  char *v14; // [rsp+38h] [rbp-48h]
  __int64 v15; // [rsp+40h] [rbp-40h]
  __int64 v16; // [rsp+48h] [rbp-38h]
  __int64 v17; // [rsp+50h] [rbp-30h]
  __int64 v18; // [rsp+58h] [rbp-28h]
  __int64 v19; // [rsp+60h] [rbp-20h]
  unsigned __int64 v20; // [rsp+68h] [rbp-18h]

  v10 = a3;
  v20 = __readfsqword(0x28u);
  v16 = a1[3];
  v17 = *(_QWORD *)v16;
  v18 = *(_QWORD *)(v17 + 96);
  v3 = a1[36];
  if ( a3 )
    v4 = sub_19B3E(*a2);
  else
    v4 = 0;
  v11 = v3 + v4 + 13;
  if ( !*(_DWORD *)(v16 + 180) )
  {
    *(_QWORD *)(v16 + 184) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v18 + 8))(v11, v18);
    v14 = *(char **)(v16 + 184);
    if ( !*(_QWORD *)(v16 + 184) )
      return sub_FF92(v18, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FSTAT/FSETSTAT packet");
    sub_101C7(&v14, v11 - 4);
    if ( v10 )
      v6 = 10;
    else
      v6 = 8;
    v7 = v14++;
    *v7 = v6;
    LODWORD(v7) = *(_DWORD *)(v16 + 8);
    *(_DWORD *)(v16 + 8) = (_DWORD)v7 + 1;
    *(_DWORD *)(v16 + 192) = (_DWORD)v7;
    sub_101C7(&v14, *(_DWORD *)(v16 + 192));
    sub_101FF((void **)&v14, a1 + 4, a1[36]);
    if ( v10 )
    {
      v8 = sub_1A681(v14, a2);
      v14 += v8;
    }
    *(_DWORD *)(v16 + 180) = 2;
  }
  if ( *(_DWORD *)(v16 + 180) != 2 )
    goto LABEL_22;
  v19 = sub_8C41(v17, 0, *(void **)(v16 + 184), v11);
  if ( v19 == -37 )
    return -37LL;
  if ( v19 == v11 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(v18 + 24))(*(_QWORD *)(v16 + 184), v18);
    *(_QWORD *)(v16 + 184) = 0LL;
    *(_DWORD *)(v16 + 180) = 3;
LABEL_22:
    v19 = (signed int)sub_1A52F((_QWORD *)v16, 2, (__int64)"ieiehe", *(_DWORD *)(v16 + 192), &v15, &v13);
    if ( v19 == -37 )
      return -37LL;
    if ( v19 )
    {
      *(_DWORD *)(v16 + 180) = 0;
      result = sub_FF92(v18, v19, (__int64)"Timeout waiting for status message");
    }
    else
    {
      *(_DWORD *)(v16 + 180) = 0;
      if ( *(_BYTE *)v15 == 101 )
      {
        v12 = sub_10071((unsigned int *)(v15 + 5));
        (*(void (__fastcall **)(__int64, __int64))(v18 + 24))(v15, v18);
        if ( v12 )
        {
          *(_DWORD *)(v16 + 64) = v12;
          result = sub_FF92(v18, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
        }
        else
        {
          result = 0LL;
        }
      }
      else
      {
        sub_1A7DD(a2, (unsigned int *)(v15 + 5));
        (*(void (__fastcall **)(__int64, __int64))(v18 + 24))(v15, v18);
        result = 0LL;
      }
    }
    return result;
  }
  (*(void (__fastcall **)(_QWORD, __int64))(v18 + 24))(*(_QWORD *)(v16 + 184), v18);
  *(_QWORD *)(v16 + 184) = 0LL;
  *(_DWORD *)(v16 + 180) = 0;
  if ( v10 )
    v9 = "Unable to send FXP_FSETSTAT";
  else
    v9 = "Unable to send FXP_FSTAT command";
  return sub_FF92(v18, 0xFFFFFFF9, (__int64)v9);
}

//----- (000000000001D722) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_fstat_ex(__int64 a1, _QWORD *a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  time_t v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 || !a2 )
    return 4294967257LL;
  v6 = time(0LL);
  do
  {
    v5 = sub_1D343((_QWORD *)a1, a2, v4);
    if ( v5 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v5 = sub_179AF(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v6);
  }
  while ( !v5 );
  return v5;
}

//----- (000000000001D7BC) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_seek64(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    *(_QWORD *)(a1 + 312) = a2;
    *(_QWORD *)(a1 + 304) = *(_QWORD *)(a1 + 312);
    sub_1A25F(a1);
    if ( *(_QWORD *)(a1 + 344) )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 24LL))(
        *(_QWORD *)(a1 + 328),
        *(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL));
      *(_QWORD *)(a1 + 336) = 0LL;
      *(_QWORD *)(a1 + 344) = *(_QWORD *)(a1 + 336);
      *(_QWORD *)(a1 + 328) = 0LL;
    }
    result = a1;
    *(_BYTE *)(a1 + 352) = 0;
  }
  return result;
}

//----- (000000000001D892) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_seek(__int64 a1, __int64 a2)
{
  return libssh2_sftp_seek64(a1, a2);
}
// 51D0: using guessed type __int64 __fastcall libssh2_sftp_seek64(_QWORD, _QWORD);

//----- (000000000001D8B8) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_tell(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(_QWORD *)(a1 + 304);
  else
    result = 0LL;
  return result;
}

//----- (000000000001D8DB) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_tell64(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(_QWORD *)(a1 + 304);
  else
    result = 0LL;
  return result;
}

//----- (000000000001D8FE) ----------------------------------------------------
__int64 __fastcall sub_1D8FE(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // ST38_8
  __int64 v3; // ST30_8
  __int64 v4; // [rsp+10h] [rbp-30h]
  __int64 v5; // [rsp+18h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-18h]

  v6 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v4 = sub_10877(a1 + 16);
  result = sub_10877(a1 + 32);
  v5 = result;
  while ( v4 )
  {
    v2 = sub_10889(v4);
    sub_108AC(v4);
    (*(void (__fastcall **)(_QWORD, __int64))(v6 + 24))(*(_QWORD *)(v4 + 32), v6);
    (*(void (__fastcall **)(__int64, __int64))(v6 + 24))(v4, v6);
    result = v2;
    v4 = v2;
  }
  while ( v5 )
  {
    v3 = sub_10889(v5);
    sub_108AC(v5);
    (*(void (__fastcall **)(__int64, __int64))(v6 + 24))(v5, v6);
    result = v3;
    v5 = v3;
  }
  return result;
}

//----- (000000000001D9F2) ----------------------------------------------------
signed __int64 __fastcall sub_1D9F2(__int64 a1)
{
  signed __int64 result; // rax
  _BYTE *v2; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-44h]
  int v4; // [rsp+20h] [rbp-40h]
  unsigned int v5; // [rsp+20h] [rbp-40h]
  int v6; // [rsp+24h] [rbp-3Ch]
  char v7; // [rsp+28h] [rbp-38h]
  _BYTE *v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+48h] [rbp-18h]
  __int64 v12; // [rsp+50h] [rbp-10h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v10 = *(_QWORD *)(a1 + 24);
  v11 = *(_QWORD *)v10;
  v12 = *(_QWORD *)(v11 + 96);
  v3 = *(unsigned __int64 *)(a1 + 288) + 13;
  v9 = 0LL;
  if ( !*(_DWORD *)(a1 + 360) )
  {
    *(_QWORD *)(a1 + 368) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v12 + 8))(v3, v12);
    v8 = *(_BYTE **)(a1 + 368);
    if ( !*(_QWORD *)(a1 + 368) )
      return sub_FF92(v12, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_CLOSE packet");
    sub_101C7(&v8, v3 - 4);
    v2 = v8++;
    *v2 = 4;
    LODWORD(v2) = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = (_DWORD)v2 + 1;
    *(_DWORD *)(a1 + 364) = (_DWORD)v2;
    sub_101C7(&v8, *(_DWORD *)(a1 + 364));
    sub_101FF((void **)&v8, (const void *)(a1 + 32), *(_QWORD *)(a1 + 288));
    *(_DWORD *)(a1 + 360) = 2;
  }
  if ( *(_DWORD *)(a1 + 360) == 2 )
  {
    v4 = sub_8C41(v11, 0, *(void **)(a1 + 368), v3);
    if ( v4 == -37 )
      return 4294967259LL;
    if ( v3 != (signed __int64)v4 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v12 + 24))(*(_QWORD *)(a1 + 368), v12);
      *(_QWORD *)(a1 + 368) = 0LL;
      *(_DWORD *)(a1 + 360) = 0;
      return sub_FF92(v12, 0xFFFFFFF9, (__int64)"Unable to send FXP_CLOSE command");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v12 + 24))(*(_QWORD *)(a1 + 368), v12);
    *(_QWORD *)(a1 + 368) = 0LL;
    *(_DWORD *)(a1 + 360) = 3;
  }
  if ( *(_DWORD *)(a1 + 360) == 3 )
  {
    v5 = sub_1A483(v10, 101, *(_DWORD *)(a1 + 364), &v9, &v7);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 )
    {
      *(_DWORD *)(a1 + 360) = 0;
      return sub_FF92(v12, v5, (__int64)"Error waiting for status message");
    }
    *(_DWORD *)(a1 + 360) = 4;
  }
  if ( !v9 )
    return 4294967262LL;
  v6 = sub_10071((unsigned int *)(v9 + 5));
  (*(void (__fastcall **)(__int64, __int64))(v12 + 24))(v9, v12);
  if ( v6 )
  {
    *(_DWORD *)(v10 + 64) = v6;
    *(_DWORD *)(a1 + 360) = 0;
    result = sub_FF92(v12, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
  }
  else
  {
    sub_108AC(a1);
    if ( *(_DWORD *)(a1 + 296) == 1 && *(_DWORD *)(a1 + 304) )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v12 + 24))(*(_QWORD *)(a1 + 312), v12);
    }
    else if ( *(_QWORD *)(a1 + 328) )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v12 + 24))(*(_QWORD *)(a1 + 328), v12);
    }
    sub_1A25F(a1);
    *(_DWORD *)(v10 + 148) = 0;
    *(_DWORD *)(a1 + 360) = 0;
    (*(void (__fastcall **)(__int64, __int64))(v12 + 24))(a1, v12);
    result = 0LL;
  }
  return result;
}

//----- (000000000001DDF9) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_close_handle(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_1D9F2(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v2 = sub_179AF(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v3);
  }
  while ( !v2 );
  return v2;
}

//----- (000000000001DE7B) ----------------------------------------------------
__int64 __fastcall sub_1DE7B(__int64 a1, const void *a2, size_t a3)
{
  __int64 result; // rax
  _BYTE *v4; // rax
  size_t v5; // [rsp+8h] [rbp-58h]
  unsigned int v6; // [rsp+24h] [rbp-3Ch]
  int v7; // [rsp+28h] [rbp-38h]
  unsigned int v8; // [rsp+28h] [rbp-38h]
  int v9; // [rsp+2Ch] [rbp-34h]
  char v10; // [rsp+30h] [rbp-30h]
  _BYTE *v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v5 = a3;
  v15 = __readfsqword(0x28u);
  v13 = *(_QWORD *)a1;
  v14 = *(_QWORD *)(v13 + 96);
  v6 = a3 + 13;
  if ( !*(_DWORD *)(a1 + 196) )
  {
    *(_QWORD *)(a1 + 200) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v14 + 8))(v6, v14);
    v11 = *(_BYTE **)(a1 + 200);
    if ( !*(_QWORD *)(a1 + 200) )
      return sub_FF92(v14, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_REMOVE packet");
    sub_101C7(&v11, v6 - 4);
    v4 = v11++;
    *v4 = 13;
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v4 + 1;
    *(_DWORD *)(a1 + 208) = (_DWORD)v4;
    sub_101C7(&v11, *(_DWORD *)(a1 + 208));
    sub_101FF((void **)&v11, a2, v5);
    *(_DWORD *)(a1 + 196) = 2;
  }
  if ( *(_DWORD *)(a1 + 196) == 2 )
  {
    v7 = sub_8C41(v13, 0, *(void **)(a1 + 200), v6);
    if ( v7 == -37 )
      return 4294967259LL;
    if ( v6 != (signed __int64)v7 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v14 + 24))(*(_QWORD *)(a1 + 200), v14);
      *(_QWORD *)(a1 + 200) = 0LL;
      *(_DWORD *)(a1 + 196) = 0;
      return sub_FF92(v14, 0xFFFFFFF9, (__int64)"Unable to send FXP_REMOVE command");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v14 + 24))(*(_QWORD *)(a1 + 200), v14);
    *(_QWORD *)(a1 + 200) = 0LL;
    *(_DWORD *)(a1 + 196) = 3;
  }
  v8 = sub_1A483(a1, 101, *(_DWORD *)(a1 + 208), &v12, &v10);
  if ( v8 == -37 )
    return 4294967259LL;
  if ( v8 )
  {
    *(_DWORD *)(a1 + 196) = 0;
    result = sub_FF92(v14, v8, (__int64)"Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 196) = 0;
    v9 = sub_10071((unsigned int *)(v12 + 5));
    (*(void (__fastcall **)(__int64, __int64))(v14 + 24))(v12, v14);
    if ( v9 )
    {
      *(_DWORD *)(a1 + 64) = v9;
      result = sub_FF92(v14, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000001E175) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_unlink_ex(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-24h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  time_t v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 )
    return 4294967257LL;
  v6 = time(0LL);
  do
  {
    v5 = sub_1DE7B(a1, a2, v4);
    if ( v5 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v5 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v6);
  }
  while ( !v5 );
  return v5;
}

//----- (000000000001E200) ----------------------------------------------------
__int64 __fastcall sub_1E200(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6)
{
  int v6; // edx
  signed int v7; // eax
  __int64 result; // rax
  _BYTE *v9; // rax
  int v10; // [rsp+8h] [rbp-68h]
  const void *v11; // [rsp+10h] [rbp-60h]
  unsigned int v12; // [rsp+18h] [rbp-58h]
  unsigned int v13; // [rsp+1Ch] [rbp-54h]
  int v14; // [rsp+38h] [rbp-38h]
  unsigned int v15; // [rsp+38h] [rbp-38h]
  unsigned int v16; // [rsp+3Ch] [rbp-34h]
  char v17; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  __int64 v20; // [rsp+58h] [rbp-18h]
  __int64 v21; // [rsp+60h] [rbp-10h]
  unsigned __int64 v22; // [rsp+68h] [rbp-8h]

  v13 = a3;
  v11 = a4;
  v12 = a5;
  v10 = a6;
  v22 = __readfsqword(0x28u);
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD *)(v19 + 96);
  v6 = a5 + a3;
  if ( *(_DWORD *)(a1 + 12) <= 4u )
    v7 = 0;
  else
    v7 = 4;
  v16 = v6 + v7 + 17;
  if ( *(_DWORD *)(a1 + 12) <= 1u )
    return sub_FF92(v20, 0xFFFFFFE1, (__int64)"Server does not support RENAME");
  if ( !*(_DWORD *)(a1 + 212) )
  {
    *(_QWORD *)(a1 + 216) = (*(__int64 (__fastcall **)(_QWORD, __int64))(v20 + 8))(v16, v20);
    *(_QWORD *)(a1 + 224) = *(_QWORD *)(a1 + 216);
    if ( !*(_QWORD *)(a1 + 216) )
      return sub_FF92(v20, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_RENAME packet");
    sub_101C7((_BYTE **)(a1 + 224), v16 - 4);
    v9 = *(_BYTE **)(a1 + 224);
    *(_QWORD *)(a1 + 224) = v9 + 1;
    *v9 = 18;
    LODWORD(v9) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v9 + 1;
    *(_DWORD *)(a1 + 232) = (_DWORD)v9;
    sub_101C7((_BYTE **)(a1 + 224), *(_DWORD *)(a1 + 232));
    sub_101FF((void **)(a1 + 224), a2, v13);
    sub_101FF((void **)(a1 + 224), v11, v12);
    if ( *(_DWORD *)(a1 + 12) > 4u )
      sub_101C7((_BYTE **)(a1 + 224), v10);
    *(_DWORD *)(a1 + 212) = 2;
  }
  if ( *(_DWORD *)(a1 + 212) == 2 )
  {
    v21 = sub_8C41(v19, 0, *(void **)(a1 + 216), *(_QWORD *)(a1 + 224) - *(_QWORD *)(a1 + 216));
    if ( v21 == -37 )
      return -37LL;
    if ( v21 != v16 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v20 + 24))(*(_QWORD *)(a1 + 216), v20);
      *(_QWORD *)(a1 + 216) = 0LL;
      *(_DWORD *)(a1 + 212) = 0;
      return sub_FF92(v20, 0xFFFFFFF9, (__int64)"Unable to send FXP_RENAME command");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v20 + 24))(*(_QWORD *)(a1 + 216), v20);
    *(_QWORD *)(a1 + 216) = 0LL;
    *(_DWORD *)(a1 + 212) = 3;
  }
  v21 = (signed int)sub_1A483(a1, 101, *(_DWORD *)(a1 + 232), &v18, &v17);
  if ( v21 == -37 )
    return -37LL;
  if ( v21 )
  {
    *(_DWORD *)(a1 + 212) = 0;
    result = sub_FF92(v20, v21, (__int64)"Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 212) = 0;
    v14 = sub_10071((unsigned int *)(v18 + 5));
    (*(void (__fastcall **)(__int64, __int64))(v20 + 24))(v18, v20);
    *(_DWORD *)(a1 + 64) = v14;
    if ( v14 == 8 )
    {
      v15 = sub_FF92(v20, 0xFFFFFFE1, (__int64)"Operation Not Supported");
    }
    else if ( v14 == 11 )
    {
      v15 = sub_FF92(v20, 0xFFFFFFE1, (__int64)"File already exists and SSH_FXP_RENAME_OVERWRITE not specified");
    }
    else if ( v14 )
    {
      v15 = sub_FF92(v20, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
    }
    else
    {
      v15 = 0;
    }
    result = v15;
  }
  return result;
}

//----- (000000000001E62F) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_rename_ex(__int64 a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, int a6)
{
  int v7; // [rsp+8h] [rbp-38h]
  const void *v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+18h] [rbp-28h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v11 = sub_1E200(a1, a2, v10, v8, v9, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v11 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v12);
  }
  while ( !v11 );
  return v11;
}

//----- (000000000001E6D4) ----------------------------------------------------
signed __int64 __fastcall sub_1E6D4(_QWORD *a1, unsigned __int64 *a2)
{
  signed __int64 result; // rax
  char *v3; // rax
  char v4; // ST14_1
  unsigned int v5; // [rsp+10h] [rbp-50h]
  unsigned __int64 v6; // [rsp+18h] [rbp-48h]
  char *v7; // [rsp+20h] [rbp-40h]
  unsigned __int8 *v8; // [rsp+28h] [rbp-38h]
  char *v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  v10 = a1[3];
  v11 = *(_QWORD *)v10;
  v12 = *(_QWORD *)(v11 + 96);
  v5 = a1[36] + 37;
  if ( *(_DWORD *)(v10 + 236) )
  {
    v9 = *(char **)(v10 + 240);
  }
  else
  {
    v9 = (char *)(*(__int64 (__fastcall **)(_QWORD, __int64))(v12 + 8))(v5, v12);
    v7 = v9;
    if ( !v9 )
      return sub_FF92(v12, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_EXTENDED packet");
    sub_101C7(&v7, v5 - 4);
    v3 = v7++;
    *v3 = -56;
    LODWORD(v3) = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = (_DWORD)v3 + 1;
    *(_DWORD *)(v10 + 248) = (_DWORD)v3;
    sub_101C7(&v7, *(_DWORD *)(v10 + 248));
    sub_101FF((void **)&v7, "fstatvfs@openssh.com", 0x14uLL);
    sub_101FF((void **)&v7, a1 + 4, a1[36]);
    *(_DWORD *)(v10 + 236) = 2;
  }
  if ( *(_DWORD *)(v10 + 236) == 2 )
  {
    v13 = sub_8C41(v11, 0, v9, v5);
    if ( v13 == -37 || v13 >= 0 && v13 < v5 )
    {
      *(_QWORD *)(v10 + 240) = v9;
      return 4294967259LL;
    }
    (*(void (__fastcall **)(char *, __int64))(v12 + 24))(v9, v12);
    *(_QWORD *)(v10 + 240) = 0LL;
    if ( v13 < 0 )
    {
      *(_DWORD *)(v10 + 236) = 0;
      return sub_FF92(v12, 0xFFFFFFF9, (__int64)"_libssh2_channel_write() failed");
    }
    *(_DWORD *)(v10 + 236) = 3;
  }
  v13 = (signed int)sub_1A483(v10, 201, *(_DWORD *)(v10 + 248), &v8, &v6);
  if ( v13 == -37 )
    return -37LL;
  if ( v13 )
  {
    *(_DWORD *)(v10 + 236) = 0;
    result = sub_FF92(v12, v13, (__int64)"Error waiting for FXP EXTENDED REPLY");
  }
  else if ( v6 > 0x5C )
  {
    *(_DWORD *)(v10 + 236) = 0;
    *a2 = sub_100C0(v8 + 5);
    a2[1] = sub_100C0(v8 + 13);
    a2[2] = sub_100C0(v8 + 21);
    a2[3] = sub_100C0(v8 + 29);
    a2[4] = sub_100C0(v8 + 37);
    a2[5] = sub_100C0(v8 + 45);
    a2[6] = sub_100C0(v8 + 53);
    a2[7] = sub_100C0(v8 + 61);
    a2[8] = sub_100C0(v8 + 69);
    v4 = sub_100C0(v8 + 77);
    a2[10] = sub_100C0(v8 + 85);
    a2[9] = v4 & 1;
    a2[9] |= v4 & 2;
    (*(void (__fastcall **)(unsigned __int8 *, __int64))(v12 + 24))(v8, v12);
    result = 0LL;
  }
  else
  {
    (*(void (__fastcall **)(unsigned __int8 *, __int64))(v12 + 24))(v8, v12);
    *(_DWORD *)(v10 + 236) = 0;
    result = sub_FF92(v12, 0xFFFFFFE1, (__int64)"SFTP Protocol Error: short response");
  }
  return result;
}

//----- (000000000001EB40) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_fstatvfs(__int64 a1, unsigned __int64 *a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  if ( !a1 || !a2 )
    return 4294967257LL;
  v4 = time(0LL);
  do
  {
    v3 = sub_1E6D4((_QWORD *)a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v3 = sub_179AF(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v4);
  }
  while ( !v3 );
  return v3;
}

//----- (000000000001EBD4) ----------------------------------------------------
signed __int64 __fastcall sub_1EBD4(__int64 a1, const void *a2, unsigned int a3, unsigned __int64 *a4)
{
  signed __int64 result; // rax
  char *v5; // rax
  char v6; // ST2C_1
  unsigned __int64 *v7; // [rsp+0h] [rbp-70h]
  unsigned int v8; // [rsp+Ch] [rbp-64h]
  unsigned int v9; // [rsp+28h] [rbp-48h]
  unsigned __int64 v10; // [rsp+30h] [rbp-40h]
  char *v11; // [rsp+38h] [rbp-38h]
  unsigned __int8 *v12; // [rsp+40h] [rbp-30h]
  char *v13; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  __int64 v16; // [rsp+60h] [rbp-10h]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v17 = __readfsqword(0x28u);
  v14 = *(_QWORD *)a1;
  v15 = *(_QWORD *)(v14 + 96);
  v9 = a3 + 36;
  if ( *(_DWORD *)(a1 + 252) )
  {
    v13 = *(char **)(a1 + 256);
  }
  else
  {
    v13 = (char *)(*(__int64 (__fastcall **)(_QWORD, __int64))(v15 + 8))(v9, v15);
    v11 = v13;
    if ( !v13 )
      return sub_FF92(v15, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_EXTENDED packet");
    sub_101C7(&v11, v9 - 4);
    v5 = v11++;
    *v5 = -56;
    LODWORD(v5) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v5 + 1;
    *(_DWORD *)(a1 + 264) = (_DWORD)v5;
    sub_101C7(&v11, *(_DWORD *)(a1 + 264));
    sub_101FF((void **)&v11, "statvfs@openssh.com", 0x13uLL);
    sub_101FF((void **)&v11, a2, v8);
    *(_DWORD *)(a1 + 252) = 2;
  }
  if ( *(_DWORD *)(a1 + 252) == 2 )
  {
    v16 = sub_8C41(v14, 0, v13, v9);
    if ( v16 == -37 || v16 >= 0 && v16 < v9 )
    {
      *(_QWORD *)(a1 + 256) = v13;
      return 4294967259LL;
    }
    (*(void (__fastcall **)(char *, __int64))(v15 + 24))(v13, v15);
    *(_QWORD *)(a1 + 256) = 0LL;
    if ( v16 < 0 )
    {
      *(_DWORD *)(a1 + 252) = 0;
      return sub_FF92(v15, 0xFFFFFFF9, (__int64)"_libssh2_channel_write() failed");
    }
    *(_DWORD *)(a1 + 252) = 3;
  }
  v16 = (signed int)sub_1A483(a1, 201, *(_DWORD *)(a1 + 264), &v12, &v10);
  if ( v16 == -37 )
    return -37LL;
  if ( v16 )
  {
    *(_DWORD *)(a1 + 252) = 0;
    result = sub_FF92(v15, v16, (__int64)"Error waiting for FXP EXTENDED REPLY");
  }
  else if ( v10 > 0x5C )
  {
    *(_DWORD *)(a1 + 252) = 0;
    *v7 = sub_100C0(v12 + 5);
    v7[1] = sub_100C0(v12 + 13);
    v7[2] = sub_100C0(v12 + 21);
    v7[3] = sub_100C0(v12 + 29);
    v7[4] = sub_100C0(v12 + 37);
    v7[5] = sub_100C0(v12 + 45);
    v7[6] = sub_100C0(v12 + 53);
    v7[7] = sub_100C0(v12 + 61);
    v7[8] = sub_100C0(v12 + 69);
    v6 = sub_100C0(v12 + 77);
    v7[10] = sub_100C0(v12 + 85);
    v7[9] = v6 & 1;
    v7[9] |= v6 & 2;
    (*(void (__fastcall **)(unsigned __int8 *, __int64))(v15 + 24))(v12, v15);
    result = 0LL;
  }
  else
  {
    (*(void (__fastcall **)(unsigned __int8 *, __int64))(v15 + 24))(v12, v15);
    *(_DWORD *)(a1 + 236) = 0;
    result = sub_FF92(v15, 0xFFFFFFE1, (__int64)"SFTP Protocol Error: short response");
  }
  return result;
}

//----- (000000000001F027) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_statvfs(__int64 a1, const void *a2, unsigned int a3, unsigned __int64 *a4)
{
  unsigned __int64 *v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( !a1 || !a4 )
    return 4294967257LL;
  v8 = time(0LL);
  do
  {
    v7 = sub_1EBD4(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v7 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v8);
  }
  while ( !v7 );
  return v7;
}

//----- (000000000001F0C7) ----------------------------------------------------
__int64 __fastcall sub_1F0C7(__int64 a1, const void *a2, unsigned int a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // rax
  _BYTE *v6; // rax
  __int64 v7; // rax
  __int64 v8; // [rsp+0h] [rbp-A0h]
  unsigned int v9; // [rsp+Ch] [rbp-94h]
  int v10; // [rsp+20h] [rbp-80h]
  unsigned int v11; // [rsp+20h] [rbp-80h]
  int v12; // [rsp+24h] [rbp-7Ch]
  char v13; // [rsp+28h] [rbp-78h]
  _BYTE *v14; // [rsp+30h] [rbp-70h]
  __int64 v15; // [rsp+38h] [rbp-68h]
  _BYTE *v16; // [rsp+40h] [rbp-60h]
  __int64 v17; // [rsp+48h] [rbp-58h]
  __int64 v18; // [rsp+50h] [rbp-50h]
  unsigned __int64 v19; // [rsp+58h] [rbp-48h]
  __int64 v20; // [rsp+60h] [rbp-40h]
  __int64 v21; // [rsp+68h] [rbp-38h]
  __int64 v22; // [rsp+70h] [rbp-30h]
  __int64 v23; // [rsp+78h] [rbp-28h]
  __int64 v24; // [rsp+80h] [rbp-20h]
  __int64 v25; // [rsp+88h] [rbp-18h]
  __int64 v26; // [rsp+90h] [rbp-10h]
  unsigned __int64 v27; // [rsp+98h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v27 = __readfsqword(0x28u);
  v17 = *(_QWORD *)a1;
  v18 = *(_QWORD *)(v17 + 96);
  v20 = 4LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  v25 = 0LL;
  v26 = 0LL;
  v19 = (unsigned int)sub_19B3E(4) + a3 + 13;
  if ( *(_DWORD *)(a1 + 268) )
  {
    v16 = *(_BYTE **)(a1 + 272);
  }
  else
  {
    v16 = (_BYTE *)(*(__int64 (__fastcall **)(unsigned __int64, __int64))(v18 + 8))(v19, v18);
    v14 = v16;
    if ( !v16 )
      return sub_FF92(v18, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_MKDIR packet");
    v5 = v8;
    BYTE1(v5) |= 0x40u;
    v24 = v5;
    sub_101C7(&v14, v19 - 4);
    v6 = v14++;
    *v6 = 14;
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v6 + 1;
    *(_DWORD *)(a1 + 280) = (_DWORD)v6;
    sub_101C7(&v14, *(_DWORD *)(a1 + 280));
    sub_101FF((void **)&v14, a2, v9);
    v7 = sub_1A681(v14, &v20);
    v14 += v7;
    *(_DWORD *)(a1 + 268) = 2;
  }
  if ( *(_DWORD *)(a1 + 268) == 2 )
  {
    v10 = sub_8C41(v17, 0, v16, v19);
    if ( v10 == -37 )
    {
      *(_QWORD *)(a1 + 272) = v16;
      return 4294967259LL;
    }
    if ( v19 != v10 )
    {
      (*(void (__fastcall **)(_BYTE *, __int64))(v18 + 24))(v16, v18);
      *(_DWORD *)(a1 + 268) = 0;
      return sub_FF92(v18, 0xFFFFFFF9, (__int64)"_libssh2_channel_write() failed");
    }
    (*(void (__fastcall **)(_BYTE *, __int64))(v18 + 24))(v16, v18);
    *(_DWORD *)(a1 + 268) = 3;
    *(_QWORD *)(a1 + 272) = 0LL;
  }
  v11 = sub_1A483(a1, 101, *(_DWORD *)(a1 + 280), &v15, &v13);
  if ( v11 == -37 )
    return 4294967259LL;
  if ( v11 )
  {
    *(_DWORD *)(a1 + 268) = 0;
    result = sub_FF92(v18, v11, (__int64)"Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 268) = 0;
    v12 = sub_10071((unsigned int *)(v15 + 5));
    (*(void (__fastcall **)(__int64, __int64))(v18 + 24))(v15, v18);
    if ( v12 )
    {
      *(_DWORD *)(a1 + 64) = v12;
      result = sub_FF92(v18, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000001F46B) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_mkdir_ex(__int64 a1, const void *a2, unsigned int a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( !a1 )
    return 4294967257LL;
  v8 = time(0LL);
  do
  {
    v7 = sub_1F0C7(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v7 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v8);
  }
  while ( !v7 );
  return v7;
}

//----- (000000000001F4FB) ----------------------------------------------------
__int64 __fastcall sub_1F4FB(__int64 a1, const void *a2, unsigned int a3)
{
  __int64 result; // rax
  _BYTE *v4; // rax
  unsigned int v5; // [rsp+Ch] [rbp-54h]
  int v6; // [rsp+20h] [rbp-40h]
  unsigned int v7; // [rsp+20h] [rbp-40h]
  int v8; // [rsp+24h] [rbp-3Ch]
  char v9; // [rsp+28h] [rbp-38h]
  _BYTE *v10; // [rsp+30h] [rbp-30h]
  __int64 v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  unsigned __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v5 = a3;
  v15 = __readfsqword(0x28u);
  v12 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(v12 + 96);
  v14 = a3 + 13;
  if ( !*(_DWORD *)(a1 + 284) )
  {
    *(_QWORD *)(a1 + 288) = (*(__int64 (__fastcall **)(unsigned __int64, __int64))(v13 + 8))(v14, v13);
    v10 = *(_BYTE **)(a1 + 288);
    if ( !*(_QWORD *)(a1 + 288) )
      return sub_FF92(v13, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_RMDIR packet");
    sub_101C7(&v10, v14 - 4);
    v4 = v10++;
    *v4 = 15;
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v4 + 1;
    *(_DWORD *)(a1 + 296) = (_DWORD)v4;
    sub_101C7(&v10, *(_DWORD *)(a1 + 296));
    sub_101FF((void **)&v10, a2, v5);
    *(_DWORD *)(a1 + 284) = 2;
  }
  if ( *(_DWORD *)(a1 + 284) == 2 )
  {
    v6 = sub_8C41(v12, 0, *(void **)(a1 + 288), v14);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v14 != v6 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v13 + 24))(*(_QWORD *)(a1 + 288), v13);
      *(_QWORD *)(a1 + 288) = 0LL;
      *(_DWORD *)(a1 + 284) = 0;
      return sub_FF92(v13, 0xFFFFFFF9, (__int64)"Unable to send FXP_RMDIR command");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v13 + 24))(*(_QWORD *)(a1 + 288), v13);
    *(_QWORD *)(a1 + 288) = 0LL;
    *(_DWORD *)(a1 + 284) = 3;
  }
  v7 = sub_1A483(a1, 101, *(_DWORD *)(a1 + 296), &v11, &v9);
  if ( v7 == -37 )
    return 4294967259LL;
  if ( v7 )
  {
    *(_DWORD *)(a1 + 284) = 0;
    result = sub_FF92(v13, v7, (__int64)"Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 284) = 0;
    v8 = sub_10071((unsigned int *)(v11 + 5));
    (*(void (__fastcall **)(__int64, __int64))(v13 + 24))(v11, v13);
    if ( v8 )
    {
      *(_DWORD *)(a1 + 64) = v8;
      result = sub_FF92(v13, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000001F7F6) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_rmdir_ex(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-24h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  time_t v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 )
    return 4294967257LL;
  v6 = time(0LL);
  do
  {
    v5 = sub_1F4FB(a1, a2, v4);
    if ( v5 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v5 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v6);
  }
  while ( !v5 );
  return v5;
}

//----- (000000000001F881) ----------------------------------------------------
__int64 __fastcall sub_1F881(__int64 a1, const void *a2, unsigned int a3, int a4, _QWORD *a5)
{
  int v5; // edx
  __int64 result; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  int v10; // eax
  __int64 v11; // rax
  _QWORD *s; // [rsp+0h] [rbp-60h]
  int v13; // [rsp+8h] [rbp-58h]
  unsigned int v14; // [rsp+Ch] [rbp-54h]
  int v15; // [rsp+20h] [rbp-40h]
  unsigned int v16; // [rsp+20h] [rbp-40h]
  int v17; // [rsp+24h] [rbp-3Ch]
  char v18; // [rsp+28h] [rbp-38h]
  _BYTE *v19; // [rsp+30h] [rbp-30h]
  __int64 v20; // [rsp+38h] [rbp-28h]
  __int64 v21; // [rsp+40h] [rbp-20h]
  __int64 v22; // [rsp+48h] [rbp-18h]
  unsigned __int64 v23; // [rsp+50h] [rbp-10h]
  unsigned __int64 v24; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  s = a5;
  v24 = __readfsqword(0x28u);
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD *)(v21 + 96);
  if ( a4 == 2 )
    v5 = sub_19B3E(*a5);
  else
    v5 = 0;
  v23 = v5 + v14 + 13;
  if ( !*(_DWORD *)(a1 + 300) )
  {
    *(_QWORD *)(a1 + 304) = (*(__int64 (__fastcall **)(unsigned __int64, __int64))(v22 + 8))(v23, v22);
    v19 = *(_BYTE **)(a1 + 304);
    if ( !*(_QWORD *)(a1 + 304) )
      return sub_FF92(v22, 0xFFFFFFFA, (__int64)"Unable to allocate memory for FXP_*STAT packet");
    sub_101C7(&v19, v23 - 4);
    if ( v13 == 1 )
    {
      v8 = v19++;
      *v8 = 7;
    }
    else if ( v13 == 2 )
    {
      v7 = v19++;
      *v7 = 9;
    }
    else
    {
      v9 = v19++;
      *v9 = 17;
    }
    v10 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v10 + 1;
    *(_DWORD *)(a1 + 312) = v10;
    sub_101C7(&v19, *(_DWORD *)(a1 + 312));
    sub_101FF((void **)&v19, a2, v14);
    if ( v13 == 2 )
    {
      v11 = sub_1A681(v19, s);
      v19 += v11;
    }
    *(_DWORD *)(a1 + 300) = 2;
  }
  if ( *(_DWORD *)(a1 + 300) == 2 )
  {
    v15 = sub_8C41(v21, 0, *(void **)(a1 + 304), v23);
    if ( v15 == -37 )
      return 4294967259LL;
    if ( v23 != v15 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 304), v22);
      *(_QWORD *)(a1 + 304) = 0LL;
      *(_DWORD *)(a1 + 300) = 0;
      return sub_FF92(v22, 0xFFFFFFF9, (__int64)"Unable to send STAT/LSTAT/SETSTAT command");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 304), v22);
    *(_QWORD *)(a1 + 304) = 0LL;
    *(_DWORD *)(a1 + 300) = 3;
  }
  v16 = sub_1A52F((_QWORD *)a1, 2, (__int64)"iehe", *(_DWORD *)(a1 + 312), &v20, &v18);
  if ( v16 == -37 )
    return 4294967259LL;
  if ( v16 )
  {
    *(_DWORD *)(a1 + 300) = 0;
    result = sub_FF92(v22, v16, (__int64)"Timeout waiting for status message");
  }
  else
  {
    *(_DWORD *)(a1 + 300) = 0;
    if ( *(_BYTE *)v20 == 101 )
    {
      v17 = sub_10071((unsigned int *)(v20 + 5));
      (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
      if ( v17 )
      {
        *(_DWORD *)(a1 + 64) = v17;
        result = sub_FF92(v22, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      memset(s, 0, 0x38uLL);
      sub_1A7DD(s, (unsigned int *)(v20 + 5));
      (*(void (__fastcall **)(__int64, __int64))(v22 + 24))(v20, v22);
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000001FC5F) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_stat_ex(__int64 a1, const void *a2, unsigned int a3, int a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-30h]
  int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_1F881(a1, a2, v8, v7, v6);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v9 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v10);
  }
  while ( !v9 );
  return v9;
}

//----- (000000000001FCF8) ----------------------------------------------------
signed __int64 __fastcall sub_1FCF8(__int64 a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, int a6)
{
  int v6; // edx
  signed __int64 result; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  int v11; // eax
  int v12; // [rsp+Ch] [rbp-74h]
  void *dest; // [rsp+10h] [rbp-70h]
  unsigned int v14; // [rsp+18h] [rbp-68h]
  unsigned int v15; // [rsp+1Ch] [rbp-64h]
  unsigned int v16; // [rsp+30h] [rbp-50h]
  unsigned int v17; // [rsp+30h] [rbp-50h]
  int v18; // [rsp+34h] [rbp-4Ch]
  char v19; // [rsp+38h] [rbp-48h]
  _BYTE *v20; // [rsp+40h] [rbp-40h]
  __int64 v21; // [rsp+48h] [rbp-38h]
  __int64 v22; // [rsp+50h] [rbp-30h]
  __int64 v23; // [rsp+58h] [rbp-28h]
  unsigned __int64 v24; // [rsp+60h] [rbp-20h]
  __int64 v25; // [rsp+68h] [rbp-18h]
  size_t n; // [rsp+70h] [rbp-10h]
  unsigned __int64 v27; // [rsp+78h] [rbp-8h]

  v15 = a3;
  dest = a4;
  v14 = a5;
  v12 = a6;
  v27 = __readfsqword(0x28u);
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD *)(v22 + 96);
  if ( a6 )
    v6 = 0;
  else
    v6 = a5 + 4;
  v24 = v6 + v15 + 13;
  if ( *(_DWORD *)(a1 + 12) <= 2u && a6 != 2 )
    return sub_FF92(v23, 0xFFFFFFE1, (__int64)"Server does not support SYMLINK or READLINK");
  if ( !*(_DWORD *)(a1 + 316) )
  {
    *(_QWORD *)(a1 + 320) = (*(__int64 (__fastcall **)(unsigned __int64, __int64))(v23 + 8))(v24, v23);
    v20 = *(_BYTE **)(a1 + 320);
    if ( !*(_QWORD *)(a1 + 320) )
      return sub_FF92(v23, 0xFFFFFFFA, (__int64)"Unable to allocate memory for SYMLINK/READLINK/REALPATH packet");
    sub_101C7(&v20, v24 - 4);
    if ( v12 )
    {
      if ( v12 == 2 )
      {
        v8 = v20++;
        *v8 = 16;
      }
      else
      {
        v10 = v20++;
        *v10 = 19;
      }
    }
    else
    {
      v9 = v20++;
      *v9 = 20;
    }
    v11 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v11 + 1;
    *(_DWORD *)(a1 + 328) = v11;
    sub_101C7(&v20, *(_DWORD *)(a1 + 328));
    sub_101FF((void **)&v20, a2, v15);
    if ( !v12 )
      sub_101FF((void **)&v20, dest, v14);
    *(_DWORD *)(a1 + 316) = 2;
  }
  if ( *(_DWORD *)(a1 + 316) == 2 )
  {
    v25 = sub_8C41(v22, 0, *(void **)(a1 + 320), v24);
    if ( v25 == -37 )
      return -37LL;
    if ( v24 != v25 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(v23 + 24))(*(_QWORD *)(a1 + 320), v23);
      *(_QWORD *)(a1 + 320) = 0LL;
      *(_DWORD *)(a1 + 316) = 0;
      return sub_FF92(v23, 0xFFFFFFF9, (__int64)"Unable to send SYMLINK/READLINK command");
    }
    (*(void (__fastcall **)(_QWORD, __int64))(v23 + 24))(*(_QWORD *)(a1 + 320), v23);
    *(_QWORD *)(a1 + 320) = 0LL;
    *(_DWORD *)(a1 + 316) = 3;
  }
  v16 = sub_1A52F((_QWORD *)a1, 2, (__int64)"he", *(_DWORD *)(a1 + 328), &v21, &v19);
  if ( v16 == -37 )
    return 4294967259LL;
  if ( v16 )
  {
    *(_DWORD *)(a1 + 316) = 0;
    result = sub_FF92(v23, v16, (__int64)"Error waiting for status message");
  }
  else
  {
    *(_DWORD *)(a1 + 316) = 0;
    if ( *(_BYTE *)v21 == 101 )
    {
      v18 = sub_10071((unsigned int *)(v21 + 5));
      (*(void (__fastcall **)(__int64, __int64))(v23 + 24))(v21, v23);
      if ( v18 )
      {
        *(_DWORD *)(a1 + 64) = v18;
        result = sub_FF92(v23, 0xFFFFFFE1, (__int64)"SFTP Protocol Error");
      }
      else
      {
        result = 0LL;
      }
    }
    else if ( (unsigned int)sub_10071((unsigned int *)(v21 + 5)) )
    {
      n = (unsigned int)sub_10071((unsigned int *)(v21 + 9));
      if ( n >= v14 )
      {
        v17 = -38;
      }
      else
      {
        memcpy(dest, (const void *)(v21 + 13), n);
        *((_BYTE *)dest + n) = 0;
        v17 = n;
      }
      (*(void (__fastcall **)(__int64, __int64))(v23 + 24))(v21, v23);
      result = v17;
    }
    else
    {
      (*(void (__fastcall **)(__int64, __int64))(v23 + 24))(v21, v23);
      result = sub_FF92(v23, 0xFFFFFFE1, (__int64)"Invalid READLINK/REALPATH response, no name entries");
    }
  }
  return result;
}

//----- (000000000002016A) ----------------------------------------------------
signed __int64 __fastcall libssh2_sftp_symlink_ex(__int64 a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, int a6)
{
  int v7; // [rsp+Ch] [rbp-34h]
  void *v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+18h] [rbp-28h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v11 = sub_1FCF8(a1, a2, v10, v8, v9, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v11 = sub_179AF(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v12);
  }
  while ( !v11 );
  return v11;
}

//----- (000000000002020F) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_last_error(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(unsigned int *)(a1 + 64);
  else
    result = 0LL;
  return result;
}

//----- (0000000000020230) ----------------------------------------------------
__int64 __fastcall libssh2_sftp_get_channel(__int64 *a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *a1;
  else
    result = 0LL;
  return result;
}

//----- (000000000002024F) ----------------------------------------------------
__int64 __fastcall sub_2024F(size_t a1, const void *a2, unsigned int a3)
{
  _BYTE *v4; // rax
  unsigned int v5; // [rsp+Ch] [rbp-34h]
  int v6; // [rsp+24h] [rbp-1Ch]
  unsigned int v7; // [rsp+24h] [rbp-1Ch]
  _BYTE *v8; // [rsp+28h] [rbp-18h]
  size_t n; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v10 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53064) )
  {
    memset((void *)(a1 + 53088), 0, 8uLL);
    *(_QWORD *)(a1 + 53080) = v5 + 27;
    *(_QWORD *)(a1 + 53072) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53080), a1);
    v8 = *(_BYTE **)(a1 + 53072);
    if ( !*(_QWORD *)(a1 + 53072) )
    {
      sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for userauth_list");
      return 0LL;
    }
    v4 = v8++;
    *v4 = 50;
    sub_101FF((void **)&v8, a2, v5);
    sub_101FF((void **)&v8, "ssh-connection", 0xEuLL);
    sub_101C7(&v8, 4);
    *(_DWORD *)(a1 + 53064) = 2;
  }
  if ( *(_DWORD *)(a1 + 53064) == 2 )
  {
    v6 = sub_24D86(a1, *(const void **)(a1 + 53072), *(_QWORD *)(a1 + 53080), "none", 4uLL);
    if ( v6 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block requesting userauth list");
      return 0LL;
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53072), a1);
    *(_QWORD *)(a1 + 53072) = 0LL;
    if ( v6 )
    {
      sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth-none request");
      *(_DWORD *)(a1 + 53064) = 0;
      return 0LL;
    }
    *(_DWORD *)(a1 + 53064) = 3;
  }
  if ( *(_DWORD *)(a1 + 53064) == 3 )
  {
    v7 = sub_12797(a1, "43", (_QWORD *)(a1 + 53072), (_QWORD *)(a1 + 53080), 0, 0LL, 0LL, (time_t *)(a1 + 53088));
    if ( v7 == -37 )
    {
      sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block requesting userauth list");
      return 0LL;
    }
    if ( v7 )
    {
      sub_FF92(a1, v7, (__int64)"Failed getting response");
      *(_DWORD *)(a1 + 53064) = 0;
      return 0LL;
    }
    if ( **(_BYTE **)(a1 + 53072) == 52 )
    {
      sub_FF92(a1, 0, (__int64)"No error");
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53072), a1);
      *(_QWORD *)(a1 + 53072) = 0LL;
      *(_DWORD *)(a1 + 104) |= 4u;
      *(_DWORD *)(a1 + 53064) = 0;
      return 0LL;
    }
    n = (unsigned int)sub_10071((unsigned int *)(*(_QWORD *)(a1 + 53072) + 1LL));
    memmove(*(void **)(a1 + 53072), (const void *)(*(_QWORD *)(a1 + 53072) + 5LL), n);
    *(_BYTE *)(*(_QWORD *)(a1 + 53072) + n) = 0;
  }
  *(_DWORD *)(a1 + 53064) = 0;
  return *(_QWORD *)(a1 + 53072);
}

//----- (0000000000020620) ----------------------------------------------------
__int64 __fastcall libssh2_userauth_list(size_t a1, const void *a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-34h]
  time_t v5; // [rsp+30h] [rbp-10h]
  __int64 v6; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v5 = time(0LL);
  do
    v6 = sub_2024F(a1, a2, v4);
  while ( *(_DWORD *)(a1 + 148)
       && !v6
       && (unsigned int)libssh2_session_last_errno(a1, a2) == -37
       && !(unsigned int)sub_179AF(a1, v5) );
  return v6;
}
// 4C60: using guessed type __int64 __fastcall libssh2_session_last_errno(_QWORD, _QWORD);

//----- (00000000000206A3) ----------------------------------------------------
__int64 __fastcall libssh2_userauth_authenticated(__int64 a1)
{
  return (*(_DWORD *)(a1 + 104) >> 2) & 1;
}

//----- (00000000000206BA) ----------------------------------------------------
__int64 __fastcall sub_206BA(size_t a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, void (__fastcall *a6)(size_t, size_t, size_t, size_t))
{
  __int64 result; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  void (__fastcall *v11)(size_t, size_t, size_t, size_t); // [rsp+8h] [rbp-48h]
  void *v12; // [rsp+10h] [rbp-40h]
  unsigned int v13; // [rsp+18h] [rbp-38h]
  unsigned int v14; // [rsp+1Ch] [rbp-34h]
  int v15; // [rsp+3Ch] [rbp-14h]
  int v16; // [rsp+3Ch] [rbp-14h]
  int v17; // [rsp+3Ch] [rbp-14h]
  _BYTE *v18; // [rsp+40h] [rbp-10h]
  unsigned __int64 v19; // [rsp+48h] [rbp-8h]

  v14 = a3;
  v12 = a4;
  v13 = a5;
  v11 = a6;
  v19 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53096) )
  {
    memset((void *)(a1 + 53144), 0, 8uLL);
    *(_QWORD *)(a1 + 53120) = v14 + 40;
    *(_BYTE *)(a1 + 53112) = -61;
    *(_QWORD *)(a1 + 53104) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53120), a1);
    v18 = *(_BYTE **)(a1 + 53104);
    if ( !*(_QWORD *)(a1 + 53104) )
      return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for userauth-password request");
    v7 = v18++;
    *v7 = 50;
    sub_101FF((void **)&v18, a2, v14);
    sub_101FF((void **)&v18, "ssh-connection", 0xEuLL);
    sub_101FF((void **)&v18, "password", 8uLL);
    v8 = v18++;
    *v8 = 0;
    sub_101C7(&v18, v13);
    *(_DWORD *)(a1 + 53096) = 2;
  }
  if ( *(_DWORD *)(a1 + 53096) == 2 )
  {
    v15 = sub_24D86(a1, *(const void **)(a1 + 53104), *(_QWORD *)(a1 + 53120), v12, v13);
    if ( v15 == -37 )
    {
      result = sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block writing password request");
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
      *(_QWORD *)(a1 + 53104) = 0LL;
      if ( !v15 )
      {
        *(_DWORD *)(a1 + 53096) = 3;
        goto LABEL_11;
      }
      *(_DWORD *)(a1 + 53096) = 0;
      result = sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth-password request");
    }
  }
  else
  {
LABEL_11:
    while ( *(_DWORD *)(a1 + 53096) == 3 || *(_DWORD *)(a1 + 53096) == 4 || *(_DWORD *)(a1 + 53096) == 5 )
    {
      if ( *(_DWORD *)(a1 + 53096) == 3 )
      {
        v16 = sub_12797(a1, "43<", (_QWORD *)(a1 + 53104), (_QWORD *)(a1 + 53120), 0, 0LL, 0LL, (time_t *)(a1 + 53144));
        if ( v16 == -37 )
          return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting");
        if ( v16 )
        {
          *(_DWORD *)(a1 + 53096) = 0;
          return sub_FF92(a1, 0xFFFFFFF7, (__int64)"Would block waiting");
        }
        if ( **(_BYTE **)(a1 + 53104) == 52 )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
          *(_QWORD *)(a1 + 53104) = 0LL;
          *(_DWORD *)(a1 + 104) |= 4u;
          *(_DWORD *)(a1 + 53096) = 0;
          return 0LL;
        }
        if ( **(_BYTE **)(a1 + 53104) == 51 )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
          *(_QWORD *)(a1 + 53104) = 0LL;
          *(_DWORD *)(a1 + 53096) = 0;
          return sub_FF92(a1, 0xFFFFFFEE, (__int64)"Authentication failed (username/password)");
        }
        *(_QWORD *)(a1 + 53128) = 0LL;
        *(_DWORD *)(a1 + 53136) = 0;
        *(_DWORD *)(a1 + 53096) = 4;
      }
      if ( **(_BYTE **)(a1 + 53104) != 60 && *(_BYTE *)(a1 + 53112) != 60 )
        break;
      *(_BYTE *)(a1 + 53112) = 60;
      if ( *(_DWORD *)(a1 + 53096) != 4 && *(_DWORD *)(a1 + 53096) != 5 )
      {
        *(_DWORD *)(a1 + 53096) = 0;
        return sub_FF92(a1, 0xFFFFFFF1, (__int64)"Password Expired, and no callback specified");
      }
      if ( *(_DWORD *)(a1 + 53096) == 4 )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
        *(_QWORD *)(a1 + 53104) = 0LL;
      }
      if ( !v11 )
        break;
      if ( *(_DWORD *)(a1 + 53096) == 4 )
      {
        v11(a1, a1 + 53128, a1 + 53136, a1);
        if ( !*(_QWORD *)(a1 + 53128) )
          return sub_FF92(a1, 0xFFFFFFF1, (__int64)"Password expired, and callback failed");
        *(_QWORD *)(a1 + 53120) = v14 + v13 + 44;
        *(_QWORD *)(a1 + 53104) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53120), a1);
        v18 = *(_BYTE **)(a1 + 53104);
        if ( !*(_QWORD *)(a1 + 53104) )
        {
          (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53128), a1);
          *(_QWORD *)(a1 + 53128) = 0LL;
          return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for userauth password change request");
        }
        v9 = v18++;
        *v9 = 50;
        sub_101FF((void **)&v18, a2, v14);
        sub_101FF((void **)&v18, "ssh-connection", 0xEuLL);
        sub_101FF((void **)&v18, "password", 8uLL);
        v10 = v18++;
        *v10 = 1;
        sub_101FF((void **)&v18, v12, v13);
        sub_101C7(&v18, *(_DWORD *)(a1 + 53136));
        *(_DWORD *)(a1 + 53096) = 5;
      }
      if ( *(_DWORD *)(a1 + 53096) != 5 )
        break;
      v17 = sub_24D86(
              a1,
              *(const void **)(a1 + 53104),
              *(_QWORD *)(a1 + 53120),
              *(void **)(a1 + 53128),
              *(signed int *)(a1 + 53136));
      if ( v17 == -37 )
        return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block waiting");
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
      *(_QWORD *)(a1 + 53104) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53128), a1);
      *(_QWORD *)(a1 + 53128) = 0LL;
      if ( v17 )
        return sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth password-change request");
      *(_DWORD *)(a1 + 53096) = 3;
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53104), a1);
    *(_QWORD *)(a1 + 53104) = 0LL;
    *(_DWORD *)(a1 + 53096) = 0;
    result = sub_FF92(a1, 0xFFFFFFEE, (__int64)"Authentication failed");
  }
  return result;
}

//----- (0000000000020EC8) ----------------------------------------------------
__int64 __fastcall libssh2_userauth_password_ex(size_t a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, void (__fastcall *a6)(size_t, size_t, size_t, size_t))
{
  void (__fastcall *v7)(size_t, size_t, size_t, size_t); // [rsp+8h] [rbp-38h]
  void *v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+18h] [rbp-28h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  v12 = time(0LL);
  do
  {
    v11 = sub_206BA(a1, a2, v10, v8, v9, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v11 = sub_179AF(a1, v12);
  }
  while ( !v11 );
  return v11;
}

//----- (0000000000020F51) ----------------------------------------------------
__int64 __fastcall sub_20F51(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, const char *a6)
{
  __int64 result; // rax
  size_t v7; // rax
  _QWORD *v8; // [rsp+8h] [rbp-68h]
  _QWORD *v9; // [rsp+10h] [rbp-60h]
  _QWORD *v10; // [rsp+18h] [rbp-58h]
  char ptr; // [rsp+33h] [rbp-3Dh]
  unsigned int v12; // [rsp+34h] [rbp-3Ch]
  __int64 v13; // [rsp+38h] [rbp-38h]
  char *v14; // [rsp+40h] [rbp-30h]
  size_t n; // [rsp+48h] [rbp-28h]
  void *s; // [rsp+50h] [rbp-20h]
  FILE *stream; // [rsp+58h] [rbp-18h]
  void *v18; // [rsp+60h] [rbp-10h]
  unsigned __int64 v19; // [rsp+68h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v19 = __readfsqword(0x28u);
  s = 0LL;
  n = 0LL;
  stream = fopen(a6, "r");
  if ( !stream )
    return sub_FF92(a1, 0xFFFFFFF0, (__int64)"Unable to open public key file");
  while ( !feof(stream) && fread(&ptr, 1uLL, 1uLL, stream) == 1 && ptr != 13 && ptr != 10 )
    ++n;
  if ( feof(stream) )
    --n;
  rewind(stream);
  if ( n > 1 )
  {
    s = (void *)(*(__int64 (__fastcall **)(size_t, __int64))(a1 + 8))(n, a1);
    if ( s )
    {
      v7 = fread(s, 1uLL, n, stream);
      if ( n == v7 )
      {
        fclose(stream);
        while ( n && (*__ctype_b_loc())[*((unsigned __int8 *)s + n - 1)] & 0x2000 )
          --n;
        if ( n )
        {
          v18 = memchr(s, 32, n);
          if ( v18 )
          {
            v18 = (char *)v18 + 1;
            v14 = (char *)memchr(v18, 32, n - ((_BYTE *)v18 - (_BYTE *)s) + 1);
            if ( !v14 )
              v14 = (char *)s + n;
            if ( (unsigned int)libssh2_base64_decode(a1, &v13, &v12, v18, (unsigned int)((_DWORD)v14 - (_DWORD)v18)) )
            {
              (*(void (__fastcall **)(void *, __int64))(a1 + 24))(s, a1);
              result = sub_FF92(a1, 0xFFFFFFF0, (__int64)"Invalid key data, not base64 encoded");
            }
            else
            {
              *a2 = s;
              *v10 = (_BYTE *)v18 - (_BYTE *)s - 1;
              *v9 = v13;
              *v8 = v12;
              result = 0LL;
            }
          }
          else
          {
            (*(void (__fastcall **)(void *, __int64))(a1 + 24))(s, a1);
            result = sub_FF92(a1, 0xFFFFFFF0, (__int64)"Invalid public key data");
          }
        }
        else
        {
          (*(void (__fastcall **)(void *, __int64))(a1 + 24))(s, a1);
          result = sub_FF92(a1, 0xFFFFFFF0, (__int64)"Missing public key data");
        }
      }
      else
      {
        (*(void (__fastcall **)(void *, __int64))(a1 + 24))(s, a1);
        fclose(stream);
        result = sub_FF92(a1, 0xFFFFFFF0, (__int64)"Unable to read public key from file");
      }
    }
    else
    {
      fclose(stream);
      result = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for public key data");
    }
  }
  else
  {
    fclose(stream);
    result = sub_FF92(a1, 0xFFFFFFF0, (__int64)"Invalid data in public key file");
  }
  return result;
}
// 4EB0: using guessed type __int64 __fastcall libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000212F3) ----------------------------------------------------
__int64 __fastcall sub_212F3(__int64 a1, __int64 a2, _QWORD *a3, char *a4, int a5, __int64 a6, __int64 a7)
{
  __int64 v8; // [rsp+0h] [rbp-40h]
  int v9; // [rsp+Ch] [rbp-34h]
  char *s2; // [rsp+10h] [rbp-30h]
  _QWORD *v11; // [rsp+18h] [rbp-28h]
  const char ***v12; // [rsp+38h] [rbp-8h]

  v11 = a3;
  s2 = a4;
  v9 = a5;
  v8 = a6;
  v12 = (const char ***)libssh2_hostkey_methods(a1);
  *(_QWORD *)a2 = 0LL;
  *v11 = 0LL;
  while ( *v12 && **v12 )
  {
    if ( (*v12)[3] && !strncmp(**v12, s2, v9) )
    {
      *(_QWORD *)a2 = *v12;
      break;
    }
    ++v12;
  }
  if ( !*(_QWORD *)a2 )
    return sub_FF92(a1, 0xFFFFFFEF, (__int64)"No handler for specified private key");
  if ( (*(unsigned int (__fastcall **)(__int64, __int64, __int64, _QWORD *))(*(_QWORD *)a2 + 24LL))(a1, v8, a7, v11) )
    return sub_FF92(a1, 0xFFFFFFF0, (__int64)"Unable to initialize private key from file");
  return 0LL;
}
// 4DC0: using guessed type __int64 __fastcall libssh2_hostkey_methods(_QWORD);

//----- (0000000000021402) ----------------------------------------------------
signed __int64 __fastcall sub_21402(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 **a6)
{
  signed __int64 result; // rax
  __int64 **v7; // [rsp+8h] [rbp-70h]
  __int64 v8; // [rsp+10h] [rbp-68h]
  __int64 v9; // [rsp+18h] [rbp-60h]
  __int64 v10; // [rsp+20h] [rbp-58h]
  unsigned int v11; // [rsp+3Ch] [rbp-3Ch]
  __int64 v12; // [rsp+40h] [rbp-38h]
  char v13; // [rsp+48h] [rbp-30h]
  __int64 *v14; // [rsp+50h] [rbp-28h]
  __int64 v15; // [rsp+58h] [rbp-20h]
  __int64 v16; // [rsp+60h] [rbp-18h]
  unsigned __int64 v17; // [rsp+70h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v17 = __readfsqword(0x28u);
  v14 = *a6;
  v11 = sub_212F3(a1, (__int64)&v12, &v13, *(char **)(a1 + 53264), *(_QWORD *)(a1 + 53272), *v14, v14[1]);
  if ( v11 )
    return v11;
  v15 = v9;
  v16 = v8;
  if ( (*(unsigned int (__fastcall **)(__int64, __int64, __int64, signed __int64, __int64 *, char *))(v12 + 40))(
         a1,
         a2,
         v10,
         1LL,
         &v15,
         &v13) )
  {
    if ( *(_QWORD *)(v12 + 56) )
      (*(void (__fastcall **)(__int64, __int64 **))(v12 + 56))(a1, v7);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( *(_QWORD *)(v12 + 56) )
      (*(void (__fastcall **)(__int64, char *))(v12 + 56))(a1, &v13);
    result = 0LL;
  }
  return result;
}

//----- (0000000000021541) ----------------------------------------------------
signed __int64 __fastcall sub_21541(size_t a1, const void *a2, size_t a3, const char *a4, __int64 a5, __int64 a6, const void *a7, size_t a8, const void *a9, size_t a10)
{
  signed __int64 result; // rax
  _BYTE *v11; // rax
  __int64 v12; // rax
  __int64 v13; // [rsp+10h] [rbp-C0h]
  __int64 v14; // [rsp+18h] [rbp-B8h]
  const char *v15; // [rsp+20h] [rbp-B0h]
  size_t v16; // [rsp+28h] [rbp-A8h]
  unsigned int v17; // [rsp+44h] [rbp-8Ch]
  unsigned int v18; // [rsp+44h] [rbp-8Ch]
  unsigned int v19; // [rsp+44h] [rbp-8Ch]
  int v20; // [rsp+44h] [rbp-8Ch]
  int v21; // [rsp+44h] [rbp-8Ch]
  __int64 v22; // [rsp+48h] [rbp-88h]
  const void *v23; // [rsp+50h] [rbp-80h]
  const void *v24; // [rsp+58h] [rbp-78h]
  size_t v25; // [rsp+60h] [rbp-70h]
  size_t v26; // [rsp+68h] [rbp-68h]
  char v27; // [rsp+70h] [rbp-60h]
  __int64 v28; // [rsp+78h] [rbp-58h]
  char *v29; // [rsp+80h] [rbp-50h]
  __int64 v30; // [rsp+88h] [rbp-48h]
  __int64 v31; // [rsp+90h] [rbp-40h]
  __int64 v32; // [rsp+98h] [rbp-38h]
  __int64 v33; // [rsp+A0h] [rbp-30h]
  __int64 v34; // [rsp+A8h] [rbp-28h]
  char v35; // [rsp+C3h] [rbp-Dh]
  unsigned __int64 v36; // [rsp+C8h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  v36 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53152) )
  {
    memset((void *)(a1 + 53216), 0, 8uLL);
    if ( v15 )
    {
      v17 = sub_20F51(a1, (void **)(a1 + 53192), (_QWORD *)(a1 + 53200), &v23, &v25, v15);
      if ( v17 )
        return v17;
    }
    else
    {
      v18 = sub_29578(a1, (void **)(a1 + 53192), (_QWORD *)(a1 + 53200), &v23, &v25, v14, v13);
      if ( v18 )
        return v18;
    }
    *(_QWORD *)(a1 + 53184) = a10 + a8 + v16 + *(_QWORD *)(a1 + 53200) + v25 + 52;
    *(_QWORD *)(a1 + 53176) = (*(__int64 (__fastcall **)(size_t, size_t))(a1 + 8))(
                                *(_QWORD *)(a1 + 53200) + *(_QWORD *)(a1 + 53184) + v25 + 12,
                                a1);
    *(_QWORD *)(a1 + 53208) = *(_QWORD *)(a1 + 53176);
    if ( !*(_QWORD *)(a1 + 53176) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53192), a1);
      *(_QWORD *)(a1 + 53192) = 0LL;
      (*(void (__fastcall **)(const void *, size_t))(a1 + 24))(v23, a1);
      return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Out of memory");
    }
    v11 = *(_BYTE **)(a1 + 53208);
    *(_QWORD *)(a1 + 53208) = v11 + 1;
    *v11 = 50;
    sub_101FF((void **)(a1 + 53208), a2, v16);
    sub_101FF((void **)(a1 + 53208), "ssh-connection", 0xEuLL);
    sub_101FF((void **)(a1 + 53208), "hostbased", 9uLL);
    sub_101FF((void **)(a1 + 53208), *(const void **)(a1 + 53192), *(_QWORD *)(a1 + 53200));
    sub_101FF((void **)(a1 + 53208), v23, v25);
    (*(void (__fastcall **)(const void *, size_t))(a1 + 24))(v23, a1);
    sub_101FF((void **)(a1 + 53208), a7, a8);
    sub_101FF((void **)(a1 + 53208), a9, a10);
    v19 = sub_212F3(a1, (__int64)&v22, &v27, *(char **)(a1 + 53192), *(_QWORD *)(a1 + 53200), v14, v13);
    if ( v19 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53192), a1);
      *(_QWORD *)(a1 + 53192) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53176), a1);
      *(_QWORD *)(a1 + 53176) = 0LL;
      return v19;
    }
    sub_1017A(&v35, *(_DWORD *)(a1 + 144));
    v29 = &v35;
    v30 = 4LL;
    v31 = *(_QWORD *)(a1 + 136);
    v32 = *(unsigned int *)(a1 + 144);
    v33 = *(_QWORD *)(a1 + 53176);
    v34 = *(_QWORD *)(a1 + 53184);
    if ( (*(unsigned int (__fastcall **)(size_t, const void **, size_t *, signed __int64, char **, char *))(v22 + 40))(
           a1,
           &v24,
           &v26,
           3LL,
           &v29,
           &v27) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53192), a1);
      *(_QWORD *)(a1 + 53192) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53176), a1);
      *(_QWORD *)(a1 + 53176) = 0LL;
      if ( *(_QWORD *)(v22 + 56) )
        (*(void (__fastcall **)(size_t, char *))(v22 + 56))(a1, &v27);
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(v22 + 56) )
      (*(void (__fastcall **)(size_t, char *))(v22 + 56))(a1, &v27);
    if ( v26 > v25 )
    {
      if ( *(_QWORD *)(a1 + 53176) )
        v12 = (*(__int64 (__fastcall **)(_QWORD, size_t, size_t))(a1 + 16))(
                *(_QWORD *)(a1 + 53176),
                *(_QWORD *)(a1 + 53200) + *(_QWORD *)(a1 + 53184) + v26 + 12,
                a1);
      else
        v12 = (*(__int64 (__fastcall **)(size_t, size_t))(a1 + 8))(
                *(_QWORD *)(a1 + 53200) + *(_QWORD *)(a1 + 53184) + v26 + 12,
                a1);
      v28 = v12;
      if ( !v12 )
      {
        (*(void (__fastcall **)(const void *, size_t))(a1 + 24))(v24, a1);
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53176), a1);
        *(_QWORD *)(a1 + 53176) = 0LL;
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53192), a1);
        *(_QWORD *)(a1 + 53192) = 0LL;
        return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Failed allocating additional space for userauth-hostbased packet");
      }
      *(_QWORD *)(a1 + 53176) = v28;
    }
    *(_QWORD *)(a1 + 53208) = *(_QWORD *)(a1 + 53184) + *(_QWORD *)(a1 + 53176);
    sub_101C7((_BYTE **)(a1 + 53208), *(unsigned __int64 *)(a1 + 53200) + v26 + 8);
    sub_101FF((void **)(a1 + 53208), *(const void **)(a1 + 53192), *(_QWORD *)(a1 + 53200));
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53192), a1);
    *(_QWORD *)(a1 + 53192) = 0LL;
    sub_101FF((void **)(a1 + 53208), v24, v26);
    (*(void (__fastcall **)(const void *, size_t))(a1 + 24))(v24, a1);
    *(_DWORD *)(a1 + 53152) = 2;
  }
  if ( *(_DWORD *)(a1 + 53152) == 2 )
  {
    v20 = sub_24D86(a1, *(const void **)(a1 + 53176), *(_QWORD *)(a1 + 53208) - *(_QWORD *)(a1 + 53176), 0LL, 0LL);
    if ( v20 == -37 )
      return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
    if ( v20 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53176), a1);
      *(_QWORD *)(a1 + 53176) = 0LL;
      *(_DWORD *)(a1 + 53152) = 0;
      return sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth-hostbased request");
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53176), a1);
    *(_QWORD *)(a1 + 53176) = 0LL;
    *(_DWORD *)(a1 + 53152) = 3;
  }
  if ( *(_DWORD *)(a1 + 53152) != 3 )
    goto LABEL_41;
  v21 = sub_12797(a1, "43", (_QWORD *)(a1 + 53160), &v27, 0, 0LL, 0LL, (time_t *)(a1 + 53216));
  if ( v21 == -37 )
    return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
  *(_DWORD *)(a1 + 53152) = 0;
  if ( v21 )
    return sub_FF92(a1, 0xFFFFFFED, (__int64)"Auth failed");
  if ( **(_BYTE **)(a1 + 53160) != 52 )
  {
LABEL_41:
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53160), a1);
    *(_QWORD *)(a1 + 53160) = 0LL;
    result = sub_FF92(
               a1,
               0xFFFFFFED,
               (__int64)"Invalid signature for supplied public key, or bad username/public key combination");
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53160), a1);
    *(_QWORD *)(a1 + 53160) = 0LL;
    *(_DWORD *)(a1 + 104) |= 4u;
    result = 0LL;
  }
  return result;
}

//----- (0000000000022132) ----------------------------------------------------
__int64 __fastcall libssh2_userauth_hostbased_fromfile_ex(size_t a1, const void *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6, const void *a7, unsigned int a8, const void *a9, unsigned int a10)
{
  __int64 v11; // [rsp+0h] [rbp-40h]
  __int64 v12; // [rsp+8h] [rbp-38h]
  const char *v13; // [rsp+10h] [rbp-30h]
  unsigned int v14; // [rsp+1Ch] [rbp-24h]
  unsigned int v15; // [rsp+34h] [rbp-Ch]
  time_t v16; // [rsp+38h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  v16 = time(0LL);
  do
  {
    v15 = sub_21541(a1, a2, v14, v13, v12, v11, a7, a8, a9, a10);
    if ( v15 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v15 = sub_179AF(a1, v16);
  }
  while ( !v15 );
  return v15;
}

//----- (00000000000221CD) ----------------------------------------------------
__int64 __fastcall sub_221CD(size_t a1, const void *a2, unsigned int a3, unsigned int *a4, unsigned __int64 a5, __int64 (__fastcall *a6)(size_t, const void **, size_t *, void *, signed __int64, __int64), __int64 a7)
{
  __int64 result; // rax
  __int64 v8; // rbx
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  __int64 v11; // rax
  __int64 (__fastcall *v12)(size_t, const void **, size_t *, void *, signed __int64, __int64); // [rsp+10h] [rbp-80h]
  size_t v13; // [rsp+18h] [rbp-78h]
  unsigned int *v14; // [rsp+20h] [rbp-70h]
  unsigned int v15; // [rsp+2Ch] [rbp-64h]
  int v16; // [rsp+44h] [rbp-4Ch]
  int v17; // [rsp+44h] [rbp-4Ch]
  int v18; // [rsp+44h] [rbp-4Ch]
  int v19; // [rsp+44h] [rbp-4Ch]
  int v20; // [rsp+44h] [rbp-4Ch]
  void *dest; // [rsp+48h] [rbp-48h]
  const void *v22; // [rsp+50h] [rbp-40h]
  size_t v23; // [rsp+58h] [rbp-38h]
  void *v24; // [rsp+60h] [rbp-30h]
  __int64 v25; // [rsp+68h] [rbp-28h]
  char v26; // [rsp+74h] [rbp-1Ch]
  char v27; // [rsp+75h] [rbp-1Bh]
  char v28; // [rsp+76h] [rbp-1Ah]
  char v29; // [rsp+77h] [rbp-19h]
  unsigned __int64 v30; // [rsp+78h] [rbp-18h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v30 = __readfsqword(0x28u);
  v26 = 52;
  v27 = 51;
  v28 = 60;
  v29 = 0;
  if ( !*(_DWORD *)(a1 + 53224) )
  {
    if ( a5 <= 3 )
      return sub_FF92(a1, 0xFFFFFFED, (__int64)"Invalid public key, too short");
    memset((void *)(a1 + 53296), 0, 8uLL);
    if ( *(_QWORD *)(a1 + 53264) )
    {
      v8 = *(_QWORD *)(a1 + 53272);
      if ( v8 != (unsigned int)sub_10071(v14) )
        return sub_FF92(a1, 0xFFFFFFED, (__int64)"Invalid public key");
    }
    else
    {
      *(_QWORD *)(a1 + 53272) = (unsigned int)sub_10071(v14);
      if ( v13 < *(_QWORD *)(a1 + 53272) )
        return sub_FF92(a1, 0xFFFFFFED, (__int64)"Invalid public key");
      *(_QWORD *)(a1 + 53264) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53272), a1);
      if ( !*(_QWORD *)(a1 + 53264) )
        return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for public key data");
      memcpy(*(void **)(a1 + 53264), v14 + 1, *(_QWORD *)(a1 + 53272));
    }
    *(_QWORD *)(a1 + 53256) = *(_QWORD *)(a1 + 53272) + v15 + v13 + 45;
    *(_QWORD *)(a1 + 53248) = (*(__int64 (__fastcall **)(size_t, size_t))(a1 + 8))(
                                *(_QWORD *)(a1 + 53272) + *(_QWORD *)(a1 + 53256) + v13 + 12,
                                a1);
    dest = *(void **)(a1 + 53248);
    if ( !*(_QWORD *)(a1 + 53248) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
      *(_QWORD *)(a1 + 53264) = 0LL;
      return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Out of memory");
    }
    v9 = dest;
    dest = (char *)dest + 1;
    *v9 = 50;
    sub_101FF(&dest, a2, v15);
    sub_101FF(&dest, "ssh-connection", 0xEuLL);
    sub_101FF(&dest, "publickey", 9uLL);
    *(_QWORD *)(a1 + 53288) = dest;
    v10 = dest;
    dest = (char *)dest + 1;
    *v10 = 0;
    sub_101FF(&dest, *(const void **)(a1 + 53264), *(_QWORD *)(a1 + 53272));
    sub_101FF(&dest, v14, v13);
    *(_DWORD *)(a1 + 53224) = 2;
  }
  if ( *(_DWORD *)(a1 + 53224) == 2 )
  {
    v16 = sub_24D86(a1, *(const void **)(a1 + 53248), *(_QWORD *)(a1 + 53256), 0LL, 0LL);
    if ( v16 == -37 )
      return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
    if ( v16 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
      *(_QWORD *)(a1 + 53248) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
      *(_QWORD *)(a1 + 53264) = 0LL;
      *(_DWORD *)(a1 + 53224) = 0;
      return sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth-publickey request");
    }
    *(_DWORD *)(a1 + 53224) = 3;
  }
  if ( *(_DWORD *)(a1 + 53224) == 3 )
  {
    v17 = sub_12797(a1, &v26, (_QWORD *)(a1 + 53232), (_QWORD *)(a1 + 53240), 0, 0LL, 0LL, (time_t *)(a1 + 53296));
    if ( v17 == -37 )
      return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
    if ( v17 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
      *(_QWORD *)(a1 + 53248) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
      *(_QWORD *)(a1 + 53264) = 0LL;
      *(_DWORD *)(a1 + 53224) = 0;
      return sub_FF92(a1, 0xFFFFFFED, (__int64)"Waiting for USERAUTH response");
    }
    if ( **(_BYTE **)(a1 + 53232) == 52 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53232), a1);
      *(_QWORD *)(a1 + 53232) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
      *(_QWORD *)(a1 + 53248) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
      *(_QWORD *)(a1 + 53264) = 0LL;
      *(_DWORD *)(a1 + 104) |= 4u;
      *(_DWORD *)(a1 + 53224) = 0;
      return 0LL;
    }
    if ( **(_BYTE **)(a1 + 53232) == 51 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53232), a1);
      *(_QWORD *)(a1 + 53232) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
      *(_QWORD *)(a1 + 53248) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
      *(_QWORD *)(a1 + 53264) = 0LL;
      *(_DWORD *)(a1 + 53224) = 0;
      return sub_FF92(a1, 0xFFFFFFEE, (__int64)"Username/PublicKey combination invalid");
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53232), a1);
    *(_QWORD *)(a1 + 53232) = 0LL;
    **(_BYTE **)(a1 + 53288) = 1;
    *(_DWORD *)(a1 + 53224) = 4;
  }
  if ( *(_DWORD *)(a1 + 53224) == 4 )
  {
    v24 = (void *)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                    (unsigned int)(*(_DWORD *)(a1 + 144) + 4) + *(_QWORD *)(a1 + 53256),
                    a1);
    dest = v24;
    if ( !v24 )
      return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for userauth-publickey signed data");
    sub_101FF(&dest, *(const void **)(a1 + 136), *(unsigned int *)(a1 + 144));
    memcpy(dest, *(const void **)(a1 + 53248), *(_QWORD *)(a1 + 53256));
    dest = (char *)dest + *(_QWORD *)(a1 + 53256);
    v18 = v12(a1, &v22, &v23, v24, (_BYTE *)dest - (_BYTE *)v24, a7);
    (*(void (__fastcall **)(void *, size_t))(a1 + 24))(v24, a1);
    if ( v18 == -37 )
      return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
    if ( v18 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
      *(_QWORD *)(a1 + 53264) = 0LL;
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
      *(_QWORD *)(a1 + 53248) = 0LL;
      *(_DWORD *)(a1 + 53224) = 0;
      return sub_FF92(a1, 0xFFFFFFED, (__int64)"Callback returned error");
    }
    if ( v13 < v23 )
    {
      if ( *(_QWORD *)(a1 + 53248) )
        v11 = (*(__int64 (__fastcall **)(_QWORD, size_t, size_t))(a1 + 16))(
                *(_QWORD *)(a1 + 53248),
                *(_QWORD *)(a1 + 53272) + *(_QWORD *)(a1 + 53256) + v23 + 12,
                a1);
      else
        v11 = (*(__int64 (__fastcall **)(size_t, size_t))(a1 + 8))(
                *(_QWORD *)(a1 + 53272) + *(_QWORD *)(a1 + 53256) + v23 + 12,
                a1);
      v25 = v11;
      if ( !v11 )
      {
        (*(void (__fastcall **)(const void *, size_t))(a1 + 24))(v22, a1);
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
        *(_QWORD *)(a1 + 53248) = 0LL;
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
        *(_QWORD *)(a1 + 53264) = 0LL;
        *(_DWORD *)(a1 + 53224) = 0;
        return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Failed allocating additional space for userauth-publickey packet");
      }
      *(_QWORD *)(a1 + 53248) = v25;
    }
    dest = (void *)(*(_QWORD *)(a1 + 53248) + *(_QWORD *)(a1 + 53256));
    *(_QWORD *)(a1 + 53288) = 0LL;
    sub_101C7((_BYTE **)&dest, *(unsigned __int64 *)(a1 + 53272) + v23 + 8);
    sub_101FF(&dest, *(const void **)(a1 + 53264), *(_QWORD *)(a1 + 53272));
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53264), a1);
    *(_QWORD *)(a1 + 53264) = 0LL;
    sub_101FF(&dest, v22, v23);
    (*(void (__fastcall **)(const void *, size_t))(a1 + 24))(v22, a1);
    *(_QWORD *)(a1 + 53280) = dest;
    *(_DWORD *)(a1 + 53224) = 5;
  }
  if ( *(_DWORD *)(a1 + 53224) == 5 )
  {
    v19 = sub_24D86(a1, *(const void **)(a1 + 53248), *(_QWORD *)(a1 + 53280) - *(_QWORD *)(a1 + 53248), 0LL, 0LL);
    if ( v19 == -37 )
      return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
    if ( v19 )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
      *(_QWORD *)(a1 + 53248) = 0LL;
      *(_DWORD *)(a1 + 53224) = 0;
      return sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth-publickey request");
    }
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53248), a1);
    *(_QWORD *)(a1 + 53248) = 0LL;
    *(_DWORD *)(a1 + 53224) = 6;
  }
  v28 = 0;
  v20 = sub_12797(a1, &v26, (_QWORD *)(a1 + 53232), (_QWORD *)(a1 + 53240), 0, 0LL, 0LL, (time_t *)(a1 + 53296));
  if ( v20 == -37 )
    return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block requesting userauth list");
  if ( v20 )
  {
    *(_DWORD *)(a1 + 53224) = 0;
    result = sub_FF92(a1, 0xFFFFFFED, (__int64)"Waiting for publickey USERAUTH response");
  }
  else if ( **(_BYTE **)(a1 + 53232) == 52 )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53232), a1);
    *(_QWORD *)(a1 + 53232) = 0LL;
    *(_DWORD *)(a1 + 104) |= 4u;
    *(_DWORD *)(a1 + 53224) = 0;
    result = 0LL;
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53232), a1);
    *(_QWORD *)(a1 + 53232) = 0LL;
    *(_DWORD *)(a1 + 53224) = 0;
    result = sub_FF92(
               a1,
               0xFFFFFFED,
               (__int64)"Invalid signature for supplied public key, or bad username/public key combination");
  }
  return result;
}

//----- (0000000000022FBA) ----------------------------------------------------
__int64 __fastcall sub_22FBA(size_t a1, const void *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+18h] [rbp-58h]
  unsigned int v8; // [rsp+34h] [rbp-3Ch]
  unsigned int v9; // [rsp+34h] [rbp-3Ch]
  unsigned int v10; // [rsp+34h] [rbp-3Ch]
  unsigned int *v11; // [rsp+38h] [rbp-38h]
  unsigned __int64 v12; // [rsp+40h] [rbp-30h]
  __int64 *v13; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  unsigned __int64 v16; // [rsp+68h] [rbp-8h]

  v7 = a3;
  v16 = __readfsqword(0x28u);
  v11 = 0LL;
  v12 = 0LL;
  v13 = &v14;
  v14 = a5;
  v15 = a6;
  if ( !*(_DWORD *)(a1 + 53224) )
  {
    if ( a4 )
    {
      v8 = sub_20F51(a1, (void **)(a1 + 53264), (_QWORD *)(a1 + 53272), &v11, &v12, a4);
      if ( v8 )
        return v8;
    }
    else
    {
      v9 = sub_29578(a1, (void **)(a1 + 53264), (_QWORD *)(a1 + 53272), &v11, &v12, a5, a6);
      if ( v9 )
        return v9;
    }
  }
  v10 = sub_221CD(
          a1,
          a2,
          v7,
          v11,
          v12,
          (__int64 (__fastcall *)(size_t, const void **, size_t *, void *, signed __int64, __int64))sub_21402,
          (__int64)&v13);
  if ( v11 )
    (*(void (__fastcall **)(unsigned int *, size_t))(a1 + 24))(v11, a1);
  return v10;
}

//----- (0000000000023141) ----------------------------------------------------
__int64 __fastcall libssh2_userauth_publickey_fromfile_ex(size_t a1, const void *a2, unsigned int a3, const char *a4, __int64 a5, void *a6)
{
  void *v7; // [rsp+0h] [rbp-40h]
  __int64 v8; // [rsp+8h] [rbp-38h]
  const char *v9; // [rsp+10h] [rbp-30h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a6 )
    v7 = &unk_2CEE8;
  v12 = time(0LL);
  do
  {
    v11 = sub_22FBA(a1, a2, v10, v9, v8, (__int64)v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v11 = sub_179AF(a1, v12);
  }
  while ( !v11 );
  return v11;
}

//----- (00000000000231DD) ----------------------------------------------------
signed __int64 __fastcall libssh2_userauth_publickey(size_t a1, const char *a2, __int64 a3, __int64 a4, __int64 (__fastcall *a5)(size_t, const void **, size_t *, void *, signed __int64, __int64), __int64 a6)
{
  unsigned int v7; // eax
  __int64 v8; // [rsp+0h] [rbp-40h]
  __int64 (__fastcall *v9)(size_t, const void **, size_t *, void *, signed __int64, __int64); // [rsp+8h] [rbp-38h]
  __int128 v10; // [rsp+10h] [rbp-30h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  *((_QWORD *)&v10 + 1) = a3;
  *(_QWORD *)&v10 = a4;
  v9 = a5;
  v8 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v7 = strlen(a2);
    v11 = sub_221CD(a1, a2, v7, *((unsigned int **)&v10 + 1), v10, v9, v8);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v11 = sub_179AF(a1, v12);
  }
  while ( !v11 );
  return v11;
}

//----- (0000000000023296) ----------------------------------------------------
signed __int64 __fastcall sub_23296(size_t a1, const void *a2, unsigned int a3, void (__fastcall *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, size_t))
{
  _BYTE *v5; // rax
  unsigned int v6; // ST3C_4
  signed __int64 v7; // rbx
  signed __int64 v8; // rbx
  _BYTE *v9; // rax
  void (__fastcall *v10)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, size_t); // [rsp+0h] [rbp-50h]
  unsigned int v11; // [rsp+Ch] [rbp-44h]
  unsigned int i; // [rsp+24h] [rbp-2Ch]
  unsigned int j; // [rsp+24h] [rbp-2Ch]
  unsigned int k; // [rsp+24h] [rbp-2Ch]
  unsigned int l; // [rsp+24h] [rbp-2Ch]
  unsigned int m; // [rsp+24h] [rbp-2Ch]
  int v17; // [rsp+28h] [rbp-28h]
  int v18; // [rsp+28h] [rbp-28h]
  int v19; // [rsp+28h] [rbp-28h]
  void *src; // [rsp+30h] [rbp-20h]
  unsigned __int64 v21; // [rsp+38h] [rbp-18h]

  v11 = a3;
  v10 = a4;
  v21 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53304) )
  {
    *(_QWORD *)(a1 + 53352) = 0LL;
    *(_QWORD *)(a1 + 53368) = 0LL;
    *(_DWORD *)(a1 + 53376) = 0;
    *(_DWORD *)(a1 + 53380) = 1;
    *(_QWORD *)(a1 + 53384) = 0LL;
    *(_QWORD *)(a1 + 53392) = 0LL;
    memset((void *)(a1 + 53400), 0, 8uLL);
    *(_QWORD *)(a1 + 53336) = v11 + 55;
    src = (void *)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53336), a1);
    *(_QWORD *)(a1 + 53312) = src;
    if ( !src )
      return sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for keyboard-interactive authentication");
    v5 = src;
    src = (char *)src + 1;
    *v5 = 50;
    sub_101FF(&src, a2, v11);
    sub_101FF(&src, "ssh-connection", 0xEuLL);
    sub_101FF(&src, "keyboard-interactive", 0x14uLL);
    sub_101C7((_BYTE **)&src, 0);
    sub_101C7((_BYTE **)&src, 0);
    *(_DWORD *)(a1 + 53304) = 2;
  }
  if ( *(_DWORD *)(a1 + 53304) != 2 )
    goto LABEL_11;
  v17 = sub_24D86(a1, *(const void **)(a1 + 53312), *(_QWORD *)(a1 + 53336), 0LL, 0LL);
  if ( v17 == -37 )
    return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
  if ( v17 )
  {
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
    *(_QWORD *)(a1 + 53312) = 0LL;
    *(_DWORD *)(a1 + 53304) = 0;
    return sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send keyboard-interactive request");
  }
  (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
  *(_QWORD *)(a1 + 53312) = 0LL;
  for ( *(_DWORD *)(a1 + 53304) = 3; ; *(_DWORD *)(a1 + 53304) = 3 )
  {
LABEL_11:
    if ( *(_DWORD *)(a1 + 53304) == 3 )
    {
      v18 = sub_12797(a1, "43<", (_QWORD *)(a1 + 53312), (_QWORD *)(a1 + 53320), 0, 0LL, 0LL, (time_t *)(a1 + 53400));
      if ( v18 == -37 )
        return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
      if ( v18 )
      {
        *(_DWORD *)(a1 + 53304) = 0;
        return sub_FF92(a1, 0xFFFFFFEE, (__int64)"Waiting for keyboard USERAUTH response");
      }
      if ( **(_BYTE **)(a1 + 53312) == 52 )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
        *(_QWORD *)(a1 + 53312) = 0LL;
        *(_DWORD *)(a1 + 104) |= 4u;
        *(_DWORD *)(a1 + 53304) = 0;
        return 0LL;
      }
      if ( **(_BYTE **)(a1 + 53312) == 51 )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
        *(_QWORD *)(a1 + 53312) = 0LL;
        *(_DWORD *)(a1 + 53304) = 0;
        return sub_FF92(a1, 0xFFFFFFEE, (__int64)"Authentication failed (keyboard-interactive)");
      }
      src = (void *)(*(_QWORD *)(a1 + 53312) + 1LL);
      *(_DWORD *)(a1 + 53344) = sub_10071((unsigned int *)src);
      src = (char *)src + 4;
      if ( *(_DWORD *)(a1 + 53344) )
      {
        *(_QWORD *)(a1 + 53352) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                    *(unsigned int *)(a1 + 53344),
                                    a1);
        if ( !*(_QWORD *)(a1 + 53352) )
        {
          sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for keyboard-interactive 'name' request field");
          goto LABEL_53;
        }
        memcpy(*(void **)(a1 + 53352), src, *(unsigned int *)(a1 + 53344));
        src = (char *)src + *(unsigned int *)(a1 + 53344);
      }
      *(_DWORD *)(a1 + 53360) = sub_10071((unsigned int *)src);
      src = (char *)src + 4;
      if ( *(_DWORD *)(a1 + 53360) )
      {
        *(_QWORD *)(a1 + 53368) = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(
                                    *(unsigned int *)(a1 + 53360),
                                    a1);
        if ( !*(_QWORD *)(a1 + 53368) )
        {
          sub_FF92(
            a1,
            0xFFFFFFFA,
            (__int64)"Unable to allocate memory for keyboard-interactive 'instruction' request field");
          goto LABEL_53;
        }
        memcpy(*(void **)(a1 + 53368), src, *(unsigned int *)(a1 + 53360));
        src = (char *)src + *(unsigned int *)(a1 + 53360);
      }
      v6 = sub_10071((unsigned int *)src);
      src = (char *)src + 4;
      src = (char *)src + v6;
      *(_DWORD *)(a1 + 53376) = sub_10071((unsigned int *)src);
      src = (char *)src + 4;
      if ( *(_DWORD *)(a1 + 53376) )
      {
        *(_QWORD *)(a1 + 53384) = (*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(
                                    16LL * *(unsigned int *)(a1 + 53376),
                                    a1);
        if ( !*(_QWORD *)(a1 + 53384) )
        {
          sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for keyboard-interactive prompts array");
          goto LABEL_53;
        }
        memset(*(void **)(a1 + 53384), 0, 16LL * *(unsigned int *)(a1 + 53376));
        *(_QWORD *)(a1 + 53392) = (*(__int64 (__fastcall **)(signed __int64, size_t))(a1 + 8))(
                                    16LL * *(unsigned int *)(a1 + 53376),
                                    a1);
        if ( !*(_QWORD *)(a1 + 53392) )
        {
          sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for keyboard-interactive responses array");
          goto LABEL_53;
        }
        memset(*(void **)(a1 + 53392), 0, 16LL * *(unsigned int *)(a1 + 53376));
        for ( i = 0; i != *(_DWORD *)(a1 + 53376); ++i )
        {
          v7 = *(_QWORD *)(a1 + 53384) + 16LL * i;
          *(_DWORD *)(v7 + 8) = sub_10071((unsigned int *)src);
          src = (char *)src + 4;
          v8 = *(_QWORD *)(a1 + 53384) + 16LL * i;
          *(_QWORD *)v8 = (*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(unsigned int *)(v8 + 8), a1);
          if ( !*(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 53384)) )
          {
            sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for keyboard-interactive prompt message");
            goto LABEL_53;
          }
          memcpy(
            *(void **)(16LL * i + *(_QWORD *)(a1 + 53384)),
            src,
            *(unsigned int *)(16LL * i + *(_QWORD *)(a1 + 53384) + 8));
          src = (char *)src + *(unsigned int *)(16LL * i + *(_QWORD *)(a1 + 53384) + 8);
          v9 = src;
          src = (char *)src + 1;
          *(_BYTE *)(16LL * i + *(_QWORD *)(a1 + 53384) + 12) = *v9;
        }
      }
      v10(
        *(_QWORD *)(a1 + 53352),
        *(unsigned int *)(a1 + 53344),
        *(_QWORD *)(a1 + 53368),
        *(unsigned int *)(a1 + 53360),
        *(unsigned int *)(a1 + 53376),
        *(_QWORD *)(a1 + 53384),
        *(_QWORD *)(a1 + 53392),
        a1);
      *(_QWORD *)(a1 + 53336) = 5LL;
      for ( j = 0; j != *(_DWORD *)(a1 + 53376); ++j )
        *(_QWORD *)(a1 + 53336) += (unsigned int)(*(_DWORD *)(16LL * j + *(_QWORD *)(a1 + 53392) + 8) + 4);
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
      src = (void *)(*(__int64 (__fastcall **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53336), a1);
      *(_QWORD *)(a1 + 53312) = src;
      if ( !src )
      {
        sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for keyboard-interactive response packet");
        goto LABEL_53;
      }
      *(_BYTE *)src = 61;
      src = (char *)src + 1;
      sub_101C7((_BYTE **)&src, *(_DWORD *)(a1 + 53376));
      for ( k = 0; k != *(_DWORD *)(a1 + 53376); ++k )
        sub_101FF(
          &src,
          *(const void **)(16LL * k + *(_QWORD *)(a1 + 53392)),
          *(unsigned int *)(16LL * k + *(_QWORD *)(a1 + 53392) + 8));
      *(_DWORD *)(a1 + 53304) = 4;
    }
    if ( *(_DWORD *)(a1 + 53304) == 4 )
    {
      v19 = sub_24D86(a1, *(const void **)(a1 + 53312), *(_QWORD *)(a1 + 53336), 0LL, 0LL);
      if ( v19 == -37 )
        return sub_FF92(a1, 0xFFFFFFDB, (__int64)"Would block");
      if ( v19 )
        sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send userauth-keyboard-interactive request");
      else
        *(_DWORD *)(a1 + 53380) = 0;
    }
LABEL_53:
    (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53312), a1);
    *(_QWORD *)(a1 + 53312) = 0LL;
    if ( *(_QWORD *)(a1 + 53384) )
    {
      for ( l = 0; l != *(_DWORD *)(a1 + 53376); ++l )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(16LL * l + *(_QWORD *)(a1 + 53384)), a1);
        *(_QWORD *)(16LL * l + *(_QWORD *)(a1 + 53384)) = 0LL;
      }
    }
    if ( *(_QWORD *)(a1 + 53392) )
    {
      for ( m = 0; m != *(_DWORD *)(a1 + 53376); ++m )
      {
        (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(16LL * m + *(_QWORD *)(a1 + 53392)), a1);
        *(_QWORD *)(16LL * m + *(_QWORD *)(a1 + 53392)) = 0LL;
      }
    }
    if ( *(_QWORD *)(a1 + 53384) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53384), a1);
      *(_QWORD *)(a1 + 53384) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 53392) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53392), a1);
      *(_QWORD *)(a1 + 53392) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 53352) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53352), a1);
      *(_QWORD *)(a1 + 53352) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 53368) )
    {
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53368), a1);
      *(_QWORD *)(a1 + 53368) = 0LL;
    }
    if ( *(_DWORD *)(a1 + 53380) )
      break;
  }
  *(_DWORD *)(a1 + 53304) = 0;
  return 0xFFFFFFFFLL;
}

//----- (0000000000024013) ----------------------------------------------------
__int64 __fastcall libssh2_userauth_keyboard_interactive_ex(size_t a1, const void *a2, unsigned int a3, void (__fastcall *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, size_t))
{
  void (__fastcall *v5)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, size_t); // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = time(0LL);
  do
  {
    v7 = sub_23296(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v7 = sub_179AF(a1, v8);
  }
  while ( !v7 );
  return v7;
}

//----- (0000000000024087) ----------------------------------------------------
signed __int64 __fastcall sub_24087(__int64 a1, char *a2, char *a3, int a4)
{
  int v5; // [rsp+4h] [rbp-2Ch]
  char *dest; // [rsp+8h] [rbp-28h]
  char *src; // [rsp+10h] [rbp-20h]
  int v8; // [rsp+24h] [rbp-Ch]

  src = a2;
  dest = a3;
  v5 = a4;
  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 248) + 8LL);
  if ( a4 % v8 )
    __assert_fail("(len % blocksize) == 0", "transport.c", 0x8Bu, "decrypt");
  while ( v5 >= v8 )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)(a1 + 248) + 40LL))(a1, src, a1 + 256) )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 16968), a1);
      return 4294967284LL;
    }
    memcpy(dest, src, v8);
    v5 -= v8;
    dest += v8;
    src += v8;
  }
  return 0LL;
}

//----- (0000000000024182) ----------------------------------------------------
__int64 __fastcall sub_24182(size_t a1, int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-3Ch]
  unsigned int v4; // [rsp+14h] [rbp-3Ch]
  __int64 v5; // [rsp+18h] [rbp-38h]
  __int64 v6; // [rsp+20h] [rbp-30h]
  size_t v7; // [rsp+28h] [rbp-28h]
  char s1; // [rsp+30h] [rbp-20h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v7 = a1 + 536;
  if ( !*(_DWORD *)(a1 + 53816) )
  {
    *(_DWORD *)(a1 + 53820) = 0;
    *(_QWORD *)(a1 + 53824) = (unsigned int)(*(_DWORD *)(v7 + 16408) - 1);
    if ( a2 )
    {
      (*(void (__fastcall **)(size_t, char *, _QWORD, size_t, signed __int64, _QWORD, _QWORD, size_t))(*(_QWORD *)(a1 + 264) + 24LL))(
        a1,
        &s1,
        *(unsigned int *)(a1 + 272),
        v7 + 0x4000,
        5LL,
        *(_QWORD *)(v7 + 16432),
        (unsigned int)*(_QWORD *)(a1 + 53824),
        a1 + 280);
      if ( memcmp(
             &s1,
             (const void *)(*(_QWORD *)(a1 + 53824) + *(_QWORD *)(v7 + 16432)),
             *(signed int *)(*(_QWORD *)(a1 + 264) + 8LL)) )
      {
        *(_DWORD *)(a1 + 53820) = -1;
      }
    }
    ++*(_DWORD *)(a1 + 272);
    *(_QWORD *)(a1 + 53824) -= *(unsigned __int8 *)(v7 + 16412);
    if ( *(_QWORD *)(a1 + 288) && *(_DWORD *)(*(_QWORD *)(a1 + 288) + 8LL) && *(_QWORD *)(a1 + 296) )
    {
      v3 = (*(__int64 (__fastcall **)(size_t, __int64 *, __int64 *, signed __int64, _QWORD, _QWORD, size_t))(*(_QWORD *)(a1 + 288) + 32LL))(
             a1,
             &v5,
             &v6,
             40000LL,
             *(_QWORD *)(v7 + 16432),
             *(_QWORD *)(a1 + 53824),
             a1 + 296);
      (*(void (__fastcall **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(v7 + 16432), a1);
      if ( v3 )
        return v3;
      *(_QWORD *)(v7 + 16432) = v5;
      *(_QWORD *)(a1 + 53824) = v6;
    }
    *(_DWORD *)(a1 + 53832) = **(unsigned __int8 **)(v7 + 16432);
    *(_DWORD *)(a1 + 53816) = 2;
  }
  if ( *(_DWORD *)(a1 + 53816) == 2 )
  {
    v4 = sub_113E1(a1, *(unsigned __int8 **)(v7 + 16432), *(_QWORD *)(a1 + 53824), *(_DWORD *)(a1 + 53820));
    if ( v4 )
      return v4;
  }
  *(_DWORD *)(a1 + 53816) = 0;
  return *(unsigned int *)(a1 + 53832);
}

//----- (000000000002445D) ----------------------------------------------------
signed __int64 __fastcall sub_2445D(size_t a1)
{
  signed __int64 result; // rax
  unsigned int v2; // er9
  int v3; // eax
  int v4; // [rsp+14h] [rbp-6Ch]
  int v5; // [rsp+18h] [rbp-68h]
  int v6; // [rsp+1Ch] [rbp-64h]
  int v7; // [rsp+20h] [rbp-60h]
  int v8; // [rsp+24h] [rbp-5Ch]
  unsigned int v9; // [rsp+28h] [rbp-58h]
  unsigned int v10; // [rsp+28h] [rbp-58h]
  unsigned int v11; // [rsp+28h] [rbp-58h]
  int v12; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+40h] [rbp-40h]
  unsigned __int64 v14; // [rsp+48h] [rbp-38h]
  unsigned int v15; // [rsp+50h] [rbp-30h]
  char v16; // [rsp+54h] [rbp-2Ch]
  _BYTE v17[3]; // [rsp+55h] [rbp-2Bh]
  unsigned __int64 v18; // [rsp+78h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  v8 = 1;
  *(_DWORD *)(a1 + 512) &= 0xFFFFFFFE;
  if ( *(_DWORD *)(a1 + 104) & 1 )
  {
    if ( !(*(_DWORD *)(a1 + 104) & 8) )
    {
      v9 = sub_EFB4(a1, 1, (_DWORD *)(a1 + 52384));
      if ( v9 )
        return v9;
    }
  }
  if ( *(_DWORD *)(a1 + 53056) != 11 )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(a1 + 508) == -1 )
        return 0LL;
      if ( *(_DWORD *)(a1 + 104) & 2 )
      {
        v7 = *(_DWORD *)(*(_QWORD *)(a1 + 248) + 8LL);
      }
      else
      {
        v8 = 0;
        v7 = 5;
      }
      v4 = *(unsigned __int64 *)(a1 + 16928) - *(unsigned __int64 *)(a1 + 16936);
      if ( v4 < 0 )
        __assert_fail("remainbuf >= 0", "transport.c", 0x154u, "_libssh2_transport_read");
      if ( v4 < v7 )
      {
        if ( v4 )
        {
          memmove((void *)(a1 + 536), (const void *)(a1 + 536 + *(_QWORD *)(a1 + 16936)), v4);
          *(_QWORD *)(a1 + 16936) = 0LL;
          *(_QWORD *)(a1 + 16928) = v4;
        }
        else
        {
          *(_QWORD *)(a1 + 16928) = 0LL;
          *(_QWORD *)(a1 + 16936) = *(_QWORD *)(a1 + 16928);
        }
        if ( *(_DWORD *)(a1 + 108) )
          v2 = 0;
        else
          v2 = 0x4000;
        v13 = (*(__int64 (__fastcall **)(_QWORD, size_t, _QWORD, _QWORD, size_t))(a1 + 80))(
                *(unsigned int *)(a1 + 504),
                a1 + 536 + v4,
                0x4000 - v4,
                v2,
                a1);
        if ( v13 <= 0 )
        {
          if ( v13 >= 0 || v13 != -11 )
            return 4294967253LL;
          *(_DWORD *)(a1 + 512) |= 1u;
          return 4294967259LL;
        }
        *(_QWORD *)(a1 + 16928) += v13;
        v4 = *(unsigned __int64 *)(a1 + 16928) - *(unsigned __int64 *)(a1 + 16936);
      }
      v5 = v4;
      if ( !*(_QWORD *)(a1 + 16960) )
      {
        if ( v4 < v7 )
        {
          *(_DWORD *)(a1 + 512) |= 1u;
          return 4294967259LL;
        }
        if ( v8 )
        {
          v10 = sub_24087(a1, (char *)(*(_QWORD *)(a1 + 16936) + a1 + 536), (char *)&v15, v7);
          if ( v10 )
            return v10;
          memcpy((void *)(a1 + 16920), (const void *)(*(_QWORD *)(a1 + 16936) + a1 + 536), 5uLL);
        }
        else
        {
          memcpy(&v15, (const void *)(a1 + 536 + *(_QWORD *)(a1 + 16936)), v7);
        }
        *(_QWORD *)(a1 + 16936) += v7;
        *(_DWORD *)(a1 + 16944) = sub_10071(&v15);
        if ( !*(_DWORD *)(a1 + 16944) )
          return 4294967284LL;
        *(_BYTE *)(a1 + 16948) = v16;
        if ( v8 )
          v3 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 8LL);
        else
          v3 = 0;
        v14 = (unsigned int)(*(_DWORD *)(a1 + 16944) + v3 - 1);
        if ( v14 > 0x9C40 )
          return 4294967255LL;
        *(_QWORD *)(a1 + 16968) = (*(__int64 (__fastcall **)(unsigned __int64, size_t))(a1 + 8))(v14, a1);
        if ( !*(_QWORD *)(a1 + 16968) )
          return 4294967290LL;
        *(_QWORD *)(a1 + 16960) = v14;
        *(_QWORD *)(a1 + 16976) = *(_QWORD *)(a1 + 16968);
        if ( v7 > 5 )
        {
          memcpy(*(void **)(a1 + 16976), v17, v7 - 5);
          *(_QWORD *)(a1 + 16976) += v7 - 5LL;
        }
        *(_QWORD *)(a1 + 16952) = *(_QWORD *)(a1 + 16976) - *(_QWORD *)(a1 + 16968);
        v5 = v4 - v7;
      }
      if ( v5 > (signed int)(*(unsigned __int64 *)(a1 + 16960) - *(_QWORD *)(a1 + 16952)) )
        v5 = *(unsigned __int64 *)(a1 + 16960) - *(unsigned __int64 *)(a1 + 16952);
      if ( v8 )
      {
        v12 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 8LL);
        if ( *(_QWORD *)(a1 + 16952) + (signed __int64)v5 <= (unsigned __int64)(*(_QWORD *)(a1 + 16960) - v12) )
        {
          v6 = v5;
          if ( v5 % v7 )
          {
            v6 = v5 - v5 % v7;
            v5 = 0;
          }
        }
        else
        {
          v6 = *(unsigned __int64 *)(a1 + 16960) - v12 - *(unsigned __int64 *)(a1 + 16952);
        }
      }
      else
      {
        v6 = 0;
      }
      if ( v6 > 0 )
      {
        v11 = sub_24087(a1, (char *)(*(_QWORD *)(a1 + 16936) + a1 + 536), *(char **)(a1 + 16976), v6);
        if ( v11 )
          return v11;
        *(_QWORD *)(a1 + 16936) += v6;
        *(_QWORD *)(a1 + 16976) += v6;
        *(_QWORD *)(a1 + 16952) += v6;
        v5 -= v6;
      }
      if ( v5 > 0 )
      {
        memcpy(*(void **)(a1 + 16976), (const void *)(a1 + 536 + *(_QWORD *)(a1 + 16936)), v5);
        *(_QWORD *)(a1 + 16936) += v5;
        *(_QWORD *)(a1 + 16976) += v5;
        *(_QWORD *)(a1 + 16952) += v5;
      }
      if ( (unsigned int)*(_QWORD *)(a1 + 16960) == (unsigned int)*(_QWORD *)(a1 + 16952) )
      {
        LODWORD(result) = sub_24182(a1, v8);
        goto LABEL_63;
      }
    }
  }
  *(_DWORD *)(a1 + 53056) = 0;
  v8 = *(_DWORD *)(a1 + 53060);
  LODWORD(result) = sub_24182(a1, v8);
LABEL_63:
  if ( (_DWORD)result == -37 )
  {
    if ( *(_DWORD *)(a1 + 53608) )
    {
      *(_DWORD *)(a1 + 53060) = v8;
      *(_DWORD *)(a1 + 53056) = 11;
    }
    result = (unsigned int)result;
  }
  else
  {
    *(_QWORD *)(a1 + 16960) = 0LL;
    result = (unsigned int)result;
  }
  return result;
}

//----- (0000000000024BF5) ----------------------------------------------------
signed __int64 __fastcall sub_24BF5(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  signed __int64 result; // rax
  unsigned int v5; // er9
  __int64 v6; // [rsp+30h] [rbp-10h]
  __int64 v7; // [rsp+38h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 52000) )
  {
    if ( a2 == *(_QWORD *)(a1 + 51992) && a3 == *(_QWORD *)(a1 + 52000) )
    {
      *a4 = 1LL;
      v6 = *(signed int *)(a1 + 51984) - *(_QWORD *)(a1 + 52008);
      if ( *(_DWORD *)(a1 + 108) )
        v5 = 0;
      else
        v5 = 0x4000;
      v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, __int64))(a1 + 72))(
             *(unsigned int *)(a1 + 504),
             a1 + 536 + *(_QWORD *)(a1 + 52008) + 16448LL,
             v6,
             v5,
             a1);
      if ( v7 == v6 )
      {
        *(_DWORD *)(a1 + 51984) = 0;
        *(_QWORD *)(a1 + 52000) = 0LL;
        result = 0LL;
      }
      else if ( v7 >= 0 )
      {
        *(_QWORD *)(a1 + 52008) += v7;
        if ( v7 >= v6 )
          result = 0LL;
        else
          result = 4294967259LL;
      }
      else if ( v7 == -11 )
      {
        *(_DWORD *)(a1 + 512) |= 2u;
        result = 4294967259LL;
      }
      else
      {
        result = 4294967289LL;
      }
    }
    else
    {
      result = 4294967257LL;
    }
  }
  else
  {
    *a4 = 0LL;
    result = 0LL;
  }
  return result;
}

//----- (0000000000024D86) ----------------------------------------------------
signed __int64 __fastcall sub_24D86(__int64 a1, const void *a2, __int64 a3, void *a4, size_t a5)
{
  signed int v5; // eax
  signed __int64 result; // rax
  int v7; // edx
  unsigned int v8; // er9
  __int64 v9; // rax
  size_t v10; // [rsp+8h] [rbp-98h]
  const void *v11; // [rsp+10h] [rbp-90h]
  __int64 n; // [rsp+18h] [rbp-88h]
  size_t na; // [rsp+18h] [rbp-88h]
  signed int v14; // [rsp+3Ch] [rbp-64h]
  unsigned int v15; // [rsp+40h] [rbp-60h]
  unsigned int v16; // [rsp+40h] [rbp-60h]
  unsigned int v17; // [rsp+40h] [rbp-60h]
  signed int v18; // [rsp+44h] [rbp-5Ch]
  int v19; // [rsp+48h] [rbp-58h]
  int v20; // [rsp+4Ch] [rbp-54h]
  __int64 v21; // [rsp+50h] [rbp-50h]
  __int64 v22; // [rsp+58h] [rbp-48h]
  __int64 v23; // [rsp+60h] [rbp-40h]
  unsigned __int64 i; // [rsp+68h] [rbp-38h]
  __int64 v25; // [rsp+70h] [rbp-30h]
  const void *v26; // [rsp+78h] [rbp-28h]
  __int64 v27; // [rsp+80h] [rbp-20h]
  unsigned __int64 v28; // [rsp+88h] [rbp-18h]
  unsigned __int64 v29; // [rsp+90h] [rbp-10h]
  unsigned __int64 v30; // [rsp+98h] [rbp-8h]

  n = a3;
  v11 = a4;
  v10 = a5;
  v30 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 104) & 2 )
    v5 = *(_DWORD *)(*(_QWORD *)(a1 + 360) + 8LL);
  else
    v5 = 8;
  v18 = v5;
  v25 = a1 + 536;
  v26 = a2;
  v27 = a3;
  if ( *(_DWORD *)(a1 + 104) & 1 )
  {
    if ( !(*(_DWORD *)(a1 + 104) & 8) )
    {
      v15 = sub_EFB4(a1, 1, (_DWORD *)(a1 + 52384));
      if ( v15 )
        return v15;
    }
  }
  v16 = sub_24BF5(a1, (__int64)a2, n, &v21);
  if ( v16 )
    return v16;
  *(_DWORD *)(a1 + 512) &= 0xFFFFFFFD;
  if ( v21 )
    return 0LL;
  v19 = (*(_DWORD *)(a1 + 104) >> 1) & 1;
  if ( v19 && *(_DWORD *)(*(_QWORD *)(a1 + 400) + 8LL) )
  {
    v22 = 34739LL;
    v23 = 34739LL;
    v17 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, const void *, __int64, __int64))(*(_QWORD *)(a1 + 400)
                                                                                                 + 24LL))(
            a1,
            v25 + 16453,
            &v22,
            a2,
            n,
            a1 + 408);
    if ( v17 )
      return v17;
    if ( v11 && v10 )
    {
      v23 -= v22;
      v17 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, const void *, size_t, __int64))(*(_QWORD *)(a1 + 400)
                                                                                                  + 24LL))(
              a1,
              v22 + 16453 + v25,
              &v23,
              v11,
              v10,
              a1 + 408);
    }
    else
    {
      v23 = 0LL;
    }
    if ( v17 )
      return v17;
    na = v22 + v23;
  }
  else
  {
    if ( n + v10 > 0x87B7 )
      return 4294967262LL;
    memcpy((void *)(v25 + 16453), a2, n);
    if ( v11 && v10 )
      memcpy((void *)(n + 16453 + v25), v11, v10);
    na = v10 + n;
  }
  v28 = na + 5;
  v14 = v18 - (na + 5) % v18;
  if ( v14 <= 3 )
    v14 += v18;
  v28 += v14;
  if ( v19 )
    v7 = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 8LL);
  else
    v7 = 0;
  v20 = v7 + v28;
  sub_1017A((_BYTE *)(v25 + 16448), v28 - 4);
  *(_BYTE *)(v25 + 16452) = v14;
  RAND_bytes(na + 5 + v25 + 16448, (unsigned int)v14);
  if ( v19 )
  {
    (*(void (__fastcall **)(__int64, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 376) + 24LL))(
      a1,
      v25 + 16448 + v28,
      *(unsigned int *)(a1 + 384),
      v25 + 16448,
      (unsigned int)v28,
      0LL,
      0LL,
      a1 + 392);
    for ( i = 0LL; i < v28; i += *(signed int *)(*(_QWORD *)(a1 + 360) + 8LL) )
    {
      v29 = i + 16448 + v25;
      if ( (*(unsigned int (__fastcall **)(__int64, unsigned __int64, __int64))(*(_QWORD *)(a1 + 360) + 40LL))(
             a1,
             v29,
             a1 + 368) )
      {
        return 4294967252LL;
      }
    }
  }
  ++*(_DWORD *)(a1 + 384);
  if ( *(_DWORD *)(a1 + 108) )
    v8 = 0;
  else
    v8 = 0x4000;
  v21 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, __int64))(a1 + 72))(
          *(unsigned int *)(a1 + 504),
          v25 + 16448,
          v20,
          v8,
          a1);
  if ( v20 == v21 )
  {
    *(_QWORD *)(v25 + 51456) = 0LL;
    *(_QWORD *)(v25 + 51464) = 0LL;
    result = 0LL;
  }
  else if ( v21 < 0 && v21 != -11 )
  {
    result = 4294967289LL;
  }
  else
  {
    *(_DWORD *)(a1 + 512) |= 2u;
    *(_QWORD *)(v25 + 51456) = v26;
    *(_QWORD *)(v25 + 51464) = v27;
    v9 = v21;
    if ( v21 < 0 )
      v9 = 0LL;
    *(_QWORD *)(v25 + 51472) = v9;
    *(_DWORD *)(v25 + 51448) = v20;
    result = 4294967259LL;
  }
  return result;
}
// 4FC0: using guessed type __int64 __fastcall RAND_bytes(_QWORD, _QWORD);

//----- (000000000002532B) ----------------------------------------------------
const char *__fastcall libssh2_version(signed int a1)
{
  const char *result; // rax

  if ( a1 > (signed int)&loc_10403 )
    result = 0LL;
  else
    result = "1.4.3_DEV";
  return result;
}

//----- (000000000002534B) ----------------------------------------------------
__int64 __fastcall sub_2534B(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    if ( a2[9] )
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(a2[9], a1);
    if ( a2[8] )
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(a2[8], a1);
    if ( a2[6] )
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(a2[6], a1);
    if ( a2[3] )
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 24))(a2[3], a1);
    result = (*(__int64 (__fastcall **)(_QWORD *, __int64))(a1 + 24))(a2, a1);
  }
  return result;
}

//----- (0000000000025425) ----------------------------------------------------
__int64 *__fastcall libssh2_knownhost_init(__int64 a1)
{
  __int64 *result; // rax
  __int64 *v2; // [rsp+18h] [rbp-8h]

  v2 = (__int64 *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(24LL, a1);
  if ( v2 )
  {
    *v2 = a1;
    sub_107E8(v2 + 1);
    result = v2;
  }
  else
  {
    sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for known-hosts collection");
    result = 0LL;
  }
  return result;
}

//----- (0000000000025492) ----------------------------------------------------
signed __int64 __fastcall sub_25492(__int64 a1)
{
  __int64 v1; // rax

  *(_DWORD *)(a1 + 80) = -559035650;
  *(_QWORD *)(a1 + 88) = a1;
  if ( (unsigned __int16)*(_DWORD *)(a1 + 44) == 1 )
    v1 = *(_QWORD *)(a1 + 24);
  else
    v1 = 0LL;
  *(_QWORD *)(a1 + 96) = v1;
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44);
  return a1 + 80;
}

//----- (0000000000025506) ----------------------------------------------------
__int64 __fastcall sub_25506(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, void *a6, __int64 a7, __int64 a8, signed __int64 *a9)
{
  int v10; // eax
  unsigned int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rax
  void *src; // [rsp+10h] [rbp-60h]
  size_t v15; // [rsp+18h] [rbp-58h]
  char *v16; // [rsp+20h] [rbp-50h]
  char *v17; // [rsp+28h] [rbp-48h]
  unsigned int v18; // [rsp+40h] [rbp-30h]
  unsigned int v19; // [rsp+44h] [rbp-2Ch]
  __int64 v20; // [rsp+48h] [rbp-28h]
  size_t v21; // [rsp+50h] [rbp-20h]
  void *v22; // [rsp+58h] [rbp-18h]
  size_t v23; // [rsp+60h] [rbp-10h]
  unsigned __int64 v24; // [rsp+68h] [rbp-8h]

  v17 = a3;
  v16 = a4;
  v15 = a5;
  src = a6;
  v24 = __readfsqword(0x28u);
  v21 = strlen(a2);
  if ( !(a8 & 0xC0000) )
    return sub_FF92(*a1, 0xFFFFFFDE, (__int64)"No key type set");
  v22 = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(*a1 + 8))(120LL, *a1);
  if ( !v22 )
    return sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for known host entry");
  memset(v22, 0, 0x78uLL);
  *((_DWORD *)v22 + 11) = a8;
  v10 = (unsigned __int16)*((_DWORD *)v22 + 11);
  if ( v10 == 2 )
  {
    v19 = libssh2_base64_decode(*a1, &v20, &v18, a2, (unsigned int)v21);
    if ( v19 )
      goto LABEL_32;
    *((_QWORD *)v22 + 3) = v20;
    *((_QWORD *)v22 + 4) = v18;
    v11 = strlen(v17);
    v19 = libssh2_base64_decode(*a1, &v20, &v18, v17, v11);
    if ( v19 )
      goto LABEL_32;
    *((_QWORD *)v22 + 6) = v20;
    *((_QWORD *)v22 + 7) = v18;
  }
  else
  {
    if ( v10 != 3 && v10 != 1 )
    {
      v19 = sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unknown host name type");
      goto LABEL_32;
    }
    *((_QWORD *)v22 + 3) = (*(__int64 (__fastcall **)(size_t, __int64))(*a1 + 8))(v21 + 1, *a1);
    if ( !*((_QWORD *)v22 + 3) )
    {
      v19 = sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for host name");
LABEL_32:
      sub_2534B(*a1, v22);
      return v19;
    }
    memcpy(*((void **)v22 + 3), a2, v21 + 1);
  }
  if ( a8 & 0x20000 )
  {
    if ( !v15 )
      v15 = strlen(v16);
    v12 = (*(__int64 (__fastcall **)(size_t, __int64))(*a1 + 8))(v15 + 1, *a1);
    *((_QWORD *)v22 + 8) = v12;
    if ( !*((_QWORD *)v22 + 8) )
    {
      v19 = sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for key");
      goto LABEL_32;
    }
    memcpy(*((void **)v22 + 8), v16, v15 + 1);
    *(_BYTE *)(*((_QWORD *)v22 + 8) + v15) = 0;
  }
  else
  {
    v23 = sub_104AE(*a1, v16, v15, (char **)&v20);
    if ( !v23 )
    {
      v19 = sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for base64-encoded key");
      goto LABEL_32;
    }
    *((_QWORD *)v22 + 8) = v20;
  }
  if ( src )
  {
    v13 = (*(__int64 (__fastcall **)(__int64, __int64))(*a1 + 8))(a7 + 1, *a1);
    *((_QWORD *)v22 + 9) = v13;
    if ( !*((_QWORD *)v22 + 9) )
    {
      v19 = sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for comment");
      goto LABEL_32;
    }
    memcpy(*((void **)v22 + 9), src, a7 + 1);
    *(_BYTE *)(*((_QWORD *)v22 + 9) + a7) = 0;
  }
  else
  {
    *((_QWORD *)v22 + 9) = 0LL;
  }
  sub_1080D(a1 + 1, v22);
  if ( a9 )
    *a9 = sub_25492((__int64)v22);
  return 0LL;
}
// 4EB0: using guessed type __int64 __fastcall libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002596A) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_add(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, unsigned int a6, signed __int64 *a7)
{
  return sub_25506(a1, a2, a3, a4, a5, 0LL, 0LL, a6, a7);
}

//----- (00000000000259BF) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_addc(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, void *a6, __int64 a7, unsigned int a8, signed __int64 *a9)
{
  return sub_25506(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (0000000000025A13) ----------------------------------------------------
signed __int64 __fastcall sub_25A13(__int64 *a1, char *a2, unsigned int a3, const char *a4, size_t a5, int a6, signed __int64 *a7)
{
  signed __int64 v8; // rdi
  int v9; // eax
  __int64 v10; // rax
  size_t v11; // rax
  char *v12; // [rsp+10h] [rbp-2C0h]
  unsigned int v13; // [rsp+1Ch] [rbp-2B4h]
  char *v14; // [rsp+20h] [rbp-2B0h]
  __int64 *v15; // [rsp+28h] [rbp-2A8h]
  unsigned int v16; // [rsp+38h] [rbp-298h]
  signed int v17; // [rsp+3Ch] [rbp-294h]
  _BOOL4 v18; // [rsp+40h] [rbp-290h]
  int v19; // [rsp+44h] [rbp-28Ch]
  char *v20; // [rsp+48h] [rbp-288h]
  __int64 i; // [rsp+50h] [rbp-280h]
  __int64 v22; // [rsp+58h] [rbp-278h]
  char *s1; // [rsp+60h] [rbp-270h]
  size_t v24; // [rsp+68h] [rbp-268h]
  char v25; // [rsp+70h] [rbp-260h]
  char v26; // [rsp+190h] [rbp-140h]
  char s; // [rsp+1B0h] [rbp-120h]
  unsigned __int64 v28; // [rsp+2C8h] [rbp-8h]

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v12 = (char *)a4;
  v28 = __readfsqword(0x28u);
  v22 = 0LL;
  v19 = (unsigned __int16)a6;
  v20 = 0LL;
  v16 = 2;
  v18 = 0;
  if ( (unsigned __int16)a6 == 2 )
    return 1LL;
  if ( !(a6 & 0x20000) )
  {
    a2 = (char *)a4;
    v24 = sub_104AE(*a1, a4, a5, &v20);
    if ( !v24 )
    {
      sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for base64-encoded key");
      return 3LL;
    }
    v12 = v20;
  }
  if ( (v13 & 0x80000000) != 0 )
  {
    s1 = v14;
    v17 = 1;
  }
  else
  {
    a2 = (_BYTE *)(&qword_108 + 6);
    snprintf(&s, 0x10EuLL, "[%s]:%d", v14, v13);
    s1 = &s;
    v17 = 2;
  }
  do
  {
    v8 = (signed __int64)(v15 + 1);
    for ( i = sub_10877((__int64)(v15 + 1)); i; i = sub_10889(i) )
    {
      v9 = (unsigned __int16)*(_DWORD *)(i + 44);
      if ( v9 == 2 )
      {
        if ( v19 == 1 && *(_QWORD *)(i + 32) == 20LL )
        {
          v10 = EVP_sha1(v8, a2);
          HMAC_Init(&v25, *(_QWORD *)(i + 48), (unsigned int)*(_QWORD *)(i + 56), v10);
          v11 = strlen(s1);
          HMAC_Update(&v25, s1, v11);
          HMAC_Final(&v25, &v26, 0LL);
          HMAC_CTX_cleanup(&v25);
          a2 = *(char **)(i + 24);
          if ( !memcmp(&v26, a2, 0x14uLL) )
            v18 = 1;
        }
      }
      else if ( v9 == 3 )
      {
        if ( v19 == 3 )
        {
          a2 = *(char **)(i + 24);
          v18 = strcmp(s1, a2) == 0;
        }
      }
      else if ( v9 == 1 && v19 == 1 )
      {
        a2 = *(char **)(i + 24);
        v18 = strcmp(s1, a2) == 0;
      }
      if ( v18 )
      {
        a2 = *(char **)(i + 64);
        if ( !strcmp(v12, a2) )
        {
          if ( a7 )
            *a7 = sub_25492(i);
          v22 = 0LL;
          v16 = 0;
          break;
        }
        if ( !v22 )
          v22 = i;
        v18 = 0;
      }
      v8 = i;
    }
    s1 = v14;
    if ( v18 )
      break;
    --v17;
  }
  while ( v17 );
  if ( v22 )
  {
    if ( a7 )
      *a7 = sub_25492(v22);
    v16 = 1;
  }
  if ( v20 )
    (*(void (__fastcall **)(char *, __int64))(*v15 + 24))(v20, *v15);
  return v16;
}
// 108: using guessed type __int64;
// 4CA0: using guessed type __int64 __fastcall HMAC_CTX_cleanup(_QWORD);
// 4D60: using guessed type __int64 __fastcall HMAC_Init(_QWORD, _QWORD, _QWORD, _QWORD);
// 4E00: using guessed type __int64 __fastcall HMAC_Final(_QWORD, _QWORD, _QWORD);
// 4F00: using guessed type __int64 __fastcall EVP_sha1(_QWORD, _QWORD);
// 50C0: using guessed type __int64 __fastcall HMAC_Update(_QWORD, _QWORD, _QWORD);

//----- (0000000000025EA3) ----------------------------------------------------
signed __int64 __fastcall libssh2_knownhost_check(__int64 *a1, char *a2, const char *a3, size_t a4, int a5, signed __int64 *a6)
{
  return sub_25A13(a1, a2, 0xFFFFFFFF, a3, a4, a5, a6);
}

//----- (0000000000025EF9) ----------------------------------------------------
signed __int64 __fastcall libssh2_knownhost_checkp(__int64 *a1, char *a2, unsigned int a3, const char *a4, size_t a5, int a6, signed __int64 *a7)
{
  return sub_25A13(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0000000000025F4A) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_del(__int64 *a1, _QWORD *a2)
{
  _QWORD *v3; // ST18_8

  if ( !a2 || *(_DWORD *)a2 != -559035650 )
    return sub_FF92(*a1, 0xFFFFFFDE, (__int64)"Invalid host information");
  v3 = (_QWORD *)a2[1];
  sub_108AC(a2[1]);
  memset(a2, 0, 0x28uLL);
  sub_2534B(*a1, v3);
  return 0LL;
}

//----- (0000000000025FD6) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_free(__int64 *a1)
{
  __int64 v1; // ST18_8
  _QWORD *i; // [rsp+10h] [rbp-10h]

  for ( i = (_QWORD *)sub_10877((__int64)(a1 + 1)); i; i = (_QWORD *)v1 )
  {
    v1 = sub_10889((__int64)i);
    sub_2534B(*a1, i);
  }
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 24))(a1, *a1);
}

//----- (0000000000026051) ----------------------------------------------------
__int64 __fastcall sub_26051(__int64 *a1, char *a2, __int64 a3, char *a4, size_t a5, int a6, void *a7, __int64 a8)
{
  int v9; // [rsp+14h] [rbp-15Ch]
  size_t v10; // [rsp+18h] [rbp-158h]
  char *v11; // [rsp+20h] [rbp-150h]
  unsigned int v12; // [rsp+4Ch] [rbp-124h]
  size_t n; // [rsp+50h] [rbp-120h]
  char *src; // [rsp+58h] [rbp-118h]
  char dest[264]; // [rsp+60h] [rbp-110h]
  unsigned __int64 v16; // [rsp+168h] [rbp-8h]

  v11 = a4;
  v10 = a5;
  v9 = a6;
  v16 = __readfsqword(0x28u);
  n = 0LL;
  src = &a2[a3];
  if ( !a3 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Failed to parse known_hosts line (no host names)");
  while ( src > a2 )
  {
    --src;
    ++n;
    if ( src == a2 || *(src - 1) == 44 )
    {
      if ( n > 0xFE )
        return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Failed to parse known_hosts line (unexpected length)");
      memcpy(dest, src, n);
      dest[n] = 0;
      v12 = sub_25506(a1, dest, 0LL, v11, v10, a7, a8, v9 | 0x20001u, 0LL);
      if ( v12 )
        return v12;
      if ( src > a2 )
      {
        n = 0LL;
        --src;
      }
    }
  }
  return 0LL;
}
// 26051: using guessed type char dest[264];

//----- (0000000000026258) ----------------------------------------------------
__int64 __fastcall sub_26258(__int64 *a1, __int64 a2, __int64 a3, char *a4, size_t a5, int a6, void *a7, __int64 a8)
{
  int v9; // [rsp+14h] [rbp-17Ch]
  size_t v10; // [rsp+18h] [rbp-178h]
  char *v11; // [rsp+20h] [rbp-170h]
  size_t v12; // [rsp+28h] [rbp-168h]
  unsigned __int64 v13; // [rsp+28h] [rbp-168h]
  _BYTE *i; // [rsp+40h] [rbp-150h]
  _BYTE *src; // [rsp+48h] [rbp-148h]
  size_t n; // [rsp+58h] [rbp-138h]
  char dest[32]; // [rsp+60h] [rbp-130h]
  char v18[264]; // [rsp+80h] [rbp-110h]
  unsigned __int64 v19; // [rsp+188h] [rbp-8h]

  v11 = a4;
  v10 = a5;
  v9 = a6;
  v19 = __readfsqword(0x28u);
  src = (_BYTE *)(a2 + 3);
  v12 = a3 - 3;
  for ( i = (_BYTE *)(a2 + 3); *i && *i != 124; ++i )
    ;
  if ( *i != 124 )
    return 0LL;
  n = i - src;
  if ( (unsigned __int64)(i - src) > 0x1E )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Failed to parse known_hosts line (unexpectedly long salt)");
  memcpy(dest, src, n);
  dest[n] = 0;
  v13 = v12 - n - 1;
  if ( v13 > 0xFE )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Failed to parse known_hosts line (unexpected length)");
  memcpy(v18, i + 1, v13);
  v18[v13] = 0;
  return sub_25506(a1, v18, dest, v11, v10, a7, a8, v9 | 0x20002u, 0LL);
}
// 26258: using guessed type char dest[32];
// 26258: using guessed type char var_110[264];

//----- (00000000000264AB) ----------------------------------------------------
__int64 __fastcall sub_264AB(__int64 *a1, char *a2, unsigned __int64 a3, const char *a4, unsigned __int64 a5)
{
  __int64 result; // rax
  signed int v6; // eax
  size_t v7; // [rsp+8h] [rbp-48h]
  signed __int64 v8; // [rsp+8h] [rbp-48h]
  char *s1; // [rsp+10h] [rbp-40h]
  unsigned __int64 v10; // [rsp+18h] [rbp-38h]
  int v11; // [rsp+3Ch] [rbp-14h]
  char *v12; // [rsp+40h] [rbp-10h]
  __int64 i; // [rsp+48h] [rbp-8h]

  v10 = a3;
  s1 = (char *)a4;
  v7 = a5;
  v12 = 0LL;
  i = 0LL;
  if ( a5 <= 0x13 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Failed to parse known_hosts line (key too short)");
  v6 = *a4;
  if ( v6 < 48 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unknown key format");
  if ( v6 <= 57 )
  {
    v11 = 0x40000;
  }
  else
  {
    if ( v6 != 115 )
      return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unknown key format");
    if ( !strncmp(a4, "ssh-dss", 7uLL) )
    {
      v11 = 786432;
    }
    else
    {
      if ( strncmp(s1, "ssh-rsa", 7uLL) )
        return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unknown key type");
      v11 = 0x80000;
    }
    s1 += 7;
    v8 = v7 - 7;
    while ( *s1 == 32 || *s1 == 9 )
    {
      ++s1;
      --v8;
    }
    v12 = s1;
    for ( i = v8; i && *v12 && *v12 != 32 && *v12 != 9; --i )
      ++v12;
    v7 = v8 - i;
    if ( !i )
      v12 = 0LL;
    while ( i && *v12 && (*v12 == 32 || *v12 == 9) )
    {
      ++v12;
      --i;
    }
  }
  if ( v10 <= 2 || !memcmp(a2, "|1|", 3uLL) )
    result = sub_26258(a1, (__int64)a2, v10, s1, v7, v11, v12, i);
  else
    result = sub_26051(a1, a2, v10, s1, v7, v11, v12, i);
  return result;
}

//----- (00000000000266FB) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_readline(__int64 *a1, char *a2, unsigned __int64 a3, int a4)
{
  __int64 result; // rax
  unsigned __int64 v5; // [rsp+8h] [rbp-48h]
  unsigned int v6; // [rsp+24h] [rbp-2Ch]
  char *v7; // [rsp+28h] [rbp-28h]
  unsigned __int64 v8; // [rsp+30h] [rbp-20h]
  char *v9; // [rsp+38h] [rbp-18h]
  unsigned __int64 v10; // [rsp+40h] [rbp-10h]
  const char *v11; // [rsp+48h] [rbp-8h]

  v5 = a3;
  if ( a4 != 1 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unsupported type of known-host information store");
  v7 = a2;
  while ( v5 && (*v7 == 32 || *v7 == 9) )
  {
    ++v7;
    --v5;
  }
  if ( !v5 || !*v7 || *v7 == 35 || *v7 == 10 )
    return 0LL;
  v9 = v7;
  while ( v5 && *v7 && *v7 != 32 && *v7 != 9 )
  {
    ++v7;
    --v5;
  }
  v10 = v7 - v9;
  while ( v5 && *v7 && (*v7 == 32 || *v7 == 9) )
  {
    ++v7;
    --v5;
  }
  if ( !*v7 || !v5 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Failed to parse known_hosts line");
  v11 = v7;
  v8 = v5;
  while ( v5 && *v7 && *v7 != 10 )
  {
    ++v7;
    --v5;
  }
  if ( *v7 == 10 )
    --v8;
  v6 = sub_264AB(a1, v9, v10, v11, v8);
  if ( v6 )
    result = v6;
  else
    result = 0LL;
  return result;
}

//----- (00000000000268C9) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_readfile(__int64 *a1, const char *a2, unsigned int a3)
{
  size_t v4; // rax
  unsigned int v5; // [rsp+Ch] [rbp-834h]
  unsigned int v6; // [rsp+24h] [rbp-81Ch]
  FILE *stream; // [rsp+28h] [rbp-818h]
  char s; // [rsp+30h] [rbp-810h]
  unsigned __int64 v9; // [rsp+838h] [rbp-8h]

  v5 = a3;
  v9 = __readfsqword(0x28u);
  v6 = 0;
  if ( a3 != 1 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unsupported type of known-host information store");
  stream = fopen(a2, "r");
  if ( !stream )
    return sub_FF92(*a1, 0xFFFFFFF0, (__int64)"Failed to open file");
  while ( fgets(&s, 2048, stream) )
  {
    v4 = strlen(&s);
    if ( (unsigned int)libssh2_knownhost_readline(a1, &s, v4, v5) )
      break;
    ++v6;
  }
  fclose(stream);
  return v6;
}
// 5250: using guessed type __int64 __fastcall libssh2_knownhost_readline(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000026A02) ----------------------------------------------------
__int64 __fastcall sub_26A02(__int64 *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6)
{
  size_t v7; // rbx
  size_t v8; // rbx
  size_t v9; // rbx
  size_t v10; // rax
  size_t v11; // rbx
  size_t v12; // rbx
  _QWORD *v13; // [rsp+8h] [rbp-98h]
  unsigned __int64 maxlen; // [rsp+10h] [rbp-90h]
  char *v15; // [rsp+18h] [rbp-88h]
  unsigned int v16; // [rsp+30h] [rbp-70h]
  void *ptr; // [rsp+38h] [rbp-68h]
  char *s; // [rsp+40h] [rbp-60h]
  size_t v19; // [rsp+48h] [rbp-58h]
  size_t v20; // [rsp+50h] [rbp-50h]
  char *v21; // [rsp+58h] [rbp-48h]
  void *v22; // [rsp+60h] [rbp-40h]
  void *v23; // [rsp+68h] [rbp-38h]
  const char *v24; // [rsp+70h] [rbp-30h]
  const char *v25; // [rsp+78h] [rbp-28h]
  unsigned __int64 v26; // [rsp+88h] [rbp-18h]

  v15 = a3;
  maxlen = a4;
  v13 = a5;
  v26 = __readfsqword(0x28u);
  v16 = 0;
  v22 = &unk_2D527;
  v23 = &unk_2D527;
  v24 = " ssh-rsa";
  v25 = " ssh-dss";
  v20 = 0LL;
  if ( a6 != 1 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unsupported type of known-host information store");
  v21 = (char *)*(&v22 + ((*(_DWORD *)(a2 + 44) >> 18) & 3));
  if ( *(_QWORD *)(a2 + 72) )
    v20 = strlen(*(const char **)(a2 + 72)) + 1;
  if ( (unsigned __int16)*(_DWORD *)(a2 + 44) == 2 )
  {
    v19 = sub_104AE(*a1, *(const char **)(a2 + 24), *(_QWORD *)(a2 + 32), (char **)&ptr);
    if ( !v19 )
      return sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for base64-encoded host name");
    v19 = sub_104AE(*a1, *(const char **)(a2 + 48), *(_QWORD *)(a2 + 56), &s);
    if ( !v19 )
    {
      free(ptr);
      return sub_FF92(*a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for base64-encoded salt");
    }
    v7 = strlen(s);
    v8 = strlen((const char *)ptr) + v7;
    v9 = strlen(v21) + v8;
    v10 = strlen(*(const char **)(a2 + 64));
    v19 = v9 + v10 + v20 + 7;
    if ( v19 > maxlen )
    {
      v16 = sub_FF92(*a1, 0xFFFFFFDA, (__int64)"Known-host write buffer too small");
    }
    else if ( *(_QWORD *)(a2 + 72) )
    {
      snprintf(v15, maxlen, "|1|%s|%s%s %s %s\n", s, ptr, v21, *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 72));
    }
    else
    {
      snprintf(v15, maxlen, "|1|%s|%s%s %s\n", s, ptr, v21, *(_QWORD *)(a2 + 64));
    }
    free(ptr);
    free(s);
  }
  else
  {
    v11 = strlen(*(const char **)(a2 + 24));
    v12 = strlen(v21) + v11;
    v19 = v12 + strlen(*(const char **)(a2 + 64)) + v20 + 3;
    if ( v19 > maxlen )
    {
      v16 = sub_FF92(*a1, 0xFFFFFFDA, (__int64)"Known-host write buffer too small");
    }
    else if ( *(_QWORD *)(a2 + 72) )
    {
      snprintf(v15, maxlen, "%s%s %s %s\n", *(_QWORD *)(a2 + 24), v21, *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 72));
    }
    else
    {
      snprintf(v15, maxlen, "%s%s %s\n", *(_QWORD *)(a2 + 24), v21, *(_QWORD *)(a2 + 64));
    }
  }
  *v13 = v19 - 1;
  return v16;
}

//----- (0000000000026E22) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_writeline(__int64 *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6)
{
  __int64 result; // rax

  if ( *(_DWORD *)a2 == -559035650 )
    result = sub_26A02(a1, *(_QWORD *)(a2 + 8), a3, a4, a5, a6);
  else
    result = sub_FF92(*a1, 0xFFFFFFDE, (__int64)"Invalid host information");
  return result;
}

//----- (0000000000026EA0) ----------------------------------------------------
__int64 __fastcall libssh2_knownhost_writefile(__int64 *a1, const char *a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-854h]
  unsigned int v5; // [rsp+2Ch] [rbp-834h]
  size_t n; // [rsp+30h] [rbp-830h]
  __int64 i; // [rsp+38h] [rbp-828h]
  FILE *s; // [rsp+40h] [rbp-820h]
  size_t v9; // [rsp+48h] [rbp-818h]
  char ptr; // [rsp+50h] [rbp-810h]
  unsigned __int64 v11; // [rsp+858h] [rbp-8h]

  v4 = a3;
  v11 = __readfsqword(0x28u);
  v5 = 0;
  if ( a3 != 1 )
    return sub_FF92(*a1, 0xFFFFFFDF, (__int64)"Unsupported type of known-host information store");
  s = fopen(a2, "w");
  if ( !s )
    return sub_FF92(*a1, 0xFFFFFFF0, (__int64)"Failed to open file");
  for ( i = sub_10877((__int64)(a1 + 1)); i; i = sub_10889(i) )
  {
    v5 = sub_26A02(a1, i, &ptr, 0x800uLL, &n, v4);
    if ( v5 )
      break;
    v9 = fwrite(&ptr, 1uLL, n, s);
    if ( v9 != n )
    {
      v5 = sub_FF92(*a1, 0xFFFFFFF0, (__int64)"Write failed");
      break;
    }
  }
  fclose(s);
  return v5;
}

//----- (0000000000027067) ----------------------------------------------------
signed __int64 __fastcall libssh2_knownhost_get(__int64 a1, signed __int64 *a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-10h]

  if ( a3 && *(_QWORD *)(a3 + 8) )
    v4 = sub_10889(*(_QWORD *)(a3 + 8));
  else
    v4 = sub_10877(a1 + 8);
  if ( !v4 )
    return 1LL;
  *a2 = sub_25492(v4);
  return 0LL;
}

//----- (00000000000270EC) ----------------------------------------------------
__int64 __fastcall sub_270EC(__int64 a1)
{
  const char *src; // [rsp+18h] [rbp-88h]
  struct sockaddr addr; // [rsp+20h] [rbp-80h]
  unsigned __int64 v4; // [rsp+98h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  src = getenv("SSH_AUTH_SOCK");
  if ( !src )
    return sub_FF92(*(_QWORD *)a1, 0xFFFFFFD9, (__int64)"no auth sock variable");
  *(_DWORD *)(a1 + 8) = socket(1, 1, 0);
  if ( *(_DWORD *)(a1 + 8) < 0 )
    return sub_FF92(*(_QWORD *)a1, 0xFFFFFFD3, (__int64)"failed creating socket");
  addr.sa_family = 1;
  strncpy(addr.sa_data, src, 0x6CuLL);
  if ( !connect(*(_DWORD *)(a1 + 8), &addr, 0x6Eu) )
    return 0LL;
  close(*(_DWORD *)(a1 + 8));
  return sub_FF92(*(_QWORD *)a1, 0xFFFFFFD6, (__int64)"failed connecting with agent");
}

//----- (000000000002722D) ----------------------------------------------------
signed __int64 __fastcall sub_2722D(unsigned int *a1, __int64 a2)
{
  signed __int64 result; // rax
  int v3; // [rsp+10h] [rbp-10h]
  int v4; // [rsp+10h] [rbp-10h]
  int v5; // [rsp+10h] [rbp-10h]
  int v6; // [rsp+10h] [rbp-10h]
  unsigned int v7; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v8; // [rsp+18h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    sub_1017A(&v7, *(_QWORD *)(a2 + 8));
    v3 = (*(__int64 (__fastcall **)(_QWORD, unsigned int *, signed __int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 72LL))(
           a1[2],
           &v7,
           4LL,
           0LL,
           *(_QWORD *)a1);
    if ( v3 == -11 )
      return 4294967259LL;
    if ( v3 < 0 )
      return sub_FF92(*(_QWORD *)a1, 0xFFFFFFF9, (__int64)"agent send failed");
    *(_DWORD *)(a2 + 32) = 2;
  }
  if ( *(_DWORD *)(a2 + 32) == 2 )
  {
    v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 72LL))(
           a1[2],
           *(_QWORD *)a2,
           *(_QWORD *)(a2 + 8),
           0LL,
           *(_QWORD *)a1);
    if ( v4 == -11 )
      return 4294967259LL;
    if ( v4 < 0 )
      return sub_FF92(*(_QWORD *)a1, 0xFFFFFFF9, (__int64)"agent send failed");
    *(_DWORD *)(a2 + 32) = 3;
  }
  if ( *(_DWORD *)(a2 + 32) == 3 )
  {
    v5 = (*(__int64 (__fastcall **)(_QWORD, unsigned int *, signed __int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 80LL))(
           a1[2],
           &v7,
           4LL,
           0LL,
           *(_QWORD *)a1);
    if ( v5 < 0 )
    {
      if ( v5 == -11 )
        result = 4294967259LL;
      else
        result = sub_FF92(*(_QWORD *)a1, 0xFFFFFFD5, (__int64)"agent recv failed");
      return result;
    }
    *(_QWORD *)(a2 + 24) = (unsigned int)sub_10071(&v7);
    *(_QWORD *)(a2 + 16) = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)a1 + 8LL))(
                             *(_QWORD *)(a2 + 24),
                             *(_QWORD *)a1);
    if ( !*(_QWORD *)(a2 + 16) )
      return 4294967290LL;
    *(_DWORD *)(a2 + 32) = 4;
  }
  if ( *(_DWORD *)(a2 + 32) != 4 )
    return 0LL;
  v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 80LL))(
         a1[2],
         *(_QWORD *)(a2 + 16),
         *(_QWORD *)(a2 + 24),
         0LL,
         *(_QWORD *)a1);
  if ( v6 >= 0 )
  {
    *(_DWORD *)(a2 + 32) = 5;
    return 0LL;
  }
  if ( v6 == -11 )
    result = 4294967259LL;
  else
    result = sub_FF92(*(_QWORD *)a1, 0xFFFFFFF9, (__int64)"agent recv failed");
  return result;
}

//----- (00000000000274E1) ----------------------------------------------------
__int64 __fastcall sub_274E1(__int64 a1)
{
  __int64 result; // rax

  if ( close(*(_DWORD *)(a1 + 8)) == -1 )
    result = sub_FF92(*(_QWORD *)a1, 0xFFFFFFF3, (__int64)"failed closing the agent socket");
  else
    result = 0LL;
  return result;
}

//----- (0000000000027528) ----------------------------------------------------
__int64 __fastcall sub_27528(__int64 a1, void **a2, size_t *a3, const void *a4, size_t a5, __int64 *a6)
{
  _BYTE *v7; // rax
  size_t v8; // [rsp+8h] [rbp-68h]
  const void *v9; // [rsp+10h] [rbp-60h]
  size_t *v10; // [rsp+18h] [rbp-58h]
  unsigned int v11; // [rsp+34h] [rbp-3Ch]
  void *src; // [rsp+38h] [rbp-38h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  void **v14; // [rsp+48h] [rbp-28h]
  __int64 v15; // [rsp+50h] [rbp-20h]
  char *v16; // [rsp+58h] [rbp-18h]
  __int64 v17; // [rsp+60h] [rbp-10h]
  unsigned __int64 v18; // [rsp+68h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v18 = __readfsqword(0x28u);
  v13 = *a6;
  v14 = (void **)(v13 + 24);
  v15 = *(_QWORD *)(v13 + 64);
  v16 = (char *)(*(_QWORD *)(v15 + 48) + a5 + 13);
  if ( !*(_DWORD *)(v13 + 56) )
  {
    *v14 = (void *)(*(__int64 (__fastcall **)(char *, __int64))(a1 + 8))(v16, a1);
    src = *v14;
    if ( !*v14 )
      return sub_FF92(a1, 0xFFFFFFFA, (__int64)"out of memory");
    v7 = src;
    src = (char *)src + 1;
    *v7 = 13;
    sub_101FF(&src, *(const void **)(v15 + 40), *(_QWORD *)(v15 + 48));
    sub_101FF(&src, v9, v8);
    sub_101C7((_BYTE **)&src, 0);
    v14[1] = (void *)((_BYTE *)src - (_BYTE *)*v14);
    *((_DWORD *)v14 + 8) = 1;
  }
  if ( *(_BYTE *)*v14 != 13 )
    return sub_FF92(a1, 0xFFFFFFD9, (__int64)"illegal request");
  if ( !*(_QWORD *)(v13 + 16) )
    return sub_FF92(a1, 0xFFFFFFD9, (__int64)"agent not connected");
  v11 = (*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)(v13 + 16) + 8LL))(v13, v14);
  if ( !v11 )
  {
    (*(void (__fastcall **)(void *, __int64))(a1 + 24))(*v14, a1);
    *v14 = 0LL;
    v16 = (char *)v14[3];
    src = v14[2];
    if ( (signed __int64)--v16 >= 0 )
    {
      if ( *(_BYTE *)src == 14 )
      {
        src = (char *)src + 1;
        v16 -= 4;
        if ( (signed __int64)v16 >= 0 )
        {
          src = (char *)src + 4;
          v16 -= 4;
          if ( (signed __int64)v16 >= 0 )
          {
            v17 = (unsigned int)sub_10071((unsigned int *)src);
            src = (char *)src + 4;
            v16 -= v17;
            if ( (signed __int64)v16 >= 0 )
            {
              src = (char *)src + v17;
              v16 -= 4;
              if ( (signed __int64)v16 >= 0 )
              {
                *v10 = (unsigned int)sub_10071((unsigned int *)src);
                src = (char *)src + 4;
                v16 -= *v10;
                if ( (signed __int64)v16 >= 0 )
                {
                  *a2 = (void *)(*(__int64 (__fastcall **)(size_t, __int64))(a1 + 8))(*v10, a1);
                  if ( *a2 )
                    memcpy(*a2, src, *v10);
                  else
                    v11 = -6;
                }
                else
                {
                  v11 = -42;
                }
              }
              else
              {
                v11 = -42;
              }
            }
            else
            {
              v11 = -42;
            }
          }
          else
          {
            v11 = -42;
          }
        }
        else
        {
          v11 = -42;
        }
      }
      else
      {
        v11 = -42;
      }
    }
    else
    {
      v11 = -42;
    }
  }
  (*(void (__fastcall **)(void *, __int64))(a1 + 24))(*v14, a1);
  *v14 = 0LL;
  (*(void (__fastcall **)(void *, __int64))(a1 + 24))(v14[2], a1);
  v14[2] = 0LL;
  return sub_FF92(a1, v11, (__int64)"agent sign failure");
}

//----- (0000000000027925) ----------------------------------------------------
__int64 __fastcall sub_27925(_QWORD *a1)
{
  unsigned int v2; // eax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  char v6; // [rsp+13h] [rbp-3Dh]
  unsigned int v7; // [rsp+14h] [rbp-3Ch]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+20h] [rbp-30h]
  void *src; // [rsp+28h] [rbp-28h]
  _QWORD *v11; // [rsp+30h] [rbp-20h]
  __int64 v12; // [rsp+38h] [rbp-18h]
  size_t n; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  v11 = a1 + 3;
  v6 = 11;
  if ( !*((_DWORD *)a1 + 14) )
  {
    *v11 = &v6;
    v11[1] = 1LL;
    *((_DWORD *)v11 + 8) = 1;
  }
  if ( *(_BYTE *)*v11 != 11 )
    return sub_FF92(*a1, 0xFFFFFFD9, (__int64)"illegal agent request");
  if ( !a1[2] )
    return sub_FF92(*a1, 0xFFFFFFD9, (__int64)"agent not connected");
  v7 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD *))(a1[2] + 8LL))(a1, v11);
  if ( !v7 )
  {
    *v11 = 0LL;
    v8 = v11[3];
    src = (void *)v11[2];
    if ( --v8 >= 0 )
    {
      if ( *(_BYTE *)src == 12 )
      {
        src = (char *)src + 1;
        v8 -= 4LL;
        if ( v8 >= 0 )
        {
          v9 = (unsigned int)sub_10071((unsigned int *)src);
          src = (char *)src + 4;
          while ( 1 )
          {
            v5 = v9--;
            if ( !v5 )
              break;
            v12 = (*(__int64 (__fastcall **)(signed __int64, _QWORD))(*a1 + 8LL))(64LL, *a1);
            if ( !v12 )
            {
              v7 = -6;
              break;
            }
            v8 -= 4LL;
            if ( v8 < 0 )
            {
              v7 = -42;
              break;
            }
            v2 = sub_10071((unsigned int *)src);
            *(_QWORD *)(v12 + 48) = v2;
            src = (char *)src + 4;
            v8 -= *(_QWORD *)(v12 + 48);
            if ( v8 < 0 )
            {
              v7 = -42;
              break;
            }
            v3 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(*a1 + 8LL))(*(_QWORD *)(v12 + 48), *a1);
            *(_QWORD *)(v12 + 40) = v3;
            if ( !*(_QWORD *)(v12 + 40) )
            {
              v7 = -6;
              break;
            }
            memcpy(*(void **)(v12 + 40), src, *(_QWORD *)(v12 + 48));
            src = (char *)src + *(_QWORD *)(v12 + 48);
            v8 -= 4LL;
            if ( v8 < 0 )
            {
              v7 = -42;
              break;
            }
            n = (unsigned int)sub_10071((unsigned int *)src);
            src = (char *)src + 4;
            v8 -= n;
            if ( v8 < 0 )
            {
              v7 = -42;
              break;
            }
            v4 = (*(__int64 (__fastcall **)(size_t, _QWORD))(*a1 + 8LL))(n + 1, *a1);
            *(_QWORD *)(v12 + 56) = v4;
            if ( !*(_QWORD *)(v12 + 56) )
            {
              v7 = -6;
              break;
            }
            *(_BYTE *)(*(_QWORD *)(v12 + 56) + n) = 0;
            memcpy(*(void **)(v12 + 56), src, n);
            src = (char *)src + n;
            sub_1080D(a1 + 9, (_QWORD *)v12);
          }
        }
        else
        {
          v7 = -42;
        }
      }
      else
      {
        v7 = -42;
      }
    }
    else
    {
      v7 = -42;
    }
  }
  (*(void (__fastcall **)(_QWORD, _QWORD))(*a1 + 24LL))(v11[2], *a1);
  v11[2] = 0LL;
  return sub_FF92(*a1, v7, (__int64)"agent list id failed");
}

//----- (0000000000027CE5) ----------------------------------------------------
_QWORD *__fastcall sub_27CE5(_QWORD *a1)
{
  __int64 v1; // ST18_8
  __int64 i; // [rsp+10h] [rbp-10h]

  for ( i = sub_10877((__int64)(a1 + 9)); i; i = v1 )
  {
    v1 = sub_10889(i);
    (*(void (__fastcall **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(i + 40), *a1);
    (*(void (__fastcall **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(i + 56), *a1);
    (*(void (__fastcall **)(__int64, _QWORD))(*a1 + 24LL))(i, *a1);
  }
  return sub_107E8(a1 + 9);
}

//----- (0000000000027DAB) ----------------------------------------------------
signed __int64 __fastcall sub_27DAB(__int64 a1)
{
  *(_DWORD *)(a1 + 24) = 1004469970;
  *(_QWORD *)(a1 + 32) = a1;
  return a1 + 24;
}

//----- (0000000000027DDB) ----------------------------------------------------
__int64 *__fastcall libssh2_agent_init(__int64 a1)
{
  __int64 *result; // rax
  __int64 *s; // [rsp+18h] [rbp-8h]

  s = (__int64 *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(88LL, a1);
  if ( s )
  {
    memset(s, 0, 0x58uLL);
    *s = a1;
    sub_107E8(s + 9);
    result = s;
  }
  else
  {
    sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate space for agent connection");
    result = 0LL;
  }
  return result;
}

//----- (0000000000027E5E) ----------------------------------------------------
__int64 __fastcall libssh2_agent_connect(__int64 a1)
{
  int i; // [rsp+18h] [rbp-8h]
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v3 = -1;
  for ( i = 0; (&off_232540)[2 * i]; ++i )
  {
    *(_QWORD *)(a1 + 16) = *(&off_232548 + 2 * i);
    v3 = (**(__int64 (__fastcall ***)(__int64))(a1 + 16))(a1);
    if ( !v3 )
      return 0LL;
  }
  return v3;
}
// 232540: using guessed type char *off_232540;
// 232548: using guessed type __int64 (__fastcall *(*off_232548)[3])();

//----- (0000000000027EE2) ----------------------------------------------------
__int64 __fastcall libssh2_agent_list_identities(_QWORD *a1)
{
  memset(a1 + 3, 0, 0x28uLL);
  sub_27CE5(a1);
  return sub_27925(a1);
}

//----- (0000000000027F22) ----------------------------------------------------
signed __int64 __fastcall libssh2_agent_get_identity(__int64 a1, signed __int64 *a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-10h]

  if ( a3 && *(_QWORD *)(a3 + 8) )
    v4 = sub_10889(*(_QWORD *)(a3 + 8));
  else
    v4 = sub_10877(a1 + 72);
  if ( !v4 )
    return 1LL;
  *a2 = sub_27DAB(v4);
  return 0LL;
}

//----- (0000000000027FA7) ----------------------------------------------------
__int64 __fastcall libssh2_agent_userauth(size_t *a1, const char *a2, _QWORD *a3)
{
  unsigned __int64 v3; // r12
  unsigned int *v4; // rbx
  unsigned int v5; // eax
  _QWORD *v7; // [rsp+8h] [rbp-48h]
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  size_t *v9; // [rsp+28h] [rbp-28h]
  time_t v10; // [rsp+30h] [rbp-20h]
  unsigned __int64 v11; // [rsp+38h] [rbp-18h]

  v7 = a3;
  v11 = __readfsqword(0x28u);
  v9 = a1;
  if ( !*(_DWORD *)(*a1 + 53224) )
  {
    memset(a1 + 3, 0, 0x28uLL);
    a1[8] = v7[1];
  }
  v10 = time(0LL);
  do
  {
    v3 = v7[3];
    v4 = (unsigned int *)v7[2];
    v5 = strlen(a2);
    v8 = sub_221CD(
           *a1,
           a2,
           v5,
           v4,
           v3,
           (__int64 (__fastcall *)(size_t, const void **, size_t *, void *, signed __int64, __int64))sub_27528,
           (__int64)&v9);
    if ( v8 != -37 )
      break;
    if ( !*(_DWORD *)(*a1 + 148) )
      break;
    v8 = sub_179AF(*a1, v10);
  }
  while ( !v8 );
  return v8;
}

//----- (00000000000280C8) ----------------------------------------------------
__int64 __fastcall libssh2_agent_disconnect(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 16) && *(_DWORD *)(a1 + 8) != -1 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16LL))(a1);
  else
    result = 0LL;
  return result;
}

//----- (000000000002810B) ----------------------------------------------------
__int64 __fastcall libssh2_agent_free(_QWORD *a1)
{
  if ( *((_DWORD *)a1 + 2) != -1 )
    libssh2_agent_disconnect(a1);
  sub_27CE5(a1);
  return (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*a1 + 24LL))(a1, *a1);
}
// 4BB0: using guessed type __int64 __fastcall libssh2_agent_disconnect(_QWORD);

//----- (000000000002815F) ----------------------------------------------------
__int64 __fastcall sub_2815F(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, unsigned int a13, __int64 a14, unsigned int a15, __int64 a16, unsigned int a17)
{
  unsigned int v17; // ST18_4
  __int64 v18; // rbx
  __int64 v19; // rbx
  __int64 v20; // rbx
  __int64 v21; // rbx
  __int64 v22; // rbx
  __int64 v23; // rbx
  __int64 v24; // rbx
  __int64 v25; // rbx
  __int64 v27; // [rsp+0h] [rbp-40h]
  unsigned int v28; // [rsp+8h] [rbp-38h]
  __int64 v29; // [rsp+10h] [rbp-30h]

  v17 = a3;
  v29 = a4;
  v28 = a5;
  v27 = a6;
  *a1 = RSA_new();
  v18 = *a1;
  *(_QWORD *)(v18 + 40) = BN_new(a1, a2);
  BN_bin2bn(a2, v17, *(_QWORD *)(*a1 + 40));
  v19 = *a1;
  *(_QWORD *)(v19 + 32) = BN_new(a2, v17);
  BN_bin2bn(v29, v28, *(_QWORD *)(*a1 + 32));
  if ( v27 )
  {
    v20 = *a1;
    *(_QWORD *)(v20 + 48) = BN_new(v29, v28);
    BN_bin2bn(v27, (unsigned int)a7, *(_QWORD *)(*a1 + 48));
    v21 = *a1;
    *(_QWORD *)(v21 + 56) = BN_new(v27, (unsigned int)a7);
    BN_bin2bn(a8, (unsigned int)a9, *(_QWORD *)(*a1 + 56));
    v22 = *a1;
    *(_QWORD *)(v22 + 64) = BN_new(a8, (unsigned int)a9);
    BN_bin2bn(a10, (unsigned int)a11, *(_QWORD *)(*a1 + 64));
    v23 = *a1;
    *(_QWORD *)(v23 + 72) = BN_new(a10, (unsigned int)a11);
    BN_bin2bn(a12, a13, *(_QWORD *)(*a1 + 72));
    v24 = *a1;
    *(_QWORD *)(v24 + 80) = BN_new(a12, a13);
    BN_bin2bn(a14, a15, *(_QWORD *)(*a1 + 80));
    v25 = *a1;
    *(_QWORD *)(v25 + 88) = BN_new(a14, a15);
    BN_bin2bn(a16, a17, *(_QWORD *)(*a1 + 88));
  }
  return 0LL;
}
// 4C80: using guessed type __int64 RSA_new(void);
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);

//----- (000000000002831E) ----------------------------------------------------
signed __int64 __fastcall sub_2831E(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  unsigned int v5; // ST18_4
  signed __int64 result; // rax
  char v7; // [rsp+40h] [rbp-20h]
  unsigned __int64 v8; // [rsp+58h] [rbp-8h]

  v5 = a3;
  v8 = __readfsqword(0x28u);
  libssh2_sha1(a4, a5, &v7);
  if ( (unsigned int)RSA_verify(64LL, &v7, 20LL, a2, v5, a1) == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 4D90: using guessed type __int64 __fastcall libssh2_sha1(_QWORD, _QWORD, _QWORD);
// 51F0: using guessed type __int64 __fastcall RSA_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000283B8) ----------------------------------------------------
__int64 __fastcall sub_283B8(__int64 *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, __int64 a8, unsigned int a9, __int64 a10, __int64 a11)
{
  unsigned int v11; // ST18_4
  __int64 v12; // ST10_8
  unsigned int v13; // ST08_4
  __int64 v14; // ST00_8
  __int64 v15; // rbx
  __int64 v16; // rbx
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int64 v19; // rbx

  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  *a1 = DSA_new();
  v15 = *a1;
  *(_QWORD *)(v15 + 24) = ((__int64 (*)(void))BN_new)();
  BN_bin2bn(a2, v11, *(_QWORD *)(*a1 + 24));
  v16 = *a1;
  *(_QWORD *)(v16 + 32) = BN_new(a2, v11);
  BN_bin2bn(v12, v13, *(_QWORD *)(*a1 + 32));
  v17 = *a1;
  *(_QWORD *)(v17 + 40) = BN_new(v12, v13);
  BN_bin2bn(v14, a7, *(_QWORD *)(*a1 + 40));
  v18 = *a1;
  *(_QWORD *)(v18 + 48) = BN_new(v14, a7);
  BN_bin2bn(a8, a9, *(_QWORD *)(*a1 + 48));
  if ( a11 )
  {
    v19 = *a1;
    *(_QWORD *)(v19 + 56) = BN_new(a8, a9);
    BN_bin2bn(a10, (unsigned int)a11, *(_QWORD *)(*a1 + 56));
  }
  return 0LL;
}
// 4B30: using guessed type __int64 DSA_new(void);
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);

//----- (00000000000284E6) ----------------------------------------------------
signed __int64 __fastcall sub_284E6(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST08_8
  __int64 v5; // ST00_8
  int v6; // ST2C_4
  signed __int64 result; // rax
  __int64 v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  char v10; // [rsp+40h] [rbp-20h]
  unsigned __int64 v11; // [rsp+58h] [rbp-8h]

  v4 = a3;
  v5 = a4;
  v11 = __readfsqword(0x28u);
  v8 = BN_new(a1, a2);
  BN_bin2bn(a2, 20LL, v8);
  v9 = BN_new(a2, 20LL);
  BN_bin2bn(a2 + 20, 20LL, v9);
  libssh2_sha1(v4, v5, &v10);
  v6 = DSA_do_verify(&v10, 20LL, &v8, a1);
  BN_clear_free(v9);
  BN_clear_free(v8);
  if ( v6 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 4BE0: using guessed type __int64 __fastcall DSA_do_verify(_QWORD, _QWORD, _QWORD, _QWORD);
// 4CF0: using guessed type __int64 __fastcall BN_new(_QWORD, _QWORD);
// 4D90: using guessed type __int64 __fastcall libssh2_sha1(_QWORD, _QWORD, _QWORD);
// 50A0: using guessed type __int64 __fastcall BN_clear_free(_QWORD);
// 5210: using guessed type __int64 __fastcall BN_bin2bn(_QWORD, _QWORD, _QWORD);

//----- (00000000000285C3) ----------------------------------------------------
__int64 __fastcall sub_285C3(__int64 a1, __int64 (*a2)(void), __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // ST18_8
  __int64 v6; // ST10_8
  unsigned int v7; // ST0C_4
  __int64 v8; // rax

  v5 = a3;
  v6 = a4;
  v7 = a5;
  EVP_CIPHER_CTX_init(a1);
  v8 = a2();
  EVP_CipherInit(a1, v8, v6, v5, v7);
  return 0LL;
}
// 4C10: using guessed type __int64 __fastcall EVP_CIPHER_CTX_init(_QWORD);
// 4CD0: using guessed type __int64 __fastcall EVP_CipherInit(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028618) ----------------------------------------------------
_BOOL8 __fastcall sub_28618(__int64 a1, __int64 a2, __int64 a3, void *a4)
{
  void *dest; // [rsp+0h] [rbp-60h]
  signed int v6; // [rsp+28h] [rbp-38h]
  int v7; // [rsp+2Ch] [rbp-34h]
  char src; // [rsp+30h] [rbp-30h]
  unsigned __int64 v9; // [rsp+58h] [rbp-8h]

  dest = a4;
  v9 = __readfsqword(0x28u);
  v6 = *(_DWORD *)(*(_QWORD *)a1 + 4LL);
  if ( v6 == 1 )
    v6 = 8;
  v7 = EVP_Cipher(a1, &src, a4, (unsigned int)v6);
  if ( v7 == 1 )
    memcpy(dest, &src, v6);
  return v7 != 1;
}
// 5080: using guessed type __int64 __fastcall EVP_Cipher(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000286B1) ----------------------------------------------------
signed __int64 __fastcall sub_286B1(__int64 a1, __int64 a2, _QWORD *a3)
{
  int v4; // eax
  _QWORD *v5; // rcx
  __int64 v6; // rdx
  _QWORD *v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+20h] [rbp-10h]
  _QWORD *v9; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v9 = malloc(0x110uLL);
  if ( !v9 )
    return 0LL;
  v4 = *(_DWORD *)(a1 + 104);
  switch ( v4 )
  {
    case 24:
      v8 = EVP_aes_192_ecb(272LL);
      break;
    case 32:
      v8 = EVP_aes_256_ecb(272LL);
      break;
    case 16:
      v8 = EVP_aes_128_ecb(272LL);
      break;
    default:
      return 0LL;
  }
  v9[31] = malloc(0xA8uLL);
  if ( !v9[31] )
    return 0LL;
  if ( (unsigned int)EVP_EncryptInit(v9[31], v8, a2, 0LL) != 1 )
    return 0LL;
  EVP_CIPHER_CTX_set_padding(v9[31], 0LL);
  v5 = v9 + 32;
  v6 = v7[1];
  *v5 = *v7;
  v5[1] = v6;
  EVP_CIPHER_CTX_set_app_data(a1, v9);
  return 1LL;
}
// 4B50: using guessed type __int64 __fastcall EVP_aes_128_ecb(_QWORD);
// 4E20: using guessed type __int64 __fastcall EVP_EncryptInit(_QWORD, _QWORD, _QWORD, _QWORD);
// 5010: using guessed type __int64 __fastcall EVP_aes_256_ecb(_QWORD);
// 5090: using guessed type __int64 __fastcall EVP_CIPHER_CTX_set_padding(_QWORD, _QWORD);
// 50E0: using guessed type __int64 __fastcall EVP_CIPHER_CTX_set_app_data(_QWORD, _QWORD);
// 5220: using guessed type __int64 __fastcall EVP_aes_192_ecb(_QWORD);

//----- (00000000000287D2) ----------------------------------------------------
signed __int64 __fastcall sub_287D2(__int64 a1, _BYTE *a2, char *a3, __int64 a4)
{
  __int64 v4; // ST00_8
  char *v6; // rax
  char v7; // si
  _BYTE *v8; // rax
  char v9; // al
  char *v10; // [rsp+8h] [rbp-58h]
  _BYTE *v11; // [rsp+10h] [rbp-50h]
  int v12; // [rsp+2Ch] [rbp-34h]
  unsigned __int64 i; // [rsp+30h] [rbp-30h]
  __int64 v14; // [rsp+38h] [rbp-28h]
  char v15[24]; // [rsp+40h] [rbp-20h]
  unsigned __int64 v16; // [rsp+58h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  v4 = a4;
  v16 = __readfsqword(0x28u);
  v14 = EVP_CIPHER_CTX_get_app_data(a1);
  i = 0LL;
  v12 = 0;
  if ( v4 != 16 )
    return 0LL;
  if ( !v14 )
    return 0LL;
  if ( (unsigned int)EVP_EncryptUpdate(*(_QWORD *)(v14 + 248), v15, &v12, v14 + 256, 16LL) != 1 )
    return 0LL;
  for ( i = 0LL; i <= 0xF; ++i )
  {
    v6 = v10++;
    v7 = *v6;
    v8 = v11++;
    *v8 = v15[i] ^ v7;
  }
  for ( i = 15LL; ; --i )
  {
    v9 = *(_BYTE *)(v14 + i + 256);
    *(_BYTE *)(v14 + i + 256) = v9 + 1;
    if ( v9 != -1 || !i )
      break;
  }
  return 1LL;
}
// 4CE0: using guessed type __int64 __fastcall EVP_CIPHER_CTX_get_app_data(_QWORD);
// 4EA0: using guessed type __int64 __fastcall EVP_EncryptUpdate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 287D2: using guessed type char var_20[24];

//----- (000000000002891D) ----------------------------------------------------
signed __int64 __fastcall sub_2891D(__int64 a1)
{
  void **ptr; // [rsp+18h] [rbp-8h]

  ptr = (void **)EVP_CIPHER_CTX_get_app_data(a1);
  if ( !ptr )
    return 1LL;
  if ( ptr[31] )
  {
    EVP_CIPHER_CTX_cleanup(ptr[31]);
    free(ptr[31]);
  }
  free(ptr);
  return 1LL;
}
// 4CE0: using guessed type __int64 __fastcall EVP_CIPHER_CTX_get_app_data(_QWORD);
// 5160: using guessed type __int64 __fastcall EVP_CIPHER_CTX_cleanup(_QWORD);

//----- (0000000000028990) ----------------------------------------------------
__int64 __fastcall sub_28990(int a1, __int64 a2)
{
  *(_DWORD *)(a2 + 4) = 16;
  *(_DWORD *)(a2 + 8) = a1;
  *(_DWORD *)(a2 + 12) = 16;
  *(_QWORD *)(a2 + 24) = sub_286B1;
  *(_QWORD *)(a2 + 32) = sub_287D2;
  *(_QWORD *)(a2 + 40) = sub_2891D;
  return a2;
}

//----- (00000000000289F2) ----------------------------------------------------
void *sub_289F2()
{
  void *result; // rax

  if ( dword_232588 )
    result = &unk_232580;
  else
    result = (void *)sub_28990(16, (__int64)&unk_232580);
  return result;
}
// 232588: using guessed type int dword_232588;

//----- (0000000000028A1C) ----------------------------------------------------
void *sub_28A1C()
{
  void *result; // rax

  if ( dword_2325E8 )
    result = &unk_2325E0;
  else
    result = (void *)sub_28990(24, (__int64)&unk_2325E0);
  return result;
}
// 2325E8: using guessed type int dword_2325E8;

//----- (0000000000028A46) ----------------------------------------------------
void *sub_28A46()
{
  void *result; // rax

  if ( dword_232648 )
    result = &unk_232640;
  else
    result = (void *)sub_28990(32, (__int64)&unk_232640);
  return result;
}
// 232648: using guessed type int dword_232648;

//----- (0000000000028A70) ----------------------------------------------------
void *sub_28A70()
{
  sub_289F2();
  sub_28A1C();
  return sub_28A46();
}

//----- (0000000000028A86) ----------------------------------------------------
__int64 __fastcall sub_28A86(void *a1, int a2, __int64 a3, const char *a4)
{
  char *s; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+2Ch] [rbp-4h]

  s = (char *)a4;
  v6 = strlen(a4);
  if ( v6 > a2 - 1 )
    v6 = a2 - 1;
  memcpy(a1, s, v6);
  *((_BYTE *)a1 + v6) = 0;
  return (unsigned int)v6;
}

//----- (0000000000028AED) ----------------------------------------------------
signed __int64 __fastcall sub_28AED(_QWORD *a1, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD, __int64), __int64 a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-30h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a4;
  *a1 = 0LL;
  v6 = BIO_new_file(a3, "r");
  if ( !v6 )
    return 0xFFFFFFFFLL;
  *a1 = a2(v6, 0LL, sub_28A86, v5);
  BIO_free(v6);
  if ( *a1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 4FD0: using guessed type __int64 __fastcall BIO_free(_QWORD);
// 4FE0: using guessed type __int64 __fastcall BIO_new_file(_QWORD, _QWORD);

//----- (0000000000028B82) ----------------------------------------------------
signed __int64 __fastcall sub_28B82(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST08_8
  __int64 v5; // ST00_8

  v4 = a3;
  v5 = a4;
  sub_29922();
  return sub_28AED(a1, (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_RSAPrivateKey, v4, v5);
}

//----- (0000000000028BC4) ----------------------------------------------------
signed __int64 __fastcall sub_28BC4(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST08_8
  __int64 v5; // ST00_8

  v4 = a3;
  v5 = a4;
  sub_29922();
  return sub_28AED(a1, (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_DSAPrivateKey, v4, v5);
}

//----- (0000000000028C06) ----------------------------------------------------
signed __int64 __fastcall sub_28C06(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5, _QWORD *a6)
{
  signed __int64 result; // rax
  _QWORD *v7; // [rsp+0h] [rbp-50h]
  _QWORD *v8; // [rsp+8h] [rbp-48h]
  unsigned int v9; // [rsp+10h] [rbp-40h]
  __int64 v10; // [rsp+18h] [rbp-38h]
  unsigned int v11; // [rsp+38h] [rbp-18h]
  int v12; // [rsp+3Ch] [rbp-14h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v14 = __readfsqword(0x28u);
  v11 = RSA_size(a2);
  v13 = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v11, a1);
  if ( !v13 )
    return 0xFFFFFFFFLL;
  v12 = RSA_sign(64LL, v10, v9, v13, &v11, a2);
  if ( v12 )
  {
    *v8 = v13;
    *v7 = v11;
    result = 0LL;
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64))(a1 + 24))(v13, a1);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 4F10: using guessed type __int64 __fastcall RSA_size(_QWORD);
// 5150: using guessed type __int64 __fastcall RSA_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028CF7) ----------------------------------------------------
signed __int64 __fastcall sub_28CF7(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  signed __int64 result; // rax
  char *s; // [rsp+0h] [rbp-30h]
  int v6; // [rsp+20h] [rbp-10h]
  int v7; // [rsp+24h] [rbp-Ch]
  _QWORD *v8; // [rsp+28h] [rbp-8h]

  s = a4;
  v8 = (_QWORD *)DSA_do_sign(a2, 20LL, a1);
  if ( !v8 )
    return 0xFFFFFFFFLL;
  v6 = (signed int)((unsigned __int64)BN_num_bits(*v8) + 7) / 8;
  if ( v6 > 0 && v6 <= 20 )
  {
    v7 = (signed int)((unsigned __int64)BN_num_bits(v8[1]) + 7) / 8;
    if ( v7 > 0 && v7 <= 20 )
    {
      memset(s, 0, 0x28uLL);
      BN_bn2bin(*v8, &s[20 - v6]);
      BN_bn2bin(v8[1], &s[20 - v7 + 20]);
      DSA_SIG_free(v8);
      result = 0LL;
    }
    else
    {
      DSA_SIG_free(v8);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    DSA_SIG_free(v8);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 4D10: using guessed type __int64 __fastcall DSA_do_sign(_QWORD, _QWORD, _QWORD);
// 4E30: using guessed type __int64 __fastcall BN_bn2bin(_QWORD, _QWORD);
// 4FA0: using guessed type __int64 __fastcall DSA_SIG_free(_QWORD);
// 5140: using guessed type __int64 __fastcall BN_num_bits(_QWORD);

//----- (0000000000028E30) ----------------------------------------------------
unsigned __int64 __fastcall libssh2_sha1(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // ST08_8
  __int64 v4; // rax
  char v6; // [rsp+20h] [rbp-40h]
  unsigned __int64 v7; // [rsp+58h] [rbp-8h]

  v3 = a3;
  v7 = __readfsqword(0x28u);
  v4 = EVP_get_digestbyname("sha1");
  EVP_DigestInit(&v6, v4);
  EVP_DigestUpdate(&v6, a1, a2);
  EVP_DigestFinal(&v6, v3, 0LL);
  return __readfsqword(0x28u) ^ v7;
}
// 4E70: using guessed type __int64 __fastcall EVP_get_digestbyname(_QWORD);
// 4EC0: using guessed type __int64 __fastcall EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 4F20: using guessed type __int64 __fastcall EVP_DigestInit(_QWORD, _QWORD);
// 5270: using guessed type __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);

//----- (0000000000028EB7) ----------------------------------------------------
unsigned __int64 __fastcall libssh2_md5(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // ST08_8
  __int64 v4; // rax
  char v6; // [rsp+20h] [rbp-40h]
  unsigned __int64 v7; // [rsp+58h] [rbp-8h]

  v3 = a3;
  v7 = __readfsqword(0x28u);
  v4 = EVP_get_digestbyname("md5");
  EVP_DigestInit(&v6, v4);
  EVP_DigestUpdate(&v6, a1, a2);
  EVP_DigestFinal(&v6, v3, 0LL);
  return __readfsqword(0x28u) ^ v7;
}
// 4E70: using guessed type __int64 __fastcall EVP_get_digestbyname(_QWORD);
// 4EC0: using guessed type __int64 __fastcall EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 4F20: using guessed type __int64 __fastcall EVP_DigestInit(_QWORD, _QWORD);
// 5270: using guessed type __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);

//----- (0000000000028F3E) ----------------------------------------------------
signed __int64 __fastcall sub_28F3E(_BYTE *a1, __int64 a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]

  v4 = a3;
  a1[4] = 0;
  BN_bn2bin(a2, a1 + 5);
  if ( a1[5] >= 0 )
    memmove(a1 + 4, a1 + 5, --v4);
  sub_1017A(a1, v4);
  return (signed __int64)&a1[v4 + 4];
}
// 4E30: using guessed type __int64 __fastcall BN_bn2bin(_QWORD, _QWORD);

//----- (0000000000028FD0) ----------------------------------------------------
_BYTE *__fastcall sub_28FD0(__int64 a1, __int64 a2, _QWORD *a3)
{
  _BYTE *v4; // rax
  _QWORD *v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+20h] [rbp-20h]
  int v7; // [rsp+24h] [rbp-1Ch]
  _BYTE *v8; // [rsp+30h] [rbp-10h]

  v5 = a3;
  v6 = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a2 + 40)) + 7) / 8 + 1;
  v7 = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a2 + 32)) + 7) / 8 + 1;
  v8 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v6 + 19 + v7, a1);
  if ( !v8 )
    return 0LL;
  sub_1017A(v8, 7);
  memcpy(v8 + 4, "ssh-rsa", 7uLL);
  v4 = (_BYTE *)sub_28F3E(v8 + 11, *(_QWORD *)(a2 + 40), v6);
  *v5 = sub_28F3E(v4, *(_QWORD *)(a2 + 32), v7) - (_QWORD)v8;
  return v8;
}
// 5140: using guessed type __int64 __fastcall BN_num_bits(_QWORD);

//----- (00000000000290FF) ----------------------------------------------------
_BYTE *__fastcall sub_290FF(__int64 a1, __int64 *a2, _QWORD *a3)
{
  _BYTE *v4; // rax
  _BYTE *v5; // rax
  _BYTE *v6; // rax
  _QWORD *v7; // [rsp+8h] [rbp-48h]
  int v8; // [rsp+28h] [rbp-28h]
  int v9; // [rsp+2Ch] [rbp-24h]
  int v10; // [rsp+30h] [rbp-20h]
  int v11; // [rsp+34h] [rbp-1Ch]
  _BYTE *v12; // [rsp+40h] [rbp-10h]

  v7 = a3;
  v8 = (signed int)((unsigned __int64)BN_num_bits(a2[3]) + 7) / 8 + 1;
  v9 = (signed int)((unsigned __int64)BN_num_bits(a2[4]) + 7) / 8 + 1;
  v10 = (signed int)((unsigned __int64)BN_num_bits(a2[5]) + 7) / 8 + 1;
  v11 = (signed int)((unsigned __int64)BN_num_bits(a2[6]) + 7) / 8 + 1;
  v12 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(v8 + 19 + v9 + 4 + v10 + 4 + v11, a1);
  if ( !v12 )
    return 0LL;
  sub_1017A(v12, 7);
  memcpy(v12 + 4, "ssh-dss", 7uLL);
  v4 = (_BYTE *)sub_28F3E(v12 + 11, a2[3], v8);
  v5 = (_BYTE *)sub_28F3E(v4, a2[4], v9);
  v6 = (_BYTE *)sub_28F3E(v5, a2[5], v10);
  *v7 = sub_28F3E(v6, a2[6], v11) - (_QWORD)v12;
  return v12;
}
// 5140: using guessed type __int64 __fastcall BN_num_bits(_QWORD);

//----- (00000000000292C2) ----------------------------------------------------
__int64 __fastcall sub_292C2(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  __int64 result; // rax
  _QWORD *v7; // [rsp+8h] [rbp-58h]
  _QWORD *v8; // [rsp+10h] [rbp-50h]
  _QWORD *v9; // [rsp+18h] [rbp-48h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  void *dest; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  _BYTE *v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  dest = 0LL;
  v12 = EVP_PKEY_get1_RSA(a6);
  if ( v12
    && (dest = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(7LL, a1)) != 0LL
    && (v13 = sub_28FD0(a1, v12, &v10)) != 0LL )
  {
    RSA_free(v12);
    memcpy(dest, "ssh-rsa", 7uLL);
    *a2 = dest;
    *v9 = 7LL;
    *v8 = v13;
    *v7 = v10;
    result = 0LL;
  }
  else
  {
    if ( v12 )
      RSA_free(v12);
    if ( dest )
      (*(void (__fastcall **)(void *, __int64))(a1 + 24))(dest, a1);
    result = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for private key data");
  }
  return result;
}
// 4C90: using guessed type __int64 __fastcall RSA_free(_QWORD);
// 4DB0: using guessed type __int64 __fastcall EVP_PKEY_get1_RSA(_QWORD);

//----- (000000000002941D) ----------------------------------------------------
__int64 __fastcall sub_2941D(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  __int64 result; // rax
  _QWORD *v7; // [rsp+8h] [rbp-58h]
  _QWORD *v8; // [rsp+10h] [rbp-50h]
  _QWORD *v9; // [rsp+18h] [rbp-48h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  void *dest; // [rsp+40h] [rbp-20h]
  __int64 *v12; // [rsp+48h] [rbp-18h]
  _BYTE *v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  dest = 0LL;
  v12 = (__int64 *)EVP_PKEY_get1_DSA(a6);
  if ( v12
    && (dest = (void *)(*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8))(7LL, a1)) != 0LL
    && (v13 = sub_290FF(a1, v12, &v10)) != 0LL )
  {
    DSA_free(v12);
    memcpy(dest, "ssh-dss", 7uLL);
    *a2 = dest;
    *v9 = 7LL;
    *v8 = v13;
    *v7 = v10;
    result = 0LL;
  }
  else
  {
    if ( v12 )
      DSA_free(v12);
    if ( dest )
      (*(void (__fastcall **)(void *, __int64))(a1 + 24))(dest, a1);
    result = sub_FF92(a1, 0xFFFFFFFA, (__int64)"Unable to allocate memory for private key data");
  }
  return result;
}
// 4D30: using guessed type __int64 __fastcall EVP_PKEY_get1_DSA(_QWORD);
// 4DD0: using guessed type __int64 __fastcall DSA_free(_QWORD);

//----- (0000000000029578) ----------------------------------------------------
__int64 __fastcall sub_29578(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6, __int64 a7)
{
  _QWORD *v8; // [rsp+8h] [rbp-48h]
  _QWORD *v9; // [rsp+10h] [rbp-40h]
  _QWORD *v10; // [rsp+18h] [rbp-38h]
  unsigned int v11; // [rsp+3Ch] [rbp-14h]
  __int64 v12; // [rsp+40h] [rbp-10h]
  _DWORD *v13; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v12 = BIO_new_file(a6, "r");
  if ( !v12 )
    return sub_FF92(
             a1,
             0xFFFFFFF0,
             (__int64)"Unable to extract public key from private key file: Unable to open private key file");
  if ( !EVP_get_cipherbyname("des", "r") )
    OpenSSL_add_all_ciphers("des");
  BIO_ctrl(v12, 1LL, 0LL, 0LL);
  v13 = (_DWORD *)PEM_read_bio_PrivateKey(v12, 0LL, 0LL, a7);
  BIO_free(v12);
  if ( !v13 )
    return sub_FF92(
             a1,
             0xFFFFFFF0,
             (__int64)"Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized priva"
                      "te key file format");
  if ( *v13 == 6 )
  {
    v11 = sub_292C2(a1, a2, v10, v9, v8, (__int64)v13);
  }
  else if ( *v13 == 116 )
  {
    v11 = sub_2941D(a1, a2, v10, v9, v8, (__int64)v13);
  }
  else
  {
    a2 = (void **)4294967280LL;
    v11 = sub_FF92(
            a1,
            0xFFFFFFF0,
            (__int64)"Unable to extract public key from private key file: Unsupported private key file format");
  }
  EVP_PKEY_free(v13, a2);
  return v11;
}
// 4BA0: using guessed type __int64 __fastcall EVP_PKEY_free(_QWORD, _QWORD);
// 4D00: using guessed type __int64 __fastcall PEM_read_bio_PrivateKey(_QWORD, _QWORD, _QWORD, _QWORD);
// 4F90: using guessed type __int64 __fastcall BIO_ctrl(_QWORD, _QWORD, _QWORD, _QWORD);
// 4FD0: using guessed type __int64 __fastcall BIO_free(_QWORD);
// 4FE0: using guessed type __int64 __fastcall BIO_new_file(_QWORD, _QWORD);
// 5170: using guessed type __int64 __fastcall EVP_get_cipherbyname(_QWORD, _QWORD);
// 51E0: using guessed type __int64 __cdecl OpenSSL_add_all_ciphers(_QWORD);

//----- (00000000000296E7) ----------------------------------------------------
__int64 __fastcall libssh2_keepalive_config(__int64 a1, int a2, int a3)
{
  __int64 result; // rax

  if ( a3 == 1 )
    *(_DWORD *)(a1 + 54496) = 2;
  else
    *(_DWORD *)(a1 + 54496) = a3;
  result = a1;
  *(_DWORD *)(a1 + 54500) = a2 != 0;
  return result;
}

//----- (000000000002972F) ----------------------------------------------------
__int64 __fastcall libssh2_keepalive_send(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-44h]
  time_t v4; // [rsp+20h] [rbp-40h]
  __int64 v5; // [rsp+30h] [rbp-30h]
  __int64 v6; // [rsp+38h] [rbp-28h]
  __int64 v7; // [rsp+40h] [rbp-20h]
  int v8; // [rsp+48h] [rbp-18h]
  unsigned __int64 v9; // [rsp+58h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 54496) )
  {
    v4 = time(0LL);
    if ( v4 < *(_QWORD *)(a1 + 54504) + (signed __int64)*(signed int *)(a1 + 54496) )
    {
      if ( a2 )
        *a2 = *(unsigned __int64 *)(a1 + 54504) + *(_DWORD *)(a1 + 54496) - v4;
    }
    else
    {
      v5 = 7306363708416983120LL;
      v6 = 7800346113854955888LL;
      v7 = 8011396211333620329LL;
      v8 = 5728114;
      BYTE2(v8) = *(_DWORD *)(a1 + 54500);
      v3 = sub_24D86(a1, &v5, 27LL, 0LL, 0LL);
      if ( v3 && v3 != -37 )
      {
        sub_FF92(a1, 0xFFFFFFF9, (__int64)"Unable to send keepalive message");
        return v3;
      }
      *(_QWORD *)(a1 + 54504) = v4;
      if ( a2 )
        *a2 = *(_DWORD *)(a1 + 54496);
    }
    result = 0LL;
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    result = 0LL;
  }
  return result;
}

//----- (00000000000298B1) ----------------------------------------------------
__int64 __fastcall libssh2_init(int a1)
{
  if ( !dword_232698 && !(a1 & 1) )
  {
    OPENSSL_add_all_algorithms_noconf();
    sub_28A70();
  }
  ++dword_232698;
  dword_23269C |= a1;
  return 0LL;
}
// 4C70: using guessed type __int64 OPENSSL_add_all_algorithms_noconf(void);
// 232698: using guessed type int dword_232698;
// 23269C: using guessed type int dword_23269C;

//----- (00000000000298FF) ----------------------------------------------------
__int64 libssh2_exit()
{
  __int64 result; // rax

  result = (unsigned int)dword_232698;
  if ( dword_232698 )
    result = (unsigned int)(dword_232698-- - 1);
  return result;
}
// 232698: using guessed type int dword_232698;

//----- (0000000000029922) ----------------------------------------------------
__int64 sub_29922()
{
  __int64 result; // rax

  result = (unsigned int)dword_232698;
  if ( !dword_232698 )
    result = libssh2_init(0LL);
  return result;
}
// 5110: using guessed type __int64 __fastcall libssh2_init(_QWORD);
// 232698: using guessed type int dword_232698;

//----- (0000000000029940) ----------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 333 function(s) have been successfully decompiled
