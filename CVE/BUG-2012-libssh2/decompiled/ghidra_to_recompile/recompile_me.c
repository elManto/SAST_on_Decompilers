#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <openssl/bn.h>

typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned long    qword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;


struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

//struct _IO_FILE {
//    int _flags;
//    char * _IO_read_ptr;
//    char * _IO_read_end;
//    char * _IO_read_base;
//    char * _IO_write_base;
//    char * _IO_write_ptr;
//    char * _IO_write_end;
//    char * _IO_buf_base;
//    char * _IO_buf_end;
//    char * _IO_save_base;
//    char * _IO_backup_base;
//    char * _IO_save_end;
//    struct _IO_marker * _markers;
//    struct _IO_FILE * _chain;
//    int _fileno;
//    int _flags2;
//    __off_t _old_offset;
//    ushort _cur_column;
//    char _vtable_offset;
//    char _shortbuf[1];
//    _IO_lock_t * _lock;
//    __off64_t _offset;
//    void * __pad1;
//    void * __pad2;
//    void * __pad3;
//    void * __pad4;
//    size_t __pad5;
//    int _mode;
//    char _unused2[15];
//};

//struct _IO_marker {
//    struct _IO_marker * _next;
//    struct _IO_FILE * _sbuf;
//    int _pos;
//};
//
typedef struct hmac_ctx_st hmac_ctx_st, *Phmac_ctx_st;

typedef struct hmac_ctx_st HMAC_CTX;

typedef struct env_md_st env_md_st, *Penv_md_st;

typedef struct env_md_ctx_st env_md_ctx_st, *Penv_md_ctx_st;

//typedef struct env_md_ctx_st EVP_MD_CTX;

//typedef struct env_md_st EVP_MD;

typedef struct engine_st engine_st, *Pengine_st;

typedef struct engine_st ENGINE;

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

struct engine_st {
};

struct env_md_ctx_st {
    EVP_MD * digest;
    ENGINE * engine;
    ulong flags;
    void * md_data;
    EVP_PKEY_CTX * pctx;
    int (* update)(EVP_MD_CTX *, void *, size_t);
};

struct evp_pkey_ctx_st {
};

//struct hmac_ctx_st {
//    EVP_MD * md;
//    EVP_MD_CTX md_ctx;
//    EVP_MD_CTX i_ctx;
//    EVP_MD_CTX o_ctx;
//    uint key_length;
//    uchar key[128];
//};

struct env_md_st {
    int type;
    int pkey_type;
    int md_size;
    ulong flags;
    int (* init)(EVP_MD_CTX *);
    int (* update)(EVP_MD_CTX *, void *, size_t);
    int (* final)(EVP_MD_CTX *, uchar *);
    int (* copy)(EVP_MD_CTX *, EVP_MD_CTX *);
    int (* cleanup)(EVP_MD_CTX *);
    int (* sign)(int, uchar *, uint, uchar *, uint *, void *);
    int (* verify)(int, uchar *, uint, uchar *, uint, void *);
    int required_pkey_type[5];
    int block_size;
    int ctx_size;
    int (* md_ctrl)(EVP_MD_CTX *, int, int, void *);
};

typedef int (pem_password_cb)(char *, int, int, void *);

typedef struct stack_st_void stack_st_void, *Pstack_st_void;

typedef struct stack_st stack_st, *Pstack_st;

typedef struct stack_st _STACK;

//struct stack_st {
//    int num;
//    char * * data;
//    int sorted;
//    int num_alloc;
//    int (* comp)(void *, void *);
//};

//struct stack_st_void {
//    _STACK stack;
//};

typedef struct bio_st bio_st, *Pbio_st;

typedef struct bio_method_st bio_method_st, *Pbio_method_st;

typedef struct bio_st BIO;

typedef void (bio_info_cb)(struct bio_st *, int, char *, int, long, long);

typedef struct bio_method_st BIO_METHOD;

typedef struct crypto_ex_data_st crypto_ex_data_st, *Pcrypto_ex_data_st;

typedef struct crypto_ex_data_st CRYPTO_EX_DATA;

//struct crypto_ex_data_st {
//    struct stack_st_void * sk;
//    int dummy;
//};

struct bio_method_st {
    int type;
    char * name;
    int (* bwrite)(BIO *, char *, int);
    int (* bread)(BIO *, char *, int);
    int (* bputs)(BIO *, char *);
    int (* bgets)(BIO *, char *, int);
    long (* ctrl)(BIO *, int, long, void *);
    int (* create)(BIO *);
    int (* destroy)(BIO *);
    long (* callback_ctrl)(BIO *, int, bio_info_cb *);
};

struct bio_st {
    BIO_METHOD * method;
    long (* callback)(struct bio_st *, int, char *, int, long, long);
    char * cb_arg;
    int init;
    int shutdown;
    int flags;
    int retry_reason;
    int num;
    void * ptr;
    struct bio_st * next_bio;
    struct bio_st * prev_bio;
    int references;
    ulong num_read;
    ulong num_write;
    CRYPTO_EX_DATA ex_data;
};

typedef struct _IO_FILE FILE;

typedef struct sockaddr sockaddr, *Psockaddr;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef uint __socklen_t;

typedef __socklen_t socklen_t;

typedef long __ssize_t;

typedef __ssize_t ssize_t;

typedef long __time_t;

typedef long __suseconds_t;

typedef struct pollfd pollfd, *Ppollfd;

struct pollfd {
    int fd;
    short events;
    short revents;
};

typedef ulong nfds_t;

typedef struct pkcs8_priv_key_info_st pkcs8_priv_key_info_st, *Ppkcs8_priv_key_info_st;

typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;

typedef struct asn1_string_st asn1_string_st, *Pasn1_string_st;

typedef struct asn1_string_st ASN1_INTEGER;

typedef struct X509_algor_st X509_algor_st, *PX509_algor_st;

typedef struct X509_algor_st X509_ALGOR;

typedef struct asn1_type_st asn1_type_st, *Pasn1_type_st;

typedef struct asn1_type_st ASN1_TYPE;

typedef struct stack_st_X509_ATTRIBUTE stack_st_X509_ATTRIBUTE, *Pstack_st_X509_ATTRIBUTE;

typedef struct asn1_object_st asn1_object_st, *Pasn1_object_st;

typedef struct asn1_object_st ASN1_OBJECT;

typedef union _union_257 _union_257, *P_union_257;

typedef int ASN1_BOOLEAN;

typedef struct asn1_string_st ASN1_STRING;

typedef struct asn1_string_st ASN1_ENUMERATED;

typedef struct asn1_string_st ASN1_BIT_STRING;

typedef struct asn1_string_st ASN1_OCTET_STRING;

typedef struct asn1_string_st ASN1_PRINTABLESTRING;

typedef struct asn1_string_st ASN1_T61STRING;

typedef struct asn1_string_st ASN1_IA5STRING;

typedef struct asn1_string_st ASN1_GENERALSTRING;

typedef struct asn1_string_st ASN1_BMPSTRING;

typedef struct asn1_string_st ASN1_UNIVERSALSTRING;

typedef struct asn1_string_st ASN1_UTCTIME;

typedef struct asn1_string_st ASN1_GENERALIZEDTIME;

typedef struct asn1_string_st ASN1_VISIBLESTRING;

typedef struct asn1_string_st ASN1_UTF8STRING;

typedef struct ASN1_VALUE_st ASN1_VALUE_st, *PASN1_VALUE_st;

typedef struct ASN1_VALUE_st ASN1_VALUE;

struct ASN1_VALUE_st {
};

struct X509_algor_st {
    ASN1_OBJECT * algorithm;
    ASN1_TYPE * parameter;
};

union _union_257 {
    char * ptr;
    ASN1_BOOLEAN boolean;
    ASN1_STRING * asn1_string;
    ASN1_OBJECT * object;
    ASN1_INTEGER * integer;
    ASN1_ENUMERATED * enumerated;
    ASN1_BIT_STRING * bit_string;
    ASN1_OCTET_STRING * octet_string;
    ASN1_PRINTABLESTRING * printablestring;
    ASN1_T61STRING * t61string;
    ASN1_IA5STRING * ia5string;
    ASN1_GENERALSTRING * generalstring;
    ASN1_BMPSTRING * bmpstring;
    ASN1_UNIVERSALSTRING * universalstring;
    ASN1_UTCTIME * utctime;
    ASN1_GENERALIZEDTIME * generalizedtime;
    ASN1_VISIBLESTRING * visiblestring;
    ASN1_UTF8STRING * utf8string;
    ASN1_STRING * set;
    ASN1_STRING * sequence;
    ASN1_VALUE * asn1_value;
};

struct asn1_type_st {
    int type;
    union _union_257 value;
};

struct pkcs8_priv_key_info_st {
    int broken;
    ASN1_INTEGER * version;
    X509_ALGOR * pkeyalg;
    ASN1_TYPE * pkey;
    struct stack_st_X509_ATTRIBUTE * attributes;
};

struct stack_st_X509_ATTRIBUTE {
    int stack;
};

struct asn1_string_st {
    int length;
    int type;
    uchar * data;
    long flags;
};

struct asn1_object_st {
    char * sn;
    char * * ln;
    int nid;
    int length;
    uchar * data;
    int flags;
};

typedef struct dh_method dh_method, *Pdh_method;

typedef struct dh_st dh_st, *Pdh_st;

typedef struct dh_st DH;

typedef struct bignum_st bignum_st, *Pbignum_st;

typedef struct bignum_st BIGNUM;

typedef struct bignum_ctx bignum_ctx, *Pbignum_ctx;

typedef struct bignum_ctx BN_CTX;

typedef struct bn_mont_ctx_st bn_mont_ctx_st, *Pbn_mont_ctx_st;

typedef struct bn_mont_ctx_st BN_MONT_CTX;

typedef struct bn_gencb_st bn_gencb_st, *Pbn_gencb_st;

typedef struct bn_gencb_st BN_GENCB;

typedef struct dh_method DH_METHOD;

typedef union _union_175 _union_175, *P_union_175;

union _union_175 {
    void (* cb_1)(int, int, void *);
    int (* cb_2)(int, int, BN_GENCB *);
};

//struct bn_gencb_st {
//    uint ver;
//    void * arg;
//    union _union_175 cb;
//};

//struct bignum_st {
//    ulong * d;
//    int top;
//    int dmax;
//    int neg;
//    int flags;
//};

struct bignum_ctx {
};

struct dh_method {
    char * name;
    int (* generate_key)(DH *);
    int (* compute_key)(uchar *, BIGNUM *, DH *);
    int (* bn_mod_exp)(DH *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (* init)(DH *);
    int (* finish)(DH *);
    int flags;
    char * app_data;
    int (* generate_params)(DH *, int, int, BN_GENCB *);
};

struct dh_st {
    int pad;
    int version;
    BIGNUM * p;
    BIGNUM * g;
    long length;
    BIGNUM * pub_key;
    BIGNUM * priv_key;
    int flags;
    BN_MONT_CTX * method_mont_p;
    BIGNUM * q;
    BIGNUM * j;
    uchar * seed;
    int seedlen;
    BIGNUM * counter;
    int references;
    CRYPTO_EX_DATA ex_data;
    DH_METHOD * meth;
    ENGINE * engine;
};

//struct bn_mont_ctx_st {
//    int ri;
//    BIGNUM RR;
//    BIGNUM N;
//    BIGNUM Ni;
//    ulong n0[2];
//    int flags;
//};

typedef struct evp_pkey_asn1_method_st evp_pkey_asn1_method_st, *Pevp_pkey_asn1_method_st;

typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;

struct evp_pkey_asn1_method_st {
};

typedef struct evp_pkey_st evp_pkey_st, *Pevp_pkey_st;

typedef struct evp_pkey_st EVP_PKEY;

typedef union _union_271 _union_271, *P_union_271;

typedef struct rsa_st rsa_st, *Prsa_st;

typedef struct dsa_st dsa_st, *Pdsa_st;

typedef struct ec_key_st ec_key_st, *Pec_key_st;

typedef struct rsa_meth_st rsa_meth_st, *Prsa_meth_st;

typedef struct rsa_st RSA;

typedef struct rsa_meth_st RSA_METHOD;

typedef struct bn_blinding_st bn_blinding_st, *Pbn_blinding_st;

typedef struct bn_blinding_st BN_BLINDING;

typedef struct dsa_method dsa_method, *Pdsa_method;

typedef struct DSA_SIG_st DSA_SIG_st, *PDSA_SIG_st;

typedef struct DSA_SIG_st DSA_SIG;

typedef struct dsa_st DSA;

typedef struct dsa_method DSA_METHOD;

struct ec_key_st {
};

struct rsa_meth_st {
    char * name;
    int (* rsa_pub_enc)(int, uchar *, uchar *, RSA *, int);
    int (* rsa_pub_dec)(int, uchar *, uchar *, RSA *, int);
    int (* rsa_priv_enc)(int, uchar *, uchar *, RSA *, int);
    int (* rsa_priv_dec)(int, uchar *, uchar *, RSA *, int);
    int (* rsa_mod_exp)(BIGNUM *, BIGNUM *, RSA *, BN_CTX *);
    int (* bn_mod_exp)(BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (* init)(RSA *);
    int (* finish)(RSA *);
    int flags;
    char * app_data;
    int (* rsa_sign)(int, uchar *, uint, uchar *, uint *, RSA *);
    int (* rsa_verify)(int, uchar *, uint, uchar *, uint, RSA *);
    int (* rsa_keygen)(RSA *, int, BIGNUM *, BN_GENCB *);
};

struct bn_blinding_st {
};

union _union_271 {
    char * ptr;
    struct rsa_st * rsa;
    struct dsa_st * dsa;
    struct dh_st * dh;
    struct ec_key_st * ec;
};

struct dsa_st {
    int pad;
    long version;
    int write_params;
    BIGNUM * p;
    BIGNUM * q;
    BIGNUM * g;
    BIGNUM * pub_key;
    BIGNUM * priv_key;
    BIGNUM * kinv;
    BIGNUM * r;
    int flags;
    BN_MONT_CTX * method_mont_p;
    int references;
    CRYPTO_EX_DATA ex_data;
    DSA_METHOD * meth;
    ENGINE * engine;
};

struct rsa_st {
    int pad;
    long version;
    RSA_METHOD * meth;
    ENGINE * engine;
    BIGNUM * n;
    BIGNUM * e;
    BIGNUM * d;
    BIGNUM * p;
    BIGNUM * q;
    BIGNUM * dmp1;
    BIGNUM * dmq1;
    BIGNUM * iqmp;
    CRYPTO_EX_DATA ex_data;
    int references;
    int flags;
    BN_MONT_CTX * _method_mod_n;
    BN_MONT_CTX * _method_mod_p;
    BN_MONT_CTX * _method_mod_q;
    char * bignum_data;
    BN_BLINDING * blinding;
    BN_BLINDING * mt_blinding;
};

struct DSA_SIG_st {
    BIGNUM * r;
    BIGNUM * s;
};

struct dsa_method {
    char * name;
    DSA_SIG * (* dsa_do_sign)(uchar *, int, DSA *);
    int (* dsa_sign_setup)(DSA *, BN_CTX *, BIGNUM * *, BIGNUM * *);
    int (* dsa_do_verify)(uchar *, int, DSA_SIG *, DSA *);
    int (* dsa_mod_exp)(DSA *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (* bn_mod_exp)(DSA *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (* init)(DSA *);
    int (* finish)(DSA *);
    int flags;
    char * app_data;
    int (* dsa_paramgen)(DSA *, int, uchar *, int, int *, ulong *, BN_GENCB *);
    int (* dsa_keygen)(DSA *);
};

struct evp_pkey_st {
    int type;
    int save_type;
    int references;
    EVP_PKEY_ASN1_METHOD * ameth;
    ENGINE * engine;
    union _union_271 pkey;
    int save_parameters;
};

typedef struct X509_pubkey_st X509_pubkey_st, *PX509_pubkey_st;

struct X509_pubkey_st {
    X509_ALGOR * algor;
    ASN1_BIT_STRING * public_key;
    EVP_PKEY * pkey;
};

typedef struct evp_cipher_st evp_cipher_st, *Pevp_cipher_st;

typedef struct evp_cipher_ctx_st evp_cipher_ctx_st, *Pevp_cipher_ctx_st;

typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;

typedef struct evp_cipher_st EVP_CIPHER;

struct evp_cipher_ctx_st {
    EVP_CIPHER * cipher;
    ENGINE * engine;
    int encrypt;
    int buf_len;
    uchar oiv[16];
    uchar iv[16];
    uchar buf[32];
    int num;
    void * app_data;
    int key_len;
    ulong flags;
    void * cipher_data;
    int final_used;
    int block_mask;
    uchar final[32];
};

struct evp_cipher_st {
    int nid;
    int block_size;
    int key_len;
    int iv_len;
    ulong flags;
    int (* init)(EVP_CIPHER_CTX *, uchar *, uchar *, int);
    int (* do_cipher)(EVP_CIPHER_CTX *, uchar *, uchar *, size_t);
    int (* cleanup)(EVP_CIPHER_CTX *);
    int ctx_size;
    int (* set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);
    int (* get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);
    int (* ctrl)(EVP_CIPHER_CTX *, int, int, void *);
    void * app_data;
};

typedef struct X509_pubkey_st X509_PUBKEY;

typedef struct timeval timeval, *Ptimeval;

//struct timeval {
//    __time_t tv_sec;
//    __suseconds_t tv_usec;
//};

//typedef struct timezone timezone, *Ptimezone;

typedef struct timezone * __timezone_ptr_t;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef __time_t time_t;

typedef struct ECDSA_SIG_st ECDSA_SIG_st, *PECDSA_SIG_st;

struct ECDSA_SIG_st {
    BIGNUM * r;
    BIGNUM * s;
};

typedef struct ECDSA_SIG_st ECDSA_SIG;

typedef struct ec_group_st ec_group_st, *Pec_group_st;

typedef struct ec_group_st EC_GROUP;

struct ec_group_st {
};

typedef struct ec_point_st ec_point_st, *Pec_point_st;

typedef struct ec_point_st EC_POINT;

struct ec_point_st {
};

typedef struct ec_key_st EC_KEY;

typedef enum enum_295 {
    POINT_CONVERSION_COMPRESSED=2,
    POINT_CONVERSION_HYBRID=6,
    POINT_CONVERSION_UNCOMPRESSED=4
} enum_295;

typedef enum enum_295 point_conversion_form_t;

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_CHECKSUM=1879048184,
    SHT_DYNAMIC=6,
    SHT_DYNSYM=11,
    SHT_FINI_ARRAY=15,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191,
    SHT_GROUP=17,
    SHT_HASH=5,
    SHT_INIT_ARRAY=14,
    SHT_NOBITS=8,
    SHT_NOTE=7,
    SHT_NULL=0,
    SHT_PREINIT_ARRAY=16,
    SHT_PROGBITS=1,
    SHT_REL=9,
    SHT_RELA=4,
    SHT_SHLIB=10,
    SHT_STRTAB=3,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_syminfo=1879048188,
    SHT_SYMTAB=2,
    SHT_SYMTAB_SHNDX=18
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef enum Elf_ProgramHeaderType {
    PT_DYNAMIC=2,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_RELRO=1685382482,
    PT_GNU_STACK=1685382481,
    PT_INTERP=3,
    PT_LOAD=1,
    PT_NOTE=4,
    PT_NULL=0,
    PT_PHDR=6,
    PT_SHLIB=5,
    PT_TLS=7
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_AUDIT=1879047932,
    DT_AUXILIARY=2147483645,
    DT_BIND_NOW=24,
    DT_CHECKSUM=1879047672,
    DT_CONFIG=1879047930,
    DT_DEBUG=21,
    DT_DEPAUDIT=1879047931,
    DT_ENCODING=32,
    DT_FEATURE_1=1879047676,
    DT_FILTER=2147483647,
    DT_FINI=13,
    DT_FINI_ARRAY=26,
    DT_FINI_ARRAYSZ=28,
    DT_FLAGS=30,
    DT_FLAGS_1=1879048187,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_HASH=1879047925,
    DT_GNU_LIBLIST=1879047929,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_GNU_PRELINKED=1879047669,
    DT_HASH=4,
    DT_INIT=12,
    DT_INIT_ARRAY=25,
    DT_INIT_ARRAYSZ=27,
    DT_JMPREL=23,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_MOVETAB=1879047934,
    DT_NEEDED=1,
    DT_NULL=0,
    DT_PLTGOT=3,
    DT_PLTPAD=1879047933,
    DT_PLTPADSZ=1879047673,
    DT_PLTREL=20,
    DT_PLTRELSZ=2,
    DT_POSFLAG_1=1879047677,
    DT_PREINIT_ARRAYSZ=33,
    DT_REL=17,
    DT_RELA=7,
    DT_RELACOUNT=1879048185,
    DT_RELAENT=9,
    DT_RELASZ=8,
    DT_RELCOUNT=1879048186,
    DT_RELENT=19,
    DT_RELSZ=18,
    DT_RPATH=15,
    DT_RUNPATH=29,
    DT_SONAME=14,
    DT_STRSZ=10,
    DT_STRTAB=5,
    DT_SYMBOLIC=16,
    DT_SYMENT=11,
    DT_SYMINENT=1879047679,
    DT_SYMINFO=1879047935,
    DT_SYMINSZ=1879047678,
    DT_SYMTAB=6,
    DT_TEXTREL=22,
    DT_TLSDESC_GOT=1879047927,
    DT_TLSDESC_PLT=1879047926,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_VERSYM=1879048176
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_pad[9];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};


//EVP_MD * EVP_get_digestbyname(char *name)
//
//{
//  EVP_MD *pEVar1;
//  
//  pEVar1 = EVP_get_digestbyname(name);
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EC_POINT * EC_POINT_new(EC_GROUP *group)
//
//{
//  EC_POINT *pEVar1;
//  
//  pEVar1 = EC_POINT_new(group);
//  return pEVar1;
//}
//
//
//
//
//int _init(EVP_PKEY_CTX *ctx)
//
//{
//  int iVar1;
//  
//  iVar1 = __gmon_start__();
//  return iVar1;
//}
//my declarations

ulong _libssh2_channel_close(long param_1) ;
undefined8 _libssh2_sha1(void *param_1,size_t param_2,uchar *param_3);
undefined8 _libssh2_sha256(void *param_1,size_t param_2,uchar *param_3);
undefined8 _libssh2_rsa_sha1_verify(RSA *param_1,uchar *param_2,uint param_3,undefined8 param_4,undefined8 param_5);
long FUN_0010a76f(long param_1,undefined8 param_2,long *param_3);
ulong FUN_0010b01b(undefined8 param_1,long param_2,char *param_3,undefined8 param_4);
undefined8 FUN_0010b4ae(long param_1,void **param_2,undefined8 *param_3,long *param_4,undefined8 *param_5, EVP_PKEY *param_6);
ulong FUN_0010b90e(undefined8 param_1,long param_2,char *param_3,undefined8 param_4);
undefined8 FUN_0010beb8(long param_1,void **param_2,undefined8 *param_3,long *param_4,long *param_5, undefined8 param_6);
undefined8 FUN_0010c0f3(long param_1,long *param_2,void **param_3,undefined8 *param_4,long *param_5, undefined8 *param_6,EVP_PKEY **param_7);
undefined8 FUN_0010d1b9(long param_1,void **param_2,undefined8 *param_3,long *param_4,long *param_5, EVP_PKEY *param_6);
ulong FUN_0010d7b2(undefined8 param_1,long param_2,char *param_3,undefined8 param_4);
ulong FUN_0010e23c(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4, undefined8 param_5,char *param_6,undefined8 param_7);
ulong FUN_0010e731(long param_1,undefined8 *param_2,char *param_3,undefined8 param_4, undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined8 param_8, undefined8 param_9,undefined8 param_10);
undefined8 FUN_00116c6b(long param_1);
undefined8 FUN_0011843e(undefined8 param_1,DSA **param_2);
undefined8 FUN_00118c7b(undefined8 param_1,void **param_2);
undefined8 libssh2_base64_decode(long param_1,long *param_2,int *param_3,byte *param_4,uint param_5);
size_t _libssh2_base64_encode(long param_1,byte *param_2,size_t param_3,char **param_4);
undefined8 _libssh2_list_first(long param_1);
undefined8 _libssh2_list_next(undefined8 *param_1);
void * _libssh2_calloc(long param_1,size_t param_2);
undefined8 _libssh2_get_u32(long param_1,undefined4 *param_2);
undefined8 _libssh2_match_string(undefined8 param_1,char *param_2);
 undefined8 _libssh2_get_string(long param_1,undefined8 *param_2,ulong *param_3, undefined8* param_4);
undefined8 _libssh2_copy_string(long param_1,undefined8 param_2,void **param_3,size_t *param_4);
undefined8 _libssh2_get_bignum_bytes(long param_1,char **param_2,ulong *param_3) ;
ulong _libssh2_transport_send (long param_1,void *param_2,size_t param_3,void *param_4,size_t param_5);
ulong _libssh2_transport_read(long param_1);
undefined8 _libssh2_userauth_publickey(long param_1,undefined8 param_2,uint param_3,long param_4,ulong param_5,void *param_6, undefined8 param_7);
void ASN1_STRING_get0_data(void);
void DSA_set0_pqg(void);
void _libssh2_init_if_needed(void);
void __stack_chk_fail(void);
void DSA_SIG_free(DSA_SIG *a);
void EVP_DigestVerify(void);
void Blowfish_encipher(long param_1,uint *param_2,uint *param_3);
void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a);
void _libssh2_ecdsa_get_curve_type(EC_KEY *param_1);
void _libssh2_openssl_crypto_init(void);
void FUN_001100c8(undefined8 param_1,undefined8 param_2,long param_3);
void _libssh2_htonu32(undefined *param_1,undefined4 param_2);
void _libssh2_store_u32(long *param_1,uint param_2);
void _libssh2_store_str(void **param_1,void *param_2,ulong param_3);
void _libssh2_list_init(undefined8 *param_1);
void _libssh2_list_add(undefined8 *param_1,undefined8 *param_2);
void _libssh2_list_remove(long *param_1);
void _libssh2_explicit_zero(undefined8 param_1,undefined8 param_2);
void _libssh2_string_buf_free(long param_1,long *param_2, long *param_3);
void libssh2_publickey_list_free(long *param_1,long *param_2);
void FUN_0013b842(long *param_1);
void read_openssh_private_key_from_memory(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4, undefined8 param_5,undefined8 param_6);




undefined8 _libssh2_sha512(void *param_1,size_t param_2,uchar *param_3)
{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha512");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}

undefined8 _libssh2_sha384(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha384");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}




undefined8
_libssh2_ecdsa_verify
          (EC_KEY *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,undefined8 param_6,
          undefined8 param_7)

{
  int iVar1;
  ECDSA_SIG *sig;
  BIGNUM *ret;
  BIGNUM *ret_00;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int iStack128;
  uchar auStack88 [72];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  iStack128 = 0;
  _libssh2_ecdsa_get_curve_type(param_1);
  sig = ECDSA_SIG_new();
  ret = BN_new();
  ret_00 = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  BN_bin2bn(param_4,param_5,ret_00);
  ECDSA_SIG_set0(sig,ret,ret_00,ret);
  if (iVar1 == 0x19f) {
    _libssh2_sha256(param_6,param_7,auStack88);
    iStack128 = ECDSA_do_verify(auStack88,0x20,sig,param_1);
  }
  else {
    if (iVar1 == 0x2cb) {
      _libssh2_sha384(param_6,param_7,auStack88);
      iStack128 = ECDSA_do_verify(auStack88,0x30,sig,param_1);
    }
    else {
      if (iVar1 == 0x2cc) {
        _libssh2_sha512(param_6,param_7,auStack88);
        iStack128 = ECDSA_do_verify(auStack88,0x40,sig,param_1);
      }
    }
  }
  if (sig != (ECDSA_SIG *)0x0) {
    ECDSA_SIG_free(sig);
  }
  if (iStack128 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//int BN_div(BIGNUM *dv,BIGNUM *rem,BIGNUM *m,BIGNUM *d,BN_CTX *ctx)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_div(dv,rem,m,d,ctx);
//  return iVar1;
//}



//void _libssh2_transport_send(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_transport_send();
//  return;
//}

//EC_POINT * EC_KEY_get0_public_key(EC_KEY *key)
//
//{
//  EC_POINT *pEVar1;
//  
//  pEVar1 = EC_KEY_get0_public_key(key);
//  return pEVar1;
//}
//
//
//
//void HMAC_CTX_new(void)
//
//{
//  HMAC_CTX_new();
//  return;
//}



undefined8
_libssh2_ecdsa_create_key(long param_1,EC_KEY **param_2,void **param_3,size_t *param_4,int param_5)

{
  BN_CTX *ctx;
  undefined8 uVar1;
  EC_KEY *key;
  EC_GROUP *group;
  EC_POINT *p;
  size_t len;
  size_t sVar2;
  void *pvVar3;
  long in_FS_OFFSET;
  int iStack196;
  uchar auStack152 [136];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  iStack196 = 1;
  ctx = BN_CTX_new();
  if (ctx == (BN_CTX *)0x0) {
    uVar1 = 0xffffffff;
    goto LAB_0010dc2a;
  }
  key = EC_KEY_new_by_curve_name(param_5);
  group = EC_KEY_get0_group(key);
  EC_KEY_generate_key(key);
  p = EC_KEY_get0_public_key(key);
  len = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,(uchar *)0x0,0,ctx);
  if (len < 0x86) {
    sVar2 = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,auStack152,len,ctx);
    if (len == sVar2) {
      if (param_2 != (EC_KEY **)0x0) {
        *param_2 = key;
      }
      if (param_3 != (void **)0x0) {
        void* (* fcn_ptr)(size_t,long,size_t,long) = param_1;
        pvVar3 = (*fcn_ptr)(len,param_1,len,param_1);
        //pvVar3 = (void *)((&param_1))(len,param_1,len,param_1);
        *param_3 = pvVar3;
        if (*param_3 == (void *)0x0) {
          iStack196 = -1;
          goto LAB_0010dbfc;
        }
        memcpy(*param_3,auStack152,len);
      }
      if (param_4 != (size_t *)0x0) {
        *param_4 = len;
      }
    }
    else {
      iStack196 = -1;
    }
  }
  else {
    iStack196 = -1;
  }
LAB_0010dbfc:
  if (ctx != (BN_CTX *)0x0) {
    BN_CTX_free(ctx);
  }
  if (iStack196 == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffff;
  }
LAB_0010dc2a:
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}

//long PEM_read_bio_PrivateKey(long, )
long PTR_PTR_DAT_00350970;
long PTR_PTR_DAT_00350960;
long PEM_read_bio_ECPrivateKey;
long PEM_read_bio_DSAPrivateKey;
long DAT_00350afc;
long PEM_read_bio_RSAPrivateKey;
long DAT_00144aa0;
long DAT_0014668c;
long PTR_PTR_s_aes128_ctr_00350980;
long DAT_00350b00;
long DAT_0014667a;
long KDF;
long _edata;
long PTR_LOOP_00350900;
long DAT_0014468b;
long PTR_DAT_00350940;
long PTR_agent_ops_unix_00350948;
long DAT_0014667d;
long DAT_00145ec9;
long DAT_00146680;
long DAT_00146683;
long DAT_00146686;
//long PEM_read_bio_PrivateKey;
long DAT_00146689;
long PTR_PTR_s_ecdsa_sha2_nistp256_00350a00;
long DAT_00146840;
long DAT_00146850;
long DAT_00146860;
long DAT_00146870;
long DAT_00146890;
long DAT_001468b0;
long DAT_00146ad9;
long DAT_00146adb;
long _func_1088;
long DAT_00146ad5;
long DAT_00146ad7;
long DAT_00146ad1;
long DAT_00146ad3;
long DAT_00147060;
long PTR_PTR_s_ecdh_sha2_nistp256_00350a40;
long DAT_001474c9;
long PTR_PTR_s_hmac_sha2_256_00350aa0;
long DAT_00147700;
long DAT_00147bee;
long DAT_00147c31;
long DAT_00147f18;
long PTR_s_Proc_Type__4_ENCRYPTED_00350af0;
long PTR_s_success_0034f868;
long DAT_0034f800;
long DAT_0014860d;
long DAT_001486a7;
long DAT_0014878e;
long DAT_0014878c;
long DAT_001487c8;
long DAT_00148eab;
long DAT_001490fa;
long DAT_00149c6a;
long DAT_00149c92;
long DAT_00149c94;
long DAT_00149c96;
long DAT_00149c98;
long DAT_00149d63;
long DAT_0014a9a5;
long DAT_0014a9ac;
long DAT_0014a3f8;

ulong _libssh2_cipher_init
                (EVP_CIPHER_CTX **param_1,void *param_2,uchar *param_3,uchar *param_4,int param_5)

{
  int iVar1;
  EVP_CIPHER_CTX *pEVar2;
  EVP_CIPHER *cipher;
  
  pEVar2 = EVP_CIPHER_CTX_new();
  *param_1 = pEVar2;
  void* (*fcn_ptr)() = &param_2;
  cipher = (EVP_CIPHER *)(*fcn_ptr)();
  iVar1 = EVP_CipherInit(*param_1,cipher,param_4,param_3,param_5);
  return (ulong)(iVar1 == 0);
}

ulong FUN_0010a551(void *param_1,int param_2,undefined8 param_3,char *param_4)

{
  size_t sVar1;
  uint local_c;
  
  sVar1 = strlen(param_4);
  local_c = (uint)sVar1;
  if (param_2 + -1 < (int)local_c) {
    local_c = param_2 - 1;
  }
  memcpy(param_1,param_4,(long)(int)local_c);
  *(undefined *)((long)param_1 + (long)(int)local_c) = 0;
  return (ulong)local_c;
}



undefined8 FUN_0010a5b8(long *param_1, void* (*param_2)() ,void *param_3,int param_4,undefined8 param_5)
{
  BIO *a;
  undefined8 uVar1;
  long lVar2;
  
  *param_1 = 0;
  a = BIO_new_mem_buf(param_3,param_4);
  if (a == (BIO *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    lVar2 = (*param_2)(a,0,FUN_0010a551,param_5);
    *param_1 = lVar2;
    BIO_free(a);
    if (*param_1 == 0) {
      uVar1 = 0xffffffff;
    }
    else {
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined8
_libssh2_ed25519_new_private_frommemory
          (EVP_PKEY **param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
          undefined8 param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  EVP_PKEY *pEStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  pEStack24 = (EVP_PKEY *)0x0;
  _libssh2_init_if_needed();
  iVar1 = FUN_0010a5b8(&pEStack24,PEM_read_bio_ECPrivateKey,param_3,param_4,param_5);
  if (iVar1 == 0) {
    iVar1 = EVP_PKEY_id(pEStack24);
    if (iVar1 == 0x43f) {
      *param_1 = pEStack24;
      uVar2 = 0;
    }
    else {
      EVP_PKEY_free(pEStack24);
      uVar2 = _libssh2_error(param_2,0xfffffff2,"Private key is not an ED25519 key");
    }
  }
  else {
    read_openssh_private_key_from_memory
                      (param_1,param_2,"ssh-ed25519",param_3,param_4,param_5);
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
_libssh2_ecdsa_curve_name_with_octal_new(EC_KEY **param_1,uchar *param_2,size_t param_3,int param_4)

{
  EC_KEY *key;
  EC_GROUP *group;
  EC_POINT *p;
  undefined8 uVar1;
  int iStack36;
  
  iStack36 = 0;
  key = EC_KEY_new_by_curve_name(param_4);
  if (key != (EC_KEY *)0x0) {
    group = EC_KEY_get0_group(key);
    p = EC_POINT_new(group);
    EC_POINT_oct2point(group,p,param_2,param_3,(BN_CTX *)0x0);
    iStack36 = EC_KEY_set_public_key(key,p);
    if (p != (EC_POINT *)0x0) {
      EC_POINT_free(p);
    }
    if (param_1 != (EC_KEY **)0x0) {
      *param_1 = key;
    }
  }
  if (iStack36 == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}





//void EVP_PKEY_get_raw_public_key(void)
//
//{
//  EVP_PKEY_get_raw_public_key();
//  return;
//}
ulong _libssh2_ntohu32(byte *param_1)

{
  return (ulong)((uint)param_1[3] |
                (uint)*param_1 << 0x18 | (uint)param_1[1] << 0x10 | (uint)param_1[2] << 8);
}




ulong libssh2_channel_eof(long param_1)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  long lVar4;
  long lStack48;
  
  if (param_1 == 0) {
    uVar3 = 0xffffffd9;
  }
  else {
    lVar4 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
    do {
      lStack48 = lVar4;
      if (lStack48 == 0) {
        return (ulong)(uint)(int)*(char *)(param_1 + 0x55);
      }
      lVar4 = _libssh2_list_next(lStack48);
    } while (((*(long *)(lStack48 + 0x20) == 0) ||
             (((**(char **)(lStack48 + 0x18) != '^' && (**(char **)(lStack48 + 0x18) != '_')) ||
              (*(ulong *)(lStack48 + 0x20) < 5)))) ||
            (iVar1 = *(int *)(param_1 + 0x30),
            iVar2 = _libssh2_ntohu32(*(long *)(lStack48 + 0x18) + 1), iVar1 != iVar2));
    uVar3 = 0;
  }
  return uVar3;
}



undefined8
_libssh2_rsa_sha1_verify
          (RSA *param_1,uchar *param_2,uint param_3,undefined8 param_4,undefined8 param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uchar auStack40 [24];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_sha1(param_4,param_5,auStack40);
  if (iVar1 == 0) {
    iVar1 = RSA_verify(0x40,auStack40,0x14,param_2,param_3,param_1);
    if (iVar1 == 1) {
      uVar2 = 0;
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



//void RSA_set0_factors(void)
//
//{
//  RSA_set0_factors();
//  return;
//}
//
//
//
//void _libssh2_string_buf_free(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_string_buf_free();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,dsa_st *key)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_PKEY_set1_DSA(pkey,key);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void EC_KEY_free(EC_KEY *key)
//
//{
//  EC_KEY_free(key);
//  return;
//}
//
//
//
//void _libssh2_copy_string(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_copy_string();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//DSA_SIG * DSA_SIG_new(void)
//
//{
//  DSA_SIG *pDVar1;
//  
//  pDVar1 = DSA_SIG_new();
//  return pDVar1;
//}
//
//
//
//void _libssh2_packet_add(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_packet_add();
//  return;
//}



void blf_enc(undefined8 param_1,long param_2,ushort param_3)

{
  ushort uStack18;
  long lStack16;
  
  uStack18 = 0;
  lStack16 = param_2;
  while (uStack18 < param_3) {
    Blowfish_encipher(param_1,lStack16,lStack16 + 4);
    lStack16 = lStack16 + 8;
    uStack18 = uStack18 + 1;
  }
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//void * memset(void *__s,int __c,size_t __n)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = memset(__s,__c,__n);
//  return pvVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//int EVP_CipherInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *cipher,uchar *key,uchar *iv,int enc)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_CipherInit(ctx,cipher,key,iv,enc);
//  return iVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//int snprintf(char *__s,size_t __maxlen,char *__format,...)
//
//{
//  int iVar1;
//  
//  iVar1 = snprintf(__s,__maxlen,__format);
//  return iVar1;
//}



//void _libssh2_ecdsa_get_curve_type(EC_KEY *param_1)
//
//{
//  EC_GROUP *group;
//  
//  group = EC_KEY_get0_group(param_1);
//  EC_GROUP_get_curve_name(group);
//  return;
//}
//
//
//
//void _libssh2_openssh_pem_parse(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_openssh_pem_parse();
//  return;
//}



//long _libssh2_channel_locate(long param_1,int param_2)
//
//{
//  long lStack24;
//  long lStack16;
//  
//  lStack24 = _libssh2_list_first(param_1 + 0x200);
//  while (lStack24 != 0) {
//    if (param_2 == *(int *)(lStack24 + 0x30)) {
//      return lStack24;
//    }
//    lStack24 = _libssh2_list_next(lStack24);
//  }
//  lStack16 = _libssh2_list_first(param_1 + 0x218);
//  do {
//    if (lStack16 == 0) {
//      return 0;
//    }
//    lStack24 = _libssh2_list_first(lStack16 + 0x30);
//    while (lStack24 != 0) {
//      if (param_2 == *(int *)(lStack24 + 0x30)) {
//        return lStack24;
//      }
//      lStack24 = _libssh2_list_next(lStack24);
//    }
//    lStack16 = _libssh2_list_next(lStack16);
//  } while( 1 );
//}
//


//void _libssh2_list_first(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_list_first();
//  return;
//}
undefined8
FUN_0010a8ca(long param_1,void **param_2,undefined8 *param_3,long *param_4,undefined8 *param_5,
            EVP_PKEY *param_6)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  undefined8 local_30;
  void *local_28;
  rsa_st *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (rsa_st *)0x0;
  local_28 = (void *)0x0;
  local_20 = EVP_PKEY_get1_RSA(param_6);
  if (((local_20 == (rsa_st *)0x0) ||
      (local_28 = (void *)((void*(*)())(param_1 + 8))(7,param_1,param_1), local_28 == (void *)0x0))
     || (local_18 = FUN_0010a76f(param_1,local_20,&local_30), local_18 == 0)) {
    if (local_20 != (rsa_st *)0x0) {
      RSA_free((RSA *)local_20);
    }
    if (local_28 != (void *)0x0) {
      ((void*(*)())(param_1 + 0x18))(local_28,param_1,local_28,param_1);
    }
    uVar1 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
  }
  else {
    RSA_free((RSA *)local_20);
    memcpy(local_28,"ssh-rsa",7);
    *param_2 = local_28;
    *param_3 = 7;
    *param_4 = local_18;
    *param_5 = local_30;
    uVar1 = 0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}




ulong _libssh2_pub_priv_keyfilememory
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,void *param_6,undefined8 param_7,void *param_8)

{
  int iVar1;
  BIO *bp;
  EVP_PKEY *pkey;
  undefined8 uVar2;
  uint uStack32;
  
  bp = BIO_new_mem_buf(param_6,(int)param_7);
  if (bp == (BIO *)0x0) {
    return 0xffffffff;
  }
  BIO_ctrl(bp,1,0,(void *)0x0);
  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_8);
  BIO_free(bp);
  if (pkey == (EVP_PKEY *)0x0) {
    iVar1 = FUN_0010e731(param_1,0,0,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
    if (iVar1 != 0) {
      uVar2 = _libssh2_error(param_1,0xfffffff0,
                                                          
                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
                            );
      return uVar2;
    }
    return 0;
  }
  iVar1 = EVP_PKEY_id(pkey);
  if (iVar1 == 0x74) {
    uStack32 = FUN_0010b4ae(param_1,param_2,param_3,param_4,param_5,pkey);
    goto LAB_0010eccf;
  }
  if (iVar1 < 0x75) {
    if (iVar1 == 6) {
      uStack32 = FUN_0010a8ca(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0010eccf;
    }
  }
  else {
    if (iVar1 == 0x198) {
      uStack32 = FUN_0010d1b9(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0010eccf;
    }
    if (iVar1 == 0x43f) {
      uStack32 = FUN_0010beb8(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0010eccf;
    }
  }
  uStack32 = _libssh2_error(param_1,0xfffffff0,
                                                        
                            "Unable to extract public key from private key file: Unsupported private key file format"
                           );
LAB_0010eccf:
  EVP_PKEY_free(pkey);
  return (ulong)uStack32;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void BN_CTX_free(BN_CTX *c)
//
//{
//  BN_CTX_free(c);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//ec_key_st * EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)
//
//{
//  ec_key_st *peVar1;
//  
//  peVar1 = EVP_PKEY_get1_EC_KEY(pkey);
//  return peVar1;
//}



//void _libssh2_explicit_zero(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_explicit_zero();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memchr(__s,__c,__n);
  return pvVar1;
}

undefined8
_libssh2_packet_ask(long param_1,char param_2,undefined8 *param_3,undefined8 *param_4,int param_5,
                   void *param_6,size_t param_7)

{
  int iVar1;
  long local_10;
  
  local_10 = _libssh2_list_first(param_1 + 0x1f0);
  while( 1 ) {
    if (local_10 == 0) {
      return 0xffffffff;
    }
    if (((param_2 == **(char **)(local_10 + 0x18)) &&
        (param_7 + (long)param_5 <= *(ulong *)(local_10 + 0x20))) &&
       ((param_6 == (void *)0x0 ||
        (iVar1 = memcmp((void *)(*(long *)(local_10 + 0x18) + (long)param_5),param_6,param_7),
        iVar1 == 0)))) break;
    local_10 = _libssh2_list_next(local_10);
  }
  *param_3 = *(undefined8 *)(local_10 + 0x18);
  *param_4 = *(undefined8 *)(local_10 + 0x20);
  _libssh2_list_remove(local_10);
  ((void*(*)())(param_1 + 0x18))(local_10,param_1,local_10,param_1);
  return 0;
}



undefined8 _libssh2_channel_free(long param_1)
{
  int iVar1;
  long in_FS_OFFSET;
  undefined8 uVar2;
  undefined8 uStack48;
  undefined auStack40 [8];
  long lStack32;
  undefined auStack20 [4];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  lStack32 = *(long *)(param_1 + 0x60);
  if (lStack32 == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("session","/home/mantovan/Repositories/libssh2/src/channel.c",0xaa3,
                  "_libssh2_channel_free");
  }
  if (*(int *)(param_1 + 0x2a4) == 0) {
    *(undefined4 *)(param_1 + 0x2a4) = 2;
  }
  if (((*(char *)(param_1 + 0x40) == '\0') && (*(int *)(lStack32 + 0x22c) == 0)) &&
     (iVar1 = _libssh2_channel_close(param_1), iVar1 == -0x25)) {
    uVar2 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 0x2a4) = 0;
    if (*(long *)(param_1 + 0x28) != 0) {
	void (*fcn_ptr)(long, long, long, long) = lStack32 + 0x18;
      (*fcn_ptr)(*(undefined8 *)(param_1 + 0x28),lStack32,*(undefined8 *)(param_1 + 0x28),lStack32);
    }
    uVar2 = 0x117452;
    _libssh2_htonu32(auStack20,(ulong)*(uint *)(param_1 + 0x30));
    while ((iVar1 = _libssh2_packet_ask(lStack32,0x5e,&uStack48,auStack40,1,auStack20,4),
           -1 < iVar1 ||
           (iVar1 = _libssh2_packet_ask(lStack32,0x5f,&uStack48,auStack40,1,auStack20,4),
           -1 < iVar1))) {
      uVar2 = 0x11746c;
	  void (*ptr)() = lStack32+0x18;
      (*ptr)(uStack48,lStack32,uStack48,lStack32);
    }
    if (*(long *)(param_1 + 0x18) != 0) {
	  void* (*fcn_ptr)() = lStack32 + 0x18;
      (*fcn_ptr)
                (*(undefined8 *)(param_1 + 0x18),lStack32,*(undefined8 *)(param_1 + 0x18),lStack32);
    }
    _libssh2_list_remove(param_1);
    if (*(long *)(param_1 + 0x80) != 0) {

	  void* (*fcn_ptr)() = lStack32 + 0x80;
		(*fcn_ptr)
                (*(undefined8 *)(param_1 + 0x80),lStack32,*(undefined8 *)(param_1 + 0x80),lStack32);
    }
    if (*(long *)(param_1 + 0x1f0) != 0) {

	  void* (*fcn_ptr)() = lStack32 + 0x18;
		(*fcn_ptr)(*(undefined8 *)(param_1 + 0x1f0),lStack32,*(undefined8 *)(param_1 + 0x1f0),lStack32
                );
    }
    if (*(long *)(param_1 + 0x218) != 0) {

	  void* (*fcn_ptr)() = lStack32 + 0x18;
      (*fcn_ptr)(*(undefined8 *)(param_1 + 0x218),lStack32,*(undefined8 *)(param_1 + 0x218),lStack32
                );
    }

	void* (*fcn_ptr)() = lStack32 + 0x18;
    (*fcn_ptr)(param_1,lStack32,param_1,lStack32);
    uVar2 = 0;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_channel_free(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint uStack20;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      uStack20 = _libssh2_channel_free(param_1);
      if ((uStack20 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;

    } while (uStack20 == 0);
    uVar1 = (ulong)uStack20;
  }
  return uVar1;
}




//void _libssh2_list_init(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_list_init();
//  return;
//}
//
//
//
//void _libssh2_dh_dtor(BIGNUM **param_1)
//
//{
//  BN_clear_free(*param_1);
//  *param_1 = (BIGNUM *)0x0;
//  return;
//}



//void ECDSA_SIG_get0(void)
//
//{
//  ECDSA_SIG_get0();
//  return;
//}


ulong Blowfish_stream2word(long param_1,ushort param_2,ushort *param_3)

{
  byte bStack15;
  ushort uStack14;
  uint uStack12;
  
  uStack12 = 0;
  uStack14 = *param_3;
  bStack15 = 0;
  while (bStack15 < 4) {
    if (param_2 <= uStack14) {
      uStack14 = 0;
    }
    uStack12 = (uint)*(byte *)(param_1 + (ulong)uStack14) | uStack12 << 8;
    bStack15 = bStack15 + 1;
    uStack14 = uStack14 + 1;
  }
  *param_3 = uStack14;
  return (ulong)uStack12;
}



void Blowfish_expand0state(long param_1,undefined8 param_2,ushort param_3)

{
  long in_FS_OFFSET;
  undefined2 uStack34;
  ushort uStack32;
  ushort uStack30;
  undefined4 uStack28;
  undefined4 uStack24;
  uint uStack20;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack34 = 0;
  uStack32 = 0;
  while (uStack32 < 0x12) {
    uStack20 = Blowfish_stream2word(param_2,(ulong)param_3,&uStack34);
    *(uint *)(param_1 + ((long)(int)(uint)uStack32 + 0x400) * 4) =
         *(uint *)(param_1 + ((long)(int)(uint)uStack32 + 0x400) * 4) ^ uStack20;
    uStack32 = uStack32 + 1;
  }
  uStack34 = 0;
  uStack28 = 0;
  uStack24 = 0;
  uStack32 = 0;
  while (uStack32 < 0x12) {
    Blowfish_encipher(param_1,&uStack28,&uStack24);
    *(undefined4 *)(param_1 + ((long)(int)(uint)uStack32 + 0x400) * 4) = uStack28;
    *(undefined4 *)(param_1 + ((long)(int)((uint)uStack32 + 1) + 0x400) * 4) = uStack24;
    uStack32 = uStack32 + 2;
  }
  uStack32 = 0;
  while (uStack32 < 4) {
    uStack30 = 0;
    while (uStack30 < 0x100) {
      Blowfish_encipher(param_1,&uStack28,&uStack24);
      *(undefined4 *)(param_1 + ((long)(int)(uint)uStack30 + (long)(int)(uint)uStack32 * 0x100) * 4)
           = uStack28;
      *(undefined4 *)
       (param_1 + ((long)(int)((uint)uStack30 + 1) + (long)(int)(uint)uStack32 * 0x100) * 4) =
           uStack24;
      uStack30 = uStack30 + 2;
    }
    uStack32 = uStack32 + 1;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



//void _libssh2_get_bignum_bytes(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_get_bignum_bytes();
//  return;
//}



//void _libssh2_calloc(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_calloc();
//  return;
//}



undefined8 libssh2_agent_disconnect(long param_1,undefined8 param_2)

{
  undefined8 uVar1;
  
  if ((*(long *)(param_1 + 0x10) == 0) || (*(int *)(param_1 + 8) == -1)) {
    uVar1 = 0;
  }
  else {
	undefined8 (*fcn_ptr)(long, undefined8) = param_1+0x10;
    uVar1 = (*fcn_ptr)(param_1,param_2);
   // uVar1 = ((void*(*)())(*(long *)(param_1 + 0x10) + 0x10))(param_1,param_2);
  }
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//PKCS8_PRIV_KEY_INFO * EVP_PKEY2PKCS8(EVP_PKEY *pkey)
//
//{
//  PKCS8_PRIV_KEY_INFO *pPVar1;
//  
//  pPVar1 = EVP_PKEY2PKCS8(pkey);
//  return pPVar1;
//}
//
//
//
//void DSA_SIG_set0(void)
//
//{
//  DSA_SIG_set0();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void __assert_fail(char *__assertion,char *__file,uint __line,char *__function)
//
//{
//                    // WARNING: Subroutine does not return
//  __assert_fail(__assertion,__file,__line,__function);
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_PKEY_CTX * EVP_PKEY_CTX_new(EVP_PKEY *pkey,ENGINE *e)
//
//{
//  EVP_PKEY_CTX *pEVar1;
//  
//  pEVar1 = EVP_PKEY_CTX_new(pkey,e);
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)
//
//{
//  int iVar1;
//  
//  iVar1 = gettimeofday(__tv,__tz);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_PKEY * EVP_PKEY_new(void)
//
//{
//  EVP_PKEY *pEVar1;
//  
//  pEVar1 = EVP_PKEY_new();
//  return pEVar1;
//}



undefined8 _libssh2_sha256_init(EVP_MD_CTX **param_1)

{
  int iVar1;
  EVP_MD_CTX *pEVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  *param_1 = pEVar2;
  if (*param_1 == (EVP_MD_CTX *)0x0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha256");
    iVar1 = EVP_DigestInit(*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = (EVP_MD_CTX *)0x0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



// WARNING: Unknown calling convention yet parameter storage is locked

DSA_SIG * DSA_do_sign(uchar *dgst,int dlen,DSA *dsa)

{
  DSA_SIG *pDVar1;
  
  pDVar1 = DSA_do_sign(dgst,dlen,dsa);
  return pDVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int HMAC_Update(HMAC_CTX *ctx,uchar *data,size_t len)

{
  int iVar1;
  
  iVar1 = HMAC_Update(ctx,data,len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked



long _libssh2_channel_packet_data_len(long param_1,int param_2)

{
  int iVar1;
  int iVar2;
  long lVar3;
  long lStack32;
  
  lVar3 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
  if (lVar3 == 0) {
    lVar3 = 0;
  }
  else {
    do {
      lStack32 = lVar3;
      if (lStack32 == 0) {
        return 0;
      }
      lVar3 = _libssh2_list_next(lStack32);
    } while ((*(ulong *)(lStack32 + 0x20) < 5) ||
            ((((((iVar1 = _libssh2_ntohu32(*(long *)(lStack32 + 0x18) + 1), param_2 == 0 ||
                 (**(char **)(lStack32 + 0x18) != '_')) || (iVar1 != *(int *)(param_1 + 0x30))) ||
               ((*(ulong *)(lStack32 + 0x20) < 9 ||
                (iVar2 = _libssh2_ntohu32(*(long *)(lStack32 + 0x18) + 5), param_2 != iVar2)))) &&
              ((param_2 != 0 ||
               ((**(char **)(lStack32 + 0x18) != '^' || (iVar1 != *(int *)(param_1 + 0x30))))))) &&
             ((param_2 != 0 ||
              (((**(char **)(lStack32 + 0x18) != '_' || (iVar1 != *(int *)(param_1 + 0x30))) ||
               (*(char *)(param_1 + 0x56) != '\x02'))))))));
    lVar3 = *(long *)(lStack32 + 0x20) - *(long *)(lStack32 + 0x28);
  }
  return lVar3;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//int strncmp(char *__s1,char *__s2,size_t __n)
//
//{
//  int iVar1;
//  
//  iVar1 = strncmp(__s1,__s2,__n);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void * malloc(size_t __size)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = malloc(__size);
//  return pvVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//FILE * fopen(char *__filename,char *__modes)
//
//{
//  FILE *pFVar1;
//  
//  pFVar1 = fopen(__filename,__modes);
//  return pFVar1;
//}
//




// WARNING: Unknown calling convention yet parameter storage is locked

//ssize_t recv(int __fd,void *__buf,size_t __n,int __flags)
//
//{
//  ssize_t sVar1;
//  
//  sVar1 = recv(__fd,__buf,__n,__flags);
//  return sVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int BN_set_word(BIGNUM *a,ulong w)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_set_word(a,w);
//  return iVar1;
//}
//
//
//
//void libssh2_session_last_errno(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_session_last_errno();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_DigestSignInit(EVP_MD_CTX *ctx,EVP_PKEY_CTX **pctx,EVP_MD *type,ENGINE *e,EVP_PKEY *pkey)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_DigestSignInit(ctx,pctx,type,e,pkey);
//  return iVar1;
//}
//
//
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
////BIGNUM * BN_bin2bn(uchar *s,int len,BIGNUM *ret)
////
////{
////  BIGNUM *pBVar1;
////  
////  pBVar1 = BN_bin2bn(s,len,ret);
////  return pBVar1;
////}
//
//
//
//void _libssh2_bcrypt_pbkdf(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_bcrypt_pbkdf();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_PKEY_id(EVP_PKEY *pkey)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_PKEY_id(pkey);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EC_KEY_set_public_key(EC_KEY *key,EC_POINT *pub)
//
//{
//  int iVar1;
//  
//  iVar1 = EC_KEY_set_public_key(key,pub);
//  return iVar1;
//}
//
//
//
//void RSA_set0_key(void)
//
//{
//  RSA_set0_key();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//dsa_st * EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
//
//{
//  dsa_st *pdVar1;
//  
//  pdVar1 = EVP_PKEY_get1_DSA(pkey);
//  return pdVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_MD * EVP_md5(void)
//
//{
//  EVP_MD *pEVar1;
//  
//  pEVar1 = EVP_md5();
//  return pEVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//int BN_num_bits(BIGNUM *a)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_num_bits(a);
//  return iVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//char * fgets(char *__s,int __n,FILE *__stream)
//
//{
//  char *pcVar1;
//  
//  pcVar1 = fgets(__s,__n,__stream);
//  return pcVar1;
//}
//


undefined8
_libssh2_dsa_new(DSA **param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,uchar *param_6,
                int param_7,uchar *param_8,int param_9,uchar *param_10,long param_11)

{
  BIGNUM *ret;
  BIGNUM *ret_00;
  BIGNUM *ret_01;
  BIGNUM *ret_02;
  DSA *pDVar1;
  BIGNUM *pBStack48;
  
  pBStack48 = (BIGNUM *)0x0;
  ret = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_4,param_5,ret_00);
  ret_01 = BN_new();
  BN_bin2bn(param_6,param_7,ret_01);
  ret_02 = BN_new();
  BN_bin2bn(param_8,param_9,ret_02);
  if (param_11 != 0) {
    pBStack48 = BN_new();
    BN_bin2bn(param_10,(int)param_11,pBStack48);
  }
  pDVar1 = DSA_new();
  *param_1 = pDVar1;
  DSA_set0_pqg();
  DSA_set0_key(*param_1,ret_02,pBStack48,ret_02);
  return 0;
}



undefined ** _libssh2_comp_methods(long param_1)

{
  undefined **ppuVar1;
  
  if (*(int *)(param_1 + 0x70) == 0) {
    ppuVar1 = &PTR_PTR_DAT_00350970;
  }
  else {
    ppuVar1 = &PTR_PTR_DAT_00350960;
  }
  return ppuVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int RSA_verify(int type,uchar *m,uint m_length,uchar *sigbuf,uint siglen,RSA *rsa)

{
  int iVar1;
  
  iVar1 = RSA_verify(type,m,m_length,sigbuf,siglen,rsa);
  return iVar1;
}


ASN1_OCTET_STRING * d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a,uchar **in,long len)

{
  ASN1_OCTET_STRING *pAVar1;
  
  pAVar1 = d2i_ASN1_OCTET_STRING(a,in,len);
  return pAVar1;
}


ulong _libssh2_curve25519_new(long param_1,long *param_2,void **param_3,void **param_4)

{
  int iVar1;
  ulong uVar2;
  void *pvVar3;
  long in_FS_OFFSET;
  int iStack104;
  int iStack100;
  uint uStack96;
  int iStack92;
  EVP_PKEY *pEStack88;
  X509_PUBKEY *pXStack80;
  uchar *puStack72;
  uchar *puStack64;
  ASN1_OCTET_STRING *pAStack56;
  EVP_PKEY_CTX *pEStack48;
  PKCS8_PRIV_KEY_INFO *pPStack40;
  long lStack32;
  void *pvStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  pEStack88 = (EVP_PKEY *)0x0;
  pEStack48 = (EVP_PKEY_CTX *)0x0;
  pPStack40 = (PKCS8_PRIV_KEY_INFO *)0x0;
  pAStack56 = (ASN1_OCTET_STRING *)0x0;
  pXStack80 = (X509_PUBKEY *)0x0;
  lStack32 = 0;
  uStack96 = 0xffffffff;
  pEStack48 = EVP_PKEY_CTX_new_id(0x40a,(ENGINE *)0x0);
  if (pEStack48 == (EVP_PKEY_CTX *)0x0) {
    uVar2 = 0xffffffff;
    goto LAB_0010bea2;
  }
  EVP_PKEY_keygen_init(pEStack48);
  EVP_PKEY_keygen(pEStack48,&pEStack88);
  pPStack40 = EVP_PKEY2PKCS8(pEStack88);
  if (((pPStack40 != (PKCS8_PRIV_KEY_INFO *)0x0) &&
      (iVar1 = PKCS8_pkey_get0((ASN1_OBJECT **)0x0,&puStack72,&iStack100,(X509_ALGOR **)0x0,
                               pPStack40), iVar1 != 0)) &&
     (pAStack56 = d2i_ASN1_OCTET_STRING((ASN1_OCTET_STRING **)0x0,&puStack72,(long)iStack100),
     pAStack56 != (ASN1_OCTET_STRING *)0x0)) {
    ASN1_STRING_get0_data();
    iStack92 = ASN1_STRING_length((ASN1_STRING *)pAStack56);
    if (((iStack92 == 0x20) && (pXStack80 = X509_PUBKEY_new(), pXStack80 != (X509_PUBKEY *)0x0)) &&
       ((iVar1 = X509_PUBKEY_set(&pXStack80,pEStack88), iVar1 != 0 &&
        ((iVar1 = X509_PUBKEY_get0_param
                            ((ASN1_OBJECT **)0x0,&puStack64,&iStack104,(X509_ALGOR **)0x0,pXStack80)
         , iVar1 != 0 && (iStack104 == 0x20)))))) {
      if (param_4 != (void **)0x0) {
          pvVar3 = (void *)((void*(*)())(param_1 + 8))(0x20,param_1,param_1);
        //pvVar3 = (void *)((void*(*)())param_1+8)(0x20,param_1,param_1);
        *param_4 = pvVar3;
        if (*param_4 == (void *)0x0) goto LAB_0010be3c;
        memcpy(*param_4,pvStack24,0x20);
      }
      if (param_3 != (void **)0x0) {

        pvVar3 = (void *)((void*(*)())param_1)(0x20,param_1,param_1);
        *param_3 = pvVar3;
        if (*param_3 == (void *)0x0) goto LAB_0010be3c;
        memcpy(*param_3,puStack64,0x20);
      }
      if (param_2 != (long *)0x0) {
        lStack32 = EVP_PKEY_new_raw_private_key(0x40a,0,pvStack24,0x20);
        if (lStack32 == 0) goto LAB_0010be3c;
        *param_2 = lStack32;
      }
      uStack96 = 0;
    }
  }
LAB_0010be3c:
  if (pPStack40 != (PKCS8_PRIV_KEY_INFO *)0x0) {
    PKCS8_PRIV_KEY_INFO_free(pPStack40);
  }
  if (pEStack48 != (EVP_PKEY_CTX *)0x0) {
    EVP_PKEY_CTX_free(pEStack48);
  }
  if (pAStack56 != (ASN1_OCTET_STRING *)0x0) {
    ASN1_OCTET_STRING_free(pAStack56);
  }
  if (pXStack80 != (X509_PUBKEY *)0x0) {
    X509_PUBKEY_free(pXStack80);
  }
  if (pEStack88 != (EVP_PKEY *)0x0) {
    EVP_PKEY_free(pEStack88);
  }
  uVar2 = (ulong)uStack96;
LAB_0010bea2:
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ASN1_STRING_get0_data(void)

{
  ASN1_STRING_get0_data();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EVP_DigestUpdate(EVP_MD_CTX *ctx,void *d,size_t cnt)

{
  int iVar1;
  
  iVar1 = EVP_DigestUpdate(ctx,d,cnt);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int PKCS8_pkey_get0(ASN1_OBJECT **ppkalg,uchar **pk,int *ppklen,X509_ALGOR **pa,
                   PKCS8_PRIV_KEY_INFO *p8)

{
  int iVar1;
  
  iVar1 = PKCS8_pkey_get0(ppkalg,pk,ppklen,pa,p8);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//int BN_sub(BIGNUM *r,BIGNUM *a,BIGNUM *b)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_sub(r,a,b);
//  return iVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//EC_GROUP * EC_KEY_get0_group(EC_KEY *key)
//
//{
//  EC_GROUP *pEVar1;
//  
//  pEVar1 = EC_KEY_get0_group(key);
//  return pEVar1;
//}



//void _libssh2_base64_encode(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_base64_encode();
//  return;
//}



long _libssh2_channel_write(long param_1,uint param_2,undefined8 param_3,ulong param_4)

{
  int iVar1;
  uint uVar2;
  long lVar3;
  undefined uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  ulong uStack88;
  undefined *puStack40;
  long lStack32;
  long lStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  lStack32 = *(long *)(param_1 + 0x60);
  lStack24 = 0;
  uStack88 = param_4;
  if (0x7fbc < param_4) {
    uStack88 = 0x7fbc;
  }
  if (*(int *)(param_1 + 0x268) == 0) {
    puStack40 = (undefined *)(param_1 + 0x26c);
    if (*(char *)(param_1 + 0x40) != '\0') {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe6,
                             "We\'ve already closed this channel");
      lVar3 = (long)iVar1;
      goto LAB_00116bc2;
    }
    if (*(char *)(param_1 + 0x41) != '\0') {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe5,
                             "EOF has already been received, data might be ignored");
      lVar3 = (long)iVar1;
      goto LAB_00116bc2;
    }
    do {
      uVar2 = _libssh2_transport_read(lStack32);
    } while (0 < (int)uVar2);
    if (((int)uVar2 < 0) && (uVar2 != 0xffffffdb)) {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),(ulong)uVar2,
                             "Failure while draining incoming flow",(ulong)uVar2);
      lVar3 = (long)iVar1;
      goto LAB_00116bc2;
    }
    if (*(int *)(param_1 + 0x38) == 0) {
      *(undefined4 *)(lStack32 + 0x230) = 1;
      if (uVar2 == 0xffffffdb) {
        lVar3 = -0x25;
      }
      else {
        lVar3 = 0;
      }
      goto LAB_00116bc2;
    }
    *(ulong *)(param_1 + 0x288) = uStack88;
    if (param_2 == 0) {
      uVar4 = 0x5e;
    }
    else {
      uVar4 = 0x5f;
    }
    *puStack40 = uVar4;
    puStack40 = puStack40 + 1;
    _libssh2_store_u32(&puStack40,(ulong)*(uint *)(param_1 + 0x44))
    ;
    if (param_2 != 0) {
      _libssh2_store_u32(&puStack40,(ulong)param_2);
    }
    if ((ulong)*(uint *)(param_1 + 0x38) < *(ulong *)(param_1 + 0x288)) {
      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x38);
    }
    if ((ulong)*(uint *)(param_1 + 0x3c) < *(ulong *)(param_1 + 0x288)) {
      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x3c);
    }
    uVar5 = *(ulong *)(param_1 + 0x288) & 0xffffffff;
    _libssh2_store_u32(&puStack40,uVar5);
    *(undefined **)(param_1 + 0x280) = puStack40 + -(param_1 + 0x26c);
    *(undefined4 *)(param_1 + 0x268) = 2;
  }
  if (*(int *)(param_1 + 0x268) == 2) {
    uVar2 = _libssh2_transport_send
                      (lStack32,param_1 + 0x26c,*(undefined8 *)(param_1 + 0x280),param_3,
                       *(undefined8 *)(param_1 + 0x288));
    if (uVar2 == 0xffffffdb) {
      iVar1 = _libssh2_error(lStack32,0xffffffdb,"Unable to send channel data",0xffffffdb);
      lVar3 = (long)iVar1;
    }
    else {
      if (uVar2 == 0) {
        *(int *)(param_1 + 0x38) = *(int *)(param_1 + 0x38) - (int)*(undefined8 *)(param_1 + 0x288);
        lVar3 = lStack24 + *(long *)(param_1 + 0x288);
        *(undefined4 *)(param_1 + 0x268) = 0;
        lStack24 = lVar3;
      }
      else {
        *(undefined4 *)(param_1 + 0x268) = 0;
        iVar1 = _libssh2_error(lStack32,(ulong)uVar2,"Unable to send channel data",(ulong)uVar2);
        lVar3 = (long)iVar1;
      }
    }
  }
  else {
    lVar3 = -0x22;
  }
LAB_00116bc2:
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return lVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}


//void _libssh2_error(undefined8 param_1,uint param_2,undefined8 param_3)
//
//{
//  _libssh2_error_flags(param_1,(ulong)param_2,param_3,0);
//  return;
//}



//void _libssh2_error(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_error();
//  return;
//}



//void DSA_get0_key(void)
//
//{
//  DSA_get0_key();
//  return;
//}
//
//
//
//void EVP_PKEY_new_raw_public_key(void)
//
//{
//  EVP_PKEY_new_raw_public_key();
//  return;
//}
//
//
//
//void DSA_set0_key(void)
//
//{
//  DSA_set0_key();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//BIO * BIO_new_file(char *filename,char *mode)
//
//{
//  BIO *pBVar1;
//  
//  pBVar1 = BIO_new_file(filename,mode);
//  return pBVar1;
//}
//
//
//
//void RSA_get0_factors(void)
//
//{
//  RSA_get0_factors();
//  return;
//}

undefined * FUN_00109bba(long param_1,BIGNUM *param_2,uint param_3, uint param_4)

{
  undefined *__dest;
  uint local_2c;
  
  __dest = (undefined *)(param_1 + 4);
  *__dest = 0;
  BN_bn2bin(param_2,(uchar *)(param_1 + 5));
  local_2c = param_3;
  if (-1 < *(char *)(param_1 + 5)) {
    local_2c = param_3 - 1;
    memmove(__dest,(void *)(param_1 + 5),(long)(int)local_2c);
  }
  _libssh2_htonu32(param_1,(ulong)local_2c);
  return __dest + (int)local_2c;
}



ulong _libssh2_ecdsa_sign(undefined8 param_1,EC_KEY *param_2,uchar *param_3,int param_4,
                         void **param_5,size_t *param_6)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  uint uStack84;
  BIGNUM *pBStack72;
  BIGNUM *pBStack64;
  size_t sStack56;
  void *pvStack48;
  void *pvStack40;
  ECDSA_SIG *pEStack32;
  void *pvStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack84 = 0;
  sStack56 = 0;
  pBStack72 = (BIGNUM *)0x0;
  pBStack64 = (BIGNUM *)0x0;
  pvStack48 = (void *)0x0;
  pvStack40 = (void *)0x0;
  pEStack32 = ECDSA_do_sign(param_3,param_4,param_2);
  if (pEStack32 == (ECDSA_SIG *)0x0) {
    uVar5 = 0xffffffff;
  }
  else {
    ECDSA_SIG_get0(pEStack32,&pBStack72,&pBStack64,&pBStack72);
    iVar1 = BN_num_bits(pBStack72);
    iVar2 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar2 = iVar1 + 0xe;
    }
    uVar3 = (iVar2 >> 3) + 1;
    iVar1 = BN_num_bits(pBStack64);
    iVar2 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar2 = iVar1 + 0xe;
    }
    uVar4 = (iVar2 >> 3) + 1;
    pvStack48 = malloc((long)(int)(uVar4 + uVar3 + 8));
    if (pvStack48 == (void *)0x0) {
      uStack84 = 0xffffffff;
    }
    else {
      pvStack24 = pvStack48;
      pvStack24 = (void *)FUN_00109bba(pvStack48,pBStack72,(ulong)uVar3,pBStack72);
      pvStack24 = (void *)FUN_00109bba(pvStack24,pBStack64,(ulong)uVar4,pBStack64);
      sStack56 = (long)pvStack24 - (long)pvStack48;
      pvStack40 = (void *)_libssh2_calloc(param_1,sStack56);
      if (pvStack40 == (void *)0x0) {
        uStack84 = 0xffffffff;
      }
      else {
        memcpy(pvStack40,pvStack48,sStack56);
        *param_5 = pvStack40;
        *param_6 = sStack56;
      }
    }
    if (pvStack48 != (void *)0x0) {
      free(pvStack48);
    }
    if (pEStack32 != (ECDSA_SIG *)0x0) {
      ECDSA_SIG_free(pEStack32);
    }
    uVar5 = (ulong)uStack84;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

int RSA_size(RSA *rsa)

{
  int iVar1;
  
  iVar1 = RSA_size(rsa);
  return iVar1;
}



ulong _libssh2_ecdsa_new_private_frommemory
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5)

{
  uint uStack20;
  
  _libssh2_init_if_needed();
  uStack20 = FUN_0010a5b8(param_1,PEM_read_bio_ECPrivateKey,param_3,param_4,param_5);
  if (uStack20 != 0) {
    read_openssh_private_key_from_memory
                         (param_1,param_2,"ssh-ecdsa",param_3,param_4,param_5);
  }
  return (ulong)uStack20;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//void free(void *__ptr)
//
//{
//  free(__ptr);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//size_t strlen(char *__s)
//
//{
//  size_t sVar1;
//  
//  sVar1 = strlen(__s);
//  return sVar1;
//}
//
//
//
//void _libssh2_get_u64(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_get_u64();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//size_t EC_POINT_point2oct(EC_GROUP *group,EC_POINT *p,point_conversion_form_t form,uchar *buf,
//                         size_t len,BN_CTX *ctx)
//
//{
//  size_t sVar1;
//  
//  sVar1 = EC_POINT_point2oct(group,p,form,buf,len,ctx);
//  return sVar1;
//}



//void _libssh2_kex_exchange(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_kex_exchange();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,rsa_st *key)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_PKEY_set1_RSA(pkey,key);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_PKEY_keygen_init(ctx);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,ec_key_st *key)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_PKEY_set1_EC_KEY(pkey,key);
//  return iVar1;
//}

undefined8
_libssh2_channel_receive_window_adjust(long param_1,uint param_2,char param_3,undefined4 *param_4)

{
  int iVar1;
  undefined8 uVar2;
  uint uStack36;
  
  if (param_4 != (undefined4 *)0x0) {
    *param_4 = *(undefined4 *)(param_1 + 0x4c);
  }
  uStack36 = param_2;
  if (*(int *)(param_1 + 0x250) == 0) {
    if ((param_3 == '\0') && (param_2 + *(int *)(param_1 + 0x58) < 0x400)) {
      *(int *)(param_1 + 0x58) = *(int *)(param_1 + 0x58) + param_2;
      return 0;
    }
    if ((param_2 == 0) && (*(int *)(param_1 + 0x58) == 0)) {
      return 0;
    }
    uStack36 = param_2 + *(int *)(param_1 + 0x58);
    *(undefined4 *)(param_1 + 0x58) = 0;
    *(undefined *)(param_1 + 0x254) = 0x5d;
    _libssh2_htonu32(param_1 + 0x255,(ulong)*(uint *)(param_1 + 0x44));
    _libssh2_htonu32(param_1 + 0x259,(ulong)uStack36);
    *(undefined4 *)(param_1 + 0x250) = 2;
  }
  iVar1 = _libssh2_transport_send(*(undefined8 *)(param_1 + 0x60),param_1 + 0x254,9,0,0);
  if (iVar1 == -0x25) {
    _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffdb,"Would block sending window adjust",
                   0xffffffdb);
    uVar2 = 0xffffffdb;
  }
  else {
    if (iVar1 == 0) {
      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) + uStack36;
      *(undefined4 *)(param_1 + 0x250) = 0;
      uVar2 = 0;
    }
    else {
      *(uint *)(param_1 + 0x58) = uStack36;
      uVar2 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xfffffff9,
                             "Unable to send transfer-window adjustment packet, deferring");
    }
  }
  return uVar2;
}


undefined8 _libssh2_channel_flush(long param_1,int param_2)

{
  char cVar1;
  long lVar2;
  long lVar3;
  int iVar4;
  long lVar5;
  undefined8 uVar6;
  int iStack40;
  long lStack32;
  
  if (*(int *)(param_1 + 0x238) == 0) {
    lVar5 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
    *(undefined8 *)(param_1 + 0x240) = 0;
    *(undefined8 *)(param_1 + 0x248) = 0;
    while (lStack32 = lVar5, lStack32 != 0) {
      lVar5 = _libssh2_list_next(lStack32);
      if ((*(long *)(lStack32 + 0x20) != 0) &&
         ((((cVar1 = **(char **)(lStack32 + 0x18), cVar1 == '^' || (cVar1 == '_')) &&
           (4 < *(ulong *)(lStack32 + 0x20))) &&
          (iVar4 = _libssh2_ntohu32(*(long *)(lStack32 + 0x18) + 1),
          iVar4 == *(int *)(param_1 + 0x30))))) {
        if (cVar1 == '^') {
          iStack40 = 0;
        }
        else {
          if (*(ulong *)(lStack32 + 0x20) < 9) {
            *(undefined4 *)(param_1 + 0x238) = 0;
            uVar6 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xfffffff2,
                                   "Unexpected packet length");
            return uVar6;
          }
          iStack40 = _libssh2_ntohu32(*(long *)(lStack32 + 0x18) + 5);
        }
        if (((param_2 == -2) || ((cVar1 == '_' && ((param_2 == -1 || (param_2 == iStack40)))))) ||
           ((cVar1 == '^' && (param_2 == 0)))) {
          lVar2 = *(long *)(lStack32 + 0x20);
          lVar3 = *(long *)(lStack32 + 0x28);
          *(long *)(param_1 + 0x240) =
               *(long *)(lStack32 + 0x20) + *(long *)(param_1 + 0x240) + -0xd;
          *(long *)(param_1 + 0x248) = *(long *)(param_1 + 0x248) + (lVar2 - lVar3);
          ((void*(*)())(*(long *)(param_1 + 0x60) + 0x18))
                    (*(undefined8 *)(lStack32 + 0x18),*(undefined8 *)(param_1 + 0x60),
                     *(undefined8 *)(lStack32 + 0x18),*(undefined8 *)(param_1 + 0x60));
          _libssh2_list_remove(lStack32);
          ((void*(*)())(*(long *)(param_1 + 0x60) + 0x18))
                    (lStack32,*(undefined8 *)(param_1 + 0x60),lStack32,
                     *(undefined8 *)(param_1 + 0x60));
        }
      }
    }
    *(undefined4 *)(param_1 + 0x238) = 2;
  }
  *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - (int)*(undefined8 *)(param_1 + 0x248);
  *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - (int)*(undefined8 *)(param_1 + 0x248);
  if ((*(long *)(param_1 + 0x240) == 0) ||
     (iVar4 = _libssh2_channel_receive_window_adjust
                        (param_1,*(ulong *)(param_1 + 0x240) & 0xffffffff,1,0), iVar4 != -0x25)) {
    *(undefined4 *)(param_1 + 0x238) = 0;
    uVar6 = *(undefined8 *)(param_1 + 0x248);
  }
  else {
    uVar6 = 0xffffffdb;
  }
  return uVar6;
}




ulong libssh2_channel_flush_ex(long param_1,uint param_2)

{
  ulong uVar1;
  uint uStack20;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    time((time_t *)0x0);
    do {
      uStack20 = _libssh2_channel_flush(param_1,(ulong)param_2);
      if ((uStack20 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
    } while (uStack20 == 0);
    uVar1 = (ulong)uStack20;
  }
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EC_KEY_generate_key(EC_KEY *key)

{
  int iVar1;
  
  iVar1 = EC_KEY_generate_key(key);
  return iVar1;
}



//void libssh2_publickey_list_free(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_publickey_list_free();
//  return;
//}



undefined8
_libssh2_ed25519_verify
          (EVP_PKEY *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
          undefined8 param_5)

{
  EVP_MD_CTX *ctx;
  undefined8 uVar1;
  int iStack20;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    iStack20 = EVP_DigestVerifyInit(ctx,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,param_1);
    if (iStack20 == 1) {
      EVP_DigestVerify();
    }
    EVP_MD_CTX_free(ctx);
    if (iStack20 == 1) {
      uVar1 = 0;
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void BN_clear_free(BIGNUM *a)

{
  BN_clear_free(a);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EVP_DigestFinal(EVP_MD_CTX *ctx,uchar *md,uint *s)

{
  int iVar1;
  
  iVar1 = EVP_DigestFinal(ctx,md,s);
  return iVar1;
}



//void _libssh2_error_flags(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_error_flags();
//  return;
//}
//


// WARNING: Unknown calling convention yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EVP_PKEY_derive(EVP_PKEY_CTX *ctx,uchar *key,size_t *keylen)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_derive(ctx,key,keylen);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EVP_DigestVerifyInit(EVP_MD_CTX *ctx,EVP_PKEY_CTX **pctx,EVP_MD *type,ENGINE *e,EVP_PKEY *pkey)

{
  int iVar1;
  
  iVar1 = EVP_DigestVerifyInit(ctx,pctx,type,e,pkey);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

RSA * RSA_new(void)

{
  RSA *pRVar1;
  
  pRVar1 = RSA_new();
  return pRVar1;
}



//void libssh2_hostkey_methods(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_hostkey_methods();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int ECDSA_do_verify(uchar *dgst,int dgst_len,ECDSA_SIG *sig,EC_KEY *eckey)
//
//{
//  int iVar1;
//  
//  iVar1 = ECDSA_do_verify(dgst,dgst_len,sig,eckey);
//  return iVar1;
//}

undefined8 FUN_0010a652(long *param_1, void* (*param_2)() ,char *param_3,undefined8 param_4)

{
  BIO *a;
  undefined8 uVar1;
  long lVar2;
  
  *param_1 = 0;
  a = BIO_new_file(param_3,"r");
  if (a == (BIO *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    lVar2 = (*param_2)(a,0,FUN_0010a551,param_4);
    *param_1 = lVar2;
    BIO_free(a);
    if (*param_1 == 0) {
      uVar1 = 0xffffffff;
    }
    else {
      uVar1 = 0;
    }
  }
  return uVar1;
}




ulong _libssh2_dsa_new_private
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  uint uStack20;
  
  _libssh2_init_if_needed();
  uStack20 = FUN_0010a652(param_1,PEM_read_bio_DSAPrivateKey,param_3,param_4);
  if (uStack20 != 0) {
    uStack20 = FUN_0010b90e(param_1,param_2,param_3,param_4);
  }
  return (ulong)uStack20;
}



ulong _libssh2_channel_nextid(long param_1)

{
  uint uStack20;
  long lStack16;
  
  uStack20 = *(uint *)(param_1 + 0x210);
  lStack16 = _libssh2_list_first(param_1 + 0x200);
  while (lStack16 != 0) {
    if (uStack20 < *(uint *)(lStack16 + 0x30)) {
      uStack20 = *(uint *)(lStack16 + 0x30);
    }
    lStack16 = _libssh2_list_next(lStack16);
  }
  *(int *)(param_1 + 0x210) = uStack20 + 1;
  return (ulong)uStack20;
}



void DSA_set0_pqg(void)

{
  DSA_set0_pqg();
  return;
}



undefined8
_libssh2_dh_key_pair
          (BIGNUM **param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,int param_5,
          BN_CTX *param_6)

{
  BN_rand(*param_1,param_5 * 8 + -1,0,-1);
  BN_mod_exp(param_2,param_3,*param_1,param_4,param_6);
  return 0;
}



//
//
//void _libssh2_get_u32(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_get_u32();
//  return;
//}
//
//
//
//void _libssh2_string_buf_new(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_string_buf_new();
//  return;
//}
//


// WARNING: Unknown calling convention yet parameter storage is locked

//ECDSA_SIG * ECDSA_SIG_new(void)
//
//{
//  ECDSA_SIG *pEVar1;
//  
//  pEVar1 = ECDSA_SIG_new();
//  return pEVar1;
//}



undefined8
_libssh2_ed25519_new_public(EVP_PKEY **param_1,undefined8 param_2,undefined8 param_3,byte param_4)

{
  undefined8 uVar1;
  EVP_PKEY *pkey;
  
  if (param_1 == (EVP_PKEY **)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    pkey = (EVP_PKEY *)EVP_PKEY_new_raw_public_key(0x43f,0,param_3,(ulong)param_4);
    if (pkey == (EVP_PKEY *)0x0) {
      uVar1 = _libssh2_error(param_2,0xfffffff2,"could not create ED25519 public key");
    }
    else {
      if (param_1 == (EVP_PKEY **)0x0) {
        if (pkey != (EVP_PKEY *)0x0) {
          EVP_PKEY_free(pkey);
        }
      }
      else {
        *param_1 = pkey;
      }
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined8
_libssh2_ecdsa_new_private
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  undefined8 uVar2;
  
  _libssh2_init_if_needed();
  iVar1 = FUN_0010a652(param_1,PEM_read_bio_ECPrivateKey,param_3,param_4);
  if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = FUN_0010d7b2(param_1,param_2,param_3,param_4);
  }
  return uVar2;
}



//void _libssh2_packet_require(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_packet_require();
//  return;
//}



ulong _libssh2_pub_priv_keyfile
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,char *param_6,void *param_7)

{
  int iVar1;
  BIO *bp;
  undefined8 uVar2;
  EVP_PKEY *pkey;
  uint uStack36;
  
  bp = BIO_new_file(param_6,"r");
  if (bp == (BIO *)0x0) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,
                                                      
                           "Unable to extract public key from private key file: Unable to open private key file"
                          );
    return uVar2;
  }
  BIO_ctrl(bp,1,0,(void *)0x0);
  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_7);
  uVar2 = 0x10e5b1;
  BIO_free(bp);
  if (pkey == (EVP_PKEY *)0x0) {
    iVar1 = FUN_0010e23c(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
    if (iVar1 != 0) {
      uVar2 = _libssh2_error(param_1,0xfffffff0,
                                                          
                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
                            );
      return uVar2;
    }
    return 0;
  }
  iVar1 = EVP_PKEY_id(pkey);
  if (iVar1 == 0x74) {
    uStack36 = FUN_0010b4ae(param_1,param_2,param_3,param_4,param_5,pkey);
    goto LAB_0010e720;
  }
  if (iVar1 < 0x75) {
    if (iVar1 == 6) {
      uStack36 = FUN_0010a8ca(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0010e720;
    }
  }
  else {
    if (iVar1 == 0x198) {
      uStack36 = FUN_0010d1b9(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0010e720;
    }
    if (iVar1 == 0x43f) {
      uStack36 = FUN_0010beb8(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0010e720;
    }
  }
  uStack36 = _libssh2_error(param_1,0xfffffff0,
                                                        
                            "Unable to extract public key from private key file: Unsupported private key file format"
                           );
LAB_0010e720:
  EVP_PKEY_free(pkey);
  return (ulong)uStack36;
}

undefined8 libssh2_init(uint param_1)

{
  if ((DAT_00350afc == 0) && ((param_1 & 1) == 0)) {
    _libssh2_openssl_crypto_init();
  }
  DAT_00350afc = DAT_00350afc + 1;
  DAT_00350b00 = DAT_00350b00 | param_1;
  return 0;
}




void _libssh2_init_if_needed(void)

{
  if (DAT_00350afc == 0) {
    libssh2_init(0);
  }
  return;
}



void read_openssh_private_key_from_memory(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4, undefined8 param_5,undefined8 param_6)

{
  FUN_0010e731(param_2,param_1,param_3,0,0,0,0,param_4,param_5,param_6);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx,EVP_PKEY *peer)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_derive_set_peer(ctx,peer);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//char * strrchr(char *__s,int __c)
//
//{
//  char *pcVar1;
//  
//  pcVar1 = strrchr(__s,__c);
//  return pcVar1;
//}
//
//
//
//void libssh2_keepalive_send(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_keepalive_send();
//  return;
//}



ulong _libssh2_rsa_new_private
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  uint uStack20;
  
  _libssh2_init_if_needed();
  uStack20 = FUN_0010a652(param_1,PEM_read_bio_RSAPrivateKey,param_3,param_4);
  if (uStack20 != 0) {
    uStack20 = FUN_0010b01b(param_1,param_2,param_3,param_4);
  }
  return (ulong)uStack20;
}



//void libssh2_session_block_directions(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_session_block_directions();
//  return;
//}



ulong libssh2_channel_window_read_ex(long param_1,long *param_2,ulong *param_3)

{
  int iVar1;
  ulong uVar2;
  long lVar3;
  long lStack32;
  long lStack24;
  
  if (param_1 == 0) {
    uVar2 = 0;
  }
  else {
    if (param_3 != (ulong *)0x0) {
      *param_3 = (ulong)*(uint *)(param_1 + 0x48);
    }
    if (param_2 != (long *)0x0) {
      lStack32 = 0;
      lVar3 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
      while (lStack24 = lVar3, lStack24 != 0) {
        lVar3 = _libssh2_list_next(lStack24);
        if (((*(long *)(lStack24 + 0x20) != 0) &&
            (((**(char **)(lStack24 + 0x18) == '^' || (**(char **)(lStack24 + 0x18) == '_')) &&
             (4 < *(ulong *)(lStack24 + 0x20))))) &&
           (iVar1 = _libssh2_ntohu32(*(long *)(lStack24 + 0x18) + 1),
           iVar1 == *(int *)(param_1 + 0x30))) {
          lStack32 = lStack32 + (*(long *)(lStack24 + 0x20) - *(long *)(lStack24 + 0x28));
        }
      }
      *param_2 = lStack32;
    }
    uVar2 = (ulong)*(uint *)(param_1 + 0x4c);
  }
  return uVar2;
}



void Blowfish_initstate(undefined8 *param_1)

{
  ulong uVar1;
  undefined8 *puVar2;
  undefined8 *puVar3;
  
  *param_1 = 0x98dfb5acd1310ba6;
  param_1[0x208] = 0x8979fb1b9216d5d9;
  puVar2 = (undefined8 *)
           ((long)param_1 - (long)(undefined8 *)((ulong)(param_1 + 1) & 0xfffffffffffffff8));
  uVar1 = (ulong)((int)puVar2 + 0x1048U >> 3);
  puVar2 = (undefined8 *)((long)&DAT_00144aa0 - (long)puVar2);
  puVar3 = (undefined8 *)((ulong)(param_1 + 1) & 0xfffffffffffffff8);
  while (uVar1 != 0) {
    uVar1 = uVar1 - 1;
    *puVar3 = *puVar2;
    puVar2 = puVar2 + 1;
    puVar3 = puVar3 + 1;
  }
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//EC_KEY * EC_KEY_new_by_curve_name(int nid)
//
//{
//  EC_KEY *pEVar1;
//  
//  pEVar1 = EC_KEY_new_by_curve_name(nid);
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int poll(pollfd *__fds,nfds_t __nfds,int __timeout)
//
//{
//  int iVar1;
//  
//  iVar1 = poll(__fds,__nfds,__timeout);
//  return iVar1;
//}
//
//
//
//void _libssh2_userauth_publickey(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_userauth_publickey();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//X509_PUBKEY * X509_PUBKEY_new(void)
//
//{
//  X509_PUBKEY *pXVar1;
//  
//  pXVar1 = X509_PUBKEY_new();
//  return pXVar1;
//}



//void _libssh2_store_str(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_store_str();
//  return;
//}
//
//
//
//void _libssh2_openssh_pem_parse_memory(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_openssh_pem_parse_memory();
//  return;
//}
//
//
//
//void EVP_MD_CTX_new(void)
//
//{
//  EVP_MD_CTX_new();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//BIO * BIO_new_mem_buf(void *buf,int len)
//
//{
//  BIO *pBVar1;
//  
//  pBVar1 = BIO_new_mem_buf(buf,len);
//  return pBVar1;
//}



undefined8 _libssh2_sha512_init(EVP_MD_CTX **param_1)

{
  int iVar1;
  EVP_MD_CTX *pEVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  *param_1 = pEVar2;
  if (*param_1 == (EVP_MD_CTX *)0x0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha512");
    iVar1 = EVP_DigestInit(*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = (EVP_MD_CTX *)0x0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//int EC_GROUP_get_curve_name(EC_GROUP *group)
//
//{
//  int iVar1;
//  
//  iVar1 = EC_GROUP_get_curve_name(group);
//  return iVar1;
//}
//
//
//
//void _libssh2_ntohu32(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_ntohu32();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void rewind(FILE *__stream)
//
//{
//  rewind(__stream);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//BIGNUM * BN_value_one(void)
//
//{
//  BIGNUM *pBVar1;
//  
//  pBVar1 = BN_value_one();
//  return pBVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void ENGINE_load_builtin_engines(void)
//
//{
//  ENGINE_load_builtin_engines();
//  return;
//}

undefined8 _libssh2_channel_extended_data(long param_1,int param_2)

{
  int iVar1;
  
  if (*(int *)(param_1 + 0x2a8) == 0) {
    *(undefined *)(param_1 + 0x56) = (char)param_2;
    *(undefined4 *)(param_1 + 0x2a8) = 2;
  }
  if (((*(int *)(param_1 + 0x2a8) == 0) && (param_2 == 1)) &&
     (iVar1 = _libssh2_channel_flush(param_1,0xffffffff), iVar1 == -0x25)) {
    return 0xffffffdb;
  }
  *(undefined4 *)(param_1 + 0x2a8) = 0;
  return 0;
}




ulong libssh2_channel_handle_extended_data2(long param_1,uint param_2)

{
  ulong uVar1;
  uint uStack20;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    time((time_t *)0x0);
    do {
      uStack20 = _libssh2_channel_extended_data(param_1,(ulong)param_2);
      if ((uStack20 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;

    } while (uStack20 == 0);
    uVar1 = (ulong)uStack20;
  }
  return uVar1;
}



//void libssh2_base64_decode(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_base64_decode();
//  return;
//}
//
//
//
//void _libssh2_list_next(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_list_next();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//long strtol(char *__nptr,char **__endptr,int __base)
//
//{
//  long lVar1;
//  
//  lVar1 = strtol(__nptr,__endptr,__base);
//  return lVar1;
//}



//void libssh2_session_banner_set(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_session_banner_set();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//BIGNUM * BN_new(void)
//
//{
//  BIGNUM *pBVar1;
//  
//  pBVar1 = BN_new();
//  return pBVar1;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//int connect(int __fd,sockaddr *__addr,socklen_t __len)
//
//{
//  int iVar1;
//  
//  iVar1 = connect(__fd,__addr,__len);
//  return iVar1;
//}
//
//
//
//void EVP_DigestSign(void)
//
//{
//  EVP_DigestSign();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int X509_PUBKEY_get0_param
//              (ASN1_OBJECT **ppkalg,uchar **pk,int *ppklen,X509_ALGOR **pa,X509_PUBKEY *pub)
//
//{
//  int iVar1;
//  
//  iVar1 = X509_PUBKEY_get0_param(ppkalg,pk,ppklen,pa,pub);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_MD * EVP_sha1(void)
//
//{
//  EVP_MD *pEVar1;
//  
//  pEVar1 = EVP_sha1();
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx)
//
//{
//  EVP_PKEY_CTX_free(ctx);
//  return;
//}
//


void _libssh2_dh_init(BIGNUM **param_1)

{
  BIGNUM *pBVar1;
  
  pBVar1 = BN_new();
  *param_1 = pBVar1;
  return;
}



ulong _libssh2_channel_forward_cancel(long param_1)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint uStack80;
  undefined *puStack72;
  long lStack64;
  undefined *puStack56;
  long lStack48;
  size_t sStack40;
  long lStack32;
  long lStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  lStack48 = *(long *)(param_1 + 0x18);
  sStack40 = strlen(*(char **)(param_1 + 0x20));
  lStack32 = sStack40 + 0x22;
  uStack80 = 0;
  if (*(int *)(param_1 + 0x48) == 0) {
    puStack56 = (undefined *)((void*(*)())(lStack48 + 8))(lStack32,lStack48,lStack32,lStack48);
    if (puStack56 == (undefined *)0x0) {
      puStack72 = puStack56;
      _libssh2_error(lStack48,0xfffffffa,"Unable to allocate memory for setenv packet");
      uVar2 = 0xfffffffa;
      goto LAB_00113f11;
    }
    puStack72 = puStack56 + 1;
    *puStack56 = 0x50;
    _libssh2_store_str(&puStack72,"cancel-tcpip-forward",0x14);
    *puStack72 = 0;
    puStack72 = puStack72 + 1;
    _libssh2_store_str(&puStack72,*(undefined8 *)(param_1 + 0x20),sStack40);

    _libssh2_store_u32(&puStack72,(ulong)*(uint *)(param_1 + 0x28))
    ;
    *(undefined4 *)(param_1 + 0x48) = 2;
  }
  else {
    puStack56 = *(undefined **)(param_1 + 0x50);
  }
  if (*(int *)(param_1 + 0x48) == 2) {
    iVar1 = _libssh2_transport_send(lStack48,puStack56,lStack32,0,0);
    if (iVar1 == -0x25) {
      _libssh2_error(lStack48,0xffffffdb,"Would block sending forward request",0xffffffdb);
      *(undefined **)(param_1 + 0x50) = puStack56;
      uVar2 = 0xffffffdb;
      goto LAB_00113f11;
    }
    if (iVar1 != 0) {
      _libssh2_error(lStack48,0xfffffff9,
                     "Unable to send global-request packet for forward listen request");
      *(undefined4 *)(param_1 + 0x48) = 3;
      uStack80 = 0xfffffff9;
    }
    ((void*(*)())(lStack48 + 0x18))(puStack56,lStack48,puStack56,lStack48);
    *(undefined4 *)(param_1 + 0x48) = 3;
  }
  lStack64 = _libssh2_list_first(param_1 + 0x30);
  while (lStack64 != 0) {
    lStack24 = _libssh2_list_next(lStack64);
    iVar1 = _libssh2_channel_free(lStack64);
    if (iVar1 == -0x25) {
      uVar2 = 0xffffffdb;
      goto LAB_00113f11;
    }
    lStack64 = lStack24;
  }
  ((void*(*)())(lStack48 + 0x18))
            (*(undefined8 *)(param_1 + 0x20),lStack48,*(undefined8 *)(param_1 + 0x20),lStack48);
  _libssh2_list_remove(param_1);
  ((void*(*)())(lStack48 + 0x18))(param_1,lStack48,param_1,lStack48);
  uVar2 = (ulong)uStack80;
LAB_00113f11:
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//EVP_CIPHER_CTX * EVP_CIPHER_CTX_new(void)
//
//{
//  EVP_CIPHER_CTX *pEVar1;
//  
//  pEVar1 = EVP_CIPHER_CTX_new();
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//BN_CTX * BN_CTX_new(void)
//
//{
//  BN_CTX *pBVar1;
//  
//  pBVar1 = BN_CTX_new();
//  return pBVar1;
//}
//
//
//
//void _libssh2_list_remove(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_list_remove();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void * memmove(void *__dest,void *__src,size_t __n)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = memmove(__dest,__src,__n);
//  return pvVar1;
//}



undefined8 _libssh2_curve25519_gen_k(BIGNUM **param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  int iStack100;
  size_t sStack96;
  EVP_PKEY_CTX *pEStack88;
  EVP_PKEY *pEStack80;
  EVP_PKEY *pEStack72;
  BN_CTX *pBStack64;
  uchar auStack56 [40];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  iStack100 = -1;
  pEStack80 = (EVP_PKEY *)0x0;
  pEStack72 = (EVP_PKEY *)0x0;
  pEStack88 = (EVP_PKEY_CTX *)0x0;
  pBStack64 = (BN_CTX *)0x0;
  sStack96 = 0;
  if ((param_1 == (BIGNUM **)0x0) || (*param_1 == (BIGNUM *)0x0)) {
    uVar1 = 0xffffffff;
  }
  else {
    pBStack64 = BN_CTX_new();
    if (pBStack64 == (BN_CTX *)0x0) {
      uVar1 = 0xffffffff;
    }
    else {
      pEStack80 = (EVP_PKEY *)EVP_PKEY_new_raw_public_key(0x40a,0,param_3,0x20);
      pEStack72 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key(0x40a,0,param_2,0x20);
      if (((((pEStack80 != (EVP_PKEY *)0x0) && (pEStack72 != (EVP_PKEY *)0x0)) &&
           (pEStack88 = EVP_PKEY_CTX_new(pEStack72,(ENGINE *)0x0), pEStack88 != (EVP_PKEY_CTX *)0x0)
           ) && ((iStack100 = EVP_PKEY_derive_init(pEStack88), 0 < iStack100 &&
                 (iStack100 = EVP_PKEY_derive_set_peer(pEStack88,pEStack80), 0 < iStack100)))) &&
         (iStack100 = EVP_PKEY_derive(pEStack88,(uchar *)0x0,&sStack96), 0 < iStack100)) {
        if (sStack96 == 0x20) {
          iStack100 = EVP_PKEY_derive(pEStack88,auStack56,&sStack96);
          if ((iStack100 == 1) && (sStack96 == 0x20)) {
            BN_bin2bn(auStack56,0x20,*param_1);
          }
          else {
            iStack100 = -1;
          }
        }
        else {
          iStack100 = -1;
        }
      }
      if (pEStack88 != (EVP_PKEY_CTX *)0x0) {
        EVP_PKEY_CTX_free(pEStack88);
      }
      if (pEStack80 != (EVP_PKEY *)0x0) {
        EVP_PKEY_free(pEStack80);
      }
      if (pEStack72 != (EVP_PKEY *)0x0) {
        EVP_PKEY_free(pEStack72);
      }
      if (pBStack64 != (BN_CTX *)0x0) {
        BN_CTX_free(pBStack64);
      }
      if (iStack100 == 1) {
        uVar1 = 0;
      }
      else {
        uVar1 = 0xffffffff;
      }
    }
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//int EC_KEY_set_private_key(EC_KEY *key,BIGNUM *prv)
//
//{
//  int iVar1;
//  
//  iVar1 = EC_KEY_set_private_key(key,prv);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//char * strchr(char *__s,int __c)
//
//{
//  char *pcVar1;
//  
//  pcVar1 = strchr(__s,__c);
//  return pcVar1;
//}
//
//
//
//void HMAC_CTX_free(void)
//
//{
//  HMAC_CTX_free();
//  return;
//}
//
//
//
//void _libssh2_packet_requirev(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_packet_requirev();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int socket(int __domain,int __type,int __protocol)
//
//{
//  int iVar1;
//  
//  iVar1 = socket(__domain,__type,__protocol);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)
//
//{
//  size_t sVar1;
//  
//  sVar1 = fread(__ptr,__size,__n,__stream);
//  return sVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//char * getenv(char *__name)
//
//{
//  char *pcVar1;
//  
//  pcVar1 = getenv(__name);
//  return pcVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx,EVP_PKEY **ppkey)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_PKEY_keygen(ctx,ppkey);
//  return iVar1;
//}



ulong _libssh2_rsa_new_private_frommemory
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5)

{
  uint uStack20;
  
  _libssh2_init_if_needed();
  uStack20 = FUN_0010a5b8(param_1,PEM_read_bio_RSAPrivateKey,param_3,param_4,param_5);
  if (uStack20 != 0) {
    read_openssh_private_key_from_memory
                         (param_1,param_2,"ssh-rsa",param_3,param_4,param_5);
  }
  return (ulong)uStack20;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//int ECDH_compute_key(void *out,size_t outlen,EC_POINT *pub_key,EC_KEY *ecdh,KDF *KDF)
//
//{
//  int iVar1;
//  
//  iVar1 = ECDH_compute_key(out,outlen,pub_key,ecdh,KDF);
//  return iVar1;
//}



//ulong _libssh2_ecdsa_curve_type_from_name(char *param_1,undefined4 *param_2)
//
//{
//  int iVar1;
//  size_t sVar2;
//  uint uStack16;
//  undefined4 uStack12;
//  
//  uStack16 = 0;
//  if ((param_1 != (char *)0x0) && (sVar2 = strlen(param_1), sVar2 == 0x13)) {
//    iVar1 = strcmp(param_1,"ecdsa-sha2-nistp256");
//    if (iVar1 == 0) {
//      uStack12 = 0x19f;
//    }
//    else {
//      iVar1 = strcmp(param_1,"ecdsa-sha2-nistp384");
//      if (iVar1 == 0) {
//        uStack12 = 0x2cb;
//      }
//      else {
//        iVar1 = strcmp(param_1,"ecdsa-sha2-nistp521");
//        if (iVar1 == 0) {
//          uStack12 = 0x2cc;
//        }
//        else {
//          uStack16 = 0xffffffff;
//        }
//      }
//    }
//    if ((uStack16 == 0) && (param_2 != (undefined4 *)0x0)) {
//      *param_2 = uStack12;
//    }
//    return (ulong)uStack16;
//  }
//  return 0xffffffff;
//}



// WARNING: Unknown calling convention yet parameter storage is locked
//
int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}
//
//
//
//void _libssh2_match_string(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_match_string();
//  return;
//}
//


//void _libssh2_transport_read(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_transport_read();
//  return;
//}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
_libssh2_rsa_new(RSA **param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,uchar *param_6,
                int param_7,uchar *param_8,int param_9,uchar *param_10,int param_11,uchar *param_12,
                int param_13,uchar *param_14,int param_15,uchar *param_16,int param_17)

{
  BIGNUM *ret;
  BIGNUM *ret_00;
  RSA *pRVar1;
  BIGNUM *pBStack72;
  BIGNUM *pBStack64;
  BIGNUM *pBStack56;
  BIGNUM *pBStack48;
  BIGNUM *pBStack40;
  BIGNUM *pBStack32;
  
  pBStack72 = (BIGNUM *)0x0;
  pBStack64 = (BIGNUM *)0x0;
  pBStack56 = (BIGNUM *)0x0;
  pBStack48 = (BIGNUM *)0x0;
  pBStack40 = (BIGNUM *)0x0;
  pBStack32 = (BIGNUM *)0x0;
  ret = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_4,param_5,ret_00);
  if (param_6 != (uchar *)0x0) {
    pBStack72 = BN_new();
    BN_bin2bn(param_6,param_7,pBStack72);
    pBStack64 = BN_new();
    BN_bin2bn(param_8,param_9,pBStack64);
    pBStack56 = BN_new();
    BN_bin2bn(param_10,param_11,pBStack56);
    pBStack48 = BN_new();
    BN_bin2bn(param_12,param_13,pBStack48);
    pBStack40 = BN_new();
    BN_bin2bn(param_14,param_15,pBStack40);
    pBStack32 = BN_new();
    BN_bin2bn(param_16,param_17,pBStack32);
  }
  pRVar1 = RSA_new();
  *param_1 = pRVar1;
  RSA_set0_key(*param_1,ret_00,ret,pBStack72);
  RSA_set0_factors(*param_1,pBStack64,pBStack56,pBStack64);
  RSA_set0_crt_params(*param_1,pBStack48,pBStack40,pBStack32);
  return 0;
}

undefined8
_libssh2_packet_askv
          (undefined8 param_1,char *param_2,undefined8 param_3,undefined8 param_4,uint param_5,
          undefined8 param_6,undefined8 param_7)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  int local_10;
  
  uVar3 = 0x12c6bc;
  sVar2 = strlen(param_2);
  local_10 = 0;
  while( 1 ) {
    if ((int)sVar2 <= local_10) {
      return 0xffffffff;
    }
    iVar1 = _libssh2_packet_ask(param_1,(ulong)(byte)param_2[local_10],param_3,param_4,
                                (ulong)param_5,param_6,param_7);
    if (iVar1 == 0) break;
    local_10 = local_10 + 1;
  }
  return 0;
}






ulong _libssh2_packet_requirev
                (long param_1,char *param_2,undefined8 param_3,undefined8 param_4,uint param_5,
                undefined8 param_6,undefined8 param_7,long *param_8)

{
  int iVar1;
  uint __c;
  undefined8 uVar2;
  time_t tVar3;
  char *pcVar4;
  
  iVar1 = _libssh2_packet_askv(param_1,param_2,param_3,param_4,(ulong)param_5,param_6,param_7);
  if (iVar1 == 0) {
    *param_8 = 0;
    uVar2 = 0;
  }
  else {
    if (*param_8 == 0) {
      tVar3 = time((time_t *)0x0);
      *param_8 = tVar3;
    }
    do {
      if (*(int *)(param_1 + 0x22c) == -1) {
        *param_8 = 0;
        return 0xfffffff3;
      }
      __c = _libssh2_transport_read(param_1);
      if (((int)__c < 0) && (__c != 0xffffffdb)) {
        *param_8 = 0;
        return (ulong)__c;
      }
      if ((int)__c < 1) {
        tVar3 = time((time_t *)0x0);
        if (0x3c - (tVar3 - *param_8) < 1) {
          *param_8 = 0;
          return 0xfffffff7;
        }
        if (__c == 0xffffffdb) {
          return 0xffffffdb;
        }
      }
      uVar2 = 0x12cbc2;
      pcVar4 = strchr(param_2,__c);
    } while (pcVar4 == (char *)0x0);
    uVar2 = _libssh2_packet_askv
                      (param_1,param_2,param_3,param_4,(ulong)param_5,param_6,param_7);
  }
  return uVar2;
}




undefined8
_libssh2_channel_process_startup
          (long param_1,undefined8 param_2,long param_3,long param_4,ulong param_5)

{
  char cVar1;
  undefined *puVar2;
  uint uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *puStack48;
  char *pcStack40;
  long lStack32;
  long lStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  lStack24 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x210) == 0x10) {
    uVar4 = _libssh2_error(lStack24,0xffffffd9,"Channel can not be reused");
    goto LAB_0011589c;
  }
  if (*(int *)(param_1 + 0x210) == 0) {
    *(long *)(param_1 + 0x220) = param_3 + 10;
    memset((void *)(param_1 + 0x230),0,8);
    if (param_4 != 0) {
      *(long *)(param_1 + 0x220) = *(long *)(param_1 + 0x220) + 4;
    }
    uVar4 = ((void*(*)())(lStack24 + 8))
                      (*(undefined8 *)(param_1 + 0x220),lStack24,*(undefined8 *)(param_1 + 0x220),
                       lStack24);
    *(undefined8 *)(param_1 + 0x218) = uVar4;
    puVar2 = *(undefined **)(param_1 + 0x218);
    if (*(long *)(param_1 + 0x218) == 0) {
      puStack48 = puVar2;
      uVar4 = _libssh2_error(lStack24,0xfffffffa,
                             "Unable to allocate memory for channel-process request");
      goto LAB_0011589c;
    }
    puStack48 = puVar2 + 1;
    *puVar2 = 0x62;
    _libssh2_store_u32(&puStack48,(ulong)*(uint *)(param_1 + 0x44))
    ;
    _libssh2_store_str(&puStack48,param_2,param_3);
    puVar2 = puStack48 + 1;
    *puStack48 = 1;
    puStack48 = puVar2;
    if (param_4 != 0) {
      _libssh2_store_u32(&puStack48,param_5 & 0xffffffff);
    }
    *(undefined4 *)(param_1 + 0x210) = 2;
  }
  if (*(int *)(param_1 + 0x210) == 2) {
    uVar3 = _libssh2_transport_send
                      (lStack24,*(undefined8 *)(param_1 + 0x218),*(undefined8 *)(param_1 + 0x220),
                       param_4,param_5);
    if (uVar3 == 0xffffffdb) {
      _libssh2_error(lStack24,0xffffffdb,"Would block sending channel request",0xffffffdb);
      uVar4 = 0xffffffdb;
      goto LAB_0011589c;
    }
    if (uVar3 != 0) {
      ((void*(*)())(lStack24 + 0x18))
                (*(undefined8 *)(param_1 + 0x218),lStack24,*(undefined8 *)(param_1 + 0x218),lStack24
                );
      *(undefined8 *)(param_1 + 0x218) = 0;
      *(undefined4 *)(param_1 + 0x210) = 0x10;
      uVar4 = _libssh2_error(lStack24,(ulong)uVar3,"Unable to send channel request",(ulong)uVar3);
      goto LAB_0011589c;
    }
    ((void*(*)())(lStack24 + 0x18))
              (*(undefined8 *)(param_1 + 0x218),lStack24,*(undefined8 *)(param_1 + 0x218),lStack24);
    *(undefined8 *)(param_1 + 0x218) = 0;
    _libssh2_htonu32(param_1 + 0x228,(ulong)*(uint *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x210) = 3;
  }
  if (*(int *)(param_1 + 0x210) == 3) {
    uVar3 = _libssh2_packet_requirev
                      (lStack24,&DAT_0014668c,&pcStack40,&lStack32,1,param_1 + 0x228,4,
                       param_1 + 0x230);
    if (uVar3 == 0xffffffdb) {
      uVar4 = 0xffffffdb;
      goto LAB_0011589c;
    }
    if ((uVar3 != 0) || (lStack32 == 0)) {
      *(undefined4 *)(param_1 + 0x210) = 0x10;
      uVar4 = _libssh2_error(lStack24,(ulong)uVar3,"Failed waiting for channel success",(ulong)uVar3
                            );
      goto LAB_0011589c;
    }
    cVar1 = *pcStack40;
    ((void*(*)())(lStack24 + 0x18))(pcStack40,lStack24,pcStack40,lStack24);
    *(undefined4 *)(param_1 + 0x210) = 0x10;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_0011589c;
    }
  }
  uVar4 = _libssh2_error(lStack24,0xffffffea,
                         "Unable to complete request for channel-process-startup");
LAB_0011589c:
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *a)
//
//{
//  ASN1_OCTET_STRING_free(a);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void DSA_free(DSA *r)
//
//{
//  DSA_free(r);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int strcmp(char *__s1,char *__s2)
//
//{
//  int iVar1;
//  
//  iVar1 = strcmp(__s1,__s2);
//  return iVar1;
//}
//
//
//
//void _libssh2_get_string(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_get_string();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//ssize_t send(int __fd,void *__buf,size_t __n,int __flags)
//
//{
//  ssize_t sVar1;
//  
//  sVar1 = send(__fd,__buf,__n,__flags);
//  return sVar1;
//}
//
//
//
//void _libssh2_openssl_crypto_exit(void)
//
//{
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int BN_rand(BIGNUM *rnd,int bits,int top,int bottom)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_rand(rnd,bits,top,bottom);
//  return iVar1;
//}




// WARNING: Unknown calling convention yet parameter storage is locked

//int RSA_sign(int type,uchar *m,uint m_length,uchar *sigret,uint *siglen,RSA *rsa)
//
//{
//  int iVar1;
//  
//  iVar1 = RSA_sign(type,m,m_length,sigret,siglen,rsa);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int HMAC_Init_ex(HMAC_CTX *ctx,void *key,int len,EVP_MD *md,ENGINE *impl)
//
//{
//  int iVar1;
//  
//  iVar1 = HMAC_Init_ex(ctx,key,len,md,impl);
//  return iVar1;
//}



//undefined ** libssh2_crypt_methods(void)
//
//{
//  return &PTR_PTR_s_aes128_ctr_00350980;
//}
//
//
//
//void DSA_SIG_get0(void)
//
//{
//  DSA_SIG_get0();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_MD * EVP_ripemd160(void)
//
//{
//  EVP_MD *pEVar1;
//  
//  pEVar1 = EVP_ripemd160();
//  return pEVar1;
//}
//
//
//
//void _libssh2_wait_socket(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_wait_socket();
//  return;
//}
//


void Blowfish_decipher(long param_1,uint *param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  
  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1044);
  uVar2 = *param_3 ^
          *(uint *)(param_1 + 0x1040) ^
          (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x103c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1038) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1034) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1030) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x102c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1028) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1024) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1020) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x101c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1018) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1014) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1010) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x100c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1008) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  iVar3 = *(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4);
  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar7 = *(uint *)(param_1 + 0x1004);
  *param_2 = *(uint *)(param_1 + 0x1000) ^ uVar2;
  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EC_GROUP_get_degree(EC_GROUP *group)

{
  int iVar1;
  
  iVar1 = EC_GROUP_get_degree(group);
  return iVar1;
}



void _libssh2_mac_methods(void)

{
                    // WARNING: Treating indirect jump as call
  _libssh2_mac_methods();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_derive_init(ctx);
  return iVar1;
}



undefined8 _libssh2_dsa_sha1_sign(DSA *param_1,uchar *param_2,undefined8 param_3,void *param_4)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  BIGNUM *pBStack40;
  BIGNUM *pBStack32;
  DSA_SIG *pDStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  pDStack24 = DSA_do_sign(param_2,0x14,param_1);
  if (pDStack24 == (DSA_SIG *)0x0) {
    uVar4 = 0xffffffff;
  }
  else {
    DSA_SIG_get0(pDStack24,&pBStack40,&pBStack32,&pBStack40);
    iVar1 = BN_num_bits(pBStack40);
    iVar2 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar2 = iVar1 + 0xe;
    }
    iVar2 = iVar2 >> 3;
    if ((iVar2 < 1) || (0x14 < iVar2)) {
      DSA_SIG_free(pDStack24);
      uVar4 = 0xffffffff;
    }
    else {
      iVar3 = BN_num_bits(pBStack32);
      iVar1 = iVar3 + 7;
      if (iVar3 + 7 < 0) {
        iVar1 = iVar3 + 0xe;
      }
      iVar1 = iVar1 >> 3;
      if ((iVar1 < 1) || (0x14 < iVar1)) {
        DSA_SIG_free(pDStack24);
        uVar4 = 0xffffffff;
      }
      else {
        memset(param_4,0,0x28);
        BN_bn2bin(pBStack40,(uchar *)((long)(0x14 - iVar2) + (long)param_4));
        BN_bn2bin(pBStack32,(uchar *)((long)(0x14 - iVar1) + 0x14 + (long)param_4));
        DSA_SIG_free(pDStack24);
        uVar4 = 0;
      }
    }
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



//void RSA_set0_crt_params(void)
//
//{
//  RSA_set0_crt_params();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//int DSA_do_verify(uchar *dgst,int dgst_len,DSA_SIG *sig,DSA *dsa)
//
//{
//  int iVar1;
//  
//  iVar1 = DSA_do_verify(dgst,dgst_len,sig,dsa);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int memcmp(void *__s1,void *__s2,size_t __n)
//
//{
//  int iVar1;
//  
//  iVar1 = memcmp(__s1,__s2,__n);
//  return iVar1;
//}
//
//
//
//void DSA_get0_pqg(void)
//
//{
//  DSA_get0_pqg();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//void * calloc(size_t __nmemb,size_t __size)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = calloc(__nmemb,__size);
//  return pvVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EC_POINT_oct2point(EC_GROUP *group,EC_POINT *p,uchar *buf,size_t len,BN_CTX *ctx)
//
//{
//  int iVar1;
//  
//  iVar1 = EC_POINT_oct2point(group,p,buf,len,ctx);
//  return iVar1;
//}
//
//
//
//undefined8
//_libssh2_dh_secret(BIGNUM **param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,BN_CTX *param_5)
//
//{
//  BN_mod_exp(param_2,param_3,*param_1,param_4,param_5);
//  return 0;
//}
//


// WARNING: Unknown calling convention yet parameter storage is locked

//void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a)
//
//{
//  EVP_CIPHER_CTX_free(a);
//  return;
//}
//
//
//
//void EVP_PKEY_new_raw_private_key(void)
//
//{
//  EVP_PKEY_new_raw_private_key();
//  return;
//}
//
//
//
//void EVP_MD_CTX_free(void)
//
//{
//  EVP_MD_CTX_free();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int feof(FILE *__stream)
//
//{
//  int iVar1;
//  
//  iVar1 = feof(__stream);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int ENGINE_register_all_complete(void)
//
//{
//  int iVar1;
//  
//  iVar1 = ENGINE_register_all_complete();
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void EC_POINT_free(EC_POINT *point)
//
//{
//  EC_POINT_free(point);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int fclose(FILE *__stream)
//
//{
//  int iVar1;
//  
//  iVar1 = fclose(__stream);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int RAND_bytes(uchar *buf,int num)
//
//{
//  int iVar1;
//  
//  iVar1 = RAND_bytes(buf,num);
//  return iVar1;
//}
//
//
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void X509_PUBKEY_free(X509_PUBKEY *a)
//
//{
//  X509_PUBKEY_free(a);
//  return;
//}



undefined8
bcrypt_pbkdf(void *param_1,size_t param_2,void *param_3,ulong param_4,long param_5,ulong param_6,
            uint param_7)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  ulong uStack344;
  int iStack284;
  EVP_MD_CTX *pEStack280;
  ulong uStack272;
  ulong uStack264;
  ulong uStack256;
  ulong uStack248;
  void *pvStack240;
  ulong uStack232;
  ulong uStack224;
  undefined8 uStack216;
  undefined8 uStack208;
  undefined8 uStack200;
  undefined8 uStack192;
  undefined8 uStack184;
  undefined8 uStack176;
  undefined8 uStack168;
  undefined8 uStack160;
  uchar auStack152 [64];
  uchar auStack88 [72];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack248 = param_6;
  if (param_7 == 0) {
    uVar1 = 0xffffffff;
  }
  else {
    if ((((param_2 == 0) || (param_4 == 0)) || (param_6 == 0)) ||
       ((0x400 < param_6 || (0x100000 < param_4)))) {
      uVar1 = 0xffffffff;
    }
    else {
      pvStack240 = calloc(1,param_4 + 4);
      if (pvStack240 == (void *)0x0) {
        uVar1 = 0xffffffff;
      }
      else {
        uStack232 = param_6 + 0x1f >> 5;
        uStack256 = ((uStack232 + param_6) - 1) / uStack232;
        memcpy(pvStack240,param_3,param_4);
        _libssh2_sha512_init(&pEStack280);
        EVP_DigestUpdate(pEStack280,param_1,param_2);
        EVP_DigestFinal(pEStack280,auStack152,(uint *)0x0);
        EVP_MD_CTX_free(pEStack280);
        iStack284 = 1;
        uStack344 = param_6;
        while (uStack344 != 0) {
          *(undefined *)(param_4 + (long)pvStack240) = (char)((uint)iStack284 >> 0x18);
          *(undefined *)((long)pvStack240 + param_4 + 1) = (char)((uint)iStack284 >> 0x10);
          *(undefined *)((long)pvStack240 + param_4 + 2) = (char)((uint)iStack284 >> 8);
          *(undefined *)((long)pvStack240 + param_4 + 3) = (char)iStack284;
          _libssh2_sha512_init(&pEStack280);
          EVP_DigestUpdate(pEStack280,pvStack240,param_4 + 4);
          EVP_DigestFinal(pEStack280,auStack88,(uint *)0x0);
          EVP_MD_CTX_free(pEStack280);
          FUN_001100c8(auStack152,auStack88,&uStack184);
          uStack216 = uStack184;
          uStack208 = uStack176;
          uStack200 = uStack168;
          uStack192 = uStack160;
          uStack272 = 1;
          while (uStack272 < param_7) {
            _libssh2_sha512_init(&pEStack280);
            EVP_DigestUpdate(pEStack280,&uStack184,0x20);
            EVP_DigestFinal(pEStack280,auStack88,(uint *)0x0);
            EVP_MD_CTX_free(pEStack280);
            FUN_001100c8(auStack152,auStack88,&uStack184);
            uStack264 = 0;
            while (uStack264 < 0x20) {
              *(byte *)((long)&uStack216 + uStack264) =
                   *(byte *)((long)&uStack216 + uStack264) ^ *(byte *)((long)&uStack184 + uStack264)
              ;
              uStack264 = uStack264 + 1;
            }
            uStack272 = uStack272 + 1;
          }
          if (uStack344 <= uStack256) {
            uStack256 = uStack344;
          }
          uStack272 = 0;
          while ((uStack272 < uStack256 &&
                 (uStack224 = uStack272 * uStack232 + (ulong)(iStack284 - 1), uStack224 < uStack248)
                 )) {
            *(undefined *)(param_5 + uStack224) = *(undefined *)((long)&uStack216 + uStack272);
            uStack272 = uStack272 + 1;
          }
          uStack344 = uStack344 - uStack272;
          iStack284 = iStack284 + 1;
        }
        _libssh2_explicit_zero(&uStack216,0x20);
        free(pvStack240);
        uVar1 = 0;
      }
    }
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//char * strncpy(char *__dest,char *__src,size_t __n)
//
//{
//  char *pcVar1;
//  
//  pcVar1 = strncpy(__dest,__src,__n);
//  return pcVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_Cipher(EVP_CIPHER_CTX *c,uchar *out,uchar *in,uint inl)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_Cipher(c,out,in,inl);
//  return iVar1;
//}



ulong _libssh2_dsa_new_private_frommemory
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5)

{
  uint uStack20;
  
  _libssh2_init_if_needed();
  uStack20 = FUN_0010a5b8(param_1,PEM_read_bio_DSAPrivateKey,param_3,param_4,param_5);
  if (uStack20 != 0) {
    read_openssh_private_key_from_memory
                         (param_1,param_2,"ssh-dsa",param_3,param_4,param_5);
  }
  return (ulong)uStack20;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//double difftime(time_t __time1,time_t __time0)
//
//{
//  double dVar1;
//  
//  dVar1 = difftime(__time1,__time0);
//  return dVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void EVP_PKEY_free(EVP_PKEY *pkey)
//
//{
//  EVP_PKEY_free(pkey);
//  return;
//}
//
//
//
//void _libssh2_htonu32(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_htonu32();
//  return;
//}
//
//
//
//void _libssh2_store_u32(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_store_u32();
//  return;
//}
//
//
//
//void _libssh2_openssl_crypto_init(void)
//
//{
//  ENGINE_load_builtin_engines();
//  ENGINE_register_all_complete();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int HMAC_Final(HMAC_CTX *ctx,uchar *md,uint *len)
//
//{
//  int iVar1;
//  
//  iVar1 = HMAC_Final(ctx,md,len);
//  return iVar1;
//}



undefined8
_libssh2_rsa_sha1_sign
          (long param_1,RSA *param_2,uchar *param_3,uint param_4,uchar **param_5,ulong *param_6)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  uint uStack32;
  int iStack28;
  uchar *puStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack32 = RSA_size(param_2);
  puStack24 = (uchar *)((void*(*)())(param_1 + 8))((ulong)uStack32,param_1,param_1);
  if (puStack24 == (uchar *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    iStack28 = RSA_sign(0x40,param_3,param_4,puStack24,&uStack32,param_2);
    if (iStack28 == 0) {
      ((void*(*)())(param_1 + 0x18))(puStack24,param_1,puStack24,param_1);
      uVar1 = 0xffffffff;
    }
    else {
      *param_5 = puStack24;
      *param_6 = (ulong)uStack32;
      uVar1 = 0;
    }
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong _libssh2_cipher_crypt
                (EVP_CIPHER_CTX **param_1,undefined8 param_2,undefined8 param_3,uchar *param_4,
                size_t param_5)

{
  int iVar1;
  long in_FS_OFFSET;
  uchar auStack56 [40];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = EVP_Cipher(*param_1,auStack56,param_4,(uint)param_5);
  if (iVar1 == 1) {
    memcpy(param_4,auStack56,param_5);
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return (ulong)(iVar1 != 1);
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



//void _libssh2_packet_burn(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_packet_burn();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//int BN_bn2bin(BIGNUM *a,uchar *to)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_bn2bin(a,to);
//  return iVar1;
//}
//


undefined8 _libssh2_sha1_init(EVP_MD_CTX **param_1)

{
  int iVar1;
  EVP_MD_CTX *pEVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  *param_1 = pEVar2;
  if (*param_1 == (EVP_MD_CTX *)0x0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha1");
    iVar1 = EVP_DigestInit(*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = (EVP_MD_CTX *)0x0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//void ECDSA_SIG_free(ECDSA_SIG *sig)
//
//{
//  ECDSA_SIG_free(sig);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void RSA_free(RSA *r)
//
//{
//  RSA_free(r);
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int BN_mod_exp(BIGNUM *r,BIGNUM *a,BIGNUM *p,BIGNUM *m,BN_CTX *ctx)
//
//{
//  int iVar1;
//  
//  iVar1 = BN_mod_exp(r,a,p,m,ctx);
//  return iVar1;
//}



void Blowfish_expandstate
               (long param_1,undefined8 param_2,ushort param_3,undefined8 param_4,ushort param_5)

{
  uint uVar1;
  long in_FS_OFFSET;
  undefined2 uStack34;
  ushort uStack32;
  ushort uStack30;
  uint uStack28;
  uint uStack24;
  uint uStack20;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  uStack34 = 0;
  uStack32 = 0;
  while (uStack32 < 0x12) {
    uStack20 = Blowfish_stream2word(param_4,(ulong)param_5,&uStack34);
    *(uint *)(param_1 + ((long)(int)(uint)uStack32 + 0x400) * 4) =
         *(uint *)(param_1 + ((long)(int)(uint)uStack32 + 0x400) * 4) ^ uStack20;
    uStack32 = uStack32 + 1;
  }
  uStack34 = 0;
  uStack28 = 0;
  uStack24 = 0;
  uStack32 = 0;
  while (uStack32 < 0x12) {
    uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&uStack34);
    uStack28 = uStack28 ^ uVar1;
    uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&uStack34);
    uStack24 = uStack24 ^ uVar1;
    Blowfish_encipher(param_1,&uStack28,&uStack24);
    *(uint *)(param_1 + ((long)(int)(uint)uStack32 + 0x400) * 4) = uStack28;
    *(uint *)(param_1 + ((long)(int)((uint)uStack32 + 1) + 0x400) * 4) = uStack24;
    uStack32 = uStack32 + 2;
  }
  uStack32 = 0;
  while (uStack32 < 4) {
    uStack30 = 0;
    while (uStack30 < 0x100) {
      uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&uStack34);
      uStack28 = uStack28 ^ uVar1;
      uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&uStack34);
      uStack24 = uStack24 ^ uVar1;
      Blowfish_encipher(param_1,&uStack28,&uStack24);
      *(uint *)(param_1 + ((long)(int)(uint)uStack30 + (long)(int)(uint)uStack32 * 0x100) * 4) =
           uStack28;
      *(uint *)(param_1 + ((long)(int)((uint)uStack30 + 1) + (long)(int)(uint)uStack32 * 0x100) * 4)
           = uStack24;
      uStack30 = uStack30 + 2;
    }
    uStack32 = uStack32 + 1;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//long BIO_ctrl(BIO *bp,int cmd,long larg,void *parg)
//
//{
//  long lVar1;
//  
//  lVar1 = BIO_ctrl(bp,cmd,larg,parg);
//  return lVar1;
//}



ulong _libssh2_channel_read(long param_1,int param_2,long param_3,ulong param_4)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  undefined4 uVar4;
  long lVar5;
  bool bVar6;
  uint uStack64;
  ulong uStack56;
  ulong uStack48;
  long lStack40;
  
  lVar1 = *(long *)(param_1 + 0x60);
  uStack56 = 0;
  if ((*(int *)(param_1 + 0x260) == 0xb) ||
     ((ulong)*(uint *)(param_1 + 0x4c) < param_4 + (*(uint *)(param_1 + 0x48) >> 2) * 3)) {
    uStack64 = ((int)param_4 + *(int *)(param_1 + 0x48)) - *(int *)(param_1 + 0x4c);
    if (uStack64 < 0x400) {
      uStack64 = 0x400;
    }
    *(undefined4 *)(param_1 + 0x260) = 0xb;
    iVar2 = _libssh2_channel_receive_window_adjust(param_1,(ulong)uStack64,0,0);
    if (iVar2 != 0) {
      return (long)iVar2;
    }
    *(undefined4 *)(param_1 + 0x260) = 0;
  }
  do {
    uVar3 = _libssh2_transport_read(lVar1);
  } while (0 < (int)uVar3);
  if (((int)uVar3 < 0) && (uVar3 != 0xffffffdb)) {
    iVar2 = _libssh2_error(lVar1,(ulong)uVar3,"transport read",(ulong)uVar3);
    uStack56 = SEXT48(iVar2);
  }
  else {
    lVar5 = _libssh2_list_first(lVar1 + 0x1f0);
    while ((lStack40 = lVar5, lStack40 != 0 && (uStack56 < param_4))) {
      lVar5 = _libssh2_list_next(lStack40);
      if (4 < *(ulong *)(lStack40 + 0x20)) {
        uVar4 = _libssh2_ntohu32(*(long *)(lStack40 + 0x18) + 1);
        *(undefined4 *)(param_1 + 0x264) = uVar4;
        if ((((((param_2 != 0) && (**(char **)(lStack40 + 0x18) == '_')) &&
              (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))) &&
             ((8 < *(ulong *)(lStack40 + 0x20) &&
              (iVar2 = _libssh2_ntohu32(*(long *)(lStack40 + 0x18) + 5), param_2 == iVar2)))) ||
            ((param_2 == 0 &&
             ((**(char **)(lStack40 + 0x18) == '^' &&
              (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))))))) ||
           ((param_2 == 0 &&
            (((**(char **)(lStack40 + 0x18) == '_' &&
              (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))) &&
             (*(char *)(param_1 + 0x56) == '\x02')))))) {
          uStack48 = param_4 - uStack56;
          bVar6 = (ulong)(*(long *)(lStack40 + 0x20) - *(long *)(lStack40 + 0x28)) <= uStack48;
          if (bVar6) {
            uStack48 = *(long *)(lStack40 + 0x20) - *(long *)(lStack40 + 0x28);
          }
          memcpy((void *)(param_3 + uStack56),
                 (void *)(*(long *)(lStack40 + 0x18) + *(long *)(lStack40 + 0x28)),uStack48);
          *(long *)(lStack40 + 0x28) = *(long *)(lStack40 + 0x28) + uStack48;
          uStack56 = uStack56 + uStack48;
          if (bVar6) {
            _libssh2_list_remove(lStack40);
            ((void*(*)())(lVar1 + 0x18))
                      (*(undefined8 *)(lStack40 + 0x18),lVar1,*(undefined8 *)(lStack40 + 0x18),lVar1
                      );
            ((void*(*)())(lVar1 + 0x18))(lStack40,lVar1,lStack40,lVar1);
          }
        }
      }
    }
    if (uStack56 == 0) {
      if ((*(char *)(param_1 + 0x55) == '\0') && (*(char *)(param_1 + 0x54) == '\0')) {
        if (uVar3 == 0xffffffdb) {
          iVar2 = _libssh2_error(lVar1,0xffffffdb,"would block",0xffffffdb);
          uStack56 = SEXT48(iVar2);
        }
        else {
          uStack56 = 0;
        }
      }
      else {
        uStack56 = 0;
      }
    }
    else {
      *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - (int)uStack56;
      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - (int)uStack56;
    }
  }
  return uStack56;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//longlong strtoll(char *__nptr,char **__endptr,int __base)
//
//{
//  longlong lVar1;
//  
//  lVar1 = strtoll(__nptr,__endptr,__base);
//  return lVar1;
//}
//
//
//
//void ECDSA_SIG_set0(void)
//
//{
//  ECDSA_SIG_set0();
//  return;
//}
//
//
//
//void _libssh2_list_add(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_list_add();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int BIO_free(BIO *a)
//
//{
//  int iVar1;
//  
//  iVar1 = BIO_free(a);
//  return iVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_MD * EVP_sha512(void)
//
//{
//  EVP_MD *pEVar1;
//  
//  pEVar1 = EVP_sha512();
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)
//
//{
//  size_t sVar1;
//  
//  sVar1 = fwrite(__ptr,__size,__n,__s);
//  return sVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int X509_PUBKEY_set(X509_PUBKEY **x,EVP_PKEY *pkey)
//
//{
//  int iVar1;
//  
//  iVar1 = X509_PUBKEY_set(x,pkey);
//  return iVar1;
//}
//
//
//
//void libssh2_poll_channel_read(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_poll_channel_read();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_PKEY_CTX * EVP_PKEY_CTX_new_id(int id,ENGINE *e)
//
//{
//  EVP_PKEY_CTX *pEVar1;
//  
//  pEVar1 = EVP_PKEY_CTX_new_id(id,e);
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//void * realloc(void *__ptr,size_t __size)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = realloc(__ptr,__size);
//  return pvVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_MD * EVP_sha256(void)
//
//{
//  EVP_MD *pEVar1;
//  
//  pEVar1 = EVP_sha256();
//  return pEVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int EVP_DigestInit(EVP_MD_CTX *ctx,EVP_MD *type)
//
//{
//  int iVar1;
//  
//  iVar1 = EVP_DigestInit(ctx,type);
//  return iVar1;
//}
//
//
//
//void libssh2_sftp_seek64(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_sftp_seek64();
//  return;
//}
//
//
//
//void _libssh2_session_set_blocking(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_session_set_blocking();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//rsa_st * EVP_PKEY_get1_RSA(EVP_PKEY *pkey)
//
//{
//  rsa_st *prVar1;
//  
//  prVar1 = EVP_PKEY_get1_RSA(pkey);
//  return prVar1;
//}
undefined8 FUN_0012cc1e(char *param_1,int param_2,FILE *param_3)

{
  undefined8 uVar1;
  char *pcVar2;
  size_t sVar3;
  
  if (param_1 == (char *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    pcVar2 = fgets(param_1,param_2,param_3);
    if (pcVar2 == (char *)0x0) {
      uVar1 = 0xffffffff;
    }
    else {
      if (*param_1 != '\0') {
        sVar3 = strlen(param_1);
        if ((sVar3 != 0) && (param_1[sVar3 - 1] == '\n')) {
          param_1[sVar3 - 1] = '\0';
        }
      }
      if (*param_1 != '\0') {
        sVar3 = strlen(param_1);
        if ((sVar3 != 0) && (param_1[sVar3 - 1] == '\r')) {
          param_1[sVar3 - 1] = '\0';
        }
      }
      uVar1 = 0;
    }
  }
  return uVar1;
}



ulong _libssh2_openssh_pem_parse
                (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  ulong uVar2;
  size_t __n;
  long in_FS_OFFSET;
  uint local_b8;
  uint local_b4;
  long local_b0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_b0 = 0;
  local_b8 = 0;
  do {
    local_98[0] = '\0';
    iVar1 = FUN_0012cc1e(local_98,0x80, 0);
    if (iVar1 != 0) {
      uVar2 = 0xffffffff;
      goto LAB_0012eae6;
    }
    iVar1 = strcmp(local_98,"-----BEGIN OPENSSH PRIVATE KEY-----");
  } while (iVar1 != 0);
  iVar1 = FUN_0012cc1e(local_98,0x80,param_3);
  if (iVar1 == 0) {
    do {
      if (local_98[0] != '\0') {
        __n = strlen(local_98);
        if (local_b0 == 0) {
          local_b0 = ((void*(*)())(param_1 + 8))(__n + local_b8,param_1,param_1,__n + local_b8);
        }
        else {
          local_b0 = ((void*(*)())(param_1 + 0x10))(local_b0,local_b8 + __n,param_1,local_b0);
        }
        if (local_b0 == 0) {
          local_b4 = 0xffffffff;
          goto LAB_0012eae0;
        }
        memcpy((void *)((ulong)local_b8 + local_b0),local_98,__n);
        local_b8 = local_b8 + (int)__n;
      }
      local_98[0] = '\0';
      iVar1 = FUN_0012cc1e(local_98,0x80,param_3);
      if (iVar1 != 0) {
        local_b4 = 0xffffffff;
        goto LAB_0012eae0;
      }
      iVar1 = strcmp(local_98,"-----END OPENSSH PRIVATE KEY-----");
    } while (iVar1 != 0);
    if (local_b0 == 0) {
      uVar2 = 0xffffffff;
    }
    else {
      if (local_b0 != 0) {
        _libssh2_explicit_zero(local_b0,(ulong)local_b8);
        ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
      }
LAB_0012eae0:
      uVar2 = (ulong)local_b4;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
LAB_0012eae6:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}





ulong _libssh2_ed25519_new_private(EVP_PKEY **param_1,long param_2,char *param_3,undefined8 param_4)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  undefined8 uVar4;
  uint uStack52;
  char *pcStack48;
  long lStack40;
  EVP_PKEY *pEStack32;
  FILE *pFStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  lStack40 = 0;
  pEStack32 = (EVP_PKEY *)0x0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    uVar3 = 0xffffffff;
  }
  else {
    _libssh2_init_if_needed();
    pFStack24 = fopen(param_3,"r");
    if (pFStack24 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open ED25519 private key file");
      uVar3 = 0xffffffff;
    }
    else {
      uVar1 = _libssh2_openssh_pem_parse(param_2,param_4,pFStack24,&lStack40);
      fclose(pFStack24);
      if (uVar1 == 0) {
        iVar2 = _libssh2_get_string(lStack40,&pcStack48,0,&pcStack48);
        if ((iVar2 == 0) && (pcStack48 != (char *)0x0)) {
          uVar4 = 0x10c654;
          iVar2 = strcmp("ssh-ed25519",pcStack48);
          if (iVar2 == 0) {
            uStack52 = FUN_0010c0f3(param_2,lStack40,0,0,0,0,&pEStack32);
          }
          else {
            uStack52 = 0xffffffff;
          }
          if (lStack40 != 0) {
            _libssh2_string_buf_free(param_2,lStack40,lStack40);
          }
          if (uStack52 == 0) {
            if (param_1 == (EVP_PKEY **)0x0) {
              if (pEStack32 != (EVP_PKEY *)0x0) {
                EVP_PKEY_free(pEStack32);
              }
            }
            else {
              *param_1 = pEStack32;
            }
          }
          uVar3 = (ulong)uStack52;
        }
        else {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          uVar3 = 0xffffffff;
        }
      }
      else {
        uVar3 = (ulong)uVar1;
      }
    }
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//ECDSA_SIG * ECDSA_do_sign(uchar *dgst,int dgst_len,EC_KEY *eckey)
//
//{
//  ECDSA_SIG *pEVar1;
//  
//  pEVar1 = ECDSA_do_sign(dgst,dgst_len,eckey);
//  return pEVar1;
//}



undefined8 _libssh2_md5_init(EVP_MD_CTX **param_1)

{
  int iVar1;
  EVP_MD_CTX *pEVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  *param_1 = pEVar2;
  if (*param_1 == (EVP_MD_CTX *)0x0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("md5");
    iVar1 = EVP_DigestInit(*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = (EVP_MD_CTX *)0x0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}





// WARNING: Unknown calling convention yet parameter storage is locked



ulong _libssh2_channel_close(long param_1)

{
  long lVar1;
  ulong uVar2;
  uint uStack20;
  
  lVar1 = *(long *)(param_1 + 0x60);
  uStack20 = 0;
  if (*(char *)(param_1 + 0x40) == '\0') {
    if ((*(char *)(param_1 + 0x41) == '\0') && (uStack20 = FUN_00116c6b(param_1), uStack20 != 0)) {
      if (uStack20 == 0xffffffdb) {
        return 0xffffffdb;
      }
      _libssh2_error(lVar1,(ulong)uStack20,"Unable to send EOF, but closing channel anyway",
                     (ulong)uStack20);
    }
    if (*(int *)(param_1 + 0x290) == 0) {
      *(undefined *)(param_1 + 0x294) = 0x61;
      _libssh2_htonu32(param_1 + 0x295,(ulong)*(uint *)(param_1 + 0x44));
      *(undefined4 *)(param_1 + 0x290) = 2;
    }
    if (*(int *)(param_1 + 0x290) == 2) {
      uStack20 = _libssh2_transport_send(lVar1,param_1 + 0x294,5,0,0);
      if (uStack20 == 0xffffffdb) {
        _libssh2_error(lVar1,0xffffffdb,"Would block sending close-channel",0xffffffdb);
        return 0xffffffdb;
      }
      if (uStack20 == 0) {
        *(undefined4 *)(param_1 + 0x290) = 3;
      }
      else {
        _libssh2_error(lVar1,(ulong)uStack20,
                       "Unable to send close-channel request, but closing anyway",(ulong)uStack20);
      }
    }
    if (*(int *)(param_1 + 0x290) == 3) {
      while (((*(char *)(param_1 + 0x54) == '\0' && (uStack20 == 0)) &&
             (*(int *)(lVar1 + 0x22c) != -1))) {
        uStack20 = _libssh2_transport_read(lVar1);
      }
    }
    if (uStack20 != 0xffffffdb) {
      *(undefined *)(param_1 + 0x40) = 1;
      if (*(long *)(param_1 + 0x70) != 0) {
        ((void*(*)())(param_1 + 0x70))(lVar1,lVar1,param_1,param_1 + 0x68);
      }
      *(undefined4 *)(param_1 + 0x290) = 0;
    }
    uVar2 = 0;
    if ((int)uStack20 < 1) {
      uVar2 = (ulong)uStack20;
    }
  }
  else {
    *(undefined4 *)(param_1 + 0x290) = 0;
    uVar2 = 0;
  }
  return uVar2;
}



//void libssh2_session_handshake(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_session_handshake();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

void DSA_SIG_free(DSA_SIG *a)

{
  DSA_SIG_free(a);
  return;
}



undefined8 _libssh2_sha384_init(EVP_MD_CTX **param_1)

{
  int iVar1;
  EVP_MD_CTX *pEVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  *param_1 = pEVar2;
  if (*param_1 == (EVP_MD_CTX *)0x0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha384");
    iVar1 = EVP_DigestInit(*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = (EVP_MD_CTX *)0x0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



// WARNING: Unknown calling convention yet parameter storage is locked

//void * memcpy(void *__dest,void *__src,size_t __n)
//
//{
//  void *pvVar1;
//  
//  pvVar1 = memcpy(__dest,__src,__n);
//  return pvVar1;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//int fcntl(int __fd,int __cmd,...)
//
//{
//  int iVar1;
//  
//  iVar1 = fcntl(__fd,__cmd);
//  return iVar1;
//}
//
//
//
//void libssh2_knownhost_readline(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  libssh2_knownhost_readline();
//  return;
//}



undefined8 _libssh2_sha1(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha1");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



undefined8
_libssh2_ed25519_sign
          (EVP_PKEY *param_1,long param_2,long *param_3,long *param_4,undefined8 param_5,
          undefined8 param_6)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int iStack44;
  long lStack40;
  long lStack32;
  EVP_MD_CTX *pEStack24;
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  iStack44 = -1;
  pEStack24 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  lStack40 = 0;
  lStack32 = 0;
  if (pEStack24 != (EVP_MD_CTX *)0x0) {
    iVar1 = EVP_DigestSignInit(pEStack24,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,param_1);
    if ((((iVar1 != 1) ||
         (iVar1 = EVP_DigestSign(pEStack24,0,&lStack40,param_5,param_6), iVar1 != 1)) ||
        (lStack40 != 0x40)) || (lStack32 = _libssh2_calloc(param_2,0x40), lStack32 == 0))
    goto LAB_0010df22;
    iStack44 = EVP_DigestSign(pEStack24,lStack32,&lStack40,param_5,param_6);
  }
  if (iStack44 == 1) {
    *param_3 = lStack32;
    *param_4 = lStack40;
  }
  else {
    *param_4 = 0;
    *param_3 = 0;
    ((void*(*)())(param_2 + 0x18))(lStack32,param_2,lStack32,param_2);
  }
LAB_0010df22:
  if (pEStack24 != (EVP_MD_CTX *)0x0) {
    EVP_MD_CTX_free(pEStack24);
  }
  if (iStack44 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



//void _libssh2_ntohu64(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_ntohu64();
//  return;
//}
//


//void _libssh2_packet_ask(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_packet_ask();
//  return;
//}



//undefined8
//_libssh2_dsa_sha1_verify(DSA *param_1,uchar *param_2,undefined8 param_3,undefined4 param_4)
//
//{
//  int iVar1;
//  BIGNUM *ret;
//  BIGNUM *ret_00;
//  DSA_SIG *sig;
//  unsigned uVar2;
//  long in_FS_OFFSET;
//  int iStack68;
//  uchar auStack40 [24];
//  long lStack16;
//  
//  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
//  iStack68 = -1;
//  ret = BN_new();
//  BN_bin2bn(param_2,0x14,ret);
//  ret_00 = BN_new();
//  BN_bin2bn(param_2 + 0x14,0x14,ret_00);
//  sig = DSA_SIG_new();
//  DSA_SIG_set0(sig,ret,ret_00,ret);
//  iVar1 = _libssh2_sha1(param_3,param_4,auStack40);
//  if (iVar1 == 0) {
//    iStack68 = DSA_do_verify(auStack40,0x14,sig);
//  }
//  DSA_SIG_free(sig);
//  if (iStack68 == 1) {
//    uVar2 = 0;
//  }
//  else {
//    uVar2 = 0xffffffff;
//  }
//  if (lStack16 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar2;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}



// WARNING: Unknown calling convention yet parameter storage is locked

//DSA * DSA_new(void)
//
//{
//  DSA *pDVar1;
//  
//  pDVar1 = DSA_new();
//  return pDVar1;
//}
//
//
//
//void RSA_get0_key(void)
//
//{
//  RSA_get0_key();
//  return;
//}



undefined8 _libssh2_sha256(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha256");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



//void _libssh2_check_length(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_check_length();
//  return;
//}



void EVP_DigestVerify(void)

{
  EVP_DigestVerify();
  return;
}



undefined8
_libssh2_channel_open
          (long param_1,void *param_2,uint param_3,uint param_4,uint param_5,undefined8 param_6,
          undefined8 param_7)

{
  long lVar1;
  undefined *puVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  undefined *puStack48;
  undefined auStack36 [4];
  long lStack32;
  
  lStack32 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd1e8) == 0) {
    *(undefined8 *)(param_1 + 0xd1f8) = 0;
    *(undefined8 *)(param_1 + 0xd200) = 0;
    *(undefined8 *)(param_1 + 0xd210) = 0;
    *(ulong *)(param_1 + 0xd208) = (ulong)(param_3 + 0x11);
    uVar3 = _libssh2_channel_nextid(param_1);
    *(undefined4 *)(param_1 + 0xd220) = uVar3;
    memset((void *)(param_1 + 0xd1f0),0,8);
    uVar6 = _libssh2_calloc(param_1,0x2f0);
    *(undefined8 *)(param_1 + 0xd1f8) = uVar6;
    if (*(long *)(param_1 + 0xd1f8) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate space for channel data");
      uVar6 = 0;
      goto LAB_001132fc;
    }
    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x20) = param_3;
    lVar1 = *(long *)(param_1 + 0xd1f8);
    uVar6 = ((void*(*)())(param_1 + 8))((ulong)param_3,param_1,(ulong)param_3,param_1);
    *(undefined8 *)(lVar1 + 0x18) = uVar6;
    if (*(long *)(*(long *)(param_1 + 0xd1f8) + 0x18) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Failed allocating memory for channel type name");
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd1f8),param_1,*(undefined8 *)(param_1 + 0xd1f8),param_1
                );
      *(undefined8 *)(param_1 + 0xd1f8) = 0;
      uVar6 = 0;
      goto LAB_001132fc;
    }
    memcpy(*(void **)(*(long *)(param_1 + 0xd1f8) + 0x18),param_2,(ulong)param_3);
    *(undefined4 *)(*(long *)(param_1 + 0xd1f8) + 0x30) = *(undefined4 *)(param_1 + 0xd220);
    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x4c) = param_4;
    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x48) = param_4;
    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x50) = param_5;
    *(long *)(*(long *)(param_1 + 0xd1f8) + 0x60) = param_1;
    _libssh2_list_add(param_1 + 0x200,*(undefined8 *)(param_1 + 0xd1f8));
    uVar6 = ((void*(*)())(param_1 + 8))
                      (*(undefined8 *)(param_1 + 0xd208),param_1,*(undefined8 *)(param_1 + 0xd208),
                       param_1);
    *(undefined8 *)(param_1 + 0xd200) = uVar6;
    puVar2 = *(undefined **)(param_1 + 0xd200);
    if (*(long *)(param_1 + 0xd200) != 0) {
      puStack48 = puVar2 + 1;
      *puVar2 = 0x5a;
      _libssh2_store_str(&puStack48,param_2,(ulong)param_3);
      _libssh2_store_u32(&puStack48,(ulong)*(uint *)(param_1 + 0xd220));

      _libssh2_store_u32(&puStack48,(ulong)param_4);
      _libssh2_store_u32(&puStack48,(ulong)param_5);
      *(undefined4 *)(param_1 + 0xd1e8) = 2;
      goto LAB_00112d7b;
    }
    puStack48 = puVar2;
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate temporary space for packet");
  }
  else {
LAB_00112d7b:
    if (*(int *)(param_1 + 0xd1e8) == 2) {
      uVar4 = _libssh2_transport_send
                        (param_1,*(undefined8 *)(param_1 + 0xd200),*(undefined8 *)(param_1 + 0xd208)
                         ,param_6,param_7);
      if (uVar4 == 0xffffffdb) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending channel-open request",0xffffffdb);
        uVar6 = 0;
        goto LAB_001132fc;
      }
      if (uVar4 != 0) {
        _libssh2_error(param_1,(ulong)uVar4,"Unable to send channel-open request",(ulong)uVar4);
        goto LAB_00113121;
      }
      *(undefined4 *)(param_1 + 0xd1e8) = 3;
    }
    if (*(int *)(param_1 + 0xd1e8) == 3) {
      uVar4 = _libssh2_packet_requirev
                        (param_1,&DAT_0014667a,param_1 + 0xd210,param_1 + 0xd218,1,
                         *(long *)(param_1 + 0xd200) + (ulong)param_3 + 5,4,param_1 + 0xd1f0);
      if (uVar4 == 0xffffffdb) {
        _libssh2_error(param_1,0xffffffdb,"Would block");
        uVar6 = 0;
        goto LAB_001132fc;
      }
      if (uVar4 == 0) {
        if (*(long *)(param_1 + 0xd218) == 0) {
          _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
        }
        else {
          if (**(char **)(param_1 + 0xd210) == '[') {
            if (0x10 < *(ulong *)(param_1 + 0xd218)) {
              lVar1 = *(long *)(param_1 + 0xd1f8);
              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 5);
              *(undefined4 *)(lVar1 + 0x44) = uVar3;
              lVar1 = *(long *)(param_1 + 0xd1f8);
              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 9);
              *(undefined4 *)(lVar1 + 0x38) = uVar3;
              lVar1 = *(long *)(param_1 + 0xd1f8);
              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 9);
              *(undefined4 *)(lVar1 + 0x34) = uVar3;
              lVar1 = *(long *)(param_1 + 0xd1f8);
              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 0xd);
              *(undefined4 *)(lVar1 + 0x3c) = uVar3;
              ((void*(*)())(param_1 + 0x18))
                        (*(undefined8 *)(param_1 + 0xd200),param_1,*(undefined8 *)(param_1 + 0xd200)
                         ,param_1);
              *(undefined8 *)(param_1 + 0xd200) = 0;
              ((void*(*)())(param_1 + 0x18))
                        (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210)
                         ,param_1);
              *(undefined8 *)(param_1 + 0xd210) = 0;
              *(undefined4 *)(param_1 + 0xd1e8) = 0;
              uVar6 = *(undefined8 *)(param_1 + 0xd1f8);
              goto LAB_001132fc;
            }
            _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
          }
          else {
            if (**(char **)(param_1 + 0xd210) == '\\') {
              uVar4 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 5);
              if (uVar4 == 2) {
                _libssh2_error(param_1,0xffffffeb,"Channel open failure (connect failed)");
              }
              else {
                if (uVar4 < 3) {
                  if (uVar4 == 1) {
                    _libssh2_error(param_1,0xffffffeb,
                                   "Channel open failure (administratively prohibited)");
                  }
                  else {
LAB_00113106:
                    _libssh2_error(param_1,0xffffffeb,"Channel open failure");
                  }
                }
                else {
                  if (uVar4 == 3) {
                    _libssh2_error(param_1,0xffffffeb,"Channel open failure (unknown channel type)")
                    ;
                  }
                  else {
                    if (uVar4 != 4) goto LAB_00113106;
                    _libssh2_error(param_1,0xffffffeb,"Channel open failure (resource shortage)");
                  }
                }
              }
            }
          }
        }
      }
      else {
        _libssh2_error(param_1,(ulong)uVar4,"Unexpected error",(ulong)uVar4);
      }
    }
  }
LAB_00113121:
  if (*(long *)(param_1 + 0xd210) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210),param_1);
    *(undefined8 *)(param_1 + 0xd210) = 0;
  }
  if (*(long *)(param_1 + 0xd200) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd200),param_1,*(undefined8 *)(param_1 + 0xd200),param_1);
    *(undefined8 *)(param_1 + 0xd200) = 0;
  }
  if (*(long *)(param_1 + 0xd1f8) != 0) {
    uVar6 = *(undefined8 *)(*(long *)(param_1 + 0xd1f8) + 0x18);
    ((void*(*)())(param_1 + 0x18))(uVar6,param_1,uVar6,param_1);
    _libssh2_list_remove(*(undefined8 *)(param_1 + 0xd1f8));
    uVar4 = *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x30);
    uVar6 = 0x113203;
    _libssh2_htonu32(auStack36,(ulong)uVar4);
    while ((iVar5 = _libssh2_packet_ask(param_1,0x5e,param_1 + 0xd210,param_1 + 0xd218,1,auStack36,4
                                        ), -1 < iVar5 ||
           (iVar5 = _libssh2_packet_ask(param_1,0x5f,param_1 + 0xd210,param_1 + 0xd218,1,auStack36,4
                                        ), -1 < iVar5))) {
      uVar6 = 0x113224;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210),param_1
                );
      *(undefined8 *)(param_1 + 0xd210) = 0;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd1f8),param_1,*(undefined8 *)(param_1 + 0xd1f8),param_1);
    *(undefined8 *)(param_1 + 0xd1f8) = 0;
  }
  *(undefined4 *)(param_1 + 0xd1e8) = 0;
  uVar6 = 0;
LAB_001132fc:
  if (lStack32 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

//time_t time(time_t *__timer)
//
//{
//  time_t tVar1;
//  
//  tVar1 = time(__timer);
//  return tVar1;
//}
//


void Blowfish_encipher(long param_1,uint *param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  
  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1000);
  uVar2 = *param_3 ^
          *(uint *)(param_1 + 0x1004) ^
          (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1008) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x100c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1010) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1014) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1018) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x101c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1020) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1024) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1028) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x102c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1030) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1034) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1038) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x103c) ^
                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  iVar3 = *(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4);
  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar7 = *(uint *)(param_1 + 0x1040);
  *param_2 = *(uint *)(param_1 + 0x1044) ^ uVar2;
  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a)

{
  PKCS8_PRIV_KEY_INFO_free(a);
  return;
}



//void _libssh2_packet_askv(void)
//
//{
//                    // WARNING: Treating indirect jump as call
//  _libssh2_packet_askv();
//  return;
//}



// WARNING: Unknown calling convention yet parameter storage is locked

int ASN1_STRING_length(ASN1_STRING *x)

{
  int iVar1;
  
  iVar1 = ASN1_STRING_length(x);
  return iVar1;
}



ulong _libssh2_ecdh_gen_k(BIGNUM **param_1,EC_KEY *param_2,uchar *param_3,size_t param_4)

{
  int iVar1;
  int iVar2;
  uint len;
  BN_CTX *ctx;
  ulong uVar3;
  EC_GROUP *group;
  EC_POINT *p;
  uint uStack56;
  uchar *puStack48;
  
  uStack56 = 0;
  puStack48 = (uchar *)0x0;
  ctx = BN_CTX_new();
  if (ctx == (BN_CTX *)0x0) {
    uVar3 = 0xffffffff;
  }
  else {
    if (param_1 == (BIGNUM **)0x0) {
      uVar3 = 0xffffffff;
    }
    else {
      group = EC_KEY_get0_group(param_2);
      p = EC_POINT_new(group);
      if (p == (EC_POINT *)0x0) {
        uVar3 = 0xffffffff;
      }
      else {
        iVar1 = EC_POINT_oct2point(group,p,param_3,param_4,ctx);
        if (iVar1 == 1) {
          iVar2 = EC_GROUP_get_degree(group);
          iVar1 = iVar2 + 7;
          if (iVar2 + 7 < 0) {
            iVar1 = iVar2 + 0xe;
          }
          puStack48 = (uchar *)malloc((long)(iVar1 >> 3));
          if (puStack48 == (uchar *)0x0) {
            uStack56 = 0xffffffff;
          }
          else {
            len = ECDH_compute_key(puStack48,(long)(iVar1 >> 3),p,param_2, 0x0);
            if ((len == 0) || (0x85 < len)) {
              uStack56 = 0xffffffff;
            }
            else {
              BN_bin2bn(puStack48,len,*param_1);
            }
          }
        }
        else {
          uStack56 = 0xffffffff;
        }
        if (p != (EC_POINT *)0x0) {
          EC_POINT_free(p);
        }
        if (ctx != (BN_CTX *)0x0) {
          BN_CTX_free(ctx);
        }
        if (puStack48 != (uchar *)0x0) {
          free(puStack48);
        }
        uVar3 = (ulong)uStack56;
      }
    }
  }
  return uVar3;
}



//void __cxa_finalize(void)
//
//{
//  __cxa_finalize();
//  return;
//}
//
//
//
//// WARNING: Unknown calling convention yet parameter storage is locked
//
//EVP_PKEY * PEM_read_bio_PrivateKey(BIO *bp,EVP_PKEY **x,undefined1 *cb,void *u)
//
//{
//  EVP_PKEY *pEVar1;
//  
//  pEVar1 = PEM_read_bio_PrivateKey(bp,x,cb,u);
//  return pEVar1;
//}
//
//
//
//// WARNING: Removing unreachable block (ram,0x00109af7)
//// WARNING: Removing unreachable block (ram,0x00109b03)
//
//void entry(void)
//
//{
//  return;
//}
//
//
//
//void _FINI_0(void)
//
//{
//  if (_edata != '\0') {
//    return;
//  }
//  __cxa_finalize(PTR_LOOP_00350900);
//  entry();
//  _edata = 1;
//  return;
//}
//
//
//
//// WARNING: Removing unreachable block (ram,0x00109b48)
//// WARNING: Removing unreachable block (ram,0x00109b54)
//
//void _INIT_0(void)
//
//{
//  return;
//}





//undefined8
//_libssh2_rsa_new(RSA **param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,uchar *param_6,
//                int param_7,uchar *param_8,int param_9,uchar *param_10,int param_11,uchar *param_12,
//                int param_13,uchar *param_14,int param_15,uchar *param_16,int param_17)
//
//{
//  BIGNUM *ret;
//  BIGNUM *ret_00;
//  RSA *pRVar1;
//  BIGNUM *local_48;
//  BIGNUM *local_40;
//  BIGNUM *local_38;
//  BIGNUM *local_30;
//  BIGNUM *local_28;
//  BIGNUM *local_20;
//  
//  local_48 = (BIGNUM *)0x0;
//  local_40 = (BIGNUM *)0x0;
//  local_38 = (BIGNUM *)0x0;
//  local_30 = (BIGNUM *)0x0;
//  local_28 = (BIGNUM *)0x0;
//  local_20 = (BIGNUM *)0x0;
//  ret = BN_new();
//  BN_bin2bn(param_2,param_3,ret);
//  ret_00 = BN_new();
//  BN_bin2bn(param_4,param_5,ret_00);
//  if (param_6 != (uchar *)0x0) {
//    local_48 = BN_new();
//    BN_bin2bn(param_6,param_7,local_48);
//    local_40 = BN_new();
//    BN_bin2bn(param_8,param_9,local_40);
//    local_38 = BN_new();
//    BN_bin2bn(param_10,param_11,local_38);
//    local_30 = BN_new();
//    BN_bin2bn(param_12,param_13,local_30);
//    local_28 = BN_new();
//    BN_bin2bn(param_14,param_15,local_28);
//    local_20 = BN_new();
//    BN_bin2bn(param_16,param_17,local_20);
//  }
//  pRVar1 = RSA_new();
//  *param_1 = pRVar1;
//  RSA_set0_key(*param_1,ret_00,ret,local_48);
//  RSA_set0_factors(*param_1,local_40,local_38,local_40);
//  RSA_set0_crt_params(*param_1,local_30,local_28,local_20);
//  return 0;
//}
//


//undefined8 _libssh2_rsa_sha1_verify(RSA *param_1,uchar *param_2,uint param_3,undefined8 param_4,undefined8 param_5)
//{
//  int iVar1;
//  undefined8 uVar2;
//  long in_FS_OFFSET;
//  uchar local_28 [24];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  iVar1 = _libssh2_sha1(param_4,param_5,local_28);
//  if (iVar1 == 0) {
//    iVar1 = RSA_verify(0x40,local_28,0x14,param_2,param_3,param_1);
//    if (iVar1 == 1) {
//      uVar2 = 0;
//    }
//    else {
//      uVar2 = 0xffffffff;
//    }
//  }
//  else {
//    uVar2 = 0xffffffff;
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar2;
//}



//undefined8
//_libssh2_dsa_new(DSA **param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,uchar *param_6,
//                int param_7,uchar *param_8,int param_9,uchar *param_10,long param_11)
//
//{
//  BIGNUM *ret;
//  BIGNUM *ret_00;
//  BIGNUM *ret_01;
//  BIGNUM *ret_02;
//  DSA *pDVar1;
//  BIGNUM *local_30;
//  
//  local_30 = (BIGNUM *)0x0;
//  ret = BN_new();
//  BN_bin2bn(param_2,param_3,ret);
//  ret_00 = BN_new();
//  BN_bin2bn(param_4,param_5,ret_00);
//  ret_01 = BN_new();
//  BN_bin2bn(param_6,param_7,ret_01);
//  ret_02 = BN_new();
//  BN_bin2bn(param_8,param_9,ret_02);
//  if (param_11 != 0) {
//    local_30 = BN_new();
//    BN_bin2bn(param_10,(int)param_11,local_30);
//  }
//  pDVar1 = DSA_new();
//  *param_1 = pDVar1;
//  DSA_set0_pqg(*param_1,ret,ret_00,ret_01);
//  DSA_set0_key(*param_1,ret_02,local_30,ret_02);
//  return 0;
//}
//


undefined8
_libssh2_dsa_sha1_verify(DSA *param_1,uchar *param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  BIGNUM *ret;
  BIGNUM *ret_00;
  DSA_SIG *sig;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_44;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_44 = -1;
  ret = BN_new();
  BN_bin2bn(param_2,0x14,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_2 + 0x14,0x14,ret_00);
  sig = DSA_SIG_new();
  DSA_SIG_set0(sig,ret,ret_00,ret);
  iVar1 = _libssh2_sha1(param_3,param_4,local_28);
  if (iVar1 == 0) {
    local_44 = DSA_do_verify(local_28,0x14,sig,param_1);
  }
  DSA_SIG_free(sig);
  if (local_44 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



void _libssh2_ecdsa_get_curve_type(EC_KEY *param_1)

{
  EC_GROUP *group;
  
  group = EC_KEY_get0_group(param_1);
  EC_GROUP_get_curve_name(group);
  return;
}



ulong _libssh2_ecdsa_curve_type_from_name(char *param_1,undefined4 *param_2)

{
  int iVar1;
  size_t sVar2;
  uint local_10;
  undefined4 local_c;
  
  local_10 = 0;
  if ((param_1 != (char *)0x0) && (sVar2 = strlen(param_1), sVar2 == 0x13)) {
    iVar1 = strcmp(param_1,"ecdsa-sha2-nistp256");
    if (iVar1 == 0) {
      local_c = 0x19f;
    }
    else {
      iVar1 = strcmp(param_1,"ecdsa-sha2-nistp384");
      if (iVar1 == 0) {
        local_c = 0x2cb;
      }
      else {
        iVar1 = strcmp(param_1,"ecdsa-sha2-nistp521");
        if (iVar1 == 0) {
          local_c = 0x2cc;
        }
        else {
          local_10 = 0xffffffff;
        }
      }
    }
    if ((local_10 == 0) && (param_2 != (undefined4 *)0x0)) {
      *param_2 = local_c;
    }
    return (ulong)local_10;
  }
  return 0xffffffff;
}



//undefined8
//_libssh2_ecdsa_curve_name_with_octal_new(EC_KEY **param_1,uchar *param_2,size_t param_3,int param_4)
//
//{
//  EC_KEY *key;
//  EC_GROUP *group;
//  EC_POINT *p;
//  undefined8 uVar1;
//  int local_24;
//  
//  local_24 = 0;
//  key = EC_KEY_new_by_curve_name(param_4);
//  if (key != (EC_KEY *)0x0) {
//    group = EC_KEY_get0_group(key);
//    p = EC_POINT_new(group);
//    EC_POINT_oct2point(group,p,param_2,param_3,(BN_CTX *)0x0);
//    local_24 = EC_KEY_set_public_key(key,p);
//    if (p != (EC_POINT *)0x0) {
//      EC_POINT_free(p);
//    }
//    if (param_1 != (EC_KEY **)0x0) {
//      *param_1 = key;
//    }
//  }
//  if (local_24 == 1) {
//    uVar1 = 0;
//  }
//  else {
//    uVar1 = 0xffffffff;
//  }
//  return uVar1;
//}
//


//undefined8
//_libssh2_ecdsa_verify
//          (EC_KEY *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,undefined8 param_6,
//          undefined8 param_7)
//
//{
//  int iVar1;
//  ECDSA_SIG *sig;
//  BIGNUM *ret;
//  BIGNUM *ret_00;
//  undefined8 uVar2;
//  long in_FS_OFFSET;
//  int local_80;
//  uchar local_58 [72];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_80 = 0;
//  iVar1 = _libssh2_ecdsa_get_curve_type(param_1);
//  sig = ECDSA_SIG_new();
//  ret = BN_new();
//  ret_00 = BN_new();
//  BN_bin2bn(param_2,param_3,ret);
//  BN_bin2bn(param_4,param_5,ret_00);
//  ECDSA_SIG_set0(sig,ret,ret_00,ret);
//  if (iVar1 == 0x19f) {
//    _libssh2_sha256(param_6,param_7,local_58);
//    local_80 = ECDSA_do_verify(local_58,0x20,sig,param_1);
//  }
//  else {
//    if (iVar1 == 0x2cb) {
//      _libssh2_sha384(param_6,param_7,local_58);
//      local_80 = ECDSA_do_verify(local_58,0x30,sig,param_1);
//    }
//    else {
//      if (iVar1 == 0x2cc) {
//        _libssh2_sha512(param_6,param_7,local_58);
//        local_80 = ECDSA_do_verify(local_58,0x40,sig,param_1);
//      }
//    }
//  }
//  if (sig != (ECDSA_SIG *)0x0) {
//    ECDSA_SIG_free(sig);
//  }
//  if (local_80 == 1) {
//    uVar2 = 0;
//  }
//  else {
//    uVar2 = 0xffffffff;
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar2;
//}



//ulong _libssh2_cipher_init
//                (EVP_CIPHER_CTX **param_1, void* (*param_2)(),uchar *param_3,uchar *param_4,int param_5)
//
//{
//  int iVar1;
//  EVP_CIPHER_CTX *pEVar2;
//  EVP_CIPHER *cipher;
//  
//  pEVar2 = EVP_CIPHER_CTX_new();
//  *param_1 = pEVar2;
//  cipher = (EVP_CIPHER *)(*param_2)();
//  iVar1 = EVP_CipherInit(*param_1,cipher,param_4,param_3,param_5);
//  return (ulong)(iVar1 == 0);
//}
//
//
//
//ulong _libssh2_cipher_crypt
//                (EVP_CIPHER_CTX **param_1,undefined8 param_2,undefined8 param_3,uchar *param_4,
//                size_t param_5)
//
//{
//  int iVar1;
//  long in_FS_OFFSET;
//  uchar local_38 [40];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  iVar1 = EVP_Cipher(*param_1,local_38,param_4,(uint)param_5);
//  if (iVar1 == 1) {
//    memcpy(param_4,local_38,param_5);
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return (ulong)(iVar1 != 1);
//}
//


void _libssh2_openssl_crypto_init(void)

{
  ENGINE_load_builtin_engines();
  ENGINE_register_all_complete();
  return;
}



void _libssh2_openssl_crypto_exit(void)

{
  return;
}








//ulong _libssh2_rsa_new_private_frommemory
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//                undefined8 param_5)
//
//{
//  uint local_14;
//  
//  _libssh2_init_if_needed();
//  local_14 = FUN_0010a5b8(param_1,PEM_read_bio_RSAPrivateKey,param_3,param_4,param_5);
//  if (local_14 != 0) {
//    local_14 = read_openssh_private_key_from_memory
//                         (param_1,param_2,"ssh-rsa",param_3,param_4,param_5);
//  }
//  return (ulong)local_14;
//}



long FUN_0010a76f(long param_1,undefined8 param_2,long *param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  long lVar5;
  long in_FS_OFFSET;
  BIGNUM *local_38;
  BIGNUM *local_30;
  long local_28;
  long local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  RSA_get0_key(param_2,&local_30,&local_38,0);
  iVar1 = BN_num_bits(local_38);
  iVar2 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar2 = iVar1 + 0xe;
  }
  iVar3 = BN_num_bits(local_30);
  iVar1 = iVar3 + 7;
  if (iVar3 + 7 < 0) {
    iVar1 = iVar3 + 0xe;
  }
  uVar4 = (iVar1 >> 3) + 1;
  local_28 = (long)(int)(uVar4 + (iVar2 >> 3) + 0x14);
  local_20 = ((void*(*)())(param_1 + 8))(local_28,param_1,local_28,param_1);
  if (local_20 == 0) {
    lVar5 = 0;
  }
  else {
    local_18 = (void *)local_20;
    _libssh2_htonu32(local_20,7);
    local_18 = (void *)((long)local_18 + 4);
    memcpy(local_18,"ssh-rsa",7);
    local_18 = (void *)((long)local_18 + 7);
    local_18 = (void *)FUN_00109bba(local_18,local_38,(ulong)((iVar2 >> 3) + 1),local_38);
    local_18 = (void *)FUN_00109bba(local_18,local_30,(ulong)uVar4,local_30);
    *param_3 = (long)local_18 - local_20;
    lVar5 = local_20;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar5;
}





ulong FUN_0010aa25(undefined8 param_1)

{
  int iVar1;
  ulong uVar2;
  BIGNUM *b;
  long in_FS_OFFSET;
  uint local_4c;
  BIGNUM *local_48;
  BIGNUM *local_40;
  BIGNUM *local_38;
  BIGNUM *local_30;
  BIGNUM *local_28;
  BN_CTX *local_20;
  BIGNUM *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (BN_CTX *)0x0;
  local_18 = (BIGNUM *)0x0;
  local_30 = (BIGNUM *)0x0;
  local_28 = (BIGNUM *)0x0;
  local_48 = (BIGNUM *)0x0;
  local_40 = (BIGNUM *)0x0;
  local_38 = (BIGNUM *)0x0;
  local_4c = 0;
  RSA_get0_key(param_1,0,0,&local_38);
  RSA_get0_factors(param_1,&local_48,&local_40,&local_48);
  local_20 = BN_CTX_new();
  if (local_20 == (BN_CTX *)0x0) {
    uVar2 = 0xffffffff;
    goto LAB_0010ac17;
  }
  local_18 = BN_new();
  if (local_18 == (BIGNUM *)0x0) {
    local_4c = 0xffffffff;
  }
  else {
    local_30 = BN_new();
    if (local_30 == (BIGNUM *)0x0) {
      local_4c = 0xffffffff;
    }
    else {
      local_28 = BN_new();
      if (local_28 == (BIGNUM *)0x0) {
        local_4c = 0xffffffff;
      }
      else {
        b = BN_value_one();
        iVar1 = BN_sub(local_18,local_40,b);
        if (iVar1 != 0) {
          iVar1 = BN_div((BIGNUM *)0x0,local_28,local_38,local_18,local_20);
          if (iVar1 != 0) {
            b = BN_value_one();
            iVar1 = BN_sub(local_18,local_48,b);
            if (iVar1 != 0) {
              iVar1 = BN_div((BIGNUM *)0x0,local_30,local_38,local_18,local_20);
              if (iVar1 != 0) {
                RSA_set0_crt_params(param_1,local_30,local_28,0);
                goto LAB_0010abc9;
              }
            }
          }
        }
        local_4c = 0xffffffff;
      }
    }
  }
LAB_0010abc9:
  if (local_18 != (BIGNUM *)0x0) {
    BN_clear_free(local_18);
  }
  BN_CTX_free(local_20);
  if (local_4c != 0) {
    if (local_30 != (BIGNUM *)0x0) {
      BN_clear_free(local_30);
    }
    if (local_28 != (BIGNUM *)0x0) {
      BN_clear_free(local_28);
    }
  }
  uVar2 = (ulong)local_4c;
LAB_0010ac17:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong FUN_0010ac2d(undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,
                  long param_5,undefined8 param_6,RSA **param_7)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  undefined8 uVar3;
  uint local_b4;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined local_80 [8];
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined local_48 [8];
  RSA *local_40;
  EVP_PKEY *local_38;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = (RSA *)0x0;
  iVar1 = _libssh2_get_bignum_bytes(param_2,&local_78,&local_b0);
  if (iVar1 == 0) {
    iVar1 = _libssh2_get_bignum_bytes(param_2,&local_70,&local_a8);
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_bignum_bytes(param_2,&local_68,&local_a0);
      if (iVar1 == 0) {
        iVar1 = _libssh2_get_bignum_bytes(param_2,&local_50,&local_88);
        if (iVar1 == 0) {
          iVar1 = _libssh2_get_bignum_bytes(param_2,&local_60,&local_98);
          if (iVar1 == 0) {
            iVar1 = _libssh2_get_bignum_bytes(param_2,&local_58,&local_90);
            if (iVar1 == 0) {
              uVar3 = 0x10ae50;
              iVar1 = _libssh2_get_string(param_2,local_48,local_80,local_48);
              if (iVar1 == 0) {
                local_b4 = _libssh2_rsa_new(&local_40,local_70,local_a8,local_78,local_b0,local_68,
                                            local_a0,local_60,local_98,local_58,local_90,0,0,0,0,
                                            local_50,local_88);
                if (local_b4 == 0) {
                  if (local_40 != (RSA *)0x0) {
                    local_b4 = FUN_0010aa25(local_40);
                  }
                  if (((local_40 != (RSA *)0x0) && (param_5 != 0)) && (param_3 != 0)) {
                    local_38 = EVP_PKEY_new();
                    EVP_PKEY_set1_RSA(local_38,(rsa_st *)local_40);
                    local_b4 = FUN_0010a8ca(param_1,param_3,param_4,param_5,param_6,local_38);
                    if (local_38 != (EVP_PKEY *)0x0) {
                      EVP_PKEY_free(local_38);
                    }
                  }
                  if (param_7 == (RSA **)0x0) {
                    RSA_free(local_40);
                  }
                  else {
                    *param_7 = local_40;
                  }
                  uVar2 = (ulong)local_b4;
                }
                else {
                  if (local_40 != (RSA *)0x0) {
                    RSA_free(local_40);
                  }
                  uVar2 = _libssh2_error(param_1,0xfffffffa,
                                         "Unable to allocate memory for private key data");
                }
              }
              else {
                _libssh2_error(param_1,0xfffffff2,"RSA no comment");
                uVar2 = 0xffffffff;
              }
            }
            else {
              _libssh2_error(param_1,0xfffffff2,"RSA no q");
              uVar2 = 0xffffffff;
            }
          }
          else {
            _libssh2_error(param_1,0xfffffff2,"RSA no p");
            uVar2 = 0xffffffff;
          }
        }
        else {
          _libssh2_error(param_1,0xfffffff2,"RSA no coeff");
          uVar2 = 0xffffffff;
        }
      }
      else {
        _libssh2_error(param_1,0xfffffff2,"RSA no d");
        uVar2 = 0xffffffff;
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"RSA no e");
      uVar2 = 0xffffffff;
    }
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"RSA no n");
    uVar2 = 0xffffffff;
  }
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong FUN_0010b01b(undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  undefined8 uVar4;
  uint local_2c;
  char *local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char *)0x0;
  local_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    uVar3 = 0xffffffff;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH RSA private key file");
      uVar3 = 0xffffffff;
    }
    else {
      uVar1 = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_20);
      fclose(local_18);
      if (uVar1 == 0) {
        iVar2 = _libssh2_get_string(local_20,&local_28,0,&local_28);
        if ((iVar2 == 0) && (local_28 != (char *)0x0)) {
          uVar4 = 0x10b151;
          iVar2 = strcmp("ssh-rsa",local_28);
          if (iVar2 == 0) {
            local_2c = FUN_0010ac2d(param_2,local_20,0,0,0,0,param_1);
          }
          else {
            local_2c = 0xffffffff;
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_2,local_20,local_20);
          }
          uVar3 = (ulong)local_2c;
        }
        else {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          uVar3 = 0xffffffff;
        }
      }
      else {
        uVar3 = (ulong)uVar1;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



//ulong _libssh2_rsa_new_private
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)
//
//{
//  uint local_14;
//  
//  _libssh2_init_if_needed();
//  local_14 = FUN_0010a652(param_1,PEM_read_bio_RSAPrivateKey,param_3,param_4);
//  if (local_14 != 0) {
//    local_14 = FUN_0010b01b(param_1,param_2,param_3,param_4);
//  }
//  return (ulong)local_14;
//}



//ulong _libssh2_dsa_new_private_frommemory
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//                undefined8 param_5)
//
//{
//  uint local_14;
//  
//  _libssh2_init_if_needed();
//  local_14 = FUN_0010a5b8(param_1,PEM_read_bio_DSAPrivateKey,param_3,param_4,param_5);
//  if (local_14 != 0) {
//    local_14 = read_openssh_private_key_from_memory
//                         (param_1,param_2,"ssh-dsa",param_3,param_4,param_5);
//  }
//  return (ulong)local_14;
//}



long FUN_0010b2b8(long param_1,undefined8 param_2,long *param_3)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  long lVar7;
  long in_FS_OFFSET;
  BIGNUM *local_48;
  BIGNUM *local_40;
  BIGNUM *local_38;
  BIGNUM *local_30;
  long local_28;
  long local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  DSA_get0_pqg(param_2,&local_48,&local_40,&local_38);
  DSA_get0_key(param_2,&local_30,0,&local_30);
  iVar1 = BN_num_bits(local_48);
  iVar2 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar2 = iVar1 + 0xe;
  }
  uVar3 = (iVar2 >> 3) + 1;
  iVar1 = BN_num_bits(local_40);
  iVar2 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar2 = iVar1 + 0xe;
  }
  uVar4 = (iVar2 >> 3) + 1;
  iVar1 = BN_num_bits(local_38);
  iVar2 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar2 = iVar1 + 0xe;
  }
  uVar5 = (iVar2 >> 3) + 1;
  iVar1 = BN_num_bits(local_30);
  iVar2 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar2 = iVar1 + 0xe;
  }
  uVar6 = (iVar2 >> 3) + 1;
  local_28 = (long)(int)(uVar6 + uVar5 + uVar4 + uVar3 + 0x1b);
  local_20 = ((void*(*)())(param_1 + 8))(local_28,param_1,local_28,param_1);
  if (local_20 == 0) {
    lVar7 = 0;
  }
  else {
    local_18 = (void *)local_20;
    _libssh2_htonu32(local_20,7);
    local_18 = (void *)((long)local_18 + 4);
    memcpy(local_18,"ssh-dss",7);
    local_18 = (void *)((long)local_18 + 7);
    local_18 = (void *)FUN_00109bba(local_18,local_48,(ulong)uVar3,local_48);
    local_18 = (void *)FUN_00109bba(local_18,local_40,(ulong)uVar4,local_40);
    local_18 = (void *)FUN_00109bba(local_18,local_38,(ulong)uVar5,local_38);
    local_18 = (void *)FUN_00109bba(local_18,local_30,(ulong)uVar6,local_30);
    *param_3 = (long)local_18 - local_20;
    lVar7 = local_20;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar7;
}



undefined8 FUN_0010b4ae(long param_1,void **param_2,undefined8 *param_3,long *param_4,undefined8 *param_5, EVP_PKEY *param_6)
{
  undefined8 uVar1;
  long in_FS_OFFSET;
  undefined8 local_30;
  void *local_28;
  dsa_st *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (dsa_st *)0x0;
  local_28 = (void *)0x0;
  local_20 = EVP_PKEY_get1_DSA(param_6);
  if (((local_20 == (dsa_st *)0x0) ||
      (local_28 = (void *)((void*(*)())(param_1 + 8))(7,param_1,param_1), local_28 == (void *)0x0))
     || (local_18 = FUN_0010b2b8(param_1,local_20,&local_30), local_18 == 0)) {
    if (local_20 != (dsa_st *)0x0) {
      DSA_free((DSA *)local_20);
    }
    if (local_28 != (void *)0x0) {
      ((void*(*)())(param_1 + 0x18))(local_28,param_1,local_28,param_1);
    }
    uVar1 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
  }
  else {
    DSA_free((DSA *)local_20);
    memcpy(local_28,"ssh-dss",7);
    *param_2 = local_28;
    *param_3 = 7;
    *param_4 = local_18;
    *param_5 = local_30;
    uVar1 = 0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong FUN_0010b609(undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,
                  long param_5,undefined8 param_6,DSA **param_7)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  undefined8 uVar3;
  uint local_84;
  undefined8 local_80;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  DSA *local_30;
  EVP_PKEY *local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = (DSA *)0x0;
  iVar1 = _libssh2_get_bignum_bytes(param_2,&local_58,&local_80);
  if (iVar1 == 0) {
    iVar1 = _libssh2_get_bignum_bytes(param_2,&local_50,&local_78);
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_bignum_bytes(param_2,&local_48,&local_70);
      if (iVar1 == 0) {
        iVar1 = _libssh2_get_bignum_bytes(param_2,&local_40,&local_68);
        if (iVar1 == 0) {
          uVar3 = 0x10b790;
          iVar1 = _libssh2_get_bignum_bytes(param_2,&local_38,&local_60);
          if (iVar1 == 0) {
            local_84 = _libssh2_dsa_new(&local_30,local_58,local_80,local_50,local_78,local_48,
                                        local_70,local_40,local_68,local_38,local_60);
            if (local_84 == 0) {
              if (((local_30 != (DSA *)0x0) && (param_5 != 0)) && (param_3 != 0)) {
                local_28 = EVP_PKEY_new();
                EVP_PKEY_set1_DSA(local_28,(dsa_st *)local_30);
                local_84 = FUN_0010b4ae(param_1,param_3,param_4,param_5,param_6,local_28);
                if (local_28 != (EVP_PKEY *)0x0) {
                  EVP_PKEY_free(local_28);
                }
              }
              if (param_7 == (DSA **)0x0) {
                DSA_free(local_30);
              }
              else {
                *param_7 = local_30;
              }
              uVar2 = (ulong)local_84;
            }
            else {
              if (local_30 != (DSA *)0x0) {
                DSA_free(local_30);
              }
              uVar2 = _libssh2_error(param_1,0xfffffffa,
                                     "Unable to allocate memory for private key data");
            }
          }
          else {
            _libssh2_error(param_1,0xfffffff2,"DSA no private key");
            uVar2 = 0xffffffff;
          }
        }
        else {
          _libssh2_error(param_1,0xfffffff2,"DSA no public key");
          uVar2 = 0xffffffff;
        }
      }
      else {
        _libssh2_error(param_1,0xfffffff2,"DSA no g");
        uVar2 = 0xffffffff;
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"DSA no q");
      uVar2 = 0xffffffff;
    }
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"DSA no p");
    uVar2 = 0xffffffff;
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong FUN_0010b90e(undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  undefined8 uVar4;
  uint local_2c;
  char *local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char *)0x0;
  local_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    uVar3 = 0xffffffff;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH DSA private key file");
      uVar3 = 0xffffffff;
    }
    else {
      uVar1 = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_20);
      fclose(local_18);
      if (uVar1 == 0) {
        iVar2 = _libssh2_get_string(local_20,&local_28,0,&local_28);
        if ((iVar2 == 0) && (local_28 != (char *)0x0)) {
          uVar4 = 0x10ba44;
          iVar2 = strcmp("ssh-dss",local_28);
          if (iVar2 == 0) {
            local_2c = FUN_0010b609(param_2,local_20,0,0,0,0,param_1);
          }
          else {
            local_2c = 0xffffffff;
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_2,local_20,local_20);
          }
          uVar3 = (ulong)local_2c;
        }
        else {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          uVar3 = 0xffffffff;
        }
      }
      else {
        uVar3 = (ulong)uVar1;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



//ulong _libssh2_dsa_new_private
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)
//
//{
//  uint local_14;
//  
//  _libssh2_init_if_needed();
//  local_14 = FUN_0010a652(param_1,PEM_read_bio_DSAPrivateKey,param_3,param_4);
//  if (local_14 != 0) {
//    local_14 = FUN_0010b90e(param_1,param_2,param_3,param_4);
//  }
//  return (ulong)local_14;
//}
//
//
//
//ulong _libssh2_ecdsa_new_private_frommemory
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//                undefined8 param_5)
//
//{
//  uint local_14;
//  
//  _libssh2_init_if_needed();
//  local_14 = FUN_0010a5b8(param_1,PEM_read_bio_ECPrivateKey,param_3,param_4,param_5);
//  if (local_14 != 0) {
//    local_14 = read_openssh_private_key_from_memory
//                         (param_1,param_2,"ssh-ecdsa",param_3,param_4,param_5);
//  }
//  return (ulong)local_14;
//}
//
//
//
//ulong _libssh2_curve25519_new(long param_1,long *param_2,void **param_3,void **param_4)
//
//{
//  int iVar1;
//  ulong uVar2;
//  void *pvVar3;
//  long in_FS_OFFSET;
//  int local_68;
//  int local_64;
//  uint local_60;
//  int local_5c;
//  EVP_PKEY *local_58;
//  X509_PUBKEY *local_50;
//  uchar *local_48;
//  uchar *local_40;
//  ASN1_OCTET_STRING *local_38;
//  EVP_PKEY_CTX *local_30;
//  PKCS8_PRIV_KEY_INFO *local_28;
//  long local_20;
//  void *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_58 = (EVP_PKEY *)0x0;
//  local_30 = (EVP_PKEY_CTX *)0x0;
//  local_28 = (PKCS8_PRIV_KEY_INFO *)0x0;
//  local_38 = (ASN1_OCTET_STRING *)0x0;
//  local_50 = (X509_PUBKEY *)0x0;
//  local_20 = 0;
//  local_60 = 0xffffffff;
//  local_30 = EVP_PKEY_CTX_new_id(0x40a,(ENGINE *)0x0);
//  if (local_30 == (EVP_PKEY_CTX *)0x0) {
//    uVar2 = 0xffffffff;
//    goto LAB_0010bea2;
//  }
//  EVP_PKEY_keygen_init(local_30);
//  EVP_PKEY_keygen(local_30,&local_58);
//  local_28 = EVP_PKEY2PKCS8(local_58);
//  if (((local_28 != (PKCS8_PRIV_KEY_INFO *)0x0) &&
//      (iVar1 = PKCS8_pkey_get0((ASN1_OBJECT **)0x0,&local_48,&local_64,(X509_ALGOR **)0x0,local_28),
//      iVar1 != 0)) &&
//     (local_38 = d2i_ASN1_OCTET_STRING((ASN1_OCTET_STRING **)0x0,&local_48,(long)local_64),
//     local_38 != (ASN1_OCTET_STRING *)0x0)) {
//    local_18 = (void *)ASN1_STRING_get0_data();
//    local_5c = ASN1_STRING_length((ASN1_STRING *)local_38);
//    if (((local_5c == 0x20) && (local_50 = X509_PUBKEY_new(), local_50 != (X509_PUBKEY *)0x0)) &&
//       ((iVar1 = X509_PUBKEY_set(&local_50,local_58), iVar1 != 0 &&
//        ((iVar1 = X509_PUBKEY_get0_param
//                            ((ASN1_OBJECT **)0x0,&local_40,&local_68,(X509_ALGOR **)0x0,local_50),
//         iVar1 != 0 && (local_68 == 0x20)))))) {
//      if (param_4 != (void **)0x0) {
//        pvVar3 = (void *)((void*(*)())(param_1 + 8))(0x20,param_1,param_1);
//        *param_4 = pvVar3;
//        if (*param_4 == (void *)0x0) goto LAB_0010be3c;
//        memcpy(*param_4,local_18,0x20);
//      }
//      if (param_3 != (void **)0x0) {
//        pvVar3 = (void *)((void*(*)())(param_1 + 8))(0x20,param_1,param_1);
//        *param_3 = pvVar3;
//        if (*param_3 == (void *)0x0) goto LAB_0010be3c;
//        memcpy(*param_3,local_40,0x20);
//      }
//      if (param_2 != (long *)0x0) {
//        local_20 = EVP_PKEY_new_raw_private_key(0x40a,0,local_18,0x20);
//        if (local_20 == 0) goto LAB_0010be3c;
//        *param_2 = local_20;
//      }
//      local_60 = 0;
//    }
//  }
//LAB_0010be3c:
//  if (local_28 != (PKCS8_PRIV_KEY_INFO *)0x0) {
//    PKCS8_PRIV_KEY_INFO_free(local_28);
//  }
//  if (local_30 != (EVP_PKEY_CTX *)0x0) {
//    EVP_PKEY_CTX_free(local_30);
//  }
//  if (local_38 != (ASN1_OCTET_STRING *)0x0) {
//    ASN1_OCTET_STRING_free(local_38);
//  }
//  if (local_50 != (X509_PUBKEY *)0x0) {
//    X509_PUBKEY_free(local_50);
//  }
//  if (local_58 != (EVP_PKEY *)0x0) {
//    EVP_PKEY_free(local_58);
//  }
//  uVar2 = (ulong)local_60;
//LAB_0010bea2:
//  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar2;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}
//


undefined8 FUN_0010beb8(long param_1,void **param_2,undefined8 *param_3,long *param_4,long *param_5, undefined8 param_6)
{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  ulong local_48;
  long local_40;
  long local_38;
  void *local_30;
  long local_28;
  undefined8 local_1c;
  undefined4 local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_1c = 0x353264652d687373;
  local_14 = 0x393135;
  local_30 = (void *)0x0;
  local_48 = 0;
  local_38 = 0;
  local_28 = 0;
  local_40 = 0;
  local_30 = (void *)((void*(*)())(param_1 + 8))(0xb,param_1,param_1);
  if (local_30 == (void *)0x0) {
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
  }
  else {
    memcpy(local_30,&local_1c,0xb);
    iVar1 = EVP_PKEY_get_raw_public_key(param_6,0,&local_48);
    if (iVar1 == 1) {
      local_28 = local_48 + 0x13;
      local_40 = ((void*(*)())(param_1 + 8))(local_28,param_1,local_28,param_1);
      local_38 = local_40;
      if (local_40 == 0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
      }
      else {
        _libssh2_store_str(&local_40,&local_1c,0xb);
        _libssh2_store_u32(&local_40,local_48 & 0xffffffff);
        iVar1 = EVP_PKEY_get_raw_public_key(param_6,local_40,&local_48,local_40);
        if (iVar1 == 1) {
          *param_2 = local_30;
          *param_3 = 0xb;
          *param_4 = local_38;
          *param_5 = local_28;
          uVar2 = 0;
          goto LAB_0010c0dd;
        }
        _libssh2_error(param_1,0xfffffff2,"EVP_PKEY_get_raw_public_key failed");
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"EVP_PKEY_get_raw_public_key failed");
    }
  }
  if (local_30 != (void *)0x0) {
    ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
  }
  if (local_38 != 0) {
    ((void*(*)())(param_1 + 0x18))(local_38,param_1,local_38,param_1);
  }
  uVar2 = 0xffffffff;
LAB_0010c0dd:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



// WARNING: Removing unreachable block (ram,0x0010c4a9)

undefined8 FUN_0010c0f3(long param_1,long *param_2,void **param_3,undefined8 *param_4,long *param_5, undefined8 *param_6,EVP_PKEY **param_7)
{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uint local_68;
  undefined8 local_60;
  undefined8 local_58;
  void *local_50;
  size_t local_48;
  long local_40;
  EVP_PKEY *local_38;
  void *local_30;
  long local_28;
  undefined8 local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = (EVP_PKEY *)0x0;
  local_30 = (void *)0x0;
  local_28 = 0;
  local_20 = 0;
  local_48 = 0;
  iVar1 = _libssh2_get_string(param_2,&local_60,&local_48,&local_60);
  if ((iVar1 == 0) && (local_48 == 0x20)) {
    iVar1 = _libssh2_get_string(param_2,&local_58,&local_48,&local_58);
    if ((iVar1 == 0) && (local_48 == 0x40)) {
      local_38 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key(0x43f,0,local_58,0x20);
      iVar1 = _libssh2_get_string(param_2,&local_50,&local_48,&local_50);
      if (iVar1 == 0) {
        if ((local_48 != 0) &&
           (local_18 = (void *)_libssh2_calloc(param_1,local_48 + 1),
           local_18 != (void *)0x0)) {
          memcpy(local_18,local_50,local_48);
          memcpy((void *)((long)local_18 + local_48),&DAT_0014468b,1);
          ((void*(*)())(param_1 + 0x18))(local_18,param_1,local_18,param_1);
        }
        local_68 = 1;
        while ((ulong)param_2[1] < (ulong)(param_2[2] + *param_2)) {
          if (local_68 != (uint)*(byte *)param_2[1]) {
            _libssh2_error(param_1,0xfffffff2,"Wrong padding");
            goto LAB_0010c4af;
          }
          local_68 = local_68 + 1;
          param_2[1] = param_2[1] + 1;
        }
        local_30 = (void *)((void*(*)())(param_1 + 8))(0xb,param_1,param_1);
        if (local_30 != (void *)0x0) {
          local_20 = 0x33;
          local_28 = _libssh2_calloc(param_1,0x33);
          if (local_28 != 0) {
            local_40 = local_28;
            _libssh2_store_str(&local_40,"ssh-ed25519",0xb);
            _libssh2_store_str(&local_40,local_60,0x20);
            memcpy(local_30,"ssh-ed25519",0xb);
            if (param_3 == (void **)0x0) {
              ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
            }
            else {
              *param_3 = local_30;
            }
            if (param_4 != (undefined8 *)0x0) {
              *param_4 = 0xb;
            }
            if (param_5 == (long *)0x0) {
              ((void*(*)())(param_1 + 0x18))(local_28,param_1,local_28,param_1);
            }
            else {
              *param_5 = local_28;
            }
            if (param_6 != (undefined8 *)0x0) {
              *param_6 = local_20;
            }
            if (param_7 == (EVP_PKEY **)0x0) {
              if (local_38 != (EVP_PKEY *)0x0) {
                EVP_PKEY_free(local_38);
              }
            }
            else {
              *param_7 = local_38;
            }
            uVar2 = 0;
            goto LAB_0010c505;
          }
        }
      }
      else {
        _libssh2_error(param_1,0xfffffff2,"Unable to read comment");
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"Wrong private key length");
    }
LAB_0010c4af:
    if (local_38 != (EVP_PKEY *)0x0) {
      EVP_PKEY_free(local_38);
    }
    if (local_30 != (void *)0x0) {
      ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
    }
    if (local_28 != 0) {
      ((void*(*)())(param_1 + 0x18))(local_28,param_1,local_28,param_1);
    }
    uVar2 = 0xffffffff;
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"Wrong public key length");
    uVar2 = 0xffffffff;
  }
LAB_0010c505:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



//ulong _libssh2_ed25519_new_private(EVP_PKEY **param_1,long param_2,char *param_3,undefined8 param_4)
//
//{
//  uint uVar1;
//  int iVar2;
//  ulong uVar3;
//  long in_FS_OFFSET;
//  undefined8 uVar4;
//  uint local_34;
//  char *local_30;
//  long local_28;
//  EVP_PKEY *local_20;
//  FILE *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_28 = 0;
//  local_20 = (EVP_PKEY *)0x0;
//  if (param_2 == 0) {
//    _libssh2_error(0,0xfffffff2,"Session is required");
//    uVar3 = 0xffffffff;
//  }
//  else {
//    _libssh2_init_if_needed();
//    local_18 = fopen(param_3,"r");
//    if (local_18 == (FILE *)0x0) {
//      _libssh2_error(param_2,0xfffffff0,"Unable to open ED25519 private key file");
//      uVar3 = 0xffffffff;
//    }
//    else {
//      uVar1 = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_28);
//      fclose(local_18);
//      if (uVar1 == 0) {
//        iVar2 = _libssh2_get_string(local_28,&local_30,0,&local_30);
//        if ((iVar2 == 0) && (local_30 != (char *)0x0)) {
//          uVar4 = 0x10c654;
//          iVar2 = strcmp("ssh-ed25519",local_30);
//          if (iVar2 == 0) {
//            local_34 = FUN_0010c0f3(param_2,local_28,0,0,0,0,&local_20);
//          }
//          else {
//            local_34 = 0xffffffff;
//          }
//          if (local_28 != 0) {
//            _libssh2_string_buf_free(param_2,local_28,local_28);
//          }
//          if (local_34 == 0) {
//            if (param_1 == (EVP_PKEY **)0x0) {
//              if (local_20 != (EVP_PKEY *)0x0) {
//                EVP_PKEY_free(local_20);
//              }
//            }
//            else {
//              *param_1 = local_20;
//            }
//          }
//          uVar3 = (ulong)local_34;
//        }
//        else {
//          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
//          uVar3 = 0xffffffff;
//        }
//      }
//      else {
//        uVar3 = (ulong)uVar1;
//      }
//    }
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar3;
//}
//
//
//
//undefined8
//_libssh2_ed25519_new_private_frommemory
//          (EVP_PKEY **param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//          undefined8 param_5)
//
//{
//  int iVar1;
//  undefined8 uVar2;
//  long in_FS_OFFSET;
//  EVP_PKEY *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_18 = (EVP_PKEY *)0x0;
//  _libssh2_init_if_needed();
//  iVar1 = FUN_0010a5b8(&local_18,PEM_read_bio_PrivateKey,param_3,param_4,param_5);
//  if (iVar1 == 0) {
//    iVar1 = EVP_PKEY_id(local_18);
//    if (iVar1 == 0x43f) {
//      *param_1 = local_18;
//      uVar2 = 0;
//    }
//    else {
//      EVP_PKEY_free(local_18);
//      uVar2 = _libssh2_error(param_2,0xfffffff2,"Private key is not an ED25519 key");
//    }
//  }
//  else {
//    uVar2 = read_openssh_private_key_from_memory
//                      (param_1,param_2,"ssh-ed25519",param_3,param_4,param_5);
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar2;
//}
//


//undefined8
//_libssh2_ed25519_new_public(EVP_PKEY **param_1,undefined8 param_2,undefined8 param_3,byte param_4)
//
//{
//  undefined8 uVar1;
//  EVP_PKEY *pkey;
//  
//  if (param_1 == (EVP_PKEY **)0x0) {
//    uVar1 = 0xffffffff;
//  }
//  else {
//    pkey = (EVP_PKEY *)EVP_PKEY_new_raw_public_key(0x43f,0,param_3,(ulong)param_4);
//    if (pkey == (EVP_PKEY *)0x0) {
//      uVar1 = _libssh2_error(param_2,0xfffffff2,"could not create ED25519 public key");
//    }
//    else {
//      if (param_1 == (EVP_PKEY **)0x0) {
//        if (pkey != (EVP_PKEY *)0x0) {
//          EVP_PKEY_free(pkey);
//        }
//      }
//      else {
//        *param_1 = pkey;
//      }
//      uVar1 = 0;
//    }
//  }
//  return uVar1;
//}
//


//undefined8
//_libssh2_rsa_sha1_sign
//          (long param_1,RSA *param_2,uchar *param_3,uint param_4,uchar **param_5,ulong *param_6)
//
//{
//  undefined8 uVar1;
//  long in_FS_OFFSET;
//  uint local_20;
//  int local_1c;
//  uchar *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_20 = RSA_size(param_2);
//  local_18 = (uchar *)((void*(*)())(param_1 + 8))((ulong)local_20,param_1,param_1);
//  if (local_18 == (uchar *)0x0) {
//    uVar1 = 0xffffffff;
//  }
//  else {
//    local_1c = RSA_sign(0x40,param_3,param_4,local_18,&local_20,param_2);
//    if (local_1c == 0) {
//      ((void*(*)())(param_1 + 0x18))(local_18,param_1,local_18,param_1);
//      uVar1 = 0xffffffff;
//    }
//    else {
//      *param_5 = local_18;
//      *param_6 = (ulong)local_20;
//      uVar1 = 0;
//    }
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar1;
//}
//
//
//
//undefined8 _libssh2_dsa_sha1_sign(DSA *param_1,uchar *param_2,undefined8 param_3,void *param_4)
//
//{
//  int iVar1;
//  int iVar2;
//  int iVar3;
//  undefined8 uVar4;
//  long in_FS_OFFSET;
//  BIGNUM *local_28;
//  BIGNUM *local_20;
//  DSA_SIG *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_18 = DSA_do_sign(param_2,0x14,param_1);
//  if (local_18 == (DSA_SIG *)0x0) {
//    uVar4 = 0xffffffff;
//  }
//  else {
//    DSA_SIG_get0(local_18,&local_28,&local_20,&local_28);
//    iVar1 = BN_num_bits(local_28);
//    iVar2 = iVar1 + 7;
//    if (iVar1 + 7 < 0) {
//      iVar2 = iVar1 + 0xe;
//    }
//    iVar2 = iVar2 >> 3;
//    if ((iVar2 < 1) || (0x14 < iVar2)) {
//      DSA_SIG_free(local_18);
//      uVar4 = 0xffffffff;
//    }
//    else {
//      iVar3 = BN_num_bits(local_20);
//      iVar1 = iVar3 + 7;
//      if (iVar3 + 7 < 0) {
//        iVar1 = iVar3 + 0xe;
//      }
//      iVar1 = iVar1 >> 3;
//      if ((iVar1 < 1) || (0x14 < iVar1)) {
//        DSA_SIG_free(local_18);
//        uVar4 = 0xffffffff;
//      }
//      else {
//        memset(param_4,0,0x28);
//        BN_bn2bin(local_28,(uchar *)((long)(0x14 - iVar2) + (long)param_4));
//        BN_bn2bin(local_20,(uchar *)((long)(0x14 - iVar1) + 0x14 + (long)param_4));
//        DSA_SIG_free(local_18);
//        uVar4 = 0;
//      }
//    }
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar4;
//}
//
//
//
//ulong _libssh2_ecdsa_sign(undefined8 param_1,EC_KEY *param_2,uchar *param_3,int param_4,
//                         void **param_5,size_t *param_6)
//
//{
//  int iVar1;
//  int iVar2;
//  uint uVar3;
//  uint uVar4;
//  ulong uVar5;
//  long in_FS_OFFSET;
//  uint local_54;
//  BIGNUM *local_48;
//  BIGNUM *local_40;
//  size_t local_38;
//  void *local_30;
//  void *local_28;
//  ECDSA_SIG *local_20;
//  void *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_54 = 0;
//  local_38 = 0;
//  local_48 = (BIGNUM *)0x0;
//  local_40 = (BIGNUM *)0x0;
//  local_30 = (void *)0x0;
//  local_28 = (void *)0x0;
//  local_20 = ECDSA_do_sign(param_3,param_4,param_2);
//  if (local_20 == (ECDSA_SIG *)0x0) {
//    uVar5 = 0xffffffff;
//  }
//  else {
//    ECDSA_SIG_get0(local_20,&local_48,&local_40,&local_48);
//    iVar1 = BN_num_bits(local_48);
//    iVar2 = iVar1 + 7;
//    if (iVar1 + 7 < 0) {
//      iVar2 = iVar1 + 0xe;
//    }
//    uVar3 = (iVar2 >> 3) + 1;
//    iVar1 = BN_num_bits(local_40);
//    iVar2 = iVar1 + 7;
//    if (iVar1 + 7 < 0) {
//      iVar2 = iVar1 + 0xe;
//    }
//    uVar4 = (iVar2 >> 3) + 1;
//    local_30 = malloc((long)(int)(uVar4 + uVar3 + 8));
//    if (local_30 == (void *)0x0) {
//      local_54 = 0xffffffff;
//    }
//    else {
//      local_18 = local_30;
//      local_18 = (void *)FUN_00109bba(local_30,local_48,(ulong)uVar3,local_48);
//      local_18 = (void *)FUN_00109bba(local_18,local_40,(ulong)uVar4,local_40);
//      local_38 = (long)local_18 - (long)local_30;
//      local_28 = (void *)_libssh2_calloc(param_1,local_38,local_38);
//      if (local_28 == (void *)0x0) {
//        local_54 = 0xffffffff;
//      }
//      else {
//        memcpy(local_28,local_30,local_38);
//        *param_5 = local_28;
//        *param_6 = local_38;
//      }
//    }
//    if (local_30 != (void *)0x0) {
//      free(local_30);
//    }
//    if (local_20 != (ECDSA_SIG *)0x0) {
//      ECDSA_SIG_free(local_20);
//    }
//    uVar5 = (ulong)local_54;
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar5;
//}
//
//
//
//undefined8 _libssh2_sha1_init(EVP_MD_CTX **param_1)
//
//{
//  int iVar1;
//  EVP_MD_CTX *pEVar2;
//  undefined8 uVar3;
//  EVP_MD *type;
//  
//  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  *param_1 = pEVar2;
//  if (*param_1 == (EVP_MD_CTX *)0x0) {
//    uVar3 = 0;
//  }
//  else {
//    type = EVP_get_digestbyname("sha1");
//    iVar1 = EVP_DigestInit(*param_1,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(*param_1);
//      *param_1 = (EVP_MD_CTX *)0x0;
//      uVar3 = 0;
//    }
//    else {
//      uVar3 = 1;
//    }
//  }
//  return uVar3;
//}



//undefined8 _libssh2_sha1(void *param_1,size_t param_2,uchar *param_3)
//
//{
//  int iVar1;
//  EVP_MD_CTX *ctx;
//  undefined8 uVar2;
//  EVP_MD *type;
//  
//  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  if (ctx == (EVP_MD_CTX *)0x0) {
//    uVar2 = 1;
//  }
//  else {
//    type = EVP_get_digestbyname("sha1");
//    iVar1 = EVP_DigestInit(ctx,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 1;
//    }
//    else {
//      EVP_DigestUpdate(ctx,param_1,param_2);
//      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 0;
//    }
//  }
//  return uVar2;
//}
//


//undefined8 _libssh2_sha256_init(EVP_MD_CTX **param_1)
//
//{
//  int iVar1;
//  EVP_MD_CTX *pEVar2;
//  undefined8 uVar3;
//  EVP_MD *type;
//  
//  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  *param_1 = pEVar2;
//  if (*param_1 == (EVP_MD_CTX *)0x0) {
//    uVar3 = 0;
//  }
//  else {
//    type = EVP_get_digestbyname("sha256");
//    iVar1 = EVP_DigestInit(*param_1,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(*param_1);
//      *param_1 = (EVP_MD_CTX *)0x0;
//      uVar3 = 0;
//    }
//    else {
//      uVar3 = 1;
//    }
//  }
//  return uVar3;
//}
//
//
//
//undefined8 _libssh2_sha256(void *param_1,size_t param_2,uchar *param_3)
//
//{
//  int iVar1;
//  EVP_MD_CTX *ctx;
//  undefined8 uVar2;
//  EVP_MD *type;
//  
//  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  if (ctx == (EVP_MD_CTX *)0x0) {
//    uVar2 = 1;
//  }
//  else {
//    type = EVP_get_digestbyname("sha256");
//    iVar1 = EVP_DigestInit(ctx,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 1;
//    }
//    else {
//      EVP_DigestUpdate(ctx,param_1,param_2);
//      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 0;
//    }
//  }
//  return uVar2;
//}
//
//
//
//undefined8 _libssh2_sha384_init(EVP_MD_CTX **param_1)
//
//{
//  int iVar1;
//  EVP_MD_CTX *pEVar2;
//  undefined8 uVar3;
//  EVP_MD *type;
//  
//  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  *param_1 = pEVar2;
//  if (*param_1 == (EVP_MD_CTX *)0x0) {
//    uVar3 = 0;
//  }
//  else {
//    type = EVP_get_digestbyname("sha384");
//    iVar1 = EVP_DigestInit(*param_1,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(*param_1);
//      *param_1 = (EVP_MD_CTX *)0x0;
//      uVar3 = 0;
//    }
//    else {
//      uVar3 = 1;
//    }
//  }
//  return uVar3;
//}
//
//
//
//undefined8 _libssh2_sha384(void *param_1,size_t param_2,uchar *param_3)
//
//{
//  int iVar1;
//  EVP_MD_CTX *ctx;
//  undefined8 uVar2;
//  EVP_MD *type;
//  
//  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  if (ctx == (EVP_MD_CTX *)0x0) {
//    uVar2 = 1;
//  }
//  else {
//    type = EVP_get_digestbyname("sha384");
//    iVar1 = EVP_DigestInit(ctx,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 1;
//    }
//    else {
//      EVP_DigestUpdate(ctx,param_1,param_2);
//      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 0;
//    }
//  }
//  return uVar2;
//}



//undefined8 _libssh2_sha512_init(EVP_MD_CTX **param_1)
//
//{
//  int iVar1;
//  EVP_MD_CTX *pEVar2;
//  undefined8 uVar3;
//  EVP_MD *type;
//  
//  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  *param_1 = pEVar2;
//  if (*param_1 == (EVP_MD_CTX *)0x0) {
//    uVar3 = 0;
//  }
//  else {
//    type = EVP_get_digestbyname("sha512");
//    iVar1 = EVP_DigestInit(*param_1,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(*param_1);
//      *param_1 = (EVP_MD_CTX *)0x0;
//      uVar3 = 0;
//    }
//    else {
//      uVar3 = 1;
//    }
//  }
//  return uVar3;
//}
//

//
//undefined8 _libssh2_sha512(void *param_1,size_t param_2,uchar *param_3)
//
//{
//  int iVar1;
//  EVP_MD_CTX *ctx;
//  undefined8 uVar2;
//  EVP_MD *type;
//  
//  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  if (ctx == (EVP_MD_CTX *)0x0) {
//    uVar2 = 1;
//  }
//  else {
//    type = EVP_get_digestbyname("sha512");
//    iVar1 = EVP_DigestInit(ctx,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 1;
//    }
//    else {
//      EVP_DigestUpdate(ctx,param_1,param_2);
//      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
//      EVP_MD_CTX_free(ctx);
//      uVar2 = 0;
//    }
//  }
//  return uVar2;
//}
//
//
//
//undefined8 _libssh2_md5_init(EVP_MD_CTX **param_1)
//
//{
//  int iVar1;
//  EVP_MD_CTX *pEVar2;
//  undefined8 uVar3;
//  EVP_MD *type;
//  
//  pEVar2 = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  *param_1 = pEVar2;
//  if (*param_1 == (EVP_MD_CTX *)0x0) {
//    uVar3 = 0;
//  }
//  else {
//    type = EVP_get_digestbyname("md5");
//    iVar1 = EVP_DigestInit(*param_1,type);
//    if (iVar1 == 0) {
//      EVP_MD_CTX_free(*param_1);
//      *param_1 = (EVP_MD_CTX *)0x0;
//      uVar3 = 0;
//    }
//    else {
//      uVar3 = 1;
//    }
//  }
//  return uVar3;
//}
//


undefined8 FUN_0010d1b9(long param_1,void **param_2,undefined8 *param_3,long *param_4,long *param_5, EVP_PKEY *param_6)
{
  int iVar1;
  undefined8 uVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  int local_68;
  long local_60;
  void *local_58;
  uchar *local_50;
  ec_key_st *local_48;
  long local_40;
  BN_CTX *local_38;
  EC_POINT *local_30;
  EC_GROUP *local_28;
  size_t local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_68 = 0;
  local_48 = (ec_key_st *)0x0;
  local_58 = (void *)0x0;
  local_40 = 0;
  local_50 = (uchar *)0x0;
  local_38 = BN_CTX_new();
  if (local_38 == (BN_CTX *)0x0) {
    uVar2 = 0xffffffff;
    goto LAB_0010d501;
  }
  local_48 = EVP_PKEY_get1_EC_KEY(param_6);
  if (local_48 == (ec_key_st *)0x0) {
    local_68 = -1;
  }
  else {
    local_30 = EC_KEY_get0_public_key((EC_KEY *)local_48);
    local_28 = EC_KEY_get0_group((EC_KEY *)local_48);
    _libssh2_ecdsa_get_curve_type(local_48);
    local_58 = (void *)((void*(*)())(param_1 + 8))(0x13,param_1,param_1);
    if (local_58 == (void *)0x0) {
      _libssh2_error(param_1,0xfffffffa,"out of memory");
      goto LAB_0010d501;
    }
    if (iVar1 == 0x19f) {
      memcpy(local_58,"ecdsa-sha2-nistp256",0x13);
    }
    else {
      if (iVar1 == 0x2cb) {
        memcpy(local_58,"ecdsa-sha2-nistp384",0x13);
      }
      else {
        if (iVar1 != 0x2cc) {
          local_68 = -1;
          goto LAB_0010d497;
        }
        memcpy(local_58,"ecdsa-sha2-nistp521",0x13);
      }
    }
    local_20 = EC_POINT_point2oct(local_28,local_30,POINT_CONVERSION_UNCOMPRESSED,(uchar *)0x0,0,
                                  local_38);
    if (local_20 < 0x86) {
      local_50 = (uchar *)malloc(local_20);
      if (local_50 == (uchar *)0x0) {
        local_68 = -1;
      }
      else {
        sVar3 = EC_POINT_point2oct(local_28,local_30,POINT_CONVERSION_UNCOMPRESSED,local_50,local_20
                                   ,local_38);
        if (local_20 == sVar3) {
          local_40 = local_20 + 0x27;
          local_18 = ((void*(*)())(param_1 + 8))(local_40,param_1,local_40,param_1);
          if (local_18 == 0) {
            local_68 = -1;
          }
          else {
            local_60 = local_18;
            _libssh2_store_str(&local_60,local_58,0x13);
            _libssh2_store_str(&local_60,(long)local_58 + 0xb,8);
            _libssh2_store_str(&local_60,local_50,local_20);
            *param_2 = local_58;
            *param_3 = 0x13;
            *param_4 = local_18;
            *param_5 = local_40;
          }
        }
        else {
          local_68 = -1;
        }
      }
    }
    else {
      local_68 = -1;
    }
  }
LAB_0010d497:
  if (local_48 != (ec_key_st *)0x0) {
    EC_KEY_free((EC_KEY *)local_48);
  }
  if (local_38 != (BN_CTX *)0x0) {
    BN_CTX_free(local_38);
  }
  if (local_50 != (uchar *)0x0) {
    free(local_50);
  }
  if (local_68 == 0) {
    uVar2 = 0;
  }
  else {
    if (local_58 != (void *)0x0) {
      ((void*(*)())(param_1 + 0x18))(local_58,param_1,local_58,param_1);
    }
    uVar2 = 0xffffffff;
  }
LAB_0010d501:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong FUN_0010d517(undefined8 param_1,undefined8 param_2,undefined8 param_3,long param_4,
                  undefined8 param_5,long param_6,undefined8 param_7,EC_KEY **param_8)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_5c;
  long local_58;
  int local_50 [2];
  undefined8 local_48;
  undefined local_40 [8];
  uchar *local_38;
  undefined8 local_30;
  EC_KEY *local_28;
  BIGNUM *local_20;
  EVP_PKEY *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (EC_KEY *)0x0;
  iVar1 = _libssh2_get_string(param_3,local_40,&local_58,local_40);
  if ((iVar1 == 0) && (local_58 != 0)) {
    iVar1 = _libssh2_get_string(param_3,&local_30,&local_48,&local_30);
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_bignum_bytes(param_3,&local_38,local_50);
      if (iVar1 == 0) {
        iVar1 = _libssh2_ecdsa_curve_name_with_octal_new(&local_28,local_30,local_48, local_48);
        if (iVar1 == 0) {
          local_20 = BN_new();
          if (local_20 != (BIGNUM *)0x0) {
            BN_bin2bn(local_38,local_50[0],local_20);
            iVar1 = EC_KEY_set_private_key(local_28,local_20);
            local_5c = (uint)(iVar1 != 1);
            if ((((iVar1 == 1) && (local_28 != (EC_KEY *)0x0)) && (param_6 != 0)) && (param_4 != 0))
            {
              local_18 = EVP_PKEY_new();
              EVP_PKEY_set1_EC_KEY(local_18,(ec_key_st *)local_28);
              local_5c = FUN_0010d1b9(param_1,param_4,param_5,param_6,param_7,local_18);
              if (local_18 != (EVP_PKEY *)0x0) {
                EVP_PKEY_free(local_18);
              }
            }
            if (param_8 == (EC_KEY **)0x0) {
              EC_KEY_free(local_28);
            }
            else {
              *param_8 = local_28;
            }
            uVar2 = (ulong)local_5c;
            goto LAB_0010d79c;
          }
        }
        else {
          _libssh2_error(param_1,0xfffffff2,"ECDSA could not create key");
        }
        if (local_28 != (EC_KEY *)0x0) {
          EC_KEY_free(local_28);
        }
        uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
      }
      else {
        _libssh2_error(param_1,0xfffffff2,"ECDSA no exponent");
        uVar2 = 0xffffffff;
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"ECDSA no point");
      uVar2 = 0xffffffff;
    }
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"ECDSA no curve");
    uVar2 = 0xffffffff;
  }
LAB_0010d79c:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong FUN_0010d7b2(undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint local_30;
  uint local_2c;
  long local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = 0;
  local_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    uVar1 = 0xffffffff;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH ECDSA private key file");
      uVar1 = 0xffffffff;
    }
    else {
      local_2c = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_20);
      fclose(local_18);
      if (local_2c == 0) {
        local_2c = _libssh2_get_string(local_20,&local_28,0,&local_28);
        if ((local_2c == 0) && (local_28 != 0)) {
          local_2c = _libssh2_ecdsa_curve_type_from_name(local_28,&local_30);
          if (local_2c == 0) {
            local_2c = FUN_0010d517(param_2,(ulong)local_30,local_20,0,0,0,0,param_1);
          }
          else {
            local_2c = 0xffffffff;
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_2,local_20,local_20);
          }
          uVar1 = (ulong)local_2c;
        }
        else {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          uVar1 = 0xffffffff;
        }
      }
      else {
        uVar1 = (ulong)local_2c;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



//undefined8
//_libssh2_ecdsa_new_private
//          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)
//
//{
//  int iVar1;
//  undefined8 uVar2;
//  
//  _libssh2_init_if_needed();
//  iVar1 = FUN_0010a652(param_1,PEM_read_bio_ECPrivateKey,param_3,param_4);
//  if (iVar1 == 0) {
//    uVar2 = 0;
//  }
//  else {
//    uVar2 = FUN_0010d7b2(param_1,param_2,param_3,param_4);
//  }
//  return uVar2;
//}
//
//
//
//undefined8
//_libssh2_ecdsa_create_key(long param_1,EC_KEY **param_2,void **param_3,size_t *param_4,int param_5)
//
//{
//  BN_CTX *ctx;
//  undefined8 uVar1;
//  EC_KEY *key;
//  EC_GROUP *group;
//  EC_POINT *p;
//  size_t len;
//  size_t sVar2;
//  void *pvVar3;
//  long in_FS_OFFSET;
//  int local_c4;
//  uchar local_98 [136];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_c4 = 1;
//  ctx = BN_CTX_new();
//  if (ctx == (BN_CTX *)0x0) {
//    uVar1 = 0xffffffff;
//    goto LAB_0010dc2a;
//  }
//  key = EC_KEY_new_by_curve_name(param_5);
//  group = EC_KEY_get0_group(key);
//  EC_KEY_generate_key(key);
//  p = EC_KEY_get0_public_key(key);
//  len = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,(uchar *)0x0,0,ctx);
//  if (len < 0x86) {
//    sVar2 = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,local_98,len,ctx);
//    if (len == sVar2) {
//      if (param_2 != (EC_KEY **)0x0) {
//        *param_2 = key;
//      }
//      if (param_3 != (void **)0x0) {
//        pvVar3 = (void *)((void*(*)())(param_1 + 8))(len,param_1,len,param_1);
//        *param_3 = pvVar3;
//        if (*param_3 == (void *)0x0) {
//          local_c4 = -1;
//          goto LAB_0010dbfc;
//        }
//        memcpy(*param_3,local_98,len);
//      }
//      if (param_4 != (size_t *)0x0) {
//        *param_4 = len;
//      }
//    }
//    else {
//      local_c4 = -1;
//    }
//  }
//  else {
//    local_c4 = -1;
//  }
//LAB_0010dbfc:
//  if (ctx != (BN_CTX *)0x0) {
//    BN_CTX_free(ctx);
//  }
//  if (local_c4 == 1) {
//    uVar1 = 0;
//  }
//  else {
//    uVar1 = 0xffffffff;
//  }
//LAB_0010dc2a:
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar1;
//}
//
//
//
//ulong _libssh2_ecdh_gen_k(BIGNUM **param_1,EC_KEY *param_2,uchar *param_3,size_t param_4)
//
//{
//  int iVar1;
//  int iVar2;
//  uint len;
//  BN_CTX *ctx;
//  ulong uVar3;
//  EC_GROUP *group;
//  EC_POINT *p;
//  uint local_38;
//  uchar *local_30;
//  
//  local_38 = 0;
//  local_30 = (uchar *)0x0;
//  ctx = BN_CTX_new();
//  if (ctx == (BN_CTX *)0x0) {
//    uVar3 = 0xffffffff;
//  }
//  else {
//    if (param_1 == (BIGNUM **)0x0) {
//      uVar3 = 0xffffffff;
//    }
//    else {
//      group = EC_KEY_get0_group(param_2);
//      p = EC_POINT_new(group);
//      if (p == (EC_POINT *)0x0) {
//        uVar3 = 0xffffffff;
//      }
//      else {
//        iVar1 = EC_POINT_oct2point(group,p,param_3,param_4,ctx);
//        if (iVar1 == 1) {
//          iVar2 = EC_GROUP_get_degree(group);
//          iVar1 = iVar2 + 7;
//          if (iVar2 + 7 < 0) {
//            iVar1 = iVar2 + 0xe;
//          }
//          local_30 = (uchar *)malloc((long)(iVar1 >> 3));
//          if (local_30 == (uchar *)0x0) {
//            local_38 = 0xffffffff;
//          }
//          else {
//            len = ECDH_compute_key(local_30,(long)(iVar1 >> 3),p,param_2,(KDF *)0x0);
//            if ((len == 0) || (0x85 < len)) {
//              local_38 = 0xffffffff;
//            }
//            else {
//              BN_bin2bn(local_30,len,*param_1);
//            }
//          }
//        }
//        else {
//          local_38 = 0xffffffff;
//        }
//        if (p != (EC_POINT *)0x0) {
//          EC_POINT_free(p);
//        }
//        if (ctx != (BN_CTX *)0x0) {
//          BN_CTX_free(ctx);
//        }
//        if (local_30 != (uchar *)0x0) {
//          free(local_30);
//        }
//        uVar3 = (ulong)local_38;
//      }
//    }
//  }
//  return uVar3;
//}
//
//
//
//undefined8
//_libssh2_ed25519_sign
//          (EVP_PKEY *param_1,long param_2,long *param_3,long *param_4,undefined8 param_5,
//          undefined8 param_6)
//
//{
//  int iVar1;
//  undefined8 uVar2;
//  long in_FS_OFFSET;
//  int local_2c;
//  long local_28;
//  long local_20;
//  EVP_MD_CTX *local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_2c = -1;
//  local_18 = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  local_28 = 0;
//  local_20 = 0;
//  if (local_18 != (EVP_MD_CTX *)0x0) {
//    iVar1 = EVP_DigestSignInit(local_18,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,param_1);
//    if ((((iVar1 != 1) || (iVar1 = EVP_DigestSign(local_18,0,&local_28,param_5,param_6), iVar1 != 1)
//         ) || (local_28 != 0x40)) || (local_20 = _libssh2_calloc(param_2,0x40,0x40), local_20 == 0))
//    goto LAB_0010df22;
//    local_2c = EVP_DigestSign(local_18,local_20,&local_28,param_5,param_6);
//  }
//  if (local_2c == 1) {
//    *param_3 = local_20;
//    *param_4 = local_28;
//  }
//  else {
//    *param_4 = 0;
//    *param_3 = 0;
//    ((void*(*)())(param_2 + 0x18))(local_20,param_2,local_20,param_2);
//  }
//LAB_0010df22:
//  if (local_18 != (EVP_MD_CTX *)0x0) {
//    EVP_MD_CTX_free(local_18);
//  }
//  if (local_2c == 1) {
//    uVar2 = 0;
//  }
//  else {
//    uVar2 = 0xffffffff;
//  }
//  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar2;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}
//
//
//
//undefined8 _libssh2_curve25519_gen_k(BIGNUM **param_1,undefined8 param_2,undefined8 param_3)
//
//{
//  undefined8 uVar1;
//  long in_FS_OFFSET;
//  int local_64;
//  size_t local_60;
//  EVP_PKEY_CTX *local_58;
//  EVP_PKEY *local_50;
//  EVP_PKEY *local_48;
//  BN_CTX *local_40;
//  uchar local_38 [40];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_64 = -1;
//  local_50 = (EVP_PKEY *)0x0;
//  local_48 = (EVP_PKEY *)0x0;
//  local_58 = (EVP_PKEY_CTX *)0x0;
//  local_40 = (BN_CTX *)0x0;
//  local_60 = 0;
//  if ((param_1 == (BIGNUM **)0x0) || (*param_1 == (BIGNUM *)0x0)) {
//    uVar1 = 0xffffffff;
//  }
//  else {
//    local_40 = BN_CTX_new();
//    if (local_40 == (BN_CTX *)0x0) {
//      uVar1 = 0xffffffff;
//    }
//    else {
//      local_50 = (EVP_PKEY *)EVP_PKEY_new_raw_public_key(0x40a,0,param_3,0x20);
//      local_48 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key(0x40a,0,param_2,0x20);
//      if (((((local_50 != (EVP_PKEY *)0x0) && (local_48 != (EVP_PKEY *)0x0)) &&
//           (local_58 = EVP_PKEY_CTX_new(local_48,(ENGINE *)0x0), local_58 != (EVP_PKEY_CTX *)0x0))
//          && ((local_64 = EVP_PKEY_derive_init(local_58), 0 < local_64 &&
//              (local_64 = EVP_PKEY_derive_set_peer(local_58,local_50), 0 < local_64)))) &&
//         (local_64 = EVP_PKEY_derive(local_58,(uchar *)0x0,&local_60), 0 < local_64)) {
//        if (local_60 == 0x20) {
//          local_64 = EVP_PKEY_derive(local_58,local_38,&local_60);
//          if ((local_64 == 1) && (local_60 == 0x20)) {
//            BN_bin2bn(local_38,0x20,*param_1);
//          }
//          else {
//            local_64 = -1;
//          }
//        }
//        else {
//          local_64 = -1;
//        }
//      }
//      if (local_58 != (EVP_PKEY_CTX *)0x0) {
//        EVP_PKEY_CTX_free(local_58);
//      }
//      if (local_50 != (EVP_PKEY *)0x0) {
//        EVP_PKEY_free(local_50);
//      }
//      if (local_48 != (EVP_PKEY *)0x0) {
//        EVP_PKEY_free(local_48);
//      }
//      if (local_40 != (BN_CTX *)0x0) {
//        BN_CTX_free(local_40);
//      }
//      if (local_64 == 1) {
//        uVar1 = 0;
//      }
//      else {
//        uVar1 = 0xffffffff;
//      }
//    }
//  }
//  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar1;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}
//
//
//
//undefined8
//_libssh2_ed25519_verify
//          (EVP_PKEY *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//          undefined8 param_5)
//
//{
//  EVP_MD_CTX *ctx;
//  undefined8 uVar1;
//  int local_14;
//  
//  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
//  if (ctx == (EVP_MD_CTX *)0x0) {
//    uVar1 = 0xffffffff;
//  }
//  else {
//    local_14 = EVP_DigestVerifyInit(ctx,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,param_1);
//    if (local_14 == 1) {
//      local_14 = EVP_DigestVerify();
//    }
//    EVP_MD_CTX_free(ctx);
//    if (local_14 == 1) {
//      uVar1 = 0;
//    }
//    else {
//      uVar1 = 0xffffffff;
//    }
//  }
//  return uVar1;
//}
//


ulong FUN_0010e23c(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4, undefined8 param_5,char *param_6,undefined8 param_7)
{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  undefined8 uVar3;
  uint local_30;
  uint local_2c;
  char *local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char *)0x0;
  local_20 = 0;
  local_2c = 0;
  if (param_1 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    uVar2 = 0xffffffff;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_6,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_1,0xfffffff0,"Unable to open private key file");
      uVar2 = 0xffffffff;
    }
    else {
      local_2c = _libssh2_openssh_pem_parse(param_1,param_7,local_18,&local_20);
      fclose(local_18);
      if (local_2c == 0) {
        local_2c = _libssh2_get_string(local_20,&local_28,0,&local_28);
        if ((local_2c == 0) && (local_28 != (char *)0x0)) {
          local_2c = 0xffffffff;
          uVar3 = 0x10e3ab;
          iVar1 = strcmp("ssh-ed25519",local_28);
          if (iVar1 == 0) {
            local_2c = FUN_0010c0f3(param_1,local_20,param_2,param_3,param_4,param_5,0);
          }
          uVar3 = 0x10e3f5;
          iVar1 = strcmp("ssh-rsa",local_28);
          if (iVar1 == 0) {
            local_2c = FUN_0010ac2d(param_1,local_20,param_2,param_3,param_4,param_5,0);
          }
          uVar3 = 0x10e43f;
          iVar1 = strcmp("ssh-dss",local_28);
          if (iVar1 == 0) {
            local_2c = FUN_0010b609(param_1,local_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = _libssh2_ecdsa_curve_type_from_name(local_28,&local_30);
          if (iVar1 == 0) {
            local_2c = FUN_0010d517(param_1,(ulong)local_30,local_20,param_2,param_3,param_4,param_5
                                    ,0);
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_1,local_20,local_20);
          }
          if (local_2c != 0) {
            _libssh2_error(param_1,0xfffffff0,"Unsupported OpenSSH key type");
          }
          uVar2 = (ulong)local_2c;
        }
        else {
          _libssh2_error(param_1,0xfffffff2,"Public key type in decrypted key data not found");
          uVar2 = 0xffffffff;
        }
      }
      else {
        _libssh2_error(param_1,0xfffffff0,"Not an OpenSSH key file");
        uVar2 = (ulong)local_2c;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



//ulong _libssh2_pub_priv_keyfile
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//                undefined8 param_5,char *param_6,void *param_7)
//
//{
//  int iVar1;
//  BIO *bp;
//  undefined8 uVar2;
//  EVP_PKEY *pkey;
//  uint local_24;
//  
//  bp = BIO_new_file(param_6,"r");
//  if (bp == (BIO *)0x0) {
//    uVar2 = _libssh2_error(param_1,0xfffffff0,
//                                                      
//                           "Unable to extract public key from private key file: Unable to open private key file"
//                          );
//    return uVar2;
//  }
//  BIO_ctrl(bp,1,0,(void *)0x0);
//  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_7);
//  uVar2 = 0x10e5b1;
//  BIO_free(bp);
//  if (pkey == (EVP_PKEY *)0x0) {
//    iVar1 = FUN_0010e23c(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
//    if (iVar1 != 0) {
//      uVar2 = _libssh2_error(param_1,0xfffffff0,
//                                                          
//                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
//                            );
//      return uVar2;
//    }
//    return 0;
//  }
//  iVar1 = EVP_PKEY_id(pkey);
//  if (iVar1 == 0x74) {
//    local_24 = FUN_0010b4ae(param_1,param_2,param_3,param_4,param_5,pkey);
//    goto LAB_0010e720;
//  }
//  if (iVar1 < 0x75) {
//    if (iVar1 == 6) {
//      local_24 = FUN_0010a8ca(param_1,param_2,param_3,param_4,param_5,pkey);
//      goto LAB_0010e720;
//    }
//  }
//  else {
//    if (iVar1 == 0x198) {
//      local_24 = FUN_0010d1b9(param_1,param_2,param_3,param_4,param_5,pkey);
//      goto LAB_0010e720;
//    }
//    if (iVar1 == 0x43f) {
//      local_24 = FUN_0010beb8(param_1,param_2,param_3,param_4,param_5,pkey);
//      goto LAB_0010e720;
//    }
//  }
//  local_24 = _libssh2_error(param_1,0xfffffff0,
//                                                        
//                            "Unable to extract public key from private key file: Unsupported private key file format"
//                           );
//LAB_0010e720:
//  EVP_PKEY_free(pkey);
//  return (ulong)local_24;
//}
//
ulong _libssh2_openssh_pem_parse_memory
                (long param_1,undefined8 param_2,long param_3,ulong param_4,undefined8 param_5)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_c0;
  uint local_bc;
  ulong local_b8;
  long local_b0;
  size_t local_a8;
  long local_a0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_b0 = 0;
  local_c0 = 0;
  local_b8 = 0;
  if ((param_3 == 0) || (param_4 == 0)) {
    uVar2 = 0xffffffff;
  }
  else {
    do {
      local_98[0] = '\0';
      if (param_4 <= local_b8) {
        uVar2 = 0xffffffff;
        goto LAB_0012edee;
      }
     //iVar1 = FUN_0012cd01(local_98,0x80,param_3,param_4,&local_b8);
      if (iVar1 != 0) {
        uVar2 = 0xffffffff;
        goto LAB_0012edee;
      }
      iVar1 = strcmp(local_98,"-----BEGIN OPENSSH PRIVATE KEY-----");
    } while (iVar1 != 0);
    local_98[0] = '\0';
    do {
      if (local_98[0] != '\0') {
        local_a8 = strlen(local_98);
        if (local_b0 == 0) {
          local_a0 = ((void*(*)())(param_1 + 8))
                               (local_a8 + local_c0,param_1,param_1,local_a8 + local_c0);
        }
        else {
          local_a0 = ((void*(*)())(param_1 + 0x10))(local_b0,local_c0 + local_a8,param_1,local_b0);
        }
        if (local_a0 == 0) {
          local_bc = 0xffffffff;
          goto LAB_0012eda5;
        }
        memcpy((void *)((ulong)local_c0 + local_a0),local_98,local_a8);
        local_b0 = local_a0;
        local_c0 = local_c0 + (int)local_a8;
      }
      local_98[0] = '\0';
      if (param_4 <= local_b8) {
        local_bc = 0xffffffff;
        goto LAB_0012eda5;
      }

      if (iVar1 != 0) {
        local_bc = 0xffffffff;
        goto LAB_0012eda5;
      }
      iVar1 = strcmp(local_98,"-----END OPENSSH PRIVATE KEY-----");
    } while (iVar1 != 0);
    if (local_b0 == 0) {
      uVar2 = 0xffffffff;
    }
    else {

LAB_0012eda5:
      if (local_b0 != 0) {
        _libssh2_explicit_zero(local_b0,(ulong)local_c0);
        ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
      }
      uVar2 = (ulong)local_bc;
    }
  }
LAB_0012edee:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}




ulong FUN_0010e731(long param_1,undefined8 *param_2,char *param_3,undefined8 param_4, undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined8 param_8, undefined8 param_9,undefined8 param_10)
{
  int iVar1;
  ulong uVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  undefined8 uVar4;
  uint local_28;
  uint local_24;
  char *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (char *)0x0;
  local_18 = 0;
  if (param_2 != (undefined8 *)0x0) {
    *param_2 = 0;
  }
  if (param_1 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    uVar2 = 0xffffffff;
    goto LAB_0010ea59;
  }
  if (param_3 != (char *)0x0) {
    sVar3 = strlen(param_3);
    if (sVar3 < 0xc) {
      sVar3 = strlen(param_3);
      if (6 < sVar3) goto LAB_0010e810;
    }
    _libssh2_error(param_1,0xfffffff2,"type is invalid");
    uVar2 = 0xffffffff;
    goto LAB_0010ea59;
  }
LAB_0010e810:
  _libssh2_init_if_needed();
  local_24 = _libssh2_openssh_pem_parse_memory(param_1,param_10,param_8,param_9,&local_18);
  if (local_24 != 0) {
    uVar2 = (ulong)local_24;
    goto LAB_0010ea59;
  }
  local_24 = _libssh2_get_string(local_18,&local_20,0,&local_20);
  if ((local_24 != 0) || (local_20 == (char *)0x0)) {
    _libssh2_error(param_1,0xfffffff2,"Public key type in decrypted key data not found");
    uVar2 = 0xffffffff;
    goto LAB_0010ea59;
  }
  local_24 = 0xffffffff;
  uVar4 = 0x10e8ab;
  iVar1 = strcmp("ssh-ed25519",local_20);
  if (iVar1 == 0) {
    if (param_3 != (char *)0x0) {
      uVar4 = 0x10e8c9;
      iVar1 = strcmp("ssh-ed25519",param_3);
      if (iVar1 != 0) goto LAB_0010e901;
    }
    local_24 = FUN_0010c0f3(param_1,local_18,param_4,param_5,param_6,param_7,param_2);
  }
LAB_0010e901:
  uVar4 = 0x10e914;
  iVar1 = strcmp("ssh-rsa",local_20);
  if (iVar1 == 0) {
    if (param_3 != (char *)0x0) {
      uVar4 = 0x10e932;
      iVar1 = strcmp("ssh-rsa",param_3);
      if (iVar1 != 0) goto LAB_0010e96a;
    }
    local_24 = FUN_0010ac2d(param_1,local_18,param_4,param_5,param_6,param_7,param_2);
  }
LAB_0010e96a:
  uVar4 = 0x10e97d;
  iVar1 = strcmp("ssh-dss",local_20);
  if (iVar1 == 0) {
    if (param_3 != (char *)0x0) {
      uVar4 = 0x10e99b;
      iVar1 = strcmp("ssh-dss",param_3);
      if (iVar1 != 0) goto LAB_0010e9d3;
    }
    local_24 = FUN_0010b609(param_1,local_18,param_4,param_5,param_6,param_7,param_2);
  }
LAB_0010e9d3:
  iVar1 = _libssh2_ecdsa_curve_type_from_name(local_20,&local_28);
  if (iVar1 == 0) {
    if (param_3 != (char *)0x0) {
      iVar1 = strcmp("ssh-ecdsa",param_3);
      if (iVar1 != 0) goto LAB_0010ea3a;
    }
    local_24 = FUN_0010d517(param_1,(ulong)local_28,local_18,param_4,param_5,param_6,param_7,param_2
                           );
  }
LAB_0010ea3a:
  if (local_18 != 0) {
    _libssh2_string_buf_free(param_1,local_18,local_18);
  }
  uVar2 = (ulong)local_24;
LAB_0010ea59:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



//void read_openssh_private_key_from_memory
//               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//               undefined8 param_5,undefined8 param_6)
//
//{
//  FUN_0010e731(param_2,param_1,param_3,0,0,0,0,param_4,param_5,param_6);
//  return;
//}
//
//
//
//ulong _libssh2_pub_priv_keyfilememory
//                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
//                undefined8 param_5,void *param_6,undefined8 param_7,void *param_8)
//
//{
//  int iVar1;
//  BIO *bp;
//  EVP_PKEY *pkey;
//  undefined8 uVar2;
//  uint local_20;
//  
//  bp = BIO_new_mem_buf(param_6,(int)param_7);
//  if (bp == (BIO *)0x0) {
//    return 0xffffffff;
//  }
//  BIO_ctrl(bp,1,0,(void *)0x0);
//  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_8);
//  BIO_free(bp);
//  if (pkey == (EVP_PKEY *)0x0) {
//    iVar1 = FUN_0010e731(param_1,0,0,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
//    if (iVar1 != 0) {
//      uVar2 = _libssh2_error(param_1,0xfffffff0,
//                                                          
//                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
//                            );
//      return uVar2;
//    }
//    return 0;
//  }
//  iVar1 = EVP_PKEY_id(pkey);
//  if (iVar1 == 0x74) {
//    local_20 = FUN_0010b4ae(param_1,param_2,param_3,param_4,param_5,pkey);
//    goto LAB_0010eccf;
//  }
//  if (iVar1 < 0x75) {
//    if (iVar1 == 6) {
//      local_20 = FUN_0010a8ca(param_1,param_2,param_3,param_4,param_5,pkey);
//      goto LAB_0010eccf;
//    }
//  }
//  else {
//    if (iVar1 == 0x198) {
//      local_20 = FUN_0010d1b9(param_1,param_2,param_3,param_4,param_5,pkey);
//      goto LAB_0010eccf;
//    }
//    if (iVar1 == 0x43f) {
//      local_20 = FUN_0010beb8(param_1,param_2,param_3,param_4,param_5,pkey);
//      goto LAB_0010eccf;
//    }
//  }
//  local_20 = _libssh2_error(param_1,0xfffffff0,
//                                                        
//                            "Unable to extract public key from private key file: Unsupported private key file format"
//                           );
//LAB_0010eccf:
//  EVP_PKEY_free(pkey);
//  return (ulong)local_20;
//}
//
//
//
//void _libssh2_dh_init(BIGNUM **param_1)
//
//{
//  BIGNUM *pBVar1;
//  
//  pBVar1 = BN_new();
//  *param_1 = pBVar1;
//  return;
//}
//
//
//
//undefined8
//_libssh2_dh_key_pair
//          (BIGNUM **param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,int param_5,
//          BN_CTX *param_6)
//
//{
//  BN_rand(*param_1,param_5 * 8 + -1,0,-1);
//  BN_mod_exp(param_2,param_3,*param_1,param_4,param_6);
//  return 0;
//}
//
//
//
//undefined8
//_libssh2_dh_secret(BIGNUM **param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,BN_CTX *param_5)
//
//{
//  BN_mod_exp(param_2,param_3,*param_1,param_4,param_5);
//  return 0;
//}
//
//
//
//void _libssh2_dh_dtor(BIGNUM **param_1)
//
//{
//  BN_clear_free(*param_1);
//  *param_1 = (BIGNUM *)0x0;
//  return;
//}
//


undefined8 FUN_0010edd7(undefined8 *param_1)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  char *local_90;
  sockaddr local_88 [6];
  undefined local_1b;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_90 = (char *)param_1[0xb];
  if (local_90 == (char *)0x0) {
    local_90 = getenv("SSH_AUTH_SOCK");
    if (local_90 == (char *)0x0) {
      uVar2 = _libssh2_error(*param_1,0xffffffd9,"no auth sock variable");
      goto LAB_0010ef25;
    }
  }
  iVar1 = socket(1,1,0);
  *(int *)(param_1 + 1) = iVar1;
  if (*(int *)(param_1 + 1) < 0) {
    uVar2 = _libssh2_error(*param_1,0xffffffd3,"failed creating socket");
  }
  else {
    local_88[0].sa_family = 1;
    strncpy(local_88[0].sa_data,local_90,0x6c);
    local_1b = 0;
    iVar1 = connect(*(int *)(param_1 + 1),local_88,0x6e);
    if (iVar1 == 0) {
      uVar2 = 0;
    }
    else {
      close(*(int *)(param_1 + 1));
      uVar2 = _libssh2_error(*param_1,0xffffffd6,"failed connecting with agent");
    }
  }
LAB_0010ef25:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 FUN_0010ef3b(long *param_1,undefined8 *param_2)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_2 + 4) == 1) {
    _libssh2_htonu32(local_14,param_2[1] & 0xffffffff);
    iVar1 = ((void*(*)())(*param_1 + 0x48))((ulong)*(uint *)(param_1 + 1),local_14,4,0,*param_1);
    if (iVar1 == -0xb) {
      uVar3 = 0xffffffdb;
      goto LAB_0010f1d9;
    }
    if (iVar1 < 0) {
      uVar3 = _libssh2_error(*param_1,0xfffffff9,"agent send failed");
      goto LAB_0010f1d9;
    }
    *(undefined4 *)(param_2 + 4) = 2;
  }
  if (*(int *)(param_2 + 4) == 2) {
    iVar1 = ((void*(*)())(*param_1 + 0x48))
                      ((ulong)*(uint *)(param_1 + 1),*param_2,param_2[1],0,*param_1);
    if (iVar1 == -0xb) {
      uVar3 = 0xffffffdb;
      goto LAB_0010f1d9;
    }
    if (iVar1 < 0) {
      uVar3 = _libssh2_error(*param_1,0xfffffff9,"agent send failed");
      goto LAB_0010f1d9;
    }
    *(undefined4 *)(param_2 + 4) = 3;
  }
  if (*(int *)(param_2 + 4) == 3) {
    iVar1 = ((void*(*)())(*param_1 + 0x50))((ulong)*(uint *)(param_1 + 1),local_14,4,0,*param_1);
    if (iVar1 < 0) {
      if (iVar1 == -0xb) {
        uVar3 = 0xffffffdb;
      }
      else {
        uVar3 = _libssh2_error(*param_1,0xffffffd5,"agent recv failed");
      }
      goto LAB_0010f1d9;
    }
    uVar2 = _libssh2_ntohu32(local_14);
    param_2[3] = (ulong)uVar2;
    uVar3 = ((void*(*)())(*param_1 + 8))(param_2[3],*param_1,param_2[3],*param_1);
    param_2[2] = uVar3;
    if (param_2[2] == 0) {
      uVar3 = 0xfffffffa;
      goto LAB_0010f1d9;
    }
    *(undefined4 *)(param_2 + 4) = 4;
  }
  if (*(int *)(param_2 + 4) == 4) {
    iVar1 = ((void*(*)())(*param_1 + 0x50))
                      ((ulong)*(uint *)(param_1 + 1),param_2[2],param_2[3],0,*param_1);
    if (iVar1 < 0) {
      if (iVar1 == -0xb) {
        uVar3 = 0xffffffdb;
      }
      else {
        uVar3 = _libssh2_error(*param_1,0xfffffff9,"agent recv failed");
      }
      goto LAB_0010f1d9;
    }
    *(undefined4 *)(param_2 + 4) = 5;
  }
  uVar3 = 0;
LAB_0010f1d9:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8 FUN_0010f1ef(undefined8 *param_1)

{
  int iVar1;
  undefined8 uVar2;
  
  iVar1 = close(*(int *)(param_1 + 1));
  if (iVar1 == -1) {
    uVar2 = _libssh2_error(*param_1,0xfffffff3,"failed closing the agent socket");
  }
  else {
    *(undefined4 *)(param_1 + 1) = 0xffffffff;
    uVar2 = 0;
  }
  return uVar2;
}



void FUN_0010f241(long param_1,void **param_2,size_t *param_3,undefined8 param_4,long param_5,
                 long *param_6)

{
  char *pcVar1;
  uint uVar2;
  char *pcVar3;
  void *pvVar4;
  long in_FS_OFFSET;
  uint local_44;
  char *local_40;
  long local_38;
  char **local_30;
  long local_28;
  char *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = *param_6;
  local_30 = (char **)(local_38 + 0x18);
  local_28 = *(long *)(local_38 + 0x40);
  local_20 = (char *)(param_5 + *(long *)(local_28 + 0x30) + 0xd);
  if (*(int *)(local_38 + 0x38) == 0) {
    pcVar3 = (char *)((void*(*)())(param_1 + 8))(local_20,param_1,local_20,param_1);
    *local_30 = pcVar3;
    pcVar3 = *local_30;
    if (*local_30 == (char *)0x0) {
      local_40 = pcVar3;
      _libssh2_error(param_1,0xfffffffa,"out of memory");
      goto LAB_0010f628;
    }
    local_40 = pcVar3 + 1;
    *pcVar3 = '\r';
    _libssh2_store_str(&local_40,*(undefined8 *)(local_28 + 0x28),*(undefined8 *)(local_28 + 0x30));

    _libssh2_store_str(&local_40,param_4,param_5);
    _libssh2_store_u32(&local_40,0);
    local_30[1] = local_40 + -(long)*local_30;
    *(undefined4 *)(local_30 + 4) = 1;
  }
  if (**local_30 == '\r') {
    if (*(long *)(local_38 + 0x10) == 0) {
      _libssh2_error(param_1,0xffffffd9,"agent not connected");
    }
    else {
      local_44 = ((void*(*)())(*(long *)(local_38 + 0x10) + 8))(local_38,local_30,local_38,local_30);
      if (local_44 == 0) {
        ((void*(*)())(param_1 + 0x18))(*local_30,param_1,*local_30,param_1);
        *local_30 = (char *)0x0;
        pcVar3 = local_30[3];
        pcVar1 = local_30[2];
        local_20 = pcVar3 + -1;
        local_40 = pcVar1;
        if ((long)local_20 < 0) {
          local_44 = 0xffffffd6;
        }
        else {
          if (*pcVar1 == '\x0e') {
            local_40 = pcVar1 + 1;
            local_20 = pcVar3 + -5;
            if ((long)local_20 < 0) {
              local_44 = 0xffffffd6;
            }
            else {
              local_40 = pcVar1 + 5;
              local_20 = pcVar3 + -9;
              if ((long)local_20 < 0) {
                local_44 = 0xffffffd6;
              }
              else {
                uVar2 = _libssh2_ntohu32(local_40);
                local_18 = (ulong)uVar2;
                local_40 = local_40 + 4;
                local_20 = local_20 + -local_18;
                if ((long)local_20 < 0) {
                  local_44 = 0xffffffd6;
                }
                else {
                  local_40 = local_40 + local_18;
                  local_20 = local_20 + -4;
                  if ((long)local_20 < 0) {
                    local_44 = 0xffffffd6;
                  }
                  else {
                    uVar2 = _libssh2_ntohu32(local_40);
                    *param_3 = (ulong)uVar2;
                    local_40 = local_40 + 4;
                    local_20 = local_20 + -*param_3;
                    if ((long)local_20 < 0) {
                      local_44 = 0xffffffd6;
                    }
                    else {
                      pvVar4 = (void *)((void*(*)())(param_1 + 8))(*param_3,param_1,*param_3,param_1)
                      ;
                      *param_2 = pvVar4;
                      if (*param_2 == (void *)0x0) {
                        local_44 = 0xfffffffa;
                      }
                      else {
                        memcpy(*param_2,local_40,*param_3);
                      }
                    }
                  }
                }
              }
            }
          }
          else {
            local_44 = 0xffffffd6;
          }
        }
      }
      ((void*(*)())(param_1 + 0x18))(*local_30,param_1,*local_30,param_1);
      *local_30 = (char *)0x0;
      ((void*(*)())(param_1 + 0x18))(local_30[2],param_1,local_30[2],param_1);
      local_30[2] = (char *)0x0;
      _libssh2_error(param_1,(ulong)local_44,"agent sign failure",(ulong)local_44);
    }
  }
  else {
    _libssh2_error(param_1,0xffffffd9,"illegal request");
  }
LAB_0010f628:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



ulong FUN_0010f63e(long *param_1)

{
  uint uVar1;
  ulong uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  bool bVar4;
  char local_45;
  uint local_44;
  char *local_40;
  ulong local_38;
  char *local_30;
  char **local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char **)(param_1 + 3);
  local_45 = '\v';
  if (*(int *)(param_1 + 7) == 0) {
    *local_28 = &local_45;
    param_1[4] = 1;
    *(undefined4 *)(param_1 + 7) = 1;
  }
  if (**local_28 == '\v') {
    if (param_1[2] == 0) {
      uVar2 = _libssh2_error(*param_1,0xffffffd9,"agent not connected");
    }
    else {
      local_44 = ((void*(*)())(param_1[2] + 8))(param_1,local_28,param_1,local_28);
      if (local_44 == 0) {
        *local_28 = (char *)0x0;
        local_30 = local_28[2];
        local_40 = local_28[3] + -1;
        if ((long)local_40 < 0) {
          local_44 = 0xffffffd6;
        }
        else {
          if (*local_30 == '\f') {
            local_30 = local_30 + 1;
            local_40 = local_28[3] + -5;
            if ((long)local_40 < 0) {
              local_44 = 0xffffffd6;
            }
            else {
              uVar1 = _libssh2_ntohu32(local_30);
              local_38 = (ulong)uVar1;
              local_30 = local_30 + 4;
              while (uVar2 = local_38 - 1, bVar4 = local_38 != 0, local_38 = uVar2, bVar4) {
                local_40 = local_40 + -4;
                if ((long)local_40 < 0) {
                  local_44 = 0xffffffd6;
                  break;
                }
                local_20 = ((void*(*)())(*param_1 + 8))(0x40,*param_1,*param_1);
                if (local_20 == 0) {
                  local_44 = 0xfffffffa;
                  break;
                }
                uVar1 = _libssh2_ntohu32(local_30);
                *(ulong *)(local_20 + 0x30) = (ulong)uVar1;
                local_30 = local_30 + 4;
                local_40 = local_40 + -*(long *)(local_20 + 0x30);
                if ((long)local_40 < 0) {
                  local_44 = 0xffffffd6;
                  ((void*(*)())(*param_1 + 0x18))(local_20,*param_1,local_20,*param_1);
                  break;
                }
                uVar3 = ((void*(*)())(*param_1 + 8))
                                  (*(undefined8 *)(local_20 + 0x30),*param_1,
                                   *(undefined8 *)(local_20 + 0x30),*param_1);
                *(undefined8 *)(local_20 + 0x28) = uVar3;
                if (*(long *)(local_20 + 0x28) == 0) {
                  local_44 = 0xfffffffa;
                  ((void*(*)())(*param_1 + 0x18))(local_20,*param_1,local_20,*param_1);
                  break;
                }
                memcpy(*(void **)(local_20 + 0x28),local_30,*(size_t *)(local_20 + 0x30));
                local_30 = local_30 + *(long *)(local_20 + 0x30);
                local_40 = local_40 + -4;
                if ((long)local_40 < 0) {
                  local_44 = 0xffffffd6;
                  ((void*(*)())(*param_1 + 0x18))
                            (*(undefined8 *)(local_20 + 0x28),*param_1,
                             *(undefined8 *)(local_20 + 0x28),*param_1);
                  ((void*(*)())(*param_1 + 0x18))(local_20,*param_1,local_20,*param_1);
                  break;
                }
                uVar1 = _libssh2_ntohu32(local_30);
                local_18 = (ulong)uVar1;
                local_30 = local_30 + 4;
                local_40 = local_40 + -local_18;
                if ((long)local_40 < 0) {
                  local_44 = 0xffffffd6;
                  ((void*(*)())(*param_1 + 0x18))
                            (*(undefined8 *)(local_20 + 0x28),*param_1,
                             *(undefined8 *)(local_20 + 0x28),*param_1);
                  ((void*(*)())(*param_1 + 0x18))(local_20,*param_1,local_20,*param_1);
                  break;
                }
                uVar3 = ((void*(*)())(*param_1 + 8))(local_18 + 1,*param_1,local_18 + 1,*param_1);
                *(undefined8 *)(local_20 + 0x38) = uVar3;
                if (*(long *)(local_20 + 0x38) == 0) {
                  local_44 = 0xfffffffa;
                  ((void*(*)())(*param_1 + 0x18))
                            (*(undefined8 *)(local_20 + 0x28),*param_1,
                             *(undefined8 *)(local_20 + 0x28),*param_1);
                  ((void*(*)())(*param_1 + 0x18))(local_20,*param_1,local_20,*param_1);
                  break;
                }
                *(undefined *)(local_18 + *(long *)(local_20 + 0x38)) = 0;
                memcpy(*(void **)(local_20 + 0x38),local_30,local_18);
                local_30 = local_30 + local_18;
                _libssh2_list_add(param_1 + 9,local_20);
              }
            }
          }
          else {
            local_44 = 0xffffffd6;
          }
        }
        ((void*(*)())(*param_1 + 0x18))(local_28[2],*param_1,local_28[2],*param_1);
        local_28[2] = (char *)0x0;
        uVar2 = _libssh2_error(*param_1,(ulong)local_44,"agent list id failed",(ulong)local_44);
      }
      else {
        ((void*(*)())(*param_1 + 0x18))(local_28[2],*param_1,local_28[2],*param_1);
        local_28[2] = (char *)0x0;
        uVar2 = (ulong)local_44;
      }
    }
  }
  else {
    uVar2 = _libssh2_error(*param_1,0xffffffd9);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



void FUN_0010fb45(long *param_1)

{
  long lVar1;
  long local_18;
  
  local_18 = _libssh2_list_first(param_1 + 9);
  while (local_18 != 0) {
    lVar1 = _libssh2_list_next(local_18);
    ((void*(*)())(*param_1 + 0x18))
              (*(undefined8 *)(local_18 + 0x28),*param_1,*(undefined8 *)(local_18 + 0x28),*param_1);
    ((void*(*)())(*param_1 + 0x18))
              (*(undefined8 *)(local_18 + 0x38),*param_1,*(undefined8 *)(local_18 + 0x38),*param_1);
    ((void*(*)())(*param_1 + 0x18))(local_18,*param_1,local_18,*param_1);
    local_18 = lVar1;
  }
  _libssh2_list_init(param_1 + 9);
  return;
}



undefined4 * FUN_0010fc0b(long param_1)

{
  *(undefined4 *)(param_1 + 0x18) = 0x3bdefed2;
  *(long *)(param_1 + 0x20) = param_1;
  return (undefined4 *)(param_1 + 0x18);
}



undefined8 * libssh2_agent_init(undefined8 param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_libssh2_calloc(param_1,0x60);
  if (puVar1 == (undefined8 *)0x0) {
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate space for agent connection");
    puVar1 = (undefined8 *)0x0;
  }
  else {
    *(undefined4 *)(puVar1 + 1) = 0xffffffff;
    *puVar1 = param_1;
    puVar1[0xb] = 0;
    _libssh2_list_init(puVar1 + 9);
  }
  return puVar1;
}



ulong libssh2_agent_connect(long param_1,undefined8 param_2)

{
  int local_10;
  uint local_c;
  
  local_c = 0xffffffff;
  local_10 = 0;
  while( 1 ) {
    if ((&PTR_DAT_00350940)[(long)local_10 * 2] == (undefined *)0x0) {
      return (ulong)local_c;
    }
    *(undefined **)(param_1 + 0x10) = (&PTR_agent_ops_unix_00350948)[(long)local_10 * 2];

    if (local_c == 0) break;
    local_10 = local_10 + 1;
  }
  return 0;
}



void libssh2_agent_list_identities(long param_1)

{
  memset((void *)(param_1 + 0x18),0,0x28);
  FUN_0010fb45(param_1);
  FUN_0010f63e(param_1);
  return;
}



ulong libssh2_agent_get_identity(long param_1,undefined8 *param_2,long param_3)

{
  undefined8 uVar1;
  long local_18;
  
  if ((param_3 == 0) || (*(long *)(param_3 + 8) == 0)) {
    local_18 = _libssh2_list_first(param_1 + 0x48);
  }
  else {
    local_18 = _libssh2_list_next(*(undefined8 *)(param_3 + 8));
  }
  if (local_18 != 0) {
    uVar1 = FUN_0010fc0b(local_18);
    *param_2 = uVar1;
  }
  return (ulong)(local_18 == 0);
}



ulong libssh2_agent_userauth(long *param_1,char *param_2,long param_3)

{
  undefined8 uVar1;
  undefined8 uVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  undefined8 uVar4;
  uint local_34;
  long *local_30;
  time_t local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = param_1;
  if (*(int *)(*param_1 + 0xd130) == 0) {
    memset(param_1 + 3,0,0x28);
    param_1[8] = *(long *)(param_3 + 8);
  }
  local_28 = time((time_t *)0x0);
  do {
    uVar1 = *(undefined8 *)(param_3 + 0x18);
    uVar2 = *(undefined8 *)(param_3 + 0x10);
    uVar4 = 0x10fe96;
    sVar3 = strlen(param_2);
    local_34 = _libssh2_userauth_publickey
                         (*param_1,param_2,sVar3 & 0xffffffff,uVar2,uVar1,FUN_0010f241,&local_30);
    if ((local_34 != 0xffffffdb) || (*(int *)(*param_1 + 0x94) == 0)) break;

  } while (local_34 == 0);
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (ulong)local_34;
}



//undefined8 libssh2_agent_disconnect(long param_1,undefined8 param_2)
//
//{
//  undefined8 uVar1;
//  
//  if ((*(long *)(param_1 + 0x10) == 0) || (*(int *)(param_1 + 8) == -1)) {
//    uVar1 = 0;
//  }
//  else {
//    uVar1 = ((void*(*)())(*(long *)(param_1 + 0x10) + 0x10))(param_1,param_2,param_1);
//  }
//  return uVar1;
//}



void libssh2_agent_free(long *param_1)

{
  if (*(int *)(param_1 + 1) != -1) {
    libssh2_agent_disconnect(param_1, 0);
  }
  if (param_1[0xb] != 0) {
    ((void*(*)())(*param_1 + 0x18))(param_1[0xb],*param_1,param_1[0xb],*param_1);
  }
  FUN_0010fb45(param_1);
  ((void*(*)())(*param_1 + 0x18))(param_1,*param_1,param_1,*param_1);
  return;
}



void libssh2_agent_set_identity_path(long *param_1,char *param_2)

{
  size_t __n;
  void *__dest;
  
  if (param_1[0xb] != 0) {
    ((void*(*)())(*param_1 + 0x18))(param_1[0xb],*param_1,param_1[0xb],*param_1);
    param_1[0xb] = 0;
  }
  if (param_2 != (char *)0x0) {
    __n = strlen(param_2);
    if (__n < 0xfffffffffffffffe) {
      __dest = (void *)((void*(*)())(*param_1 + 8))(__n + 1,*param_1,__n + 1,*param_1);
      memcpy(__dest,param_2,__n);
      *(undefined *)(__n + (long)__dest) = 0;
      *(void **)(param_1 + 0xb) = __dest;
    }
  }
  return;
}



undefined8 libssh2_agent_get_identity_path(long param_1)

{
  return *(undefined8 *)(param_1 + 0x58);
}



void FUN_001100c8(undefined8 param_1,undefined8 param_2,long param_3)

{
  undefined4 uVar1;
  long in_FS_OFFSET;
  undefined2 local_10b6;
  int local_10b4;
  ulong local_10b0;
  undefined4 local_10a8 [8];
  undefined local_1088 [4176];
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = 0x6d6f72686379784f;
  local_30 = 0x776f6c4263697461;
  local_28 = 0x7461775368736966;
  local_20 = 0x6574696d616e7944;
  local_10b0 = 0x40;
  Blowfish_initstate(local_1088);
  Blowfish_expandstate(local_1088,param_2,local_10b0 & 0xffff,param_1,local_10b0 & 0xffff);
  local_10b4 = 0;
  while (local_10b4 < 0x40) {
    Blowfish_expand0state(local_1088,param_2,local_10b0 & 0xffff);
    Blowfish_expand0state(local_1088,param_1,local_10b0 & 0xffff);
    local_10b4 = local_10b4 + 1;
  }
  local_10b6 = 0;
  local_10b4 = 0;
  while (local_10b4 < 8) {
    uVar1 = Blowfish_stream2word(&local_38,0x20,&local_10b6);
    local_10a8[local_10b4] = uVar1;
    local_10b4 = local_10b4 + 1;
  }
  local_10b4 = 0;
  while (local_10b4 < 0x40) {
    blf_enc(local_1088,local_10a8,4);
    local_10b4 = local_10b4 + 1;
  }
  local_10b4 = 0;
  while (local_10b4 < 8) {
    *(undefined *)(param_3 + (long)(local_10b4 << 2) + 3) =
         (char)((uint)local_10a8[local_10b4] >> 0x18);
    *(undefined *)(param_3 + (long)(local_10b4 << 2) + 2) =
         (char)((uint)local_10a8[local_10b4] >> 0x10);
    *(undefined *)(param_3 + (long)(local_10b4 << 2) + 1) =
         (char)((uint)local_10a8[local_10b4] >> 8);
    *(undefined *)(param_3 + (local_10b4 << 2)) = (char)local_10a8[local_10b4];
    local_10b4 = local_10b4 + 1;
  }
  _libssh2_explicit_zero(&local_38,0x20);
  _libssh2_explicit_zero(local_10a8,0x20);
  _libssh2_explicit_zero(local_1088,0x1048);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



//undefined8
//bcrypt_pbkdf(void *param_1,size_t param_2,void *param_3,ulong param_4,long param_5,ulong param_6,
//            uint param_7)
//
//{
//  undefined8 uVar1;
//  long in_FS_OFFSET;
//  ulong local_158;
//  int local_11c;
//  EVP_MD_CTX *local_118;
//  ulong local_110;
//  ulong local_108;
//  ulong local_100;
//  ulong local_f8;
//  void *local_f0;
//  ulong local_e8;
//  ulong local_e0;
//  undefined8 local_d8;
//  undefined8 local_d0;
//  undefined8 local_c8;
//  undefined8 local_c0;
//  undefined8 local_b8;
//  undefined8 local_b0;
//  undefined8 local_a8;
//  undefined8 local_a0;
//  uchar local_98 [64];
//  uchar local_58 [72];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_f8 = param_6;
//  if (param_7 == 0) {
//    uVar1 = 0xffffffff;
//  }
//  else {
//    if ((((param_2 == 0) || (param_4 == 0)) || (param_6 == 0)) ||
//       ((0x400 < param_6 || (0x100000 < param_4)))) {
//      uVar1 = 0xffffffff;
//    }
//    else {
//      local_f0 = calloc(1,param_4 + 4);
//      if (local_f0 == (void *)0x0) {
//        uVar1 = 0xffffffff;
//      }
//      else {
//        local_e8 = param_6 + 0x1f >> 5;
//        local_100 = ((local_e8 + param_6) - 1) / local_e8;
//        memcpy(local_f0,param_3,param_4);
//        _libssh2_sha512_init(&local_118);
//        EVP_DigestUpdate(local_118,param_1,param_2);
//        EVP_DigestFinal(local_118,local_98,(uint *)0x0);
//        EVP_MD_CTX_free(local_118);
//        local_11c = 1;
//        local_158 = param_6;
//        while (local_158 != 0) {
//          *(undefined *)(param_4 + (long)local_f0) = (char)((uint)local_11c >> 0x18);
//          *(undefined *)((long)local_f0 + param_4 + 1) = (char)((uint)local_11c >> 0x10);
//          *(undefined *)((long)local_f0 + param_4 + 2) = (char)((uint)local_11c >> 8);
//          *(undefined *)((long)local_f0 + param_4 + 3) = (char)local_11c;
//          _libssh2_sha512_init(&local_118);
//          EVP_DigestUpdate(local_118,local_f0,param_4 + 4);
//          EVP_DigestFinal(local_118,local_58,(uint *)0x0);
//          EVP_MD_CTX_free(local_118);
//          FUN_001100c8(local_98,local_58,&local_b8);
//          local_d8 = local_b8;
//          local_d0 = local_b0;
//          local_c8 = local_a8;
//          local_c0 = local_a0;
//          local_110 = 1;
//          while (local_110 < param_7) {
//            _libssh2_sha512_init(&local_118);
//            EVP_DigestUpdate(local_118,&local_b8,0x20);
//            EVP_DigestFinal(local_118,local_58,(uint *)0x0);
//            EVP_MD_CTX_free(local_118);
//            FUN_001100c8(local_98,local_58,&local_b8);
//            local_108 = 0;
//            while (local_108 < 0x20) {
//              *(byte *)((long)&local_d8 + local_108) =
//                   *(byte *)((long)&local_d8 + local_108) ^ *(byte *)((long)&local_b8 + local_108);
//              local_108 = local_108 + 1;
//            }
//            local_110 = local_110 + 1;
//          }
//          if (local_158 <= local_100) {
//            local_100 = local_158;
//          }
//          local_110 = 0;
//          while ((local_110 < local_100 &&
//                 (local_e0 = local_110 * local_e8 + (ulong)(local_11c - 1), local_e0 < local_f8))) {
//            *(undefined *)(param_5 + local_e0) = *(undefined *)((long)&local_d8 + local_110);
//            local_110 = local_110 + 1;
//          }
//          local_158 = local_158 - local_110;
//          local_11c = local_11c + 1;
//        }
//        _libssh2_explicit_zero(&local_d8,0x20);
//        free(local_f0);
//        uVar1 = 0;
//      }
//    }
//  }
//  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar1;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}
//


//void Blowfish_encipher(long param_1,uint *param_2,uint *param_3)
//
//{
//  uint uVar1;
//  uint uVar2;
//  int iVar3;
//  int iVar4;
//  uint uVar5;
//  int iVar6;
//  uint uVar7;
//  
//  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1000);
//  uVar2 = *param_3 ^
//          *(uint *)(param_1 + 0x1004) ^
//          (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1008) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x100c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1010) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1014) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1018) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x101c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1020) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1024) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1028) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x102c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1030) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1034) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1038) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x103c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  iVar3 = *(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4);
//  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
//  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
//  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar7 = *(uint *)(param_1 + 0x1040);
//  *param_2 = *(uint *)(param_1 + 0x1044) ^ uVar2;
//  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
//  return;
//}
//
//
//
//void Blowfish_decipher(long param_1,uint *param_2,uint *param_3)
//
//{
//  uint uVar1;
//  uint uVar2;
//  int iVar3;
//  int iVar4;
//  uint uVar5;
//  int iVar6;
//  uint uVar7;
//  
//  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1044);
//  uVar2 = *param_3 ^
//          *(uint *)(param_1 + 0x1040) ^
//          (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x103c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1038) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1034) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1030) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x102c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1028) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1024) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1020) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x101c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1018) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1014) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1010) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x100c) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1008) ^
//                  (*(int *)(param_1 + (ulong)(byte)(uVar1 >> 0x18) * 4) +
//                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
//                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
//                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
//  iVar3 = *(int *)(param_1 + (ulong)(byte)(uVar2 >> 0x18) * 4);
//  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
//  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
//  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
//  uVar7 = *(uint *)(param_1 + 0x1004);
//  *param_2 = *(uint *)(param_1 + 0x1000) ^ uVar2;
//  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
//  return;
//}
//
//
//
//void Blowfish_initstate(undefined8 *param_1)
//
//{
//  ulong uVar1;
//  undefined8 *puVar2;
//  undefined8 *puVar3;
//  
//  *param_1 = 0x98dfb5acd1310ba6;
//  param_1[0x208] = 0x8979fb1b9216d5d9;
//  puVar2 = (undefined8 *)
//           ((long)param_1 - (long)(undefined8 *)((ulong)(param_1 + 1) & 0xfffffffffffffff8));
//  uVar1 = (ulong)((int)puVar2 + 0x1048U >> 3);
//  puVar2 = (undefined8 *)((long)&DAT_00144aa0 - (long)puVar2);
//  puVar3 = (undefined8 *)((ulong)(param_1 + 1) & 0xfffffffffffffff8);
//  while (uVar1 != 0) {
//    uVar1 = uVar1 - 1;
//    *puVar3 = *puVar2;
//    puVar2 = puVar2 + 1;
//    puVar3 = puVar3 + 1;
//  }
//  return;
//}
//
//
//
//ulong Blowfish_stream2word(long param_1,ushort param_2,ushort *param_3)
//
//{
//  byte local_f;
//  ushort local_e;
//  uint local_c;
//  
//  local_c = 0;
//  local_e = *param_3;
//  local_f = 0;
//  while (local_f < 4) {
//    if (param_2 <= local_e) {
//      local_e = 0;
//    }
//    local_c = (uint)*(byte *)(param_1 + (ulong)local_e) | local_c << 8;
//    local_f = local_f + 1;
//    local_e = local_e + 1;
//  }
//  *param_3 = local_e;
//  return (ulong)local_c;
//}
//
//
//
//void Blowfish_expand0state(long param_1,undefined8 param_2,ushort param_3)
//
//{
//  long in_FS_OFFSET;
//  undefined2 local_22;
//  ushort local_20;
//  ushort local_1e;
//  undefined4 local_1c;
//  undefined4 local_18;
//  uint local_14;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_22 = 0;
//  local_20 = 0;
//  while (local_20 < 0x12) {
//    local_14 = Blowfish_stream2word(param_2,(ulong)param_3,&local_22);
//    *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) =
//         *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) ^ local_14;
//    local_20 = local_20 + 1;
//  }
//  local_22 = 0;
//  local_1c = 0;
//  local_18 = 0;
//  local_20 = 0;
//  while (local_20 < 0x12) {
//    Blowfish_encipher(param_1,&local_1c,&local_18);
//    *(undefined4 *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) = local_1c;
//    *(undefined4 *)(param_1 + ((long)(int)((uint)local_20 + 1) + 0x400) * 4) = local_18;
//    local_20 = local_20 + 2;
//  }
//  local_20 = 0;
//  while (local_20 < 4) {
//    local_1e = 0;
//    while (local_1e < 0x100) {
//      Blowfish_encipher(param_1,&local_1c,&local_18);
//      *(undefined4 *)(param_1 + ((long)(int)(uint)local_1e + (long)(int)(uint)local_20 * 0x100) * 4)
//           = local_1c;
//      *(undefined4 *)
//       (param_1 + ((long)(int)((uint)local_1e + 1) + (long)(int)(uint)local_20 * 0x100) * 4) =
//           local_18;
//      local_1e = local_1e + 2;
//    }
//    local_20 = local_20 + 1;
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return;
//}
//
//
//
//void Blowfish_expandstate
//               (long param_1,undefined8 param_2,ushort param_3,undefined8 param_4,ushort param_5)
//
//{
//  uint uVar1;
//  long in_FS_OFFSET;
//  undefined2 local_22;
//  ushort local_20;
//  ushort local_1e;
//  uint local_1c;
//  uint local_18;
//  uint local_14;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_22 = 0;
//  local_20 = 0;
//  while (local_20 < 0x12) {
//    local_14 = Blowfish_stream2word(param_4,(ulong)param_5,&local_22);
//    *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) =
//         *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) ^ local_14;
//    local_20 = local_20 + 1;
//  }
//  local_22 = 0;
//  local_1c = 0;
//  local_18 = 0;
//  local_20 = 0;
//  while (local_20 < 0x12) {
//    uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&local_22);
//    local_1c = local_1c ^ uVar1;
//    uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&local_22);
//    local_18 = local_18 ^ uVar1;
//    Blowfish_encipher(param_1,&local_1c,&local_18);
//    *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) = local_1c;
//    *(uint *)(param_1 + ((long)(int)((uint)local_20 + 1) + 0x400) * 4) = local_18;
//    local_20 = local_20 + 2;
//  }
//  local_20 = 0;
//  while (local_20 < 4) {
//    local_1e = 0;
//    while (local_1e < 0x100) {
//      uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&local_22);
//      local_1c = local_1c ^ uVar1;
//      uVar1 = Blowfish_stream2word(param_2,(ulong)param_3,&local_22);
//      local_18 = local_18 ^ uVar1;
//      Blowfish_encipher(param_1,&local_1c,&local_18);
//      *(uint *)(param_1 + ((long)(int)(uint)local_1e + (long)(int)(uint)local_20 * 0x100) * 4) =
//           local_1c;
//      *(uint *)(param_1 + ((long)(int)((uint)local_1e + 1) + (long)(int)(uint)local_20 * 0x100) * 4)
//           = local_18;
//      local_1e = local_1e + 2;
//    }
//    local_20 = local_20 + 1;
//  }
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return;
//}
//


void blf_key(undefined8 param_1,undefined8 param_2,ushort param_3)

{
  Blowfish_initstate(param_1);
  Blowfish_expand0state(param_1,param_2,(ulong)param_3);
  return;
}



//void blf_enc(undefined8 param_1,long param_2,ushort param_3)
//
//{
//  ushort local_12;
//  long local_10;
//  
//  local_12 = 0;
//  local_10 = param_2;
//  while (local_12 < param_3) {
//    Blowfish_encipher(param_1,local_10,local_10 + 4);
//    local_10 = local_10 + 8;
//    local_12 = local_12 + 1;
//  }
//  return;
//}
//
//
//
//void blf_dec(undefined8 param_1,long param_2,ushort param_3)
//
//{
//  ushort local_12;
//  long local_10;
//  
//  local_12 = 0;
//  local_10 = param_2;
//  while (local_12 < param_3) {
//    Blowfish_decipher(param_1,local_10,local_10 + 4);
//    local_10 = local_10 + 8;
//    local_12 = local_12 + 1;
//  }
//  return;
//}



void blf_ecb_encrypt(undefined8 param_1,byte *param_2,uint param_3)

{
  long in_FS_OFFSET;
  byte *local_38;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_14 = 0;
  local_38 = param_2;
  while (local_14 < param_3) {
    local_1c = (uint)local_38[3] |
               (uint)*local_38 << 0x18 | (uint)local_38[1] << 0x10 | (uint)local_38[2] << 8;
    local_18 = (uint)local_38[7] |
               (uint)local_38[4] << 0x18 | (uint)local_38[5] << 0x10 | (uint)local_38[6] << 8;
    Blowfish_encipher(param_1,&local_1c,&local_18);
    *local_38 = (byte)(local_1c >> 0x18);
    local_38[1] = (byte)(local_1c >> 0x10);
    local_38[2] = (byte)(local_1c >> 8);
    local_38[3] = (byte)local_1c;
    local_38[4] = (byte)(local_18 >> 0x18);
    local_38[5] = (byte)(local_18 >> 0x10);
    local_38[6] = (byte)(local_18 >> 8);
    local_38[7] = (byte)local_18;
    local_38 = local_38 + 8;
    local_14 = local_14 + 8;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_ecb_decrypt(undefined8 param_1,byte *param_2,uint param_3)

{
  long in_FS_OFFSET;
  byte *local_38;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_14 = 0;
  local_38 = param_2;
  while (local_14 < param_3) {
    local_1c = (uint)local_38[3] |
               (uint)*local_38 << 0x18 | (uint)local_38[1] << 0x10 | (uint)local_38[2] << 8;
    local_18 = (uint)local_38[7] |
               (uint)local_38[4] << 0x18 | (uint)local_38[5] << 0x10 | (uint)local_38[6] << 8;
    Blowfish_decipher(param_1,&local_1c,&local_18);
    *local_38 = (byte)(local_1c >> 0x18);
    local_38[1] = (byte)(local_1c >> 0x10);
    local_38[2] = (byte)(local_1c >> 8);
    local_38[3] = (byte)local_1c;
    local_38[4] = (byte)(local_18 >> 0x18);
    local_38[5] = (byte)(local_18 >> 0x10);
    local_38[6] = (byte)(local_18 >> 8);
    local_38[7] = (byte)local_18;
    local_38 = local_38 + 8;
    local_14 = local_14 + 8;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_cbc_encrypt(undefined8 param_1,byte *param_2,byte *param_3,uint param_4)

{
  long in_FS_OFFSET;
  byte *local_40;
  byte *local_38;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  local_40 = param_3;
  local_38 = param_2;
  while (local_18 < param_4) {
    local_14 = 0;
    while (local_14 < 8) {
      local_40[local_14] = local_40[local_14] ^ local_38[local_14];
      local_14 = local_14 + 1;
    }
    local_20 = (uint)local_40[3] |
               (uint)*local_40 << 0x18 | (uint)local_40[1] << 0x10 | (uint)local_40[2] << 8;
    local_1c = (uint)local_40[7] |
               (uint)local_40[4] << 0x18 | (uint)local_40[5] << 0x10 | (uint)local_40[6] << 8;
    Blowfish_encipher(param_1,&local_20,&local_1c);
    *local_40 = (byte)(local_20 >> 0x18);
    local_40[1] = (byte)(local_20 >> 0x10);
    local_40[2] = (byte)(local_20 >> 8);
    local_40[3] = (byte)local_20;
    local_40[4] = (byte)(local_1c >> 0x18);
    local_40[5] = (byte)(local_1c >> 0x10);
    local_40[6] = (byte)(local_1c >> 8);
    local_40[7] = (byte)local_1c;
    local_38 = local_40;
    local_40 = local_40 + 8;
    local_18 = local_18 + 8;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_cbc_decrypt(undefined8 param_1,long param_2,long param_3,uint param_4)

{
  long in_FS_OFFSET;
  byte *local_40;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = param_3 + ((ulong)param_4 - 0x10);
  local_40 = (byte *)(param_3 + ((ulong)param_4 - 8));
  local_20 = param_4 - 8;
  while (7 < local_20) {
    local_28 = (uint)local_40[3] |
               (uint)*local_40 << 0x18 | (uint)local_40[1] << 0x10 | (uint)local_40[2] << 8;
    local_24 = (uint)local_40[7] |
               (uint)local_40[4] << 0x18 | (uint)local_40[5] << 0x10 | (uint)local_40[6] << 8;
    Blowfish_decipher(param_1,&local_28,&local_24);
    *local_40 = (byte)(local_28 >> 0x18);
    local_40[1] = (byte)(local_28 >> 0x10);
    local_40[2] = (byte)(local_28 >> 8);
    local_40[3] = (byte)local_28;
    local_40[4] = (byte)(local_24 >> 0x18);
    local_40[5] = (byte)(local_24 >> 0x10);
    local_40[6] = (byte)(local_24 >> 8);
    local_40[7] = (byte)local_24;
    local_1c = 0;
    while (local_1c < 8) {
      local_40[local_1c] = local_40[local_1c] ^ *(byte *)(local_18 + (ulong)local_1c);
      local_1c = local_1c + 1;
    }
    local_18 = local_18 + -8;
    local_40 = local_40 + -8;
    local_20 = local_20 - 8;
  }
  local_28 = (uint)local_40[3] |
             (uint)*local_40 << 0x18 | (uint)local_40[1] << 0x10 | (uint)local_40[2] << 8;
  local_24 = (uint)local_40[7] |
             (uint)local_40[4] << 0x18 | (uint)local_40[5] << 0x10 | (uint)local_40[6] << 8;
  Blowfish_decipher(param_1,&local_28,&local_24);
  *local_40 = (byte)(local_28 >> 0x18);
  local_40[1] = (byte)(local_28 >> 0x10);
  local_40[2] = (byte)(local_28 >> 8);
  local_40[3] = (byte)local_28;
  local_40[4] = (byte)(local_24 >> 0x18);
  local_40[5] = (byte)(local_24 >> 0x10);
  local_40[6] = (byte)(local_24 >> 8);
  local_40[7] = (byte)local_24;
  local_1c = 0;
  while (local_1c < 8) {
    local_40[local_1c] = local_40[local_1c] ^ *(byte *)(param_2 + (ulong)local_1c);
    local_1c = local_1c + 1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



//ulong _libssh2_channel_nextid(long param_1)
//
//{
//  uint local_14;
//  long local_10;
//  
//  local_14 = *(uint *)(param_1 + 0x210);
//  local_10 = _libssh2_list_first(param_1 + 0x200);
//  while (local_10 != 0) {
//    if (local_14 < *(uint *)(local_10 + 0x30)) {
//      local_14 = *(uint *)(local_10 + 0x30);
//    }
//    local_10 = _libssh2_list_next(local_10);
//  }
//  *(int *)(param_1 + 0x210) = local_14 + 1;
//  return (ulong)local_14;
//}



long _libssh2_channel_locate(long param_1,int param_2, ulong param_3)

{
  long local_18;
  long local_10;
  
  local_18 = _libssh2_list_first(param_1 + 0x200);
  while (local_18 != 0) {
    if (param_2 == *(int *)(local_18 + 0x30)) {
      return local_18;
    }
    local_18 = _libssh2_list_next(local_18);
  }
  local_10 = _libssh2_list_first(param_1 + 0x218);
  do {
    if (local_10 == 0) {
      return 0;
    }
    local_18 = _libssh2_list_first(local_10 + 0x30);
    while (local_18 != 0) {
      if (param_2 == *(int *)(local_18 + 0x30)) {
        return local_18;
      }
      local_18 = _libssh2_list_next(local_18);
    }
    local_10 = _libssh2_list_next(local_10);
  } while( 1 );
}



//undefined8
//_libssh2_channel_open
//          (long param_1,void *param_2,uint param_3,uint param_4,uint param_5,undefined8 param_6,
//          undefined8 param_7)
//
//{
//  long lVar1;
//  undefined *puVar2;
//  undefined4 uVar3;
//  uint uVar4;
//  int iVar5;
//  undefined8 uVar6;
//  long in_FS_OFFSET;
//  undefined *local_30;
//  undefined local_24 [4];
//  long local_20;
//  
//  local_20 = *(long *)(in_FS_OFFSET + 0x28);
//  if (*(int *)(param_1 + 0xd1e8) == 0) {
//    *(undefined8 *)(param_1 + 0xd1f8) = 0;
//    *(undefined8 *)(param_1 + 0xd200) = 0;
//    *(undefined8 *)(param_1 + 0xd210) = 0;
//    *(ulong *)(param_1 + 0xd208) = (ulong)(param_3 + 0x11);
//    uVar3 = _libssh2_channel_nextid(param_1);
//    *(undefined4 *)(param_1 + 0xd220) = uVar3;
//    memset((void *)(param_1 + 0xd1f0),0,8);
//    uVar6 = _libssh2_calloc(param_1,0x2f0);
//    *(undefined8 *)(param_1 + 0xd1f8) = uVar6;
//    if (*(long *)(param_1 + 0xd1f8) == 0) {
//      _libssh2_error(param_1,0xfffffffa,"Unable to allocate space for channel data");
//      uVar6 = 0;
//      goto LAB_001132fc;
//    }
//    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x20) = param_3;
//    lVar1 = *(long *)(param_1 + 0xd1f8);
//    uVar6 = ((void*(*)())(param_1 + 8))((ulong)param_3,param_1,(ulong)param_3,param_1);
//    *(undefined8 *)(lVar1 + 0x18) = uVar6;
//    if (*(long *)(*(long *)(param_1 + 0xd1f8) + 0x18) == 0) {
//      _libssh2_error(param_1,0xfffffffa,"Failed allocating memory for channel type name");
//      ((void*(*)())(param_1 + 0x18))
//                (*(undefined8 *)(param_1 + 0xd1f8),param_1,*(undefined8 *)(param_1 + 0xd1f8),param_1
//                );
//      *(undefined8 *)(param_1 + 0xd1f8) = 0;
//      uVar6 = 0;
//      goto LAB_001132fc;
//    }
//    memcpy(*(void **)(*(long *)(param_1 + 0xd1f8) + 0x18),param_2,(ulong)param_3);
//    *(undefined4 *)(*(long *)(param_1 + 0xd1f8) + 0x30) = *(undefined4 *)(param_1 + 0xd220);
//    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x4c) = param_4;
//    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x48) = param_4;
//    *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x50) = param_5;
//    *(long *)(*(long *)(param_1 + 0xd1f8) + 0x60) = param_1;
//    _libssh2_list_add(param_1 + 0x200,*(undefined8 *)(param_1 + 0xd1f8),
//                      *(undefined8 *)(param_1 + 0xd1f8));
//    uVar6 = ((void*(*)())(param_1 + 8))
//                      (*(undefined8 *)(param_1 + 0xd208),param_1,*(undefined8 *)(param_1 + 0xd208),
//                       param_1);
//    *(undefined8 *)(param_1 + 0xd200) = uVar6;
//    puVar2 = *(undefined **)(param_1 + 0xd200);
//    if (*(long *)(param_1 + 0xd200) != 0) {
//      local_30 = puVar2 + 1;
//      *puVar2 = 0x5a;
//      _libssh2_store_str(&local_30,param_2,(ulong)param_3,param_2);
//      _libssh2_store_u32(&local_30,(ulong)*(uint *)(param_1 + 0xd220),
//                         (ulong)*(uint *)(param_1 + 0xd220));
//      _libssh2_store_u32(&local_30,(ulong)param_4,(ulong)param_4);
//      _libssh2_store_u32(&local_30,(ulong)param_5,(ulong)param_5);
//      *(undefined4 *)(param_1 + 0xd1e8) = 2;
//      goto LAB_00112d7b;
//    }
//    local_30 = puVar2;
//    _libssh2_error(param_1,0xfffffffa,"Unable to allocate temporary space for packet");
//  }
//  else {
//LAB_00112d7b:
//    if (*(int *)(param_1 + 0xd1e8) == 2) {
//      uVar4 = _libssh2_transport_send
//                        (param_1,*(undefined8 *)(param_1 + 0xd200),*(undefined8 *)(param_1 + 0xd208)
//                         ,param_6,param_7);
//      if (uVar4 == 0xffffffdb) {
//        _libssh2_error(param_1,0xffffffdb,"Would block sending channel-open request",0xffffffdb);
//        uVar6 = 0;
//        goto LAB_001132fc;
//      }
//      if (uVar4 != 0) {
//        _libssh2_error(param_1,(ulong)uVar4,"Unable to send channel-open request",(ulong)uVar4);
//        goto LAB_00113121;
//      }
//      *(undefined4 *)(param_1 + 0xd1e8) = 3;
//    }
//    if (*(int *)(param_1 + 0xd1e8) == 3) {
//      uVar4 = _libssh2_packet_requirev
//                        (param_1,&DAT_0014667a,param_1 + 0xd210,param_1 + 0xd218,1,
//                         *(long *)(param_1 + 0xd200) + (ulong)param_3 + 5,4,param_1 + 0xd1f0);
//      if (uVar4 == 0xffffffdb) {
//        _libssh2_error(param_1,0xffffffdb,"Would block");
//        uVar6 = 0;
//        goto LAB_001132fc;
//      }
//      if (uVar4 == 0) {
//        if (*(long *)(param_1 + 0xd218) == 0) {
//          _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
//        }
//        else {
//          if (**(char **)(param_1 + 0xd210) == '[') {
//            if (0x10 < *(ulong *)(param_1 + 0xd218)) {
//              lVar1 = *(long *)(param_1 + 0xd1f8);
//              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 5);
//              *(undefined4 *)(lVar1 + 0x44) = uVar3;
//              lVar1 = *(long *)(param_1 + 0xd1f8);
//              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 9);
//              *(undefined4 *)(lVar1 + 0x38) = uVar3;
//              lVar1 = *(long *)(param_1 + 0xd1f8);
//              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 9);
//              *(undefined4 *)(lVar1 + 0x34) = uVar3;
//              lVar1 = *(long *)(param_1 + 0xd1f8);
//              uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 0xd);
//              *(undefined4 *)(lVar1 + 0x3c) = uVar3;
//              ((void*(*)())(param_1 + 0x18))
//                        (*(undefined8 *)(param_1 + 0xd200),param_1,*(undefined8 *)(param_1 + 0xd200)
//                         ,param_1);
//              *(undefined8 *)(param_1 + 0xd200) = 0;
//              ((void*(*)())(param_1 + 0x18))
//                        (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210)
//                         ,param_1);
//              *(undefined8 *)(param_1 + 0xd210) = 0;
//              *(undefined4 *)(param_1 + 0xd1e8) = 0;
//              uVar6 = *(undefined8 *)(param_1 + 0xd1f8);
//              goto LAB_001132fc;
//            }
//            _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
//          }
//          else {
//            if (**(char **)(param_1 + 0xd210) == '\\') {
//              uVar4 = _libssh2_ntohu32(*(long *)(param_1 + 0xd210) + 5);
//              if (uVar4 == 2) {
//                _libssh2_error(param_1,0xffffffeb,"Channel open failure (connect failed)");
//              }
//              else {
//                if (uVar4 < 3) {
//                  if (uVar4 == 1) {
//                    _libssh2_error(param_1,0xffffffeb,
//                                   "Channel open failure (administratively prohibited)");
//                  }
//                  else {
//LAB_00113106:
//                    _libssh2_error(param_1,0xffffffeb,"Channel open failure");
//                  }
//                }
//                else {
//                  if (uVar4 == 3) {
//                    _libssh2_error(param_1,0xffffffeb,"Channel open failure (unknown channel type)")
//                    ;
//                  }
//                  else {
//                    if (uVar4 != 4) goto LAB_00113106;
//                    _libssh2_error(param_1,0xffffffeb,"Channel open failure (resource shortage)");
//                  }
//                }
//              }
//            }
//          }
//        }
//      }
//      else {
//        _libssh2_error(param_1,(ulong)uVar4,"Unexpected error",(ulong)uVar4);
//      }
//    }
//  }
//LAB_00113121:
//  if (*(long *)(param_1 + 0xd210) != 0) {
//    ((void*(*)())(param_1 + 0x18))
//              (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210),param_1);
//    *(undefined8 *)(param_1 + 0xd210) = 0;
//  }
//  if (*(long *)(param_1 + 0xd200) != 0) {
//    ((void*(*)())(param_1 + 0x18))
//              (*(undefined8 *)(param_1 + 0xd200),param_1,*(undefined8 *)(param_1 + 0xd200),param_1);
//    *(undefined8 *)(param_1 + 0xd200) = 0;
//  }
//  if (*(long *)(param_1 + 0xd1f8) != 0) {
//    uVar6 = *(undefined8 *)(*(long *)(param_1 + 0xd1f8) + 0x18);
//    ((void*(*)())(param_1 + 0x18))(uVar6,param_1,uVar6,param_1);
//    _libssh2_list_remove(*(undefined8 *)(param_1 + 0xd1f8));
//    uVar4 = *(uint *)(*(long *)(param_1 + 0xd1f8) + 0x30);
//    uVar6 = 0x113203;
//    _libssh2_htonu32(local_24,(ulong)uVar4,(ulong)uVar4);
//    while ((iVar5 = _libssh2_packet_ask(param_1,0x5e,param_1 + 0xd210,param_1 + 0xd218,1,local_24,4,
//                                        uVar6), -1 < iVar5 ||
//           (iVar5 = _libssh2_packet_ask(param_1,0x5f,param_1 + 0xd210,param_1 + 0xd218,1,local_24,4,
//                                        uVar6), -1 < iVar5))) {
//      uVar6 = 0x113224;
//      ((void*(*)())(param_1 + 0x18))
//                (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210),param_1
//                );
//      *(undefined8 *)(param_1 + 0xd210) = 0;
//    }
//    ((void*(*)())(param_1 + 0x18))
//              (*(undefined8 *)(param_1 + 0xd1f8),param_1,*(undefined8 *)(param_1 + 0xd1f8),param_1);
//    *(undefined8 *)(param_1 + 0xd1f8) = 0;
//  }
//  *(undefined4 *)(param_1 + 0xd1e8) = 0;
//  uVar6 = 0;
//LAB_001132fc:
//  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
//    return uVar6;
//  }
//                    // WARNING: Subroutine does not return
//  __stack_chk_fail();
//}
//
ulong libssh2_keepalive_send(long param_1,int *param_2)

{
  uint uVar1;
  ulong uVar2;
  time_t tVar3;
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined4 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd628) == 0) {
    if (param_2 != (int *)0x0) {
      *param_2 = 0;
    }
    uVar2 = 0;
  }
  else {
    tVar3 = time((time_t *)0x0);
    if (tVar3 < (long)*(int *)(param_1 + 0xd628) + *(long *)(param_1 + 0xd630)) {
      if (param_2 != (int *)0x0) {
        *param_2 = ((int)*(undefined8 *)(param_1 + 0xd630) - (int)tVar3) +
                   *(int *)(param_1 + 0xd628);
      }
    }
    else {
      local_38 = 0x65656b1500000050;
      local_30 = 0x6c406576696c6170;
      local_28 = 0x6f2e326873736269;
      local_20 = 0x576772;
      uVar1 = _libssh2_transport_send(param_1,&local_38,0x1b,0,0);
      if ((uVar1 != 0) && (uVar1 != 0xffffffdb)) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send keepalive message");
        uVar2 = (ulong)uVar1;
        goto LAB_0011944b;
      }
      *(time_t *)(param_1 + 0xd630) = tVar3;
      if (param_2 != (int *)0x0) {
        *param_2 = *(int *)(param_1 + 0xd628);
      }
    }
    uVar2 = 0;
  }
LAB_0011944b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}

ulong libssh2_session_block_directions(long param_1)

{
  return (ulong)*(uint *)(param_1 + 0x230);
}



ulong _libssh2_wait_socket(long param_1,time_t param_2)

{
  ulong uVar1;
  int __timeout;
  long in_FS_OFFSET;
  double dVar2;
  int local_40;
  int local_3c;
  uint local_38;
  uint local_34;
  long local_30;
  time_t local_28;
  long local_20;
  pollfd local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = 0;
  *(undefined4 *)(param_1 + 0x240) = 0;
  local_38 = libssh2_keepalive_send(param_1,&local_40);
  if (local_38 == 0) {
    local_30 = (long)(local_40 * 1000);
    local_34 = libssh2_session_block_directions(param_1);
    if (local_34 == 0) {
      local_30 = 1000;
    }
    if ((*(long *)(param_1 + 0x98) < 1) ||
       ((local_40 != 0 && (local_30 <= *(long *)(param_1 + 0x98))))) {
      if (local_30 < 1) {
        local_3c = 0;
      }
      else {
        local_3c = 1;
      }
    }
    else {
      local_28 = time((time_t *)0x0);
      dVar2 = difftime(local_28,param_2);
      local_20 = (long)(dVar2 * 1000.00000000);
      if (*(long *)(param_1 + 0x98) < local_20) {
        uVar1 = _libssh2_error(param_1,0xfffffff7,"API timeout expired");
        goto LAB_00134cc6;
      }
      local_30 = *(long *)(param_1 + 0x98) - local_20;
      local_3c = 1;
    }
    local_18.fd = *(int *)(param_1 + 0x228);
    local_18.revents = 0;
    local_18.events = (ushort)((local_34 & 1) != 0);
    if ((local_34 & 2) != 0) {
      local_18.events = local_18.events | 4;
    }
    if (local_3c == 0) {
      __timeout = -1;
    }
    else {
      __timeout = (int)local_30;
    }
    local_38 = poll(&local_18,1,__timeout);
    if (local_38 == 0) {
      uVar1 = _libssh2_error(param_1,0xfffffff7,"Timed out waiting on socket");
    }
    else {
      if ((int)local_38 < 0) {
        uVar1 = _libssh2_error(param_1,0xfffffff7,"Error waiting on socket");
      }
      else {
        uVar1 = 0;
      }
    }
  }
  else {
    uVar1 = (ulong)local_38;
  }
LAB_00134cc6:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



long libssh2_channel_open_ex
               (long param_1,undefined8 param_2,uint param_3,uint param_4,uint param_5,
               undefined8 param_6,uint param_7)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  undefined8 uVar4;
  
  if (param_1 == 0) {
    lVar2 = 0;
  }
  else {
    uVar4 = 0x11334f;
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = _libssh2_channel_open
                        (param_1,param_2,(ulong)param_3,(ulong)param_4,(ulong)param_5,param_6,
                         (ulong)param_7);
      if (*(int *)(param_1 + 0x94) == 0) {
        return lVar2;
      }
      if (lVar2 != 0) {
        return lVar2;
      }
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 != -0x25) {
        return 0;
      }
      uVar4 = 0x1133ba;
      iVar1 = _libssh2_wait_socket(param_1,tVar3);
    } while (iVar1 == 0);
  }
  return lVar2;
}



long FUN_001133c9(long param_1,char *param_2,uint param_3,char *param_4,uint param_5)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  long lVar4;
  long in_FS_OFFSET;
  undefined8 local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd224) == 0) {
    sVar2 = strlen(param_2);
    *(size_t *)(param_1 + 0xd230) = sVar2;
    sVar2 = strlen(param_4);
    *(size_t *)(param_1 + 0xd238) = sVar2;
    *(long *)(param_1 + 0xd240) = *(long *)(param_1 + 0xd238) + *(long *)(param_1 + 0xd230) + 0x10;
    uVar3 = ((void*(*)())(param_1 + 8))
                      (*(undefined8 *)(param_1 + 0xd240),param_1,*(undefined8 *)(param_1 + 0xd240),
                       param_1);
    *(undefined8 *)(param_1 + 0xd228) = uVar3;
    local_20 = *(undefined8 *)(param_1 + 0xd228);
    if (*(long *)(param_1 + 0xd228) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for direct-tcpip connection");
      lVar4 = 0;
      goto LAB_001135e3;
    }
    _libssh2_store_str(&local_20,param_2,*(undefined8 *)(param_1 + 0xd230));
    _libssh2_store_u32(&local_20,(ulong)param_3);
    _libssh2_store_str(&local_20,param_4,*(undefined8 *)(param_1 + 0xd238));
    _libssh2_store_u32(&local_20,(ulong)param_5);
  }
  local_18 = _libssh2_channel_open
                       (param_1,"direct-tcpip",0xc,0x200000,0x8000,*(undefined8 *)(param_1 + 0xd228)
                        ,*(undefined8 *)(param_1 + 0xd240));
  if (local_18 == 0) {
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 == -0x25) {
      *(undefined4 *)(param_1 + 0xd224) = 2;
      lVar4 = 0;
      goto LAB_001135e3;
    }
  }
  *(undefined4 *)(param_1 + 0xd224) = 0;
  ((void*(*)())(param_1 + 0x18))
            (*(undefined8 *)(param_1 + 0xd228),param_1,*(undefined8 *)(param_1 + 0xd228),param_1);
  *(undefined8 *)(param_1 + 0xd228) = 0;
  lVar4 = local_18;
LAB_001135e3:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar4;
}



long libssh2_channel_direct_tcpip_ex
               (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = 0;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = FUN_001133c9(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5);
      if (*(int *)(param_1 + 0x94) == 0) {
        return lVar2;
      }
      if (lVar2 != 0) {
        return lVar2;
      }
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(param_1,tVar3);
    } while (iVar1 == 0);
  }
  return lVar2;
}



long FUN_00113699(long param_1,char *param_2,uint param_3,undefined4 *param_4,undefined4 param_5)

{
  undefined *puVar1;
  int iVar2;
  undefined4 uVar3;
  size_t sVar4;
  undefined8 uVar5;
  long lVar6;
  ulong uVar7;
  long in_FS_OFFSET;
  char *local_48;
  undefined *local_30;
  char *local_28;
  ulong local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_48 = param_2;
  if (param_2 == (char *)0x0) {
    local_48 = "0.0.0.0";
  }
  if (*(int *)(param_1 + 0xd248) == 0) {
    sVar4 = strlen(local_48);
    *(undefined4 *)(param_1 + 0xd258) = (int)sVar4;
    *(int *)(param_1 + 0xd25c) = *(int *)(param_1 + 0xd258) + 0x1b;
    memset((void *)(param_1 + 0xd260),0,8);
    uVar5 = ((void*(*)())(param_1 + 8))
                      ((ulong)*(uint *)(param_1 + 0xd25c),param_1,param_1,
                       (ulong)*(uint *)(param_1 + 0xd25c));
    *(undefined8 *)(param_1 + 0xd250) = uVar5;
    puVar1 = *(undefined **)(param_1 + 0xd250);
    if (*(long *)(param_1 + 0xd250) == 0) {
      local_30 = puVar1;
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for setenv packet");
      lVar6 = 0;
      goto LAB_00113be7;
    }
    local_30 = puVar1 + 1;
    *puVar1 = 0x50;
    _libssh2_store_str(&local_30,"tcpip-forward",0xd);
    *local_30 = 1;
    local_30 = local_30 + 1;
    _libssh2_store_str(&local_30,local_48,(ulong)*(uint *)(param_1 + 0xd258));
    _libssh2_store_u32(&local_30,(ulong)param_3);
    *(undefined4 *)(param_1 + 0xd248) = 2;
  }
  if (*(int *)(param_1 + 0xd248) == 2) {
    iVar2 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd250),(ulong)*(uint *)(param_1 + 0xd25c),
                       0,0);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,
                     "Would block sending global-request packet for forward listen request");
      lVar6 = 0;
      goto LAB_00113be7;
    }
    if (iVar2 != 0) {
      _libssh2_error(param_1,0xfffffff9,
                     "Unable to send global-request packet for forward listen request");
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd250),param_1,*(undefined8 *)(param_1 + 0xd250),param_1
                );
      *(undefined8 *)(param_1 + 0xd250) = 0;
      *(undefined4 *)(param_1 + 0xd248) = 0;
      lVar6 = 0;
      goto LAB_00113be7;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd250),param_1,*(undefined8 *)(param_1 + 0xd250),param_1);
    *(undefined8 *)(param_1 + 0xd250) = 0;
    *(undefined4 *)(param_1 + 0xd248) = 3;
  }
  if (*(int *)(param_1 + 0xd248) == 3) {
    iVar2 = _libssh2_packet_requirev
                      (param_1,&DAT_0014667d,&local_28,&local_20,0,0,0,param_1 + 0xd260);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block");
      lVar6 = 0;
      goto LAB_00113be7;
    }
    if ((iVar2 != 0) || (local_20 == 0)) {
      _libssh2_error(param_1,0xfffffff2,"Unknown");
      *(undefined4 *)(param_1 + 0xd248) = 0;
      lVar6 = 0;
      goto LAB_00113be7;
    }
    if (*local_28 == 'Q') {
      local_18 = _libssh2_calloc(param_1,0x60);
      if (local_18 == 0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for listener queue");
      }
      else {
        uVar7 = (ulong)(*(int *)(param_1 + 0xd258) + 1);
        uVar5 = ((void*(*)())(param_1 + 8))(uVar7,param_1,param_1,uVar7);
        *(undefined8 *)(local_18 + 0x20) = uVar5;
        if (*(long *)(local_18 + 0x20) == 0) {
          _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for listener queue");
          ((void*(*)())(param_1 + 0x18))(local_18,param_1,local_18,param_1);
          local_18 = 0;
        }
        else {
          *(long *)(local_18 + 0x18) = param_1;
          memcpy(*(void **)(local_18 + 0x20),local_48,(ulong)*(uint *)(param_1 + 0xd258));
          *(undefined *)((ulong)*(uint *)(param_1 + 0xd258) + *(long *)(local_18 + 0x20)) = 0;
          if ((local_20 < 5) || (param_3 != 0)) {
            *(uint *)(local_18 + 0x28) = param_3;
          }
          else {
            uVar3 = _libssh2_ntohu32(local_28 + 1);
            *(undefined4 *)(local_18 + 0x28) = uVar3;
          }
          *(undefined4 *)(local_18 + 0x40) = 0;
          *(undefined4 *)(local_18 + 0x44) = param_5;
          _libssh2_list_add(param_1 + 0x218,local_18);
          if (param_4 != (undefined4 *)0x0) {
            *param_4 = *(undefined4 *)(local_18 + 0x28);
          }
        }
      }
      ((void*(*)())(param_1 + 0x18))(local_28,param_1,local_28,param_1);
      *(undefined4 *)(param_1 + 0xd248) = 0;
      lVar6 = local_18;
      goto LAB_00113be7;
    }
    if (*local_28 == 'R') {
      ((void*(*)())(param_1 + 0x18))(local_28,param_1,local_28,param_1);
      _libssh2_error(param_1,0xffffffe0,"Unable to complete request for forward-listen");
      *(undefined4 *)(param_1 + 0xd248) = 0;
      lVar6 = 0;
      goto LAB_00113be7;
    }
  }
  *(undefined4 *)(param_1 + 0xd248) = 0;
  lVar6 = 0;
LAB_00113be7:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar6;
}



long libssh2_channel_forward_listen_ex
               (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = 0;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = FUN_00113699(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5);
      if (*(int *)(param_1 + 0x94) == 0) {
        return lVar2;
      }
      if (lVar2 != 0) {
        return lVar2;
      }
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(param_1,tVar3);
    } while (iVar1 == 0);
  }
  return lVar2;
}



//ulong _libssh2_channel_forward_cancel(long param_1)
//
//{
//  int iVar1;
//  ulong uVar2;
//  long in_FS_OFFSET;
//  uint local_50;
//  undefined *local_48;
//  long local_40;
//  undefined *local_38;
//  long local_30;
//  size_t local_28;
//  long local_20;
//  long local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_30 = *(long *)(param_1 + 0x18);
//  local_28 = strlen(*(char **)(param_1 + 0x20));
//  local_20 = local_28 + 0x22;
//  local_50 = 0;
//  if (*(int *)(param_1 + 0x48) == 0) {
//    local_38 = (undefined *)((void*(*)())(local_30 + 8))(local_20,local_30,local_20,local_30);
//    if (local_38 == (undefined *)0x0) {
//      local_48 = local_38;
//      _libssh2_error(local_30,0xfffffffa,"Unable to allocate memory for setenv packet");
//      uVar2 = 0xfffffffa;
//      goto LAB_00113f11;
//    }
//    local_48 = local_38 + 1;
//    *local_38 = 0x50;
//    _libssh2_store_str(&local_48,"cancel-tcpip-forward",0x14);
//    *local_48 = 0;
//    local_48 = local_48 + 1;
//    _libssh2_store_str(&local_48,*(undefined8 *)(param_1 + 0x20),local_28,
//                       *(undefined8 *)(param_1 + 0x20));
//    _libssh2_store_u32(&local_48,(ulong)*(uint *)(param_1 + 0x28),(ulong)*(uint *)(param_1 + 0x28));
//    *(undefined4 *)(param_1 + 0x48) = 2;
//  }
//  else {
//    local_38 = *(undefined **)(param_1 + 0x50);
//  }
//  if (*(int *)(param_1 + 0x48) == 2) {
//    iVar1 = _libssh2_transport_send(local_30,local_38,local_20,0,0);
//    if (iVar1 == -0x25) {
//      _libssh2_error(local_30,0xffffffdb,"Would block sending forward request",0xffffffdb);
//      *(undefined **)(param_1 + 0x50) = local_38;
//      uVar2 = 0xffffffdb;
//      goto LAB_00113f11;
//    }
//    if (iVar1 != 0) {
//      _libssh2_error(local_30,0xfffffff9,
//                     "Unable to send global-request packet for forward listen request");
//      *(undefined4 *)(param_1 + 0x48) = 3;
//      local_50 = 0xfffffff9;
//    }
//    ((void*(*)())(local_30 + 0x18))(local_38,local_30,local_38,local_30);
//    *(undefined4 *)(param_1 + 0x48) = 3;
//  }
//  local_40 = _libssh2_list_first(param_1 + 0x30);
//  while (local_40 != 0) {
//    local_18 = _libssh2_list_next(local_40);
//    iVar1 = _libssh2_channel_free(local_40);
//    if (iVar1 == -0x25) {
//      uVar2 = 0xffffffdb;
//      goto LAB_00113f11;
//    }
//    local_40 = local_18;
//  }
//  ((void*(*)())(local_30 + 0x18))
//            (*(undefined8 *)(param_1 + 0x20),local_30,*(undefined8 *)(param_1 + 0x20),local_30);
//  _libssh2_list_remove(param_1);
//  ((void*(*)())(local_30 + 0x18))(param_1,local_30,param_1,local_30);
//  uVar2 = (ulong)local_50;
//LAB_00113f11:
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar2;
//}
//


ulong libssh2_channel_forward_cancel(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = _libssh2_channel_forward_cancel(param_1);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x18) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x18),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



long FUN_00113f9b(long param_1)

{
  int iVar1;
  long lVar2;
  long lVar3;
  
  do {
    iVar1 = _libssh2_transport_read(*(undefined8 *)(param_1 + 0x18));
  } while (0 < iVar1);
  lVar2 = _libssh2_list_first(param_1 + 0x30);
  if (lVar2 == 0) {
    if (iVar1 == -0x25) {
      _libssh2_error(*(undefined8 *)(param_1 + 0x18),0xffffffdb,"Would block waiting for packet");
    }
    else {
      _libssh2_error(*(undefined8 *)(param_1 + 0x18),0xffffffe9,"Channel not found");
    }
    lVar2 = 0;
  }
  else {
    lVar2 = _libssh2_list_first(param_1 + 0x30);
    _libssh2_list_remove(lVar2);
    *(int *)(param_1 + 0x40) = *(int *)(param_1 + 0x40) + -1;
    lVar3 = *(long *)(lVar2 + 0x60) + 0x200;
    _libssh2_list_add(lVar3,lVar2);
  }
  return lVar2;
}



long libssh2_channel_forward_accept(long param_1)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = 0;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = FUN_00113f9b(param_1);
      if (*(int *)(*(long *)(param_1 + 0x18) + 0x94) == 0) {
        return lVar2;
      }
      if (lVar2 != 0) {
        return lVar2;
      }
      iVar1 = libssh2_session_last_errno(*(undefined8 *)(param_1 + 0x18));
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x18),tVar3);
    } while (iVar1 == 0);
  }
  return lVar2;
}



ulong FUN_001140fd(long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  undefined *local_30;
  char *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x78) == 0) {
    *(ulong *)(param_1 + 0x88) = (ulong)(param_5 + param_3 + 0x15);
    memset((void *)(param_1 + 0x98),0,8);
    uVar4 = ((void*(*)())(local_18 + 8))
                      (*(undefined8 *)(param_1 + 0x88),local_18,*(undefined8 *)(param_1 + 0x88),
                       local_18);
    *(undefined8 *)(param_1 + 0x80) = uVar4;
    puVar1 = *(undefined **)(param_1 + 0x80);
    if (*(long *)(param_1 + 0x80) == 0) {
      local_30 = puVar1;
      uVar5 = _libssh2_error(local_18,0xfffffffa,"Unable to allocate memory for setenv packet");
      goto LAB_00114491;
    }
    local_30 = puVar1 + 1;
    *puVar1 = 0x62;
    _libssh2_store_u32(&local_30,(ulong)*(uint *)(param_1 + 0x44));
    _libssh2_store_str(&local_30,&DAT_00145ec9,3);
    *local_30 = 1;
    local_30 = local_30 + 1;
    _libssh2_store_str(&local_30,param_2,(ulong)param_3);
    _libssh2_store_str(&local_30,param_4,(ulong)param_5);
    *(undefined4 *)(param_1 + 0x78) = 2;
  }
  if (*(int *)(param_1 + 0x78) == 2) {
    iVar2 = _libssh2_transport_send
                      (local_18,*(undefined8 *)(param_1 + 0x80),*(undefined8 *)(param_1 + 0x88),0,0)
    ;
    if (iVar2 == -0x25) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending setenv request",0xffffffdb);
      uVar5 = 0xffffffdb;
      goto LAB_00114491;
    }
    if (iVar2 != 0) {
      ((void*(*)())(local_18 + 0x18))
                (*(undefined8 *)(param_1 + 0x80),local_18,*(undefined8 *)(param_1 + 0x80),local_18);
      *(undefined8 *)(param_1 + 0x80) = 0;
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = _libssh2_error(local_18,0xfffffff9,
                             "Unable to send channel-request packet for setenv request");
      goto LAB_00114491;
    }
    ((void*(*)())(local_18 + 0x18))
              (*(undefined8 *)(param_1 + 0x80),local_18,*(undefined8 *)(param_1 + 0x80),local_18);
    *(undefined8 *)(param_1 + 0x80) = 0;
    _libssh2_htonu32(param_1 + 0x90,(ulong)*(uint *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x78) = 3;
  }
  if (*(int *)(param_1 + 0x78) == 3) {
    uVar3 = _libssh2_packet_requirev
                      (local_18,&DAT_00146680,&local_28,&local_20,1,param_1 + 0x90,4,param_1 + 0x98)
    ;
    if (uVar3 == 0xffffffdb) {
      uVar5 = 0xffffffdb;
      goto LAB_00114491;
    }
    if (uVar3 != 0) {
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = (ulong)uVar3;
      goto LAB_00114491;
    }
    if (local_20 == 0) {
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = _libssh2_error(local_18,0xfffffff2,"Unexpected packet size");
      goto LAB_00114491;
    }
    if (*local_28 == 'c') {
      ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = 0;
      goto LAB_00114491;
    }
    ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
  }
  *(undefined4 *)(param_1 + 0x78) = 0;
  uVar5 = _libssh2_error(local_18,0xffffffea,"Unable to complete request for channel-setenv");
LAB_00114491:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong libssh2_channel_setenv_ex
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_001140fd(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8
FUN_0011453b(long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
            uint param_6,uint param_7,uint param_8,uint param_9)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *local_30;
  char *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0xa0) == 0) {
    if (0x100 < param_5 + param_3) {
      uVar4 = _libssh2_error(local_18,0xffffffde,"term + mode lengths too large");
      goto LAB_00114873;
    }
    *(ulong *)(param_1 + 0x1d0) = (ulong)(param_5 + param_3 + 0x29);
    memset((void *)(param_1 + 0x1e0),0,8);
    local_30 = (undefined *)(param_1 + 0xa5);
    *(undefined *)(param_1 + 0xa4) = 0x62;
    _libssh2_store_u32(&local_30,(ulong)*(uint *)(param_1 + 0x44));
    _libssh2_store_str(&local_30,"pty-req",7);
    *local_30 = 1;
    local_30 = local_30 + 1;
    _libssh2_store_str(&local_30,param_2,(ulong)param_3);
    _libssh2_store_u32(&local_30,(ulong)param_6);
    _libssh2_store_u32(&local_30,(ulong)param_7);
    _libssh2_store_u32(&local_30,(ulong)param_8);
    _libssh2_store_u32(&local_30,(ulong)param_9);
    _libssh2_store_str(&local_30,param_4,(ulong)param_5);
    *(undefined4 *)(param_1 + 0xa0) = 2;
  }
  if (*(int *)(param_1 + 0xa0) == 2) {
    uVar2 = _libssh2_transport_send(local_18,param_1 + 0xa4,*(undefined8 *)(param_1 + 0x1d0),0,0);
    if (uVar2 == 0xffffffdb) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending pty request",0xffffffdb);
      uVar4 = 0xffffffdb;
      goto LAB_00114873;
    }
    if (uVar2 != 0) {
      *(undefined4 *)(param_1 + 0xa0) = 0;
      uVar4 = _libssh2_error(local_18,(ulong)uVar2,"Unable to send pty-request packet",(ulong)uVar2)
      ;
      goto LAB_00114873;
    }
    _libssh2_htonu32(param_1 + 0x1d8,(ulong)*(uint *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0xa0) = 3;
  }
  if (*(int *)(param_1 + 0xa0) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (local_18,&DAT_00146683,&local_28,&local_20,1,param_1 + 0x1d8,4,
                       param_1 + 0x1e0);
    if (iVar3 == -0x25) {
      uVar4 = 0xffffffdb;
      goto LAB_00114873;
    }
    if ((iVar3 != 0) || (local_20 == 0)) {
      *(undefined4 *)(param_1 + 0xa0) = 0;
      uVar4 = _libssh2_error(local_18,0xfffffff2,"Failed to require the PTY package");
      goto LAB_00114873;
    }
    cVar1 = *local_28;
    ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
    *(undefined4 *)(param_1 + 0xa0) = 0;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_00114873;
    }
  }
  uVar4 = _libssh2_error(local_18,0xffffffea,"Unable to complete request for channel request-pty");
LAB_00114873:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



undefined8 FUN_00114889(long param_1,undefined8 param_2,int param_3)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *local_30;
  char *local_28;
  undefined local_20 [8];
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x2b0) == 0) {
    if (0x1a < param_3) {
      uVar4 = _libssh2_error(local_18,0xffffffde,"request_str length too large");
      goto LAB_00114b2a;
    }
    *(long *)(param_1 + 0x2d8) = (long)(param_3 + 10);
    memset((void *)(param_1 + 0x2e8),0,8);
    local_30 = (undefined *)(param_1 + 0x2b5);
    *(undefined *)(param_1 + 0x2b4) = 0x62;
    _libssh2_store_u32(&local_30,(ulong)*(uint *)(param_1 + 0x44));
    _libssh2_store_str(&local_30,param_2,(long)param_3);
    *local_30 = 1;
    *(undefined4 *)(param_1 + 0x2b0) = 2;
    local_30 = local_30 + 1;
  }
  if (*(int *)(param_1 + 0x2b0) == 2) {
    uVar2 = _libssh2_transport_send(local_18,param_1 + 0x2b4,*(undefined8 *)(param_1 + 0x2d8),0,0);
    if (uVar2 == 0xffffffdb) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending auth-agent request",0xffffffdb);
    }
    else {
      if (uVar2 != 0) {
        *(undefined4 *)(param_1 + 0x2b0) = 0;
        uVar4 = _libssh2_error(local_18,(ulong)uVar2,"Unable to send auth-agent request",
                               (ulong)uVar2);
        goto LAB_00114b2a;
      }
    }
    _libssh2_htonu32(param_1 + 0x2e0,(ulong)*(uint *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x2b0) = 3;
  }
  if (*(int *)(param_1 + 0x2b0) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (local_18,&DAT_00146686,&local_28,local_20,1,param_1 + 0x2e0,4,param_1 + 0x2e8
                      );
    if (iVar3 == -0x25) {
      uVar4 = 0xffffffdb;
      goto LAB_00114b2a;
    }
    if (iVar3 != 0) {
      *(undefined4 *)(param_1 + 0x2b0) = 0;
      uVar4 = _libssh2_error(local_18,0xfffffff2,"Failed to request auth-agent");
      goto LAB_00114b2a;
    }
    cVar1 = *local_28;
    ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
    *(undefined4 *)(param_1 + 0x2b0) = 0;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_00114b2a;
    }
  }
  uVar4 = _libssh2_error(local_18,0xffffffea,"Unable to complete request for auth-agent");
LAB_00114b2a:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong libssh2_channel_request_auth_agent(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_1c;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    if (*(int *)(param_1 + 0x2ac) == 0) {
      tVar2 = time((time_t *)0x0);
      do {
        local_1c = FUN_00114889(param_1,"auth-agent-req@openssh.com",0x1a);
        if ((local_1c != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
        local_1c = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
      } while (local_1c == 0);
      if ((local_1c != 0) && (local_1c != 0xffffffdb)) {
        *(undefined4 *)(param_1 + 0x2ac) = 3;
      }
    }
    if (*(int *)(param_1 + 0x2ac) == 3) {
      tVar2 = time((time_t *)0x0);
      do {
        local_1c = FUN_00114889(param_1,"auth-agent-req",0xe);
        if ((local_1c != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
        local_1c = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
      } while (local_1c == 0);
      if ((local_1c != 0) && (local_1c != 0xffffffdb)) {
        *(undefined4 *)(param_1 + 0x2ac) = 4;
      }
    }
    if (local_1c == 0) {
      *(undefined4 *)(param_1 + 0x2ac) = 0;
    }
    uVar1 = (ulong)local_1c;
  }
  return uVar1;
}



ulong libssh2_channel_request_pty_ex
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
                uint param_6,uint param_7,uint param_8,uint param_9)

{
  ulong uVar1;
  time_t tVar2;
  undefined8 uVar3;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    uVar3 = 0x114cc0;
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0011453b(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5,(ulong)param_6,
                              (ulong)param_7,(ulong)param_8,(ulong)param_9);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      uVar3 = 0x114d29;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_00114d37(long param_1,uint param_2,uint param_3,uint param_4,uint param_5)

{
  uint uVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_28;
  undefined *local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(undefined8 *)(param_1 + 0x60);
  local_28 = 0xfffffff2;
  if (*(int *)(param_1 + 0xa0) == 0) {
    *(undefined8 *)(param_1 + 0x1d0) = 0x27;
    memset((void *)(param_1 + 0x1e0),0,8);
    local_20 = (undefined *)(param_1 + 0xa5);
    *(undefined *)(param_1 + 0xa4) = 0x62;
    _libssh2_store_u32(&local_20,(ulong)*(uint *)(param_1 + 0x44));
    _libssh2_store_str(&local_20,"window-change",0xd);
    *local_20 = 0;
    local_20 = local_20 + 1;
    _libssh2_store_u32(&local_20,(ulong)param_2);
    _libssh2_store_u32(&local_20,(ulong)param_3);
    _libssh2_store_u32(&local_20,(ulong)param_4);
    _libssh2_store_u32(&local_20,(ulong)param_5);
    *(undefined4 *)(param_1 + 0xa0) = 2;
  }
  if (*(int *)(param_1 + 0xa0) == 2) {
    uVar1 = _libssh2_transport_send(local_18,param_1 + 0xa4,*(undefined8 *)(param_1 + 0x1d0),0,0);
    if (uVar1 == 0xffffffdb) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending window-change request",0xffffffdb);
      uVar2 = 0xffffffdb;
      goto LAB_00114f22;
    }
    if (uVar1 != 0) {
      *(undefined4 *)(param_1 + 0xa0) = 0;
      uVar2 = _libssh2_error(local_18,(ulong)uVar1,"Unable to send window-change packet",
                             (ulong)uVar1);
      goto LAB_00114f22;
    }
    _libssh2_htonu32(param_1 + 0x1d8,(ulong)*(uint *)(param_1 + 0x30));
    local_28 = 0;
  }
  *(undefined4 *)(param_1 + 0xa0) = 0;
  uVar2 = (ulong)local_28;
LAB_00114f22:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong libssh2_channel_request_pty_size_ex
                (long param_1,uint param_2,uint param_3,uint param_4,uint param_5)

{
  ulong uVar1;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    time((time_t *)0x0);
    do {
      local_14 = FUN_00114d37(param_1,(ulong)param_2,(ulong)param_3,(ulong)param_4,(ulong)param_5);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;

    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8 FUN_00114fc8(long param_1,int param_2,char *param_3,char *param_4,uint param_5)

{
  char cVar1;
  undefined *puVar2;
  uint uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  int local_60;
  undefined *local_58;
  long local_50;
  char *local_48;
  long local_40;
  size_t local_38;
  size_t local_30;
  byte local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = *(long *)(param_1 + 0x60);
  if (param_3 == (char *)0x0) {
    local_38 = 0x12;
  }
  else {
    local_38 = strlen(param_3);
  }
  if (param_4 == (char *)0x0) {
    local_30 = 0x20;
  }
  else {
    local_30 = strlen(param_4);
  }
  if (*(int *)(param_1 + 0x1e8) == 0) {
    *(long *)(param_1 + 0x1f8) = local_30 + local_38 + 0x1e;
    memset((void *)(param_1 + 0x208),0,8);
    uVar4 = ((void*(*)())(local_40 + 8))
                      (*(undefined8 *)(param_1 + 0x1f8),local_40,*(undefined8 *)(param_1 + 0x1f8));
    *(undefined8 *)(param_1 + 0x1f0) = uVar4;
    puVar2 = *(undefined **)(param_1 + 0x1f0);
    if (*(long *)(param_1 + 0x1f0) == 0) {
      local_58 = puVar2;
      uVar4 = _libssh2_error(local_40,0xfffffffa,"Unable to allocate memory for pty-request");
      goto LAB_00115440;
    }
    local_58 = puVar2 + 1;
    *puVar2 = 0x62;
    _libssh2_store_u32(&local_58,(ulong)*(uint *)(param_1 + 0x44));
    _libssh2_store_str(&local_58,"x11-req",7);
    puVar2 = local_58 + 1;
    *local_58 = 1;
    local_58 = local_58 + 2;
    *(bool *)puVar2 = param_2 != 0;
    if (param_3 == (char *)0x0) {
      param_3 = "MIT-MAGIC-COOKIE-1";
    }
    _libssh2_store_str(&local_58,param_3,local_38);
    _libssh2_store_u32(&local_58,local_30 & 0xffffffff);
    if (param_4 == (char *)0x0) {
      RAND_bytes(local_28,0x10);
      local_60 = 0;
      while (local_60 < 0x10) {
        snprintf(local_58 + local_60 * 2,3,"%02X",(ulong)local_28[local_60]);
        local_60 = local_60 + 1;
      }
    }
    else {
      memcpy(local_58,param_4,local_30);
    }
    local_58 = local_58 + local_30;
    _libssh2_store_u32(&local_58,(ulong)param_5);
    *(undefined4 *)(param_1 + 0x1e8) = 2;
  }
  if (*(int *)(param_1 + 0x1e8) == 2) {
    uVar3 = _libssh2_transport_send
                      (local_40,*(undefined8 *)(param_1 + 0x1f0),*(undefined8 *)(param_1 + 0x1f8),0,
                       0);
    if (uVar3 == 0xffffffdb) {
      _libssh2_error(local_40,0xffffffdb,"Would block sending X11-req packet",0xffffffdb);
      uVar4 = 0xffffffdb;
      goto LAB_00115440;
    }
    if (uVar3 != 0) {
      ((void*(*)())(local_40 + 0x18))
                (*(undefined8 *)(param_1 + 0x1f0),local_40,*(undefined8 *)(param_1 + 0x1f0),local_40
                );
      *(undefined8 *)(param_1 + 0x1f0) = 0;
      *(undefined4 *)(param_1 + 0x1e8) = 0;
      uVar4 = _libssh2_error(local_40,(ulong)uVar3,"Unable to send x11-req packet",(ulong)uVar3);
      goto LAB_00115440;
    }
    ((void*(*)())(local_40 + 0x18))
              (*(undefined8 *)(param_1 + 0x1f0),local_40,*(undefined8 *)(param_1 + 0x1f0),local_40);
    *(undefined8 *)(param_1 + 0x1f0) = 0;
    _libssh2_htonu32(param_1 + 0x200,(ulong)*(uint *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x1e8) = 3;
  }
  if (*(int *)(param_1 + 0x1e8) == 3) {
    uVar3 = _libssh2_packet_requirev
                      (local_40,&DAT_00146689,&local_48,&local_50,1,param_1 + 0x200,4,
                       param_1 + 0x208);
    if (uVar3 == 0xffffffdb) {
      uVar4 = 0xffffffdb;
      goto LAB_00115440;
    }
    if ((uVar3 != 0) || (local_50 == 0)) {
      *(undefined4 *)(param_1 + 0x1e8) = 0;
      uVar4 = _libssh2_error(local_40,(ulong)uVar3,"waiting for x11-req response packet",
                             (ulong)uVar3);
      goto LAB_00115440;
    }
    cVar1 = *local_48;
    ((void*(*)())(local_40 + 0x18))(local_48,local_40,local_48,local_40);
    *(undefined4 *)(param_1 + 0x1e8) = 0;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_00115440;
    }
  }
  uVar4 = _libssh2_error(local_40,0xffffffea,"Unable to complete request for channel x11-req");
LAB_00115440:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_channel_x11_req_ex
                (long param_1,uint param_2,undefined8 param_3,undefined8 param_4,uint param_5)

{
  ulong uVar1;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    time((time_t *)0x0);
    do {
      local_14 = FUN_00114fc8(param_1,(ulong)param_2,param_3,param_4,(ulong)param_5);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;

    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



//undefined8
//_libssh2_channel_process_startup
//          (long param_1,undefined8 param_2,long param_3,long param_4,ulong param_5)
//
//{
//  char cVar1;
//  undefined *puVar2;
//  uint uVar3;
//  undefined8 uVar4;
//  long in_FS_OFFSET;
//  undefined *local_30;
//  char *local_28;
//  long local_20;
//  long local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_18 = *(long *)(param_1 + 0x60);
//  if (*(int *)(param_1 + 0x210) == 0x10) {
//    uVar4 = _libssh2_error(local_18,0xffffffd9,"Channel can not be reused");
//    goto LAB_0011589c;
//  }
//  if (*(int *)(param_1 + 0x210) == 0) {
//    *(long *)(param_1 + 0x220) = param_3 + 10;
//    memset((void *)(param_1 + 0x230),0,8);
//    if (param_4 != 0) {
//      *(long *)(param_1 + 0x220) = *(long *)(param_1 + 0x220) + 4;
//    }
//    uVar4 = ((void*(*)())(local_18 + 8))
//                      (*(undefined8 *)(param_1 + 0x220),local_18,*(undefined8 *)(param_1 + 0x220),
//                       local_18);
//    *(undefined8 *)(param_1 + 0x218) = uVar4;
//    puVar2 = *(undefined **)(param_1 + 0x218);
//    if (*(long *)(param_1 + 0x218) == 0) {
//      local_30 = puVar2;
//      uVar4 = _libssh2_error(local_18,0xfffffffa,
//                             "Unable to allocate memory for channel-process request");
//      goto LAB_0011589c;
//    }
//    local_30 = puVar2 + 1;
//    *puVar2 = 0x62;
//    _libssh2_store_u32(&local_30,(ulong)*(uint *)(param_1 + 0x44),(ulong)*(uint *)(param_1 + 0x44));
//    _libssh2_store_str(&local_30,param_2,param_3,param_2);
//    puVar2 = local_30 + 1;
//    *local_30 = 1;
//    local_30 = puVar2;
//    if (param_4 != 0) {
//      _libssh2_store_u32(&local_30,param_5 & 0xffffffff,param_5 & 0xffffffff);
//    }
//    *(undefined4 *)(param_1 + 0x210) = 2;
//  }
//  if (*(int *)(param_1 + 0x210) == 2) {
//    uVar3 = _libssh2_transport_send
//                      (local_18,*(undefined8 *)(param_1 + 0x218),*(undefined8 *)(param_1 + 0x220),
//                       param_4,param_5);
//    if (uVar3 == 0xffffffdb) {
//      _libssh2_error(local_18,0xffffffdb,"Would block sending channel request",0xffffffdb);
//      uVar4 = 0xffffffdb;
//      goto LAB_0011589c;
//    }
//    if (uVar3 != 0) {
//      ((void*(*)())(local_18 + 0x18))
//                (*(undefined8 *)(param_1 + 0x218),local_18,*(undefined8 *)(param_1 + 0x218),local_18
//                );
//      *(undefined8 *)(param_1 + 0x218) = 0;
//      *(undefined4 *)(param_1 + 0x210) = 0x10;
//      uVar4 = _libssh2_error(local_18,(ulong)uVar3,"Unable to send channel request",(ulong)uVar3);
//      goto LAB_0011589c;
//    }
//    ((void*(*)())(local_18 + 0x18))
//              (*(undefined8 *)(param_1 + 0x218),local_18,*(undefined8 *)(param_1 + 0x218),local_18);
//    *(undefined8 *)(param_1 + 0x218) = 0;
//    _libssh2_htonu32(param_1 + 0x228,(ulong)*(uint *)(param_1 + 0x30),param_1 + 0x228);
//    *(undefined4 *)(param_1 + 0x210) = 3;
//  }
//  if (*(int *)(param_1 + 0x210) == 3) {
//    uVar3 = _libssh2_packet_requirev
//                      (local_18,&DAT_0014668c,&local_28,&local_20,1,param_1 + 0x228,4,
//                       param_1 + 0x230);
//    if (uVar3 == 0xffffffdb) {
//      uVar4 = 0xffffffdb;
//      goto LAB_0011589c;
//    }
//    if ((uVar3 != 0) || (local_20 == 0)) {
//      *(undefined4 *)(param_1 + 0x210) = 0x10;
//      uVar4 = _libssh2_error(local_18,(ulong)uVar3,"Failed waiting for channel success",(ulong)uVar3
//                            );
//      goto LAB_0011589c;
//    }
//    cVar1 = *local_28;
//    ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
//    *(undefined4 *)(param_1 + 0x210) = 0x10;
//    if (cVar1 == 'c') {
//      uVar4 = 0;
//      goto LAB_0011589c;
//    }
//  }
//  uVar4 = _libssh2_error(local_18,0xffffffea,
//                         "Unable to complete request for channel-process-startup");
//LAB_0011589c:
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar4;
//}
//


ulong libssh2_channel_process_startup
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = _libssh2_channel_process_startup
                           (param_1,param_2,(ulong)param_3,param_4,(ulong)param_5);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}

ulong _libssh2_session_set_blocking(long param_1,undefined4 param_2)

{
  uint uVar1;
  
  uVar1 = *(uint *)(param_1 + 0x94);
  *(undefined4 *)(param_1 + 0x94) = param_2;
  return (ulong)uVar1;
}


void libssh2_channel_set_blocking(long param_1,uint param_2)

{
  if (param_1 != 0) {
    _libssh2_session_set_blocking(*(undefined8 *)(param_1 + 0x60),(ulong)param_2);
  }
  return;
}



//undefined8 _libssh2_channel_flush(long param_1,int param_2)
//
//{
//  char cVar1;
//  long lVar2;
//  long lVar3;
//  int iVar4;
//  long lVar5;
//  undefined8 uVar6;
//  int local_28;
//  long local_20;
//  
//  if (*(int *)(param_1 + 0x238) == 0) {
//    lVar5 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
//    *(undefined8 *)(param_1 + 0x240) = 0;
//    *(undefined8 *)(param_1 + 0x248) = 0;
//    while (local_20 = lVar5, local_20 != 0) {
//      lVar5 = _libssh2_list_next(local_20);
//      if ((*(long *)(local_20 + 0x20) != 0) &&
//         ((((cVar1 = **(char **)(local_20 + 0x18), cVar1 == '^' || (cVar1 == '_')) &&
//           (4 < *(ulong *)(local_20 + 0x20))) &&
//          (iVar4 = _libssh2_ntohu32(*(long *)(local_20 + 0x18) + 1),
//          iVar4 == *(int *)(param_1 + 0x30))))) {
//        if (cVar1 == '^') {
//          local_28 = 0;
//        }
//        else {
//          if (*(ulong *)(local_20 + 0x20) < 9) {
//            *(undefined4 *)(param_1 + 0x238) = 0;
//            uVar6 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xfffffff2,
//                                   "Unexpected packet length");
//            return uVar6;
//          }
//          local_28 = _libssh2_ntohu32(*(long *)(local_20 + 0x18) + 5);
//        }
//        if (((param_2 == -2) || ((cVar1 == '_' && ((param_2 == -1 || (param_2 == local_28)))))) ||
//           ((cVar1 == '^' && (param_2 == 0)))) {
//          lVar2 = *(long *)(local_20 + 0x20);
//          lVar3 = *(long *)(local_20 + 0x28);
//          *(long *)(param_1 + 0x240) =
//               *(long *)(local_20 + 0x20) + *(long *)(param_1 + 0x240) + -0xd;
//          *(long *)(param_1 + 0x248) = *(long *)(param_1 + 0x248) + (lVar2 - lVar3);
//          ((void*(*)())(*(long *)(param_1 + 0x60) + 0x18))
//                    (*(undefined8 *)(local_20 + 0x18),*(undefined8 *)(param_1 + 0x60),
//                     *(undefined8 *)(local_20 + 0x18),*(undefined8 *)(param_1 + 0x60));
//          _libssh2_list_remove(local_20);
//          ((void*(*)())(*(long *)(param_1 + 0x60) + 0x18))
//                    (local_20,*(undefined8 *)(param_1 + 0x60),local_20,
//                     *(undefined8 *)(param_1 + 0x60));
//        }
//      }
//    }
//    *(undefined4 *)(param_1 + 0x238) = 2;
//  }
//  *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - (int)*(undefined8 *)(param_1 + 0x248);
//  *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - (int)*(undefined8 *)(param_1 + 0x248);
//  if ((*(long *)(param_1 + 0x240) == 0) ||
//     (iVar4 = _libssh2_channel_receive_window_adjust
//                        (param_1,*(ulong *)(param_1 + 0x240) & 0xffffffff,1,0), iVar4 != -0x25)) {
//    *(undefined4 *)(param_1 + 0x238) = 0;
//    uVar6 = *(undefined8 *)(param_1 + 0x248);
//  }
//  else {
//    uVar6 = 0xffffffdb;
//  }
//  return uVar6;
//}
//
//
//
//ulong libssh2_channel_flush_ex(long param_1,uint param_2)
//
//{
//  ulong uVar1;
//  uint local_14;
//  
//  if (param_1 == 0) {
//    uVar1 = 0xffffffd9;
//  }
//  else {
//    time((time_t *)0x0);
//    do {
//      local_14 = _libssh2_channel_flush(param_1,(ulong)param_2);
//      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
//      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60));
//    } while (local_14 == 0);
//    uVar1 = (ulong)local_14;
//  }
//  return uVar1;
//}



ulong libssh2_channel_get_exit_status(long param_1)

{
  ulong uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (ulong)*(uint *)(param_1 + 0x24);
  }
  return uVar1;
}



undefined8
libssh2_channel_get_exit_signal
          (long param_1,void **param_2,size_t *param_3,undefined8 *param_4,undefined8 *param_5,
          undefined8 *param_6,undefined8 *param_7)

{
  long lVar1;
  size_t __n;
  void *pvVar2;
  undefined8 uVar3;
  
  if (param_1 != 0) {
    lVar1 = *(long *)(param_1 + 0x60);
    if (*(long *)(param_1 + 0x28) == 0) {
      if (param_2 != (void **)0x0) {
        *param_2 = (void *)0x0;
      }
      if (param_3 != (size_t *)0x0) {
        *param_3 = 0;
      }
    }
    else {
      __n = strlen(*(char **)(param_1 + 0x28));
      if (param_2 != (void **)0x0) {
        pvVar2 = (void *)((void*(*)())(lVar1 + 8))(__n + 1,lVar1,lVar1,__n + 1);
        *param_2 = pvVar2;
        if (*param_2 == (void *)0x0) {
          uVar3 = _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for signal name");
          return uVar3;
        }
        memcpy(*param_2,*(void **)(param_1 + 0x28),__n);
        *(undefined *)(__n + (long)*param_2) = 0;
      }
      if (param_3 != (size_t *)0x0) {
        *param_3 = __n;
      }
    }
    if (param_4 != (undefined8 *)0x0) {
      *param_4 = 0;
    }
    if (param_5 != (undefined8 *)0x0) {
      *param_5 = 0;
    }
    if (param_6 != (undefined8 *)0x0) {
      *param_6 = 0;
    }
    if (param_7 != (undefined8 *)0x0) {
      *param_7 = 0;
    }
  }
  return 0;
}



//undefined8
//_libssh2_channel_receive_window_adjust(long param_1,uint param_2,char param_3,undefined4 *param_4)
//
//{
//  int iVar1;
//  undefined8 uVar2;
//  uint local_24;
//  
//  if (param_4 != (undefined4 *)0x0) {
//    *param_4 = *(undefined4 *)(param_1 + 0x4c);
//  }
//  local_24 = param_2;
//  if (*(int *)(param_1 + 0x250) == 0) {
//    if ((param_3 == '\0') && (param_2 + *(int *)(param_1 + 0x58) < 0x400)) {
//      *(int *)(param_1 + 0x58) = *(int *)(param_1 + 0x58) + param_2;
//      return 0;
//    }
//    if ((param_2 == 0) && (*(int *)(param_1 + 0x58) == 0)) {
//      return 0;
//    }
//    local_24 = param_2 + *(int *)(param_1 + 0x58);
//    *(undefined4 *)(param_1 + 0x58) = 0;
//    *(undefined *)(param_1 + 0x254) = 0x5d;
//    _libssh2_htonu32(param_1 + 0x255,(ulong)*(uint *)(param_1 + 0x44),param_1 + 0x255);
//    _libssh2_htonu32(param_1 + 0x259,(ulong)local_24,param_1 + 0x259);
//    *(undefined4 *)(param_1 + 0x250) = 2;
//  }
//  iVar1 = _libssh2_transport_send(*(undefined8 *)(param_1 + 0x60),param_1 + 0x254,9,0,0);
//  if (iVar1 == -0x25) {
//    _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffdb,"Would block sending window adjust",
//                   0xffffffdb);
//    uVar2 = 0xffffffdb;
//  }
//  else {
//    if (iVar1 == 0) {
//      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) + local_24;
//      *(undefined4 *)(param_1 + 0x250) = 0;
//      uVar2 = 0;
//    }
//    else {
//      *(uint *)(param_1 + 0x58) = local_24;
//      uVar2 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xfffffff9,
//                             "Unable to send transfer-window adjustment packet, deferring");
//    }
//  }
//  return uVar2;
//}
//


ulong libssh2_channel_receive_window_adjust(long param_1,ulong param_2,byte param_3)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint local_20;
  int local_1c;
  time_t local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 == 0) {
    uVar1 = 0xffffffffffffffd9;
  }
  else {
    local_18 = time((time_t *)0x0);
    do {
      local_1c = _libssh2_channel_receive_window_adjust
                           (param_1,param_2 & 0xffffffff,(ulong)param_3,&local_20);
      if ((local_1c != -0x25) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_1c = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60), 0);
    } while (local_1c == 0);
    if (local_1c == 0) {
      uVar1 = (ulong)local_20;
    }
    else {
      uVar1 = SEXT48(local_1c);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



ulong libssh2_channel_receive_window_adjust2
                (long param_1,ulong param_2,byte param_3,undefined8 param_4)

{
  ulong uVar1;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    time((time_t *)0x0);
    do {
      local_14 = _libssh2_channel_receive_window_adjust
                           (param_1,param_2 & 0xffffffff,(ulong)param_3,param_4);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60), 0);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



//undefined8 _libssh2_channel_extended_data(long param_1,int param_2)
//
//{
//  int iVar1;
//  
//  if (*(int *)(param_1 + 0x2a8) == 0) {
//    *(undefined *)(param_1 + 0x56) = (char)param_2;
//    *(undefined4 *)(param_1 + 0x2a8) = 2;
//  }
//  if (((*(int *)(param_1 + 0x2a8) == 0) && (param_2 == 1)) &&
//     (iVar1 = _libssh2_channel_flush(param_1,0xffffffff), iVar1 == -0x25)) {
//    return 0xffffffdb;
//  }
//  *(undefined4 *)(param_1 + 0x2a8) = 0;
//  return 0;
//}
//


//ulong libssh2_channel_handle_extended_data2(long param_1,uint param_2)
//
//{
//  ulong uVar1;
//  uint local_14;
//  
//  if (param_1 == 0) {
//    uVar1 = 0xffffffd9;
//  }
//  else {
//    time((time_t *)0x0);
//    do {
//      local_14 = _libssh2_channel_extended_data(param_1,(ulong)param_2);
//      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
//      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60));
//    } while (local_14 == 0);
//    uVar1 = (ulong)local_14;
//  }
//  return uVar1;
//}
//


void libssh2_channel_handle_extended_data(undefined8 param_1,uint param_2)

{
  libssh2_channel_handle_extended_data2(param_1,(ulong)param_2);
  return;
}



//ulong _libssh2_channel_read(long param_1,int param_2,long param_3,ulong param_4)
//
//{
//  long lVar1;
//  int iVar2;
//  uint uVar3;
//  undefined4 uVar4;
//  long lVar5;
//  bool bVar6;
//  uint local_40;
//  ulong local_38;
//  ulong local_30;
//  long local_28;
//  
//  lVar1 = *(long *)(param_1 + 0x60);
//  local_38 = 0;
//  if ((*(int *)(param_1 + 0x260) == 0xb) ||
//     ((ulong)*(uint *)(param_1 + 0x4c) < param_4 + (*(uint *)(param_1 + 0x48) >> 2) * 3)) {
//    local_40 = ((int)param_4 + *(int *)(param_1 + 0x48)) - *(int *)(param_1 + 0x4c);
//    if (local_40 < 0x400) {
//      local_40 = 0x400;
//    }
//    *(undefined4 *)(param_1 + 0x260) = 0xb;
//    iVar2 = _libssh2_channel_receive_window_adjust(param_1,(ulong)local_40,0,0);
//    if (iVar2 != 0) {
//      return (long)iVar2;
//    }
//    *(undefined4 *)(param_1 + 0x260) = 0;
//  }
//  do {
//    uVar3 = _libssh2_transport_read(lVar1);
//  } while (0 < (int)uVar3);
//  if (((int)uVar3 < 0) && (uVar3 != 0xffffffdb)) {
//    iVar2 = _libssh2_error(lVar1,(ulong)uVar3,"transport read",(ulong)uVar3);
//    local_38 = SEXT48(iVar2);
//  }
//  else {
//    lVar5 = _libssh2_list_first(lVar1 + 0x1f0);
//    while ((local_28 = lVar5, local_28 != 0 && (local_38 < param_4))) {
//      lVar5 = _libssh2_list_next(local_28);
//      if (4 < *(ulong *)(local_28 + 0x20)) {
//        uVar4 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 1);
//        *(undefined4 *)(param_1 + 0x264) = uVar4;
//        if ((((((param_2 != 0) && (**(char **)(local_28 + 0x18) == '_')) &&
//              (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))) &&
//             ((8 < *(ulong *)(local_28 + 0x20) &&
//              (iVar2 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 5), param_2 == iVar2)))) ||
//            ((param_2 == 0 &&
//             ((**(char **)(local_28 + 0x18) == '^' &&
//              (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))))))) ||
//           ((param_2 == 0 &&
//            (((**(char **)(local_28 + 0x18) == '_' &&
//              (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))) &&
//             (*(char *)(param_1 + 0x56) == '\x02')))))) {
//          local_30 = param_4 - local_38;
//          bVar6 = (ulong)(*(long *)(local_28 + 0x20) - *(long *)(local_28 + 0x28)) <= local_30;
//          if (bVar6) {
//            local_30 = *(long *)(local_28 + 0x20) - *(long *)(local_28 + 0x28);
//          }
//          memcpy((void *)(param_3 + local_38),
//                 (void *)(*(long *)(local_28 + 0x18) + *(long *)(local_28 + 0x28)),local_30);
//          *(long *)(local_28 + 0x28) = *(long *)(local_28 + 0x28) + local_30;
//          local_38 = local_38 + local_30;
//          if (bVar6) {
//            _libssh2_list_remove(local_28);
//            ((void*(*)())(lVar1 + 0x18))
//                      (*(undefined8 *)(local_28 + 0x18),lVar1,*(undefined8 *)(local_28 + 0x18),lVar1
//                      );
//            ((void*(*)())(lVar1 + 0x18))(local_28,lVar1,local_28,lVar1);
//          }
//        }
//      }
//    }
//    if (local_38 == 0) {
//      if ((*(char *)(param_1 + 0x55) == '\0') && (*(char *)(param_1 + 0x54) == '\0')) {
//        if (uVar3 == 0xffffffdb) {
//          iVar2 = _libssh2_error(lVar1,0xffffffdb,"would block",0xffffffdb);
//          local_38 = SEXT48(iVar2);
//        }
//        else {
//          local_38 = 0;
//        }
//      }
//      else {
//        local_38 = 0;
//      }
//    }
//    else {
//      *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - (int)local_38;
//      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - (int)local_38;
//    }
//  }
//  return local_38;
//}
//


long libssh2_channel_read_ex(long param_1,uint param_2,undefined8 param_3,ulong param_4)

{
  int iVar1;
  long lVar2;
  ulong uVar3;
  int local_24;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    uVar3 = libssh2_channel_window_read_ex(param_1,0,0);
    if (uVar3 < param_4) {
      time((time_t *)0x0);
      do {
        iVar1 = _libssh2_channel_receive_window_adjust(param_1,param_4 & 0xffffffff,1,0);
        if ((iVar1 != -0x25) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
        iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60), 0);
      } while (iVar1 == 0);
    }
    time((time_t *)0x0);
    do {
      local_24 = _libssh2_channel_read(param_1,(ulong)param_2,param_3,param_4);
      if ((local_24 != -0x25) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_24 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60), 0);
    } while (local_24 == 0);
    lVar2 = (long)local_24;
  }
  return lVar2;
}



//long _libssh2_channel_packet_data_len(long param_1,int param_2)
//
//{
//  int iVar1;
//  int iVar2;
//  long lVar3;
//  long local_20;
//  
//  lVar3 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
//  if (lVar3 == 0) {
//    lVar3 = 0;
//  }
//  else {
//    do {
//      local_20 = lVar3;
//      if (local_20 == 0) {
//        return 0;
//      }
//      lVar3 = _libssh2_list_next(local_20);
//    } while ((*(ulong *)(local_20 + 0x20) < 5) ||
//            ((((((iVar1 = _libssh2_ntohu32(*(long *)(local_20 + 0x18) + 1), param_2 == 0 ||
//                 (**(char **)(local_20 + 0x18) != '_')) || (iVar1 != *(int *)(param_1 + 0x30))) ||
//               ((*(ulong *)(local_20 + 0x20) < 9 ||
//                (iVar2 = _libssh2_ntohu32(*(long *)(local_20 + 0x18) + 5), param_2 != iVar2)))) &&
//              ((param_2 != 0 ||
//               ((**(char **)(local_20 + 0x18) != '^' || (iVar1 != *(int *)(param_1 + 0x30))))))) &&
//             ((param_2 != 0 ||
//              (((**(char **)(local_20 + 0x18) != '_' || (iVar1 != *(int *)(param_1 + 0x30))) ||
//               (*(char *)(param_1 + 0x56) != '\x02'))))))));
//    lVar3 = *(long *)(local_20 + 0x20) - *(long *)(local_20 + 0x28);
//  }
//  return lVar3;
//}
//


//long _libssh2_channel_write(long param_1,uint param_2,undefined8 param_3,ulong param_4)
//
//{
//  int iVar1;
//  uint uVar2;
//  long lVar3;
//  undefined uVar4;
//  ulong uVar5;
//  long in_FS_OFFSET;
//  ulong local_58;
//  undefined *local_28;
//  long local_20;
//  long local_18;
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_20 = *(long *)(param_1 + 0x60);
//  local_18 = 0;
//  local_58 = param_4;
//  if (0x7fbc < param_4) {
//    local_58 = 0x7fbc;
//  }
//  if (*(int *)(param_1 + 0x268) == 0) {
//    local_28 = (undefined *)(param_1 + 0x26c);
//    if (*(char *)(param_1 + 0x40) != '\0') {
//      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe6,
//                             "We\'ve already closed this channel");
//      lVar3 = (long)iVar1;
//      goto LAB_00116bc2;
//    }
//    if (*(char *)(param_1 + 0x41) != '\0') {
//      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe5,
//                             "EOF has already been received, data might be ignored");
//      lVar3 = (long)iVar1;
//      goto LAB_00116bc2;
//    }
//    do {
//      uVar2 = _libssh2_transport_read(local_20);
//    } while (0 < (int)uVar2);
//    if (((int)uVar2 < 0) && (uVar2 != 0xffffffdb)) {
//      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),(ulong)uVar2,
//                             "Failure while draining incoming flow",(ulong)uVar2);
//      lVar3 = (long)iVar1;
//      goto LAB_00116bc2;
//    }
//    if (*(int *)(param_1 + 0x38) == 0) {
//      *(undefined4 *)(local_20 + 0x230) = 1;
//      if (uVar2 == 0xffffffdb) {
//        lVar3 = -0x25;
//      }
//      else {
//        lVar3 = 0;
//      }
//      goto LAB_00116bc2;
//    }
//    *(ulong *)(param_1 + 0x288) = local_58;
//    if (param_2 == 0) {
//      uVar4 = 0x5e;
//    }
//    else {
//      uVar4 = 0x5f;
//    }
//    *local_28 = uVar4;
//    local_28 = local_28 + 1;
//    _libssh2_store_u32(&local_28,(ulong)*(uint *)(param_1 + 0x44),(ulong)*(uint *)(param_1 + 0x44));
//    if (param_2 != 0) {
//      _libssh2_store_u32(&local_28,(ulong)param_2,(ulong)param_2);
//    }
//    if ((ulong)*(uint *)(param_1 + 0x38) < *(ulong *)(param_1 + 0x288)) {
//      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x38);
//    }
//    if ((ulong)*(uint *)(param_1 + 0x3c) < *(ulong *)(param_1 + 0x288)) {
//      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x3c);
//    }
//    uVar5 = *(ulong *)(param_1 + 0x288) & 0xffffffff;
//    _libssh2_store_u32(&local_28,uVar5,uVar5);
//    *(undefined **)(param_1 + 0x280) = local_28 + -(param_1 + 0x26c);
//    *(undefined4 *)(param_1 + 0x268) = 2;
//  }
//  if (*(int *)(param_1 + 0x268) == 2) {
//    uVar2 = _libssh2_transport_send
//                      (local_20,param_1 + 0x26c,*(undefined8 *)(param_1 + 0x280),param_3,
//                       *(undefined8 *)(param_1 + 0x288));
//    if (uVar2 == 0xffffffdb) {
//      iVar1 = _libssh2_error(local_20,0xffffffdb,"Unable to send channel data",0xffffffdb);
//      lVar3 = (long)iVar1;
//    }
//    else {
//      if (uVar2 == 0) {
//        *(int *)(param_1 + 0x38) = *(int *)(param_1 + 0x38) - (int)*(undefined8 *)(param_1 + 0x288);
//        lVar3 = local_18 + *(long *)(param_1 + 0x288);
//        *(undefined4 *)(param_1 + 0x268) = 0;
//        local_18 = lVar3;
//      }
//      else {
//        *(undefined4 *)(param_1 + 0x268) = 0;
//        iVar1 = _libssh2_error(local_20,(ulong)uVar2,"Unable to send channel data",(ulong)uVar2);
//        lVar3 = (long)iVar1;
//      }
//    }
//  }
//  else {
//    lVar3 = -0x22;
//  }
//LAB_00116bc2:
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return lVar3;
//}
//


long libssh2_channel_write_ex(long param_1,uint param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  long lVar2;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    time((time_t *)0x0);
    do {
      lVar2 = _libssh2_channel_write(param_1,(ulong)param_2,param_3,param_4);
      if (lVar2 != -0x25) {
        return lVar2;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return 0xffffffffffffffdb;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60), 0);
      lVar2 = (long)iVar1;
    } while (lVar2 == 0);
  }
  return lVar2;
}



undefined8 FUN_00116c6b(long param_1)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  undefined local_15;
  undefined auStack20 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  uVar2 = *(undefined8 *)(param_1 + 0x60);
  local_15 = 0x60;
  _libssh2_htonu32(auStack20,(ulong)*(uint *)(param_1 + 0x44));
  iVar1 = _libssh2_transport_send(uVar2,&local_15,5,0,0);
  if (iVar1 == -0x25) {
    _libssh2_error(uVar2,0xffffffdb,"Would block sending EOF",0xffffffdb);
    uVar2 = 0xffffffdb;
  }
  else {
    if (iVar1 == 0) {
      *(undefined *)(param_1 + 0x41) = 1;
      uVar2 = 0;
    }
    else {
      uVar2 = _libssh2_error(uVar2,0xfffffff9,"Unable to send EOF on channel");
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong libssh2_channel_send_eof(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_00116c6b(param_1);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



//ulong libssh2_channel_eof(long param_1)
//
//{
//  int iVar1;
//  int iVar2;
//  undefined8 uVar3;
//  long lVar4;
//  long local_30;
//  
//  if (param_1 == 0) {
//    uVar3 = 0xffffffd9;
//  }
//  else {
//    lVar4 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
//    do {
//      local_30 = lVar4;
//      if (local_30 == 0) {
//        return (ulong)(uint)(int)*(char *)(param_1 + 0x55);
//      }
//      lVar4 = _libssh2_list_next(local_30);
//    } while (((*(long *)(local_30 + 0x20) == 0) ||
//             (((**(char **)(local_30 + 0x18) != '^' && (**(char **)(local_30 + 0x18) != '_')) ||
//              (*(ulong *)(local_30 + 0x20) < 5)))) ||
//            (iVar1 = *(int *)(param_1 + 0x30),
//            iVar2 = _libssh2_ntohu32(*(long *)(local_30 + 0x18) + 1), iVar1 != iVar2));
//    uVar3 = 0;
//  }
//  return uVar3;
//}



undefined8 FUN_00116e8f(long param_1)

{
  long lVar1;
  uint uVar2;
  undefined8 uVar3;
  
  lVar1 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x29c) == 0) {
    *(undefined4 *)(param_1 + 0x29c) = 2;
  }
  do {
    if (*(char *)(param_1 + 0x55) != '\0') {
      *(undefined4 *)(param_1 + 0x29c) = 0;
      return 0;
    }
    if ((*(int *)(param_1 + 0x4c) == *(int *)(param_1 + 0x5c)) && (*(int *)(lVar1 + 0x94) != 0)) {
      uVar3 = _libssh2_error(lVar1,0xffffffd1,"Receiving channel window has been exhausted");
      return uVar3;
    }
    uVar2 = _libssh2_transport_read(lVar1);
    if (uVar2 == 0xffffffdb) {
      return 0xffffffdb;
    }
  } while (-1 < (int)uVar2);
  *(undefined4 *)(param_1 + 0x29c) = 0;
  uVar3 = _libssh2_error(lVar1,(ulong)uVar2,"_libssh2_transport_read() bailed out!",(ulong)uVar2);
  return uVar3;
}



ulong libssh2_channel_wait_eof(long param_1)
{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_00116e8f(param_1);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    uVar1 = (ulong)local_14;
  }
    while (true);
 }
  return uVar1;
}



//ulong _libssh2_channel_close(long param_1)
//
//{
//  long lVar1;
//  ulong uVar2;
//  uint local_14;
//  
//  lVar1 = *(long *)(param_1 + 0x60);
//  local_14 = 0;
//  if (*(char *)(param_1 + 0x40) == '\0') {
//    if ((*(char *)(param_1 + 0x41) == '\0') && (local_14 = FUN_00116c6b(param_1), local_14 != 0)) {
//      if (local_14 == 0xffffffdb) {
//        return 0xffffffdb;
//      }
//      _libssh2_error(lVar1,(ulong)local_14,"Unable to send EOF, but closing channel anyway",
//                     (ulong)local_14);
//    }
//    if (*(int *)(param_1 + 0x290) == 0) {
//      *(undefined *)(param_1 + 0x294) = 0x61;
//      _libssh2_htonu32(param_1 + 0x295,(ulong)*(uint *)(param_1 + 0x44),param_1 + 0x295);
//      *(undefined4 *)(param_1 + 0x290) = 2;
//    }
//    if (*(int *)(param_1 + 0x290) == 2) {
//      local_14 = _libssh2_transport_send(lVar1,param_1 + 0x294,5,0,0);
//      if (local_14 == 0xffffffdb) {
//        _libssh2_error(lVar1,0xffffffdb,"Would block sending close-channel",0xffffffdb);
//        return 0xffffffdb;
//      }
//      if (local_14 == 0) {
//        *(undefined4 *)(param_1 + 0x290) = 3;
//      }
//      else {
//        _libssh2_error(lVar1,(ulong)local_14,
//                       "Unable to send close-channel request, but closing anyway",(ulong)local_14);
//      }
//    }
//    if (*(int *)(param_1 + 0x290) == 3) {
//      while (((*(char *)(param_1 + 0x54) == '\0' && (local_14 == 0)) &&
//             (*(int *)(lVar1 + 0x22c) != -1))) {
//        local_14 = _libssh2_transport_read(lVar1);
//      }
//    }
//    if (local_14 != 0xffffffdb) {
//      *(undefined *)(param_1 + 0x40) = 1;
//      if (*(long *)(param_1 + 0x70) != 0) {
//        ((void*(*)())(param_1 + 0x70))(lVar1,lVar1,param_1,param_1 + 0x68);
//      }
//      *(undefined4 *)(param_1 + 0x290) = 0;
//    }
//    uVar2 = 0;
//    if ((int)local_14 < 1) {
//      uVar2 = (ulong)local_14;
//    }
//  }
//  else {
//    *(undefined4 *)(param_1 + 0x290) = 0;
//    uVar2 = 0;
//  }
//  return uVar2;
//}
//


ulong libssh2_channel_close(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = _libssh2_channel_close(param_1);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_00117248(long param_1)

{
  uint uVar1;
  undefined8 uVar2;
  
  uVar2 = *(undefined8 *)(param_1 + 0x60);
  if (*(char *)(param_1 + 0x55) == '\0') {
    uVar2 = _libssh2_error(uVar2,0xffffffde,
                           "libssh2_channel_wait_closed() invoked when channel is not in EOF state")
    ;
  }
  else {
    if (*(int *)(param_1 + 0x2a0) == 0) {
      *(undefined4 *)(param_1 + 0x2a0) = 2;
    }
    if (*(char *)(param_1 + 0x54) == '\0') {
      do {
        uVar1 = _libssh2_transport_read(uVar2);
        if (*(char *)(param_1 + 0x54) != '\0') break;
      } while (0 < (int)uVar1);
      if ((int)uVar1 < 0) {
        return (ulong)uVar1;
      }
    }
    *(undefined4 *)(param_1 + 0x2a0) = 0;
    uVar2 = 0;
  }
  return uVar2;
}



ulong libssh2_channel_wait_closed(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_00117248(param_1);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



//undefined8 _libssh2_channel_free(long param_1)
//
//{
//  int iVar1;
//  long in_FS_OFFSET;
//  undefined8 uVar2;
//  undefined8 local_30;
//  undefined local_28 [8];
//  long local_20;
//  undefined local_14 [4];
//  long local_10;
//  
//  local_10 = *(long *)(in_FS_OFFSET + 0x28);
//  local_20 = *(long *)(param_1 + 0x60);
//  if (local_20 == 0) {
//                    // WARNING: Subroutine does not return
//    __assert_fail("session","/home/mantovan/Repositories/libssh2/src/channel.c",0xaa3,
//                  "_libssh2_channel_free");
//  }
//  if (*(int *)(param_1 + 0x2a4) == 0) {
//    *(undefined4 *)(param_1 + 0x2a4) = 2;
//  }
//  if ((*(char *)(param_1 + 0x40) == '\0') && (*(int *)(local_20 + 0x22c) == 0)) {
//    iVar1 = _libssh2_channel_close(param_1);
//    if (iVar1 == -0x25) {
//      uVar2 = 0xffffffdb;
//      goto LAB_001175b3;
//    }
//  }
//  *(undefined4 *)(param_1 + 0x2a4) = 0;
//  if (*(long *)(param_1 + 0x28) != 0) {
//    ((void*(*)())(local_20 + 0x18))
//              (*(undefined8 *)(param_1 + 0x28),local_20,*(undefined8 *)(param_1 + 0x28),local_20);
//  }
//  uVar2 = 0x117452;
//  _libssh2_htonu32(local_14,(ulong)*(uint *)(param_1 + 0x30),(ulong)*(uint *)(param_1 + 0x30));
//  do {
//    iVar1 = _libssh2_packet_ask(local_20,0x5e,&local_30,local_28,1,local_14,4,uVar2);
//    if (iVar1 < 0) {
//      iVar1 = _libssh2_packet_ask(local_20,0x5f,&local_30,local_28,1,local_14,4,uVar2);
//      if (iVar1 < 0) break;
//    }
//    uVar2 = 0x11746c;
//    ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
//  } while( 1 );
//  if (*(long *)(param_1 + 0x18) != 0) {
//    ((void*(*)())(local_20 + 0x18))
//              (*(undefined8 *)(param_1 + 0x18),local_20,*(undefined8 *)(param_1 + 0x18),local_20);
//  }
//  _libssh2_list_remove(param_1);
//  if (*(long *)(param_1 + 0x80) != 0) {
//    ((void*(*)())(local_20 + 0x18))
//              (*(undefined8 *)(param_1 + 0x80),local_20,*(undefined8 *)(param_1 + 0x80),local_20);
//  }
//  if (*(long *)(param_1 + 0x1f0) != 0) {
//    ((void*(*)())(local_20 + 0x18))
//              (*(undefined8 *)(param_1 + 0x1f0),local_20,*(undefined8 *)(param_1 + 0x1f0),local_20);
//  }
//  if (*(long *)(param_1 + 0x218) != 0) {
//    ((void*(*)())(local_20 + 0x18))
//              (*(undefined8 *)(param_1 + 0x218),local_20,*(undefined8 *)(param_1 + 0x218),local_20);
//  }
//  ((void*(*)())(local_20 + 0x18))(param_1,local_20,param_1,local_20);
//  uVar2 = 0;
//LAB_001175b3:
//  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
//                    // WARNING: Subroutine does not return
//    __stack_chk_fail();
//  }
//  return uVar2;
//}
//


//ulong libssh2_channel_free(long param_1)
//
//{
//  ulong uVar1;
//  time_t tVar2;
//  uint local_14;
//  
//  if (param_1 == 0) {
//    uVar1 = 0xffffffd9;
//  }
//  else {
//    tVar2 = time((time_t *)0x0);
//    do {
//      local_14 = _libssh2_channel_free(param_1);
//      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
//      local_14 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2,tVar2);
//    } while (local_14 == 0);
//    uVar1 = (ulong)local_14;
//  }
//  return uVar1;
//}
//


//ulong libssh2_channel_window_read_ex(long param_1,long *param_2,ulong *param_3)
//
//{
//  int iVar1;
//  ulong uVar2;
//  long lVar3;
//  long local_20;
//  long local_18;
//  
//  if (param_1 == 0) {
//    uVar2 = 0;
//  }
//  else {
//    if (param_3 != (ulong *)0x0) {
//      *param_3 = (ulong)*(uint *)(param_1 + 0x48);
//    }
//    if (param_2 != (long *)0x0) {
//      local_20 = 0;
//      lVar3 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
//      while (local_18 = lVar3, local_18 != 0) {
//        lVar3 = _libssh2_list_next(local_18);
//        if (((*(long *)(local_18 + 0x20) != 0) &&
//            (((**(char **)(local_18 + 0x18) == '^' || (**(char **)(local_18 + 0x18) == '_')) &&
//             (4 < *(ulong *)(local_18 + 0x20))))) &&
//           (iVar1 = _libssh2_ntohu32(*(long *)(local_18 + 0x18) + 1),
//           iVar1 == *(int *)(param_1 + 0x30))) {
//          local_20 = local_20 + (*(long *)(local_18 + 0x20) - *(long *)(local_18 + 0x28));
//        }
//      }
//      *param_2 = local_20;
//    }
//    uVar2 = (ulong)*(uint *)(param_1 + 0x4c);
//  }
//  return uVar2;
//}
//


ulong libssh2_channel_window_write_ex(long param_1,ulong *param_2)

{
  ulong uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    if (param_2 != (ulong *)0x0) {
      *param_2 = (ulong)*(uint *)(param_1 + 0x34);
    }
    uVar1 = (ulong)*(uint *)(param_1 + 0x38);
  }
  return uVar1;
}



undefined8 FUN_0011779a(void)

{
  return 0;
}



undefined8
FUN_001177bd(undefined8 param_1,undefined8 *param_2,undefined8 *param_3,undefined8 param_4,
            undefined8 param_5,undefined8 param_6)

{
  *param_2 = param_5;
  *param_3 = param_6;
  return 0;
}



//undefined ** _libssh2_comp_methods(long param_1)
//
//{
//  undefined **ppuVar1;
//  
//  if (*(int *)(param_1 + 0x70) == 0) {
//    ppuVar1 = &PTR_PTR_DAT_00350970;
//  }
//  else {
//    ppuVar1 = &PTR_PTR_DAT_00350960;
//  }
//  return ppuVar1;
//}
//

undefined8 FUN_00117f3b(undefined8 param_1,RSA **param_2)

{
  RSA_free(*param_2);
  *param_2 = (RSA *)0x0;
  return 0;
}
undefined8
FUN_0011781b(long param_1,long param_2,undefined8 param_3,undefined4 *param_4,undefined8 param_5,
            undefined4 *param_6,uint param_7,uint **param_8)

{
  int iVar1;
  uint *puVar2;
  undefined8 uVar3;
  
  puVar2 = (uint *)((void*(*)())(param_1 + 8))(0x18,param_1,param_1);
  if (puVar2 == (uint *)0x0) {
    uVar3 = 0xfffffffa;
  }
  else {
    *puVar2 = param_7;
    *(undefined8 *)(puVar2 + 2) = *(undefined8 *)(param_2 + 0x40);
    iVar1 = _libssh2_cipher_init
                      (puVar2 + 4,*(undefined8 *)(puVar2 + 2),param_3,param_5,(ulong)param_7);
    if (iVar1 == 0) {
      *param_8 = puVar2;
      *param_4 = 1;
      *param_6 = 1;
      uVar3 = 0;
    }
    else {
      ((void*(*)())(param_1 + 0x18))(puVar2,param_1,puVar2,param_1);
      uVar3 = 0xffffffff;
    }
  }
  return uVar3;
}



void FUN_001178ec(undefined8 param_1,undefined8 param_2,undefined8 param_3,uint **param_4)

{
  uint *puVar1;
  
  puVar1 = *param_4;
  _libssh2_cipher_crypt(puVar1 + 4,*(undefined8 *)(puVar1 + 2),(ulong)*puVar1,param_2,param_3);
  return;
}



undefined8 FUN_0011793a(long param_1,long *param_2)

{
  if ((param_2 != (long *)0x0) && (*param_2 != 0)) {
    EVP_CIPHER_CTX_free(*(EVP_CIPHER_CTX **)(*param_2 + 0x10));
    ((void*(*)())(param_1 + 0x18))(*param_2,param_1,*param_2,param_1);
    *param_2 = 0;
  }
  return 0;
}



ulong FUN_001179a5(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4,
                  undefined8 param_5,undefined8 param_6,uint param_7,uint **param_8)

{
  uint *puVar1;
  uint uVar2;
  long in_FS_OFFSET;
  long local_28;
  undefined local_18 [8];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  uVar2 = FUN_0011781b(param_1,param_2,param_3,param_4,param_5,param_6,(ulong)param_7,param_8);
  if (uVar2 == 0) {
    puVar1 = *param_8;
    local_28 = 0x600;
    while (local_28 != 0) {
      _libssh2_cipher_crypt
                (puVar1 + 4,*(undefined8 *)(puVar1 + 2),(ulong)*puVar1,local_18,
                 (long)*(int *)(param_2 + 0x10));
      local_28 = local_28 + -8;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (ulong)uVar2;
}



undefined ** libssh2_crypt_methods(void)

{
  return &PTR_PTR_s_aes128_ctr_00350980;
}



//undefined8 libssh2_init(uint param_1)
//
//{
//  if ((DAT_00350afc == 0) && ((param_1 & 1) == 0)) {
//    _libssh2_openssl_crypto_init();
//  }
//  DAT_00350afc = DAT_00350afc + 1;
//  DAT_00350b00 = DAT_00350b00 | param_1;
//  return 0;
//}
//


void libssh2_exit(void)

{
  if (((DAT_00350afc != 0) && (DAT_00350afc = DAT_00350afc + -1, DAT_00350afc == 0)) &&
     ((DAT_00350b00 & 1) == 0)) {
    _libssh2_openssl_crypto_exit();
  }
  return;
}



//void _libssh2_init_if_needed(void)
//
//{
//  if (DAT_00350afc == 0) {
//    libssh2_init(0);
//  }
//  return;
//}
//


undefined8 FUN_00117b2c(undefined8 param_1,undefined8 param_2,ulong param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    FUN_00117f3b(param_1,param_4);
    *param_4 = 0;
  }
  if (param_3 < 0x13) {
    uVar2 = 0xffffffff;
  }
  else {
    local_28 = param_2;
    local_20 = param_2;
    local_18 = param_3;
    iVar1 = _libssh2_match_string(&local_28,"ssh-rsa");
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_string(&local_28,&local_48,&local_38,&local_48);
      if (iVar1 == 0) {
        uVar2 = 0x117c03;
        iVar1 = _libssh2_get_string(&local_28,&local_40,&local_30,&local_40);
        if (iVar1 == 0) {
          iVar1 = _libssh2_rsa_new(&local_50,local_48,local_38,local_40,local_30,0,0,0,0,0,0,0,0,0,0
                                   ,0,0);
          if (iVar1 == 0) {
            *param_4 = local_50;
            uVar2 = 0;
          }
          else {
            uVar2 = 0xffffffff;
          }
        }
        else {
          uVar2 = 0xffffffff;
        }
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 FUN_00117c82(undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    FUN_00117f3b(param_1,param_4);
    *param_4 = 0;
  }
  iVar1 = _libssh2_rsa_new_private(&local_18,param_1,param_2,param_3);
  if (iVar1 == 0) {
    *param_4 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00117d21(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
            long *param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_5 != 0) {
    FUN_00117f3b(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_rsa_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    *param_5 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00117dcb(undefined8 param_1,long param_2,ulong param_3,undefined8 param_4,undefined8 param_5,
            undefined8 *param_6)

{
  undefined8 uVar1;
  
  if (param_3 < 0xf) {
    uVar1 = 0xffffffff;
  }
  else {
    uVar1 = _libssh2_rsa_sha1_verify(*param_6,param_2 + 0xf,param_3 - 0xf,param_4,param_5);
  }
  return uVar1;
}



undefined8
FUN_00117e2f(undefined8 param_1,undefined8 param_2,undefined8 param_3,int param_4,long param_5,
            undefined8 *param_6)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_40;
  EVP_MD_CTX *local_38;
  undefined8 local_30;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *param_6;
  _libssh2_sha1_init(&local_38);
  local_40 = 0;
  while (local_40 < param_4) {
    EVP_DigestUpdate(local_38,*(void **)(param_5 + (long)local_40 * 0x10),
                     *(size_t *)(param_5 + (long)local_40 * 0x10 + 8));
    local_40 = local_40 + 1;
  }
  EVP_DigestFinal(local_38,local_28,(uint *)0x0);
  EVP_MD_CTX_free(local_38);
  iVar1 = _libssh2_rsa_sha1_sign(param_1,local_30,local_28,0x14,param_2,param_3);
  if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}







undefined8 FUN_00117f74(undefined8 param_1,undefined8 param_2,ulong param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    FUN_0011843e(param_1,param_4);
    *param_4 = 0;
  }
  if (param_3 < 0x1b) {
    uVar2 = 0xffffffff;
  }
  else {
    local_28 = param_2;
    local_20 = param_2;
    local_18 = param_3;
    iVar1 = _libssh2_match_string(&local_28,"ssh-dss");
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_string(&local_28,&local_68,&local_48,&local_68);
      if (iVar1 == 0) {
        iVar1 = _libssh2_get_string(&local_28,&local_60,&local_40,&local_60);
        if (iVar1 == 0) {
          iVar1 = _libssh2_get_string(&local_28,&local_58,&local_38,&local_58);
          if (iVar1 == 0) {
            uVar2 = 0x1180ad;
            iVar1 = _libssh2_get_string(&local_28,&local_50,&local_30,&local_50);
            if (iVar1 == 0) {
              iVar1 = _libssh2_dsa_new(&local_70,local_68,local_48,local_60,local_40,local_58,
                                       local_38,local_50,local_30,0,0);
              if (iVar1 == 0) {
                *param_4 = local_70;
                uVar2 = 0;
              }
              else {
                uVar2 = 0xffffffff;
              }
            }
            else {
              uVar2 = 0xffffffff;
            }
          }
          else {
            uVar2 = 0xffffffff;
          }
        }
        else {
          uVar2 = 0xffffffff;
        }
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 FUN_0011812f(undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    FUN_0011843e(param_1,param_4);
    *param_4 = 0;
  }
  iVar1 = _libssh2_dsa_new_private(&local_18,param_1,param_2,param_3);
  if (iVar1 == 0) {
    *param_4 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_001181ce(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
            long *param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_5 != 0) {
    FUN_0011843e(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_dsa_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    *param_5 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



void FUN_00118278(undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5
                 ,undefined8 *param_6)

{
  if (param_3 == 0x37) {
    _libssh2_dsa_sha1_verify(*param_6,param_2 + 0xf,param_4,param_5);
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"Invalid DSS signature length");
  }
  return;
}



undefined8
FUN_001182e8(long param_1,long *param_2,undefined8 *param_3,int param_4,long param_5,
            undefined8 *param_6)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  int local_3c;
  EVP_MD_CTX *local_38;
  undefined8 local_30;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *param_6;
  lVar2 = _libssh2_calloc(param_1,0x28);
  *param_2 = lVar2;
  if (*param_2 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    *param_3 = 0x28;
    _libssh2_sha1_init(&local_38);
    local_3c = 0;
    while (local_3c < param_4) {
      EVP_DigestUpdate(local_38,*(void **)(param_5 + (long)local_3c * 0x10),
                       *(size_t *)(param_5 + (long)local_3c * 0x10 + 8));
      local_3c = local_3c + 1;
    }
    EVP_DigestFinal(local_38,local_28,(uint *)0x0);
    EVP_MD_CTX_free(local_38);
    iVar1 = _libssh2_dsa_sha1_sign(local_30,local_28,0x14,*param_2);
    if (iVar1 == 0) {
      uVar3 = 0;
    }
    else {
      ((void*(*)())(param_1 + 0x18))(*param_2,param_1,*param_2,param_1);
      uVar3 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8 FUN_0011843e(undefined8 param_1,DSA **param_2)

{
  DSA_free(*param_2);
  *param_2 = (DSA *)0x0;
  return 0;
}



undefined8 FUN_00118477(undefined8 param_1,undefined8 param_2,ulong param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uint local_5c;
  long local_58;
  char *local_50;
  char *local_48;
  undefined8 local_40;
  undefined8 local_38;
  long local_30;
  undefined8 local_28;
  undefined8 local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_58 = 0;
  if ((param_4 != (long *)0x0) && (*param_4 != 0)) {
    FUN_00118c7b(param_1,param_4);
    *param_4 = 0;
  }
  if (param_3 < 0x27) {
    uVar2 = 0xffffffff;
  }
  else {
    local_28 = param_2;
    local_20 = param_2;
    local_18 = param_3;
    iVar1 = _libssh2_get_string(&local_28,&local_50,&local_30,&local_50);
    if ((iVar1 == 0) && (local_30 == 0x13)) {
      iVar1 = strncmp(local_50,"ecdsa-sha2-nistp256",0x13);
      if (iVar1 == 0) {
        local_5c = 0x19f;
      }
      else {
        iVar1 = strncmp(local_50,"ecdsa-sha2-nistp384",0x13);
        if (iVar1 == 0) {
          local_5c = 0x2cb;
        }
        else {
          iVar1 = strncmp(local_50,"ecdsa-sha2-nistp521",0x13);
          if (iVar1 != 0) {
            uVar2 = 0xffffffff;
            goto LAB_001186bc;
          }
          local_5c = 0x2cc;
        }
      }
      iVar1 = _libssh2_get_string(&local_28,&local_48,&local_30,&local_48);
      if ((iVar1 == 0) && (local_30 == 8)) {
        if (local_5c == 0x19f) {
          iVar1 = strncmp(local_48,"nistp256",8);
          if (iVar1 != 0) {
            uVar2 = 0xffffffff;
            goto LAB_001186bc;
          }
        }
        if (local_5c == 0x2cb) {
          iVar1 = strncmp(local_48,"nistp384",8);
          if (iVar1 != 0) {
            uVar2 = 0xffffffff;
            goto LAB_001186bc;
          }
        }
        if (local_5c == 0x2cc) {
          iVar1 = strncmp(local_48,"nistp521",8);
          if (iVar1 != 0) {
            uVar2 = 0xffffffff;
            goto LAB_001186bc;
          }
        }
        iVar1 = _libssh2_get_string(&local_28,&local_40,&local_38,&local_40);
        if (iVar1 == 0) {
          iVar1 = _libssh2_ecdsa_curve_name_with_octal_new
                            (&local_58,local_40,local_38,(ulong)local_5c);
          if (iVar1 == 0) {
            if (param_4 != (long *)0x0) {
              *param_4 = local_58;
            }
            uVar2 = 0;
          }
          else {
            uVar2 = 0xffffffff;
          }
        }
        else {
          uVar2 = 0xffffffff;
        }
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
LAB_001186bc:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong FUN_001186d2(undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  uint uVar1;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if ((param_4 != (long *)0x0) && (*param_4 != 0)) {
    FUN_00118c7b(param_1,param_4);
    *param_4 = 0;
  }
  uVar1 = _libssh2_ecdsa_new_private(&local_18,param_1,param_2,param_3);
  if (param_4 != (long *)0x0) {
    *param_4 = local_18;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (ulong)uVar1;
}



undefined8
FUN_00118778(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
            long *param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if ((param_5 != (long *)0x0) && (*param_5 != 0)) {
    FUN_00118c7b(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_ecdsa_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    if (param_5 != (long *)0x0) {
      *param_5 = local_18;
    }
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00118838(undefined8 param_1,undefined8 param_2,ulong param_3,undefined8 param_4,
            undefined8 param_5,undefined8 *param_6)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uint local_64;
  undefined8 local_60;
  undefined8 local_58;
  undefined local_50 [8];
  undefined8 local_48;
  undefined8 local_40;
  long local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *param_6;
  if (param_3 < 0x23) {
    uVar2 = 0xffffffff;
  }
  else {
    local_28 = param_2;
    local_20 = param_2;
    local_18 = param_3;
    iVar1 = _libssh2_get_string(&local_28,local_50,&local_38,local_50);
    if ((iVar1 == 0) && (local_38 == 0x13)) {
      iVar1 = _libssh2_get_u32(&local_28,&local_64);
      if ((iVar1 == 0) && (7 < local_64)) {
        iVar1 = _libssh2_get_string(&local_28,&local_60,&local_48,&local_60);
        if (iVar1 == 0) {
          uVar2 = 0x118935;
          iVar1 = _libssh2_get_string(&local_28,&local_58,&local_40,&local_58);
          if (iVar1 == 0) {
            uVar2 = _libssh2_ecdsa_verify
                              (local_30,local_60,local_48,local_58,local_40,param_4,param_5);
          }
          else {
            uVar2 = 0xffffffff;
          }
        }
        else {
          uVar2 = 0xffffffff;
        }
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong FUN_0011898a(undefined8 param_1,undefined8 param_2,undefined8 param_3,int param_4,long param_5
                  ,undefined8 *param_6)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_7c;
  int local_78;
  int local_74;
  int local_70;
  EVP_MD_CTX *local_68;
  undefined8 local_60;
  uchar local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_60 = *param_6;
  _libssh2_ecdsa_get_curve_type(local_60);
  if (iVar1 == 0x19f) {
    _libssh2_sha256_init(&local_68);
    local_78 = 0;
    while (local_78 < param_4) {
      EVP_DigestUpdate(local_68,*(void **)(param_5 + (long)local_78 * 0x10),
                       *(size_t *)(param_5 + (long)local_78 * 0x10 + 8));
      local_78 = local_78 + 1;
    }
    EVP_DigestFinal(local_68,local_58,(uint *)0x0);
    EVP_MD_CTX_free(local_68);
    local_7c = _libssh2_ecdsa_sign(param_1,local_60,local_58,0x20,param_2,param_3);
  }
  else {
    if (iVar1 == 0x2cb) {
      _libssh2_sha384_init(&local_68);
      local_74 = 0;
      while (local_74 < param_4) {
        EVP_DigestUpdate(local_68,*(void **)(param_5 + (long)local_74 * 0x10),
                         *(size_t *)(param_5 + (long)local_74 * 0x10 + 8));
        local_74 = local_74 + 1;
      }
      EVP_DigestFinal(local_68,local_58,(uint *)0x0);
      EVP_MD_CTX_free(local_68);
      local_7c = _libssh2_ecdsa_sign(param_1,local_60,local_58,0x30,param_2,param_3);
    }
    else {
      if (iVar1 != 0x2cc) {
        uVar2 = 0xffffffff;
        goto LAB_00118c65;
      }
      _libssh2_sha512_init(&local_68);
      local_70 = 0;
      while (local_70 < param_4) {
        EVP_DigestUpdate(local_68,*(void **)(param_5 + (long)local_70 * 0x10),
                         *(size_t *)(param_5 + (long)local_70 * 0x10 + 8));
        local_70 = local_70 + 1;
      }
      EVP_DigestFinal(local_68,local_58,(uint *)0x0);
      EVP_MD_CTX_free(local_68);
      local_7c = _libssh2_ecdsa_sign(param_1,local_60,local_58,0x40,param_2,param_3);
    }
  }
  uVar2 = (ulong)local_7c;
LAB_00118c65:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 FUN_00118c7b(undefined8 param_1,void **param_2)

{
  if (*param_2 != (EC_KEY *)0x0) {
    EC_KEY_free(*param_2);
  }
  *param_2 = (EC_KEY *)0x0;
  return 0;
}

undefined8 FUN_00119013(undefined8 param_1,EVP_PKEY **param_2)

{
  if (*param_2 != (EVP_PKEY *)0x0) {
    EVP_PKEY_free(*param_2);
  }
  *param_2 = (EVP_PKEY *)0x0;
  return 0;
}



undefined8 FUN_00118cbb(undefined8 param_1,long param_2,ulong param_3,long *param_4)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  long local_30;
  char *local_28;
  ulong local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = 0;
  if (*param_4 != 0) {
    FUN_00119013(param_1,param_4);
    *param_4 = 0;
  }
  if (param_3 < 0x13) {
    uVar3 = 0xffffffff;
  }
  else {
    local_28 = (char *)param_2;
    uVar1 = _libssh2_ntohu32(param_2);
    local_20 = (ulong)uVar1;
    local_28 = (char *)((long)local_28 + 4);
    if (uVar1 == 0xb) {
      iVar2 = strncmp(local_28,"ssh-ed25519",0xb);
      if (iVar2 == 0) {
        local_28 = local_28 + 0xb;
        uVar1 = _libssh2_ntohu32(local_28);
        local_18 = (ulong)uVar1;
        local_28 = local_28 + 4;
        iVar2 = _libssh2_ed25519_new_public(&local_30,param_1,local_28,local_18 & 0xff);
        if (iVar2 == 0) {
          *param_4 = local_30;
          uVar3 = 0;
        }
        else {
          uVar3 = 0xffffffff;
        }
        goto LAB_00118dc0;
      }
    }
    uVar3 = 0xffffffff;
  }
LAB_00118dc0:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8 FUN_00118dd6(undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if (*param_4 != 0) {
    FUN_00119013(param_1,param_4);
    *param_4 = 0;
  }
  iVar1 = _libssh2_ed25519_new_private(&local_18,param_1,param_2,param_3);
  if (iVar1 == 0) {
    *param_4 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00118e7b(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
            long *param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if ((param_5 != (long *)0x0) && (*param_5 != 0)) {
    FUN_00119013(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_ed25519_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    if (param_5 != (long *)0x0) {
      *param_5 = local_18;
    }
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00118f3b(undefined8 param_1,long param_2,ulong param_3,undefined8 param_4,undefined8 param_5,
            undefined8 *param_6)

{
  undefined8 uVar1;
  
  if (param_3 < 0x13) {
    uVar1 = 0xffffffff;
  }
  else {
    if (param_3 == 0x53) {
      uVar1 = _libssh2_ed25519_verify(*param_6,param_2 + 0x13,0x40,param_4,param_5);
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  return uVar1;
}



undefined8
FUN_00118fad(undefined8 param_1,undefined8 param_2,undefined8 param_3,int param_4,
            undefined8 *param_5,undefined8 *param_6)

{
  undefined8 uVar1;
  
  if (param_4 == 1) {
    uVar1 = _libssh2_ed25519_sign(*param_6,param_1,param_2,param_3,*param_5,param_5[1]);
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}





undefined ** libssh2_hostkey_methods(void)

{
  return &PTR_PTR_s_ecdsa_sha2_nistp256_00350a00;
}



long libssh2_hostkey_hash(long param_1,int param_2)

{
  if (param_2 == 2) {
    if (*(int *)(param_1 + 0xe4) == 0) {
      param_1 = 0;
    }
    else {
      param_1 = param_1 + 0xd0;
    }
  }
  else {
    if (param_2 == 3) {
      if (*(int *)(param_1 + 0x108) == 0) {
        param_1 = 0;
      }
      else {
        param_1 = param_1 + 0xe8;
      }
    }
    else {
      if (param_2 == 1) {
        if (*(int *)(param_1 + 0xcc) == 0) {
          param_1 = 0;
        }
        else {
          param_1 = param_1 + 0xbc;
        }
      }
      else {
        param_1 = 0;
      }
    }
  }
  return param_1;
}



undefined8 FUN_001190e7(void *param_1,ulong param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if (param_2 < 0xb) {
    uVar2 = 0;
  }
  else {
    iVar1 = memcmp(&DAT_00146840,param_1,0xb);
    if (iVar1 == 0) {
      uVar2 = 1;
    }
    else {
      iVar1 = memcmp(&DAT_00146850,param_1,0xb);
      if (iVar1 == 0) {
        uVar2 = 2;
      }
      else {
        if (param_2 < 0xf) {
          uVar2 = 0;
        }
        else {
          iVar1 = memcmp(&DAT_00146860,param_1,0xf);
          if (iVar1 == 0) {
            uVar2 = 6;
          }
          else {
            if (param_2 < 0x17) {
              uVar2 = 0;
            }
            else {
              iVar1 = memcmp(&DAT_00146870,param_1,0x17);
              if (iVar1 == 0) {
                uVar2 = 3;
              }
              else {
                iVar1 = memcmp(&DAT_00146890,param_1,0x17);
                if (iVar1 == 0) {
                  uVar2 = 4;
                }
                else {
                  iVar1 = memcmp(&DAT_001468b0,param_1,0x17);
                  if (iVar1 == 0) {
                    uVar2 = 5;
                  }
                  else {
                    uVar2 = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return uVar2;
}



undefined8 libssh2_session_hostkey(long param_1,ulong *param_2,undefined4 *param_3)

{
  undefined4 uVar1;
  undefined8 uVar2;
  
  if (*(int *)(param_1 + 0xb8) == 0) {
    if (param_2 != (ulong *)0x0) {
      *param_2 = 0;
    }
    uVar2 = 0;
  }
  else {
    if (param_2 != (ulong *)0x0) {
      *param_2 = (ulong)*(uint *)(param_1 + 0xb8);
    }
    if (param_3 != (undefined4 *)0x0) {
      uVar1 = FUN_001190e7(*(undefined8 *)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));

      *param_3 = uVar1;
    }
    uVar2 = *(undefined8 *)(param_1 + 0xb0);
  }
  return uVar2;
}



void libssh2_keepalive_config(long param_1,int param_2,int param_3)

{
  if (param_3 == 1) {
    *(undefined4 *)(param_1 + 0xd628) = 2;
  }
  else {
    *(int *)(param_1 + 0xd628) = param_3;
  }
  *(uint *)(param_1 + 0xd62c) = (uint)(param_2 != 0);
  return;
}



ulong _libssh2_packet_require
                (long param_1,byte param_2,undefined8 param_3,undefined8 param_4,uint param_5,
                undefined8 param_6,undefined8 param_7,long param_8)

{
  int iVar1;
  uint uVar2;
  time_t tVar3;
  undefined8 uVar4;
  
  if (*(long *)(param_8 + 8) == 0) {
    iVar1 = _libssh2_packet_ask(param_1,(ulong)param_2,param_3,param_4,(ulong)param_5,param_6,
                                param_7);
    if (iVar1 == 0) {
      return 0;
    }
    tVar3 = time((time_t *)0x0);
    *(time_t *)(param_8 + 8) = tVar3;
  }
  while( 1 ) {
    if (*(int *)(param_1 + 0x22c) != 0) {
      return 0xfffffff3;
    }
    uVar4 = 0x12c7bb;
    uVar2 = _libssh2_transport_read(param_1);
    if (uVar2 == 0xffffffdb) {
      return 0xffffffdb;
    }
    if ((int)uVar2 < 0) {
      *(undefined8 *)(param_8 + 8) = 0;
      return (ulong)uVar2;
    }
    if (uVar2 == (uint)param_2) break;
    if (uVar2 == 0) {
      tVar3 = time((time_t *)0x0);
      if (0x3c - (tVar3 - *(long *)(param_8 + 8)) < 1) {
        *(undefined8 *)(param_8 + 8) = 0;
        uVar4 = 0xfffffff7;
      }
      else {
        uVar4 = 0xffffffff;
      }
      return uVar4;
    }
  }
  uVar2 = _libssh2_packet_ask(param_1,(ulong)param_2,param_3,param_4,(ulong)param_5,param_6,param_7);

  *(undefined8 *)(param_8 + 8) = 0;
  return (ulong)uVar2;
}

ulong _libssh2_packet_burn(long param_1,int *param_2)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  undefined8 uVar5;
  byte local_12d;
  byte *local_128;
  undefined local_120 [8];
  byte local_118 [254];
  undefined local_1a;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_2 == 0) {
    local_12d = 1;
    while (local_12d != 0xff) {
      local_118[(int)((uint)local_12d - 1)] = local_12d;
      local_12d = local_12d + 1;
    }
    local_1a = 0;
    iVar2 = _libssh2_packet_askv(param_1,local_118,&local_128,local_120,0,0,0);
    if (iVar2 == 0) {
      bVar1 = *local_128;
      ((void*(*)())(param_1 + 0x18))(local_128,param_1,local_128,param_1);
      uVar4 = (ulong)bVar1;
      goto LAB_0012ca88;
    }
    *param_2 = 2;
  }
  do {
    if (*(int *)(param_1 + 0x22c) != 0) {
      uVar4 = 0xfffffff3;
      goto LAB_0012ca88;
    }
    uVar5 = 0x12c9b2;
    uVar3 = _libssh2_transport_read(param_1);
    if (uVar3 == 0xffffffdb) {
      uVar4 = 0xffffffdb;
      goto LAB_0012ca88;
    }
    if ((int)uVar3 < 0) {
      *param_2 = 0;
      uVar4 = (ulong)uVar3;
      goto LAB_0012ca88;
    }
  } while ((uVar3 == 0) ||
          (iVar2 = _libssh2_packet_ask(param_1,(ulong)(byte)uVar3,&local_128,local_120,0,0,0),
          iVar2 != 0));
  ((void*(*)())(param_1 + 0x18))(local_128,param_1,local_128,param_1);
  *param_2 = 0;
  uVar4 = (ulong)uVar3;
LAB_0012ca88:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}




ulong FUN_00119461(long param_1,undefined8 param_2,undefined8 param_3,uint param_4,char param_5,
                  byte param_6,void *param_7,size_t param_8,int *param_9)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  BN_CTX *pBVar4;
  BIGNUM *pBVar5;
  undefined8 uVar6;
  ulong uVar7;
  size_t cnt;
  long lVar8;
  long in_FS_OFFSET;
  int local_a8;
  uint local_a4;
  uint local_a0;
  uint local_9c;
  int local_98 [2];
  struct env_md_ctx_st  local_90;
  void *local_60;
  ulong local_58;
  ulong local_50;
  void *local_48;
  ulong local_40;
  void *local_38;
  ulong local_30;
  struct env_md_ctx_st * local_28;
  long local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_a4 = 0;
  if (*param_9 == 0) {
    *(undefined8 *)(param_9 + 2) = 0;
    *(undefined8 *)(param_9 + 4) = 0;
    *(undefined8 *)(param_9 + 0x2c) = 0;
    pBVar4 = BN_CTX_new();
    *(BN_CTX **)(param_9 + 0x20) = pBVar4;
    _libssh2_dh_init(param_9 + 0x22);
    pBVar5 = BN_new();
    *(BIGNUM **)(param_9 + 0x24) = pBVar5;
    pBVar5 = BN_new();
    *(BIGNUM **)(param_9 + 0x26) = pBVar5;
    pBVar5 = BN_new();
    *(BIGNUM **)(param_9 + 0x28) = pBVar5;
    memset(param_9 + 0x38,0,0x10);
    local_a0 = _libssh2_dh_key_pair
                         (param_9 + 0x22,*(undefined8 *)(param_9 + 0x24),param_2,param_3,
                          (ulong)param_4,*(undefined8 *)(param_9 + 0x20));
    uVar2 = local_a4;
    if (local_a0 == 0) {
      iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      iVar3 = iVar1 + 7;
      if (iVar1 + 7 < 0) {
        iVar3 = iVar1 + 0xe;
      }
      *(long *)(param_9 + 0x1a) = (long)((iVar3 >> 3) + 6);
      uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      if ((uVar2 & 7) != 0) {
        *(long *)(param_9 + 0x1a) = *(long *)(param_9 + 0x1a) + -1;
      }
      uVar6 = ((void*(*)())(param_1 + 8))
                        (*(undefined8 *)(param_9 + 0x1a),param_1,*(undefined8 *)(param_9 + 0x1a),
                         param_1);
      *(undefined8 *)(param_9 + 2) = uVar6;
      if (*(long *)(param_9 + 2) != 0) {
        **(char **)(param_9 + 2) = param_5;
        uVar2 = (int)*(undefined8 *)(param_9 + 0x1a) - 5;
        _libssh2_htonu32(*(long *)(param_9 + 2) + 1,(ulong)uVar2);
        uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
        if ((uVar2 & 7) == 0) {
          *(undefined *)(*(long *)(param_9 + 2) + 5) = 0;
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 6));
        }
        else {
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 5));
        }
        *param_9 = 2;
        goto LAB_00119794;
      }
      uVar2 = _libssh2_error(param_1,0xfffffffa,"Out of memory error");
    }
  }
  else {
LAB_00119794:
    if (*param_9 == 2) {
      local_a0 = _libssh2_transport_send
                           (param_1,*(undefined8 *)(param_9 + 2),*(undefined8 *)(param_9 + 0x1a),0,0
                           );
      if (local_a0 == 0xffffffdb) {
        uVar7 = 0xffffffdb;
        goto LAB_0011b883;
      }
      if (local_a0 != 0) {
        uVar2 = _libssh2_error(param_1,(ulong)local_a0,"Unable to send KEX init message",
                               (ulong)local_a0);
        goto LAB_0011b6e6;
      }
      *param_9 = 3;
    }
    if (*param_9 == 3) {
      if ((*(byte *)(param_1 + 0x80) & 1) != 0) {
        local_9c = _libssh2_packet_burn(param_1,param_9 + 0x3c);
        if (local_9c == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          goto LAB_0011b883;
        }
        uVar2 = local_9c;
        if ((int)local_9c < 1) goto LAB_0011b6e6;
        *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
      }
      *param_9 = 4;
    }
    if (*param_9 == 4) {
      local_a0 = _libssh2_packet_require
                           (param_1,(ulong)param_6,param_9 + 4,param_9 + 0x1c,0,0,0,param_9 + 0x38);
      if (local_a0 == 0xffffffdb) {
        uVar7 = 0xffffffdb;
        goto LAB_0011b883;
      }
      if (local_a0 == 0) {
        if (*(ulong *)(param_9 + 0x1c) < 5) {
          uVar2 = _libssh2_error(param_1,0xfffffff2,"Unexpected packet length");
        }
        else {
          local_28 = &local_90;
          local_18 = *(undefined8 *)(param_9 + 0x1c);
          local_20 = (long)&local_28->digest + 1;
          if (*(long *)(param_1 + 0xb0) != 0) {
            ((void*(*)())(param_1 + 0x18))
                      (*(undefined8 *)(param_1 + 0xb0),param_1,*(undefined8 *)(param_1 + 0xb0),
                       param_1);
          }
          iVar3 = _libssh2_copy_string(param_1,&local_28,param_1 + 0xb0,local_98);
          if (iVar3 == 0) {
            *(int *)(param_1 + 0xb8) = local_98[0];
            iVar3 = _libssh2_md5_init(&local_90);
            if (iVar3 == 0) {
              *(undefined4 *)(param_1 + 0xcc) = 0;
            }
            else {
              EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_1 + 0xbc),(uint *)0x0);
              EVP_MD_CTX_free(local_90.digest);
              *(undefined4 *)(param_1 + 0xcc) = 1;
            }
            iVar3 = _libssh2_sha1_init(&local_90);
            if (iVar3 == 0) {
              *(undefined4 *)(param_1 + 0xe4) = 0;
            }
            else {
              EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_1 + 0xd0),(uint *)0x0);
              EVP_MD_CTX_free(local_90.digest);
              *(undefined4 *)(param_1 + 0xe4) = 1;
            }
            iVar3 = _libssh2_sha256_init(&local_90);
            if (iVar3 == 0) {
              *(undefined4 *)(param_1 + 0x108) = 0;
            }
            else {
              EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_1 + 0xe8),(uint *)0x0);
              EVP_MD_CTX_free(local_90.digest);
              *(undefined4 *)(param_1 + 0x108) = 1;
            }
            iVar3 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x10))
                              (param_1,*(undefined8 *)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8),param_1 + 0xa8);
            if (iVar3 == 0) {
              iVar3 = _libssh2_get_string(&local_28,param_9 + 0x2a,param_9 + 0x30, param_9);
              if (iVar3 == 0) {
                BN_bin2bn(*(uchar **)(param_9 + 0x2a),(int)*(undefined8 *)(param_9 + 0x30),
                          *(BIGNUM **)(param_9 + 0x26));
                iVar3 = _libssh2_get_string(&local_28,param_9 + 0x2e,param_9 + 0x34,param_9 + 0x2e);
                if (iVar3 == 0) {
                  _libssh2_dh_secret(param_9 + 0x22,*(undefined8 *)(param_9 + 0x28),
                                     *(undefined8 *)(param_9 + 0x26),param_3,
                                     *(undefined8 *)(param_9 + 0x20));
                  iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
                  iVar3 = iVar1 + 7;
                  if (iVar1 + 7 < 0) {
                    iVar3 = iVar1 + 0xe;
                  }
                  *(long *)(param_9 + 0x32) = (long)((iVar3 >> 3) + 5);
                  uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
                  if ((uVar2 & 7) != 0) {
                    *(long *)(param_9 + 0x32) = *(long *)(param_9 + 0x32) + -1;
                  }
                  uVar6 = ((void*(*)())(param_1 + 8))
                                    (*(undefined8 *)(param_9 + 0x32),param_1,
                                     *(undefined8 *)(param_9 + 0x32),param_1);
                  *(undefined8 *)(param_9 + 0x2c) = uVar6;
                  if (*(long *)(param_9 + 0x2c) == 0) {
                    uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
                  }
                  else {
                    uVar2 = (int)*(undefined8 *)(param_9 + 0x32) - 4;
                    _libssh2_htonu32(*(undefined8 *)(param_9 + 0x2c),(ulong)uVar2);
                    uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
                    if ((uVar2 & 7) == 0) {
                      *(undefined *)(*(long *)(param_9 + 0x2c) + 4) = 0;
                      BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),
                                (uchar *)(*(long *)(param_9 + 0x2c) + 5));
                    }
                    else {
                      BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),
                                (uchar *)(*(long *)(param_9 + 0x2c) + 4));
                    }
                    *(EVP_MD_CTX **)(param_9 + 0x36) = &local_90;
                    _libssh2_sha1_init(&local_90);
                    if (*(long *)(param_1 + 0x180) == 0) {
                      _libssh2_htonu32(param_9 + 8,0x19);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,"SSH-2.0-libssh2_1.9.0_DEV",
                                       0x19);
                    }
                    else {
                      cnt = strlen(*(char **)(param_1 + 0x180));
                      uVar2 = (int)cnt - 2;
                      _libssh2_htonu32(param_9 + 8,(ulong)uVar2);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                      cnt = strlen(*(char **)(param_1 + 0x180));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x180),
                                       cnt - 2);
                    }
                    cnt = strlen(*(char **)(param_1 + 0x110));
                    _libssh2_htonu32(param_9 + 8,cnt & 0xffffffff);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    cnt = strlen(*(char **)(param_1 + 0x110));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x110),cnt);
                    uVar7 = *(ulong *)(param_1 + 400) & 0xffffffff;
                    _libssh2_htonu32(param_9 + 8,uVar7);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x188),
                                     *(size_t *)(param_1 + 400));
                    uVar7 = *(ulong *)(param_1 + 0x120) & 0xffffffff;
                    _libssh2_htonu32(param_9 + 8,uVar7);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x118),
                                     *(size_t *)(param_1 + 0x120));
                    _libssh2_htonu32(param_9 + 8,(ulong)*(uint *)(param_1 + 0xb8));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                                     (ulong)*(uint *)(param_1 + 0xb8));
                    if (param_5 == ' ') {
                      _libssh2_htonu32(param_9 + 8,0);
                      _libssh2_htonu32(param_9 + 9,0);
                      _libssh2_htonu32(param_9 + 10,0);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,0xc);
                    }
                    if (param_7 != (void *)0x0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_7,param_8);
                    }
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,
                                     (void *)(*(long *)(param_9 + 2) + 1),
                                     *(long *)(param_9 + 0x1a) - 1);
                    _libssh2_htonu32(param_9 + 8,*(ulong *)(param_9 + 0x30) & 0xffffffff);

                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_9 + 0x2a),
                                     *(size_t *)(param_9 + 0x30));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_9 + 0x2c),
                                     *(size_t *)(param_9 + 0x32));
                    EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_9 + 8),(uint *)0x0
                                   );
                    EVP_MD_CTX_free(local_90.digest);
                    iVar3 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x28))
                                      (param_1,*(undefined8 *)(param_9 + 0x2e),
                                       *(undefined8 *)(param_9 + 0x34),param_9 + 8,0x14,
                                       param_1 + 0xa8);
                    if (iVar3 == 0) {
                      *(undefined *)(param_9 + 0x18) = 0x15;
                      *param_9 = 5;
                      goto LAB_0011a4d4;
                    }
                    uVar2 = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
                  }
                }
                else {
                  uVar2 = _libssh2_error(param_1,0xfffffff6,"Unable to get h sig");
                }
              }
              else {
                uVar2 = _libssh2_error(param_1,0xfffffff6,"Unable to get f value");
              }
            }
            else {
              uVar2 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
            }
          }
          else {
            uVar2 = _libssh2_error(param_1,0xfffffffa,"Could not copy host key");
          }
        }
      }
      else {
        uVar2 = _libssh2_error(param_1,0xfffffff7,"Timed out waiting for KEX reply");
      }
    }
    else {
LAB_0011a4d4:
      if (*param_9 == 5) {
        local_a0 = _libssh2_transport_send(param_1,param_9 + 0x18,1,0,0);
        if (local_a0 == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          goto LAB_0011b883;
        }
        if (local_a0 != 0) {
          uVar2 = _libssh2_error(param_1,(ulong)local_a0,"Unable to send NEWKEYS message",
                                 (ulong)local_a0);
          goto LAB_0011b6e6;
        }
        *param_9 = 6;
      }
      uVar2 = local_a4;
      if (*param_9 == 6) {
        local_a0 = _libssh2_packet_require
                             (param_1,0x15,param_9 + 6,param_9 + 0x1e,0,0,0,param_9 + 0x38);
        if (local_a0 == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          goto LAB_0011b883;
        }
        if (local_a0 == 0) {
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_9 + 6),param_1,*(undefined8 *)(param_9 + 6),param_1);
          if (*(long *)(param_1 + 0x88) == 0) {
            uVar6 = ((void*(*)())(param_1 + 8))(0x14,param_1,param_1);
            *(undefined8 *)(param_1 + 0x88) = uVar6;
            if (*(long *)(param_1 + 0x88) == 0) {
              uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest");
              goto LAB_0011b6e6;
            }
            memcpy(*(void **)(param_1 + 0x88),param_9 + 8,0x14);
            *(undefined4 *)(param_1 + 0x90) = 0x14;
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
            ((void*(*)())(*(long *)(param_1 + 0x198) + 0x38))
                      (param_1,param_1 + 0x1a0,param_1,param_1 + 0x1a0);
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_0011abc9:
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
              ((void*(*)())(*(long *)(param_1 + 0x128) + 0x38))
                        (param_1,param_1 + 0x130,param_1,param_1 + 0x130);
            }
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_0011b08b:
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
                ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x20))
                          (param_1,param_1 + 0x1b8,param_1,param_1 + 0x1b8);
              }
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
                local_48 = (void *)0x0;
                local_98[0] = 0;
                local_40 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) + 0x14);
                local_48 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_48 != (void *)0x0) {
                  while (local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc)) {
                    _libssh2_sha1_init(&local_28);
                    EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32)
                                    );
                    EVP_DigestUpdate(local_28,param_9 + 8,0x14);
                    if (local_40 == 0) {
                      EVP_DigestUpdate(local_28,&DAT_00146ad9,1);
                      EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_28,local_48,local_40);
                    }
                    EVP_DigestFinal(local_28,(uchar *)((long)local_48 + local_40),(uint *)0x0);
                    EVP_MD_CTX_free(local_28);
                    local_40 = local_40 + 0x14;
                  }
                }
                if (local_48 == (void *)0x0) {
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                  goto LAB_0011b6e6;
                }
                ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x10))
                          (param_1,local_48,local_98,param_1 + 0x1b8);
                if (local_98[0] != 0) {
                  lVar8 = (long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                  _libssh2_explicit_zero(local_48,lVar8);
                  ((void*(*)())(param_1 + 0x18))(local_48,param_1,local_48,param_1);
                }
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
                ((void*(*)())(*(long *)(param_1 + 0x138) + 0x20))
                          (param_1,param_1 + 0x148,param_1,param_1 + 0x148);
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
                local_38 = (void *)0x0;
                local_98[0] = 0;
                local_30 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) + 0x14);
                local_38 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_38 != (void *)0x0) {
                  while (local_30 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc)) {
                    _libssh2_sha1_init(&local_28);
                    EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32)
                                    );
                    EVP_DigestUpdate(local_28,param_9 + 8,0x14);
                    if (local_30 == 0) {
                      EVP_DigestUpdate(local_28,&DAT_00146adb,1);
                      EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_28,local_38,local_30);
                    }
                    EVP_DigestFinal(local_28,(uchar *)((long)local_38 + local_30),(uint *)0x0);
                    EVP_MD_CTX_free(local_28);
                    local_30 = local_30 + 0x14;
                  }
                }
                if (local_38 == (void *)0x0) {
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                  goto LAB_0011b6e6;
                }
                ((void*(*)())(*(long *)(param_1 + 0x138) + 0x10))
                          (param_1,local_38,local_98,param_1 + 0x148);
                if (local_98[0] != 0) {
                  lVar8 = (long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                  _libssh2_explicit_zero(local_38,lVar8);
                  ((void*(*)())(param_1 + 0x18))(local_38,param_1,local_38,param_1);
                }
              }
              if ((*(long *)(param_1 + 0x1c0) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
                ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8,param_1);
              }
              if (((*(long *)(param_1 + 0x1c0) == 0) ||
                  (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
                 (iVar3 = ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x10))
                                    (param_1,1,param_1 + 0x1c8,param_1), iVar3 == 0)) {
                if ((*(long *)(param_1 + 0x150) != 0) &&
                   (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                  ((void*(*)())(*(long *)(param_1 + 0x150) + 0x28))
                            (param_1,0,param_1 + 0x158,param_1);
                }
                uVar2 = local_a4;
                if (((*(long *)(param_1 + 0x150) != 0) &&
                    (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                   (iVar3 = ((void*(*)())(*(long *)(param_1 + 0x150) + 0x10))
                                      (param_1,0,param_1 + 0x158,param_1), uVar2 = local_a4,
                   iVar3 != 0)) {
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                }
              }
              else {
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
            }
            else {
              local_60 = (void *)0x0;
              local_a8 = 0;
              local_98[0] = 0;
              local_58 = 0;
              lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) + 0x14);

              if (local_90.update != 0x0) {
                while (local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14)) {
                  _libssh2_sha1_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
                  EVP_DigestUpdate(local_28,param_9 + 8,0x14);
                  if (local_58 == 0) {
                    EVP_DigestUpdate(local_28,&DAT_00146ad5,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_90.update,local_58);
                  }
                  EVP_DigestFinal(local_28,(uchar *)(local_90.update + local_58),(uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_58 = local_58 + 0x14;
                }
              }
              if (local_90.update == 0x0) {
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
              else {
                local_50 = 0;
                if (local_60 == (void *)0x0) {
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) + 0x14);
                  local_60 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                }
                if (local_60 != (void *)0x0) {
                  while (local_50 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18)) {
                    _libssh2_sha1_init(&local_28);
                    EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32)
                                    );
                    EVP_DigestUpdate(local_28,param_9 + 8,0x14);
                    if (local_50 == 0) {
                      EVP_DigestUpdate(local_28,&DAT_00146ad7,1);
                      EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_28,local_60,local_50);
                    }
                    EVP_DigestFinal(local_28,(uchar *)((long)local_60 + local_50),(uint *)0x0);
                    EVP_MD_CTX_free(local_28);
                    local_50 = local_50 + 0x14;
                  }
                }
                if (local_60 == (void *)0x0) {
                  ((void*(*)())(param_1 + 0x18))(local_90.update,param_1,local_90.update,param_1);
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                }
                else {
                  iVar3 = ((void*(*)())(*(long *)(param_1 + 0x128) + 0x28))
                                    (param_1,*(undefined8 *)(param_1 + 0x128),local_90.update,
                                     &local_a8,local_60,local_98,0,param_1 + 0x130);
                  if (iVar3 == 0) {
                    if (local_a8 != 0) {
                      lVar8 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                      _libssh2_explicit_zero(local_90.update,lVar8);
                      ((void*(*)())(param_1 + 0x18))(local_90.update,param_1,local_90.update,param_1)
                      ;
                    }
                    if (local_98[0] != 0) {
                      lVar8 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      _libssh2_explicit_zero(local_60,lVar8);
                      ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
                    }
                    goto LAB_0011b08b;
                  }
                  ((void*(*)())(param_1 + 0x18))(local_90.update,param_1,local_90.update,param_1);
                  ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                }
              }
            }
          }
          else {
            local_90.engine = (ENGINE *)0x0;
            local_90.flags = (void *)0x0;
            local_a8 = 0;
            local_98[0] = 0;
            local_90.md_data = (void *)0x0;
            lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x14);
            local_90.engine = (ENGINE *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
            if (local_90.engine != (ENGINE *)0x0) {
              while (local_90.md_data < (void *)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14)) {
                _libssh2_sha1_init(&local_28);
                EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
                EVP_DigestUpdate(local_28,param_9 + 8,0x14);
                if (local_90.md_data == (void *)0x0) {
                  EVP_DigestUpdate(local_28,&DAT_00146ad1,1);
                  EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_28,local_90.engine,(size_t)local_90.md_data);
                }
                EVP_DigestFinal(local_28,(uchar *)(local_90.engine + (long)local_90.md_data),
                                (uint *)0x0);
                EVP_MD_CTX_free(local_28);
                local_90.md_data = (void *)((long)local_90.md_data + 0x14);
              }
            }
            if (local_90.engine == (ENGINE *)0x0) {
              local_a4 = 0xffffffff;
              uVar2 = local_a4;
            }
            else {
              local_90.pctx = (EVP_PKEY_CTX *)0x0;
              if (local_90.flags == (void *)0x0) {
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) + 0x14);
                local_90.flags = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
              }
              if (local_90.flags != (void *)0x0) {
                while (local_90.pctx <
                       (EVP_PKEY_CTX *)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18)) {
                  _libssh2_sha1_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
                  EVP_DigestUpdate(local_28,param_9 + 8,0x14);
                  if (local_90.pctx == (EVP_PKEY_CTX *)0x0) {
                    EVP_DigestUpdate(local_28,&DAT_00146ad3,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_90.flags,(size_t)local_90.pctx);
                  }
                  EVP_DigestFinal(local_28,(uchar *)((long)local_90.flags + (long)local_90.pctx),
                                  (uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_90.pctx = local_90.pctx + 0x14;
                }
              }
              if (local_90.flags == (void *)0x0) {
                ((void*(*)())(param_1 + 0x18))(local_90.engine,param_1,local_90.engine,param_1);
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
              else {
                iVar3 = ((void*(*)())(*(long *)(param_1 + 0x198) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x198),local_90.engine,
                                   &local_a8,local_90.flags,local_98,1,param_1 + 0x1a0);
                if (iVar3 == 0) {
                  if (local_a8 != 0) {
                    lVar8 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                    _libssh2_explicit_zero(local_90.engine,lVar8);
                    ((void*(*)())(param_1 + 0x18))(local_90.engine,param_1,local_90.engine,param_1);
                  }
                  if (local_98[0] != 0) {
                    lVar8 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    _libssh2_explicit_zero(local_90.flags,lVar8);
                    ((void*(*)())(param_1 + 0x18))(local_90.flags,param_1,local_90.flags,param_1);
                  }
                  goto LAB_0011abc9;
                }
                ((void*(*)())(param_1 + 0x18))(local_90.engine,param_1,local_90.engine,param_1);
                ((void*(*)())(param_1 + 0x18))(local_90.flags,param_1,local_90.flags,param_1);
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
            }
          }
        }
        else {
          uVar2 = _libssh2_error(param_1,(ulong)local_a0,"Timed out waiting for NEWKEYS",
                                 (ulong)local_a0);
        }
      }
    }
  }
LAB_0011b6e6:
  local_a4 = uVar2;
  _libssh2_dh_dtor(param_9 + 0x22);
  BN_clear_free(*(BIGNUM **)(param_9 + 0x24));
  *(undefined8 *)(param_9 + 0x24) = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x26));
  *(undefined8 *)(param_9 + 0x26) = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x28));
  *(undefined8 *)(param_9 + 0x28) = 0;
  BN_CTX_free(*(BN_CTX **)(param_9 + 0x20));
  *(undefined8 *)(param_9 + 0x20) = 0;
  if (*(long *)(param_9 + 2) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_9 + 2),param_1,*(undefined8 *)(param_9 + 2),param_1);
    *(undefined8 *)(param_9 + 2) = 0;
  }
  if (*(long *)(param_9 + 4) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_9 + 4),param_1,*(undefined8 *)(param_9 + 4),param_1);
    *(undefined8 *)(param_9 + 4) = 0;
  }
  if (*(long *)(param_9 + 0x2c) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_9 + 0x2c),param_1,*(undefined8 *)(param_9 + 0x2c),param_1);
    *(undefined8 *)(param_9 + 0x2c) = 0;
  }
  *param_9 = 0;
  uVar7 = (ulong)local_a4;
LAB_0011b883:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar7;
}



ulong FUN_0011b899(long param_1,undefined8 param_2,undefined8 param_3,uint param_4,char param_5,
                  byte param_6,void *param_7,size_t param_8,int *param_9)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  BN_CTX *pBVar4;
  BIGNUM *pBVar5;
  undefined8 uVar6;
  ulong uVar7;
  size_t cnt;
  long lVar8;
  long in_FS_OFFSET;
  int local_a8;
  uint local_a4;
  uint local_a0;
  uint local_9c;
  int local_98 [2];
  struct env_md_ctx_st  local_90;
  void *local_60;
  ulong local_58;
  ulong local_50;
  void *local_48;
  ulong local_40;
  void *local_38;
  ulong local_30;
  struct env_md_ctx_st  *local_28;
  long local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_a4 = 0;
  if (*param_9 == 0) {
    *(undefined8 *)(param_9 + 2) = 0;
    *(undefined8 *)(param_9 + 4) = 0;
    *(undefined8 *)(param_9 + 0x2c) = 0;
    pBVar4 = BN_CTX_new();
    *(BN_CTX **)(param_9 + 0x20) = pBVar4;
    _libssh2_dh_init(param_9 + 0x22);
    pBVar5 = BN_new();
    *(BIGNUM **)(param_9 + 0x24) = pBVar5;
    pBVar5 = BN_new();
    *(BIGNUM **)(param_9 + 0x26) = pBVar5;
    pBVar5 = BN_new();
    *(BIGNUM **)(param_9 + 0x28) = pBVar5;
    memset(param_9 + 0x38,0,0x10);
    local_a0 = _libssh2_dh_key_pair
                         (param_9 + 0x22,*(undefined8 *)(param_9 + 0x24),param_2,param_3,
                          (ulong)param_4,*(undefined8 *)(param_9 + 0x20));
    uVar2 = local_a4;
    if (local_a0 == 0) {
      iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      iVar3 = iVar1 + 7;
      if (iVar1 + 7 < 0) {
        iVar3 = iVar1 + 0xe;
      }
      *(long *)(param_9 + 0x1a) = (long)((iVar3 >> 3) + 6);
      uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      if ((uVar2 & 7) != 0) {
        *(long *)(param_9 + 0x1a) = *(long *)(param_9 + 0x1a) + -1;
      }
      uVar6 = ((void*(*)())(param_1 + 8))
                        (*(undefined8 *)(param_9 + 0x1a),param_1,*(undefined8 *)(param_9 + 0x1a),
                         param_1);
      *(undefined8 *)(param_9 + 2) = uVar6;
      if (*(long *)(param_9 + 2) != 0) {
        **(char **)(param_9 + 2) = param_5;
        uVar2 = (int)*(undefined8 *)(param_9 + 0x1a) - 5;
        _libssh2_htonu32(*(long *)(param_9 + 2) + 1,(ulong)uVar2);
        uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
        if ((uVar2 & 7) == 0) {
          *(undefined *)(*(long *)(param_9 + 2) + 5) = 0;
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 6));
        }
        else {
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 5));
        }
        *param_9 = 2;
        goto LAB_0011bbcc;
      }
      uVar2 = _libssh2_error(param_1,0xfffffffa,"Out of memory error");
    }
  }
  else {
LAB_0011bbcc:
    if (*param_9 == 2) {
      local_a0 = _libssh2_transport_send
                           (param_1,*(undefined8 *)(param_9 + 2),*(undefined8 *)(param_9 + 0x1a),0,0
                           );
      if (local_a0 == 0xffffffdb) {
        uVar7 = 0xffffffdb;
        goto LAB_0011dcbb;
      }
      if (local_a0 != 0) {
        uVar2 = _libssh2_error(param_1,(ulong)local_a0,"Unable to send KEX init message",
                               (ulong)local_a0);
        goto LAB_0011db1e;
      }
      *param_9 = 3;
    }
    if (*param_9 == 3) {
      if ((*(byte *)(param_1 + 0x80) & 1) != 0) {
        local_9c = _libssh2_packet_burn(param_1,param_9 + 0x3c);
        if (local_9c == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          goto LAB_0011dcbb;
        }
        uVar2 = local_9c;
        if ((int)local_9c < 1) goto LAB_0011db1e;
        *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
      }
      *param_9 = 4;
    }
    if (*param_9 == 4) {
      local_a0 = _libssh2_packet_require
                           (param_1,(ulong)param_6,param_9 + 4,param_9 + 0x1c,0,0,0,param_9 + 0x38);
      if (local_a0 == 0xffffffdb) {
        uVar7 = 0xffffffdb;
        goto LAB_0011dcbb;
      }
      if (local_a0 == 0) {
        if (*(ulong *)(param_9 + 0x1c) < 5) {
          uVar2 = _libssh2_error(param_1,0xfffffff2,"Unexpected packet length");
        }
        else {
          local_28 = *(EVP_MD_CTX **)(param_9 + 4);
          local_18 = *(undefined8 *)(param_9 + 0x1c);
          local_20 = (long)&local_28->digest + 1;
          if (*(long *)(param_1 + 0xb0) != 0) {
            ((void*(*)())(param_1 + 0x18))
                      (*(undefined8 *)(param_1 + 0xb0),param_1,*(undefined8 *)(param_1 + 0xb0),
                       param_1);
          }
          iVar3 = _libssh2_copy_string(param_1,&local_28,param_1 + 0xb0,local_98);
          if (iVar3 == 0) {
            *(int *)(param_1 + 0xb8) = local_98[0];
            iVar3 = _libssh2_md5_init(&local_90);
            if (iVar3 == 0) {
              *(undefined4 *)(param_1 + 0xcc) = 0;
            }
            else {
              EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_1 + 0xbc),(uint *)0x0);
              EVP_MD_CTX_free(local_90.digest);
              *(undefined4 *)(param_1 + 0xcc) = 1;
            }
            iVar3 = _libssh2_sha1_init(&local_90);
            if (iVar3 == 0) {
              *(undefined4 *)(param_1 + 0xe4) = 0;
            }
            else {
              EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_1 + 0xd0),(uint *)0x0);
              EVP_MD_CTX_free(local_90.digest);
              *(undefined4 *)(param_1 + 0xe4) = 1;
            }
            iVar3 = _libssh2_sha256_init(&local_90);
            if (iVar3 == 0) {
              *(undefined4 *)(param_1 + 0x108) = 0;
            }
            else {
              EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_1 + 0xe8),(uint *)0x0);
              EVP_MD_CTX_free(local_90.digest);
              *(undefined4 *)(param_1 + 0x108) = 1;
            }
            iVar3 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x10))
                              (param_1,*(undefined8 *)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8),param_1 + 0xa8);
            if (iVar3 == 0) {

              if (iVar3 == 0) {
                BN_bin2bn(*(uchar **)(param_9 + 0x2a),(int)*(undefined8 *)(param_9 + 0x30),
                          *(BIGNUM **)(param_9 + 0x26));
                iVar3 = _libssh2_get_string(&local_28,param_9 + 0x2e,param_9 + 0x34,param_9 + 0x2e);
                if (iVar3 == 0) {
                  _libssh2_dh_secret(param_9 + 0x22,*(undefined8 *)(param_9 + 0x28),
                                     *(undefined8 *)(param_9 + 0x26),param_3,
                                     *(undefined8 *)(param_9 + 0x20));
                  iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
                  iVar3 = iVar1 + 7;
                  if (iVar1 + 7 < 0) {
                    iVar3 = iVar1 + 0xe;
                  }
                  *(long *)(param_9 + 0x32) = (long)((iVar3 >> 3) + 5);
                  uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
                  if ((uVar2 & 7) != 0) {
                    *(long *)(param_9 + 0x32) = *(long *)(param_9 + 0x32) + -1;
                  }
                  uVar6 = ((void*(*)())(param_1 + 8))
                                    (*(undefined8 *)(param_9 + 0x32),param_1,
                                     *(undefined8 *)(param_9 + 0x32),param_1);
                  *(undefined8 *)(param_9 + 0x2c) = uVar6;
                  if (*(long *)(param_9 + 0x2c) == 0) {
                    uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
                  }
                  else {
                    uVar2 = (int)*(undefined8 *)(param_9 + 0x32) - 4;
                    _libssh2_htonu32(*(undefined8 *)(param_9 + 0x2c),(ulong)uVar2);
                    uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
                    if ((uVar2 & 7) == 0) {
                      *(undefined *)(*(long *)(param_9 + 0x2c) + 4) = 0;
                      BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),
                                (uchar *)(*(long *)(param_9 + 0x2c) + 5));
                    }
                    else {
                      BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),
                                (uchar *)(*(long *)(param_9 + 0x2c) + 4));
                    }
                    *(EVP_MD_CTX **)(param_9 + 0x36) = &local_90;
                    _libssh2_sha256_init(&local_90);
                    if (*(long *)(param_1 + 0x180) == 0) {
                      _libssh2_htonu32(param_9 + 8,0x19);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,"SSH-2.0-libssh2_1.9.0_DEV",
                                       0x19);
                    }
                    else {
                      cnt = strlen(*(char **)(param_1 + 0x180));
                      uVar2 = (int)cnt - 2;
                      _libssh2_htonu32(param_9 + 8,(ulong)uVar2);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                      cnt = strlen(*(char **)(param_1 + 0x180));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x180),
                                       cnt - 2);
                    }
                    cnt = strlen(*(char **)(param_1 + 0x110));
                    _libssh2_htonu32(param_9 + 8,cnt & 0xffffffff);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    cnt = strlen(*(char **)(param_1 + 0x110));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x110),cnt);
                    uVar7 = *(ulong *)(param_1 + 400) & 0xffffffff;
                    _libssh2_htonu32(param_9 + 8,uVar7);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x188),
                                     *(size_t *)(param_1 + 400));
                    uVar7 = *(ulong *)(param_1 + 0x120) & 0xffffffff;
                    _libssh2_htonu32(param_9 + 8,uVar7);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0x118),
                                     *(size_t *)(param_1 + 0x120));
                    _libssh2_htonu32(param_9 + 8,(ulong)*(uint *)(param_1 + 0xb8));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_1 + 0xb0),
                                     (ulong)*(uint *)(param_1 + 0xb8));
                    if (param_5 == ' ') {
                      _libssh2_htonu32(param_9 + 8,0x400);
                      _libssh2_htonu32(param_9 + 9,0x600);
                      _libssh2_htonu32(param_9 + 10,0x800);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,0xc);
                    }
                    if (param_7 != (void *)0x0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_7,param_8);
                    }
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,
                                     (void *)(*(long *)(param_9 + 2) + 1),
                                     *(long *)(param_9 + 0x1a) - 1);
                    _libssh2_htonu32(param_9 + 8,*(ulong *)(param_9 + 0x30) & 0xffffffff);

                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,param_9 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_9 + 0x2a),
                                     *(size_t *)(param_9 + 0x30));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_90.digest,*(void **)(param_9 + 0x2c),
                                     *(size_t *)(param_9 + 0x32));
                    EVP_DigestFinal((EVP_MD_CTX *)local_90.digest,(uchar *)(param_9 + 8),(uint *)0x0
                                   );
                    EVP_MD_CTX_free(local_90.digest);
                    iVar3 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x28))
                                      (param_1,*(undefined8 *)(param_9 + 0x2e),
                                       *(undefined8 *)(param_9 + 0x34),param_9 + 8,0x20,
                                       param_1 + 0xa8);
                    if (iVar3 == 0) {
                      *(undefined *)(param_9 + 0x18) = 0x15;
                      *param_9 = 5;
                      goto LAB_0011c90c;
                    }
                    uVar2 = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
                  }
                }
                else {
                  uVar2 = _libssh2_error(param_1,0xfffffff6,"Unable to get h sig");
                }
              }
              else {
                uVar2 = _libssh2_error(param_1,0xfffffff6,"Unable to get f value");
              }
            }
            else {
              uVar2 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
            }
          }
          else {
            uVar2 = _libssh2_error(param_1,0xfffffffa,"Could not copy host key");
          }
        }
      }
      else {
        uVar2 = _libssh2_error(param_1,0xfffffff7,"Timed out waiting for KEX reply");
      }
    }
    else {
LAB_0011c90c:
      if (*param_9 == 5) {
        local_a0 = _libssh2_transport_send(param_1,param_9 + 0x18,1,0,0);
        if (local_a0 == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          goto LAB_0011dcbb;
        }
        if (local_a0 != 0) {
          uVar2 = _libssh2_error(param_1,(ulong)local_a0,"Unable to send NEWKEYS message",
                                 (ulong)local_a0);
          goto LAB_0011db1e;
        }
        *param_9 = 6;
      }
      uVar2 = local_a4;
      if (*param_9 == 6) {
        local_a0 = _libssh2_packet_require
                             (param_1,0x15,param_9 + 6,param_9 + 0x1e,0,0,0,param_9 + 0x38);
        if (local_a0 == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          goto LAB_0011dcbb;
        }
        if (local_a0 == 0) {
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_9 + 6),param_1,*(undefined8 *)(param_9 + 6),param_1);
          if (*(long *)(param_1 + 0x88) == 0) {
            uVar6 = ((void*(*)())(param_1 + 8))(0x20,param_1,param_1);
            *(undefined8 *)(param_1 + 0x88) = uVar6;
            if (*(long *)(param_1 + 0x88) == 0) {
              uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest");
              goto LAB_0011db1e;
            }
            memcpy(*(void **)(param_1 + 0x88),param_9 + 8,0x20);
            *(undefined4 *)(param_1 + 0x90) = 0x20;
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
            ((void*(*)())(*(long *)(param_1 + 0x198) + 0x38))
                      (param_1,param_1 + 0x1a0,param_1,param_1 + 0x1a0);
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_0011d001:
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
              ((void*(*)())(*(long *)(param_1 + 0x128) + 0x38))
                        (param_1,param_1 + 0x130,param_1,param_1 + 0x130);
            }
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_0011d4c3:
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
                ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x20))
                          (param_1,param_1 + 0x1b8,param_1,param_1 + 0x1b8);
              }
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
                local_48 = (void *)0x0;
                local_98[0] = 0;
                local_40 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) + 0x20);
                local_48 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_48 != (void *)0x0) {
                  while (local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc)) {
                    _libssh2_sha256_init(&local_28);
                    EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32)
                                    );
                    EVP_DigestUpdate(local_28,param_9 + 8,0x20);
                    if (local_40 == 0) {
                      EVP_DigestUpdate(local_28,&DAT_00146ad9,1);
                      EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_28,local_48,local_40);
                    }
                    EVP_DigestFinal(local_28,(uchar *)((long)local_48 + local_40),(uint *)0x0);
                    EVP_MD_CTX_free(local_28);
                    local_40 = local_40 + 0x20;
                  }
                }
                if (local_48 == (void *)0x0) {
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                  goto LAB_0011db1e;
                }
                ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x10))
                          (param_1,local_48,local_98,param_1 + 0x1b8);
                if (local_98[0] != 0) {
                  lVar8 = (long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                  _libssh2_explicit_zero(local_48,lVar8);
                  ((void*(*)())(param_1 + 0x18))(local_48,param_1,local_48,param_1);
                }
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
                ((void*(*)())(*(long *)(param_1 + 0x138) + 0x20))
                          (param_1,param_1 + 0x148,param_1,param_1 + 0x148);
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
                local_38 = (void *)0x0;
                local_98[0] = 0;
                local_30 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) + 0x20);
                local_38 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_38 != (void *)0x0) {
                  while (local_30 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc)) {
                    _libssh2_sha256_init(&local_28);
                    EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32)
                                    );
                    EVP_DigestUpdate(local_28,param_9 + 8,0x20);
                    if (local_30 == 0) {
                      EVP_DigestUpdate(local_28,&DAT_00146adb,1);
                      EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_28,local_38,local_30);
                    }
                    EVP_DigestFinal(local_28,(uchar *)((long)local_38 + local_30),(uint *)0x0);
                    EVP_MD_CTX_free(local_28);
                    local_30 = local_30 + 0x20;
                  }
                }
                if (local_38 == (void *)0x0) {
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                  goto LAB_0011db1e;
                }
                ((void*(*)())(*(long *)(param_1 + 0x138) + 0x10))
                          (param_1,local_38,local_98,param_1 + 0x148);
                if (local_98[0] != 0) {
                  lVar8 = (long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                  _libssh2_explicit_zero(local_38,lVar8);
                  ((void*(*)())(param_1 + 0x18))(local_38,param_1,local_38,param_1);
                }
              }
              if ((*(long *)(param_1 + 0x1c0) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
                ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8,param_1);
              }
              if (((*(long *)(param_1 + 0x1c0) == 0) ||
                  (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
                 (iVar3 = ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x10))
                                    (param_1,1,param_1 + 0x1c8,param_1), iVar3 == 0)) {
                if ((*(long *)(param_1 + 0x150) != 0) &&
                   (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                  ((void*(*)())(*(long *)(param_1 + 0x150) + 0x28))
                            (param_1,0,param_1 + 0x158,param_1);
                }
                uVar2 = local_a4;
                if (((*(long *)(param_1 + 0x150) != 0) &&
                    (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                   (iVar3 = ((void*(*)())(*(long *)(param_1 + 0x150) + 0x10))
                                      (param_1,0,param_1 + 0x158,param_1), uVar2 = local_a4,
                   iVar3 != 0)) {
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                }
              }
              else {
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
            }
            else {
              local_90.update = 0x0;
              local_60 = (void *)0x0;
              local_a8 = 0;
              local_98[0] = 0;
              local_58 = 0;
              lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) + 0x20);

              if (local_90.update != 0x0) {
                while (local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14)) {
                  _libssh2_sha256_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
                  EVP_DigestUpdate(local_28,param_9 + 8,0x20);
                  if (local_58 == 0) {
                    EVP_DigestUpdate(local_28,&DAT_00146ad5,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_90.update,local_58);
                  }
                  EVP_DigestFinal(local_28,(uchar *)(local_90.update + local_58),(uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_58 = local_58 + 0x20;
                }
              }
              if (local_90.update == 0x0) {
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
              else {
                local_50 = 0;
                if (local_60 == (void *)0x0) {
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) + 0x20);
                  local_60 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                }
                if (local_60 != (void *)0x0) {
                  while (local_50 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18)) {
                    _libssh2_sha256_init(&local_28);
                    EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32)
                                    );
                    EVP_DigestUpdate(local_28,param_9 + 8,0x20);
                    if (local_50 == 0) {
                      EVP_DigestUpdate(local_28,&DAT_00146ad7,1);
                      EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_28,local_60,local_50);
                    }
                    EVP_DigestFinal(local_28,(uchar *)((long)local_60 + local_50),(uint *)0x0);
                    EVP_MD_CTX_free(local_28);
                    local_50 = local_50 + 0x20;
                  }
                }
                if (local_60 == (void *)0x0) {
                  ((void*(*)())(param_1 + 0x18))(local_90.update,param_1,local_90.update,param_1);
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                }
                else {
                  iVar3 = ((void*(*)())(*(long *)(param_1 + 0x128) + 0x28))
                                    (param_1,*(undefined8 *)(param_1 + 0x128),local_90.update,
                                     &local_a8,local_60,local_98,0,param_1 + 0x130);
                  if (iVar3 == 0) {
                    if (local_a8 != 0) {
                      lVar8 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                      _libssh2_explicit_zero(local_90.update,lVar8);
                      ((void*(*)())(param_1 + 0x18))(local_90.update,param_1,local_90.update,param_1)
                      ;
                    }
                    if (local_98[0] != 0) {
                      lVar8 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      _libssh2_explicit_zero(local_60,lVar8);
                      ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
                    }
                    goto LAB_0011d4c3;
                  }
                  ((void*(*)())(param_1 + 0x18))(local_90.update,param_1,local_90.update,param_1);
                  ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
                  local_a4 = 0xfffffffb;
                  uVar2 = local_a4;
                }
              }
            }
          }
          else {
            local_90.engine = (ENGINE *)0x0;
            local_90.flags = (void *)0x0;
            local_a8 = 0;
            local_98[0] = 0;
            local_90.md_data = (void *)0x0;
            lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x20);
            local_90.engine = (ENGINE *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
            if (local_90.engine != (ENGINE *)0x0) {
              while (local_90.md_data < (void *)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14)) {
                _libssh2_sha256_init(&local_28);
                EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
                EVP_DigestUpdate(local_28,param_9 + 8,0x20);
                if (local_90.md_data == (void *)0x0) {
                  EVP_DigestUpdate(local_28,&DAT_00146ad1,1);
                  EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_28,local_90.engine,(size_t)local_90.md_data);
                }
                EVP_DigestFinal(local_28,(uchar *)(local_90.engine + (long)local_90.md_data),
                                (uint *)0x0);
                EVP_MD_CTX_free(local_28);
                local_90.md_data = (void *)((long)local_90.md_data + 0x20);
              }
            }
            if (local_90.engine == (ENGINE *)0x0) {
              local_a4 = 0xffffffff;
              uVar2 = local_a4;
            }
            else {
              local_90.pctx = (EVP_PKEY_CTX *)0x0;
              if (local_90.flags == (void *)0x0) {
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) + 0x20);
                local_90.flags = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
              }
              if (local_90.flags != (void *)0x0) {
                while (local_90.pctx <
                       (EVP_PKEY_CTX *)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18)) {
                  _libssh2_sha256_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
                  EVP_DigestUpdate(local_28,param_9 + 8,0x20);
                  if (local_90.pctx == (EVP_PKEY_CTX *)0x0) {
                    EVP_DigestUpdate(local_28,&DAT_00146ad3,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_90.flags,(size_t)local_90.pctx);
                  }
                  EVP_DigestFinal(local_28,(uchar *)((long)local_90.flags + (long)local_90.pctx),
                                  (uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_90.pctx = local_90.pctx + 0x20;
                }
              }
              if (local_90.flags == (void *)0x0) {
                ((void*(*)())(param_1 + 0x18))(local_90.engine,param_1,local_90.engine,param_1);
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
              else {
                iVar3 = ((void*(*)())(*(long *)(param_1 + 0x198) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x198),local_90.engine,
                                   &local_a8,local_90.flags,local_98,1,param_1 + 0x1a0);
                if (iVar3 == 0) {
                  if (local_a8 != 0) {
                    lVar8 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                    _libssh2_explicit_zero(local_90.engine,lVar8);
                    ((void*(*)())(param_1 + 0x18))(local_90.engine,param_1,local_90.engine,param_1);
                  }
                  if (local_98[0] != 0) {
                    lVar8 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    _libssh2_explicit_zero(local_90.flags,lVar8);
                    ((void*(*)())(param_1 + 0x18))(local_90.flags,param_1,local_90.flags,param_1);
                  }
                  goto LAB_0011d001;
                }
                ((void*(*)())(param_1 + 0x18))(local_90.engine,param_1,local_90.engine,param_1);
                ((void*(*)())(param_1 + 0x18))(local_90.flags,param_1,local_90.flags,param_1);
                local_a4 = 0xfffffffb;
                uVar2 = local_a4;
              }
            }
          }
        }
        else {
          uVar2 = _libssh2_error(param_1,(ulong)local_a0,"Timed out waiting for NEWKEYS",
                                 (ulong)local_a0);
        }
      }
    }
  }
LAB_0011db1e:
  local_a4 = uVar2;
  _libssh2_dh_dtor(param_9 + 0x22);
  BN_clear_free(*(BIGNUM **)(param_9 + 0x24));
  *(undefined8 *)(param_9 + 0x24) = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x26));
  *(undefined8 *)(param_9 + 0x26) = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x28));
  *(undefined8 *)(param_9 + 0x28) = 0;
  BN_CTX_free(*(BN_CTX **)(param_9 + 0x20));
  *(undefined8 *)(param_9 + 0x20) = 0;
  if (*(long *)(param_9 + 2) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_9 + 2),param_1,*(undefined8 *)(param_9 + 2),param_1);
    *(undefined8 *)(param_9 + 2) = 0;
  }
  if (*(long *)(param_9 + 4) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_9 + 4),param_1,*(undefined8 *)(param_9 + 4),param_1);
    *(undefined8 *)(param_9 + 4) = 0;
  }
  if (*(long *)(param_9 + 0x2c) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_9 + 0x2c),param_1,*(undefined8 *)(param_9 + 0x2c),param_1);
    *(undefined8 *)(param_9 + 0x2c) = 0;
  }
  *param_9 = 0;
  uVar7 = (ulong)local_a4;
LAB_0011dcbb:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar7;
}



ulong FUN_0011dcd1(undefined8 param_1,int *param_2)

{
  uint uVar1;
  BIGNUM *pBVar2;
  
  if (*param_2 == 0) {
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x44) = pBVar2;
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar2;
    BN_set_word(*(BIGNUM **)(param_2 + 0x46),2);
    BN_bin2bn(&DAT_00147060,0x80,*(BIGNUM **)(param_2 + 0x44));
    *param_2 = 2;
  }
  uVar1 = FUN_00119461(param_1,*(undefined8 *)(param_2 + 0x46),*(undefined8 *)(param_2 + 0x44),0x80,
                       0x1e,0x1f,0,0,param_2 + 6);
  if (uVar1 != 0xffffffdb) {
    BN_clear_free(*(BIGNUM **)(param_2 + 0x44));
    *(undefined8 *)(param_2 + 0x44) = 0;
    BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
    *(undefined8 *)(param_2 + 0x46) = 0;
    *param_2 = 0;
  }
  return (ulong)uVar1;
}



ulong FUN_0011ddfb(undefined8 param_1,int *param_2,void  *param_3)

{
  uint uVar1;
  BIGNUM *pBVar2;
  
  if (*param_2 == 0) {
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x44) = pBVar2;
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar2;
    BN_set_word(*(BIGNUM **)(param_2 + 0x46),2);
    *param_2 = 2;
  }

  if (uVar1 != 0xffffffdb) {
    *param_2 = 0;
    BN_clear_free(*(BIGNUM **)(param_2 + 0x44));
    *(undefined8 *)(param_2 + 0x44) = 0;
    BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
    *(undefined8 *)(param_2 + 0x46) = 0;
  }
  return (ulong)uVar1;
}



void FUN_0011df27(undefined8 param_1,undefined8 param_2)

{
  FUN_0011ddfb(param_1,param_2,FUN_00119461);
  return;
}



void FUN_0011df53(undefined8 param_1,undefined8 param_2)

{
  FUN_0011ddfb(param_1,param_2,FUN_0011b899);
  return;
}



ulong FUN_0011df7f(long param_1,int *param_2)

{
  uint uVar1;
  int iVar2;
  BIGNUM *pBVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  undefined8 uVar5;
  uint local_50;
  ulong local_48;
  int local_40 [2];
  uchar *local_38;
  uchar *local_30;
  long local_28;
  long local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_50 = 0;
  if (*param_2 == 0) {
    pBVar3 = BN_new();
    *(BIGNUM **)(param_2 + 0x44) = pBVar3;
    pBVar3 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar3;
    *(undefined *)(param_2 + 0x48) = 0x22;
    _libssh2_htonu32((long)param_2 + 0x121,0x400);
    _libssh2_htonu32((long)param_2 + 0x125,0x600);
    _libssh2_htonu32((long)param_2 + 0x129,0x800);
    *(undefined8 *)(param_2 + 0x8a) = 0xd;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    uVar1 = _libssh2_transport_send(param_1,param_2 + 0x48,*(undefined8 *)(param_2 + 0x8a),0,0);
    if (uVar1 == 0xffffffdb) {
      uVar4 = 0xffffffdb;
      goto LAB_0011e36a;
    }
    if (uVar1 == 0) {
      *param_2 = 3;
      goto LAB_0011e0c7;
    }
    local_50 = _libssh2_error(param_1,(ulong)uVar1,"Unable to send Group Exchange Request",
                              (ulong)uVar1);
  }
  else {
LAB_0011e0c7:
    if (*param_2 == 3) {
      uVar1 = _libssh2_packet_require(param_1,0x1f,param_2 + 0x88,param_2 + 0x8c,0,0,0,param_2 + 2);
      if (uVar1 == 0xffffffdb) {
        uVar4 = 0xffffffdb;
        goto LAB_0011e36a;
      }
      if (uVar1 != 0) {
        local_50 = _libssh2_error(param_1,(ulong)uVar1,"Timeout waiting for GEX_GROUP reply",
                                  (ulong)uVar1);
        goto LAB_0011e319;
      }
      *param_2 = 4;
    }
    if (*param_2 == 4) {
      if (*(ulong *)(param_2 + 0x8c) < 9) {
        local_50 = _libssh2_error(param_1,0xfffffff2,"Unexpected key length");
      }
      else {
        local_28 = *(long *)(param_2 + 0x88);
        local_18 = *(undefined8 *)(param_2 + 0x8c);
        local_20 = local_28 + 1;
        iVar2 = _libssh2_get_bignum_bytes(&local_28,&local_38,&local_48);
        if (iVar2 == 0) {

          if (iVar2 == 0) {
            BN_bin2bn(local_38,(int)local_48,*(BIGNUM **)(param_2 + 0x44));
            uVar5 = 0x11e27f;
            BN_bin2bn(local_30,local_40[0],*(BIGNUM **)(param_2 + 0x46));
            local_50 = FUN_00119461(param_1,*(undefined8 *)(param_2 + 0x46),
                                    *(undefined8 *)(param_2 + 0x44),local_48 & 0xffffffff,0x20,0x21,
                                    *(long *)(param_2 + 0x88) + 1,*(long *)(param_2 + 0x8c) + -1,
                                    param_2 + 6);
            if (local_50 == 0xffffffdb) {
              uVar4 = 0xffffffdb;
              goto LAB_0011e36a;
            }
            ((void*(*)())(param_1 + 0x18))
                      (*(undefined8 *)(param_2 + 0x88),param_1,*(undefined8 *)(param_2 + 0x88),
                       param_1);
          }
          else {
            local_50 = _libssh2_error(param_1,0xfffffff2,"Unexpected value");
          }
        }
        else {
          local_50 = _libssh2_error(param_1,0xfffffff2,"Unexpected value");
        }
      }
    }
  }
LAB_0011e319:
  *param_2 = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
  *(undefined8 *)(param_2 + 0x46) = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x44));
  *(undefined8 *)(param_2 + 0x44) = 0;
  uVar4 = (ulong)local_50;
LAB_0011e36a:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong FUN_0011e380(long param_1,int *param_2)

{
  uint uVar1;
  int iVar2;
  BIGNUM *pBVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  undefined8 uVar5;
  uint local_50;
  uchar *local_48;
  uchar *local_40;
  ulong local_38;
  int local_30 [2];
  long local_28;
  long local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_50 = 0;
  if (*param_2 == 0) {
    pBVar3 = BN_new();
    *(BIGNUM **)(param_2 + 0x44) = pBVar3;
    pBVar3 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar3;
    *(undefined *)(param_2 + 0x48) = 0x22;
    _libssh2_htonu32((long)param_2 + 0x121,0x400);
    _libssh2_htonu32((long)param_2 + 0x125,0x600);
    _libssh2_htonu32((long)param_2 + 0x129,0x800);
    *(undefined8 *)(param_2 + 0x8a) = 0xd;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    uVar1 = _libssh2_transport_send(param_1,param_2 + 0x48,*(undefined8 *)(param_2 + 0x8a),0,0);
    if (uVar1 == 0xffffffdb) {
      uVar4 = 0xffffffdb;
      goto LAB_0011e76b;
    }
    if (uVar1 == 0) {
      *param_2 = 3;
      goto LAB_0011e4c8;
    }
    local_50 = _libssh2_error(param_1,(ulong)uVar1,"Unable to send Group Exchange Request SHA256",
                              (ulong)uVar1);
  }
  else {
LAB_0011e4c8:
    if (*param_2 == 3) {
      uVar1 = _libssh2_packet_require(param_1,0x1f,param_2 + 0x88,param_2 + 0x8c,0,0,0,param_2 + 2);
      if (uVar1 == 0xffffffdb) {
        uVar4 = 0xffffffdb;
        goto LAB_0011e76b;
      }
      if (uVar1 != 0) {
        local_50 = _libssh2_error(param_1,(ulong)uVar1,"Timeout waiting for GEX_GROUP reply SHA256",
                                  (ulong)uVar1);
        goto LAB_0011e71a;
      }
      *param_2 = 4;
    }
    if (*param_2 == 4) {
      if (*(ulong *)(param_2 + 0x8c) < 9) {
        local_50 = _libssh2_error(param_1,0xfffffff2,"Unexpected key length");
      }
      else {
        local_28 = *(long *)(param_2 + 0x88);
        local_18 = *(undefined8 *)(param_2 + 0x8c);
        local_20 = local_28 + 1;
        iVar2 = _libssh2_get_bignum_bytes(&local_28,&local_48,&local_38);
        if (iVar2 == 0) {

          if (iVar2 == 0) {
            BN_bin2bn(local_48,(int)local_38,*(BIGNUM **)(param_2 + 0x44));
            uVar5 = 0x11e680;
            BN_bin2bn(local_40,local_30[0],*(BIGNUM **)(param_2 + 0x46));
            local_50 = FUN_0011b899(param_1,*(undefined8 *)(param_2 + 0x46),
                                    *(undefined8 *)(param_2 + 0x44),local_38 & 0xffffffff,0x20,0x21,
                                    *(long *)(param_2 + 0x88) + 1,*(long *)(param_2 + 0x8c) + -1,
                                    param_2 + 6);
            if (local_50 == 0xffffffdb) {
              uVar4 = 0xffffffdb;
              goto LAB_0011e76b;
            }
            ((void*(*)())(param_1 + 0x18))
                      (*(undefined8 *)(param_2 + 0x88),param_1,*(undefined8 *)(param_2 + 0x88),
                       param_1);
          }
          else {
            local_50 = _libssh2_error(param_1,0xfffffff2,"Unexpected value");
          }
        }
        else {
          local_50 = _libssh2_error(param_1,0xfffffff2,"Unexpected value");
        }
      }
    }
  }
LAB_0011e71a:
  *param_2 = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
  *(undefined8 *)(param_2 + 0x46) = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x44));
  *(undefined8 *)(param_2 + 0x44) = 0;
  uVar4 = (ulong)local_50;
LAB_0011e76b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong FUN_0011e781(char *param_1,undefined4 *param_2)

{
  int iVar1;
  ulong uVar2;
  uint local_10;
  undefined4 local_c;
  
  local_10 = 0;
  if (param_1 == (char *)0x0) {
    uVar2 = 0xffffffff;
  }
  else {
    iVar1 = strcmp(param_1,"ecdh-sha2-nistp256");
    if (iVar1 == 0) {
      local_c = 0x19f;
    }
    else {
      iVar1 = strcmp(param_1,"ecdh-sha2-nistp384");
      if (iVar1 == 0) {
        local_c = 0x2cb;
      }
      else {
        iVar1 = strcmp(param_1,"ecdh-sha2-nistp521");
        if (iVar1 == 0) {
          local_c = 0x2cc;
        }
        else {
          local_10 = 0xffffffff;
        }
      }
    }
    if ((local_10 == 0) && (param_2 != (undefined4 *)0x0)) {
      *param_2 = local_c;
    }
    uVar2 = (ulong)local_10;
  }
  return uVar2;
}



ulong FUN_0011e82b(long param_1,int param_2,long param_3,ulong param_4,void *param_5,ulong param_6,
                  undefined8 param_7,int *param_8)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  ulong uVar5;
  BIGNUM *pBVar6;
  undefined8 uVar7;
  size_t cnt;
  long lVar8;
  long in_FS_OFFSET;
  int local_110;
  int local_10c;
  uint local_108;
  uint local_104;
  struct env_md_ctx_st  local_100;
  ulong local_d0;
  ulong local_c8;
  ulong local_c0;
  ulong local_b8;
  void *local_b0;
  void *local_a8;
  ulong local_a0;
  ulong local_98;
  ulong local_90;
  ulong local_88;
  ulong local_80;
  ulong local_78;
  void *local_70;
  ulong local_68;
  ulong local_60;
  ulong local_58;
  void *local_50;
  ulong local_48;
  ulong local_40;
  ulong local_38;
  void *local_30;
  ulong local_28;
  void *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_108 = 0;
  if (param_4 < 5) {
    local_108 = _libssh2_error(param_1,0xfffffff6,"Host key data is too short");
    uVar5 = (ulong)local_108;
    goto LAB_001224b2;
  }
  if (*param_8 == 0) {
    pBVar6 = BN_new();
    *(BIGNUM **)(param_8 + 0x28) = pBVar6;
    *param_8 = 2;
  }
  if (*param_8 == 2) {
    local_30 = (void *)(param_3 + 1);
    uVar1 = _libssh2_ntohu32(local_30);
    *(undefined4 *)(param_1 + 0xb8) = uVar1;
    local_30 = (void *)((long)local_30 + 4);
    uVar7 = ((void*(*)())(param_1 + 8))
                      ((ulong)*(uint *)(param_1 + 0xb8),param_1,param_1,
                       (ulong)*(uint *)(param_1 + 0xb8));
    *(undefined8 *)(param_1 + 0xb0) = uVar7;
    if (*(long *)(param_1 + 0xb0) == 0) {
      local_108 = _libssh2_error(param_1,0xfffffffa,
                                 "Unable to allocate memory for a copy of the host key");
    }
    else {
      memcpy(*(void **)(param_1 + 0xb0),local_30,(ulong)*(uint *)(param_1 + 0xb8));
      local_30 = (void *)((long)local_30 + (ulong)*(uint *)(param_1 + 0xb8));
      iVar2 = _libssh2_md5_init(&local_100);
      if (iVar2 == 0) {
        *(undefined4 *)(param_1 + 0xcc) = 0;
      }
      else {
        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0xb0),
                         (ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,(uchar *)(param_1 + 0xbc),(uint *)0x0);
        EVP_MD_CTX_free(local_100.digest);
        *(undefined4 *)(param_1 + 0xcc) = 1;
      }
      iVar2 = _libssh2_sha1_init(&local_100);
      if (iVar2 == 0) {
        *(undefined4 *)(param_1 + 0xe4) = 0;
      }
      else {
        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0xb0),
                         (ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,(uchar *)(param_1 + 0xd0),(uint *)0x0);
        EVP_MD_CTX_free(local_100.digest);
        *(undefined4 *)(param_1 + 0xe4) = 1;
      }
      iVar2 = _libssh2_sha256_init(&local_100);
      if (iVar2 == 0) {
        *(undefined4 *)(param_1 + 0x108) = 0;
      }
      else {
        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0xb0),
                         (ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,(uchar *)(param_1 + 0xe8),(uint *)0x0);
        EVP_MD_CTX_free(local_100.digest);
        *(undefined4 *)(param_1 + 0x108) = 1;
      }
      iVar2 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x10))
                        (param_1,*(undefined8 *)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8),
                         param_1 + 0xa8);
      if (iVar2 == 0) {
        uVar3 = _libssh2_ntohu32(local_30);
        local_28 = (ulong)uVar3;
        local_20 = (void *)((long)local_30 + 4);
        local_30 = (void *)((long)local_20 + local_28);
        uVar3 = _libssh2_ntohu32(local_30);
        local_18 = (ulong)uVar3;
        *(long *)(param_8 + 0x2e) = (long)local_30 + 4;
        *(ulong *)(param_8 + 0x34) = local_18;
        local_30 = (void *)((long)local_30 + 4 + local_18);
        local_104 = _libssh2_ecdh_gen_k(param_8 + 0x28,param_7,local_20,local_28);
        if (local_104 == 0) {
          iVar4 = BN_num_bits(*(BIGNUM **)(param_8 + 0x28));
          iVar2 = iVar4 + 7;
          if (iVar4 + 7 < 0) {
            iVar2 = iVar4 + 0xe;
          }
          *(long *)(param_8 + 0x32) = (long)((iVar2 >> 3) + 5);
          uVar3 = BN_num_bits(*(BIGNUM **)(param_8 + 0x28));
          if ((uVar3 & 7) != 0) {
            *(long *)(param_8 + 0x32) = *(long *)(param_8 + 0x32) + -1;
          }
          uVar7 = ((void*(*)())(param_1 + 8))
                            (*(undefined8 *)(param_8 + 0x32),param_1,*(undefined8 *)(param_8 + 0x32)
                             ,param_1);
          *(undefined8 *)(param_8 + 0x2c) = uVar7;
          if (*(long *)(param_8 + 0x2c) == 0) {
            local_108 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
          }
          else {
            uVar3 = (int)*(undefined8 *)(param_8 + 0x32) - 4;
            _libssh2_htonu32(*(undefined8 *)(param_8 + 0x2c),(ulong)uVar3);
            uVar3 = BN_num_bits(*(BIGNUM **)(param_8 + 0x28));
            if ((uVar3 & 7) == 0) {
              *(undefined *)(*(long *)(param_8 + 0x2c) + 4) = 0;
              BN_bn2bin(*(BIGNUM **)(param_8 + 0x28),(uchar *)(*(long *)(param_8 + 0x2c) + 5));
            }
            else {
              BN_bn2bin(*(BIGNUM **)(param_8 + 0x28),(uchar *)(*(long *)(param_8 + 0x2c) + 4));
            }
            if (param_2 == 0x2cb) {
              *(EVP_MD_CTX **)(param_8 + 0x36) = &local_100;
              _libssh2_sha384_init(&local_100);
              if (*(long *)(param_1 + 0x180) == 0) {
                _libssh2_htonu32(param_8 + 8,0x19);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
              }
              else {
                cnt = strlen(*(char **)(param_1 + 0x180));
                uVar3 = (int)cnt - 2;
                _libssh2_htonu32(param_8 + 8,(ulong)uVar3);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                cnt = strlen(*(char **)(param_1 + 0x180));
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x180),cnt - 2)
                ;
              }
              cnt = strlen(*(char **)(param_1 + 0x110));
              _libssh2_htonu32(param_8 + 8,cnt & 0xffffffff);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
              cnt = strlen(*(char **)(param_1 + 0x110));
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x110),cnt);
              uVar5 = *(ulong *)(param_1 + 400) & 0xffffffff;
              _libssh2_htonu32(param_8 + 8,uVar5);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x188),
                               *(size_t *)(param_1 + 400));
              uVar5 = *(ulong *)(param_1 + 0x120) & 0xffffffff;
              _libssh2_htonu32(param_8 + 8,uVar5);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x118),
                               *(size_t *)(param_1 + 0x120));
              _libssh2_htonu32(param_8 + 8,(ulong)*(uint *)(param_1 + 0xb8));
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0xb0),
                               (ulong)*(uint *)(param_1 + 0xb8));
              _libssh2_htonu32(param_8 + 8,param_6 & 0xffffffff);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_5,param_6);
              _libssh2_htonu32(param_8 + 8,local_28 & 0xffffffff);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_20,local_28);
              EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                               *(size_t *)(param_8 + 0x32));
              EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,(uchar *)(param_8 + 8),(uint *)0x0);
              EVP_MD_CTX_free(local_100.digest);
              iVar2 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x28))
                                (param_1,*(undefined8 *)(param_8 + 0x2e),
                                 *(undefined8 *)(param_8 + 0x34),param_8 + 8,0x30,param_1 + 0xa8);
              if (iVar2 != 0) {
                local_104 = 0xffffffff;
              }
            }
            else {
              if (param_2 == 0x2cc) {
                *(EVP_MD_CTX **)(param_8 + 0x36) = &local_100;
                _libssh2_sha512_init(&local_100);
                if (*(long *)(param_1 + 0x180) == 0) {
                  _libssh2_htonu32(param_8 + 8,0x19);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
                }
                else {
                  cnt = strlen(*(char **)(param_1 + 0x180));
                  uVar3 = (int)cnt - 2;
                  _libssh2_htonu32(param_8 + 8,(ulong)uVar3);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  cnt = strlen(*(char **)(param_1 + 0x180));
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x180),
                                   cnt - 2);
                }
                cnt = strlen(*(char **)(param_1 + 0x110));
                _libssh2_htonu32(param_8 + 8,cnt & 0xffffffff);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                cnt = strlen(*(char **)(param_1 + 0x110));
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x110),cnt);
                uVar5 = *(ulong *)(param_1 + 400) & 0xffffffff;
                _libssh2_htonu32(param_8 + 8,uVar5);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x188),
                                 *(size_t *)(param_1 + 400));
                uVar5 = *(ulong *)(param_1 + 0x120) & 0xffffffff;
                _libssh2_htonu32(param_8 + 8,uVar5);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x118),
                                 *(size_t *)(param_1 + 0x120));
                _libssh2_htonu32(param_8 + 8,(ulong)*(uint *)(param_1 + 0xb8));
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0xb0),
                                 (ulong)*(uint *)(param_1 + 0xb8));
                _libssh2_htonu32(param_8 + 8,param_6 & 0xffffffff);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_5,param_6);
                _libssh2_htonu32(param_8 + 8,local_28 & 0xffffffff);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_20,local_28);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                 *(size_t *)(param_8 + 0x32));
                EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,(uchar *)(param_8 + 8),(uint *)0x0);
                EVP_MD_CTX_free(local_100.digest);
                iVar2 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x28))
                                  (param_1,*(undefined8 *)(param_8 + 0x2e),
                                   *(undefined8 *)(param_8 + 0x34),param_8 + 8,0x40,param_1 + 0xa8);
                if (iVar2 != 0) {
                  local_104 = 0xffffffff;
                }
              }
              else {
                if (param_2 == 0x19f) {
                  *(EVP_MD_CTX **)(param_8 + 0x36) = &local_100;
                  _libssh2_sha256_init(&local_100);
                  if (*(long *)(param_1 + 0x180) == 0) {
                    _libssh2_htonu32(param_8 + 8,0x19);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,"SSH-2.0-libssh2_1.9.0_DEV",0x19
                                    );
                  }
                  else {
                    cnt = strlen(*(char **)(param_1 + 0x180));
                    uVar3 = (int)cnt - 2;
                    _libssh2_htonu32(param_8 + 8,(ulong)uVar3);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                    cnt = strlen(*(char **)(param_1 + 0x180));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x180),
                                     cnt - 2);
                  }
                  cnt = strlen(*(char **)(param_1 + 0x110));
                  _libssh2_htonu32(param_8 + 8,cnt & 0xffffffff);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  cnt = strlen(*(char **)(param_1 + 0x110));
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x110),cnt);
                  uVar5 = *(ulong *)(param_1 + 400) & 0xffffffff;
                  _libssh2_htonu32(param_8 + 8,uVar5);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x188),
                                   *(size_t *)(param_1 + 400));
                  uVar5 = *(ulong *)(param_1 + 0x120) & 0xffffffff;
                  _libssh2_htonu32(param_8 + 8,uVar5);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x118),
                                   *(size_t *)(param_1 + 0x120));
                  _libssh2_htonu32(param_8 + 8,(ulong)*(uint *)(param_1 + 0xb8));
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0xb0),
                                   (ulong)*(uint *)(param_1 + 0xb8));
                  _libssh2_htonu32(param_8 + 8,param_6 & 0xffffffff);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_5,param_6);
                  _libssh2_htonu32(param_8 + 8,local_28 & 0xffffffff);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,4);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_20,local_28);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                   *(size_t *)(param_8 + 0x32));
                  EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,(uchar *)(param_8 + 8),(uint *)0x0)
                  ;
                  EVP_MD_CTX_free(local_100.digest);
                  iVar2 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x28))
                                    (param_1,*(undefined8 *)(param_8 + 0x2e),
                                     *(undefined8 *)(param_8 + 0x34),param_8 + 8,0x20,param_1 + 0xa8
                                    );
                  if (iVar2 != 0) {
                    local_104 = 0xffffffff;
                  }
                }
              }
            }
            if (local_104 == 0) {
              *(undefined *)(param_8 + 0x18) = 0x15;
              *param_8 = 3;
              goto LAB_0011fc93;
            }
            local_108 = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
          }
        }
        else {
          local_108 = _libssh2_error(param_1,0xfffffffb,"Unable to create ECDH shared secret");
        }
      }
      else {
        local_108 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
      }
    }
  }
  else {
LAB_0011fc93:
    if (*param_8 == 3) {
      local_104 = _libssh2_transport_send(param_1,param_8 + 0x18,1,0,0);
      if (local_104 == 0xffffffdb) {
        uVar5 = 0xffffffdb;
        goto LAB_001224b2;
      }
      if (local_104 != 0) {
        local_108 = _libssh2_error(param_1,(ulong)local_104,"Unable to send NEWKEYS message",
                                   (ulong)local_104);
        goto LAB_0012242a;
      }
      *param_8 = 5;
    }
    if (*param_8 == 5) {
      local_104 = _libssh2_packet_require
                            (param_1,0x15,param_8 + 6,param_8 + 0x1e,0,0,0,param_8 + 0x38);
      if (local_104 == 0xffffffdb) {
        uVar5 = 0xffffffdb;
        goto LAB_001224b2;
      }
      if (local_104 == 0) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_8 + 6),param_1,*(undefined8 *)(param_8 + 6),param_1);
        if (*(long *)(param_1 + 0x88) == 0) {
          local_100.engine = (ENGINE *)0x0;
          if (param_2 == 0x19f) {
            local_100.engine = (ENGINE *)0x20;
          }
          else {
            if (param_2 == 0x2cb) {
              local_100.engine = (ENGINE *)0x30;
            }
            else {
              if (param_2 != 0x2cc) {
                local_108 = _libssh2_error(param_1,0xfffffffb,"Unknown SHA digest for EC curve");
                goto LAB_0012242a;
              }
              local_100.engine = (ENGINE *)0x40;
            }
          }
          uVar7 = ((void*(*)())(param_1 + 8))(local_100.engine,param_1,local_100.engine,param_1);
          *(undefined8 *)(param_1 + 0x88) = uVar7;
          if (*(long *)(param_1 + 0x88) == 0) {
            local_108 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest"
                                      );
            goto LAB_0012242a;
          }
          memcpy(*(void **)(param_1 + 0x88),param_8 + 8,(size_t)local_100.engine);
          *(undefined4 *)(param_1 + 0x90) = (int)local_100.engine;
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
          ((void*(*)())(*(long *)(param_1 + 0x198) + 0x38))
                    (param_1,param_1 + 0x1a0,param_1,param_1 + 0x1a0);
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_00120b71:
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
            ((void*(*)())(*(long *)(param_1 + 0x128) + 0x38))
                      (param_1,param_1 + 0x130,param_1,param_1 + 0x130);
          }
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_0012175e:
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
              ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x20))
                        (param_1,param_1 + 0x1b8,param_1,param_1 + 0x1b8);
            }
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
              local_70 = (void *)0x0;
              local_10c = 0;
              if (param_2 == 0x19f) {
                local_68 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) + 0x20);
                local_70 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_70 != (void *)0x0) {
                  while (local_68 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc)) {
                    _libssh2_sha256_init(&local_100);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                     *(size_t *)(param_8 + 0x32));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x20);
                    if (local_68 == 0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad9,1);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_70,local_68);
                    }
                    EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                    (uchar *)((long)local_70 + local_68),(uint *)0x0);
                    EVP_MD_CTX_free(local_100.digest);
                    local_68 = local_68 + 0x20;
                  }
                }
              }
              else {
                if (param_2 == 0x2cb) {
                  local_60 = 0;
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) + 0x30);
                  local_70 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                  if (local_70 != (void *)0x0) {
                    while (local_60 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc)) {
                      _libssh2_sha384_init(&local_100);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                       *(size_t *)(param_8 + 0x32));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x30);
                      if (local_60 == 0) {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad9,1);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                         (ulong)*(uint *)(param_1 + 0x90));
                      }
                      else {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_70,local_60);
                      }
                      EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                      (uchar *)((long)local_70 + local_60),(uint *)0x0);
                      EVP_MD_CTX_free(local_100.digest);
                      local_60 = local_60 + 0x30;
                    }
                  }
                }
                else {
                  if (param_2 == 0x2cc) {
                    local_58 = 0;
                    lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) + 0x40);
                    local_70 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                    if (local_70 != (void *)0x0) {
                      while (local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc)) {
                        _libssh2_sha512_init(&local_100);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                         *(size_t *)(param_8 + 0x32));
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x40);
                        if (local_58 == 0) {
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad9,1);
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88)
                                           ,(ulong)*(uint *)(param_1 + 0x90));
                        }
                        else {
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_70,local_58);
                        }
                        EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                        (uchar *)((long)local_70 + local_58),(uint *)0x0);
                        EVP_MD_CTX_free(local_100.digest);
                        local_58 = local_58 + 0x40;
                      }
                    }
                  }
                }
              }
              if (local_70 == (void *)0x0) {
                local_108 = 0xfffffffb;
                goto LAB_0012242a;
              }
              ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x10))
                        (param_1,local_70,&local_10c,param_1 + 0x1b8);
              if (local_10c != 0) {
                lVar8 = (long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                _libssh2_explicit_zero(local_70,lVar8);
                ((void*(*)())(param_1 + 0x18))(local_70,param_1,local_70,param_1);
              }
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
              ((void*(*)())(*(long *)(param_1 + 0x138) + 0x20))
                        (param_1,param_1 + 0x148,param_1,param_1 + 0x148);
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
              local_50 = (void *)0x0;
              local_10c = 0;
              if (param_2 == 0x19f) {
                local_48 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) + 0x20);
                local_50 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_50 != (void *)0x0) {
                  while (local_48 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc)) {
                    _libssh2_sha256_init(&local_100);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                     *(size_t *)(param_8 + 0x32));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x20);
                    if (local_48 == 0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146adb,1);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_50,local_48);
                    }
                    EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                    (uchar *)((long)local_50 + local_48),(uint *)0x0);
                    EVP_MD_CTX_free(local_100.digest);
                    local_48 = local_48 + 0x20;
                  }
                }
              }
              else {
                if (param_2 == 0x2cb) {
                  local_40 = 0;
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) + 0x30);
                  local_50 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                  if (local_50 != (void *)0x0) {
                    while (local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc)) {
                      _libssh2_sha384_init(&local_100);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                       *(size_t *)(param_8 + 0x32));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x30);
                      if (local_40 == 0) {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146adb,1);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                         (ulong)*(uint *)(param_1 + 0x90));
                      }
                      else {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_50,local_40);
                      }
                      EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                      (uchar *)((long)local_50 + local_40),(uint *)0x0);
                      EVP_MD_CTX_free(local_100.digest);
                      local_40 = local_40 + 0x30;
                    }
                  }
                }
                else {
                  if (param_2 == 0x2cc) {
                    local_38 = 0;
                    lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) + 0x40);
                    local_50 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                    if (local_50 != (void *)0x0) {
                      while (local_38 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc)) {
                        _libssh2_sha512_init(&local_100);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                         *(size_t *)(param_8 + 0x32));
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x40);
                        if (local_38 == 0) {
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146adb,1);
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88)
                                           ,(ulong)*(uint *)(param_1 + 0x90));
                        }
                        else {
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_50,local_38);
                        }
                        EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                        (uchar *)((long)local_50 + local_38),(uint *)0x0);
                        EVP_MD_CTX_free(local_100.digest);
                        local_38 = local_38 + 0x40;
                      }
                    }
                  }
                }
              }
              if (local_50 == (void *)0x0) {
                local_108 = 0xfffffffb;
                goto LAB_0012242a;
              }
              ((void*(*)())(*(long *)(param_1 + 0x138) + 0x10))
                        (param_1,local_50,&local_10c,param_1 + 0x148);
              if (local_10c != 0) {
                lVar8 = (long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                _libssh2_explicit_zero(local_50,lVar8);
                ((void*(*)())(param_1 + 0x18))(local_50,param_1,local_50,param_1);
              }
            }
            if ((*(long *)(param_1 + 0x1c0) != 0) &&
               (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
              ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8,param_1);
            }
            if (((*(long *)(param_1 + 0x1c0) == 0) ||
                (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
               (iVar2 = ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x10))
                                  (param_1,1,param_1 + 0x1c8,param_1), iVar2 == 0)) {
              if ((*(long *)(param_1 + 0x150) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                ((void*(*)())(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158,param_1);
              }
              if (((*(long *)(param_1 + 0x150) != 0) &&
                  (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                 (iVar2 = ((void*(*)())(*(long *)(param_1 + 0x150) + 0x10))
                                    (param_1,0,param_1 + 0x158,param_1), iVar2 != 0)) {
                local_108 = 0xfffffffb;
              }
            }
            else {
              local_108 = 0xfffffffb;
            }
          }
          else {
            local_b0 = (void *)0x0;
            local_a8 = (void *)0x0;
            local_110 = 0;
            local_10c = 0;
            if (param_2 == 0x19f) {
              local_a0 = 0;
              lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) + 0x20);
              local_b0 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
              if (local_b0 != (void *)0x0) {
                while (local_a0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14)) {
                  _libssh2_sha256_init(&local_100);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                   *(size_t *)(param_8 + 0x32));
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x20);
                  if (local_a0 == 0) {
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad5,1);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_b0,local_a0);
                  }
                  EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                  (uchar *)((long)local_b0 + local_a0),(uint *)0x0);
                  EVP_MD_CTX_free(local_100.digest);
                  local_a0 = local_a0 + 0x20;
                }
              }
            }
            else {
              if (param_2 == 0x2cb) {
                local_98 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) + 0x30);
                local_b0 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_b0 != (void *)0x0) {
                  while (local_98 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14)) {
                    _libssh2_sha384_init(&local_100);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                     *(size_t *)(param_8 + 0x32));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x30);
                    if (local_98 == 0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad5,1);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_b0,local_98);
                    }
                    EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                    (uchar *)((long)local_b0 + local_98),(uint *)0x0);
                    EVP_MD_CTX_free(local_100.digest);
                    local_98 = local_98 + 0x30;
                  }
                }
              }
              else {
                if (param_2 == 0x2cc) {
                  local_90 = 0;
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) + 0x40);
                  local_b0 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                  if (local_b0 != (void *)0x0) {
                    while (local_90 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14)) {
                      _libssh2_sha512_init(&local_100);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                       *(size_t *)(param_8 + 0x32));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x40);
                      if (local_90 == 0) {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad5,1);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                         (ulong)*(uint *)(param_1 + 0x90));
                      }
                      else {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_b0,local_90);
                      }
                      EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                      (uchar *)((long)local_b0 + local_90),(uint *)0x0);
                      EVP_MD_CTX_free(local_100.digest);
                      local_90 = local_90 + 0x40;
                    }
                  }
                }
              }
            }
            if (local_b0 == (void *)0x0) {
              local_108 = 0xfffffffb;
            }
            else {
              if (param_2 == 0x19f) {
                local_88 = 0;
                if (local_a8 == (void *)0x0) {
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) + 0x20);
                  local_a8 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                }
                if (local_a8 != (void *)0x0) {
                  while (local_88 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18)) {
                    _libssh2_sha256_init(&local_100);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                     *(size_t *)(param_8 + 0x32));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x20);
                    if (local_88 == 0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad7,1);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_a8,local_88);
                    }
                    EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                    (uchar *)((long)local_a8 + local_88),(uint *)0x0);
                    EVP_MD_CTX_free(local_100.digest);
                    local_88 = local_88 + 0x20;
                  }
                }
              }
              else {
                if (param_2 == 0x2cb) {
                  local_80 = 0;
                  if (local_a8 == (void *)0x0) {
                    lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) + 0x30);
                    local_a8 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                  }
                  if (local_a8 != (void *)0x0) {
                    while (local_80 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18)) {
                      _libssh2_sha384_init(&local_100);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                       *(size_t *)(param_8 + 0x32));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x30);
                      if (local_80 == 0) {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad7,1);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                         (ulong)*(uint *)(param_1 + 0x90));
                      }
                      else {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_a8,local_80);
                      }
                      EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                      (uchar *)((long)local_a8 + local_80),(uint *)0x0);
                      EVP_MD_CTX_free(local_100.digest);
                      local_80 = local_80 + 0x30;
                    }
                  }
                }
                else {
                  if (param_2 == 0x2cc) {
                    local_78 = 0;
                    if (local_a8 == (void *)0x0) {
                      lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) + 0x40);
                      local_a8 = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                    }
                    if (local_a8 != (void *)0x0) {
                      while (local_78 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18)) {
                        _libssh2_sha512_init(&local_100);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                         *(size_t *)(param_8 + 0x32));
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x40);
                        if (local_78 == 0) {
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad7,1);
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88)
                                           ,(ulong)*(uint *)(param_1 + 0x90));
                        }
                        else {
                          EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_a8,local_78);
                        }
                        EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                        (uchar *)((long)local_a8 + local_78),(uint *)0x0);
                        EVP_MD_CTX_free(local_100.digest);
                        local_78 = local_78 + 0x40;
                      }
                    }
                  }
                }
              }
              if (local_a8 == (void *)0x0) {
                ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
                local_108 = 0xfffffffb;
              }
              else {
                iVar2 = ((void*(*)())(*(long *)(param_1 + 0x128) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x128),local_b0,&local_110,
                                   local_a8,&local_10c,0,param_1 + 0x130);
                if (iVar2 == 0) {
                  if (local_110 != 0) {
                    lVar8 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    _libssh2_explicit_zero(local_b0,lVar8);
                    ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
                  }
                  if (local_10c != 0) {
                    lVar8 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                    _libssh2_explicit_zero(local_a8,lVar8);
                    ((void*(*)())(param_1 + 0x18))(local_a8,param_1,local_a8,param_1);
                  }
                  goto LAB_0012175e;
                }
                ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
                ((void*(*)())(param_1 + 0x18))(local_a8,param_1,local_a8,param_1);
                local_108 = 0xfffffffb;
              }
            }
          }
        }
        else {
          local_100.flags = (void *)0x0;
          local_100.md_data = (void *)0x0;
          local_110 = 0;
          local_10c = 0;
          if (param_2 == 0x19f) {
            local_100.pctx = (EVP_PKEY_CTX *)0x0;
            lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x20);
            local_100.flags = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
            if (local_100.flags != (void *)0x0) {
              while (local_100.pctx <
                     (EVP_PKEY_CTX *)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14)) {
                _libssh2_sha256_init(&local_100);
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                 *(size_t *)(param_8 + 0x32));
                EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x20);
                if (local_100.pctx == (EVP_PKEY_CTX *)0x0) {
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad1,1);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_100.flags,
                                   (size_t)local_100.pctx);
                }
                EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                (uchar *)((long)local_100.flags + (long)local_100.pctx),(uint *)0x0)
                ;
                EVP_MD_CTX_free(local_100.digest);
                local_100.pctx = local_100.pctx + 0x20;
              }
            }
          }
          else {
            if (param_2 == 0x2cb) {
              local_100.update = 0x0;
              lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x30);
              local_100.flags = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
              if (local_100.flags != (void *)0x0) {
                while (local_100.update < 0x14) {
                  _libssh2_sha384_init(&local_100);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                   *(size_t *)(param_8 + 0x32));
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x30);
                  if (local_100.update == 0x0) {
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad1,1);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_100.flags,
                                     (size_t)local_100.update);
                  }
                  EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                  (uchar *)((long)local_100.flags + (long)local_100.update),
                                  (uint *)0x0);
                  EVP_MD_CTX_free(local_100.digest);
                  local_100.update = local_100.update + 0x30;
                }
              }
            }
            else {
              if (param_2 == 0x2cc) {
                local_d0 = 0;
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x40);
                local_100.flags = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                if (local_100.flags != (void *)0x0) {
                  while (local_d0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14)) {
                    _libssh2_sha512_init(&local_100);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                     *(size_t *)(param_8 + 0x32));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x40);
                    if (local_d0 == 0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad1,1);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_100.flags,local_d0);
                    }
                    EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                    (uchar *)((long)local_100.flags + local_d0),(uint *)0x0);
                    EVP_MD_CTX_free(local_100.digest);
                    local_d0 = local_d0 + 0x40;
                  }
                }
              }
            }
          }
          if (local_100.flags == (void *)0x0) {
            local_108 = 0xffffffff;
          }
          else {
            if (param_2 == 0x19f) {
              local_c8 = 0;
              if (local_100.md_data == (void *)0x0) {
                lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) + 0x20);
                local_100.md_data = (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
              }
              if (local_100.md_data != (void *)0x0) {
                while (local_c8 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18)) {
                  _libssh2_sha256_init(&local_100);
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                   *(size_t *)(param_8 + 0x32));
                  EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x20);
                  if (local_c8 == 0) {
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad3,1);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_100.md_data,local_c8);
                  }
                  EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                  (uchar *)((long)local_100.md_data + local_c8),(uint *)0x0);
                  EVP_MD_CTX_free(local_100.digest);
                  local_c8 = local_c8 + 0x20;
                }
              }
            }
            else {
              if (param_2 == 0x2cb) {
                local_c0 = 0;
                if (local_100.md_data == (void *)0x0) {
                  lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) + 0x30);
                  local_100.md_data =
                       (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                }
                if (local_100.md_data != (void *)0x0) {
                  while (local_c0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18)) {
                    _libssh2_sha384_init(&local_100);
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                     *(size_t *)(param_8 + 0x32));
                    EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x30);
                    if (local_c0 == 0) {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad3,1);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_100.md_data,local_c0);
                    }
                    EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                    (uchar *)((long)local_100.md_data + local_c0),(uint *)0x0);
                    EVP_MD_CTX_free(local_100.digest);
                    local_c0 = local_c0 + 0x30;
                  }
                }
              }
              else {
                if (param_2 == 0x2cc) {
                  local_b8 = 0;
                  if (local_100.md_data == (void *)0x0) {
                    lVar8 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) + 0x40);
                    local_100.md_data =
                         (void *)((void*(*)())(param_1 + 8))(lVar8,param_1,lVar8,param_1);
                  }
                  if (local_100.md_data != (void *)0x0) {
                    while (local_b8 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18)) {
                      _libssh2_sha512_init(&local_100);
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_8 + 0x2c),
                                       *(size_t *)(param_8 + 0x32));
                      EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,param_8 + 8,0x40);
                      if (local_b8 == 0) {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,&DAT_00146ad3,1);
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,*(void **)(param_1 + 0x88),
                                         (ulong)*(uint *)(param_1 + 0x90));
                      }
                      else {
                        EVP_DigestUpdate((EVP_MD_CTX *)local_100.digest,local_100.md_data,local_b8);
                      }
                      EVP_DigestFinal((EVP_MD_CTX *)local_100.digest,
                                      (uchar *)((long)local_100.md_data + local_b8),(uint *)0x0);
                      EVP_MD_CTX_free(local_100.digest);
                      local_b8 = local_b8 + 0x40;
                    }
                  }
                }
              }
            }
            if (local_100.md_data == (void *)0x0) {
              ((void*(*)())(param_1 + 0x18))(local_100.flags,param_1,local_100.flags,param_1);
              local_108 = 0xfffffffb;
            }
            else {
              iVar2 = ((void*(*)())(*(long *)(param_1 + 0x198) + 0x28))
                                (param_1,*(undefined8 *)(param_1 + 0x198),local_100.flags,&local_110
                                 ,local_100.md_data,&local_10c,1,param_1 + 0x1a0);
              if (iVar2 == 0) {
                if (local_110 != 0) {
                  lVar8 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  _libssh2_explicit_zero(local_100.flags,lVar8);
                  ((void*(*)())(param_1 + 0x18))(local_100.flags,param_1,local_100.flags,param_1);
                }
                if (local_10c != 0) {
                  lVar8 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                  _libssh2_explicit_zero(local_100.md_data,lVar8);
                  ((void*(*)())(param_1 + 0x18))(local_100.md_data,param_1,local_100.md_data,param_1)
                  ;
                }
                goto LAB_00120b71;
              }
              ((void*(*)())(param_1 + 0x18))(local_100.flags,param_1,local_100.flags,param_1);
              ((void*(*)())(param_1 + 0x18))(local_100.md_data,param_1,local_100.md_data,param_1);
              local_108 = 0xfffffffb;
            }
          }
        }
      }
      else {
        local_108 = _libssh2_error(param_1,(ulong)local_104,"Timed out waiting for NEWKEYS",
                                   (ulong)local_104);
      }
    }
  }
LAB_0012242a:
  BN_clear_free(*(BIGNUM **)(param_8 + 0x28));
  *(undefined8 *)(param_8 + 0x28) = 0;
  if (*(long *)(param_8 + 0x2c) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_8 + 0x2c),param_1,*(undefined8 *)(param_8 + 0x2c),param_1);
    *(undefined8 *)(param_8 + 0x2c) = 0;
  }
  *param_8 = 0;
  uVar5 = (ulong)local_108;
LAB_001224b2:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong FUN_001224c8(long param_1,int *param_2)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint local_24;
  uint local_20;
  uint local_1c;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = 0;
  local_1c = 0;
  if (*param_2 == 0) {
    *(undefined8 *)(param_2 + 0x90) = 0;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    local_1c = FUN_0011e781(**(undefined8 **)(param_1 + 0x78),&local_24);
    if (local_1c == 0) {
      local_1c = _libssh2_ecdsa_create_key
                           (param_1,param_2 + 0x8e,param_2 + 0x90,param_2 + 0x92,(ulong)local_24);
      if (local_1c == 0) {
        *(undefined *)(param_2 + 0x48) = 0x1e;
        local_18 = (long)param_2 + 0x121;
        _libssh2_store_str(&local_18,*(undefined8 *)(param_2 + 0x90),*(undefined8 *)(param_2 + 0x92));

        *(long *)(param_2 + 0x8a) = *(long *)(param_2 + 0x92) + 5;
        *param_2 = 3;
        goto LAB_0012262c;
      }
      local_20 = _libssh2_error(param_1,(ulong)local_1c,"Unable to create private key",
                                (ulong)local_1c);
    }
    else {
      local_20 = _libssh2_error(param_1,0xffffffff,"Unknown KEX nistp curve type");
    }
  }
  else {
LAB_0012262c:
    if (*param_2 == 3) {
      local_1c = _libssh2_transport_send(param_1,param_2 + 0x48,*(undefined8 *)(param_2 + 0x8a),0,0)
      ;
      if (local_1c == 0xffffffdb) {
        uVar1 = 0xffffffdb;
        goto LAB_00122865;
      }
      if (local_1c != 0) {
        local_20 = _libssh2_error(param_1,(ulong)local_1c,"Unable to send ECDH_INIT",(ulong)local_1c
                                 );
        goto LAB_001227e8;
      }
      *param_2 = 4;
    }
    if (*param_2 == 4) {
      local_1c = _libssh2_packet_require
                           (param_1,0x1f,param_2 + 0x88,param_2 + 0x8c,0,0,0,param_2 + 2);
      if (local_1c == 0xffffffdb) {
        uVar1 = 0xffffffdb;
        goto LAB_00122865;
      }
      if (local_1c != 0) {
        local_20 = _libssh2_error(param_1,(ulong)local_1c,"Timeout waiting for ECDH_REPLY reply",
                                  (ulong)local_1c);
        goto LAB_001227e8;
      }
      *param_2 = 5;
    }
    if (*param_2 == 5) {
      FUN_0011e781(**(undefined8 **)(param_1 + 0x78),&local_24);
      local_20 = FUN_0011e82b(param_1,(ulong)local_24,*(undefined8 *)(param_2 + 0x88),
                              *(undefined8 *)(param_2 + 0x8c),*(undefined8 *)(param_2 + 0x90),
                              *(undefined8 *)(param_2 + 0x92),*(undefined8 *)(param_2 + 0x8e),
                              param_2 + 6);
      if (local_20 == 0xffffffdb) {
        uVar1 = 0xffffffdb;
        goto LAB_00122865;
      }
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x88),param_1,*(undefined8 *)(param_2 + 0x88),param_1);
    }
  }
LAB_001227e8:
  if (*(long *)(param_2 + 0x90) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_2 + 0x90),param_1,*(undefined8 *)(param_2 + 0x90),param_1);
    *(undefined8 *)(param_2 + 0x90) = 0;
  }
  if (*(long *)(param_2 + 0x8e) != 0) {
    EC_KEY_free(*(EC_KEY **)(param_2 + 0x8e));
    *(undefined8 *)(param_2 + 0x8e) = 0;
  }
  *param_2 = 0;
  uVar1 = (ulong)local_20;
LAB_00122865:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



ulong FUN_0012287b(long param_1,struct env_md_ctx_st *param_2,ulong param_3,void *param_4,undefined8 param_5,
                  int *param_6)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  BIGNUM *pBVar5;
  undefined8 uVar6;
  size_t cnt;
  long lVar7;
  long in_FS_OFFSET;
  uint local_c4;
  int local_c0;
  void *local_b8;
  void *local_b0;
  size_t local_a8;
  int local_a0 [2];
  int local_98;
  undefined4 uStack148;
  void *local_90;
  void *local_88;
  ulong local_80;
  ulong local_78;
  void *local_70;
  void *local_68;
  ulong local_60;
  ulong local_58;
  void *local_50;
  ulong local_48;
  void *local_40;
  ulong local_38;
  size_t local_30;
  struct env_md_ctx_st  *local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_c4 = 0;
  if (param_3 < 5) {
    uVar4 = _libssh2_error(param_1,0xfffffff6,"Data is too short");
    goto LAB_00124736;
  }
  if (*param_6 == 0) {
    pBVar5 = BN_new();
    *(BIGNUM **)(param_6 + 0x28) = pBVar5;
    *param_6 = 2;
  }
  if (*param_6 == 2) {
    if (param_3 < 5) {
      local_c4 = _libssh2_error(param_1,0xfffffff2,"Unexpected key length");
    }
    else {
      local_20 = (long)&param_2->digest + 1;
      local_28 = param_2;
      local_18 = param_3;
      iVar1 = _libssh2_get_string(&local_28,&local_b0,local_a0,&local_b0);
      if (iVar1 == 0) {
        *(int *)(param_1 + 0xb8) = local_a0[0];
        uVar6 = ((void*(*)())(param_1 + 8))
                          ((ulong)*(uint *)(param_1 + 0xb8),param_1,param_1,
                           (ulong)*(uint *)(param_1 + 0xb8));
        *(undefined8 *)(param_1 + 0xb0) = uVar6;
        if (*(long *)(param_1 + 0xb0) == 0) {
          local_c4 = _libssh2_error(param_1,0xfffffffa,
                                    "Unable to allocate memory for a copy of the host key");
        }
        else {
          memcpy(*(void **)(param_1 + 0xb0),local_b0,(ulong)*(uint *)(param_1 + 0xb8));
          iVar1 = _libssh2_md5_init(&local_98);
          if (iVar1 == 0) {
            *(undefined4 *)(param_1 + 0xcc) = 0;
          }
          else {
            EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),*(void **)(param_1 + 0xb0),
                             (ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal((EVP_MD_CTX *)CONCAT44(uStack148,local_98),(uchar *)(param_1 + 0xbc),
                            (uint *)0x0);
            EVP_MD_CTX_free(CONCAT44(uStack148,local_98));
            *(undefined4 *)(param_1 + 0xcc) = 1;
          }
          iVar1 = _libssh2_sha1_init(&local_98);
          if (iVar1 == 0) {
            *(undefined4 *)(param_1 + 0xe4) = 0;
          }
          else {
            EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),*(void **)(param_1 + 0xb0),
                             (ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal((EVP_MD_CTX *)CONCAT44(uStack148,local_98),(uchar *)(param_1 + 0xd0),
                            (uint *)0x0);
            EVP_MD_CTX_free(CONCAT44(uStack148,local_98));
            *(undefined4 *)(param_1 + 0xe4) = 1;
          }
          iVar1 = _libssh2_sha256_init(&local_98);
          if (iVar1 == 0) {
            *(undefined4 *)(param_1 + 0x108) = 0;
          }
          else {
            EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),*(void **)(param_1 + 0xb0),
                             (ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal((EVP_MD_CTX *)CONCAT44(uStack148,local_98),(uchar *)(param_1 + 0xe8),
                            (uint *)0x0);
            EVP_MD_CTX_free(CONCAT44(uStack148,local_98));
            *(undefined4 *)(param_1 + 0x108) = 1;
          }
          iVar1 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x10))
                            (param_1,*(undefined8 *)(param_1 + 0xb0),
                             (ulong)*(uint *)(param_1 + 0xb8),param_1 + 0xa8);
          if (iVar1 == 0) {
            iVar1 = _libssh2_get_string(&local_28,&local_b8,&local_a8,&local_b8);
            if (iVar1 == 0) {
              if (local_a8 == 0x20) {
                iVar1 = _libssh2_get_string(&local_28,param_6 + 0x2e,param_6 + 0x34,param_6 + 0x2e);
                if (iVar1 == 0) {
                  local_c0 = _libssh2_curve25519_gen_k
                                       (param_6 + 0x28,param_5,local_b8);
                  if (local_c0 == 0) {
                    iVar2 = BN_num_bits(*(BIGNUM **)(param_6 + 0x28));
                    iVar1 = iVar2 + 7;
                    if (iVar2 + 7 < 0) {
                      iVar1 = iVar2 + 0xe;
                    }
                    *(long *)(param_6 + 0x32) = (long)((iVar1 >> 3) + 5);
                    uVar3 = BN_num_bits(*(BIGNUM **)(param_6 + 0x28));
                    if ((uVar3 & 7) != 0) {
                      *(long *)(param_6 + 0x32) = *(long *)(param_6 + 0x32) + -1;
                    }
                    uVar6 = ((void*(*)())(param_1 + 8))
                                      (*(undefined8 *)(param_6 + 0x32),param_1,
                                       *(undefined8 *)(param_6 + 0x32),param_1);
                    *(undefined8 *)(param_6 + 0x2c) = uVar6;
                    if (*(long *)(param_6 + 0x2c) == 0) {
                      local_c4 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K"
                                               );
                    }
                    else {
                      uVar3 = (int)*(undefined8 *)(param_6 + 0x32) - 4;
                      _libssh2_htonu32(*(undefined8 *)(param_6 + 0x2c),(ulong)uVar3);
                      uVar3 = BN_num_bits(*(BIGNUM **)(param_6 + 0x28));
                      if ((uVar3 & 7) == 0) {
                        *(undefined *)(*(long *)(param_6 + 0x2c) + 4) = 0;
                        BN_bn2bin(*(BIGNUM **)(param_6 + 0x28),
                                  (uchar *)(*(long *)(param_6 + 0x2c) + 5));
                      }
                      else {
                        BN_bn2bin(*(BIGNUM **)(param_6 + 0x28),
                                  (uchar *)(*(long *)(param_6 + 0x2c) + 4));
                      }
                      *(int **)(param_6 + 0x36) = &local_98;
                      _libssh2_sha256_init(&local_98);
                      if (*(long *)(param_1 + 0x180) == 0) {
                        _libssh2_htonu32(param_6 + 8,0x19);
                        EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                        EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                         "SSH-2.0-libssh2_1.9.0_DEV",0x19);
                      }
                      else {
                        cnt = strlen(*(char **)(param_1 + 0x180));
                        uVar3 = (int)cnt - 2;
                        _libssh2_htonu32(param_6 + 8,(ulong)uVar3);
                        EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                        cnt = strlen(*(char **)(param_1 + 0x180));
                        EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                         *(void **)(param_1 + 0x180),cnt - 2);
                      }
                      cnt = strlen(*(char **)(param_1 + 0x110));
                      _libssh2_htonu32(param_6 + 8,cnt & 0xffffffff);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                      cnt = strlen(*(char **)(param_1 + 0x110));
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                       *(void **)(param_1 + 0x110),cnt);
                      uVar4 = *(ulong *)(param_1 + 400) & 0xffffffff;
                      _libssh2_htonu32(param_6 + 8,uVar4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                       *(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
                      uVar4 = *(ulong *)(param_1 + 0x120) & 0xffffffff;
                      _libssh2_htonu32(param_6 + 8,uVar4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                       *(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120));
                      _libssh2_htonu32(param_6 + 8,(ulong)*(uint *)(param_1 + 0xb8));
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                       *(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
                      _libssh2_htonu32(param_6 + 8,0x20);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_4,0x20);
                      _libssh2_htonu32(param_6 + 8,local_a8 & 0xffffffff);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),param_6 + 8,4);
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),local_b8,local_a8)
                      ;
                      EVP_DigestUpdate((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                       *(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
                      EVP_DigestFinal((EVP_MD_CTX *)CONCAT44(uStack148,local_98),
                                      (uchar *)(param_6 + 8),(uint *)0x0);
                      EVP_MD_CTX_free(CONCAT44(uStack148,local_98));
                      iVar1 = ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x28))
                                        (param_1,*(undefined8 *)(param_6 + 0x2e),
                                         *(undefined8 *)(param_6 + 0x34),param_6 + 8,0x20,
                                         param_1 + 0xa8);
                      if (iVar1 != 0) {
                        local_c0 = -1;
                      }
                      if (local_c0 == 0) {
                        *(undefined *)(param_6 + 0x18) = 0x15;
                        *param_6 = 3;
                        goto LAB_00123470;
                      }
                      local_c4 = _libssh2_error(param_1,0xfffffff5,
                                                "Unable to verify hostkey signature");
                    }
                  }
                  else {
                    local_c4 = _libssh2_error(param_1,0xfffffffb,
                                              "Unable to create ECDH shared secret");
                  }
                }
                else {
                  local_c4 = _libssh2_error(param_1,0xfffffff6,
                                            "Unexpected curve25519 server sig length");
                }
              }
              else {
                local_c4 = _libssh2_error(param_1,0xfffffff6,
                                          "Unexpected curve25519 server public key length");
              }
            }
            else {
              local_c4 = _libssh2_error(param_1,0xfffffff2,"Unexpected key length");
            }
          }
          else {
            local_c4 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
          }
        }
      }
      else {
        local_c4 = _libssh2_error(param_1,0xfffffff2,"Unexpected key length");
      }
    }
  }
  else {
LAB_00123470:
    if (*param_6 == 3) {
      uVar3 = _libssh2_transport_send(param_1,param_6 + 0x18,1,0,0);
      if (uVar3 == 0xffffffdb) {
        uVar4 = 0xffffffdb;
        goto LAB_00124736;
      }
      if (uVar3 != 0) {
        local_c4 = _libssh2_error(param_1,(ulong)uVar3,"Unable to send NEWKEYS message",(ulong)uVar3
                                 );
        goto LAB_001246ae;
      }
      *param_6 = 5;
    }
    if (*param_6 == 5) {
      uVar3 = _libssh2_packet_require(param_1,0x15,param_6 + 6,param_6 + 0x1e,0,0,0,param_6 + 0x38);
      if (uVar3 == 0xffffffdb) {
        uVar4 = 0xffffffdb;
        goto LAB_00124736;
      }
      if (uVar3 == 0) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_6 + 6),param_1,*(undefined8 *)(param_6 + 6),param_1);
        if (*(long *)(param_1 + 0x88) == 0) {
          local_30 = 0x20;
          uVar6 = ((void*(*)())(param_1 + 8))(0x20,param_1,0x20,param_1);
          *(undefined8 *)(param_1 + 0x88) = uVar6;
          if (*(long *)(param_1 + 0x88) == 0) {
            local_c4 = _libssh2_error(param_1,0xfffffffa,
                                      "Unable to allxcocate buffer for SHA digest");
            goto LAB_001246ae;
          }
          memcpy(*(void **)(param_1 + 0x88),param_6 + 8,local_30);
          *(undefined4 *)(param_1 + 0x90) = (int)local_30;
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
          ((void*(*)())(*(long *)(param_1 + 0x198) + 0x38))
                    (param_1,param_1 + 0x1a0,param_1,param_1 + 0x1a0);
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_00123b94:
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
            ((void*(*)())(*(long *)(param_1 + 0x128) + 0x38))
                      (param_1,param_1 + 0x130,param_1,param_1 + 0x130);
          }
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_00124056:
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
              ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x20))
                        (param_1,param_1 + 0x1b8,param_1,param_1 + 0x1b8);
            }
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
              local_50 = (void *)0x0;
              local_98 = 0;
              local_48 = 0;
              lVar7 = (long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) + 0x20);
              local_50 = (void *)((void*(*)())(param_1 + 8))(lVar7,param_1,lVar7,param_1);
              if (local_50 != (void *)0x0) {
                while (local_48 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc)) {
                  _libssh2_sha256_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
                  EVP_DigestUpdate(local_28,param_6 + 8,0x20);
                  if (local_48 == 0) {
                    EVP_DigestUpdate(local_28,&DAT_00146ad9,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_50,local_48);
                  }
                  EVP_DigestFinal(local_28,(uchar *)((long)local_50 + local_48),(uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_48 = local_48 + 0x20;
                }
              }
              if (local_50 == (void *)0x0) {
                local_c4 = 0xfffffffb;
                goto LAB_001246ae;
              }
              ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x10))
                        (param_1,local_50,&local_98,param_1 + 0x1b8);
              if (local_98 != 0) {
                lVar7 = (long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                _libssh2_explicit_zero(local_50,lVar7);
                ((void*(*)())(param_1 + 0x18))(local_50,param_1,local_50,param_1);
              }
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
              ((void*(*)())(*(long *)(param_1 + 0x138) + 0x20))
                        (param_1,param_1 + 0x148,param_1,param_1 + 0x148);
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
              local_40 = (void *)0x0;
              local_98 = 0;
              local_38 = 0;
              lVar7 = (long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) + 0x20);
              local_40 = (void *)((void*(*)())(param_1 + 8))(lVar7,param_1,lVar7,param_1);
              if (local_40 != (void *)0x0) {
                while (local_38 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc)) {
                  _libssh2_sha256_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
                  EVP_DigestUpdate(local_28,param_6 + 8,0x20);
                  if (local_38 == 0) {
                    EVP_DigestUpdate(local_28,&DAT_00146adb,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_40,local_38);
                  }
                  EVP_DigestFinal(local_28,(uchar *)((long)local_40 + local_38),(uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_38 = local_38 + 0x20;
                }
              }
              if (local_40 == (void *)0x0) {
                local_c4 = 0xfffffffb;
                goto LAB_001246ae;
              }
              ((void*(*)())(*(long *)(param_1 + 0x138) + 0x10))
                        (param_1,local_40,&local_98,param_1 + 0x148);
              if (local_98 != 0) {
                lVar7 = (long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                _libssh2_explicit_zero(local_40,lVar7);
                ((void*(*)())(param_1 + 0x18))(local_40,param_1,local_40,param_1);
              }
            }
            if ((*(long *)(param_1 + 0x1c0) != 0) &&
               (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
              ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8,param_1);
            }
            if (((*(long *)(param_1 + 0x1c0) == 0) ||
                (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
               (iVar1 = ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x10))
                                  (param_1,1,param_1 + 0x1c8,param_1), iVar1 == 0)) {
              if ((*(long *)(param_1 + 0x150) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                ((void*(*)())(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158,param_1);
              }
              if (((*(long *)(param_1 + 0x150) != 0) &&
                  (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                 (iVar1 = ((void*(*)())(*(long *)(param_1 + 0x150) + 0x10))
                                    (param_1,0,param_1 + 0x158,param_1), iVar1 != 0)) {
                local_c4 = 0xfffffffb;
              }
            }
            else {
              local_c4 = 0xfffffffb;
            }
          }
          else {
            local_70 = (void *)0x0;
            local_68 = (void *)0x0;
            local_a0[0] = 0;
            local_98 = 0;
            local_60 = 0;
            lVar7 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) + 0x20);
            local_70 = (void *)((void*(*)())(param_1 + 8))(lVar7,param_1,lVar7,param_1);
            if (local_70 != (void *)0x0) {
              while (local_60 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14)) {
                _libssh2_sha256_init(&local_28);
                EVP_DigestUpdate(local_28,*(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
                EVP_DigestUpdate(local_28,param_6 + 8,0x20);
                if (local_60 == 0) {
                  EVP_DigestUpdate(local_28,&DAT_00146ad5,1);
                  EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_28,local_70,local_60);
                }
                EVP_DigestFinal(local_28,(uchar *)((long)local_70 + local_60),(uint *)0x0);
                EVP_MD_CTX_free(local_28);
                local_60 = local_60 + 0x20;
              }
            }
            if (local_70 == (void *)0x0) {
              local_c4 = 0xfffffffb;
            }
            else {
              local_58 = 0;
              if (local_68 == (void *)0x0) {
                lVar7 = (long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) + 0x20);
                local_68 = (void *)((void*(*)())(param_1 + 8))(lVar7,param_1,lVar7,param_1);
              }
              if (local_68 != (void *)0x0) {
                while (local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18)) {
                  _libssh2_sha256_init(&local_28);
                  EVP_DigestUpdate(local_28,*(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
                  EVP_DigestUpdate(local_28,param_6 + 8,0x20);
                  if (local_58 == 0) {
                    EVP_DigestUpdate(local_28,&DAT_00146ad7,1);
                    EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_28,local_68,local_58);
                  }
                  EVP_DigestFinal(local_28,(uchar *)((long)local_68 + local_58),(uint *)0x0);
                  EVP_MD_CTX_free(local_28);
                  local_58 = local_58 + 0x20;
                }
              }
              if (local_68 == (void *)0x0) {
                ((void*(*)())(param_1 + 0x18))(local_70,param_1,local_70,param_1);
                local_c4 = 0xfffffffb;
              }
              else {
                iVar1 = ((void*(*)())(*(long *)(param_1 + 0x128) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x128),local_70,local_a0,
                                   local_68,&local_98,0,param_1 + 0x130);
                if (iVar1 == 0) {
                  if (local_a0[0] != 0) {
                    lVar7 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    _libssh2_explicit_zero(local_70,lVar7);
                    ((void*(*)())(param_1 + 0x18))(local_70,param_1,local_70,param_1);
                  }
                  if (local_98 != 0) {
                    lVar7 = (long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                    _libssh2_explicit_zero(local_68,lVar7);
                    ((void*(*)())(param_1 + 0x18))(local_68,param_1,local_68,param_1);
                  }
                  goto LAB_00124056;
                }
                ((void*(*)())(param_1 + 0x18))(local_70,param_1,local_70,param_1);
                ((void*(*)())(param_1 + 0x18))(local_68,param_1,local_68,param_1);
                local_c4 = 0xfffffffb;
              }
            }
          }
        }
        else {
          local_90 = (void *)0x0;
          local_88 = (void *)0x0;
          local_a0[0] = 0;
          local_98 = 0;
          local_80 = 0;
          lVar7 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x20);
          local_90 = (void *)((void*(*)())(param_1 + 8))(lVar7,param_1,lVar7,param_1);
          if (local_90 != (void *)0x0) {
            while (local_80 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14)) {
              _libssh2_sha256_init(&local_28);
              EVP_DigestUpdate(local_28,*(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
              EVP_DigestUpdate(local_28,param_6 + 8,0x20);
              if (local_80 == 0) {
                EVP_DigestUpdate(local_28,&DAT_00146ad1,1);
                EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                 (ulong)*(uint *)(param_1 + 0x90));
              }
              else {
                EVP_DigestUpdate(local_28,local_90,local_80);
              }
              EVP_DigestFinal(local_28,(uchar *)((long)local_90 + local_80),(uint *)0x0);
              EVP_MD_CTX_free(local_28);
              local_80 = local_80 + 0x20;
            }
          }
          if (local_90 == (void *)0x0) {
            local_c4 = 0xffffffff;
          }
          else {
            local_78 = 0;
            if (local_88 == (void *)0x0) {
              lVar7 = (long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) + 0x20);
              local_88 = (void *)((void*(*)())(param_1 + 8))(lVar7,param_1,lVar7,param_1);
            }
            if (local_88 != (void *)0x0) {
              while (local_78 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18)) {
                _libssh2_sha256_init(&local_28);
                EVP_DigestUpdate(local_28,*(void **)(param_6 + 0x2c),*(size_t *)(param_6 + 0x32));
                EVP_DigestUpdate(local_28,param_6 + 8,0x20);
                if (local_78 == 0) {
                  EVP_DigestUpdate(local_28,&DAT_00146ad3,1);
                  EVP_DigestUpdate(local_28,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_28,local_88,local_78);
                }
                EVP_DigestFinal(local_28,(uchar *)((long)local_88 + local_78),(uint *)0x0);
                EVP_MD_CTX_free(local_28);
                local_78 = local_78 + 0x20;
              }
            }
            if (local_88 == (void *)0x0) {
              ((void*(*)())(param_1 + 0x18))(local_90,param_1,local_90,param_1);
              local_c4 = 0xfffffffb;
            }
            else {
              iVar1 = ((void*(*)())(*(long *)(param_1 + 0x198) + 0x28))
                                (param_1,*(undefined8 *)(param_1 + 0x198),local_90,local_a0,local_88
                                 ,&local_98,1,param_1 + 0x1a0);
              if (iVar1 == 0) {
                if (local_a0[0] != 0) {
                  lVar7 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  _libssh2_explicit_zero(local_90,lVar7);
                  ((void*(*)())(param_1 + 0x18))(local_90,param_1,local_90,param_1);
                }
                if (local_98 != 0) {
                  lVar7 = (long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                  _libssh2_explicit_zero(local_88,lVar7);
                  ((void*(*)())(param_1 + 0x18))(local_88,param_1,local_88,param_1);
                }
                goto LAB_00123b94;
              }
              ((void*(*)())(param_1 + 0x18))(local_90,param_1,local_90,param_1);
              ((void*(*)())(param_1 + 0x18))(local_88,param_1,local_88,param_1);
              local_c4 = 0xfffffffb;
            }
          }
        }
      }
      else {
        local_c4 = _libssh2_error(param_1,(ulong)uVar3,"Timed out waiting for NEWKEYS",(ulong)uVar3)
        ;
      }
    }
  }
LAB_001246ae:
  BN_clear_free(*(BIGNUM **)(param_6 + 0x28));
  *(undefined8 *)(param_6 + 0x28) = 0;
  if (*(long *)(param_6 + 0x2c) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_6 + 0x2c),param_1,*(undefined8 *)(param_6 + 0x2c),param_1);
    *(undefined8 *)(param_6 + 0x2c) = 0;
  }
  *param_6 = 0;
  uVar4 = (ulong)local_c4;
LAB_00124736:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong FUN_0012474c(long param_1,int *param_2)

{
  uint uVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_20;
  int local_1c;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = 0;
  if (*param_2 == 0) {
    *(undefined8 *)(param_2 + 0x90) = 0;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    local_18 = 0;
    local_1c = strcmp(**(char ***)(param_1 + 0x78),"curve25519-sha256@libssh.org");
    if (local_1c != 0) {
      local_1c = strcmp(**(char ***)(param_1 + 0x78),"curve25519-sha256");
    }
    if (local_1c == 0) {
      uVar1 = _libssh2_curve25519_new(param_1,0,param_2 + 0x94,param_2 + 0x96);
      if (uVar1 == 0) {
        *(undefined *)(param_2 + 0x48) = 0x1e;
        local_18 = (long)param_2 + 0x121;
        _libssh2_store_str(&local_18,*(undefined8 *)(param_2 + 0x94),0x20);

        *(undefined8 *)(param_2 + 0x8a) = 0x25;
        *param_2 = 3;
        goto LAB_001248bf;
      }
      local_20 = _libssh2_error(param_1,(ulong)uVar1,"Unable to create private key",(ulong)uVar1);
    }
    else {
      local_20 = _libssh2_error(param_1,0xffffffff,"Unknown KEX curve25519 curve type");
    }
  }
  else {
LAB_001248bf:
    if (*param_2 == 3) {
      uVar1 = _libssh2_transport_send(param_1,param_2 + 0x48,*(undefined8 *)(param_2 + 0x8a),0,0);
      if (uVar1 == 0xffffffdb) {
        uVar2 = 0xffffffdb;
        goto LAB_00124b07;
      }
      if (uVar1 != 0) {
        local_20 = _libssh2_error(param_1,(ulong)uVar1,"Unable to send ECDH_INIT",(ulong)uVar1);
        goto LAB_00124a4e;
      }
      *param_2 = 4;
    }
    if (*param_2 == 4) {
      uVar1 = _libssh2_packet_require(param_1,0x1f,param_2 + 0x88,param_2 + 0x8c,0,0,0,param_2 + 2);
      if (uVar1 == 0xffffffdb) {
        uVar2 = 0xffffffdb;
        goto LAB_00124b07;
      }
      if (uVar1 != 0) {
        local_20 = _libssh2_error(param_1,(ulong)uVar1,"Timeout waiting for ECDH_REPLY reply",
                                  (ulong)uVar1);
        goto LAB_00124a4e;
      }
      *param_2 = 5;
    }
    if (*param_2 == 5) {
      local_20 = FUN_0012287b(param_1,*(undefined8 *)(param_2 + 0x88),
                              *(undefined8 *)(param_2 + 0x8c),*(undefined8 *)(param_2 + 0x94),
                              *(undefined8 *)(param_2 + 0x96),param_2 + 6);
      if (local_20 == 0xffffffdb) {
        uVar2 = 0xffffffdb;
        goto LAB_00124b07;
      }
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x88),param_1,*(undefined8 *)(param_2 + 0x88),param_1);
    }
  }
LAB_00124a4e:
  if (*(long *)(param_2 + 0x94) != 0) {
    _libssh2_explicit_zero(*(undefined8 *)(param_2 + 0x94),0x20);
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_2 + 0x94),param_1,*(undefined8 *)(param_2 + 0x94),param_1);
    *(undefined8 *)(param_2 + 0x94) = 0;
  }
  if (*(long *)(param_2 + 0x96) != 0) {
    _libssh2_explicit_zero(*(undefined8 *)(param_2 + 0x96),0x20);
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_2 + 0x96),param_1,*(undefined8 *)(param_2 + 0x96),param_1);
    *(undefined8 *)(param_2 + 0x96) = 0;
  }
  *param_2 = 0;
  uVar2 = (ulong)local_20;
LAB_00124b07:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



long FUN_00124b1d(long **param_1)

{
  size_t sVar1;
  long **local_20;
  long local_10;
  
  local_10 = 0;
  if ((param_1 == (long **)0x0) || (local_20 = param_1, *param_1 == (long *)0x0)) {
    local_10 = 0;
  }
  else {
    while ((*local_20 != (long *)0x0 && (**local_20 != 0))) {
      sVar1 = strlen((char *)**local_20);
      local_10 = local_10 + sVar1 + 1;
      local_20 = local_20 + 1;
    }
    local_10 = local_10 + -1;
  }
  return local_10;
}



long FUN_00124b99(long param_1,ulong param_2,long **param_3)

{
  undefined *puVar1;
  long lVar2;
  size_t sVar3;
  long **local_30;
  undefined *local_20;
  
  _libssh2_htonu32(param_1,param_2 & 0xffffffff);
  local_20 = (undefined *)(param_1 + 4);
  if ((param_3 == (long **)0x0) || (local_30 = param_3, *param_3 == (long *)0x0)) {
    lVar2 = 4;
  }
  else {
    while ((*local_30 != (long *)0x0 && (**local_30 != 0))) {
      sVar3 = strlen((char *)**local_30);
      memcpy(local_20,(void *)**local_30,(long)(int)sVar3);
      puVar1 = local_20 + (int)sVar3;
      local_20 = puVar1 + 1;
      *puVar1 = 0x2c;
      local_30 = local_30 + 1;
    }
    lVar2 = param_2 + 4;
  }
  return lVar2;
}



// WARNING: Type propagation algorithm not settling

undefined8 FUN_00124c56(long param_1)

{
  uint uVar1;
  ulong __n;
  ulong __n_00;
  ulong __n_01;
  ulong __n_02;
  ulong __n_03;
  ulong __n_04;
  ulong __n_05;
  ulong __n_06;
  ulong __n_07;
  ulong __n_08;
  undefined8 uVar2;
  long lVar3;
  long local_70;
  undefined *local_68;
  undefined *local_60;
  
  if (*(int *)(param_1 + 0xcc70) == 0) {
    if (*(long *)(param_1 + 0x58) == 0) {
      __n = FUN_00124b1d(&PTR_PTR_s_ecdh_sha2_nistp256_00350a40);
    }
    else {
      __n = strlen(*(char **)(param_1 + 0x58));
    }
    if (*(long *)(param_1 + 0x60) == 0) {
      uVar2 = libssh2_hostkey_methods();
      __n_00 = FUN_00124b1d(uVar2);
    }
    else {
      __n_00 = strlen(*(char **)(param_1 + 0x60));
    }
    if (*(long *)(param_1 + 0x1d0) == 0) {
      uVar2 = libssh2_crypt_methods();
      __n_01 = FUN_00124b1d(uVar2);
    }
    else {
      __n_01 = strlen(*(char **)(param_1 + 0x1d0));
    }
    if (*(long *)(param_1 + 0x160) == 0) {
      uVar2 = libssh2_crypt_methods();
      __n_02 = FUN_00124b1d(uVar2);
    }
    else {
      __n_02 = strlen(*(char **)(param_1 + 0x160));
    }
    if (*(long *)(param_1 + 0x1d8) == 0) {
       _libssh2_mac_methods();
      __n_03 = FUN_00124b1d(uVar2);
    }
    else {
      __n_03 = strlen(*(char **)(param_1 + 0x1d8));
    }
    if (*(long *)(param_1 + 0x168) == 0) {
       _libssh2_mac_methods();
      __n_04 = FUN_00124b1d(uVar2);
    }
    else {
      __n_04 = strlen(*(char **)(param_1 + 0x168));
    }
    if (*(long *)(param_1 + 0x1e0) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      __n_05 = FUN_00124b1d(uVar2);
    }
    else {
      __n_05 = strlen(*(char **)(param_1 + 0x1e0));
    }
    if (*(long *)(param_1 + 0x170) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      __n_06 = FUN_00124b1d(uVar2);
    }
    else {
      __n_06 = strlen(*(char **)(param_1 + 0x170));
    }
    if (*(long *)(param_1 + 0x1e8) == 0) {
      __n_07 = FUN_00124b1d(0);
    }
    else {
      __n_07 = strlen(*(char **)(param_1 + 0x1e8));
    }
    if (*(long *)(param_1 + 0x178) == 0) {
      __n_08 = FUN_00124b1d(0);
    }
    else {
      __n_08 = strlen(*(char **)(param_1 + 0x178));
    }
    local_70 = __n_08 + __n + __n_00 + __n_01 + __n_02 + __n_05 + __n_06 + __n_03 + __n_04 + __n_07
               + 0x3e;
    local_68 = (undefined *)((void*(*)())(param_1 + 8))(local_70,param_1,local_70,param_1);
    if (local_68 == (undefined *)0x0) {
      uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory");
      return uVar2;
    }
    *local_68 = 0x14;
    RAND_bytes(local_68 + 1,0x10);
    local_60 = local_68 + 0x11;
    if (*(long *)(param_1 + 0x58) == 0) {
      lVar3 = FUN_00124b99(local_60,__n,&PTR_PTR_s_ecdh_sha2_nistp256_00350a40);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n & 0xffffffff);
      memcpy(local_68 + 0x15,*(void **)(param_1 + 0x58),__n);
      local_60 = local_68 + 0x15 + __n;
    }
    if (*(long *)(param_1 + 0x60) == 0) {
      uVar2 = libssh2_hostkey_methods();
      lVar3 = FUN_00124b99(local_60,__n_00,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_00 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x60),__n_00);
      local_60 = local_60 + 4 + __n_00;
    }
    if (*(long *)(param_1 + 0x1d0) == 0) {
      uVar2 = libssh2_crypt_methods();
      lVar3 = FUN_00124b99(local_60,__n_01,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_01 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1d0),__n_01);
      local_60 = local_60 + 4 + __n_01;
    }
    if (*(long *)(param_1 + 0x160) == 0) {
      uVar2 = libssh2_crypt_methods();
      lVar3 = FUN_00124b99(local_60,__n_02,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_02 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x160),__n_02);
      local_60 = local_60 + 4 + __n_02;
    }
    if (*(long *)(param_1 + 0x1d8) == 0) {
      _libssh2_mac_methods();
      lVar3 = FUN_00124b99(local_60,__n_03,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_03 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1d8),__n_03);
      local_60 = local_60 + 4 + __n_03;
    }
    if (*(long *)(param_1 + 0x168) == 0) {
      _libssh2_mac_methods();
      lVar3 = FUN_00124b99(local_60,__n_04,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_04 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x168),__n_04);
      local_60 = local_60 + 4 + __n_04;
    }
    if (*(long *)(param_1 + 0x1e0) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      lVar3 = FUN_00124b99(local_60,__n_05,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_05 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1e0),__n_05);
      local_60 = local_60 + 4 + __n_05;
    }
    if (*(long *)(param_1 + 0x170) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      lVar3 = FUN_00124b99(local_60,__n_06,uVar2);
      local_60 = (undefined *)((long)local_60 + lVar3);
    }
    else {
      _libssh2_htonu32(local_60,__n_06 & 0xffffffff);
      memcpy((void *)((long)local_60 + 4),*(void **)(param_1 + 0x170),__n_06);
      local_60 = (undefined *)((long)(void *)((long)local_60 + 4) + __n_06);
    }
    if (*(long *)(param_1 + 0x1e8) == 0) {
      lVar3 = FUN_00124b99(local_60,__n_07,0);
      local_60 = (undefined *)((long)local_60 + lVar3);
    }
    else {
      _libssh2_htonu32(local_60,__n_07 & 0xffffffff);
      memcpy((void *)((long)local_60 + 4),*(void **)(param_1 + 0x1e8),__n_07);
      local_60 = (undefined *)((long)(void *)((long)local_60 + 4) + __n_07);
    }
    if (*(long *)(param_1 + 0x178) == 0) {
      lVar3 = FUN_00124b99(local_60,__n_08,0);
      local_60 = (undefined *)((long)local_60 + lVar3);
    }
    else {
      _libssh2_htonu32(local_60,__n_08 & 0xffffffff);
      memcpy((void *)((long)local_60 + 4),*(void **)(param_1 + 0x178),__n_08);
      local_60 = (undefined *)((long)(void *)((long)local_60 + 4) + __n_08);
    }
    *local_60 = 0;
    _libssh2_htonu32(local_60 + 1,0);
    *(undefined4 *)(param_1 + 0xcc70) = 2;
  }
  else {
    local_68 = *(undefined **)(param_1 + 0xcc78);
    local_70 = *(long *)(param_1 + 0xcc80);
    *(undefined8 *)(param_1 + 0xcc78) = 0;
    *(undefined8 *)(param_1 + 0xcc80) = 0;
  }
  uVar1 = _libssh2_transport_send(param_1,local_68,local_70,0,0);
  if (uVar1 == 0xffffffdb) {
    *(undefined **)(param_1 + 0xcc78) = local_68;
    *(long *)(param_1 + 0xcc80) = local_70;
    uVar2 = 0xffffffdb;
  }
  else {
    if (uVar1 == 0) {
      if (*(long *)(param_1 + 0x188) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x188),param_1,*(undefined8 *)(param_1 + 0x188),param_1
                  );
      }
      *(undefined **)(param_1 + 0x188) = local_68;
      *(long *)(param_1 + 400) = local_70;
      *(undefined4 *)(param_1 + 0xcc70) = 0;
      uVar2 = 0;
    }
    else {
      ((void*(*)())(param_1 + 0x18))(local_68,param_1,local_68,param_1);
      *(undefined4 *)(param_1 + 0xcc70) = 0;
      uVar2 = _libssh2_error(param_1,(ulong)uVar1,"Unable to send KEXINIT packet to remote host",
                             (ulong)uVar1);
    }
  }
  return uVar2;
}



char * FUN_0012550c(char *param_1,char *param_2,char *param_3,char *param_4)

{
  int iVar1;
  char *local_10;
  
  if (param_2 < param_4) {
    param_1 = (char *)0x0;
  }
  else {
    iVar1 = strncmp(param_1,param_3,(size_t)param_4);
    local_10 = param_1;
    if ((iVar1 != 0) || ((param_4 != param_2 && (param_1[(long)param_4] != ',')))) {
      while ((local_10 = strchr(local_10,0x2c), local_10 != (char *)0x0 &&
             (param_4 < param_2 + -(long)(local_10 + -(long)param_1)))) {
        local_10 = local_10 + 1;
        iVar1 = strncmp(local_10,param_3,(size_t)param_4);
        if (iVar1 == 0) {
          if (param_2 == local_10 + (long)(param_4 + -(long)param_1)) {
            return local_10;
          }
          if (local_10[(long)param_4] == ',') {
            return local_10;
          }
        }
      }
      param_1 = (char *)0x0;
    }
  }
  return param_1;
}



char * FUN_0012561d(char *param_1,size_t param_2,char **param_3)

{
  int iVar1;
  size_t sVar2;
  char **local_20;
  
  local_20 = param_3;
  while( 1 ) {
    if (*local_20 == (char *)0x0) {
      return (char *)0;
    }
    sVar2 = strlen(*(char **)*local_20);
    if ((param_2 == sVar2) && (iVar1 = strncmp(*(char **)*local_20,param_1,param_2), iVar1 == 0))
    break;
    local_20 = local_20 + 1;
  }
  return *local_20;
}



undefined8 FUN_0012568d(long param_1,ulong param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  long lVar2;
  size_t sVar3;
  char *pcVar4;
  long **local_30;
  char *local_28;
  
  local_30 = (long **)libssh2_hostkey_methods();
  if (*(long *)(param_1 + 0x60) == 0) {
    while (((local_30 != (long **)0x0 && (*local_30 != (long *)0x0)) && (**local_30 != 0))) {
      sVar3 = strlen((char *)**local_30);
      lVar2 = FUN_0012550c(param_3,param_4,**local_30,sVar3);
      if (((lVar2 != 0) && (((param_2 & 1) == 0 || ((*local_30)[7] != 0)))) &&
         (((param_2 & 2) == 0 || ((*local_30)[5] != 0)))) {
        *(long **)(param_1 + 0xa0) = *local_30;
        return 0;
      }
      local_30 = local_30 + 1;
    }
  }
  else {
    local_28 = *(char **)(param_1 + 0x60);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        pcVar4 = (char *)strlen(local_28);
      }
      else {
        pcVar4 = pcVar1 + -(long)local_28;
      }
      lVar2 = FUN_0012550c(param_3,param_4,local_28,pcVar4);
      if (lVar2 != 0) {
        lVar2 = FUN_0012561d(local_28,pcVar4,local_30);
        if (lVar2 == 0) {
          return 0xffffffff;
        }
        if ((((param_2 & 1) == 0) || (*(long *)(lVar2 + 0x38) != 0)) &&
           (((param_2 & 2) == 0 || (*(long *)(lVar2 + 0x28) != 0)))) {
          *(long *)(param_1 + 0xa0) = lVar2;
          return 0;
        }
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8
FUN_00125897(long param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)

{
  int iVar1;
  char *pcVar2;
  long lVar3;
  long lVar4;
  size_t sVar5;
  char *pcVar6;
  undefined **local_38;
  char *local_30;
  
  local_38 = &PTR_PTR_s_ecdh_sha2_nistp256_00350a40;
  if (*(long *)(param_1 + 0x58) == 0) {
    while (((long *)*local_38 != (long *)0x0 && (*(long *)*local_38 != 0))) {
      sVar5 = strlen(*(char **)*local_38);
      lVar3 = FUN_0012550c(param_2,param_3,*(long *)*local_38,sVar5);
      if ((lVar3 != 0) &&
         (iVar1 = FUN_0012568d(param_1,*(long *)(*local_38 + 2),param_4,param_5), iVar1 == 0)) {
        *(undefined **)(param_1 + 0x78) = *local_38;
        if (((*(byte *)(param_1 + 0x80) & 1) != 0) && (param_2 == lVar3)) {
          *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
        }
        return 0;
      }
      local_38 = (undefined **)((long **)local_38 + 1);
    }
  }
  else {
    local_30 = *(char **)(param_1 + 0x58);
    while ((local_30 != (char *)0x0 && (*local_30 != '\0'))) {
      pcVar2 = strchr(local_30,0x2c);
      if (pcVar2 == (char *)0x0) {
        pcVar6 = (char *)strlen(local_30);
      }
      else {
        pcVar6 = pcVar2 + -(long)local_30;
      }
      lVar3 = FUN_0012550c(param_2,param_3,local_30,pcVar6);
      if (lVar3 != 0) {
        lVar4 = FUN_0012561d(local_30,pcVar6,&PTR_PTR_s_ecdh_sha2_nistp256_00350a40);
        if (lVar4 == 0) {
          return 0xffffffff;
        }
        iVar1 = FUN_0012568d(param_1,*(undefined8 *)(lVar4 + 0x10),param_4,param_5);
        if (iVar1 == 0) {
          *(long *)(param_1 + 0x78) = lVar4;
          if (((*(byte *)(param_1 + 0x80) & 1) != 0) && (param_2 == lVar3)) {
            *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
          }
          return 0;
        }
      }
      if (pcVar2 == (char *)0x0) {
        local_30 = (char *)0x0;
      }
      else {
        local_30 = pcVar2 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8 FUN_00125ae3(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  long lVar2;
  size_t sVar3;
  char *pcVar4;
  long **local_30;
  char *local_28;
  
  local_30 = (long **)libssh2_crypt_methods();
  if (*(long *)(param_2 + 0x50) == 0) {
    while ((*local_30 != (long *)0x0 && (**local_30 != 0))) {
      sVar3 = strlen((char *)**local_30);
      lVar2 = FUN_0012550c(param_3,param_4,**local_30,sVar3);
      if (lVar2 != 0) {
        *(long **)(param_2 + 0x18) = *local_30;
        return 0;
      }
      local_30 = local_30 + 1;
    }
  }
  else {
    local_28 = *(char **)(param_2 + 0x50);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        pcVar4 = (char *)strlen(local_28);
      }
      else {
        pcVar4 = pcVar1 + -(long)local_28;
      }
      lVar2 = FUN_0012550c(param_3,param_4,local_28,pcVar4);
      if (lVar2 != 0) {
        lVar2 = FUN_0012561d(local_28,pcVar4,local_30);
        if (lVar2 != 0) {
          *(long *)(param_2 + 0x18) = lVar2;
          return 0;
        }
        return 0xffffffff;
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8 FUN_00125c6f(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  long lVar2;
  size_t sVar3;
  char *pcVar4;
  long **local_30;
  char *local_28;
  
  _libssh2_mac_methods();
  if (*(long *)(param_2 + 0x58) == 0) {
    while ((*local_30 != (long *)0x0 && (**local_30 != 0))) {
      sVar3 = strlen((char *)**local_30);
      lVar2 = FUN_0012550c(param_3,param_4,**local_30,sVar3);
      if (lVar2 != 0) {
        *(long **)(param_2 + 0x28) = *local_30;
        return 0;
      }
      local_30 = local_30 + 1;
    }
  }
  else {
    local_28 = *(char **)(param_2 + 0x58);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        pcVar4 = (char *)strlen(local_28);
      }
      else {
        pcVar4 = pcVar1 + -(long)local_28;
      }
      lVar2 = FUN_0012550c(param_3,param_4,local_28,pcVar4);
      if (lVar2 != 0) {
        lVar2 = FUN_0012561d(local_28,pcVar4,local_30);
        if (lVar2 != 0) {
          *(long *)(param_2 + 0x28) = lVar2;
          return 0;
        }
        return 0xffffffff;
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8 FUN_00125dfb(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  long lVar2;
  size_t sVar3;
  char *pcVar4;
  long **local_30;
  char *local_28;
  
  local_30 = (long **)_libssh2_comp_methods(param_1);
  if (*(long *)(param_2 + 0x60) == 0) {
    while ((*local_30 != (long *)0x0 && (**local_30 != 0))) {
      sVar3 = strlen((char *)**local_30);
      lVar2 = FUN_0012550c(param_3,param_4,**local_30,sVar3);
      if (lVar2 != 0) {
        *(long **)(param_2 + 0x40) = *local_30;
        return 0;
      }
      local_30 = local_30 + 1;
    }
  }
  else {
    local_28 = *(char **)(param_2 + 0x60);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        pcVar4 = (char *)strlen(local_28);
      }
      else {
        pcVar4 = pcVar1 + -(long)local_28;
      }
      lVar2 = FUN_0012550c(param_3,param_4,local_28,pcVar4);
      if (lVar2 != 0) {
        lVar2 = FUN_0012561d(local_28,pcVar4,local_30);
        if (lVar2 != 0) {
          *(long *)(param_2 + 0x40) = lVar2;
          return 0;
        }
        return 0xffffffff;
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}

undefined8 _libssh2_check_length(long *param_1,ulong param_2)

{
  undefined8 uVar1;
  ulong uVar2;
  
  uVar2 = (param_1[2] + *param_1) - param_1[1];
  if ((uVar2 < param_2) || ((ulong)param_1[2] < uVar2)) {
    uVar1 = 0;
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



undefined8 FUN_00125f8e(long param_1,long param_2,uint param_3)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_80;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  long local_28;
  byte *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_3 < 0x11) {
    uVar2 = 0xffffffff;
  }
  else {
    local_18 = (ulong)param_3;
    local_20 = (byte *)(param_2 + 0x11);
    local_28 = param_2;
    iVar1 = _libssh2_get_string(&local_28,&local_a8,&local_68,&local_a8);
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_string(&local_28,&local_a0,&local_60,&local_a0);
      if (iVar1 == 0) {
        iVar1 = _libssh2_get_string(&local_28,&local_98,&local_58,&local_98);
        if (iVar1 == 0) {
          iVar1 = _libssh2_get_string(&local_28,&local_90,&local_50,&local_90);
          if (iVar1 == 0) {
            iVar1 = _libssh2_get_string(&local_28,&local_78,&local_38,&local_78);
            if (iVar1 == 0) {
              iVar1 = _libssh2_get_string(&local_28,&local_70,&local_30,&local_70);
              if (iVar1 == 0) {
                iVar1 = _libssh2_get_string(&local_28,&local_88,&local_48,&local_88);
                if (iVar1 == 0) {

                  if (iVar1 == 0) {
                    iVar1 = _libssh2_check_length(&local_28, 0);
                    if (iVar1 == 0) {
                      uVar2 = 0xffffffff;
                    }
                    else {
                      *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe | *local_20 & 1;
                      local_20 = local_20 + 1;
                      iVar1 = FUN_00125897(param_1,local_a8,local_68,local_a0,local_60);
                      if (iVar1 == 0) {
                        iVar1 = FUN_00125ae3(param_1,param_1 + 0x180,local_98,local_58);
                        if (iVar1 == 0) {
                          iVar1 = FUN_00125ae3(param_1,param_1 + 0x110,local_90,local_50);
                          if (iVar1 == 0) {
                            iVar1 = FUN_00125c6f(param_1,param_1 + 0x180,local_78,local_38);
                            if (iVar1 == 0) {
                              iVar1 = FUN_00125c6f(param_1,param_1 + 0x110,local_70,local_30);
                              if (iVar1 == 0) {
                                iVar1 = FUN_00125dfb(param_1,param_1 + 0x180,local_88,local_48);
                                if (iVar1 == 0) {
                                  iVar1 = FUN_00125dfb(param_1,param_1 + 0x110,local_80,local_40);
                                  if (iVar1 == 0) {
                                    uVar2 = 0;
                                    goto LAB_001262da;
                                  }
                                }
                                uVar2 = 0xffffffff;
                                goto LAB_001262da;
                              }
                            }
                            uVar2 = 0xffffffff;
                            goto LAB_001262da;
                          }
                        }
                        uVar2 = 0xffffffff;
                      }
                      else {
                        uVar2 = 0xffffffff;
                      }
                    }
                  }
                  else {
                    uVar2 = 0xffffffff;
                  }
                }
                else {
                  uVar2 = 0xffffffff;
                }
              }
              else {
                uVar2 = 0xffffffff;
              }
            }
            else {
              uVar2 = 0xffffffff;
            }
          }
          else {
            uVar2 = 0xffffffff;
          }
        }
        else {
          uVar2 = 0xffffffff;
        }
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
LAB_001262da:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong _libssh2_kex_exchange(long param_1,int param_2,int *param_3)

{
  int iVar1;
  uint local_10;
  
  local_10 = 0;
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 8;
  if (*param_3 == 0) {
    *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 1;
    if (param_2 != 0) {
      *(undefined8 *)(param_1 + 0x78) = 0;
      if ((*(long *)(param_1 + 0xa0) != 0) && (*(long *)(*(long *)(param_1 + 0xa0) + 0x40) != 0)) {
        ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x40))
                  (param_1,param_1 + 0xa8,param_1,param_1 + 0xa8);
      }
      *(undefined8 *)(param_1 + 0xa0) = 0;
    }
    *param_3 = 2;
  }
  if ((*(long *)(param_1 + 0x78) == 0) || (*(long *)(param_1 + 0xa0) == 0)) {
    if (*param_3 == 2) {
      *(undefined8 *)(param_3 + 0xa2) = *(undefined8 *)(param_1 + 0x188);
      *(undefined8 *)(param_3 + 0xa4) = *(undefined8 *)(param_1 + 400);
      *(undefined8 *)(param_1 + 0x188) = 0;
      *param_3 = 3;
    }
    if (*param_3 == 3) {
      iVar1 = FUN_00124c56(param_1);
      if (iVar1 == -0x25) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        return 0xffffffdb;
      }
      if (iVar1 != 0) {
        *(undefined8 *)(param_1 + 0x188) = *(undefined8 *)(param_3 + 0xa2);
        *(undefined8 *)(param_1 + 400) = *(undefined8 *)(param_3 + 0xa4);
        *param_3 = 0;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
        return 0xffffffff;
      }
      *param_3 = 4;
    }
    if (*param_3 == 4) {
      iVar1 = _libssh2_packet_require(param_1,0x14,param_3 + 0x9e,param_3 + 0xa0,0,0,0,param_3 + 2);
      if (iVar1 == -0x25) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        return 0xffffffdb;
      }
      if (iVar1 != 0) {
        if (*(long *)(param_1 + 0x188) != 0) {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0x188),param_1,*(undefined8 *)(param_1 + 0x188),
                     param_1);
        }
        *(undefined8 *)(param_1 + 0x188) = *(undefined8 *)(param_3 + 0xa2);
        *(undefined8 *)(param_1 + 400) = *(undefined8 *)(param_3 + 0xa4);
        *param_3 = 0;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
        return 0xffffffff;
      }
      if (*(long *)(param_1 + 0x118) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x118),param_1,*(undefined8 *)(param_1 + 0x118),param_1
                  );
      }
      *(undefined8 *)(param_1 + 0x118) = *(undefined8 *)(param_3 + 0x9e);
      *(undefined8 *)(param_1 + 0x120) = *(undefined8 *)(param_3 + 0xa0);
      iVar1 = FUN_00125f8e(param_1,*(undefined8 *)(param_3 + 0x9e),
                           *(ulong *)(param_3 + 0xa0) & 0xffffffff);
      if (iVar1 != 0) {
        local_10 = 0xfffffffb;
      }
      *param_3 = 5;
    }
  }
  else {
    *param_3 = 5;
  }
  if (((local_10 == 0) && (*(long *)(param_1 + 0x78) != 0)) && (*param_3 == 5)) {
    iVar1 = ((void*(*)())(*(long *)(param_1 + 0x78) + 8))(param_1,param_3 + 6,param_1,param_3 + 6);
    if (iVar1 == -0x25) {
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
      return 0xffffffdb;
    }
    if (iVar1 != 0) {
      local_10 = _libssh2_error(param_1,0xfffffff8,"Unrecoverable error exchanging keys");
    }
  }
  if (*(long *)(param_1 + 0x188) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0x188),param_1,*(undefined8 *)(param_1 + 0x188),param_1);
    *(undefined8 *)(param_1 + 0x188) = 0;
  }
  if (*(long *)(param_1 + 0x118) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0x118),param_1,*(undefined8 *)(param_1 + 0x118),param_1);
    *(undefined8 *)(param_1 + 0x118) = 0;
  }
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
  *param_3 = 0;
  return (ulong)local_10;
}



undefined8 libssh2_session_method_pref(long param_1,undefined4 param_2,char *param_3)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  char *__dest;
  char *pcVar4;
  long lVar5;
  char **local_30;
  char *local_28;
  undefined **local_20;
  
  sVar2 = strlen(param_3);
  switch(param_2) {
  case 0:
    local_30 = (char **)(param_1 + 0x58);
    local_20 = &PTR_PTR_s_ecdh_sha2_nistp256_00350a40;
    break;
  case 1:
    local_30 = (char **)(param_1 + 0x60);
    local_20 = (undefined **)libssh2_hostkey_methods();
    break;
  case 2:
    local_30 = (char **)(param_1 + 0x1d0);
    local_20 = (undefined **)libssh2_crypt_methods();
    break;
  case 3:
    local_30 = (char **)(param_1 + 0x160);
    local_20 = (undefined **)libssh2_crypt_methods();
    break;
  case 4:
    local_30 = (char **)(param_1 + 0x1d8);
    _libssh2_mac_methods();
    break;
  case 5:
    local_30 = (char **)(param_1 + 0x168);
    _libssh2_mac_methods();
    break;
  case 6:
    local_30 = (char **)(param_1 + 0x1e0);
    local_20 = (undefined **)_libssh2_comp_methods(param_1);
    break;
  case 7:
    local_30 = (char **)(param_1 + 0x170);
    local_20 = (undefined **)_libssh2_comp_methods(param_1);
    break;
  case 8:
    local_30 = (char **)(param_1 + 0x1e8);
    local_20 = (undefined **)0x0;
    break;
  case 9:
    local_30 = (char **)(param_1 + 0x178);
    local_20 = (undefined **)0x0;
    break;
  default:
    uVar3 = _libssh2_error(param_1,0xffffffde,"Invalid parameter specified for method_type");
    return uVar3;
  }
  lVar5 = (long)((int)sVar2 + 1);
  __dest = (char *)((void*(*)())(param_1 + 8))(lVar5,param_1,lVar5,param_1);
  if (__dest == (char *)0x0) {
    uVar3 = _libssh2_error(param_1,0xfffffffa,"Error allocated space for method preferences");
  }
  else {
    memcpy(__dest,param_3,(long)((int)sVar2 + 1));
    local_28 = __dest;
    while (((local_28 != (char *)0x0 && (*local_28 != '\0')) && (local_20 != (undefined **)0x0))) {
      pcVar4 = strchr(local_28,0x2c);
      if (pcVar4 == (char *)0x0) {
        sVar2 = strlen(local_28);
        iVar1 = (int)sVar2;
      }
      else {
        iVar1 = (int)pcVar4 - (int)local_28;
      }
      lVar5 = FUN_0012561d(local_28,(long)iVar1,local_20);
      if (lVar5 == 0) {
        if (pcVar4 == (char *)0x0) {
          if (__dest < local_28) {
            local_28 = local_28 + -1;
            *local_28 = '\0';
          }
          else {
            *local_28 = '\0';
          }
        }
        else {
          sVar2 = strlen(local_28);
          memcpy(local_28,pcVar4 + 1,sVar2 - (long)iVar1);
        }
      }
      else {
        if (pcVar4 == (char *)0x0) {
          local_28 = (char *)0x0;
        }
        else {
          local_28 = pcVar4 + 1;
        }
      }
    }
    if (*__dest == '\0') {
      ((void*(*)())(param_1 + 0x18))(__dest,param_1,__dest,param_1);
      uVar3 = _libssh2_error(param_1,0xffffffdf,
                             "The requested method(s) are not currently supported");
    }
    else {
      if (*local_30 != (char *)0x0) {
        ((void*(*)())(param_1 + 0x18))(*local_30,param_1,*local_30,param_1);
      }
      *local_30 = __dest;
      uVar3 = 0;
    }
  }
  return uVar3;
}



ulong libssh2_session_supported_algs(long param_1,undefined4 param_2,long *param_3)

{
  ulong uVar1;
  undefined8 uVar2;
  long lVar3;
  uint local_1c;
  uint local_18;
  uint local_14;
  undefined **local_10;
  
  if (param_3 == (long *)0x0) {
    uVar1 = _libssh2_error(param_1,0xffffffd9,"algs must not be NULL");
  }
  else {
    switch(param_2) {
    case 0:
      local_10 = &PTR_PTR_s_ecdh_sha2_nistp256_00350a40;
      break;
    case 1:
      local_10 = (undefined **)libssh2_hostkey_methods();
      break;
    case 2:
    case 3:
      local_10 = (undefined **)libssh2_crypt_methods();
      break;
    case 4:
    case 5:
      _libssh2_mac_methods();
      break;
    case 6:
    case 7:
      local_10 = (undefined **)_libssh2_comp_methods(param_1);
      break;
    default:
      uVar2 = _libssh2_error(param_1,0xffffffdf,"Unknown method type");
      return uVar2;
    }
    if (local_10 == (undefined **)0x0) {
      uVar1 = _libssh2_error(param_1,0xffffffde,"No algorithm found");
    }
    else {
      local_1c = 0;
      local_14 = 0;
      while (local_10[local_1c] != (undefined *)0x0) {
        if (*(long *)local_10[local_1c] != 0) {
          local_14 = local_14 + 1;
        }
        local_1c = local_1c + 1;
      }
      if (local_14 == 0) {
        uVar1 = _libssh2_error(param_1,0xffffffde,"No algorithm found");
      }
      else {
        lVar3 = ((void*(*)())(param_1 + 8))((ulong)local_14 << 3,param_1,param_1);
        *param_3 = lVar3;
        if (*param_3 == 0) {
          uVar1 = _libssh2_error(param_1,0xfffffffa,"Memory allocation failed");
        }
        else {
          local_1c = 0;
          local_18 = 0;
          while ((local_10[local_1c] != (undefined *)0x0 && (local_18 < local_14))) {
            if (*(long *)local_10[local_1c] != 0) {
              *(undefined8 *)(*param_3 + (ulong)local_18 * 8) = *(undefined8 *)local_10[local_1c];
              local_18 = local_18 + 1;
            }
            local_1c = local_1c + 1;
          }
          if (local_18 == local_14) {
            uVar1 = (ulong)local_14;
          }
          else {
            ((void*(*)())(param_1 + 0x18))(*param_3,param_1,*param_3,param_1);
            *param_3 = 0;
            uVar1 = _libssh2_error(param_1,0xffffffd9,"Internal error");
          }
        }
      }
    }
  }
  return uVar1;
}



void FUN_00126d8d(long param_1,long param_2)

{
  if (param_2 != 0) {
    if (*(long *)(param_2 + 0x58) != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x58),param_1,*(undefined8 *)(param_2 + 0x58),param_1);
    }
    if (*(long *)(param_2 + 0x48) != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x48),param_1,*(undefined8 *)(param_2 + 0x48),param_1);
    }
    if (*(long *)(param_2 + 0x40) != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x40),param_1,*(undefined8 *)(param_2 + 0x40),param_1);
    }
    if (*(long *)(param_2 + 0x30) != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x30),param_1,*(undefined8 *)(param_2 + 0x30),param_1);
    }
    if (*(long *)(param_2 + 0x18) != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_2 + 0x18),param_1,*(undefined8 *)(param_2 + 0x18),param_1);
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
  }
  return;
}



long * libssh2_knownhost_init(long param_1)

{
  long *plVar1;
  
  plVar1 = (long *)((void*(*)())(param_1 + 8))(0x18,param_1,param_1);
  if (plVar1 == (long *)0x0) {
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for known-hosts collection");
    plVar1 = (long *)0x0;
  }
  else {
    *plVar1 = param_1;
    _libssh2_list_init(plVar1 + 1);
  }
  return plVar1;
}



undefined4 * FUN_00126efd(long param_1)

{
  undefined8 uVar1;
  
  *(undefined4 *)(param_1 + 0x68) = 0xdeadcafe;
  *(long *)(param_1 + 0x70) = param_1;
  if ((*(uint *)(param_1 + 0x2c) & 0xffff) == 1) {
    uVar1 = *(undefined8 *)(param_1 + 0x18);
  }
  else {
    uVar1 = 0;
  }
  *(undefined8 *)(param_1 + 0x78) = uVar1;
  *(undefined8 *)(param_1 + 0x80) = *(undefined8 *)(param_1 + 0x40);
  *(undefined4 *)(param_1 + 0x88) = *(undefined4 *)(param_1 + 0x2c);
  return (undefined4 *)(param_1 + 0x68);
}



ulong FUN_00126f71(long *param_1,char *param_2,char *param_3,void *param_4,size_t param_5,
                  char *param_6,size_t param_7,void *param_8,long param_9,uint param_10,
                  undefined8 *param_11)

{
  uint uVar1;
  ulong uVar2;
  undefined8 uVar3;
  size_t sVar4;
  long in_FS_OFFSET;
  uint local_38;
  uint local_34;
  undefined8 local_30;
  size_t local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = strlen(param_2);
  if ((param_10 & 0x3c0000) == 0) {
    uVar2 = _libssh2_error(*param_1,0xffffffde,"No key type set");
    goto LAB_0012747e;
  }
  local_20 = _libssh2_calloc(*param_1,0x90);
  if (local_20 == 0) {
    uVar2 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for known host entry");
    goto LAB_0012747e;
  }
  *(uint *)(local_20 + 0x2c) = param_10;
  uVar1 = *(uint *)(local_20 + 0x2c) & 0xffff;
  if (uVar1 == 2) {
    local_34 = libssh2_base64_decode(*param_1,&local_30,&local_38,param_2,local_28 & 0xffffffff);
    if (local_34 == 0) {
      *(undefined8 *)(local_20 + 0x18) = local_30;
      *(ulong *)(local_20 + 0x20) = (ulong)local_38;
      sVar4 = strlen(param_3);
      local_34 = libssh2_base64_decode(*param_1,&local_30,&local_38,param_3,sVar4 & 0xffffffff);
      if (local_34 == 0) {
        *(undefined8 *)(local_20 + 0x30) = local_30;
        *(ulong *)(local_20 + 0x38) = (ulong)local_38;
        goto LAB_001271a7;
      }
    }
  }
  else {
    if ((uVar1 == 3) || ((*(uint *)(local_20 + 0x2c) & 0xffff) == 1)) {
      uVar3 = ((void*(*)())(*param_1 + 8))(local_28 + 1,*param_1,local_28 + 1,*param_1);
      *(undefined8 *)(local_20 + 0x18) = uVar3;
      if (*(long *)(local_20 + 0x18) == 0) {
        local_34 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for host name");
      }
      else {
        memcpy(*(void **)(local_20 + 0x18),param_2,local_28 + 1);
        *(size_t *)(local_20 + 0x20) = local_28;
LAB_001271a7:
        if ((param_10 & 0x20000) == 0) {
          local_18 = _libssh2_base64_encode(*param_1,param_6,param_7,&local_30);
          if (local_18 != 0) {
            *(undefined8 *)(local_20 + 0x40) = local_30;
            goto LAB_001272b9;
          }
          local_34 = _libssh2_error(*param_1,0xfffffffa,
                                    "Unable to allocate memory for base64-encoded key");
        }
        else {
          if (param_7 == 0) {
            param_7 = strlen(param_6);
          }
          uVar3 = ((void*(*)())(*param_1 + 8))(param_7 + 1,*param_1,param_7 + 1,*param_1);
          *(undefined8 *)(local_20 + 0x40) = uVar3;
          if (*(long *)(local_20 + 0x40) != 0) {
            memcpy(*(void **)(local_20 + 0x40),param_6,param_7 + 1);
            *(undefined *)(param_7 + *(long *)(local_20 + 0x40)) = 0;
LAB_001272b9:
            if ((param_4 != (void *)0x0) && ((param_10 & 0x3c0000) == 0x3c0000)) {
              uVar3 = ((void*(*)())(*param_1 + 8))(param_5 + 1,*param_1,param_5 + 1,*param_1);
              *(undefined8 *)(local_20 + 0x48) = uVar3;
              if (*(long *)(local_20 + 0x48) == 0) {
                local_34 = _libssh2_error(*param_1,0xfffffffa,
                                          "Unable to allocate memory for key type");
                goto LAB_00127465;
              }
              memcpy(*(void **)(local_20 + 0x48),param_4,param_5);
              *(undefined *)(param_5 + *(long *)(local_20 + 0x48)) = 0;
              *(size_t *)(local_20 + 0x50) = param_5;
            }
            if (param_8 == (void *)0x0) {
              *(undefined8 *)(local_20 + 0x58) = 0;
            }
            else {
              uVar3 = ((void*(*)())(*param_1 + 8))(param_9 + 1,*param_1,param_9 + 1,*param_1);
              *(undefined8 *)(local_20 + 0x58) = uVar3;
              if (*(long *)(local_20 + 0x58) == 0) {
                local_34 = _libssh2_error(*param_1,0xfffffffa,
                                          "Unable to allocate memory for comment");
                goto LAB_00127465;
              }
              memcpy(*(void **)(local_20 + 0x58),param_8,param_9 + 1);
              *(undefined *)(param_9 + *(long *)(local_20 + 0x58)) = 0;
              *(long *)(local_20 + 0x60) = param_9;
            }
            _libssh2_list_add(param_1 + 1,local_20);
            if (param_11 != (undefined8 *)0x0) {
              uVar3 = FUN_00126efd(local_20);
              *param_11 = uVar3;
            }
            uVar2 = 0;
            goto LAB_0012747e;
          }
          local_34 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for key");
        }
      }
    }
    else {
      local_34 = _libssh2_error(*param_1,0xffffffdf,"Unknown host name type");
    }
  }
LAB_00127465:
  FUN_00126d8d(*param_1,local_20);
  uVar2 = (ulong)local_34;
LAB_0012747e:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_knownhost_add
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,uint param_6,undefined8 param_7)

{
  FUN_00126f71(param_1,param_2,param_3,0,0,param_4,param_5,0,0,(ulong)param_6,param_7);
  return;
}



void libssh2_knownhost_addc
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined8 param_6,undefined8 param_7,uint param_8,
               undefined8 param_9)

{
  FUN_00126f71(param_1,param_2,param_3,0,0,param_4,param_5,param_6,param_7,(ulong)param_8,param_9);
  return;
}



ulong FUN_00127552(long *param_1,uchar *param_2,uint param_3,undefined8 param_4,undefined8 param_5,
                  uint param_6,undefined8 *param_7)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  EVP_MD *md;
  size_t len;
  undefined8 uVar5;
  long in_FS_OFFSET;
  bool bVar6;
  char *local_1b8;
  uint local_194;
  int local_190;
  long local_178;
  HMAC_CTX *local_170;
  long local_168;
  long local_160;
  uchar *local_158;
  long local_150;
  uchar local_148 [32];
  uchar local_128 [280];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_160 = 0;
  uVar1 = param_6 & 0xffff;
  local_178 = 0;
  local_194 = 2;
  bVar6 = 0;
  if (uVar1 == 2) {
    uVar4 = 1;
  }
  else {
    if ((int)param_3 < 0) {
      local_190 = 1;
      local_158 = param_2;
    }
    else {
      iVar2 = snprintf((char *)local_128,0x10e,"[%s]:%d",param_2,(ulong)param_3);
      if ((iVar2 < 0) || (0x10d < iVar2)) {
        _libssh2_error(*param_1,0xffffffda,"Known-host write buffer too small");
        uVar4 = 3;
        goto LAB_00127a72;
      }
      local_158 = local_128;
      local_190 = 2;
    }
    local_1b8 = (char *)param_4;
    if ((param_6 & 0x20000) == 0) {
      local_150 = _libssh2_base64_encode(*param_1,param_4,param_5,&local_178);
      if (local_150 == 0) {
        _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for base64-encoded key");
        uVar4 = 3;
        goto LAB_00127a72;
      }
      local_1b8 = (char *)local_178;
    }
    do {
      local_168 = _libssh2_list_first(param_1 + 1);
      while (local_168 != 0) {
        uVar3 = *(uint *)(local_168 + 0x2c) & 0xffff;
        if (uVar3 == 2) {
          if ((uVar1 == 1) &&
             (local_170 = (HMAC_CTX *)HMAC_CTX_new(), *(long *)(local_168 + 0x20) == 0x14)) {
            md = EVP_sha1();
            HMAC_Init_ex(local_170,*(void **)(local_168 + 0x30),
                         (int)*(undefined8 *)(local_168 + 0x38),md,(ENGINE *)0x0);
            len = strlen((char *)local_158);
            HMAC_Update(local_170,local_158,len);
            HMAC_Final(local_170,local_148,(uint *)0x0);
            HMAC_CTX_free(local_170);
            iVar2 = memcmp(local_148,*(void **)(local_168 + 0x18),0x14);
            if (iVar2 == 0) {
              bVar6 = 1;
            }
          }
        }
        else {
          if (uVar3 == 3) {
            if (uVar1 == 3) {
              iVar2 = strcmp((char *)local_158,*(char **)(local_168 + 0x18));
              bVar6 = iVar2 == 0;
            }
          }
          else {
            if (((*(uint *)(local_168 + 0x2c) & 0xffff) == 1) && (uVar1 == 1)) {
              iVar2 = strcmp((char *)local_158,*(char **)(local_168 + 0x18));
              bVar6 = iVar2 == 0;
            }
          }
        }
        if (bVar6) {
          uVar3 = param_6 & 0x3c0000;
          if ((uVar3 != 0x3c0000) &&
             ((uVar3 == 0 || (uVar3 == (*(uint *)(local_168 + 0x2c) & 0x3c0000))))) {
            iVar2 = strcmp(local_1b8,*(char **)(local_168 + 0x40));
            if (iVar2 == 0) {
              if (param_7 != (undefined8 *)0x0) {
                uVar5 = FUN_00126efd(local_168);
                *param_7 = uVar5;
              }
              local_160 = 0;
              local_194 = 0;
              break;
            }
            if (local_160 == 0) {
              local_160 = local_168;
            }
          }
          bVar6 = 0;
        }
        local_168 = _libssh2_list_next(local_168);
      }
    } while ((!bVar6) && (local_190 = local_190 + -1, local_158 = param_2, local_190 != 0));
    local_158 = param_2;
    if (local_160 != 0) {
      if (param_7 != (undefined8 *)0x0) {
        uVar5 = FUN_00126efd(local_160);
        *param_7 = uVar5;
      }
      local_194 = 1;
    }
    if (local_178 != 0) {
      ((void*(*)())(*param_1 + 0x18))(local_178,*param_1,local_178,*param_1);
    }
    uVar4 = (ulong)local_194;
  }
LAB_00127a72:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_knownhost_check
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               uint param_5,undefined8 param_6)

{
  FUN_00127552(param_1,param_2,0xffffffff,param_3,param_4,(ulong)param_5,param_6);
  return;
}



void libssh2_knownhost_checkp
               (undefined8 param_1,undefined8 param_2,uint param_3,undefined8 param_4,
               undefined8 param_5,uint param_6,undefined8 param_7)

{
  FUN_00127552(param_1,param_2,(ulong)param_3,param_4,param_5,(ulong)param_6,param_7);
  return;
}



undefined8 libssh2_knownhost_del(undefined8 *param_1,int *param_2)

{
  undefined8 uVar1;
  
  if ((param_2 == (int *)0x0) || (*param_2 != -0x21523502)) {
    uVar1 = _libssh2_error(*param_1,0xffffffde,"Invalid host information");
  }
  else {
    uVar1 = *(undefined8 *)(param_2 + 2);
    _libssh2_list_remove(uVar1);
    memset(param_2,0,0x28);
    FUN_00126d8d(*param_1,uVar1);
    uVar1 = 0;
  }
  return uVar1;
}



void libssh2_knownhost_free(long *param_1)

{
  long lVar1;
  long local_18;
  
  local_18 = _libssh2_list_first(param_1 + 1);
  while (local_18 != 0) {
    lVar1 = _libssh2_list_next(local_18);
    FUN_00126d8d(*param_1,local_18);
    local_18 = lVar1;
  }
  ((void*(*)())(*param_1 + 0x18))(param_1,*param_1,param_1,*param_1);
  return;
}



ulong FUN_00127c36(undefined8 *param_1,void *param_2,long param_3,undefined8 param_4,
                  undefined8 param_5,undefined8 param_6,undefined8 param_7,uint param_8,
                  undefined8 param_9,undefined8 param_10)

{
  void *__src;
  ulong __n;
  long in_FS_OFFSET;
  undefined8 uVar1;
  uint local_12c;
  ulong local_128;
  void *local_120;
  undefined local_118;
  undefined auStack279 [263];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12c = 0;
  local_128 = 0;
  __n = local_128;
  __src = (void *)(param_3 + (long)param_2);
  if (param_3 == 0) {
    __n = _libssh2_error(*param_1,0xffffffdf,"Failed to parse known_hosts line (no host names)");
  }
  else {
    while (local_120 = __src, local_128 = __n, param_2 < local_120) {
      __src = (void *)((long)local_120 + -1);
      __n = local_128 + 1;
      if ((__src == param_2) || (*(char *)((long)local_120 + -2) == ',')) {
        if (0xfe < __n) {
          __n = _libssh2_error(*param_1,0xffffffdf,
                               "Failed to parse known_hosts line (unexpected length)");
          goto LAB_00127e2d;
        }
        uVar1 = 0x127d69;
        memcpy(&local_118,__src,__n);
        auStack279[local_128] = 0;
        local_12c = FUN_00126f71(param_1,&local_118,0,param_4,param_5,param_6,param_7,param_9,
                                 param_10,(ulong)(param_8 | 0x20001),0);
        if (local_12c != 0) {
          __n = (ulong)local_12c;
          goto LAB_00127e2d;
        }
        if (param_2 < __src) {
          local_128 = 0;
          __n = local_128;
          __src = (void *)((long)local_120 + -2);
        }
      }
    }
    __n = (ulong)local_12c;
  }
LAB_00127e2d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return __n;
}



undefined8
FUN_00127e43(undefined8 *param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5,
            undefined8 param_6,undefined8 param_7,uint param_8,undefined8 param_9,
            undefined8 param_10)

{
  char *__src;
  undefined8 uVar1;
  ulong __n;
  char *__n_00;
  long in_FS_OFFSET;
  char *local_158;
  char local_138 [28];
  undefined auStack284 [4];
  undefined local_118 [264];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __src = (char *)(param_2 + 3);
  local_158 = __src;
  while ((*local_158 != '\0' && (*local_158 != '|'))) {
    local_158 = local_158 + 1;
  }
  if (*local_158 == '|') {
    __n_00 = local_158 + -(long)__src;
    if (__n_00 < (char *)0x1f) {
      memcpy(local_138,__src,(size_t)__n_00);
      __n_00[(long)local_138] = '\0';
      __n = (param_3 - (long)__n_00) - 4;
      if (__n < 0xff) {
        uVar1 = 0x128010;
        memcpy(local_118,local_158 + 1,__n);
        auStack284[param_3 - (long)__n_00] = 0;
        uVar1 = FUN_00126f71(param_1,local_118,local_138,param_4,param_5,param_6,param_7,param_9,
                             param_10,(ulong)(param_8 | 0x20002),0);
      }
      else {
        uVar1 = _libssh2_error(*param_1,0xffffffdf,
                               "Failed to parse known_hosts line (unexpected length)");
      }
    }
    else {
      uVar1 = _libssh2_error(*param_1,0xffffffdf,
                             "Failed to parse known_hosts line (unexpectedly long salt)");
    }
  }
  else {
    uVar1 = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



void FUN_0012809c(undefined8 *param_1,void *param_2,ulong param_3,char *param_4,ulong param_5)

{
  int iVar1;
  ulong local_60;
  char *local_58;
  uint local_2c;
  char *local_28;
  char *local_20;
  ulong local_18;
  char *local_10;
  
  local_28 = (char *)0x0;
  local_20 = (char *)0x0;
  local_18 = 0;
  local_10 = (char *)0x0;
  if (param_5 < 0x14) {
    _libssh2_error(*param_1,0xffffffdf,"Failed to parse known_hosts line (key too short)");
  }
  else {
    local_60 = param_5;
    local_58 = param_4;
    if ((int)*param_4 - 0x30U < 10) {
      local_2c = 0x40000;
    }
    else {
      while ((((local_60 != 0 && (*local_58 != '\0')) && (*local_58 != ' ')) && (*local_58 != '\t'))
            ) {
        local_58 = local_58 + 1;
        local_60 = local_60 - 1;
      }
      local_10 = local_58 + -(long)param_4;
      iVar1 = strncmp(param_4,"ssh-dss",(size_t)local_10);
      if (iVar1 == 0) {
        local_2c = 0xc0000;
      }
      else {
        iVar1 = strncmp(param_4,"ssh-rsa",(size_t)local_10);
        if (iVar1 == 0) {
          local_2c = 0x80000;
        }
        else {
          iVar1 = strncmp(param_4,"ecdsa-sha2-nistp256",(size_t)local_10);
          if (iVar1 == 0) {
            local_2c = 0x100000;
          }
          else {
            iVar1 = strncmp(param_4,"ecdsa-sha2-nistp384",(size_t)local_10);
            if (iVar1 == 0) {
              local_2c = 0x140000;
            }
            else {
              iVar1 = strncmp(param_4,"ecdsa-sha2-nistp521",(size_t)local_10);
              if (iVar1 == 0) {
                local_2c = 0x180000;
              }
              else {
                iVar1 = strncmp(param_4,"ssh-ed25519",(size_t)local_10);
                if (iVar1 == 0) {
                  local_2c = 0x1c0000;
                }
                else {
                  local_2c = 0x3c0000;
                }
              }
            }
          }
        }
      }
      while ((*local_58 == ' ' || (*local_58 == '\t'))) {
        local_58 = local_58 + 1;
        local_60 = local_60 - 1;
      }
      local_28 = local_58;
      local_18 = local_60;
      while (((local_18 != 0 && (*local_28 != '\0')) && ((*local_28 != ' ' && (*local_28 != '\t'))))
            ) {
        local_28 = local_28 + 1;
        local_18 = local_18 - 1;
      }
      local_60 = local_60 - local_18;
      if (local_18 == 0) {
        local_28 = (char *)0x0;
      }
      while (((local_20 = param_4, local_18 != 0 && (*local_28 != '\0')) &&
             ((*local_28 == ' ' || (*local_28 == '\t'))))) {
        local_28 = local_28 + 1;
        local_18 = local_18 - 1;
      }
    }
    if ((param_3 < 3) || (iVar1 = memcmp(param_2,&DAT_001474c9,3), iVar1 == 0)) {
      FUN_00127e43(param_1,param_2,param_3,local_20,local_10,local_58,local_60,(ulong)local_2c,
                   local_28,local_18);
    }
    else {
      FUN_00127c36(param_1,param_2,param_3,local_20,local_10,local_58,local_60,(ulong)local_2c,
                   local_28,local_18);
    }
  }
  return;
}



ulong libssh2_knownhost_readline(undefined8 *param_1,char *param_2,long param_3,int param_4)

{
  char *pcVar1;
  char *pcVar2;
  uint uVar3;
  ulong uVar4;
  char *pcVar5;
  long local_50;
  char *local_30;
  long local_28;
  
  local_50 = param_3;
  local_30 = param_2;
  if (param_4 == 1) {
    while ((pcVar1 = local_30, local_50 != 0 && ((*local_30 == ' ' || (*local_30 == '\t'))))) {
      local_30 = local_30 + 1;
      local_50 = local_50 + -1;
    }
    if ((((local_50 == 0) || (*local_30 == '\0')) || (*local_30 == '#')) || (*local_30 == '\n')) {
      uVar4 = 0;
    }
    else {
      while (((local_50 != 0 && (*local_30 != '\0')) && ((*local_30 != ' ' && (*local_30 != '\t'))))
            ) {
        local_30 = local_30 + 1;
        local_50 = local_50 + -1;
      }
      pcVar5 = local_30 + -(long)pcVar1;
      while (((pcVar2 = local_30, local_28 = local_50, local_50 != 0 && (*local_30 != '\0')) &&
             ((*local_30 == ' ' || (*local_30 == '\t'))))) {
        local_30 = local_30 + 1;
        local_50 = local_50 + -1;
      }
      if ((*local_30 == '\0') || (local_50 == 0)) {
        uVar4 = _libssh2_error(*param_1,0xffffffdf,"Failed to parse known_hosts line");
      }
      else {
        while (((local_50 != 0 && (*local_30 != '\0')) && (*local_30 != '\n'))) {
          local_30 = local_30 + 1;
          local_50 = local_50 + -1;
        }
        if (*local_30 == '\n') {
          local_28 = local_28 + -1;
        }
        FUN_0012809c(param_1,pcVar1,pcVar5,pcVar2,local_28);
        if (uVar3 == 0) {
          uVar4 = 0;
        }
        else {
          uVar4 = (ulong)uVar3;
        }
      }
    }
  }
  else {
    uVar4 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
  }
  return uVar4;
}



ulong libssh2_knownhost_readfile(undefined8 *param_1,char *param_2,int param_3)

{
  int iVar1;
  ulong uVar2;
  FILE *__stream;
  size_t sVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  uint local_1024;
  char local_1018 [4104];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_1024 = 0;
  if (param_3 == 1) {
    __stream = fopen(param_2,"r");
    if (__stream == (FILE *)0x0) {
      uVar2 = _libssh2_error(*param_1,0xfffffff0,"Failed to open file");
    }
    else {
      while (pcVar4 = fgets(local_1018,0xffc,__stream), pcVar4 != (char *)0x0) {
        sVar3 = strlen(local_1018);
        iVar1 = libssh2_knownhost_readline(param_1,local_1018,sVar3,1);
        if (iVar1 != 0) {
          local_1024 = _libssh2_error(*param_1,0xffffffd2,"Failed to parse known hosts file");
          break;
        }
        local_1024 = local_1024 + 1;
      }
      fclose(__stream);
      uVar2 = (ulong)local_1024;
    }
  }
  else {
    uVar2 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
FUN_001286bd(long *param_1,long param_2,char *param_3,size_t param_4,long *param_5,int param_6)

{
  uint uVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  undefined8 local_48;
  undefined8 local_40;
  ulong local_38;
  char *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_6 != 1) {
    uVar2 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
    goto LAB_00128ca6;
  }
  uVar1 = *(uint *)(param_2 + 0x2c) & 0x3c0000;
  if (uVar1 == 0x100000) {
    local_30 = "ecdsa-sha2-nistp256";
    local_28 = 0x13;
  }
  else {
    if (uVar1 < 0x100001) {
      if (uVar1 == 0x80000) {
        local_30 = "ssh-rsa";
        local_28 = 7;
      }
      else {
        if (uVar1 == 0xc0000) {
          local_30 = "ssh-dss";
          local_28 = 7;
        }
        else {
          if (uVar1 != 0x40000) goto LAB_00128840;
          local_30 = (char *)0x0;
          local_28 = 0;
        }
      }
    }
    else {
      if (uVar1 == 0x180000) {
        local_30 = "ecdsa-sha2-nistp521";
        local_28 = 0x13;
      }
      else {
        if (uVar1 < 0x180001) {
          if (uVar1 != 0x140000) {
LAB_00128840:
            uVar2 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host entry");
            goto LAB_00128ca6;
          }
          local_30 = "ecdsa-sha2-nistp384";
          local_28 = 0x13;
        }
        else {
          if (uVar1 == 0x1c0000) {
            local_30 = "ssh-ed25519";
            local_28 = 0xb;
          }
          else {
            if ((uVar1 != 0x3c0000) ||
               (local_30 = *(char **)(param_2 + 0x48), local_30 == (char *)0x0)) goto LAB_00128840;
            local_28 = *(long *)(param_2 + 0x50);
          }
        }
      }
    }
  }
  uVar2 = 0x128870;
  local_38 = strlen(*(char **)(param_2 + 0x40));
  if (local_28 != 0) {
    local_38 = local_38 + local_28 + 1;
  }
  if (*(long *)(param_2 + 0x58) != 0) {
    local_38 = local_38 + *(long *)(param_2 + 0x60) + 1;
  }
  if ((*(uint *)(param_2 + 0x2c) & 0xffff) == 2) {
    local_20 = _libssh2_base64_encode
                         (*param_1,*(undefined8 *)(param_2 + 0x18),*(undefined8 *)(param_2 + 0x20),
                          &local_48);
    if (local_20 == 0) {
      uVar2 = _libssh2_error(*param_1,0xfffffffa,
                             "Unable to allocate memory for base64-encoded host name");
      goto LAB_00128ca6;
    }
    uVar2 = 0x128936;
    local_18 = _libssh2_base64_encode
                         (*param_1,*(undefined8 *)(param_2 + 0x30),*(undefined8 *)(param_2 + 0x38),
                          &local_40);
    if (local_18 == 0) {
      ((void*(*)())(*param_1 + 0x18))(local_48,*param_1,local_48,*param_1);
      uVar2 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for base64-encoded salt"
                            );
      goto LAB_00128ca6;
    }
    local_38 = local_38 + local_18 + local_20 + 7;
    if (local_38 <= param_4) {
      if ((*(long *)(param_2 + 0x58) == 0) || (local_28 == 0)) {
        if (*(long *)(param_2 + 0x58) == 0) {
          if (local_28 == 0) {
            snprintf(param_3,param_4,"|1|%s|%s %s\n",local_40,local_48,
                     *(undefined8 *)(param_2 + 0x40));
          }
          else {
            snprintf(param_3,param_4,"|1|%s|%s %s %s\n",local_40,local_48,local_30,
                     *(undefined8 *)(param_2 + 0x40),uVar2);
          }
        }
        else {
          snprintf(param_3,param_4,"|1|%s|%s %s %s\n",local_40,local_48,
                   *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58),uVar2);
        }
      }
      else {
        snprintf(param_3,param_4,"|1|%s|%s %s %s %s\n",local_40,local_48,local_30,
                 *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58));
      }
    }
    ((void*(*)())(*param_1 + 0x18))(local_48,*param_1,local_48,*param_1);
    ((void*(*)())(*param_1 + 0x18))(local_40,*param_1,local_40,*param_1);
  }
  else {
    local_38 = local_38 + *(long *)(param_2 + 0x20) + 3;
    if (local_38 <= param_4) {
      if ((*(long *)(param_2 + 0x58) == 0) || (local_28 == 0)) {
        if (*(long *)(param_2 + 0x58) == 0) {
          if (local_28 == 0) {
            snprintf(param_3,param_4,"%s %s\n",*(undefined8 *)(param_2 + 0x18),
                     *(undefined8 *)(param_2 + 0x40));
          }
          else {
            snprintf(param_3,param_4,"%s %s %s\n",*(undefined8 *)(param_2 + 0x18),local_30,
                     *(undefined8 *)(param_2 + 0x40));
          }
        }
        else {
          snprintf(param_3,param_4,"%s %s %s\n",*(undefined8 *)(param_2 + 0x18),
                   *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58));
        }
      }
      else {
        snprintf(param_3,param_4,"%s %s %s %s\n",*(undefined8 *)(param_2 + 0x18),local_30,
                 *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58),uVar2);
      }
    }
  }
  *param_5 = local_38 - 1;
  if (param_4 < local_38) {
    uVar2 = _libssh2_error(*param_1,0xffffffda,"Known-host write buffer too small");
  }
  else {
    uVar2 = 0;
  }
LAB_00128ca6:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_knownhost_writeline
               (undefined8 *param_1,int *param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,uint param_6)

{
  if (*param_2 == -0x21523502) {
    FUN_001286bd(param_1,*(undefined8 *)(param_2 + 2),param_3,param_4,param_5,(ulong)param_6);
  }
  else {
    _libssh2_error(*param_1,0xffffffde,"Invalid host information");
  }
  return;
}



ulong libssh2_knownhost_writefile(undefined8 *param_1,char *param_2,int param_3)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint local_103c;
  size_t local_1038;
  long local_1030;
  FILE *local_1028;
  size_t local_1020;
  undefined local_1018 [4104];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_103c = 0;
  if (param_3 == 1) {
    local_1028 = fopen(param_2,"w");
    if (local_1028 == (FILE *)0x0) {
      uVar1 = _libssh2_error(*param_1,0xfffffff0,"Failed to open file");
    }
    else {
      local_1030 = _libssh2_list_first(param_1 + 1);
      while (local_1030 != 0) {
        local_1038 = 0;
        local_103c = FUN_001286bd(param_1,local_1030,local_1018,0xffc,&local_1038,1);
        if (local_103c != 0) break;
        local_1020 = fwrite(local_1018,1,local_1038,local_1028);
        if (local_1020 != local_1038) {
          local_103c = _libssh2_error(*param_1,0xfffffff0,"Write failed");
          break;
        }
        local_1030 = _libssh2_list_next(param_1);
      }
      fclose(local_1028);
      uVar1 = (ulong)local_103c;
    }
  }
  else {
    uVar1 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_knownhost_get(long param_1,undefined8 *param_2,long param_3)

{
  undefined8 uVar1;
  long local_18;
  
  if ((param_3 == 0) || (*(long *)(param_3 + 8) == 0)) {
    local_18 = _libssh2_list_first(param_1 + 8);
  }
  else {
    local_18 = _libssh2_list_next(*(undefined8 *)(param_3 + 8));
  }
  if (local_18 != 0) {
    uVar1 = FUN_00126efd(local_18);
    *param_2 = uVar1;
  }
  return (ulong)(local_18 == 0);
}



undefined8
FUN_00128f91(undefined8 param_1,undefined8 param_2,undefined4 *param_3,undefined8 *param_4)

{
  *param_4 = param_2;
  *param_3 = 0;
  return 0;
}



undefined8 FUN_00128fc1(long param_1,long *param_2)

{
  if (*param_2 != 0) {
    ((void*(*)())(param_1 + 0x18))(*param_2,param_1,*param_2,param_1);
  }
  *param_2 = 0;
  return 0;
}



undefined8
FUN_0012900a(undefined8 param_1,uchar *param_2,uint param_3,uchar *param_4,uint param_5,
            uchar *param_6,uint param_7,void **param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,(ulong)param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_sha512();
  HMAC_Init_ex(ctx,*param_8,0x40,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
FUN_00129113(undefined8 param_1,uchar *param_2,uint param_3,uchar *param_4,uint param_5,
            uchar *param_6,uint param_7,void **param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,(ulong)param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_sha256();
  HMAC_Init_ex(ctx,*param_8,0x20,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
FUN_0012921c(undefined8 param_1,uchar *param_2,uint param_3,uchar *param_4,uint param_5,
            uchar *param_6,uint param_7,void **param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,(ulong)param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_sha1();
  HMAC_Init_ex(ctx,*param_8,0x14,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
FUN_00129325(undefined8 param_1,void *param_2,uint param_3,undefined8 param_4,uint param_5,
            undefined8 param_6,uint param_7,undefined8 param_8)

{
  long in_FS_OFFSET;
  undefined local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  FUN_0012921c(param_1,local_28,(ulong)param_3,param_4,(ulong)param_5,param_6,(ulong)param_7,param_8
              );
  memcpy(param_2,local_28,0xc);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
FUN_001293b8(undefined8 param_1,uchar *param_2,uint param_3,uchar *param_4,uint param_5,
            uchar *param_6,uint param_7,void **param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,(ulong)param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_md5();
  HMAC_Init_ex(ctx,*param_8,0x10,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
FUN_001294c1(undefined8 param_1,void *param_2,uint param_3,undefined8 param_4,uint param_5,
            undefined8 param_6,uint param_7,undefined8 param_8)

{
  long in_FS_OFFSET;
  undefined local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  FUN_001293b8(param_1,local_28,(ulong)param_3,param_4,(ulong)param_5,param_6,(ulong)param_7,param_8
              );
  memcpy(param_2,local_28,0xc);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
FUN_00129554(undefined8 param_1,uchar *param_2,uint param_3,uchar *param_4,uint param_5,
            uchar *param_6,uint param_7,void **param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,(ulong)param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_ripemd160();
  HMAC_Init_ex(ctx,*param_8,0x14,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



//undefined ** _libssh2_mac_methods(void)
//
//{
//  return &PTR_PTR_s_hmac_sha2_256_00350aa0;
//}
//


ulong _libssh2_error_flags(long param_1,uint param_2,char *param_3,uint param_4)

{
  size_t sVar1;
  void *__dest;
  
  if ((*(uint *)(param_1 + 0x244) & 1) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0x238),param_1,*(undefined8 *)(param_1 + 0x238),param_1);
  }
  *(uint *)(param_1 + 0x240) = param_2;
  *(undefined4 *)(param_1 + 0x244) = 0;
  if ((param_3 == (char *)0x0) || ((param_4 & 1) == 0)) {
    *(char **)(param_1 + 0x238) = param_3;
  }
  else {
    sVar1 = strlen(param_3);
    __dest = (void *)((void*(*)())(param_1 + 8))(sVar1 + 1,param_1,param_1,sVar1 + 1);
    if (__dest == (void *)0x0) {
      *(undefined8 *)(param_1 + 0x238) = 0x1476e0;
    }
    else {
      memcpy(__dest,param_3,sVar1 + 1);
      *(undefined4 *)(param_1 + 0x244) = 1;
      *(void **)(param_1 + 0x238) = __dest;
    }
  }
  return (ulong)param_2;
}




ssize_t _libssh2_recv(int param_1,void *param_2,size_t param_3,int param_4)

{
  ssize_t sVar1;
  int *piVar2;
  
  sVar1 = recv(param_1,param_2,param_3,param_4);
  if (sVar1 < 0) {
    piVar2 = __errno_location();
    if (*piVar2 == 2) {
      sVar1 = -0xb;
    }
    else {
      piVar2 = __errno_location();
      if (*piVar2 == 0xb) {
        sVar1 = -0xb;
      }
      else {
        piVar2 = __errno_location();
        sVar1 = (ssize_t)-*piVar2;
      }
    }
  }
  return sVar1;
}



ssize_t _libssh2_send(int param_1,void *param_2,size_t param_3,int param_4)

{
  ssize_t sVar1;
  int *piVar2;
  
  sVar1 = send(param_1,param_2,param_3,param_4);
  if (sVar1 < 0) {
    piVar2 = __errno_location();
    if (*piVar2 == 0xb) {
      sVar1 = -0xb;
    }
    else {
      piVar2 = __errno_location();
      sVar1 = (ssize_t)-*piVar2;
    }
  }
  return sVar1;
}





ulong _libssh2_ntohu64(byte *param_1)

{
  return ((ulong)param_1[3] |
         (ulong)*param_1 << 0x18 | (ulong)param_1[1] << 0x10 | (ulong)param_1[2] << 8) << 0x20 |
         (ulong)param_1[7] |
         (ulong)param_1[4] << 0x18 | (ulong)param_1[5] << 0x10 | (ulong)param_1[6] << 8;
}



void _libssh2_htonu32(undefined *param_1,undefined4 param_2)

{
  *param_1 = (char)((uint)param_2 >> 0x18);
  param_1[1] = (char)((uint)param_2 >> 0x10);
  param_1[2] = (char)((uint)param_2 >> 8);
  param_1[3] = (char)param_2;
  return;
}



void _libssh2_store_u32(long *param_1,uint param_2)

{
  _libssh2_htonu32(*param_1,(ulong)param_2);
  *param_1 = *param_1 + 4;
  return;
}



void _libssh2_store_str(void **param_1,void *param_2,ulong param_3)

{
  _libssh2_store_u32(param_1,param_3 & 0xffffffff);
  if (param_3 != 0) {
    memcpy(*param_1,param_2,param_3);
    *param_1 = (void *)((long)*param_1 + param_3);
  }
  return;
}



undefined8 libssh2_base64_decode(long param_1,long *param_2,int *param_3,byte *param_4,uint param_5)

{
  short sVar1;
  byte bVar2;
  int iVar3;
  long lVar4;
  undefined8 uVar5;
  uint uVar6;
  uint uVar7;
  int local_20;
  int local_1c;
  byte *local_18;
  
  local_20 = 0;
  local_1c = 0;
  lVar4 = ((void*(*)())(param_1 + 8))((ulong)((param_5 * 3 >> 2) + 1),param_1,(ulong)param_5);
  *param_2 = lVar4;
  lVar4 = *param_2;
  local_18 = param_4;
  if (lVar4 == 0) {
    uVar5 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for base64 decoding");
  }
  else {
    while (local_18 < param_4 + param_5) {
      sVar1 = *(short *)(&DAT_00147700 + (long)(int)(uint)*local_18 * 2);
      if (-1 < sVar1) {
        uVar6 = (uint)(local_20 >> 0x1f) >> 0x1e;
        uVar7 = local_20 + uVar6 & 3;
        iVar3 = uVar7 - uVar6;
        bVar2 = (byte)sVar1;
        if (iVar3 == 1) {
          *(byte *)(lVar4 + local_1c) = *(byte *)(lVar4 + local_1c) | (byte)(sVar1 >> 4);
          *(char *)(lVar4 + (local_1c + 1)) = bVar2 << 4;
          local_1c = local_1c + 1;
        }
        else {
          if (iVar3 < 2) {
            if (uVar7 == uVar6) {
              *(char *)(lVar4 + local_1c) = bVar2 * '\x04';
            }
          }
          else {
            if (iVar3 == 2) {
              *(byte *)(lVar4 + local_1c) = *(byte *)(lVar4 + local_1c) | (byte)(sVar1 >> 2);
              *(char *)(lVar4 + (local_1c + 1)) = bVar2 << 6;
              local_1c = local_1c + 1;
            }
            else {
              if (iVar3 == 3) {
                *(byte *)(lVar4 + local_1c) = *(byte *)(lVar4 + local_1c) | bVar2;
                local_1c = local_1c + 1;
              }
            }
          }
        }
        local_20 = local_20 + 1;
      }
      local_18 = local_18 + 1;
    }
    uVar7 = (uint)(local_20 >> 0x1f) >> 0x1e;
    if ((local_20 + uVar7 & 3) - uVar7 == 1) {
      ((void*(*)())(param_1 + 0x18))(*param_2,param_1,*param_2,param_1);
      *param_2 = 0;
      uVar5 = _libssh2_error(param_1,0xffffffde,"Invalid base64");
    }
    else {
      *param_3 = local_1c;
      uVar5 = 0;
    }
  }
  return uVar5;
}



size_t _libssh2_base64_encode(long param_1,byte *param_2,size_t param_3,char **param_4)

{
  char *__s;
  size_t sVar1;
  long in_FS_OFFSET;
  undefined8 uVar2;
  size_t local_50;
  int local_38;
  int local_34;
  char *local_30;
  byte *local_28;
  byte local_17 [4];
  byte local_13;
  byte local_12;
  byte local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  *param_4 = (char *)0x0;
  local_50 = param_3;
  if (param_3 == 0) {
    local_50 = strlen((char *)param_2);
  }
  uVar2 = 0x129d4c;
  __s = (char *)((void*(*)())(param_1 + 8))
                          ((local_50 << 2) / 3 + 4,param_1,
                           SUB168(ZEXT816(local_50 << 2) * ZEXT816(0xaaaaaaaaaaaaaaab) >> 0x40,0));
  local_30 = __s;
  local_28 = param_2;
  if (__s == (char *)0x0) {
    sVar1 = 0;
  }
  else {
    while (local_50 != 0) {
      local_34 = 0;
      local_38 = 0;
      while (local_38 < 3) {
        if (local_50 == 0) {
          local_17[local_38] = 0;
        }
        else {
          local_34 = local_34 + 1;
          local_17[local_38] = *local_28;
          local_28 = local_28 + 1;
          local_50 = local_50 - 1;
        }
        local_38 = local_38 + 1;
      }
      local_17[3] = local_17[0] >> 2;
      local_13 = local_17[1] >> 4 | (byte)(((uint)local_17[0] & 3) << 4);
      local_12 = local_17[2] >> 6 | (byte)(((uint)local_17[1] & 0xf) << 2);
      local_11 = local_17[2] & 0x3f;
      if (local_34 == 1) {
        uVar2 = 0x129e67;
        snprintf(local_30,5,"%c%c==",
                 (ulong)(uint)(int)
                                   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_17[3]],
                 (ulong)(uint)(int)
                                   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_13]);
      }
      else {
        if (local_34 == 2) {
          uVar2 = 0x129ed9;
          snprintf(local_30,5,"%c%c%c=",
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_17[3]],
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_13],
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_12]);
        }
        else {
          snprintf(local_30,5,"%c%c%c%c",
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_17[3]],
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_13],
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_12],
                   (ulong)(uint)(int)
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                     [(int)(uint)local_11],uVar2);
        }
      }
      local_30 = local_30 + 4;
    }
    *local_30 = '\0';
    *param_4 = __s;
    sVar1 = strlen(__s);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return sVar1;
}



void libssh2_free(long param_1,undefined8 param_2)

{
  ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
  return;
}



undefined8 libssh2_trace(void)

{
  return 0;
}



undefined8 libssh2_trace_sethandler(void)

{
  return 0;
}



void _libssh2_list_init(undefined8 *param_1)

{
  *param_1 = 0;
  param_1[1] = *param_1;
  return;
}



void _libssh2_list_add(undefined8 *param_1,undefined8 *param_2)

{
  *(undefined8 **)(param_2 + 2) = param_1;
  *param_2 = 0;
  param_2[1] = *param_1;
  *(undefined8 **)param_1 = param_2;
  if (param_2[1] == 0) {
    *(undefined8 **)(param_1 + 1) = param_2;
  }
  else {
    *(undefined8 **)param_2[1] = param_2;
  }
  return;
}



undefined8 _libssh2_list_first(long param_1)

{
  return *(undefined8 *)(param_1 + 8);
}



undefined8 _libssh2_list_next(undefined8 *param_1)

{
  return *param_1;
}



undefined8 _libssh2_list_prev(long param_1)

{
  return *(undefined8 *)(param_1 + 8);
}



void _libssh2_list_remove(long *param_1)

{
  if (param_1[1] == 0) {
    *(long *)(param_1[2] + 8) = *param_1;
  }
  else {
    *(long *)param_1[1] = *param_1;
  }
  if (*param_1 == 0) {
    *(long *)param_1[2] = param_1[1];
  }
  else {
    *(long *)(*param_1 + 8) = param_1[1];
  }
  return;
}



void * _libssh2_calloc(long param_1,size_t param_2)

{
  void *__s;
  
  __s = (void *)((void*(*)())(param_1 + 8))(param_2,param_1,param_2,param_1);
  if (__s != (void *)0x0) {
    memset(__s,0,param_2);
  }
  return __s;
}



void _libssh2_xor_data(byte *param_1,byte *param_2,byte *param_3,ulong param_4)

{
  byte *local_30;
  byte *local_28;
  byte *local_20;
  ulong local_10;
  
  local_10 = 0;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  while (local_10 < param_4) {
    *local_20 = *local_28 ^ *local_30;
    local_10 = local_10 + 1;
    local_30 = local_30 + 1;
    local_28 = local_28 + 1;
    local_20 = local_20 + 1;
  }
  return;
}



void _libssh2_aes_ctr_increment(byte *param_1,long param_2)

{
  byte bVar1;
  uint local_18;
  byte *local_10;
  
  local_18 = 1;
  local_10 = param_1 + param_2 + -1;
  while (param_1 <= local_10) {
    bVar1 = *local_10;
    *local_10 = (byte)(local_18 + bVar1);
    local_18 = local_18 + bVar1 >> 8;
    local_10 = local_10 + -1;
  }
  return;
}



void _libssh2_explicit_zero(undefined8 param_1,undefined8 param_2)

{

  return;
}



long _libssh2_string_buf_new(undefined8 param_1)

{
  long lVar1;
  
  lVar1 = _libssh2_calloc(param_1,0x18);
  if (lVar1 == 0) {
    lVar1 = 0;
  }
  return lVar1;
}



void _libssh2_string_buf_free(long param_1,long *param_2, long *param_3)

{
  if (param_2 != (long *)0x0) {
    if (*param_2 != 0) {
      ((void*(*)())(param_1 + 0x18))(*param_2,param_1,*param_2,param_1);
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
  }
  return;
}



undefined8 _libssh2_get_u32(long param_1,undefined4 *param_2)

{
  int iVar1;
  undefined4 uVar2;
  undefined8 uVar3;
  
  iVar1 = _libssh2_check_length(param_1,4);
  if (iVar1 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    uVar2 = _libssh2_ntohu32(*(undefined8 *)(param_1 + 8));
    *param_2 = uVar2;
    *(long *)(param_1 + 8) = *(long *)(param_1 + 8) + 4;
    uVar3 = 0;
  }
  return uVar3;
}



undefined8 _libssh2_get_u64(long param_1,undefined8 *param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  iVar1 = _libssh2_check_length(param_1,8);
  if (iVar1 == 0) {
    uVar2 = 0xffffffff;
  }
  else {
    uVar2 = _libssh2_ntohu64(*(undefined8 *)(param_1 + 8));
    *param_2 = uVar2;
    *(long *)(param_1 + 8) = *(long *)(param_1 + 8) + 8;
    uVar2 = 0;
  }
  return uVar2;
}



undefined8 _libssh2_match_string(undefined8 param_1,char *param_2)

{
  int iVar1;
  size_t __n;
  undefined8 uVar2;
  long in_FS_OFFSET;
  char *local_20;
  size_t local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  iVar1 = _libssh2_get_string(param_1,&local_20,&local_18,&local_20);
  if (iVar1 == 0) {
    __n = strlen(param_2);
    if (__n == local_18) {
      __n = strlen(param_2);
      iVar1 = strncmp(local_20,param_2,__n);
      if (iVar1 == 0) {
        uVar2 = 0;
        goto LAB_0012a45b;
      }
    }
  }
  uVar2 = 0xffffffff;
LAB_0012a45b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 _libssh2_get_string(long param_1,undefined8 *param_2,ulong *param_3, undefined8* param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_get_u32(param_1,&local_14);
  if (iVar1 == 0) {
    iVar1 = _libssh2_check_length(param_1,(ulong)local_14);
    if (iVar1 == 0) {
      uVar2 = 0xffffffff;
    }
    else {
      *param_2 = *(undefined8 *)(param_1 + 8);
      *(long *)(param_1 + 8) = (ulong)local_14 + *(long *)(param_1 + 8);
      if (param_3 != (ulong *)0x0) {
        *param_3 = (ulong)local_14;
      }
      uVar2 = 0;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 _libssh2_copy_string(long param_1,undefined8 param_2,void **param_3,size_t *param_4)

{
  int iVar1;
  undefined8 uVar2;
  void *pvVar3;
  long in_FS_OFFSET;
  size_t local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);

  if (iVar1 == 0) {
    pvVar3 = (void *)((void*(*)())(param_1 + 8))(local_20,param_1,local_20,param_1);
    *param_3 = pvVar3;
    if (*param_3 == (void *)0x0) {
      uVar2 = 0xffffffff;
    }
    else {
      memcpy(*param_3,local_18,local_20);
      if (param_4 != (size_t *)0x0) {
        *param_4 = local_20;
      }
      uVar2 = 0;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 _libssh2_get_bignum_bytes(long param_1,char **param_2,ulong *param_3)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uint local_20;
  uint local_1c;
  char *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_get_u32(param_1,&local_20);
  if (iVar1 == 0) {
    iVar1 = _libssh2_check_length(param_1,(ulong)local_20);
    if (iVar1 == 0) {
      uVar2 = 0xffffffff;
    }
    else {
      local_1c = local_20;
      local_18 = *(char **)(param_1 + 8);
      while ((local_1c != 0 && (*local_18 == '\0'))) {
        local_1c = local_1c - 1;
        local_18 = local_18 + 1;
      }
      *param_2 = local_18;
      *(long *)(param_1 + 8) = (ulong)local_20 + *(long *)(param_1 + 8);
      if (param_3 != (ulong *)0x0) {
        *param_3 = (ulong)local_1c;
      }
      uVar2 = 0;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}





void _libssh2_bcrypt_pbkdf
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined8 param_6,uint param_7)

{
  bcrypt_pbkdf(param_1,param_2,param_3,param_4,param_5,param_6,(ulong)param_7);
  return;
}



undefined8 FUN_0012a779(long param_1,long param_2,ulong param_3,int *param_4)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined8 uVar4;
  size_t sVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  char local_55;
  undefined8 local_50;
  long local_48;
  undefined8 local_40;
  undefined8 local_38;
  long local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = 0x26;
  local_48 = _libssh2_list_first(param_1 + 0x218);
  local_55 = '\x01';
  if (*param_4 == 0) {
    local_38 = 0x14;
    local_50 = 0;
    local_28 = param_2;
    local_18 = param_3;
    if (param_3 < 0x14) {
      local_20 = param_2;
      uVar4 = _libssh2_error(param_1,0xffffffd7,"Unexpected packet size");
      goto LAB_0012ae5a;
    }
    local_20 = param_2 + 0x14;
    iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x10);
    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting channel");
      goto LAB_0012ae5a;
    }
    iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x11);
    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting window size");
      goto LAB_0012ae5a;
    }
    iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x12);
    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting packet");
      goto LAB_0012ae5a;
    }

    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting host");
      goto LAB_0012ae5a;
    }
    param_4[0x15] = (int)local_50;
    iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x13);
    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting port");
      goto LAB_0012ae5a;
    }

    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting shost");
      goto LAB_0012ae5a;
    }
    param_4[0x16] = (int)local_50;
    iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x14);
    if (iVar1 != 0) {
      uVar4 = _libssh2_error(param_1,0xffffffda,"Data too short extracting sport");
      goto LAB_0012ae5a;
    }
    *param_4 = 1;
  }
  if (*param_4 != 3) {
    while (local_48 != 0) {
      if (((*(int *)(local_48 + 0x28) == param_4[0x13]) &&
          (sVar5 = strlen(*(char **)(local_48 + 0x20)), sVar5 == (ulong)(uint)param_4[0x15])) &&
         (iVar1 = memcmp(*(void **)(local_48 + 0x20),*(void **)(param_4 + 0xc),
                         (ulong)(uint)param_4[0x15]), iVar1 == 0)) {
        local_30 = 0;
        *(undefined8 *)(param_4 + 0x18) = 0;
        if (*param_4 == 1) {
          if ((*(int *)(local_48 + 0x44) != 0) &&
             (*(int *)(local_48 + 0x44) <= *(int *)(local_48 + 0x40))) {
            local_55 = '\x04';
            *param_4 = 3;
            break;
          }
          local_30 = _libssh2_calloc(param_1,0x2f0);
          if (local_30 == 0) {
            _libssh2_error(param_1,0xfffffffa,"Unable to allocate a channel for new connection");
            local_55 = '\x04';
            *param_4 = 3;
            break;
          }
          *(long *)(param_4 + 0x18) = local_30;
          *(long *)(local_30 + 0x60) = param_1;
          *(undefined4 *)(local_30 + 0x20) = 0xf;
          uVar6 = (ulong)(*(int *)(local_30 + 0x20) + 1);
          uVar4 = ((void*(*)())(param_1 + 8))(uVar6,param_1,param_1,uVar6);
          *(undefined8 *)(local_30 + 0x18) = uVar4;
          if (*(long *)(local_30 + 0x18) == 0) {
            _libssh2_error(param_1,0xfffffffa,"Unable to allocate a channel for new connection");
            ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
            local_55 = '\x04';
            *param_4 = 3;
            break;
          }
          memcpy(*(void **)(local_30 + 0x18),"forwarded-tcpip",
                 (ulong)(*(int *)(local_30 + 0x20) + 1));
          *(int *)(local_30 + 0x44) = param_4[0x10];
          *(undefined4 *)(local_30 + 0x48) = 0x200000;
          *(undefined4 *)(local_30 + 0x4c) = 0x200000;
          *(undefined4 *)(local_30 + 0x50) = 0x8000;
          uVar2 = _libssh2_channel_nextid(param_1);
          *(undefined4 *)(local_30 + 0x30) = uVar2;
          *(int *)(local_30 + 0x34) = param_4[0x11];
          *(int *)(local_30 + 0x38) = param_4[0x11];
          *(int *)(local_30 + 0x3c) = param_4[0x12];
          local_28 = (long)param_4 + 5;
          *(undefined *)(param_4 + 1) = 0x5b;
          _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_30 + 0x44));

          _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_30 + 0x30));
          _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_30 + 0x48));
          _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_30 + 0x50));
          *param_4 = 2;
        }
        if (*param_4 == 2) {
          uVar3 = _libssh2_transport_send(param_1,param_4 + 1,0x11,0,0);
          if (uVar3 == 0xffffffdb) {
            uVar4 = 0xffffffdb;
          }
          else {
            if (uVar3 == 0) {
              if (*(long *)(param_4 + 0x18) != 0) {
                _libssh2_list_add(local_48 + 0x30,*(undefined8 *)(param_4 + 0x18));

                *(int *)(local_48 + 0x40) = *(int *)(local_48 + 0x40) + 1;
              }
              *param_4 = 0;
              uVar4 = 0;
            }
            else {
              *param_4 = 0;
              uVar4 = _libssh2_error(param_1,(ulong)uVar3,"Unable to send channel open confirmation"
                                     ,(ulong)uVar3);
            }
          }
          goto LAB_0012ae5a;
        }
      }
      local_48 = _libssh2_list_next(local_48);
    }
    *param_4 = 3;
  }
  local_28 = (long)param_4 + 5;
  *(undefined *)(param_4 + 1) = 0x5c;
  _libssh2_store_u32(&local_28,(ulong)(uint)param_4[0x10]);
  _libssh2_store_u32(&local_28,(ulong)(uint)(int)local_55);
  _libssh2_store_str(&local_28,"Forward not requested",0x15);
  _libssh2_htonu32(local_28,0);
  uVar3 = _libssh2_transport_send(param_1,param_4 + 1,local_40,0,0);
  if (uVar3 == 0xffffffdb) {
    uVar4 = 0xffffffdb;
  }
  else {
    if (uVar3 == 0) {
      *param_4 = 0;
      uVar4 = 0;
    }
    else {
      *param_4 = 0;
      uVar4 = _libssh2_error(param_1,(ulong)uVar3,"Unable to send open failure",(ulong)uVar3);
    }
  }
LAB_0012ae5a:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 FUN_0012ae70(long param_1,long param_2,ulong param_3,int *param_4)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined8 uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  uint local_50;
  undefined8 local_48;
  long local_40;
  undefined8 local_38;
  undefined8 local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_50 = 2;
  local_38 = 0x28;
  local_40 = *(long *)(param_4 + 0x14);
  if (*param_4 == 0) {
    local_30 = 8;
    local_48 = 0;
    local_28 = param_2;
    local_18 = param_3;
    if (param_3 < 8) {
      local_20 = param_2;
      _libssh2_error(param_1,0xffffffde,"unexpected data length");
      local_50 = 2;
    }
    else {
      local_20 = param_2 + 8;
      iVar1 = _libssh2_get_u32(&local_28,param_4 + 0xe);
      if (iVar1 == 0) {
        iVar1 = _libssh2_get_u32(&local_28,param_4 + 0xf);
        if (iVar1 == 0) {
          iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x10);
          if (iVar1 == 0) {

            if (iVar1 == 0) {
              param_4[0x12] = (int)local_48;
              iVar1 = _libssh2_get_u32(&local_28,param_4 + 0x11);
              if (iVar1 == 0) {
                *param_4 = 1;
                goto LAB_0012b07c;
              }
              _libssh2_error(param_1,0xffffffde,"unexpected port size");
              local_50 = 2;
            }
            else {
              _libssh2_error(param_1,0xffffffde,"unexpected host size");
              local_50 = 2;
            }
          }
          else {
            _libssh2_error(param_1,0xffffffde,"unexpected window size");
            local_50 = 2;
          }
        }
        else {
          _libssh2_error(param_1,0xffffffde,"unexpected window size");
          local_50 = 2;
        }
      }
      else {
        _libssh2_error(param_1,0xffffffde,"unexpected sender channel size");
        local_50 = 2;
      }
    }
  }
  else {
LAB_0012b07c:
    if (*(long *)(param_1 + 0x40) == 0) {
      local_50 = 4;
    }
    else {
      if (*param_4 == 1) {
        local_40 = _libssh2_calloc(param_1,0x2f0);
        if (local_40 == 0) {
          _libssh2_error(param_1,0xfffffffa,"allocate a channel for new connection");
          local_50 = 4;
        }
        else {
          *(long *)(local_40 + 0x60) = param_1;
          *(undefined4 *)(local_40 + 0x20) = 3;
          uVar5 = (ulong)(*(int *)(local_40 + 0x20) + 1);
          uVar4 = ((void*(*)())(param_1 + 8))(uVar5,param_1,param_1,uVar5);
          *(undefined8 *)(local_40 + 0x18) = uVar4;
          if (*(long *)(local_40 + 0x18) != 0) {
            memcpy(*(void **)(local_40 + 0x18),&DAT_00147bee,(ulong)(*(int *)(local_40 + 0x20) + 1))
            ;
            *(int *)(local_40 + 0x44) = param_4[0xe];
            *(undefined4 *)(local_40 + 0x48) = 0x200000;
            *(undefined4 *)(local_40 + 0x4c) = 0x200000;
            *(undefined4 *)(local_40 + 0x50) = 0x8000;
            uVar2 = _libssh2_channel_nextid(param_1);
            *(undefined4 *)(local_40 + 0x30) = uVar2;
            *(int *)(local_40 + 0x34) = param_4[0xf];
            *(int *)(local_40 + 0x38) = param_4[0xf];
            *(int *)(local_40 + 0x3c) = param_4[0x10];
            local_28 = (long)param_4 + 5;
            *(undefined *)(param_4 + 1) = 0x5b;
            _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_40 + 0x44));

            _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_40 + 0x30));

            _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_40 + 0x48));

            _libssh2_store_u32(&local_28,(ulong)*(uint *)(local_40 + 0x50));

            *param_4 = 2;
            goto LAB_0012b271;
          }
          _libssh2_error(param_1,0xfffffffa,"allocate a channel for new connection");
          ((void*(*)())(param_1 + 0x18))(local_40,param_1,local_40,param_1);
          local_50 = 4;
        }
      }
      else {
LAB_0012b271:
        if (*param_4 == 2) {
          iVar1 = _libssh2_transport_send(param_1,param_4 + 1,0x11,0,0);
          if (iVar1 == -0x25) {
            uVar4 = 0xffffffdb;
          }
          else {
            if (iVar1 == 0) {
              _libssh2_list_add(param_1 + 0x200,local_40);
              ((void*(*)())(*(long *)(local_40 + 0x60) + 0x40))
                        (*(undefined8 *)(local_40 + 0x60),local_40,*(undefined8 *)(param_4 + 0xc),
                         (ulong)(uint)param_4[0x11],*(undefined8 *)(local_40 + 0x60));
              *param_4 = 0;
              uVar4 = 0;
            }
            else {
              *param_4 = 0;
              uVar4 = _libssh2_error(param_1,0xfffffff9,"Unable to send channel open confirmation");
            }
          }
          goto LAB_0012b425;
        }
      }
    }
  }
  local_28 = (long)param_4 + 5;
  *(undefined *)(param_4 + 1) = 0x5c;
  _libssh2_store_u32(&local_28,(ulong)(uint)param_4[0xe]);
  _libssh2_store_u32(&local_28,(ulong)local_50);
  _libssh2_store_str(&local_28,"X11 Forward Unavailable",0x17);
  _libssh2_htonu32(local_28,0);
  uVar3 = _libssh2_transport_send(param_1,param_4 + 1,local_38,0,0);
  if (uVar3 == 0xffffffdb) {
    uVar4 = 0xffffffdb;
  }
  else {
    if (uVar3 == 0) {
      *param_4 = 0;
      uVar4 = 0;
    }
    else {
      *param_4 = 0;
      uVar4 = _libssh2_error(param_1,(ulong)uVar3,"Unable to send open failure",(ulong)uVar3);
    }
  }
LAB_0012b425:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



// WARNING: Could not reconcile some variable overlaps

ulong _libssh2_packet_add(long param_1,char *param_2,ulong param_3,int param_4)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined8 uVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  ulong local_b0;
  char local_93;
  char local_92;
  uint local_90;
  uint local_8c;
  uint local_88;
  int local_84;
  uint local_80;
  int local_7c;
  uint local_78;
  uint local_74;
  undefined8 local_70;
  undefined8 local_68;
  ulong local_60;
  ulong local_58;
  long local_50;
  ulong local_48;
  long local_40;
  char *local_38;
  char *local_30;
  ulong local_28;
  undefined local_15;
  undefined4 local_14;
  long local_10;
  

  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_8c = 0;
  local_70 = 0;
  local_68 = 0;
  local_60 = 0;
  local_58 = 0;
  local_50 = 0;
  local_48 = 0;
  cVar1 = *param_2;
  switch(*(undefined4 *)(param_1 + 0xd2b0)) {
  case 0:
    if ((param_4 == -1) &&
       ((*(long *)(param_1 + 0x38) == 0 ||
        (iVar2 = ((void*(*)())(param_1 + 0x38))(param_1,param_2,param_3 & 0xffffffff), iVar2 != 0))))
    {
      ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
      uVar6 = _libssh2_error(param_1,0xfffffffc,"Invalid MAC received");
      goto LAB_0012c576;
    }
    *(undefined4 *)(param_1 + 0xd2b0) = 1;
    break;
  case 0xb:
    goto LAB_0012bb61;
  case 0xc:
    goto LAB_0012c1a4;
  case 0xd:
    goto LAB_0012c25a;
  case 0xe:
    goto LAB_0012bfc5;
  case 0xf:
    goto LAB_0012b977;
  }
  local_b0 = param_3;
  if (*(int *)(param_1 + 0xd2b0) != 1) goto LAB_0012c39f;
  switch(cVar1) {
  default:
    goto LAB_0012c38e;
  case '\x01':
    if (4 < param_3) {
      local_90 = 0;
      local_30 = param_2 + 1;
      local_38 = param_2;
      local_28 = param_3;
      _libssh2_get_u32(&local_38,&local_90);

      uVar5 = 0x12b66a;

      if (*(long *)(param_1 + 0x30) != 0) {
        ((void*(*)())(param_1 + 0x30))
                  (param_1,(ulong)local_90,local_70,local_60 & 0xffffffff,local_68,
                   local_58 & 0xffffffff,param_1,uVar5);
      }
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0x22c) = 0xffffffff;
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    _libssh2_error(param_1,0xfffffff3,"socket disconnect");
    break;
  case '\x02':
    if (param_3 < 2) {
      if (*(long *)(param_1 + 0x20) != 0) {
        ((void*(*)())(param_1 + 0x20))(param_1,&DAT_00147c31,0,param_1);
      }
    }
    else {
      if (*(long *)(param_1 + 0x20) != 0) {
        ((void*(*)())(param_1 + 0x20))(param_1,param_2 + 1,(ulong)((int)local_b0 - 1),param_1);
      }
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    uVar6 = 0;
    break;
  case '\x04':
    if (1 < param_3) {
      local_74 = (uint)(byte)param_2[1];
      if (5 < param_3) {
        local_30 = param_2 + 2;
        local_38 = param_2;
        local_28 = param_3;


      }
      if (*(long *)(param_1 + 0x28) != 0) {
        ((void*(*)())(param_1 + 0x28))
                  (param_1,(ulong)local_74,local_70,local_60 & 0xffffffff,local_68,
                   local_58 & 0xffffffff,param_1);
      }
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    uVar6 = 0;
    break;
  case 'P':
    if (4 < param_3) {
      local_78 = 0;
      local_93 = '\0';
      local_78 = _libssh2_ntohu32(param_2 + 1);
      if ((local_78 < 0xfffffffa) && (local_78 + 6 <= param_3)) {
        local_93 = param_2[local_78 + 5];
      }
      if (local_93 != '\0') {
LAB_0012b977:
        *(undefined4 *)(param_1 + 0xd2b0) = 0xf;
        local_8c = _libssh2_transport_send(param_1,&DAT_00147f18,1,0,0);
        if (local_8c == 0xffffffdb) {
          uVar6 = 0xffffffdb;
          break;
        }
      }
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    uVar6 = 0;
    break;
  case 'Z':
    if (0x10 < param_3) {
      if (((param_3 < 0x14) || (iVar2 = _libssh2_ntohu32(param_2 + 1), iVar2 != 0xf)) ||
         (iVar2 = memcmp(param_2 + 5,"forwarded-tcpip",0xf), iVar2 != 0)) {
        if (((7 < param_3) && (iVar2 = _libssh2_ntohu32(param_2 + 1), iVar2 == 3)) &&
           (iVar2 = memcmp(param_2 + 5,&DAT_00147bee,3), iVar2 == 0)) {
          memset((void *)(param_1 + 0xd328),0,0x58);
LAB_0012c25a:
          *(undefined4 *)(param_1 + 0xd2b0) = 0xd;
          local_8c = FUN_0012ae70(param_1,param_2,param_3,param_1 + 0xd328);
        }
      }
      else {
        memset((void *)(param_1 + 0xd2c0),0,0x68);
LAB_0012c1a4:
        *(undefined4 *)(param_1 + 0xd2b0) = 0xc;
        local_8c = FUN_0012a779(param_1,param_2,param_3,param_1 + 0xd2c0);
      }
    }
    if (local_8c == 0xffffffdb) {
      uVar6 = 0xffffffdb;
    }
    else {
      ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b0) = 0;
      uVar6 = (ulong)local_8c;
    }
    break;
  case ']':
    if (8 < param_3) {
      local_7c = _libssh2_ntohu32(param_2 + 5);
      uVar4 = _libssh2_ntohu32(param_2 + 1);
      local_50 = _libssh2_channel_locate(param_1,(ulong)uVar4,(ulong)uVar4);
      if (local_50 != 0) {
        *(int *)(local_50 + 0x38) = *(int *)(local_50 + 0x38) + local_7c;
      }
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    uVar6 = 0;
    break;
  case '^':
    goto switchD_0012b5e2_caseD_5e;
  case '_':
    local_48 = local_48 + 4;
switchD_0012b5e2_caseD_5e:
    local_48 = local_48 + 9;
    if (local_48 <= param_3) {
      uVar4 = _libssh2_ntohu32(param_2 + 1);
      local_50 = _libssh2_channel_locate(param_1,(ulong)uVar4,(ulong)uVar4);
    }
    if (local_50 == 0) {
      _libssh2_error(param_1,0xffffffe9,"Packet received for unknown channel");
      ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b0) = 0;
      uVar6 = 0;
    }
    else {
      if ((*(char *)(local_50 + 0x56) == '\x01') && (cVar1 == '_')) {
        ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2);




        *(int *)(local_50 + 0x4c) = ((int)local_48 - (int)local_b0) + *(int *)(local_50 + 0x4c);
        *(long *)(param_1 + 0xd2b8) = local_50;
LAB_0012bb61:
        *(undefined4 *)(param_1 + 0xd2b0) = 0xb;
        local_8c = _libssh2_channel_receive_window_adjust
                             (*(undefined8 *)(param_1 + 0xd2b8),(ulong)((int)local_b0 - 0xd),1,0);
        if (local_8c == 0xffffffdb) {
          uVar6 = 0xffffffdb;
        }
        else {
          *(undefined4 *)(param_1 + 0xd2b0) = 0;
          uVar6 = 0;
        }
      }
      else {
        if ((ulong)*(uint *)(local_50 + 0x50) < param_3 - local_48) {
          _libssh2_error(param_1,0xffffffe7,
                         "Packet contains more data than we offered to receive, truncating");
          local_b0 = local_48 + *(uint *)(local_50 + 0x50);
        }
        if (*(uint *)(local_50 + 0x5c) < *(uint *)(local_50 + 0x4c)) {
          *(undefined *)(local_50 + 0x55) = 0;
          if ((ulong)*(uint *)(local_50 + 0x4c) < (local_b0 + *(uint *)(local_50 + 0x5c)) - local_48
             ) {
            _libssh2_error(param_1,0xffffffe8,
                           "Remote sent more data than current window allows, truncating");
            local_b0 = local_48 + (uint)(*(int *)(local_50 + 0x4c) - *(int *)(local_50 + 0x5c));
          }
          *(int *)(local_50 + 0x5c) = ((int)local_b0 - (int)local_48) + *(int *)(local_50 + 0x5c);
LAB_0012c38e:
          *(undefined4 *)(param_1 + 0xd2b0) = 3;
LAB_0012c39f:
          if (*(int *)(param_1 + 0xd2b0) == 3) {
            local_40 = ((void*(*)())(param_1 + 8))(0x30,param_1,param_1);
            if (local_40 == 0) {
              ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
              *(undefined4 *)(param_1 + 0xd2b0) = 0;
              uVar6 = 0xfffffffa;
              break;
            }
            *(char **)(local_40 + 0x18) = param_2;
            *(ulong *)(local_40 + 0x20) = local_b0;
            *(ulong *)(local_40 + 0x28) = local_48;
            _libssh2_list_add(param_1 + 0x1f0,local_40);
            *(undefined4 *)(param_1 + 0xd2b0) = 4;
          }
          if (((cVar1 == '\x14') && ((*(uint *)(param_1 + 0x68) & 1) == 0)) ||
             (*(int *)(param_1 + 0xd2b0) == 5)) {
            if (*(int *)(param_1 + 0xd2b0) == 4) {
              *(undefined4 *)(param_1 + 0xd2b0) = 5;
            }
            *(undefined4 *)(param_1 + 0xd088) = 0;
            *(undefined8 *)(param_1 + 0x4270) = 0;
            *(undefined4 *)(param_1 + 0xd2b0) = 0;
            *(undefined4 *)(param_1 + 0xd380) = 0;
            memset((void *)(param_1 + 0xccd0),0,0x298);
            local_8c = _libssh2_kex_exchange(param_1,1,param_1 + 0xccd0);
            if (local_8c == 0xffffffdb) {
              uVar6 = 0xffffffdb;
              break;
            }
          }
          *(undefined4 *)(param_1 + 0xd2b0) = 0;
          uVar6 = 0;
        }
        else {
          _libssh2_error(param_1,0xffffffe8,"The current receive window is full, data ignored");
          ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
          *(undefined4 *)(param_1 + 0xd2b0) = 0;
          uVar6 = 0;
        }
      }
    }
    break;
  case '`':
    if (4 < param_3) {
      uVar4 = _libssh2_ntohu32(param_2 + 1);
      local_50 = _libssh2_channel_locate(param_1,(ulong)uVar4,(ulong)uVar4);
    }
    if (local_50 != 0) {
      *(undefined *)(local_50 + 0x55) = 1;
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    uVar6 = 0;
    break;
  case 'a':
    if (4 < param_3) {
      uVar4 = _libssh2_ntohu32(param_2 + 1);
      local_50 = _libssh2_channel_locate(param_1,(ulong)uVar4,(ulong)uVar4);
    }
    if (local_50 == 0) {
      ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b0) = 0;
      uVar6 = 0;
    }
    else {
      *(undefined *)(local_50 + 0x54) = 1;
      *(undefined *)(local_50 + 0x55) = 1;
      ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b0) = 0;
      uVar6 = 0;
    }
    break;
  case 'b':
    if (8 < param_3) {
      local_88 = _libssh2_ntohu32(param_2 + 1);
      local_84 = _libssh2_ntohu32(param_2 + 5);
      local_92 = '\x01';
      if (local_84 + 9 < param_3) {
        local_92 = param_2[local_84 + 9];
      }
      if (((local_84 == 0xb) && (0x13 < param_3)) &&
         (iVar2 = memcmp("exit-status",param_2 + 9,0xb), iVar2 == 0)) {
        if (0x13 < param_3) {
          local_50 = _libssh2_channel_locate(param_1,(ulong)local_88,(ulong)local_88);
        }
        if ((local_50 != 0) && (0x18 < param_3)) {
          uVar3 = _libssh2_ntohu32(param_2 + 0x15);
          *(undefined4 *)(local_50 + 0x24) = uVar3;
        }
      }
      else {
        if (((local_84 == 0xb) && (0x13 < param_3)) &&
           (iVar2 = memcmp("exit-signal",param_2 + 9,0xb), iVar2 == 0)) {
          if (0x13 < param_3) {
            local_50 = _libssh2_channel_locate(param_1,(ulong)local_88,(ulong)local_88);
          }
          if ((local_50 != 0) && (0x18 < param_3)) {
            local_80 = _libssh2_ntohu32(param_2 + 0x15);
            uVar5 = ((void*(*)())(param_1 + 8))
                              ((ulong)(local_80 + 1),param_1,param_1,(ulong)(local_80 + 1));
            *(undefined8 *)(local_50 + 0x28) = uVar5;
            if (*(long *)(local_50 + 0x28) == 0) {
              local_8c = _libssh2_error(param_1,0xfffffffa,"memory for signal name");
            }
            else {
              memcpy(*(void **)(local_50 + 0x28),param_2 + 0x19,(ulong)local_80);
              *(undefined *)((ulong)local_80 + *(long *)(local_50 + 0x28)) = 0;
            }
          }
        }
      }
      if (local_92 != '\0') {
LAB_0012bfc5:
        *(undefined4 *)(param_1 + 0xd2b0) = 0xe;
        local_15 = 100;
        local_14 = *(undefined4 *)(param_2 + 1);
        local_8c = _libssh2_transport_send(param_1,&local_15,5,0,0);
        if (local_8c == 0xffffffdb) {
          uVar6 = 0xffffffdb;
          break;
        }
      }
    }
    ((void*(*)())(param_1 + 0x18))(param_2,param_1,param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b0) = 0;
    uVar6 = (ulong)local_8c;
  }
LAB_0012c576:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar6;
}



undefined8 FUN_0012cd01(void *param_1,long param_2,long param_3,ulong param_4,long *param_5)

{
  long lVar1;
  ulong local_18;
  
  lVar1 = *param_5;
  local_18 = 0;
  while ((((local_18 + lVar1 < param_4 && (local_18 < param_2 - 1U)) &&
          (*(char *)(param_3 + lVar1 + local_18) != '\n')) &&
         (*(char *)(param_3 + lVar1 + local_18) != '\r'))) {
    local_18 = local_18 + 1;
  }
  if (local_18 != 0) {
    memcpy(param_1,(void *)(param_3 + lVar1),local_18);
    *param_5 = *param_5 + local_18;
  }
  *(undefined *)(local_18 + (long)param_1) = 0;
  *param_5 = *param_5 + 1;
  return 0;
}



ulong FUN_0012cdea(byte param_1)

{
  uint uVar1;
  
  if ((char)param_1 < 'A') {
    uVar1 = (uint)param_1 - 0x30;
  }
  else {
    uVar1 = (uint)param_1 - 0x37;
  }
  return (ulong)uVar1;
}



ulong _libssh2_pem_parse(long param_1,char *param_2,char *param_3,char *param_4,undefined8 param_5,
                        long *param_6,uint *param_7)

{
  long *plVar1;
  byte bVar2;
  int iVar3;
  ulong uVar4;
  size_t __n;
  long in_FS_OFFSET;
  undefined4 local_1a8;
  int local_1a4;
  uint local_1a0;
  uint local_19c;
  int local_198;
  int local_194;
  uint local_190;
  uint local_18c;
  undefined local_188 [8];
  EVP_MD_CTX *local_180;
  long local_178;
  long local_170;
  long *local_168;
  long local_160;
  size_t local_158;
  long local_150;
  uchar local_148 [16];
  uchar auStack312 [16];
  char local_128;
  undefined auStack295 [127];
  byte local_a8 [136];
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_178 = 0;
  local_1a0 = 0;
  local_170 = 0;
  do {
    local_128 = '\0';
    iVar3 = FUN_0012cc1e(&local_128,0x80,param_5);
    if (iVar3 != 0) {
      uVar4 = 0xffffffff;
      goto LAB_0012d7a8;
    }
    iVar3 = strcmp(&local_128,param_2);
  } while (iVar3 != 0);
  iVar3 = FUN_0012cc1e(&local_128,0x80,param_5);
  if (iVar3 != 0) {
    uVar4 = 0xffffffff;
    goto LAB_0012d7a8;
  }
  if (param_4 == (char *)0x0) {
LAB_0012d119:
    do {
      if (local_128 != '\0') {
        local_158 = strlen(&local_128);
        if (local_178 == 0) {
          local_150 = ((void*(*)())(param_1 + 8))
                                (local_158 + local_1a0,param_1,param_1,local_158 + local_1a0);
        }
        else {
          local_150 = ((void*(*)())(param_1 + 0x10))
                                (local_178,local_1a0 + local_158,param_1,local_178);
        }
        if (local_150 == 0) {
          local_19c = 0xffffffff;
          goto LAB_0012d75f;
        }
        memcpy((void *)((ulong)local_1a0 + local_150),&local_128,local_158);
        local_178 = local_150;
        local_1a0 = local_1a0 + (int)local_158;
      }
      local_128 = '\0';
      iVar3 = FUN_0012cc1e(&local_128,0x80,param_5);
      if (iVar3 != 0) {
        local_19c = 0xffffffff;
        goto LAB_0012d75f;
      }
      iVar3 = strcmp(&local_128,param_3);
    } while (iVar3 != 0);
    if (local_178 == 0) {
      uVar4 = 0xffffffff;
      goto LAB_0012d7a8;
    }
    iVar3 = libssh2_base64_decode(param_1,param_6,param_7,local_178,(ulong)local_1a0);
    if (iVar3 == 0) {
      if (local_170 == 0) {
LAB_0012d755:
        local_19c = 0;
      }
      else {
        local_1a8 = 0;
        local_1a4 = 0;
        local_194 = 0;
        local_190 = 0;
        local_18c = *(uint *)(local_170 + 0x10);
        iVar3 = _libssh2_md5_init(&local_180);
        if (iVar3 == 0) {
          local_19c = 0xffffffff;
        }
        else {
          __n = strlen(param_4);
          EVP_DigestUpdate(local_180,param_4,__n);
          EVP_DigestUpdate(local_180,local_a8,8);
          EVP_DigestFinal(local_180,local_148,(uint *)0x0);
          EVP_MD_CTX_free(local_180);
          if (0x10 < *(int *)(local_170 + 0x18)) {
            iVar3 = _libssh2_md5_init(&local_180);
            if (iVar3 == 0) {
              local_19c = 0xffffffff;
              goto LAB_0012d75f;
            }
            EVP_DigestUpdate(local_180,local_148,0x10);
            __n = strlen(param_4);
            EVP_DigestUpdate(local_180,param_4,__n);
            EVP_DigestUpdate(local_180,local_a8,8);
            EVP_DigestFinal(local_180,auStack312,(uint *)0x0);
            EVP_MD_CTX_free(local_180);
          }
          iVar3 = ((void*(*)())(local_170 + 0x28))
                            (param_1,local_170,local_a8,&local_1a8,local_148,&local_1a4,0,local_188)
          ;
          if (iVar3 == 0) {



            if (*param_7 % local_18c == 0) {
              while (local_194 <= (int)(*param_7 - local_18c)) {
                iVar3 = ((void*(*)())(local_170 + 0x30))
                                  (param_1,*param_6 + (long)local_194,(long)(int)local_18c,local_188
                                  );
                if (iVar3 != 0) {
                  local_19c = 0xfffffff4;
                  _libssh2_explicit_zero(local_148,0x20);
                  ((void*(*)())(local_170 + 0x38))(param_1,local_188,param_1,local_188);
                  _libssh2_explicit_zero(*param_6,(ulong)*param_7);
                  ((void*(*)())(param_1 + 0x18))(*param_6,param_1,*param_6,param_1);
                  goto LAB_0012d75f;
                }
                local_194 = local_194 + local_18c;
              }
              local_190 = (uint)*(byte *)((ulong)(*param_7 - 1) + *param_6);
              memset((void *)(*param_6 + (ulong)(*param_7 - local_190)),0,(long)(int)local_190);
              *param_7 = *param_7 - local_190;
              _libssh2_explicit_zero(local_148,0x20);
              ((void*(*)())(local_170 + 0x38))(param_1,local_188,param_1,local_188);
              goto LAB_0012d755;
            }
            _libssh2_explicit_zero(local_148,0x20);
            ((void*(*)())(local_170 + 0x38))(param_1,local_188,param_1,local_188);
            _libssh2_explicit_zero(*param_6,(ulong)*param_7);
            ((void*(*)())(param_1 + 0x18))(*param_6,param_1,*param_6,param_1);
            local_19c = 0xffffffff;
          }
          else {
            _libssh2_explicit_zero(local_148,0x20);
            ((void*(*)())(param_1 + 0x18))(param_6,param_1,param_6,param_1);
            local_19c = 0xffffffff;
          }
        }
      }
    }
    else {
      local_19c = 0xffffffff;
    }
  }
  else {
    __n = strlen(PTR_s_Proc_Type__4_ENCRYPTED_00350af0);
    iVar3 = memcmp(&local_128,PTR_s_Proc_Type__4_ENCRYPTED_00350af0,__n);
    if (iVar3 != 0) goto LAB_0012d119;
    iVar3 = FUN_0012cc1e(&local_128,0x80,param_5);
    if (iVar3 == 0) {
      local_168 = (long *)libssh2_crypt_methods();
      while( 1 ) {
        plVar1 = local_168 + 1;
        local_160 = *local_168;
        local_168 = plVar1;
        if (local_160 == 0) break;
        if (**(char **)(local_160 + 8) != '\0') {
          __n = strlen(*(char **)(local_160 + 8));
          iVar3 = memcmp(&local_128,*(void **)(local_160 + 8),__n);
          if (iVar3 == 0) {
            local_170 = local_160;
            iVar3 = *(int *)(local_160 + 0x14);
            __n = strlen(*(char **)(local_160 + 8));
            memcpy(local_a8,auStack295 + __n,(long)(iVar3 * 2));
          }
        }
      }
      if (local_170 == 0) {
        uVar4 = 0xffffffff;
        goto LAB_0012d7a8;
      }
      local_198 = 0;
      while (local_198 < *(int *)(local_170 + 0x14)) {
        iVar3 = FUN_0012cdea((ulong)(uint)(int)(char)local_a8[local_198 * 2]);
        local_a8[local_198] = (byte)(iVar3 << 4);

        local_a8[local_198] = bVar2 | local_a8[local_198];
        local_198 = local_198 + 1;
      }
      iVar3 = FUN_0012cc1e(&local_128,0x80,param_5);
      if (iVar3 == 0) goto LAB_0012d119;
      local_19c = 0xffffffff;
    }
    else {
      local_19c = 0xffffffff;
    }
  }
LAB_0012d75f:
  if (local_178 != 0) {
    _libssh2_explicit_zero(local_178,(ulong)local_1a0);
    ((void*(*)())(param_1 + 0x18))(local_178,param_1,local_178,param_1);
  }
  uVar4 = (ulong)local_19c;
LAB_0012d7a8:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong _libssh2_pem_parse_memory
                (long param_1,char *param_2,char *param_3,undefined8 param_4,undefined8 param_5,
                undefined8 param_6,undefined8 param_7)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_c0;
  uint local_bc;
  undefined8 local_b8;
  long local_b0;
  size_t local_a8;
  long local_a0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_b0 = 0;
  local_c0 = 0;
  local_b8 = 0;
  do {
    local_98[0] = '\0';
    iVar1 = FUN_0012cd01(local_98,0x80,param_4,param_5,&local_b8);
    if (iVar1 != 0) {
      uVar2 = 0xffffffff;
      goto LAB_0012da8c;
    }
    iVar1 = strcmp(local_98,param_2);
  } while (iVar1 != 0);
  local_98[0] = '\0';
  do {
    if (local_98[0] != '\0') {
      local_a8 = strlen(local_98);
      if (local_b0 == 0) {
        local_a0 = ((void*(*)())(param_1 + 8))
                             (local_a8 + local_c0,param_1,param_1,local_a8 + local_c0);
      }
      else {
        local_a0 = ((void*(*)())(param_1 + 0x10))(local_b0,local_c0 + local_a8,param_1,local_b0);
      }
      if (local_a0 == 0) {
        local_bc = 0xffffffff;
        goto LAB_0012da43;
      }
      memcpy((void *)((ulong)local_c0 + local_a0),local_98,local_a8);
      local_b0 = local_a0;
      local_c0 = local_c0 + (int)local_a8;
    }
    local_98[0] = '\0';
    iVar1 = FUN_0012cd01(local_98,0x80,param_4,param_5,&local_b8);
    if (iVar1 != 0) {
      local_bc = 0xffffffff;
      goto LAB_0012da43;
    }
    iVar1 = strcmp(local_98,param_3);
  } while (iVar1 != 0);
  if (local_b0 == 0) {
    uVar2 = 0xffffffff;
  }
  else {
    iVar1 = libssh2_base64_decode(param_1,param_6,param_7,local_b0,(ulong)local_c0);
    if (iVar1 == 0) {
      local_bc = 0;
    }
    else {
      local_bc = 0xffffffff;
    }
LAB_0012da43:
    if (local_b0 != 0) {
      _libssh2_explicit_zero(local_b0,(ulong)local_c0);
      ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
    }
    uVar2 = (ulong)local_bc;
  }
LAB_0012da8c:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

ulong FUN_0012daa2(long param_1,char *param_2,undefined8 param_3,ulong param_4,long **param_5)

{
  char **ppcVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  int iVar4;
  size_t __n;
  void *pvVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  undefined8 uVar7;
  int local_13c;
  uint local_138;
  uint local_134;
  undefined4 local_130;
  int local_12c;
  uint local_128;
  int local_124;
  int local_120;
  int local_11c;
  int local_118;
  int local_114;
  char *local_110;
  char *local_108;
  undefined8 local_100;
  void *local_f8;
  undefined8 local_f0;
  char *local_e8;
  undefined8 local_e0;
  void *local_d8;
  undefined8 local_d0;
  undefined8 local_c8;
  char **local_c0;
  void *local_b8;
  void *local_b0;
  void *local_a8;
  char **local_a0;
  char **local_98;
  void **local_90;
  char *local_88;
  char *local_80;
  ulong local_78;
  void *local_68;
  void *local_60;
  void *local_58;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  local_c0 = (char **)0x0;
  local_110 = (char *)0x0;
  local_108 = (char *)0x0;
  local_100 = 0;
  local_f8 = (void *)0x0;
  local_f0 = 0;
  local_138 = 0;
  local_b8 = (void *)0x0;
  local_b0 = (void *)0x0;
  local_a8 = (void *)0x0;
  local_e8 = (char *)0x0;
  local_134 = 0;
  local_128 = 0;
  local_124 = 0;
  local_120 = 0;
  local_11c = 0;
  local_e0 = 0;
  local_d8 = (void *)0x0;
  local_d0 = 0;
  if (param_5 != (long **)0x0) {
    *param_5 = (long *)0x0;
  }
  iVar4 = libssh2_base64_decode(param_1,&local_e8,&local_134,param_3,param_4 & 0xffffffff);
  if (iVar4 != 0) {
    local_128 = 0xffffffff;
    goto LAB_0012e70d;
  }
  local_88 = local_e8;
  local_80 = local_e8;
  local_78 = (ulong)local_134;
  if (local_134 < 0xe) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"key too short");
    goto LAB_0012e70d;
  }
  iVar4 = strncmp(local_e8,"openssh-key-v1",0xe);
  if (iVar4 != 0) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"key auth magic mismatch");
    goto LAB_0012e70d;
  }
  local_80 = local_80 + 0xf;

  if ((iVar4 != 0) || (local_d8 == (void *)0x0)) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"ciphername is missing");
    goto LAB_0012e70d;
  }

  if ((iVar4 != 0) || (local_d8 == (void *)0x0)) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"kdfname is missing");
    goto LAB_0012e70d;
  }

  if (iVar4 != 0) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"kdf is missing");
    goto LAB_0012e70d;
  }
  local_48 = local_100;
  local_40 = local_100;
  local_38 = local_e0;
  if ((param_2 == (char *)0x0) || (*param_2 == '\0')) {
    iVar4 = strcmp(local_110,"none");
    if (iVar4 != 0) {
      local_128 = 0xffffffd0;
      goto LAB_0012e70d;
    }
  }
  iVar4 = strcmp(local_108,"none");
  if (iVar4 != 0) {
    iVar4 = strcmp(local_108,"bcrypt");
    if (iVar4 != 0) {
      local_128 = _libssh2_error(param_1,0xfffffff2,"unknown cipher");
      goto LAB_0012e70d;
    }
  }
  iVar4 = strcmp(local_108,"none");
  if (iVar4 == 0) {
    iVar4 = strcmp(local_110,"none");
    if (iVar4 != 0) {
      local_128 = _libssh2_error(param_1,0xfffffff2,"invalid format");
      goto LAB_0012e70d;
    }
  }
  iVar4 = _libssh2_get_u32(&local_88,&local_13c);
  if ((iVar4 != 0) || (local_13c != 1)) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"Multiple keys are unsupported");
    goto LAB_0012e70d;
  }

  if ((iVar4 != 0) || (local_d8 == (void *)0x0)) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"Invalid private key; expect embedded public key")
    ;
    goto LAB_0012e70d;
  }

  if ((iVar4 != 0) || (local_d8 == (void *)0x0)) {
    local_128 = _libssh2_error(param_1,0xfffffff2,"Private key data not found");
    goto LAB_0012e70d;
  }
  local_60 = local_f8;
  local_68 = local_f8;
  local_58 = local_d8;
  if (local_110 != (char *)0x0) {
    iVar4 = strcmp(local_110,"none");
    if (iVar4 != 0) {
      local_a0 = (char **)libssh2_crypt_methods();
      while( 1 ) {
        ppcVar1 = local_a0 + 1;
        local_98 = (char **)*local_a0;
        local_a0 = ppcVar1;
        if (local_98 == (char **)0x0) break;
        if (**local_98 != '\0') {
          __n = strlen(*local_98);
          iVar4 = memcmp(local_110,*local_98,__n);
          if (iVar4 == 0) {
            local_c0 = local_98;
          }
        }
      }
      if (local_c0 == (char **)0x0) {
        local_128 = _libssh2_error(param_1,0xfffffff2,"No supported cipher found");
        goto LAB_0012e70d;
      }
    }
  }
  if (local_c0 == (char **)0x0) {
LAB_0012e574:
    iVar4 = _libssh2_get_u32(&local_68,&local_12c);
    if (iVar4 == 0) {
      iVar4 = _libssh2_get_u32(&local_68,&local_c8);
      if ((iVar4 == 0) && (local_12c == (int)local_c8)) {
        if (param_5 != (long **)0x0) {
          local_90 = (void **)_libssh2_string_buf_new(param_1);
          if (local_90 == (void **)0x0) {
            local_128 = _libssh2_error(param_1,0xfffffffa,
                                       "Unable to allocate memory for decrypted struct");
          }
          else {
            pvVar5 = (void *)_libssh2_calloc(param_1,local_58);
            *local_90 = pvVar5;
            if (*local_90 == (void *)0x0) {
              local_128 = _libssh2_error(param_1,0xfffffffa,
                                         "Unable to allocate memory for decrypted struct");
              _libssh2_string_buf_free(param_1,local_90,local_90);
            }
            else {
              memcpy(*local_90,local_68,(size_t)local_58);
              local_90[1] = (void *)((long)((long)local_60 - (long)local_68) + (long)*local_90);
              local_90[2] = local_58;
              *(void ***)param_5 = local_90;
            }
          }
        }
        goto LAB_0012e70d;
      }
    }
    _libssh2_error(param_1,0xfffffff2,"Private key unpack failed (correct password?)");
    local_128 = 0xffffffd0;
  }
  else {
    local_130 = 0;
    local_12c = 0;
    local_118 = 0;
    local_c8 = 0;
    local_124 = *(int *)(local_c0 + 3);
    local_120 = *(int *)((long)local_c0 + 0x14);
    local_11c = local_120 + local_124;
    local_b8 = (void *)_libssh2_calloc(param_1,(long)local_11c);
    if (local_b8 == (void *)0x0) {
      local_128 = _libssh2_error(param_1,0xfffffff2,"Could not alloc key");
      goto LAB_0012e70d;
    }
    iVar4 = strcmp(local_108,"bcrypt");
    if ((iVar4 != 0) || (param_2 == (char *)0x0)) {
      local_128 = _libssh2_error(param_1,0xffffffd0,"bcrypted without passphrase");
      ((void*(*)())(param_1 + 0x18))(local_b8,param_1,local_b8,param_1);
      goto LAB_0012e70d;
    }

    if (iVar4 == 0) {
      iVar4 = _libssh2_get_u32(&local_48,&local_138);
      uVar3 = local_d0;
      uVar2 = local_f0;
      if (iVar4 == 0) {
        uVar6 = (ulong)local_138;
        iVar4 = local_120 + local_124;
        uVar7 = 0x12e244;
        __n = strlen(param_2);
         _libssh2_bcrypt_pbkdf(param_2,__n,uVar2,uVar3,local_b8,(long)iVar4,uVar6);
        if (iVar4 < 0) {
          local_128 = _libssh2_error(param_1,0xfffffff4,"invalid format");
          ((void*(*)())(param_1 + 0x18))(local_b8,param_1,local_b8,param_1);
          goto LAB_0012e70d;
        }
        local_114 = *(int *)(local_c0 + 2);
        local_b0 = (void *)_libssh2_calloc(param_1,(long)local_124);
        if (local_b0 == (void *)0x0) {
          local_128 = _libssh2_error(param_1,0xfffffff2,"Could not alloc key part");
          goto LAB_0012e70d;
        }
        local_a8 = (void *)_libssh2_calloc(param_1,(long)local_120);
        if (local_a8 == (void *)0x0) {
          local_128 = _libssh2_error(param_1,0xfffffff2,"Could not alloc iv part");
          goto LAB_0012e70d;
        }
        memcpy(local_b0,local_b8,(long)local_124);
        memcpy(local_a8,(void *)((long)local_124 + (long)local_b8),(long)local_120);


        if (iVar4 != 0) {
          local_128 = 0xfffffff4;
          goto LAB_0012e70d;
        }
        if ((ulong)local_58 % (long)local_114 != 0) {
          local_128 = 0xfffffff4;
          goto LAB_0012e70d;
        }
        while ((void *)(long)local_118 <= (void *)((long)local_58 - (long)local_114)) {

          if (iVar4 != 0) {
            local_128 = 0xfffffff4;
            goto LAB_0012e70d;
          }
          local_118 = local_118 + local_114;
        }
        goto LAB_0012e574;
      }
    }
    local_128 = _libssh2_error(param_1,0xfffffff2,"kdf contains unexpected values");
    ((void*(*)())(param_1 + 0x18))(local_b8,param_1,local_b8,param_1);
  }
LAB_0012e70d:
  if (local_b8 != (void *)0x0) {
    _libssh2_explicit_zero(local_b8,(long)local_11c);
    ((void*(*)())(param_1 + 0x18))(local_b8,param_1,local_b8,param_1);
  }
  if (local_b0 != (void *)0x0) {
    _libssh2_explicit_zero(local_b0,(long)local_124);
    ((void*(*)())(param_1 + 0x18))(local_b0,param_1,local_b0,param_1);
  }
  if (local_a8 != (void *)0x0) {
    _libssh2_explicit_zero(local_a8,(long)local_120);
    ((void*(*)())(param_1 + 0x18))(local_a8,param_1,local_a8,param_1);
  }
  if (local_e8 != (char *)0x0) {
    _libssh2_explicit_zero(local_e8,(ulong)local_134);
    ((void*(*)())(param_1 + 0x18))(local_e8,param_1,local_e8,param_1);
  }
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (ulong)local_128;
}



ulong FUN_0012ee04(byte *param_1,uint param_2,uint *param_3)

{
  ulong uVar1;
  uint local_10;
  
  if (param_2 == 0) {
    uVar1 = 0xffffffff;
  }
  else {
    *param_3 = (uint)*param_1;
    if (*param_3 < 0x80) {
      local_10 = 0;
    }
    else {
      local_10 = *param_3 & 0x7f;
      *param_3 = (uint)param_1[1];
      if (param_2 < local_10 + 1) {
        return 0xffffffff;
      }
      if (1 < local_10) {
        *param_3 = *param_3 << 8;
        *param_3 = *param_3 | (uint)param_1[2];
      }
    }
    if ((local_10 < 3) && (local_10 + *param_3 + 1 <= param_2)) {
      uVar1 = (ulong)(local_10 + 1);
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  return uVar1;
}



undefined8 _libssh2_pem_decode_sequence(char **param_1,uint *param_2)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  int local_18;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_2 == 0) {
    uVar1 = 0xffffffff;
  }
  else {
    if (**param_1 == '0') {
      *param_1 = *param_1 + 1;
      *param_2 = *param_2 - 1;
      local_14 = FUN_0012ee04(*param_1,(ulong)*param_2,&local_18);
      if ((local_14 < 0) || (local_14 + local_18 != *param_2)) {
        uVar1 = 0xffffffff;
      }
      else {
        *param_1 = *param_1 + local_14;
        *param_2 = *param_2 - local_14;
        uVar1 = 0;
      }
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



undefined8 _libssh2_pem_decode_integer(char **param_1,uint *param_2,char **param_3,uint *param_4)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  uint local_18;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_2 == 0) {
    uVar1 = 0xffffffff;
  }
  else {
    if (**param_1 == '\x02') {
      *param_1 = *param_1 + 1;
      *param_2 = *param_2 - 1;
      local_14 = FUN_0012ee04(*param_1,(ulong)*param_2,&local_18);
      if ((local_14 < 0) || (*param_2 < local_14 + local_18)) {
        uVar1 = 0xffffffff;
      }
      else {
        *param_1 = *param_1 + local_14;
        *param_2 = *param_2 - local_14;
        *param_3 = *param_1;
        *param_4 = local_18;
        *param_1 = *param_1 + local_18;
        *param_2 = *param_2 - local_18;
        uVar1 = 0;
      }
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



void FUN_0012f0f6(long param_1,undefined8 param_2,int param_3)

{
  int local_2c;
  char *local_10;
  
  local_2c = param_3;
  if (((param_3 == 6) && (param_1 != 0)) && (*(int *)(param_1 + 8) == 1)) {
    local_2c = 7;
  }
  if ((local_2c < 0) || (8 < local_2c)) {
    local_10 = "unknown";
  }
  else {
    local_10 = (&PTR_s_success_0034f868)[(long)local_2c * 3];
  }
  _libssh2_error(param_2,0xffffffdc,local_10);
  return;
}



undefined8 FUN_0012f17f(long *param_1,long *param_2,long *param_3)

{
  long lVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  long lVar6;
  long in_FS_OFFSET;
  undefined local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = *param_1;
  lVar2 = *(long *)(lVar1 + 0x60);
  *param_2 = 0;
  *param_3 = 0;
  if (*(int *)((long)param_1 + 0xc) == 0) {
    iVar3 = _libssh2_channel_read(lVar1,0,local_14,4);
    if (iVar3 == -0x25) {
      uVar5 = 0xffffffdb;
      goto LAB_0012f368;
    }
    if (iVar3 != 4) {
      uVar5 = _libssh2_error(lVar2,0xffffffdc,"Invalid response from publickey subsystem");
      goto LAB_0012f368;
    }
    uVar4 = _libssh2_ntohu32(local_14);
    param_1[3] = (ulong)uVar4;
    lVar6 = ((void*(*)())(lVar2 + 8))(param_1[3],lVar2,param_1[3],lVar2);
    param_1[2] = lVar6;
    if (param_1[2] == 0) {
      uVar5 = _libssh2_error(lVar2,0xfffffffa,"Unable to allocate publickey response buffer");
      goto LAB_0012f368;
    }
    *(undefined4 *)((long)param_1 + 0xc) = 3;
  }
  if (*(int *)((long)param_1 + 0xc) == 3) {
    iVar3 = _libssh2_channel_read(lVar1,0,param_1[2],param_1[3]);
    if (iVar3 == -0x25) {
      uVar5 = 0xffffffdb;
      goto LAB_0012f368;
    }
    if (iVar3 != (int)param_1[3]) {
      ((void*(*)())(lVar2 + 0x18))(param_1[2],lVar2,param_1[2],lVar2);
      param_1[2] = 0;
      *(undefined4 *)((long)param_1 + 0xc) = 0;
      uVar5 = _libssh2_error(lVar2,0xffffffe2,
                             "Timeout waiting for publickey subsystem response packet");
      goto LAB_0012f368;
    }
    *param_2 = param_1[2];
    *param_3 = param_1[3];
  }
  *(undefined4 *)((long)param_1 + 0xc) = 0;
  uVar5 = 0;
LAB_0012f368:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong FUN_0012f37e(char **param_1,ulong param_2)

{
  char *__s2;
  uint uVar1;
  int iVar2;
  ulong __n;
  uint *local_20;
  
  __s2 = *param_1;
  local_20 = &DAT_0034f800;
  if (3 < param_2) {
    uVar1 = _libssh2_ntohu32(__s2);
    __n = (ulong)uVar1;
    __s2 = __s2 + 4;
    if (__n <= param_2 - 4) {
      while (*(long *)(local_20 + 2) != 0) {
        if ((__n == (long)(int)local_20[4]) &&
           (iVar2 = strncmp(*(char **)(local_20 + 2),__s2,__n), iVar2 == 0)) {
          *param_1 = __s2 + __n;
          return (ulong)*local_20;
        }
        local_20 = local_20 + 6;
      }
    }
  }
  return 0xffffffff;
}



undefined8 FUN_0012f443(long *param_1)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  ulong local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = *(long *)(*param_1 + 0x60);
  do {
    iVar1 = FUN_0012f17f(param_1,&local_38,&local_28);
    if (iVar1 == -0x25) {
      uVar3 = 0xffffffdb;
LAB_0012f5ec:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return uVar3;
    }
    if (iVar1 != 0) {
      uVar3 = _libssh2_error(local_20,0xffffffe2,
                             "Timeout waiting for response from publickey subsystem");
      goto LAB_0012f5ec;
    }
    if (local_28 < 4) {
      uVar3 = _libssh2_error(local_20,0xffffffda,"Publickey response too small");
      goto LAB_0012f5ec;
    }
    local_30 = local_38;
    iVar1 = FUN_0012f37e(&local_30,local_28);
    if (iVar1 == 0) {
      local_18 = 0;
      if (local_28 < 8) {
        uVar3 = _libssh2_error(local_20,0xffffffda,"Publickey response too small");
      }
      else {
        uVar2 = _libssh2_ntohu32(local_30);
        local_18 = (ulong)uVar2;
        ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
        if (local_18 == 0) {
          uVar3 = 0;
        }
        else {
          FUN_0012f0f6(param_1,local_20,local_18 & 0xffffffff);
          uVar3 = 0xffffffff;
        }
      }
      goto LAB_0012f5ec;
    }
    ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
    if (iVar1 < 0) {
      uVar3 = _libssh2_error(local_20,0xffffffdc,"Invalid publickey subsystem response");
      goto LAB_0012f5ec;
    }
    _libssh2_error(local_20,0xffffffdc,"Unexpected publickey subsystem response");
    local_38 = 0;
  } while( 1 );
}



undefined8 FUN_0012f602(long param_1)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  ulong local_48;
  void *local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd268) == 0) {
    *(undefined8 *)(param_1 + 0xd280) = 0;
    *(undefined8 *)(param_1 + 0xd270) = 0;
    *(undefined8 *)(param_1 + 0xd278) = 0;
    *(undefined4 *)(param_1 + 0xd268) = 1;
  }
  if (*(int *)(param_1 + 0xd268) == 1) {
    uVar5 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd278) = uVar5;
    if (*(long *)(param_1 + 0xd278) != 0) {
      *(undefined4 *)(param_1 + 0xd268) = 3;
      goto LAB_0012f711;
    }
    iVar2 = libssh2_session_last_errno(param_1);
    if (iVar2 == -0x25) {
      uVar5 = 0;
      goto LAB_0012fe71;
    }
    _libssh2_error(param_1,0xffffffeb,"Unable to startup channel");
  }
  else {
LAB_0012f711:
    if (*(int *)(param_1 + 0xd268) == 3) {
      iVar2 = _libssh2_channel_process_startup
                        (*(undefined8 *)(param_1 + 0xd278),"subsystem",9,"publickey",9);
      if (iVar2 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting publickey subsystem");
        uVar5 = 0;
        goto LAB_0012fe71;
      }
      if (iVar2 != 0) {
        _libssh2_error(param_1,0xffffffeb,"Unable to request publickey subsystem");
        goto LAB_0012fd86;
      }
      *(undefined4 *)(param_1 + 0xd268) = 4;
    }
    if (*(int *)(param_1 + 0xd268) == 4) {
      iVar2 = _libssh2_channel_extended_data(*(undefined8 *)(param_1 + 0xd278),1);
      if (iVar2 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting publickey subsystem");
        uVar5 = 0;
        goto LAB_0012fe71;
      }
      uVar5 = _libssh2_calloc(param_1,0x80);
      *(undefined8 *)(param_1 + 0xd270) = uVar5;
      if (*(long *)(param_1 + 0xd270) == 0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate a new publickey structure");
        goto LAB_0012fd86;
      }
      **(undefined8 **)(param_1 + 0xd270) = *(undefined8 *)(param_1 + 0xd278);
      *(undefined4 *)(*(long *)(param_1 + 0xd270) + 8) = 0;
      local_40 = (void *)(param_1 + 0xd290);
      _libssh2_htonu32(local_40,0xf);
      local_40 = (void *)((long)local_40 + 4);
      _libssh2_htonu32(local_40,7);
      local_40 = (void *)((long)local_40 + 4);
      memcpy(local_40,"version",7);
      local_40 = (void *)((long)local_40 + 7);
      _libssh2_htonu32(local_40,2);
      *(undefined8 *)(param_1 + 0xd2a8) = 0;
      *(undefined4 *)(param_1 + 0xd268) = 5;
    }
    if (*(int *)(param_1 + 0xd268) == 5) {
      uVar3 = _libssh2_channel_write
                        (*(undefined8 *)(param_1 + 0xd278),0,param_1 + 0xd290,
                         0x13 - *(long *)(param_1 + 0xd2a8));
      if (uVar3 == 0xffffffdb) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending publickey version packet");
        uVar5 = 0;
        goto LAB_0012fe71;
      }
      if ((int)uVar3 < 0) {
        _libssh2_error(param_1,(ulong)uVar3,"Unable to send publickey version packet",(ulong)uVar3);
        goto LAB_0012fd86;
      }
      *(long *)(param_1 + 0xd2a8) = *(long *)(param_1 + 0xd2a8) + (long)(int)uVar3;
      if (*(ulong *)(param_1 + 0xd2a8) < 0x13) {
        _libssh2_error(param_1,0xffffffdb,"Need to be called again to complete this");
        uVar5 = 0;
        goto LAB_0012fe71;
      }
      *(undefined4 *)(param_1 + 0xd268) = 6;
    }
    if (*(int *)(param_1 + 0xd268) == 6) {
      while( 1 ) {
        iVar2 = FUN_0012f17f(*(undefined8 *)(param_1 + 0xd270),param_1 + 0xd280,param_1 + 0xd2880);
        if (iVar2 == -0x25) break;
        if (iVar2 != 0) {
          _libssh2_error(param_1,0xffffffe2,"Timeout waiting for response from publickey subsystem")
          ;
          goto LAB_0012fd86;
        }
        local_48 = *(ulong *)(param_1 + 0xd280);
        iVar2 = FUN_0012f37e(&local_48,*(undefined8 *)(param_1 + 0xd288));

        if (iVar2 < 0) {
          _libssh2_error(param_1,0xffffffdc,"Invalid publickey subsystem response code");
          goto LAB_0012fd86;
        }
        if (*(ulong *)(param_1 + 0xd288) < 4) {
          _libssh2_error(param_1,0xffffffda,"Public key init data too small");
          goto LAB_0012fd86;
        }
        if (iVar2 == 0) {
          if (*(ulong *)(param_1 + 0xd288) < 8) {
            _libssh2_error(param_1,0xffffffda,"Public key init data too small");
          }
          else {
            uVar3 = _libssh2_ntohu32(local_48);
            local_38 = (ulong)uVar3;
            local_48 = local_48 + 4;
            uVar3 = _libssh2_ntohu32(local_48);
            local_30 = (ulong)uVar3;
            local_48 = local_48 + 4;
            if ((ulong)(*(long *)(param_1 + 0xd288) + *(long *)(param_1 + 0xd280)) <
                local_48 + local_30 + 4) {
              _libssh2_error(param_1,0xffffffda,"Public key init data too small");
            }
            else {
              local_48 = local_30 + local_48;
              uVar3 = _libssh2_ntohu32(local_48);
              local_28 = (ulong)uVar3;
              local_48 = local_48 + 4;
              if ((ulong)(*(long *)(param_1 + 0xd288) + *(long *)(param_1 + 0xd280)) <
                  local_48 + local_28) {
                _libssh2_error(param_1,0xffffffda,"Public key init data too small");
              }
              else {
                local_48 = local_28 + local_48;
                if ((ulong)(*(long *)(param_1 + 0xd280) + *(long *)(param_1 + 0xd288)) < local_48) {
                  _libssh2_error(param_1,0xffffffdc,"Malformed publickey subsystem packet");
                }
                else {
                  FUN_0012f0f6(0,param_1,local_38 & 0xffffffff);
                }
              }
            }
          }
          goto LAB_0012fd86;
        }
        if (iVar2 == 1) {
          lVar1 = *(long *)(param_1 + 0xd270);
          uVar4 = _libssh2_ntohu32(local_48);
          *(undefined4 *)(lVar1 + 8) = uVar4;
          if (2 < *(uint *)(*(long *)(param_1 + 0xd270) + 8)) {
            *(undefined4 *)(*(long *)(param_1 + 0xd270) + 8) = 2;
          }
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xd280),param_1,*(undefined8 *)(param_1 + 0xd280),
                     param_1);
          *(undefined8 *)(param_1 + 0xd280) = 0;
          *(undefined4 *)(param_1 + 0xd268) = 0;
          uVar5 = *(undefined8 *)(param_1 + 0xd270);
          goto LAB_0012fe71;
        }
        _libssh2_error(param_1,0xffffffdc,"Unexpected publickey subsystem response, ignoring");
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd280),param_1,*(undefined8 *)(param_1 + 0xd280),
                   param_1);
        *(undefined8 *)(param_1 + 0xd280) = 0;
      }
      _libssh2_error(param_1,0xffffffdb,"Would block waiting for response from publickey subsystem")
      ;
      uVar5 = 0;
      goto LAB_0012fe71;
    }
  }
LAB_0012fd86:
  *(undefined4 *)(param_1 + 0xd268) = 7;
  if (*(long *)(param_1 + 0xd278) != 0) {
    iVar2 = _libssh2_channel_close(*(undefined8 *)(param_1 + 0xd278));
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block closing channel");
      uVar5 = 0;
      goto LAB_0012fe71;
    }
  }
  if (*(long *)(param_1 + 0xd270) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd270),param_1,*(undefined8 *)(param_1 + 0xd270),param_1);
    *(undefined8 *)(param_1 + 0xd270) = 0;
  }
  if (*(long *)(param_1 + 0xd280) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd280),param_1,*(undefined8 *)(param_1 + 0xd280),param_1);
    *(undefined8 *)(param_1 + 0xd280) = 0;
  }
  *(undefined4 *)(param_1 + 0xd268) = 0;
  uVar5 = 0;
LAB_0012fe71:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



long libssh2_publickey_init(long param_1)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = FUN_0012f602(param_1);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



ulong libssh2_publickey_add_ex
                (long *param_1,void *param_2,ulong param_3,void *param_4,ulong param_5,char param_6,
                ulong param_7,long param_8)

{
  char cVar1;
  long lVar2;
  long lVar3;
  int iVar4;
  long lVar5;
  undefined8 uVar6;
  ulong uVar7;
  uint uVar8;
  ulong local_38;
  long local_30;
  void *local_28;
  ulong local_20;
  
  local_28 = (void *)0x0;
  local_20 = 0;
  if (param_1 == (long *)0x0) {
    return 0xffffffd9;
  }
  lVar2 = *param_1;
  lVar3 = *(long *)(lVar2 + 0x60);
  if (*(int *)(param_1 + 4) == 0) {
    param_1[5] = 0;
    if (*(int *)(param_1 + 1) == 1) {
      local_38 = 0;
      while (local_38 < param_7) {
        if ((*(long *)(param_8 + local_38 * 0x28 + 8) == 7) &&
           (iVar4 = strncmp(*(char **)(param_8 + local_38 * 0x28),"comment",7), iVar4 == 0)) {
          local_28 = *(void **)(param_8 + local_38 * 0x28 + 0x10);
          local_20 = *(ulong *)(param_8 + local_38 * 0x28 + 0x18);
          break;
        }
        local_38 = local_38 + 1;
      }
      local_30 = param_5 + param_3 + local_20 + 0x17;
    }
    else {
      local_30 = param_5 + param_3 + 0x18;
      local_38 = 0;
      while (local_38 < param_7) {
        local_30 = local_30 +
                   *(long *)(param_8 + local_38 * 0x28 + 8) +
                   *(long *)(param_8 + local_38 * 0x28 + 0x18) + 9;
        local_38 = local_38 + 1;
      }
    }
    lVar5 = ((void*(*)())(lVar3 + 8))(local_30,lVar3,local_30,lVar3);
    param_1[5] = lVar5;
    if (param_1[5] == 0) {
      uVar6 = _libssh2_error(lVar3,0xfffffffa,
                             "Unable to allocate memory for publickey \"add\" packet");
      return uVar6;
    }
    param_1[6] = param_1[5];
    uVar8 = (int)local_30 - 4;
    _libssh2_htonu32(param_1[6],(ulong)uVar8);
    param_1[6] = param_1[6] + 4;
    _libssh2_htonu32(param_1[6],3);
    param_1[6] = param_1[6] + 4;
    memcpy((void *)param_1[6],&DAT_0014860d,3);
    param_1[6] = param_1[6] + 3;
    if (*(int *)(param_1 + 1) == 1) {
      _libssh2_htonu32(param_1[6],local_20 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      if (local_28 != (void *)0x0) {
        memcpy((void *)param_1[6],local_28,local_20);
        param_1[6] = param_1[6] + local_20;
      }
      _libssh2_htonu32(param_1[6],param_3 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_2,param_3);
      param_1[6] = param_1[6] + param_3;
      _libssh2_htonu32(param_1[6],param_5 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_4,param_5);
      param_1[6] = param_1[6] + param_5;
    }
    else {
      _libssh2_htonu32(param_1[6],param_3 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_2,param_3);
      param_1[6] = param_1[6] + param_3;
      _libssh2_htonu32(param_1[6],param_5 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_4,param_5);
      param_1[6] = param_1[6] + param_5;
      lVar5 = param_1[6];
      param_1[6] = lVar5 + 1;
      *(bool *)lVar5 = param_6 != '\0';
      _libssh2_htonu32(param_1[6],param_7 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      local_38 = 0;
      while (local_38 < param_7) {
        uVar7 = *(ulong *)(param_8 + local_38 * 0x28 + 8) & 0xffffffff;
        _libssh2_htonu32(param_1[6],uVar7);
        param_1[6] = param_1[6] + 4;
        memcpy((void *)param_1[6],*(void **)(param_8 + local_38 * 0x28),
               *(size_t *)(param_8 + local_38 * 0x28 + 8));
        param_1[6] = param_1[6] + *(long *)(param_8 + local_38 * 0x28 + 8);
        uVar7 = *(ulong *)(param_8 + local_38 * 0x28 + 0x18) & 0xffffffff;
        _libssh2_htonu32(param_1[6],uVar7);
        param_1[6] = param_1[6] + 4;
        memcpy((void *)param_1[6],*(void **)(param_8 + local_38 * 0x28 + 0x10),
               *(size_t *)(param_8 + local_38 * 0x28 + 0x18));
        param_1[6] = param_1[6] + *(long *)(param_8 + local_38 * 0x28 + 0x18);
        cVar1 = *(char *)(param_8 + local_38 * 0x28 + 0x20);
        lVar5 = param_1[6];
        param_1[6] = lVar5 + 1;
        *(bool *)lVar5 = cVar1 != '\0';
        local_38 = local_38 + 1;
      }
    }
    *(undefined4 *)(param_1 + 4) = 2;
  }
  if (*(int *)(param_1 + 4) == 2) {
    iVar4 = _libssh2_channel_write(lVar2,0,param_1[5],param_1[6] - param_1[5]);
    if (iVar4 == -0x25) {
      return 0xffffffdb;
    }
    if (param_1[6] - param_1[5] != (long)iVar4) {
      ((void*(*)())(lVar3 + 0x18))(param_1[5],lVar3,param_1[5],lVar3);
      param_1[5] = 0;
      uVar6 = _libssh2_error(lVar3,0xfffffff9,"Unable to send publickey add packet");
      return uVar6;
    }
    ((void*(*)())(lVar3 + 0x18))(param_1[5],lVar3,param_1[5],lVar3);
    param_1[5] = 0;
    *(undefined4 *)(param_1 + 4) = 3;
  }
  uVar8 = FUN_0012f443(param_1);
  if (uVar8 == 0xffffffdb) {
    uVar7 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 4) = 0;
    uVar7 = (ulong)uVar8;
  }
  return uVar7;
}



ulong libssh2_publickey_remove_ex
                (long *param_1,void *param_2,ulong param_3,void *param_4,ulong param_5)

{
  long lVar1;
  long lVar2;
  int iVar3;
  long lVar4;
  long lVar5;
  undefined8 uVar6;
  ulong uVar7;
  uint uVar8;
  
  lVar4 = param_5 + param_3 + 0x16;
  if (param_1 == (long *)0x0) {
    return 0xffffffd9;
  }
  lVar1 = *param_1;
  lVar2 = *(long *)(lVar1 + 0x60);
  if (*(int *)(param_1 + 7) == 0) {
    param_1[8] = 0;
    lVar5 = ((void*(*)())(lVar2 + 8))(lVar4,lVar2,lVar4,lVar2);
    param_1[8] = lVar5;
    if (param_1[8] == 0) {
      uVar6 = _libssh2_error(lVar2,0xfffffffa,
                             "Unable to allocate memory for publickey \"remove\" packet");
      return uVar6;
    }
    param_1[9] = param_1[8];
    uVar8 = (int)lVar4 - 4;
    _libssh2_htonu32(param_1[9],(ulong)uVar8);
    param_1[9] = param_1[9] + 4;
    _libssh2_htonu32(param_1[9],6);
    param_1[9] = param_1[9] + 4;
    memcpy((void *)param_1[9],"remove",6);
    param_1[9] = param_1[9] + 6;
    _libssh2_htonu32(param_1[9],param_3 & 0xffffffff);
    param_1[9] = param_1[9] + 4;
    memcpy((void *)param_1[9],param_2,param_3);
    param_1[9] = param_1[9] + param_3;
    _libssh2_htonu32(param_1[9],param_5 & 0xffffffff);
    param_1[9] = param_1[9] + 4;
    memcpy((void *)param_1[9],param_4,param_5);
    param_1[9] = param_1[9] + param_5;
    *(undefined4 *)(param_1 + 7) = 2;
  }
  if (*(int *)(param_1 + 7) == 2) {
    iVar3 = _libssh2_channel_write(lVar1,0,param_1[8],param_1[9] - param_1[8]);
    if (iVar3 == -0x25) {
      return 0xffffffdb;
    }
    if (param_1[9] - param_1[8] != (long)iVar3) {
      ((void*(*)())(lVar2 + 0x18))(param_1[8],lVar2,param_1[8],lVar2);
      param_1[8] = 0;
      *(undefined4 *)(param_1 + 7) = 0;
      uVar6 = _libssh2_error(lVar2,0xfffffff9,"Unable to send publickey remove packet");
      return uVar6;
    }
    ((void*(*)())(lVar2 + 0x18))(param_1[8],lVar2,param_1[8],lVar2);
    param_1[8] = 0;
    *(undefined4 *)(param_1 + 7) = 3;
  }
  uVar8 = FUN_0012f443(param_1);
  if (uVar8 == 0xffffffdb) {
    uVar7 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 7) = 0;
    uVar7 = (ulong)uVar8;
  }
  return uVar7;
}



undefined8 libssh2_publickey_list_fetch(long *param_1,ulong *param_2,long *param_3)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined8 uVar5;
  long lVar6;
  long local_78;
  ulong local_70;
  ulong local_68;
  ulong local_60;
  
  local_78 = 0;
  local_70 = 0;
  local_68 = 0;
  if (param_1 == (long *)0x0) {
    return 0xffffffd9;
  }
  lVar6 = *param_1;
  lVar1 = *(long *)(lVar6 + 0x60);
  if (*(int *)(param_1 + 10) == 0) {
    param_1[0xe] = 0;
    *(long **)(param_1 + 0xb) = param_1 + 0xc;
    _libssh2_htonu32(param_1[0xb],8);
    param_1[0xb] = param_1[0xb] + 4;
    _libssh2_htonu32(param_1[0xb],4);
    param_1[0xb] = param_1[0xb] + 4;
    memcpy((void *)param_1[0xb],&DAT_001486a7,4);
    param_1[0xb] = param_1[0xb] + 4;
    *(undefined4 *)(param_1 + 10) = 2;
  }
  if (*(int *)(param_1 + 10) == 2) {
    iVar2 = _libssh2_channel_write(lVar6,0,param_1 + 0xc,param_1[0xb] - (long)(param_1 + 0xc));
    if (iVar2 == -0x25) {
      return 0xffffffdb;
    }
    if (param_1[0xb] - (long)(param_1 + 0xc) != (long)iVar2) {
      *(undefined4 *)(param_1 + 10) = 0;
      uVar5 = _libssh2_error(lVar1,0xfffffff9,"Unable to send publickey list packet");
      return uVar5;
    }
    *(undefined4 *)(param_1 + 10) = 3;
  }
  while( 1 ) {
    iVar2 = FUN_0012f17f(param_1,param_1 + 0xe,param_1 + 0xf);
    if (iVar2 == -0x25) {
      return 0xffffffdb;
    }
    if (iVar2 != 0) break;
    param_1[0xb] = param_1[0xe];
    iVar2 = FUN_0012f37e(param_1 + 0xb,param_1[0xf]);
    if (iVar2 < 0) {
      _libssh2_error(lVar1,0xffffffdc,"Invalid publickey subsystem response code");
      goto LAB_00131f34;
    }
    if (iVar2 == 0) {
      if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 8U) {
        _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
      }
      else {
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        param_1[0xb] = param_1[0xb] + 4;
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        param_1[0xb] = param_1[0xb] + 4;
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + (ulong)uVar3 + 4) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
        }
        else {
          param_1[0xb] = param_1[0xb] + (ulong)uVar3;
          uVar3 = _libssh2_ntohu32(param_1[0xb]);
          param_1[0xb] = param_1[0xb] + 4;
          if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + (ulong)uVar3) {
            _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          }
          else {
            param_1[0xb] = param_1[0xb] + (ulong)uVar3;
            if ((ulong)(param_1[0xf] + param_1[0xe]) < (ulong)param_1[0xb]) {
              _libssh2_error(lVar1,0xffffffdc,"Malformed publickey subsystem packet");
            }
            else {
              if (uVar4 == 0) {
                ((void*(*)())(lVar1 + 0x18))(param_1[0xe],lVar1,param_1[0xe],lVar1);
                param_1[0xe] = 0;
                *param_3 = local_78;
                *param_2 = local_70;
                *(undefined4 *)(param_1 + 10) = 0;
                return 0;
              }
              FUN_0012f0f6(param_1,lVar1,(ulong)uVar4);
            }
          }
        }
      }
      goto LAB_00131f34;
    }
    if (iVar2 == 2) {
      lVar6 = local_78;
      if (local_68 <= local_70) {
        if (local_78 == 0) {
		lVar6 = 0;

        }




        local_68 = local_68 + 8;
        if (lVar6 == 0) {
          _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for publickey list");
          goto LAB_00131f34;
        }
      }
      local_78 = lVar6;
      if (*(int *)(param_1 + 1) == 1) {
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        param_1[0xb] = param_1[0xb] + 4;
        if (uVar4 == 0) {
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x28) = 0;
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x30) = 0;
        }
        else {
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x28) = 1;

          *(undefined8 *)(local_70 * 0x38 + local_78 + 0x30) = uVar5;
          if (*(long *)(local_78 + local_70 * 0x38 + 0x30) == 0) {
            _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for publickey attributes");
            goto LAB_00131f34;
          }
          **(undefined8 **)(local_78 + local_70 * 0x38 + 0x30) = 0x1485ce;
          *(undefined8 *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 8) = 7;
          *(long *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x10) = param_1[0xb];
          *(ulong *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x18) = (ulong)uVar4;
          *(undefined *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x20) = 0;
          param_1[0xb] = param_1[0xb] + (ulong)uVar4;
        }
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x10) = (ulong)uVar4;
        param_1[0xb] = param_1[0xb] + 4;
        if ((ulong)(param_1[0xf] + param_1[0xe]) <
            (ulong)(param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x10))) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        *(long *)(local_70 * 0x38 + local_78 + 8) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x10);
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x20) = (ulong)uVar4;
        param_1[0xb] = param_1[0xb] + 4;
        if ((ulong)(param_1[0xf] + param_1[0xe]) <
            (ulong)(param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x20))) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        *(long *)(local_70 * 0x38 + local_78 + 0x18) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x20);
      }
      else {
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x10) = (ulong)uVar4;
        param_1[0xb] = param_1[0xb] + 4;
        if ((ulong)(param_1[0xf] + param_1[0xe]) <
            (ulong)(param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x10))) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        *(long *)(local_70 * 0x38 + local_78 + 8) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x10);
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x20) = (ulong)uVar4;
        param_1[0xb] = param_1[0xb] + 4;
        if ((ulong)(param_1[0xf] + param_1[0xe]) <
            (ulong)(param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x20))) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        *(long *)(local_70 * 0x38 + local_78 + 0x18) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x20);
        if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
          _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
          goto LAB_00131f34;
        }
        uVar4 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x28) = (ulong)uVar4;
        param_1[0xb] = param_1[0xb] + 4;
        if (*(long *)(local_78 + local_70 * 0x38 + 0x28) == 0) {
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x30) = 0;
        }
        else {



          *(undefined8 *)(local_70 * 0x38 + local_78 + 0x30) = uVar5;
          if (*(long *)(local_78 + local_70 * 0x38 + 0x30) == 0) {
            _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for publickey attributes");
            goto LAB_00131f34;
          }
          local_60 = 0;
          while (local_60 < *(ulong *)(local_78 + local_70 * 0x38 + 0x28)) {
            if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
              _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
              goto LAB_00131f34;
            }
            uVar4 = _libssh2_ntohu32(param_1[0xb]);
            *(ulong *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 8) =
                 (ulong)uVar4;
            param_1[0xb] = param_1[0xb] + 4;
            if ((ulong)(param_1[0xf] + param_1[0xe]) <
                (ulong)(param_1[0xb] +
                       *(long *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 8)
                       )) {
              _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
              goto LAB_00131f34;
            }
            *(long *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + local_60 * 0x28) = param_1[0xb]
            ;
            param_1[0xb] = param_1[0xb] +
                           *(long *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30)
                                    + 8);
            if ((ulong)(param_1[0xf] + param_1[0xe]) < param_1[0xb] + 4U) {
              _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
              goto LAB_00131f34;
            }
            uVar4 = _libssh2_ntohu32(param_1[0xb]);
            *(ulong *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x18) =
                 (ulong)uVar4;
            param_1[0xb] = param_1[0xb] + 4;
            if ((ulong)(param_1[0xf] + param_1[0xe]) <
                (ulong)(param_1[0xb] +
                       *(long *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) +
                                0x18))) {
              _libssh2_error(lVar1,0xffffffda,"ListFetch data too short");
              goto LAB_00131f34;
            }
            *(long *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + local_60 * 0x28 + 0x10) =
                 param_1[0xb];
            param_1[0xb] = param_1[0xb] +
                           *(long *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30)
                                    + 0x18);
            *(undefined *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x20) =
                 0;
            local_60 = local_60 + 1;
          }
        }
      }
      *(long *)(local_70 * 0x38 + local_78) = param_1[0xe];
      local_70 = local_70 + 1;
      *(undefined8 *)(local_78 + local_70 * 0x38) = 0;
      param_1[0xe] = 0;
    }
    else {
      _libssh2_error(lVar1,0xffffffdc,"Unexpected publickey subsystem response");
      ((void*(*)())(lVar1 + 0x18))(param_1[0xe],lVar1,param_1[0xe],lVar1);
      param_1[0xe] = 0;
    }
  }
  _libssh2_error(lVar1,0xffffffe2,"Timeout waiting for response from publickey subsystem");
LAB_00131f34:
  if (param_1[0xe] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0xe],lVar1,param_1[0xe],lVar1);
    param_1[0xe] = 0;
  }
  if (local_78 != 0) {
    libssh2_publickey_list_free(param_1,local_78);
  }
  *(undefined4 *)(param_1 + 10) = 0;
  return 0xffffffff;
}



void libssh2_publickey_list_free(long *param_1,long *param_2)

{
  long lVar1;
  long *local_18;
  
  if ((param_1 != (long *)0x0) && (param_2 != (long *)0x0)) {
    lVar1 = *(long *)(*param_1 + 0x60);
    local_18 = param_2;
    while (*local_18 != 0) {
      if (local_18[6] != 0) {
        ((void*(*)())(lVar1 + 0x18))(local_18[6],lVar1,local_18[6],lVar1);
      }
      ((void*(*)())(lVar1 + 0x18))(*local_18,lVar1,*local_18,lVar1);
      local_18 = local_18 + 7;
    }
    ((void*(*)())(lVar1 + 0x18))(param_2,lVar1,param_2,lVar1);
  }
  return;
}



undefined8 libssh2_publickey_shutdown(long *param_1)

{
  long lVar1;
  int iVar2;
  undefined8 uVar3;
  
  if (param_1 == (long *)0x0) {
    uVar3 = 0xffffffd9;
  }
  else {
    lVar1 = *(long *)(*param_1 + 0x60);
    if (param_1[2] != 0) {
      ((void*(*)())(lVar1 + 0x18))(param_1[2],lVar1,param_1[2],lVar1);
      param_1[2] = 0;
    }
    if (param_1[5] != 0) {
      ((void*(*)())(lVar1 + 0x18))(param_1[5],lVar1,param_1[5],lVar1);
      param_1[5] = 0;
    }
    if (param_1[8] != 0) {
      ((void*(*)())(lVar1 + 0x18))(param_1[8],lVar1,param_1[8],lVar1);
      param_1[8] = 0;
    }
    if (param_1[0xe] != 0) {
      ((void*(*)())(lVar1 + 0x18))(param_1[0xe],lVar1,param_1[0xe],lVar1);
      param_1[0xe] = 0;
    }
    iVar2 = _libssh2_channel_free(*param_1);
    if (iVar2 == -0x25) {
      uVar3 = 0xffffffdb;
    }
    else {
      ((void*(*)())(lVar1 + 0x18))(param_1,lVar1,param_1,lVar1);
      uVar3 = 0;
    }
  }
  return uVar3;
}



char * FUN_00132199(char *param_1,char *param_2,uint param_3)

{
  char *pcVar1;
  char *pcVar2;
  int local_24;
  char *local_20;
  char *local_18;
  
  local_24 = 0;
  pcVar2 = param_2 + param_3;
  local_20 = param_1;
  local_18 = param_2;
  while( 1 ) {
    if ((*local_20 == '\0') || (pcVar2 + -1 <= local_18)) {
      if (local_24 == 1) {
        if (pcVar2 <= local_18 + 1) {
          return (char *)0;
        }
        *local_18 = '\'';
        local_18 = local_18 + 1;
      }
      else {
        if ((local_24 != 0) && (local_24 == 2)) {
          if (pcVar2 <= local_18 + 1) {
            return (char *)0;
          }
          *local_18 = '\"';
          local_18 = local_18 + 1;
        }
      }
      if (local_18 + 1 < pcVar2) {
        *local_18 = '\0';
        local_18 = local_18 + -(long)param_2;
      }
      else {
        local_18 = (char *)0x0;
      }
      return local_18;
    }
    if (*local_20 == '!') {
      if (local_24 == 1) {
        if (pcVar2 <= local_18 + 2) {
          return (char *)0;
        }
        pcVar1 = local_18 + 1;
        *local_18 = '\'';
        local_18 = local_18 + 2;
        *pcVar1 = '\\';
      }
      else {
        if (local_24 == 0) {
          if (pcVar2 <= local_18 + 1) {
            return (char *)0;
          }
          *local_18 = '\\';
          local_18 = local_18 + 1;
        }
        else {
          if (local_24 == 2) {
            if (pcVar2 <= local_18 + 2) {
              return (char *)0;
            }
            *local_18 = '\"';
            local_18[1] = '\\';
            local_18 = local_18 + 2;
          }
        }
      }
      local_24 = 0;
    }
    else {
      if (*local_20 == '\'') {
        if (local_24 == 1) {
          if (pcVar2 <= local_18 + 2) {
            return (char *)0;
          }
          pcVar1 = local_18 + 1;
          *local_18 = '\'';
          local_18 = local_18 + 2;
          *pcVar1 = '\"';
        }
        else {
          if (local_24 == 0) {
            if (pcVar2 <= local_18 + 1) {
              return (char *)0;
            }
            *local_18 = '\"';
            local_18 = local_18 + 1;
          }
        }
        local_24 = 2;
      }
      else {
        if (local_24 != 1) {
          if (local_24 == 0) {
            if (pcVar2 <= local_18 + 1) {
              return (char *)0;
            }
            *local_18 = '\'';
            local_18 = local_18 + 1;
          }
          else {
            if (local_24 == 2) {
              if (pcVar2 <= local_18 + 2) {
                return (char *)0;
              }
              *local_18 = '\"';
              local_18[1] = '\'';
              local_18 = local_18 + 2;
            }
          }
        }
        local_24 = 1;
      }
    }
    if (pcVar2 <= local_18 + 1) break;
    *local_18 = *local_20;
    local_20 = local_20 + 1;
    local_18 = local_18 + 1;
  }
  return (char *)0;
}



undefined8 FUN_00132487(long param_1,char *param_2,void *param_3)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  size_t sVar5;
  undefined8 uVar6;
  undefined *puVar7;
  char *pcVar8;
  longlong lVar9;
  long lVar10;
  long in_FS_OFFSET;
  char *local_50;
  char *local_48;
  char *local_40;
  long local_38;
  long local_30;
  char *local_28;
  char *local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd3b8) == 0) {
    *(undefined8 *)(param_1 + 0xd4d8) = 0;
    *(undefined8 *)(param_1 + 0xd4e0) = 0;
    *(undefined8 *)(param_1 + 0xd4e8) = 0;
    *(undefined8 *)(param_1 + 0xd4f0) = 0;
    sVar5 = strlen(param_2);
    *(long *)(param_1 + 0xd3c8) = sVar5 * 3 + (ulong)(param_3 != (void *)0x0) + 10;
    uVar6 = ((void*(*)())(param_1 + 8))
                      (*(undefined8 *)(param_1 + 0xd3c8),param_1,*(undefined8 *)(param_1 + 0xd3c8),
                       param_1);
    *(undefined8 *)(param_1 + 0xd3c0) = uVar6;
    if (*(long *)(param_1 + 0xd3c0) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate a command buffer for SCP session");
      uVar6 = 0;
      goto LAB_00133472;
    }
    if (param_3 == (void *)0x0) {
      puVar7 = &DAT_0014878e;
    }
    else {
      puVar7 = &DAT_0014878c;
    }
    snprintf(*(char **)(param_1 + 0xd3c0),*(size_t *)(param_1 + 0xd3c8),"scp -%sf ",puVar7);
    sVar5 = strlen(*(char **)(param_1 + 0xd3c0));
    iVar3 = (int)sVar5;
    lVar10 = *(long *)(param_1 + 0xd3c0) + (long)iVar3;
    iVar2 = FUN_00132199(param_2,lVar10,
                         (ulong)(uint)((int)*(undefined8 *)(param_1 + 0xd3c8) - iVar3));
    *(long *)(param_1 + 0xd3c8) = (long)(iVar3 + iVar2);
    *(undefined4 *)(param_1 + 0xd3b8) = 2;
  }
  if (*(int *)(param_1 + 0xd3b8) == 2) {
    uVar6 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd4f8) = uVar6;
    if (*(long *)(param_1 + 0xd4f8) == 0) {
      iVar3 = libssh2_session_last_errno(param_1);
      if (iVar3 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting up channel");
      }
      else {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd3c0),param_1,*(undefined8 *)(param_1 + 0xd3c0),
                   param_1);
        *(undefined8 *)(param_1 + 0xd3c0) = 0;
        *(undefined4 *)(param_1 + 0xd3b8) = 0;
      }
      uVar6 = 0;
      goto LAB_00133472;
    }
    *(undefined4 *)(param_1 + 0xd3b8) = 3;
  }
  if (*(int *)(param_1 + 0xd3b8) == 3) {
    iVar3 = _libssh2_channel_process_startup
                      (*(undefined8 *)(param_1 + 0xd4f8),&DAT_001487c8,4,
                       *(undefined8 *)(param_1 + 0xd3c0),*(undefined8 *)(param_1 + 0xd3c8));
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting SCP startup");
      uVar6 = 0;
      goto LAB_00133472;
    }
    if (iVar3 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd3c0),param_1,*(undefined8 *)(param_1 + 0xd3c0),param_1
                );
      *(undefined8 *)(param_1 + 0xd3c0) = 0;
      goto LAB_001333ff;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd3c0),param_1,*(undefined8 *)(param_1 + 0xd3c0),param_1);
    *(undefined8 *)(param_1 + 0xd3c0) = 0;
    *(undefined *)(param_1 + 0xd3d0) = 0;
    *(undefined4 *)(param_1 + 0xd3b8) = 4;
  }
  if (*(int *)(param_1 + 0xd3b8) == 4) {
    iVar3 = _libssh2_channel_write(*(undefined8 *)(param_1 + 0xd4f8),0,param_1 + 0xd3d0,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block sending initial wakeup");
      uVar6 = 0;
      goto LAB_00133472;
    }
    if (iVar3 != 1) goto LAB_001333ff;
    *(undefined8 *)(param_1 + 0xd4d0) = 0;
    *(undefined4 *)(param_1 + 0xd3b8) = 5;
  }
  if ((*(int *)(param_1 + 0xd3b8) == 5) || (*(int *)(param_1 + 0xd3b8) == 6)) {
LAB_00132e16:
    do {
      if ((param_3 == (void *)0x0) || (0xff < *(ulong *)(param_1 + 0xd4d0))) goto LAB_00132e37;
      if (*(int *)(param_1 + 0xd3b8) == 5) {
        uVar4 = _libssh2_channel_read
                          (*(undefined8 *)(param_1 + 0xd4f8),0,
                           param_1 + 0xd3d0 + *(long *)(param_1 + 0xd4d0),1);
        if (uVar4 == 0xffffffdb) {
          _libssh2_error(param_1,0xffffffdb,"Would block waiting for SCP response");
          uVar6 = 0;
          goto LAB_00133472;
        }
        if ((int)uVar4 < 0) {
          _libssh2_error(param_1,(ulong)uVar4,"Failed reading SCP response",(ulong)uVar4);
          goto LAB_001333ff;
        }
        if (uVar4 == 0) goto LAB_001333c0;
        *(long *)(param_1 + 0xd4d0) = *(long *)(param_1 + 0xd4d0) + 1;
        if (*(char *)(param_1 + 0xd3d0) != 'T') {
          local_38 = _libssh2_channel_packet_data_len(*(undefined8 *)(param_1 + 0xd4f8),0);
          local_30 = ((void*(*)())(param_1 + 8))(local_38 + 1,param_1,param_1,local_38 + 1);
          if (local_30 == 0) {
            _libssh2_error(param_1,0xfffffffa,"Failed to get memory ");
          }
          else {
            _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd4f8),0,local_30,local_38);
            *(undefined *)(local_38 + local_30) = 0;
            _libssh2_error(param_1,0xffffffe4,"Failed to recv file");
            ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
          }
          goto LAB_001333ff;
        }
        if ((1 < *(ulong *)(param_1 + 0xd4d0)) &&
           ((((*(byte *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) < 0x30 ||
              (0x39 < *(byte *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf))) &&
             (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != ' ')) &&
            ((*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != '\r' &&
             (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != '\n')))))) {
          _libssh2_error(param_1,0xffffffe4,"Invalid data in SCP response");
          goto LAB_001333ff;
        }
        if ((*(ulong *)(param_1 + 0xd4d0) < 9) ||
           (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != '\n')) {
          if (*(long *)(param_1 + 0xd4d0) == 0x100) {
            _libssh2_error(param_1,0xffffffe4,"Unterminated response from SCP server");
            goto LAB_001333ff;
          }
          goto LAB_00132e16;
        }
        while ((*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) == '\r' ||
               (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) == '\n'))) {
          *(long *)(param_1 + 0xd4d0) = *(long *)(param_1 + 0xd4d0) + -1;
        }
        *(undefined *)(param_1 + 0xd3d0 + *(long *)(param_1 + 0xd4d0)) = 0;
        if (*(ulong *)(param_1 + 0xd4d0) < 8) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, too short");
          goto LAB_001333ff;
        }
        local_48 = (char *)(param_1 + 0xd3d1);
        pcVar8 = strchr(local_48,0x20);
        if ((pcVar8 == (char *)0x0) || (pcVar8 == local_48 || (long)(pcVar8 + -(long)local_48) < 0))
        {
          local_40 = pcVar8;
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, malformed mtime");
          goto LAB_001333ff;
        }
        local_40 = pcVar8 + 1;
        *pcVar8 = '\0';
        lVar10 = strtol(local_48,(char **)0x0,10);
        *(long *)(param_1 + 0xd4e8) = lVar10;
        local_48 = strchr(local_40,0x20);
        if ((local_48 == (char *)0x0) ||
           (local_48 == local_40 || (long)(local_48 + -(long)local_40) < 0)) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, malformed mtime.usec"
                        );
          goto LAB_001333ff;
        }
        local_48 = local_48 + 1;
        local_40 = strchr(local_48,0x20);
        if ((local_40 == (char *)0x0) ||
           (local_40 == local_48 || (long)(local_40 + -(long)local_48) < 0)) {
          _libssh2_error(param_1,0xffffffe4,
                         "Invalid response from SCP server, too short or malformed");
          goto LAB_001333ff;
        }
        *local_40 = '\0';
        lVar10 = strtol(local_48,(char **)0x0,10);
        *(long *)(param_1 + 0xd4f0) = lVar10;
        *(undefined *)(param_1 + 0xd3d0) = 0;
        *(undefined4 *)(param_1 + 0xd3b8) = 6;
      }
    } while (*(int *)(param_1 + 0xd3b8) != 6);
    iVar3 = _libssh2_channel_write(*(undefined8 *)(param_1 + 0xd4f8),0,param_1 + 0xd3d0,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block waiting to send SCP ACK");
      uVar6 = 0;
      goto LAB_00133472;
    }
    if (iVar3 != 1) goto LAB_001333ff;
LAB_00132e37:
    *(undefined4 *)(param_1 + 0xd3b8) = 7;
  }
  if (*(int *)(param_1 + 0xd3b8) == 7) {
    *(undefined8 *)(param_1 + 0xd4d0) = 0;
    *(undefined4 *)(param_1 + 0xd3b8) = 8;
  }
  if ((*(int *)(param_1 + 0xd3b8) == 8) || (*(int *)(param_1 + 0xd3b8) == 9)) {
LAB_0013330b:
    do {
      if (0xff < *(ulong *)(param_1 + 0xd4d0)) goto LAB_00133325;
      local_50 = (char *)0x0;
      if (*(int *)(param_1 + 0xd3b8) == 8) {
        uVar4 = _libssh2_channel_read
                          (*(undefined8 *)(param_1 + 0xd4f8),0,
                           param_1 + 0xd3d0 + *(long *)(param_1 + 0xd4d0),1);
        if (uVar4 == 0xffffffdb) {
          _libssh2_error(param_1,0xffffffdb,"Would block waiting for SCP response");
          uVar6 = 0;
          goto LAB_00133472;
        }
        if ((int)uVar4 < 0) {
          _libssh2_error(param_1,(ulong)uVar4,"Failed reading SCP response",(ulong)uVar4);
          goto LAB_001333ff;
        }
        if (uVar4 == 0) goto LAB_001333c0;
        *(long *)(param_1 + 0xd4d0) = *(long *)(param_1 + 0xd4d0) + 1;
        if (*(char *)(param_1 + 0xd3d0) != 'C') {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server");
          goto LAB_001333ff;
        }
        if ((((1 < *(ulong *)(param_1 + 0xd4d0)) &&
             (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != '\r')) &&
            (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != '\n')) &&
           (*(byte *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) < 0x20)) {
          _libssh2_error(param_1,0xffffffe4,"Invalid data in SCP response");
          goto LAB_001333ff;
        }
        if ((*(ulong *)(param_1 + 0xd4d0) < 7) ||
           (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) != '\n')) {
          if (*(long *)(param_1 + 0xd4d0) == 0x100) {
            _libssh2_error(param_1,0xffffffe4,"Unterminated response from SCP server");
            goto LAB_001333ff;
          }
          goto LAB_0013330b;
        }
        while ((*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) == '\r' ||
               (*(char *)(param_1 + *(long *)(param_1 + 0xd4d0) + 0xd3cf) == '\n'))) {
          *(long *)(param_1 + 0xd4d0) = *(long *)(param_1 + 0xd4d0) + -1;
        }
        *(undefined *)(param_1 + 0xd3d0 + *(long *)(param_1 + 0xd4d0)) = 0;
        if (*(ulong *)(param_1 + 0xd4d0) < 6) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, too short");
          goto LAB_001333ff;
        }
        local_28 = (char *)(param_1 + 0xd3d1);
        pcVar8 = strchr(local_28,0x20);
        if ((pcVar8 == (char *)0x0) || (pcVar8 == local_28 || (long)(pcVar8 + -(long)local_28) < 0))
        {
          local_20 = pcVar8;
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, malformed mode");
          goto LAB_001333ff;
        }
        local_20 = pcVar8 + 1;
        *pcVar8 = '\0';
        lVar10 = strtol(local_28,&local_50,8);
        *(long *)(param_1 + 0xd4d8) = lVar10;
        if ((local_50 != (char *)0x0) && (*local_50 != '\0')) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, invalid mode");
          goto LAB_001333ff;
        }
        local_28 = strchr(local_20,0x20);
        if ((local_28 == (char *)0x0) ||
           (local_28 == local_20 || (long)(local_28 + -(long)local_20) < 0)) {
          _libssh2_error(param_1,0xffffffe4,
                         "Invalid response from SCP server, too short or malformed");
          goto LAB_001333ff;
        }
        *local_28 = '\0';
        lVar9 = strtoll(local_20,&local_50,10);
        *(longlong *)(param_1 + 0xd4e0) = lVar9;
        if ((local_50 != (char *)0x0) && (*local_50 != '\0')) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, invalid size");
          goto LAB_001333ff;
        }
        *(undefined *)(param_1 + 0xd3d0) = 0;
        *(undefined4 *)(param_1 + 0xd3b8) = 9;
      }
    } while (*(int *)(param_1 + 0xd3b8) != 9);
    iVar3 = _libssh2_channel_write(*(undefined8 *)(param_1 + 0xd4f8),0,param_1 + 0xd3d0,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block sending SCP ACK");
      uVar6 = 0;
      goto LAB_00133472;
    }
    if (iVar3 != 1) goto LAB_001333ff;
LAB_00133325:
    *(undefined4 *)(param_1 + 0xd3b8) = 10;
  }
  if (param_3 != (void *)0x0) {
    memset(param_3,0,0x90);
    *(undefined8 *)((long)param_3 + 0x58) = *(undefined8 *)(param_1 + 0xd4e8);
    *(undefined8 *)((long)param_3 + 0x48) = *(undefined8 *)(param_1 + 0xd4f0);
    *(undefined8 *)((long)param_3 + 0x30) = *(undefined8 *)(param_1 + 0xd4e0);
    *(uint *)((long)param_3 + 0x18) = (uint)*(undefined8 *)(param_1 + 0xd4d8) & 0xffff;
  }
  *(undefined4 *)(param_1 + 0xd3b8) = 0;
  uVar6 = *(undefined8 *)(param_1 + 0xd4f8);
  goto LAB_00133472;
LAB_001333c0:
  iVar3 = libssh2_channel_eof(*(undefined8 *)(param_1 + 0xd4f8));
  if (iVar3 == 0) {
    uVar6 = *(undefined8 *)(param_1 + 0xd4f8);
    goto LAB_00133472;
  }
  _libssh2_error(param_1,0xffffffe4,"Unexpected channel close");
LAB_001333ff:
  uVar1 = *(undefined4 *)(param_1 + 0x240);
  local_18 = *(undefined8 *)(param_1 + 0x238);
  do {
    iVar3 = libssh2_channel_free(*(undefined8 *)(param_1 + 0xd4f8));
  } while (iVar3 == -0x25);
  *(undefined4 *)(param_1 + 0x240) = uVar1;
  *(undefined8 *)(param_1 + 0x238) = local_18;
  *(undefined8 *)(param_1 + 0xd4f8) = 0;
  *(undefined4 *)(param_1 + 0xd3b8) = 0;
  uVar6 = 0;
LAB_00133472:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar6;
}



long libssh2_scp_recv(long param_1,undefined8 param_2,void *param_3)

{
  int iVar1;
  undefined *puVar2;
  time_t tVar3;
  long lVar4;
  long in_FS_OFFSET;
  undefined local_a8 [24];
  undefined4 local_90;
  undefined8 local_78;
  undefined8 local_60;
  undefined8 local_50;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  memset(local_a8,0,0x90);
  if (param_3 == (void *)0x0) {
    puVar2 = (undefined *)0x0;
  }
  else {
    puVar2 = local_a8;
  }
  tVar3 = time((time_t *)0x0);
  do {
    lVar4 = FUN_00132487(param_1,param_2,puVar2);
    if ((*(int *)(param_1 + 0x94) == 0) || (lVar4 != 0)) break;
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar3);
   }
    while(true);
  if (param_3 != (void *)0x0) {
    memset(param_3,0,0x90);
    *(undefined8 *)((long)param_3 + 0x58) = local_50;
    *(undefined8 *)((long)param_3 + 0x48) = local_60;
    *(undefined8 *)((long)param_3 + 0x30) = local_78;
    *(undefined4 *)((long)param_3 + 0x18) = local_90;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar4;
}



long libssh2_scp_recv2(long param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = FUN_00132487(param_1,param_2,param_3);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



undefined8
FUN_00133680(long param_1,char *param_2,uint param_3,undefined8 param_4,long param_5,long param_6)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  size_t sVar5;
  undefined8 uVar6;
  undefined *puVar7;
  char *pcVar8;
  long lVar9;
  long lVar10;
  char *local_28;
  
  if (*(int *)(param_1 + 0xd500) == 0) {
    sVar5 = strlen(param_2);
    if ((param_5 == 0) && (param_6 == 0)) {
      lVar10 = 0;
    }
    else {
      lVar10 = 1;
    }
    *(long *)(param_1 + 0xd510) = sVar5 * 3 + lVar10 + 10;
    uVar6 = ((void*(*)())(param_1 + 8))
                      (*(undefined8 *)(param_1 + 0xd510),param_1,*(undefined8 *)(param_1 + 0xd510),
                       param_1);
    *(undefined8 *)(param_1 + 0xd508) = uVar6;
    if (*(long *)(param_1 + 0xd508) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate a command buffer for SCP session");
      return 0;
    }
    if ((param_5 == 0) && (param_6 == 0)) {
      puVar7 = &DAT_0014878e;
    }
    else {
      puVar7 = &DAT_0014878c;
    }
    snprintf(*(char **)(param_1 + 0xd508),*(size_t *)(param_1 + 0xd510),"scp -%st ",puVar7);
    sVar5 = strlen(*(char **)(param_1 + 0xd508));
    iVar3 = (int)sVar5;
    lVar10 = *(long *)(param_1 + 0xd508) + (long)iVar3;
    iVar2 = FUN_00132199(param_2,lVar10,
                         (ulong)(uint)((int)*(undefined8 *)(param_1 + 0xd510) - iVar3));
    *(long *)(param_1 + 0xd510) = (long)(iVar3 + iVar2);
    *(undefined4 *)(param_1 + 0xd500) = 2;
  }
  if (*(int *)(param_1 + 0xd500) == 2) {
    uVar6 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd620) = uVar6;
    if (*(long *)(param_1 + 0xd620) == 0) {
      iVar3 = libssh2_session_last_errno(param_1);
      if (iVar3 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting up channel");
      }
      else {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd508),param_1,*(undefined8 *)(param_1 + 0xd508),
                   param_1);
        *(undefined8 *)(param_1 + 0xd508) = 0;
        *(undefined4 *)(param_1 + 0xd500) = 0;
      }
      return 0;
    }
    *(undefined4 *)(param_1 + 0xd500) = 3;
  }
  if (*(int *)(param_1 + 0xd500) == 3) {
    iVar3 = _libssh2_channel_process_startup
                      (*(undefined8 *)(param_1 + 0xd620),&DAT_001487c8,4,
                       *(undefined8 *)(param_1 + 0xd508),*(undefined8 *)(param_1 + 0xd510));
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting SCP startup");
      return 0;
    }
    if (iVar3 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd508),param_1,*(undefined8 *)(param_1 + 0xd508),param_1
                );
      *(undefined8 *)(param_1 + 0xd508) = 0;
      _libssh2_error(param_1,0xffffffe4,"Unknown error while getting error string");
      goto LAB_00133fc4;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd508),param_1,*(undefined8 *)(param_1 + 0xd508),param_1);
    *(undefined8 *)(param_1 + 0xd508) = 0;
    *(undefined4 *)(param_1 + 0xd500) = 4;
  }
  if (*(int *)(param_1 + 0xd500) == 4) {
    uVar4 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd620),0,param_1 + 0xd518,1);
    if (uVar4 == 0xffffffdb) {
      _libssh2_error(param_1,0xffffffdb,"Would block waiting for response from remote");
      return 0;
    }
    if ((int)uVar4 < 0) {
      _libssh2_error(param_1,(ulong)uVar4,"SCP failure",(ulong)uVar4);
      goto LAB_00133fc4;
    }
    if (uVar4 != 0) {
      if (*(char *)(param_1 + 0xd518) != '\0') {
        _libssh2_error(param_1,0xffffffe4,"Invalid ACK response from remote");
        goto LAB_00133fc4;
      }
      if ((param_5 != 0) || (param_6 != 0)) {
        iVar3 = snprintf((char *)(param_1 + 0xd518),0x100,"T%ld 0 %ld 0\n",param_5,param_6);
        *(long *)(param_1 + 0xd618) = (long)iVar3;
      }
      *(undefined4 *)(param_1 + 0xd500) = 5;
      goto LAB_00133b10;
    }
  }
  else {
LAB_00133b10:
    if ((param_5 == 0) && (param_6 == 0)) {
      if (*(int *)(param_1 + 0xd500) == 5) {
        *(undefined4 *)(param_1 + 0xd500) = 7;
      }
    }
    else {
      if (*(int *)(param_1 + 0xd500) == 5) {
        iVar3 = _libssh2_channel_write
                          (*(undefined8 *)(param_1 + 0xd620),0,param_1 + 0xd518,
                           *(undefined8 *)(param_1 + 0xd618));
        if (iVar3 == -0x25) {
          _libssh2_error(param_1,0xffffffdb,"Would block sending time data for SCP file");
          return 0;
        }
        if (iVar3 != (int)*(undefined8 *)(param_1 + 0xd618)) {
          _libssh2_error(param_1,0xfffffff9,"Unable to send time data for SCP file");
          goto LAB_00133fc4;
        }
        *(undefined4 *)(param_1 + 0xd500) = 6;
      }
      if (*(int *)(param_1 + 0xd500) == 6) {
        uVar4 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd620),0,param_1 + 0xd518,1);
        if (uVar4 == 0xffffffdb) {
          _libssh2_error(param_1,0xffffffdb,"Would block waiting for response");
          return 0;
        }
        if ((int)uVar4 < 0) {
          _libssh2_error(param_1,(ulong)uVar4,"SCP failure",(ulong)uVar4);
          goto LAB_00133fc4;
        }
        if (uVar4 == 0) goto LAB_00133f86;
        if (*(char *)(param_1 + 0xd518) != '\0') {
          _libssh2_error(param_1,0xffffffe4,"Invalid SCP ACK response");
          goto LAB_00133fc4;
        }
        *(undefined4 *)(param_1 + 0xd500) = 7;
      }
    }
    if (*(int *)(param_1 + 0xd500) == 7) {
      pcVar8 = strrchr(param_2,0x2f);
      local_28 = param_2;
      if (pcVar8 != (char *)0x0) {
        local_28 = pcVar8 + 1;
      }
      iVar3 = snprintf((char *)(param_1 + 0xd518),0x100,"C0%o %lld %s\n",(ulong)param_3,param_4,
                       local_28);
      *(long *)(param_1 + 0xd618) = (long)iVar3;
      *(undefined4 *)(param_1 + 0xd500) = 8;
    }
    if (*(int *)(param_1 + 0xd500) == 8) {
      iVar3 = _libssh2_channel_write
                        (*(undefined8 *)(param_1 + 0xd620),0,param_1 + 0xd518,
                         *(undefined8 *)(param_1 + 0xd618));
      if (iVar3 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block send core file data for SCP file");
        return 0;
      }
      if (iVar3 != (int)*(undefined8 *)(param_1 + 0xd618)) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send core file data for SCP file");
        goto LAB_00133fc4;
      }
      *(undefined4 *)(param_1 + 0xd500) = 9;
    }
    if (*(int *)(param_1 + 0xd500) != 9) {
LAB_00133f61:
      *(undefined4 *)(param_1 + 0xd500) = 0;
      return *(undefined8 *)(param_1 + 0xd620);
    }
    iVar3 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd620),0,param_1 + 0xd518,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block waiting for response");
      return 0;
    }
    if (iVar3 < 0) {
      _libssh2_error(param_1,0xffffffe4,"Invalid ACK response from remote");
      goto LAB_00133fc4;
    }
    if (iVar3 != 0) {
      if (*(char *)(param_1 + 0xd518) == '\0') goto LAB_00133f61;
      lVar10 = _libssh2_channel_packet_data_len(*(undefined8 *)(param_1 + 0xd620),0);
      lVar9 = ((void*(*)())(param_1 + 8))(lVar10 + 1,param_1,param_1,lVar10 + 1);
      if (lVar9 == 0) {
        _libssh2_error(param_1,0xfffffffa,"failed to get memory");
      }
      else {
        iVar3 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd620),0,lVar9,lVar10);
        if (0 < iVar3) {
          *(undefined *)(lVar10 + lVar9) = 0;
        }
        ((void*(*)())(param_1 + 0x18))(lVar9,param_1,lVar9,param_1);
        _libssh2_error(param_1,0xffffffe4,"failed to send file");
      }
      goto LAB_00133fc4;
    }
  }
LAB_00133f86:
  iVar3 = libssh2_channel_eof(*(undefined8 *)(param_1 + 0xd620));
  if (iVar3 == 0) {
    return *(undefined8 *)(param_1 + 0xd620);
  }
  _libssh2_error(param_1,0xffffffe4,"Unexpected channel close");
LAB_00133fc4:
  uVar1 = *(undefined4 *)(param_1 + 0x240);
  uVar6 = *(undefined8 *)(param_1 + 0x238);
  do {
    iVar3 = libssh2_channel_free(*(undefined8 *)(param_1 + 0xd620));
  } while (iVar3 == -0x25);
  *(undefined4 *)(param_1 + 0x240) = uVar1;
  *(undefined8 *)(param_1 + 0x238) = uVar6;
  *(undefined8 *)(param_1 + 0xd620) = 0;
  *(undefined4 *)(param_1 + 0xd500) = 0;
  return 0;
}



long libssh2_scp_send_ex(long param_1,undefined8 param_2,uint param_3,undefined8 param_4,
                        undefined8 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = FUN_00133680(param_1,param_2,(ulong)param_3,param_4,param_5,param_6);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



long libssh2_scp_send64(long param_1,undefined8 param_2,uint param_3,undefined8 param_4,
                       undefined8 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = FUN_00133680(param_1,param_2,(ulong)param_3,param_4,param_5,param_6);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



void FUN_00134175(size_t param_1)

{
  malloc(param_1);
  return;
}



void FUN_00134193(void *param_1)

{
  free(param_1);
  return;
}



void FUN_001341b2(void *param_1,size_t param_2)

{
  realloc(param_1,param_2);
  return;
}



undefined8 FUN_001341db(long param_1)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  char local_19;
  int local_18;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xcb60) == 0) {
    local_18 = 0;
    *(undefined4 *)(param_1 + 0xcb60) = 2;
  }
  else {
    local_18 = (int)*(undefined8 *)(param_1 + 0xcc68);
  }
  do {
    if ((0xff < local_18) ||
       ((local_18 != 0 && (*(char *)(param_1 + 0xcb64 + (long)(local_18 + -1)) == '\n')))) {
      while ((local_18 != 0 &&
             ((*(char *)(param_1 + 0xcb64 + (long)(local_18 + -1)) == '\n' ||
              (*(char *)(param_1 + 0xcb64 + (long)(local_18 + -1)) == '\r'))))) {
        local_18 = local_18 + -1;
      }
      *(undefined4 *)(param_1 + 0xcb60) = 0;
      *(undefined8 *)(param_1 + 0xcc68) = 0;
      if (local_18 == 0) {
        uVar1 = 0xfffffffe;
      }
      else {
        if (*(long *)(param_1 + 0x110) != 0) {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0x110),param_1,*(undefined8 *)(param_1 + 0x110),
                     param_1);
        }
        uVar1 = ((void*(*)())(param_1 + 8))
                          ((long)(local_18 + 1),param_1,(long)(local_18 + 1),param_1);
        *(undefined8 *)(param_1 + 0x110) = uVar1;
        if (*(long *)(param_1 + 0x110) == 0) {
          uVar1 = _libssh2_error(param_1,0xfffffffa,"Error allocating space for remote banner");
        }
        else {
          memcpy(*(void **)(param_1 + 0x110),(void *)(param_1 + 0xcb64),(long)local_18);
          *(undefined *)((long)local_18 + *(long *)(param_1 + 0x110)) = 0;
          uVar1 = 0;
        }
      }
LAB_001344b6:
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return uVar1;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    local_19 = '\0';
    *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffe;
    if (*(int *)(param_1 + 0x6c) == 0) {
      uVar1 = 0x4000;
    }
    else {
      uVar1 = 0;
    }
    local_14 = ((void*(*)())(param_1 + 0x50))
                         ((ulong)*(uint *)(param_1 + 0x228),&local_19,1,uVar1,param_1);
    if (local_14 < 0) {
      if (local_14 == -0xb) {
        *(undefined4 *)(param_1 + 0x230) = 1;
        *(long *)(param_1 + 0xcc68) = (long)local_18;
        uVar1 = 0xffffffdb;
      }
      else {
        *(undefined4 *)(param_1 + 0xcb60) = 0;
        *(undefined8 *)(param_1 + 0xcc68) = 0;
        uVar1 = 0xffffffd5;
      }
      goto LAB_001344b6;
    }
    if (local_14 == 0) {
      *(undefined4 *)(param_1 + 0x22c) = 0xffffffff;
      uVar1 = 0xfffffff3;
      goto LAB_001344b6;
    }
    if (local_19 == '\0') {
      *(undefined4 *)(param_1 + 0xcb60) = 0;
      *(undefined8 *)(param_1 + 0xcc68) = 0;
      uVar1 = 0xfffffffe;
      goto LAB_001344b6;
    }
    *(char *)(param_1 + 0xcb64 + (long)local_18) = local_19;
    local_18 = local_18 + 1;
  } while( 1 );
}



undefined8 FUN_001344cc(long param_1)

{
  size_t sVar1;
  long lVar2;
  undefined8 uVar3;
  int local_1c;
  char *local_18;
  
  local_18 = "SSH-2.0-libssh2_1.9.0_DEV\r\n";
  local_1c = 0x1b;
  if (*(int *)(param_1 + 0xcb60) == 0) {
    if (*(long *)(param_1 + 0x180) != 0) {
      sVar1 = strlen(*(char **)(param_1 + 0x180));
      local_1c = (int)sVar1;
      local_18 = *(char **)(param_1 + 0x180);
    }
    *(undefined4 *)(param_1 + 0xcb60) = 2;
  }
  *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffd;
  if (*(int *)(param_1 + 0x6c) == 0) {
    uVar3 = 0x4000;
  }
  else {
    uVar3 = 0;
  }
  lVar2 = ((void*(*)())(param_1 + 0x48))
                    ((ulong)*(uint *)(param_1 + 0x228),local_18 + *(long *)(param_1 + 0xcc68),
                     (long)local_1c - *(long *)(param_1 + 0xcc68),uVar3,param_1);
  if (lVar2 == (long)local_1c - *(long *)(param_1 + 0xcc68)) {
    *(undefined4 *)(param_1 + 0xcb60) = 0;
    *(undefined8 *)(param_1 + 0xcc68) = 0;
    uVar3 = 0;
  }
  else {
    if ((lVar2 < 0) && (lVar2 != -0xb)) {
      *(undefined4 *)(param_1 + 0xcb60) = 0;
      *(undefined8 *)(param_1 + 0xcc68) = 0;
      uVar3 = 0xffffffd5;
    }
    else {
      *(undefined4 *)(param_1 + 0x230) = 2;
      if (0 < lVar2) {
        *(long *)(param_1 + 0xcc68) = *(long *)(param_1 + 0xcc68) + lVar2;
      }
      uVar3 = 0xffffffdb;
    }
  }
  return uVar3;
}



void FUN_0013466d(int param_1,int param_2)

{
  uint uVar1;
  
  uVar1 = fcntl(param_1,3,0);
  if (param_2 == 0) {
    fcntl(param_1,4,
          (ulong)(uVar1 & 0xffff0000 |
                 (uint)CONCAT11((char)((ulong)uVar1 >> 8),(char)uVar1) & 0xfffff7ff));
  }
  else {
    fcntl(param_1,4,
          (ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >> 8),(char)uVar1) | 0x800
                 ));
  }
  return;
}



ulong FUN_001346d9(int param_1)

{
  uint uVar1;
  ulong uVar2;
  
  uVar1 = fcntl(param_1,3,0);
  if (uVar1 == 0xffffffff) {
    uVar2 = 1;
  }
  else {
    uVar2 = (ulong)(uVar1 & 0x800);
  }
  return uVar2;
}



undefined8 libssh2_session_banner_set(long param_1,char *param_2)

{
  size_t __n;
  undefined8 uVar1;
  
  if (param_2 == (char *)0x0) {
    __n = 0;
  }
  else {
    __n = strlen(param_2);
  }
  if (*(long *)(param_1 + 0x180) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0x180),param_1,*(undefined8 *)(param_1 + 0x180),param_1);
    *(undefined8 *)(param_1 + 0x180) = 0;
  }
  if (__n == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = ((void*(*)())(param_1 + 8))(__n + 3,param_1,param_1,__n + 3);
    *(undefined8 *)(param_1 + 0x180) = uVar1;
    if (*(long *)(param_1 + 0x180) == 0) {
      uVar1 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for local banner");
    }
    else {
      memcpy(*(void **)(param_1 + 0x180),param_2,__n);
      *(undefined *)(__n + *(long *)(param_1 + 0x180)) = 0;
      *(undefined *)(__n + *(long *)(param_1 + 0x180)) = 0xd;
      *(undefined *)(__n + 1 + *(long *)(param_1 + 0x180)) = 10;
      *(undefined *)(__n + 2 + *(long *)(param_1 + 0x180)) = 0;
      uVar1 = 0;
    }
  }
  return uVar1;
}



//void libssh2_banner_set(undefined8 param_1,undefined8 param_2)
//
//{
//  libssh2_session_banner_set(param_1,param_2,param_2);
//  return;
//}



undefined8 * libssh2_session_init_ex(void *param_1,void *param_2,void *param_3,undefined8 param_4)

{
  undefined8 local_48;
  void *local_40;
  void *local_38;
  void *local_30;
  void *local_28;
  void *local_20;
  void *local_18;
  undefined8 *local_10;
  
  local_28 = FUN_00134175;
  local_20 = FUN_00134193;
  local_18 = FUN_001341b2;
  if (param_1 != 0x0) {
    local_28 = param_1;
  }
  if (param_2 != 0x0) {
    local_20 = param_2;
  }
  if (param_3 != 0x0) {
    local_18 = param_3;
  }
  local_48 = param_4;
  local_40 = param_3;
  local_38 = param_2;
  local_30 = param_1;

  if (local_10 != (undefined8 *)0x0) {
    memset(local_10,0,0xd638);
   *local_10 = local_48;
    local_10[0x13] = 0;
    *(undefined4 *)((long)local_10 + 0x94) = 1;
    _libssh2_init_if_needed();
  }
  return local_10;
}



undefined8 libssh2_session_callback_set(long param_1,undefined4 param_2,undefined8 param_3)

{
  undefined8 uVar1;
  
  switch(param_2) {
  case 0:
    uVar1 = *(undefined8 *)(param_1 + 0x20);
    *(undefined8 *)(param_1 + 0x20) = param_3;
    break;
  case 1:
    uVar1 = *(undefined8 *)(param_1 + 0x28);
    *(undefined8 *)(param_1 + 0x28) = param_3;
    break;
  case 2:
    uVar1 = *(undefined8 *)(param_1 + 0x30);
    *(undefined8 *)(param_1 + 0x30) = param_3;
    break;
  case 3:
    uVar1 = *(undefined8 *)(param_1 + 0x38);
    *(undefined8 *)(param_1 + 0x38) = param_3;
    break;
  case 4:
    uVar1 = *(undefined8 *)(param_1 + 0x40);
    *(undefined8 *)(param_1 + 0x40) = param_3;
    break;
  case 5:
    uVar1 = *(undefined8 *)(param_1 + 0x48);
    *(undefined8 *)(param_1 + 0x48) = param_3;
    break;
  case 6:
    uVar1 = *(undefined8 *)(param_1 + 0x50);
    *(undefined8 *)(param_1 + 0x50) = param_3;
    break;
  default:
    uVar1 = 0;
  }
  return uVar1;
}





ulong FUN_00134cdc(long param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  ulong uVar4;
  
  if (*(int *)(param_1 + 0xcc88) == 0) {
    if (param_2 == -1) {
      uVar3 = _libssh2_error(param_1,0xffffffd3,"Bad socket provided");
      return uVar3;
    }
    *(int *)(param_1 + 0x228) = param_2;
    iVar1 = FUN_001346d9((ulong)*(uint *)(param_1 + 0x228));
    *(uint *)(param_1 + 0x234) = (uint)(iVar1 == 0);
    if ((*(int *)(param_1 + 0x234) != 0) &&
       ( FUN_0013466d((ulong)*(uint *)(param_1 + 0x228),1), uVar2 != 0)) {
      _libssh2_error(param_1,(ulong)uVar2,
                             "Failed changing socket\'s blocking state to non-blocking",(ulong)uVar2
                            );
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 2;
  }
  if (*(int *)(param_1 + 0xcc88) == 2) {
    uVar2 = FUN_001344cc(param_1);
    if (uVar2 == 0xffffffdb) {
      return 0xffffffdb;
    }
    if (uVar2 != 0) {
      uVar3 = _libssh2_error(param_1,(ulong)uVar2,"Failed sending banner",(ulong)uVar2);
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 3;
    *(undefined4 *)(param_1 + 0xcb60) = 0;
  }
  if (*(int *)(param_1 + 0xcc88) == 3) {
    do {
      uVar2 = FUN_001341db(param_1);
      if (uVar2 == 0xffffffdb) {
        return 0xffffffdb;
      }
      if (uVar2 != 0) {
        uVar3 = _libssh2_error(param_1,(ulong)uVar2,"Failed getting banner",(ulong)uVar2);
        return uVar3;
      }
      iVar1 = strncmp("SSH-",*(char **)(param_1 + 0x110),4);
    } while (iVar1 != 0);
    *(undefined4 *)(param_1 + 0xcc88) = 4;
  }
  if (*(int *)(param_1 + 0xcc88) == 4) {
    uVar2 = _libssh2_kex_exchange(param_1,0,param_1 + 0xccd0);
    if (uVar2 == 0xffffffdb) {
      return 0xffffffdb;
    }
    if (uVar2 != 0) {
      uVar3 = _libssh2_error(param_1,(ulong)uVar2,"Unable to exchange encryption keys",(ulong)uVar2)
      ;
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 5;
  }
  if (*(int *)(param_1 + 0xcc88) == 5) {
    *(undefined *)(param_1 + 0xcca0) = 5;
    _libssh2_htonu32(param_1 + 0xcca1,0xc);
    memcpy((void *)(param_1 + 0xcca5),"ssh-userauth",0xc);
    *(undefined4 *)(param_1 + 0xcc88) = 6;
  }
  if (*(int *)(param_1 + 0xcc88) == 6) {
    uVar2 = _libssh2_transport_send(param_1,param_1 + 0xcca0,0x11,0,0);
    if (uVar2 == 0xffffffdb) {
      return 0xffffffdb;
    }
    if (uVar2 != 0) {
      uVar3 = _libssh2_error(param_1,(ulong)uVar2,"Unable to ask for ssh-userauth service",
                             (ulong)uVar2);
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 7;
  }
  if (*(int *)(param_1 + 0xcc88) == 7) {
    uVar2 = _libssh2_packet_require
                      (param_1,6,param_1 + 0xcc90,param_1 + 0xcc98,0,0,0,param_1 + 0xccc0);
    if (uVar2 == 0) {
      if (*(ulong *)(param_1 + 0xcc98) < 5) {
        uVar4 = _libssh2_error(param_1,0xfffffff2,"Unexpected packet length");
      }
      else {
        uVar2 = _libssh2_ntohu32(*(long *)(param_1 + 0xcc90) + 1);
        *(ulong *)(param_1 + 0xccb8) = (ulong)uVar2;
        if ((*(long *)(param_1 + 0xccb8) == 0xc) &&
           (iVar1 = strncmp("ssh-userauth",(char *)(*(long *)(param_1 + 0xcc90) + 5),
                            *(size_t *)(param_1 + 0xccb8)), iVar1 == 0)) {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xcc90),param_1,*(undefined8 *)(param_1 + 0xcc90),
                     param_1);
          *(undefined8 *)(param_1 + 0xcc90) = 0;
          *(undefined4 *)(param_1 + 0xcc88) = 0;
          return 0;
        }
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xcc90),param_1,*(undefined8 *)(param_1 + 0xcc90),
                   param_1);
        *(undefined8 *)(param_1 + 0xcc90) = 0;
        uVar4 = _libssh2_error(param_1,0xfffffff2,"Invalid response received from server");
      }
    }
    else {
      uVar4 = (ulong)uVar2;
    }
  }
  else {
    uVar4 = 0xffffffde;
  }
  return uVar4;
}



ulong libssh2_session_handshake(long param_1,uint param_2)

{
  uint local_14;
  
  time((time_t *)0x0);
  do {
    local_14 = FUN_00134cdc(param_1,(ulong)param_2);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;

  } while (local_14 == 0);
  return (ulong)local_14;
}



//void libssh2_session_startup(undefined8 param_1,uint param_2)
//
//{
//  libssh2_session_handshake(param_1,(ulong)param_2,(ulong)param_2);
//  return;
//}



undefined8 FUN_001351f3(long param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  
  if (*(int *)(param_1 + 0xcf68) == 0) {
    *(undefined4 *)(param_1 + 0xcf68) = 2;
  }
  if (*(int *)(param_1 + 0xcf68) == 2) {
    do {
      lVar2 = _libssh2_list_first(param_1 + 0x200);
      if (lVar2 == 0) {
        *(undefined4 *)(param_1 + 0xcf68) = 3;
        goto LAB_0013527b;
      }
      iVar1 = _libssh2_channel_free(lVar2);
    } while (iVar1 != -0x25);
    uVar3 = 0xffffffdb;
  }
  else {
LAB_0013527b:
    if (*(int *)(param_1 + 0xcf68) == 3) {
      do {
        lVar2 = _libssh2_list_first(param_1 + 0x218);
        if (lVar2 == 0) {
          *(undefined4 *)(param_1 + 0xcf68) = 4;
          goto LAB_001352d4;
        }
        iVar1 = _libssh2_channel_forward_cancel(lVar2);
      } while (iVar1 != -0x25);
      uVar3 = 0xffffffdb;
    }
    else {
LAB_001352d4:
      if ((*(uint *)(param_1 + 0x68) & 2) != 0) {
        if ((*(long *)(param_1 + 0xa0) != 0) && (*(long *)(*(long *)(param_1 + 0xa0) + 0x40) != 0))
        {
          ((void*(*)())(*(long *)(param_1 + 0xa0) + 0x40))
                    (param_1,param_1 + 0xa8,param_1,param_1 + 0xa8);
        }
        if ((*(long *)(param_1 + 0x198) != 0) && (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0)
           ) {
          ((void*(*)())(*(long *)(param_1 + 0x198) + 0x38))
                    (param_1,param_1 + 0x1a0,param_1,param_1 + 0x1a0);
        }
        if ((*(long *)(param_1 + 0x1c0) != 0) && (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)
           ) {
          ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8,param_1);
        }
        if ((*(long *)(param_1 + 0x1a8) != 0) && (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0)
           ) {
          ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x20))
                    (param_1,param_1 + 0x1b8,param_1,param_1 + 0x1b8);
        }
        if ((*(long *)(param_1 + 0x128) != 0) && (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0)
           ) {
          ((void*(*)())(*(long *)(param_1 + 0x128) + 0x38))
                    (param_1,param_1 + 0x130,param_1,param_1 + 0x130);
        }
        if ((*(long *)(param_1 + 0x150) != 0) && (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)
           ) {
          ((void*(*)())(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158,param_1);
        }
        if ((*(long *)(param_1 + 0x138) != 0) && (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0)
           ) {
          ((void*(*)())(*(long *)(param_1 + 0x138) + 0x20))
                    (param_1,param_1 + 0x148,param_1,param_1 + 0x148);
        }
        if (*(long *)(param_1 + 0x88) != 0) {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0x88),param_1,*(undefined8 *)(param_1 + 0x88),param_1
                    );
        }
      }
      if (*(long *)(param_1 + 0x110) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x110),param_1,*(undefined8 *)(param_1 + 0x110),param_1
                  );
      }
      if (*(long *)(param_1 + 0x180) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x180),param_1,*(undefined8 *)(param_1 + 0x180),param_1
                  );
      }
      if (*(long *)(param_1 + 0x58) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x58),param_1,*(undefined8 *)(param_1 + 0x58),param_1);
      }
      if (*(long *)(param_1 + 0x60) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x60),param_1,*(undefined8 *)(param_1 + 0x60),param_1);
      }
      if (*(long *)(param_1 + 0x188) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x188),param_1,*(undefined8 *)(param_1 + 0x188),param_1
                  );
      }
      if (*(long *)(param_1 + 0x1d0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x1d0),param_1,*(undefined8 *)(param_1 + 0x1d0),param_1
                  );
      }
      if (*(long *)(param_1 + 0x1d8) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x1d8),param_1,*(undefined8 *)(param_1 + 0x1d8),param_1
                  );
      }
      if (*(long *)(param_1 + 0x1e0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x1e0),param_1,*(undefined8 *)(param_1 + 0x1e0),param_1
                  );
      }
      if (*(long *)(param_1 + 0x1e8) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x1e8),param_1,*(undefined8 *)(param_1 + 0x1e8),param_1
                  );
      }
      if (*(long *)(param_1 + 0x118) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x118),param_1,*(undefined8 *)(param_1 + 0x118),param_1
                  );
      }
      if (*(long *)(param_1 + 0x160) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x160),param_1,*(undefined8 *)(param_1 + 0x160),param_1
                  );
      }
      if (*(long *)(param_1 + 0x168) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x168),param_1,*(undefined8 *)(param_1 + 0x168),param_1
                  );
      }
      if (*(long *)(param_1 + 0x170) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x170),param_1,*(undefined8 *)(param_1 + 0x170),param_1
                  );
      }
      if (*(long *)(param_1 + 0x178) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x178),param_1,*(undefined8 *)(param_1 + 0x178),param_1
                  );
      }
      if (*(long *)(param_1 + 0xcc78) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xcc78),param_1,*(undefined8 *)(param_1 + 0xcc78),
                   param_1);
      }
      if (*(long *)(param_1 + 0xcc90) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xcc90),param_1,*(undefined8 *)(param_1 + 0xcc90),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd098) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd098),param_1,*(undefined8 *)(param_1 + 0xd098),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd0b8) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd0d0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd0d0),param_1,*(undefined8 *)(param_1 + 0xd0d0),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd100) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd100),param_1,*(undefined8 *)(param_1 + 0xd100),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd110) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd110),param_1,*(undefined8 *)(param_1 + 0xd110),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd0f0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd0f0),param_1,*(undefined8 *)(param_1 + 0xd0f0),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd138) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd138),param_1,*(undefined8 *)(param_1 + 0xd138),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd148) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd158) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd188) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd188),param_1,*(undefined8 *)(param_1 + 0xd188),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd198) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd198),param_1,*(undefined8 *)(param_1 + 0xd198),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd1c0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd1c0),param_1,*(undefined8 *)(param_1 + 0xd1c0),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd200) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd200),param_1,*(undefined8 *)(param_1 + 0xd200),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd210) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd210),param_1,*(undefined8 *)(param_1 + 0xd210),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd228) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd228),param_1,*(undefined8 *)(param_1 + 0xd228),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd250) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd250),param_1,*(undefined8 *)(param_1 + 0xd250),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd280) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd280),param_1,*(undefined8 *)(param_1 + 0xd280),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd3c0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd3c0),param_1,*(undefined8 *)(param_1 + 0xd3c0),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd508) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd508),param_1,*(undefined8 *)(param_1 + 0xd508),
                   param_1);
      }
      if (*(long *)(param_1 + 0xd398) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd398),param_1,*(undefined8 *)(param_1 + 0xd398),
                   param_1);
      }
      if (*(long *)(param_1 + 0x4270) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x4278),param_1,*(undefined8 *)(param_1 + 0x4278),
                   param_1);
      }
      while (lVar2 = _libssh2_list_first(param_1 + 0x1f0), lVar2 != 0) {
        _libssh2_list_remove(lVar2);
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(lVar2 + 0x18),param_1,*(undefined8 *)(lVar2 + 0x18),param_1);
        ((void*(*)())(param_1 + 0x18))(lVar2,param_1,lVar2,param_1);
      }
      if (*(int *)(param_1 + 0x234) != 0) {
        FUN_0013466d((ulong)*(uint *)(param_1 + 0x228),0);
      }
      if (*(long *)(param_1 + 0xb0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xb0),param_1,*(undefined8 *)(param_1 + 0xb0),param_1);
      }
      if ((*(long *)(param_1 + 0x238) != 0) && ((*(uint *)(param_1 + 0x244) & 1) != 0)) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0x238),param_1,*(undefined8 *)(param_1 + 0x238),param_1
                  );
      }
      ((void*(*)())(param_1 + 0x18))(param_1,param_1,param_1,param_1);
      uVar3 = 0;
    }
  }
  return uVar3;
}



ulong libssh2_session_free(long param_1)

{
  time_t tVar1;
  uint local_14;
  
  tVar1 = time((time_t *)0x0);
  do {
    local_14 = FUN_001351f3(param_1);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
    local_14 = _libssh2_wait_socket(param_1,tVar1);
  } while (local_14 == 0);
  return (ulong)local_14;
}



undefined8 FUN_00135d54(long param_1,uint param_2,char *param_3,char *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_28;
  size_t local_20;
  size_t local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = 0;
  local_18 = 0;
  if (*(int *)(param_1 + 0xcf6c) == 0) {
    if (param_3 != (char *)0x0) {
      local_20 = strlen(param_3);
    }
    if (param_4 != (char *)0x0) {
      local_18 = strlen(param_4);
    }
    if (0x100 < local_20) {
      uVar2 = _libssh2_error(param_1,0xffffffde,"too long description");
      goto LAB_00135ec0;
    }
    *(long *)(param_1 + 0xd080) = local_18 + local_20 + 0xd;
    local_28 = param_1 + 0xcf71;
    *(undefined *)(param_1 + 0xcf70) = 1;
    _libssh2_store_u32(&local_28,(ulong)param_2);
    _libssh2_store_str(&local_28,param_3,local_20);
    _libssh2_store_u32(&local_28,local_18 & 0xffffffff);
    *(undefined4 *)(param_1 + 0xcf6c) = 2;
  }
  iVar1 = _libssh2_transport_send
                    (param_1,param_1 + 0xcf70,*(undefined8 *)(param_1 + 0xd080),param_4,local_18);
  if (iVar1 == -0x25) {
    uVar2 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 0xcf6c) = 0;
    uVar2 = 0;
  }
LAB_00135ec0:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong libssh2_session_disconnect_ex(long param_1,uint param_2,undefined8 param_3,undefined8 param_4)

{
  uint local_14;
  
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
  time((time_t *)0x0);
  do {
    local_14 = FUN_00135d54(param_1,(ulong)param_2,param_3,param_4);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;

  } while (local_14 == 0);
  return (ulong)local_14;
}



undefined * libssh2_session_methods(long param_1,undefined4 param_2)

{
  undefined8 uVar1;
  undefined8 *local_10;
  
  switch(param_2) {
  case 0:
    local_10 = *(undefined8 **)(param_1 + 0x78);
    break;
  case 1:
    local_10 = *(undefined8 **)(param_1 + 0xa0);
    break;
  case 2:
    local_10 = *(undefined8 **)(param_1 + 0x198);
    break;
  case 3:
    local_10 = *(undefined8 **)(param_1 + 0x128);
    break;
  case 4:
    local_10 = *(undefined8 **)(param_1 + 0x1a8);
    break;
  case 5:
    local_10 = *(undefined8 **)(param_1 + 0x138);
    break;
  case 6:
    local_10 = *(undefined8 **)(param_1 + 0x1c0);
    break;
  case 7:
    local_10 = *(undefined8 **)(param_1 + 0x150);
    break;
  case 8:
    return &DAT_00148eab;
  case 9:
    return &DAT_00148eab;
  default:
    _libssh2_error(param_1,0xffffffde,"Invalid parameter specified for method_type");
    return (undefined *)0;
  }
  if (local_10 == (undefined8 *)0x0) {
    _libssh2_error(param_1,0xffffffef,"No method negotiated");
    uVar1 = 0;
  }
  else {
    uVar1 = *local_10;
  }
  return (undefined *)uVar1;
}



undefined8 libssh2_session_abstract(undefined8 param_1)

{
  return param_1;
}



ulong libssh2_session_last_error(long param_1,char **param_2,undefined4 *param_3,int param_4)

{
  ulong uVar1;
  char *__s;
  size_t __n;
  char *pcVar2;
  undefined4 local_18;
  
  local_18 = 0;
  if (*(int *)(param_1 + 0x240) == 0) {
    if (param_2 != (char **)0x0) {
      if (param_4 == 0) {
        *param_2 = "";
      }
      else {
        __s = (char *)((void*(*)())(param_1 + 8))(1,param_1,param_1);
        *param_2 = __s;
        if (*param_2 != (char *)0x0) {
          **param_2 = '\0';
        }
      }
    }
    if (param_3 != (undefined4 *)0x0) {
      *param_3 = 0;
    }
    uVar1 = 0;
  }
  else {
    if (param_2 != (char **)0x0) {
      if (*(long *)(param_1 + 0x238) == 0) {
        __s = "";
      }
      else {
        __s = *(char **)(param_1 + 0x238);
      }
      __n = strlen(__s);
      local_18 = (undefined4)__n;
      if (param_4 == 0) {
        *param_2 = __s;
      }
      else {
        pcVar2 = (char *)((void*(*)())(param_1 + 8))(__n + 1,param_1,param_1,__n + 1);
        *param_2 = pcVar2;
        if (*param_2 != (char *)0x0) {
          memcpy(*param_2,__s,__n);
          (*param_2)[__n] = '\0';
        }
      }
    }
    if (param_3 != (undefined4 *)0x0) {
      *param_3 = local_18;
    }
    uVar1 = (ulong)*(uint *)(param_1 + 0x240);
  }
  return uVar1;
}


//
//ulong libssh2_session_last_errno(long param_1)
//
//{
//  return (ulong)*(uint *)(param_1 + 0x240);
//}
//


void libssh2_session_set_last_error(undefined8 param_1,uint param_2,undefined8 param_3)

{
  _libssh2_error_flags(param_1,(ulong)param_2,param_3,1);
  return;
}



undefined8 libssh2_session_flag(long param_1,int param_2,undefined4 param_3)

{
  if (param_2 == 1) {
    *(undefined4 *)(param_1 + 0x6c) = param_3;
  }
  else {
    if (param_2 != 2) {
      return 0xffffffde;
    }
    *(undefined4 *)(param_1 + 0x70) = param_3;
  }
  return 0;
}





//void libssh2_session_set_blocking(undefined8 param_1,uint param_2)
//
//{
//  _libssh2_session_set_blocking(param_1,(ulong)param_2,(ulong)param_2);
//  return;
//}
//
//
//
//ulong libssh2_session_get_blocking(long param_1)
//
//{
//  return (ulong)*(uint *)(param_1 + 0x94);
//}
//
//
//
//void libssh2_session_set_timeout(long param_1,undefined8 param_2)
//
//{
//  *(undefined8 *)(param_1 + 0x98) = param_2;
//  return;
//}
//
//
//
//undefined8 libssh2_session_get_timeout(long param_1)
//
//{
//  return *(undefined8 *)(param_1 + 0x98);
//}



undefined8 libssh2_poll_channel_read(long param_1,int param_2)

{
  int iVar1;
  long lVar2;
  int iVar3;
  undefined8 uVar4;
  long local_28;
  
  if (param_1 == 0) {
    uVar4 = 0xffffffd9;
  }
  else {
    lVar2 = *(long *)(param_1 + 0x60);
    local_28 = _libssh2_list_first(lVar2 + 0x1f0);
    while (local_28 != 0) {
      if (*(ulong *)(local_28 + 0x20) < 5) {
        uVar4 = _libssh2_error(lVar2,0xffffffda,"Packet too small");
        return uVar4;
      }
      iVar1 = *(int *)(param_1 + 0x30);
      iVar3 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 1);
      if (iVar1 == iVar3) {
        if ((param_2 == 1) &&
           ((**(char **)(local_28 + 0x18) == '_' || (**(char **)(local_28 + 0x18) == '^')))) {
          return 1;
        }
        if ((param_2 == 0) && (**(char **)(local_28 + 0x18) == '^')) {
          return 1;
        }
      }
      local_28 = _libssh2_list_next(local_28);
    }
    uVar4 = 0;
  }
  return uVar4;
}



ulong FUN_00136423(long param_1)

{
  return (ulong)(*(int *)(param_1 + 0x38) != 0);
}



ulong FUN_0013643c(long param_1)

{
  long lVar1;
  
  lVar1 = _libssh2_list_first(param_1 + 0x30);
  return (ulong)(lVar1 != 0);
}



ulong libssh2_poll(long param_1,uint param_2,long param_3)

{
  char cVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  uint local_854;
  uint local_850;
  long local_848;
  long local_840;
  timeval local_838;
  timeval local_828;
  pollfd local_818 [257];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_840 = 0;
  if (param_2 < 0x101) {
    local_854 = 0;
    while (local_848 = param_3, local_854 < param_2) {
      *(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 0x18) = 0;
      cVar1 = *(char *)(param_1 + (ulong)local_854 * 0x20);
      if (cVar1 == '\x02') {
        local_818[local_854].fd =
             *(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60) + 0x228);
        local_818[local_854].events = 1;
        local_818[local_854].revents = 0;
        if (local_840 == 0) {
          local_840 = *(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60);
        }
      }
      else {
        if (cVar1 == '\x03') {
          local_818[local_854].fd =
               *(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18) + 0x228);
          local_818[local_854].events = 1;
          local_818[local_854].revents = 0;
          if (local_840 == 0) {
            local_840 = *(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18);
          }
        }
        else {
          if (cVar1 != '\x01') {
            if (local_840 != 0) {
              _libssh2_error(local_840,0xffffffdd,"Invalid descriptor passed to libssh2_poll()");
            }
            uVar3 = 0xffffffff;
            goto LAB_00136edf;
          }
          local_818[local_854].fd = *(int *)(param_1 + (ulong)local_854 * 0x20 + 8);
          local_818[local_854].events =
               (short)*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 0x10);
          local_818[local_854].revents = 0;
        }
      }
      local_854 = local_854 + 1;
    }
    do {
      local_850 = 0;
      local_854 = 0;
      while (local_854 < param_2) {
        if (*(long *)(param_1 + (ulong)local_854 * 0x20 + 0x10) !=
            *(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18)) {
          cVar1 = *(char *)(param_1 + (ulong)local_854 * 0x20);
          if (cVar1 == '\x02') {
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 1) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 1) == 0)) {
              iVar2 = libssh2_poll_channel_read
                                (*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8),0);
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)(int)(uint)(iVar2 != 0) |
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 2) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 2) == 0)) {
              iVar2 = libssh2_poll_channel_read
                                (*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8),1);
              if (iVar2 == 0) {
                iVar2 = 0;
              }
              else {
                iVar2 = 2;
              }
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)iVar2 | *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 4) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 4) == 0)) {
              iVar2 = FUN_00136423(*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8));
              if (iVar2 == 0) {
                iVar2 = 0;
              }
              else {
                iVar2 = 4;
              }
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)iVar2 | *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if ((*(char *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x54) != '\0') ||
               (*(char *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x40) != '\0')) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x80;
            }
            if (*(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60) + 0x22c)
                == -1) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
            }
          }
          else {
            if (cVar1 == '\x03') {
              if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 1) != 0) &&
                 ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 1) == 0)) {
                iVar2 = FUN_0013643c(*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8));
                *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                     (long)(int)(uint)(iVar2 != 0) |
                     *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
              }
              if (*(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18) +
                          0x22c) == -1) {
                *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                     *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
              }
            }
          }
        }
        if (*(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18) != 0) {
          local_850 = local_850 + 1;
        }
        local_854 = local_854 + 1;
      }
      if (local_850 != 0) {
        local_848 = 0;
      }
      gettimeofday(&local_838,(__timezone_ptr_t)0x0);
      iVar2 = poll(local_818,(ulong)param_2,(int)local_848);
      gettimeofday(&local_828,(__timezone_ptr_t)0x0);
      local_848 = (local_848 + (local_828.tv_sec - local_838.tv_sec) * -1000) -
                  (local_828.tv_usec - local_838.tv_usec) / 1000;
      if (0 < iVar2) {
        local_854 = 0;
        while (local_854 < param_2) {
          cVar1 = *(char *)(param_1 + (ulong)local_854 * 0x20);
          if (cVar1 == '\x02') {
            if ((local_818[local_854].events & 1U) != 0) {
              do {
                iVar2 = _libssh2_transport_read
                                  (*(undefined8 *)
                                    (*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60));
              } while (0 < iVar2);
            }
            if ((local_818[local_854].revents & 0x10U) != 0) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
            }
            local_818[local_854].revents = 0;
          }
          else {
            if (cVar1 == '\x03') {
              if ((local_818[local_854].events & 1U) != 0) {
                do {
                  iVar2 = _libssh2_transport_read
                                    (*(undefined8 *)
                                      (*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18));
                } while (0 < iVar2);
              }
              if ((local_818[local_854].revents & 0x10U) != 0) {
                *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                     *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
              }
              local_818[local_854].revents = 0;
            }
            else {
              if (cVar1 == '\x01') {
                *(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                     (long)local_818[local_854].revents;
                local_818[local_854].revents = 0;
                if (*(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18) != 0) {
                  local_850 = local_850 + 1;
                }
              }
            }
          }
          local_854 = local_854 + 1;
        }
      }
    } while ((0 < local_848) && (local_850 == 0));
    uVar3 = (ulong)local_850;
  }
  else {
    uVar3 = 0xffffffff;
  }
LAB_00136edf:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}





undefined8 libssh2_session_banner_get(long param_1)

{
  undefined8 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    if (*(long *)(param_1 + 0x110) == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = *(undefined8 *)(param_1 + 0x110);
    }
  }
  return uVar1;
}



ulong FUN_00136f43(undefined8 param_1)

{
  uint uVar1;
  
  uVar1 = (uint)param_1;
  return (ulong)((uVar1 & 8) + (uVar1 & 1) * 8 + 4 + (uVar1 & 2) * 4 + (uVar1 & 4));
}



void FUN_00136f78(long *param_1,undefined8 param_2)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)*param_1;
  *puVar1 = (char)((ulong)param_2 >> 0x38);
  puVar1[1] = (char)((ulong)param_2 >> 0x30);
  puVar1[2] = (char)((ulong)param_2 >> 0x28);
  puVar1[3] = (char)((ulong)param_2 >> 0x20);
  puVar1[4] = (char)((ulong)param_2 >> 0x18);
  puVar1[5] = (char)((ulong)param_2 >> 0x10);
  puVar1[6] = (char)((ulong)param_2 >> 8);
  puVar1[7] = (char)param_2;
  *param_1 = *param_1 + 8;
  return;
}



long FUN_0013703b(long param_1,int param_2)

{
  long local_10;
  
  local_10 = _libssh2_list_first(param_1 + 0x20);
  while ((local_10 != 0 && (param_2 != *(int *)(local_10 + 0x18)))) {
    local_10 = _libssh2_list_next(local_10);
  }
  return local_10;
}



void FUN_0013708c(long *param_1,uint param_2)

{
  long lVar1;
  long lVar2;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  lVar2 = FUN_0013703b(param_1,(ulong)param_2);
  if (lVar2 != 0) {
    _libssh2_list_remove(lVar2);
    ((void*(*)())(lVar1 + 0x18))(lVar2,lVar1,lVar2,lVar1);
  }
  return;
}



undefined8 FUN_001370ed(long *param_1,undefined4 param_2)

{
  long lVar1;
  undefined8 uVar2;
  
  uVar2 = *(undefined8 *)(*param_1 + 0x60);
  lVar1 = ((void*(*)())(*(long *)(*param_1 + 0x60) + 8))
                    (0x20,*(undefined8 *)(*param_1 + 0x60),*(undefined8 *)(*param_1 + 0x60));
  if (lVar1 == 0) {
    uVar2 = _libssh2_error(uVar2,0xfffffffa,"malloc fail for zombie request  ID");
  }
  else {
    *(undefined4 *)(lVar1 + 0x18) = param_2;
    _libssh2_list_add(param_1 + 4,lVar1);
    uVar2 = 0;
  }
  return uVar2;
}



undefined8 FUN_0013717c(long *param_1,byte *param_2,ulong param_3)

{
  byte bVar1;
  long lVar2;
  uint uVar3;
  long lVar4;
  undefined8 uVar5;
  
  lVar2 = *(long *)(*param_1 + 0x60);
  if (param_3 < 5) {
    return 0xffffffd7;
  }
  bVar1 = *param_2;
  if (bVar1 < 0x6a) {
    if ((bVar1 < 0x65) && (0x13 < (uint)bVar1 - 1)) {
LAB_001371d8:
      uVar5 = _libssh2_error(lVar2,0xffffffe1,"Out of sync with the world");
      return uVar5;
    }
  }
  else {
    if (1 < (uint)bVar1 - 200) goto LAB_001371d8;
  }
  uVar3 = _libssh2_ntohu32(param_2 + 1);
  if (((*param_2 == 0x65) || (*param_2 == 0x67)) &&
     (lVar4 = FUN_0013703b(param_1,(ulong)uVar3), lVar4 != 0)) {
    ((void*(*)())(lVar2 + 0x18))(param_2,lVar2,param_2,lVar2);
    FUN_0013708c(param_1,(ulong)uVar3);
    uVar5 = 0;
  }
  else {
    lVar4 = ((void*(*)())(lVar2 + 8))(0x30,lVar2,lVar2);
    if (lVar4 == 0) {
      uVar5 = _libssh2_error(lVar2,0xfffffffa,"Unable to allocate datablock for SFTP packet");
    }
    else {
      *(byte **)(lVar4 + 0x20) = param_2;
      *(ulong *)(lVar4 + 0x28) = param_3;
      *(uint *)(lVar4 + 0x18) = uVar3;
      _libssh2_list_add(param_1 + 2,lVar4);
      uVar5 = 0;
    }
  }
  return uVar5;
}



ulong FUN_001372e0(long *param_1)

{
  byte bVar1;
  long lVar2;
  long lVar3;
  undefined4 uVar4;
  int iVar5;
  ulong uVar6;
  undefined8 uVar7;
  byte *local_30;
  
  lVar2 = *param_1;
  lVar3 = *(long *)(lVar2 + 0x60);
  local_30 = (byte *)0x0;
  if (*(int *)(param_1 + 0x13) == 3) {
    *(undefined4 *)(param_1 + 0x13) = 0;
    local_30 = (byte *)param_1[10];
  }
  else {
    if (*(int *)(param_1 + 0x13) == 4) {
      *(undefined4 *)(param_1 + 0x13) = 0;
      local_30 = (byte *)param_1[10];
    }
    if (local_30 != (byte *)0x0) goto LAB_0013763b;
    uVar6 = _libssh2_channel_read(lVar2,0,(long)param_1 + param_1[9] + 0x44,4 - param_1[9]);
    if (uVar6 == 0xffffffffffffffdb) {
      return 0xffffffffffffffdb;
    }
    if ((long)uVar6 < 0) {
      uVar7 = _libssh2_error(lVar3,uVar6 & 0xffffffff,"channel read",uVar6 & 0xffffffff);
      return uVar7;
    }
    param_1[9] = param_1[9] + uVar6;
    if (param_1[9] != 4) {
      return 0xffffffdb;
    }
    uVar4 = _libssh2_ntohu32((long)param_1 + 0x44);
    *(undefined4 *)(param_1 + 0xb) = uVar4;
    if (0x40000 < *(uint *)(param_1 + 0xb)) {
      libssh2_channel_flush_ex(lVar2,0);
      param_1[9] = 0;
      uVar7 = _libssh2_error(lVar3,0xffffffe7,"SFTP packet too large");
      return uVar7;
    }
    if (*(int *)(param_1 + 0xb) == 0) {
      uVar7 = _libssh2_error(lVar3,0xfffffffa,"Unable to allocate empty SFTP packet");
      return uVar7;
    }
    local_30 = (byte *)((void*(*)())(lVar3 + 8))
                                 ((ulong)*(uint *)(param_1 + 0xb),lVar3,lVar3,
                                  (ulong)*(uint *)(param_1 + 0xb));
    if (local_30 == (byte *)0x0) {
      uVar7 = _libssh2_error(lVar3,0xfffffffa,"Unable to allocate SFTP packet");
      return uVar7;
    }
    param_1[9] = 0;
    param_1[0xc] = 0;
    *(byte **)(param_1 + 10) = local_30;
  }
  uVar6 = libssh2_channel_window_read_ex(lVar2,0,0);
  if (uVar6 < *(uint *)(param_1 + 0xb)) {
    iVar5 = _libssh2_channel_receive_window_adjust
                      (lVar2,(ulong)(uint)(*(int *)(param_1 + 0xb) * 2),1,0);
    if (iVar5 == -0x25) {
      uVar4 = 3;
    }
    else {
      uVar4 = 0;
    }
    *(undefined4 *)(param_1 + 0x13) = uVar4;
    if (iVar5 == -0x25) {
      return 0xffffffffffffffdb;
    }
  }
LAB_0013763b:
  while( 1 ) {
    if ((ulong)*(uint *)(param_1 + 0xb) <= (ulong)param_1[0xc]) {
      param_1[10] = 0;
      bVar1 = *local_30;
      iVar5 = FUN_0013717c(param_1,local_30,(ulong)*(uint *)(param_1 + 0xb));
      uVar6 = SEXT48(iVar5);
      if (uVar6 == 0) {
        uVar6 = (ulong)bVar1;
      }
      else {
        ((void*(*)())(lVar3 + 0x18))(local_30,lVar3,local_30,lVar3);
      }
      return uVar6;
    }
    uVar6 = _libssh2_channel_read
                      (lVar2,0,local_30 + param_1[0xc],
                       (ulong)*(uint *)(param_1 + 0xb) - param_1[0xc]);
    if (uVar6 == 0xffffffffffffffdb) break;
    if ((long)uVar6 < 0) {
      ((void*(*)())(lVar3 + 0x18))(local_30,lVar3,local_30,lVar3);
      param_1[10] = 0;
      uVar7 = _libssh2_error(lVar3,uVar6 & 0xffffffff,"Error waiting for SFTP packet",
                             uVar6 & 0xffffffff);
      return uVar7;
    }
    param_1[0xc] = param_1[0xc] + uVar6;
  }
  *(undefined4 *)(param_1 + 0x13) = 4;
  return 0xffffffffffffffdb;
}

undefined8
FUN_001377fd(long *param_1,char param_2,int param_3,undefined8 *param_4,undefined8 *param_5)

{
  long lVar1;
  long local_18;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  local_18 = _libssh2_list_first(param_1 + 2);
  if (local_18 != 0) {
    while (local_18 != 0) {
      if ((param_2 == **(char **)(local_18 + 0x20)) &&
         ((param_2 == '\x02' || (param_3 == *(int *)(local_18 + 0x18))))) {
        *param_4 = *(undefined8 *)(local_18 + 0x20);
        *param_5 = *(undefined8 *)(local_18 + 0x28);
        _libssh2_list_remove(local_18);
        ((void*(*)())(lVar1 + 0x18))(local_18,lVar1,local_18,lVar1);
        return 0;
      }
      local_18 = _libssh2_list_next(local_18);
    }
  }
  return 0xffffffff;
}



void FUN_001376ba(long param_1)

{
  long in_FS_OFFSET;
  int local_44;
  undefined8 local_40;
  undefined local_38 [8];
  long local_30;
  long *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *(long **)(param_1 + 0x18);
  local_20 = *(long *)(*local_28 + 0x60);
  local_30 = _libssh2_list_first(param_1 + 0x178);
  while (local_30 != 0) {
    local_18 = _libssh2_list_next(local_30);
    local_44 = FUN_001377fd(local_28,0x65,(ulong)*(uint *)(local_30 + 0x38),&local_40,local_38);
    if (local_44 != 0) {
      local_44 = FUN_001377fd(local_28,0x67,(ulong)*(uint *)(local_30 + 0x38),&local_40,local_38);
    }
    if (local_44 == 0) {
      ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
    }
    else {
      if (*(long *)(local_30 + 0x28) != 0) {
        FUN_001370ed(local_28,(ulong)*(uint *)(local_30 + 0x38));
      }
    }
    _libssh2_list_remove(local_30);
    ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
    local_30 = local_18;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}





ulong FUN_001378de(long *param_1,byte param_2,uint param_3,long param_4,ulong *param_5,ulong param_6
                  )

{
  long lVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  if (((param_4 == 0) || (param_5 == (ulong *)0x0)) || (param_6 == 0)) {
    uVar4 = 0xffffffd9;
  }
  else {
    iVar2 = FUN_001377fd(param_1,(ulong)param_2,(ulong)param_3,param_4,param_5);
    if (iVar2 == 0) {
      if (*param_5 < param_6) {
        uVar4 = 0xffffffda;
      }
      else {
        uVar4 = 0;
      }
    }
    else {
      do {
        if (*(int *)(lVar1 + 0x22c) != 0) {
          return 0xfffffff3;
        }
        uVar3 = FUN_001372e0(param_1);
        if ((int)uVar3 < 0) {
          return (ulong)uVar3;
        }
        iVar2 = FUN_001377fd(param_1,(ulong)param_2,(ulong)param_3,param_4,param_5);
      } while (iVar2 != 0);
      if (*param_5 < param_6) {
        uVar4 = 0xffffffda;
      }
      else {
        uVar4 = 0;
      }
    }
  }
  return uVar4;
}



ulong FUN_001379d5(long *param_1,int param_2,long param_3,uint param_4,long param_5,ulong *param_6,
                  ulong param_7)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  time_t tVar4;
  int local_18;
  
  if (((param_5 == 0) || (param_6 == (ulong *)0x0)) || (param_7 == 0)) {
    uVar3 = 0xffffffd9;
  }
  else {
    if (param_1[0xd] == 0) {
      tVar4 = time((time_t *)0x0);
      param_1[0xd] = tVar4;
    }
    do {
      do {
        if (*(int *)(*(long *)(*param_1 + 0x60) + 0x22c) != 0) {
          param_1[0xd] = 0;
          return 0xfffffff3;
        }
        local_18 = 0;
        while (local_18 < param_2) {
          iVar1 = FUN_001377fd(param_1,(ulong)*(byte *)(param_3 + local_18),(ulong)param_4,param_5,
                               param_6);
          if (iVar1 == 0) {
            param_1[0xd] = 0;
            if (*param_6 < param_7) {
              return 0xffffffda;
            }
            return 0;
          }
          local_18 = local_18 + 1;
        }
        uVar2 = FUN_001372e0(param_1);
        if (((int)uVar2 < 0) && (uVar2 != 0xffffffdb)) {
          param_1[0xd] = 0;
          return (ulong)uVar2;
        }
      } while (0 < (int)uVar2);
      tVar4 = time((time_t *)0x0);
      if (0x3c - (tVar4 - param_1[0xd]) < 1) {
        param_1[0xd] = 0;
        return 0xfffffff7;
      }
    } while (uVar2 != 0xffffffdb);
    uVar3 = 0xffffffdb;
  }
  return uVar3;
}



long FUN_00137b5d(long param_1,ulong *param_2)

{
  uint uVar1;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = param_1;
  if (param_2 == (ulong *)0x0) {
    _libssh2_htonu32(param_1,0);
    param_1 = 4;
  }
  else {
    uVar1 = (uint)*param_2 & 0xf;
    _libssh2_store_u32(&local_18,(ulong)uVar1);
    if ((*param_2 & 1) != 0) {
      FUN_00136f78(&local_18,param_2[1]);
    }
    if ((*param_2 & 2) != 0) {
      _libssh2_store_u32(&local_18,param_2[2] & 0xffffffff);
      _libssh2_store_u32(&local_18,param_2[3] & 0xffffffff);
    }
    if ((*param_2 & 4) != 0) {
      _libssh2_store_u32(&local_18,param_2[4] & 0xffffffff);
    }
    if ((*param_2 & 8) != 0) {
      _libssh2_store_u32(&local_18,param_2[5] & 0xffffffff);
      _libssh2_store_u32(&local_18,param_2[6] & 0xffffffff);
    }
    param_1 = local_18 - param_1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return param_1;
}



long FUN_00137cb9(ulong *param_1,long param_2,undefined8 param_3)

{
  int iVar1;
  long lVar2;
  long in_FS_OFFSET;
  uint local_34;
  uint local_30;
  uint local_2c;
  long local_28;
  long local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_34 = 0;
  local_28 = param_2;
  local_20 = param_2;
  local_18 = param_3;
  iVar1 = _libssh2_get_u32(&local_28,&local_34);
  if (iVar1 != 0) {
    lVar2 = 0xffffffda;
    goto LAB_00137e74;
  }
  *param_1 = (ulong)local_34;
  if ((*param_1 & 1) != 0) {
    iVar1 = _libssh2_get_u64(&local_28,param_1 + 1);
    if (iVar1 != 0) {
      lVar2 = 0xffffffda;
      goto LAB_00137e74;
    }
  }
  if ((*param_1 & 2) != 0) {
    local_30 = 0;
    local_2c = 0;
    iVar1 = _libssh2_get_u32(&local_28,&local_30);
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_u32(&local_28,&local_2c);
      if (iVar1 == 0) {
        param_1[2] = (ulong)local_30;
        param_1[3] = (ulong)local_2c;
        goto LAB_00137dcb;
      }
    }
    lVar2 = 0xffffffda;
    goto LAB_00137e74;
  }
LAB_00137dcb:
  if ((*param_1 & 4) != 0) {
    iVar1 = _libssh2_get_u32(&local_28,&local_2c);
    if (iVar1 != 0) {
      lVar2 = 0xffffffda;
      goto LAB_00137e74;
    }
    param_1[4] = (ulong)local_2c;
  }
  if ((*param_1 & 8) == 0) {
LAB_00137e63:
    lVar2 = local_20 - local_28;
  }
  else {
    iVar1 = _libssh2_get_u32(&local_28,&local_30);
    if (iVar1 == 0) {
      iVar1 = _libssh2_get_u32(&local_28,&local_2c);
      if (iVar1 == 0) {
        param_1[5] = (ulong)local_30;
        param_1[6] = (ulong)local_2c;
        goto LAB_00137e63;
      }
    }
    lVar2 = 0xffffffda;
  }
LAB_00137e74:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar2;
}



void libssh2_sftp_dtor(long param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  long lVar1;
  
  lVar1 = *param_4;
  if (*(long *)(lVar1 + 0x50) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(lVar1 + 0x50),param_1,*(undefined8 *)(lVar1 + 0x50),param_1);
  }
  if (*(long *)(lVar1 + 0xb8) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(lVar1 + 0xb8),param_1,*(undefined8 *)(lVar1 + 0xb8),param_1);
  }
  ((void*(*)())(param_1 + 0x18))(lVar1,param_1,lVar1,param_1);
  return;
}



long * FUN_00137f20(long param_1)

{
  int iVar1;
  undefined8 uVar2;
  long *plVar3;
  long in_FS_OFFSET;
  long local_60;
  long local_58;
  undefined local_50 [8];
  undefined local_48 [8];
  long *local_40;
  ulong local_38;
  ulong local_30;
  long local_28;
  ulong local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd394) == 0) {
    if (*(long *)(param_1 + 0xd398) != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("session->sftpInit_sftp == NULL",
                    "/home/mantovan/Repositories/libssh2/src/sftp.c",0x316,"sftp_init");
    }
    *(undefined8 *)(param_1 + 0xd398) = 0;
    *(undefined4 *)(param_1 + 0xd394) = 2;
  }
  local_40 = *(long **)(param_1 + 0xd398);
  if (*(int *)(param_1 + 0xd394) == 2) {
    uVar2 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd3a0) = uVar2;
    if (*(long *)(param_1 + 0xd3a0) == 0) {
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting up channel");
      }
      else {
        _libssh2_error(param_1,0xffffffeb,"Unable to startup channel");
        *(undefined4 *)(param_1 + 0xd394) = 0;
      }
      plVar3 = (long *)0x0;
      goto LAB_00138611;
    }
    *(undefined4 *)(param_1 + 0xd394) = 3;
  }
  if (*(int *)(param_1 + 0xd394) == 3) {
    iVar1 = _libssh2_channel_process_startup
                      (*(undefined8 *)(param_1 + 0xd3a0),"subsystem",9,&DAT_001490fa,4);
    if (iVar1 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block to request SFTP subsystem");
      plVar3 = (long *)0x0;
      goto LAB_00138611;
    }
    if (iVar1 == 0) {
      *(undefined4 *)(param_1 + 0xd394) = 4;
      goto LAB_0013810c;
    }
    _libssh2_error(param_1,0xffffffeb,"Unable to request SFTP subsystem");
  }
  else {
LAB_0013810c:
    if (*(int *)(param_1 + 0xd394) == 4) {
      iVar1 = _libssh2_channel_extended_data(*(undefined8 *)(param_1 + 0xd3a0),1);
      local_38 = SEXT48(iVar1);
      if (local_38 == 0xffffffffffffffdb) {
        _libssh2_error(param_1,0xffffffdb,"Would block requesting handle extended data");
        plVar3 = (long *)0x0;
        goto LAB_00138611;
      }
      uVar2 = _libssh2_calloc(param_1,0x160);
      *(undefined8 *)(param_1 + 0xd398) = uVar2;
      local_40 = *(long **)(param_1 + 0xd398);
      if (local_40 == (long *)0x0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate a new SFTP structure");
        goto LAB_00138599;
      }
      *local_40 = *(long *)(param_1 + 0xd3a0);
      *(undefined4 *)(local_40 + 1) = 0;
      _libssh2_htonu32(param_1 + 0xd3a8,5);
      *(undefined *)(param_1 + 0xd3ac) = 1;
      _libssh2_htonu32(param_1 + 0xd3ad,3);
      *(undefined4 *)(param_1 + 0xd3b4) = 0;
      *(undefined4 *)(param_1 + 0xd394) = 5;
    }
    if (*(int *)(param_1 + 0xd394) == 5) {
      local_38 = _libssh2_channel_write
                           (*(undefined8 *)(param_1 + 0xd3a0),0,
                            param_1 + 0xd3a8 + (long)*(int *)(param_1 + 0xd3b4),
                            (long)(9 - *(int *)(param_1 + 0xd3b4)));
      if (local_38 == 0xffffffffffffffdb) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending SSH_FXP_INIT");
        plVar3 = (long *)0x0;
        goto LAB_00138611;
      }
      if ((long)local_38 < 0) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send SSH_FXP_INIT");
        goto LAB_00138599;
      }
      *(int *)(param_1 + 0xd3b4) = (int)local_38 + *(int *)(param_1 + 0xd3b4);
      if (*(int *)(param_1 + 0xd3b4) == 9) {
        *(undefined4 *)(param_1 + 0xd394) = 6;
      }
    }
    iVar1 = FUN_001378de(local_40,2,0,&local_60,&local_58,5);
    local_38 = SEXT48(iVar1);
    if (local_38 == 0xffffffffffffffdb) {
      _libssh2_error(param_1,0xffffffdb,"Would block receiving SSH_FXP_VERSION");
      plVar3 = (long *)0x0;
      goto LAB_00138611;
    }
    if (local_38 == 0xffffffffffffffda) {
      if (local_58 != 0) {
        ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
      }
      _libssh2_error(param_1,0xffffffe1,"Invalid SSH_FXP_VERSION response");
    }
    else {
      if (local_38 == 0) {
        local_28 = local_60;
        local_20 = local_60 + 1;
        local_18 = local_58;
        local_30 = local_58 + local_60;
        iVar1 = _libssh2_get_u32(&local_28,(long)local_40 + 0xc);
        if (iVar1 == 0) {
          if (3 < *(uint *)((long)local_40 + 0xc)) {
            *(undefined4 *)((long)local_40 + 0xc) = 3;
          }
          do {
            if (local_30 <= local_20) {
              ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
              *(long **)(*local_40 + 0x68) = local_40;

              *(undefined4 *)(param_1 + 0xd394) = 0;
              *(undefined8 *)(param_1 + 0xd398) = 0;
              *(undefined8 *)(param_1 + 0xd3a0) = 0;
              _libssh2_list_init(local_40 + 6);
              plVar3 = local_40;
              goto LAB_00138611;
            }

            if (iVar1 != 0) {
              ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
              _libssh2_error(param_1,0xffffffda,"Data too short when extracting extname");
              goto LAB_00138599;
            }
          } while (iVar1 == 0);
          ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
          _libssh2_error(param_1,0xffffffda,"Data too short when extracting extdata");
        }
        else {
          ((void*(*)())(param_1 + 0x18))(local_60,param_1,local_60,param_1);
          local_38 = 0xffffffffffffffda;
        }
      }
      else {
        _libssh2_error(param_1,local_38 & 0xffffffff,
                       "Timeout waiting for response from SFTP subsystem",local_38 & 0xffffffff);
      }
    }
  }
LAB_00138599:
  do {
    iVar1 = _libssh2_channel_free(*(undefined8 *)(param_1 + 0xd3a0));
  } while (iVar1 == -0x25);
  *(undefined8 *)(param_1 + 0xd3a0) = 0;
  if (*(long *)(param_1 + 0xd398) != 0) {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd398),param_1,*(undefined8 *)(param_1 + 0xd398),param_1);
    *(undefined8 *)(param_1 + 0xd398) = 0;
  }
  *(undefined4 *)(param_1 + 0xd394) = 0;
  plVar3 = (long *)0x0;
LAB_00138611:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



long libssh2_sftp_init(long param_1)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = 0;
  }
  else {
    if ((*(uint *)(param_1 + 0x68) & 4) == 0) {
      _libssh2_error(param_1,0xffffffde,"session not authenticated yet");
      lVar2 = 0;
    }
    else {
      tVar3 = time((time_t *)0x0);
      do {
        lVar2 = FUN_00137f20(param_1);
        if (*(int *)(param_1 + 0x94) == 0) {
          return lVar2;
        }
        if (lVar2 != 0) {
          return lVar2;
        }
        iVar1 = libssh2_session_last_errno(param_1);
        if (iVar1 != -0x25) {
          return 0;
        }
        iVar1 = _libssh2_wait_socket(param_1,tVar3);
      } while (iVar1 == 0);
    }
  }
  return lVar2;
}



ulong FUN_001386d7(long *param_1)

{
  long lVar1;
  uint uVar2;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  if (param_1[10] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[10],lVar1,param_1[10],lVar1);
    param_1[10] = 0;
  }
  if (param_1[0xf] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0xf],lVar1,param_1[0xf],lVar1);
    param_1[0xf] = 0;
  }
  if (param_1[0x17] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x17],lVar1,param_1[0x17],lVar1);
    param_1[0x17] = 0;
  }
  if (param_1[0x19] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x19],lVar1,param_1[0x19],lVar1);
    param_1[0x19] = 0;
  }
  if (param_1[0x1b] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x1b],lVar1,param_1[0x1b],lVar1);
    param_1[0x1b] = 0;
  }
  if (param_1[0x1d] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x1d],lVar1,param_1[0x1d],lVar1);
    param_1[0x1d] = 0;
  }
  if (param_1[0x20] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x20],lVar1,param_1[0x20],lVar1);
    param_1[0x20] = 0;
  }
  if (param_1[0x22] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x22],lVar1,param_1[0x22],lVar1);
    param_1[0x22] = 0;
  }
  if (param_1[0x24] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x24],lVar1,param_1[0x24],lVar1);
    param_1[0x24] = 0;
  }
  if (param_1[0x26] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x26],lVar1,param_1[0x26],lVar1);
    param_1[0x26] = 0;
  }
  if (param_1[0x28] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x28],lVar1,param_1[0x28],lVar1);
    param_1[0x28] = 0;
  }
  if (param_1[0x2a] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x2a],lVar1,param_1[0x2a],lVar1);
    param_1[0x2a] = 0;
  }
  if (param_1[0x15] != 0) {
    ((void*(*)())(lVar1 + 0x18))(param_1[0x15],lVar1,param_1[0x15],lVar1);
    param_1[0x15] = 0;
  }
  FUN_0013b842(param_1);
  uVar2 = _libssh2_channel_free(*param_1);
  return (ulong)uVar2;
}



ulong libssh2_sftp_shutdown(long *param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_001386d7(param_1);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



long FUN_00138aa3(long *param_1,undefined8 param_2,undefined8 param_3,uint param_4,ulong param_5,
                 int param_6)

{
  bool bVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  long lVar5;
  undefined uVar6;
  long in_FS_OFFSET;
  bool bVar7;
  undefined *local_80;
  ulong local_78;
  char *local_70;
  long local_68;
  long local_60;
  ulong local_58;
  long local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  ulong local_28;
  undefined8 local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_68 = *param_1;
  local_60 = *(long *)(local_68 + 0x60);
  local_48 = 4;
  local_40 = 0;
  local_38 = 0;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  local_18 = 0;
  bVar7 = param_6 == 0;
  if (*(int *)(param_1 + 0xe) == 0) {
    if (bVar7) {
      iVar2 = FUN_00136f43(4);
      iVar2 = iVar2 + 4;
    }
    else {
      iVar2 = 0;
    }
    *(int *)(param_1 + 0x10) = (int)param_3 + iVar2 + 0xd;
    param_1[0x11] = 0;
    lVar5 = ((void*(*)())(local_60 + 8))
                      ((ulong)*(uint *)(param_1 + 0x10),local_60,local_60,
                       (ulong)*(uint *)(param_1 + 0x10));
    param_1[0xf] = lVar5;
    local_80 = (undefined *)param_1[0xf];
    if (param_1[0xf] == 0) {
      _libssh2_error(local_60,0xfffffffa,
                     "Unable to allocate memory for FXP_OPEN or FXP_OPENDIR packet");
      lVar5 = 0;
      goto LAB_001392cb;
    }
    if (bVar7) {
      local_28 = 0x8000;
    }
    else {
      local_28 = 0x4000;
    }
    local_28 = local_28 | param_5;
    _libssh2_store_u32(&local_80,(ulong)(*(int *)(param_1 + 0x10) - 4U));

    if (bVar7) {
      uVar6 = 3;
    }
    else {
      uVar6 = 0xb;
    }
    *local_80 = uVar6;
    iVar2 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar2 + 1;
    *(int *)(param_1 + 0x12) = iVar2;
    local_80 = local_80 + 1;
    _libssh2_store_u32(&local_80,(ulong)*(uint *)(param_1 + 0x12));
    _libssh2_store_str(&local_80,param_2,param_3);
    if (bVar7) {
      _libssh2_store_u32(&local_80,(ulong)param_4);
      lVar5 = FUN_00137b5d(local_80,&local_48);
      local_80 = local_80 + lVar5;
    }
    *(undefined4 *)(param_1 + 0xe) = 2;
  }
  if (*(int *)(param_1 + 0xe) == 2) {
    local_58 = _libssh2_channel_write
                         (local_68,0,param_1[0xf] + param_1[0x11],
                          (ulong)*(uint *)(param_1 + 0x10) - param_1[0x11]);
    if (local_58 == 0xffffffffffffffdb) {
      _libssh2_error(local_60,0xffffffdb,"Would block sending FXP_OPEN or FXP_OPENDIR command");
      lVar5 = 0;
      goto LAB_001392cb;
    }
    if ((long)local_58 < 0) {
      _libssh2_error(local_60,local_58 & 0xffffffff,"Unable to send FXP_OPEN*",local_58 & 0xffffffff
                    );
      ((void*(*)())(local_60 + 0x18))(param_1[0xf],local_60,param_1[0xf],local_60);
      param_1[0xf] = 0;
      *(undefined4 *)(param_1 + 0xe) = 0;
      lVar5 = 0;
      goto LAB_001392cb;
    }
    param_1[0x11] = param_1[0x11] + local_58;
    if ((ulong)*(uint *)(param_1 + 0x10) == param_1[0x11]) {
      ((void*(*)())(local_60 + 0x18))(param_1[0xf],local_60,param_1[0xf],local_60);
      param_1[0xf] = 0;
      *(undefined4 *)(param_1 + 0xe) = 3;
    }
  }
  if (*(int *)(param_1 + 0xe) == 3) {
    iVar2 = FUN_001379d5(param_1,2,&DAT_00149c6a,(ulong)*(uint *)(param_1 + 0x12),&local_70,
                         &local_78,1);
    local_58 = SEXT48(iVar2);
    if (local_58 == 0xffffffffffffffdb) {
      _libssh2_error(local_60,0xffffffdb,"Would block waiting for status message");
      lVar5 = 0;
    }
    else {
      if (local_58 == 0xffffffffffffffda) {
        if (local_78 != 0) {
          ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
        }
        _libssh2_error(local_60,0xffffffe1,"Response too small");
        lVar5 = 0;
      }
      else {
        *(undefined4 *)(param_1 + 0xe) = 0;
        if (local_58 == 0) {
          if (*local_70 == 'e') {
            bVar1 = 1;
            if (local_78 < 9) {
              _libssh2_error(local_60,0xffffffe1,"Too small FXP_STATUS");
              ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
              lVar5 = 0;
              goto LAB_001392cb;
            }
            uVar3 = _libssh2_ntohu32(local_70 + 5);
            *(undefined4 *)(param_1 + 8) = uVar3;
            if (*(int *)(param_1 + 8) == 0) {
              ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
              iVar2 = FUN_001378de(param_1,0x66,(ulong)*(uint *)(param_1 + 0x12),&local_70,&local_78
                                   ,10);
              local_58 = SEXT48(iVar2);
              if (local_58 == 0xffffffffffffffdb) {
                *(undefined4 *)(param_1 + 0xe) = 3;
                lVar5 = 0;
                goto LAB_001392cb;
              }
              if (local_58 == 0xffffffffffffffda) {
                if (local_78 != 0) {
                  ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
                }
                _libssh2_error(local_60,0xffffffe1,"Too small FXP_HANDLE");
                lVar5 = 0;
                goto LAB_001392cb;
              }
              if (local_58 == 0) {
                bVar1 = 0;
              }
            }
            if (bVar1) {
              _libssh2_error(local_60,0xffffffe1,"Failed opening remote file");
              ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
              lVar5 = 0;
              goto LAB_001392cb;
            }
          }
          if (local_78 < 10) {
            _libssh2_error(local_60,0xffffffe1,"Too small FXP_HANDLE");
            ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
            lVar5 = 0;
          }
          else {
            local_50 = _libssh2_calloc(local_60,0x188);
            if (local_50 == 0) {
              _libssh2_error(local_60,0xfffffffa,"Unable to allocate new SFTP handle structure");
              ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
              lVar5 = 0;
            }
            else {
              *(uint *)(local_50 + 0x128) = (uint)!bVar7;
              uVar4 = _libssh2_ntohu32(local_70 + 5);
              *(ulong *)(local_50 + 0x120) = (ulong)uVar4;
              if (0x100 < *(ulong *)(local_50 + 0x120)) {
                *(undefined8 *)(local_50 + 0x120) = 0x100;
              }
              if (local_78 - 9 < *(ulong *)(local_50 + 0x120)) {
                *(long *)(local_50 + 0x120) = local_78 - 9;
              }
              memcpy((void *)(local_50 + 0x20),local_70 + 9,*(size_t *)(local_50 + 0x120));
              ((void*(*)())(local_60 + 0x18))(local_70,local_60,local_70,local_60);
              _libssh2_list_add(param_1 + 6,local_50);
              *(long **)(local_50 + 0x18) = param_1;
              *(undefined8 *)(local_50 + 0x130) = 0;
              *(undefined8 *)(local_50 + 0x138) = 0;
              lVar5 = local_50;
            }
          }
        }
        else {
          _libssh2_error(local_60,local_58 & 0xffffffff,"Timeout waiting for status message",
                         local_58 & 0xffffffff);
          lVar5 = 0;
        }
      }
    }
  }
  else {
    lVar5 = 0;
  }
LAB_001392cb:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar5;
}



long libssh2_sftp_open_ex
               (long *param_1,undefined8 param_2,uint param_3,ulong param_4,undefined8 param_5,
               uint param_6)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == (long *)0x0) {
    lVar2 = 0;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = FUN_00138aa3(param_1,param_2,(ulong)param_3,param_4 & 0xffffffff,param_5,
                           (ulong)param_6);
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return lVar2;
      }
      if (lVar2 != 0) {
        return lVar2;
      }
      iVar1 = libssh2_session_last_errno(*(undefined8 *)(*param_1 + 0x60));
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar3);
    } while (iVar1 == 0);
  }
  return lVar2;
}



size_t FUN_001393ae(long param_1,void *param_2,ulong param_3)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  long lVar4;
  size_t sVar5;
  long in_FS_OFFSET;
  undefined8 uVar6;
  uint local_a0;
  uint local_9c;
  char *local_90;
  undefined *local_88;
  ulong local_80;
  long local_78;
  ulong local_70;
  void *local_68;
  ulong local_60;
  long *local_58;
  long local_50;
  long local_48;
  long *local_40;
  ulong local_38;
  ulong local_30;
  size_t local_28;
  ulong local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_58 = *(long **)(param_1 + 0x18);
  local_50 = *local_58;
  local_48 = *(long *)(local_50 + 0x60);
  local_80 = 0;
  local_40 = (long *)(param_1 + 0x130);
  local_70 = 0;
  iVar1 = *(int *)((long)local_58 + 0x94);
  local_68 = param_2;
  if (iVar1 == 3) {
LAB_00139839:
    *(undefined4 *)((long)local_58 + 0x94) = 0;
    local_78 = _libssh2_list_first(param_1 + 0x178);
    do {
      while( 1 ) {
        if (local_78 == 0) goto LAB_00139941;
        if (*(long *)(local_78 + 0x30) != 0) break;
LAB_00139923:
        local_78 = _libssh2_list_next(local_78);
      }
      local_28 = _libssh2_channel_write
                           (local_50,0,local_78 + *(long *)(local_78 + 0x28) + 0x3c,
                            *(undefined8 *)(local_78 + 0x30));
      if ((long)local_28 < 0) {
        *(undefined4 *)((long)local_58 + 0x94) = 3;
        sVar5 = local_28;
        goto LAB_00139dcc;
      }
      *(long *)(local_78 + 0x30) = *(long *)(local_78 + 0x30) - local_28;
      *(long *)(local_78 + 0x28) = *(long *)(local_78 + 0x28) + local_28;
      if (*(long *)(local_78 + 0x30) == 0) goto LAB_00139923;
      lVar4 = _libssh2_list_first(param_1 + 0x178);
    } while (local_78 == lVar4);
  }
  else {
    if (iVar1 != 5) {
      if (iVar1 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!\"State machine error; unrecognised read state\"",
                      "/home/mantovan/Repositories/libssh2/src/sftp.c",0x6b8,"sftp_read");
      }
      if (*(long *)(param_1 + 0x158) != 0) {
        local_20 = *(ulong *)(param_1 + 0x158);
        if (param_3 <= *(ulong *)(param_1 + 0x158)) {
          local_20 = param_3;
        }
        memcpy(param_2,(void *)(*(long *)(param_1 + 0x148) +
                               (*(long *)(param_1 + 0x150) - *(long *)(param_1 + 0x158))),local_20);
        local_40[5] = local_40[5] - local_20;
        *local_40 = *local_40 + local_20;
        sVar5 = local_20;
        if (local_40[5] == 0) {
          ((void*(*)())(local_48 + 0x18))(local_40[3],local_48,local_40[3],local_48);
          local_40[3] = 0;
          sVar5 = local_20;
        }
        goto LAB_00139dcc;
      }
      if (*(char *)(param_1 + 0x160) != '\0') {
        sVar5 = 0;
        goto LAB_00139dcc;
      }
      local_38 = *(long *)(param_1 + 0x138) - *local_40;
      local_60 = param_3 << 2;
      if (0x800000 < local_60) {
        local_60 = 0x800000;
      }
      if (local_38 < local_60) {
        local_80 = local_60 - local_38;
      }
      local_30 = libssh2_channel_window_read_ex(*local_58,0,0);
      if (local_30 < local_60) {

        local_28 = SEXT48(iVar1);
        if ((local_28 == 0xffffffffffffffdb) && (local_40[5] != 0)) {
                    // WARNING: Subroutine does not return
          __assert_fail("rc != LIBSSH2_ERROR_EAGAIN || !filep->data_left",
                        "/home/mantovan/Repositories/libssh2/src/sftp.c",0x5b3,"sftp_read");
        }
        if ((local_28 == 0xffffffffffffffdb) && (*(char *)(local_40 + 6) != '\0')) {
                    // WARNING: Subroutine does not return
          __assert_fail("rc != LIBSSH2_ERROR_EAGAIN || !filep->eof",
                        "/home/mantovan/Repositories/libssh2/src/sftp.c",0x5b4,"sftp_read");
        }
        sVar5 = local_28;
        if (local_28 != 0) goto LAB_00139dcc;
      }
      while (local_80 != 0) {
        iVar1 = (int)*(undefined8 *)(param_1 + 0x120);
        uVar2 = iVar1 + 0x19;
        local_a0 = (uint)local_80;
        if ((local_80 & 0xffffffff) < param_3) {
          local_a0 = (uint)param_3;
        }
        if (30000 < local_a0) {
          local_a0 = 30000;
        }
        local_78 = ((void*(*)())(local_48 + 8))((ulong)uVar2 + 0x40,local_48,local_48);
        if (local_78 == 0) {
          iVar1 = _libssh2_error(local_48,0xfffffffa,"malloc fail for FXP_WRITE");
          sVar5 = (long)iVar1;
          goto LAB_00139dcc;
        }
        *(long *)(local_78 + 0x18) = local_40[1];
        *(ulong *)(local_78 + 0x20) = (ulong)local_a0;
        *(ulong *)(local_78 + 0x30) = (ulong)uVar2;
        *(undefined8 *)(local_78 + 0x28) = 0;
        local_88 = (undefined *)(local_78 + 0x3c);
        uVar2 = iVar1 + 0x15;
        _libssh2_store_u32(&local_88,(ulong)uVar2);
        *local_88 = 5;
        uVar2 = *(uint *)(local_58 + 1);
        *(uint *)(local_58 + 1) = uVar2 + 1;
        *(uint *)(local_78 + 0x38) = uVar2;
        local_88 = local_88 + 1;
        _libssh2_store_u32(&local_88,(ulong)uVar2);
        _libssh2_store_str(&local_88,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
        FUN_00136f78(&local_88,local_40[1]);
        local_40[1] = local_40[1] + (ulong)local_a0;
        _libssh2_store_u32(&local_88,(ulong)local_a0);
        _libssh2_list_add(param_1 + 0x178,local_78);
        uVar3 = (ulong)local_a0;
        if (local_80 <= (ulong)local_a0) {
          uVar3 = local_80;
        }
        local_80 = local_80 - uVar3;
      }
      goto LAB_00139839;
    }
  }
LAB_00139941:
  *(undefined4 *)((long)local_58 + 0x94) = 0;
  uVar6 = 0x139964;
  local_78 = _libssh2_list_first(param_1 + 0x178);
  while (sVar5 = local_70, local_78 != 0) {
    if (*(long *)(local_78 + 0x30) != 0) {
      if (local_70 == 0) {
        iVar1 = _libssh2_error(local_48,0xffffffe1,"sftp_read() internal error");
        sVar5 = (long)iVar1;
      }
      goto LAB_00139dcc;
    }
    iVar1 = FUN_001379d5(local_58,2,"geheiesftp_close_handle",(ulong)*(uint *)(local_78 + 0x38),
                         &local_90,&local_88,9);
    local_28 = SEXT48(iVar1);
    if ((local_28 == 0xffffffffffffffdb) && (sVar5 = local_70, local_70 != 0)) goto LAB_00139dcc;
    if (local_28 == 0xffffffffffffffda) {
      if (local_88 != (undefined *)0x0) {
        ((void*(*)())(local_48 + 0x18))(local_90,local_48,local_90,local_48);
      }
      iVar1 = _libssh2_error(local_48,0xffffffe1,"Response too small");
      sVar5 = (long)iVar1;
      goto LAB_00139dcc;
    }
    if ((long)local_28 < 0) {
      *(undefined4 *)((long)local_58 + 0x94) = 5;
      sVar5 = local_28;
      goto LAB_00139dcc;
    }
    if (*local_90 == 'e') {
      _libssh2_list_remove(local_78);
      ((void*(*)())(local_48 + 0x18))(local_78,local_48,local_78,local_48);
      FUN_001376ba(param_1);
      iVar1 = _libssh2_ntohu32(local_90 + 5);
      ((void*(*)())(local_48 + 0x18))(local_90,local_48,local_90,local_48);
      if (iVar1 == 1) {
        *(undefined *)(local_40 + 6) = 1;
        sVar5 = local_70;
      }
      else {
        *(int *)(local_58 + 8) = iVar1;
        iVar1 = _libssh2_error(local_48,0xffffffe1,"SFTP READ error");
        sVar5 = (long)iVar1;
      }
      goto LAB_00139dcc;
    }
    if (*local_90 != 'g') {
      iVar1 = _libssh2_error(local_48,0xffffffe1,
                             "SFTP Protocol badness: unrecognised read request response");
      sVar5 = (long)iVar1;
      goto LAB_00139dcc;
    }
    if (*(long *)(local_78 + 0x18) != *local_40) {
      iVar1 = _libssh2_error(local_48,0xffffffe1,"Read Packet At Unexpected Offset");
      sVar5 = (long)iVar1;
      goto LAB_00139dcc;
    }
    local_9c = _libssh2_ntohu32(local_90 + 5);
    if (local_88 + -9 < (undefined *)(ulong)local_9c) {
      iVar1 = _libssh2_error(local_48,0xffffffe1,"SFTP Protocol badness");
      sVar5 = (long)iVar1;
      goto LAB_00139dcc;
    }
    if (*(ulong *)(local_78 + 0x20) < (ulong)local_9c) {
      iVar1 = _libssh2_error(local_48,0xffffffe1,"FXP_READ response too big");
      sVar5 = (long)iVar1;
      goto LAB_00139dcc;
    }
    if ((ulong)local_9c != *(ulong *)(local_78 + 0x20)) {
      local_40[1] = local_40[1] + ((ulong)local_9c - *(long *)(local_78 + 0x20));
    }
    if (param_3 < local_70 + local_9c) {
      local_40[5] = (local_70 + local_9c) - param_3;
      local_9c = (uint)param_3 - (int)local_70;
      *(char **)(local_40 + 3) = local_90;
      *(undefined **)(local_40 + 4) = local_88;
    }
    else {
      local_40[4] = 0;
    }
    memcpy(local_68,local_90 + 9,(ulong)local_9c);
    *local_40 = *local_40 + (ulong)local_9c;
    local_70 = local_70 + local_9c;
    local_68 = (void *)((long)local_68 + (ulong)local_9c);
    if (local_40[4] == 0) {
      ((void*(*)())(local_48 + 0x18))(local_90,local_48,local_90,local_48);
    }
    local_18 = _libssh2_list_next(local_78);
    _libssh2_list_remove(local_78);
    uVar6 = 0x139d3d;
    ((void*(*)())(local_48 + 0x18))(local_78,local_48,local_78,local_48);
    if (local_70 < param_3) {
      local_78 = local_18;
    }
    else {
      local_78 = 0;
    }
  }
  if (local_70 == 0) {
    iVar1 = _libssh2_error(local_48,0xffffffe1,"sftp_read() internal error");
    sVar5 = (long)iVar1;
  }
LAB_00139dcc:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return sVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long libssh2_sftp_read(long param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = FUN_001393ae(param_1,param_2,param_3);
      if (lVar2 != -0x25) {
        return lVar2;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return 0xffffffffffffffdb;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar3);
      lVar2 = (long)iVar1;
    } while (lVar2 == 0);
  }
  return lVar2;
}



ulong FUN_00139e80(long param_1,void *param_2,ulong param_3,void *param_4,ulong param_5,
                  char **param_6)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  long lVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  long local_a0;
  undefined *local_98;
  ulong local_90;
  long *local_88;
  long local_80;
  long local_78;
  ulong local_70;
  ulong local_68;
  ulong local_60;
  ulong local_58;
  ulong local_50;
  char *local_48 [7];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_88 = *(long **)(param_1 + 0x18);
  local_80 = *local_88;
  local_78 = *(long *)(local_80 + 0x60);
  iVar3 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar2 = iVar3 + 0xd;
  if (*(int *)((long)local_88 + 0xb4) == 0) {
    if (*(int *)(param_1 + 0x130) != 0) {
      local_70 = *(ulong *)(param_1 + 0x148);
      if (local_70 < 4) {
        local_90 = 0xffffffffffffffda;
      }
      else {
        local_98 = *(undefined **)(param_1 + 0x140);
        uVar2 = _libssh2_ntohu32(local_98);
        local_68 = (ulong)uVar2;
        local_98 = local_98 + 4;
        local_70 = local_70 - 4;
        if (local_68 < param_3) {
          if ((param_3 < local_68) || (local_70 < local_68)) {
            local_90 = 0xffffffffffffffda;
          }
          else {
            local_90 = local_68;
            memcpy(param_2,local_98,local_68);
            *(undefined *)(local_90 + (long)param_2) = 0;
            local_98 = local_98 + local_68;
            local_70 = local_70 - local_68;
            if (local_70 < 4) {
              local_90 = 0xffffffffffffffda;
            }
            else {
              uVar2 = _libssh2_ntohu32(local_98);
              local_60 = (ulong)uVar2;
              local_98 = local_98 + 4;
              local_70 = local_70 - 4;
              if ((param_4 != (void *)0x0) && (1 < param_5)) {
                local_58 = local_60;
                if ((param_5 <= local_60) || (local_70 < local_60)) {
                  local_90 = 0xffffffffffffffda;
                  goto LAB_0013a1f1;
                }
                memcpy(param_4,local_98,local_60);
                *(undefined *)(local_58 + (long)param_4) = 0;
              }
              if (local_70 < local_60) {
                local_90 = 0xffffffffffffffda;
              }
              else {
                local_98 = local_98 + local_60;
                local_70 = local_70 - local_60;
                if (param_6 == (char **)0x0) {
                  param_6 = local_48;
                }
                else {
                  memset(param_6,0,0x38);
                }
                iVar3 = FUN_00137cb9(param_6,local_98,local_70);
                if (iVar3 < 0) {
                  local_90 = 0xffffffffffffffda;
                }
                else {
                  local_98 = local_98 + iVar3;
                  local_70 = local_70 - (long)iVar3;
                  *(undefined **)(param_1 + 0x140) = local_98;
                  *(ulong *)(param_1 + 0x148) = local_70;
                }
              }
            }
          }
        }
        else {
          local_90 = 0xffffffffffffffda;
        }
      }
LAB_0013a1f1:
      *(int *)(param_1 + 0x130) = *(int *)(param_1 + 0x130) + -1;
      uVar5 = local_90;
      if (*(int *)(param_1 + 0x130) == 0) {
        ((void*(*)())(local_78 + 0x18))
                  (*(undefined8 *)(param_1 + 0x138),local_78,*(undefined8 *)(param_1 + 0x138),
                   local_78);
        uVar5 = local_90;
      }
      goto LAB_0013a687;
    }
    lVar4 = ((void*(*)())(local_78 + 8))((ulong)uVar2,local_78,(ulong)uVar2);
    local_88[0x17] = lVar4;
    local_98 = (undefined *)local_88[0x17];
    if (local_88[0x17] == 0) {
      iVar3 = _libssh2_error(local_78,0xfffffffa,"Unable to allocate memory for FXP_READDIR packet")
      ;
      uVar5 = (long)iVar3;
      goto LAB_0013a687;
    }
    uVar1 = iVar3 + 9;
    _libssh2_store_u32(&local_98,(ulong)uVar1);
    *local_98 = 0xc;
    iVar3 = *(int *)(local_88 + 1);
    *(int *)(local_88 + 1) = iVar3 + 1;
    *(int *)(local_88 + 0x18) = iVar3;
    local_98 = local_98 + 1;
    _libssh2_store_u32(&local_98,(ulong)*(uint *)(local_88 + 0x18));
    _libssh2_store_str(&local_98,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    *(undefined4 *)((long)local_88 + 0xb4) = 2;
  }
  if (*(int *)((long)local_88 + 0xb4) == 2) {
    uVar5 = _libssh2_channel_write(local_80,0,local_88[0x17],(ulong)uVar2);
    local_50 = uVar5;
    if (uVar5 == 0xffffffffffffffdb) goto LAB_0013a687;
    if (uVar5 != (ulong)uVar2) {
      ((void*(*)())(local_78 + 0x18))(local_88[0x17],local_78,local_88[0x17],local_78);
      local_88[0x17] = 0;
      *(undefined4 *)((long)local_88 + 0xb4) = 0;
      iVar3 = _libssh2_error(local_78,0xfffffff9,"_libssh2_channel_write() failed");
      uVar5 = (long)iVar3;
      goto LAB_0013a687;
    }
    ((void*(*)())(local_78 + 0x18))(local_88[0x17],local_78,local_88[0x17],local_78);
    local_88[0x17] = 0;
    *(undefined4 *)((long)local_88 + 0xb4) = 3;
  }
  iVar3 = FUN_001379d5(local_88,2,0x149c7c,(ulong)*(uint *)(local_88 + 0x18),local_48,&local_a0,9);
  uVar5 = SEXT48(iVar3);
  local_50 = uVar5;
  if (uVar5 != 0xffffffffffffffdb) {
    if (uVar5 == 0xffffffffffffffda) {
      if (local_a0 != 0) {
        ((void*(*)())(local_78 + 0x18))(local_48[0],local_78,local_48[0],local_78);
      }
      iVar3 = _libssh2_error(local_78,0xffffffe1,"Status message too short");
      uVar5 = (long)iVar3;
    }
    else {
      if (uVar5 == 0) {
        if (*local_48[0] == 'e') {
          uVar2 = _libssh2_ntohu32(local_48[0] + 5);
          local_50 = (ulong)uVar2;
          ((void*(*)())(local_78 + 0x18))(local_48[0],local_78,local_48[0],local_78);
          if (local_50 == 1) {
            *(undefined4 *)((long)local_88 + 0xb4) = 0;
            uVar5 = 0;
          }
          else {
            *(int *)(local_88 + 8) = (int)local_50;
            *(undefined4 *)((long)local_88 + 0xb4) = 0;
            iVar3 = _libssh2_error(local_78,0xffffffe1,"SFTP Protocol Error");
            uVar5 = (long)iVar3;
          }
        }
        else {
          *(undefined4 *)((long)local_88 + 0xb4) = 0;
          iVar3 = _libssh2_ntohu32(local_48[0] + 5);
          if (iVar3 == 0) {
            ((void*(*)())(local_78 + 0x18))(local_48[0],local_78,local_48[0],local_78);
            uVar5 = 0;
          }
          else {
            *(int *)(param_1 + 0x130) = iVar3;
            *(char **)(param_1 + 0x138) = local_48[0];
            *(char **)(param_1 + 0x140) = local_48[0] + 9;
            *(long *)(param_1 + 0x148) = local_a0 + -9;
            uVar5 = FUN_00139e80(param_1,param_2,param_3,param_4,param_5,param_6);
          }
        }
      }
      else {
        *(undefined4 *)((long)local_88 + 0xb4) = 0;
        iVar3 = _libssh2_error(local_78,uVar5 & 0xffffffff,"Timeout waiting for status message",
                               uVar5 & 0xffffffff);
        uVar5 = (long)iVar3;
      }
    }
  }
LAB_0013a687:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong libssh2_sftp_readdir_ex
                (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,undefined8 param_6)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_00139e80(param_1,param_2,param_3,param_4,param_5,param_6);
      if ((local_14 != 0xffffffdb) ||
         (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket
                           (*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_0013a750(long param_1,long param_2,ulong param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  ulong local_a0;
  long local_98;
  long local_78;
  undefined *local_70;
  long local_68;
  long local_60;
  ulong local_58;
  long *local_50;
  long local_48;
  long local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_50 = *(long **)(param_1 + 0x18);
  local_48 = *local_50;
  local_40 = *(long *)(local_48 + 0x60);
  local_58 = 0;
  local_38 = param_3;
  if (*(int *)((long)local_50 + 0x9c) != 3) {
    local_30 = *(long *)(param_1 + 0x140) +
               (*(long *)(param_1 + 0x138) - *(long *)(param_1 + 0x130));
    if (param_3 < local_30) {
      local_a0 = 0;
      local_98 = param_2;
    }
    else {
      local_98 = param_2 + local_30;
      local_a0 = param_3 - local_30;
    }
    *(undefined4 *)((long)local_50 + 0x9c) = 0;
    while (local_a0 != 0) {
      uVar1 = 30000;
      if (local_a0 < 0x7531) {
        uVar1 = (uint)local_a0;
      }
      iVar3 = uVar1 + (int)*(undefined8 *)(param_1 + 0x120);
      uVar2 = iVar3 + 0x19;
      local_60 = ((void*(*)())(local_40 + 8))((ulong)uVar2 + 0x40,local_40,local_40);
      if (local_60 == 0) {
        iVar3 = _libssh2_error(local_40,0xfffffffa,"malloc fail for FXP_WRITE");
        uVar4 = SEXT48(iVar3);
        goto LAB_0013ad43;
      }
      *(ulong *)(local_60 + 0x20) = (ulong)uVar1;
      *(undefined8 *)(local_60 + 0x28) = 0;
      *(ulong *)(local_60 + 0x30) = (ulong)uVar2;
      local_70 = (undefined *)(local_60 + 0x3c);
      uVar2 = iVar3 + 0x15;
      _libssh2_store_u32(&local_70,(ulong)uVar2);
      *local_70 = 6;
      uVar2 = *(uint *)(local_50 + 1);
      *(uint *)(local_50 + 1) = uVar2 + 1;
      *(uint *)(local_60 + 0x38) = uVar2;
      local_70 = local_70 + 1;
      _libssh2_store_u32(&local_70,(ulong)uVar2);
      _libssh2_store_str(&local_70,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
      FUN_00136f78(&local_70,*(undefined8 *)(param_1 + 0x138));
      *(long *)(param_1 + 0x138) = *(long *)(param_1 + 0x138) + (ulong)uVar1;
      _libssh2_store_str(&local_70,local_98,(ulong)uVar1);
      _libssh2_list_add(param_1 + 0x178,local_60);
      local_98 = local_98 + (ulong)uVar1;
      local_a0 = local_a0 - uVar1;
    }
    local_60 = _libssh2_list_first(param_1 + 0x178);
    while (local_60 != 0) {
      if (*(long *)(local_60 + 0x30) != 0) {
        uVar4 = _libssh2_channel_write
                          (local_48,0,local_60 + *(long *)(local_60 + 0x28) + 0x3c,
                           *(undefined8 *)(local_60 + 0x30));
        local_28 = uVar4;
        if ((long)uVar4 < 0) goto LAB_0013ad43;
        *(long *)(local_60 + 0x30) = *(long *)(local_60 + 0x30) - uVar4;
        *(long *)(local_60 + 0x28) = *(long *)(local_60 + 0x28) + uVar4;
        if (*(long *)(local_60 + 0x30) != 0) break;
      }
      local_60 = _libssh2_list_next(local_60);
    }
  }
  *(undefined4 *)((long)local_50 + 0x9c) = 0;
  local_60 = _libssh2_list_first(param_1 + 0x178);
  while (((local_60 != 0 && (*(long *)(local_60 + 0x30) == 0)) && (local_58 == 0))) {
    iVar3 = FUN_001378de(local_50,0x65,(ulong)*(uint *)(local_60 + 0x38),&local_68,&local_78,9);
    uVar4 = SEXT48(iVar3);
    local_28 = uVar4;
    if (uVar4 == 0xffffffffffffffda) {
      if (local_78 != 0) {
        ((void*(*)())(local_40 + 0x18))(local_68,local_40,local_68,local_40);
      }
      iVar3 = _libssh2_error(local_40,0xffffffe1,"FXP write packet too short");
      uVar4 = SEXT48(iVar3);
      goto LAB_0013ad43;
    }
    if ((long)uVar4 < 0) {
      if (uVar4 == 0xffffffffffffffdb) {
        *(undefined4 *)((long)local_50 + 0x9c) = 3;
      }
      goto LAB_0013ad43;
    }
    iVar3 = _libssh2_ntohu32(local_68 + 5);
    ((void*(*)())(local_40 + 0x18))(local_68,local_40,local_68,local_40);
    *(int *)(local_50 + 8) = iVar3;
    if (iVar3 != 0) {
      FUN_001376ba(param_1);
      *(long *)(param_1 + 0x130) = *(long *)(param_1 + 0x130) - *(long *)(param_1 + 0x140);
      *(undefined8 *)(param_1 + 0x138) = *(undefined8 *)(param_1 + 0x130);
      *(undefined8 *)(param_1 + 0x140) = 0;
      iVar3 = _libssh2_error(local_40,0xffffffe1,"FXP write failed");
      uVar4 = SEXT48(iVar3);
      goto LAB_0013ad43;
    }
    local_58 = local_58 + *(long *)(local_60 + 0x20);
    *(long *)(param_1 + 0x130) = *(long *)(param_1 + 0x130) + *(long *)(local_60 + 0x20);
    local_20 = _libssh2_list_next(local_60);
    _libssh2_list_remove(local_60);
    ((void*(*)())(local_40 + 0x18))(local_60,local_40,local_60,local_40);
    local_60 = local_20;
  }
  local_58 = local_58 + *(long *)(param_1 + 0x140);
  if (local_58 == 0) {
    uVar4 = 0;
  }
  else {
    uVar4 = local_58;
    if (local_38 <= local_58) {
      uVar4 = local_38;
    }
    *(long *)(param_1 + 0x140) = local_58 - uVar4;
    local_18 = uVar4;
  }
LAB_0013ad43:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long libssh2_sftp_write(long param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = FUN_0013a750(param_1,param_2,param_3);
      if (lVar2 != -0x25) {
        return lVar2;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return 0xffffffffffffffdb;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar3);
      lVar2 = (long)iVar1;
    } while (lVar2 == 0);
  }
  return lVar2;
}



ulong FUN_0013adf7(long param_1)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  long local_50;
  undefined *local_48;
  long local_40;
  undefined *local_38;
  long *local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *(long **)(param_1 + 0x18);
  local_28 = *local_30;
  local_20 = *(long *)(local_28 + 0x60);
  iVar3 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar2 = iVar3 + 0x22;
  if (*(int *)(local_30 + 0x14) == 0) {
    local_48 = (undefined *)((void*(*)())(local_20 + 8))((ulong)uVar2,local_20,(ulong)uVar2);
    local_38 = local_48;
    if (local_48 == (undefined *)0x0) {
      uVar4 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_EXTENDED packet"
                            );
      goto LAB_0013b135;
    }
    uVar1 = iVar3 + 0x1e;
    _libssh2_store_u32(&local_48,(ulong)uVar1);
    *local_48 = 200;
    iVar3 = *(int *)(local_30 + 1);
    *(int *)(local_30 + 1) = iVar3 + 1;
    *(int *)(local_30 + 0x16) = iVar3;
    local_48 = local_48 + 1;
    _libssh2_store_u32(&local_48,(ulong)*(uint *)(local_30 + 0x16));
    _libssh2_store_str(&local_48,"fsync@openssh.com",0x11);
    _libssh2_store_str(&local_48,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    *(undefined4 *)(local_30 + 0x14) = 2;
  }
  else {
    local_38 = (undefined *)local_30[0x15];
  }
  if (*(int *)(local_30 + 0x14) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,local_38,(ulong)uVar2);
    if ((local_18 == 0xffffffffffffffdb) ||
       ((-1 < (long)local_18 && ((long)local_18 < (long)(ulong)uVar2)))) {
      *(undefined **)(local_30 + 0x15) = local_38;
      uVar4 = 0xffffffdb;
      goto LAB_0013b135;
    }
    ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
    local_30[0x15] = 0;
    if ((long)local_18 < 0) {
      *(undefined4 *)(local_30 + 0x14) = 0;
      uVar4 = _libssh2_error(local_20,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013b135;
    }
    *(undefined4 *)(local_30 + 0x14) = 3;
  }
  iVar3 = FUN_001378de(local_30,0x65,(ulong)*(uint *)(local_30 + 0x16),&local_40,&local_50,9);
  uVar4 = SEXT48(iVar3);
  local_18 = uVar4;
  if (uVar4 != 0xffffffffffffffdb) {
    if (uVar4 == 0xffffffffffffffda) {
      if (local_50 != 0) {
        ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
      }
      uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP fsync packet too short");
    }
    else {
      if (uVar4 == 0) {
        *(undefined4 *)(local_30 + 0x14) = 0;
        iVar3 = _libssh2_ntohu32(local_40 + 5);
        ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
        if (iVar3 == 0) {
          uVar4 = 0;
        }
        else {
          *(int *)(local_30 + 8) = iVar3;
          uVar4 = _libssh2_error(local_20,0xffffffe1,"fsync failed");
        }
      }
      else {
        *(undefined4 *)(local_30 + 0x14) = 0;
        uVar4 = _libssh2_error(local_20,uVar4 & 0xffffffff,"Error waiting for FXP EXTENDED REPLY",
                               uVar4 & 0xffffffff);
      }
    }
  }
LAB_0013b135:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_sftp_fsync(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013adf7(param_1);
      if ((local_14 != 0xffffffdb) ||
         (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket
                           (*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_0013b1cd(long param_1,undefined8 *param_2,int param_3)

{
  uint uVar1;
  undefined8 uVar2;
  int iVar3;
  uint uVar4;
  long lVar5;
  ulong uVar6;
  char *pcVar7;
  undefined uVar8;
  long in_FS_OFFSET;
  long local_58;
  undefined *local_50;
  char *local_48;
  long *local_40;
  long local_38;
  long local_30;
  ulong local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = *(long **)(param_1 + 0x18);
  local_38 = *local_40;
  local_30 = *(long *)(local_38 + 0x60);
  uVar2 = *(undefined8 *)(param_1 + 0x120);
  if (param_3 == 0) {
    iVar3 = 0;
  }
  else {
    iVar3 = FUN_00136f43(*param_2);
  }
  iVar3 = iVar3 + (int)uVar2;
  uVar4 = iVar3 + 0xd;
  if (*(int *)((long)local_40 + 0xc4) == 0) {
    lVar5 = ((void*(*)())(local_30 + 8))((ulong)uVar4,local_30,(ulong)uVar4,local_30);
    local_40[0x19] = lVar5;
    local_50 = (undefined *)local_40[0x19];
    if (local_40[0x19] == 0) {
      uVar6 = _libssh2_error(local_30,0xfffffffa,
                             "Unable to allocate memory for FSTAT/FSETSTAT packet");
      goto LAB_0013b621;
    }
    uVar1 = iVar3 + 9;
    _libssh2_store_u32(&local_50,(ulong)uVar1);
    if (param_3 == 0) {
      uVar8 = 8;
    }
    else {
      uVar8 = 10;
    }
    *local_50 = uVar8;
    iVar3 = *(int *)(local_40 + 1);
    *(int *)(local_40 + 1) = iVar3 + 1;
    *(int *)(local_40 + 0x1a) = iVar3;
    local_50 = local_50 + 1;
    _libssh2_store_u32(&local_50,(ulong)*(uint *)(local_40 + 0x1a));
    _libssh2_store_str(&local_50,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    if (param_3 != 0) {
      lVar5 = FUN_00137b5d(local_50,param_2);
      local_50 = local_50 + lVar5;
    }
    *(undefined4 *)((long)local_40 + 0xc4) = 2;
  }
  if (*(int *)((long)local_40 + 0xc4) == 2) {
    uVar6 = _libssh2_channel_write(local_38,0,local_40[0x19],(ulong)uVar4);
    local_28 = uVar6;
    if (uVar6 == 0xffffffffffffffdb) goto LAB_0013b621;
    if (uVar6 != (ulong)uVar4) {
      ((void*(*)())(local_30 + 0x18))(local_40[0x19],local_30,local_40[0x19],local_30);
      local_40[0x19] = 0;
      *(undefined4 *)((long)local_40 + 0xc4) = 0;
      if (param_3 == 0) {
        pcVar7 = "Unable to send FXP_FSTAT command";
      }
      else {
        pcVar7 = "Unable to send FXP_FSETSTAT";
      }
      uVar6 = _libssh2_error(local_30,0xfffffff9,pcVar7,local_30);
      goto LAB_0013b621;
    }
    ((void*(*)())(local_30 + 0x18))(local_40[0x19],local_30,local_40[0x19],local_30);
    local_40[0x19] = 0;
    *(undefined4 *)((long)local_40 + 0xc4) = 3;
  }
  iVar3 = FUN_001379d5(local_40,2,0x149c7e,(ulong)*(uint *)(local_40 + 0x1a),&local_48,&local_58,9);
  uVar6 = SEXT48(iVar3);
  local_28 = uVar6;
  if (uVar6 != 0xffffffffffffffdb) {
    if (uVar6 == 0xffffffffffffffda) {
      if (local_58 != 0) {
        ((void*(*)())(local_30 + 0x18))(local_48,local_30,local_48,local_30);
      }
      uVar6 = _libssh2_error(local_30,0xffffffe1,"SFTP fstat packet too short");
    }
    else {
      if (uVar6 == 0) {
        *(undefined4 *)((long)local_40 + 0xc4) = 0;
        if (*local_48 == 'e') {
          iVar3 = _libssh2_ntohu32(local_48 + 5);
          ((void*(*)())(local_30 + 0x18))(local_48,local_30,local_48,local_30);
          if (iVar3 == 0) {
            uVar6 = 0;
          }
          else {
            *(int *)(local_40 + 8) = iVar3;
            uVar6 = _libssh2_error(local_30,0xffffffe1,"SFTP Protocol Error");
          }
        }
        else {
          iVar3 = FUN_00137cb9(param_2,local_48 + 5,local_58 + -5);
          if (iVar3 < 0) {
            ((void*(*)())(local_30 + 0x18))(local_48,local_30,local_48,local_30);
            uVar6 = _libssh2_error(local_30,0xffffffe1,"Attributes too short in SFTP fstat");
          }
          else {
            ((void*(*)())(local_30 + 0x18))(local_48,local_30,local_48,local_30);
            uVar6 = 0;
          }
        }
      }
      else {
        *(undefined4 *)((long)local_40 + 0xc4) = 0;
        uVar6 = _libssh2_error(local_30,uVar6 & 0xffffffff,"Timeout waiting for status message",
                               uVar6 & 0xffffffff);
      }
    }
  }
LAB_0013b621:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_sftp_fstat_ex(long param_1,long param_2,uint param_3)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if ((param_1 == 0) || (param_2 == 0)) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013b1cd(param_1,param_2,(ulong)param_3);
      if ((local_14 != 0xffffffdb) ||
         (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket
                           (*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



void libssh2_sftp_seek64(long param_1,long param_2)

{
  undefined8 uVar1;
  
  if ((param_1 != 0) &&
     ((param_2 != *(long *)(param_1 + 0x130) || (param_2 != *(long *)(param_1 + 0x138))))) {
    *(long *)(param_1 + 0x138) = param_2;
    *(undefined8 *)(param_1 + 0x130) = *(undefined8 *)(param_1 + 0x138);
    FUN_001376ba(param_1);
    if (*(long *)(param_1 + 0x158) != 0) {
      uVar1 = *(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60);
      ((void*(*)())(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x18))
                (*(undefined8 *)(param_1 + 0x148),uVar1,*(undefined8 *)(param_1 + 0x148),uVar1);
      *(undefined8 *)(param_1 + 0x150) = 0;
      *(undefined8 *)(param_1 + 0x158) = *(undefined8 *)(param_1 + 0x150);
      *(undefined8 *)(param_1 + 0x148) = 0;
    }
    *(undefined *)(param_1 + 0x160) = 0;
  }
  return;
}



//void libssh2_sftp_seek(undefined8 param_1,undefined8 param_2)
//
//{
//  libssh2_sftp_seek64(param_1,param_2);
//  return;
//}



undefined8 libssh2_sftp_tell(long param_1)

{
  undefined8 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined8 *)(param_1 + 0x130);
  }
  return uVar1;
}



undefined8 libssh2_sftp_tell64(long param_1)

{
  undefined8 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined8 *)(param_1 + 0x130);
  }
  return uVar1;
}



void FUN_0013b842(long *param_1)

{
  long lVar1;
  long lVar2;
  long local_38;
  long local_30;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  local_38 = _libssh2_list_first(param_1 + 2);
  local_30 = _libssh2_list_first(param_1 + 4);
  while (local_38 != 0) {
    lVar2 = _libssh2_list_next(local_38);
    _libssh2_list_remove(local_38);
    ((void*(*)())(lVar1 + 0x18))
              (*(undefined8 *)(local_38 + 0x20),lVar1,*(undefined8 *)(local_38 + 0x20),lVar1);
    ((void*(*)())(lVar1 + 0x18))(local_38,lVar1,local_38,lVar1);
    local_38 = lVar2;
  }
  while (local_30 != 0) {
    lVar2 = _libssh2_list_next(local_30);
    _libssh2_list_remove(local_30);
    ((void*(*)())(lVar1 + 0x18))(local_30,lVar1,local_30,lVar1);
    local_30 = lVar2;
  }
  return;
}



ulong FUN_0013b936(long param_1)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  undefined8 uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  uint local_4c;
  long local_40;
  undefined *local_38;
  long local_30;
  long *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *(long **)(param_1 + 0x18);
  local_20 = *local_28;
  local_18 = *(long *)(local_20 + 0x60);
  iVar3 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar2 = iVar3 + 0xd;
  local_30 = 0;
  local_4c = 0;
  if (*(int *)(param_1 + 0x168) == 0) {
    uVar4 = ((void*(*)())(local_18 + 8))((ulong)uVar2,local_18,(ulong)uVar2);
    *(undefined8 *)(param_1 + 0x170) = uVar4;
    local_38 = *(undefined **)(param_1 + 0x170);
    if (*(long *)(param_1 + 0x170) == 0) {
      *(undefined4 *)(param_1 + 0x168) = 0;
      local_4c = _libssh2_error(local_18,0xfffffffa,"Unable to allocate memory for FXP_CLOSE packet"
                               );
    }
    else {
      uVar1 = iVar3 + 9;
      _libssh2_store_u32(&local_38,(ulong)uVar1);
      *local_38 = 4;
      iVar3 = *(int *)(local_28 + 1);
      *(int *)(local_28 + 1) = iVar3 + 1;
      *(int *)(param_1 + 0x16c) = iVar3;
      local_38 = local_38 + 1;
      _libssh2_store_u32(&local_38,(ulong)*(uint *)(param_1 + 0x16c));
      _libssh2_store_str(&local_38,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
      *(undefined4 *)(param_1 + 0x168) = 2;
    }
  }
  if (*(int *)(param_1 + 0x168) == 2) {
    local_4c = _libssh2_channel_write(local_20,0,*(undefined8 *)(param_1 + 0x170),(ulong)uVar2);
    if (local_4c == 0xffffffdb) {
      uVar5 = 0xffffffdb;
      goto LAB_0013bd7a;
    }
    if ((ulong)uVar2 == (long)(int)local_4c) {
      *(undefined4 *)(param_1 + 0x168) = 3;
    }
    else {
      *(undefined4 *)(param_1 + 0x168) = 0;
      local_4c = _libssh2_error(local_18,0xfffffff9,"Unable to send FXP_CLOSE command");
    }
    ((void*(*)())(local_18 + 0x18))
              (*(undefined8 *)(param_1 + 0x170),local_18,*(undefined8 *)(param_1 + 0x170),local_18);
    *(undefined8 *)(param_1 + 0x170) = 0;
  }
  if (*(int *)(param_1 + 0x168) == 3) {
    local_4c = FUN_001378de(local_28,0x65,(ulong)*(uint *)(param_1 + 0x16c),&local_30,&local_40,9);
    if (local_4c == 0xffffffdb) {
      uVar5 = 0xffffffdb;
      goto LAB_0013bd7a;
    }
    if (local_4c == 0xffffffda) {
      if (local_40 != 0) {
        ((void*(*)())(local_18 + 0x18))(local_30,local_18,local_30,local_18);
      }
      local_30 = 0;
      _libssh2_error(local_18,0xffffffe1,"Packet too short in FXP_CLOSE command");
    }
    else {
      if (local_4c != 0) {
        _libssh2_error(local_18,(ulong)local_4c,"Error waiting for status message",(ulong)local_4c);
      }
    }
    *(undefined4 *)(param_1 + 0x168) = 4;
  }
  if (local_30 == 0) {
    if (local_4c == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("rc","/home/mantovan/Repositories/libssh2/src/sftp.c",0xa58,"sftp_close_handle")
      ;
    }
  }
  else {
    iVar3 = _libssh2_ntohu32(local_30 + 5);
    ((void*(*)())(local_18 + 0x18))(local_30,local_18,local_30,local_18);
    if (iVar3 != 0) {
      *(int *)(local_28 + 8) = iVar3;
      *(undefined4 *)(param_1 + 0x168) = 0;
      local_4c = _libssh2_error(local_18,0xffffffe1,"SFTP Protocol Error");
    }
  }
  _libssh2_list_remove(param_1);
  if (*(int *)(param_1 + 0x128) == 1) {
    if (*(int *)(param_1 + 0x130) != 0) {
      ((void*(*)())(local_18 + 0x18))
                (*(undefined8 *)(param_1 + 0x138),local_18,*(undefined8 *)(param_1 + 0x138),local_18
                );
    }
  }
  else {
    if ((*(int *)(param_1 + 0x128) == 0) && (*(long *)(param_1 + 0x148) != 0)) {
      ((void*(*)())(local_18 + 0x18))
                (*(undefined8 *)(param_1 + 0x148),local_18,*(undefined8 *)(param_1 + 0x148),local_18
                );
    }
  }
  FUN_001376ba(param_1);
  *(undefined4 *)((long)local_28 + 0x94) = 0;
  *(undefined4 *)(param_1 + 0x168) = 0;
  ((void*(*)())(local_18 + 0x18))(param_1,local_18,param_1,local_18);
  uVar5 = (ulong)local_4c;
LAB_0013bd7a:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong libssh2_sftp_close_handle(long param_1)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013b936(param_1);
      if ((local_14 != 0xffffffdb) ||
         (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket
                           (*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8 FUN_0013be12(long *param_1,undefined8 param_2,undefined8 param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  long lVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  long local_38;
  undefined *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = *param_1;
  local_18 = *(long *)(local_20 + 0x60);
  uVar2 = (int)param_3 + 0xd;
  if (*(int *)((long)param_1 + 0xd4) == 0) {
    lVar4 = ((void*(*)())(local_18 + 8))((ulong)uVar2,local_18,(ulong)uVar2);
    param_1[0x1b] = lVar4;
    local_30 = (undefined *)param_1[0x1b];
    if (param_1[0x1b] == 0) {
      uVar5 = _libssh2_error(local_18,0xfffffffa,"Unable to allocate memory for FXP_REMOVE packet");
      goto LAB_0013c140;
    }
    uVar1 = (int)param_3 + 9;
    _libssh2_store_u32(&local_30,(ulong)uVar1);
    *local_30 = 0xd;
    iVar3 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar3 + 1;
    *(int *)(param_1 + 0x1c) = iVar3;
    local_30 = local_30 + 1;
    _libssh2_store_u32(&local_30,(ulong)*(uint *)(param_1 + 0x1c));
    _libssh2_store_str(&local_30,param_2,param_3);
    *(undefined4 *)((long)param_1 + 0xd4) = 2;
  }
  if (*(int *)((long)param_1 + 0xd4) == 2) {
    iVar3 = _libssh2_channel_write(local_20,0,param_1[0x1b],(ulong)uVar2);
    if (iVar3 == -0x25) {
      uVar5 = 0xffffffdb;
      goto LAB_0013c140;
    }
    if ((ulong)uVar2 != (long)iVar3) {
      ((void*(*)())(local_18 + 0x18))(param_1[0x1b],local_18,param_1[0x1b],local_18);
      param_1[0x1b] = 0;
      *(undefined4 *)((long)param_1 + 0xd4) = 0;
      uVar5 = _libssh2_error(local_18,0xfffffff9,"Unable to send FXP_REMOVE command");
      goto LAB_0013c140;
    }
    ((void*(*)())(local_18 + 0x18))(param_1[0x1b],local_18,param_1[0x1b],local_18);
    param_1[0x1b] = 0;
    *(undefined4 *)((long)param_1 + 0xd4) = 3;
  }
  uVar2 = FUN_001378de(param_1,0x65,(ulong)*(uint *)(param_1 + 0x1c),&local_28,&local_38,9);
  if (uVar2 == 0xffffffdb) {
    uVar5 = 0xffffffdb;
  }
  else {
    if (uVar2 == 0xffffffda) {
      if (local_38 != 0) {
        ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
      }
      uVar5 = _libssh2_error(local_18,0xffffffe1,"SFTP unlink packet too short");
    }
    else {
      if (uVar2 == 0) {
        *(undefined4 *)((long)param_1 + 0xd4) = 0;
        iVar3 = _libssh2_ntohu32(local_28 + 5);
        ((void*(*)())(local_18 + 0x18))(local_28,local_18,local_28,local_18);
        if (iVar3 == 0) {
          uVar5 = 0;
        }
        else {
          *(int *)(param_1 + 8) = iVar3;
          uVar5 = _libssh2_error(local_18,0xffffffe1,"SFTP Protocol Error");
        }
      }
      else {
        *(undefined4 *)((long)param_1 + 0xd4) = 0;
        uVar5 = _libssh2_error(local_18,(ulong)uVar2,"Error waiting for FXP STATUS",(ulong)uVar2);
      }
    }
  }
LAB_0013c140:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong libssh2_sftp_unlink_ex(long *param_1,undefined8 param_2,uint param_3)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013be12(param_1,param_2,(ulong)param_3);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_0013c1e1(long *param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
                  ulong param_6)

{
  uint uVar1;
  undefined *puVar2;
  int iVar3;
  uint uVar4;
  ulong uVar5;
  long lVar6;
  long in_FS_OFFSET;
  uint local_40;
  long local_38;
  long local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  if (*(uint *)((long)param_1 + 0xc) < 5) {
    iVar3 = 0;
  }
  else {
    iVar3 = 4;
  }
  iVar3 = iVar3 + param_3 + param_5;
  uVar4 = iVar3 + 0x11;
  if (*(uint *)((long)param_1 + 0xc) < 2) {
    uVar5 = _libssh2_error(local_20,0xffffffe1,"Server does not support RENAME");
    goto LAB_0013c645;
  }
  if (*(int *)((long)param_1 + 0xe4) == 0) {
    lVar6 = ((void*(*)())(local_20 + 8))((ulong)uVar4,local_20,(ulong)uVar4,local_20);
    param_1[0x1d] = lVar6;
    param_1[0x1e] = param_1[0x1d];
    if (param_1[0x1d] == 0) {
      uVar5 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_RENAME packet");
      goto LAB_0013c645;
    }
    uVar1 = iVar3 + 0xd;
    _libssh2_store_u32(param_1 + 0x1e,(ulong)uVar1);
    puVar2 = (undefined *)param_1[0x1e];
    *(undefined **)(param_1 + 0x1e) = puVar2 + 1;
    *puVar2 = 0x12;
    iVar3 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar3 + 1;
    *(int *)(param_1 + 0x1f) = iVar3;
    _libssh2_store_u32(param_1 + 0x1e,(ulong)*(uint *)(param_1 + 0x1f));
    _libssh2_store_str(param_1 + 0x1e,param_2,(ulong)param_3);
    _libssh2_store_str(param_1 + 0x1e,param_4,(ulong)param_5);
    if (4 < *(uint *)((long)param_1 + 0xc)) {
      _libssh2_store_u32(param_1 + 0x1e,param_6 & 0xffffffff);
    }
    *(undefined4 *)((long)param_1 + 0xe4) = 2;
  }
  if (*(int *)((long)param_1 + 0xe4) == 2) {
    uVar5 = _libssh2_channel_write(local_28,0,param_1[0x1d],param_1[0x1e] - param_1[0x1d]);
    local_18 = uVar5;
    if (uVar5 == 0xffffffffffffffdb) goto LAB_0013c645;
    if (uVar5 != (ulong)uVar4) {
      ((void*(*)())(local_20 + 0x18))(param_1[0x1d],local_20,param_1[0x1d],local_20);
      param_1[0x1d] = 0;
      *(undefined4 *)((long)param_1 + 0xe4) = 0;
      uVar5 = _libssh2_error(local_20,0xfffffff9,"Unable to send FXP_RENAME command");
      goto LAB_0013c645;
    }
    ((void*(*)())(local_20 + 0x18))(param_1[0x1d],local_20,param_1[0x1d],local_20);
    param_1[0x1d] = 0;
    *(undefined4 *)((long)param_1 + 0xe4) = 3;
  }
  iVar3 = FUN_001378de(param_1,0x65,(ulong)*(uint *)(param_1 + 0x1f),&local_30,&local_38,9);
  uVar5 = SEXT48(iVar3);
  local_18 = uVar5;
  if (uVar5 != 0xffffffffffffffdb) {
    if (uVar5 == 0xffffffffffffffda) {
      if (local_38 != 0) {
        ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
      }
      uVar5 = _libssh2_error(local_20,0xffffffe1,"SFTP rename packet too short");
    }
    else {
      if (uVar5 == 0) {
        *(undefined4 *)((long)param_1 + 0xe4) = 0;
        iVar3 = _libssh2_ntohu32(local_30 + 5);
        ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
        *(int *)(param_1 + 8) = iVar3;
        if (iVar3 == 8) {
          local_40 = _libssh2_error(local_20,0xffffffe1,"Operation Not Supported");
        }
        else {
          if (iVar3 == 0xb) {
            local_40 = _libssh2_error(local_20,0xffffffe1,
                                                                            
                                      "File already exists and SSH_FXP_RENAME_OVERWRITE not specified"
                                     );
          }
          else {
            if (iVar3 == 0) {
              local_40 = 0;
            }
            else {
              local_40 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
            }
          }
        }
        uVar5 = (ulong)local_40;
      }
      else {
        *(undefined4 *)((long)param_1 + 0xe4) = 0;
        uVar5 = _libssh2_error(local_20,uVar5 & 0xffffffff,"Error waiting for FXP STATUS",
                               uVar5 & 0xffffffff);
      }
    }
  }
LAB_0013c645:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_sftp_rename_ex
                (long *param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
                undefined8 param_6)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013c1e1(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5,param_6);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_0013c700(long param_1,undefined8 *param_2)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  ulong uVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  ulong local_50;
  undefined *local_48;
  char *local_40;
  undefined *local_38;
  long *local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *(long **)(param_1 + 0x18);
  local_28 = *local_30;
  local_20 = *(long *)(local_28 + 0x60);
  iVar3 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar2 = iVar3 + 0x25;
  if (*(int *)((long)local_30 + 0xfc) == 0) {
    local_48 = (undefined *)((void*(*)())(local_20 + 8))((ulong)uVar2,local_20,(ulong)uVar2);
    local_38 = local_48;
    if (local_48 == (undefined *)0x0) {
      uVar5 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_EXTENDED packet"
                            );
      goto LAB_0013cc1c;
    }
    uVar1 = iVar3 + 0x21;
    _libssh2_store_u32(&local_48,(ulong)uVar1);
    *local_48 = 200;
    iVar3 = *(int *)(local_30 + 1);
    *(int *)(local_30 + 1) = iVar3 + 1;
    *(int *)(local_30 + 0x21) = iVar3;
    local_48 = local_48 + 1;
    _libssh2_store_u32(&local_48,(ulong)*(uint *)(local_30 + 0x21) );
    _libssh2_store_str(&local_48,"fstatvfs@openssh.com",0x14);
    _libssh2_store_str(&local_48,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    *(undefined4 *)((long)local_30 + 0xfc) = 2;
  }
  else {
    local_38 = (undefined *)local_30[0x20];
  }
  if (*(int *)((long)local_30 + 0xfc) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,local_38,(ulong)uVar2);
    if ((local_18 == 0xffffffffffffffdb) ||
       ((-1 < (long)local_18 && ((long)local_18 < (long)(ulong)uVar2)))) {
      *(undefined **)(local_30 + 0x20) = local_38;
      uVar5 = 0xffffffdb;
      goto LAB_0013cc1c;
    }
    ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
    local_30[0x20] = 0;
    if ((long)local_18 < 0) {
      *(undefined4 *)((long)local_30 + 0xfc) = 0;
      uVar5 = _libssh2_error(local_20,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013cc1c;
    }
    *(undefined4 *)((long)local_30 + 0xfc) = 3;
  }
  iVar3 = FUN_001379d5(local_30,2,&DAT_00149c92,(ulong)*(uint *)(local_30 + 0x21),&local_40,
                       &local_50,9);
  uVar5 = SEXT48(iVar3);
  local_18 = uVar5;
  if (uVar5 != 0xffffffffffffffdb) {
    if (uVar5 == 0xffffffffffffffda) {
      if (local_50 != 0) {
        ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
      }
      uVar5 = _libssh2_error(local_20,0xffffffe1,"SFTP rename packet too short");
    }
    else {
      if (uVar5 == 0) {
        if (*local_40 == 'e') {
          uVar4 = _libssh2_ntohu32(local_40 + 5);
          *(undefined4 *)((long)local_30 + 0xfc) = 0;
          ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
          *(undefined4 *)(local_30 + 8) = uVar4;
          uVar5 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
        }
        else {
          if (local_50 < 0x5d) {
            ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
            *(undefined4 *)((long)local_30 + 0xfc) = 0;
            uVar5 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error: short response");
          }
          else {
            *(undefined4 *)((long)local_30 + 0xfc) = 0;
            uVar6 = _libssh2_ntohu64(local_40 + 5);
            *param_2 = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0xd);
            param_2[1] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x15);
            param_2[2] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x1d);
            param_2[3] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x25);
            param_2[4] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x2d);
            param_2[5] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x35);
            param_2[6] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x3d);
            param_2[7] = uVar6;
            uVar6 = _libssh2_ntohu64(local_40 + 0x45);
            param_2[8] = uVar6;
            uVar2 = _libssh2_ntohu64(local_40 + 0x4d);
            uVar6 = _libssh2_ntohu64(local_40 + 0x55);
            param_2[10] = uVar6;
            param_2[9] = (ulong)(uVar2 & 1);
            param_2[9] = (ulong)(uVar2 & 2) | param_2[9];
            ((void*(*)())(local_20 + 0x18))(local_40,local_20,local_40,local_20);
            uVar5 = 0;
          }
        }
      }
      else {
        *(undefined4 *)((long)local_30 + 0xfc) = 0;
        uVar5 = _libssh2_error(local_20,uVar5 & 0xffffffff,"Error waiting for FXP EXTENDED REPLY",
                               uVar5 & 0xffffffff);
      }
    }
  }
LAB_0013cc1c:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_sftp_fstatvfs(long param_1,long param_2)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if ((param_1 == 0) || (param_2 == 0)) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013c700(param_1,param_2);
      if ((local_14 != 0xffffffdb) ||
         (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket
                           (*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_0013ccc6(long *param_1,undefined8 param_2,uint param_3,undefined8 *param_4)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  ulong uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  ulong local_48;
  undefined *local_40;
  char *local_38;
  undefined *local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  uVar1 = param_3 + 0x24;
  if (*(int *)((long)param_1 + 0x10c) == 0) {
    local_40 = (undefined *)((void*(*)())(local_20 + 8))((ulong)uVar1,local_20,(ulong)uVar1);
    local_30 = local_40;
    if (local_40 == (undefined *)0x0) {
      uVar4 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_EXTENDED packet"
                            );
      goto LAB_0013d1c9;
    }
    _libssh2_store_u32(&local_40,(ulong)(param_3 + 0x20));
    *local_40 = 200;
    iVar2 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar2 + 1;
    *(int *)(param_1 + 0x23) = iVar2;
    local_40 = local_40 + 1;
    _libssh2_store_u32(&local_40,(ulong)*(uint *)(param_1 + 0x23));
    _libssh2_store_str(&local_40,"statvfs@openssh.com",0x13);
    _libssh2_store_str(&local_40,param_2,(ulong)param_3);
    *(undefined4 *)((long)param_1 + 0x10c) = 2;
  }
  else {
    local_30 = (undefined *)param_1[0x22];
  }
  if (*(int *)((long)param_1 + 0x10c) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,local_30,(ulong)uVar1);
    if ((local_18 == 0xffffffffffffffdb) ||
       ((-1 < (long)local_18 && ((long)local_18 < (long)(ulong)uVar1)))) {
      *(undefined **)(param_1 + 0x22) = local_30;
      uVar4 = 0xffffffdb;
      goto LAB_0013d1c9;
    }
    ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
    param_1[0x22] = 0;
    if ((long)local_18 < 0) {
      *(undefined4 *)((long)param_1 + 0x10c) = 0;
      uVar4 = _libssh2_error(local_20,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013d1c9;
    }
    *(undefined4 *)((long)param_1 + 0x10c) = 3;
  }
  iVar2 = FUN_001379d5(param_1,2,&DAT_00149c94,(ulong)*(uint *)(param_1 + 0x23),&local_38,&local_48,
                       9);
  uVar4 = SEXT48(iVar2);
  local_18 = uVar4;
  if (uVar4 != 0xffffffffffffffdb) {
    if (uVar4 == 0xffffffffffffffda) {
      if (local_48 != 0) {
        ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
      }
      uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP fstat packet too short");
    }
    else {
      if (uVar4 == 0) {
        if (*local_38 == 'e') {
          uVar3 = _libssh2_ntohu32(local_38 + 5);
          *(undefined4 *)((long)param_1 + 0x10c) = 0;
          ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
          *(undefined4 *)(param_1 + 8) = uVar3;
          uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
        }
        else {
          if (local_48 < 0x5d) {
            ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
            *(undefined4 *)((long)param_1 + 0x10c) = 0;
            uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error: short response");
          }
          else {
            *(undefined4 *)((long)param_1 + 0x10c) = 0;
            uVar5 = _libssh2_ntohu64(local_38 + 5);
            *param_4 = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0xd);
            param_4[1] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x15);
            param_4[2] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x1d);
            param_4[3] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x25);
            param_4[4] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x2d);
            param_4[5] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x35);
            param_4[6] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x3d);
            param_4[7] = uVar5;
            uVar5 = _libssh2_ntohu64(local_38 + 0x45);
            param_4[8] = uVar5;
            uVar1 = _libssh2_ntohu64(local_38 + 0x4d);
            uVar5 = _libssh2_ntohu64(local_38 + 0x55);
            param_4[10] = uVar5;
            param_4[9] = (ulong)(uVar1 & 1);
            param_4[9] = (ulong)(uVar1 & 2) | param_4[9];
            ((void*(*)())(local_20 + 0x18))(local_38,local_20,local_38,local_20);
            uVar4 = 0;
          }
        }
      }
      else {
        *(undefined4 *)((long)param_1 + 0x10c) = 0;
        uVar4 = _libssh2_error(local_20,uVar4 & 0xffffffff,"Error waiting for FXP EXTENDED REPLY",
                               uVar4 & 0xffffffff);
      }
    }
  }
LAB_0013d1c9:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_sftp_statvfs(long *param_1,undefined8 param_2,ulong param_3,long param_4)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if ((param_1 == (long *)0x0) || (param_4 == 0)) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013ccc6(param_1,param_2,param_3 & 0xffffffff,param_4);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8 FUN_0013d27f(long *param_1,undefined8 param_2,uint param_3,ulong param_4)

{
  int iVar1;
  undefined8 uVar2;
  long lVar3;
  uint uVar4;
  long in_FS_OFFSET;
  long local_80;
  undefined *local_78;
  long local_70;
  undefined *local_68;
  long local_60;
  long local_58;
  ulong local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  ulong local_28;
  undefined8 local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_60 = *param_1;
  local_58 = *(long *)(local_60 + 0x60);
  local_48 = 0;
  local_40 = 0;
  local_38 = 0;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  local_18 = 0;
  if (param_4 != 0xffffffffffffffff) {
    local_48 = 4;
    local_28 = param_4 | 0x4000;
  }
  iVar1 = FUN_00136f43(local_48);
  local_50 = (ulong)(param_3 + iVar1 + 0xd);
  if (*(int *)((long)param_1 + 0x11c) == 0) {
    local_78 = (undefined *)((void*(*)())(local_58 + 8))(local_50,local_58,local_50);
    local_68 = local_78;
    if (local_78 == (undefined *)0x0) {
      uVar2 = _libssh2_error(local_58,0xfffffffa,"Unable to allocate memory for FXP_MKDIR packet");
      goto LAB_0013d66b;
    }
    uVar4 = (int)local_50 - 4;
    _libssh2_store_u32(&local_78,(ulong)uVar4);
    *local_78 = 0xe;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x25) = iVar1;
    local_78 = local_78 + 1;
    _libssh2_store_u32(&local_78,(ulong)*(uint *)(param_1 + 0x25));
    _libssh2_store_str(&local_78,param_2,(ulong)param_3);
    lVar3 = FUN_00137b5d(local_78,&local_48);
    local_78 = local_78 + lVar3;
    *(undefined4 *)((long)param_1 + 0x11c) = 2;
  }
  else {
    local_68 = (undefined *)param_1[0x24];
  }
  if (*(int *)((long)param_1 + 0x11c) == 2) {
    iVar1 = _libssh2_channel_write(local_60,0,local_68,local_50);
    if (iVar1 == -0x25) {
      *(undefined **)(param_1 + 0x24) = local_68;
      uVar2 = 0xffffffdb;
      goto LAB_0013d66b;
    }
    if (local_50 != (long)iVar1) {
      ((void*(*)())(local_58 + 0x18))(local_68,local_58,local_68,local_58);
      *(undefined4 *)((long)param_1 + 0x11c) = 0;
      uVar2 = _libssh2_error(local_58,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013d66b;
    }
    ((void*(*)())(local_58 + 0x18))(local_68,local_58,local_68,local_58);
    *(undefined4 *)((long)param_1 + 0x11c) = 3;
    param_1[0x24] = 0;
  }
  uVar4 = FUN_001378de(param_1,0x65,(ulong)*(uint *)(param_1 + 0x25),&local_70,&local_80,9);
  if (uVar4 == 0xffffffdb) {
    uVar2 = 0xffffffdb;
  }
  else {
    if (uVar4 == 0xffffffda) {
      if (local_80 != 0) {
        ((void*(*)())(local_58 + 0x18))(local_70,local_58,local_70,local_58);
      }
      uVar2 = _libssh2_error(local_58,0xffffffe1,"SFTP mkdir packet too short");
    }
    else {
      if (uVar4 == 0) {
        *(undefined4 *)((long)param_1 + 0x11c) = 0;
        iVar1 = _libssh2_ntohu32(local_70 + 5);
        ((void*(*)())(local_58 + 0x18))(local_70,local_58,local_70,local_58);
        if (iVar1 == 0) {
          uVar2 = 0;
        }
        else {
          *(int *)(param_1 + 8) = iVar1;
          uVar2 = _libssh2_error(local_58,0xffffffe1,"SFTP Protocol Error");
        }
      }
      else {
        *(undefined4 *)((long)param_1 + 0x11c) = 0;
        uVar2 = _libssh2_error(local_58,(ulong)uVar4,"Error waiting for FXP STATUS",(ulong)uVar4);
      }
    }
  }
LAB_0013d66b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong libssh2_sftp_mkdir_ex(long *param_1,undefined8 param_2,uint param_3,undefined8 param_4)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013d27f(param_1,param_2,(ulong)param_3,param_4);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8 FUN_0013d711(long *param_1,undefined8 param_2,uint param_3)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  uint uVar4;
  long in_FS_OFFSET;
  long local_40;
  undefined *local_38;
  long local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  local_18 = (ulong)(param_3 + 0xd);
  if (*(int *)((long)param_1 + 300) == 0) {
    lVar2 = ((void*(*)())(local_20 + 8))(local_18,local_20,local_18);
    param_1[0x26] = lVar2;
    local_38 = (undefined *)param_1[0x26];
    if (param_1[0x26] == 0) {
      uVar3 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_RMDIR packet");
      goto LAB_0013da40;
    }
    uVar4 = (int)local_18 - 4;
    _libssh2_store_u32(&local_38,(ulong)uVar4);
    *local_38 = 0xf;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x27) = iVar1;
    local_38 = local_38 + 1;
    _libssh2_store_u32(&local_38,(ulong)*(uint *)(param_1 + 0x27));
    _libssh2_store_str(&local_38,param_2,(ulong)param_3);
    *(undefined4 *)((long)param_1 + 300) = 2;
  }
  if (*(int *)((long)param_1 + 300) == 2) {
    iVar1 = _libssh2_channel_write(local_28,0,param_1[0x26],local_18);
    if (iVar1 == -0x25) {
      uVar3 = 0xffffffdb;
      goto LAB_0013da40;
    }
    if (local_18 != (long)iVar1) {
      ((void*(*)())(local_20 + 0x18))(param_1[0x26],local_20,param_1[0x26],local_20);
      param_1[0x26] = 0;
      *(undefined4 *)((long)param_1 + 300) = 0;
      uVar3 = _libssh2_error(local_20,0xfffffff9,"Unable to send FXP_RMDIR command");
      goto LAB_0013da40;
    }
    ((void*(*)())(local_20 + 0x18))(param_1[0x26],local_20,param_1[0x26],local_20);
    param_1[0x26] = 0;
    *(undefined4 *)((long)param_1 + 300) = 3;
  }
  uVar4 = FUN_001378de(param_1,0x65,(ulong)*(uint *)(param_1 + 0x27),&local_30,&local_40,9);
  if (uVar4 == 0xffffffdb) {
    uVar3 = 0xffffffdb;
  }
  else {
    if (uVar4 == 0xffffffda) {
      if (local_40 != 0) {
        ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
      }
      uVar3 = _libssh2_error(local_20,0xffffffe1,"SFTP rmdir packet too short");
    }
    else {
      if (uVar4 == 0) {
        *(undefined4 *)((long)param_1 + 300) = 0;
        iVar1 = _libssh2_ntohu32(local_30 + 5);
        ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
        if (iVar1 == 0) {
          uVar3 = 0;
        }
        else {
          *(int *)(param_1 + 8) = iVar1;
          uVar3 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
        }
      }
      else {
        *(undefined4 *)((long)param_1 + 300) = 0;
        uVar3 = _libssh2_error(local_20,(ulong)uVar4,"Error waiting for FXP STATUS",(ulong)uVar4);
      }
    }
  }
LAB_0013da40:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



ulong libssh2_sftp_rmdir_ex(long *param_1,undefined8 param_2,uint param_3)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013d711(param_1,param_2,(ulong)param_3);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8
FUN_0013dae1(long *param_1,undefined8 param_2,uint param_3,int param_4,undefined8 *param_5)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  uint uVar4;
  long in_FS_OFFSET;
  long local_40;
  undefined *local_38;
  char *local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  if (param_4 == 2) {
    iVar1 = FUN_00136f43(*param_5);
  }
  else {
    iVar1 = 0;
  }
  local_18 = (ulong)(param_3 + iVar1 + 0xd);
  if (*(int *)((long)param_1 + 0x13c) == 0) {
    lVar2 = ((void*(*)())(local_20 + 8))(local_18,local_20,local_18);
    param_1[0x28] = lVar2;
    local_38 = (undefined *)param_1[0x28];
    if (param_1[0x28] == 0) {
      uVar3 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_*STAT packet");
      goto LAB_0013df51;
    }
    uVar4 = (int)local_18 - 4;
    _libssh2_store_u32(&local_38,(ulong)uVar4);
    if (param_4 == 1) {
      *local_38 = 7;
    }
    else {
      if (param_4 == 2) {
        *local_38 = 9;
      }
      else {
        *local_38 = 0x11;
      }
    }
    local_38 = local_38 + 1;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x29) = iVar1;
    _libssh2_store_u32(&local_38,(ulong)*(uint *)(param_1 + 0x29));
    _libssh2_store_str(&local_38,param_2,(ulong)param_3);
    if (param_4 == 2) {
      lVar2 = FUN_00137b5d(local_38,param_5);
      local_38 = local_38 + lVar2;
    }
    *(undefined4 *)((long)param_1 + 0x13c) = 2;
  }
  if (*(int *)((long)param_1 + 0x13c) == 2) {
    iVar1 = _libssh2_channel_write(local_28,0,param_1[0x28],local_18);
    if (iVar1 == -0x25) {
      uVar3 = 0xffffffdb;
      goto LAB_0013df51;
    }
    if (local_18 != (long)iVar1) {
      ((void*(*)())(local_20 + 0x18))(param_1[0x28],local_20,param_1[0x28],local_20);
      param_1[0x28] = 0;
      *(undefined4 *)((long)param_1 + 0x13c) = 0;
      uVar3 = _libssh2_error(local_20,0xfffffff9,"Unable to send STAT/LSTAT/SETSTAT command");
      goto LAB_0013df51;
    }
    ((void*(*)())(local_20 + 0x18))(param_1[0x28],local_20,param_1[0x28],local_20);
    param_1[0x28] = 0;
    *(undefined4 *)((long)param_1 + 0x13c) = 3;
  }
  uVar4 = FUN_001379d5(param_1,2,&DAT_00149c96,(ulong)*(uint *)(param_1 + 0x29),&local_30,&local_40,
                       9);
  if (uVar4 == 0xffffffdb) {
    uVar3 = 0xffffffdb;
  }
  else {
    if (uVar4 == 0xffffffda) {
      if (local_40 != 0) {
        ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
      }
      uVar3 = _libssh2_error(local_20,0xffffffe1,"SFTP stat packet too short");
    }
    else {
      if (uVar4 == 0) {
        *(undefined4 *)((long)param_1 + 0x13c) = 0;
        if (*local_30 == 'e') {
          iVar1 = _libssh2_ntohu32(local_30 + 5);
          ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
          if (iVar1 == 0) {
            memset(param_5,0,0x38);
            uVar3 = 0;
          }
          else {
            *(int *)(param_1 + 8) = iVar1;
            uVar3 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
          }
        }
        else {
          memset(param_5,0,0x38);
          iVar1 = FUN_00137cb9(param_5,local_30 + 5,local_40 + -5);
          if (iVar1 < 0) {
            ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
            uVar3 = _libssh2_error(local_20,0xffffffe1,"Attributes too short in SFTP fstat");
          }
          else {
            ((void*(*)())(local_20 + 0x18))(local_30,local_20,local_30,local_20);
            uVar3 = 0;
          }
        }
      }
      else {
        *(undefined4 *)((long)param_1 + 0x13c) = 0;
        uVar3 = _libssh2_error(local_20,(ulong)uVar4,"Timeout waiting for status message",
                               (ulong)uVar4);
      }
    }
  }
LAB_0013df51:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



ulong libssh2_sftp_stat_ex
                (long *param_1,undefined8 param_2,uint param_3,uint param_4,undefined8 param_5)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013dae1(param_1,param_2,(ulong)param_3,(ulong)param_4,param_5);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong FUN_0013e000(long *param_1,undefined8 param_2,uint param_3,void *param_4,uint param_5,
                  int param_6)

{
  int iVar1;
  ulong uVar2;
  long lVar3;
  uint uVar4;
  long in_FS_OFFSET;
  uint local_54;
  ulong local_50;
  undefined *local_48;
  char *local_40;
  long local_38;
  long local_30;
  ulong local_28;
  ulong local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = *param_1;
  local_30 = *(long *)(local_38 + 0x60);
  if (param_6 == 0) {
    iVar1 = param_5 + 4;
  }
  else {
    iVar1 = 0;
  }
  local_28 = (ulong)(param_3 + iVar1 + 0xd);
  if ((*(uint *)((long)param_1 + 0xc) < 3) && (param_6 != 2)) {
    uVar2 = _libssh2_error(local_30,0xffffffe1,"Server does not support SYMLINK or READLINK");
    goto LAB_0013e4f2;
  }
  if (*(int *)((long)param_1 + 0x14c) == 0) {
    lVar3 = ((void*(*)())(local_30 + 8))(local_28,local_30,local_28);
    param_1[0x2a] = lVar3;
    local_48 = (undefined *)param_1[0x2a];
    if (param_1[0x2a] == 0) {
      uVar2 = _libssh2_error(local_30,0xfffffffa,
                             "Unable to allocate memory for SYMLINK/READLINK/REALPATH packet");
      goto LAB_0013e4f2;
    }
    uVar4 = (int)local_28 - 4;
    _libssh2_store_u32(&local_48,(ulong)uVar4);
    if (param_6 == 0) {
      *local_48 = 0x14;
    }
    else {
      if (param_6 == 2) {
        *local_48 = 0x10;
      }
      else {
        *local_48 = 0x13;
      }
    }
    local_48 = local_48 + 1;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x2b) = iVar1;
    _libssh2_store_u32(&local_48,(ulong)*(uint *)(param_1 + 0x2b));
    _libssh2_store_str(&local_48,param_2,(ulong)param_3);
    if (param_6 == 0) {
      _libssh2_store_str(&local_48,param_4,(ulong)param_5);
    }
    *(undefined4 *)((long)param_1 + 0x14c) = 2;
  }
  if (*(int *)((long)param_1 + 0x14c) == 2) {
    uVar2 = _libssh2_channel_write(local_38,0,param_1[0x2a],local_28);
    local_20 = uVar2;
    if (uVar2 == 0xffffffffffffffdb) goto LAB_0013e4f2;
    if (local_28 != uVar2) {
      ((void*(*)())(local_30 + 0x18))(param_1[0x2a],local_30,param_1[0x2a],local_30);
      param_1[0x2a] = 0;
      *(undefined4 *)((long)param_1 + 0x14c) = 0;
      uVar2 = _libssh2_error(local_30,0xfffffff9,"Unable to send SYMLINK/READLINK command");
      goto LAB_0013e4f2;
    }
    ((void*(*)())(local_30 + 0x18))(param_1[0x2a],local_30,param_1[0x2a],local_30);
    param_1[0x2a] = 0;
    *(undefined4 *)((long)param_1 + 0x14c) = 3;
  }
  uVar4 = FUN_001379d5(param_1,2,&DAT_00149c98,(ulong)*(uint *)(param_1 + 0x2b),&local_40,&local_50,
                       9);
  if (uVar4 == 0xffffffdb) {
    uVar2 = 0xffffffdb;
  }
  else {
    if (uVar4 == 0xffffffda) {
      if (local_50 != 0) {
        ((void*(*)())(local_30 + 0x18))(local_40,local_30,local_40,local_30);
      }
      uVar2 = _libssh2_error(local_30,0xffffffe1,"SFTP symlink packet too short");
    }
    else {
      if (uVar4 == 0) {
        *(undefined4 *)((long)param_1 + 0x14c) = 0;
        if (*local_40 == 'e') {
          iVar1 = _libssh2_ntohu32(local_40 + 5);
          ((void*(*)())(local_30 + 0x18))(local_40,local_30,local_40,local_30);
          if (iVar1 == 0) {
            uVar2 = 0;
          }
          else {
            *(int *)(param_1 + 8) = iVar1;
            uVar2 = _libssh2_error(local_30,0xffffffe1,"SFTP Protocol Error");
          }
        }
        else {
          iVar1 = _libssh2_ntohu32(local_40 + 5);
          if (iVar1 == 0) {
            ((void*(*)())(local_30 + 0x18))(local_40,local_30,local_40,local_30);
            uVar2 = _libssh2_error(local_30,0xffffffe1,
                                   "Invalid READLINK/REALPATH response, no name entries");
          }
          else {
            if (local_50 < 0xd) {
              if (local_50 != 0) {
                ((void*(*)())(local_30 + 0x18))(local_40,local_30,local_40,local_30);
              }
              uVar2 = _libssh2_error(local_30,0xffffffe1,"SFTP stat packet too short");
            }
            else {
              uVar4 = _libssh2_ntohu32(local_40 + 9);
              local_18 = (ulong)uVar4;
              if (local_18 < param_5) {
                memcpy(param_4,local_40 + 0xd,local_18);
                *(undefined *)(local_18 + (long)param_4) = 0;
                local_54 = (uint)local_18;
              }
              else {
                local_54 = 0xffffffda;
              }
              ((void*(*)())(local_30 + 0x18))(local_40,local_30,local_40,local_30);
              uVar2 = (ulong)local_54;
            }
          }
        }
      }
      else {
        *(undefined4 *)((long)param_1 + 0x14c) = 0;
        uVar2 = _libssh2_error(local_30,(ulong)uVar4,"Error waiting for status message",(ulong)uVar4
                              );
      }
    }
  }
LAB_0013e4f2:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong libssh2_sftp_symlink_ex
                (long *param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
                uint param_6)

{
  ulong uVar1;
  time_t tVar2;
  uint local_14;
  
  if (param_1 == (long *)0x0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      local_14 = FUN_0013e000(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5,(ulong)param_6);
      if ((local_14 != 0xffffffdb) || (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



ulong libssh2_sftp_last_error(long param_1)

{
  ulong uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (ulong)*(uint *)(param_1 + 0x40);
  }
  return uVar1;
}



undefined8 libssh2_sftp_get_channel(undefined8 *param_1)

{
  undefined8 uVar1;
  
  if (param_1 == (undefined8 *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *param_1;
  }
  return uVar1;
}



undefined8 FUN_0013e5ed(long param_1,void *param_2,void *param_3,int param_4)

{
  int iVar1;
  int iVar2;
  int local_34;
  void *local_30;
  void *local_28;
  
  iVar1 = *(int *)(*(long *)(param_1 + 0x128) + 0x10);
  local_34 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  if (param_4 % iVar1 != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("(len % blocksize) == 0","/home/mantovan/Repositories/libssh2/src/transport.c",
                  0x8b,"decrypt");
  }
  while( 1 ) {
    if (local_34 < iVar1) {
      return 0;
    }
    iVar2 = ((void*(*)())(*(long *)(param_1 + 0x128) + 0x30))
                      (param_1,local_28,(long)iVar1,param_1 + 0x130);
    if (iVar2 != 0) break;
    memcpy(local_30,local_28,(long)iVar1);
    local_34 = local_34 - iVar1;
    local_30 = (void *)((long)local_30 + (long)iVar1);
    local_28 = (void *)((long)local_28 + (long)iVar1);
  }
  ((void*(*)())(param_1 + 0x18))
            (*(undefined8 *)(param_1 + 0x4278),param_1,*(undefined8 *)(param_1 + 0x4278),param_1);
  return 0xfffffff4;
}



ulong FUN_0013e6eb(long param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  undefined8 local_70;
  undefined8 local_68;
  long local_60;
  undefined local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_60 = param_1 + 0x248;
  if (*(int *)(param_1 + 0xd380) == 0) {
    *(undefined4 *)(param_1 + 0xd384) = 0;
    *(ulong *)(param_1 + 0xd388) = (ulong)(*(int *)(param_1 + 0x4260) - 1);
    if (param_2 != 0) {
      ((void*(*)())(*(long *)(param_1 + 0x138) + 0x18))
                (param_1,local_58,(ulong)*(uint *)(param_1 + 0x140),param_1 + 0x4248,5,
                 *(undefined8 *)(param_1 + 0x4278),*(ulong *)(param_1 + 0xd388) & 0xffffffff,
                 param_1 + 0x148);
      iVar2 = memcmp(local_58,(void *)(*(long *)(local_60 + 0x4030) + *(long *)(param_1 + 0xd388)),
                     (long)*(int *)(*(long *)(param_1 + 0x138) + 8));
      if (iVar2 != 0) {
        *(undefined4 *)(param_1 + 0xd384) = 0xffffffff;
      }
    }
    *(int *)(param_1 + 0x140) = *(int *)(param_1 + 0x140) + 1;
    *(long *)(param_1 + 0xd388) = *(long *)(param_1 + 0xd388) - (ulong)*(byte *)(local_60 + 0x401c);
    if (((*(long *)(param_1 + 0x1c0) == 0) || (*(int *)(*(long *)(param_1 + 0x1c0) + 8) == 0)) ||
       (((*(uint *)(param_1 + 0x68) & 4) == 0 && (*(int *)(*(long *)(param_1 + 0x1c0) + 0xc) == 0)))
       ) {
      bVar1 = 0;
    }
    else {
      bVar1 = 1;
    }
    if ((bVar1) && (*(long *)(param_1 + 0x158) != 0)) {
      uVar3 = ((void*(*)())(*(long *)(param_1 + 0x150) + 0x20))
                        (param_1,&local_70,&local_68,40000,*(undefined8 *)(local_60 + 0x4030),
                         *(undefined8 *)(param_1 + 0xd388),param_1 + 0x158);
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(local_60 + 0x4030),param_1,*(undefined8 *)(local_60 + 0x4030),
                 param_1);
      if (uVar3 != 0) {
        uVar4 = (ulong)uVar3;
        goto LAB_0013e9fa;
      }
      *(undefined8 *)(local_60 + 0x4030) = local_70;
      *(undefined8 *)(param_1 + 0xd388) = local_68;
    }
    *(uint *)(param_1 + 0xd390) = (uint)**(byte **)(local_60 + 0x4030);
    *(undefined4 *)(param_1 + 0xd380) = 2;
  }
  if (*(int *)(param_1 + 0xd380) == 2) {
    uVar3 = _libssh2_packet_add(param_1,*(undefined8 *)(local_60 + 0x4030),
                                *(undefined8 *)(param_1 + 0xd388),(ulong)*(uint *)(param_1 + 0xd384)
                               );
    if (uVar3 == 0xffffffdb) {
      uVar4 = 0xffffffdb;
      goto LAB_0013e9fa;
    }
    if (uVar3 != 0) {
      *(undefined4 *)(param_1 + 0xd380) = 0;
      uVar4 = (ulong)uVar3;
      goto LAB_0013e9fa;
    }
  }
  *(undefined4 *)(param_1 + 0xd380) = 0;
  uVar4 = (ulong)*(uint *)(param_1 + 0xd390);
LAB_0013e9fa:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong _libssh2_transport_read(long param_1)

{
  uint uVar1;
  undefined4 uVar2;
  void *__dest;
  ulong uVar3;
  long lVar4;
  int iVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  int local_74;
  int local_70;
  int local_6c;
  uint local_68;
  uint local_64;
  undefined local_38 [4];
  undefined local_34;
  undefined auStack51 [35];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __dest = (void *)(param_1 + 0x248);
  local_64 = 1;
  *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffe;
  if (((*(uint *)(param_1 + 0x68) & 1) != 0) && ((*(uint *)(param_1 + 0x68) & 8) == 0)) {
    uVar1 = _libssh2_kex_exchange(param_1,1,param_1 + 0xccd0);
    if (uVar1 != 0) {
      uVar3 = (ulong)uVar1;
      goto LAB_0013f23d;
    }
  }
  if (*(int *)(param_1 + 0xd088) == 0xb) {
    *(undefined4 *)(param_1 + 0xd088) = 0;
    local_64 = *(uint *)(param_1 + 0xd08c);
  }
  else {
    do {
      if (*(int *)(param_1 + 0x22c) == -1) {
        uVar3 = 0;
        goto LAB_0013f23d;
      }
      if ((*(uint *)(param_1 + 0x68) & 2) == 0) {
        local_64 = 0;
        local_68 = 5;
      }
      else {
        local_68 = *(uint *)(*(long *)(param_1 + 0x128) + 0x10);
      }
      local_74 = (int)*(undefined8 *)(param_1 + 0x4250) - (int)*(undefined8 *)(param_1 + 0x4258);
      if (local_74 < 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("remainbuf >= 0","/home/mantovan/Repositories/libssh2/src/transport.c",0x15d,
                      "_libssh2_transport_read");
      }
      if (local_74 < (int)local_68) {
        if (local_74 == 0) {
          *(undefined8 *)(param_1 + 0x4250) = 0;
          *(undefined8 *)(param_1 + 0x4258) = *(undefined8 *)(param_1 + 0x4250);
        }
        else {
          memmove(__dest,(void *)(*(long *)(param_1 + 0x4258) + (long)__dest),(long)local_74);
          *(undefined8 *)(param_1 + 0x4258) = 0;
          *(long *)(param_1 + 0x4250) = (long)local_74;
        }
        if (*(int *)(param_1 + 0x6c) == 0) {
          uVar6 = 0x4000;
        }
        else {
          uVar6 = 0;
        }
        lVar4 = ((void*(*)())(param_1 + 0x50))
                          ((ulong)*(uint *)(param_1 + 0x228),(long)local_74 + (long)__dest,
                           (long)(0x4000 - local_74),uVar6,param_1);
        if (lVar4 < 1) {
          if ((lVar4 < 0) && (lVar4 == -0xb)) {
            *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 1;
            uVar3 = 0xffffffdb;
          }
          else {
            uVar3 = 0xffffffd5;
          }
          goto LAB_0013f23d;
        }
        *(long *)(param_1 + 0x4250) = *(long *)(param_1 + 0x4250) + lVar4;
        local_74 = (int)*(undefined8 *)(param_1 + 0x4250) - (int)*(undefined8 *)(param_1 + 0x4258);
      }
      local_70 = local_74;
      if (*(long *)(param_1 + 0x4270) == 0) {
        if (local_74 < (int)local_68) {
          *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 1;
          uVar3 = 0xffffffdb;
          goto LAB_0013f23d;
        }
        if (local_64 == 0) {
          memcpy(local_38,(void *)(*(long *)(param_1 + 0x4258) + (long)__dest),(long)(int)local_68);
        }
        else {
          uVar1 = FUN_0013e5ed(param_1,*(long *)(param_1 + 0x4258) + (long)__dest,local_38,
                               (ulong)local_68);
          if (uVar1 != 0) {
            uVar3 = (ulong)uVar1;
            goto LAB_0013f23d;
          }
          memcpy((void *)(param_1 + 0x4248),local_38,5);
        }
        *(long *)(param_1 + 0x4258) = *(long *)(param_1 + 0x4258) + (long)(int)local_68;
        uVar2 = _libssh2_ntohu32(local_38);
        *(undefined4 *)(param_1 + 0x4260) = uVar2;
        if (*(int *)(param_1 + 0x4260) == 0) {
          uVar3 = 0xfffffff4;
          goto LAB_0013f23d;
        }
        if (40000 < *(uint *)(param_1 + 0x4260)) {
          uVar3 = 0xffffffd7;
          goto LAB_0013f23d;
        }
        *(undefined *)(param_1 + 0x4264) = local_34;
        if (*(int *)(param_1 + 0x4260) - 1U < (uint)*(byte *)(param_1 + 0x4264)) {
          uVar3 = 0xfffffff4;
          goto LAB_0013f23d;
        }
        if (local_64 == 0) {
          iVar5 = 0;
        }
        else {
          iVar5 = *(int *)(*(long *)(param_1 + 0x138) + 8);
        }
        uVar1 = (iVar5 + *(int *)(param_1 + 0x4260)) - 1;
        if ((40000 < uVar1) || (uVar1 == 0)) {
          uVar3 = 0xffffffd7;
          goto LAB_0013f23d;
        }
        uVar6 = ((void*(*)())(param_1 + 8))((ulong)uVar1,param_1);
        *(undefined8 *)(param_1 + 0x4278) = uVar6;
        if (*(long *)(param_1 + 0x4278) == 0) {
          uVar3 = 0xfffffffa;
          goto LAB_0013f23d;
        }
        *(ulong *)(param_1 + 0x4270) = (ulong)uVar1;
        *(undefined8 *)(param_1 + 0x4280) = *(undefined8 *)(param_1 + 0x4278);
        if (5 < (int)local_68) {
          if ((int)uVar1 < (int)(local_68 - 5)) {
            uVar3 = 0xffffffd7;
            goto LAB_0013f23d;
          }
          memcpy(*(void **)(param_1 + 0x4280),auStack51,(long)(int)(local_68 - 5));
          *(long *)(param_1 + 0x4280) = (long)(int)local_68 + -5 + *(long *)(param_1 + 0x4280);
        }
        *(long *)(param_1 + 17000) = *(long *)(param_1 + 0x4280) - *(long *)(param_1 + 0x4278);
        local_70 = local_74 - local_68;
      }
      iVar5 = (int)*(undefined8 *)(param_1 + 0x4270) - (int)*(undefined8 *)(param_1 + 17000);
      if (iVar5 < local_70) {
        local_70 = iVar5;
      }
      if (local_64 == 0) {
        local_6c = 0;
      }
      else {
        iVar5 = *(int *)(*(long *)(param_1 + 0x138) + 8);
        if ((ulong)(*(long *)(param_1 + 0x4270) - (long)iVar5) <
            (ulong)(*(long *)(param_1 + 17000) + (long)local_70)) {
          local_6c = ((int)*(undefined8 *)(param_1 + 0x4270) - iVar5) -
                     (int)*(undefined8 *)(param_1 + 17000);
        }
        else {
          local_6c = local_70;
          if (local_70 % local_68 != 0) {
            local_6c = local_70 - local_70 % local_68;
            local_70 = 0;
          }
        }
      }
      if (0 < local_6c) {

        if (uVar1 != 0) {
          *(undefined8 *)(param_1 + 0x4270) = 0;
          uVar3 = (ulong)uVar1;
          goto LAB_0013f23d;
        }
        *(long *)(param_1 + 0x4258) = *(long *)(param_1 + 0x4258) + (long)local_6c;
        *(long *)(param_1 + 0x4280) = *(long *)(param_1 + 0x4280) + (long)local_6c;
        *(long *)(param_1 + 17000) = *(long *)(param_1 + 17000) + (long)local_6c;
        local_70 = local_70 - local_6c;
      }
      if (0 < local_70) {
        if ((int)*(undefined8 *)(param_1 + 0x4270) -
            ((int)*(undefined8 *)(param_1 + 0x4280) - (int)*(undefined8 *)(param_1 + 0x4278)) <
            local_70) {
          uVar3 = 0xffffffd7;
          goto LAB_0013f23d;
        }
        memcpy(*(void **)(param_1 + 0x4280),(void *)(*(long *)(param_1 + 0x4258) + (long)__dest),
               (long)local_70);
        *(long *)(param_1 + 0x4258) = *(long *)(param_1 + 0x4258) + (long)local_70;
        *(long *)(param_1 + 0x4280) = *(long *)(param_1 + 0x4280) + (long)local_70;
        *(long *)(param_1 + 17000) = *(long *)(param_1 + 17000) + (long)local_70;
      }
    } while ((int)*(undefined8 *)(param_1 + 0x4270) != (int)*(undefined8 *)(param_1 + 17000));
  }
  uVar1 = FUN_0013e6eb(param_1,(ulong)local_64);
  if (uVar1 == 0xffffffdb) {
    if (*(int *)(param_1 + 0xd2b0) != 0) {
      *(uint *)(param_1 + 0xd08c) = local_64;
      *(undefined4 *)(param_1 + 0xd088) = 0xb;
    }
    uVar3 = 0xffffffdb;
  }
  else {
    *(undefined8 *)(param_1 + 0x4270) = 0;
    uVar3 = (ulong)uVar1;
  }
LAB_0013f23d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8 FUN_0013f253(long param_1,long param_2,long param_3,undefined8 *param_4)

{
  undefined8 uVar1;
  long lVar2;
  long lVar3;
  
  if (*(long *)(param_1 + 0xcb50) == 0) {
    *param_4 = 0;
    uVar1 = 0;
  }
  else {
    if ((param_2 == *(long *)(param_1 + 0xcb48)) && (param_3 == *(long *)(param_1 + 0xcb50))) {
      *param_4 = 1;
      lVar3 = (long)*(int *)(param_1 + 0xcb40) - *(long *)(param_1 + 0xcb58);
      if (*(int *)(param_1 + 0x6c) == 0) {
        uVar1 = 0x4000;
      }
      else {
        uVar1 = 0;
      }
      lVar2 = ((void*(*)())(param_1 + 0x48))
                        ((ulong)*(uint *)(param_1 + 0x228),
                         *(long *)(param_1 + 0xcb58) + param_1 + 0x4288,lVar3,uVar1,param_1);
      if (lVar2 == lVar3) {
        *(undefined4 *)(param_1 + 0xcb40) = 0;
        *(undefined8 *)(param_1 + 0xcb50) = 0;
        uVar1 = 0;
      }
      else {
        if (lVar2 < 0) {
          if (lVar2 == -0xb) {
            *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 2;
            uVar1 = 0xffffffdb;
          }
          else {
            uVar1 = 0xfffffff9;
          }
        }
        else {
          *(long *)(param_1 + 0xcb58) = *(long *)(param_1 + 0xcb58) + lVar2;
          if (lVar2 < lVar3) {
            uVar1 = 0xffffffdb;
          }
          else {
            uVar1 = 0;
          }
        }
      }
    }
    else {
      uVar1 = 0xffffffd9;
    }
  }
  return uVar1;
}



ulong _libssh2_transport_send (long param_1,void *param_2,size_t param_3,void *param_4,size_t param_5)
{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  long lVar5;
  ulong uVar6;
  undefined8 uVar7;
  long in_FS_OFFSET;
  long local_90;
  int local_70;
  uint local_6c;
  long local_58;
  long local_50;
  long local_48;
  ulong local_40;
  long local_38;
  void *local_30;
  size_t local_28;
  ulong local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((*(uint *)(param_1 + 0x68) & 2) == 0) {
    iVar3 = 8;
  }
  else {
    iVar3 = *(int *)(*(long *)(param_1 + 0x198) + 0x10);
  }
  local_38 = param_1 + 0x248;
  local_30 = param_2;
  local_28 = param_3;
  if (((*(uint *)(param_1 + 0x68) & 1) != 0) && ((*(uint *)(param_1 + 0x68) & 8) == 0)) {
    uVar2 = _libssh2_kex_exchange(param_1,1,param_1 + 0xccd0);
    if (uVar2 != 0) {
      uVar6 = (ulong)uVar2;
      goto LAB_0013f9da;
    }
  }
  uVar2 = FUN_0013f253(param_1,param_2,param_3,&local_58);
  if (uVar2 == 0) {
    *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffd;
    if (local_58 == 0) {
      uVar2 = *(int *)(param_1 + 0x68) >> 1 & 1;
      if (((*(long *)(param_1 + 0x1c0) == 0) || (*(int *)(*(long *)(param_1 + 0x1c0) + 8) == 0)) ||
         (((*(uint *)(param_1 + 0x68) & 4) == 0 && (*(int *)(*(long *)(param_1 + 0x1c0) + 0xc) == 0)
          ))) {
        bVar1 = 0;
      }
      else {
        bVar1 = 1;
      }
      if (((uVar2 == 0) || (!bVar1)) || (*(long *)(param_1 + 0x1c8) == 0)) {
        if (0x87b7 < param_5 + param_3) {
          uVar6 = 0xffffffde;
          goto LAB_0013f9da;
        }
        memcpy((void *)(local_38 + 0x4045),param_2,param_3);
        if ((param_4 != (void *)0x0) && (param_5 != 0)) {
          memcpy((void *)(param_3 + 0x4045 + local_38),param_4,param_5);
        }
        local_90 = param_3 + param_5;
      }
      else {
        local_50 = 0x87b3;
        local_48 = 0x87b3;
        local_6c = ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x18))
                             (param_1,local_38 + 0x4045,&local_50,param_2,param_3,param_1 + 0x1c8);
        if (local_6c != 0) {
          uVar6 = (ulong)local_6c;
          goto LAB_0013f9da;
        }
        if ((param_4 == (void *)0x0) || (param_5 == 0)) {
          local_48 = 0;
        }
        else {
          local_48 = local_48 - local_50;
          local_6c = ((void*(*)())(*(long *)(param_1 + 0x1c0) + 0x18))
                               (param_1,local_50 + 0x4045 + local_38,&local_48,param_4,param_5,
                                param_1 + 0x1c8);
        }
        if (local_6c != 0) {
          uVar6 = (ulong)local_6c;
          goto LAB_0013f9da;
        }
        local_90 = local_48 + local_50;
      }
      local_70 = iVar3 - (int)((local_90 + 5U) % (long)iVar3);
      if (local_70 < 4) {
        local_70 = local_70 + iVar3;
      }
      local_20 = local_90 + 5U + (long)local_70;
      if (uVar2 == 0) {
        iVar3 = 0;
      }
      else {
        iVar3 = *(int *)(*(long *)(param_1 + 0x1a8) + 8);
      }
      iVar3 = (int)local_20 + iVar3;
      _libssh2_htonu32(local_38 + 0x4040, 0);
      *(undefined *)(local_38 + 0x4044) = (char)local_70;
      RAND_bytes((uchar *)(local_38 + local_90 + 0x4045),local_70);
      if (uVar2 != 0) {
        ((void*(*)())(*(long *)(param_1 + 0x1a8) + 0x18))
                  (param_1,local_20 + local_38 + 0x4040,(ulong)*(uint *)(param_1 + 0x1b0),
                   local_38 + 0x4040,local_20 & 0xffffffff,0,0,param_1 + 0x1b8);
        local_40 = 0;
        while (local_40 < local_20) {
          local_18 = local_38 + local_40 + 0x4040;
          iVar4 = ((void*(*)())(*(long *)(param_1 + 0x198) + 0x30))
                            (param_1,local_18,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x10),
                             param_1 + 0x1a0);
          if (iVar4 != 0) {
            uVar6 = 0xffffffd4;
            goto LAB_0013f9da;
          }
          local_40 = local_40 + (long)*(int *)(*(long *)(param_1 + 0x198) + 0x10);
        }
      }
      *(int *)(param_1 + 0x1b0) = *(int *)(param_1 + 0x1b0) + 1;
      if (*(int *)(param_1 + 0x6c) == 0) {
        uVar7 = 0x4000;
      }
      else {
        uVar7 = 0;
      }
      local_58 = ((void*(*)())(param_1 + 0x48))
                           ((ulong)*(uint *)(param_1 + 0x228),local_38 + 0x4040,(long)iVar3,uVar7,
                            param_1);
      if ((long)iVar3 == local_58) {
        *(undefined8 *)(local_38 + 0xc900) = 0;
        *(undefined8 *)(local_38 + 0xc908) = 0;
        uVar6 = 0;
      }
      else {
        if ((local_58 < 0) && (local_58 != -0xb)) {
          uVar6 = 0xfffffff9;
        }
        else {
          *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 2;
          *(void **)(local_38 + 0xc900) = local_30;
          *(size_t *)(local_38 + 0xc908) = local_28;
          lVar5 = local_58;
          if (local_58 < 0) {
            lVar5 = 0;
          }
          *(long *)(local_38 + 0xc910) = lVar5;
          *(int *)(local_38 + 0xc8f8) = iVar3;
          uVar6 = 0xffffffdb;
        }
      }
    }
    else {
      uVar6 = 0;
    }
  }
  else {
    uVar6 = (ulong)uVar2;
  }
LAB_0013f9da:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar6;
}



undefined8 FUN_0013f9f0(long param_1,undefined8 param_2,uint param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd090) == 0) {
    memset((void *)(param_1 + 0xd0a8),0,8);
    *(ulong *)(param_1 + 0xd0a0) = (ulong)(param_3 + 0x1b);
    uVar4 = ((void*(*)())(param_1 + 8))
                      (*(undefined8 *)(param_1 + 0xd0a0),param_1,*(undefined8 *)(param_1 + 0xd0a0),
                       param_1);
    *(undefined8 *)(param_1 + 0xd098) = uVar4;
    puVar1 = *(undefined **)(param_1 + 0xd098);
    if (*(long *)(param_1 + 0xd098) == 0) {
      local_20 = puVar1;
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for userauth_list");
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    local_20 = puVar1 + 1;
    *puVar1 = 0x32;
    _libssh2_store_str(&local_20,param_2,(ulong)param_3);
    _libssh2_store_str(&local_20,"ssh-connection",0xe);
    _libssh2_store_u32(&local_20,4);
    *(undefined4 *)(param_1 + 0xd090) = 2;
  }
  if (*(int *)(param_1 + 0xd090) == 2) {
    iVar2 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd098),*(undefined8 *)(param_1 + 0xd0a0),
                       &DAT_00149d63,4);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting userauth list");
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd098),param_1,*(undefined8 *)(param_1 + 0xd098),param_1);
    *(undefined8 *)(param_1 + 0xd098) = 0;
    if (iVar2 != 0) {
      _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-none request");
      *(undefined4 *)(param_1 + 0xd090) = 0;
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    *(undefined4 *)(param_1 + 0xd090) = 3;
  }
  if (*(int *)(param_1 + 0xd090) == 3) {
    uVar3 = _libssh2_packet_requirev
                      (param_1,&DAT_0014a9a5,param_1 + 0xd098,param_1 + 0xd0a0,0,0,0,
                       param_1 + 0xd0a8);
    if (uVar3 == 0xffffffdb) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting userauth list");
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    if ((uVar3 != 0) || (*(long *)(param_1 + 0xd0a0) == 0)) {
      _libssh2_error(param_1,(ulong)uVar3,"Failed getting response",(ulong)uVar3);
      *(undefined4 *)(param_1 + 0xd090) = 0;
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    if (**(char **)(param_1 + 0xd098) == '4') {
      _libssh2_error(param_1,0,"No error");
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd098),param_1,*(undefined8 *)(param_1 + 0xd098),param_1
                );
      *(undefined8 *)(param_1 + 0xd098) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      *(undefined4 *)(param_1 + 0xd090) = 0;
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    if (*(ulong *)(param_1 + 0xd0a0) < 5) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd098),param_1,*(undefined8 *)(param_1 + 0xd098),param_1
                );
      *(undefined8 *)(param_1 + 0xd098) = 0;
      _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd098) + 1);
    local_18 = (ulong)uVar3;
    if (*(long *)(param_1 + 0xd0a0) - 5U <= local_18) {
      _libssh2_error(param_1,0xffffffd7,"Unexpected userauth list size");
      uVar4 = 0;
      goto LAB_0013fe53;
    }
    memmove(*(void **)(param_1 + 0xd098),(void *)(*(long *)(param_1 + 0xd098) + 5),local_18);
    *(undefined *)(local_18 + *(long *)(param_1 + 0xd098)) = 0;
  }
  *(undefined4 *)(param_1 + 0xd090) = 0;
  uVar4 = *(undefined8 *)(param_1 + 0xd098);
LAB_0013fe53:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



long libssh2_userauth_list(long param_1,undefined8 param_2,uint param_3)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = FUN_0013f9f0(param_1,param_2,(ulong)param_3);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



ulong libssh2_userauth_authenticated(long param_1)

{
  return (ulong)(*(int *)(param_1 + 0x68) >> 2 & 1);
}



undefined8
FUN_0013ff03(long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
          void *param_6)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd0b0) == 0) {
    memset((void *)(param_1 + 0xd0e0),0,8);
    *(ulong *)(param_1 + 0xd0c8) = (ulong)(param_3 + 0x28);
    *(undefined *)(param_1 + 0xd0c0) = 0xc3;
    uVar4 = ((void*(*)())(param_1 + 8))
                      (*(undefined8 *)(param_1 + 0xd0c8),param_1,*(undefined8 *)(param_1 + 0xd0c8),
                       param_1);
    *(undefined8 *)(param_1 + 0xd0b8) = uVar4;
    puVar1 = *(undefined **)(param_1 + 0xd0b8);
    if (*(long *)(param_1 + 0xd0b8) == 0) {
      local_18 = puVar1;
      uVar4 = _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for userauth-password request");
      goto LAB_00140754;
    }
    local_18 = puVar1 + 1;
    *puVar1 = 0x32;
    _libssh2_store_str(&local_18,param_2,(ulong)param_3);
    _libssh2_store_str(&local_18,"ssh-connection",0xe);
    _libssh2_store_str(&local_18,"password",8);
    *local_18 = 0;
    local_18 = local_18 + 1;
    _libssh2_store_u32(&local_18,(ulong)param_5);
    *(undefined4 *)(param_1 + 0xd0b0) = 2;
  }
  if (*(int *)(param_1 + 0xd0b0) != 2) {
LAB_0014013e:
    do {
      if (((*(int *)(param_1 + 0xd0b0) != 3) && (*(int *)(param_1 + 0xd0b0) != 4)) &&
         (*(int *)(param_1 + 0xd0b0) != 5)) {
LAB_00140700:
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),
                   param_1);
        *(undefined8 *)(param_1 + 0xd0b8) = 0;
        *(undefined4 *)(param_1 + 0xd0b0) = 0;
        uVar4 = _libssh2_error(param_1,0xffffffee,"Authentication failed");
        goto LAB_00140754;
      }
      if (*(int *)(param_1 + 0xd0b0) == 3) {
        uVar3 = _libssh2_packet_requirev
                          (param_1,&DAT_0014a9ac,param_1 + 0xd0b8,param_1 + 0xd0c8,0,0,0,
                           param_1 + 0xd0e0);
        if (uVar3 != 0) {
          if (uVar3 != 0xffffffdb) {
            *(undefined4 *)(param_1 + 0xd0b0) = 0;
          }
          uVar4 = _libssh2_error(param_1,(ulong)uVar3,"Waiting for password response",(ulong)uVar3);
          goto LAB_00140754;
        }
        if (*(long *)(param_1 + 0xd0c8) == 0) {
          *(undefined4 *)(param_1 + 0xd0b0) = 0;
          uVar4 = _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
          goto LAB_00140754;
        }
        if (**(char **)(param_1 + 0xd0b8) == '4') {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),
                     param_1);
          *(undefined8 *)(param_1 + 0xd0b8) = 0;
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
          *(undefined4 *)(param_1 + 0xd0b0) = 0;
          uVar4 = 0;
          goto LAB_00140754;
        }
        if (**(char **)(param_1 + 0xd0b8) == '3') {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),
                     param_1);
          *(undefined8 *)(param_1 + 0xd0b8) = 0;
          *(undefined4 *)(param_1 + 0xd0b0) = 0;
          uVar4 = _libssh2_error(param_1,0xffffffee,"Authentication failed (username/password)");
          goto LAB_00140754;
        }
        *(undefined8 *)(param_1 + 0xd0d0) = 0;
        *(undefined4 *)(param_1 + 0xd0d8) = 0;
        *(undefined4 *)(param_1 + 0xd0b0) = 4;
      }
      if (*(long *)(param_1 + 0xd0c8) == 0) {
        *(undefined4 *)(param_1 + 0xd0b0) = 0;
        uVar4 = _libssh2_error(param_1,0xfffffff2,"Unexpected packet size");
        goto LAB_00140754;
      }
      if ((**(char **)(param_1 + 0xd0b8) != '<') && (*(char *)(param_1 + 0xd0c0) != '<'))
      goto LAB_00140700;
      *(undefined *)(param_1 + 0xd0c0) = 0x3c;
      if ((*(int *)(param_1 + 0xd0b0) != 4) && (*(int *)(param_1 + 0xd0b0) != 5)) {
        *(undefined4 *)(param_1 + 0xd0b0) = 0;
        uVar4 = _libssh2_error(param_1,0xfffffff1,"Password Expired, and no callback specified");
        goto LAB_00140754;
      }
      if (*(int *)(param_1 + 0xd0b0) == 4) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),
                   param_1);
        *(undefined8 *)(param_1 + 0xd0b8) = 0;
      }
      if (param_6 == 0x0) goto LAB_00140700;
      if (*(int *)(param_1 + 0xd0b0) == 4) {

        if (*(long *)(param_1 + 0xd0d0) == 0) {
          uVar4 = _libssh2_error(param_1,0xfffffff1,"Password expired, and callback failed");
          goto LAB_00140754;
        }
        *(ulong *)(param_1 + 0xd0c8) = (ulong)(param_5 + param_3 + 0x2c);
        uVar4 = ((void*(*)())(param_1 + 8))
                          (*(undefined8 *)(param_1 + 0xd0c8),param_1,
                           *(undefined8 *)(param_1 + 0xd0c8),param_1);
        *(undefined8 *)(param_1 + 0xd0b8) = uVar4;
        puVar1 = *(undefined **)(param_1 + 0xd0b8);
        if (*(long *)(param_1 + 0xd0b8) == 0) {
          local_18 = puVar1;
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xd0d0),param_1,*(undefined8 *)(param_1 + 0xd0d0),
                     param_1);
          *(undefined8 *)(param_1 + 0xd0d0) = 0;
          uVar4 = _libssh2_error(param_1,0xfffffffa,
                                 "Unable to allocate memory for userauth password change request");
          goto LAB_00140754;
        }
        local_18 = puVar1 + 1;
        *puVar1 = 0x32;
        _libssh2_store_str(&local_18,param_2,(ulong)param_3);
        _libssh2_store_str(&local_18,"ssh-connection",0xe);
        _libssh2_store_str(&local_18,"password",8);
        *local_18 = 1;
        local_18 = local_18 + 1;
        _libssh2_store_str(&local_18,param_4,(ulong)param_5);
        _libssh2_store_u32(&local_18,(ulong)*(uint *)(param_1 + 0xd0d8));
        *(undefined4 *)(param_1 + 0xd0b0) = 5;
      }
      if (*(int *)(param_1 + 0xd0b0) != 5) goto LAB_00140700;
      iVar2 = _libssh2_transport_send
                        (param_1,*(undefined8 *)(param_1 + 0xd0b8),*(undefined8 *)(param_1 + 0xd0c8)
                         ,*(undefined8 *)(param_1 + 0xd0d0),(long)*(int *)(param_1 + 0xd0d8));
      if (iVar2 == -0x25) {
        uVar4 = _libssh2_error(param_1,0xffffffdb,"Would block waiting");
        goto LAB_00140754;
      }
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),param_1
                );
      *(undefined8 *)(param_1 + 0xd0b8) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd0d0),param_1,*(undefined8 *)(param_1 + 0xd0d0),param_1
                );
      *(undefined8 *)(param_1 + 0xd0d0) = 0;
      if (iVar2 != 0) goto code_r0x001406a7;
      *(undefined4 *)(param_1 + 0xd0b0) = 3;
    } while( 1 );
  }
  iVar2 = _libssh2_transport_send
                    (param_1,*(undefined8 *)(param_1 + 0xd0b8),*(undefined8 *)(param_1 + 0xd0c8),
                     param_4,(ulong)param_5);
  if (iVar2 == -0x25) {
    uVar4 = _libssh2_error(param_1,0xffffffdb,"Would block writing password request");
  }
  else {
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd0b8),param_1,*(undefined8 *)(param_1 + 0xd0b8),param_1);
    *(undefined8 *)(param_1 + 0xd0b8) = 0;
    if (iVar2 == 0) {
      *(undefined4 *)(param_1 + 0xd0b0) = 3;
      goto LAB_0014013e;
    }
    *(undefined4 *)(param_1 + 0xd0b0) = 0;
    uVar4 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-password request");
  }
  goto LAB_00140754;
code_r0x001406a7:
  uVar4 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth password-change request");
LAB_00140754:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong libssh2_userauth_password_ex
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,uint param_5,
                undefined8 param_6)

{
  time_t tVar1;
  uint local_14;
  
  tVar1 = time((time_t *)0x0);
  do {
    local_14 = FUN_0013ff03(param_1,param_2,(ulong)param_3,param_4,(ulong)param_5,param_6);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
    local_14 = _libssh2_wait_socket(param_1,tVar1);
  } while (local_14 == 0);
  return (ulong)local_14;
}



undefined8
FUN_001407f3(long param_1,void **param_2,long *param_3,undefined8 *param_4,ulong *param_5,
            void *param_6,ulong param_7)

{
  int iVar1;
  undefined8 uVar2;
  ushort **ppuVar3;
  long in_FS_OFFSET;
  uint local_3c;
  undefined8 local_38;
  void *local_30;
  ulong local_28;
  void *local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (void *)0x0;
  local_28 = param_7;
  if (param_7 < 2) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid data in public key file");
  }
  else {
    local_20 = (void *)((void*(*)())(param_1 + 8))(param_7,param_1,param_1);
    if (local_20 == (void *)0x0) {
      uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for public key data");
    }
    else {
      memcpy(local_20,param_6,param_7);
      while (local_28 != 0) {
        ppuVar3 = __ctype_b_loc();
        if (((*ppuVar3)[*(byte *)((long)local_20 + (local_28 - 1))] & 0x2000) == 0) break;
        local_28 = local_28 - 1;
      }
      if (local_28 == 0) {
        ((void*(*)())(param_1 + 0x18))(local_20,param_1,local_20,param_1);
        uVar2 = _libssh2_error(param_1,0xfffffff0,"Missing public key data");
      }
      else {
        local_18 = memchr(local_20,0x20,local_28);
        if (local_18 == (void *)0x0) {
          ((void*(*)())(param_1 + 0x18))(local_20,param_1,local_20,param_1);
          uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid public key data");
        }
        else {
          local_18 = (void *)((long)local_18 + 1);
          local_30 = memchr(local_18,0x20,local_28 - (long)((long)local_18 - (long)local_20));
          if (local_30 == (void *)0x0) {
            local_30 = (void *)(local_28 + (long)local_20);
          }
          iVar1 = libssh2_base64_decode
                            (param_1,&local_38,&local_3c,local_18,
                             (ulong)((long)local_30 - (long)local_18) & 0xffffffff);
          if (iVar1 == 0) {
            *param_2 = local_20;
            *param_3 = (long)local_18 + (-1 - (long)local_20);
            *param_4 = local_38;
            *param_5 = (ulong)local_3c;
            uVar2 = 0;
          }
          else {
            ((void*(*)())(param_1 + 0x18))(local_20,param_1,local_20,param_1);
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid key data, not base64 encoded");
          }
        }
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00140a80(long param_1,void **param_2,long *param_3,undefined8 *param_4,ulong *param_5,
            char *param_6)

{
  int iVar1;
  undefined8 uVar2;
  size_t sVar3;
  ushort **ppuVar4;
  long in_FS_OFFSET;
  char local_4d;
  uint local_4c;
  undefined8 local_48;
  void *local_40;
  size_t local_38;
  void *local_30;
  FILE *local_28;
  void *local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = (void *)0x0;
  local_38 = 0;
  local_28 = fopen(param_6,"r");
  if (local_28 == (FILE *)0x0) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to open public key file");
  }
  else {
    while( 1 ) {
      iVar1 = feof(local_28);
      if (iVar1 != 0) break;
      sVar3 = fread(&local_4d,1,1,local_28);
      if (((sVar3 != 1) || (local_4d == '\r')) || (local_4d == '\n')) break;
      local_38 = local_38 + 1;
    }
    rewind(local_28);
    if (local_38 < 2) {
      fclose(local_28);
      uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid data in public key file");
    }
    else {
      local_30 = (void *)((void*(*)())(param_1 + 8))(local_38,param_1,local_38,param_1);
      if (local_30 == (void *)0x0) {
        fclose(local_28);
        uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for public key data");
      }
      else {
        sVar3 = fread(local_30,1,local_38,local_28);
        if (local_38 == sVar3) {
          fclose(local_28);
          while (local_38 != 0) {
            ppuVar4 = __ctype_b_loc();
            if (((*ppuVar4)[*(byte *)((long)local_30 + (local_38 - 1))] & 0x2000) == 0) break;
            local_38 = local_38 - 1;
          }
          if (local_38 == 0) {
            ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Missing public key data");
          }
          else {
            local_20 = memchr(local_30,0x20,local_38);
            if (local_20 == (void *)0x0) {
              ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
              uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid public key data");
            }
            else {
              local_20 = (void *)((long)local_20 + 1);
              if (local_30 < local_20) {
                local_18 = (void *)((long)local_20 - (long)local_30);
              }
              else {
                local_18 = (void *)0x0;
              }
              local_40 = memchr(local_20,0x20,local_38 - (long)local_18);
              if (local_40 == (void *)0x0) {
                local_40 = (void *)(local_38 + (long)local_30);
              }
              iVar1 = libssh2_base64_decode
                                (param_1,&local_48,&local_4c,local_20,
                                 (ulong)((long)local_40 - (long)local_20) & 0xffffffff);
              if (iVar1 == 0) {
                *param_2 = local_30;
                *param_3 = (long)local_20 + (-1 - (long)local_30);
                *param_4 = local_48;
                *param_5 = (ulong)local_4c;
                uVar2 = 0;
              }
              else {
                ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
                uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid key data, not base64 encoded");
              }
            }
          }
        }
        else {
          ((void*(*)())(param_1 + 0x18))(local_30,param_1,local_30,param_1);
          fclose(local_28);
          uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to read public key from file");
        }
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
FUN_00140e1f(undefined8 param_1,long **param_2,undefined8 *param_3,char *param_4,int param_5,
            undefined8 param_6,undefined8 param_7,undefined8 param_8)

{
  int iVar1;
  undefined8 uVar2;
  long **local_10;
  
  local_10 = (long **)libssh2_hostkey_methods();
  *param_2 = (long *)0x0;
  *param_3 = 0;
  do {
    if ((*local_10 == (long *)0x0) || (**local_10 == 0)) goto LAB_00140ec3;
    if ((*local_10)[4] != 0) {
      iVar1 = strncmp((char *)**local_10,param_4,(long)param_5);
      if (iVar1 == 0) {
        *param_2 = *local_10;
LAB_00140ec3:
        if (*param_2 == (long *)0x0) {
          uVar2 = _libssh2_error(param_1,0xffffffef,"No handler for specified private key");
        }
        else {
          if (iVar1 == 0) {
            uVar2 = 0;
          }
          else {
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to initialize private key from file");
          }
        }
        return uVar2;
      }
    }
    local_10 = local_10 + 1;
  } while( 1 );
}



undefined8
FUN_00140f35(undefined8 param_1,long **param_2,undefined8 *param_3,char *param_4,int param_5,
            undefined8 param_6,undefined8 param_7)

{
  int iVar1;
  undefined8 uVar2;
  long **local_10;
  
  local_10 = (long **)libssh2_hostkey_methods();
  *param_2 = (long *)0x0;
  *param_3 = 0;
  do {
    if ((*local_10 == (long *)0x0) || (**local_10 == 0)) goto LAB_00140fd9;
    if ((*local_10)[3] != 0) {
      iVar1 = strncmp((char *)**local_10,param_4,(long)param_5);
      if (iVar1 == 0) {
        *param_2 = *local_10;
LAB_00140fd9:
        if (*param_2 == (long *)0x0) {
          uVar2 = _libssh2_error(param_1,0xffffffef,"No handler for specified private key");
        }
        else {

          if (iVar1 == 0) {
            uVar2 = 0;
          }
          else {
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to initialize private key from file");
          }
        }
        return uVar2;
      }
    }
    local_10 = local_10 + 1;
  } while( 1 );
}



ulong FUN_00141044(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                  undefined8 param_5,char **param_6)

{
  char *pcVar1;
  uint uVar2;
  int iVar3;
  size_t sVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  long local_50;
  undefined local_48 [8];
  char **local_40;
  undefined8 local_38;
  undefined8 local_30;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = (char **)*param_6;
  pcVar1 = local_40[1];
  sVar4 = strlen(*local_40);
  uVar2 = FUN_00140e1f(param_1,&local_50,local_48,*(undefined8 *)(param_1 + 0xd158),
                       *(ulong *)(param_1 + 0xd160) & 0xffffffff,*local_40,sVar4,pcVar1);

  if (uVar2 == 0) {
    local_38 = param_4;
    local_30 = param_5;
    iVar3 = ((void*(*)())(local_50 + 0x30))(param_1,param_2,param_3,1,&local_38,local_48);
    if (iVar3 == 0) {
      if (*(long *)(local_50 + 0x40) != 0) {
        ((void*(*)())(local_50 + 0x40))(param_1,local_48,param_1,local_48);
      }
      uVar5 = 0;
    }
    else {
      if (*(long *)(local_50 + 0x40) != 0) {
        ((void*(*)())(local_50 + 0x40))(param_1,local_48,param_1,local_48);
      }
      uVar5 = 0xffffffff;
    }
  }
  else {
    uVar5 = (ulong)uVar2;
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong FUN_00141198(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                  undefined8 param_5,long *param_6)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  long local_40;
  undefined local_38 [8];
  undefined8 *local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = (undefined8 *)*param_6;
  uVar1 = FUN_00140f35(param_1,&local_40,local_38,*(undefined8 *)(param_1 + 0xd158),
                       *(ulong *)(param_1 + 0xd160) & 0xffffffff,*local_30,local_30[1]);
  if (uVar1 == 0) {
    local_28 = param_4;
    local_20 = param_5;
    iVar2 = ((void*(*)())(local_40 + 0x30))
                      (param_1,param_2,param_3,1,&local_28,local_38,param_6,param_5,param_4);
    if (iVar2 == 0) {
      if (*(long *)(local_40 + 0x40) != 0) {
        ((void*(*)())(local_40 + 0x40))(param_1,local_38,param_1,local_38);
      }
      uVar3 = 0;
    }
    else {
      if (*(long *)(local_40 + 0x40) != 0) {
        ((void*(*)())(local_40 + 0x40))(param_1,local_38,param_1,local_38);
      }
      uVar3 = 0xffffffff;
    }
  }
  else {
    uVar3 = (ulong)uVar1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



ulong FUN_001412d7(long param_1,undefined8 param_2,long param_3,long param_4,undefined8 param_5,
                  undefined8 param_6,undefined8 param_7,long param_8,undefined8 param_9,
                  long param_10)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  long lVar5;
  long in_FS_OFFSET;
  undefined8 uVar6;
  long local_90;
  undefined8 local_88;
  undefined8 local_80;
  ulong local_78;
  ulong local_70;
  long local_68;
  long local_60;
  undefined *local_58;
  undefined8 local_50;
  undefined8 local_48;
  ulong local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined local_15 [5];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd0e8) == 0) {
    local_88 = 0;
    local_80 = 0;
    local_78 = 0;
    local_70 = 0;
    uVar6 = 0x141385;
    memset((void *)(param_1 + 0xd128),0,8);
    if (param_4 == 0) {
      uVar2 = _libssh2_pub_priv_keyfile
                        (param_1,param_1 + 0xd110,param_1 + 0xd118,&local_88,&local_78,param_5,
                         param_6);
      if (uVar2 != 0) {
        uVar4 = (ulong)uVar2;
        goto LAB_00141f0b;
      }
    }
    else {
      uVar2 = FUN_00140a80(param_1,param_1 + 0xd110,param_1 + 0xd118,&local_88,&local_78,param_4);
      if (uVar2 != 0) {
        uVar4 = (ulong)uVar2;
        goto LAB_00141f0b;
      }
    }
    *(long *)(param_1 + 0xd108) =
         local_78 + *(long *)(param_1 + 0xd118) + param_3 + param_8 + param_10 + 0x34;
    lVar5 = local_78 + *(long *)(param_1 + 0xd108) + *(long *)(param_1 + 0xd118) + 0xc;
    uVar6 = ((void*(*)())(param_1 + 8))(lVar5,param_1,param_1,lVar5);
    *(undefined8 *)(param_1 + 0xd100) = uVar6;
    *(undefined8 *)(param_1 + 0xd120) = *(undefined8 *)(param_1 + 0xd100);
    if (*(long *)(param_1 + 0xd100) == 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd110),param_1,*(undefined8 *)(param_1 + 0xd110),param_1
                );
      *(undefined8 *)(param_1 + 0xd110) = 0;
      ((void*(*)())(param_1 + 0x18))(local_88,param_1,local_88,param_1);
      uVar4 = _libssh2_error(param_1,0xfffffffa,"Out of memory");
      goto LAB_00141f0b;
    }
    puVar1 = *(undefined **)(param_1 + 0xd120);
    *(undefined **)(param_1 + 0xd120) = puVar1 + 1;
    *puVar1 = 0x32;
    _libssh2_store_str(param_1 + 0xd120,param_2,param_3);
    _libssh2_store_str(param_1 + 0xd120,"ssh-connection",0xe);
    _libssh2_store_str(param_1 + 0xd120,"hostbased",9);
    _libssh2_store_str(param_1 + 0xd120,*(undefined8 *)(param_1 + 0xd110),
                       *(undefined8 *)(param_1 + 0xd118));
    _libssh2_store_str(param_1 + 0xd120,local_88,local_78);
    ((void*(*)())(param_1 + 0x18))(local_88,param_1,local_88,param_1);
    _libssh2_store_str(param_1 + 0xd120,param_7,param_8);
    uVar6 = 0x1416e0;
    _libssh2_store_str(param_1 + 0xd120,param_9,param_10);
    uVar2 = FUN_00140f35(param_1,&local_90,&local_68,*(undefined8 *)(param_1 + 0xd110),
                         *(ulong *)(param_1 + 0xd118) & 0xffffffff,param_5,param_6);
    if (uVar2 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd110),param_1,*(undefined8 *)(param_1 + 0xd110),param_1
                );
      *(undefined8 *)(param_1 + 0xd110) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd100),param_1,*(undefined8 *)(param_1 + 0xd100),param_1
                );
      *(undefined8 *)(param_1 + 0xd100) = 0;
      uVar4 = (ulong)uVar2;
      goto LAB_00141f0b;
    }
    _libssh2_htonu32(local_15,(ulong)*(uint *)(param_1 + 0x90));
    local_58 = local_15;
    local_50 = 4;
    local_48 = *(undefined8 *)(param_1 + 0x88);
    local_40 = (ulong)*(uint *)(param_1 + 0x90);
    local_38 = *(undefined8 *)(param_1 + 0xd100);
    local_30 = *(undefined8 *)(param_1 + 0xd108);
    if ((local_90 != 0) && (*(long *)(local_90 + 0x30) != 0)) {
      iVar3 = ((void*(*)())(local_90 + 0x30))(param_1,&local_80,&local_70,3,&local_58,&local_68);
      if (iVar3 != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd110),param_1,*(undefined8 *)(param_1 + 0xd110),
                   param_1);
        *(undefined8 *)(param_1 + 0xd110) = 0;
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd100),param_1,*(undefined8 *)(param_1 + 0xd100),
                   param_1);
        *(undefined8 *)(param_1 + 0xd100) = 0;
        if (*(long *)(local_90 + 0x40) != 0) {
          ((void*(*)())(local_90 + 0x40))(param_1,&local_68,param_1,&local_68);
        }
        uVar4 = 0xffffffff;
        goto LAB_00141f0b;
      }
    }
    if ((local_90 != 0) && (*(long *)(local_90 + 0x40) != 0)) {
      ((void*(*)())(local_90 + 0x40))(param_1,&local_68,param_1,&local_68);
    }
    if (local_78 < local_70) {
      if (*(long *)(param_1 + 0xd100) == 0) {
        lVar5 = local_70 + *(long *)(param_1 + 0xd108) + *(long *)(param_1 + 0xd118) + 0xc;
        local_60 = ((void*(*)())(param_1 + 8))(lVar5,param_1,param_1,lVar5);
      }
      else {
        local_60 = ((void*(*)())(param_1 + 0x10))
                             (*(undefined8 *)(param_1 + 0xd100),
                              local_70 + *(long *)(param_1 + 0xd108) + *(long *)(param_1 + 0xd118) +
                              0xc,param_1,*(undefined8 *)(param_1 + 0xd100));
      }
      if (local_60 == 0) {
        ((void*(*)())(param_1 + 0x18))(local_80,param_1,local_80,param_1);
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd100),param_1,*(undefined8 *)(param_1 + 0xd100),
                   param_1);
        *(undefined8 *)(param_1 + 0xd100) = 0;
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd110),param_1,*(undefined8 *)(param_1 + 0xd110),
                   param_1);
        *(undefined8 *)(param_1 + 0xd110) = 0;
        uVar4 = _libssh2_error(param_1,0xfffffffa,
                               "Failed allocating additional space for userauth-hostbased packet");
        goto LAB_00141f0b;
      }
      *(long *)(param_1 + 0xd100) = local_60;
    }
    *(long *)(param_1 + 0xd120) = *(long *)(param_1 + 0xd100) + *(long *)(param_1 + 0xd108);
    uVar2 = (int)local_70 + (int)*(undefined8 *)(param_1 + 0xd118) + 8;
    _libssh2_store_u32(param_1 + 0xd120,(ulong)uVar2);
    _libssh2_store_str(param_1 + 0xd120,*(undefined8 *)(param_1 + 0xd110),
                       *(undefined8 *)(param_1 + 0xd118));
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd110),param_1,*(undefined8 *)(param_1 + 0xd110),param_1);
    *(undefined8 *)(param_1 + 0xd110) = 0;
    _libssh2_store_str(param_1 + 0xd120,local_80,local_70);
    ((void*(*)())(param_1 + 0x18))(local_80,param_1,local_80,param_1);
    *(undefined4 *)(param_1 + 0xd0e8) = 2;
  }
  if (*(int *)(param_1 + 0xd0e8) == 2) {
    iVar3 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd100),
                       *(long *)(param_1 + 0xd120) - *(long *)(param_1 + 0xd100),0,0);
    if (iVar3 == -0x25) {
      uVar4 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00141f0b;
    }
    if (iVar3 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd100),param_1,*(undefined8 *)(param_1 + 0xd100),param_1
                );
      *(undefined8 *)(param_1 + 0xd100) = 0;
      *(undefined4 *)(param_1 + 0xd0e8) = 0;
      uVar4 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-hostbased request");
      goto LAB_00141f0b;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd100),param_1,*(undefined8 *)(param_1 + 0xd100),param_1);
    *(undefined8 *)(param_1 + 0xd100) = 0;
    *(undefined4 *)(param_1 + 0xd0e8) = 3;
  }
  if (*(int *)(param_1 + 0xd0e8) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (param_1,&DAT_0014a9ac,param_1 + 0xd0f0,&local_68,0,0,0,param_1 + 0xd128);
    if (iVar3 == -0x25) {
      uVar4 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00141f0b;
    }
    *(undefined4 *)(param_1 + 0xd0e8) = 0;
    if ((iVar3 != 0) || (local_68 == 0)) {
      uVar4 = _libssh2_error(param_1,0xffffffed,"Auth failed");
      goto LAB_00141f0b;
    }
    if (**(char **)(param_1 + 0xd0f0) == '4') {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd0f0),param_1,*(undefined8 *)(param_1 + 0xd0f0),param_1
                );
      *(undefined8 *)(param_1 + 0xd0f0) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      uVar4 = 0;
      goto LAB_00141f0b;
    }
  }
  ((void*(*)())(param_1 + 0x18))
            (*(undefined8 *)(param_1 + 0xd0f0),param_1,*(undefined8 *)(param_1 + 0xd0f0),param_1);
  *(undefined8 *)(param_1 + 0xd0f0) = 0;
  uVar4 = _libssh2_error(param_1,0xffffffed,
                                                  
                         "Invalid signature for supplied public key, or bad username/public key combination"
                        );
LAB_00141f0b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



ulong libssh2_userauth_hostbased_fromfile_ex
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,undefined8 param_5,
                undefined8 param_6,undefined8 param_7,uint param_8,undefined8 param_9,uint param_10)

{
  time_t tVar1;
  uint local_14;
  
  tVar1 = time((time_t *)0x0);
  do {
    local_14 = FUN_001412d7(param_1,param_2,(ulong)param_3,param_4,param_5,param_6,param_7,
                            (ulong)param_8,param_9,(ulong)param_10);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
    local_14 = _libssh2_wait_socket(param_1,tVar1);
  } while (local_14 == 0);
  return (ulong)local_14;
}



undefined8 _libssh2_userauth_publickey(long param_1,undefined8 param_2,uint param_3,long param_4,ulong param_5,void *param_6, undefined8 param_7)

{
  ulong uVar1;
  undefined *puVar2;
  uint uVar3;
  int iVar4;
  undefined8 uVar5;
  long lVar6;
  long in_FS_OFFSET;
  undefined *local_50;
  undefined8 local_48;
  ulong local_40;
  undefined *local_38;
  long local_30;
  undefined local_24;
  undefined local_23;
  undefined local_22;
  undefined local_21;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_24 = 0x34;
  local_23 = 0x33;
  local_22 = 0x3c;
  local_21 = 0;
  if (*(int *)(param_1 + 0xd130) == 0) {
    if (param_5 < 4) {
      uVar5 = _libssh2_error(param_1,0xffffffed,"Invalid public key, too short");
      goto LAB_00142db6;
    }
    memset((void *)(param_1 + 0xd178),0,8);
    if (*(long *)(param_1 + 0xd158) == 0) {
      uVar3 = _libssh2_ntohu32(param_4);
      *(ulong *)(param_1 + 0xd160) = (ulong)uVar3;
      if (param_5 - 4 < *(ulong *)(param_1 + 0xd160)) {
        uVar5 = _libssh2_error(param_1,0xffffffed,"Invalid public key");
        goto LAB_00142db6;
      }
      uVar5 = ((void*(*)())(param_1 + 8))
                        (*(undefined8 *)(param_1 + 0xd160),param_1,*(undefined8 *)(param_1 + 0xd160)
                         ,param_1);
      *(undefined8 *)(param_1 + 0xd158) = uVar5;
      if (*(long *)(param_1 + 0xd158) == 0) {
        uVar5 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for public key data");
        goto LAB_00142db6;
      }
      memcpy(*(void **)(param_1 + 0xd158),(void *)(param_4 + 4),*(size_t *)(param_1 + 0xd160));
    }
    else {
      uVar1 = *(ulong *)(param_1 + 0xd160);
      uVar3 = _libssh2_ntohu32(param_4);
      if (uVar1 != (ulong)uVar3) {
        uVar5 = _libssh2_error(param_1,0xffffffed,"Invalid public key");
        goto LAB_00142db6;
      }
    }
    *(long *)(param_1 + 0xd150) = param_5 + (ulong)param_3 + *(long *)(param_1 + 0xd160) + 0x2d;
    lVar6 = param_5 + *(long *)(param_1 + 0xd150) + *(long *)(param_1 + 0xd160) + 0xc;
    uVar5 = ((void*(*)())(param_1 + 8))(lVar6,param_1,param_1,lVar6);
    *(undefined8 *)(param_1 + 0xd148) = uVar5;
    puVar2 = *(undefined **)(param_1 + 0xd148);
    if (*(long *)(param_1 + 0xd148) == 0) {
      local_50 = puVar2;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1
                );
      *(undefined8 *)(param_1 + 0xd158) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffffa,"Out of memory");
      goto LAB_00142db6;
    }
    local_50 = puVar2 + 1;
    *puVar2 = 0x32;
    _libssh2_store_str(&local_50,param_2,(ulong)param_3);
    _libssh2_store_str(&local_50,"ssh-connection",0xe);
    _libssh2_store_str(&local_50,"publickey",9);
    *(undefined **)(param_1 + 0xd170) = local_50;
    *local_50 = 0;
    local_50 = local_50 + 1;
    _libssh2_store_str(&local_50,*(undefined8 *)(param_1 + 0xd158),*(undefined8 *)(param_1 + 0xd160));

    _libssh2_store_str(&local_50,param_4,param_5);
    *(undefined4 *)(param_1 + 0xd130) = 2;
  }
  if (*(int *)(param_1 + 0xd130) == 2) {
    iVar4 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd148),*(undefined8 *)(param_1 + 0xd150),0
                       ,0);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00142db6;
    }
    if (iVar4 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1
                );
      *(undefined8 *)(param_1 + 0xd148) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1
                );
      *(undefined8 *)(param_1 + 0xd158) = 0;
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-publickey request");
      goto LAB_00142db6;
    }
    *(undefined4 *)(param_1 + 0xd130) = 3;
  }
  if (*(int *)(param_1 + 0xd130) == 3) {
    iVar4 = _libssh2_packet_requirev
                      (param_1,&local_24,param_1 + 0xd138,param_1 + 0xd140,0,0,0,param_1 + 0xd178);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00142db6;
    }
    if ((iVar4 != 0) || (*(long *)(param_1 + 0xd140) == 0)) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1
                );
      *(undefined8 *)(param_1 + 0xd148) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1
                );
      *(undefined8 *)(param_1 + 0xd158) = 0;
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffed,"Waiting for USERAUTH response");
      goto LAB_00142db6;
    }
    if (**(char **)(param_1 + 0xd138) == '4') {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd138),param_1,*(undefined8 *)(param_1 + 0xd138),param_1
                );
      *(undefined8 *)(param_1 + 0xd138) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1
                );
      *(undefined8 *)(param_1 + 0xd148) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1
                );
      *(undefined8 *)(param_1 + 0xd158) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = 0;
      goto LAB_00142db6;
    }
    if (**(char **)(param_1 + 0xd138) == '3') {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd138),param_1,*(undefined8 *)(param_1 + 0xd138),param_1
                );
      *(undefined8 *)(param_1 + 0xd138) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1
                );
      *(undefined8 *)(param_1 + 0xd148) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1
                );
      *(undefined8 *)(param_1 + 0xd158) = 0;
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffee,"Username/PublicKey combination invalid");
      goto LAB_00142db6;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd138),param_1,*(undefined8 *)(param_1 + 0xd138),param_1);
    *(undefined8 *)(param_1 + 0xd138) = 0;
    **(undefined **)(param_1 + 0xd170) = 1;
    *(undefined4 *)(param_1 + 0xd130) = 4;
  }
  if (*(int *)(param_1 + 0xd130) == 4) {
    lVar6 = *(long *)(param_1 + 0xd150) + (ulong)(*(int *)(param_1 + 0x90) + 4);
    local_50 = (undefined *)((void*(*)())(param_1 + 8))(lVar6,param_1,param_1,lVar6);
    local_38 = local_50;
    if (local_50 == (undefined *)0x0) {
      uVar5 = _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for userauth-publickey signed data");
      goto LAB_00142db6;
    }
    _libssh2_store_str(&local_50,*(undefined8 *)(param_1 + 0x88),(ulong)*(uint *)(param_1 + 0x90));
    memcpy(local_50,*(void **)(param_1 + 0xd148),*(size_t *)(param_1 + 0xd150));
    local_50 = local_50 + *(long *)(param_1 + 0xd150);

    ((void*(*)())(param_1 + 0x18))(local_38,param_1,local_38,param_1);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00142db6;
    }
    if (iVar4 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1
                );
      *(undefined8 *)(param_1 + 0xd158) = 0;
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1
                );
      *(undefined8 *)(param_1 + 0xd148) = 0;
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffed,"Callback returned error");
      goto LAB_00142db6;
    }
    if (param_5 < local_40) {
      if (*(long *)(param_1 + 0xd148) == 0) {
        lVar6 = local_40 + *(long *)(param_1 + 0xd150) + *(long *)(param_1 + 0xd160) + 0xc;
        local_30 = ((void*(*)())(param_1 + 8))(lVar6,param_1,param_1,lVar6);
      }
      else {
        local_30 = ((void*(*)())(param_1 + 0x10))
                             (*(undefined8 *)(param_1 + 0xd148),
                              local_40 + *(long *)(param_1 + 0xd150) + *(long *)(param_1 + 0xd160) +
                              0xc,param_1,*(undefined8 *)(param_1 + 0xd148));
      }
      if (local_30 == 0) {
        ((void*(*)())(param_1 + 0x18))(local_48,param_1,local_48,param_1);
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),
                   param_1);
        *(undefined8 *)(param_1 + 0xd148) = 0;
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),
                   param_1);
        *(undefined8 *)(param_1 + 0xd158) = 0;
        *(undefined4 *)(param_1 + 0xd130) = 0;
        uVar5 = _libssh2_error(param_1,0xfffffffa,
                               "Failed allocating additional space for userauth-publickey packet");
        goto LAB_00142db6;
      }
      *(long *)(param_1 + 0xd148) = local_30;
    }
    local_50 = (undefined *)(*(long *)(param_1 + 0xd150) + *(long *)(param_1 + 0xd148));
    *(undefined8 *)(param_1 + 0xd170) = 0;
    uVar3 = (int)local_40 + (int)*(undefined8 *)(param_1 + 0xd160) + 8;
    _libssh2_store_u32(&local_50,(ulong)uVar3);
    _libssh2_store_str(&local_50,*(undefined8 *)(param_1 + 0xd158)
                       ,*(undefined8 *)(param_1 + 0xd158));
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd158),param_1,*(undefined8 *)(param_1 + 0xd158),param_1);
    *(undefined8 *)(param_1 + 0xd158) = 0;
    _libssh2_store_str(&local_50,local_48,local_40);
    ((void*(*)())(param_1 + 0x18))(local_48,param_1,local_48,param_1);
    *(undefined **)(param_1 + 0xd168) = local_50;
    *(undefined4 *)(param_1 + 0xd130) = 5;
  }
  if (*(int *)(param_1 + 0xd130) == 5) {
    iVar4 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd148),
                       *(long *)(param_1 + 0xd168) - *(long *)(param_1 + 0xd148),0,0);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00142db6;
    }
    if (iVar4 != 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1
                );
      *(undefined8 *)(param_1 + 0xd148) = 0;
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-publickey request");
      goto LAB_00142db6;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd148),param_1,*(undefined8 *)(param_1 + 0xd148),param_1);
    *(undefined8 *)(param_1 + 0xd148) = 0;
    *(undefined4 *)(param_1 + 0xd130) = 6;
  }
  local_22 = 0;
  iVar4 = _libssh2_packet_requirev
                    (param_1,&local_24,param_1 + 0xd138,param_1 + 0xd140,0,0,0,param_1 + 0xd178);
  if (iVar4 == -0x25) {
    uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block requesting userauth list");
  }
  else {
    if ((iVar4 == 0) && (*(long *)(param_1 + 0xd140) != 0)) {
      if (**(char **)(param_1 + 0xd138) == '4') {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd138),param_1,*(undefined8 *)(param_1 + 0xd138),
                   param_1);
        *(undefined8 *)(param_1 + 0xd138) = 0;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
        *(undefined4 *)(param_1 + 0xd130) = 0;
        uVar5 = 0;
      }
      else {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd138),param_1,*(undefined8 *)(param_1 + 0xd138),
                   param_1);
        *(undefined8 *)(param_1 + 0xd138) = 0;
        *(undefined4 *)(param_1 + 0xd130) = 0;
        uVar5 = _libssh2_error(param_1,0xffffffed,
                                                              
                               "Invalid signature for supplied public key, or bad username/public key combination"
                              );
      }
    }
    else {
      *(undefined4 *)(param_1 + 0xd130) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffed,"Waiting for publickey USERAUTH response");
    }
  }
LAB_00142db6:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong FUN_00142dd0(long param_1,undefined8 param_2,ulong param_3,long param_4,long param_5,
                  long param_6,long param_7,undefined8 param_8)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  long local_40;
  undefined8 local_38;
  long *local_30;
  long local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = 0;
  local_38 = 0;
  local_30 = &local_28;
  local_20 = param_8;
  local_28 = param_6;
  if (*(int *)(param_1 + 0xd130) == 0) {
    if ((param_5 == 0) || (param_4 == 0)) {
      if ((param_7 == 0) || (param_6 == 0)) {
        uVar3 = _libssh2_error(param_1,0xfffffff0,"Invalid data in public and private key.");
        goto LAB_00142f96;
      }
      iVar2 = _libssh2_pub_priv_keyfilememory
                        (param_1,param_1 + 0xd158,param_1 + 0xd160,&local_40,&local_38,param_6,
                         param_7,param_8);
      if (iVar2 != 0) {
        uVar3 = _libssh2_error(param_1,0xfffffff0,"Unable to extract public key from private key.");
        goto LAB_00142f96;
      }
    }
    else {
      uVar1 = FUN_001407f3(param_1,param_1 + 0xd158,param_1 + 0xd160,&local_40,&local_38,param_4,
                           param_5);
      if (uVar1 != 0) {
        uVar3 = (ulong)uVar1;
        goto LAB_00142f96;
      }
    }
  }
  uVar1 = _libssh2_userauth_publickey
                    (param_1,param_2,param_3 & 0xffffffff,local_40,local_38,FUN_00141044,&local_30);
  if (local_40 != 0) {
    ((void*(*)())(param_1 + 0x18))(local_40,param_1,local_40,param_1);
  }
  uVar3 = (ulong)uVar1;
LAB_00142f96:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



ulong FUN_00142fac(long param_1,undefined8 param_2,ulong param_3,long param_4,undefined8 param_5,
                  undefined8 param_6)

{
  uint uVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  long local_40;
  undefined8 local_38;
  undefined8 *local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = 0;
  local_38 = 0;
  local_30 = &local_28;
  local_28 = param_5;
  local_20 = param_6;
  if (*(int *)(param_1 + 0xd130) == 0) {
    if (param_4 == 0) {
      uVar1 = _libssh2_pub_priv_keyfile
                        (param_1,param_1 + 0xd158,param_1 + 0xd160,&local_40,&local_38,param_5,
                         param_6);
      if (uVar1 != 0) {
        uVar2 = (ulong)uVar1;
        goto LAB_0014311d;
      }
    }
    else {
      uVar1 = FUN_00140a80(param_1,param_1 + 0xd158,param_1 + 0xd160,&local_40,&local_38,param_4);
      if (uVar1 != 0) {
        uVar2 = (ulong)uVar1;
        goto LAB_0014311d;
      }
    }
  }
  uVar1 = _libssh2_userauth_publickey
                    (param_1,param_2,param_3 & 0xffffffff,local_40,local_38,FUN_00141198,&local_30);
  if (local_40 != 0) {
    ((void*(*)())(param_1 + 0x18))(local_40,param_1,local_40,param_1);
  }
  uVar2 = (ulong)uVar1;
LAB_0014311d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong libssh2_userauth_publickey_frommemory
                (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined *param_8)

{
  time_t tVar1;
  uint local_14;
  
  if (param_8 == (undefined *)0x0) {
    param_8 = &DAT_0014a3f8;
  }
  tVar1 = time((time_t *)0x0);
  do {
    local_14 = FUN_00142dd0(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
    local_14 = _libssh2_wait_socket(param_1,tVar1);
  } while (local_14 == 0);
  return (ulong)local_14;
}



ulong libssh2_userauth_publickey_fromfile_ex
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4,undefined8 param_5,
                undefined *param_6)

{
  time_t tVar1;
  undefined *local_48;
  uint local_14;
  
  local_48 = param_6;
  if (param_6 == (undefined *)0x0) {
    local_48 = &DAT_0014a3f8;
  }
  tVar1 = time((time_t *)0x0);
  do {
    local_14 = FUN_00142fac(param_1,param_2,(ulong)param_3,param_4,param_5,local_48);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
    local_14 = _libssh2_wait_socket(param_1,tVar1);
  } while (local_14 == 0);
  return (ulong)local_14;
}



ulong libssh2_userauth_publickey
                (long param_1,char *param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5
                ,undefined8 param_6)

{
  ulong uVar1;
  time_t tVar2;
  size_t sVar3;
  undefined8 uVar4;
  uint local_14;
  
  if (param_1 == 0) {
    uVar1 = 0xffffffd9;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      uVar4 = 0x1432c2;
      sVar3 = strlen(param_2);
      local_14 = _libssh2_userauth_publickey
                           (param_1,param_2,sVar3 & 0xffffffff,param_3,param_4,param_5,param_6
                           );
      if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
      local_14 = _libssh2_wait_socket(param_1,tVar2);
    } while (local_14 == 0);
    uVar1 = (ulong)local_14;
  }
  return uVar1;
}



undefined8 FUN_00143330(long param_1,undefined8 param_2,uint param_3,void *param_4)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined *puVar4;
  undefined8 uVar5;
  long lVar6;
  long in_FS_OFFSET;
  uint local_34;
  undefined *local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd180) == 0) {
    *(undefined8 *)(param_1 + 0xd1b0) = 0;
    *(undefined8 *)(param_1 + 0xd1c0) = 0;
    *(undefined4 *)(param_1 + 0xd1c8) = 0;
    *(undefined4 *)(param_1 + 0xd1cc) = 1;
    *(undefined8 *)(param_1 + 0xd1d0) = 0;
    *(undefined8 *)(param_1 + 0xd1d8) = 0;
    memset((void *)(param_1 + 0xd1e0),0,8);
    *(ulong *)(param_1 + 0xd1a0) = (ulong)(param_3 + 0x37);
    puVar4 = (undefined *)
             ((void*(*)())(param_1 + 8))
                       (*(undefined8 *)(param_1 + 0xd1a0),param_1,*(undefined8 *)(param_1 + 0xd1a0),
                        param_1);
    *(undefined **)(param_1 + 0xd188) = puVar4;
    if (puVar4 == (undefined *)0x0) {
      local_28 = puVar4;
      uVar5 = _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for keyboard-interactive authentication");
      goto LAB_001443a5;
    }
    local_28 = puVar4 + 1;
    *puVar4 = 0x32;
    _libssh2_store_str(&local_28,param_2,(ulong)param_3);
    _libssh2_store_str(&local_28,"ssh-connection",0xe);
    _libssh2_store_str(&local_28,"keyboard-interactive",0x14);
    _libssh2_store_u32(&local_28,0);
    _libssh2_store_u32(&local_28,0);
    *(undefined4 *)(param_1 + 0xd180) = 2;
  }
  if (*(int *)(param_1 + 0xd180) != 2) {
LAB_001435ce:
    do {
      if (*(int *)(param_1 + 0xd180) == 3) {
        iVar1 = _libssh2_packet_requirev
                          (param_1,&DAT_0014a9ac,param_1 + 0xd188,param_1 + 0xd190,0,0,0,
                           param_1 + 0xd1e0);
        if (iVar1 == -0x25) {
          uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
          goto LAB_001443a5;
        }
        if ((iVar1 != 0) || (*(long *)(param_1 + 0xd190) == 0)) {
          *(undefined4 *)(param_1 + 0xd180) = 0;
          uVar5 = _libssh2_error(param_1,0xffffffee,"Waiting for keyboard USERAUTH response");
          goto LAB_001443a5;
        }
        if (**(char **)(param_1 + 0xd188) == '4') {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xd188),param_1,*(undefined8 *)(param_1 + 0xd188),
                     param_1);
          *(undefined8 *)(param_1 + 0xd188) = 0;
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
          *(undefined4 *)(param_1 + 0xd180) = 0;
          uVar5 = 0;
          goto LAB_001443a5;
        }
        if (**(char **)(param_1 + 0xd188) == '3') {
          ((void*(*)())(param_1 + 0x18))
                    (*(undefined8 *)(param_1 + 0xd188),param_1,*(undefined8 *)(param_1 + 0xd188),
                     param_1);
          *(undefined8 *)(param_1 + 0xd188) = 0;
          *(undefined4 *)(param_1 + 0xd180) = 0;
          uVar5 = _libssh2_error(param_1,0xffffffee,"Authentication failed (keyboard-interactive)");
          goto LAB_001443a5;
        }
        local_28 = (undefined *)(*(long *)(param_1 + 0xd188) + 1);
        if (*(ulong *)(param_1 + 0xd190) < 5) {
          _libssh2_error(param_1,0xffffffda,"userauth keyboard data buffer too smallto get length");
        }
        else {
          uVar2 = _libssh2_ntohu32(local_28);
          *(undefined4 *)(param_1 + 0xd1a8) = uVar2;
          local_28 = local_28 + 4;
          if (*(int *)(param_1 + 0xd1a8) == 0) {
LAB_001438c6:
            if ((undefined *)(*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188)) <
                local_28 + 4) {
              _libssh2_error(param_1,0xffffffda,
                             "userauth keyboard data buffer too smallfor auth instruction length");
            }
            else {
              uVar2 = _libssh2_ntohu32(local_28);
              *(undefined4 *)(param_1 + 0xd1b8) = uVar2;
              local_28 = local_28 + 4;
              if (*(int *)(param_1 + 0xd1b8) == 0) {
LAB_00143a2a:
                if ((undefined *)(*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188)) <
                    local_28 + 4) {
                  _libssh2_error(param_1,0xffffffda,
                                                                  
                                 "userauth keyboard data buffer too smallfor auth language tag length"
                                );
                }
                else {
                  uVar3 = _libssh2_ntohu32(local_28);
                  local_28 = local_28 + 4;
                  if ((undefined *)(*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188)) <
                      local_28 + uVar3) {
                    _libssh2_error(param_1,0xffffffda,
                                   "userauth keyboard data buffer too smallfor auth language tag");
                  }
                  else {
                    local_28 = local_28 + uVar3;
                    if ((undefined *)(*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188)) <
                        local_28 + 4) {
                      _libssh2_error(param_1,0xffffffda,
                                                                          
                                     "userauth keyboard data buffer too smallfor auth num keyboard prompts"
                                    );
                    }
                    else {
                      uVar2 = _libssh2_ntohu32(local_28);
                      *(undefined4 *)(param_1 + 0xd1c8) = uVar2;
                      local_28 = local_28 + 4;
                      if (*(uint *)(param_1 + 0xd1c8) < 0x65) {
                        if (*(int *)(param_1 + 0xd1c8) == 0) {
LAB_00143e8e:
                         *(undefined8 *)(param_1 + 0xd1a0) = 5;
                          local_34 = 0;
                          while (local_34 < *(uint *)(param_1 + 0xd1c8)) {
                            if (-*(long *)(param_1 + 0xd1a0) - 5U <
                                (ulong)*(uint *)(*(long *)(param_1 + 0xd1d8) +
                                                 (ulong)local_34 * 0x10 + 8)) {
                              _libssh2_error(param_1,0xfffffffa,
                                                                                          
                                             "Unable to allocate memory for keyboard-interactive response packet"
                                            );
                              goto LAB_00144161;
                            }
                            *(long *)(param_1 + 0xd1a0) =
                                 *(long *)(param_1 + 0xd1a0) +
                                 (ulong)(*(int *)(*(long *)(param_1 + 0xd1d8) +
                                                  (ulong)local_34 * 0x10 + 8) + 4);
                            local_34 = local_34 + 1;
                          }
                          ((void*(*)())(param_1 + 0x18))
                                    (*(undefined8 *)(param_1 + 0xd188),param_1,
                                     *(undefined8 *)(param_1 + 0xd188),param_1);
                          local_28 = (undefined *)
                                     ((void*(*)())(param_1 + 8))
                                               (*(undefined8 *)(param_1 + 0xd1a0),param_1,
                                                *(undefined8 *)(param_1 + 0xd1a0),param_1);
                          *(undefined **)(param_1 + 0xd188) = local_28;
                          if (local_28 != (undefined *)0x0) {
                            *local_28 = 0x3d;
                            local_28 = local_28 + 1;
                            _libssh2_store_u32(&local_28,(ulong)*(uint *)(param_1 + 0xd1c8) );
                            local_34 = 0;
                            while (local_34 < *(uint *)(param_1 + 0xd1c8)) {
                              uVar5 = *(undefined8 *)
                                       (*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10);
                              _libssh2_store_str(&local_28,uVar5,
                                                 (ulong)*(uint *)(*(long *)(param_1 + 0xd1d8) +
                                                                  (ulong)local_34 * 0x10 + 8))
                              ;
                              local_34 = local_34 + 1;
                            }
                            *(undefined4 *)(param_1 + 0xd180) = 4;
                            goto LAB_001440ca;
                          }
                          _libssh2_error(param_1,0xfffffffa,
                                                                                  
                                         "Unable to allocate memory for keyboard-interactive response packet"
                                        );
                        }
                        else {
                          lVar6 = (ulong)*(uint *)(param_1 + 0xd1c8) << 4;
                          uVar5 = _libssh2_calloc(param_1,lVar6);
                          *(undefined8 *)(param_1 + 0xd1d0) = uVar5;
                          if (*(long *)(param_1 + 0xd1d0) == 0) {
                            _libssh2_error(param_1,0xfffffffa,
                                                                                      
                                           "Unable to allocate memory for keyboard-interactive prompts array"
                                          );
                          }
                          else {
                            lVar6 = (ulong)*(uint *)(param_1 + 0xd1c8) << 4;
                            uVar5 = _libssh2_calloc(param_1,lVar6);
                            *(undefined8 *)(param_1 + 0xd1d8) = uVar5;
                            if (*(long *)(param_1 + 0xd1d8) != 0) {
                              local_34 = 0;
                              while (local_34 < *(uint *)(param_1 + 0xd1c8)) {
                                if ((undefined *)
                                    (*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188)) <
                                    local_28 + 4) {
                                  _libssh2_error(param_1,0xffffffda,
                                                                                                  
                                                 "userauth keyboard data buffer too small for auth keyboard prompt length"
                                                );
                                  goto LAB_00144161;
                                }
                                lVar6 = *(long *)(param_1 + 0xd1d0);
                                uVar2 = _libssh2_ntohu32(local_28);
                                *(undefined4 *)(lVar6 + (ulong)local_34 * 0x10 + 8) = uVar2;
                                local_28 = local_28 + 4;
                                lVar6 = *(long *)(param_1 + 0xd1d0);
                                uVar5 = _libssh2_calloc(param_1, 4);
                                *(undefined8 *)(lVar6 + (ulong)local_34 * 0x10) = uVar5;
                                if (*(long *)(*(long *)(param_1 + 0xd1d0) + (ulong)local_34 * 0x10)
                                    == 0) {
                                  _libssh2_error(param_1,0xfffffffa,
                                                                                                  
                                                 "Unable to allocate memory for keyboard-interactive prompt message"
                                                );
                                  goto LAB_00144161;
                                }
                                if ((undefined *)
                                    (*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188)) <
                                    local_28 +
                                    *(uint *)(*(long *)(param_1 + 0xd1d0) + (ulong)local_34 * 0x10 +
                                             8)) {
                                  _libssh2_error(param_1,0xffffffda,
                                                                                                  
                                                 "userauth keyboard data buffer too small for auth keyboard prompt"
                                                );
                                  goto LAB_00144161;
                                }
                                memcpy(*(void **)(*(long *)(param_1 + 0xd1d0) +
                                                 (ulong)local_34 * 0x10),local_28,
                                       (ulong)*(uint *)(*(long *)(param_1 + 0xd1d0) +
                                                        (ulong)local_34 * 0x10 + 8));
                                local_28 = local_28 +
                                           *(uint *)(*(long *)(param_1 + 0xd1d0) +
                                                     (ulong)local_34 * 0x10 + 8);
                                if ((undefined *)
                                    (*(long *)(param_1 + 0xd188) + *(long *)(param_1 + 0xd190)) <=
                                    local_28) {
                                  _libssh2_error(param_1,0xffffffda,
                                                                                                  
                                                 "userauth keyboard data buffer too small for auth keyboard prompt echo"
                                                );
                                  goto LAB_00144161;
                                }
                                *(undefined *)
                                 (*(long *)(param_1 + 0xd1d0) + (ulong)local_34 * 0x10 + 0xc) =
                                     *local_28;
                                local_34 = local_34 + 1;
                                local_28 = local_28 + 1;
                              }
                              goto LAB_00143e8e;
                            }
                            _libssh2_error(param_1,0xfffffffa,
                                                                                      
                                           "Unable to allocate memory for keyboard-interactive responses array"
                                          );
                          }
                        }
                      }
                      else {
                        _libssh2_error(param_1,0xffffffd7,
                                       "Too many replies for keyboard-interactive prompts");
                      }
                    }
                  }
                }
              }
              else {
                uVar5 = ((void*(*)())(param_1 + 8))
                                  ((ulong)*(uint *)(param_1 + 0xd1b8),param_1,param_1,
                                   (ulong)*(uint *)(param_1 + 0xd1b8));
                *(undefined8 *)(param_1 + 0xd1c0) = uVar5;
                if (*(long *)(param_1 + 0xd1c0) == 0) {
                  _libssh2_error(param_1,0xfffffffa,
                                                                  
                                 "Unable to allocate memory for keyboard-interactive \'instruction\' request field"
                                );
                }
                else {
                  if (local_28 + *(uint *)(param_1 + 0xd1b8) <=
                      (undefined *)(*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188))) {
                    memcpy(*(void **)(param_1 + 0xd1c0),local_28,(ulong)*(uint *)(param_1 + 0xd1b8))
                    ;
                    local_28 = local_28 + *(uint *)(param_1 + 0xd1b8);
                    goto LAB_00143a2a;
                  }
                  _libssh2_error(param_1,0xffffffda,
                                 "userauth keyboard data buffer too smallfor auth instruction");
                }
              }
            }
          }
          else {
            uVar5 = ((void*(*)())(param_1 + 8))
                              ((ulong)*(uint *)(param_1 + 0xd1a8),param_1,param_1,
                               (ulong)*(uint *)(param_1 + 0xd1a8));
            *(undefined8 *)(param_1 + 0xd1b0) = uVar5;
            if (*(long *)(param_1 + 0xd1b0) == 0) {
              _libssh2_error(param_1,0xfffffffa,
                                                          
                             "Unable to allocate memory for keyboard-interactive \'name\' request field"
                            );
            }
            else {
              if (local_28 + *(long *)(param_1 + 0xd0a0) <=
                  (undefined *)(*(long *)(param_1 + 0xd190) + *(long *)(param_1 + 0xd188))) {
                memcpy(*(void **)(param_1 + 0xd1b0),local_28,(ulong)*(uint *)(param_1 + 0xd1a8));
                local_28 = local_28 + *(uint *)(param_1 + 0xd1a8);
                goto LAB_001438c6;
              }
              _libssh2_error(param_1,0xffffffda,
                             "userauth keyboard data buffer too smallfor auth name");
            }
          }
        }
      }
      else {
LAB_001440ca:
        if (*(int *)(param_1 + 0xd180) == 4) {
          iVar1 = _libssh2_transport_send
                            (param_1,*(undefined8 *)(param_1 + 0xd188),
                             *(undefined8 *)(param_1 + 0xd1a0),0,0);
          if (iVar1 == -0x25) {
            uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
            goto LAB_001443a5;
          }
          if (iVar1 == 0) {
            *(undefined4 *)(param_1 + 0xd1cc) = 0;
          }
          else {
            _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-keyboard-interactive request"
                          );
          }
        }
      }
LAB_00144161:
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd188),param_1,*(undefined8 *)(param_1 + 0xd188));
      *(undefined8 *)(param_1 + 0xd188) = 0;
      if (*(long *)(param_1 + 0xd1d0) != 0) {
        local_34 = 0;
        while (local_34 < *(uint *)(param_1 + 0xd1c8)) {
          uVar5 = *(undefined8 *)(*(long *)(param_1 + 0xd1d0) + (ulong)local_34 * 0x10);
          ((void*(*)())(param_1 + 0x18))(uVar5,param_1,uVar5);
          *(undefined8 *)(*(long *)(param_1 + 0xd1d0) + (ulong)local_34 * 0x10) = 0;
          local_34 = local_34 + 1;
        }
      }
      if (*(long *)(param_1 + 0xd1d8) != 0) {
        local_34 = 0;
        while (local_34 < *(uint *)(param_1 + 0xd1c8)) {
          uVar5 = *(undefined8 *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10);
          ((void*(*)())(param_1 + 0x18))(uVar5,param_1,uVar5);
          *(undefined8 *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10) = 0;
          local_34 = local_34 + 1;
        }
      }
      if (*(long *)(param_1 + 0xd1d0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd1d0),param_1,*(undefined8 *)(param_1 + 0xd1d0),
                   param_1);
        *(undefined8 *)(param_1 + 0xd1d0) = 0;
      }
      if (*(long *)(param_1 + 0xd1d8) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd1d8),param_1,*(undefined8 *)(param_1 + 0xd1d8),
                   param_1);
        *(undefined8 *)(param_1 + 0xd1d8) = 0;
      }
      if (*(long *)(param_1 + 0xd1b0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd1b0),param_1,*(undefined8 *)(param_1 + 0xd1b0),
                   param_1);
        *(undefined8 *)(param_1 + 0xd1b0) = 0;
      }
      if (*(long *)(param_1 + 0xd1c0) != 0) {
        ((void*(*)())(param_1 + 0x18))
                  (*(undefined8 *)(param_1 + 0xd1c0),param_1,*(undefined8 *)(param_1 + 0xd1c0),
                   param_1);
        *(undefined8 *)(param_1 + 0xd1c0) = 0;
      }
      if (*(int *)(param_1 + 0xd1cc) != 0) goto code_r0x0014437d;
      *(undefined4 *)(param_1 + 0xd180) = 3;
    } while( 1 );
  }
  iVar1 = _libssh2_transport_send
                    (param_1,*(undefined8 *)(param_1 + 0xd188),*(undefined8 *)(param_1 + 0xd1a0),0,0
                    );
  if (iVar1 == -0x25) {
    uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
  }
  else {
    if (iVar1 == 0) {
      ((void*(*)())(param_1 + 0x18))
                (*(undefined8 *)(param_1 + 0xd188),param_1,*(undefined8 *)(param_1 + 0xd188),param_1
                );
      *(undefined8 *)(param_1 + 0xd188) = 0;
      *(undefined4 *)(param_1 + 0xd180) = 3;
      goto LAB_001435ce;
    }
    ((void*(*)())(param_1 + 0x18))
              (*(undefined8 *)(param_1 + 0xd188),param_1,*(undefined8 *)(param_1 + 0xd188),param_1);
    *(undefined8 *)(param_1 + 0xd188) = 0;
    *(undefined4 *)(param_1 + 0xd180) = 0;
    uVar5 = _libssh2_error(param_1,0xfffffff9,"Unable to send keyboard-interactive request");
  }
  goto LAB_001443a5;
code_r0x0014437d:
  *(undefined4 *)(param_1 + 0xd180) = 0;
  uVar5 = 0xffffffff;
LAB_001443a5:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong libssh2_userauth_keyboard_interactive_ex
                (long param_1,undefined8 param_2,uint param_3,undefined8 param_4)

{
  time_t tVar1;
  uint local_14;
  
  tVar1 = time((time_t *)0x0);
  do {
    local_14 = FUN_00143330(param_1,param_2,(ulong)param_3,param_4);
    if ((local_14 != 0xffffffdb) || (*(int *)(param_1 + 0x94) == 0)) break;
    local_14 = _libssh2_wait_socket(param_1,tVar1);
  } while (local_14 == 0);
  return (ulong)local_14;
}



char * libssh2_version(int param_1)

{
  char *pcVar1;
  
  if (param_1 < 0x10901) {
    pcVar1 = "1.9.0_DEV";
  }
  else {
    pcVar1 = (char *)0x0;
  }
  return pcVar1;
}



