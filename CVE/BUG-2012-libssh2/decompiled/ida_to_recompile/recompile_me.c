//#include <openssl/bn.h>
#include <emmintrin.h>
#include <stdio.h>
#include <stdlib.h>
/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_88F0();
// My openssl definitions
__int64* BN_new(QWORD, QWORD);
__int64* PEM_read_bio_PrivateKey(QWORD, QWORD, QWORD, QWORD);
__int64* PEM_read_bio_ECPrivateKey(QWORD, QWORD, QWORD, QWORD);
__int64* PEM_read_bio_RSAPrivateKey(QWORD, QWORD, QWORD, QWORD);
__int64* PEM_read_bio_DSAPrivateKey(QWORD, QWORD, QWORD, QWORD);

// Other function declarations
__int64 _libssh2_error(QWORD, QWORD, QWORD);



// void *memset(void *s, int c, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
 int close(int fd);
// void *memchr(const void *s, int c, size_t n);
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int strncmp(const char *s1, const char *s2, size_t n);
// void *malloc(size_t size);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *fgets(char *s, int n, FILE *stream);
// void free(void *ptr);
// size_t strlen(const char *s);
const unsigned __int16 **__ctype_b_loc(void);
// char *strrchr(const char *s, int c);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// void rewind(FILE *stream);
// __int64 strtol(const char *nptr, char **endptr, int base);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void *memmove(void *dest, const void *src, size_t n);
// char *strchr(const char *s, int c);
// int socket(int domain, int type, int protocol);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
int *__errno_location(void);
// int strcmp(const char *s1, const char *s2);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int memcmp(const void *s1, const void *s2, size_t n);
// void *calloc(size_t nmemb, size_t size);
// int feof(FILE *stream);
// int fclose(FILE *stream);
// char *strncpy(char *dest, const char *src, size_t n);
// double difftime(time_t time1, time_t time0);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// void *realloc(void *ptr, size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
// int fcntl(int fd, int cmd, ...);
__int64  _libssh2_packet_ask(size_t n); // idb
// time_t time(time_t *timer);
char *start();
__int64 sub_9B20();
char *sub_9B70();
__int64 sub_9BB0();
signed __int64  sub_9BBA(__int64 a1, __int64 a2, unsigned int a3);
__int64  libssh2_rsa_new(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, unsigned int a13, __int64 a14, unsigned int a15, __int64 a16, unsigned int a17);
signed __int64  libssh2_rsa_sha1_verify(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
__int64  libssh2_dsa_new(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, __int64 a8, unsigned int a9, __int64 a10, __int64 a11);
signed __int64  libssh2_dsa_sha1_verify(__int64 a1, __int64 a2, __int64 a3, signed __int64 a4);
__int64  libssh2_ecdsa_get_curve_type(__int64 a1);
signed __int64  libssh2_ecdsa_curve_type_from_name(const char *a1, signed int *a2);
signed __int64  libssh2_ecdsa_curve_name_with_octal_new(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4);
signed __int64  libssh2_ecdsa_verify(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7);
_BOOL4  libssh2_cipher_init(_QWORD *a1, __int64 (*a2)(void), __int64 a3, __int64 a4, unsigned int a5);
_BOOL4  libssh2_cipher_crypt(_QWORD *a1, __int64 a2, __int64 a3, void *a4, size_t a5);
__int64 libssh2_openssl_crypto_init();
void libssh2_openssl_crypto_exit();
__int64  sub_A551(void *a1, int a2, __int64 a3, const char *a4);
signed __int64  sub_A5B8(_QWORD *a1, __int64 ( *a2)(__int64, _QWORD, _QWORD, __int64), __int64 a3, unsigned int a4, __int64 a5);
signed __int64  sub_A652(_QWORD *a1, __int64 ( *a2)(__int64, _QWORD, _QWORD, __int64), __int64 a3, __int64 a4);
__int64  libssh2_rsa_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void * sub_A76F(__int64 a1, __int64 a2, _QWORD *a3);
__int64  sub_A8CA(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6);
signed __int64  sub_AA25(__int64 a1);
__int64  sub_AC2D(__int64 a1, __int64 a2, void **a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7);
signed __int64  sub_B01B(_QWORD *a1, __int64 a2, char *a3, __int64 a4);
__int64  libssh2_rsa_new_private(_QWORD *a1, __int64 a2, char *a3, __int64 a4);
__int64  libssh2_dsa_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void * sub_B2B8(__int64 a1, __int64 a2, _QWORD *a3);
__int64  sub_B4AE(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6);
__int64  sub_B609(__int64 a1, __int64 a2, void **a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7);
signed __int64  sub_B90E(_QWORD *a1, __int64 a2, char *a3, __int64 a4);
__int64  libssh2_dsa_new_private(_QWORD *a1, __int64 a2, char *a3, __int64 a4);
__int64  libssh2_ecdsa_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  libssh2_curve25519_new(__int64 a1, _QWORD *a2, void **a3, void **a4);
signed __int64  sub_BEB8(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6);
signed __int64  sub_C0F3(signed __int64 a1, __int64 a2, void **a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7);
signed __int64  libssh2_ed25519_new_private(_QWORD *a1, signed __int64 a2, char *a3, __int64 a4);
__int64  libssh2_ed25519_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64  libssh2_ed25519_new_public(__int64 *a1, __int64 a2, __int64 a3, unsigned __int8 a4);
signed __int64  libssh2_rsa_sha1_sign(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5, _QWORD *a6);
signed __int64  libssh2_dsa_sha1_sign(__int64 a1, __int64 a2, __int64 a3, char *a4);
signed __int64  libssh2_ecdsa_sign(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void **a5, size_t *a6);
signed __int64  libssh2_sha1_init(_QWORD *a1);
signed __int64  libssh2_sha1(__int64 a1, __int64 a2, __int64 a3);
signed __int64  libssh2_sha256_init(_QWORD *a1);
signed __int64  libssh2_sha256(__int64 a1, __int64 a2, __int64 a3);
signed __int64  libssh2_sha384_init(_QWORD *a1);
signed __int64  libssh2_sha384(__int64 a1, __int64 a2, __int64 a3);
signed __int64  libssh2_sha512_init(_QWORD *a1);
signed __int64  libssh2_sha512(__int64 a1, __int64 a2, __int64 a3);
signed __int64  libssh2_md5_init(_QWORD *a1);
__int64  sub_D1B9(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, __int64 a6);
__int64  sub_D517(__int64 a1, unsigned int a2, __int64 a3, void **a4, _QWORD *a5, _QWORD *a6, size_t *a7, _QWORD *a8);
signed __int64  sub_D7B2(_QWORD *a1, __int64 a2, char *a3, __int64 a4);
signed __int64  libssh2_ecdsa_new_private(_QWORD *a1, __int64 a2, char *a3, __int64 a4);
signed __int64  libssh2_ecdsa_create_key(__int64 a1, __int64 *a2, void **a3, unsigned __int64 *a4, unsigned int a5);
signed __int64  libssh2_ecdh_gen_k(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64  libssh2_ed25519_sign(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 a5, __int64 a6);
signed __int64  libssh2_curve25519_gen_k(_QWORD *a1, __int64 a2, __int64 a3);
signed __int64  libssh2_ed25519_verify(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64  sub_E23C(signed __int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, char *a6, __int64 a7);
__int64  libssh2_pub_priv_keyfile(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, char *a6, __int64 a7);
signed __int64  sub_E731(signed __int64 a1, _QWORD *a2, const char *a3, void **a4, _QWORD *a5, _QWORD *a6, size_t *a7, __int64 a8, __int64 a9, __int64 a10);
signed __int64  read_openssh_private_key_from_memory(_QWORD *a1, signed __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64  libssh2_pub_priv_keyfilememory(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, __int64 a6, __int64 a7, __int64 a8);
__int64 * libssh2_dh_init(__int64 *a1, __int64 a2);
__int64  libssh2_dh_key_pair(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int a5, __int64 a6);
__int64  libssh2_dh_secret(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
_QWORD * libssh2_dh_dtor(_QWORD *a1, __int64 a2);
__int64  sub_EDD7(_QWORD *a1);
__int64  sub_EF3B(unsigned int *a1, __int64 a2);
__int64  sub_F1EF(__int64 a1);
__int64  sub_F241(__int64 a1, void **a2, size_t *a3, __int64 a4, __int64 a5, __int64 *a6);
__int64  sub_F63E(_QWORD *a1);
__int64  sub_FB45(_QWORD *a1);
signed __int64  sub_FC0B(__int64 a1);
__int64  libssh2_agent_init(__int64 a1);
__int64  libssh2_agent_connect(__int64 a1);
__int64  libssh2_agent_list_identities(_QWORD *a1);
signed __int64  libssh2_agent_get_identity(__int64 a1, signed __int64 *a2, __int64 a3);
__int64  libssh2_agent_userauth(_QWORD *a1, const char *a2, _QWORD *a3);
__int64  libssh2_agent_disconnect(__int64 a1);
__int64  libssh2_agent_free(_QWORD *a1);
size_t  libssh2_agent_set_identity_path(_QWORD *a1, const char *a2);
__int64  libssh2_agent_get_identity_path(__int64 a1);
unsigned __int64  sub_100C8(__int64 a1, __int64 a2, __int64 a3);
signed __int64  bcrypt_pbkdf(__int64 a1, __int64 a2, void *a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6, unsigned int a7);
int * Blowfish_encipher(_DWORD *a1, int *a2, int *a3);
int * Blowfish_decipher(_DWORD *a1, int *a2, int *a3);
char * Blowfish_initstate(char *a1);
__int64  Blowfish_stream2word(__int64 a1, unsigned __int16 a2, _WORD *a3);
unsigned __int64  Blowfish_expand0state(__int64 a1, __int64 a2, unsigned __int16 a3);
unsigned __int64  Blowfish_expandstate(__int64 a1, __int64 a2, unsigned __int16 a3, __int64 a4, unsigned __int16 a5);
__int64  blf_key(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64  blf_enc(__int64 a1, __int64 a2, unsigned __int16 a3);
__int64  blf_dec(__int64 a1, __int64 a2, unsigned __int16 a3);
unsigned __int64  blf_ecb_encrypt(__int64 a1, __int64 a2, unsigned int a3);
unsigned __int64  blf_ecb_decrypt(__int64 a1, __int64 a2, unsigned int a3);
unsigned __int64  blf_cbc_encrypt(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
unsigned __int64  blf_cbc_decrypt(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64  libssh2_channel_nextid(__int64 a1);
__int64  libssh2_channel_locate(__int64 a1, int a2);
__int64  libssh2_channel_open(size_t a1, const void *a2, unsigned int a3, unsigned int a4, unsigned int a5, __int64 a6, __int64 a7);
__int64  libssh2_channel_open_ex(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int a5, __int64 a6, unsigned int a7);
__int64  sub_133C9(__int64 a1, const char *a2, unsigned int a3, char *a4, unsigned int a5);
__int64  libssh2_channel_direct_tcpip_ex(__int64 a1, const char *a2, unsigned int a3, char *a4, unsigned int a5);
__int64  sub_13699(__int64 a1, char *a2, unsigned int a3, _DWORD *a4, int a5);
__int64  libssh2_channel_forward_listen_ex(__int64 a1, char *a2, unsigned int a3, _DWORD *a4, int a5);
signed __int64  libssh2_channel_forward_cancel(__int64 a1);
signed __int64  libssh2_channel_forward_cancel(__int64 a1);
__int64  sub_13F9B(__int64 a1);
__int64  libssh2_channel_forward_accept(__int64 a1);
__int64  sub_140FD(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5);
signed __int64  libssh2_channel_setenv_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5);
__int64  sub_1453B(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9);
__int64  sub_14889(__int64 a1, __int64 a2, signed int a3);
signed __int64  libssh2_channel_request_auth_agent(__int64 a1);
signed __int64  libssh2_channel_request_pty_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9);
__int64  sub_14D37(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5);
signed __int64  libssh2_channel_request_pty_size_ex(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5);
__int64  sub_14FC8(__int64 a1, int a2, const char *a3, char *a4, unsigned int a5);
signed __int64  libssh2_channel_x11_req_ex(__int64 a1, int a2, const char *a3, char *a4, unsigned int a5);
__int64  libssh2_channel_process_startup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
//signed __int64  libssh2_channel_process_startup(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5);
__int64  libssh2_channel_set_blocking(__int64 a1, unsigned int a2);
__int64  libssh2_channel_flush(__int64 a1, int a2);
signed __int64  libssh2_channel_flush_ex(__int64 a1, unsigned int a2);
__int64  libssh2_channel_get_exit_status(__int64 a1);
__int64  libssh2_channel_get_exit_signal(__int64 a1, void **a2, size_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7);
__int64  libssh2_channel_receive_window_adjust(__int64 a1, unsigned int a2, char a3, _DWORD *a4);
//signed __int64  libssh2_channel_receive_window_adjust(__int64 a1, unsigned int a2, unsigned __int8 a3);
signed __int64  libssh2_channel_receive_window_adjust2(__int64 a1, unsigned int a2, unsigned __int8 a3, __int64 a4);
signed __int64  libssh2_channel_extended_data(__int64 a1, int a2);
signed __int64  libssh2_channel_handle_extended_data2(__int64 a1, unsigned int a2);
__int64  libssh2_channel_handle_extended_data(__int64 a1, unsigned int a2);
unsigned __int64  libssh2_channel_read(__int64 a1, int a2, __int64 a3, unsigned __int64 a4);
signed __int64  libssh2_channel_read_ex(__int64 a1, unsigned int a2, __int64 a3, unsigned __int64 a4);
__int64  libssh2_channel_packet_data_len(__int64 a1, int a2);
signed __int64  libssh2_channel_write(__int64 a1, unsigned int a2, __int64 a3, unsigned __int64 a4);
signed __int64  libssh2_channel_write_ex(__int64 a1, unsigned int a2, __int64 a3, __int64 a4);
__int64  sub_16C6B(__int64 a1);
signed __int64  libssh2_channel_send_eof(__int64 a1);
signed __int64  libssh2_channel_eof(__int64 a1);
__int64  sub_16E8F(__int64 a1);
signed __int64  libssh2_channel_wait_eof(__int64 a1);
signed __int64  libssh2_channel_close(__int64 a1);
signed __int64  libssh2_channel_close(__int64 a1);
__int64  sub_17248(__int64 a1);
signed __int64  libssh2_channel_wait_closed(__int64 a1);
signed __int64  libssh2_channel_free(__int64 a1);
signed __int64  libssh2_channel_free(__int64 a1);
__int64  libssh2_channel_window_read_ex(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64  libssh2_channel_window_write_ex(__int64 a1, _QWORD *a2);
__int64 sub_1779A();
__int64  sub_177BD(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
char *** libssh2_comp_methods(__int64 a1);
signed __int64  sub_1781B(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8);
__int64  sub_178EC(__int64 a1, __int64 a2, __int64 a3, unsigned int **a4);
__int64  sub_1793A(__int64 a1, _QWORD *a2);
__int64  sub_179A5(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8);
char **libssh2_crypt_methods();
__int64  libssh2_init(int a1);
__int64 libssh2_exit();
__int64 libssh2_init_if_needed();
signed __int64  sub_17B2C(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4);
signed __int64  sub_17C82(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64  sub_17D21(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5);
__int64  sub_17DCB(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, _QWORD *a6);
signed __int64  sub_17E2F(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 *a6);
__int64  sub_17F3B(__int64 a1, _QWORD *a2);
signed __int64  sub_17F74(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4);
signed __int64  sub_1812F(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64  sub_181CE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5);
__int64  sub_18278(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6);
signed __int64  sub_182E8(__int64 a1, _QWORD *a2, _QWORD *a3, int a4, __int64 a5, __int64 *a6);
__int64  sub_1843E(__int64 a1, _QWORD *a2);
signed __int64  sub_18477(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4);
__int64  sub_186D2(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64  sub_18778(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5);
__int64  sub_18838(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 *a6);
signed __int64  sub_1898A(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 *a6);
__int64  sub_18C7B(__int64 a1, _QWORD *a2);
signed __int64  sub_18CBB(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4);
signed __int64  sub_18DD6(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64  sub_18E7B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5);
__int64  sub_18F3B(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, _QWORD *a6);
__int64  sub_18FAD(__int64 a1, __int64 a2, __int64 a3, int a4, _QWORD *a5, _QWORD *a6);
__int64  sub_19013(__int64 a1, _QWORD *a2);
char ***libssh2_hostkey_methods();
signed __int64  libssh2_hostkey_hash(_DWORD *a1, int a2);
signed __int64  sub_190E7(const void *a1, unsigned __int64 a2);
__int64  libssh2_session_hostkey(__int64 a1, _QWORD *a2, _DWORD *a3);
__int64  libssh2_keepalive_config(__int64 a1, int a2, int a3);
__int64  libssh2_keepalive_send(__int64 a1, _DWORD *a2);
signed __int64  sub_19461(signed __int64 a1, signed __int64 a2, __int64 a3, unsigned int a4, char a5, unsigned __int8 a6, __int64 a7, __int64 a8, __int64 a9);
signed __int64  sub_1B899(signed __int64 a1, signed __int64 a2, __int64 a3, unsigned int a4, char a5, unsigned __int8 a6, __int64 a7, __int64 a8, __int64 a9);
signed __int64  sub_1DCD1(signed __int64 a1, __int64 a2);
signed __int64  sub_1DDFB(__int64 a1, __int64 a2, __int64 ( *a3)(__int64, __int64, _QWORD, signed __int64, signed __int64, signed __int64, _QWORD, _QWORD, signed __int64));
signed __int64  sub_1DF27(__int64 a1, __int64 a2);
signed __int64  sub_1DF53(__int64 a1, __int64 a2);
signed __int64  sub_1DF7F(signed __int64 a1, signed __int64 a2);
signed __int64  sub_1E380(signed __int64 a1, signed __int64 a2);
signed __int64  sub_1E781(const char *a1, signed int *a2);
signed __int64  sub_1E82B(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
signed __int64  sub_224C8(__int64 a1, __int64 a2);
__int64  sub_2287B(signed __int64 a1, signed __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64  sub_2474C(signed __int64 a1, __int64 a2);
signed __int64  sub_24B1D(const char ***a1);
signed __int64  sub_24B99(__int64 a1, __int64 a2, const char ***a3);
__int64  sub_24C56(__int64 a1, __int64 a2);
char * sub_2550C(const char *a1, size_t a2, const char *a3, size_t a4);
const char ** sub_2561D(const char *a1, size_t a2, const char ***a3);
signed __int64  sub_2568D(__int64 a1, char a2, const char *a3, size_t a4);
signed __int64  sub_25897(__int64 a1, const char *a2, size_t a3, const char *a4, size_t a5);
signed __int64  sub_25AE3(__int64 a1, __int64 a2, const char *a3, size_t a4);
signed __int64  sub_25C6F(__int64 a1, __int64 a2, const char *a3, size_t a4);
signed __int64  sub_25DFB(__int64 a1, __int64 a2, const char *a3, size_t a4);
signed __int64  sub_25F8E(__int64 a1, __int64 a2, unsigned int a3);
signed __int64  libssh2_kex_exchange(__int64 a1, __int64 a2, _DWORD *a3);
__int64  libssh2_session_method_pref(__int64 a1, __int64 a2, const char *a3);
__int64  libssh2_session_supported_algs(__int64 a1, __int64 a2, _QWORD *a3);
__int64  sub_26D8D(__int64 a1, _QWORD *a2);
_QWORD * libssh2_knownhost_init(__int64 a1);
signed __int64  sub_26EFD(__int64 a1);
__int64  sub_26F71(__int64 *a1, const char *a2, char *a3, void *a4, size_t a5, char *a6, size_t a7, const void *a8, __int64 a9, __int64 a10, signed __int64 *a11);
__int64  libssh2_knownhost_add(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, unsigned int a6, signed __int64 *a7);
__int64  libssh2_knownhost_addc(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, const void *a6, __int64 a7, unsigned int a8, signed __int64 *a9);
signed __int64  sub_27552(_QWORD *a1, char *a2, unsigned int a3, char *a4, __int64 a5, int a6, signed __int64 *a7);
signed __int64  libssh2_knownhost_check(_QWORD *a1, char *a2, char *a3, __int64 a4, int a5, signed __int64 *a6);
signed __int64  libssh2_knownhost_checkp(_QWORD *a1, char *a2, unsigned int a3, char *a4, __int64 a5, int a6, signed __int64 *a7);
__int64  libssh2_knownhost_del(__int64 *a1, _QWORD *a2);
__int64  libssh2_knownhost_free(__int64 *a1);
__int64  sub_27C36(__int64 *a1, char *a2, __int64 a3, void *a4, size_t a5, char *a6, size_t a7, int a8, const void *a9, __int64 a10);
__int64  sub_27E43(__int64 *a1, __int64 a2, __int64 a3, void *a4, size_t a5, char *a6, size_t a7, int a8, const void *a9, __int64 a10);
__int64  sub_2809C(__int64 *a1, char *a2, unsigned __int64 a3, const char *a4, unsigned __int64 a5);
__int64  libssh2_knownhost_readline(__int64 *a1, char *a2, unsigned __int64 a3, int a4);
__int64  libssh2_knownhost_readfile(_QWORD *a1, const char *a2, unsigned int a3);
__int64  sub_286BD(_QWORD *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6);
__int64  libssh2_knownhost_writeline(_QWORD *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6);
__int64  libssh2_knownhost_writefile(_QWORD *a1, const char *a2, int a3);
signed __int64  libssh2_knownhost_get(__int64 a1, signed __int64 *a2, __int64 a3);
__int64  sub_28F91(__int64 a1, __int64 a2, _DWORD *a3, _QWORD *a4);
__int64  sub_28FC1(__int64 a1, _QWORD *a2);
__int64  sub_2900A(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64  sub_29113(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64  sub_2921C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64  sub_29325(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64  sub_293B8(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64  sub_294C1(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
__int64  sub_29554(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8);
char ***libssh2_mac_methods();
__int64  libssh2_error_flags(__int64 a1, unsigned int a2, char *a3, char a4);
__int64  libssh2_error(__int64 a1, unsigned int a2, __int64 a3);
signed __int64  libssh2_recv(int a1, void *a2, size_t a3, int a4);
signed __int64  libssh2_send(int a1, const void *a2, size_t a3, int a4);
__int64  libssh2_ntohu32(unsigned int *a1);
unsigned __int64  libssh2_ntohu64(unsigned __int8 *a1);
signed __int64  libssh2_htonu32(_BYTE *a1, int a2);
_QWORD * libssh2_store_u32(_QWORD *a1, unsigned int a2);
__int64  libssh2_store_str(void **a1, const void *a2, size_t a3);
__int64  libssh2_base64_decode(__int64 a1, _QWORD *a2, _DWORD *a3, unsigned __int8 *a4, int a5);
size_t  libssh2_base64_encode(__int64 a1, const char *a2, size_t a3, char **a4);
__int64  libssh2_free(__int64 a1, __int64 a2);
__int64 libssh2_trace();
__int64 libssh2_trace_sethandler();
_QWORD * libssh2_list_init(_QWORD *a1);
_QWORD * libssh2_list_add(_QWORD *a1, _QWORD *a2);
__int64  libssh2_list_first(__int64 a1);
__int64  libssh2_list_next(__int64 a1);
__int64  libssh2_list_prev(__int64 a1);
_QWORD * libssh2_list_remove(__int64 a1);
void * libssh2_calloc(__int64 a1, size_t a2);
unsigned __int64  libssh2_xor_data(_BYTE *a1, char *a2, char *a3, unsigned __int64 a4);
unsigned __int8 * libssh2_aes_ctr_increment(unsigned __int64 a1, __int64 a2);
__int64  libssh2_explicit_zero(__int64 a1, __int64 a2);
__int64  libssh2_string_buf_new(__int64 a1);
__int64  libssh2_string_buf_free(__int64 a1, _QWORD *a2);
signed __int64  libssh2_get_u32(__int64 a1, _DWORD *a2);
signed __int64  libssh2_get_u64(__int64 a1, _QWORD *a2);
signed __int64  libssh2_match_string(__int64 a1, const char *a2);
signed __int64  libssh2_get_string(__int64 a1, _QWORD *a2, _QWORD *a3);
signed __int64  libssh2_copy_string(__int64 a1, __int64 a2, void **a3, size_t *a4);
signed __int64  libssh2_get_bignum_bytes(__int64 a1, _QWORD *a2, _QWORD *a3);
_BOOL4  libssh2_check_length(_QWORD *a1, unsigned __int64 a2);
__int64  libssh2_bcrypt_pbkdf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7);
__int64  sub_2A779(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4);
__int64  sub_2AE70(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4);
__int64  sub_2B43B(__int64 a1, __int64 a2, unsigned __int64 a3, int a4);
__int64  libssh2_packet_ask(size_t n, char a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t na);
signed __int64  libssh2_packet_askv(size_t a1, const char *a2);
signed __int64  libssh2_packet_require(size_t a1, unsigned __int8 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
signed __int64  libssh2_packet_burn(size_t a1, _DWORD *a2);
__int64  libssh2_packet_requirev(__int64 a1, const char *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, time_t *a8);
signed __int64  sub_2CC1E(char *a1, int a2, FILE *a3);
__int64  sub_2CD01(void *a1, __int64 a2, __int64 a3, unsigned __int64 a4, _QWORD *a5);
__int64  sub_2CDEA(unsigned __int8 a1);
signed __int64  libssh2_pem_parse(__int64 a1, const char *a2, char *a3, char *a4, FILE *a5, _QWORD *a6, _DWORD *a7);
signed __int64  libssh2_pem_parse_memory(__int64 a1, const char *a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7);
__int64  sub_2DAA2(__int64 a1, const char *a2, __int64 a3, unsigned int a4, _QWORD *a5);
signed __int64  libssh2_openssh_pem_parse(__int64 a1, const char *a2, FILE *a3, _QWORD *a4);
signed __int64  libssh2_openssh_pem_parse_memory(__int64 a1, const char *a2, __int64 a3, unsigned __int64 a4, _QWORD *a5);
signed __int64  sub_2EE04(unsigned __int8 *a1, unsigned int a2, _DWORD *a3);
signed __int64  libssh2_pem_decode_sequence(_BYTE **a1, _DWORD *a2);
signed __int64  libssh2_pem_decode_integer(_BYTE **a1, _DWORD *a2, _QWORD *a3, unsigned int *a4);
__int64  sub_2F0F6(__int64 a1, __int64 a2, signed int a3);
__int64  sub_2F17F(__int64 *a1, _QWORD *a2, _QWORD *a3);
signed __int64  sub_2F37E(char **a1, unsigned __int64 a2);
__int64  sub_2F443(__int64 *a1);
__int64  sub_2F602(__int64 a1);
__int64  libssh2_publickey_init(__int64 a1);
__int64  libssh2_publickey_add_ex(__int64 *a1, const void *a2, size_t a3, void *a4, size_t a5, char a6, unsigned __int64 a7, __int64 a8);
__int64  libssh2_publickey_remove_ex(__int64 *a1, const void *a2, size_t a3, void *a4, size_t a5);
__int64  libssh2_publickey_list_fetch(__int64 a1, unsigned __int64 *a2, __int64 *a3);
__int64  libssh2_publickey_list_free(__int64 a1, _QWORD *a2);
signed __int64  libssh2_publickey_shutdown(_QWORD *a1);
_BYTE * sub_32199(char *a1, _BYTE *a2, int a3);
__int64  sub_32487(__int64 a1, char *a2, void *a3);
__int64  libssh2_scp_recv(__int64 a1, char *a2, void *a3);
__int64  libssh2_scp_recv2(__int64 a1, char *a2, void *a3);
__int64  sub_33680(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  libssh2_scp_send_ex(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64  libssh2_scp_send64(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
void * sub_34175(size_t a1);
void  sub_34193(void *a1);
void * sub_341B2(void *a1, size_t a2);
__int64  sub_341DB(__int64 a1);
signed __int64  sub_344CC(__int64 a1);
int  sub_3466D(int a1, int a2);
signed __int64  sub_346D9(int a1);
__int64  libssh2_session_banner_set(__int64 a1, const char *a2);
__int64  libssh2_banner_set(__int64 a1, __int64 a2);
void * libssh2_session_init_ex(void *( *a1)(size_t a1), void ( *a2)(void *a1), void *( *a3)(void *a1, size_t a2), __int64 a4);
__int64  libssh2_session_callback_set(_QWORD *a1, unsigned int a2, __int64 a3);
__int64  libssh2_wait_socket(__int64 a1, time_t a2);
__int64  sub_34CDC(__int64 a1, int a2);
__int64  libssh2_session_handshake(__int64 a1, int a2);
__int64  libssh2_session_startup(__int64 a1, unsigned int a2);
signed __int64  sub_351F3(__int64 a1);
__int64  libssh2_session_free(__int64 a1);
__int64  sub_35D54(__int64 a1, unsigned int a2, const char *a3, char *a4);
__int64  libssh2_session_disconnect_ex(__int64 a1, unsigned int a2, const char *a3, char *a4);
void * libssh2_session_methods(_QWORD *a1, unsigned int a2);
__int64  libssh2_session_abstract(__int64 a1);
__int64  libssh2_session_last_error(__int64 a1, void **a2, _DWORD *a3, int a4);
__int64  libssh2_session_last_errno(__int64 a1);
__int64  libssh2_session_set_last_error(__int64 a1, unsigned int a2, __int64 a3);
signed __int64  libssh2_session_flag(__int64 a1, int a2, int a3);
__int64  libssh2_session_set_blocking(__int64 a1, unsigned int a2);
//__int64  libssh2_session_set_blocking(__int64 a1, unsigned int a2);
__int64  libssh2_session_get_blocking(__int64 a1);
__int64  libssh2_session_set_timeout(__int64 a1, __int64 a2);
__int64  libssh2_session_get_timeout(__int64 a1);
__int64  libssh2_poll_channel_read(__int64 a1, int a2);
_BOOL4  sub_36423(__int64 a1);
_BOOL4  sub_3643C(__int64 a1);
signed __int64  libssh2_poll(__int64 a1, unsigned int a2, __int64 a3);
__int64  libssh2_session_block_directions(__int64 a1);
__int64  libssh2_session_banner_get(__int64 a1);
__int64  sub_36F43(char a1);
_QWORD * sub_36F78(_BYTE **a1, __int64 a2);
__int64  sub_3703B(__int64 a1, int a2);
__int64  sub_3708C(__int64 a1, int a2);
__int64  sub_370ED(__int64 a1, int a2);
__int64  sub_3717C(__int64 a1, _BYTE *a2, unsigned __int64 a3);
__int64  sub_372E0(__int64 a1);
unsigned __int64  sub_376BA(__int64 a1);
signed __int64  sub_377FD(__int64 a1, char a2, int a3, _QWORD *a4, _QWORD *a5);
signed __int64  sub_378DE(__int64 a1, char a2, int a3, _QWORD *a4, unsigned __int64 *a5, unsigned __int64 a6);
signed __int64  sub_379D5(_QWORD *a1, int a2, __int64 a3, int a4, _QWORD *a5, unsigned __int64 *a6, unsigned __int64 a7);
__int64  sub_37B5D(__int64 a1, _QWORD *a2);
__int64  sub_37CB9(_QWORD *a1, __int64 a2, __int64 a3);
__int64  libssh2_sftp_dtor(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
_DWORD * sub_37F20(__int64 a1);
_DWORD * libssh2_sftp_init(__int64 a1);
__int64  sub_386D7(_QWORD *a1);
signed __int64  libssh2_sftp_shutdown(_QWORD *a1);
__int64  sub_38AA3(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, int a6);
__int64  libssh2_sftp_open_ex(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, int a6);
size_t  sub_393AE(__int64 a1, void *a2, unsigned __int64 a3);
signed __int64  libssh2_sftp_read(__int64 a1, void *a2, unsigned __int64 a3);
size_t  sub_39E80(__int64 a1, void *a2, size_t a3, void *a4, unsigned __int64 a5, void *a6);
signed __int64  libssh2_sftp_readdir_ex(__int64 a1, void *a2, size_t a3, void *a4, unsigned __int64 a5, void *a6);
__int64  sub_3A750(_QWORD *a1, __int64 a2, unsigned __int64 a3);
signed __int64  libssh2_sftp_write(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64  sub_3ADF7(__int64 a1);
signed __int64  libssh2_sftp_fsync(__int64 a1);
__int64  sub_3B1CD(__int64 a1, _QWORD *a2, int a3);
signed __int64  libssh2_sftp_fstat_ex(__int64 a1, _QWORD *a2, int a3);
__int64  libssh2_sftp_seek64(__int64 a1, __int64 a2);
__int64  libssh2_sftp_seek(__int64 a1, __int64 a2);
__int64  libssh2_sftp_tell(__int64 a1);
__int64  libssh2_sftp_tell64(__int64 a1);
__int64  sub_3B842(__int64 a1);
signed __int64  sub_3B936(__int64 a1);
signed __int64  libssh2_sftp_close_handle(__int64 a1);
__int64  sub_3BE12(__int64 a1, __int64 a2, __int64 a3);
signed __int64  libssh2_sftp_unlink_ex(__int64 a1, __int64 a2, unsigned int a3);
__int64  sub_3C1E1(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6);
signed __int64  libssh2_sftp_rename_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6);
__int64  sub_3C700(__int64 a1, _QWORD *a2);
signed __int64  libssh2_sftp_fstatvfs(__int64 a1, _QWORD *a2);
__int64  sub_3CCC6(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4);
signed __int64  libssh2_sftp_statvfs(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4);
__int64  sub_3D27F(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
signed __int64  libssh2_sftp_mkdir_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64  sub_3D711(__int64 a1, __int64 a2, unsigned int a3);
signed __int64  libssh2_sftp_rmdir_ex(__int64 a1, __int64 a2, unsigned int a3);
__int64  sub_3DAE1(__int64 a1, __int64 a2, unsigned int a3, int a4, _QWORD *a5);
signed __int64  libssh2_sftp_stat_ex(__int64 a1, __int64 a2, unsigned int a3, int a4, _QWORD *a5);
__int64  sub_3E000(__int64 a1, __int64 a2, unsigned int a3, void *a4, unsigned int a5, int a6);
signed __int64  libssh2_sftp_symlink_ex(__int64 a1, __int64 a2, unsigned int a3, void *a4, unsigned int a5, int a6);
__int64  libssh2_sftp_last_error(__int64 a1);
__int64  libssh2_sftp_get_channel(__int64 *a1);
signed __int64  sub_3E5ED(__int64 a1, char *a2, char *a3, int a4);
signed __int64  sub_3E6EB(__int64 a1, int a2);
signed __int64  libssh2_transport_read(__int64 a1);
signed __int64  sub_3F253(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
signed __int64  libssh2_transport_send(__int64 a1, const void *a2, __int64 a3, void *a4, size_t a5);
__int64  sub_3F9F0(__int64 a1, __int64 a2, unsigned int a3);
__int64  libssh2_userauth_list(__int64 a1, __int64 a2, unsigned int a3);
__int64  libssh2_userauth_authenticated(__int64 a1);
__int64  sub_3FF03(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, void ( *a6)(__int64, signed __int64, signed __int64, __int64));
__int64  libssh2_userauth_password_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, void ( *a6)(__int64, signed __int64, signed __int64, __int64));
__int64  sub_407F3(size_t n, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, void *a6, size_t na);
__int64  sub_40A80(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, const char *a6);
__int64  sub_40E1F(__int64 a1, __int64 a2, _QWORD *a3, char *a4, int a5, __int64 a6, __int64 a7, __int64 a8);
__int64  sub_40F35(__int64 a1, __int64 a2, _QWORD *a3, char *a4, int a5, __int64 a6, __int64 a7);
signed __int64  sub_41044(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6);
signed __int64  sub_41198(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 **a6);
__int64  sub_412D7(__int64 a1, __int64 a2, __int64 a3, const char *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64  libssh2_userauth_hostbased_fromfile_ex(__int64 a1, __int64 a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6, __int64 a7, unsigned int a8, __int64 a9, unsigned int a10);
__int64  _libssh2_userauth_publickey(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 ( *a6)(__int64, __int64 *, unsigned __int64 *, void *, signed __int64, __int64), __int64 a7);
__int64  sub_42DD0(size_t a1, __int64 a2, unsigned int a3, void *a4, size_t a5, __int64 a6, __int64 a7, __int64 a8);
__int64  sub_42FAC(__int64 a1, __int64 a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
__int64  libssh2_userauth_publickey_frommemory(size_t a1, __int64 a2, unsigned int a3, void *a4, size_t a5, __int64 a6, __int64 a7, void *a8);
__int64  libssh2_userauth_publickey_fromfile_ex(__int64 a1, __int64 a2, unsigned int a3, const char *a4, __int64 a5, void *a6);
//signed __int64  libssh2_userauth_publickey(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64  sub_43330(__int64 a1, __int64 a2, unsigned int a3, void ( *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64));
__int64  libssh2_userauth_keyboard_interactive_ex(__int64 a1, __int64 a2, unsigned int a3, void ( *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64));
const char * libssh2_version(signed int a1);
void term_proc();


//-------------------------------------------------------------------------
// Data declarations

_QWORD qword_44AA0[522] =
{
  -7431021106289374298LL,
  -3451200186548915493LL,
  7648940202947358701LL,
  -1068338713358200763LL,
  -5507501060570113721LL,
  -8822837448418397470LL,
  8167082663806050520LL,
  -823246692746199389LL,
  8254735656317973647LL,
  -9073263486300336808LL,
  -4442139446454475747LL,
  3094641531298043193LL,
  2909472628438839331LL,
  -5126441148289550056LL,
  6933881027089259696LL,
  -5756011273018012021LL,
  -4813983892198033471LL,
  6152018660399460314LL,
  -6172839058233547277LL,
  7199026270926575714LL,
  3074569545919904106LL,
  1243530946625166388LL,
  8967486628324214447LL,
  7165152423763121169LL,
  8365491241204958557LL,
  -7239656115454329322LL,
  7792581252251826739LL,
  2924391380756353921LL,
  7731477347581249688LL,
  7361170509481895963LL,
  -350812854081287732LL,
  6767925293483863136LL,
  -1619759083881734819LL,
  -1484750227525721342LL,
  -3200180522495426943LL,
  -8938446547584192525LL,
  -6592108752239115134LL,
  -7052747661634899894LL,
  -654872861558282174LL,
  -6065353707035517855LL,
  -2858607737966583598LL,
  -6102039242420017368LL,
  1403500086179072876LL,
  9149953903381180496LL,
  4156542590120977693LL,
  -9060382046336427714LL,
  5003393308839282201LL,
  4290627242243171779LL,
  -8808723714101250600LL,
  6251395020039537823LL,
  3908973870556883554LL,
  4799432289379344242LL,
  -3455929662670055644LL,
  5328251609783724755LL,
  -9180276150200208695LL,
  -655028592709436968LL,
  -5298119666512801766LL,
  342280970154336445LL,
  4656546937903337398LL,
  1831316207683018434LL,
  4498062166451777455LL,
  4274738958136095467LL,
  -7264142180892258017LL,
  -5809998619477981884LL,
  -2435520519787524092LL,
  1814470933760387079LL,
  5028396594967062615LL,
  -5056421035066564807LL,
  1900574062715453629LL,
  4624196785020141766LL,
  -351382147604470274LL,
  -2652018779627329032LL,
  -188751970420058401LL,
  -5979282035077800248LL,
  -206172310699395590LL,
  4467816581186026312LL,
  -3859711734153717829LL,
  -2371310289023445458LL,
  2918050825144281334LL,
  -8336350429937454394LL,
  -4915018425537189968LL,
  -5120573393636187299LL,
  -206739281300275816LL,
  3301652390892844396LL,
  -5262379861899221895LL,
  5475136420262595004LL,
  -6572020469919255846LL,
  -3538484705811033279LL,
  3924689171467258586LL,
  3166346874470702846LL,
  -5868030229928486323LL,
  7751774270743481969LL,
  -5780609949204819504LL,
  -8181469631962391761LL,
  -1003692056038153477LL,
  -8066527352210278382LL,
  7534455227977391776LL,
  -5500933992539491951LL,
  -4751834756169129448LL,
  -8430140772200403458LL,
  -5372947286795957233LL,
  -3564068482915175466LL,
  -210577677941714976LL,
  -3265768502719136895LL,
  -9181301401590979994LL,
  2385241456459412244LL,
  8626076118600720485LL,
  -316037232327376139LL,
  8880686839465094924LL,
  -5900139606216467501LL,
  2337846897892724269LL,
  6321049119815631035LL,
  -1150184690705746277LL,
  6476078039689302301LL,
  -2784821612623346807LL,
  208777214047378338LL,
  7103812314203554678LL,
  5652943600611760488LL,
  8868899704499809738LL,
  -7326466998172319662LL,
  -4856069087042775233LL,
  -9086447654096821130LL,
  6276866825170612149LL,
  3030316812577729643LL,
  -1749092417117395679LL,
  -4213866884556913362LL,
  -6224098236946174627LL,
  7963779668068943769LL,
  -5353890158712557335LL,
  -4316376832410318546LL,
  5307456416753034928LL,
  -8075602403016154952LL,
  7609420908350573681LL,
  -4417575068819500436LL,
  8433355516628304549LL,
  -2010793192968350912LL,
  6575991464094111898LL,
  -7352337676498901802LL,
  -1159623072507847673LL,
  -1142403845663672090LL,
  -8903357913580625786LL,
  152784143145691590LL,
  4520188822745017151LL,
  7740122747398199316LL,
  5954007774290457988LL,
  -6174427153239878907LL,
  9213993598847517724LL,
  6275470005265843436LL,
  -1130390253539239369LL,
  144313099902263044LL,
  4374530923833390362LL,
  -2591503014313100712LL,
  8982763668891571193LL,
  2518997638690522995LL,
  4018014456983709057LL,
  -7281232459831347660LL,
  1139414067228991814LL,
  -6596332810719934658LL,
  4317278791609666969LL,
  1747030729348397985LL,
  5723434146782808888LL,
  -717755970360308477LL,
  2636712966731862672LL,
  -4850506887491637134LL,
  -2768860477355559137LL,
  -2535738595372978670LL,
  3344891549112758815LL,
  -6952205943704986138LL,
  8361172502585034520LL,
  -1636075996205573444LL,
  -2628661843954308038LL,
  -4295092836232510618LL,
  3609029308801882183LL,
  2648884138211490615LL,
  3055063774724705603LL,
  1385671474560630786LL,
  1166799907355359390LL,
  6850284663893424086LL,
  -2908261671905175823LL,
  6423440427618211899LL,
  -7497934849365252371LL,
  2167705241455869740LL,
  -1519560590997895824LL,
  6502681862506176010LL,
  5637669981347899164LL,
  -7356879515330159431LL,
  5937653222125504982LL,
  -7201058535540733576LL,
  -7718349006919364934LL,
  2164593099684985939LL,
  3899320397442010791LL,
  1856179450077062671LL,
  -643149747512432888LL,
  -1530344921474662802LL,
  -6450341572491065963LL,
  111744641019099089LL,
  -4725302241027498513LL,
  7542289137019658629LL,
  -2652737570855803633LL,
  6588255549592141229LL,
  2956438814410782248LL,
  7034364305413588853LL,
  -1485697949780629456LL,
  -6195998921568485858LL,
  5508080713015188624LL,
  -3770957556904714741LL,
  6945162675136267964LL,
  -5551948305007944533LL,
  1854903373607411375LL,
  7303355700693133753LL,
  4335476273270250034LL,
  -4602193972367005227LL,
  -8692052174205351143LL,
  7078952352320297342LL,
  -7502102560980367206LL,
  1614560811973186399LL,
  -4042508611296589783LL,
  8671886251325841313LL,
  1955250959235253413LL,
  1928181203136136191LL,
  5993781294863157995LL,
  7907249096037583076LL,
  3803008317340250863LL,
  -1262067326687580831LL,
  -1701032572088609575LL,
  2323316311671725332LL,
  -6653316476802506058LL,
  -375118385502204139LL,
  -1194936361706916798LL,
  4741482289749244701LL,
  -8753504780004984418LL,
  4431931607876323178LL,
  6596971114736558578LL,
  -4483414088591309920LL,
  7623314966800835779LL,
  6238244719361821195LL,
  -5973663591426179328LL,
  2558622931804664180LL,
  888886888327449898LL,
  2539872277272327230LL,
  -8245107674284101486LL,
  7791856120684866801LL,
  -3751933481792424103LL,
  -3569328730557517145LL,
  1871334287493005444LL,
  7050832949422315605LL,
  -4248012915381524566LL,
  -9220052764359087108LL,
  -4376033718724953554LL,
  1017425156216547077LL,
  1176997295358729171LL,
  -2060604360607409543LL,
  8160022078523978853LL,
  -1049902624177325922LL,
  -8092901141991513625LL,
  -2629066477212033237LL,
  -7745838450586330520LL,
  -7752619976094374372LL,
  8503593204842832119LL,
  -3124934741594969298LL,
  3684213234850079857LL,
  5764714928417526967LL,
  -7555838107363707346LL,
  -4644468781905522828LL,
  -7586997815128753123LL,
  7394962563436699091LL,
  269538153415313900LL,
  3588107782499102160LL,
  6196171616199321523LL,
  -6068025887727204378LL,
  5981952333679982629LL,
  -1605975292136093990LL,
  -2933979706751708062LL,
  2855719693817135268LL,
  -1691192316917711198LL,
  8859942447162908678LL,
  -3227005137905115524LL,
  4641850307355648921LL,
  -2741700717969498571LL,
  4256550960722728875LL,
  5435027083452087031LL,
  -1521205457712880079LL,
  -2496327685439030668LL,
  -3857296816684800009LL,
  -2810611652099377842LL,
  -5023601388433680724LL,
  2342871843554409018LL,
  -3416379113690388041LL,
  -6839390754907330628LL,
  -7358359300623226525LL,
  4553462452413155926LL,
  -8058855647964004836LL,
  299260062587217922LL,
  371596324887008604LL,
  -1961760592364497592LL,
  -4102912454839692481LL,
  4684903661790939630LL,
  6739757888501676452LL,
  -3054635917514944021LL,
  4688587394754855311LL,
  6929522913422571572LL,
  2261770304847669411LL,
  207502712258081986LL,
  -3832139877778567215LL,
  3692550241353176544LL,
  -1243352890435433630LL,
  -1821128146293710322LL,
  3288462432836652172LL,
  -7658488823481731003LL,
  -1743748542872352670LL,
  -8683704266507312273LL,
  -919142110666556121LL,
  -7408703463124147391LL,
  -794606920585482581LL,
  -6779080754034713504LL,
  -2635051025817673396LL,
  7883318290800137488LL,
  -2535271485671091141LL,
  -3746713810381500985LL,
  7570530133173931922LL,
  -3541098571309015045LL,
  -2804231136101675253LL,
  5862469713221857160LL,
  8519639426980411839LL,
  -3742111438215762253LL,
  -851689208033123689LL,
  -4149456572516225625LL,
  8660124236351098060LL,
  -5219018963810106825LL,
  5475078967358766054LL,
  1282098702381158424LL,
  -2098180682296214056LL,
  725663957351798361LL,
  -3050086852862350226LL,
  -2700285798897457330LL,
  7270151197372180872LL,
  -1083185500954787753LL,
  6918479338018470904LL,
  -704778497385725114LL,
  -2938883751708086780LL,
  -1144288751283705037LL,
  4323559407351775623LL,
  -4762365134295246914LL,
  -4658922818937404775LL,
  -946321473136954225LL,
  -8680198161757311176LL,
  -3984684615026148925LL,
  5115202668405846613LL,
  -8422329968022051231LL,
  -7971488015305798023LL,
  2356604644751202702LL,
  -3962360301770943087LL,
  -4935375847628755743LL,
  8463576096102179400LL,
  -2258031803858216522LL,
  -4309304706868639327LL,
  716281853154828034LL,
  2120911820462596133LL,
  839258183707475229LL,
  2911842595078861327LL,
  6285062446666734211LL,
  5750392292102033051LL,
  -6411291908406944255LL,
  1001716835743348164LL,
  8592734230377172007LL,
  7036881795503115270LL,
  -4542576348474410456LL,
  3520826868563466410LL,
  2538036101246262999LL,
  -4412940270870274668LL,
  -8017332168876626346LL,
  -3577796032366608991LL,
  5439224135446553609LL,
  8976373502327261757LL,
  8236412713688068703LL,
  -3197915292466324556LL,
  647574647223899512LL,
  5597147250007309523LL,
  -5664992902920474786LL,
  7805040780355376345LL,
  6260371562618537959LL,
  -2466063606481240114LL,
  -7898326304039488972LL,
  4638708579993320078LL,
  -3171952717145190857LL,
  6540683630694528823LL,
  5738491108362577822LL,
  -7368843646390360256LL,
  -4679394950208450915LL,
  -4107066824008590210LL,
  2423376703608593259LL,
  7653426339129504190LL,
  -4858136630591444177LL,
  7298578838712448722LL,
  5083964184216991982LL,
  5535009458418289181LL,
  -6216579025528570917LL,
  -4729092949477611800LL,
  7650861066556724720LL,
  -7311895113516479262LL,
  4838043537029841592LL,
  -7137413053865393238LL,
  -7212116447101689414LL,
  -5015783107888605872LL,
  -6396735582010694919LL,
  -1200944971488062074LL,
  -625164879234338861LL,
  8645233813116710761LL,
  -8669281941672646379LL,
  4269101918917879469LL,
  -7046770469469356710LL,
  156371792836999129LL,
  107425024458468410LL,
  8970375686133858006LL,
  -5912460384394074673LL,
  6523733768536503410LL,
  -2298623723774038927LL,
  -1327441920314528515LL,
  2899007322734183565LL,
  8724367656655087145LL,
  -1336055794237505135LL,
  -2030175047471722940LL,
  -8578110744249930284LL,
  388700162461098277LL,
  4364084395505327637LL,
  -6252677253144569108LL,
  2189631180440038811LL,
  2800380361138005755LL,
  -5668345325300754136LL,
  -8450374976894782334LL,
  -4464516420732881135LL,
  -3698138779399466649LL,
  4048978568756598609LL,
  -7844996148780771230LL,
  -342700393006198590LL,
  8597299336992378468LL,
  -4383905388580904066LL,
  7211360867003028329LL,
  -2491139148448135152LL,
  650525394919042557LL,
  7225393235619366410LL,
  2026840483450117839LL,
  1970480144531257309LL,
  7761078453600911743LL,
  4204672402663303806LL,
  -4849024583015790012LL,
  -404052125934760280LL,
  -4666732760757038418LL,
  6066170159810995299LL,
  -698511556576381157LL,
  -1775804361737368179LL,
  -5813164851451521423LL,
  5671407197645490952LL,
  78161550905591402LL,
  -7667314465583397848LL,
  -3571741223247372364LL,
  3828248259965434754LL,
  2842378260948065611LL,
  -1759992813617585999LL,
  3766458160185506091LL,
  5894782327997348321LL,
  -6908597930120001097LL,
  -4843672015961536386LL,
  -6779981463858114109LL,
  -3148089144940394679LL,
  -3095421856306766133LL,
  -4138466766513126614LL,
  -2255974317651578500LL,
  4897026031772129719LL,
  2871402777816668671LL,
  1578225979973116460LL,
  -7236135452358345615LL,
  -3551478718794460319LL,
  1349576657218331737LL,
  -2088146249378101410LL,
  -3818027455423033243LL,
  1628292315517578766LL,
  3636913316092747966LL,
  -2246290299982736078LL,
  -8542780803931687893LL,
  5450257750402167873LL,
  -4362243282449829600LL,
  -7234699448034156659LL,
  1145023840998092615LL,
  2223327487189637716LL,
  -3657346828709234225LL,
  -203755975455755930LL,
  -649887678475545915LL,
  -6470979817769274537LL,
  6254599393461679409LL,
  6518375201211711842LL,
  -8587674217584642409LL,
  -9099160410688953710LL,
  8198334816854249499LL,
  3637241686109112253LL,
  -4327260389422018554LL,
  7108948507862127613LL,
  3872483211752095714LL,
  -5619364088102360827LL,
  -3641551537118130308LL,
  1603531964115140288LL,
  2686306950004325728LL,
  -628588088645902180LL,
  2338881548929966533LL,
  -8437337940781433266LL,
  5546651876284103088LL,
  214917741554483804LL,
  -2960023870473278748LL,
  -6459042984350123927LL,
  -4465065458906094291LL,
  -3569135296122560206LL,
  4234354408295489507LL,
  -8817193942522041720LL,
  247824715720788526LL,
  2999170649027065890LL,
  -1419077496771511656LL,
  4093793464262074854LL,
  3812592220735039183LL,
  -3928175861623412297LL,
  -5384324834043570763LL,
  -8540519122497776167LL,
  0LL
}; // idb
_WORD word_47700[256] =
{
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  62,
  65535,
  65535,
  65535,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535
}; // idb
char * byte_7;
char *off_24F868[3] = { "success", &byte_7, (char *)1LL }; // idb

// First array
char* off_24F550;
char* off_24F570;
char* off_24F590;
char* off_24F5D0;
char* off_24F5B0;
char* off_24F4F0;
char* off_24F530;
char* off_24F510;
char* off_24F4D0;
char* off_24F4B0;

// Second array
char* off_24F640;
char* off_24F600;
char* off_24F680;
char* off_24F6C0;
char*off_24F700;
char*off_24F740;
char*off_24F780;
char*off_24F7C0;


char **off_250A40[10] =
{
  &off_24F550,
  &off_24F570,
  &off_24F590,
  &off_24F5D0,
  &off_24F5B0,
  &off_24F4F0,
  &off_24F530,
  &off_24F510,
  &off_24F4D0,
  &off_24F4B0
};

char **off_250AA0[8] =
{
  &off_24F640,
  &off_24F600,
  &off_24F680,
  &off_24F6C0,
  &off_24F700,
  &off_24F740,
  &off_24F780,
  &off_24F7C0
};
char *s = "Proc-Type: 4,ENCRYPTED"; // idb

void* loc_40000; 
void* loc_10900; 

char* unk_24F800;
char* unk_4468B;
char* unk_46840;
char* unk_46850;
char* unk_46860;
char* unk_46870;
char* unk_46890;
char* unk_468B0;
char* unk_47060;
char* unk_470E0;
char* unk_47F18;
char* unk_47C31;
char* unk_4A3F8;
char* unk_48EAB;
char* unk_4878E;
char* unk_49C94;
char* unk_49C92;


QWORD qword_20;
QWORD qword_108;
DWORD dword_250AFC;
DWORD dword_250B00;
DWORD dword_250A00;

char *off_250940;
char *off_250948;
char *off_250960;
char *off_250970;
char *off_250980;

struct sockaddr {
    unsigned short sa_family;   // address family, AF_xxx
    char           sa_data[14]; // 14 bytes of protocol address
};

struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};

//----- (00000000000088D0) ----------------------------------------------------
//__int64 (**init_proc())(void)
//{
//  __int64 (**result)(void); // rax
//
//  result = &_gmon_start__;
//  if ( &_gmon_start__ )
//    result = (__int64 (**)(void))_gmon_start__();
//  return result;
//}
//// 251070: using guessed type __int64 _gmon_start__(void);
//
////----- (00000000000088F0) ----------------------------------------------------
//void sub_88F0()
//{
//  JUMPOUT(&dword_0);
//}
// 0: using guessed type int dword_0;

//----- (0000000000009AE0) ----------------------------------------------------
char _bss_start;
__int64 ITM_deregisterTMCloneTable(void);

char *start()
{
  char *result; // rax

  result = &_bss_start;
  if ( &_bss_start != &_bss_start )
  {
    result = (char *)&ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (char *)ITM_deregisterTMCloneTable();
  }
  return result;
}
// 250AF8: using guessed type char _bss_start;
// 251078: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000009B20) ----------------------------------------------------
__int64 sub_9B20()
{
  return 0LL;
}

__int64  _cxa_finalize(_QWORD);
void *off_250900;


//----- (0000000000009B70) ----------------------------------------------------
char *sub_9B70()
{
  char *result; // rax

  if ( !_bss_start )
  {
    if ( &_cxa_finalize )
      _cxa_finalize(off_250900);
    result = start();
    _bss_start = 1;
  }
  return result;
}
// 9AD0: using guessed type __int64  _cxa_finalize(_QWORD);
// 250900: using guessed type void *off_250900;
// 250AF8: using guessed type char _bss_start;

//----- (0000000000009BB0) ----------------------------------------------------
__int64 sub_9BB0()
{
  return sub_9B20();
}

//----- (0000000000009BBA) ----------------------------------------------------
signed __int64  sub_9BBA(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-24h]

  v4 = a3;
  *(_BYTE *)(a1 + 4) = 0;
  BN_bn2bin(a2, a1 + 5);
  if ( *(_BYTE *)(a1 + 5) >= 0 )
    memmove((void *)(a1 + 4), (const void *)(a1 + 5), (signed int)--v4);
  _libssh2_htonu32(a1, v4);
  return (signed int)v4 + a1 + 4;
}
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9780: using guessed type __int64  BN_bn2bin(_QWORD, _QWORD);

//----- (0000000000009C4C) ----------------------------------------------------
__int64  libssh2_rsa_new(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, unsigned int a13, __int64 a14, unsigned int a15, __int64 a16, unsigned int a17)
{
  unsigned int v17; // ST18_4
  __int64 v18; // rsi
  __int64 v19; // rdi
  __int64 v21; // [rsp+0h] [rbp-70h]
  unsigned int v22; // [rsp+8h] [rbp-68h]
  __int64 v23; // [rsp+10h] [rbp-60h]
  _QWORD *v24; // [rsp+28h] [rbp-48h]
  __int64 v25; // [rsp+30h] [rbp-40h]
  __int64 v26; // [rsp+38h] [rbp-38h]
  __int64 v27; // [rsp+40h] [rbp-30h]
  __int64 v28; // [rsp+48h] [rbp-28h]
  __int64 v29; // [rsp+50h] [rbp-20h]
  __int64 v30; // [rsp+58h] [rbp-18h]
  __int64 v31; // [rsp+60h] [rbp-10h]
  __int64 v32; // [rsp+68h] [rbp-8h]

  v24 = a1;
  v17 = a3;
  v23 = a4;
  v22 = a5;
  v21 = a6;
  v25 = 0LL;
  v26 = 0LL;
  v27 = 0LL;
  v28 = 0LL;
  v29 = 0LL;
  v30 = 0LL;
  v31 = BN_new(a1, a2);
  BN_bin2bn(a2, v17, v31);
  v32 = BN_new(a2, v17);
  v18 = v22;
  v19 = v23;
  BN_bin2bn(v23, v22, v32);
  if ( v21 )
  {
    v25 = BN_new(v23, v22);
    BN_bin2bn(v21, (unsigned int)a7, v25);
    v26 = BN_new(v21, (unsigned int)a7);
    BN_bin2bn(a8, (unsigned int)a9, v26);
    v27 = BN_new(a8, (unsigned int)a9);
    BN_bin2bn(a10, (unsigned int)a11, v27);
    v28 = BN_new(a10, (unsigned int)a11);
    BN_bin2bn(a12, a13, v28);
    v29 = BN_new(a12, a13);
    BN_bin2bn(a14, a15, v29);
    v30 = BN_new(a14, a15);
    v18 = a17;
    v19 = a16;
    BN_bin2bn(a16, a17, v30);
  }
  *v24 = RSA_new(v19, v18);
  RSA_set0_key(*v24, v32, v31, v25);
  RSA_set0_factors(*v24, v26, v27);
  RSA_set0_crt_params(*v24, v28, v29, v30);
  return 0LL;
}
// 89C0: using guessed type __int64  RSA_set0_factors(_QWORD, _QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8D30: using guessed type __int64  RSA_set0_key(_QWORD, _QWORD, _QWORD, _QWORD);
// 8FE0: using guessed type __int64  RSA_new(_QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 95A0: using guessed type __int64  RSA_set0_crt_params(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000009E15) ----------------------------------------------------
signed __int64  libssh2_rsa_sha1_verify(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  unsigned int v6; // [rsp+18h] [rbp-48h]
  char v7; // [rsp+40h] [rbp-20h]
  unsigned __int64 v8; // [rsp+58h] [rbp-8h]

  v6 = a3;
  v8 = __readfsqword(0x28u);
  if ( (unsigned int)_libssh2_sha1(a4, a5, &v7) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)RSA_verify(64LL, &v7, 20LL, a2, v6, a1) == 1 )
    return 0LL;
  return 0xFFFFFFFFLL;
}
// 8DA0: using guessed type __int64  RSA_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 99C0: using guessed type __int64  _libssh2_sha1(_QWORD, _QWORD, _QWORD);

//----- (0000000000009EBA) ----------------------------------------------------
__int64  libssh2_dsa_new(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, __int64 a8, unsigned int a9, __int64 a10, __int64 a11)
{
  unsigned int v11; // ST18_4
  __int64 v12; // ST10_8
  unsigned int v13; // ST08_4
  __int64 v14; // ST00_8
  __int64 v15; // rsi
  __int64 v16; // rdi
  _QWORD *v18; // [rsp+28h] [rbp-38h]
  __int64 v19; // [rsp+38h] [rbp-28h]
  __int64 v20; // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  __int64 v22; // [rsp+50h] [rbp-10h]
  __int64 v23; // [rsp+58h] [rbp-8h]

  v18 = a1;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  v19 = 0LL;
  v20 = ((__int64 (*)(void))BN_new)();
  BN_bin2bn(a2, v11, v20);
  v21 = BN_new(a2, v11);
  BN_bin2bn(v12, v13, v21);
  v22 = BN_new(v12, v13);
  BN_bin2bn(v14, a7, v22);
  v23 = BN_new(v14, a7);
  v15 = a9;
  v16 = a8;
  BN_bin2bn(a8, a9, v23);
  if ( a11 )
  {
    v19 = BN_new(a8, a9);
    v15 = (unsigned int)a11;
    v16 = a10;
    BN_bin2bn(a10, (unsigned int)a11, v19);
  }
  *v18 = DSA_new(v16, v15);
  DSA_set0_pqg(*v18, v20, v21, v22);
  DSA_set0_key(*v18, v23, v19);
  return 0LL;
}
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8E60: using guessed type __int64  DSA_set0_key(_QWORD, _QWORD, _QWORD);
// 9030: using guessed type __int64  DSA_set0_pqg(_QWORD, _QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9A10: using guessed type __int64  DSA_new(_QWORD, _QWORD);

//----- (0000000000009FD9) ----------------------------------------------------
signed __int64  libssh2_dsa_sha1_verify(__int64 a1, __int64 a2, __int64 a3, signed __int64 a4)
{
  __int64 v4; // ST08_8
  signed __int64 v5; // ST00_8
  __int64 v6; // ST28_8
  __int64 v7; // ST30_8
  signed __int64 v8; // rsi
  signed __int64 result; // rax
  signed int v10; // [rsp+24h] [rbp-3Ch]
  __int64 v11; // [rsp+38h] [rbp-28h]
  char v12; // [rsp+40h] [rbp-20h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v4 = a3;
  v5 = a4;
  v13 = __readfsqword(0x28u);
  v10 = -1;
  v6 = BN_new(a1, a2);
  BN_bin2bn(a2, 20LL, v6);
  v7 = BN_new(a2, 20LL);
  BN_bin2bn(a2 + 20, 20LL, v7);
  v11 = DSA_SIG_new(a2 + 20, 20LL);
  DSA_SIG_set0(v11, v6, v7);
  v8 = v5;
  if ( !(unsigned int)_libssh2_sha1(v4, v5, &v12) )
  {
    v8 = 20LL;
    v10 = DSA_do_verify(&v12, 20LL, v11, a1);
  }
  DSA_SIG_free(v11, v8);
  if ( v10 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8A10: using guessed type __int64  DSA_SIG_new(_QWORD, _QWORD);
// 8BA0: using guessed type __int64  DSA_SIG_set0(_QWORD, _QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 95B0: using guessed type __int64  DSA_do_verify(_QWORD, _QWORD, _QWORD, _QWORD);
// 9970: using guessed type __int64  DSA_SIG_free(_QWORD, _QWORD);
// 99C0: using guessed type __int64  _libssh2_sha1(_QWORD, _QWORD, _QWORD);

//----- (000000000000A0D5) ----------------------------------------------------
__int64  libssh2_ecdsa_get_curve_type(__int64 a1)
{
  __int64 v1; // ST18_8

  v1 = EC_KEY_get0_group(a1);
  return EC_GROUP_get_curve_name(v1);
}
// 8E00: using guessed type __int64  EC_KEY_get0_group(_QWORD);
// 91F0: using guessed type __int64  EC_GROUP_get_curve_name(_QWORD);

//----- (000000000000A0FF) ----------------------------------------------------
signed __int64  libssh2_ecdsa_curve_type_from_name(const char *a1, signed int *a2)
{
  unsigned int v3; // [rsp+18h] [rbp-8h]
  signed int v4; // [rsp+1Ch] [rbp-4h]

  v3 = 0;
  if ( !a1 || strlen(a1) != 19 )
    return 0xFFFFFFFFLL;
  if ( !strcmp(a1, "ecdsa-sha2-nistp256") )
  {
    v4 = 415;
  }
  else if ( !strcmp(a1, "ecdsa-sha2-nistp384") )
  {
    v4 = 715;
  }
  else if ( !strcmp(a1, "ecdsa-sha2-nistp521") )
  {
    v4 = 716;
  }
  else
  {
    v3 = -1;
  }
  if ( !v3 )
  {
    if ( a2 )
      *a2 = v4;
  }
  return v3;
}

//----- (000000000000A1BB) ----------------------------------------------------
signed __int64  libssh2_ecdsa_curve_name_with_octal_new(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // ST28_8
  signed __int64 result; // rax
  __int64 v6; // [rsp+8h] [rbp-38h]
  int v7; // [rsp+24h] [rbp-1Ch]
  __int64 v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v7 = 0;
  v8 = EC_KEY_new_by_curve_name(a4);
  if ( v8 )
  {
    v4 = EC_KEY_get0_group(v8);
    v9 = EC_POINT_new(v4);
    EC_POINT_oct2point(v4, v9, a2, v6, 0LL);
    v7 = EC_KEY_set_public_key(v8, v9);
    if ( v9 )
      EC_POINT_free(v9);
    if ( a1 )
      *a1 = v8;
  }
  if ( v7 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8D00: using guessed type __int64  EC_POINT_new(_QWORD);
// 8D20: using guessed type __int64  EC_KEY_set_public_key(_QWORD, _QWORD);
// 8E00: using guessed type __int64  EC_KEY_get0_group(_QWORD);
// 9160: using guessed type __int64  EC_KEY_new_by_curve_name(_QWORD);
// 95F0: using guessed type __int64  EC_POINT_oct2point(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9660: using guessed type __int64  EC_POINT_free(_QWORD);

//----- (000000000000A28E) ----------------------------------------------------
signed __int64  libssh2_ecdsa_verify(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7)
{
  unsigned int v7; // ST18_4
  __int64 v8; // ST10_8
  unsigned int v9; // ST08_4
  __int64 v10; // ST50_8
  __int64 v11; // ST58_8
  signed __int64 result; // rax
  __int64 v13; // [rsp+0h] [rbp-B0h]
  int v14; // [rsp+38h] [rbp-78h]
  int v15; // [rsp+3Ch] [rbp-74h]
  __int64 v16; // [rsp+48h] [rbp-68h]
  char v17; // [rsp+60h] [rbp-50h]
  unsigned __int64 v18; // [rsp+A8h] [rbp-8h]

  v7 = a3;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v18 = __readfsqword(0x28u);
  v14 = 0;
  v15 = _libssh2_ecdsa_get_curve_type(a1);
  v16 = ECDSA_SIG_new();
  v10 = BN_new(a1, a2);
  v11 = BN_new(a1, a2);
  BN_bin2bn(a2, v7, v10);
  BN_bin2bn(v8, v9, v11);
  ECDSA_SIG_set0(v16, v10, v11);
  switch ( v15 )
  {
    case 415:
      _libssh2_sha256(v13, a7, &v17);
      v14 = ECDSA_do_verify(&v17, 32LL, v16, a1);
      break;
    case 715:
      _libssh2_sha384(v13, a7, &v17);
      v14 = ECDSA_do_verify(&v17, 48LL, v16, a1);
      break;
    case 716:
      _libssh2_sha512(v13, a7, &v17);
      v14 = ECDSA_do_verify(&v17, 64LL, v16, a1);
      break;
  }
  if ( v16 )
    ECDSA_SIG_free(v16);
  if ( v14 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8980: using guessed type __int64  _libssh2_sha512(_QWORD, _QWORD, _QWORD);
// 8A70: using guessed type __int64  _libssh2_ecdsa_get_curve_type(_QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 9000: using guessed type __int64  ECDSA_do_verify(_QWORD, _QWORD, _QWORD, _QWORD);
// 9080: using guessed type __int64 ECDSA_SIG_new(void);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 97A0: using guessed type __int64  ECDSA_SIG_free(_QWORD);
// 9810: using guessed type __int64  ECDSA_SIG_set0(_QWORD, _QWORD, _QWORD);
// 9930: using guessed type __int64  _libssh2_sha384(_QWORD, _QWORD, _QWORD);
// 9A30: using guessed type __int64  _libssh2_sha256(_QWORD, _QWORD, _QWORD);

//----- (000000000000A454) ----------------------------------------------------
_BOOL4  libssh2_cipher_init(_QWORD *a1, __int64 (*a2)(void), __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // ST18_8
  __int64 v6; // ST10_8
  unsigned int v7; // ST0C_4
  __int64 v8; // rax

  v5 = a3;
  v6 = a4;
  v7 = a5;
  *a1 = EVP_CIPHER_CTX_new();
  v8 = a2();
  return (unsigned int)EVP_CipherInit(*a1, v8, v6, v5, v7) == 0;
}
// 8A50: using guessed type __int64  EVP_CipherInit(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9310: using guessed type __int64 EVP_CIPHER_CTX_new(void);

//----- (000000000000A4B2) ----------------------------------------------------
_BOOL4  libssh2_cipher_crypt(_QWORD *a1, __int64 a2, __int64 a3, void *a4, size_t a5)
{
  size_t n; // [rsp+8h] [rbp-68h]
  void *dest; // [rsp+10h] [rbp-60h]
  int v8; // [rsp+3Ch] [rbp-34h]
  char src; // [rsp+40h] [rbp-30h]
  unsigned __int64 v10; // [rsp+68h] [rbp-8h]

  dest = a4;
  n = a5;
  v10 = __readfsqword(0x28u);
  v8 = EVP_Cipher(*a1, &src, a4, (unsigned int)a5);
  if ( v8 == 1 )
    memcpy(dest, &src, n);
  return v8 != 1;
}
// 96D0: using guessed type __int64  EVP_Cipher(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000A539) ----------------------------------------------------
__int64 libssh2_openssl_crypto_init()
{
  ENGINE_load_builtin_engines();
  return ENGINE_register_all_complete();
}
// 9230: using guessed type __int64 ENGINE_load_builtin_engines(void);
// 9650: using guessed type __int64 ENGINE_register_all_complete(void);

//----- (000000000000A54A) ----------------------------------------------------
void libssh2_openssl_crypto_exit()
{
  ;
}

//----- (000000000000A551) ----------------------------------------------------
__int64  sub_A551(void *a1, int a2, __int64 a3, const char *a4)
{
  char *s; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+2Ch] [rbp-4h]

  s = (char *)a4;
  v6 = strlen(a4);
  if ( v6 > a2 - 1 )
    v6 = a2 - 1;
  memcpy(a1, s, v6);
  *((_BYTE *)a1 + v6) = 0;
  return (unsigned int)v6;
}

//----- (000000000000A5B8) ----------------------------------------------------
signed __int64  sub_A5B8(_QWORD *a1, __int64 ( *a2)(__int64, _QWORD, _QWORD, __int64), __int64 a3, unsigned int a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+38h] [rbp-8h]

  v6 = a5;
  *a1 = 0LL;
  v7 = BIO_new_mem_buf(a3, a4);
  if ( !v7 )
    return 0xFFFFFFFFLL;
  *a1 = a2(v7, 0LL, sub_A551, v6);
  BIO_free(v7);
  if ( *a1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 91D0: using guessed type __int64  BIO_new_mem_buf(_QWORD, _QWORD);
// 9830: using guessed type __int64  BIO_free(_QWORD);

//----- (000000000000A652) ----------------------------------------------------
signed __int64  sub_A652(_QWORD *a1, __int64 ( *a2)(__int64, _QWORD, _QWORD, __int64), __int64 a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-30h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a4;
  *a1 = 0LL;
  v6 = BIO_new_file(a3, "r");
  if ( !v6 )
    return 0xFFFFFFFFLL;
  *a1 = a2(v6, 0LL, sub_A551, v5);
  BIO_free(v6);
  if ( *a1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8E70: using guessed type __int64  BIO_new_file(_QWORD, _QWORD);
// 9830: using guessed type __int64  BIO_free(_QWORD);

//----- (000000000000A6E7) ----------------------------------------------------
__int64  libssh2_rsa_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+10h] [rbp-30h]
  __int64 v8; // [rsp+18h] [rbp-28h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  _libssh2_init_if_needed(a1, a2);
  v9 = sub_A5B8(a1, (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_RSAPrivateKey, v8, v7, v6);
  if ( v9 )
    v9 = read_openssh_private_key_from_memory(a1, a2, "ssh-rsa", v8, v7, v6);
  return v9;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 90E0: using guessed type __int64  read_openssh_private_key_from_memory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000A76F) ----------------------------------------------------
void * sub_A76F(__int64 a1, __int64 a2, _QWORD *a3)
{
  void *v4; // rax
  signed __int64 v5; // rax
  _QWORD *v6; // [rsp+8h] [rbp-58h]
  unsigned int v7; // [rsp+28h] [rbp-38h]
  unsigned int v8; // [rsp+2Ch] [rbp-34h]
  __int64 v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  void *v12; // [rsp+48h] [rbp-18h]
  void *dest; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v6 = a3;
  v14 = __readfsqword(0x28u);
  RSA_get0_key(a2, &v10, &v9, 0LL);
  v7 = (signed int)((unsigned __int64)BN_num_bits(v9) + 7) / 8 + 1;
  v8 = (signed int)((unsigned __int64)BN_num_bits(v10) + 7) / 8 + 1;
  v11 = (signed int)(v7 + 19 + v8);
  v12 = (void *)(*(__int64 ( **)(__int64, __int64))(a1 + 8))(v11, a1);
  if ( !v12 )
    return 0LL;
  dest = v12;
  _libssh2_htonu32(v12, 7LL);
  dest = (char *)dest + 4;
  memcpy(dest, "ssh-rsa", 7uLL);
  dest = (char *)dest + 7;
  v4 = (void *)sub_9BBA((__int64)dest, v9, v7);
  dest = v4;
  v5 = sub_9BBA((__int64)v4, v10, v8);
  *v6 = v5 - (_QWORD)v12;
  return v12;
}
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9A20: using guessed type __int64  RSA_get0_key(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000A8CA) ----------------------------------------------------
__int64  sub_A8CA(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  __int64 result; // rax
  _QWORD *v7; // [rsp+8h] [rbp-58h]
  _QWORD *v8; // [rsp+10h] [rbp-50h]
  _QWORD *v9; // [rsp+18h] [rbp-48h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  void *dest; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  void *v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  dest = 0LL;
  v12 = EVP_PKEY_get1_RSA(a6);
  if ( v12
    && (dest = (void *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(7LL, a1)) != 0LL
    && (v13 = sub_A76F(a1, v12, &v10)) != 0LL )
  {
    RSA_free(v12);
    memcpy(dest, "ssh-rsa", 7uLL);
    *a2 = dest;
    *v9 = 7LL;
    *v8 = v13;
    *v7 = v10;
    result = 0LL;
  }
  else
  {
    if ( v12 )
      RSA_free(v12);
    if ( dest )
      (*(void ( **)(void *, __int64))(a1 + 24))(dest, a1);
    result = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 97B0: using guessed type __int64  RSA_free(_QWORD);
// 98E0: using guessed type __int64  EVP_PKEY_get1_RSA(_QWORD);

//----- (000000000000AA25) ----------------------------------------------------
signed __int64  sub_AA25(__int64 a1)
{
  __int64 *v1; // rsi
  __int64 v3; // rax
  __int64 v4; // rax
  unsigned int v5; // [rsp+1Ch] [rbp-44h]
  __int64 *v6; // [rsp+20h] [rbp-40h]
  __int64 *v7; // [rsp+28h] [rbp-38h]
  __int64 v8; // [rsp+30h] [rbp-30h]
  __int64 *v9; // [rsp+38h] [rbp-28h]
  __int64 *v10; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+48h] [rbp-18h]
  __int64 v12; // [rsp+50h] [rbp-10h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v11 = 0LL;
  v12 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  v5 = 0;
  RSA_get0_key(a1, 0LL, 0LL, &v8);
  v1 = (__int64 *)&v6;
  RSA_get0_factors(a1, &v6, &v7);
  v11 = BN_CTX_new();
  if ( !v11 )
    return 0xFFFFFFFFLL;
  v12 = BN_new(a1, &v6);
  if ( v12 )
  {
    v9 = (__int64 *)BN_new(a1, &v6);
    if ( v9 )
    {
      v10 = (__int64 *)BN_new(a1, &v6);
      if ( v10 )
      {
        v3 = BN_value_one();
        v1 = v7;
        if ( (unsigned int)BN_sub(v12, v7, v3)
          && (v1 = v10, (unsigned int)BN_div(0LL, v10, v8, v12, v11))
          && (v4 = BN_value_one(), v1 = v6, (unsigned int)BN_sub(v12, v6, v4))
          && (v1 = v9, (unsigned int)BN_div(0LL, v9, v8, v12, v11)) )
        {
          v1 = v9;
          RSA_set0_crt_params(a1, v9, v10, 0LL);
        }
        else
        {
          v5 = -1;
        }
      }
      else
      {
        v5 = -1;
      }
    }
    else
    {
      v5 = -1;
    }
  }
  else
  {
    v5 = -1;
  }
  if ( v12 )
    BN_clear_free(v12, v1);
  BN_CTX_free(v11, v1);
  if ( v5 )
  {
    if ( v9 )
      BN_clear_free(v9, v1);
    if ( v10 )
      BN_clear_free(v10, v1);
  }
  return v5;
}
// 8910: using guessed type __int64  BN_div(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8DF0: using guessed type __int64  BN_sub(_QWORD, _QWORD, _QWORD);
// 8E80: using guessed type __int64  RSA_get0_factors(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 9220: using guessed type __int64 BN_value_one(void);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);
// 95A0: using guessed type __int64  RSA_set0_crt_params(_QWORD, _QWORD, _QWORD, _QWORD);
// 9A20: using guessed type __int64  RSA_get0_key(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000AC2D) ----------------------------------------------------
__int64  sub_AC2D(__int64 a1, __int64 a2, void **a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  __int64 result; // rax
  _QWORD *v8; // [rsp+10h] [rbp-E0h]
  _QWORD *v9; // [rsp+18h] [rbp-D8h]
  _QWORD *v10; // [rsp+20h] [rbp-D0h]
  void **v11; // [rsp+28h] [rbp-C8h]
  unsigned int v12; // [rsp+44h] [rbp-ACh]
  __int64 v13; // [rsp+48h] [rbp-A8h]
  __int64 v14; // [rsp+50h] [rbp-A0h]
  __int64 v15; // [rsp+58h] [rbp-98h]
  __int64 v16; // [rsp+60h] [rbp-90h]
  __int64 v17; // [rsp+68h] [rbp-88h]
  __int64 v18; // [rsp+70h] [rbp-80h]
  char v19; // [rsp+78h] [rbp-78h]
  __int64 v20; // [rsp+80h] [rbp-70h]
  __int64 v21; // [rsp+88h] [rbp-68h]
  __int64 v22; // [rsp+90h] [rbp-60h]
  __int64 v23; // [rsp+98h] [rbp-58h]
  __int64 v24; // [rsp+A0h] [rbp-50h]
  __int64 v25; // [rsp+A8h] [rbp-48h]
  char v26; // [rsp+B0h] [rbp-40h]
  __int64 v27; // [rsp+B8h] [rbp-38h]
  __int64 v28; // [rsp+C0h] [rbp-30h]
  unsigned __int64 v29; // [rsp+C8h] [rbp-28h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  v29 = __readfsqword(0x28u);
  v27 = 0LL;
  if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v20, &v13) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no n");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v21, &v14) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no e");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v22, &v15) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no d");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v25, &v18) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no coeff");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v23, &v16) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no p");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v24, &v17) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no q");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_string(a2, &v26, &v19) )
  {
    _libssh2_error(a1, 4294967282LL, "RSA no comment");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v12 = _libssh2_rsa_new(&v27, v21, v14, v20, v13, v22, v15, v23, v16, v24, v17, 0LL, 0LL, 0LL, 0LL, v25, v18);
    if ( v12 )
    {
      if ( v27 )
        RSA_free(v27);
      result = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
    }
    else
    {
      if ( v27 )
        v12 = sub_AA25(v27);
      if ( v27 )
      {
        if ( v9 )
        {
          if ( v11 )
          {
            v28 = EVP_PKEY_new();
            EVP_PKEY_set1_RSA(v28, v27);
            v12 = sub_A8CA(a1, v11, v10, v9, v8, v28);
            if ( v28 )
              EVP_PKEY_free(v28, v11);
          }
        }
      }
      if ( a7 )
        *a7 = v27;
      else
        RSA_free(v27);
      result = v12;
    }
  }
  return result;
}
// 8B60: using guessed type __int64  _libssh2_get_bignum_bytes(_QWORD, _QWORD, _QWORD);
// 8BE0: using guessed type __int64 EVP_PKEY_new(void);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F10: using guessed type __int64  EVP_PKEY_set1_RSA(_QWORD, _QWORD);
// 9450: using guessed type __int64  _libssh2_rsa_new(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);
// 97B0: using guessed type __int64  RSA_free(_QWORD);

//----- (000000000000B01B) ----------------------------------------------------
signed __int64  sub_B01B(_QWORD *a1, __int64 a2, char *a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-50h]
  const char *filename; // [rsp+8h] [rbp-48h]
  unsigned int v7; // [rsp+2Ch] [rbp-24h]
  unsigned int v8; // [rsp+2Ch] [rbp-24h]
  char *s2; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  FILE *stream; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  filename = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  s2 = 0LL;
  v10 = 0LL;
  if ( a2 )
  {
    _libssh2_init_if_needed(a1, a2);
    stream = fopen(filename, "r");
    if ( stream )
    {
      v7 = _libssh2_openssh_pem_parse(a2, v5, stream, &v10);
      fclose(stream);
      if ( v7 )
      {
        result = v7;
      }
      else if ( !(unsigned int)_libssh2_get_string(v10, &s2, 0LL) && s2 )
      {
        if ( !strcmp("ssh-rsa", s2) )
          v8 = sub_AC2D(a2, v10, 0LL, 0LL, 0LL, 0LL, a1);
        else
          v8 = -1;
        if ( v10 )
          _libssh2_string_buf_free(a2, v10);
        result = v8;
      }
      else
      {
        _libssh2_error(a2, 4294967282LL, "Public key type in decrypted key data not found");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      _libssh2_error(a2, 4294967280LL, "Unable to open OpenSSH RSA private key file");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    _libssh2_error(0LL, 4294967282LL, "Session is required");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8A80: using guessed type __int64  _libssh2_openssh_pem_parse(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000000B1C7) ----------------------------------------------------
__int64  libssh2_rsa_new_private(_QWORD *a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  char *v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]

  v6 = a3;
  v5 = a4;
  _libssh2_init_if_needed(a1, a2);
  v7 = sub_A652(
         a1,
         (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_RSAPrivateKey,
         (__int64)v6,
         v5);
  if ( v7 )
    v7 = sub_B01B(a1, a2, v6, v5);
  return v7;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);

//----- (000000000000B230) ----------------------------------------------------
__int64  libssh2_dsa_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+10h] [rbp-30h]
  __int64 v8; // [rsp+18h] [rbp-28h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  _libssh2_init_if_needed(a1, a2);
  v9 = sub_A5B8(a1, (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_DSAPrivateKey, v8, v7, v6);
  if ( v9 )
    v9 = read_openssh_private_key_from_memory(a1, a2, "ssh-dsa", v8, v7, v6);
  return v9;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 90E0: using guessed type __int64  read_openssh_private_key_from_memory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000B2B8) ----------------------------------------------------
void * sub_B2B8(__int64 a1, __int64 a2, _QWORD *a3)
{
  void *v4; // rax
  void *v5; // rax
  void *v6; // rax
  signed __int64 v7; // rax
  _QWORD *v8; // [rsp+8h] [rbp-68h]
  unsigned int v9; // [rsp+20h] [rbp-50h]
  unsigned int v10; // [rsp+24h] [rbp-4Ch]
  unsigned int v11; // [rsp+28h] [rbp-48h]
  unsigned int v12; // [rsp+2Ch] [rbp-44h]
  __int64 v13; // [rsp+30h] [rbp-40h]
  __int64 v14; // [rsp+38h] [rbp-38h]
  __int64 v15; // [rsp+40h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-28h]
  __int64 v17; // [rsp+50h] [rbp-20h]
  void *v18; // [rsp+58h] [rbp-18h]
  void *dest; // [rsp+60h] [rbp-10h]
  unsigned __int64 v20; // [rsp+68h] [rbp-8h]

  v8 = a3;
  v20 = __readfsqword(0x28u);
  DSA_get0_pqg(a2, &v13, &v14, &v15);
  DSA_get0_key(a2, &v16, 0LL);
  v9 = (signed int)((unsigned __int64)BN_num_bits(v13) + 7) / 8 + 1;
  v10 = (signed int)((unsigned __int64)BN_num_bits(v14) + 7) / 8 + 1;
  v11 = (signed int)((unsigned __int64)BN_num_bits(v15) + 7) / 8 + 1;
  v12 = (signed int)((unsigned __int64)BN_num_bits(v16) + 7) / 8 + 1;
  v17 = (signed int)(v9 + 19 + v10 + 4 + v11 + 4 + v12);
  v18 = (void *)(*(__int64 ( **)(__int64, __int64))(a1 + 8))(v17, a1);
  if ( !v18 )
    return 0LL;
  dest = v18;
  _libssh2_htonu32(v18, 7LL);
  dest = (char *)dest + 4;
  memcpy(dest, "ssh-dss", 7uLL);
  dest = (char *)dest + 7;
  v4 = (void *)sub_9BBA((__int64)dest, v13, v9);
  dest = v4;
  v5 = (void *)sub_9BBA((__int64)v4, v14, v10);
  dest = v5;
  v6 = (void *)sub_9BBA((__int64)v5, v15, v11);
  dest = v6;
  v7 = sub_9BBA((__int64)v6, v16, v12);
  *v8 = v7 - (_QWORD)v18;
  return v18;
}
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 8E40: using guessed type __int64  DSA_get0_key(_QWORD, _QWORD, _QWORD);
// 95D0: using guessed type __int64  DSA_get0_pqg(_QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (000000000000B4AE) ----------------------------------------------------
__int64  sub_B4AE(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  __int64 result; // rax
  _QWORD *v7; // [rsp+8h] [rbp-58h]
  _QWORD *v8; // [rsp+10h] [rbp-50h]
  _QWORD *v9; // [rsp+18h] [rbp-48h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  void *dest; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  void *v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  dest = 0LL;
  v12 = EVP_PKEY_get1_DSA(a6);
  if ( v12
    && (dest = (void *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(7LL, a1)) != 0LL
    && (v13 = sub_B2B8(a1, v12, &v10)) != 0LL )
  {
    DSA_free(v12);
    memcpy(dest, "ssh-dss", 7uLL);
    *a2 = dest;
    *v9 = 7LL;
    *v8 = v13;
    *v7 = v10;
    result = 0LL;
  }
  else
  {
    if ( v12 )
      DSA_free(v12);
    if ( dest )
      (*(void ( **)(void *, __int64))(a1 + 24))(dest, a1);
    result = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
  }
  return result;
}
// 8D40: using guessed type __int64  EVP_PKEY_get1_DSA(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9480: using guessed type __int64  DSA_free(_QWORD);

//----- (000000000000B609) ----------------------------------------------------
__int64  sub_B609(__int64 a1, __int64 a2, void **a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  __int64 result; // rax
  _QWORD *v8; // [rsp+10h] [rbp-B0h]
  _QWORD *v9; // [rsp+18h] [rbp-A8h]
  _QWORD *v10; // [rsp+20h] [rbp-A0h]
  void **v11; // [rsp+28h] [rbp-98h]
  unsigned int v12; // [rsp+44h] [rbp-7Ch]
  __int64 v13; // [rsp+48h] [rbp-78h]
  __int64 v14; // [rsp+50h] [rbp-70h]
  __int64 v15; // [rsp+58h] [rbp-68h]
  __int64 v16; // [rsp+60h] [rbp-60h]
  __int64 v17; // [rsp+68h] [rbp-58h]
  __int64 v18; // [rsp+70h] [rbp-50h]
  __int64 v19; // [rsp+78h] [rbp-48h]
  __int64 v20; // [rsp+80h] [rbp-40h]
  __int64 v21; // [rsp+88h] [rbp-38h]
  __int64 v22; // [rsp+90h] [rbp-30h]
  __int64 v23; // [rsp+98h] [rbp-28h]
  __int64 v24; // [rsp+A0h] [rbp-20h]
  unsigned __int64 v25; // [rsp+A8h] [rbp-18h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  v25 = __readfsqword(0x28u);
  v23 = 0LL;
  if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v18, &v13) )
  {
    _libssh2_error(a1, 4294967282LL, "DSA no p");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v19, &v14) )
  {
    _libssh2_error(a1, 4294967282LL, "DSA no q");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v20, &v15) )
  {
    _libssh2_error(a1, 4294967282LL, "DSA no g");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v21, &v16) )
  {
    _libssh2_error(a1, 4294967282LL, "DSA no public key");
    result = 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)_libssh2_get_bignum_bytes(a2, &v22, &v17) )
  {
    _libssh2_error(a1, 4294967282LL, "DSA no private key");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v12 = _libssh2_dsa_new(&v23, v18, v13, v19, v14, v20, v15, v21, v16, v22, v17);
    if ( v12 )
    {
      if ( v23 )
        DSA_free(v23);
      result = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
    }
    else
    {
      if ( v23 )
      {
        if ( v9 )
        {
          if ( v11 )
          {
            v24 = EVP_PKEY_new();
            EVP_PKEY_set1_DSA(v24, v23);
            v12 = sub_B4AE(a1, v11, v10, v9, v8, v24);
            if ( v24 )
              EVP_PKEY_free(v24, v11);
          }
        }
      }
      if ( a7 )
        *a7 = v23;
      else
        DSA_free(v23);
      result = v12;
    }
  }
  return result;
}
// 89E0: using guessed type __int64  EVP_PKEY_set1_DSA(_QWORD, _QWORD);
// 8B60: using guessed type __int64  _libssh2_get_bignum_bytes(_QWORD, _QWORD, _QWORD);
// 8BE0: using guessed type __int64 EVP_PKEY_new(void);
// 8D80: using guessed type __int64  _libssh2_dsa_new(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9480: using guessed type __int64  DSA_free(_QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000B90E) ----------------------------------------------------
signed __int64  sub_B90E(_QWORD *a1, __int64 a2, char *a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-50h]
  const char *filename; // [rsp+8h] [rbp-48h]
  unsigned int v7; // [rsp+2Ch] [rbp-24h]
  unsigned int v8; // [rsp+2Ch] [rbp-24h]
  char *s2; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  FILE *stream; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  filename = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  s2 = 0LL;
  v10 = 0LL;
  if ( a2 )
  {
    _libssh2_init_if_needed(a1, a2);
    stream = fopen(filename, "r");
    if ( stream )
    {
      v7 = _libssh2_openssh_pem_parse(a2, v5, stream, &v10);
      fclose(stream);
      if ( v7 )
      {
        result = v7;
      }
      else if ( !(unsigned int)_libssh2_get_string(v10, &s2, 0LL) && s2 )
      {
        if ( !strcmp("ssh-dss", s2) )
          v8 = sub_B609(a2, v10, 0LL, 0LL, 0LL, 0LL, a1);
        else
          v8 = -1;
        if ( v10 )
          _libssh2_string_buf_free(a2, v10);
        result = v8;
      }
      else
      {
        _libssh2_error(a2, 4294967282LL, "Public key type in decrypted key data not found");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      _libssh2_error(a2, 4294967280LL, "Unable to open OpenSSH DSA private key file");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    _libssh2_error(0LL, 4294967282LL, "Session is required");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8A80: using guessed type __int64  _libssh2_openssh_pem_parse(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000000BABA) ----------------------------------------------------
__int64  libssh2_dsa_new_private(_QWORD *a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  char *v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]

  v6 = a3;
  v5 = a4;
  _libssh2_init_if_needed(a1, a2);
  v7 = sub_A652(
         a1,
         (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_DSAPrivateKey,
         (__int64)v6,
         v5);
  if ( v7 )
    v7 = sub_B90E(a1, a2, v6, v5);
  return v7;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);

//----- (000000000000BB23) ----------------------------------------------------
__int64  libssh2_ecdsa_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+10h] [rbp-30h]
  __int64 v8; // [rsp+18h] [rbp-28h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  _libssh2_init_if_needed(a1, a2);
  v9 = sub_A5B8(a1, (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_ECPrivateKey, v8, v7, v6);
  if ( v9 )
    v9 = read_openssh_private_key_from_memory(a1, a2, "ssh-ecdsa", v8, v7, v6);
  return v9;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 90E0: using guessed type __int64  read_openssh_private_key_from_memory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000BBAB) ----------------------------------------------------
signed __int64  libssh2_curve25519_new(__int64 a1, _QWORD *a2, void **a3, void **a4)
{
  __int64 *v5; // rsi
  void **v6; // [rsp+0h] [rbp-80h]
  void **v7; // [rsp+8h] [rbp-78h]
  _QWORD *v8; // [rsp+10h] [rbp-70h]
  int v9; // [rsp+20h] [rbp-60h]
  int v10; // [rsp+24h] [rbp-5Ch]
  unsigned int v11; // [rsp+28h] [rbp-58h]
  int v12; // [rsp+2Ch] [rbp-54h]
  __int64 *v13; // [rsp+30h] [rbp-50h]
  __int64 v14; // [rsp+38h] [rbp-48h]
  char v15; // [rsp+40h] [rbp-40h]
  void *v16; // [rsp+48h] [rbp-38h]
  __int64 v17; // [rsp+50h] [rbp-30h]
  __int128 v18; // [rsp+58h] [rbp-28h]
  __int64 v19; // [rsp+68h] [rbp-18h]
  void *src; // [rsp+70h] [rbp-10h]
  unsigned __int64 v21; // [rsp+78h] [rbp-8h]

  v8 = a2;
  v7 = a3;
  v6 = a4;
  v21 = __readfsqword(0x28u);
  v13 = 0LL;
  v17 = 0LL;
  v14 = 0LL;
  v19 = 0LL;
  v11 = -1;
  v18 = (unsigned __int64)EVP_PKEY_CTX_new_id(1034LL, 0LL);
  if ( !(_QWORD)v18 )
    return 0xFFFFFFFFLL;
  EVP_PKEY_keygen_init(v18);
  v5 = (__int64 *)&v13;
  EVP_PKEY_keygen(v18, &v13);
  *((_QWORD *)&v18 + 1) = EVP_PKEY2PKCS8(v13);
  if ( *((_QWORD *)&v18 + 1) )
  {
    v5 = (__int64 *)&v15;
    if ( (unsigned int)PKCS8_pkey_get0(0LL, &v15, &v10, 0LL, *((_QWORD *)&v18 + 1)) )
    {
      v5 = (__int64 *)&v15;
      v17 = d2i_ASN1_OCTET_STRING(0LL, &v15, v10);
      if ( v17 )
      {
        src = (void *)ASN1_STRING_get0_data(v17);
        v12 = ASN1_STRING_length(v17);
        if ( v12 == 32 )
        {
          v14 = X509_PUBKEY_new();
          if ( v14 )
          {
            v5 = v13;
            if ( (unsigned int)X509_PUBKEY_set(&v14, v13) )
            {
              v5 = (__int64 *)&v16;
              if ( (unsigned int)X509_PUBKEY_get0_param(0LL, &v16, &v9, 0LL, v14) )
              {
                if ( v9 == 32 )
                {
                  if ( v6 )
                  {
                    v5 = (__int64 *)a1;
                    *v6 = (void *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(32LL, a1);
                    if ( !*v6 )
                      goto LABEL_21;
                    v5 = (__int64 *)src;
                    memcpy(*v6, src, 0x20uLL);
                  }
                  if ( v7 )
                  {
                    v5 = (__int64 *)a1;
                    *v7 = (void *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(32LL, a1);
                    if ( !*v7 )
                      goto LABEL_21;
                    v5 = (__int64 *)v16;
                    memcpy(*v7, v16, 0x20uLL);
                  }
                  if ( !v8 )
                  {
LABEL_20:
                    v11 = 0;
                    goto LABEL_21;
                  }
                  v5 = 0LL;
                  v19 = EVP_PKEY_new_raw_private_key(1034LL, 0LL, src, 32LL);
                  if ( v19 )
                  {
                    *v8 = v19;
                    goto LABEL_20;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_21:
  if ( *((_QWORD *)&v18 + 1) )
    PKCS8_PRIV_KEY_INFO_free(*((_QWORD *)&v18 + 1), v5);
  if ( (_QWORD)v18 )
    EVP_PKEY_CTX_free(v18, v5);
  if ( v17 )
    ASN1_OCTET_STRING_free(v17, v5);
  if ( v14 )
    X509_PUBKEY_free(v14, v5);
  if ( v13 )
    EVP_PKEY_free(v13, v5);
  return v11;
}
// 8B90: using guessed type __int64  EVP_PKEY2PKCS8(_QWORD);
// 8DC0: using guessed type __int64  ASN1_STRING_get0_data(_QWORD);
// 8DE0: using guessed type __int64  PKCS8_pkey_get0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8F20: using guessed type __int64  EVP_PKEY_keygen_init(_QWORD);
// 9190: using guessed type __int64 X509_PUBKEY_new(void);
// 92C0: using guessed type __int64  X509_PUBKEY_get0_param(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 92E0: using guessed type __int64  EVP_PKEY_CTX_free(_QWORD, _QWORD);
// 93D0: using guessed type __int64  EVP_PKEY_keygen(_QWORD, _QWORD);
// 9470: using guessed type __int64  ASN1_OCTET_STRING_free(_QWORD, _QWORD);
// 9620: using guessed type __int64  EVP_PKEY_new_raw_private_key(_QWORD, _QWORD, _QWORD, _QWORD);
// 96A0: using guessed type __int64  X509_PUBKEY_free(_QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);
// 9860: using guessed type __int64  X509_PUBKEY_set(_QWORD, _QWORD);
// 9880: using guessed type __int64  EVP_PKEY_CTX_new_id(_QWORD, _QWORD);
// 9940: using guessed type __int64  d2i_ASN1_OCTET_STRING(_QWORD, _QWORD, _QWORD);
// 9A90: using guessed type __int64  PKCS8_PRIV_KEY_INFO_free(_QWORD, _QWORD);
// 9AB0: using guessed type __int64  ASN1_STRING_length(_QWORD);

//----- (000000000000BEB8) ----------------------------------------------------
signed __int64  sub_BEB8(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-70h]
  _QWORD *v8; // [rsp+8h] [rbp-68h]
  _QWORD *v9; // [rsp+10h] [rbp-60h]
  _QWORD *v10; // [rsp+18h] [rbp-58h]
  __int64 v11; // [rsp+30h] [rbp-40h]
  __int64 v12; // [rsp+38h] [rbp-38h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  __int128 dest; // [rsp+48h] [rbp-28h]
  __int64 src; // [rsp+5Ch] [rbp-14h]
  int v16; // [rsp+64h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v17 = __readfsqword(0x28u);
  src = 3833236618562007923LL;
  v16 = 3748149;
  *(_QWORD *)&dest = 0LL;
  v11 = 0LL;
  v13 = 0LL;
  v12 = 0LL;
  dest = (unsigned __int64)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(11LL, a1);
  if ( (_QWORD)dest )
  {
    memcpy((void *)dest, &src, 0xBuLL);
    if ( (unsigned int)EVP_PKEY_get_raw_public_key(v7, 0LL, &v11) == 1 )
    {
      *((_QWORD *)&dest + 1) = v11 + 19;
      v13 = (*(__int64 ( **)(__int64, __int64))(a1 + 8))(v11 + 19, a1);
      v12 = v13;
      if ( v13 )
      {
        _libssh2_store_str(&v12, &src, 11LL);
        _libssh2_store_u32(&v12, (unsigned int)v11);
        if ( (unsigned int)EVP_PKEY_get_raw_public_key(v7, v12, &v11) == 1 )
        {
          *a2 = dest;
          *v10 = 11LL;
          *v9 = v13;
          *v8 = *((_QWORD *)&dest + 1);
          return 0LL;
        }
        _libssh2_error(a1, 4294967282LL, "EVP_PKEY_get_raw_public_key failed");
      }
      else
      {
        _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
      }
    }
    else
    {
      _libssh2_error(a1, 4294967282LL, "EVP_PKEY_get_raw_public_key failed");
    }
  }
  else
  {
    _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
  }
  if ( (_QWORD)dest )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(dest, a1);
  if ( v13 )
    (*(void ( **)(__int64, __int64))(a1 + 24))(v13, a1);
  return 0xFFFFFFFFLL;
}
// 8990: using guessed type __int64  EVP_PKEY_get_raw_public_key(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);


//----- (000000000000C0F3) ----------------------------------------------------
signed __int64  sub_C0F3(signed __int64 a1, __int64 a2, void **a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  signed __int64 v8; // rsi
  const char *v9; // rsi
  _QWORD *v10; // [rsp+10h] [rbp-90h]
  _QWORD *v11; // [rsp+18h] [rbp-88h]
  _QWORD *v12; // [rsp+20h] [rbp-80h]
  void **v13; // [rsp+28h] [rbp-78h]
  signed int v14; // [rsp+40h] [rbp-60h]
  __int64 v15; // [rsp+48h] [rbp-58h]
  __int64 v16; // [rsp+50h] [rbp-50h]
  void *src; // [rsp+58h] [rbp-48h]
  size_t n; // [rsp+60h] [rbp-40h]
  __int64 v19; // [rsp+68h] [rbp-38h]
  __int64 v20; // [rsp+70h] [rbp-30h]
  void *v21; // [rsp+78h] [rbp-28h]
  __int64 v22; // [rsp+80h] [rbp-20h]
  __int64 v23; // [rsp+88h] [rbp-18h]
  void *dest; // [rsp+90h] [rbp-10h]
  unsigned __int64 v25; // [rsp+98h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  v25 = __readfsqword(0x28u);
  v20 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  n = 0LL;
  if ( (unsigned int)_libssh2_get_string(a2, &v15, &n) || n != 32 )
  {
    _libssh2_error(a1, 4294967282LL, "Wrong public key length");
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)_libssh2_get_string(a2, &v16, &n) || n != 64 )
  {
    v8 = 4294967282LL;
    _libssh2_error(a1, 4294967282LL, "Wrong private key length");
LABEL_34:
    if ( v20 )
      EVP_PKEY_free(v20, v8);
    if ( v21 )
      (*(void ( **)(void *, signed __int64))(a1 + 24))(v21, a1);
    if ( v22 )
      (*(void ( **)(__int64, signed __int64))(a1 + 24))(v22, a1);
    return 0xFFFFFFFFLL;
  }
  v20 = EVP_PKEY_new_raw_private_key(1087LL, 0LL, v16, 32LL);
  if ( (unsigned int)_libssh2_get_string(a2, &src, &n) )
  {
    v8 = 4294967282LL;
    _libssh2_error(a1, 4294967282LL, "Unable to read comment");
    goto LABEL_34;
  }
  if ( n )
  {
    dest = (void *)_libssh2_calloc(a1, n + 1);
    if ( dest )
    {
      memcpy(dest, src, n);
      memcpy((char *)dest + n, &unk_4468B, 1uLL);
      (*(void ( **)(void *, signed __int64))(a1 + 24))(dest, a1);
    }
  }
  v14 = 1;
  while ( *(_QWORD *)(a2 + 8) < *(_QWORD *)a2 + *(_QWORD *)(a2 + 16) )
  {
    if ( v14 != **(unsigned __int8 **)(a2 + 8) )
    {
      v8 = 4294967282LL;
      _libssh2_error(a1, 4294967282LL, "Wrong padding");
      goto LABEL_34;
    }
    ++v14;
    ++*(_QWORD *)(a2 + 8);
  }
  v8 = a1;
  v21 = (void *)(*(__int64 ( **)(signed __int64, signed __int64))(a1 + 8))(11LL, a1);
  if ( !v21 )
    goto LABEL_34;
  v23 = 51LL;
  v8 = 51LL;
  v22 = _libssh2_calloc(a1, 51LL);
  if ( !v22 )
    goto LABEL_34;
  v19 = v22;
  _libssh2_store_str(&v19, "ssh-ed25519", 11LL);
  _libssh2_store_str(&v19, v15, 32LL);
  v9 = "ssh-ed25519";
  memcpy(v21, "ssh-ed25519", 0xBuLL);
  if ( v13 )
  {
    *v13 = v21;
  }
  else
  {
    v9 = (const char *)a1;
    (*(void ( **)(void *, signed __int64))(a1 + 24))(v21, a1);
  }
  if ( v12 )
    *v12 = 11LL;
  if ( v11 )
  {
    *v11 = v22;
  }
  else
  {
    v9 = (const char *)a1;
    (*(void ( **)(__int64, signed __int64))(a1 + 24))(v22, a1);
  }
  if ( v10 )
    *v10 = v23;
  if ( a7 )
  {
    *a7 = v20;
  }
  else if ( v20 )
  {
    EVP_PKEY_free(v20, v9);
  }
  return 0LL;
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9620: using guessed type __int64  EVP_PKEY_new_raw_private_key(_QWORD, _QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000C51B) ----------------------------------------------------
signed __int64  libssh2_ed25519_new_private(_QWORD *a1, signed __int64 a2, char *a3, __int64 a4)
{
  signed __int64 result; // rax
  char *v5; // rsi
  __int64 v6; // [rsp+0h] [rbp-50h]
  const char *filename; // [rsp+8h] [rbp-48h]
  signed __int64 v8; // [rsp+10h] [rbp-40h]
  unsigned int v9; // [rsp+24h] [rbp-2Ch]
  unsigned int v10; // [rsp+24h] [rbp-2Ch]
  char *s2; // [rsp+28h] [rbp-28h]
  char *v12; // [rsp+30h] [rbp-20h]
  __int64 v13; // [rsp+38h] [rbp-18h]
  FILE *stream; // [rsp+40h] [rbp-10h]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v8 = a2;
  filename = a3;
  v6 = a4;
  v15 = __readfsqword(0x28u);
  v12 = 0LL;
  v13 = 0LL;
  if ( a2 )
  {
    _libssh2_init_if_needed(a1, a2);
    stream = fopen(filename, "r");
    if ( stream )
    {
      v9 = _libssh2_openssh_pem_parse(a2, v6, stream, &v12);
      fclose(stream);
      if ( v9 )
      {
        result = v9;
      }
      else if ( !(unsigned int)_libssh2_get_string(v12, &s2, 0LL) && s2 )
      {
        v5 = s2;
        if ( !strcmp("ssh-ed25519", s2) )
        {
          v5 = v12;
          v10 = sub_C0F3(v8, (__int64)v12, 0LL, 0LL, 0LL, 0LL, &v13);
        }
        else
        {
          v10 = -1;
        }
        if ( v12 )
        {
          v5 = v12;
          _libssh2_string_buf_free(v8, v12);
        }
        if ( !v10 )
        {
          if ( a1 )
          {
            *a1 = v13;
          }
          else if ( v13 )
          {
            EVP_PKEY_free(v13, v5);
          }
        }
        result = v10;
      }
      else
      {
        _libssh2_error(a2, 4294967282LL, "Public key type in decrypted key data not found");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      _libssh2_error(a2, 4294967280LL, "Unable to open ED25519 private key file");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    _libssh2_error(a2, 4294967282LL, "Session is required");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8A80: using guessed type __int64  _libssh2_openssh_pem_parse(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000C6FB) ----------------------------------------------------
__int64  libssh2_ed25519_new_private_frommemory(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 result; // rax
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+10h] [rbp-30h]
  __int64 v8; // [rsp+18h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = __readfsqword(0x28u);
  v9 = 0LL;
  _libssh2_init_if_needed(a1, a2);
  if ( (unsigned int)sub_A5B8(
                       &v9,
                       (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_PrivateKey,
                       v8,
                       v7,
                       v6) )
    return read_openssh_private_key_from_memory(a1, a2, "ssh-ed25519", v8, v7, v6);
  if ( (unsigned int)EVP_PKEY_id(v9, &PEM_read_bio_PrivateKey) == 1087 )
  {
    *a1 = v9;
    result = 0LL;
  }
  else
  {
    EVP_PKEY_free(v9, &PEM_read_bio_PrivateKey);
    result = _libssh2_error(a2, 4294967282LL, "Private key is not an ED25519 key");
  }
  return result;
}
// 8D10: using guessed type __int64  EVP_PKEY_id(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 90E0: using guessed type __int64  read_openssh_private_key_from_memory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000C7E6) ----------------------------------------------------
__int64  libssh2_ed25519_new_public(__int64 *a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v5 = EVP_PKEY_new_raw_public_key(1087LL, 0LL, a3, a4);
  if ( !v5 )
    return _libssh2_error(a2, 4294967282LL, "could not create ED25519 public key");
  if ( a1 )
  {
    *a1 = v5;
  }
  else if ( v5 )
  {
    EVP_PKEY_free(v5, 0LL);
  }
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8E50: using guessed type __int64  EVP_PKEY_new_raw_public_key(_QWORD, _QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000C885) ----------------------------------------------------
signed __int64  libssh2_rsa_sha1_sign(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, _QWORD *a5, _QWORD *a6)
{
  signed __int64 result; // rax
  _QWORD *v7; // [rsp+0h] [rbp-50h]
  _QWORD *v8; // [rsp+8h] [rbp-48h]
  unsigned int v9; // [rsp+10h] [rbp-40h]
  __int64 v10; // [rsp+18h] [rbp-38h]
  unsigned int v11; // [rsp+38h] [rbp-18h]
  int v12; // [rsp+3Ch] [rbp-14h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v14 = __readfsqword(0x28u);
  v11 = RSA_size(a2);
  v13 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(v11, a1);
  if ( !v13 )
    return 0xFFFFFFFFLL;
  v12 = RSA_sign(64LL, v10, v9, v13, &v11, a2);
  if ( v12 )
  {
    *v8 = v13;
    *v7 = v11;
    result = 0LL;
  }
  else
  {
    (*(void ( **)(__int64, __int64))(a1 + 24))(v13, a1);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8EA0: using guessed type __int64  RSA_size(_QWORD);
// 94F0: using guessed type __int64  RSA_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000C976) ----------------------------------------------------
signed __int64  libssh2_dsa_sha1_sign(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  signed __int64 result; // rax
  signed __int64 v5; // rsi
  char *s; // [rsp+0h] [rbp-50h]
  int v7; // [rsp+28h] [rbp-28h]
  int v8; // [rsp+2Ch] [rbp-24h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  s = a4;
  v12 = __readfsqword(0x28u);
  v11 = DSA_do_sign(a2, 20LL, a1);
  if ( !v11 )
    return 0xFFFFFFFFLL;
  DSA_SIG_get0(v11, &v9, &v10);
  v7 = (signed int)((unsigned __int64)BN_num_bits(v9) + 7) / 8;
  if ( v7 > 0 && v7 <= 20 )
  {
    v8 = (signed int)((unsigned __int64)BN_num_bits(v10) + 7) / 8;
    if ( v8 > 0 && v8 <= 20 )
    {
      memset(s, 0, 0x28uLL);
      BN_bn2bin(v9, &s[20 - v7]);
      v5 = (signed __int64)&s[20 - v8 + 20];
      BN_bn2bin(v10, v5);
      DSA_SIG_free(v11, v5);
      result = 0LL;
    }
    else
    {
      DSA_SIG_free(v11, &v9);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    DSA_SIG_free(v11, &v9);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8C00: using guessed type __int64  DSA_do_sign(_QWORD, _QWORD, _QWORD);
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 9520: using guessed type __int64  DSA_SIG_get0(_QWORD, _QWORD, _QWORD);
// 9780: using guessed type __int64  BN_bn2bin(_QWORD, _QWORD);
// 9970: using guessed type __int64  DSA_SIG_free(_QWORD, _QWORD);

//----- (000000000000CADB) ----------------------------------------------------
signed __int64  libssh2_ecdsa_sign(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void **a5, size_t *a6)
{
  size_t *v7; // [rsp+0h] [rbp-80h]
  void **v8; // [rsp+8h] [rbp-78h]
  unsigned int v9; // [rsp+34h] [rbp-4Ch]
  unsigned int v10; // [rsp+38h] [rbp-48h]
  unsigned int v11; // [rsp+3Ch] [rbp-44h]
  __int64 v12; // [rsp+40h] [rbp-40h]
  __int64 v13; // [rsp+48h] [rbp-38h]
  size_t n; // [rsp+50h] [rbp-30h]
  void *src; // [rsp+58h] [rbp-28h]
  void *dest; // [rsp+60h] [rbp-20h]
  __int64 v17; // [rsp+68h] [rbp-18h]
  __int64 v18; // [rsp+70h] [rbp-10h]
  unsigned __int64 v19; // [rsp+78h] [rbp-8h]

  v8 = a5;
  v7 = a6;
  v19 = __readfsqword(0x28u);
  v9 = 0;
  n = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  src = 0LL;
  dest = 0LL;
  v17 = ECDSA_do_sign(a3, a4, a2);
  if ( !v17 )
    return 0xFFFFFFFFLL;
  ECDSA_SIG_get0(v17, &v12, &v13);
  v10 = (signed int)((unsigned __int64)BN_num_bits(v12) + 7) / 8 + 1;
  v11 = (signed int)((unsigned __int64)BN_num_bits(v13) + 7) / 8 + 1;
  src = malloc((signed int)(v10 + v11 + 8));
  if ( src )
  {
    v18 = (__int64)src;
    v18 = sub_9BBA((__int64)src, v12, v10);
    v18 = sub_9BBA(v18, v13, v11);
    n = v18 - (_QWORD)src;
    dest = (void *)_libssh2_calloc(a1, v18 - (_QWORD)src);
    if ( dest )
    {
      memcpy(dest, src, n);
      *v8 = dest;
      *v7 = n;
    }
    else
    {
      v9 = -1;
    }
  }
  else
  {
    v9 = -1;
  }
  if ( src )
    free(src);
  if ( v17 )
    ECDSA_SIG_free(v17);
  return v9;
}
// 8B40: using guessed type __int64  ECDSA_SIG_get0(_QWORD, _QWORD, _QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 97A0: using guessed type __int64  ECDSA_SIG_free(_QWORD);
// 9910: using guessed type __int64  ECDSA_do_sign(_QWORD, _QWORD, _QWORD);

//----- (000000000000CCCA) ----------------------------------------------------
signed __int64  libssh2_sha1_init(_QWORD *a1)
{
  __int64 v2; // rax

  *a1 = EVP_MD_CTX_new();
  if ( !*a1 )
    return 0LL;
  v2 = EVP_get_digestbyname("sha1");
  if ( (unsigned int)EVP_DigestInit(*a1, v2) )
    return 1LL;
  EVP_MD_CTX_free(*a1);
  *a1 = 0LL;
  return 0LL;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000CD45) ----------------------------------------------------
signed __int64  libssh2_sha1(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a3;
  v6 = EVP_MD_CTX_new();
  if ( !v6 )
    return 1LL;
  v4 = EVP_get_digestbyname("sha1");
  if ( (unsigned int)EVP_DigestInit(v6, v4) )
  {
    EVP_DigestUpdate(v6, a1, a2);
    EVP_DigestFinal(v6, v5, 0LL);
    EVP_MD_CTX_free(v6);
    result = 0LL;
  }
  else
  {
    EVP_MD_CTX_free(v6);
    result = 1LL;
  }
  return result;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000CDE7) ----------------------------------------------------
signed __int64  libssh2_sha256_init(_QWORD *a1)
{
  __int64 v2; // rax

  *a1 = EVP_MD_CTX_new();
  if ( !*a1 )
    return 0LL;
  v2 = EVP_get_digestbyname("sha256");
  if ( (unsigned int)EVP_DigestInit(*a1, v2) )
    return 1LL;
  EVP_MD_CTX_free(*a1);
  *a1 = 0LL;
  return 0LL;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000CE62) ----------------------------------------------------
signed __int64  libssh2_sha256(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a3;
  v6 = EVP_MD_CTX_new();
  if ( !v6 )
    return 1LL;
  v4 = EVP_get_digestbyname("sha256");
  if ( (unsigned int)EVP_DigestInit(v6, v4) )
  {
    EVP_DigestUpdate(v6, a1, a2);
    EVP_DigestFinal(v6, v5, 0LL);
    EVP_MD_CTX_free(v6);
    result = 0LL;
  }
  else
  {
    EVP_MD_CTX_free(v6);
    result = 1LL;
  }
  return result;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000CF04) ----------------------------------------------------
signed __int64  libssh2_sha384_init(_QWORD *a1)
{
  __int64 v2; // rax

  *a1 = EVP_MD_CTX_new();
  if ( !*a1 )
    return 0LL;
  v2 = EVP_get_digestbyname("sha384");
  if ( (unsigned int)EVP_DigestInit(*a1, v2) )
    return 1LL;
  EVP_MD_CTX_free(*a1);
  *a1 = 0LL;
  return 0LL;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000CF7F) ----------------------------------------------------
signed __int64  libssh2_sha384(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a3;
  v6 = EVP_MD_CTX_new();
  if ( !v6 )
    return 1LL;
  v4 = EVP_get_digestbyname("sha384");
  if ( (unsigned int)EVP_DigestInit(v6, v4) )
  {
    EVP_DigestUpdate(v6, a1, a2);
    EVP_DigestFinal(v6, v5, 0LL);
    EVP_MD_CTX_free(v6);
    result = 0LL;
  }
  else
  {
    EVP_MD_CTX_free(v6);
    result = 1LL;
  }
  return result;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000D021) ----------------------------------------------------
signed __int64  libssh2_sha512_init(_QWORD *a1)
{
  __int64 v2; // rax

  *a1 = EVP_MD_CTX_new();
  if ( !*a1 )
    return 0LL;
  v2 = EVP_get_digestbyname("sha512");
  if ( (unsigned int)EVP_DigestInit(*a1, v2) )
    return 1LL;
  EVP_MD_CTX_free(*a1);
  *a1 = 0LL;
  return 0LL;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000D09C) ----------------------------------------------------
signed __int64  libssh2_sha512(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v5 = a3;
  v6 = EVP_MD_CTX_new();
  if ( !v6 )
    return 1LL;
  v4 = EVP_get_digestbyname("sha512");
  if ( (unsigned int)EVP_DigestInit(v6, v4) )
  {
    EVP_DigestUpdate(v6, a1, a2);
    EVP_DigestFinal(v6, v5, 0LL);
    EVP_MD_CTX_free(v6);
    result = 0LL;
  }
  else
  {
    EVP_MD_CTX_free(v6);
    result = 1LL;
  }
  return result;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000D13E) ----------------------------------------------------
signed __int64  libssh2_md5_init(_QWORD *a1)
{
  __int64 v2; // rax

  *a1 = EVP_MD_CTX_new();
  if ( !*a1 )
    return 0LL;
  v2 = EVP_get_digestbyname("md5");
  if ( (unsigned int)EVP_DigestInit(*a1, v2) )
    return 1LL;
  EVP_MD_CTX_free(*a1);
  *a1 = 0LL;
  return 0LL;
}
// 8CF0: using guessed type __int64  EVP_get_digestbyname(_QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 98B0: using guessed type __int64  EVP_DigestInit(_QWORD, _QWORD);

//----- (000000000000D1B9) ----------------------------------------------------
__int64  sub_D1B9(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-90h]
  size_t *v8; // [rsp+8h] [rbp-88h]
  _QWORD *v9; // [rsp+10h] [rbp-80h]
  _QWORD *v10; // [rsp+18h] [rbp-78h]
  void **v11; // [rsp+20h] [rbp-70h]
  signed int v12; // [rsp+30h] [rbp-60h]
  int v13; // [rsp+34h] [rbp-5Ch]
  __int64 v14; // [rsp+38h] [rbp-58h]
  void *dest; // [rsp+40h] [rbp-50h]
  void *ptr; // [rsp+48h] [rbp-48h]
  __int64 v17; // [rsp+50h] [rbp-40h]
  size_t v18; // [rsp+58h] [rbp-38h]
  __int64 v19; // [rsp+60h] [rbp-30h]
  void **v20; // [rsp+68h] [rbp-28h]
  __int64 v21; // [rsp+70h] [rbp-20h]
  size_t size; // [rsp+78h] [rbp-18h]
  __int64 v23; // [rsp+80h] [rbp-10h]
  unsigned __int64 v24; // [rsp+88h] [rbp-8h]

  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v24 = __readfsqword(0x28u);
  v12 = 0;
  v17 = 0LL;
  dest = 0LL;
  v18 = 0LL;
  ptr = 0LL;
  v19 = BN_CTX_new();
  if ( !v19 )
    return 0xFFFFFFFFLL;
  v17 = EVP_PKEY_get1_EC_KEY(v7);
  if ( v17 )
  {
    v20 = (void **)EC_KEY_get0_public_key(v17);
    v21 = EC_KEY_get0_group(v17);
    v13 = _libssh2_ecdsa_get_curve_type(v17);
    a2 = (void **)a1;
    dest = (void *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(19LL, a1);
    if ( !dest )
      return _libssh2_error(a1, 4294967290LL, "out of memory");
    switch ( v13 )
    {
      case 415:
        memcpy(dest, "ecdsa-sha2-nistp256", 0x13uLL);
        break;
      case 715:
        memcpy(dest, "ecdsa-sha2-nistp384", 0x13uLL);
        break;
      case 716:
        memcpy(dest, "ecdsa-sha2-nistp521", 0x13uLL);
        break;
      default:
        v12 = -1;
        goto LABEL_23;
    }
    a2 = v20;
    size = EC_POINT_point2oct(v21, v20, 4LL, 0LL, 0LL, v19);
    if ( size <= 0x85 )
    {
      ptr = malloc(size);
      if ( ptr )
      {
        a2 = v20;
        if ( size == EC_POINT_point2oct(v21, v20, 4LL, ptr, size, v19) )
        {
          v18 = size + 39;
          a2 = (void **)a1;
          v23 = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(size + 39, a1);
          if ( v23 )
          {
            v14 = v23;
            _libssh2_store_str(&v14, dest, 19LL);
            _libssh2_store_str(&v14, (char *)dest + 11, 8LL);
            a2 = (void **)ptr;
            _libssh2_store_str(&v14, ptr, size);
            *v11 = dest;
            *v10 = 19LL;
            *v9 = v23;
            *v8 = v18;
          }
          else
          {
            v12 = -1;
          }
        }
        else
        {
          v12 = -1;
        }
      }
      else
      {
        v12 = -1;
      }
    }
    else
    {
      v12 = -1;
    }
    goto LABEL_23;
  }
  v12 = -1;
LABEL_23:
  if ( v17 )
    EC_KEY_free(v17);
  if ( v19 )
    BN_CTX_free(v19, a2);
  if ( ptr )
    free(ptr);
  if ( !v12 )
    return 0LL;
  if ( dest )
    (*(void ( **)(void *, __int64))(a1 + 24))(dest, a1);
  return 0xFFFFFFFFLL;
}
// 89F0: using guessed type __int64  EC_KEY_free(_QWORD);
// 8A70: using guessed type __int64  _libssh2_ecdsa_get_curve_type(_QWORD);
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8AE0: using guessed type __int64  EVP_PKEY_get1_EC_KEY(_QWORD);
// 8C20: using guessed type __int64  EC_KEY_get0_public_key(_QWORD);
// 8E00: using guessed type __int64  EC_KEY_get0_group(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8EF0: using guessed type __int64  EC_POINT_point2oct(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);

//----- (000000000000D517) ----------------------------------------------------
__int64  sub_D517(__int64 a1, unsigned int a2, __int64 a3, void **a4, _QWORD *a5, _QWORD *a6, size_t *a7, _QWORD *a8)
{
  __int64 v9; // rsi
  int v10; // eax
  _QWORD *v11; // [rsp+10h] [rbp-90h]
  _QWORD *v12; // [rsp+18h] [rbp-88h]
  void **v13; // [rsp+20h] [rbp-80h]
  __int64 v14; // [rsp+28h] [rbp-78h]
  unsigned int v15; // [rsp+34h] [rbp-6Ch]
  unsigned int v16; // [rsp+4Ch] [rbp-54h]
  __int64 v17; // [rsp+50h] [rbp-50h]
  __int64 v18; // [rsp+58h] [rbp-48h]
  __int64 v19; // [rsp+60h] [rbp-40h]
  char v20; // [rsp+68h] [rbp-38h]
  __int64 v21; // [rsp+70h] [rbp-30h]
  __int64 v22; // [rsp+78h] [rbp-28h]
  __int64 v23; // [rsp+80h] [rbp-20h]
  __int64 v24; // [rsp+88h] [rbp-18h]
  __int64 v25; // [rsp+90h] [rbp-10h]
  unsigned __int64 v26; // [rsp+98h] [rbp-8h]

  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  v26 = __readfsqword(0x28u);
  v23 = 0LL;
  if ( (unsigned int)_libssh2_get_string(a3, &v20, &v17) || !v17 )
  {
    _libssh2_error(a1, 4294967282LL, "ECDSA no curve");
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)_libssh2_get_string(v14, &v22, &v19) )
  {
    _libssh2_error(a1, 4294967282LL, "ECDSA no point");
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)_libssh2_get_bignum_bytes(v14, &v21, &v18) )
  {
    _libssh2_error(a1, 4294967282LL, "ECDSA no exponent");
    return 0xFFFFFFFFLL;
  }
  v9 = v22;
  if ( (unsigned int)_libssh2_ecdsa_curve_name_with_octal_new(&v23, v22, v19, v15) )
  {
    _libssh2_error(a1, 4294967282LL, "ECDSA could not create key");
LABEL_21:
    if ( v23 )
      EC_KEY_free(v23);
    return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for private key data");
  }
  v24 = BN_new(&v23, v9);
  if ( !v24 )
    goto LABEL_21;
  BN_bin2bn(v21, (unsigned int)v18, v24);
  v10 = EC_KEY_set_private_key(v23, v24);
  v16 = v10 != 1;
  if ( v10 == 1 )
  {
    if ( v23 )
    {
      if ( v11 )
      {
        if ( v13 )
        {
          v25 = EVP_PKEY_new();
          EVP_PKEY_set1_EC_KEY(v25, v23);
          v16 = sub_D1B9(a1, v13, v12, v11, a7, v25);
          if ( v25 )
            EVP_PKEY_free(v25, v13);
        }
      }
    }
  }
  if ( a8 )
    *a8 = v23;
  else
    EC_KEY_free(v23);
  return v16;
}
// 8970: using guessed type __int64  _libssh2_ecdsa_curve_name_with_octal_new(_QWORD, _QWORD, _QWORD, _QWORD);
// 89F0: using guessed type __int64  EC_KEY_free(_QWORD);
// 8B60: using guessed type __int64  _libssh2_get_bignum_bytes(_QWORD, _QWORD, _QWORD);
// 8BE0: using guessed type __int64 EVP_PKEY_new(void);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F30: using guessed type __int64  EVP_PKEY_set1_EC_KEY(_QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9360: using guessed type __int64  EC_KEY_set_private_key(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000D7B2) ----------------------------------------------------
signed __int64  sub_D7B2(_QWORD *a1, __int64 a2, char *a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-50h]
  const char *filename; // [rsp+8h] [rbp-48h]
  unsigned int v7; // [rsp+28h] [rbp-28h]
  unsigned int v8; // [rsp+2Ch] [rbp-24h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  FILE *stream; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  filename = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  v9 = 0LL;
  v10 = 0LL;
  if ( a2 )
  {
    _libssh2_init_if_needed(a1, a2);
    stream = fopen(filename, "r");
    if ( stream )
    {
      v8 = _libssh2_openssh_pem_parse(a2, v5, stream, &v10);
      fclose(stream);
      if ( v8 )
      {
        result = v8;
      }
      else
      {
        v8 = _libssh2_get_string(v10, &v9, 0LL);
        if ( !v8 && v9 )
        {
          v8 = _libssh2_ecdsa_curve_type_from_name(v9, &v7);
          if ( v8 )
            v8 = -1;
          else
            v8 = sub_D517(a2, v7, v10, 0LL, 0LL, 0LL, 0LL, a1);
          if ( v10 )
            _libssh2_string_buf_free(a2, v10);
          result = v8;
        }
        else
        {
          _libssh2_error(a2, 4294967282LL, "Public key type in decrypted key data not found");
          result = 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      _libssh2_error(a2, 4294967280LL, "Unable to open OpenSSH ECDSA private key file");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    _libssh2_error(0LL, 4294967282LL, "Session is required");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8A80: using guessed type __int64  _libssh2_openssh_pem_parse(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 9400: using guessed type __int64  _libssh2_ecdsa_curve_type_from_name(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000000D95F) ----------------------------------------------------
signed __int64  libssh2_ecdsa_new_private(_QWORD *a1, __int64 a2, char *a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-30h]
  char *v6; // [rsp+8h] [rbp-28h]

  v6 = a3;
  v5 = a4;
  _libssh2_init_if_needed(a1, a2);
  if ( (unsigned int)sub_A652(
                       a1,
                       (__int64 ( *)(__int64, _QWORD, _QWORD, __int64))&PEM_read_bio_ECPrivateKey,
                       (__int64)v6,
                       v5) )
    result = sub_D7B2(a1, a2, v6, v5);
  else
    result = 0LL;
  return result;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);

//----- (000000000000D9C7) ----------------------------------------------------
signed __int64  libssh2_ecdsa_create_key(__int64 a1, __int64 *a2, void **a3, unsigned __int64 *a4, unsigned int a5)
{
  signed __int64 result; // rax
  char *v6; // rsi
  unsigned int v7; // [rsp+Ch] [rbp-E4h]
  unsigned __int64 *v8; // [rsp+10h] [rbp-E0h]
  void **v9; // [rsp+18h] [rbp-D8h]
  __int64 *v10; // [rsp+20h] [rbp-D0h]
  signed int v11; // [rsp+34h] [rbp-BCh]
  unsigned __int64 n; // [rsp+38h] [rbp-B8h]
  __int64 v13; // [rsp+40h] [rbp-B0h]
  __int64 v14; // [rsp+48h] [rbp-A8h]
  __int64 v15; // [rsp+50h] [rbp-A0h]
  __int64 v16; // [rsp+58h] [rbp-98h]
  char src; // [rsp+60h] [rbp-90h]
  unsigned __int64 v18; // [rsp+E8h] [rbp-8h]

  v10 = a2;
  v9 = a3;
  v8 = a4;
  v7 = a5;
  v18 = __readfsqword(0x28u);
  v11 = 1;
  v16 = BN_CTX_new();
  if ( !v16 )
    return 0xFFFFFFFFLL;
  v14 = EC_KEY_new_by_curve_name(v7);
  v15 = EC_KEY_get0_group(v14);
  EC_KEY_generate_key(v14);
  v13 = EC_KEY_get0_public_key(v14);
  v6 = (char *)v13;
  n = EC_POINT_point2oct(v15, v13, 4LL, 0LL, 0LL, v16);
  if ( n <= 0x85 )
  {
    v6 = (char *)v13;
    if ( n == EC_POINT_point2oct(v15, v13, 4LL, &src, n, v16) )
    {
      if ( v10 )
        *v10 = v14;
      if ( v9 )
      {
        v6 = (char *)a1;
        *v9 = (void *)(*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(n, a1);
        if ( !*v9 )
        {
          v11 = -1;
          goto LABEL_15;
        }
        v6 = &src;
        memcpy(*v9, &src, n);
      }
      if ( v8 )
        *v8 = n;
      goto LABEL_15;
    }
    v11 = -1;
  }
  else
  {
    v11 = -1;
  }
LABEL_15:
  if ( v16 )
    BN_CTX_free(v16, v6);
  if ( v11 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8C20: using guessed type __int64  EC_KEY_get0_public_key(_QWORD);
// 8E00: using guessed type __int64  EC_KEY_get0_group(_QWORD);
// 8EF0: using guessed type __int64  EC_POINT_point2oct(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8F50: using guessed type __int64  EC_KEY_generate_key(_QWORD);
// 9160: using guessed type __int64  EC_KEY_new_by_curve_name(_QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);

//----- (000000000000DC40) ----------------------------------------------------
signed __int64  libssh2_ecdh_gen_k(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  size_t v5; // rsi
  unsigned int v6; // eax
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+10h] [rbp-40h]
  unsigned int v10; // [rsp+20h] [rbp-30h]
  void *ptr; // [rsp+28h] [rbp-28h]
  __int64 v12; // [rsp+30h] [rbp-20h]
  __int64 v13; // [rsp+38h] [rbp-18h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  size_t size; // [rsp+48h] [rbp-8h]

  v9 = a2;
  v8 = a3;
  v7 = a4;
  v10 = 0;
  ptr = 0LL;
  v12 = BN_CTX_new();
  if ( !v12 )
    return 0xFFFFFFFFLL;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v13 = EC_KEY_get0_group(a2);
  v14 = EC_POINT_new(v13);
  if ( !v14 )
    return 0xFFFFFFFFLL;
  v5 = v14;
  if ( (unsigned int)EC_POINT_oct2point(v13, v14, v8, v7, v12) == 1 )
  {
    size = (signed int)((unsigned __int64)EC_GROUP_get_degree(v13, v14) + 7) / 8;
    ptr = malloc(size);
    if ( ptr )
    {
      v5 = size;
      v6 = ECDH_compute_key(ptr, size, v14, v9, 0LL);
      if ( v6 && (unsigned __int64)(signed int)v6 <= 0x85 )
      {
        v5 = v6;
        BN_bin2bn(ptr, v6, *a1);
      }
      else
      {
        v10 = -1;
      }
    }
    else
    {
      v10 = -1;
    }
  }
  else
  {
    v10 = -1;
  }
  if ( v14 )
    EC_POINT_free(v14);
  if ( v12 )
    BN_CTX_free(v12, v5);
  if ( ptr )
    free(ptr);
  return v10;
}
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8D00: using guessed type __int64  EC_POINT_new(_QWORD);
// 8E00: using guessed type __int64  EC_KEY_get0_group(_QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);
// 93F0: using guessed type __int64  ECDH_compute_key(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9560: using guessed type __int64  EC_GROUP_get_degree(_QWORD, _QWORD);
// 95F0: using guessed type __int64  EC_POINT_oct2point(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9660: using guessed type __int64  EC_POINT_free(_QWORD);

//----- (000000000000DDCE) ----------------------------------------------------
signed __int64  libssh2_ed25519_sign(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-60h]
  __int64 v8; // [rsp+8h] [rbp-58h]
  _QWORD *v9; // [rsp+10h] [rbp-50h]
  _QWORD *v10; // [rsp+18h] [rbp-48h]
  signed int v11; // [rsp+3Ch] [rbp-24h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v15 = __readfsqword(0x28u);
  v11 = -1;
  v14 = EVP_MD_CTX_new();
  v12 = 0LL;
  v13 = 0LL;
  if ( !v14 )
    goto LABEL_7;
  if ( (unsigned int)EVP_DigestSignInit(v14, 0LL, 0LL, 0LL, a1) == 1
    && (unsigned int)EVP_DigestSign(v14, 0LL, &v12, v8, v7) == 1
    && v12 == 64 )
  {
    v13 = _libssh2_calloc(a2, 64LL);
    if ( v13 )
    {
      v11 = EVP_DigestSign(v14, v13, &v12, v8, v7);
LABEL_7:
      if ( v11 == 1 )
      {
        *v10 = v13;
        *v9 = v12;
      }
      else
      {
        *v9 = 0LL;
        *v10 = 0LL;
        (*(void ( **)(__int64, __int64))(a2 + 24))(v13, a2);
      }
      goto LABEL_10;
    }
  }
LABEL_10:
  if ( v14 )
    EVP_MD_CTX_free(v14);
  if ( v11 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8CB0: using guessed type __int64  EVP_DigestSignInit(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 92B0: using guessed type __int64  EVP_DigestSign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);

//----- (000000000000DF5D) ----------------------------------------------------
signed __int64  libssh2_curve25519_gen_k(_QWORD *a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  char *v4; // rsi
  __int64 v5; // [rsp+8h] [rbp-78h]
  __int64 v6; // [rsp+10h] [rbp-70h]
  signed int v7; // [rsp+24h] [rbp-5Ch]
  __int64 v8; // [rsp+28h] [rbp-58h]
  __int64 v9; // [rsp+30h] [rbp-50h]
  char *v10; // [rsp+38h] [rbp-48h]
  __int64 v11; // [rsp+40h] [rbp-40h]
  __int64 v12; // [rsp+48h] [rbp-38h]
  char v13; // [rsp+50h] [rbp-30h]
  unsigned __int64 v14; // [rsp+78h] [rbp-8h]

  v6 = a2;
  v5 = a3;
  v14 = __readfsqword(0x28u);
  v7 = -1;
  v10 = 0LL;
  v11 = 0LL;
  v9 = 0LL;
  v12 = 0LL;
  v8 = 0LL;
  if ( !a1 || !*a1 )
    return 0xFFFFFFFFLL;
  v12 = BN_CTX_new();
  if ( !v12 )
    return 0xFFFFFFFFLL;
  v10 = (char *)EVP_PKEY_new_raw_public_key(1034LL, 0LL, v5, 32LL);
  v4 = 0LL;
  v11 = EVP_PKEY_new_raw_private_key(1034LL, 0LL, v6, 32LL);
  if ( v10 )
  {
    if ( v11 )
    {
      v4 = 0LL;
      v9 = EVP_PKEY_CTX_new(v11, 0LL);
      if ( v9 )
      {
        v7 = EVP_PKEY_derive_init(v9);
        if ( v7 > 0 )
        {
          v4 = v10;
          v7 = EVP_PKEY_derive_set_peer(v9, v10);
          if ( v7 > 0 )
          {
            v4 = 0LL;
            v7 = EVP_PKEY_derive(v9, 0LL, &v8);
            if ( v7 > 0 )
            {
              if ( v8 == 32 )
              {
                v4 = &v13;
                v7 = EVP_PKEY_derive(v9, &v13, &v8);
                if ( v7 != 1 || v8 != 32 )
                {
                  v7 = -1;
                }
                else
                {
                  v4 = (char *)&qword_20;
                  BN_bin2bn(&v13, 32LL, *a1);
                }
              }
              else
              {
                v7 = -1;
              }
            }
          }
        }
      }
    }
  }
  if ( v9 )
    EVP_PKEY_CTX_free(v9, v4);
  if ( v10 )
    EVP_PKEY_free(v10, v4);
  if ( v11 )
    EVP_PKEY_free(v11, v4);
  if ( v12 )
    BN_CTX_free(v12, v4);
  if ( v7 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 20: using guessed type __int64;
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8BC0: using guessed type __int64  EVP_PKEY_CTX_new(_QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8E50: using guessed type __int64  EVP_PKEY_new_raw_public_key(_QWORD, _QWORD, _QWORD, _QWORD);
// 8FC0: using guessed type __int64  EVP_PKEY_derive(_QWORD, _QWORD, _QWORD);
// 90F0: using guessed type __int64  EVP_PKEY_derive_set_peer(_QWORD, _QWORD);
// 92E0: using guessed type __int64  EVP_PKEY_CTX_free(_QWORD, _QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);
// 9580: using guessed type __int64  EVP_PKEY_derive_init(_QWORD);
// 9620: using guessed type __int64  EVP_PKEY_new_raw_private_key(_QWORD, _QWORD, _QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (000000000000E192) ----------------------------------------------------
signed __int64  libssh2_ed25519_verify(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+10h] [rbp-30h]
  __int64 v8; // [rsp+18h] [rbp-28h]
  int v9; // [rsp+34h] [rbp-Ch]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = EVP_MD_CTX_new();
  if ( !v10 )
    return 0xFFFFFFFFLL;
  v9 = EVP_DigestVerifyInit(v10, 0LL, 0LL, 0LL, a1);
  if ( v9 == 1 )
    v9 = EVP_DigestVerify(v10, a2, v8, v7, v6);
  EVP_MD_CTX_free(v10);
  if ( v9 == 1 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 8FD0: using guessed type __int64  EVP_DigestVerifyInit(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91C0: using guessed type __int64 EVP_MD_CTX_new(void);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9A50: using guessed type __int64  EVP_DigestVerify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000E23C) ----------------------------------------------------
signed __int64  sub_E23C(signed __int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, char *a6, __int64 a7)
{
  signed __int64 result; // rax
  const char *filename; // [rsp+10h] [rbp-60h]
  size_t *v9; // [rsp+18h] [rbp-58h]
  _QWORD *v10; // [rsp+20h] [rbp-50h]
  _QWORD *v11; // [rsp+28h] [rbp-48h]
  unsigned int v12; // [rsp+48h] [rbp-28h]
  unsigned int v13; // [rsp+4Ch] [rbp-24h]
  char *s2; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  FILE *stream; // [rsp+60h] [rbp-10h]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  filename = a6;
  v17 = __readfsqword(0x28u);
  s2 = 0LL;
  v15 = 0LL;
  v13 = 0;
  if ( a1 )
  {
    _libssh2_init_if_needed(a1, a2);
    stream = fopen(filename, "r");
    if ( stream )
    {
      v13 = _libssh2_openssh_pem_parse(a1, a7, stream, &v15);
      fclose(stream);
      if ( v13 )
      {
        _libssh2_error(a1, 4294967280LL, "Not an OpenSSH key file");
        result = v13;
      }
      else if ( !(unsigned int)_libssh2_get_string(v15, &s2, 0LL) && s2 )
      {
        v13 = -1;
        if ( !strcmp("ssh-ed25519", s2) )
          v13 = sub_C0F3(a1, v15, a2, v11, v10, v9, 0LL);
        if ( !strcmp("ssh-rsa", s2) )
          v13 = sub_AC2D(a1, v15, a2, v11, v10, v9, 0LL);
        if ( !strcmp("ssh-dss", s2) )
          v13 = sub_B609(a1, v15, a2, v11, v10, v9, 0LL);
        if ( !(unsigned int)_libssh2_ecdsa_curve_type_from_name(s2, &v12) )
          v13 = sub_D517(a1, v12, v15, a2, v11, v10, v9, 0LL);
        if ( v15 )
          _libssh2_string_buf_free(a1, v15);
        if ( v13 )
          _libssh2_error(a1, 4294967280LL, "Unsupported OpenSSH key type");
        result = v13;
      }
      else
      {
        _libssh2_error(a1, 4294967282LL, "Public key type in decrypted key data not found");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      _libssh2_error(a1, 4294967280LL, "Unable to open private key file");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    _libssh2_error(0LL, 4294967282LL, "Session is required");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8A80: using guessed type __int64  _libssh2_openssh_pem_parse(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 9400: using guessed type __int64  _libssh2_ecdsa_curve_type_from_name(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000000E511) ----------------------------------------------------
__int64  libssh2_pub_priv_keyfile(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, char *a6, __int64 a7)
{
  __int64 result; // rax
  signed int v8; // eax
  char *v9; // [rsp+0h] [rbp-50h]
  size_t *v10; // [rsp+8h] [rbp-48h]
  _QWORD *v11; // [rsp+10h] [rbp-40h]
  _QWORD *v12; // [rsp+18h] [rbp-38h]
  unsigned int v13; // [rsp+34h] [rbp-1Ch]
  __int64 v14; // [rsp+40h] [rbp-10h]
  __int64 v15; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v14 = BIO_new_file(a6, "r");
  if ( !v14 )
    return _libssh2_error(
             a1,
             4294967280LL,
             "Unable to extract public key from private key file: Unable to open private key file");
  BIO_ctrl(v14, 1LL, 0LL, 0LL);
  v15 = PEM_read_bio_PrivateKey(v14, 0LL, 0LL, a7);
  BIO_free(v14);
  if ( v15 )
  {
    v8 = EVP_PKEY_id(v15, 0LL);
    if ( v8 == 116 )
    {
      v13 = sub_B4AE(a1, a2, v12, v11, v10, v15);
    }
    else if ( v8 > 116 )
    {
      if ( v8 == 408 )
      {
        v13 = sub_D1B9(a1, a2, v12, v11, v10, v15);
      }
      else
      {
        if ( v8 != 1087 )
        {
LABEL_17:
          a2 = (void **)4294967280LL;
          v13 = _libssh2_error(
                  a1,
                  4294967280LL,
                  "Unable to extract public key from private key file: Unsupported private key file format");
          goto LABEL_18;
        }
        v13 = sub_BEB8(a1, a2, v12, v11, v10, v15);
      }
    }
    else
    {
      if ( v8 != 6 )
        goto LABEL_17;
      v13 = sub_A8CA(a1, a2, v12, v11, v10, v15);
    }
LABEL_18:
    EVP_PKEY_free(v15, a2);
    return v13;
  }
  if ( (unsigned int)sub_E23C(a1, a2, v12, v11, v10, v9, a7) )
    result = _libssh2_error(
               a1,
               4294967280LL,
               "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format");
  else
    result = 0LL;
  return result;
}
// 8D10: using guessed type __int64  EVP_PKEY_id(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8E70: using guessed type __int64  BIO_new_file(_QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);
// 97E0: using guessed type __int64  BIO_ctrl(_QWORD, _QWORD, _QWORD, _QWORD);
// 9830: using guessed type __int64  BIO_free(_QWORD);
// 9AD8: using guessed type __int64  PEM_read_bio_PrivateKey(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000E731) ----------------------------------------------------
signed __int64  sub_E731(signed __int64 a1, _QWORD *a2, const char *a3, void **a4, _QWORD *a5, _QWORD *a6, size_t *a7, __int64 a8, __int64 a9, __int64 a10)
{
  signed __int64 result; // rax
  _QWORD *v11; // [rsp+20h] [rbp-50h]
  _QWORD *v12; // [rsp+28h] [rbp-48h]
  void **v13; // [rsp+30h] [rbp-40h]
  char *s; // [rsp+38h] [rbp-38h]
  signed __int64 v15; // [rsp+48h] [rbp-28h]
  unsigned int v16; // [rsp+50h] [rbp-20h]
  unsigned int v17; // [rsp+54h] [rbp-1Ch]
  char *s2; // [rsp+58h] [rbp-18h]
  __int64 v19; // [rsp+60h] [rbp-10h]
  unsigned __int64 v20; // [rsp+68h] [rbp-8h]

  v15 = a1;
  s = (char *)a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  v20 = __readfsqword(0x28u);
  s2 = 0LL;
  v19 = 0LL;
  if ( a2 )
    *a2 = 0LL;
  if ( a1 )
  {
    if ( a3 && (strlen(a3) > 0xB || (a1 = (signed __int64)s, strlen(s) <= 6)) )
    {
      _libssh2_error(v15, 4294967282LL, "type is invalid");
      result = 0xFFFFFFFFLL;
    }
    else
    {
      _libssh2_init_if_needed(a1, a2);
      v17 = _libssh2_openssh_pem_parse_memory(v15, a10, a8, a9, &v19);
      if ( v17 )
      {
        result = v17;
      }
      else if ( !(unsigned int)_libssh2_get_string(v19, &s2, 0LL) && s2 )
      {
        v17 = -1;
        if ( !strcmp("ssh-ed25519", s2) && (!s || !strcmp("ssh-ed25519", s)) )
          v17 = sub_C0F3(v15, v19, v13, v12, v11, a7, a2);
        if ( !strcmp("ssh-rsa", s2) && (!s || !strcmp("ssh-rsa", s)) )
          v17 = sub_AC2D(v15, v19, v13, v12, v11, a7, a2);
        if ( !strcmp("ssh-dss", s2) && (!s || !strcmp("ssh-dss", s)) )
          v17 = sub_B609(v15, v19, v13, v12, v11, a7, a2);
        if ( !(unsigned int)_libssh2_ecdsa_curve_type_from_name(s2, &v16) && (!s || !strcmp("ssh-ecdsa", s)) )
          v17 = sub_D517(v15, v16, v19, v13, v12, v11, a7, a2);
        if ( v19 )
          _libssh2_string_buf_free(v15, v19);
        result = v17;
      }
      else
      {
        _libssh2_error(v15, 4294967282LL, "Public key type in decrypted key data not found");
        result = 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    _libssh2_error(0LL, 4294967282LL, "Session is required");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);
// 91B0: using guessed type __int64  _libssh2_openssh_pem_parse_memory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9400: using guessed type __int64  _libssh2_ecdsa_curve_type_from_name(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000000EA6F) ----------------------------------------------------
signed __int64  read_openssh_private_key_from_memory(_QWORD *a1, signed __int64 a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_E731(a2, a1, a3, 0LL, 0LL, 0LL, 0LL, a4, a5, a6);
}

//----- (000000000000EAC5) ----------------------------------------------------
__int64  libssh2_pub_priv_keyfilememory(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, size_t *a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 result; // rax
  signed int v9; // eax
  __int64 v10; // [rsp+0h] [rbp-50h]
  size_t *v11; // [rsp+8h] [rbp-48h]
  _QWORD *v12; // [rsp+10h] [rbp-40h]
  _QWORD *v13; // [rsp+18h] [rbp-38h]
  unsigned int v14; // [rsp+38h] [rbp-18h]
  __int64 v15; // [rsp+40h] [rbp-10h]
  __int64 v16; // [rsp+48h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  v15 = BIO_new_mem_buf(a6, (unsigned int)a7);
  if ( !v15 )
    return 0xFFFFFFFFLL;
  BIO_ctrl(v15, 1LL, 0LL, 0LL);
  v16 = PEM_read_bio_PrivateKey(v15, 0LL, 0LL, a8);
  BIO_free(v15);
  if ( v16 )
  {
    v9 = EVP_PKEY_id(v16, 0LL);
    if ( v9 == 116 )
    {
      v14 = sub_B4AE(a1, a2, v13, v12, v11, v16);
    }
    else if ( v9 > 116 )
    {
      if ( v9 == 408 )
      {
        v14 = sub_D1B9(a1, a2, v13, v12, v11, v16);
      }
      else
      {
        if ( v9 != 1087 )
        {
LABEL_17:
          a2 = (void **)4294967280LL;
          v14 = _libssh2_error(
                  a1,
                  4294967280LL,
                  "Unable to extract public key from private key file: Unsupported private key file format");
          goto LABEL_18;
        }
        v14 = sub_BEB8(a1, a2, v13, v12, v11, v16);
      }
    }
    else
    {
      if ( v9 != 6 )
        goto LABEL_17;
      v14 = sub_A8CA(a1, a2, v13, v12, v11, v16);
    }
LABEL_18:
    EVP_PKEY_free(v16, a2);
    return v14;
  }
  if ( (unsigned int)sub_E731(a1, 0LL, 0LL, a2, v13, v12, v11, v10, a7, a8) )
    result = _libssh2_error(
               a1,
               4294967280LL,
               "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format");
  else
    result = 0LL;
  return result;
}
// 8D10: using guessed type __int64  EVP_PKEY_id(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91D0: using guessed type __int64  BIO_new_mem_buf(_QWORD, _QWORD);
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);
// 97E0: using guessed type __int64  BIO_ctrl(_QWORD, _QWORD, _QWORD, _QWORD);
// 9830: using guessed type __int64  BIO_free(_QWORD);
// 9AD8: using guessed type __int64  PEM_read_bio_PrivateKey(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000ECE0) ----------------------------------------------------
__int64 * libssh2_dh_init(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 *result; // rax

  v2 = BN_new(a1, a2);
  result = a1;
  *a1 = v2;
  return result;
}
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);

//----- (000000000000ECFE) ----------------------------------------------------
__int64  libssh2_dh_key_pair(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  __int64 v6; // ST18_8
  __int64 v7; // ST10_8
  __int64 v8; // ST00_8

  v6 = a3;
  v7 = a4;
  v8 = a6;
  BN_rand(*a1, (unsigned int)(8 * a5 - 1), 0LL, 0xFFFFFFFFLL);
  BN_mod_exp(a2, v6, *a1, v7, v8);
  return 0LL;
}
// 94D0: using guessed type __int64  BN_rand(_QWORD, _QWORD, _QWORD, _QWORD);
// 97C0: using guessed type __int64  BN_mod_exp(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000ED69) ----------------------------------------------------
__int64  libssh2_dh_secret(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  BN_mod_exp(a2, a3, *a1, a4, a5);
  return 0LL;
}
// 97C0: using guessed type __int64  BN_mod_exp(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000EDAE) ----------------------------------------------------
_QWORD * libssh2_dh_dtor(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  BN_clear_free(*a1, a2);
  result = a1;
  *a1 = 0LL;
  return result;
}
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);

//----- (000000000000EDD7) ----------------------------------------------------
__int64  sub_EDD7(_QWORD *a1)
{
  const char *src; // [rsp+18h] [rbp-88h]
  struct sockaddr addr; // [rsp+20h] [rbp-80h]
  char v4; // [rsp+8Dh] [rbp-13h]
  unsigned __int64 v5; // [rsp+98h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  src = (const char *)a1[11];
  if ( !src )
  {
    src = getenv("SSH_AUTH_SOCK");
    if ( !src )
      return _libssh2_error(*a1, 4294967257LL, "no auth sock variable");
  }
  *((_DWORD *)a1 + 2) = socket(1, 1, 0);
  if ( *((_DWORD *)a1 + 2) < 0 )
    return _libssh2_error(*a1, 4294967251LL, "failed creating socket");
  addr.sa_family = 1;
  strncpy(addr.sa_data, src, 0x6CuLL);
  v4 = 0;
  if ( !connect(*((_DWORD *)a1 + 2), &addr, 0x6Eu) )
    return 0LL;
  close(*((_DWORD *)a1 + 2));
  return _libssh2_error(*a1, 4294967254LL, "failed connecting with agent");
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (000000000000EF3B) ----------------------------------------------------
__int64  sub_EF3B(unsigned int *a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // [rsp+10h] [rbp-10h]
  int v4; // [rsp+10h] [rbp-10h]
  int v5; // [rsp+10h] [rbp-10h]
  int v6; // [rsp+10h] [rbp-10h]
  char v7; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v8; // [rsp+18h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    _libssh2_htonu32(&v7, (unsigned int)*(_QWORD *)(a2 + 8));
    v3 = (*(__int64 ( **)(_QWORD, char *, signed __int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 72LL))(
           a1[2],
           &v7,
           4LL,
           0LL,
           *(_QWORD *)a1);
    if ( v3 == -11 )
      return 4294967259LL;
    if ( v3 < 0 )
      return _libssh2_error(*(_QWORD *)a1, 4294967289LL, "agent send failed");
    *(_DWORD *)(a2 + 32) = 2;
  }
  if ( *(_DWORD *)(a2 + 32) == 2 )
  {
    v4 = (*(__int64 ( **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 72LL))(
           a1[2],
           *(_QWORD *)a2,
           *(_QWORD *)(a2 + 8),
           0LL,
           *(_QWORD *)a1);
    if ( v4 == -11 )
      return 4294967259LL;
    if ( v4 < 0 )
      return _libssh2_error(*(_QWORD *)a1, 4294967289LL, "agent send failed");
    *(_DWORD *)(a2 + 32) = 3;
  }
  if ( *(_DWORD *)(a2 + 32) == 3 )
  {
    v5 = (*(__int64 ( **)(_QWORD, char *, signed __int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 80LL))(
           a1[2],
           &v7,
           4LL,
           0LL,
           *(_QWORD *)a1);
    if ( v5 < 0 )
    {
      if ( v5 == -11 )
        result = 4294967259LL;
      else
        result = _libssh2_error(*(_QWORD *)a1, 4294967253LL, "agent recv failed");
      return result;
    }
    *(_QWORD *)(a2 + 24) = (unsigned int)_libssh2_ntohu32(&v7);
    *(_QWORD *)(a2 + 16) = (*(__int64 ( **)(_QWORD, _QWORD))(*(_QWORD *)a1 + 8LL))(
                             *(_QWORD *)(a2 + 24),
                             *(_QWORD *)a1);
    if ( !*(_QWORD *)(a2 + 16) )
      return 4294967290LL;
    *(_DWORD *)(a2 + 32) = 4;
  }
  if ( *(_DWORD *)(a2 + 32) != 4 )
    return 0LL;
  v6 = (*(__int64 ( **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 80LL))(
         a1[2],
         *(_QWORD *)(a2 + 16),
         *(_QWORD *)(a2 + 24),
         0LL,
         *(_QWORD *)a1);
  if ( v6 >= 0 )
  {
    *(_DWORD *)(a2 + 32) = 5;
    return 0LL;
  }
  if ( v6 == -11 )
    result = 4294967259LL;
  else
    result = _libssh2_error(*(_QWORD *)a1, 4294967289LL, "agent recv failed");
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (000000000000F1EF) ----------------------------------------------------
__int64  sub_F1EF(__int64 a1)
{
  if ( close(*(_DWORD *)(a1 + 8)) == -1 )
    return _libssh2_error(*(_QWORD *)a1, 4294967283LL, "failed closing the agent socket");
  *(_DWORD *)(a1 + 8) = -1;
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (000000000000F241) ----------------------------------------------------
__int64  sub_F241(__int64 a1, void **a2, size_t *a3, __int64 a4, __int64 a5, __int64 *a6)
{
  _BYTE *v7; // rax
  __int64 v8; // [rsp+8h] [rbp-68h]
  __int64 v9; // [rsp+10h] [rbp-60h]
  size_t *v10; // [rsp+18h] [rbp-58h]
  unsigned int v11; // [rsp+34h] [rbp-3Ch]
  void *src; // [rsp+38h] [rbp-38h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  void **v14; // [rsp+48h] [rbp-28h]
  __int64 v15; // [rsp+50h] [rbp-20h]
  char *v16; // [rsp+58h] [rbp-18h]
  __int64 v17; // [rsp+60h] [rbp-10h]
  unsigned __int64 v18; // [rsp+68h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v18 = __readfsqword(0x28u);
  v13 = *a6;
  v14 = (void **)(v13 + 24);
  v15 = *(_QWORD *)(v13 + 64);
  v16 = (char *)(*(_QWORD *)(v15 + 48) + a5 + 13);
  if ( !*(_DWORD *)(v13 + 56) )
  {
    *v14 = (void *)(*(__int64 ( **)(char *, __int64))(a1 + 8))(v16, a1);
    src = *v14;
    if ( !*v14 )
      return _libssh2_error(a1, 4294967290LL, "out of memory");
    v7 = src;
    src = (char *)src + 1;
    *v7 = 13;
    _libssh2_store_str(&src, *(_QWORD *)(v15 + 40), *(_QWORD *)(v15 + 48));
    _libssh2_store_str(&src, v9, v8);
    _libssh2_store_u32(&src, 0LL);
    v14[1] = (void *)((_BYTE *)src - (_BYTE *)*v14);
    *((_DWORD *)v14 + 8) = 1;
  }
  if ( *(_BYTE *)*v14 != 13 )
    return _libssh2_error(a1, 4294967257LL, "illegal request");
  if ( !*(_QWORD *)(v13 + 16) )
    return _libssh2_error(a1, 4294967257LL, "agent not connected");
  v11 = (*(__int64 ( **)(__int64, void **))(*(_QWORD *)(v13 + 16) + 8LL))(v13, v14);
  if ( !v11 )
  {
    (*(void ( **)(void *, __int64))(a1 + 24))(*v14, a1);
    *v14 = 0LL;
    v16 = (char *)v14[3];
    src = v14[2];
    if ( (signed __int64)--v16 >= 0 )
    {
      if ( *(_BYTE *)src == 14 )
      {
        src = (char *)src + 1;
        v16 -= 4;
        if ( (signed __int64)v16 >= 0 )
        {
          src = (char *)src + 4;
          v16 -= 4;
          if ( (signed __int64)v16 >= 0 )
          {
            v17 = (unsigned int)_libssh2_ntohu32(src);
            src = (char *)src + 4;
            v16 -= v17;
            if ( (signed __int64)v16 >= 0 )
            {
              src = (char *)src + v17;
              v16 -= 4;
              if ( (signed __int64)v16 >= 0 )
              {
                *v10 = (unsigned int)_libssh2_ntohu32(src);
                src = (char *)src + 4;
                v16 -= *v10;
                if ( (signed __int64)v16 >= 0 )
                {
                  *a2 = (void *)(*(__int64 ( **)(size_t, __int64))(a1 + 8))(*v10, a1);
                  if ( *a2 )
                    memcpy(*a2, src, *v10);
                  else
                    v11 = -6;
                }
                else
                {
                  v11 = -42;
                }
              }
              else
              {
                v11 = -42;
              }
            }
            else
            {
              v11 = -42;
            }
          }
          else
          {
            v11 = -42;
          }
        }
        else
        {
          v11 = -42;
        }
      }
      else
      {
        v11 = -42;
      }
    }
    else
    {
      v11 = -42;
    }
  }
  (*(void ( **)(void *, __int64))(a1 + 24))(*v14, a1);
  *v14 = 0LL;
  (*(void ( **)(void *, __int64))(a1 + 24))(v14[2], a1);
  v14[2] = 0LL;
  return _libssh2_error(a1, v11, "agent sign failure");
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000000F63E) ----------------------------------------------------
__int64  sub_F63E(_QWORD *a1)
{
  __int64 result; // rax
  unsigned int v2; // eax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  char v6; // [rsp+13h] [rbp-3Dh]
  unsigned int v7; // [rsp+14h] [rbp-3Ch]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+20h] [rbp-30h]
  void *src; // [rsp+28h] [rbp-28h]
  _QWORD *v11; // [rsp+30h] [rbp-20h]
  __int64 v12; // [rsp+38h] [rbp-18h]
  size_t n; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  v11 = a1 + 3;
  v6 = 11;
  if ( !*((_DWORD *)a1 + 14) )
  {
    *v11 = &v6;
    v11[1] = 1LL;
    *((_DWORD *)v11 + 8) = 1;
  }
  if ( *(_BYTE *)*v11 != 11 )
    return _libssh2_error(*a1, 4294967257LL, "illegal agent request");
  if ( !a1[2] )
    return _libssh2_error(*a1, 4294967257LL, "agent not connected");
  v7 = (*(__int64 ( **)(_QWORD *, _QWORD *))(a1[2] + 8LL))(a1, v11);
  if ( v7 )
  {
    (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(v11[2], *a1);
    v11[2] = 0LL;
    result = v7;
  }
  else
  {
    *v11 = 0LL;
    v8 = v11[3];
    src = (void *)v11[2];
    if ( --v8 >= 0 )
    {
      if ( *(_BYTE *)src == 12 )
      {
        src = (char *)src + 1;
        v8 -= 4LL;
        if ( v8 >= 0 )
        {
          v9 = (unsigned int)_libssh2_ntohu32(src);
          src = (char *)src + 4;
          while ( 1 )
          {
            v5 = v9--;
            if ( !v5 )
              break;
            v8 -= 4LL;
            if ( v8 < 0 )
            {
              v7 = -42;
              break;
            }
            v12 = (*(__int64 ( **)(signed __int64, _QWORD))(*a1 + 8LL))(64LL, *a1);
            if ( !v12 )
            {
              v7 = -6;
              break;
            }
            v2 = _libssh2_ntohu32(src);
            *(_QWORD *)(v12 + 48) = v2;
            src = (char *)src + 4;
            v8 -= *(_QWORD *)(v12 + 48);
            if ( v8 < 0 )
            {
              v7 = -42;
              (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v12, *a1);
              break;
            }
            v3 = (*(__int64 ( **)(_QWORD, _QWORD))(*a1 + 8LL))(*(_QWORD *)(v12 + 48), *a1);
            *(_QWORD *)(v12 + 40) = v3;
            if ( !*(_QWORD *)(v12 + 40) )
            {
              v7 = -6;
              (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v12, *a1);
              break;
            }
            memcpy(*(void **)(v12 + 40), src, *(_QWORD *)(v12 + 48));
            src = (char *)src + *(_QWORD *)(v12 + 48);
            v8 -= 4LL;
            if ( v8 < 0 )
            {
              v7 = -42;
              (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(v12 + 40), *a1);
              (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v12, *a1);
              break;
            }
            n = (unsigned int)_libssh2_ntohu32(src);
            src = (char *)src + 4;
            v8 -= n;
            if ( v8 < 0 )
            {
              v7 = -42;
              (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(v12 + 40), *a1);
              (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v12, *a1);
              break;
            }
            v4 = (*(__int64 ( **)(size_t, _QWORD))(*a1 + 8LL))(n + 1, *a1);
            *(_QWORD *)(v12 + 56) = v4;
            if ( !*(_QWORD *)(v12 + 56) )
            {
              v7 = -6;
              (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(v12 + 40), *a1);
              (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v12, *a1);
              break;
            }
            *(_BYTE *)(*(_QWORD *)(v12 + 56) + n) = 0;
            memcpy(*(void **)(v12 + 56), src, n);
            src = (char *)src + n;
            _libssh2_list_add(a1 + 9, v12);
          }
        }
        else
        {
          v7 = -42;
        }
      }
      else
      {
        v7 = -42;
      }
    }
    else
    {
      v7 = -42;
    }
    (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(v11[2], *a1);
    v11[2] = 0LL;
    result = _libssh2_error(*a1, v7, "agent list id failed");
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (000000000000FB45) ----------------------------------------------------
__int64  sub_FB45(_QWORD *a1)
{
  __int64 v1; // ST18_8
  __int64 i; // [rsp+10h] [rbp-10h]

  for ( i = _libssh2_list_first(a1 + 9); i; i = v1 )
  {
    v1 = _libssh2_list_next(i);
    (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(i + 40), *a1);
    (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(*(_QWORD *)(i + 56), *a1);
    (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(i, *a1);
  }
  return _libssh2_list_init(a1 + 9);
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8B20: using guessed type __int64  _libssh2_list_init(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (000000000000FC0B) ----------------------------------------------------
signed __int64  sub_FC0B(__int64 a1)
{
  *(_DWORD *)(a1 + 24) = 1004469970;
  *(_QWORD *)(a1 + 32) = a1;
  return a1 + 24;
}

//----- (000000000000FC3B) ----------------------------------------------------
__int64  libssh2_agent_init(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = _libssh2_calloc(a1, 96LL);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 8) = -1;
    *(_QWORD *)v2 = a1;
    *(_QWORD *)(v2 + 88) = 0LL;
    _libssh2_list_init(v2 + 72);
    result = v2;
  }
  else
  {
    _libssh2_error(a1, 4294967290LL, "Unable to allocate space for agent connection");
    result = 0LL;
  }
  return result;
}
// 8B20: using guessed type __int64  _libssh2_list_init(_QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (000000000000FCBA) ----------------------------------------------------
__int64  libssh2_agent_connect(__int64 a1)
{
  int i; // [rsp+18h] [rbp-8h]
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v3 = -1;
  for ( i = 0; (&off_250940)[2 * i]; ++i )
  {
    *(_QWORD *)(a1 + 16) = *(&off_250948 + 2 * i);
    v3 = (**(__int64 ( ***)(__int64))(a1 + 16))(a1);
    if ( !v3 )
      return 0LL;
  }
  return v3;
}
// 250940: using guessed type char *off_250940;
// 250948: using guessed type __int64 ( *(*off_250948)[3])();

//----- (000000000000FD3E) ----------------------------------------------------
__int64  libssh2_agent_list_identities(_QWORD *a1)
{
  memset(a1 + 3, 0, 0x28uLL);
  sub_FB45(a1);
  return sub_F63E(a1);
}

//----- (000000000000FD7E) ----------------------------------------------------
signed __int64  libssh2_agent_get_identity(__int64 a1, signed __int64 *a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-10h]

  if ( a3 && *(_QWORD *)(a3 + 8) )
    v4 = _libssh2_list_next(*(_QWORD *)(a3 + 8));
  else
    v4 = _libssh2_list_first(a1 + 72);
  if ( !v4 )
    return 1LL;
  *a2 = sub_FC0B(v4);
  return 0LL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (000000000000FE03) ----------------------------------------------------
__int64  libssh2_agent_userauth(_QWORD *a1, const char *a2, _QWORD *a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  unsigned int v5; // eax
  _QWORD *v7; // [rsp+8h] [rbp-48h]
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  _QWORD *v9; // [rsp+28h] [rbp-28h]
  time_t v10; // [rsp+30h] [rbp-20h]
  unsigned __int64 v11; // [rsp+38h] [rbp-18h]

  v7 = a3;
  v11 = __readfsqword(0x28u);
  v9 = a1;
  if ( !*(_DWORD *)(*a1 + 53552LL) )
  {
    memset(a1 + 3, 0, 0x28uLL);
    a1[8] = v7[1];
  }
  v10 = time(0LL);
  do
  {
    v3 = v7[3];
    v4 = v7[2];
    v5 = strlen(a2);
    v8 = _libssh2_userauth_publickey(*a1, a2, v5, v4, v3, sub_F241, &v9);
    if ( v8 != -37 )
      break;
    if ( !*(_DWORD *)(*a1 + 148LL) )
      break;
    v8 = _libssh2_wait_socket(*a1, v10);
  }
  while ( !v8 );
  return v8;
}
// 9180: using guessed type __int64  _libssh2_userauth_publickey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000000FF24) ----------------------------------------------------
__int64  libssh2_agent_disconnect(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 16) && *(_DWORD *)(a1 + 8) != -1 )
    result = (*(__int64 ( **)(__int64))(*(_QWORD *)(a1 + 16) + 16LL))(a1);
  else
    result = 0LL;
  return result;
}

//----- (000000000000FF67) ----------------------------------------------------
__int64  libssh2_agent_free(_QWORD *a1)
{
  if ( *((_DWORD *)a1 + 2) != -1 )
    libssh2_agent_disconnect(a1);
  if ( a1[11] )
    (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(a1[11], *a1);
  sub_FB45(a1);
  return (*(__int64 ( **)(_QWORD *, _QWORD))(*a1 + 24LL))(a1, *a1);
}
// 8B80: using guessed type __int64  libssh2_agent_disconnect(_QWORD);

//----- (000000000000FFED) ----------------------------------------------------
size_t  libssh2_agent_set_identity_path(_QWORD *a1, const char *a2)
{
  size_t result; // rax
  void *dest; // ST18_8
  size_t n; // [rsp+10h] [rbp-10h]

  result = a1[11];
  if ( result )
  {
    (*(void ( **)(_QWORD, _QWORD))(*a1 + 24LL))(a1[11], *a1);
    result = (size_t)a1;
    a1[11] = 0LL;
  }
  if ( a2 )
  {
    result = strlen(a2);
    n = result;
    if ( result <= 0xFFFFFFFFFFFFFFFDLL )
    {
      dest = (void *)(*(__int64 ( **)(size_t, _QWORD))(*a1 + 8LL))(result + 1, *a1);
      memcpy(dest, a2, n);
      *((_BYTE *)dest + n) = 0;
      result = (size_t)a1;
      a1[11] = dest;
    }
  }
  return result;
}

//----- (00000000000100B6) ----------------------------------------------------
__int64  libssh2_agent_get_identity_path(__int64 a1)
{
  return *(_QWORD *)(a1 + 88);
}

//----- (00000000000100C8) ----------------------------------------------------
unsigned __int64  sub_100C8(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  __int64 v5; // [rsp+8h] [rbp-10C8h]
  __int16 v6; // [rsp+22h] [rbp-10AEh]
  int i; // [rsp+24h] [rbp-10ACh]
  __int64 v8; // [rsp+28h] [rbp-10A8h]
  int v9[8]; // [rsp+30h] [rbp-10A0h]
  char v10; // [rsp+50h] [rbp-1080h]
  __int64 v11; // [rsp+10A0h] [rbp-30h]
  __int64 v12; // [rsp+10A8h] [rbp-28h]
  __int64 v13; // [rsp+10B0h] [rbp-20h]
  __int64 v14; // [rsp+10B8h] [rbp-18h]
  unsigned __int64 v15; // [rsp+10C8h] [rbp-8h]

  v5 = a3;
  v15 = __readfsqword(0x28u);
  v11 = 7885647265220098127LL;
  v12 = 8606216445319804001LL;
  v13 = 8386115181258959206LL;
  v14 = 7310584013636139332LL;
  v8 = 64LL;
  Blowfish_initstate(&v10);
  Blowfish_expandstate(&v10, a2, 64LL, a1, 64LL);
  for ( i = 0; i <= 63; ++i )
  {
    Blowfish_expand0state(&v10, a2, (unsigned __int16)v8);
    Blowfish_expand0state(&v10, a1, (unsigned __int16)v8);
  }
  v6 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    v3 = Blowfish_stream2word(&v11, 32LL, &v6);
    v9[i] = v3;
  }
  for ( i = 0; i <= 63; ++i )
    blf_enc(&v10, v9, 4LL);
  for ( i = 0; i <= 7; ++i )
  {
    *(_BYTE *)(4 * i + 3LL + v5) = (unsigned int)v9[i] >> 24;
    *(_BYTE *)(4 * i + 2LL + v5) = (unsigned int)v9[i] >> 16;
    *(_WORD *)(4 * i + v5) = __PAIR__(LOWORD(v9[i]) >> 8, (unsigned __int8)v9[i]);
  }
  _libssh2_explicit_zero(&v11, 32LL);
  _libssh2_explicit_zero(v9, 32LL);
  _libssh2_explicit_zero(&v10, 4168LL);
  return __readfsqword(0x28u) ^ v15;
}
// 8A30: using guessed type __int64  blf_enc(_QWORD, _QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8B50: using guessed type __int64  Blowfish_expand0state(_QWORD, _QWORD, _QWORD);
// 8C70: using guessed type __int64  Blowfish_stream2word(_QWORD, _QWORD, _QWORD);
// 9150: using guessed type __int64  Blowfish_initstate(_QWORD);
// 97D0: using guessed type __int64  Blowfish_expandstate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 100C8: using guessed type int var_10A0[8];

//----- (000000000001038E) ----------------------------------------------------
signed __int64  bcrypt_pbkdf(__int64 a1, __int64 a2, void *a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6, unsigned int a7)
{
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // [rsp+0h] [rbp-150h]
  __int64 v10; // [rsp+8h] [rbp-148h]
  size_t n; // [rsp+10h] [rbp-140h]
  void *src; // [rsp+18h] [rbp-138h]
  signed int v13; // [rsp+3Ch] [rbp-114h]
  __int64 v14; // [rsp+40h] [rbp-110h]
  unsigned __int64 i; // [rsp+48h] [rbp-108h]
  unsigned __int64 j; // [rsp+50h] [rbp-100h]
  unsigned __int64 v17; // [rsp+58h] [rbp-F8h]
  unsigned __int64 v18; // [rsp+60h] [rbp-F0h]
  void *dest; // [rsp+68h] [rbp-E8h]
  unsigned __int64 v20; // [rsp+70h] [rbp-E0h]
  unsigned __int64 v21; // [rsp+78h] [rbp-D8h]
  __int64 v22; // [rsp+80h] [rbp-D0h]
  __int64 v23; // [rsp+88h] [rbp-C8h]
  __int64 v24; // [rsp+90h] [rbp-C0h]
  __int64 v25; // [rsp+98h] [rbp-B8h]
  __int64 v26; // [rsp+A0h] [rbp-B0h]
  __int64 v27; // [rsp+A8h] [rbp-A8h]
  __int64 v28; // [rsp+B0h] [rbp-A0h]
  __int64 v29; // [rsp+B8h] [rbp-98h]
  char v30; // [rsp+C0h] [rbp-90h]
  char v31; // [rsp+100h] [rbp-50h]
  unsigned __int64 v32; // [rsp+148h] [rbp-8h]

  src = a3;
  n = a4;
  v10 = a5;
  v9 = a6;
  v32 = __readfsqword(0x28u);
  v18 = a6;
  if ( !a7 )
    return 0xFFFFFFFFLL;
  if ( !a2 || !a4 || !a6 || a6 > 0x400 || a4 > 0x100000 )
    return 0xFFFFFFFFLL;
  dest = calloc(1uLL, a4 + 4);
  if ( !dest )
    return 0xFFFFFFFFLL;
  v20 = (v9 + 31) >> 5;
  v17 = (v9 + v20 - 1) / v20;
  memcpy(dest, src, n);
  _libssh2_sha512_init(&v14);
  EVP_DigestUpdate(v14, a1, a2);
  EVP_DigestFinal(v14, &v30, 0LL);
  EVP_MD_CTX_free(v14);
  v13 = 1;
  while ( v9 )
  {
    *((_BYTE *)dest + n) = HIBYTE(v13);
    *((_BYTE *)dest + n + 1) = BYTE2(v13);
    *((_BYTE *)dest + n + 2) = BYTE1(v13);
    *((_BYTE *)dest + n + 3) = v13;
    _libssh2_sha512_init(&v14);
    EVP_DigestUpdate(v14, dest, n + 4);
    EVP_DigestFinal(v14, &v31, 0LL);
    EVP_MD_CTX_free(v14);
    sub_100C8((__int64)&v30, (__int64)&v31, (__int64)&v26);
    v22 = v26;
    v23 = v27;
    v24 = v28;
    v25 = v29;
    for ( i = 1LL; i < a7; ++i )
    {
      _libssh2_sha512_init(&v14);
      EVP_DigestUpdate(v14, &v26, 32LL);
      EVP_DigestFinal(v14, &v31, 0LL);
      EVP_MD_CTX_free(v14);
      sub_100C8((__int64)&v30, (__int64)&v31, (__int64)&v26);
      for ( j = 0LL; j <= 0x1F; ++j )
        *((_BYTE *)&v22 + j) ^= *((_BYTE *)&v26 + j);
    }
    v8 = v17;
    if ( v9 <= v17 )
      v8 = v9;
    v17 = v8;
    for ( i = 0LL; i < v17; ++i )
    {
      v21 = (unsigned int)(v13 - 1) + v20 * i;
      if ( v21 >= v18 )
        break;
      *(_BYTE *)(v21 + v10) = *((_BYTE *)&v22 + i);
    }
    v9 -= i;
    ++v13;
  }
  _libssh2_explicit_zero(&v22, 32LL);
  free(dest);
  return 0LL;
}
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 91E0: using guessed type __int64  _libssh2_sha512_init(_QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);

//----- (000000000001085A) ----------------------------------------------------
int * Blowfish_encipher(_DWORD *a1, int *a2, int *a3)
{
  _DWORD *v3; // ST28_8
  int v4; // ST20_4
  int v5; // ST24_4
  int v6; // ST20_4
  int v7; // ST24_4
  int v8; // ST20_4
  int v9; // ST24_4
  int v10; // ST20_4
  int v11; // ST24_4
  int v12; // ST20_4
  int v13; // ST24_4
  int v14; // ST20_4
  int v15; // ST24_4
  int v16; // ST20_4
  int v17; // ST24_4
  int v18; // ST20_4
  int v19; // ST24_4
  int v20; // ST20_4
  int *result; // rax

  v3 = a1;
  v4 = a1[1024] ^ *a2;
  v5 = (a1[(unsigned __int8)(*((_BYTE *)a1 + 4096) ^ *(_BYTE *)a2) + 768]
      + (a1[BYTE1(v4) + 512] ^ (a1[BYTE2(v4) + 256] + a1[HIBYTE(v4)]))) ^ a1[1025] ^ *a3;
  v6 = (v3[(unsigned __int8)v5 + 768] + (v3[BYTE1(v5) + 512] ^ (v3[BYTE2(v5) + 256] + v3[HIBYTE(v5)]))) ^ a1[1026] ^ v4;
  v7 = (v3[(unsigned __int8)v6 + 768] + (v3[BYTE1(v6) + 512] ^ (v3[BYTE2(v6) + 256] + v3[HIBYTE(v6)]))) ^ a1[1027] ^ v5;
  v8 = (v3[(unsigned __int8)v7 + 768] + (v3[BYTE1(v7) + 512] ^ (v3[BYTE2(v7) + 256] + v3[HIBYTE(v7)]))) ^ a1[1028] ^ v6;
  v9 = (v3[(unsigned __int8)v8 + 768] + (v3[BYTE1(v8) + 512] ^ (v3[BYTE2(v8) + 256] + v3[HIBYTE(v8)]))) ^ a1[1029] ^ v7;
  v10 = (v3[(unsigned __int8)v9 + 768] + (v3[BYTE1(v9) + 512] ^ (v3[BYTE2(v9) + 256] + v3[HIBYTE(v9)]))) ^ a1[1030] ^ v8;
  v11 = (v3[(unsigned __int8)v10 + 768] + (v3[BYTE1(v10) + 512] ^ (v3[BYTE2(v10) + 256] + v3[HIBYTE(v10)]))) ^ a1[1031] ^ v9;
  v12 = (v3[(unsigned __int8)v11 + 768] + (v3[BYTE1(v11) + 512] ^ (v3[BYTE2(v11) + 256] + v3[HIBYTE(v11)]))) ^ a1[1032] ^ v10;
  v13 = (v3[(unsigned __int8)v12 + 768] + (v3[BYTE1(v12) + 512] ^ (v3[BYTE2(v12) + 256] + v3[HIBYTE(v12)]))) ^ a1[1033] ^ v11;
  v14 = (v3[(unsigned __int8)v13 + 768] + (v3[BYTE1(v13) + 512] ^ (v3[BYTE2(v13) + 256] + v3[HIBYTE(v13)]))) ^ a1[1034] ^ v12;
  v15 = (v3[(unsigned __int8)v14 + 768] + (v3[BYTE1(v14) + 512] ^ (v3[BYTE2(v14) + 256] + v3[HIBYTE(v14)]))) ^ a1[1035] ^ v13;
  v16 = (v3[(unsigned __int8)v15 + 768] + (v3[BYTE1(v15) + 512] ^ (v3[BYTE2(v15) + 256] + v3[HIBYTE(v15)]))) ^ a1[1036] ^ v14;
  v17 = (v3[(unsigned __int8)v16 + 768] + (v3[BYTE1(v16) + 512] ^ (v3[BYTE2(v16) + 256] + v3[HIBYTE(v16)]))) ^ a1[1037] ^ v15;
  v18 = (v3[(unsigned __int8)v17 + 768] + (v3[BYTE1(v17) + 512] ^ (v3[BYTE2(v17) + 256] + v3[HIBYTE(v17)]))) ^ a1[1038] ^ v16;
  v19 = (v3[(unsigned __int8)v18 + 768] + (v3[BYTE1(v18) + 512] ^ (v3[BYTE2(v18) + 256] + v3[HIBYTE(v18)]))) ^ a1[1039] ^ v17;
  v20 = (v3[(unsigned __int8)v19 + 768] + (v3[BYTE1(v19) + 512] ^ (v3[BYTE2(v19) + 256] + v3[HIBYTE(v19)]))) ^ a1[1040] ^ v18;
  *a2 = v19 ^ a1[1041];
  result = a3;
  *a3 = v20;
  return result;
}

//----- (00000000000111CC) ----------------------------------------------------
int * Blowfish_decipher(_DWORD *a1, int *a2, int *a3)
{
  int v3; // ST20_4
  int v4; // ST24_4
  int v5; // ST20_4
  int v6; // ST24_4
  int v7; // ST20_4
  int v8; // ST24_4
  int v9; // ST20_4
  int v10; // ST24_4
  int v11; // ST20_4
  int v12; // ST24_4
  int v13; // ST20_4
  int v14; // ST24_4
  int v15; // ST20_4
  int v16; // ST24_4
  int v17; // ST20_4
  int v18; // ST24_4
  int v19; // ST20_4
  int *result; // rax

  v3 = a1[1041] ^ *a2;
  v4 = (a1[(unsigned __int8)v3 + 768] + (a1[BYTE1(v3) + 512] ^ (a1[BYTE2(v3) + 256] + a1[HIBYTE(v3)]))) ^ a1[1040] ^ *a3;
  v5 = (a1[(unsigned __int8)v4 + 768] + (a1[BYTE1(v4) + 512] ^ (a1[BYTE2(v4) + 256] + a1[HIBYTE(v4)]))) ^ a1[1039] ^ v3;
  v6 = (a1[(unsigned __int8)v5 + 768] + (a1[BYTE1(v5) + 512] ^ (a1[BYTE2(v5) + 256] + a1[HIBYTE(v5)]))) ^ a1[1038] ^ v4;
  v7 = (a1[(unsigned __int8)v6 + 768] + (a1[BYTE1(v6) + 512] ^ (a1[BYTE2(v6) + 256] + a1[HIBYTE(v6)]))) ^ a1[1037] ^ v5;
  v8 = (a1[(unsigned __int8)v7 + 768] + (a1[BYTE1(v7) + 512] ^ (a1[BYTE2(v7) + 256] + a1[HIBYTE(v7)]))) ^ a1[1036] ^ v6;
  v9 = (a1[(unsigned __int8)v8 + 768] + (a1[BYTE1(v8) + 512] ^ (a1[BYTE2(v8) + 256] + a1[HIBYTE(v8)]))) ^ a1[1035] ^ v7;
  v10 = (a1[(unsigned __int8)v9 + 768] + (a1[BYTE1(v9) + 512] ^ (a1[BYTE2(v9) + 256] + a1[HIBYTE(v9)]))) ^ a1[1034] ^ v8;
  v11 = (a1[(unsigned __int8)v10 + 768] + (a1[BYTE1(v10) + 512] ^ (a1[BYTE2(v10) + 256] + a1[HIBYTE(v10)]))) ^ a1[1033] ^ v9;
  v12 = (a1[(unsigned __int8)v11 + 768] + (a1[BYTE1(v11) + 512] ^ (a1[BYTE2(v11) + 256] + a1[HIBYTE(v11)]))) ^ a1[1032] ^ v10;
  v13 = (a1[(unsigned __int8)v12 + 768] + (a1[BYTE1(v12) + 512] ^ (a1[BYTE2(v12) + 256] + a1[HIBYTE(v12)]))) ^ a1[1031] ^ v11;
  v14 = (a1[(unsigned __int8)v13 + 768] + (a1[BYTE1(v13) + 512] ^ (a1[BYTE2(v13) + 256] + a1[HIBYTE(v13)]))) ^ a1[1030] ^ v12;
  v15 = (a1[(unsigned __int8)v14 + 768] + (a1[BYTE1(v14) + 512] ^ (a1[BYTE2(v14) + 256] + a1[HIBYTE(v14)]))) ^ a1[1029] ^ v13;
  v16 = (a1[(unsigned __int8)v15 + 768] + (a1[BYTE1(v15) + 512] ^ (a1[BYTE2(v15) + 256] + a1[HIBYTE(v15)]))) ^ a1[1028] ^ v14;
  v17 = (a1[(unsigned __int8)v16 + 768] + (a1[BYTE1(v16) + 512] ^ (a1[BYTE2(v16) + 256] + a1[HIBYTE(v16)]))) ^ a1[1027] ^ v15;
  v18 = (a1[(unsigned __int8)v17 + 768] + (a1[BYTE1(v17) + 512] ^ (a1[BYTE2(v17) + 256] + a1[HIBYTE(v17)]))) ^ a1[1026] ^ v16;
  v19 = (a1[(unsigned __int8)v18 + 768] + (a1[BYTE1(v18) + 512] ^ (a1[BYTE2(v18) + 256] + a1[HIBYTE(v18)]))) ^ a1[1025] ^ v17;
  *a2 = v18 ^ a1[1024];
  result = a3;
  *a3 = v19;
  return result;
}

//----- (0000000000011B3E) ----------------------------------------------------
char * Blowfish_initstate(char *a1)
{
  char *v1; // rdx
  char *v2; // rdi
  signed __int64 v3; // rdx
  char *result; // rax

  v1 = a1;
  *(_QWORD *)a1 = qword_44AA0[0];
  *((_QWORD *)a1 + 520) = qword_44AA0[520];
  v2 = (char *)((unsigned __int64)(a1 + 8) & 0xFFFFFFFFFFFFFFF8LL);
  v3 = v1 - v2;
  result = (char *)qword_44AA0 - v3;
  qmemcpy(v2, (char *)qword_44AA0 - v3, 8LL * ((((_DWORD)v3 + 4168) & 0xFFFFFFF8) >> 3));
  return result;
}

//----- (0000000000011B9F) ----------------------------------------------------
__int64  Blowfish_stream2word(__int64 a1, unsigned __int16 a2, _WORD *a3)
{
  unsigned __int8 v4; // [rsp+21h] [rbp-7h]
  _BYTE v5[6]; // [rsp+22h] [rbp-6h]

  *(_WORD *)&v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int16)*a3;
  v4 = 0;
  while ( v4 <= 3u )
  {
    if ( *(_WORD *)v5 >= a2 )
      *(_WORD *)v5 = 0;
    *(_DWORD *)&v5[2] = (*(_DWORD *)&v5[2] << 8) | *(unsigned __int8 *)(*(unsigned __int16 *)v5 + a1);
    ++v4;
    ++*(_WORD *)v5;
  }
  *a3 = *(_WORD *)v5;
  return *(unsigned int *)&v5[2];
}

//----- (0000000000011C22) ----------------------------------------------------
unsigned __int64  Blowfish_expand0state(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  unsigned __int16 v4; // [rsp+Ch] [rbp-34h]
  __int16 v5; // [rsp+26h] [rbp-1Ah]
  unsigned __int16 i; // [rsp+28h] [rbp-18h]
  unsigned __int16 j; // [rsp+2Ah] [rbp-16h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]
  int v10; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v11 = __readfsqword(0x28u);
  v5 = 0;
  for ( i = 0; i <= 0x11u; ++i )
  {
    v10 = Blowfish_stream2word(a2, v4, &v5);
    *(_DWORD *)(a1 + 4 * (i + 1024LL)) ^= v10;
  }
  v5 = 0;
  v8 = 0;
  v9 = 0;
  for ( i = 0; i <= 0x11u; i += 2 )
  {
    Blowfish_encipher(a1, &v8, &v9);
    *(_DWORD *)(a1 + 4 * (i + 1024LL)) = v8;
    *(_DWORD *)(a1 + 4 * (i + 1 + 1024LL)) = v9;
  }
  for ( i = 0; i <= 3u; ++i )
  {
    for ( j = 0; j <= 0xFFu; j += 2 )
    {
      Blowfish_encipher(a1, &v8, &v9);
      *(_DWORD *)(a1 + 4 * (((unsigned __int64)i << 8) + j)) = v8;
      *(_DWORD *)(a1 + 4 * (((unsigned __int64)i << 8) + j + 1)) = v9;
    }
  }
  return __readfsqword(0x28u) ^ v11;
}
// 8C70: using guessed type __int64  Blowfish_stream2word(_QWORD, _QWORD, _QWORD);
// 9A80: using guessed type __int64  Blowfish_encipher(_QWORD, _QWORD, _QWORD);

//----- (0000000000011DBF) ----------------------------------------------------
unsigned __int64  Blowfish_expandstate(__int64 a1, __int64 a2, unsigned __int16 a3, __int64 a4, unsigned __int16 a5)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  __int64 v10; // [rsp+0h] [rbp-40h]
  unsigned __int16 v11; // [rsp+8h] [rbp-38h]
  unsigned __int16 v12; // [rsp+Ch] [rbp-34h]
  __int16 v13; // [rsp+26h] [rbp-1Ah]
  unsigned __int16 i; // [rsp+28h] [rbp-18h]
  unsigned __int16 j; // [rsp+2Ah] [rbp-16h]
  int v16; // [rsp+2Ch] [rbp-14h]
  int v17; // [rsp+30h] [rbp-10h]
  int v18; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v19; // [rsp+38h] [rbp-8h]

  v10 = a4;
  v12 = a3;
  v11 = a5;
  v19 = __readfsqword(0x28u);
  v13 = 0;
  for ( i = 0; i <= 0x11u; ++i )
  {
    v18 = Blowfish_stream2word(v10, v11, &v13);
    *(_DWORD *)(a1 + 4 * (i + 1024LL)) ^= v18;
  }
  v13 = 0;
  v16 = 0;
  v17 = 0;
  for ( i = 0; i <= 0x11u; i += 2 )
  {
    v5 = Blowfish_stream2word(a2, v12, &v13);
    v16 ^= v5;
    v6 = Blowfish_stream2word(a2, v12, &v13);
    v17 ^= v6;
    Blowfish_encipher(a1, &v16, &v17);
    *(_DWORD *)(a1 + 4 * (i + 1024LL)) = v16;
    *(_DWORD *)(a1 + 4 * (i + 1 + 1024LL)) = v17;
  }
  for ( i = 0; i <= 3u; ++i )
  {
    for ( j = 0; j <= 0xFFu; j += 2 )
    {
      v7 = Blowfish_stream2word(a2, v12, &v13);
      v16 ^= v7;
      v8 = Blowfish_stream2word(a2, v12, &v13);
      v17 ^= v8;
      Blowfish_encipher(a1, &v16, &v17);
      *(_DWORD *)(a1 + 4 * (((unsigned __int64)i << 8) + j)) = v16;
      *(_DWORD *)(a1 + 4 * (((unsigned __int64)i << 8) + j + 1)) = v17;
    }
  }
  return __readfsqword(0x28u) ^ v19;
}
// 8C70: using guessed type __int64  Blowfish_stream2word(_QWORD, _QWORD, _QWORD);
// 9A80: using guessed type __int64  Blowfish_encipher(_QWORD, _QWORD, _QWORD);

//----- (0000000000011FFE) ----------------------------------------------------
__int64  blf_key(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  unsigned __int16 v3; // ST0C_2

  v3 = a3;
  Blowfish_initstate(a1);
  return Blowfish_expand0state(a1, a2, v3);
}
// 8B50: using guessed type __int64  Blowfish_expand0state(_QWORD, _QWORD, _QWORD);
// 9150: using guessed type __int64  Blowfish_initstate(_QWORD);

//----- (000000000001203A) ----------------------------------------------------
__int64  blf_enc(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  __int64 result; // rax
  unsigned __int16 v4; // [rsp+Ch] [rbp-24h]
  unsigned __int16 i; // [rsp+26h] [rbp-Ah]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v6 = a2;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    Blowfish_encipher(a1, v6, v6 + 4);
    v6 += 8LL;
  }
  return result;
}
// 9A80: using guessed type __int64  Blowfish_encipher(_QWORD, _QWORD, _QWORD);

//----- (0000000000012098) ----------------------------------------------------
__int64  blf_dec(__int64 a1, __int64 a2, unsigned __int16 a3)
{
  __int64 result; // rax
  unsigned __int16 v4; // [rsp+Ch] [rbp-24h]
  unsigned __int16 i; // [rsp+26h] [rbp-Ah]
  __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v6 = a2;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    Blowfish_decipher(a1, v6, v6 + 4);
    v6 += 8LL;
  }
  return result;
}
// 9550: using guessed type __int64  Blowfish_decipher(_QWORD, _QWORD, _QWORD);

//----- (00000000000120F6) ----------------------------------------------------
unsigned __int64  blf_ecb_encrypt(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-34h]
  __int64 v5; // [rsp+10h] [rbp-30h]
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  unsigned int v7; // [rsp+30h] [rbp-10h]
  unsigned int i; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v5 = a2;
  v4 = a3;
  v9 = __readfsqword(0x28u);
  for ( i = 0; i < v4; i += 8 )
  {
    v6 = _byteswap_ulong(*(_DWORD *)v5);
    v7 = _byteswap_ulong(*(_DWORD *)(v5 + 4));
    Blowfish_encipher(a1, &v6, &v7);
    *(_BYTE *)v5 = HIBYTE(v6);
    *(_BYTE *)(v5 + 1) = BYTE2(v6);
    *(_BYTE *)(v5 + 2) = BYTE1(v6);
    *(_BYTE *)(v5 + 3) = v6;
    *(_BYTE *)(v5 + 4) = HIBYTE(v7);
    *(_BYTE *)(v5 + 5) = BYTE2(v7);
    *(_BYTE *)(v5 + 6) = BYTE1(v7);
    *(_BYTE *)(v5 + 7) = v7;
    v5 += 8LL;
  }
  return __readfsqword(0x28u) ^ v9;
}
// 9A80: using guessed type __int64  Blowfish_encipher(_QWORD, _QWORD, _QWORD);

//----- (000000000001227D) ----------------------------------------------------
unsigned __int64  blf_ecb_decrypt(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-34h]
  __int64 v5; // [rsp+10h] [rbp-30h]
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  unsigned int v7; // [rsp+30h] [rbp-10h]
  unsigned int i; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v5 = a2;
  v4 = a3;
  v9 = __readfsqword(0x28u);
  for ( i = 0; i < v4; i += 8 )
  {
    v6 = _byteswap_ulong(*(_DWORD *)v5);
    v7 = _byteswap_ulong(*(_DWORD *)(v5 + 4));
    Blowfish_decipher(a1, &v6, &v7);
    *(_BYTE *)v5 = HIBYTE(v6);
    *(_BYTE *)(v5 + 1) = BYTE2(v6);
    *(_BYTE *)(v5 + 2) = BYTE1(v6);
    *(_BYTE *)(v5 + 3) = v6;
    *(_BYTE *)(v5 + 4) = HIBYTE(v7);
    *(_BYTE *)(v5 + 5) = BYTE2(v7);
    *(_BYTE *)(v5 + 6) = BYTE1(v7);
    *(_BYTE *)(v5 + 7) = v7;
    v5 += 8LL;
  }
  return __readfsqword(0x28u) ^ v9;
}
// 9550: using guessed type __int64  Blowfish_decipher(_QWORD, _QWORD, _QWORD);

//----- (0000000000012404) ----------------------------------------------------
unsigned __int64  blf_cbc_encrypt(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  unsigned int v5; // [rsp+4h] [rbp-3Ch]
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+10h] [rbp-30h]
  unsigned int v8; // [rsp+28h] [rbp-18h]
  unsigned int v9; // [rsp+2Ch] [rbp-14h]
  unsigned int i; // [rsp+30h] [rbp-10h]
  unsigned int j; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v12; // [rsp+38h] [rbp-8h]

  v7 = a2;
  v6 = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  for ( i = 0; i < v5; i += 8 )
  {
    for ( j = 0; j <= 7; ++j )
      *(_BYTE *)(j + v6) ^= *(_BYTE *)(j + v7);
    v8 = _byteswap_ulong(*(_DWORD *)v6);
    v9 = _byteswap_ulong(*(_DWORD *)(v6 + 4));
    Blowfish_encipher(a1, &v8, &v9);
    *(_BYTE *)v6 = HIBYTE(v8);
    *(_BYTE *)(v6 + 1) = BYTE2(v8);
    *(_BYTE *)(v6 + 2) = BYTE1(v8);
    *(_BYTE *)(v6 + 3) = v8;
    *(_BYTE *)(v6 + 4) = HIBYTE(v9);
    *(_BYTE *)(v6 + 5) = BYTE2(v9);
    *(_BYTE *)(v6 + 6) = BYTE1(v9);
    *(_BYTE *)(v6 + 7) = v9;
    v7 = v6;
    v6 += 8LL;
  }
  return __readfsqword(0x28u) ^ v12;
}
// 9A80: using guessed type __int64  Blowfish_encipher(_QWORD, _QWORD, _QWORD);

//----- (00000000000125D4) ----------------------------------------------------
unsigned __int64  blf_cbc_decrypt(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  signed __int64 v5; // [rsp+8h] [rbp-38h]
  unsigned int v6; // [rsp+20h] [rbp-20h]
  unsigned int v7; // [rsp+24h] [rbp-1Ch]
  unsigned int i; // [rsp+28h] [rbp-18h]
  unsigned int j; // [rsp+2Ch] [rbp-14h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  v10 = a4 - 16LL + a3;
  v5 = a4 - 8LL + a3;
  for ( i = a4 - 8; i > 7; i -= 8 )
  {
    v6 = _byteswap_ulong(*(_DWORD *)v5);
    v7 = _byteswap_ulong(*(_DWORD *)(v5 + 4));
    Blowfish_decipher(a1, &v6, &v7);
    *(_BYTE *)v5 = HIBYTE(v6);
    *(_BYTE *)(v5 + 1) = BYTE2(v6);
    *(_BYTE *)(v5 + 2) = BYTE1(v6);
    *(_BYTE *)(v5 + 3) = v6;
    *(_BYTE *)(v5 + 4) = HIBYTE(v7);
    *(_BYTE *)(v5 + 5) = BYTE2(v7);
    *(_BYTE *)(v5 + 6) = BYTE1(v7);
    *(_BYTE *)(v5 + 7) = v7;
    for ( j = 0; j <= 7; ++j )
      *(_BYTE *)(j + v5) ^= *(_BYTE *)(j + v10);
    v10 -= 8LL;
    v5 -= 8LL;
  }
  v6 = _byteswap_ulong(*(_DWORD *)v5);
  v7 = _byteswap_ulong(*(_DWORD *)(v5 + 4));
  Blowfish_decipher(a1, &v6, &v7);
  *(_BYTE *)v5 = HIBYTE(v6);
  *(_BYTE *)(v5 + 1) = BYTE2(v6);
  *(_BYTE *)(v5 + 2) = BYTE1(v6);
  *(_BYTE *)(v5 + 3) = v6;
  *(_BYTE *)(v5 + 4) = HIBYTE(v7);
  *(_BYTE *)(v5 + 5) = BYTE2(v7);
  *(_BYTE *)(v5 + 6) = BYTE1(v7);
  *(_BYTE *)(v5 + 7) = v7;
  for ( j = 0; j <= 7; ++j )
    *(_BYTE *)(j + v5) ^= *(_BYTE *)(j + a2);
  return __readfsqword(0x28u) ^ v11;
}
// 9550: using guessed type __int64  Blowfish_decipher(_QWORD, _QWORD, _QWORD);

//----- (0000000000012928) ----------------------------------------------------
__int64  libssh2_channel_nextid(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  __int64 i; // [rsp+18h] [rbp-8h]

  v2 = *(_DWORD *)(a1 + 528);
  for ( i = _libssh2_list_first(a1 + 512); i; i = _libssh2_list_next(i) )
  {
    if ( v2 < *(_DWORD *)(i + 48) )
      v2 = *(_DWORD *)(i + 48);
  }
  *(_DWORD *)(a1 + 528) = v2 + 1;
  return v2;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (000000000001299B) ----------------------------------------------------
__int64  libssh2_channel_locate(__int64 a1, int a2)
{
  __int64 i; // [rsp+10h] [rbp-10h]
  __int64 k; // [rsp+10h] [rbp-10h]
  __int64 j; // [rsp+18h] [rbp-8h]

  for ( i = _libssh2_list_first(a1 + 512); i; i = _libssh2_list_next(i) )
  {
    if ( a2 == *(_DWORD *)(i + 48) )
      return i;
  }
  for ( j = _libssh2_list_first(a1 + 536); j; j = _libssh2_list_next(j) )
  {
    for ( k = _libssh2_list_first(j + 48); k; k = _libssh2_list_next(k) )
    {
      if ( a2 == *(_DWORD *)(k + 48) )
        return k;
    }
  }
  return 0LL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (0000000000012A63) ----------------------------------------------------
__int64  libssh2_channel_open(size_t a1, const void *a2, unsigned int a3, unsigned int a4, unsigned int a5, __int64 a6, __int64 a7)
{
  __int64 v8; // rbx
  _BYTE *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v13; // rbx
  unsigned int v14; // eax
  __int64 v15; // [rsp+8h] [rbp-58h]
  unsigned int v16; // [rsp+14h] [rbp-4Ch]
  unsigned int v17; // [rsp+18h] [rbp-48h]
  unsigned int n; // [rsp+1Ch] [rbp-44h]
  unsigned int v19; // [rsp+30h] [rbp-30h]
  unsigned int v20; // [rsp+30h] [rbp-30h]
  _BYTE *v21; // [rsp+38h] [rbp-28h]
  char v22; // [rsp+44h] [rbp-1Ch]
  unsigned __int64 v23; // [rsp+48h] [rbp-18h]

  n = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v23 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53736) )
  {
    *(_QWORD *)(a1 + 53752) = 0LL;
    *(_QWORD *)(a1 + 53760) = 0LL;
    *(_QWORD *)(a1 + 53776) = 0LL;
    *(_QWORD *)(a1 + 53768) = a3 + 17;
    *(_DWORD *)(a1 + 53792) = _libssh2_channel_nextid(a1);
    memset((void *)(a1 + 53744), 0, 8uLL);
    *(_QWORD *)(a1 + 53752) = _libssh2_calloc(a1, 752LL);
    if ( !*(_QWORD *)(a1 + 53752) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate space for channel data");
      return 0LL;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 53752) + 32LL) = n;
    v8 = *(_QWORD *)(a1 + 53752);
    *(_QWORD *)(v8 + 24) = (*(__int64 ( **)(_QWORD, size_t))(a1 + 8))(n, a1);
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 53752) + 24LL) )
    {
      _libssh2_error(a1, 4294967290LL, "Failed allocating memory for channel type name");
      (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53752), a1);
      *(_QWORD *)(a1 + 53752) = 0LL;
      return 0LL;
    }
    memcpy(*(void **)(*(_QWORD *)(a1 + 53752) + 24LL), a2, n);
    *(_DWORD *)(*(_QWORD *)(a1 + 53752) + 48LL) = *(_DWORD *)(a1 + 53792);
    *(_DWORD *)(*(_QWORD *)(a1 + 53752) + 76LL) = v17;
    *(_DWORD *)(*(_QWORD *)(a1 + 53752) + 72LL) = v17;
    *(_DWORD *)(*(_QWORD *)(a1 + 53752) + 80LL) = v16;
    *(_QWORD *)(*(_QWORD *)(a1 + 53752) + 96LL) = a1;
    _libssh2_list_add(a1 + 512, *(_QWORD *)(a1 + 53752));
    *(_QWORD *)(a1 + 53760) = (*(__int64 ( **)(_QWORD, size_t))(a1 + 8))(*(_QWORD *)(a1 + 53768), a1);
    v21 = *(_BYTE **)(a1 + 53760);
    if ( !*(_QWORD *)(a1 + 53760) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate temporary space for packet");
      goto LABEL_39;
    }
    v9 = v21++;
    *v9 = 90;
    _libssh2_store_str(&v21, a2, n);
    _libssh2_store_u32(&v21, *(unsigned int *)(a1 + 53792));
    _libssh2_store_u32(&v21, v17);
    _libssh2_store_u32(&v21, v16);
    *(_DWORD *)(a1 + 53736) = 2;
  }
  if ( *(_DWORD *)(a1 + 53736) == 2 )
  {
    v19 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53760), *(_QWORD *)(a1 + 53768), v15, a7);
    if ( v19 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block sending channel-open request");
      return 0LL;
    }
    if ( v19 )
    {
      _libssh2_error(a1, v19, "Unable to send channel-open request");
      goto LABEL_39;
    }
    *(_DWORD *)(a1 + 53736) = 3;
  }
  if ( *(_DWORD *)(a1 + 53736) == 3 )
  {
    v20 = _libssh2_packet_requirev(
            a1,
            "[\\",
            a1 + 53776,
            a1 + 53784,
            1LL,
            *(_QWORD *)(a1 + 53760) + n + 5LL,
            4LL,
            a1 + 53744);
    if ( v20 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block");
      return 0LL;
    }
    if ( v20 )
    {
      _libssh2_error(a1, v20, "Unexpected error");
    }
    else if ( *(_QWORD *)(a1 + 53784) )
    {
      if ( **(_BYTE **)(a1 + 53776) == 91 )
      {
        if ( *(_QWORD *)(a1 + 53784) > 0x10uLL )
        {
          v10 = *(_QWORD *)(a1 + 53752);
          *(_DWORD *)(v10 + 68) = _libssh2_ntohu32(*(_QWORD *)(a1 + 53776) + 5LL);
          v11 = *(_QWORD *)(a1 + 53752);
          *(_DWORD *)(v11 + 56) = _libssh2_ntohu32(*(_QWORD *)(a1 + 53776) + 9LL);
          v12 = *(_QWORD *)(a1 + 53752);
          *(_DWORD *)(v12 + 52) = _libssh2_ntohu32(*(_QWORD *)(a1 + 53776) + 9LL);
          v13 = *(_QWORD *)(a1 + 53752);
          *(_DWORD *)(v13 + 60) = _libssh2_ntohu32(*(_QWORD *)(a1 + 53776) + 13LL);
          (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53760), a1);
          *(_QWORD *)(a1 + 53760) = 0LL;
          (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53776), a1);
          *(_QWORD *)(a1 + 53776) = 0LL;
          *(_DWORD *)(a1 + 53736) = 0;
          return *(_QWORD *)(a1 + 53752);
        }
        _libssh2_error(a1, 4294967282LL, "Unexpected packet size");
      }
      else if ( **(_BYTE **)(a1 + 53776) == 92 )
      {
        v14 = _libssh2_ntohu32(*(_QWORD *)(a1 + 53776) + 5LL);
        if ( v14 == 2 )
        {
          _libssh2_error(a1, 4294967275LL, "Channel open failure (connect failed)");
          goto LABEL_39;
        }
        if ( v14 > 2 )
        {
          if ( v14 == 3 )
          {
            _libssh2_error(a1, 4294967275LL, "Channel open failure (unknown channel type)");
            goto LABEL_39;
          }
          if ( v14 == 4 )
          {
            _libssh2_error(a1, 4294967275LL, "Channel open failure (resource shortage)");
            goto LABEL_39;
          }
        }
        else if ( v14 == 1 )
        {
          _libssh2_error(a1, 4294967275LL, "Channel open failure (administratively prohibited)");
          goto LABEL_39;
        }
        _libssh2_error(a1, 4294967275LL, "Channel open failure");
        goto LABEL_39;
      }
    }
    else
    {
      _libssh2_error(a1, 4294967282LL, "Unexpected packet size");
    }
  }
LABEL_39:
  if ( *(_QWORD *)(a1 + 53776) )
  {
    (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53776), a1);
    *(_QWORD *)(a1 + 53776) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 53760) )
  {
    (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53760), a1);
    *(_QWORD *)(a1 + 53760) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 53752) )
  {
    (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 53752) + 24LL), a1);
    _libssh2_list_remove(*(_QWORD *)(a1 + 53752));
    _libssh2_htonu32(&v22, *(unsigned int *)(*(_QWORD *)(a1 + 53752) + 48LL));
    while ( (signed int)_libssh2_packet_ask(a1) >= 0 || (signed int)_libssh2_packet_ask(a1) >= 0 )
    {
      (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53776), a1);
      *(_QWORD *)(a1 + 53776) = 0LL;
    }
    (*(void ( **)(_QWORD, size_t))(a1 + 24))(*(_QWORD *)(a1 + 53752), a1);
    *(_QWORD *)(a1 + 53752) = 0LL;
  }
  *(_DWORD *)(a1 + 53736) = 0;
  return 0LL;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9020: using guessed type __int64  _libssh2_channel_nextid(_QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (0000000000013316) ----------------------------------------------------
__int64  libssh2_channel_open_ex(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int a5, __int64 a6, unsigned int a7)
{
  __int64 v8; // [rsp+8h] [rbp-48h]
  unsigned int v9; // [rsp+14h] [rbp-3Ch]
  unsigned int v10; // [rsp+18h] [rbp-38h]
  unsigned int v11; // [rsp+1Ch] [rbp-34h]
  time_t v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  if ( !a1 )
    return 0LL;
  v12 = time(0LL);
  do
    v13 = _libssh2_channel_open(a1, a2, v11, v10, v9, v8, a7);
  while ( *(_DWORD *)(a1 + 148)
       && !v13
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v12) );
  return v13;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);
// 9A60: using guessed type __int64  _libssh2_channel_open(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000133C9) ----------------------------------------------------
__int64  sub_133C9(__int64 a1, const char *a2, unsigned int a3, char *a4, unsigned int a5)
{
  __int64 result; // rax
  char *v6; // [rsp+0h] [rbp-40h]
  unsigned int v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  __int64 v9; // [rsp+28h] [rbp-18h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  v11 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53796) )
  {
    *(_QWORD *)(a1 + 53808) = strlen(a2);
    *(_QWORD *)(a1 + 53816) = strlen(v6);
    *(_QWORD *)(a1 + 53824) = *(_QWORD *)(a1 + 53808) + *(_QWORD *)(a1 + 53816) + 16LL;
    *(_QWORD *)(a1 + 53800) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53824), a1);
    v9 = *(_QWORD *)(a1 + 53800);
    if ( !*(_QWORD *)(a1 + 53800) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for direct-tcpip connection");
      return 0LL;
    }
    _libssh2_store_str(&v9, a2, *(_QWORD *)(a1 + 53808));
    _libssh2_store_u32(&v9, v8);
    _libssh2_store_str(&v9, v6, *(_QWORD *)(a1 + 53816));
    _libssh2_store_u32(&v9, v7);
  }
  v10 = _libssh2_channel_open(
          a1,
          "direct-tcpip",
          12LL,
          0x200000LL,
          0x8000LL,
          *(_QWORD *)(a1 + 53800),
          *(_QWORD *)(a1 + 53824));
  if ( v10 || (unsigned int)libssh2_session_last_errno(a1) != -37 )
  {
    *(_DWORD *)(a1 + 53796) = 0;
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53800), a1);
    *(_QWORD *)(a1 + 53800) = 0LL;
    result = v10;
  }
  else
  {
    *(_DWORD *)(a1 + 53796) = 2;
    result = 0LL;
  }
  return result;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9A60: using guessed type __int64  _libssh2_channel_open(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000135F9) ----------------------------------------------------
__int64  libssh2_channel_direct_tcpip_ex(__int64 a1, const char *a2, unsigned int a3, char *a4, unsigned int a5)
{
  char *v6; // [rsp+0h] [rbp-40h]
  unsigned int v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  time_t v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 0LL;
  v9 = time(0LL);
  do
    v10 = sub_133C9(a1, a2, v8, v6, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v10
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v9) );
  return v10;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000013699) ----------------------------------------------------
__int64  sub_13699(__int64 a1, char *a2, unsigned int a3, _DWORD *a4, int a5)
{
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  __int64 v8; // rax
  int v9; // eax
  _DWORD *v10; // [rsp+0h] [rbp-50h]
  int v11; // [rsp+8h] [rbp-48h]
  unsigned int v12; // [rsp+Ch] [rbp-44h]
  char *s; // [rsp+10h] [rbp-40h]
  int v14; // [rsp+24h] [rbp-2Ch]
  int v15; // [rsp+24h] [rbp-2Ch]
  _BYTE *v16; // [rsp+28h] [rbp-28h]
  _BYTE *v17; // [rsp+30h] [rbp-20h]
  unsigned __int64 v18; // [rsp+38h] [rbp-18h]
  __int64 v19; // [rsp+40h] [rbp-10h]
  unsigned __int64 v20; // [rsp+48h] [rbp-8h]

  s = a2;
  v12 = a3;
  v10 = a4;
  v11 = a5;
  v20 = __readfsqword(0x28u);
  if ( !a2 )
    s = "0.0.0.0";
  if ( !*(_DWORD *)(a1 + 53832) )
  {
    *(_DWORD *)(a1 + 53848) = strlen(s);
    *(_DWORD *)(a1 + 53852) = *(_DWORD *)(a1 + 53848) + 27;
    memset((void *)(a1 + 53856), 0, 8uLL);
    *(_QWORD *)(a1 + 53840) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(unsigned int *)(a1 + 53852), a1);
    v16 = *(_BYTE **)(a1 + 53840);
    if ( !*(_QWORD *)(a1 + 53840) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for setenv packet");
      return 0LL;
    }
    v6 = v16++;
    *v6 = 80;
    _libssh2_store_str(&v16, "tcpip-forward", 13LL);
    v7 = v16++;
    *v7 = 1;
    _libssh2_store_str(&v16, s, *(unsigned int *)(a1 + 53848));
    _libssh2_store_u32(&v16, v12);
    *(_DWORD *)(a1 + 53832) = 2;
  }
  if ( *(_DWORD *)(a1 + 53832) == 2 )
  {
    v14 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53840), *(unsigned int *)(a1 + 53852), 0LL, 0LL);
    if ( v14 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block sending global-request packet for forward listen request");
      return 0LL;
    }
    if ( v14 )
    {
      _libssh2_error(a1, 4294967289LL, "Unable to send global-request packet for forward listen request");
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53840), a1);
      *(_QWORD *)(a1 + 53840) = 0LL;
      *(_DWORD *)(a1 + 53832) = 0;
      return 0LL;
    }
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53840), a1);
    *(_QWORD *)(a1 + 53840) = 0LL;
    *(_DWORD *)(a1 + 53832) = 3;
  }
  if ( *(_DWORD *)(a1 + 53832) != 3 )
  {
LABEL_33:
    *(_DWORD *)(a1 + 53832) = 0;
    return 0LL;
  }
  v15 = _libssh2_packet_requirev(a1, "QR", &v17, &v18, 0LL, 0LL, 0LL, a1 + 53856);
  if ( v15 == -37 )
  {
    _libssh2_error(a1, 4294967259LL, "Would block");
    return 0LL;
  }
  if ( v15 || !v18 )
  {
    _libssh2_error(a1, 4294967282LL, "Unknown");
    *(_DWORD *)(a1 + 53832) = 0;
    return 0LL;
  }
  if ( *v17 != 81 )
  {
    if ( *v17 == 82 )
    {
      (*(void ( **)(_BYTE *, __int64))(a1 + 24))(v17, a1);
      _libssh2_error(a1, 4294967264LL, "Unable to complete request for forward-listen");
      *(_DWORD *)(a1 + 53832) = 0;
      return 0LL;
    }
    goto LABEL_33;
  }
  v19 = _libssh2_calloc(a1, 96LL);
  if ( v19 )
  {
    v8 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))((unsigned int)(*(_DWORD *)(a1 + 53848) + 1), a1);
    *(_QWORD *)(v19 + 32) = v8;
    if ( *(_QWORD *)(v19 + 32) )
    {
      *(_QWORD *)(v19 + 24) = a1;
      memcpy(*(void **)(v19 + 32), s, *(unsigned int *)(a1 + 53848));
      *(_BYTE *)(*(_QWORD *)(v19 + 32) + *(unsigned int *)(a1 + 53848)) = 0;
      if ( v18 <= 4 || v12 )
      {
        *(_DWORD *)(v19 + 40) = v12;
      }
      else
      {
        v9 = _libssh2_ntohu32(v17 + 1);
        *(_DWORD *)(v19 + 40) = v9;
      }
      *(_DWORD *)(v19 + 64) = 0;
      *(_DWORD *)(v19 + 68) = v11;
      _libssh2_list_add(a1 + 536, v19);
      if ( v10 )
        *v10 = *(_DWORD *)(v19 + 40);
    }
    else
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for listener queue");
      (*(void ( **)(__int64, __int64))(a1 + 24))(v19, a1);
      v19 = 0LL;
    }
  }
  else
  {
    _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for listener queue");
  }
  (*(void ( **)(_BYTE *, __int64))(a1 + 24))(v17, a1);
  *(_DWORD *)(a1 + 53832) = 0;
  return v19;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (0000000000013BFD) ----------------------------------------------------
__int64  libssh2_channel_forward_listen_ex(__int64 a1, char *a2, unsigned int a3, _DWORD *a4, int a5)
{
  _DWORD *v6; // [rsp+0h] [rbp-40h]
  int v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  time_t v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 0LL;
  v9 = time(0LL);
  do
    v10 = sub_13699(a1, a2, v8, v6, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v10
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v9) );
  return v10;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000016FDF) ----------------------------------------------------
signed __int64  _libssh2_channel_close(__int64 a1)
{
  signed __int64 result; // rax
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 96);
  v2 = 0;
  if ( *(_BYTE *)(a1 + 64) )
  {
    *(_DWORD *)(a1 + 656) = 0;
    return 0LL;
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    v2 = sub_16C6B(a1);
    if ( v2 )
    {
      if ( v2 == -37 )
        return 4294967259LL;
      _libssh2_error(v3, v2, "Unable to send EOF, but closing channel anyway");
    }
  }
  if ( !*(_DWORD *)(a1 + 656) )
  {
    *(_BYTE *)(a1 + 660) = 97;
    _libssh2_htonu32(a1 + 661, *(unsigned int *)(a1 + 68));
    *(_DWORD *)(a1 + 656) = 2;
  }
  if ( *(_DWORD *)(a1 + 656) == 2 )
  {
    v2 = _libssh2_transport_send(v3, a1 + 660, 5LL, 0LL, 0LL);
    if ( v2 == -37 )
    {
      _libssh2_error(v3, 4294967259LL, "Would block sending close-channel");
      return 4294967259LL;
    }
    if ( v2 )
      _libssh2_error(v3, v2, "Unable to send close-channel request, but closing anyway");
    else
      *(_DWORD *)(a1 + 656) = 3;
  }
  if ( *(_DWORD *)(a1 + 656) == 3 )
  {
    while ( !*(_BYTE *)(a1 + 84) && !v2 && *(_DWORD *)(v3 + 556) != -1 )
      v2 = _libssh2_transport_read(v3);
  }
  if ( v2 != -37 )
  {
    *(_BYTE *)(a1 + 64) = 1;
    if ( *(_QWORD *)(a1 + 112) )
      (*(void ( **)(__int64, __int64, __int64, __int64))(a1 + 112))(v3, v3, a1, a1 + 104);
    *(_DWORD *)(a1 + 656) = 0;
  }
  result = 0LL;
  if ( (signed int)v2 <= 0 )
    result = v2;
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);



//----- (0000000000017366) ----------------------------------------------------
signed __int64  _libssh2_channel_free(__int64 a1)
{
  size_t n; // [rsp+28h] [rbp-18h]
  char v3; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+38h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  n = *(_QWORD *)(a1 + 96);
  if ( !n )
    __assert_fail("session", "/home/mantovan/Repositories/libssh2/src/channel.c", 0xAA3u, "_libssh2_channel_free");
  if ( !*(_DWORD *)(a1 + 676) )
    *(_DWORD *)(a1 + 676) = 2;
  if ( !*(_BYTE *)(a1 + 64) && !*(_DWORD *)(n + 556) && (unsigned int)_libssh2_channel_close(a1) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 676) = 0;
  if ( *(_QWORD *)(a1 + 40) )
    (*(void ( **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 40), n);
  _libssh2_htonu32(&v3, *(unsigned int *)(a1 + 48));
  while ( (signed int)_libssh2_packet_ask(n) >= 0 || (signed int)_libssh2_packet_ask(n) >= 0 )
    (*(void ( **)(size_t))(n + 24))(n);
  if ( *(_QWORD *)(a1 + 24) )
    (*(void ( **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 24), n);
  _libssh2_list_remove(a1);
  if ( *(_QWORD *)(a1 + 128) )
    (*(void ( **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 128), n);
  if ( *(_QWORD *)(a1 + 496) )
    (*(void ( **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 496), n);
  if ( *(_QWORD *)(a1 + 536) )
    (*(void ( **)(_QWORD, size_t))(n + 24))(*(_QWORD *)(a1 + 536), n);
  (*(void ( **)(__int64, size_t))(n + 24))(a1, n);
  return 0LL;
}
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9950: using guessed type __int64  _libssh2_channel_close(_QWORD);



//----- (0000000000013C9D) ----------------------------------------------------
signed __int64  _libssh2_channel_forward_cancel(__int64 a1)
{
  _BYTE *v2; // rax
  _BYTE *v3; // rax
  unsigned int v4; // [rsp+18h] [rbp-48h]
  int v5; // [rsp+1Ch] [rbp-44h]
  _BYTE *v6; // [rsp+20h] [rbp-40h]
  __int64 i; // [rsp+28h] [rbp-38h]
  _BYTE *v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  size_t v10; // [rsp+40h] [rbp-20h]
  size_t v11; // [rsp+48h] [rbp-18h]
  __int64 v12; // [rsp+50h] [rbp-10h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = *(_QWORD *)(a1 + 24);
  v10 = strlen(*(const char **)(a1 + 32));
  v11 = v10 + 34;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 72) )
  {
    v8 = *(_BYTE **)(a1 + 80);
  }
  else
  {
    v8 = (_BYTE *)(*(__int64 ( **)(size_t, __int64))(v9 + 8))(v11, v9);
    v6 = v8;
    if ( !v8 )
    {
      _libssh2_error(v9, 4294967290LL, "Unable to allocate memory for setenv packet");
      return 4294967290LL;
    }
    v2 = v6++;
    *v2 = 80;
    _libssh2_store_str(&v6, "cancel-tcpip-forward", 20LL);
    v3 = v6++;
    *v3 = 0;
    _libssh2_store_str(&v6, *(_QWORD *)(a1 + 32), v10);
    _libssh2_store_u32(&v6, *(unsigned int *)(a1 + 40));
    *(_DWORD *)(a1 + 72) = 2;
  }
  if ( *(_DWORD *)(a1 + 72) == 2 )
  {
    v5 = _libssh2_transport_send(v9, v8, v11, 0LL, 0LL);
    if ( v5 == -37 )
    {
      _libssh2_error(v9, 4294967259LL, "Would block sending forward request");
      *(_QWORD *)(a1 + 80) = v8;
      return 4294967259LL;
    }
    if ( v5 )
    {
      _libssh2_error(v9, 4294967289LL, "Unable to send global-request packet for forward listen request");
      *(_DWORD *)(a1 + 72) = 3;
      v4 = -7;
    }
    (*(void ( **)(_BYTE *, __int64))(v9 + 24))(v8, v9);
    *(_DWORD *)(a1 + 72) = 3;
  }
  for ( i = _libssh2_list_first(a1 + 48); i; i = v12 )
  {
    v12 = _libssh2_list_next(i);
    if ( (unsigned int)_libssh2_channel_free(i) == -37 )
      return 4294967259LL;
  }
  (*(void ( **)(_QWORD, __int64))(v9 + 24))(*(_QWORD *)(a1 + 32), v9);
  _libssh2_list_remove(a1);
  (*(void ( **)(__int64, __int64))(v9 + 24))(a1, v9);
  return v4;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8CC0: using guessed type __int64  _libssh2_channel_free(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000013F27) ----------------------------------------------------
signed __int64  libssh2_channel_forward_cancel(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = _libssh2_channel_forward_cancel(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 24) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 24), v3);
  }
  while ( !v2 );
  return v2;
}
// 9300: using guessed type __int64  _libssh2_channel_forward_cancel(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000013F9B) ----------------------------------------------------
__int64  sub_13F9B(__int64 a1)
{
  __int64 v1; // ST18_8
  __int64 result; // rax
  int v3; // [rsp+14h] [rbp-Ch]

  do
    v3 = _libssh2_transport_read(*(_QWORD *)(a1 + 24));
  while ( v3 > 0 );
  if ( _libssh2_list_first(a1 + 48) )
  {
    v1 = _libssh2_list_first(a1 + 48);
    _libssh2_list_remove(v1);
    --*(_DWORD *)(a1 + 64);
    _libssh2_list_add(*(_QWORD *)(v1 + 96) + 512LL, v1);
    result = v1;
  }
  else
  {
    if ( v3 == -37 )
      _libssh2_error(*(_QWORD *)(a1 + 24), 4294967259LL, "Would block waiting for packet");
    else
      _libssh2_error(*(_QWORD *)(a1 + 24), 4294967273LL, "Channel not found");
    result = 0LL;
  }
  return result;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (0000000000014071) ----------------------------------------------------
__int64  libssh2_channel_forward_accept(__int64 a1)
{
  time_t v2; // [rsp+20h] [rbp-10h]
  __int64 v3; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v2 = time(0LL);
  do
    v3 = sub_13F9B(a1);
  while ( *(_DWORD *)(*(_QWORD *)(a1 + 24) + 148LL)
       && !v3
       && (unsigned int)libssh2_session_last_errno(*(_QWORD *)(a1 + 24)) == -37
       && !(unsigned int)_libssh2_wait_socket(*(_QWORD *)(a1 + 24), v2) );
  return v3;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000140FD) ----------------------------------------------------
__int64  sub_140FD(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5)
{
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  __int64 v8; // [rsp+0h] [rbp-50h]
  unsigned int v9; // [rsp+8h] [rbp-48h]
  unsigned int v10; // [rsp+Ch] [rbp-44h]
  int v11; // [rsp+24h] [rbp-2Ch]
  unsigned int v12; // [rsp+24h] [rbp-2Ch]
  _BYTE *v13; // [rsp+28h] [rbp-28h]
  _BYTE *v14; // [rsp+30h] [rbp-20h]
  __int64 v15; // [rsp+38h] [rbp-18h]
  __int64 v16; // [rsp+40h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v17 = __readfsqword(0x28u);
  v16 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 120) )
  {
    *(_QWORD *)(a1 + 136) = a3 + a5 + 21;
    memset((void *)(a1 + 152), 0, 8uLL);
    *(_QWORD *)(a1 + 128) = (*(__int64 ( **)(_QWORD, __int64))(v16 + 8))(*(_QWORD *)(a1 + 136), v16);
    v13 = *(_BYTE **)(a1 + 128);
    if ( !*(_QWORD *)(a1 + 128) )
      return _libssh2_error(v16, 4294967290LL, "Unable to allocate memory for setenv packet");
    v6 = v13++;
    *v6 = 98;
    _libssh2_store_u32(&v13, *(unsigned int *)(a1 + 68));
    _libssh2_store_str(&v13, "env", 3LL);
    v7 = v13++;
    *v7 = 1;
    _libssh2_store_str(&v13, a2, v10);
    _libssh2_store_str(&v13, v8, v9);
    *(_DWORD *)(a1 + 120) = 2;
  }
  if ( *(_DWORD *)(a1 + 120) == 2 )
  {
    v11 = _libssh2_transport_send(v16, *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 136), 0LL, 0LL);
    if ( v11 == -37 )
    {
      _libssh2_error(v16, 4294967259LL, "Would block sending setenv request");
      return 4294967259LL;
    }
    if ( v11 )
    {
      (*(void ( **)(_QWORD, __int64))(v16 + 24))(*(_QWORD *)(a1 + 128), v16);
      *(_QWORD *)(a1 + 128) = 0LL;
      *(_DWORD *)(a1 + 120) = 0;
      return _libssh2_error(v16, 4294967289LL, "Unable to send channel-request packet for setenv request");
    }
    (*(void ( **)(_QWORD, __int64))(v16 + 24))(*(_QWORD *)(a1 + 128), v16);
    *(_QWORD *)(a1 + 128) = 0LL;
    _libssh2_htonu32(a1 + 144, *(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 120) = 3;
  }
  if ( *(_DWORD *)(a1 + 120) == 3 )
  {
    v12 = _libssh2_packet_requirev(v16, "cd", &v14, &v15, 1LL, a1 + 144, 4LL, a1 + 152);
    if ( v12 == -37 )
      return 4294967259LL;
    if ( v12 )
    {
      *(_DWORD *)(a1 + 120) = 0;
      return v12;
    }
    if ( !v15 )
    {
      *(_DWORD *)(a1 + 120) = 0;
      return _libssh2_error(v16, 4294967282LL, "Unexpected packet size");
    }
    if ( *v14 == 99 )
    {
      (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v14, v16);
      *(_DWORD *)(a1 + 120) = 0;
      return 0LL;
    }
    (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v14, v16);
  }
  *(_DWORD *)(a1 + 120) = 0;
  return _libssh2_error(v16, 4294967274LL, "Unable to complete request for channel-setenv");
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (00000000000144A7) ----------------------------------------------------
signed __int64  libssh2_channel_setenv_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5)
{
  __int64 v6; // [rsp+0h] [rbp-30h]
  unsigned int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_140FD(a1, a2, v8, v6, v7);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000001453B) ----------------------------------------------------
__int64  sub_1453B(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9)
{
  __int64 result; // rax
  _BYTE *v10; // rax
  char v11; // ST43_1
  unsigned int v12; // [rsp+Ch] [rbp-54h]
  __int64 v13; // [rsp+10h] [rbp-50h]
  unsigned int v14; // [rsp+18h] [rbp-48h]
  unsigned int v15; // [rsp+1Ch] [rbp-44h]
  unsigned int v16; // [rsp+34h] [rbp-2Ch]
  int v17; // [rsp+34h] [rbp-2Ch]
  _BYTE *v18; // [rsp+38h] [rbp-28h]
  char *v19; // [rsp+40h] [rbp-20h]
  __int64 v20; // [rsp+48h] [rbp-18h]
  __int64 v21; // [rsp+50h] [rbp-10h]
  unsigned __int64 v22; // [rsp+58h] [rbp-8h]

  v15 = a3;
  v13 = a4;
  v14 = a5;
  v12 = a6;
  v22 = __readfsqword(0x28u);
  v21 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 160) )
  {
    if ( a3 + a5 > 0x100 )
      return _libssh2_error(v21, 4294967262LL, "term + mode lengths too large");
    *(_QWORD *)(a1 + 464) = a3 + a5 + 41;
    memset((void *)(a1 + 480), 0, 8uLL);
    v18 = (_BYTE *)(a1 + 165);
    *(_BYTE *)(a1 + 164) = 98;
    _libssh2_store_u32(&v18, *(unsigned int *)(a1 + 68));
    _libssh2_store_str(&v18, "pty-req", 7LL);
    v10 = v18++;
    *v10 = 1;
    _libssh2_store_str(&v18, a2, v15);
    _libssh2_store_u32(&v18, v12);
    _libssh2_store_u32(&v18, a7);
    _libssh2_store_u32(&v18, a8);
    _libssh2_store_u32(&v18, a9);
    _libssh2_store_str(&v18, v13, v14);
    *(_DWORD *)(a1 + 160) = 2;
  }
  if ( *(_DWORD *)(a1 + 160) == 2 )
  {
    v16 = _libssh2_transport_send(v21, a1 + 164, *(_QWORD *)(a1 + 464), 0LL, 0LL);
    if ( v16 == -37 )
    {
      _libssh2_error(v21, 4294967259LL, "Would block sending pty request");
      return 4294967259LL;
    }
    if ( v16 )
    {
      *(_DWORD *)(a1 + 160) = 0;
      return _libssh2_error(v21, v16, "Unable to send pty-request packet");
    }
    _libssh2_htonu32(a1 + 472, *(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 160) = 3;
  }
  if ( *(_DWORD *)(a1 + 160) != 3 )
    goto LABEL_22;
  v17 = _libssh2_packet_requirev(v21, "cd", &v19, &v20, 1LL, a1 + 472, 4LL, a1 + 480);
  if ( v17 == -37 )
    return 4294967259LL;
  if ( v17 || !v20 )
  {
    *(_DWORD *)(a1 + 160) = 0;
    return _libssh2_error(v21, 4294967282LL, "Failed to require the PTY package");
  }
  v11 = *v19;
  (*(void ( **)(char *, __int64))(v21 + 24))(v19, v21);
  *(_DWORD *)(a1 + 160) = 0;
  if ( v11 != 99 )
LABEL_22:
    result = _libssh2_error(v21, 4294967274LL, "Unable to complete request for channel request-pty");
  else
    result = 0LL;
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000014889) ----------------------------------------------------
__int64  sub_14889(__int64 a1, __int64 a2, signed int a3)
{
  __int64 result; // rax
  _BYTE *v4; // rax
  int v5; // ST33_4
  signed int v6; // [rsp+Ch] [rbp-44h]
  unsigned int v7; // [rsp+24h] [rbp-2Ch]
  int v8; // [rsp+24h] [rbp-2Ch]
  _BYTE *v9; // [rsp+28h] [rbp-28h]
  unsigned __int8 *v10; // [rsp+30h] [rbp-20h]
  char v11; // [rsp+38h] [rbp-18h]
  __int64 v12; // [rsp+40h] [rbp-10h]
  unsigned __int64 v13; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v13 = __readfsqword(0x28u);
  v12 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 688) )
  {
    if ( a3 > 26 )
      return _libssh2_error(v12, 4294967262LL, "request_str length too large");
    *(_QWORD *)(a1 + 728) = a3 + 10;
    memset((void *)(a1 + 744), 0, 8uLL);
    v9 = (_BYTE *)(a1 + 693);
    *(_BYTE *)(a1 + 692) = 98;
    _libssh2_store_u32(&v9, *(unsigned int *)(a1 + 68));
    _libssh2_store_str(&v9, a2, v6);
    v4 = v9++;
    *v4 = 1;
    *(_DWORD *)(a1 + 688) = 2;
  }
  if ( *(_DWORD *)(a1 + 688) == 2 )
  {
    v7 = _libssh2_transport_send(v12, a1 + 692, *(_QWORD *)(a1 + 728), 0LL, 0LL);
    if ( v7 == -37 )
    {
      _libssh2_error(v12, 4294967259LL, "Would block sending auth-agent request");
    }
    else if ( v7 )
    {
      *(_DWORD *)(a1 + 688) = 0;
      return _libssh2_error(v12, v7, "Unable to send auth-agent request");
    }
    _libssh2_htonu32(a1 + 736, *(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 688) = 3;
  }
  if ( *(_DWORD *)(a1 + 688) != 3 )
    goto LABEL_21;
  v8 = _libssh2_packet_requirev(v12, "cd", &v10, &v11, 1LL, a1 + 736, 4LL, a1 + 744);
  if ( v8 == -37 )
    return 4294967259LL;
  if ( v8 )
  {
    *(_DWORD *)(a1 + 688) = 0;
    return _libssh2_error(v12, 4294967282LL, "Failed to request auth-agent");
  }
  v5 = *v10;
  (*(void ( **)(unsigned __int8 *, __int64))(v12 + 24))(v10, v12);
  *(_DWORD *)(a1 + 688) = 0;
  if ( (_BYTE)v5 != 99 )
LABEL_21:
    result = _libssh2_error(v12, 4294967274LL, "Unable to complete request for auth-agent");
  else
    result = 0LL;
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000014B40) ----------------------------------------------------
signed __int64  libssh2_channel_request_auth_agent(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-14h]
  time_t v3; // [rsp+20h] [rbp-10h]
  time_t v4; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  if ( !*(_DWORD *)(a1 + 684) )
  {
    v3 = time(0LL);
    do
    {
      v2 = sub_14889(a1, (__int64)"auth-agent-req@openssh.com", 26);
      if ( v2 != -37 )
        break;
      if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
        break;
      v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v3);
    }
    while ( !v2 );
    if ( v2 && v2 != -37 )
      *(_DWORD *)(a1 + 684) = 3;
  }
  if ( *(_DWORD *)(a1 + 684) == 3 )
  {
    v4 = time(0LL);
    do
    {
      v2 = sub_14889(a1, (__int64)"auth-agent-req", 14);
      if ( v2 != -37 )
        break;
      if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
        break;
      v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v4);
    }
    while ( !v2 );
    if ( v2 && v2 != -37 )
      *(_DWORD *)(a1 + 684) = 4;
  }
  if ( !v2 )
    *(_DWORD *)(a1 + 684) = 0;
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000014C89) ----------------------------------------------------
signed __int64  libssh2_channel_request_pty_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9)
{
  unsigned int v10; // [rsp+Ch] [rbp-34h]
  __int64 v11; // [rsp+10h] [rbp-30h]
  unsigned int v12; // [rsp+18h] [rbp-28h]
  unsigned int v13; // [rsp+1Ch] [rbp-24h]
  unsigned int v14; // [rsp+34h] [rbp-Ch]
  time_t v15; // [rsp+38h] [rbp-8h]

  v13 = a3;
  v11 = a4;
  v12 = a5;
  v10 = a6;
  if ( !a1 )
    return 4294967257LL;
  v15 = time(0LL);
  do
  {
    v14 = sub_1453B(a1, a2, v13, v11, v12, v10, a7, a8, a9);
    if ( v14 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v14 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v15);
  }
  while ( !v14 );
  return v14;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000014D37) ----------------------------------------------------
__int64  sub_14D37(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  _BYTE *v5; // rax
  unsigned int v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  unsigned int v9; // [rsp+10h] [rbp-30h]
  unsigned int v10; // [rsp+20h] [rbp-20h]
  unsigned int v11; // [rsp+24h] [rbp-1Ch]
  _BYTE *v12; // [rsp+28h] [rbp-18h]
  __int64 v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  v13 = *(_QWORD *)(a1 + 96);
  v10 = -14;
  if ( !*(_DWORD *)(a1 + 160) )
  {
    *(_QWORD *)(a1 + 464) = 39LL;
    memset((void *)(a1 + 480), 0, 8uLL);
    v12 = (_BYTE *)(a1 + 165);
    *(_BYTE *)(a1 + 164) = 98;
    _libssh2_store_u32(&v12, *(unsigned int *)(a1 + 68));
    _libssh2_store_str(&v12, "window-change", 13LL);
    v5 = v12++;
    *v5 = 0;
    _libssh2_store_u32(&v12, a2);
    _libssh2_store_u32(&v12, v9);
    _libssh2_store_u32(&v12, v8);
    _libssh2_store_u32(&v12, v7);
    *(_DWORD *)(a1 + 160) = 2;
  }
  if ( *(_DWORD *)(a1 + 160) == 2 )
  {
    v11 = _libssh2_transport_send(v13, a1 + 164, *(_QWORD *)(a1 + 464), 0LL, 0LL);
    if ( v11 == -37 )
    {
      _libssh2_error(v13, 4294967259LL, "Would block sending window-change request");
      return 4294967259LL;
    }
    if ( v11 )
    {
      *(_DWORD *)(a1 + 160) = 0;
      return _libssh2_error(v13, v11, "Unable to send window-change packet");
    }
    _libssh2_htonu32(a1 + 472, *(unsigned int *)(a1 + 48));
    v10 = 0;
  }
  *(_DWORD *)(a1 + 160) = 0;
  return v10;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000014F38) ----------------------------------------------------
signed __int64  libssh2_channel_request_pty_size_ex(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+Ch] [rbp-24h]
  unsigned int v8; // [rsp+10h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_14D37(a1, a2, v8, v7, v6);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000014FC8) ----------------------------------------------------
__int64  sub_14FC8(__int64 a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  size_t v5; // rax
  size_t v6; // rax
  __int64 result; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  const char *v11; // rax
  char v12; // ST37_1
  char *v13; // [rsp+0h] [rbp-80h]
  char *s; // [rsp+8h] [rbp-78h]
  unsigned int v15; // [rsp+10h] [rbp-70h]
  signed int i; // [rsp+28h] [rbp-58h]
  unsigned int v17; // [rsp+2Ch] [rbp-54h]
  unsigned int v18; // [rsp+2Ch] [rbp-54h]
  void *dest; // [rsp+30h] [rbp-50h]
  __int64 v20; // [rsp+38h] [rbp-48h]
  char *v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h]
  size_t v23; // [rsp+50h] [rbp-30h]
  size_t n; // [rsp+58h] [rbp-28h]
  char v25[24]; // [rsp+60h] [rbp-20h]
  unsigned __int64 v26; // [rsp+78h] [rbp-8h]

  s = (char *)a3;
  v13 = a4;
  v15 = a5;
  v26 = __readfsqword(0x28u);
  v22 = *(_QWORD *)(a1 + 96);
  if ( a3 )
    v5 = strlen(a3);
  else
    v5 = 18LL;
  v23 = v5;
  if ( v13 )
    v6 = strlen(v13);
  else
    v6 = 32LL;
  n = v6;
  if ( !*(_DWORD *)(a1 + 488) )
  {
    *(_QWORD *)(a1 + 504) = v23 + n + 30;
    memset((void *)(a1 + 520), 0, 8uLL);
    *(_QWORD *)(a1 + 496) = (*(__int64 ( **)(_QWORD, __int64))(v22 + 8))(*(_QWORD *)(a1 + 504), v22);
    dest = *(void **)(a1 + 496);
    if ( !*(_QWORD *)(a1 + 496) )
      return _libssh2_error(v22, 4294967290LL, "Unable to allocate memory for pty-request");
    v8 = dest;
    dest = (char *)dest + 1;
    *v8 = 98;
    _libssh2_store_u32(&dest, *(unsigned int *)(a1 + 68));
    _libssh2_store_str(&dest, "x11-req", 7LL);
    v9 = dest;
    dest = (char *)dest + 1;
    *v9 = 1;
    v10 = dest;
    dest = (char *)dest + 1;
    *v10 = a2 != 0;
    if ( s )
      v11 = s;
    else
      v11 = "MIT-MAGIC-COOKIE-1";
    _libssh2_store_str(&dest, v11, v23);
    _libssh2_store_u32(&dest, (unsigned int)n);
    if ( v13 )
    {
      memcpy(dest, v13, n);
    }
    else
    {
      RAND_bytes(v25, 16LL);
      for ( i = 0; i <= 15; ++i )
        snprintf((char *)dest + 2 * i, 3uLL, "%02X", (unsigned __int8)v25[i]);
    }
    dest = (char *)dest + n;
    _libssh2_store_u32(&dest, v15);
    *(_DWORD *)(a1 + 488) = 2;
  }
  if ( *(_DWORD *)(a1 + 488) == 2 )
  {
    v17 = _libssh2_transport_send(v22, *(_QWORD *)(a1 + 496), *(_QWORD *)(a1 + 504), 0LL, 0LL);
    if ( v17 == -37 )
    {
      _libssh2_error(v22, 4294967259LL, "Would block sending X11-req packet");
      return 4294967259LL;
    }
    if ( v17 )
    {
      (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 496), v22);
      *(_QWORD *)(a1 + 496) = 0LL;
      *(_DWORD *)(a1 + 488) = 0;
      return _libssh2_error(v22, v17, "Unable to send x11-req packet");
    }
    (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 496), v22);
    *(_QWORD *)(a1 + 496) = 0LL;
    _libssh2_htonu32(a1 + 512, *(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 488) = 3;
  }
  if ( *(_DWORD *)(a1 + 488) != 3 )
    goto LABEL_36;
  v18 = _libssh2_packet_requirev(v22, "cd", &v21, &v20, 1LL, a1 + 512, 4LL, a1 + 520);
  if ( v18 == -37 )
    return 4294967259LL;
  if ( v18 || !v20 )
  {
    *(_DWORD *)(a1 + 488) = 0;
    return _libssh2_error(v22, v18, "waiting for x11-req response packet");
  }
  v12 = *v21;
  (*(void ( **)(char *, __int64))(v22 + 24))(v21, v22);
  *(_DWORD *)(a1 + 488) = 0;
  if ( v12 != 99 )
LABEL_36:
    result = _libssh2_error(v22, 4294967274LL, "Unable to complete request for channel x11-req");
  else
    result = 0LL;
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9680: using guessed type __int64  RAND_bytes(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 14FC8: using guessed type char var_20[24];

//----- (0000000000015456) ----------------------------------------------------
signed __int64  libssh2_channel_x11_req_ex(__int64 a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  char *v6; // [rsp+0h] [rbp-30h]
  const char *v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+10h] [rbp-20h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v8 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_14FC8(a1, a2, v7, v6, v8);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000154EA) ----------------------------------------------------
__int64  _libssh2_channel_process_startup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 result; // rax
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  char v8; // ST43_1
  __int64 v9; // [rsp+8h] [rbp-58h]
  __int64 v10; // [rsp+10h] [rbp-50h]
  __int64 v11; // [rsp+18h] [rbp-48h]
  unsigned int v12; // [rsp+34h] [rbp-2Ch]
  unsigned int v13; // [rsp+34h] [rbp-2Ch]
  _BYTE *v14; // [rsp+38h] [rbp-28h]
  char *v15; // [rsp+40h] [rbp-20h]
  __int64 v16; // [rsp+48h] [rbp-18h]
  __int64 v17; // [rsp+50h] [rbp-10h]
  unsigned __int64 v18; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v18 = __readfsqword(0x28u);
  v17 = *(_QWORD *)(a1 + 96);
  if ( *(_DWORD *)(a1 + 528) == 16 )
    return _libssh2_error(v17, 4294967257LL, "Channel can not be reused");
  if ( !*(_DWORD *)(a1 + 528) )
  {
    *(_QWORD *)(a1 + 544) = a3 + 10;
    memset((void *)(a1 + 560), 0, 8uLL);
    if ( v10 )
      *(_QWORD *)(a1 + 544) += 4LL;
    *(_QWORD *)(a1 + 536) = (*(__int64 ( **)(_QWORD, __int64))(v17 + 8))(*(_QWORD *)(a1 + 544), v17);
    v14 = *(_BYTE **)(a1 + 536);
    if ( !*(_QWORD *)(a1 + 536) )
      return _libssh2_error(v17, 4294967290LL, "Unable to allocate memory for channel-process request");
    v6 = v14++;
    *v6 = 98;
    _libssh2_store_u32(&v14, *(unsigned int *)(a1 + 68));
    _libssh2_store_str(&v14, a2, v11);
    v7 = v14++;
    *v7 = 1;
    if ( v10 )
      _libssh2_store_u32(&v14, (unsigned int)v9);
    *(_DWORD *)(a1 + 528) = 2;
  }
  if ( *(_DWORD *)(a1 + 528) == 2 )
  {
    v12 = _libssh2_transport_send(v17, *(_QWORD *)(a1 + 536), *(_QWORD *)(a1 + 544), v10, v9);
    if ( v12 == -37 )
    {
      _libssh2_error(v17, 4294967259LL, "Would block sending channel request");
      return 4294967259LL;
    }
    if ( v12 )
    {
      (*(void ( **)(_QWORD, __int64))(v17 + 24))(*(_QWORD *)(a1 + 536), v17);
      *(_QWORD *)(a1 + 536) = 0LL;
      *(_DWORD *)(a1 + 528) = 16;
      return _libssh2_error(v17, v12, "Unable to send channel request");
    }
    (*(void ( **)(_QWORD, __int64))(v17 + 24))(*(_QWORD *)(a1 + 536), v17);
    *(_QWORD *)(a1 + 536) = 0LL;
    _libssh2_htonu32(a1 + 552, *(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 528) = 3;
  }
  if ( *(_DWORD *)(a1 + 528) != 3 )
    goto LABEL_28;
  v13 = _libssh2_packet_requirev(v17, "cd", &v15, &v16, 1LL, a1 + 552, 4LL, a1 + 560);
  if ( v13 == -37 )
    return 4294967259LL;
  if ( v13 || !v16 )
  {
    *(_DWORD *)(a1 + 528) = 16;
    return _libssh2_error(v17, v13, "Failed waiting for channel success");
  }
  v8 = *v15;
  (*(void ( **)(char *, __int64))(v17 + 24))(v15, v17);
  *(_DWORD *)(a1 + 528) = 16;
  if ( v8 != 99 )
LABEL_28:
    result = _libssh2_error(v17, 4294967274LL, "Unable to complete request for channel-process-startup");
  else
    result = 0LL;
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003628F) ----------------------------------------------------
__int64  _libssh2_session_set_blocking(__int64 a1, int a2)
{
  unsigned int v2; // ST1C_4

  v2 = *(_DWORD *)(a1 + 148);
  *(_DWORD *)(a1 + 148) = a2;
  return v2;
}

//----- (00000000000158B2) ----------------------------------------------------
__int64  libssh2_channel_process_startup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+0h] [rbp-30h]
  unsigned int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v6 = a4;
  v7 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = _libssh2_channel_process_startup(a1, a2, v8, v6, v7);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v9 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v10);
  }
  while ( !v9 );
  return v9;
}
// 9460: using guessed type __int64  _libssh2_channel_process_startup(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000015946) ----------------------------------------------------
__int64  libssh2_channel_set_blocking(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  if ( a1 )
    result = _libssh2_session_set_blocking(*(_QWORD *)(a1 + 96), a2);
  return result;
}
// 98D0: using guessed type __int64  _libssh2_session_set_blocking(_QWORD, _QWORD);



//----- (0000000000015FF0) ----------------------------------------------------
signed __int64  _libssh2_channel_receive_window_adjust(__int64 a1, unsigned int a2, unsigned __int8 a3)
{
  signed __int64 result; // rax
  unsigned __int8 v4; // [rsp+Ch] [rbp-34h]
  unsigned int v5; // [rsp+28h] [rbp-18h]
  int v6; // [rsp+2Ch] [rbp-14h]
  time_t v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v8 = __readfsqword(0x28u);
  if ( !a1 )
    return -39LL;
  v7 = time(0LL);
  do
  {
    v6 = _libssh2_channel_receive_window_adjust(a1, a2, v4);
    if ( v6 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v6 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v7);
  }
  while ( !v6 );
  if ( v6 )
    result = v6;
  else
    result = v5;
  return result;
}
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);



//----- (0000000000015974) ----------------------------------------------------
__int64  libssh2_channel_flush(__int64 a1, int a2)
{
  __int64 v3; // ST38_8
  char v4; // [rsp+1Fh] [rbp-21h]
  int v5; // [rsp+20h] [rbp-20h]
  __int64 v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]

  if ( !*(_DWORD *)(a1 + 568) )
  {
    v6 = _libssh2_list_first(*(_QWORD *)(a1 + 96) + 496LL);
    *(_QWORD *)(a1 + 576) = 0LL;
    *(_QWORD *)(a1 + 584) = 0LL;
    while ( v6 )
    {
      v7 = _libssh2_list_next(v6);
      if ( *(_QWORD *)(v6 + 32) )
      {
        v4 = **(_BYTE **)(v6 + 24);
        if ( (v4 == 94 || v4 == 95)
          && *(_QWORD *)(v6 + 32) > 4uLL
          && (unsigned int)_libssh2_ntohu32(*(_QWORD *)(v6 + 24) + 1LL) == *(_DWORD *)(a1 + 48) )
        {
          if ( v4 == 94 )
          {
            v5 = 0;
          }
          else
          {
            if ( *(_QWORD *)(v6 + 32) <= 8uLL )
            {
              *(_DWORD *)(a1 + 568) = 0;
              return _libssh2_error(*(_QWORD *)(a1 + 96), 4294967282LL, "Unexpected packet length");
            }
            v5 = _libssh2_ntohu32(*(_QWORD *)(v6 + 24) + 5LL);
          }
          if ( a2 == -2 || v4 == 95 && (a2 == -1 || a2 == v5) || v4 == 94 && !a2 )
          {
            v3 = *(_QWORD *)(v6 + 32) - *(_QWORD *)(v6 + 40);
            *(_QWORD *)(a1 + 576) = *(_QWORD *)(a1 + 576) + *(_QWORD *)(v6 + 32) - 13LL;
            *(_QWORD *)(a1 + 584) += v3;
            (*(void ( **)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 96) + 24LL))(
              *(_QWORD *)(v6 + 24),
              *(_QWORD *)(a1 + 96));
            _libssh2_list_remove(v6);
            (*(void ( **)(__int64, _QWORD))(*(_QWORD *)(a1 + 96) + 24LL))(v6, *(_QWORD *)(a1 + 96));
          }
        }
        v6 = v7;
      }
      else
      {
        v6 = v7;
      }
    }
    *(_DWORD *)(a1 + 568) = 2;
  }
  *(_DWORD *)(a1 + 92) -= *(_QWORD *)(a1 + 584);
  *(_DWORD *)(a1 + 76) -= *(_QWORD *)(a1 + 584);
  unsigned __int8 tmp = 1;
  if ( *(_QWORD *)(a1 + 576)
    && _libssh2_channel_receive_window_adjust(a1, (unsigned int) a2, tmp) == -37 )
  {
    return 4294967259LL;
  }
  *(_DWORD *)(a1 + 568) = 0;
  return *(_QWORD *)(a1 + 584);
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (0000000000015C49) ----------------------------------------------------
signed __int64  libssh2_channel_flush_ex(__int64 a1, unsigned int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v4 = time(0LL);
  do
  {
    v3 = _libssh2_channel_flush(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v3 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v4);
  }
  while ( !v3 );
  return v3;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);
// 98F0: using guessed type __int64  _libssh2_channel_flush(_QWORD, _QWORD);

//----- (0000000000015CC5) ----------------------------------------------------
__int64  libssh2_channel_get_exit_status(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(unsigned int *)(a1 + 36);
  else
    result = 0LL;
  return result;
}

//----- (0000000000015CE4) ----------------------------------------------------
__int64  libssh2_channel_get_exit_signal(__int64 a1, void **a2, size_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  _QWORD *v8; // [rsp+0h] [rbp-40h]
  _QWORD *v9; // [rsp+8h] [rbp-38h]
  _QWORD *v10; // [rsp+10h] [rbp-30h]
  size_t *v11; // [rsp+18h] [rbp-28h]
  size_t n; // [rsp+30h] [rbp-10h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v8 = a6;
  if ( a1 )
  {
    v13 = *(_QWORD *)(a1 + 96);
    if ( *(_QWORD *)(a1 + 40) )
    {
      n = strlen(*(const char **)(a1 + 40));
      if ( a2 )
      {
        *a2 = (void *)(*(__int64 ( **)(size_t, __int64))(v13 + 8))(n + 1, v13);
        if ( !*a2 )
          return _libssh2_error(v13, 4294967290LL, "Unable to allocate memory for signal name");
        memcpy(*a2, *(const void **)(a1 + 40), n);
        *((_BYTE *)*a2 + n) = 0;
      }
      if ( v11 )
        *v11 = n;
    }
    else
    {
      if ( a2 )
        *a2 = 0LL;
      if ( a3 )
        *a3 = 0LL;
    }
    if ( v10 )
      *v10 = 0LL;
    if ( v9 )
      *v9 = 0LL;
    if ( v8 )
      *v8 = 0LL;
    if ( a7 )
      *a7 = 0LL;
  }
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000015E54) ----------------------------------------------------
__int64  libssh2_channel_receive_window_adjust(__int64 a1, unsigned int a2, char a3, _DWORD *a4)
{
  __int64 result; // rax
  unsigned int v5; // [rsp+14h] [rbp-1Ch]
  int v6; // [rsp+2Ch] [rbp-4h]

  v5 = a2;
  if ( a4 )
    *a4 = *(_DWORD *)(a1 + 76);
  if ( !*(_DWORD *)(a1 + 592) )
  {
    if ( !a3 && *(_DWORD *)(a1 + 88) + a2 <= 0x3FF )
    {
      *(_DWORD *)(a1 + 88) += a2;
      return 0LL;
    }
    if ( !a2 && !*(_DWORD *)(a1 + 88) )
      return 0LL;
    v5 = *(_DWORD *)(a1 + 88) + a2;
    *(_DWORD *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 596) = 93;
    _libssh2_htonu32(a1 + 597, *(unsigned int *)(a1 + 68));
    _libssh2_htonu32(a1 + 601, v5);
    *(_DWORD *)(a1 + 592) = 2;
  }
  v6 = _libssh2_transport_send(*(_QWORD *)(a1 + 96), a1 + 596, 9LL, 0LL, 0LL);
  if ( v6 == -37 )
  {
    _libssh2_error(*(_QWORD *)(a1 + 96), 4294967259LL, "Would block sending window adjust");
    result = 4294967259LL;
  }
  else if ( v6 )
  {
    *(_DWORD *)(a1 + 88) = v5;
    result = _libssh2_error(
               *(_QWORD *)(a1 + 96),
               4294967289LL,
               "Unable to send transfer-window adjustment packet, deferring");
  }
  else
  {
    *(_DWORD *)(a1 + 76) += v5;
    *(_DWORD *)(a1 + 592) = 0;
    result = 0LL;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);


//----- (00000000000160AF) ----------------------------------------------------
signed __int64  libssh2_channel_receive_window_adjust2(__int64 a1, unsigned int a2, unsigned __int8 a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  unsigned __int8 v6; // [rsp+Ch] [rbp-24h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v5 = a4;
  v6 = a3;
  if ( !a1 )
    return 4294967257LL;
  v8 = time(0LL);
  do
  {
    v7 = _libssh2_channel_receive_window_adjust(a1, a2, v6);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v7 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v8);
  }
  while ( !v7 );
  return v7;
}
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000001613E) ----------------------------------------------------
signed __int64  libssh2_channel_extended_data(__int64 a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 680) )
  {
    *(_BYTE *)(a1 + 86) = a2;
    *(_DWORD *)(a1 + 680) = 2;
  }
  if ( !*(_DWORD *)(a1 + 680) && a2 == 1 && (unsigned int)_libssh2_channel_flush(a1, 0xFFFFFFFFLL) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 680) = 0;
  return 0LL;
}
// 98F0: using guessed type __int64  _libssh2_channel_flush(_QWORD, _QWORD);

//----- (00000000000161BD) ----------------------------------------------------
signed __int64  libssh2_channel_handle_extended_data2(__int64 a1, unsigned int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v4 = time(0LL);
  do
  {
    v3 = _libssh2_channel_extended_data(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v3 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v4);
  }
  while ( !v3 );
  return v3;
}
// 94E0: using guessed type __int64  _libssh2_channel_extended_data(_QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000016239) ----------------------------------------------------
__int64  libssh2_channel_handle_extended_data(__int64 a1, unsigned int a2)
{
  return libssh2_channel_handle_extended_data2(a1, a2);
}
// 9240: using guessed type __int64  libssh2_channel_handle_extended_data2(_QWORD, _QWORD);

//----- (000000000001625C) ----------------------------------------------------
unsigned __int64  libssh2_channel_read(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 result; // rax
  unsigned __int64 v5; // [rsp+0h] [rbp-60h]
  __int64 v6; // [rsp+8h] [rbp-58h]
  signed int v7; // [rsp+24h] [rbp-3Ch]
  unsigned int v8; // [rsp+28h] [rbp-38h]
  int v9; // [rsp+2Ch] [rbp-34h]
  signed int v10; // [rsp+2Ch] [rbp-34h]
  unsigned __int64 v11; // [rsp+30h] [rbp-30h]
  size_t n; // [rsp+38h] [rbp-28h]
  _QWORD *v13; // [rsp+40h] [rbp-20h]
  __int64 v14; // [rsp+48h] [rbp-18h]
  __int64 v15; // [rsp+58h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v14 = *(_QWORD *)(a1 + 96);
  v11 = 0LL;
  if ( *(_DWORD *)(a1 + 608) == 11 || *(unsigned int *)(a1 + 76) < (unsigned int)(3 * (*(_DWORD *)(a1 + 72) >> 2)) + a4 )
  {
    v8 = *(_DWORD *)(a1 + 72) + a4 - *(_DWORD *)(a1 + 76);
    if ( v8 <= 0x3FF )
      v8 = 1024;
    *(_DWORD *)(a1 + 608) = 11;
    v9 = _libssh2_channel_receive_window_adjust(a1, v8, 0LL);
    if ( v9 )
      return v9;
    *(_DWORD *)(a1 + 608) = 0;
  }
  do
    v10 = _libssh2_transport_read(v14);
  while ( v10 > 0 );
  if ( v10 < 0 && v10 != -37 )
    return (signed int)_libssh2_error(v14, (unsigned int)v10, "transport read");
  v13 = (_QWORD *)_libssh2_list_first(v14 + 496);
  while ( v13 && v11 < v5 )
  {
    v15 = _libssh2_list_next(v13);
    if ( v13[4] > 4uLL )
    {
      *(_DWORD *)(a1 + 612) = _libssh2_ntohu32(v13[3] + 1LL);
      if ( a2
        && *(_BYTE *)v13[3] == 95
        && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 612)
        && v13[4] > 8uLL
        && a2 == (unsigned int)_libssh2_ntohu32(v13[3] + 5LL)
        || !a2 && *(_BYTE *)v13[3] == 94 && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 612)
        || !a2 && *(_BYTE *)v13[3] == 95 && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 612) && *(_BYTE *)(a1 + 86) == 2 )
      {
        n = v5 - v11;
        v7 = 0;
        if ( v5 - v11 >= v13[4] - v13[5] )
        {
          n = v13[4] - v13[5];
          v7 = 1;
        }
        memcpy((void *)(v6 + v11), (const void *)(v13[3] + v13[5]), n);
        v13[5] += n;
        v11 += n;
        if ( v7 )
        {
          _libssh2_list_remove(v13);
          (*(void ( **)(_QWORD, __int64))(v14 + 24))(v13[3], v14);
          (*(void ( **)(_QWORD *, __int64))(v14 + 24))(v13, v14);
        }
      }
      v13 = (_QWORD *)v15;
    }
    else
    {
      v13 = (_QWORD *)v15;
    }
  }
  if ( v11 )
  {
    *(_DWORD *)(a1 + 92) -= v11;
    *(_DWORD *)(a1 + 76) -= v11;
    result = v11;
  }
  else if ( *(_BYTE *)(a1 + 85) || *(_BYTE *)(a1 + 84) )
  {
    result = 0LL;
  }
  else if ( v10 == -37 )
  {
    result = (signed int)_libssh2_error(v14, 4294967259LL, "would block");
  }
  else
  {
    result = 0LL;
  }
  return result;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);

//----- (0000000000016623) ----------------------------------------------------
signed __int64  libssh2_channel_read_ex(__int64 a1, unsigned int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  int v7; // [rsp+24h] [rbp-1Ch]
  time_t v8; // [rsp+30h] [rbp-10h]
  time_t v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( !a1 )
    return -39LL;
  if ( a4 > libssh2_channel_window_read_ex(a1, 0LL, 0LL) )
  {
    v8 = time(0LL);
    while ( (unsigned int)_libssh2_channel_receive_window_adjust(a1, (unsigned int)v5, 1LL) == -37
         && *(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL)
         && !(unsigned int)_libssh2_wait_socket(*(_QWORD *)(a1 + 96), v8) )
      ;
  }
  v9 = time(0LL);
  do
  {
    v7 = _libssh2_channel_read(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v7 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v9);
  }
  while ( !v7 );
  return v7;
}
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9140: using guessed type __int64  libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);
// 97F0: using guessed type __int64  _libssh2_channel_read(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001673D) ----------------------------------------------------
__int64  libssh2_channel_packet_data_len(__int64 a1, int a2)
{
  int v3; // [rsp+14h] [rbp-1Ch]
  _QWORD *v4; // [rsp+18h] [rbp-18h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = (_QWORD *)_libssh2_list_first(*(_QWORD *)(a1 + 96) + 496LL);
  if ( !v4 )
    return 0LL;
  while ( v4 )
  {
    v5 = _libssh2_list_next(v4);
    if ( v4[4] > 4uLL )
    {
      v3 = _libssh2_ntohu32(v4[3] + 1LL);
      if ( a2
        && *(_BYTE *)v4[3] == 95
        && v3 == *(_DWORD *)(a1 + 48)
        && v4[4] > 8uLL
        && a2 == (unsigned int)_libssh2_ntohu32(v4[3] + 5LL)
        || !a2 && *(_BYTE *)v4[3] == 94 && v3 == *(_DWORD *)(a1 + 48)
        || !a2 && *(_BYTE *)v4[3] == 95 && v3 == *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 86) == 2 )
      {
        return v4[4] - v4[5];
      }
      v4 = (_QWORD *)v5;
    }
    else
    {
      v4 = (_QWORD *)v5;
    }
  }
  return 0LL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (000000000001688D) ----------------------------------------------------
signed __int64  libssh2_channel_write(__int64 a1, unsigned int a2, __int64 a3, unsigned __int64 a4)
{
  signed __int64 result; // rax
  char v5; // cl
  char *v6; // rax
  signed __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+8h] [rbp-48h]
  signed int v9; // [rsp+2Ch] [rbp-24h]
  unsigned int v10; // [rsp+2Ch] [rbp-24h]
  char *v11; // [rsp+30h] [rbp-20h]
  __int64 v12; // [rsp+38h] [rbp-18h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  unsigned __int64 v14; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v14 = __readfsqword(0x28u);
  v12 = *(_QWORD *)(a1 + 96);
  v13 = 0LL;
  if ( a4 > 0x7FBC )
    v7 = 32700LL;
  if ( !*(_DWORD *)(a1 + 616) )
  {
    v11 = (char *)(a1 + 620);
    if ( *(_BYTE *)(a1 + 64) )
      return (signed int)_libssh2_error(*(_QWORD *)(a1 + 96), 4294967270LL, "We've already closed this channel");
    if ( *(_BYTE *)(a1 + 65) )
      return (signed int)_libssh2_error(
                           *(_QWORD *)(a1 + 96),
                           4294967269LL,
                           "EOF has already been received, data might be ignored");
    do
      v9 = _libssh2_transport_read(v12);
    while ( v9 > 0 );
    if ( v9 < 0 && v9 != -37 )
      return (signed int)_libssh2_error(*(_QWORD *)(a1 + 96), (unsigned int)v9, "Failure while draining incoming flow");
    if ( !*(_DWORD *)(a1 + 56) )
    {
      *(_DWORD *)(v12 + 560) = 1;
      if ( v9 == -37 )
        result = -37LL;
      else
        result = 0LL;
      return result;
    }
    *(_QWORD *)(a1 + 648) = v7;
    if ( a2 )
      v5 = 95;
    else
      v5 = 94;
    v6 = v11++;
    *v6 = v5;
    _libssh2_store_u32(&v11, *(unsigned int *)(a1 + 68));
    if ( a2 )
      _libssh2_store_u32(&v11, a2);
    if ( *(_QWORD *)(a1 + 648) > (unsigned __int64)*(unsigned int *)(a1 + 56) )
      *(_QWORD *)(a1 + 648) = *(unsigned int *)(a1 + 56);
    if ( *(_QWORD *)(a1 + 648) > (unsigned __int64)*(unsigned int *)(a1 + 60) )
      *(_QWORD *)(a1 + 648) = *(unsigned int *)(a1 + 60);
    _libssh2_store_u32(&v11, (unsigned int)*(_QWORD *)(a1 + 648));
    *(_QWORD *)(a1 + 640) = &v11[-a1 - 620];
    *(_DWORD *)(a1 + 616) = 2;
  }
  if ( *(_DWORD *)(a1 + 616) != 2 )
    return -34LL;
  v10 = _libssh2_transport_send(v12, a1 + 620, *(_QWORD *)(a1 + 640), v8, *(_QWORD *)(a1 + 648));
  if ( v10 == -37 )
    return (signed int)_libssh2_error(v12, 4294967259LL, "Unable to send channel data");
  if ( v10 )
  {
    *(_DWORD *)(a1 + 616) = 0;
    result = (signed int)_libssh2_error(v12, v10, "Unable to send channel data");
  }
  else
  {
    *(_DWORD *)(a1 + 56) -= *(_QWORD *)(a1 + 648);
    v13 += *(_QWORD *)(a1 + 648);
    *(_DWORD *)(a1 + 616) = 0;
    result = v13;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000016BD8) ----------------------------------------------------
signed __int64  libssh2_channel_write_ex(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  int v5; // eax
  __int64 v6; // [rsp+0h] [rbp-30h]
  __int64 v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+20h] [rbp-10h]
  time_t v9; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  if ( !a1 )
    return -39LL;
  v9 = time(0LL);
  do
  {
    v8 = _libssh2_channel_write(a1, a2, v7, v6);
    if ( v8 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v5 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v9);
    v8 = v5;
  }
  while ( !v5 );
  return v8;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000016C6B) ----------------------------------------------------
__int64  sub_16C6B(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+14h] [rbp-1Ch]
  __int64 v3; // [rsp+18h] [rbp-18h]
  char v4; // [rsp+23h] [rbp-Dh]
  int v5; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v3 = *(_QWORD *)(a1 + 96);
  v4 = 96;
  _libssh2_htonu32(&v5, *(unsigned int *)(a1 + 68));
  v2 = _libssh2_transport_send(v3, &v4, 5LL, 0LL, 0LL);
  if ( v2 == -37 )
  {
    _libssh2_error(v3, 4294967259LL, "Would block sending EOF");
    result = 4294967259LL;
  }
  else if ( v2 )
  {
    result = _libssh2_error(v3, 4294967289LL, "Unable to send EOF on channel");
  }
  else
  {
    *(_BYTE *)(a1 + 65) = 1;
    result = 0LL;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (0000000000016D38) ----------------------------------------------------
signed __int64  libssh2_channel_send_eof(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_16C6B(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000016DAC) ----------------------------------------------------
signed __int64  libssh2_channel_eof(__int64 a1)
{
  int v2; // ebx
  __int64 v3; // [rsp+18h] [rbp-28h]
  __int64 v4; // [rsp+28h] [rbp-18h]

  if ( !a1 )
    return 4294967257LL;
  v3 = _libssh2_list_first(*(_QWORD *)(a1 + 96) + 496LL);
  while ( v3 )
  {
    v4 = _libssh2_list_next(v3);
    if ( *(_QWORD *)(v3 + 32) )
    {
      if ( (**(_BYTE **)(v3 + 24) == 94 || **(_BYTE **)(v3 + 24) == 95) && *(_QWORD *)(v3 + 32) > 4uLL )
      {
        v2 = *(_DWORD *)(a1 + 48);
        if ( v2 == (unsigned int)_libssh2_ntohu32(*(_QWORD *)(v3 + 24) + 1LL) )
          return 0LL;
      }
      v3 = v4;
    }
    else
    {
      v3 = v4;
    }
  }
  return (unsigned int)*(char *)(a1 + 85);
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (0000000000016E8F) ----------------------------------------------------
__int64  sub_16E8F(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 96);
  if ( !*(_DWORD *)(a1 + 668) )
    *(_DWORD *)(a1 + 668) = 2;
  while ( !*(_BYTE *)(a1 + 85) )
  {
    if ( *(_DWORD *)(a1 + 76) == *(_DWORD *)(a1 + 92) && *(_DWORD *)(v3 + 148) )
      return _libssh2_error(v3, 4294967249LL, "Receiving channel window has been exhausted");
    v2 = _libssh2_transport_read(v3);
    if ( v2 == -37 )
      return 4294967259LL;
    if ( (v2 & 0x80000000) != 0 )
    {
      *(_DWORD *)(a1 + 668) = 0;
      return _libssh2_error(v3, v2, "_libssh2_transport_read() bailed out!");
    }
  }
  *(_DWORD *)(a1 + 668) = 0;
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);

//----- (0000000000016F6B) ----------------------------------------------------
signed __int64  libssh2_channel_wait_eof(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_16E8F(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000171D4) ----------------------------------------------------
signed __int64  libssh2_channel_close(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = _libssh2_channel_close(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);
// 9950: using guessed type __int64  _libssh2_channel_close(_QWORD);

//----- (0000000000017248) ----------------------------------------------------
__int64  sub_17248(__int64 a1)
{
  signed int v2; // [rsp+14h] [rbp-Ch]
  __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 96);
  if ( !*(_BYTE *)(a1 + 85) )
    return _libssh2_error(v3, 4294967262LL, "libssh2_channel_wait_closed() invoked when channel is not in EOF state");
  if ( !*(_DWORD *)(a1 + 672) )
    *(_DWORD *)(a1 + 672) = 2;
  if ( !*(_BYTE *)(a1 + 84) )
  {
    do
      v2 = _libssh2_transport_read(v3);
    while ( !*(_BYTE *)(a1 + 84) && v2 > 0 );
    if ( v2 < 0 )
      return (unsigned int)v2;
  }
  *(_DWORD *)(a1 + 672) = 0;
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);

//----- (00000000000172F2) ----------------------------------------------------
signed __int64  libssh2_channel_wait_closed(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_17248(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000175C9) ----------------------------------------------------
signed __int64  libssh2_channel_free(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = _libssh2_channel_free(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(a1 + 96), v3);
  }
  while ( !v2 );
  return v2;
}
// 8CC0: using guessed type __int64  _libssh2_channel_free(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000001763D) ----------------------------------------------------
__int64  libssh2_channel_window_read_ex(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  char v4; // [rsp+27h] [rbp-19h]
  __int64 v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+30h] [rbp-10h]
  __int64 v7; // [rsp+38h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  if ( a3 )
    *a3 = *(unsigned int *)(a1 + 72);
  if ( a2 )
  {
    v5 = 0LL;
    v6 = _libssh2_list_first(*(_QWORD *)(a1 + 96) + 496LL);
    while ( v6 )
    {
      v7 = _libssh2_list_next(v6);
      if ( *(_QWORD *)(v6 + 32) )
      {
        v4 = **(_BYTE **)(v6 + 24);
        if ( (v4 == 94 || v4 == 95)
          && *(_QWORD *)(v6 + 32) > 4uLL
          && (unsigned int)_libssh2_ntohu32(*(_QWORD *)(v6 + 24) + 1LL) == *(_DWORD *)(a1 + 48) )
        {
          v5 += *(_QWORD *)(v6 + 32) - *(_QWORD *)(v6 + 40);
        }
        v6 = v7;
      }
      else
      {
        v6 = v7;
      }
    }
    *a2 = v5;
  }
  return *(unsigned int *)(a1 + 76);
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (000000000001775E) ----------------------------------------------------
__int64  libssh2_channel_window_write_ex(__int64 a1, _QWORD *a2)
{
  if ( !a1 )
    return 0LL;
  if ( a2 )
    *a2 = *(unsigned int *)(a1 + 52);
  return *(unsigned int *)(a1 + 56);
}

//----- (000000000001779A) ----------------------------------------------------
__int64 sub_1779A()
{
  return 0LL;
}

//----- (00000000000177BD) ----------------------------------------------------
__int64  sub_177BD(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  *a2 = a5;
  *a3 = a6;
  return 0LL;
}

//----- (00000000000177F6) ----------------------------------------------------
char *** libssh2_comp_methods(__int64 a1)
{
  char ***result; // rax

  if ( *(_DWORD *)(a1 + 112) )
    result = &off_250960;
  else
    result = &off_250970;
  return result;
}
// 250960: using guessed type char **off_250960;
// 250970: using guessed type char **off_250970;

//----- (000000000001781B) ----------------------------------------------------
signed __int64  sub_1781B(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8)
{
  signed __int64 result; // rax
  _DWORD *v9; // [rsp+0h] [rbp-40h]
  __int64 v10; // [rsp+8h] [rbp-38h]
  _DWORD *v11; // [rsp+10h] [rbp-30h]
  __int64 v12; // [rsp+18h] [rbp-28h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v13 = (*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(24LL, a1);
  if ( !v13 )
    return 4294967290LL;
  *(_DWORD *)v13 = a7;
  *(_QWORD *)(v13 + 8) = *(_QWORD *)(a2 + 64);
  if ( (unsigned int)_libssh2_cipher_init(v13 + 16, *(_QWORD *)(v13 + 8), v12, v10, a7) )
  {
    (*(void ( **)(__int64, __int64))(a1 + 24))(v13, a1);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    *a8 = v13;
    *v11 = 1;
    *v9 = 1;
    result = 0LL;
  }
  return result;
}
// 8950: using guessed type __int64  _libssh2_cipher_init(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000178EC) ----------------------------------------------------
__int64  sub_178EC(__int64 a1, __int64 a2, __int64 a3, unsigned int **a4)
{
  return _libssh2_cipher_crypt(*a4 + 4, *((_QWORD *)*a4 + 1), **a4, a2, a3);
}
// 9760: using guessed type __int64  _libssh2_cipher_crypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001793A) ----------------------------------------------------
__int64  sub_1793A(__int64 a1, _QWORD *a2)
{
  if ( a2 && *a2 )
  {
    EVP_CIPHER_CTX_free(*(_QWORD *)(*a2 + 16LL));
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
    *a2 = 0LL;
  }
  return 0LL;
}
// 9610: using guessed type __int64  EVP_CIPHER_CTX_free(_QWORD);

//----- (00000000000179A5) ----------------------------------------------------
__int64  sub_179A5(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5, _DWORD *a6, unsigned int a7, __int64 *a8)
{
  unsigned int v9; // [rsp+4Ch] [rbp-24h]
  signed __int64 i; // [rsp+50h] [rbp-20h]
  unsigned int *v11; // [rsp+58h] [rbp-18h]
  char v12; // [rsp+60h] [rbp-10h]
  unsigned __int64 v13; // [rsp+68h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = sub_1781B(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( !v9 )
  {
    v11 = (unsigned int *)*a8;
    for ( i = 1536LL; i; i -= 8LL )
      _libssh2_cipher_crypt(v11 + 4, *((_QWORD *)v11 + 1), *v11, &v12, *(signed int *)(a2 + 16));
  }
  return v9;
}
// 9760: using guessed type __int64  _libssh2_cipher_crypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017A79) ----------------------------------------------------
char **libssh2_crypt_methods()
{
  return off_250980;
}
// 250980: using guessed type char *off_250980[3];

//----- (0000000000017A86) ----------------------------------------------------
__int64  libssh2_init(int a1)
{
  if ( !dword_250AFC && !(a1 & 1) )
    _libssh2_openssl_crypto_init();
  ++dword_250AFC;
  dword_250B00 |= a1;
  return 0LL;
}
// 9730: using guessed type __int64 _libssh2_openssl_crypto_init(void);
// 250AFC: using guessed type int dword_250AFC;
// 250B00: using guessed type int dword_250B00;

//----- (0000000000017ACF) ----------------------------------------------------
__int64 libssh2_exit()
{
  __int64 result; // rax

  result = (unsigned int)dword_250AFC;
  if ( dword_250AFC )
  {
    result = (unsigned int)--dword_250AFC;
    if ( !dword_250AFC )
    {
      result = dword_250B00 & 1;
      if ( !(dword_250B00 & 1) )
        result = _libssh2_openssl_crypto_exit();
    }
  }
  return result;
}
// 94C0: using guessed type __int64 _libssh2_openssl_crypto_exit(void);
// 250AFC: using guessed type int dword_250AFC;
// 250B00: using guessed type int dword_250B00;

//----- (0000000000017B11) ----------------------------------------------------
__int64 libssh2_init_if_needed()
{
  __int64 result; // rax

  result = (unsigned int)dword_250AFC;
  if ( !dword_250AFC )
    result = libssh2_init(0LL);
  return result;
}
// 9690: using guessed type __int64  libssh2_init(_QWORD);
// 250AFC: using guessed type int dword_250AFC;

//----- (0000000000017B2C) ----------------------------------------------------
signed __int64  sub_17B2C(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-70h]
  unsigned __int64 v6; // [rsp+8h] [rbp-68h]
  __int64 v7; // [rsp+28h] [rbp-48h]
  __int64 v8; // [rsp+30h] [rbp-40h]
  __int64 v9; // [rsp+38h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-30h]
  __int64 v11; // [rsp+48h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-20h]
  __int64 v13; // [rsp+58h] [rbp-18h]
  unsigned __int64 v14; // [rsp+60h] [rbp-10h]
  unsigned __int64 v15; // [rsp+68h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v15 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_17F3B(a1, a4);
    *v5 = 0LL;
  }
  if ( v6 <= 0x12 )
    return 0xFFFFFFFFLL;
  v12 = a2;
  v13 = a2;
  v14 = v6;
  if ( (unsigned int)_libssh2_match_string(&v12, "ssh-rsa") )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v12, &v8, &v10) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v12, &v9, &v11) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_rsa_new(&v7, v8, v10, v9, v11, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}
// 9420: using guessed type __int64  _libssh2_match_string(_QWORD, _QWORD);
// 9450: using guessed type __int64  _libssh2_rsa_new(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (0000000000017C82) ----------------------------------------------------
signed __int64  sub_17C82(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_17F3B(a1, a4);
    *v5 = 0LL;
  }
  if ( (unsigned int)_libssh2_rsa_new_private(&v7, a1, a2, v6) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}
// 9120: using guessed type __int64  _libssh2_rsa_new_private(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017D21) ----------------------------------------------------
signed __int64  sub_17D21(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = __readfsqword(0x28u);
  if ( *a5 )
  {
    sub_17F3B(a1, a5);
    *v6 = 0LL;
  }
  if ( (unsigned int)_libssh2_rsa_new_private_frommemory(&v9, a1, a2, v8, v7) )
    return 0xFFFFFFFFLL;
  *v6 = v9;
  return 0LL;
}
// 93E0: using guessed type __int64  _libssh2_rsa_new_private_frommemory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017DCB) ----------------------------------------------------
__int64  sub_17DCB(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  __int64 result; // rax

  if ( a3 > 0xE )
    result = _libssh2_rsa_sha1_verify(*a6, a2 + 15, a3 - 15, a4, a5);
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 89B0: using guessed type __int64  _libssh2_rsa_sha1_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017E2F) ----------------------------------------------------
signed __int64  sub_17E2F(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 *a6)
{
  signed __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-68h]
  int v8; // [rsp+14h] [rbp-5Ch]
  __int64 v9; // [rsp+18h] [rbp-58h]
  int i; // [rsp+38h] [rbp-38h]
  __int64 v11; // [rsp+40h] [rbp-30h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  char v13; // [rsp+50h] [rbp-20h]
  unsigned __int64 v14; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  v12 = *a6;
  _libssh2_sha1_init(&v11);
  for ( i = 0; i < v8; ++i )
    EVP_DigestUpdate(v11, *(_QWORD *)(16LL * i + v7), *(_QWORD *)(16LL * i + v7 + 8));
  EVP_DigestFinal(v11, &v13, 0LL);
  EVP_MD_CTX_free(v11);
  if ( (unsigned int)_libssh2_rsa_sha1_sign(a1, v12, &v13, 20LL, a2, v9) )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9750: using guessed type __int64  _libssh2_rsa_sha1_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9790: using guessed type __int64  _libssh2_sha1_init(_QWORD);

//----- (0000000000017F3B) ----------------------------------------------------
__int64  sub_17F3B(__int64 a1, _QWORD *a2)
{
  RSA_free(*a2);
  *a2 = 0LL;
  return 0LL;
}
// 97B0: using guessed type __int64  RSA_free(_QWORD);

//----- (0000000000017F74) ----------------------------------------------------
signed __int64  sub_17F74(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-90h]
  unsigned __int64 v6; // [rsp+8h] [rbp-88h]
  __int64 v7; // [rsp+28h] [rbp-68h]
  __int64 v8; // [rsp+30h] [rbp-60h]
  __int64 v9; // [rsp+38h] [rbp-58h]
  __int64 v10; // [rsp+40h] [rbp-50h]
  __int64 v11; // [rsp+48h] [rbp-48h]
  __int64 v12; // [rsp+50h] [rbp-40h]
  __int64 v13; // [rsp+58h] [rbp-38h]
  __int64 v14; // [rsp+60h] [rbp-30h]
  __int64 v15; // [rsp+68h] [rbp-28h]
  __int64 v16; // [rsp+70h] [rbp-20h]
  __int64 v17; // [rsp+78h] [rbp-18h]
  unsigned __int64 v18; // [rsp+80h] [rbp-10h]
  unsigned __int64 v19; // [rsp+88h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v19 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_1843E(a1, a4);
    *v5 = 0LL;
  }
  if ( v6 <= 0x1A )
    return 0xFFFFFFFFLL;
  v16 = a2;
  v17 = a2;
  v18 = v6;
  if ( (unsigned int)_libssh2_match_string(&v16, "ssh-dss") )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v16, &v8, &v12) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v16, &v9, &v13) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v16, &v10, &v14) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v16, &v11, &v15) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_dsa_new(&v7, v8, v12, v9, v13, v10, v14, v11, v15, 0LL, 0LL) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}
// 8D80: using guessed type __int64  _libssh2_dsa_new(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9420: using guessed type __int64  _libssh2_match_string(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000001812F) ----------------------------------------------------
signed __int64  sub_1812F(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  if ( *a4 )
  {
    sub_1843E(a1, a4);
    *v5 = 0LL;
  }
  if ( (unsigned int)_libssh2_dsa_new_private(&v7, a1, a2, v6) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}
// 9010: using guessed type __int64  _libssh2_dsa_new_private(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000181CE) ----------------------------------------------------
signed __int64  sub_181CE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = __readfsqword(0x28u);
  if ( *a5 )
  {
    sub_1843E(a1, a5);
    *v6 = 0LL;
  }
  if ( (unsigned int)_libssh2_dsa_new_private_frommemory(&v9, a1, a2, v8, v7) )
    return 0xFFFFFFFFLL;
  *v6 = v9;
  return 0LL;
}
// 96E0: using guessed type __int64  _libssh2_dsa_new_private_frommemory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018278) ----------------------------------------------------
__int64  sub_18278(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  __int64 result; // rax

  if ( a3 == 55 )
    result = _libssh2_dsa_sha1_verify(*a6, a2 + 15, a4, a5);
  else
    result = _libssh2_error(a1, 4294967282LL, "Invalid DSS signature length");
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9A00: using guessed type __int64  _libssh2_dsa_sha1_verify(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000182E8) ----------------------------------------------------
signed __int64  sub_182E8(__int64 a1, _QWORD *a2, _QWORD *a3, int a4, __int64 a5, __int64 *a6)
{
  __int64 v7; // [rsp+8h] [rbp-68h]
  int v8; // [rsp+14h] [rbp-5Ch]
  _QWORD *v9; // [rsp+18h] [rbp-58h]
  int i; // [rsp+3Ch] [rbp-34h]
  __int64 v11; // [rsp+40h] [rbp-30h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  char v13; // [rsp+50h] [rbp-20h]
  unsigned __int64 v14; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v14 = __readfsqword(0x28u);
  v12 = *a6;
  *a2 = _libssh2_calloc(a1, 40LL);
  if ( !*a2 )
    return 0xFFFFFFFFLL;
  *v9 = 40LL;
  _libssh2_sha1_init(&v11);
  for ( i = 0; i < v8; ++i )
    EVP_DigestUpdate(v11, *(_QWORD *)(16LL * i + v7), *(_QWORD *)(16LL * i + v7 + 8));
  EVP_DigestFinal(v11, &v13, 0LL);
  EVP_MD_CTX_free(v11);
  if ( !(unsigned int)_libssh2_dsa_sha1_sign(v12, &v13, 20LL, *a2) )
    return 0LL;
  (*(void ( **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
  return 0xFFFFFFFFLL;
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 9590: using guessed type __int64  _libssh2_dsa_sha1_sign(_QWORD, _QWORD, _QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9790: using guessed type __int64  _libssh2_sha1_init(_QWORD);

//----- (000000000001843E) ----------------------------------------------------
__int64  sub_1843E(__int64 a1, _QWORD *a2)
{
  DSA_free(*a2);
  *a2 = 0LL;
  return 0LL;
}
// 9480: using guessed type __int64  DSA_free(_QWORD);

//----- (0000000000018477) ----------------------------------------------------
signed __int64  sub_18477(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-80h]
  unsigned __int64 v6; // [rsp+8h] [rbp-78h]
  unsigned int v7; // [rsp+2Ch] [rbp-54h]
  __int64 v8; // [rsp+30h] [rbp-50h]
  char *s1; // [rsp+38h] [rbp-48h]
  char *v10; // [rsp+40h] [rbp-40h]
  __int64 v11; // [rsp+48h] [rbp-38h]
  __int64 v12; // [rsp+50h] [rbp-30h]
  __int64 v13; // [rsp+58h] [rbp-28h]
  __int64 v14; // [rsp+60h] [rbp-20h]
  __int64 v15; // [rsp+68h] [rbp-18h]
  unsigned __int64 v16; // [rsp+70h] [rbp-10h]
  unsigned __int64 v17; // [rsp+78h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v17 = __readfsqword(0x28u);
  v8 = 0LL;
  if ( a4 && *a4 )
  {
    sub_18C7B(a1, a4);
    *v5 = 0LL;
  }
  if ( v6 <= 0x26 )
    return 0xFFFFFFFFLL;
  v14 = a2;
  v15 = a2;
  v16 = v6;
  if ( (unsigned int)_libssh2_get_string(&v14, &s1, &v13) || v13 != 19 )
    return 0xFFFFFFFFLL;
  if ( !strncmp(s1, "ecdsa-sha2-nistp256", 0x13uLL) )
  {
    v7 = 415;
  }
  else if ( !strncmp(s1, "ecdsa-sha2-nistp384", 0x13uLL) )
  {
    v7 = 715;
  }
  else
  {
    if ( strncmp(s1, "ecdsa-sha2-nistp521", 0x13uLL) )
      return 0xFFFFFFFFLL;
    v7 = 716;
  }
  if ( (unsigned int)_libssh2_get_string(&v14, &v10, &v13) || v13 != 8 )
    return 0xFFFFFFFFLL;
  if ( v7 == 415 && strncmp(v10, "nistp256", 8uLL) )
    return 0xFFFFFFFFLL;
  if ( v7 == 715 && strncmp(v10, "nistp384", 8uLL) )
    return 0xFFFFFFFFLL;
  if ( v7 == 716 && strncmp(v10, "nistp521", 8uLL) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v14, &v11, &v12) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_ecdsa_curve_name_with_octal_new(&v8, v11, v12, v7) )
    return 0xFFFFFFFFLL;
  if ( v5 )
    *v5 = v8;
  return 0LL;
}
// 8970: using guessed type __int64  _libssh2_ecdsa_curve_name_with_octal_new(_QWORD, _QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (00000000000186D2) ----------------------------------------------------
__int64  sub_186D2(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  unsigned int v7; // [rsp+2Ch] [rbp-14h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v9 = __readfsqword(0x28u);
  v8 = 0LL;
  if ( a4 && *a4 )
  {
    sub_18C7B(a1, a4);
    *v5 = 0LL;
  }
  v7 = _libssh2_ecdsa_new_private(&v8, a1, a2, v6);
  if ( v5 )
    *v5 = v8;
  return v7;
}
// 90A0: using guessed type __int64  _libssh2_ecdsa_new_private(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018778) ----------------------------------------------------
signed __int64  sub_18778(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = __readfsqword(0x28u);
  v9 = 0LL;
  if ( a5 && *a5 )
  {
    sub_18C7B(a1, a5);
    *v6 = 0LL;
  }
  if ( (unsigned int)_libssh2_ecdsa_new_private_frommemory(&v9, a1, a2, v8, v7) )
    return 0xFFFFFFFFLL;
  if ( v6 )
    *v6 = v9;
  return 0LL;
}
// 8EB0: using guessed type __int64  _libssh2_ecdsa_new_private_frommemory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018838) ----------------------------------------------------
__int64  sub_18838(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 *a6)
{
  __int64 v7; // [rsp+8h] [rbp-88h]
  __int64 v8; // [rsp+10h] [rbp-80h]
  unsigned int v9; // [rsp+34h] [rbp-5Ch]
  __int64 v10; // [rsp+38h] [rbp-58h]
  __int64 v11; // [rsp+40h] [rbp-50h]
  char v12; // [rsp+48h] [rbp-48h]
  __int64 v13; // [rsp+50h] [rbp-40h]
  __int64 v14; // [rsp+58h] [rbp-38h]
  __int64 v15; // [rsp+60h] [rbp-30h]
  __int64 v16; // [rsp+68h] [rbp-28h]
  __int64 v17; // [rsp+70h] [rbp-20h]
  __int64 v18; // [rsp+78h] [rbp-18h]
  unsigned __int64 v19; // [rsp+80h] [rbp-10h]
  unsigned __int64 v20; // [rsp+88h] [rbp-8h]

  v8 = a4;
  v7 = a5;
  v20 = __readfsqword(0x28u);
  v16 = *a6;
  if ( a3 <= 0x22 )
    return 0xFFFFFFFFLL;
  v17 = a2;
  v18 = a2;
  v19 = a3;
  if ( (unsigned int)_libssh2_get_string(&v17, &v12, &v15) || v15 != 19 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_u32(&v17, &v9) || v9 <= 7 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v17, &v10, &v13) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v17, &v11, &v14) )
    return 0xFFFFFFFFLL;
  return _libssh2_ecdsa_verify(v16, v10, v13, v11, v14, v8, v7);
}
// 8900: using guessed type __int64  _libssh2_ecdsa_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000001898A) ----------------------------------------------------
signed __int64  sub_1898A(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 *a6)
{
  __int64 *v7; // [rsp+0h] [rbp-B0h]
  __int64 v8; // [rsp+8h] [rbp-A8h]
  int v9; // [rsp+14h] [rbp-9Ch]
  __int64 v10; // [rsp+18h] [rbp-98h]
  unsigned int v11; // [rsp+3Ch] [rbp-74h]
  int i; // [rsp+40h] [rbp-70h]
  int j; // [rsp+44h] [rbp-6Ch]
  int k; // [rsp+48h] [rbp-68h]
  int v15; // [rsp+4Ch] [rbp-64h]
  __int64 v16; // [rsp+50h] [rbp-60h]
  __int64 v17; // [rsp+58h] [rbp-58h]
  char v18; // [rsp+60h] [rbp-50h]
  unsigned __int64 v19; // [rsp+A8h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v19 = __readfsqword(0x28u);
  v17 = *a6;
  v15 = _libssh2_ecdsa_get_curve_type(v17);
  switch ( v15 )
  {
    case 415:
      _libssh2_sha256_init(&v16);
      for ( i = 0; i < v9; ++i )
        EVP_DigestUpdate(v16, *(_QWORD *)(16LL * i + v8), *(_QWORD *)(16LL * i + v8 + 8));
      EVP_DigestFinal(v16, &v18, 0LL);
      EVP_MD_CTX_free(v16);
      v11 = _libssh2_ecdsa_sign(a1, v17, &v18, 32LL, a2, v10, v7, v8);
      break;
    case 715:
      _libssh2_sha384_init(&v16);
      for ( j = 0; j < v9; ++j )
        EVP_DigestUpdate(v16, *(_QWORD *)(16LL * j + v8), *(_QWORD *)(16LL * j + v8 + 8));
      EVP_DigestFinal(v16, &v18, 0LL);
      EVP_MD_CTX_free(v16);
      v11 = _libssh2_ecdsa_sign(a1, v17, &v18, 48LL, a2, v10, v7, v8);
      break;
    case 716:
      _libssh2_sha512_init(&v16);
      for ( k = 0; k < v9; ++k )
        EVP_DigestUpdate(v16, *(_QWORD *)(16LL * k + v8), *(_QWORD *)(16LL * k + v8 + 8));
      EVP_DigestFinal(v16, &v18, 0LL);
      EVP_MD_CTX_free(v16);
      v11 = _libssh2_ecdsa_sign(a1, v17, &v18, 64LL, a2, v10, v7, v8);
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  return v11;
}
// 8A70: using guessed type __int64  _libssh2_ecdsa_get_curve_type(_QWORD);
// 8BF0: using guessed type __int64  _libssh2_sha256_init(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8E90: using guessed type __int64  _libssh2_ecdsa_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 91E0: using guessed type __int64  _libssh2_sha512_init(_QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9980: using guessed type __int64  _libssh2_sha384_init(_QWORD);

//----- (0000000000018C7B) ----------------------------------------------------
__int64  sub_18C7B(__int64 a1, _QWORD *a2)
{
  if ( *a2 )
    EC_KEY_free(*a2);
  *a2 = 0LL;
  return 0LL;
}
// 89F0: using guessed type __int64  EC_KEY_free(_QWORD);

//----- (0000000000018CBB) ----------------------------------------------------
signed __int64  sub_18CBB(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4)
{
  unsigned int v5; // eax
  _QWORD *v6; // [rsp+0h] [rbp-50h]
  unsigned __int64 v7; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+28h] [rbp-28h]
  char *s1; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v12 = __readfsqword(0x28u);
  v8 = 0LL;
  if ( *a4 )
  {
    sub_19013(a1, a4);
    *v6 = 0LL;
  }
  if ( v7 <= 0x12 )
    return 0xFFFFFFFFLL;
  v10 = (unsigned int)_libssh2_ntohu32(a2);
  s1 = (char *)(a2 + 4);
  if ( v10 != 11 || strncmp(s1, "ssh-ed25519", 0xBuLL) )
    return 0xFFFFFFFFLL;
  s1 += 11;
  v5 = _libssh2_ntohu32(s1);
  v11 = v5;
  s1 += 4;
  if ( (unsigned int)_libssh2_ed25519_new_public(&v8, a1, s1, (unsigned __int8)v5) )
    return 0xFFFFFFFFLL;
  *v6 = v8;
  return 0LL;
}
// 9090: using guessed type __int64  _libssh2_ed25519_new_public(_QWORD, _QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);

//----- (0000000000018DD6) ----------------------------------------------------
signed __int64  sub_18DD6(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-40h]
  __int64 v6; // [rsp+8h] [rbp-38h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = __readfsqword(0x28u);
  v7 = 0LL;
  if ( *a4 )
  {
    sub_19013(a1, a4);
    *v5 = 0LL;
  }
  if ( (unsigned int)_libssh2_ed25519_new_private(&v7, a1, a2, v6) )
    return 0xFFFFFFFFLL;
  *v5 = v7;
  return 0LL;
}
// 9900: using guessed type __int64  _libssh2_ed25519_new_private(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018E7B) ----------------------------------------------------
signed __int64  sub_18E7B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+10h] [rbp-40h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  __int64 v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = __readfsqword(0x28u);
  v9 = 0LL;
  if ( a5 && *a5 )
  {
    sub_19013(a1, a5);
    *v6 = 0LL;
  }
  if ( (unsigned int)_libssh2_ed25519_new_private_frommemory(&v9, a1, a2, v8, v7) )
    return 0xFFFFFFFFLL;
  if ( v6 )
    *v6 = v9;
  return 0LL;
}
// 8960: using guessed type __int64  _libssh2_ed25519_new_private_frommemory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018F3B) ----------------------------------------------------
__int64  sub_18F3B(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  if ( a3 <= 0x12 )
    return 0xFFFFFFFFLL;
  if ( a3 == 83 )
    return _libssh2_ed25519_verify(*a6, a2 + 19, 64LL, a4, a5);
  return 0xFFFFFFFFLL;
}
// 8F70: using guessed type __int64  _libssh2_ed25519_verify(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018FAD) ----------------------------------------------------
__int64  sub_18FAD(__int64 a1, __int64 a2, __int64 a3, int a4, _QWORD *a5, _QWORD *a6)
{
  __int64 result; // rax

  if ( a4 == 1 )
    result = _libssh2_ed25519_sign(*a6, a1, a2, a3, *a5, a5[1], a6);
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 99D0: using guessed type __int64  _libssh2_ed25519_sign(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000019013) ----------------------------------------------------
__int64  sub_19013(__int64 a1, _QWORD *a2)
{
  if ( *a2 )
    EVP_PKEY_free(*a2, a2);
  *a2 = 0LL;
  return 0LL;
}
// 9700: using guessed type __int64  EVP_PKEY_free(_QWORD, _QWORD);

//----- (0000000000019053) ----------------------------------------------------
char **off_250A00[6];

char ***libssh2_hostkey_methods()
{
  return off_250A00;
}
// 250A00: using guessed type char **off_250A00[6];

//----- (0000000000019060) ----------------------------------------------------
signed __int64  libssh2_hostkey_hash(_DWORD *a1, int a2)
{
  signed __int64 result; // rax

  switch ( a2 )
  {
    case 2:
      if ( a1[57] )
        result = (signed __int64)(a1 + 52);
      else
        result = 0LL;
      break;
    case 3:
      if ( a1[66] )
        result = (signed __int64)(a1 + 58);
      else
        result = 0LL;
      break;
    case 1:
      if ( a1[51] )
        result = (signed __int64)(a1 + 47);
      else
        result = 0LL;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000190E7) ----------------------------------------------------
signed __int64  sub_190E7(const void *a1, unsigned __int64 a2)
{
  if ( a2 <= 0xA )
    return 0LL;
  if ( !memcmp(&unk_46840, a1, 0xBuLL) )
    return 1LL;
  if ( !memcmp(&unk_46850, a1, 0xBuLL) )
    return 2LL;
  if ( a2 <= 0xE )
    return 0LL;
  if ( !memcmp(&unk_46860, a1, 0xFuLL) )
    return 6LL;
  if ( a2 <= 0x16 )
    return 0LL;
  if ( !memcmp(&unk_46870, a1, 0x17uLL) )
    return 3LL;
  if ( !memcmp(&unk_46890, a1, 0x17uLL) )
    return 4LL;
  if ( !memcmp(&unk_468B0, a1, 0x17uLL) )
    return 5LL;
  return 0LL;
}

//----- (0000000000019206) ----------------------------------------------------
__int64  libssh2_session_hostkey(__int64 a1, _QWORD *a2, _DWORD *a3)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 184) )
  {
    if ( a2 )
      *a2 = *(unsigned int *)(a1 + 184);
    if ( a3 )
      *a3 = sub_190E7(*(const void **)(a1 + 176), *(unsigned int *)(a1 + 184));
    result = *(_QWORD *)(a1 + 176);
  }
  else
  {
    if ( a2 )
      *a2 = 0LL;
    result = 0LL;
  }
  return result;
}

//----- (0000000000019299) ----------------------------------------------------
__int64  libssh2_keepalive_config(__int64 a1, int a2, int a3)
{
  __int64 result; // rax

  if ( a3 == 1 )
    *(_DWORD *)(a1 + 54824) = 2;
  else
    *(_DWORD *)(a1 + 54824) = a3;
  result = a1;
  *(_DWORD *)(a1 + 54828) = a2 != 0;
  return result;
}

//----- (00000000000192E1) ----------------------------------------------------
__int64  libssh2_keepalive_send(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-44h]
  time_t v4; // [rsp+20h] [rbp-40h]
  __int64 v5; // [rsp+30h] [rbp-30h]
  __int64 v6; // [rsp+38h] [rbp-28h]
  __int64 v7; // [rsp+40h] [rbp-20h]
  int v8; // [rsp+48h] [rbp-18h]
  unsigned __int64 v9; // [rsp+58h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 54824) )
  {
    v4 = time(0LL);
    if ( v4 < *(_QWORD *)(a1 + 54832) + (signed __int64)*(signed int *)(a1 + 54824) )
    {
      if ( a2 )
        *a2 = *(_DWORD *)(a1 + 54824) + *(unsigned __int64 *)(a1 + 54832) - v4;
    }
    else
    {
      v5 = 7306363708416983120LL;
      v6 = 7800346113854955888LL;
      v7 = 8011396211333620329LL;
      v8 = 5728114;
      BYTE2(v8) = *(_DWORD *)(a1 + 54828);
      v3 = _libssh2_transport_send(a1, &v5, 27LL, 0LL, 0LL);
      if ( v3 && v3 != -37 )
      {
        _libssh2_error(a1, 4294967289LL, "Unable to send keepalive message");
        return v3;
      }
      *(_QWORD *)(a1 + 54832) = v4;
      if ( a2 )
        *a2 = *(_DWORD *)(a1 + 54824);
    }
    result = 0LL;
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    result = 0LL;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000019461) ----------------------------------------------------
signed __int64  sub_19461(signed __int64 a1, signed __int64 a2, __int64 a3, unsigned int a4, char a5, unsigned __int8 a6, __int64 a7, __int64 a8, __int64 a9)
{
  int v10; // eax
  size_t v11; // rax
  unsigned int v12; // eax
  size_t v13; // rax
  unsigned __int8 v14; // [rsp+1Ch] [rbp-C4h]
  char v15; // [rsp+20h] [rbp-C0h]
  unsigned int v16; // [rsp+24h] [rbp-BCh]
  __int64 v17; // [rsp+28h] [rbp-B8h]
  signed __int64 v18; // [rsp+30h] [rbp-B0h]
  int v19; // [rsp+40h] [rbp-A0h]
  unsigned int v20; // [rsp+44h] [rbp-9Ch]
  unsigned int v21; // [rsp+48h] [rbp-98h]
  int v22; // [rsp+4Ch] [rbp-94h]
  __int64 v23; // [rsp+50h] [rbp-90h]
  __int64 v24; // [rsp+58h] [rbp-88h]
  __int128 v25; // [rsp+60h] [rbp-80h]
  unsigned __int64 v26; // [rsp+70h] [rbp-70h]
  unsigned __int64 v27; // [rsp+78h] [rbp-68h]
  __int128 v28; // [rsp+80h] [rbp-60h]
  unsigned __int64 v29; // [rsp+90h] [rbp-50h]
  unsigned __int64 v30; // [rsp+98h] [rbp-48h]
  __int128 v31; // [rsp+A0h] [rbp-40h]
  __int128 v32; // [rsp+B0h] [rbp-30h]
  __int64 v33; // [rsp+C0h] [rbp-20h]
  __int64 v34; // [rsp+C8h] [rbp-18h]
  __int64 v35; // [rsp+D0h] [rbp-10h]
  unsigned __int64 v36; // [rsp+D8h] [rbp-8h]

  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v36 = __readfsqword(0x28u);
  v20 = 0;
  if ( !*(_DWORD *)a9 )
  {
    *(_QWORD *)(a9 + 8) = 0LL;
    *(_QWORD *)(a9 + 16) = 0LL;
    *(_QWORD *)(a9 + 176) = 0LL;
    *(_QWORD *)(a9 + 128) = BN_CTX_new();
    _libssh2_dh_init(a9 + 136);
    *(_QWORD *)(a9 + 144) = BN_new(a9 + 136, a2);
    *(_QWORD *)(a9 + 152) = BN_new(a9 + 136, a2);
    *(_QWORD *)(a9 + 160) = BN_new(a9 + 136, a2);
    memset((void *)(a9 + 224), 0, 0x10uLL);
    a2 = *(_QWORD *)(a9 + 144);
    v21 = _libssh2_dh_key_pair(a9 + 136, a2, v18, v17, v16, *(_QWORD *)(a9 + 128));
    if ( v21 )
      goto LABEL_183;
    *(_QWORD *)(a9 + 104) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a9 + 144)) + 7) / 8 + 6;
    if ( BN_num_bits(*(_QWORD *)(a9 + 144)) & 7 )
      --*(_QWORD *)(a9 + 104);
    *(_QWORD *)(a9 + 8) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(*(_QWORD *)(a9 + 104), a1);
    if ( !*(_QWORD *)(a9 + 8) )
    {
      a2 = 4294967290LL;
      v20 = _libssh2_error(a1, 4294967290LL, "Out of memory error");
      goto LABEL_183;
    }
    **(_BYTE **)(a9 + 8) = v15;
    _libssh2_htonu32(*(_QWORD *)(a9 + 8) + 1LL, (unsigned int)*(_QWORD *)(a9 + 104) - 5);
    if ( BN_num_bits(*(_QWORD *)(a9 + 144)) & 7 )
    {
      a2 = *(_QWORD *)(a9 + 8) + 5LL;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a9 + 8) + 5LL) = 0;
      a2 = *(_QWORD *)(a9 + 8) + 6LL;
    }
    BN_bn2bin(*(_QWORD *)(a9 + 144), a2);
    *(_DWORD *)a9 = 2;
  }
  if ( *(_DWORD *)a9 == 2 )
  {
    a2 = *(_QWORD *)(a9 + 8);
    v21 = _libssh2_transport_send(a1, a2, *(_QWORD *)(a9 + 104), 0LL, 0LL);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( v21 )
    {
      a2 = v21;
      v20 = _libssh2_error(a1, v21, "Unable to send KEX init message");
      goto LABEL_183;
    }
    *(_DWORD *)a9 = 3;
  }
  if ( *(_DWORD *)a9 == 3 )
  {
    if ( *(_BYTE *)(a1 + 128) & 1 )
    {
      a2 = a9 + 240;
      v22 = _libssh2_packet_burn(a1, a9 + 240);
      if ( v22 == -37 )
        return 4294967259LL;
      if ( v22 <= 0 )
      {
        v20 = v22;
        goto LABEL_183;
      }
      *(_BYTE *)(a1 + 128) &= 0xFEu;
    }
    *(_DWORD *)a9 = 4;
  }
  if ( *(_DWORD *)a9 == 4 )
  {
    v21 = _libssh2_packet_require(a1, v14, a9 + 16, a9 + 112, 0LL, 0LL, 0LL, a9 + 224);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( v21 )
    {
      a2 = 4294967287LL;
      v20 = _libssh2_error(a1, 4294967287LL, "Timed out waiting for KEX reply");
      goto LABEL_183;
    }
    if ( *(_QWORD *)(a9 + 112) <= 4uLL )
    {
      a2 = 4294967282LL;
      v20 = _libssh2_error(a1, 4294967282LL, "Unexpected packet length");
      goto LABEL_183;
    }
    v33 = *(_QWORD *)(a9 + 16);
    v35 = *(_QWORD *)(a9 + 112);
    v34 = v33 + 1;
    if ( *(_QWORD *)(a1 + 176) )
      (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a1 + 176), a1);
    if ( (unsigned int)_libssh2_copy_string(a1, &v33, a1 + 176, &v23) )
    {
      a2 = 4294967290LL;
      v20 = _libssh2_error(a1, 4294967290LL, "Could not copy host key");
      goto LABEL_183;
    }
    *(_DWORD *)(a1 + 184) = v23;
    if ( (unsigned int)_libssh2_md5_init(&v24) )
    {
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v24, a1 + 188, 0LL);
      EVP_MD_CTX_free(v24);
      *(_DWORD *)(a1 + 204) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 204) = 0;
    }
    if ( (unsigned int)_libssh2_sha1_init(&v24) )
    {
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v24, a1 + 208, 0LL);
      EVP_MD_CTX_free(v24);
      *(_DWORD *)(a1 + 228) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 228) = 0;
    }
    if ( (unsigned int)_libssh2_sha256_init(&v24) )
    {
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v24, a1 + 232, 0LL);
      EVP_MD_CTX_free(v24);
      *(_DWORD *)(a1 + 264) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 264) = 0;
    }
    if ( (*(unsigned int ( **)(signed __int64, _QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 160) + 16LL))(
           a1,
           *(_QWORD *)(a1 + 176),
           *(unsigned int *)(a1 + 184),
           a1 + 168) )
    {
      a2 = 4294967286LL;
      v20 = _libssh2_error(a1, 4294967286LL, "Unable to initialize hostkey importer");
      goto LABEL_183;
    }
    if ( (unsigned int)_libssh2_get_string(&v33, a9 + 168, a9 + 192) )
    {
      a2 = 4294967286LL;
      v20 = _libssh2_error(a1, 4294967286LL, "Unable to get f value");
      goto LABEL_183;
    }
    BN_bin2bn(*(_QWORD *)(a9 + 168), (unsigned int)*(_QWORD *)(a9 + 192), *(_QWORD *)(a9 + 152));
    if ( (unsigned int)_libssh2_get_string(&v33, a9 + 184, a9 + 208) )
    {
      a2 = 4294967286LL;
      v20 = _libssh2_error(a1, 4294967286LL, "Unable to get h sig");
      goto LABEL_183;
    }
    _libssh2_dh_secret(a9 + 136, *(_QWORD *)(a9 + 160), *(_QWORD *)(a9 + 152), v17, *(_QWORD *)(a9 + 128));
    *(_QWORD *)(a9 + 200) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a9 + 160)) + 7) / 8 + 5;
    if ( BN_num_bits(*(_QWORD *)(a9 + 160)) & 7 )
      --*(_QWORD *)(a9 + 200);
    *(_QWORD *)(a9 + 176) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(*(_QWORD *)(a9 + 200), a1);
    if ( !*(_QWORD *)(a9 + 176) )
    {
      a2 = 4294967290LL;
      v20 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for K");
      goto LABEL_183;
    }
    _libssh2_htonu32(*(_QWORD *)(a9 + 176), (unsigned int)*(_QWORD *)(a9 + 200) - 4);
    if ( BN_num_bits(*(_QWORD *)(a9 + 160)) & 7 )
    {
      BN_bn2bin(*(_QWORD *)(a9 + 160), *(_QWORD *)(a9 + 176) + 4LL);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a9 + 176) + 4LL) = 0;
      BN_bn2bin(*(_QWORD *)(a9 + 160), *(_QWORD *)(a9 + 176) + 5LL);
    }
    *(_QWORD *)(a9 + 216) = &v24;
    _libssh2_sha1_init(&v24);
    if ( *(_QWORD *)(a1 + 384) )
    {
      v10 = strlen(*(const char **)(a1 + 384));
      _libssh2_htonu32(a9 + 32, (unsigned int)(v10 - 2));
      EVP_DigestUpdate(v24, a9 + 32, 4LL);
      v11 = strlen(*(const char **)(a1 + 384));
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 384), v11 - 2);
    }
    else
    {
      _libssh2_htonu32(a9 + 32, 25LL);
      EVP_DigestUpdate(v24, a9 + 32, 4LL);
      EVP_DigestUpdate(v24, "SSH-2.0-libssh2_1.9.0_DEV", 25LL);
    }
    v12 = strlen(*(const char **)(a1 + 272));
    _libssh2_htonu32(a9 + 32, v12);
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    v13 = strlen(*(const char **)(a1 + 272));
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 272), v13);
    _libssh2_htonu32(a9 + 32, (unsigned int)*(_QWORD *)(a1 + 400));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400));
    _libssh2_htonu32(a9 + 32, (unsigned int)*(_QWORD *)(a1 + 288));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 288));
    _libssh2_htonu32(a9 + 32, *(unsigned int *)(a1 + 184));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
    if ( v15 == 32 )
    {
      _libssh2_htonu32(a9 + 32, 1024LL);
      _libssh2_htonu32(a9 + 36, 1536LL);
      _libssh2_htonu32(a9 + 40, 2048LL);
      EVP_DigestUpdate(v24, a9 + 32, 12LL);
    }
    if ( a7 )
      EVP_DigestUpdate(v24, a7, a8);
    EVP_DigestUpdate(v24, *(_QWORD *)(a9 + 8) + 1LL, *(_QWORD *)(a9 + 104) - 1LL);
    _libssh2_htonu32(a9 + 32, (unsigned int)*(_QWORD *)(a9 + 192));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a9 + 168), *(_QWORD *)(a9 + 192));
    EVP_DigestUpdate(v24, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
    EVP_DigestFinal(v24, a9 + 32, 0LL);
    EVP_MD_CTX_free(v24);
    a2 = *(_QWORD *)(a9 + 184);
    if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 160) + 40LL))(
           a1,
           a2,
           *(_QWORD *)(a9 + 208),
           a9 + 32,
           20LL,
           a1 + 168) )
    {
      a2 = 4294967285LL;
      v20 = _libssh2_error(a1, 4294967285LL, "Unable to verify hostkey signature");
      goto LABEL_183;
    }
    *(_BYTE *)(a9 + 96) = 21;
    *(_DWORD *)a9 = 5;
  }
  if ( *(_DWORD *)a9 == 5 )
  {
    a2 = a9 + 96;
    v21 = _libssh2_transport_send(a1, a9 + 96, 1LL, 0LL, 0LL);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( v21 )
    {
      a2 = v21;
      v20 = _libssh2_error(a1, v21, "Unable to send NEWKEYS message");
      goto LABEL_183;
    }
    *(_DWORD *)a9 = 6;
  }
  if ( *(_DWORD *)a9 == 6 )
  {
    v21 = _libssh2_packet_require(a1, 21LL, a9 + 24, a9 + 120, 0LL, 0LL, 0LL, a9 + 224);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( !v21 )
    {
      *(_DWORD *)(a1 + 104) |= 2u;
      a2 = a1;
      (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 24), a1);
      if ( !*(_QWORD *)(a1 + 136) )
      {
        *(_QWORD *)(a1 + 136) = (*(__int64 ( **)(signed __int64, signed __int64))(a1 + 8))(20LL, a1);
        if ( !*(_QWORD *)(a1 + 136) )
        {
          a2 = 4294967290LL;
          v20 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for SHA digest");
          goto LABEL_183;
        }
        a2 = a9 + 32;
        memcpy(*(void **)(a1 + 136), (const void *)(a9 + 32), 0x14uLL);
        *(_DWORD *)(a1 + 144) = 20;
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 56LL) )
      {
        a2 = a1 + 416;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 408) + 56LL))(a1, a1 + 416);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 40LL) )
      {
        *(_QWORD *)&v25 = 0LL;
        v19 = 0;
        LODWORD(v23) = 0;
        v26 = 0LL;
        a2 = a1;
        v25 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 408) + 20LL) + 20,
                                  a1);
        if ( (_QWORD)v25 )
        {
          while ( v26 < *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL) )
          {
            _libssh2_sha1_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 20LL);
            if ( v26 )
            {
              EVP_DigestUpdate(v33, v25, v26);
            }
            else
            {
              EVP_DigestUpdate(v33, "A", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v25 + v26;
            EVP_DigestFinal(v33, v25 + v26, 0LL);
            EVP_MD_CTX_free(v33);
            v26 += 20LL;
          }
        }
        if ( !(_QWORD)v25 )
        {
          v20 = -1;
          goto LABEL_183;
        }
        v27 = 0LL;
        if ( !*((_QWORD *)&v25 + 1) )
          *((_QWORD *)&v25 + 1) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 408) + 24LL) + 20,
                                    a1);
        if ( *((_QWORD *)&v25 + 1) )
        {
          while ( v27 < *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL) )
          {
            _libssh2_sha1_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 20LL);
            if ( v27 )
            {
              EVP_DigestUpdate(v33, *((_QWORD *)&v25 + 1), v27);
            }
            else
            {
              EVP_DigestUpdate(v33, "C", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(v33, *((_QWORD *)&v25 + 1) + v27, 0LL);
            EVP_MD_CTX_free(v33);
            v27 += 20LL;
          }
        }
        if ( !*((_QWORD *)&v25 + 1) )
        {
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v25, a1);
          v20 = -5;
          goto LABEL_183;
        }
        a2 = *(_QWORD *)(a1 + 408);
        if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, int *, _QWORD, __int64 *, signed __int64, signed __int64))(*(_QWORD *)(a1 + 408) + 40LL))(
               a1,
               a2,
               v25,
               &v19,
               *((_QWORD *)&v25 + 1),
               &v23,
               1LL,
               a1 + 416) )
        {
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v25, a1);
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v25 + 1), a1);
          v20 = -5;
          goto LABEL_183;
        }
        if ( v19 )
        {
          _libssh2_explicit_zero(v25, *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v25, a1);
        }
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(*((_QWORD *)&v25 + 1), *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v25 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 56LL) )
      {
        a2 = a1 + 304;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 296) + 56LL))(a1, a1 + 304);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 40LL) )
      {
        *(_QWORD *)&v28 = 0LL;
        v19 = 0;
        LODWORD(v23) = 0;
        v29 = 0LL;
        a2 = a1;
        v28 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 296) + 20LL) + 20,
                                  a1);
        if ( (_QWORD)v28 )
        {
          while ( v29 < *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL) )
          {
            _libssh2_sha1_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 20LL);
            if ( v29 )
            {
              EVP_DigestUpdate(v33, v28, v29);
            }
            else
            {
              EVP_DigestUpdate(v33, "B", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v28 + v29;
            EVP_DigestFinal(v33, v28 + v29, 0LL);
            EVP_MD_CTX_free(v33);
            v29 += 20LL;
          }
        }
        if ( !(_QWORD)v28 )
        {
          v20 = -5;
          goto LABEL_183;
        }
        v30 = 0LL;
        if ( !*((_QWORD *)&v28 + 1) )
          *((_QWORD *)&v28 + 1) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 296) + 24LL) + 20,
                                    a1);
        if ( *((_QWORD *)&v28 + 1) )
        {
          while ( v30 < *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL) )
          {
            _libssh2_sha1_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 20LL);
            if ( v30 )
            {
              EVP_DigestUpdate(v33, *((_QWORD *)&v28 + 1), v30);
            }
            else
            {
              EVP_DigestUpdate(v33, "D", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(v33, *((_QWORD *)&v28 + 1) + v30, 0LL);
            EVP_MD_CTX_free(v33);
            v30 += 20LL;
          }
        }
        if ( !*((_QWORD *)&v28 + 1) )
        {
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v28, a1);
          v20 = -5;
          goto LABEL_183;
        }
        a2 = *(_QWORD *)(a1 + 296);
        if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, int *, _QWORD, __int64 *, _QWORD, signed __int64))(*(_QWORD *)(a1 + 296) + 40LL))(
               a1,
               a2,
               v28,
               &v19,
               *((_QWORD *)&v28 + 1),
               &v23,
               0LL,
               a1 + 304) )
        {
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v28, a1);
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v28 + 1), a1);
          v20 = -5;
          goto LABEL_183;
        }
        if ( v19 )
        {
          _libssh2_explicit_zero(v28, *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v28, a1);
        }
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(*((_QWORD *)&v28 + 1), *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v28 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 32LL) )
      {
        a2 = a1 + 440;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 424) + 32LL))(a1, a1 + 440);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 16LL) )
      {
        *(_QWORD *)&v31 = 0LL;
        LODWORD(v23) = 0;
        a2 = a1;
        v31 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 424) + 12LL) + 20,
                                  a1);
        if ( (_QWORD)v31 )
        {
          while ( *((_QWORD *)&v31 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 424) + 12LL) )
          {
            _libssh2_sha1_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 20LL);
            if ( *((_QWORD *)&v31 + 1) )
            {
              EVP_DigestUpdate(v33, v31, *((_QWORD *)&v31 + 1));
            }
            else
            {
              EVP_DigestUpdate(v33, "E", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v31 + *((_QWORD *)&v31 + 1);
            EVP_DigestFinal(v33, v31 + *((_QWORD *)&v31 + 1), 0LL);
            EVP_MD_CTX_free(v33);
            *((_QWORD *)&v31 + 1) += 20LL;
          }
        }
        if ( !(_QWORD)v31 )
        {
          v20 = -5;
          goto LABEL_183;
        }
        a2 = v31;
        (*(void ( **)(signed __int64, _QWORD, __int64 *, signed __int64))(*(_QWORD *)(a1 + 424) + 16LL))(
          a1,
          v31,
          &v23,
          a1 + 440);
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(v31, *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v31, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32LL) )
      {
        a2 = a1 + 328;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 312) + 32LL))(a1, a1 + 328);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16LL) )
      {
        *(_QWORD *)&v32 = 0LL;
        LODWORD(v23) = 0;
        a2 = a1;
        v32 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 312) + 12LL) + 20,
                                  a1);
        if ( (_QWORD)v32 )
        {
          while ( *((_QWORD *)&v32 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 312) + 12LL) )
          {
            _libssh2_sha1_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 20LL);
            if ( *((_QWORD *)&v32 + 1) )
            {
              EVP_DigestUpdate(v33, v32, *((_QWORD *)&v32 + 1));
            }
            else
            {
              EVP_DigestUpdate(v33, "F", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v32 + *((_QWORD *)&v32 + 1);
            EVP_DigestFinal(v33, v32 + *((_QWORD *)&v32 + 1), 0LL);
            EVP_MD_CTX_free(v33);
            *((_QWORD *)&v32 + 1) += 20LL;
          }
        }
        if ( !(_QWORD)v32 )
        {
          v20 = -5;
          goto LABEL_183;
        }
        a2 = v32;
        (*(void ( **)(signed __int64, _QWORD, __int64 *, signed __int64))(*(_QWORD *)(a1 + 312) + 16LL))(
          a1,
          v32,
          &v23,
          a1 + 328);
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(v32, *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v32, a1);
        }
      }
      if ( *(_QWORD *)(a1 + 448) && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 40LL) )
      {
        a2 = 1LL;
        (*(void ( **)(signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 448) + 40LL))(
          a1,
          1LL,
          a1 + 456);
      }
      if ( *(_QWORD *)(a1 + 448)
        && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 16LL)
        && (a2 = 1LL,
            (*(unsigned int ( **)(signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 448) + 16LL))(
              a1,
              1LL,
              a1 + 456)) )
      {
        v20 = -5;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 336) && *(_QWORD *)(*(_QWORD *)(a1 + 336) + 40LL) )
        {
          a2 = 0LL;
          (*(void ( **)(signed __int64, _QWORD, signed __int64))(*(_QWORD *)(a1 + 336) + 40LL))(
            a1,
            0LL,
            a1 + 344);
        }
        if ( *(_QWORD *)(a1 + 336) )
        {
          if ( *(_QWORD *)(*(_QWORD *)(a1 + 336) + 16LL) )
          {
            a2 = 0LL;
            if ( (*(unsigned int ( **)(signed __int64, _QWORD, signed __int64))(*(_QWORD *)(a1 + 336) + 16LL))(
                   a1,
                   0LL,
                   a1 + 344) )
            {
              v20 = -5;
            }
          }
        }
      }
      goto LABEL_183;
    }
    a2 = v21;
    v20 = _libssh2_error(a1, v21, "Timed out waiting for NEWKEYS");
  }
LABEL_183:
  _libssh2_dh_dtor(a9 + 136, a2);
  BN_clear_free(*(_QWORD *)(a9 + 144), a2);
  *(_QWORD *)(a9 + 144) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 152), a2);
  *(_QWORD *)(a9 + 152) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 160), a2);
  *(_QWORD *)(a9 + 160) = 0LL;
  BN_CTX_free(*(_QWORD *)(a9 + 128), a2);
  *(_QWORD *)(a9 + 128) = 0LL;
  if ( *(_QWORD *)(a9 + 8) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 8), a1);
    *(_QWORD *)(a9 + 8) = 0LL;
  }
  if ( *(_QWORD *)(a9 + 16) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 16), a1);
    *(_QWORD *)(a9 + 16) = 0LL;
  }
  if ( *(_QWORD *)(a9 + 176) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 176), a1);
    *(_QWORD *)(a9 + 176) = 0LL;
  }
  *(_DWORD *)a9 = 0;
  return v20;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8A00: using guessed type __int64  _libssh2_copy_string(_QWORD, _QWORD, _QWORD, _QWORD);
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8B30: using guessed type __int64  _libssh2_dh_dtor(_QWORD, _QWORD);
// 8BF0: using guessed type __int64  _libssh2_sha256_init(_QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 9040: using guessed type __int64  _libssh2_dh_key_pair(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 92F0: using guessed type __int64  _libssh2_dh_init(_QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9600: using guessed type __int64  _libssh2_dh_secret(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9770: using guessed type __int64  _libssh2_packet_burn(_QWORD, _QWORD);
// 9780: using guessed type __int64  BN_bn2bin(_QWORD, _QWORD);
// 9790: using guessed type __int64  _libssh2_sha1_init(_QWORD);
// 9920: using guessed type __int64  _libssh2_md5_init(_QWORD);

//----- (000000000001B899) ----------------------------------------------------
signed __int64  sub_1B899(signed __int64 a1, signed __int64 a2, __int64 a3, unsigned int a4, char a5, unsigned __int8 a6, __int64 a7, __int64 a8, __int64 a9)
{
  int v10; // eax
  size_t v11; // rax
  unsigned int v12; // eax
  size_t v13; // rax
  unsigned __int8 v14; // [rsp+1Ch] [rbp-C4h]
  char v15; // [rsp+20h] [rbp-C0h]
  unsigned int v16; // [rsp+24h] [rbp-BCh]
  __int64 v17; // [rsp+28h] [rbp-B8h]
  signed __int64 v18; // [rsp+30h] [rbp-B0h]
  int v19; // [rsp+40h] [rbp-A0h]
  unsigned int v20; // [rsp+44h] [rbp-9Ch]
  unsigned int v21; // [rsp+48h] [rbp-98h]
  int v22; // [rsp+4Ch] [rbp-94h]
  __int64 v23; // [rsp+50h] [rbp-90h]
  __int64 v24; // [rsp+58h] [rbp-88h]
  __int128 v25; // [rsp+60h] [rbp-80h]
  unsigned __int64 v26; // [rsp+70h] [rbp-70h]
  unsigned __int64 v27; // [rsp+78h] [rbp-68h]
  __int128 v28; // [rsp+80h] [rbp-60h]
  unsigned __int64 v29; // [rsp+90h] [rbp-50h]
  unsigned __int64 v30; // [rsp+98h] [rbp-48h]
  __int128 v31; // [rsp+A0h] [rbp-40h]
  __int128 v32; // [rsp+B0h] [rbp-30h]
  __int64 v33; // [rsp+C0h] [rbp-20h]
  __int64 v34; // [rsp+C8h] [rbp-18h]
  __int64 v35; // [rsp+D0h] [rbp-10h]
  unsigned __int64 v36; // [rsp+D8h] [rbp-8h]

  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v36 = __readfsqword(0x28u);
  v20 = 0;
  if ( !*(_DWORD *)a9 )
  {
    *(_QWORD *)(a9 + 8) = 0LL;
    *(_QWORD *)(a9 + 16) = 0LL;
    *(_QWORD *)(a9 + 176) = 0LL;
    *(_QWORD *)(a9 + 128) = BN_CTX_new();
    _libssh2_dh_init(a9 + 136);
    *(_QWORD *)(a9 + 144) = BN_new(a9 + 136, a2);
    *(_QWORD *)(a9 + 152) = BN_new(a9 + 136, a2);
    *(_QWORD *)(a9 + 160) = BN_new(a9 + 136, a2);
    memset((void *)(a9 + 224), 0, 0x10uLL);
    a2 = *(_QWORD *)(a9 + 144);
    v21 = _libssh2_dh_key_pair(a9 + 136, a2, v18, v17, v16, *(_QWORD *)(a9 + 128));
    if ( v21 )
      goto LABEL_183;
    *(_QWORD *)(a9 + 104) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a9 + 144)) + 7) / 8 + 6;
    if ( BN_num_bits(*(_QWORD *)(a9 + 144)) & 7 )
      --*(_QWORD *)(a9 + 104);
    *(_QWORD *)(a9 + 8) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(*(_QWORD *)(a9 + 104), a1);
    if ( !*(_QWORD *)(a9 + 8) )
    {
      a2 = 4294967290LL;
      v20 = _libssh2_error(a1, 4294967290LL, "Out of memory error");
      goto LABEL_183;
    }
    **(_BYTE **)(a9 + 8) = v15;
    _libssh2_htonu32(*(_QWORD *)(a9 + 8) + 1LL, (unsigned int)*(_QWORD *)(a9 + 104) - 5);
    if ( BN_num_bits(*(_QWORD *)(a9 + 144)) & 7 )
    {
      a2 = *(_QWORD *)(a9 + 8) + 5LL;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a9 + 8) + 5LL) = 0;
      a2 = *(_QWORD *)(a9 + 8) + 6LL;
    }
    BN_bn2bin(*(_QWORD *)(a9 + 144), a2);
    *(_DWORD *)a9 = 2;
  }
  if ( *(_DWORD *)a9 == 2 )
  {
    a2 = *(_QWORD *)(a9 + 8);
    v21 = _libssh2_transport_send(a1, a2, *(_QWORD *)(a9 + 104), 0LL, 0LL);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( v21 )
    {
      a2 = v21;
      v20 = _libssh2_error(a1, v21, "Unable to send KEX init message");
      goto LABEL_183;
    }
    *(_DWORD *)a9 = 3;
  }
  if ( *(_DWORD *)a9 == 3 )
  {
    if ( *(_BYTE *)(a1 + 128) & 1 )
    {
      a2 = a9 + 240;
      v22 = _libssh2_packet_burn(a1, a9 + 240);
      if ( v22 == -37 )
        return 4294967259LL;
      if ( v22 <= 0 )
      {
        v20 = v22;
        goto LABEL_183;
      }
      *(_BYTE *)(a1 + 128) &= 0xFEu;
    }
    *(_DWORD *)a9 = 4;
  }
  if ( *(_DWORD *)a9 == 4 )
  {
    v21 = _libssh2_packet_require(a1, v14, a9 + 16, a9 + 112, 0LL, 0LL, 0LL, a9 + 224);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( v21 )
    {
      a2 = 4294967287LL;
      v20 = _libssh2_error(a1, 4294967287LL, "Timed out waiting for KEX reply");
      goto LABEL_183;
    }
    if ( *(_QWORD *)(a9 + 112) <= 4uLL )
    {
      a2 = 4294967282LL;
      v20 = _libssh2_error(a1, 4294967282LL, "Unexpected packet length");
      goto LABEL_183;
    }
    v33 = *(_QWORD *)(a9 + 16);
    v35 = *(_QWORD *)(a9 + 112);
    v34 = v33 + 1;
    if ( *(_QWORD *)(a1 + 176) )
      (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a1 + 176), a1);
    if ( (unsigned int)_libssh2_copy_string(a1, &v33, a1 + 176, &v23) )
    {
      a2 = 4294967290LL;
      v20 = _libssh2_error(a1, 4294967290LL, "Could not copy host key");
      goto LABEL_183;
    }
    *(_DWORD *)(a1 + 184) = v23;
    if ( (unsigned int)_libssh2_md5_init(&v24) )
    {
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v24, a1 + 188, 0LL);
      EVP_MD_CTX_free(v24);
      *(_DWORD *)(a1 + 204) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 204) = 0;
    }
    if ( (unsigned int)_libssh2_sha1_init(&v24) )
    {
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v24, a1 + 208, 0LL);
      EVP_MD_CTX_free(v24);
      *(_DWORD *)(a1 + 228) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 228) = 0;
    }
    if ( (unsigned int)_libssh2_sha256_init(&v24) )
    {
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v24, a1 + 232, 0LL);
      EVP_MD_CTX_free(v24);
      *(_DWORD *)(a1 + 264) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 264) = 0;
    }
    if ( (*(unsigned int ( **)(signed __int64, _QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 160) + 16LL))(
           a1,
           *(_QWORD *)(a1 + 176),
           *(unsigned int *)(a1 + 184),
           a1 + 168) )
    {
      a2 = 4294967286LL;
      v20 = _libssh2_error(a1, 4294967286LL, "Unable to initialize hostkey importer");
      goto LABEL_183;
    }
    if ( (unsigned int)_libssh2_get_string(&v33, a9 + 168, a9 + 192) )
    {
      a2 = 4294967286LL;
      v20 = _libssh2_error(a1, 4294967286LL, "Unable to get f value");
      goto LABEL_183;
    }
    BN_bin2bn(*(_QWORD *)(a9 + 168), (unsigned int)*(_QWORD *)(a9 + 192), *(_QWORD *)(a9 + 152));
    if ( (unsigned int)_libssh2_get_string(&v33, a9 + 184, a9 + 208) )
    {
      a2 = 4294967286LL;
      v20 = _libssh2_error(a1, 4294967286LL, "Unable to get h sig");
      goto LABEL_183;
    }
    _libssh2_dh_secret(a9 + 136, *(_QWORD *)(a9 + 160), *(_QWORD *)(a9 + 152), v17, *(_QWORD *)(a9 + 128));
    *(_QWORD *)(a9 + 200) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a9 + 160)) + 7) / 8 + 5;
    if ( BN_num_bits(*(_QWORD *)(a9 + 160)) & 7 )
      --*(_QWORD *)(a9 + 200);
    *(_QWORD *)(a9 + 176) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(*(_QWORD *)(a9 + 200), a1);
    if ( !*(_QWORD *)(a9 + 176) )
    {
      a2 = 4294967290LL;
      v20 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for K");
      goto LABEL_183;
    }
    _libssh2_htonu32(*(_QWORD *)(a9 + 176), (unsigned int)*(_QWORD *)(a9 + 200) - 4);
    if ( BN_num_bits(*(_QWORD *)(a9 + 160)) & 7 )
    {
      BN_bn2bin(*(_QWORD *)(a9 + 160), *(_QWORD *)(a9 + 176) + 4LL);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a9 + 176) + 4LL) = 0;
      BN_bn2bin(*(_QWORD *)(a9 + 160), *(_QWORD *)(a9 + 176) + 5LL);
    }
    *(_QWORD *)(a9 + 216) = &v24;
    _libssh2_sha256_init(&v24);
    if ( *(_QWORD *)(a1 + 384) )
    {
      v10 = strlen(*(const char **)(a1 + 384));
      _libssh2_htonu32(a9 + 32, (unsigned int)(v10 - 2));
      EVP_DigestUpdate(v24, a9 + 32, 4LL);
      v11 = strlen(*(const char **)(a1 + 384));
      EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 384), v11 - 2);
    }
    else
    {
      _libssh2_htonu32(a9 + 32, 25LL);
      EVP_DigestUpdate(v24, a9 + 32, 4LL);
      EVP_DigestUpdate(v24, "SSH-2.0-libssh2_1.9.0_DEV", 25LL);
    }
    v12 = strlen(*(const char **)(a1 + 272));
    _libssh2_htonu32(a9 + 32, v12);
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    v13 = strlen(*(const char **)(a1 + 272));
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 272), v13);
    _libssh2_htonu32(a9 + 32, (unsigned int)*(_QWORD *)(a1 + 400));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400));
    _libssh2_htonu32(a9 + 32, (unsigned int)*(_QWORD *)(a1 + 288));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 288));
    _libssh2_htonu32(a9 + 32, *(unsigned int *)(a1 + 184));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
    if ( v15 == 32 )
    {
      _libssh2_htonu32(a9 + 32, 1024LL);
      _libssh2_htonu32(a9 + 36, 1536LL);
      _libssh2_htonu32(a9 + 40, 2048LL);
      EVP_DigestUpdate(v24, a9 + 32, 12LL);
    }
    if ( a7 )
      EVP_DigestUpdate(v24, a7, a8);
    EVP_DigestUpdate(v24, *(_QWORD *)(a9 + 8) + 1LL, *(_QWORD *)(a9 + 104) - 1LL);
    _libssh2_htonu32(a9 + 32, (unsigned int)*(_QWORD *)(a9 + 192));
    EVP_DigestUpdate(v24, a9 + 32, 4LL);
    EVP_DigestUpdate(v24, *(_QWORD *)(a9 + 168), *(_QWORD *)(a9 + 192));
    EVP_DigestUpdate(v24, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
    EVP_DigestFinal(v24, a9 + 32, 0LL);
    EVP_MD_CTX_free(v24);
    a2 = *(_QWORD *)(a9 + 184);
    if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 160) + 40LL))(
           a1,
           a2,
           *(_QWORD *)(a9 + 208),
           a9 + 32,
           32LL,
           a1 + 168) )
    {
      a2 = 4294967285LL;
      v20 = _libssh2_error(a1, 4294967285LL, "Unable to verify hostkey signature");
      goto LABEL_183;
    }
    *(_BYTE *)(a9 + 96) = 21;
    *(_DWORD *)a9 = 5;
  }
  if ( *(_DWORD *)a9 == 5 )
  {
    a2 = a9 + 96;
    v21 = _libssh2_transport_send(a1, a9 + 96, 1LL, 0LL, 0LL);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( v21 )
    {
      a2 = v21;
      v20 = _libssh2_error(a1, v21, "Unable to send NEWKEYS message");
      goto LABEL_183;
    }
    *(_DWORD *)a9 = 6;
  }
  if ( *(_DWORD *)a9 == 6 )
  {
    v21 = _libssh2_packet_require(a1, 21LL, a9 + 24, a9 + 120, 0LL, 0LL, 0LL, a9 + 224);
    if ( v21 == -37 )
      return 4294967259LL;
    if ( !v21 )
    {
      *(_DWORD *)(a1 + 104) |= 2u;
      a2 = a1;
      (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 24), a1);
      if ( !*(_QWORD *)(a1 + 136) )
      {
        *(_QWORD *)(a1 + 136) = (*(__int64 ( **)(signed __int64, signed __int64))(a1 + 8))(32LL, a1);
        if ( !*(_QWORD *)(a1 + 136) )
        {
          a2 = 4294967290LL;
          v20 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for SHA digest");
          goto LABEL_183;
        }
        a2 = a9 + 32;
        memcpy(*(void **)(a1 + 136), (const void *)(a9 + 32), 0x20uLL);
        *(_DWORD *)(a1 + 144) = 32;
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 56LL) )
      {
        a2 = a1 + 416;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 408) + 56LL))(a1, a1 + 416);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 40LL) )
      {
        *(_QWORD *)&v25 = 0LL;
        v19 = 0;
        LODWORD(v23) = 0;
        v26 = 0LL;
        a2 = a1;
        v25 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 408) + 20LL) + 32,
                                  a1);
        if ( (_QWORD)v25 )
        {
          while ( v26 < *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 32LL);
            if ( v26 )
            {
              EVP_DigestUpdate(v33, v25, v26);
            }
            else
            {
              EVP_DigestUpdate(v33, "A", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v25 + v26;
            EVP_DigestFinal(v33, v25 + v26, 0LL);
            EVP_MD_CTX_free(v33);
            v26 += 32LL;
          }
        }
        if ( !(_QWORD)v25 )
        {
          v20 = -1;
          goto LABEL_183;
        }
        v27 = 0LL;
        if ( !*((_QWORD *)&v25 + 1) )
          *((_QWORD *)&v25 + 1) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 408) + 24LL) + 32,
                                    a1);
        if ( *((_QWORD *)&v25 + 1) )
        {
          while ( v27 < *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 32LL);
            if ( v27 )
            {
              EVP_DigestUpdate(v33, *((_QWORD *)&v25 + 1), v27);
            }
            else
            {
              EVP_DigestUpdate(v33, "C", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(v33, *((_QWORD *)&v25 + 1) + v27, 0LL);
            EVP_MD_CTX_free(v33);
            v27 += 32LL;
          }
        }
        if ( !*((_QWORD *)&v25 + 1) )
        {
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v25, a1);
          v20 = -5;
          goto LABEL_183;
        }
        a2 = *(_QWORD *)(a1 + 408);
        if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, int *, _QWORD, __int64 *, signed __int64, signed __int64))(*(_QWORD *)(a1 + 408) + 40LL))(
               a1,
               a2,
               v25,
               &v19,
               *((_QWORD *)&v25 + 1),
               &v23,
               1LL,
               a1 + 416) )
        {
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v25, a1);
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v25 + 1), a1);
          v20 = -5;
          goto LABEL_183;
        }
        if ( v19 )
        {
          _libssh2_explicit_zero(v25, *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v25, a1);
        }
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(*((_QWORD *)&v25 + 1), *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v25 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 56LL) )
      {
        a2 = a1 + 304;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 296) + 56LL))(a1, a1 + 304);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 40LL) )
      {
        *(_QWORD *)&v28 = 0LL;
        v19 = 0;
        LODWORD(v23) = 0;
        v29 = 0LL;
        a2 = a1;
        v28 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 296) + 20LL) + 32,
                                  a1);
        if ( (_QWORD)v28 )
        {
          while ( v29 < *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 32LL);
            if ( v29 )
            {
              EVP_DigestUpdate(v33, v28, v29);
            }
            else
            {
              EVP_DigestUpdate(v33, "B", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v28 + v29;
            EVP_DigestFinal(v33, v28 + v29, 0LL);
            EVP_MD_CTX_free(v33);
            v29 += 32LL;
          }
        }
        if ( !(_QWORD)v28 )
        {
          v20 = -5;
          goto LABEL_183;
        }
        v30 = 0LL;
        if ( !*((_QWORD *)&v28 + 1) )
          *((_QWORD *)&v28 + 1) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 296) + 24LL) + 32,
                                    a1);
        if ( *((_QWORD *)&v28 + 1) )
        {
          while ( v30 < *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 32LL);
            if ( v30 )
            {
              EVP_DigestUpdate(v33, *((_QWORD *)&v28 + 1), v30);
            }
            else
            {
              EVP_DigestUpdate(v33, "D", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(v33, *((_QWORD *)&v28 + 1) + v30, 0LL);
            EVP_MD_CTX_free(v33);
            v30 += 32LL;
          }
        }
        if ( !*((_QWORD *)&v28 + 1) )
        {
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v28, a1);
          v20 = -5;
          goto LABEL_183;
        }
        a2 = *(_QWORD *)(a1 + 296);
        if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, int *, _QWORD, __int64 *, _QWORD, signed __int64))(*(_QWORD *)(a1 + 296) + 40LL))(
               a1,
               a2,
               v28,
               &v19,
               *((_QWORD *)&v28 + 1),
               &v23,
               0LL,
               a1 + 304) )
        {
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v28, a1);
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v28 + 1), a1);
          v20 = -5;
          goto LABEL_183;
        }
        if ( v19 )
        {
          _libssh2_explicit_zero(v28, *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v28, a1);
        }
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(*((_QWORD *)&v28 + 1), *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v28 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 32LL) )
      {
        a2 = a1 + 440;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 424) + 32LL))(a1, a1 + 440);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 16LL) )
      {
        *(_QWORD *)&v31 = 0LL;
        LODWORD(v23) = 0;
        a2 = a1;
        v31 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 424) + 12LL) + 32,
                                  a1);
        if ( (_QWORD)v31 )
        {
          while ( *((_QWORD *)&v31 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 424) + 12LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 32LL);
            if ( *((_QWORD *)&v31 + 1) )
            {
              EVP_DigestUpdate(v33, v31, *((_QWORD *)&v31 + 1));
            }
            else
            {
              EVP_DigestUpdate(v33, "E", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v31 + *((_QWORD *)&v31 + 1);
            EVP_DigestFinal(v33, v31 + *((_QWORD *)&v31 + 1), 0LL);
            EVP_MD_CTX_free(v33);
            *((_QWORD *)&v31 + 1) += 32LL;
          }
        }
        if ( !(_QWORD)v31 )
        {
          v20 = -5;
          goto LABEL_183;
        }
        a2 = v31;
        (*(void ( **)(signed __int64, _QWORD, __int64 *, signed __int64))(*(_QWORD *)(a1 + 424) + 16LL))(
          a1,
          v31,
          &v23,
          a1 + 440);
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(v31, *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v31, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32LL) )
      {
        a2 = a1 + 328;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 312) + 32LL))(a1, a1 + 328);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16LL) )
      {
        *(_QWORD *)&v32 = 0LL;
        LODWORD(v23) = 0;
        a2 = a1;
        v32 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 312) + 12LL) + 32,
                                  a1);
        if ( (_QWORD)v32 )
        {
          while ( *((_QWORD *)&v32 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 312) + 12LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(a9 + 176), *(_QWORD *)(a9 + 200));
            EVP_DigestUpdate(v33, a9 + 32, 32LL);
            if ( *((_QWORD *)&v32 + 1) )
            {
              EVP_DigestUpdate(v33, v32, *((_QWORD *)&v32 + 1));
            }
            else
            {
              EVP_DigestUpdate(v33, "F", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v32 + *((_QWORD *)&v32 + 1);
            EVP_DigestFinal(v33, v32 + *((_QWORD *)&v32 + 1), 0LL);
            EVP_MD_CTX_free(v33);
            *((_QWORD *)&v32 + 1) += 32LL;
          }
        }
        if ( !(_QWORD)v32 )
        {
          v20 = -5;
          goto LABEL_183;
        }
        a2 = v32;
        (*(void ( **)(signed __int64, _QWORD, __int64 *, signed __int64))(*(_QWORD *)(a1 + 312) + 16LL))(
          a1,
          v32,
          &v23,
          a1 + 328);
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(v32, *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v32, a1);
        }
      }
      if ( *(_QWORD *)(a1 + 448) && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 40LL) )
      {
        a2 = 1LL;
        (*(void ( **)(signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 448) + 40LL))(
          a1,
          1LL,
          a1 + 456);
      }
      if ( *(_QWORD *)(a1 + 448)
        && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 16LL)
        && (a2 = 1LL,
            (*(unsigned int ( **)(signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 448) + 16LL))(
              a1,
              1LL,
              a1 + 456)) )
      {
        v20 = -5;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 336) && *(_QWORD *)(*(_QWORD *)(a1 + 336) + 40LL) )
        {
          a2 = 0LL;
          (*(void ( **)(signed __int64, _QWORD, signed __int64))(*(_QWORD *)(a1 + 336) + 40LL))(
            a1,
            0LL,
            a1 + 344);
        }
        if ( *(_QWORD *)(a1 + 336) )
        {
          if ( *(_QWORD *)(*(_QWORD *)(a1 + 336) + 16LL) )
          {
            a2 = 0LL;
            if ( (*(unsigned int ( **)(signed __int64, _QWORD, signed __int64))(*(_QWORD *)(a1 + 336) + 16LL))(
                   a1,
                   0LL,
                   a1 + 344) )
            {
              v20 = -5;
            }
          }
        }
      }
      goto LABEL_183;
    }
    a2 = v21;
    v20 = _libssh2_error(a1, v21, "Timed out waiting for NEWKEYS");
  }
LABEL_183:
  _libssh2_dh_dtor(a9 + 136, a2);
  BN_clear_free(*(_QWORD *)(a9 + 144), a2);
  *(_QWORD *)(a9 + 144) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 152), a2);
  *(_QWORD *)(a9 + 152) = 0LL;
  BN_clear_free(*(_QWORD *)(a9 + 160), a2);
  *(_QWORD *)(a9 + 160) = 0LL;
  BN_CTX_free(*(_QWORD *)(a9 + 128), a2);
  *(_QWORD *)(a9 + 128) = 0LL;
  if ( *(_QWORD *)(a9 + 8) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 8), a1);
    *(_QWORD *)(a9 + 8) = 0LL;
  }
  if ( *(_QWORD *)(a9 + 16) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 16), a1);
    *(_QWORD *)(a9 + 16) = 0LL;
  }
  if ( *(_QWORD *)(a9 + 176) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a9 + 176), a1);
    *(_QWORD *)(a9 + 176) = 0LL;
  }
  *(_DWORD *)a9 = 0;
  return v20;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8A00: using guessed type __int64  _libssh2_copy_string(_QWORD, _QWORD, _QWORD, _QWORD);
// 8AD0: using guessed type __int64  BN_CTX_free(_QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8B30: using guessed type __int64  _libssh2_dh_dtor(_QWORD, _QWORD);
// 8BF0: using guessed type __int64  _libssh2_sha256_init(_QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 9040: using guessed type __int64  _libssh2_dh_key_pair(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 92F0: using guessed type __int64  _libssh2_dh_init(_QWORD);
// 9320: using guessed type __int64 BN_CTX_new(void);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9600: using guessed type __int64  _libssh2_dh_secret(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9770: using guessed type __int64  _libssh2_packet_burn(_QWORD, _QWORD);
// 9780: using guessed type __int64  BN_bn2bin(_QWORD, _QWORD);
// 9790: using guessed type __int64  _libssh2_sha1_init(_QWORD);
// 9920: using guessed type __int64  _libssh2_md5_init(_QWORD);

//----- (000000000001DCD1) ----------------------------------------------------
signed __int64  sub_1DCD1(signed __int64 a1, __int64 a2)
{
  signed __int64 v2; // rsi
  __int64 v4; // [rsp+0h] [rbp-20h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  v4 = a2;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    BN_set_word(*(_QWORD *)(a2 + 280), 2LL);
    BN_bin2bn(&unk_47060, 128LL, *(_QWORD *)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v2 = *(_QWORD *)(a2 + 280);
  v5 = sub_19461(a1, v2, *(_QWORD *)(v4 + 272), 0x80u, 30, 0x1Fu, 0LL, 0LL, v4 + 24);
  if ( v5 == -37 )
    return 4294967259LL;
  BN_clear_free(*(_QWORD *)(v4 + 272), v2);
  *(_QWORD *)(v4 + 272) = 0LL;
  BN_clear_free(*(_QWORD *)(v4 + 280), v2);
  *(_QWORD *)(v4 + 280) = 0LL;
  *(_DWORD *)v4 = 0;
  return v5;
}
// 8C90: using guessed type __int64  BN_set_word(_QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);

//----- (000000000001DDFB) ----------------------------------------------------
signed __int64  sub_1DDFB(__int64 a1, __int64 a2, __int64 ( *a3)(__int64, __int64, _QWORD, signed __int64, signed __int64, signed __int64, _QWORD, _QWORD, signed __int64))
{
  __int64 v3; // rsi
  __int64 ( *v5)(__int64, __int64, _QWORD, signed __int64, signed __int64, signed __int64, _QWORD, _QWORD, signed __int64); // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+10h] [rbp-20h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  v6 = a2;
  v5 = a3;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    BN_set_word(*(_QWORD *)(a2 + 280), 2LL);
    BN_bin2bn(&unk_470E0, 256LL, *(_QWORD *)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v3 = *(_QWORD *)(a2 + 280);
  v7 = v5(a1, v3, *(_QWORD *)(v6 + 272), 256LL, 30LL, 31LL, 0LL, 0LL, v6 + 24);
  if ( v7 == -37 )
    return 4294967259LL;
  *(_DWORD *)v6 = 0;
  BN_clear_free(*(_QWORD *)(v6 + 272), v3);
  *(_QWORD *)(v6 + 272) = 0LL;
  BN_clear_free(*(_QWORD *)(v6 + 280), v3);
  *(_QWORD *)(v6 + 280) = 0LL;
  return v7;
}
// 8C90: using guessed type __int64  BN_set_word(_QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);

//----- (000000000001DF27) ----------------------------------------------------
signed __int64  sub_1DF27(__int64 a1, __int64 a2)
{
  return sub_1DDFB(
           a1,
           a2,
           (__int64 ( *)(__int64, __int64, _QWORD, signed __int64, signed __int64, signed __int64, _QWORD, _QWORD, signed __int64))sub_19461);
}

//----- (000000000001DF53) ----------------------------------------------------
signed __int64  sub_1DF53(__int64 a1, __int64 a2)
{
  return sub_1DDFB(
           a1,
           a2,
           (__int64 ( *)(__int64, __int64, _QWORD, signed __int64, signed __int64, signed __int64, _QWORD, _QWORD, signed __int64))sub_1B899);
}

//----- (000000000001DF7F) ----------------------------------------------------
signed __int64  sub_1DF7F(signed __int64 a1, signed __int64 a2)
{
  signed __int64 v3; // [rsp+0h] [rbp-60h]
  unsigned int v4; // [rsp+18h] [rbp-48h]
  unsigned int v5; // [rsp+1Ch] [rbp-44h]
  unsigned int v6; // [rsp+1Ch] [rbp-44h]
  __int64 v7; // [rsp+20h] [rbp-40h]
  __int64 v8; // [rsp+28h] [rbp-38h]
  __int64 v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v3 = a2;
  v14 = __readfsqword(0x28u);
  v4 = 0;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    *(_BYTE *)(a2 + 288) = 34;
    _libssh2_htonu32(a2 + 289, 1024LL);
    _libssh2_htonu32(a2 + 293, 1536LL);
    a2 = 2048LL;
    _libssh2_htonu32(v3 + 297, 2048LL);
    *(_QWORD *)(v3 + 552) = 13LL;
    *(_DWORD *)v3 = 2;
  }
  if ( *(_DWORD *)v3 == 2 )
  {
    a2 = v3 + 288;
    v5 = _libssh2_transport_send(a1, v3 + 288, *(_QWORD *)(v3 + 552), 0LL, 0LL);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 )
    {
      a2 = v5;
      v4 = _libssh2_error(a1, v5, "Unable to send Group Exchange Request");
      goto LABEL_25;
    }
    *(_DWORD *)v3 = 3;
  }
  if ( *(_DWORD *)v3 == 3 )
  {
    a2 = 31LL;
    v6 = _libssh2_packet_require(a1, 31LL, v3 + 544, v3 + 560, 0LL, 0LL, 0LL, v3 + 8);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v6 )
    {
      a2 = v6;
      v4 = _libssh2_error(a1, v6, "Timeout waiting for GEX_GROUP reply");
      goto LABEL_25;
    }
    *(_DWORD *)v3 = 4;
  }
  if ( *(_DWORD *)v3 == 4 )
  {
    if ( *(_QWORD *)(v3 + 560) > 8uLL )
    {
      v11 = *(_QWORD *)(v3 + 544);
      v12 = v11;
      v13 = *(_QWORD *)(v3 + 560);
      v12 = v11 + 1;
      if ( (unsigned int)_libssh2_get_bignum_bytes(&v11, &v9, &v7) )
      {
        a2 = 4294967282LL;
        v4 = _libssh2_error(a1, 4294967282LL, "Unexpected value");
      }
      else if ( (unsigned int)_libssh2_get_bignum_bytes(&v11, &v10, &v8) )
      {
        a2 = 4294967282LL;
        v4 = _libssh2_error(a1, 4294967282LL, "Unexpected value");
      }
      else
      {
        BN_bin2bn(v9, (unsigned int)v7, *(_QWORD *)(v3 + 272));
        BN_bin2bn(v10, (unsigned int)v8, *(_QWORD *)(v3 + 280));
        v4 = sub_19461(
               a1,
               *(_QWORD *)(v3 + 280),
               *(_QWORD *)(v3 + 272),
               v7,
               32,
               0x21u,
               *(_QWORD *)(v3 + 544) + 1LL,
               *(_QWORD *)(v3 + 560) - 1LL,
               v3 + 24);
        if ( v4 == -37 )
          return 4294967259LL;
        a2 = a1;
        (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(v3 + 544), a1);
      }
    }
    else
    {
      a2 = 4294967282LL;
      v4 = _libssh2_error(a1, 4294967282LL, "Unexpected key length");
    }
  }
LABEL_25:
  *(_DWORD *)v3 = 0;
  BN_clear_free(*(_QWORD *)(v3 + 280), a2);
  *(_QWORD *)(v3 + 280) = 0LL;
  BN_clear_free(*(_QWORD *)(v3 + 272), a2);
  *(_QWORD *)(v3 + 272) = 0LL;
  return v4;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B60: using guessed type __int64  _libssh2_get_bignum_bytes(_QWORD, _QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (000000000001E380) ----------------------------------------------------
signed __int64  sub_1E380(signed __int64 a1, signed __int64 a2)
{
  signed __int64 v3; // [rsp+0h] [rbp-60h]
  unsigned int v4; // [rsp+18h] [rbp-48h]
  unsigned int v5; // [rsp+1Ch] [rbp-44h]
  unsigned int v6; // [rsp+1Ch] [rbp-44h]
  __int64 v7; // [rsp+20h] [rbp-40h]
  __int64 v8; // [rsp+28h] [rbp-38h]
  __int64 v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp-10h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v3 = a2;
  v14 = __readfsqword(0x28u);
  v4 = 0;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 272) = BN_new(a1, a2);
    *(_QWORD *)(a2 + 280) = BN_new(a1, a2);
    *(_BYTE *)(a2 + 288) = 34;
    _libssh2_htonu32(a2 + 289, 1024LL);
    _libssh2_htonu32(a2 + 293, 1536LL);
    a2 = 2048LL;
    _libssh2_htonu32(v3 + 297, 2048LL);
    *(_QWORD *)(v3 + 552) = 13LL;
    *(_DWORD *)v3 = 2;
  }
  if ( *(_DWORD *)v3 == 2 )
  {
    a2 = v3 + 288;
    v5 = _libssh2_transport_send(a1, v3 + 288, *(_QWORD *)(v3 + 552), 0LL, 0LL);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 )
    {
      a2 = v5;
      v4 = _libssh2_error(a1, v5, "Unable to send Group Exchange Request SHA256");
      goto LABEL_25;
    }
    *(_DWORD *)v3 = 3;
  }
  if ( *(_DWORD *)v3 == 3 )
  {
    a2 = 31LL;
    v6 = _libssh2_packet_require(a1, 31LL, v3 + 544, v3 + 560, 0LL, 0LL, 0LL, v3 + 8);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v6 )
    {
      a2 = v6;
      v4 = _libssh2_error(a1, v6, "Timeout waiting for GEX_GROUP reply SHA256");
      goto LABEL_25;
    }
    *(_DWORD *)v3 = 4;
  }
  if ( *(_DWORD *)v3 == 4 )
  {
    if ( *(_QWORD *)(v3 + 560) > 8uLL )
    {
      v11 = *(_QWORD *)(v3 + 544);
      v12 = v11;
      v13 = *(_QWORD *)(v3 + 560);
      v12 = v11 + 1;
      if ( (unsigned int)_libssh2_get_bignum_bytes(&v11, &v7, &v9) )
      {
        a2 = 4294967282LL;
        v4 = _libssh2_error(a1, 4294967282LL, "Unexpected value");
      }
      else if ( (unsigned int)_libssh2_get_bignum_bytes(&v11, &v8, &v10) )
      {
        a2 = 4294967282LL;
        v4 = _libssh2_error(a1, 4294967282LL, "Unexpected value");
      }
      else
      {
        BN_bin2bn(v7, (unsigned int)v9, *(_QWORD *)(v3 + 272));
        BN_bin2bn(v8, (unsigned int)v10, *(_QWORD *)(v3 + 280));
        v4 = sub_1B899(
               a1,
               *(_QWORD *)(v3 + 280),
               *(_QWORD *)(v3 + 272),
               v9,
               32,
               0x21u,
               *(_QWORD *)(v3 + 544) + 1LL,
               *(_QWORD *)(v3 + 560) - 1LL,
               v3 + 24);
        if ( v4 == -37 )
          return 4294967259LL;
        a2 = a1;
        (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(v3 + 544), a1);
      }
    }
    else
    {
      a2 = 4294967282LL;
      v4 = _libssh2_error(a1, 4294967282LL, "Unexpected key length");
    }
  }
LABEL_25:
  *(_DWORD *)v3 = 0;
  BN_clear_free(*(_QWORD *)(v3 + 280), a2);
  *(_QWORD *)(v3 + 280) = 0LL;
  BN_clear_free(*(_QWORD *)(v3 + 272), a2);
  *(_QWORD *)(v3 + 272) = 0LL;
  return v4;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B60: using guessed type __int64  _libssh2_get_bignum_bytes(_QWORD, _QWORD, _QWORD);
// 8CD0: using guessed type __int64  BN_bin2bn(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (000000000001E781) ----------------------------------------------------
signed __int64  sub_1E781(const char *a1, signed int *a2)
{
  unsigned int v3; // [rsp+18h] [rbp-8h]
  signed int v4; // [rsp+1Ch] [rbp-4h]

  v3 = 0;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !strcmp(a1, "ecdh-sha2-nistp256") )
  {
    v4 = 415;
  }
  else if ( !strcmp(a1, "ecdh-sha2-nistp384") )
  {
    v4 = 715;
  }
  else if ( !strcmp(a1, "ecdh-sha2-nistp521") )
  {
    v4 = 716;
  }
  else
  {
    v3 = -1;
  }
  if ( !v3 )
  {
    if ( a2 )
      *a2 = v4;
  }
  return v3;
}

//----- (000000000001E82B) ----------------------------------------------------
signed __int64  sub_1E82B(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  int v9; // eax
  size_t v10; // rax
  unsigned int v11; // eax
  size_t v12; // rax
  int v13; // eax
  size_t v14; // rax
  unsigned int v15; // eax
  size_t v16; // rax
  int v17; // eax
  size_t v18; // rax
  unsigned int v19; // eax
  size_t v20; // rax
  __int64 v21; // [rsp+10h] [rbp-140h]
  __int64 v22; // [rsp+18h] [rbp-138h]
  __int64 v23; // [rsp+28h] [rbp-128h]
  int v24; // [rsp+34h] [rbp-11Ch]
  int v25; // [rsp+48h] [rbp-108h]
  int v26; // [rsp+4Ch] [rbp-104h]
  unsigned int v27; // [rsp+50h] [rbp-100h]
  unsigned int v28; // [rsp+54h] [rbp-FCh]
  __int64 v29; // [rsp+58h] [rbp-F8h]
  size_t n; // [rsp+60h] [rbp-F0h]
  __int64 v31; // [rsp+68h] [rbp-E8h]
  __int64 v32; // [rsp+70h] [rbp-E0h]
  unsigned __int64 v33; // [rsp+78h] [rbp-D8h]
  unsigned __int64 v34; // [rsp+80h] [rbp-D0h]
  unsigned __int64 v35; // [rsp+88h] [rbp-C8h]
  unsigned __int64 v36; // [rsp+90h] [rbp-C0h]
  unsigned __int64 v37; // [rsp+98h] [rbp-B8h]
  unsigned __int64 v38; // [rsp+A0h] [rbp-B0h]
  __int64 v39; // [rsp+A8h] [rbp-A8h]
  __int64 v40; // [rsp+B0h] [rbp-A0h]
  unsigned __int64 v41; // [rsp+B8h] [rbp-98h]
  unsigned __int64 v42; // [rsp+C0h] [rbp-90h]
  unsigned __int64 v43; // [rsp+C8h] [rbp-88h]
  unsigned __int64 v44; // [rsp+D0h] [rbp-80h]
  unsigned __int64 v45; // [rsp+D8h] [rbp-78h]
  unsigned __int64 v46; // [rsp+E0h] [rbp-70h]
  __int64 v47; // [rsp+E8h] [rbp-68h]
  unsigned __int64 v48; // [rsp+F0h] [rbp-60h]
  unsigned __int64 v49; // [rsp+F8h] [rbp-58h]
  unsigned __int64 v50; // [rsp+100h] [rbp-50h]
  __int64 v51; // [rsp+108h] [rbp-48h]
  unsigned __int64 v52; // [rsp+110h] [rbp-40h]
  unsigned __int64 v53; // [rsp+118h] [rbp-38h]
  unsigned __int64 v54; // [rsp+120h] [rbp-30h]
  void *src; // [rsp+128h] [rbp-28h]
  __int64 v56; // [rsp+130h] [rbp-20h]
  void *v57; // [rsp+138h] [rbp-18h]
  __int64 v58; // [rsp+140h] [rbp-10h]
  unsigned __int64 v59; // [rsp+148h] [rbp-8h]

  v24 = a2;
  v23 = a3;
  v22 = a5;
  v21 = a6;
  v59 = __readfsqword(0x28u);
  v27 = 0;
  if ( a4 <= 4 )
    return (unsigned int)_libssh2_error(a1, 4294967286LL, "Host key data is too short");
  if ( !*(_DWORD *)a8 )
  {
    *(_QWORD *)(a8 + 160) = BN_new(a1, a2);
    *(_DWORD *)a8 = 2;
  }
  if ( *(_DWORD *)a8 == 2 )
  {
    src = (void *)(v23 + 1);
    *(_DWORD *)(a1 + 184) = _libssh2_ntohu32(v23 + 1);
    src = (char *)src + 4;
    *(_QWORD *)(a1 + 176) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(unsigned int *)(a1 + 184), a1);
    if ( !*(_QWORD *)(a1 + 176) )
    {
      a2 = 4294967290LL;
      v27 = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for a copy of the host key");
      goto LABEL_317;
    }
    memcpy(*(void **)(a1 + 176), src, *(unsigned int *)(a1 + 184));
    src = (char *)src + *(unsigned int *)(a1 + 184);
    if ( (unsigned int)_libssh2_md5_init(&v29) )
    {
      EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v29, a1 + 188, 0LL);
      EVP_MD_CTX_free(v29);
      *(_DWORD *)(a1 + 204) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 204) = 0;
    }
    if ( (unsigned int)_libssh2_sha1_init(&v29) )
    {
      EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v29, a1 + 208, 0LL);
      EVP_MD_CTX_free(v29);
      *(_DWORD *)(a1 + 228) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 228) = 0;
    }
    if ( (unsigned int)_libssh2_sha256_init(&v29) )
    {
      EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v29, a1 + 232, 0LL);
      EVP_MD_CTX_free(v29);
      *(_DWORD *)(a1 + 264) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 264) = 0;
    }
    if ( (*(unsigned int ( **)(__int64, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 160) + 16LL))(
           a1,
           *(_QWORD *)(a1 + 176),
           *(unsigned int *)(a1 + 184),
           a1 + 168) )
    {
      a2 = 4294967286LL;
      v27 = _libssh2_error(a1, 4294967286LL, "Unable to initialize hostkey importer");
      goto LABEL_317;
    }
    v56 = (unsigned int)_libssh2_ntohu32(src);
    src = (char *)src + 4;
    v57 = src;
    src = (char *)src + v56;
    v58 = (unsigned int)_libssh2_ntohu32(src);
    src = (char *)src + 4;
    *(_QWORD *)(a8 + 184) = src;
    *(_QWORD *)(a8 + 208) = v58;
    src = (char *)src + v58;
    v28 = _libssh2_ecdh_gen_k(a8 + 160, a7, v57, v56);
    if ( v28 )
    {
      a2 = 4294967291LL;
      v27 = _libssh2_error(a1, 4294967291LL, "Unable to create ECDH shared secret");
      goto LABEL_317;
    }
    *(_QWORD *)(a8 + 200) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(a8 + 160)) + 7) / 8 + 5;
    if ( BN_num_bits(*(_QWORD *)(a8 + 160)) & 7 )
      --*(_QWORD *)(a8 + 200);
    *(_QWORD *)(a8 + 176) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a8 + 200), a1);
    if ( !*(_QWORD *)(a8 + 176) )
    {
      a2 = 4294967290LL;
      v27 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for K");
      goto LABEL_317;
    }
    _libssh2_htonu32(*(_QWORD *)(a8 + 176), (unsigned int)*(_QWORD *)(a8 + 200) - 4);
    if ( BN_num_bits(*(_QWORD *)(a8 + 160)) & 7 )
    {
      a2 = *(_QWORD *)(a8 + 176) + 4LL;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a8 + 176) + 4LL) = 0;
      a2 = *(_QWORD *)(a8 + 176) + 5LL;
    }
    BN_bn2bin(*(_QWORD *)(a8 + 160), a2);
    switch ( v24 )
    {
      case 715:
        *(_QWORD *)(a8 + 216) = &v29;
        _libssh2_sha384_init(&v29);
        if ( *(_QWORD *)(a1 + 384) )
        {
          v13 = strlen(*(const char **)(a1 + 384));
          _libssh2_htonu32(a8 + 32, (unsigned int)(v13 - 2));
          EVP_DigestUpdate(v29, a8 + 32, 4LL);
          v14 = strlen(*(const char **)(a1 + 384));
          EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 384), v14 - 2);
        }
        else
        {
          _libssh2_htonu32(a8 + 32, 25LL);
          EVP_DigestUpdate(v29, a8 + 32, 4LL);
          EVP_DigestUpdate(v29, "SSH-2.0-libssh2_1.9.0_DEV", 25LL);
        }
        v15 = strlen(*(const char **)(a1 + 272));
        _libssh2_htonu32(a8 + 32, v15);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        v16 = strlen(*(const char **)(a1 + 272));
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 272), v16);
        _libssh2_htonu32(a8 + 32, (unsigned int)*(_QWORD *)(a1 + 400));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400));
        _libssh2_htonu32(a8 + 32, (unsigned int)*(_QWORD *)(a1 + 288));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 288));
        _libssh2_htonu32(a8 + 32, *(unsigned int *)(a1 + 184));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
        _libssh2_htonu32(a8 + 32, (unsigned int)v21);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, v22, v21);
        _libssh2_htonu32(a8 + 32, (unsigned int)v56);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, v57, v56);
        EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
        EVP_DigestFinal(v29, a8 + 32, 0LL);
        EVP_MD_CTX_free(v29);
        a2 = *(_QWORD *)(a8 + 184);
        if ( (*(unsigned int ( **)(__int64, __int64, _QWORD, __int64, signed __int64, __int64))(*(_QWORD *)(a1 + 160) + 40LL))(
               a1,
               a2,
               *(_QWORD *)(a8 + 208),
               a8 + 32,
               48LL,
               a1 + 168) )
        {
          v28 = -1;
        }
        break;
      case 716:
        *(_QWORD *)(a8 + 216) = &v29;
        _libssh2_sha512_init(&v29);
        if ( *(_QWORD *)(a1 + 384) )
        {
          v17 = strlen(*(const char **)(a1 + 384));
          _libssh2_htonu32(a8 + 32, (unsigned int)(v17 - 2));
          EVP_DigestUpdate(v29, a8 + 32, 4LL);
          v18 = strlen(*(const char **)(a1 + 384));
          EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 384), v18 - 2);
        }
        else
        {
          _libssh2_htonu32(a8 + 32, 25LL);
          EVP_DigestUpdate(v29, a8 + 32, 4LL);
          EVP_DigestUpdate(v29, "SSH-2.0-libssh2_1.9.0_DEV", 25LL);
        }
        v19 = strlen(*(const char **)(a1 + 272));
        _libssh2_htonu32(a8 + 32, v19);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        v20 = strlen(*(const char **)(a1 + 272));
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 272), v20);
        _libssh2_htonu32(a8 + 32, (unsigned int)*(_QWORD *)(a1 + 400));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400));
        _libssh2_htonu32(a8 + 32, (unsigned int)*(_QWORD *)(a1 + 288));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 288));
        _libssh2_htonu32(a8 + 32, *(unsigned int *)(a1 + 184));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
        _libssh2_htonu32(a8 + 32, (unsigned int)v21);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, v22, v21);
        _libssh2_htonu32(a8 + 32, (unsigned int)v56);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, v57, v56);
        EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
        EVP_DigestFinal(v29, a8 + 32, 0LL);
        EVP_MD_CTX_free(v29);
        a2 = *(_QWORD *)(a8 + 184);
        if ( (*(unsigned int ( **)(__int64, __int64, _QWORD, __int64, signed __int64, __int64))(*(_QWORD *)(a1 + 160) + 40LL))(
               a1,
               a2,
               *(_QWORD *)(a8 + 208),
               a8 + 32,
               64LL,
               a1 + 168) )
        {
          v28 = -1;
        }
        break;
      case 415:
        *(_QWORD *)(a8 + 216) = &v29;
        _libssh2_sha256_init(&v29);
        if ( *(_QWORD *)(a1 + 384) )
        {
          v9 = strlen(*(const char **)(a1 + 384));
          _libssh2_htonu32(a8 + 32, (unsigned int)(v9 - 2));
          EVP_DigestUpdate(v29, a8 + 32, 4LL);
          v10 = strlen(*(const char **)(a1 + 384));
          EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 384), v10 - 2);
        }
        else
        {
          _libssh2_htonu32(a8 + 32, 25LL);
          EVP_DigestUpdate(v29, a8 + 32, 4LL);
          EVP_DigestUpdate(v29, "SSH-2.0-libssh2_1.9.0_DEV", 25LL);
        }
        v11 = strlen(*(const char **)(a1 + 272));
        _libssh2_htonu32(a8 + 32, v11);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        v12 = strlen(*(const char **)(a1 + 272));
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 272), v12);
        _libssh2_htonu32(a8 + 32, (unsigned int)*(_QWORD *)(a1 + 400));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400));
        _libssh2_htonu32(a8 + 32, (unsigned int)*(_QWORD *)(a1 + 288));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 288));
        _libssh2_htonu32(a8 + 32, *(unsigned int *)(a1 + 184));
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
        _libssh2_htonu32(a8 + 32, (unsigned int)v21);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, v22, v21);
        _libssh2_htonu32(a8 + 32, (unsigned int)v56);
        EVP_DigestUpdate(v29, a8 + 32, 4LL);
        EVP_DigestUpdate(v29, v57, v56);
        EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
        EVP_DigestFinal(v29, a8 + 32, 0LL);
        EVP_MD_CTX_free(v29);
        a2 = *(_QWORD *)(a8 + 184);
        if ( (*(unsigned int ( **)(__int64, __int64, _QWORD, __int64, signed __int64, __int64))(*(_QWORD *)(a1 + 160) + 40LL))(
               a1,
               a2,
               *(_QWORD *)(a8 + 208),
               a8 + 32,
               32LL,
               a1 + 168) )
        {
          v28 = -1;
        }
        break;
    }
    if ( v28 )
    {
      a2 = 4294967285LL;
      v27 = _libssh2_error(a1, 4294967285LL, "Unable to verify hostkey signature");
      goto LABEL_317;
    }
    *(_BYTE *)(a8 + 96) = 21;
    *(_DWORD *)a8 = 3;
  }
  if ( *(_DWORD *)a8 == 3 )
  {
    a2 = a8 + 96;
    v28 = _libssh2_transport_send(a1, a8 + 96, 1LL, 0LL, 0LL);
    if ( v28 == -37 )
      return 4294967259LL;
    if ( v28 )
    {
      a2 = v28;
      v27 = _libssh2_error(a1, v28, "Unable to send NEWKEYS message");
      goto LABEL_317;
    }
    *(_DWORD *)a8 = 5;
  }
  if ( *(_DWORD *)a8 == 5 )
  {
    v28 = _libssh2_packet_require(a1, 21LL, a8 + 24, a8 + 120, 0LL, 0LL, 0LL, a8 + 224);
    if ( v28 == -37 )
      return 4294967259LL;
    if ( !v28 )
    {
      *(_DWORD *)(a1 + 104) |= 2u;
      a2 = a1;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a8 + 24), a1);
      if ( !*(_QWORD *)(a1 + 136) )
      {
        n = 0LL;
        switch ( v24 )
        {
          case 415:
            n = 32LL;
            break;
          case 715:
            n = 48LL;
            break;
          case 716:
            n = 64LL;
            break;
          default:
            a2 = 4294967291LL;
            v27 = _libssh2_error(a1, 4294967291LL, "Unknown SHA digest for EC curve");
            goto LABEL_317;
        }
        *(_QWORD *)(a1 + 136) = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(n, a1);
        if ( !*(_QWORD *)(a1 + 136) )
        {
          a2 = 4294967290LL;
          v27 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for SHA digest");
          goto LABEL_317;
        }
        a2 = a8 + 32;
        memcpy(*(void **)(a1 + 136), (const void *)(a8 + 32), n);
        *(_DWORD *)(a1 + 144) = n;
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 56LL) )
      {
        a2 = a1 + 416;
        (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 408) + 56LL))(a1, a1 + 416);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 40LL) )
      {
        v31 = 0LL;
        v32 = 0LL;
        v25 = 0;
        v26 = 0;
        switch ( v24 )
        {
          case 415:
            v33 = 0LL;
            if ( !v31 )
            {
              a2 = a1;
              v31 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 20LL) + 32,
                      a1);
            }
            if ( v31 )
            {
              while ( v33 < *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL) )
              {
                _libssh2_sha256_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 32LL);
                if ( v33 )
                {
                  EVP_DigestUpdate(v29, v31, v33);
                }
                else
                {
                  EVP_DigestUpdate(v29, "A", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v31 + v33;
                EVP_DigestFinal(v29, v31 + v33, 0LL);
                EVP_MD_CTX_free(v29);
                v33 += 32LL;
              }
            }
            break;
          case 715:
            v34 = 0LL;
            if ( !v31 )
            {
              a2 = a1;
              v31 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 20LL) + 48,
                      a1);
            }
            if ( v31 )
            {
              while ( v34 < *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL) )
              {
                _libssh2_sha384_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 48LL);
                if ( v34 )
                {
                  EVP_DigestUpdate(v29, v31, v34);
                }
                else
                {
                  EVP_DigestUpdate(v29, "A", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v31 + v34;
                EVP_DigestFinal(v29, v31 + v34, 0LL);
                EVP_MD_CTX_free(v29);
                v34 += 48LL;
              }
            }
            break;
          case 716:
            v35 = 0LL;
            if ( !v31 )
            {
              a2 = a1;
              v31 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 20LL) + 64,
                      a1);
            }
            if ( v31 )
            {
              while ( v35 < *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL) )
              {
                _libssh2_sha512_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 64LL);
                if ( v35 )
                {
                  EVP_DigestUpdate(v29, v31, v35);
                }
                else
                {
                  EVP_DigestUpdate(v29, "A", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v31 + v35;
                EVP_DigestFinal(v29, v31 + v35, 0LL);
                EVP_MD_CTX_free(v29);
                v35 += 64LL;
              }
            }
            break;
        }
        if ( !v31 )
        {
          v27 = -1;
          goto LABEL_317;
        }
        switch ( v24 )
        {
          case 415:
            v36 = 0LL;
            if ( !v32 )
              v32 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 24LL) + 32,
                      a1);
            if ( v32 )
            {
              while ( v36 < *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL) )
              {
                _libssh2_sha256_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 32LL);
                if ( v36 )
                {
                  EVP_DigestUpdate(v29, v32, v36);
                }
                else
                {
                  EVP_DigestUpdate(v29, "C", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                EVP_DigestFinal(v29, v32 + v36, 0LL);
                EVP_MD_CTX_free(v29);
                v36 += 32LL;
              }
            }
            break;
          case 715:
            v37 = 0LL;
            if ( !v32 )
              v32 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 24LL) + 48,
                      a1);
            if ( v32 )
            {
              while ( v37 < *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL) )
              {
                _libssh2_sha384_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 48LL);
                if ( v37 )
                {
                  EVP_DigestUpdate(v29, v32, v37);
                }
                else
                {
                  EVP_DigestUpdate(v29, "C", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                EVP_DigestFinal(v29, v32 + v37, 0LL);
                EVP_MD_CTX_free(v29);
                v37 += 48LL;
              }
            }
            break;
          case 716:
            v38 = 0LL;
            if ( !v32 )
              v32 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 24LL) + 64,
                      a1);
            if ( v32 )
            {
              while ( v38 < *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL) )
              {
                _libssh2_sha512_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 64LL);
                if ( v38 )
                {
                  EVP_DigestUpdate(v29, v32, v38);
                }
                else
                {
                  EVP_DigestUpdate(v29, "C", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                EVP_DigestFinal(v29, v32 + v38, 0LL);
                EVP_MD_CTX_free(v29);
                v38 += 64LL;
              }
            }
            break;
        }
        if ( !v32 )
        {
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v31, a1);
          v27 = -5;
          goto LABEL_317;
        }
        a2 = *(_QWORD *)(a1 + 408);
        if ( (*(unsigned int ( **)(__int64, __int64, __int64, int *, __int64, int *, signed __int64, __int64))(*(_QWORD *)(a1 + 408) + 40LL))(
               a1,
               a2,
               v31,
               &v25,
               v32,
               &v26,
               1LL,
               a1 + 416) )
        {
          (*(void ( **)(__int64, __int64))(a1 + 24))(v31, a1);
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v32, a1);
          v27 = -5;
          goto LABEL_317;
        }
        if ( v25 )
        {
          _libssh2_explicit_zero(v31, *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL));
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v31, a1);
        }
        if ( v26 )
        {
          _libssh2_explicit_zero(v32, *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL));
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v32, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 56LL) )
      {
        a2 = a1 + 304;
        (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 296) + 56LL))(a1, a1 + 304);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 40LL) )
      {
        v39 = 0LL;
        v40 = 0LL;
        v25 = 0;
        v26 = 0;
        switch ( v24 )
        {
          case 415:
            v41 = 0LL;
            if ( !v39 )
            {
              a2 = a1;
              v39 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 296) + 20LL) + 32,
                      a1);
            }
            if ( v39 )
            {
              while ( v41 < *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL) )
              {
                _libssh2_sha256_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 32LL);
                if ( v41 )
                {
                  EVP_DigestUpdate(v29, v39, v41);
                }
                else
                {
                  EVP_DigestUpdate(v29, "B", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v39 + v41;
                EVP_DigestFinal(v29, v39 + v41, 0LL);
                EVP_MD_CTX_free(v29);
                v41 += 32LL;
              }
            }
            break;
          case 715:
            v42 = 0LL;
            if ( !v39 )
            {
              a2 = a1;
              v39 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 296) + 20LL) + 48,
                      a1);
            }
            if ( v39 )
            {
              while ( v42 < *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL) )
              {
                _libssh2_sha384_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 48LL);
                if ( v42 )
                {
                  EVP_DigestUpdate(v29, v39, v42);
                }
                else
                {
                  EVP_DigestUpdate(v29, "B", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v39 + v42;
                EVP_DigestFinal(v29, v39 + v42, 0LL);
                EVP_MD_CTX_free(v29);
                v42 += 48LL;
              }
            }
            break;
          case 716:
            v43 = 0LL;
            if ( !v39 )
            {
              a2 = a1;
              v39 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 296) + 20LL) + 64,
                      a1);
            }
            if ( v39 )
            {
              while ( v43 < *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL) )
              {
                _libssh2_sha512_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 64LL);
                if ( v43 )
                {
                  EVP_DigestUpdate(v29, v39, v43);
                }
                else
                {
                  EVP_DigestUpdate(v29, "B", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v39 + v43;
                EVP_DigestFinal(v29, v39 + v43, 0LL);
                EVP_MD_CTX_free(v29);
                v43 += 64LL;
              }
            }
            break;
        }
        if ( !v39 )
        {
          v27 = -5;
          goto LABEL_317;
        }
        switch ( v24 )
        {
          case 415:
            v44 = 0LL;
            if ( !v40 )
              v40 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 296) + 24LL) + 32,
                      a1);
            if ( v40 )
            {
              while ( v44 < *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL) )
              {
                _libssh2_sha256_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 32LL);
                if ( v44 )
                {
                  EVP_DigestUpdate(v29, v40, v44);
                }
                else
                {
                  EVP_DigestUpdate(v29, "D", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                EVP_DigestFinal(v29, v40 + v44, 0LL);
                EVP_MD_CTX_free(v29);
                v44 += 32LL;
              }
            }
            break;
          case 715:
            v45 = 0LL;
            if ( !v40 )
              v40 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 296) + 24LL) + 48,
                      a1);
            if ( v40 )
            {
              while ( v45 < *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL) )
              {
                _libssh2_sha384_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 48LL);
                if ( v45 )
                {
                  EVP_DigestUpdate(v29, v40, v45);
                }
                else
                {
                  EVP_DigestUpdate(v29, "D", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                EVP_DigestFinal(v29, v40 + v45, 0LL);
                EVP_MD_CTX_free(v29);
                v45 += 48LL;
              }
            }
            break;
          case 716:
            v46 = 0LL;
            if ( !v40 )
              v40 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 296) + 24LL) + 64,
                      a1);
            if ( v40 )
            {
              while ( v46 < *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL) )
              {
                _libssh2_sha512_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 64LL);
                if ( v46 )
                {
                  EVP_DigestUpdate(v29, v40, v46);
                }
                else
                {
                  EVP_DigestUpdate(v29, "D", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                EVP_DigestFinal(v29, v40 + v46, 0LL);
                EVP_MD_CTX_free(v29);
                v46 += 64LL;
              }
            }
            break;
        }
        if ( !v40 )
        {
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v39, a1);
          v27 = -5;
          goto LABEL_317;
        }
        a2 = *(_QWORD *)(a1 + 296);
        if ( (*(unsigned int ( **)(__int64, __int64, __int64, int *, __int64, int *, _QWORD, __int64))(*(_QWORD *)(a1 + 296) + 40LL))(
               a1,
               a2,
               v39,
               &v25,
               v40,
               &v26,
               0LL,
               a1 + 304) )
        {
          (*(void ( **)(__int64, __int64))(a1 + 24))(v39, a1);
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v40, a1);
          v27 = -5;
          goto LABEL_317;
        }
        if ( v25 )
        {
          _libssh2_explicit_zero(v39, *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL));
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v39, a1);
        }
        if ( v26 )
        {
          _libssh2_explicit_zero(v40, *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL));
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v40, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 32LL) )
      {
        a2 = a1 + 440;
        (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 424) + 32LL))(a1, a1 + 440);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 16LL) )
      {
        v47 = 0LL;
        v26 = 0;
        switch ( v24 )
        {
          case 415:
            v48 = 0LL;
            if ( !v47 )
            {
              a2 = a1;
              v47 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 424) + 12LL) + 32,
                      a1);
            }
            if ( v47 )
            {
              while ( v48 < *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL) )
              {
                _libssh2_sha256_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 32LL);
                if ( v48 )
                {
                  EVP_DigestUpdate(v29, v47, v48);
                }
                else
                {
                  EVP_DigestUpdate(v29, "E", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v47 + v48;
                EVP_DigestFinal(v29, v47 + v48, 0LL);
                EVP_MD_CTX_free(v29);
                v48 += 32LL;
              }
            }
            break;
          case 715:
            v49 = 0LL;
            if ( !v47 )
            {
              a2 = a1;
              v47 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 424) + 12LL) + 48,
                      a1);
            }
            if ( v47 )
            {
              while ( v49 < *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL) )
              {
                _libssh2_sha384_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 48LL);
                if ( v49 )
                {
                  EVP_DigestUpdate(v29, v47, v49);
                }
                else
                {
                  EVP_DigestUpdate(v29, "E", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v47 + v49;
                EVP_DigestFinal(v29, v47 + v49, 0LL);
                EVP_MD_CTX_free(v29);
                v49 += 48LL;
              }
            }
            break;
          case 716:
            v50 = 0LL;
            if ( !v47 )
            {
              a2 = a1;
              v47 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 424) + 12LL) + 64,
                      a1);
            }
            if ( v47 )
            {
              while ( v50 < *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL) )
              {
                _libssh2_sha512_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 64LL);
                if ( v50 )
                {
                  EVP_DigestUpdate(v29, v47, v50);
                }
                else
                {
                  EVP_DigestUpdate(v29, "E", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v47 + v50;
                EVP_DigestFinal(v29, v47 + v50, 0LL);
                EVP_MD_CTX_free(v29);
                v50 += 64LL;
              }
            }
            break;
        }
        if ( !v47 )
        {
          v27 = -5;
          goto LABEL_317;
        }
        a2 = v47;
        (*(void ( **)(__int64, __int64, int *, __int64))(*(_QWORD *)(a1 + 424) + 16LL))(
          a1,
          v47,
          &v26,
          a1 + 440);
        if ( v26 )
        {
          _libssh2_explicit_zero(v47, *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL));
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v47, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32LL) )
      {
        a2 = a1 + 328;
        (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 312) + 32LL))(a1, a1 + 328);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16LL) )
      {
        v51 = 0LL;
        v26 = 0;
        switch ( v24 )
        {
          case 415:
            v52 = 0LL;
            if ( !v51 )
            {
              a2 = a1;
              v51 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 312) + 12LL) + 32,
                      a1);
            }
            if ( v51 )
            {
              while ( v52 < *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL) )
              {
                _libssh2_sha256_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 32LL);
                if ( v52 )
                {
                  EVP_DigestUpdate(v29, v51, v52);
                }
                else
                {
                  EVP_DigestUpdate(v29, "F", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v51 + v52;
                EVP_DigestFinal(v29, v51 + v52, 0LL);
                EVP_MD_CTX_free(v29);
                v52 += 32LL;
              }
            }
            break;
          case 715:
            v53 = 0LL;
            if ( !v51 )
            {
              a2 = a1;
              v51 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 312) + 12LL) + 48,
                      a1);
            }
            if ( v51 )
            {
              while ( v53 < *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL) )
              {
                _libssh2_sha384_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 48LL);
                if ( v53 )
                {
                  EVP_DigestUpdate(v29, v51, v53);
                }
                else
                {
                  EVP_DigestUpdate(v29, "F", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v51 + v53;
                EVP_DigestFinal(v29, v51 + v53, 0LL);
                EVP_MD_CTX_free(v29);
                v53 += 48LL;
              }
            }
            break;
          case 716:
            v54 = 0LL;
            if ( !v51 )
            {
              a2 = a1;
              v51 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                      *(_DWORD *)(*(_QWORD *)(a1 + 312) + 12LL) + 64,
                      a1);
            }
            if ( v51 )
            {
              while ( v54 < *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL) )
              {
                _libssh2_sha512_init(&v29);
                EVP_DigestUpdate(v29, *(_QWORD *)(a8 + 176), *(_QWORD *)(a8 + 200));
                EVP_DigestUpdate(v29, a8 + 32, 64LL);
                if ( v54 )
                {
                  EVP_DigestUpdate(v29, v51, v54);
                }
                else
                {
                  EVP_DigestUpdate(v29, "F", 1LL);
                  EVP_DigestUpdate(v29, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
                }
                a2 = v51 + v54;
                EVP_DigestFinal(v29, v51 + v54, 0LL);
                EVP_MD_CTX_free(v29);
                v54 += 64LL;
              }
            }
            break;
        }
        if ( !v51 )
        {
          v27 = -5;
          goto LABEL_317;
        }
        a2 = v51;
        (*(void ( **)(__int64, __int64, int *, __int64))(*(_QWORD *)(a1 + 312) + 16LL))(
          a1,
          v51,
          &v26,
          a1 + 328);
        if ( v26 )
        {
          _libssh2_explicit_zero(v51, *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL));
          a2 = a1;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v51, a1);
        }
      }
      if ( *(_QWORD *)(a1 + 448) && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 40LL) )
      {
        a2 = 1LL;
        (*(void ( **)(__int64, signed __int64, __int64))(*(_QWORD *)(a1 + 448) + 40LL))(a1, 1LL, a1 + 456);
      }
      if ( *(_QWORD *)(a1 + 448)
        && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 16LL)
        && (a2 = 1LL,
            (*(unsigned int ( **)(__int64, signed __int64, __int64))(*(_QWORD *)(a1 + 448) + 16LL))(
              a1,
              1LL,
              a1 + 456)) )
      {
        v27 = -5;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 336) && *(_QWORD *)(*(_QWORD *)(a1 + 336) + 40LL) )
        {
          a2 = 0LL;
          (*(void ( **)(__int64, _QWORD, __int64))(*(_QWORD *)(a1 + 336) + 40LL))(a1, 0LL, a1 + 344);
        }
        if ( *(_QWORD *)(a1 + 336) )
        {
          if ( *(_QWORD *)(*(_QWORD *)(a1 + 336) + 16LL) )
          {
            a2 = 0LL;
            if ( (*(unsigned int ( **)(__int64, _QWORD, __int64))(*(_QWORD *)(a1 + 336) + 16LL))(
                   a1,
                   0LL,
                   a1 + 344) )
            {
              v27 = -5;
            }
          }
        }
      }
      goto LABEL_317;
    }
    a2 = v28;
    v27 = _libssh2_error(a1, v28, "Timed out waiting for NEWKEYS");
  }
LABEL_317:
  BN_clear_free(*(_QWORD *)(a8 + 160), a2);
  *(_QWORD *)(a8 + 160) = 0LL;
  if ( *(_QWORD *)(a8 + 176) )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a8 + 176), a1);
    *(_QWORD *)(a8 + 176) = 0LL;
  }
  *(_DWORD *)a8 = 0;
  return v27;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8BF0: using guessed type __int64  _libssh2_sha256_init(_QWORD);
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91E0: using guessed type __int64  _libssh2_sha512_init(_QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9780: using guessed type __int64  BN_bn2bin(_QWORD, _QWORD);
// 9790: using guessed type __int64  _libssh2_sha1_init(_QWORD);
// 9920: using guessed type __int64  _libssh2_md5_init(_QWORD);
// 9980: using guessed type __int64  _libssh2_sha384_init(_QWORD);
// 9AC0: using guessed type __int64  _libssh2_ecdh_gen_k(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000224C8) ----------------------------------------------------
signed __int64  sub_224C8(__int64 a1, __int64 a2)
{
  unsigned int v3; // [rsp+14h] [rbp-1Ch]
  unsigned int v4; // [rsp+18h] [rbp-18h]
  unsigned int v5; // [rsp+1Ch] [rbp-14h]
  __int64 v6; // [rsp+20h] [rbp-10h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  v4 = 0;
  v5 = 0;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 576) = 0LL;
    *(_DWORD *)a2 = 2;
  }
  if ( *(_DWORD *)a2 == 2 )
  {
    v5 = sub_1E781(**(const char ***)(a1 + 120), (signed int *)&v3);
    if ( v5 )
    {
      v4 = _libssh2_error(a1, 0xFFFFFFFFLL, "Unknown KEX nistp curve type");
      goto LABEL_25;
    }
    v5 = _libssh2_ecdsa_create_key(a1, a2 + 568, a2 + 576, a2 + 584, v3);
    if ( v5 )
    {
      v4 = _libssh2_error(a1, v5, "Unable to create private key");
      goto LABEL_25;
    }
    *(_BYTE *)(a2 + 288) = 30;
    v6 = a2 + 289;
    _libssh2_store_str(&v6, *(_QWORD *)(a2 + 576), *(_QWORD *)(a2 + 584));
    *(_QWORD *)(a2 + 552) = *(_QWORD *)(a2 + 584) + 5LL;
    *(_DWORD *)a2 = 3;
  }
  if ( *(_DWORD *)a2 == 3 )
  {
    v5 = _libssh2_transport_send(a1, a2 + 288, *(_QWORD *)(a2 + 552), 0LL, 0LL);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 )
    {
      v4 = _libssh2_error(a1, v5, "Unable to send ECDH_INIT");
      goto LABEL_25;
    }
    *(_DWORD *)a2 = 4;
  }
  if ( *(_DWORD *)a2 == 4 )
  {
    v5 = _libssh2_packet_require(a1, 31LL, a2 + 544, a2 + 560, 0LL, 0LL, 0LL, a2 + 8);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 )
    {
      v4 = _libssh2_error(a1, v5, "Timeout waiting for ECDH_REPLY reply");
      goto LABEL_25;
    }
    *(_DWORD *)a2 = 5;
  }
  if ( *(_DWORD *)a2 == 5 )
  {
    sub_1E781(**(const char ***)(a1 + 120), (signed int *)&v3);
    v4 = sub_1E82B(
           a1,
           v3,
           *(_QWORD *)(a2 + 544),
           *(_QWORD *)(a2 + 560),
           *(_QWORD *)(a2 + 576),
           *(_QWORD *)(a2 + 584),
           *(_QWORD *)(a2 + 568),
           a2 + 24);
    if ( v4 == -37 )
      return 4294967259LL;
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a2 + 544), a1);
  }
LABEL_25:
  if ( *(_QWORD *)(a2 + 576) )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a2 + 576), a1);
    *(_QWORD *)(a2 + 576) = 0LL;
  }
  if ( *(_QWORD *)(a2 + 568) )
  {
    EC_KEY_free(*(_QWORD *)(a2 + 568));
    *(_QWORD *)(a2 + 568) = 0LL;
  }
  *(_DWORD *)a2 = 0;
  return v4;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8940: using guessed type __int64  _libssh2_ecdsa_create_key(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 89F0: using guessed type __int64  EC_KEY_free(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);

//----- (000000000002287B) ----------------------------------------------------
__int64  sub_2287B(signed __int64 a1, signed __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // eax
  size_t v8; // rax
  unsigned int v9; // eax
  size_t v10; // rax
  __int64 v11; // [rsp+0h] [rbp-F0h]
  __int64 v12; // [rsp+8h] [rbp-E8h]
  __int64 v13; // [rsp+10h] [rbp-E0h]
  unsigned __int64 v14; // [rsp+18h] [rbp-D8h]
  unsigned int v15; // [rsp+34h] [rbp-BCh]
  signed int v16; // [rsp+38h] [rbp-B8h]
  unsigned int v17; // [rsp+38h] [rbp-B8h]
  unsigned int v18; // [rsp+38h] [rbp-B8h]
  __int64 v19; // [rsp+40h] [rbp-B0h]
  void *src; // [rsp+48h] [rbp-A8h]
  __int64 v21; // [rsp+50h] [rbp-A0h]
  __int64 v22; // [rsp+58h] [rbp-98h]
  __int64 v23; // [rsp+60h] [rbp-90h]
  __int128 v24; // [rsp+68h] [rbp-88h]
  unsigned __int64 v25; // [rsp+78h] [rbp-78h]
  unsigned __int64 v26; // [rsp+80h] [rbp-70h]
  __int128 v27; // [rsp+88h] [rbp-68h]
  unsigned __int64 v28; // [rsp+98h] [rbp-58h]
  unsigned __int64 v29; // [rsp+A0h] [rbp-50h]
  __int128 v30; // [rsp+A8h] [rbp-48h]
  __int128 v31; // [rsp+B8h] [rbp-38h]
  size_t n; // [rsp+C8h] [rbp-28h]
  __int64 v33; // [rsp+D0h] [rbp-20h]
  __int64 v34; // [rsp+D8h] [rbp-18h]
  unsigned __int64 v35; // [rsp+E0h] [rbp-10h]
  unsigned __int64 v36; // [rsp+E8h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  v36 = __readfsqword(0x28u);
  v15 = 0;
  if ( a3 <= 4 )
    return _libssh2_error(a1, 4294967286LL, "Data is too short");
  if ( !*(_DWORD *)a6 )
  {
    *(_QWORD *)(a6 + 160) = BN_new(a1, a2);
    *(_DWORD *)v11 = 2;
  }
  if ( *(_DWORD *)v11 == 2 )
  {
    if ( v14 <= 4 )
    {
      a2 = 4294967282LL;
      v15 = _libssh2_error(a1, 4294967282LL, "Unexpected key length");
      goto LABEL_161;
    }
    v33 = a2;
    v35 = v14;
    v34 = a2 + 1;
    if ( (unsigned int)_libssh2_get_string(&v33, &src, &v22) )
    {
      a2 = 4294967282LL;
      v15 = _libssh2_error(a1, 4294967282LL, "Unexpected key length");
      goto LABEL_161;
    }
    *(_DWORD *)(a1 + 184) = v22;
    *(_QWORD *)(a1 + 176) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                              *(unsigned int *)(a1 + 184),
                              a1);
    if ( !*(_QWORD *)(a1 + 176) )
    {
      a2 = 4294967290LL;
      v15 = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for a copy of the host key");
      goto LABEL_161;
    }
    memcpy(*(void **)(a1 + 176), src, *(unsigned int *)(a1 + 184));
    if ( (unsigned int)_libssh2_md5_init(&v23) )
    {
      EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v23, a1 + 188, 0LL);
      EVP_MD_CTX_free(v23);
      *(_DWORD *)(a1 + 204) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 204) = 0;
    }
    if ( (unsigned int)_libssh2_sha1_init(&v23) )
    {
      EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v23, a1 + 208, 0LL);
      EVP_MD_CTX_free(v23);
      *(_DWORD *)(a1 + 228) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 228) = 0;
    }
    if ( (unsigned int)_libssh2_sha256_init(&v23) )
    {
      EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
      EVP_DigestFinal(v23, a1 + 232, 0LL);
      EVP_MD_CTX_free(v23);
      *(_DWORD *)(a1 + 264) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 264) = 0;
    }
    if ( (*(unsigned int ( **)(signed __int64, _QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 160) + 16LL))(
           a1,
           *(_QWORD *)(a1 + 176),
           *(unsigned int *)(a1 + 184),
           a1 + 168) )
    {
      a2 = 4294967286LL;
      v15 = _libssh2_error(a1, 4294967286LL, "Unable to initialize hostkey importer");
      goto LABEL_161;
    }
    if ( (unsigned int)_libssh2_get_string(&v33, &v19, &v21) )
    {
      a2 = 4294967282LL;
      v15 = _libssh2_error(a1, 4294967282LL, "Unexpected key length");
      goto LABEL_161;
    }
    if ( v21 != 32 )
    {
      a2 = 4294967286LL;
      v15 = _libssh2_error(a1, 4294967286LL, "Unexpected curve25519 server public key length");
      goto LABEL_161;
    }
    if ( (unsigned int)_libssh2_get_string(&v33, v11 + 184, v11 + 208) )
    {
      a2 = 4294967286LL;
      v15 = _libssh2_error(a1, 4294967286LL, "Unexpected curve25519 server sig length");
      goto LABEL_161;
    }
    v16 = _libssh2_curve25519_gen_k(v11 + 160, v12, v19);
    if ( v16 )
    {
      a2 = 4294967291LL;
      v15 = _libssh2_error(a1, 4294967291LL, "Unable to create ECDH shared secret");
      goto LABEL_161;
    }
    *(_QWORD *)(v11 + 200) = (signed int)((unsigned __int64)BN_num_bits(*(_QWORD *)(v11 + 160)) + 7) / 8 + 5;
    if ( BN_num_bits(*(_QWORD *)(v11 + 160)) & 7 )
      --*(_QWORD *)(v11 + 200);
    *(_QWORD *)(v11 + 176) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(*(_QWORD *)(v11 + 200), a1);
    if ( !*(_QWORD *)(v11 + 176) )
    {
      a2 = 4294967290LL;
      v15 = _libssh2_error(a1, 4294967290LL, "Unable to allocate buffer for K");
      goto LABEL_161;
    }
    _libssh2_htonu32(*(_QWORD *)(v11 + 176), (unsigned int)*(_QWORD *)(v11 + 200) - 4);
    if ( BN_num_bits(*(_QWORD *)(v11 + 160)) & 7 )
    {
      BN_bn2bin(*(_QWORD *)(v11 + 160), *(_QWORD *)(v11 + 176) + 4LL);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(v11 + 176) + 4LL) = 0;
      BN_bn2bin(*(_QWORD *)(v11 + 160), *(_QWORD *)(v11 + 176) + 5LL);
    }
    *(_QWORD *)(v11 + 216) = &v23;
    _libssh2_sha256_init(&v23);
    if ( *(_QWORD *)(a1 + 384) )
    {
      v7 = strlen(*(const char **)(a1 + 384));
      _libssh2_htonu32(v11 + 32, (unsigned int)(v7 - 2));
      EVP_DigestUpdate(v23, v11 + 32, 4LL);
      v8 = strlen(*(const char **)(a1 + 384));
      EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 384), v8 - 2);
    }
    else
    {
      _libssh2_htonu32(v11 + 32, 25LL);
      EVP_DigestUpdate(v23, v11 + 32, 4LL);
      EVP_DigestUpdate(v23, "SSH-2.0-libssh2_1.9.0_DEV", 25LL);
    }
    v9 = strlen(*(const char **)(a1 + 272));
    _libssh2_htonu32(v11 + 32, v9);
    EVP_DigestUpdate(v23, v11 + 32, 4LL);
    v10 = strlen(*(const char **)(a1 + 272));
    EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 272), v10);
    _libssh2_htonu32(v11 + 32, (unsigned int)*(_QWORD *)(a1 + 400));
    EVP_DigestUpdate(v23, v11 + 32, 4LL);
    EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400));
    _libssh2_htonu32(v11 + 32, (unsigned int)*(_QWORD *)(a1 + 288));
    EVP_DigestUpdate(v23, v11 + 32, 4LL);
    EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 288));
    _libssh2_htonu32(v11 + 32, *(unsigned int *)(a1 + 184));
    EVP_DigestUpdate(v23, v11 + 32, 4LL);
    EVP_DigestUpdate(v23, *(_QWORD *)(a1 + 176), *(unsigned int *)(a1 + 184));
    _libssh2_htonu32(v11 + 32, 32LL);
    EVP_DigestUpdate(v23, v11 + 32, 4LL);
    EVP_DigestUpdate(v23, v13, 32LL);
    _libssh2_htonu32(v11 + 32, (unsigned int)v21);
    EVP_DigestUpdate(v23, v11 + 32, 4LL);
    EVP_DigestUpdate(v23, v19, v21);
    EVP_DigestUpdate(v23, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
    EVP_DigestFinal(v23, v11 + 32, 0LL);
    EVP_MD_CTX_free(v23);
    a2 = *(_QWORD *)(v11 + 184);
    if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 160) + 40LL))(
           a1,
           a2,
           *(_QWORD *)(v11 + 208),
           v11 + 32,
           32LL,
           a1 + 168) )
    {
      v16 = -1;
    }
    if ( v16 )
    {
      a2 = 4294967285LL;
      v15 = _libssh2_error(a1, 4294967285LL, "Unable to verify hostkey signature");
      goto LABEL_161;
    }
    *(_BYTE *)(v11 + 96) = 21;
    *(_DWORD *)v11 = 3;
  }
  if ( *(_DWORD *)v11 == 3 )
  {
    a2 = v11 + 96;
    v17 = _libssh2_transport_send(a1, v11 + 96, 1LL, 0LL, 0LL);
    if ( v17 == -37 )
      return 4294967259LL;
    if ( v17 )
    {
      a2 = v17;
      v15 = _libssh2_error(a1, v17, "Unable to send NEWKEYS message");
      goto LABEL_161;
    }
    *(_DWORD *)v11 = 5;
  }
  if ( *(_DWORD *)v11 == 5 )
  {
    v18 = _libssh2_packet_require(a1, 21LL, v11 + 24, v11 + 120, 0LL, 0LL, 0LL, v11 + 224);
    if ( v18 == -37 )
      return 4294967259LL;
    if ( !v18 )
    {
      *(_DWORD *)(a1 + 104) |= 2u;
      a2 = a1;
      (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(v11 + 24), a1);
      if ( !*(_QWORD *)(a1 + 136) )
      {
        n = 32LL;
        *(_QWORD *)(a1 + 136) = (*(__int64 ( **)(signed __int64, signed __int64))(a1 + 8))(32LL, a1);
        if ( !*(_QWORD *)(a1 + 136) )
        {
          a2 = 4294967290LL;
          v15 = _libssh2_error(a1, 4294967290LL, "Unable to allxcocate buffer for SHA digest");
          goto LABEL_161;
        }
        a2 = v11 + 32;
        memcpy(*(void **)(a1 + 136), (const void *)(v11 + 32), n);
        *(_DWORD *)(a1 + 144) = n;
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 56LL) )
      {
        a2 = a1 + 416;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 408) + 56LL))(a1, a1 + 416);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 408) + 40LL) )
      {
        *(_QWORD *)&v24 = 0LL;
        LODWORD(v22) = 0;
        LODWORD(v23) = 0;
        v25 = 0LL;
        a2 = a1;
        v24 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 408) + 20LL) + 32,
                                  a1);
        if ( (_QWORD)v24 )
        {
          while ( v25 < *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
            EVP_DigestUpdate(v33, v11 + 32, 32LL);
            if ( v25 )
            {
              EVP_DigestUpdate(v33, v24, v25);
            }
            else
            {
              EVP_DigestUpdate(v33, "A", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v24 + v25;
            EVP_DigestFinal(v33, v24 + v25, 0LL);
            EVP_MD_CTX_free(v33);
            v25 += 32LL;
          }
        }
        if ( !(_QWORD)v24 )
        {
          v15 = -1;
          goto LABEL_161;
        }
        v26 = 0LL;
        if ( !*((_QWORD *)&v24 + 1) )
          *((_QWORD *)&v24 + 1) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 408) + 24LL) + 32,
                                    a1);
        if ( *((_QWORD *)&v24 + 1) )
        {
          while ( v26 < *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
            EVP_DigestUpdate(v33, v11 + 32, 32LL);
            if ( v26 )
            {
              EVP_DigestUpdate(v33, *((_QWORD *)&v24 + 1), v26);
            }
            else
            {
              EVP_DigestUpdate(v33, "C", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(v33, *((_QWORD *)&v24 + 1) + v26, 0LL);
            EVP_MD_CTX_free(v33);
            v26 += 32LL;
          }
        }
        if ( !*((_QWORD *)&v24 + 1) )
        {
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v24, a1);
          v15 = -5;
          goto LABEL_161;
        }
        a2 = *(_QWORD *)(a1 + 408);
        if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, __int64 *, _QWORD, __int64 *, signed __int64, signed __int64))(*(_QWORD *)(a1 + 408) + 40LL))(
               a1,
               a2,
               v24,
               &v22,
               *((_QWORD *)&v24 + 1),
               &v23,
               1LL,
               a1 + 416) )
        {
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v24, a1);
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v24 + 1), a1);
          v15 = -5;
          goto LABEL_161;
        }
        if ( (_DWORD)v22 )
        {
          _libssh2_explicit_zero(v24, *(signed int *)(*(_QWORD *)(a1 + 408) + 20LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v24, a1);
        }
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(*((_QWORD *)&v24 + 1), *(signed int *)(*(_QWORD *)(a1 + 408) + 24LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v24 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 56LL) )
      {
        a2 = a1 + 304;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 296) + 56LL))(a1, a1 + 304);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 296) + 40LL) )
      {
        *(_QWORD *)&v27 = 0LL;
        LODWORD(v22) = 0;
        LODWORD(v23) = 0;
        v28 = 0LL;
        a2 = a1;
        v27 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 296) + 20LL) + 32,
                                  a1);
        if ( (_QWORD)v27 )
        {
          while ( v28 < *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
            EVP_DigestUpdate(v33, v11 + 32, 32LL);
            if ( v28 )
            {
              EVP_DigestUpdate(v33, v27, v28);
            }
            else
            {
              EVP_DigestUpdate(v33, "B", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v27 + v28;
            EVP_DigestFinal(v33, v27 + v28, 0LL);
            EVP_MD_CTX_free(v33);
            v28 += 32LL;
          }
        }
        if ( !(_QWORD)v27 )
        {
          v15 = -5;
          goto LABEL_161;
        }
        v29 = 0LL;
        if ( !*((_QWORD *)&v27 + 1) )
          *((_QWORD *)&v27 + 1) = (*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                    *(_DWORD *)(*(_QWORD *)(a1 + 296) + 24LL) + 32,
                                    a1);
        if ( *((_QWORD *)&v27 + 1) )
        {
          while ( v29 < *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
            EVP_DigestUpdate(v33, v11 + 32, 32LL);
            if ( v29 )
            {
              EVP_DigestUpdate(v33, *((_QWORD *)&v27 + 1), v29);
            }
            else
            {
              EVP_DigestUpdate(v33, "D", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            EVP_DigestFinal(v33, *((_QWORD *)&v27 + 1) + v29, 0LL);
            EVP_MD_CTX_free(v33);
            v29 += 32LL;
          }
        }
        if ( !*((_QWORD *)&v27 + 1) )
        {
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v27, a1);
          v15 = -5;
          goto LABEL_161;
        }
        a2 = *(_QWORD *)(a1 + 296);
        if ( (*(unsigned int ( **)(signed __int64, signed __int64, _QWORD, __int64 *, _QWORD, __int64 *, _QWORD, signed __int64))(*(_QWORD *)(a1 + 296) + 40LL))(
               a1,
               a2,
               v27,
               &v22,
               *((_QWORD *)&v27 + 1),
               &v23,
               0LL,
               a1 + 304) )
        {
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v27, a1);
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v27 + 1), a1);
          v15 = -5;
          goto LABEL_161;
        }
        if ( (_DWORD)v22 )
        {
          _libssh2_explicit_zero(v27, *(signed int *)(*(_QWORD *)(a1 + 296) + 20LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v27, a1);
        }
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(*((_QWORD *)&v27 + 1), *(signed int *)(*(_QWORD *)(a1 + 296) + 24LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*((_QWORD *)&v27 + 1), a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 32LL) )
      {
        a2 = a1 + 440;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 424) + 32LL))(a1, a1 + 440);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 424) + 16LL) )
      {
        *(_QWORD *)&v30 = 0LL;
        LODWORD(v23) = 0;
        a2 = a1;
        v30 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 424) + 12LL) + 32,
                                  a1);
        if ( (_QWORD)v30 )
        {
          while ( *((_QWORD *)&v30 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 424) + 12LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
            EVP_DigestUpdate(v33, v11 + 32, 32LL);
            if ( *((_QWORD *)&v30 + 1) )
            {
              EVP_DigestUpdate(v33, v30, *((_QWORD *)&v30 + 1));
            }
            else
            {
              EVP_DigestUpdate(v33, "E", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v30 + *((_QWORD *)&v30 + 1);
            EVP_DigestFinal(v33, v30 + *((_QWORD *)&v30 + 1), 0LL);
            EVP_MD_CTX_free(v33);
            *((_QWORD *)&v30 + 1) += 32LL;
          }
        }
        if ( !(_QWORD)v30 )
        {
          v15 = -5;
          goto LABEL_161;
        }
        a2 = v30;
        (*(void ( **)(signed __int64, _QWORD, __int64 *, signed __int64))(*(_QWORD *)(a1 + 424) + 16LL))(
          a1,
          v30,
          &v23,
          a1 + 440);
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(v30, *(signed int *)(*(_QWORD *)(a1 + 424) + 12LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v30, a1);
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32LL) )
      {
        a2 = a1 + 328;
        (*(void ( **)(signed __int64, signed __int64))(*(_QWORD *)(a1 + 312) + 32LL))(a1, a1 + 328);
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16LL) )
      {
        *(_QWORD *)&v31 = 0LL;
        LODWORD(v23) = 0;
        a2 = a1;
        v31 = (unsigned __int64)(*(__int64 ( **)(_QWORD, signed __int64))(a1 + 8))(
                                  *(_DWORD *)(*(_QWORD *)(a1 + 312) + 12LL) + 32,
                                  a1);
        if ( (_QWORD)v31 )
        {
          while ( *((_QWORD *)&v31 + 1) < (unsigned __int64)*(signed int *)(*(_QWORD *)(a1 + 312) + 12LL) )
          {
            _libssh2_sha256_init(&v33);
            EVP_DigestUpdate(v33, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 200));
            EVP_DigestUpdate(v33, v11 + 32, 32LL);
            if ( *((_QWORD *)&v31 + 1) )
            {
              EVP_DigestUpdate(v33, v31, *((_QWORD *)&v31 + 1));
            }
            else
            {
              EVP_DigestUpdate(v33, "F", 1LL);
              EVP_DigestUpdate(v33, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
            }
            a2 = v31 + *((_QWORD *)&v31 + 1);
            EVP_DigestFinal(v33, v31 + *((_QWORD *)&v31 + 1), 0LL);
            EVP_MD_CTX_free(v33);
            *((_QWORD *)&v31 + 1) += 32LL;
          }
        }
        if ( !(_QWORD)v31 )
        {
          v15 = -5;
          goto LABEL_161;
        }
        a2 = v31;
        (*(void ( **)(signed __int64, _QWORD, __int64 *, signed __int64))(*(_QWORD *)(a1 + 312) + 16LL))(
          a1,
          v31,
          &v23,
          a1 + 328);
        if ( (_DWORD)v23 )
        {
          _libssh2_explicit_zero(v31, *(signed int *)(*(_QWORD *)(a1 + 312) + 12LL));
          a2 = a1;
          (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(v31, a1);
        }
      }
      if ( *(_QWORD *)(a1 + 448) && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 40LL) )
      {
        a2 = 1LL;
        (*(void ( **)(signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 448) + 40LL))(
          a1,
          1LL,
          a1 + 456);
      }
      if ( *(_QWORD *)(a1 + 448)
        && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 16LL)
        && (a2 = 1LL,
            (*(unsigned int ( **)(signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 448) + 16LL))(
              a1,
              1LL,
              a1 + 456)) )
      {
        v15 = -5;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 336) && *(_QWORD *)(*(_QWORD *)(a1 + 336) + 40LL) )
        {
          a2 = 0LL;
          (*(void ( **)(signed __int64, _QWORD, signed __int64))(*(_QWORD *)(a1 + 336) + 40LL))(
            a1,
            0LL,
            a1 + 344);
        }
        if ( *(_QWORD *)(a1 + 336) )
        {
          if ( *(_QWORD *)(*(_QWORD *)(a1 + 336) + 16LL) )
          {
            a2 = 0LL;
            if ( (*(unsigned int ( **)(signed __int64, _QWORD, signed __int64))(*(_QWORD *)(a1 + 336) + 16LL))(
                   a1,
                   0LL,
                   a1 + 344) )
            {
              v15 = -5;
            }
          }
        }
      }
      goto LABEL_161;
    }
    a2 = v18;
    v15 = _libssh2_error(a1, v18, "Timed out waiting for NEWKEYS");
  }
LABEL_161:
  BN_clear_free(*(_QWORD *)(v11 + 160), a2);
  *(_QWORD *)(v11 + 160) = 0LL;
  if ( *(_QWORD *)(v11 + 176) )
  {
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(v11 + 176), a1);
    *(_QWORD *)(v11 + 176) = 0LL;
  }
  *(_DWORD *)v11 = 0;
  return v15;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8BF0: using guessed type __int64  _libssh2_sha256_init(_QWORD);
// 8D60: using guessed type __int64  BN_num_bits(_QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64  BN_clear_free(_QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9290: using guessed type __int64  BN_new(_QWORD, _QWORD);
// 9350: using guessed type __int64  _libssh2_curve25519_gen_k(_QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9780: using guessed type __int64  BN_bn2bin(_QWORD, _QWORD);
// 9790: using guessed type __int64  _libssh2_sha1_init(_QWORD);
// 9920: using guessed type __int64  _libssh2_md5_init(_QWORD);

//----- (000000000002474C) ----------------------------------------------------
signed __int64  sub_2474C(signed __int64 a1, __int64 a2)
{
  unsigned int v3; // [rsp+18h] [rbp-18h]
  int v4; // [rsp+1Ch] [rbp-14h]
  unsigned int v5; // [rsp+1Ch] [rbp-14h]
  unsigned int v6; // [rsp+1Ch] [rbp-14h]
  unsigned int v7; // [rsp+1Ch] [rbp-14h]
  __int64 v8; // [rsp+20h] [rbp-10h]
  unsigned __int64 v9; // [rsp+28h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v3 = 0;
  if ( !*(_DWORD *)a2 )
  {
    *(_QWORD *)(a2 + 576) = 0LL;
    *(_DWORD *)a2 = 2;
  }
  if ( *(_DWORD *)a2 == 2 )
  {
    v8 = 0LL;
    v4 = strcmp(**(const char ***)(a1 + 120), "curve25519-sha256@libssh.org");
    if ( v4 )
      v4 = strcmp(**(const char ***)(a1 + 120), "curve25519-sha256");
    if ( v4 )
    {
      v3 = _libssh2_error(a1, 0xFFFFFFFFLL, "Unknown KEX curve25519 curve type");
      goto LABEL_27;
    }
    v5 = _libssh2_curve25519_new(a1, 0LL, a2 + 592, a2 + 600);
    if ( v5 )
    {
      v3 = _libssh2_error(a1, v5, "Unable to create private key");
      goto LABEL_27;
    }
    *(_BYTE *)(a2 + 288) = 30;
    v8 = a2 + 289;
    _libssh2_store_str(&v8, *(_QWORD *)(a2 + 592), 32LL);
    *(_QWORD *)(a2 + 552) = 37LL;
    *(_DWORD *)a2 = 3;
  }
  if ( *(_DWORD *)a2 == 3 )
  {
    v6 = _libssh2_transport_send(a1, a2 + 288, *(_QWORD *)(a2 + 552), 0LL, 0LL);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v6 )
    {
      v3 = _libssh2_error(a1, v6, "Unable to send ECDH_INIT");
      goto LABEL_27;
    }
    *(_DWORD *)a2 = 4;
  }
  if ( *(_DWORD *)a2 == 4 )
  {
    v7 = _libssh2_packet_require(a1, 31LL, a2 + 544, a2 + 560, 0LL, 0LL, 0LL, a2 + 8);
    if ( v7 == -37 )
      return 4294967259LL;
    if ( v7 )
    {
      v3 = _libssh2_error(a1, v7, "Timeout waiting for ECDH_REPLY reply");
      goto LABEL_27;
    }
    *(_DWORD *)a2 = 5;
  }
  if ( *(_DWORD *)a2 == 5 )
  {
    v3 = sub_2287B(
           a1,
           *(_QWORD *)(a2 + 544),
           *(_QWORD *)(a2 + 560),
           *(_QWORD *)(a2 + 592),
           *(_QWORD *)(a2 + 600),
           a2 + 24);
    if ( v3 == -37 )
      return 4294967259LL;
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a2 + 544), a1);
  }
LABEL_27:
  if ( *(_QWORD *)(a2 + 592) )
  {
    _libssh2_explicit_zero(*(_QWORD *)(a2 + 592), 32LL);
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a2 + 592), a1);
    *(_QWORD *)(a2 + 592) = 0LL;
  }
  if ( *(_QWORD *)(a2 + 600) )
  {
    _libssh2_explicit_zero(*(_QWORD *)(a2 + 600), 32LL);
    (*(void ( **)(_QWORD, signed __int64))(a1 + 24))(*(_QWORD *)(a2 + 600), a1);
    *(_QWORD *)(a2 + 600) = 0LL;
  }
  *(_DWORD *)a2 = 0;
  return v3;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8DB0: using guessed type __int64  _libssh2_curve25519_new(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);

//----- (0000000000024B1D) ----------------------------------------------------
signed __int64  sub_24B1D(const char ***a1)
{
  const char ***v2; // [rsp+8h] [rbp-18h]
  __int64 v3; // [rsp+18h] [rbp-8h]

  v2 = a1;
  v3 = 0LL;
  if ( !a1 || !*a1 )
    return 0LL;
  while ( *v2 && **v2 )
  {
    v3 += strlen(**v2) + 1;
    ++v2;
  }
  return v3 - 1;
}

//----- (0000000000024B99) ----------------------------------------------------
signed __int64  sub_24B99(__int64 a1, __int64 a2, const char ***a3)
{
  int v4; // ST2C_4
  char *v5; // rax
  const char ***v6; // [rsp+8h] [rbp-28h]
  char *dest; // [rsp+18h] [rbp-18h]

  v6 = a3;
  _libssh2_htonu32(a1, (unsigned int)a2);
  dest = (char *)(a1 + 4);
  if ( !v6 || !*v6 )
    return 4LL;
  while ( *v6 && **v6 )
  {
    v4 = strlen(**v6);
    memcpy(dest, **v6, v4);
    v5 = &dest[v4];
    dest = v5 + 1;
    *v5 = 44;
    ++v6;
  }
  return a2 + 4;
}
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (0000000000024C56) ----------------------------------------------------
__int64  sub_24C56(__int64 a1, __int64 a2)
{
  const char *v2; // rdi
  size_t v3; // rax
  char *v4; // rdi
  size_t v5; // rax
  char *v6; // rdi
  size_t v7; // rax
  char *v8; // rdi
  size_t v9; // rax
  char *v10; // rdi
  size_t v11; // rax
  size_t v12; // rax
  const char ***v13; // rax
  size_t v14; // rax
  const char ***v15; // rax
  size_t v16; // rax
  const char ***v17; // rax
  size_t v18; // rax
  size_t v19; // rax
  __int64 result; // rax
  signed __int64 v21; // rdi
  char *v22; // ST28_8
  const void *v23; // rsi
  char *v24; // rdi
  const char ***v25; // rax
  char *v26; // ST28_8
  const void *v27; // rsi
  char *v28; // rdi
  const char ***v29; // rax
  char *v30; // ST28_8
  char *v31; // rdi
  const char ***v32; // rax
  char *v33; // ST28_8
  char *v34; // rdi
  const char ***v35; // rax
  char *v36; // ST28_8
  const char ***v37; // rax
  char *v38; // ST28_8
  const char ***v39; // rax
  char *v40; // ST28_8
  const char ***v41; // rax
  char *v42; // ST28_8
  char *v43; // ST28_8
  __int64 v44; // [rsp+8h] [rbp-78h]
  unsigned int v45; // [rsp+14h] [rbp-6Ch]
  signed __int64 v46; // [rsp+18h] [rbp-68h]
  _BYTE *v47; // [rsp+20h] [rbp-60h]
  char *dest; // [rsp+28h] [rbp-58h]
  char *desta; // [rsp+28h] [rbp-58h]
  char *destb; // [rsp+28h] [rbp-58h]
  char *destc; // [rsp+28h] [rbp-58h]
  char *destd; // [rsp+28h] [rbp-58h]
  char *deste; // [rsp+28h] [rbp-58h]
  char *destf; // [rsp+28h] [rbp-58h]
  char *destg; // [rsp+28h] [rbp-58h]
  char *desth; // [rsp+28h] [rbp-58h]
  char *desti; // [rsp+28h] [rbp-58h]
  char *destj; // [rsp+28h] [rbp-58h]
  size_t v59; // [rsp+30h] [rbp-50h]
  size_t n; // [rsp+38h] [rbp-48h]
  size_t v61; // [rsp+40h] [rbp-40h]
  size_t v62; // [rsp+48h] [rbp-38h]
  size_t v63; // [rsp+50h] [rbp-30h]
  size_t v64; // [rsp+58h] [rbp-28h]
  size_t v65; // [rsp+60h] [rbp-20h]
  size_t v66; // [rsp+68h] [rbp-18h]
  size_t v67; // [rsp+70h] [rbp-10h]
  size_t v68; // [rsp+78h] [rbp-8h]

  v44 = a1;
  if ( *(_DWORD *)(a1 + 52336) )
  {
    v47 = *(_BYTE **)(a1 + 52344);
    v46 = *(_QWORD *)(a1 + 52352);
    *(_QWORD *)(a1 + 52344) = 0LL;
    *(_QWORD *)(a1 + 52352) = 0LL;
  }
  else
  {
    if ( *(_QWORD *)(a1 + 88) )
    {
      v2 = *(const char **)(a1 + 88);
      v3 = strlen(v2);
    }
    else
    {
      v2 = (const char *)off_250A40;
      v3 = sub_24B1D((const char ***)off_250A40);
    }
    n = v3;
    if ( *(_QWORD *)(v44 + 96) )
    {
      v4 = *(char **)(v44 + 96);
      v5 = strlen(v4);
    }
    else
    {
      v4 = (char *)libssh2_hostkey_methods(v2);
      v5 = sub_24B1D((const char ***)v4);
    }
    v59 = v5;
    if ( *(_QWORD *)(v44 + 464) )
    {
      v6 = *(char **)(v44 + 464);
      v7 = strlen(v6);
    }
    else
    {
      v6 = (char *)libssh2_crypt_methods(v4, a2);
      v7 = sub_24B1D((const char ***)v6);
    }
    v61 = v7;
    if ( *(_QWORD *)(v44 + 352) )
    {
      v8 = *(char **)(v44 + 352);
      v9 = strlen(v8);
    }
    else
    {
      v8 = (char *)libssh2_crypt_methods(v6, a2);
      v9 = sub_24B1D((const char ***)v8);
    }
    v62 = v9;
    if ( *(_QWORD *)(v44 + 472) )
    {
      v10 = *(char **)(v44 + 472);
      v11 = strlen(v10);
    }
    else
    {
      v10 = (char *)_libssh2_mac_methods(v8);
      v11 = sub_24B1D((const char ***)v10);
    }
    v63 = v11;
    if ( *(_QWORD *)(v44 + 360) )
    {
      v12 = strlen(*(const char **)(v44 + 360));
    }
    else
    {
      v13 = (const char ***)_libssh2_mac_methods(v10);
      v12 = sub_24B1D(v13);
    }
    v64 = v12;
    if ( *(_QWORD *)(v44 + 480) )
    {
      v14 = strlen(*(const char **)(v44 + 480));
    }
    else
    {
      v15 = (const char ***)_libssh2_comp_methods(v44);
      v14 = sub_24B1D(v15);
    }
    v65 = v14;
    if ( *(_QWORD *)(v44 + 368) )
    {
      v16 = strlen(*(const char **)(v44 + 368));
    }
    else
    {
      v17 = (const char ***)_libssh2_comp_methods(v44);
      v16 = sub_24B1D(v17);
    }
    v66 = v16;
    if ( *(_QWORD *)(v44 + 488) )
      v18 = strlen(*(const char **)(v44 + 488));
    else
      v18 = sub_24B1D(0LL);
    v67 = v18;
    if ( *(_QWORD *)(v44 + 376) )
      v19 = strlen(*(const char **)(v44 + 376));
    else
      v19 = sub_24B1D(0LL);
    v68 = v19;
    v46 = v67 + v64 + v63 + v66 + v65 + v62 + v61 + v59 + n + v19 + 62;
    v47 = (_BYTE *)(*(__int64 ( **)(signed __int64, __int64))(v44 + 8))(v46, v44);
    if ( !v47 )
      return _libssh2_error(v44, 4294967290LL, "Unable to allocate memory");
    *v47 = 20;
    RAND_bytes(v47 + 1, 16LL);
    dest = v47 + 17;
    if ( *(_QWORD *)(v44 + 88) )
    {
      _libssh2_htonu32(dest, (unsigned int)n);
      v21 = (signed __int64)(v47 + 21);
      memcpy(v47 + 21, *(const void **)(v44 + 88), n);
      desta = &v47[n + 21];
    }
    else
    {
      v21 = (signed __int64)(v47 + 17);
      desta = &dest[sub_24B99((__int64)dest, n, (const char ***)off_250A40)];
    }
    if ( *(_QWORD *)(v44 + 96) )
    {
      _libssh2_htonu32(desta, (unsigned int)v59);
      v22 = desta + 4;
      v23 = *(const void **)(v44 + 96);
      v24 = v22;
      memcpy(v22, v23, v59);
      destb = &v22[v59];
    }
    else
    {
      v25 = (const char ***)libssh2_hostkey_methods(v21);
      v23 = (const void *)v59;
      v24 = desta;
      destb = &desta[sub_24B99((__int64)desta, v59, v25)];
    }
    if ( *(_QWORD *)(v44 + 464) )
    {
      _libssh2_htonu32(destb, (unsigned int)v61);
      v26 = destb + 4;
      v27 = *(const void **)(v44 + 464);
      v28 = v26;
      memcpy(v26, v27, v61);
      destc = &v26[v61];
    }
    else
    {
      v29 = (const char ***)libssh2_crypt_methods(v24, v23);
      v27 = (const void *)v61;
      v28 = destb;
      destc = &destb[sub_24B99((__int64)destb, v61, v29)];
    }
    if ( *(_QWORD *)(v44 + 352) )
    {
      _libssh2_htonu32(destc, (unsigned int)v62);
      v30 = destc + 4;
      v31 = v30;
      memcpy(v30, *(const void **)(v44 + 352), v62);
      destd = &v30[v62];
    }
    else
    {
      v32 = (const char ***)libssh2_crypt_methods(v28, v27);
      v31 = destc;
      destd = &destc[sub_24B99((__int64)destc, v62, v32)];
    }
    if ( *(_QWORD *)(v44 + 472) )
    {
      _libssh2_htonu32(destd, (unsigned int)v63);
      v33 = destd + 4;
      v34 = v33;
      memcpy(v33, *(const void **)(v44 + 472), v63);
      deste = &v33[v63];
    }
    else
    {
      v35 = (const char ***)_libssh2_mac_methods(v31);
      v34 = destd;
      deste = &destd[sub_24B99((__int64)destd, v63, v35)];
    }
    if ( *(_QWORD *)(v44 + 360) )
    {
      _libssh2_htonu32(deste, (unsigned int)v64);
      v36 = deste + 4;
      memcpy(v36, *(const void **)(v44 + 360), v64);
      destf = &v36[v64];
    }
    else
    {
      v37 = (const char ***)_libssh2_mac_methods(v34);
      destf = &deste[sub_24B99((__int64)deste, v64, v37)];
    }
    if ( *(_QWORD *)(v44 + 480) )
    {
      _libssh2_htonu32(destf, (unsigned int)v65);
      v38 = destf + 4;
      memcpy(v38, *(const void **)(v44 + 480), v65);
      destg = &v38[v65];
    }
    else
    {
      v39 = (const char ***)_libssh2_comp_methods(v44);
      destg = &destf[sub_24B99((__int64)destf, v65, v39)];
    }
    if ( *(_QWORD *)(v44 + 368) )
    {
      _libssh2_htonu32(destg, (unsigned int)v66);
      v40 = destg + 4;
      memcpy(v40, *(const void **)(v44 + 368), v66);
      desth = &v40[v66];
    }
    else
    {
      v41 = (const char ***)_libssh2_comp_methods(v44);
      desth = &destg[sub_24B99((__int64)destg, v66, v41)];
    }
    if ( *(_QWORD *)(v44 + 488) )
    {
      _libssh2_htonu32(desth, (unsigned int)v67);
      v42 = desth + 4;
      memcpy(v42, *(const void **)(v44 + 488), v67);
      desti = &v42[v67];
    }
    else
    {
      desti = &desth[sub_24B99((__int64)desth, v67, 0LL)];
    }
    if ( *(_QWORD *)(v44 + 376) )
    {
      _libssh2_htonu32(desti, (unsigned int)v68);
      v43 = desti + 4;
      memcpy(v43, *(const void **)(v44 + 376), v68);
      destj = &v43[v68];
    }
    else
    {
      destj = &desti[sub_24B99((__int64)desti, v68, 0LL)];
    }
    *destj = 0;
    _libssh2_htonu32(destj + 1, 0LL);
    *(_DWORD *)(v44 + 52336) = 2;
  }
  v45 = _libssh2_transport_send(v44, v47, v46, 0LL, 0LL);
  if ( v45 == -37 )
  {
    *(_QWORD *)(v44 + 52344) = v47;
    *(_QWORD *)(v44 + 52352) = v46;
    result = 4294967259LL;
  }
  else if ( v45 )
  {
    (*(void ( **)(_BYTE *, __int64))(v44 + 24))(v47, v44);
    *(_DWORD *)(v44 + 52336) = 0;
    result = _libssh2_error(v44, v45, "Unable to send KEXINIT packet to remote host");
  }
  else
  {
    if ( *(_QWORD *)(v44 + 392) )
      (*(void ( **)(_QWORD, __int64))(v44 + 24))(*(_QWORD *)(v44 + 392), v44);
    *(_QWORD *)(v44 + 392) = v47;
    *(_QWORD *)(v44 + 400) = v46;
    *(_DWORD *)(v44 + 52336) = 0;
    result = 0LL;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8D90: using guessed type __int64  _libssh2_comp_methods(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8FF0: using guessed type __int64  libssh2_hostkey_methods(_QWORD);
// 9510: using guessed type __int64  libssh2_crypt_methods(_QWORD, _QWORD);
// 9570: using guessed type __int64  _libssh2_mac_methods(_QWORD);
// 9680: using guessed type __int64  RAND_bytes(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 250A40: using guessed type char **off_250A40[10];

//----- (000000000002550C) ----------------------------------------------------
char * sub_2550C(const char *a1, size_t a2, const char *a3, size_t a4)
{
  char *i; // rax
  size_t n; // [rsp+0h] [rbp-30h]
  char *s2; // [rsp+8h] [rbp-28h]
  char *s; // [rsp+28h] [rbp-8h]

  s2 = (char *)a3;
  n = a4;
  if ( a2 < a4 )
    return 0LL;
  if ( !strncmp(a1, a3, a4) && (n == a2 || a1[n] == 44) )
    return (char *)a1;
  for ( i = strchr(a1, 44); i && n < a2 - (i - a1); i = strchr(s, 44) )
  {
    s = i + 1;
    if ( !strncmp(i + 1, s2, n) && (a2 == s - a1 + n || s[n] == 44) )
      return s;
  }
  return 0LL;
}

//----- (000000000002561D) ----------------------------------------------------
const char ** sub_2561D(const char *a1, size_t a2, const char ***a3)
{
  const char ***i; // [rsp+8h] [rbp-18h]

  for ( i = a3; *i; ++i )
  {
    if ( a2 == strlen(**i) && !strncmp(**i, a1, a2) )
      return *i;
  }
  return 0LL;
}

//----- (000000000002568D) ----------------------------------------------------
signed __int64  sub_2568D(__int64 a1, char a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  const char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = (const char ***)libssh2_hostkey_methods(a1);
  if ( *(_QWORD *)(a1 + 96) )
  {
    for ( s = *(char **)(a1 + 96); s && *s; s = (char *)v6 )
    {
      v12 = strchr(s, 44);
      if ( v12 )
        v4 = v12 - s;
      else
        v4 = strlen(s);
      v13 = v4;
      if ( sub_2550C(v9, v8, s, v4) )
      {
        v14 = sub_2561D(s, v13, v10);
        if ( !v14 )
          return 0xFFFFFFFFLL;
        if ( (!(a2 & 1) || v14[7]) && (!(a2 & 2) || v14[5]) )
        {
          *(_QWORD *)(a1 + 160) = v14;
          return 0LL;
        }
      }
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    result = 0xFFFFFFFFLL;
  }
  else
  {
    while ( v10 && *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_2550C(v9, v8, **v10, v7) && (!(a2 & 1) || (*v10)[7]) && (!(a2 & 2) || (*v10)[5]) )
      {
        *(_QWORD *)(a1 + 160) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8FF0: using guessed type __int64  libssh2_hostkey_methods(_QWORD);

//----- (0000000000025897) ----------------------------------------------------
signed __int64  sub_25897(__int64 a1, const char *a2, size_t a3, const char *a4, size_t a5)
{
  size_t v5; // rax
  signed __int64 result; // rax
  signed __int64 v7; // rax
  size_t v8; // rax
  size_t v9; // [rsp+8h] [rbp-58h]
  const char *v10; // [rsp+10h] [rbp-50h]
  size_t v11; // [rsp+18h] [rbp-48h]
  const char ***v12; // [rsp+30h] [rbp-30h]
  char *s; // [rsp+38h] [rbp-28h]
  char *sa; // [rsp+38h] [rbp-28h]
  char *v15; // [rsp+40h] [rbp-20h]
  size_t v16; // [rsp+48h] [rbp-18h]
  char *v17; // [rsp+50h] [rbp-10h]
  const char **v18; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v12 = (const char ***)off_250A40;
  if ( *(_QWORD *)(a1 + 88) )
  {
    for ( s = *(char **)(a1 + 88); ; s = (char *)v7 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v15 = strchr(s, 44);
      v5 = v15 ? v15 - s : strlen(s);
      v16 = v5;
      v17 = sub_2550C(a2, v11, s, v5);
      if ( v17 )
      {
        v18 = sub_2561D(s, v16, (const char ***)off_250A40);
        if ( !v18 )
          return 0xFFFFFFFFLL;
        if ( !(unsigned int)sub_2568D(a1, (unsigned __int64)v18[2], v10, v9) )
          break;
      }
      if ( v15 )
        v7 = (signed __int64)(v15 + 1);
      else
        v7 = 0LL;
    }
    *(_QWORD *)(a1 + 120) = v18;
    if ( *(_BYTE *)(a1 + 128) & 1 )
    {
      if ( a2 == v17 )
        *(_BYTE *)(a1 + 128) &= 0xFEu;
    }
    result = 0LL;
  }
  else
  {
    while ( 1 )
    {
      if ( !*v12 || !**v12 )
        return 0xFFFFFFFFLL;
      v8 = strlen(**v12);
      sa = sub_2550C(a2, v11, **v12, v8);
      if ( sa )
      {
        if ( !(unsigned int)sub_2568D(a1, (unsigned __int64)(*v12)[2], v10, v9) )
          break;
      }
      ++v12;
    }
    *(_QWORD *)(a1 + 120) = *v12;
    if ( *(_BYTE *)(a1 + 128) & 1 && a2 == sa )
      *(_BYTE *)(a1 + 128) &= 0xFEu;
    result = 0LL;
  }
  return result;
}
// 250A40: using guessed type char **off_250A40[10];

//----- (0000000000025AE3) ----------------------------------------------------
signed __int64  sub_25AE3(__int64 a1, __int64 a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  const char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = (const char ***)libssh2_crypt_methods(a1, a2);
  if ( *(_QWORD *)(a2 + 80) )
  {
    for ( s = *(char **)(a2 + 80); ; s = (char *)v6 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v12 = strchr(s, 44);
      v4 = v12 ? v12 - s : strlen(s);
      v13 = v4;
      if ( sub_2550C(v9, v8, s, v4) )
        break;
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    v14 = sub_2561D(s, v13, v10);
    if ( v14 )
    {
      *(_QWORD *)(a2 + 24) = v14;
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    while ( *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_2550C(v9, v8, **v10, v7) )
      {
        *(_QWORD *)(a2 + 24) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 9510: using guessed type __int64  libssh2_crypt_methods(_QWORD, _QWORD);

//----- (0000000000025C6F) ----------------------------------------------------
signed __int64  sub_25C6F(__int64 a1, __int64 a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  const char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = (const char ***)_libssh2_mac_methods(a1);
  if ( *(_QWORD *)(a2 + 88) )
  {
    for ( s = *(char **)(a2 + 88); ; s = (char *)v6 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v12 = strchr(s, 44);
      v4 = v12 ? v12 - s : strlen(s);
      v13 = v4;
      if ( sub_2550C(v9, v8, s, v4) )
        break;
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    v14 = sub_2561D(s, v13, v10);
    if ( v14 )
    {
      *(_QWORD *)(a2 + 40) = v14;
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    while ( *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_2550C(v9, v8, **v10, v7) )
      {
        *(_QWORD *)(a2 + 40) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 9570: using guessed type __int64  _libssh2_mac_methods(_QWORD);

//----- (0000000000025DFB) ----------------------------------------------------
signed __int64  sub_25DFB(__int64 a1, __int64 a2, const char *a3, size_t a4)
{
  size_t v4; // rax
  signed __int64 result; // rax
  signed __int64 v6; // rax
  size_t v7; // rax
  size_t v8; // [rsp+0h] [rbp-50h]
  const char *v9; // [rsp+8h] [rbp-48h]
  const char ***v10; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v12; // [rsp+38h] [rbp-18h]
  size_t v13; // [rsp+40h] [rbp-10h]
  const char **v14; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v10 = (const char ***)_libssh2_comp_methods(a1);
  if ( *(_QWORD *)(a2 + 96) )
  {
    for ( s = *(char **)(a2 + 96); ; s = (char *)v6 )
    {
      if ( !s || !*s )
        return 0xFFFFFFFFLL;
      v12 = strchr(s, 44);
      v4 = v12 ? v12 - s : strlen(s);
      v13 = v4;
      if ( sub_2550C(v9, v8, s, v4) )
        break;
      if ( v12 )
        v6 = (signed __int64)(v12 + 1);
      else
        v6 = 0LL;
    }
    v14 = sub_2561D(s, v13, v10);
    if ( v14 )
    {
      *(_QWORD *)(a2 + 64) = v14;
      result = 0LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    while ( *v10 && **v10 )
    {
      v7 = strlen(**v10);
      if ( sub_2550C(v9, v8, **v10, v7) )
      {
        *(_QWORD *)(a2 + 64) = *v10;
        return 0LL;
      }
      ++v10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8D90: using guessed type __int64  _libssh2_comp_methods(_QWORD);

//----- (0000000000025F8E) ----------------------------------------------------
signed __int64  sub_25F8E(__int64 a1, __int64 a2, unsigned int a3)
{
  _BYTE *v4; // rax
  const char *v5; // [rsp+20h] [rbp-A0h]
  const char *v6; // [rsp+28h] [rbp-98h]
  const char *v7; // [rsp+30h] [rbp-90h]
  const char *v8; // [rsp+38h] [rbp-88h]
  const char *v9; // [rsp+40h] [rbp-80h]
  const char *v10; // [rsp+48h] [rbp-78h]
  const char *v11; // [rsp+50h] [rbp-70h]
  const char *v12; // [rsp+58h] [rbp-68h]
  size_t v13; // [rsp+60h] [rbp-60h]
  size_t v14; // [rsp+68h] [rbp-58h]
  size_t v15; // [rsp+70h] [rbp-50h]
  size_t v16; // [rsp+78h] [rbp-48h]
  size_t v17; // [rsp+80h] [rbp-40h]
  size_t v18; // [rsp+88h] [rbp-38h]
  size_t v19; // [rsp+90h] [rbp-30h]
  size_t v20; // [rsp+98h] [rbp-28h]
  __int64 v21; // [rsp+A0h] [rbp-20h]
  _BYTE *v22; // [rsp+A8h] [rbp-18h]
  __int64 v23; // [rsp+B0h] [rbp-10h]
  unsigned __int64 v24; // [rsp+B8h] [rbp-8h]

  v24 = __readfsqword(0x28u);
  if ( a3 <= 0x10 )
    return 0xFFFFFFFFLL;
  v21 = a2;
  v23 = a3;
  v22 = (_BYTE *)(a2 + 17);
  if ( (unsigned int)_libssh2_get_string(&v21, &v5, &v13) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v6, &v14) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v7, &v15) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v8, &v16) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v11, &v19) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v12, &v20) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v9, &v17) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)_libssh2_get_string(&v21, &v10, &v18) )
    return 0xFFFFFFFFLL;
  if ( !(unsigned int)_libssh2_check_length(&v21, 1LL) )
    return 0xFFFFFFFFLL;
  v4 = v22++;
  *(_BYTE *)(a1 + 128) = *v4 & 1 | *(_BYTE *)(a1 + 128) & 0xFE;
  if ( (unsigned int)sub_25897(a1, v5, v13, v6, v14) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_25AE3(a1, a1 + 384, v7, v15) || (unsigned int)sub_25AE3(a1, a1 + 272, v8, v16) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_25C6F(a1, a1 + 384, v11, v19) || (unsigned int)sub_25C6F(a1, a1 + 272, v12, v20) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_25DFB(a1, a1 + 384, v9, v17) || (unsigned int)sub_25DFB(a1, a1 + 272, v10, v18) )
    return 0xFFFFFFFFLL;
  return 0LL;
}
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9A40: using guessed type __int64  _libssh2_check_length(_QWORD, _QWORD);

//----- (00000000000262F0) ----------------------------------------------------
signed __int64  libssh2_kex_exchange(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v4; // [rsp+8h] [rbp-28h]
  unsigned int v5; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]
  int v7; // [rsp+2Ch] [rbp-4h]
  int v8; // [rsp+2Ch] [rbp-4h]

  v4 = a3;
  v5 = 0;
  *(_DWORD *)(a1 + 104) |= 8u;
  if ( !*a3 )
  {
    *(_DWORD *)(a1 + 104) |= 1u;
    if ( (_DWORD)a2 )
    {
      *(_QWORD *)(a1 + 120) = 0LL;
      if ( *(_QWORD *)(a1 + 160) && *(_QWORD *)(*(_QWORD *)(a1 + 160) + 64LL) )
      {
        a2 = a1 + 168;
        (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 160) + 64LL))(a1, a1 + 168);
      }
      *(_QWORD *)(a1 + 160) = 0LL;
    }
    *v4 = 2;
  }
  if ( *(_QWORD *)(a1 + 120) && *(_QWORD *)(a1 + 160) )
  {
    *v4 = 5;
  }
  else
  {
    if ( *v4 == 2 )
    {
      *((_QWORD *)v4 + 81) = *(_QWORD *)(a1 + 392);
      *((_QWORD *)v4 + 82) = *(_QWORD *)(a1 + 400);
      *(_QWORD *)(a1 + 392) = 0LL;
      *v4 = 3;
    }
    if ( *v4 == 3 )
    {
      v6 = sub_24C56(a1, a2);
      if ( v6 == -37 )
      {
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        return 4294967259LL;
      }
      if ( v6 )
      {
        *(_QWORD *)(a1 + 392) = *((_QWORD *)v4 + 81);
        *(_QWORD *)(a1 + 400) = *((_QWORD *)v4 + 82);
        *v4 = 0;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
        return 0xFFFFFFFFLL;
      }
      *v4 = 4;
    }
    if ( *v4 == 4 )
    {
      v7 = _libssh2_packet_require(a1, 20LL, v4 + 158, v4 + 160, 0LL, 0LL, 0LL, v4 + 2);
      if ( v7 == -37 )
      {
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        return 4294967259LL;
      }
      if ( v7 )
      {
        if ( *(_QWORD *)(a1 + 392) )
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 392), a1);
        *(_QWORD *)(a1 + 392) = *((_QWORD *)v4 + 81);
        *(_QWORD *)(a1 + 400) = *((_QWORD *)v4 + 82);
        *v4 = 0;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
        *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
        return 0xFFFFFFFFLL;
      }
      if ( *(_QWORD *)(a1 + 280) )
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 280), a1);
      *(_QWORD *)(a1 + 280) = *((_QWORD *)v4 + 79);
      *(_QWORD *)(a1 + 288) = *((_QWORD *)v4 + 80);
      if ( (unsigned int)sub_25F8E(a1, *((_QWORD *)v4 + 79), *((_QWORD *)v4 + 80)) )
        v5 = -5;
      *v4 = 5;
    }
  }
  if ( !v5 && *(_QWORD *)(a1 + 120) && *v4 == 5 )
  {
    v8 = (*(__int64 ( **)(__int64, _DWORD *))(*(_QWORD *)(a1 + 120) + 8LL))(a1, v4 + 6);
    if ( v8 == -37 )
    {
      *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
      return 4294967259LL;
    }
    if ( v8 )
      v5 = _libssh2_error(a1, 4294967288LL, "Unrecoverable error exchanging keys");
  }
  if ( *(_QWORD *)(a1 + 392) )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 392), a1);
    *(_QWORD *)(a1 + 392) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 280) )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 280), a1);
    *(_QWORD *)(a1 + 280) = 0LL;
  }
  *(_DWORD *)(a1 + 104) &= 0xFFFFFFF7;
  *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
  *v4 = 0;
  return v5;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000267C4) ----------------------------------------------------
__int64  libssh2_session_method_pref(__int64 a1, __int64 a2, const char *a3)
{
  const char *v3; // rdi
  __int64 result; // rax
  int v5; // eax
  size_t v6; // rax
  signed __int64 v7; // rax
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+18h] [rbp-38h]
  int v10; // [rsp+20h] [rbp-30h]
  int v11; // [rsp+24h] [rbp-2Ch]
  char **v12; // [rsp+28h] [rbp-28h]
  char *dest; // [rsp+30h] [rbp-20h]
  const char ***v14; // [rsp+38h] [rbp-18h]
  char *v15; // [rsp+40h] [rbp-10h]
  char *v16; // [rsp+48h] [rbp-8h]

  v9 = a1;
  s = (char *)a3;
  v3 = a3;
  v10 = strlen(a3);
  switch ( (unsigned __int64)(unsigned int)a2 )
  {
    case 0uLL:
      v12 = (char **)(v9 + 88);
      v14 = (const char ***)off_250A40;
      goto LABEL_13;
    case 1uLL:
      v12 = (char **)(v9 + 96);
      v14 = (const char ***)libssh2_hostkey_methods(v3);
      goto LABEL_13;
    case 2uLL:
      v12 = (char **)(v9 + 464);
      v14 = (const char ***)libssh2_crypt_methods(v3, a2);
      goto LABEL_13;
    case 3uLL:
      v12 = (char **)(v9 + 352);
      v14 = (const char ***)libssh2_crypt_methods(v3, a2);
      goto LABEL_13;
    case 4uLL:
      v12 = (char **)(v9 + 472);
      v14 = (const char ***)_libssh2_mac_methods(v3);
      goto LABEL_13;
    case 5uLL:
      v12 = (char **)(v9 + 360);
      v14 = (const char ***)_libssh2_mac_methods(v3);
      goto LABEL_13;
    case 6uLL:
      v12 = (char **)(v9 + 480);
      v14 = (const char ***)_libssh2_comp_methods(v9);
      goto LABEL_13;
    case 7uLL:
      v12 = (char **)(v9 + 368);
      v14 = (const char ***)_libssh2_comp_methods(v9);
      goto LABEL_13;
    case 8uLL:
      v12 = (char **)(v9 + 488);
      v14 = 0LL;
      goto LABEL_13;
    case 9uLL:
      v12 = (char **)(v9 + 376);
      v14 = 0LL;
LABEL_13:
      v15 = (char *)(*(__int64 ( **)(_QWORD, __int64))(v9 + 8))(v10 + 1, v9);
      dest = v15;
      if ( v15 )
      {
        memcpy(v15, s, v10 + 1);
        while ( dest && *dest && v14 )
        {
          v16 = strchr(dest, 44);
          if ( v16 )
            v5 = (_DWORD)v16 - (_DWORD)dest;
          else
            v5 = strlen(dest);
          v11 = v5;
          if ( sub_2561D(dest, v5, v14) )
          {
            if ( v16 )
              v7 = (signed __int64)(v16 + 1);
            else
              v7 = 0LL;
            dest = (char *)v7;
          }
          else if ( v16 )
          {
            v6 = strlen(dest);
            memcpy(dest, v16 + 1, v6 - v11);
          }
          else
          {
            if ( dest > v15 )
              --dest;
            *dest = 0;
          }
        }
        if ( *v15 )
        {
          if ( *v12 )
            (*(void ( **)(char *, __int64))(v9 + 24))(*v12, v9);
          *v12 = v15;
          result = 0LL;
        }
        else
        {
          (*(void ( **)(char *, __int64))(v9 + 24))(v15, v9);
          result = _libssh2_error(v9, 4294967263LL, "The requested method(s) are not currently supported");
        }
      }
      else
      {
        result = _libssh2_error(v9, 4294967290LL, "Error allocated space for method preferences");
      }
      break;
    default:
      result = _libssh2_error(v9, 4294967262LL, "Invalid parameter specified for method_type");
      break;
  }
  return result;
}
// 8D90: using guessed type __int64  _libssh2_comp_methods(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8FF0: using guessed type __int64  libssh2_hostkey_methods(_QWORD);
// 9510: using guessed type __int64  libssh2_crypt_methods(_QWORD, _QWORD);
// 9570: using guessed type __int64  _libssh2_mac_methods(_QWORD);
// 250A40: using guessed type char **off_250A40[10];

//----- (0000000000026B13) ----------------------------------------------------
__int64  libssh2_session_supported_algs(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // rax
  unsigned int v4; // eax
  _QWORD *v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+2Ch] [rbp-14h]
  int v7; // [rsp+2Ch] [rbp-14h]
  unsigned int v8; // [rsp+30h] [rbp-10h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]
  char ***v10; // [rsp+38h] [rbp-8h]

  v5 = a3;
  if ( !a3 )
    return _libssh2_error(a1, 4294967257LL, "algs must not be NULL");
  switch ( (unsigned __int64)(unsigned int)a2 )
  {
    case 0uLL:
      v10 = off_250A40;
      goto LABEL_10;
    case 1uLL:
      v10 = (char ***)libssh2_hostkey_methods(a1);
      goto LABEL_10;
    case 2uLL:
    case 3uLL:
      v10 = (char ***)libssh2_crypt_methods(a1, a2);
      goto LABEL_10;
    case 4uLL:
    case 5uLL:
      v10 = (char ***)_libssh2_mac_methods(a1);
      goto LABEL_10;
    case 6uLL:
    case 7uLL:
      v10 = (char ***)_libssh2_comp_methods(a1);
LABEL_10:
      if ( v10 )
      {
        v6 = 0;
        v9 = 0;
        while ( v10[v6] )
        {
          if ( *v10[v6] )
            ++v9;
          ++v6;
        }
        if ( v9 )
        {
          *v5 = (*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(8LL * v9, a1);
          if ( *v5 )
          {
            v7 = 0;
            v8 = 0;
            while ( v10[v7] && v8 < v9 )
            {
              if ( *v10[v7] )
              {
                v4 = v8++;
                *(_QWORD *)(*v5 + 8LL * v4) = *v10[v7];
              }
              ++v7;
            }
            if ( v8 == v9 )
            {
              result = v9;
            }
            else
            {
              (*(void ( **)(_QWORD, __int64))(a1 + 24))(*v5, a1);
              *v5 = 0LL;
              result = _libssh2_error(a1, 4294967257LL, "Internal error");
            }
          }
          else
          {
            result = _libssh2_error(a1, 4294967290LL, "Memory allocation failed");
          }
        }
        else
        {
          result = _libssh2_error(a1, 4294967262LL, "No algorithm found");
        }
      }
      else
      {
        result = _libssh2_error(a1, 4294967262LL, "No algorithm found");
      }
      break;
    default:
      result = _libssh2_error(a1, 4294967263LL, "Unknown method type");
      break;
  }
  return result;
}
// 8D90: using guessed type __int64  _libssh2_comp_methods(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8FF0: using guessed type __int64  libssh2_hostkey_methods(_QWORD);
// 9510: using guessed type __int64  libssh2_crypt_methods(_QWORD, _QWORD);
// 9570: using guessed type __int64  _libssh2_mac_methods(_QWORD);
// 250A40: using guessed type char **off_250A40[10];

//----- (0000000000026D8D) ----------------------------------------------------
__int64  sub_26D8D(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    if ( a2[11] )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(a2[11], a1);
    if ( a2[9] )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(a2[9], a1);
    if ( a2[8] )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(a2[8], a1);
    if ( a2[6] )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(a2[6], a1);
    if ( a2[3] )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(a2[3], a1);
    result = (*(__int64 ( **)(_QWORD *, __int64))(a1 + 24))(a2, a1);
  }
  return result;
}

//----- (0000000000026E90) ----------------------------------------------------
_QWORD * libssh2_knownhost_init(__int64 a1)
{
  _QWORD *result; // rax
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  v2 = (_QWORD *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(24LL, a1);
  if ( v2 )
  {
    *v2 = a1;
    _libssh2_list_init(v2 + 1);
    result = v2;
  }
  else
  {
    _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for known-hosts collection");
    result = 0LL;
  }
  return result;
}
// 8B20: using guessed type __int64  _libssh2_list_init(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000026EFD) ----------------------------------------------------
signed __int64  sub_26EFD(__int64 a1)
{
  __int64 v1; // rax

  *(_DWORD *)(a1 + 104) = -559035650;
  *(_QWORD *)(a1 + 112) = a1;
  if ( (unsigned __int16)*(_DWORD *)(a1 + 44) == 1 )
    v1 = *(_QWORD *)(a1 + 24);
  else
    v1 = 0LL;
  *(_QWORD *)(a1 + 120) = v1;
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 44);
  return a1 + 104;
}

//----- (0000000000026F71) ----------------------------------------------------
__int64  sub_26F71(__int64 *a1, const char *a2, char *a3, void *a4, size_t a5, char *a6, size_t a7, const void *a8, __int64 a9, __int64 a10, signed __int64 *a11)
{
  int v12; // eax
  unsigned int v13; // eax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  char *v17; // [rsp+10h] [rbp-60h]
  size_t n; // [rsp+18h] [rbp-58h]
  void *src; // [rsp+20h] [rbp-50h]
  char *v20; // [rsp+28h] [rbp-48h]
  unsigned int v21; // [rsp+40h] [rbp-30h]
  unsigned int v22; // [rsp+44h] [rbp-2Ch]
  __int64 v23; // [rsp+48h] [rbp-28h]
  size_t v24; // [rsp+50h] [rbp-20h]
  __int64 v25; // [rsp+58h] [rbp-18h]
  __int64 v26; // [rsp+60h] [rbp-10h]
  unsigned __int64 v27; // [rsp+68h] [rbp-8h]

  v20 = a3;
  src = a4;
  n = a5;
  v17 = a6;
  v27 = __readfsqword(0x28u);
  v24 = strlen(a2);
  if ( !(a10 & 0x3C0000) )
    return _libssh2_error(*a1, 4294967262LL, "No key type set");
  v25 = _libssh2_calloc(*a1, 144LL);
  if ( !v25 )
    return _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for known host entry");
  *(_DWORD *)(v25 + 44) = a10;
  v12 = (unsigned __int16)*(_DWORD *)(v25 + 44);
  if ( v12 == 2 )
  {
    v22 = libssh2_base64_decode(*a1, &v23, &v21, a2, (unsigned int)v24);
    if ( v22 )
      goto LABEL_37;
    *(_QWORD *)(v25 + 24) = v23;
    *(_QWORD *)(v25 + 32) = v21;
    v13 = strlen(v20);
    v22 = libssh2_base64_decode(*a1, &v23, &v21, v20, v13);
    if ( v22 )
      goto LABEL_37;
    *(_QWORD *)(v25 + 48) = v23;
    *(_QWORD *)(v25 + 56) = v21;
  }
  else
  {
    if ( v12 != 3 && v12 != 1 )
    {
      v22 = _libssh2_error(*a1, 4294967263LL, "Unknown host name type");
      goto LABEL_37;
    }
    *(_QWORD *)(v25 + 24) = (*(__int64 ( **)(size_t, __int64))(*a1 + 8))(v24 + 1, *a1);
    if ( !*(_QWORD *)(v25 + 24) )
    {
      v22 = _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for host name");
LABEL_37:
      sub_26D8D(*a1, (_QWORD *)v25);
      return v22;
    }
    memcpy(*(void **)(v25 + 24), a2, v24 + 1);
    *(_QWORD *)(v25 + 32) = v24;
  }
  if ( a10 & 0x20000 )
  {
    if ( !a7 )
      a7 = strlen(v17);
    v14 = (*(__int64 ( **)(size_t, __int64))(*a1 + 8))(a7 + 1, *a1);
    *(_QWORD *)(v25 + 64) = v14;
    if ( !*(_QWORD *)(v25 + 64) )
    {
      v22 = _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for key");
      goto LABEL_37;
    }
    memcpy(*(void **)(v25 + 64), v17, a7 + 1);
    *(_BYTE *)(*(_QWORD *)(v25 + 64) + a7) = 0;
  }
  else
  {
    v26 = _libssh2_base64_encode(*a1, v17, a7, &v23);
    if ( !v26 )
    {
      v22 = _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for base64-encoded key");
      goto LABEL_37;
    }
    *(_QWORD *)(v25 + 64) = v23;
  }
  if ( src && (a10 & 0x3C0000) == 3932160 )
  {
    v15 = (*(__int64 ( **)(size_t, __int64))(*a1 + 8))(n + 1, *a1);
    *(_QWORD *)(v25 + 72) = v15;
    if ( !*(_QWORD *)(v25 + 72) )
    {
      v22 = _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for key type");
      goto LABEL_37;
    }
    memcpy(*(void **)(v25 + 72), src, n);
    *(_BYTE *)(*(_QWORD *)(v25 + 72) + n) = 0;
    *(_QWORD *)(v25 + 80) = n;
  }
  if ( a8 )
  {
    v16 = (*(__int64 ( **)(__int64, __int64))(*a1 + 8))(a9 + 1, *a1);
    *(_QWORD *)(v25 + 88) = v16;
    if ( !*(_QWORD *)(v25 + 88) )
    {
      v22 = _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for comment");
      goto LABEL_37;
    }
    memcpy(*(void **)(v25 + 88), a8, a9 + 1);
    *(_BYTE *)(*(_QWORD *)(v25 + 88) + a9) = 0;
    *(_QWORD *)(v25 + 96) = a9;
  }
  else
  {
    *(_QWORD *)(v25 + 88) = 0LL;
  }
  _libssh2_list_add(a1 + 1, v25);
  if ( a11 )
    *a11 = sub_26EFD(v25);
  return 0LL;
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E10: using guessed type __int64  _libssh2_base64_encode(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9250: using guessed type __int64  libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (0000000000027494) ----------------------------------------------------
__int64  libssh2_knownhost_add(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, unsigned int a6, signed __int64 *a7)
{
  return sub_26F71(a1, a2, a3, 0LL, 0LL, a4, a5, 0LL, 0LL, a6, a7);
}

//----- (00000000000274F2) ----------------------------------------------------
__int64  libssh2_knownhost_addc(__int64 *a1, const char *a2, char *a3, char *a4, size_t a5, const void *a6, __int64 a7, unsigned int a8, signed __int64 *a9)
{
  return sub_26F71(a1, a2, a3, 0LL, 0LL, a4, a5, a6, a7, a8, a9);
}

//----- (0000000000027552) ----------------------------------------------------
signed __int64  sub_27552(_QWORD *a1, char *a2, unsigned int a3, char *a4, __int64 a5, int a6, signed __int64 *a7)
{
  signed __int64 v8; // rdi
  int v9; // eax
  __int64 v10; // rax
  size_t v11; // rax
  __int64 v12; // [rsp+8h] [rbp-1B8h]
  char *v13; // [rsp+10h] [rbp-1B0h]
  int v14; // [rsp+18h] [rbp-1A8h]
  char *v15; // [rsp+20h] [rbp-1A0h]
  _QWORD *v16; // [rsp+28h] [rbp-198h]
  unsigned int v17; // [rsp+34h] [rbp-18Ch]
  signed int v18; // [rsp+38h] [rbp-188h]
  _BOOL4 v19; // [rsp+3Ch] [rbp-184h]
  int v20; // [rsp+40h] [rbp-180h]
  int v21; // [rsp+44h] [rbp-17Ch]
  int v22; // [rsp+48h] [rbp-178h]
  char *v23; // [rsp+50h] [rbp-170h]
  __int64 v24; // [rsp+58h] [rbp-168h]
  __int64 i; // [rsp+60h] [rbp-160h]
  __int64 v26; // [rsp+68h] [rbp-158h]
  char *s1; // [rsp+70h] [rbp-150h]
  __int64 v28; // [rsp+78h] [rbp-148h]
  char v29; // [rsp+80h] [rbp-140h]
  char s; // [rsp+A0h] [rbp-120h]
  unsigned __int64 v31; // [rsp+1B8h] [rbp-8h]

  v16 = a1;
  v15 = a2;
  v13 = a4;
  v12 = a5;
  v14 = a6;
  v31 = __readfsqword(0x28u);
  v26 = 0LL;
  v20 = (unsigned __int16)a6;
  v23 = 0LL;
  v17 = 2;
  v19 = 0;
  if ( (unsigned __int16)a6 == 2 )
    return 1LL;
  if ( (a3 & 0x80000000) != 0 )
  {
    s1 = a2;
    v18 = 1;
  }
  else
  {
    a2 = (_BYTE *)(&qword_108 + 6);
    v21 = snprintf(&s, 0x10EuLL, "[%s]:%d", v15, a3);
    if ( v21 < 0 || v21 > 269 )
    {
      _libssh2_error(*a1, 4294967258LL, "Known-host write buffer too small");
      return 3LL;
    }
    s1 = &s;
    v18 = 2;
  }
  if ( !(v14 & 0x20000) )
  {
    a2 = v13;
    v28 = _libssh2_base64_encode(*a1, v13, v12, &v23);
    if ( !v28 )
    {
      _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for base64-encoded key");
      return 3LL;
    }
    v13 = v23;
  }
  do
  {
    v8 = (signed __int64)(v16 + 1);
    for ( i = _libssh2_list_first(v16 + 1); i; i = _libssh2_list_next(i) )
    {
      v9 = (unsigned __int16)*(_DWORD *)(i + 44);
      if ( v9 == 2 )
      {
        if ( v20 == 1 )
        {
          v24 = HMAC_CTX_new(v8, a2);
          if ( *(_QWORD *)(i + 32) == 20LL )
          {
            v10 = EVP_sha1();
            HMAC_Init_ex(v24, *(_QWORD *)(i + 48), (unsigned int)*(_QWORD *)(i + 56), v10, 0LL);
            v11 = strlen(s1);
            HMAC_Update(v24, s1, v11);
            HMAC_Final(v24, &v29, 0LL);
            HMAC_CTX_free(v24);
            a2 = *(char **)(i + 24);
            if ( !memcmp(&v29, a2, 0x14uLL) )
              v19 = 1;
          }
        }
      }
      else if ( v9 == 3 )
      {
        if ( v20 == 3 )
        {
          a2 = *(char **)(i + 24);
          v19 = strcmp(s1, a2) == 0;
        }
      }
      else if ( v9 == 1 && v20 == 1 )
      {
        a2 = *(char **)(i + 24);
        v19 = strcmp(s1, a2) == 0;
      }
      if ( v19 )
      {
        v22 = v14 & 0x3C0000;
        if ( (v14 & 0x3C0000) != 3932160 && (!v22 || v22 == (*(_DWORD *)(i + 44) & 0x3C0000)) )
        {
          a2 = *(char **)(i + 64);
          if ( !strcmp(v13, a2) )
          {
            if ( a7 )
              *a7 = sub_26EFD(i);
            v26 = 0LL;
            v17 = 0;
            break;
          }
          if ( !v26 )
            v26 = i;
        }
        v19 = 0;
      }
      v8 = i;
    }
    s1 = v15;
    if ( v19 )
      break;
    --v18;
  }
  while ( v18 );
  if ( v26 )
  {
    if ( a7 )
      *a7 = sub_26EFD(v26);
    v17 = 1;
  }
  if ( v23 )
    (*(void ( **)(char *, _QWORD))(*v16 + 24LL))(v23, *v16);
  return v17;
}
// 108: using guessed type __int64;
// 8930: using guessed type __int64  HMAC_CTX_new(_QWORD, _QWORD);
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8C10: using guessed type __int64  HMAC_Update(_QWORD, _QWORD, _QWORD);
// 8E10: using guessed type __int64  _libssh2_base64_encode(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 92D0: using guessed type __int64 EVP_sha1(void);
// 9380: using guessed type __int64  HMAC_CTX_free(_QWORD);
// 9500: using guessed type __int64  HMAC_Init_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9740: using guessed type __int64  HMAC_Final(_QWORD, _QWORD, _QWORD);

//----- (0000000000027A88) ----------------------------------------------------
signed __int64  libssh2_knownhost_check(_QWORD *a1, char *a2, char *a3, __int64 a4, int a5, signed __int64 *a6)
{
  return sub_27552(a1, a2, 0xFFFFFFFF, a3, a4, a5, a6);
}

//----- (0000000000027ADE) ----------------------------------------------------
signed __int64  libssh2_knownhost_checkp(_QWORD *a1, char *a2, unsigned int a3, char *a4, __int64 a5, int a6, signed __int64 *a7)
{
  return sub_27552(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0000000000027B2F) ----------------------------------------------------
__int64  libssh2_knownhost_del(__int64 *a1, _QWORD *a2)
{
  _QWORD *v3; // ST18_8

  if ( !a2 || *(_DWORD *)a2 != -559035650 )
    return _libssh2_error(*a1, 4294967262LL, "Invalid host information");
  v3 = (_QWORD *)a2[1];
  _libssh2_list_remove(a2[1]);
  memset(a2, 0, 0x28uLL);
  sub_26D8D(*a1, v3);
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (0000000000027BBB) ----------------------------------------------------
__int64  libssh2_knownhost_free(__int64 *a1)
{
  __int64 v1; // ST18_8
  _QWORD *i; // [rsp+10h] [rbp-10h]

  for ( i = (_QWORD *)_libssh2_list_first(a1 + 1); i; i = (_QWORD *)v1 )
  {
    v1 = _libssh2_list_next(i);
    sub_26D8D(*a1, i);
  }
  return (*(__int64 ( **)(__int64 *, __int64))(*a1 + 24))(a1, *a1);
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (0000000000027C36) ----------------------------------------------------
__int64  sub_27C36(__int64 *a1, char *a2, __int64 a3, void *a4, size_t a5, char *a6, size_t a7, int a8, const void *a9, __int64 a10)
{
  char *v11; // [rsp+10h] [rbp-160h]
  size_t v12; // [rsp+18h] [rbp-158h]
  void *v13; // [rsp+20h] [rbp-150h]
  unsigned int v14; // [rsp+4Ch] [rbp-124h]
  size_t n; // [rsp+50h] [rbp-120h]
  char *src; // [rsp+58h] [rbp-118h]
  char dest[264]; // [rsp+60h] [rbp-110h]
  unsigned __int64 v18; // [rsp+168h] [rbp-8h]

  v13 = a4;
  v12 = a5;
  v11 = a6;
  v18 = __readfsqword(0x28u);
  n = 0LL;
  src = &a2[a3];
  if ( !a3 )
    return _libssh2_error(*a1, 4294967263LL, "Failed to parse known_hosts line (no host names)");
  while ( src > a2 )
  {
    --src;
    ++n;
    if ( src == a2 || *(src - 1) == 44 )
    {
      if ( n > 0xFE )
        return _libssh2_error(*a1, 4294967263LL, "Failed to parse known_hosts line (unexpected length)");
      memcpy(dest, src, n);
      dest[n] = 0;
      v14 = sub_26F71(a1, dest, 0LL, v13, v12, v11, a7, a9, a10, a8 | 0x20001u, 0LL);
      if ( v14 )
        return v14;
      if ( src > a2 )
      {
        n = 0LL;
        --src;
      }
    }
  }
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 27C36: using guessed type char dest[264];

//----- (0000000000027E43) ----------------------------------------------------
__int64  sub_27E43(__int64 *a1, __int64 a2, __int64 a3, void *a4, size_t a5, char *a6, size_t a7, int a8, const void *a9, __int64 a10)
{
  char *v11; // [rsp+10h] [rbp-180h]
  size_t v12; // [rsp+18h] [rbp-178h]
  void *v13; // [rsp+20h] [rbp-170h]
  size_t v14; // [rsp+28h] [rbp-168h]
  unsigned __int64 v15; // [rsp+28h] [rbp-168h]
  _BYTE *i; // [rsp+40h] [rbp-150h]
  _BYTE *src; // [rsp+48h] [rbp-148h]
  size_t n; // [rsp+58h] [rbp-138h]
  char dest[32]; // [rsp+60h] [rbp-130h]
  char v20[264]; // [rsp+80h] [rbp-110h]
  unsigned __int64 v21; // [rsp+188h] [rbp-8h]

  v13 = a4;
  v12 = a5;
  v11 = a6;
  v21 = __readfsqword(0x28u);
  src = (_BYTE *)(a2 + 3);
  v14 = a3 - 3;
  for ( i = (_BYTE *)(a2 + 3); *i && *i != 124; ++i )
    ;
  if ( *i != 124 )
    return 0LL;
  n = i - src;
  if ( (unsigned __int64)(i - src) > 0x1E )
    return _libssh2_error(*a1, 4294967263LL, "Failed to parse known_hosts line (unexpectedly long salt)");
  memcpy(dest, src, n);
  dest[n] = 0;
  v15 = v14 - n - 1;
  if ( v15 > 0xFE )
    return _libssh2_error(*a1, 4294967263LL, "Failed to parse known_hosts line (unexpected length)");
  memcpy(v20, i + 1, v15);
  v20[v15] = 0;
  return sub_26F71(a1, v20, dest, v13, v12, v11, a7, a9, a10, a8 | 0x20002u, 0LL);
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 27E43: using guessed type char dest[32];
// 27E43: using guessed type char var_110[264];

//----- (000000000002809C) ----------------------------------------------------
__int64  sub_2809C(__int64 *a1, char *a2, unsigned __int64 a3, const char *a4, unsigned __int64 a5)
{
  __int64 result; // rax
  size_t v6; // [rsp+8h] [rbp-58h]
  char *v7; // [rsp+10h] [rbp-50h]
  unsigned __int64 v8; // [rsp+18h] [rbp-48h]
  int v9; // [rsp+3Ch] [rbp-24h]
  char *v10; // [rsp+40h] [rbp-20h]
  char *s1; // [rsp+48h] [rbp-18h]
  __int64 i; // [rsp+50h] [rbp-10h]
  size_t n; // [rsp+58h] [rbp-8h]

  v8 = a3;
  v7 = (char *)a4;
  v6 = a5;
  v10 = 0LL;
  s1 = 0LL;
  i = 0LL;
  n = 0LL;
  if ( a5 <= 0x13 )
    return _libssh2_error(*a1, 4294967263LL, "Failed to parse known_hosts line (key too short)");
  if ( (unsigned int)(*a4 - 48) > 9 )
  {
    s1 = (char *)a4;
    while ( v6 && *v7 && *v7 != 32 && *v7 != 9 )
    {
      ++v7;
      --v6;
    }
    n = v7 - a4;
    if ( !strncmp(a4, "ssh-dss", v7 - a4) )
    {
      v9 = 786432;
    }
    else if ( !strncmp(s1, "ssh-rsa", n) )
    {
      v9 = 0x80000;
    }
    else if ( !strncmp(s1, "ecdsa-sha2-nistp256", n) )
    {
      v9 = 0x100000;
    }
    else if ( !strncmp(s1, "ecdsa-sha2-nistp384", n) )
    {
      v9 = 1310720;
    }
    else if ( !strncmp(s1, "ecdsa-sha2-nistp521", n) )
    {
      v9 = 1572864;
    }
    else if ( !strncmp(s1, "ssh-ed25519", n) )
    {
      v9 = 1835008;
    }
    else
    {
      v9 = 3932160;
    }
    while ( *v7 == 32 || *v7 == 9 )
    {
      ++v7;
      --v6;
    }
    v10 = v7;
    for ( i = v6; i && *v10 && *v10 != 32 && *v10 != 9; --i )
      ++v10;
    v6 -= i;
    if ( !i )
      v10 = 0LL;
    while ( i && *v10 && (*v10 == 32 || *v10 == 9) )
    {
      ++v10;
      --i;
    }
  }
  else
  {
    v9 = (signed int)&loc_40000;
  }
  if ( v8 <= 2 || !memcmp(a2, "|1|", 3uLL) )
    result = sub_27E43(a1, (__int64)a2, v8, s1, n, v7, v6, v9, v10, i);
  else
    result = sub_27C36(a1, a2, v8, s1, n, v7, v6, v9, v10, i);
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (000000000002838B) ----------------------------------------------------
__int64  libssh2_knownhost_readline(__int64 *a1, char *a2, unsigned __int64 a3, int a4)
{
  __int64 result; // rax
  unsigned __int64 v5; // [rsp+8h] [rbp-48h]
  unsigned int v6; // [rsp+24h] [rbp-2Ch]
  char *v7; // [rsp+28h] [rbp-28h]
  unsigned __int64 v8; // [rsp+30h] [rbp-20h]
  char *v9; // [rsp+38h] [rbp-18h]
  unsigned __int64 v10; // [rsp+40h] [rbp-10h]
  const char *v11; // [rsp+48h] [rbp-8h]

  v5 = a3;
  if ( a4 != 1 )
    return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host information store");
  v7 = a2;
  while ( v5 && (*v7 == 32 || *v7 == 9) )
  {
    ++v7;
    --v5;
  }
  if ( !v5 || !*v7 || *v7 == 35 || *v7 == 10 )
    return 0LL;
  v9 = v7;
  while ( v5 && *v7 && *v7 != 32 && *v7 != 9 )
  {
    ++v7;
    --v5;
  }
  v10 = v7 - v9;
  while ( v5 && *v7 && (*v7 == 32 || *v7 == 9) )
  {
    ++v7;
    --v5;
  }
  if ( !*v7 || !v5 )
    return _libssh2_error(*a1, 4294967263LL, "Failed to parse known_hosts line");
  v11 = v7;
  v8 = v5;
  while ( v5 && *v7 && *v7 != 10 )
  {
    ++v7;
    --v5;
  }
  if ( *v7 == 10 )
    --v8;
  v6 = sub_2809C(a1, v9, v10, v11, v8);
  if ( v6 )
    result = v6;
  else
    result = 0LL;
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000028559) ----------------------------------------------------
__int64  libssh2_knownhost_readfile(_QWORD *a1, const char *a2, unsigned int a3)
{
  size_t v4; // rax
  unsigned int v5; // [rsp+Ch] [rbp-1034h]
  unsigned int v6; // [rsp+24h] [rbp-101Ch]
  FILE *stream; // [rsp+28h] [rbp-1018h]
  char s; // [rsp+30h] [rbp-1010h]
  unsigned __int64 v9; // [rsp+1038h] [rbp-8h]

  v5 = a3;
  v9 = __readfsqword(0x28u);
  v6 = 0;
  if ( a3 != 1 )
    return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host information store");
  stream = fopen(a2, "r");
  if ( !stream )
    return _libssh2_error(*a1, 4294967280LL, "Failed to open file");
  while ( fgets(&s, 4092, stream) )
  {
    v4 = strlen(&s);
    if ( (unsigned int)libssh2_knownhost_readline(a1, &s, v4, v5) )
    {
      v6 = _libssh2_error(*a1, 4294967250LL, "Failed to parse known hosts file");
      break;
    }
    ++v6;
  }
  fclose(stream);
  return v6;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 99B0: using guessed type __int64  libssh2_knownhost_readline(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000286BD) ----------------------------------------------------
__int64  sub_286BD(_QWORD *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6)
{
  __int64 result; // rax
  int v7; // eax
  _QWORD *v8; // [rsp+8h] [rbp-68h]
  unsigned __int64 maxlen; // [rsp+10h] [rbp-60h]
  char *s; // [rsp+18h] [rbp-58h]
  __int64 v11; // [rsp+30h] [rbp-40h]
  __int64 v12; // [rsp+38h] [rbp-38h]
  size_t v13; // [rsp+40h] [rbp-30h]
  const char *v14; // [rsp+48h] [rbp-28h]
  __int64 v15; // [rsp+50h] [rbp-20h]
  __int64 v16; // [rsp+58h] [rbp-18h]
  __int64 v17; // [rsp+60h] [rbp-10h]
  unsigned __int64 v18; // [rsp+68h] [rbp-8h]

  s = a3;
  maxlen = a4;
  v8 = a5;
  v18 = __readfsqword(0x28u);
  if ( a6 != 1 )
    return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host information store");
  v7 = *(_DWORD *)(a2 + 44) & 0x3C0000;
  if ( v7 == 0x100000 )
  {
    v14 = "ecdsa-sha2-nistp256";
    v15 = 19LL;
  }
  else if ( v7 > 0x100000 )
  {
    if ( v7 == 1572864 )
    {
      v14 = "ecdsa-sha2-nistp521";
      v15 = 19LL;
    }
    else if ( v7 > 1572864 )
    {
      if ( v7 == 1835008 )
      {
        v14 = "ssh-ed25519";
        v15 = 11LL;
      }
      else
      {
        if ( v7 != 3932160 )
          return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host entry");
        v14 = *(const char **)(a2 + 72);
        if ( !v14 )
          return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host entry");
        v15 = *(_QWORD *)(a2 + 80);
      }
    }
    else
    {
      if ( v7 != 1310720 )
        return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host entry");
      v14 = "ecdsa-sha2-nistp384";
      v15 = 19LL;
    }
  }
  else if ( v7 == 0x80000 )
  {
    v14 = "ssh-rsa";
    v15 = 7LL;
  }
  else if ( v7 == 786432 )
  {
    v14 = "ssh-dss";
    v15 = 7LL;
  }
  else
  {
    if ( v7 != (_DWORD)&loc_40000 )
      return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host entry");
    v14 = 0LL;
    v15 = 0LL;
  }
  v13 = strlen(*(const char **)(a2 + 64));
  if ( v15 )
    v13 += v15 + 1;
  if ( *(_QWORD *)(a2 + 88) )
    v13 += *(_QWORD *)(a2 + 96) + 1LL;
  if ( (unsigned __int16)*(_DWORD *)(a2 + 44) == 2 )
  {
    v16 = _libssh2_base64_encode(*a1, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), &v11);
    if ( !v16 )
      return _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for base64-encoded host name");
    v17 = _libssh2_base64_encode(*a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), &v12);
    if ( !v17 )
    {
      (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v11, *a1);
      return _libssh2_error(*a1, 4294967290LL, "Unable to allocate memory for base64-encoded salt");
    }
    v13 += v16 + v17 + 7;
    if ( v13 <= maxlen )
    {
      if ( *(_QWORD *)(a2 + 88) && v15 )
      {
        snprintf(s, maxlen, "|1|%s|%s %s %s %s\n", v12, v11, v14, *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 88));
      }
      else if ( *(_QWORD *)(a2 + 88) )
      {
        snprintf(s, maxlen, "|1|%s|%s %s %s\n", v12, v11, *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 88));
      }
      else if ( v15 )
      {
        snprintf(s, maxlen, "|1|%s|%s %s %s\n", v12, v11, v14, *(_QWORD *)(a2 + 64));
      }
      else
      {
        snprintf(s, maxlen, "|1|%s|%s %s\n", v12, v11, *(_QWORD *)(a2 + 64));
      }
    }
    (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v11, *a1);
    (*(void ( **)(__int64, _QWORD))(*a1 + 24LL))(v12, *a1);
  }
  else
  {
    v13 += *(_QWORD *)(a2 + 32) + 3LL;
    if ( v13 <= maxlen )
    {
      if ( *(_QWORD *)(a2 + 88) && v15 )
      {
        snprintf(s, maxlen, "%s %s %s %s\n", *(_QWORD *)(a2 + 24), v14, *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 88));
      }
      else if ( *(_QWORD *)(a2 + 88) )
      {
        snprintf(s, maxlen, "%s %s %s\n", *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 88));
      }
      else if ( v15 )
      {
        snprintf(s, maxlen, "%s %s %s\n", *(_QWORD *)(a2 + 24), v14, *(_QWORD *)(a2 + 64));
      }
      else
      {
        snprintf(s, maxlen, "%s %s\n", *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 64));
      }
    }
  }
  *v8 = v13 - 1;
  if ( v13 > maxlen )
    result = _libssh2_error(*a1, 4294967258LL, "Known-host write buffer too small");
  else
    result = 0LL;
  return result;
}
// 8E10: using guessed type __int64  _libssh2_base64_encode(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000028CBC) ----------------------------------------------------
__int64  libssh2_knownhost_writeline(_QWORD *a1, __int64 a2, char *a3, unsigned __int64 a4, _QWORD *a5, int a6)
{
  __int64 result; // rax

  if ( *(_DWORD *)a2 == -559035650 )
    result = sub_286BD(a1, *(_QWORD *)(a2 + 8), a3, a4, a5, a6);
  else
    result = _libssh2_error(*a1, 4294967262LL, "Invalid host information");
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000028D3A) ----------------------------------------------------
__int64  libssh2_knownhost_writefile(_QWORD *a1, const char *a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-1054h]
  unsigned int v5; // [rsp+2Ch] [rbp-1034h]
  size_t n; // [rsp+30h] [rbp-1030h]
  __int64 i; // [rsp+38h] [rbp-1028h]
  FILE *s; // [rsp+40h] [rbp-1020h]
  size_t v9; // [rsp+48h] [rbp-1018h]
  char ptr; // [rsp+50h] [rbp-1010h]
  unsigned __int64 v11; // [rsp+1058h] [rbp-8h]

  v4 = a3;
  v11 = __readfsqword(0x28u);
  v5 = 0;
  if ( a3 != 1 )
    return _libssh2_error(*a1, 4294967263LL, "Unsupported type of known-host information store");
  s = fopen(a2, "w");
  if ( !s )
    return _libssh2_error(*a1, 4294967280LL, "Failed to open file");
  for ( i = _libssh2_list_first(a1 + 1); i; i = _libssh2_list_next(i) )
  {
    n = 0LL;
    v5 = sub_286BD(a1, i, &ptr, 0xFFCuLL, &n, v4);
    if ( v5 )
      break;
    v9 = fwrite(&ptr, 1uLL, n, s);
    if ( v9 != n )
    {
      v5 = _libssh2_error(*a1, 4294967280LL, "Write failed");
      break;
    }
  }
  fclose(s);
  return v5;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (0000000000028F0C) ----------------------------------------------------
signed __int64  libssh2_knownhost_get(__int64 a1, signed __int64 *a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-10h]

  if ( a3 && *(_QWORD *)(a3 + 8) )
    v4 = _libssh2_list_next(*(_QWORD *)(a3 + 8));
  else
    v4 = _libssh2_list_first(a1 + 8);
  if ( !v4 )
    return 1LL;
  *a2 = sub_26EFD(v4);
  return 0LL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (0000000000028F91) ----------------------------------------------------
__int64  sub_28F91(__int64 a1, __int64 a2, _DWORD *a3, _QWORD *a4)
{
  *a4 = a2;
  *a3 = 0;
  return 0LL;
}

//----- (0000000000028FC1) ----------------------------------------------------
__int64  sub_28FC1(__int64 a1, _QWORD *a2)
{
  if ( *a2 )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
  *a2 = 0LL;
  return 0LL;
}

//----- (000000000002900A) ----------------------------------------------------
__int64  sub_2900A(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+20h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-18h]
  char v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  _libssh2_htonu32(&v16, a3);
  v15 = HMAC_CTX_new(&v16, v10);
  v11 = EVP_sha512();
  HMAC_Init_ex(v15, *a8, 64LL, v11, 0LL);
  HMAC_Update(v15, &v16, 4LL);
  HMAC_Update(v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(v15, v13, a7);
  HMAC_Final(v15, v14, 0LL);
  HMAC_CTX_free(v15);
  return 0LL;
}
// 8930: using guessed type __int64  HMAC_CTX_new(_QWORD, _QWORD);
// 8C10: using guessed type __int64  HMAC_Update(_QWORD, _QWORD, _QWORD);
// 9380: using guessed type __int64  HMAC_CTX_free(_QWORD);
// 9500: using guessed type __int64  HMAC_Init_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9740: using guessed type __int64  HMAC_Final(_QWORD, _QWORD, _QWORD);
// 9840: using guessed type __int64 EVP_sha512(void);

//----- (0000000000029113) ----------------------------------------------------
__int64  sub_29113(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+20h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-18h]
  char v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  _libssh2_htonu32(&v16, a3);
  v15 = HMAC_CTX_new(&v16, v10);
  v11 = EVP_sha256();
  HMAC_Init_ex(v15, *a8, 32LL, v11, 0LL);
  HMAC_Update(v15, &v16, 4LL);
  HMAC_Update(v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(v15, v13, a7);
  HMAC_Final(v15, v14, 0LL);
  HMAC_CTX_free(v15);
  return 0LL;
}
// 8930: using guessed type __int64  HMAC_CTX_new(_QWORD, _QWORD);
// 8C10: using guessed type __int64  HMAC_Update(_QWORD, _QWORD, _QWORD);
// 9380: using guessed type __int64  HMAC_CTX_free(_QWORD);
// 9500: using guessed type __int64  HMAC_Init_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9740: using guessed type __int64  HMAC_Final(_QWORD, _QWORD, _QWORD);
// 98A0: using guessed type __int64 EVP_sha256(void);

//----- (000000000002921C) ----------------------------------------------------
__int64  sub_2921C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+20h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-18h]
  char v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  _libssh2_htonu32(&v16, a3);
  v15 = HMAC_CTX_new(&v16, v10);
  v11 = EVP_sha1();
  HMAC_Init_ex(v15, *a8, 20LL, v11, 0LL);
  HMAC_Update(v15, &v16, 4LL);
  HMAC_Update(v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(v15, v13, a7);
  HMAC_Final(v15, v14, 0LL);
  HMAC_CTX_free(v15);
  return 0LL;
}
// 8930: using guessed type __int64  HMAC_CTX_new(_QWORD, _QWORD);
// 8C10: using guessed type __int64  HMAC_Update(_QWORD, _QWORD, _QWORD);
// 92D0: using guessed type __int64 EVP_sha1(void);
// 9380: using guessed type __int64  HMAC_CTX_free(_QWORD);
// 9500: using guessed type __int64  HMAC_Init_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9740: using guessed type __int64  HMAC_Final(_QWORD, _QWORD, _QWORD);

//----- (0000000000029325) ----------------------------------------------------
__int64  sub_29325(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  char src; // [rsp+30h] [rbp-20h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  sub_2921C(a1, (__int64)&src, a3, a4, a5, a6, a7, a8);
  memcpy(a2, &src, 0xCuLL);
  return 0LL;
}

//----- (00000000000293B8) ----------------------------------------------------
__int64  sub_293B8(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+20h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-18h]
  char v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  _libssh2_htonu32(&v16, a3);
  v15 = HMAC_CTX_new(&v16, v10);
  v11 = EVP_md5();
  HMAC_Init_ex(v15, *a8, 16LL, v11, 0LL);
  HMAC_Update(v15, &v16, 4LL);
  HMAC_Update(v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(v15, v13, a7);
  HMAC_Final(v15, v14, 0LL);
  HMAC_CTX_free(v15);
  return 0LL;
}
// 8930: using guessed type __int64  HMAC_CTX_new(_QWORD, _QWORD);
// 8C10: using guessed type __int64  HMAC_Update(_QWORD, _QWORD, _QWORD);
// 8D50: using guessed type __int64 EVP_md5(void);
// 9380: using guessed type __int64  HMAC_CTX_free(_QWORD);
// 9500: using guessed type __int64  HMAC_Init_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9740: using guessed type __int64  HMAC_Final(_QWORD, _QWORD, _QWORD);

//----- (00000000000294C1) ----------------------------------------------------
__int64  sub_294C1(__int64 a1, void *a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  char src; // [rsp+30h] [rbp-20h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  sub_293B8(a1, (__int64)&src, a3, a4, a5, a6, a7, a8);
  memcpy(a2, &src, 0xCuLL);
  return 0LL;
}

//----- (0000000000029554) ----------------------------------------------------
__int64  sub_29554(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, unsigned int a7, _QWORD *a8)
{
  __int64 v8; // ST10_8
  unsigned int v9; // ST18_4
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v13; // [rsp+8h] [rbp-48h]
  __int64 v14; // [rsp+20h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-18h]
  char v16; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v17; // [rsp+48h] [rbp-8h]

  v14 = a2;
  v8 = a4;
  v9 = a5;
  v13 = a6;
  v17 = __readfsqword(0x28u);
  v10 = a3;
  _libssh2_htonu32(&v16, a3);
  v15 = HMAC_CTX_new(&v16, v10);
  v11 = EVP_ripemd160();
  HMAC_Init_ex(v15, *a8, 20LL, v11, 0LL);
  HMAC_Update(v15, &v16, 4LL);
  HMAC_Update(v15, v8, v9);
  if ( v13 && a7 )
    HMAC_Update(v15, v13, a7);
  HMAC_Final(v15, v14, 0LL);
  HMAC_CTX_free(v15);
  return 0LL;
}
// 8930: using guessed type __int64  HMAC_CTX_new(_QWORD, _QWORD);
// 8C10: using guessed type __int64  HMAC_Update(_QWORD, _QWORD, _QWORD);
// 9380: using guessed type __int64  HMAC_CTX_free(_QWORD);
// 9500: using guessed type __int64  HMAC_Init_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9530: using guessed type __int64 EVP_ripemd160(void);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9740: using guessed type __int64  HMAC_Final(_QWORD, _QWORD, _QWORD);

//----- (000000000002965D) ----------------------------------------------------
char ***libssh2_mac_methods()
{
  return off_250AA0;
}
// 250AA0: using guessed type char **off_250AA0[8];

//----- (000000000002966A) ----------------------------------------------------
__int64  libssh2_error_flags(__int64 a1, unsigned int a2, char *a3, char a4)
{
  char *s; // [rsp+8h] [rbp-28h]
  char v6; // [rsp+10h] [rbp-20h]
  size_t v7; // [rsp+20h] [rbp-10h]
  void *dest; // [rsp+28h] [rbp-8h]

  s = a3;
  v6 = a4;
  if ( *(_DWORD *)(a1 + 580) & 1 )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 568), a1);
  *(_DWORD *)(a1 + 576) = a2;
  *(_DWORD *)(a1 + 580) = 0;
  if ( s && v6 & 1 )
  {
    v7 = strlen(s);
    dest = (void *)(*(__int64 ( **)(size_t, __int64))(a1 + 8))(v7 + 1, a1);
    if ( dest )
    {
      memcpy(dest, s, v7 + 1);
      *(_DWORD *)(a1 + 580) = 1;
      *(_QWORD *)(a1 + 568) = dest;
    }
    else
    {
      *(_QWORD *)(a1 + 568) = "former error forgotten (OOM)";
    }
  }
  else
  {
    *(_QWORD *)(a1 + 568) = s;
  }
  return a2;
}

//----- (000000000002977D) ----------------------------------------------------
__int64  libssh2_error(__int64 a1, unsigned int a2, __int64 a3)
{
  return _libssh2_error_flags(a1, a2, a3, 0LL);
}
// 8FA0: using guessed type __int64  _libssh2_error_flags(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000297AA) ----------------------------------------------------
signed __int64  libssh2_recv(int a1, void *a2, size_t a3, int a4)
{
  ssize_t v5; // [rsp+28h] [rbp-8h]

  v5 = recv(a1, a2, a3, a4);
  if ( v5 >= 0 )
    return v5;
  if ( *__errno_location() == 2 )
    return -11LL;
  if ( *__errno_location() == 11 )
    return -11LL;
  return -*__errno_location();
}

//----- (0000000000029821) ----------------------------------------------------
signed __int64  libssh2_send(int a1, const void *a2, size_t a3, int a4)
{
  ssize_t v5; // [rsp+28h] [rbp-8h]

  v5 = send(a1, a2, a3, a4);
  if ( v5 >= 0 )
    return v5;
  if ( *__errno_location() == 11 )
    return -11LL;
  return -*__errno_location();
}

//----- (0000000000029883) ----------------------------------------------------
__int64  libssh2_ntohu32(unsigned int *a1)
{
  return _byteswap_ulong(*a1);
}

//----- (00000000000298D2) ----------------------------------------------------
unsigned __int64  libssh2_ntohu64(unsigned __int8 *a1)
{
  return ((unsigned __int64)a1[6] << 8) | ((unsigned __int64)a1[5] << 16) | ((unsigned __int64)a1[4] << 24) | a1[7] | ((((unsigned __int64)a1[2] << 8) | ((unsigned __int64)a1[1] << 16) | ((unsigned __int64)*a1 << 24) | a1[3]) << 32);
}

//----- (000000000002998C) ----------------------------------------------------
signed __int64  libssh2_htonu32(_BYTE *a1, int a2)
{
  signed __int64 result; // rax

  *a1 = HIBYTE(a2);
  a1[1] = BYTE2(a2);
  a1[2] = BYTE1(a2);
  result = (signed __int64)(a1 + 3);
  a1[3] = a2;
  return result;
}

//----- (00000000000299D9) ----------------------------------------------------
_QWORD * libssh2_store_u32(_QWORD *a1, unsigned int a2)
{
  _QWORD *result; // rax

  _libssh2_htonu32(*a1, a2);
  result = a1;
  *result += 4LL;
  return result;
}
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (0000000000029A11) ----------------------------------------------------
__int64  libssh2_store_str(void **a1, const void *a2, size_t a3)
{
  __int64 result; // rax
  size_t n; // [rsp+8h] [rbp-18h]

  n = a3;
  result = _libssh2_store_u32(a1, (unsigned int)a3);
  if ( n )
  {
    memcpy(*a1, a2, n);
    result = (__int64)a1;
    *a1 = (char *)*a1 + n;
  }
  return result;
}
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000029A72) ----------------------------------------------------
__int64  libssh2_base64_decode(__int64 a1, _QWORD *a2, _DWORD *a3, unsigned __int8 *a4, int a5)
{
  __int64 result; // rax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // [rsp+Ch] [rbp-44h]
  unsigned __int8 *v11; // [rsp+10h] [rbp-40h]
  _DWORD *v12; // [rsp+18h] [rbp-38h]
  __int16 v13; // [rsp+36h] [rbp-1Ah]
  int v14; // [rsp+38h] [rbp-18h]
  int v15; // [rsp+3Ch] [rbp-14h]
  unsigned __int8 *i; // [rsp+40h] [rbp-10h]
  __int64 v17; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v14 = 0;
  v15 = 0;
  *a2 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(((unsigned int)(3 * a5) >> 2) + 1, a1);
  v17 = *a2;
  if ( !*a2 )
    return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for base64 decoding");
  for ( i = v11; i < &v11[v10]; ++i )
  {
    v13 = word_47700[*i];
    if ( v13 >= 0 )
    {
      v6 = v14 % 4;
      if ( v14 % 4 == 1 )
      {
        v7 = v15++;
        *(_BYTE *)(v7 + v17) |= v13 >> 4;
        *(_BYTE *)(v15 + v17) = 16 * v13;
      }
      else if ( v6 > 1 )
      {
        if ( v6 == 2 )
        {
          v8 = v15++;
          *(_BYTE *)(v8 + v17) |= v13 >> 2;
          *(_BYTE *)(v15 + v17) = (_BYTE)v13 << 6;
        }
        else if ( v6 == 3 )
        {
          v9 = v15++;
          *(_BYTE *)(v9 + v17) |= v13;
        }
      }
      else if ( !v6 )
      {
        *(_BYTE *)(v15 + v17) = 4 * v13;
      }
      ++v14;
    }
  }
  if ( v14 % 4 == 1 )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
    *a2 = 0LL;
    result = _libssh2_error(a1, 4294967262LL, "Invalid base64");
  }
  else
  {
    *v12 = v15;
    result = 0LL;
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
char aAbcdefghijklmn[];

//----- (0000000000029CCB) ----------------------------------------------------
size_t  libssh2_base64_encode(__int64 a1, const char *a2, size_t a3, char **a4)
{
  char **v5; // [rsp+0h] [rbp-50h]
  size_t v6; // [rsp+8h] [rbp-48h]
  signed int i; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  char *v9; // [rsp+28h] [rbp-28h]
  char *s; // [rsp+30h] [rbp-20h]
  char *v11; // [rsp+38h] [rbp-18h]
  unsigned __int8 v12; // [rsp+41h] [rbp-Fh]
  unsigned __int8 v13; // [rsp+42h] [rbp-Eh]
  unsigned __int8 v14; // [rsp+43h] [rbp-Dh]
  unsigned __int8 v15; // [rsp+44h] [rbp-Ch]
  unsigned __int8 v16; // [rsp+45h] [rbp-Bh]
  unsigned __int8 v17; // [rsp+46h] [rbp-Ah]
  unsigned __int8 v18; // [rsp+47h] [rbp-9h]
  unsigned __int64 v19; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v19 = __readfsqword(0x28u);
  s = (char *)a2;
  *a4 = 0LL;
  if ( !a3 )
    v6 = strlen(a2);
  v9 = (char *)(*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(
                 ((unsigned __int64)(0xAAAAAAAAAAAAAAABLL * (unsigned __int128)(4 * v6) >> 64) >> 1) + 4,
                 a1);
  v11 = v9;
  if ( !v9 )
    return 0LL;
  while ( v6 )
  {
    v8 = 0;
    for ( i = 0; i <= 2; ++i )
    {
      if ( v6 )
      {
        ++v8;
        *(&v12 + i) = *s++;
        --v6;
      }
      else
      {
        *(&v12 + i) = 0;
      }
    }
    v15 = v12 >> 2;
    v16 = 16 * v12 & 0x30 | (v13 >> 4);
    v17 = 4 * v13 & 0x3C | (v14 >> 6);
    v18 = v14 & 0x3F;
    if ( v8 == 1 )
    {
      snprintf(v9, 5uLL, "%c%c==", (unsigned int)aAbcdefghijklmn[v15], (unsigned int)aAbcdefghijklmn[v16]);
    }
    else if ( v8 == 2 )
    {
      snprintf(
        v9,
        5uLL,
        "%c%c%c=",
        (unsigned int)aAbcdefghijklmn[v15],
        (unsigned int)aAbcdefghijklmn[v16],
        (unsigned int)aAbcdefghijklmn[v17],
        v5);
    }
    else
    {
      snprintf(
        v9,
        5uLL,
        "%c%c%c%c",
        (unsigned int)aAbcdefghijklmn[v15],
        (unsigned int)aAbcdefghijklmn[v16],
        (unsigned int)aAbcdefghijklmn[v17],
        (unsigned int)aAbcdefghijklmn[v18]);
    }
    v9 += 4;
  }
  *v9 = 0;
  *v5 = v11;
  return strlen(v11);
}

//----- (0000000000029FB1) ----------------------------------------------------
__int64  libssh2_free(__int64 a1, __int64 a2)
{
  return (*(__int64 ( **)(__int64, __int64))(a1 + 24))(a2, a1);
}

//----- (0000000000029FDC) ----------------------------------------------------
__int64 libssh2_trace()
{
  return 0LL;
}

//----- (0000000000029FEE) ----------------------------------------------------
__int64 libssh2_trace_sethandler()
{
  return 0LL;
}

//----- (000000000002A005) ----------------------------------------------------
_QWORD * libssh2_list_init(_QWORD *a1)
{
  _QWORD *result; // rax

  *a1 = 0LL;
  result = a1;
  result[1] = *result;
  return result;
}

//----- (000000000002A02A) ----------------------------------------------------
_QWORD * libssh2_list_add(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  a2[2] = a1;
  *a2 = 0LL;
  a2[1] = *a1;
  *a1 = a2;
  if ( a2[1] )
  {
    result = (_QWORD *)a2[1];
    *result = a2;
  }
  else
  {
    result = a1;
    a1[1] = a2;
  }
  return result;
}

//----- (000000000002A094) ----------------------------------------------------
__int64  libssh2_list_first(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000002A0A6) ----------------------------------------------------
__int64  libssh2_list_next(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000000002A0B7) ----------------------------------------------------
__int64  libssh2_list_prev(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000002A0C9) ----------------------------------------------------
_QWORD * libssh2_list_remove(__int64 a1)
{
  _QWORD *result; // rax

  if ( *(_QWORD *)(a1 + 8) )
    **(_QWORD **)(a1 + 8) = *(_QWORD *)a1;
  else
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8LL) = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    result = *(_QWORD **)a1;
    *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)(a1 + 8);
  }
  else
  {
    result = *(_QWORD **)(a1 + 16);
    *result = *(_QWORD *)(a1 + 8);
  }
  return result;
}

//----- (000000000002A13C) ----------------------------------------------------
void * libssh2_calloc(__int64 a1, size_t a2)
{
  void *s; // [rsp+18h] [rbp-8h]

  s = (void *)(*(__int64 ( **)(size_t, __int64))(a1 + 8))(a2, a1);
  if ( s )
    memset(s, 0, a2);
  return s;
}

//----- (000000000002A18A) ----------------------------------------------------
unsigned __int64  libssh2_xor_data(_BYTE *a1, char *a2, char *a3, unsigned __int64 a4)
{
  char *v4; // rax
  char v5; // si
  char *v6; // rax
  char v7; // cl
  _BYTE *v8; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v10; // [rsp+0h] [rbp-30h]
  char *v11; // [rsp+8h] [rbp-28h]
  char *v12; // [rsp+10h] [rbp-20h]
  _BYTE *v13; // [rsp+18h] [rbp-18h]
  unsigned __int64 i; // [rsp+28h] [rbp-8h]

  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = a4;
  for ( i = 0LL; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v4 = v12++;
    v5 = *v4;
    v6 = v11++;
    v7 = *v6;
    v8 = v13++;
    *v8 = v7 ^ v5;
  }
  return result;
}

//----- (000000000002A1EA) ----------------------------------------------------
unsigned __int8 * libssh2_aes_ctr_increment(unsigned __int64 a1, __int64 a2)
{
  unsigned int v2; // ST14_4
  unsigned __int8 *v3; // rax
  unsigned __int8 *result; // rax
  signed int i; // [rsp+10h] [rbp-10h]
  unsigned __int8 *v6; // [rsp+18h] [rbp-8h]

  v6 = (unsigned __int8 *)(a2 - 1 + a1);
  for ( i = 1; ; i = v2 >> 8 )
  {
    result = v6;
    if ( (unsigned __int64)v6 < a1 )
      break;
    v2 = *v6 + i;
    v3 = v6--;
    *v3 = v2;
  }
  return result;
}

//----- (000000000002A24B) ----------------------------------------------------
__int64  libssh2_explicit_zero(__int64 a1, __int64 a2)
{
  return off_250AE8(a1, 0LL, a2);
}
// 250AE8: using guessed type __int64 ( *off_250AE8)(_QWORD, _QWORD, _QWORD);

//----- (000000000002A277) ----------------------------------------------------
__int64  libssh2_string_buf_new(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = _libssh2_calloc(a1, 24LL);
  if ( v2 )
    result = v2;
  else
    result = 0LL;
  return result;
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);

//----- (000000000002A2AC) ----------------------------------------------------
__int64  libssh2_string_buf_free(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    if ( *a2 )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*a2, a1);
    result = (*(__int64 ( **)(_QWORD *, __int64))(a1 + 24))(a2, a1);
  }
  return result;
}

//----- (000000000002A30F) ----------------------------------------------------
signed __int64  libssh2_get_u32(__int64 a1, _DWORD *a2)
{
  if ( !(unsigned int)_libssh2_check_length(a1, 4LL) )
    return 0xFFFFFFFFLL;
  *a2 = _libssh2_ntohu32(*(_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 8) += 4LL;
  return 0LL;
}
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9A40: using guessed type __int64  _libssh2_check_length(_QWORD, _QWORD);

//----- (000000000002A36E) ----------------------------------------------------
signed __int64  libssh2_get_u64(__int64 a1, _QWORD *a2)
{
  if ( !(unsigned int)_libssh2_check_length(a1, 8LL) )
    return 0xFFFFFFFFLL;
  *a2 = _libssh2_ntohu64(*(_QWORD *)(a1 + 8), 8LL);
  *(_QWORD *)(a1 + 8) += 8LL;
  return 0LL;
}
// 99E0: using guessed type __int64  _libssh2_ntohu64(_QWORD, _QWORD);
// 9A40: using guessed type __int64  _libssh2_check_length(_QWORD, _QWORD);

//----- (000000000002A3CF) ----------------------------------------------------
signed __int64  libssh2_match_string(__int64 a1, const char *a2)
{
  size_t v2; // rax
  size_t v3; // rax
  signed __int64 result; // rax
  char *s1; // [rsp+18h] [rbp-18h]
  __int64 v6; // [rsp+20h] [rbp-10h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  v6 = 0LL;
  if ( !(unsigned int)_libssh2_get_string(a1, &s1, &v6)
    && (v2 = strlen(a2), v2 == v6)
    && (v3 = strlen(a2), !strncmp(s1, a2, v3)) )
  {
    result = 0LL;
  }
  else
  {
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000002A471) ----------------------------------------------------
signed __int64  libssh2_get_string(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-28h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v6 = __readfsqword(0x28u);
  if ( (unsigned int)_libssh2_get_u32(a1, &v5) )
    return 0xFFFFFFFFLL;
  if ( !(unsigned int)_libssh2_check_length(a1, v5) )
    return 0xFFFFFFFFLL;
  *a2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) += v5;
  if ( v4 )
    *v4 = v5;
  return 0LL;
}
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 9A40: using guessed type __int64  _libssh2_check_length(_QWORD, _QWORD);

//----- (000000000002A526) ----------------------------------------------------
signed __int64  libssh2_copy_string(__int64 a1, __int64 a2, void **a3, size_t *a4)
{
  size_t *v5; // [rsp+0h] [rbp-40h]
  void **v6; // [rsp+8h] [rbp-38h]
  size_t n; // [rsp+28h] [rbp-18h]
  void *src; // [rsp+30h] [rbp-10h]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v9 = __readfsqword(0x28u);
  if ( (unsigned int)_libssh2_get_string(a2, &src, &n) )
    return 0xFFFFFFFFLL;
  *v6 = (void *)(*(__int64 ( **)(size_t, __int64))(a1 + 8))(n, a1);
  if ( !*v6 )
    return 0xFFFFFFFFLL;
  memcpy(*v6, src, n);
  if ( v5 )
    *v5 = n;
  return 0LL;
}
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);

//----- (000000000002A5ED) ----------------------------------------------------
signed __int64  libssh2_get_bignum_bytes(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-38h]
  unsigned int v5; // [rsp+28h] [rbp-18h]
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  _BYTE *i; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v8 = __readfsqword(0x28u);
  if ( (unsigned int)_libssh2_get_u32(a1, &v5) )
    return 0xFFFFFFFFLL;
  if ( !(unsigned int)_libssh2_check_length(a1, v5) )
    return 0xFFFFFFFFLL;
  v6 = v5;
  for ( i = *(_BYTE **)(a1 + 8); v6 && !*i; ++i )
    --v6;
  *a2 = i;
  *(_QWORD *)(a1 + 8) += v5;
  if ( v4 )
    *v4 = v6;
  return 0LL;
}
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 9A40: using guessed type __int64  _libssh2_check_length(_QWORD, _QWORD);

//----- (000000000002A6CD) ----------------------------------------------------
_BOOL4  libssh2_check_length(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = *a1 + a1[2] - a1[1];
  return a2 <= v3 && v3 <= a1[2];
}

//----- (000000000002A72B) ----------------------------------------------------
__int64  libssh2_bcrypt_pbkdf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7)
{
  return bcrypt_pbkdf(a1, a2, a3, a4, a5, a6, a7);
}
// 96B0: using guessed type __int64  bcrypt_pbkdf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002A779) ----------------------------------------------------
__int64  sub_2A779(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // rax
  int v6; // eax
  __int64 v7; // [rsp+0h] [rbp-70h]
  unsigned __int64 v8; // [rsp+8h] [rbp-68h]
  char v9; // [rsp+23h] [rbp-4Dh]
  unsigned int v10; // [rsp+24h] [rbp-4Ch]
  unsigned int v11; // [rsp+24h] [rbp-4Ch]
  __int64 v12; // [rsp+28h] [rbp-48h]
  __int64 v13; // [rsp+30h] [rbp-40h]
  __int64 v14; // [rsp+38h] [rbp-38h]
  __int64 v15; // [rsp+40h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-28h]
  __int64 v17; // [rsp+50h] [rbp-20h]
  __int64 v18; // [rsp+58h] [rbp-18h]
  unsigned __int64 v19; // [rsp+60h] [rbp-10h]
  unsigned __int64 v20; // [rsp+68h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v20 = __readfsqword(0x28u);
  v14 = 38LL;
  v13 = _libssh2_list_first(a1 + 536);
  v9 = 1;
  if ( !*(_DWORD *)v7 )
  {
    v15 = 20LL;
    v12 = 0LL;
    v17 = a2;
    v18 = a2;
    v19 = v8;
    if ( v8 < 0x14 )
      return _libssh2_error(a1, 4294967255LL, "Unexpected packet size");
    v18 += v15;
    if ( (unsigned int)_libssh2_get_u32(&v17, v7 + 64) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting channel");
    if ( (unsigned int)_libssh2_get_u32(&v17, v7 + 68) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting window size");
    if ( (unsigned int)_libssh2_get_u32(&v17, v7 + 72) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting packet");
    if ( (unsigned int)_libssh2_get_string(&v17, v7 + 48, &v12) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting host");
    *(_DWORD *)(v7 + 84) = v12;
    if ( (unsigned int)_libssh2_get_u32(&v17, v7 + 76) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting port");
    if ( (unsigned int)_libssh2_get_string(&v17, v7 + 56, &v12) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting shost");
    *(_DWORD *)(v7 + 88) = v12;
    if ( (unsigned int)_libssh2_get_u32(&v17, v7 + 80) )
      return _libssh2_error(a1, 4294967258LL, "Data too short extracting sport");
    *(_DWORD *)v7 = 1;
  }
  if ( *(_DWORD *)v7 == 3 )
  {
LABEL_44:
    v17 = v7 + 5;
    *(_BYTE *)(v7 + 4) = 92;
    _libssh2_store_u32(&v17, *(unsigned int *)(v7 + 64));
    _libssh2_store_u32(&v17, (unsigned int)v9);
    _libssh2_store_str(&v17, "Forward not requested", 21LL);
    _libssh2_htonu32(v17, 0LL);
    v11 = _libssh2_transport_send(a1, v7 + 4, v14, 0LL, 0LL);
    if ( v11 == -37 )
    {
      result = 4294967259LL;
    }
    else if ( v11 )
    {
      *(_DWORD *)v7 = 0;
      result = _libssh2_error(a1, v11, "Unable to send open failure");
    }
    else
    {
      *(_DWORD *)v7 = 0;
      result = 0LL;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( !v13 )
        goto LABEL_43;
      if ( *(_DWORD *)(v13 + 40) == *(_DWORD *)(v7 + 76)
        && strlen(*(const char **)(v13 + 32)) == *(_DWORD *)(v7 + 84)
        && !memcmp(*(const void **)(v13 + 32), *(const void **)(v7 + 48), *(unsigned int *)(v7 + 84)) )
      {
        v16 = 0LL;
        *(_QWORD *)(v7 + 96) = 0LL;
        if ( *(_DWORD *)v7 == 1 )
        {
          if ( *(_DWORD *)(v13 + 68) && *(_DWORD *)(v13 + 68) <= *(_DWORD *)(v13 + 64) )
          {
            v9 = 4;
            *(_DWORD *)v7 = 3;
LABEL_43:
            *(_DWORD *)v7 = 3;
            goto LABEL_44;
          }
          v16 = _libssh2_calloc(a1, 752LL);
          if ( !v16 )
          {
            _libssh2_error(a1, 4294967290LL, "Unable to allocate a channel for new connection");
            v9 = 4;
            *(_DWORD *)v7 = 3;
            goto LABEL_43;
          }
          *(_QWORD *)(v7 + 96) = v16;
          *(_QWORD *)(v16 + 96) = a1;
          *(_DWORD *)(v16 + 32) = 15;
          v5 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))((unsigned int)(*(_DWORD *)(v16 + 32) + 1), a1);
          *(_QWORD *)(v16 + 24) = v5;
          if ( !*(_QWORD *)(v16 + 24) )
          {
            _libssh2_error(a1, 4294967290LL, "Unable to allocate a channel for new connection");
            (*(void ( **)(__int64, __int64))(a1 + 24))(v16, a1);
            v9 = 4;
            *(_DWORD *)v7 = 3;
            goto LABEL_43;
          }
          memcpy(*(void **)(v16 + 24), "forwarded-tcpip", (unsigned int)(*(_DWORD *)(v16 + 32) + 1));
          *(_DWORD *)(v16 + 68) = *(_DWORD *)(v7 + 64);
          *(_DWORD *)(v16 + 72) = 0x200000;
          *(_DWORD *)(v16 + 76) = 0x200000;
          *(_DWORD *)(v16 + 80) = 0x8000;
          v6 = _libssh2_channel_nextid(a1);
          *(_DWORD *)(v16 + 48) = v6;
          *(_DWORD *)(v16 + 52) = *(_DWORD *)(v7 + 68);
          *(_DWORD *)(v16 + 56) = *(_DWORD *)(v7 + 68);
          *(_DWORD *)(v16 + 60) = *(_DWORD *)(v7 + 72);
          v17 = v7 + 5;
          *(_BYTE *)(v7 + 4) = 91;
          _libssh2_store_u32(&v17, *(unsigned int *)(v16 + 68));
          _libssh2_store_u32(&v17, *(unsigned int *)(v16 + 48));
          _libssh2_store_u32(&v17, *(unsigned int *)(v16 + 72));
          _libssh2_store_u32(&v17, *(unsigned int *)(v16 + 80));
          *(_DWORD *)v7 = 2;
        }
        if ( *(_DWORD *)v7 == 2 )
          break;
      }
      v13 = _libssh2_list_next(v13);
    }
    v10 = _libssh2_transport_send(a1, v7 + 4, 17LL, 0LL, 0LL);
    if ( v10 == -37 )
    {
      result = 4294967259LL;
    }
    else if ( v10 )
    {
      *(_DWORD *)v7 = 0;
      result = _libssh2_error(a1, v10, "Unable to send channel open confirmation");
    }
    else
    {
      if ( *(_QWORD *)(v7 + 96) )
      {
        _libssh2_list_add(v13 + 48, *(_QWORD *)(v7 + 96));
        ++*(_DWORD *)(v13 + 64);
      }
      *(_DWORD *)v7 = 0;
      result = 0LL;
    }
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9020: using guessed type __int64  _libssh2_channel_nextid(_QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (000000000002AE70) ----------------------------------------------------
__int64  sub_2AE70(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  int v5; // eax
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-70h]
  unsigned int v8; // [rsp+28h] [rbp-48h]
  int v9; // [rsp+2Ch] [rbp-44h]
  unsigned int v10; // [rsp+2Ch] [rbp-44h]
  __int64 v11; // [rsp+30h] [rbp-40h]
  __int64 v12; // [rsp+38h] [rbp-38h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  __int64 v14; // [rsp+48h] [rbp-28h]
  __int64 v15; // [rsp+50h] [rbp-20h]
  __int64 v16; // [rsp+58h] [rbp-18h]
  unsigned __int64 v17; // [rsp+60h] [rbp-10h]
  unsigned __int64 v18; // [rsp+68h] [rbp-8h]

  v7 = a4;
  v18 = __readfsqword(0x28u);
  v8 = 2;
  v13 = 40LL;
  v12 = *(_QWORD *)(a4 + 80);
  if ( !*(_DWORD *)a4 )
  {
    v14 = 8LL;
    v11 = 0LL;
    v15 = a2;
    v16 = a2;
    v17 = a3;
    if ( a3 < 8 )
    {
      _libssh2_error(a1, 4294967262LL, "unexpected data length");
      v8 = 2;
      goto LABEL_29;
    }
    v16 += v14;
    if ( (unsigned int)_libssh2_get_u32(&v15, a4 + 56) )
    {
      _libssh2_error(a1, 4294967262LL, "unexpected sender channel size");
      v8 = 2;
      goto LABEL_29;
    }
    if ( (unsigned int)_libssh2_get_u32(&v15, v7 + 60) )
    {
      _libssh2_error(a1, 4294967262LL, "unexpected window size");
      v8 = 2;
      goto LABEL_29;
    }
    if ( (unsigned int)_libssh2_get_u32(&v15, v7 + 64) )
    {
      _libssh2_error(a1, 4294967262LL, "unexpected window size");
      v8 = 2;
      goto LABEL_29;
    }
    if ( (unsigned int)_libssh2_get_string(&v15, v7 + 48, &v11) )
    {
      _libssh2_error(a1, 4294967262LL, "unexpected host size");
      v8 = 2;
      goto LABEL_29;
    }
    *(_DWORD *)(v7 + 72) = v11;
    if ( (unsigned int)_libssh2_get_u32(&v15, v7 + 68) )
    {
      _libssh2_error(a1, 4294967262LL, "unexpected port size");
      v8 = 2;
      goto LABEL_29;
    }
    *(_DWORD *)v7 = 1;
  }
  if ( !*(_QWORD *)(a1 + 64) )
  {
    v8 = 4;
    goto LABEL_29;
  }
  if ( *(_DWORD *)v7 == 1 )
  {
    v12 = _libssh2_calloc(a1, 752LL);
    if ( !v12 )
    {
      _libssh2_error(a1, 4294967290LL, "allocate a channel for new connection");
      v8 = 4;
      goto LABEL_29;
    }
    *(_QWORD *)(v12 + 96) = a1;
    *(_DWORD *)(v12 + 32) = 3;
    v4 = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))((unsigned int)(*(_DWORD *)(v12 + 32) + 1), a1);
    *(_QWORD *)(v12 + 24) = v4;
    if ( !*(_QWORD *)(v12 + 24) )
    {
      _libssh2_error(a1, 4294967290LL, "allocate a channel for new connection");
      (*(void ( **)(__int64, __int64))(a1 + 24))(v12, a1);
      v8 = 4;
      goto LABEL_29;
    }
    memcpy(*(void **)(v12 + 24), "x11", (unsigned int)(*(_DWORD *)(v12 + 32) + 1));
    *(_DWORD *)(v12 + 68) = *(_DWORD *)(v7 + 56);
    *(_DWORD *)(v12 + 72) = 0x200000;
    *(_DWORD *)(v12 + 76) = 0x200000;
    *(_DWORD *)(v12 + 80) = 0x8000;
    v5 = _libssh2_channel_nextid(a1);
    *(_DWORD *)(v12 + 48) = v5;
    *(_DWORD *)(v12 + 52) = *(_DWORD *)(v7 + 60);
    *(_DWORD *)(v12 + 56) = *(_DWORD *)(v7 + 60);
    *(_DWORD *)(v12 + 60) = *(_DWORD *)(v7 + 64);
    v15 = v7 + 5;
    *(_BYTE *)(v7 + 4) = 91;
    _libssh2_store_u32(&v15, *(unsigned int *)(v12 + 68));
    _libssh2_store_u32(&v15, *(unsigned int *)(v12 + 48));
    _libssh2_store_u32(&v15, *(unsigned int *)(v12 + 72));
    _libssh2_store_u32(&v15, *(unsigned int *)(v12 + 80));
    *(_DWORD *)v7 = 2;
  }
  if ( *(_DWORD *)v7 != 2 )
  {
LABEL_29:
    v15 = v7 + 5;
    *(_BYTE *)(v7 + 4) = 92;
    _libssh2_store_u32(&v15, *(unsigned int *)(v7 + 56));
    _libssh2_store_u32(&v15, v8);
    _libssh2_store_str(&v15, "X11 Forward Unavailable", 23LL);
    _libssh2_htonu32(v15, 0LL);
    v10 = _libssh2_transport_send(a1, v7 + 4, v13, 0LL, 0LL);
    if ( v10 == -37 )
      return 4294967259LL;
    if ( v10 )
    {
      *(_DWORD *)v7 = 0;
      result = _libssh2_error(a1, v10, "Unable to send open failure");
    }
    else
    {
      *(_DWORD *)v7 = 0;
      result = 0LL;
    }
    return result;
  }
  v9 = _libssh2_transport_send(a1, v7 + 4, 17LL, 0LL, 0LL);
  if ( v9 == -37 )
    return 4294967259LL;
  if ( v9 )
  {
    *(_DWORD *)v7 = 0;
    result = _libssh2_error(a1, 4294967289LL, "Unable to send channel open confirmation");
  }
  else
  {
    _libssh2_list_add(a1 + 512, v12);
    (*(void ( **)(_QWORD, __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v12 + 96) + 64LL))(
      *(_QWORD *)(v12 + 96),
      v12,
      *(_QWORD *)(v7 + 48),
      *(unsigned int *)(v7 + 68),
      *(_QWORD *)(v12 + 96));
    *(_DWORD *)v7 = 0;
    result = 0LL;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9020: using guessed type __int64  _libssh2_channel_nextid(_QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (000000000002B43B) ----------------------------------------------------
__int64  sub_2B43B(__int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 result; // rax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned __int64 v9; // [rsp+8h] [rbp-A8h]
  char v10; // [rsp+25h] [rbp-8Bh]
  char v11; // [rsp+26h] [rbp-8Ah]
  char v12; // [rsp+27h] [rbp-89h]
  unsigned int v13; // [rsp+28h] [rbp-88h]
  unsigned int v14; // [rsp+2Ch] [rbp-84h]
  unsigned int v15; // [rsp+30h] [rbp-80h]
  int v16; // [rsp+34h] [rbp-7Ch]
  size_t n; // [rsp+38h] [rbp-78h]
  unsigned int v18; // [rsp+40h] [rbp-70h]
  unsigned int v19; // [rsp+44h] [rbp-6Ch]
  __int64 v20; // [rsp+48h] [rbp-68h]
  __int64 v21; // [rsp+50h] [rbp-60h]
  __int64 v22; // [rsp+58h] [rbp-58h]
  __int64 v23; // [rsp+60h] [rbp-50h]
  __int64 v24; // [rsp+68h] [rbp-48h]
  unsigned __int64 v25; // [rsp+70h] [rbp-40h]
  _QWORD *v26; // [rsp+78h] [rbp-38h]
  __int64 v27; // [rsp+80h] [rbp-30h]
  __int64 v28; // [rsp+88h] [rbp-28h]
  unsigned __int64 v29; // [rsp+90h] [rbp-20h]
  char v30; // [rsp+A3h] [rbp-Dh]
  int v31; // [rsp+A4h] [rbp-Ch]
  unsigned __int64 v32; // [rsp+A8h] [rbp-8h]

  v9 = a3;
  v32 = __readfsqword(0x28u);
  v14 = 0;
  v20 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  v25 = 0LL;
  v12 = *(_BYTE *)a2;
  switch ( *(_DWORD *)(a1 + 53936) )
  {
    case 0:
      if ( a4 != -1
        || *(_QWORD *)(a1 + 56)
        && !(*(unsigned int ( **)(__int64, __int64, _QWORD, __int64))(a1 + 56))(a1, a2, (unsigned int)a3, a1) )
      {
        *(_DWORD *)(a1 + 53936) = 1;
        goto LABEL_7;
      }
      (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
      return _libssh2_error(a1, 4294967292LL, "Invalid MAC received");
    case 0xB:
LABEL_43:
      *(_DWORD *)(a1 + 53936) = 11;
      if ( (unsigned int)_libssh2_channel_receive_window_adjust(
                           *(_QWORD *)(a1 + 53944),
                           (unsigned int)(v9 - 13),
                           1LL) == -37 )
        return 4294967259LL;
      *(_DWORD *)(a1 + 53936) = 0;
      return 0LL;
    case 0xC:
LABEL_93:
      *(_DWORD *)(a1 + 53936) = 12;
      v14 = sub_2A779(a1, a2, v9, a1 + 53952);
      goto LABEL_99;
    case 0xD:
LABEL_98:
      *(_DWORD *)(a1 + 53936) = 13;
      v14 = sub_2AE70(a1, a2, v9, a1 + 54056);
LABEL_99:
      if ( v14 == -37 )
        return 4294967259LL;
      (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
      *(_DWORD *)(a1 + 53936) = 0;
      return v14;
    case 0xE:
LABEL_80:
      *(_DWORD *)(a1 + 53936) = 14;
      v30 = 100;
      v31 = *(_DWORD *)(a2 + 1);
      v14 = _libssh2_transport_send(a1, &v30, 5LL, 0LL, 0LL);
      if ( v14 == -37 )
        return 4294967259LL;
LABEL_82:
      (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
      *(_DWORD *)(a1 + 53936) = 0;
      return v14;
    case 0xF:
LABEL_30:
      *(_DWORD *)(a1 + 53936) = 15;
      v14 = _libssh2_transport_send(a1, &unk_47F18, 1LL, 0LL, 0LL);
      if ( v14 == -37 )
        return 4294967259LL;
LABEL_32:
      (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
      *(_DWORD *)(a1 + 53936) = 0;
      return 0LL;
    default:
LABEL_7:
      if ( *(_DWORD *)(a1 + 53936) == 1 )
      {
        switch ( v12 )
        {
          case 1:
            if ( v9 > 4 )
            {
              v13 = 0;
              v27 = a2;
              v29 = v9;
              v28 = a2 + 1;
              _libssh2_get_u32(&v27, &v13);
              _libssh2_get_string(&v27, &v20, &v22);
              _libssh2_get_string(&v27, &v21, &v23);
              if ( *(_QWORD *)(a1 + 48) )
                (*(void ( **)(__int64, _QWORD, __int64, _QWORD, __int64, _QWORD, __int64))(a1 + 48))(
                  a1,
                  v13,
                  v20,
                  (unsigned int)v22,
                  v21,
                  (unsigned int)v23,
                  a1);
            }
            (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 556) = -1;
            *(_DWORD *)(a1 + 53936) = 0;
            return _libssh2_error(a1, 4294967283LL, "socket disconnect");
          case 2:
            if ( v9 <= 1 )
            {
              if ( *(_QWORD *)(a1 + 32) )
                (*(void ( **)(__int64, void *, _QWORD, __int64))(a1 + 32))(a1, &unk_47C31, 0LL, a1);
            }
            else if ( *(_QWORD *)(a1 + 32) )
            {
              (*(void ( **)(__int64, __int64, _QWORD, __int64))(a1 + 32))(
                a1,
                a2 + 1,
                (unsigned int)(v9 - 1),
                a1);
            }
            (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53936) = 0;
            return 0LL;
          case 4:
            if ( v9 > 1 )
            {
              v19 = *(unsigned __int8 *)(a2 + 1);
              if ( v9 > 5 )
              {
                v27 = a2;
                v29 = v9;
                v28 = a2 + 2;
                _libssh2_get_string(&v27, &v20, &v22);
                _libssh2_get_string(&v27, &v21, &v23);
              }
              if ( *(_QWORD *)(a1 + 40) )
                (*(void ( **)(__int64, _QWORD, __int64, _QWORD, __int64, _QWORD, __int64))(a1 + 40))(
                  a1,
                  v19,
                  v20,
                  (unsigned int)v22,
                  v21,
                  (unsigned int)v23,
                  a1);
            }
            (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53936) = 0;
            return 0LL;
          case 0x50:
            if ( v9 > 4 )
            {
              v10 = 0;
              v18 = _libssh2_ntohu32(a2 + 1);
              if ( v18 <= 0xFFFFFFF9 && v9 >= v18 + 6 )
                v10 = *(_BYTE *)(v18 + 5 + a2);
              if ( v10 )
                goto LABEL_30;
            }
            goto LABEL_32;
          case 0x5A:
            if ( v9 <= 0x10 )
              goto LABEL_99;
            if ( v9 > 0x13
              && (unsigned int)_libssh2_ntohu32(a2 + 1) == 15
              && !memcmp((const void *)(a2 + 5), "forwarded-tcpip", 0xFuLL) )
            {
              memset((void *)(a1 + 53952), 0, 0x68uLL);
              goto LABEL_93;
            }
            if ( v9 <= 7 || (unsigned int)_libssh2_ntohu32(a2 + 1) != 3 || memcmp((const void *)(a2 + 5), "x11", 3uLL) )
              goto LABEL_99;
            memset((void *)(a1 + 54056), 0, 0x58uLL);
            goto LABEL_98;
          case 0x5D:
            if ( v9 > 8 )
            {
              HIDWORD(n) = _libssh2_ntohu32(a2 + 5);
              v8 = _libssh2_ntohu32(a2 + 1);
              v24 = _libssh2_channel_locate(a1, v8);
              if ( v24 )
                *(_DWORD *)(v24 + 56) += HIDWORD(n);
            }
            (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53936) = 0;
            return 0LL;
          case 0x5E:
            goto LABEL_34;
          case 0x5F:
            v25 += 4LL;
LABEL_34:
            v25 += 9LL;
            if ( v9 >= v25 )
            {
              v5 = _libssh2_ntohu32(a2 + 1);
              v24 = _libssh2_channel_locate(a1, v5);
            }
            if ( !v24 )
            {
              _libssh2_error(a1, 4294967273LL, "Packet received for unknown channel");
              (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
              *(_DWORD *)(a1 + 53936) = 0;
              return 0LL;
            }
            if ( *(_BYTE *)(v24 + 86) == 1 && v12 == 95 )
            {
              (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
              if ( *(unsigned int *)(v24 + 92) + v9 - v25 >= *(unsigned int *)(v24 + 76) )
                LODWORD(v9) = *(_DWORD *)(v24 + 76) - *(_DWORD *)(v24 + 92) + v25;
              *(_DWORD *)(v24 + 76) += v25 - v9;
              *(_QWORD *)(a1 + 53944) = v24;
              goto LABEL_43;
            }
            if ( *(unsigned int *)(v24 + 80) < v9 - v25 )
            {
              _libssh2_error(a1, 4294967271LL, "Packet contains more data than we offered to receive, truncating");
              v9 = *(unsigned int *)(v24 + 80) + v25;
            }
            if ( *(_DWORD *)(v24 + 76) <= *(_DWORD *)(v24 + 92) )
            {
              _libssh2_error(a1, 4294967272LL, "The current receive window is full, data ignored");
              (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
              *(_DWORD *)(a1 + 53936) = 0;
              return 0LL;
            }
            *(_BYTE *)(v24 + 85) = 0;
            if ( *(unsigned int *)(v24 + 92) + v9 - v25 > *(unsigned int *)(v24 + 76) )
            {
              _libssh2_error(a1, 4294967272LL, "Remote sent more data than current window allows, truncating");
              v9 = (unsigned int)(*(_DWORD *)(v24 + 76) - *(_DWORD *)(v24 + 92)) + v25;
            }
            *(_DWORD *)(v24 + 92) += v9 - v25;
LABEL_106:
            *(_DWORD *)(a1 + 53936) = 3;
            break;
          case 0x60:
            if ( v9 > 4 )
            {
              v6 = _libssh2_ntohu32(a2 + 1);
              v24 = _libssh2_channel_locate(a1, v6);
            }
            if ( v24 )
              *(_BYTE *)(v24 + 85) = 1;
            (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53936) = 0;
            return 0LL;
          case 0x61:
            if ( v9 > 4 )
            {
              v7 = _libssh2_ntohu32(a2 + 1);
              v24 = _libssh2_channel_locate(a1, v7);
            }
            if ( v24 )
            {
              *(_BYTE *)(v24 + 84) = 1;
              *(_BYTE *)(v24 + 85) = 1;
            }
            (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
            *(_DWORD *)(a1 + 53936) = 0;
            return 0LL;
          case 0x62:
            if ( v9 > 8 )
            {
              v15 = _libssh2_ntohu32(a2 + 1);
              v16 = _libssh2_ntohu32(a2 + 5);
              v11 = 1;
              if ( v9 > (unsigned int)(v16 + 9) )
                v11 = *(_BYTE *)((unsigned int)(v16 + 9) + a2);
              if ( v16 == 11 && v9 > 0x13 && !memcmp("exit-status", (const void *)(a2 + 9), 0xBuLL) )
              {
                if ( v9 > 0x13 )
                  v24 = _libssh2_channel_locate(a1, v15);
                if ( v24 && v9 > 0x18 )
                  *(_DWORD *)(v24 + 36) = _libssh2_ntohu32(a2 + 21);
              }
              else if ( v16 == 11 && v9 > 0x13 && !memcmp("exit-signal", (const void *)(a2 + 9), 0xBuLL) )
              {
                if ( v9 > 0x13 )
                  v24 = _libssh2_channel_locate(a1, v15);
                if ( v24 && v9 > 0x18 )
                {
                  LODWORD(n) = _libssh2_ntohu32(a2 + 21);
                  *(_QWORD *)(v24 + 40) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                                            (unsigned int)(n + 1),			// BUG integer overflow
                                            a1);
                  if ( *(_QWORD *)(v24 + 40) )
                  {
                    memcpy(*(void **)(v24 + 40), (const void *)(a2 + 25), (unsigned int)n);
                    *(_BYTE *)(*(_QWORD *)(v24 + 40) + (unsigned int)n) = 0;
                  }
                  else
                  {
                    v14 = _libssh2_error(a1, 4294967290LL, "memory for signal name");
                  }
                }
              }
              if ( v11 )
                goto LABEL_80;
            }
            goto LABEL_82;
          default:
            goto LABEL_106;
        }
      }
      if ( *(_DWORD *)(a1 + 53936) != 3 )
        goto LABEL_111;
      v26 = (_QWORD *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(48LL, a1);
      if ( v26 )
      {
        v26[3] = a2;
        v26[4] = v9;
        v26[5] = v25;
        _libssh2_list_add(a1 + 496, v26);
        *(_DWORD *)(a1 + 53936) = 4;
LABEL_111:
        if ( (v12 != 20 || *(_DWORD *)(a1 + 104) & 1) && *(_DWORD *)(a1 + 53936) != 5 )
          goto LABEL_121;
        if ( *(_DWORD *)(a1 + 53936) == 4 )
          *(_DWORD *)(a1 + 53936) = 5;
        *(_DWORD *)(a1 + 53384) = 0;
        *(_QWORD *)(a1 + 17008) = 0LL;
        *(_DWORD *)(a1 + 53936) = 0;
        *(_DWORD *)(a1 + 54144) = 0;
        memset((void *)(a1 + 52432), 0, 0x298uLL);
        if ( (unsigned int)_libssh2_kex_exchange(a1, 1LL, a1 + 52432) != -37 )
        {
LABEL_121:
          *(_DWORD *)(a1 + 53936) = 0;
          result = 0LL;
        }
        else
        {
          result = 4294967259LL;
        }
      }
      else
      {
        (*(void ( **)(__int64, __int64))(a1 + 24))(a2, a1);
        *(_DWORD *)(a1 + 53936) = 0;
        result = 4294967290LL;
      }
      return result;
  }
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8A90: using guessed type __int64  _libssh2_channel_locate(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F00: using guessed type __int64  _libssh2_kex_exchange(_QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (000000000002C58C) ----------------------------------------------------
__int64  libssh2_packet_ask(size_t n, char a2, _QWORD *a3, _QWORD *a4, int a5, void *a6, size_t na)
{
  void *s2; // [rsp+8h] [rbp-38h]
  _QWORD *v9; // [rsp+10h] [rbp-30h]
  _QWORD *v10; // [rsp+18h] [rbp-28h]
  int v11; // [rsp+20h] [rbp-20h]
  __int64 i; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v11 = a5;
  s2 = a6;
  for ( i = _libssh2_list_first(n + 496); i; i = _libssh2_list_next(i) )
  {
    if ( a2 == **(_BYTE **)(i + 24)
      && *(_QWORD *)(i + 32) >= v11 + na
      && (!s2 || !memcmp((const void *)(*(_QWORD *)(i + 24) + v11), s2, na)) )
    {
      *v10 = *(_QWORD *)(i + 24);
      *v9 = *(_QWORD *)(i + 32);
      _libssh2_list_remove(i);
      (*(void ( **)(__int64, size_t))(n + 24))(i, n);
      return 0LL;
    }
  }
  return 0xFFFFFFFFLL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (000000000002C690) ----------------------------------------------------
signed __int64  libssh2_packet_askv(size_t a1, const char *a2)
{
  int i; // [rsp+38h] [rbp-8h]
  int v4; // [rsp+3Ch] [rbp-4h]

  v4 = strlen(a2);
  for ( i = 0; i < v4; ++i )
  {
    if ( !(unsigned int)_libssh2_packet_ask(a1) )
      return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000002C725) ----------------------------------------------------
signed __int64  libssh2_packet_require(size_t a1, unsigned __int8 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  signed __int64 result; // rax
  unsigned int v9; // [rsp+34h] [rbp-Ch]

  if ( *(_QWORD *)(a8 + 8) )
  {
    do
    {
LABEL_15:
      if ( *(_DWORD *)(a1 + 556) )
        return 4294967283LL;
      v9 = _libssh2_transport_read(a1);
      if ( v9 == -37 )
        return 4294967259LL;
      if ( (v9 & 0x80000000) != 0 )
      {
        *(_QWORD *)(a8 + 8) = 0LL;
        return v9;
      }
      if ( v9 == a2 )
      {
        LODWORD(result) = _libssh2_packet_ask(a1);
        *(_QWORD *)(a8 + 8) = 0LL;
        return (unsigned int)result;
      }
    }
    while ( v9 );
    if ( 60 - (time(0LL) - *(_QWORD *)(a8 + 8)) > 0 )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      *(_QWORD *)(a8 + 8) = 0LL;
      result = 4294967287LL;
    }
  }
  else
  {
    if ( (unsigned int)_libssh2_packet_ask(a1) )
    {
      *(_QWORD *)(a8 + 8) = time(0LL);
      goto LABEL_15;
    }
    result = 0LL;
  }
  return result;
}
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);

//----- (000000000002C89D) ----------------------------------------------------
signed __int64  libssh2_packet_burn(size_t a1, _DWORD *a2)
{
  unsigned __int8 v2; // ST2B_1
  signed __int64 result; // rax
  unsigned __int8 i; // [rsp+1Bh] [rbp-125h]
  unsigned int v5; // [rsp+1Ch] [rbp-124h]
  unsigned __int8 *v6; // [rsp+20h] [rbp-120h]
  char v7; // [rsp+28h] [rbp-118h]
  char v8[254]; // [rsp+30h] [rbp-110h]
  char v9; // [rsp+12Eh] [rbp-12h]
  unsigned __int64 v10; // [rsp+138h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  if ( *a2 )
  {
LABEL_15:
    while ( !*(_DWORD *)(a1 + 556) )
    {
      v5 = _libssh2_transport_read(a1);
      if ( v5 == -37 )
        return 4294967259LL;
      if ( (v5 & 0x80000000) != 0 )
      {
        *a2 = 0;
        return v5;
      }
      if ( v5 && !(unsigned int)_libssh2_packet_ask(a1) )
      {
        (*(void ( **)(unsigned __int8 *, size_t))(a1 + 24))(v6, a1);
        *a2 = 0;
        return v5;
      }
    }
    result = 4294967283LL;
  }
  else
  {
    for ( i = 1; i != -1; ++i )
      v8[i - 1] = i;
    v9 = 0;
    if ( (unsigned int)_libssh2_packet_askv(a1, v8, &v6, &v7, 0LL, 0LL, 0LL) )
    {
      *a2 = 2;
      goto LABEL_15;
    }
    v2 = *v6;
    (*(void ( **)(unsigned __int8 *, size_t))(a1 + 24))(v6, a1);
    result = v2;
  }
  return result;
}
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);
// 9AA0: using guessed type __int64  _libssh2_packet_askv(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2C89D: using guessed type char var_110[254];

//----- (000000000002CA9E) ----------------------------------------------------
__int64  libssh2_packet_requirev(__int64 a1, const char *a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7, time_t *a8)
{
  __int64 result; // rax
  __int64 v9; // [rsp+8h] [rbp-40h]
  unsigned int v10; // [rsp+14h] [rbp-34h]
  __int64 v11; // [rsp+18h] [rbp-30h]
  __int64 v12; // [rsp+20h] [rbp-28h]
  int c; // [rsp+3Ch] [rbp-Ch]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( (unsigned int)_libssh2_packet_askv(a1, a2, a3, a4, a5, a6, a7) )
  {
    if ( !*a8 )
      *a8 = time(0LL);
    while ( *(_DWORD *)(a1 + 556) != -1 )
    {
      c = _libssh2_transport_read(a1);
      if ( c < 0 && c != -37 )
      {
        *a8 = 0LL;
        return (unsigned int)c;
      }
      if ( c <= 0 )
      {
        if ( 60 - (time(0LL) - *a8) <= 0 )
        {
          *a8 = 0LL;
          return 4294967287LL;
        }
        if ( c == -37 )
          return 4294967259LL;
      }
      if ( strchr(a2, c) )
        return _libssh2_packet_askv(a1, a2, v12, v11, v10, v9, a7);
    }
    *a8 = 0LL;
    result = 4294967283LL;
  }
  else
  {
    *a8 = 0LL;
    result = 0LL;
  }
  return result;
}
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);
// 9AA0: using guessed type __int64  _libssh2_packet_askv(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CC1E) ----------------------------------------------------
signed __int64  sub_2CC1E(char *a1, int a2, FILE *a3)
{
  size_t v4; // [rsp+28h] [rbp-8h]
  size_t v5; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !fgets(a1, a2, a3) )
    return 0xFFFFFFFFLL;
  if ( *a1 )
  {
    v4 = strlen(a1);
    if ( v4 )
    {
      if ( a1[v4 - 1] == 10 )
        a1[v4 - 1] = 0;
    }
  }
  if ( *a1 )
  {
    v5 = strlen(a1);
    if ( v5 )
    {
      if ( a1[v5 - 1] == 13 )
        a1[v5 - 1] = 0;
    }
  }
  return 0LL;
}

//----- (000000000002CD01) ----------------------------------------------------
__int64  sub_2CD01(void *a1, __int64 a2, __int64 a3, unsigned __int64 a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+8h] [rbp-38h]
  unsigned __int64 n; // [rsp+30h] [rbp-10h]
  __int64 v8; // [rsp+38h] [rbp-8h]

  v6 = a5;
  v8 = *a5;
  for ( n = 0LL; a4 > v8 + n && n < a2 - 1 && *(_BYTE *)(n + v8 + a3) != 10 && *(_BYTE *)(n + v8 + a3) != 13; ++n )
    ;
  if ( n )
  {
    memcpy(a1, (const void *)(a3 + v8), n);
    *v6 += n;
  }
  *((_BYTE *)a1 + n) = 0;
  ++*v6;
  return 0LL;
}

//----- (000000000002CDEA) ----------------------------------------------------
__int64  sub_2CDEA(unsigned __int8 a1)
{
  __int64 result; // rax

  if ( (char)a1 <= 64 )
    result = (unsigned int)a1 - 48;
  else
    result = (unsigned int)a1 - 55;
  return result;
}

//----- (000000000002CE0B) ----------------------------------------------------
signed __int64  libssh2_pem_parse(__int64 a1, const char *a2, char *a3, char *a4, FILE *a5, _QWORD *a6, _DWORD *a7)
{
  size_t v8; // rax
  size_t v9; // rax
  size_t v10; // rbx
  size_t v11; // rax
  __int64 *v12; // rax
  __int64 v13; // rax
  size_t v14; // rax
  size_t v15; // rax
  _QWORD *v16; // [rsp+10h] [rbp-1D0h]
  FILE *v17; // [rsp+18h] [rbp-1C8h]
  char *s; // [rsp+20h] [rbp-1C0h]
  char *v19; // [rsp+28h] [rbp-1B8h]
  int v20; // [rsp+40h] [rbp-1A0h]
  int v21; // [rsp+44h] [rbp-19Ch]
  unsigned int v22; // [rsp+48h] [rbp-198h]
  unsigned int v23; // [rsp+4Ch] [rbp-194h]
  int i; // [rsp+50h] [rbp-190h]
  int v25; // [rsp+54h] [rbp-18Ch]
  int v26; // [rsp+58h] [rbp-188h]
  unsigned int v27; // [rsp+5Ch] [rbp-184h]
  char v28; // [rsp+60h] [rbp-180h]
  __int64 v29; // [rsp+68h] [rbp-178h]
  __int64 v30; // [rsp+70h] [rbp-170h]
  __int64 v31; // [rsp+78h] [rbp-168h]
  __int64 *v32; // [rsp+80h] [rbp-160h]
  __int64 v33; // [rsp+88h] [rbp-158h]
  size_t n; // [rsp+90h] [rbp-150h]
  __int64 v35; // [rsp+98h] [rbp-148h]
  char v36; // [rsp+A0h] [rbp-140h]
  __int64 v37; // [rsp+B0h] [rbp-130h]
  char s1[128]; // [rsp+C0h] [rbp-120h]
  char dest[136]; // [rsp+140h] [rbp-A0h]
  unsigned __int64 v40; // [rsp+1C8h] [rbp-18h]

  v19 = a3;
  s = a4;
  v17 = a5;
  v16 = a6;
  v40 = __readfsqword(0x28u);
  v30 = 0LL;
  v22 = 0;
  v31 = 0LL;
  do
  {
    s1[0] = 0;
    if ( (unsigned int)sub_2CC1E(s1, 128, v17) )
      return 0xFFFFFFFFLL;
  }
  while ( strcmp(s1, a2) );
  if ( (unsigned int)sub_2CC1E(s1, 128, v17) )
    return 0xFFFFFFFFLL;
  if ( s )
  {
    v8 = strlen(s);
    if ( !memcmp(s1, s, v8) )
    {
      if ( (unsigned int)sub_2CC1E(s1, 128, v17) )
      {
        v23 = -1;
      }
      else
      {
        v32 = (__int64 *)libssh2_crypt_methods(s1, 128LL);
        while ( 1 )
        {
          v12 = v32;
          ++v32;
          v33 = *v12;
          if ( !v33 )
            break;
          if ( **(_BYTE **)(v33 + 8) )
          {
            v9 = strlen(*(const char **)(v33 + 8));
            if ( !memcmp(s1, *(const void **)(v33 + 8), v9) )
            {
              v31 = v33;
              v10 = 2 * *(_DWORD *)(v33 + 20);
              v11 = strlen(*(const char **)(v33 + 8));
              memcpy(dest, &s1[v11 + 1], v10);
            }
          }
        }
        if ( !v31 )
          return 0xFFFFFFFFLL;
        for ( i = 0; i < *(_DWORD *)(v31 + 20); ++i )
        {
          dest[i] = 16 * (unsigned __int64)sub_2CDEA(dest[2 * i]);
          dest[i] |= sub_2CDEA(dest[2 * i + 1]);
        }
        if ( !(unsigned int)sub_2CC1E(s1, 128, v17) )
          goto LABEL_23;
        v23 = -1;
      }
      goto LABEL_56;
    }
  }
  do
  {
LABEL_23:
    if ( s1[0] )
    {
      n = strlen(s1);
      if ( v30 )
        v13 = (*(__int64 ( **)(__int64, size_t, __int64))(a1 + 16))(v30, n + v22, a1);
      else
        v13 = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(v22 + n, a1);
      v35 = v13;
      if ( !v13 )
      {
        v23 = -1;
        goto LABEL_56;
      }
      memcpy((void *)(v22 + v35), s1, n);
      v30 = v35;
      v22 += n;
    }
    s1[0] = 0;
    if ( (unsigned int)sub_2CC1E(s1, 128, v17) )
    {
      v23 = -1;
      goto LABEL_56;
    }
  }
  while ( strcmp(s1, v19) );
  if ( !v30 )
    return 0xFFFFFFFFLL;
  if ( !(unsigned int)libssh2_base64_decode(a1, v16, a7, v30, v22) )
  {
    if ( v31 )
    {
      v20 = 0;
      v21 = 0;
      v25 = 0;
      v26 = 0;
      v27 = *(_DWORD *)(v31 + 16);
      if ( !(unsigned int)_libssh2_md5_init(&v29) )
      {
        v23 = -1;
        goto LABEL_56;
      }
      v14 = strlen(s);
      EVP_DigestUpdate(v29, s, v14);
      EVP_DigestUpdate(v29, dest, 8LL);
      EVP_DigestFinal(v29, &v36, 0LL);
      EVP_MD_CTX_free(v29);
      if ( *(_DWORD *)(v31 + 24) > 16 )
      {
        if ( !(unsigned int)_libssh2_md5_init(&v29) )
        {
          v23 = -1;
          goto LABEL_56;
        }
        EVP_DigestUpdate(v29, &v36, 16LL);
        v15 = strlen(s);
        EVP_DigestUpdate(v29, s, v15);
        EVP_DigestUpdate(v29, dest, 8LL);
        EVP_DigestFinal(v29, &v37, 0LL);
        EVP_MD_CTX_free(v29);
      }
      if ( (*(unsigned int ( **)(__int64, __int64, char *, int *, char *, int *, _QWORD, char *))(v31 + 40))(
             a1,
             v31,
             dest,
             &v20,
             &v36,
             &v21,
             0LL,
             &v28) )
      {
        _libssh2_explicit_zero(&v36, 32LL);
        (*(void ( **)(_QWORD *, __int64))(a1 + 24))(v16, a1);
        v23 = -1;
        goto LABEL_56;
      }
      if ( v21 )
        _libssh2_explicit_zero(&v36, 32LL);
      if ( *a7 % v27 )
      {
        _libssh2_explicit_zero(&v36, 32LL);
        (*(void ( **)(__int64, char *))(v31 + 56))(a1, &v28);
        _libssh2_explicit_zero(*v16, (unsigned int)*a7);
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*v16, a1);
        v23 = -1;
        goto LABEL_56;
      }
      while ( v25 <= (signed int)(*a7 - v27) )
      {
        if ( (*(unsigned int ( **)(__int64, _QWORD, _QWORD, char *))(v31 + 48))(
               a1,
               v25 + *v16,
               (signed int)v27,
               &v28) )
        {
          v23 = -12;
          _libssh2_explicit_zero(&v36, 32LL);
          (*(void ( **)(__int64, char *))(v31 + 56))(a1, &v28);
          _libssh2_explicit_zero(*v16, (unsigned int)*a7);
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*v16, a1);
          goto LABEL_56;
        }
        v25 += v27;
      }
      v26 = *(unsigned __int8 *)(*v16 + (unsigned int)(*a7 - 1));
      memset((void *)((unsigned int)(*a7 - v26) + *v16), 0, v26);
      *a7 -= v26;
      _libssh2_explicit_zero(&v36, 32LL);
      (*(void ( **)(__int64, char *))(v31 + 56))(a1, &v28);
    }
    v23 = 0;
    goto LABEL_56;
  }
  v23 = -1;
LABEL_56:
  if ( v30 )
  {
    _libssh2_explicit_zero(v30, v22);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v30, a1);
  }
  return v23;
}
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8DD0: using guessed type __int64  EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 8F90: using guessed type __int64  EVP_DigestFinal(_QWORD, _QWORD, _QWORD);
// 9250: using guessed type __int64  libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9510: using guessed type __int64  libssh2_crypt_methods(_QWORD, _QWORD);
// 9630: using guessed type __int64  EVP_MD_CTX_free(_QWORD);
// 9920: using guessed type __int64  _libssh2_md5_init(_QWORD);
// 2CE0B: using guessed type char s1[128];
// 2CE0B: using guessed type char dest[136];

//----- (000000000002D7C2) ----------------------------------------------------
signed __int64  libssh2_pem_parse_memory(__int64 a1, const char *a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v8; // rax
  __int64 v9; // [rsp+10h] [rbp-F0h]
  unsigned __int64 v10; // [rsp+18h] [rbp-E8h]
  __int64 v11; // [rsp+20h] [rbp-E0h]
  char *v12; // [rsp+28h] [rbp-D8h]
  unsigned int v13; // [rsp+48h] [rbp-B8h]
  unsigned int v14; // [rsp+4Ch] [rbp-B4h]
  __int64 v15; // [rsp+50h] [rbp-B0h]
  __int64 v16; // [rsp+58h] [rbp-A8h]
  size_t n; // [rsp+60h] [rbp-A0h]
  __int64 v18; // [rsp+68h] [rbp-98h]
  char s1; // [rsp+70h] [rbp-90h]
  unsigned __int64 v20; // [rsp+F8h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v20 = __readfsqword(0x28u);
  v16 = 0LL;
  v13 = 0;
  v15 = 0LL;
  do
  {
    s1 = 0;
    if ( (unsigned int)sub_2CD01(&s1, 128LL, v11, v10, &v15) )
      return 0xFFFFFFFFLL;
  }
  while ( strcmp(&s1, a2) );
  s1 = 0;
  do
  {
    if ( s1 )
    {
      n = strlen(&s1);
      if ( v16 )
        v8 = (*(__int64 ( **)(__int64, size_t, __int64))(a1 + 16))(v16, n + v13, a1);
      else
        v8 = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(v13 + n, a1);
      v18 = v8;
      if ( !v8 )
      {
        v14 = -1;
        goto LABEL_21;
      }
      memcpy((void *)(v13 + v18), &s1, n);
      v16 = v18;
      v13 += n;
    }
    s1 = 0;
    if ( (unsigned int)sub_2CD01(&s1, 128LL, v11, v10, &v15) )
    {
      v14 = -1;
      goto LABEL_21;
    }
  }
  while ( strcmp(&s1, v12) );
  if ( !v16 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)libssh2_base64_decode(a1, v9, a7, v16, v13) )
    v14 = -1;
  else
    v14 = 0;
LABEL_21:
  if ( v16 )
  {
    _libssh2_explicit_zero(v16, v13);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v16, a1);
  }
  return v14;
}
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 9250: using guessed type __int64  libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002DAA2) ----------------------------------------------------
__int64  sub_2DAA2(__int64 a1, const char *a2, __int64 a3, unsigned int a4, _QWORD *a5)
{
  char *v5; // rdi
  size_t v6; // rax
  const char ***v7; // rax
  __int64 v8; // r13
  __int64 v9; // r14
  __int64 v10; // r12
  __int64 v11; // rbx
  size_t v12; // rax
  __int64 v13; // rax
  _QWORD *v15; // [rsp+8h] [rbp-168h]
  __int64 v16; // [rsp+28h] [rbp-148h]
  int v17; // [rsp+3Ch] [rbp-134h]
  unsigned int v18; // [rsp+40h] [rbp-130h]
  unsigned int v19; // [rsp+44h] [rbp-12Ch]
  int v20; // [rsp+48h] [rbp-128h]
  int v21; // [rsp+4Ch] [rbp-124h]
  unsigned int v22; // [rsp+50h] [rbp-120h]
  int v23; // [rsp+54h] [rbp-11Ch]
  int v24; // [rsp+58h] [rbp-118h]
  int v25; // [rsp+5Ch] [rbp-114h]
  int v26; // [rsp+60h] [rbp-110h]
  int v27; // [rsp+64h] [rbp-10Ch]
  char *v28; // [rsp+68h] [rbp-108h]
  char *v29; // [rsp+70h] [rbp-100h]
  __int64 v30; // [rsp+78h] [rbp-F8h]
  _BYTE *v31; // [rsp+80h] [rbp-F0h]
  __int64 v32; // [rsp+88h] [rbp-E8h]
  char *v33; // [rsp+90h] [rbp-E0h]
  __int64 v34; // [rsp+98h] [rbp-D8h]
  size_t v35; // [rsp+A0h] [rbp-D0h]
  __int64 v36; // [rsp+A8h] [rbp-C8h]
  __int64 v37; // [rsp+B0h] [rbp-C0h]
  const char **v38; // [rsp+B8h] [rbp-B8h]
  void *src; // [rsp+C0h] [rbp-B0h]
  void *dest; // [rsp+C8h] [rbp-A8h]
  void *v41; // [rsp+D0h] [rbp-A0h]
  const char ***v42; // [rsp+D8h] [rbp-98h]
  const char **v43; // [rsp+E0h] [rbp-90h]
  __int64 v44; // [rsp+E8h] [rbp-88h]
  char *v45; // [rsp+F0h] [rbp-80h]
  char *s1; // [rsp+F8h] [rbp-78h]
  __int64 v47; // [rsp+100h] [rbp-70h]
  void *v48; // [rsp+110h] [rbp-60h]
  _BYTE *v49; // [rsp+118h] [rbp-58h]
  size_t n; // [rsp+120h] [rbp-50h]
  __int64 v51; // [rsp+130h] [rbp-40h]
  __int64 v52; // [rsp+138h] [rbp-38h]
  __int64 v53; // [rsp+140h] [rbp-30h]
  unsigned __int64 v54; // [rsp+148h] [rbp-28h]

  v16 = a1;
  v15 = a5;
  v54 = __readfsqword(0x28u);
  v38 = 0LL;
  v28 = 0LL;
  v29 = 0LL;
  v30 = 0LL;
  v31 = 0LL;
  v32 = 0LL;
  v18 = 0;
  src = 0LL;
  dest = 0LL;
  v41 = 0LL;
  v33 = 0LL;
  v19 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v34 = 0LL;
  v35 = 0LL;
  v36 = 0LL;
  if ( a5 )
    *a5 = 0LL;
  if ( (unsigned int)libssh2_base64_decode(a1, &v33, &v19, a3, a4) )
  {
    v22 = -1;
    goto LABEL_79;
  }
  v45 = v33;
  s1 = v33;
  v47 = v19;
  if ( v19 <= 0xDuLL )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "key too short");
    goto LABEL_79;
  }
  if ( strncmp(s1, "openssh-key-v1", 0xEuLL) )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "key auth magic mismatch");
    goto LABEL_79;
  }
  s1 += 15;
  if ( (unsigned int)_libssh2_get_string(&v45, &v28, &v35) || !v35 )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "ciphername is missing");
    goto LABEL_79;
  }
  if ( (unsigned int)_libssh2_get_string(&v45, &v29, &v35) || !v35 )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "kdfname is missing");
    goto LABEL_79;
  }
  if ( (unsigned int)_libssh2_get_string(&v45, &v30, &v34) )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "kdf is missing");
    goto LABEL_79;
  }
  v51 = v30;
  v52 = v30;
  v53 = v34;
  if ( (!a2 || !*a2) && strcmp(v28, "none") )
  {
    v22 = -48;
    goto LABEL_79;
  }
  if ( strcmp(v29, "none") && strcmp(v29, "bcrypt") )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "unknown cipher");
    goto LABEL_79;
  }
  if ( !strcmp(v29, "none") && strcmp(v28, "none") )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "invalid format");
    goto LABEL_79;
  }
  if ( (unsigned int)_libssh2_get_u32(&v45, &v17) || v17 != 1 )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "Multiple keys are unsupported");
    goto LABEL_79;
  }
  if ( (unsigned int)_libssh2_get_string(&v45, &v31, &v35) || !v35 )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "Invalid private key; expect embedded public key");
    goto LABEL_79;
  }
  if ( (unsigned int)_libssh2_get_string(&v45, &v31, &v35) || !v35 )
  {
    v22 = _libssh2_error(a1, 4294967282LL, "Private key data not found");
    goto LABEL_79;
  }
  v49 = v31;
  v48 = v31;
  n = v35;
  if ( v28 )
  {
    v5 = v28;
    if ( strcmp(v28, "none") )
    {
      v42 = (const char ***)libssh2_crypt_methods(v5, "none");
      while ( 1 )
      {
        v7 = v42;
        ++v42;
        v43 = *v7;
        if ( !v43 )
          break;
        if ( **v43 )
        {
          v6 = strlen(*v43);
          if ( !memcmp(v28, *v43, v6) )
            v38 = v43;
        }
      }
      if ( !v38 )
      {
        v22 = _libssh2_error(v16, 4294967282LL, "No supported cipher found");
        goto LABEL_79;
      }
    }
  }
  if ( v38 )
  {
    v20 = 0;
    v21 = 0;
    v26 = 0;
    v37 = 0LL;
    v23 = *((_DWORD *)v38 + 6);
    v24 = *((_DWORD *)v38 + 5);
    v25 = v23 + v24;
    src = (void *)_libssh2_calloc(v16, v23 + v24);
    if ( !src )
    {
      v22 = _libssh2_error(v16, 4294967282LL, "Could not alloc key");
      goto LABEL_79;
    }
    if ( strcmp(v29, "bcrypt") || !a2 )
    {
      v22 = _libssh2_error(v16, 4294967248LL, "bcrypted without passphrase");
      (*(void ( **)(void *, __int64))(v16 + 24))(src, v16);
      goto LABEL_79;
    }
    if ( (unsigned int)_libssh2_get_string(&v51, &v32, &v36) || (unsigned int)_libssh2_get_u32(&v51, &v18) )
    {
      v22 = _libssh2_error(v16, 4294967282LL, "kdf contains unexpected values");
      (*(void ( **)(void *, __int64))(v16 + 24))(src, v16);
      goto LABEL_79;
    }
    v8 = v18;
    v9 = v23 + v24;
    v10 = v36;
    v11 = v32;
    v12 = strlen(a2);
    if ( (signed int)_libssh2_bcrypt_pbkdf(a2, v12, v11, v10, src, v9, v8) < 0 )
    {
      v22 = _libssh2_error(v16, 4294967284LL, "invalid format");
      (*(void ( **)(void *, __int64))(v16 + 24))(src, v16);
      goto LABEL_79;
    }
    v27 = *((_DWORD *)v38 + 4);
    dest = (void *)_libssh2_calloc(v16, v23);
    if ( !dest )
    {
      v22 = _libssh2_error(v16, 4294967282LL, "Could not alloc key part");
      goto LABEL_79;
    }
    v41 = (void *)_libssh2_calloc(v16, v24);
    if ( !v41 )
    {
      v22 = _libssh2_error(v16, 4294967282LL, "Could not alloc iv part");
      goto LABEL_79;
    }
    memcpy(dest, src, v23);
    memcpy(v41, (char *)src + v23, v24);
    if ( ((unsigned int ( *)(__int64, const char **, void *, int *, void *, int *, _QWORD, __int64 *))v38[5])(
           v16,
           v38,
           v41,
           &v20,
           dest,
           &v21,
           0LL,
           &v37) )
    {
      v22 = -12;
      goto LABEL_79;
    }
    if ( n % v27 )
    {
      ((void ( *)(__int64, __int64 *))v38[7])(v16, &v37);
      v22 = -12;
      goto LABEL_79;
    }
    while ( v26 <= n - v27 )
    {
      if ( ((unsigned int ( *)(__int64, char *, _QWORD, __int64 *))v38[6])(v16, (char *)v48 + v26, v27, &v37) )
      {
        v22 = -12;
        ((void ( *)(__int64, __int64 *))v38[7])(v16, &v37);
        goto LABEL_79;
      }
      v26 += v27;
    }
    ((void ( *)(__int64, __int64 *))v38[7])(v16, &v37);
  }
  if ( (unsigned int)_libssh2_get_u32(&v48, &v21) || (unsigned int)_libssh2_get_u32(&v48, &v37) || v21 != (_DWORD)v37 )
  {
    _libssh2_error(v16, 4294967282LL, "Private key unpack failed (correct password?)");
    v22 = -48;
  }
  else if ( v15 )
  {
    v44 = _libssh2_string_buf_new(v16, &v37);
    if ( v44 )
    {
      v13 = _libssh2_calloc(v16, n);
      *(_QWORD *)v44 = v13;
      if ( *(_QWORD *)v44 )
      {
        memcpy(*(void **)v44, v48, n);
        *(_QWORD *)(v44 + 8) = *(_QWORD *)v44 + v49 - (_BYTE *)v48;
        *(_QWORD *)(v44 + 16) = n;
        *v15 = v44;
      }
      else
      {
        v22 = _libssh2_error(v16, 4294967290LL, "Unable to allocate memory for decrypted struct");
        _libssh2_string_buf_free(v16, v44);
      }
    }
    else
    {
      v22 = _libssh2_error(v16, 4294967290LL, "Unable to allocate memory for decrypted struct");
    }
  }
LABEL_79:
  if ( src )
  {
    _libssh2_explicit_zero(src, v25);
    (*(void ( **)(void *, __int64))(v16 + 24))(src, v16);
  }
  if ( dest )
  {
    _libssh2_explicit_zero(dest, v23);
    (*(void ( **)(void *, __int64))(v16 + 24))(dest, v16);
  }
  if ( v41 )
  {
    _libssh2_explicit_zero(v41, v24);
    (*(void ( **)(void *, __int64))(v16 + 24))(v41, v16);
  }
  if ( v33 )
  {
    _libssh2_explicit_zero(v33, v19);
    (*(void ( **)(char *, __int64))(v16 + 24))(v33, v16);
  }
  return v22;
}
// 89D0: using guessed type __int64  _libssh2_string_buf_free(_QWORD, _QWORD);
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8CE0: using guessed type __int64  _libssh2_bcrypt_pbkdf(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 9070: using guessed type __int64  _libssh2_string_buf_new(_QWORD, _QWORD);
// 9250: using guessed type __int64  libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 9510: using guessed type __int64  libssh2_crypt_methods(_QWORD, _QWORD);

//----- (000000000002E84D) ----------------------------------------------------
signed __int64  libssh2_openssh_pem_parse(__int64 a1, const char *a2, FILE *a3, _QWORD *a4)
{
  __int64 v5; // rax
  _QWORD *v6; // [rsp+0h] [rbp-D0h]
  FILE *v7; // [rsp+8h] [rbp-C8h]
  unsigned int v8; // [rsp+20h] [rbp-B0h]
  unsigned int v9; // [rsp+24h] [rbp-ACh]
  __int64 v10; // [rsp+28h] [rbp-A8h]
  size_t n; // [rsp+30h] [rbp-A0h]
  __int64 v12; // [rsp+38h] [rbp-98h]
  char s1; // [rsp+40h] [rbp-90h]
  unsigned __int64 v14; // [rsp+C8h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v14 = __readfsqword(0x28u);
  v10 = 0LL;
  v8 = 0;
  do
  {
    s1 = 0;
    if ( (unsigned int)sub_2CC1E(&s1, 128, v7) )
      return 0xFFFFFFFFLL;
  }
  while ( strcmp(&s1, "-----BEGIN OPENSSH PRIVATE KEY-----") );
  if ( (unsigned int)sub_2CC1E(&s1, 128, v7) )
    return 0xFFFFFFFFLL;
  do
  {
    if ( s1 )
    {
      n = strlen(&s1);
      if ( v10 )
        v5 = (*(__int64 ( **)(__int64, size_t, __int64))(a1 + 16))(v10, n + v8, a1);
      else
        v5 = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(v8 + n, a1);
      v12 = v5;
      if ( !v5 )
        return (unsigned int)-1;
      memcpy((void *)(v8 + v5), &s1, n);
      v10 = v12;
      v8 += n;
    }
    s1 = 0;
    if ( (unsigned int)sub_2CC1E(&s1, 128, v7) )
      return (unsigned int)-1;
  }
  while ( strcmp(&s1, "-----END OPENSSH PRIVATE KEY-----") );
  if ( !v10 )
    return 0xFFFFFFFFLL;
  v9 = sub_2DAA2(a1, a2, v10, v8, v6);
  if ( v10 )
  {
    _libssh2_explicit_zero(v10, v8);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v10, a1);
  }
  return v9;
}
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);

//----- (000000000002EAFC) ----------------------------------------------------
signed __int64  libssh2_openssh_pem_parse_memory(__int64 a1, const char *a2, __int64 a3, unsigned __int64 a4, _QWORD *a5)
{
  __int64 v6; // rax
  _QWORD *v7; // [rsp+8h] [rbp-E8h]
  unsigned __int64 v8; // [rsp+10h] [rbp-E0h]
  __int64 v9; // [rsp+18h] [rbp-D8h]
  unsigned int v10; // [rsp+38h] [rbp-B8h]
  unsigned int v11; // [rsp+3Ch] [rbp-B4h]
  unsigned __int64 v12; // [rsp+40h] [rbp-B0h]
  __int64 v13; // [rsp+48h] [rbp-A8h]
  size_t n; // [rsp+50h] [rbp-A0h]
  __int64 v15; // [rsp+58h] [rbp-98h]
  char s1; // [rsp+60h] [rbp-90h]
  unsigned __int64 v17; // [rsp+E8h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v17 = __readfsqword(0x28u);
  v13 = 0LL;
  v10 = 0;
  v12 = 0LL;
  if ( !a3 || !a4 )
    return 0xFFFFFFFFLL;
  do
  {
    s1 = 0;
    if ( v8 <= v12 )
      return 0xFFFFFFFFLL;
    if ( (unsigned int)sub_2CD01(&s1, 128LL, v9, v8, &v12) )
      return 0xFFFFFFFFLL;
  }
  while ( strcmp(&s1, "-----BEGIN OPENSSH PRIVATE KEY-----") );
  s1 = 0;
  do
  {
    if ( s1 )
    {
      n = strlen(&s1);
      if ( v13 )
        v6 = (*(__int64 ( **)(__int64, size_t, __int64))(a1 + 16))(v13, n + v10, a1);
      else
        v6 = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(v10 + n, a1);
      v15 = v6;
      if ( !v6 )
      {
        v11 = -1;
        goto LABEL_25;
      }
      memcpy((void *)(v10 + v15), &s1, n);
      v13 = v15;
      v10 += n;
    }
    s1 = 0;
    if ( v8 <= v12 )
    {
      v11 = -1;
      goto LABEL_25;
    }
    if ( (unsigned int)sub_2CD01(&s1, 128LL, v9, v8, &v12) )
    {
      v11 = -1;
      goto LABEL_25;
    }
  }
  while ( strcmp(&s1, "-----END OPENSSH PRIVATE KEY-----") );
  if ( !v13 )
    return 0xFFFFFFFFLL;
  v11 = sub_2DAA2(a1, a2, v13, v10, v7);
LABEL_25:
  if ( v13 )
  {
    _libssh2_explicit_zero(v13, v10);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v13, a1);
  }
  return v11;
}
// 8AF0: using guessed type __int64  _libssh2_explicit_zero(_QWORD, _QWORD);

//----- (000000000002EE04) ----------------------------------------------------
signed __int64  sub_2EE04(unsigned __int8 *a1, unsigned int a2, _DWORD *a3)
{
  signed __int64 result; // rax
  unsigned int v4; // [rsp+20h] [rbp-8h]

  if ( !a2 )
    return 0xFFFFFFFFLL;
  *a3 = *a1;
  if ( *a3 <= 0x7Fu )
  {
    v4 = 0;
  }
  else
  {
    v4 = *a3 & 0x7F;
    *a3 = a1[1];
    if ( a2 < v4 + 1 )
      return 0xFFFFFFFFLL;
    if ( v4 > 1 )
    {
      *a3 <<= 8;
      *a3 |= a1[2];
    }
  }
  if ( v4 <= 2 && a2 >= *a3 + v4 + 1 )
    result = v4 + 1;
  else
    result = 0xFFFFFFFFLL;
  return result;
}

//----- (000000000002EEDA) ----------------------------------------------------
signed __int64  libssh2_pem_decode_sequence(_BYTE **a1, _DWORD *a2)
{
  int v3; // [rsp+10h] [rbp-10h]
  int v4; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  if ( !*a2 )
    return 0xFFFFFFFFLL;
  if ( **a1 != 48 )
    return 0xFFFFFFFFLL;
  v4 = sub_2EE04(++*a1, --*a2, &v3);
  if ( v4 < 0 || v3 + v4 != *a2 )
    return 0xFFFFFFFFLL;
  *a1 += v4;
  *a2 -= v4;
  return 0LL;
}

//----- (000000000002EFC5) ----------------------------------------------------
signed __int64  libssh2_pem_decode_integer(_BYTE **a1, _DWORD *a2, _QWORD *a3, unsigned int *a4)
{
  unsigned int *v5; // [rsp+0h] [rbp-30h]
  _QWORD *v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+20h] [rbp-10h]
  int v8; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v9; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v9 = __readfsqword(0x28u);
  if ( !*a2 )
    return 0xFFFFFFFFLL;
  if ( **a1 != 2 )
    return 0xFFFFFFFFLL;
  v8 = sub_2EE04(++*a1, --*a2, &v7);
  if ( v8 < 0 || v7 + v8 > *a2 )
    return 0xFFFFFFFFLL;
  *a1 += v8;
  *a2 -= v8;
  *v6 = *a1;
  *v5 = v7;
  *a1 += v7;
  *a2 -= v7;
  return 0LL;
}

//----- (000000000002F0F6) ----------------------------------------------------
__int64  sub_2F0F6(__int64 a1, __int64 a2, signed int a3)
{
  __int64 result; // rax
  signed int v4; // [rsp+Ch] [rbp-24h]

  v4 = a3;
  if ( a3 == 6 && a1 && *(_DWORD *)(a1 + 8) == 1 )
    v4 = 7;
  if ( v4 >= 0 && v4 <= 8 )
    result = _libssh2_error(a2, 4294967260LL, off_24F868[3 * v4]);
  else
    result = _libssh2_error(a2, 4294967260LL, "unknown");
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (000000000002F17F) ----------------------------------------------------
__int64  sub_2F17F(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+8h] [rbp-48h]
  int v5; // [rsp+2Ch] [rbp-24h]
  int v6; // [rsp+2Ch] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  __int64 v8; // [rsp+38h] [rbp-18h]
  char v9; // [rsp+44h] [rbp-Ch]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v4 = a3;
  v10 = __readfsqword(0x28u);
  v7 = *a1;
  v8 = *(_QWORD *)(*a1 + 96);
  *a2 = 0LL;
  *a3 = 0LL;
  if ( !*((_DWORD *)a1 + 3) )
  {
    v5 = _libssh2_channel_read(v7, 0LL, &v9, 4LL);
    if ( v5 == -37 )
      return 4294967259LL;
    if ( v5 != 4 )
      return _libssh2_error(v8, 4294967260LL, "Invalid response from publickey subsystem");
    a1[3] = (unsigned int)_libssh2_ntohu32(&v9);
    a1[2] = (*(__int64 ( **)(__int64, __int64))(v8 + 8))(a1[3], v8);
    if ( !a1[2] )
      return _libssh2_error(v8, 4294967290LL, "Unable to allocate publickey response buffer");
    *((_DWORD *)a1 + 3) = 3;
  }
  if ( *((_DWORD *)a1 + 3) == 3 )
  {
    v6 = _libssh2_channel_read(v7, 0LL, a1[2], a1[3]);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v6 != (unsigned int)a1[3] )
    {
      (*(void ( **)(__int64, __int64))(v8 + 24))(a1[2], v8);
      a1[2] = 0LL;
      *((_DWORD *)a1 + 3) = 0;
      return _libssh2_error(v8, 4294967266LL, "Timeout waiting for publickey subsystem response packet");
    }
    *a2 = a1[2];
    *v4 = a1[3];
  }
  *((_DWORD *)a1 + 3) = 0;
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 97F0: using guessed type __int64  _libssh2_channel_read(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002F37E) ----------------------------------------------------
signed __int64  sub_2F37E(char **a1, unsigned __int64 a2)
{
  const char **v3; // [rsp+18h] [rbp-18h]
  char *s2; // [rsp+20h] [rbp-10h]
  char *s2a; // [rsp+20h] [rbp-10h]
  unsigned __int64 n; // [rsp+28h] [rbp-8h]

  s2 = *a1;
  v3 = (const char **)&unk_24F800;
  if ( a2 <= 3 )
    return 0xFFFFFFFFLL;
  n = (unsigned int)_libssh2_ntohu32(s2);
  s2a = s2 + 4;
  if ( a2 - 4 < n )
    return 0xFFFFFFFFLL;
  while ( v3[1] )
  {
    if ( n == *((_DWORD *)v3 + 4) && !strncmp(v3[1], s2a, n) )
    {
      *a1 = &s2a[n];
      return *(unsigned int *)v3;
    }
    v3 += 3;
  }
  return 0xFFFFFFFFLL;
}
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);

//----- (000000000002F443) ----------------------------------------------------
__int64  sub_2F443(__int64 *a1)
{
  int v2; // [rsp+18h] [rbp-38h]
  int v3; // [rsp+1Ch] [rbp-34h]
  __int64 v4; // [rsp+20h] [rbp-30h]
  __int64 v5; // [rsp+28h] [rbp-28h]
  unsigned __int64 v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v7 = *(_QWORD *)(*a1 + 96);
  while ( 1 )
  {
    v2 = sub_2F17F(a1, &v4, &v6);
    if ( v2 == -37 )
      return 4294967259LL;
    if ( v2 )
      return _libssh2_error(v7, 4294967266LL, "Timeout waiting for response from publickey subsystem");
    if ( v6 <= 3 )
      return _libssh2_error(v7, 4294967258LL, "Publickey response too small");
    v5 = v4;
    v3 = sub_2F37E((char **)&v5, v6);
    if ( !v3 )
      break;
    (*(void ( **)(__int64, __int64))(v7 + 24))(v4, v7);
    if ( v3 < 0 )
      return _libssh2_error(v7, 4294967260LL, "Invalid publickey subsystem response");
    _libssh2_error(v7, 4294967260LL, "Unexpected publickey subsystem response");
    v4 = 0LL;
  }
  v8 = 0LL;
  if ( v6 <= 7 )
    return _libssh2_error(v7, 4294967258LL, "Publickey response too small");
  v8 = (unsigned int)_libssh2_ntohu32(v5);
  (*(void ( **)(__int64, __int64))(v7 + 24))(v4, v7);
  if ( !v8 )
    return 0LL;
  sub_2F0F6((__int64)a1, v7, v8);
  return 0xFFFFFFFFLL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);

//----- (000000000002F602) ----------------------------------------------------
__int64  sub_2F602(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // eax
  __int64 v3; // rbx
  int v4; // [rsp+18h] [rbp-48h]
  unsigned int v5; // [rsp+18h] [rbp-48h]
  int v6; // [rsp+18h] [rbp-48h]
  int v7; // [rsp+1Ch] [rbp-44h]
  unsigned __int64 v8; // [rsp+20h] [rbp-40h]
  void *dest; // [rsp+28h] [rbp-38h]
  __int64 v10; // [rsp+30h] [rbp-30h]
  __int64 v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  unsigned __int64 v13; // [rsp+48h] [rbp-18h]

  v13 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53864) )
  {
    *(_QWORD *)(a1 + 53888) = 0LL;
    *(_QWORD *)(a1 + 53872) = 0LL;
    *(_QWORD *)(a1 + 53880) = 0LL;
    *(_DWORD *)(a1 + 53864) = 1;
  }
  if ( *(_DWORD *)(a1 + 53864) == 1 )
  {
    *(_QWORD *)(a1 + 53880) = _libssh2_channel_open(a1, "session", 7LL, 0x200000LL, 0x8000LL, 0LL, 0LL);
    if ( !*(_QWORD *)(a1 + 53880) )
    {
      if ( (unsigned int)libssh2_session_last_errno(a1) == -37 )
        return 0LL;
      _libssh2_error(a1, 4294967275LL, "Unable to startup channel");
      goto LABEL_55;
    }
    *(_DWORD *)(a1 + 53864) = 3;
  }
  if ( *(_DWORD *)(a1 + 53864) == 3 )
  {
    v4 = _libssh2_channel_process_startup(*(_QWORD *)(a1 + 53880), "subsystem", 9LL, "publickey", 9LL);
    if ( v4 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block starting publickey subsystem");
      return 0LL;
    }
    if ( v4 )
    {
      _libssh2_error(a1, 4294967275LL, "Unable to request publickey subsystem");
LABEL_55:
      *(_DWORD *)(a1 + 53864) = 7;
      if ( *(_QWORD *)(a1 + 53880) && (unsigned int)_libssh2_channel_close(*(_QWORD *)(a1 + 53880)) == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block closing channel");
        result = 0LL;
      }
      else
      {
        if ( *(_QWORD *)(a1 + 53872) )
        {
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53872), a1);
          *(_QWORD *)(a1 + 53872) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 53888) )
        {
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53888), a1);
          *(_QWORD *)(a1 + 53888) = 0LL;
        }
        *(_DWORD *)(a1 + 53864) = 0;
        result = 0LL;
      }
      return result;
    }
    *(_DWORD *)(a1 + 53864) = 4;
  }
  if ( *(_DWORD *)(a1 + 53864) == 4 )
  {
    if ( (unsigned int)_libssh2_channel_extended_data(*(_QWORD *)(a1 + 53880), 1LL) == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block starting publickey subsystem");
      return 0LL;
    }
    *(_QWORD *)(a1 + 53872) = _libssh2_calloc(a1, 128LL);
    if ( !*(_QWORD *)(a1 + 53872) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate a new publickey structure");
      goto LABEL_55;
    }
    **(_QWORD **)(a1 + 53872) = *(_QWORD *)(a1 + 53880);
    *(_DWORD *)(*(_QWORD *)(a1 + 53872) + 8LL) = 0;
    _libssh2_htonu32(a1 + 53904, 15LL);
    _libssh2_htonu32(a1 + 53908, 7LL);
    memcpy((void *)(a1 + 53912), "version", 7uLL);
    dest = (void *)(a1 + 53919);
    _libssh2_htonu32(a1 + 53919, 2LL);
    *(_QWORD *)(a1 + 53928) = 0LL;
    *(_DWORD *)(a1 + 53864) = 5;
  }
  if ( *(_DWORD *)(a1 + 53864) == 5 )
  {
    v5 = _libssh2_channel_write(*(_QWORD *)(a1 + 53880), 0LL, a1 + 53904, 19LL - *(_QWORD *)(a1 + 53928));
    if ( v5 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block sending publickey version packet");
      return 0LL;
    }
    if ( (v5 & 0x80000000) != 0 )
    {
      _libssh2_error(a1, v5, "Unable to send publickey version packet");
      goto LABEL_55;
    }
    *(_QWORD *)(a1 + 53928) += (signed int)v5;
    if ( *(_QWORD *)(a1 + 53928) <= 0x12uLL )
    {
      _libssh2_error(a1, 4294967259LL, "Need to be called again to complete this");
      return 0LL;
    }
    *(_DWORD *)(a1 + 53864) = 6;
  }
  if ( *(_DWORD *)(a1 + 53864) != 6 )
    goto LABEL_55;
  while ( 1 )
  {
    v6 = sub_2F17F(*(__int64 **)(a1 + 53872), (_QWORD *)(a1 + 53888), (_QWORD *)(a1 + 53896));
    if ( v6 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block waiting for response from publickey subsystem");
      return 0LL;
    }
    if ( v6 )
    {
      _libssh2_error(a1, 4294967266LL, "Timeout waiting for response from publickey subsystem");
      goto LABEL_55;
    }
    v8 = *(_QWORD *)(a1 + 53888);
    v7 = sub_2F37E((char **)&v8, *(_QWORD *)(a1 + 53896));
    if ( v7 < 0 )
    {
      _libssh2_error(a1, 4294967260LL, "Invalid publickey subsystem response code");
      goto LABEL_55;
    }
    if ( *(_QWORD *)(a1 + 53896) <= 3uLL )
    {
      _libssh2_error(a1, 4294967258LL, "Public key init data too small");
      goto LABEL_55;
    }
    if ( !v7 )
    {
      if ( *(_QWORD *)(a1 + 53896) <= 7uLL )
      {
        _libssh2_error(a1, 4294967258LL, "Public key init data too small");
      }
      else
      {
        v10 = (unsigned int)_libssh2_ntohu32(v8);
        v8 += 4LL;
        v11 = (unsigned int)_libssh2_ntohu32(v8);
        v8 += 4LL;
        if ( v8 + v11 + 4 > *(_QWORD *)(a1 + 53888) + *(_QWORD *)(a1 + 53896) )
        {
          _libssh2_error(a1, 4294967258LL, "Public key init data too small");
        }
        else
        {
          v8 += v11;
          v2 = _libssh2_ntohu32(v8);
          v12 = v2;
          v8 += 4LL;
          if ( v8 + v2 > *(_QWORD *)(a1 + 53888) + *(_QWORD *)(a1 + 53896) )
          {
            _libssh2_error(a1, 4294967258LL, "Public key init data too small");
          }
          else
          {
            v8 += v12;
            if ( *(_QWORD *)(a1 + 53896) + *(_QWORD *)(a1 + 53888) >= v8 )
              sub_2F0F6(0LL, a1, v10);
            else
              _libssh2_error(a1, 4294967260LL, "Malformed publickey subsystem packet");
          }
        }
      }
      goto LABEL_55;
    }
    if ( v7 == 1 )
      break;
    _libssh2_error(a1, 4294967260LL, "Unexpected publickey subsystem response, ignoring");
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53888), a1);
    *(_QWORD *)(a1 + 53888) = 0LL;
  }
  v3 = *(_QWORD *)(a1 + 53872);
  *(_DWORD *)(v3 + 8) = _libssh2_ntohu32(v8);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 53872) + 8LL) > 2u )
    *(_DWORD *)(*(_QWORD *)(a1 + 53872) + 8LL) = 2;
  (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53888), a1);
  *(_QWORD *)(a1 + 53888) = 0LL;
  *(_DWORD *)(a1 + 53864) = 0;
  return *(_QWORD *)(a1 + 53872);
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9460: using guessed type __int64  _libssh2_channel_process_startup(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 94E0: using guessed type __int64  _libssh2_channel_extended_data(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9950: using guessed type __int64  _libssh2_channel_close(_QWORD);
// 9A60: using guessed type __int64  _libssh2_channel_open(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002FE8B) ----------------------------------------------------
__int64  libssh2_publickey_init(__int64 a1)
{
  time_t v2; // [rsp+20h] [rbp-10h]
  __int64 v3; // [rsp+28h] [rbp-8h]

  v2 = time(0LL);
  do
    v3 = sub_2F602(a1);
  while ( *(_DWORD *)(a1 + 148)
       && !v3
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v2) );
  return v3;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000002FEFD) ----------------------------------------------------
__int64  libssh2_publickey_add_ex(__int64 *a1, const void *a2, size_t a3, void *a4, size_t a5, char a6, unsigned __int64 a7, __int64 a8)
{
  bool *v9; // rax
  bool v10; // si
  bool *v11; // rax
  char v12; // [rsp+4h] [rbp-6Ch]
  size_t v13; // [rsp+8h] [rbp-68h]
  void *v14; // [rsp+10h] [rbp-60h]
  size_t v15; // [rsp+18h] [rbp-58h]
  int v16; // [rsp+3Ch] [rbp-34h]
  unsigned int v17; // [rsp+3Ch] [rbp-34h]
  unsigned __int64 i; // [rsp+40h] [rbp-30h]
  unsigned __int64 j; // [rsp+40h] [rbp-30h]
  unsigned __int64 k; // [rsp+40h] [rbp-30h]
  signed __int64 v21; // [rsp+48h] [rbp-28h]
  signed __int64 v22; // [rsp+48h] [rbp-28h]
  void *src; // [rsp+50h] [rbp-20h]
  size_t n; // [rsp+58h] [rbp-18h]
  __int64 v25; // [rsp+60h] [rbp-10h]
  __int64 v26; // [rsp+68h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v21 = a3 + a5 + 19;
  src = 0LL;
  n = 0LL;
  if ( !a1 )
    return 4294967257LL;
  v25 = *a1;
  v26 = *(_QWORD *)(*a1 + 96);
  if ( !*((_DWORD *)a1 + 8) )
  {
    a1[5] = 0LL;
    if ( *((_DWORD *)a1 + 2) == 1 )
    {
      for ( i = 0LL; i < a7; ++i )
      {
        if ( *(_QWORD *)(40 * i + a8 + 8) == 7LL && !strncmp(*(const char **)(40 * i + a8), "comment", 7uLL) )
        {
          src = *(void **)(40 * i + a8 + 16);
          n = *(_QWORD *)(40 * i + a8 + 24);
          break;
        }
      }
      v22 = n + v21 + 4;
    }
    else
    {
      v22 = a3 + a5 + 24;
      for ( j = 0LL; j < a7; ++j )
        v22 += *(_QWORD *)(40 * j + a8 + 8) + *(_QWORD *)(40 * j + a8 + 24) + 9LL;
    }
    a1[5] = (*(__int64 ( **)(signed __int64, __int64))(v26 + 8))(v22, v26);
    if ( !a1[5] )
      return _libssh2_error(v26, 4294967290LL, "Unable to allocate memory for publickey \"add\" packet");
    a1[6] = a1[5];
    _libssh2_htonu32(a1[6], (unsigned int)(v22 - 4));
    a1[6] += 4LL;
    _libssh2_htonu32(a1[6], 3LL);
    a1[6] += 4LL;
    memcpy((void *)a1[6], "add", 3uLL);
    a1[6] += 3LL;
    if ( *((_DWORD *)a1 + 2) == 1 )
    {
      _libssh2_htonu32(a1[6], (unsigned int)n);
      a1[6] += 4LL;
      if ( src )
      {
        memcpy((void *)a1[6], src, n);
        a1[6] += n;
      }
      _libssh2_htonu32(a1[6], (unsigned int)v15);
      a1[6] += 4LL;
      memcpy((void *)a1[6], a2, v15);
      a1[6] += v15;
      _libssh2_htonu32(a1[6], (unsigned int)v13);
      a1[6] += 4LL;
      memcpy((void *)a1[6], v14, v13);
      a1[6] += v13;
    }
    else
    {
      _libssh2_htonu32(a1[6], (unsigned int)v15);
      a1[6] += 4LL;
      memcpy((void *)a1[6], a2, v15);
      a1[6] += v15;
      _libssh2_htonu32(a1[6], (unsigned int)v13);
      a1[6] += 4LL;
      memcpy((void *)a1[6], v14, v13);
      a1[6] += v13;
      v9 = (bool *)a1[6];
      a1[6] = (__int64)(v9 + 1);
      *v9 = v12 != 0;
      _libssh2_htonu32(a1[6], (unsigned int)a7);
      a1[6] += 4LL;
      for ( k = 0LL; k < a7; ++k )
      {
        _libssh2_htonu32(a1[6], (unsigned int)*(_QWORD *)(40 * k + a8 + 8));
        a1[6] += 4LL;
        memcpy((void *)a1[6], *(const void **)(40 * k + a8), *(_QWORD *)(40 * k + a8 + 8));
        a1[6] += *(_QWORD *)(40 * k + a8 + 8);
        _libssh2_htonu32(a1[6], (unsigned int)*(_QWORD *)(40 * k + a8 + 24));
        a1[6] += 4LL;
        memcpy((void *)a1[6], *(const void **)(40 * k + a8 + 16), *(_QWORD *)(40 * k + a8 + 24));
        a1[6] += *(_QWORD *)(40 * k + a8 + 24);
        v10 = *(_BYTE *)(40 * k + a8 + 32) != 0;
        v11 = (bool *)a1[6];
        a1[6] = (__int64)(v11 + 1);
        *v11 = v10;
      }
    }
    *((_DWORD *)a1 + 8) = 2;
  }
  if ( *((_DWORD *)a1 + 8) == 2 )
  {
    v16 = _libssh2_channel_write(v25, 0LL, a1[5], a1[6] - a1[5]);
    if ( v16 == -37 )
      return 4294967259LL;
    if ( a1[6] - a1[5] != v16 )
    {
      (*(void ( **)(__int64, __int64))(v26 + 24))(a1[5], v26);
      a1[5] = 0LL;
      return _libssh2_error(v26, 4294967289LL, "Unable to send publickey add packet");
    }
    (*(void ( **)(__int64, __int64))(v26 + 24))(a1[5], v26);
    a1[5] = 0LL;
    *((_DWORD *)a1 + 8) = 3;
  }
  v17 = sub_2F443(a1);
  if ( v17 != -37 )
    *((_DWORD *)a1 + 8) = 0;
  return v17;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (0000000000030728) ----------------------------------------------------
__int64  libssh2_publickey_remove_ex(__int64 *a1, const void *a2, size_t a3, void *a4, size_t a5)
{
  size_t v6; // [rsp+8h] [rbp-48h]
  void *v7; // [rsp+10h] [rbp-40h]
  size_t n; // [rsp+18h] [rbp-38h]
  int v9; // [rsp+34h] [rbp-1Ch]
  unsigned int v10; // [rsp+34h] [rbp-1Ch]
  signed __int64 v11; // [rsp+38h] [rbp-18h]
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  n = a3;
  v7 = a4;
  v6 = a5;
  v11 = a3 + a5 + 22;
  if ( !a1 )
    return 4294967257LL;
  v12 = *a1;
  v13 = *(_QWORD *)(*a1 + 96);
  if ( !*((_DWORD *)a1 + 14) )
  {
    a1[8] = 0LL;
    a1[8] = (*(__int64 ( **)(signed __int64, __int64))(v13 + 8))(v11, v13);
    if ( !a1[8] )
      return _libssh2_error(v13, 4294967290LL, "Unable to allocate memory for publickey \"remove\" packet");
    a1[9] = a1[8];
    _libssh2_htonu32(a1[9], (unsigned int)(v11 - 4));
    a1[9] += 4LL;
    _libssh2_htonu32(a1[9], 6LL);
    a1[9] += 4LL;
    memcpy((void *)a1[9], "remove", 6uLL);
    a1[9] += 6LL;
    _libssh2_htonu32(a1[9], (unsigned int)n);
    a1[9] += 4LL;
    memcpy((void *)a1[9], a2, n);
    a1[9] += n;
    _libssh2_htonu32(a1[9], (unsigned int)v6);
    a1[9] += 4LL;
    memcpy((void *)a1[9], v7, v6);
    a1[9] += v6;
    *((_DWORD *)a1 + 14) = 2;
  }
  if ( *((_DWORD *)a1 + 14) == 2 )
  {
    v9 = _libssh2_channel_write(v12, 0LL, a1[8], a1[9] - a1[8]);
    if ( v9 == -37 )
      return 4294967259LL;
    if ( a1[9] - a1[8] != v9 )
    {
      (*(void ( **)(__int64, __int64))(v13 + 24))(a1[8], v13);
      a1[8] = 0LL;
      *((_DWORD *)a1 + 14) = 0;
      return _libssh2_error(v13, 4294967289LL, "Unable to send publickey remove packet");
    }
    (*(void ( **)(__int64, __int64))(v13 + 24))(a1[8], v13);
    a1[8] = 0LL;
    *((_DWORD *)a1 + 14) = 3;
  }
  v10 = sub_2F443(a1);
  if ( v10 != -37 )
    *((_DWORD *)a1 + 14) = 0;
  return v10;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (0000000000030A64) ----------------------------------------------------
__int64  libssh2_publickey_list_fetch(__int64 a1, unsigned __int64 *a2, __int64 *a3)
{
  __int64 result; // rax
  unsigned int v4; // eax
  __int64 v5; // rax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  __int64 *v10; // [rsp+8h] [rbp-98h]
  int v11; // [rsp+28h] [rbp-78h]
  int v12; // [rsp+28h] [rbp-78h]
  int v13; // [rsp+2Ch] [rbp-74h]
  __int64 v14; // [rsp+30h] [rbp-70h]
  unsigned __int64 v15; // [rsp+38h] [rbp-68h]
  unsigned __int64 v16; // [rsp+40h] [rbp-60h]
  unsigned __int64 i; // [rsp+48h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-48h]
  __int64 v19; // [rsp+60h] [rbp-40h]
  __int64 v20; // [rsp+70h] [rbp-30h]
  __int64 v21; // [rsp+78h] [rbp-28h]
  __int64 v22; // [rsp+80h] [rbp-20h]

  v10 = a3;
  v14 = 0LL;
  v15 = 0LL;
  v16 = 0LL;
  if ( !a1 )
    return 4294967257LL;
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !*(_DWORD *)(a1 + 80) )
  {
    *(_QWORD *)(a1 + 112) = 0LL;
    *(_QWORD *)(a1 + 88) = a1 + 96;
    _libssh2_htonu32(*(_QWORD *)(a1 + 88), 8LL);
    *(_QWORD *)(a1 + 88) += 4LL;
    _libssh2_htonu32(*(_QWORD *)(a1 + 88), 4LL);
    *(_QWORD *)(a1 + 88) += 4LL;
    memcpy(*(void **)(a1 + 88), "list", 4uLL);
    *(_QWORD *)(a1 + 88) += 4LL;
    *(_DWORD *)(a1 + 80) = 2;
  }
  if ( *(_DWORD *)(a1 + 80) == 2 )
  {
    v11 = _libssh2_channel_write(v18, 0LL, a1 + 96, *(_QWORD *)(a1 + 88) - (a1 + 96));
    if ( v11 == -37 )
    {
      result = 4294967259LL;
    }
    else
    {
      if ( *(_QWORD *)(a1 + 88) - (a1 + 96) == v11 )
      {
        *(_DWORD *)(a1 + 80) = 3;
        goto LABEL_11;
      }
      *(_DWORD *)(a1 + 80) = 0;
      result = _libssh2_error(v19, 4294967289LL, "Unable to send publickey list packet");
    }
  }
  else
  {
    while ( 1 )
    {
LABEL_11:
      v12 = sub_2F17F((__int64 *)a1, (_QWORD *)(a1 + 112), (_QWORD *)(a1 + 120));
      if ( v12 == -37 )
        return 4294967259LL;
      if ( v12 )
      {
        _libssh2_error(v19, 4294967266LL, "Timeout waiting for response from publickey subsystem");
        goto LABEL_95;
      }
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a1 + 112);
      v13 = sub_2F37E((char **)(a1 + 88), *(_QWORD *)(a1 + 120));
      if ( v13 < 0 )
      {
        _libssh2_error(v19, 4294967260LL, "Invalid publickey subsystem response code");
        goto LABEL_95;
      }
      if ( !v13 )
        break;
      if ( v13 == 2 )
      {
        if ( v15 >= v16 )
        {
          v16 += 8LL;
          if ( v14 )
            v5 = (*(__int64 ( **)(__int64, unsigned __int64, __int64))(v19 + 16))(v14, 56 * (v16 + 1), v19);
          else
            v5 = (*(__int64 ( **)(unsigned __int64, __int64))(v19 + 8))(56 * (v16 + 1), v19);
          if ( !v5 )
          {
            _libssh2_error(v19, 4294967290LL, "Unable to allocate memory for publickey list");
            goto LABEL_95;
          }
          v14 = v5;
        }
        if ( *(_DWORD *)(a1 + 8) == 1 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          v20 = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( v20 )
          {
            *(_QWORD *)(56 * v15 + v14 + 40) = 1LL;
            *(_QWORD *)(56 * v15 + v14 + 48) = (*(__int64 ( **)(signed __int64, __int64))(v19 + 8))(40LL, v19);
            if ( !*(_QWORD *)(56 * v15 + v14 + 48) )
            {
              _libssh2_error(v19, 4294967290LL, "Unable to allocate memory for publickey attributes");
              goto LABEL_95;
            }
            **(_QWORD **)(56 * v15 + v14 + 48) = "comment";
            *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 8LL) = 7LL;
            *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 16LL) = *(_QWORD *)(a1 + 88);
            *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 24LL) = v20;
            *(_BYTE *)(*(_QWORD *)(56 * v15 + v14 + 48) + 32LL) = 0;
            *(_QWORD *)(a1 + 88) += v20;
          }
          else
          {
            *(_QWORD *)(56 * v15 + v14 + 40) = 0LL;
            *(_QWORD *)(56 * v15 + v14 + 48) = 0LL;
          }
          if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          *(_QWORD *)(56 * v15 + v14 + 16) = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( *(_QWORD *)(56 * v15 + v14 + 16) + *(_QWORD *)(a1 + 88) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          *(_QWORD *)(v14 + 56 * v15 + 8) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v15 + v14 + 16);
          if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          v6 = _libssh2_ntohu32(*(_QWORD *)(a1 + 88));
          *(_QWORD *)(56 * v15 + v14 + 32) = v6;
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( *(_QWORD *)(56 * v15 + v14 + 32) + *(_QWORD *)(a1 + 88) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          *(_QWORD *)(v14 + 56 * v15 + 24) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v15 + v14 + 32);
        }
        else
        {
          if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          *(_QWORD *)(56 * v15 + v14 + 16) = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 88));
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( *(_QWORD *)(56 * v15 + v14 + 16) + *(_QWORD *)(a1 + 88) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          *(_QWORD *)(v14 + 56 * v15 + 8) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v15 + v14 + 16);
          if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          v7 = _libssh2_ntohu32(*(_QWORD *)(a1 + 88));
          *(_QWORD *)(56 * v15 + v14 + 32) = v7;
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( *(_QWORD *)(56 * v15 + v14 + 32) + *(_QWORD *)(a1 + 88) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          *(_QWORD *)(v14 + 56 * v15 + 24) = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 88) += *(_QWORD *)(56 * v15 + v14 + 32);
          if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
            goto LABEL_95;
          }
          v8 = _libssh2_ntohu32(*(_QWORD *)(a1 + 88));
          *(_QWORD *)(56 * v15 + v14 + 40) = v8;
          *(_QWORD *)(a1 + 88) += 4LL;
          if ( *(_QWORD *)(56 * v15 + v14 + 40) )
          {
            *(_QWORD *)(56 * v15 + v14 + 48) = (*(__int64 ( **)(signed __int64, __int64))(v19 + 8))(
                                                 40LL * *(_QWORD *)(56 * v15 + v14 + 40),
                                                 v19);
            if ( !*(_QWORD *)(56 * v15 + v14 + 48) )
            {
              _libssh2_error(v19, 4294967290LL, "Unable to allocate memory for publickey attributes");
              goto LABEL_95;
            }
            for ( i = 0LL; i < *(_QWORD *)(56 * v15 + v14 + 40); ++i )
            {
              if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
              {
                _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
                goto LABEL_95;
              }
              *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 8) = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 88));
              *(_QWORD *)(a1 + 88) += 4LL;
              if ( *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 8) + *(_QWORD *)(a1 + 88) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
              {
                _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
                goto LABEL_95;
              }
              *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i) = *(_QWORD *)(a1 + 88);
              *(_QWORD *)(a1 + 88) += *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 8);
              if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 4LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
              {
                _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
                goto LABEL_95;
              }
              v9 = _libssh2_ntohu32(*(_QWORD *)(a1 + 88));
              *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 24) = v9;
              *(_QWORD *)(a1 + 88) += 4LL;
              if ( *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 24) + *(_QWORD *)(a1 + 88) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
              {
                _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
                goto LABEL_95;
              }
              *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 16) = *(_QWORD *)(a1 + 88);
              *(_QWORD *)(a1 + 88) += *(_QWORD *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 24);
              *(_BYTE *)(*(_QWORD *)(56 * v15 + v14 + 48) + 40 * i + 32) = 0;
            }
          }
          else
          {
            *(_QWORD *)(56 * v15 + v14 + 48) = 0LL;
          }
        }
        *(_QWORD *)(v14 + 56 * v15++) = *(_QWORD *)(a1 + 112);
        *(_QWORD *)(56 * v15 + v14) = 0LL;
        *(_QWORD *)(a1 + 112) = 0LL;
      }
      else
      {
        _libssh2_error(v19, 4294967260LL, "Unexpected publickey subsystem response");
        (*(void ( **)(_QWORD, __int64))(v19 + 24))(*(_QWORD *)(a1 + 112), v19);
        *(_QWORD *)(a1 + 112) = 0LL;
      }
    }
    if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + 8LL) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
    {
      _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
    }
    else
    {
      v21 = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 88));
      *(_QWORD *)(a1 + 88) += 4LL;
      v22 = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 88));
      *(_QWORD *)(a1 + 88) += 4LL;
      if ( (unsigned __int64)(*(_QWORD *)(a1 + 88) + v22 + 4) > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
      {
        _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
      }
      else
      {
        *(_QWORD *)(a1 + 88) += v22;
        v4 = _libssh2_ntohu32(*(_QWORD *)(a1 + 88));
        *(_QWORD *)(a1 + 88) += 4LL;
        if ( *(_QWORD *)(a1 + 88) + (unsigned __int64)v4 > *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
        {
          _libssh2_error(v19, 4294967258LL, "ListFetch data too short");
        }
        else
        {
          *(_QWORD *)(a1 + 88) += v4;
          if ( *(_QWORD *)(a1 + 88) <= *(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 120) )
          {
            if ( !v21 )
            {
              (*(void ( **)(_QWORD, __int64))(v19 + 24))(*(_QWORD *)(a1 + 112), v19);
              *(_QWORD *)(a1 + 112) = 0LL;
              *v10 = v14;
              *a2 = v15;
              *(_DWORD *)(a1 + 80) = 0;
              return 0LL;
            }
            sub_2F0F6(a1, v19, v21);
          }
          else
          {
            _libssh2_error(v19, 4294967260LL, "Malformed publickey subsystem packet");
          }
        }
      }
    }
LABEL_95:
    if ( *(_QWORD *)(a1 + 112) )
    {
      (*(void ( **)(_QWORD, __int64))(v19 + 24))(*(_QWORD *)(a1 + 112), v19);
      *(_QWORD *)(a1 + 112) = 0LL;
    }
    if ( v14 )
      libssh2_publickey_list_free(a1, v14);
    *(_DWORD *)(a1 + 80) = 0;
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F60: using guessed type __int64  libssh2_publickey_list_free(_QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (0000000000031FAC) ----------------------------------------------------
__int64  libssh2_publickey_list_free(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  _QWORD *v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  result = (__int64)a2;
  v3 = a2;
  if ( a1 && a2 )
  {
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
    while ( *v3 )
    {
      if ( v3[6] )
        (*(void ( **)(_QWORD, __int64))(v4 + 24))(v3[6], v4);
      (*(void ( **)(_QWORD, __int64))(v4 + 24))(*v3, v4);
      v3 += 7;
    }
    result = (*(__int64 ( **)(_QWORD *, __int64))(v4 + 24))(a2, v4);
  }
  return result;
}

//----- (000000000003205D) ----------------------------------------------------
signed __int64  libssh2_publickey_shutdown(_QWORD *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v2 = *(_QWORD *)(*a1 + 96LL);
  if ( a1[2] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[2], v2);
    a1[2] = 0LL;
  }
  if ( a1[5] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[5], v2);
    a1[5] = 0LL;
  }
  if ( a1[8] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[8], v2);
    a1[8] = 0LL;
  }
  if ( a1[14] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[14], v2);
    a1[14] = 0LL;
  }
  if ( (unsigned int)_libssh2_channel_free(*a1) == -37 )
    return 4294967259LL;
  (*(void ( **)(_QWORD *, __int64))(v2 + 24))(a1, v2);
  return 0LL;
}
// 8CC0: using guessed type __int64  _libssh2_channel_free(_QWORD);

//----- (0000000000032199) ----------------------------------------------------
_BYTE * sub_32199(char *a1, _BYTE *a2, int a3)
{
  int v3; // eax
  _BYTE *v5; // rax
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  _BYTE *v11; // rax
  char *v12; // rax
  char v13; // cl
  _BYTE *v14; // rax
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  unsigned int v17; // [rsp+18h] [rbp-1Ch]
  char *v18; // [rsp+1Ch] [rbp-18h]
  _BYTE *v19; // [rsp+24h] [rbp-10h]
  unsigned __int64 v20; // [rsp+2Ch] [rbp-8h]

  v17 = 0;
  v20 = (unsigned __int64)&a2[a3];
  v18 = a1;
  v19 = a2;
  while ( *v18 && (unsigned __int64)v19 < v20 - 1 )
  {
    v3 = *v18;
    if ( v3 == 33 )
    {
      if ( v17 == 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 2) )
          return 0LL;
        *v19 = 39;
        v9 = v19 + 1;
        v19 += 2;
        *v9 = 92;
      }
      else if ( v17 < 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 1) )
          return 0LL;
        v7 = v19++;
        *v7 = 92;
      }
      else if ( v17 == 2 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 2) )
          return 0LL;
        *v19 = 34;
        v8 = v19 + 1;
        v19 += 2;
        *v8 = 92;
      }
      v17 = 0;
    }
    else if ( v3 == 39 )
    {
      if ( v17 == 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 2) )
          return 0LL;
        *v19 = 39;
        v6 = v19 + 1;
        v19 += 2;
        *v6 = 34;
      }
      else if ( v17 < 1 )
      {
        if ( v20 <= (unsigned __int64)(v19 + 1) )
          return 0LL;
        v5 = v19++;
        *v5 = 34;
      }
      v17 = 2;
    }
    else
    {
      if ( v17 != 1 )
      {
        if ( v17 < 1 )
        {
          if ( v20 <= (unsigned __int64)(v19 + 1) )
            return 0LL;
          v10 = v19++;
          *v10 = 39;
        }
        else if ( v17 == 2 )
        {
          if ( v20 <= (unsigned __int64)(v19 + 2) )
            return 0LL;
          *v19 = 34;
          v11 = v19 + 1;
          v19 += 2;
          *v11 = 39;
        }
      }
      v17 = 1;
    }
    if ( v20 <= (unsigned __int64)(v19 + 1) )
      return 0LL;
    v12 = v18++;
    v13 = *v12;
    v14 = v19++;
    *v14 = v13;
  }
  if ( v17 == 1 )
  {
    if ( v20 <= (unsigned __int64)(v19 + 1) )
      return 0LL;
    v16 = v19++;
    *v16 = 39;
  }
  else if ( v17 >= 1 && v17 == 2 )
  {
    if ( v20 <= (unsigned __int64)(v19 + 1) )
      return 0LL;
    v15 = v19++;
    *v15 = 34;
  }
  if ( v20 <= (unsigned __int64)(v19 + 1) )
    return 0LL;
  *v19 = 0;
  return (_BYTE *)(v19 - a2);
}

//----- (0000000000032487) ----------------------------------------------------
__int64  sub_32487(__int64 a1, char *a2, void *a3)
{
  const char *v4; // rax
  int v5; // eax
  char *v6; // rax
  char *v7; // rax
  void *v8; // [rsp+8h] [rbp-78h]
  int v9; // [rsp+30h] [rbp-50h]
  int v10; // [rsp+30h] [rbp-50h]
  unsigned int v11; // [rsp+30h] [rbp-50h]
  int v12; // [rsp+30h] [rbp-50h]
  unsigned int v13; // [rsp+30h] [rbp-50h]
  int v14; // [rsp+30h] [rbp-50h]
  int v15; // [rsp+34h] [rbp-4Ch]
  char *endptr; // [rsp+38h] [rbp-48h]
  char *nptr; // [rsp+40h] [rbp-40h]
  char *v18; // [rsp+48h] [rbp-38h]
  __int64 v19; // [rsp+50h] [rbp-30h]
  __int64 v20; // [rsp+58h] [rbp-28h]
  char *v21; // [rsp+60h] [rbp-20h]
  char *v22; // [rsp+68h] [rbp-18h]
  __int64 v23; // [rsp+70h] [rbp-10h]
  unsigned __int64 v24; // [rsp+78h] [rbp-8h]

  v8 = a3;
  v24 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 54200) )
  {
    *(_QWORD *)(a1 + 54488) = 0LL;
    *(_QWORD *)(a1 + 54496) = 0LL;
    *(_QWORD *)(a1 + 54504) = 0LL;
    *(_QWORD *)(a1 + 54512) = 0LL;
    *(_QWORD *)(a1 + 54216) = (a3 != 0LL) + 3 * strlen(a2) + 10;
    *(_QWORD *)(a1 + 54208) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 54216), a1);
    if ( !*(_QWORD *)(a1 + 54208) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate a command buffer for SCP session");
      return 0LL;
    }
    if ( v8 )
      v4 = "p";
    else
      v4 = (const char *)&unk_4878E;
    snprintf(*(char **)(a1 + 54208), *(_QWORD *)(a1 + 54216), "scp -%sf ", v4);
    v5 = strlen(*(const char **)(a1 + 54208));
    *(_QWORD *)(a1 + 54216) = (signed int)&sub_32199(
                                             a2,
                                             (_BYTE *)(v5 + *(_QWORD *)(a1 + 54208)),
                                             (unsigned int)*(_QWORD *)(a1 + 54216) - v5)[v5];
    *(_DWORD *)(a1 + 54200) = 2;
  }
  if ( *(_DWORD *)(a1 + 54200) == 2 )
  {
    *(_QWORD *)(a1 + 54520) = _libssh2_channel_open(a1, "session", 7LL, 0x200000LL, 0x8000LL, 0LL, 0LL);
    if ( !*(_QWORD *)(a1 + 54520) )
    {
      if ( (unsigned int)libssh2_session_last_errno(a1) == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block starting up channel");
      }
      else
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
        *(_QWORD *)(a1 + 54208) = 0LL;
        *(_DWORD *)(a1 + 54200) = 0;
      }
      return 0LL;
    }
    *(_DWORD *)(a1 + 54200) = 3;
  }
  if ( *(_DWORD *)(a1 + 54200) == 3 )
  {
    v9 = _libssh2_channel_process_startup(
           *(_QWORD *)(a1 + 54520),
           "exec",
           4LL,
           *(_QWORD *)(a1 + 54208),
           *(_QWORD *)(a1 + 54216));
    if ( v9 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block requesting SCP startup");
      return 0LL;
    }
    if ( v9 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
      *(_QWORD *)(a1 + 54208) = 0LL;
      goto LABEL_126;
    }
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
    *(_QWORD *)(a1 + 54208) = 0LL;
    *(_BYTE *)(a1 + 54224) = 0;
    *(_DWORD *)(a1 + 54200) = 4;
  }
  if ( *(_DWORD *)(a1 + 54200) == 4 )
  {
    v10 = _libssh2_channel_write(*(_QWORD *)(a1 + 54520), 0LL, a1 + 54224, 1LL);
    if ( v10 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block sending initial wakeup");
      return 0LL;
    }
    if ( v10 != 1 )
      goto LABEL_126;
    *(_QWORD *)(a1 + 54480) = 0LL;
    *(_DWORD *)(a1 + 54200) = 5;
  }
  if ( *(_DWORD *)(a1 + 54200) != 5 && *(_DWORD *)(a1 + 54200) != 6 )
    goto LABEL_73;
  while ( v8 && *(_QWORD *)(a1 + 54480) <= 0xFFuLL )
  {
    if ( *(_DWORD *)(a1 + 54200) == 5 )
    {
      v11 = _libssh2_channel_read(*(_QWORD *)(a1 + 54520), 0LL, *(_QWORD *)(a1 + 54480) + a1 + 54224, 1LL);
      if ( v11 == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block waiting for SCP response");
        return 0LL;
      }
      if ( (v11 & 0x80000000) != 0 )
      {
        _libssh2_error(a1, v11, "Failed reading SCP response");
        goto LABEL_126;
      }
      if ( !v11 )
      {
LABEL_123:
        if ( (unsigned int)libssh2_channel_eof(*(_QWORD *)(a1 + 54520)) )
        {
          _libssh2_error(a1, 4294967268LL, "Unexpected channel close");
          goto LABEL_126;
        }
        return *(_QWORD *)(a1 + 54520);
      }
      ++*(_QWORD *)(a1 + 54480);
      if ( *(_BYTE *)(a1 + 54224) != 84 )
      {
        v19 = _libssh2_channel_packet_data_len(*(_QWORD *)(a1 + 54520), 0LL);
        v20 = (*(__int64 ( **)(__int64, __int64))(a1 + 8))(v19 + 1, a1);
        if ( v20 )
        {
          _libssh2_channel_read(*(_QWORD *)(a1 + 54520), 0LL, v20, v19);
          *(_BYTE *)(v20 + v19) = 0;
          _libssh2_error(a1, 4294967268LL, "Failed to recv file");
          (*(void ( **)(__int64, __int64))(a1 + 24))(v20, a1);
        }
        else
        {
          _libssh2_error(a1, 4294967290LL, "Failed to get memory ");
        }
        goto LABEL_126;
      }
      if ( *(_QWORD *)(a1 + 54480) > 1uLL
        && (*(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) <= 0x2Fu
         || *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) > 0x39u)
        && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) != 32
        && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) != 13
        && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) != 10 )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid data in SCP response");
        goto LABEL_126;
      }
      if ( *(_QWORD *)(a1 + 54480) > 8uLL && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) == 10 )
      {
        while ( *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) == 13
             || *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) == 10 )
          --*(_QWORD *)(a1 + 54480);
        *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) + 54224) = 0;
        if ( *(_QWORD *)(a1 + 54480) <= 7uLL )
        {
          _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, too short");
          goto LABEL_126;
        }
        nptr = (char *)(a1 + 54225);
        v18 = strchr((const char *)(a1 + 54225), 32);
        if ( !v18 || v18 - nptr <= 0 )
        {
          _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, malformed mtime");
          goto LABEL_126;
        }
        v6 = v18++;
        *v6 = 0;
        *(_QWORD *)(a1 + 54504) = strtol(nptr, 0LL, 10);
        nptr = strchr(v18, 32);
        if ( !nptr || nptr - v18 <= 0 )
        {
          _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, malformed mtime.usec");
          goto LABEL_126;
        }
        v18 = strchr(++nptr, 32);
        if ( !v18 || v18 - nptr <= 0 )
        {
          _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, too short or malformed");
          goto LABEL_126;
        }
        *v18 = 0;
        *(_QWORD *)(a1 + 54512) = strtol(nptr, 0LL, 10);
        *(_BYTE *)(a1 + 54224) = 0;
        *(_DWORD *)(a1 + 54200) = 6;
        goto LABEL_65;
      }
      if ( *(_QWORD *)(a1 + 54480) == 256LL )
      {
        _libssh2_error(a1, 4294967268LL, "Unterminated response from SCP server");
        goto LABEL_126;
      }
    }
    else
    {
LABEL_65:
      if ( *(_DWORD *)(a1 + 54200) == 6 )
      {
        v12 = _libssh2_channel_write(*(_QWORD *)(a1 + 54520), 0LL, a1 + 54224, 1LL);
        if ( v12 == -37 )
        {
          _libssh2_error(a1, 4294967259LL, "Would block waiting to send SCP ACK");
          return 0LL;
        }
        if ( v12 != 1 )
          goto LABEL_126;
        break;
      }
    }
  }
  *(_DWORD *)(a1 + 54200) = 7;
LABEL_73:
  if ( *(_DWORD *)(a1 + 54200) == 7 )
  {
    *(_QWORD *)(a1 + 54480) = 0LL;
    *(_DWORD *)(a1 + 54200) = 8;
  }
  if ( *(_DWORD *)(a1 + 54200) != 8 && *(_DWORD *)(a1 + 54200) != 9 )
  {
LABEL_120:
    if ( v8 )
    {
      memset(v8, 0, 0x90uLL);
      *((_QWORD *)v8 + 11) = *(_QWORD *)(a1 + 54504);
      *((_QWORD *)v8 + 9) = *(_QWORD *)(a1 + 54512);
      *((_QWORD *)v8 + 6) = *(_QWORD *)(a1 + 54496);
      *((_DWORD *)v8 + 6) = (unsigned __int16)*(_QWORD *)(a1 + 54488);
    }
    *(_DWORD *)(a1 + 54200) = 0;
    return *(_QWORD *)(a1 + 54520);
  }
  while ( 1 )
  {
LABEL_118:
    if ( *(_QWORD *)(a1 + 54480) > 0xFFuLL )
      goto LABEL_119;
    endptr = 0LL;
    if ( *(_DWORD *)(a1 + 54200) != 8 )
      break;
    v13 = _libssh2_channel_read(*(_QWORD *)(a1 + 54520), 0LL, *(_QWORD *)(a1 + 54480) + a1 + 54224, 1LL);
    if ( v13 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block waiting for SCP response");
      return 0LL;
    }
    if ( (v13 & 0x80000000) != 0 )
    {
      _libssh2_error(a1, v13, "Failed reading SCP response");
      goto LABEL_126;
    }
    if ( !v13 )
      goto LABEL_123;
    ++*(_QWORD *)(a1 + 54480);
    if ( *(_BYTE *)(a1 + 54224) != 67 )
    {
      _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server");
      goto LABEL_126;
    }
    if ( *(_QWORD *)(a1 + 54480) > 1uLL
      && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) != 13
      && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) != 10
      && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) <= 0x1Fu )
    {
      _libssh2_error(a1, 4294967268LL, "Invalid data in SCP response");
      goto LABEL_126;
    }
    if ( *(_QWORD *)(a1 + 54480) > 6uLL && *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) == 10 )
    {
      while ( *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) == 13
           || *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) - 1LL + 54224) == 10 )
        --*(_QWORD *)(a1 + 54480);
      *(_BYTE *)(a1 + *(_QWORD *)(a1 + 54480) + 54224) = 0;
      if ( *(_QWORD *)(a1 + 54480) <= 5uLL )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, too short");
        goto LABEL_126;
      }
      v21 = (char *)(a1 + 54225);
      v22 = strchr((const char *)(a1 + 54225), 32);
      if ( !v22 || v22 - v21 <= 0 )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, malformed mode");
        goto LABEL_126;
      }
      v7 = v22++;
      *v7 = 0;
      *(_QWORD *)(a1 + 54488) = strtol(v21, &endptr, 8);
      if ( endptr && *endptr )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, invalid mode");
        goto LABEL_126;
      }
      v21 = strchr(v22, 32);
      if ( !v21 || v21 - v22 <= 0 )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, too short or malformed");
        goto LABEL_126;
      }
      *v21 = 0;
      *(_QWORD *)(a1 + 54496) = strtoll(v22, &endptr, 10);
      if ( endptr && *endptr )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid response from SCP server, invalid size");
        goto LABEL_126;
      }
      *(_BYTE *)(a1 + 54224) = 0;
      *(_DWORD *)(a1 + 54200) = 9;
      break;
    }
    if ( *(_QWORD *)(a1 + 54480) == 256LL )
    {
      _libssh2_error(a1, 4294967268LL, "Unterminated response from SCP server");
      goto LABEL_126;
    }
  }
  if ( *(_DWORD *)(a1 + 54200) != 9 )
    goto LABEL_118;
  v14 = _libssh2_channel_write(*(_QWORD *)(a1 + 54520), 0LL, a1 + 54224, 1LL);
  if ( v14 == -37 )
  {
    _libssh2_error(a1, 4294967259LL, "Would block sending SCP ACK");
    return 0LL;
  }
  if ( v14 == 1 )
  {
LABEL_119:
    *(_DWORD *)(a1 + 54200) = 10;
    goto LABEL_120;
  }
LABEL_126:
  v15 = *(_DWORD *)(a1 + 576);
  v23 = *(_QWORD *)(a1 + 568);
  while ( (unsigned int)libssh2_channel_free(*(_QWORD *)(a1 + 54520)) == -37 )
    ;
  *(_DWORD *)(a1 + 576) = v15;
  *(_QWORD *)(a1 + 568) = v23;
  *(_QWORD *)(a1 + 54520) = 0LL;
  *(_DWORD *)(a1 + 54200) = 0;
  return 0LL;
}
// 89A0: using guessed type __int64  libssh2_channel_eof(_QWORD, _QWORD);
// 8B10: using guessed type __int64  libssh2_channel_free(_QWORD);
// 8C30: using guessed type __int64  _libssh2_channel_packet_data_len(_QWORD, _QWORD);
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9460: using guessed type __int64  _libssh2_channel_process_startup(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 97F0: using guessed type __int64  _libssh2_channel_read(_QWORD, _QWORD, _QWORD, _QWORD);
// 9A60: using guessed type __int64  _libssh2_channel_open(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000033488) ----------------------------------------------------
__int64  libssh2_scp_recv(__int64 a1, char *a2, void *a3)
{
  char *v3; // rax
  void *v5; // [rsp+8h] [rbp-D8h]
  char *v6; // [rsp+28h] [rbp-B8h]
  time_t v7; // [rsp+30h] [rbp-B0h]
  __int64 v8; // [rsp+38h] [rbp-A8h]
  char s; // [rsp+40h] [rbp-A0h]
  int v10; // [rsp+58h] [rbp-88h]
  __int64 v11; // [rsp+70h] [rbp-70h]
  __int64 v12; // [rsp+88h] [rbp-58h]
  __int64 v13; // [rsp+98h] [rbp-48h]
  unsigned __int64 v14; // [rsp+D8h] [rbp-8h]

  v5 = a3;
  v14 = __readfsqword(0x28u);
  memset(&s, 0, 0x90uLL);
  if ( v5 )
    v3 = &s;
  else
    v3 = 0LL;
  v6 = v3;
  v7 = time(0LL);
  do
    v8 = sub_32487(a1, a2, v6);
  while ( *(_DWORD *)(a1 + 148)
       && !v8
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v7) );
  if ( v5 )
  {
    memset(v5, 0, 0x90uLL);
    *((_QWORD *)v5 + 11) = v13;
    *((_QWORD *)v5 + 9) = v12;
    *((_QWORD *)v5 + 6) = v11;
    *((_DWORD *)v5 + 6) = v10;
  }
  return v8;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000335FB) ----------------------------------------------------
__int64  libssh2_scp_recv2(__int64 a1, char *a2, void *a3)
{
  void *v4; // [rsp+8h] [rbp-38h]
  time_t v5; // [rsp+30h] [rbp-10h]
  __int64 v6; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v5 = time(0LL);
  do
    v6 = sub_32487(a1, a2, v4);
  while ( *(_DWORD *)(a1 + 148)
       && !v6
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v5) );
  return v6;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000033680) ----------------------------------------------------
__int64  sub_33680(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  size_t v6; // rax
  _BOOL4 v7; // rdx
  const char *v9; // rax
  int v10; // eax
  __int64 v11; // [rsp+0h] [rbp-60h]
  __int64 v12; // [rsp+8h] [rbp-58h]
  __int64 v13; // [rsp+10h] [rbp-50h]
  unsigned int v14; // [rsp+1Ch] [rbp-44h]
  int v15; // [rsp+38h] [rbp-28h]
  unsigned int v16; // [rsp+38h] [rbp-28h]
  int v17; // [rsp+38h] [rbp-28h]
  unsigned int v18; // [rsp+38h] [rbp-28h]
  int v19; // [rsp+38h] [rbp-28h]
  int v20; // [rsp+38h] [rbp-28h]
  int v21; // [rsp+3Ch] [rbp-24h]
  char *v22; // [rsp+40h] [rbp-20h]
  signed __int64 v23; // [rsp+40h] [rbp-20h]
  __int64 v24; // [rsp+48h] [rbp-18h]
  __int64 v25; // [rsp+50h] [rbp-10h]
  __int64 v26; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  if ( !*(_DWORD *)(a1 + 54528) )
  {
    v6 = 3 * strlen(a2);
    v7 = v12 || v11;
    *(_QWORD *)(a1 + 54544) = v7 + v6 + 10;
    *(_QWORD *)(a1 + 54536) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 54544), a1);
    if ( !*(_QWORD *)(a1 + 54536) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate a command buffer for SCP session");
      return 0LL;
    }
    if ( v12 || v11 )
      v9 = "p";
    else
      v9 = (const char *)&unk_4878E;
    snprintf(*(char **)(a1 + 54536), *(_QWORD *)(a1 + 54544), "scp -%st ", v9);
    v10 = strlen(*(const char **)(a1 + 54536));
    *(_QWORD *)(a1 + 54544) = (signed int)&sub_32199(
                                             a2,
                                             (_BYTE *)(v10 + *(_QWORD *)(a1 + 54536)),
                                             (unsigned int)*(_QWORD *)(a1 + 54544) - v10)[v10];
    *(_DWORD *)(a1 + 54528) = 2;
  }
  if ( *(_DWORD *)(a1 + 54528) != 2 )
  {
LABEL_20:
    if ( *(_DWORD *)(a1 + 54528) == 3 )
    {
      v15 = _libssh2_channel_process_startup(
              *(_QWORD *)(a1 + 54816),
              "exec",
              4LL,
              *(_QWORD *)(a1 + 54536),
              *(_QWORD *)(a1 + 54544));
      if ( v15 == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block requesting SCP startup");
        return 0LL;
      }
      if ( v15 )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54536), a1);
        *(_QWORD *)(a1 + 54536) = 0LL;
        _libssh2_error(a1, 4294967268LL, "Unknown error while getting error string");
        goto LABEL_84;
      }
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54536), a1);
      *(_QWORD *)(a1 + 54536) = 0LL;
      *(_DWORD *)(a1 + 54528) = 4;
    }
    if ( *(_DWORD *)(a1 + 54528) == 4 )
    {
      v16 = _libssh2_channel_read(*(_QWORD *)(a1 + 54816), 0LL, a1 + 54552, 1LL);
      if ( v16 == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block waiting for response from remote");
        return 0LL;
      }
      if ( (v16 & 0x80000000) != 0 )
      {
        _libssh2_error(a1, v16, "SCP failure");
        goto LABEL_84;
      }
      if ( !v16 )
        goto LABEL_81;
      if ( *(_BYTE *)(a1 + 54552) )
      {
        _libssh2_error(a1, 4294967268LL, "Invalid ACK response from remote");
        goto LABEL_84;
      }
      if ( v12 || v11 )
        *(_QWORD *)(a1 + 54808) = snprintf((char *)(a1 + 54552), 0x100uLL, "T%ld 0 %ld 0\n", v12, v11);
      *(_DWORD *)(a1 + 54528) = 5;
    }
    if ( v12 || v11 )
    {
      if ( *(_DWORD *)(a1 + 54528) == 5 )
      {
        v17 = _libssh2_channel_write(*(_QWORD *)(a1 + 54816), 0LL, a1 + 54552, *(_QWORD *)(a1 + 54808));
        if ( v17 == -37 )
        {
          _libssh2_error(a1, 4294967259LL, "Would block sending time data for SCP file");
          return 0LL;
        }
        if ( v17 != (unsigned int)*(_QWORD *)(a1 + 54808) )
        {
          _libssh2_error(a1, 4294967289LL, "Unable to send time data for SCP file");
          goto LABEL_84;
        }
        *(_DWORD *)(a1 + 54528) = 6;
      }
      if ( *(_DWORD *)(a1 + 54528) == 6 )
      {
        v18 = _libssh2_channel_read(*(_QWORD *)(a1 + 54816), 0LL, a1 + 54552, 1LL);
        if ( v18 == -37 )
        {
          _libssh2_error(a1, 4294967259LL, "Would block waiting for response");
          return 0LL;
        }
        if ( (v18 & 0x80000000) != 0 )
        {
          _libssh2_error(a1, v18, "SCP failure");
          goto LABEL_84;
        }
        if ( !v18 )
          goto LABEL_81;
        if ( *(_BYTE *)(a1 + 54552) )
        {
          _libssh2_error(a1, 4294967268LL, "Invalid SCP ACK response");
          goto LABEL_84;
        }
        *(_DWORD *)(a1 + 54528) = 7;
      }
    }
    else if ( *(_DWORD *)(a1 + 54528) == 5 )
    {
      *(_DWORD *)(a1 + 54528) = 7;
    }
    if ( *(_DWORD *)(a1 + 54528) == 7 )
    {
      v22 = strrchr(a2, 47);
      if ( v22 )
        v23 = (signed __int64)(v22 + 1);
      else
        v23 = (signed __int64)a2;
      *(_QWORD *)(a1 + 54808) = snprintf((char *)(a1 + 54552), 0x100uLL, "C0%o %lld %s\n", v14, v13, v23, v11);
      *(_DWORD *)(a1 + 54528) = 8;
    }
    if ( *(_DWORD *)(a1 + 54528) == 8 )
    {
      v19 = _libssh2_channel_write(*(_QWORD *)(a1 + 54816), 0LL, a1 + 54552, *(_QWORD *)(a1 + 54808));
      if ( v19 == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block send core file data for SCP file");
        return 0LL;
      }
      if ( v19 != (unsigned int)*(_QWORD *)(a1 + 54808) )
      {
        _libssh2_error(a1, 4294967289LL, "Unable to send core file data for SCP file");
        goto LABEL_84;
      }
      *(_DWORD *)(a1 + 54528) = 9;
    }
    if ( *(_DWORD *)(a1 + 54528) != 9 )
    {
LABEL_80:
      *(_DWORD *)(a1 + 54528) = 0;
      return *(_QWORD *)(a1 + 54816);
    }
    v20 = _libssh2_channel_read(*(_QWORD *)(a1 + 54816), 0LL, a1 + 54552, 1LL);
    if ( v20 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block waiting for response");
      return 0LL;
    }
    if ( v20 < 0 )
    {
      _libssh2_error(a1, 4294967268LL, "Invalid ACK response from remote");
LABEL_84:
      v21 = *(_DWORD *)(a1 + 576);
      v26 = *(_QWORD *)(a1 + 568);
      while ( (unsigned int)libssh2_channel_free(*(_QWORD *)(a1 + 54816)) == -37 )
        ;
      *(_DWORD *)(a1 + 576) = v21;
      *(_QWORD *)(a1 + 568) = v26;
      *(_QWORD *)(a1 + 54816) = 0LL;
      *(_DWORD *)(a1 + 54528) = 0;
      return 0LL;
    }
    if ( v20 )
    {
      if ( *(_BYTE *)(a1 + 54552) )
      {
        v24 = _libssh2_channel_packet_data_len(*(_QWORD *)(a1 + 54816), 0LL);
        v25 = (*(__int64 ( **)(__int64, __int64))(a1 + 8))(v24 + 1, a1);
        if ( v25 )
        {
          if ( (signed int)_libssh2_channel_read(*(_QWORD *)(a1 + 54816), 0LL, v25, v24) > 0 )
            *(_BYTE *)(v25 + v24) = 0;
          (*(void ( **)(__int64, __int64))(a1 + 24))(v25, a1);
          _libssh2_error(a1, 4294967268LL, "failed to send file");
        }
        else
        {
          _libssh2_error(a1, 4294967290LL, "failed to get memory");
        }
        goto LABEL_84;
      }
      goto LABEL_80;
    }
LABEL_81:
    if ( !(unsigned int)libssh2_channel_eof(*(_QWORD *)(a1 + 54816)) )
      return *(_QWORD *)(a1 + 54816);
    _libssh2_error(a1, 4294967268LL, "Unexpected channel close");
    goto LABEL_84;
  }
  *(_QWORD *)(a1 + 54816) = _libssh2_channel_open(a1, "session", 7LL, 0x200000LL, 0x8000LL, 0LL, 0LL);
  if ( *(_QWORD *)(a1 + 54816) )
  {
    *(_DWORD *)(a1 + 54528) = 3;
    goto LABEL_20;
  }
  if ( (unsigned int)libssh2_session_last_errno(a1) == -37 )
  {
    _libssh2_error(a1, 4294967259LL, "Would block starting up channel");
  }
  else
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54536), a1);
    *(_QWORD *)(a1 + 54536) = 0LL;
    *(_DWORD *)(a1 + 54528) = 0;
  }
  return 0LL;
}
// 89A0: using guessed type __int64  libssh2_channel_eof(_QWORD, _QWORD);
// 8B10: using guessed type __int64  libssh2_channel_free(_QWORD);
// 8C30: using guessed type __int64  _libssh2_channel_packet_data_len(_QWORD, _QWORD);
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9460: using guessed type __int64  _libssh2_channel_process_startup(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 97F0: using guessed type __int64  _libssh2_channel_read(_QWORD, _QWORD, _QWORD, _QWORD);
// 9A60: using guessed type __int64  _libssh2_channel_open(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034039) ----------------------------------------------------
__int64  libssh2_scp_send_ex(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+10h] [rbp-40h]
  unsigned int v10; // [rsp+1Ch] [rbp-34h]
  time_t v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v11 = time(0LL);
  do
    v12 = sub_33680(a1, a2, v10, v9, v8, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v12
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v11) );
  return v12;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000340D7) ----------------------------------------------------
__int64  libssh2_scp_send64(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 v8; // [rsp+8h] [rbp-48h]
  __int64 v9; // [rsp+10h] [rbp-40h]
  unsigned int v10; // [rsp+1Ch] [rbp-34h]
  time_t v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v11 = time(0LL);
  do
    v12 = sub_33680(a1, a2, v10, v9, v8, v7);
  while ( *(_DWORD *)(a1 + 148)
       && !v12
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v11) );
  return v12;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000034175) ----------------------------------------------------
void * sub_34175(size_t a1)
{
  return malloc(a1);
}

//----- (0000000000034193) ----------------------------------------------------
void  sub_34193(void *a1)
{
  free(a1);
}

//----- (00000000000341B2) ----------------------------------------------------
void * sub_341B2(void *a1, size_t a2)
{
  return realloc(a1, a2);
}

//----- (00000000000341DB) ----------------------------------------------------
__int64  sub_341DB(__int64 a1)
{
  unsigned int v1; // er9
  __int64 result; // rax
  int v3; // eax
  char v4; // [rsp+1Fh] [rbp-11h]
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 52064) )
  {
    v5 = *(_QWORD *)(a1 + 52328);
  }
  else
  {
    v5 = 0;
    *(_DWORD *)(a1 + 52064) = 2;
  }
  while ( v5 <= 255 && (!v5 || *(_BYTE *)(a1 + v5 - 1 + 52068) != 10) )
  {
    v4 = 0;
    *(_DWORD *)(a1 + 560) &= 0xFFFFFFFE;
    if ( *(_DWORD *)(a1 + 108) )
      v1 = 0;
    else
      v1 = 0x4000;
    v6 = (*(__int64 ( **)(_QWORD, char *, signed __int64, _QWORD, __int64))(a1 + 80))(
           *(unsigned int *)(a1 + 552),
           &v4,
           1LL,
           v1,
           a1);
    if ( v6 < 0 )
    {
      if ( v6 == -11 )
      {
        *(_DWORD *)(a1 + 560) = 1;
        *(_QWORD *)(a1 + 52328) = v5;
        result = 4294967259LL;
      }
      else
      {
        *(_DWORD *)(a1 + 52064) = 0;
        *(_QWORD *)(a1 + 52328) = 0LL;
        result = 4294967253LL;
      }
      return result;
    }
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 556) = -1;
      return 4294967283LL;
    }
    if ( !v4 )
    {
      *(_DWORD *)(a1 + 52064) = 0;
      *(_QWORD *)(a1 + 52328) = 0LL;
      return 4294967294LL;
    }
    v3 = v5++;
    *(_BYTE *)(a1 + v3 + 52068) = v4;
  }
  while ( v5 && (*(_BYTE *)(a1 + v5 - 1 + 52068) == 10 || *(_BYTE *)(a1 + v5 - 1 + 52068) == 13) )
    --v5;
  *(_DWORD *)(a1 + 52064) = 0;
  *(_QWORD *)(a1 + 52328) = 0LL;
  if ( !v5 )
    return 4294967294LL;
  if ( *(_QWORD *)(a1 + 272) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 272), a1);
  *(_QWORD *)(a1 + 272) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(v5 + 1, a1);
  if ( !*(_QWORD *)(a1 + 272) )
    return _libssh2_error(a1, 4294967290LL, "Error allocating space for remote banner");
  memcpy(*(void **)(a1 + 272), (const void *)(a1 + 52068), v5);
  *(_BYTE *)(*(_QWORD *)(a1 + 272) + v5) = 0;
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (00000000000344CC) ----------------------------------------------------
signed __int64  sub_344CC(__int64 a1)
{
  unsigned int v1; // er9
  signed __int64 result; // rax
  signed int v3; // [rsp+1Ch] [rbp-14h]
  const char *v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = "SSH-2.0-libssh2_1.9.0_DEV\r\n";
  v3 = 27;
  if ( !*(_DWORD *)(a1 + 52064) )
  {
    if ( *(_QWORD *)(a1 + 384) )
    {
      v3 = strlen(*(const char **)(a1 + 384));
      v4 = *(const char **)(a1 + 384);
    }
    *(_DWORD *)(a1 + 52064) = 2;
  }
  *(_DWORD *)(a1 + 560) &= 0xFFFFFFFD;
  if ( *(_DWORD *)(a1 + 108) )
    v1 = 0;
  else
    v1 = 0x4000;
  v5 = (*(__int64 ( **)(_QWORD, const char *, _QWORD, _QWORD, __int64))(a1 + 72))(
         *(unsigned int *)(a1 + 552),
         &v4[*(_QWORD *)(a1 + 52328)],
         v3 - *(_QWORD *)(a1 + 52328),
         v1,
         a1);
  if ( v5 == v3 - *(_QWORD *)(a1 + 52328) )
  {
    *(_DWORD *)(a1 + 52064) = 0;
    *(_QWORD *)(a1 + 52328) = 0LL;
    result = 0LL;
  }
  else if ( v5 < 0 && v5 != -11 )
  {
    *(_DWORD *)(a1 + 52064) = 0;
    *(_QWORD *)(a1 + 52328) = 0LL;
    result = 4294967253LL;
  }
  else
  {
    *(_DWORD *)(a1 + 560) = 2;
    if ( v5 > 0 )
      *(_QWORD *)(a1 + 52328) += v5;
    result = 4294967259LL;
  }
  return result;
}

//----- (000000000003466D) ----------------------------------------------------
int  sub_3466D(int a1, int a2)
{
  unsigned int v2; // eax
  int v4; // [rsp+1Ch] [rbp-4h]

  v4 = fcntl(a1, 3, 0LL);
  if ( a2 )
  {
    v2 = v4;
    BYTE1(v2) |= 8u;
  }
  else
  {
    v2 = v4;
    BYTE1(v2) &= 0xF7u;
  }
  return fcntl(a1, 4, v2);
}

//----- (00000000000346D9) ----------------------------------------------------
signed __int64  sub_346D9(int a1)
{
  signed __int64 result; // rax
  int v2; // [rsp+1Ch] [rbp-4h]

  v2 = fcntl(a1, 3, 0LL);
  if ( v2 == -1 )
    result = 1LL;
  else
    result = v2 & 0x800;
  return result;
}

//----- (0000000000034717) ----------------------------------------------------
__int64  libssh2_session_banner_set(__int64 a1, const char *a2)
{
  size_t v2; // rax
  signed __int64 v4; // rax
  size_t n; // [rsp+18h] [rbp-8h]

  if ( a2 )
    v2 = strlen(a2);
  else
    v2 = 0LL;
  n = v2;
  if ( *(_QWORD *)(a1 + 384) )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 384), a1);
    *(_QWORD *)(a1 + 384) = 0LL;
  }
  if ( !n )
    return 0LL;
  *(_QWORD *)(a1 + 384) = (*(__int64 ( **)(size_t, __int64))(a1 + 8))(n + 3, a1);
  if ( !*(_QWORD *)(a1 + 384) )
    return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for local banner");
  memcpy(*(void **)(a1 + 384), a2, n);
  *(_BYTE *)(*(_QWORD *)(a1 + 384) + n) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 384) + n) = 13;
  v4 = n + 1;
  *(_BYTE *)(*(_QWORD *)(a1 + 384) + v4) = 10;
  *(_BYTE *)(*(_QWORD *)(a1 + 384) + v4 + 1) = 0;
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000034874) ----------------------------------------------------
__int64  libssh2_banner_set(__int64 a1, __int64 a2)
{
  return libssh2_session_banner_set(a1, a2);
}
// 9280: using guessed type __int64  libssh2_session_banner_set(_QWORD, _QWORD);

//----- (0000000000034899) ----------------------------------------------------
void * libssh2_session_init_ex(void *( *a1)(size_t a1), void ( *a2)(void *a1), void *( *a3)(void *a1, size_t a2), __int64 a4)
{
  void *v4; // rdi
  __int64 v6; // [rsp+0h] [rbp-40h]
  void *( *v7)(void *, size_t); // [rsp+8h] [rbp-38h]
  void ( *v8)(void *); // [rsp+10h] [rbp-30h]
  void *( *v9)(size_t); // [rsp+18h] [rbp-28h]
  void *( *v10)(size_t); // [rsp+20h] [rbp-20h]
  void ( *v11)(void *); // [rsp+28h] [rbp-18h]
  void *( *v12)(void *, size_t); // [rsp+30h] [rbp-10h]
  void *s; // [rsp+38h] [rbp-8h]

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v10 = sub_34175;
  v11 = sub_34193;
  v12 = sub_341B2;
  if ( a1 )
    v10 = v9;
  if ( v8 )
    v11 = v8;
  if ( v7 )
    v12 = v7;
  s = (void *)((__int64 ( *)(signed __int64, __int64 *))v10)(54840LL, &v6);
  if ( s )
  {
    v4 = s;
    memset(s, 0, 0xD638uLL);
    *((_QWORD *)s + 1) = v10;
    *((_QWORD *)s + 3) = v11;
    *((_QWORD *)s + 2) = v12;
    *((_QWORD *)s + 9) = libssh2_send;
    *((_QWORD *)s + 10) = libssh2_recv;
    *(_QWORD *)s = v6;
    *((_QWORD *)s + 19) = 0LL;
    *((_DWORD *)s + 37) = 1;
    _libssh2_init_if_needed(v4, 0LL);
  }
  return s;
}
// 90D0: using guessed type __int64  _libssh2_init_if_needed(_QWORD, _QWORD);

//----- (00000000000349AB) ----------------------------------------------------
__int64  libssh2_session_callback_set(_QWORD *a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // ST20_8
  __int64 result; // rax
  __int64 v5; // ST20_8
  __int64 v6; // ST20_8
  __int64 v7; // ST20_8
  __int64 v8; // ST20_8
  __int64 v9; // ST20_8
  __int64 v10; // ST20_8

  switch ( (unsigned __int64)a2 )
  {
    case 0uLL:
      v3 = a1[4];
      a1[4] = a3;
      result = v3;
      break;
    case 1uLL:
      v5 = a1[5];
      a1[5] = a3;
      result = v5;
      break;
    case 2uLL:
      v6 = a1[6];
      a1[6] = a3;
      result = v6;
      break;
    case 3uLL:
      v7 = a1[7];
      a1[7] = a3;
      result = v7;
      break;
    case 4uLL:
      v8 = a1[8];
      a1[8] = a3;
      result = v8;
      break;
    case 5uLL:
      v9 = a1[9];
      a1[9] = a3;
      result = v9;
      break;
    case 6uLL:
      v10 = a1[10];
      a1[10] = a3;
      result = v10;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000034AC7) ----------------------------------------------------
__int64  libssh2_wait_socket(__int64 a1, time_t a2)
{
  int v3; // edx
  int v4; // [rsp+18h] [rbp-38h]
  _BOOL4 v5; // [rsp+1Ch] [rbp-34h]
  int v6; // [rsp+20h] [rbp-30h]
  int v7; // [rsp+24h] [rbp-2Ch]
  __int64 v8; // [rsp+28h] [rbp-28h]
  time_t time1; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  struct pollfd fds; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  v8 = 0LL;
  *(_DWORD *)(a1 + 576) = 0;
  v6 = libssh2_keepalive_send(a1, &v4);
  if ( v6 )
    return (unsigned int)v6;
  v8 = 1000 * v4;
  v7 = libssh2_session_block_directions(a1);
  if ( !v7 )
    v8 = 1000LL;
  if ( *(_QWORD *)(a1 + 152) <= 0LL || v4 && v8 <= *(_QWORD *)(a1 + 152) )
  {
    v5 = v8 > 0;
  }
  else
  {
    time1 = time(0LL);
    v10 = (unsigned int)(signed int)(1000.0 * difftime(time1, a2));
    if ( v10 > *(_QWORD *)(a1 + 152) )
      return _libssh2_error(a1, 4294967287LL, "API timeout expired");
    v8 = *(_QWORD *)(a1 + 152) - v10;
    v5 = 1;
  }
  fds.fd = *(_DWORD *)(a1 + 552);
  fds.events = 0;
  fds.revents = 0;
  if ( v7 & 1 )
    fds.events |= 1u;
  if ( v7 & 2 )
    fds.events |= 4u;
  if ( v5 )
    v3 = v8;
  else
    v3 = -1;
  v6 = poll(&fds, 1uLL, v3);
  if ( !v6 )
    return _libssh2_error(a1, 4294967287LL, "Timed out waiting on socket");
  if ( v6 >= 0 )
    return 0LL;
  return _libssh2_error(a1, 4294967287LL, "Error waiting on socket");
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9110: using guessed type __int64  libssh2_keepalive_send(_QWORD, _QWORD);
// 9130: using guessed type __int64  libssh2_session_block_directions(_QWORD);

//----- (0000000000034CDC) ----------------------------------------------------
__int64  sub_34CDC(__int64 a1, int a2)
{
  __int64 result; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-4h]
  unsigned int v4; // [rsp+1Ch] [rbp-4h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]
  unsigned int v6; // [rsp+1Ch] [rbp-4h]
  unsigned int v7; // [rsp+1Ch] [rbp-4h]
  unsigned int v8; // [rsp+1Ch] [rbp-4h]

  if ( !*(_DWORD *)(a1 + 52360) )
  {
    if ( a2 == -1 )
      return _libssh2_error(a1, 4294967251LL, "Bad socket provided");
    *(_DWORD *)(a1 + 552) = a2;
    *(_DWORD *)(a1 + 564) = (unsigned __int64)sub_346D9(*(_DWORD *)(a1 + 552)) == 0;
    if ( *(_DWORD *)(a1 + 564) )
    {
      v3 = sub_3466D(*(_DWORD *)(a1 + 552), 1);
      if ( v3 )
        return _libssh2_error(a1, v3, "Failed changing socket's blocking state to non-blocking");
    }
    *(_DWORD *)(a1 + 52360) = 2;
  }
  if ( *(_DWORD *)(a1 + 52360) == 2 )
  {
    v4 = sub_344CC(a1);
    if ( v4 == -37 )
      return 4294967259LL;
    if ( v4 )
      return _libssh2_error(a1, v4, "Failed sending banner");
    *(_DWORD *)(a1 + 52360) = 3;
    *(_DWORD *)(a1 + 52064) = 0;
  }
  if ( *(_DWORD *)(a1 + 52360) == 3 )
  {
    do
    {
      v5 = sub_341DB(a1);
      if ( v5 == -37 )
        return 4294967259LL;
      if ( v5 )
        return _libssh2_error(a1, v5, "Failed getting banner");
    }
    while ( strncmp("SSH-", *(const char **)(a1 + 272), 4uLL) );
    *(_DWORD *)(a1 + 52360) = 4;
  }
  if ( *(_DWORD *)(a1 + 52360) == 4 )
  {
    v6 = _libssh2_kex_exchange(a1, 0LL, a1 + 52432);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v6 )
      return _libssh2_error(a1, v6, "Unable to exchange encryption keys");
    *(_DWORD *)(a1 + 52360) = 5;
  }
  if ( *(_DWORD *)(a1 + 52360) == 5 )
  {
    *(_BYTE *)(a1 + 52384) = 5;
    _libssh2_htonu32(a1 + 52385, 12LL);
    memcpy((void *)(a1 + 52389), "ssh-userauth", 0xCuLL);
    *(_DWORD *)(a1 + 52360) = 6;
  }
  if ( *(_DWORD *)(a1 + 52360) == 6 )
  {
    v7 = _libssh2_transport_send(a1, a1 + 52384, 17LL, 0LL, 0LL);
    if ( v7 == -37 )
      return 4294967259LL;
    if ( v7 )
      return _libssh2_error(a1, v7, "Unable to ask for ssh-userauth service");
    *(_DWORD *)(a1 + 52360) = 7;
  }
  if ( *(_DWORD *)(a1 + 52360) != 7 )
    return 4294967262LL;
  v8 = _libssh2_packet_require(a1, 6LL, a1 + 52368, a1 + 52376, 0LL, 0LL, 0LL, a1 + 52416);
  if ( v8 )
    return v8;
  if ( *(_QWORD *)(a1 + 52376) <= 4uLL )
    return _libssh2_error(a1, 4294967282LL, "Unexpected packet length");
  *(_QWORD *)(a1 + 52408) = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 52368) + 1LL);
  if ( *(_QWORD *)(a1 + 52408) == 12LL
    && !strncmp("ssh-userauth", (const char *)(*(_QWORD *)(a1 + 52368) + 5LL), *(_QWORD *)(a1 + 52408)) )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 52368), a1);
    *(_QWORD *)(a1 + 52368) = 0LL;
    *(_DWORD *)(a1 + 52360) = 0;
    result = 0LL;
  }
  else
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 52368), a1);
    *(_QWORD *)(a1 + 52368) = 0LL;
    result = _libssh2_error(a1, 4294967282LL, "Invalid response received from server");
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F00: using guessed type __int64  _libssh2_kex_exchange(_QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64  _libssh2_packet_require(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (000000000003516B) ----------------------------------------------------
__int64  libssh2_session_handshake(__int64 a1, int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  v4 = time(0LL);
  do
  {
    v3 = sub_34CDC(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v3 = _libssh2_wait_socket(a1, v4);
  }
  while ( !v3 );
  return v3;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000351D1) ----------------------------------------------------
__int64  libssh2_session_startup(__int64 a1, unsigned int a2)
{
  return libssh2_session_handshake(a1, a2);
}
// 9960: using guessed type __int64  libssh2_session_handshake(_QWORD, _QWORD);

//----- (00000000000351F3) ----------------------------------------------------
signed __int64  sub_351F3(__int64 a1)
{
  int v2; // [rsp+10h] [rbp-20h]
  __int64 v3; // [rsp+18h] [rbp-18h]
  __int64 v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v2 = 0;
  if ( !*(_DWORD *)(a1 + 53096) )
    *(_DWORD *)(a1 + 53096) = 2;
  if ( *(_DWORD *)(a1 + 53096) == 2 )
  {
    while ( 1 )
    {
      v3 = _libssh2_list_first(a1 + 512);
      if ( !v3 )
        break;
      if ( (unsigned int)_libssh2_channel_free(v3) == -37 )
        return 4294967259LL;
    }
    *(_DWORD *)(a1 + 53096) = 3;
  }
  if ( *(_DWORD *)(a1 + 53096) == 3 )
  {
    while ( 1 )
    {
      v4 = _libssh2_list_first(a1 + 536);
      if ( !v4 )
        break;
      if ( (unsigned int)_libssh2_channel_forward_cancel(v4) == -37 )
        return 4294967259LL;
    }
    *(_DWORD *)(a1 + 53096) = 4;
  }
  if ( *(_DWORD *)(a1 + 104) & 2 )
  {
    if ( *(_QWORD *)(a1 + 160) && *(_QWORD *)(*(_QWORD *)(a1 + 160) + 64LL) )
      (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 160) + 64LL))(a1, a1 + 168);
    if ( *(_QWORD *)(a1 + 408) && *(_QWORD *)(*(_QWORD *)(a1 + 408) + 56LL) )
      (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 408) + 56LL))(a1, a1 + 416);
    if ( *(_QWORD *)(a1 + 448) && *(_QWORD *)(*(_QWORD *)(a1 + 448) + 40LL) )
      (*(void ( **)(__int64, signed __int64, __int64))(*(_QWORD *)(a1 + 448) + 40LL))(a1, 1LL, a1 + 456);
    if ( *(_QWORD *)(a1 + 424) && *(_QWORD *)(*(_QWORD *)(a1 + 424) + 32LL) )
      (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 424) + 32LL))(a1, a1 + 440);
    if ( *(_QWORD *)(a1 + 296) && *(_QWORD *)(*(_QWORD *)(a1 + 296) + 56LL) )
      (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 296) + 56LL))(a1, a1 + 304);
    if ( *(_QWORD *)(a1 + 336) && *(_QWORD *)(*(_QWORD *)(a1 + 336) + 40LL) )
      (*(void ( **)(__int64, _QWORD, __int64))(*(_QWORD *)(a1 + 336) + 40LL))(a1, 0LL, a1 + 344);
    if ( *(_QWORD *)(a1 + 312) && *(_QWORD *)(*(_QWORD *)(a1 + 312) + 32LL) )
      (*(void ( **)(__int64, __int64))(*(_QWORD *)(a1 + 312) + 32LL))(a1, a1 + 328);
    if ( *(_QWORD *)(a1 + 136) )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 136), a1);
  }
  if ( *(_QWORD *)(a1 + 272) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 272), a1);
  if ( *(_QWORD *)(a1 + 384) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 384), a1);
  if ( *(_QWORD *)(a1 + 88) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 88), a1);
  if ( *(_QWORD *)(a1 + 96) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 96), a1);
  if ( *(_QWORD *)(a1 + 392) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 392), a1);
  if ( *(_QWORD *)(a1 + 464) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 464), a1);
  if ( *(_QWORD *)(a1 + 472) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 472), a1);
  if ( *(_QWORD *)(a1 + 480) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 480), a1);
  if ( *(_QWORD *)(a1 + 488) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 488), a1);
  if ( *(_QWORD *)(a1 + 280) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 280), a1);
  if ( *(_QWORD *)(a1 + 352) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 352), a1);
  if ( *(_QWORD *)(a1 + 360) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 360), a1);
  if ( *(_QWORD *)(a1 + 368) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 368), a1);
  if ( *(_QWORD *)(a1 + 376) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 376), a1);
  if ( *(_QWORD *)(a1 + 52344) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 52344), a1);
  if ( *(_QWORD *)(a1 + 52368) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 52368), a1);
  if ( *(_QWORD *)(a1 + 53400) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53400), a1);
  if ( *(_QWORD *)(a1 + 53432) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
  if ( *(_QWORD *)(a1 + 53456) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53456), a1);
  if ( *(_QWORD *)(a1 + 53504) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53504), a1);
  if ( *(_QWORD *)(a1 + 53520) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53520), a1);
  if ( *(_QWORD *)(a1 + 53488) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53488), a1);
  if ( *(_QWORD *)(a1 + 53560) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
  if ( *(_QWORD *)(a1 + 53576) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
  if ( *(_QWORD *)(a1 + 53592) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
  if ( *(_QWORD *)(a1 + 53640) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
  if ( *(_QWORD *)(a1 + 53656) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53656), a1);
  if ( *(_QWORD *)(a1 + 53696) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53696), a1);
  if ( *(_QWORD *)(a1 + 53760) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53760), a1);
  if ( *(_QWORD *)(a1 + 53776) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53776), a1);
  if ( *(_QWORD *)(a1 + 53800) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53800), a1);
  if ( *(_QWORD *)(a1 + 53840) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53840), a1);
  if ( *(_QWORD *)(a1 + 53888) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53888), a1);
  if ( *(_QWORD *)(a1 + 54208) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54208), a1);
  if ( *(_QWORD *)(a1 + 54536) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54536), a1);
  if ( *(_QWORD *)(a1 + 54168) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54168), a1);
  if ( *(_QWORD *)(a1 + 17008) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 17016), a1);
  while ( 1 )
  {
    v5 = _libssh2_list_first(a1 + 496);
    if ( !v5 )
      break;
    ++v2;
    _libssh2_list_remove(v5);
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v5 + 24), a1);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v5, a1);
  }
  if ( *(_DWORD *)(a1 + 564) )
    sub_3466D(*(_DWORD *)(a1 + 552), 0);
  if ( *(_QWORD *)(a1 + 176) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 176), a1);
  if ( *(_QWORD *)(a1 + 568) )
  {
    if ( *(_DWORD *)(a1 + 580) & 1 )
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 568), a1);
  }
  (*(void ( **)(__int64, __int64))(a1 + 24))(a1, a1);
  return 0LL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8CC0: using guessed type __int64  _libssh2_channel_free(_QWORD);
// 9300: using guessed type __int64  _libssh2_channel_forward_cancel(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (0000000000035CF6) ----------------------------------------------------
__int64  libssh2_session_free(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  v3 = time(0LL);
  do
  {
    v2 = sub_351F3(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v2 = _libssh2_wait_socket(a1, v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000035D54) ----------------------------------------------------
__int64  sub_35D54(__int64 a1, unsigned int a2, const char *a3, char *a4)
{
  char *v5; // [rsp+0h] [rbp-50h]
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  size_t v8; // [rsp+38h] [rbp-18h]
  size_t v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  s = (char *)a3;
  v5 = a4;
  v10 = __readfsqword(0x28u);
  v8 = 0LL;
  v9 = 0LL;
  if ( !*(_DWORD *)(a1 + 53100) )
  {
    if ( a3 )
      v8 = strlen(a3);
    if ( v5 )
      v9 = strlen(v5);
    if ( v8 > 0x100 )
      return _libssh2_error(a1, 4294967262LL, "too long description");
    *(_QWORD *)(a1 + 53376) = v8 + v9 + 13;
    v7 = a1 + 53105;
    *(_BYTE *)(a1 + 53104) = 1;
    _libssh2_store_u32(&v7, a2);
    _libssh2_store_str(&v7, s, v8);
    _libssh2_store_u32(&v7, (unsigned int)v9);
    *(_DWORD *)(a1 + 53100) = 2;
  }
  if ( (unsigned int)_libssh2_transport_send(a1, a1 + 53104, *(_QWORD *)(a1 + 53376), v5, v9) == -37 )
    return 4294967259LL;
  *(_DWORD *)(a1 + 53100) = 0;
  return 0LL;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000035ED6) ----------------------------------------------------
__int64  libssh2_session_disconnect_ex(__int64 a1, unsigned int a2, const char *a3, char *a4)
{
  char *v5; // [rsp+0h] [rbp-30h]
  const char *v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  *(_DWORD *)(a1 + 104) &= 0xFFFFFFFE;
  v8 = time(0LL);
  do
  {
    v7 = sub_35D54(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v7 = _libssh2_wait_socket(a1, v8);
  }
  while ( !v7 );
  return v7;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000035F5D) ----------------------------------------------------
void * libssh2_session_methods(_QWORD *a1, unsigned int a2)
{
  void *result; // rax
  void **v3; // [rsp+18h] [rbp-8h]

  switch ( (unsigned __int64)a2 )
  {
    case 0uLL:
      v3 = (void **)a1[15];
      goto LABEL_13;
    case 1uLL:
      v3 = (void **)a1[20];
      goto LABEL_13;
    case 2uLL:
      v3 = (void **)a1[51];
      goto LABEL_13;
    case 3uLL:
      v3 = (void **)a1[37];
      goto LABEL_13;
    case 4uLL:
      v3 = (void **)a1[53];
      goto LABEL_13;
    case 5uLL:
      v3 = (void **)a1[39];
      goto LABEL_13;
    case 6uLL:
      v3 = (void **)a1[56];
      goto LABEL_13;
    case 7uLL:
      v3 = (void **)a1[42];
LABEL_13:
      if ( v3 )
      {
        result = *v3;
      }
      else
      {
        _libssh2_error(a1, 4294967279LL, "No method negotiated");
        result = 0LL;
      }
      break;
    case 8uLL:
      result = &unk_48EAB;
      break;
    case 9uLL:
      result = &unk_48EAB;
      break;
    default:
      _libssh2_error(a1, 4294967262LL, "Invalid parameter specified for method_type");
      result = 0LL;
      break;
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);

//----- (0000000000036090) ----------------------------------------------------
__int64  libssh2_session_abstract(__int64 a1)
{
  return a1;
}

//----- (000000000003609E) ----------------------------------------------------
__int64  libssh2_session_last_error(__int64 a1, void **a2, _DWORD *a3, int a4)
{
  __int64 result; // rax
  const char *v5; // rax
  int v6; // [rsp+4h] [rbp-2Ch]
  _DWORD *v7; // [rsp+8h] [rbp-28h]
  size_t n; // [rsp+20h] [rbp-10h]
  char *s; // [rsp+28h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  LODWORD(n) = 0;
  if ( *(_DWORD *)(a1 + 576) )
  {
    if ( a2 )
    {
      if ( *(_QWORD *)(a1 + 568) )
        v5 = *(const char **)(a1 + 568);
      else
        v5 = (const char *)&unk_48EAB;
      s = (char *)v5;
      n = strlen(v5);
      if ( v6 )
      {
        *a2 = (void *)(*(__int64 ( **)(size_t, __int64))(a1 + 8))(n + 1, a1);
        if ( *a2 )
        {
          memcpy(*a2, s, n);
          *((_BYTE *)*a2 + n) = 0;
        }
      }
      else
      {
        *a2 = s;
      }
    }
    if ( v7 )
      *v7 = n;
    result = *(unsigned int *)(a1 + 576);
  }
  else
  {
    if ( a2 )
    {
      if ( a4 )
      {
        *a2 = (void *)(*(__int64 ( **)(signed __int64, __int64))(a1 + 8))(1LL, a1);
        if ( *a2 )
          *(_BYTE *)*a2 = 0;
      }
      else
      {
        *a2 = &unk_48EAB;
      }
    }
    if ( v7 )
      *v7 = 0;
    result = 0LL;
  }
  return result;
}

//----- (000000000003620B) ----------------------------------------------------
__int64  libssh2_session_last_errno(__int64 a1)
{
  return *(unsigned int *)(a1 + 576);
}

//----- (000000000003621F) ----------------------------------------------------
__int64  libssh2_session_set_last_error(__int64 a1, unsigned int a2, __int64 a3)
{
  return _libssh2_error_flags(a1, a2, a3, 1LL);
}
// 8FA0: using guessed type __int64  _libssh2_error_flags(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000003624C) ----------------------------------------------------
signed __int64  libssh2_session_flag(__int64 a1, int a2, int a3)
{
  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 108) = a3;
  }
  else
  {
    if ( a2 != 2 )
      return 4294967262LL;
    *(_DWORD *)(a1 + 112) = a3;
  }
  return 0LL;
}



//----- (00000000000362B9) ----------------------------------------------------
__int64  libssh2_session_set_blocking(__int64 a1, unsigned int a2)
{
  return _libssh2_session_set_blocking(a1, a2);
}
// 98D0: using guessed type __int64  _libssh2_session_set_blocking(_QWORD, _QWORD);

//----- (00000000000362DC) ----------------------------------------------------
__int64  libssh2_session_get_blocking(__int64 a1)
{
  return *(unsigned int *)(a1 + 148);
}

//----- (00000000000362F0) ----------------------------------------------------
__int64  libssh2_session_set_timeout(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 152) = a2;
  return result;
}

//----- (000000000003630E) ----------------------------------------------------
__int64  libssh2_session_get_timeout(__int64 a1)
{
  return *(_QWORD *)(a1 + 152);
}

//----- (0000000000036323) ----------------------------------------------------
__int64  libssh2_poll_channel_read(__int64 a1, int a2)
{
  int v3; // ebx
  __int64 i; // [rsp+10h] [rbp-20h]
  __int64 v5; // [rsp+18h] [rbp-18h]

  if ( !a1 )
    return 4294967257LL;
  v5 = *(_QWORD *)(a1 + 96);
  for ( i = _libssh2_list_first(v5 + 496); i; i = _libssh2_list_next(i) )
  {
    if ( *(_QWORD *)(i + 32) <= 4uLL )
      return _libssh2_error(v5, 4294967258LL, "Packet too small");
    v3 = *(_DWORD *)(a1 + 48);
    if ( v3 == (unsigned int)_libssh2_ntohu32(*(_QWORD *)(i + 24) + 1LL) )
    {
      if ( a2 == 1 && (**(_BYTE **)(i + 24) == 95 || **(_BYTE **)(i + 24) == 94) )
        return 1LL;
      if ( !a2 && **(_BYTE **)(i + 24) == 94 )
        return 1LL;
    }
  }
  return 0LL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (0000000000036423) ----------------------------------------------------
_BOOL4  sub_36423(__int64 a1)
{
  return *(_DWORD *)(a1 + 56) != 0;
}

//----- (000000000003643C) ----------------------------------------------------
_BOOL4  sub_3643C(__int64 a1)
{
  return _libssh2_list_first(a1 + 48) != 0;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);

//----- (0000000000036463) ----------------------------------------------------
signed __int64  libssh2_poll(__int64 a1, unsigned int a2, __int64 a3)
{
  int v4; // eax
  int v5; // eax
  signed int v6; // esi
  signed int v7; // esi
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rdx
  int v11; // ST2C_4
  int v12; // eax
  __int64 v13; // rdx
  __int64 v14; // rdx
  unsigned int nfds; // [rsp+14h] [rbp-85Ch]
  unsigned int i; // [rsp+24h] [rbp-84Ch]
  unsigned int j; // [rsp+24h] [rbp-84Ch]
  unsigned int k; // [rsp+24h] [rbp-84Ch]
  unsigned int v19; // [rsp+28h] [rbp-848h]
  __int64 timeout; // [rsp+30h] [rbp-840h]
  __int64 v21; // [rsp+38h] [rbp-838h]
  struct timeval tv; // [rsp+40h] [rbp-830h]
  struct timeval v23; // [rsp+50h] [rbp-820h]
  struct pollfd fds[257]; // [rsp+60h] [rbp-810h]
  unsigned __int64 v25; // [rsp+868h] [rbp-8h]

  nfds = a2;
  v25 = __readfsqword(0x28u);
  v21 = 0LL;
  if ( a2 > 0x100 )
    return 0xFFFFFFFFLL;
  for ( i = 0; ; ++i )
  {
    if ( i >= a2 )
    {
      timeout = a3;
      do
      {
        v19 = 0;
        for ( j = 0; j < nfds; ++j )
        {
          if ( *(_QWORD *)(32LL * j + a1 + 16) != *(_QWORD *)(32LL * j + a1 + 24) )
          {
            v5 = *(unsigned __int8 *)(32LL * j + a1);
            if ( v5 == 2 )
            {
              if ( *(_QWORD *)(32LL * j + a1 + 16) & 1LL && !(*(_QWORD *)(32LL * j + a1 + 24) & 1LL) )
                *(_QWORD *)(32LL * j + a1 + 24) |= (unsigned int)libssh2_poll_channel_read(
                                                                   *(_QWORD *)(32LL * j + a1 + 8),
                                                                   0LL) != 0;
              if ( *(_QWORD *)(32LL * j + a1 + 16) & 2LL && !(*(_QWORD *)(32LL * j + a1 + 24) & 2LL) )
              {
                if ( (unsigned int)libssh2_poll_channel_read(*(_QWORD *)(32LL * j + a1 + 8), 1LL) )
                  v6 = 2;
                else
                  v6 = 0;
                *(_QWORD *)(32LL * j + a1 + 24) |= v6;
              }
              if ( *(_QWORD *)(32LL * j + a1 + 16) & 4LL && !(*(_QWORD *)(32LL * j + a1 + 24) & 4LL) )
              {
                if ( (unsigned int)sub_36423(*(_QWORD *)(32LL * j + a1 + 8)) )
                  v7 = 4;
                else
                  v7 = 0;
                *(_QWORD *)(32LL * j + a1 + 24) |= v7;
              }
              if ( *(_BYTE *)(*(_QWORD *)(32LL * j + a1 + 8) + 84LL)
                || *(_BYTE *)(*(_QWORD *)(32LL * j + a1 + 8) + 64LL) )
              {
                v8 = *(_QWORD *)(32LL * j + a1 + 24);
                LOBYTE(v8) = v8 | 0x80;
                *(_QWORD *)(32LL * j + a1 + 24) = v8;
              }
              if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * j + a1 + 8) + 96LL) + 556LL) == -1 )
              {
                v9 = *(_QWORD *)(32LL * j + a1 + 24);
                LOBYTE(v9) = v9 | 0x90;
                *(_QWORD *)(32LL * j + a1 + 24) = v9;
              }
            }
            else if ( v5 == 3 )
            {
              if ( *(_QWORD *)(32LL * j + a1 + 16) & 1LL && !(*(_QWORD *)(32LL * j + a1 + 24) & 1LL) )
                *(_QWORD *)(32LL * j + a1 + 24) |= (unsigned int)sub_3643C(*(_QWORD *)(32LL * j + a1 + 8)) != 0;
              if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * j + a1 + 8) + 24LL) + 556LL) == -1 )
              {
                v10 = *(_QWORD *)(32LL * j + a1 + 24);
                LOBYTE(v10) = v10 | 0x90;
                *(_QWORD *)(32LL * j + a1 + 24) = v10;
              }
            }
          }
          if ( *(_QWORD *)(32LL * j + a1 + 24) )
            ++v19;
        }
        if ( v19 )
          timeout = 0LL;
        gettimeofday(&tv, 0LL);
        v11 = poll(fds, nfds, timeout);
        gettimeofday(&v23, 0LL);
        timeout += ((v23.tv_usec - tv.tv_usec) >> 63)
                 - ((signed __int64)((unsigned __int128)(2361183241434822607LL
                                                       * (signed __int128)(v23.tv_usec - tv.tv_usec)) >> 64) >> 7)
                 + -1000 * (v23.tv_sec - tv.tv_sec);
        if ( v11 > 0 )
        {
          for ( k = 0; k < nfds; ++k )
          {
            v12 = *(unsigned __int8 *)(32LL * k + a1);
            switch ( v12 )
            {
              case 2:
                if ( fds[k].events & 1 )
                {
                  while ( (signed int)_libssh2_transport_read(*(_QWORD *)(*(_QWORD *)(32LL * k + a1 + 8) + 96LL)) > 0 )
                    ;
                }
                if ( fds[k].revents & 0x10 )
                {
                  v13 = *(_QWORD *)(32LL * k + a1 + 24);
                  LOBYTE(v13) = v13 | 0x90;
                  *(_QWORD *)(32LL * k + a1 + 24) = v13;
                }
                fds[k].revents = 0;
                break;
              case 3:
                if ( fds[k].events & 1 )
                {
                  while ( (signed int)_libssh2_transport_read(*(_QWORD *)(*(_QWORD *)(32LL * k + a1 + 8) + 24LL)) > 0 )
                    ;
                }
                if ( fds[k].revents & 0x10 )
                {
                  v14 = *(_QWORD *)(32LL * k + a1 + 24);
                  LOBYTE(v14) = v14 | 0x90;
                  *(_QWORD *)(32LL * k + a1 + 24) = v14;
                }
                fds[k].revents = 0;
                break;
              case 1:
                *(_QWORD *)(32LL * k + a1 + 24) = fds[k].revents;
                fds[k].revents = 0;
                if ( *(_QWORD *)(32LL * k + a1 + 24) )
                  ++v19;
                break;
            }
          }
        }
      }
      while ( timeout > 0 && !v19 );
      return v19;
    }
    *(_QWORD *)(32LL * i + a1 + 24) = 0LL;
    v4 = *(unsigned __int8 *)(32LL * i + a1);
    if ( v4 != 2 )
      break;
    fds[i].fd = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * i + a1 + 8) + 96LL) + 552LL);
    fds[i].events = 1;
    fds[i].revents = 0;
    if ( !v21 )
      v21 = *(_QWORD *)(*(_QWORD *)(32LL * i + a1 + 8) + 96LL);
LABEL_15:
    ;
  }
  if ( v4 == 3 )
  {
    fds[i].fd = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(32LL * i + a1 + 8) + 24LL) + 552LL);
    fds[i].events = 1;
    fds[i].revents = 0;
    if ( !v21 )
      v21 = *(_QWORD *)(*(_QWORD *)(32LL * i + a1 + 8) + 24LL);
    goto LABEL_15;
  }
  if ( v4 == 1 )
  {
    fds[i].fd = *(_DWORD *)(32LL * i + a1 + 8);
    fds[i].events = *(_QWORD *)(32LL * i + a1 + 16);
    fds[i].revents = 0;
    goto LABEL_15;
  }
  if ( v21 )
    _libssh2_error(v21, 4294967261LL, "Invalid descriptor passed to libssh2_poll()");
  return 0xFFFFFFFFLL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9430: using guessed type __int64  _libssh2_transport_read(_QWORD);
// 9870: using guessed type __int64  libssh2_poll_channel_read(_QWORD, _QWORD);
// 36463: using guessed type struct pollfd fds[257];

//----- (0000000000036EF5) ----------------------------------------------------
__int64  libssh2_session_block_directions(__int64 a1)
{
  return *(unsigned int *)(a1 + 560);
}

//----- (0000000000036F09) ----------------------------------------------------
__int64  libssh2_session_banner_get(__int64 a1)
{
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 272) )
    return *(_QWORD *)(a1 + 272);
  return 0LL;
}

//----- (0000000000036F43) ----------------------------------------------------
__int64  sub_36F43(char a1)
{
  return (a1 & 4) + (4 * a1 & 8) + (8 * a1 & 8) + 4 + (a1 & 8u);
}

//----- (0000000000036F78) ----------------------------------------------------
_QWORD * sub_36F78(_BYTE **a1, __int64 a2)
{
  _BYTE *v2; // ST18_8
  _QWORD *result; // rax

  v2 = *a1;
  *v2 = HIBYTE(a2);
  v2[1] = BYTE6(a2);
  v2[2] = BYTE5(a2);
  v2[3] = BYTE4(a2);
  v2[4] = BYTE3(a2);
  v2[5] = BYTE2(a2);
  v2[6] = BYTE1(a2);
  v2[7] = a2;
  result = a1;
  *result += 8LL;
  return result;
}

//----- (000000000003703B) ----------------------------------------------------
__int64  sub_3703B(__int64 a1, int a2)
{
  __int64 i; // [rsp+18h] [rbp-8h]

  for ( i = _libssh2_list_first(a1 + 32); i && a2 != *(_DWORD *)(i + 24); i = _libssh2_list_next(i) )
    ;
  return i;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);

//----- (000000000003708C) ----------------------------------------------------
__int64  sub_3708C(__int64 a1, int a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  result = sub_3703B(a1, a2);
  v4 = result;
  if ( result )
  {
    _libssh2_list_remove(result);
    result = (*(__int64 ( **)(__int64, __int64))(v3 + 24))(v4, v3);
  }
  return result;
}
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (00000000000370ED) ----------------------------------------------------
__int64  sub_370ED(__int64 a1, int a2)
{
  __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v4 = (*(__int64 ( **)(signed __int64, _QWORD))(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 8LL))(
         32LL,
         *(_QWORD *)(*(_QWORD *)a1 + 96LL));
  if ( !v4 )
    return _libssh2_error(v3, 4294967290LL, "malloc fail for zombie request  ID");
  *(_DWORD *)(v4 + 24) = a2;
  _libssh2_list_add(a1 + 32, v4);
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (000000000003717C) ----------------------------------------------------
__int64  sub_3717C(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  __int64 result; // rax
  signed int v4; // eax
  unsigned __int64 v5; // [rsp+8h] [rbp-38h]
  int v6; // [rsp+2Ch] [rbp-14h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  __int64 v8; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v7 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( a3 <= 4 )
    return 4294967255LL;
  v4 = (unsigned __int8)*a2;
  if ( v4 <= 105 )
  {
    if ( v4 >= 101 || (unsigned int)(v4 - 1) <= 0x13 )
      goto LABEL_9;
    return _libssh2_error(v7, 4294967265LL, "Out of sync with the world");
  }
  if ( (unsigned int)(v4 - 200) > 1 )
    return _libssh2_error(v7, 4294967265LL, "Out of sync with the world");
LABEL_9:
  v6 = _libssh2_ntohu32(a2 + 1);
  if ( (*a2 == 101 || *a2 == 103) && sub_3703B(a1, v6) )
  {
    (*(void ( **)(_BYTE *, __int64))(v7 + 24))(a2, v7);
    sub_3708C(a1, v6);
    result = 0LL;
  }
  else
  {
    v8 = (*(__int64 ( **)(signed __int64, __int64))(v7 + 8))(48LL, v7);
    if ( v8 )
    {
      *(_QWORD *)(v8 + 32) = a2;
      *(_QWORD *)(v8 + 40) = v5;
      *(_DWORD *)(v8 + 24) = v6;
      _libssh2_list_add(a1 + 16, v8);
      result = 0LL;
    }
    else
    {
      result = _libssh2_error(v7, 4294967290LL, "Unable to allocate datablock for SFTP packet");
    }
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (00000000000372E0) ----------------------------------------------------
__int64  sub_372E0(__int64 a1)
{
  int v1; // eax
  signed int v3; // edx
  int v4; // eax
  unsigned int v5; // [rsp+14h] [rbp-2Ch]
  _BYTE *v6; // [rsp+18h] [rbp-28h]
  __int64 v7; // [rsp+20h] [rbp-20h]
  __int64 v8; // [rsp+28h] [rbp-18h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+30h] [rbp-10h]
  __int64 v11; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+30h] [rbp-10h]

  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v6 = 0LL;
  v1 = *(_DWORD *)(a1 + 152);
  if ( v1 == 3 )
  {
    *(_DWORD *)(a1 + 152) = 0;
    v6 = *(_BYTE **)(a1 + 80);
LABEL_20:
    if ( libssh2_channel_window_read_ex(v7, 0LL, 0LL) >= (unsigned __int64)*(unsigned int *)(a1 + 88) )
      goto LABEL_31;
    v10 = (signed int)_libssh2_channel_receive_window_adjust(v7, (unsigned int)(2 * *(_DWORD *)(a1 + 88)), 1LL);
    v3 = v10 == -37 ? 3 : 0;
    *(_DWORD *)(a1 + 152) = v3;
    if ( v10 != -37 )
      goto LABEL_31;
    return -37LL;
  }
  if ( v1 == 4 )
  {
    *(_DWORD *)(a1 + 152) = 0;
    v6 = *(_BYTE **)(a1 + 80);
  }
  if ( !v6 )
  {
    v9 = _libssh2_channel_read(v7, 0LL, *(_QWORD *)(a1 + 72) + 64LL + a1 + 4, 4LL - *(_QWORD *)(a1 + 72));
    if ( v9 == -37 )
      return -37LL;
    if ( v9 < 0 )
      return _libssh2_error(v8, (unsigned int)v9, "channel read");
    *(_QWORD *)(a1 + 72) += v9;
    if ( *(_QWORD *)(a1 + 72) != 4LL )
      return 4294967259LL;
    *(_DWORD *)(a1 + 88) = _libssh2_ntohu32(a1 + 68);
    if ( *(_DWORD *)(a1 + 88) > (unsigned int)&loc_40000 )
    {
      libssh2_channel_flush_ex(v7, 0LL);
      *(_QWORD *)(a1 + 72) = 0LL;
      return _libssh2_error(v8, 4294967271LL, "SFTP packet too large");
    }
    if ( !*(_DWORD *)(a1 + 88) )
      return _libssh2_error(v8, 4294967290LL, "Unable to allocate empty SFTP packet");
    v6 = (_BYTE *)(*(__int64 ( **)(_QWORD, __int64))(v8 + 8))(*(unsigned int *)(a1 + 88), v8);
    if ( !v6 )
      return _libssh2_error(v8, 4294967290LL, "Unable to allocate SFTP packet");
    *(_QWORD *)(a1 + 72) = 0LL;
    *(_QWORD *)(a1 + 96) = 0LL;
    *(_QWORD *)(a1 + 80) = v6;
    goto LABEL_20;
  }
LABEL_31:
  while ( (unsigned __int64)*(unsigned int *)(a1 + 88) > *(_QWORD *)(a1 + 96) )
  {
    v11 = _libssh2_channel_read(v7, 0LL, &v6[*(_QWORD *)(a1 + 96)], *(unsigned int *)(a1 + 88) - *(_QWORD *)(a1 + 96));
    if ( v11 == -37 )
    {
      *(_DWORD *)(a1 + 152) = 4;
      return -37LL;
    }
    if ( v11 < 0 )
    {
      (*(void ( **)(_BYTE *, __int64))(v8 + 24))(v6, v8);
      *(_QWORD *)(a1 + 80) = 0LL;
      return _libssh2_error(v8, (unsigned int)v11, "Error waiting for SFTP packet");
    }
    *(_QWORD *)(a1 + 96) += v11;
  }
  *(_QWORD *)(a1 + 80) = 0LL;
  v5 = (unsigned __int8)*v6;
  v4 = sub_3717C(a1, v6, *(unsigned int *)(a1 + 88));
  v12 = v4;
  if ( !v4 )
    return v5;
  (*(void ( **)(_BYTE *, __int64))(v8 + 24))(v6, v8);
  return v12;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8F40: using guessed type __int64  libssh2_channel_flush_ex(_QWORD, _QWORD);
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9140: using guessed type __int64  libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 97F0: using guessed type __int64  _libssh2_channel_read(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000376BA) ----------------------------------------------------
unsigned __int64  sub_376BA(__int64 a1)
{
  int v2; // [rsp+14h] [rbp-3Ch]
  __int64 v3; // [rsp+18h] [rbp-38h]
  char v4; // [rsp+20h] [rbp-30h]
  __int64 i; // [rsp+28h] [rbp-28h]
  __int64 v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(_QWORD *)(*(_QWORD *)v6 + 96LL);
  for ( i = _libssh2_list_first(a1 + 376); i; i = v8 )
  {
    v8 = _libssh2_list_next(i);
    v2 = sub_377FD(v6, 101, *(_DWORD *)(i + 56), &v3, &v4);
    if ( v2 )
      v2 = sub_377FD(v6, 103, *(_DWORD *)(i + 56), &v3, &v4);
    if ( v2 )
    {
      if ( *(_QWORD *)(i + 40) )
        sub_370ED(v6, *(_DWORD *)(i + 56));
    }
    else
    {
      (*(void ( **)(__int64, __int64))(v7 + 24))(v3, v7);
    }
    _libssh2_list_remove(i);
    (*(void ( **)(__int64, __int64))(v7 + 24))(i, v7);
  }
  return __readfsqword(0x28u) ^ v9;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (00000000000377FD) ----------------------------------------------------
signed __int64  sub_377FD(__int64 a1, char a2, int a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-30h]
  _QWORD *v7; // [rsp+8h] [rbp-28h]
  int v8; // [rsp+10h] [rbp-20h]
  __int64 v9; // [rsp+20h] [rbp-10h]
  __int64 v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v9 = _libssh2_list_first(a1 + 16);
  if ( !v9 )
    return 0xFFFFFFFFLL;
  while ( v9 )
  {
    if ( a2 == **(_BYTE **)(v9 + 32) && (a2 == 2 || v8 == *(_DWORD *)(v9 + 24)) )
    {
      *v7 = *(_QWORD *)(v9 + 32);
      *v6 = *(_QWORD *)(v9 + 40);
      _libssh2_list_remove(v9);
      (*(void ( **)(__int64, __int64))(v10 + 24))(v9, v10);
      return 0LL;
    }
    v9 = _libssh2_list_next(v9);
  }
  return 0xFFFFFFFFLL;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (00000000000378DE) ----------------------------------------------------
signed __int64  sub_378DE(__int64 a1, char a2, int a3, _QWORD *a4, unsigned __int64 *a5, unsigned __int64 a6)
{
  signed __int64 result; // rax
  unsigned __int64 v7; // [rsp+8h] [rbp-38h]
  unsigned __int64 *v8; // [rsp+10h] [rbp-30h]
  _QWORD *v9; // [rsp+18h] [rbp-28h]
  int v10; // [rsp+20h] [rbp-20h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  __int64 v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v12 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  if ( !a4 || !a5 || !a6 )
    return 4294967257LL;
  if ( (unsigned int)sub_377FD(a1, a2, a3, a4, a5) )
  {
    do
    {
      if ( *(_DWORD *)(v12 + 556) )
        return 4294967283LL;
      v11 = sub_372E0(a1);
      if ( (v11 & 0x80000000) != 0 )
        return v11;
    }
    while ( (unsigned int)sub_377FD(a1, a2, v10, v9, v8) );
    if ( v7 <= *v8 )
      result = 0LL;
    else
      result = 4294967258LL;
  }
  else if ( v7 <= *v8 )
  {
    result = 0LL;
  }
  else
  {
    result = 4294967258LL;
  }
  return result;
}

//----- (00000000000379D5) ----------------------------------------------------
signed __int64  sub_379D5(_QWORD *a1, int a2, __int64 a3, int a4, _QWORD *a5, unsigned __int64 *a6, unsigned __int64 a7)
{
  signed __int64 result; // rax
  unsigned __int64 *v8; // [rsp+8h] [rbp-38h]
  _QWORD *v9; // [rsp+10h] [rbp-30h]
  __int64 v10; // [rsp+18h] [rbp-28h]
  int v11; // [rsp+20h] [rbp-20h]
  int i; // [rsp+30h] [rbp-10h]
  signed int v13; // [rsp+34h] [rbp-Ch]

  v10 = a3;
  v11 = a4;
  v9 = a5;
  v8 = a6;
  if ( !a5 || !a6 || !a7 )
    return 4294967257LL;
  if ( !a1[13] )
    a1[13] = time(0LL);
  while ( !*(_DWORD *)(*(_QWORD *)(*a1 + 96LL) + 556LL) )
  {
    for ( i = 0; i < a2; ++i )
    {
      if ( !(unsigned int)sub_377FD((__int64)a1, *(_BYTE *)(i + v10), v11, v9, v8) )
      {
        a1[13] = 0LL;
        if ( a7 <= *v8 )
          result = 0LL;
        else
          result = 4294967258LL;
        return result;
      }
    }
    v13 = sub_372E0((__int64)a1);
    if ( v13 < 0 && v13 != -37 )
    {
      a1[13] = 0LL;
      return (unsigned int)v13;
    }
    if ( v13 <= 0 )
    {
      if ( 60 - (time(0LL) - a1[13]) <= 0 )
      {
        a1[13] = 0LL;
        return 4294967287LL;
      }
      if ( v13 == -37 )
        return 4294967259LL;
    }
  }
  a1[13] = 0LL;
  return 4294967283LL;
}

//----- (0000000000037B5D) ----------------------------------------------------
__int64  sub_37B5D(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+20h] [rbp-10h]
  unsigned __int64 v4; // [rsp+28h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v3 = a1;
  if ( a2 )
  {
    _libssh2_store_u32(&v3, *a2 & 0xFLL);
    if ( *a2 & 1LL )
      sub_36F78((_BYTE **)&v3, a2[1]);
    if ( *a2 & 2LL )
    {
      _libssh2_store_u32(&v3, (unsigned int)a2[2]);
      _libssh2_store_u32(&v3, (unsigned int)a2[3]);
    }
    if ( *a2 & 4LL )
      _libssh2_store_u32(&v3, (unsigned int)a2[4]);
    if ( *a2 & 8LL )
    {
      _libssh2_store_u32(&v3, (unsigned int)a2[5]);
      _libssh2_store_u32(&v3, (unsigned int)a2[6]);
    }
    result = v3 - a1;
  }
  else
  {
    _libssh2_htonu32(v3, 0LL);
    result = 4LL;
  }
  return result;
}
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000037CB9) ----------------------------------------------------
__int64  sub_37CB9(_QWORD *a1, __int64 a2, __int64 a3)
{
  unsigned int v4; // [rsp+24h] [rbp-2Ch]
  unsigned int v5; // [rsp+28h] [rbp-28h]
  unsigned int v6; // [rsp+2Ch] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  __int64 v8; // [rsp+38h] [rbp-18h]
  __int64 v9; // [rsp+40h] [rbp-10h]
  unsigned __int64 v10; // [rsp+48h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v4 = 0;
  v7 = a2;
  v8 = a2;
  v9 = a3;
  if ( (unsigned int)_libssh2_get_u32(&v7, &v4) )
    return 4294967258LL;
  *a1 = v4;
  if ( *a1 & 1LL && (unsigned int)_libssh2_get_u64(&v7, a1 + 1) )
    return 4294967258LL;
  if ( *a1 & 2LL )
  {
    v5 = 0;
    v6 = 0;
    if ( (unsigned int)_libssh2_get_u32(&v7, &v5) || (unsigned int)_libssh2_get_u32(&v7, &v6) )
      return 4294967258LL;
    a1[2] = v5;
    a1[3] = v6;
  }
  if ( *a1 & 4LL )
  {
    if ( (unsigned int)_libssh2_get_u32(&v7, &v6) )
      return 4294967258LL;
    a1[4] = v6;
  }
  if ( *a1 & 8LL )
  {
    if ( (unsigned int)_libssh2_get_u32(&v7, &v5) || (unsigned int)_libssh2_get_u32(&v7, &v6) )
      return 4294967258LL;
    a1[5] = v5;
    a1[6] = v6;
  }
  return v8 - v7;
}
// 8EE0: using guessed type __int64  _libssh2_get_u64(_QWORD, _QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);

//----- (0000000000037E8A) ----------------------------------------------------
__int64  libssh2_sftp_dtor(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = *a4;
  if ( *(_QWORD *)(*a4 + 80) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v5 + 80), a1);
  if ( *(_QWORD *)(v5 + 184) )
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v5 + 184), a1);
  return (*(__int64 ( **)(__int64, __int64))(a1 + 24))(v5, a1);
}

//----- (0000000000037F20) ----------------------------------------------------
_DWORD * sub_37F20(__int64 a1)
{
  int v2; // [rsp+14h] [rbp-5Ch]
  __int64 v3; // [rsp+18h] [rbp-58h]
  __int64 v4; // [rsp+20h] [rbp-50h]
  char v5; // [rsp+28h] [rbp-48h]
  char v6; // [rsp+30h] [rbp-40h]
  _DWORD *v7; // [rsp+38h] [rbp-38h]
  __int64 v8; // [rsp+40h] [rbp-30h]
  unsigned __int64 v9; // [rsp+48h] [rbp-28h]
  __int64 v10; // [rsp+50h] [rbp-20h]
  unsigned __int64 v11; // [rsp+58h] [rbp-18h]
  __int64 v12; // [rsp+60h] [rbp-10h]
  unsigned __int64 v13; // [rsp+68h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 54164) )
  {
    if ( *(_QWORD *)(a1 + 54168) )
      __assert_fail(
        "session->sftpInit_sftp == NULL",
        "/home/mantovan/Repositories/libssh2/src/sftp.c",
        0x316u,
        "sftp_init");
    *(_QWORD *)(a1 + 54168) = 0LL;
    *(_DWORD *)(a1 + 54164) = 2;
  }
  v7 = *(_DWORD **)(a1 + 54168);
  if ( *(_DWORD *)(a1 + 54164) == 2 )
  {
    *(_QWORD *)(a1 + 54176) = _libssh2_channel_open(a1, "session", 7LL, 0x200000LL, 0x8000LL, 0LL, 0LL);
    if ( !*(_QWORD *)(a1 + 54176) )
    {
      if ( (unsigned int)libssh2_session_last_errno(a1) == -37 )
      {
        _libssh2_error(a1, 4294967259LL, "Would block starting up channel");
      }
      else
      {
        _libssh2_error(a1, 4294967275LL, "Unable to startup channel");
        *(_DWORD *)(a1 + 54164) = 0;
      }
      return 0LL;
    }
    *(_DWORD *)(a1 + 54164) = 3;
  }
  if ( *(_DWORD *)(a1 + 54164) == 3 )
  {
    v2 = _libssh2_channel_process_startup(*(_QWORD *)(a1 + 54176), "subsystem", 9LL, "sftp", 4LL);
    if ( v2 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block to request SFTP subsystem");
      return 0LL;
    }
    if ( v2 )
    {
      _libssh2_error(a1, 4294967275LL, "Unable to request SFTP subsystem");
LABEL_49:
      while ( (unsigned int)_libssh2_channel_free(*(_QWORD *)(a1 + 54176)) == -37 )
        ;
      *(_QWORD *)(a1 + 54176) = 0LL;
      if ( *(_QWORD *)(a1 + 54168) )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 54168), a1);
        *(_QWORD *)(a1 + 54168) = 0LL;
      }
      *(_DWORD *)(a1 + 54164) = 0;
      return 0LL;
    }
    *(_DWORD *)(a1 + 54164) = 4;
  }
  if ( *(_DWORD *)(a1 + 54164) == 4 )
  {
    v8 = (signed int)_libssh2_channel_extended_data(*(_QWORD *)(a1 + 54176), 1LL);
    if ( v8 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block requesting handle extended data");
      return 0LL;
    }
    *(_QWORD *)(a1 + 54168) = _libssh2_calloc(a1, 352LL);
    v7 = *(_DWORD **)(a1 + 54168);
    if ( !v7 )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate a new SFTP structure");
      goto LABEL_49;
    }
    *(_QWORD *)v7 = *(_QWORD *)(a1 + 54176);
    v7[2] = 0;
    _libssh2_htonu32(a1 + 54184, 5LL);
    *(_BYTE *)(a1 + 54188) = 1;
    _libssh2_htonu32(a1 + 54189, 3LL);
    *(_DWORD *)(a1 + 54196) = 0;
    *(_DWORD *)(a1 + 54164) = 5;
  }
  if ( *(_DWORD *)(a1 + 54164) == 5 )
  {
    v8 = _libssh2_channel_write(
           *(_QWORD *)(a1 + 54176),
           0LL,
           a1 + 54184 + *(signed int *)(a1 + 54196),
           9 - *(_DWORD *)(a1 + 54196));
    if ( v8 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block sending SSH_FXP_INIT");
      return 0LL;
    }
    if ( v8 < 0 )
    {
      _libssh2_error(a1, 4294967289LL, "Unable to send SSH_FXP_INIT");
      goto LABEL_49;
    }
    *(_DWORD *)(a1 + 54196) += v8;
    if ( *(_DWORD *)(a1 + 54196) == 9 )
      *(_DWORD *)(a1 + 54164) = 6;
  }
  v8 = (signed int)sub_378DE((__int64)v7, 2, 0, &v3, (unsigned __int64 *)&v4, 5uLL);
  if ( v8 == -37 )
  {
    _libssh2_error(a1, 4294967259LL, "Would block receiving SSH_FXP_VERSION");
    return 0LL;
  }
  if ( v8 == -38 )
  {
    if ( v4 )
      (*(void ( **)(__int64, __int64))(a1 + 24))(v3, a1);
    _libssh2_error(a1, 4294967265LL, "Invalid SSH_FXP_VERSION response");
    goto LABEL_49;
  }
  if ( v8 )
  {
    _libssh2_error(a1, (unsigned int)v8, "Timeout waiting for response from SFTP subsystem");
    goto LABEL_49;
  }
  v10 = v3;
  v11 = v3 + 1;
  v12 = v4;
  v9 = v3 + v4;
  if ( (unsigned int)_libssh2_get_u32(&v10, v7 + 3) )
  {
    (*(void ( **)(__int64, __int64))(a1 + 24))(v3, a1);
    v8 = -38LL;
    goto LABEL_49;
  }
  if ( v7[3] > 3u )
    v7[3] = 3;
  while ( v9 > v11 )
  {
    if ( (unsigned int)_libssh2_get_string(&v10, &v5, 0LL) )
    {
      (*(void ( **)(__int64, __int64))(a1 + 24))(v3, a1);
      _libssh2_error(a1, 4294967258LL, "Data too short when extracting extname");
      goto LABEL_49;
    }
    if ( (unsigned int)_libssh2_get_string(&v10, &v6, 0LL) )
    {
      (*(void ( **)(__int64, __int64))(a1 + 24))(v3, a1);
      _libssh2_error(a1, 4294967258LL, "Data too short when extracting extdata");
      goto LABEL_49;
    }
  }
  (*(void ( **)(__int64, __int64))(a1 + 24))(v3, a1);
  *(_QWORD *)(*(_QWORD *)v7 + 104LL) = v7;
  *(_QWORD *)(*(_QWORD *)v7 + 112LL) = libssh2_sftp_dtor;
  *(_DWORD *)(a1 + 54164) = 0;
  *(_QWORD *)(a1 + 54168) = 0LL;
  *(_QWORD *)(a1 + 54176) = 0LL;
  _libssh2_list_init(v7 + 12);
  return v7;
}
// 8B20: using guessed type __int64  _libssh2_list_init(_QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 8CC0: using guessed type __int64  _libssh2_channel_free(_QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9060: using guessed type __int64  _libssh2_get_u32(_QWORD, _QWORD);
// 9460: using guessed type __int64  _libssh2_channel_process_startup(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 94A0: using guessed type __int64  _libssh2_get_string(_QWORD, _QWORD, _QWORD);
// 94E0: using guessed type __int64  _libssh2_channel_extended_data(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9A60: using guessed type __int64  _libssh2_channel_open(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038627) ----------------------------------------------------
_DWORD * libssh2_sftp_init(__int64 a1)
{
  _DWORD *result; // rax
  time_t v2; // [rsp+20h] [rbp-10h]
  _DWORD *v3; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 104) & 4 )
  {
    v2 = time(0LL);
    do
      v3 = sub_37F20(a1);
    while ( *(_DWORD *)(a1 + 148)
         && !v3
         && (unsigned int)libssh2_session_last_errno(a1) == -37
         && !(unsigned int)_libssh2_wait_socket(a1, v2) );
    result = v3;
  }
  else
  {
    _libssh2_error(a1, 4294967262LL, "session not authenticated yet");
    result = 0LL;
  }
  return result;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000386D7) ----------------------------------------------------
__int64  sub_386D7(_QWORD *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = *(_QWORD *)(*a1 + 96LL);
  if ( a1[10] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[10], v2);
    a1[10] = 0LL;
  }
  if ( a1[15] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[15], v2);
    a1[15] = 0LL;
  }
  if ( a1[23] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[23], v2);
    a1[23] = 0LL;
  }
  if ( a1[25] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[25], v2);
    a1[25] = 0LL;
  }
  if ( a1[27] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[27], v2);
    a1[27] = 0LL;
  }
  if ( a1[29] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[29], v2);
    a1[29] = 0LL;
  }
  if ( a1[32] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[32], v2);
    a1[32] = 0LL;
  }
  if ( a1[34] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[34], v2);
    a1[34] = 0LL;
  }
  if ( a1[36] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[36], v2);
    a1[36] = 0LL;
  }
  if ( a1[38] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[38], v2);
    a1[38] = 0LL;
  }
  if ( a1[40] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[40], v2);
    a1[40] = 0LL;
  }
  if ( a1[42] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[42], v2);
    a1[42] = 0LL;
  }
  if ( a1[21] )
  {
    (*(void ( **)(_QWORD, __int64))(v2 + 24))(a1[21], v2);
    a1[21] = 0LL;
  }
  sub_3B842((__int64)a1);
  return (unsigned int)_libssh2_channel_free(*a1);
}
// 8CC0: using guessed type __int64  _libssh2_channel_free(_QWORD);

//----- (0000000000038A29) ----------------------------------------------------
signed __int64  libssh2_sftp_shutdown(_QWORD *a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_386D7(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*a1 + 96LL) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(*a1 + 96LL), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000038AA3) ----------------------------------------------------
__int64  sub_38AA3(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, int a6)
{
  int v6; // edx
  __int64 result; // rax
  signed __int64 v8; // rax
  char v9; // cl
  char *v10; // rax
  __int64 v11; // rax
  unsigned int v12; // eax
  __int64 v13; // [rsp+8h] [rbp-A8h]
  unsigned int v14; // [rsp+14h] [rbp-9Ch]
  __int64 v15; // [rsp+18h] [rbp-98h]
  signed int v16; // [rsp+30h] [rbp-80h]
  _BOOL4 v17; // [rsp+34h] [rbp-7Ch]
  char *v18; // [rsp+38h] [rbp-78h]
  unsigned __int64 v19; // [rsp+40h] [rbp-70h]
  _BYTE *v20; // [rsp+48h] [rbp-68h]
  __int64 v21; // [rsp+50h] [rbp-60h]
  __int64 v22; // [rsp+58h] [rbp-58h]
  __int64 v23; // [rsp+60h] [rbp-50h]
  __int64 v24; // [rsp+68h] [rbp-48h]
  __int64 v25; // [rsp+70h] [rbp-40h]
  __int64 v26; // [rsp+78h] [rbp-38h]
  __int64 v27; // [rsp+80h] [rbp-30h]
  __int64 v28; // [rsp+88h] [rbp-28h]
  __int64 v29; // [rsp+90h] [rbp-20h]
  __int64 v30; // [rsp+98h] [rbp-18h]
  __int64 v31; // [rsp+A0h] [rbp-10h]
  unsigned __int64 v32; // [rsp+A8h] [rbp-8h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v32 = __readfsqword(0x28u);
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD *)(v21 + 96);
  v25 = 4LL;
  v26 = 0LL;
  v27 = 0LL;
  v28 = 0LL;
  v29 = 0LL;
  v30 = 0LL;
  v31 = 0LL;
  v17 = a6 == 0;
  if ( !*(_DWORD *)(a1 + 112) )
  {
    if ( a6 == 0 )
      v6 = (unsigned __int64)sub_36F43(4) + 4;
    else
      v6 = 0;
    *(_DWORD *)(a1 + 128) = v6 + v15 + 13;
    *(_QWORD *)(a1 + 136) = 0LL;
    *(_QWORD *)(a1 + 120) = (*(__int64 ( **)(_QWORD, __int64))(v22 + 8))(*(unsigned int *)(a1 + 128), v22);
    v18 = *(char **)(a1 + 120);
    if ( !*(_QWORD *)(a1 + 120) )
    {
      _libssh2_error(v22, 4294967290LL, "Unable to allocate memory for FXP_OPEN or FXP_OPENDIR packet");
      return 0LL;
    }
    if ( v17 )
      v8 = 0x8000LL;
    else
      v8 = 0x4000LL;
    v29 = v13 | v8;
    _libssh2_store_u32(&v18, (unsigned int)(*(_DWORD *)(a1 + 128) - 4));
    if ( v17 )
      v9 = 3;
    else
      v9 = 11;
    v10 = v18++;
    *v10 = v9;
    LODWORD(v10) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v10 + 1;
    *(_DWORD *)(a1 + 144) = (_DWORD)v10;
    _libssh2_store_u32(&v18, *(unsigned int *)(a1 + 144));
    _libssh2_store_str(&v18, a2, v15);
    if ( v17 )
    {
      _libssh2_store_u32(&v18, v14);
      v11 = sub_37B5D((__int64)v18, &v25);
      v18 += v11;
    }
    *(_DWORD *)(a1 + 112) = 2;
  }
  if ( *(_DWORD *)(a1 + 112) == 2 )
  {
    v23 = _libssh2_channel_write(
            v21,
            0LL,
            *(_QWORD *)(a1 + 136) + *(_QWORD *)(a1 + 120),
            *(unsigned int *)(a1 + 128) - *(_QWORD *)(a1 + 136));
    if ( v23 == -37 )
    {
      _libssh2_error(v22, 4294967259LL, "Would block sending FXP_OPEN or FXP_OPENDIR command");
      return 0LL;
    }
    if ( v23 < 0 )
    {
      _libssh2_error(v22, (unsigned int)v23, "Unable to send FXP_OPEN*");
      (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 120), v22);
      *(_QWORD *)(a1 + 120) = 0LL;
      *(_DWORD *)(a1 + 112) = 0;
      return 0LL;
    }
    *(_QWORD *)(a1 + 136) += v23;
    if ( *(_DWORD *)(a1 + 128) == *(_QWORD *)(a1 + 136) )
    {
      (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 120), v22);
      *(_QWORD *)(a1 + 120) = 0LL;
      *(_DWORD *)(a1 + 112) = 3;
    }
  }
  if ( *(_DWORD *)(a1 + 112) != 3 )
    return 0LL;
  v23 = (signed int)sub_379D5((_QWORD *)a1, 2, (__int64)"fe", *(_DWORD *)(a1 + 144), &v20, &v19, 1uLL);
  if ( v23 == -37 )
  {
    _libssh2_error(v22, 4294967259LL, "Would block waiting for status message");
    return 0LL;
  }
  if ( v23 == -38 )
  {
    if ( v19 )
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
    _libssh2_error(v22, 4294967265LL, "Response too small");
    return 0LL;
  }
  *(_DWORD *)(a1 + 112) = 0;
  if ( v23 )
  {
    _libssh2_error(v22, (unsigned int)v23, "Timeout waiting for status message");
    return 0LL;
  }
  if ( *v20 == 101 )
  {
    v16 = 1;
    if ( v19 <= 8 )
    {
      _libssh2_error(v22, 4294967265LL, "Too small FXP_STATUS");
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
      return 0LL;
    }
    *(_DWORD *)(a1 + 64) = _libssh2_ntohu32(v20 + 5);
    if ( !*(_DWORD *)(a1 + 64) )
    {
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
      v23 = (signed int)sub_378DE(a1, 102, *(_DWORD *)(a1 + 144), &v20, &v19, 0xAuLL);
      switch ( v23 )
      {
        case -37LL:
          *(_DWORD *)(a1 + 112) = 3;
          return 0LL;
        case -38LL:
          if ( v19 )
            (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
          _libssh2_error(v22, 4294967265LL, "Too small FXP_HANDLE");
          return 0LL;
        case 0LL:
          v16 = 0;
          break;
      }
    }
    if ( v16 )
    {
      _libssh2_error(v22, 4294967265LL, "Failed opening remote file");
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
      return 0LL;
    }
  }
  if ( v19 > 9 )
  {
    v24 = _libssh2_calloc(v22, 392LL);
    if ( v24 )
    {
      *(_DWORD *)(v24 + 296) = !v17;
      v12 = _libssh2_ntohu32(v20 + 5);
      *(_QWORD *)(v24 + 288) = v12;
      if ( *(_QWORD *)(v24 + 288) > 0x100uLL )
        *(_QWORD *)(v24 + 288) = 256LL;
      if ( *(_QWORD *)(v24 + 288) > v19 - 9 )
        *(_QWORD *)(v24 + 288) = v19 - 9;
      memcpy((void *)(v24 + 32), v20 + 9, *(_QWORD *)(v24 + 288));
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
      _libssh2_list_add(a1 + 48, v24);
      *(_QWORD *)(v24 + 24) = a1;
      *(_QWORD *)(v24 + 304) = 0LL;
      *(_QWORD *)(v24 + 312) = 0LL;
      result = v24;
    }
    else
    {
      _libssh2_error(v22, 4294967290LL, "Unable to allocate new SFTP handle structure");
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
      result = 0LL;
    }
  }
  else
  {
    _libssh2_error(v22, 4294967265LL, "Too small FXP_HANDLE");
    (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
    result = 0LL;
  }
  return result;
}
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (00000000000392E1) ----------------------------------------------------
__int64  libssh2_sftp_open_ex(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, int a6)
{
  __int64 v7; // [rsp+8h] [rbp-48h]
  unsigned int v8; // [rsp+10h] [rbp-40h]
  int v9; // [rsp+18h] [rbp-38h]
  unsigned int v10; // [rsp+1Ch] [rbp-34h]
  time_t v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v7 = a5;
  v9 = a6;
  if ( !a1 )
    return 0LL;
  v11 = time(0LL);
  do
    v12 = sub_38AA3(a1, a2, v10, v8, v7, v9);
  while ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL)
       && !v12
       && (unsigned int)libssh2_session_last_errno(*(_QWORD *)(*(_QWORD *)a1 + 96LL)) == -37
       && !(unsigned int)_libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v11) );
  return v12;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000393AE) ----------------------------------------------------
size_t  sub_393AE(__int64 a1, void *a2, unsigned __int64 a3)
{
  int v3; // eax
  size_t v4; // rax
  size_t result; // rax
  _BYTE *v6; // rax
  unsigned __int64 v7; // rax
  __int64 v8; // rax
  int v9; // eax
  unsigned __int64 v10; // [rsp+8h] [rbp-B8h]
  unsigned int v11; // [rsp+28h] [rbp-98h]
  int v12; // [rsp+2Ch] [rbp-94h]
  unsigned int v13; // [rsp+2Ch] [rbp-94h]
  unsigned int v14; // [rsp+30h] [rbp-90h]
  unsigned __int8 *v15; // [rsp+38h] [rbp-88h]
  _BYTE *v16; // [rsp+40h] [rbp-80h]
  unsigned __int64 v17; // [rsp+48h] [rbp-78h]
  __int64 v18; // [rsp+50h] [rbp-70h]
  unsigned __int64 v19; // [rsp+58h] [rbp-68h]
  void *v20; // [rsp+60h] [rbp-60h]
  unsigned __int64 v21; // [rsp+68h] [rbp-58h]
  _QWORD *v22; // [rsp+70h] [rbp-50h]
  __int64 v23; // [rsp+78h] [rbp-48h]
  __int64 v24; // [rsp+80h] [rbp-40h]
  __int64 v25; // [rsp+88h] [rbp-38h]
  unsigned __int64 v26; // [rsp+90h] [rbp-30h]
  unsigned __int64 v27; // [rsp+98h] [rbp-28h]
  __int64 v28; // [rsp+A0h] [rbp-20h]
  size_t n; // [rsp+A8h] [rbp-18h]
  __int64 v30; // [rsp+B0h] [rbp-10h]
  unsigned __int64 v31; // [rsp+B8h] [rbp-8h]

  v10 = a3;
  v31 = __readfsqword(0x28u);
  v22 = *(_QWORD **)(a1 + 24);
  v23 = *v22;
  v24 = *(_QWORD *)(v23 + 96);
  v17 = 0LL;
  v25 = a1 + 304;
  v19 = 0LL;
  v20 = a2;
  v3 = *((_DWORD *)v22 + 37);
  if ( v3 == 3 )
  {
LABEL_35:
    *((_DWORD *)v22 + 37) = 0;
    v18 = _libssh2_list_first(a1 + 376);
    while ( v18 )
    {
      if ( !*(_QWORD *)(v18 + 48) )
        goto LABEL_87;
      v28 = _libssh2_channel_write(v23, 0LL, *(_QWORD *)(v18 + 40) + 48LL + v18 + 12, *(_QWORD *)(v18 + 48));
      if ( v28 < 0 )
      {
        *((_DWORD *)v22 + 37) = 3;
        return v28;
      }
      *(_QWORD *)(v18 + 48) -= v28;
      *(_QWORD *)(v18 + 40) += v28;
      if ( *(_QWORD *)(v18 + 48) )
      {
        v8 = _libssh2_list_first(a1 + 376);
        if ( v18 != v8 )
          goto LABEL_44;
      }
      else
      {
LABEL_87:
        v18 = _libssh2_list_next(v18);
      }
    }
    goto LABEL_44;
  }
  if ( v3 != 5 )
  {
    if ( v3 )
      __assert_fail(
        "!\"State machine error; unrecognised read state\"",
        "/home/mantovan/Repositories/libssh2/src/sftp.c",
        0x6B8u,
        "sftp_read");
    if ( *(_QWORD *)(v25 + 40) )
    {
      v4 = *(_QWORD *)(v25 + 40);
      if ( a3 <= v4 )
        v4 = a3;
      n = v4;
      memcpy(a2, (const void *)(*(_QWORD *)(v25 + 24) + *(_QWORD *)(v25 + 32) - *(_QWORD *)(v25 + 40)), v4);
      *(_QWORD *)(v25 + 40) -= n;
      *(_QWORD *)v25 += n;
      if ( !*(_QWORD *)(v25 + 40) )
      {
        (*(void ( **)(_QWORD, __int64))(v24 + 24))(*(_QWORD *)(v25 + 24), v24);
        *(_QWORD *)(v25 + 24) = 0LL;
      }
      return n;
    }
    if ( *(_BYTE *)(v25 + 48) )
      return 0LL;
    v26 = *(_QWORD *)(v25 + 8) - *(_QWORD *)v25;
    v21 = 4 * a3;
    if ( 4 * a3 > 0x800000 )
      v21 = 0x800000LL;
    if ( v21 > v26 )
      v17 = v21 - v26;
    v27 = libssh2_channel_window_read_ex(*v22, 0LL, 0LL);
    if ( v21 > v27 )
    {
      v28 = (signed int)_libssh2_channel_receive_window_adjust(*v22, (unsigned int)(8 * v21), 1LL);
      if ( v28 == -37 && *(_QWORD *)(v25 + 40) )
        __assert_fail(
          "rc != LIBSSH2_ERROR_EAGAIN || !filep->data_left",
          "/home/mantovan/Repositories/libssh2/src/sftp.c",
          0x5B3u,
          "sftp_read");
      if ( v28 == -37 && *(_BYTE *)(v25 + 48) )
        __assert_fail(
          "rc != LIBSSH2_ERROR_EAGAIN || !filep->eof",
          "/home/mantovan/Repositories/libssh2/src/sftp.c",
          0x5B4u,
          "sftp_read");
      if ( v28 )
        return v28;
    }
    while ( v17 )
    {
      v14 = *(unsigned __int64 *)(a1 + 288) + 25;
      v11 = v17;
      if ( v10 > (unsigned int)v17 )
        v11 = v10;
      if ( v11 > 0x7530 )
        v11 = 30000;
      v18 = (*(__int64 ( **)(signed __int64, __int64))(v24 + 8))(v14 + 64LL, v24);
      if ( !v18 )
        return (signed int)_libssh2_error(v24, 4294967290LL, "malloc fail for FXP_WRITE");
      *(_QWORD *)(v18 + 24) = *(_QWORD *)(v25 + 8);
      *(_QWORD *)(v18 + 32) = v11;
      *(_QWORD *)(v18 + 48) = v14;
      *(_QWORD *)(v18 + 40) = 0LL;
      v16 = (_BYTE *)(v18 + 60);
      _libssh2_store_u32(&v16, v14 - 4);
      v6 = v16++;
      *v6 = 5;
      LODWORD(v6) = *((_DWORD *)v22 + 2);
      *((_DWORD *)v22 + 2) = (_DWORD)v6 + 1;
      *(_DWORD *)(v18 + 56) = (_DWORD)v6;
      _libssh2_store_u32(&v16, (unsigned int)v6);
      _libssh2_store_str(&v16, a1 + 32, *(_QWORD *)(a1 + 288));
      sub_36F78(&v16, *(_QWORD *)(v25 + 8));
      *(_QWORD *)(v25 + 8) += v11;
      _libssh2_store_u32(&v16, v11);
      _libssh2_list_add(a1 + 376, v18);
      v7 = v11;
      if ( v17 <= v11 )
        v7 = v17;
      v17 -= v7;
    }
    goto LABEL_35;
  }
LABEL_44:
  *((_DWORD *)v22 + 37) = 0;
  v18 = _libssh2_list_first(a1 + 376);
  while ( 1 )
  {
    if ( !v18 )
    {
      if ( v19 )
        result = v19;
      else
        result = (signed int)_libssh2_error(v24, 4294967265LL, "sftp_read() internal error");
      return result;
    }
    if ( *(_QWORD *)(v18 + 48) )
    {
      if ( v19 )
        result = v19;
      else
        result = (signed int)_libssh2_error(v24, 4294967265LL, "sftp_read() internal error");
      return result;
    }
    v28 = (signed int)sub_379D5(
                        v22,
                        2,
                        (__int64)"geheiesftp_close_handle",
                        *(_DWORD *)(v18 + 56),
                        &v15,
                        (unsigned __int64 *)&v16,
                        9uLL);
    if ( v28 == -37 && v19 )
      return v19;
    if ( v28 == -38 )
      break;
    if ( v28 < 0 )
    {
      *((_DWORD *)v22 + 37) = 5;
      return v28;
    }
    v9 = *v15;
    if ( v9 == 101 )
    {
      _libssh2_list_remove(v18);
      (*(void ( **)(__int64, __int64))(v24 + 24))(v18, v24);
      sub_376BA(a1);
      v12 = _libssh2_ntohu32(v15 + 5);
      (*(void ( **)(unsigned __int8 *, __int64))(v24 + 24))(v15, v24);
      if ( v12 == 1 )
      {
        *(_BYTE *)(v25 + 48) = 1;
        result = v19;
      }
      else
      {
        *((_DWORD *)v22 + 16) = v12;
        result = (signed int)_libssh2_error(v24, 4294967265LL, "SFTP READ error");
      }
      return result;
    }
    if ( v9 != 103 )
      return (signed int)_libssh2_error(v24, 4294967265LL, "SFTP Protocol badness: unrecognised read request response");
    if ( *(_QWORD *)(v18 + 24) != *(_QWORD *)v25 )
      return (signed int)_libssh2_error(v24, 4294967265LL, "Read Packet At Unexpected Offset");
    v13 = _libssh2_ntohu32(v15 + 5);
    if ( v13 > (unsigned __int64)(v16 - 9) )
      return (signed int)_libssh2_error(v24, 4294967265LL, "SFTP Protocol badness");
    if ( (unsigned __int64)v13 > *(_QWORD *)(v18 + 32) )
      return (signed int)_libssh2_error(v24, 4294967265LL, "FXP_READ response too big");
    if ( v13 != *(_QWORD *)(v18 + 32) )
      *(_QWORD *)(v25 + 8) += v13 - *(_QWORD *)(v18 + 32);
    if ( v10 >= v13 + v19 )
    {
      *(_QWORD *)(v25 + 32) = 0LL;
    }
    else
    {
      *(_QWORD *)(v25 + 40) = v13 + v19 - v10;
      v13 = v10 - v19;
      *(_QWORD *)(v25 + 24) = v15;
      *(_QWORD *)(v25 + 32) = v16;
    }
    memcpy(v20, v15 + 9, v13);
    *(_QWORD *)v25 += v13;
    v19 += v13;
    v20 = (char *)v20 + v13;
    if ( !*(_QWORD *)(v25 + 32) )
      (*(void ( **)(unsigned __int8 *, __int64))(v24 + 24))(v15, v24);
    v30 = _libssh2_list_next(v18);
    _libssh2_list_remove(v18);
    (*(void ( **)(__int64, __int64))(v24 + 24))(v18, v24);
    if ( v19 >= v10 )
      v18 = 0LL;
    else
      v18 = v30;
  }
  if ( v16 )
    (*(void ( **)(unsigned __int8 *, __int64))(v24 + 24))(v15, v24);
  return (signed int)_libssh2_error(v24, 4294967265LL, "Response too small");
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64  _libssh2_channel_receive_window_adjust(_QWORD, _QWORD, _QWORD, _QWORD);
// 9140: using guessed type __int64  libssh2_channel_window_read_ex(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (0000000000039DE2) ----------------------------------------------------
signed __int64  libssh2_sftp_read(__int64 a1, void *a2, unsigned __int64 a3)
{
  int v4; // eax
  unsigned __int64 v5; // [rsp+8h] [rbp-28h]
  size_t v6; // [rsp+20h] [rbp-10h]
  time_t v7; // [rsp+28h] [rbp-8h]

  v5 = a3;
  if ( !a1 )
    return -39LL;
  v7 = time(0LL);
  do
  {
    v6 = sub_393AE(a1, a2, v5);
    if ( v6 != -37LL )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v4 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v7);
    v6 = v4;
  }
  while ( !v4 );
  return v6;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000039E80) ----------------------------------------------------
size_t  sub_39E80(__int64 a1, void *a2, size_t a3, void *a4, unsigned __int64 a5, void *a6)
{
  unsigned int v6; // eax
  _QWORD *v7; // rax
  size_t result; // rax
  _BYTE *v9; // rax
  void *s; // [rsp+0h] [rbp-E0h]
  unsigned __int64 v11; // [rsp+8h] [rbp-D8h]
  void *v12; // [rsp+10h] [rbp-D0h]
  size_t v13; // [rsp+18h] [rbp-C8h]
  unsigned int v14; // [rsp+3Ch] [rbp-A4h]
  int v15; // [rsp+40h] [rbp-A0h]
  int v16; // [rsp+44h] [rbp-9Ch]
  __int64 v17; // [rsp+48h] [rbp-98h]
  void *src; // [rsp+50h] [rbp-90h]
  size_t n; // [rsp+58h] [rbp-88h]
  __int64 v20; // [rsp+60h] [rbp-80h]
  __int64 v21; // [rsp+68h] [rbp-78h]
  __int64 v22; // [rsp+70h] [rbp-70h]
  unsigned __int64 v23; // [rsp+78h] [rbp-68h]
  __int64 v24; // [rsp+80h] [rbp-60h]
  size_t v25; // [rsp+88h] [rbp-58h]
  size_t v26; // [rsp+90h] [rbp-50h]
  __int64 v27; // [rsp+98h] [rbp-48h]
  _BYTE *v28; // [rsp+A0h] [rbp-40h]
  unsigned __int64 v29; // [rsp+D8h] [rbp-8h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  s = a6;
  v29 = __readfsqword(0x28u);
  v20 = *(_QWORD *)(a1 + 24);
  v21 = *(_QWORD *)v20;
  v22 = *(_QWORD *)(v21 + 96);
  v14 = *(unsigned __int64 *)(a1 + 288) + 13;
  if ( !*(_DWORD *)(v20 + 180) )
  {
    if ( *(_DWORD *)(a1 + 304) )
    {
      v23 = *(_QWORD *)(a1 + 328);
      if ( v23 <= 3 )
      {
        n = -38LL;
      }
      else
      {
        src = *(void **)(a1 + 320);
        v6 = _libssh2_ntohu32(src);
        v24 = v6;
        src = (char *)src + 4;
        v23 -= 4LL;
        n = v6;
        if ( v6 < v13 )
        {
          if ( v13 < n || v23 < n )
          {
            n = -38LL;
          }
          else
          {
            memcpy(a2, src, n);
            *((_BYTE *)a2 + n) = 0;
            src = (char *)src + v24;
            v23 -= v24;
            if ( v23 > 3 )
            {
              v25 = (unsigned int)_libssh2_ntohu32(src);
              src = (char *)src + 4;
              v23 -= 4LL;
              if ( v12 && v11 > 1 )
              {
                v26 = v25;
                if ( v25 >= v11 || v26 > v23 )
                {
                  n = -38LL;
                  goto LABEL_28;
                }
                memcpy(v12, src, v26);
                *((_BYTE *)v12 + v26) = 0;
              }
              if ( v25 > v23 )
              {
                n = -38LL;
              }
              else
              {
                src = (char *)src + v25;
                v23 -= v25;
                if ( s )
                  memset(s, 0, 0x38uLL);
                if ( s )
                  v7 = s;
                else
                  v7 = &v28;
                v15 = sub_37CB9(v7, (__int64)src, v23);
                if ( v15 < 0 )
                {
                  n = -38LL;
                }
                else
                {
                  src = (char *)src + v15;
                  v23 -= v15;
                  *(_QWORD *)(a1 + 320) = src;
                  *(_QWORD *)(a1 + 328) = v23;
                }
              }
              goto LABEL_28;
            }
            n = -38LL;
          }
        }
        else
        {
          n = -38LL;
        }
      }
LABEL_28:
      if ( !--*(_DWORD *)(a1 + 304) )
        (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 312), v22);
      return n;
    }
    *(_QWORD *)(v20 + 184) = (*(__int64 ( **)(_QWORD, __int64))(v22 + 8))(v14, v22);
    src = *(void **)(v20 + 184);
    if ( !*(_QWORD *)(v20 + 184) )
      return (signed int)_libssh2_error(v22, 4294967290LL, "Unable to allocate memory for FXP_READDIR packet");
    _libssh2_store_u32(&src, v14 - 4);
    v9 = src;
    src = (char *)src + 1;
    *v9 = 12;
    LODWORD(v9) = *(_DWORD *)(v20 + 8);
    *(_DWORD *)(v20 + 8) = (_DWORD)v9 + 1;
    *(_DWORD *)(v20 + 192) = (_DWORD)v9;
    _libssh2_store_u32(&src, *(unsigned int *)(v20 + 192));
    _libssh2_store_str(&src, a1 + 32, *(_QWORD *)(a1 + 288));
    *(_DWORD *)(v20 + 180) = 2;
  }
  if ( *(_DWORD *)(v20 + 180) == 2 )
  {
    v27 = _libssh2_channel_write(v21, 0LL, *(_QWORD *)(v20 + 184), v14);
    if ( v27 == -37 )
      return -37LL;
    if ( v27 != v14 )
    {
      (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(v20 + 184), v22);
      *(_QWORD *)(v20 + 184) = 0LL;
      *(_DWORD *)(v20 + 180) = 0;
      return (signed int)_libssh2_error(v22, 4294967289LL, "_libssh2_channel_write() failed");
    }
    (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(v20 + 184), v22);
    *(_QWORD *)(v20 + 184) = 0LL;
    *(_DWORD *)(v20 + 180) = 3;
  }
  v27 = (signed int)sub_379D5(
                      (_QWORD *)v20,
                      2,
                      (__int64)"heiesftp_close_handle",
                      *(_DWORD *)(v20 + 192),
                      &v28,
                      (unsigned __int64 *)&v17,
                      9uLL);
  if ( v27 == -37 )
    return -37LL;
  if ( v27 == -38 )
  {
    if ( v17 )
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v28, v22);
    result = (signed int)_libssh2_error(v22, 4294967265LL, "Status message too short");
  }
  else if ( v27 )
  {
    *(_DWORD *)(v20 + 180) = 0;
    result = (signed int)_libssh2_error(v22, (unsigned int)v27, "Timeout waiting for status message");
  }
  else if ( *v28 == 101 )
  {
    v27 = (unsigned int)_libssh2_ntohu32(v28 + 5);
    (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v28, v22);
    if ( v27 == 1 )
    {
      *(_DWORD *)(v20 + 180) = 0;
      result = 0LL;
    }
    else
    {
      *(_DWORD *)(v20 + 64) = v27;
      *(_DWORD *)(v20 + 180) = 0;
      result = (signed int)_libssh2_error(v22, 4294967265LL, "SFTP Protocol Error");
    }
  }
  else
  {
    *(_DWORD *)(v20 + 180) = 0;
    v16 = _libssh2_ntohu32(v28 + 5);
    if ( v16 )
    {
      *(_DWORD *)(a1 + 304) = v16;
      *(_QWORD *)(a1 + 312) = v28;
      *(_QWORD *)(a1 + 320) = v28 + 9;
      *(_QWORD *)(a1 + 328) = v17 - 9;
      result = sub_39E80(a1, a2, v13, v12, v11, s);
    }
    else
    {
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v28, v22);
      result = 0LL;
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003A69D) ----------------------------------------------------
signed __int64  libssh2_sftp_readdir_ex(__int64 a1, void *a2, size_t a3, void *a4, unsigned __int64 a5, void *a6)
{
  void *v7; // [rsp+0h] [rbp-40h]
  unsigned __int64 v8; // [rsp+8h] [rbp-38h]
  void *v9; // [rsp+10h] [rbp-30h]
  size_t v10; // [rsp+18h] [rbp-28h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v11 = sub_39E80(a1, a2, v10, v9, v8, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v11 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v12);
  }
  while ( !v11 );
  return v11;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003A750) ----------------------------------------------------
__int64  sub_3A750(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  signed int v3; // eax
  _BYTE *v5; // rax
  int v6; // ST2C_4
  __int64 v7; // rax
  unsigned __int64 v8; // [rsp+8h] [rbp-98h]
  __int64 v9; // [rsp+10h] [rbp-90h]
  unsigned int v10; // [rsp+20h] [rbp-80h]
  unsigned int v11; // [rsp+24h] [rbp-7Ch]
  __int64 v12; // [rsp+30h] [rbp-70h]
  _BYTE *v13; // [rsp+38h] [rbp-68h]
  __int64 v14; // [rsp+40h] [rbp-60h]
  __int64 i; // [rsp+48h] [rbp-58h]
  unsigned __int64 v16; // [rsp+50h] [rbp-50h]
  __int64 v17; // [rsp+58h] [rbp-48h]
  __int64 v18; // [rsp+60h] [rbp-40h]
  __int64 v19; // [rsp+68h] [rbp-38h]
  unsigned __int64 v20; // [rsp+70h] [rbp-30h]
  unsigned __int64 v21; // [rsp+78h] [rbp-28h]
  __int64 v22; // [rsp+80h] [rbp-20h]
  __int64 v23; // [rsp+88h] [rbp-18h]
  __int64 v24; // [rsp+90h] [rbp-10h]
  unsigned __int64 v25; // [rsp+98h] [rbp-8h]

  v9 = a2;
  v25 = __readfsqword(0x28u);
  v17 = a1[3];
  v18 = *(_QWORD *)v17;
  v19 = *(_QWORD *)(v18 + 96);
  v16 = 0LL;
  v20 = a3;
  if ( *(_DWORD *)(v17 + 156) != 3 )
  {
    v21 = a1[39] - a1[38] + a1[40];
    if ( a3 < v21 )
    {
      v8 = 0LL;
    }
    else
    {
      v9 = v21 + a2;
      v8 = a3 - v21;
    }
    *(_DWORD *)(v17 + 156) = 0;
    while ( v8 )
    {
      v3 = 30000;
      if ( v8 <= 0x7530 )
        v3 = v8;
      v10 = v3;
      v11 = a1[36] + v3 + 25;
      i = (*(__int64 ( **)(signed __int64, __int64))(v19 + 8))(v11 + 64LL, v19);
      if ( !i )
        return (signed int)_libssh2_error(v19, 4294967290LL, "malloc fail for FXP_WRITE");
      *(_QWORD *)(i + 32) = v10;
      *(_QWORD *)(i + 40) = 0LL;
      *(_QWORD *)(i + 48) = v11;
      v13 = (_BYTE *)(i + 60);
      _libssh2_store_u32(&v13, v11 - 4);
      v5 = v13++;
      *v5 = 6;
      LODWORD(v5) = *(_DWORD *)(v17 + 8);
      *(_DWORD *)(v17 + 8) = (_DWORD)v5 + 1;
      *(_DWORD *)(i + 56) = (_DWORD)v5;
      _libssh2_store_u32(&v13, (unsigned int)v5);
      _libssh2_store_str(&v13, a1 + 4, a1[36]);
      sub_36F78(&v13, a1[39]);
      a1[39] += v10;
      _libssh2_store_str(&v13, v9, v10);
      _libssh2_list_add(a1 + 47, i);
      v9 += v10;
      v8 -= v10;
    }
    for ( i = _libssh2_list_first(a1 + 47); i; i = _libssh2_list_next(i) )
    {
      if ( *(_QWORD *)(i + 48) )
      {
        v22 = _libssh2_channel_write(v18, 0LL, *(_QWORD *)(i + 40) + 48LL + i + 12, *(_QWORD *)(i + 48));
        if ( v22 < 0 )
          return v22;
        *(_QWORD *)(i + 48) -= v22;
        *(_QWORD *)(i + 40) += v22;
        if ( *(_QWORD *)(i + 48) )
          break;
      }
    }
  }
  *(_DWORD *)(v17 + 156) = 0;
  for ( i = _libssh2_list_first(a1 + 47); ; i = v23 )
  {
    if ( !i || *(_QWORD *)(i + 48) || v16 )
    {
      v16 += a1[40];
      if ( !v16 )
        return 0LL;
      v7 = v16;
      if ( v20 <= v16 )
        v7 = v20;
      v24 = v7;
      a1[40] = v16 - v7;
      return v24;
    }
    v22 = (signed int)sub_378DE(v17, 101, *(_DWORD *)(i + 56), &v14, (unsigned __int64 *)&v12, 9uLL);
    if ( v22 == -38 )
    {
      if ( v12 )
        (*(void ( **)(__int64, __int64))(v19 + 24))(v14, v19);
      return (signed int)_libssh2_error(v19, 4294967265LL, "FXP write packet too short");
    }
    if ( v22 < 0 )
      break;
    v6 = _libssh2_ntohu32(v14 + 5);
    (*(void ( **)(__int64, __int64))(v19 + 24))(v14, v19);
    *(_DWORD *)(v17 + 64) = v6;
    if ( v6 )
    {
      sub_376BA((__int64)a1);
      a1[38] -= a1[40];
      a1[39] = a1[38];
      a1[40] = 0LL;
      return (signed int)_libssh2_error(v19, 4294967265LL, "FXP write failed");
    }
    v16 += *(_QWORD *)(i + 32);
    a1[38] += *(_QWORD *)(i + 32);
    v23 = _libssh2_list_next(i);
    _libssh2_list_remove(i);
    (*(void ( **)(__int64, __int64))(v19 + 24))(i, v19);
  }
  if ( v22 == -37 )
    *(_DWORD *)(v17 + 156) = 3;
  return v22;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 9820: using guessed type __int64  _libssh2_list_add(_QWORD, _QWORD);

//----- (000000000003AD59) ----------------------------------------------------
signed __int64  libssh2_sftp_write(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  int v4; // eax
  unsigned __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 v6; // [rsp+20h] [rbp-10h]
  time_t v7; // [rsp+28h] [rbp-8h]

  v5 = a3;
  if ( !a1 )
    return -39LL;
  v7 = time(0LL);
  do
  {
    v6 = sub_3A750((_QWORD *)a1, a2, v5);
    if ( v6 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v4 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v7);
    v6 = v4;
  }
  while ( !v4 );
  return v6;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003ADF7) ----------------------------------------------------
__int64  sub_3ADF7(__int64 a1)
{
  __int64 result; // rax
  _BYTE *v2; // rax
  unsigned int v3; // [rsp+10h] [rbp-50h]
  int v4; // [rsp+14h] [rbp-4Ch]
  __int64 v5; // [rsp+18h] [rbp-48h]
  _BYTE *v6; // [rsp+20h] [rbp-40h]
  __int64 v7; // [rsp+28h] [rbp-38h]
  _BYTE *v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+48h] [rbp-18h]
  __int64 v12; // [rsp+50h] [rbp-10h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_QWORD *)v9;
  v11 = *(_QWORD *)(v10 + 96);
  v3 = *(unsigned __int64 *)(a1 + 288) + 34;
  if ( *(_DWORD *)(v9 + 160) )
  {
    v8 = *(_BYTE **)(v9 + 168);
  }
  else
  {
    v8 = (_BYTE *)(*(__int64 ( **)(_QWORD, __int64))(v11 + 8))(v3, v11);
    v6 = v8;
    if ( !v8 )
      return _libssh2_error(v11, 4294967290LL, "Unable to allocate memory for FXP_EXTENDED packet");
    _libssh2_store_u32(&v6, v3 - 4);
    v2 = v6++;
    *v2 = -56;
    LODWORD(v2) = *(_DWORD *)(v9 + 8);
    *(_DWORD *)(v9 + 8) = (_DWORD)v2 + 1;
    *(_DWORD *)(v9 + 176) = (_DWORD)v2;
    _libssh2_store_u32(&v6, *(unsigned int *)(v9 + 176));
    _libssh2_store_str(&v6, "fsync@openssh.com", 17LL);
    _libssh2_store_str(&v6, a1 + 32, *(_QWORD *)(a1 + 288));
    *(_DWORD *)(v9 + 160) = 2;
  }
  if ( *(_DWORD *)(v9 + 160) == 2 )
  {
    v12 = _libssh2_channel_write(v10, 0LL, v8, v3);
    if ( v12 == -37 || v12 >= 0 && v12 < v3 )
    {
      *(_QWORD *)(v9 + 168) = v8;
      return 4294967259LL;
    }
    (*(void ( **)(_BYTE *, __int64))(v11 + 24))(v8, v11);
    *(_QWORD *)(v9 + 168) = 0LL;
    if ( v12 < 0 )
    {
      *(_DWORD *)(v9 + 160) = 0;
      return _libssh2_error(v11, 4294967289LL, "_libssh2_channel_write() failed");
    }
    *(_DWORD *)(v9 + 160) = 3;
  }
  v12 = (signed int)sub_378DE(v9, 101, *(_DWORD *)(v9 + 176), &v7, (unsigned __int64 *)&v5, 9uLL);
  if ( v12 == -37 )
    return -37LL;
  if ( v12 == -38 )
  {
    if ( v5 )
      (*(void ( **)(__int64, __int64))(v11 + 24))(v7, v11);
    result = _libssh2_error(v11, 4294967265LL, "SFTP fsync packet too short");
  }
  else if ( v12 )
  {
    *(_DWORD *)(v9 + 160) = 0;
    result = _libssh2_error(v11, (unsigned int)v12, "Error waiting for FXP EXTENDED REPLY");
  }
  else
  {
    *(_DWORD *)(v9 + 160) = 0;
    v4 = _libssh2_ntohu32(v7 + 5);
    (*(void ( **)(__int64, __int64))(v11 + 24))(v7, v11);
    if ( v4 )
    {
      *(_DWORD *)(v9 + 64) = v4;
      result = _libssh2_error(v11, 4294967265LL, "fsync failed");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003B14B) ----------------------------------------------------
signed __int64  libssh2_sftp_fsync(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_3ADF7(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003B1CD) ----------------------------------------------------
__int64  sub_3B1CD(__int64 a1, _QWORD *a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  __int64 result; // rax
  char v6; // cl
  char *v7; // rax
  __int64 v8; // rax
  const char *v9; // rax
  int v10; // [rsp+Ch] [rbp-74h]
  unsigned int v11; // [rsp+28h] [rbp-58h]
  int v12; // [rsp+2Ch] [rbp-54h]
  __int64 v13; // [rsp+30h] [rbp-50h]
  char *v14; // [rsp+38h] [rbp-48h]
  _BYTE *v15; // [rsp+40h] [rbp-40h]
  __int64 v16; // [rsp+48h] [rbp-38h]
  __int64 v17; // [rsp+50h] [rbp-30h]
  __int64 v18; // [rsp+58h] [rbp-28h]
  __int64 v19; // [rsp+60h] [rbp-20h]
  unsigned __int64 v20; // [rsp+68h] [rbp-18h]

  v10 = a3;
  v20 = __readfsqword(0x28u);
  v16 = *(_QWORD *)(a1 + 24);
  v17 = *(_QWORD *)v16;
  v18 = *(_QWORD *)(v17 + 96);
  v3 = *(_QWORD *)(a1 + 288);
  if ( a3 )
    v4 = sub_36F43(*a2);
  else
    v4 = 0;
  v11 = v3 + v4 + 13;
  if ( !*(_DWORD *)(v16 + 196) )
  {
    *(_QWORD *)(v16 + 200) = (*(__int64 ( **)(_QWORD, __int64))(v18 + 8))(v11, v18);
    v14 = *(char **)(v16 + 200);
    if ( !*(_QWORD *)(v16 + 200) )
      return _libssh2_error(v18, 4294967290LL, "Unable to allocate memory for FSTAT/FSETSTAT packet");
    _libssh2_store_u32(&v14, v11 - 4);
    if ( v10 )
      v6 = 10;
    else
      v6 = 8;
    v7 = v14++;
    *v7 = v6;
    LODWORD(v7) = *(_DWORD *)(v16 + 8);
    *(_DWORD *)(v16 + 8) = (_DWORD)v7 + 1;
    *(_DWORD *)(v16 + 208) = (_DWORD)v7;
    _libssh2_store_u32(&v14, *(unsigned int *)(v16 + 208));
    _libssh2_store_str(&v14, a1 + 32, *(_QWORD *)(a1 + 288));
    if ( v10 )
    {
      v8 = sub_37B5D((__int64)v14, a2);
      v14 += v8;
    }
    *(_DWORD *)(v16 + 196) = 2;
  }
  if ( *(_DWORD *)(v16 + 196) == 2 )
  {
    v19 = _libssh2_channel_write(v17, 0LL, *(_QWORD *)(v16 + 200), v11);
    if ( v19 == -37 )
      return -37LL;
    if ( v19 != v11 )
    {
      (*(void ( **)(_QWORD, __int64))(v18 + 24))(*(_QWORD *)(v16 + 200), v18);
      *(_QWORD *)(v16 + 200) = 0LL;
      *(_DWORD *)(v16 + 196) = 0;
      if ( v10 )
        v9 = "Unable to send FXP_FSETSTAT";
      else
        v9 = "Unable to send FXP_FSTAT command";
      return _libssh2_error(v18, 4294967289LL, v9);
    }
    (*(void ( **)(_QWORD, __int64))(v18 + 24))(*(_QWORD *)(v16 + 200), v18);
    *(_QWORD *)(v16 + 200) = 0LL;
    *(_DWORD *)(v16 + 196) = 3;
  }
  v19 = (signed int)sub_379D5(
                      (_QWORD *)v16,
                      2,
                      (__int64)"iesftp_close_handle",
                      *(_DWORD *)(v16 + 208),
                      &v15,
                      (unsigned __int64 *)&v13,
                      9uLL);
  if ( v19 == -37 )
    return -37LL;
  if ( v19 == -38 )
  {
    if ( v13 )
      (*(void ( **)(_BYTE *, __int64))(v18 + 24))(v15, v18);
    result = _libssh2_error(v18, 4294967265LL, "SFTP fstat packet too short");
  }
  else if ( v19 )
  {
    *(_DWORD *)(v16 + 196) = 0;
    result = _libssh2_error(v18, (unsigned int)v19, "Timeout waiting for status message");
  }
  else
  {
    *(_DWORD *)(v16 + 196) = 0;
    if ( *v15 == 101 )
    {
      v12 = _libssh2_ntohu32(v15 + 5);
      (*(void ( **)(_BYTE *, __int64))(v18 + 24))(v15, v18);
      if ( v12 )
      {
        *(_DWORD *)(v16 + 64) = v12;
        result = _libssh2_error(v18, 4294967265LL, "SFTP Protocol Error");
      }
      else
      {
        result = 0LL;
      }
    }
    else if ( (signed int)sub_37CB9(a2, (__int64)(v15 + 5), v13 - 5) >= 0 )
    {
      (*(void ( **)(_BYTE *, __int64))(v18 + 24))(v15, v18);
      result = 0LL;
    }
    else
    {
      (*(void ( **)(_BYTE *, __int64))(v18 + 24))(v15, v18);
      result = _libssh2_error(v18, 4294967265LL, "Attributes too short in SFTP fstat");
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003B63B) ----------------------------------------------------
signed __int64  libssh2_sftp_fstat_ex(__int64 a1, _QWORD *a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  time_t v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 || !a2 )
    return 4294967257LL;
  v6 = time(0LL);
  do
  {
    v5 = sub_3B1CD(a1, a2, v4);
    if ( v5 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v5 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v6);
  }
  while ( !v5 );
  return v5;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003B6D5) ----------------------------------------------------
__int64  libssh2_sftp_seek64(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( a2 != *(_QWORD *)(a1 + 304) || (result = *(_QWORD *)(a1 + 312), a2 != result) )
    {
      *(_QWORD *)(a1 + 312) = a2;
      *(_QWORD *)(a1 + 304) = *(_QWORD *)(a1 + 312);
      sub_376BA(a1);
      if ( *(_QWORD *)(a1 + 344) )
      {
        (*(void ( **)(_QWORD, _QWORD))(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 24LL))(
          *(_QWORD *)(a1 + 328),
          *(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL));
        *(_QWORD *)(a1 + 336) = 0LL;
        *(_QWORD *)(a1 + 344) = *(_QWORD *)(a1 + 336);
        *(_QWORD *)(a1 + 328) = 0LL;
      }
      result = a1;
      *(_BYTE *)(a1 + 352) = 0;
    }
  }
  return result;
}

//----- (000000000003B7D6) ----------------------------------------------------
__int64  libssh2_sftp_seek(__int64 a1, __int64 a2)
{
  return libssh2_sftp_seek64(a1, a2);
}
// 98C0: using guessed type __int64  libssh2_sftp_seek64(_QWORD, _QWORD);

//----- (000000000003B7FC) ----------------------------------------------------
__int64  libssh2_sftp_tell(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(_QWORD *)(a1 + 304);
  else
    result = 0LL;
  return result;
}

//----- (000000000003B81F) ----------------------------------------------------
__int64  libssh2_sftp_tell64(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(_QWORD *)(a1 + 304);
  else
    result = 0LL;
  return result;
}

//----- (000000000003B842) ----------------------------------------------------
__int64  sub_3B842(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // ST38_8
  __int64 v3; // ST30_8
  __int64 v4; // [rsp+10h] [rbp-30h]
  __int64 v5; // [rsp+18h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-18h]

  v6 = *(_QWORD *)(*(_QWORD *)a1 + 96LL);
  v4 = _libssh2_list_first(a1 + 16);
  result = _libssh2_list_first(a1 + 32);
  v5 = result;
  while ( v4 )
  {
    v2 = _libssh2_list_next(v4);
    _libssh2_list_remove(v4);
    (*(void ( **)(_QWORD, __int64))(v6 + 24))(*(_QWORD *)(v4 + 32), v6);
    (*(void ( **)(__int64, __int64))(v6 + 24))(v4, v6);
    result = v2;
    v4 = v2;
  }
  while ( v5 )
  {
    v3 = _libssh2_list_next(v5);
    _libssh2_list_remove(v5);
    (*(void ( **)(__int64, __int64))(v6 + 24))(v5, v6);
    result = v3;
    v5 = v3;
  }
  return result;
}
// 8AA0: using guessed type __int64  _libssh2_list_first(_QWORD);
// 9260: using guessed type __int64  _libssh2_list_next(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);

//----- (000000000003B936) ----------------------------------------------------
signed __int64  sub_3B936(__int64 a1)
{
  _BYTE *v1; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-44h]
  unsigned int v4; // [rsp+20h] [rbp-40h]
  int v5; // [rsp+24h] [rbp-3Ch]
  __int64 v6; // [rsp+28h] [rbp-38h]
  _BYTE *v7; // [rsp+30h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-28h]
  __int64 v9; // [rsp+40h] [rbp-20h]
  __int64 v10; // [rsp+48h] [rbp-18h]
  __int64 v11; // [rsp+50h] [rbp-10h]
  unsigned __int64 v12; // [rsp+58h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_QWORD *)v9;
  v11 = *(_QWORD *)(v10 + 96);
  v4 = *(unsigned __int64 *)(a1 + 288) + 13;
  v8 = 0LL;
  v3 = 0;
  if ( !*(_DWORD *)(a1 + 360) )
  {
    *(_QWORD *)(a1 + 368) = (*(__int64 ( **)(_QWORD, __int64))(v11 + 8))(v4, v11);
    v7 = *(_BYTE **)(a1 + 368);
    if ( *(_QWORD *)(a1 + 368) )
    {
      _libssh2_store_u32(&v7, v4 - 4);
      v1 = v7++;
      *v1 = 4;
      LODWORD(v1) = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + 8) = (_DWORD)v1 + 1;
      *(_DWORD *)(a1 + 364) = (_DWORD)v1;
      _libssh2_store_u32(&v7, *(unsigned int *)(a1 + 364));
      _libssh2_store_str(&v7, a1 + 32, *(_QWORD *)(a1 + 288));
      *(_DWORD *)(a1 + 360) = 2;
    }
    else
    {
      *(_DWORD *)(a1 + 360) = 0;
      v3 = _libssh2_error(v11, 4294967290LL, "Unable to allocate memory for FXP_CLOSE packet");
    }
  }
  if ( *(_DWORD *)(a1 + 360) == 2 )
  {
    v3 = _libssh2_channel_write(v10, 0LL, *(_QWORD *)(a1 + 368), v4);
    if ( v3 == -37 )
      return 4294967259LL;
    if ( v4 == (signed __int64)(signed int)v3 )
    {
      *(_DWORD *)(a1 + 360) = 3;
    }
    else
    {
      *(_DWORD *)(a1 + 360) = 0;
      v3 = _libssh2_error(v11, 4294967289LL, "Unable to send FXP_CLOSE command");
    }
    (*(void ( **)(_QWORD, __int64))(v11 + 24))(*(_QWORD *)(a1 + 368), v11);
    *(_QWORD *)(a1 + 368) = 0LL;
  }
  if ( *(_DWORD *)(a1 + 360) == 3 )
  {
    v3 = sub_378DE(v9, 101, *(_DWORD *)(a1 + 364), &v8, (unsigned __int64 *)&v6, 9uLL);
    if ( v3 == -37 )
      return 4294967259LL;
    if ( v3 == -38 )
    {
      if ( v6 )
        (*(void ( **)(__int64, __int64))(v11 + 24))(v8, v11);
      v8 = 0LL;
      _libssh2_error(v11, 4294967265LL, "Packet too short in FXP_CLOSE command");
    }
    else if ( v3 )
    {
      _libssh2_error(v11, v3, "Error waiting for status message");
    }
    *(_DWORD *)(a1 + 360) = 4;
  }
  if ( v8 )
  {
    v5 = _libssh2_ntohu32(v8 + 5);
    (*(void ( **)(__int64, __int64))(v11 + 24))(v8, v11);
    if ( v5 )
    {
      *(_DWORD *)(v9 + 64) = v5;
      *(_DWORD *)(a1 + 360) = 0;
      v3 = _libssh2_error(v11, 4294967265LL, "SFTP Protocol Error");
    }
  }
  else if ( !v3 )
  {
    __assert_fail("rc", "/home/mantovan/Repositories/libssh2/src/sftp.c", 0xA58u, "sftp_close_handle");
  }
  _libssh2_list_remove(a1);
  if ( *(_DWORD *)(a1 + 296) == 1 )
  {
    if ( *(_DWORD *)(a1 + 304) )
      (*(void ( **)(_QWORD, __int64))(v11 + 24))(*(_QWORD *)(a1 + 312), v11);
  }
  else if ( !*(_DWORD *)(a1 + 296) && *(_QWORD *)(a1 + 328) )
  {
    (*(void ( **)(_QWORD, __int64))(v11 + 24))(*(_QWORD *)(a1 + 328), v11);
  }
  sub_376BA(a1);
  *(_DWORD *)(v9 + 148) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  (*(void ( **)(__int64, __int64))(v11 + 24))(a1, v11);
  return v3;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9330: using guessed type __int64  _libssh2_list_remove(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003BD90) ----------------------------------------------------
signed __int64  libssh2_sftp_close_handle(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  time_t v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 4294967257LL;
  v3 = time(0LL);
  do
  {
    v2 = sub_3B936(a1);
    if ( v2 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v2 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v3);
  }
  while ( !v2 );
  return v2;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003BE12) ----------------------------------------------------
__int64  sub_3BE12(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  _BYTE *v4; // rax
  __int64 v5; // [rsp+8h] [rbp-58h]
  unsigned int v6; // [rsp+24h] [rbp-3Ch]
  int v7; // [rsp+28h] [rbp-38h]
  unsigned int v8; // [rsp+28h] [rbp-38h]
  int v9; // [rsp+2Ch] [rbp-34h]
  __int64 v10; // [rsp+30h] [rbp-30h]
  _BYTE *v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v5 = a3;
  v15 = __readfsqword(0x28u);
  v13 = *(_QWORD *)a1;
  v14 = *(_QWORD *)(v13 + 96);
  v6 = a3 + 13;
  if ( !*(_DWORD *)(a1 + 212) )
  {
    *(_QWORD *)(a1 + 216) = (*(__int64 ( **)(_QWORD, __int64))(v14 + 8))(v6, v14);
    v11 = *(_BYTE **)(a1 + 216);
    if ( !*(_QWORD *)(a1 + 216) )
      return _libssh2_error(v14, 4294967290LL, "Unable to allocate memory for FXP_REMOVE packet");
    _libssh2_store_u32(&v11, v6 - 4);
    v4 = v11++;
    *v4 = 13;
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v4 + 1;
    *(_DWORD *)(a1 + 224) = (_DWORD)v4;
    _libssh2_store_u32(&v11, *(unsigned int *)(a1 + 224));
    _libssh2_store_str(&v11, a2, v5);
    *(_DWORD *)(a1 + 212) = 2;
  }
  if ( *(_DWORD *)(a1 + 212) == 2 )
  {
    v7 = _libssh2_channel_write(v13, 0LL, *(_QWORD *)(a1 + 216), v6);
    if ( v7 == -37 )
      return 4294967259LL;
    if ( v6 != (signed __int64)v7 )
    {
      (*(void ( **)(_QWORD, __int64))(v14 + 24))(*(_QWORD *)(a1 + 216), v14);
      *(_QWORD *)(a1 + 216) = 0LL;
      *(_DWORD *)(a1 + 212) = 0;
      return _libssh2_error(v14, 4294967289LL, "Unable to send FXP_REMOVE command");
    }
    (*(void ( **)(_QWORD, __int64))(v14 + 24))(*(_QWORD *)(a1 + 216), v14);
    *(_QWORD *)(a1 + 216) = 0LL;
    *(_DWORD *)(a1 + 212) = 3;
  }
  v8 = sub_378DE(a1, 101, *(_DWORD *)(a1 + 224), &v12, (unsigned __int64 *)&v10, 9uLL);
  if ( v8 == -37 )
    return 4294967259LL;
  if ( v8 == -38 )
  {
    if ( v10 )
      (*(void ( **)(__int64, __int64))(v14 + 24))(v12, v14);
    result = _libssh2_error(v14, 4294967265LL, "SFTP unlink packet too short");
  }
  else if ( v8 )
  {
    *(_DWORD *)(a1 + 212) = 0;
    result = _libssh2_error(v14, v8, "Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 212) = 0;
    v9 = _libssh2_ntohu32(v12 + 5);
    (*(void ( **)(__int64, __int64))(v14 + 24))(v12, v14);
    if ( v9 )
    {
      *(_DWORD *)(a1 + 64) = v9;
      result = _libssh2_error(v14, 4294967265LL, "SFTP Protocol Error");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003C156) ----------------------------------------------------
signed __int64  libssh2_sftp_unlink_ex(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-24h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  time_t v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 )
    return 4294967257LL;
  v6 = time(0LL);
  do
  {
    v5 = sub_3BE12(a1, a2, v4);
    if ( v5 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v5 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v6);
  }
  while ( !v5 );
  return v5;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003C1E1) ----------------------------------------------------
__int64  sub_3C1E1(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  int v6; // edx
  signed int v7; // eax
  __int64 result; // rax
  _BYTE *v9; // rax
  unsigned int v10; // [rsp+8h] [rbp-68h]
  __int64 v11; // [rsp+10h] [rbp-60h]
  unsigned int v12; // [rsp+18h] [rbp-58h]
  unsigned int v13; // [rsp+1Ch] [rbp-54h]
  int v14; // [rsp+38h] [rbp-38h]
  unsigned int v15; // [rsp+38h] [rbp-38h]
  unsigned int v16; // [rsp+3Ch] [rbp-34h]
  __int64 v17; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h]
  __int64 v19; // [rsp+50h] [rbp-20h]
  __int64 v20; // [rsp+58h] [rbp-18h]
  __int64 v21; // [rsp+60h] [rbp-10h]
  unsigned __int64 v22; // [rsp+68h] [rbp-8h]

  v13 = a3;
  v11 = a4;
  v12 = a5;
  v10 = a6;
  v22 = __readfsqword(0x28u);
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD *)(v19 + 96);
  v6 = a5 + a3;
  if ( *(_DWORD *)(a1 + 12) <= 4u )
    v7 = 0;
  else
    v7 = 4;
  v16 = v6 + v7 + 17;
  if ( *(_DWORD *)(a1 + 12) <= 1u )
    return _libssh2_error(v20, 4294967265LL, "Server does not support RENAME");
  if ( !*(_DWORD *)(a1 + 228) )
  {
    *(_QWORD *)(a1 + 232) = (*(__int64 ( **)(_QWORD, __int64))(v20 + 8))(v16, v20);
    *(_QWORD *)(a1 + 240) = *(_QWORD *)(a1 + 232);
    if ( !*(_QWORD *)(a1 + 232) )
      return _libssh2_error(v20, 4294967290LL, "Unable to allocate memory for FXP_RENAME packet");
    _libssh2_store_u32(a1 + 240, v16 - 4);
    v9 = *(_BYTE **)(a1 + 240);
    *(_QWORD *)(a1 + 240) = v9 + 1;
    *v9 = 18;
    LODWORD(v9) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v9 + 1;
    *(_DWORD *)(a1 + 248) = (_DWORD)v9;
    _libssh2_store_u32(a1 + 240, *(unsigned int *)(a1 + 248));
    _libssh2_store_str(a1 + 240, a2, v13);
    _libssh2_store_str(a1 + 240, v11, v12);
    if ( *(_DWORD *)(a1 + 12) > 4u )
      _libssh2_store_u32(a1 + 240, v10);
    *(_DWORD *)(a1 + 228) = 2;
  }
  if ( *(_DWORD *)(a1 + 228) == 2 )
  {
    v21 = _libssh2_channel_write(v19, 0LL, *(_QWORD *)(a1 + 232), *(_QWORD *)(a1 + 240) - *(_QWORD *)(a1 + 232));
    if ( v21 == -37 )
      return -37LL;
    if ( v21 != v16 )
    {
      (*(void ( **)(_QWORD, __int64))(v20 + 24))(*(_QWORD *)(a1 + 232), v20);
      *(_QWORD *)(a1 + 232) = 0LL;
      *(_DWORD *)(a1 + 228) = 0;
      return _libssh2_error(v20, 4294967289LL, "Unable to send FXP_RENAME command");
    }
    (*(void ( **)(_QWORD, __int64))(v20 + 24))(*(_QWORD *)(a1 + 232), v20);
    *(_QWORD *)(a1 + 232) = 0LL;
    *(_DWORD *)(a1 + 228) = 3;
  }
  v21 = (signed int)sub_378DE(a1, 101, *(_DWORD *)(a1 + 248), &v18, (unsigned __int64 *)&v17, 9uLL);
  if ( v21 == -37 )
    return -37LL;
  if ( v21 == -38 )
  {
    if ( v17 )
      (*(void ( **)(__int64, __int64))(v20 + 24))(v18, v20);
    result = _libssh2_error(v20, 4294967265LL, "SFTP rename packet too short");
  }
  else if ( v21 )
  {
    *(_DWORD *)(a1 + 228) = 0;
    result = _libssh2_error(v20, (unsigned int)v21, "Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 228) = 0;
    v14 = _libssh2_ntohu32(v18 + 5);
    (*(void ( **)(__int64, __int64))(v20 + 24))(v18, v20);
    *(_DWORD *)(a1 + 64) = v14;
    if ( v14 == 8 )
    {
      v15 = _libssh2_error(v20, 4294967265LL, "Operation Not Supported");
    }
    else if ( v14 == 11 )
    {
      v15 = _libssh2_error(v20, 4294967265LL, "File already exists and SSH_FXP_RENAME_OVERWRITE not specified");
    }
    else if ( v14 )
    {
      v15 = _libssh2_error(v20, 4294967265LL, "SFTP Protocol Error");
    }
    else
    {
      v15 = 0;
    }
    result = v15;
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003C65B) ----------------------------------------------------
signed __int64  libssh2_sftp_rename_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  unsigned int v7; // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+18h] [rbp-28h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v11 = sub_3C1E1(a1, a2, v10, v8, v9, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v11 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v12);
  }
  while ( !v11 );
  return v11;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003C700) ----------------------------------------------------
__int64  sub_3C700(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  _BYTE *v3; // rax
  int v4; // ST34_4
  char v5; // ST30_1
  unsigned int v6; // [rsp+1Ch] [rbp-54h]
  unsigned __int64 v7; // [rsp+28h] [rbp-48h]
  _BYTE *v8; // [rsp+30h] [rbp-40h]
  _BYTE *v9; // [rsp+38h] [rbp-38h]
  _BYTE *v10; // [rsp+40h] [rbp-30h]
  __int64 v11; // [rsp+48h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-20h]
  __int64 v13; // [rsp+58h] [rbp-18h]
  __int64 v14; // [rsp+60h] [rbp-10h]
  unsigned __int64 v15; // [rsp+68h] [rbp-8h]

  v15 = __readfsqword(0x28u);
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_QWORD *)v11;
  v13 = *(_QWORD *)(v12 + 96);
  v6 = *(unsigned __int64 *)(a1 + 288) + 37;
  if ( *(_DWORD *)(v11 + 252) )
  {
    v10 = *(_BYTE **)(v11 + 256);
  }
  else
  {
    v10 = (_BYTE *)(*(__int64 ( **)(_QWORD, __int64))(v13 + 8))(v6, v13);
    v8 = v10;
    if ( !v10 )
      return _libssh2_error(v13, 4294967290LL, "Unable to allocate memory for FXP_EXTENDED packet");
    _libssh2_store_u32(&v8, v6 - 4);
    v3 = v8++;
    *v3 = -56;
    LODWORD(v3) = *(_DWORD *)(v11 + 8);
    *(_DWORD *)(v11 + 8) = (_DWORD)v3 + 1;
    *(_DWORD *)(v11 + 264) = (_DWORD)v3;
    _libssh2_store_u32(&v8, *(unsigned int *)(v11 + 264));
    _libssh2_store_str(&v8, "fstatvfs@openssh.com", 20LL);
    _libssh2_store_str(&v8, a1 + 32, *(_QWORD *)(a1 + 288));
    *(_DWORD *)(v11 + 252) = 2;
  }
  if ( *(_DWORD *)(v11 + 252) == 2 )
  {
    v14 = _libssh2_channel_write(v12, 0LL, v10, v6);
    if ( v14 == -37 || v14 >= 0 && v14 < v6 )
    {
      *(_QWORD *)(v11 + 256) = v10;
      return 4294967259LL;
    }
    (*(void ( **)(_BYTE *, __int64))(v13 + 24))(v10, v13);
    *(_QWORD *)(v11 + 256) = 0LL;
    if ( v14 < 0 )
    {
      *(_DWORD *)(v11 + 252) = 0;
      return _libssh2_error(v13, 4294967289LL, "_libssh2_channel_write() failed");
    }
    *(_DWORD *)(v11 + 252) = 3;
  }
  v14 = (signed int)sub_379D5((_QWORD *)v11, 2, (__int64)&unk_49C92, *(_DWORD *)(v11 + 264), &v9, &v7, 9uLL);
  if ( v14 == -37 )
    return -37LL;
  if ( v14 == -38 )
  {
    if ( v7 )
      (*(void ( **)(_BYTE *, __int64))(v13 + 24))(v9, v13);
    result = _libssh2_error(v13, 4294967265LL, "SFTP rename packet too short");
  }
  else if ( v14 )
  {
    *(_DWORD *)(v11 + 252) = 0;
    result = _libssh2_error(v13, (unsigned int)v14, "Error waiting for FXP EXTENDED REPLY");
  }
  else if ( *v9 == 101 )
  {
    v4 = _libssh2_ntohu32(v9 + 5);
    *(_DWORD *)(v11 + 252) = 0;
    (*(void ( **)(_BYTE *, __int64))(v13 + 24))(v9, v13);
    *(_DWORD *)(v11 + 64) = v4;
    result = _libssh2_error(v13, 4294967265LL, "SFTP Protocol Error");
  }
  else if ( v7 > 0x5C )
  {
    *(_DWORD *)(v11 + 252) = 0;
    *a2 = _libssh2_ntohu64(v9 + 5, 2LL);
    a2[1] = _libssh2_ntohu64(v9 + 13, 2LL);
    a2[2] = _libssh2_ntohu64(v9 + 21, 2LL);
    a2[3] = _libssh2_ntohu64(v9 + 29, 2LL);
    a2[4] = _libssh2_ntohu64(v9 + 37, 2LL);
    a2[5] = _libssh2_ntohu64(v9 + 45, 2LL);
    a2[6] = _libssh2_ntohu64(v9 + 53, 2LL);
    a2[7] = _libssh2_ntohu64(v9 + 61, 2LL);
    a2[8] = _libssh2_ntohu64(v9 + 69, 2LL);
    v5 = _libssh2_ntohu64(v9 + 77, 2LL);
    a2[10] = _libssh2_ntohu64(v9 + 85, 2LL);
    a2[9] = v5 & 1;
    a2[9] |= v5 & 2;
    (*(void ( **)(_BYTE *, __int64))(v13 + 24))(v9, v13);
    result = 0LL;
  }
  else
  {
    (*(void ( **)(_BYTE *, __int64))(v13 + 24))(v9, v13);
    *(_DWORD *)(v11 + 252) = 0;
    result = _libssh2_error(v13, 4294967265LL, "SFTP Protocol Error: short response");
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 99E0: using guessed type __int64  _libssh2_ntohu64(_QWORD, _QWORD);

//----- (000000000003CC32) ----------------------------------------------------
signed __int64  libssh2_sftp_fstatvfs(__int64 a1, _QWORD *a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  time_t v4; // [rsp+18h] [rbp-8h]

  if ( !a1 || !a2 )
    return 4294967257LL;
  v4 = time(0LL);
  do
  {
    v3 = sub_3C700(a1, a2);
    if ( v3 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL) + 148LL) )
      break;
    v3 = _libssh2_wait_socket(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 96LL), v4);
  }
  while ( !v3 );
  return v3;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003CCC6) ----------------------------------------------------
__int64  sub_3CCC6(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4)
{
  __int64 result; // rax
  _BYTE *v5; // rax
  int v6; // ST3C_4
  char v7; // ST38_1
  _QWORD *v8; // [rsp+0h] [rbp-70h]
  unsigned int v9; // [rsp+Ch] [rbp-64h]
  unsigned int v10; // [rsp+24h] [rbp-4Ch]
  unsigned __int64 v11; // [rsp+30h] [rbp-40h]
  _BYTE *v12; // [rsp+38h] [rbp-38h]
  _BYTE *v13; // [rsp+40h] [rbp-30h]
  _BYTE *v14; // [rsp+48h] [rbp-28h]
  __int64 v15; // [rsp+50h] [rbp-20h]
  __int64 v16; // [rsp+58h] [rbp-18h]
  __int64 v17; // [rsp+60h] [rbp-10h]
  unsigned __int64 v18; // [rsp+68h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v18 = __readfsqword(0x28u);
  v15 = *(_QWORD *)a1;
  v16 = *(_QWORD *)(v15 + 96);
  v10 = a3 + 36;
  if ( *(_DWORD *)(a1 + 268) )
  {
    v14 = *(_BYTE **)(a1 + 272);
  }
  else
  {
    v14 = (_BYTE *)(*(__int64 ( **)(_QWORD, __int64))(v16 + 8))(v10, v16);
    v12 = v14;
    if ( !v14 )
      return _libssh2_error(v16, 4294967290LL, "Unable to allocate memory for FXP_EXTENDED packet");
    _libssh2_store_u32(&v12, v10 - 4);
    v5 = v12++;
    *v5 = -56;
    LODWORD(v5) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v5 + 1;
    *(_DWORD *)(a1 + 280) = (_DWORD)v5;
    _libssh2_store_u32(&v12, *(unsigned int *)(a1 + 280));
    _libssh2_store_str(&v12, "statvfs@openssh.com", 19LL);
    _libssh2_store_str(&v12, a2, v9);
    *(_DWORD *)(a1 + 268) = 2;
  }
  if ( *(_DWORD *)(a1 + 268) == 2 )
  {
    v17 = _libssh2_channel_write(v15, 0LL, v14, v10);
    if ( v17 == -37 || v17 >= 0 && v17 < v10 )
    {
      *(_QWORD *)(a1 + 272) = v14;
      return 4294967259LL;
    }
    (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v14, v16);
    *(_QWORD *)(a1 + 272) = 0LL;
    if ( v17 < 0 )
    {
      *(_DWORD *)(a1 + 268) = 0;
      return _libssh2_error(v16, 4294967289LL, "_libssh2_channel_write() failed");
    }
    *(_DWORD *)(a1 + 268) = 3;
  }
  v17 = (signed int)sub_379D5((_QWORD *)a1, 2, (__int64)&unk_49C94, *(_DWORD *)(a1 + 280), &v13, &v11, 9uLL);
  if ( v17 == -37 )
    return -37LL;
  if ( v17 == -38 )
  {
    if ( v11 )
      (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v13, v16);
    result = _libssh2_error(v16, 4294967265LL, "SFTP fstat packet too short");
  }
  else if ( v17 )
  {
    *(_DWORD *)(a1 + 268) = 0;
    result = _libssh2_error(v16, (unsigned int)v17, "Error waiting for FXP EXTENDED REPLY");
  }
  else if ( *v13 == 101 )
  {
    v6 = _libssh2_ntohu32(v13 + 5);
    *(_DWORD *)(a1 + 268) = 0;
    (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v13, v16);
    *(_DWORD *)(a1 + 64) = v6;
    result = _libssh2_error(v16, 4294967265LL, "SFTP Protocol Error");
  }
  else if ( v11 > 0x5C )
  {
    *(_DWORD *)(a1 + 268) = 0;
    *v8 = _libssh2_ntohu64(v13 + 5, 2LL);
    v8[1] = _libssh2_ntohu64(v13 + 13, 2LL);
    v8[2] = _libssh2_ntohu64(v13 + 21, 2LL);
    v8[3] = _libssh2_ntohu64(v13 + 29, 2LL);
    v8[4] = _libssh2_ntohu64(v13 + 37, 2LL);
    v8[5] = _libssh2_ntohu64(v13 + 45, 2LL);
    v8[6] = _libssh2_ntohu64(v13 + 53, 2LL);
    v8[7] = _libssh2_ntohu64(v13 + 61, 2LL);
    v8[8] = _libssh2_ntohu64(v13 + 69, 2LL);
    v7 = _libssh2_ntohu64(v13 + 77, 2LL);
    v8[10] = _libssh2_ntohu64(v13 + 85, 2LL);
    v8[9] = v7 & 1;
    v8[9] |= v7 & 2;
    (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v13, v16);
    result = 0LL;
  }
  else
  {
    (*(void ( **)(_BYTE *, __int64))(v16 + 24))(v13, v16);
    *(_DWORD *)(a1 + 268) = 0;
    result = _libssh2_error(v16, 4294967265LL, "SFTP Protocol Error: short response");
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);
// 99E0: using guessed type __int64  _libssh2_ntohu64(_QWORD, _QWORD);

//----- (000000000003D1DF) ----------------------------------------------------
signed __int64  libssh2_sftp_statvfs(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4)
{
  _QWORD *v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+8h] [rbp-28h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( !a1 || !a4 )
    return 4294967257LL;
  v8 = time(0LL);
  do
  {
    v7 = sub_3CCC6(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v7 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v8);
  }
  while ( !v7 );
  return v7;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003D27F) ----------------------------------------------------
__int64  sub_3D27F(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 result; // rax
  _BYTE *v6; // rax
  __int64 v7; // rax
  unsigned int v8; // [rsp+Ch] [rbp-94h]
  int v9; // [rsp+20h] [rbp-80h]
  unsigned int v10; // [rsp+20h] [rbp-80h]
  int v11; // [rsp+24h] [rbp-7Ch]
  __int64 v12; // [rsp+28h] [rbp-78h]
  _BYTE *v13; // [rsp+30h] [rbp-70h]
  __int64 v14; // [rsp+38h] [rbp-68h]
  _BYTE *v15; // [rsp+40h] [rbp-60h]
  __int64 v16; // [rsp+48h] [rbp-58h]
  __int64 v17; // [rsp+50h] [rbp-50h]
  __int64 v18; // [rsp+58h] [rbp-48h]
  __int64 v19; // [rsp+60h] [rbp-40h]
  __int64 v20; // [rsp+68h] [rbp-38h]
  __int64 v21; // [rsp+70h] [rbp-30h]
  __int64 v22; // [rsp+78h] [rbp-28h]
  __int64 v23; // [rsp+80h] [rbp-20h]
  __int64 v24; // [rsp+88h] [rbp-18h]
  __int64 v25; // [rsp+90h] [rbp-10h]
  unsigned __int64 v26; // [rsp+98h] [rbp-8h]

  v8 = a3;
  v26 = __readfsqword(0x28u);
  v16 = *(_QWORD *)a1;
  v17 = *(_QWORD *)(v16 + 96);
  v19 = 0LL;
  v20 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  v25 = 0LL;
  if ( a4 != -1 )
  {
    v19 = 4LL;
    v4 = a4;
    BYTE1(v4) |= 0x40u;
    v23 = v4;
  }
  v18 = (unsigned int)sub_36F43(v19) + a3 + 13;
  if ( *(_DWORD *)(a1 + 284) )
  {
    v15 = *(_BYTE **)(a1 + 288);
  }
  else
  {
    v15 = (_BYTE *)(*(__int64 ( **)(__int64, __int64))(v17 + 8))(v18, v17);
    v13 = v15;
    if ( !v15 )
      return _libssh2_error(v17, 4294967290LL, "Unable to allocate memory for FXP_MKDIR packet");
    _libssh2_store_u32(&v13, (unsigned int)(v18 - 4));
    v6 = v13++;
    *v6 = 14;
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v6 + 1;
    *(_DWORD *)(a1 + 296) = (_DWORD)v6;
    _libssh2_store_u32(&v13, *(unsigned int *)(a1 + 296));
    _libssh2_store_str(&v13, a2, v8);
    v7 = sub_37B5D((__int64)v13, &v19);
    v13 += v7;
    *(_DWORD *)(a1 + 284) = 2;
  }
  if ( *(_DWORD *)(a1 + 284) == 2 )
  {
    v9 = _libssh2_channel_write(v16, 0LL, v15, v18);
    if ( v9 == -37 )
    {
      *(_QWORD *)(a1 + 288) = v15;
      return 4294967259LL;
    }
    if ( v18 != v9 )
    {
      (*(void ( **)(_BYTE *, __int64))(v17 + 24))(v15, v17);
      *(_DWORD *)(a1 + 284) = 0;
      return _libssh2_error(v17, 4294967289LL, "_libssh2_channel_write() failed");
    }
    (*(void ( **)(_BYTE *, __int64))(v17 + 24))(v15, v17);
    *(_DWORD *)(a1 + 284) = 3;
    *(_QWORD *)(a1 + 288) = 0LL;
  }
  v10 = sub_378DE(a1, 101, *(_DWORD *)(a1 + 296), &v14, (unsigned __int64 *)&v12, 9uLL);
  if ( v10 == -37 )
    return 4294967259LL;
  if ( v10 == -38 )
  {
    if ( v12 )
      (*(void ( **)(__int64, __int64))(v17 + 24))(v14, v17);
    result = _libssh2_error(v17, 4294967265LL, "SFTP mkdir packet too short");
  }
  else if ( v10 )
  {
    *(_DWORD *)(a1 + 284) = 0;
    result = _libssh2_error(v17, v10, "Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 284) = 0;
    v11 = _libssh2_ntohu32(v14 + 5);
    (*(void ( **)(__int64, __int64))(v17 + 24))(v14, v17);
    if ( v11 )
    {
      *(_DWORD *)(a1 + 64) = v11;
      result = _libssh2_error(v17, 4294967265LL, "SFTP Protocol Error");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003D681) ----------------------------------------------------
signed __int64  libssh2_sftp_mkdir_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  if ( !a1 )
    return 4294967257LL;
  v8 = time(0LL);
  do
  {
    v7 = sub_3D27F(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v7 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v8);
  }
  while ( !v7 );
  return v7;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003D711) ----------------------------------------------------
__int64  sub_3D711(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  _BYTE *v4; // rax
  unsigned int v5; // [rsp+Ch] [rbp-54h]
  int v6; // [rsp+20h] [rbp-40h]
  unsigned int v7; // [rsp+20h] [rbp-40h]
  int v8; // [rsp+24h] [rbp-3Ch]
  __int64 v9; // [rsp+28h] [rbp-38h]
  _BYTE *v10; // [rsp+30h] [rbp-30h]
  __int64 v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  __int64 v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+58h] [rbp-8h]

  v5 = a3;
  v15 = __readfsqword(0x28u);
  v12 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(v12 + 96);
  v14 = a3 + 13;
  if ( !*(_DWORD *)(a1 + 300) )
  {
    *(_QWORD *)(a1 + 304) = (*(__int64 ( **)(__int64, __int64))(v13 + 8))(v14, v13);
    v10 = *(_BYTE **)(a1 + 304);
    if ( !*(_QWORD *)(a1 + 304) )
      return _libssh2_error(v13, 4294967290LL, "Unable to allocate memory for FXP_RMDIR packet");
    _libssh2_store_u32(&v10, (unsigned int)(v14 - 4));
    v4 = v10++;
    *v4 = 15;
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = (_DWORD)v4 + 1;
    *(_DWORD *)(a1 + 312) = (_DWORD)v4;
    _libssh2_store_u32(&v10, *(unsigned int *)(a1 + 312));
    _libssh2_store_str(&v10, a2, v5);
    *(_DWORD *)(a1 + 300) = 2;
  }
  if ( *(_DWORD *)(a1 + 300) == 2 )
  {
    v6 = _libssh2_channel_write(v12, 0LL, *(_QWORD *)(a1 + 304), v14);
    if ( v6 == -37 )
      return 4294967259LL;
    if ( v14 != v6 )
    {
      (*(void ( **)(_QWORD, __int64))(v13 + 24))(*(_QWORD *)(a1 + 304), v13);
      *(_QWORD *)(a1 + 304) = 0LL;
      *(_DWORD *)(a1 + 300) = 0;
      return _libssh2_error(v13, 4294967289LL, "Unable to send FXP_RMDIR command");
    }
    (*(void ( **)(_QWORD, __int64))(v13 + 24))(*(_QWORD *)(a1 + 304), v13);
    *(_QWORD *)(a1 + 304) = 0LL;
    *(_DWORD *)(a1 + 300) = 3;
  }
  v7 = sub_378DE(a1, 101, *(_DWORD *)(a1 + 312), &v11, (unsigned __int64 *)&v9, 9uLL);
  if ( v7 == -37 )
    return 4294967259LL;
  if ( v7 == -38 )
  {
    if ( v9 )
      (*(void ( **)(__int64, __int64))(v13 + 24))(v11, v13);
    result = _libssh2_error(v13, 4294967265LL, "SFTP rmdir packet too short");
  }
  else if ( v7 )
  {
    *(_DWORD *)(a1 + 300) = 0;
    result = _libssh2_error(v13, v7, "Error waiting for FXP STATUS");
  }
  else
  {
    *(_DWORD *)(a1 + 300) = 0;
    v8 = _libssh2_ntohu32(v11 + 5);
    (*(void ( **)(__int64, __int64))(v13 + 24))(v11, v13);
    if ( v8 )
    {
      *(_DWORD *)(a1 + 64) = v8;
      result = _libssh2_error(v13, 4294967265LL, "SFTP Protocol Error");
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003DA56) ----------------------------------------------------
signed __int64  libssh2_sftp_rmdir_ex(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-24h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  time_t v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  if ( !a1 )
    return 4294967257LL;
  v6 = time(0LL);
  do
  {
    v5 = sub_3D711(a1, a2, v4);
    if ( v5 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v5 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v6);
  }
  while ( !v5 );
  return v5;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003DAE1) ----------------------------------------------------
__int64  sub_3DAE1(__int64 a1, __int64 a2, unsigned int a3, int a4, _QWORD *a5)
{
  int v5; // edx
  __int64 result; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  int v10; // eax
  __int64 v11; // rax
  _QWORD *s; // [rsp+0h] [rbp-60h]
  int v13; // [rsp+8h] [rbp-58h]
  unsigned int v14; // [rsp+Ch] [rbp-54h]
  int v15; // [rsp+20h] [rbp-40h]
  unsigned int v16; // [rsp+20h] [rbp-40h]
  int v17; // [rsp+24h] [rbp-3Ch]
  __int64 v18; // [rsp+28h] [rbp-38h]
  _BYTE *v19; // [rsp+30h] [rbp-30h]
  _BYTE *v20; // [rsp+38h] [rbp-28h]
  __int64 v21; // [rsp+40h] [rbp-20h]
  __int64 v22; // [rsp+48h] [rbp-18h]
  __int64 v23; // [rsp+50h] [rbp-10h]
  unsigned __int64 v24; // [rsp+58h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  s = a5;
  v24 = __readfsqword(0x28u);
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD *)(v21 + 96);
  if ( a4 == 2 )
    v5 = sub_36F43(*a5);
  else
    v5 = 0;
  v23 = v5 + v14 + 13;
  if ( !*(_DWORD *)(a1 + 316) )
  {
    *(_QWORD *)(a1 + 320) = (*(__int64 ( **)(__int64, __int64))(v22 + 8))(v23, v22);
    v19 = *(_BYTE **)(a1 + 320);
    if ( !*(_QWORD *)(a1 + 320) )
      return _libssh2_error(v22, 4294967290LL, "Unable to allocate memory for FXP_*STAT packet");
    _libssh2_store_u32(&v19, (unsigned int)(v23 - 4));
    if ( v13 == 1 )
    {
      v8 = v19++;
      *v8 = 7;
    }
    else if ( v13 == 2 )
    {
      v7 = v19++;
      *v7 = 9;
    }
    else
    {
      v9 = v19++;
      *v9 = 17;
    }
    v10 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v10 + 1;
    *(_DWORD *)(a1 + 328) = v10;
    _libssh2_store_u32(&v19, *(unsigned int *)(a1 + 328));
    _libssh2_store_str(&v19, a2, v14);
    if ( v13 == 2 )
    {
      v11 = sub_37B5D((__int64)v19, s);
      v19 += v11;
    }
    *(_DWORD *)(a1 + 316) = 2;
  }
  if ( *(_DWORD *)(a1 + 316) == 2 )
  {
    v15 = _libssh2_channel_write(v21, 0LL, *(_QWORD *)(a1 + 320), v23);
    if ( v15 == -37 )
      return 4294967259LL;
    if ( v23 != v15 )
    {
      (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 320), v22);
      *(_QWORD *)(a1 + 320) = 0LL;
      *(_DWORD *)(a1 + 316) = 0;
      return _libssh2_error(v22, 4294967289LL, "Unable to send STAT/LSTAT/SETSTAT command");
    }
    (*(void ( **)(_QWORD, __int64))(v22 + 24))(*(_QWORD *)(a1 + 320), v22);
    *(_QWORD *)(a1 + 320) = 0LL;
    *(_DWORD *)(a1 + 316) = 3;
  }
  v16 = sub_379D5((_QWORD *)a1, 2, (__int64)"iehe", *(_DWORD *)(a1 + 328), &v20, (unsigned __int64 *)&v18, 9uLL);
  if ( v16 == -37 )
    return 4294967259LL;
  if ( v16 == -38 )
  {
    if ( v18 )
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
    result = _libssh2_error(v22, 4294967265LL, "SFTP stat packet too short");
  }
  else if ( v16 )
  {
    *(_DWORD *)(a1 + 316) = 0;
    result = _libssh2_error(v22, v16, "Timeout waiting for status message");
  }
  else
  {
    *(_DWORD *)(a1 + 316) = 0;
    if ( *v20 == 101 )
    {
      v17 = _libssh2_ntohu32(v20 + 5);
      (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
      if ( v17 )
      {
        *(_DWORD *)(a1 + 64) = v17;
        result = _libssh2_error(v22, 4294967265LL, "SFTP Protocol Error");
      }
      else
      {
        memset(s, 0, 0x38uLL);
        result = 0LL;
      }
    }
    else
    {
      memset(s, 0, 0x38uLL);
      if ( (signed int)sub_37CB9(s, (__int64)(v20 + 5), v18 - 5) >= 0 )
      {
        (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
        result = 0LL;
      }
      else
      {
        (*(void ( **)(_BYTE *, __int64))(v22 + 24))(v20, v22);
        result = _libssh2_error(v22, 4294967265LL, "Attributes too short in SFTP fstat");
      }
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003DF67) ----------------------------------------------------
signed __int64  libssh2_sftp_stat_ex(__int64 a1, __int64 a2, unsigned int a3, int a4, _QWORD *a5)
{
  _QWORD *v6; // [rsp+0h] [rbp-30h]
  int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  unsigned int v9; // [rsp+24h] [rbp-Ch]
  time_t v10; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v6 = a5;
  if ( !a1 )
    return 4294967257LL;
  v10 = time(0LL);
  do
  {
    v9 = sub_3DAE1(a1, a2, v8, v7, v6);
    if ( v9 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v9 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v10);
  }
  while ( !v9 );
  return v9;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003E000) ----------------------------------------------------
__int64  sub_3E000(__int64 a1, __int64 a2, unsigned int a3, void *a4, unsigned int a5, int a6)
{
  int v6; // edx
  __int64 result; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  int v11; // eax
  int v12; // [rsp+Ch] [rbp-74h]
  void *dest; // [rsp+10h] [rbp-70h]
  unsigned int v14; // [rsp+18h] [rbp-68h]
  unsigned int v15; // [rsp+1Ch] [rbp-64h]
  unsigned int v16; // [rsp+34h] [rbp-4Ch]
  int v17; // [rsp+34h] [rbp-4Ch]
  unsigned int v18; // [rsp+34h] [rbp-4Ch]
  unsigned __int64 v19; // [rsp+38h] [rbp-48h]
  _BYTE *v20; // [rsp+40h] [rbp-40h]
  _BYTE *v21; // [rsp+48h] [rbp-38h]
  __int64 v22; // [rsp+50h] [rbp-30h]
  __int64 v23; // [rsp+58h] [rbp-28h]
  __int64 v24; // [rsp+60h] [rbp-20h]
  __int64 v25; // [rsp+68h] [rbp-18h]
  size_t n; // [rsp+70h] [rbp-10h]
  unsigned __int64 v27; // [rsp+78h] [rbp-8h]

  v15 = a3;
  dest = a4;
  v14 = a5;
  v12 = a6;
  v27 = __readfsqword(0x28u);
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD *)(v22 + 96);
  if ( a6 )
    v6 = 0;
  else
    v6 = a5 + 4;
  v24 = v6 + v15 + 13;
  if ( *(_DWORD *)(a1 + 12) <= 2u && a6 != 2 )
    return _libssh2_error(v23, 4294967265LL, "Server does not support SYMLINK or READLINK");
  if ( !*(_DWORD *)(a1 + 332) )
  {
    *(_QWORD *)(a1 + 336) = (*(__int64 ( **)(__int64, __int64))(v23 + 8))(v24, v23);
    v20 = *(_BYTE **)(a1 + 336);
    if ( !*(_QWORD *)(a1 + 336) )
      return _libssh2_error(v23, 4294967290LL, "Unable to allocate memory for SYMLINK/READLINK/REALPATH packet");
    _libssh2_store_u32(&v20, (unsigned int)(v24 - 4));
    if ( v12 )
    {
      if ( v12 == 2 )
      {
        v8 = v20++;
        *v8 = 16;
      }
      else
      {
        v10 = v20++;
        *v10 = 19;
      }
    }
    else
    {
      v9 = v20++;
      *v9 = 20;
    }
    v11 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v11 + 1;
    *(_DWORD *)(a1 + 344) = v11;
    _libssh2_store_u32(&v20, *(unsigned int *)(a1 + 344));
    _libssh2_store_str(&v20, a2, v15);
    if ( !v12 )
      _libssh2_store_str(&v20, dest, v14);
    *(_DWORD *)(a1 + 332) = 2;
  }
  if ( *(_DWORD *)(a1 + 332) == 2 )
  {
    v25 = _libssh2_channel_write(v22, 0LL, *(_QWORD *)(a1 + 336), v24);
    if ( v25 == -37 )
      return -37LL;
    if ( v24 != v25 )
    {
      (*(void ( **)(_QWORD, __int64))(v23 + 24))(*(_QWORD *)(a1 + 336), v23);
      *(_QWORD *)(a1 + 336) = 0LL;
      *(_DWORD *)(a1 + 332) = 0;
      return _libssh2_error(v23, 4294967289LL, "Unable to send SYMLINK/READLINK command");
    }
    (*(void ( **)(_QWORD, __int64))(v23 + 24))(*(_QWORD *)(a1 + 336), v23);
    *(_QWORD *)(a1 + 336) = 0LL;
    *(_DWORD *)(a1 + 332) = 3;
  }
  v16 = sub_379D5((_QWORD *)a1, 2, (__int64)"he", *(_DWORD *)(a1 + 344), &v21, &v19, 9uLL);
  if ( v16 == -37 )
    return 4294967259LL;
  if ( v16 == -38 )
  {
    if ( v19 )
      (*(void ( **)(_BYTE *, __int64))(v23 + 24))(v21, v23);
    result = _libssh2_error(v23, 4294967265LL, "SFTP symlink packet too short");
  }
  else if ( v16 )
  {
    *(_DWORD *)(a1 + 332) = 0;
    result = _libssh2_error(v23, v16, "Error waiting for status message");
  }
  else
  {
    *(_DWORD *)(a1 + 332) = 0;
    if ( *v21 == 101 )
    {
      v17 = _libssh2_ntohu32(v21 + 5);
      (*(void ( **)(_BYTE *, __int64))(v23 + 24))(v21, v23);
      if ( v17 )
      {
        *(_DWORD *)(a1 + 64) = v17;
        result = _libssh2_error(v23, 4294967265LL, "SFTP Protocol Error");
      }
      else
      {
        result = 0LL;
      }
    }
    else if ( (unsigned int)_libssh2_ntohu32(v21 + 5) )
    {
      if ( v19 > 0xC )
      {
        n = (unsigned int)_libssh2_ntohu32(v21 + 9);
        if ( n >= v14 )
        {
          v18 = -38;
        }
        else
        {
          memcpy(dest, v21 + 13, n);
          *((_BYTE *)dest + n) = 0;
          v18 = n;
        }
        (*(void ( **)(_BYTE *, __int64))(v23 + 24))(v21, v23);
        result = v18;
      }
      else
      {
        if ( v19 )
          (*(void ( **)(_BYTE *, __int64))(v23 + 24))(v21, v23);
        result = _libssh2_error(v23, 4294967265LL, "SFTP stat packet too short");
      }
    }
    else
    {
      (*(void ( **)(_BYTE *, __int64))(v23 + 24))(v21, v23);
      result = _libssh2_error(v23, 4294967265LL, "Invalid READLINK/REALPATH response, no name entries");
    }
  }
  return result;
}
// 8E20: using guessed type __int64  _libssh2_channel_write(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003E508) ----------------------------------------------------
signed __int64  libssh2_sftp_symlink_ex(__int64 a1, __int64 a2, unsigned int a3, void *a4, unsigned int a5, int a6)
{
  int v7; // [rsp+Ch] [rbp-34h]
  void *v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+18h] [rbp-28h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v11 = sub_3E000(a1, a2, v10, v8, v9, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 96LL) + 148LL) )
      break;
    v11 = _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)a1 + 96LL), v12);
  }
  while ( !v11 );
  return v11;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003E5AD) ----------------------------------------------------
__int64  libssh2_sftp_last_error(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *(unsigned int *)(a1 + 64);
  else
    result = 0LL;
  return result;
}

//----- (000000000003E5CE) ----------------------------------------------------
__int64  libssh2_sftp_get_channel(__int64 *a1)
{
  __int64 result; // rax

  if ( a1 )
    result = *a1;
  else
    result = 0LL;
  return result;
}

//----- (000000000003E5ED) ----------------------------------------------------
signed __int64  sub_3E5ED(__int64 a1, char *a2, char *a3, int a4)
{
  int v5; // [rsp+4h] [rbp-2Ch]
  char *dest; // [rsp+8h] [rbp-28h]
  char *src; // [rsp+10h] [rbp-20h]
  int v8; // [rsp+24h] [rbp-Ch]

  src = a2;
  dest = a3;
  v5 = a4;
  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 296) + 16LL);
  if ( a4 % v8 )
    __assert_fail("(len % blocksize) == 0", "/home/mantovan/Repositories/libssh2/src/transport.c", 0x8Bu, "decrypt");
  while ( v5 >= v8 )
  {
    if ( (*(unsigned int ( **)(__int64, char *, _QWORD, __int64))(*(_QWORD *)(a1 + 296) + 48LL))(
           a1,
           src,
           v8,
           a1 + 304) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 17016), a1);
      return 4294967284LL;
    }
    memcpy(dest, src, v8);
    v5 -= v8;
    dest += v8;
    src += v8;
  }
  return 0LL;
}

//----- (000000000003E6EB) ----------------------------------------------------
signed __int64  sub_3E6EB(__int64 a1, int a2)
{
  _BOOL4 v2; // eax
  signed __int64 result; // rax
  unsigned int v4; // [rsp+14h] [rbp-6Ch]
  unsigned int v5; // [rsp+14h] [rbp-6Ch]
  __int64 v6; // [rsp+18h] [rbp-68h]
  __int64 v7; // [rsp+20h] [rbp-60h]
  __int64 v8; // [rsp+28h] [rbp-58h]
  char s1; // [rsp+30h] [rbp-50h]
  unsigned __int64 v10; // [rsp+78h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v8 = a1 + 584;
  if ( !*(_DWORD *)(a1 + 54144) )
  {
    *(_DWORD *)(a1 + 54148) = 0;
    *(_QWORD *)(a1 + 54152) = (unsigned int)(*(_DWORD *)(v8 + 16408) - 1);
    if ( a2 )
    {
      (*(void ( **)(__int64, char *, _QWORD, __int64, signed __int64, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 312) + 24LL))(
        a1,
        &s1,
        *(unsigned int *)(a1 + 320),
        v8 + 0x4000,
        5LL,
        *(_QWORD *)(v8 + 16432),
        (unsigned int)*(_QWORD *)(a1 + 54152),
        a1 + 328);
      if ( memcmp(
             &s1,
             (const void *)(*(_QWORD *)(a1 + 54152) + *(_QWORD *)(v8 + 16432)),
             *(signed int *)(*(_QWORD *)(a1 + 312) + 8LL)) )
      {
        *(_DWORD *)(a1 + 54148) = -1;
      }
    }
    ++*(_DWORD *)(a1 + 320);
    *(_QWORD *)(a1 + 54152) -= *(unsigned __int8 *)(v8 + 16412);
    v2 = *(_QWORD *)(a1 + 448)
      && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 8LL)
      && (*(_DWORD *)(a1 + 104) & 4 || *(_DWORD *)(*(_QWORD *)(a1 + 448) + 12LL));
    if ( v2 && *(_QWORD *)(a1 + 344) )
    {
      v4 = (*(__int64 ( **)(__int64, __int64 *, __int64 *, signed __int64, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 336) + 32LL))(
             a1,
             &v6,
             &v7,
             40000LL,
             *(_QWORD *)(v8 + 16432),
             *(_QWORD *)(a1 + 54152),
             a1 + 344);
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(v8 + 16432), a1);
      if ( v4 )
        return v4;
      *(_QWORD *)(v8 + 16432) = v6;
      *(_QWORD *)(a1 + 54152) = v7;
    }
    *(_DWORD *)(a1 + 54160) = **(unsigned __int8 **)(v8 + 16432);
    *(_DWORD *)(a1 + 54144) = 2;
  }
  if ( *(_DWORD *)(a1 + 54144) != 2 )
    goto LABEL_25;
  v5 = _libssh2_packet_add(a1, *(_QWORD *)(v8 + 16432), *(_QWORD *)(a1 + 54152), *(unsigned int *)(a1 + 54148));
  if ( v5 == -37 )
    return 4294967259LL;
  if ( v5 )
  {
    *(_DWORD *)(a1 + 54144) = 0;
    result = v5;
  }
  else
  {
LABEL_25:
    *(_DWORD *)(a1 + 54144) = 0;
    result = *(unsigned int *)(a1 + 54160);
  }
  return result;
}
// 8A20: using guessed type __int64  _libssh2_packet_add(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000003EA10) ----------------------------------------------------
signed __int64  libssh2_transport_read(__int64 a1)
{
  signed __int64 result; // rax
  unsigned int v2; // er9
  int v3; // edx
  int v4; // eax
  int v5; // [rsp+14h] [rbp-6Ch]
  int v6; // [rsp+18h] [rbp-68h]
  int v7; // [rsp+1Ch] [rbp-64h]
  int v8; // [rsp+20h] [rbp-60h]
  int v9; // [rsp+24h] [rbp-5Ch]
  unsigned int v10; // [rsp+28h] [rbp-58h]
  unsigned int v11; // [rsp+28h] [rbp-58h]
  unsigned int v12; // [rsp+28h] [rbp-58h]
  int v13; // [rsp+30h] [rbp-50h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  unsigned __int64 v15; // [rsp+48h] [rbp-38h]
  char src; // [rsp+50h] [rbp-30h]
  char v17; // [rsp+54h] [rbp-2Ch]
  _BYTE v18[3]; // [rsp+55h] [rbp-2Bh]
  unsigned __int64 v19; // [rsp+78h] [rbp-8h]

  v19 = __readfsqword(0x28u);
  v9 = 1;
  *(_DWORD *)(a1 + 560) &= 0xFFFFFFFE;
  if ( *(_DWORD *)(a1 + 104) & 1 )
  {
    if ( !(*(_DWORD *)(a1 + 104) & 8) )
    {
      v10 = _libssh2_kex_exchange(a1, 1LL, a1 + 52432);
      if ( v10 )
        return v10;
    }
  }
  if ( *(_DWORD *)(a1 + 53384) != 11 )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(a1 + 556) == -1 )
        return 0LL;
      if ( *(_DWORD *)(a1 + 104) & 2 )
      {
        v8 = *(_DWORD *)(*(_QWORD *)(a1 + 296) + 16LL);
      }
      else
      {
        v9 = 0;
        v8 = 5;
      }
      v5 = *(unsigned __int64 *)(a1 + 16976) - *(unsigned __int64 *)(a1 + 16984);
      if ( v5 < 0 )
        __assert_fail(
          "remainbuf >= 0",
          "/home/mantovan/Repositories/libssh2/src/transport.c",
          0x15Du,
          "_libssh2_transport_read");
      if ( v5 < v8 )
      {
        if ( v5 )
        {
          memmove((void *)(a1 + 584), (const void *)(a1 + 584 + *(_QWORD *)(a1 + 16984)), v5);
          *(_QWORD *)(a1 + 16984) = 0LL;
          *(_QWORD *)(a1 + 16976) = v5;
        }
        else
        {
          *(_QWORD *)(a1 + 16976) = 0LL;
          *(_QWORD *)(a1 + 16984) = *(_QWORD *)(a1 + 16976);
        }
        if ( *(_DWORD *)(a1 + 108) )
          v2 = 0;
        else
          v2 = 0x4000;
        v14 = (*(__int64 ( **)(_QWORD, __int64, _QWORD, _QWORD, __int64))(a1 + 80))(
                *(unsigned int *)(a1 + 552),
                a1 + 584 + v5,
                0x4000 - v5,
                v2,
                a1);
        if ( v14 <= 0 )
        {
          if ( v14 >= 0 || v14 != -11 )
            return 4294967253LL;
          *(_DWORD *)(a1 + 560) |= 1u;
          return 4294967259LL;
        }
        *(_QWORD *)(a1 + 16976) += v14;
        v5 = *(unsigned __int64 *)(a1 + 16976) - *(unsigned __int64 *)(a1 + 16984);
      }
      v6 = v5;
      if ( !*(_QWORD *)(a1 + 17008) )
      {
        if ( v5 < v8 )
        {
          *(_DWORD *)(a1 + 560) |= 1u;
          return 4294967259LL;
        }
        if ( v9 )
        {
          v11 = sub_3E5ED(a1, (char *)(*(_QWORD *)(a1 + 16984) + a1 + 584), &src, v8);
          if ( v11 )
            return v11;
          memcpy((void *)(a1 + 16968), &src, 5uLL);
        }
        else
        {
          memcpy(&src, (const void *)(a1 + 584 + *(_QWORD *)(a1 + 16984)), v8);
        }
        *(_QWORD *)(a1 + 16984) += v8;
        *(_DWORD *)(a1 + 16992) = _libssh2_ntohu32(&src);
        if ( !*(_DWORD *)(a1 + 16992) )
          return 4294967284LL;
        if ( *(_DWORD *)(a1 + 16992) > 0x9C40u )
          return 4294967255LL;
        *(_BYTE *)(a1 + 16996) = v17;
        if ( *(unsigned __int8 *)(a1 + 16996) > (unsigned int)(*(_DWORD *)(a1 + 16992) - 1) )
          return 4294967284LL;
        if ( v9 )
          v4 = *(_DWORD *)(*(_QWORD *)(a1 + 312) + 8LL);
        else
          v4 = 0;
        v3 = *(_DWORD *)(a1 + 16992);
        v15 = (unsigned int)(v3 + v4 - 1);
        if ( v15 > 0x9C40 || v3 + v4 == 1 )
          return 4294967255LL;
        *(_QWORD *)(a1 + 17016) = (*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(v15, a1);
        if ( !*(_QWORD *)(a1 + 17016) )
          return 4294967290LL;
        *(_QWORD *)(a1 + 17008) = v15;
        *(_QWORD *)(a1 + 17024) = *(_QWORD *)(a1 + 17016);
        if ( v8 > 5 )
        {
          if ( v8 - 5 > (signed int)v15 )
            return 4294967255LL;
          memcpy(*(void **)(a1 + 17024), v18, v8 - 5);
          *(_QWORD *)(a1 + 17024) += v8 - 5LL;
        }
        *(_QWORD *)(a1 + 17000) = *(_QWORD *)(a1 + 17024) - *(_QWORD *)(a1 + 17016);
        v6 = v5 - v8;
      }
      if ( v6 > (signed int)(*(unsigned __int64 *)(a1 + 17008) - *(_QWORD *)(a1 + 17000)) )
        v6 = *(unsigned __int64 *)(a1 + 17008) - *(unsigned __int64 *)(a1 + 17000);
      if ( v9 )
      {
        v13 = *(_DWORD *)(*(_QWORD *)(a1 + 312) + 8LL);
        if ( *(_QWORD *)(a1 + 17000) + (signed __int64)v6 <= (unsigned __int64)(*(_QWORD *)(a1 + 17008) - v13) )
        {
          v7 = v6;
          if ( v6 % v8 )
          {
            v7 = v6 - v6 % v8;
            v6 = 0;
          }
        }
        else
        {
          v7 = *(unsigned __int64 *)(a1 + 17008) - v13 - *(unsigned __int64 *)(a1 + 17000);
        }
      }
      else
      {
        v7 = 0;
      }
      if ( v7 > 0 )
      {
        v12 = sub_3E5ED(a1, (char *)(*(_QWORD *)(a1 + 16984) + a1 + 584), *(char **)(a1 + 17024), v7);
        if ( v12 )
        {
          *(_QWORD *)(a1 + 17008) = 0LL;
          return v12;
        }
        *(_QWORD *)(a1 + 16984) += v7;
        *(_QWORD *)(a1 + 17024) += v7;
        *(_QWORD *)(a1 + 17000) += v7;
        v6 -= v7;
      }
      if ( v6 > 0 )
      {
        if ( v6 > (signed int)(*(unsigned __int64 *)(a1 + 17008) - (*(_DWORD *)(a1 + 17024) - *(_DWORD *)(a1 + 17016))) )
          return 4294967255LL;
        memcpy(*(void **)(a1 + 17024), (const void *)(a1 + 584 + *(_QWORD *)(a1 + 16984)), v6);
        *(_QWORD *)(a1 + 16984) += v6;
        *(_QWORD *)(a1 + 17024) += v6;
        *(_QWORD *)(a1 + 17000) += v6;
      }
      if ( (unsigned int)*(_QWORD *)(a1 + 17008) == (unsigned int)*(_QWORD *)(a1 + 17000) )
      {
        LODWORD(result) = sub_3E6EB(a1, v9);
        goto LABEL_72;
      }
    }
  }
  *(_DWORD *)(a1 + 53384) = 0;
  v9 = *(_DWORD *)(a1 + 53388);
  LODWORD(result) = sub_3E6EB(a1, v9);
LABEL_72:
  if ( (_DWORD)result == -37 )
  {
    if ( *(_DWORD *)(a1 + 53936) )
    {
      *(_DWORD *)(a1 + 53388) = v9;
      *(_DWORD *)(a1 + 53384) = 11;
    }
    result = (unsigned int)result;
  }
  else
  {
    *(_QWORD *)(a1 + 17008) = 0LL;
    result = (unsigned int)result;
  }
  return result;
}
// 8F00: using guessed type __int64  _libssh2_kex_exchange(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);

//----- (000000000003F253) ----------------------------------------------------
signed __int64  sub_3F253(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  signed __int64 result; // rax
  unsigned int v5; // er9
  __int64 v6; // [rsp+30h] [rbp-10h]
  __int64 v7; // [rsp+38h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 52048) )
  {
    if ( a2 == *(_QWORD *)(a1 + 52040) && a3 == *(_QWORD *)(a1 + 52048) )
    {
      *a4 = 1LL;
      v6 = *(signed int *)(a1 + 52032) - *(_QWORD *)(a1 + 52056);
      if ( *(_DWORD *)(a1 + 108) )
        v5 = 0;
      else
        v5 = 0x4000;
      v7 = (*(__int64 ( **)(_QWORD, __int64, __int64, _QWORD, __int64))(a1 + 72))(
             *(unsigned int *)(a1 + 552),
             a1 + 584 + *(_QWORD *)(a1 + 52056) + 16448LL,
             v6,
             v5,
             a1);
      if ( v7 == v6 )
      {
        *(_DWORD *)(a1 + 52032) = 0;
        *(_QWORD *)(a1 + 52048) = 0LL;
        result = 0LL;
      }
      else if ( v7 >= 0 )
      {
        *(_QWORD *)(a1 + 52056) += v7;
        if ( v7 >= v6 )
          result = 0LL;
        else
          result = 4294967259LL;
      }
      else if ( v7 == -11 )
      {
        *(_DWORD *)(a1 + 560) |= 2u;
        result = 4294967259LL;
      }
      else
      {
        result = 4294967289LL;
      }
    }
    else
    {
      result = 4294967257LL;
    }
  }
  else
  {
    *a4 = 0LL;
    result = 0LL;
  }
  return result;
}

//----- (000000000003F3E4) ----------------------------------------------------
signed __int64  libssh2_transport_send(__int64 a1, const void *a2, __int64 a3, void *a4, size_t a5)
{
  signed int v5; // eax
  signed __int64 result; // rax
  _BOOL4 v7; // eax
  int v8; // edx
  unsigned int v9; // er9
  __int64 v10; // rax
  size_t v11; // [rsp+8h] [rbp-98h]
  void *v12; // [rsp+10h] [rbp-90h]
  size_t n; // [rsp+18h] [rbp-88h]
  size_t na; // [rsp+18h] [rbp-88h]
  signed int v15; // [rsp+38h] [rbp-68h]
  unsigned int v16; // [rsp+3Ch] [rbp-64h]
  unsigned int v17; // [rsp+3Ch] [rbp-64h]
  unsigned int v18; // [rsp+3Ch] [rbp-64h]
  signed int v19; // [rsp+40h] [rbp-60h]
  int v20; // [rsp+44h] [rbp-5Ch]
  int v21; // [rsp+4Ch] [rbp-54h]
  __int64 v22; // [rsp+50h] [rbp-50h]
  __int64 v23; // [rsp+58h] [rbp-48h]
  __int64 v24; // [rsp+60h] [rbp-40h]
  unsigned __int64 i; // [rsp+68h] [rbp-38h]
  __int64 v26; // [rsp+70h] [rbp-30h]
  const void *v27; // [rsp+78h] [rbp-28h]
  __int64 v28; // [rsp+80h] [rbp-20h]
  unsigned __int64 v29; // [rsp+88h] [rbp-18h]
  unsigned __int64 v30; // [rsp+90h] [rbp-10h]
  unsigned __int64 v31; // [rsp+98h] [rbp-8h]

  n = a3;
  v12 = a4;
  v11 = a5;
  v31 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 104) & 2 )
    v5 = *(_DWORD *)(*(_QWORD *)(a1 + 408) + 16LL);
  else
    v5 = 8;
  v19 = v5;
  v26 = a1 + 584;
  v27 = a2;
  v28 = a3;
  if ( *(_DWORD *)(a1 + 104) & 1 )
  {
    if ( !(*(_DWORD *)(a1 + 104) & 8) )
    {
      v16 = _libssh2_kex_exchange(a1, 1LL, a1 + 52432);
      if ( v16 )
        return v16;
    }
  }
  v17 = sub_3F253(a1, (__int64)a2, n, &v22);
  if ( v17 )
    return v17;
  *(_DWORD *)(a1 + 560) &= 0xFFFFFFFD;
  if ( v22 )
    return 0LL;
  v20 = (*(_DWORD *)(a1 + 104) >> 1) & 1;
  v7 = *(_QWORD *)(a1 + 448)
    && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 8LL)
    && (*(_DWORD *)(a1 + 104) & 4 || *(_DWORD *)(*(_QWORD *)(a1 + 448) + 12LL));
  if ( v20 && v7 && *(_QWORD *)(a1 + 456) )
  {
    v23 = 34739LL;
    v24 = 34739LL;
    v18 = (*(__int64 ( **)(__int64, __int64, __int64 *, const void *, size_t, __int64))(*(_QWORD *)(a1 + 448)
                                                                                                + 24LL))(
            a1,
            v26 + 16453,
            &v23,
            a2,
            n,
            a1 + 456);
    if ( v18 )
      return v18;
    if ( v12 && v11 )
    {
      v24 -= v23;
      v18 = (*(__int64 ( **)(__int64, __int64, __int64 *, void *, size_t, __int64))(*(_QWORD *)(a1 + 448)
                                                                                            + 24LL))(
              a1,
              v23 + 16453 + v26,
              &v24,
              v12,
              v11,
              a1 + 456);
    }
    else
    {
      v24 = 0LL;
    }
    if ( v18 )
      return v18;
    na = v23 + v24;
  }
  else
  {
    if ( n + v11 > 0x87B7 )
      return 4294967262LL;
    memcpy((void *)(v26 + 16453), a2, n);
    if ( v12 && v11 )
      memcpy((void *)(n + 16453 + v26), v12, v11);
    na = v11 + n;
  }
  v29 = na + 5;
  v15 = v19 - (na + 5) % v19;
  if ( v15 <= 3 )
    v15 += v19;
  v29 += v15;
  if ( v20 )
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 424) + 8LL);
  else
    v8 = 0;
  v21 = v8 + v29;
  _libssh2_htonu32(v26 + 16448, (unsigned int)(v29 - 4));
  *(_BYTE *)(v26 + 16452) = v15;
  RAND_bytes(na + 5 + v26 + 16448, (unsigned int)v15);
  if ( v20 )
  {
    (*(void ( **)(__int64, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 424) + 24LL))(
      a1,
      v26 + 16448 + v29,
      *(unsigned int *)(a1 + 432),
      v26 + 16448,
      (unsigned int)v29,
      0LL,
      0LL,
      a1 + 440);
    for ( i = 0LL; i < v29; i += *(signed int *)(*(_QWORD *)(a1 + 408) + 16LL) )
    {
      v30 = i + 16448 + v26;
      if ( (*(unsigned int ( **)(__int64, unsigned __int64, _QWORD, __int64))(*(_QWORD *)(a1 + 408) + 48LL))(
             a1,
             v30,
             *(signed int *)(*(_QWORD *)(a1 + 408) + 16LL),
             a1 + 416) )
      {
        return 4294967252LL;
      }
    }
  }
  ++*(_DWORD *)(a1 + 432);
  if ( *(_DWORD *)(a1 + 108) )
    v9 = 0;
  else
    v9 = 0x4000;
  v22 = (*(__int64 ( **)(_QWORD, __int64, _QWORD, _QWORD, __int64))(a1 + 72))(
          *(unsigned int *)(a1 + 552),
          v26 + 16448,
          v21,
          v9,
          a1);
  if ( v21 == v22 )
  {
    *(_QWORD *)(v26 + 51456) = 0LL;
    *(_QWORD *)(v26 + 51464) = 0LL;
    result = 0LL;
  }
  else if ( v22 < 0 && v22 != -11 )
  {
    result = 4294967289LL;
  }
  else
  {
    *(_DWORD *)(a1 + 560) |= 2u;
    *(_QWORD *)(v26 + 51456) = v27;
    *(_QWORD *)(v26 + 51464) = v28;
    v10 = v22;
    if ( v22 < 0 )
      v10 = 0LL;
    *(_QWORD *)(v26 + 51472) = v10;
    *(_DWORD *)(v26 + 51448) = v21;
    result = 4294967259LL;
  }
  return result;
}
// 8F00: using guessed type __int64  _libssh2_kex_exchange(_QWORD, _QWORD, _QWORD);
// 9680: using guessed type __int64  RAND_bytes(_QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);

//----- (000000000003F9F0) ----------------------------------------------------
__int64  sub_3F9F0(__int64 a1, __int64 a2, unsigned int a3)
{
  _BYTE *v4; // rax
  unsigned int v5; // [rsp+Ch] [rbp-34h]
  int v6; // [rsp+24h] [rbp-1Ch]
  unsigned int v7; // [rsp+24h] [rbp-1Ch]
  _BYTE *v8; // [rsp+28h] [rbp-18h]
  size_t n; // [rsp+30h] [rbp-10h]
  unsigned __int64 v10; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v10 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53392) )
  {
    memset((void *)(a1 + 53416), 0, 8uLL);
    *(_QWORD *)(a1 + 53408) = v5 + 27;
    *(_QWORD *)(a1 + 53400) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53408), a1);
    v8 = *(_BYTE **)(a1 + 53400);
    if ( !*(_QWORD *)(a1 + 53400) )
    {
      _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for userauth_list");
      return 0LL;
    }
    v4 = v8++;
    *v4 = 50;
    _libssh2_store_str(&v8, a2, v5);
    _libssh2_store_str(&v8, "ssh-connection", 14LL);
    _libssh2_store_u32(&v8, 4LL);
    *(_DWORD *)(a1 + 53392) = 2;
  }
  if ( *(_DWORD *)(a1 + 53392) == 2 )
  {
    v6 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53400), *(_QWORD *)(a1 + 53408), "none", 4LL);
    if ( v6 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block requesting userauth list");
      return 0LL;
    }
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53400), a1);
    *(_QWORD *)(a1 + 53400) = 0LL;
    if ( v6 )
    {
      _libssh2_error(a1, 4294967289LL, "Unable to send userauth-none request");
      *(_DWORD *)(a1 + 53392) = 0;
      return 0LL;
    }
    *(_DWORD *)(a1 + 53392) = 3;
  }
  if ( *(_DWORD *)(a1 + 53392) == 3 )
  {
    v7 = _libssh2_packet_requirev(a1, "43", a1 + 53400, a1 + 53408, 0LL, 0LL, 0LL, a1 + 53416);
    if ( v7 == -37 )
    {
      _libssh2_error(a1, 4294967259LL, "Would block requesting userauth list");
      return 0LL;
    }
    if ( v7 || !*(_QWORD *)(a1 + 53408) )
    {
      _libssh2_error(a1, v7, "Failed getting response");
      *(_DWORD *)(a1 + 53392) = 0;
      return 0LL;
    }
    if ( **(_BYTE **)(a1 + 53400) == 52 )
    {
      _libssh2_error(a1, 0LL, "No error");
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53400), a1);
      *(_QWORD *)(a1 + 53400) = 0LL;
      *(_DWORD *)(a1 + 104) |= 4u;
      *(_DWORD *)(a1 + 53392) = 0;
      return 0LL;
    }
    if ( *(_QWORD *)(a1 + 53408) <= 4uLL )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53400), a1);
      *(_QWORD *)(a1 + 53400) = 0LL;
      _libssh2_error(a1, 4294967282LL, "Unexpected packet size");
      return 0LL;
    }
    n = (unsigned int)_libssh2_ntohu32(*(_QWORD *)(a1 + 53400) + 1LL);
    if ( n >= *(_QWORD *)(a1 + 53408) - 5LL )
    {
      _libssh2_error(a1, 4294967255LL, "Unexpected userauth list size");
      return 0LL;
    }
    memmove(*(void **)(a1 + 53400), (const void *)(*(_QWORD *)(a1 + 53400) + 5LL), n);
    *(_BYTE *)(*(_QWORD *)(a1 + 53400) + n) = 0;
  }
  *(_DWORD *)(a1 + 53392) = 0;
  return *(_QWORD *)(a1 + 53400);
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000003FE69) ----------------------------------------------------
__int64  libssh2_userauth_list(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // [rsp+Ch] [rbp-34h]
  time_t v5; // [rsp+30h] [rbp-10h]
  __int64 v6; // [rsp+38h] [rbp-8h]

  v4 = a3;
  v5 = time(0LL);
  do
    v6 = sub_3F9F0(a1, a2, v4);
  while ( *(_DWORD *)(a1 + 148)
       && !v6
       && (unsigned int)libssh2_session_last_errno(a1) == -37
       && !(unsigned int)_libssh2_wait_socket(a1, v5) );
  return v6;
}
// 8CA0: using guessed type __int64  libssh2_session_last_errno(_QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (000000000003FEEC) ----------------------------------------------------
__int64  libssh2_userauth_authenticated(__int64 a1)
{
  return (*(_DWORD *)(a1 + 104) >> 2) & 1;
}

//----- (000000000003FF03) ----------------------------------------------------
__int64  sub_3FF03(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, void ( *a6)(__int64, signed __int64, signed __int64, __int64))
{
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  void ( *v11)(__int64, signed __int64, signed __int64, __int64); // [rsp+8h] [rbp-48h]
  __int64 v12; // [rsp+10h] [rbp-40h]
  unsigned int v13; // [rsp+18h] [rbp-38h]
  unsigned int v14; // [rsp+1Ch] [rbp-34h]
  int v15; // [rsp+3Ch] [rbp-14h]
  unsigned int v16; // [rsp+3Ch] [rbp-14h]
  int v17; // [rsp+3Ch] [rbp-14h]
  _BYTE *v18; // [rsp+40h] [rbp-10h]
  unsigned __int64 v19; // [rsp+48h] [rbp-8h]

  v14 = a3;
  v12 = a4;
  v13 = a5;
  v11 = a6;
  v19 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53424) )
  {
    memset((void *)(a1 + 53472), 0, 8uLL);
    *(_QWORD *)(a1 + 53448) = v14 + 40;
    *(_BYTE *)(a1 + 53440) = -61;
    *(_QWORD *)(a1 + 53432) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53448), a1);
    v18 = *(_BYTE **)(a1 + 53432);
    if ( !*(_QWORD *)(a1 + 53432) )
      return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for userauth-password request");
    v7 = v18++;
    *v7 = 50;
    _libssh2_store_str(&v18, a2, v14);
    _libssh2_store_str(&v18, "ssh-connection", 14LL);
    _libssh2_store_str(&v18, "password", 8LL);
    v8 = v18++;
    *v8 = 0;
    _libssh2_store_u32(&v18, v13);
    *(_DWORD *)(a1 + 53424) = 2;
  }
  if ( *(_DWORD *)(a1 + 53424) != 2 )
  {
    while ( 1 )
    {
LABEL_11:
      if ( *(_DWORD *)(a1 + 53424) != 3 && *(_DWORD *)(a1 + 53424) != 4 && *(_DWORD *)(a1 + 53424) != 5 )
      {
LABEL_48:
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
        *(_QWORD *)(a1 + 53432) = 0LL;
        *(_DWORD *)(a1 + 53424) = 0;
        return _libssh2_error(a1, 4294967278LL, "Authentication failed");
      }
      if ( *(_DWORD *)(a1 + 53424) == 3 )
      {
        v16 = _libssh2_packet_requirev(a1, "43<", a1 + 53432, a1 + 53448, 0LL, 0LL, 0LL, a1 + 53472);
        if ( v16 )
        {
          if ( v16 != -37 )
            *(_DWORD *)(a1 + 53424) = 0;
          return _libssh2_error(a1, v16, "Waiting for password response");
        }
        if ( !*(_QWORD *)(a1 + 53448) )
        {
          *(_DWORD *)(a1 + 53424) = 0;
          return _libssh2_error(a1, 4294967282LL, "Unexpected packet size");
        }
        if ( **(_BYTE **)(a1 + 53432) == 52 )
        {
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
          *(_QWORD *)(a1 + 53432) = 0LL;
          *(_DWORD *)(a1 + 104) |= 4u;
          *(_DWORD *)(a1 + 53424) = 0;
          return 0LL;
        }
        if ( **(_BYTE **)(a1 + 53432) == 51 )
        {
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
          *(_QWORD *)(a1 + 53432) = 0LL;
          *(_DWORD *)(a1 + 53424) = 0;
          return _libssh2_error(a1, 4294967278LL, "Authentication failed (username/password)");
        }
        *(_QWORD *)(a1 + 53456) = 0LL;
        *(_DWORD *)(a1 + 53464) = 0;
        *(_DWORD *)(a1 + 53424) = 4;
      }
      if ( !*(_QWORD *)(a1 + 53448) )
      {
        *(_DWORD *)(a1 + 53424) = 0;
        return _libssh2_error(a1, 4294967282LL, "Unexpected packet size");
      }
      if ( **(_BYTE **)(a1 + 53432) != 60 && *(_BYTE *)(a1 + 53440) != 60 )
        goto LABEL_48;
      *(_BYTE *)(a1 + 53440) = 60;
      if ( *(_DWORD *)(a1 + 53424) != 4 && *(_DWORD *)(a1 + 53424) != 5 )
      {
        *(_DWORD *)(a1 + 53424) = 0;
        return _libssh2_error(a1, 4294967281LL, "Password Expired, and no callback specified");
      }
      if ( *(_DWORD *)(a1 + 53424) == 4 )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
        *(_QWORD *)(a1 + 53432) = 0LL;
      }
      if ( !v11 )
        goto LABEL_48;
      if ( *(_DWORD *)(a1 + 53424) == 4 )
      {
        v11(a1, a1 + 53456, a1 + 53464, a1);
        if ( !*(_QWORD *)(a1 + 53456) )
          return _libssh2_error(a1, 4294967281LL, "Password expired, and callback failed");
        *(_QWORD *)(a1 + 53448) = v14 + v13 + 44;
        *(_QWORD *)(a1 + 53432) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53448), a1);
        v18 = *(_BYTE **)(a1 + 53432);
        if ( !*(_QWORD *)(a1 + 53432) )
        {
          (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53456), a1);
          *(_QWORD *)(a1 + 53456) = 0LL;
          return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for userauth password change request");
        }
        v9 = v18++;
        *v9 = 50;
        _libssh2_store_str(&v18, a2, v14);
        _libssh2_store_str(&v18, "ssh-connection", 14LL);
        _libssh2_store_str(&v18, "password", 8LL);
        v10 = v18++;
        *v10 = 1;
        _libssh2_store_str(&v18, v12, v13);
        _libssh2_store_u32(&v18, *(unsigned int *)(a1 + 53464));
        *(_DWORD *)(a1 + 53424) = 5;
      }
      if ( *(_DWORD *)(a1 + 53424) != 5 )
        goto LABEL_48;
      v17 = _libssh2_transport_send(
              a1,
              *(_QWORD *)(a1 + 53432),
              *(_QWORD *)(a1 + 53448),
              *(_QWORD *)(a1 + 53456),
              *(signed int *)(a1 + 53464));
      if ( v17 == -37 )
        return _libssh2_error(a1, 4294967259LL, "Would block waiting");
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
      *(_QWORD *)(a1 + 53432) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53456), a1);
      *(_QWORD *)(a1 + 53456) = 0LL;
      if ( v17 )
        return _libssh2_error(a1, 4294967289LL, "Unable to send userauth password-change request");
      *(_DWORD *)(a1 + 53424) = 3;
    }
  }
  v15 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53432), *(_QWORD *)(a1 + 53448), v12, v13);
  if ( v15 == -37 )
    return _libssh2_error(a1, 4294967259LL, "Would block writing password request");
  (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53432), a1);
  *(_QWORD *)(a1 + 53432) = 0LL;
  if ( !v15 )
  {
    *(_DWORD *)(a1 + 53424) = 3;
    goto LABEL_11;
  }
  *(_DWORD *)(a1 + 53424) = 0;
  return _libssh2_error(a1, 4294967289LL, "Unable to send userauth-password request");
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (000000000004076A) ----------------------------------------------------
__int64  libssh2_userauth_password_ex(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, void ( *a6)(__int64, signed __int64, signed __int64, __int64))
{
  void ( *v7)(__int64, signed __int64, signed __int64, __int64); // [rsp+8h] [rbp-38h]
  __int64 v8; // [rsp+10h] [rbp-30h]
  unsigned int v9; // [rsp+18h] [rbp-28h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v9 = a5;
  v7 = a6;
  v12 = time(0LL);
  do
  {
    v11 = sub_3FF03(a1, a2, v10, v8, v9, v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v11 = _libssh2_wait_socket(a1, v12);
  }
  while ( !v11 );
  return v11;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000407F3) ----------------------------------------------------
__int64  sub_407F3(size_t n, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, void *a6, size_t na)
{
  __int64 result; // rax
  void *src; // [rsp+0h] [rbp-70h]
  _QWORD *v9; // [rsp+8h] [rbp-68h]
  _QWORD *v10; // [rsp+10h] [rbp-60h]
  _QWORD *v11; // [rsp+18h] [rbp-58h]
  unsigned int v12; // [rsp+3Ch] [rbp-34h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  char *v14; // [rsp+48h] [rbp-28h]
  size_t v15; // [rsp+50h] [rbp-20h]
  void *dest; // [rsp+58h] [rbp-18h]
  void *s; // [rsp+60h] [rbp-10h]
  unsigned __int64 v18; // [rsp+68h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  src = a6;
  v18 = __readfsqword(0x28u);
  dest = 0LL;
  v15 = na;
  if ( na <= 1 )
    return _libssh2_error(n, 4294967280LL, "Invalid data in public key file");
  dest = (void *)(*(__int64 ( **)(size_t, size_t))(n + 8))(na, n);
  if ( !dest )
    return _libssh2_error(n, 4294967290LL, "Unable to allocate memory for public key data");
  memcpy(dest, src, na);
  while ( v15 && (*__ctype_b_loc())[*((unsigned __int8 *)dest + v15 - 1)] & 0x2000 )
    --v15;
  if ( v15 )
  {
    s = memchr(dest, 32, v15);
    if ( s )
    {
      s = (char *)s + 1;
      v14 = (char *)memchr(s, 32, v15 - ((_BYTE *)s - (_BYTE *)dest));
      if ( !v14 )
        v14 = (char *)dest + v15;
      if ( (unsigned int)libssh2_base64_decode(n, &v13, &v12, s, (unsigned int)((_DWORD)v14 - (_DWORD)s)) )
      {
        (*(void ( **)(void *, size_t))(n + 24))(dest, n);
        result = _libssh2_error(n, 4294967280LL, "Invalid key data, not base64 encoded");
      }
      else
      {
        *a2 = dest;
        *v11 = (_BYTE *)s - (_BYTE *)dest - 1;
        *v10 = v13;
        *v9 = v12;
        result = 0LL;
      }
    }
    else
    {
      (*(void ( **)(void *, size_t))(n + 24))(dest, n);
      result = _libssh2_error(n, 4294967280LL, "Invalid public key data");
    }
  }
  else
  {
    (*(void ( **)(void *, size_t))(n + 24))(dest, n);
    result = _libssh2_error(n, 4294967280LL, "Missing public key data");
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9250: using guessed type __int64  libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000040A80) ----------------------------------------------------
__int64  sub_40A80(__int64 a1, void **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, const char *a6)
{
  __int64 result; // rax
  size_t v7; // rax
  signed __int64 v8; // rax
  _QWORD *v9; // [rsp+8h] [rbp-78h]
  _QWORD *v10; // [rsp+10h] [rbp-70h]
  _QWORD *v11; // [rsp+18h] [rbp-68h]
  char ptr; // [rsp+3Bh] [rbp-45h]
  unsigned int v13; // [rsp+3Ch] [rbp-44h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  char *v15; // [rsp+48h] [rbp-38h]
  size_t n; // [rsp+50h] [rbp-30h]
  void *s; // [rsp+58h] [rbp-28h]
  FILE *stream; // [rsp+60h] [rbp-20h]
  void *v19; // [rsp+68h] [rbp-18h]
  __int64 v20; // [rsp+70h] [rbp-10h]
  unsigned __int64 v21; // [rsp+78h] [rbp-8h]

  v11 = a3;
  v10 = a4;
  v9 = a5;
  v21 = __readfsqword(0x28u);
  s = 0LL;
  n = 0LL;
  stream = fopen(a6, "r");
  if ( !stream )
    return _libssh2_error(a1, 4294967280LL, "Unable to open public key file");
  while ( !feof(stream) && fread(&ptr, 1uLL, 1uLL, stream) == 1 && ptr != 13 && ptr != 10 )
    ++n;
  rewind(stream);
  if ( n > 1 )
  {
    s = (void *)(*(__int64 ( **)(size_t, __int64))(a1 + 8))(n, a1);
    if ( s )
    {
      v7 = fread(s, 1uLL, n, stream);
      if ( n == v7 )
      {
        fclose(stream);
        while ( n && (*__ctype_b_loc())[*((unsigned __int8 *)s + n - 1)] & 0x2000 )
          --n;
        if ( n )
        {
          v19 = memchr(s, 32, n);
          if ( v19 )
          {
            v19 = (char *)v19 + 1;
            if ( v19 <= s )
              v8 = 0LL;
            else
              v8 = (_BYTE *)v19 - (_BYTE *)s;
            v20 = v8;
            v15 = (char *)memchr(v19, 32, n - v8);
            if ( !v15 )
              v15 = (char *)s + n;
            if ( (unsigned int)libssh2_base64_decode(a1, &v14, &v13, v19, (unsigned int)((_DWORD)v15 - (_DWORD)v19)) )
            {
              (*(void ( **)(void *, __int64))(a1 + 24))(s, a1);
              result = _libssh2_error(a1, 4294967280LL, "Invalid key data, not base64 encoded");
            }
            else
            {
              *a2 = s;
              *v11 = (_BYTE *)v19 - (_BYTE *)s - 1;
              *v10 = v14;
              *v9 = v13;
              result = 0LL;
            }
          }
          else
          {
            (*(void ( **)(void *, __int64))(a1 + 24))(s, a1);
            result = _libssh2_error(a1, 4294967280LL, "Invalid public key data");
          }
        }
        else
        {
          (*(void ( **)(void *, __int64))(a1 + 24))(s, a1);
          result = _libssh2_error(a1, 4294967280LL, "Missing public key data");
        }
      }
      else
      {
        (*(void ( **)(void *, __int64))(a1 + 24))(s, a1);
        fclose(stream);
        result = _libssh2_error(a1, 4294967280LL, "Unable to read public key from file");
      }
    }
    else
    {
      fclose(stream);
      result = _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for public key data");
    }
  }
  else
  {
    fclose(stream);
    result = _libssh2_error(a1, 4294967280LL, "Invalid data in public key file");
  }
  return result;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9250: using guessed type __int64  libssh2_base64_decode(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000040E1F) ----------------------------------------------------
__int64  sub_40E1F(__int64 a1, __int64 a2, _QWORD *a3, char *a4, int a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v9; // [rsp+0h] [rbp-40h]
  int v10; // [rsp+Ch] [rbp-34h]
  const char *s2; // [rsp+10h] [rbp-30h]
  _QWORD *v12; // [rsp+18h] [rbp-28h]
  const char ***v13; // [rsp+38h] [rbp-8h]

  v12 = a3;
  s2 = a4;
  v10 = a5;
  v9 = a6;
  v13 = (const char ***)libssh2_hostkey_methods(a1);
  *(_QWORD *)a2 = 0LL;
  *v12 = 0LL;
  while ( *v13 && **v13 )
  {
    if ( (*v13)[4] && !strncmp(**v13, s2, v10) )
    {
      *(_QWORD *)a2 = *v13;
      break;
    }
    ++v13;
  }
  if ( !*(_QWORD *)a2 )
    return _libssh2_error(a1, 4294967279LL, "No handler for specified private key");
  if ( (*(unsigned int ( **)(__int64, __int64, __int64, __int64, _QWORD *))(*(_QWORD *)a2 + 32LL))(
         a1,
         v9,
         a7,
         a8,
         v12) )
  {
    return _libssh2_error(a1, 4294967280LL, "Unable to initialize private key from file");
  }
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8FF0: using guessed type __int64  libssh2_hostkey_methods(_QWORD);

//----- (0000000000040F35) ----------------------------------------------------
__int64  sub_40F35(__int64 a1, __int64 a2, _QWORD *a3, char *a4, int a5, __int64 a6, __int64 a7)
{
  __int64 v8; // [rsp+0h] [rbp-40h]
  int v9; // [rsp+Ch] [rbp-34h]
  const char *s2; // [rsp+10h] [rbp-30h]
  _QWORD *v11; // [rsp+18h] [rbp-28h]
  const char ***v12; // [rsp+38h] [rbp-8h]

  v11 = a3;
  s2 = a4;
  v9 = a5;
  v8 = a6;
  v12 = (const char ***)libssh2_hostkey_methods(a1);
  *(_QWORD *)a2 = 0LL;
  *v11 = 0LL;
  while ( *v12 && **v12 )
  {
    if ( (*v12)[3] && !strncmp(**v12, s2, v9) )
    {
      *(_QWORD *)a2 = *v12;
      break;
    }
    ++v12;
  }
  if ( !*(_QWORD *)a2 )
    return _libssh2_error(a1, 4294967279LL, "No handler for specified private key");
  if ( (*(unsigned int ( **)(__int64, __int64, __int64, _QWORD *))(*(_QWORD *)a2 + 24LL))(a1, v8, a7, v11) )
    return _libssh2_error(a1, 4294967280LL, "Unable to initialize private key from file");
  return 0LL;
}
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 8FF0: using guessed type __int64  libssh2_hostkey_methods(_QWORD);

//----- (0000000000041044) ----------------------------------------------------
signed __int64  sub_41044(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6)
{
  __int64 v6; // rbx
  __int64 v7; // rax
  signed __int64 result; // rax
  __int64 *v9; // [rsp+0h] [rbp-80h]
  __int64 v10; // [rsp+8h] [rbp-78h]
  __int64 v11; // [rsp+10h] [rbp-70h]
  __int64 v12; // [rsp+18h] [rbp-68h]
  unsigned int v13; // [rsp+34h] [rbp-4Ch]
  __int64 v14; // [rsp+38h] [rbp-48h]
  char v15; // [rsp+40h] [rbp-40h]
  __int64 v16; // [rsp+48h] [rbp-38h]
  __int64 v17; // [rsp+50h] [rbp-30h]
  __int64 v18; // [rsp+58h] [rbp-28h]
  unsigned __int64 v19; // [rsp+68h] [rbp-18h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v19 = __readfsqword(0x28u);
  v16 = *a6;
  v6 = *(_QWORD *)(v16 + 8);
  v7 = strlen(*(const char **)v16);
  v13 = sub_40E1F(a1, (__int64)&v14, &v15, *(char **)(a1 + 53592), *(_QWORD *)(a1 + 53600), *(_QWORD *)v16, v7, v6);
  if ( v13 )
    return v13;
  v17 = v11;
  v18 = v10;
  if ( (*(unsigned int ( **)(__int64, __int64, __int64, signed __int64, __int64 *, char *, __int64 *))(v14 + 48))(
         a1,
         a2,
         v12,
         1LL,
         &v17,
         &v15,
         v9) )
  {
    if ( *(_QWORD *)(v14 + 64) )
      (*(void ( **)(__int64, char *))(v14 + 64))(a1, &v15);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( *(_QWORD *)(v14 + 64) )
      (*(void ( **)(__int64, char *))(v14 + 64))(a1, &v15);
    result = 0LL;
  }
  return result;
}

//----- (0000000000041198) ----------------------------------------------------
signed __int64  sub_41198(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 **a6)
{
  signed __int64 result; // rax
  __int64 **v7; // [rsp+8h] [rbp-70h]
  __int64 v8; // [rsp+10h] [rbp-68h]
  __int64 v9; // [rsp+18h] [rbp-60h]
  __int64 v10; // [rsp+20h] [rbp-58h]
  unsigned int v11; // [rsp+3Ch] [rbp-3Ch]
  __int64 v12; // [rsp+40h] [rbp-38h]
  char v13; // [rsp+48h] [rbp-30h]
  __int64 *v14; // [rsp+50h] [rbp-28h]
  __int64 v15; // [rsp+58h] [rbp-20h]
  __int64 v16; // [rsp+60h] [rbp-18h]
  unsigned __int64 v17; // [rsp+70h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  v17 = __readfsqword(0x28u);
  v14 = *a6;
  v11 = sub_40F35(a1, (__int64)&v12, &v13, *(char **)(a1 + 53592), *(_QWORD *)(a1 + 53600), *v14, v14[1]);
  if ( v11 )
    return v11;
  v15 = v9;
  v16 = v8;
  if ( (*(unsigned int ( **)(__int64, __int64, __int64, signed __int64, __int64 *, char *, __int64 **))(v12 + 48))(
         a1,
         a2,
         v10,
         1LL,
         &v15,
         &v13,
         v7) )
  {
    if ( *(_QWORD *)(v12 + 64) )
      (*(void ( **)(__int64, char *))(v12 + 64))(a1, &v13);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( *(_QWORD *)(v12 + 64) )
      (*(void ( **)(__int64, char *))(v12 + 64))(a1, &v13);
    result = 0LL;
  }
  return result;
}

//----- (00000000000412D7) ----------------------------------------------------
__int64  sub_412D7(__int64 a1, __int64 a2, __int64 a3, const char *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)
{
  __int64 result; // rax
  _BYTE *v11; // rax
  __int64 v12; // rax
  __int64 v13; // [rsp+10h] [rbp-C0h]
  __int64 v14; // [rsp+18h] [rbp-B8h]
  const char *v15; // [rsp+20h] [rbp-B0h]
  __int64 v16; // [rsp+28h] [rbp-A8h]
  unsigned int v17; // [rsp+44h] [rbp-8Ch]
  unsigned int v18; // [rsp+44h] [rbp-8Ch]
  unsigned int v19; // [rsp+44h] [rbp-8Ch]
  int v20; // [rsp+44h] [rbp-8Ch]
  int v21; // [rsp+44h] [rbp-8Ch]
  __int64 v22; // [rsp+48h] [rbp-88h]
  __int64 v23; // [rsp+50h] [rbp-80h]
  __int64 v24; // [rsp+58h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-70h]
  unsigned __int64 v26; // [rsp+68h] [rbp-68h]
  __int64 v27; // [rsp+70h] [rbp-60h]
  __int64 v28; // [rsp+78h] [rbp-58h]
  char *v29; // [rsp+80h] [rbp-50h]
  __int64 v30; // [rsp+88h] [rbp-48h]
  __int64 v31; // [rsp+90h] [rbp-40h]
  __int64 v32; // [rsp+98h] [rbp-38h]
  __int64 v33; // [rsp+A0h] [rbp-30h]
  __int64 v34; // [rsp+A8h] [rbp-28h]
  char v35; // [rsp+C3h] [rbp-Dh]
  unsigned __int64 v36; // [rsp+C8h] [rbp-8h]

  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  v36 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53480) )
  {
    v23 = 0LL;
    v24 = 0LL;
    v25 = 0LL;
    v26 = 0LL;
    memset((void *)(a1 + 53544), 0, 8uLL);
    if ( v15 )
    {
      v17 = sub_40A80(a1, (void **)(a1 + 53520), (_QWORD *)(a1 + 53528), &v23, &v25, v15);
      if ( v17 )
        return v17;
    }
    else
    {
      v18 = _libssh2_pub_priv_keyfile(a1, a1 + 53520, a1 + 53528, &v23, &v25, v14, v13);
      if ( v18 )
        return v18;
    }
    *(_QWORD *)(a1 + 53512) = a10 + a8 + v16 + *(_QWORD *)(a1 + 53528) + v25 + 52;
    *(_QWORD *)(a1 + 53504) = (*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(
                                *(_QWORD *)(a1 + 53528) + *(_QWORD *)(a1 + 53512) + v25 + 12,
                                a1);
    *(_QWORD *)(a1 + 53536) = *(_QWORD *)(a1 + 53504);
    if ( !*(_QWORD *)(a1 + 53504) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53520), a1);
      *(_QWORD *)(a1 + 53520) = 0LL;
      (*(void ( **)(__int64, __int64))(a1 + 24))(v23, a1);
      return _libssh2_error(a1, 4294967290LL, "Out of memory");
    }
    v11 = *(_BYTE **)(a1 + 53536);
    *(_QWORD *)(a1 + 53536) = v11 + 1;
    *v11 = 50;
    _libssh2_store_str(a1 + 53536, a2, v16);
    _libssh2_store_str(a1 + 53536, "ssh-connection", 14LL);
    _libssh2_store_str(a1 + 53536, "hostbased", 9LL);
    _libssh2_store_str(a1 + 53536, *(_QWORD *)(a1 + 53520), *(_QWORD *)(a1 + 53528));
    _libssh2_store_str(a1 + 53536, v23, v25);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v23, a1);
    _libssh2_store_str(a1 + 53536, a7, a8);
    _libssh2_store_str(a1 + 53536, a9, a10);
    v19 = sub_40F35(a1, (__int64)&v22, &v27, *(char **)(a1 + 53520), *(_QWORD *)(a1 + 53528), v14, v13);
    if ( v19 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53520), a1);
      *(_QWORD *)(a1 + 53520) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53504), a1);
      *(_QWORD *)(a1 + 53504) = 0LL;
      return v19;
    }
    _libssh2_htonu32(&v35, *(unsigned int *)(a1 + 144));
    v29 = &v35;
    v30 = 4LL;
    v31 = *(_QWORD *)(a1 + 136);
    v32 = *(unsigned int *)(a1 + 144);
    v33 = *(_QWORD *)(a1 + 53504);
    v34 = *(_QWORD *)(a1 + 53512);
    if ( v22
      && *(_QWORD *)(v22 + 48)
      && (*(unsigned int ( **)(__int64, __int64 *, unsigned __int64 *, signed __int64, char **, __int64 *))(v22 + 48))(
           a1,
           &v24,
           &v26,
           3LL,
           &v29,
           &v27) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53520), a1);
      *(_QWORD *)(a1 + 53520) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53504), a1);
      *(_QWORD *)(a1 + 53504) = 0LL;
      if ( *(_QWORD *)(v22 + 64) )
        (*(void ( **)(__int64, __int64 *))(v22 + 64))(a1, &v27);
      return 0xFFFFFFFFLL;
    }
    if ( v22 && *(_QWORD *)(v22 + 64) )
      (*(void ( **)(__int64, __int64 *))(v22 + 64))(a1, &v27);
    if ( v26 > v25 )
    {
      if ( *(_QWORD *)(a1 + 53504) )
        v12 = (*(__int64 ( **)(_QWORD, unsigned __int64, __int64))(a1 + 16))(
                *(_QWORD *)(a1 + 53504),
                *(_QWORD *)(a1 + 53528) + *(_QWORD *)(a1 + 53512) + v26 + 12,
                a1);
      else
        v12 = (*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(
                *(_QWORD *)(a1 + 53528) + *(_QWORD *)(a1 + 53512) + v26 + 12,
                a1);
      v28 = v12;
      if ( !v12 )
      {
        (*(void ( **)(__int64, __int64))(a1 + 24))(v24, a1);
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53504), a1);
        *(_QWORD *)(a1 + 53504) = 0LL;
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53520), a1);
        *(_QWORD *)(a1 + 53520) = 0LL;
        return _libssh2_error(a1, 4294967290LL, "Failed allocating additional space for userauth-hostbased packet");
      }
      *(_QWORD *)(a1 + 53504) = v28;
    }
    *(_QWORD *)(a1 + 53536) = *(_QWORD *)(a1 + 53512) + *(_QWORD *)(a1 + 53504);
    _libssh2_store_u32(a1 + 53536, (unsigned int)*(_QWORD *)(a1 + 53528) + (unsigned int)v26 + 8);
    _libssh2_store_str(a1 + 53536, *(_QWORD *)(a1 + 53520), *(_QWORD *)(a1 + 53528));
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53520), a1);
    *(_QWORD *)(a1 + 53520) = 0LL;
    _libssh2_store_str(a1 + 53536, v24, v26);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v24, a1);
    *(_DWORD *)(a1 + 53480) = 2;
  }
  if ( *(_DWORD *)(a1 + 53480) == 2 )
  {
    v20 = _libssh2_transport_send(
            a1,
            *(_QWORD *)(a1 + 53504),
            *(_QWORD *)(a1 + 53536) - *(_QWORD *)(a1 + 53504),
            0LL,
            0LL);
    if ( v20 == -37 )
      return _libssh2_error(a1, 4294967259LL, "Would block");
    if ( v20 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53504), a1);
      *(_QWORD *)(a1 + 53504) = 0LL;
      *(_DWORD *)(a1 + 53480) = 0;
      return _libssh2_error(a1, 4294967289LL, "Unable to send userauth-hostbased request");
    }
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53504), a1);
    *(_QWORD *)(a1 + 53504) = 0LL;
    *(_DWORD *)(a1 + 53480) = 3;
  }
  if ( *(_DWORD *)(a1 + 53480) != 3 )
    goto LABEL_45;
  v21 = _libssh2_packet_requirev(a1, "43", a1 + 53488, &v27, 0LL, 0LL, 0LL, a1 + 53544);
  if ( v21 == -37 )
    return _libssh2_error(a1, 4294967259LL, "Would block");
  *(_DWORD *)(a1 + 53480) = 0;
  if ( v21 || !v27 )
    return _libssh2_error(a1, 4294967277LL, "Auth failed");
  if ( **(_BYTE **)(a1 + 53488) != 52 )
  {
LABEL_45:
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53488), a1);
    *(_QWORD *)(a1 + 53488) = 0LL;
    result = _libssh2_error(
               a1,
               4294967277LL,
               "Invalid signature for supplied public key, or bad username/public key combination");
  }
  else
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53488), a1);
    *(_QWORD *)(a1 + 53488) = 0LL;
    *(_DWORD *)(a1 + 104) |= 4u;
    result = 0LL;
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 90C0: using guessed type __int64  _libssh2_pub_priv_keyfile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9710: using guessed type __int64  _libssh2_htonu32(_QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000041F21) ----------------------------------------------------
__int64  libssh2_userauth_hostbased_fromfile_ex(__int64 a1, __int64 a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6, __int64 a7, unsigned int a8, __int64 a9, unsigned int a10)
{
  __int64 v11; // [rsp+0h] [rbp-40h]
  __int64 v12; // [rsp+8h] [rbp-38h]
  const char *v13; // [rsp+10h] [rbp-30h]
  unsigned int v14; // [rsp+1Ch] [rbp-24h]
  unsigned int v15; // [rsp+34h] [rbp-Ch]
  time_t v16; // [rsp+38h] [rbp-8h]

  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = a6;
  v16 = time(0LL);
  do
  {
    v15 = sub_412D7(a1, a2, v14, v13, v12, v11, a7, a8, a9, a10);
    if ( v15 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v15 = _libssh2_wait_socket(a1, v16);
  }
  while ( !v15 );
  return v15;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000041FBC) ----------------------------------------------------
__int64  _libssh2_userauth_publickey(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 ( *a6)(__int64, __int64 *, unsigned __int64 *, void *, signed __int64, __int64), __int64 a7)
{
  __int64 result; // rax
  __int64 v8; // rbx
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  __int64 v11; // rax
  __int64 ( *v12)(__int64, __int64 *, unsigned __int64 *, void *, signed __int64, __int64); // [rsp+10h] [rbp-80h]
  unsigned __int64 v13; // [rsp+18h] [rbp-78h]
  __int64 v14; // [rsp+20h] [rbp-70h]
  unsigned int v15; // [rsp+2Ch] [rbp-64h]
  int v16; // [rsp+44h] [rbp-4Ch]
  int v17; // [rsp+44h] [rbp-4Ch]
  int v18; // [rsp+44h] [rbp-4Ch]
  int v19; // [rsp+44h] [rbp-4Ch]
  int v20; // [rsp+44h] [rbp-4Ch]
  void *dest; // [rsp+48h] [rbp-48h]
  __int64 v22; // [rsp+50h] [rbp-40h]
  unsigned __int64 v23; // [rsp+58h] [rbp-38h]
  void *v24; // [rsp+60h] [rbp-30h]
  __int64 v25; // [rsp+68h] [rbp-28h]
  char v26; // [rsp+74h] [rbp-1Ch]
  char v27; // [rsp+75h] [rbp-1Bh]
  char v28; // [rsp+76h] [rbp-1Ah]
  char v29; // [rsp+77h] [rbp-19h]
  unsigned __int64 v30; // [rsp+78h] [rbp-18h]

  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v30 = __readfsqword(0x28u);
  v26 = 52;
  v27 = 51;
  v28 = 60;
  v29 = 0;
  if ( !*(_DWORD *)(a1 + 53552) )
  {
    if ( a5 <= 3 )
      return _libssh2_error(a1, 4294967277LL, "Invalid public key, too short");
    memset((void *)(a1 + 53624), 0, 8uLL);
    if ( *(_QWORD *)(a1 + 53592) )
    {
      v8 = *(_QWORD *)(a1 + 53600);
      if ( v8 != (unsigned int)_libssh2_ntohu32(v14) )
        return _libssh2_error(a1, 4294967277LL, "Invalid public key");
    }
    else
    {
      *(_QWORD *)(a1 + 53600) = (unsigned int)_libssh2_ntohu32(v14);
      if ( *(_QWORD *)(a1 + 53600) > v13 - 4 )
        return _libssh2_error(a1, 4294967277LL, "Invalid public key");
      *(_QWORD *)(a1 + 53592) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53600), a1);
      if ( !*(_QWORD *)(a1 + 53592) )
        return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for public key data");
      memcpy(*(void **)(a1 + 53592), (const void *)(v14 + 4), *(_QWORD *)(a1 + 53600));
    }
    *(_QWORD *)(a1 + 53584) = *(_QWORD *)(a1 + 53600) + v15 + v13 + 45;
    *(_QWORD *)(a1 + 53576) = (*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(
                                *(_QWORD *)(a1 + 53600) + *(_QWORD *)(a1 + 53584) + v13 + 12,
                                a1);
    dest = *(void **)(a1 + 53576);
    if ( !*(_QWORD *)(a1 + 53576) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
      *(_QWORD *)(a1 + 53592) = 0LL;
      return _libssh2_error(a1, 4294967290LL, "Out of memory");
    }
    v9 = dest;
    dest = (char *)dest + 1;
    *v9 = 50;
    _libssh2_store_str(&dest, a2, v15);
    _libssh2_store_str(&dest, "ssh-connection", 14LL);
    _libssh2_store_str(&dest, "publickey", 9LL);
    *(_QWORD *)(a1 + 53616) = dest;
    v10 = dest;
    dest = (char *)dest + 1;
    *v10 = 0;
    _libssh2_store_str(&dest, *(_QWORD *)(a1 + 53592), *(_QWORD *)(a1 + 53600));
    _libssh2_store_str(&dest, v14, v13);
    *(_DWORD *)(a1 + 53552) = 2;
  }
  if ( *(_DWORD *)(a1 + 53552) == 2 )
  {
    v16 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53576), *(_QWORD *)(a1 + 53584), 0LL, 0LL);
    if ( v16 == -37 )
      return _libssh2_error(a1, 4294967259LL, "Would block");
    if ( v16 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
      *(_QWORD *)(a1 + 53576) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
      *(_QWORD *)(a1 + 53592) = 0LL;
      *(_DWORD *)(a1 + 53552) = 0;
      return _libssh2_error(a1, 4294967289LL, "Unable to send userauth-publickey request");
    }
    *(_DWORD *)(a1 + 53552) = 3;
  }
  if ( *(_DWORD *)(a1 + 53552) == 3 )
  {
    v17 = _libssh2_packet_requirev(a1, &v26, a1 + 53560, a1 + 53568, 0LL, 0LL, 0LL, a1 + 53624);
    if ( v17 == -37 )
      return _libssh2_error(a1, 4294967259LL, "Would block");
    if ( v17 || !*(_QWORD *)(a1 + 53568) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
      *(_QWORD *)(a1 + 53576) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
      *(_QWORD *)(a1 + 53592) = 0LL;
      *(_DWORD *)(a1 + 53552) = 0;
      return _libssh2_error(a1, 4294967277LL, "Waiting for USERAUTH response");
    }
    if ( **(_BYTE **)(a1 + 53560) == 52 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
      *(_QWORD *)(a1 + 53560) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
      *(_QWORD *)(a1 + 53576) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
      *(_QWORD *)(a1 + 53592) = 0LL;
      *(_DWORD *)(a1 + 104) |= 4u;
      *(_DWORD *)(a1 + 53552) = 0;
      return 0LL;
    }
    if ( **(_BYTE **)(a1 + 53560) == 51 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
      *(_QWORD *)(a1 + 53560) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
      *(_QWORD *)(a1 + 53576) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
      *(_QWORD *)(a1 + 53592) = 0LL;
      *(_DWORD *)(a1 + 53552) = 0;
      return _libssh2_error(a1, 4294967278LL, "Username/PublicKey combination invalid");
    }
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
    *(_QWORD *)(a1 + 53560) = 0LL;
    **(_BYTE **)(a1 + 53616) = 1;
    *(_DWORD *)(a1 + 53552) = 4;
  }
  if ( *(_DWORD *)(a1 + 53552) == 4 )
  {
    v24 = (void *)(*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                    (unsigned int)(*(_DWORD *)(a1 + 144) + 4) + *(_QWORD *)(a1 + 53584),
                    a1);
    dest = v24;
    if ( !v24 )
      return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for userauth-publickey signed data");
    _libssh2_store_str(&dest, *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 144));
    memcpy(dest, *(const void **)(a1 + 53576), *(_QWORD *)(a1 + 53584));
    dest = (char *)dest + *(_QWORD *)(a1 + 53584);
    v18 = v12(a1, &v22, &v23, v24, (_BYTE *)dest - (_BYTE *)v24, a7);
    (*(void ( **)(void *, __int64))(a1 + 24))(v24, a1);
    if ( v18 == -37 )
      return _libssh2_error(a1, 4294967259LL, "Would block");
    if ( v18 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
      *(_QWORD *)(a1 + 53592) = 0LL;
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
      *(_QWORD *)(a1 + 53576) = 0LL;
      *(_DWORD *)(a1 + 53552) = 0;
      return _libssh2_error(a1, 4294967277LL, "Callback returned error");
    }
    if ( v13 < v23 )
    {
      if ( *(_QWORD *)(a1 + 53576) )
        v11 = (*(__int64 ( **)(_QWORD, unsigned __int64, __int64))(a1 + 16))(
                *(_QWORD *)(a1 + 53576),
                *(_QWORD *)(a1 + 53600) + *(_QWORD *)(a1 + 53584) + v23 + 12,
                a1);
      else
        v11 = (*(__int64 ( **)(unsigned __int64, __int64))(a1 + 8))(
                *(_QWORD *)(a1 + 53600) + *(_QWORD *)(a1 + 53584) + v23 + 12,
                a1);
      v25 = v11;
      if ( !v11 )
      {
        (*(void ( **)(__int64, __int64))(a1 + 24))(v22, a1);
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
        *(_QWORD *)(a1 + 53576) = 0LL;
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
        *(_QWORD *)(a1 + 53592) = 0LL;
        *(_DWORD *)(a1 + 53552) = 0;
        return _libssh2_error(a1, 4294967290LL, "Failed allocating additional space for userauth-publickey packet");
      }
      *(_QWORD *)(a1 + 53576) = v25;
    }
    dest = (void *)(*(_QWORD *)(a1 + 53576) + *(_QWORD *)(a1 + 53584));
    *(_QWORD *)(a1 + 53616) = 0LL;
    _libssh2_store_u32(&dest, (unsigned int)*(_QWORD *)(a1 + 53600) + (unsigned int)v23 + 8);
    _libssh2_store_str(&dest, *(_QWORD *)(a1 + 53592), *(_QWORD *)(a1 + 53600));
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53592), a1);
    *(_QWORD *)(a1 + 53592) = 0LL;
    _libssh2_store_str(&dest, v22, v23);
    (*(void ( **)(__int64, __int64))(a1 + 24))(v22, a1);
    *(_QWORD *)(a1 + 53608) = dest;
    *(_DWORD *)(a1 + 53552) = 5;
  }
  if ( *(_DWORD *)(a1 + 53552) == 5 )
  {
    v19 = _libssh2_transport_send(
            a1,
            *(_QWORD *)(a1 + 53576),
            *(_QWORD *)(a1 + 53608) - *(_QWORD *)(a1 + 53576),
            0LL,
            0LL);
    if ( v19 == -37 )
      return _libssh2_error(a1, 4294967259LL, "Would block");
    if ( v19 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
      *(_QWORD *)(a1 + 53576) = 0LL;
      *(_DWORD *)(a1 + 53552) = 0;
      return _libssh2_error(a1, 4294967289LL, "Unable to send userauth-publickey request");
    }
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53576), a1);
    *(_QWORD *)(a1 + 53576) = 0LL;
    *(_DWORD *)(a1 + 53552) = 6;
  }
  v28 = 0;
  v20 = _libssh2_packet_requirev(a1, &v26, a1 + 53560, a1 + 53568, 0LL, 0LL, 0LL, a1 + 53624);
  if ( v20 == -37 )
    return _libssh2_error(a1, 4294967259LL, "Would block requesting userauth list");
  if ( !v20 && *(_QWORD *)(a1 + 53568) )
  {
    if ( **(_BYTE **)(a1 + 53560) == 52 )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
      *(_QWORD *)(a1 + 53560) = 0LL;
      *(_DWORD *)(a1 + 104) |= 4u;
      *(_DWORD *)(a1 + 53552) = 0;
      result = 0LL;
    }
    else
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53560), a1);
      *(_QWORD *)(a1 + 53560) = 0LL;
      *(_DWORD *)(a1 + 53552) = 0;
      result = _libssh2_error(
                 a1,
                 4294967277LL,
                 "Invalid signature for supplied public key, or bad username/public key combination");
    }
  }
  else
  {
    *(_DWORD *)(a1 + 53552) = 0;
    result = _libssh2_error(a1, 4294967277LL, "Waiting for publickey USERAUTH response");
  }
  return result;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (0000000000042DD0) ----------------------------------------------------
__int64  sub_42DD0(size_t a1, __int64 a2, unsigned int a3, void *a4, size_t a5, __int64 a6, __int64 a7, __int64 a8)
{
  unsigned int v9; // [rsp+28h] [rbp-58h]
  unsigned int v10; // [rsp+44h] [rbp-3Ch]
  unsigned int v11; // [rsp+44h] [rbp-3Ch]
  __int64 v12; // [rsp+48h] [rbp-38h]
  __int64 v13; // [rsp+50h] [rbp-30h]
  __int64 *v14; // [rsp+58h] [rbp-28h]
  __int64 v15; // [rsp+60h] [rbp-20h]
  __int64 v16; // [rsp+68h] [rbp-18h]
  unsigned __int64 v17; // [rsp+78h] [rbp-8h]

  v9 = a3;
  v17 = __readfsqword(0x28u);
  v12 = 0LL;
  v13 = 0LL;
  v14 = &v15;
  v15 = a6;
  v16 = a8;
  if ( !*(_DWORD *)(a1 + 53552) )
  {
    if ( a5 && a4 )
    {
      v10 = sub_407F3(a1, (void **)(a1 + 53592), (_QWORD *)(a1 + 53600), &v12, &v13, a4, a5);
      if ( v10 )
        return v10;
    }
    else
    {
      if ( !a7 || !a6 )
        return _libssh2_error(a1, 4294967280LL, "Invalid data in public and private key.");
      if ( (unsigned int)_libssh2_pub_priv_keyfilememory(a1, a1 + 53592, a1 + 53600, &v12, &v13, a6, a7, a8) )
        return _libssh2_error(a1, 4294967280LL, "Unable to extract public key from private key.");
    }
  }
  v11 = _libssh2_userauth_publickey(a1, a2, v9, v12, v13, sub_41044, &v14);
  if ( v12 )
    (*(void ( **)(__int64, size_t))(a1 + 24))(v12, a1);
  return v11;
}
// 8AB0: using guessed type __int64  _libssh2_pub_priv_keyfilememory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 9180: using guessed type __int64  _libssh2_userauth_publickey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000042FAC) ----------------------------------------------------
__int64  sub_42FAC(__int64 a1, __int64 a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+18h] [rbp-58h]
  unsigned int v8; // [rsp+34h] [rbp-3Ch]
  unsigned int v9; // [rsp+34h] [rbp-3Ch]
  unsigned int v10; // [rsp+34h] [rbp-3Ch]
  __int64 v11; // [rsp+38h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-30h]
  __int64 *v13; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]
  unsigned __int64 v16; // [rsp+68h] [rbp-8h]

  v7 = a3;
  v16 = __readfsqword(0x28u);
  v11 = 0LL;
  v12 = 0LL;
  v13 = &v14;
  v14 = a5;
  v15 = a6;
  if ( !*(_DWORD *)(a1 + 53552) )
  {
    if ( a4 )
    {
      v8 = sub_40A80(a1, (void **)(a1 + 53592), (_QWORD *)(a1 + 53600), &v11, &v12, a4);
      if ( v8 )
        return v8;
    }
    else
    {
      v9 = _libssh2_pub_priv_keyfile(a1, a1 + 53592, a1 + 53600, &v11, &v12, a5, a6);
      if ( v9 )
        return v9;
    }
  }
  v10 = _libssh2_userauth_publickey(a1, a2, v7, v11, v12, sub_41198, &v13);
  if ( v11 )
    (*(void ( **)(__int64, __int64))(a1 + 24))(v11, a1);
  return v10;
}
// 90C0: using guessed type __int64  _libssh2_pub_priv_keyfile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9180: using guessed type __int64  _libssh2_userauth_publickey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000043133) ----------------------------------------------------
__int64  libssh2_userauth_publickey_frommemory(size_t a1, __int64 a2, unsigned int a3, void *a4, size_t a5, __int64 a6, __int64 a7, void *a8)
{
  __int64 v9; // [rsp+0h] [rbp-40h]
  size_t v10; // [rsp+8h] [rbp-38h]
  void *v11; // [rsp+10h] [rbp-30h]
  unsigned int v12; // [rsp+18h] [rbp-28h]
  unsigned int v13; // [rsp+34h] [rbp-Ch]
  time_t v14; // [rsp+38h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( !a8 )
    a8 = &unk_4A3F8;
  v14 = time(0LL);
  do
  {
    v13 = sub_42DD0(a1, a2, v12, v11, v10, v9, a7, (__int64)a8);
    if ( v13 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v13 = _libssh2_wait_socket(a1, v14);
  }
  while ( !v13 );
  return v13;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (00000000000431DB) ----------------------------------------------------
__int64  libssh2_userauth_publickey_fromfile_ex(__int64 a1, __int64 a2, unsigned int a3, const char *a4, __int64 a5, void *a6)
{
  void *v7; // [rsp+0h] [rbp-40h]
  __int64 v8; // [rsp+8h] [rbp-38h]
  const char *v9; // [rsp+10h] [rbp-30h]
  unsigned int v10; // [rsp+1Ch] [rbp-24h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = a6;
  if ( !a6 )
    v7 = &unk_4A3F8;
  v12 = time(0LL);
  do
  {
    v11 = sub_42FAC(a1, a2, v10, v9, v8, (__int64)v7);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v11 = _libssh2_wait_socket(a1, v12);
  }
  while ( !v11 );
  return v11;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000043277) ----------------------------------------------------
signed __int64  libssh2_userauth_publickey(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // eax
  __int64 v8; // [rsp+0h] [rbp-40h]
  __int64 v9; // [rsp+8h] [rbp-38h]
  __int128 v10; // [rsp+10h] [rbp-30h]
  unsigned int v11; // [rsp+34h] [rbp-Ch]
  time_t v12; // [rsp+38h] [rbp-8h]

  *((_QWORD *)&v10 + 1) = a3;
  *(_QWORD *)&v10 = a4;
  v9 = a5;
  v8 = a6;
  if ( !a1 )
    return 4294967257LL;
  v12 = time(0LL);
  do
  {
    v7 = strlen(a2);
    v11 = _libssh2_userauth_publickey(a1, a2, v7, *((_QWORD *)&v10 + 1), v10, v9, v8);
    if ( v11 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v11 = _libssh2_wait_socket(a1, v12);
  }
  while ( !v11 );
  return v11;
}
// 9180: using guessed type __int64  _libssh2_userauth_publickey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000043330) ----------------------------------------------------
__int64  sub_43330(__int64 a1, __int64 a2, unsigned int a3, void ( *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64))
{
  _BYTE *v5; // rax
  int v6; // eax
  signed __int64 v7; // rbx
  signed __int64 v8; // rbx
  _BYTE *v9; // rax
  void ( *v10)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64); // [rsp+0h] [rbp-50h]
  unsigned int v11; // [rsp+Ch] [rbp-44h]
  unsigned int i; // [rsp+24h] [rbp-2Ch]
  unsigned int j; // [rsp+24h] [rbp-2Ch]
  unsigned int k; // [rsp+24h] [rbp-2Ch]
  unsigned int l; // [rsp+24h] [rbp-2Ch]
  unsigned int m; // [rsp+24h] [rbp-2Ch]
  int v17; // [rsp+28h] [rbp-28h]
  int v18; // [rsp+28h] [rbp-28h]
  int v19; // [rsp+28h] [rbp-28h]
  unsigned int v20; // [rsp+2Ch] [rbp-24h]
  void *src; // [rsp+30h] [rbp-20h]
  unsigned __int64 v22; // [rsp+38h] [rbp-18h]

  v11 = a3;
  v10 = a4;
  v22 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(a1 + 53632) )
  {
    *(_QWORD *)(a1 + 53680) = 0LL;
    *(_QWORD *)(a1 + 53696) = 0LL;
    *(_DWORD *)(a1 + 53704) = 0;
    *(_DWORD *)(a1 + 53708) = 1;
    *(_QWORD *)(a1 + 53712) = 0LL;
    *(_QWORD *)(a1 + 53720) = 0LL;
    memset((void *)(a1 + 53728), 0, 8uLL);
    *(_QWORD *)(a1 + 53664) = v11 + 55;
    src = (void *)(*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53664), a1);
    *(_QWORD *)(a1 + 53640) = src;
    if ( !src )
      return _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive authentication");
    v5 = src;
    src = (char *)src + 1;
    *v5 = 50;
    _libssh2_store_str(&src, a2, v11);
    _libssh2_store_str(&src, "ssh-connection", 14LL);
    _libssh2_store_str(&src, "keyboard-interactive", 20LL);
    _libssh2_store_u32(&src, 0LL);
    _libssh2_store_u32(&src, 0LL);
    *(_DWORD *)(a1 + 53632) = 2;
  }
  if ( *(_DWORD *)(a1 + 53632) != 2 )
    goto LABEL_11;
  v17 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53640), *(_QWORD *)(a1 + 53664), 0LL, 0LL);
  if ( v17 == -37 )
    return _libssh2_error(a1, 4294967259LL, "Would block");
  if ( v17 )
  {
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
    *(_QWORD *)(a1 + 53640) = 0LL;
    *(_DWORD *)(a1 + 53632) = 0;
    return _libssh2_error(a1, 4294967289LL, "Unable to send keyboard-interactive request");
  }
  (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
  *(_QWORD *)(a1 + 53640) = 0LL;
  for ( *(_DWORD *)(a1 + 53632) = 3; ; *(_DWORD *)(a1 + 53632) = 3 )
  {
LABEL_11:
    if ( *(_DWORD *)(a1 + 53632) == 3 )
    {
      v18 = _libssh2_packet_requirev(a1, "43<", a1 + 53640, a1 + 53648, 0LL, 0LL, 0LL, a1 + 53728);
      if ( v18 == -37 )
        return _libssh2_error(a1, 4294967259LL, "Would block");
      if ( v18 || !*(_QWORD *)(a1 + 53648) )
      {
        *(_DWORD *)(a1 + 53632) = 0;
        return _libssh2_error(a1, 4294967278LL, "Waiting for keyboard USERAUTH response");
      }
      if ( **(_BYTE **)(a1 + 53640) == 52 )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
        *(_QWORD *)(a1 + 53640) = 0LL;
        *(_DWORD *)(a1 + 104) |= 4u;
        *(_DWORD *)(a1 + 53632) = 0;
        return 0LL;
      }
      if ( **(_BYTE **)(a1 + 53640) == 51 )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
        *(_QWORD *)(a1 + 53640) = 0LL;
        *(_DWORD *)(a1 + 53632) = 0;
        return _libssh2_error(a1, 4294967278LL, "Authentication failed (keyboard-interactive)");
      }
      src = (void *)(*(_QWORD *)(a1 + 53640) + 1LL);
      if ( *(_QWORD *)(a1 + 53648) <= 4uLL )
      {
        _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallto get length");
        goto LABEL_82;
      }
      *(_DWORD *)(a1 + 53672) = _libssh2_ntohu32(src);
      src = (char *)src + 4;
      if ( *(_DWORD *)(a1 + 53672) )
      {
        *(_QWORD *)(a1 + 53680) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                                    *(unsigned int *)(a1 + 53672),
                                    a1);
        if ( !*(_QWORD *)(a1 + 53680) )
        {
          _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive 'name' request field");
          goto LABEL_82;
        }
        if ( (unsigned __int64)src + *(_QWORD *)(a1 + 53408) > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
        {
          _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallfor auth name");
          goto LABEL_82;
        }
        memcpy(*(void **)(a1 + 53680), src, *(unsigned int *)(a1 + 53672));
        src = (char *)src + *(unsigned int *)(a1 + 53672);
      }
      if ( (unsigned __int64)src + 4 > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
      {
        _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallfor auth instruction length");
        goto LABEL_82;
      }
      *(_DWORD *)(a1 + 53688) = _libssh2_ntohu32(src);
      src = (char *)src + 4;
      if ( *(_DWORD *)(a1 + 53688) )
      {
        *(_QWORD *)(a1 + 53696) = (*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(
                                    *(unsigned int *)(a1 + 53688),
                                    a1);
        if ( !*(_QWORD *)(a1 + 53696) )
        {
          _libssh2_error(
            a1,
            4294967290LL,
            "Unable to allocate memory for keyboard-interactive 'instruction' request field");
          goto LABEL_82;
        }
        if ( (unsigned __int64)src + *(unsigned int *)(a1 + 53688) > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
        {
          _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallfor auth instruction");
          goto LABEL_82;
        }
        memcpy(*(void **)(a1 + 53696), src, *(unsigned int *)(a1 + 53688));
        src = (char *)src + *(unsigned int *)(a1 + 53688);
      }
      if ( (unsigned __int64)src + 4 > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
      {
        _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallfor auth language tag length");
        goto LABEL_82;
      }
      v20 = _libssh2_ntohu32(src);
      src = (char *)src + 4;
      if ( (unsigned __int64)src + v20 > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
      {
        _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallfor auth language tag");
        goto LABEL_82;
      }
      src = (char *)src + v20;
      if ( (unsigned __int64)src + 4 > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
      {
        _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too smallfor auth num keyboard prompts");
        goto LABEL_82;
      }
      v6 = _libssh2_ntohu32(src);
      *(_DWORD *)(a1 + 53704) = v6;
      src = (char *)src + 4;
      if ( *(_DWORD *)(a1 + 53704) > 0x64u )
      {
        _libssh2_error(a1, 4294967255LL, "Too many replies for keyboard-interactive prompts");
        goto LABEL_82;
      }
      if ( *(_DWORD *)(a1 + 53704) )
      {
        *(_QWORD *)(a1 + 53712) = _libssh2_calloc(a1, 16LL * *(unsigned int *)(a1 + 53704));
        if ( !*(_QWORD *)(a1 + 53712) )
        {
          _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive prompts array");
          goto LABEL_82;
        }
        *(_QWORD *)(a1 + 53720) = _libssh2_calloc(a1, 16LL * *(unsigned int *)(a1 + 53704));
        if ( !*(_QWORD *)(a1 + 53720) )
        {
          _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive responses array");
          goto LABEL_82;
        }
        for ( i = 0; i < *(_DWORD *)(a1 + 53704); ++i )
        {
          if ( (unsigned __int64)src + 4 > *(_QWORD *)(a1 + 53640) + *(_QWORD *)(a1 + 53648) )
          {
            _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too small for auth keyboard prompt length");
            goto LABEL_82;
          }
          v7 = *(_QWORD *)(a1 + 53712) + 16LL * i;
          *(_DWORD *)(v7 + 8) = _libssh2_ntohu32(src);
          src = (char *)src + 4;
          v8 = *(_QWORD *)(a1 + 53712) + 16LL * i;
          *(_QWORD *)v8 = _libssh2_calloc(a1, *(unsigned int *)(v8 + 8));
          if ( !*(_QWORD *)(16LL * i + *(_QWORD *)(a1 + 53712)) )
          {
            _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive prompt message");
            goto LABEL_82;
          }
          if ( (unsigned __int64)src + *(unsigned int *)(16LL * i + *(_QWORD *)(a1 + 53712) + 8) > *(_QWORD *)(a1 + 53640)
                                                                                                 + *(_QWORD *)(a1 + 53648) )
          {
            _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too small for auth keyboard prompt");
            goto LABEL_82;
          }
          memcpy(
            *(void **)(16LL * i + *(_QWORD *)(a1 + 53712)),
            src,
            *(unsigned int *)(16LL * i + *(_QWORD *)(a1 + 53712) + 8));
          src = (char *)src + *(unsigned int *)(16LL * i + *(_QWORD *)(a1 + 53712) + 8);
          if ( *(_QWORD *)(a1 + 53648) + *(_QWORD *)(a1 + 53640) <= (unsigned __int64)src )
          {
            _libssh2_error(a1, 4294967258LL, "userauth keyboard data buffer too small for auth keyboard prompt echo");
            goto LABEL_82;
          }
          v9 = src;
          src = (char *)src + 1;
          *(_BYTE *)(16LL * i + *(_QWORD *)(a1 + 53712) + 12) = *v9;
        }
      }
      v10(
        *(_QWORD *)(a1 + 53680),
        *(unsigned int *)(a1 + 53672),
        *(_QWORD *)(a1 + 53696),
        *(unsigned int *)(a1 + 53688),
        *(unsigned int *)(a1 + 53704),
        *(_QWORD *)(a1 + 53712),
        *(_QWORD *)(a1 + 53720),
        a1);
      *(_QWORD *)(a1 + 53664) = 5LL;
      for ( j = 0; j < *(_DWORD *)(a1 + 53704); ++j )
      {
        if ( *(unsigned int *)(16LL * j + *(_QWORD *)(a1 + 53720) + 8) > (unsigned __int64)(-5LL
                                                                                          - *(_QWORD *)(a1 + 53664)) )
        {
          _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive response packet");
          goto LABEL_82;
        }
        *(_QWORD *)(a1 + 53664) += (unsigned int)(*(_DWORD *)(16LL * j + *(_QWORD *)(a1 + 53720) + 8) + 4);
      }
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
      src = (void *)(*(__int64 ( **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 53664), a1);
      *(_QWORD *)(a1 + 53640) = src;
      if ( !src )
      {
        _libssh2_error(a1, 4294967290LL, "Unable to allocate memory for keyboard-interactive response packet");
        goto LABEL_82;
      }
      *(_BYTE *)src = 61;
      src = (char *)src + 1;
      _libssh2_store_u32(&src, *(unsigned int *)(a1 + 53704));
      for ( k = 0; k < *(_DWORD *)(a1 + 53704); ++k )
        _libssh2_store_str(
          &src,
          *(_QWORD *)(16LL * k + *(_QWORD *)(a1 + 53720)),
          *(unsigned int *)(16LL * k + *(_QWORD *)(a1 + 53720) + 8));
      *(_DWORD *)(a1 + 53632) = 4;
    }
    if ( *(_DWORD *)(a1 + 53632) == 4 )
    {
      v19 = _libssh2_transport_send(a1, *(_QWORD *)(a1 + 53640), *(_QWORD *)(a1 + 53664), 0LL, 0LL);
      if ( v19 == -37 )
        return _libssh2_error(a1, 4294967259LL, "Would block");
      if ( v19 )
        _libssh2_error(a1, 4294967289LL, "Unable to send userauth-keyboard-interactive request");
      else
        *(_DWORD *)(a1 + 53708) = 0;
    }
LABEL_82:
    (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53640), a1);
    *(_QWORD *)(a1 + 53640) = 0LL;
    if ( *(_QWORD *)(a1 + 53712) )
    {
      for ( l = 0; l < *(_DWORD *)(a1 + 53704); ++l )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(16LL * l + *(_QWORD *)(a1 + 53712)), a1);
        *(_QWORD *)(16LL * l + *(_QWORD *)(a1 + 53712)) = 0LL;
      }
    }
    if ( *(_QWORD *)(a1 + 53720) )
    {
      for ( m = 0; m < *(_DWORD *)(a1 + 53704); ++m )
      {
        (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(16LL * m + *(_QWORD *)(a1 + 53720)), a1);
        *(_QWORD *)(16LL * m + *(_QWORD *)(a1 + 53720)) = 0LL;
      }
    }
    if ( *(_QWORD *)(a1 + 53712) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53712), a1);
      *(_QWORD *)(a1 + 53712) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 53720) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53720), a1);
      *(_QWORD *)(a1 + 53720) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 53680) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53680), a1);
      *(_QWORD *)(a1 + 53680) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 53696) )
    {
      (*(void ( **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 53696), a1);
      *(_QWORD *)(a1 + 53696) = 0LL;
    }
    if ( *(_DWORD *)(a1 + 53708) )
      break;
  }
  *(_DWORD *)(a1 + 53632) = 0;
  return 0xFFFFFFFFLL;
}
// 8920: using guessed type __int64  _libssh2_transport_send(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B70: using guessed type __int64  _libssh2_calloc(_QWORD, _QWORD);
// 8E30: using guessed type __int64  _libssh2_error(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64  _libssh2_store_str(_QWORD, _QWORD, _QWORD);
// 9200: using guessed type __int64  _libssh2_ntohu32(_QWORD);
// 9390: using guessed type __int64  _libssh2_packet_requirev(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9720: using guessed type __int64  _libssh2_store_u32(_QWORD, _QWORD);

//----- (00000000000443BF) ----------------------------------------------------
__int64  libssh2_userauth_keyboard_interactive_ex(__int64 a1, __int64 a2, unsigned int a3, void ( *a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64))
{
  void ( *v5)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64); // [rsp+0h] [rbp-30h]
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  time_t v8; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v8 = time(0LL);
  do
  {
    v7 = sub_43330(a1, a2, v6, v5);
    if ( v7 != -37 )
      break;
    if ( !*(_DWORD *)(a1 + 148) )
      break;
    v7 = _libssh2_wait_socket(a1, v8);
  }
  while ( !v7 );
  return v7;
}
// 9540: using guessed type __int64  _libssh2_wait_socket(_QWORD, _QWORD);

//----- (0000000000044433) ----------------------------------------------------
const char * libssh2_version(signed int a1)
{
  const char *result; // rax

  if ( a1 > (signed int)&loc_10900 )
    result = 0LL;
  else
    result = "1.9.0_DEV";
  return result;
}

//----- (0000000000044454) ----------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 444 function(s) have been successfully decompiled
