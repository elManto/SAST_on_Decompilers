/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_2CD0();
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
__int64 __fastcall slirp_new(_QWORD, _QWORD, _QWORD); // weak
// void free(void *ptr);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int strcasecmp(const char *s1, const char *s2);
// __int64 __fastcall g_string_new(_QWORD); weak
// int *__errno_location(void);
// __int64 __fastcall g_malloc(_QWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// __int64 __fastcall g_free(_QWORD); weak
// char *strcpy(char *dest, const char *src);
// __int64 __fastcall g_strsplit(_QWORD, _QWORD, _QWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int fcntl(int fd, int cmd, ...);
// char *inet_ntoa(struct in_addr in);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// int fclose(FILE *stream);
// int __xstat64(int ver, const char *filename, struct stat64 *stat_buf);
// int shutdown(int fd, int how);
// size_t strlen(const char *s);
// uint16_t htons(uint16_t hostshort);
// int dup2(int fd, int fd2);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// char *strchr(const char *s, int c);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// __int64 __fastcall g_rand_free(_QWORD); weak
// __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// __int64 __fastcall g_return_if_fail_warning(_QWORD, _QWORD, _QWORD); weak
// uint32_t htonl(uint32_t hostlong);
// void *memset(void *s, int c, size_t n);
// int ioctl(int fd, unsigned __int64 request, ...);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int close(int fd);
// __pid_t setsid(void);
// __int64 __fastcall g_string_free(_QWORD, _QWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *fgets(char *s, int n, FILE *stream);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 g_rand_new(void); weak
// __int64 __fastcall g_spawn_async(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// unsigned int if_nametoindex(const char *ifname);
// FILE *fopen64(const char *filename, const char *modes);
// void *memcpy(void *dest, const void *src, size_t n);
// __int64 __fastcall g_strstr_len(_QWORD, _QWORD, _QWORD); weak
// int inet_pton(int af, const char *cp, void *buf);
// void *malloc(size_t size);
// __int64 __fastcall g_malloc_n(_QWORD, _QWORD); weak
// __int64 __fastcall __isoc99_sscanf(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall g_rand_int_range(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall g_parse_debug_string(_QWORD, _QWORD, _QWORD); weak
// int listen(int fd, int n);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// __int64 __fastcall g_strfreev(_QWORD, _QWORD); weak
// __int64 __fastcall g_string_append_printf(_QWORD, _QWORD); weak
// __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD); weak
// void *realloc(void *ptr, size_t size);
// uint16_t ntohs(uint16_t netshort);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int open64(const char *file, int oflag, ...);
// void *memmove(void *dest, const void *src, size_t n);
// __int64 __fastcall g_malloc0_n(_QWORD, _QWORD); weak
// __int64 __fastcall g_realloc(_QWORD, _QWORD); weak
// __int64 __fastcall g_malloc0(_QWORD); weak
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int atoi(const char *nptr);
// __int64 __fastcall g_strdup(_QWORD); weak
// __int64 __fastcall g_getenv(_QWORD); weak
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __off64_t lseek64(int fd, __off64_t offset, int whence);
// uint32_t ntohl(uint32_t netlong);
// char *strerror(int errnum);
// char *strstr(const char *haystack, const char *needle);
// __int64 __fastcall g_error_free(_QWORD, _QWORD); weak
// int socket(int domain, int type, int protocol);
// __int64 __fastcall _cxa_finalize(_QWORD); weak
char *start();
__int64 sub_3220();
char *sub_3270();
__int64 sub_32B0();
signed __int64 __fastcall sub_32BA(_DWORD *a1, struct in_addr a2, void *a3);
signed __int64 __fastcall sub_350E(__int64 a1, struct in_addr a2, void *a3);
signed __int64 __fastcall sub_36F2(__int64 a1, _DWORD *a2, void *a3);
signed __int64 __fastcall sub_37BC(__int64 a1, uint32_t *a2, void *a3);
signed __int64 __fastcall sub_3869(__int64 a1, _DWORD *a2, void *a3);
uint32_t __fastcall sub_391B(__int64 a1, uint32_t *a2, uint32_t *a3);
unsigned __int64 __fastcall sub_3AD6(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_4485(__int64 a1);
__int64 __fastcall sub_44C3(__int64 a1, int a2);
__int64 __fastcall sub_4820(__int64 a1);
signed __int64 __fastcall sub_494B(__int64 a1, unsigned __int8 *a2, int a3, __int64 a4);
unsigned __int64 __fastcall sub_4B5B(__int64 a1, __int64 a2, int a3, unsigned __int8 *a4, int a5);
__int64 __fastcall sub_5152(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_5215(__int64 a1, __int64 a2);
signed __int64 __fastcall compar(const void *a1, const void *a2);
__int64 __fastcall sub_5378(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_542E(__int64 a1, unsigned __int64 a2);
_BYTE *__fastcall sub_54E9(__int64 a1, char *a2);
__int64 __fastcall sub_5613(__int64 a1, __int64 a2, unsigned __int64 a3);
char *__fastcall sub_5764(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_58E0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_5DCA(__int64 a1);
__int64 __fastcall sub_5DF1(__int64 a1, __int64 a2);
__int64 __fastcall sub_5E38(__int64 a1);
_QWORD *__fastcall sub_5E6B(_QWORD *a1);
__int64 __fastcall sub_5ECE(__int64 a1, __int64 a2);
__int64 __fastcall sub_6168(__int64 a1);
bool __fastcall sub_63A8(const void *a1, const void *a2);
bool __fastcall sub_63D7(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
bool __fastcall sub_64A4(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_658F(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_65CF(_QWORD *a1);
__int64 __fastcall sub_6697(__int64 a1);
__int64 __fastcall sub_6798(__int64 a1);
__int64 __fastcall sub_67E5(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_6903(__int64 a1, unsigned __int8 a2, char a3);
unsigned __int64 __fastcall sub_6C7B(__int64 a1);
unsigned __int64 __fastcall sub_7017(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_72E0(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_754E(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4);
unsigned __int64 __fastcall sub_7AE5(__int64 a1);
__int64 __fastcall sub_7E9D(__int64 a1);
__int64 __fastcall sub_7EB8(__int64 a1);
// unsigned __int64 __usercall sub_7ED3@<rax>(__int64 a1@<rdi>, __int64 a2@<r12>);
__int64 __fastcall sub_80BC(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_81F2(unsigned __int16 *a1);
_QWORD *__fastcall sub_8249(_QWORD *a1);
__int64 __fastcall sub_8296(__int64 a1);
signed __int64 __fastcall sub_82D5(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_84C1(__int64 a1);
unsigned __int64 __fastcall sub_851A(__int64 a1, int a2);
unsigned __int64 __fastcall sub_8B39(__int64 a1, char a2, char a3, int a4);
__int64 __fastcall sub_8F3F(__int64 a1);
__int64 __fastcall sub_9096(__int64 a1);
_QWORD *__fastcall sub_929D(_QWORD *a1);
__int64 __fastcall sub_92FC(__int64 a1);
// unsigned __int64 __usercall sub_932F@<rax>(__int64 a1@<rdi>, signed __int64 a2@<r12>);
unsigned __int64 __fastcall sub_96E7(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_9C34(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_9CB3(_QWORD *a1, __int64 *a2);
_QWORD *__fastcall sub_9D39(_QWORD **a1);
signed __int64 __fastcall sub_9D58(__int64 a1);
_BYTE *__fastcall sub_9E0E(__int64 a1);
__int64 __fastcall sub_9E96(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_A28A(_QWORD *a1);
signed __int64 __fastcall sub_A2ED(__int64 a1);
__int64 __fastcall sub_A39A(__int64 a1);
__int64 __fastcall sub_A4F0(__int64 a1);
__int64 __fastcall sub_A60D(signed __int64 a1, __int64 a2);
signed __int64 __fastcall sub_A70B(signed __int64 a1, int a2);
__int64 __fastcall sub_A875(__int64 a1, int a2);
signed __int64 __fastcall sub_A8D5(__int64 a1, __int64 a2, int a3, signed __int64 a4);
__int64 *__fastcall sub_A9B5(__int64 a1, unsigned __int64 a2);
int __fastcall sub_AAF4(int a1);
__int64 __fastcall sub_AB4C(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_AB7F(_QWORD *a1);
__int64 __fastcall sub_ABAD(__int64 *a1, __int64 a2, __int64 a3, int a4, int a5);
__int64 __fastcall sub_AC26(__int64 *a1, __int64 a2, int a3, int a4);
signed __int64 __fastcall sub_AC7E(int *a1);
__pid_t sub_AE71();
__int64 __fastcall sub_AE85(__int64 a1);
__int64 __fastcall sub_AEE9(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, __int64 a11);
signed __int64 __fastcall sub_AF8E(__int64 a1, __int64 a2);
__int64 __fastcall slirp_connection_info(_QWORD *a1);
__int64 __fastcall sub_B890(__int64 a1, int a2);
__int64 __fastcall sub_B8E6(__int64 a1);
__int64 __fastcall sub_B970(__int64 a1);
__int64 __fastcall sub_B99E(__int64 a1);
unsigned __int64 __fastcall sub_B9D7(__int64 a1, _BYTE *a2);
bool __fastcall sub_BCE7(const void *a1, const void *a2);
unsigned __int64 __fastcall sub_BD16(__int64 a1, __int64 a2, __int64 a3, void *a4);
signed __int64 __fastcall sub_C04F(__int64 a1, __int64 a2, __int64 a3, void *a4);
void __fastcall sub_C3AB(__int64 a1);
_BOOL8 __fastcall sub_C3CA(unsigned int *a1, unsigned int a2);
__int64 __fastcall sub_C48D(__int64 a1, unsigned int a2);
__int64 __fastcall sub_C59C(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_C791(unsigned __int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_C938(int *a1, int a2, int a3, char *a4);
bool __fastcall sub_CA4B(const void *a1, const void *a2);
__int64 __fastcall sub_CA7A(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_CABA(void *a1, const void *a2, unsigned int a3, struct stat64 *a4, _DWORD *a5);
signed __int64 __fastcall sub_CC9E(unsigned int a1, void *a2, void *a3, unsigned int a4, unsigned int *a5, _DWORD *a6);
signed __int64 __fastcall sub_CFD3(void *a1);
signed __int64 __fastcall sub_D049(void *a1, unsigned int *a2);
unsigned __int64 sub_D107();
__int64 __fastcall slirp_new(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall slirp_init(int a1, char a2, int a3, int a4, int a5, char a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, __int64 a21, __int64 a22, __int64 a23);
__int64 __fastcall slirp_cleanup(_QWORD *a1);
signed int *__fastcall sub_D8EF(__int64 a1, signed int *a2);
signed int *__fastcall slirp_pollfds_fill(__int64 a1, signed int *a2, __int64 (__fastcall *a3)(_QWORD, signed __int64, __int64), __int64 a4);
// unsigned __int64 __usercall slirp_pollfds_poll@<rax>(__int64 (__fastcall *a1)(_QWORD, __int64)@<rdx>, __int64 a2@<rcx>, signed __int64 a3@<rdi>, int a4@<esi>, __int64 a5@<r12>);
unsigned __int64 __fastcall sub_E15C(__int64 a1, __int64 a2);
// void __usercall slirp_input(signed int a1@<edx>, __int64 a2@<rdi>, unsigned __int8 *a3@<rsi>, signed __int64 a4@<r12>);
signed __int64 __fastcall sub_E629(__int64 a1, __int64 a2, __int64 a3, void *a4);
signed __int64 __fastcall sub_E86B(__int64 a1, __int64 a2, __int64 a3, void *a4);
signed __int64 __fastcall sub_E953(__int64 a1, __int64 a2);
signed __int64 __fastcall slirp_remove_hostfwd(__int64 a1, int a2, int a3, uint16_t a4);
signed __int64 __fastcall slirp_add_hostfwd(__int64 a1, int a2, int a3, uint16_t a4, in_addr_t a5, uint16_t a6);
signed __int64 __fastcall sub_EE4D(__int64 a1, uint32_t *a2, int a3);
signed __int64 __fastcall slirp_add_exec(__int64 a1, __int64 a2, uint32_t *a3, int a4);
signed __int64 __fastcall slirp_add_guestfwd(__int64 a1, __int64 a2, __int64 a3, uint32_t *a4, int a5);
ssize_t __fastcall sub_F014(__int64 a1, const void *a2, size_t a3, int a4);
__int64 *__fastcall sub_F0A9(__int64 a1, int a2, int a3);
__int64 __fastcall slirp_socket_can_recv(__int64 a1, int a2, int a3);
__int64 __fastcall slirp_socket_recv(__int64 a1, int a2, int a3, char *a4, int a5);
__int64 __fastcall sub_F245(__int64 a1, __int64 a2, unsigned __int64 a3);
int __fastcall sub_F2F8(int a1);
bool __fastcall sub_F350(const void *a1, const void *a2);
bool __fastcall sub_F37F(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
__int64 __fastcall sub_F44C(unsigned __int16 *a1, __int64 a2);
__int64 __fastcall sub_F550(unsigned __int16 *a1);
unsigned __int16 *__fastcall sub_F5A7(unsigned __int16 **a1, unsigned __int16 *a2, __int64 a3, __int64 a4);
void *__fastcall sub_F694(__int64 a1);
_QWORD *__fastcall sub_F6FF(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_F77A(__int64 a1);
__int64 __fastcall sub_F8A6(__int64 a1, _QWORD *a2, signed int *a3);
signed __int64 __fastcall sub_FC35(__int64 a1);
signed __int64 __fastcall sub_10030(__int64 a1, char *a2, int a3);
__int64 __fastcall sub_10238(__int64 a1);
__int64 __fastcall sub_10307(__int64 a1);
signed __int64 __fastcall sub_106A3(__int64 a1);
unsigned __int64 __fastcall sub_10A5A(__int64 a1);
signed __int64 __fastcall sub_11417(__int64 a1, __int64 a2);
struct in_addr *__fastcall sub_116C0(__int64 a1, struct in_addr a2, uint16_t a3, in_addr_t a4, uint16_t a5, int a6);
__int64 __fastcall sub_11ABA(__int64 a1);
__int64 __fastcall sub_11AF7(__int64 a1);
__int64 __fastcall sub_11B34(__int64 a1);
__int64 __fastcall sub_11BE0(__int64 a1);
__int64 __fastcall sub_11C8C(__int64 a1);
__int64 __fastcall sub_11CD0(__int64 a1, unsigned __int16 *a2);
char __fastcall sub_11E85(__int64 a1, unsigned __int16 *a2);
char __fastcall sub_11FE2(__int64 a1);
__int64 __fastcall sub_120B2(__int64 a1, unsigned int a2);
__int64 __fastcall sub_12107(__int64 a1);
__int64 __fastcall sub_12129(_DWORD *a1);
signed __int64 __fastcall sub_12190(__int64 a1);
bool __fastcall sub_1228A(__int64 a1, signed int a2);
bool __fastcall sub_1229E(_WORD *a1);
signed __int64 __fastcall sub_122C1(__int64 a1);
__int64 __fastcall sub_1230A(__int64 a1);
signed __int64 __fastcall sub_12361(__int64 a1);
unsigned __int64 __fastcall slirp_state_save(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall slirp_state_load(__int64 a1, int a2, __int64 a3, __int64 a4);
signed __int64 slirp_state_version();
bool __fastcall sub_12648(__int64 a1, __int64 a2, __int64 a3);
bool __fastcall sub_12681(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_126BA(__int64 a1);
bool __fastcall sub_12712(__int64 a1, char a2);
__int16 __fastcall sub_1273D(__int64 a1);
bool __fastcall sub_12799(__int64 a1, __int16 a2);
__int64 __fastcall sub_127D1(__int64 a1);
bool __fastcall sub_1284F(__int64 a1, unsigned int a2);
__int16 __fastcall sub_128A5(__int64 a1);
bool __fastcall sub_12901(__int64 a1, __int16 a2);
__int64 __fastcall sub_12939(__int64 a1);
bool __fastcall sub_129B7(__int64 a1, unsigned int a2);
__int64 __fastcall sub_12A0D(_DWORD *a1, __int64 a2, __int64 a3);
// unsigned __int64 __usercall sub_12CFB@<rax>(unsigned __int16 *a1@<rdx>, __int16 a2@<cx>, __int64 a3@<rdi>, unsigned int a4@<esi>, __int64 a5@<r12>);
unsigned __int64 __fastcall sub_14FE8(__int64 a1, unsigned __int8 *a2, int a3, __int64 a4);
__int64 __fastcall sub_1514F(_WORD *a1, int a2);
__int64 __fastcall sub_15314(__int64 a1, unsigned int a2);
__int64 __fastcall sub_15563(__int64 a1);
unsigned __int64 __fastcall sub_16346(_WORD *a1);
int __fastcall sub_163F5(int a1);
int __fastcall sub_1644D(int a1);
__int64 __fastcall sub_164A5(unsigned __int16 *a1);
__int64 __fastcall sub_164FC(__int64 a1);
__int64 __fastcall sub_16557(__int64 a1);
__int64 __fastcall sub_1659D(__int64 a1);
unsigned __int64 __fastcall sub_16709(__int64 a1, __int64 a2, __int64 a3, uint32_t a4, uint32_t a5, char a6, __int16 a7);
_QWORD *__fastcall sub_16EBD(__int64 a1);
__int64 __fastcall sub_16FC0(__int64 a1);
__int64 __fastcall sub_17098(_QWORD *a1);
__int64 __fastcall sub_17227(__int64 a1);
signed __int64 __fastcall sub_17310(__int64 a1, unsigned __int16 a2);
unsigned __int64 __fastcall sub_17600(unsigned int *a1);
signed __int64 __fastcall sub_17B83(_QWORD *a1);
__int64 __fastcall sub_17BE5(__int64 a1);
signed __int64 __fastcall sub_17D52(__int64 a1, signed __int64 a2);
signed __int64 __fastcall sub_190AA(__int64 a1);
signed __int64 __fastcall sub_19297(signed __int64 a1);
__int64 __fastcall sub_1933B(__int64 a1);
__int64 __fastcall sub_1949B(__int64 a1);
__int64 __fastcall sub_194C9(__int64 a1, signed int a2);
bool __fastcall sub_19784(const void *a1, const void *a2);
__int64 __fastcall sub_197B3(unsigned __int16 *a1, __int64 a2);
__int64 __fastcall sub_198B7(unsigned __int16 *a1);
_BOOL8 __fastcall sub_1990E(_QWORD *a1);
__int64 __fastcall sub_19928(__int64 a1);
__int64 __fastcall sub_19948(__int64 a1);
signed __int64 __fastcall sub_19996(__int64 a1, unsigned __int16 *a2, _WORD *a3);
signed __int64 __fastcall sub_19AAC(__int64 a1, __int64 a2, _WORD *a3);
signed __int64 __fastcall sub_19B4E(__int64 a1, int a2, void *a3, int a4);
__int64 __fastcall sub_19BFB(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_19C9C(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_19D9E(__int64 *a1, __int64 a2, __int64 a3, int a4, __int64 a5);
__int64 __fastcall sub_19EFE(__int64 *a1, uint16_t a2, char *a3, __int64 a4);
__int64 __fastcall sub_1A007(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_1A151(__int64 a1, unsigned __int16 *a2, _WORD *a3, int a4);
signed __int64 __fastcall sub_1A8B4(__int64 a1, __int64 a2, _WORD *a3);
signed __int64 __fastcall sub_1A928(__int64 a1, __int64 a2, _WORD *a3);
signed __int64 __fastcall sub_1A995(unsigned __int16 *a1, __int64 a2);
int __fastcall sub_1AA3C(int a1);
_QWORD *__fastcall sub_1AA94(_QWORD *a1);
__int64 __fastcall sub_1AAE1(__int64 a1);
unsigned __int64 __fastcall sub_1AB20(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1B11D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_1B34D(__int64 a1, unsigned __int16 a2);
__int64 __fastcall sub_1B3C9(__int64 a1);
__int64 __fastcall sub_1B422(__int64 a1);
void *__fastcall sub_1B58F(__int64 a1, int a2, __int16 a3, int a4, __int16 a5, int a6);
bool __fastcall sub_1B761(const void *a1, const void *a2);
unsigned __int64 __fastcall sub_1B790(__int64 a1);
__int64 __fastcall sub_1BF57(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
int __fastcall sub_1C142(int a1);
int __fastcall sub_1C1D0(int a1);
__int64 __fastcall sub_1C25E(int a1, int a2, int a3);
_BYTE *__fastcall sub_1C2CC(_BYTE *a1, int a2, char *a3);
const char *slirp_version_string();
signed __int64 __fastcall sub_1C346(__int64 a1);
signed __int64 __fastcall sub_1C399(__int64 a1, __int64 a2);
__int64 __fastcall sub_1C3F4(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1C42F(__int64 a1, char *a2);
__int64 __fastcall sub_1C46E(__int64 a1, __int16 *a2);
__int64 __fastcall sub_1C4AA(__int64 a1, __int16 *a2);
__int64 __fastcall sub_1C4E9(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1C524(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_1C55F(__int64 a1, __int16 *a2);
__int64 __fastcall sub_1C59B(__int64 a1, __int16 *a2);
__int64 __fastcall sub_1C5DA(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1C615(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_1C650(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1C6C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1C72E(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1C764(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1C79A(__int64 a1, __int64 a2);
__int64 __fastcall sub_1C88B(__int64 a1, __int64 a2);
__int64 __fastcall sub_1C8F0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1CC71(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1CCA2(__int64 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_1CD2E(__int64 a1, __int64 a2, __int64 a3, int a4);
int __fastcall sub_1D0D0(char *filename, struct stat64 *stat_buf);
void term_proc();
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
_UNKNOWN loc_10055; // weak
int dword_1D1A0 = 1666417251; // weak
_DWORD dword_1D7E0[20] = { 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 }; // idb
_BYTE byte_1E7D8[11] = { 20, 0, 2, 18, 16, 16, 17, 17, 17, 16, 16 }; // idb
_UNKNOWN unk_1E980; // weak
_UNKNOWN unk_1E982; // weak
_UNKNOWN unk_1E984; // weak
_BYTE byte_1E985[66] =
{
  0,
  21,
  0,
  21,
  0,
  16,
  2,
  0,
  0,
  23,
  0,
  16,
  0,
  0,
  0,
  80,
  0,
  8,
  0,
  0,
  0,
  1,
  2,
  16,
  22,
  0,
  0,
  32,
  2,
  16,
  3,
  0,
  0,
  31,
  2,
  16,
  0,
  0,
  0,
  11,
  26,
  8,
  4,
  0,
  0,
  12,
  26,
  8,
  4,
  0,
  0,
  158,
  27,
  16,
  5,
  0,
  0,
  113,
  0,
  16,
  7,
  0,
  0,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_1EA08; // weak
_UNKNOWN unk_1EA28; // weak
_UNKNOWN unk_1EA50; // weak
_WORD word_1EC60[26] =
{
  1,
  0,
  2,
  0,
  4,
  0,
  8,
  0,
  16,
  0,
  32,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0
}; // idb
_UNKNOWN unk_1EE38; // weak
char a5[2] = "5"; // weak
_UNKNOWN unk_1EE3C; // weak
_BYTE byte_1EE3D[6] = { 0, 0, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_20000; // weak
unsigned __int8 byte_222900[160] =
{
  128u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  129u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  130u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  131u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  132u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  133u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  134u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  135u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  136u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  137u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
char *off_222C20 = "slirp-socket"; // weak
char *off_222CA0 = "slirp"; // weak
void *off_2232A0 = &off_2232A0; // weak
char byte_224F40; // weak
int dword_224F60; // weak
_UNKNOWN unk_224F70; // weak
_UNKNOWN unk_224F80; // weak
_UNKNOWN unk_224F84; // weak
_UNKNOWN unk_224FA0; // weak
_UNKNOWN unk_225040; // weak
int dword_2250D0; // weak
int dword_2250D4; // weak
int dword_2250D8; // weak
_UNKNOWN unk_2250E0; // weak
_UNKNOWN unk_2250E4; // weak
_UNKNOWN unk_2250E8; // weak
_UNKNOWN unk_2250EC; // weak
// extern const struct in6_addr in6addr_any;
// extern const struct in6_addr in6addr_loopback;
// extern _UNKNOWN __cxa_finalize; weak


//----- (0000000000002CB8) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 225380: using guessed type __int64 _gmon_start__(void);

//----- (0000000000002CD0) ----------------------------------------------------
void sub_2CD0()
{
  JUMPOUT(&dword_0);
}
// 0: using guessed type int dword_0;

//----- (00000000000031E0) ----------------------------------------------------
char *start()
{
  char *result; // rax

  result = &byte_224F40;
  if ( &byte_224F40 != &byte_224F40 )
  {
    result = (char *)&ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (char *)ITM_deregisterTMCloneTable();
  }
  return result;
}
// 224F40: using guessed type char byte_224F40;
// 225378: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000003220) ----------------------------------------------------
__int64 sub_3220()
{
  return 0LL;
}

//----- (0000000000003270) ----------------------------------------------------
char *sub_3270()
{
  char *result; // rax

  if ( !byte_224F40 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_2232A0);
    result = start();
    byte_224F40 = 1;
  }
  return result;
}
// 31D0: using guessed type __int64 __fastcall _cxa_finalize(_QWORD);
// 2232A0: using guessed type void *off_2232A0;
// 224F40: using guessed type char byte_224F40;

//----- (00000000000032B0) ----------------------------------------------------
__int64 sub_32B0()
{
  return sub_3220();
}

//----- (00000000000032BA) ----------------------------------------------------
signed __int64 __fastcall sub_32BA(_DWORD *a1, struct in_addr a2, void *a3)
{
  signed __int64 result; // rax
  unsigned int v4; // eax
  int v5; // edx
  void *src; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+20h] [rbp-10h]
  int v8; // [rsp+24h] [rbp-Ch]
  signed __int64 v9; // [rsp+28h] [rbp-8h]

  src = a3;
  v8 = ~a1[4] | a1[3];
  v9 = (signed __int64)(a1 + 1282);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "arp_table_add...");
  if ( unk_2250E0 & 1 )
  {
    inet_ntoa(a2);
    g_log("Slirp", 128LL, " ip = %s");
  }
  result = unk_2250E0 & 1;
  if ( unk_2250E0 & 1 )
    result = g_log("Slirp", 128LL, " hw addr = %02x:%02x:%02x:%02x:%02x:%02x");
  if ( a2.s_addr )
  {
    if ( a2.s_addr != -1 )
    {
      result = a2.s_addr;
      if ( a2.s_addr != v8 )
      {
        for ( i = 0; i <= 15; ++i )
        {
          if ( a2.s_addr == *(_DWORD *)(v9 + 28LL * i + 14) )
            return (signed __int64)memcpy((void *)(v9 + 28LL * i + 8), src, 6uLL);
        }
        *(_DWORD *)((char *)&a1[7 * a1[1394] + 1285] + 2) = a2.s_addr;
        memcpy(&a1[7 * a1[1394] + 1284], src, 6uLL);
        v4 = (unsigned int)((a1[1394] + 1) >> 31) >> 28;
        v5 = (((_BYTE)v4 + *((_BYTE *)a1 + 5576) + 1) & 0xF) - v4;
        result = (signed __int64)(a1 + 1282);
        a1[1394] = v5;
      }
    }
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000350E) ----------------------------------------------------
signed __int64 __fastcall sub_350E(__int64 a1, struct in_addr a2, void *a3)
{
  signed __int64 result; // rax
  void *s; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  signed __int64 v7; // [rsp+28h] [rbp-8h]

  s = a3;
  v6 = ~*(_DWORD *)(a1 + 16) | *(_DWORD *)(a1 + 12);
  v7 = a1 + 5128;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "arp_table_search...");
  if ( unk_2250E0 & 1 )
  {
    inet_ntoa(a2);
    g_log("Slirp", 128LL, " ip = %s");
  }
  if ( a2.s_addr != -1 && a2.s_addr != v6 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i > 15 )
        return 0LL;
      if ( a2.s_addr == *(_DWORD *)(v7 + 28LL * i + 14) )
        break;
    }
    memcpy(s, (const void *)(v7 + 28LL * i + 8), 6uLL);
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " found hw addr = %02x:%02x:%02x:%02x:%02x:%02x");
    result = 1LL;
  }
  else
  {
    memset(s, 255, 6uLL);
    result = 1LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000036F2) ----------------------------------------------------
signed __int64 __fastcall sub_36F2(__int64 a1, _DWORD *a2, void *a3)
{
  int v4; // ebx
  void *s1; // [rsp+8h] [rbp-38h]
  signed int hostlong; // [rsp+24h] [rbp-1Ch]

  s1 = a3;
  for ( hostlong = 0; ; ++hostlong )
  {
    if ( hostlong > 15 )
      return 0LL;
    if ( !*(_WORD *)(8 * (hostlong + 34LL) + a1 + 10)
      || !memcmp(s1, (const void *)(8 * (hostlong + 34LL) + a1 + 12), 6uLL) )
    {
      break;
    }
  }
  *(_WORD *)(8 * (hostlong + 34LL) + a1 + 10) = 1;
  v4 = *(_DWORD *)(a1 + 60);
  *a2 = v4 + htonl(hostlong);
  return 8 * (hostlong + 34LL) + a1 + 10;
}

//----- (00000000000037BC) ----------------------------------------------------
signed __int64 __fastcall sub_37BC(__int64 a1, uint32_t *a2, void *a3)
{
  void *s1; // [rsp+8h] [rbp-28h]
  uint32_t v5; // [rsp+20h] [rbp-10h]
  uint32_t v6; // [rsp+24h] [rbp-Ch]
  _WORD *v7; // [rsp+28h] [rbp-8h]

  s1 = a3;
  v5 = ntohl(*a2);
  v6 = ntohl(*(_DWORD *)(a1 + 60));
  if ( v5 < v6 )
    return 0LL;
  if ( v5 >= v6 + 16 )
    return 0LL;
  v7 = (_WORD *)(8 * (v5 - v6 + 34LL) + a1 + 10);
  if ( *v7 )
  {
    if ( memcmp(s1, (const void *)(8 * (v5 - v6 + 34LL) + a1 + 12), 6uLL) )
      return 0LL;
  }
  *v7 = 1;
  return 8 * (v5 - v6 + 34LL) + a1 + 10;
}

//----- (0000000000003869) ----------------------------------------------------
signed __int64 __fastcall sub_3869(__int64 a1, _DWORD *a2, void *a3)
{
  int v4; // ebx
  void *s1; // [rsp+8h] [rbp-38h]
  signed int hostlong; // [rsp+24h] [rbp-1Ch]

  s1 = a3;
  for ( hostlong = 0; ; ++hostlong )
  {
    if ( hostlong > 15 )
      return 0LL;
    if ( !memcmp(s1, (const void *)(8 * (hostlong + 34LL) + a1 + 12), 6uLL) )
      break;
  }
  *(_WORD *)(8 * (hostlong + 34LL) + a1 + 10) = 1;
  v4 = *(_DWORD *)(a1 + 60);
  *a2 = v4 + htonl(hostlong);
  return 8 * (hostlong + 34LL) + a1 + 10;
}

//----- (000000000000391B) ----------------------------------------------------
uint32_t __fastcall sub_391B(__int64 a1, uint32_t *a2, uint32_t *a3)
{
  uint32_t result; // eax
  unsigned __int8 *v4; // rax
  uint32_t v5; // ebx
  uint32_t *v6; // [rsp+8h] [rbp-48h]
  int v7; // [rsp+28h] [rbp-28h]
  signed int v8; // [rsp+2Ch] [rbp-24h]
  _BYTE *s1; // [rsp+30h] [rbp-20h]
  unsigned __int8 *s1a; // [rsp+30h] [rbp-20h]
  uint32_t *s1b; // [rsp+30h] [rbp-20h]
  unsigned __int64 v12; // [rsp+38h] [rbp-18h]

  v6 = a3;
  *a2 = 0;
  *a3 = htonl(0);
  v12 = a1 + 576;
  result = memcmp((const void *)(a1 + 264), &dword_1D1A0, 4uLL);
  if ( !result )
  {
    s1 = (_BYTE *)(a1 + 268);
    while ( (unsigned __int64)s1 < v12 )
    {
      v7 = (unsigned __int8)*s1;
      if ( *s1 )
      {
        if ( v7 == 255 )
          break;
        s1a = s1 + 1;
        if ( (unsigned __int64)s1a >= v12 )
          break;
        v4 = s1a;
        s1b = (uint32_t *)(s1a + 1);
        v8 = *v4;
        if ( v12 < (unsigned __int64)s1b + *v4 )
          break;
        if ( unk_2250E0 & 1 )
          g_log("Slirp", 128LL, "dhcp: tag=%d len=%d\n...");
        if ( v7 == 50 )
        {
          if ( v8 > 3 )
            *v6 = *s1b;
        }
        else if ( v7 == 53 && v8 > 0 )
        {
          *a2 = *(unsigned __int8 *)s1b;
        }
        s1 = (char *)s1b + v8;
      }
      else
      {
        ++s1;
      }
    }
    result = *a2;
    if ( *a2 == 3 )
    {
      v5 = *v6;
      result = htonl(0);
      if ( v5 == result )
      {
        result = *(_DWORD *)(a1 + 40);
        if ( result )
        {
          result = (unsigned int)v6;
          *v6 = *(_DWORD *)(a1 + 40);
        }
      }
    }
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);
// 1D1A0: using guessed type int dword_1D1A0;

//----- (0000000000003AD6) ----------------------------------------------------
unsigned __int64 __fastcall sub_3AD6(__int64 a1, __int64 a2)
{
  uint32_t v2; // ebx
  uint32_t v3; // ebx
  __int64 v4; // rax
  uint32_t v5; // ebx
  __int64 v6; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  _BYTE *v11; // rax
  _BYTE *v12; // rax
  _BYTE *v13; // rax
  _BYTE *v14; // rax
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  _BYTE *v17; // rax
  _BYTE *v18; // rax
  _BYTE *v19; // rax
  _BYTE *v20; // rax
  _BYTE *v21; // rax
  _BYTE *v22; // rax
  _BYTE *v23; // rax
  _BYTE *v24; // rax
  _BYTE *v25; // rax
  _BYTE *v26; // rax
  _BYTE *v27; // rax
  _BYTE *v28; // rax
  _BYTE *v29; // rax
  _BYTE *v30; // rax
  _BYTE *v31; // rax
  _BYTE *v32; // rax
  _BYTE *v33; // rax
  uint32_t netlong; // [rsp+1Ch] [rbp-74h]
  int v36; // [rsp+20h] [rbp-70h]
  int v37; // [rsp+24h] [rbp-6Ch]
  __int64 v38; // [rsp+28h] [rbp-68h]
  void *dest; // [rsp+30h] [rbp-60h]
  __int64 v40; // [rsp+38h] [rbp-58h]
  void *s; // [rsp+40h] [rbp-50h]
  char *v42; // [rsp+48h] [rbp-48h]
  char v43; // [rsp+50h] [rbp-40h]
  uint16_t v44; // [rsp+52h] [rbp-3Eh]
  int v45; // [rsp+54h] [rbp-3Ch]
  char v46; // [rsp+60h] [rbp-30h]
  uint16_t v47; // [rsp+62h] [rbp-2Eh]
  uint32_t v48; // [rsp+64h] [rbp-2Ch]
  int v49; // [rsp+72h] [rbp-1Eh]
  __int16 v50; // [rsp+76h] [rbp-1Ah]
  unsigned __int64 v51; // [rsp+78h] [rbp-18h]

  v51 = __readfsqword(0x28u);
  v38 = 0LL;
  sub_391B(a2, (uint32_t *)&v36, &netlong);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "bootp packet op=%d msgtype=%d...");
  v2 = netlong;
  if ( v2 == htonl(0) )
  {
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, "\n...");
  }
  else if ( unk_2250E0 & 1 )
  {
    ntohl(netlong);
    g_log("Slirp", 128LL, " req_addr=%08x\n...");
  }
  if ( !v36 )
    v36 = 3;
  if ( v36 == 1 || v36 == 3 )
  {
    v49 = *(_DWORD *)(a2 + 56);
    v50 = *(_WORD *)(a2 + 60);
    v40 = sub_A39A(a1);
    if ( v40 )
    {
      *(_QWORD *)(v40 + 48) += 16LL;
      s = *(void **)(v40 + 48);
      *(_QWORD *)(v40 + 48) += 28LL;
      memset(s, 0, 0x240uLL);
      if ( v36 == 1 )
      {
        v3 = netlong;
        if ( v3 != htonl(0) )
        {
          v38 = sub_37BC(a1, &netlong, &v49);
          if ( v38 )
            v48 = netlong;
        }
        if ( v38 )
        {
LABEL_21:
          v4 = v38 + 2;
          *(_DWORD *)v4 = v49;
          *(_WORD *)(v4 + 4) = v50;
          goto LABEL_27;
        }
      }
      else
      {
        v5 = netlong;
        if ( v5 != htonl(0) )
        {
          v38 = sub_37BC(a1, &netlong, &v49);
          if ( v38 )
          {
            v48 = netlong;
            v6 = v38 + 2;
            *(_DWORD *)v6 = v49;
            *(_WORD *)(v6 + 4) = v50;
          }
          else
          {
            v48 = -1;
          }
          goto LABEL_27;
        }
        v38 = sub_3869(a1, &v48, (void *)(a2 + 56));
        if ( v38 )
        {
LABEL_27:
          sub_32BA((_DWORD *)a1, (struct in_addr)v48, &v49);
          v45 = *(_DWORD *)(a1 + 20);
          v44 = htons(0x43u);
          v47 = htons(0x44u);
          *((_BYTE *)s + 28) = 2;
          *((_DWORD *)s + 8) = *(_DWORD *)(a2 + 32);
          *((_BYTE *)s + 29) = 1;
          *((_BYTE *)s + 30) = 6;
          memcpy((char *)s + 56, (const void *)(a2 + 56), 6uLL);
          *((_DWORD *)s + 11) = v48;
          *((_DWORD *)s + 12) = v45;
          dest = (char *)s + 264;
          v42 = (char *)s + 576;
          *((_DWORD *)s + 66) = 1666417251;
          dest = (char *)dest + 4;
          if ( v38 )
          {
            if ( unk_2250E0 & 1 )
            {
              ntohl(v48);
              g_log("Slirp", 128LL, "%s addr=%08x\n...");
            }
            if ( v36 == 1 )
            {
              v7 = dest;
              dest = (char *)dest + 1;
              *v7 = 53;
              v8 = dest;
              dest = (char *)dest + 1;
              *v8 = 1;
              v9 = dest;
              dest = (char *)dest + 1;
              *v9 = 2;
            }
            else
            {
              v10 = dest;
              dest = (char *)dest + 1;
              *v10 = 53;
              v11 = dest;
              dest = (char *)dest + 1;
              *v11 = 1;
              v12 = dest;
              dest = (char *)dest + 1;
              *v12 = 5;
            }
            if ( *(_QWORD *)(a1 + 416) )
              snprintf((char *)s + 136, 0x80uLL, "%s", *(_QWORD *)(a1 + 416));
            v13 = dest;
            dest = (char *)dest + 1;
            *v13 = 54;
            v14 = dest;
            dest = (char *)dest + 1;
            *v14 = 4;
            *(_DWORD *)dest = v45;
            dest = (char *)dest + 4;
            v15 = dest;
            dest = (char *)dest + 1;
            *v15 = 1;
            v16 = dest;
            dest = (char *)dest + 1;
            *v16 = 4;
            *(_DWORD *)dest = *(_DWORD *)(a1 + 16);
            dest = (char *)dest + 4;
            if ( !*(_DWORD *)(a1 + 124) )
            {
              v17 = dest;
              dest = (char *)dest + 1;
              *v17 = 3;
              v18 = dest;
              dest = (char *)dest + 1;
              *v18 = 4;
              *(_DWORD *)dest = v45;
              dest = (char *)dest + 4;
              v19 = dest;
              dest = (char *)dest + 1;
              *v19 = 6;
              v20 = dest;
              dest = (char *)dest + 1;
              *v20 = 4;
              *(_DWORD *)dest = *(_DWORD *)(a1 + 64);
              dest = (char *)dest + 4;
            }
            v21 = dest;
            dest = (char *)dest + 1;
            *v21 = 51;
            v22 = dest;
            dest = (char *)dest + 1;
            *v22 = 4;
            v37 = htonl(0x15180u);
            *(_DWORD *)dest = v37;
            dest = (char *)dest + 4;
            if ( *(_BYTE *)(a1 + 88) )
            {
              v37 = strlen((const char *)(a1 + 88));
              if ( v42 > (char *)dest + v37 + 2 )
              {
                v23 = dest;
                dest = (char *)dest + 1;
                *v23 = 12;
                v24 = dest;
                dest = (char *)dest + 1;
                *v24 = v37;
                memcpy(dest, (const void *)(a1 + 88), v37);
                dest = (char *)dest + v37;
              }
              else
              {
                g_log("Slirp", 16LL, "DHCP packet size exceeded, omitting host name option.");
              }
            }
            if ( *(_QWORD *)(a1 + 440) )
            {
              v37 = strlen(*(const char **)(a1 + 440));
              if ( v42 > (char *)dest + v37 + 2 )
              {
                v25 = dest;
                dest = (char *)dest + 1;
                *v25 = 15;
                v26 = dest;
                dest = (char *)dest + 1;
                *v26 = v37;
                memcpy(dest, *(const void **)(a1 + 440), v37);
                dest = (char *)dest + v37;
              }
              else
              {
                g_log("Slirp", 16LL, "DHCP packet size exceeded, omitting domain name option.");
              }
            }
            if ( *(_QWORD *)(a1 + 5120) )
            {
              v37 = strlen(*(const char **)(a1 + 5120));
              if ( v42 > (char *)dest + v37 + 2 )
              {
                v27 = dest;
                dest = (char *)dest + 1;
                *v27 = 66;
                v28 = dest;
                dest = (char *)dest + 1;
                *v28 = v37;
                memcpy(dest, *(const void **)(a1 + 5120), v37);
                dest = (char *)dest + v37;
              }
              else
              {
                g_log("Slirp", 16LL, "DHCP packet size exceeded, omitting tftp-server-name option.");
              }
            }
            if ( *(_QWORD *)(a1 + 432) )
            {
              v37 = *(_QWORD *)(a1 + 424);
              if ( v42 > (char *)dest + v37 )
              {
                memcpy(dest, *(const void **)(a1 + 432), v37);
                dest = (char *)dest + v37;
              }
              else
              {
                g_log("Slirp", 16LL, "DHCP packet size exceeded, omitting domain-search option.");
              }
            }
          }
          else
          {
            if ( unk_2250E0 & 1 )
            {
              ntohl(netlong);
              g_log("Slirp", 128LL, "nak'ed addr=%08x\n...");
            }
            v29 = dest;
            dest = (char *)dest + 1;
            *v29 = 53;
            v30 = dest;
            dest = (char *)dest + 1;
            *v30 = 1;
            v31 = dest;
            dest = (char *)dest + 1;
            *v31 = 6;
            v32 = dest;
            dest = (char *)dest + 1;
            *v32 = 56;
            v33 = dest;
            dest = (char *)dest + 1;
            *v33 = 31;
            memcpy(dest, "requested address not available", 0x1FuLL);
            dest = (char *)dest + 31;
          }
          if ( dest >= v42 )
            __assert_fail("q < end", "../src/bootp.c", 0x160u, "bootp_reply");
          *(_BYTE *)dest = -1;
          v48 = -1;
          *(_DWORD *)(v40 + 56) = 548;
          sub_1B11D(0LL, v40, (__int64)&v43, (__int64)&v46, 16);
          return __readfsqword(0x28u) ^ v51;
        }
      }
      v38 = sub_36F2(a1, &v48, &v49);
      if ( !v38 )
      {
        if ( unk_2250E0 & 1 )
          g_log("Slirp", 128LL, "no address left\n...");
        return __readfsqword(0x28u) ^ v51;
      }
      goto LABEL_21;
    }
  }
  return __readfsqword(0x28u) ^ v51;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);
// 1D1A0: using guessed type int dword_1D1A0;

//----- (0000000000004485) ----------------------------------------------------
unsigned __int64 __fastcall sub_4485(__int64 a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = *(_QWORD *)(a1 + 48);
  result = *(unsigned __int8 *)(v2 + 28);
  if ( (_BYTE)result == 1 )
    result = sub_3AD6(*(_QWORD *)(a1 + 64), v2);
  return result;
}

//----- (00000000000044C3) ----------------------------------------------------
__int64 __fastcall sub_44C3(__int64 a1, int a2)
{
  int v2; // ebx
  int v3; // er13
  unsigned __int16 *v4; // r12
  int v5; // er13
  int v6; // er13
  unsigned __int16 *v7; // rax
  int v8; // ebx
  int v9; // ebx
  int v11; // [rsp+4h] [rbp-4Ch]
  signed int v12; // [rsp+1Ch] [rbp-34h]
  unsigned __int16 v13; // [rsp+22h] [rbp-2Eh]

  v11 = a2;
  v2 = 0;
  v3 = 0;
  v12 = 0;
  if ( *(_DWORD *)(a1 + 56) )
  {
    v4 = *(unsigned __int16 **)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
    if ( a2 < v5 )
      v5 = a2;
    v11 = a2 - v5;
    if ( (unsigned __int8)v4 & 1 && v5 > 0 )
    {
      v2 = 0;
      LOBYTE(v13) = *(_BYTE *)v4;
      v4 = (unsigned __int16 *)((char *)v4 + 1);
      --v5;
      v12 = 1;
    }
    while ( 1 )
    {
      v5 -= 32;
      if ( v5 < 0 )
        break;
      v2 += v4[15]
          + v4[14]
          + v4[13]
          + v4[12]
          + v4[11]
          + v4[10]
          + v4[9]
          + v4[8]
          + v4[7]
          + v4[6]
          + v4[5]
          + v4[4]
          + v4[3]
          + v4[2]
          + v4[1]
          + *v4;
      v4 += 16;
    }
    v6 = v5 + 32;
    while ( 1 )
    {
      v6 -= 8;
      if ( v6 < 0 )
        break;
      v2 += v4[3] + v4[2] + v4[1] + *v4;
      v4 += 4;
    }
    v3 = v6 + 8;
    if ( v3 || v12 )
    {
      v2 = (unsigned __int16)v2 + HIWORD(v2);
      if ( v2 > 0xFFFF )
        v2 -= 0xFFFF;
      while ( 1 )
      {
        v3 -= 2;
        if ( v3 < 0 )
          break;
        v7 = v4;
        ++v4;
        v2 += *v7;
      }
      if ( v12 )
      {
        v8 = (unsigned __int16)v2 + HIWORD(v2);
        if ( v8 > 0xFFFF )
          v8 -= 0xFFFF;
        v2 = v8 << 8;
        if ( v3 == -1 )
        {
          HIBYTE(v13) = *(_BYTE *)v4;
          v2 += v13;
          v3 = 0;
        }
        else
        {
          v3 = -1;
        }
      }
      else if ( v3 == -1 )
      {
        LOBYTE(v13) = *(_BYTE *)v4;
      }
    }
  }
  if ( v11 )
  {
    if ( unk_2250E0 & 4 )
      g_log("Slirp", 128LL, "cksum: out of data");
    if ( unk_2250E0 & 4 )
      g_log("Slirp", 128LL, " len = %d");
  }
  if ( v3 == -1 )
    v2 += (unsigned __int8)v13;
  v9 = (unsigned __int16)v2 + HIWORD(v2);
  if ( v9 > 0xFFFF )
    LOWORD(v9) = v9 + 1;
  return (unsigned __int16)~(_WORD)v9;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000004820) ----------------------------------------------------
__int64 __fastcall sub_4820(__int64 a1)
{
  __int64 *v1; // ST20_8
  __int64 v2; // ST28_8
  __int64 v3; // ST30_8
  __int64 v4; // ST38_8
  __int64 v5; // ST40_8
  __int64 v6; // ST48_8
  __int64 v7; // ST50_8
  __int64 v8; // rdx
  uint16_t v9; // ax
  uint32_t v10; // eax
  __int64 result; // rax

  v1 = *(__int64 **)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 48);
  v3 = *v1;
  v4 = v1[1];
  v5 = v1[2];
  v6 = v1[3];
  v7 = v1[4];
  v8 = v1[2];
  *(_QWORD *)v2 = v4;
  *(_QWORD *)(v2 + 8) = v8;
  *(_QWORD *)(v2 + 16) = v6;
  *(_QWORD *)(v2 + 24) = v7;
  v9 = ntohs(WORD2(v3));
  *(_DWORD *)(v2 + 32) = htonl(v9);
  *(_WORD *)(v2 + 36) = 0;
  *(_BYTE *)(v2 + 38) = 0;
  *(_BYTE *)(v2 + 39) = BYTE6(v3);
  v10 = ntohl(*(_DWORD *)(v2 + 32));
  LODWORD(result) = sub_44C3(a1, v10 + 40);
  *v1 = v3;
  v1[1] = v4;
  v1[2] = v5;
  v1[3] = v6;
  v1[4] = v7;
  return (unsigned int)result;
}

//----- (000000000000494B) ----------------------------------------------------
signed __int64 __fastcall sub_494B(__int64 a1, unsigned __int8 *a2, int a3, __int64 a4)
{
  int v5; // eax
  __int64 v6; // [rsp+0h] [rbp-30h]
  int v7; // [rsp+Ch] [rbp-24h]
  unsigned __int8 *v8; // [rsp+10h] [rbp-20h]
  int i; // [rsp+20h] [rbp-10h]
  int v10; // [rsp+28h] [rbp-8h]

  v8 = a2;
  v7 = a3;
  v6 = a4;
  while ( v7 > 4 )
  {
    v10 = (v8[2] << 8) | v8[3];
    if ( v7 < v10 + 4 )
    {
      (*(void (__fastcall **)(const char *, _QWORD))(*(_QWORD *)(a1 + 5992) + 8LL))(
        "Guest sent bad DHCPv6 packet!",
        *(_QWORD *)(a1 + 6000));
      return 4294967289LL;
    }
    switch ( (*v8 << 8) | v8[1] )
    {
      case 5:
        return 4294967274LL;
      case 6:
        if ( v8[3] & 1 )
          return 4294967274LL;
        for ( i = 0; i < v10; i += 2 )
        {
          v5 = (v8[i + 4] << 8) | v8[i + 5];
          if ( v5 == 23 )
          {
            *(_BYTE *)(v6 + 12) = 1;
          }
          else if ( ((v8[i + 4] << 8) | v8[i + 5]) == 59 )
          {
            *(_BYTE *)(v6 + 13) = 1;
          }
          else if ( unk_2250E0 & 2 )
          {
            g_log("Slirp", 128LL, "dhcpv6: Unsupported option request %d");
          }
        }
        break;
      case 1:
        if ( ((v8[2] << 8) | v8[3]) > 256 )
          return 4294967289LL;
        *(_QWORD *)v6 = v8 + 4;
        *(_DWORD *)(v6 + 8) = v10;
        break;
      default:
        if ( unk_2250E0 & 2 )
          g_log("Slirp", 128LL, "dhcpv6 info req: Unsupported option %d, len=%d");
        break;
    }
    v8 += v10 + 4;
    v7 -= v10 + 4;
  }
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000004B5B) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B5B(__int64 a1, __int64 a2, int a3, unsigned __int8 *a4, int a5)
{
  _BYTE *v5; // STB8_8
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  char *v8; // rax
  char *v9; // STB8_8
  char *v10; // rax
  char *v11; // rax
  char *v12; // rax
  char *v13; // rax
  _OWORD *v14; // STB8_8
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  _BYTE *v17; // rax
  char *v18; // rax
  char *v19; // STB8_8
  _BYTE *v20; // rax
  int v21; // eax
  __int64 v22; // rdx
  __int64 v23; // rdx
  int v25; // [rsp+2Ch] [rbp-C4h]
  int v26; // [rsp+40h] [rbp-B0h]
  char *dest; // [rsp+48h] [rbp-A8h]
  _BYTE *desta; // [rsp+48h] [rbp-A8h]
  __int64 v29; // [rsp+50h] [rbp-A0h]
  void *src; // [rsp+60h] [rbp-90h]
  __int64 v31; // [rsp+68h] [rbp-88h]
  char v32; // [rsp+70h] [rbp-80h]
  __int16 v33; // [rsp+72h] [rbp-7Eh]
  __int64 v34; // [rsp+78h] [rbp-78h]
  __int64 v35; // [rsp+80h] [rbp-70h]
  char v36; // [rsp+90h] [rbp-60h]
  __int16 v37; // [rsp+92h] [rbp-5Eh]
  __int64 v38; // [rsp+98h] [rbp-58h]
  __int64 v39; // [rsp+A0h] [rbp-50h]
  unsigned __int64 v40; // [rsp+B8h] [rbp-38h]

  v25 = a3;
  v40 = __readfsqword(0x28u);
  src = 0LL;
  v31 = 0LL;
  if ( (signed int)sub_494B(a1, a4, a5, (__int64)&src) >= 0 )
  {
    v29 = sub_A39A(a1);
    if ( v29 )
    {
      memset(*(void **)(v29 + 48), 0, *(signed int *)(v29 + 36));
      *(_QWORD *)(v29 + 48) += 16LL;
      v5 = (_BYTE *)(*(_QWORD *)(v29 + 48) + 49LL);
      *(_BYTE *)(*(_QWORD *)(v29 + 48) + 48LL) = 7;
      v6 = v5++;
      *v6 = BYTE2(v25);
      *v5 = BYTE1(v25);
      v7 = v5 + 1;
      dest = v5 + 2;
      *v7 = v25;
      if ( src )
      {
        v8 = dest;
        v9 = dest + 1;
        *v8 = 0;
        v10 = v9++;
        *v10 = 1;
        v11 = v9++;
        *v11 = BYTE1(v31);
        v12 = v9++;
        *v12 = v31;
        memcpy(v9, src, (signed int)v31);
        dest = &v9[(signed int)v31];
      }
      if ( BYTE4(v31) )
      {
        v13 = dest;
        v14 = dest + 1;
        *v13 = 0;
        v15 = v14;
        v14 = (_OWORD *)((char *)v14 + 1);
        *v15 = 23;
        v16 = v14;
        v14 = (_OWORD *)((char *)v14 + 1);
        *v16 = 0;
        v17 = v14;
        v14 = (_OWORD *)((char *)v14 + 1);
        *v17 = 16;
        *v14 = *(_OWORD *)(a1 + 68);
        dest = (char *)(v14 + 1);
      }
      if ( BYTE5(v31) )
      {
        v18 = dest;
        v19 = dest + 1;
        *v18 = 0;
        v20 = v19;
        desta = v19 + 1;
        *v20 = 59;
        v26 = *(unsigned __int64 *)(v29 + 48) + *(_DWORD *)(a1 + 136) - ((_DWORD)desta + 2);
        v21 = snprintf(
                desta + 2,
                v26,
                "tftp://[%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x]/%s",
                *(unsigned __int8 *)(a1 + 44),
                *(unsigned __int8 *)(a1 + 45),
                *(unsigned __int8 *)(a1 + 46),
                *(unsigned __int8 *)(a1 + 47),
                *(unsigned __int8 *)(a1 + 48),
                *(unsigned __int8 *)(a1 + 49),
                *(unsigned __int8 *)(a1 + 50),
                *(unsigned __int8 *)(a1 + 51),
                *(unsigned __int8 *)(a1 + 52),
                *(unsigned __int8 *)(a1 + 53),
                *(unsigned __int8 *)(a1 + 54),
                *(unsigned __int8 *)(a1 + 55),
                *(unsigned __int8 *)(a1 + 56),
                *(unsigned __int8 *)(a1 + 57),
                *(unsigned __int8 *)(a1 + 58),
                *(unsigned __int8 *)(a1 + 59),
                *(_QWORD *)(a1 + 416));
        if ( v26 <= v21 )
          v21 = v26;
        *desta = BYTE1(v21);
        desta[1] = v21;
        dest = &desta[v21 + 2];
      }
      v22 = *(_QWORD *)(a1 + 52);
      v34 = *(_QWORD *)(a1 + 44);
      v35 = v22;
      v33 = 547;
      v23 = *(_QWORD *)(a2 + 16);
      v38 = *(_QWORD *)(a2 + 8);
      v39 = v23;
      v37 = *(_WORD *)(a2 + 2);
      *(_QWORD *)(v29 + 48) += 48LL;
      *(_DWORD *)(v29 + 56) = (_DWORD)dest - *(unsigned __int64 *)(v29 + 48);
      sub_1BF57(0LL, v29, (__int64)&v32, (__int64)&v36);
    }
  }
  return __readfsqword(0x28u) ^ v40;
}

//----- (0000000000005152) ----------------------------------------------------
__int64 __fastcall sub_5152(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // [rsp+10h] [rbp-10h]
  int v4; // [rsp+14h] [rbp-Ch]
  signed __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = *(_QWORD *)(a2 + 48) + 8LL;
  result = (unsigned int)(*(_DWORD *)(a2 + 56) - 8);
  v3 = *(_DWORD *)(a2 + 56) - 8;
  if ( v3 > 3 )
  {
    v4 = ntohl(*(_DWORD *)v5) & 0xFFFFFF;
    if ( *(_BYTE *)v5 == 11 )
    {
      result = sub_4B5B(*(_QWORD *)(a2 + 64), a1, v4, (unsigned __int8 *)(v5 + 4), v3 - 4);
    }
    else
    {
      result = unk_2250E0 & 2;
      if ( unk_2250E0 & 2 )
        result = g_log("Slirp", 128LL, "dhcpv6_input: Unsupported message type 0x%x");
    }
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000005215) ----------------------------------------------------
unsigned __int64 __fastcall sub_5215(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // ST28_8
  unsigned __int64 v3; // ST30_8
  unsigned __int64 v4; // rax
  __int64 v6; // [rsp+10h] [rbp-30h]
  __int64 v7; // [rsp+18h] [rbp-28h]
  unsigned __int64 i; // [rsp+20h] [rbp-20h]

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a1 + 16) + v2;
  v7 = *(_QWORD *)(a2 + 16) + v3;
  v4 = *(_QWORD *)(a1 + 24);
  if ( v3 <= v2 )
    v4 = *(_QWORD *)(a2 + 24);
  for ( i = 0LL; i < v4; ++i )
  {
    if ( *(_BYTE *)--v6 != *(_BYTE *)--v7 )
      break;
  }
  return i;
}

//----- (00000000000052AE) ----------------------------------------------------
signed __int64 __fastcall compar(const void *a1, const void *a2)
{
  unsigned __int64 v2; // ST38_8
  unsigned __int8 v4; // [rsp+16h] [rbp-2Ah]
  unsigned __int8 v5; // [rsp+17h] [rbp-29h]
  unsigned __int64 v6; // [rsp+28h] [rbp-18h]
  unsigned __int64 v7; // [rsp+30h] [rbp-10h]

  v6 = *((_QWORD *)a1 + 3);
  v7 = *((_QWORD *)a2 + 3);
  v2 = sub_5215((__int64)a1, (__int64)a2);
  v4 = *(_BYTE *)(*((_QWORD *)a1 + 2) + v6 - v2);
  v5 = *(_BYTE *)(*((_QWORD *)a2 + 2) + v7 - v2);
  if ( v4 < v5 )
    return 0xFFFFFFFFLL;
  if ( v4 > v5 )
    return 1LL;
  if ( v6 >= v7 )
    return v6 > v7;
  return 0xFFFFFFFFLL;
}

//----- (0000000000005378) ----------------------------------------------------
__int64 __fastcall sub_5378(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  _BYTE *i; // [rsp+10h] [rbp-20h]
  unsigned __int64 v4; // [rsp+20h] [rbp-10h]

  v4 = *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 24) - sub_5215(a1, a2);
  for ( i = *(_BYTE **)(a1 + 16); *i && (unsigned __int64)i < v4; i += (unsigned __int8)*i + 1 )
    ;
  if ( *(_QWORD *)(a1 + 24) - (_QWORD)&i[-*(_QWORD *)(a1 + 16)] <= 2uLL )
    result = 0LL;
  else
    result = *(_QWORD *)(a1 + 24) - (_QWORD)&i[-*(_QWORD *)(a1 + 16)];
  return result;
}

//----- (000000000000542E) ----------------------------------------------------
unsigned __int64 __fastcall sub_542E(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // ST28_8
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+10h] [rbp-20h]
  _QWORD *v5; // [rsp+18h] [rbp-18h]
  _QWORD *v6; // [rsp+20h] [rbp-10h]

  for ( i = 0LL; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v5 = (_QWORD *)(40 * i + a1);
    v6 = (_QWORD *)*v5;
    while ( !v5[4] )
    {
      v2 = (_QWORD *)*v6;
      *v6 = v5;
      ++v5[4];
      v5 = v6;
      v6 = v2;
    }
  }
  return result;
}

//----- (00000000000054E9) ----------------------------------------------------
_BYTE *__fastcall sub_54E9(__int64 a1, char *a2)
{
  char *v2; // rax
  _BYTE *result; // rax
  char v4; // [rsp+1Fh] [rbp-21h]
  _BYTE *v5; // [rsp+20h] [rbp-20h]
  _BYTE *v6; // [rsp+28h] [rbp-18h]
  char *v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v5 = *(_BYTE **)(a1 + 16);
  v6 = *(_BYTE **)(a1 + 16);
  v7 = a2;
  v8 = 0LL;
  if ( *(_QWORD *)(a1 + 24) )
  {
    ++*(_QWORD *)(a1 + 24);
    do
    {
      v2 = v7++;
      v4 = *v2;
      if ( *v2 != 46 && v4 )
      {
        result = ++v6;
        *v6 = v4;
      }
      else
      {
        v8 = v6 - v5;
        if ( v6 == v5 && v4 == 46 || v8 > 0x3F )
          goto LABEL_13;
        *v5 = v8;
        result = ++v6;
        v5 = v6;
      }
    }
    while ( v4 );
    if ( v8 )
    {
      *v5 = 0;
      result = (_BYTE *)a1;
      ++*(_QWORD *)(a1 + 24);
    }
  }
  else
  {
LABEL_13:
    g_log("Slirp", 16LL, "failed to parse domain name '%s'\n");
    result = (_BYTE *)a1;
    *(_QWORD *)(a1 + 24) = 0LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000005613) ----------------------------------------------------
__int64 __fastcall sub_5613(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax
  unsigned __int64 v5; // [rsp+8h] [rbp-48h]
  __int64 v6; // [rsp+28h] [rbp-28h]
  __int64 i; // [rsp+28h] [rbp-28h]
  __int64 v8; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 j; // [rsp+38h] [rbp-18h]
  unsigned __int64 v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v5 = a3;
  v6 = a1;
  v9 = a1;
  do
  {
    if ( *(_QWORD *)(v6 + 16) < *(_QWORD *)(v9 + 16) )
      v9 = v6;
    v3 = v6;
    v6 += 40LL;
  }
  while ( a2 != v3 );
  for ( i = a1; ; i += 40LL )
  {
    result = i;
    if ( i == a2 )
      break;
    if ( v5 != *(_QWORD *)(i + 32) )
    {
      v11 = -1LL;
      for ( j = i; j != a2; j += 40LL )
      {
        v12 = *(_QWORD *)(j + 32);
        if ( v12 <= v5 )
          break;
        if ( v12 < v11 )
          v11 = *(_QWORD *)(j + 32);
      }
      sub_5613(i, j, v11);
      i = j;
      result = j;
      if ( j == a2 )
        break;
    }
  }
  if ( v5 )
  {
    v8 = a1;
    do
    {
      if ( v8 != v9 && !*(_QWORD *)(v8 + 8) )
      {
        *(_QWORD *)(v8 + 8) = v9;
        *(_QWORD *)(v8 + 32) = v5;
      }
      result = v8;
      v8 += 40LL;
    }
    while ( a2 != result );
  }
  return result;
}

//----- (0000000000005764) ----------------------------------------------------
char *__fastcall sub_5764(__int64 a1, unsigned __int64 a2)
{
  char *dest; // [rsp+10h] [rbp-30h]
  unsigned __int64 i; // [rsp+18h] [rbp-28h]
  __int64 v5; // [rsp+20h] [rbp-20h]
  __int64 v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v5 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
  dest = *(char **)(*(_QWORD *)a1 + 16LL);
  for ( i = 0LL; i < a2; ++i )
  {
    v6 = *(_QWORD *)(40 * i + a1);
    v7 = *(_QWORD *)(v6 + 8);
    if ( v7 )
    {
      v8 = *(_QWORD *)(v7 + 16) - v5 + *(_QWORD *)(v7 + 24) - *(_QWORD *)(v6 + 32);
      if ( v8 <= 0x3FFE )
      {
        *(_QWORD *)(v6 + 24) = *(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 32) + 2LL;
        *(_BYTE *)(*(_QWORD *)(v6 + 16) + *(_QWORD *)(v6 + 24) - 1LL) = v8;
        *(_BYTE *)(*(_QWORD *)(v6 + 16) + *(_QWORD *)(v6 + 24) - 2LL) = BYTE1(v8) | 0xC0;
      }
    }
    if ( dest != *(char **)(v6 + 16) )
    {
      memmove(dest, *(const void **)(v6 + 16), *(_QWORD *)(v6 + 24));
      *(_QWORD *)(v6 + 16) = dest;
    }
    dest += *(_QWORD *)(v6 + 24);
  }
  return &dest[-v5];
}

//----- (00000000000058E0) ----------------------------------------------------
signed __int64 __fastcall sub_58E0(__int64 a1, _QWORD *a2)
{
  signed __int64 result; // rax
  size_t v3; // rax
  char *v4; // rax
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // [rsp+10h] [rbp-70h]
  signed __int64 v7; // [rsp+18h] [rbp-68h]
  char *v8; // [rsp+20h] [rbp-60h]
  signed __int64 v9; // [rsp+28h] [rbp-58h]
  size_t j; // [rsp+30h] [rbp-50h]
  size_t k; // [rsp+30h] [rbp-50h]
  unsigned __int64 l; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  signed __int64 v14; // [rsp+38h] [rbp-48h]
  __int64 v15; // [rsp+40h] [rbp-40h]
  _QWORD *i; // [rsp+48h] [rbp-38h]
  __int64 v17; // [rsp+50h] [rbp-30h]
  _QWORD *base; // [rsp+58h] [rbp-28h]
  size_t nmemb; // [rsp+60h] [rbp-20h]

  v13 = 0LL;
  for ( i = a2; *i; ++i )
    ;
  nmemb = i - a2;
  if ( !nmemb )
    return 4294967294LL;
  base = (_QWORD *)g_malloc(40 * nmemb);
  for ( j = 0LL; j < nmemb; ++j )
  {
    v3 = strlen((const char *)a2[j]);
    v13 += v3 + 2;
    base[5 * j] = &base[5 * j];
    base[5 * j + 3] = v3;
    base[5 * j + 4] = 0LL;
    base[5 * j + 1] = 0LL;
  }
  v17 = g_malloc(2 * ((v13 + 254) / 0xFFuLL) + v13);
  v15 = v17;
  for ( k = 0LL; k < nmemb; ++k )
  {
    base[5 * k + 2] = v15;
    sub_54E9((__int64)&base[5 * k], (char *)a2[k]);
    v15 += base[5 * k + 3];
  }
  if ( v15 == v17 )
  {
    g_free(base);
    g_free(v17);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    qsort(base, nmemb, 0x28uLL, (__compar_fn_t)compar);
    sub_542E((__int64)base, nmemb);
    for ( l = 1LL; l < nmemb; ++l )
      base[5 * l - 1] = sub_5378((__int64)&base[5 * l - 5], (__int64)&base[5 * l]);
    sub_5613((__int64)base, (__int64)&base[5 * nmemb - 5], 0LL);
    v4 = sub_5764((__int64)base, nmemb);
    v6 = (unsigned __int64)(v4 + 254) / 0xFF;
    v8 = v4;
    v7 = 255 * (v6 - 1);
    v9 = 2 * v6 + 255 * (v6 - 1);
    v14 = (signed __int64)&v4[2 * v6];
    while ( 1 )
    {
      v5 = v6--;
      if ( !v5 )
        break;
      memmove((void *)(v17 + v9), (const void *)(v17 + v7), (size_t)&v8[-v7]);
      *(_BYTE *)(v9 - 2 + v17) = 119;
      *(_BYTE *)(v9 - 1 + v17) = (_BYTE)v8 - v7;
      v8 = (char *)v7;
      v7 -= 255LL;
      v9 -= 257LL;
    }
    g_free(base);
    *(_QWORD *)(a1 + 432) = v17;
    *(_QWORD *)(a1 + 424) = v14;
    result = 0LL;
  }
  return result;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);

//----- (0000000000005DCA) ----------------------------------------------------
__int64 __fastcall sub_5DCA(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 24) = a1;
  result = a1;
  *(_QWORD *)(result + 16) = *(_QWORD *)(result + 24);
  return result;
}

//----- (0000000000005DF1) ----------------------------------------------------
__int64 __fastcall sub_5DF1(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = a1;
  *(_QWORD *)(a1 + 24) = a2;
  result = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(result + 24) = a1;
  return result;
}

//----- (0000000000005E38) ----------------------------------------------------
__int64 __fastcall sub_5E38(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL) = *(_QWORD *)(a1 + 16);
  result = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a1 + 24);
  return result;
}

//----- (0000000000005E6B) ----------------------------------------------------
_QWORD *__fastcall sub_5E6B(_QWORD *a1)
{
  _QWORD *v1; // ST00_8
  _QWORD *result; // rax

  v1 = a1;
  a1[25] = a1 + 24;
  v1[24] = v1[25];
  v1[27] = v1 + 26;
  result = a1;
  v1[26] = v1[27];
  return result;
}

//----- (0000000000005ECE) ----------------------------------------------------
__int64 __fastcall sub_5ECE(__int64 a1, __int64 a2)
{
  _QWORD *i; // [rsp+20h] [rbp-10h]
  _QWORD *v4; // [rsp+20h] [rbp-10h]
  _QWORD *v5; // [rsp+28h] [rbp-8h]

  v5 = *(_QWORD **)(a2 + 64);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "if_output...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ifm = %p");
  if ( *(_DWORD *)(a2 + 32) & 4 )
  {
    sub_AB7F((_QWORD *)a2);
    *(_DWORD *)(a2 + 32) &= 0xFFFFFFFB;
  }
  if ( a1 )
  {
    for ( i = (_QWORD *)v5[27]; i != v5 + 26; i = (_QWORD *)i[1] )
    {
      if ( a1 == i[5] )
      {
        *(_QWORD *)(a2 + 40) = a1;
        sub_5DF1(a2, i[3]);
        goto LABEL_21;
      }
    }
  }
  if ( !a1 || !(*(_BYTE *)(a1 + 328) & 0x10) )
  {
    v4 = (_QWORD *)v5[27];
    goto LABEL_20;
  }
  v4 = (_QWORD *)v5[25];
  if ( a1 != v4[5] )
  {
LABEL_20:
    *(_QWORD *)(a2 + 40) = a1;
    sub_5DCA(a2);
    sub_AB4C((_QWORD *)a2, v4);
    goto LABEL_21;
  }
  *(_QWORD *)(a2 + 40) = a1;
  sub_5DF1(a2, v4[3]);
LABEL_21:
  if ( a1 )
  {
    ++*(_DWORD *)(a1 + 348);
    if ( ++*(_DWORD *)(a1 + 352) > 5 && *(_DWORD *)(a1 + 352) - *(_DWORD *)(a1 + 348) > 2 )
    {
      sub_AB7F(*(_QWORD **)(a2 + 16));
      sub_AB4C(*(_QWORD **)(a2 + 16), v5 + 26);
    }
  }
  return sub_6168(*(_QWORD *)(a2 + 64));
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000006168) ----------------------------------------------------
__int64 __fastcall sub_6168(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rax
  char v3; // [rsp+1Fh] [rbp-31h]
  _QWORD *v4; // [rsp+20h] [rbp-30h]
  _QWORD *v5; // [rsp+28h] [rbp-28h]
  unsigned __int64 v6; // [rsp+30h] [rbp-20h]
  _QWORD *v7; // [rsp+38h] [rbp-18h]
  _QWORD *v8; // [rsp+40h] [rbp-10h]
  _QWORD *v9; // [rsp+48h] [rbp-8h]

  v6 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 5992) + 16LL))(*(_QWORD *)(a1 + 6000));
  v3 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "if_start...");
  result = *(unsigned __int8 *)(a1 + 224);
  if ( !(_BYTE)result )
  {
    *(_BYTE *)(a1 + 224) = 1;
    v5 = 0LL;
    if ( *(_QWORD *)(a1 + 208) != a1 + 208 )
      v5 = *(_QWORD **)(a1 + 208);
    if ( *(_QWORD *)(a1 + 192) == a1 + 192 )
    {
      if ( v5 )
      {
        v4 = v5;
        v3 = 1;
      }
      else
      {
        v4 = 0LL;
      }
    }
    else
    {
      v4 = *(_QWORD **)(a1 + 192);
    }
    while ( v4 )
    {
      v7 = v4;
      v4 = (_QWORD *)*v4;
      if ( v4 == (_QWORD *)(a1 + 192) )
      {
        v4 = v5;
        v3 = 1;
      }
      if ( v4 == (_QWORD *)(a1 + 208) )
        v4 = 0LL;
      if ( v6 > v7[10] || (unsigned int)sub_E953(a1, (__int64)v7) )
      {
        v8 = (_QWORD *)v7[1];
        sub_AB7F(v7);
        if ( v7 != (_QWORD *)v7[2] )
        {
          v9 = (_QWORD *)v7[2];
          sub_AB4C((_QWORD *)v7[2], v8);
          sub_5E38((__int64)v7);
          if ( v3 != 1 )
            v4 = v9;
        }
        if ( v7[5] )
        {
          v2 = v7[5];
          if ( !--*(_DWORD *)(v2 + 348) )
            *(_DWORD *)(v7[5] + 352LL) = 0;
        }
        sub_A4F0((__int64)v7);
      }
    }
    result = a1;
    *(_BYTE *)(a1 + 224) = 0;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000063A8) ----------------------------------------------------
bool __fastcall sub_63A8(const void *a1, const void *a2)
{
  return memcmp(a1, a2, 0x10uLL) == 0;
}

//----- (00000000000063D7) ----------------------------------------------------
bool __fastcall sub_63D7(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v6; // [rsp+Ch] [rbp-14h]

  v6 = a3;
  v3 = a3;
  v4 = a3 + 7;
  if ( v3 < 0 )
    v3 = v4;
  if ( memcmp(a1, a2, v3 >> 3) )
    return 0;
  if ( v6 & 7 )
    return (signed int)a1[v6 / 8] >> (8 - v6 % 8) == (signed int)a2[v6 / 8] >> (8 - v6 % 8);
  return 1;
}

//----- (00000000000064A4) ----------------------------------------------------
bool __fastcall sub_64A4(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax
  int v4; // edx
  size_t v5; // rdx
  int v6; // eax
  const void *v7; // rcx
  int v8; // eax
  int v10; // [rsp+Ch] [rbp-14h]

  v10 = a3;
  v3 = a3 + 7;
  v4 = a3 + 14;
  if ( v3 < 0 )
    v3 = v4;
  v5 = 16 - (v3 >> 3);
  v6 = v10 + 7;
  if ( v10 + 7 < 0 )
    v6 = v10 + 14;
  v7 = (const void *)(a2 + (v6 >> 3));
  v8 = v10 + 7;
  if ( v10 + 7 < 0 )
    v8 = v10 + 14;
  if ( memcmp((const void *)((v8 >> 3) + a1), v7, v5) )
    return 0;
  if ( v10 & 7 )
    return ((unsigned __int8)(*(_BYTE *)(a1 + v10 / 8) ^ *(_BYTE *)(a2 + v10 / 8)) & ~(-1 << (8 - v10 % 8))) == 0;
  return 1;
}

//----- (000000000000658F) ----------------------------------------------------
__int64 __fastcall sub_658F(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  *(_BYTE *)a3 = 82;
  *(_BYTE *)(a3 + 1) = 86;
  result = HIDWORD(a2);
  *(_DWORD *)(a3 + 2) = HIDWORD(a2);
  return result;
}

//----- (00000000000065CF) ----------------------------------------------------
unsigned __int64 __fastcall sub_65CF(_QWORD *a1)
{
  void (__fastcall *v1)(_QWORD, signed __int64, __int64); // rbx
  __int64 v2; // r12
  __int64 v3; // rax
  signed __int64 v4; // r13
  int v5; // eax

  v1 = *(void (__fastcall **)(_QWORD, signed __int64, __int64))(a1[749] + 40LL);
  v2 = a1[750];
  v3 = (*(__int64 (__fastcall **)(_QWORD))(a1[749] + 16LL))(a1[750]);
  v4 = ((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v3) >> 64) >> 18) - (v3 >> 63);
  v5 = g_rand_int_range(a1[746], 200000LL, 600000LL);
  v1(a1[747], v4 + v5, v2);
  return sub_6C7B((__int64)a1);
}
// 3020: using guessed type __int64 __fastcall g_rand_int_range(_QWORD, _QWORD, _QWORD);

//----- (0000000000006697) ----------------------------------------------------
__int64 __fastcall sub_6697(__int64 a1)
{
  __int64 result; // rax
  __int64 (__fastcall *v2)(_QWORD, signed __int64, __int64); // rbx
  __int64 v3; // r12
  __int64 v4; // rax
  signed __int64 v5; // r13
  int v6; // eax

  result = *(unsigned __int8 *)(a1 + 10) ^ 1u;
  if ( *(_BYTE *)(a1 + 10) == 1 )
  {
    *(_QWORD *)(a1 + 5976) = (*(__int64 (__fastcall **)(unsigned __int64 (__fastcall *)(_QWORD *), __int64, _QWORD))(*(_QWORD *)(a1 + 5992) + 24LL))(
                               sub_65CF,
                               a1,
                               *(_QWORD *)(a1 + 6000));
    v2 = *(__int64 (__fastcall **)(_QWORD, signed __int64, __int64))(*(_QWORD *)(a1 + 5992) + 40LL);
    v3 = *(_QWORD *)(a1 + 6000);
    v4 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 5992) + 16LL))(*(_QWORD *)(a1 + 6000));
    v5 = ((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v4) >> 64) >> 18) - (v4 >> 63);
    v6 = g_rand_int_range(*(_QWORD *)(a1 + 5968), 200000LL, 600000LL);
    result = v2(*(_QWORD *)(a1 + 5976), v5 + v6, v3);
  }
  return result;
}
// 3020: using guessed type __int64 __fastcall g_rand_int_range(_QWORD, _QWORD, _QWORD);

//----- (0000000000006798) ----------------------------------------------------
__int64 __fastcall sub_6798(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned __int8 *)(a1 + 10) ^ 1u;
  if ( *(_BYTE *)(a1 + 10) == 1 )
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 5992) + 32LL))(
               *(_QWORD *)(a1 + 5976),
               *(_QWORD *)(a1 + 6000));
  return result;
}

//----- (00000000000067E5) ----------------------------------------------------
__int64 __fastcall sub_67E5(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // ST08_8
  __int64 v4; // ST28_8
  _QWORD *v5; // ST30_8
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // ST38_8

  v3 = a3;
  v4 = sub_A39A(a2);
  *(_DWORD *)(v4 + 56) = ntohs(*(_WORD *)(v3 + 4)) + 40;
  memcpy(*(void **)(v4 + 48), *(const void **)(a1 + 48), *(signed int *)(v4 + 56));
  v5 = *(_QWORD **)(v4 + 48);
  v6 = *(_QWORD *)(v3 + 16);
  v5[3] = *(_QWORD *)(v3 + 8);
  v5[4] = v6;
  v7 = *(_QWORD *)(v3 + 32);
  v5[1] = *(_QWORD *)(v3 + 24);
  v5[2] = v7;
  *(_QWORD *)(v4 + 48) += 40LL;
  v8 = *(_QWORD *)(v4 + 48);
  *(_BYTE *)v8 = -127;
  *(_WORD *)(v8 + 2) = 0;
  *(_QWORD *)(v4 + 48) -= 40LL;
  *(_WORD *)(v8 + 2) = sub_4820(v4);
  return sub_80BC(0LL, v4, 0);
}

//----- (0000000000006903) ----------------------------------------------------
unsigned __int64 __fastcall sub_6903(__int64 a1, unsigned __int8 a2, char a3)
{
  __int64 v3; // rdx
  unsigned __int64 v4; // rax
  char v6; // [rsp+0h] [rbp-90h]
  int v7; // [rsp+14h] [rbp-7Ch]
  __int64 v8; // [rsp+18h] [rbp-78h]
  __int64 v9; // [rsp+20h] [rbp-70h]
  __int64 v10; // [rsp+28h] [rbp-68h]
  __int64 v11; // [rsp+30h] [rbp-60h]
  __int64 v12; // [rsp+38h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-50h]
  __int64 v14; // [rsp+48h] [rbp-48h]
  char buf; // [rsp+50h] [rbp-40h]
  unsigned __int64 v16; // [rsp+88h] [rbp-8h]

  v6 = a3;
  v16 = __readfsqword(0x28u);
  v8 = *(_QWORD *)(a1 + 64);
  v9 = *(_QWORD *)(a1 + 48);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "icmp6_send_error...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " type = %d, code = %d");
  if ( *(_BYTE *)(v9 + 8) != -1 )
  {
    v13 = 0LL;
    v14 = 0LL;
    if ( !sub_63A8((const void *)(v9 + 8), &v13) )
    {
      v10 = sub_A39A(v8);
      v11 = *(_QWORD *)(v10 + 48);
      *(_QWORD *)(v11 + 8) = 0LL;
      *(_QWORD *)(v11 + 16) = 0LL;
      *(_BYTE *)(v11 + 8) = -2;
      *(_BYTE *)(v11 + 9) = -128;
      *(_BYTE *)(v11 + 23) = 2;
      v3 = *(_QWORD *)(v9 + 16);
      *(_QWORD *)(v11 + 24) = *(_QWORD *)(v9 + 8);
      *(_QWORD *)(v11 + 32) = v3;
      inet_ntop(10, (const void *)(v11 + 24), &buf, 0x2Eu);
      if ( unk_2250E0 & 1 )
        g_log("Slirp", 128LL, " target = %s");
      *(_BYTE *)(v11 + 6) = 58;
      v4 = *(signed int *)(a1 + 56);
      if ( *(signed int *)(v8 + 136) - 48LL <= v4 )
        LODWORD(v4) = *(_DWORD *)(v8 + 136) - 48;
      v7 = v4;
      *(_WORD *)(v11 + 4) = htons(v4 + 8);
      *(_DWORD *)(v10 + 56) = ntohs(*(_WORD *)(v11 + 4)) + 40;
      *(_QWORD *)(v10 + 48) += 40LL;
      v12 = *(_QWORD *)(v10 + 48);
      *(_BYTE *)v12 = a2;
      *(_BYTE *)(v12 + 1) = v6;
      *(_WORD *)(v12 + 2) = 0;
      if ( a2 == 2 )
      {
        *(_DWORD *)(v12 + 4) = htonl(*(_DWORD *)(v8 + 136));
        goto LABEL_21;
      }
      if ( (signed int)a2 > 2 )
      {
        if ( a2 != 3 )
        {
          if ( a2 != 4 )
            goto LABEL_20;
LABEL_21:
          *(_QWORD *)(v10 + 48) += 8LL;
          memcpy(*(void **)(v10 + 48), *(const void **)(a1 + 48), v7);
          *(_QWORD *)(v10 + 48) -= 8LL;
          *(_QWORD *)(v10 + 48) -= 40LL;
          *(_WORD *)(v12 + 2) = sub_4820(v10);
          sub_80BC(0LL, v10, 0);
          return __readfsqword(0x28u) ^ v16;
        }
      }
      else if ( a2 != 1 )
      {
LABEL_20:
        g_assertion_message_expr("Slirp", "../src/ip6_icmp.c", 121LL, "icmp6_send_error", 0LL);
        goto LABEL_21;
      }
      *(_DWORD *)(v12 + 4) = 0;
      goto LABEL_21;
    }
  }
  return __readfsqword(0x28u) ^ v16;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000006C7B) ----------------------------------------------------
unsigned __int64 __fastcall sub_6C7B(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rdx
  uint32_t v5; // eax
  __int64 v6; // rcx
  __int64 v7; // rdx
  uint16_t v8; // ax
  __int16 v9; // ax
  char v11; // [rsp+14h] [rbp-5Ch]
  __int64 v12; // [rsp+18h] [rbp-58h]
  __int64 v13; // [rsp+20h] [rbp-50h]
  __int64 v14; // [rsp+28h] [rbp-48h]
  __int64 v15; // [rsp+30h] [rbp-40h]
  _BYTE *v16; // [rsp+38h] [rbp-38h]
  __int64 v17; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h]
  char v19; // [rsp+50h] [rbp-20h]
  unsigned __int64 v20; // [rsp+68h] [rbp-8h]

  v20 = __readfsqword(0x28u);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ndp_send_ra...");
  v13 = sub_A39A(a1);
  v14 = *(_QWORD *)(v13 + 48);
  v12 = 0LL;
  v1 = v14;
  *(_QWORD *)(v14 + 8) = 0LL;
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_BYTE *)(v14 + 8) = -2;
  *(_BYTE *)(v14 + 9) = -128;
  *(_BYTE *)(v14 + 23) = 2;
  v2 = v14;
  *(_QWORD *)(v14 + 24) = 0LL;
  *(_QWORD *)(v2 + 32) = 0LL;
  *(_BYTE *)(v14 + 24) = -1;
  *(_BYTE *)(v14 + 25) = 2;
  *(_BYTE *)(v14 + 39) = 1;
  *(_BYTE *)(v14 + 6) = 58;
  *(_QWORD *)(v13 + 48) += 40LL;
  v15 = *(_QWORD *)(v13 + 48);
  *(_DWORD *)v15 = 134;
  *(_BYTE *)(v15 + 4) = 64;
  *(_BYTE *)(v15 + 5) &= 0x7Fu;
  *(_BYTE *)(v15 + 5) &= 0xBFu;
  *(_BYTE *)(v15 + 5) &= 0xC0u;
  *(_WORD *)(v15 + 6) = htons(0x708u);
  *(_DWORD *)(v15 + 8) = htonl(0);
  *(_DWORD *)(v15 + 12) = htonl(0);
  *(_QWORD *)(v13 + 48) += 16LL;
  v12 += 16LL;
  v16 = *(_BYTE **)(v13 + 48);
  *v16 = 1;
  v16[1] = 1;
  sub_658F(*(_QWORD *)(v14 + 8), *(_QWORD *)(v14 + 16), (__int64)(v16 + 2));
  *(_QWORD *)(v13 + 48) += 8LL;
  v12 += 8LL;
  v17 = *(_QWORD *)(v13 + 48);
  *(_BYTE *)v17 = 3;
  *(_BYTE *)(v17 + 1) = 4;
  *(_BYTE *)(v17 + 2) = *(_BYTE *)(a1 + 40);
  *(_BYTE *)(v17 + 3) |= 0x80u;
  *(_BYTE *)(v17 + 3) |= 0x40u;
  *(_BYTE *)(v17 + 3) &= 0xC0u;
  *(_DWORD *)(v17 + 4) = htonl(0x15180u);
  *(_DWORD *)(v17 + 8) = htonl(0x3840u);
  *(_DWORD *)(v17 + 12) = 0;
  v3 = v17;
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v17 + 16) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v3 + 24) = v4;
  *(_QWORD *)(v13 + 48) += 32LL;
  v12 += 32LL;
  if ( (signed int)sub_D049(&v19, (unsigned int *)&v11) >= 0 )
  {
    v18 = *(_QWORD *)(v13 + 48);
    *(_BYTE *)v18 = 25;
    *(_BYTE *)(v18 + 1) = 3;
    *(_WORD *)(v18 + 2) = 0;
    v5 = htonl(0x124F80u);
    *(_DWORD *)(v18 + 4) = v5;
    v6 = v18;
    v7 = *(_QWORD *)(a1 + 76);
    *(_QWORD *)(v18 + 8) = *(_QWORD *)(a1 + 68);
    *(_QWORD *)(v6 + 16) = v7;
    *(_QWORD *)(v13 + 48) += 24LL;
    v12 += 24LL;
  }
  v8 = htons(v12);
  *(_WORD *)(v14 + 4) = v8;
  *(_QWORD *)(v13 + 48) += -40 - v12;
  *(_DWORD *)(v13 + 56) = v12 + 40;
  v9 = sub_4820(v13);
  *(_WORD *)(v15 + 2) = v9;
  sub_80BC(0LL, v13, 0);
  return __readfsqword(0x28u) ^ v20;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000007017) ----------------------------------------------------
unsigned __int64 __fastcall sub_7017(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  uint16_t v6; // ax
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int16 v9; // ax
  __int64 cp; // [rsp+0h] [rbp-80h]
  __int64 v12; // [rsp+8h] [rbp-78h]
  __int64 v13; // [rsp+18h] [rbp-68h]
  __int64 v14; // [rsp+20h] [rbp-60h]
  __int64 v15; // [rsp+28h] [rbp-58h]
  __int64 v16; // [rsp+30h] [rbp-50h]
  _BYTE *v17; // [rsp+38h] [rbp-48h]
  char buf; // [rsp+40h] [rbp-40h]
  unsigned __int64 v19; // [rsp+78h] [rbp-8h]

  v13 = a1;
  cp = a2;
  v12 = a3;
  v19 = __readfsqword(0x28u);
  inet_ntop(10, &cp, &buf, 0x2Eu);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ndp_send_ns...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " target = %s");
  v3 = sub_A39A(v13);
  v14 = v3;
  v15 = *(_QWORD *)(v3 + 48);
  v4 = v15;
  v5 = *(_QWORD *)(v13 + 52);
  *(_QWORD *)(v15 + 8) = *(_QWORD *)(v13 + 44);
  *(_QWORD *)(v4 + 16) = v5;
  *(_BYTE *)(v15 + 24) = -1;
  *(_BYTE *)(v15 + 25) = 2;
  *(_BYTE *)(v15 + 26) = 0;
  *(_BYTE *)(v15 + 27) = 0;
  *(_BYTE *)(v15 + 28) = 0;
  *(_BYTE *)(v15 + 29) = 0;
  *(_BYTE *)(v15 + 30) = 0;
  *(_BYTE *)(v15 + 31) = 0;
  *(_BYTE *)(v15 + 32) = 0;
  *(_BYTE *)(v15 + 33) = 0;
  *(_BYTE *)(v15 + 34) = 0;
  *(_BYTE *)(v15 + 35) = 1;
  *(_BYTE *)(v15 + 36) = -1;
  *(_BYTE *)(v15 + 37) = 0;
  *(_BYTE *)(v15 + 38) = 0;
  *(_BYTE *)(v15 + 39) = 0;
  memcpy((void *)(v15 + 37), (char *)&v12 + 5, 3uLL);
  *(_BYTE *)(v15 + 6) = 58;
  *(_WORD *)(v15 + 4) = htons(0x20u);
  v6 = ntohs(*(_WORD *)(v15 + 4));
  *(_DWORD *)(v14 + 56) = v6 + 40;
  *(_QWORD *)(v14 + 48) += 40LL;
  v16 = *(_QWORD *)(v14 + 48);
  *(_QWORD *)v16 = 135LL;
  v7 = v16;
  v8 = v12;
  *(_QWORD *)(v16 + 8) = cp;
  *(_QWORD *)(v7 + 16) = v8;
  *(_QWORD *)(v14 + 48) += 24LL;
  v17 = *(_BYTE **)(v14 + 48);
  *v17 = 1;
  v17[1] = 1;
  sub_658F(*(_QWORD *)(v13 + 44), *(_QWORD *)(v13 + 52), (__int64)(v17 + 2));
  *(_QWORD *)(v14 + 48) -= 24LL;
  *(_QWORD *)(v14 + 48) -= 40LL;
  v9 = sub_4820(v14);
  *(_WORD *)(v16 + 2) = v9;
  sub_80BC(0LL, v14, 1);
  return __readfsqword(0x28u) ^ v19;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000072E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_72E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v5; // ST30_8
  __int64 v6; // rdx
  _BYTE *v7; // ST38_8
  __int64 v9; // [rsp+8h] [rbp-58h]
  __int64 v10; // [rsp+20h] [rbp-40h]
  __int64 v11; // [rsp+28h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  unsigned __int64 v14; // [rsp+58h] [rbp-8h]

  v9 = a3;
  v14 = __readfsqword(0x28u);
  v10 = sub_A39A(a1);
  v11 = *(_QWORD *)(v10 + 48);
  v3 = *(_QWORD *)(v9 + 16);
  *(_QWORD *)(v11 + 8) = *(_QWORD *)(v9 + 8);
  *(_QWORD *)(v11 + 16) = v3;
  v12 = 0LL;
  v13 = 0LL;
  if ( sub_63A8((const void *)(a2 + 8), &v12) )
  {
    *(_QWORD *)(v11 + 24) = 0LL;
    *(_QWORD *)(v11 + 32) = 0LL;
    *(_BYTE *)(v11 + 24) = -1;
    *(_BYTE *)(v11 + 25) = 2;
    *(_BYTE *)(v11 + 39) = 1;
  }
  else
  {
    v4 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(v11 + 24) = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(v11 + 32) = v4;
  }
  *(_BYTE *)(v11 + 6) = 58;
  *(_WORD *)(v11 + 4) = htons(0x20u);
  *(_DWORD *)(v10 + 56) = ntohs(*(_WORD *)(v11 + 4)) + 40;
  *(_QWORD *)(v10 + 48) += 40LL;
  v5 = *(_QWORD *)(v10 + 48);
  *(_DWORD *)v5 = 136;
  *(_BYTE *)(v5 + 4) |= 0x80u;
  *(_BYTE *)(v5 + 4) = ((*(_BYTE *)(v11 + 24) != -1) << 6) | *(_BYTE *)(v5 + 4) & 0xBF;
  *(_BYTE *)(v5 + 4) |= 0x20u;
  *(_BYTE *)(v5 + 4) &= 0xE0u;
  *(_DWORD *)(v5 + 4) = (unsigned __int8)*(_DWORD *)(v5 + 4);
  v6 = *(_QWORD *)(v9 + 16);
  *(_QWORD *)(v5 + 8) = *(_QWORD *)(v9 + 8);
  *(_QWORD *)(v5 + 16) = v6;
  *(_QWORD *)(v10 + 48) += 24LL;
  v7 = *(_BYTE **)(v10 + 48);
  *v7 = 2;
  v7[1] = 1;
  sub_658F(*(_QWORD *)(v5 + 8), *(_QWORD *)(v5 + 16), (__int64)(v7 + 2));
  *(_QWORD *)(v10 + 48) -= 24LL;
  *(_QWORD *)(v10 + 48) -= 40LL;
  *(_WORD *)(v5 + 2) = sub_4820(v10);
  sub_80BC(0LL, v10, 0);
  return __readfsqword(0x28u) ^ v14;
}

//----- (000000000000754E) ----------------------------------------------------
unsigned __int64 __fastcall sub_754E(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4)
{
  __int64 v4; // ST18_8
  _BYTE *v6; // [rsp+0h] [rbp-80h]
  __int64 v7; // [rsp+8h] [rbp-78h]
  __int64 v8; // [rsp+28h] [rbp-58h]
  __int64 v9; // [rsp+30h] [rbp-50h]
  __int64 v10; // [rsp+38h] [rbp-48h]
  char v11; // [rsp+40h] [rbp-40h]
  char v12; // [rsp+41h] [rbp-3Fh]
  char v13; // [rsp+42h] [rbp-3Eh]
  char v14; // [rsp+43h] [rbp-3Dh]
  char v15; // [rsp+44h] [rbp-3Ch]
  char v16; // [rsp+45h] [rbp-3Bh]
  char v17; // [rsp+46h] [rbp-3Ah]
  char v18; // [rsp+47h] [rbp-39h]
  char v19; // [rsp+48h] [rbp-38h]
  char v20; // [rsp+49h] [rbp-37h]
  char v21; // [rsp+4Ah] [rbp-36h]
  char v22; // [rsp+4Bh] [rbp-35h]
  char v23; // [rsp+4Ch] [rbp-34h]
  char v24; // [rsp+4Dh] [rbp-33h]
  char v25; // [rsp+4Eh] [rbp-32h]
  char v26; // [rsp+4Fh] [rbp-31h]
  __int64 v27; // [rsp+50h] [rbp-30h]
  __int64 v28; // [rsp+58h] [rbp-28h]
  __int64 v29; // [rsp+60h] [rbp-20h]
  __int64 v30; // [rsp+68h] [rbp-18h]
  unsigned __int64 v31; // [rsp+78h] [rbp-8h]

  v4 = a1;
  v7 = a3;
  v6 = a4;
  v31 = __readfsqword(0x28u);
  *(_DWORD *)(a1 + 56) += 14;
  *(_QWORD *)(v4 + 48) -= 14LL;
  v8 = *(_QWORD *)(a1 + 48);
  *(_DWORD *)(v4 + 56) -= 14;
  *(_QWORD *)(a1 + 48) += 14LL;
  switch ( *a4 )
  {
    case 0x85u:
      if ( unk_2250E0 & 1 )
        g_log("Slirp", 128LL, " type = Router Solicitation...");
      if ( *(_BYTE *)(v7 + 7) == -1 && !v6[1] && ntohs(*(_WORD *)(v7 + 4)) > 7u )
      {
        sub_BD16(a2, *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 16), (void *)(v8 + 6));
        sub_6C7B(a2);
      }
      break;
    case 0x86u:
      if ( unk_2250E0 & 1 )
        g_log("Slirp", 128LL, " type = Router Advertisement...");
      (*(void (__fastcall **)(const char *, _QWORD))(*(_QWORD *)(a2 + 5992) + 8LL))(
        "Warning: guest sent NDP RA, but shouldn't",
        *(_QWORD *)(a2 + 6000));
      break;
    case 0x87u:
      if ( unk_2250E0 & 1 )
        g_log("Slirp", 128LL, " type = Neighbor Solicitation...");
      if ( *(_BYTE *)(v7 + 7) == -1 && !v6[1] && v6[8] != -1 && ntohs(*(_WORD *)(v7 + 4)) > 0x17u )
      {
        v9 = 0LL;
        v10 = 0LL;
        if ( !sub_63A8((const void *)(v7 + 8), &v9) )
          goto LABEL_44;
        v11 = -1;
        v12 = 2;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = 1;
        v23 = -1;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        if ( sub_63D7((unsigned __int8 *)(v7 + 24), (unsigned __int8 *)&v11, 104) )
        {
LABEL_44:
          if ( sub_63D7(v6 + 8, (unsigned __int8 *)(a2 + 24), *(unsigned __int8 *)(a2 + 40))
            && sub_64A4((__int64)(v6 + 8), a2 + 44, *(unsigned __int8 *)(a2 + 40)) )
          {
            goto LABEL_43;
          }
          v27 = 0LL;
          v28 = 0LL;
          LOWORD(v27) = -32514;
          HIBYTE(v28) = 2;
          if ( sub_63D7(v6 + 8, (unsigned __int8 *)&v27, 64) && sub_64A4((__int64)(v6 + 8), a2 + 44, 64) )
            goto LABEL_43;
          if ( sub_63D7(v6 + 8, (unsigned __int8 *)(a2 + 24), *(unsigned __int8 *)(a2 + 40))
            && sub_64A4((__int64)(v6 + 8), a2 + 68, *(unsigned __int8 *)(a2 + 40))
            || (v29 = 0LL,
                v30 = 0LL,
                LOWORD(v29) = -32514,
                HIBYTE(v30) = 2,
                sub_63D7(v6 + 8, (unsigned __int8 *)&v29, 64))
            && sub_64A4((__int64)(v6 + 8), a2 + 68, 64) )
          {
LABEL_43:
            sub_BD16(a2, *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 16), (void *)(v8 + 6));
            sub_72E0(a2, v7, (__int64)v6);
          }
        }
      }
      break;
    case 0x88u:
      if ( unk_2250E0 & 1 )
        g_log("Slirp", 128LL, " type = Neighbor Advertisement...");
      if ( *(_BYTE *)(v7 + 7) == -1
        && !v6[1]
        && ntohs(*(_WORD *)(v7 + 4)) > 0x17u
        && v6[8] != -1
        && (*(_BYTE *)(v7 + 24) != -1 || !(v6[4] & 0x40)) )
      {
        sub_BD16(a2, *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 16), (void *)(v8 + 6));
      }
      break;
    case 0x89u:
      if ( unk_2250E0 & 1 )
        g_log("Slirp", 128LL, " type = Redirect...");
      (*(void (__fastcall **)(const char *, _QWORD))(*(_QWORD *)(a2 + 5992) + 8LL))(
        "Warning: guest sent NDP REDIRECT, but shouldn't",
        *(_QWORD *)(a2 + 6000));
      break;
    default:
      return __readfsqword(0x28u) ^ v31;
  }
  return __readfsqword(0x28u) ^ v31;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000007AE5) ----------------------------------------------------
unsigned __int64 __fastcall sub_7AE5(__int64 a1)
{
  signed int v1; // eax
  __int64 v3; // [rsp+18h] [rbp-48h]
  __int64 v4; // [rsp+20h] [rbp-40h]
  unsigned __int8 *v5; // [rsp+28h] [rbp-38h]
  __int64 v6; // [rsp+30h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-28h]
  __int64 v8; // [rsp+40h] [rbp-20h]
  __int64 v9; // [rsp+48h] [rbp-18h]
  unsigned __int64 v10; // [rsp+58h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 64);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "icmp6_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m_len = %d");
  if ( ntohs(*(_WORD *)(v3 + 4)) > 3u && !(unsigned int)sub_4820(a1) )
  {
    *(_DWORD *)(a1 + 56) -= 40;
    *(_QWORD *)(a1 + 48) += 40LL;
    v5 = *(unsigned __int8 **)(a1 + 48);
    *(_DWORD *)(a1 + 56) += 40;
    *(_QWORD *)(a1 + 48) -= 40LL;
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " icmp6_type = %d");
    v1 = *v5;
    if ( v1 == 128 )
    {
      if ( sub_63D7((unsigned __int8 *)(v3 + 24), (unsigned __int8 *)(v4 + 24), *(unsigned __int8 *)(v4 + 40))
        && sub_64A4(v3 + 24, v4 + 44, *(unsigned __int8 *)(v4 + 40)) )
      {
        goto LABEL_28;
      }
      v6 = 0LL;
      v7 = 0LL;
      LOWORD(v6) = -32514;
      HIBYTE(v7) = 2;
      if ( sub_63D7((unsigned __int8 *)(v3 + 24), (unsigned __int8 *)&v6, 64) && sub_64A4(v3 + 24, v4 + 44, 64) )
        goto LABEL_28;
      if ( sub_63D7((unsigned __int8 *)(v3 + 24), (unsigned __int8 *)(v4 + 24), *(unsigned __int8 *)(v4 + 40))
        && sub_64A4(v3 + 24, v4 + 68, *(unsigned __int8 *)(v4 + 40))
        || (v8 = 0LL,
            v9 = 0LL,
            LOWORD(v8) = -32514,
            HIBYTE(v9) = 2,
            sub_63D7((unsigned __int8 *)(v3 + 24), (unsigned __int8 *)&v8, 64))
        && sub_64A4(v3 + 24, v4 + 68, 64) )
      {
LABEL_28:
        sub_67E5(a1, v4, v3);
      }
      else
      {
        g_log("Slirp", 8LL, "external icmpv6 not supported yet");
      }
    }
    else if ( v1 >= 128 && (unsigned int)(v1 - 133) <= 4 )
    {
      sub_754E(a1, v4, v3, v5);
    }
  }
  sub_A4F0(a1);
  return __readfsqword(0x28u) ^ v10;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000007E9D) ----------------------------------------------------
__int64 __fastcall sub_7E9D(__int64 a1)
{
  return sub_6697(a1);
}

//----- (0000000000007EB8) ----------------------------------------------------
__int64 __fastcall sub_7EB8(__int64 a1)
{
  return sub_6798(a1);
}

//----- (0000000000007ED3) ----------------------------------------------------
unsigned __int64 __usercall sub_7ED3@<rax>(__int64 a1@<rdi>, __int64 a2@<r12>)
{
  int v2; // eax
  __int64 v4; // [rsp+10h] [rbp-10h]
  __int64 v5; // [rsp+18h] [rbp-8h]

  v4 = *(_QWORD *)(a1 + 64);
  if ( *(_BYTE *)(v4 + 10) != 1 )
    return sub_A4F0(a1);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip6_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m_len = %d");
  if ( *(_DWORD *)(a1 + 56) <= 0x27u )
    return sub_A4F0(a1);
  v5 = *(_QWORD *)(a1 + 48);
  if ( (*(_BYTE *)v5 & 0xF0) != 96 )
    return sub_A4F0(a1);
  if ( (signed int)ntohs(*(_WORD *)(v5 + 4)) > *(_DWORD *)(v4 + 136) )
  {
    sub_6903(a1, 2u, 0);
    return sub_A4F0(a1);
  }
  if ( !*(_BYTE *)(v5 + 7) )
  {
    sub_6903(a1, 3u, 0);
    return sub_A4F0(a1);
  }
  v2 = *(unsigned __int8 *)(v5 + 6);
  if ( v2 == 17 )
    return sub_1B790(a1);
  if ( v2 == 58 )
    return sub_7AE5(a1);
  if ( v2 != 6 )
    return sub_A4F0(a1);
  *(_WORD *)(v5 + 4) = ntohs(*(_WORD *)(v5 + 4));
  return sub_12CFB(0LL, 10, a1, 0x28u, a2);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000080BC) ----------------------------------------------------
__int64 __fastcall sub_80BC(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+Ch] [rbp-24h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v5 = *(_QWORD *)(a2 + 48);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip6_output...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  *(_BYTE *)v5 = *(_BYTE *)v5 & 0xF | 0x60;
  *(_BYTE *)(v5 + 7) = -1;
  *(_BYTE *)v5 &= 0xF0u;
  *(_BYTE *)(v5 + 1) &= 0xFu;
  *(_BYTE *)(v5 + 1) &= 0xF0u;
  *(_WORD *)(v5 + 2) = 0;
  if ( v4 )
    sub_E953(*(_QWORD *)(a2 + 64), a2);
  else
    sub_5ECE(a1, a2);
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000081F2) ----------------------------------------------------
__int64 __fastcall sub_81F2(unsigned __int16 *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( v1 == 2 )
    return 16LL;
  if ( v1 == 10 )
    return 28LL;
  return g_assertion_message_expr("Slirp", "../src/socket.h", 136LL, "sockaddr_size", 0LL);
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008249) ----------------------------------------------------
_QWORD *__fastcall sub_8249(_QWORD *a1)
{
  _QWORD *v1; // ST00_8
  _QWORD *result; // rax

  v1 = a1;
  a1[166] = a1 + 165;
  v1[165] = v1[166];
  result = a1;
  v1[218] = v1 + 165;
  return result;
}

//----- (0000000000008296) ----------------------------------------------------
__int64 __fastcall sub_8296(__int64 a1)
{
  __int64 result; // rax

  while ( 1 )
  {
    result = *(_QWORD *)(a1 + 1320);
    if ( result == a1 + 1320 )
      break;
    sub_84C1(*(_QWORD *)(a1 + 1320));
  }
  return result;
}

//----- (00000000000082D5) ----------------------------------------------------
signed __int64 __fastcall sub_82D5(__int64 a1, __int64 a2, int a3)
{
  int *v4; // rax
  int *v5; // rax
  int v6; // [rsp+Ch] [rbp-54h]
  __int64 v7; // [rsp+28h] [rbp-38h]
  struct sockaddr addr; // [rsp+30h] [rbp-30h]
  unsigned __int64 v9; // [rsp+48h] [rbp-18h]

  v6 = a3;
  v9 = __readfsqword(0x28u);
  v7 = *(_QWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 16) = sub_1C25E(2, 2, 1);
  if ( *(_DWORD *)(a1 + 16) == -1 )
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(v7 + 16);
  *(_DWORD *)(a1 + 204) = *(_DWORD *)(v7 + 12);
  *(_BYTE *)(a1 + 328) = *(_BYTE *)(v7 + 1);
  *(_BYTE *)(a1 + 330) = 1;
  *(_DWORD *)(a1 + 332) = 4;
  *(_DWORD *)(a1 + 344) = unk_2250E8 + 240000;
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = *(_DWORD *)(a1 + 76);
  sub_AB4C((_QWORD *)a1, (_QWORD *)(*(_QWORD *)(a1 + 40) + 1320LL));
  if ( sendto(
         *(_DWORD *)(a1 + 16),
         (const void *)(*(_QWORD *)(a2 + 48) + v6),
         *(_DWORD *)(a2 + 56) - v6,
         0,
         &addr,
         0x10u) == -1 )
  {
    if ( unk_2250E0 & 2 )
    {
      v4 = __errno_location();
      strerror(*v4);
      __errno_location();
      g_log("Slirp", 128LL, "icmp_input icmp sendto tx errno = %d-%s");
    }
    v5 = __errno_location();
    strerror(*v5);
    sub_8B39(a2, 3, 0, 0);
    sub_84C1(a1);
  }
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000084C1) ----------------------------------------------------
__int64 __fastcall sub_84C1(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 5992LL) + 56LL))(
    *(unsigned int *)(a1 + 16),
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 6000LL));
  close(*(_DWORD *)(a1 + 16));
  return sub_F77A(a1);
}

//----- (000000000000851A) ----------------------------------------------------
unsigned __int64 __fastcall sub_851A(__int64 a1, int a2)
{
  __int64 v2; // rbx
  unsigned __int8 *v3; // r12
  int *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rdx
  int *v13; // rax
  socklen_t v14; // eax
  int *v15; // rax
  int *v16; // rax
  int v18; // [rsp+1Ch] [rbp-B4h]
  _DWORD *v19; // [rsp+20h] [rbp-B0h]
  void *v20; // [rsp+28h] [rbp-A8h]
  struct sockaddr addr; // [rsp+30h] [rbp-A0h]
  __int64 v22; // [rsp+40h] [rbp-90h]
  __int64 v23; // [rsp+48h] [rbp-88h]
  __int64 v24; // [rsp+50h] [rbp-80h]
  __int64 v25; // [rsp+58h] [rbp-78h]
  __int64 v26; // [rsp+60h] [rbp-70h]
  __int64 v27; // [rsp+68h] [rbp-68h]
  __int64 v28; // [rsp+70h] [rbp-60h]
  __int64 v29; // [rsp+78h] [rbp-58h]
  __int64 v30; // [rsp+80h] [rbp-50h]
  __int64 v31; // [rsp+88h] [rbp-48h]
  __int64 v32; // [rsp+90h] [rbp-40h]
  __int64 v33; // [rsp+98h] [rbp-38h]
  __int64 v34; // [rsp+A0h] [rbp-30h]
  __int64 v35; // [rsp+A8h] [rbp-28h]
  unsigned __int64 v36; // [rsp+B8h] [rbp-18h]

  v36 = __readfsqword(0x28u);
  v2 = *(_QWORD *)(a1 + 48);
  v18 = *(unsigned __int16 *)(v2 + 2);
  v19 = *(_DWORD **)(a1 + 64);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "icmp_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m_len = %d");
  if ( v18 <= 7
    || (*(_DWORD *)(a1 + 56) -= a2,
        *(_QWORD *)(a1 + 48) += a2,
        v3 = *(unsigned __int8 **)(a1 + 48),
        (unsigned int)sub_44C3(a1, v18)) )
  {
LABEL_8:
    sub_A4F0(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 56) += a2;
    *(_QWORD *)(a1 + 48) -= a2;
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " icmp_type = %d");
    switch ( *v3 )
    {
      case 3u:
      case 4u:
      case 5u:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0x11u:
        sub_A4F0(a1);
        break;
      case 8u:
        *(_WORD *)(v2 + 2) += a2;
        if ( *(_DWORD *)(v2 + 16) != v19[5] && *(_DWORD *)(v2 + 16) != v19[16] )
        {
          if ( v19[31] )
            goto LABEL_8;
          v20 = sub_F694((__int64)v19);
          if ( (unsigned int)sub_82D5((__int64)v20, a1, a2) )
          {
            if ( (unsigned int)sub_1B34D((__int64)v20, 2u) == -1 )
            {
              if ( unk_2250E0 & 2 )
              {
                v4 = __errno_location();
                strerror(*v4);
                __errno_location();
                g_log("Slirp", 128LL, "icmp_input udp_attach errno = %d-%s");
              }
              sub_F77A((__int64)v20);
              sub_A4F0(a1);
            }
            else
            {
              *((_QWORD *)v20 + 6) = a1;
              *((_WORD *)v20 + 36) = 2;
              *((_DWORD *)v20 + 19) = *(_DWORD *)(v2 + 16);
              *((_WORD *)v20 + 37) = htons(7u);
              *((_WORD *)v20 + 100) = 2;
              *((_DWORD *)v20 + 51) = *(_DWORD *)(v2 + 12);
              *((_WORD *)v20 + 101) = htons(9u);
              *((_BYTE *)v20 + 328) = *(_BYTE *)(v2 + 1);
              *((_BYTE *)v20 + 330) = 1;
              *((_DWORD *)v20 + 83) = 4;
              v5 = *((_QWORD *)v20 + 10);
              *(_QWORD *)&addr.sa_family = *((_QWORD *)v20 + 9);
              *(_QWORD *)&addr.sa_data[6] = v5;
              v6 = *((_QWORD *)v20 + 12);
              v22 = *((_QWORD *)v20 + 11);
              v23 = v6;
              v7 = *((_QWORD *)v20 + 14);
              v24 = *((_QWORD *)v20 + 13);
              v25 = v7;
              v8 = *((_QWORD *)v20 + 16);
              v26 = *((_QWORD *)v20 + 15);
              v27 = v8;
              v9 = *((_QWORD *)v20 + 18);
              v28 = *((_QWORD *)v20 + 17);
              v29 = v9;
              v10 = *((_QWORD *)v20 + 20);
              v30 = *((_QWORD *)v20 + 19);
              v31 = v10;
              v11 = *((_QWORD *)v20 + 22);
              v32 = *((_QWORD *)v20 + 21);
              v33 = v11;
              v12 = *((_QWORD *)v20 + 24);
              v34 = *((_QWORD *)v20 + 23);
              v35 = v12;
              if ( (signed int)sub_11CD0((__int64)v20, &addr.sa_family) >= 0 )
              {
                v14 = sub_81F2(&addr.sa_family);
                if ( sendto(
                       *((_DWORD *)v20 + 4),
                       "This is a pseudo-PING packet used by Slirp to emulate ICMP ECHO-REQUEST packets.\n",
                       0x51uLL,
                       0,
                       &addr,
                       v14) == -1 )
                {
                  if ( unk_2250E0 & 2 )
                  {
                    v15 = __errno_location();
                    strerror(*v15);
                    __errno_location();
                    g_log("Slirp", 128LL, "icmp_input udp sendto tx errno = %d-%s");
                  }
                  v16 = __errno_location();
                  strerror(*v16);
                  sub_8B39(a1, 3, 0, 0);
                  sub_1B3C9((__int64)v20);
                }
              }
              else
              {
                v13 = __errno_location();
                strerror(*v13);
                sub_8B39(a1, 3, 0, 0);
                sub_1B3C9((__int64)v20);
              }
            }
          }
        }
        else
        {
          sub_8F3F(a1);
        }
        break;
      default:
        sub_A4F0(a1);
        break;
    }
  }
  return __readfsqword(0x28u) ^ v36;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000008B39) ----------------------------------------------------
unsigned __int64 __fastcall sub_8B39(__int64 a1, char a2, char a3, int a4)
{
  __int64 v4; // r12
  char *v5; // rax
  char *v6; // rax
  int v7; // ebx
  _BYTE *v8; // r13
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // r12
  __int64 v12; // r13
  int v14; // [rsp+Ch] [rbp-84h]
  char v15; // [rsp+10h] [rbp-80h]
  unsigned int n; // [rsp+20h] [rbp-70h]
  unsigned int n_4; // [rsp+24h] [rbp-6Ch]
  int v18; // [rsp+28h] [rbp-68h]
  char dest; // [rsp+30h] [rbp-60h]
  char v20; // [rsp+50h] [rbp-40h]
  unsigned __int64 v21; // [rsp+68h] [rbp-28h]

  v14 = a4;
  v15 = a3;
  v21 = __readfsqword(0x28u);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "icmp_send_error...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " msrc = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " msrc_len = %d");
  if ( (a2 == 3 || a2 == 11) && a1 )
  {
    v4 = *(_QWORD *)(a1 + 48);
    if ( unk_2250E0 & 2 )
    {
      v5 = inet_ntoa(*(struct in_addr *)(v4 + 12));
      strcpy(&dest, v5);
      v6 = inet_ntoa(*(struct in_addr *)(v4 + 16));
      strcpy(&v20, v6);
      if ( unk_2250E0 & 2 )
        g_log("Slirp", 128LL, " %.16s to %.16s");
    }
    if ( !(*(_WORD *)(v4 + 6) & 0x1FFF) )
    {
      v7 = *(_DWORD *)(v4 + 12);
      if ( v7 & htonl(0xFFFFFFFu) )
      {
        n_4 = 4 * (*(_BYTE *)v4 & 0xF);
        n = *(unsigned __int16 *)(v4 + 2);
        if ( *(_BYTE *)(v4 + 9) != 1 || (v8 = (_BYTE *)(v4 + n_4), *v8 <= 0x12u) && !dword_1D7E0[(unsigned __int8)*v8] )
        {
          v9 = sub_A39A(*(_QWORD *)(a1 + 64));
          v10 = v9;
          if ( v9 )
          {
            v18 = *(_DWORD *)(a1 + 56) + 576;
            if ( v18 > *(_DWORD *)(v9 + 36) )
              sub_A70B(v9, v18);
            memcpy(*(void **)(v10 + 48), *(const void **)(a1 + 48), *(signed int *)(a1 + 56));
            *(_DWORD *)(v10 + 56) = *(_DWORD *)(a1 + 56);
            v11 = *(_QWORD *)(v10 + 48);
            *(_QWORD *)(v10 + 48) += 20LL;
            *(_DWORD *)(v10 + 56) -= 20;
            v12 = *(_QWORD *)(v10 + 48);
            if ( v14 )
            {
              n = n_4 + 8;
            }
            else if ( n > 0x224 )
            {
              n = 548;
            }
            *(_DWORD *)(v10 + 56) = n + 8;
            *(_BYTE *)v12 = a2;
            *(_BYTE *)(v12 + 1) = v15;
            *(_WORD *)(v12 + 4) = 0;
            *(_WORD *)(v12 + 6) = 0;
            memcpy((void *)(v12 + 8), *(const void **)(a1 + 48), n);
            *(_WORD *)(v12 + 10) = htons(*(_WORD *)(v12 + 10));
            *(_WORD *)(v12 + 12) = htons(*(_WORD *)(v12 + 12));
            *(_WORD *)(v12 + 14) = htons(*(_WORD *)(v12 + 14));
            *(_WORD *)(v12 + 2) = 0;
            *(_WORD *)(v12 + 2) = sub_44C3(v10, *(_DWORD *)(v10 + 56));
            *(_QWORD *)(v10 + 48) -= 20LL;
            *(_DWORD *)(v10 + 56) += 20;
            *(_BYTE *)v11 = *(_BYTE *)v11 & 0xF0 | 5;
            *(_WORD *)(v11 + 2) = *(_DWORD *)(v10 + 56);
            *(_BYTE *)(v11 + 1) = *(_BYTE *)(v11 + 1) & 0x1E | 0xC0;
            *(_BYTE *)(v11 + 8) = -1;
            *(_BYTE *)(v11 + 9) = 1;
            *(_DWORD *)(v11 + 16) = *(_DWORD *)(v11 + 12);
            *(_DWORD *)(v11 + 12) = *(_DWORD *)(*(_QWORD *)(v10 + 64) + 20LL);
            sub_9E96(0LL, v10);
          }
        }
      }
    }
  }
  return __readfsqword(0x28u) ^ v21;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000008F3F) ----------------------------------------------------
__int64 __fastcall sub_8F3F(__int64 a1)
{
  __int64 v1; // ST08_8
  __int64 v2; // rbx
  __int64 v3; // r12
  int v4; // ST14_4
  int v6; // [rsp+18h] [rbp-18h]
  int v7; // [rsp+1Ch] [rbp-14h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 48);
  v6 = 4 * (*(_BYTE *)v2 & 0xF);
  v7 = v6 - 20;
  *(_QWORD *)(a1 + 48) += v6;
  *(_DWORD *)(v1 + 56) -= v6;
  v3 = *(_QWORD *)(a1 + 48);
  *(_BYTE *)v3 = 0;
  *(_WORD *)(v3 + 2) = 0;
  *(_WORD *)(v3 + 2) = sub_44C3(a1, (unsigned int)*(unsigned __int16 *)(v2 + 2) - v6);
  *(_QWORD *)(v1 + 48) -= v6;
  *(_DWORD *)(v1 + 56) += v6;
  if ( v6 - 20 > 0 )
  {
    memmove((void *)(v2 + 20), (const void *)(v2 + v6), (unsigned int)(*(_DWORD *)(a1 + 56) - v6));
    *(_BYTE *)v2 = *(_BYTE *)v2 & 0xF0 | 5;
    *(_WORD *)(v2 + 2) -= v7;
    *(_DWORD *)(a1 + 56) -= v7;
  }
  *(_BYTE *)(v2 + 8) = -1;
  v4 = *(_DWORD *)(v2 + 16);
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 12) = v4;
  return sub_9E96(0LL, a1);
}

//----- (0000000000009096) ----------------------------------------------------
__int64 __fastcall sub_9096(__int64 a1)
{
  signed __int64 v1; // rdx
  int *v2; // rax
  int *v3; // rax
  bool v5; // [rsp+1Bh] [rbp-35h]
  int v6; // [rsp+1Ch] [rbp-34h]
  __int16 v7; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  __int64 v9; // [rsp+28h] [rbp-28h]
  _WORD *buf; // [rsp+38h] [rbp-18h]

  v9 = *(_QWORD *)(a1 + 48);
  v6 = 4 * (**(_BYTE **)(v9 + 48) & 0xF);
  *(_QWORD *)(v9 + 48) += v6;
  *(_DWORD *)(v9 + 56) -= v6;
  buf = *(_WORD **)(v9 + 48);
  v7 = buf[2];
  if ( *(_DWORD *)(v9 + 32) & 1 )
    v1 = *(_QWORD *)(v9 + 88) + *(signed int *)(v9 + 36);
  else
    v1 = v9 + 96 + *(signed int *)(v9 + 36);
  v8 = recv(*(_DWORD *)(a1 + 16), buf, v1 - *(_QWORD *)(v9 + 48), 0);
  buf[2] = v7;
  *(_QWORD *)(v9 + 48) -= v6;
  *(_DWORD *)(v9 + 56) += v6;
  if ( v8 != -1 && v8 )
  {
    sub_8F3F(*(_QWORD *)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0LL;
  }
  else
  {
    v5 = *__errno_location() != 101;
    if ( unk_2250E0 & 2 )
    {
      v2 = __errno_location();
      strerror(*v2);
      __errno_location();
      g_log("Slirp", 128LL, " udp icmp rx errno = %d-%s");
    }
    v3 = __errno_location();
    strerror(*v3);
    sub_8B39(*(_QWORD *)(a1 + 48), 3, v5, 0);
  }
  return sub_84C1(a1);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000929D) ----------------------------------------------------
_QWORD *__fastcall sub_929D(_QWORD *a1)
{
  a1[32] = a1 + 31;
  a1[31] = a1[32];
  sub_1AA94(a1);
  sub_164FC((__int64)a1);
  return sub_8249(a1);
}

//----- (00000000000092FC) ----------------------------------------------------
__int64 __fastcall sub_92FC(__int64 a1)
{
  sub_1AAE1(a1);
  sub_16557(a1);
  return sub_8296(a1);
}

//----- (000000000000932F) ----------------------------------------------------
unsigned __int64 __usercall sub_932F@<rax>(__int64 a1@<rdi>, signed __int64 a2@<r12>)
{
  __int64 v2; // rbx
  int v3; // eax
  unsigned __int64 result; // rax
  int v5; // eax
  __int64 *v6; // [rsp+8h] [rbp-38h]
  int v7; // [rsp+14h] [rbp-2Ch]
  _QWORD *i; // [rsp+18h] [rbp-28h]
  __int64 v9; // [rsp+20h] [rbp-20h]

  v6 = (__int64 *)a1;
  v9 = *(_QWORD *)(a1 + 64);
  if ( *(_BYTE *)(v9 + 9) != 1 )
    return sub_A4F0(a1);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m_len = %d");
  if ( *(_DWORD *)(a1 + 56) <= 0x13u )
    return sub_A4F0(a1);
  v2 = *(_QWORD *)(a1 + 48);
  if ( (*(_BYTE *)v2 & 0xF0) != 64 )
    return sub_A4F0(a1);
  v7 = 4 * (*(_BYTE *)v2 & 0xF);
  if ( (unsigned int)v7 <= 0x13 )
    return sub_A4F0(a1);
  if ( v7 > *(_DWORD *)(a1 + 56) )
    return sub_A4F0(a1);
  if ( (unsigned int)sub_44C3(a1, v7) )
    return sub_A4F0(a1);
  *(_WORD *)(v2 + 2) = ntohs(*(_WORD *)(v2 + 2));
  if ( v7 > *(unsigned __int16 *)(v2 + 2) )
    return sub_A4F0(a1);
  *(_WORD *)(v2 + 4) = ntohs(*(_WORD *)(v2 + 4));
  *(_WORD *)(v2 + 6) = ntohs(*(_WORD *)(v2 + 6));
  if ( *(_DWORD *)(a1 + 56) < (signed int)*(unsigned __int16 *)(v2 + 2) )
    return sub_A4F0(a1);
  if ( *(_DWORD *)(a1 + 56) > (signed int)*(unsigned __int16 *)(v2 + 2) )
    sub_A875(a1, *(unsigned __int16 *)(v2 + 2) - *(_DWORD *)(a1 + 56));
  if ( !*(_BYTE *)(v2 + 8) )
  {
    sub_8B39(a1, 11, 0, 0);
    return sub_A4F0(a1);
  }
  v3 = *(unsigned __int16 *)(v2 + 6);
  BYTE1(v3) &= 0xBFu;
  if ( v3 )
  {
    for ( i = *(_QWORD **)(v9 + 248); i != (_QWORD *)(v9 + 248); i = (_QWORD *)*i )
    {
      a2 = (signed __int64)(i - 2);
      if ( *(_WORD *)(v2 + 4) == *((_WORD *)i + 9)
        && *(_DWORD *)(v2 + 12) == *(_DWORD *)(a2 + 36)
        && *(_DWORD *)(v2 + 16) == *(_DWORD *)(a2 + 40)
        && *(_BYTE *)(v2 + 9) == *(_BYTE *)(a2 + 33) )
      {
        goto LABEL_28;
      }
    }
    a2 = 0LL;
LABEL_28:
    *(_WORD *)(v2 + 2) -= v7;
    if ( *(_WORD *)(v2 + 6) & 0x2000 )
      *(_BYTE *)(v2 + 1) |= 1u;
    else
      *(_BYTE *)(v2 + 1) &= 0xFEu;
    *(_WORD *)(v2 + 6) *= 8;
    if ( *(_BYTE *)(v2 + 1) & 1 || *(_WORD *)(v2 + 6) )
    {
      result = sub_96E7(v9, v2, (_QWORD *)a2);
      v2 = result;
      if ( !result )
        return result;
      v6 = sub_A9B5(v9, result);
    }
    else if ( a2 )
    {
      sub_9C34(v9, a2);
    }
  }
  else
  {
    *(_WORD *)(v2 + 2) -= v7;
  }
  v5 = *(unsigned __int8 *)(v2 + 9);
  switch ( v5 )
  {
    case 6:
      return sub_12CFB(0LL, 2, (__int64)v6, v7, a2);
    case 17:
      return sub_1AB20((__int64)v6, v7);
    case 1:
      return sub_851A((__int64)v6, v7);
  }
  return sub_A4F0((__int64)v6);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000096E7) ----------------------------------------------------
unsigned __int64 __fastcall sub_96E7(__int64 a1, __int64 a2, _QWORD *a3)	// Function containg the UAF BUG
{
  __int64 *v3; // r12
  unsigned __int64 i; // rbx
  __int64 *v5; // rax
  __int64 *v6; // rax
  __int64 *v7; // rax
  unsigned __int64 j; // rbx
  unsigned __int64 **v10; // rbx
  __int64 *v11; // r12
  unsigned __int64 *v12; // rbx
  __int64 *v13; // ST48_8
  unsigned __int64 v14; // rbx
  signed __int64 v15; // ST10_8
  __int64 *v16; // rax
  unsigned __int64 *v17; // [rsp+8h] [rbp-58h]
  int v18; // [rsp+24h] [rbp-3Ch]
  int v19; // [rsp+28h] [rbp-38h]
  int v20; // [rsp+2Ch] [rbp-34h]
  int v21; // [rsp+2Ch] [rbp-34h]
  int v22; // [rsp+30h] [rbp-30h]
  __int64 v23; // [rsp+40h] [rbp-20h]

  v17 = a3;
  v3 = sub_A9B5(a1, a2);					// sub_A9B5 -> dtom()
  v19 = 4 * (*(_BYTE *)a2 & 0xF);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip_reass...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ip = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " fp = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  v3[6] += v19;
  *((_DWORD *)v3 + 14) -= v19;
  if ( v17 )
  {
    for ( i = *v17; (unsigned __int64 *)i != v17 && *(_WORD *)(i + 22) <= *(_WORD *)(a2 + 6); i = *(_QWORD *)i )
      ;
    if ( *(unsigned __int64 **)(i + 8) == v17
      || (v20 = *(unsigned __int16 *)(*(_QWORD *)(i + 8) + 18LL)
              + *(unsigned __int16 *)(*(_QWORD *)(i + 8) + 22LL)
              - *(unsigned __int16 *)(a2 + 6),
          v20 <= 0) )
    {
LABEL_23:
      while ( (unsigned __int64 *)i != v17
           && *(unsigned __int16 *)(a2 + 2) + *(unsigned __int16 *)(a2 + 6) > *(unsigned __int16 *)(i + 22) )
      {
        v21 = *(unsigned __int16 *)(a2 + 2) + *(unsigned __int16 *)(a2 + 6) - *(unsigned __int16 *)(i + 22);
        if ( v21 < *(unsigned __int16 *)(i + 18) )
        {
          *(_WORD *)(i + 18) -= v21;
          *(_WORD *)(i + 22) += v21;
          v6 = sub_A9B5(a1, i);
          sub_A875((__int64)v6, v21);
          goto LABEL_25;
        }
        i = *(_QWORD *)i;
        v7 = sub_A9B5(a1, *(_QWORD *)(i + 8));		// Acutal bug !
        sub_A4F0((__int64)v7);
        sub_9D39(*(_QWORD ***)(i + 8));
      }
      goto LABEL_25;
    }
    if ( v20 < *(unsigned __int16 *)(a2 + 2) )
    {
      v5 = sub_A9B5(a1, a2);
      sub_A875((__int64)v5, v20);	// Should be the m_free call
      *(_WORD *)(a2 + 6) += v20;
      *(_WORD *)(a2 + 2) -= v20;
      goto LABEL_23;
    }
LABEL_39:
    sub_A4F0((__int64)v3);
    return 0LL;
  }
  v23 = sub_A39A(a1);
  if ( !v23 )
    goto LABEL_39;
  v17 = *(unsigned __int64 **)(v23 + 48);
  sub_AB4C(v17 + 2, (_QWORD *)(a1 + 248));
  *((_BYTE *)v17 + 32) = 60;
  *((_BYTE *)v17 + 33) = *(_BYTE *)(a2 + 9);
  *((_WORD *)v17 + 17) = *(_WORD *)(a2 + 4);
  v17[1] = (unsigned __int64)v17;
  *v17 = v17[1];
  *((_DWORD *)v17 + 9) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)v17 + 10) = *(_DWORD *)(a2 + 16);
  i = (unsigned __int64)v17;
LABEL_25:
  sub_9CB3((_QWORD *)(a2 - 16), *(__int64 **)(i + 8));
  v18 = 0;
  for ( j = *v17; (unsigned __int64 *)j != v17; j = *(_QWORD *)j )
  {
    if ( v18 != *(unsigned __int16 *)(j + 22) )
      return 0LL;
    v18 += *(unsigned __int16 *)(j + 18);
  }
  if ( *(_BYTE *)(*(_QWORD *)(j + 8) + 17LL) & 1 )
    return 0LL;
  v10 = (unsigned __int64 **)*v17;
  v11 = sub_A9B5(a1, *v17);
  v22 = v11[4] & 1;
  v12 = *v10;
  while ( v12 != v17 )
  {
    v13 = sub_A9B5(a1, (unsigned __int64)v12);
    v12 = (unsigned __int64 *)*v12;
    sub_A60D((signed __int64)v11, (__int64)v13);
  }
  v14 = *v17;
  if ( !v22 )
  {
    if ( v11[4] & 1 )
      v14 = v11[11] + (signed int)v14 - ((signed int)v11 + 96);
  }
  v15 = v14 + 16;
  *(_WORD *)(v14 + 18) = v18;
  *(_BYTE *)(v15 + 1) &= 0xFEu;
  *(_DWORD *)(v15 + 12) = *((_DWORD *)v17 + 9);
  *(_DWORD *)(v15 + 16) = *((_DWORD *)v17 + 10);
  sub_AB7F(v17 + 2);
  v16 = sub_A9B5(a1, (unsigned __int64)v17);
  sub_A4F0((__int64)v16);
  *((_DWORD *)v11 + 14) += 4 * (*(_BYTE *)(v14 + 16) & 0xF);
  v11[6] -= 4 * (*(_BYTE *)(v14 + 16) & 0xF);
  return v14 + 16;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000009C34) ----------------------------------------------------
__int64 __fastcall sub_9C34(__int64 a1, unsigned __int64 a2)
{
  _QWORD **i; // rbx
  _QWORD *v3; // r12
  __int64 *v4; // rax
  __int64 *v5; // rax

  for ( i = *(_QWORD ***)a2; i != (_QWORD **)a2; i = (_QWORD **)v3 )
  {
    v3 = *i;
    sub_9D39(i);
    v4 = sub_A9B5(a1, (unsigned __int64)i);
    sub_A4F0((__int64)v4);
  }
  sub_AB7F((_QWORD *)(a2 + 16));
  v5 = sub_A9B5(a1, a2);
  return sub_A4F0((__int64)v5);
}

//----- (0000000000009CB3) ----------------------------------------------------
__int64 __fastcall sub_9CB3(_QWORD *a1, __int64 *a2)
{
  __int64 result; // rax

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip_enq...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " prev = %p");
  a1[1] = a2;
  *a1 = *a2;
  result = *a2;
  *(_QWORD *)(*a2 + 8) = a1;
  *a2 = (__int64)a1;
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000009D39) ----------------------------------------------------
_QWORD *__fastcall sub_9D39(_QWORD **a1)
{
  _QWORD *result; // rax

  *a1[1] = *a1;
  result = a1[1];
  (*a1)[1] = result;
  return result;
}

//----- (0000000000009D58) ----------------------------------------------------
signed __int64 __fastcall sub_9D58(__int64 a1)
{
  signed __int64 result; // rax
  _QWORD *v2; // [rsp+18h] [rbp-18h]
  unsigned __int64 v3; // [rsp+28h] [rbp-8h]

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip_slowtimo...");
  result = *(_QWORD *)(a1 + 248);
  v2 = *(_QWORD **)(a1 + 248);
  if ( v2 )
  {
    while ( 1 )
    {
      result = a1 + 248;
      if ( v2 == (_QWORD *)(a1 + 248) )
        break;
      v3 = (unsigned __int64)(v2 - 2);
      v2 = (_QWORD *)*v2;
      if ( !--*(_BYTE *)(v3 + 32) )
        sub_9C34(a1, v3);
    }
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000009E0E) ----------------------------------------------------
_BYTE *__fastcall sub_9E0E(__int64 a1)
{
  _BYTE *v1; // ST18_8
  int v2; // ST14_4
  _BYTE *result; // rax

  v1 = *(_BYTE **)(a1 + 48);
  v2 = 4 * (*v1 & 0xF) - 20;
  memcpy(v1 + 20, &v1[v2 + 20], *(_DWORD *)(a1 + 56) - 4 * (*v1 & 0xFu));
  *(_DWORD *)(a1 + 56) -= v2;
  result = v1;
  *v1 = *v1 & 0xF0 | 5;
  return result;
}

//----- (0000000000009E96) ----------------------------------------------------
__int64 __fastcall sub_9E96(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  uint16_t v3; // ax
  __int64 v4; // rax
  __int64 v5; // r12
  __int64 v6; // r13
  __int64 v7; // rdx
  __int16 v8; // ax
  __int16 v9; // ax
  __int16 v10; // ax
  uint16_t v11; // ax
  __int64 j; // r12
  __int64 v14; // [rsp+0h] [rbp-60h]
  unsigned int v15; // [rsp+1Ch] [rbp-44h]
  int i; // [rsp+20h] [rbp-40h]
  unsigned int v17; // [rsp+24h] [rbp-3Ch]
  unsigned int v18; // [rsp+28h] [rbp-38h]
  __int64 *v19; // [rsp+30h] [rbp-30h]
  __int64 v20; // [rsp+38h] [rbp-28h]

  v20 = *(_QWORD *)(a2 + 64);
  v17 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ip_output...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m0 = %p");
  v2 = *(_QWORD *)(a2 + 48);
  *(_BYTE *)v2 = *(_BYTE *)v2 & 0xF | 0x40;
  *(_WORD *)(v2 + 6) &= 0x4000u;
  v3 = *(_WORD *)(v20 + 280);
  *(_WORD *)(v20 + 280) = v3 + 1;
  *(_WORD *)(v2 + 4) = htons(v3);
  *(_BYTE *)v2 = *(_BYTE *)v2 & 0xF0 | 5;
  if ( (signed int)*(unsigned __int16 *)(v2 + 2) <= *(_DWORD *)(v20 + 136) )
  {
    *(_WORD *)(v2 + 2) = htons(*(_WORD *)(v2 + 2));
    *(_WORD *)(v2 + 6) = htons(*(_WORD *)(v2 + 6));
    *(_WORD *)(v2 + 10) = 0;
    *(_WORD *)(v2 + 10) = sub_44C3(a2, 20);
    sub_5ECE(a1, a2);
    return v17;
  }
  if ( *(_WORD *)(v2 + 6) & 0x4000 )
  {
    v17 = -1;
LABEL_33:
    sub_A4F0(a2);
    return v17;
  }
  v15 = (*(_DWORD *)(v20 + 136) - 20) & 0xFFFFFFF8;
  if ( (signed int)v15 <= 7 )
  {
    v17 = -1;
    goto LABEL_33;
  }
  v18 = (*(_DWORD *)(v20 + 136) - 20) & 0xFFFFFFF8;
  v19 = (__int64 *)(a2 + 16);
  for ( i = v15 + 20; i < *(unsigned __int16 *)(v2 + 2); i += v15 )
  {
    v4 = sub_A39A(v20);
    v5 = v4;
    if ( !v4 )
    {
      v17 = -1;
      goto LABEL_26;
    }
    *(_QWORD *)(v4 + 48) += 16LL;
    v6 = *(_QWORD *)(v4 + 48);
    v7 = *(_QWORD *)(v2 + 8);
    *(_QWORD *)v6 = *(_QWORD *)v2;
    *(_QWORD *)(v6 + 8) = v7;
    *(_DWORD *)(v6 + 16) = *(_DWORD *)(v2 + 16);
    *(_DWORD *)(v4 + 56) = 20;
    v8 = *(_WORD *)(v2 + 6);
    HIBYTE(v8) &= 0xDFu;
    *(_WORD *)(v6 + 6) = ((i - 20) >> 3) + v8;
    if ( *(_WORD *)(v2 + 6) & 0x2000 )
    {
      v9 = *(_WORD *)(v6 + 6);
      HIBYTE(v9) |= 0x20u;
      *(_WORD *)(v6 + 6) = v9;
    }
    if ( (signed int)(v15 + i) < *(unsigned __int16 *)(v2 + 2) )
    {
      v10 = *(_WORD *)(v6 + 6);
      HIBYTE(v10) |= 0x20u;
      *(_WORD *)(v6 + 6) = v10;
    }
    else
    {
      v15 = *(unsigned __int16 *)(v2 + 2) - i;
    }
    *(_WORD *)(v6 + 2) = htons(v15 + 20);
    if ( (signed int)sub_A8D5(v5, a2, i, v15) < 0 )
    {
      v17 = -1;
      goto LABEL_26;
    }
    *(_WORD *)(v6 + 6) = htons(*(_WORD *)(v6 + 6));
    *(_WORD *)(v6 + 10) = 0;
    *(_WORD *)(v6 + 10) = sub_44C3(v5, 20);
    *v19 = v5;
    v19 = (__int64 *)(v5 + 16);
  }
  sub_A875(a2, v18 + 20 - *(unsigned __int16 *)(v2 + 2));
  *(_WORD *)(v2 + 2) = htons(*(_DWORD *)(a2 + 56));
  v11 = *(_WORD *)(v2 + 6);
  HIBYTE(v11) |= 0x20u;
  *(_WORD *)(v2 + 6) = htons(v11);
  *(_WORD *)(v2 + 10) = 0;
  *(_WORD *)(v2 + 10) = sub_44C3(a2, 20);
LABEL_26:
  for ( j = a2; j; j = v14 )
  {
    v14 = *(_QWORD *)(j + 16);
    *(_QWORD *)(j + 16) = 0LL;
    if ( v17 )
      sub_A4F0(j);
    else
      sub_5ECE(a1, j);
  }
  return v17;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000A28A) ----------------------------------------------------
_QWORD *__fastcall sub_A28A(_QWORD *a1)
{
  _QWORD *v1; // ST00_8
  _QWORD *result; // rax

  v1 = a1;
  a1[20] = a1 + 19;
  v1[19] = v1[20];
  v1[22] = v1 + 21;
  result = a1;
  v1[21] = v1[22];
  return result;
}

//----- (000000000000A2ED) ----------------------------------------------------
signed __int64 __fastcall sub_A2ED(__int64 a1)
{
  _QWORD *v1; // ST18_8
  signed __int64 result; // rax
  __int64 *i; // [rsp+10h] [rbp-10h]
  _QWORD *j; // [rsp+10h] [rbp-10h]
  __int64 *v5; // [rsp+18h] [rbp-8h]

  for ( i = *(__int64 **)(a1 + 168); i != (__int64 *)(a1 + 168); i = v5 )
  {
    v5 = (__int64 *)*i;
    if ( i[4] & 1 )
      g_free(i[11]);
    g_free(i);
  }
  for ( j = *(_QWORD **)(a1 + 152); ; j = v1 )
  {
    result = a1 + 152;
    if ( j == (_QWORD *)(a1 + 152) )
      break;
    v1 = (_QWORD *)*j;
    g_free(j);
  }
  return result;
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);

//----- (000000000000A39A) ----------------------------------------------------
__int64 __fastcall sub_A39A(__int64 a1)
{
  __int64 v1; // rbx
  signed int v3; // [rsp+1Ch] [rbp-14h]

  v3 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "m_get...");
  if ( *(_QWORD *)(a1 + 152) == a1 + 152 )
  {
    v1 = g_malloc(*(signed int *)(a1 + 136) + 140LL);
    if ( ++*(_DWORD *)(a1 + 184) > 30 )
      v3 = 8;
    *(_QWORD *)(v1 + 64) = a1;
  }
  else
  {
    v1 = *(_QWORD *)(a1 + 152);
    sub_AB7F(*(_QWORD **)(a1 + 152));
  }
  sub_AB4C((_QWORD *)v1, (_QWORD *)(a1 + 168));
  *(_DWORD *)(v1 + 32) = v3 | 4;
  *(_DWORD *)(v1 + 36) = *(_DWORD *)(a1 + 136) + 44;
  *(_QWORD *)(v1 + 48) = v1 + 96;
  *(_DWORD *)(v1 + 56) = 0;
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_QWORD *)(v1 + 24) = 0LL;
  *(_BYTE *)(v1 + 72) = 0;
  *(_QWORD *)(v1 + 80) = -1LL;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  return v1;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000A4F0) ----------------------------------------------------
__int64 __fastcall sub_A4F0(__int64 a1)		//m_free
{
  __int64 result; // rax

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "m_free...");
  result = unk_2250E0 & 1;
  if ( unk_2250E0 & 1 )
    result = g_log("Slirp", 128LL, " m = %p");
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 32) & 4 )
      sub_AB7F((_QWORD *)a1);
    if ( *(_DWORD *)(a1 + 32) & 1 )
      g_free(*(_QWORD *)(a1 + 88));
    if ( *(_DWORD *)(a1 + 32) & 8 )
    {
      g_free(a1);
      --*(_DWORD *)(*(_QWORD *)(a1 + 64) + 184LL);
    }
    else
    {
      result = *(_DWORD *)(a1 + 32) & 2;
      if ( !(_DWORD)result )
      {
        sub_AB4C((_QWORD *)a1, (_QWORD *)(*(_QWORD *)(a1 + 64) + 152LL));
        result = a1;
        *(_DWORD *)(a1 + 32) = 2;
      }
    }
  }
  return result;
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000A60D) ----------------------------------------------------
__int64 __fastcall sub_A60D(signed __int64 a1, __int64 a2)
{
  signed __int64 v2; // rdx

  if ( *(_DWORD *)(a1 + 32) & 1 )
    v2 = *(_QWORD *)(a1 + 88) + *(signed int *)(a1 + 36);
  else
    v2 = a1 + 96 + *(signed int *)(a1 + 36);
  if ( v2 - *(_QWORD *)(a1 + 48) - *(signed int *)(a1 + 56) < *(signed int *)(a2 + 56) )
    sub_A70B(a1, *(_DWORD *)(a2 + 56) + *(_DWORD *)(a1 + 56));
  memcpy((void *)(*(_QWORD *)(a1 + 48) + *(signed int *)(a1 + 56)), *(const void **)(a2 + 48), *(signed int *)(a2 + 56));
  *(_DWORD *)(a1 + 56) += *(_DWORD *)(a2 + 56);
  return sub_A4F0(a2);
}

//----- (000000000000A70B) ----------------------------------------------------
signed __int64 __fastcall sub_A70B(signed __int64 a1, int a2)
{
  signed __int64 v2; // rdx
  signed __int64 result; // rax
  int v4; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 32) & 1 )
    v2 = *(_QWORD *)(a1 + 88) + *(signed int *)(a1 + 36);
  else
    v2 = a1 + 96 + *(signed int *)(a1 + 36);
  result = v2 - *(_QWORD *)(a1 + 48);
  if ( result <= a2 )
  {
    if ( *(_DWORD *)(a1 + 32) & 1 )
    {
      v4 = *(unsigned __int64 *)(a1 + 48) - *(unsigned __int64 *)(a1 + 88);
      *(_QWORD *)(a1 + 88) = g_realloc(*(_QWORD *)(a1 + 88), a2 + v4);
    }
    else
    {
      v4 = *(unsigned __int64 *)(a1 + 48) - (a1 + 96);
      *(_QWORD *)(a1 + 88) = g_malloc(a2 + v4);
      memcpy(*(void **)(a1 + 88), (const void *)(a1 + 96), *(signed int *)(a1 + 36));
      *(_DWORD *)(a1 + 32) |= 1u;
    }
    *(_QWORD *)(a1 + 48) = v4 + *(_QWORD *)(a1 + 88);
    result = a1;
    *(_DWORD *)(a1 + 36) = v4 + a2;
  }
  return result;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);
// 30F0: using guessed type __int64 __fastcall g_realloc(_QWORD, _QWORD);

//----- (000000000000A875) ----------------------------------------------------
__int64 __fastcall sub_A875(__int64 a1, int a2)
{
  __int64 result; // rax
  int v3; // [rsp+0h] [rbp-Ch]

  v3 = a2;
  if ( a1 )
  {
    if ( a2 < 0 )
      v3 = -a2;
    else
      *(_QWORD *)(a1 + 48) += a2;
    result = a1;
    *(_DWORD *)(a1 + 56) -= v3;
  }
  return result;
}

//----- (000000000000A8D5) ----------------------------------------------------
signed __int64 __fastcall sub_A8D5(__int64 a1, __int64 a2, int a3, signed __int64 a4)
{
  signed __int64 v4; // rdx
  int v6; // [rsp+8h] [rbp-18h]
  int v7; // [rsp+Ch] [rbp-14h]

  v7 = a3;
  v6 = a4;
  a4 = (signed int)a4;
  if ( *(_DWORD *)(a1 + 32) & 1 )
    v4 = *(_QWORD *)(a1 + 88) + *(signed int *)(a1 + 36);
  else
    v4 = a1 + 96 + *(signed int *)(a1 + 36);
  if ( a4 > v4 - *(_QWORD *)(a1 + 48) - *(signed int *)(a1 + 56) )
    return 0xFFFFFFFFLL;
  memcpy(
    (void *)(*(signed int *)(a1 + 56) + *(_QWORD *)(a1 + 48)),
    (const void *)(*(_QWORD *)(a2 + 48) + v7),
    (signed int)a4);
  *(_DWORD *)(a1 + 56) += v6;
  return 0LL;
}

//----- (000000000000A9B5) ----------------------------------------------------
__int64 *__fastcall sub_A9B5(__int64 a1, unsigned __int64 a2)
{
  __int64 *i; // [rsp+18h] [rbp-8h]

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "dtom...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " dat = %p");
  for ( i = *(__int64 **)(a1 + 168); i != (__int64 *)(a1 + 168); i = (__int64 *)*i )
  {
    if ( i[4] & 1 )
    {
      if ( a2 >= i[11] && a2 < i[11] + *((signed int *)i + 9) )
        return i;
    }
    else if ( a2 >= (unsigned __int64)(i + 12) && a2 < (unsigned __int64)i + *((signed int *)i + 9) + 96 )
    {
      return i;
    }
  }
  if ( unk_2250E0 & 4 )
    g_log("Slirp", 128LL, "dtom failed");
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000AAF4) ----------------------------------------------------
int __fastcall sub_AAF4(int a1)
{
  int optval; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  optval = 1;
  return setsockopt(a1, 1, 2, &optval, 4u);
}

//----- (000000000000AB4C) ----------------------------------------------------
__int64 __fastcall sub_AB4C(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  *a1 = *a2;
  *a2 = a1;
  a1[1] = a2;
  result = *a1;
  *(_QWORD *)(*a1 + 8LL) = a1;
  return result;
}

//----- (000000000000AB7F) ----------------------------------------------------
_QWORD *__fastcall sub_AB7F(_QWORD *a1)
{
  _QWORD *result; // rax

  *(_QWORD *)(*a1 + 8LL) = a1[1];
  result = (_QWORD *)a1[1];
  *result = *a1;
  a1[1] = 0LL;
  return result;
}

//----- (000000000000ABAD) ----------------------------------------------------
__int64 __fastcall sub_ABAD(__int64 *a1, __int64 a2, __int64 a3, int a4, int a5)
{
  __int64 v5; // ST08_8
  int v6; // ST04_4
  int v7; // ST00_4
  __int64 result; // rax

  v5 = a3;
  v6 = a4;
  v7 = a5;
  result = g_malloc0_n(1LL, 40LL);
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = v5;
  *(_DWORD *)(result + 20) = v7;
  *(_DWORD *)(result + 16) = v6;
  *(_QWORD *)(result + 32) = *a1;
  *a1 = result;
  return result;
}
// 30E0: using guessed type __int64 __fastcall g_malloc0_n(_QWORD, _QWORD);

//----- (000000000000AC26) ----------------------------------------------------
__int64 __fastcall sub_AC26(__int64 *a1, __int64 a2, int a3, int a4)
{
  __int64 v4; // ST28_8

  v4 = sub_ABAD(a1, 0LL, 0LL, a3, a4);
  *(_QWORD *)(v4 + 24) = g_strdup(a2);
  return v4;
}
// 3140: using guessed type __int64 __fastcall g_strdup(_QWORD);

//----- (000000000000AC7E) ----------------------------------------------------
signed __int64 __fastcall sub_AC7E(int *a1)
{
  signed __int64 result; // rax
  int *v2; // rax
  socklen_t len; // [rsp+14h] [rbp-3Ch]
  int fd; // [rsp+18h] [rbp-38h]
  int v5; // [rsp+1Ch] [rbp-34h]
  struct sockaddr addr; // [rsp+20h] [rbp-30h]
  unsigned __int64 v7; // [rsp+38h] [rbp-18h]

  v7 = __readfsqword(0x28u);
  *(_QWORD *)&addr.sa_family = 0LL;
  *(_QWORD *)&addr.sa_data[6] = 0LL;
  addr.sa_family = 2;
  len = 16;
  a1[1] = -1;
  fd = sub_1C25E(2, 1, 0);
  if ( fd < 0 )
    goto LABEL_20;
  if ( bind(fd, &addr, len) < 0 )
    goto LABEL_20;
  if ( listen(fd, 1) < 0 )
    goto LABEL_20;
  if ( getsockname(fd, &addr, &len) < 0 )
    goto LABEL_20;
  a1[1] = sub_1C25E(2, 1, 0);
  if ( a1[1] < 0 )
    goto LABEL_20;
  do
    v5 = connect(a1[1], &addr, len);
  while ( v5 < 0 && *__errno_location() == 4 );
  if ( v5 < 0 )
    goto LABEL_20;
  do
    *a1 = accept(fd, &addr, &len);
  while ( *a1 < 0 && *__errno_location() == 4 );
  if ( *a1 < 0 )
  {
LABEL_20:
    v2 = __errno_location();
    strerror(*v2);
    g_log("Slirp", 8LL, "slirp_socketpair(): %s");
    if ( fd >= 0 )
      close(fd);
    if ( a1[1] >= 0 )
      close(a1[1]);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    close(fd);
    result = 0LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000AE71) ----------------------------------------------------
__pid_t sub_AE71()
{
  return setsid();
}

//----- (000000000000AE85) ----------------------------------------------------
__int64 __fastcall sub_AE85(__int64 a1)
{
  dup2(*(_DWORD *)(a1 + 16), 0);
  dup2(*(_DWORD *)(a1 + 20), 1);
  dup2(*(_DWORD *)(a1 + 24), 2);
  return (*(__int64 (__fastcall **)(_QWORD, signed __int64))a1)(*(_QWORD *)(a1 + 8), 2LL);
}

//----- (000000000000AEE9) ----------------------------------------------------
__int64 __fastcall sub_AEE9(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, __int64 a11)
{
  __int64 v12; // [rsp+40h] [rbp-30h]
  __int64 v13; // [rsp+48h] [rbp-28h]
  int v14; // [rsp+50h] [rbp-20h]
  int v15; // [rsp+54h] [rbp-1Ch]
  int v16; // [rsp+58h] [rbp-18h]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v17 = __readfsqword(0x28u);
  v12 = a5;
  v13 = a6;
  v14 = a8;
  v15 = a9;
  v16 = a10;
  return g_spawn_async(a1, a2, a3, a4, sub_AE85, &v12, a7, a11);
}
// 2F90: using guessed type __int64 __fastcall g_spawn_async(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000AF8E) ----------------------------------------------------
signed __int64 __fastcall sub_AF8E(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __int64 v3; // rsi
  int optval; // [rsp+1Ch] [rbp-24h]
  __int64 v5; // [rsp+20h] [rbp-20h]
  __int64 v6; // [rsp+28h] [rbp-18h]
  int fd; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v5 = 0LL;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "fork_exec...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ex = %p");
  if ( (signed int)sub_AC7E(&fd) < 0 )
    return 0LL;
  v6 = g_strsplit(a2, " ", 0xFFFFFFFFLL);
  v3 = v6;
  sub_AEE9(0LL, v6, 0LL, 4u, (__int64)sub_AE71, 0LL, 0LL, (unsigned int)v8, v8, v8, (__int64)&v5);
  g_strfreev(v6, v3);
  if ( v5 )
  {
    g_log("Slirp", 8LL, "fork_exec: %s");
    g_error_free(v5, 8LL);
    close(fd);
    close(v8);
    result = 0LL;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = fd;
    close(v8);
    sub_AAF4(*(_DWORD *)(a1 + 16));
    optval = 1;
    setsockopt(*(_DWORD *)(a1 + 16), 1, 10, &optval, 4u);
    sub_1C142(*(_DWORD *)(a1 + 16));
    (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 5992LL) + 48LL))(
      *(unsigned int *)(a1 + 16),
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 6000LL));
    result = 1LL;
  }
  return result;
}
// 2D90: using guessed type __int64 __fastcall g_strsplit(_QWORD, _QWORD, _QWORD);
// 3060: using guessed type __int64 __fastcall g_strfreev(_QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);
// 31B0: using guessed type __int64 __fastcall g_error_free(_QWORD, _QWORD);

//----- (000000000000B1D1) ----------------------------------------------------
__int64 __fastcall slirp_connection_info(_QWORD *a1)
{
  uint16_t v2; // [rsp+1Eh] [rbp-D2h]
  uint16_t v3; // [rsp+1Eh] [rbp-D2h]
  struct in_addr in; // [rsp+20h] [rbp-D0h]
  struct in_addr ina; // [rsp+20h] [rbp-D0h]
  struct in_addr inb; // [rsp+20h] [rbp-D0h]
  socklen_t len; // [rsp+24h] [rbp-CCh]
  __int64 i; // [rsp+28h] [rbp-C8h]
  const char *v9; // [rsp+30h] [rbp-C0h]
  __int64 v10; // [rsp+38h] [rbp-B8h]
  struct sockaddr addr; // [rsp+40h] [rbp-B0h]
  const char *v12; // [rsp+50h] [rbp-A0h]
  const char *v13; // [rsp+58h] [rbp-98h]
  const char *v14; // [rsp+60h] [rbp-90h]
  const char *v15; // [rsp+68h] [rbp-88h]
  const char *v16; // [rsp+70h] [rbp-80h]
  const char *v17; // [rsp+78h] [rbp-78h]
  const char *v18; // [rsp+80h] [rbp-70h]
  const char *v19; // [rsp+88h] [rbp-68h]
  const char *v20; // [rsp+90h] [rbp-60h]
  const char *v21; // [rsp+98h] [rbp-58h]
  const char *v22; // [rsp+A0h] [rbp-50h]
  char s[8]; // [rsp+B0h] [rbp-40h]
  unsigned __int64 v24; // [rsp+C8h] [rbp-28h]

  v24 = __readfsqword(0x28u);
  v10 = g_string_new(0LL);
  v12 = "CLOSED";
  v13 = "LISTEN";
  v14 = "SYN_SENT";
  v15 = "SYN_RCVD";
  v16 = "ESTABLISHED";
  v17 = "CLOSE_WAIT";
  v18 = "FIN_WAIT_1";
  v19 = "CLOSING";
  v20 = "LAST_ACK";
  v21 = "FIN_WAIT_2";
  v22 = "TIME_WAIT";
  g_string_append_printf(v10, "  Protocol[State]    FD  Source Address  Port   Dest. Address  Port RecvQ SendQ\n");
  for ( i = a1[56]; (_QWORD *)i != a1 + 56; i = *(_QWORD *)i )
  {
    if ( *(_DWORD *)(i + 332) & 0x1000 )
    {
      v9 = "HOST_FORWARD";
    }
    else if ( *(_QWORD *)(i + 336) )
    {
      v9 = (&v12)[*(signed __int16 *)(*(_QWORD *)(i + 336) + 16LL)];
    }
    else
    {
      v9 = "NONE";
    }
    if ( *(_DWORD *)(i + 332) & 0x3000 )
    {
      len = 16;
      getsockname(*(_DWORD *)(i + 16), &addr, &len);
      in.s_addr = *(_DWORD *)(i + 204);
      v2 = *(_WORD *)(i + 202);
    }
    else
    {
      *(_DWORD *)&addr.sa_data[2] = *(_DWORD *)(i + 204);
      *(_WORD *)addr.sa_data = *(_WORD *)(i + 202);
      in.s_addr = *(_DWORD *)(i + 76);
      v2 = *(_WORD *)(i + 74);
    }
    snprintf(s, 0x14uLL, "  TCP[%s]", v9);
    ntohs(*(uint16_t *)addr.sa_data);
    if ( *(_DWORD *)&addr.sa_data[2] )
      inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);
    g_string_append_printf(v10, "%-19s %3d %15s %5d ");
    ntohs(v2);
    inet_ntoa(in);
    g_string_append_printf(v10, "%15s %5d %5d %5d\n");
  }
  for ( i = a1[111]; (_QWORD *)i != a1 + 111; i = *(_QWORD *)i )
  {
    if ( *(_DWORD *)(i + 332) & 0x1000 )
    {
      strcpy(s, "  UDP[HOST_FORWARD]");
      len = 16;
      getsockname(*(_DWORD *)(i + 16), &addr, &len);
      ina.s_addr = *(_DWORD *)(i + 204);
      v3 = *(_WORD *)(i + 202);
    }
    else
    {
      snprintf(s, 0x14uLL, "  UDP[%d sec]", (*(_DWORD *)(i + 344) - unk_2250E8) / 0x3E8u);
      *(_DWORD *)&addr.sa_data[2] = *(_DWORD *)(i + 204);
      *(_WORD *)addr.sa_data = *(_WORD *)(i + 202);
      ina.s_addr = *(_DWORD *)(i + 76);
      v3 = *(_WORD *)(i + 74);
    }
    ntohs(*(uint16_t *)addr.sa_data);
    if ( *(_DWORD *)&addr.sa_data[2] )
      inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);
    g_string_append_printf(v10, "%-19s %3d %15s %5d ");
    ntohs(v3);
    inet_ntoa(ina);
    g_string_append_printf(v10, "%15s %5d %5d %5d\n");
  }
  for ( i = a1[165]; (_QWORD *)i != a1 + 165; i = *(_QWORD *)i )
  {
    snprintf(s, 0x14uLL, "  ICMP[%d sec]", (*(_DWORD *)(i + 344) - unk_2250E8) / 0x3E8u);
    *(_DWORD *)&addr.sa_data[2] = *(_DWORD *)(i + 204);
    inb.s_addr = *(_DWORD *)(i + 76);
    if ( *(_DWORD *)&addr.sa_data[2] )
      inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);
    g_string_append_printf(v10, "%-19s %3d %15s  -    ");
    inet_ntoa(inb);
    g_string_append_printf(v10, "%15s  -    %5d %5d\n");
  }
  return g_string_free(v10, 0LL);
}
// 2D30: using guessed type __int64 __fastcall g_string_new(_QWORD);
// 2F30: using guessed type __int64 __fastcall g_string_free(_QWORD, _QWORD);
// 3070: using guessed type __int64 __fastcall g_string_append_printf(_QWORD, _QWORD);

//----- (000000000000B890) ----------------------------------------------------
__int64 __fastcall sub_B890(__int64 a1, int a2)
{
  int v3; // [rsp+18h] [rbp-8h]
  int i; // [rsp+1Ch] [rbp-4h]

  v3 = 0;
  for ( i = 0; i < a2; ++i )
    v3 += htons(*(_WORD *)(2LL * i + a1));
  return (unsigned int)-v3;
}

//----- (000000000000B8E6) ----------------------------------------------------
__int64 __fastcall sub_B8E6(__int64 a1)
{
  *(_DWORD *)(a1 + 20) = htonl(0xFFFFFFFF);
  *(_DWORD *)(a1 + 24) = htonl(0xFFFFFFFF);
  *(_DWORD *)(a1 + 28) = htonl(0xFFFFFFFF);
  *(_DWORD *)(a1 + 32) = htonl(0xFFFFFFFF);
  *(_DWORD *)(a1 + 36) = htonl(0xFFFFFFFF);
  *(_BYTE *)(a1 + 46) = -1;
  *(_BYTE *)(a1 + 43) = 2;
  return 0LL;
}

//----- (000000000000B970) ----------------------------------------------------
__int64 __fastcall sub_B970(__int64 a1)
{
  *(_DWORD *)(a1 + 20) = htonl(1u);
  return 0LL;
}

//----- (000000000000B99E) ----------------------------------------------------
__int64 __fastcall sub_B99E(__int64 a1)
{
  *(_BYTE *)(a1 + 20) = 0;
  *(_BYTE *)(a1 + 23) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 26) = 0;
  return 0LL;
}

//----- (000000000000B9D7) ----------------------------------------------------
unsigned __int64 __fastcall sub_B9D7(__int64 a1, _BYTE *a2)
{
  uint32_t v2; // eax
  unsigned int i; // [rsp+2Ch] [rbp-114h]
  int v5; // [rsp+30h] [rbp-110h]
  unsigned __int8 *v6; // [rsp+38h] [rbp-108h]
  char s; // [rsp+60h] [rbp-E0h]
  __int16 v8; // [rsp+66h] [rbp-DAh]
  uint16_t v9; // [rsp+6Ch] [rbp-D4h]
  char v10; // [rsp+6Eh] [rbp-D2h]
  char v11; // [rsp+6Fh] [rbp-D1h]
  char v12; // [rsp+71h] [rbp-CFh]
  char v13; // [rsp+72h] [rbp-CEh]
  char v14; // [rsp+73h] [rbp-CDh]
  uint16_t v15; // [rsp+74h] [rbp-CCh]
  uint16_t v16; // [rsp+7Eh] [rbp-C2h]
  uint16_t v17; // [rsp+80h] [rbp-C0h]
  unsigned __int64 v18; // [rsp+138h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  v6 = 0LL;
  v5 = 16;
  memset(&s, 0, 0xCEuLL);
  memset(&s, 255, 6uLL);
  memset(&v8, 255, 6uLL);
  v9 = htons(0x88F8u);
  for ( i = 0; i <= 0x1D; ++i )
  {
    if ( byte_222900[16 * i] == (unsigned __int8)a2[18] + 128 )
    {
      v6 = &byte_222900[16 * i];
      break;
    }
  }
  v10 = a2[14];
  v11 = 1;
  v12 = a2[17];
  v13 = a2[18] + -128;
  v14 = a2[19];
  if ( v6 )
  {
    v15 = htons(*((_DWORD *)v6 + 1));
    v16 = htons(0);
    v17 = htons(0);
    if ( *((_QWORD *)v6 + 1) )
      (*((void (__fastcall **)(char *, signed __int64))v6 + 1))(&v10, 255LL);
    v5 = *((_DWORD *)v6 + 1) + 16;
    v2 = sub_B890((__int64)&v10, v5);
  }
  else
  {
    v15 = 0;
    v16 = htons(2u);
    v17 = htons(0x7FFFu);
    v2 = sub_B890((__int64)&v10, 16);
  }
  *(_DWORD *)(&v10 + v5) = htonl(v2);
  sub_F245(a1, (__int64)&s, v5 + 18);
  return __readfsqword(0x28u) ^ v18;
}

//----- (000000000000BCE7) ----------------------------------------------------
bool __fastcall sub_BCE7(const void *a1, const void *a2)
{
  return memcmp(a1, a2, 0x10uLL) == 0;
}

//----- (000000000000BD16) ----------------------------------------------------
unsigned __int64 __fastcall sub_BD16(__int64 a1, __int64 a2, __int64 a3, void *a4)
{
  signed __int64 v4; // rcx
  __int64 v5; // rdx
  unsigned int v6; // eax
  __int64 cp; // [rsp+0h] [rbp-80h]
  __int64 v9; // [rsp+8h] [rbp-78h]
  void *src; // [rsp+10h] [rbp-70h]
  __int64 v11; // [rsp+18h] [rbp-68h]
  int i; // [rsp+24h] [rbp-5Ch]
  __int64 v13; // [rsp+28h] [rbp-58h]
  __int64 v14; // [rsp+30h] [rbp-50h]
  __int64 v15; // [rsp+38h] [rbp-48h]
  char buf; // [rsp+40h] [rbp-40h]
  unsigned __int64 v17; // [rsp+78h] [rbp-8h]

  v11 = a1;
  cp = a2;
  v9 = a3;
  src = a4;
  v17 = __readfsqword(0x28u);
  v13 = a1 + 5580;
  inet_ntop(10, &cp, &buf, 0x2Eu);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ndp_table_add...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ip = %s");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " hw addr = %02x:%02x:%02x:%02x:%02x:%02x");
  if ( (_BYTE)cp == -1 || (v14 = 0LL, v15 = 0LL, sub_BCE7(&cp, &v14)) )
  {
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " abort: do not register multicast or unspecified address...");
  }
  else
  {
    for ( i = 0; ; ++i )
    {
      if ( i > 15 )
      {
        if ( unk_2250E0 & 1 )
          g_log("Slirp", 128LL, " create new entry...");
        v4 = 24LL * *(signed int *)(v13 + 384) + v13;
        v5 = v9;
        *(_QWORD *)(v4 + 8) = cp;
        *(_QWORD *)(v4 + 16) = v5;
        memcpy((void *)(24LL * *(signed int *)(v13 + 384) + v13), src, 6uLL);
        v6 = (unsigned int)((*(_DWORD *)(v13 + 384) + 1) >> 31) >> 28;
        *(_DWORD *)(v13 + 384) = (((_BYTE)v6 + *(_BYTE *)(v13 + 384) + 1) & 0xF) - v6;
        return __readfsqword(0x28u) ^ v17;
      }
      if ( sub_BCE7((const void *)(v13 + 24LL * i + 8), &cp) )
        break;
    }
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " already in table: update the entry...");
    memcpy((void *)(24LL * i + v13), src, 6uLL);
  }
  return __readfsqword(0x28u) ^ v17;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000C04F) ----------------------------------------------------
signed __int64 __fastcall sub_C04F(__int64 a1, __int64 a2, __int64 a3, void *a4)
{
  signed __int64 result; // rax
  __int64 cp; // [rsp+0h] [rbp-80h]
  __int64 v6; // [rsp+8h] [rbp-78h]
  void *dest; // [rsp+10h] [rbp-70h]
  __int64 v8; // [rsp+18h] [rbp-68h]
  int i; // [rsp+24h] [rbp-5Ch]
  __int64 v10; // [rsp+28h] [rbp-58h]
  __int64 v11; // [rsp+30h] [rbp-50h]
  __int64 v12; // [rsp+38h] [rbp-48h]
  char buf; // [rsp+40h] [rbp-40h]
  unsigned __int64 v14; // [rsp+78h] [rbp-8h]

  v8 = a1;
  cp = a2;
  v6 = a3;
  dest = a4;
  v14 = __readfsqword(0x28u);
  v10 = a1 + 5580;
  inet_ntop(10, &cp, &buf, 0x2Eu);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "ndp_table_search...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ip = %s");
  v11 = 0LL;
  v12 = 0LL;
  if ( sub_BCE7(&cp, &v11) )
    __assert_fail("!in6_zero(&ip_addr)", "../src/ndp_table.c", 0x3Bu, "ndp_table_search");
  if ( (_BYTE)cp == -1 )
  {
    *(_BYTE *)dest = 51;
    *((_BYTE *)dest + 1) = 51;
    *(_DWORD *)((char *)dest + 2) = HIDWORD(v6);
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " multicast addr = %02x:%02x:%02x:%02x:%02x:%02x");
    result = 1LL;
  }
  else
  {
    for ( i = 0; ; ++i )
    {
      if ( i > 15 )
      {
        if ( unk_2250E0 & 1 )
          g_log("Slirp", 128LL, " ip not found in table...");
        return 0LL;
      }
      if ( sub_BCE7((const void *)(v10 + 24LL * i + 8), &cp) )
        break;
    }
    memcpy(dest, (const void *)(24LL * i + v10), 6uLL);
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " found hw addr = %02x:%02x:%02x:%02x:%02x:%02x");
    result = 1LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000C3AB) ----------------------------------------------------
void __fastcall sub_C3AB(__int64 a1)
{
  free(*(void **)(a1 + 24));
}

//----- (000000000000C3CA) ----------------------------------------------------
_BOOL8 __fastcall sub_C3CA(unsigned int *a1, unsigned int a2)
{
  unsigned int v3; // [rsp+0h] [rbp-1Ch]
  unsigned int v4; // [rsp+18h] [rbp-4h]

  v3 = a2;
  v4 = a1[1] >> 1;
  if ( *a1 < a2 )
    v3 = *a1;
  *a1 -= v3;
  *((_QWORD *)a1 + 2) += (signed int)v3;
  if ( *((_QWORD *)a1 + 2) >= *((_QWORD *)a1 + 3) + (unsigned __int64)a1[1] )
    *((_QWORD *)a1 + 2) -= a1[1];
  return *a1 < v4 && v3 + *a1 >= v4;
}

//----- (000000000000C48D) ----------------------------------------------------
__int64 __fastcall sub_C48D(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 24) )
  {
    result = a2;
    if ( *(_DWORD *)(a1 + 4) != a2 )
    {
      *(_QWORD *)(a1 + 24) = realloc(*(void **)(a1 + 24), (signed int)a2);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 16);
      *(_DWORD *)a1 = 0;
      if ( *(_QWORD *)(a1 + 8) )
      {
        result = a1;
        *(_DWORD *)(a1 + 4) = a2;
      }
      else
      {
        result = a1;
        *(_DWORD *)(a1 + 4) = 0;
      }
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = malloc((signed int)a2);
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 16);
    *(_DWORD *)a1 = 0;
    if ( *(_QWORD *)(a1 + 8) )
    {
      result = a1;
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      result = a1;
      *(_DWORD *)(a1 + 4) = 0;
    }
  }
  return result;
}

//----- (000000000000C59C) ----------------------------------------------------
__int64 __fastcall sub_C59C(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // [rsp+1Ch] [rbp-4h]

  v3 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sbappend...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m->m_len = %d");
  if ( *(_DWORD *)(a2 + 56) <= 0 )
    return sub_A4F0(a2);
  if ( *(_DWORD *)(a1 + 64) )
  {
    sub_C791(a1 + 360, a2);
    sub_A4F0(a2);
    result = sub_10307(a1);
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 360) )
      v3 = sub_F014(a1, *(const void **)(a2 + 48), *(signed int *)(a2 + 56), 0);
    if ( v3 > 0 )
    {
      if ( v3 != *(_DWORD *)(a2 + 56) )
      {
        *(_DWORD *)(a2 + 56) -= v3;
        *(_QWORD *)(a2 + 48) += v3;
        sub_C791(a1 + 360, a2);
      }
    }
    else
    {
      sub_C791(a1 + 360, a2);
    }
    result = sub_A4F0(a2);
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000C791) ----------------------------------------------------
unsigned __int64 __fastcall sub_C791(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax
  int v3; // [rsp+14h] [rbp-Ch]
  int v4; // [rsp+18h] [rbp-8h]
  int v5; // [rsp+1Ch] [rbp-4h]
  int v6; // [rsp+1Ch] [rbp-4h]

  v5 = *(_DWORD *)(a2 + 56);
  if ( *(_QWORD *)(a1 + 8) >= *(_QWORD *)(a1 + 16) )
  {
    v3 = *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8);
    if ( v3 > v5 )
      v3 = *(_DWORD *)(a2 + 56);
    memcpy(*(void **)(a1 + 8), *(const void **)(a2 + 48), v3);
    v6 = v5 - v3;
    if ( v6 )
    {
      v4 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 24);
      if ( v4 > v6 )
        v4 = v6;
      memcpy(*(void **)(a1 + 24), (const void *)(v3 + *(_QWORD *)(a2 + 48)), v4);
      v3 += v4;
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 8);
    if ( v3 > v5 )
      v3 = *(_DWORD *)(a2 + 56);
    memcpy(*(void **)(a1 + 8), *(const void **)(a2 + 48), v3);
  }
  *(_DWORD *)a1 += v3;
  *(_QWORD *)(a1 + 8) += v3;
  result = *(_QWORD *)(a1 + 24) + *(unsigned int *)(a1 + 4);
  if ( *(_QWORD *)(a1 + 8) >= result )
  {
    result = a1;
    *(_QWORD *)(a1 + 8) -= *(unsigned int *)(a1 + 4);
  }
  return result;
}

//----- (000000000000C938) ----------------------------------------------------
unsigned __int64 __fastcall sub_C938(int *a1, int a2, int a3, char *a4)
{
  unsigned __int64 result; // rax
  char *dest; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+10h] [rbp-20h]
  int v7; // [rsp+10h] [rbp-20h]
  int v8; // [rsp+14h] [rbp-1Ch]
  char *src; // [rsp+28h] [rbp-8h]

  v6 = a3;
  dest = a4;
  src = (char *)(*((_QWORD *)a1 + 2) + a2);
  if ( (unsigned __int64)src >= *((_QWORD *)a1 + 3) + (unsigned __int64)(unsigned int)a1[1] )
    src -= (unsigned int)a1[1];
  if ( (unsigned __int64)src >= *((_QWORD *)a1 + 1) )
  {
    v8 = a1[6] + a1[1] - (_DWORD)src;
    if ( v8 > a3 )
      v8 = a3;
    memcpy(a4, src, v8);
    result = (unsigned int)v8;
    v7 = v6 - v8;
    if ( v7 )
      result = (unsigned __int64)memcpy(&dest[v8], *((const void **)a1 + 3), v7);
  }
  else
  {
    if ( *a1 < (unsigned int)a3 )
      v6 = *a1;
    result = (unsigned __int64)memcpy(a4, src, v6);
  }
  return result;
}

//----- (000000000000CA4B) ----------------------------------------------------
bool __fastcall sub_CA4B(const void *a1, const void *a2)
{
  return memcmp(a1, a2, 0x10uLL) == 0;
}

//----- (000000000000CA7A) ----------------------------------------------------
__int64 __fastcall sub_CA7A(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  *(_BYTE *)a3 = 82;
  *(_BYTE *)(a3 + 1) = 86;
  result = HIDWORD(a2);
  *(_DWORD *)(a3 + 2) = HIDWORD(a2);
  return result;
}

//----- (000000000000CABA) ----------------------------------------------------
signed __int64 __fastcall sub_CABA(void *a1, const void *a2, unsigned int a3, struct stat64 *a4, _DWORD *a5)
{
  signed __int64 result; // rax
  struct stat64 *stat_buf; // [rsp+10h] [rbp-C0h]
  unsigned int n; // [rsp+1Ch] [rbp-B4h]
  __dev_t v8; // [rsp+30h] [rbp-A0h]
  __ino64_t v9; // [rsp+38h] [rbp-98h]
  __off_t v10; // [rsp+60h] [rbp-70h]
  __time_t v11; // [rsp+88h] [rbp-48h]

  n = a3;
  stat_buf = a4;
  if ( (unsigned int)(unk_2250E8 - *a5) > 0x3E7 )
  {
    v8 = a4->st_dev;
    v9 = a4->st_ino;
    v10 = a4->st_size;
    v11 = a4->st_mtim.tv_sec;
    if ( sub_1D0D0("/etc/resolv.conf", a4) )
    {
      result = 0xFFFFFFFFLL;
    }
    else if ( stat_buf->st_dev != v8
           || stat_buf->st_ino != v9
           || stat_buf->st_size != v10
           || stat_buf->st_mtim.tv_sec != v11 )
    {
      result = 1LL;
    }
    else
    {
      memcpy(a1, a2, n);
      result = 0LL;
    }
  }
  else
  {
    memcpy(a1, a2, a3);
    result = 0LL;
  }
  return result;
}

//----- (000000000000CC9E) ----------------------------------------------------
signed __int64 __fastcall sub_CC9E(unsigned int a1, void *a2, void *a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  void *v6; // rsp
  signed __int64 result; // rax
  _DWORD *v8; // [rsp+8h] [rbp-3A8h]
  unsigned int *v9; // [rsp+10h] [rbp-3A0h]
  void *v10; // [rsp+18h] [rbp-398h]
  void *dest; // [rsp+20h] [rbp-390h]
  size_t n; // [rsp+28h] [rbp-388h]
  int v13; // [rsp+38h] [rbp-378h]
  unsigned int v14; // [rsp+3Ch] [rbp-374h]
  const char *v15; // [rsp+40h] [rbp-370h]
  void *buf; // [rsp+48h] [rbp-368h]
  FILE *stream; // [rsp+50h] [rbp-360h]
  char *v18; // [rsp+58h] [rbp-358h]
  char v19; // [rsp+60h] [rbp-350h]
  char s; // [rsp+90h] [rbp-320h]
  char v21; // [rsp+1A0h] [rbp-210h]
  unsigned __int64 v22; // [rsp+3A8h] [rbp-8h]

  dest = a2;
  v10 = a3;
  n = __PAIR__(a1, a4);
  v9 = a5;
  v8 = a6;
  v22 = __readfsqword(0x28u);
  v13 = 0;
  v6 = alloca(16 * (((unsigned __int64)a4 + 30) / 0x10));
  buf = (void *)(16 * (((unsigned __int64)&v8 + 7) >> 4));
  stream = fopen64("/etc/resolv.conf", "r");
  if ( !stream )
    return 0xFFFFFFFFLL;
  if ( unk_2250E0 & 2 )
    g_log("Slirp", 128LL, "IP address of your DNS(s):");
  while ( fgets(&v21, 512, stream) )
  {
    if ( (unsigned int)__isoc99_sscanf(&v21, "nameserver%*[ \t]%256s", &s) == 1 )
    {
      v18 = strchr(&s, 37);
      if ( v18 )
      {
        v14 = if_nametoindex(v18 + 1);
        *v18 = 0;
      }
      else
      {
        v14 = 0;
      }
      if ( inet_pton(SHIDWORD(n), &s, buf) )
      {
        if ( !v13 )
        {
          memcpy(dest, buf, (unsigned int)n);
          memcpy(v10, buf, (unsigned int)n);
          if ( v9 )
            *v9 = v14;
          *v8 = unk_2250E8;
        }
        if ( ++v13 > 3 )
        {
          if ( unk_2250E0 & 2 )
            g_log("Slirp", 128LL, "  (more)");
          break;
        }
        if ( unk_2250E0 & 2 )
        {
          v15 = inet_ntop(SHIDWORD(n), buf, &v19, 0x2Eu);
          if ( !v15 )
            v15 = "  (string conversion error)";
          if ( unk_2250E0 & 2 )
            g_log("Slirp", 128LL, "  %s");
        }
      }
    }
  }
  fclose(stream);
  if ( v13 )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
  return result;
}
// 3010: using guessed type __int64 __fastcall __isoc99_sscanf(_QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000CFD3) ----------------------------------------------------
signed __int64 __fastcall sub_CFD3(void *a1)
{
  signed __int64 result; // rax
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  if ( dword_224F60
    && (v2 = sub_CABA(a1, &dword_224F60, 4u, (struct stat64 *)&unk_224FA0, &unk_224F80), (signed int)v2 <= 0) )
  {
    result = v2;
  }
  else
  {
    result = sub_CC9E(2u, a1, &dword_224F60, 4u, 0LL, &unk_224F80);
  }
  return result;
}
// 224F60: using guessed type int dword_224F60;

//----- (000000000000D049) ----------------------------------------------------
signed __int64 __fastcall sub_D049(void *a1, unsigned int *a2)
{
  signed __int64 result; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-24h]
  __int64 v4; // [rsp+20h] [rbp-20h]
  __int64 v5; // [rsp+28h] [rbp-18h]
  unsigned __int64 v6; // [rsp+38h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v4 = 0LL;
  v5 = 0LL;
  if ( !sub_CA4B(&unk_224F70, &v4)
    && (v3 = sub_CABA(a1, &unk_224F70, 0x10u, (struct stat64 *)&unk_225040, &unk_224F84), (signed int)v3 <= 0) )
  {
    result = v3;
  }
  else
  {
    result = sub_CC9E(0xAu, a1, &unk_224F70, 0x10u, a2, &unk_224F84);
  }
  return result;
}

//----- (000000000000D107) ----------------------------------------------------
unsigned __int64 sub_D107()
{
  __int64 v1; // [rsp+8h] [rbp-58h]
  const char *v2; // [rsp+10h] [rbp-50h]
  int v3; // [rsp+18h] [rbp-48h]
  const char *v4; // [rsp+20h] [rbp-40h]
  int v5; // [rsp+28h] [rbp-38h]
  const char *v6; // [rsp+30h] [rbp-30h]
  int v7; // [rsp+38h] [rbp-28h]
  const char *v8; // [rsp+40h] [rbp-20h]
  int v9; // [rsp+48h] [rbp-18h]
  unsigned __int64 v10; // [rsp+58h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  if ( !dword_2250D0 )
  {
    dword_2250D0 = 1;
    unk_2250E4 = htonl(0x7F000001u);
    unk_2250D8 = htonl(0xFF000000);
    v1 = g_getenv("SLIRP_DEBUG");
    if ( v1 )
    {
      v2 = "call";
      v3 = 1;
      v4 = "misc";
      v5 = 2;
      v6 = "error";
      v7 = 4;
      v8 = "tftp";
      v9 = 8;
      unk_2250E0 = g_parse_debug_string(v1, &v2, 4LL);
    }
  }
  return __readfsqword(0x28u) ^ v10;
}
// 3030: using guessed type __int64 __fastcall g_parse_debug_string(_QWORD, _QWORD, _QWORD);
// 3150: using guessed type __int64 __fastcall g_getenv(_QWORD);
// 2250D0: using guessed type int dword_2250D0;

//----- (000000000000D1FC) ----------------------------------------------------
__int64 __fastcall slirp_new(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 v6; // rdx
  signed int v7; // edx
  signed int v8; // edx
  __int64 v9; // [rsp+8h] [rbp-28h]
  __int64 v10; // [rsp+28h] [rbp-8h]

  v9 = a3;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 )
    {
      if ( *(_DWORD *)a1 <= 1u )
      {
        if ( *(_QWORD *)(a1 + 136) <= 0x43uLL && *(_QWORD *)(a1 + 136) )
        {
          g_return_if_fail_warning("Slirp", "slirp_new", "cfg->if_mtu >= IF_MTU_MIN || cfg->if_mtu == 0");
          result = 0LL;
        }
        else if ( *(_QWORD *)(a1 + 136) <= 0xFFF1uLL )
        {
          if ( *(_QWORD *)(a1 + 144) <= 0x43uLL && *(_QWORD *)(a1 + 144) )
          {
            g_return_if_fail_warning("Slirp", "slirp_new", "cfg->if_mru >= IF_MRU_MIN || cfg->if_mru == 0");
            result = 0LL;
          }
          else if ( *(_QWORD *)(a1 + 144) <= 0xFFF1uLL )
          {
            v10 = g_malloc0(6008LL);
            sub_D107();
            *(_QWORD *)(v10 + 6000) = v9;
            *(_QWORD *)(v10 + 5992) = a2;
            *(_QWORD *)(v10 + 5968) = g_rand_new();
            *(_DWORD *)(v10 + 124) = *(_DWORD *)(a1 + 4);
            *(_BYTE *)(v10 + 9) = *(_BYTE *)(a1 + 8);
            *(_BYTE *)(v10 + 10) = *(_BYTE *)(a1 + 24);
            sub_5E6B((_QWORD *)v10);
            sub_929D((_QWORD *)v10);
            sub_7E9D(v10);
            sub_A28A((_QWORD *)v10);
            *(_DWORD *)(v10 + 12) = *(_DWORD *)(a1 + 12);
            *(_DWORD *)(v10 + 16) = *(_DWORD *)(a1 + 16);
            *(_DWORD *)(v10 + 20) = *(_DWORD *)(a1 + 20);
            v4 = *(_QWORD *)(a1 + 36);
            *(_QWORD *)(v10 + 24) = *(_QWORD *)(a1 + 28);
            *(_QWORD *)(v10 + 32) = v4;
            *(_BYTE *)(v10 + 40) = *(_BYTE *)(a1 + 44);
            v5 = *(_QWORD *)(a1 + 56);
            *(_QWORD *)(v10 + 44) = *(_QWORD *)(a1 + 48);
            *(_QWORD *)(v10 + 52) = v5;
            if ( *(_QWORD *)(a1 + 64) )
              sub_1C2CC((_BYTE *)(v10 + 88), 33, *(char **)(a1 + 64));
            *(_QWORD *)(v10 + 1752) = g_strdup(*(_QWORD *)(a1 + 80));
            *(_QWORD *)(v10 + 416) = g_strdup(*(_QWORD *)(a1 + 88));
            *(_QWORD *)(v10 + 440) = g_strdup(*(_QWORD *)(a1 + 128));
            *(_DWORD *)(v10 + 60) = *(_DWORD *)(a1 + 96);
            *(_DWORD *)(v10 + 64) = *(_DWORD *)(a1 + 100);
            v6 = *(_QWORD *)(a1 + 112);
            *(_QWORD *)(v10 + 68) = *(_QWORD *)(a1 + 104);
            *(_QWORD *)(v10 + 76) = v6;
            *(_QWORD *)(v10 + 5120) = g_strdup(*(_QWORD *)(a1 + 72));
            if ( *(_QWORD *)(a1 + 120) )
              sub_58E0(v10, *(_QWORD **)(a1 + 120));
            if ( *(_QWORD *)(a1 + 136) )
              v7 = *(_QWORD *)(a1 + 136);
            else
              v7 = 1500;
            *(_DWORD *)(v10 + 136) = v7;
            if ( *(_QWORD *)(a1 + 144) )
              v8 = *(_QWORD *)(a1 + 144);
            else
              v8 = 1500;
            *(_DWORD *)(v10 + 140) = v8;
            *(_BYTE *)(v10 + 144) = *(_BYTE *)(a1 + 152);
            *(_BYTE *)(v10 + 5984) = *(_BYTE *)(a1 + 153);
            result = v10;
          }
          else
          {
            g_return_if_fail_warning("Slirp", "slirp_new", "cfg->if_mru <= IF_MRU_MAX");
            result = 0LL;
          }
        }
        else
        {
          g_return_if_fail_warning("Slirp", "slirp_new", "cfg->if_mtu <= IF_MTU_MAX");
          result = 0LL;
        }
      }
      else
      {
        g_return_if_fail_warning("Slirp", "slirp_new", "cfg->version <= SLIRP_CONFIG_VERSION_MAX");
        result = 0LL;
      }
    }
    else
    {
      g_return_if_fail_warning("Slirp", "slirp_new", "cfg->version >= SLIRP_CONFIG_VERSION_MIN");
      result = 0LL;
    }
  }
  else
  {
    g_return_if_fail_warning("Slirp", "slirp_new", "cfg != NULL");
    result = 0LL;
  }
  return result;
}
// 2EC0: using guessed type __int64 __fastcall g_return_if_fail_warning(_QWORD, _QWORD, _QWORD);
// 2F80: using guessed type __int64 g_rand_new(void);
// 3100: using guessed type __int64 __fastcall g_malloc0(_QWORD);
// 3140: using guessed type __int64 __fastcall g_strdup(_QWORD);

//----- (000000000000D625) ----------------------------------------------------
__int64 __fastcall slirp_init(int a1, char a2, int a3, int a4, int a5, char a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, __int64 a21, __int64 a22, __int64 a23)
{
  int v23; // ST54_4
  int v24; // ST50_4
  int v25; // ST4C_4
  char v26; // ST48_1
  int s; // [rsp+60h] [rbp-B0h]
  int v29; // [rsp+64h] [rbp-ACh]
  char v30; // [rsp+68h] [rbp-A8h]
  int v31; // [rsp+6Ch] [rbp-A4h]
  int v32; // [rsp+70h] [rbp-A0h]
  int v33; // [rsp+74h] [rbp-9Ch]
  char v34; // [rsp+78h] [rbp-98h]
  __int64 v35; // [rsp+7Ch] [rbp-94h]
  __int64 v36; // [rsp+84h] [rbp-8Ch]
  char v37; // [rsp+8Ch] [rbp-84h]
  __int64 v38; // [rsp+90h] [rbp-80h]
  __int64 v39; // [rsp+98h] [rbp-78h]
  __int64 v40; // [rsp+A0h] [rbp-70h]
  __int64 v41; // [rsp+A8h] [rbp-68h]
  __int64 v42; // [rsp+B0h] [rbp-60h]
  __int64 v43; // [rsp+B8h] [rbp-58h]
  int v44; // [rsp+C0h] [rbp-50h]
  int v45; // [rsp+C4h] [rbp-4Ch]
  __int64 v46; // [rsp+C8h] [rbp-48h]
  __int64 v47; // [rsp+D0h] [rbp-40h]
  __int64 v48; // [rsp+D8h] [rbp-38h]
  __int64 v49; // [rsp+E0h] [rbp-30h]
  unsigned __int64 v50; // [rsp+108h] [rbp-8h]

  v23 = a3;
  v24 = a4;
  v25 = a5;
  v26 = a6;
  v50 = __readfsqword(0x28u);
  memset(&s, 0, 0xA0uLL);
  s = 1;
  v29 = a1;
  v30 = a2;
  v31 = v23;
  v32 = v24;
  v33 = v25;
  v34 = v26;
  v35 = a7;
  v36 = a8;
  v37 = a9;
  v38 = a10;
  v39 = a11;
  v40 = a12;
  v41 = a13;
  v42 = a14;
  v43 = a15;
  v44 = a16;
  v45 = a17;
  v46 = a18;
  v47 = a19;
  v48 = a20;
  v49 = a21;
  return slirp_new(&s, a22, a23);
}
// 2CF0: using guessed type __int64 __fastcall slirp_new(_QWORD, _QWORD, _QWORD);

//----- (000000000000D809) ----------------------------------------------------
__int64 __fastcall slirp_cleanup(_QWORD *a1)
{
  __int64 v1; // ST18_8
  __int64 i; // [rsp+10h] [rbp-10h]

  for ( i = a1[16]; i; i = v1 )
  {
    v1 = *(_QWORD *)(i + 32);
    g_free(*(_QWORD *)(i + 24));
    g_free(i);
  }
  sub_92FC((__int64)a1);
  sub_7EB8((__int64)a1);
  sub_A2ED((__int64)a1);
  g_rand_free(a1[746]);
  g_free(a1[54]);
  g_free(a1[219]);
  g_free(a1[52]);
  g_free(a1[55]);
  return g_free(a1);
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);
// 2E90: using guessed type __int64 __fastcall g_rand_free(_QWORD);

//----- (000000000000D8EF) ----------------------------------------------------
signed int *__fastcall sub_D8EF(__int64 a1, signed int *a2)
{
  signed int *result; // rax
  signed int v3; // eax
  signed int v4; // eax
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  result = (signed int *)(unsigned int)*a2;
  if ( (unsigned int)result > 2 )
  {
    v3 = *a2;
    if ( (unsigned int)*a2 > 0x3E8 )
      v3 = 1000;
    v5 = v3;
    if ( *(_DWORD *)a1 )
    {
      result = a2;
      *a2 = 2;
    }
    else
    {
      if ( *(_BYTE *)(a1 + 8) )
      {
        v4 = 499;
        if ( v5 <= 0x1F3 )
          v4 = v5;
        v5 = v4;
      }
      result = a2;
      *a2 = v5;
    }
  }
  return result;
}

//----- (000000000000D95F) ----------------------------------------------------
signed int *__fastcall slirp_pollfds_fill(__int64 a1, signed int *a2, __int64 (__fastcall *a3)(_QWORD, signed __int64, __int64), __int64 a4)
{
  bool v4; // al
  __int64 v6; // [rsp+0h] [rbp-40h]
  __int64 (__fastcall *v7)(_QWORD, signed __int64, __int64); // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+2Ch] [rbp-14h]
  __int64 *i; // [rsp+30h] [rbp-10h]
  __int64 j; // [rsp+30h] [rbp-10h]
  __int64 k; // [rsp+30h] [rbp-10h]
  __int64 *v12; // [rsp+38h] [rbp-8h]
  __int64 v13; // [rsp+38h] [rbp-8h]
  __int64 v14; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v6 = a4;
  v4 = *(_QWORD *)(a1 + 448) != a1 + 448 || a1 + 248 != *(_QWORD *)(a1 + 248);
  *(_BYTE *)(a1 + 8) = v4;
  for ( i = *(__int64 **)(a1 + 448); i != (__int64 *)(a1 + 448); i = v12 )
  {
    v8 = 0;
    v12 = (__int64 *)*i;
    *((_DWORD *)i + 8) = -1;
    if ( !*(_DWORD *)a1 && *(_WORD *)(i[42] + 36) & 2 )
      *(_DWORD *)a1 = unk_2250E8;
    if ( !(*((_DWORD *)i + 83) & 1) && *((_DWORD *)i + 4) != -1 )
    {
      if ( *((_DWORD *)i + 83) & 0x100 )
      {
        *((_DWORD *)i + 8) = v7(*((unsigned int *)i + 4), 25LL, v6);
      }
      else if ( *((_DWORD *)i + 83) & 2 )
      {
        *((_DWORD *)i + 8) = v7(*((unsigned int *)i + 4), 10LL, v6);
      }
      else
      {
        if ( (*((_DWORD *)i + 83) & 0x14) == 4 && *((_DWORD *)i + 90) )
          v8 = 10;
        if ( (*((_DWORD *)i + 83) & 0xC) == 4 && *((_DWORD *)i + 98) < *((_DWORD *)i + 99) >> 1 )
          v8 |= 0x1Du;
        if ( v8 )
          *((_DWORD *)i + 8) = v7(*((unsigned int *)i + 4), v8, v6);
      }
    }
  }
  for ( j = *(_QWORD *)(a1 + 888); j != a1 + 888; j = v13 )
  {
    v13 = *(_QWORD *)j;
    *(_DWORD *)(j + 32) = -1;
    if ( *(_DWORD *)(j + 344) )
    {
      if ( *(_DWORD *)(j + 344) <= unk_2250E8 )
      {
        sub_1B3C9(j);
        continue;
      }
      *(_BYTE *)(a1 + 8) = 1;
    }
    if ( *(_DWORD *)(j + 332) & 4 && *(_DWORD *)(j + 348) <= 4 )
      *(_DWORD *)(j + 32) = v7(*(unsigned int *)(j + 16), 25LL, v6);
  }
  for ( k = *(_QWORD *)(a1 + 1320); k != a1 + 1320; k = v14 )
  {
    v14 = *(_QWORD *)k;
    *(_DWORD *)(k + 32) = -1;
    if ( *(_DWORD *)(k + 344) )
    {
      if ( *(_DWORD *)(k + 344) <= unk_2250E8 )
      {
        sub_84C1(k);
        continue;
      }
      *(_BYTE *)(a1 + 8) = 1;
    }
    if ( *(_DWORD *)(k + 332) & 4 )
      *(_DWORD *)(k + 32) = v7(*(unsigned int *)(k + 16), 25LL, v6);
  }
  return sub_D8EF(a1, a2);
}

//----- (000000000000DCDB) ----------------------------------------------------
unsigned __int64 __usercall slirp_pollfds_poll@<rax>(__int64 (__fastcall *a1)(_QWORD, __int64)@<rdx>, __int64 a2@<rcx>, signed __int64 a3@<rdi>, int a4@<esi>, __int64 a5@<r12>)
{
  __int64 v5; // rax
  __int64 v7; // [rsp+0h] [rbp-50h]
  __int64 (__fastcall *v8)(_QWORD, __int64); // [rsp+8h] [rbp-48h]
  int buf; // [rsp+28h] [rbp-28h]
  int v10; // [rsp+2Ch] [rbp-24h]
  int v11; // [rsp+30h] [rbp-20h]
  int v12; // [rsp+34h] [rbp-1Ch]
  __int64 i; // [rsp+38h] [rbp-18h]
  __int64 v14; // [rsp+40h] [rbp-10h]
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v8 = a1;
  v7 = a2;
  v15 = __readfsqword(0x28u);
  v5 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a3 + 5992) + 16LL))(*(_QWORD *)(a3 + 6000));
  unk_2250E8 = ((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v5) >> 64) >> 18)
             - (v5 >> 63);
  if ( *(_DWORD *)a3 && (unsigned int)(unk_2250E8 - *(_DWORD *)a3) > 1 )
  {
    sub_19297(a3);
    *(_DWORD *)a3 = 0;
  }
  if ( *(_BYTE *)(a3 + 8) && (unsigned int)(unk_2250E8 - *(_DWORD *)(a3 + 4)) > 0x1F2 )
  {
    sub_9D58(a3);
    sub_1933B(a3);
    *(_DWORD *)(a3 + 4) = unk_2250E8;
  }
  if ( !a4 )
  {
    for ( i = *(_QWORD *)(a3 + 448); ; i = v14 )
    {
      if ( i == a3 + 448 )
      {
        for ( i = *(_QWORD *)(a3 + 888); i != a3 + 888; i = v14 )
        {
          v14 = *(_QWORD *)i;
          v11 = 0;
          if ( *(_DWORD *)(i + 32) != -1 )
            v11 = v8(*(unsigned int *)(i + 32), v7);
          if ( *(_DWORD *)(i + 16) != -1 && v11 & 0x19 )
            sub_10A5A(i);
        }
        for ( i = *(_QWORD *)(a3 + 1320); i != a3 + 1320; i = v14 )
        {
          v14 = *(_QWORD *)i;
          v12 = 0;
          if ( *(_DWORD *)(i + 32) != -1 )
            v12 = v8(*(unsigned int *)(i + 32), v7);
          if ( *(_DWORD *)(i + 16) != -1 && v12 & 0x19 )
            sub_9096(i);
        }
        break;
      }
      v14 = *(_QWORD *)i;
      v10 = 0;
      if ( *(_DWORD *)(i + 32) != -1 )
        v10 = v8(*(unsigned int *)(i + 32), v7);
      if ( *(_DWORD *)(i + 332) & 1 || *(_DWORD *)(i + 16) == -1 )
        continue;
      if ( v10 & 4 )
      {
        buf = sub_10238(i);
        if ( buf < 0 )
          continue;
      }
      else if ( v10 & 0x19 )
      {
        if ( *(_DWORD *)(i + 332) & 0x100 )
        {
          sub_17600((unsigned int *)i);
          continue;
        }
        buf = sub_FC35(i);
        if ( buf > 0 )
          sub_15563(*(_QWORD *)(i + 336));
        if ( buf < 0 )
          continue;
      }
      if ( !(*(_DWORD *)(i + 332) & 1) && v10 & 0xA )
      {
        if ( *(_DWORD *)(i + 332) & 2 )
        {
          *(_DWORD *)(i + 332) &= 0xFFFFFFFD;
          buf = send(*(_DWORD *)(i + 16), &buf, 0LL, 0);
          if ( buf >= 0 )
            goto LABEL_31;
          if ( *__errno_location() != 11
            && *__errno_location() != 11
            && *__errno_location() != 115
            && *__errno_location() != 107 )
          {
            *(_DWORD *)(i + 332) &= 0xF000u;
            *(_DWORD *)(i + 332) |= 1u;
LABEL_31:
            sub_12CFB((unsigned __int16 *)i, *(_WORD *)(i + 72), 0LL, 0x14u, a5);
            continue;
          }
        }
        else
        {
          buf = sub_106A3(i);
          if ( buf > 0 )
            sub_15563(*(_QWORD *)(i + 336));
        }
      }
    }
  }
  sub_6168(a3);
  return __readfsqword(0x28u) ^ v15;
}

//----- (000000000000E15C) ----------------------------------------------------
unsigned __int64 __fastcall sub_E15C(__int64 a1, __int64 a2)
{
  uint16_t v2; // ax
  __int64 i; // [rsp+30h] [rbp-70h]
  char s; // [rsp+50h] [rbp-50h]
  __int16 v6; // [rsp+56h] [rbp-4Ah]
  int v7; // [rsp+58h] [rbp-48h]
  uint16_t v8; // [rsp+5Ch] [rbp-44h]
  uint16_t v9; // [rsp+5Eh] [rbp-42h]
  uint16_t v10; // [rsp+60h] [rbp-40h]
  char v11; // [rsp+62h] [rbp-3Eh]
  char v12; // [rsp+63h] [rbp-3Dh]
  uint16_t v13; // [rsp+64h] [rbp-3Ch]
  __int16 v14; // [rsp+66h] [rbp-3Ah]
  int v15; // [rsp+6Ch] [rbp-34h]
  __int64 v16; // [rsp+70h] [rbp-30h]
  unsigned __int64 v17; // [rsp+98h] [rbp-8h]

  v17 = __readfsqword(0x28u);
  if ( *(_BYTE *)(a1 + 9) == 1 )
  {
    v2 = ntohs(*(_WORD *)(a2 + 20));
    if ( v2 == 1 )
    {
      if ( *(_DWORD *)(a2 + 38) == *(_DWORD *)(a2 + 28) )
      {
        sub_32BA((_DWORD *)a1, *(struct in_addr *)(a2 + 28), (void *)(a2 + 22));
      }
      else if ( (*(_DWORD *)(a1 + 16) & *(_DWORD *)(a2 + 38)) == *(_DWORD *)(a1 + 12) )
      {
        if ( *(_DWORD *)(a2 + 38) == *(_DWORD *)(a1 + 64) || *(_DWORD *)(a2 + 38) == *(_DWORD *)(a1 + 20) )
        {
LABEL_15:
          memset(&s, 0, 0x40uLL);
          sub_32BA((_DWORD *)a1, *(struct in_addr *)(a2 + 28), (void *)(a2 + 22));
          memcpy(&s, (const void *)(a2 + 6), 6uLL);
          v6 = 21842;
          v7 = *(_DWORD *)(a2 + 38);
          v8 = htons(0x806u);
          v9 = htons(1u);
          v10 = htons(0x800u);
          v11 = 6;
          v12 = 4;
          v13 = htons(2u);
          memcpy(&v14, &v6, 6uLL);
          v15 = *(_DWORD *)(a2 + 38);
          memcpy(&v16, (const void *)(a2 + 22), 6uLL);
          *(_DWORD *)((char *)&v16 + 6) = *(_DWORD *)(a2 + 28);
          sub_F245(a1, (__int64)&s, 0x40uLL);
        }
        else
        {
          for ( i = *(_QWORD *)(a1 + 128); i; i = *(_QWORD *)(i + 32) )
          {
            if ( *(_DWORD *)(i + 16) == *(_DWORD *)(a2 + 38) )
              goto LABEL_15;
          }
        }
      }
    }
    else if ( v2 == 2 )
    {
      sub_32BA((_DWORD *)a1, *(struct in_addr *)(a2 + 28), (void *)(a2 + 22));
    }
  }
  return __readfsqword(0x28u) ^ v17;
}

//----- (000000000000E448) ----------------------------------------------------
void __usercall slirp_input(signed int a1@<edx>, __int64 a2@<rdi>, unsigned __int8 *a3@<rsi>, signed __int64 a4@<r12>)
{
  signed __int64 v4; // rdx
  signed int v5; // [rsp+Ch] [rbp-24h]
  int v6; // [rsp+24h] [rbp-Ch]
  __int64 v7; // [rsp+28h] [rbp-8h]

  v5 = a1;
  if ( a1 <= 13 )
    return;
  v6 = (a3[12] << 8) + a3[13];
  if ( v6 == 2054 )
  {
    sub_E15C(a2, (__int64)a3);
    return;
  }
  if ( v6 <= 2054 )
  {
    if ( v6 != 2048 )
      return;
    goto LABEL_10;
  }
  if ( v6 == 34525 )
  {
LABEL_10:
    v7 = sub_A39A(a2);
    if ( v7 )
    {
      if ( *(_DWORD *)(v7 + 32) & 1 )
        v4 = *(_QWORD *)(v7 + 88) + *(signed int *)(v7 + 36);
      else
        v4 = v7 + 96 + *(signed int *)(v7 + 36);
      if ( v4 - *(_QWORD *)(v7 + 48) - *(signed int *)(v7 + 56) < (unsigned __int64)(v5 + 30LL) )
        sub_A70B(v7, v5 + 30);
      *(_DWORD *)(v7 + 56) = v5 + 30;
      memcpy((void *)(*(_QWORD *)(v7 + 48) + 30LL), a3, v5);
      *(_QWORD *)(v7 + 48) += 44LL;
      *(_DWORD *)(v7 + 56) -= 44;
      if ( v6 == 2048 )
      {
        sub_932F(v7, a4);
      }
      else if ( v6 == 34525 )
      {
        sub_7ED3(v7, a4);
      }
    }
    return;
  }
  if ( v6 == 35064 )
    sub_B9D7(a2, a3);
}

//----- (000000000000E629) ----------------------------------------------------
signed __int64 __fastcall sub_E629(__int64 a1, __int64 a2, __int64 a3, void *a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+8h] [rbp-78h]
  struct in_addr *v6; // [rsp+28h] [rbp-58h]
  char v7; // [rsp+40h] [rbp-40h]
  __int16 v8; // [rsp+46h] [rbp-3Ah]
  int v9; // [rsp+48h] [rbp-38h]
  uint16_t v10; // [rsp+4Ch] [rbp-34h]
  uint16_t v11; // [rsp+4Eh] [rbp-32h]
  uint16_t v12; // [rsp+50h] [rbp-30h]
  char v13; // [rsp+52h] [rbp-2Eh]
  char v14; // [rsp+53h] [rbp-2Dh]
  uint16_t v15; // [rsp+54h] [rbp-2Ch]
  __int16 v16; // [rsp+56h] [rbp-2Ah]
  int v17; // [rsp+58h] [rbp-28h]
  int v18; // [rsp+5Ch] [rbp-24h]
  __int64 v19; // [rsp+60h] [rbp-20h]
  unsigned __int64 v20; // [rsp+78h] [rbp-8h]

  v5 = a3;
  v20 = __readfsqword(0x28u);
  v6 = *(struct in_addr **)(a2 + 48);
  if ( !v6[4].s_addr )
    return 1LL;
  if ( (unsigned __int8)sub_350E(a1, v6[4], a4) != 1 )
  {
    if ( *(_BYTE *)(a2 + 72) != 1 )
    {
      memset(&v7, 255, 6uLL);
      v8 = 21842;
      v9 = *(_DWORD *)(a1 + 20);
      v10 = htons(0x806u);
      v11 = htons(1u);
      v12 = htons(0x800u);
      v13 = 6;
      v14 = 4;
      v15 = htons(1u);
      v16 = 21842;
      v17 = *(_DWORD *)(a1 + 20);
      v18 = *(_DWORD *)(a1 + 20);
      memset(&v19, 0, 6uLL);
      *(struct in_addr *)((char *)&v19 + 6) = v6[4];
      *(struct in_addr *)(a1 + 84) = v6[4];
      sub_F245(a1, (__int64)&v7, 0x2AuLL);
      *(_BYTE *)(a2 + 72) = 1;
      *(_QWORD *)(a2 + 80) = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)(a1 + 5992) + 16LL))(
                               *(_QWORD *)(a1 + 6000),
                               &v7)
                           + 1000000000;
    }
    result = 0LL;
  }
  else
  {
    *(_WORD *)(v5 + 6) = 21842;
    *(_DWORD *)(v5 + 8) = *(_DWORD *)(a1 + 20);
    *(_WORD *)(v5 + 12) = htons(0x800u);
    result = 2LL;
  }
  return result;
}

//----- (000000000000E86B) ----------------------------------------------------
signed __int64 __fastcall sub_E86B(__int64 a1, __int64 a2, __int64 a3, void *a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+8h] [rbp-28h]
  __int64 *v6; // [rsp+28h] [rbp-8h]

  v5 = a3;
  v6 = *(__int64 **)(a2 + 48);
  if ( (unsigned __int8)sub_C04F(a1, v6[3], v6[4], a4) != 1 )
  {
    if ( *(_BYTE *)(a2 + 72) != 1 )
    {
      sub_7017(a1, v6[3], v6[4]);
      *(_BYTE *)(a2 + 72) = 1;
      *(_QWORD *)(a2 + 80) = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 5992) + 16LL))(*(_QWORD *)(a1 + 6000))
                           + 1000000000;
    }
    result = 0LL;
  }
  else
  {
    *(_WORD *)(v5 + 12) = htons(0x86DDu);
    sub_CA7A(v6[1], v6[2], v5 + 6);
    result = 2LL;
  }
  return result;
}

//----- (000000000000E953) ----------------------------------------------------
signed __int64 __fastcall sub_E953(__int64 a1, __int64 a2)
{
  int v3; // eax
  signed int v4; // [rsp+14h] [rbp-1007Ch]
  signed int v5; // [rsp+14h] [rbp-1007Ch]
  int v6; // [rsp+2Ah] [rbp-10066h]
  __int16 v7; // [rsp+2Eh] [rbp-10062h]
  char v8; // [rsp+30h] [rbp-10060h]
  __int16 v9; // [rsp+34h] [rbp-1005Ch]
  __int16 v10; // [rsp+3Eh] [rbp-10052h]
  unsigned __int64 v11; // [rsp+10088h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a2 + 56) + 14 > (unsigned int)&loc_10055 )
    return 1LL;
  v3 = (unsigned __int8)(**(_BYTE **)(a2 + 48) >> 4);
  if ( v3 == 4 )
  {
    v4 = sub_E629(a1, a2, (__int64)&v8, &v6);
    if ( v4 <= 1 )
      return (unsigned int)v4;
  }
  else if ( v3 == 6 )
  {
    v5 = sub_E86B(a1, a2, (__int64)&v8, &v6);
    if ( v5 <= 1 )
      return (unsigned int)v5;
  }
  else
  {
    g_assertion_message_expr("Slirp", "../src/slirp.c", 958LL, "if_encap", 0LL);
  }
  *(_DWORD *)&v8 = v6;
  v9 = v7;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " src = %02x:%02x:%02x:%02x:%02x:%02x");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " dst = %02x:%02x:%02x:%02x:%02x:%02x");
  memcpy(&v10, *(const void **)(a2 + 48), *(signed int *)(a2 + 56));
  sub_F245(a1, (__int64)&v8, *(_DWORD *)(a2 + 56) + 14);
  return 1LL;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000EC37) ----------------------------------------------------
signed __int64 __fastcall slirp_remove_hostfwd(__int64 a1, int a2, int a3, uint16_t a4)
{
  __int64 *v4; // rax
  int v6; // [rsp+10h] [rbp-50h]
  socklen_t len; // [rsp+28h] [rbp-38h]
  int v8; // [rsp+2Ch] [rbp-34h]
  __int64 i; // [rsp+30h] [rbp-30h]
  __int64 *v10; // [rsp+38h] [rbp-28h]
  struct sockaddr addr; // [rsp+40h] [rbp-20h]
  unsigned __int64 v12; // [rsp+58h] [rbp-8h]

  v6 = a3;
  v12 = __readfsqword(0x28u);
  if ( a2 )
    v4 = (__int64 *)(a1 + 888);
  else
    v4 = (__int64 *)(a1 + 448);
  v10 = v4;
  v8 = htons(a4);
  for ( i = *v10; (__int64 *)i != v10; i = *(_QWORD *)i )
  {
    len = 16;
    if ( *(_DWORD *)(i + 332) & 0x1000
      && !getsockname(*(_DWORD *)(i + 16), &addr, &len)
      && *(_DWORD *)&addr.sa_data[2] == v6
      && v8 == *(unsigned __int16 *)addr.sa_data )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(i + 40) + 5992LL) + 56LL))(
        *(unsigned int *)(i + 16),
        *(_QWORD *)(*(_QWORD *)(i + 40) + 6000LL));
      close(*(_DWORD *)(i + 16));
      sub_F77A(i);
      return 0LL;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000000ED74) ----------------------------------------------------
signed __int64 __fastcall slirp_add_hostfwd(__int64 a1, int a2, int a3, uint16_t a4, in_addr_t a5, uint16_t a6)
{
  __int16 v6; // r12
  __int16 v7; // ax
  uint16_t v9; // r12
  uint16_t v10; // ax
  in_addr_t v11; // [rsp+8h] [rbp-28h]
  uint16_t v12; // [rsp+Ch] [rbp-24h]
  int v13; // [rsp+10h] [rbp-20h]

  v13 = a3;
  v12 = a4;
  v11 = a5;
  if ( !a5 )
    v11 = *(_DWORD *)(a1 + 60);
  if ( a2 )
  {
    v6 = htons(a6);
    v7 = htons(v12);
    if ( !sub_1B58F(a1, v13, v7, v11, v6, 4096) )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = htons(a6);
    v10 = htons(v12);
    if ( !sub_116C0(a1, (struct in_addr)v13, v10, v11, v9, 4096) )
      return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (000000000000EE4D) ----------------------------------------------------
signed __int64 __fastcall sub_EE4D(__int64 a1, uint32_t *a2, int a3)
{
  int v3; // ebx
  int v5; // [rsp+Ch] [rbp-34h]
  __int64 i; // [rsp+28h] [rbp-18h]

  v5 = a3;
  if ( !*a2 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    *a2 = htonl(0x204u) & ~*(_DWORD *)(a1 + 16) | v3;
  }
  if ( (*(_DWORD *)(a1 + 16) & *a2) != *(_DWORD *)(a1 + 12)
    || *a2 == *(_DWORD *)(a1 + 20)
    || *a2 == *(_DWORD *)(a1 + 64) )
  {
    return 0LL;
  }
  for ( i = *(_QWORD *)(a1 + 128); i; i = *(_QWORD *)(i + 32) )
  {
    if ( v5 == *(_DWORD *)(i + 20) && *a2 == *(_DWORD *)(i + 16) )
      return 0LL;
  }
  return 1LL;
}

//----- (000000000000EF2A) ----------------------------------------------------
signed __int64 __fastcall slirp_add_exec(__int64 a1, __int64 a2, uint32_t *a3, int a4)
{
  uint16_t v5; // ax
  uint16_t v6; // [rsp+4h] [rbp-1Ch]
  int *v7; // [rsp+8h] [rbp-18h]

  v7 = (int *)a3;
  v6 = a4;
  if ( (unsigned __int8)sub_EE4D(a1, a3, a4) != 1 )
    return 0xFFFFFFFFLL;
  v5 = htons(v6);
  sub_AC26((__int64 *)(a1 + 128), a2, *v7, v5);
  return 0LL;
}

//----- (000000000000EF99) ----------------------------------------------------
signed __int64 __fastcall slirp_add_guestfwd(__int64 a1, __int64 a2, __int64 a3, uint32_t *a4, int a5)
{
  uint16_t v6; // ax
  uint16_t v7; // [rsp+Ch] [rbp-24h]
  int *v8; // [rsp+10h] [rbp-20h]
  __int64 v9; // [rsp+18h] [rbp-18h]

  v9 = a3;
  v8 = (int *)a4;
  v7 = a5;
  if ( (unsigned __int8)sub_EE4D(a1, a4, a5) != 1 )
    return 0xFFFFFFFFLL;
  v6 = htons(v7);
  sub_ABAD((__int64 *)(a1 + 128), a2, v9, *v8, v6);
  return 0LL;
}

//----- (000000000000F014) ----------------------------------------------------
ssize_t __fastcall sub_F014(__int64 a1, const void *a2, size_t a3, int a4)
{
  ssize_t result; // rax
  size_t n; // [rsp+8h] [rbp-18h]

  n = a3;
  if ( *(_DWORD *)(a1 + 16) == -1 && *(_QWORD *)(a1 + 24) )
  {
    (**(void (__fastcall ***)(const void *, size_t, _QWORD))(a1 + 24))(a2, a3, *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL));
    result = n;
  }
  else if ( *(_DWORD *)(a1 + 16) == -1 )
  {
    *__errno_location() = 9;
    result = -1LL;
  }
  else
  {
    result = send(*(_DWORD *)(a1 + 16), a2, a3, a4);
  }
  return result;
}

//----- (000000000000F0A9) ----------------------------------------------------
__int64 *__fastcall sub_F0A9(__int64 a1, int a2, int a3)
{
  int v4; // [rsp+0h] [rbp-20h]
  __int64 *i; // [rsp+18h] [rbp-8h]

  v4 = a3;
  for ( i = *(__int64 **)(a1 + 448); i != (__int64 *)(a1 + 448); i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 19) == a2 && v4 == htons(*((_WORD *)i + 37)) )
      return i;
  }
  return 0LL;
}

//----- (000000000000F11C) ----------------------------------------------------
__int64 __fastcall slirp_socket_can_recv(__int64 a1, int a2, int a3)
{
  __int64 *v4; // [rsp+18h] [rbp-38h]
  char v5; // [rsp+20h] [rbp-30h]
  unsigned __int64 v6; // [rsp+48h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v4 = sub_F0A9(a1, a2, a3);
  if ( !v4 || *((_DWORD *)v4 + 83) & 1 )
    return 0LL;
  if ( (*((_DWORD *)v4 + 83) & 0xC) == 4 && *((_DWORD *)v4 + 98) < *((_DWORD *)v4 + 99) >> 1 )
    return sub_F8A6((__int64)v4, &v5, 0LL);
  return 0LL;
}

//----- (000000000000F1D5) ----------------------------------------------------
__int64 __fastcall slirp_socket_recv(__int64 a1, int a2, int a3, char *a4, int a5)
{
  __int64 result; // rax
  int v6; // [rsp+4h] [rbp-2Ch]
  char *v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  v7 = a4;
  v6 = a5;
  result = (__int64)sub_F0A9(a1, a2, a3);
  v8 = result;
  if ( result )
  {
    result = sub_10030(result, v7, v6);
    if ( (signed int)result > 0 )
      result = sub_15563(*(_QWORD *)(v8 + 336));
  }
  return result;
}

//----- (000000000000F245) ----------------------------------------------------
__int64 __fastcall sub_F245(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // [rsp+8h] [rbp-28h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v4 = a3;
  v5 = (**(__int64 (__fastcall ***)(__int64, unsigned __int64, _QWORD))(a1 + 5992))(a2, a3, *(_QWORD *)(a1 + 6000));
  if ( v5 < 0 )
    return g_log("Slirp", 8LL, "Failed to send packet, ret: %ld");
  result = v5;
  if ( v4 > v5 )
  {
    result = unk_2250E0 & 4;
    if ( unk_2250E0 & 4 )
      result = g_log("Slirp", 128LL, "send_packet() didn't send all data: %ld < %lu");
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000F2F8) ----------------------------------------------------
int __fastcall sub_F2F8(int a1)
{
  int optval; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  optval = 1;
  return setsockopt(a1, 1, 2, &optval, 4u);
}

//----- (000000000000F350) ----------------------------------------------------
bool __fastcall sub_F350(const void *a1, const void *a2)
{
  return memcmp(a1, a2, 0x10uLL) == 0;
}

//----- (000000000000F37F) ----------------------------------------------------
bool __fastcall sub_F37F(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v6; // [rsp+Ch] [rbp-14h]

  v6 = a3;
  v3 = a3;
  v4 = a3 + 7;
  if ( v3 < 0 )
    v3 = v4;
  if ( memcmp(a1, a2, v3 >> 3) )
    return 0;
  if ( v6 & 7 )
    return (signed int)a1[v6 / 8] >> (8 - v6 % 8) == (signed int)a2[v6 / 8] >> (8 - v6 % 8);
  return 1;
}

//----- (000000000000F44C) ----------------------------------------------------
__int64 __fastcall sub_F44C(unsigned __int16 *a1, __int64 a2)
{
  int v3; // eax

  if ( *a1 != *(_WORD *)a2 )
    return 0LL;
  v3 = *a1;
  if ( v3 == 2 )
    return *((_DWORD *)a1 + 1) == *(_DWORD *)(a2 + 4) && a1[1] == *(_WORD *)(a2 + 2);
  if ( v3 == 10 )
    return sub_F350(a1 + 4, (const void *)(a2 + 8)) && a1[1] == *(_WORD *)(a2 + 2);
  return g_assertion_message_expr("Slirp", "../src/socket.h", 122LL, "sockaddr_equal", 0LL);
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000F550) ----------------------------------------------------
__int64 __fastcall sub_F550(unsigned __int16 *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( v1 == 2 )
    return 16LL;
  if ( v1 == 10 )
    return 28LL;
  return g_assertion_message_expr("Slirp", "../src/socket.h", 136LL, "sockaddr_size", 0LL);
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000F5A7) ----------------------------------------------------
unsigned __int16 *__fastcall sub_F5A7(unsigned __int16 **a1, unsigned __int16 *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // [rsp+0h] [rbp-30h]
  __int64 v6; // [rsp+8h] [rbp-28h]
  unsigned __int16 *v7; // [rsp+28h] [rbp-8h]
  unsigned __int16 *i; // [rsp+28h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v7 = *a1;
  if ( *a1 != a2 && (unsigned int)sub_F44C(v7 + 100, a3) && (!v5 || (unsigned int)sub_F44C(v7 + 36, v5)) )
    return v7;
  for ( i = *(unsigned __int16 **)a2; i != a2; i = *(unsigned __int16 **)i )
  {
    if ( (unsigned int)sub_F44C(i + 100, v6) && (!v5 || (unsigned int)sub_F44C(i + 36, v5)) )
    {
      *a1 = i;
      return i;
    }
  }
  return 0LL;
}

//----- (000000000000F694) ----------------------------------------------------
void *__fastcall sub_F694(__int64 a1)
{
  void *s; // ST18_8

  s = (void *)g_malloc_n(1LL, 424LL);
  memset(s, 0, 0x1A8uLL);
  *((_DWORD *)s + 83) = 1;
  *((_DWORD *)s + 4) = -1;
  *((_QWORD *)s + 5) = a1;
  *((_DWORD *)s + 8) = -1;
  return s;
}
// 3000: using guessed type __int64 __fastcall g_malloc_n(_QWORD, _QWORD);

//----- (000000000000F6FF) ----------------------------------------------------
_QWORD *__fastcall sub_F6FF(__int64 a1, _QWORD *a2)
{
  _QWORD *result; // rax
  _QWORD *i; // [rsp+10h] [rbp-10h]
  _QWORD *j; // [rsp+18h] [rbp-8h]

  for ( i = (_QWORD *)*a2; ; i = (_QWORD *)*i )
  {
    result = i;
    if ( i == a2 )
      break;
    if ( a1 == i[5] )
    {
      i[5] = 0LL;
      for ( j = (_QWORD *)i[2]; j != i; j = (_QWORD *)j[2] )
        j[5] = 0LL;
    }
  }
  return result;
}

//----- (000000000000F77A) ----------------------------------------------------
__int64 __fastcall sub_F77A(__int64 a1)
{
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  v2 = *(_QWORD **)(a1 + 40);
  sub_F6FF(a1, v2 + 24);
  sub_F6FF(a1, v2 + 26);
  if ( a1 == v2[109] )
  {
    v2[109] = v2 + 56;
  }
  else if ( a1 == v2[164] )
  {
    v2[164] = v2 + 111;
  }
  else if ( a1 == v2[218] )
  {
    v2[218] = v2 + 165;
  }
  sub_A4F0(*(_QWORD *)(a1 + 48));
  if ( *(_QWORD *)a1 && *(_QWORD *)(a1 + 8) )
    sub_AB7F((_QWORD *)a1);
  if ( *(_QWORD *)(a1 + 336) )
    free(*(void **)(a1 + 336));
  return g_free(a1);
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);

//----- (000000000000F8A6) ----------------------------------------------------
__int64 __fastcall sub_F8A6(__int64 a1, _QWORD *a2, signed int *a3)
{
  signed int *v4; // [rsp+8h] [rbp-38h]
  signed int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]
  int v10; // [rsp+34h] [rbp-Ch]

  v4 = a3;
  v6 = *(_DWORD *)(a1 + 396) - *(_DWORD *)(a1 + 392);
  v8 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 336) + 32LL);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sopreprbuf...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( v6 <= 0 )
    return 0LL;
  *a2 = *(_QWORD *)(a1 + 400);
  a2[2] = 0LL;
  a2[3] = 0LL;
  if ( *(_QWORD *)(a1 + 400) >= *(_QWORD *)(a1 + 408) )
  {
    a2[1] = *(_QWORD *)(a1 + 416) + *(unsigned int *)(a1 + 396) - *(_QWORD *)(a1 + 400);
    if ( a2[1] > (unsigned __int64)v6 )
      a2[1] = v6;
    v7 = v6 - a2[1];
    if ( v7 )
    {
      a2[2] = *(_QWORD *)(a1 + 416);
      a2[3] = *(_QWORD *)(a1 + 408) - *(_QWORD *)(a1 + 416);
      if ( a2[3] > (unsigned __int64)v7 )
        a2[3] = v7;
      v9 = a2[1] + a2[3];
      if ( v9 <= v8 )
      {
        v5 = 2;
      }
      else
      {
        v10 = v9 % v8;
        if ( a2[3] <= (unsigned __int64)(v9 % v8) )
        {
          a2[1] -= (signed int)(v10 - a2[3]);
          v5 = 1;
        }
        else
        {
          a2[3] -= v10;
          v5 = 2;
        }
      }
    }
    else
    {
      if ( a2[1] > (unsigned __int64)v8 )
        a2[1] -= a2[1] % (unsigned __int64)v8;
      v5 = 1;
    }
  }
  else
  {
    a2[1] = *(_QWORD *)(a1 + 408) - *(_QWORD *)(a1 + 400);
    if ( a2[1] > (unsigned __int64)v6 )
      a2[1] = v6;
    if ( a2[1] > (unsigned __int64)v8 )
      a2[1] -= a2[1] % (unsigned __int64)v8;
    v5 = 1;
  }
  if ( v4 )
    *v4 = v5;
  return a2[1] + (v5 - 1) * a2[3];
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000000FC35) ----------------------------------------------------
signed __int64 __fastcall sub_FC35(__int64 a1)
{
  signed __int64 result; // rax
  int *v2; // rax
  int v3; // [rsp+10h] [rbp-F0h]
  int optval; // [rsp+14h] [rbp-ECh]
  socklen_t optlen; // [rsp+18h] [rbp-E8h]
  socklen_t len; // [rsp+1Ch] [rbp-E4h]
  int v7; // [rsp+20h] [rbp-E0h]
  int v8; // [rsp+24h] [rbp-DCh]
  __int64 v9; // [rsp+28h] [rbp-D8h]
  __int64 v10; // [rsp+30h] [rbp-D0h]
  struct sockaddr *addr; // [rsp+38h] [rbp-C8h]
  void *buf; // [rsp+40h] [rbp-C0h]
  size_t n; // [rsp+48h] [rbp-B8h]
  void *v14; // [rsp+50h] [rbp-B0h]
  size_t v15; // [rsp+58h] [rbp-A8h]
  char v16; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v17; // [rsp+E8h] [rbp-18h]

  v17 = __readfsqword(0x28u);
  v9 = a1 + 392;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "soread...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  v10 = sub_F8A6(a1, &buf, &v3);
  if ( !v10 )
    __assert_fail("buf_len != 0", "../src/socket.c", 0xB7u, "soread");
  v7 = recv(*(_DWORD *)(a1 + 16), buf, n, 0);
  if ( v7 > 0 )
  {
    if ( v3 == 2 && v7 == n )
    {
      v8 = recv(*(_DWORD *)(a1 + 16), v14, v15, 0);
      if ( v8 > 0 )
        v7 += v8;
    }
    if ( unk_2250E0 & 2 )
      g_log("Slirp", 128LL, " ... read nn = %d bytes");
    *(_DWORD *)v9 += v7;
    *(_QWORD *)(v9 + 8) += v7;
    if ( *(_QWORD *)(v9 + 8) >= *(_QWORD *)(v9 + 24) + (unsigned __int64)*(unsigned int *)(v9 + 4) )
      *(_QWORD *)(v9 + 8) -= *(unsigned int *)(v9 + 4);
    result = (unsigned int)v7;
  }
  else if ( v7 >= 0 || *__errno_location() != 4 && *__errno_location() != 11 )
  {
    optlen = 4;
    addr = (struct sockaddr *)&v16;
    len = 128;
    optval = *__errno_location();
    if ( !v7 )
    {
      if ( getpeername(*(_DWORD *)(a1 + 16), addr, &len) >= 0 )
        getsockopt(*(_DWORD *)(a1 + 16), 1, 4, &optval, &optlen);
      else
        optval = *__errno_location();
    }
    if ( unk_2250E0 & 2 )
    {
      v2 = __errno_location();
      strerror(*v2);
      __errno_location();
      g_log("Slirp", 128LL, " --- soread() disconnected, nn = %d, errno = %d-%s");
    }
    sub_11B34(a1);
    if ( optval != 104 && optval != 111 && optval != 107 && optval != 32 )
      sub_17227(*(_QWORD *)(a1 + 336));
    else
      sub_16FC0(*(_QWORD *)(a1 + 336));
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = 0LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000010030) ----------------------------------------------------
signed __int64 __fastcall sub_10030(__int64 a1, char *a2, int a3)
{
  int v3; // eax
  signed __int64 result; // rax
  int v5; // [rsp+Ch] [rbp-64h]
  char v6; // [rsp+2Ch] [rbp-44h]
  int v7; // [rsp+30h] [rbp-40h]
  int v8; // [rsp+34h] [rbp-3Ch]
  __int64 v9; // [rsp+38h] [rbp-38h]
  void *dest; // [rsp+40h] [rbp-30h]
  unsigned __int64 v11; // [rsp+48h] [rbp-28h]
  void *v12; // [rsp+50h] [rbp-20h]
  unsigned __int64 v13; // [rsp+68h] [rbp-8h]

  v5 = a3;
  v13 = __readfsqword(0x28u);
  v7 = a3;
  v9 = a1 + 392;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "soreadbuf...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( v5 <= 0 )
    __assert_fail("size > 0", "../src/socket.c", 0x102u, "soreadbuf");
  if ( sub_F8A6(a1, &dest, (signed int *)&v6) < (unsigned __int64)v5 )
  {
    sub_11B34(a1);
    sub_17227(*(_QWORD *)(a1 + 336));
    g_log("Slirp", 8LL, "soreadbuf buffer too small");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v3 = v11;
    if ( v7 <= v11 )
      v3 = v7;
    v8 = v3;
    memcpy(dest, a2, v3);
    v7 -= v8;
    if ( v7 )
      memcpy(v12, &a2[v8], v7);
    *(_DWORD *)v9 += v5;
    *(_QWORD *)(v9 + 8) += v5;
    if ( *(_QWORD *)(v9 + 8) >= *(_QWORD *)(v9 + 24) + (unsigned __int64)*(unsigned int *)(v9 + 4) )
      *(_QWORD *)(v9 + 8) -= *(unsigned int *)(v9 + 4);
    result = (unsigned int)v5;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000010238) ----------------------------------------------------
__int64 __fastcall sub_10238(__int64 a1)
{
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 336);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sorecvoob...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  v2 = sub_FC35(a1);
  if ( (signed int)v2 > 0 )
  {
    *(_DWORD *)(v3 + 128) = *(_DWORD *)(a1 + 392) + *(_DWORD *)(v3 + 120);
    *(_BYTE *)(v3 + 34) = 1;
    sub_15563(v3);
    *(_BYTE *)(v3 + 34) = 0;
  }
  return v2;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000010307) ----------------------------------------------------
__int64 __fastcall sub_10307(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-824h]
  int v3; // [rsp+1Ch] [rbp-824h]
  int v4; // [rsp+20h] [rbp-820h]
  unsigned int v5; // [rsp+24h] [rbp-81Ch]
  unsigned int v6; // [rsp+24h] [rbp-81Ch]
  char dest[2056]; // [rsp+30h] [rbp-810h]
  unsigned __int64 v8; // [rsp+838h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sosendoob...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " sb->sb_cc = %d");
  if ( *(_DWORD *)(a1 + 64) > 0x800u )
    *(_DWORD *)(a1 + 64) = 2048;
  if ( *(_QWORD *)(a1 + 376) >= *(_QWORD *)(a1 + 368) )
  {
    v5 = *(_DWORD *)(a1 + 64);
    v4 = *(_DWORD *)(a1 + 384) + *(_DWORD *)(a1 + 364) - *(_DWORD *)(a1 + 376);
    if ( v5 < v4 )
      v4 = *(_DWORD *)(a1 + 64);
    memcpy(dest, *(const void **)(a1 + 376), v4);
    v6 = v5 - v4;
    if ( v6 )
    {
      v3 = *(_DWORD *)(a1 + 368) - *(_DWORD *)(a1 + 384);
      if ( v6 < v3 )
        v3 = v6;
      memcpy(&dest[v4], *(const void **)(a1 + 384), v3);
      v4 += v3;
    }
    v2 = sub_F014(a1, dest, v4, 1);
  }
  else
  {
    v2 = sub_F014(a1, *(const void **)(a1 + 376), *(unsigned int *)(a1 + 64), 1);
  }
  if ( (v2 & 0x80000000) != 0 )
    return v2;
  *(_DWORD *)(a1 + 64) -= v2;
  if ( unk_2250E0 & 2 )
    g_log("Slirp", 128LL, " ---2 sent %d bytes urgent data, %d urgent bytes left");
  *(_DWORD *)(a1 + 360) -= v2;
  *(_QWORD *)(a1 + 376) += (signed int)v2;
  if ( *(_QWORD *)(a1 + 376) >= *(_QWORD *)(a1 + 384) + (unsigned __int64)*(unsigned int *)(a1 + 364) )
    *(_QWORD *)(a1 + 376) -= *(unsigned int *)(a1 + 364);
  return v2;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);
// 10307: using guessed type char dest[2056];

//----- (00000000000106A3) ----------------------------------------------------
signed __int64 __fastcall sub_106A3(__int64 a1)
{
  unsigned int v1; // ST20_4
  signed int v3; // [rsp+14h] [rbp-4Ch]
  signed int v4; // [rsp+18h] [rbp-48h]
  int v5; // [rsp+1Ch] [rbp-44h]
  int v6; // [rsp+1Ch] [rbp-44h]
  int v7; // [rsp+24h] [rbp-3Ch]
  _DWORD *v8; // [rsp+28h] [rbp-38h]
  size_t v9; // [rsp+38h] [rbp-28h]
  const void *v10; // [rsp+40h] [rbp-20h]
  size_t v11; // [rsp+48h] [rbp-18h]

  v8 = (_DWORD *)(a1 + 360);
  v5 = *(_DWORD *)(a1 + 360);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sowrite...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( *(_DWORD *)(a1 + 64) )
  {
    v1 = *(_DWORD *)(a1 + 64);
    if ( v1 > (unsigned int)sub_10307(a1) )
      goto LABEL_37;
    if ( !*v8 )
      return 0LL;
  }
  v10 = 0LL;
  v11 = 0LL;
  if ( *(_QWORD *)(a1 + 376) >= *(_QWORD *)(a1 + 368) )
  {
    v9 = *(_QWORD *)(a1 + 384) + *(unsigned int *)(a1 + 364) - *(_QWORD *)(a1 + 376);
    if ( v9 > v5 )
      v9 = v5;
    v6 = v5 - v9;
    if ( v6 )
    {
      v10 = *(const void **)(a1 + 384);
      v11 = *(_QWORD *)(a1 + 368) - *(_QWORD *)(a1 + 384);
      if ( v11 > v6 )
        v11 = v6;
      v3 = 2;
    }
    else
    {
      v3 = 1;
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 368) - *(_QWORD *)(a1 + 376);
    if ( v9 > v5 )
      v9 = v5;
    v3 = 1;
  }
  v4 = sub_F014(a1, *(const void **)(a1 + 376), v9, 0);
  if ( v4 < 0 && (*__errno_location() == 11 || *__errno_location() == 4) )
    return 0LL;
  if ( v4 > 0 )
  {
    if ( v3 == 2 && v4 == v9 )
    {
      v7 = sub_F014(a1, v10, v11, 0);
      if ( v7 > 0 )
        v4 += v7;
    }
    if ( unk_2250E0 & 2 )
      g_log("Slirp", 128LL, "  ... wrote nn = %d bytes");
    *v8 -= v4;
    *(_QWORD *)(a1 + 376) += v4;
    if ( *(_QWORD *)(a1 + 376) >= *(_QWORD *)(a1 + 384) + (unsigned __int64)*(unsigned int *)(a1 + 364) )
      *(_QWORD *)(a1 + 376) -= *(unsigned int *)(a1 + 364);
    if ( *(_DWORD *)(a1 + 332) & 0x40 )
    {
      if ( !*v8 )
        sub_11BE0(a1);
    }
    return (unsigned int)v4;
  }
LABEL_37:
  if ( unk_2250E0 & 2 )
  {
    __errno_location();
    g_log("Slirp", 128LL, " --- sowrite disconnected, so->so_state = %x, errno = %d");
  }
  sub_11BE0(a1);
  sub_17227(*(_QWORD *)(a1 + 336));
  return 0xFFFFFFFFLL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000010A5A) ----------------------------------------------------
unsigned __int64 __fastcall sub_10A5A(__int64 a1)
{
  int *v1; // rax
  int *v2; // rax
  int *v3; // rax
  int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // rdx
  int v7; // eax
  int *v8; // rax
  int v9; // eax
  int *v10; // rax
  __int16 v11; // bx
  int v12; // edx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rdx
  int v21; // eax
  char v23; // [rsp+16h] [rbp-2BAh]
  char v24; // [rsp+17h] [rbp-2B9h]
  char v25; // [rsp+17h] [rbp-2B9h]
  socklen_t addr_len; // [rsp+18h] [rbp-2B8h]
  int v27; // [rsp+1Ch] [rbp-2B4h]
  int v28; // [rsp+20h] [rbp-2B0h]
  int v29; // [rsp+24h] [rbp-2ACh]
  __int64 v30; // [rsp+28h] [rbp-2A8h]
  struct sockaddr addr; // [rsp+30h] [rbp-2A0h]
  __int64 v32; // [rsp+40h] [rbp-290h]
  __int64 v33; // [rsp+48h] [rbp-288h]
  __int64 v34; // [rsp+50h] [rbp-280h]
  __int64 v35; // [rsp+58h] [rbp-278h]
  __int64 v36; // [rsp+60h] [rbp-270h]
  __int64 v37; // [rsp+68h] [rbp-268h]
  __int64 v38; // [rsp+70h] [rbp-260h]
  __int64 v39; // [rsp+78h] [rbp-258h]
  __int64 v40; // [rsp+80h] [rbp-250h]
  __int64 v41; // [rsp+88h] [rbp-248h]
  __int64 v42; // [rsp+90h] [rbp-240h]
  __int64 v43; // [rsp+98h] [rbp-238h]
  __int64 v44; // [rsp+A0h] [rbp-230h]
  __int64 v45; // [rsp+A8h] [rbp-228h]
  struct sockaddr v46; // [rsp+B0h] [rbp-220h]
  __int64 v47; // [rsp+C0h] [rbp-210h]
  __int64 v48; // [rsp+C8h] [rbp-208h]
  __int64 v49; // [rsp+D0h] [rbp-200h]
  __int64 v50; // [rsp+D8h] [rbp-1F8h]
  __int64 v51; // [rsp+E0h] [rbp-1F0h]
  __int64 v52; // [rsp+E8h] [rbp-1E8h]
  __int64 v53; // [rsp+F0h] [rbp-1E0h]
  __int64 v54; // [rsp+F8h] [rbp-1D8h]
  __int64 v55; // [rsp+100h] [rbp-1D0h]
  __int64 v56; // [rsp+108h] [rbp-1C8h]
  __int64 v57; // [rsp+110h] [rbp-1C0h]
  __int64 v58; // [rsp+118h] [rbp-1B8h]
  __int64 v59; // [rsp+120h] [rbp-1B0h]
  __int64 v60; // [rsp+128h] [rbp-1A8h]
  __int64 v61; // [rsp+130h] [rbp-1A0h]
  __int64 v62; // [rsp+138h] [rbp-198h]
  __int64 v63; // [rsp+140h] [rbp-190h]
  __int64 v64; // [rsp+148h] [rbp-188h]
  __int64 v65; // [rsp+150h] [rbp-180h]
  __int64 v66; // [rsp+158h] [rbp-178h]
  __int64 v67; // [rsp+160h] [rbp-170h]
  __int64 v68; // [rsp+168h] [rbp-168h]
  __int64 v69; // [rsp+170h] [rbp-160h]
  __int64 v70; // [rsp+178h] [rbp-158h]
  __int64 v71; // [rsp+180h] [rbp-150h]
  __int64 v72; // [rsp+188h] [rbp-148h]
  __int64 v73; // [rsp+190h] [rbp-140h]
  __int64 v74; // [rsp+198h] [rbp-138h]
  __int64 v75; // [rsp+1A0h] [rbp-130h]
  __int64 v76; // [rsp+1A8h] [rbp-128h]
  char buf; // [rsp+1B0h] [rbp-120h]
  unsigned __int64 v78; // [rsp+2B8h] [rbp-18h]

  v78 = __readfsqword(0x28u);
  addr_len = 128;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sorecvfrom...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( *(_BYTE *)(a1 + 330) == 1 )
  {
    v29 = recvfrom(*(_DWORD *)(a1 + 16), &buf, 0x100uLL, 0, &addr, &addr_len);
    if ( v29 != -1 && v29 )
    {
      sub_8F3F(*(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 48) = 0LL;
    }
    else
    {
      v23 = 3;
      if ( *__errno_location() == 113 )
      {
        v23 = 1;
      }
      else if ( *__errno_location() == 101 )
      {
        v23 = 0;
      }
      if ( unk_2250E0 & 2 )
      {
        v1 = __errno_location();
        strerror(*v1);
        __errno_location();
        g_log("Slirp", 128LL, " udp icmp rx errno = %d-%s");
      }
      v2 = __errno_location();
      strerror(*v2);
      sub_8B39(*(_QWORD *)(a1 + 48), 3, v23, 0);
    }
    sub_1B3C9(a1);
  }
  else if ( ioctl(*(_DWORD *)(a1 + 16), 0x541BuLL, &v27) )
  {
    if ( unk_2250E0 & 2 )
    {
      v3 = __errno_location();
      strerror(*v3);
      __errno_location();
      g_log("Slirp", 128LL, " ioctlsocket errno = %d-%s\n");
    }
  }
  else if ( v27 )
  {
    v30 = sub_A39A(*(_QWORD *)(a1 + 40));
    if ( v30 )
    {
      v4 = *(unsigned __int16 *)(a1 + 72);
      if ( v4 == 2 )
      {
        *(_QWORD *)(v30 + 48) += 44LL;
      }
      else if ( v4 == 10 )
      {
        *(_QWORD *)(v30 + 48) += 64LL;
      }
      else
      {
        g_assertion_message_expr("Slirp", "../src/socket.c", 551LL, "sorecvfrom", 0LL);
      }
      if ( *(_DWORD *)(v30 + 32) & 1 )
        v5 = *(_QWORD *)(v30 + 88) + *(signed int *)(v30 + 36);
      else
        v5 = v30 + 96 + *(signed int *)(v30 + 36);
      v28 = v5 - *(_QWORD *)(v30 + 48) - *(_DWORD *)(v30 + 56);
      if ( v28 < v27 )
      {
        v27 += *(_DWORD *)(v30 + 56) + *(unsigned __int64 *)(v30 + 48) - (v30 + 96) + 1;
        sub_A70B(v30, v27);
        if ( *(_DWORD *)(v30 + 32) & 1 )
          v6 = *(_QWORD *)(v30 + 88) + *(signed int *)(v30 + 36);
        else
          v6 = v30 + 96 + *(signed int *)(v30 + 36);
        v28 = v6 - *(_QWORD *)(v30 + 48) - *(_DWORD *)(v30 + 56);
      }
      v7 = recvfrom(*(_DWORD *)(a1 + 16), *(void **)(v30 + 48), v28, 0, &addr, &addr_len);
      *(_DWORD *)(v30 + 56) = v7;
      if ( unk_2250E0 & 2 )
      {
        v8 = __errno_location();
        strerror(*v8);
        __errno_location();
        g_log("Slirp", 128LL, " did recvfrom %d, errno = %d-%s");
      }
      if ( *(_DWORD *)(v30 + 56) >= 0 )
      {
        if ( *(_DWORD *)(a1 + 344) )
        {
          v11 = *(_WORD *)(a1 + 74);
          if ( v11 == htons(0x35u) )
            v12 = unk_2250E8 + 10000;
          else
            v12 = unk_2250E8 + 240000;
          *(_DWORD *)(a1 + 344) = v12;
        }
        v46 = addr;
        v47 = v32;
        v48 = v33;
        v49 = v34;
        v50 = v35;
        v51 = v36;
        v52 = v37;
        v53 = v38;
        v54 = v39;
        v55 = v40;
        v56 = v41;
        v57 = v42;
        v58 = v43;
        v59 = v44;
        v60 = v45;
        sub_11E85(a1, &v46.sa_family);
        v13 = *(_QWORD *)(a1 + 208);
        v61 = *(_QWORD *)(a1 + 200);
        v62 = v13;
        v14 = *(_QWORD *)(a1 + 224);
        v63 = *(_QWORD *)(a1 + 216);
        v64 = v14;
        v15 = *(_QWORD *)(a1 + 240);
        v65 = *(_QWORD *)(a1 + 232);
        v66 = v15;
        v16 = *(_QWORD *)(a1 + 256);
        v67 = *(_QWORD *)(a1 + 248);
        v68 = v16;
        v17 = *(_QWORD *)(a1 + 272);
        v69 = *(_QWORD *)(a1 + 264);
        v70 = v17;
        v18 = *(_QWORD *)(a1 + 288);
        v71 = *(_QWORD *)(a1 + 280);
        v72 = v18;
        v19 = *(_QWORD *)(a1 + 304);
        v73 = *(_QWORD *)(a1 + 296);
        v74 = v19;
        v20 = *(_QWORD *)(a1 + 320);
        v75 = *(_QWORD *)(a1 + 312);
        v76 = v20;
        v21 = *(unsigned __int16 *)(a1 + 72);
        if ( v21 == 2 )
        {
          sub_1B11D(a1, v30, (__int64)&v46, (__int64)&v61, *(_BYTE *)(a1 + 328));
        }
        else if ( v21 == 10 )
        {
          sub_1BF57(a1, v30, (__int64)&v46, (__int64)&v61);
        }
        else
        {
          g_assertion_message_expr("Slirp", "../src/socket.c", 639LL, "sorecvfrom", 0LL);
        }
      }
      else
      {
        v9 = *(unsigned __int16 *)(a1 + 200);
        if ( v9 == 2 )
        {
          v24 = 3;
          if ( *__errno_location() == 113 )
          {
            v24 = 1;
          }
          else if ( *__errno_location() == 101 )
          {
            v24 = 0;
          }
          if ( unk_2250E0 & 2 )
            g_log("Slirp", 128LL, " rx error, tx icmp ICMP_UNREACH:%i");
          v10 = __errno_location();
          strerror(*v10);
          sub_8B39(*(_QWORD *)(a1 + 48), 3, v24, 0);
        }
        else if ( v9 == 10 )
        {
          v25 = 4;
          if ( *__errno_location() == 113 )
          {
            v25 = 3;
          }
          else if ( *__errno_location() == 101 )
          {
            v25 = 0;
          }
          if ( unk_2250E0 & 2 )
            g_log("Slirp", 128LL, " rx error, tx icmp6 ICMP_UNREACH:%i");
          sub_6903(*(_QWORD *)(a1 + 48), 1u, v25);
        }
        else
        {
          g_assertion_message_expr("Slirp", "../src/socket.c", 603LL, "sorecvfrom", 0LL);
        }
        sub_A4F0(v30);
      }
    }
  }
  return __readfsqword(0x28u) ^ v78;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000011417) ----------------------------------------------------
signed __int64 __fastcall sub_11417(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rdx
  socklen_t v11; // eax
  struct sockaddr addr; // [rsp+20h] [rbp-90h]
  __int64 v13; // [rsp+30h] [rbp-80h]
  __int64 v14; // [rsp+38h] [rbp-78h]
  __int64 v15; // [rsp+40h] [rbp-70h]
  __int64 v16; // [rsp+48h] [rbp-68h]
  __int64 v17; // [rsp+50h] [rbp-60h]
  __int64 v18; // [rsp+58h] [rbp-58h]
  __int64 v19; // [rsp+60h] [rbp-50h]
  __int64 v20; // [rsp+68h] [rbp-48h]
  __int64 v21; // [rsp+70h] [rbp-40h]
  __int64 v22; // [rsp+78h] [rbp-38h]
  __int64 v23; // [rsp+80h] [rbp-30h]
  __int64 v24; // [rsp+88h] [rbp-28h]
  __int64 v25; // [rsp+90h] [rbp-20h]
  __int64 v26; // [rsp+98h] [rbp-18h]
  unsigned __int64 v27; // [rsp+A8h] [rbp-8h]

  v27 = __readfsqword(0x28u);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "sosendto...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  v2 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)&addr.sa_family = *(_QWORD *)(a1 + 72);
  *(_QWORD *)&addr.sa_data[6] = v2;
  v3 = *(_QWORD *)(a1 + 96);
  v13 = *(_QWORD *)(a1 + 88);
  v14 = v3;
  v4 = *(_QWORD *)(a1 + 112);
  v15 = *(_QWORD *)(a1 + 104);
  v16 = v4;
  v5 = *(_QWORD *)(a1 + 128);
  v17 = *(_QWORD *)(a1 + 120);
  v18 = v5;
  v6 = *(_QWORD *)(a1 + 144);
  v19 = *(_QWORD *)(a1 + 136);
  v20 = v6;
  v7 = *(_QWORD *)(a1 + 160);
  v21 = *(_QWORD *)(a1 + 152);
  v22 = v7;
  v8 = *(_QWORD *)(a1 + 176);
  v23 = *(_QWORD *)(a1 + 168);
  v24 = v8;
  v9 = *(_QWORD *)(a1 + 192);
  v25 = *(_QWORD *)(a1 + 184);
  v26 = v9;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " sendto()ing)...");
  if ( (signed int)sub_11CD0(a1, &addr.sa_family) < 0 )
    return 0xFFFFFFFFLL;
  v11 = sub_F550(&addr.sa_family);
  if ( (signed int)sendto(*(_DWORD *)(a1 + 16), *(const void **)(a2 + 48), *(signed int *)(a2 + 56), 0, &addr, v11) < 0 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 344) )
    *(_DWORD *)(a1 + 344) = unk_2250E8 + 240000;
  *(_DWORD *)(a1 + 332) &= 0xF000u;
  *(_DWORD *)(a1 + 332) |= 4u;
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000116C0) ----------------------------------------------------
struct in_addr *__fastcall sub_116C0(__int64 a1, struct in_addr a2, uint16_t a3, in_addr_t a4, uint16_t a5, int a6)
{
  struct in_addr *result; // rax
  int v7; // edx
  int v8; // [rsp+4h] [rbp-5Ch]
  uint16_t v9; // [rsp+8h] [rbp-58h]
  struct in_addr v10; // [rsp+Ch] [rbp-54h]
  uint16_t v11; // [rsp+10h] [rbp-50h]
  int optval; // [rsp+28h] [rbp-38h]
  size_t n; // [rsp+2Ch] [rbp-34h]
  int v14; // [rsp+34h] [rbp-2Ch]
  struct in_addr *v15; // [rsp+38h] [rbp-28h]
  __int16 s; // [rsp+40h] [rbp-20h]
  uint16_t v17; // [rsp+42h] [rbp-1Eh]
  in_addr_t v18; // [rsp+44h] [rbp-1Ch]
  unsigned __int64 v19; // [rsp+58h] [rbp-8h]

  v11 = a3;
  v10.s_addr = a4;
  v9 = a5;
  v8 = a6;
  v19 = __readfsqword(0x28u);
  optval = 1;
  LODWORD(n) = 16;
  memset(&s, 0, 0x10uLL);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_listen...");
  if ( unk_2250E0 & 1 )
  {
    inet_ntoa(a2);
    g_log("Slirp", 128LL, " haddr = %s");
  }
  if ( unk_2250E0 & 1 )
  {
    ntohs(v11);
    g_log("Slirp", 128LL, " hport = %d");
  }
  if ( unk_2250E0 & 1 )
  {
    inet_ntoa(v10);
    g_log("Slirp", 128LL, " laddr = %s");
  }
  if ( unk_2250E0 & 1 )
  {
    ntohs(v9);
    g_log("Slirp", 128LL, " lport = %d");
  }
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " flags = %x");
  v15 = (struct in_addr *)sub_F694(a1);
  *(_QWORD *)&v15[84].s_addr = sub_16EBD((__int64)v15);
  if ( *(_QWORD *)&v15[84].s_addr )
  {
    sub_AB4C(v15, (_QWORD *)(a1 + 448));
    if ( v8 & 0x200 )
      *(_WORD *)(*(_QWORD *)&v15[84].s_addr + 22LL) = 300;
    v15[83].s_addr &= 0xF000u;
    v7 = v8;
    BYTE1(v7) |= 1u;
    v15[83].s_addr |= v7;
    LOWORD(v15[50].s_addr) = 2;
    HIWORD(v15[50].s_addr) = v9;
    v15[51].s_addr = v10.s_addr;
    s = 2;
    v18 = a2.s_addr;
    v17 = v11;
    HIDWORD(n) = sub_1C25E(2, 1, 0);
    if ( (n & 0x8000000000000000LL) == 0LL
      && sub_F2F8(SHIDWORD(n)) >= 0
      && bind(SHIDWORD(n), (const struct sockaddr *)&s, 0x10u) >= 0
      && listen(SHIDWORD(n), 1) >= 0 )
    {
      setsockopt(SHIDWORD(n), 1, 10, &optval, 4u);
      optval = 1;
      setsockopt(SHIDWORD(n), 6, 1, &optval, 4u);
      getsockname(SHIDWORD(n), (struct sockaddr *)&s, (socklen_t *)&n);
      LOWORD(v15[18].s_addr) = 2;
      HIWORD(v15[18].s_addr) = v17;
      if ( v18 && v18 != unk_2250E4 )
        v15[19].s_addr = v18;
      else
        v15[19].s_addr = *(in_addr_t *)(a1 + 20);
      v15[4].s_addr = *(_DWORD *)((char *)&n + 4);
      result = v15;
    }
    else
    {
      v14 = *__errno_location();
      if ( (n & 0x8000000000000000LL) == 0LL )
        close(SHIDWORD(n));
      sub_F77A((__int64)v15);
      *__errno_location() = v14;
      result = 0LL;
    }
  }
  else
  {
    g_free(v15);
    result = 0LL;
  }
  return result;
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000011ABA) ----------------------------------------------------
__int64 __fastcall sub_11ABA(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 332) &= 0xFFFFFFA2;
  result = a1;
  *(_DWORD *)(result + 332) |= 2u;
  return result;
}

//----- (0000000000011AF7) ----------------------------------------------------
__int64 __fastcall sub_11AF7(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 332) &= 0xFFFFFFBC;
  result = a1;
  *(_DWORD *)(result + 332) |= 4u;
  return result;
}

//----- (0000000000011B34) ----------------------------------------------------
__int64 __fastcall sub_11B34(__int64 a1)
{
  int v1; // edx
  __int64 result; // rax

  if ( !(*(_DWORD *)(a1 + 332) & 1) )
    shutdown(*(_DWORD *)(a1 + 16), 0);
  *(_DWORD *)(a1 + 332) &= 0xFFFFFFFD;
  if ( *(_DWORD *)(a1 + 332) & 0x10 )
  {
    *(_DWORD *)(a1 + 332) &= 0xF000u;
    v1 = *(_DWORD *)(a1 + 332) | 1;
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 332) | 8;
  }
  result = a1;
  *(_DWORD *)(a1 + 332) = v1;
  return result;
}

//----- (0000000000011BE0) ----------------------------------------------------
__int64 __fastcall sub_11BE0(__int64 a1)
{
  int v1; // edx
  __int64 result; // rax

  if ( !(*(_DWORD *)(a1 + 332) & 1) )
    shutdown(*(_DWORD *)(a1 + 16), 1);
  *(_DWORD *)(a1 + 332) &= 0xFFFFFFFD;
  if ( *(_DWORD *)(a1 + 332) & 8 )
  {
    *(_DWORD *)(a1 + 332) &= 0xF000u;
    v1 = *(_DWORD *)(a1 + 332) | 1;
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 332) | 0x10;
  }
  result = a1;
  *(_DWORD *)(a1 + 332) = v1;
  return result;
}

//----- (0000000000011C8C) ----------------------------------------------------
__int64 __fastcall sub_11C8C(__int64 a1)
{
  __int64 result; // rax

  if ( !*(_DWORD *)(a1 + 360) )
    return sub_11BE0(a1);
  result = a1;
  *(_DWORD *)(a1 + 332) |= 0x40u;
  return result;
}

//----- (0000000000011CD0) ----------------------------------------------------
__int64 __fastcall sub_11CD0(__int64 a1, unsigned __int16 *a2)
{
  int v2; // eax
  __int64 v3; // rcx
  __int64 v4; // rdx
  int v6; // [rsp+18h] [rbp-28h]
  unsigned int v7; // [rsp+1Ch] [rbp-24h]
  __int64 v8; // [rsp+20h] [rbp-20h]
  unsigned __int16 *v9; // [rsp+28h] [rbp-18h]
  unsigned __int16 *v10; // [rsp+30h] [rbp-10h]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  v7 = 0;
  v8 = *(_QWORD *)(a1 + 40);
  v9 = a2;
  v10 = a2;
  v2 = *a2;
  if ( v2 == 2 )
  {
    if ( (*(_DWORD *)(v8 + 16) & *(_DWORD *)(a1 + 76)) == *(_DWORD *)(v8 + 12)
      && (*(_DWORD *)(a1 + 76) != *(_DWORD *)(v8 + 64) || (signed int)sub_CFD3(v9 + 2) < 0) )
    {
      if ( *(_BYTE *)(v8 + 144) )
      {
        v7 = -1;
        *__errno_location() = 1;
      }
      else
      {
        *((_DWORD *)v9 + 1) = unk_2250E4;
      }
    }
  }
  else if ( v2 == 10
         && sub_F37F((unsigned __int8 *)(a1 + 80), (unsigned __int8 *)(v8 + 24), *(unsigned __int8 *)(v8 + 40)) )
  {
    if ( sub_F350((const void *)(a1 + 80), (const void *)(v8 + 68))
      && (signed int)sub_D049(v10 + 4, (unsigned int *)&v6) >= 0 )
    {
      *((_DWORD *)v10 + 6) = v6;
    }
    else if ( *(_BYTE *)(v8 + 144) )
    {
      v7 = -1;
      *__errno_location() = 1;
    }
    else
    {
      v3 = (__int64)v10;
      v4 = *(_QWORD *)&in6addr_loopback.__u6_addr32[2];
      *((_QWORD *)v10 + 1) = *(_QWORD *)in6addr_loopback.__u6_addr8;
      *(_QWORD *)(v3 + 16) = v4;
    }
  }
  return v7;
}

//----- (0000000000011E85) ----------------------------------------------------
char __fastcall sub_11E85(__int64 a1, unsigned __int16 *a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v5; // [rsp+18h] [rbp-18h]

  v5 = *(_QWORD *)(a1 + 40);
  LODWORD(v2) = *a2;
  if ( (_DWORD)v2 == 2 )
  {
    LODWORD(v2) = *(_DWORD *)(v5 + 12);
    if ( (*(_DWORD *)(v5 + 16) & *(_DWORD *)(a1 + 76)) == (_DWORD)v2 )
    {
      if ( ~*(_DWORD *)(v5 + 16) == (~*(_DWORD *)(v5 + 16) & *(_DWORD *)(a1 + 76)) )
      {
        LOBYTE(v2) = (_BYTE)a2;
        *((_DWORD *)a2 + 1) = *(_DWORD *)(v5 + 20);
      }
      else if ( *((_DWORD *)a2 + 1) == unk_2250E4
             || (LODWORD(v2) = *(_DWORD *)(v5 + 20), *(_DWORD *)(a1 + 76) != (_DWORD)v2) )
      {
        LOBYTE(v2) = (_BYTE)a2;
        *((_DWORD *)a2 + 1) = *(_DWORD *)(a1 + 76);
      }
    }
  }
  else if ( (_DWORD)v2 == 10 )
  {
    LOBYTE(v2) = sub_F37F((unsigned __int8 *)(a1 + 80), (unsigned __int8 *)(v5 + 24), *(unsigned __int8 *)(v5 + 40));
    if ( (_BYTE)v2 )
    {
      if ( sub_F350(a2 + 4, &in6addr_loopback)
        || (LOBYTE(v2) = !sub_F350((const void *)(a1 + 80), (const void *)(v5 + 44)), (_BYTE)v2) )
      {
        v3 = *(_QWORD *)(a1 + 88);
        v2 = *(_QWORD *)(a1 + 80);
        *((_QWORD *)a2 + 1) = v2;
        *((_QWORD *)a2 + 2) = v3;
      }
    }
  }
  return v2;
}

//----- (0000000000011FE2) ----------------------------------------------------
char __fastcall sub_11FE2(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = *(_QWORD *)(a1 + 40);
  LODWORD(v1) = *(unsigned __int16 *)(a1 + 72);
  if ( (_DWORD)v1 == 2 )
  {
    if ( !*(_DWORD *)(a1 + 76) || (LODWORD(v1) = (*(_DWORD *)(a1 + 76) ^ unk_2250E4) & dword_2250D8, !(_DWORD)v1) )
    {
      LOBYTE(v1) = a1;
      *(_DWORD *)(a1 + 76) = *(_DWORD *)(v4 + 20);
    }
  }
  else if ( (_DWORD)v1 == 10 )
  {
    if ( sub_F350((const void *)(a1 + 80), &in6addr_any)
      || (LOBYTE(v1) = sub_F350((const void *)(a1 + 80), &in6addr_loopback), (_BYTE)v1) )
    {
      v2 = *(_QWORD *)(v4 + 52);
      v1 = *(_QWORD *)(v4 + 44);
      *(_QWORD *)(a1 + 80) = v1;
      *(_QWORD *)(a1 + 88) = v2;
    }
  }
  return v1;
}
// 2250D8: using guessed type int dword_2250D8;

//----- (00000000000120B2) ----------------------------------------------------
__int64 __fastcall sub_120B2(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  result = sub_C3CA((unsigned int *)(a1 + 392), a2);
  if ( (_BYTE)result )
    result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 5992LL) + 64LL))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 6000LL));
  return result;
}

//----- (0000000000012107) ----------------------------------------------------
__int64 __fastcall sub_12107(__int64 a1)
{
  sub_1659D(a1);
  return 0LL;
}

//----- (0000000000012129) ----------------------------------------------------
__int64 __fastcall sub_12129(_DWORD *a1)
{
  a1[3] = *(unsigned __int64 *)(*(_QWORD *)a1 + 8LL) - *(unsigned __int64 *)(*(_QWORD *)a1 + 24LL);
  a1[2] = *(unsigned __int64 *)(*(_QWORD *)a1 + 16LL) - *(unsigned __int64 *)(*(_QWORD *)a1 + 24LL);
  return 0LL;
}

//----- (0000000000012190) ----------------------------------------------------
signed __int64 __fastcall sub_12190(__int64 a1)
{
  signed __int64 result; // rax
  unsigned int v2; // [rsp+14h] [rbp-Ch]

  v2 = *(_DWORD *)(*(_QWORD *)a1 + 4LL);
  sub_C48D(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)a1 + 4LL));
  if ( v2 != *(_DWORD *)(*(_QWORD *)a1 + 4LL) )
    return 4294967284LL;
  if ( v2 > *(_DWORD *)(a1 + 12) && v2 > *(_DWORD *)(a1 + 8) )
  {
    *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(unsigned int *)(a1 + 12) + *(_QWORD *)(*(_QWORD *)a1 + 24LL);
    *(_QWORD *)(*(_QWORD *)a1 + 16LL) = *(unsigned int *)(a1 + 8) + *(_QWORD *)(*(_QWORD *)a1 + 24LL);
    result = 0LL;
  }
  else
  {
    g_log("Slirp", 8LL, "invalid sbuf offsets r/w=%u/%u len=%u");
    result = 4294967274LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001228A) ----------------------------------------------------
bool __fastcall sub_1228A(__int64 a1, signed int a2)
{
  return a2 <= 3;
}

//----- (000000000001229E) ----------------------------------------------------
bool __fastcall sub_1229E(_WORD *a1)
{
  return *a1 == 2;
}

//----- (00000000000122C1) ----------------------------------------------------
signed __int64 __fastcall sub_122C1(__int64 a1)
{
  if ( (signed int)sub_17B83((_QWORD *)a1) < 0 )
    return 4294967284LL;
  *(_WORD *)(a1 + 72) = 2;
  *(_WORD *)(a1 + 200) = 2;
  return 0LL;
}

//----- (000000000001230A) ----------------------------------------------------
__int64 __fastcall sub_1230A(__int64 a1)
{
  *(_WORD *)(a1 + 8) = -1;
  if ( **(_WORD **)a1 == 2 )
  {
    *(_WORD *)(a1 + 8) = 2;
  }
  else if ( **(_WORD **)a1 == 10 )
  {
    *(_WORD *)(a1 + 8) = 10;
  }
  return 0LL;
}

//----- (0000000000012361) ----------------------------------------------------
signed __int64 __fastcall sub_12361(__int64 a1)
{
  signed int v1; // eax

  v1 = *(unsigned __int16 *)(a1 + 8);
  if ( v1 == 10 )
  {
LABEL_9:
    **(_WORD **)a1 = 10;
    return 0LL;
  }
  if ( v1 > 10 )
  {
    if ( v1 != 23 && v1 != 28 )
      goto LABEL_10;
    goto LABEL_9;
  }
  if ( v1 != 2 )
  {
LABEL_10:
    g_log("Slirp", 8LL, "invalid ss_family type %x");
    return 4294967274LL;
  }
  **(_WORD **)a1 = 2;
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (00000000000123F4) ----------------------------------------------------
unsigned __int64 __fastcall slirp_state_save(__int64 a1, __int64 a2, __int64 a3)
{
  uint16_t v3; // ax
  __int64 i; // [rsp+20h] [rbp-30h]
  __int64 *v6; // [rsp+28h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-20h]
  __int64 v8; // [rsp+38h] [rbp-18h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v7 = a2;
  v8 = a3;
  for ( i = *(_QWORD *)(a1 + 128); i; i = *(_QWORD *)(i + 32) )
  {
    if ( *(_QWORD *)i )
    {
      v3 = ntohs(*(_DWORD *)(i + 20));
      v6 = sub_F0A9(a1, *(_DWORD *)(i + 16), v3);
      if ( v6 )
      {
        sub_12712((__int64)&v7, 42);
        sub_1CC71((__int64)&v7, (__int64)&off_222C20, (__int64)v6);
      }
    }
  }
  sub_12712((__int64)&v7, 0);
  sub_1CC71((__int64)&v7, (__int64)&off_222CA0, a1);
  return __readfsqword(0x28u) ^ v9;
}
// 222C20: using guessed type char *off_222C20;
// 222CA0: using guessed type char *off_222CA0;

//----- (00000000000124F5) ----------------------------------------------------
signed __int64 __fastcall slirp_state_load(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  unsigned int v5; // [rsp+2Ch] [rbp-34h]
  __int64 i; // [rsp+30h] [rbp-30h]
  _DWORD *v7; // [rsp+38h] [rbp-28h]
  __int64 v8; // [rsp+40h] [rbp-20h]
  __int64 v9; // [rsp+48h] [rbp-18h]
  unsigned __int64 v10; // [rsp+58h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v8 = a3;
  v9 = a4;
  while ( (unsigned __int8)sub_126BA((__int64)&v8) )
  {
    v7 = sub_F694(a1);
    v5 = sub_1CD2E((__int64)&v8, (__int64)&off_222C20, (__int64)v7, a2);
    if ( (v5 & 0x80000000) != 0 )
      return v5;
    if ( (*(_DWORD *)(a1 + 16) & v7[19]) != *(_DWORD *)(a1 + 12) )
      return 4294967274LL;
    for ( i = *(_QWORD *)(a1 + 128);
          i && (!*(_QWORD *)i || v7[19] != *(_DWORD *)(i + 16) || *((unsigned __int16 *)v7 + 37) != *(_DWORD *)(i + 20));
          i = *(_QWORD *)(i + 32) )
    {
      ;
    }
    if ( !i )
      return 4294967274LL;
  }
  return sub_1CD2E((__int64)&v8, (__int64)&off_222CA0, a1, a2);
}
// 222C20: using guessed type char *off_222C20;
// 222CA0: using guessed type char *off_222CA0;

//----- (000000000001263D) ----------------------------------------------------
signed __int64 slirp_state_version()
{
  return 4LL;
}

//----- (0000000000012648) ----------------------------------------------------
bool __fastcall sub_12648(__int64 a1, __int64 a2, __int64 a3)
{
  return a3 == (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))a1)(a2, a3, *(_QWORD *)(a1 + 8));
}

//----- (0000000000012681) ----------------------------------------------------
bool __fastcall sub_12681(__int64 a1, __int64 a2, __int64 a3)
{
  return a3 == (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))a1)(a2, a3, *(_QWORD *)(a1 + 8));
}

//----- (00000000000126BA) ----------------------------------------------------
__int64 __fastcall sub_126BA(__int64 a1)
{
  __int64 result; // rax
  unsigned __int8 v2; // [rsp+17h] [rbp-9h]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( sub_12648(a1, (__int64)&v2, 1LL) )
    result = v2;
  else
    result = 0LL;
  return result;
}

//----- (0000000000012712) ----------------------------------------------------
bool __fastcall sub_12712(__int64 a1, char a2)
{
  char v3; // [rsp+4h] [rbp-Ch]
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = a2;
  return sub_12681(a1, (__int64)&v3, 1LL);
}

//----- (000000000001273D) ----------------------------------------------------
__int16 __fastcall sub_1273D(__int64 a1)
{
  __int16 result; // ax
  __int16 v2; // [rsp+16h] [rbp-Ah]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( sub_12648(a1, (__int64)&v2, 2LL) )
    result = __ROL2__(v2, 8);
  else
    result = 0;
  return result;
}

//----- (0000000000012799) ----------------------------------------------------
bool __fastcall sub_12799(__int64 a1, __int16 a2)
{
  __int16 v3; // [rsp+4h] [rbp-Ch]
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = __ROL2__(a2, 8);
  return sub_12681(a1, (__int64)&v3, 2LL);
}

//----- (00000000000127D1) ----------------------------------------------------
__int64 __fastcall sub_127D1(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( sub_12648(a1, (__int64)&v2, 4LL) )
    result = (v2 >> 8) & 0xFF00 | (v2 << 8) & 0xFF0000 | (v2 << 24) | (v2 >> 24);
  else
    result = 0LL;
  return result;
}

//----- (000000000001284F) ----------------------------------------------------
bool __fastcall sub_1284F(__int64 a1, unsigned int a2)
{
  unsigned int v3; // [rsp+4h] [rbp-Ch]
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = (a2 >> 8) & 0xFF00 | (a2 << 8) & 0xFF0000 | (a2 << 24) | (a2 >> 24);
  return sub_12681(a1, (__int64)&v3, 4LL);
}

//----- (00000000000128A5) ----------------------------------------------------
__int16 __fastcall sub_128A5(__int64 a1)
{
  __int16 result; // ax
  __int16 v2; // [rsp+16h] [rbp-Ah]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( sub_12648(a1, (__int64)&v2, 2LL) )
    result = __ROL2__(v2, 8);
  else
    result = 0;
  return result;
}

//----- (0000000000012901) ----------------------------------------------------
bool __fastcall sub_12901(__int64 a1, __int16 a2)
{
  __int16 v3; // [rsp+4h] [rbp-Ch]
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = __ROL2__(a2, 8);
  return sub_12681(a1, (__int64)&v3, 2LL);
}

//----- (0000000000012939) ----------------------------------------------------
__int64 __fastcall sub_12939(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( sub_12648(a1, (__int64)&v2, 4LL) )
    result = (v2 >> 8) & 0xFF00 | (v2 << 8) & 0xFF0000 | (v2 << 24) | (v2 >> 24);
  else
    result = 0LL;
  return result;
}

//----- (00000000000129B7) ----------------------------------------------------
bool __fastcall sub_129B7(__int64 a1, unsigned int a2)
{
  unsigned int v3; // [rsp+4h] [rbp-Ch]
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  v3 = (a2 >> 8) & 0xFF00 | (a2 << 8) & 0xFF0000 | (a2 << 24) | (a2 >> 24);
  return sub_12681(a1, (__int64)&v3, 4LL);
}

//----- (0000000000012A0D) ----------------------------------------------------
__int64 __fastcall sub_12A0D(_DWORD *a1, __int64 a2, __int64 a3)
{
  signed __int64 i; // r12
  signed __int64 v4; // r12
  int v5; // er14
  int v6; // er14
  __int64 v7; // ST08_8
  signed __int64 v9; // rbx
  __int64 v10; // [rsp+8h] [rbp-38h]
  __int64 v11; // [rsp+8h] [rbp-38h]
  unsigned int v12; // [rsp+14h] [rbp-2Ch]
  __int64 v13; // [rsp+18h] [rbp-28h]

  v10 = a3;
  v13 = *((_QWORD *)a1 + 14);
  if ( a2 )
  {
    for ( i = *(_QWORD *)a1 + 16LL;
          a1 != (_DWORD *)(i - 16) && *(_DWORD *)(i + 52) - *(_DWORD *)(a2 + 52) <= 0;
          i = *(_QWORD *)(i - 16) + 16LL )
    {
      ;
    }
    if ( a1 != *(_DWORD **)(i - 16 + 8) )
    {
      v4 = *(_QWORD *)(i - 16 + 8) + 16LL;
      v5 = *(unsigned __int16 *)(v4 + 46) + *(_DWORD *)(v4 + 52) - *(_DWORD *)(a2 + 52);
      if ( v5 > 0 )
      {
        if ( v5 >= *(unsigned __int16 *)(a2 + 46) )
        {
          sub_A4F0(a3);
          goto LABEL_19;
        }
        sub_A875(a3, v5);
        *(_WORD *)(a2 + 46) -= v5;
        *(_DWORD *)(a2 + 52) += v5;
      }
      i = *(_QWORD *)(v4 - 16) + 16LL;
    }
    *(_QWORD *)a2 = v10;
    while ( a1 != (_DWORD *)(i - 16) )
    {
      v6 = *(unsigned __int16 *)(a2 + 46) + *(_DWORD *)(a2 + 52) - *(_DWORD *)(i + 52);
      if ( v6 <= 0 )
        break;
      if ( v6 < *(unsigned __int16 *)(i + 46) )
      {
        *(_DWORD *)(i + 52) = *(unsigned __int16 *)(a2 + 46) + *(_DWORD *)(a2 + 52);
        *(_WORD *)(i + 46) -= v6;
        sub_A875(*(_QWORD *)i, v6);
        break;
      }
      i = *(_QWORD *)(i - 16) + 16LL;
      v7 = *(_QWORD *)(*(_QWORD *)(i - 16 + 8) + 16LL);
      sub_AB7F(*(_QWORD **)(i - 16 + 8));
      sub_A4F0(v7);
    }
    sub_AB4C((_QWORD *)(a2 - 16), *(_QWORD **)(i - 16 + 8));
  }
LABEL_19:
  if ( *((_WORD *)a1 + 8) <= 3 )
    return 0LL;
  v9 = *(_QWORD *)a1 + 16LL;
  if ( a1 == *(_DWORD **)a1 || *(_DWORD *)(*(_QWORD *)a1 + 68LL) != a1[38] )
    return 0LL;
  if ( *((_WORD *)a1 + 8) == 3 && *(_WORD *)(*(_QWORD *)a1 + 62LL) )
    return 0LL;
  do
  {
    a1[38] += *(unsigned __int16 *)(v9 + 46);
    v12 = *(_BYTE *)(v9 + 61) & 1;
    sub_AB7F((_QWORD *)(v9 - 16));
    v11 = *(_QWORD *)v9;
    v9 = *(_QWORD *)(v9 - 16) + 16LL;
    if ( *(_DWORD *)(v13 + 332) & 0x10 )
    {
      sub_A4F0(v11);
    }
    else if ( *(_BYTE *)(v13 + 329) )
    {
      if ( (unsigned int)sub_17D52(v13, v11) )
        sub_C59C(v13, v11);
    }
    else
    {
      sub_C59C(v13, v11);
    }
  }
  while ( (_DWORD *)v9 != a1 && *(_DWORD *)(v9 + 52) == a1[38] );
  return v12;
}

//----- (0000000000012CFB) ----------------------------------------------------
unsigned __int64 __usercall sub_12CFB@<rax>(unsigned __int16 *a1@<rdx>, __int16 a2@<cx>, __int64 a3@<rdi>, unsigned int a4@<esi>, __int64 a5@<r12>)
{
  __int64 v5; // rbx
  int v6; // er13
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rcx
  int v25; // eax
  __int16 v26; // ax
  int v27; // eax
  int *v28; // rax
  int *v29; // rax
  __int16 v30; // ax
  int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // er15
  unsigned int v34; // er14
  signed int v35; // eax
  __int16 v36; // ax
  char v37; // r13
  unsigned __int16 *v39; // [rsp+8h] [rbp-238h]
  __int16 v40; // [rsp+10h] [rbp-230h]
  signed __int16 v41; // [rsp+14h] [rbp-22Ch]
  __int64 v42; // [rsp+18h] [rbp-228h]
  char v43; // [rsp+27h] [rbp-219h]
  int v44; // [rsp+28h] [rbp-218h]
  int v45; // [rsp+2Ch] [rbp-214h]
  int v46; // [rsp+30h] [rbp-210h]
  int v47; // [rsp+30h] [rbp-210h]
  signed int v48; // [rsp+34h] [rbp-20Ch]
  signed int v49; // [rsp+38h] [rbp-208h]
  int v50; // [rsp+3Ch] [rbp-204h]
  unsigned int v51; // [rsp+40h] [rbp-200h]
  int v52; // [rsp+44h] [rbp-1FCh]
  unsigned int v53; // [rsp+48h] [rbp-1F8h]
  int v54; // [rsp+50h] [rbp-1F0h]
  unsigned int v55; // [rsp+54h] [rbp-1ECh]
  int v56; // [rsp+58h] [rbp-1E8h]
  int v57; // [rsp+5Ch] [rbp-1E4h]
  unsigned __int8 *v58; // [rsp+60h] [rbp-1E0h]
  unsigned __int16 *v59; // [rsp+68h] [rbp-1D8h]
  __int64 i; // [rsp+70h] [rbp-1D0h]
  __int64 j; // [rsp+70h] [rbp-1D0h]
  __int64 v62; // [rsp+78h] [rbp-1C8h]
  __int64 *v63; // [rsp+80h] [rbp-1C0h]
  __int64 *v64; // [rsp+88h] [rbp-1B8h]
  __int64 v65; // [rsp+B0h] [rbp-190h]
  __int64 v66; // [rsp+B8h] [rbp-188h]
  int v67; // [rsp+C0h] [rbp-180h]
  __int64 v68; // [rsp+D0h] [rbp-170h]
  __int64 v69; // [rsp+D8h] [rbp-168h]
  __int64 v70; // [rsp+E0h] [rbp-160h]
  __int64 v71; // [rsp+E8h] [rbp-158h]
  __int64 v72; // [rsp+F0h] [rbp-150h]
  __int64 v73; // [rsp+100h] [rbp-140h]
  __int64 v74; // [rsp+108h] [rbp-138h]
  __int64 v75; // [rsp+110h] [rbp-130h]
  __int64 v76; // [rsp+118h] [rbp-128h]
  __int64 v77; // [rsp+120h] [rbp-120h]
  __int64 v78; // [rsp+128h] [rbp-118h]
  __int64 v79; // [rsp+130h] [rbp-110h]
  __int64 v80; // [rsp+138h] [rbp-108h]
  __int64 v81; // [rsp+140h] [rbp-100h]
  __int64 v82; // [rsp+148h] [rbp-F8h]
  __int64 v83; // [rsp+150h] [rbp-F0h]
  __int64 v84; // [rsp+158h] [rbp-E8h]
  __int64 v85; // [rsp+160h] [rbp-E0h]
  __int64 v86; // [rsp+168h] [rbp-D8h]
  __int64 v87; // [rsp+170h] [rbp-D0h]
  __int64 v88; // [rsp+178h] [rbp-C8h]
  __int64 v89; // [rsp+180h] [rbp-C0h]
  __int64 v90; // [rsp+188h] [rbp-B8h]
  __int64 v91; // [rsp+190h] [rbp-B0h]
  __int64 v92; // [rsp+198h] [rbp-A8h]
  __int64 v93; // [rsp+1A0h] [rbp-A0h]
  __int64 v94; // [rsp+1A8h] [rbp-98h]
  __int64 v95; // [rsp+1B0h] [rbp-90h]
  __int64 v96; // [rsp+1B8h] [rbp-88h]
  __int64 v97; // [rsp+1C0h] [rbp-80h]
  __int64 v98; // [rsp+1C8h] [rbp-78h]
  __int64 v99; // [rsp+1D0h] [rbp-70h]
  __int64 v100; // [rsp+1D8h] [rbp-68h]
  __int64 v101; // [rsp+1E0h] [rbp-60h]
  __int64 v102; // [rsp+1E8h] [rbp-58h]
  __int64 v103; // [rsp+1F0h] [rbp-50h]
  __int64 v104; // [rsp+1F8h] [rbp-48h]
  unsigned __int64 v105; // [rsp+208h] [rbp-38h]

  v42 = a3;
  v41 = a4;
  v39 = a1;
  v40 = a2;
  v105 = __readfsqword(0x28u);
  v58 = 0LL;
  v44 = 0;
  v5 = 0LL;
  v49 = 0;
  v50 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p  iphlen = %2d  inso = %p");
  if ( a3 )
  {
    v62 = *(_QWORD *)(a3 + 64);
    v63 = *(__int64 **)(a3 + 48);
    v64 = *(__int64 **)(a3 + 48);
    if ( v40 == 2 )
    {
      if ( a4 > 0x14 )
      {
        sub_9E0E(a3);
        v41 = 20;
      }
      v65 = *v63;
      v66 = v63[1];
      v67 = *((_DWORD *)v63 + 4);
      WORD1(v65) += v41;
      *(_QWORD *)(a3 + 48) -= 28LL;
      *(_DWORD *)(a3 + 56) += 28;
      a5 = *(_QWORD *)(a3 + 48);
      v45 = *((unsigned __int16 *)v63 + 1);
      *(_QWORD *)(a5 - 16 + 8) = 0LL;
      *(_QWORD *)(a5 - 16) = *(_QWORD *)(a5 - 16 + 8);
      memset((void *)a5, 0, 8uLL);
      memset((void *)(a5 + 8), 0, 0x24uLL);
      *(_WORD *)(a5 + 44) = 0;
      *(_DWORD *)(a5 + 8) = HIDWORD(v66);
      *(_DWORD *)(a5 + 12) = v67;
      *(_BYTE *)(a5 + 17) = BYTE1(v66);
      *(_WORD *)(a5 + 46) = htons(v45);
    }
    else if ( v40 == 10 )
    {
      v68 = *v64;
      v69 = v64[1];
      v70 = v64[2];
      v71 = v64[3];
      v72 = v64[4];
      *(_QWORD *)(a3 + 48) -= 8LL;
      *(_DWORD *)(a3 + 56) += 8;
      a5 = *(_QWORD *)(a3 + 48);
      v45 = *((unsigned __int16 *)v64 + 2);
      *(_QWORD *)(a5 - 16 + 8) = 0LL;
      *(_QWORD *)(a5 - 16) = *(_QWORD *)(a5 - 16 + 8);
      memset((void *)a5, 0, 8uLL);
      memset((void *)(a5 + 8), 0, 0x24uLL);
      *(_WORD *)(a5 + 44) = 0;
      *(_QWORD *)(a5 + 8) = v69;
      *(_QWORD *)(a5 + 16) = v70;
      *(_QWORD *)(a5 + 24) = v71;
      *(_QWORD *)(a5 + 32) = v72;
      *(_BYTE *)(a5 + 41) = BYTE6(v68);
      *(_WORD *)(a5 + 46) = htons(v45);
    }
    else
    {
      g_assertion_message_expr("Slirp", "../src/tcp_input.c", 308LL, "tcp_input", 0LL);
    }
    if ( (unsigned int)sub_44C3(a3, v45 + 48)
      || (v54 = 4 * (unsigned __int8)(*(_BYTE *)(a5 + 60) >> 4), (unsigned int)v54 <= 0x13)
      || v54 > v45 )
    {
LABEL_306:
      sub_A4F0(a3);
      return __readfsqword(0x28u) ^ v105;
    }
    *(_WORD *)(a5 + 46) = v45 - v54;
    if ( (unsigned int)v54 > 0x14 )
    {
      v44 = v54 - 20;
      v58 = (unsigned __int8 *)(*(_QWORD *)(a3 + 48) + 68LL);
    }
    v6 = *(unsigned __int8 *)(a5 + 61);
    *(_DWORD *)(a5 + 52) = ntohl(*(_DWORD *)(a5 + 52));
    *(_DWORD *)(a5 + 56) = ntohl(*(_DWORD *)(a5 + 56));
    *(_WORD *)(a5 + 62) = ntohs(*(_WORD *)(a5 + 62));
    *(_WORD *)(a5 + 66) = ntohs(*(_WORD *)(a5 + 66));
    *(_QWORD *)(a3 + 48) += v54 + 48LL;
    *(_DWORD *)(a3 + 56) = *(_DWORD *)(a3 + 56) - v54 - 48;
    while ( 1 )
    {
      LOWORD(v73) = v40;
      LOWORD(v89) = v40;
      if ( v40 == 2 )
      {
        HIDWORD(v73) = *(_DWORD *)(a5 + 8);
        WORD1(v73) = *(_WORD *)(a5 + 48);
        HIDWORD(v89) = *(_DWORD *)(a5 + 12);
        WORD1(v89) = *(_WORD *)(a5 + 50);
      }
      else if ( v40 == 10 )
      {
        v7 = *(_QWORD *)(a5 + 16);
        v74 = *(_QWORD *)(a5 + 8);
        v75 = v7;
        WORD1(v73) = *(_WORD *)(a5 + 48);
        v8 = *(_QWORD *)(a5 + 32);
        v90 = *(_QWORD *)(a5 + 24);
        v91 = v8;
        WORD1(v89) = *(_WORD *)(a5 + 50);
      }
      else
      {
        g_assertion_message_expr("Slirp", "../src/tcp_input.c", 370LL, "tcp_input", 0LL);
      }
      v59 = sub_F5A7((unsigned __int16 **)(v62 + 872), (unsigned __int16 *)(v62 + 448), (__int64)&v73, (__int64)&v89);
      if ( !v59 )
      {
        if ( *(_DWORD *)(v62 + 124) )
        {
          for ( i = *(_QWORD *)(v62 + 128);
                i
             && (*(_DWORD *)(i + 20) != *(unsigned __int16 *)(a5 + 50) || *(_DWORD *)(a5 + 12) != *(_DWORD *)(i + 16));
                i = *(_QWORD *)(i + 32) )
          {
            ;
          }
          if ( !i )
            goto LABEL_301;
        }
        if ( (v6 & 0x37) != 2 )
          goto LABEL_301;
        v59 = (unsigned __int16 *)sub_F694(v62);
        if ( (signed int)sub_17B83(v59) < 0 )
        {
          g_free(v59);
          goto LABEL_301;
        }
        sub_C48D((__int64)(v59 + 196), (unsigned __int64)&unk_20000);
        sub_C48D((__int64)(v59 + 180), (unsigned __int64)&unk_20000);
        v9 = v74;
        *((_QWORD *)v59 + 25) = v73;
        *((_QWORD *)v59 + 26) = v9;
        v10 = v76;
        *((_QWORD *)v59 + 27) = v75;
        *((_QWORD *)v59 + 28) = v10;
        v11 = v78;
        *((_QWORD *)v59 + 29) = v77;
        *((_QWORD *)v59 + 30) = v11;
        v12 = v80;
        *((_QWORD *)v59 + 31) = v79;
        *((_QWORD *)v59 + 32) = v12;
        v13 = v82;
        *((_QWORD *)v59 + 33) = v81;
        *((_QWORD *)v59 + 34) = v13;
        v14 = v84;
        *((_QWORD *)v59 + 35) = v83;
        *((_QWORD *)v59 + 36) = v14;
        v15 = v86;
        *((_QWORD *)v59 + 37) = v85;
        *((_QWORD *)v59 + 38) = v15;
        v16 = v88;
        *((_QWORD *)v59 + 39) = v87;
        *((_QWORD *)v59 + 40) = v16;
        v17 = v90;
        *((_QWORD *)v59 + 9) = v89;
        *((_QWORD *)v59 + 10) = v17;
        v18 = v92;
        *((_QWORD *)v59 + 11) = v91;
        *((_QWORD *)v59 + 12) = v18;
        v19 = v94;
        *((_QWORD *)v59 + 13) = v93;
        *((_QWORD *)v59 + 14) = v19;
        v20 = v96;
        *((_QWORD *)v59 + 15) = v95;
        *((_QWORD *)v59 + 16) = v20;
        v21 = v98;
        *((_QWORD *)v59 + 17) = v97;
        *((_QWORD *)v59 + 18) = v21;
        v22 = v100;
        *((_QWORD *)v59 + 19) = v99;
        *((_QWORD *)v59 + 20) = v22;
        v23 = v102;
        *((_QWORD *)v59 + 21) = v101;
        *((_QWORD *)v59 + 22) = v23;
        v24 = v104;
        *((_QWORD *)v59 + 23) = v103;
        *((_QWORD *)v59 + 24) = v24;
        *((_BYTE *)v59 + 328) = sub_17BE5((__int64)v59);
        if ( !*((_BYTE *)v59 + 328) )
        {
          if ( v40 == 2 )
          {
            *((_BYTE *)v59 + 328) = *(_BYTE *)(a5 + 1);
          }
          else if ( v40 != 10 )
          {
            g_assertion_message_expr("Slirp", "../src/tcp_input.c", 431LL, "tcp_input", 0LL);
          }
        }
        *(_WORD *)(*((_QWORD *)v59 + 42) + 16LL) = 1;
      }
      if ( *((_DWORD *)v59 + 83) & 2 )
        goto LABEL_306;
      v5 = *((_QWORD *)v59 + 42);
      if ( !v5 )
        goto LABEL_301;
      if ( !*(_WORD *)(v5 + 16) )
        goto LABEL_306;
      v51 = *(unsigned __int16 *)(a5 + 62);
      *(_WORD *)(v5 + 180) = 0;
      if ( unk_2250EC )
        *(_WORD *)(v5 + 22) = 150;
      else
        *(_WORD *)(v5 + 22) = 14400;
      if ( v58 && *(_WORD *)(v5 + 16) != 1 )
        sub_14FE8(v5, v58, v44, a5);
      if ( *(_WORD *)(v5 + 16) == 4
        && (v6 & 0x37) == 16
        && *(_DWORD *)(a5 + 52) == *(_DWORD *)(v5 + 152)
        && v51
        && v51 == *(_DWORD *)(v5 + 144)
        && *(_DWORD *)(v5 + 124) == *(_DWORD *)(v5 + 168) )
      {
        if ( *(_WORD *)(a5 + 46) )
        {
          if ( *(_DWORD *)(a5 + 56) == *(_DWORD *)(v5 + 120)
            && v5 == *(_QWORD *)v5
            && *(unsigned __int16 *)(a5 + 46) <= (unsigned int)(*((_DWORD *)v59 + 91) - *((_DWORD *)v59 + 90)) )
          {
            *(_DWORD *)(v5 + 152) += *(unsigned __int16 *)(a5 + 46);
            if ( *((_BYTE *)v59 + 329) )
            {
              if ( (unsigned int)sub_17D52((__int64)v59, a3) )
                sub_C59C((__int64)v59, a3);
            }
            else
            {
              sub_C59C((__int64)v59, a3);
            }
            *(_WORD *)(v5 + 36) |= 1u;
            sub_15563(v5);
            return __readfsqword(0x28u) ^ v105;
          }
        }
        else if ( *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 120) > 0
               && *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 168) <= 0
               && *(_DWORD *)(v5 + 172) >= *(_DWORD *)(v5 + 144) )
        {
          if ( *(_WORD *)(v5 + 182) && *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 184) > 0 )
            sub_1514F((_WORD *)v5, *(signed __int16 *)(v5 + 182));
          sub_120B2((__int64)v59, *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 120));
          *(_DWORD *)(v5 + 120) = *(_DWORD *)(a5 + 56);
          sub_A4F0(a3);
          if ( *(_DWORD *)(v5 + 120) == *(_DWORD *)(v5 + 168) )
          {
            *(_WORD *)(v5 + 18) = 0;
          }
          else if ( !*(_WORD *)(v5 + 20) )
          {
            *(_WORD *)(v5 + 18) = *(_WORD *)(v5 + 28);
          }
          if ( *((_DWORD *)v59 + 98) )
            sub_15563(v5);
          return __readfsqword(0x28u) ^ v105;
        }
      }
      v52 = *((_DWORD *)v59 + 91) - *((_DWORD *)v59 + 90);
      if ( v52 < 0 )
        v52 = 0;
      v25 = *(_DWORD *)(v5 + 164) - *(_DWORD *)(v5 + 152);
      if ( v52 >= v25 )
        v25 = v52;
      *(_DWORD *)(v5 + 148) = v25;
      v26 = *(_WORD *)(v5 + 16);
      if ( v26 == 1 )
        break;
      if ( v26 == 2 )
      {
        if ( v6 & 0x10
          && (*(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 140) <= 0 || *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 168) > 0) )
        {
          goto LABEL_301;
        }
        if ( v6 & 4 )
        {
          if ( v6 & 0x10 )
            sub_16FC0(v5);
          goto LABEL_306;
        }
        if ( !(v6 & 2) )
          goto LABEL_306;
        if ( v6 & 0x10 )
        {
          *(_DWORD *)(v5 + 120) = *(_DWORD *)(a5 + 56);
          if ( *(_DWORD *)(v5 + 124) - *(_DWORD *)(v5 + 120) < 0 )
            *(_DWORD *)(v5 + 124) = *(_DWORD *)(v5 + 120);
        }
        *(_WORD *)(v5 + 18) = 0;
        *(_DWORD *)(v5 + 160) = *(_DWORD *)(a5 + 52);
        *(_DWORD *)(v5 + 152) = *(_DWORD *)(v5 + 160) + 1;
        *(_DWORD *)(v5 + 164) = *(_DWORD *)(v5 + 152);
        *(_WORD *)(v5 + 36) |= 1u;
        if ( v6 & 0x10 && *(_DWORD *)(v5 + 120) - *(_DWORD *)(v5 + 140) > 0 )
        {
          sub_11AF7((__int64)v59);
          *(_WORD *)(v5 + 16) = 4;
          sub_12A0D((_DWORD *)v5, 0LL, 0LL);
          if ( *(_WORD *)(v5 + 182) )
            sub_1514F((_WORD *)v5, *(signed __int16 *)(v5 + 182));
        }
        else
        {
          *(_WORD *)(v5 + 16) = 3;
        }
        goto LABEL_145;
      }
      v46 = *(_DWORD *)(v5 + 152) - *(_DWORD *)(a5 + 52);
      if ( v46 > 0 )
      {
        if ( v6 & 2 )
        {
          v6 &= 0xFFFFFFFD;
          ++*(_DWORD *)(a5 + 52);
          if ( *(_WORD *)(a5 + 66) <= 1u )
            v6 &= 0xFFFFFFDF;
          else
            --*(_WORD *)(a5 + 66);
          --v46;
        }
        if ( v46 > *(unsigned __int16 *)(a5 + 46) || v46 == *(unsigned __int16 *)(a5 + 46) && !(v6 & 1) )
        {
          v6 &= 0xFFFFFFFE;
          *(_WORD *)(v5 + 36) |= 1u;
          v46 = *(unsigned __int16 *)(a5 + 46);
        }
        sub_A875(a3, v46);
        *(_DWORD *)(a5 + 52) += v46;
        *(_WORD *)(a5 + 46) -= v46;
        if ( v46 >= *(unsigned __int16 *)(a5 + 66) )
        {
          v6 &= 0xFFFFFFDF;
          *(_WORD *)(a5 + 66) = 0;
        }
        else
        {
          *(_WORD *)(a5 + 66) -= v46;
        }
      }
      if ( *((_DWORD *)v59 + 83) & 1 && *(_WORD *)(v5 + 16) > 5 && *(_WORD *)(a5 + 46) )
      {
        v5 = sub_17098((_QWORD *)v5);
        goto LABEL_301;
      }
      v47 = *(_DWORD *)(a5 + 52) + *(unsigned __int16 *)(a5 + 46) - (*(_DWORD *)(v5 + 152) + *(_DWORD *)(v5 + 148));
      if ( v47 <= 0 )
        goto LABEL_175;
      if ( v47 < *(unsigned __int16 *)(a5 + 46) )
        goto LABEL_174;
      if ( !(v6 & 2) || *(_WORD *)(v5 + 16) != 10 || *(_DWORD *)(a5 + 52) - *(_DWORD *)(v5 + 152) <= 0 )
      {
        if ( !*(_DWORD *)(v5 + 148) && *(_DWORD *)(a5 + 52) == *(_DWORD *)(v5 + 152) )
        {
          *(_WORD *)(v5 + 36) |= 1u;
LABEL_174:
          sub_A875(a3, -v47);
          *(_WORD *)(a5 + 46) -= v47;
          LOBYTE(v6) = v6 & 0xF6;
LABEL_175:
          if ( v6 & 4 )
          {
            switch ( *(signed __int16 *)(v5 + 16) )
            {
              case 3:
              case 4:
              case 5:
              case 6:
              case 9:
                *(_WORD *)(v5 + 16) = 0;
                sub_17098((_QWORD *)v5);
                goto LABEL_306;
              case 7:
              case 8:
              case 10:
                sub_17098((_QWORD *)v5);
                goto LABEL_306;
              default:
                break;
            }
          }
          if ( v6 & 2 )
          {
            v5 = sub_16FC0(v5);
            goto LABEL_301;
          }
          if ( !(v6 & 0x10) )
            goto LABEL_306;
          v30 = *(_WORD *)(v5 + 16);
          if ( v30 == 3 )
          {
            if ( *(_DWORD *)(v5 + 120) - *(_DWORD *)(a5 + 56) > 0 || *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 168) > 0 )
              goto LABEL_301;
            *(_WORD *)(v5 + 16) = 4;
            *(_DWORD *)(v5 + 120) = *(_DWORD *)(a5 + 56);
            if ( *((_DWORD *)v59 + 83) & 0x80 )
            {
              v57 = sub_190AA((__int64)v59);
              if ( v57 == 1 )
              {
                sub_11AF7((__int64)v59);
                v31 = *((_DWORD *)v59 + 83);
                LOBYTE(v31) = v31 & 0x7F;
                *((_DWORD *)v59 + 83) = v31;
              }
              else if ( v57 == 2 )
              {
                *((_DWORD *)v59 + 83) &= 0xF000u;
                *((_DWORD *)v59 + 83) |= 1u;
              }
              else
              {
                v49 = 1;
                *(_WORD *)(v5 + 16) = 6;
              }
            }
            else
            {
              sub_11AF7((__int64)v59);
            }
            sub_12A0D((_DWORD *)v5, 0LL, 0LL);
            *(_DWORD *)(v5 + 132) = *(_DWORD *)(a5 + 52) - 1;
          }
          else
          {
            if ( v30 < 3 || v30 > 10 )
              goto LABEL_251;
            if ( *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 120) <= 0 )
            {
              if ( *(_WORD *)(a5 + 46) || v51 != *(_DWORD *)(v5 + 144) )
              {
                *(_WORD *)(v5 + 30) = 0;
                goto LABEL_251;
              }
              if ( unk_2250E0 & 2 )
                g_log("Slirp", 128LL, " dup ack  m = %p  so = %p");
              if ( !*(_WORD *)(v5 + 18) || *(_DWORD *)(a5 + 56) != *(_DWORD *)(v5 + 120) )
              {
                *(_WORD *)(v5 + 30) = 0;
                goto LABEL_251;
              }
              if ( ++*(_WORD *)(v5 + 30) == 3 )
              {
                v56 = *(_DWORD *)(v5 + 124);
                v32 = *(_DWORD *)(v5 + 144);
                if ( *(_DWORD *)(v5 + 172) <= v32 )
                  v32 = *(_DWORD *)(v5 + 172);
                v53 = (v32 >> 1) / *(unsigned __int16 *)(v5 + 32);
                if ( v53 <= 1 )
                  v53 = 2;
                *(_DWORD *)(v5 + 176) = v53 * *(unsigned __int16 *)(v5 + 32);
                *(_WORD *)(v5 + 18) = 0;
                *(_WORD *)(v5 + 182) = 0;
                *(_DWORD *)(v5 + 124) = *(_DWORD *)(a5 + 56);
                *(_DWORD *)(v5 + 172) = *(unsigned __int16 *)(v5 + 32);
                sub_15563(v5);
                *(_DWORD *)(v5 + 172) = *(unsigned __int16 *)(v5 + 32) * *(signed __int16 *)(v5 + 30)
                                      + *(_DWORD *)(v5 + 176);
                if ( v56 - *(_DWORD *)(v5 + 124) > 0 )
                  *(_DWORD *)(v5 + 124) = v56;
              }
              else
              {
                if ( *(_WORD *)(v5 + 30) <= 3 )
                  goto LABEL_251;
                *(_DWORD *)(v5 + 172) += *(unsigned __int16 *)(v5 + 32);
                sub_15563(v5);
              }
              goto LABEL_306;
            }
          }
          if ( *(_WORD *)(v5 + 30) > 3 && *(_DWORD *)(v5 + 172) > *(_DWORD *)(v5 + 176) )
            *(_DWORD *)(v5 + 172) = *(_DWORD *)(v5 + 176);
          *(_WORD *)(v5 + 30) = 0;
          if ( *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 168) <= 0 )
          {
            v55 = *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 120);
            if ( *(_WORD *)(v5 + 182) && *(_DWORD *)(a5 + 56) - *(_DWORD *)(v5 + 184) > 0 )
              sub_1514F((_WORD *)v5, *(signed __int16 *)(v5 + 182));
            if ( *(_DWORD *)(a5 + 56) == *(_DWORD *)(v5 + 168) )
            {
              *(_WORD *)(v5 + 18) = 0;
              v49 = 1;
            }
            else if ( !*(_WORD *)(v5 + 20) )
            {
              *(_WORD *)(v5 + 18) = *(_WORD *)(v5 + 28);
            }
            v33 = *(_DWORD *)(v5 + 172);
            v34 = *(unsigned __int16 *)(v5 + 32);
            if ( v33 > *(_DWORD *)(v5 + 176) )
              v34 = v34 * v34 / v33;
            v35 = v33 + v34;
            if ( 0xFFFF << *(_BYTE *)(v5 + 204) <= v33 + v34 )
              v35 = 0xFFFF << *(_BYTE *)(v5 + 204);
            *(_DWORD *)(v5 + 172) = v35;
            if ( *((_DWORD *)v59 + 98) >= v55 )
            {
              sub_120B2((__int64)v59, v55);
              *(_DWORD *)(v5 + 144) -= v55;
              v48 = 0;
            }
            else
            {
              *(_DWORD *)(v5 + 144) -= *((_DWORD *)v59 + 98);
              sub_120B2((__int64)v59, *((_DWORD *)v59 + 98));
              v48 = 1;
            }
            *(_DWORD *)(v5 + 120) = *(_DWORD *)(a5 + 56);
            if ( *(_DWORD *)(v5 + 124) - *(_DWORD *)(v5 + 120) < 0 )
              *(_DWORD *)(v5 + 124) = *(_DWORD *)(v5 + 120);
            v36 = *(_WORD *)(v5 + 16);
            if ( v36 == 7 )
            {
              if ( v48 )
              {
                *(_WORD *)(v5 + 16) = 10;
                sub_1949B(v5);
                *(_WORD *)(v5 + 24) = 20;
              }
              goto LABEL_251;
            }
            if ( v36 <= 7 )
            {
              if ( v36 == 6 && v48 )
              {
                if ( *((_DWORD *)v59 + 83) & 8 )
                  *(_WORD *)(v5 + 24) = 1200;
                *(_WORD *)(v5 + 16) = 9;
              }
              goto LABEL_251;
            }
            if ( v36 == 8 )
            {
              if ( !v48 )
                goto LABEL_251;
              sub_17098((_QWORD *)v5);
              goto LABEL_306;
            }
            if ( v36 != 10 )
              goto LABEL_251;
            *(_WORD *)(v5 + 24) = 20;
          }
        }
        if ( v6 & 4 )
          goto LABEL_306;
        sub_A4F0(a3);
        *(_WORD *)(v5 + 36) |= 1u;
        sub_15563(v5);
        return __readfsqword(0x28u) ^ v105;
      }
      v50 = *(_DWORD *)(v5 + 152) + 128000;
      v5 = sub_17098((_QWORD *)v5);
    }
    if ( v6 & 4 )
      goto LABEL_306;
    if ( v6 & 0x10 )
      goto LABEL_301;
    if ( !(v6 & 2) )
      goto LABEL_306;
    if ( v40 != 2
      || (*(_DWORD *)(v62 + 16) & *((_DWORD *)v59 + 19)) != *(_DWORD *)(v62 + 12)
      || *((_DWORD *)v59 + 19) == *(_DWORD *)(v62 + 20)
      || *((_DWORD *)v59 + 19) == *(_DWORD *)(v62 + 64) )
    {
      goto LABEL_310;
    }
    for ( j = *(_QWORD *)(v62 + 128); j; j = *(_QWORD *)(j + 32) )
    {
      if ( *(_DWORD *)(j + 20) == v59[37] && *((_DWORD *)v59 + 19) == *(_DWORD *)(j + 16) )
      {
        v27 = *((_DWORD *)v59 + 83);
        LOBYTE(v27) = v27 | 0x80;
        *((_DWORD *)v59 + 83) = v27;
        break;
      }
    }
    if ( !(*((_DWORD *)v59 + 83) & 0x80) )
    {
LABEL_310:
      if ( *((_BYTE *)v59 + 329) & 0x10 )
      {
        *((_BYTE *)v59 + 329) &= 0xEFu;
        goto LABEL_124;
      }
      if ( (unsigned int)sub_17310((__int64)v59, v59[36]) != -1
        || *__errno_location() == 11
        || *__errno_location() == 115
        || *__errno_location() == 11 )
      {
        *((_QWORD *)v59 + 6) = a3;
        *((_QWORD *)v59 + 7) = a5;
        *(_WORD *)(v5 + 22) = 150;
        *(_WORD *)(v5 + 16) = 3;
        *(_DWORD *)(v5 + 160) = *(_DWORD *)(a5 + 52);
        *(_DWORD *)(v5 + 152) = *(_DWORD *)(v5 + 160) + 1;
        *(_DWORD *)(v5 + 164) = *(_DWORD *)(v5 + 152);
        sub_1659D(v5);
      }
      else
      {
        if ( unk_2250E0 & 2 )
        {
          v28 = __errno_location();
          strerror(*v28);
          __errno_location();
          g_log("Slirp", 128LL, " tcp fconnect errno = %d-%s");
        }
        if ( *__errno_location() == 111 )
        {
          sub_16709(v5, a5, a3, *(_DWORD *)(a5 + 52) + 1, 0, 20, v40);
        }
        else
        {
          if ( v40 == 2 )
          {
            v43 = 0;
            if ( *__errno_location() == 113 )
              v43 = 1;
          }
          else if ( v40 == 10 )
          {
            v43 = 0;
            if ( *__errno_location() == 113 )
              v43 = 3;
          }
          else
          {
            g_assertion_message_expr("Slirp", "../src/tcp_input.c", 659LL, "tcp_input", 0LL);
          }
          *(_DWORD *)(a5 + 52) = htonl(*(_DWORD *)(a5 + 52));
          *(_DWORD *)(a5 + 56) = htonl(*(_DWORD *)(a5 + 56));
          *(_WORD *)(a5 + 62) = htons(*(_WORD *)(a5 + 62));
          *(_WORD *)(a5 + 66) = htons(*(_WORD *)(a5 + 66));
          *(_QWORD *)(a3 + 48) += -48LL - v54;
          *(_DWORD *)(a3 + 56) += v54 + 48;
          if ( v40 == 2 )
          {
            *(_QWORD *)(a3 + 48) += 28LL;
            *(_DWORD *)(a3 + 56) -= 28;
            *v63 = v65;
            v63[1] = v66;
            *((_DWORD *)v63 + 4) = v67;
            v29 = __errno_location();
            strerror(*v29);
            sub_8B39(a3, 3, v43, 0);
          }
          else if ( v40 == 10 )
          {
            *(_QWORD *)(a3 + 48) += 8LL;
            *(_DWORD *)(a3 + 56) -= 8;
            *v64 = v68;
            v64[1] = v69;
            v64[2] = v70;
            v64[3] = v71;
            v64[4] = v72;
            sub_6903(a3, 1u, v43);
          }
          else
          {
            g_assertion_message_expr("Slirp", "../src/tcp_input.c", 687LL, "tcp_input", 0LL);
          }
        }
        sub_17098((_QWORD *)v5);
        sub_A4F0(a3);
      }
      return __readfsqword(0x28u) ^ v105;
    }
  }
  else
  {
    v59 = v39;
    v62 = *((_QWORD *)v39 + 5);
    v5 = *((_QWORD *)v39 + 42);
    v42 = *((_QWORD *)v39 + 6);
    *((_QWORD *)v39 + 6) = 0LL;
    a5 = *((_QWORD *)v39 + 7);
    v51 = *(unsigned __int16 *)(a5 + 62);
    LOBYTE(v6) = *(_BYTE *)(a5 + 61);
    if ( *((_DWORD *)v39 + 83) & 1 )
    {
      v5 = sub_17098((_QWORD *)v5);
LABEL_301:
      if ( v6 & 0x10 )
      {
        sub_16709(v5, a5, v42, 0, *(_DWORD *)(a5 + 56), 4, v40);
      }
      else
      {
        if ( v6 & 2 )
          ++*(_WORD *)(a5 + 46);
        sub_16709(v5, a5, v42, *(unsigned __int16 *)(a5 + 46) + *(_DWORD *)(a5 + 52), 0, 20, v40);
      }
      return __readfsqword(0x28u) ^ v105;
    }
  }
LABEL_124:
  sub_1659D(v5);
  if ( v58 )
    sub_14FE8(v5, v58, v44, a5);
  if ( v50 )
    *(_DWORD *)(v5 + 140) = v50;
  else
    *(_DWORD *)(v5 + 140) = *(_DWORD *)(v62 + 880);
  *(_DWORD *)(v62 + 880) += 64000;
  *(_DWORD *)(v5 + 160) = *(_DWORD *)(a5 + 52);
  *(_DWORD *)(v5 + 128) = *(_DWORD *)(v5 + 140);
  *(_DWORD *)(v5 + 168) = *(_DWORD *)(v5 + 128);
  *(_DWORD *)(v5 + 124) = *(_DWORD *)(v5 + 168);
  *(_DWORD *)(v5 + 120) = *(_DWORD *)(v5 + 124);
  *(_DWORD *)(v5 + 152) = *(_DWORD *)(v5 + 160) + 1;
  *(_DWORD *)(v5 + 164) = *(_DWORD *)(v5 + 152);
  *(_WORD *)(v5 + 36) |= 1u;
  *(_WORD *)(v5 + 16) = 3;
  *(_WORD *)(v5 + 22) = 150;
LABEL_145:
  ++*(_DWORD *)(a5 + 52);
  if ( (unsigned int)*(unsigned __int16 *)(a5 + 46) > *(_DWORD *)(v5 + 148) )
  {
    sub_A875(v42, *(_DWORD *)(v5 + 148) - *(unsigned __int16 *)(a5 + 46));
    *(_WORD *)(a5 + 46) = *(_DWORD *)(v5 + 148);
    LOBYTE(v6) = v6 & 0xFE;
  }
  *(_DWORD *)(v5 + 132) = *(_DWORD *)(a5 + 52) - 1;
  *(_DWORD *)(v5 + 156) = *(_DWORD *)(a5 + 52);
LABEL_251:
  if ( v6 & 0x10
    && (*(_DWORD *)(v5 + 132) - *(_DWORD *)(a5 + 52) < 0
     || *(_DWORD *)(v5 + 132) == *(_DWORD *)(a5 + 52)
     && (*(_DWORD *)(v5 + 136) - *(_DWORD *)(a5 + 56) < 0
      || *(_DWORD *)(v5 + 136) == *(_DWORD *)(a5 + 56) && v51 > *(_DWORD *)(v5 + 144))) )
  {
    *(_DWORD *)(v5 + 144) = v51;
    *(_DWORD *)(v5 + 132) = *(_DWORD *)(a5 + 52);
    *(_DWORD *)(v5 + 136) = *(_DWORD *)(a5 + 56);
    if ( *(_DWORD *)(v5 + 144) > *(_DWORD *)(v5 + 196) )
      *(_DWORD *)(v5 + 196) = *(_DWORD *)(v5 + 144);
    v49 = 1;
  }
  if ( v6 & 0x20 && *(_WORD *)(a5 + 66) && *(_WORD *)(v5 + 16) <= 9 )
  {
    if ( *((_DWORD *)v59 + 90) + (unsigned int)*(unsigned __int16 *)(a5 + 66) <= *((_DWORD *)v59 + 91) )
    {
      if ( *(unsigned __int16 *)(a5 + 66) + *(_DWORD *)(a5 + 52) - *(_DWORD *)(v5 + 156) > 0 )
      {
        *(_DWORD *)(v5 + 156) = *(_DWORD *)(a5 + 52) + *(unsigned __int16 *)(a5 + 66);
        *((_DWORD *)v59 + 16) = *((_DWORD *)v59 + 90) + *(_DWORD *)(v5 + 156) - *(_DWORD *)(v5 + 152);
        *(_DWORD *)(v5 + 156) = *(_DWORD *)(a5 + 52) + *(unsigned __int16 *)(a5 + 66);
      }
    }
    else
    {
      *(_WORD *)(a5 + 66) = 0;
      LOBYTE(v6) = v6 & 0xDF;
    }
  }
  else if ( *(_DWORD *)(v5 + 152) - *(_DWORD *)(v5 + 156) > 0 )
  {
    *(_DWORD *)(v5 + 156) = *(_DWORD *)(v5 + 152);
  }
  if ( *(_WORD *)(a5 + 46) && *(_WORD *)(a5 + 46) <= 5u && *(_BYTE *)(a5 + 68) == 27 )
    *(_WORD *)(v5 + 36) |= 1u;
  if ( (*(_WORD *)(a5 + 46) || v6 & 1) && *(_WORD *)(v5 + 16) <= 9 )
  {
    if ( *(_DWORD *)(a5 + 52) != *(_DWORD *)(v5 + 152) || v5 != *(_QWORD *)v5 || *(_WORD *)(v5 + 16) != 4 )
    {
      v37 = sub_12A0D((_DWORD *)v5, a5, v42);
      *(_WORD *)(v5 + 36) |= 1u;
    }
    else
    {
      *(_WORD *)(v5 + 36) |= 2u;
      *(_DWORD *)(v5 + 152) += *(unsigned __int16 *)(a5 + 46);
      v37 = *(_BYTE *)(a5 + 61) & 1;
      if ( *((_BYTE *)v59 + 329) )
      {
        if ( (unsigned int)sub_17D52((__int64)v59, v42) )
          sub_C59C((__int64)v59, v42);
      }
      else
      {
        sub_C59C((__int64)v59, v42);
      }
    }
  }
  else
  {
    sub_A4F0(v42);
    v37 = v6 & 0xFE;
  }
  if ( v37 & 1 )
  {
    if ( *(_WORD *)(v5 + 16) <= 9 )
    {
      sub_11C8C((__int64)v59);
      *(_WORD *)(v5 + 36) |= 1u;
      ++*(_DWORD *)(v5 + 152);
    }
    switch ( *(signed __int16 *)(v5 + 16) )
    {
      case 3:
      case 4:
        if ( *((_BYTE *)v59 + 329) == 1 )
          *(_WORD *)(v5 + 16) = 8;
        else
          *(_WORD *)(v5 + 16) = 5;
        break;
      case 6:
        *(_WORD *)(v5 + 16) = 7;
        break;
      case 9:
        *(_WORD *)(v5 + 16) = 10;
        sub_1949B(v5);
        *(_WORD *)(v5 + 24) = 20;
        break;
      case 10:
        *(_WORD *)(v5 + 24) = 20;
        break;
      default:
        break;
    }
  }
  if ( v49 || *(_WORD *)(v5 + 36) & 1 )
    sub_15563(v5);
  return __readfsqword(0x28u) ^ v105;
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000014FE8) ----------------------------------------------------
unsigned __int64 __fastcall sub_14FE8(__int64 a1, unsigned __int8 *a2, int a3, __int64 a4)
{
  uint16_t v4; // ST2E_2
  __int64 v6; // [rsp+0h] [rbp-40h]
  int v7; // [rsp+Ch] [rbp-34h]
  unsigned __int8 *v8; // [rsp+10h] [rbp-30h]
  signed int v9; // [rsp+30h] [rbp-10h]
  int v10; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v11; // [rsp+38h] [rbp-8h]

  v8 = a2;
  v7 = a3;
  v6 = a4;
  v11 = __readfsqword(0x28u);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_dooptions...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p  cnt=%i");
  while ( v7 > 0 )
  {
    v10 = *v8;
    if ( !*v8 )
      break;
    if ( v10 == 1 )
    {
      v9 = 1;
    }
    else
    {
      v9 = v8[1];
      if ( v9 <= 0 )
        return __readfsqword(0x28u) ^ v11;
    }
    if ( v10 == 2 && v9 == 4 && *(_BYTE *)(v6 + 61) & 2 )
    {
      v4 = ntohs(*((_WORD *)v8 + 1));
      sub_15314(a1, v4);
    }
    v7 -= v9;
    v8 += v9;
  }
  return __readfsqword(0x28u) ^ v11;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001514F) ----------------------------------------------------
__int64 __fastcall sub_1514F(_WORD *a1, int a2)
{
  int v2; // eax
  int v3; // er12
  __int64 result; // rax

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_xmit_timer...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " rtt = %d");
  if ( a1[94] )
  {
    v2 = (unsigned __int16)a1[94];
    LOWORD(v2) = (signed __int16)v2 >> 3;
    v3 = a2 - v2 - 1;
    a1[94] += a2 - v2 - 1;
    if ( a1[94] <= 0 )
      a1[94] = 1;
    if ( (v3 & 0x8000u) != 0 )
      v3 = 1 - (a2 - v2);
    a1[95] += v3 - (a1[95] >> 2);
    if ( a1[95] <= 0 )
      a1[95] = 1;
  }
  else
  {
    a1[94] = 8 * a2;
    a1[95] = 2 * a2;
  }
  a1[91] = 0;
  a1[13] = 0;
  a1[14] = (a1[94] >> 3) + a1[95];
  if ( a1[14] >= a1[96] )
  {
    result = (unsigned __int16)a1[14];
    if ( (signed __int16)result > 24 )
      a1[14] = 24;
  }
  else
  {
    result = (unsigned __int16)a1[96];
    a1[14] = result;
  }
  a1[101] = 0;
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000015314) ----------------------------------------------------
__int64 __fastcall sub_15314(__int64 a1, unsigned int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  signed int v6; // eax
  signed __int16 v7; // ax
  void *v8; // rax
  void *v9; // rax
  int v11; // [rsp+14h] [rbp-Ch]
  signed int v12; // [rsp+14h] [rbp-Ch]
  __int64 v13; // [rsp+18h] [rbp-8h]

  v13 = *(_QWORD *)(a1 + 112);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_mss...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " offer = %d");
  v2 = *(unsigned __int16 *)(v13 + 72);
  if ( v2 == 2 )
  {
    v3 = *(_DWORD *)(*(_QWORD *)(v13 + 40) + 136LL);
    if ( *(_DWORD *)(*(_QWORD *)(v13 + 40) + 140LL) <= v3 )
      v3 = *(_DWORD *)(*(_QWORD *)(v13 + 40) + 140LL);
    v11 = v3 - 40;
  }
  else if ( v2 == 10 )
  {
    v4 = *(_DWORD *)(*(_QWORD *)(v13 + 40) + 136LL);
    if ( *(_DWORD *)(*(_QWORD *)(v13 + 40) + 140LL) <= v4 )
      v4 = *(_DWORD *)(*(_QWORD *)(v13 + 40) + 140LL);
    v11 = v4 - 60;
  }
  else
  {
    g_assertion_message_expr("Slirp", "../src/tcp_input.c", 1521LL, "tcp_mss", 0LL);
  }
  if ( a2 )
  {
    v5 = v11;
    if ( a2 <= v11 )
      v5 = a2;
    v11 = v5;
  }
  v6 = 32;
  if ( v11 >= 32 )
    v6 = v11;
  v12 = v6;
  if ( v6 < *(unsigned __int16 *)(a1 + 32) || a2 )
  {
    v7 = -32768;
    if ( v12 <= 0x8000 )
      v7 = v12;
    *(_WORD *)(a1 + 32) = v7;
  }
  *(_DWORD *)(a1 + 172) = v12;
  if ( (unsigned int)((signed __int64)&unk_20000 % v12) )
    LODWORD(v8) = v12 - (unsigned __int64)((signed __int64)&unk_20000 % v12) + 0x20000;
  else
    v8 = &unk_20000;
  sub_C48D(v13 + 392, (unsigned int)v8);
  if ( (unsigned int)((signed __int64)&unk_20000 % v12) )
    LODWORD(v9) = v12 - (unsigned __int64)((signed __int64)&unk_20000 % v12) + 0x20000;
  else
    v9 = &unk_20000;
  sub_C48D(v13 + 360, (unsigned int)v9);
  if ( unk_2250E0 & 2 )
    g_log("Slirp", 128LL, " returning mss = %d");
  return (unsigned int)v12;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000015563) ----------------------------------------------------
__int64 __fastcall sub_15563(__int64 a1)
{
  __int64 v1; // r13
  unsigned int v2; // eax
  signed __int64 v3; // r15
  signed __int64 v4; // rax
  signed __int64 v5; // r12
  signed __int64 v6; // r15
  signed __int64 v7; // rax
  uint16_t v9; // ax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int16 v14; // ST06_2
  __int16 v15; // ax
  _QWORD *v16; // rax
  int v17; // eax
  __int64 v18; // ST48_8
  __int64 v19; // ST40_8
  char v20; // [rsp+18h] [rbp-E8h]
  unsigned int v21; // [rsp+1Ch] [rbp-E4h]
  unsigned int n; // [rsp+20h] [rbp-E0h]
  signed int n_4; // [rsp+24h] [rbp-DCh]
  int v24; // [rsp+2Ch] [rbp-D4h]
  unsigned int v25; // [rsp+30h] [rbp-D0h]
  int v26; // [rsp+34h] [rbp-CCh]
  signed __int64 v27; // [rsp+38h] [rbp-C8h]
  __int64 v28; // [rsp+58h] [rbp-A8h]
  __int64 v29; // [rsp+60h] [rbp-A0h]
  __int64 v30; // [rsp+68h] [rbp-98h]
  __int64 v31; // [rsp+70h] [rbp-90h]
  __int64 v32; // [rsp+78h] [rbp-88h]
  char src; // [rsp+A0h] [rbp-60h]
  char v34; // [rsp+A1h] [rbp-5Fh]
  uint16_t v35; // [rsp+A2h] [rbp-5Eh]
  unsigned __int64 v36; // [rsp+C8h] [rbp-38h]

  v36 = __readfsqword(0x28u);
  v1 = *(_QWORD *)(a1 + 112);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_output...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p");
  if ( *(_DWORD *)(a1 + 168) == *(_DWORD *)(a1 + 120) && *(_WORD *)(a1 + 180) >= *(_WORD *)(a1 + 28) )
    *(_DWORD *)(a1 + 172) = *(unsigned __int16 *)(a1 + 32);
  while ( 1 )
  {
    n_4 = 0;
    v24 = *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120);
    v2 = *(_DWORD *)(a1 + 144);
    if ( *(_DWORD *)(a1 + 172) <= v2 )
      v2 = *(_DWORD *)(a1 + 172);
    v3 = v2;
    v20 = byte_1E7D8[*(signed __int16 *)(a1 + 16)];
    if ( unk_2250E0 & 2 )
      g_log("Slirp", 128LL, " --- tcp_output flags = 0x%x");
    if ( *(_BYTE *)(a1 + 34) )
    {
      if ( v3 )
      {
        *(_WORD *)(a1 + 20) = 0;
        *(_WORD *)(a1 + 26) = 0;
      }
      else
      {
        if ( *(_DWORD *)(v1 + 392) > (unsigned int)v24 )
          v20 &= 0xFEu;
        v3 = 1LL;
      }
    }
    v4 = *(unsigned int *)(v1 + 392);
    if ( v3 <= v4 )
      v4 = v3;
    v5 = v4 - v24;
    if ( v5 < 0 )
    {
      v5 = 0LL;
      if ( !v3 )
      {
        *(_WORD *)(a1 + 18) = 0;
        *(_DWORD *)(a1 + 124) = *(_DWORD *)(a1 + 120);
      }
    }
    if ( v5 > *(unsigned __int16 *)(a1 + 32) )
    {
      v5 = *(unsigned __int16 *)(a1 + 32);
      n_4 = 1;
    }
    if ( *(_DWORD *)(a1 + 124) + (signed int)v5 - (*(_DWORD *)(a1 + 120) + *(_DWORD *)(v1 + 392)) < 0 )
      v20 &= 0xFEu;
    v6 = (unsigned int)(*(_DWORD *)(v1 + 364) - *(_DWORD *)(v1 + 360));
    if ( !v5
      || v5 != *(unsigned __int16 *)(a1 + 32)
      && v5 + v24 < *(unsigned int *)(v1 + 392)
      && !*(_BYTE *)(a1 + 34)
      && (v5 < (unsigned int)(*(_DWORD *)(a1 + 196) >> 1) || !*(_DWORD *)(a1 + 196))
      && *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 168) >= 0 )
    {
      if ( v6 <= 0 )
        goto LABEL_116;
      v7 = 0xFFFFLL << *(_BYTE *)(a1 + 205);
      if ( v6 <= v7 )
        v7 = (unsigned int)(*(_DWORD *)(v1 + 364) - *(_DWORD *)(v1 + 360));
      v27 = v7 - (unsigned int)(*(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 152));
      if ( v27 < 2 * *(unsigned __int16 *)(a1 + 32) && 2 * v27 < *(unsigned int *)(v1 + 364) )
      {
LABEL_116:
        if ( !(*(_WORD *)(a1 + 36) & 1)
          && !(v20 & 6)
          && *(_DWORD *)(a1 + 128) - *(_DWORD *)(a1 + 120) <= 0
          && (!(v20 & 1) || *(_WORD *)(a1 + 36) & 0x10 && *(_DWORD *)(a1 + 124) != *(_DWORD *)(a1 + 120)) )
        {
          break;
        }
      }
    }
    n = 0;
    if ( v20 & 2 )
    {
      *(_DWORD *)(a1 + 124) = *(_DWORD *)(a1 + 140);
      if ( !(*(_WORD *)(a1 + 36) & 8) )
      {
        src = 2;
        v34 = 4;
        v9 = sub_15314(a1, 0);
        v35 = htons(v9);
        n = 4;
      }
    }
    v25 = n + 68;
    if ( v5 > *(unsigned __int16 *)(a1 + 32) - n )
    {
      v5 = *(unsigned __int16 *)(a1 + 32) - n;
      n_4 = 1;
    }
    if ( v5 )
    {
      v10 = sub_A39A(*(_QWORD *)(v1 + 40));
      v11 = v10;
      if ( !v10 )
        return 1;
      *(_QWORD *)(v10 + 48) += 16LL;
      *(_DWORD *)(v10 + 56) = v25;
      sub_C938((int *)(v1 + 392), v24, v5, (char *)(v25 + *(_QWORD *)(v10 + 48)));
      *(_DWORD *)(v11 + 56) += v5;
      if ( v5 + v24 == *(_DWORD *)(v1 + 392) )
        v20 |= 8u;
    }
    else
    {
      v12 = sub_A39A(*(_QWORD *)(v1 + 40));
      v11 = v12;
      if ( !v12 )
        return 1;
      *(_QWORD *)(v12 + 48) += 16LL;
      *(_DWORD *)(v12 + 56) = v25;
    }
    v13 = *(_QWORD *)(v11 + 48);
    memcpy(*(void **)(v11 + 48), (const void *)(a1 + 40), 0x44uLL);
    if ( v20 & 1 && *(_WORD *)(a1 + 36) & 0x10 && *(_DWORD *)(a1 + 124) == *(_DWORD *)(a1 + 168) )
      --*(_DWORD *)(a1 + 124);
    if ( v5 || v20 & 3 || *(_WORD *)(a1 + 20) )
      *(_DWORD *)(v13 + 52) = htonl(*(_DWORD *)(a1 + 124));
    else
      *(_DWORD *)(v13 + 52) = htonl(*(_DWORD *)(a1 + 168));
    *(_DWORD *)(v13 + 56) = htonl(*(_DWORD *)(a1 + 152));
    if ( n )
    {
      memcpy((void *)(v13 + 68), &src, n);
      *(_BYTE *)(v13 + 60) = 16 * ((((unsigned __int64)n + 20) >> 2) & 0xF) | *(_BYTE *)(v13 + 60) & 0xF;
    }
    *(_BYTE *)(v13 + 61) = v20;
    if ( v6 < (unsigned int)(*(_DWORD *)(v1 + 364) >> 2) && v6 < *(unsigned __int16 *)(a1 + 32) )
      v6 = 0LL;
    if ( v6 > 0xFFFFLL << *(_BYTE *)(a1 + 205) )
      v6 = 0xFFFFLL << *(_BYTE *)(a1 + 205);
    if ( v6 < (unsigned int)(*(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 152)) )
      v6 = (unsigned int)(*(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 152));
    *(_WORD *)(v13 + 62) = htons(v6 >> *(_BYTE *)(a1 + 205));
    if ( *(_DWORD *)(a1 + 128) - *(_DWORD *)(a1 + 120) <= 0 )
    {
      *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 120);
    }
    else
    {
      v14 = *(_DWORD *)(a1 + 128);
      v15 = ntohl(*(_DWORD *)(v13 + 52));
      *(_WORD *)(v13 + 66) = htons(v14 - v15);
      *(_BYTE *)(v13 + 61) |= 0x20u;
    }
    if ( v5 + n )
      *(_WORD *)(v13 + 46) = htons(n + v5 + 20);
    *(_WORD *)(v13 + 64) = sub_44C3(v11, (unsigned int)v5 + v25);
    if ( *(_BYTE *)(a1 + 34) && *(_WORD *)(a1 + 20) )
    {
      if ( *(_DWORD *)(a1 + 124) + (signed int)v5 - *(_DWORD *)(a1 + 168) > 0 )
        *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 124) + v5;
    }
    else
    {
      v26 = *(_DWORD *)(a1 + 124);
      if ( v20 & 3 )
      {
        if ( v20 & 2 )
          ++*(_DWORD *)(a1 + 124);
        if ( v20 & 1 )
        {
          ++*(_DWORD *)(a1 + 124);
          *(_WORD *)(a1 + 36) |= 0x10u;
        }
      }
      *(_DWORD *)(a1 + 124) += v5;
      if ( *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 168) > 0 )
      {
        *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 124);
        if ( !*(_WORD *)(a1 + 182) )
        {
          *(_WORD *)(a1 + 182) = 1;
          *(_DWORD *)(a1 + 184) = v26;
        }
      }
      if ( !*(_WORD *)(a1 + 18) && *(_DWORD *)(a1 + 124) != *(_DWORD *)(a1 + 120) )
      {
        *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 28);
        if ( *(_WORD *)(a1 + 20) )
        {
          *(_WORD *)(a1 + 20) = 0;
          *(_WORD *)(a1 + 26) = 0;
        }
      }
    }
    *(_DWORD *)(v11 + 56) = v5 + v25;
    v16 = *(_QWORD **)(v11 + 48);
    v28 = v16[1];
    v29 = v16[2];
    v30 = v16[3];
    v31 = v16[4];
    v32 = v16[5];
    v17 = *(unsigned __int16 *)(v1 + 72);
    if ( v17 == 2 )
    {
      *(_QWORD *)(v11 + 48) += 28LL;
      *(_DWORD *)(v11 + 56) -= 28;
      v18 = *(_QWORD *)(v11 + 48);
      *(_WORD *)(v18 + 2) = *(_DWORD *)(v11 + 56);
      *(_QWORD *)(v18 + 12) = v28;
      *(_BYTE *)(v18 + 9) = BYTE1(v29);
      *(_BYTE *)(v18 + 8) = 64;
      *(_BYTE *)(v18 + 1) = *(_BYTE *)(v1 + 328);
      v21 = sub_9E96(v1, v11);
    }
    else if ( v17 == 10 )
    {
      *(_QWORD *)(v11 + 48) += 8LL;
      *(_DWORD *)(v11 + 56) -= 8;
      v19 = *(_QWORD *)(v11 + 48);
      *(_WORD *)(v19 + 4) = HIWORD(v32);
      *(_QWORD *)(v19 + 24) = v30;
      *(_QWORD *)(v19 + 32) = v31;
      *(_QWORD *)(v19 + 8) = v28;
      *(_QWORD *)(v19 + 16) = v29;
      *(_BYTE *)(v19 + 6) = BYTE1(v32);
      v21 = sub_80BC(v1, v11, 0);
    }
    else
    {
      g_assertion_message_expr("Slirp", "../src/tcp_output.c", 481LL, "tcp_output", 0LL);
    }
    if ( v21 )
      return v21;
    if ( v6 > 0 && *(_DWORD *)(a1 + 152) + (signed int)v6 - *(_DWORD *)(a1 + 164) > 0 )
      *(_DWORD *)(a1 + 164) = *(_DWORD *)(a1 + 152) + v6;
    *(_DWORD *)(a1 + 216) = *(_DWORD *)(a1 + 152);
    *(_WORD *)(a1 + 36) &= 0xFFFCu;
    if ( !n_4 )
      return 0LL;
  }
  if ( *(_DWORD *)(v1 + 392) && !*(_WORD *)(a1 + 18) && !*(_WORD *)(a1 + 20) )
  {
    *(_WORD *)(a1 + 26) = 0;
    sub_16346((_WORD *)a1);
  }
  return 0LL;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000016346) ----------------------------------------------------
unsigned __int64 __fastcall sub_16346(_WORD *a1)
{
  unsigned __int64 result; // rax

  a1[10] = word_1EC60[2 * (signed __int16)a1[13]] * (((signed __int16)(a1[94] >> 2) + (signed __int16)a1[95]) >> 1);
  if ( a1[10] > 9 )
  {
    if ( a1[10] > 120 )
      a1[10] = 120;
  }
  else
  {
    a1[10] = 10;
  }
  result = (unsigned __int16)a1[13];
  if ( (signed __int16)result <= 11 )
  {
    result = (unsigned __int64)a1;
    ++a1[13];
  }
  return result;
}

//----- (00000000000163F5) ----------------------------------------------------
int __fastcall sub_163F5(int a1)
{
  int optval; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  optval = 1;
  return setsockopt(a1, 6, 1, &optval, 4u);
}

//----- (000000000001644D) ----------------------------------------------------
int __fastcall sub_1644D(int a1)
{
  int optval; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  optval = 1;
  return setsockopt(a1, 1, 2, &optval, 4u);
}

//----- (00000000000164A5) ----------------------------------------------------
__int64 __fastcall sub_164A5(unsigned __int16 *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( v1 == 2 )
    return 16LL;
  if ( v1 == 10 )
    return 28LL;
  return g_assertion_message_expr("Slirp", "../src/socket.h", 136LL, "sockaddr_size", 0LL);
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000164FC) ----------------------------------------------------
__int64 __fastcall sub_164FC(__int64 a1)
{
  _QWORD *v1; // ST00_8
  __int64 result; // rax

  v1 = (_QWORD *)a1;
  *(_DWORD *)(a1 + 880) = 1;
  v1[57] = v1 + 56;
  v1[56] = v1[57];
  result = a1;
  v1[109] = v1 + 56;
  return result;
}

//----- (0000000000016557) ----------------------------------------------------
__int64 __fastcall sub_16557(__int64 a1)
{
  __int64 result; // rax

  while ( 1 )
  {
    result = *(_QWORD *)(a1 + 448);
    if ( result == a1 + 448 )
      break;
    sub_17098(*(_QWORD **)(*(_QWORD *)(a1 + 448) + 336LL));
  }
  return result;
}

//----- (000000000001659D) ----------------------------------------------------
__int64 __fastcall sub_1659D(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 result; // rax
  __int64 v5; // [rsp+18h] [rbp-18h]

  v5 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 40) = 0LL;
  memset((void *)(a1 + 48), 0, 0x24uLL);
  *(_WORD *)(a1 + 84) = 0;
  v1 = *(unsigned __int16 *)(v5 + 72);
  if ( v1 == 2 )
  {
    *(_BYTE *)(a1 + 57) = 6;
    *(_WORD *)(a1 + 86) = htons(0x14u);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v5 + 76);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v5 + 204);
    *(_WORD *)(a1 + 88) = *(_WORD *)(v5 + 74);
    *(_WORD *)(a1 + 90) = *(_WORD *)(v5 + 202);
  }
  else if ( v1 == 10 )
  {
    *(_BYTE *)(a1 + 81) = 6;
    *(_WORD *)(a1 + 86) = htons(0x14u);
    v2 = *(_QWORD *)(v5 + 88);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(v5 + 80);
    *(_QWORD *)(a1 + 56) = v2;
    v3 = *(_QWORD *)(v5 + 216);
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(v5 + 208);
    *(_QWORD *)(a1 + 72) = v3;
    *(_WORD *)(a1 + 88) = *(_WORD *)(v5 + 74);
    *(_WORD *)(a1 + 90) = *(_WORD *)(v5 + 202);
  }
  else
  {
    g_assertion_message_expr("Slirp", "../src/tcp_subr.c", 96LL, "tcp_template", 0LL);
  }
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 100) &= 0xF0u;
  result = *(_BYTE *)(a1 + 100) & 0xF | 0x50u;
  *(_WORD *)(a1 + 100) = *(_BYTE *)(a1 + 100) & 0xF | 0x50;
  *(_WORD *)(a1 + 102) = 0;
  *(_WORD *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 106) = 0;
  return result;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000016709) ----------------------------------------------------
unsigned __int64 __fastcall sub_16709(__int64 a1, __int64 a2, __int64 a3, uint32_t a4, uint32_t a5, char a6, __int16 a7)
{
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rbx
  int v12; // ST3C_4
  __int16 v13; // ST36_2
  __int64 v14; // ST50_8
  __int64 v15; // ST58_8
  __int64 v16; // rdx
  __int16 v17; // ST34_2
  uint16_t v18; // dx
  _QWORD *v19; // rax
  __int64 v20; // ST40_8
  char v22; // [rsp+Ch] [rbp-A4h]
  uint32_t hostlong; // [rsp+10h] [rbp-A0h]
  uint32_t v24; // [rsp+14h] [rbp-9Ch]
  __int64 v25; // [rsp+18h] [rbp-98h]
  __int64 v26; // [rsp+20h] [rbp-90h]
  int v27; // [rsp+38h] [rbp-78h]
  __int64 v28; // [rsp+48h] [rbp-68h]
  __int64 v29; // [rsp+58h] [rbp-58h]
  __int64 v30; // [rsp+60h] [rbp-50h]
  __int64 v31; // [rsp+68h] [rbp-48h]
  __int64 v32; // [rsp+70h] [rbp-40h]
  __int64 v33; // [rsp+78h] [rbp-38h]
  unsigned __int64 v34; // [rsp+98h] [rbp-18h]

  v26 = a2;
  v25 = a3;
  v24 = a4;
  hostlong = a5;
  v22 = a6;
  v34 = __readfsqword(0x28u);
  v27 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_respond...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ti = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " ack = %u");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " seq = %u");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " flags = %x");
  if ( a1 )
    v27 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 364LL) - *(_DWORD *)(*(_QWORD *)(a1 + 112) + 360LL);
  if ( v25 )
  {
    *(_QWORD *)(v25 + 48) = a2;
    *(_DWORD *)(v25 + 56) = 68;
    if ( a7 == 2 )
    {
      v12 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = v12;
      v13 = *(_WORD *)(a2 + 50);
      *(_WORD *)(a2 + 50) = *(_WORD *)(a2 + 48);
      *(_WORD *)(a2 + 48) = v13;
    }
    else if ( a7 == 10 )
    {
      v14 = *(_QWORD *)(a2 + 24);
      v15 = *(_QWORD *)(a2 + 32);
      v16 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 24) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 32) = v16;
      *(_QWORD *)(a2 + 8) = v14;
      *(_QWORD *)(a2 + 16) = v15;
      v17 = *(_WORD *)(a2 + 50);
      *(_WORD *)(a2 + 50) = *(_WORD *)(a2 + 48);
      *(_WORD *)(a2 + 48) = v17;
    }
    else
    {
      g_assertion_message_expr("Slirp", "../src/tcp_subr.c", 182LL, "tcp_respond", 0LL);
    }
  }
  else
  {
    if ( !a1 )
      return __readfsqword(0x28u) ^ v34;
    v25 = sub_A39A(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 40LL));
    if ( !v25 )
      return __readfsqword(0x28u) ^ v34;
    *(_QWORD *)(v25 + 48) += 16LL;
    v7 = *(_QWORD *)(v25 + 48);
    v8 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)v7 = *(_QWORD *)a2;
    *(_QWORD *)(v7 + 8) = v8;
    v9 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(v7 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(v7 + 24) = v9;
    v10 = *(_QWORD *)(a2 + 40);
    *(_QWORD *)(v7 + 32) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(v7 + 40) = v10;
    v11 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(v7 + 48) = *(_QWORD *)(a2 + 48);
    *(_QWORD *)(v7 + 56) = v11;
    *(_DWORD *)(v7 + 64) = *(_DWORD *)(a2 + 64);
    v26 = *(_QWORD *)(v25 + 48);
    if ( a7 == 2 )
    {
      *(_BYTE *)(v26 + 16) = 0;
    }
    else if ( a7 == 10 )
    {
      *(_BYTE *)(v26 + 40) = 0;
    }
    else
    {
      g_assertion_message_expr("Slirp", "../src/tcp_subr.c", 153LL, "tcp_respond", 0LL);
    }
    v22 = 16;
  }
  *(_WORD *)(v26 + 46) = htons(0x14u);
  *(_DWORD *)(v25 + 56) = 68;
  *(_QWORD *)v26 = 0LL;
  *(_WORD *)(v26 + 44) = 0;
  *(_DWORD *)(v26 + 52) = htonl(hostlong);
  *(_DWORD *)(v26 + 56) = htonl(v24);
  *(_BYTE *)(v26 + 60) &= 0xF0u;
  *(_BYTE *)(v26 + 60) = *(_BYTE *)(v26 + 60) & 0xF | 0x50;
  *(_BYTE *)(v26 + 61) = v22;
  if ( a1 )
    v18 = htons(v27 >> *(_BYTE *)(a1 + 205));
  else
    v18 = htons(v27);
  *(_WORD *)(v26 + 62) = v18;
  *(_WORD *)(v26 + 66) = 0;
  *(_WORD *)(v26 + 64) = 0;
  *(_WORD *)(v26 + 64) = sub_44C3(v25, 68);
  v19 = *(_QWORD **)(v25 + 48);
  v29 = v19[1];
  v30 = v19[2];
  v31 = v19[3];
  v32 = v19[4];
  v33 = v19[5];
  if ( a7 == 2 )
  {
    *(_QWORD *)(v25 + 48) += 28LL;
    *(_DWORD *)(v25 + 56) -= 28;
    v28 = *(_QWORD *)(v25 + 48);
    *(_WORD *)(v28 + 2) = *(_DWORD *)(v25 + 56);
    *(_QWORD *)(v28 + 12) = v29;
    *(_BYTE *)(v28 + 9) = BYTE1(v30);
    if ( v22 & 4 )
      *(_BYTE *)(v28 + 8) = -1;
    else
      *(_BYTE *)(v28 + 8) = 64;
    sub_9E96(0LL, v25);
  }
  else if ( a7 == 10 )
  {
    *(_QWORD *)(v25 + 48) += 8LL;
    *(_DWORD *)(v25 + 56) -= 8;
    v20 = *(_QWORD *)(v25 + 48);
    *(_WORD *)(v20 + 4) = HIWORD(v33);
    *(_QWORD *)(v20 + 24) = v31;
    *(_QWORD *)(v20 + 32) = v32;
    *(_QWORD *)(v20 + 8) = v29;
    *(_QWORD *)(v20 + 16) = v30;
    *(_BYTE *)(v20 + 6) = BYTE1(v33);
    sub_80BC(0LL, v25, 0);
  }
  else
  {
    g_assertion_message_expr("Slirp", "../src/tcp_subr.c", 245LL, "tcp_respond", 0LL);
  }
  return __readfsqword(0x28u) ^ v34;
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000016EBD) ----------------------------------------------------
_QWORD *__fastcall sub_16EBD(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx
  signed int v4; // eax
  int v5; // eax

  v1 = malloc(0xE0uLL);
  v2 = v1;
  if ( !v1 )
    return 0LL;
  memset(v1, 0, 0xE0uLL);
  v2[1] = v2;
  *v2 = v2[1];
  if ( *(_WORD *)(a1 + 72) == 2 )
    v4 = 40;
  else
    v4 = 60;
  v5 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 136LL) - v4;
  if ( v5 > 0x8000 )
    LOWORD(v5) = -32768;
  *((_WORD *)v2 + 16) = v5;
  *((_WORD *)v2 + 18) = 0;
  v2[14] = a1;
  *((_WORD *)v2 + 94) = 0;
  *((_WORD *)v2 + 95) = 24;
  *((_WORD *)v2 + 96) = 2;
  *((_WORD *)v2 + 14) = 12;
  if ( *((_WORD *)v2 + 14) > 1 )
  {
    if ( *((_WORD *)v2 + 14) > 24 )
      *((_WORD *)v2 + 14) = 24;
  }
  else
  {
    *((_WORD *)v2 + 14) = 2;
  }
  *((_DWORD *)v2 + 43) = 1073725440;
  *((_DWORD *)v2 + 44) = 1073725440;
  *((_WORD *)v2 + 8) = 0;
  *(_QWORD *)(a1 + 336) = v2;
  return v2;
}

//----- (0000000000016FC0) ----------------------------------------------------
__int64 __fastcall sub_16FC0(__int64 a1)
{
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_drop...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p");
  if ( unk_2250E0 & 1 )
  {
    __errno_location();
    g_log("Slirp", 128LL, " errno = %d");
  }
  if ( *(_WORD *)(a1 + 16) > 2 )
  {
    *(_WORD *)(a1 + 16) = 0;
    sub_15563(a1);
  }
  return sub_17098((_QWORD *)a1);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000017098) ----------------------------------------------------
__int64 __fastcall sub_17098(_QWORD *a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // r12
  __int64 v4; // [rsp+10h] [rbp-20h]
  __int64 v5; // [rsp+18h] [rbp-18h]

  v4 = a1[14];
  v5 = *(_QWORD *)(v4 + 40);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_close...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " tp = %p");
  v1 = *a1 + 16LL;
  while ( a1 != (_QWORD *)(v1 - 16) )
  {
    v1 = *(_QWORD *)(v1 - 16) + 16LL;
    v2 = *(_QWORD *)(*(_QWORD *)(v1 - 16 + 8) + 16LL);
    sub_AB7F(*(_QWORD **)(v1 - 16 + 8));
    sub_A4F0(v2);
  }
  free(a1);
  *(_QWORD *)(v4 + 336) = 0LL;
  if ( v4 == *(_QWORD *)(v5 + 872) )
    *(_QWORD *)(v5 + 872) = v5 + 448;
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 5992LL) + 56LL))(
    *(unsigned int *)(v4 + 16),
    *(_QWORD *)(*(_QWORD *)(v4 + 40) + 6000LL));
  close(*(_DWORD *)(v4 + 16));
  sub_C3AB(v4 + 360);
  sub_C3AB(v4 + 392);
  sub_F77A(v4);
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000017227) ----------------------------------------------------
__int64 __fastcall sub_17227(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // ST08_8

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_sockclosed...");
  result = unk_2250E0 & 1;
  if ( unk_2250E0 & 1 )
    result = g_log("Slirp", 128LL, " tp = %p");
  if ( a1 )
  {
    switch ( *(signed __int16 *)(a1 + 16) )
    {
      case 0:
      case 1:
      case 2:
        *(_WORD *)(a1 + 16) = 0;
        v2 = sub_17098((_QWORD *)a1);
        return sub_15563(v2);
      case 3:
      case 4:
        *(_WORD *)(a1 + 16) = 6;
        break;
      case 5:
        *(_WORD *)(a1 + 16) = 8;
        break;
      default:
        break;
    }
    result = sub_15563(a1);
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000017310) ----------------------------------------------------
signed __int64 __fastcall sub_17310(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rdx
  socklen_t v11; // eax
  int optval; // [rsp+14h] [rbp-9Ch]
  int v13; // [rsp+18h] [rbp-98h]
  int fd; // [rsp+1Ch] [rbp-94h]
  struct sockaddr addr; // [rsp+20h] [rbp-90h]
  __int64 v16; // [rsp+30h] [rbp-80h]
  __int64 v17; // [rsp+38h] [rbp-78h]
  __int64 v18; // [rsp+40h] [rbp-70h]
  __int64 v19; // [rsp+48h] [rbp-68h]
  __int64 v20; // [rsp+50h] [rbp-60h]
  __int64 v21; // [rsp+58h] [rbp-58h]
  __int64 v22; // [rsp+60h] [rbp-50h]
  __int64 v23; // [rsp+68h] [rbp-48h]
  __int64 v24; // [rsp+70h] [rbp-40h]
  __int64 v25; // [rsp+78h] [rbp-38h]
  __int64 v26; // [rsp+80h] [rbp-30h]
  __int64 v27; // [rsp+88h] [rbp-28h]
  __int64 v28; // [rsp+90h] [rbp-20h]
  __int64 v29; // [rsp+98h] [rbp-18h]
  unsigned __int64 v30; // [rsp+A8h] [rbp-8h]

  v30 = __readfsqword(0x28u);
  v13 = 0;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_fconnect...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  *(_DWORD *)(a1 + 16) = sub_1C25E(a2, 1, 0);
  v13 = *(_DWORD *)(a1 + 16);
  if ( v13 >= 0 )
  {
    fd = *(_DWORD *)(a1 + 16);
    sub_1C142(fd);
    (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 5992LL) + 48LL))(
      *(unsigned int *)(a1 + 16),
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 6000LL));
    sub_1644D(fd);
    optval = 1;
    setsockopt(fd, 1, 10, &optval, 4u);
    optval = 1;
    setsockopt(fd, 6, 1, &optval, 4u);
    v2 = *(_QWORD *)(a1 + 80);
    *(_QWORD *)&addr.sa_family = *(_QWORD *)(a1 + 72);
    *(_QWORD *)&addr.sa_data[6] = v2;
    v3 = *(_QWORD *)(a1 + 96);
    v16 = *(_QWORD *)(a1 + 88);
    v17 = v3;
    v4 = *(_QWORD *)(a1 + 112);
    v18 = *(_QWORD *)(a1 + 104);
    v19 = v4;
    v5 = *(_QWORD *)(a1 + 128);
    v20 = *(_QWORD *)(a1 + 120);
    v21 = v5;
    v6 = *(_QWORD *)(a1 + 144);
    v22 = *(_QWORD *)(a1 + 136);
    v23 = v6;
    v7 = *(_QWORD *)(a1 + 160);
    v24 = *(_QWORD *)(a1 + 152);
    v25 = v7;
    v8 = *(_QWORD *)(a1 + 176);
    v26 = *(_QWORD *)(a1 + 168);
    v27 = v8;
    v9 = *(_QWORD *)(a1 + 192);
    v28 = *(_QWORD *)(a1 + 184);
    v29 = v9;
    if ( unk_2250E0 & 1 )
      g_log("Slirp", 128LL, " connect()ing...");
    if ( (signed int)sub_11CD0(a1, &addr.sa_family) < 0 )
      return 0xFFFFFFFFLL;
    v11 = sub_164A5(&addr.sa_family);
    v13 = connect(fd, &addr, v11);
    sub_11ABA(a1);
  }
  return (unsigned int)v13;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000017600) ----------------------------------------------------
unsigned __int64 __fastcall sub_17600(unsigned int *a1)
{
  _QWORD *v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rbx
  __int64 v4; // rbx
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rcx
  _QWORD *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  unsigned int v19; // eax
  char v20; // al
  socklen_t addr_len; // [rsp+1Ch] [rbp-C4h]
  int optval; // [rsp+20h] [rbp-C0h]
  int fd; // [rsp+24h] [rbp-BCh]
  unsigned int *v25; // [rsp+28h] [rbp-B8h]
  __int64 v26; // [rsp+30h] [rbp-B0h]
  __int64 v27; // [rsp+38h] [rbp-A8h]
  struct sockaddr addr; // [rsp+40h] [rbp-A0h]
  __int64 v29; // [rsp+50h] [rbp-90h]
  __int64 v30; // [rsp+58h] [rbp-88h]
  __int64 v31; // [rsp+60h] [rbp-80h]
  __int64 v32; // [rsp+68h] [rbp-78h]
  __int64 v33; // [rsp+70h] [rbp-70h]
  __int64 v34; // [rsp+78h] [rbp-68h]
  __int64 v35; // [rsp+80h] [rbp-60h]
  __int64 v36; // [rsp+88h] [rbp-58h]
  __int64 v37; // [rsp+90h] [rbp-50h]
  __int64 v38; // [rsp+98h] [rbp-48h]
  __int64 v39; // [rsp+A0h] [rbp-40h]
  __int64 v40; // [rsp+A8h] [rbp-38h]
  __int64 v41; // [rsp+B0h] [rbp-30h]
  __int64 v42; // [rsp+B8h] [rbp-28h]
  unsigned __int64 v43; // [rsp+C8h] [rbp-18h]

  v43 = __readfsqword(0x28u);
  v26 = *((_QWORD *)a1 + 5);
  addr_len = 128;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_connect...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " inso = %p");
  if ( a1[83] & 0x200 )
  {
    v25 = a1;
  }
  else
  {
    v25 = (unsigned int *)sub_F694(v26);
    if ( (signed int)sub_17B83(v25) < 0 )
    {
      g_free(v25);
      return __readfsqword(0x28u) ^ v43;
    }
    v1 = v25;
    v2 = *((_QWORD *)a1 + 26);
    *((_QWORD *)v25 + 25) = *((_QWORD *)a1 + 25);
    v1[26] = v2;
    v3 = *((_QWORD *)a1 + 28);
    v1[27] = *((_QWORD *)a1 + 27);
    v1[28] = v3;
    v4 = *((_QWORD *)a1 + 30);
    v1[29] = *((_QWORD *)a1 + 29);
    v1[30] = v4;
    v5 = *((_QWORD *)a1 + 32);
    v1[31] = *((_QWORD *)a1 + 31);
    v1[32] = v5;
    v6 = *((_QWORD *)a1 + 34);
    v1[33] = *((_QWORD *)a1 + 33);
    v1[34] = v6;
    v7 = *((_QWORD *)a1 + 36);
    v1[35] = *((_QWORD *)a1 + 35);
    v1[36] = v7;
    v8 = *((_QWORD *)a1 + 38);
    v1[37] = *((_QWORD *)a1 + 37);
    v1[38] = v8;
    v9 = *((_QWORD *)a1 + 40);
    v1[39] = *((_QWORD *)a1 + 39);
    v1[40] = v9;
    *((_WORD *)v25 + 36) = *((_WORD *)a1 + 36);
  }
  sub_15314(*((_QWORD *)v25 + 42), 0);
  fd = accept(a1[4], &addr, &addr_len);
  if ( fd >= 0 )
  {
    sub_1C142(fd);
    (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*((_QWORD *)v25 + 5) + 5992LL) + 48LL))(
      v25[4],
      *(_QWORD *)(*((_QWORD *)v25 + 5) + 6000LL));
    sub_1644D(fd);
    optval = 1;
    setsockopt(fd, 1, 10, &optval, 4u);
    sub_163F5(fd);
    v10 = v25;
    v11 = *(_QWORD *)&addr.sa_data[6];
    *((_QWORD *)v25 + 9) = *(_QWORD *)&addr.sa_family;
    v10[10] = v11;
    v12 = v30;
    v10[11] = v29;
    v10[12] = v12;
    v13 = v32;
    v10[13] = v31;
    v10[14] = v13;
    v14 = v34;
    v10[15] = v33;
    v10[16] = v14;
    v15 = v36;
    v10[17] = v35;
    v10[18] = v15;
    v16 = v38;
    v10[19] = v37;
    v10[20] = v16;
    v17 = v40;
    v10[21] = v39;
    v10[22] = v17;
    v18 = v42;
    v10[23] = v41;
    v10[24] = v18;
    sub_11FE2((__int64)v25);
    if ( a1[83] & 0x200 )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*((_QWORD *)v25 + 5) + 5992LL) + 56LL))(
        v25[4],
        *(_QWORD *)(*((_QWORD *)v25 + 5) + 6000LL));
      close(v25[4]);
      v25[83] = 1;
    }
    v25[4] = fd;
    v19 = v25[83];
    BYTE1(v19) |= 0x20u;
    v25[83] = v19;
    v20 = sub_17BE5((__int64)v25);
    *((_BYTE *)v25 + 328) = v20;
    v27 = *((_QWORD *)v25 + 42);
    sub_1659D(v27);
    *(_WORD *)(v27 + 16) = 2;
    *(_WORD *)(v27 + 22) = 150;
    *(_DWORD *)(v27 + 140) = *(_DWORD *)(v26 + 880);
    *(_DWORD *)(v26 + 880) += 64000;
    *(_DWORD *)(v27 + 128) = *(_DWORD *)(v27 + 140);
    *(_DWORD *)(v27 + 168) = *(_DWORD *)(v27 + 128);
    *(_DWORD *)(v27 + 124) = *(_DWORD *)(v27 + 168);
    *(_DWORD *)(v27 + 120) = *(_DWORD *)(v27 + 124);
    sub_15563(v27);
  }
  else
  {
    sub_17098(*((_QWORD **)v25 + 42));
  }
  return __readfsqword(0x28u) ^ v43;
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000017B83) ----------------------------------------------------
signed __int64 __fastcall sub_17B83(_QWORD *a1)
{
  a1[42] = sub_16EBD((__int64)a1);
  if ( !a1[42] )
    return 0xFFFFFFFFLL;
  sub_AB4C(a1, (_QWORD *)(a1[5] + 448LL));
  return 0LL;
}

//----- (0000000000017BE5) ----------------------------------------------------
__int64 __fastcall sub_17BE5(__int64 a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    if ( !*((_BYTE *)&unk_1E984 + 6 * i) )
      return 0LL;
    if ( *((_WORD *)&unk_1E982 + 3 * i) && ntohs(*(_WORD *)(a1 + 74)) == *((_WORD *)&unk_1E982 + 3 * i)
      || *((_WORD *)&unk_1E980 + 3 * i) && ntohs(*(_WORD *)(a1 + 202)) == *((_WORD *)&unk_1E980 + 3 * i) )
    {
      break;
    }
  }
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 40) + 5984LL) )
    *(_BYTE *)(a1 + 329) = byte_1E985[6 * i];
  return *((unsigned __int8 *)&unk_1E984 + 6 * i);
}

//----- (0000000000017D52) ----------------------------------------------------
signed __int64 __fastcall sub_17D52(__int64 a1, signed __int64 a2)
{
  signed __int64 result; // rax
  uint16_t v3; // ax
  int v4; // eax
  signed __int64 v5; // rsi
  signed __int64 v6; // rcx
  uint16_t v7; // ax
  uint16_t v8; // ax
  char *v9; // rax
  uint16_t v10; // ax
  uint16_t v11; // ax
  char *v12; // rax
  uint16_t v13; // ax
  uint16_t v14; // ax
  uint16_t v15; // bx
  in_addr_t v16; // eax
  unsigned int v17; // ebx
  uint32_t v18; // eax
  int v19; // eax
  __int64 v20; // ST20_8
  uint16_t v21; // bx
  in_addr_t v22; // eax
  unsigned int v23; // er12
  uint32_t v24; // eax
  uint16_t v25; // bx
  in_addr_t v26; // eax
  unsigned int v27; // er12
  uint32_t v28; // eax
  char *v29; // rax
  char *v30; // rax
  __int16 v31; // r12
  int v32; // ebx
  __int16 v33; // ax
  char *v34; // rax
  signed __int64 v35; // [rsp+0h] [rbp-190h]
  struct in_addr *v36; // [rsp+8h] [rbp-188h]
  struct in_addr *v37; // [rsp+8h] [rbp-188h]
  struct in_addr *v38; // [rsp+8h] [rbp-188h]
  struct in_addr *v39; // [rsp+8h] [rbp-188h]
  struct in_addr *v40; // [rsp+8h] [rbp-188h]
  struct in_addr *v41; // [rsp+8h] [rbp-188h]
  signed __int16 j; // [rsp+16h] [rbp-17Ah]
  unsigned int v43; // [rsp+18h] [rbp-178h]
  unsigned int v44; // [rsp+1Ch] [rbp-174h]
  unsigned int v45; // [rsp+20h] [rbp-170h]
  unsigned int v46; // [rsp+24h] [rbp-16Ch]
  unsigned int v47; // [rsp+28h] [rbp-168h]
  unsigned int v48; // [rsp+2Ch] [rbp-164h]
  uint32_t hostlong; // [rsp+30h] [rbp-160h]
  socklen_t len; // [rsp+34h] [rbp-15Ch]
  int i; // [rsp+38h] [rbp-158h]
  int v52; // [rsp+3Ch] [rbp-154h]
  char *s; // [rsp+40h] [rbp-150h]
  __int64 k; // [rsp+48h] [rbp-148h]
  __int64 v55; // [rsp+50h] [rbp-140h]
  _BYTE *v56; // [rsp+58h] [rbp-138h]
  struct sockaddr addr; // [rsp+60h] [rbp-130h]
  char v58; // [rsp+70h] [rbp-120h]
  char v59; // [rsp+71h] [rbp-11Fh]
  char v60; // [rsp+72h] [rbp-11Eh]
  char v61; // [rsp+73h] [rbp-11Dh]
  unsigned __int64 v62; // [rsp+178h] [rbp-18h]

  v35 = a2;
  v62 = __readfsqword(0x28u);
  v55 = *(_QWORD *)(a1 + 40);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_emu...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  switch ( *(unsigned __int8 *)(a1 + 329) )
  {
    case 2u:
      sub_A70B(a2, *(_DWORD *)(a2 + 56) + 1);
      *(_BYTE *)(*(_QWORD *)(a2 + 48) + *(signed int *)(a2 + 56)) = 0;
      s = strstr(*(const char **)(a2 + 48), "ORT");
      if ( s )
      {
        v52 = __isoc99_sscanf(s, &unk_1EA08, &v43);
        if ( v52 > 5 )
        {
          hostlong = htonl((v45 << 8) | (v44 << 16) | (v43 << 24) | v46);
          v7 = htons(((_WORD)v47 << 8) | v48);
          len = v7;
          v36 = sub_116C0(v55, 0, 0, hostlong, v7, 512);
          if ( v36 )
          {
            v8 = ntohs(HIWORD(v36[18].s_addr));
            v47 = HIBYTE(v8);
            v48 = (unsigned __int8)v8;
            hostlong = ntohl(v36[19].s_addr);
            v43 = hostlong >> 24;
            v44 = BYTE2(hostlong);
            v45 = BYTE1(hostlong);
            v46 = (unsigned __int8)hostlong;
            *(_DWORD *)(a2 + 56) = (_DWORD)s - *(unsigned __int64 *)(a2 + 48);
            if ( v52 == 7 )
              v9 = &v58;
            else
              v9 = (char *)&unk_1EA28;
            *(_DWORD *)(a2 + 56) += snprintf(
                                      s,
                                      *(_DWORD *)(a2 + 36) - *(_DWORD *)(a2 + 56),
                                      "ORT %d,%d,%d,%d,%d,%d\r\n%s",
                                      v43,
                                      v44,
                                      v45,
                                      v46,
                                      v47,
                                      v48,
                                      v9);
            result = 1LL;
          }
          else
          {
            result = 1LL;
          }
        }
        else
        {
          result = 1LL;
        }
      }
      else
      {
        s = strstr(*(const char **)(a2 + 48), "27 Entering");
        if ( s )
        {
          v52 = __isoc99_sscanf(s, &unk_1EA50, &v43);
          if ( v52 > 5 )
          {
            hostlong = htonl((v45 << 8) | (v44 << 16) | (v43 << 24) | v46);
            v10 = htons(((_WORD)v47 << 8) | v48);
            len = v10;
            v37 = sub_116C0(v55, 0, 0, hostlong, v10, 512);
            if ( v37 )
            {
              v11 = ntohs(HIWORD(v37[18].s_addr));
              v47 = HIBYTE(v11);
              v48 = (unsigned __int8)v11;
              hostlong = ntohl(v37[19].s_addr);
              v43 = hostlong >> 24;
              v44 = BYTE2(hostlong);
              v45 = BYTE1(hostlong);
              v46 = (unsigned __int8)hostlong;
              *(_DWORD *)(a2 + 56) = (_DWORD)s - *(unsigned __int64 *)(a2 + 48);
              if ( v52 == 7 )
                v12 = &v58;
              else
                v12 = (char *)&unk_1EA28;
              *(_DWORD *)(a2 + 56) += snprintf(
                                        s,
                                        *(_DWORD *)(a2 + 36) - *(_DWORD *)(a2 + 56),
                                        "27 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n%s",
                                        v43,
                                        v44,
                                        v45,
                                        v46,
                                        v47,
                                        v48,
                                        v12);
              result = 1LL;
            }
            else
            {
              result = 1LL;
            }
          }
          else
          {
            result = 1LL;
          }
        }
        else
        {
          result = 1LL;
        }
      }
      break;
    case 3u:
      *(_BYTE *)(a1 + 329) = 0;
      len = 0;
      for ( i = 0; i < *(_DWORD *)(a2 + 56) - 1; ++i )
      {
        if ( *(_BYTE *)(*(_QWORD *)(a2 + 48) + i) <= 47 || *(_BYTE *)(*(_QWORD *)(a2 + 48) + i) > 57 )
          return 1LL;
        len = *(char *)(*(_QWORD *)(a2 + 48) + i) + 10 * len - 48;
      }
      if ( !*(_BYTE *)(*(_QWORD *)(a2 + 48) + *(signed int *)(a2 + 56) - 1LL) )
      {
        if ( len )
        {
          v13 = htons(len);
          v38 = sub_116C0(v55, 0, 0, *(_DWORD *)(a1 + 204), v13, 512);
          if ( v38 )
          {
            v14 = ntohs(HIWORD(v38[18].s_addr));
            *(_DWORD *)(a2 + 56) = snprintf(*(char **)(a2 + 48), *(signed int *)(a2 + 36), "%d", v14) + 1;
          }
        }
      }
      result = 1LL;
      break;
    case 4u:
      sub_A70B(a2, *(_DWORD *)(a2 + 56) + 1);
      *(_BYTE *)(*(_QWORD *)(a2 + 48) + *(signed int *)(a2 + 56)) = 0;
      s = strstr(*(const char **)(a2 + 48), "DCC");
      if ( !s )
        return 1LL;
      if ( (unsigned int)__isoc99_sscanf(s, "DCC CHAT %256s %u %u", &v58) == 3 )
      {
        v15 = htons(len);
        v16 = htonl(hostlong);
        v39 = sub_116C0(v55, 0, 0, v16, v15, 512);
        if ( !v39 )
          return 1LL;
        *(_DWORD *)(a2 + 56) = (_DWORD)s - *(unsigned __int64 *)(a2 + 48);
        v17 = ntohs(HIWORD(v39[18].s_addr));
        v18 = ntohl(v39[19].s_addr);
        v19 = snprintf(s, *(signed int *)(a2 + 36), "DCC CHAT chat %lu %u%c\n", v18, v17, 1LL, a2);
        *(_DWORD *)(v20 + 56) += v19;
      }
      else if ( (unsigned int)__isoc99_sscanf(s, "DCC SEND %256s %u %u %u", &v58) == 4 )
      {
        v21 = htons(len);
        v22 = htonl(hostlong);
        v40 = sub_116C0(v55, 0, 0, v22, v21, 512);
        if ( !v40 )
          return 1LL;
        *(_DWORD *)(a2 + 56) = (_DWORD)s - *(unsigned __int64 *)(a2 + 48);
        v23 = ntohs(HIWORD(v40[18].s_addr));
        v24 = ntohl(v40[19].s_addr);
        *(_DWORD *)(a2 + 56) += snprintf(
                                  s,
                                  *(signed int *)(a2 + 36),
                                  "DCC SEND %s %lu %u %u%c\n",
                                  &v58,
                                  v24,
                                  v23,
                                  v43,
                                  1LL);
      }
      else if ( (unsigned int)__isoc99_sscanf(s, "DCC MOVE %256s %u %u %u", &v58) == 4 )
      {
        v25 = htons(len);
        v26 = htonl(hostlong);
        v41 = sub_116C0(v55, 0, 0, v26, v25, 512);
        if ( !v41 )
          return 1LL;
        *(_DWORD *)(a2 + 56) = (_DWORD)s - *(unsigned __int64 *)(a2 + 48);
        v27 = ntohs(HIWORD(v41[18].s_addr));
        v28 = ntohl(v41[19].s_addr);
        *(_DWORD *)(a2 + 56) += snprintf(
                                  s,
                                  *(signed int *)(a2 + 36),
                                  "DCC MOVE %s %lu %u %u%c\n",
                                  &v58,
                                  v28,
                                  v27,
                                  v43,
                                  1LL);
      }
      result = 1LL;
      break;
    case 5u:
      s = *(char **)(a2 + 48);
LABEL_101:
      while ( (unsigned __int64)s < *(_QWORD *)(a2 + 48) + (signed __int64)*(signed int *)(a2 + 56) )
      {
        v58 = 80;
        v59 = 78;
        v60 = 65;
        v61 = 0;
        switch ( dword_2250D4 )
        {
          case 0:
          case 2:
          case 3:
            v29 = s++;
            if ( *v29 == *(&v58 + dword_2250D4) )
              goto LABEL_100;
            dword_2250D4 = 0;
            goto LABEL_101;
          case 1:
            if ( *s == 80 )
            {
              dword_2250D4 = 1;
              ++s;
            }
            else
            {
              v30 = s++;
              if ( *v30 == *(&v58 + dword_2250D4) )
LABEL_100:
                ++dword_2250D4;
              else
                dword_2250D4 = 0;
            }
            break;
          case 4:
            ++s;
            goto LABEL_100;
          case 5:
            if ( s[1] == 2 )
              s += 8;
            else
              s += 4;
            goto LABEL_100;
          case 6:
            len = ((unsigned __int8)*s << 8) + (unsigned __int8)s[1];
            if ( len <= 0x1B39 )
              len += 256;
            if ( len <= 0x1B39 || len > 0x1C02 )
              return 1LL;
            for ( j = 6970; (unsigned __int16)j <= 0x1B9Eu; ++j )
            {
              v31 = htons(len);
              v32 = *(_DWORD *)(a1 + 204);
              v33 = htons(j);
              if ( sub_1B58F(v55, 0, v33, v32, v31, 512) )
                break;
            }
            if ( j == 7071 )
              j = 0;
            v34 = s++;
            *v34 = HIBYTE(j);
            *s = j;
            dword_2250D4 = 0;
            return 1LL;
          default:
            dword_2250D4 = 0;
            goto LABEL_100;
        }
      }
      result = 1LL;
      break;
    case 7u:
      len = 16;
      v56 = (_BYTE *)g_strstr_len(*(_QWORD *)(a2 + 48), *(signed int *)(a2 + 56), "\r\n");
      if ( v56 )
      {
        *v56 = 0;
        if ( (unsigned int)__isoc99_sscanf(*(_QWORD *)(a2 + 48), "%u%*[ ,]%u", &v43) == 2 )
        {
          v43 = htons(v43);
          v44 = htons(v44);
          for ( k = *(_QWORD *)(v55 + 448); k != v55 + 448; k = *(_QWORD *)k )
          {
            if ( *(_DWORD *)(k + 204) == *(_DWORD *)(a1 + 204)
              && *(unsigned __int16 *)(k + 202) == v44
              && *(_DWORD *)(k + 76) == *(_DWORD *)(a1 + 76)
              && *(unsigned __int16 *)(k + 74) == v43 )
            {
              if ( !getsockname(*(_DWORD *)(k + 16), &addr, &len) )
                v44 = *(unsigned __int16 *)addr.sa_data;
              break;
            }
          }
          v43 = ntohs(v43);
          v3 = ntohs(v44);
          v44 = v3;
          v4 = snprintf(0LL, 0LL, "%d,%d\r\n", v43, v3);
          sub_A70B(a2, v4 + 1);
          if ( *(_DWORD *)(a2 + 32) & 1 )
            v5 = *(_QWORD *)(a2 + 88) + *(signed int *)(a2 + 36);
          else
            v5 = a2 + 96 + *(signed int *)(a2 + 36);
          *(_DWORD *)(v35 + 56) = snprintf(*(char **)(v35 + 48), v5 - *(_QWORD *)(v35 + 48), "%d,%d\r\n", v43, v44);
          if ( *(_DWORD *)(v35 + 32) & 1 )
            v6 = *(_QWORD *)(v35 + 88) + *(signed int *)(v35 + 36);
          else
            v6 = v35 + 96 + *(signed int *)(v35 + 36);
          if ( v6 - *(_QWORD *)(v35 + 48) <= *(signed int *)(v35 + 56) )
            __assert_fail("m->m_len < M_ROOM(m)", "../src/tcp_subr.c", 0x28Fu, "tcp_emu");
        }
        else
        {
          *v56 = 13;
        }
        result = 1LL;
      }
      else
      {
        result = 1LL;
      }
      break;
    default:
      *(_BYTE *)(a1 + 329) = 0;
      result = 1LL;
      break;
  }
  return result;
}
// 2FD0: using guessed type __int64 __fastcall g_strstr_len(_QWORD, _QWORD, _QWORD);
// 3010: using guessed type __int64 __fastcall __isoc99_sscanf(_QWORD, _QWORD, _QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);
// 2250D4: using guessed type int dword_2250D4;

//----- (00000000000190AA) ----------------------------------------------------
signed __int64 __fastcall sub_190AA(__int64 a1)
{
  signed __int64 result; // rax
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 v3; // [rsp+20h] [rbp-10h]

  v3 = *(_QWORD *)(a1 + 40);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_ctl...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( *(_DWORD *)(a1 + 76) != *(_DWORD *)(v3 + 20) )
  {
    for ( i = *(_QWORD *)(v3 + 128); i; i = *(_QWORD *)(i + 32) )
    {
      if ( *(_DWORD *)(i + 20) == *(unsigned __int16 *)(a1 + 74) && *(_DWORD *)(a1 + 76) == *(_DWORD *)(i + 16) )
      {
        if ( *(_QWORD *)i )
        {
          *(_DWORD *)(a1 + 16) = -1;
          *(_QWORD *)(a1 + 24) = i;
          result = 1LL;
        }
        else
        {
          if ( unk_2250E0 & 2 )
            g_log("Slirp", 128LL, " executing %s");
          result = sub_AF8E(a1, *(_QWORD *)(i + 24));
        }
        return result;
      }
    }
  }
  *(_DWORD *)(a1 + 392) = snprintf(
                            *(char **)(a1 + 400),
                            *(unsigned int *)(a1 + 396) - (*(_QWORD *)(a1 + 400) - *(_QWORD *)(a1 + 416)),
                            "Error: No application configured.\r\n");
  *(_QWORD *)(a1 + 400) += *(unsigned int *)(a1 + 392);
  return 0LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000019297) ----------------------------------------------------
signed __int64 __fastcall sub_19297(signed __int64 a1)
{
  signed __int64 result; // rax
  _QWORD *v2; // r12
  __int64 v3; // rbx

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_fasttimo...");
  result = a1;
  v2 = *(_QWORD **)(a1 + 448);
  if ( v2 )
  {
    while ( 1 )
    {
      result = a1 + 448;
      if ( v2 == (_QWORD *)(a1 + 448) )
        break;
      v3 = v2[42];
      if ( v3 )
      {
        if ( *(_WORD *)(v3 + 36) & 2 )
        {
          *(_WORD *)(v3 + 36) &= 0xFFFDu;
          *(_WORD *)(v3 + 36) |= 1u;
          sub_15563(v3);
        }
      }
      v2 = (_QWORD *)*v2;
    }
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001933B) ----------------------------------------------------
__int64 __fastcall sub_1933B(__int64 a1)
{
  __int64 result; // rax
  __int64 *v2; // r13
  __int64 v3; // r14
  __int64 v4; // rbx
  signed int i; // er12

  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_slowtimo...");
  result = a1;
  v2 = *(__int64 **)(a1 + 448);
  if ( v2 )
  {
    while ( v2 != (__int64 *)(a1 + 448) )
    {
      v3 = *v2;
      v4 = v2[42];
      if ( v4 )
      {
        for ( i = 0; i <= 3; ++i )
        {
          if ( *(_WORD *)(v4 + 2 * (i + 8LL) + 2) )
          {
            if ( !--*(_WORD *)(v4 + 2 * (i + 8LL) + 2) )
            {
              sub_194C9(v4, i);
              if ( v2 != *(__int64 **)(v3 + 8) )
                goto LABEL_14;
            }
          }
        }
        ++*(_WORD *)(v4 + 180);
        if ( *(_WORD *)(v4 + 182) )
          ++*(_WORD *)(v4 + 182);
      }
LABEL_14:
      v2 = (__int64 *)v3;
    }
    *(_DWORD *)(a1 + 880) += 64000;
    result = a1;
    ++*(_DWORD *)(a1 + 884);
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001949B) ----------------------------------------------------
__int64 __fastcall sub_1949B(__int64 a1)
{
  signed int i; // ebx
  __int64 result; // rax

  for ( i = 0; i <= 3; ++i )
  {
    result = a1;
    *(_WORD *)(a1 + 2 * (i + 8LL) + 2) = 0;
  }
  return result;
}

//----- (00000000000194C9) ----------------------------------------------------
__int64 __fastcall sub_194C9(__int64 a1, signed int a2)
{
  __int64 v2; // rbx
  unsigned int v4; // eax
  unsigned int v5; // [rsp+1Ch] [rbp-14h]

  v2 = a1;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "tcp_timers...");
  if ( a2 == 1 )
  {
    sub_16346((_WORD *)a1);
    *(_BYTE *)(a1 + 34) = 1;
    sub_15563(a1);
    *(_BYTE *)(a1 + 34) = 0;
  }
  else if ( a2 > 1 )
  {
    if ( a2 != 2 )
    {
      if ( a2 == 3 )
      {
        if ( *(_WORD *)(a1 + 16) == 10 || *(_WORD *)(a1 + 180) > 1200 )
          v2 = sub_17098((_QWORD *)a1);
        else
          *(_WORD *)(a1 + 24) = 150;
      }
      return v2;
    }
    if ( *(_WORD *)(a1 + 16) <= 3 )
      return sub_16FC0(a1);
    if ( !unk_2250EC || *(_WORD *)(a1 + 16) > 5 )
    {
      *(_WORD *)(a1 + 22) = 14400;
      return v2;
    }
    if ( *(_WORD *)(a1 + 180) > 15599 )
      return sub_16FC0(a1);
    sub_16709(
      a1,
      a1 + 40,
      0LL,
      *(_DWORD *)(a1 + 152),
      *(_DWORD *)(a1 + 120) - 1,
      0,
      *(_WORD *)(*(_QWORD *)(a1 + 112) + 72LL));
    *(_WORD *)(a1 + 22) = 150;
  }
  else if ( !a2 )
  {
    if ( ++*(_WORD *)(a1 + 26) > 12 )
    {
      *(_WORD *)(a1 + 32) >>= 1;
      if ( *(_WORD *)(a1 + 32) <= 0x1Fu )
      {
        *(_WORD *)(a1 + 26) = 12;
        return sub_16FC0(a1);
      }
      *(_WORD *)(a1 + 26) = 6;
    }
    *(_WORD *)(a1 + 28) = word_1EC60[2 * *(signed __int16 *)(a1 + 26)]
                        * ((*(_WORD *)(a1 + 188) >> 3) + *(_WORD *)(a1 + 190));
    if ( *(_WORD *)(a1 + 28) >= *(_WORD *)(a1 + 192) )
    {
      if ( *(_WORD *)(a1 + 28) > 24 )
        *(_WORD *)(a1 + 28) = 24;
    }
    else
    {
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 192);
    }
    *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 28);
    if ( *(_WORD *)(a1 + 26) > 3 )
    {
      *(_WORD *)(a1 + 190) += *(_WORD *)(a1 + 188) >> 3;
      *(_WORD *)(a1 + 188) = 0;
    }
    *(_DWORD *)(a1 + 124) = *(_DWORD *)(a1 + 120);
    *(_WORD *)(a1 + 182) = 0;
    v4 = *(_DWORD *)(a1 + 144);
    if ( *(_DWORD *)(a1 + 172) <= v4 )
      v4 = *(_DWORD *)(a1 + 172);
    v5 = (v4 >> 1) / *(unsigned __int16 *)(a1 + 32);
    if ( v5 <= 1 )
      v5 = 2;
    *(_DWORD *)(a1 + 172) = *(unsigned __int16 *)(a1 + 32);
    *(_DWORD *)(a1 + 176) = v5 * *(unsigned __int16 *)(a1 + 32);
    *(_WORD *)(a1 + 30) = 0;
    sub_15563(a1);
  }
  return v2;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (0000000000019784) ----------------------------------------------------
bool __fastcall sub_19784(const void *a1, const void *a2)
{
  return memcmp(a1, a2, 0x10uLL) == 0;
}

//----- (00000000000197B3) ----------------------------------------------------
__int64 __fastcall sub_197B3(unsigned __int16 *a1, __int64 a2)
{
  int v3; // eax

  if ( *a1 != *(_WORD *)a2 )
    return 0LL;
  v3 = *a1;
  if ( v3 == 2 )
    return *((_DWORD *)a1 + 1) == *(_DWORD *)(a2 + 4) && a1[1] == *(_WORD *)(a2 + 2);
  if ( v3 == 10 )
    return sub_19784(a1 + 4, (const void *)(a2 + 8)) && a1[1] == *(_WORD *)(a2 + 2);
  return g_assertion_message_expr("Slirp", "../src/socket.h", 122LL, "sockaddr_equal", 0LL);
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000198B7) ----------------------------------------------------
__int64 __fastcall sub_198B7(unsigned __int16 *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( v1 == 2 )
    return 16LL;
  if ( v1 == 10 )
    return 28LL;
  return g_assertion_message_expr("Slirp", "../src/socket.h", 136LL, "sockaddr_size", 0LL);
}
// 2EA0: using guessed type __int64 __fastcall g_assertion_message_expr(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001990E) ----------------------------------------------------
_BOOL8 __fastcall sub_1990E(_QWORD *a1)
{
  return *a1 != 0LL;
}

//----- (0000000000019928) ----------------------------------------------------
__int64 __fastcall sub_19928(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 160) = unk_2250E8;
  return result;
}

//----- (0000000000019948) ----------------------------------------------------
__int64 __fastcall sub_19948(__int64 a1)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 16) >= 0 )
  {
    close(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = -1;
  }
  g_free(*(_QWORD *)(a1 + 8));
  result = a1;
  *(_QWORD *)a1 = 0LL;
  return result;
}
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);

//----- (0000000000019996) ----------------------------------------------------
signed __int64 __fastcall sub_19996(__int64 a1, unsigned __int16 *a2, _WORD *a3)
{
  unsigned int v4; // eax
  _WORD *v5; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+24h] [rbp-Ch]
  _DWORD *s; // [rsp+28h] [rbp-8h]

  v5 = a3;
  for ( i = 0; ; ++i )
  {
    if ( i > 19 )
      return 0xFFFFFFFFLL;
    s = (_DWORD *)(168LL * i + 1760 + a1);
    if ( !(unsigned int)sub_1990E(s) )
      break;
    if ( unk_2250E8 - s[40] > 5000 )
    {
      sub_19948((__int64)s);
      break;
    }
  }
  memset(s, 0, 0xA8uLL);
  v4 = sub_198B7(a2);
  memcpy(s + 6, a2, v4);
  s[4] = -1;
  *((_WORD *)s + 10) = 512;
  *((_WORD *)s + 76) = *v5;
  *(_QWORD *)s = a1;
  sub_19928((__int64)s);
  return (unsigned int)i;
}

//----- (0000000000019AAC) ----------------------------------------------------
signed __int64 __fastcall sub_19AAC(__int64 a1, __int64 a2, _WORD *a3)
{
  _WORD *v4; // [rsp+8h] [rbp-28h]
  signed int i; // [rsp+24h] [rbp-Ch]
  signed __int64 v6; // [rsp+28h] [rbp-8h]

  v4 = a3;
  for ( i = 0; i <= 19; ++i )
  {
    v6 = 168LL * i + 1760 + a1;
    if ( (unsigned int)sub_1990E((_QWORD *)v6)
      && (unsigned int)sub_197B3((unsigned __int16 *)(v6 + 24), a2)
      && *(_WORD *)(v6 + 152) == *v4 )
    {
      return (unsigned int)i;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000019B4E) ----------------------------------------------------
signed __int64 __fastcall sub_19B4E(__int64 a1, int a2, void *a3, int a4)
{
  void *buf; // [rsp+8h] [rbp-28h]
  int v6; // [rsp+10h] [rbp-20h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  buf = a3;
  v6 = a4;
  v7 = 0;
  if ( *(_DWORD *)(a1 + 16) < 0 )
    *(_DWORD *)(a1 + 16) = open64(*(const char **)(a1 + 8), 0);
  if ( *(_DWORD *)(a1 + 16) < 0 )
    return 0xFFFFFFFFLL;
  if ( v6 )
  {
    lseek64(*(_DWORD *)(a1 + 16), a2 * (unsigned int)*(unsigned __int16 *)(a1 + 20), 0);
    v7 = read(*(_DWORD *)(a1 + 16), buf, v6);
  }
  return v7;
}

//----- (0000000000019BFB) ----------------------------------------------------
__int64 __fastcall sub_19BFB(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rdx
  __int64 v3; // ST18_8

  memset(*(void **)(a2 + 48), 0, *(signed int *)(a2 + 36));
  *(_QWORD *)(a2 + 48) += 16LL;
  if ( *(_WORD *)(a1 + 24) == 10 )
    v2 = *(_QWORD *)(a2 + 48) + 40LL;
  else
    v2 = *(_QWORD *)(a2 + 48) + 20LL;
  *(_QWORD *)(a2 + 48) = v2;
  v3 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) += 8LL;
  return v3;
}

//----- (0000000000019C9C) ----------------------------------------------------
unsigned __int64 __fastcall sub_19C9C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v6; // [rsp+8h] [rbp-68h]
  char v7; // [rsp+20h] [rbp-50h]
  __int16 v8; // [rsp+22h] [rbp-4Eh]
  int v9; // [rsp+24h] [rbp-4Ch]
  __int64 v10; // [rsp+28h] [rbp-48h]
  __int64 v11; // [rsp+30h] [rbp-40h]
  char v12; // [rsp+40h] [rbp-30h]
  __int16 v13; // [rsp+42h] [rbp-2Eh]
  int v14; // [rsp+44h] [rbp-2Ch]
  __int64 v15; // [rsp+48h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp-20h]
  unsigned __int64 v17; // [rsp+68h] [rbp-8h]

  v6 = a3;
  v17 = __readfsqword(0x28u);
  if ( *(_WORD *)(a1 + 24) == 10 )
  {
    v3 = *(_QWORD *)(*(_QWORD *)a1 + 52LL);
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 44LL);
    v11 = v3;
    v8 = *(_WORD *)(v6 + 2);
    v4 = *(_QWORD *)(a1 + 40);
    v15 = *(_QWORD *)(a1 + 32);
    v16 = v4;
    v13 = *(_WORD *)(a1 + 152);
    sub_1BF57(0LL, a2, (__int64)&v7, (__int64)&v12);
  }
  else
  {
    v9 = *(_DWORD *)(*(_QWORD *)a1 + 20LL);
    v8 = *(_WORD *)(a3 + 2);
    v14 = *(_DWORD *)(a1 + 28);
    v13 = *(_WORD *)(a1 + 152);
    sub_1B11D(0LL, a2, (__int64)&v7, (__int64)&v12, 16);
  }
  return __readfsqword(0x28u) ^ v17;
}

//----- (0000000000019D9E) ----------------------------------------------------
signed __int64 __fastcall sub_19D9E(__int64 *a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  int v6; // ST3C_4
  __int64 v7; // [rsp+8h] [rbp-48h]
  int v8; // [rsp+14h] [rbp-3Ch]
  __int64 v9; // [rsp+18h] [rbp-38h]
  int i; // [rsp+38h] [rbp-18h]
  int v11; // [rsp+3Ch] [rbp-14h]
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  v11 = 0;
  v12 = sub_A39A(*a1);
  if ( !v12 )
    return 0xFFFFFFFFLL;
  v13 = sub_19BFB((__int64)a1, v12);
  *(_WORD *)(v13 + 8) = htons(6u);
  for ( i = 0; i < v8; ++i )
  {
    v6 = snprintf((char *)(v13 + 10 + v11), 1430LL - v11, "%s", *(_QWORD *)(8LL * i + a2)) + 1 + v11;
    v11 = snprintf((char *)(v13 + 10 + v6), 1430LL - v6, "%u", *(unsigned int *)(4LL * i + v9)) + 1 + v6;
  }
  *(_DWORD *)(v12 + 56) = v11 + 2;
  sub_19C9C((__int64)a1, v12, v7);
  return 0LL;
}

//----- (0000000000019EFE) ----------------------------------------------------
__int64 __fastcall sub_19EFE(__int64 *a1, uint16_t a2, char *a3, __int64 a4)
{
  __int64 v4; // ST28_8
  __int64 v6; // [rsp+0h] [rbp-30h]
  char *s; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+20h] [rbp-10h]

  s = a3;
  v6 = a4;
  if ( unk_2250E0 & 8 )
    g_log("Slirp", 128LL, "tftp error msg: %s");
  v8 = sub_A39A(*a1);
  if ( v8 )
  {
    v4 = sub_19BFB((__int64)a1, v8);
    *(_WORD *)(v4 + 8) = htons(5u);
    *(_WORD *)(v4 + 10) = htons(a2);
    sub_1C2CC((_BYTE *)(v4 + 12), 1428, s);
    *(_DWORD *)(v8 + 56) = strlen(s) + 5;
    sub_19C9C((__int64)a1, v8, v6);
  }
  return sub_19948((__int64)a1);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001A007) ----------------------------------------------------
__int64 __fastcall sub_1A007(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // [rsp+1Ch] [rbp-14h]
  __int64 v4; // [rsp+20h] [rbp-10h]
  _WORD *v5; // [rsp+28h] [rbp-8h]

  result = sub_A39A(*(_QWORD *)a1);
  v4 = result;
  if ( result )
  {
    v5 = (_WORD *)sub_19BFB(a1, result);
    v5[4] = htons(3u);
    v5[5] = htons(*(unsigned int *)(a1 + 156) + 1);
    v3 = sub_19B4E(a1, *(_DWORD *)(a1 + 156), v5 + 6, *(unsigned __int16 *)(a1 + 20));
    if ( v3 >= 0 )
    {
      *(_DWORD *)(v4 + 56) = v3 + 4;
      sub_19C9C(a1, v4, a2);
      if ( v3 == *(unsigned __int16 *)(a1 + 20) )
        sub_19928(a1);
      else
        sub_19948(a1);
      result = a1;
      ++*(_DWORD *)(a1 + 156);
    }
    else
    {
      sub_A4F0(v4);
      result = sub_19EFE((__int64 *)a1, 1u, "File not found", (__int64)v5);
    }
  }
  return result;
}

//----- (000000000001A151) ----------------------------------------------------
unsigned __int64 __fastcall sub_1A151(__int64 a1, unsigned __int16 *a2, _WORD *a3, int a4)
{
  size_t n; // ST48_8
  signed int v5; // eax
  signed __int16 v6; // ax
  int v8; // [rsp+4h] [rbp-11Ch]
  int v9; // [rsp+4h] [rbp-11Ch]
  _WORD *v10; // [rsp+8h] [rbp-118h]
  signed int v11; // [rsp+2Ch] [rbp-F4h]
  int v12; // [rsp+2Ch] [rbp-F4h]
  int v13; // [rsp+2Ch] [rbp-F4h]
  unsigned int v14; // [rsp+30h] [rbp-F0h]
  int v15; // [rsp+34h] [rbp-ECh]
  int v16; // [rsp+38h] [rbp-E8h]
  int v17; // [rsp+38h] [rbp-E8h]
  int v18; // [rsp+3Ch] [rbp-E4h]
  __int64 v19; // [rsp+40h] [rbp-E0h]
  char *s1; // [rsp+50h] [rbp-D0h]
  char *s; // [rsp+58h] [rbp-C8h]
  char *nptr; // [rsp+60h] [rbp-C0h]
  int v23[2]; // [rsp+68h] [rbp-B8h]
  __int64 v24[2]; // [rsp+70h] [rbp-B0h]
  struct stat64 stat_buf; // [rsp+80h] [rbp-A0h]
  unsigned __int64 v26; // [rsp+118h] [rbp-8h]

  v10 = a3;
  v8 = a4;
  v26 = __readfsqword(0x28u);
  v14 = 0;
  v16 = sub_19AAC(a1, (__int64)a2, a3);
  if ( v16 >= 0 )
    sub_19948(168LL * v16 + 1760 + a1);
  v17 = sub_19996(a1, a2, v10);
  if ( v17 >= 0 )
  {
    v19 = 168LL * v17 + 1760 + a1;
    if ( *(_QWORD *)(a1 + 1752) )
    {
      v11 = 0;
      v9 = v8 - 10;
      n = strlen(*(const char **)(a1 + 1752));
      *(_QWORD *)(v19 + 8) = g_malloc(n + 514);
      memcpy(*(void **)(v19 + 8), *(const void **)(a1 + 1752), n);
      *(_BYTE *)(*(_QWORD *)(v19 + 8) + n) = 47;
      s1 = (char *)(n + 1 + *(_QWORD *)(v19 + 8));
      do
      {
        if ( v11 > 511 || v11 >= v9 )
        {
          sub_19EFE((__int64 *)v19, 2u, "Access violation", (__int64)v10);
          return __readfsqword(0x28u) ^ v26;
        }
        s1[v11] = *((_BYTE *)v10 + v11 + 10);
        v5 = v11++;
      }
      while ( s1[v5] );
      if ( unk_2250E0 & 8 )
        g_log("Slirp", 128LL, "tftp rrq file: %s");
      if ( v9 - v11 > 5 )
      {
        if ( !strcasecmp((const char *)v10 + v11 + 10, "octet") )
        {
          v12 = v11 + 6;
          if ( !strncmp(s1, "../", 3uLL) || s1[strlen(s1) - 1] == 47 || strstr(s1, "/../") )
          {
            sub_19EFE((__int64 *)v19, 2u, "Access violation", (__int64)v10);
          }
          else if ( (signed int)sub_19B4E(v19, 0, 0LL, 0) >= 0 )
          {
            if ( *((_BYTE *)v10 + v9 + 9) )
            {
              sub_19EFE((__int64 *)v19, 2u, "Access violation", (__int64)v10);
            }
            else
            {
              while ( v12 < v9 && v14 <= 1 )
              {
                s = (char *)v10 + v12 + 10;
                v13 = strlen(s) + v12 + 1;
                if ( v13 >= v9 )
                {
                  sub_19EFE((__int64 *)v19, 2u, "Access violation", (__int64)v10);
                  return __readfsqword(0x28u) ^ v26;
                }
                nptr = (char *)v10 + v13 + 10;
                v12 = strlen(nptr) + v13 + 1;
                if ( !strcasecmp(s, "tsize") )
                {
                  v15 = atoi(nptr);
                  if ( !v15 )
                  {
                    if ( sub_1D0D0(*(char **)(v19 + 8), &stat_buf) )
                    {
                      sub_19EFE((__int64 *)v19, 1u, "File not found", (__int64)v10);
                      return __readfsqword(0x28u) ^ v26;
                    }
                    v15 = stat_buf.st_size;
                  }
                  v24[v14] = (__int64)"tsize";
                  v23[v14++] = v15;
                }
                else if ( !strcasecmp(s, "blksize") )
                {
                  v18 = atoi(nptr);
                  if ( v18 > 0 )
                  {
                    v6 = 1428;
                    if ( v18 <= 1428 )
                      v6 = v18;
                    *(_WORD *)(v19 + 20) = v6;
                    v24[v14] = (__int64)"blksize";
                    v23[v14++] = *(unsigned __int16 *)(v19 + 20);
                  }
                }
              }
              if ( (signed int)v14 <= 0 )
              {
                *(_DWORD *)(v19 + 156) = 0;
                sub_1A007(v19, (__int64)v10);
              }
              else
              {
                if ( v14 > 2 )
                  __assert_fail("nb_options <= G_N_ELEMENTS(option_name)", "../src/tftp.c", 0x198u, "tftp_handle_rrq");
                sub_19D9E((__int64 *)v19, (__int64)v24, (__int64)v23, v14, (__int64)v10);
              }
            }
          }
          else
          {
            sub_19EFE((__int64 *)v19, 1u, "File not found", (__int64)v10);
          }
        }
        else
        {
          sub_19EFE((__int64 *)v19, 4u, "Unsupported transfer mode", (__int64)v10);
        }
      }
      else
      {
        sub_19EFE((__int64 *)v19, 2u, "Access violation", (__int64)v10);
      }
    }
    else
    {
      sub_19EFE((__int64 *)v19, 2u, "Access violation", (__int64)v10);
    }
  }
  return __readfsqword(0x28u) ^ v26;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);
// 1A151: using guessed type __int64 var_B0[2];
// 1A151: using guessed type int var_B8[2];

//----- (000000000001A8B4) ----------------------------------------------------
signed __int64 __fastcall sub_1A8B4(__int64 a1, __int64 a2, _WORD *a3)
{
  signed __int64 result; // rax
  __int64 v4; // [rsp+8h] [rbp-28h]

  v4 = (__int64)a3;
  result = sub_19AAC(a1, a2, a3);
  if ( (signed int)result >= 0 )
    result = sub_1A007(a1 + 168LL * (signed int)result + 1760, v4);
  return result;
}

//----- (000000000001A928) ----------------------------------------------------
signed __int64 __fastcall sub_1A928(__int64 a1, __int64 a2, _WORD *a3)
{
  signed __int64 result; // rax

  result = sub_19AAC(a1, a2, a3);
  if ( (signed int)result >= 0 )
    result = sub_19948(168LL * (signed int)result + 1760 + a1);
  return result;
}

//----- (000000000001A995) ----------------------------------------------------
signed __int64 __fastcall sub_1A995(unsigned __int16 *a1, __int64 a2)
{
  signed __int64 result; // rax
  _WORD *v3; // [rsp+18h] [rbp-8h]

  v3 = *(_WORD **)(a2 + 48);
  result = ntohs(v3[4]);
  if ( (unsigned __int16)result == 4 )
    return sub_1A8B4(*(_QWORD *)(a2 + 64), (__int64)a1, v3);
  if ( (_DWORD)result == 5 )
    return sub_1A928(*(_QWORD *)(a2 + 64), (__int64)a1, v3);
  if ( (_DWORD)result == 1 )
    result = sub_1A151(*(_QWORD *)(a2 + 64), a1, v3, *(_DWORD *)(a2 + 56));
  return result;
}

//----- (000000000001AA3C) ----------------------------------------------------
int __fastcall sub_1AA3C(int a1)
{
  int optval; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  optval = 1;
  return setsockopt(a1, 1, 2, &optval, 4u);
}

//----- (000000000001AA94) ----------------------------------------------------
_QWORD *__fastcall sub_1AA94(_QWORD *a1)
{
  _QWORD *v1; // ST00_8
  _QWORD *result; // rax

  v1 = a1;
  a1[112] = a1 + 111;
  v1[111] = v1[112];
  result = a1;
  v1[164] = v1 + 111;
  return result;
}

//----- (000000000001AAE1) ----------------------------------------------------
__int64 __fastcall sub_1AAE1(__int64 a1)
{
  __int64 result; // rax

  while ( 1 )
  {
    result = *(_QWORD *)(a1 + 888);
    if ( result == a1 + 888 )
      break;
    sub_1B3C9(*(_QWORD *)(a1 + 888));
  }
  return result;
}

//----- (000000000001AB20) ----------------------------------------------------
unsigned __int64 __fastcall sub_1AB20(__int64 a1, unsigned int a2)
{
  __int64 *v2; // r12
  __int16 *v3; // r13
  int *v4; // rax
  int *v5; // rax
  int *v6; // rax
  signed int v8; // [rsp+Ch] [rbp-F4h]
  int v9; // [rsp+Ch] [rbp-F4h]
  signed int v10; // [rsp+14h] [rbp-ECh]
  void *v11; // [rsp+18h] [rbp-E8h]
  __int64 v12; // [rsp+20h] [rbp-E0h]
  __int64 v13; // [rsp+30h] [rbp-D0h]
  __int64 v14; // [rsp+38h] [rbp-C8h]
  int v15; // [rsp+40h] [rbp-C0h]
  __int16 v16; // [rsp+50h] [rbp-B0h]
  __int16 v17; // [rsp+52h] [rbp-AEh]
  int v18; // [rsp+54h] [rbp-ACh]
  unsigned __int64 v19; // [rsp+D8h] [rbp-28h]

  v8 = a2;
  v19 = __readfsqword(0x28u);
  v12 = *(_QWORD *)(a1 + 64);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "udp_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " iphlen = %d");
  if ( a2 > 0x14 )
  {
    sub_9E0E(a1);
    v8 = 20;
  }
  v2 = *(__int64 **)(a1 + 48);
  v3 = (__int16 *)((char *)v2 + v8);
  v10 = ntohs(v3[2]);
  if ( v10 != *((unsigned __int16 *)v2 + 1) )
  {
    if ( v10 > *((unsigned __int16 *)v2 + 1) )
    {
LABEL_34:
      sub_A4F0(a1);
      return __readfsqword(0x28u) ^ v19;
    }
    sub_A875(a1, v10 - *((unsigned __int16 *)v2 + 1));
    *((_WORD *)v2 + 1) = v10;
  }
  v13 = *v2;
  v14 = v2[1];
  v15 = *((_DWORD *)v2 + 4);
  WORD1(v13) += v8;
  if ( v3[3] )
  {
    memset(v2, 0, 8uLL);
    *((_BYTE *)v2 + 8) = 0;
    *((_WORD *)v2 + 5) = v3[2];
    if ( (unsigned int)sub_44C3(a1, v10 + 20) )
      goto LABEL_34;
  }
  v16 = 2;
  v18 = *((_DWORD *)v2 + 3);
  v17 = *v3;
  if ( ntohs(v3[1]) == 67 && (*((_DWORD *)v2 + 4) == *(_DWORD *)(v12 + 20) || *((_DWORD *)v2 + 4) == -1) )
  {
    sub_4485(a1);
    goto LABEL_34;
  }
  if ( ntohs(v3[1]) == 69 && *((_DWORD *)v2 + 4) == *(_DWORD *)(v12 + 20) )
  {
    *(_QWORD *)(a1 + 48) += v8;
    *(_DWORD *)(a1 + 56) -= v8;
    sub_1A995((unsigned __int16 *)&v16, a1);
    *(_QWORD *)(a1 + 48) -= v8;
    *(_DWORD *)(a1 + 56) += v8;
    goto LABEL_34;
  }
  if ( *(_DWORD *)(v12 + 124) )
    goto LABEL_34;
  v11 = sub_F5A7((unsigned __int16 **)(v12 + 1312), (unsigned __int16 *)(v12 + 888), (__int64)&v16, 0LL);
  if ( !v11 )
  {
    v11 = sub_F694(v12);
    if ( (unsigned int)sub_1B34D((__int64)v11, 2u) == -1 )
    {
      if ( unk_2250E0 & 2 )
      {
        v4 = __errno_location();
        strerror(*v4);
        __errno_location();
        g_log("Slirp", 128LL, " udp_attach errno = %d-%s");
      }
      sub_F77A((__int64)v11);
      goto LABEL_34;
    }
    *((_WORD *)v11 + 100) = 2;
    *((_DWORD *)v11 + 51) = *((_DWORD *)v2 + 3);
    *((_WORD *)v11 + 101) = *v3;
    *((_BYTE *)v11 + 328) = sub_1B422((__int64)v11);
    if ( !*((_BYTE *)v11 + 328) )
      *((_BYTE *)v11 + 328) = *((_BYTE *)v2 + 1);
  }
  *((_WORD *)v11 + 36) = 2;
  *((_DWORD *)v11 + 19) = *((_DWORD *)v2 + 4);
  *((_WORD *)v11 + 37) = v3[1];
  v9 = v8 + 8;
  *(_DWORD *)(a1 + 56) -= v9;
  *(_QWORD *)(a1 + 48) += v9;
  if ( (unsigned int)sub_11417((__int64)v11, a1) == -1 )
  {
    *(_DWORD *)(a1 + 56) += v9;
    *(_QWORD *)(a1 + 48) -= v9;
    *v2 = v13;
    v2[1] = v14;
    *((_DWORD *)v2 + 4) = v15;
    if ( unk_2250E0 & 2 )
    {
      v5 = __errno_location();
      strerror(*v5);
      __errno_location();
      g_log("Slirp", 128LL, "udp tx errno = %d-%s");
    }
    v6 = __errno_location();
    strerror(*v6);
    sub_8B39(a1, 3, 0, 0);
    goto LABEL_34;
  }
  sub_A4F0(*((_QWORD *)v11 + 6));
  *(_DWORD *)(a1 + 56) += v9;
  *(_QWORD *)(a1 + 48) -= v9;
  *v2 = v13;
  v2[1] = v14;
  *((_DWORD *)v2 + 4) = v15;
  *((_QWORD *)v11 + 6) = a1;
  return __readfsqword(0x28u) ^ v19;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001B11D) ----------------------------------------------------
__int64 __fastcall sub_1B11D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  __int64 v5; // rbx
  char v7; // [rsp+Ch] [rbp-44h]
  __int64 v8; // [rsp+10h] [rbp-40h]
  __int64 v9; // [rsp+18h] [rbp-38h]

  v9 = a3;
  v8 = a4;
  v7 = a5;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "udp_output...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( unk_2250E0 & 1 )
  {
    inet_ntoa(*(struct in_addr *)(v9 + 4));
    g_log("Slirp", 128LL, " saddr = %s");
  }
  if ( unk_2250E0 & 1 )
  {
    inet_ntoa(*(struct in_addr *)(v8 + 4));
    g_log("Slirp", 128LL, " daddr = %s");
  }
  *(_QWORD *)(a2 + 48) -= 28LL;
  *(_DWORD *)(a2 + 56) += 28;
  v5 = *(_QWORD *)(a2 + 48);
  memset(*(void **)(a2 + 48), 0, 8uLL);
  *(_BYTE *)(v5 + 8) = 0;
  *(_BYTE *)(v5 + 9) = 17;
  *(_WORD *)(v5 + 10) = htons(*(unsigned int *)(a2 + 56) - 20);
  *(_DWORD *)(v5 + 12) = *(_DWORD *)(v9 + 4);
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v8 + 4);
  *(_WORD *)(v5 + 20) = *(_WORD *)(v9 + 2);
  *(_WORD *)(v5 + 22) = *(_WORD *)(v8 + 2);
  *(_WORD *)(v5 + 24) = *(_WORD *)(v5 + 10);
  *(_WORD *)(v5 + 26) = 0;
  *(_WORD *)(v5 + 26) = sub_44C3(a2, *(_DWORD *)(a2 + 56));
  if ( !*(_WORD *)(v5 + 26) )
    *(_WORD *)(v5 + 26) = -1;
  *(_WORD *)(v5 + 2) = *(_DWORD *)(a2 + 56);
  *(_BYTE *)(v5 + 8) = 64;
  *(_BYTE *)(v5 + 1) = v7;
  return (unsigned int)sub_9E96(a1, a2);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001B34D) ----------------------------------------------------
__int64 __fastcall sub_1B34D(__int64 a1, unsigned __int16 a2)
{
  *(_DWORD *)(a1 + 16) = sub_1C25E(a2, 2, 0);
  if ( *(_DWORD *)(a1 + 16) != -1 )
  {
    *(_DWORD *)(a1 + 344) = unk_2250E8 + 240000;
    sub_AB4C((_QWORD *)a1, (_QWORD *)(*(_QWORD *)(a1 + 40) + 888LL));
  }
  return *(unsigned int *)(a1 + 16);
}

//----- (000000000001B3C9) ----------------------------------------------------
__int64 __fastcall sub_1B3C9(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 5992LL) + 56LL))(
    *(unsigned int *)(a1 + 16),
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 6000LL));
  close(*(_DWORD *)(a1 + 16));
  return sub_F77A(a1);
}

//----- (000000000001B422) ----------------------------------------------------
__int64 __fastcall sub_1B422(__int64 a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    if ( !*((_BYTE *)&unk_1EE3C + 6 * i) )
      return 0LL;
    if ( *(_WORD *)&a5[6 * i] && ntohs(*(_WORD *)(a1 + 74)) == *(_WORD *)&a5[6 * i]
      || *((_WORD *)&unk_1EE38 + 3 * i) && ntohs(*(_WORD *)(a1 + 202)) == *((_WORD *)&unk_1EE38 + 3 * i) )
    {
      break;
    }
  }
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 40) + 5984LL) )
    *(_BYTE *)(a1 + 329) = byte_1EE3D[6 * i];
  return *((unsigned __int8 *)&unk_1EE3C + 6 * i);
}

//----- (000000000001B58F) ----------------------------------------------------
void *__fastcall sub_1B58F(__int64 a1, int a2, __int16 a3, int a4, __int16 a5, int a6)
{
  void *result; // rax
  _QWORD *v7; // rcx
  __int64 v8; // rdx
  int v9; // [rsp+4h] [rbp-4Ch]
  __int16 v10; // [rsp+8h] [rbp-48h]
  int v11; // [rsp+Ch] [rbp-44h]
  __int16 v12; // [rsp+10h] [rbp-40h]
  socklen_t len; // [rsp+24h] [rbp-2Ch]
  _DWORD *v14; // [rsp+28h] [rbp-28h]
  struct sockaddr addr; // [rsp+30h] [rbp-20h]
  unsigned __int64 v16; // [rsp+48h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v16 = __readfsqword(0x28u);
  len = 16;
  v14 = sub_F694(a1);
  v14[4] = sub_1C25E(2, 2, 0);
  if ( v14[4] >= 0 )
  {
    v14[86] = unk_2250E8 + 240000;
    sub_AB4C(v14, (_QWORD *)(a1 + 888));
    addr.sa_family = 2;
    *(_DWORD *)&addr.sa_data[2] = a2;
    *(_WORD *)addr.sa_data = v12;
    if ( bind(v14[4], &addr, len) >= 0 )
    {
      sub_1AA3C(v14[4]);
      getsockname(v14[4], &addr, &len);
      v7 = v14;
      v8 = *(_QWORD *)&addr.sa_data[6];
      *((_QWORD *)v14 + 9) = *(_QWORD *)&addr.sa_family;
      v7[10] = v8;
      sub_11FE2((__int64)v14);
      *((_WORD *)v14 + 100) = 2;
      *((_WORD *)v14 + 101) = v10;
      v14[51] = v11;
      if ( v9 != 512 )
        v14[86] = 0;
      v14[83] &= 0xF000u;
      v14[83] |= v9 | 4;
      result = v14;
    }
    else
    {
      sub_1B3C9((__int64)v14);
      result = 0LL;
    }
  }
  else
  {
    sub_F77A((__int64)v14);
    result = 0LL;
  }
  return result;
}

//----- (000000000001B761) ----------------------------------------------------
bool __fastcall sub_1B761(const void *a1, const void *a2)
{
  return memcmp(a1, a2, 0x10uLL) == 0;
}

//----- (000000000001B790) ----------------------------------------------------
unsigned __int64 __fastcall sub_1B790(__int64 a1)
{
  uint16_t v1; // ax
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 v4; // rdx
  int *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // rdx
  int *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rdx
  signed int v14; // [rsp+1Ch] [rbp-94h]
  void *v15; // [rsp+20h] [rbp-90h]
  __int64 v16; // [rsp+28h] [rbp-88h]
  __int64 v17; // [rsp+30h] [rbp-80h]
  __int64 v18; // [rsp+38h] [rbp-78h]
  char v19; // [rsp+40h] [rbp-70h]
  char v20; // [rsp+41h] [rbp-6Fh]
  char v21; // [rsp+42h] [rbp-6Eh]
  char v22; // [rsp+43h] [rbp-6Dh]
  char v23; // [rsp+44h] [rbp-6Ch]
  char v24; // [rsp+45h] [rbp-6Bh]
  char v25; // [rsp+46h] [rbp-6Ah]
  char v26; // [rsp+47h] [rbp-69h]
  char v27; // [rsp+48h] [rbp-68h]
  char v28; // [rsp+49h] [rbp-67h]
  char v29; // [rsp+4Ah] [rbp-66h]
  char v30; // [rsp+4Bh] [rbp-65h]
  char v31; // [rsp+4Ch] [rbp-64h]
  char v32; // [rsp+4Dh] [rbp-63h]
  char v33; // [rsp+4Eh] [rbp-62h]
  char v34; // [rsp+4Fh] [rbp-61h]
  __int16 v35; // [rsp+50h] [rbp-60h]
  __int16 v36; // [rsp+52h] [rbp-5Eh]
  __int64 v37; // [rsp+58h] [rbp-58h]
  __int64 v38; // [rsp+60h] [rbp-50h]
  __int64 v39; // [rsp+70h] [rbp-40h]
  __int64 v40; // [rsp+78h] [rbp-38h]
  __int64 v41; // [rsp+80h] [rbp-30h]
  __int64 v42; // [rsp+88h] [rbp-28h]
  __int64 v43; // [rsp+90h] [rbp-20h]
  unsigned __int64 v44; // [rsp+98h] [rbp-18h]

  v44 = __readfsqword(0x28u);
  v16 = *(_QWORD *)(a1 + 64);
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "udp6_input...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  if ( *(_DWORD *)(v16 + 124) )
    goto LABEL_28;
  v17 = *(_QWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) -= 40;
  *(_QWORD *)(a1 + 48) += 40LL;
  v18 = *(_QWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) += 40;
  *(_QWORD *)(a1 + 48) -= 40LL;
  if ( (unsigned int)sub_4820(a1) )
    goto LABEL_28;
  v14 = ntohs(*(_WORD *)(v18 + 4));
  if ( v14 != ntohs(*(_WORD *)(v17 + 4)) )
  {
    if ( v14 > ntohs(*(_WORD *)(v17 + 4)) )
    {
LABEL_28:
      sub_A4F0(a1);
      return __readfsqword(0x28u) ^ v44;
    }
    v1 = ntohs(*(_WORD *)(v17 + 4));
    sub_A875(a1, v14 - v1);
    *(_WORD *)(v17 + 4) = htons(v14);
  }
  v2 = *(_QWORD *)(v17 + 8);
  v39 = *(_QWORD *)v17;
  v40 = v2;
  v3 = *(_QWORD *)(v17 + 24);
  v41 = *(_QWORD *)(v17 + 16);
  v42 = v3;
  v43 = *(_QWORD *)(v17 + 32);
  v35 = 10;
  v4 = *(_QWORD *)(v17 + 16);
  v37 = *(_QWORD *)(v17 + 8);
  v38 = v4;
  v36 = *(_WORD *)v18;
  if ( ntohs(*(_WORD *)(v18 + 2)) == 547 )
  {
    if ( sub_1B761((const void *)(v17 + 24), (const void *)(v16 + 44)) )
      goto LABEL_32;
    v19 = -1;
    v20 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 1;
    v33 = 0;
    v34 = 2;
    if ( sub_1B761((const void *)(v17 + 24), &v19) )
    {
LABEL_32:
      *(_QWORD *)(a1 + 48) += 40LL;
      *(_DWORD *)(a1 + 56) -= 40;
      sub_5152((__int64)&v35, a1);
      *(_QWORD *)(a1 + 48) -= 40LL;
      *(_DWORD *)(a1 + 56) += 40;
      goto LABEL_28;
    }
  }
  if ( ntohs(*(_WORD *)(v18 + 2)) == 69 && !memcmp((const void *)(v17 + 24), (const void *)(v16 + 44), 0x10uLL) )
  {
    *(_QWORD *)(a1 + 48) += 40LL;
    *(_DWORD *)(a1 + 56) -= 40;
    sub_1A995((unsigned __int16 *)&v35, a1);
    *(_QWORD *)(a1 + 48) -= 40LL;
    *(_DWORD *)(a1 + 56) += 40;
    goto LABEL_28;
  }
  v15 = sub_F5A7((unsigned __int16 **)(v16 + 1312), (unsigned __int16 *)(v16 + 888), (__int64)&v35, 0LL);
  if ( !v15 )
  {
    v15 = sub_F694(v16);
    if ( (unsigned int)sub_1B34D((__int64)v15, 0xAu) == -1 )
    {
      if ( unk_2250E0 & 2 )
      {
        v5 = __errno_location();
        strerror(*v5);
        __errno_location();
        g_log("Slirp", 128LL, " udp6_attach errno = %d-%s");
      }
      sub_F77A((__int64)v15);
      goto LABEL_28;
    }
    *((_WORD *)v15 + 100) = 10;
    v6 = *(_QWORD *)(v17 + 16);
    *((_QWORD *)v15 + 26) = *(_QWORD *)(v17 + 8);
    *((_QWORD *)v15 + 27) = v6;
    *((_WORD *)v15 + 101) = *(_WORD *)v18;
  }
  *((_WORD *)v15 + 36) = 10;
  v7 = *(_QWORD *)(v17 + 32);
  *((_QWORD *)v15 + 10) = *(_QWORD *)(v17 + 24);
  *((_QWORD *)v15 + 11) = v7;
  *((_WORD *)v15 + 37) = *(_WORD *)(v18 + 2);
  *(_DWORD *)(a1 + 56) -= 48;
  *(_QWORD *)(a1 + 48) += 48LL;
  if ( (unsigned int)sub_11417((__int64)v15, a1) == -1 )
  {
    *(_DWORD *)(a1 + 56) += 48;
    *(_QWORD *)(a1 + 48) -= 48LL;
    v8 = v40;
    *(_QWORD *)v17 = v39;
    *(_QWORD *)(v17 + 8) = v8;
    v9 = v42;
    *(_QWORD *)(v17 + 16) = v41;
    *(_QWORD *)(v17 + 24) = v9;
    *(_QWORD *)(v17 + 32) = v43;
    if ( unk_2250E0 & 2 )
    {
      v10 = __errno_location();
      strerror(*v10);
      __errno_location();
      g_log("Slirp", 128LL, "udp tx errno = %d-%s");
    }
    sub_6903(a1, 1u, 0);
    goto LABEL_28;
  }
  sub_A4F0(*((_QWORD *)v15 + 6));
  *(_DWORD *)(a1 + 56) += 48;
  *(_QWORD *)(a1 + 48) -= 48LL;
  v11 = v40;
  *(_QWORD *)v17 = v39;
  *(_QWORD *)(v17 + 8) = v11;
  v12 = v42;
  *(_QWORD *)(v17 + 16) = v41;
  *(_QWORD *)(v17 + 24) = v12;
  *(_QWORD *)(v17 + 32) = v43;
  *((_QWORD *)v15 + 6) = a1;
  return __readfsqword(0x28u) ^ v44;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001BF57) ----------------------------------------------------
__int64 __fastcall sub_1BF57(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST28_8
  __int64 v5; // rdx
  __int64 v6; // rdx
  __int64 v8; // [rsp+0h] [rbp-30h]
  __int64 v9; // [rsp+8h] [rbp-28h]
  __int64 v10; // [rsp+20h] [rbp-10h]

  v9 = a3;
  v8 = a4;
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, "udp6_output...");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " so = %p");
  if ( unk_2250E0 & 1 )
    g_log("Slirp", 128LL, " m = %p");
  *(_QWORD *)(a2 + 48) -= 8LL;
  *(_DWORD *)(a2 + 56) += 8;
  v10 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) -= 40LL;
  *(_DWORD *)(a2 + 56) += 40;
  v4 = *(_QWORD *)(a2 + 48);
  *(_WORD *)(v4 + 4) = htons(*(unsigned int *)(a2 + 56) - 40);
  *(_BYTE *)(v4 + 6) = 17;
  v5 = *(_QWORD *)(v9 + 16);
  *(_QWORD *)(v4 + 8) = *(_QWORD *)(v9 + 8);
  *(_QWORD *)(v4 + 16) = v5;
  v6 = *(_QWORD *)(v8 + 16);
  *(_QWORD *)(v4 + 24) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v4 + 32) = v6;
  *(_WORD *)v10 = *(_WORD *)(v9 + 2);
  *(_WORD *)(v10 + 2) = *(_WORD *)(v8 + 2);
  *(_DWORD *)(v10 + 4) = *(unsigned __int16 *)(v4 + 4);
  *(_WORD *)(v10 + 6) = sub_4820(a2);
  if ( !*(_WORD *)(v10 + 6) )
    *(_WORD *)(v10 + 6) = -1;
  return sub_80BC(a1, a2, 0);
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001C142) ----------------------------------------------------
int __fastcall sub_1C142(int a1)
{
  unsigned int v1; // eax
  int result; // eax
  int v3; // [rsp+1Ch] [rbp-4h]

  v3 = fcntl(a1, 3);
  if ( v3 == -1 )
    __assert_fail("f != -1", "../src/util.c", 0x34u, "slirp_set_nonblock");
  v1 = v3;
  BYTE1(v1) |= 8u;
  result = fcntl(a1, 4, v1);
  if ( result == -1 )
    __assert_fail("f != -1", "../src/util.c", 0x36u, "slirp_set_nonblock");
  return result;
}

//----- (000000000001C1D0) ----------------------------------------------------
int __fastcall sub_1C1D0(int a1)
{
  int result; // eax
  int v2; // [rsp+1Ch] [rbp-4h]

  v2 = fcntl(a1, 1);
  if ( v2 == -1 )
    __assert_fail("f != -1", "../src/util.c", 0x42u, "slirp_set_cloexec");
  result = fcntl(a1, 2, v2 | 1u);
  if ( result == -1 )
    __assert_fail("f != -1", "../src/util.c", 0x44u, "slirp_set_cloexec");
  return result;
}

//----- (000000000001C25E) ----------------------------------------------------
__int64 __fastcall sub_1C25E(int a1, int a2, int a3)
{
  int protocol; // [rsp+4h] [rbp-1Ch]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]
  int v6; // [rsp+1Ch] [rbp-4h]

  protocol = a3;
  v5 = socket(a1, a2 | 0x80000, a3);
  if ( v5 != -1 || *__errno_location() != 22 )
    return v5;
  v6 = socket(a1, a2, protocol);
  if ( v6 >= 0 )
    sub_1C1D0(v6);
  return (unsigned int)v6;
}

//----- (000000000001C2CC) ----------------------------------------------------
_BYTE *__fastcall sub_1C2CC(_BYTE *a1, int a2, char *a3)
{
  _BYTE *result; // rax
  char *v4; // rax
  _BYTE *v5; // rax
  char *v6; // [rsp+0h] [rbp-28h]
  char v7; // [rsp+1Ch] [rbp-Ch]
  _BYTE *v8; // [rsp+20h] [rbp-8h]

  v6 = a3;
  result = a1;
  v8 = a1;
  if ( a2 > 0 )
  {
    while ( 1 )
    {
      v4 = v6++;
      v7 = *v4;
      if ( !*v4 || v8 >= &a1[a2 - 1] )
        break;
      v5 = v8++;
      *v5 = v7;
    }
    result = v8;
    *v8 = 0;
  }
  return result;
}

//----- (000000000001C339) ----------------------------------------------------
const char *slirp_version_string()
{
  return "4.0.0";
}

//----- (000000000001C346) ----------------------------------------------------
signed __int64 __fastcall sub_1C346(__int64 a1)
{
  if ( (unsigned __int8)sub_126BA(a1) == 48 )
    return 0LL;
  g_log("Slirp", 16LL, "vmstate: get_nullptr expected VMS_NULLPTR_MARKER");
  return 4294967274LL;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001C399) ----------------------------------------------------
signed __int64 __fastcall sub_1C399(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( a2 )
  {
    g_log("Slirp", 16LL, "vmstate: put_nullptr must be called with pv == NULL");
    result = 4294967274LL;
  }
  else
  {
    sub_12712(a1, 48);
    result = 0LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001C3F4) ----------------------------------------------------
__int64 __fastcall sub_1C3F4(__int64 a1, _BYTE *a2)
{
  *a2 = sub_126BA(a1);
  return 0LL;
}

//----- (000000000001C42F) ----------------------------------------------------
__int64 __fastcall sub_1C42F(__int64 a1, char *a2)
{
  sub_12712(a1, *a2);
  return 0LL;
}

//----- (000000000001C46E) ----------------------------------------------------
__int64 __fastcall sub_1C46E(__int64 a1, __int16 *a2)
{
  *a2 = sub_1273D(a1);
  return 0LL;
}

//----- (000000000001C4AA) ----------------------------------------------------
__int64 __fastcall sub_1C4AA(__int64 a1, __int16 *a2)
{
  sub_12799(a1, *a2);
  return 0LL;
}

//----- (000000000001C4E9) ----------------------------------------------------
__int64 __fastcall sub_1C4E9(__int64 a1, _DWORD *a2)
{
  *a2 = sub_127D1(a1);
  return 0LL;
}

//----- (000000000001C524) ----------------------------------------------------
__int64 __fastcall sub_1C524(__int64 a1, unsigned int *a2)
{
  sub_1284F(a1, *a2);
  return 0LL;
}

//----- (000000000001C55F) ----------------------------------------------------
__int64 __fastcall sub_1C55F(__int64 a1, __int16 *a2)
{
  *a2 = sub_128A5(a1);
  return 0LL;
}

//----- (000000000001C59B) ----------------------------------------------------
__int64 __fastcall sub_1C59B(__int64 a1, __int16 *a2)
{
  sub_12901(a1, *a2);
  return 0LL;
}

//----- (000000000001C5DA) ----------------------------------------------------
__int64 __fastcall sub_1C5DA(__int64 a1, _DWORD *a2)
{
  *a2 = sub_12939(a1);
  return 0LL;
}

//----- (000000000001C615) ----------------------------------------------------
__int64 __fastcall sub_1C615(__int64 a1, unsigned int *a2)
{
  sub_129B7(a1, *a2);
  return 0LL;
}

//----- (000000000001C650) ----------------------------------------------------
__int64 __fastcall sub_1C650(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST30_8
  int v5; // ST28_4
  _QWORD *v6; // rax
  _QWORD *v7; // ST38_8
  unsigned int v8; // ST2C_4

  v4 = *(_QWORD *)(a4 + 72);
  v5 = *(_DWORD *)(a4 + 80);
  v6 = (_QWORD *)g_malloc(a3);
  v7 = v6;
  *v6 = a2;
  v8 = sub_1CD2E(a1, v4, (__int64)v6, v5);
  g_free(v7);
  return v8;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);

//----- (000000000001C6C4) ----------------------------------------------------
__int64 __fastcall sub_1C6C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // ST30_8
  _QWORD *v5; // rax
  _QWORD *v6; // ST38_8
  unsigned int v7; // ST2C_4

  v4 = *(_QWORD *)(a4 + 72);
  v5 = (_QWORD *)g_malloc(a3);
  v6 = v5;
  *v5 = a2;
  v7 = sub_1CC71(a1, v4, (__int64)v5);
  g_free(v6);
  return v7;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);
// 2D70: using guessed type __int64 __fastcall g_free(_QWORD);

//----- (000000000001C72E) ----------------------------------------------------
__int64 __fastcall sub_1C72E(__int64 a1, __int64 a2, __int64 a3)
{
  sub_12648(a1, a2, a3);
  return 0LL;
}

//----- (000000000001C764) ----------------------------------------------------
__int64 __fastcall sub_1C764(__int64 a1, __int64 a2, __int64 a3)
{
  sub_12681(a1, a2, a3);
  return 0LL;
}

//----- (000000000001C79A) ----------------------------------------------------
__int64 __fastcall sub_1C79A(__int64 a1, __int64 a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v3 = 1;
  if ( *(_DWORD *)(a2 + 64) & 4 )
  {
    v3 = *(_DWORD *)(a2 + 32);
  }
  else if ( *(_DWORD *)(a2 + 64) & 0x10 )
  {
    v3 = *(_DWORD *)(*(_QWORD *)(a2 + 40) + a1);
  }
  else if ( *(_DWORD *)(a2 + 64) & 0x800 )
  {
    v3 = *(_DWORD *)(*(_QWORD *)(a2 + 40) + a1);
  }
  else if ( *(_DWORD *)(a2 + 64) & 0x80 )
  {
    v3 = *(unsigned __int16 *)(*(_QWORD *)(a2 + 40) + a1);
  }
  else if ( *(_DWORD *)(a2 + 64) & 0x400 )
  {
    v3 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 40) + a1);
  }
  if ( *(_DWORD *)(a2 + 64) & 0x4000 )
    v3 *= *(_DWORD *)(a2 + 32);
  return v3;
}

//----- (000000000001C88B) ----------------------------------------------------
__int64 __fastcall sub_1C88B(__int64 a1, __int64 a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v3 = *(_QWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 64) & 0x100 )
  {
    v3 = *(_DWORD *)(*(_QWORD *)(a2 + 48) + a1);
    if ( *(_DWORD *)(a2 + 64) & 0x200 )
      v3 *= (unsigned int)*(_QWORD *)(a2 + 16);
  }
  return v3;
}

//----- (000000000001C8F0) ----------------------------------------------------
__int64 __fastcall sub_1C8F0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 result; // rax
  unsigned int v5; // [rsp+4h] [rbp-4Ch]
  __int64 v6; // [rsp+8h] [rbp-48h]
  unsigned int v7; // [rsp+28h] [rbp-28h]
  unsigned int v8; // [rsp+28h] [rbp-28h]
  int i; // [rsp+2Ch] [rbp-24h]
  int v10; // [rsp+30h] [rbp-20h]
  int v11; // [rsp+34h] [rbp-1Ch]
  __int64 v12; // [rsp+38h] [rbp-18h]
  _QWORD *v13; // [rsp+40h] [rbp-10h]
  _QWORD *v14; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v12 = *(_QWORD *)(a2 + 40);
  if ( *(_QWORD *)(a2 + 32) && (v7 = (*(__int64 (__fastcall **)(__int64))(a2 + 32))(a3)) != 0 )
  {
    g_log("Slirp", 16LL, "pre-save failed: %s");
    result = v7;
  }
  else
  {
    while ( *(_QWORD *)v12 )
    {
      if ( *(_QWORD *)(v12 + 88) && (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v12 + 88))(v6, v5)
        || !*(_QWORD *)(v12 + 88) && (signed int)v5 >= *(_DWORD *)(v12 + 80) )
      {
        v13 = (_QWORD *)(*(_QWORD *)(v12 + 8) + v6);
        v10 = sub_1C79A(v6, v12);
        v11 = sub_1C88B(v6, v12);
        if ( *(_DWORD *)(v12 + 64) & 2 )
        {
          v13 = (_QWORD *)*v13;
          if ( !v13 && v10 && v11 )
            __assert_fail("first_elem || !n_elems || !size", "../src/vmstate.c", 0x140u, "vmstate_save_state_v");
        }
        for ( i = 0; i < v10; ++i )
        {
          v14 = (_QWORD *)((char *)v13 + i * v11);
          if ( *(_DWORD *)(v12 + 64) & 0x40 )
          {
            if ( !v14 )
              __assert_fail("curr_elem", "../src/vmstate.c", 0x147u, "vmstate_save_state_v");
            v14 = (_QWORD *)*v14;
          }
          if ( v14 || !v11 )
          {
            if ( *(_DWORD *)(v12 + 64) & 8 )
            {
              v8 = sub_1CC71(a1, *(_QWORD *)(v12 + 72), (__int64)v14);
            }
            else if ( *(_DWORD *)(v12 + 64) & 0x8000 )
            {
              v8 = sub_1C8F0(a1, *(_QWORD *)(v12 + 72), (__int64)v14, *(_DWORD *)(v12 + 84));
            }
            else
            {
              v8 = (*(__int64 (__fastcall **)(__int64, _QWORD *, _QWORD, __int64))(*(_QWORD *)(v12 + 56) + 16LL))(
                     a1,
                     v14,
                     v11,
                     v12);
            }
          }
          else
          {
            if ( !(*(_DWORD *)(v12 + 64) & 0x40) )
              __assert_fail("field->flags & VMS_ARRAY_OF_POINTER", "../src/vmstate.c", 0x14Cu, "vmstate_save_state_v");
            v8 = sub_1C399(a1, 0LL);
          }
          if ( v8 )
          {
            g_log("Slirp", 16LL, "Save of field %s/%s failed");
            return v8;
          }
        }
      }
      else if ( *(_DWORD *)(v12 + 64) & 0x1000 )
      {
        g_log("Slirp", 16LL, "Output state validation failed: %s/%s");
        if ( *(_DWORD *)(v12 + 64) & 0x1000 )
          __assert_fail("!(field->flags & VMS_MUST_EXIST)", "../src/vmstate.c", 0x161u, "vmstate_save_state_v");
      }
      v12 += 96LL;
    }
    result = 0LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001CC71) ----------------------------------------------------
__int64 __fastcall sub_1CC71(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1C8F0(a1, a2, a3, *(_DWORD *)(a2 + 8));
}

//----- (000000000001CCA2) ----------------------------------------------------
__int64 __fastcall sub_1CCA2(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // ST28_8
  __int64 v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-28h]

  v6 = a3;
  result = *(_DWORD *)(a2 + 64) & 2;
  if ( (_DWORD)result )
  {
    result = *(_DWORD *)(a2 + 64) & 0x2000;
    if ( (_DWORD)result )
    {
      v4 = (signed int)sub_1C88B(a3, a2);
      result = v4 * (signed int)sub_1C79A(v6, a2);
      if ( result )
      {
        v5 = g_malloc(result);
        result = (__int64)a1;
        *a1 = v5;
      }
    }
  }
  return result;
}
// 2D50: using guessed type __int64 __fastcall g_malloc(_QWORD);

//----- (000000000001CD2E) ----------------------------------------------------
signed __int64 __fastcall sub_1CD2E(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  signed __int64 result; // rax
  unsigned int v5; // [rsp+4h] [rbp-4Ch]
  __int64 v6; // [rsp+8h] [rbp-48h]
  unsigned int v7; // [rsp+24h] [rbp-2Ch]
  int i; // [rsp+28h] [rbp-28h]
  unsigned int v9; // [rsp+2Ch] [rbp-24h]
  int v10; // [rsp+30h] [rbp-20h]
  int v11; // [rsp+34h] [rbp-1Ch]
  __int64 v12; // [rsp+38h] [rbp-18h]
  __int64 *v13; // [rsp+40h] [rbp-10h]
  _QWORD *v14; // [rsp+48h] [rbp-8h]

  v6 = a3;
  v5 = a4;
  v12 = *(_QWORD *)(a2 + 40);
  v7 = 0;
  if ( a4 <= *(_DWORD *)(a2 + 8) )
  {
    if ( *(_QWORD *)(a2 + 16) && (v9 = (*(__int64 (__fastcall **)(__int64))(a2 + 16))(a3)) != 0 )
    {
      result = v9;
    }
    else
    {
      while ( *(_QWORD *)v12 )
      {
        if ( *(_QWORD *)(v12 + 88) && (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v12 + 88))(v6, v5)
          || !*(_QWORD *)(v12 + 88) && (signed int)v5 >= *(_DWORD *)(v12 + 80) )
        {
          v13 = (__int64 *)(*(_QWORD *)(v12 + 8) + v6);
          v10 = sub_1C79A(v6, v12);
          v11 = sub_1C88B(v6, v12);
          sub_1CCA2(v13, v12, v6);
          if ( *(_DWORD *)(v12 + 64) & 2 )
          {
            v13 = (__int64 *)*v13;
            if ( !v13 && v10 && v11 )
              __assert_fail("first_elem || !n_elems || !size", "../src/vmstate.c", 0x197u, "slirp_vmstate_load_state");
          }
          for ( i = 0; i < v10; ++i )
          {
            v14 = (__int64 *)((char *)v13 + i * v11);
            if ( *(_DWORD *)(v12 + 64) & 0x40 )
              v14 = (_QWORD *)*v14;
            if ( v14 || !v11 )
            {
              if ( *(_DWORD *)(v12 + 64) & 8 )
              {
                v7 = sub_1CD2E(a1, *(_QWORD *)(v12 + 72), v14, *(unsigned int *)(*(_QWORD *)(v12 + 72) + 8LL));
              }
              else if ( *(_DWORD *)(v12 + 64) & 0x8000 )
              {
                v7 = sub_1CD2E(a1, *(_QWORD *)(v12 + 72), v14, *(unsigned int *)(v12 + 84));
              }
              else
              {
                v7 = (*(__int64 (__fastcall **)(__int64, _QWORD *, _QWORD, __int64))(*(_QWORD *)(v12 + 56) + 8LL))(
                       a1,
                       v14,
                       v11,
                       v12);
              }
            }
            else
            {
              if ( !(*(_DWORD *)(v12 + 64) & 0x40) )
                __assert_fail(
                  "field->flags & VMS_ARRAY_OF_POINTER",
                  "../src/vmstate.c",
                  0x1A1u,
                  "slirp_vmstate_load_state");
              v7 = sub_1C346(a1);
            }
            if ( (v7 & 0x80000000) != 0 )
            {
              g_log("Slirp", 16LL, "Failed to load %s:%s");
              return v7;
            }
          }
        }
        else if ( *(_DWORD *)(v12 + 64) & 0x1000 )
        {
          g_log("Slirp", 16LL, "Input validation failed: %s/%s");
          return 0xFFFFFFFFLL;
        }
        v12 += 96LL;
      }
      if ( *(_QWORD *)(a2 + 24) )
        v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a2 + 24))(v6, v5);
      result = v7;
    }
  }
  else
  {
    g_log("Slirp", 16LL, "%s: incoming version_id %d is too new for local version_id %d");
    result = 4294967274LL;
  }
  return result;
}
// 3080: using guessed type __int64 __fastcall g_log(_QWORD, _QWORD, _QWORD);

//----- (000000000001D0D0) ----------------------------------------------------
int __fastcall sub_1D0D0(char *filename, struct stat64 *stat_buf)
{
  return __xstat64(1, filename, stat_buf);
}

//----- (000000000001D0E0) ----------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 269 function(s) have been successfully decompiled
