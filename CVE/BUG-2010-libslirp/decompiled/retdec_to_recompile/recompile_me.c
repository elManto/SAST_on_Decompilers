//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

/*
struct _IO_FILE {
    int32_t e0;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};
*/

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10030(int64_t a1, int64_t a2, int32_t a3);
int64_t function_10238(int64_t a1);
int64_t function_10307(int64_t a1);
int64_t function_106a3(int64_t a1);
int64_t function_10a5a(int64_t a1);
int64_t function_11417(int64_t a1, int64_t a2);
int64_t function_116c0(int64_t a1, int32_t a2, int64_t net_short, int64_t a4, int64_t a5, char * a6);
int64_t function_11aba(int64_t result);
int64_t function_11af7(int64_t result);
int64_t function_11b34(int64_t result);
int64_t function_11be0(int64_t result);
int64_t function_11c8c(int64_t a1);
int64_t function_11cd0(int64_t a1, int64_t a2);
int64_t function_11e85(int64_t a1, int64_t * a2);
int64_t function_11fe2(int64_t result2);
int64_t function_120b2(int64_t a1, int64_t a2);
int64_t function_12107(int64_t a1, int64_t a2);
int64_t function_12129(int64_t a1);
int64_t function_12190(int64_t a1, int64_t a2);
int64_t function_1228a(int64_t a1, int64_t a2);
int64_t function_1229e(int64_t a1, int64_t a2);
int64_t function_122c1(int64_t a1);
int64_t function_1230a(int64_t a1);
int64_t function_12361(int64_t a1, int64_t a2);
int64_t function_12648(int64_t a1, int64_t * a2, int64_t a3);
int64_t function_12681(int64_t a1, char * a2, int64_t a3);
int64_t function_126ba(int64_t * a1);
int64_t function_12712(int64_t * a1, int64_t a2);
int64_t function_1273d(int64_t a1);
int64_t function_12799(int64_t a1, uint64_t a2);
int64_t function_127d1(int64_t a1);
int64_t function_1284f(int64_t a1, int64_t a2);
int64_t function_128a5(int64_t a1);
int64_t function_12901(int64_t a1, uint64_t a2);
int64_t function_12939(int64_t a1);
int64_t function_129b7(int64_t a1, int64_t a2);
int64_t function_12a0d(int64_t a1, int64_t a2, int64_t a3);
int64_t function_12cfb(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_14fe8(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t function_1514f(int64_t a1, int64_t a2);
int64_t function_15314(int64_t a1, int64_t a2);
int64_t function_15563(int64_t a1);
int64_t function_16346(int64_t a1);
int64_t function_163f5(int64_t sock);
int64_t function_1644d(int64_t sock);
int64_t function_164a5(int64_t * a1);
int64_t function_164fc(int64_t result);
int64_t function_16557(int64_t a1);
int64_t function_1659d(int64_t a1);
int64_t function_16709(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t function_16ebd(int64_t a1);
int64_t function_16fc0(int64_t a1, int64_t a2);
int64_t function_17098(int64_t a1);
int64_t function_17227(int64_t a1);
int64_t function_17310(int64_t a1, uint64_t a2);
int64_t function_17600(int64_t a1);
int64_t function_17b83(int64_t a1);
int64_t function_17be5(int64_t a1);
int64_t function_17d52(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_190aa(int64_t a1);
int64_t function_19297(int64_t result);
int64_t function_1933b(int64_t result);
int64_t function_1949b(int64_t result);
int64_t function_194c9(int64_t result, int64_t a2);
int64_t function_19784(int64_t str, int64_t str2);
int64_t function_197b3(int64_t a1, int64_t a2);
int64_t function_198b7(int64_t a1);
int64_t function_1990e(int64_t a1);
int64_t function_19928(int64_t result);
int64_t function_19948(int64_t result);
int64_t function_19996(int64_t a1, int64_t a2, int64_t a3);
int64_t function_19aac(int64_t a1, int64_t a2, int64_t a3);
int64_t function_19b4e(int64_t a1, int32_t a2, int64_t buf, int64_t a4);
int64_t function_19bfb(int64_t a1, int64_t a2);
int64_t function_19c9c(int64_t a1, int64_t a2, int64_t a3);
int64_t function_19d9e(int64_t a1, int64_t * a2, int64_t * a3, uint32_t a4, int64_t a5);
int64_t function_19efe(int64_t a1, int64_t host_short, char * str, int64_t a4);
int64_t function_1a007(int64_t result, int64_t a2);
int64_t function_1a151(int64_t a1, int64_t a2, int64_t a3, int32_t a4);
int64_t function_1a8b4(int64_t a1, int64_t a2, int64_t a3, int32_t a4);
int64_t function_1a928(int64_t a1, int64_t a2, int64_t a3, int32_t a4);
int64_t function_1a995(int16_t * a1, int64_t a2);
int64_t function_1aa3c(int64_t sock);
int64_t function_1aa94(int64_t result);
int64_t function_1aae1(int64_t a1);
int64_t function_1ab20(int64_t a1, int64_t a2);
int64_t function_1b11d(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t a5);
int64_t function_1b34d(int64_t a1, uint64_t a2);
int64_t function_1b3c9(int64_t a1);
int64_t function_1b422(int64_t a1);
int64_t function_1b58f(int64_t a1, int32_t a2, int64_t a3, int64_t a4, int64_t a5, char * a6);
int64_t function_1b761(int64_t str, int64_t str2);
int64_t function_1b790(int64_t a1);
int64_t function_1bf57(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4);
int64_t function_1c142(int64_t a1);
int64_t function_1c1d0(int64_t a1);
int64_t function_1c25e(int64_t a1, int64_t a2, int64_t a3);
int64_t function_1c2cc(int64_t result, int64_t a2, int64_t a3);
int64_t function_1c346(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c399(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c3f4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c42f(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c46e(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c4aa(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c4e9(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c524(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c55f(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c59b(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c5da(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c615(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c650(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c6c4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c72e(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c764(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1c79a(int64_t a1, int64_t a2);
int64_t function_1c88b(int64_t a1, int64_t a2);
int64_t function_1c8f0(int64_t a1, int64_t a2, int64_t a3, uint32_t a4);
int64_t function_1cc71(int64_t * a1, char (**a2)[13], int64_t a3);
int64_t function_1cca2(int64_t a1, int64_t a2, int64_t a3);
int64_t function_1cd2e(int64_t * a1, char (**a2)[13], int64_t a3, uint32_t a4);
int64_t function_1d0d0(char * a1, int64_t a2);
int64_t function_1d0e0(void);
int64_t function_2cb8(void);
int64_t function_2cd0(void);
char * function_2ce0(int32_t af, int64_t * cp, char * buf, int32_t len);
int64_t function_2cf0(int64_t * a1, int64_t a2, int64_t a3);
void function_2d00(int64_t * ptr);
int32_t function_2d10(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_2d20(char * s1, char * s2);
int64_t function_2d30(int64_t a1);
int32_t * function_2d40(void);
int64_t function_2d50(int64_t a1);
int32_t function_2d60(char * s1, char * s2, int32_t n);
int64_t function_2d70(int64_t a1);
char * function_2d80(char * dest, char * src);
int64_t function_2d90(int64_t a1, int64_t * a2, int64_t a3);
void function_2da0(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_2db0(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t optlen);
int32_t function_2dc0(int32_t fd, int32_t cmd, ...);
char * function_2dd0(struct in_addr in);
int32_t function_2de0(int32_t fd, struct sockaddr * addr, int32_t * len);
int32_t function_2df0(struct _IO_FILE * stream);
int32_t function_2e10(int32_t fd, int32_t how);
int32_t function_2e20(char * s);
void function_2e30(void);
int16_t function_2e40(int16_t hostshort);
int32_t function_2e50(int32_t fd, int32_t fd2);
int32_t function_2e60(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
char * function_2e70(char * s, int32_t c);
int32_t function_2e80(char * s, int32_t maxlen, char * format, ...);
int64_t function_2e90(int64_t a1);
int64_t function_2ea0(char * a1, char * a2, int64_t a3, char * a4, int64_t a5);
void function_2eb0(char * assertion, char * file, int32_t line, char * function);
int64_t function_2ec0(char * a1, char * a2, char * a3);
int32_t function_2ed0(int32_t hostlong);
int64_t * function_2ee0(int64_t * s, int32_t c, int32_t n);
int32_t function_2ef0(int32_t fd, int32_t request, ...);
int32_t function_2f00(int32_t fd, int64_t * buf, int32_t n, int32_t flags, struct sockaddr * addr, int32_t addr_len);
int32_t function_2f10(int32_t fd);
int32_t function_2f20(void);
int64_t function_2f30(int64_t a1, int64_t a2);
int32_t function_2f40(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_2f50(int64_t * s1, int64_t * s2, int32_t n);
char * function_2f60(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_2f70(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t * optlen);
int64_t function_2f80(void);
int64_t function_2f90(int64_t a1, int64_t a2, int64_t a3, int32_t a4, int64_t a5, int64_t * a6, int64_t a7, int64_t a8);
int32_t function_2fa0(char * ifname);
struct _IO_FILE * function_2fb0(char * filename, char * modes);
int64_t * function_2fc0(int64_t * dest, int64_t * src, int32_t n);
int64_t function_2fd0(int64_t a1, int64_t a2, char * a3);
int32_t function_2fe0(int32_t af, char * cp, int64_t * buf);
int64_t * function_2ff0(int32_t size);
int64_t function_3000(int64_t a1, int64_t a2);
int32_t function_3010(char * s, char * format, ...);
int64_t function_3020(int64_t a1, int64_t a2, int64_t a3);
int64_t function_3030(int64_t a1, int64_t * a2, int64_t a3, int64_t * a4);
int32_t function_3040(int32_t fd, int32_t n);
int32_t function_3050(int32_t fd, int64_t * buf, int32_t n, int32_t flags, struct sockaddr * addr, int32_t * addr_len);
int64_t function_3060(int64_t a1);
int64_t function_3070(int64_t a1, char * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3080(char * a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6);
int64_t * function_3090(int64_t * ptr, int32_t size);
int16_t function_30a0(int16_t netshort);
int32_t function_30b0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_30c0(char * file, int32_t oflag, ...);
int64_t * function_30d0(int64_t * dest, int64_t * src, int32_t n);
int64_t function_30e0(int64_t a1, int64_t a2);
int64_t function_30f0(int64_t a1, int64_t a2);
int64_t function_3100(int64_t * a1);
int32_t function_3110(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_3120(int32_t fd, struct sockaddr * addr, int32_t * len);
int32_t function_3130(char * nptr);
int64_t function_3140(int64_t a1);
int64_t function_3150(char * a1);
int32_t function_3160(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_3170(int32_t fd, int32_t offset, int32_t whence);
int32_t function_3180(int32_t netlong);
char * function_3190(int32_t errnum);
char * function_31a0(char * haystack, char * needle);
int64_t function_31b0(int64_t a1);
int32_t function_31c0(int32_t domain, int32_t type, int32_t protocol);
void function_31d0(int64_t * d);
int64_t function_3220(void);
int64_t function_3270(void);
int64_t function_32b0(void);
int64_t function_32ba(int64_t a1, int64_t a2, int32_t * a3);
int64_t function_350e(int64_t a1, int64_t a2, int64_t a3);
int64_t function_36f2(int64_t a1, int32_t * a2, int32_t * str);
int64_t function_37bc(int64_t a1, int64_t * a2, int32_t * str);
int64_t function_3869(int64_t a1, int32_t * a2, int64_t str);
int64_t function_391b(int64_t a1, int64_t * a2, int64_t * a3);
int64_t function_3ad6(int64_t a1, int64_t a2);
int64_t function_4485(int64_t a1);
int64_t function_44c3(int64_t a1, int64_t a2);
int64_t function_4820(int64_t a1);
int64_t function_494b(int64_t a1, int64_t a2, uint32_t a3, int64_t * a4);
int64_t function_4b5b(int64_t a1, int64_t a2, uint32_t a3, int64_t a4, int64_t a5);
int64_t function_5152(int16_t * a1, int64_t a2);
int64_t function_5215(int64_t a1, int64_t a2);
int64_t function_52ae(int64_t a1, int64_t a2);
int64_t function_5378(int64_t a1, int64_t a2);
int64_t function_542e(int64_t a1, int64_t result);
int64_t function_54e9(int64_t result, int64_t a2);
int64_t function_5613(int64_t a1, int64_t a2, uint64_t a3);
int64_t function_5764(int64_t a1, int64_t a2);
int64_t function_58e0(int64_t a1, int64_t a2);
int64_t function_5dca(int64_t result);
int64_t function_5df1(int64_t a1, int64_t a2);
int64_t function_5e38(int64_t a1);
int64_t function_5e6b(int64_t result);
int64_t function_5ece(int64_t a1, int64_t a2);
int64_t function_6168(int64_t result2);
int64_t function_63a8(int64_t str, int64_t * str2);
int64_t function_63d7(int64_t str, int64_t str2, uint64_t a3);
int64_t function_64a4(int64_t a1, int64_t a2, uint64_t a3);
int64_t function_658f(int64_t a1, int64_t a2, int64_t a3);
int64_t function_65cf(int64_t a1);
int64_t function_6697(int64_t a1);
int64_t function_6798(int64_t a1);
int64_t function_67e5(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_6903(int64_t a1, int64_t a2, int64_t a3);
int64_t function_6c7b(int64_t a1);
int64_t function_7017(int64_t a1, int64_t a2, int64_t a3);
int64_t function_72e0(int64_t a1, int64_t a2, int64_t a3);
int64_t function_754e(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_7ae5(int64_t a1);
int64_t function_7e9d(int64_t a1);
int64_t function_7eb8(int64_t a1);
int64_t function_7ed3(int64_t a1);
int64_t function_80bc(int64_t a1, int64_t a2, int64_t a3);
int64_t function_81f2(int64_t a1);
int64_t function_8249(int64_t result);
int64_t function_8296(int64_t a1);
int64_t function_82d5(int64_t a1, int64_t a2, int32_t a3);
int64_t function_84c1(int64_t a1);
int64_t function_851a(int64_t a1, int64_t a2);
int64_t function_8b39(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_8f3f(int64_t a1);
int64_t function_9096(int64_t a1);
int64_t function_929d(int64_t a1);
int64_t function_92fc(int64_t a1);
int64_t function_932f(int64_t a1);
int64_t function_96e7(int64_t a1, int64_t a2, int64_t a3);
int64_t function_9c34(int64_t a1, int64_t a2);
int64_t function_9cb3(int64_t a1, int64_t a2);
int64_t function_9d39(int64_t a1);
int64_t function_9d58(int64_t a1);
int64_t function_9e0e(int64_t a1, int64_t a2);
int64_t function_9e96(int64_t a1, int64_t a2);
int64_t function_a28a(int64_t result);
int64_t function_a2ed(int64_t a1);
int64_t function_a39a(int64_t a1);
int64_t function_a4f0(int64_t a1);
int64_t function_a60d(int64_t a1, int64_t a2);
int64_t function_a70b(int64_t result2, int64_t a2);
int64_t function_a875(int64_t result2, int64_t a2);
int64_t function_a8d5(int64_t a1, int64_t a2, int32_t a3, int32_t a4);
int64_t function_a9b5(int64_t a1, uint64_t a2);
int64_t function_aaf4(int64_t sock);
int64_t function_ab4c(int64_t result, int64_t a2);
int64_t function_ab7f(int64_t a1);
int64_t function_abad(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_ac26(int64_t a1, int64_t a2, uint32_t a3, int64_t a4);
int64_t function_ac7e(int64_t * a1);
int64_t function_ae71(int64_t a1);
int64_t function_ae85(int64_t a1);
int64_t function_aee9(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t * a11);
int64_t function_af8e(int64_t a1, int64_t a2);
int64_t function_b890(int64_t a1, int64_t a2);
int64_t function_b8e6(int64_t a1);
int64_t function_b970(int64_t a1);
int64_t function_b99e(int64_t a1);
int64_t function_b9d7(int64_t a1, int64_t a2, int32_t a3);
int64_t function_bce7(int64_t * str, int64_t * str2);
int64_t function_bd16(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_c04f(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_c3ab(int64_t a1);
int64_t function_c3ca(int64_t a1, int64_t a2);
int64_t function_c48d(int64_t result, int64_t a2);
int64_t function_c59c(int64_t a1, int64_t a2);
int64_t function_c791(int64_t a1, int64_t a2);
int64_t function_c938(int64_t a1, int32_t a2, int64_t a3, int64_t a4);
int64_t function_ca4b(int64_t * str, int64_t * str2);
int64_t function_ca7a(int64_t a1, int64_t a2, int64_t a3);
int64_t function_caba(int64_t a1, int64_t * a2, int64_t a3, int64_t * a4, int64_t * a5);
int64_t function_cc9e(int64_t a1, int64_t a2, int64_t * a3, int64_t a4, int64_t a5, int64_t * a6);
int64_t function_cfd3(int64_t a1);
int64_t function_d049(int64_t * a1, int64_t * a2);
int64_t function_d107(void);
int64_t function_d8ef(int64_t a1, int64_t result);
int64_t function_e15c(int64_t a1, int64_t a2, int32_t a3);
int64_t function_e629(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
int64_t function_e86b(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
int64_t function_e953(int64_t a1, int64_t a2);
int64_t function_ee4d(int64_t a1, int64_t a2, int32_t a3);
int64_t function_f014(int64_t a1, int64_t buf, int64_t length, int64_t flags);
int64_t function_f0a9(int64_t a1, int64_t a2, int64_t a3);
int64_t function_f245(int64_t a1, int64_t * a2, uint64_t a3);
int64_t function_f2f8(int64_t sock);
int64_t function_f350(int64_t str, int64_t str2);
int64_t function_f37f(int64_t str, int64_t str2, uint64_t a3);
int64_t function_f44c(int64_t a1, int64_t a2);
int64_t function_f550(int64_t * a1);
int64_t function_f5a7(int64_t result, int64_t a2, int16_t * a3, int16_t * a4);
int64_t function_f694(int64_t a1);
int64_t function_f6ff(int64_t a1, int64_t result);
int64_t function_f77a(int64_t a1);
int64_t function_f8a6(int64_t a1, int64_t * a2, int64_t a3);
int64_t function_fc35(int64_t a1);
int64_t slirp_add_exec(int64_t a1, int64_t a2, int64_t a3, int64_t host_short);
int64_t slirp_add_guestfwd(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t host_short);
int64_t slirp_add_hostfwd(int64_t a1, int64_t a2, int64_t a3, int64_t host_short2, int64_t a5, int64_t host_short);
int64_t slirp_cleanup(int64_t a1);
int64_t slirp_connection_info(int64_t a1);
int64_t slirp_init(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int32_t a9, int64_t a10, int64_t a11, int64_t a12, int64_t a13, int64_t a14, int64_t a15, int32_t a16, int32_t a17, int64_t a18, int64_t a19, int64_t a20, int64_t a21, int64_t a22, int64_t a23);
int64_t slirp_input(int64_t a1, int64_t a2, int64_t a3);
int64_t slirp_new(int64_t a1, int64_t a2, int64_t a3);
int64_t slirp_pollfds_fill(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t slirp_pollfds_poll(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t slirp_remove_hostfwd(int64_t a1, int64_t a2, int64_t a3, int64_t host_short);
int64_t slirp_socket_can_recv(int64_t a1, int64_t a2, int64_t a3);
int64_t slirp_socket_recv(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t slirp_state_load(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t slirp_state_save(int64_t a1, int64_t a2, int64_t a3);
int64_t slirp_state_version(void);
int64_t slirp_version_string(void);

// --------------------- Global Variables ---------------------

bool g1 = false; // 0x1388
int64_t g2 = 8; // 0x1400
int64_t g3; // 0x1408
int64_t g4 = 0x1ef9000000000; // 0x15cc
char * g7 = "\b"; // 0x1760
int64_t g8; // 0x1768
int64_t g10 = 8; // 0x1778
int64_t g11 = 0x1400000004; // 0x1c8
int64_t g12 = 0x7063686463538263; // 0x1d1a0
int64_t g13 = -0x15fef0001608a; // 0x1d690
int64_t g14 = 0x100000000; // 0x1d7e0
int64_t g15 = -0x14ded00014dee; // 0x1d8e0
int64_t g16 = 0x655f6b726f660020; // 0x1da94
int64_t g17 = 0x207339312d25002a; // 0x1db7d
int64_t g18 = 0x275cc204c8c15735; // 0x1e1
int64_t g19 = -0xa1db0000a1dc; // 0x1e70c
int64_t g20 = -0x98f2000098f3; // 0x1e72c
int64_t g21 = 0x1111101012020014; // 0x1e7d8
int64_t g22 = -0x763b0000763c; // 0x1e908
int64_t g23 = 0x15000800140000; // 0x1e980
int64_t g24 = 0x15001500080014; // 0x1e982
int64_t g25 = 0x210001500150008; // 0x1e984
int64_t g26 = -0x5ad500005ad6; // 0x1eb50
int32_t * g27 = (int32_t *)0x200000001; // 0x1ec60
int64_t g28 = 0x1000350000; // 0x1ee38
int64_t g29 = 0x100035; // 0x1ee3a
int64_t g30 = 16; // 0x1ee3c
int32_t g31 = 0x550000; // 0x1f2
int32_t g32 = 0x5500; // 0x1f3
int32_t g33 = -0x13f7b; // 0x1f400
bool g34 = false; // 0x1ff
int32_t g36 = 0x8340601; // 0x200
int32_t g37 = 8; // 0x2000
int32_t g38 = 0xc480206; // 0x20000
int64_t g39 = 0x1046a17010480834; // 0x202
int32_t g40 = -0x5e8fefb8; // 0x204
int64_t g41 = 0x400000080; // 0x222900
char (*g42)[13] = "slirp-socket"; // 0x222c20
char (*g43)[6] = "slirp"; // 0x222ca0
char (*g44)[6] = "int16"; // 0x222d50
int16_t g45 = 0x5900; // 0x223
char (*g47)[8] = "t_timer"; // 0x223320
int32_t g48 = 89; // 0x224
int64_t g49 = 0; // 0x224f40
int64_t g50 = 0; // 0x224f60
int64_t g51 = 0; // 0x224f70
int64_t g52 = 0; // 0x224f80
int64_t g53 = 0; // 0x224f84
int64_t g54 = 0; // 0x224fa0
int64_t g55 = 0; // 0x225040
int32_t g56 = 0; // 0x2250d0
int64_t g57 = 0; // 0x2250d8
int32_t * g58 = NULL; // 0x2250e0
int32_t * g59 = NULL; // 0x2250e4
int32_t * g60 = NULL; // 0x2250e8
char g61 = 0; // 0x2250ec
int64_t g62 = 0x5b0000005a00; // 0x227
int32_t g63 = 96; // 0x240
int64_t g64 = -0x6179a082b405f665; // 0x25b
int64_t g65 = -0x51b38443b049c765; // 0x27f
int64_t g66 = 0x4a20e99b5ca0eea5; // 0x293
int64_t g67 = 0; // 0x2af
int64_t g68 = 0; // 0x368
int32_t * g69 = NULL; // 0x370
int32_t * g70 = (int32_t *)0x1000000000; // 0x374
int64_t g71 = 0x2000000010; // 0x378
int64_t g72 = 0; // 0x380
int64_t g73 = 0x120000019f0000; // 0x3be
int32_t g74 = 0; // 0x3e7
int32_t g75 = 0; // 0x3e8
int32_t g76 = 0; // 0x400
bool g77 = true; // 0x4b0
int64_t g78 = 0; // 0x520
int64_t g79 = 0x1200000222; // 0x528
int64_t g80 = 0; // 0x530
int32_t g81 = 0; // 0x594
int32_t g82 = 0; // 0x596
int32_t g83 = 0; // 0x5dc
int64_t g84 = 0; // 0x5f1
int64_t g85 = 0; // 0x6d0
int64_t g86 = 0x120000029a; // 0x6d8
int64_t g87 = 0; // 0x6e0
int16_t g88 = 1; // 0x708
int16_t g89 = 0; // 0x800
int16_t g90 = 0; // 0x806
int32_t g91;
char (**g46)[6] = &g44; // 0x2232f8
char * g5[2] = {
    "t_state",
    (char *)&g46
}; // 0x1750
char (***g6)[6] = &g46; // 0x1758
char (**g9)[8] = &g47; // 0x1770
int64_t * g35 = (int64_t *)&g89; // 0x1fff

// ------------------------ Functions -------------------------

// Address range: 0x2cb8 - 0x2ccf
int64_t function_2cb8(void) {
    int64_t result = 0; // 0x2cc6
    if (*(int64_t *)0x222fe0 != 0) {
        // 0x2cc8
        __gmon_start__();
        result = &g91;
    }
    // 0x2cca
    return result;
}

// Address range: 0x2cd0 - 0x2cdc
int64_t function_2cd0(void) {
    // 0x2cd0
    int64_t result; // 0x2cd0
    return result;
}

// Address range: 0x2ce0 - 0x2ce6
char * function_2ce0(int32_t af, int64_t * cp, char * buf, int32_t len) {
    // 0x2ce0
    return inet_ntop(af, cp, buf, len);
}

// Address range: 0x2cf0 - 0x2d00
int64_t function_2cf0(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x2cf0
    return function_2cd0();
}

// Address range: 0x2d00 - 0x2d06
void function_2d00(int64_t * ptr) {
    // 0x2d00
    free(ptr);
}

// Address range: 0x2d10 - 0x2d16
int32_t function_2d10(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x2d10
    return recv(fd, buf, n, flags);
}

// Address range: 0x2d20 - 0x2d26
int32_t function_2d20(char * s1, char * s2) {
    // 0x2d20
    return strcasecmp(s1, s2);
}

// Address range: 0x2d30 - 0x2d36
int64_t function_2d30(int64_t a1) {
    // 0x2d30
    return g_string_new();
}

// Address range: 0x2d40 - 0x2d46
int32_t * function_2d40(void) {
    // 0x2d40
    return __errno_location();
}

// Address range: 0x2d50 - 0x2d56
int64_t function_2d50(int64_t a1) {
    // 0x2d50
    return g_malloc();
}

// Address range: 0x2d60 - 0x2d66
int32_t function_2d60(char * s1, char * s2, int32_t n) {
    // 0x2d60
    return strncmp(s1, s2, n);
}

// Address range: 0x2d70 - 0x2d76
int64_t function_2d70(int64_t a1) {
    // 0x2d70
    return g_free();
}

// Address range: 0x2d80 - 0x2d86
char * function_2d80(char * dest, char * src) {
    // 0x2d80
    return strcpy(dest, src);
}

// Address range: 0x2d90 - 0x2d96
int64_t function_2d90(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x2d90
    return g_strsplit();
}

// Address range: 0x2da0 - 0x2da6
void function_2da0(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x2da0
    qsort(base, nmemb, size, compar);
}

// Address range: 0x2db0 - 0x2db6
int32_t function_2db0(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t optlen) {
    // 0x2db0
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x2dc0 - 0x2dc6
int32_t function_2dc0(int32_t fd, int32_t cmd, ...) {
    // 0x2dc0
    return fcntl(fd, cmd);
}

// Address range: 0x2dd0 - 0x2dd6
char * function_2dd0(struct in_addr in) {
    // 0x2dd0
    return inet_ntoa(in);
}

// Address range: 0x2de0 - 0x2de6
int32_t function_2de0(int32_t fd, struct sockaddr * addr, int32_t * len) {
    // 0x2de0
    return getpeername(fd, addr, len);
}

// Address range: 0x2df0 - 0x2df6
int32_t function_2df0(struct _IO_FILE * stream) {
    // 0x2df0
    return fclose(stream);
}



// Address range: 0x2e10 - 0x2e16
int32_t function_2e10(int32_t fd, int32_t how) {
    // 0x2e10
    return shutdown(fd, how);
}

// Address range: 0x2e20 - 0x2e26
int32_t function_2e20(char * s) {
    // 0x2e20
    return strlen(s);
}

// Address range: 0x2e30 - 0x2e36
void function_2e30(void) {
    // 0x2e30
    __stack_chk_fail();
}

// Address range: 0x2e40 - 0x2e46
int16_t function_2e40(int16_t hostshort) {
    // 0x2e40
    return htons(hostshort);
}

// Address range: 0x2e50 - 0x2e56
int32_t function_2e50(int32_t fd, int32_t fd2) {
    // 0x2e50
    return dup2(fd, fd2);
}

// Address range: 0x2e60 - 0x2e66
int32_t function_2e60(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x2e60
    return send(fd, buf, n, flags);
}

// Address range: 0x2e70 - 0x2e76
char * function_2e70(char * s, int32_t c) {
    // 0x2e70
    return strchr(s, c);
}

// Address range: 0x2e80 - 0x2e86
int32_t function_2e80(char * s, int32_t maxlen, char * format, ...) {
    // 0x2e80
    return snprintf(s, maxlen, format);
}

// Address range: 0x2e90 - 0x2e96
int64_t function_2e90(int64_t a1) {
    // 0x2e90
    return g_rand_free();
}

// Address range: 0x2ea0 - 0x2ea6
int64_t function_2ea0(char * a1, char * a2, int64_t a3, char * a4, int64_t a5) {
    // 0x2ea0
    return g_assertion_message_expr();
}

// Address range: 0x2eb0 - 0x2eb6
void function_2eb0(char * assertion, char * file, int32_t line, char * function) {
    // 0x2eb0
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x2ec0 - 0x2ec6
int64_t function_2ec0(char * a1, char * a2, char * a3) {
    // 0x2ec0
    return g_return_if_fail_warning();
}

// Address range: 0x2ed0 - 0x2ed6
int32_t function_2ed0(int32_t hostlong) {
    // 0x2ed0
    return htonl(hostlong);
}

// Address range: 0x2ee0 - 0x2ee6
int64_t * function_2ee0(int64_t * s, int32_t c, int32_t n) {
    // 0x2ee0
    return memset(s, c, n);
}

// Address range: 0x2ef0 - 0x2ef6
int32_t function_2ef0(int32_t fd, int32_t request, ...) {
    // 0x2ef0
    return ioctl(fd, request);
}

// Address range: 0x2f00 - 0x2f06
int32_t function_2f00(int32_t fd, int64_t * buf, int32_t n, int32_t flags, struct sockaddr * addr, int32_t addr_len) {
    // 0x2f00
    return sendto(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x2f10 - 0x2f16
int32_t function_2f10(int32_t fd) {
    // 0x2f10
    return close(fd);
}

// Address range: 0x2f20 - 0x2f26
int32_t function_2f20(void) {
    // 0x2f20
    return setsid();
}

// Address range: 0x2f30 - 0x2f36
int64_t function_2f30(int64_t a1, int64_t a2) {
    // 0x2f30
    return g_string_free();
}

// Address range: 0x2f40 - 0x2f46
int32_t function_2f40(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x2f40
    return read(fd, buf, nbytes);
}

// Address range: 0x2f50 - 0x2f56
int32_t function_2f50(int64_t * s1, int64_t * s2, int32_t n) {
    // 0x2f50
    return memcmp(s1, s2, n);
}

// Address range: 0x2f60 - 0x2f66
char * function_2f60(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x2f60
    return fgets(s, n, stream);
}

// Address range: 0x2f70 - 0x2f76
int32_t function_2f70(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t * optlen) {
    // 0x2f70
    return getsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x2f80 - 0x2f86
int64_t function_2f80(void) {
    // 0x2f80
    return g_rand_new();
}

// Address range: 0x2f90 - 0x2f96
int64_t function_2f90(int64_t a1, int64_t a2, int64_t a3, int32_t a4, int64_t a5, int64_t * a6, int64_t a7, int64_t a8) {
    // 0x2f90
    return g_spawn_async();
}

// Address range: 0x2fa0 - 0x2fa6
int32_t function_2fa0(char * ifname) {
    // 0x2fa0
    return if_nametoindex(ifname);
}

// Address range: 0x2fb0 - 0x2fb6
struct _IO_FILE * function_2fb0(char * filename, char * modes) {
    // 0x2fb0
    return fopen64(filename, modes);
}

// Address range: 0x2fc0 - 0x2fc6
int64_t * function_2fc0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x2fc0
    return memcpy(dest, src, n);
}

// Address range: 0x2fd0 - 0x2fd6
int64_t function_2fd0(int64_t a1, int64_t a2, char * a3) {
    // 0x2fd0
    return g_strstr_len();
}

// Address range: 0x2fe0 - 0x2fe6
int32_t function_2fe0(int32_t af, char * cp, int64_t * buf) {
    // 0x2fe0
    return inet_pton(af, cp, buf);
}

// Address range: 0x2ff0 - 0x2ff6
int64_t * function_2ff0(int32_t size) {
    // 0x2ff0
    return malloc(size);
}

// Address range: 0x3000 - 0x3006
int64_t function_3000(int64_t a1, int64_t a2) {
    // 0x3000
    return g_malloc_n();
}

// Address range: 0x3010 - 0x3016
int32_t function_3010(char * s, char * format, ...) {
    // 0x3010
    return sscanf(s, format);
}

// Address range: 0x3020 - 0x3026
int64_t function_3020(int64_t a1, int64_t a2, int64_t a3) {
    // 0x3020
    return g_rand_int_range();
}

// Address range: 0x3030 - 0x3036
int64_t function_3030(int64_t a1, int64_t * a2, int64_t a3, int64_t * a4) {
    // 0x3030
    return g_parse_debug_string();
}

// Address range: 0x3040 - 0x3046
int32_t function_3040(int32_t fd, int32_t n) {
    // 0x3040
    return listen(fd, n);
}

// Address range: 0x3050 - 0x3056
int32_t function_3050(int32_t fd, int64_t * buf, int32_t n, int32_t flags, struct sockaddr * addr, int32_t * addr_len) {
    // 0x3050
    return recvfrom(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x3060 - 0x3066
int64_t function_3060(int64_t a1) {
    // 0x3060
    return g_strfreev();
}

// Address range: 0x3070 - 0x3076
int64_t function_3070(int64_t a1, char * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3070
    return g_string_append_printf();
}

// Address range: 0x3080 - 0x3086
int64_t function_3080(char * a1, int64_t a2, char * a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3080
    return g_log();
}

// Address range: 0x3090 - 0x3096
int64_t * function_3090(int64_t * ptr, int32_t size) {
    // 0x3090
    return realloc(ptr, size);
}

// Address range: 0x30a0 - 0x30a6
int16_t function_30a0(int16_t netshort) {
    // 0x30a0
    return ntohs(netshort);
}

// Address range: 0x30b0 - 0x30b6
int32_t function_30b0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x30b0
    return bind(fd, addr, len);
}

// Address range: 0x30c0 - 0x30c6
int32_t function_30c0(char * file, int32_t oflag, ...) {
    // 0x30c0
    return open64(file, oflag);
}

// Address range: 0x30d0 - 0x30d6
int64_t * function_30d0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x30d0
    return memmove(dest, src, n);
}

// Address range: 0x30e0 - 0x30e6
int64_t function_30e0(int64_t a1, int64_t a2) {
    // 0x30e0
    return g_malloc0_n();
}

// Address range: 0x30f0 - 0x30f6
int64_t function_30f0(int64_t a1, int64_t a2) {
    // 0x30f0
    return g_realloc();
}

// Address range: 0x3100 - 0x3106
int64_t function_3100(int64_t * a1) {
    // 0x3100
    return g_malloc0();
}

// Address range: 0x3110 - 0x3116
int32_t function_3110(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x3110
    return accept(fd, addr, addr_len);
}

// Address range: 0x3120 - 0x3126
int32_t function_3120(int32_t fd, struct sockaddr * addr, int32_t * len) {
    // 0x3120
    return getsockname(fd, addr, len);
}

// Address range: 0x3130 - 0x3136
int32_t function_3130(char * nptr) {
    // 0x3130
    return atoi(nptr);
}

// Address range: 0x3140 - 0x3146
int64_t function_3140(int64_t a1) {
    // 0x3140
    return g_strdup();
}

// Address range: 0x3150 - 0x3156
int64_t function_3150(char * a1) {
    // 0x3150
    return g_getenv();
}

// Address range: 0x3160 - 0x3166
int32_t function_3160(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x3160
    return connect(fd, addr, len);
}

// Address range: 0x3170 - 0x3176
int32_t function_3170(int32_t fd, int32_t offset, int32_t whence) {
    // 0x3170
    return lseek64(fd, offset, whence);
}

// Address range: 0x3180 - 0x3186
int32_t function_3180(int32_t netlong) {
    // 0x3180
    return ntohl(netlong);
}

// Address range: 0x3190 - 0x3196
char * function_3190(int32_t errnum) {
    // 0x3190
    return strerror(errnum);
}

// Address range: 0x31a0 - 0x31a6
char * function_31a0(char * haystack, char * needle) {
    // 0x31a0
    return strstr(haystack, needle);
}

// Address range: 0x31b0 - 0x31b6
int64_t function_31b0(int64_t a1) {
    // 0x31b0
    return g_error_free();
}

// Address range: 0x31c0 - 0x31c6
int32_t function_31c0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x31c0
    return socket(domain, type, protocol);
}

// Address range: 0x31d0 - 0x31d6
void function_31d0(int64_t * d) {
    // 0x31d0
    __cxa_finalize(d);
}

// Address range: 0x31e0 - 0x3212
int64_t entry_point(void) {
    // 0x31e0
    return &g49;
}

// Address range: 0x3220 - 0x3262
int64_t function_3220(void) {
    // 0x3220
    return 0;
}

// Address range: 0x3270 - 0x32aa
int64_t function_3270(void) {
    // 0x3270
    if (*(char *)&g49 != 0) {
        // 0x32a8
        int64_t result; // 0x3270
        return result;
    }
    // 0x3279
    if (*(int64_t *)0x222ff0 != 0) {
        // 0x3287
        __cxa_finalize((int64_t *)*(int64_t *)0x2232a0);
    }
    int64_t result2 = entry_point(); // 0x3293
    *(char *)&g49 = 1;
    return result2;
}

// Address range: 0x32b0 - 0x32ba
int64_t function_32b0(void) {
    // 0x32b0
    return function_3220();
}

// Address range: 0x32ba - 0x350e
int64_t function_32ba(int64_t a1, int64_t a2, int32_t * a3) {
    struct in_addr in; // 0x3334
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x32c6
    int64_t v2 = 0; // 0x3300
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x331f
        int64_t v3; // 0x32ba
        int64_t v4; // 0x32ba
        int64_t v5; // 0x32ba
        function_3080("Slirp", 128, "arp_table_add...", v5, v4, v3);
        v2 = 0;
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x3359



            in.s_addr = v1;
            function_3080("Slirp", 128, " ip = %s", (int64_t)inet_ntoa(in), v4, v3);
            v2 = 0;
            if (*(int32_t *)&g58 % 2 != 0) {
                int64_t v6 = (int64_t)a3; // 0x3397
                unsigned char v7 = *(char *)(v6 + 2); // 0x339f
                unsigned char v8 = *(char *)(v6 + 1); // 0x33ae
                uint64_t v9; // 0x32ba
                v2 = function_3080("Slirp", 128, " hw addr = %02x:%02x:%02x:%02x:%02x:%02x", v9 % 256, (int64_t)v8, (int64_t)v7);
            }
        }
    }
    int32_t v10 = v1; // 0x33ee
    int64_t dest_mem = v2; // 0x32ba
    switch (v10) {
        case 0: {
            return dest_mem;
        }
        case -1: {
            return dest_mem;
        }
        default: {
            int64_t v11 = a1 + (int64_t)&g3; // 0x32e8
            if ((*(int32_t *)(a1 + 12) | -1 - *(int32_t *)(a1 + 16)) == v10) {
                // 0x350c
                return v1 & 0xffffffff;
            }
            int32_t v12 = 0; // 0x3408
            int64_t v13 = 28 * (int64_t)v12 + v11; // 0x342f
            while (*(int32_t *)(v13 + 14) != v10) {
                // 0x3476
                v12++;
                if (v12 >= 16) {
                    int32_t * v14 = (int32_t *)(a1 + (int64_t)&g3 + 448); // 0x3480
                    int32_t v15 = *v14; // 0x3480
                    *(int32_t *)(a1 + (int64_t)&g3 + 14 + 28 * (int64_t)v15) = v10;
                    int32_t v16 = *v14; // 0x34a9
                    memcpy((int64_t *)(a1 + (int64_t)&g3 + 8 + 28 * (int64_t)v16), (int64_t *)a3, 6);
                    *v14 = (*v14 + 1) % 16;
                    dest_mem = v11;
                    return dest_mem;
                }
                v13 = 28 * (int64_t)v12 + v11;
            }
            // 0x343a
            dest_mem = (int64_t)memcpy((int64_t *)(v13 + 8), (int64_t *)a3, 6);
          lab_0x350c:
            // 0x350c
            return dest_mem;
        }
    }
}

// Address range: 0x350e - 0x36f2
int64_t function_350e(int64_t a1, int64_t a2, int64_t a3) {
    struct in_addr in; // 0x3588
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x351a
    int32_t v2 = *(int32_t *)(a1 + 12); // 0x3530
    int32_t v3; // 0x350e
    if (*(int32_t *)&g58 % 2 == 0) {
        // 0x3573
        v3 = v1;
        goto lab_0x35ad;
    } else {
        // 0x3573
        int64_t v4; // 0x350e
        int64_t v5; // 0x350e
        int64_t v6; // 0x350e
        function_3080("Slirp", 128, "arp_table_search...", v6, v5, v4);
        if (*(int32_t *)&g58 % 2 == 0) {
            // 0x3573
            v3 = v1;
            goto lab_0x35ad;
        } else {
            int32_t v7 = v1;



            in.s_addr = v7;
            function_3080("Slirp", 128, " ip = %s", (int64_t)inet_ntoa(in), v5, v4);
            v3 = v7;
            goto lab_0x35ad;
        }
    }
  lab_0x35ad:;
    int32_t v8 = v3;
    int32_t v9 = 0; // 0x35b1
    if (v8 != -1 != (v2 || -1 - *(int32_t *)(a1 + 16)) != v8) {
        // 0x35bb
        memset((int64_t *)a3, 255, 6);
        // 0x36f0
        return 1;
    }
    int64_t v10 = a1 + (int64_t)&g3 + 28 * (int64_t)v9; // 0x35ff
    while (*(int32_t *)(v10 + 14) != v8) {
        int32_t v11 = v9 + 1; // 0x36dd
        v9 = v11;
        if (v11 >= 16) {
            // 0x36f0
            return 0;
        }
        v10 = a1 + (int64_t)&g3 + 28 * (int64_t)v9;
    }
    // 0x360e
    memcpy((int64_t *)a3, (int64_t *)(v10 + 8), 6);
    if (*(int32_t *)&g58 % 2 != 0) {
        unsigned char v12 = *(char *)(a3 + 2); // 0x3687
        unsigned char v13 = *(char *)(a3 + 1); // 0x3696
        uint64_t v14; // 0x350e
        function_3080("Slirp", 128, " found hw addr = %02x:%02x:%02x:%02x:%02x:%02x", v14 % 256, (int64_t)v13, (int64_t)v12);
    }
    // 0x36f0
    return 1;
}

// Address range: 0x36f2 - 0x37bc
int64_t function_36f2(int64_t a1, int32_t * a2, int32_t * str) {
    int32_t host_long = 0;
    int64_t v1 = a1 + 272 + 8 * (int64_t)host_long; // 0x3725
    int64_t result = v1 + 10; // 0x3728
    int16_t * v2 = (int16_t *)result;
    while (*v2 != 0) {
        // 0x373c
        if (memcmp((int64_t *)str, (int64_t *)(v1 + 12), 6) == 0) {
            // break -> 0x376d
            break;
        }
        int32_t v3 = host_long + 1; // 0x375c
        if (v3 >= 16) {
            // 0x37b5
            return 0;
        }
        host_long = v3;
        v1 = a1 + 272 + 8 * (int64_t)host_long;
        result = v1 + 10;
        v2 = (int16_t *)result;
    }
    // 0x376d
    *v2 = 1;
    *a2 = htonl(host_long) + *(int32_t *)(a1 + 60);
    // 0x37b5
    return result;
}

// Address range: 0x37bc - 0x3869
int64_t function_37bc(int64_t a1, int64_t * a2, int32_t * str) {
    // 0x37bc
    int64_t net_long; // 0x37bc
    uint32_t v1 = ntohl((int32_t)net_long); // 0x37d8
    uint32_t v2 = ntohl(*(int32_t *)(a1 + 60)); // 0x37e9
    if (v1 < v2 || v1 >= v2 + 16) {
        // 0x3867
        return 0;
    }
    int64_t v3 = a1 + 272 + 8 * (int64_t)(v1 - v2); // 0x381c
    int64_t result = v3 + 10; // 0x381f
    int16_t * v4 = (int16_t *)result; // 0x3823
    if (*v4 != 0) {
        // 0x3833
        if (memcmp((int64_t *)str, (int64_t *)(v3 + 12), 6) != 0) {
            // 0x3867
            return 0;
        }
    }
    // 0x3853
    *v4 = 1;
    // 0x3867
    return result;
}

// Address range: 0x3869 - 0x391b
int64_t function_3869(int64_t a1, int32_t * a2, int64_t str) {
    int64_t host_long = 0;
    int64_t v1 = a1 + 272 + 8 * host_long; // 0x389c
    while (memcmp((int64_t *)str, (int64_t *)(v1 + 12), 6) != 0) {
        int64_t v2 = host_long + 1;
        if (v2 >= 16) {
            // 0x3914
            return 0;
        }
        host_long = v2;
        v1 = a1 + 272 + 8 * host_long;
    }
    int64_t result = v1 + 10; // 0x38e5
    *(int16_t *)result = 1;
    *a2 = htonl((int32_t)host_long) + *(int32_t *)(a1 + 60);
    // 0x3914
    return result;
}

// Address range: 0x391b - 0x3ad6
int64_t function_391b(int64_t a1, int64_t * a2, int64_t * a3) {
    // 0x391b
    *(int32_t *)a2 = 0;
    *(int32_t *)a3 = htonl(0);
    int32_t memcmp_rc = memcmp((int64_t *)(a1 + 264), &g12, 4); // 0x397b
    if (memcmp_rc != 0) {
        // 0x3acf
        return memcmp_rc;
    }
    uint64_t v1 = a1 + 576; // 0x395e
    int64_t v2 = a1 + 268; // 0x3988
    if (v1 > v2) {
        unsigned char v3 = *(char *)v2; // 0x3996
        int64_t v4; // 0x391b
        int64_t v5; // 0x391b
        uint64_t v6; // 0x39bc
        int64_t v7; // 0x39d3
        unsigned char v8; // 0x39db
        int64_t v9; // 0x39e7
        int64_t v10; // 0x39ee
        if (v3 != 0) {
            if (v3 == -1) {
                // break -> 0x3a92
                return 0;
            }
            // 0x39bc
            v6 = v2 + 1;
            if (v6 >= v1) {
                // break -> 0x3a92
                return 0;
            }
            // 0x39cf
            v7 = v2 + 2;
            v8 = *(char *)v6;
            v9 = v8;
            v10 = v7 + v9;
            if (v1 < v10) {
                // break -> 0x3a92
                return 0;
            }
            // 0x39fb
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x3a0b
                function_3080("Slirp", 128, "dhcp: tag=%d len=%d\n...", (int64_t)v3, v9, v5);
            }
            if (v3 == 50) {
                // 0x3a5a
                v4 = v10;
                if (v8 >= 4) {
                    // 0x3a60
                    *(int32_t *)a3 = *(int32_t *)v7;
                    v4 = v10;
                }
            } else {
                // 0x3a3b
                v4 = v10;
                if (v3 == 53 && v8 != 0) {
                    // 0x3a48
                    *(int32_t *)a2 = (int32_t)*(char *)v7;
                    v4 = v10;
                }
            }
        } else {
            // 0x39a5
            v4 = v2 + 1;
        }
        int64_t v11 = v4;
        while (v1 > v11) {
            int64_t v12 = v11;
            v3 = *(char *)v12;
            if (v3 != 0) {
                if (v3 == -1) {
                    // break -> 0x3a92
                    break;
                }
                // 0x39bc
                v6 = v12 + 1;
                if (v6 >= v1) {
                    // break -> 0x3a92
                    break;
                }
                // 0x39cf
                v7 = v12 + 2;
                v8 = *(char *)v6;
                v9 = v8;
                v10 = v7 + v9;
                if (v1 < v10) {
                    // break -> 0x3a92
                    break;
                }
                // 0x39fb
                if (*(int32_t *)&g58 % 2 != 0) {
                    // 0x3a0b
                    function_3080("Slirp", 128, "dhcp: tag=%d len=%d\n...", (int64_t)v3, v9, v5);
                }
                if (v3 == 50) {
                    // 0x3a5a
                    v4 = v10;
                    if (v8 >= 4) {
                        // 0x3a60
                        *(int32_t *)a3 = *(int32_t *)v7;
                        v4 = v10;
                    }
                } else {
                    // 0x3a3b
                    v4 = v10;
                    if (v3 == 53 && v8 != 0) {
                        // 0x3a48
                        *(int32_t *)a2 = (int32_t)*(char *)v7;
                        v4 = v10;
                    }
                }
            } else {
                // 0x39a5
                v4 = v12 + 1;
            }
            // 0x3a7b
            v11 = v4;
        }
    }
    // 0x3a92
    int64_t v13; // 0x391b
    if ((int32_t)v13 != 3) {
        // 0x3acf
        return v13 & 0xffffffff;
    }
    int32_t result = htonl(0); // 0x3aa8
    int64_t v14; // 0x391b
    if (result != (int32_t)v14) {
        // 0x3acf
        return result;
    }
    int32_t v15 = *(int32_t *)(a1 + 40); // 0x3ab5
    int64_t result2 = 0; // 0x3aba
    if (v15 != 0) {
        // 0x3abc
        *(int32_t *)a3 = v15;
        result2 = (int64_t)a3;
    }
    // 0x3acf
    return result2;
}

// Address range: 0x3ad6 - 0x4485
int64_t function_3ad6(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x3af0
    int32_t v2; // bp-120, 0x3ad6
    int32_t net_long; // bp-124, 0x3ad6
    function_391b(a2, (int64_t *)&v2, (int64_t *)&net_long);
    int64_t v3 = &v2; // 0x3b2f
    int64_t v4; // 0x3ad6
    int64_t v5; // 0x3ad6
    if (*(int32_t *)&g58 % 2 != 0) {
        int64_t v6 = v2; // 0x3b42
        v3 = (int64_t)*(char *)(a2 + 28);
        function_3080("Slirp", 128, "bootp packet op=%d msgtype=%d...", v3, v6, v5);
        v4 = v6;
    }
    int32_t v7 = htonl(0); // 0x3b6c
    uint32_t v8 = *(int32_t *)&g58;
    if (net_long == v7) {
        if (v8 % 2 != 0) {
            // 0x3bc0
            function_3080("Slirp", 128, "\n...", v3, v4, v5);
        }
    } else {
        if (v8 % 2 != 0) {
            // 0x3b85
            function_3080("Slirp", 128, " req_addr=%08x\n...", (int64_t)ntohl(net_long), v4, v5);
        }
    }
    int32_t v9 = v2; // 0x3bdd
    if (v9 != 0) {
        if (v9 != 1 == (v9 != 3)) {
            goto lab_0x4467;
        } else {
            goto lab_0x3bff;
        }
    } else {
        // 0x3beb
        v2 = 3;
        goto lab_0x3bff;
    }
  lab_0x4467:;
    int64_t result = 0; // 0x4474
    if (v1 != __readfsqword(40)) {
        // 0x4476
        __stack_chk_fail();
        result = &g91;
    }
    // 0x447b
    return result;
  lab_0x3bff:;
    int64_t v10 = a2 + 56; // 0x3c06
    int32_t v11 = *(int32_t *)v10; // bp-38, 0x3c0c
    int16_t v12 = *(int16_t *)(a2 + 60); // 0x3c0f
    int64_t v13 = function_a39a(a1); // 0x3c21
    int64_t v14; // 0x3ad6
    int64_t v15; // 0x3ad6
    int32_t net_long2; // bp-52, 0x3ad6
    int64_t v16; // 0x3c39
    int64_t v17; // 0x3c3d
    int64_t v18; // 0x3c5d
    if (v13 == 0) {
        goto lab_0x4467;
    } else {
        int64_t * v19 = (int64_t *)(v13 + 48); // 0x3c39
        v16 = *v19;
        v17 = v16 + 16;
        v18 = v16 + 44;
        *v19 = v18;
        memset((int64_t *)v17, 0, (int32_t)&g63);
        int32_t v20 = htonl(0);
        if (v2 != 1) {
            if (net_long == v20) {
                int64_t v21 = function_3869(a1, &net_long2, v10); // 0x3dc7
                v15 = v21;
                if (v21 == 0) {
                    goto lab_0x3cd2;
                } else {
                    goto lab_0x3ddb;
                }
            } else {
                int64_t v22 = function_37bc(a1, (int64_t *)&net_long, &v11); // 0x3d71
                if (v22 == 0) {
                    // 0x3d9e
                    net_long2 = -1;
                    v15 = 0;
                } else {
                    // 0x3d81
                    net_long2 = net_long;
                    *(int32_t *)(v22 + 2) = v11;
                    *(int16_t *)(v22 + 6) = v12;
                    v15 = v22;
                }
                goto lab_0x3ddb;
            }
        } else {
            if (net_long == v20) {
                goto lab_0x3cd2;
            } else {
                int64_t v23 = function_37bc(a1, (int64_t *)&net_long, &v11); // 0x3cb1
                if (v23 == 0) {
                    goto lab_0x3cd2;
                } else {
                    // 0x3cc7
                    net_long2 = net_long;
                    v14 = v23;
                    goto lab_0x3d31;
                }
            }
        }
    }
  lab_0x3cd2:;
    int64_t v24 = function_36f2(a1, &net_long2, &v11); // 0x3ceb
    v14 = v24;
    if (v24 != 0) {
        goto lab_0x3d31;
    } else {
        // 0x3cfb
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x3d0f
            function_3080("Slirp", 128, "no address left\n...", (int64_t)&net_long2, v4, v5);
        }
        goto lab_0x4467;
    }
  lab_0x3ddb:
    // 0x3ddb
    function_32ba(a1, (int64_t)net_long2, &v11);
    int32_t v25 = *(int32_t *)(a1 + 20); // 0x3dfa
    htons(67);
    htons(68);
    *(char *)v18 = 2;
    *(int32_t *)(v16 + 48) = *(int32_t *)(a2 + 32);
    *(char *)(v16 + 45) = 1;
    *(char *)(v16 + 46) = 6;
    memcpy((int64_t *)(v16 + 72), (int64_t *)v10, 6);
    *(int32_t *)(v16 + 60) = net_long2;
    *(int32_t *)(v16 + 64) = v25;
    int32_t v26 = (int32_t)v17 + (int32_t)&g63; // 0x3e94
    *(int32_t *)(v16 + 280) = 0x63538263;
    int64_t v27 = v16 + 284; // 0x3ea4
    uint32_t v28 = *(int32_t *)&g58;
    int64_t v29; // 0x3ad6
    if (v15 == 0) {
        if (v28 % 2 != 0) {
            // 0x436c
            function_3080("Slirp", 128, "nak'ed addr=%08x\n...", (int64_t)ntohl(net_long), v4, v5);
        }
        // 0x4395
        *(char *)v27 = 53;
        *(char *)(v16 + 285) = 1;
        *(char *)(v16 + 286) = 6;
        *(char *)(v16 + 287) = 56;
        *(char *)(v16 + 288) = 31;
        memcpy((int64_t *)(v16 + 289), (int64_t *)"requested address not available", 31);
        v29 = v16 + 320;
    } else {
        int64_t v30 = v10; // 0x3ec2
        int64_t v31 = v4; // 0x3ec2
        if (v28 % 2 != 0) {
            // 0x3ec4
            v31 = ntohl(net_long2);
            v30 = v2 != 1 ? (int64_t)"ack'ed" : (int64_t)"offered";
            function_3080("Slirp", 128, "%s addr=%08x\n...", v30, v31, v5);
        }
        // 0x3f0b
        *(char *)v27 = 53;
        *(char *)(v16 + 285) = 1;
        *(char *)(v16 + 286) = v2 != 1 ? 5 : 2;
        int64_t v32 = *(int64_t *)(a1 + 416); // 0x3f76
        int64_t v33 = v30; // 0x3f80
        if (v32 != 0) {
            // 0x3f82
            snprintf((char *)(v16 + 152), 128, "%s", (char *)v32);
            v33 = v32;
        }
        // 0x3fb4
        *(char *)(v16 + 287) = 54;
        *(char *)(v16 + 288) = 4;
        *(int32_t *)(v16 + 289) = v25;
        *(char *)(v16 + 293) = 1;
        *(char *)(v16 + 294) = 4;
        *(int32_t *)(v16 + 295) = *(int32_t *)(a1 + 16);
        int64_t v34 = v16 + 299; // 0x4011
        int64_t v35 = v34; // 0x4022
        if (*(int32_t *)(a1 + 124) == 0) {
            // 0x4024
            *(char *)v34 = 3;
            *(char *)(v16 + 300) = 4;
            *(int32_t *)(v16 + 301) = v25;
            *(char *)(v16 + 305) = 6;
            *(char *)(v16 + 306) = 4;
            *(int32_t *)(v16 + 307) = *(int32_t *)(a1 + 64);
            v35 = v16 + 311;
        }
        // 0x4086
        *(char *)v35 = 51;
        *(char *)(v35 + 1) = 4;
        *(int32_t *)(v35 + 2) = htonl(0x15180);
        int64_t v36 = v35 + 6; // 0x40ba
        int64_t v37 = a1 + 88; // 0x40c6
        char * str = (char *)v37; // 0x40c6
        int64_t v38 = v36; // 0x40cc
        int64_t v39 = v33; // 0x40cc
        if (*str != 0) {
            int32_t len = strlen(str); // 0x40e0
            int64_t v40 = v35 + 8;
            int64_t v41 = v40 + (int64_t)len;
            if (v41 < (int64_t)v26) {
                // 0x411d
                *(char *)v36 = 12;
                *(char *)(v35 + 7) = (char)len;
                memcpy((int64_t *)v40, (int64_t *)v37, len);
                v38 = v41;
                v39 = v37;
            } else {
                // 0x40fe
                function_3080("Slirp", 16, "DHCP packet size exceeded, omitting host name option.", v33, v31, v5);
                v38 = v36;
                v39 = v33;
            }
        }
        int64_t * v42 = (int64_t *)(a1 + 440); // 0x416f
        int64_t str2 = *v42; // 0x416f
        int64_t v43 = v38; // 0x4179
        int64_t v44 = v39; // 0x4179
        if (str2 != 0) {
            int32_t len2 = strlen((char *)str2); // 0x4190
            int64_t v45 = v38 + 2;
            int64_t v46 = v45 + (int64_t)len2;
            if (v46 < (int64_t)v26) {
                // 0x41cd
                *(char *)v38 = 15;
                *(char *)(v38 + 1) = (char)len2;
                int64_t v47 = *v42; // 0x41fc
                memcpy((int64_t *)v45, (int64_t *)v47, len2);
                v43 = v46;
                v44 = v47;
            } else {
                // 0x41ae
                function_3080("Slirp", 16, "DHCP packet size exceeded, omitting domain name option.", v39, v31, v5);
                v43 = v38;
                v44 = v39;
            }
        }
        int64_t * v48 = (int64_t *)(a1 + (int64_t)&g2); // 0x4222
        int64_t str3 = *v48; // 0x4222
        int64_t v49 = v43; // 0x422c
        int64_t v50 = v44; // 0x422c
        if (str3 != 0) {
            int32_t len3 = strlen((char *)str3); // 0x4243
            int64_t v51 = v43 + 2;
            int64_t v52 = v51 + (int64_t)len3;
            if (v52 < (int64_t)v26) {
                // 0x4280
                *(char *)v43 = 66;
                *(char *)(v43 + 1) = (char)len3;
                int64_t v53 = *v48; // 0x42af
                memcpy((int64_t *)v51, (int64_t *)v53, len3);
                v49 = v52;
                v50 = v53;
            } else {
                // 0x4261
                function_3080("Slirp", 16, "DHCP packet size exceeded, omitting tftp-server-name option.", v44, v31, v5);
                v49 = v43;
                v50 = v44;
            }
        }
        int64_t v54 = *(int64_t *)(a1 + 432); // 0x42d5
        v29 = v49;
        if (v54 != 0) {
            int64_t v55 = *(int64_t *)(a1 + 424); // 0x42ec
            int64_t v56 = 0x100000000 * v55 / 0x100000000 + v49; // 0x4300
            if (v56 < (int64_t)v26) {
                // 0x432b
                memcpy((int64_t *)v49, (int64_t *)v54, (int32_t)v55);
                v29 = v56;
            } else {
                // 0x4309
                function_3080("Slirp", 16, "DHCP packet size exceeded, omitting domain-search option.", v50, v31, v5);
                v29 = v49;
            }
        }
    }
    // 0x43fd
    if (v29 >= (int64_t)v26) {
        // 0x4407
        __assert_fail("q < end", "../src/bootp.c", 352, "bootp_reply");
    }
    // 0x4426
    *(char *)v29 = -1;
    net_long2 = -1;
    *(int32_t *)(v13 + 56) = (int32_t)&g48;
    int64_t v57; // bp-56, 0x3ad6
    int64_t v58; // bp-72, 0x3ad6
    function_1b11d(0, v13, &v58, &v57, 16);
    goto lab_0x4467;
  lab_0x3d31:
    // 0x3d31
    *(int32_t *)(v14 + 2) = v11;
    *(int16_t *)(v14 + 6) = v12;
    v15 = v14;
    goto lab_0x3ddb;
}

// Address range: 0x4485 - 0x44c3
int64_t function_4485(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 48); // 0x4495
    unsigned char v2 = *(char *)(v1 + 28); // 0x44a1
    int64_t result = v2; // 0x44a7
    if (v2 == 1) {
        // 0x44a9
        result = function_3ad6(*(int64_t *)(a1 + 64), v1);
    }
    // 0x44c0
    return result;
}

// Address range: 0x44c3 - 0x4820
int64_t function_44c3(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x44d4
    int64_t v2 = __readfsqword(40); // 0x44d7
    uint32_t v3 = *(int32_t *)(a1 + 56); // 0x44fc
    int64_t v4 = 0; // 0x4501
    int64_t v5 = v1; // 0x4501
    int64_t v6 = 0; // 0x4501
    int32_t v7; // 0x44c3
    uint16_t v8; // 0x44c3
    if (v3 != 0) {
        uint64_t v9 = *(int64_t *)(a1 + 48); // 0x450b
        int64_t v10 = v3; // 0x4513
        int64_t v11 = v1 < v10 ? v1 & 0xffffffff : v10;
        int32_t v12 = 0; // 0x452e
        int64_t v13 = 0; // 0x452e
        int64_t v14 = v9; // 0x452e
        int64_t v15 = v11; // 0x452e
        int32_t v16; // 0x44c3
        if ((int32_t)v11 >= 1 && v9 % 2 != 0) {
            // 0x453d
            v12 = 1;
            v16 = (int32_t)*(char *)v9;
            v13 = 256 * (int64_t)v8;
            v14 = v9 + 1;
            v15 = v11 + 0xffffffff & 0xffffffff;
        }
        int64_t v17 = v15 + 0xffffffe0; // 0x4651
        int64_t v18 = v13; // 0x4658
        int64_t v19 = v14; // 0x4658
        int64_t v20 = v15; // 0x4658
        if ((int32_t)v17 >= 0) {
            int64_t v21 = v17 & 0xffffffff; // 0x4651
            uint16_t v22 = *(int16_t *)v14; // 0x4580
            uint16_t v23 = *(int16_t *)(v14 + 2); // 0x458f
            uint16_t v24 = *(int16_t *)(v14 + 4); // 0x459c
            uint16_t v25 = *(int16_t *)(v14 + 6); // 0x45a9
            uint16_t v26 = *(int16_t *)(v14 + 8); // 0x45b6
            uint16_t v27 = *(int16_t *)(v14 + 10); // 0x45c3
            uint16_t v28 = *(int16_t *)(v14 + 12); // 0x45d0
            uint16_t v29 = *(int16_t *)(v14 + 14); // 0x45dd
            uint16_t v30 = *(int16_t *)(v14 + 16); // 0x45ea
            uint16_t v31 = *(int16_t *)(v14 + 18); // 0x45f7
            uint16_t v32 = *(int16_t *)(v14 + 20); // 0x4604
            uint16_t v33 = *(int16_t *)(v14 + 22); // 0x4611
            uint16_t v34 = *(int16_t *)(v14 + 24); // 0x461e
            uint16_t v35 = *(int16_t *)(v14 + 26); // 0x462b
            uint16_t v36 = *(int16_t *)(v14 + 28); // 0x4638
            uint16_t v37 = *(int16_t *)(v14 + 30); // 0x4645
            int64_t v38 = v13 + (int64_t)v22 + (int64_t)v23 + (int64_t)v24 + (int64_t)v25 + (int64_t)v26 + (int64_t)v27 + (int64_t)v28 + (int64_t)v29 + (int64_t)v30 + (int64_t)v31 + (int64_t)v32 + (int64_t)v33 + (int64_t)v34 + (int64_t)v35 + (int64_t)v36 + (int64_t)v37 & 0xffffffff; // 0x464b
            int64_t v39 = v14 + 32; // 0x464d
            int64_t v40 = v21 + 0xffffffe0; // 0x4651
            int64_t v41 = v39; // 0x4658
            int64_t v42 = v38; // 0x4658
            v18 = v38;
            v19 = v39;
            v20 = v21;
            while ((int32_t)v40 >= 0) {
                // 0x4580
                v21 = v40 & 0xffffffff;
                v22 = *(int16_t *)v41;
                v23 = *(int16_t *)(v41 + 2);
                v24 = *(int16_t *)(v41 + 4);
                v25 = *(int16_t *)(v41 + 6);
                v26 = *(int16_t *)(v41 + 8);
                v27 = *(int16_t *)(v41 + 10);
                v28 = *(int16_t *)(v41 + 12);
                v29 = *(int16_t *)(v41 + 14);
                v30 = *(int16_t *)(v41 + 16);
                v31 = *(int16_t *)(v41 + 18);
                v32 = *(int16_t *)(v41 + 20);
                v33 = *(int16_t *)(v41 + 22);
                v34 = *(int16_t *)(v41 + 24);
                v35 = *(int16_t *)(v41 + 26);
                v36 = *(int16_t *)(v41 + 28);
                v37 = *(int16_t *)(v41 + 30);
                v38 = v42 + (int64_t)v22 + (int64_t)v23 + (int64_t)v24 + (int64_t)v25 + (int64_t)v26 + (int64_t)v27 + (int64_t)v28 + (int64_t)v29 + (int64_t)v30 + (int64_t)v31 + (int64_t)v32 + (int64_t)v33 + (int64_t)v34 + (int64_t)v35 + (int64_t)v36 + (int64_t)v37 & 0xffffffff;
                v39 = v41 + 32;
                v40 = v21 + 0xffffffe0;
                v41 = v39;
                v42 = v38;
                v18 = v38;
                v19 = v39;
                v20 = v21;
            }
        }
        int64_t v43 = (v20 & 0xffffffff) + 0xfffffff8; // 0x4699
        int64_t v44 = v43 & 0xffffffff; // 0x4699
        int64_t v45 = v18; // 0x46a0
        int64_t v46 = v19; // 0x46a0
        int64_t v47 = v44; // 0x46a0
        if ((int32_t)v43 >= 0) {
            uint16_t v48 = *(int16_t *)v19; // 0x4664
            uint16_t v49 = *(int16_t *)(v19 + 2); // 0x4673
            uint16_t v50 = *(int16_t *)(v19 + 4); // 0x4680
            uint16_t v51 = *(int16_t *)(v19 + 6); // 0x468d
            int64_t v52 = v18 + (int64_t)v48 + (int64_t)v49 + (int64_t)v50 + (int64_t)v51 & 0xffffffff; // 0x4693
            int64_t v53 = v19 + 8; // 0x4695
            int64_t v54 = v44 + 0xfffffff8; // 0x4699
            int64_t v55 = v54 & 0xffffffff; // 0x4699
            int64_t v56 = v53; // 0x46a0
            int64_t v57 = v52; // 0x46a0
            v45 = v52;
            v46 = v53;
            v47 = v55;
            while ((int32_t)v54 >= 0) {
                // 0x4664
                v48 = *(int16_t *)v56;
                v49 = *(int16_t *)(v56 + 2);
                v50 = *(int16_t *)(v56 + 4);
                v51 = *(int16_t *)(v56 + 6);
                v52 = v57 + (int64_t)v48 + (int64_t)v49 + (int64_t)v50 + (int64_t)v51 & 0xffffffff;
                v53 = v56 + 8;
                v54 = v55 + 0xfffffff8;
                v55 = v54 & 0xffffffff;
                v56 = v53;
                v57 = v52;
                v45 = v52;
                v46 = v53;
                v47 = v55;
            }
        }
        int64_t v58 = 0x100000000 * (v1 - v11) / 0x100000000; // 0x4521
        int64_t v59 = v47 + 8; // 0x46a2
        int64_t v60 = v59 & 0xffffffff; // 0x46a2
        v7 = v16;
        v4 = v45;
        v5 = v58;
        v6 = v60;
        if ((v12 || (int32_t)v59) != 0) {
            int64_t v61 = v8; // 0x46c5
            int64_t v62 = v45 % 0x10000 + v61; // 0x46c8
            int64_t v63 = (int32_t)v62 < 0x10000 ? v62 : v62 + 0xffff0001 & 0xffffffff;
            int64_t v64 = v60 + 0xfffffffe; // 0x46ea
            int64_t v65 = v64 & 0xffffffff; // 0x46ea
            int32_t v66 = v64; // 0x46ee
            int64_t v67 = v63; // 0x46f1
            int64_t v68 = v46; // 0x46f1
            int64_t v69 = v65; // 0x46f1
            int32_t v70 = v66; // 0x46f1
            if (v66 >= 0) {
                int64_t v71 = v46 + 2; // 0x46de
                int64_t v72 = v63 + (int64_t)*(int16_t *)v46 & 0xffffffff; // 0x46e8
                int64_t v73 = v65 + 0xfffffffe; // 0x46ea
                int64_t v74 = v73 & 0xffffffff; // 0x46ea
                int32_t v75 = v73;
                int64_t v76 = v71; // 0x46f1
                int64_t v77 = v72; // 0x46f1
                v67 = v72;
                v68 = v71;
                v69 = v74;
                v70 = v75;
                while (v75 >= 0) {
                    // 0x46db
                    v71 = v76 + 2;
                    v72 = v77 + (int64_t)*(int16_t *)v76 & 0xffffffff;
                    v73 = v74 + 0xfffffffe;
                    v74 = v73 & 0xffffffff;
                    v75 = v73;
                    v76 = v71;
                    v77 = v72;
                    v67 = v72;
                    v68 = v71;
                    v69 = v74;
                    v70 = v75;
                }
            }
            // 0x46f3
            if (v12 == 0) {
                // 0x4747
                v7 = v16;
                v4 = v67;
                v5 = v58;
                v6 = v69;
                if (v70 == -1) {
                    // 0x474d
                    v7 = (int32_t)*(char *)v68;
                    v4 = v67;
                    v5 = v58;
                    v6 = v69;
                }
            } else {
                int64_t v78 = v67 % 0x10000 + v61; // 0x470c
                int64_t v79 = 256 * ((int32_t)v78 < 0x10000 ? v78 : v78 + 0xffff0001 & 0xffffffff); // 0x471d
                if (v70 != -1) {
                    // 0x473f
                    v7 = v16;
                    v4 = v79 & 0xffffff00;
                    v5 = v58;
                    v6 = 0xffffffff;
                } else {
                    // 0x4726
                    v7 = v16;
                    v4 = v79 + (int64_t)(256 * (int16_t)v16 / 256) & 0xffffffff;
                    v5 = v58;
                    v6 = 0;
                }
            }
        }
    }
    // 0x475e
    if ((int32_t)v5 != 0) {
        // 0x4764
        if ((*(int32_t *)&g58 & 4) != 0) {
            // 0x4791
            int64_t v80; // 0x44c3
            int64_t v81; // 0x44c3
            int64_t v82; // 0x44c3
            function_3080("Slirp", 128, "cksum: out of data", v82, v81, v80);
            if ((*(int32_t *)&g58 & 4) != 0) {
                // 0x47a1
                function_3080("Slirp", 128, " len = %d", v5 & 0xffffffff, v81, v80);
            }
        }
    }
    int64_t v83 = v4; // 0x47c7
    if (v6 == 0xffffffff) {
        // 0x47c9
        v83 = v4 + (int64_t)(256 * (int16_t)v7 / 256) & 0xffffffff;
    }
    int64_t v84 = v83 % 0x10000 + (int64_t)v8; // 0x47e9
    int64_t result = (v84 + (int64_t)((int32_t)v84 > 0xffff)) % 0x10000 ^ 0xffff; // 0x480e
    if (v2 != __readfsqword(40)) {
        // 0x4810
        __stack_chk_fail();
        result = &g91;
    }
    // 0x4815
    return result;
}

// Address range: 0x4820 - 0x494b
int64_t function_4820(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x482c
    int64_t v2 = *(int64_t *)(a1 + 48); // 0x483f
    int64_t * v3 = (int64_t *)v2; // 0x4857
    int64_t * v4 = (int64_t *)(v2 + 8); // 0x485a
    int64_t v5 = *v4; // 0x485a
    int64_t * v6 = (int64_t *)(v2 + 16); // 0x4866
    int64_t v7 = *v6; // 0x4866
    int64_t * v8 = (int64_t *)(v2 + 24); // 0x486a
    int64_t v9 = *v8; // 0x486a
    int64_t v10 = v2 + 32; // 0x4876
    int64_t * v11 = (int64_t *)v10; // 0x4876
    int64_t v12 = *v11; // 0x4876
    *v3 = v5;
    *v4 = v7;
    *v6 = v9;
    *v8 = v12;
    int16_t net_short; // 0x4820
    int32_t v13 = htonl((int32_t)ntohs(net_short)); // 0x48b8
    int32_t * net_long = (int32_t *)v10; // 0x48c3
    *net_long = v13;
    *(int16_t *)(v2 + 36) = 0;
    *(char *)(v2 + 38) = 0;
    int64_t v14 = function_44c3(a1, (int64_t)(ntohl(*net_long) + 40)); // 0x48ff
    *v4 = v5;
    *v6 = v7;
    *v8 = v9;
    *v11 = v12;
    int64_t result = v14 & 0xffffffff; // 0x4942
    if (v1 != __readfsqword(40)) {
        // 0x4944
        __stack_chk_fail();
        result = &g91;
    }
    // 0x4949
    return result;
}

// Address range: 0x494b - 0x4b5b
int64_t function_494b(int64_t a1, int64_t a2, uint32_t a3, int64_t * a4) {
    // 0x494b
    if (a3 <= 4) {
        // 0x4b59
        return 0;
    }
    int64_t v1 = (int64_t)a4;
    int32_t v2 = a3; // 0x4b47
    int64_t v3 = a2;
    unsigned char v4 = *(char *)(v3 + 1); // 0x497e
    uint32_t v5 = (int32_t)*(char *)(v3 + 3); // 0x49aa
    uint32_t v6 = 256 * (int32_t)*(char *)(v3 + 2) | v5; // 0x49aa
    uint32_t v7 = v6 + 4; // 0x49b2
    int64_t v8 = v7; // 0x49b2
    int64_t result = 0xfffffff9; // 0x49b8
    while ((int64_t)v2 >= v8) {
        // 0x49ea
        int64_t v9; // 0x494b
        int64_t v10 = v9;
        uint32_t v11 = 256 * (int32_t)*(char *)v3 | (int32_t)v4; // 0x4984
        int64_t v12; // 0x494b
        int64_t v13; // 0x494b
        switch ((int16_t)v11) {
            case 5: {
                // 0x4b59
                return 0xffffffea;
            }
            case 6: {
                // 0x4a3c
                if (v5 % 2 != 0) {
                    // break -> 0x4b59
                    break;
                }
                // 0x4aee
                v12 = v10;
                if (v6 != 0) {
                    int64_t v14 = 0;
                    int64_t v15 = v14 + 4;
                    unsigned char v16 = *(char *)(v15 + v3); // 0x4a6c
                    unsigned char v17 = *(char *)((v15 | 1) + v3); // 0x4a8a
                    uint32_t v18 = 256 * (int32_t)v16 | (int32_t)v17; // 0x4a90
                    switch ((int16_t)v18) {
                        case 23: {
                            // 0x4aa4
                            *(char *)(v1 + 12) = 1;
                            // break -> 0x4aea
                            break;
                        }
                        case 59: {
                            // 0x4aae
                            *(char *)(v1 + 13) = 1;
                            // break -> 0x4aea
                            break;
                        }
                        default: {
                            // 0x4ab8
                            if ((*(int32_t *)&g58 & 2) != 0) {
                                // 0x4ac8
                                function_3080("Slirp", 128, "dhcpv6: Unsupported option request %d", (int64_t)v18, v10, v13);
                            }
                            // break -> 0x4aea
                            break;
                        }
                    }
                    // 0x4aea
                    v14 += 2;
                    v12 = v10;
                    while (v14 < (int64_t)v6) {
                        // 0x4a5c
                        v15 = v14 + 4;
                        v16 = *(char *)(v15 + v3);
                        v17 = *(char *)((v15 | 1) + v3);
                        v18 = 256 * (int32_t)v16 | (int32_t)v17;
                        switch ((int16_t)v18) {
                            case 23: {
                                // 0x4aa4
                                *(char *)(v1 + 12) = 1;
                                // break -> 0x4aea
                                break;
                            }
                            case 59: {
                                // 0x4aae
                                *(char *)(v1 + 13) = 1;
                                // break -> 0x4aea
                                break;
                            }
                            default: {
                                // 0x4ab8
                                if ((*(int32_t *)&g58 & 2) != 0) {
                                    // 0x4ac8
                                    function_3080("Slirp", 128, "dhcpv6: Unsupported option request %d", (int64_t)v18, v10, v13);
                                }
                                // break -> 0x4aea
                                break;
                            }
                        }
                        // 0x4aea
                        v14 += 2;
                        v12 = v10;
                    }
                }
                // break -> 0x4b34
                break;
            }
            case 1: {
                // 0x4a0b
                if (v6 >= 257) {
                    // break -> 0x4b59
                    break;
                }
                // 0x4a1e
                *a4 = v3 + 4;
                *(int32_t *)(v1 + 8) = v6;
                v12 = v10;
                // break -> 0x4b34
                break;
            }
            default: {
                // 0x4afc
                v12 = v10;
                if ((*(int32_t *)&g58 & 2) != 0) {
                    int64_t v19 = v6; // 0x4b12
                    function_3080("Slirp", 128, "dhcpv6 info req: Unsupported option %d, len=%d", (int64_t)v11, v19, v13);
                    v12 = v19;
                }
                // break -> 0x4b34
                break;
            }
        }
        // 0x4b34
        v2 -= v7;
        v9 = v12;
        result = 0;
        if (v2 <= 4) {
            // break -> 0x4b59
            break;
        }
        v3 += v8;
        v4 = *(char *)(v3 + 1);
        v5 = (int32_t)*(char *)(v3 + 3);
        v6 = 256 * (int32_t)*(char *)(v3 + 2) | v5;
        v7 = v6 + 4;
        v8 = v7;
        result = 0xfffffff9;
    }
    // 0x4b59
    return result;
}

// Address range: 0x4b5b - 0x5152
int64_t function_4b5b(int64_t a1, int64_t a2, uint32_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = __readfsqword(40); // 0x4b91
    int64_t v2 = 0; // bp-152, 0x4ba0
    if ((int32_t)function_494b(a1, a4, (int32_t)a5, &v2) >= 0) {
        int64_t v3 = function_a39a(a1); // 0x4beb
        if (v3 != 0) {
            int64_t * v4 = (int64_t *)(v3 + 48); // 0x4c19
            memset((int64_t *)*v4, 0, *(int32_t *)(v3 + 36));
            int64_t v5 = *v4; // 0x4c31
            *v4 = v5 + 16;
            *(char *)(v5 + 64) = 7;
            *(char *)(v5 + 65) = (char)(a3 / 0x10000);
            *(char *)(v5 + 66) = (char)(a3 / 256);
            char * v6 = (char *)(v5 + 68); // 0x4cbc
            *(char *)(v5 + 67) = (char)a3;
            char * v7 = v6; // 0x4cd5
            if (v2 != 0) {
                // 0x4cdb
                *v6 = 0;
                *(char *)(v5 + 69) = 1;
                *(char *)(v5 + 70) = 0;
                int64_t v8 = v5 + 72; // 0x4d33
                *(char *)(v5 + 71) = 0;
                memcpy((int64_t *)v8, (int64_t *)v2, 0);
                v7 = (char *)v8;
            }
            char * v9 = v7; // 0x4d7c
            char v10; // 0x4b5b
            if (v10 != 0) {
                int64_t v11 = (int64_t)v7; // 0x4d7e
                *v7 = 0;
                *(char *)(v11 + 1) = 23;
                *(char *)(v11 + 2) = 0;
                *(char *)(v11 + 3) = 16;
                *(int64_t *)(v11 + 4) = *(int64_t *)(a1 + 68);
                *(int64_t *)(v11 + 12) = *(int64_t *)(a1 + 76);
                v9 = (char *)(v11 + 20);
            }
            char * v12 = v9; // 0x4e03
            char v13; // 0x4b5b
            if (v13 != 0) {
                int64_t v14 = (int64_t)v9; // 0x4e1b
                *v9 = 0;
                *(char *)(v14 + 1) = 59;
                int64_t str = v14 + 4; // 0x4e6c
                int32_t size = *(int32_t *)(a1 + 136) + (int32_t)(0xfffffffc - v14 + *v4); // 0x4e76
                int64_t v15 = *(int64_t *)(a1 + 416); // 0x4e83
                unsigned char v16 = *(char *)(a1 + 59); // 0x4e95
                unsigned char v17 = *(char *)(a1 + 58); // 0x4ea7
                unsigned char v18 = *(char *)(a1 + 57); // 0x4eb9
                unsigned char v19 = *(char *)(a1 + 56); // 0x4ecb
                unsigned char v20 = *(char *)(a1 + 55); // 0x4ee2
                unsigned char v21 = *(char *)(a1 + 54); // 0x4ef9
                unsigned char v22 = *(char *)(a1 + 53); // 0x4f10
                unsigned char v23 = *(char *)(a1 + 52); // 0x4f27
                unsigned char v24 = *(char *)(a1 + 51); // 0x4f3e
                unsigned char v25 = *(char *)(a1 + 50); // 0x4f50
                unsigned char v26 = *(char *)(a1 + 49); // 0x4f62
                unsigned char v27 = *(char *)(a1 + 48); // 0x4f74
                unsigned char v28 = *(char *)(a1 + 47); // 0x4f86
                unsigned char v29 = *(char *)(a1 + 46); // 0x4f97
                unsigned char v30 = *(char *)(a1 + 45); // 0x4fa9
                unsigned char v31 = *(char *)(a1 + 44); // 0x4fb6
                int32_t chars_printed = snprintf((char *)str, size, "tftp://[%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x]/%s", (int32_t)v31, (int32_t)v30, (int32_t)v29, (int32_t)v28, (int32_t)v27, (int32_t)v26, (int32_t)v25, (int32_t)v24, (int32_t)v23, (int32_t)v22, (int32_t)v21, (int32_t)v20, (int32_t)v19, (int32_t)v18, (int32_t)v17, (int32_t)v16, (char *)v15); // 0x501a
                int32_t v32 = size - chars_printed; // 0x502f
                int32_t v33 = v32 == 0 | v32 < 0 != ((v32 ^ size) & (chars_printed ^ size)) < 0 ? size : chars_printed; // 0x5035
                *(char *)(v14 + 2) = (char)(v33 / 256);
                *(char *)(v14 + 3) = (char)v33;
                v12 = (char *)(str + (int64_t)v33);
            }
            int64_t v34 = *v4 + 48; // 0x50da
            *v4 = v34;
            *(int32_t *)(v3 + 56) = (int32_t)((int64_t)v12 - v34);
            int64_t v35; // bp-104, 0x4b5b
            int64_t v36; // bp-136, 0x4b5b
            function_1bf57(0, v3, &v36, &v35);
        }
    }
    int64_t result = 0; // 0x513c
    if (v1 != __readfsqword(40)) {
        // 0x513e
        __stack_chk_fail();
        result = &g91;
    }
    // 0x5143
    return result;
}

// Address range: 0x5152 - 0x5215
int64_t function_5152(int16_t * a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a2 + 48); // 0x5166
    int32_t v2 = *(int32_t *)(a2 + 56); // 0x5176
    int32_t result = v2 - 8; // 0x5179
    if (result < 4) {
        // 0x5213
        return result;
    }
    int64_t net_long = v1 + 8; // 0x516a
    uint32_t v3 = ntohl(*(int32_t *)net_long); // 0x5191
    unsigned char v4 = *(char *)net_long; // 0x51a2
    int64_t result2; // 0x5152
    if (v4 == 11) {
        int64_t v5 = *(int64_t *)(a2 + 64); // 0x51bf
        result2 = function_4b5b(v5, (int64_t)a1, v3 % 0x1000000, v1 + 12, (int64_t)(v2 - 12));
        // 0x5213
        return result2;
    }
    // 0x51d7
    result2 = 0;
    if ((*(int32_t *)&g58 & 2) != 0) {
        // 0x51e7
        int64_t v6; // 0x5152
        int64_t v7; // 0x5152
        result2 = function_3080("Slirp", 128, "dhcpv6_input: Unsupported message type 0x%x", (int64_t)v4, v7, v6);
    }
    // 0x5213
    return result2;
}

// Address range: 0x5215 - 0x52ae
int64_t function_5215(int64_t a1, int64_t a2) {
    uint64_t v1 = *(int64_t *)(a1 + 24); // 0x5225
    uint64_t v2 = *(int64_t *)(a2 + 24); // 0x5231
    uint64_t v3 = v2 > v1 ? v1 : v2; // 0x5267
    if (v3 == 0) {
        // 0x52a8
        return 0;
    }
    int64_t result = 0; // 0x5296
    int64_t v4 = *(int64_t *)(a2 + 16) + v2; // 0x527f
    int64_t v5 = *(int64_t *)(a1 + 16) + v1; // 0x527a
    v5--;
    v4--;
    while (*(char *)v5 == *(char *)v4) {
        // 0x5296
        result++;
        if (result >= v3) {
            // break -> 0x52a8
            break;
        }
        v5--;
        v4--;
    }
    // 0x52a8
    return result;
}

// Address range: 0x52ae - 0x5378
int64_t function_52ae(int64_t a1, int64_t a2) {
    uint64_t v1 = *(int64_t *)(a1 + 24); // 0x52d2
    uint64_t v2 = *(int64_t *)(a2 + 24); // 0x52de
    int64_t v3 = function_5215(a1, a2); // 0x52f4
    unsigned char v4 = *(char *)(v1 - v3 + *(int64_t *)(a1 + 16)); // 0x5310
    unsigned char v5 = *(char *)(v2 - v3 + *(int64_t *)(a2 + 16)); // 0x5329
    if (v4 < v5) {
        // 0x5376
        return 0xffffffff;
    }
    // 0x533f
    if (v4 > v5) {
        // 0x5376
        return 1;
    }
    int64_t result = 0xffffffff; // 0x5357
    if (v1 >= v2) {
        // 0x5360
        result = v1 > v2;
    }
    // 0x5376
    return result;
}

// Address range: 0x5378 - 0x542e
int64_t function_5378(int64_t a1, int64_t a2) {
    int64_t v1 = function_5215(a1, a2); // 0x5396
    int64_t v2 = *(int64_t *)(a1 + 16);
    int64_t v3 = *(int64_t *)(a1 + 24); // 0x53ab
    uint64_t v4 = v2 - v1 + v3; // 0x53b3
    char v5 = *(char *)v2; // 0x53de
    int64_t v6 = v2; // 0x53e3
    uint64_t v7; // 0x5409
    if (v4 > v2 != v5 != 0) {
        // 0x53ef
        v7 = v3;
        return v7 < 3 ? 0 : v7;
    }
    v6 = v6 + 1 + (int64_t)v5;
    char v8 = *(char *)v6; // 0x53de
    while (v8 != 0 == v4 > v6) {
        // 0x53c8
        v6 = v6 + 1 + (int64_t)v8;
        v8 = *(char *)v6;
    }
    // 0x53ef
    v7 = v2 - v6 + v3;
    return v7 < 3 ? 0 : v7;
}

// Address range: 0x542e - 0x54e9
int64_t function_542e(int64_t a1, int64_t result) {
    // 0x542e
    if (result == 0) {
        // 0x54e6
        return result;
    }
    int64_t v1 = 0; // 0x54e0
    int64_t v2 = 40 * v1 + a1; // 0x5460
    int64_t * v3 = (int64_t *)(v2 + 32); // 0x54ca
    int64_t * v4; // 0x542e
    int64_t v5; // 0x542e
    int64_t v6; // 0x542e
    int64_t * v7; // 0x5490
    int64_t * v8; // 0x54ca
    if (*v3 == 0) {
        // 0x548c
        v6 = *(int64_t *)v2;
        v4 = v3;
        v7 = (int64_t *)v6;
        *v7 = v2;
        *v4 = *v4 + 1;
        v8 = (int64_t *)(v6 + 32);
        while (*v8 == 0) {
            // 0x548c
            v5 = v6;
            v6 = *v7;
            v4 = v8;
            v7 = (int64_t *)v6;
            *v7 = v5;
            *v4 = *v4 + 1;
            v8 = (int64_t *)(v6 + 32);
        }
    }
    // 0x54d3
    v1++;
    while (v1 != result) {
        // 0x5447
        v2 = 40 * v1 + a1;
        v3 = (int64_t *)(v2 + 32);
        if (*v3 == 0) {
            // 0x548c
            v6 = *(int64_t *)v2;
            v4 = v3;
            v7 = (int64_t *)v6;
            *v7 = v2;
            *v4 = *v4 + 1;
            v8 = (int64_t *)(v6 + 32);
            while (*v8 == 0) {
                // 0x548c
                v5 = v6;
                v6 = *v7;
                v4 = v8;
                v7 = (int64_t *)v6;
                *v7 = v5;
                *v4 = *v4 + 1;
                v8 = (int64_t *)(v6 + 32);
            }
        }
        // 0x54d3
        v1++;
    }
    // 0x54e6
    return result;
}

// Address range: 0x54e9 - 0x5613
int64_t function_54e9(int64_t result, int64_t a2) {
    int64_t * v1 = (int64_t *)(result + 24); // 0x5521
    int64_t v2 = *v1; // 0x5521
    int64_t v3; // 0x54e9
    int64_t v4; // 0x54e9
    if (v2 == 0) {
        // 0x55de
        function_3080("Slirp", 16, "failed to parse domain name '%s'\n", a2, v4, v3);
        *v1 = 0;
        // 0x5611
        return result;
    }
    int64_t v5 = *(int64_t *)(result + 16); // 0x54fd
    *v1 = v2 + 1;
    char * v6 = (char *)v5; // 0x553e
    int64_t v7 = v5; // 0x553e
    int64_t v8 = a2; // 0x553e
    int32_t v9 = 0; // 0x553e
    int64_t result2; // 0x54e9
    while (true) {
        int64_t v10 = v7;
        char * v11 = v6;
        char v12 = *(char *)v8; // 0x554e
        int32_t v13; // 0x54e9
        int64_t v14; // 0x54e9
        char * v15; // 0x54e9
        if (v12 != 46 == (v12 != 0)) {
            int64_t v16 = v10 + 1; // 0x55a1
            *(char *)v16 = v12;
            v15 = v11;
            v14 = v16;
            v13 = v9;
        } else {
            int64_t v17 = v10 - (int64_t)v11; // 0x5568
            int32_t v18 = v17; // 0x556e
            if (v18 < 64 != (v17 != 0 || v12 != 46)) {
                // break -> 0x55de
                break;
            }
            // 0x5586
            *v11 = (char)v17;
            int64_t v19 = v10 + 1; // 0x5592
            v15 = (char *)v19;
            v14 = v19;
            v13 = v18;
        }
        int32_t v20 = v13;
        v7 = v14;
        v6 = v15;
        v8++;
        v9 = v20;
        if (v12 == 0) {
            // 0x55b6
            result2 = v7;
            if (v20 == 0) {
                return result2;
            } else {
                // 0x55bd
                *v6 = 0;
                *v1 = *v1 + 1;
                result2 = result;
                return result2;
            }
        }
    }
    // 0x55de
    function_3080("Slirp", 16, "failed to parse domain name '%s'\n", a2, v4, v3);
    *v1 = 0;
    result2 = result;
  lab_0x5611:
    // 0x5611
    return result2;
}

// Address range: 0x5613 - 0x5764
int64_t function_5613(int64_t a1, int64_t a2, uint64_t a3) {
    int64_t v1 = a1; // 0x5633
    int64_t v2 = a1; // 0x5633
    uint64_t v3 = *(int64_t *)(v1 + 16); // 0x563b
    v2 += 16;
    while (v1 != a2) {
        // 0x5637
        v1 += 40;
        v3 = *(int64_t *)(v1 + 16);
        v2 += 16;
    }
    int64_t result = a1; // 0x5706
    int64_t v4; // 0x5613
    int64_t v5; // 0x5613
    int64_t v6; // 0x5613
    if (a1 != a2) {
        v5 = a1;
        uint64_t v7; // 0x5697
        int64_t v8; // 0x56bb
        if (*(int64_t *)(v5 + 32) != a3) {
            // 0x56c0
            v8 = v5;
            v4 = -1;
            v6 = v5;
            if (v5 == a2) {
                goto lab_0x56cd_2;
            }
            uint64_t v9 = -1;
            v7 = *(int64_t *)(v8 + 32);
            while (v7 > a3) {
                // 0x56a9
                v8 += 40;
                if (v8 == a2) {
                    goto lab_0x56cd_2;
                }
                v9 = v7 >= v9 ? v9 : v7;
                v7 = *(int64_t *)(v8 + 32);
            }
        }
        int64_t v10 = v5 + 40; // 0x56f9
        result = v10;
        while (v10 != a2) {
            // 0x5673
            v5 = v10;
            if (*(int64_t *)(v5 + 32) != a3) {
                // 0x56c0
                v8 = v5;
                v4 = -1;
                v6 = v5;
                if (v5 == a2) {
                    goto lab_0x56cd_2;
                }
                int64_t v11 = -1;
                v7 = *(int64_t *)(v8 + 32);
                while (v7 > a3) {
                    // 0x56a9
                    v11 = v7 >= v11 ? v11 : v7;
                    v8 += 40;
                    v4 = v11;
                    v6 = v8;
                    if (v8 == a2) {
                        goto lab_0x56cd_2;
                    }
                    v7 = *(int64_t *)(v8 + 32);
                }
            }
            // 0x56f9
            v10 = v5 + 40;
            result = v10;
        }
    }
    goto lab_0x570f;
  lab_0x56cd_2:
    // 0x56cd
    function_5613(v5, v6, v4);
    result = v6;
    goto lab_0x570f;
  lab_0x570f:
    // 0x570f
    if (a3 == 0) {
        // 0x5762
        return result;
    }
    int64_t result2 = a1;
    int64_t * v12; // 0x572c
    if (result2 != v2) {
        // 0x5728
        v12 = (int64_t *)(result2 + 8);
        if (*v12 == 0) {
            // 0x5735
            *v12 = v2;
            *(int64_t *)(result2 + 32) = a3;
        }
    }
    int64_t v13 = result2 + 40; // 0x575d
    while (result2 != a2) {
        // 0x571e
        result2 = v13;
        if (result2 != v2) {
            // 0x5728
            v12 = (int64_t *)(result2 + 8);
            if (*v12 == 0) {
                // 0x5735
                *v12 = v2;
                *(int64_t *)(result2 + 32) = a3;
            }
        }
        // 0x574d
        v13 = result2 + 40;
    }
    // 0x5762
    return result2;
}

// Address range: 0x5764 - 0x58e0
int64_t function_5764(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a1 + 16); // 0x577b
    int64_t v2 = 0; // 0x58ca
    if (a2 == 0) {
        // 0x58d0
        return 0;
    }
    int64_t v3 = *(int64_t *)(40 * v2 + a1); // 0x57b4
    int64_t v4 = *(int64_t *)(v3 + 8); // 0x57bf
    char v5; // 0x5803
    int64_t * v6; // 0x5815
    int64_t v7; // 0x5821
    int64_t * v8; // 0x5837
    int64_t v9; // 0x57f6
    uint64_t v10; // 0x5800
    if (v4 != 0) {
        // 0x57d2
        v9 = *(int64_t *)(v3 + 32);
        v10 = *(int64_t *)(v4 + 24) - v9 + *(int64_t *)(v4 + 16) - v1;
        if (v10 < 0x3fff) {
            // 0x5811
            v5 = v10;
            v6 = (int64_t *)(v3 + 24);
            v7 = *v6 - v9;
            *v6 = v7 + 2;
            v8 = (int64_t *)(v3 + 16);
            *(char *)(v7 + 1 + *v8) = v5;
            *(char *)(*v8 - 2 + *v6) = v5 >> 7 | -64;
        }
    }
    int64_t * v11 = (int64_t *)(v3 + 16); // 0x587c
    int64_t v12 = *v11; // 0x587c
    int64_t * v13 = (int64_t *)(v3 + 24);
    if (v1 != v12) {
        // 0x5886
        memmove((int64_t *)v1, (int64_t *)v12, (int32_t)*v13);
        *v11 = v1;
    }
    int64_t v14 = *v13 + v1; // 0x58b9
    v2++;
    while (v2 != a2) {
        int64_t v15 = v14;
        v3 = *(int64_t *)(40 * v2 + a1);
        v4 = *(int64_t *)(v3 + 8);
        if (v4 != 0) {
            // 0x57d2
            v9 = *(int64_t *)(v3 + 32);
            v10 = *(int64_t *)(v4 + 24) - v9 + *(int64_t *)(v4 + 16) - v1;
            if (v10 < 0x3fff) {
                // 0x5811
                v5 = v10;
                v6 = (int64_t *)(v3 + 24);
                v7 = *v6 - v9;
                *v6 = v7 + 2;
                v8 = (int64_t *)(v3 + 16);
                *(char *)(v7 + 1 + *v8) = v5;
                *(char *)(*v8 - 2 + *v6) = v5 >> 7 | -64;
            }
        }
        // 0x5878
        v11 = (int64_t *)(v3 + 16);
        v12 = *v11;
        v13 = (int64_t *)(v3 + 24);
        if (v15 != v12) {
            // 0x5886
            memmove((int64_t *)v15, (int64_t *)v12, (int32_t)*v13);
            *v11 = v15;
        }
        // 0x58b1
        v14 = *v13 + v15;
        v2++;
    }
    // 0x58d0
    return v14 - v1;
}

// Address range: 0x58e0 - 0x5dca
int64_t function_58e0(int64_t a1, int64_t a2) {
    int64_t v1 = a2; // 0x5910
    while (*(int64_t *)v1 != 0) {
        // 0x5917
        v1 += 8;
    }
    int64_t v2 = v1 - a2; // 0x592b
    if (v2 < 8) {
        // 0x5dc8
        return 0xfffffffe;
    }
    int64_t nmemb = v2 / 8; // 0x5931
    int64_t v3 = 0x100000000 * nmemb;
    uint64_t v4 = v3 / 0x100000000; // 0x594a
    int64_t v5 = 40 * v4; // 0x5958
    int64_t base = function_2d50(v5); // 0x595f
    int64_t v6 = 0; // 0x5a5e
    int64_t v7 = 0; // 0x5a5e
    int64_t v8 = 0; // 0x5a5e
    if (v3 != 0) {
        int64_t len = strlen((char *)*(int64_t *)(8 * v6 + a2)); // 0x598e
        v7 = v7 + 2 + len;
        int64_t v9 = 40 * v6 + base; // 0x59d8
        *(int64_t *)v9 = v9;
        *(int64_t *)(v9 + 24) = len;
        *(int64_t *)(v9 + 32) = 0;
        *(int64_t *)(v9 + 8) = 0;
        v6++;
        v8 = v7;
        while (v6 < v4) {
            // 0x5975
            len = strlen((char *)*(int64_t *)(8 * v6 + a2));
            v7 = v7 + 2 + len;
            v9 = 40 * v6 + base;
            *(int64_t *)v9 = v9;
            *(int64_t *)(v9 + 24) = len;
            *(int64_t *)(v9 + 32) = 0;
            *(int64_t *)(v9 + 8) = 0;
            v6++;
            v8 = v7;
        }
    }
    int64_t v10 = v8;
    int64_t v11 = function_2d50(2 * (v10 + 254) / 255 + v10); // 0x5aa1
    int64_t v12 = 0; // 0x5b51
    int64_t v13 = v11; // 0x5b51
    if (v3 == 0) {
        // 0x5b61
        function_2d70(base);
        function_2d70(v11);
        // 0x5dc8
        return 0xffffffff;
    }
    int64_t v14 = 40 * v12 + base; // 0x5ad8
    *(int64_t *)(v14 + 16) = v13;
    function_54e9(v14, *(int64_t *)(8 * v12 + a2));
    v13 += *(int64_t *)(v14 + 24);
    v12++;
    while (v12 < v4) {
        // 0x5abf
        v14 = 40 * v12 + base;
        *(int64_t *)(v14 + 16) = v13;
        function_54e9(v14, *(int64_t *)(8 * v12 + a2));
        v13 += *(int64_t *)(v14 + 24);
        v12++;
    }
    if (v13 == v11) {
        // 0x5b61
        function_2d70(base);
        function_2d70(v11);
        // 0x5dc8
        return 0xffffffff;
    }
    // 0x5b83
    qsort((int64_t *)base, (int32_t)nmemb, 40, (int32_t (*)(int64_t *, int64_t *))0x52ae);
    function_542e(base, v4);
    int64_t v15 = base - 40;
    int64_t v16 = 1; // 0x5c37
    if (v4 > 1) {
        int64_t v17 = 40 * v16; // 0x5bca
        int64_t v18 = v17 + v15; // 0x5bf3
        *(int64_t *)(v18 + 32) = function_5378(v18, v17 + base);
        v16++;
        while (v16 != v4) {
            // 0x5bbc
            v17 = 40 * v16;
            v18 = v17 + v15;
            *(int64_t *)(v18 + 32) = function_5378(v18, v17 + base);
            v16++;
        }
    }
    // 0x5c39
    function_5613(base, v15 + v5, 0);
    int64_t v19 = function_5764(base, v4); // 0x5c79
    uint64_t v20 = v19 + 254; // 0x5c91
    int64_t v21 = v20 / 255;
    int64_t v22 = 2 * v21;
    if (v20 >= 255) {
        int64_t v23 = 255 * v21 - 255; // 0x5cc1
        int64_t v24 = v23 + v22; // 0x58e0
        int64_t v25 = v21; // 0x5d88
        int64_t v26 = v23;
        v25--;
        int64_t v27 = v19 - v26; // 0x5cfe
        int64_t v28 = v24 + v11;
        memmove((int64_t *)v28, (int64_t *)(v26 + v11), (int32_t)v27);
        *(char *)(v28 - 2) = 119;
        *(char *)(v28 - 1) = (char)v27;
        v24 -= 257;
        int64_t v29 = v26 - 255; // 0x5d93
        while (v25 != 0) {
            int64_t v30 = v26;
            v26 = v29;
            v25--;
            v27 = v30 - v26;
            v28 = v24 + v11;
            memmove((int64_t *)v28, (int64_t *)(v26 + v11), (int32_t)v27);
            *(char *)(v28 - 2) = 119;
            *(char *)(v28 - 1) = (char)v27;
            v24 -= 257;
            v29 = v26 - 255;
        }
    }
    // 0x5d99
    function_2d70(base);
    *(int64_t *)(a1 + 432) = v11;
    *(int64_t *)(a1 + 424) = v22 + v19;
    // 0x5dc8
    return 0;
}

// Address range: 0x5dca - 0x5df1
int64_t function_5dca(int64_t result) {
    // 0x5dca
    *(int64_t *)(result + 24) = result;
    *(int64_t *)(result + 16) = result;
    return result;
}

// Address range: 0x5df1 - 0x5e38
int64_t function_5df1(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a2 + 16); // 0x5e01
    int64_t * v2 = (int64_t *)(a1 + 16); // 0x5e09
    *v2 = *v1;
    *v1 = a1;
    *(int64_t *)(a1 + 24) = a2;
    int64_t result = *v2; // 0x5e29
    *(int64_t *)(result + 24) = a1;
    return result;
}

// Address range: 0x5e38 - 0x5e6b
int64_t function_5e38(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 24); // 0x5e44
    int64_t * v2 = (int64_t *)(a1 + 16); // 0x5e4c
    *(int64_t *)(*v1 + 16) = *v2;
    int64_t result = *v2; // 0x5e58
    *(int64_t *)(result + 24) = *v1;
    return result;
}

// Address range: 0x5e6b - 0x5ece
int64_t function_5e6b(int64_t result) {
    int64_t v1 = result + 192; // 0x5e77
    *(int64_t *)(result + 200) = v1;
    *(int64_t *)v1 = v1;
    int64_t v2 = result + 208; // 0x5ea3
    *(int64_t *)(result + 216) = v2;
    *(int64_t *)v2 = v2;
    return result;
}

// Address range: 0x5ece - 0x6168
int64_t function_5ece(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a2 + 64); // 0x5ee2
    int64_t v2 = *v1; // 0x5ee2
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x5f1e
        int64_t v3; // 0x5ece
        int64_t v4; // 0x5ece
        int64_t v5; // 0x5ece
        function_3080("Slirp", 128, "if_output...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x5f52
            function_3080("Slirp", 128, " so = %p", a1, v4, v3);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x5f62
                function_3080("Slirp", 128, " ifm = %p", a2, v4, v3);
            }
        }
    }
    int32_t * v6 = (int32_t *)(a2 + 32); // 0x5f8a
    if ((*v6 & 4) != 0) {
        // 0x5f94
        function_ab7f(a2);
        *v6 = *v6 & -5;
    }
    int64_t v7 = *(int64_t *)(v2 + 216);
    int64_t v8 = v7; // 0x5ece
    if (a1 == 0) {
        goto lab_0x6091;
    } else {
        int64_t v9 = v2 + 208; // 0x6011
        if (v7 != v9) {
            int64_t v10 = v7;
            while (*(int64_t *)(v10 + 40) != a1) {
                int64_t v11 = *(int64_t *)(v10 + 8);
                if (v11 == v9) {
                    goto lab_0x6024;
                }
                v10 = v11;
            }
            // 0x5fd9
            *(int64_t *)(a2 + 40) = a1;
            function_5df1(a2, *(int64_t *)(v10 + 24));
            goto lab_0x60bc;
        } else {
            goto lab_0x6024;
        }
    }
  lab_0x6024:
    // 0x6024
    v8 = v7;
    if ((*(char *)(a1 + 328) & 16) == 0) {
        goto lab_0x6091;
    } else {
        int64_t v12 = *(int64_t *)(v2 + 200); // 0x603d
        v8 = v12;
        if (*(int64_t *)(v12 + 40) != a1) {
            goto lab_0x6091;
        } else {
            // 0x605d
            *(int64_t *)(a2 + 40) = a1;
            function_5df1(a2, *(int64_t *)(v12 + 24));
            goto lab_0x60bc;
        }
    }
  lab_0x6091:
    // 0x6091
    *(int64_t *)(a2 + 40) = a1;
    function_5dca(a2);
    function_ab4c(a2, v8);
    goto lab_0x60bc;
  lab_0x60bc:
    if (a1 == 0) {
        // 0x6155
        return function_6168(*v1);
    }
    int32_t * v13 = (int32_t *)(a1 + 348); // 0x60cb
    *v13 = *v13 + 1;
    int32_t * v14 = (int32_t *)(a1 + 352); // 0x60e2
    uint32_t v15 = *v14 + 1; // 0x60e8
    *v14 = v15;
    if (v15 >= 6) {
        // 0x610a
        if (v15 - *v13 >= 3) {
            int64_t * v16 = (int64_t *)(a2 + 16); // 0x612b
            function_ab7f(*v16);
            function_ab4c(*v16, v2 + 208);
        }
    }
    // 0x6155
    return function_6168(*v1);
}

// Address range: 0x6168 - 0x63a8
int64_t function_6168(int64_t result2) {
    uint64_t v1 = *(int64_t *)(*(int64_t *)(result2 + (int64_t)&g8) + 16); // 0x617f
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x61ab
        int64_t v2; // 0x6168
        int64_t v3; // 0x6168
        int64_t v4; // 0x6168
        function_3080("Slirp", 128, "if_start...", v4, v3, v2);
    }
    char * v5 = (char *)(result2 + 224); // 0x61cc
    unsigned char result = *v5; // 0x61cc
    if (result != 0) {
        // 0x63a6
        return result;
    }
    // 0x61db
    *v5 = 1;
    int64_t v6 = result2 + 208; // 0x61f2
    int64_t v7 = *(int64_t *)v6; // 0x61f2
    int64_t v8 = v7 == v6 ? 0 : v7;
    int64_t v9 = result2 + 192; // 0x621c
    int64_t v10 = *(int64_t *)v9; // 0x621c
    int64_t v11 = v10 == v9 ? v8 : v10;
    if (v11 == 0) {
        // 0x6398
        *v5 = 0;
        // 0x63a6
        return result2;
    }
    int32_t v12 = v10 == v9 == (v8 != 0);
    int64_t v13 = v11;
    int64_t v14; // 0x6168
    int64_t v15; // 0x6168
    int64_t v16; // 0x6168
    while (true) {
      lab_0x626c:
        // 0x626c
        v15 = v13;
        int64_t v17 = *(int64_t *)v15; // 0x6278
        int64_t v18 = v17 != v9 ? v17 : v8;
        v12 = v17 != v9 ? v12 : 1;
        v14 = v18 != v6 ? v18 : 0;
        if (v1 > *(int64_t *)(v15 + 80)) {
            goto lab_0x62dd;
        } else {
            // 0x62c1
            v16 = v14;
            if ((int32_t)function_e953(result2, v15) != 0) {
                goto lab_0x62dd;
            } else {
                goto lab_0x638d;
            }
        }
    }
  lab_0x6398:
    // 0x6398
    *v5 = 0;
    // 0x63a6
    return result2;
  lab_0x62dd:;
    int64_t v19 = *(int64_t *)(v15 + 8); // 0x62e1
    function_ab7f(v15);
    int64_t v20 = *(int64_t *)(v15 + 16); // 0x62f9
    int64_t v21 = v14; // 0x6301
    if (v15 != v20) {
        // 0x6303
        function_ab4c(v20, v19);
        function_5e38(v15);
        v21 = (char)v12 == 1 ? v14 : v20;
    }
    int64_t * v22 = (int64_t *)(v15 + 40); // 0x6345
    int64_t v23 = *v22; // 0x6345
    if (v23 != 0) {
        int32_t * v24 = (int32_t *)(v23 + 348); // 0x6356
        int32_t v25 = *v24 - 1; // 0x635c
        *v24 = v25;
        if (v25 == 0) {
            // 0x636f
            *(int32_t *)(*v22 + 352) = 0;
        }
    }
    // 0x6381
    function_a4f0(v15);
    v16 = v21;
    goto lab_0x638d;
  lab_0x638d:
    // 0x638d
    v13 = v16;
    if (v13 == 0) {
        // break -> 0x6398
        goto lab_0x6398;
    }
    goto lab_0x626c;
}

// Address range: 0x63a8 - 0x63d7
int64_t function_63a8(int64_t str, int64_t * str2) {
    int32_t memcmp_rc = memcmp((int64_t *)str, str2, 16); // 0x63cb
    return (int64_t)(memcmp_rc & -256) | (int64_t)(memcmp_rc == 0);
}

// Address range: 0x63d7 - 0x64a4
int64_t function_63d7(int64_t str, int64_t str2, uint64_t a3) {
    int32_t v1 = a3;
    int32_t n = v1 / 128;
    if (memcmp((int64_t *)str, (int64_t *)str2, n) != 0) {
        // 0x64a2
        return 0;
    }
    // 0x641c
    if (a3 % 8 == 0) {
        // 0x64a2
        return 1;
    }
    int64_t v2 = n; // 0x643f
    unsigned char v3 = *(char *)(v2 + str); // 0x6441
    uint32_t v4 = (v1 >> 31) / 0x20000000; // 0x644c
    uint32_t v5 = (v4 | 8) - (v4 + v1) % 8; // 0x6463
    unsigned char v6 = *(char *)(v2 + str2); // 0x6479
    int64_t v7 = v6; // 0x6499
    if (v5 != 0) {
        v7 = (int32_t)v6 >> v5;
    }
    int64_t v8 = v7;
    int64_t result = v8 & 0xffffff00 | (int64_t)((int32_t)v3 >> v5 == (int32_t)v8); // 0x649f
    // 0x64a2
    return result;
}

// Address range: 0x64a4 - 0x658f
int64_t function_64a4(int64_t a1, int64_t a2, uint64_t a3) {
    int32_t v1 = a3;
    int32_t v2 = v1 / 0x4000; // 0x64c5
    int64_t v3 = v2; // 0x64e1
    if (memcmp((int64_t *)(v3 + a1), (int64_t *)(v3 + a2), 16 - v2) != 0) {
        // 0x658d
        return 0;
    }
    int64_t result = 1; // 0x6524
    if (a3 % 8 != 0) {
        int64_t v4 = v1 / 128; // 0x653f
        char v5 = *(char *)(v4 + a1); // 0x6541
        char v6 = *(char *)(v4 + a2); // 0x6559
        uint32_t v7 = (v1 >> 31) / 0x20000000; // 0x6566
        uint32_t v8 = (v7 | 8) - (v7 + v1) % 8; // 0x6580
        int32_t v9 = v8 == 0 ? 0 : -1 << v8 ^ 255;
        result = (v9 & (int32_t)(v6 ^ v5)) == 0;
    }
    // 0x658d
    return result;
}

// Address range: 0x658f - 0x65cf
int64_t function_658f(int64_t a1, int64_t a2, int64_t a3) {
    // 0x658f
    *(char *)a3 = 82;
    *(char *)(a3 + 1) = 86;
    uint32_t result; // 0x658f
    return result;
}

// Address range: 0x65cf - 0x6697
int64_t function_65cf(int64_t a1) {
    // 0x65cf
    function_3020(*(int64_t *)(a1 + (int64_t)&g5), 0x30d40, 0x927c0);
    return function_6c7b(a1);
}

// Address range: 0x6697 - 0x6798
int64_t function_6697(int64_t a1) {
    unsigned char v1 = *(char *)(a1 + 10) ^ 1;
    int64_t result = v1; // 0x66b5
    if (v1 == 0) {
        int64_t v2 = *(int64_t *)(*(int64_t *)(a1 + (int64_t)&g8) + 24); // 0x66c6
        int64_t * v3 = (int64_t *)(a1 + (int64_t)&g6); // 0x66ec
        *v3 = v2;
        function_3020(*(int64_t *)(a1 + (int64_t)&g5), 0x30d40, 0x927c0);
        result = *v3;
    }
    // 0x678d
    return result;
}

// Address range: 0x6798 - 0x67e5
int64_t function_6798(int64_t a1) {
    unsigned char v1 = *(char *)(a1 + 10) ^ 1;
    int64_t result = v1; // 0x67b1
    if (v1 == 0) {
        // 0x67b3
        result = *(int64_t *)(*(int64_t *)(a1 + (int64_t)&g8) + 32);
    }
    // 0x67e3
    return result;
}

// Address range: 0x67e5 - 0x6903
int64_t function_67e5(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = function_a39a(a2); // 0x6804
    int32_t v2 = (int32_t)ntohs(*(int16_t *)(a3 + 4)) + 40; // 0x6822
    *(int32_t *)(v1 + 56) = v2;
    int64_t * v3 = (int64_t *)(v1 + 48); // 0x6844
    memcpy((int64_t *)*v3, (int64_t *)*(int64_t *)(a1 + 48), v2);
    int64_t v4 = *v3; // 0x6857
    *(int64_t *)(v4 + 24) = *(int64_t *)(a3 + 8);
    *(int64_t *)(v4 + 32) = *(int64_t *)(a3 + 16);
    *(int64_t *)(v4 + 8) = *(int64_t *)(a3 + 24);
    *(int64_t *)(v4 + 16) = *(int64_t *)(a3 + 32);
    int64_t v5 = *v3; // 0x6893
    int64_t v6 = v5 + 40; // 0x6897
    *v3 = v6;
    *(char *)v6 = -127;
    int16_t * v7 = (int16_t *)(v5 + 42); // 0x68ba
    *v7 = 0;
    *v3 = *v3 - 40;
    *v7 = (int16_t)function_4820(v1);
    return function_80bc(0, v1, 0);
}

// Address range: 0x6903 - 0x6c7b
int64_t function_6903(int64_t a1, int64_t a2, int64_t a3) {
    uint64_t v1 = (int64_t)(0x100000000000000 * a2 / 0x100000000000000); // 0x691b
    int64_t v2 = 0x100000000000000 * a3 / 0x100000000000000; // 0x6921
    int64_t v3 = __readfsqword(40); // 0x6927
    int64_t v4 = *(int64_t *)(a1 + 64); // 0x693d
    int64_t * v5 = (int64_t *)(a1 + 48); // 0x694c
    int64_t v6 = *v5; // 0x694c
    int64_t v7; // 0x6903
    int64_t v8; // 0x6903
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x6981
        int64_t v9; // 0x6903
        function_3080("Slirp", 128, "icmp6_send_error...", a2 & 0xffffffff, v9, v8);
        if (*(int32_t *)&g58 % 2 != 0) {
            int64_t v10 = v2 % 256; // 0x699f
            function_3080("Slirp", 128, " type = %d, code = %d", v1 % 256, v10, v8);
            v7 = v10;
        }
    }
    int64_t v11 = v6 + 8; // 0x69c5
    int64_t v12; // 0x6a0a
    int64_t * v13; // 0x6a17
    int64_t v14; // 0x6adc
    int16_t * v15; // 0x6b5d
    if (*(char *)v11 == -1) {
        goto lab_0x6c65;
    } else {
        int64_t v16 = 0; // bp-88, 0x69d4
        if ((char)function_63a8(v11, &v16) != 0) {
            goto lab_0x6c65;
        } else {
            // 0x6a03
            v12 = function_a39a(v4);
            v13 = (int64_t *)(v12 + 48);
            int64_t v17 = *v13; // 0x6a17
            int64_t v18 = v17 + 8; // 0x6a23
            *(int64_t *)v18 = 0;
            *(int64_t *)(v17 + 16) = 0;
            *(char *)v18 = -2;
            *(char *)(v17 + 9) = -128;
            *(char *)(v17 + 23) = 2;
            int64_t * address = (int64_t *)(v17 + 24); // 0x6a5b
            *address = *(int64_t *)v11;
            *(int64_t *)(v17 + 32) = *(int64_t *)(v6 + 16);
            int64_t address_str; // bp-72, 0x6903
            inet_ntop(AF_INET6, address, (char *)&address_str, 46);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x6a91
                function_3080("Slirp", 128, " target = %s", (int64_t)&address_str, v7, v8);
            }
            // 0x6ab5
            *(char *)(v17 + 6) = 58;
            int32_t * host_long = (int32_t *)(v4 + 136); // 0x6ac1
            uint64_t v19 = (int64_t)*host_long - 48; // 0x6ac9
            uint64_t v20 = (int64_t)*(int32_t *)(a1 + 56); // 0x6ad7
            v14 = v19 > v20 ? v20 : v19;
            int16_t net_short = htons((int16_t)v14 + 8); // 0x6aee
            *(int16_t *)(v17 + 4) = net_short;
            *(int32_t *)(v12 + 56) = (int32_t)ntohs(net_short) + 40;
            int64_t v21 = *v13; // 0x6b22
            int64_t v22 = v21 + 40; // 0x6b26
            *v13 = v22;
            char v23 = v1;
            *(char *)v22 = v23;
            *(char *)(v21 + 41) = (char)v2;
            v15 = (int16_t *)(v21 + 42);
            *v15 = 0;
            uint64_t v24 = v1 % 256; // 0x6b63
            if (v24 == 2) {
                // 0x6b94
                *(int32_t *)(v21 + 44) = htonl(*host_long);
                goto lab_0x6bd6;
            } else {
                uint32_t v25 = (int32_t)v24; // 0x6b72
                if (v25 > 2) {
                    switch (v23) {
                        case 3: {
                            // 0x6b87
                            *(int32_t *)(v21 + 44) = 0;
                            goto lab_0x6bd6;
                        }
                        case 4: {
                            goto lab_0x6bd6;
                        }
                        default: {
                            // 0x6bb0
                            function_2ea0("Slirp", "../src/ip6_icmp.c", 121, "icmp6_send_error", 0);
                            goto lab_0x6bd6;
                        }
                    }
                } else {
                    if (v25 == 1) {
                        // 0x6b87
                        *(int32_t *)(v21 + 44) = 0;
                        goto lab_0x6bd6;
                    } else {
                        // 0x6bb0
                        function_2ea0("Slirp", "../src/ip6_icmp.c", 121, "icmp6_send_error", 0);
                        goto lab_0x6bd6;
                    }
                }
            }
        }
    }
  lab_0x6c65:;
    int64_t result = 0; // 0x6c72
    if (v3 != __readfsqword(40)) {
        // 0x6c74
        __stack_chk_fail();
        result = &g91;
    }
    // 0x6c79
    return result;
  lab_0x6bd6:;
    int64_t v26 = *v13 + 8; // 0x6bde
    *v13 = v26;
    memcpy((int64_t *)v26, (int64_t *)*v5, (int32_t)v14);
    *v13 = *v13 - 48;
    *v15 = (int16_t)function_4820(v12);
    function_80bc(0, v12, 0);
    goto lab_0x6c65;
}

// Address range: 0x6c7b - 0x7017
int64_t function_6c7b(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x6c87
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x6ca6
        int64_t v2; // 0x6c7b
        int64_t v3; // 0x6c7b
        int64_t v4; // 0x6c7b
        function_3080("Slirp", 128, "ndp_send_ra...", v4, v3, v2);
    }
    int64_t v5 = function_a39a(a1); // 0x6cca
    int64_t * v6 = (int64_t *)(v5 + 48); // 0x6cd7
    int64_t v7 = *v6; // 0x6cd7
    int64_t v8 = v7 + 8; // 0x6ceb
    int64_t * v9 = (int64_t *)v8; // 0x6ceb
    *v9 = 0;
    int64_t * v10 = (int64_t *)(v7 + 16); // 0x6cf3
    *v10 = 0;
    *(char *)v8 = -2;
    *(char *)(v7 + 9) = -128;
    *(char *)(v7 + 23) = 2;
    int64_t v11 = v7 + 24; // 0x6d17
    *(int64_t *)v11 = 0;
    *(int64_t *)(v7 + 32) = 0;
    *(char *)v11 = -1;
    *(char *)(v7 + 25) = 2;
    *(char *)(v7 + 39) = 1;
    *(char *)(v7 + 6) = 58;
    int64_t v12 = *v6; // 0x6d4b
    int64_t v13 = v12 + 40; // 0x6d4f
    *v6 = v13;
    *(char *)v13 = -122;
    *(char *)(v12 + 41) = 0;
    int16_t * v14 = (int16_t *)(v12 + 42); // 0x6d7a
    *v14 = 0;
    *(char *)(v12 + 44) = 64;
    *(char *)(v12 + 45) = 0;
    *(int16_t *)(v12 + 46) = htons((int16_t)&g88);
    *(int32_t *)(v12 + 48) = htonl(0);
    *(int32_t *)(v12 + 52) = htonl(0);
    int64_t v15 = *v6; // 0x6df0
    int64_t v16 = v15 + 16; // 0x6df4
    *v6 = v16;
    *(char *)v16 = 1;
    *(char *)(v15 + 17) = 1;
    function_658f(*v9, *v10, v15 + 18);
    int64_t v17 = *v6; // 0x6e43
    int64_t v18 = v17 + 8; // 0x6e47
    *v6 = v18;
    *(char *)v18 = 3;
    *(char *)(v17 + 9) = 4;
    *(char *)(v17 + 10) = *(char *)(a1 + 40);
    *(char *)(v17 + 11) = -64;
    *(int32_t *)(v17 + 12) = htonl(0x15180);
    *(int32_t *)(v17 + 16) = htonl(0x3840);
    *(int32_t *)(v17 + 20) = 0;
    *(int64_t *)(v17 + 24) = *(int64_t *)(a1 + 24);
    *(int64_t *)(v17 + 32) = *(int64_t *)(a1 + 32);
    *v6 = *v6 + 32;
    int64_t v19; // bp-100, 0x6c7b
    int64_t v20; // bp-40, 0x6c7b
    int64_t v21 = function_d049(&v20, &v19); // 0x6f1c
    int16_t host_short = 56; // 0x6f23
    if ((int32_t)v21 >= 0) {
        int64_t v22 = *v6; // 0x6f29
        *(char *)v22 = 25;
        *(char *)(v22 + 1) = 3;
        *(int16_t *)(v22 + 2) = 0;
        *(int32_t *)(v22 + 4) = htonl(0x124f80);
        *(int64_t *)(v22 + 8) = *(int64_t *)(a1 + 68);
        *(int64_t *)(v22 + 16) = *(int64_t *)(a1 + 76);
        *v6 = *v6 + 24;
        host_short = 80;
    }
    // 0x6f8e
    *(int16_t *)(v7 + 4) = htons(host_short);
    *v6 = -40 - (int64_t)host_short + *v6;
    *(int32_t *)(v5 + 56) = (int32_t)(host_short + 40);
    *v14 = (int16_t)function_4820(v5);
    function_80bc(0, v5, 0);
    int64_t result = 0; // 0x700e
    if (v1 != __readfsqword(40)) {
        // 0x7010
        __stack_chk_fail();
        result = &g91;
    }
    // 0x7015
    return result;
}

// Address range: 0x7017 - 0x72e0
int64_t function_7017(int64_t a1, int64_t a2, int64_t a3) {
    int64_t address = a2; // bp-136, 0x702c
    int64_t v1 = __readfsqword(40); // 0x7034
    int64_t address_str; // bp-72, 0x7017
    inet_ntop(AF_INET6, &address, (char *)&address_str, 46);
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x708a
        int64_t v2; // 0x7017
        int64_t v3; // 0x7017
        function_3080("Slirp", 128, "ndp_send_ns...", 46, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x709a
            function_3080("Slirp", 128, " target = %s", (int64_t)&address_str, v3, v2);
        }
    }
    int64_t v4 = function_a39a(a1); // 0x70c5
    int64_t * v5 = (int64_t *)(v4 + 48); // 0x70d2
    int64_t v6 = *v5; // 0x70d2
    int64_t * v7 = (int64_t *)(a1 + 52); // 0x70e2
    int64_t * v8 = (int64_t *)(a1 + 44); // 0x70e6
    *(int64_t *)(v6 + 8) = *v8;
    *(int64_t *)(v6 + 16) = *v7;
    *(char *)(v6 + 24) = -1;
    *(char *)(v6 + 25) = 2;
    *(char *)(v6 + 26) = 0;
    *(char *)(v6 + 27) = 0;
    *(char *)(v6 + 28) = 0;
    *(char *)(v6 + 29) = 0;
    *(char *)(v6 + 30) = 0;
    *(char *)(v6 + 31) = 0;
    *(char *)(v6 + 32) = 0;
    *(char *)(v6 + 33) = 0;
    *(char *)(v6 + 34) = 0;
    *(char *)(v6 + 35) = 1;
    *(char *)(v6 + 36) = -1;
    int64_t v9 = v6 + 37; // 0x715e
    *(char *)v9 = 0;
    *(char *)(v6 + 38) = 0;
    *(char *)(v6 + 39) = 0;
    int64_t v10; // bp-123, 0x7017
    memcpy((int64_t *)v9, &v10, 3);
    *(char *)(v6 + 6) = 58;
    int16_t net_short = htons(32); // 0x719f
    *(int16_t *)(v6 + 4) = net_short;
    *(int32_t *)(v4 + 56) = (int32_t)ntohs(net_short) + 40;
    int64_t v11 = *v5; // 0x71d3
    int64_t v12 = v11 + 40; // 0x71d7
    *v5 = v12;
    *(char *)v12 = -121;
    *(char *)(v11 + 41) = 0;
    int16_t * v13 = (int16_t *)(v11 + 42); // 0x7202
    *v13 = 0;
    *(int32_t *)(v11 + 44) = 0;
    *(int64_t *)(v11 + 48) = address;
    *(int64_t *)(v11 + 56) = a3;
    int64_t v14 = *v5; // 0x722b
    int64_t v15 = v14 + 24; // 0x722f
    *v5 = v15;
    *(char *)v15 = 1;
    *(char *)(v14 + 25) = 1;
    function_658f(*v8, *v7, v14 + 26);
    *v5 = *v5 - 64;
    *v13 = (int16_t)function_4820(v4);
    function_80bc(0, v4, 1);
    int64_t result = 0; // 0x72d7
    if (v1 != __readfsqword(40)) {
        // 0x72d9
        __stack_chk_fail();
        result = &g91;
    }
    // 0x72de
    return result;
}

// Address range: 0x72e0 - 0x754e
int64_t function_72e0(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = __readfsqword(40); // 0x72f4
    int64_t v2 = function_a39a(a1); // 0x730a
    int64_t * v3 = (int64_t *)(v2 + 48); // 0x7317
    int64_t v4 = *v3; // 0x7317
    int64_t * v5 = (int64_t *)(a3 + 16); // 0x7327
    int64_t * v6 = (int64_t *)(a3 + 8); // 0x732b
    *(int64_t *)(v4 + 8) = *v6;
    *(int64_t *)(v4 + 16) = *v5;
    int64_t v7 = 0; // bp-40, 0x7337
    int64_t v8 = a2 + 8; // 0x734b
    char * v9; // 0x72e0
    if ((char)function_63a8(v8, &v7) == 0) {
        int64_t v10 = v4 + 24;
        *(int64_t *)v10 = *(int64_t *)v8;
        *(int64_t *)(v4 + 32) = *(int64_t *)(a2 + 16);
        v9 = (char *)v10;
    } else {
        int64_t v11 = v4 + 24;
        *(int64_t *)v11 = 0;
        *(int64_t *)(v4 + 32) = 0;
        char * v12 = (char *)v11;
        *v12 = -1;
        *(char *)(v4 + 25) = 2;
        *(char *)(v4 + 39) = 1;
        v9 = v12;
    }
    // 0x73a8
    *(char *)(v4 + 6) = 58;
    int16_t net_short = htons(32); // 0x73b5
    *(int16_t *)(v4 + 4) = net_short;
    *(int32_t *)(v2 + 56) = (int32_t)ntohs(net_short) + 40;
    int64_t v13 = *v3; // 0x73e9
    int64_t v14 = v13 + 40; // 0x73ed
    *v3 = v14;
    *(char *)v14 = -120;
    *(char *)(v13 + 41) = 0;
    int16_t * v15 = (int16_t *)(v13 + 42); // 0x7418
    *v15 = 0;
    int64_t v16 = v13 + 44; // 0x7422
    char * v17 = (char *)v16; // 0x7422
    *v17 = *v17 | -128;
    *v17 = 64 * (char)(*v9 != -1) | -96;
    int32_t * v18 = (int32_t *)v16; // 0x7474
    *v18 = *v18 % 256;
    int64_t * v19 = (int64_t *)(v13 + 48); // 0x748d
    *v19 = *v6;
    int64_t * v20 = (int64_t *)(v13 + 56); // 0x7491
    *v20 = *v5;
    int64_t v21 = *v3; // 0x7499
    int64_t v22 = v21 + 24; // 0x749d
    *v3 = v22;
    *(char *)v22 = 2;
    *(char *)(v21 + 25) = 1;
    function_658f(*v19, *v20, v21 + 26);
    *v3 = *v3 - 64;
    *v15 = (int16_t)function_4820(v2);
    function_80bc(0, v2, 0);
    int64_t result = 0; // 0x7545
    if (v1 != __readfsqword(40)) {
        // 0x7547
        __stack_chk_fail();
        result = &g91;
    }
    // 0x754c
    return result;
}

// Address range: 0x754e - 0x7ae5
int64_t function_754e(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0x7566
    int32_t * v2 = (int32_t *)(a1 + 56); // 0x7579
    *v2 = *v2 + 14;
    int64_t * v3 = (int64_t *)(a1 + 48); // 0x758a
    *v3 = *v3 - 14;
    *v2 = *v2 - 14;
    *v3 = *v3 + 14;
    int64_t v4; // 0x754e
    int64_t v5 = (int64_t)*(char *)&v4 + 0xffffff7b; // 0x75d5
    if ((int32_t)v5 < 5) {
        int32_t v6 = *(int32_t *)((4 * v5 & 0x3fffffffc) + (int64_t)&g13); // 0x75f4
        return (int64_t)v6 + (int64_t)&g13;
    }
    int64_t result = 0; // 0x7adc
    if (v1 != __readfsqword(40)) {
        // 0x7ade
        __stack_chk_fail();
        result = &g91;
    }
    // 0x7ae3
    return result;
}

// Address range: 0x7ae5 - 0x7e9d
int64_t function_7ae5(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x7af1
    int64_t * v2 = (int64_t *)(a1 + 48); // 0x7b04
    int64_t v3 = *v2; // 0x7b04
    int64_t v4 = *(int64_t *)(a1 + 64); // 0x7b10
    int64_t v5; // 0x7ae5
    int64_t v6; // 0x7ae5
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x7b4c
        int64_t v7; // 0x7ae5
        function_3080("Slirp", 128, "icmp6_input...", v7, v6, v5);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x7b80
            function_3080("Slirp", 128, " m = %p", a1, v6, v5);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x7b90
                function_3080("Slirp", 128, " m_len = %d", (int64_t)*(int32_t *)(a1 + 56), v6, v5);
            }
        }
    }
    // 0x7bb6
    int64_t v8; // 0x7c06
    char * v9; // 0x7cb8
    int64_t v10; // 0x7cc3
    int64_t v11; // 0x7ccb
    if (ntohs(*(int16_t *)(v3 + 4)) < 4) {
        goto lab_0x7e7a;
    } else {
        // 0x7bd2
        if ((int32_t)function_4820(a1) != 0) {
            goto lab_0x7e7a;
        } else {
            int32_t * v12 = (int32_t *)(a1 + 56); // 0x7bea
            *v12 = *v12 - 40;
            v8 = *v2 + 40;
            *v2 = v8;
            char * v13 = (char *)v8; // 0x7c19
            *v12 = *v12 + 40;
            *v2 = *v2 - 40;
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x7c5c
                function_3080("Slirp", 128, " icmp6_type = %d", (int64_t)*v13, v6, v5);
            }
            unsigned char v14 = *v13; // 0x7c89
            if (v14 == -128) {
                // 0x7cb4
                v9 = (char *)(v4 + 40);
                v10 = v4 + 24;
                v11 = v3 + 24;
                if ((char)function_63d7(v11, v10, (int64_t)*v9) == 0) {
                    goto lab_0x7d0a;
                } else {
                    // 0x7cdd
                    if ((char)function_64a4(v11, v4 + 44, (int64_t)*v9) != 0) {
                        // 0x7e20
                        function_67e5(a1, v4, v3, v8);
                        goto lab_0x7e7a;
                    } else {
                        goto lab_0x7d0a;
                    }
                }
            } else {
                if (v14 <= 255) {
                    if ((int32_t)v14 < 138) {
                        // 0x7e59
                        function_754e(a1, v4, v3, v8);
                    }
                }
                goto lab_0x7e7a;
            }
        }
    }
  lab_0x7e7a:
    // 0x7e7a
    function_a4f0(a1);
    int64_t result = 0; // 0x7e94
    if (v1 != __readfsqword(40)) {
        // 0x7e96
        __stack_chk_fail();
        result = &g91;
    }
    // 0x7e9b
    return result;
  lab_0x7d0a:;
    int64_t v15 = -2; // bp-56, 0x7d1a
    if ((char)function_63d7(v11, (int64_t)&v15, 64) == 0) {
        goto lab_0x7d6e;
    } else {
        // 0x7d46
        if ((char)function_64a4(v11, v4 + 44, 64) != 0) {
            // 0x7e20
            function_67e5(a1, v4, v3, v8);
            goto lab_0x7e7a;
        } else {
            goto lab_0x7d6e;
        }
    }
  lab_0x7d6e:
    // 0x7d6e
    if ((char)function_63d7(v11, v10, (int64_t)*v9) == 0) {
        goto lab_0x7dc0;
    } else {
        // 0x7d97
        if ((char)function_64a4(v11, v4 + 68, (int64_t)*v9) != 0) {
            // 0x7e20
            function_67e5(a1, v4, v3, v8);
            goto lab_0x7e7a;
        } else {
            goto lab_0x7dc0;
        }
    }
  lab_0x7dc0:;
    int64_t v16 = -2; // bp-40, 0x7dd0
    if ((char)function_63d7(v11, (int64_t)&v16, 64) == 0) {
        // 0x7e3a
        function_3080("Slirp", 8, "external icmpv6 not supported yet", v11, v6, v5);
        goto lab_0x7e7a;
    } else {
        int64_t v17 = v4 + 68; // 0x7e00
        if ((char)function_64a4(v11, v17, 64) == 0) {
            // 0x7e3a
            function_3080("Slirp", 8, "external icmpv6 not supported yet", v17, v6, v5);
            goto lab_0x7e7a;
        } else {
            // 0x7e20
            function_67e5(a1, v4, v3, v8);
            goto lab_0x7e7a;
        }
    }
}

// Address range: 0x7e9d - 0x7eb8
int64_t function_7e9d(int64_t a1) {
    // 0x7e9d
    return function_6697(a1);
}

// Address range: 0x7eb8 - 0x7ed3
int64_t function_7eb8(int64_t a1) {
    // 0x7eb8
    return function_6798(a1);
}

// Address range: 0x7ed3 - 0x80bc
int64_t function_7ed3(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 64); // 0x7ee3
    if (*(char *)(v1 + 10) != 1) {
        // 0x80ba
        return function_a4f0(a1);
    }
    // 0x7efe
    int32_t * v2; // 0x7ed3
    if (*(int32_t *)&g58 % 2 == 0) {
        // 0x7f5f
        v2 = (int32_t *)(a1 + 56);
        goto lab_0x7f95;
    } else {
        // 0x7f2b
        int64_t v3; // 0x7ed3
        int64_t v4; // 0x7ed3
        int64_t v5; // 0x7ed3
        function_3080("Slirp", 128, "ip6_input...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 == 0) {
            // 0x7f5f
            v2 = (int32_t *)(a1 + 56);
            goto lab_0x7f95;
        } else {
            // 0x7f5f
            function_3080("Slirp", 128, " m = %p", a1, v4, v3);
            if (*(int32_t *)&g58 % 2 == 0) {
                // 0x7f5f
                v2 = (int32_t *)(a1 + 56);
                goto lab_0x7f95;
            } else {
                int32_t * v6 = (int32_t *)(a1 + 56);
                function_3080("Slirp", 128, " m_len = %d", (int64_t)*v6, v4, v3);
                v2 = v6;
                goto lab_0x7f95;
            }
        }
    }
  lab_0x7f95:
    // 0x7f95
    if (*v2 < 40) {
        // 0x80ba
        return function_a4f0(a1);
    }
    int64_t v7 = *(int64_t *)(a1 + 48); // 0x7fa9
    if ((*(char *)v7 & -16) != 96) {
        // 0x80ba
        return function_a4f0(a1);
    }
    int16_t * net_short = (int16_t *)(v7 + 4); // 0x7fc7
    if ((int64_t)ntohs(*net_short) > (int64_t)*(int32_t *)(v1 + 136)) {
        // 0x7fe6
        function_6903(a1, 2, 0);
        // 0x80ba
        return function_a4f0(a1);
    }
    // 0x8001
    if (*(char *)(v7 + 7) == 0) {
        // 0x800d
        function_6903(a1, 3, 0);
        // 0x80ba
        return function_a4f0(a1);
    }
    char v8 = *(char *)(v7 + 6); // 0x802c
    switch (v8) {
        case 17: {
            // 0x80ba
            return function_1b790(a1);
        }
        case 58: {
            // 0x80ba
            return function_7ae5(a1);
        }
    }
    int64_t result; // 0x7ed3
    if (v8 != 6) {
        // 0x8097
        result = function_a4f0(a1);
    } else {
        // 0x8042
        *net_short = ntohs(*net_short);
        result = function_12cfb(a1, 40, 0, 10);
    }
    // 0x80ba
    return result;
}

// Address range: 0x80bc - 0x81f2
int64_t function_80bc(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)(a2 + 48); // 0x80d3
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x8108
        int64_t v2; // 0x80bc
        int64_t v3; // 0x80bc
        int64_t v4; // 0x80bc
        function_3080("Slirp", 128, "ip6_output...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x813c
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x814c
                function_3080("Slirp", 128, " m = %p", a2, v3, v2);
            }
        }
    }
    char * v5 = (char *)v1; // 0x80d7
    *v5 = *v5 % 16 | 96;
    *(char *)(v1 + 7) = -1;
    *v5 = *v5 & -16;
    *(char *)(v1 + 1) = 0;
    *(int16_t *)(v1 + 2) = 0;
    if ((int32_t)a3 == 0) {
        // 0x81d8
        function_5ece(a1, a2);
    } else {
        // 0x81bf
        function_e953(*(int64_t *)(a2 + 64), a2);
    }
    // 0x81eb
    return 0;
}

// Address range: 0x81f2 - 0x8249
int64_t function_81f2(int64_t a1) {
    int64_t result = 16; // 0x81f2
    int64_t v1; // 0x81f2
    switch ((int16_t)v1) {
        case 10: {
            // 0x821b
            result = 28;
        }
        case 2: {
            // 0x8247
            return result;
        }
        default: {
            // 0x8222
            result = function_2ea0("Slirp", "../src/socket.h", 136, "sockaddr_size", 0);
            return result;
        }
    }
}

// Address range: 0x8249 - 0x8296
int64_t function_8249(int64_t result) {
    int64_t v1 = result + (int64_t)&g79; // 0x8255
    *(int64_t *)(result + (int64_t)&g80) = v1;
    *(int64_t *)v1 = v1;
    *(int64_t *)(result + (int64_t)&g85) = v1;
    return result;
}

// Address range: 0x8296 - 0x82d5
int64_t function_8296(int64_t a1) {
    int64_t v1 = a1 + (int64_t)&g79; // 0x82bb
    int64_t * v2 = (int64_t *)v1; // 0x82bb
    int64_t result = *v2; // 0x82bb
    if (result == v1) {
        // 0x82d2
        return result;
    }
    function_84c1(result);
    int64_t result2 = *v2; // 0x82bb
    while (result2 != v1) {
        // 0x82a4
        function_84c1(result2);
        result2 = *v2;
    }
    // 0x82d2
    return result2;
}

// Address range: 0x82d5 - 0x84c1
int64_t function_82d5(int64_t a1, int64_t a2, int32_t a3) {
    int64_t v1 = __readfsqword(40); // 0x82e9
    int64_t * v2 = (int64_t *)(a2 + 48); // 0x82fc
    int64_t v3 = *v2; // 0x82fc
    int32_t v4 = function_1c25e(2, 2, 1); // 0x8318
    int32_t * v5 = (int32_t *)(a1 + 16); // 0x831e
    *v5 = v4;
    int64_t v6 = 0xffffffff; // 0x832b
    if (v4 != -1) {
        // 0x8337
        *(int64_t *)(a1 + 48) = a2;
        *(int32_t *)(a1 + 76) = *(int32_t *)(v3 + 16);
        *(int32_t *)(a1 + 204) = *(int32_t *)(v3 + 12);
        *(char *)(a1 + 328) = *(char *)(v3 + 1);
        *(char *)(a1 + 330) = 1;
        *(int32_t *)(a1 + 332) = 4;
        *(int32_t *)(a1 + 344) = *(int32_t *)&g60 + 0x3a980;
        int16_t dest_addr = 2; // bp-56, 0x83a6
        function_ab4c(a1, *(int64_t *)(a1 + 40) + (int64_t)&g79);
        int32_t v7 = *(int32_t *)(a2 + 56); // 0x83d8
        int64_t v8 = *v2; // 0x83e5
        int32_t sock = *v5; // 0x83f6
        int32_t v9 = sendto(sock, (int64_t *)(v8 + (int64_t)a3), v7 - a3, 0, (struct sockaddr *)&dest_addr, 16); // 0x840d
        v6 = 0;
        if (v9 == -1) {
            // 0x841c
            if ((*(int32_t *)&g58 & 2) != 0) {
                char * err_str = strerror(*__errno_location()); // 0x8435
                uint32_t v10 = *__errno_location(); // 0x8442
                function_3080("Slirp", 128, "icmp_input icmp sendto tx errno = %d-%s", (int64_t)v10, (int64_t)err_str, 16);
            }
            int32_t err_num = *__errno_location(); // 0x846b
            function_8b39(a2, 3, 0, 0, (int64_t)strerror(err_num));
            function_84c1(a1);
            v6 = 0;
        }
    }
    int64_t result = v6; // 0x84b3
    if (v1 != __readfsqword(40)) {
        // 0x84b5
        __stack_chk_fail();
        result = &g91;
    }
    // 0x84ba
    return result;
}

// Address range: 0x84c1 - 0x851a
int64_t function_84c1(int64_t a1) {
    // 0x84c1
    close(*(int32_t *)(a1 + 16));
    return function_f77a(a1);
}

// Address range: 0x851a - 0x8b39
int64_t function_851a(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x8535
    int64_t * v2 = (int64_t *)(a1 + 48); // 0x854b
    uint16_t v3 = *(int16_t *)(*v2 + 2); // 0x854f
    int64_t v4; // 0x851a
    int64_t v5; // 0x851a
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x859b
        int64_t v6; // 0x851a
        function_3080("Slirp", 128, "icmp_input...", v6, v5, v4);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x85d2
            function_3080("Slirp", 128, " m = %p", a1, v5, v4);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x85e2
                function_3080("Slirp", 128, " m_len = %d", (int64_t)*(int32_t *)(a1 + 56), v5, v4);
            }
        }
    }
    if (v3 > 7) {
        int64_t v7 = 0x100000000 * a2 / 0x100000000; // 0x852f
        int32_t * v8 = (int32_t *)(a1 + 56); // 0x8636
        int32_t v9 = v7; // 0x8639
        *v8 = *v8 - v9;
        int64_t v10 = *v2 + v7; // 0x865e
        *v2 = v10;
        if ((int32_t)function_44c3(a1, (int64_t)v3) != 0) {
            // 0x861b
            function_a4f0(a1);
            goto lab_0x8b19;
        } else {
            // 0x8692
            *v8 = *v8 + v9;
            *v2 = *v2 - v7;
            char * v11 = (char *)v10;
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x86e3
                function_3080("Slirp", 128, " icmp_type = %d", (int64_t)*v11, v5, v4);
            }
            int64_t v12 = (int64_t)*v11 + 0xfffffffd; // 0x8712
            if ((int32_t)v12 < 15) {
                int32_t v13 = *(int32_t *)((4 * v12 & 0x3fffffffc) + (int64_t)&g15); // 0x872f
                return (int64_t)v13 + (int64_t)&g15;
            }
            // 0x8b03
            function_a4f0(a1);
            goto lab_0x8b19;
        }
    } else {
        // 0x861b
        function_a4f0(a1);
        goto lab_0x8b19;
    }
  lab_0x8b19:;
    int64_t result = 0; // 0x8b26
    if (v1 != __readfsqword(40)) {
        // 0x8b28
        __stack_chk_fail();
        result = &g91;
    }
    // 0x8b2d
    return result;
}

// Address range: 0x8b39 - 0x8f3f
int64_t function_8b39(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    struct in_addr in; // 0x8c41
    struct in_addr in2; // 0x8c5f
    int64_t v1 = __readfsqword(40); // 0x8b61
    int64_t v2; // 0x8b39
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x8b9d
        function_3080("Slirp", 128, "icmp_send_error...", a4, a5, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x8bd1
            function_3080("Slirp", 128, " msrc = %p", a1, a5, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x8be1
                function_3080("Slirp", 128, " msrc_len = %d", (int64_t)*(int32_t *)(a1 + 56), a5, v2);
            }
        }
    }
    char v3 = a2; // 0x8c07
    unsigned char v4; // 0x8b39
    int64_t * v5; // 0x8c26
    int64_t v6; // 0x8c26
    if (a1 == 0 || v3 != 3 == (v3 != 11)) {
        goto lab_0x8f1f;
    } else {
        // 0x8c22
        v5 = (int64_t *)(a1 + 48);
        v6 = *v5;
        if ((*(int32_t *)&g58 & 2) != 0) {
            // 0x8c3a


            in.s_addr = *(int32_t *)(v6 + 12);
            int64_t str; // bp-104, 0x8b39
            strcpy((char *)&str, inet_ntoa(in));
            in2.s_addr = *(int32_t *)(v6 + 16);


            int64_t str2; // bp-72, 0x8b39
            strcpy((char *)&str2, inet_ntoa(in2));
            if ((*(int32_t *)&g58 & 2) != 0) {
                // 0x8c86
                function_3080("Slirp", 128, " %.16s to %.16s", (int64_t)&str, (int64_t)&str2, v2);
            }
        }
        uint16_t v7 = *(int16_t *)(v6 + 6); // 0x8cb1
        if (((int32_t)v7 & (int32_t)&g35) != 0) {
            goto lab_0x8f1f;
        } else {
            // 0x8cc7
            if ((htonl(0xfffffff) & *(int32_t *)(v6 + 12)) == 0) {
                goto lab_0x8f1f;
            } else {
                // 0x8ce0
                v4 = 4 * *(char *)v6 & 60;
                if (*(char *)(v6 + 9) != 1) {
                    goto lab_0x8d3f;
                } else {
                    unsigned char v8 = *(char *)(v6 + (int64_t)v4); // 0x8d0e
                    if (v8 < 19) {
                        int32_t v9 = *(int32_t *)(4 * (int64_t)v8 + (int64_t)&g14); // 0x8d34
                        if (v9 != 0) {
                            goto lab_0x8f1f;
                        } else {
                            goto lab_0x8d3f;
                        }
                    } else {
                        goto lab_0x8f1f;
                    }
                }
            }
        }
    }
  lab_0x8f1f:;
    int64_t result = 0; // 0x8f2d
    if (v1 != __readfsqword(40)) {
        // 0x8f2f
        __stack_chk_fail();
        result = &g91;
    }
    // 0x8f34
    return result;
  lab_0x8d3f:;
    int64_t v10 = function_a39a(*(int64_t *)(a1 + 64)); // 0x8d4a
    if (v10 != 0) {
        int32_t * v11 = (int32_t *)(a1 + 56); // 0x8d5f
        int32_t v12 = *v11; // 0x8d5f
        int32_t v13 = v12 + (int32_t)&g63; // 0x8d62
        int32_t v14 = v12; // 0x8d70
        if ((int64_t)v13 > (int64_t)*(int32_t *)(v10 + 36)) {
            // 0x8d72
            function_a70b(v10, (int64_t)v13);
            v14 = *v11;
        }
        uint32_t v15 = (int32_t)*(int16_t *)(v6 + 2); // 0x8cfa
        int64_t * v16 = (int64_t *)(v10 + 48); // 0x8d91
        memcpy((int64_t *)*v16, (int64_t *)*v5, v14);
        int32_t * v17 = (int32_t *)(v10 + 56); // 0x8da7
        *v17 = *v11;
        int64_t v18 = *v16;
        *v16 = v18 + 20;
        *v17 = *v17 - 20;
        int64_t v19 = *v16; // 0x8dcc
        int32_t v20 = v15 < (int32_t)&g48 ? v15 : (int32_t)&g48;
        int32_t v21 = (int32_t)a4 == 0 ? v20 : (int32_t)(v4 + 8);
        *v17 = v21 + 8;
        *(char *)v19 = v3;
        *(char *)(v19 + 1) = (char)a3;
        *(int16_t *)(v19 + 4) = 0;
        *(int16_t *)(v19 + 6) = 0;
        memcpy((int64_t *)(v19 + 8), (int64_t *)*v5, v21);
        int16_t * host_short = (int16_t *)(v19 + 10); // 0x8e35
        *host_short = htons(*host_short);
        int16_t * host_short2 = (int16_t *)(v19 + 12); // 0x8e49
        *host_short2 = htons(*host_short2);
        int16_t * host_short3 = (int16_t *)(v19 + 14); // 0x8e5d
        *host_short3 = htons(*host_short3);
        int16_t * v22 = (int16_t *)(v19 + 2); // 0x8e71
        *v22 = 0;
        *v22 = (int16_t)function_44c3(v10, (int64_t)*v17);
        *v16 = *v16 - 20;
        *v17 = *v17 + 20;
        char * v23 = (char *)v18; // 0x8eb6
        *v23 = *v23 & -16 | 5;
        *(int16_t *)(v18 + 2) = (int16_t)*v17;
        char * v24 = (char *)(v18 + 1); // 0x8ecd
        *v24 = *v24 & 30 | -64;
        *(char *)(v18 + 8) = -1;
        *(char *)(v18 + 9) = 1;
        int32_t * v25 = (int32_t *)(v18 + 12); // 0x8eea
        *(int32_t *)(v18 + 16) = *v25;
        *v25 = *(int32_t *)(*(int64_t *)(v10 + 64) + 20);
        function_9e96(0, v10);
    }
    goto lab_0x8f1f;
}

// Address range: 0x8f3f - 0x9096
int64_t function_8f3f(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 48); // 0x8f52
    int64_t v2 = *v1; // 0x8f52
    char * v3 = (char *)v2; // 0x8f56
    unsigned char v4 = 4 * *v3 & 60;
    int32_t v5 = v4; // 0x8f5f
    uint32_t v6 = v5 - 20; // 0x8f68
    int64_t v7 = v4; // 0x8f79
    int64_t v8 = v2 + v7; // 0x8f7b
    *v1 = v8;
    int32_t * v9 = (int32_t *)(a1 + 56); // 0x8f8a
    *v9 = *v9 - v5;
    int64_t v10 = *v1; // 0x8f9d
    *(char *)v10 = 0;
    int16_t * v11 = (int16_t *)(v10 + 2); // 0x8fa6
    *v11 = 0;
    int16_t * v12 = (int16_t *)(v2 + 2); // 0x8fae
    *v11 = (int16_t)function_44c3(a1, (int64_t)((int32_t)*v12 - v5));
    *v1 = *v1 - v7;
    int32_t v13 = *v9; // 0x8fee
    *v9 = v13 + v5;
    if (v6 >= 1) {
        // 0x9003
        memmove((int64_t *)(v2 + 20), (int64_t *)v8, v13);
        *v3 = *v3 & -16 | 5;
        *v12 = *v12 - (int16_t)v6;
        *v9 = *v9 - v6;
    }
    // 0x9065
    *(char *)(v2 + 8) = -1;
    int32_t * v14 = (int32_t *)(v2 + 16); // 0x9069
    int32_t * v15 = (int32_t *)(v2 + 12); // 0x906f
    *v14 = *v15;
    *v15 = *v14;
    return function_9e96(0, a1);
}

// Address range: 0x9096 - 0x929d
int64_t function_9096(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 48); // 0x90a7
    int64_t v2 = *v1; // 0x90a7
    int64_t * v3 = (int64_t *)(v2 + 48); // 0x90b3
    int64_t v4 = *v3;
    unsigned char v5 = 4 * *(char *)v4 & 60;
    int32_t v6 = v5; // 0x90c8
    int64_t v7 = v5; // 0x90d9
    *v3 = v4 + v7;
    int32_t * v8 = (int32_t *)(v2 + 56); // 0x90ea
    *v8 = *v8 - v6;
    int64_t buf = *v3; // 0x90fd
    int16_t * v9 = (int16_t *)(buf + 4); // 0x9109
    int64_t v10; // 0x9096
    if (*(int32_t *)(v2 + 32) % 2 == 0) {
        // 0x914b
        v10 = v2 + 96 + (int64_t)*(int32_t *)(v2 + 36);
    } else {
        // 0x9121
        v10 = *(int64_t *)(v2 + 88) + (int64_t)*(int32_t *)(v2 + 36);
    }
    int32_t sock = *(int32_t *)(a1 + 16); // 0x9177
    int32_t v11 = recv(sock, (int64_t *)buf, (int32_t)(v10 - buf), 0); // 0x9185
    *v3 = *v3 - v7;
    *v8 = *v8 + v6;
    if (v11 != -1 == (v11 != 0)) {
        // 0x926d
        function_8f3f(*v1);
        *v1 = 0;
        // 0x9289
        return function_84c1(a1);
    }
    int32_t v12 = *__errno_location(); // 0x91de
    if ((*(int32_t *)&g58 & 2) != 0) {
        char * err_str = strerror(*__errno_location()); // 0x9208
        uint32_t v13 = *__errno_location(); // 0x9215
        int64_t v14; // 0x9096
        function_3080("Slirp", 128, " udp icmp rx errno = %d-%s", (int64_t)v13, (int64_t)err_str, v14);
    }
    char * err_str2 = strerror(*__errno_location()); // 0x9242
    function_8b39(*v1, 3, (int64_t)(v12 != 101), 0, (int64_t)err_str2);
    // 0x9289
    return function_84c1(a1);
}

// Address range: 0x929d - 0x92fc
int64_t function_929d(int64_t a1) {
    int64_t v1 = a1 + 248; // 0x92ad
    *(int64_t *)(a1 + 256) = v1;
    *(int64_t *)v1 = v1;
    function_1aa94(a1);
    function_164fc(a1);
    return function_8249(a1);
}

// Address range: 0x92fc - 0x932f
int64_t function_92fc(int64_t a1) {
    // 0x92fc
    function_1aae1(a1);
    function_16557(a1);
    return function_8296(a1);
}

// Address range: 0x932f - 0x96e7
int64_t function_932f(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 64); // 0x9342
    if (*(char *)(v1 + 9) != 1) {
        // 0x96de
        return function_a4f0(a1);
    }
    // 0x935d
    int32_t * v2; // 0x932f
    if (*(int32_t *)&g58 % 2 == 0) {
        // 0x93be
        v2 = (int32_t *)(a1 + 56);
        goto lab_0x93f4;
    } else {
        // 0x938a
        int64_t v3; // 0x932f
        int64_t v4; // 0x932f
        int64_t v5; // 0x932f
        function_3080("Slirp", 128, "ip_input...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 == 0) {
            // 0x93be
            v2 = (int32_t *)(a1 + 56);
            goto lab_0x93f4;
        } else {
            // 0x93be
            function_3080("Slirp", 128, " m = %p", a1, v4, v3);
            if (*(int32_t *)&g58 % 2 == 0) {
                // 0x93be
                v2 = (int32_t *)(a1 + 56);
                goto lab_0x93f4;
            } else {
                int32_t * v6 = (int32_t *)(a1 + 56);
                function_3080("Slirp", 128, " m_len = %d", (int64_t)*v6, v4, v3);
                v2 = v6;
                goto lab_0x93f4;
            }
        }
    }
  lab_0x93f4:;
    uint32_t v7 = *v2; // 0x93f8
    if (v7 < 20) {
        // 0x96de
        return function_a4f0(a1);
    }
    int64_t v8 = *(int64_t *)(a1 + 48); // 0x9408
    char v9 = *(char *)v8; // 0x940c
    if ((v9 & -16) != 64) {
        // 0x96de
        return function_a4f0(a1);
    }
    unsigned char v10 = 4 * v9 & 60;
    if (v10 < 19) {
        // 0x96de
        return function_a4f0(a1);
    }
    uint64_t v11 = (int64_t)v10; // 0x943f
    if (v11 > (int64_t)v7 || (int32_t)function_44c3(a1, v11) != 0) {
        // 0x96de
        return function_a4f0(a1);
    }
    int16_t * net_short = (int16_t *)(v8 + 2); // 0x945e
    uint16_t v12 = ntohs(*net_short); // 0x9467
    *net_short = v12;
    if (v11 > (int64_t)v12) {
        // 0x96de
        return function_a4f0(a1);
    }
    int16_t * net_short2 = (int16_t *)(v8 + 4); // 0x9480
    *net_short2 = ntohs(*net_short2);
    int16_t * net_short3 = (int16_t *)(v8 + 6); // 0x9492
    *net_short3 = ntohs(*net_short3);
    uint32_t v13 = *v2; // 0x94a8
    uint64_t v14 = (int64_t)v13; // 0x94a8
    uint16_t v15 = *net_short; // 0x94ab
    uint64_t v16 = (int64_t)v15; // 0x94af
    if (v14 < v16) {
        // 0x96de
        return function_a4f0(a1);
    }
    if (v14 > v16) {
        // 0x94cc
        function_a875(a1, (int64_t)((int32_t)v15 - v13));
    }
    // 0x94ea
    if (*(char *)(v8 + 8) == 0) {
        // 0x94f2
        function_8b39(a1, 11, 0, 0, (int64_t)"ttl");
        // 0x96de
        return function_a4f0(a1);
    }
    // 0x9519
    int64_t v17; // 0x932f
    int64_t v18; // 0x932f
    int64_t v19; // 0x932f
    if ((*net_short3 & -0x4001) == 0) {
        // 0x9646
        *net_short = *net_short - (int16_t)v10;
        v18 = v8;
        v19 = a1;
        goto lab_0x9653;
    } else {
        int64_t v20 = v1 + 248; // 0x952f
        int64_t v21 = *(int64_t *)v20;
        v17 = 0;
        if (v21 != v20) {
            // 0x953c
            if (*net_short2 == *(int16_t *)(v21 + 18)) {
                // 0x955e
                if (*(int32_t *)(v8 + 12) == *(int32_t *)(v21 + 20)) {
                    // 0x956a
                    if (*(int32_t *)(v8 + 16) == *(int32_t *)(v21 + 24)) {
                        // 0x9576
                        if (*(char *)(v8 + 9) == *(char *)(v21 + 17)) {
                            // 0x9576
                            v17 = v21 - 16;
                            goto lab_0x95a8;
                        }
                    }
                }
            }
            int64_t v22 = *(int64_t *)v21;
            v17 = 0;
            while (v22 != v20) {
                int64_t v23 = v22;
                if (*net_short2 == *(int16_t *)(v23 + 18)) {
                    // 0x955e
                    if (*(int32_t *)(v8 + 12) == *(int32_t *)(v23 + 20)) {
                        // 0x956a
                        if (*(int32_t *)(v8 + 16) == *(int32_t *)(v23 + 24)) {
                            // 0x9576
                            if (*(char *)(v8 + 9) == *(char *)(v23 + 17)) {
                                // 0x9576
                                v17 = v23 - 16;
                                goto lab_0x95a8;
                            }
                        }
                    }
                }
                // 0x9584
                v22 = *(int64_t *)v23;
                v17 = 0;
            }
        }
        goto lab_0x95a8;
    }
  lab_0x9653:;
    // 0x9653
    int64_t result; // 0x932f
    switch (*(char *)(v18 + 9)) {
        case 6: {
            // 0x966b
            result = function_12cfb(v19, v11, 0, 2);
            // break -> 0x96de
            break;
        }
        case 17: {
            // 0x9686
            result = function_1ab20(v19, v11);
            // break -> 0x96de
            break;
        }
        case 1: {
            // 0x9699
            result = function_851a(v19, v11);
            // break -> 0x96de
            break;
        }
        default: {
            // 0x96ac
            result = function_a4f0(v19);
            // break -> 0x96de
            break;
        }
    }
    // 0x96de
    return result;
  lab_0x95a8:
    // 0x95a8
    *net_short = *net_short - (int16_t)v10;
    uint16_t v24 = *net_short3; // 0x95b5
    char * v25 = (char *)(v8 + 1);
    char v26 = *v25;
    char v27 = ((int32_t)v24 & (int32_t)&g37) == 0 ? v26 & -2 : v26 | 1;
    *v25 = v27;
    int16_t v28 = 8 * *net_short3; // 0x95df
    *net_short3 = v28;
    if (v28 == 0 == *v25 % 2 == 0) {
        // 0x9630
        v18 = v8;
        v19 = a1;
        if (v17 != 0) {
            // 0x9635
            function_9c34(v1, v17);
            v18 = v8;
            v19 = a1;
        }
    } else {
        int64_t v29 = function_96e7(v1, v8, v17); // 0x960a
        if (v29 == 0) {
            // 0x96de
            return 0;
        }
        int64_t v30 = function_a9b5(v1, v29); // 0x9625
        v18 = v29;
        v19 = v30;
    }
    goto lab_0x9653;
}

// Address range: 0x96e7 - 0x9c34
int64_t function_96e7(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = function_a9b5(a1, a2); // 0x970c
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x9754
        int64_t v2; // 0x96e7
        int64_t v3; // 0x96e7
        int64_t v4; // 0x96e7
        function_3080("Slirp", 128, "ip_reass...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x9788
            function_3080("Slirp", 128, " ip = %p", a2, v3, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x97bc
                function_3080("Slirp", 128, " fp = %p", a3, v3, v2);
                if (*(int32_t *)&g58 % 2 != 0) {
                    // 0x97cc
                    function_3080("Slirp", 128, " m = %p", v1, v3, v2);
                }
            }
        }
    }
    // 0x97ec
    int64_t v5; // 0x96e7
    unsigned char v6 = 4 * (char)v5 & 60;
    int64_t * v7 = (int64_t *)(v1 + 48); // 0x97ec
    int64_t v8 = *v7; // 0x97ec
    *v7 = v8 + (int64_t)v6;
    int32_t * v9 = (int32_t *)(v1 + 56); // 0x97fe
    *v9 = *v9 - (int32_t)v6;
    int64_t v10; // 0x96e7
    int64_t v11; // 0x96e7
    if (a3 != 0) {
        int64_t v12 = v8; // 0x98e6
        if (v8 != a3) {
            int64_t v13 = v8; // 0x98dc
            v12 = v13;
            while (*(int16_t *)(v13 + 22) <= *(int16_t *)(a2 + 6)) {
                // 0x98dc
                v13 = *(int64_t *)v13;
                v12 = v13;
                if (v13 == a3) {
                    // break -> 0x98eb
                    break;
                }
                v12 = v13;
            }
        }
        int64_t v14 = *(int64_t *)(v12 + 8); // 0x98eb
        if (v14 != a3) {
            uint16_t v15 = *(int16_t *)(v14 + 22); // 0x9908
            uint16_t v16 = *(int16_t *)(v14 + 18); // 0x9913
            int16_t * v17 = (int16_t *)(a2 + 6); // 0x9920
            uint32_t v18 = (int32_t)v16 + (int32_t)v15 - (int32_t)*v17; // 0x9927
            if (v18 >= 1) {
                int16_t * v19 = (int16_t *)(a2 + 2); // 0x993c
                if ((int64_t)v18 >= (int64_t)*v19) {
                    // 0x9c1e
                    function_a4f0(v1);
                    // 0x9c2b
                    return 0;
                }
                // 0x994c
                function_a875(function_a9b5(a1, a2), (int64_t)v18);
                int16_t v20 = v18;
                *v17 = *v17 + v20;
                *v19 = *v19 - v20;
            }
        }
        // 0x9a37
        v11 = a3;
        v10 = a3;
        if (v12 != a3) {
            int64_t v21 = v12;
            uint16_t v22 = *(int16_t *)(a2 + 6); // 0x9a44
            uint16_t v23 = *(int16_t *)(a2 + 2); // 0x9a4f
            int16_t * v24 = (int16_t *)(v21 + 22);
            uint16_t v25 = *v24; // 0x9a58
            v11 = a3;
            v10 = v21;
            while ((int64_t)v23 + (int64_t)v22 > (int64_t)v25) {
                int32_t v26 = (int32_t)v23 + (int32_t)v22 - (int32_t)v25; // 0x99bf
                int16_t * v27 = (int16_t *)(v21 + 18);
                uint16_t v28 = *v27; // 0x99c6
                if ((int64_t)v26 < (int64_t)v28) {
                    int16_t v29 = v26;
                    *v27 = v28 - v29;
                    *v24 = *v24 + v29;
                    function_a875(function_a9b5(a1, v21), (int64_t)v26);
                    v11 = a3;
                    v10 = v21;
                    goto lab_0x9a68;
                }
                int64_t v30 = *(int64_t *)v21; // 0x9a0d
                int64_t * v31 = (int64_t *)(v30 + 8); // 0x9a10
                function_a4f0(function_a9b5(a1, *v31));
                function_9d39(*v31);
                v11 = a3;
                v10 = a3;
                if (v30 == a3) {
                    // break -> 0x9a68
                    break;
                }
                v21 = v30;
                v22 = *(int16_t *)(a2 + 6);
                v23 = *(int16_t *)(a2 + 2);
                v24 = (int16_t *)(v21 + 22);
                v25 = *v24;
                v11 = a3;
                v10 = v21;
            }
        }
    } else {
        int64_t v32 = function_a39a(a1); // 0x981d
        if (v32 == 0) {
            // 0x9c1e
            function_a4f0(v1);
            // 0x9c2b
            return 0;
        }
        int64_t v33 = *(int64_t *)(v32 + 48); // 0x9835
        function_ab4c(v33 + 16, a1 + 248);
        *(char *)(v33 + 32) = 60;
        *(char *)(v33 + 33) = *(char *)(a2 + 9);
        *(int16_t *)(v33 + 34) = *(int16_t *)(a2 + 4);
        *(int64_t *)(v33 + 8) = v33;
        *(int64_t *)v33 = v33;
        *(int32_t *)(v33 + 36) = *(int32_t *)(a2 + 12);
        *(int32_t *)(v33 + 40) = *(int32_t *)(a2 + 16);
        v11 = v33;
        v10 = v33;
    }
    goto lab_0x9a68;
  lab_0x9a68:
    // 0x9a68
    function_9cb3(a2 - 16, *(int64_t *)(v10 + 8));
    int64_t * v34 = (int64_t *)v11;
    int64_t v35 = *v34;
    int64_t v36 = v35; // 0x9ab9
    int32_t v37 = 0; // 0x9ab9
    int16_t v38 = 0; // 0x9ab9
    int64_t v39 = v35; // 0x9ab9
    if (v35 != v11) {
        while (v37 == (int32_t)*(int16_t *)(v36 + 22)) {
            int32_t v40 = v37 + (int32_t)*(int16_t *)(v36 + 18); // 0x9aac
            int64_t v41 = *(int64_t *)v36;
            v36 = v41;
            v37 = v40;
            if (v41 == v11) {
                // 0x9ab2
                v38 = v40;
                v39 = v41;
                goto lab_0x9abb;
            }
        }
        // 0x9c2b
        return 0;
    }
    goto lab_0x9abb;
  lab_0x9abb:
    // 0x9abb
    if (*(char *)(*(int64_t *)(v39 + 8) + 17) % 2 != 0) {
        // 0x9c2b
        return 0;
    }
    int64_t v42 = function_a9b5(a1, v35); // 0x9ae8
    int32_t * v43 = (int32_t *)(v42 + 32); // 0x9af0
    int64_t v44 = *(int64_t *)v35; // 0x9afb
    if (v44 != v11) {
        int64_t v45 = function_a9b5(a1, v44); // 0x9b0a
        int64_t v46 = *(int64_t *)v44; // 0x9b13
        function_a60d(v42, v45);
        int64_t v47 = v46; // 0x9b2c
        while (v46 != v11) {
            // 0x9b00
            v45 = function_a9b5(a1, v47);
            v46 = *(int64_t *)v47;
            function_a60d(v42, v45);
            v47 = v46;
        }
    }
    int64_t v48 = *v34; // 0x9b32
    int64_t v49 = v48; // 0x9b39
    if (*v43 % 2 == 0) {
        // 0x9b3b
        v49 = v48;
        if (*v43 % 2 != 0) {
            // 0x9b47
            v49 = *(int64_t *)(v42 + 88) + 0x100000000 * (0xffffffa0 - v42 + v48) / 0x100000000;
        }
    }
    int64_t result = v49 + 16; // 0x9b66
    *(int16_t *)(v49 + 18) = v38;
    char * v50 = (char *)(v49 + 17); // 0x9b7f
    *v50 = *v50 & -2;
    *(int32_t *)(v49 + 28) = *(int32_t *)(v11 + 36);
    *(int32_t *)(v49 + 32) = *(int32_t *)(v11 + 40);
    function_ab7f(v11 + 16);
    function_a4f0(function_a9b5(a1, v11));
    int32_t * v51 = (int32_t *)(v42 + 56); // 0x9bd6
    char * v52 = (char *)result; // 0x9bdf
    *v51 = *v51 + (int32_t)(4 * *v52 & 60);
    int64_t * v53 = (int64_t *)(v42 + 48); // 0x9bf2
    *v53 = *v53 - (int64_t)(4 * *v52 & 60);
    // 0x9c2b
    return result;
}

// Address range: 0x9c34 - 0x9cb3
int64_t function_9c34(int64_t a1, int64_t a2) {
    // 0x9c7e
    function_ab7f(a2 + 16);
    return function_a4f0(function_a9b5(a1, a2));
}

// Address range: 0x9cb3 - 0x9d39
int64_t function_9cb3(int64_t a1, int64_t a2) {
    int64_t result = a2; // 0x9cce
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x9ced
        int64_t v1; // 0x9cb3
        int64_t v2; // 0x9cb3
        int64_t v3; // 0x9cb3
        function_3080("Slirp", 128, "ip_enq...", v3, v2, v1);
        result = 128;
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x9cfd
            function_3080("Slirp", 128, " prev = %p", a2, v2, v1);
            result = 128;
        }
    }
    // 0x9d1d
    *(int64_t *)(a1 + 8) = a2;
    *(int64_t *)a1 = result;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)a2 = a1;
    return result;
}

// Address range: 0x9d39 - 0x9d58
int64_t function_9d39(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x9d40
    *(int64_t *)*v1 = a1;
    return *v1;
}

// Address range: 0x9d58 - 0x9e0e
int64_t function_9d58(int64_t a1) {
    // 0x9d58
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x9d74
        int64_t v1; // 0x9d58
        int64_t v2; // 0x9d58
        int64_t v3; // 0x9d58
        function_3080("Slirp", 128, "ip_slowtimo...", v3, v2, v1);
    }
    int64_t result = a1 + 248; // 0x9d95
    int64_t v4 = *(int64_t *)result; // 0x9d95
    if (v4 == 0) {
        // 0x9e0c
        return 0;
    }
    // 0x9df9
    if (v4 == result) {
        // 0x9e0c
        return result;
    }
    int64_t v5 = *(int64_t *)v4; // 0x9dc1
    char * v6 = (char *)(v4 + 16); // 0x9dcc
    char v7 = *v6 - 1; // 0x9dd0
    *v6 = v7;
    if (v7 == 0) {
        // 0x9de6
        function_9c34(a1, v4 - 16);
    }
    while (v5 != result) {
        int64_t v8 = v5;
        v5 = *(int64_t *)v8;
        v6 = (char *)(v8 + 16);
        v7 = *v6 - 1;
        *v6 = v7;
        if (v7 == 0) {
            // 0x9de6
            function_9c34(a1, v8 - 16);
        }
    }
    // 0x9e0c
    return result;
}

// Address range: 0x9e0e - 0x9e96
int64_t function_9e0e(int64_t a1, int64_t a2) {
    int64_t result = *(int64_t *)(a1 + 48); // 0x9e22
    char * v1 = (char *)result; // 0x9e2e
    int32_t v2 = (int32_t)(4 * *v1 & 60); // 0x9e37
    int32_t v3 = v2 - 20; // 0x9e3a
    int64_t v4 = result + 20; // 0x9e44
    int32_t * v5 = (int32_t *)(a1 + 56); // 0x9e48
    memcpy((int64_t *)v4, (int64_t *)(v4 + (int64_t)v3), *v5 - v2);
    *v5 = *v5 - v3;
    *v1 = *v1 & -16 | 5;
    return result;
}

// Address range: 0x9e96 - 0xa28a
int64_t function_9e96(int64_t a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a2 + 64); // 0x9eb1
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x9ef7
        int64_t v2; // 0x9e96
        int64_t v3; // 0x9e96
        int64_t v4; // 0x9e96
        function_3080("Slirp", 128, "ip_output...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x9f2b
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x9f3b
                function_3080("Slirp", 128, " m0 = %p", a2, v3, v2);
            }
        }
    }
    int64_t v5 = *(int64_t *)(a2 + 48); // 0x9f5f
    char * v6 = (char *)v5; // 0x9f64
    *v6 = *v6 % 16 | 64;
    int16_t * host_short3 = (int16_t *)(v5 + 6); // 0x9f6f
    *host_short3 = *host_short3 & 0x4000;
    int16_t * v7 = (int16_t *)(v1 + 280); // 0x9f7f
    int16_t host_short = *v7; // 0x9f7f
    *v7 = host_short + 1;
    *(int16_t *)(v5 + 4) = htons(host_short);
    *v6 = *v6 & -16 | 5;
    int16_t * v8 = (int16_t *)(v5 + 2); // 0x9fba
    uint16_t host_short2 = *v8; // 0x9fba
    int64_t v9 = host_short2;
    uint32_t v10 = *(int32_t *)(v1 + 136); // 0x9fc5
    if (v9 <= (int64_t)v10) {
        // 0x9fcf
        *v8 = htons(host_short2);
        *host_short3 = htons(*host_short3);
        int16_t * v11 = (int16_t *)(v5 + 10); // 0x9ff3
        *v11 = 0;
        *v11 = (int16_t)function_44c3(a2, 20);
        function_5ece(a1, a2);
        // 0xa26a
        return 0;
    }
    // 0xa01c
    if ((*host_short3 & 0x4000) != 0) {
        // 0xa26f
        function_a4f0(a2);
        // 0xa26a
        return -1;
    }
    int32_t v12 = v10 - 20 & -8; // 0xa045
    if (v12 <= 7) {
        // 0xa26f
        function_a4f0(a2);
        // 0xa26a
        return -1;
    }
    int32_t v13 = v12 + 20; // 0xa07a
    int16_t v14 = host_short2; // 0xa1c6
    int32_t result; // 0x9e96
    if ((int64_t)v13 < v9) {
        int64_t v15 = a2; // 0x9e96
        int32_t v16 = v13; // 0xa1b9
        int32_t v17 = v12;
        int64_t v18 = function_a39a(v1); // 0xa08c
        result = -1;
        while (v18 != 0) {
            int32_t v19 = v17;
            int32_t v20 = v16;
            int64_t * v21 = (int64_t *)(v18 + 48); // 0xa0a5
            int64_t v22 = *v21; // 0xa0a5
            int64_t v23 = v22 + 16; // 0xa0aa
            *v21 = v23;
            *(int64_t *)v23 = *(int64_t *)v5;
            *(int64_t *)(v22 + 24) = *(int64_t *)(v5 + 8);
            *(int32_t *)(v22 + 32) = *(int32_t *)(v5 + 16);
            *(int32_t *)(v18 + 56) = 20;
            int16_t v24 = (*host_short3 & -0x2001) + (int16_t)((v20 + 0x7ffec) / 8); // 0xa0ea
            int16_t * host_short4 = (int16_t *)(v22 + 22); // 0xa0ea
            *host_short4 = v24;
            int16_t v25 = v24; // 0xa0fd
            if (((int32_t)*host_short3 & (int32_t)&g37) != 0) {
                int16_t v26 = v24 | 0x2000;
                *host_short4 = v26;
                v25 = v26;
            }
            uint16_t v27 = *v8; // 0xa114
            int32_t v28; // 0x9e96
            if ((int64_t)(v19 + v20) < (int64_t)v27) {
                // 0xa12e
                *host_short4 = v25 | 0x2000;
                v28 = v19;
            } else {
                // 0xa11f
                v28 = (int32_t)v27 - v20;
            }
            // 0xa13b
            v17 = v28;
            *(int16_t *)(v22 + 18) = htons((int16_t)v17 + 20);
            result = -1;
            if ((int32_t)function_a8d5(v18, a2, v20, v17) < 0) {
                // break -> 0xa229
                break;
            }
            // 0xa179
            *host_short4 = htons(*host_short4);
            int16_t * v29 = (int16_t *)(v22 + 26); // 0xa18d
            *v29 = 0;
            *v29 = (int16_t)function_44c3(v18, 20);
            *(int64_t *)(v15 + 16) = v18;
            v16 = v17 + v20;
            uint16_t v30 = *v8; // 0xa1bc
            v15 = v18;
            v14 = v30;
            if ((int64_t)v16 >= (int64_t)v30) {
                goto lab_0xa1cc;
            }
            v18 = function_a39a(v1);
            result = -1;
        }
    } else {
      lab_0xa1cc:
        // 0xa1cc
        function_a875(a2, (int64_t)(v13 - (int32_t)v14));
        *v8 = htons((int16_t)*(int32_t *)(a2 + 56));
        *host_short3 = htons(*host_short3 | 0x2000);
        int16_t * v31 = (int16_t *)(v5 + 10); // 0xa214
        *v31 = 0;
        *v31 = (int16_t)function_44c3(a2, 20);
        result = 0;
    }
    // 0xa229
    if (a2 == 0) {
        // 0xa26a
        return result;
    }
    int64_t * v32 = (int64_t *)(a2 + 16); // 0xa22f
    int64_t v33 = *v32; // 0xa22f
    *v32 = 0;
    if (result != 0) {
        // 0xa258
        function_a4f0(a2);
    } else {
        // 0xa247
        function_5ece(a1, a2);
    }
    while (v33 != 0) {
        int64_t v34 = v33;
        v32 = (int64_t *)(v34 + 16);
        v33 = *v32;
        *v32 = 0;
        if (result != 0) {
            // 0xa258
            function_a4f0(v34);
        } else {
            // 0xa247
            function_5ece(a1, v34);
        }
    }
    // 0xa26a
    return result;
}

// Address range: 0xa28a - 0xa2ed
int64_t function_a28a(int64_t result) {
    int64_t v1 = result + 152; // 0xa296
    *(int64_t *)(result + 160) = v1;
    *(int64_t *)v1 = v1;
    int64_t v2 = result + 168; // 0xa2c2
    *(int64_t *)(result + 176) = v2;
    *(int64_t *)v2 = v2;
    return result;
}

// Address range: 0xa2ed - 0xa39a
int64_t function_a2ed(int64_t a1) {
    int64_t v1 = a1 + 168; // 0xa2fd
    int64_t v2 = *(int64_t *)v1; // 0xa2fd
    if (v2 != v1) {
        int64_t v3 = *(int64_t *)v2; // 0xa30e
        if (*(int32_t *)(v2 + 32) % 2 != 0) {
            // 0xa323
            function_2d70(*(int64_t *)(v2 + 88));
        }
        // 0xa333
        function_2d70(v2);
        while (v3 != v1) {
            int64_t v4 = v3;
            v3 = *(int64_t *)v4;
            if (*(int32_t *)(v4 + 32) % 2 != 0) {
                // 0xa323
                function_2d70(*(int64_t *)(v4 + 88));
            }
            // 0xa333
            function_2d70(v4);
        }
    }
    int64_t result = a1 + 152; // 0xa35b
    int64_t v5 = *(int64_t *)result; // 0xa35b
    if (v5 == result) {
        // 0xa397
        return result;
    }
    int64_t v6 = *(int64_t *)v5; // 0xa36c
    function_2d70(v5);
    while (v6 != result) {
        int64_t v7 = v6;
        v6 = *(int64_t *)v7;
        function_2d70(v7);
    }
    // 0xa397
    return result;
}

// Address range: 0xa39a - 0xa4f0
int64_t function_a39a(int64_t a1) {
    // 0xa39a
    int64_t v1; // 0xa39a
    int64_t v2; // 0xa39a
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xa3be
        int64_t v3; // 0xa39a
        function_3080("Slirp", 128, "m_get...", v3, v2, v1);
    }
    int64_t v4 = a1 + 152; // 0xa3df
    int64_t v5 = *(int64_t *)v4; // 0xa3df
    int32_t * v6; // 0xa39a
    int64_t v7; // 0xa39a
    int32_t v8; // 0xa39a
    if (v5 != v4) {
        // 0xa44a
        function_ab7f(v5);
        v6 = (int32_t *)(a1 + 136);
        v7 = v5;
        v8 = 4;
    } else {
        int32_t * v9 = (int32_t *)(a1 + 136);
        int64_t v10 = function_2d50((int64_t)*v9 + 140); // 0xa40b
        int32_t * v11 = (int32_t *)(a1 + 184); // 0xa417
        int32_t v12 = *v11 + 1; // 0xa41d
        *v11 = v12;
        *(int64_t *)(v10 + 64) = a1;
        v6 = v9;
        v7 = v10;
        v8 = v12 < 31 ? 4 : 12;
    }
    int64_t result = v7;
    function_ab4c(result, a1 + 168);
    *(int32_t *)(result + 32) = v8;
    *(int32_t *)(result + 36) = *v6 + 44;
    *(int64_t *)(result + 48) = result + 96;
    *(int32_t *)(result + 56) = 0;
    *(int64_t *)(result + 16) = 0;
    *(int64_t *)(result + 24) = 0;
    *(char *)(result + 72) = 0;
    *(int64_t *)(result + 80) = -1;
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xa4c6
        function_3080("Slirp", 128, " m = %p", result, v2, v1);
    }
    // 0xa4e6
    return result;
}

// Address range: 0xa4f0 - 0xa60d
int64_t function_a4f0(int64_t a1) {	// m_free()
    int64_t result = 0; // 0xa50a
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xa529
        int64_t v1; // 0xa4f0
        int64_t v2; // 0xa4f0
        int64_t v3; // 0xa4f0
        function_3080("Slirp", 128, "m_free...", v3, v2, v1);
        result = 0;
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0xa539
            result = function_3080("Slirp", 128, " m = %p", a1, v2, v1);
        }
    }
    // 0xa55d
    if (a1 == 0) {
        // 0xa60a
        return result;
    }
    int32_t * v4 = (int32_t *)(a1 + 32); // 0xa56c
    int32_t v5 = *v4; // 0xa56c
    int32_t v6 = v5; // 0xa574
    if ((v5 & 4) != 0) {
        // 0xa576
        function_ab7f(a1);
        v6 = *v4;
    }
    int32_t v7 = v6; // 0xa58e
    if (v6 % 2 != 0) {
        // 0xa590
        function_2d70(*(int64_t *)(a1 + 88));
        v7 = *v4;
    }
    // 0xa5a0
    if ((v7 & 8) != 0) {
	result = function_2d70(a1);
        int32_t * v8 = (int32_t *)(*(int64_t *)(a1 + 64) + 184); // 0xa5b6
        *v8 = *v8 - 1;
        // 0xa60a
        return result;
    }
    uint32_t v9 = v7 & 2; // 0xa5da
    int64_t result2 = v9; // 0xa5df
    if (v9 == 0) {
        // 0xa5e1
        function_ab4c(a1, *(int64_t *)(a1 + 64) + 152);
        *v4 = 2;
        result2 = a1;
    }
    // 0xa60a
    return result2;
}

// Address range: 0xa60d - 0xa70b
int64_t function_a60d(int64_t a1, int64_t a2) {
    // 0xa60d
    int64_t v1; // 0xa60d
    if (*(int32_t *)(a1 + 32) % 2 == 0) {
        int64_t v2 = *(int64_t *)(a1 + 48); // 0xa66d
        v1 = a1 + 96 + (int64_t)*(int32_t *)(a1 + 36) - v2;
    } else {
        int32_t v3 = *(int32_t *)(a1 + 36); // 0xa637
        int64_t v4 = *(int64_t *)(a1 + 48); // 0xa646
        v1 = *(int64_t *)(a1 + 88) + (int64_t)v3 - v4;
    }
    int32_t * v5 = (int32_t *)(a1 + 56); // 0xa67b
    int32_t v6 = *v5; // 0xa67b
    int64_t v7 = v6;
    int32_t * v8 = (int32_t *)(a2 + 56); // 0xa68b
    int32_t v9 = *v8; // 0xa68b
    int64_t v10 = v7; // 0xa693
    int32_t v11 = v9; // 0xa693
    if (v1 - v7 < (int64_t)v9) {
        // 0xa695
        function_a70b(a1, (int64_t)(v9 + v6));
        v10 = (int64_t)*v5;
        v11 = *v8;
    }
    int64_t v12 = *(int64_t *)(a2 + 48); // 0xa6c1
    int64_t v13 = *(int64_t *)(a1 + 48); // 0xa6c9
    memcpy((int64_t *)(v13 + v10), (int64_t *)v12, v11);
    *v5 = *v8 + *v5;
    return function_a4f0(a2);
}

// Address range: 0xa70b - 0xa875
int64_t function_a70b(int64_t result2, int64_t a2) {
    int32_t * v1 = (int32_t *)(result2 + 32); // 0xa71e
    uint32_t v2 = *v1; // 0xa71e
    int64_t result; // 0xa70b
    if (v2 % 2 == 0) {
        int64_t v3 = *(int64_t *)(result2 + 48); // 0xa76a
        result = result2 + 96 + (int64_t)*(int32_t *)(result2 + 36) - v3;
    } else {
        int32_t v4 = *(int32_t *)(result2 + 36); // 0xa734
        int64_t v5 = *(int64_t *)(result2 + 48); // 0xa743
        result = *(int64_t *)(result2 + 88) + (int64_t)v4 - v5;
    }
    int64_t v6 = 0x100000000 * a2 / 0x100000000; // 0xa717
    if (result > v6) {
        // 0xa873
        return result;
    }
    int64_t * v7 = (int64_t *)(result2 + 48);
    int64_t v8 = *v7;
    int32_t * v9; // 0xa70b
    int64_t v10; // 0xa70b
    int64_t v11; // 0xa70b
    if (v2 % 2 == 0) {
        int64_t v12 = result2 + 96; // 0xa7e7
        int64_t v13 = v8 - v12; // 0xa7eb
        int64_t v14 = function_2d50(0x100000000 * (v13 + v6) / 0x100000000); // 0xa801
        int64_t * v15 = (int64_t *)(result2 + 88);
        *v15 = v14;
        int32_t * v16 = (int32_t *)(result2 + 36);
        memcpy((int64_t *)v14, (int64_t *)v12, *v16);
        *v1 = *v1 | 1;
        v10 = *v15;
        v9 = v16;
        v11 = v13;
    } else {
        int64_t * v17 = (int64_t *)(result2 + 88);
        int64_t v18 = *v17; // 0xa7a0
        int64_t v19 = v8 - v18; // 0xa7a4
        int64_t v20 = function_30f0(v18, 0x100000000 * (v19 + v6) / 0x100000000); // 0xa7c6
        *v17 = v20;
        v10 = v20;
        v9 = (int32_t *)(result2 + 36);
        v11 = v19;
    }
    // 0xa849
    *v7 = 0x100000000 * v11 / 0x100000000 + v10;
    *v9 = (int32_t)v11 + (int32_t)v6;
    // 0xa873
    return result2;
}

// Address range: 0xa875 - 0xa8d5
int64_t function_a875(int64_t result2, int64_t a2) {
    if (result2 == 0) {
        // 0xa8d3
        int64_t result; // 0xa875
        return result;
    }
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0xa87d
    int32_t v2 = v1; // 0xa887
    if (v2 < 0) {
        int32_t * v3 = (int32_t *)(result2 + 56); // 0xa8c1
        *v3 = *v3 + v2;
    } else {
        int64_t * v4 = (int64_t *)(result2 + 48); // 0xa891
        *v4 = *v4 + v1;
        int32_t * v5 = (int32_t *)(result2 + 56); // 0xa8a9
        *v5 = *v5 - v2;
    }
    // 0xa8d3
    return result2;
}

// Address range: 0xa8d5 - 0xa9b5
int64_t function_a8d5(int64_t a1, int64_t a2, int32_t a3, int32_t a4) {
    // 0xa8d5
    int64_t v1; // 0xa8d5
    if (*(int32_t *)(a1 + 32) % 2 == 0) {
        int64_t v2 = *(int64_t *)(a1 + 48); // 0xa941
        v1 = a1 + 96 + (int64_t)*(int32_t *)(a1 + 36) - v2;
    } else {
        int32_t v3 = *(int32_t *)(a1 + 36); // 0xa90b
        int64_t v4 = *(int64_t *)(a1 + 48); // 0xa91a
        v1 = *(int64_t *)(a1 + 88) + (int64_t)v3 - v4;
    }
    int32_t * v5 = (int32_t *)(a1 + 56); // 0xa94f
    int64_t v6 = (int64_t)*v5; // 0xa952
    int64_t result = 0xffffffff; // 0xa95b
    if (v1 - v6 >= (int64_t)a4) {
        int64_t v7 = *(int64_t *)(a2 + 48); // 0xa96d
        int64_t v8 = *(int64_t *)(a1 + 48); // 0xa97f
        memcpy((int64_t *)(v8 + v6), (int64_t *)(v7 + (int64_t)a3), a4);
        *v5 = *v5 + a4;
        result = 0;
    }
    // 0xa9b3
    return result;
}

// Address range: 0xa9b5 - 0xaaf4
int64_t function_a9b5(int64_t a1, uint64_t a2) {
    // 0xa9b5
    int64_t v1; // 0xa9b5
    int64_t v2; // 0xa9b5
    int64_t v3; // 0xa9b5
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xa9f2
        int64_t v4; // 0xa9b5
        function_3080("Slirp", 128, "dtom...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0xaa02
            function_3080("Slirp", 128, " dat = %p", a2, v3, v2);
            v1 = a2;
        }
    }
    int64_t v5 = a1 + 168; // 0xaa2a
    int64_t result = *(int64_t *)v5;
    if (result != v5) {
        uint64_t v6; // 0xaa77
        uint64_t v7; // 0xaa49
        if (*(int32_t *)(result + 32) % 2 == 0) {
            // 0xaa73
            v6 = result + 96;
            if (v6 <= a2) {
                // 0xaa81
                if (v6 + (int64_t)*(int32_t *)(result + 36) > a2) {
                    // 0xaaf2
                    return result;
                }
            }
        } else {
            // 0xaa45
            v7 = *(int64_t *)(result + 88);
            if (v7 <= a2) {
                // 0xaa53
                if (v7 + (int64_t)*(int32_t *)(result + 36) > a2) {
                    // 0xaaf2
                    return result;
                }
            }
        }
        int64_t v8 = *(int64_t *)result;
        while (v8 != v5) {
            int64_t v9 = v8;
            int64_t result2; // 0xa9b5
            if (*(int32_t *)(v9 + 32) % 2 == 0) {
                // 0xaa73
                v6 = v9 + 96;
                if (v6 <= a2) {
                    // 0xaa81
                    result2 = v9;
                    if (v6 + (int64_t)*(int32_t *)(v9 + 36) > a2) {
                        // 0xaaf2
                        return result2;
                    }
                }
            } else {
                // 0xaa45
                v7 = *(int64_t *)(v9 + 88);
                if (v7 <= a2) {
                    // 0xaa53
                    result2 = v9;
                    if (v7 + (int64_t)*(int32_t *)(v9 + 36) > a2) {
                        // 0xaaf2
                        return result2;
                    }
                }
            }
            // 0xaaa1
            v8 = *(int64_t *)v9;
        }
    }
    // 0xaac0
    if ((*(int32_t *)&g58 & 4) != 0) {
        // 0xaad0
        function_3080("Slirp", 128, "dtom failed", v1, v3, v2);
    }
    // 0xaaf2
    return 0;
}

// Address range: 0xaaf4 - 0xab4c
int64_t function_aaf4(int64_t sock) {
    int64_t v1 = __readfsqword(40); // 0xaaff
    int32_t option_value = 1; // bp-20, 0xab0e
    int32_t v2 = setsockopt((int32_t)sock, SO_DEBUG, 2, (int64_t *)&option_value, 4); // 0xab31
    int64_t result = v2; // 0xab43
    if (v1 != __readfsqword(40)) {
        // 0xab45
        __stack_chk_fail();
        result = &g91;
    }
    // 0xab4a
    return result;
}

// Address range: 0xab4c - 0xab7f
int64_t function_ab4c(int64_t result, int64_t a2) {
    // 0xab4c
    *(int64_t *)result = a2;
    *(int64_t *)a2 = result;
    *(int64_t *)(result + 8) = result;
    return result;
}

// Address range: 0xab7f - 0xabad
int64_t function_ab7f(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0xab8f
    int64_t result = *v1; // 0xab8f
    *(int64_t *)result = a1;
    *v1 = 0;
    return result;
}

// Address range: 0xabad - 0xac26
int64_t function_abad(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t result = function_30e0(1, 40); // 0xabd2
    *(int64_t *)result = a2;
    *(int64_t *)(result + 8) = a3;
    *(int32_t *)(result + 20) = (int32_t)a5;
    *(int32_t *)(result + 16) = (int32_t)a4;
    *(int64_t *)(result + 32) = 1;
    *(int64_t *)a1 = result;
    return result;
}

// Address range: 0xac26 - 0xac7e
int64_t function_ac26(int64_t a1, int64_t a2, uint32_t a3, int64_t a4) {
    int64_t result = function_abad(a1, 0, 0, (int64_t)a3, a4 & 0xffffffff); // 0xac58
    *(int64_t *)(result + 24) = function_3140(a2);
    return result;
}

// Address range: 0xac7e - 0xae71
int64_t function_ac7e(int64_t * a1) {
    int64_t v1 = __readfsqword(40); // 0xac8b
    int64_t addr = 2; // bp-56, 0xacaa
    int32_t addr_len = 16; // bp-68, 0xacb0
    int32_t * sock3 = (int32_t *)((int64_t)a1 + 4); // 0xacbf
    *sock3 = -1;
    int32_t sock = function_1c25e(2, 1, 0); // 0xacd9
    int64_t v2; // 0xac7e
    int64_t v3; // 0xac7e
    if (sock < 0) {
        int32_t err_num = *__errno_location(); // 0xadf9
        function_3080("Slirp", 8, "slirp_socketpair(): %s", (int64_t)strerror(err_num), v3, v2);
        goto lab_0xae32_2;
    } else {
        // 0xace6
        if (bind(sock, (struct sockaddr *)&addr, addr_len) < 0) {
            goto lab_0xae28;
        } else {
            // 0xad02
            if (listen(sock, 1) < 0) {
                goto lab_0xae28;
            } else {
                // 0xad19
                if (getsockname(sock, (struct sockaddr *)&addr, &addr_len) < 0) {
                    goto lab_0xae28;
                } else {
                    int32_t sock2 = function_1c25e(2, 1, 0); // 0xad52
                    *sock3 = sock2;
                    if (sock2 < 0) {
                        goto lab_0xae28;
                    } else {
                        // 0xad66
                        if (connect(sock2, (struct sockaddr *)&addr, addr_len) >= 0) {
                            goto lab_0xad9c;
                        } else {
                            while (*__errno_location() == 4) {
                                // 0xad8a
                                if (connect(*sock3, (struct sockaddr *)&addr, addr_len) >= 0) {
                                    goto lab_0xad9c;
                                }
                            }
                            goto lab_0xae28;
                        }
                    }
                }
            }
        }
    }
  lab_0xad9c:
    // 0xad9c
    while (true) {
        // 0xad9c
        *(int32_t *)a1 = accept(sock, (struct sockaddr *)&addr, &addr_len);
        int64_t v4; // 0xac7e
        if (*(int32_t *)&v4 >= 0) {
            // break -> 0xadd9
            break;
        }
        // 0xadc3
        if (*__errno_location() != 4) {
            goto lab_0xae28;
        }
    }
    // 0xadd9
    close(sock);
    int64_t v5 = 0; // 0xade8
    goto lab_0xae56;
  lab_0xae28:;
    int32_t err_num2 = *__errno_location(); // 0xadf9
    function_3080("Slirp", 8, "slirp_socketpair(): %s", (int64_t)strerror(err_num2), v3, v2);
    close(sock);
    goto lab_0xae32_2;
  lab_0xae32_2:;
    uint32_t fd = *sock3; // 0xae3a
    v5 = 0xffffffff;
    if (fd >= 0) {
        // 0xae40
        close(fd);
        v5 = 0xffffffff;
    }
    goto lab_0xae56;
  lab_0xae56:;
    int64_t result = v5; // 0xae63
    if (v1 != __readfsqword(40)) {
        // 0xae65
        __stack_chk_fail();
        result = &g91;
    }
    // 0xae6a
    return result;
}

// Address range: 0xae71 - 0xae85
int64_t function_ae71(int64_t a1) {
    // 0xae71
    return setsid();
}

// Address range: 0xae85 - 0xaee9
int64_t function_ae85(int64_t a1) {
    // 0xae85
    dup2(*(int32_t *)(a1 + 16), 0);
    dup2(*(int32_t *)(a1 + 20), 1);
    uint32_t fd = *(int32_t *)(a1 + 24); // 0xaec3
    dup2(fd, 2);
    return fd;
}

// Address range: 0xaee9 - 0xaf8e
int64_t function_aee9(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t * a11) {
    int64_t v1 = __readfsqword(40); // 0xaf18
    int64_t v2 = a5; // bp-56, 0xaf2b
    int64_t v3 = function_2f90(a1, a2, a3, (int32_t)a4, 0xae85, &v2, a7, (int64_t)a11); // 0xaf6f
    int64_t result = v3; // 0xaf85
    if (v1 != __readfsqword(40)) {
        // 0xaf87
        __stack_chk_fail();
        result = &g91;
    }
    // 0xaf8c
    return result;
}

// Address range: 0xaf8e - 0xb1d1
int64_t function_af8e(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0xaf9e
    int64_t v2 = 0; // bp-40, 0xafad
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xafe2
        int64_t v3; // 0xaf8e
        int64_t v4; // 0xaf8e
        int64_t v5; // 0xaf8e
        function_3080("Slirp", 128, "fork_exec...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0xb016
            function_3080("Slirp", 128, " so = %p", a1, v4, v3);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0xb026
                function_3080("Slirp", 128, " ex = %p", a2, v4, v3);
            }
        }
    }
    // 0xb04a
    int32_t fd2; // bp-24, 0xaf8e
    int64_t v6 = function_ac7e((int64_t *)&fd2); // 0xb051
    int64_t v7 = 0; // 0xb058
    if ((int32_t)v6 >= 0) {
        int64_t v8 = function_2d90(a2, &g16, 0xffffffff); // 0xb077
        uint32_t fd; // 0xaf8e
        int64_t v9 = fd; // 0xb080
        function_aee9(0, v8, 0, 4, 0xae71, 0, 0, v9, v9, v9, &v2);
        function_3060(v8);
        if (v2 == 0) {
            int32_t * sock = (int32_t *)(a1 + 16); // 0xb131
            *sock = fd2;
            close(fd);
            function_aaf4((int64_t)*sock);
            int32_t option_value = 1; // bp-44, 0xb14c
            setsockopt(*sock, SO_DEBUG, 10, (int64_t *)&option_value, 4);
            function_1c142((int64_t)*sock);
            v7 = 1;
        } else {
            // 0xb0d8
            function_3080("Slirp", 8, "fork_exec: %s", *(int64_t *)(v2 + 8), 0xae71, 0);
            function_31b0(v2);
            close(fd2);
            close(fd);
            v7 = 0;
        }
    }
    int64_t result = v7; // 0xb1c8
    if (v1 != __readfsqword(40)) {
        // 0xb1ca
        __stack_chk_fail();
        result = &g91;
    }
    // 0xb1cf
    return result;
}

// Address range: 0xb1d1 - 0xb890
int64_t slirp_connection_info(int64_t a1) {
    struct in_addr in6; // 0xb807
    struct in_addr in5; // 0xb7ad
    struct in_addr in2; // 0xb4a1
    struct in_addr in; // 0xb432
    struct in_addr in4; // 0xb6c5
    struct in_addr in3; // 0xb656
    int64_t v1 = __readfsqword(40); // 0xb1e8
    int64_t v2 = function_2d30(0); // 0xb1fc
    int64_t v3; // 0xb1d1
    int64_t v4; // 0xb1d1
    int64_t v5; // 0xb1d1
    int64_t v6; // 0xb1d1
    function_3070(v2, "  Protocol[State]    FD  Source Address  Port   Dest. Address  Port RecvQ SendQ\n", v5, v6, v4, v3);
    int64_t v7 = a1 + 448; // 0xb2af
    int64_t v8 = *(int64_t *)v7;
    int64_t v9; // 0xb1d1
    int32_t v10; // 0xb1d1
    int16_t v11; // 0xb1d1
    int64_t addr; // bp-184, 0xb1d1
    int32_t addr_len; // bp-212, 0xb1d1
    int64_t str; // bp-72, 0xb1d1
    if (v8 != v7) {
        // 0xb2c2
        int64_t v12; // bp-8, 0xb1d1
        int64_t v13 = (int64_t)&v12 - 160;
        int64_t v14 = &str;
        int32_t v15 = *(int32_t *)(v8 + 332); // 0xb2c9
        char * v16 = "HOST_FORWARD"; // 0xb2d6
        int64_t v17; // 0xb2ef
        int64_t v18; // 0xb310
        if ((v15 & (int32_t)"back") == 0) {
            // 0xb2e8
            v17 = *(int64_t *)(v8 + 336);
            v16 = "NONE";
            if (v17 != 0) {
                // 0xb2fb
                v18 = *(int64_t *)(v13 + 8 * (int64_t)*(int16_t *)(v17 + 16));
                v16 = (char *)v18;
            }
        }
        // 0xb32f
        int32_t v19; // 0xb1d1
        int16_t net_short; // 0xb1d1
        int64_t v20; // 0xb1d1
        int64_t net_short2; // 0xb1d1
        int32_t sock; // 0xb356
        if ((v15 & 0x3000) == 0) {
            // 0xb39b
            v20 = v8 + 76;
            v19 = *(int32_t *)(v8 + 204);
            net_short = *(int16_t *)(v8 + 202);
            net_short2 = v8 + 74;
        } else {
            // 0xb345
            addr_len = 16;
            sock = *(int32_t *)(v8 + 16);
            getsockname(sock, (struct sockaddr *)&addr, &addr_len);
            v20 = v8 + 204;
            int32_t v21; // 0xb1d1
            v19 = v21;
            int16_t v22; // 0xb1d1
            net_short = v22;
            net_short2 = v8 + 202;
        }
        int32_t v23 = v19;
        snprintf((char *)&str, 20, "  TCP[%s]", v16);
        uint16_t v24 = ntohs(net_short); // 0xb418
        int64_t v25 = &g17; // 0xb428
        if (v23 != 0) {
            // 0xb42a

            in.s_addr = v23;
            v25 = (int64_t)inet_ntoa(in);
        }
        uint32_t v26 = *(int32_t *)(v8 + 16); // 0xb447
        function_3070(v2, "%-19s %3d %15s %5d ", v14, (int64_t)v26, v25, (int64_t)v24);
        uint32_t v27 = *(int32_t *)(v8 + 360); // 0xb481
        uint16_t v28 = ntohs(*(int16_t *)net_short2); // 0xb491

        in2.s_addr = *(int32_t *)v20;
        int64_t v29 = (int64_t)*(int32_t *)(v8 + 392); // 0xb4b0
        function_3070(v2, "%15s %5d %5d %5d\n", (int64_t)inet_ntoa(in2), (int64_t)v28, (int64_t)v27, v29);
        int64_t v30 = *(int64_t *)v8;
        v10 = v23;
        v11 = net_short;
        v9 = v29;
        while (v30 != v7) {
            int32_t v31 = v23;
            int16_t v32 = net_short;
            int64_t v33 = v30;
            v15 = *(int32_t *)(v33 + 332);
            v16 = "HOST_FORWARD";
            if ((v15 & (int32_t)"back") == 0) {
                // 0xb2e8
                v17 = *(int64_t *)(v33 + 336);
                v16 = "NONE";
                if (v17 != 0) {
                    // 0xb2fb
                    v18 = *(int64_t *)(v13 + 8 * (int64_t)*(int16_t *)(v17 + 16));
                    v16 = (char *)v18;
                }
            }
            // 0xb32f
            if ((v15 & 0x3000) == 0) {
                // 0xb39b
                v20 = v33 + 76;
                v19 = *(int32_t *)(v33 + 204);
                net_short = *(int16_t *)(v33 + 202);
                net_short2 = v33 + 74;
            } else {
                // 0xb345
                addr_len = 16;
                sock = *(int32_t *)(v33 + 16);
                getsockname(sock, (struct sockaddr *)&addr, &addr_len);
                v20 = v33 + 204;
                v19 = v31;
                net_short = v32;
                net_short2 = v33 + 202;
            }
            // 0xb3e5
            v23 = v19;
            snprintf((char *)&str, 20, "  TCP[%s]", v16);
            v24 = ntohs(net_short);
            v25 = &g17;
            if (v23 != 0) {
                // 0xb42a

                in.s_addr = v23;
                v25 = (int64_t)inet_ntoa(in);
            }
            // 0xb440
            v26 = *(int32_t *)(v33 + 16);
            function_3070(v2, "%-19s %3d %15s %5d ", v14, (int64_t)v26, v25, (int64_t)v24);
            v27 = *(int32_t *)(v33 + 360);
            v28 = ntohs(*(int16_t *)net_short2);
            in2.s_addr = *(int32_t *)v20;
            v29 = (int64_t)*(int32_t *)(v33 + 392);
            function_3070(v2, "%15s %5d %5d %5d\n", (int64_t)inet_ntoa(in2), (int64_t)v28, (int64_t)v27, v29);
            v30 = *(int64_t *)v33;
            v10 = v23;
            v11 = net_short;
            v9 = v29;
        }
    }
    int64_t v34 = a1 + (int64_t)&g71; // 0xb4fe
    int64_t v35 = *(int64_t *)v34;
    int64_t v36 = v9; // 0xb715
    if (v35 != v34) {
        int64_t v37 = &str;
        int32_t v38; // 0xb1d1
        int16_t net_short3; // 0xb1d1
        int64_t v39; // 0xb1d1
        int64_t net_short4; // 0xb1d1
        int32_t v40; // 0xb5aa
        int32_t v41; // 0xb5b7
        int32_t sock2; // 0xb55b
        if ((*(int32_t *)(v35 + 332) & (int32_t)"back") == 0) {
            // 0xb5a3
            v40 = *(int32_t *)(v35 + 344);
            v41 = *(int32_t *)&g60;
            snprintf((char *)&str, 20, "  UDP[%d sec]", 0x10624dd3 * (int64_t)(v40 - v41) / 0x4000000000);
            v39 = v35 + 76;
            v38 = *(int32_t *)(v35 + 204);
            net_short3 = *(int16_t *)(v35 + 202);
            net_short4 = v35 + 74;
        } else {
            // 0xb527
            str = 0x4f485b5044552020;
            addr_len = 16;
            sock2 = *(int32_t *)(v35 + 16);
            getsockname(sock2, (struct sockaddr *)&addr, &addr_len);
            v39 = v35 + 204;
            v38 = v10;
            net_short3 = v11;
            net_short4 = v35 + 202;
        }
        int32_t v42 = v38;
        uint16_t v43 = ntohs(net_short3); // 0xb63c
        int64_t v44 = &g17; // 0xb64c
        if (v42 != 0) {
            // 0xb64e

            in3.s_addr = v42;
            v44 = (int64_t)inet_ntoa(in3);
        }
        uint32_t v45 = *(int32_t *)(v35 + 16); // 0xb66b
        function_3070(v2, "%-19s %3d %15s %5d ", v37, (int64_t)v45, v44, (int64_t)v43);
        uint32_t v46 = *(int32_t *)(v35 + 360); // 0xb6a5
        uint16_t v47 = ntohs(*(int16_t *)net_short4); // 0xb6b5

        in4.s_addr = *(int32_t *)v39;
        int64_t v48 = (int64_t)*(int32_t *)(v35 + 392); // 0xb6d4
        function_3070(v2, "%15s %5d %5d %5d\n", (int64_t)inet_ntoa(in4), (int64_t)v47, (int64_t)v46, v48);
        int64_t v49 = *(int64_t *)v35;
        int16_t v50 = net_short3; // 0xb715
        int32_t v51 = v42; // 0xb715
        v36 = v48;
        while (v49 != v34) {
            int64_t v52 = v49;
            if ((*(int32_t *)(v52 + 332) & (int32_t)"back") == 0) {
                // 0xb5a3
                v40 = *(int32_t *)(v52 + 344);
                v41 = *(int32_t *)&g60;
                snprintf((char *)&str, 20, "  UDP[%d sec]", 0x10624dd3 * (int64_t)(v40 - v41) / 0x4000000000);
                v39 = v52 + 76;
                v38 = *(int32_t *)(v52 + 204);
                net_short3 = *(int16_t *)(v52 + 202);
                net_short4 = v52 + 74;
            } else {
                // 0xb527
                str = 0x4f485b5044552020;
                addr_len = 16;
                sock2 = *(int32_t *)(v52 + 16);
                getsockname(sock2, (struct sockaddr *)&addr, &addr_len);
                v39 = v52 + 204;
                v38 = v51;
                net_short3 = v50;
                net_short4 = v52 + 202;
            }
            // 0xb630
            v42 = v38;
            v43 = ntohs(net_short3);
            v44 = &g17;
            if (v42 != 0) {
                // 0xb64e



                in3.s_addr = v42;
                v44 = (int64_t)inet_ntoa(in3);
            }
            // 0xb664
            v45 = *(int32_t *)(v52 + 16);
            function_3070(v2, "%-19s %3d %15s %5d ", v37, (int64_t)v45, v44, (int64_t)v43);
            v46 = *(int32_t *)(v52 + 360);
            v47 = ntohs(*(int16_t *)net_short4);


            in4.s_addr = *(int32_t *)v39;
            v48 = (int64_t)*(int32_t *)(v52 + 392);
            function_3070(v2, "%15s %5d %5d %5d\n", (int64_t)inet_ntoa(in4), (int64_t)v47, (int64_t)v46, v48);
            v49 = *(int64_t *)v52;
            v50 = net_short3;
            v51 = v42;
            v36 = v48;
        }
    }
    int64_t v53 = a1 + (int64_t)&g79; // 0xb722
    int64_t v54 = *(int64_t *)v53;
    if (v54 != v53) {
        int64_t v55 = &str;
        int64_t v56 = v54;
        int32_t v57 = *(int32_t *)(v56 + 344); // 0xb73c
        int32_t v58 = *(int32_t *)&g60; // 0xb749
        snprintf((char *)&str, 20, "  ICMP[%d sec]", 0x10624dd3 * (int64_t)(v57 - v58) / 0x4000000000);
        int32_t v59 = *(int32_t *)(v56 + 204); // 0xb77f
        int64_t v60 = &g17; // 0xb7a3
        if (v59 != 0) {
            // 0xb7a5

            in5.s_addr = v59;
            v60 = (int64_t)inet_ntoa(in5);
        }
        uint32_t v61 = *(int32_t *)(v56 + 16); // 0xb7c2
        function_3070(v2, "%-19s %3d %15s  -    ", v55, (int64_t)v61, v60, v36);
        uint32_t v62 = *(int32_t *)(v56 + 392); // 0xb7eb
        uint32_t v63 = *(int32_t *)(v56 + 360); // 0xb7f9

        in6.s_addr = *(int32_t *)(v56 + 76);
        function_3070(v2, "%15s  -    %5d %5d\n", (int64_t)inet_ntoa(in6), (int64_t)v63, (int64_t)v62, v36);
        v56 = *(int64_t *)v56;
        while (v56 != v53) {
            // 0xb735
            v57 = *(int32_t *)(v56 + 344);
            v58 = *(int32_t *)&g60;
            snprintf((char *)&str, 20, "  ICMP[%d sec]", 0x10624dd3 * (int64_t)(v57 - v58) / 0x4000000000);
            v59 = *(int32_t *)(v56 + 204);
            v60 = &g17;
            if (v59 != 0) {
                // 0xb7a5

                in5.s_addr = v59;
                v60 = (int64_t)inet_ntoa(in5);
            }
            // 0xb7bb
            v61 = *(int32_t *)(v56 + 16);
            function_3070(v2, "%-19s %3d %15s  -    ", v55, (int64_t)v61, v60, v36);
            v62 = *(int32_t *)(v56 + 392);
            v63 = *(int32_t *)(v56 + 360);


            in6.s_addr = *(int32_t *)(v56 + 76);
            function_3070(v2, "%15s  -    %5d %5d\n", (int64_t)inet_ntoa(in6), (int64_t)v63, (int64_t)v62, v36);
            v56 = *(int64_t *)v56;
        }
    }
    int64_t result = function_2f30(v2, 0); // 0xb87b
    if (v1 != __readfsqword(40)) {
        // 0xb87d
        __stack_chk_fail();
        result = &g91;
    }
    // 0xb882
    return result;
}

// Address range: 0xb890 - 0xb8e6
int64_t function_b890(int64_t a1, int64_t a2) {
    // 0xb890
    if ((int32_t)a2 <= 0) {
        // 0xb8de
        return 0;
    }
    int64_t v1 = 0;
    int32_t v2 = 0; // 0xb8cf
    v2 += (int32_t)htons(*(int16_t *)(2 * v1 + a1));
    v1++;
    while (v1 != (a2 & 0xffffffff)) {
        // 0xb8af
        v2 += (int32_t)htons(*(int16_t *)(2 * v1 + a1));
        v1++;
    }
    // 0xb8de
    return -v2;
}

// Address range: 0xb8e6 - 0xb970
int64_t function_b8e6(int64_t a1) {
    // 0xb8e6
    *(int32_t *)(a1 + 20) = htonl(-1);
    *(int32_t *)(a1 + 24) = htonl(-1);
    *(int32_t *)(a1 + 28) = htonl(-1);
    *(int32_t *)(a1 + 32) = htonl(-1);
    *(int32_t *)(a1 + 36) = htonl(-1);
    *(char *)(a1 + 46) = -1;
    *(char *)(a1 + 43) = 2;
    return 0;
}

// Address range: 0xb970 - 0xb99e
int64_t function_b970(int64_t a1) {
    // 0xb970
    *(int32_t *)(a1 + 20) = htonl(1);
    return 0;
}

// Address range: 0xb99e - 0xb9d7
int64_t function_b99e(int64_t a1) {
    // 0xb99e
    *(char *)(a1 + 20) = 0;
    *(char *)(a1 + 23) = 0;
    *(char *)(a1 + 24) = 0;
    *(int16_t *)(a1 + 26) = 0;
    return 0;
}

// Address range: 0xb9d7 - 0xbce7
int64_t function_b9d7(int64_t a1, int64_t a2, int32_t a3) {
    int64_t v1 = __readfsqword(40); // 0xb9f6
    int64_t v2; // bp-232, 0xb9d7
    int64_t v3 = &v2; // 0xba1e
    memset(&v2, 0, 206);
    memset(&v2, 255, 6);
    memset((int64_t *)(v3 | 6), 255, 6);
    *(int16_t *)(v3 + 12) = htons(-0x7708);
    char * v4 = (char *)(a2 + 18);
    int64_t v5 = 0;
    int64_t v6 = 16 * v5 + (int64_t)&g41; // 0xbad4
    int64_t v7 = v6; // 0xbaee
    while ((int32_t)*v4 + 128 != (int32_t)*(char *)v6) {
        // 0xbb19
        v5++;
        v7 = 0;
        if (v5 >= 30) {
            // break -> 0xbb24
            break;
        }
        v6 = 16 * v5 + (int64_t)&g41;
        v7 = v6;
    }
    // 0xbb24
    int64_t v8; // bp-218, 0xb9d7
    *(char *)&v8 = *(char *)(a2 + 14);
    int64_t v9 = &v8; // 0xbb37
    *(char *)(v9 | 1) = 1;
    *(char *)(v9 | 3) = *(char *)(a2 + 17);
    *(char *)(v9 | 4) = *v4 ^ -128;
    *(char *)(v9 | 5) = *(char *)(a2 + 19);
    int32_t v10; // 0xb9d7
    if (v7 == 0) {
        // 0xbc1a
        *(int16_t *)(v9 | 6) = 0;
        *(int16_t *)(v9 + 16) = htons(2);
        *(int16_t *)(v9 + 18) = htons(0x7fff);
        v10 = 16;
    } else {
        int32_t * host_short = (int32_t *)(v7 + 4); // 0xbb99
        *(int16_t *)(v9 | 6) = htons((int16_t)*host_short);
        *(int16_t *)(v9 + 16) = htons(0);
        *(int16_t *)(v9 + 18) = htons(0);
        v10 = *host_short + 16;
    }
    int32_t v11 = htonl((int32_t)function_b890(v9, (int64_t)v10)); // 0xbc94
    *(int32_t *)((int64_t)v10 + v9) = v11;
    function_f245(a1, &v2, (int64_t)(v10 + 18));
    int64_t result = 0; // 0xbcde
    if (v1 != __readfsqword(40)) {
        // 0xbce0
        __stack_chk_fail();
        result = &g91;
    }
    // 0xbce5
    return result;
}

// Address range: 0xbce7 - 0xbd16
int64_t function_bce7(int64_t * str, int64_t * str2) {
    int32_t memcmp_rc = memcmp(str, str2, 16); // 0xbd0a
    return (int64_t)(memcmp_rc & -256) | (int64_t)(memcmp_rc == 0);
}

// Address range: 0xbd16 - 0xc04f
int64_t function_bd16(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t address = a2; // bp-136, 0xbd2b
    int64_t v1 = __readfsqword(40); // 0xbd37
    int64_t address_str; // bp-72, 0xbd16
    inet_ntop(AF_INET6, &address, (char *)&address_str, 46);
    int64_t v2 = 46; // 0xbd7c
    int64_t v3; // 0xbd16
    int64_t v4; // 0xbd16
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xbd9b
        int64_t v5; // 0xbd16
        int64_t v6; // 0xbd16
        function_3080("Slirp", 128, "ndp_table_add...", 46, v6, v5);
        v2 = 46;
        if (*(int32_t *)&g58 % 2 != 0) {
            int64_t v7 = &address_str; // 0xbdaf
            function_3080("Slirp", 128, " ip = %s", v7, v6, v5);
            v2 = v7;
            if (*(int32_t *)&g58 % 2 != 0) {
                int64_t v8 = v7 & 248;
                int64_t v9 = (int64_t)*(char *)(a4 + 2); // 0xbe3b
                int64_t v10 = (int64_t)*(char *)(a4 + 1); // 0xbe3e
                function_3080("Slirp", 128, " hw addr = %02x:%02x:%02x:%02x:%02x:%02x", v8, v10, v9);
                v2 = v8;
                v3 = v10;
                v4 = v9;
            }
        }
    }
    // 0xbe64
    int64_t v11; // 0xbd4a
    if ((char)address == -1) {
        goto lab_0xbe96;
    } else {
        // 0xbe6f
        v11 = a1 + (int64_t)&g4;
        int64_t v12 = 0; // bp-88, 0xbe6f
        int64_t v13 = function_bce7(&address, &v12); // 0xbe8d
        int64_t v14 = 0; // 0xbe94
        if ((char)v13 == 0) {
            int64_t v15 = 24 * v14 + v11; // 0xbeef
            while ((char)function_bce7((int64_t *)(v15 + 8), &address) == 0) {
                int64_t v16 = v14 + 1;
                v14 = v16;
                if (v16 >= 16) {
                    // 0xbf78
                    if (*(int32_t *)&g58 % 2 == 0) {
                        goto lab_0xbfa5;
                    } else {
                        // 0xbf88
                        function_3080("Slirp", 128, " create new entry...", v2, v3, v4);
                        goto lab_0xbfa5;
                    }
                }
                v15 = 24 * v14 + v11;
            }
            // 0xbf09
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0xbf19
                function_3080("Slirp", 128, " already in table: update the entry...", v2, v3, v4);
            }
            // 0xbf36
            memcpy((int64_t *)v15, (int64_t *)a4, 6);
            goto lab_0xc039;
        } else {
            goto lab_0xbe96;
        }
    }
  lab_0xbe96:
    // 0xbe96
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xbeaa
        function_3080("Slirp", 128, " abort: do not register multicast or unspecified address...", v2, v3, v4);
    }
    goto lab_0xc039;
  lab_0xc039:;
    int64_t result = 0; // 0xc046
    if (v1 != __readfsqword(40)) {
        // 0xc048
        __stack_chk_fail();
        result = &g91;
    }
    // 0xc04d
    return result;
  lab_0xbfa5:;
    int32_t * v17 = (int32_t *)(a1 + (int64_t)&g4 + 384); // 0xbfa9
    int64_t v18 = 24 * (int64_t)*v17 + v11; // 0xbfc3
    *(int64_t *)(v18 + 8) = address;
    *(int64_t *)(v18 + 16) = a3;
    memcpy((int64_t *)(24 * (int64_t)*v17 + v11), (int64_t *)a4, 6);
    *v17 = (*v17 + 1) % 16;
    goto lab_0xc039;
}

// Address range: 0xc04f - 0xc3ab
int64_t function_c04f(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t address = a2; // bp-136, 0xc064
    int64_t v1 = __readfsqword(40); // 0xc070
    int64_t v2 = 46; // 0xc095
    int64_t address_str; // bp-72, 0xc04f
    inet_ntop(AF_INET6, &address, (char *)&address_str, 46);
    int64_t v3 = 46; // 0xc0b5
    int64_t v4; // 0xc04f
    int64_t v5; // 0xc04f
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xc0d4
        function_3080("Slirp", 128, "ndp_table_search...", 46, v5, v4);
        v3 = 46;
        if (*(int32_t *)&g58 % 2 != 0) {
            int64_t v6 = &address_str; // 0xc0e8
            v2 = v6;
            function_3080("Slirp", 128, " ip = %s", v6, v5, v4);
            v3 = v6;
        }
    }
    int64_t v7 = 0; // bp-88, 0xc108
    int64_t v8 = function_bce7(&address, &v7); // 0xc126
    int64_t v9 = v3; // 0xc130
    int64_t v10 = v3; // 0xc130
    if ((char)v8 == 1) {
        // 0xc132
        v2 = (int64_t)"ndp_table_search";
        __assert_fail("!in6_zero(&ip_addr)", "../src/ndp_table.c", 59, "ndp_table_search");
        v9 = (int64_t)"ndp_table_search";
        v10 = (char)"ndp_table_search";
    }
    int64_t v11 = 0; // 0xc15a
    int64_t v12; // 0xc04f
    if ((char)address != -1) {
        int64_t v13 = a1 + (int64_t)&g4 + 24 * v11; // 0xc26c
        while ((char)function_bce7((int64_t *)(v13 + 8), &address) == 0) {
            // 0xc359
            v11++;
            if (v11 >= 16) {
                // 0xc363
                v12 = 0;
                if (*(int32_t *)&g58 % 2 == 0) {
                    goto lab_0xc395;
                } else {
                    // 0xc373
                    function_3080("Slirp", 128, " ip not found in table...", v9, v5, v4);
                    v12 = 0;
                    goto lab_0xc395;
                }
            }
            v13 = a1 + (int64_t)&g4 + 24 * v11;
        }
        // 0xc28a
        memcpy((int64_t *)a4, (int64_t *)v13, 6);
        v12 = 1;
        if (*(int32_t *)&g58 % 2 != 0) {
            unsigned char v14 = *(char *)(a4 + 2); // 0xc2ff
            unsigned char v15 = *(char *)(a4 + 1); // 0xc30e
            function_3080("Slirp", 128, " found hw addr = %02x:%02x:%02x:%02x:%02x:%02x", v10 % 256, (int64_t)v15, (int64_t)v14);
            v12 = 1;
        }
    } else {
        // 0xc160
        *(char *)a4 = 51;
        char * v16 = (char *)(a4 + 1); // 0xc16f
        *v16 = 51;
        v12 = 1;
        if (*(int32_t *)&g58 % 2 != 0) {
            unsigned char v17 = *(char *)(a4 + 2); // 0xc1f0
            unsigned char v18 = *v16; // 0xc1ff
            unsigned char v19 = *(char *)&v2; // 0xc209
            function_3080("Slirp", 128, " multicast addr = %02x:%02x:%02x:%02x:%02x:%02x", (int64_t)v19, (int64_t)v18, (int64_t)v17);
            v12 = 1;
        }
    }
    goto lab_0xc395;
  lab_0xc395:;
    int64_t result = v12; // 0xc3a2
    if (v1 != __readfsqword(40)) {
        // 0xc3a4
        __stack_chk_fail();
        result = &g91;
    }
    // 0xc3a9
    return result;
}

// Address range: 0xc3ab - 0xc3ca
int64_t function_c3ab(int64_t a1) {
    // 0xc3ab
    free((int64_t *)*(int64_t *)(a1 + 24));
    return &g91;
}

// Address range: 0xc3ca - 0xc48d
int64_t function_c3ca(int64_t a1, int64_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0xc3d9
    int64_t v2; // 0xc3ca
    uint32_t v3 = (int32_t)v2;
    int64_t v4 = 0x100000000 * (v3 >= (int32_t)a2 ? a2 : v2) / 0x100000000;
    int32_t v5 = v4; // 0xc3fd
    *(int32_t *)a1 = v3 - v5;
    int64_t * v6 = (int64_t *)(a1 + 16); // 0xc40c
    uint64_t v7 = *v6 + v4; // 0xc415
    *v6 = v7;
    int64_t v8 = (int64_t)*v1; // 0xc437
    if (v7 >= *(int64_t *)(a1 + 24) + v8) {
        // 0xc441
        *v6 = v7 - v8;
    }
    uint32_t v9 = *v1 / 2; // 0xc3dc
    int64_t v10; // 0xc3ca
    uint32_t v11 = *(int32_t *)&v10; // 0xc464
    return v11 < v9 == v11 + v5 >= v9;
}

// Address range: 0xc48d - 0xc59c
int64_t function_c48d(int64_t result, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0xc499
    int64_t * v2 = (int64_t *)(result + 24); // 0xc4a0
    int64_t v3 = *v2; // 0xc4a0
    if (v3 == 0) {
        int32_t size = v1; // 0xc533
        int64_t mem = (int64_t)malloc(size); // 0xc53b
        *v2 = mem;
        *(int64_t *)(result + 16) = mem;
        int64_t * v4 = (int64_t *)(result + 8); // 0xc567
        *v4 = mem;
        *(int32_t *)result = 0;
        int32_t * v5 = (int32_t *)(result + 4);
        if (*v4 == 0) {
            // 0xc58e
            *v5 = 0;
        } else {
            // 0xc582
            *v5 = size;
        }
        // 0xc599
        return result;
    }
    int32_t * v6 = (int32_t *)(result + 4); // 0xc4b1
    int32_t v7 = v1; // 0xc4b7
    if (*v6 == v7) {
        // 0xc599
        return v1 & 0xffffffff;
    }
    int64_t mem2 = (int64_t)realloc((int64_t *)v3, v7); // 0xc4d3
    *v2 = mem2;
    *(int64_t *)(result + 16) = mem2;
    int64_t * v8 = (int64_t *)(result + 8); // 0xc4ff
    *v8 = mem2;
    *(int32_t *)result = 0;
    if (*v8 == 0) {
        // 0xc526
        *v6 = 0;
    } else {
        // 0xc51a
        *v6 = v7;
    }
    // 0xc599
    return result;
}

// Address range: 0xc59c - 0xc791
int64_t function_c59c(int64_t a1, int64_t a2) {
    // 0xc59c
    int32_t * v1; // 0xc59c
    if (*(int32_t *)&g58 % 2 == 0) {
        // 0xc648
        v1 = (int32_t *)(a2 + 56);
        goto lab_0xc67e;
    } else {
        // 0xc5e0
        int64_t v2; // 0xc59c
        int64_t v3; // 0xc59c
        int64_t v4; // 0xc59c
        function_3080("Slirp", 128, "sbappend...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 == 0) {
            // 0xc648
            v1 = (int32_t *)(a2 + 56);
            goto lab_0xc67e;
        } else {
            // 0xc614
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 == 0) {
                // 0xc648
                v1 = (int32_t *)(a2 + 56);
                goto lab_0xc67e;
            } else {
                // 0xc648
                function_3080("Slirp", 128, " m = %p", a2, v3, v2);
                if (*(int32_t *)&g58 % 2 == 0) {
                    // 0xc648
                    v1 = (int32_t *)(a2 + 56);
                    goto lab_0xc67e;
                } else {
                    int32_t * v5 = (int32_t *)(a2 + 56);
                    function_3080("Slirp", 128, " m->m_len = %d", (int64_t)*v5, v3, v2);
                    v1 = v5;
                    goto lab_0xc67e;
                }
            }
        }
    }
  lab_0xc67e:;
    int32_t v6 = *v1; // 0xc682
    if (v6 >= 0 != v6 != 0) {
        // 0xc78f
        return function_a4f0(a2);
    }
    int64_t v7 = a1 + 360;
    if (*(int32_t *)(a1 + 64) != 0) {
        // 0xc6a5
        function_c791(v7, a2);
        function_a4f0(a2);
        // 0xc78f
        return function_10307(a1);
    }
    int32_t v8 = 0; // 0xc6e8
    if (*(int32_t *)v7 == 0) {
        int64_t v9 = *(int64_t *)(a2 + 48); // 0xc6f8
        v8 = function_f014(a1, v9, (int64_t)v6, 0);
    }
    int32_t v10 = v8;
    if (v10 >= 0 != v10 != 0) {
        // 0xc716
        function_c791(v7, a2);
        // 0xc78f
        return function_a4f0(a2);
    }
    int32_t v11 = *v1; // 0xc736
    if (v11 != v10) {
        // 0xc73e
        *v1 = v11 - v10;
        int64_t * v12 = (int64_t *)(a2 + 48); // 0xc755
        *v12 = *v12 + (int64_t)v10;
        function_c791(v7, a2);
    }
    // 0xc78f
    return function_a4f0(a2);
}

// Address range: 0xc791 - 0xc938
int64_t function_c791(int64_t a1, int64_t a2) {
    int32_t v1 = *(int32_t *)(a2 + 56); // 0xc7a5
    int64_t * v2 = (int64_t *)(a1 + 8); // 0xc7af
    uint64_t v3 = *v2; // 0xc7af
    int64_t * v4 = (int64_t *)(a1 + 16); // 0xc7b7
    uint64_t v5 = *v4; // 0xc7b7
    int64_t * v6; // 0xc791
    int32_t * v7; // 0xc791
    int32_t v8; // 0xc791
    if (v5 <= v3) {
        int64_t * v9 = (int64_t *)(a1 + 24);
        int32_t * v10 = (int32_t *)(a1 + 4);
        int32_t v11 = *v10 + (int32_t)(*v9 - v3); // 0xc835
        int32_t v12 = v1 < v11 ? v1 : v11;
        int64_t * v13 = (int64_t *)(a2 + 48); // 0xc850
        memcpy((int64_t *)v3, (int64_t *)*v13, v12);
        int32_t v14 = v1 - v12; // 0xc86a
        v7 = v10;
        v6 = v9;
        v8 = v12;
        if (v14 != 0) {
            int64_t v15 = *v9; // 0xc882
            int32_t v16 = (int32_t)(*v4 - v15); // 0xc88c
            int32_t v17 = v14 < v16 ? v14 : v16;
            memcpy((int64_t *)v15, (int64_t *)(*v13 + (int64_t)v12), v17);
            v7 = v10;
            v6 = v9;
            v8 = v17 + v12;
        }
    } else {
        int32_t v18 = v5 - v3; // 0xc7d9
        int32_t v19 = v1 < v18 ? v1 : v18;
        memcpy((int64_t *)v3, (int64_t *)*(int64_t *)(a2 + 48), v19);
        v7 = (int32_t *)(a1 + 4);
        v6 = (int64_t *)(a1 + 24);
        v8 = v19;
    }
    // 0xc8cc
    int64_t v20; // 0xc791
    *(int32_t *)a1 = v8 + (int32_t)v20;
    uint64_t v21 = *v2 + (int64_t)v8; // 0xc8ea
    *v2 = v21;
    int64_t v22 = (int64_t)*v7; // 0xc90c
    int64_t v23 = *v6 + v22; // 0xc90e
    int64_t result = v23; // 0xc914
    if (v21 >= v23) {
        // 0xc916
        *v2 = v21 - v22;
        result = a1;
    }
    // 0xc935
    return result;
}

// Address range: 0xc938 - 0xca4b
int64_t function_c938(int64_t a1, int32_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = 0x100000000 * a3;
    int64_t v2 = v1 / 0x100000000; // 0xc947
    uint64_t v3 = *(int64_t *)(a1 + 16) + (int64_t)a2; // 0xc95b
    int64_t * v4 = (int64_t *)(a1 + 24); // 0xc966
    int64_t v5 = *v4; // 0xc966
    int64_t v6 = (int64_t)*(int32_t *)(a1 + 4);
    uint64_t v7 = v3 - (v3 < v5 + v6 ? 0 : v6);
    int64_t dest_mem; // 0xc938
    if (v7 < *(int64_t *)(a1 + 8)) {
        // 0xc99a
        int64_t v8; // 0xc938
        int64_t v9 = (int32_t)v8 >= (int32_t)v2 ? v2 : v8;
        dest_mem = (int64_t)memcpy((int64_t *)a4, (int64_t *)v7, (int32_t)v9);
        // 0xca48
        return dest_mem;
    }
    int64_t v10 = v5 - v7 + v6; // 0xc9e6
    int32_t v11 = v2; // 0xc9f2
    int64_t v12 = ((int32_t)v10 > v11 ? v1 : 0x100000000 * v10) / 0x100000000;
    int32_t v13 = v12; // 0xc9fd
    memcpy((int64_t *)a4, (int64_t *)v7, v13);
    int32_t v14 = v11 - v13; // 0xca19
    dest_mem = v12 & 0xffffffff;
    if (v14 != 0) {
        int64_t v15 = *v4; // 0xca2c
        dest_mem = (int64_t)memcpy((int64_t *)(v12 + a4), (int64_t *)v15, v14);
    }
    // 0xca48
    return dest_mem;
}

// Address range: 0xca4b - 0xca7a
int64_t function_ca4b(int64_t * str, int64_t * str2) {
    int32_t memcmp_rc = memcmp(str, str2, 16); // 0xca6e
    return (int64_t)(memcmp_rc & -256) | (int64_t)(memcmp_rc == 0);
}

// Address range: 0xca7a - 0xcaba
int64_t function_ca7a(int64_t a1, int64_t a2, int64_t a3) {
    // 0xca7a
    *(char *)a3 = 82;
    *(char *)(a3 + 1) = 86;
    uint32_t result; // 0xca7a
    return result;
}

// Address range: 0xcaba - 0xcc9e
int64_t function_caba(int64_t a1, int64_t * a2, int64_t a3, int64_t * a4, int64_t * a5) {
    int64_t v1 = 0x100000000 * a3 / 0x100000000; // 0xcad3
    int64_t v2 = __readfsqword(40); // 0xcae7
    int32_t v3 = *(int32_t *)&g60; // 0xcafd
    int64_t v4; // 0xcaba
    int64_t v5; // 0xcaba
    if (v3 - (int32_t)v5 > (int32_t)&g74) {
        int64_t v6 = (int64_t)a4;
        int64_t * v7 = (int64_t *)(v6 + 8); // 0xcb46
        int64_t * v8 = (int64_t *)(v6 + 48); // 0xcb7e
        int64_t * v9 = (int64_t *)(v6 + 88); // 0xcba2
        v4 = 0xffffffff;
        if ((int32_t)function_1d0d0("/etc/resolv.conf", v6) == 0) {
            // 0xcc08
            v4 = 1;
            if (*(int64_t *)(v6 + 120) == v6) {
                // 0xcc1e
                v4 = 1;
                if (*v7 == *v7) {
                    // 0xcc35
                    v4 = 1;
                    if (*v8 == *v8) {
                        // 0xcc49
                        v4 = 1;
                        if (*v9 == *v9) {
                            // 0xcc5d
                            memcpy((int64_t *)a1, a2, (int32_t)v1);
                            v4 = 0;
                        }
                    }
                }
            }
        }
    } else {
        // 0xcb13
        memcpy((int64_t *)a1, a2, (int32_t)v1);
        v4 = 0;
    }
    int64_t result = v4; // 0xcc95
    if (v2 != __readfsqword(40)) {
        // 0xcc97
        __stack_chk_fail();
        result = &g91;
    }
    // 0xcc9c
    return result;
}

// Address range: 0xcc9e - 0xcfd3
int64_t function_cc9e(int64_t a1, int64_t a2, int64_t * a3, int64_t a4, int64_t a5, int64_t * a6) {
    int64_t v1 = __readfsqword(40); // 0xccd1
    struct _IO_FILE * stream = fopen64("/etc/resolv.conf", "r"); // 0xcd38
    int64_t v2 = 0xffffffff; // 0xcd4c
    int32_t v3; // 0xcc9e
    if (stream != NULL) {
        int64_t v4 = (int64_t)a6;
        if ((*(int32_t *)&g58 & 2) != 0) {
            // 0xcd6c
            function_3080("Slirp", 128, "IP address of your DNS(s):", 16, a5, v4);
        }
        // 0xcf72
        int64_t v5; // bp-952, 0xcc9e
        int64_t v6 = 15 - 16 * ((a4 & 0xffffffff) + 30) / 16 + (int64_t)&v5 & -16; // 0xcd1b
        int64_t str3; // bp-808, 0xcc9e
        int64_t v7 = &str3;
        int32_t address_family = a1;
        int64_t * address = (int64_t *)v6;
        int32_t v8 = a4;
        int32_t v9 = 0; // 0xcea6
        int64_t v10 = 16; // 0xcc9e
        while (true) {
            // 0xcf72
            int64_t str2; // bp-536, 0xcc9e
            char * str = fgets((char *)&str2, (int32_t)&g36, stream); // 0xcf88
            v3 = v9;
            if (str == NULL) {
                // break (via goto) -> 0xcf99
                goto lab_0xcf99;
            }
            // 0xcf72
            while (sscanf((char *)&str2, "nameserver%*[ \t]%256s", &str3, (int64_t *)v10, (char **)a5) != 1) {
                // 0xcf72
                str = fgets((char *)&str2, (int32_t)&g36, stream);
                v3 = v9;
                if (str == NULL) {
                    // break (via goto) -> 0xcf99
                    goto lab_0xcf99;
                }
            }
            char * found_char_pos = strchr((char *)&str3, 37); // 0xcdc8
            int32_t v11 = 0; // 0xcddc
            int32_t v12; // 0xcdec
            if (found_char_pos != NULL) {
                // 0xcdde
                v12 = if_nametoindex((char *)((int64_t)found_char_pos + 1));
                *found_char_pos = 0;
                v11 = v12;
            }
            int32_t v13 = inet_pton(address_family, (char *)&str3, address); // 0xce26
            int64_t v14 = v7; // 0xce2d
            while (v13 == 0) {
                str = fgets((char *)&str2, (int32_t)&g36, stream);
                v3 = v9;
                if (str == NULL) {
                    // break (via goto) -> 0xcf99
                    goto lab_0xcf99;
                }
                // 0xcf72
                while (sscanf((char *)&str2, "nameserver%*[ \t]%256s", &str3, (int64_t *)v14, (char **)a5) != 1) {
                    // 0xcf72
                    str = fgets((char *)&str2, (int32_t)&g36, stream);
                    v3 = v9;
                    if (str == NULL) {
                        // break (via goto) -> 0xcf99
                        goto lab_0xcf99;
                    }
                }
                // 0xcdb9
                found_char_pos = strchr((char *)&str3, 37);
                v11 = 0;
                if (found_char_pos != NULL) {
                    // 0xcdde
                    v12 = if_nametoindex((char *)((int64_t)found_char_pos + 1));
                    *found_char_pos = 0;
                    v11 = v12;
                }
                // 0xce0d
                v13 = inet_pton(address_family, (char *)&str3, address);
                v14 = v7;
            }
            int64_t v15 = v7; // 0xce3b
            if (v9 == 0) {
                // 0xce3d
                memcpy((int64_t *)a2, address, v8);
                memcpy(a3, address, v8);
                if (a5 != 0) {
                    // 0xce85
                    *(int32_t *)a5 = v11;
                }
                // 0xce94
                *(int32_t *)a6 = *(int32_t *)&g60;
                v15 = v6;
            }
            int64_t v16 = v15;
            v9++;
            int32_t v17 = *(int32_t *)&g58;
            if (v9 >= 4) {
                // 0xceb6
                v3 = 1;
                if ((v17 & 2) == 0) {
                    goto lab_0xcf99;
                } else {
                    // 0xceca
                    function_3080("Slirp", 128, "  (more)", v16, a5, v4);
                    v3 = 1;
                    goto lab_0xcf99;
                }
            }
            int64_t v18 = v16; // 0xcefa
            if ((v17 & 2) != 0) {
                // 0xcefc
                int64_t address_str; // bp-856, 0xcc9e
                char * v19 = inet_ntop(address_family, address, (char *)&address_str, 46); // 0xcf17
                v18 = 46;
                if ((*(int32_t *)&g58 & 2) != 0) {
                    int64_t v20 = v19 != NULL ? (int64_t)v19 : (int64_t)"  (string conversion error)";
                    function_3080("Slirp", 128, "  %s", v20, a5, v4);
                    v18 = v20;
                }
            }
            // 0xcf72
            v10 = v18;
        }
    } else {
        goto lab_0xcfbd;
    }
  lab_0xcf99:
    // 0xcf99
    fclose(stream);
    v2 = v3 != 0 ? 0 : 0xffffffff;
    goto lab_0xcfbd;
  lab_0xcfbd:;
    int64_t result = v2; // 0xcfca
    if (v1 != __readfsqword(40)) {
        // 0xcfcc
        __stack_chk_fail();
        result = &g91;
    }
    // 0xcfd1
    return result;
}

// Address range: 0xcfd3 - 0xd049
int64_t function_cfd3(int64_t a1) {
    // 0xcfd3
    if (*(int32_t *)&g50 == 0) {
        // 0xd047
        return function_cc9e(2, a1, &g50, 4, 0, &g52);
    }
    int64_t v1 = function_caba(a1, &g50, 4, &g54, &g52); // 0xd00a
    int32_t v2 = v1; // 0xd00f
    if (v2 >= 0 == (v2 != 0)) {
        // 0xd047
        return function_cc9e(2, a1, &g50, 4, 0, &g52);
    }
    // 0xd047
    return v1 & 0xffffffff;
}

// Address range: 0xd049 - 0xd107
int64_t function_d049(int64_t * a1, int64_t * a2) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = __readfsqword(40); // 0xd059
    int64_t v3 = 0; // bp-40, 0xd068
    int64_t v4; // 0xd049
    int64_t v5; // 0xd0ec
    if ((char)function_ca4b(&g51, &v3) == 1) {
        // 0xd0c6
        v5 = function_cc9e(10, v1, &g51, 16, (int64_t)a2, &g53);
        v4 = v5;
        goto lab_0xd0f1;
    } else {
        int64_t v6 = function_caba(v1, &g51, 16, &g55, &g53); // 0xd0b3
        int32_t v7 = v6; // 0xd0b8
        if (v7 >= 0 == (v7 != 0)) {
            // 0xd0c6
            v5 = function_cc9e(10, v1, &g51, 16, (int64_t)a2, &g53);
            v4 = v5;
            goto lab_0xd0f1;
        } else {
            // 0xd0c1
            v4 = v6 & 0xffffffff;
            goto lab_0xd0f1;
        }
    }
  lab_0xd0f1:;
    int64_t result = v4; // 0xd0fe
    if (v2 != __readfsqword(40)) {
        // 0xd100
        __stack_chk_fail();
        result = &g91;
    }
    // 0xd105
    return result;
}

// Address range: 0xd107 - 0xd1fc
int64_t function_d107(void) {
    int64_t v1 = __readfsqword(40); // 0xd10f
    if (g56 == 0) {
        // 0xd12c
        g56 = 1;
        *(int32_t *)&g59 = htonl(0x7f000001);
        g57 = htonl(-0x1000000);
        int64_t v2 = function_3150("SLIRP_DEBUG"); // 0xd168
        if (v2 != 0) {
            char * v3 = "call"; // bp-88, 0xd17f
            int64_t v4 = function_3030(v2, (int64_t *)&v3, 4, (int64_t *)&v3); // 0xd1d3
            *(int32_t *)&g58 = (int32_t)v4;
        }
    }
    int64_t result = 0; // 0xd1f3
    if (v1 != __readfsqword(40)) {
        // 0xd1f5
        __stack_chk_fail();
        result = &g91;
    }
    // 0xd1fa
    return result;
}

// Address range: 0xd1fc - 0xd625
int64_t slirp_new(int64_t a1, int64_t a2, int64_t a3) {
    // 0xd1fc
    if (a1 == 0) {
        // 0xd217
        function_2ec0("Slirp", "slirp_new", "cfg != NULL");
        // 0xd623
        return 0;
    }
    // 0xd23b
    int64_t v1; // 0xd1fc
    uint32_t v2 = (int32_t)v1;
    if (v2 == 0) {
        // 0xd245
        function_2ec0("Slirp", "slirp_new", "cfg->version >= SLIRP_CONFIG_VERSION_MIN");
        // 0xd623
        return 0;
    }
    if (v2 >= 2) {
        // 0xd274
        function_2ec0("Slirp", "slirp_new", "cfg->version <= SLIRP_CONFIG_VERSION_MAX");
        // 0xd623
        return 0;
    }
    int64_t * v3 = (int64_t *)(a1 + 136); // 0xd29c
    uint64_t v4 = *v3; // 0xd29c
    if (v4 <= 67) {
        // 0xd2b9
        function_2ec0("Slirp", "slirp_new", "cfg->if_mtu >= IF_MTU_MIN || cfg->if_mtu == 0");
        // 0xd623
        return 0;
    }
    if (v4 >= 0xfff2) {
        // 0xd2f0
        function_2ec0("Slirp", "slirp_new", "cfg->if_mtu <= IF_MTU_MAX");
        // 0xd623
        return 0;
    }
    int64_t * v5 = (int64_t *)(a1 + 144); // 0xd318
    uint64_t v6 = *v5; // 0xd318
    if (v6 <= 67) {
        // 0xd335
        function_2ec0("Slirp", "slirp_new", "cfg->if_mru >= IF_MRU_MIN || cfg->if_mru == 0");
        // 0xd623
        return 0;
    }
    if (v6 >= 0xfff2) {
        // 0xd36c
        function_2ec0("Slirp", "slirp_new", "cfg->if_mru <= IF_MRU_MAX");
        // 0xd623
        return 0;
    }
    int64_t result = function_3100(&g10); // 0xd395
    function_d107();
    *(int64_t *)(result + (int64_t)&g9) = a3;
    *(int64_t *)(result + (int64_t)&g8) = a2;
    int64_t v7 = function_2f80(); // 0xd3c1
    *(int64_t *)(result + (int64_t)&g5) = v7;
    *(int32_t *)(result + 124) = *(int32_t *)(a1 + 4);
    *(char *)(result + 9) = *(char *)(a1 + 8);
    *(char *)(result + 10) = *(char *)(a1 + 24);
    function_5e6b(result);
    function_929d(result);
    function_7e9d(result);
    function_a28a(result);
    *(int32_t *)(result + 12) = *(int32_t *)(a1 + 12);
    *(int32_t *)(result + 16) = *(int32_t *)(a1 + 16);
    *(int32_t *)(result + 20) = *(int32_t *)(a1 + 20);
    *(int64_t *)(result + 24) = *(int64_t *)(a1 + 28);
    *(int64_t *)(result + 32) = *(int64_t *)(a1 + 36);
    *(char *)(result + 40) = *(char *)(a1 + 44);
    *(int64_t *)(result + 44) = *(int64_t *)(a1 + 48);
    *(int64_t *)(result + 52) = *(int64_t *)(a1 + 56);
    int64_t v8 = *(int64_t *)(a1 + 64); // 0xd49d
    if (v8 != 0) {
        // 0xd4a6
        function_1c2cc(result + 88, 33, v8);
    }
    int64_t v9 = function_3140(*(int64_t *)(a1 + 80)); // 0xd4d1
    *(int64_t *)(result + (int64_t)&g86) = v9;
    *(int64_t *)(result + 416) = function_3140(*(int64_t *)(a1 + 88));
    *(int64_t *)(result + 440) = function_3140(*(int64_t *)(a1 + 128));
    *(int32_t *)(result + 60) = *(int32_t *)(a1 + 96);
    *(int32_t *)(result + 64) = *(int32_t *)(a1 + 100);
    *(int64_t *)(result + 68) = *(int64_t *)(a1 + 104);
    *(int64_t *)(result + 76) = *(int64_t *)(a1 + 112);
    int64_t v10 = function_3140(*(int64_t *)(a1 + 72)); // 0xd562
    *(int64_t *)(result + (int64_t)&g2) = v10;
    int64_t v11 = *(int64_t *)(a1 + 120); // 0xd579
    if (v11 != 0) {
        // 0xd582
        function_58e0(result, v11);
    }
    int64_t v12 = *v3; // 0xd59d
    int64_t v13 = v12 == 0 ? (int64_t)&g83 : v12;
    *(int32_t *)(result + 136) = (int32_t)v13;
    int64_t v14 = *v5; // 0xd5cb
    int64_t v15 = v14 == 0 ? (int64_t)&g83 : v14;
    *(int32_t *)(result + 140) = (int32_t)v15;
    *(char *)(result + 144) = *(char *)(a1 + 152);
    *(char *)(result + (int64_t)&g7) = *(char *)(a1 + 153);
    // 0xd623
    return result;
}

// Address range: 0xd625 - 0xd809
int64_t slirp_init(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int32_t a9, int64_t a10, int64_t a11, int64_t a12, int64_t a13, int64_t a14, int64_t a15, int32_t a16, int32_t a17, int64_t a18, int64_t a19, int64_t a20, int64_t a21, int64_t a22, int64_t a23) {
    int64_t v1 = __readfsqword(40); // 0xd6c6
    int64_t v2; // bp-184, 0xd625
    memset(&v2, 0, 160);
    v2 = 1;
    int64_t result = function_2cf0(&v2, a22, a23); // 0xd800
    if (v1 != __readfsqword(40)) {
        // 0xd802
        __stack_chk_fail();
        result = &g91;
    }
    // 0xd807
    return result;
}

// Address range: 0xd809 - 0xd8ef
int64_t slirp_cleanup(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 128); // 0xd819
    if (v1 != 0) {
        int64_t v2 = *(int64_t *)(v1 + 32); // 0xd82a
        function_2d70(*(int64_t *)(v1 + 24));
        function_2d70(v1);
        while (v2 != 0) {
            int64_t v3 = v2;
            v2 = *(int64_t *)(v3 + 32);
            function_2d70(*(int64_t *)(v3 + 24));
            function_2d70(v3);
        }
    }
    // 0xd85d
    function_92fc(a1);
    function_7eb8(a1);
    function_a2ed(a1);
    function_2e90(*(int64_t *)(a1 + (int64_t)&g5));
    function_2d70(*(int64_t *)(a1 + 432));
    function_2d70(*(int64_t *)(a1 + (int64_t)&g86));
    function_2d70(*(int64_t *)(a1 + 416));
    function_2d70(*(int64_t *)(a1 + 440));
    return function_2d70(a1);
}

// Address range: 0xd8ef - 0xd95f
int64_t function_d8ef(int64_t a1, int64_t result) {
    // 0xd8ef
    int64_t v1; // 0xd8ef
    uint32_t v2 = (int32_t)v1;
    if (v2 < 3) {
        // 0xd95d
        return v1 & 0xffffffff;
    }
    int64_t v3; // 0xd8ef
    if ((int32_t)v3 == 0) {
        uint32_t v4 = v2 < (int32_t)&g75 ? v2 : (int32_t)&g75; // 0xd916
        char v5 = *(char *)(a1 + 8); // 0xd936
        int32_t v6 = v4 < (int32_t)&g32 | v5 == 0 ? v4 : (int32_t)&g32;
        *(int32_t *)result = v6;
    } else {
        // 0xd926
        *(int32_t *)result = 2;
    }
    // 0xd95d
    return result;
}

// Address range: 0xd95f - 0xdcdb
int64_t slirp_pollfds_fill(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1 + 448; // 0xd97b
    int64_t * v2 = (int64_t *)v1; // 0xd97b
    char v3 = 1; // 0xd990
    if (*v2 == v1) {
        int64_t v4 = a1 + 248; // 0xd996
        v3 = v4 != *(int64_t *)v4;
    }
    char * v5 = (char *)(a1 + 8); // 0xd9c0
    *v5 = v3;
    int64_t v6 = *v2; // 0xd9c7
    int64_t v7; // 0xd95f
    int64_t v8; // 0xd9e2
    if (v6 != v1) {
        int32_t * v9 = (int32_t *)a1;
        int32_t v10 = a3;
        v7 = v6;
        while (true) {
          lab_0xd9d7:;
            int64_t v11 = v7;
            v8 = *(int64_t *)v11;
            int32_t * v12 = (int32_t *)(v11 + 32); // 0xd9ed
            *v12 = -1;
            int64_t v13; // 0xd95f
            if (*(int32_t *)&v13 == 0) {
                // 0xd9fe
                if ((*(int16_t *)(*(int64_t *)(v11 + 336) + 36) & 2) != 0) {
                    // 0xda17
                    *v9 = *(int32_t *)&g60;
                }
            }
            uint32_t v14 = *(int32_t *)(v11 + 332); // 0xda2a
            if (v14 % 2 != 0) {
                goto lab_0xdb34;
            } else {
                // 0xda3b
                if (*(int32_t *)(v11 + 16) == -1) {
                    goto lab_0xdb34;
                } else {
                    if ((v14 & 256) == 0) {
                        if ((v14 & 2) == 0) {
                            int32_t v15 = 0; // 0xdac8
                            if ((v14 & 20) == 4) {
                                // 0xdaca
                                v15 = *(int32_t *)(v11 + 360) == 0 ? 0 : 10;
                            }
                            int32_t v16 = v15;
                            if ((v14 & 12) != 4) {
                                if (v16 == 0) {
                                    goto lab_0xdb34;
                                } else {
                                    // 0xdb12
                                    *v12 = v10;
                                    goto lab_0xdb34;
                                }
                            } else {
                                uint32_t v17 = *(int32_t *)(v11 + 396); // 0xdafc
                                if (v16 == 0 == *(int32_t *)(v11 + 392) >= v17 / 2) {
                                    goto lab_0xdb34;
                                } else {
                                    // 0xdb12
                                    *v12 = v10;
                                    goto lab_0xdb34;
                                }
                            }
                        } else {
                            // 0xda95
                            *v12 = v10;
                            goto lab_0xdb34;
                        }
                    } else {
                        // 0xda5e
                        *v12 = v10;
                        goto lab_0xdb34;
                    }
                }
            }
        }
    }
  lab_0xdb50:;
    int64_t v18 = a1 + (int64_t)&g71; // 0xdb54
    int64_t v19 = *(int64_t *)v18; // 0xdb54
    int64_t v20; // 0xd95f
    int64_t v21; // 0xd95f
    int32_t v22; // 0xd95f
    int64_t v23; // 0xdb68
    int32_t * v24; // 0xdb73
    if (v19 != v18) {
        // 0xdb64
        v22 = a3;
        v20 = v19;
        while (true) {
          lab_0xdb64:
            // 0xdb64
            v21 = v20;
            v23 = *(int64_t *)v21;
            v24 = (int32_t *)(v21 + 32);
            *v24 = -1;
            uint32_t v25 = *(int32_t *)(v21 + 344); // 0xdb7e
            if (v25 == 0) {
                goto lab_0xdbb5;
            } else {
                // 0xdb88
                if (v25 > *(int32_t *)&g60) {
                    // 0xdbad
                    *v5 = 1;
                    goto lab_0xdbb5;
                } else {
                    // 0xdb9f
                    function_1b3c9(v21);
                    goto lab_0xdbf6;
                }
            }
        }
    }
  lab_0xdc12:;
    int64_t v26 = a1 + (int64_t)&g79; // 0xdc16
    int64_t v27 = *(int64_t *)v26; // 0xdc16
    if (v27 == v26) {
        // 0xdcc5
        return function_d8ef(a1, a2);
    }
    int64_t v28 = v27; // 0xd95f
    int64_t v29; // 0xd95f
    int64_t v30; // 0xdc2a
    int32_t * v31; // 0xdc35
    while (true) {
      lab_0xdc26:
        // 0xdc26
        v29 = v28;
        v30 = *(int64_t *)v29;
        v31 = (int32_t *)(v29 + 32);
        *v31 = -1;
        uint32_t v32 = *(int32_t *)(v29 + 344); // 0xdc40
        if (v32 == 0) {
            goto lab_0xdc77;
        } else {
            // 0xdc4a
            if (v32 > *(int32_t *)&g60) {
                // 0xdc6f
                *v5 = 1;
                goto lab_0xdc77;
            } else {
                // 0xdc61
                function_84c1(v29);
                goto lab_0xdca9;
            }
        }
    }
  lab_0xdcc5:
    // 0xdcc5
    return function_d8ef(a1, a2);
  lab_0xdc77:
    // 0xdc77
    if ((*(int32_t *)(v29 + 332) & 4) != 0) {
        // 0xdc88
        *v31 = (int32_t)a3;
    }
    goto lab_0xdca9;
  lab_0xdca9:
    // 0xdca9
    v28 = v30;
    if (v30 == v26) {
        // break -> 0xdcc5
        goto lab_0xdcc5;
    }
    goto lab_0xdc26;
  lab_0xdbb5:
    // 0xdbb5
    if ((*(int32_t *)(v21 + 332) & 4) != 0) {
        // 0xdbc6
        if (*(int32_t *)(v21 + 348) <= 4) {
            // 0xdbd5
            *v24 = v22;
        }
    }
    goto lab_0xdbf6;
  lab_0xdbf6:
    // 0xdbf6
    v20 = v23;
    if (v23 == v18) {
        // break -> 0xdc12
        goto lab_0xdc12;
    }
    goto lab_0xdb64;
  lab_0xdb34:
    // 0xdb34
    v7 = v8;
    if (v8 == v1) {
        // break -> 0xdb50
        goto lab_0xdb50;
    }
    goto lab_0xd9d7;
}

// Address range: 0xdcdb - 0xe15c
int64_t slirp_pollfds_poll(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0xdcf2
    int64_t v2; // 0xdcdb
    if ((int32_t)v2 != 0) {
        // 0xdd71
        function_19297(a1);
        *(int32_t *)a1 = 0;
    }
    // 0xdd87
    if (*(char *)(a1 + 8) != 0) {
        int32_t * v3 = (int32_t *)(a1 + 4); // 0xdda0
        if (*(int32_t *)&g60 - *v3 > (int32_t)&g31) {
            // 0xddae
            function_9d58(a1);
            function_1933b(a1);
            *v3 = *(int32_t *)&g60;
        }
    }
    int64_t v4; // 0xdcdb
    int32_t buf; // bp-48, 0xdcdb
    int64_t v5; // 0xdcdb
    int64_t v6; // 0xdcdb
    int64_t v7; // 0xddf8
    int32_t * v8; // 0xde2f
    int32_t * sock; // 0xde44
    int64_t v9; // 0xdde4
    if ((int32_t)a2 == 0) {
        // 0xdde0
        v9 = a1 + 448;
        int64_t v10 = *(int64_t *)v9; // 0xdde4
        if (v10 != v9) {
            // 0xddf4
            v5 = v10;
            while (true) {
              lab_0xddf4:
                // 0xddf4
                v6 = v5;
                v7 = *(int64_t *)v6;
                v8 = (int32_t *)(v6 + 332);
                uint32_t v11 = *v8; // 0xde2f
                if (v11 % 2 != 0) {
                    goto lab_0xe019;
                } else {
                    // 0xde40
                    sock = (int32_t *)(v6 + 16);
                    if (*sock == -1) {
                        goto lab_0xe019;
                    } else {
                        int32_t v12 = *(int32_t *)(v6 + 32); // 0xde0a
                        v4 = v12 == -1 ? 0 : 0x100000000 * a3 / 0x100000000;
                        if ((v4 & 4) == 0) {
                            if ((v4 & 25) == 0) {
                                goto lab_0xded7;
                            } else {
                                if ((v11 & 256) == 0) {
                                    int32_t v13 = function_fc35(v6); // 0xdeaf
                                    buf = v13;
                                    int32_t v14 = v13; // 0xdeb7
                                    if (v13 >= 1) {
                                        // 0xdeb9
                                        function_15563(*(int64_t *)(v6 + 336));
                                        v14 = buf;
                                    }
                                    // 0xdecc
                                    if (v14 < 0) {
                                        goto lab_0xe019;
                                    } else {
                                        goto lab_0xded7;
                                    }
                                } else {
                                    // 0xde92
                                    function_17600(v6);
                                    goto lab_0xe019;
                                }
                            }
                        } else {
                            int32_t v15 = function_10238(v6); // 0xde66
                            buf = v15;
                            if (v15 >= 0) {
                                goto lab_0xded7;
                            } else {
                                goto lab_0xe019;
                            }
                        }
                    }
                }
            }
        }
      lab_0xe035:;
        int64_t v16 = a1 + (int64_t)&g71; // 0xe039
        int64_t v17 = *(int64_t *)v16; // 0xe039
        if (v17 != v16) {
            int64_t v18 = *(int64_t *)v17; // 0xe04a
            int32_t v19 = *(int32_t *)(v17 + 16); // 0xe081
            if (!((v19 == -1 | (a3 & 25) == 0 | *(int32_t *)(v17 + 32) == -1))) {
                // 0xe093
                function_10a5a(v17);
            }
            while (v18 != v16) {
                int64_t v20 = v18;
                v18 = *(int64_t *)v20;
                v19 = *(int32_t *)(v20 + 16);
                if (!((v19 == -1 | (a3 & 25) == 0 | *(int32_t *)(v20 + 32) == -1))) {
                    // 0xe093
                    function_10a5a(v20);
                }
            }
        }
        int64_t v21 = a1 + (int64_t)&g79; // 0xe0bb
        int64_t v22 = *(int64_t *)v21; // 0xe0bb
        if (v22 != v21) {
            int64_t v23 = *(int64_t *)v22; // 0xe0cc
            int32_t v24 = *(int32_t *)(v22 + 16); // 0xe103
            if (!((v24 == -1 | (a3 & 25) == 0 | *(int32_t *)(v22 + 32) == -1))) {
                // 0xe115
                function_9096(v22);
            }
            while (v23 != v21) {
                int64_t v25 = v23;
                v23 = *(int64_t *)v25;
                v24 = *(int32_t *)(v25 + 16);
                if (!((v24 == -1 | (a3 & 25) == 0 | *(int32_t *)(v25 + 32) == -1))) {
                    // 0xe115
                    function_9096(v25);
                }
            }
        }
    }
    // 0xe139
    function_6168(a1);
    int64_t result = 0; // 0xe153
    if (v1 != __readfsqword(40)) {
        // 0xe155
        __stack_chk_fail();
        result = &g91;
    }
    // 0xe15a
    return result;
  lab_0xe019:
    // 0xe019
    v5 = v7;
    if (v7 == v9) {
        // break -> 0xe035
        goto lab_0xe035;
    }
    goto lab_0xddf4;
  lab_0xded7:;
    uint32_t v26 = *v8; // 0xdedb
    if ((v4 & 10) == 0 || v26 % 2 != 0) {
        goto lab_0xe019;
    } else {
        if ((v26 & 2) == 0) {
            int32_t v27 = function_106a3(v6); // 0xdff3
            buf = v27;
            if (v27 >= 1) {
                // 0xdffd
                function_15563(*(int64_t *)(v6 + 336));
            }
            goto lab_0xe019;
        } else {
            // 0xdf0f
            *v8 = v26 & -3;
            int32_t v28 = send(*sock, (int64_t *)&buf, 0, 0); // 0xdf3f
            buf = v28;
            if (v28 >= 0) {
                // 0xdfc2
                function_12cfb(0, 20, v6, (int64_t)*(int16_t *)(v6 + 72));
                goto lab_0xe019;
            } else {
                // 0xdf4e
                if (*__errno_location() == 11) {
                    goto lab_0xe019;
                } else {
                    // 0xdf5e
                    if (*__errno_location() == 11) {
                        goto lab_0xe019;
                    } else {
                        // 0xdf6e
                        if (*__errno_location() == 115) {
                            goto lab_0xe019;
                        } else {
                            // 0xdf7e
                            if (*__errno_location() == 107) {
                                goto lab_0xe019;
                            } else {
                                // 0xdf8e
                                *v8 = *v8 & 0xf000 | 1;
                                // 0xdfc2
                                function_12cfb(0, 20, v6, (int64_t)*(int16_t *)(v6 + 72));
                                goto lab_0xe019;
                            }
                        }
                    }
                }
            }
        }
    }
}

// Address range: 0xe15c - 0xe448
int64_t function_e15c(int64_t a1, int64_t a2, int32_t a3) {
    int64_t v1 = __readfsqword(40); // 0xe17b
    int32_t * v2; // 0xe1f5
    int32_t * v3; // 0xe1fc
    if (*(char *)(a1 + 9) != 1) {
        goto lab_0xe432;
    } else {
        // 0xe1c3
        int16_t net_short; // 0xe1c7
        switch (ntohs(net_short)) {
            case 1: {
                // 0xe1f1
                v2 = (int32_t *)(a2 + 38);
                int32_t v4 = *v2; // 0xe1f5
                v3 = (int32_t *)(a2 + 28);
                uint32_t v5 = *v3; // 0xe1fc
                if (v4 != v5) {
                    // 0xe228
                    if ((*(int32_t *)(a1 + 16) & v4) != *(int32_t *)(a1 + 12)) {
                        goto lab_0xe432;
                    } else {
                        // 0xe24d
                        if (v4 == *(int32_t *)(a1 + 64)) {
                            goto lab_0xe2b9;
                        } else {
                            // 0xe262
                            if (v4 == *(int32_t *)(a1 + 20)) {
                                goto lab_0xe2b9;
                            } else {
                                int64_t v6 = *(int64_t *)(a1 + 128);
                                int64_t v7 = v6; // 0xe2ae
                                if (v6 != 0) {
                                    while (*(int32_t *)(v7 + 16) != v4) {
                                        int64_t v8 = *(int64_t *)(v7 + 32);
                                        v7 = v8;
                                        if (v8 == 0) {
                                            goto lab_0xe432;
                                        }
                                    }
                                    goto lab_0xe2b9;
                                } else {
                                    goto lab_0xe432;
                                }
                            }
                        }
                    }
                } else {
                    // 0xe203
                    function_32ba(a1, (int64_t)v5, (int32_t *)(a2 + 22));
                    goto lab_0xe432;
                }
            }
            case 2: {
                // 0xe40c
                function_32ba(a1, (int64_t)*(int32_t *)(a2 + 28), (int32_t *)(a2 + 22));
                goto lab_0xe432;
            }
            default: {
                goto lab_0xe432;
            }
        }
    }
  lab_0xe432:;
    int64_t result = 0; // 0xe43f
    if (v1 != __readfsqword(40)) {
        // 0xe441
        __stack_chk_fail();
        result = &g91;
    }
    // 0xe446
    return result;
  lab_0xe2b9:;
    // 0xe2b9
    int64_t v9; // bp-88, 0xe15c
    int64_t v10 = &v9; // 0xe19d
    memset(&v9, 0, 64);
    int64_t v11 = a2 + 22; // 0xe2d3
    function_32ba(a1, (int64_t)*v3, (int32_t *)v11);
    memcpy(&v9, (int64_t *)(a2 + 6), 6);
    int64_t v12 = v10 | 6; // 0xe312
    *(int16_t *)v12 = 0x5552;
    *(int32_t *)(v10 + 8) = *v2;
    *(int16_t *)(v10 + 12) = htons((int16_t)&g90);
    int64_t v13; // bp-74, 0xe15c
    *(int16_t *)&v13 = htons(1);
    int16_t v14 = htons((int16_t)&g89); // 0xe360
    int64_t v15 = &v13; // 0xe367
    *(int16_t *)(v15 | 2) = v14;
    *(char *)(v15 | 4) = 6;
    *(char *)(v15 | 5) = 4;
    *(int16_t *)(v15 | 6) = htons(2);
    memcpy((int64_t *)(v15 + 8), (int64_t *)v12, 6);
    *(int32_t *)(v15 + 14) = *v2;
    memcpy((int64_t *)(v15 + 18), (int64_t *)v11, 6);
    *(int32_t *)(v15 + 24) = *v3;
    function_f245(a1, &v9, 64);
    goto lab_0xe432;
}

// Address range: 0xe448 - 0xe629
int64_t slirp_input(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result; // 0xe448
    if ((int32_t)a3 < 14) {
        // 0xe627
        return result;
    }
    int64_t v1 = 0x100000000 * a3 / 0x100000000; // 0xe458
    unsigned char v2 = *(char *)(a2 + 13); // 0xe480
    int32_t v3 = 256 * (int32_t)*(char *)(a2 + 12) | (int32_t)v2; // 0xe486
    if (v3 == (int32_t)&g90) {
        // 0xe627
        return function_e15c(a1, a2, (int32_t)v1);
    }
    int64_t result2 = v3; // 0xe48b
    if (v3 > (int32_t)&g90) {
        // 0xe4a8
        result = result2;
        switch ((int16_t)v3) {
            case -0x7923: {
                goto lab_0xe4da;
            }
            case -0x7708: {
                // 0xe627
                return function_b9d7(a1, a2, (int32_t)v1);
            }
            default: {
                return result;
            }
        }
    } else {
        // 0xe49c
        if (v3 != (int32_t)&g89) {
            // 0xe627
            return result2;
        }
        goto lab_0xe4da;
    }
  lab_0xe4da:;
    int64_t v4 = function_a39a(a1); // 0xe4e1
    if (v4 == 0) {
        // 0xe627
        return 0;
    }
    // 0xe4f5
    int64_t v5; // 0xe448
    if (*(int32_t *)(v4 + 32) % 2 == 0) {
        int64_t v6 = *(int64_t *)(v4 + 48); // 0xe545
        v5 = v4 + 96 + (int64_t)*(int32_t *)(v4 + 36) - v6;
    } else {
        int32_t v7 = *(int32_t *)(v4 + 36); // 0xe50f
        int64_t v8 = *(int64_t *)(v4 + 48); // 0xe51e
        v5 = *(int64_t *)(v4 + 88) + (int64_t)v7 - v8;
    }
    int32_t * v9 = (int32_t *)(v4 + 56); // 0xe553
    uint64_t v10 = v1 + 30; // 0xe564
    if (v5 - (int64_t)*v9 < v10) {
        // 0xe56d
        function_a70b(v4, v10 & 0xffffffff);
    }
    int32_t v11 = v1; // 0xe583
    *v9 = v11 + 30;
    int64_t * v12 = (int64_t *)(v4 + 48); // 0xe59c
    memcpy((int64_t *)(*v12 + 30), (int64_t *)a2, v11);
    *v12 = *v12 + 44;
    *v9 = *v9 - 44;
    if (v3 == (int32_t)&g89) {
        // 0xe627
        return function_932f(v4);
    }
    // 0xe5f1
    result = v4;
    if (v3 == 0x86dd) {
        // 0xe5fa
        result = function_7ed3(v4);
    }
    // 0xe627
    return result;
}

// Address range: 0xe629 - 0xe86b
int64_t function_e629(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    int64_t v1 = __readfsqword(40); // 0xe641
    int32_t * v2 = (int32_t *)(*(int64_t *)(a2 + 48) + 16); // 0xe660
    uint32_t v3 = *v2; // 0xe660
    int64_t v4 = 1; // 0xe665
    if (v3 != 0) {
        // 0xe671
        if ((char)function_350e(a1, (int64_t)v3, (int64_t)a4) == 1) {
            // 0xe816
            *(int16_t *)(a3 + 6) = 0x5552;
            *(int32_t *)(a3 + 8) = *(int32_t *)(a1 + 20);
            *(int16_t *)(a3 + 12) = htons((int16_t)&g89);
            v4 = 2;
        } else {
            char * v5 = (char *)(a2 + 72); // 0xe6ad
            v4 = 0;
            if (*v5 != 1) {
                // 0xe6bc
                int64_t v6; // bp-72, 0xe629
                int64_t v7 = &v6; // 0xe699
                memset(&v6, 255, 6);
                *(int16_t *)(v7 | 6) = 0x5552;
                int32_t * v8 = (int32_t *)(a1 + 20); // 0xe6f4
                *(int32_t *)(v7 + 8) = *v8;
                *(int16_t *)(v7 + 12) = htons((int16_t)&g90);
                int64_t v9; // bp-58, 0xe629
                *(int16_t *)&v9 = htons(1);
                int16_t v10 = htons((int16_t)&g89); // 0xe724
                int64_t v11 = &v9; // 0xe72b
                *(int16_t *)(v11 | 2) = v10;
                *(char *)(v11 | 4) = 6;
                *(char *)(v11 | 5) = 4;
                *(int16_t *)(v11 | 6) = htons(1);
                *(int16_t *)(v11 + 8) = 0x5552;
                *(int32_t *)(v11 + 10) = *v8;
                *(int32_t *)(v11 + 14) = *v8;
                memset((int64_t *)(v11 + 18), 0, 6);
                *(int32_t *)(v11 + 24) = *v2;
                *(int32_t *)(a1 + 84) = *v2;
                function_f245(a1, &v6, 42);
                *v5 = 1;
                int64_t v12 = *(int64_t *)(*(int64_t *)(a1 + (int64_t)&g8) + 16); // 0xe7ec
                *(int64_t *)(a2 + 80) = v12 + 0x3b9aca00;
                v4 = 0;
            }
        }
    }
    int64_t result = v4; // 0xe862
    if (v1 != __readfsqword(40)) {
        // 0xe864
        __stack_chk_fail();
        result = &g91;
    }
    // 0xe869
    return result;
}

// Address range: 0xe86b - 0xe953
int64_t function_e86b(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    int64_t v1 = *(int64_t *)(a2 + 48); // 0xe887
    int64_t * v2 = (int64_t *)(v1 + 24); // 0xe897
    int64_t * v3 = (int64_t *)(v1 + 32); // 0xe89b
    if ((char)function_c04f(a1, *v2, *v3, (int64_t)a4) == 1) {
        // 0xe919
        *(int16_t *)(a3 + 12) = htons(-0x7923);
        function_ca7a(*(int64_t *)(v1 + 8), *(int64_t *)(v1 + 16), a3 + 6);
        // 0xe951
        return 2;
    }
    char * v4 = (char *)(a2 + 72); // 0xe8b6
    if (*v4 != 1) {
        // 0xe8c1
        function_7017(a1, *v2, *v3);
        *v4 = 1;
        int64_t v5 = *(int64_t *)(*(int64_t *)(a1 + (int64_t)&g8) + 16); // 0xe8ef
        *(int64_t *)(a2 + 80) = v5 + 0x3b9aca00;
    }
    // 0xe951
    return 0;
}

// Address range: 0xe953 - 0xec37
int64_t function_e953(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0xe96c
    int32_t * v2 = (int32_t *)(a2 + 56); // 0xe9a2
    int64_t v3 = 1; // 0xe9ad
    int64_t v4; // 0xe953
    int64_t v5; // bp-65640, 0xe953
    int32_t v6; // bp-65646, 0xe953
    if (*v2 < 0x10048) {
        // 0xe9b9
        unsigned char v7; // 0xe9c0
        switch (v7 / 16) {
            case 4: {
                int64_t v8 = &v5;
                int64_t v9 = function_e629(a1, a2, v8, (int64_t *)&v6); // 0xe9f4
                v4 = v8;
                v3 = v9;
                if ((int32_t)v9 > 1) {
                    goto lab_0xea7a;
                } else {
                    goto lab_0xec21;
                }
            }
            case 6: {
                int64_t v10 = &v5;
                int64_t v11 = function_e86b(a1, a2, v10, (int64_t *)&v6); // 0xea32
                v4 = v10;
                v3 = v11;
                if ((int32_t)v11 > 1) {
                    goto lab_0xea7a;
                } else {
                    goto lab_0xec21;
                }
            }
            default: {
                // 0xea51
                function_2ea0("Slirp", "../src/slirp.c", (int64_t)&g73, "if_encap", 0);
                v4 = &v5;
                goto lab_0xea7a;
            }
        }
    } else {
        goto lab_0xec21;
    }
  lab_0xec21:;
    int64_t result = v3 & 0xffffffff; // 0xec2e
    if (v1 != __readfsqword(40)) {
        // 0xec30
        __stack_chk_fail();
        result = &g91;
    }
    // 0xec35
    return result;
  lab_0xea7a:
    // 0xea7a
    *(int32_t *)&v5 = v6;
    if (*(int32_t *)&g58 % 2 != 0) {
        unsigned char v12 = *(char *)(v4 + 8); // 0xead9
        unsigned char v13 = *(char *)(v4 | 7); // 0xeae8
        unsigned char v14 = *(char *)(v4 | 6); // 0xeaf6
        function_3080("Slirp", 128, " src = %02x:%02x:%02x:%02x:%02x:%02x", (int64_t)v14, (int64_t)v13, (int64_t)v12);
        if (*(int32_t *)&g58 % 2 != 0) {
            unsigned char v15 = *(char *)(v4 | 2); // 0xeb72
            unsigned char v16 = *(char *)(v4 | 1); // 0xeb81
            unsigned char v17 = *(char *)&v5; // 0xeb8f
            function_3080("Slirp", 128, " dst = %02x:%02x:%02x:%02x:%02x:%02x", (int64_t)v17, (int64_t)v16, (int64_t)v15);
        }
    }
    // 0xebc5
    int64_t v18; // bp-65626, 0xe953
    memcpy(&v18, (int64_t *)*(int64_t *)(a2 + 48), *v2);
    function_f245(a1, &v5, (int64_t)(*v2 + 14));
    v3 = 1;
    goto lab_0xec21;
}

// Address range: 0xec37 - 0xed74
int64_t slirp_remove_hostfwd(int64_t a1, int64_t a2, int64_t a3, int64_t host_short) {
    int64_t v1 = __readfsqword(40); // 0xec4c
    int64_t v2 = ((int32_t)a2 == 0 ? 448 : (int64_t)&g71) + a1;
    int16_t v3 = htons((int16_t)host_short); // 0xec83
    int64_t v4 = *(int64_t *)v2;
    int64_t v5 = 0xffffffff; // 0xed53
    if (v4 != v2) {
        int32_t addr_len = 16; // bp-64, 0xec9e
        int64_t addr; // bp-40, 0xec37
        int32_t v6; // 0xec37
        int32_t v7; // 0xec37
        int32_t * sock; // 0xec37
        int32_t v8; // 0xecd0
        if ((*(int32_t *)(v4 + 332) & (int32_t)"back") != 0) {
            // 0xecbc
            sock = (int32_t *)(v4 + 16);
            v8 = getsockname(*sock, (struct sockaddr *)&addr, &addr_len);
            if (v3 == (int16_t)v6 == v7 == (int32_t)a3 == v8 == 0) {
                // 0xecef
                close(*sock);
                function_f77a(v4);
                v5 = 0;
                goto lab_0xed5e;
            }
        }
        int64_t v9 = *(int64_t *)v4;
        v5 = 0xffffffff;
        while (v9 != v2) {
            int64_t v10 = v9;
            addr_len = 16;
            if ((*(int32_t *)(v10 + 332) & (int32_t)"back") != 0) {
                // 0xecbc
                sock = (int32_t *)(v10 + 16);
                v8 = getsockname(*sock, (struct sockaddr *)&addr, &addr_len);
                if (v3 == (int16_t)v6 == v7 == (int32_t)a3 == v8 == 0) {
                    // 0xecef
                    close(*sock);
                    function_f77a(v10);
                    v5 = 0;
                    goto lab_0xed5e;
                }
            }
            // 0xed40
            v9 = *(int64_t *)v10;
            v5 = 0xffffffff;
        }
    }
    goto lab_0xed5e;
  lab_0xed5e:;
    int64_t result = v5; // 0xed6b
    if (v1 != __readfsqword(40)) {
        // 0xed6d
        __stack_chk_fail();
        result = &g91;
    }
    // 0xed72
    return result;
}

// Address range: 0xed74 - 0xee4d
int64_t slirp_add_hostfwd(int64_t a1, int64_t a2, int64_t a3, int64_t host_short2, int64_t a5, int64_t host_short) {
    int64_t v1 = 0x100000000 * a5 / 0x100000000; // 0xed99
    if ((int32_t)a5 == 0) {
        // 0xed9b
        v1 = (int64_t)*(int32_t *)(a1 + 60);
    }
    uint16_t v2 = htons((int16_t)host_short);
    int64_t v3 = htons((int16_t)host_short2);
    int32_t v4 = a3;
    int64_t v5 = v2;
    int64_t v6 = v1 & 0xffffffff;
    if ((int32_t)a2 == 0) {
        // 0xedf5
        if (function_116c0(a1, v4, v3, v6, v5, "back") == 0) {
            // 0xee44
            return 0xffffffff;
        }
        // 0xee44
        return 0;
    }
    // 0xedab
    if (function_1b58f(a1, v4, v3, v6, v5, "back") == 0) {
        // 0xee44
        return 0xffffffff;
    }
    // 0xee44
    return 0;
}

// Address range: 0xee4d - 0xef2a
int64_t function_ee4d(int64_t a1, int64_t a2, int32_t a3) {
    // 0xee4d
    int64_t v1; // 0xee4d
    int32_t v2 = v1;
    int32_t * v3; // 0xee4d
    int32_t * v4; // 0xee4d
    int32_t v5; // 0xee4d
    if (v2 != 0) {
        // 0xee4d
        v3 = (int32_t *)(a1 + 12);
        v4 = (int32_t *)(a1 + 16);
        v5 = v2;
    } else {
        int32_t * v6 = (int32_t *)(a1 + 12);
        int32_t v7 = htonl((int32_t)&g40); // 0xee77
        int32_t * v8 = (int32_t *)(a1 + 16);
        *(int32_t *)a2 = v7 & -1 - *v8 | *v6;
        v3 = v6;
        v4 = v8;
        int64_t v9; // 0xee4d
        v5 = *(int32_t *)&v9;
    }
    // 0xee93
    if ((*v4 & v5) != *v3 || v5 == *(int32_t *)(a1 + 20) || v5 == *(int32_t *)(a1 + 64)) {
        // 0xef23
        return 0;
    }
    int64_t v10 = *(int64_t *)(a1 + 128);
    if (v10 == 0) {
        // 0xef23
        return 1;
    }
    if (*(int32_t *)(v10 + 20) == a3) {
        // 0xeef3
        if (v5 == *(int32_t *)(v10 + 16)) {
            // break -> 0xef23
            return 0;
        }
    }
    int64_t v11 = *(int64_t *)(v10 + 32);
    int64_t result = 1; // 0xef1c
    while (v11 != 0) {
        int64_t v12 = v11;
        if (*(int32_t *)(v12 + 20) == a3) {
            // 0xeef3
            result = 0;
            if (v5 == *(int32_t *)(v12 + 16)) {
                // break -> 0xef23
                break;
            }
        }
        // 0xef0b
        v11 = *(int64_t *)(v12 + 32);
        result = 1;
    }
    // 0xef23
    return result;
}

// Address range: 0xef2a - 0xef99
int64_t slirp_add_exec(int64_t a1, int64_t a2, int64_t a3, int64_t host_short) {
    int64_t result = 0xffffffff; // 0xef5c
    if ((char)function_ee4d(a1, a3, (int32_t)host_short) == 1) {
        // 0xef65
        int64_t v1; // 0xef2a
        function_ac26(a1 + 128, a2, (int32_t)v1, (int64_t)htons((int16_t)host_short));
        result = 0;
    }
    // 0xef97
    return result;
}

// Address range: 0xef99 - 0xf014
int64_t slirp_add_guestfwd(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t host_short) {
    int64_t result = 0xffffffff; // 0xefd0
    if ((char)function_ee4d(a1, a4, (int32_t)host_short) == 1) {
        // 0xefd9
        int64_t v1; // 0xef99
        function_abad(a1 + 128, a2, a3, v1 & 0xffffffff, (int64_t)htons((int16_t)host_short));
        result = 0;
    }
    // 0xf012
    return result;
}

// Address range: 0xf014 - 0xf0a9
int64_t function_f014(int64_t a1, int64_t buf, int64_t length, int64_t flags) {
    int32_t sock = *(int32_t *)(a1 + 16); // 0xf02f
    int64_t result; // 0xf014
    if (sock != -1) {
        // 0xf08e
        result = send(sock, (int64_t *)buf, (int32_t)length, (int32_t)flags);
        // 0xf0a7
        return result;
    }
    // 0xf037
    result = length;
    if (*(int64_t *)(a1 + 24) == 0) {
        // 0xf07a
        *__errno_location() = 9;
        result = -1;
    }
    // 0xf0a7
    return result;
}

// Address range: 0xf0a9 - 0xf11c
int64_t function_f0a9(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a1 + 448; // 0xf0bf
    int64_t v2 = *(int64_t *)v1;
    if (v2 == v1) {
        // 0xf11a
        return 0;
    }
    // 0xf0cc
    if (*(int32_t *)(v2 + 76) == (int32_t)a2) {
        // 0xf0da
        if ((int32_t)a3 == (int32_t)htons(*(int16_t *)(v2 + 74))) {
            // break -> 0xf11a
            return 0;
        }
    }
    int64_t v3 = *(int64_t *)v2;
    int64_t result = 0; // 0xf113
    while (v3 != v1) {
        int64_t v4 = v3;
        if (*(int32_t *)(v4 + 76) == (int32_t)a2) {
            // 0xf0da
            result = v4;
            if ((int32_t)a3 == (int32_t)htons(*(int16_t *)(v4 + 74))) {
                // break -> 0xf11a
                break;
            }
        }
        // 0xf0fa
        v3 = *(int64_t *)v4;
        result = 0;
    }
    // 0xf11a
    return result;
}

// Address range: 0xf11c - 0xf1d5
int64_t slirp_socket_can_recv(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = __readfsqword(40); // 0xf12e
    int64_t v2 = function_f0a9(a1, a2 & 0xffffffff, a3 & 0xffffffff); // 0xf14c
    int64_t v3 = 0; // 0xf15a
    if (v2 != 0) {
        uint32_t v4 = *(int32_t *)(v2 + 332); // 0xf160
        v3 = 0;
        if (v4 % 2 == 0) {
            // 0xf174
            v3 = 0;
            if ((v4 & 12) == 4) {
                // 0xf186
                v3 = 0;
                if (*(int32_t *)(v2 + 392) < *(int32_t *)(v2 + 396) / 2) {
                    // 0xf1a7
                    int64_t v5; // bp-56, 0xf11c
                    v3 = function_f8a6(v2, &v5, 0);
                }
            }
        }
    }
    int64_t result = v3; // 0xf1cc
    if (v1 != __readfsqword(40)) {
        // 0xf1ce
        __stack_chk_fail();
        result = &g91;
    }
    // 0xf1d3
    return result;
}

// Address range: 0xf1d5 - 0xf245
int64_t slirp_socket_recv(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = function_f0a9(a1, a2 & 0xffffffff, a3 & 0xffffffff); // 0xf1fe
    if (v1 == 0) {
        // 0xf243
        return 0;
    }
    int64_t v2 = function_10030(v1, a4, (int32_t)a5); // 0xf21f
    int64_t result = v2; // 0xf22b
    if ((int32_t)v2 >= 1) {
        // 0xf22d
        result = function_15563(*(int64_t *)(v1 + 336));
    }
    // 0xf243
    return result;
}

// Address range: 0xf245 - 0xf2f8
int64_t function_f245(int64_t a1, int64_t * a2, uint64_t a3) {
    int64_t result = *(int64_t *)*(int64_t *)(a1 + (int64_t)&g8); // 0xf264
    int64_t v1; // 0xf245
    if (result < 0) {
        // 0xf2f5
        int64_t v2; // 0xf245
        return function_3080("Slirp", 8, "Failed to send packet, ret: %ld", result, v2, v1);
    }
    // 0xf2b0
    if (result >= a3) {
        // 0xf2f5
        return result;
    }
    int64_t result2 = 0; // 0xf2c8
    if ((*(int32_t *)&g58 & 4) != 0) {
        // 0xf2ca
        result2 = function_3080("Slirp", 128, "send_packet() didn't send all data: %ld < %lu", result, a3, v1);
    }
    // 0xf2f5
    return result2;
}

// Address range: 0xf2f8 - 0xf350
int64_t function_f2f8(int64_t sock) {
    int64_t v1 = __readfsqword(40); // 0xf303
    int32_t option_value = 1; // bp-20, 0xf312
    int32_t v2 = setsockopt((int32_t)sock, SO_DEBUG, 2, (int64_t *)&option_value, 4); // 0xf335
    int64_t result = v2; // 0xf347
    if (v1 != __readfsqword(40)) {
        // 0xf349
        __stack_chk_fail();
        result = &g91;
    }
    // 0xf34e
    return result;
}

// Address range: 0xf350 - 0xf37f
int64_t function_f350(int64_t str, int64_t str2) {
    int32_t memcmp_rc = memcmp((int64_t *)str, (int64_t *)str2, 16); // 0xf373
    return (int64_t)(memcmp_rc & -256) | (int64_t)(memcmp_rc == 0);
}

// Address range: 0xf37f - 0xf44c
int64_t function_f37f(int64_t str, int64_t str2, uint64_t a3) {
    int32_t v1 = a3;
    int32_t n = v1 / 128;
    if (memcmp((int64_t *)str, (int64_t *)str2, n) != 0) {
        // 0xf44a
        return 0;
    }
    // 0xf3c4
    if (a3 % 8 == 0) {
        // 0xf44a
        return 1;
    }
    int64_t v2 = n; // 0xf3e7
    unsigned char v3 = *(char *)(v2 + str); // 0xf3e9
    uint32_t v4 = (v1 >> 31) / 0x20000000; // 0xf3f4
    uint32_t v5 = (v4 | 8) - (v4 + v1) % 8; // 0xf40b
    unsigned char v6 = *(char *)(v2 + str2); // 0xf421
    int64_t v7 = v6; // 0xf441
    if (v5 != 0) {
        v7 = (int32_t)v6 >> v5;
    }
    int64_t v8 = v7;
    int64_t result = v8 & 0xffffff00 | (int64_t)((int32_t)v3 >> v5 == (int32_t)v8); // 0xf447
    // 0xf44a
    return result;
}

// Address range: 0xf44c - 0xf550
int64_t function_f44c(int64_t a1, int64_t a2) {
    // 0xf44c
    int64_t v1; // 0xf44c
    int16_t v2 = v1;
    int64_t v3; // 0xf44c
    if (v2 != (int16_t)v3) {
        // 0xf54e
        return 0;
    }
    switch (v2) {
        case 2: {
            // 0xf492
            if (*(int32_t *)(a1 + 4) != *(int32_t *)(a2 + 4) || *(int16_t *)(a1 + 2) != *(int16_t *)(a2 + 2)) {
                // 0xf54e
                return 0;
            }
            // 0xf54e
            return 1;
        }
        case 10: {
            // 0xf4d7
            if ((char)function_f350(a1 + 8, a2 + 8) == 0 || *(int16_t *)(a1 + 2) != *(int16_t *)(a2 + 2)) {
                // 0xf54e
                return 0;
            }
            // 0xf54e
            return 1;
        }
    }
    // 0xf54e
    return function_2ea0("Slirp", "../src/socket.h", 122, "sockaddr_equal", 0);
}

// Address range: 0xf550 - 0xf5a7
int64_t function_f550(int64_t * a1) {
    int64_t result = 16; // 0xf550
    int64_t v1; // 0xf550
    switch ((int16_t)v1) {
        case 10: {
            // 0xf579
            result = 28;
        }
        case 2: {
            // 0xf5a5
            return result;
        }
        default: {
            // 0xf580
            result = function_2ea0("Slirp", "../src/socket.h", 136, "sockaddr_size", 0);
            return result;
        }
    }
}

// Address range: 0xf5a7 - 0xf694
int64_t function_f5a7(int64_t result, int64_t a2, int16_t * a3, int16_t * a4) {
    int64_t v1 = result; // 0xf5d2
    if (result != a2) {
        int64_t v2 = (int64_t)a3; // 0xf5df
        int64_t v3 = function_f44c(result + 200, v2); // 0xf5e9
        v1 = v2;
        if ((int32_t)v3 != 0) {
            // 0xf5f2
            if (a4 == NULL) {
                // 0xf692
                return result;
            }
            int64_t v4 = (int64_t)a4; // 0xf601
            int64_t v5 = function_f44c(result + 72, v4); // 0xf60b
            v1 = v4;
            if ((int32_t)v5 != 0) {
                // 0xf692
                return result;
            }
        }
    }
    // 0xf61a
    if (v1 == a2) {
        // 0xf692
        return 0;
    }
    // 0xf627
    int64_t result2; // 0xf5a7
    if ((int32_t)function_f44c(v1 + 200, (int64_t)a3) != 0) {
        if (a4 == NULL) {
            // 0xf667
            *(int64_t *)result = v1;
            result2 = v1;
            return result2;
        }
        // 0xf64c
        if ((int32_t)function_f44c(v1 + 72, (int64_t)a4) != 0) {
            // 0xf667
            *(int64_t *)result = v1;
            result2 = v1;
            return result2;
        }
    }
    int64_t v6 = *(int64_t *)v1; // 0xf67c
    result2 = 0;
    while (v6 != a2) {
        int64_t v7 = v6;
        if ((int32_t)function_f44c(v7 + 200, (int64_t)a3) != 0) {
            if (a4 == NULL) {
                // 0xf667
                *(int64_t *)result = v7;
                result2 = v7;
                return result2;
            }
            // 0xf64c
            if ((int32_t)function_f44c(v7 + 72, (int64_t)a4) != 0) {
                // 0xf667
                *(int64_t *)result = v7;
                result2 = v7;
                return result2;
            }
        }
        // 0xf678
        v6 = *(int64_t *)v7;
        result2 = 0;
    }
  lab_0xf692:
    // 0xf692
    return result2;
}

// Address range: 0xf694 - 0xf6ff
int64_t function_f694(int64_t a1) {
    int64_t result = function_3000(1, 424); // 0xf6aa
    memset((int64_t *)result, 0, 424);
    *(int32_t *)(result + 332) = 1;
    *(int32_t *)(result + 16) = -1;
    *(int64_t *)(result + 40) = a1;
    *(int32_t *)(result + 32) = -1;
    return result;
}

// Address range: 0xf6ff - 0xf77a
int64_t function_f6ff(int64_t a1, int64_t result) {
    // 0xf777
    return result;
}

// Address range: 0xf77a - 0xf8a6
int64_t function_f77a(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 40); // 0xf78a
    function_f6ff(a1, v1 + 192);
    function_f6ff(a1, v1 + 208);
    int64_t * v2 = (int64_t *)(v1 + (int64_t)&g68); // 0xf7ca
    if (*v2 != a1) {
        int64_t * v3 = (int64_t *)(v1 + (int64_t)&g78); // 0xf7f3
        if (*v3 != a1) {
            int64_t * v4 = (int64_t *)(v1 + (int64_t)&g85); // 0xf81c
            if (*v4 == a1) {
                // 0xf829
                *v4 = v1 + (int64_t)&g79;
            }
        } else {
            // 0xf800
            *v3 = v1 + (int64_t)&g71;
        }
    } else {
        // 0xf7d7
        *v2 = v1 + 448;
    }
    int64_t v5 = *(int64_t *)(a1 + 48); // 0xf843
    function_a4f0(v5);
    if (v5 != 0) {
        // 0xf85b
        if (*(int64_t *)(a1 + 8) != 0) {
            // 0xf868
            function_ab7f(a1);
        }
    }
    int64_t v6 = *(int64_t *)(a1 + 336); // 0xf878
    if (v6 != 0) {
        // 0xf884
        free((int64_t *)v6);
    }
    // 0xf897
    return function_2d70(a1);
}

// Address range: 0xf8a6 - 0xfc35
int64_t function_f8a6(int64_t a1, int64_t * a2, int64_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 396); // 0xf8cc
    uint16_t v2 = *(int16_t *)(*(int64_t *)(a1 + 336) + 32); // 0xf8e7
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xf91e
        int64_t v3; // 0xf8a6
        int64_t v4; // 0xf8a6
        int64_t v5; // 0xf8a6
        function_3080("Slirp", 128, "sopreprbuf...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0xf92e
            function_3080("Slirp", 128, " so = %p", a1, v4, v3);
        }
    }
    int32_t v6 = *v1 - *(int32_t *)(a1 + 392); // 0xf8d5
    if (v6 >= 0 != v6 != 0) {
        // 0xfc33
        return 0;
    }
    int64_t v7 = (int64_t)a2;
    int64_t * v8 = (int64_t *)(a1 + 400); // 0xf966
    *a2 = *v8;
    int64_t * v9 = (int64_t *)(v7 + 16); // 0xf979
    *v9 = 0;
    int64_t * v10 = (int64_t *)(v7 + 24); // 0xf988
    *v10 = 0;
    uint64_t v11 = *v8; // 0xf994
    int64_t * v12 = (int64_t *)(a1 + 408); // 0xf99c
    uint64_t v13 = *v12; // 0xf99c
    int32_t v14; // 0xf8a6
    if (v13 <= v11) {
        int64_t * v15 = (int64_t *)(a1 + 416); // 0xfa3e
        uint64_t v16 = *v15 - v11 + (int64_t)*v1; // 0xfa59
        int64_t * v17 = (int64_t *)(v7 + 8); // 0xfa66
        uint64_t v18 = (int64_t)v6; // 0xfa75
        uint64_t v19 = v16 > v18 ? v18 : v16;
        *v17 = v19;
        int32_t v20 = v6 - (int32_t)v19; // 0xfa95
        if (v20 == 0) {
            uint64_t v21 = (int64_t)v2; // 0xfbbf
            v14 = 1;
            if (v19 > v21) {
                // 0xfbc9
                *v17 = v19 - v19 % v21;
                v14 = 1;
            }
        } else {
            // 0xfaa6
            *v9 = *v15;
            uint64_t v22 = *v12 - *v15; // 0xfacc
            uint64_t v23 = (int64_t)v20; // 0xfaea
            uint64_t v24 = v22 > v23 ? v23 : v22;
            *v10 = v24;
            int64_t v25 = *v17; // 0xfb06
            int32_t v26 = (int32_t)v24 + (int32_t)v25; // 0xfb18
            v14 = 2;
            if (v26 > (int32_t)v2) {
                int64_t v27 = (0x100000000 * (int64_t)(v26 >> 31) | (int64_t)v26) % (int64_t)v2; // 0xfb2d
                int64_t v28 = 0x100000000 * v27 / 0x100000000; // 0xfb42
                if (v24 > v28) {
                    // 0xfb49
                    *v10 = v24 - v28;
                    v14 = 2;
                } else {
                    // 0xfb79
                    *v17 = v25 - 0x100000000 * (v27 - v24) / 0x100000000;
                    v14 = 1;
                }
            }
        }
    } else {
        uint64_t v29 = v13 - v11; // 0xf9bc
        int64_t * v30 = (int64_t *)(v7 + 8); // 0xf9c9
        uint64_t v31 = (int64_t)v6; // 0xf9d8
        uint64_t v32 = v29 > v31 ? v31 : v29;
        *v30 = v32;
        uint64_t v33 = (int64_t)v2; // 0xf9f5
        v14 = 1;
        if (v32 > v33) {
            // 0xf9ff
            *v30 = v32 - v32 % v33;
            v14 = 1;
        }
    }
    // 0xfbff
    if (a3 != 0) {
        // 0xfc06
        *(int32_t *)a3 = v14;
    }
    // 0xfc33
    return *v10 * (int64_t)(v14 - 1) + *(int64_t *)(v7 + 8);
}

// Address range: 0xfc35 - 0x10030
int64_t function_fc35(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0xfc48
    int64_t v2; // 0xfc35
    int64_t v3; // 0xfc35
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0xfc98
        int64_t v4; // 0xfc35
        function_3080("Slirp", 128, "soread...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0xfca8
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
        }
    }
    // 0xfccf
    int64_t buf; // bp-200, 0xfc35
    int32_t v5; // bp-248, 0xfc35
    if (function_f8a6(a1, &buf, (int64_t)&v5) == 0) {
        // 0xfd00
        __assert_fail("buf_len != 0", "../src/socket.c", 183, "soread");
    }
    int32_t * sock = (int32_t *)(a1 + 16); // 0xfd34
    int32_t length; // 0xfc35
    int32_t v6 = recv(*sock, (int64_t *)buf, length, 0); // 0xfd3e
    int64_t v7; // 0xfc35
    if (v6 >= 0 == (v6 != 0)) {
        int32_t v8 = v6; // 0xfef4
        if (v6 == length == v5 == 2) {
            // 0xff0b
            int64_t buf2; // 0xfc35
            int32_t length2; // 0xfc35
            int32_t v9 = recv(*sock, (int64_t *)buf2, length2, 0); // 0xff2a
            v8 = (v9 > 0 ? v9 : 0) + length;
        }
        // 0xff4a
        if ((*(int32_t *)&g58 & 2) != 0) {
            // 0xff5a
            function_3080("Slirp", 128, " ... read nn = %d bytes", (int64_t)v8, v3, v2);
        }
        int32_t * v10 = (int32_t *)(a1 + 392); // 0xfc64
        *v10 = *v10 + v8;
        int64_t * v11 = (int64_t *)(a1 + 400); // 0xffa0
        uint64_t v12 = *v11 + (int64_t)v8; // 0xffac
        *v11 = v12;
        int64_t v13 = (int64_t)*(int32_t *)(a1 + 396); // 0xffda
        if (v12 >= *(int64_t *)(a1 + 416) + v13) {
            // 0xffe4
            *v11 = v12 - v13;
        }
        // 0x1000c
        v7 = v8;
        goto lab_0x10012;
    } else {
        if (v6 >= 0) {
            goto lab_0xfd81;
        } else {
            int32_t v14 = *__errno_location(); // 0xfd64
            v7 = 0;
            if (v14 == 4) {
                goto lab_0x10012;
            } else {
                int32_t v15 = *__errno_location(); // 0xfd70
                v7 = 0;
                if (v15 != 11) {
                    goto lab_0xfd81;
                } else {
                    goto lab_0x10012;
                }
            }
        }
    }
  lab_0x10012:;
    int64_t result = v7; // 0x1001f
    if (v1 != __readfsqword(40)) {
        // 0x10021
        __stack_chk_fail();
        result = &g91;
    }
    // 0x10026
    return result;
  lab_0xfd81:;
    int32_t option_len = 4; // bp-240, 0xfd81
    int32_t addr_len = 128; // bp-236, 0xfd99
    int32_t option_value = *__errno_location(); // bp-244, 0xfdaa
    if (v6 == 0) {
        // 0xfdb9
        int64_t addr; // bp-168, 0xfc35
        if (getpeername(*sock, (struct sockaddr *)&addr, &addr_len) >= 0) {
            // 0xfdee
            getsockopt(*sock, SO_DEBUG, 4, (int64_t *)&option_value, &option_len);
        } else {
            // 0xfddf
            option_value = *__errno_location();
        }
    }
    // 0xfe1d
    if ((*(int32_t *)&g58 & 2) != 0) {
        char * err_str = strerror(*__errno_location()); // 0xfe36
        uint32_t v16 = *__errno_location(); // 0xfe43
        function_3080("Slirp", 128, " --- soread() disconnected, nn = %d, errno = %d-%s", (int64_t)v6, (int64_t)v16, (int64_t)err_str);
    }
    // 0xfe70
    function_11b34(a1);
    switch (option_value) {
        case 111: {
            goto lab_0xfeab;
        }
        case 107: {
            goto lab_0xfeab;
        }
        case 104: {
            goto lab_0xfeab;
        }
        default: {
            if (option_value != 32) {
                // 0xfecb
                function_17227(*(int64_t *)(a1 + 336));
                v7 = 0xffffffff;
                goto lab_0x10012;
            } else {
                goto lab_0xfeab;
            }
        }
    }
  lab_0xfeab:
    // 0xfeab
    function_16fc0(*(int64_t *)(a1 + 336), (int64_t)option_value);
    v7 = 0xffffffff;
    goto lab_0x10012;
}

// Address range: 0x10030 - 0x10238
int64_t function_10030(int64_t a1, int64_t a2, int32_t a3) {
    int64_t v1 = __readfsqword(40); // 0x10043
    int64_t v2; // 0x10030
    int64_t v3; // 0x10030
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x10093
        int64_t v4; // 0x10030
        function_3080("Slirp", 128, "soreadbuf...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x100a3
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
        }
    }
    if (a3 >= 0 != a3 != 0) {
        // 0x100cd
        __assert_fail("size > 0", "../src/socket.c", 258, "soreadbuf");
    }
    // 0x100ec
    int64_t v5; // bp-56, 0x10030
    int64_t v6; // bp-76, 0x10030
    uint64_t v7 = function_f8a6(a1, &v5, (int64_t)&v6); // 0x100fe
    uint64_t v8 = (int64_t)a3; // 0x10109
    int64_t v9; // 0x10030
    if (v7 < v8) {
        // 0x101e0
        function_11b34(a1);
        function_17227(*(int64_t *)(a1 + 336));
        function_3080("Slirp", 8, "soreadbuf buffer too small", (int64_t)&v5, v3, v2);
        v9 = 0xffffffff;
    } else {
        // 0x10114
        uint64_t v10; // 0x10030
        int64_t v11 = v10 < v8 ? v10 : v8; // 0x10121
        int32_t v12 = v11; // 0x10125
        memcpy((int64_t *)v5, (int64_t *)a2, v12);
        int32_t v13 = a3 - v12; // 0x10144
        if (v13 != 0) {
            // 0x10156
            int64_t v14; // 0x10030
            memcpy((int64_t *)v14, (int64_t *)(0x100000000 * v11 / 0x100000000 + a2), v13);
        }
        int32_t * v15 = (int32_t *)(a1 + 392); // 0x10062
        *v15 = *v15 + a3;
        int64_t * v16 = (int64_t *)(a1 + 400); // 0x10187
        uint64_t v17 = *v16 + v8; // 0x10190
        *v16 = v17;
        int64_t v18 = (int64_t)*(int32_t *)(a1 + 396); // 0x101b2
        if (v17 >= *(int64_t *)(a1 + 416) + v18) {
            // 0x101bc
            *v16 = v17 - v18;
        }
        // 0x101db
        v9 = a3;
    }
    int64_t result = v9; // 0x1022f
    if (v1 != __readfsqword(40)) {
        // 0x10231
        __stack_chk_fail();
        result = &g91;
    }
    // 0x10236
    return result;
}

// Address range: 0x10238 - 0x10307
int64_t function_10238(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 336); // 0x10248
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x10280
        int64_t v2; // 0x10238
        int64_t v3; // 0x10238
        int64_t v4; // 0x10238
        function_3080("Slirp", 128, "sorecvoob...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x10290
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
        }
    }
    int64_t v5 = function_fc35(a1); // 0x102bb
    if ((int32_t)v5 >= 1) {
        int32_t v6 = *(int32_t *)(a1 + 392); // 0x102d4
        *(int32_t *)(v1 + 128) = v6 + *(int32_t *)(v1 + 120);
        char * v7 = (char *)(v1 + 34); // 0x102ea
        *v7 = 1;
        function_15563(v1);
        *v7 = 0;
    }
    // 0x10302
    return v5 & 0xffffffff;
}

// Address range: 0x10307 - 0x106a3
int64_t function_10307(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x10319
    int32_t * v2 = (int32_t *)(a1 + 360); // 0x10335
    int64_t v3; // 0x10307
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x10369
        int64_t v4; // 0x10307
        int64_t v5; // 0x10307
        function_3080("Slirp", 128, "sosendoob...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x103a0
            function_3080("Slirp", 128, " so = %p", a1, v4, v3);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x103b0
                function_3080("Slirp", 128, " sb->sb_cc = %d", (int64_t)*v2, v4, v3);
            }
        }
    }
    int32_t * v6 = (int32_t *)(a1 + 64); // 0x103df
    uint32_t v7 = *v6; // 0x103df
    int32_t v8 = v7; // 0x103e7
    if (v7 > (int32_t)&g89) {
        // 0x103e9
        *v6 = (int32_t)&g89;
        v8 = &g89;
    }
    uint32_t v9 = v8;
    int64_t * v10 = (int64_t *)(a1 + 376); // 0x103fe
    uint64_t v11 = *v10; // 0x103fe
    int64_t * v12 = (int64_t *)(a1 + 368); // 0x10409
    int64_t v13; // 0x10307
    if (v11 >= *v12) {
        int64_t * v14 = (int64_t *)(a1 + 384); // 0x1045f
        uint32_t v15 = *(int32_t *)(a1 + 364) + (int32_t)(*v14 - v11); // 0x10486
        int32_t v16 = v9 >= v15 ? v15 : v9;
        int64_t v17; // bp-2072, 0x10307
        memcpy(&v17, (int64_t *)v11, v16);
        uint32_t v18 = v9 - v16; // 0x104d2
        int64_t v19; // 0x10307
        int32_t v20; // 0x10307
        if (v18 == 0) {
            // 0x10448
            v19 = &v17;
            v20 = v16;
        } else {
            int64_t v21 = *v14; // 0x104f6
            uint32_t v22 = (int32_t)(*v12 - v21); // 0x10500
            int32_t v23 = v18 >= v22 ? v22 : v18;
            int64_t v24 = &v17;
            memcpy((int64_t *)((int64_t)v16 + v24), (int64_t *)v21, v23);
            v19 = v24;
            v20 = v23 + v16;
        }
        // 0x1055e
        v13 = function_f014(a1, v19, (int64_t)v20, 1);
    } else {
        // 0x10412
        v13 = function_f014(a1, v11, (int64_t)v9, 1);
    }
    int32_t v25 = v13;
    if (v25 >= 0) {
        uint32_t v26 = *v6 - v25; // 0x105ac
        *v6 = v26;
        if ((*(int32_t *)&g58 & 2) != 0) {
            // 0x105c8
            function_3080("Slirp", 128, " ---2 sent %d bytes urgent data, %d urgent bytes left", v13 & 0xffffffff, (int64_t)v26, v3);
        }
        // 0x105fa
        *v2 = *v2 - v25;
        uint64_t v27 = *v10 + 0x100000000 * v13 / 0x100000000; // 0x10627
        *v10 = v27;
        int64_t v28 = (int64_t)*(int32_t *)(a1 + 364); // 0x10655
        if (v27 >= *(int64_t *)(a1 + 384) + v28) {
            // 0x1065f
            *v10 = v27 - v28;
        }
    }
    int64_t result = v13 & 0xffffffff; // 0x1069a
    if (v1 != __readfsqword(40)) {
        // 0x1069c
        __stack_chk_fail();
        result = &g91;
    }
    // 0x106a1
    return result;
}

// Address range: 0x106a3 - 0x10a5a
int64_t function_106a3(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x106af
    int32_t * v2 = (int32_t *)(a1 + 360); // 0x106c8
    int32_t v3 = *v2; // 0x106d0
    int64_t v4; // 0x106a3
    int64_t v5; // 0x106a3
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x10702
        int64_t v6; // 0x106a3
        function_3080("Slirp", 128, "sowrite...", v6, v5, v4);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x10712
            function_3080("Slirp", 128, " so = %p", a1, v5, v4);
        }
    }
    uint32_t v7 = *(int32_t *)(a1 + 64); // 0x1073a
    int64_t v8; // 0x106a3
    if (v7 == 0) {
        goto lab_0x10774;
    } else {
        // 0x10741
        if (v7 > (int32_t)function_10307(a1)) {
            goto lab_0x109dd;
        } else {
            // 0x10760
            v8 = 0;
            if (*v2 != 0) {
                goto lab_0x10774;
            } else {
                goto lab_0x10a44;
            }
        }
    }
  lab_0x10774:;
    int64_t * v9 = (int64_t *)(a1 + 376); // 0x10778
    uint64_t v10 = *v9; // 0x10778
    uint64_t v11 = *(int64_t *)(a1 + 368); // 0x1079c
    int64_t v12; // 0x106a3
    int64_t v13; // 0x106a3
    int32_t v14; // 0x106a3
    int32_t v15; // 0x106a3
    if (v11 <= v10) {
        int64_t v16 = *(int64_t *)(a1 + 384); // 0x107e9
        uint64_t v17 = v16 - v10 + (int64_t)*(int32_t *)(a1 + 364); // 0x10804
        int32_t v18 = v17 > (int64_t)v3 ? v3 : (int32_t)v17;
        int32_t v19 = v3 - v18; // 0x1082c
        v13 = 0;
        v12 = 0;
        v14 = v18;
        v15 = 1;
        if (v19 != 0) {
            uint64_t v20 = v11 - v16; // 0x10856
            uint64_t v21 = (int64_t)v19; // 0x10867
            v13 = v16;
            v12 = v20 > v21 ? v21 : v20;
            v14 = v18;
            v15 = 2;
        }
    } else {
        uint64_t v22 = v11 - v10; // 0x107b8
        v13 = 0;
        v12 = 0;
        v14 = v22 > (int64_t)v3 ? v3 : (int32_t)v22;
        v15 = 1;
    }
    int32_t v23 = function_f014(a1, v10, (int64_t)v14, 0); // 0x108a0
    if (v23 >= 0) {
        goto lab_0x108cb;
    } else {
        int32_t v24 = *__errno_location(); // 0x108ae
        v8 = 0;
        if (v24 == 11) {
            goto lab_0x10a44;
        } else {
            int32_t v25 = *__errno_location(); // 0x108ba
            v8 = 0;
            if (v25 != 4) {
                goto lab_0x108cb;
            } else {
                goto lab_0x10a44;
            }
        }
    }
  lab_0x108cb:
    if (v23 < 1) {
        goto lab_0x109dd;
    } else {
        int32_t v26 = v23; // 0x108d9
        if (v15 == 2 == v14 == v23) {
            int32_t v27 = function_f014(a1, v13, v12, 0); // 0x10903
            v26 = (v27 > 0 ? v27 : 0) + v14;
        }
        // 0x10912
        if ((*(int32_t *)&g58 & 2) != 0) {
            // 0x10922
            function_3080("Slirp", 128, "  ... wrote nn = %d bytes", (int64_t)v26, v5, v4);
        }
        // 0x10944
        *v2 = *v2 - v26;
        uint64_t v28 = *v9 + (int64_t)v26; // 0x10962
        *v9 = v28;
        int64_t v29 = (int64_t)*(int32_t *)(a1 + 364); // 0x10984
        if (v28 >= *(int64_t *)(a1 + 384) + v29) {
            // 0x1098e
            *v9 = v28 - v29;
        }
        // 0x109ad
        if ((*(int32_t *)(a1 + 332) & 64) != 0) {
            // 0x109be
            if (*v2 == 0) {
                // 0x109c8
                function_11be0(a1);
            }
        }
        // 0x109d4
        v8 = v26;
        goto lab_0x10a44;
    }
  lab_0x109dd:
    // 0x109dd
    if ((*(int32_t *)&g58 & 2) != 0) {
        uint32_t v30 = *__errno_location(); // 0x109f2
        uint32_t v31 = *(int32_t *)(a1 + 332); // 0x109f8
        function_3080("Slirp", 128, " --- sowrite disconnected, so->so_state = %x, errno = %d", (int64_t)v31, (int64_t)v30, v4);
    }
    // 0x10a20
    function_11be0(a1);
    function_17227(*(int64_t *)(a1 + 336));
    v8 = 0xffffffff;
    goto lab_0x10a44;
  lab_0x10a44:;
    int64_t result = v8; // 0x10a51
    if (v1 != __readfsqword(40)) {
        // 0x10a53
        __stack_chk_fail();
        result = &g91;
    }
    // 0x10a58
    return result;
}

// Address range: 0x10a5a - 0x11417
int64_t function_10a5a(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x10a6d
    int32_t addr_len = 128; // bp-704, 0x10a7c
    int64_t v2; // 0x10a5a
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x10ab3
        int64_t v3; // 0x10a5a
        int64_t v4; // 0x10a5a
        function_3080("Slirp", 128, "sorecvfrom...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x10ac3
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
        }
    }
    int32_t * v5 = (int32_t *)(a1 + 16);
    int32_t fd = *v5;
    int64_t addr; // bp-680, 0x10a5a
    if (*(char *)(a1 + 330) != 1) {
        // 0x10c3b
        if (ioctl(fd, 0x541b) == 0) {
            uint32_t v6; // 0x10a5a
            if (v6 != 0) {
                int64_t v7 = function_a39a(*(int64_t *)(a1 + 40)); // 0x10cd0
                if (v7 != 0) {
                    int16_t * v8 = (int16_t *)(a1 + 72); // 0x10cf1
                    switch (*v8) {
                        case 2: {
                            int64_t * v9 = (int64_t *)(v7 + 48); // 0x10d0b
                            *v9 = *v9 + 44;
                            // break -> 0x10d61
                            break;
                        }
                        case 10: {
                            int64_t * v10 = (int64_t *)(v7 + 48); // 0x10d27
                            *v10 = *v10 + 64;
                            // break -> 0x10d61
                            break;
                        }
                        default: {
                            // 0x10d3c
                            function_2ea0("Slirp", "../src/socket.c", (int64_t)&g62, "sorecvfrom", 0);
                            // break -> 0x10d61
                            break;
                        }
                    }
                    int32_t * v11 = (int32_t *)(v7 + 32); // 0x10d68
                    int64_t * v12; // 0x10a5a
                    int64_t v13; // 0x10a5a
                    if (*v11 % 2 == 0) {
                        int64_t * v14 = (int64_t *)(v7 + 48);
                        v12 = v14;
                        v13 = v7 + 96 + (int64_t)*(int32_t *)(v7 + 36) - *v14;
                    } else {
                        uint32_t v15 = *(int32_t *)(v7 + 36); // 0x10d84
                        int64_t * v16 = (int64_t *)(v7 + 48);
                        v12 = v16;
                        v13 = *(int64_t *)(v7 + 88) + (int64_t)v15 - *v16;
                    }
                    int32_t * v17 = (int32_t *)(v7 + 56); // 0x10ddb
                    int32_t v18 = *v17; // 0x10ddb
                    int32_t v19 = (int32_t)v13 - v18; // 0x10dde
                    int64_t v20 = *v12;
                    int64_t buf = v20; // 0x10df4
                    int32_t length = v19; // 0x10df4
                    if ((int64_t)v19 < (int64_t)v6) {
                        int64_t v21 = v7 + 96; // 0x10e0f
                        function_a70b(v7, (int64_t)(v6 + 1 + v18 + (int32_t)(v20 - v21)));
                        int64_t v22; // 0x10a5a
                        int64_t v23; // 0x10a5a
                        if (*v11 % 2 == 0) {
                            int64_t v24 = *v12; // 0x10eb6
                            v22 = v24;
                            v23 = v21 + (int64_t)*(int32_t *)(v7 + 36) - v24;
                        } else {
                            uint32_t v25 = *(int32_t *)(v7 + 36); // 0x10e72
                            int64_t v26 = *v12; // 0x10e84
                            v22 = v26;
                            v23 = *(int64_t *)(v7 + 88) + (int64_t)v25 - v26;
                        }
                        // 0x10ec2
                        buf = v22;
                        length = (int32_t)v23 - *v17;
                    }
                    int32_t sock = *v5; // 0x10ef1
                    int32_t v27 = recvfrom(sock, (int64_t *)buf, length, 0, (struct sockaddr *)&addr, &addr_len); // 0x10f0f
                    *v17 = v27;
                    int32_t v28 = v27; // 0x10f2e
                    int64_t v29 = &addr; // 0x10f2e
                    int64_t err_str = &addr_len; // 0x10f2e
                    if ((*(int32_t *)&g58 & 2) != 0) {
                        // 0x10f30
                        err_str = (int64_t)strerror(*__errno_location());
                        v29 = (int64_t)*__errno_location();
                        function_3080("Slirp", 128, " did recvfrom %d, errno = %d-%s", (int64_t)*v17, v29, err_str);
                        v28 = *v17;
                    }
                    // 0x10f77
                    if (v28 >= 0) {
                        int32_t * v30 = (int32_t *)(a1 + 344); // 0x11115
                        if (*v30 != 0) {
                            int16_t v31 = htons(53); // 0x1112f
                            int32_t v32 = *(int32_t *)&g60;
                            if (*(int16_t *)(a1 + 74) != v31) {
                                // 0x11157
                                *v30 = v32 + 0x3a980;
                            } else {
                                // 0x11139
                                *v30 = v32 + 0x2710;
                            }
                        }
                        int64_t v33 = addr; // bp-552, 0x11181
                        function_11e85(a1, &v33);
                        int64_t v34 = *(int64_t *)(a1 + 200); // bp-424, 0x11281
                        switch (*v8) {
                            case 2: {
                                unsigned char v35 = *(char *)(a1 + 328); // 0x11374
                                function_1b11d(a1, v7, &v33, &v34, (int64_t)v35);
                                // break -> 0x113f9
                                break;
                            }
                            case 10: {
                                // 0x113a7
                                function_1bf57(a1, v7, &v33, &v34);
                                // break -> 0x113f9
                                break;
                            }
                            default: {
                                // 0x113cd
                                function_2ea0("Slirp", "../src/socket.c", (int64_t)&g65, "sorecvfrom", 0);
                                // break -> 0x113f9
                                break;
                            }
                        }
                    } else {
                        // 0x10f89
                        switch (*(int16_t *)(a1 + 200)) {
                            case 2: {
                                int32_t v36 = *__errno_location(); // 0x10fb9
                                int64_t v37 = 1; // 0x10fbe
                                if (v36 != 113) {
                                    // 0x10fc9
                                    v37 = *__errno_location() != 101 ? 3 : 0;
                                }
                                // 0x10fdc
                                if ((*(int32_t *)&g58 & 2) != 0) {
                                    // 0x10fec
                                    function_3080("Slirp", 128, " rx error, tx icmp ICMP_UNREACH:%i", v37, v29, err_str);
                                }
                                char * err_str2 = strerror(*__errno_location()); // 0x1101b
                                function_8b39(*(int64_t *)(a1 + 48), 3, v37, 0, (int64_t)err_str2);
                                // break -> 0x110fa
                                break;
                            }
                            case 10: {
                                int32_t v38 = *__errno_location(); // 0x1105b
                                int64_t v39 = 3; // 0x11060
                                if (v38 != 113) {
                                    // 0x1106b
                                    v39 = *__errno_location() != 101 ? 4 : 0;
                                }
                                // 0x1107e
                                if ((*(int32_t *)&g58 & 2) != 0) {
                                    // 0x1108e
                                    function_3080("Slirp", 128, " rx error, tx icmp6 ICMP_UNREACH:%i", v39, v29, err_str);
                                }
                                // 0x110b4
                                function_6903(*(int64_t *)(a1 + 48), 1, v39);
                                // break -> 0x110fa
                                break;
                            }
                            default: {
                                // 0x110d5
                                function_2ea0("Slirp", "../src/socket.c", (int64_t)&g64, "sorecvfrom", 0);
                                // break -> 0x110fa
                                break;
                            }
                        }
                        // 0x110fa
                        function_a4f0(v7);
                    }
                }
            }
        } else {
            // 0x10c61
            if ((*(int32_t *)&g58 & 2) != 0) {
                char * err_str3 = strerror(*__errno_location()); // 0x10c7e
                uint32_t v40 = *__errno_location(); // 0x10c8b
                function_3080("Slirp", 128, " ioctlsocket errno = %d-%s\n", (int64_t)v40, (int64_t)err_str3, v2);
            }
        }
    } else {
        // 0x10b00
        int64_t buf2; // bp-296, 0x10a5a
        int32_t v41 = recvfrom(fd, &buf2, 256, 0, (struct sockaddr *)&addr, &addr_len); // 0x10b31
        if (v41 != -1 == (v41 != 0)) {
            int64_t * v42 = (int64_t *)(a1 + 48); // 0x10c0c
            function_8f3f(*v42);
            *v42 = 0;
        } else {
            int32_t v43 = *__errno_location(); // 0x10b5e
            int64_t v44 = 1; // 0x10b63
            if (v43 != 113) {
                // 0x10b6e
                v44 = *__errno_location() != 101 ? 3 : 0;
            }
            // 0x10b81
            if ((*(int32_t *)&g58 & 2) != 0) {
                char * err_str4 = strerror(*__errno_location()); // 0x10b9a
                uint32_t v45 = *__errno_location(); // 0x10ba7
                function_3080("Slirp", 128, " udp icmp rx errno = %d-%s", (int64_t)v45, (int64_t)err_str4, (int64_t)&addr_len);
            }
            char * err_str5 = strerror(*__errno_location()); // 0x10bd4
            function_8b39(*(int64_t *)(a1 + 48), 3, v44, 0, (int64_t)err_str5);
        }
        // 0x10c27
        function_1b3c9(a1);
    }
    int64_t result = 0; // 0x11406
    if (v1 != __readfsqword(40)) {
        // 0x11408
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1140d
    return result;
}

// Address range: 0x11417 - 0x116c0
int64_t function_11417(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x11430
    int64_t dest_addr; // bp-152, 0x11417
    if (*(int32_t *)&g58 % 2 == 0) {
        // 0x114da
        dest_addr = *(int64_t *)(a1 + 72);
        goto lab_0x115af;
    } else {
        // 0x1146c
        int64_t v2; // 0x11417
        int64_t v3; // 0x11417
        int64_t v4; // 0x11417
        function_3080("Slirp", 128, "sosendto...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 == 0) {
            // 0x114da
            dest_addr = *(int64_t *)(a1 + 72);
            goto lab_0x115af;
        } else {
            // 0x114a3
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 == 0) {
                // 0x114da
                dest_addr = *(int64_t *)(a1 + 72);
                goto lab_0x115af;
            } else {
                // 0x114da
                function_3080("Slirp", 128, " m = %p", a2, v3, v2);
                dest_addr = *(int64_t *)(a1 + 72);
                if (*(int32_t *)&g58 % 2 != 0) {
                    // 0x11592
                    function_3080("Slirp", 128, " sendto()ing)...", *(int64_t *)(a1 + 176), v3, v2);
                }
                goto lab_0x115af;
            }
        }
    }
  lab_0x115af:;
    int64_t v5 = function_11cd0(a1, (int64_t)&dest_addr); // 0x115c3
    int64_t v6 = 0xffffffff; // 0x115ca
    if ((int32_t)v5 >= 0) {
        int64_t dest_len = function_f550(&dest_addr); // 0x115e0
        int32_t length = *(int32_t *)(a2 + 56); // 0x115ee
        int64_t message = *(int64_t *)(a2 + 48); // 0x115fb
        int32_t sock = *(int32_t *)(a1 + 16); // 0x11606
        int32_t v7 = sendto(sock, (int64_t *)message, length, 0, (struct sockaddr *)&dest_addr, (int32_t)dest_len); // 0x1161d
        v6 = 0xffffffff;
        if (v7 >= 0) {
            int32_t * v8 = (int32_t *)(a1 + 344); // 0x1163f
            if (*v8 != 0) {
                // 0x11649
                *v8 = *(int32_t *)&g60 + 0x3a980;
            }
            int32_t * v9 = (int32_t *)(a1 + 332); // 0x1166c
            *v9 = *v9 & 0xf000 | 4;
            v6 = 0;
        }
    }
    int64_t result = v6; // 0x116b7
    if (v1 != __readfsqword(40)) {
        // 0x116b9
        __stack_chk_fail();
        result = &g91;
    }
    // 0x116be
    return result;
}

// Address range: 0x116c0 - 0x11aba
int64_t function_116c0(int64_t a1, int32_t a2, int64_t net_short, int64_t a4, int64_t a5, char * a6) {
    struct in_addr in; // 0x11752
    struct in_addr in2; // 0x117cb
    int64_t v1 = (int64_t)a6;
    int64_t v2 = 0x100000000 * a4 / 0x100000000; // 0x116d2
    int64_t net_short2 = 0x100000000 * a5 / 0x100000000; // 0x116d5
    int64_t v3 = __readfsqword(40); // 0x116dd
    int32_t option_value = 1; // bp-64, 0x116ec
    int32_t addr_len = 16; // bp-60, 0x116f3
    int64_t addr; // bp-40, 0x116c0
    memset(&addr, 0, 16);
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1173d
        function_3080("Slirp", 128, "tcp_listen...", a4, a5, v1);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x11777



            in.s_addr = a2;
            function_3080("Slirp", 128, " haddr = %s", (int64_t)inet_ntoa(in), a5, v1);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x117b6
                function_3080("Slirp", 128, " hport = %d", (int64_t)ntohs((int16_t)net_short), a5, v1);
                if (*(int32_t *)&g58 % 2 != 0) {
                    // 0x117f0



                    in2.s_addr = v2;
                    function_3080("Slirp", 128, " laddr = %s", (int64_t)inet_ntoa(in2), a5, v1);
                    if (*(int32_t *)&g58 % 2 != 0) {
                        // 0x1182f
                        function_3080("Slirp", 128, " lport = %d", (int64_t)ntohs((int16_t)net_short2), a5, v1);
                        if (*(int32_t *)&g58 % 2 != 0) {
                            // 0x1183f
                            function_3080("Slirp", 128, " flags = %x", v1 & 0xffffffff, a5, v1);
                        }
                    }
                }
            }
        }
    }
    int64_t v4 = function_f694(a1); // 0x11868
    int64_t v5 = function_16ebd(v4); // 0x11878
    int64_t * v6 = (int64_t *)(v4 + 336); // 0x11884
    *v6 = v5;
    int32_t v7; // 0x116c0
    int64_t v8; // 0x116c0
    int32_t sock; // 0x11970
    if (v5 != 0) {
        // 0x118b1
        function_ab4c(v4, a1 + 448);
        int32_t v9 = v1;
        if ((v9 & (int32_t)&g36) != 0) {
            // 0x118d7
            *(int16_t *)(*v6 + 22) = 300;
        }
        int32_t * v10 = (int32_t *)(v4 + 332); // 0x118ec
        *v10 = *v10 & 0xf000 | v9 | 256;
        *(int16_t *)(v4 + 200) = 2;
        *(int16_t *)(v4 + 202) = (int16_t)net_short2;
        *(int32_t *)(v4 + 204) = (int32_t)v2;
        addr = 2;
        int64_t v11 = function_1c25e(2, 1, 0); // 0x1196b
        sock = v11;
        if (sock < 0) {
            // 0x119b4
            v7 = *__errno_location();
            goto lab_0x119ce;
        } else {
            // 0x11979
            if ((int32_t)function_f2f8(v11 & 0xffffffff) < 0) {
                goto lab_0x119c4;
            } else {
                // 0x11987
                if (bind(sock, (struct sockaddr *)&addr, 16) < 0) {
                    goto lab_0x119c4;
                } else {
                    // 0x119a1
                    if (listen(sock, 1) >= 0) {
                        // 0x119f1
                        setsockopt(sock, SO_DEBUG, 10, (int64_t *)&option_value, 4);
                        option_value = 1;
                        setsockopt(sock, SO_BROADCAST, 1, (int64_t *)&option_value, 4);
                        getsockname(sock, (struct sockaddr *)&addr, &addr_len);
                        *(int16_t *)(v4 + 72) = 2;
                        *(int16_t *)(v4 + 74) = (int16_t)net_short;
                        if (a2 == 0) {
                            // 0x11a7c
                            *(int32_t *)(v4 + 76) = *(int32_t *)(a1 + 20);
                            // 0x11a96
                            *(int32_t *)(v4 + 16) = sock;
                            v8 = v4;
                            goto lab_0x11aa4;
                        } else {
                            // 0x11a6c
                            if (*(int32_t *)&g59 != a2) {
                                // 0x11a8c
                                *(int32_t *)(v4 + 76) = a2;
                                // 0x11a96
                                *(int32_t *)(v4 + 16) = sock;
                                v8 = v4;
                                goto lab_0x11aa4;
                            } else {
                                // 0x11a7c
                                *(int32_t *)(v4 + 76) = *(int32_t *)(a1 + 20);
                                // 0x11a96
                                *(int32_t *)(v4 + 16) = sock;
                                v8 = v4;
                                goto lab_0x11aa4;
                            }
                        }
                    } else {
                        goto lab_0x119c4;
                    }
                }
            }
        }
    } else {
        // 0x1189b
        function_2d70(v4);
        v8 = 0;
        goto lab_0x11aa4;
    }
  lab_0x11aa4:;
    int64_t result = v8; // 0x11ab1
    if (v3 != __readfsqword(40)) {
        // 0x11ab3
        __stack_chk_fail();
        result = &g91;
    }
    // 0x11ab8
    return result;
  lab_0x119ce:
    // 0x119ce
    function_f77a(v4);
    *__errno_location() = v7;
    v8 = 0;
    goto lab_0x11aa4;
  lab_0x119c4:;
    int32_t v12 = *__errno_location(); // 0x119b9
    close(sock);
    v7 = v12;
    goto lab_0x119ce;
}

// Address range: 0x11aba - 0x11af7
int64_t function_11aba(int64_t result) {
    int32_t * v1 = (int32_t *)(result + 332); // 0x11ac6
    *v1 = *v1 & -96 | 2;
    return result;
}

// Address range: 0x11af7 - 0x11b34
int64_t function_11af7(int64_t result) {
    int32_t * v1 = (int32_t *)(result + 332); // 0x11b03
    *v1 = *v1 & -72 | 4;
    return result;
}

// Address range: 0x11b34 - 0x11be0
int64_t function_11b34(int64_t result) {
    int32_t * v1 = (int32_t *)(result + 332); // 0x11b44
    uint32_t v2 = *v1; // 0x11b44
    int32_t v3 = v2; // 0x11b4f
    if (v2 % 2 == 0) {
        // 0x11b51
        shutdown(*(int32_t *)(result + 16), SHUT_RD);
        v3 = *v1;
    }
    int32_t v4 = v3; // 0x11b68
    *v1 = (v4 & 16) == 0 ? v4 & -11 | 8 : v4 & 0xf000 | 1;
    return result;
}

// Address range: 0x11be0 - 0x11c8c
int64_t function_11be0(int64_t result) {
    int32_t * v1 = (int32_t *)(result + 332); // 0x11bf0
    uint32_t v2 = *v1; // 0x11bf0
    int32_t v3 = v2; // 0x11bfb
    if (v2 % 2 == 0) {
        // 0x11bfd
        shutdown(*(int32_t *)(result + 16), SHUT_WR);
        v3 = *v1;
    }
    int32_t v4 = v3; // 0x11c14
    *v1 = (v4 & 8) == 0 ? v4 & -19 | 16 : v4 & 0xf000 | 1;
    return result;
}

// Address range: 0x11c8c - 0x11cd0
int64_t function_11c8c(int64_t a1) {
    // 0x11c8c
    int64_t result; // 0x11c8c
    if (*(int32_t *)(a1 + 360) == 0) {
        // 0x11cc1
        result = function_11be0(a1);
    } else {
        int32_t * v1 = (int32_t *)(a1 + 332); // 0x11caa
        *v1 = *v1 | 64;
        result = a1;
    }
    // 0x11ccd
    return result;
}

// Address range: 0x11cd0 - 0x11e85
int64_t function_11cd0(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x11ce0
    int64_t v2 = *(int64_t *)(a1 + 40); // 0x11cfa
    int64_t v3 = 0; // 0x11cd0
    int64_t v4; // 0x11cd0
    switch ((int16_t)v4) {
        case 2: {
            int32_t v5 = *(int32_t *)(a1 + 76); // 0x11d33
            v3 = 0;
            if ((*(int32_t *)(v2 + 16) & v5) != *(int32_t *)(v2 + 12)) {
                goto lab_0x11e6c;
            } else {
                // 0x11d4e
                if (v5 != *(int32_t *)(v2 + 64)) {
                    goto lab_0x11d78;
                } else {
                    // 0x11d60
                    v3 = 0;
                    if ((int32_t)function_cfd3(a2 + 4) >= 0) {
                        goto lab_0x11e6c;
                    } else {
                        goto lab_0x11d78;
                    }
                }
            }
        }
        case 10: {
            unsigned char v6 = *(char *)(v2 + 40); // 0x11db7
            int64_t v7 = a1 + 80; // 0x11dca
            v3 = 0;
            if ((char)function_f37f(v7, v2 + 24, (int64_t)v6) == 0) {
                goto lab_0x11e6c;
            } else {
                // 0x11de0
                if ((char)function_f350(v7, v2 + 68) == 0) {
                    goto lab_0x11e26;
                } else {
                    // 0x11dff
                    int32_t v8; // bp-48, 0x11cd0
                    int64_t v9 = function_d049((int64_t *)(a2 + 8), (int64_t *)&v8); // 0x11e11
                    if ((int32_t)v9 < 0) {
                        goto lab_0x11e26;
                    } else {
                        // 0x11e1a
                        *(int32_t *)(a2 + 24) = v8;
                        v3 = 0;
                        goto lab_0x11e6c;
                    }
                }
            }
        }
        default: {
            goto lab_0x11e6c;
        }
    }
  lab_0x11e6c:;
    int64_t result = v3; // 0x11e7c
    if (v1 != __readfsqword(40)) {
        // 0x11e7e
        __stack_chk_fail();
        result = &g91;
    }
    // 0x11e83
    return result;
  lab_0x11d78:
    // 0x11d78
    if (*(char *)(v2 + 144) == 0) {
        // 0x11d9e
        *(int32_t *)(a2 + 4) = *(int32_t *)&g59;
        v3 = 0;
    } else {
        // 0x11d87
        *__errno_location() = 1;
        v3 = 0xffffffff;
    }
    goto lab_0x11e6c;
  lab_0x11e26:
    // 0x11e26
    if (*(char *)(v2 + 144) == 0) {
        int64_t v10 = *(int64_t *)0x222fd8; // 0x11e4d
        *(int64_t *)(a2 + 8) = *(int64_t *)v10;
        *(int64_t *)(a2 + 16) = *(int64_t *)(v10 + 8);
        v3 = 0;
    } else {
        // 0x11e35
        *__errno_location() = 1;
        v3 = 0xffffffff;
    }
    goto lab_0x11e6c;
}

// Address range: 0x11e85 - 0x11fe2
int64_t function_11e85(int64_t a1, int64_t * a2) {
    int64_t result2 = (int64_t)a2;
    int64_t v1 = *(int64_t *)(a1 + 40); // 0x11e99
    uint64_t v2; // 0x11e85
    int16_t v3 = v2;
    if (v3 == 2) {
        int32_t v4 = *(int32_t *)(a1 + 76); // 0x11ed2
        int32_t v5 = *(int32_t *)(v1 + 16); // 0x11ed9
        uint32_t result = *(int32_t *)(v1 + 12); // 0x11ee2
        if ((v5 & v4) != result) {
            // 0x11fdf
            return result;
        }
        if ((v5 || v4) == -1) {
            // 0x11f08
            *(int32_t *)(result2 + 4) = *(int32_t *)(v1 + 20);
            // 0x11fdf
            return result2;
        }
        int32_t * v6 = (int32_t *)(result2 + 4); // 0x11f1f
        if (*v6 != *(int32_t *)&g59) {
            uint32_t result3 = *(int32_t *)(v1 + 20); // 0x11f3a
            if (v4 == result3) {
                // 0x11fdf
                return result3;
            }
        }
        // 0x11f45
        *v6 = v4;
        // 0x11fdf
        return result2;
    }
    // 0x11ec0
    if (v3 != 10) {
        // 0x11fdf
        return v2 % 0x10000;
    }
    int64_t v7 = a1 + 80; // 0x11f6f
    int64_t result4 = function_f37f(v7, v1 + 24, (int64_t)*(char *)(v1 + 40)); // 0x11f78
    if ((char)result4 == 0) {
        // 0x11fdf
        return result4;
    }
    int64_t v8 = result2 + 8; // 0x11f85
    if ((char)function_f350(v8, *(int64_t *)0x222fd8) == 0) {
        int64_t result5 = function_f350(v7, v1 + 44) & 0xffffffff ^ 1; // 0x11fba
        if ((char)result5 == 0) {
            // 0x11fdf
            return result5;
        }
    }
    int64_t result6 = *(int64_t *)v7; // 0x11fcd
    *(int64_t *)v8 = result6;
    *(int64_t *)(result2 + 16) = *(int64_t *)(a1 + 88);
    // 0x11fdf
    return result6;
}

// Address range: 0x11fe2 - 0x120b2
int64_t function_11fe2(int64_t result2) {
    int64_t v1 = *(int64_t *)(result2 + 40); // 0x11ff2
    uint16_t result3 = *(int16_t *)(result2 + 72); // 0x11ffe
    if (result3 == 2) {
        int32_t * v2 = (int32_t *)(result2 + 76); // 0x12018
        int32_t v3 = *v2; // 0x12018
        if (v3 != 0) {
            int64_t result = g57 & (int64_t)(*(int32_t *)&g59 ^ v3); // 0x1203d
            if (result != 0) {
                // 0x120af
                return result;
            }
        }
        // 0x12045
        *v2 = *(int32_t *)(v1 + 20);
        // 0x120af
        return result2;
    }
    // 0x1200a
    if (result3 != 10) {
        // 0x120af
        return result3;
    }
    int64_t v4 = result2 + 80; // 0x12059
    if ((char)function_f350(v4, *(int64_t *)0x222fd0) == 0) {
        int64_t result4 = function_f350(v4, *(int64_t *)0x222fd8); // 0x12088
        if ((char)result4 == 0) {
            // 0x120af
            return result4;
        }
    }
    int64_t result5 = *(int64_t *)(v1 + 44); // 0x1209d
    *(int64_t *)v4 = result5;
    *(int64_t *)(result2 + 88) = *(int64_t *)(v1 + 52);
    // 0x120af
    return result5;
}

// Address range: 0x120b2 - 0x12107
int64_t function_120b2(int64_t a1, int64_t a2) {
    int64_t v1 = function_c3ca(a1 + 392, a2 & 0xffffffff); // 0x120d4
    int64_t result = v1; // 0x120db
    if ((char)v1 != 0) {
        int64_t v2 = *(int64_t *)(*(int64_t *)(a1 + 40) + (int64_t)&g8); // 0x120e5
        result = *(int64_t *)(v2 + 64);
    }
    // 0x12104
    return result;
}

// Address range: 0x12107 - 0x12129
int64_t function_12107(int64_t a1, int64_t a2) {
    // 0x12107
    function_1659d(a1);
    return 0;
}

// Address range: 0x12129 - 0x12190
int64_t function_12129(int64_t a1) {
    int64_t v1 = a1 + 8; // 0x12140
    int64_t * v2 = (int64_t *)(a1 + 24); // 0x1214e
    *(int32_t *)(a1 + 12) = (int32_t)(*(int64_t *)v1 - *v2);
    *(int32_t *)v1 = (int32_t)(*(int64_t *)(a1 + 16) - *v2);
    return 0;
}

// Address range: 0x12190 - 0x1228a
int64_t function_12190(int64_t a1, int64_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x121ae
    uint32_t v2 = *v1;
    int64_t v3 = v2; // 0x121c7
    function_c48d(a1, v3);
    if (v2 != *v1) {
        // 0x12288
        return 0xfffffff4;
    }
    uint32_t v4 = *(int32_t *)(a1 + 12); // 0x121ee
    int64_t v5 = a1 + 8;
    int32_t * v6 = (int32_t *)v5;
    uint32_t v7 = *v6;
    int64_t result; // 0x12190
    if (v2 > v4 == v2 > v7) {
        int64_t * v8 = (int64_t *)(a1 + 24); // 0x12246
        *(int64_t *)v5 = *v8 + (int64_t)v4;
        *(int64_t *)(a1 + 16) = *v8 + (int64_t)*v6;
        result = 0;
    } else {
        // 0x12202
        function_3080("Slirp", 8, "invalid sbuf offsets r/w=%u/%u len=%u", (int64_t)v7, (int64_t)v4, v3);
        result = 0xffffffea;
    }
    // 0x12288
    return result;
}

// Address range: 0x1228a - 0x1229e
int64_t function_1228a(int64_t a1, int64_t a2) {
    int32_t v1 = a2; // 0x12292
    int32_t v2 = v1 - 3; // 0x12295
    int64_t v3; // 0x1228a
    return v3 & -256 | (int64_t)(v2 == 0 | v2 < 0 != (2 - v1 & v1) < 0);
}

// Address range: 0x1229e - 0x122c1
int64_t function_1229e(int64_t a1, int64_t a2) {
    // 0x1229e
    int64_t v1; // 0x1229e
    return v1 & 0xff00 | (int64_t)(bool)((int16_t)v1 == 2);
}

// Address range: 0x122c1 - 0x1230a
int64_t function_122c1(int64_t a1) {
    int64_t result = 0xfffffff4; // 0x122e3
    if ((int32_t)function_17b83(a1) >= 0) {
        // 0x122ec
        *(int16_t *)(a1 + 72) = 2;
        *(int16_t *)(a1 + 200) = 2;
        result = 0;
    }
    // 0x12308
    return result;
}

// Address range: 0x1230a - 0x12361
int64_t function_1230a(int64_t a1) {
    int64_t v1 = a1;
    int16_t * v2 = (int16_t *)(a1 + 8); // 0x1231e
    *v2 = -1;
    int16_t v3 = *(int16_t *)&v1; // 0x1232b
    if (v3 == 2) {
        // 0x12334
        *v2 = 2;
        // 0x1235a
        return 0;
    }
    if (v3 == 10) {
        // 0x12350
        *v2 = 10;
    }
    // 0x1235a
    return 0;
}

// Address range: 0x12361 - 0x123f4
int64_t function_12361(int64_t a1, int64_t a2) {
    uint16_t v1 = *(int16_t *)(a1 + 8); // 0x1237c
    if (v1 == 10) {
        // 0x123ae
        *(int16_t *)a1 = 10;
        // 0x123f2
        return 0;
    }
    int64_t v2; // 0x12361
    int64_t v3; // 0x12361
    if (v1 > 10) {
        switch (v1) {
            case 23: {
            }
            case 28: {
                // 0x123ae
                *(int16_t *)a1 = 10;
                // 0x123f2
                return 0;
            }
        }
        // 0x123bc
        function_3080("Slirp", 8, "invalid ss_family type %x", (int64_t)v1, v3, v2);
        // 0x123f2
        return 0xffffffea;
    }
    if (v1 == 2) {
        // 0x123a0
        *(int16_t *)a1 = 2;
        // 0x123f2
        return 0;
    }
    // 0x123bc
    function_3080("Slirp", 8, "invalid ss_family type %x", (int64_t)v1, v3, v2);
    // 0x123f2
    return 0xffffffea;
}

// Address range: 0x123f4 - 0x124f5
int64_t slirp_state_save(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = __readfsqword(40); // 0x12408
    int64_t v2 = a2; // bp-40, 0x1241b
    int64_t v3 = *(int64_t *)(a1 + 128);
    if (v3 != 0) {
        uint16_t v4; // 0x12450
        int64_t v5; // 0x12468
        if (*(int64_t *)v3 != 0) {
            // 0x12444
            v4 = ntohs((int16_t)*(int32_t *)(v3 + 20));
            v5 = function_f0a9(a1, (int64_t)*(int32_t *)(v3 + 16), (int64_t)v4);
            if (v5 != 0) {
                // 0x12478
                function_12712(&v2, 42);
                function_1cc71(&v2, &g42, v5);
            }
        }
        int64_t v6 = *(int64_t *)(v3 + 32);
        while (v6 != 0) {
            int64_t v7 = v6;
            if (*(int64_t *)v7 != 0) {
                // 0x12444
                v4 = ntohs((int16_t)*(int32_t *)(v7 + 20));
                uint32_t v8 = *(int32_t *)(v7 + 16); // 0x1245c
                v5 = function_f0a9(a1, (int64_t)v8, (int64_t)v4);
                if (v5 != 0) {
                    // 0x12478
                    function_12712(&v2, 42);
                    function_1cc71(&v2, &g42, v5);
                }
            }
            // 0x124a3
            v6 = *(int64_t *)(v7 + 32);
        }
    }
    // 0x124b6
    function_12712(&v2, 0);
    function_1cc71(&v2, (char (**)[13])&g43, a1);
    int64_t result = 0; // 0x124ec
    if (v1 != __readfsqword(40)) {
        // 0x124ee
        __stack_chk_fail();
        result = &g91;
    }
    // 0x124f3
    return result;
}

// Address range: 0x124f5 - 0x1263d
int64_t slirp_state_load(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0x1250c
    int64_t v2 = a3; // bp-40, 0x1251f
    int64_t v3 = function_126ba(&v2); // 0x12600
    int32_t v4 = a2;
    int64_t v5; // 0x124f5
    if ((char)v3 != 0) {
        int64_t v6 = function_f694(a1); // 0x12537
        int64_t v7 = function_1cd2e(&v2, &g42, v6, v4); // 0x12555
        // 0x12530
        while ((int32_t)v7 >= 0) {
            int32_t v8 = *(int32_t *)(v6 + 76); // 0x1256f
            v5 = 0xffffffea;
            if ((*(int32_t *)(a1 + 16) & v8) != *(int32_t *)(a1 + 12)) {
                goto lab_0x12627_3;
            }
            int64_t v9 = *(int64_t *)(a1 + 128);
            v5 = 0xffffffea;
            if (v9 == 0) {
                goto lab_0x12627_3;
            }
            int64_t v10 = v9;
            while (true) {
                int64_t v11 = v10;
                if (*(int64_t *)v11 != 0) {
                    // 0x125ad
                    if (v8 == *(int32_t *)(v11 + 16)) {
                        // 0x125bf
                        if (*(int32_t *)(v11 + 20) == (int32_t)*(int16_t *)(v6 + 74)) {
                            // break -> 0x125f9
                            break;
                        }
                    }
                }
                // 0x125d5
                v10 = *(int64_t *)(v11 + 32);
                v5 = 0xffffffea;
                if (v10 == 0) {
                    goto lab_0x12627_3;
                }
            }
            // 0x125f9
            if ((char)function_126ba(&v2) == 0) {
                goto lab_0x1260d;
            }
            v6 = function_f694(a1);
            v7 = function_1cd2e(&v2, &g42, v6, v4);
        }
        // 0x12563
        v5 = v7 & 0xffffffff;
    } else {
      lab_0x1260d:
        // 0x1260d
        v5 = function_1cd2e(&v2, (char (**)[13])&g43, a1, v4);
    }
  lab_0x12627_3:;
    int64_t result = v5; // 0x12634
    if (v1 != __readfsqword(40)) {
        // 0x12636
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1263b
    return result;
}

// Address range: 0x1263d - 0x12648
int64_t slirp_state_version(void) {
    // 0x1263d
    return 4;
}

// Address range: 0x12648 - 0x12681
int64_t function_12648(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x12648
    return a1 & -256 | (int64_t)(bool)(a3 == a1);
}

// Address range: 0x12681 - 0x126ba
int64_t function_12681(int64_t a1, char * a2, int64_t a3) {
    // 0x12681
    return a1 & -256 | (int64_t)(bool)(a3 == a1);
}

// Address range: 0x126ba - 0x12712
int64_t function_126ba(int64_t * a1) {
    int64_t v1 = __readfsqword(40); // 0x126c6
    char v2; // bp-17, 0x126ba
    int64_t v3 = function_12648((int64_t)a1, (int64_t *)&v2, 1); // 0x126e8
    int64_t result = (char)v3 == 0 ? 0 : v2; // 0x12709
    if (v1 != __readfsqword(40)) {
        // 0x1270b
        __stack_chk_fail();
        result = &g91;
    }
    // 0x12710
    return result;
}

// Address range: 0x12712 - 0x1273d
int64_t function_12712(int64_t * a1, int64_t a2) {
    int64_t v1 = 0x100000000000000 * a2 / 0x100000000000000; // bp-20, 0x12720
    return function_12681((int64_t)a1, (char *)&v1, 1);
}

// Address range: 0x1273d - 0x12799
int64_t function_1273d(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x12749
    int16_t v2; // bp-18, 0x1273d
    int64_t v3 = function_12648(a1, (int64_t *)&v2, 2); // 0x1276b
    int64_t v4 = 0; // 0x12772
    if ((char)v3 != 0) {
        // 0x12774
        v4 = llvm_bswap_i16(v2);
    }
    int64_t result = v4; // 0x12790
    if (v1 != __readfsqword(40)) {
        // 0x12792
        __stack_chk_fail();
        result = &g91;
    }
    // 0x12797
    return result;
}

// Address range: 0x12799 - 0x127d1
int64_t function_12799(int64_t a1, uint64_t a2) {
    int64_t v1 = (int64_t)(0x1000000000000 * (a2 / 256 % 256 | 256 * a2)) / 0x1000000000000; // bp-20, 0x127b3
    return function_12681(a1, (char *)&v1, 2);
}

// Address range: 0x127d1 - 0x1284f
int64_t function_127d1(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x127dd
    int32_t v2; // bp-20, 0x127d1
    int64_t v3 = function_12648(a1, (int64_t *)&v2, 4); // 0x127ff
    int64_t v4 = 0; // 0x12806
    if ((char)v3 != 0) {
        // 0x12808
        v4 = llvm_bswap_i32(v2);
    }
    int64_t result = v4; // 0x12846
    if (v1 != __readfsqword(40)) {
        // 0x12848
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1284d
    return result;
}

// Address range: 0x1284f - 0x128a5
int64_t function_1284f(int64_t a1, int64_t a2) {
    int64_t v1 = llvm_bswap_i32((int32_t)a2); // bp-20, 0x12888
    return function_12681(a1, (char *)&v1, 4);
}

// Address range: 0x128a5 - 0x12901
int64_t function_128a5(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x128b1
    int16_t v2; // bp-18, 0x128a5
    int64_t v3 = function_12648(a1, (int64_t *)&v2, 2); // 0x128d3
    int64_t v4 = 0; // 0x128da
    if ((char)v3 != 0) {
        // 0x128dc
        v4 = llvm_bswap_i16(v2);
    }
    int64_t result = v4; // 0x128f8
    if (v1 != __readfsqword(40)) {
        // 0x128fa
        __stack_chk_fail();
        result = &g91;
    }
    // 0x128ff
    return result;
}

// Address range: 0x12901 - 0x12939
int64_t function_12901(int64_t a1, uint64_t a2) {
    int64_t v1 = (int64_t)(0x1000000000000 * (a2 / 256 % 256 | 256 * a2)) / 0x1000000000000; // bp-20, 0x1291b
    return function_12681(a1, (char *)&v1, 2);
}

// Address range: 0x12939 - 0x129b7
int64_t function_12939(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x12945
    int32_t v2; // bp-20, 0x12939
    int64_t v3 = function_12648(a1, (int64_t *)&v2, 4); // 0x12967
    int64_t v4 = 0; // 0x1296e
    if ((char)v3 != 0) {
        // 0x12970
        v4 = llvm_bswap_i32(v2);
    }
    int64_t result = v4; // 0x129ae
    if (v1 != __readfsqword(40)) {
        // 0x129b0
        __stack_chk_fail();
        result = &g91;
    }
    // 0x129b5
    return result;
}

// Address range: 0x129b7 - 0x12a0d
int64_t function_129b7(int64_t a1, int64_t a2) {
    int64_t v1 = llvm_bswap_i32((int32_t)a2); // bp-20, 0x129f0
    return function_12681(a1, (char *)&v1, 4);
}

// Address range: 0x12a0d - 0x12cfb
int64_t function_12a0d(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)(a1 + 112); // 0x12a26
    if (a2 == 0) {
        // 0x12cee
        return 0;
    }
    int64_t v2 = *(int64_t *)(a1 + 8); // 0x12a6f
    int64_t v3; // 0x12a0d
    int64_t v4; // 0x12a0d
    int32_t * v5; // 0x12a95
    if (v2 == a1) {
        // 0x12af4
        *(int64_t *)a2 = a3;
        v3 = a1;
        goto lab_0x12bae;
    } else {
        // 0x12a78
        v5 = (int32_t *)(a2 + 52);
        int32_t v6 = *(int32_t *)(v2 + 68) + (int32_t)*(int16_t *)(v2 + 62) - *v5; // 0x12a98
        if (v6 < 1) {
            goto lab_0x12af4_2;
        } else {
            // 0x12aa4
            if ((int64_t)v6 < (int64_t)*(int16_t *)(a2 + 46)) {
                // 0x12ac1
                uint64_t v7; // 0x12a9c
                function_a875(a3, v7);
            } else {
                // 0x12ab0
                function_a4f0(a3);
                v4 = a3;
                goto lab_0x12bc9;
            }
        }
    }
  lab_0x12bae:;
    int64_t v8 = a2 - 16; // 0x12bb7
    function_ab4c(v8, *(int64_t *)(v3 + 8));
    v4 = v8;
    goto lab_0x12bc9;
  lab_0x12af4_2:;
    int64_t v19 = *(int64_t *)v2; // 0x12aed
    *(int64_t *)a2 = a3;
    v3 = v19;
    if (v19 != a1) {
        int64_t v20 = v19;
        int32_t v21 = *v5 + (int32_t)*(int16_t *)(a2 + 46); // 0x12b0a
        int32_t * v22 = (int32_t *)(v20 + 68);
        int32_t v23 = v21 - *v22; // 0x12b11
        v3 = v20;
        while (v23 >= 1) {
            uint64_t v24 = (int64_t)v23; // 0x12b15
            int16_t * v25 = (int16_t *)(v20 + 62);
            if (v24 < (int64_t)*v25) {
                // 0x12b2f
                *v22 = v21;
                *v25 = *v25 - (int16_t)v23;
                function_a875(*(int64_t *)(v20 + 16), v24);
                v3 = v20;
                goto lab_0x12bae;
            }
            int64_t v26 = *(int64_t *)v20; // 0x12b65
            int64_t v27 = *(int64_t *)(v26 + 8); // 0x12b71
            function_ab7f(v27);
            function_a4f0(*(int64_t *)(v27 + 16));
            v3 = v26;
            if (v26 == a1) {
                // break -> 0x12bae
                break;
            }
            v20 = v26;
            v21 = *v5 + (int32_t)*(int16_t *)(a2 + 46);
            v22 = (int32_t *)(v20 + 68);
            v23 = v21 - *v22;
            v3 = v20;
        }
    }
    goto lab_0x12bae;
  lab_0x12bc9:
    // 0x12bc9
    if (v4 == a1 | *(int16_t *)(a1 + 16) < 4) {
        // 0x12cee
        return 0;
    }
    int32_t v9 = *(int32_t *)(v4 + 68); // 0x12bef
    int32_t * v10 = (int32_t *)(a1 + 152); // 0x12bf2
    if (v9 != *v10) {
        // 0x12cee
        return 0;
    }
    int64_t v11 = v4 + 16; // 0x12a0d
    *v10 = v9 + (int32_t)*(int16_t *)(v11 + 46);
    unsigned char v12 = *(char *)(v11 + 61); // 0x12c3c
    int64_t v13 = v11 - 16; // 0x12c49
    function_ab7f(v13);
    int64_t v14 = *(int64_t *)v11; // 0x12c55
    int64_t v15 = *(int64_t *)v13; // 0x12c60
    int64_t v16; // 0x12a0d
    if ((*(int32_t *)(v1 + 332) & 16) == 0) {
        // 0x12c86
        if (*(char *)(v1 + 329) == 0) {
            // 0x12cc1
            function_c59c(v1, v14);
        } else {
            // 0x12c95
            if ((int32_t)function_17d52(v1, v14, v14, v16) != 0) {
                // 0x12cac
                function_c59c(v1, v14);
            }
        }
    } else {
        // 0x12c78
        function_a4f0(v14);
    }
    int64_t v17 = v15 + 16; // 0x12c63
    while (v17 != a1) {
        int32_t v18 = *(int32_t *)(v15 + 68); // 0x12cd9
        if (v18 != *v10) {
            // break -> 0x12ceb
            break;
        }
        *v10 = v18 + (int32_t)*(int16_t *)(v17 + 46);
        v12 = *(char *)(v17 + 61);
        v13 = v17 - 16;
        function_ab7f(v13);
        v14 = *(int64_t *)v17;
        v15 = *(int64_t *)v13;
        if ((*(int32_t *)(v1 + 332) & 16) == 0) {
            // 0x12c86
            if (*(char *)(v1 + 329) == 0) {
                // 0x12cc1
                function_c59c(v1, v14);
            } else {
                // 0x12c95
                if ((int32_t)function_17d52(v1, v14, v14, v16) != 0) {
                    // 0x12cac
                    function_c59c(v1, v14);
                }
            }
        } else {
            // 0x12c78
            function_a4f0(v14);
        }
        // 0x12cd4
        v17 = v15 + 16;
    }
    // 0x12cee
    return v12 % 2;
}

// Address range: 0x12cfb - 0x14fe8
int64_t function_12cfb(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x12d16
    int64_t v2 = __readfsqword(40); // 0x12d2c
    int64_t v3 = a4; // 0x12d82
    int64_t v4; // 0x12cfb
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x12da1
        int64_t v5; // 0x12cfb
        int64_t v6; // 0x12cfb
        function_3080("Slirp", 128, "tcp_input...", a4, v6, v5);
        v3 = a4;
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x12db1
            function_3080("Slirp", 128, " m = %p  iphlen = %2d  inso = %p", a1, v1 & 0xffffffff, a3);
            v3 = a1;
            v4 = a3;
        }
    }
    int64_t v7 = 0x1000000000000 * a4 / 0x1000000000000; // 0x12d25
    int32_t * v8; // 0x12cfb
    int32_t * v9; // 0x12cfb
    int32_t * v10; // 0x12cfb
    int16_t * v11; // 0x12cfb
    int16_t * v12; // 0x12cfb
    int16_t * v13; // 0x12cfb
    int32_t * v14; // 0x12cfb
    int64_t v15; // 0x12cfb
    int64_t v16; // 0x12cfb
    int64_t v17; // 0x12cfb
    int64_t v18; // 0x12cfb
    int64_t v19; // 0x12cfb
    int64_t v20; // 0x12cfb
    int64_t v21; // 0x12cfb
    int64_t v22; // 0x12cfb
    int64_t v23; // 0x12cfb
    int64_t v24; // 0x12cfb
    int64_t v25; // 0x12cfb
    int64_t v26; // 0x12cfb
    int64_t v27; // bp-200, 0x12cfb
    int64_t v28; // bp-328, 0x12cfb
    int64_t v29; // 0x12cfb
    int64_t v30; // 0x12cfb
    int64_t v31; // 0x12cfb
    int64_t v32; // 0x12cfb
    int64_t v33; // 0x12cfb
    int32_t v34; // 0x12cfb
    int64_t v35; // 0x12cfb
    int64_t v36; // 0x12cfb
    int64_t v37; // 0x12cfb
    int64_t v38; // 0x12cfb
    int64_t v39; // 0x12cfb
    int32_t v40; // 0x12cfb
    int32_t v41; // 0x12cfb
    int32_t v42; // 0x12cfb
    int32_t v43; // 0x12cfb
    int64_t v44; // 0x12cfb
    int64_t v45; // 0x12cfb
    int64_t * v46; // 0x12cfb
    int16_t v47; // 0x12cfb
    int64_t v48; // 0x12ea3
    int32_t * v49; // 0x12cfb
    int64_t v50; // 0x12cfb
    int64_t v51; // 0x12cfb
    unsigned char v52; // 0x12cfb
    int32_t v53; // 0x131a9
    int16_t * v54; // 0x12cfb
    int32_t * net_long; // 0x12cfb
    int32_t * net_long2; // 0x13236
    int16_t * net_short; // 0x13247
    int64_t v55; // 0x12e91
    int16_t * net_short2; // 0x1325d
    int32_t * v56; // 0x132a0
    int64_t * v57; // 0x12ea3
    int64_t v58; // 0x12cfb
    int16_t * v59; // 0x12cfb
    if (a1 != 0) {
        // 0x12e8a
        v55 = *(int64_t *)(a1 + 64);
        v57 = (int64_t *)(a1 + 48);
        v48 = *v57;
        v47 = v7;
        int32_t v60; // 0x12cfb
        switch (v47) {
            case 2: {
                int64_t v61 = v48; // 0x12ee3
                if ((int32_t)v1 >= 21) {
                    // 0x12ee5
                    function_9e0e(a1, 0);
                    v61 = *v57;
                }
                int32_t v62 = *(int32_t *)(v48 + 16); // 0x12f1f
                *v57 = v61 - 28;
                int32_t * v63 = (int32_t *)(a1 + 56); // 0x12f5f
                *v63 = *v63 + 28;
                int64_t v64 = *v57; // 0x12f78
                uint16_t host_short = *(int16_t *)(v48 + 2); // 0x12f83
                *(int64_t *)(v64 - 8) = 0;
                *(int64_t *)(v64 - 16) = 0;
                memset((int64_t *)v64, 0, 8);
                memset((int64_t *)(v64 + 8), 0, 36);
                *(int16_t *)(v64 + 44) = 0;
                *(int32_t *)(v64 + 12) = v62;
                *(int16_t *)(v64 + 46) = htons(host_short);
                v60 = host_short;
                v34 = v62;
                v35 = *(int64_t *)(v48 + 8);
                v36 = *(int64_t *)v48;
                v15 = v64;
                // break -> 0x1316f
                break;
            }
            case 10: {
                int64_t v65 = *(int64_t *)(v48 + 8); // 0x13024
                int64_t v66 = *(int64_t *)(v48 + 16); // 0x13036
                int64_t v67 = *(int64_t *)(v48 + 24); // 0x1303a
                int64_t v68 = *(int64_t *)(v48 + 32); // 0x1304c
                *v57 = v48 - 8;
                int32_t * v69 = (int32_t *)(a1 + 56); // 0x13078
                *v69 = *v69 + 8;
                int64_t v70 = *v57; // 0x13091
                uint16_t host_short2 = *(int16_t *)(v48 + 4); // 0x1309c
                *(int64_t *)(v70 - 8) = 0;
                *(int64_t *)(v70 - 16) = 0;
                memset((int64_t *)v70, 0, 8);
                int64_t * v71 = (int64_t *)(v70 + 8); // 0x130e9
                memset(v71, 0, 36);
                *(int16_t *)(v70 + 44) = 0;
                *v71 = v65;
                *(int64_t *)(v70 + 16) = v66;
                *(int64_t *)(v70 + 24) = v67;
                *(int64_t *)(v70 + 32) = v68;
                *(int16_t *)(v70 + 46) = htons(host_short2);
                v29 = v68;
                v30 = v67;
                v31 = v66;
                v32 = v65;
                v33 = *(int64_t *)v48;
                v60 = host_short2;
                v15 = v70;
                // break -> 0x1316f
                break;
            }
            default: {
                // 0x1314a
                function_2ea0("Slirp", "../src/tcp_input.c", 308, "tcp_input", 0);
                // break -> 0x1316f
                break;
            }
        }
        // 0x1316f
        if ((int32_t)function_44c3(a1, (int64_t)(v60 + 48)) == 0) {
            unsigned char v72 = *(char *)(v15 + 60); // 0x1319d
            v52 = 4 * v72 / 16;
            v53 = v52;
            if (v72 >= 80 && v60 >= v53) {
                // 0x131d3
                v54 = (int16_t *)(v15 + 46);
                *v54 = (int16_t)(v60 - v53);
                v43 = 0;
                v39 = 0;
                if (v72 >= 96) {
                    // 0x131f6
                    v43 = v53 - 20;
                    v39 = *v57 + 68;
                }
                // 0x1321b
                net_long = (int32_t *)(v15 + 52);
                *net_long = ntohl(*net_long);
                net_long2 = (int32_t *)(v15 + 56);
                *net_long2 = ntohl(*net_long2);
                net_short = (int16_t *)(v15 + 62);
                *net_short = ntohs(*net_short);
                net_short2 = (int16_t *)(v15 + 66);
                *net_short2 = ntohs(*net_short2);
                *v57 = *v57 + (int64_t)(v52 + 48);
                v56 = (int32_t *)(a1 + 56);
                *v56 = -48 - v53 + *v56;
                int64_t v73 = &v28;
                int64_t v74 = v15 + 8;
                int16_t * v75 = (int16_t *)(v15 + 48);
                int16_t * v76 = (int16_t *)(v73 | 2);
                v58 = &v27;
                v59 = (int16_t *)(v15 + 50);
                int16_t * v77 = (int16_t *)(v58 | 2);
                v49 = (int32_t *)(v15 + 12);
                v50 = v55 + 448;
                v51 = v55 + (int64_t)&g68;
                v46 = (int64_t *)(v55 + 128);
                v41 = 0;
                v22 = 0;
                v18 = (int64_t)*(char *)(v15 + 61);
                while (true) {
                  lab_0x132be:
                    // 0x132be
                    v19 = v18;
                    v23 = v22;
                    v42 = v41;
                    v28 = v7;
                    v27 = v7;
                    switch (v47) {
                        case 2: {
                            // 0x132f0
                            *(int32_t *)(v73 | 4) = *(int32_t *)v74;
                            *v76 = *v75;
                            *(int32_t *)(v58 | 4) = *v49;
                            *v77 = *v59;
                            goto lab_0x133e8;
                        }
                        case 10: {
                            // 0x13351
                            *(int64_t *)(v73 + 8) = *(int64_t *)v74;
                            *(int64_t *)(v73 + 16) = *(int64_t *)(v15 + 16);
                            *v76 = *v75;
                            *(int64_t *)(v58 + 8) = *(int64_t *)(v15 + 24);
                            *(int64_t *)(v58 + 16) = *(int64_t *)(v15 + 32);
                            *v77 = *v59;
                            goto lab_0x133e8;
                        }
                        default: {
                            // 0x133c3
                            function_2ea0("Slirp", "../src/tcp_input.c", 370, "tcp_input", 0);
                            goto lab_0x133e8;
                        }
                    }
                }
            }
        }
        // 0x14fb0
        lab_0x14fb0_3:
        function_a4f0(a1);
        goto lab_0x14fc5;
    } else {
        int64_t v78 = *(int64_t *)(a3 + 336); // 0x12e20
        int64_t * v79 = (int64_t *)(a3 + 48); // 0x12e2e
        int64_t v80 = *v79; // 0x12e2e
        *v79 = 0;
        int64_t v81 = *(int64_t *)(a3 + 56); // 0x12e4f
        int64_t v82 = (int64_t)*(char *)(v81 + 61); // 0x12e68
        if (*(int32_t *)(a3 + 332) % 2 == 0) {
            // 0x14046
            function_1659d(v78);
            v14 = (int32_t *)(v78 + 148);
            v13 = (int16_t *)(v81 + 46);
            v12 = (int16_t *)(v78 + 22);
            v11 = (int16_t *)(v78 + 16);
            v10 = (int32_t *)(v78 + 164);
            v9 = (int32_t *)(v78 + 152);
            v8 = (int32_t *)(v81 + 52);
            v26 = v3;
            v40 = (int32_t)*(int16_t *)(v81 + 62);
            v37 = *(int64_t *)(a3 + 40);
            v38 = a3;
            v24 = v78;
            v44 = v80;
            v16 = v81;
            v20 = v82;
            goto lab_0x1405d;
        } else {
            // 0x14005
            v25 = function_17098(v78);
            v45 = v80;
            v17 = v81;
            v21 = v82;
            goto lab_0x14eee_4;
        }
    }
  lab_0x14eee_4:
    // 0x14eee
    if ((v21 & 16) == 0) {
        int16_t * v83 = (int16_t *)(v17 + 46);
        int16_t v84 = *v83;
        int16_t v85 = v84; // 0x14f3d
        if ((v21 & 2) != 0) {
            // 0x14f3f
            v85 = v84 + 1;
            *v83 = v85;
        }
        int32_t v86 = *(int32_t *)(v17 + 52); // 0x14f55
        function_16709(v25, v17, v45, (int64_t)(v86 + (int32_t)v85), 0, 20, v7 % 0x10000);
    } else {
        uint32_t v87 = *(int32_t *)(v17 + 56); // 0x14eff
        function_16709(v25, v17, v45, 0, (int64_t)v87, 4, v7 % 0x10000);
    }
    goto lab_0x14fc5;
  lab_0x144f6:;
    // 0x144f6
    int64_t v184; // 0x12cfb
    int64_t v208 = v184 & 4;
    int16_t * v186; // 0x12cfb
    if (v208 == 0) {
        goto lab_0x14550;
    } else {
        int64_t v281 = (int64_t)*v186 + 0xfffffffd; // 0x14505
        if ((int32_t)v281 < 8) {
            int32_t v282 = *(int32_t *)((4 * v281 & 0x3fffffffc) + (int64_t)&g19); // 0x1451e
            return (int64_t)v282 + (int64_t)&g19;
        }
        goto lab_0x14550;
    }
  lab_0x144c3:;
    // 0x144c3
    int32_t v196; // 0x14427
    function_a875(a1, (int64_t)-v196);
    int16_t v283 = *v54 - (int16_t)v196; // 0x144ec
    *v54 = v283;
    int16_t v199 = v283; // 0x144f2
    int64_t v284; // 0x12cfb
    v184 = v284 & 0xfffffff6;
    goto lab_0x144f6;
  lab_0x14497_2:;
    int64_t v207; // 0x12cfb
    int64_t v188; // 0x13783
    int32_t v285; // 0x14408
    int32_t v286; // 0x14419
    int32_t v287; // 0x1441f
    if (v285 == v286 == v287 == 0) {
        int16_t * v288 = (int16_t *)(v188 + 36); // 0x144b8
        *v288 = *v288 | 1;
        goto lab_0x144c3;
    } else {
        // 0x14497
        v207 = v284 & 4;
        goto lab_0x14eac;
    }
  lab_0x133e8:;
    int64_t v289 = function_f5a7(v51, v50, (int16_t *)&v28, (int16_t *)&v27); // 0x13418
    int64_t v290 = v289; // 0x1342c
    int64_t v291 = v58; // 0x1342c
    int64_t v292; // 0x12cfb
    int64_t v293; // 0x134c7
    if (v289 != 0) {
        goto lab_0x13764;
    } else {
        // 0x13432
        if (*(int32_t *)(v55 + 124) != 0) {
            int64_t v294 = *v46;
            v25 = v23;
            v45 = a1;
            v17 = v15;
            v21 = v19;
            if (v294 == 0) {
                goto lab_0x14eee_4;
            }
            int64_t v295 = v294;
            while (true) {
                int64_t v296 = v295;
                if (*(int32_t *)(v296 + 20) == (int32_t)*v59) {
                    // 0x1346e
                    if (*v49 == *(int32_t *)(v296 + 16)) {
                        // break -> 0x134ae
                        break;
                    }
                }
                // 0x13481
                v295 = *(int64_t *)(v296 + 32);
                v25 = v23;
                v45 = a1;
                v17 = v15;
                v21 = v19;
                if (v295 == 0) {
                    goto lab_0x14eee_4;
                }
            }
        }
        // 0x134ae
        v25 = v23;
        v45 = a1;
        v17 = v15;
        v21 = v19;
        if ((v19 & 55) != 2) {
            goto lab_0x14eee_4;
        }
        // 0x134bd
        v293 = function_f694(v55);
        if ((int32_t)function_17b83(v293) < 0) {
            // 0x134e6
            function_2d70(v293);
            v25 = v23;
            v45 = a1;
            v17 = v15;
            v21 = v19;
            goto lab_0x14eee_4;
        }
        // 0x134fa
        function_c48d(v293 + 392, (int64_t)&g38);
        function_c48d(v293 + 360, (int64_t)&g38);
        *(int64_t *)(v293 + 200) = 0x1000000000000 * v28 / 0x1000000000000;
        *(int64_t *)(v293 + 72) = 0x1000000000000 * v27 / 0x1000000000000;
        char v297 = function_17be5(v293); // 0x136e7
        char * v298 = (char *)(v293 + 328); // 0x136e7
        *v298 = v297;
        if (v297 != 0) {
            goto lab_0x13750;
        } else {
            switch (v47) {
                case 2: {
                    // 0x13712
                    *v298 = *(char *)(v15 + 1);
                    goto lab_0x13750;
                }
                case 10: {
                    goto lab_0x13750;
                }
                default: {
                    // 0x13727
                    function_2ea0("Slirp", "../src/tcp_input.c", 431, "tcp_input", 0);
                    v292 = (int64_t)"tcp_input";
                    goto lab_0x13750;
                }
            }
        }
    }
  lab_0x13764:;
    int64_t v193 = v290;
    int32_t * v192 = (int32_t *)(v193 + 332);
    if ((*v192 & 2) != 0) {
        // break -> 0x14fb0
        goto lab_0x14fb0_3;
    }
    // 0x1377c
    v188 = *(int64_t *)(v193 + 336);
    v25 = 0;
    v45 = a1;
    v17 = v15;
    v21 = v19;
    if (v188 == 0) {
        goto lab_0x14eee_4;
    }
    // 0x13793
    v186 = (int16_t *)(v188 + 16);
    if (*v186 == 0) {
        // break -> 0x14fb0
        goto lab_0x14fb0_3;
    }
    int64_t v299 = v291;
    uint16_t v300 = *net_short; // 0x137a0
    *(int16_t *)(v188 + 180) = 0;
    int16_t * v263 = (int16_t *)(v188 + 22);
    *v263 = g61 == 0 ? 0x3840 : 150;
    int64_t v301 = v299; // 0x137dc
    if (v39 != 0) {
        // 0x137de
        v301 = v299;
        if (*v186 != 1) {
            // 0x137e8
            function_14fe8(v188, v39, v43, v15);
            v301 = v15;
        }
    }
    int32_t v197 = v300; // 0x137a9
    int64_t v302 = v301;
    int64_t v303 = v302; // 0x1380b
    int32_t v256; // 0x12cfb
    int32_t * v258; // 0x12cfb
    int32_t * v257; // 0x12cfb
    if (*v186 == 4) {
        // 0x13811
        v303 = v302;
        if ((v19 & 55) == 16) {
            int32_t * v304 = (int32_t *)(v188 + 152);
            int32_t v305 = *v304; // 0x13825
            v303 = v302;
            if (!((v300 == 0 | *net_long != v305))) {
                uint32_t v306 = *(int32_t *)(v188 + 144); // 0x13840
                v303 = v302;
                if (v306 == v197) {
                    // 0x13852
                    v258 = (int32_t *)(v188 + 168);
                    int32_t v307 = *v258; // 0x13855
                    v303 = v302;
                    if (*(int32_t *)(v188 + 124) == v307) {
                        uint16_t v308 = *v54; // 0x13863
                        int32_t v309 = *net_long2;
                        v257 = (int32_t *)(v188 + 120);
                        int32_t v310 = *v257;
                        if (v308 != 0) {
                            // 0x1396a
                            v303 = v302;
                            if (v309 == v310) {
                                // 0x1397a
                                v303 = v302;
                                if (v188 == *(int64_t *)v188) {
                                    int32_t v311 = *(int32_t *)(v193 + 360); // 0x139a3
                                    uint32_t v312 = *(int32_t *)(v193 + 364) - v311; // 0x139a9
                                    int64_t v313 = v312; // 0x139a9
                                    uint32_t v314 = (int32_t)v308; // 0x139ad
                                    v303 = v313;
                                    if (v312 >= v314) {
                                        // 0x139b5
                                        *v304 = v305 + v314;
                                        if (*(char *)(v193 + 329) == 0) {
                                            // 0x13a16
                                            function_c59c(v193, a1);
                                            goto lab_0x13a2f;
                                        } else {
                                            // 0x139de
                                            if ((int32_t)function_17d52(v193, a1, a1, v313) == 0) {
                                                goto lab_0x13a2f;
                                            } else {
                                                // 0x139fb
                                                function_c59c(v193, a1);
                                                goto lab_0x13a2f;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            int32_t v315 = v309 - v310;
                            v303 = v302;
                            if (v315 >= 1) {
                                int32_t v316 = v309 - v307; // 0x13891
                                v303 = v302;
                                if (v316 >= 0 != v316 != 0) {
                                    // 0x1389d
                                    v303 = v302;
                                    if (*(int32_t *)(v188 + 172) >= v306) {
                                        int16_t v317 = *(int16_t *)(v188 + 182); // 0x138b1
                                        v256 = v315;
                                        if (v317 == 0) {
                                            goto lab_0x138e2;
                                        } else {
                                            // 0x138bd
                                            v256 = v315;
                                            if (v309 - *(int32_t *)(v188 + 184) < 1) {
                                                goto lab_0x138e2;
                                            } else {
                                                // 0x138d0
                                                function_1514f(v188, (int64_t)v317 & 0xffffffff);
                                                v256 = *net_long2 - *v257;
                                                goto lab_0x138e2;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    int64_t v261 = v303;
    int32_t v318 = *(int32_t *)(v193 + 360); // 0x13a5b
    int32_t v319 = *(int32_t *)(v193 + 364) - v318; // 0x13a61
    int32_t v320 = v319 >= 0 ? v319 : 0;
    int32_t * v264 = (int32_t *)(v188 + 164);
    int32_t * v265 = (int32_t *)(v188 + 152);
    int32_t v321 = *v264 - *v265; // 0x13a8a
    int32_t v322 = v320 - v321; // 0x13a8e
    int32_t * v262 = (int32_t *)(v188 + 148);
    *v262 = v322 < 0 == ((v322 ^ v320) & (v320 ^ v321)) < 0 ? v320 : v321;
    int64_t v323; // 0x12cfb
    int32_t v259; // 0x12cfb
    int64_t v324; // 0x12cfb
    int64_t v325; // 0x12cfb
    int64_t v326; // 0x12cfb
    int32_t v327; // 0x12cfb
    switch (*v186) {
        case 1: {
            if ((v19 & 4) != 0) {
                // 0x14fb0
                function_a4f0(a1);
                goto lab_0x14fc5;
            } else {
                // 0x13ac7
                v25 = v188;
                v45 = a1;
                v17 = v15;
                v21 = v19;
                if ((v19 & 16) != 0) {
                    goto lab_0x14eee_4;
                } else {
                    if ((v19 & 2) == 0) {
                        // 0x14fb0
                        function_a4f0(a1);
                        goto lab_0x14fc5;
                    } else {
                        if (v47 != 2) {
                            goto lab_0x13bf2;
                        } else {
                            int32_t v328 = *(int32_t *)(v193 + 76); // 0x13af8
                            if ((*(int32_t *)(v55 + 16) & v328) != *(int32_t *)(v55 + 12)) {
                                goto lab_0x13bf2;
                            } else {
                                // 0x13b19
                                if (v328 == *(int32_t *)(v55 + 20)) {
                                    goto lab_0x13bf2;
                                } else {
                                    // 0x13b35
                                    if (v328 == *(int32_t *)(v55 + 64)) {
                                        goto lab_0x13bf2;
                                    } else {
                                        int64_t v329 = *v46;
                                        if (v329 != 0) {
                                            int32_t v330 = (int32_t)*(int16_t *)(v193 + 74); // 0x13b80
                                            int32_t v331; // 0x12cfb
                                            if (*(int32_t *)(v329 + 20) == v330) {
                                                // 0x13b84
                                                if (v328 == *(int32_t *)(v329 + 16)) {
                                                    // 0x13b9c
                                                    v331 = *v192 | 128;
                                                    *v192 = v331;
                                                    v259 = v331;
                                                    goto lab_0x13bd8;
                                                }
                                            }
                                            int64_t v332 = *(int64_t *)(v329 + 32);
                                            while (v332 != 0) {
                                                int64_t v333 = v332;
                                                if (*(int32_t *)(v333 + 20) == v330) {
                                                    // 0x13b84
                                                    if (v328 == *(int32_t *)(v333 + 16)) {
                                                        // 0x13b9c
                                                        v331 = *v192 | 128;
                                                        *v192 = v331;
                                                        v259 = v331;
                                                        goto lab_0x13bd8;
                                                    }
                                                }
                                                // 0x13bbc
                                                v332 = *(int64_t *)(v333 + 32);
                                            }
                                        }
                                        // 0x13bd8
                                        v259 = *v192;
                                        goto lab_0x13bd8;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        case 2: {
            if ((v19 & 16) == 0) {
                goto lab_0x14131;
            } else {
                int32_t v334 = *net_long2; // 0x14103
                v25 = v188;
                v45 = a1;
                v17 = v15;
                v21 = v19;
                if (v334 - *(int32_t *)(v188 + 140) < 1) {
                    goto lab_0x14eee_4;
                } else {
                    int32_t v335 = v334 - *(int32_t *)(v188 + 168); // 0x14125
                    v25 = v188;
                    v45 = a1;
                    v17 = v15;
                    v21 = v19;
                    if (v335 >= 0 == (v335 != 0)) {
                        goto lab_0x14eee_4;
                    } else {
                        goto lab_0x14131;
                    }
                }
            }
        }
        default: {
            int32_t v336 = *net_long; // 0x142b6
            int32_t v337 = *v265 - v336; // 0x142bb
            v326 = v19;
            if (v337 < 1) {
                goto lab_0x143cf;
            } else {
                int32_t v338 = v337; // 0x142da
                int64_t v339 = v19; // 0x142da
                if ((v19 & 2) != 0) {
                    // 0x142dc
                    *net_long = v336 + 1;
                    uint16_t v340 = *net_short2; // 0x142ed
                    int64_t v341; // 0x12cfb
                    if (v340 < 2) {
                        // 0x1430a
                        v341 = v19 & 0xffffffdd;
                    } else {
                        // 0x142f9
                        *net_short2 = v340 - 1;
                        v341 = v19 & 0xfffffffd;
                    }
                    // 0x1430e
                    v338 = v337 - 1;
                    v339 = v341;
                }
                // 0x14315
                v324 = v339;
                int32_t v342 = v338;
                uint16_t v343 = *v54; // 0x14315
                int64_t v344 = v342;
                if (v344 > (int64_t)v343) {
                    goto lab_0x14341;
                } else {
                    // 0x14326
                    v323 = v344;
                    v327 = v342;
                    v325 = v324;
                    if (v342 != (int32_t)v343) {
                        goto lab_0x1435f;
                    } else {
                        // 0x14337
                        if (v324 % 2 != 0) {
                            goto lab_0x1435f;
                        } else {
                            goto lab_0x14341;
                        }
                    }
                }
            }
        }
    }
  lab_0x13750:
    // 0x13750
    *(int16_t *)(*(int64_t *)(v293 + 336) + 16) = 1;
    v290 = v293;
    v291 = v292;
    goto lab_0x13764;
  lab_0x143cf:
    // 0x143cf
    v284 = v326;
    if (*v192 % 2 != 0) {
        // 0x143e3
        if (*v186 >= 6) {
            // 0x143ed
            if (*v54 != 0) {
                // 0x143f8
                v25 = function_17098(v188);
                v45 = a1;
                v17 = v15;
                v21 = v284;
                goto lab_0x14eee_4;
            }
        }
    }
    // 0x14408
    v285 = *net_long;
    uint16_t v345 = *v54; // 0x1440d
    v286 = *v265;
    v287 = *v262;
    v196 = v285 + (int32_t)v345 - v286 - v287;
    v199 = v345;
    v184 = v284;
    if (v196 < 1) {
        goto lab_0x144f6;
    }
    if ((int64_t)v196 < (int64_t)v345) {
        goto lab_0x144c3;
    }
    if ((v284 & 2) == 0) {
        goto lab_0x14497_2;
    }
    // 0x14459
    if (v285 - v286 < 1 | *v186 != 10) {
        goto lab_0x14497_2;
    }
    int64_t v346 = function_17098(v188); // 0x1448a
    v41 = v286 + (int32_t)&g33;
    v22 = v346;
    v18 = v284;
    goto lab_0x132be;
  lab_0x14341:;
    int16_t * v347 = (int16_t *)(v188 + 36); // 0x14345
    *v347 = *v347 | 1;
    uint16_t v348 = *v54; // 0x14350
    v323 = v348;
    v327 = v348;
    v325 = v324 & 0xfffffffe;
    goto lab_0x1435f;
  lab_0x1435f:;
    int64_t v349 = v325;
    function_a875(a1, (int64_t)v327);
    *net_long = *net_long + v327;
    int16_t v350 = v327;
    *v54 = *v54 - v350;
    uint16_t v351 = *net_short2; // 0x1439c
    if (v323 < (int64_t)v351) {
        // 0x143ad
        *net_short2 = v351 - v350;
        v326 = v349;
    } else {
        // 0x143c3
        *net_short2 = 0;
        v326 = v349 & 0xffffffdf;
    }
    goto lab_0x143cf;
  lab_0x14fc5:;
    int64_t result = 0; // 0x14fd2
    if (v2 != __readfsqword(40)) {
        // 0x14fd4
        __stack_chk_fail();
        result = &g91;
    }
    // 0x14fd9
    return result;
  lab_0x1405d:;
    int32_t * v88 = (int32_t *)(v37 + (int64_t)&g69);
    int32_t * v89 = (int32_t *)(v24 + 140);
    *v89 = *v88;
    int32_t * v90 = v14; // 0x1406a
    int16_t * v91 = v13; // 0x1406a
    int16_t * v92 = v12; // 0x1406a
    int16_t * v93 = v11; // 0x1406a
    int32_t * v94 = v10; // 0x1406a
    int32_t * v95 = v9; // 0x1406a
    int32_t * v96 = v89; // 0x1406a
    int32_t * v97 = v8; // 0x1406a
    int32_t * v98 = v88; // 0x1406a
    int64_t v99 = v26; // 0x1406a
    int32_t v100 = v40; // 0x1406a
    int64_t v101 = v38; // 0x1406a
    int64_t v102 = v44; // 0x1406a
    int64_t v103 = v16; // 0x1406a
    int64_t v104 = v20; // 0x1406a
    int64_t v105 = v24; // 0x1406a
    goto lab_0x14070;
  lab_0x14070:;
    int32_t * v106 = v98;
    *v106 = *v106 + 0xfa00;
    int32_t * v107 = (int32_t *)(v105 + 160); // 0x14095
    *v107 = *v97;
    int32_t v108 = *v96; // 0x1409b
    *(int32_t *)(v105 + 128) = v108;
    *(int32_t *)(v105 + 168) = v108;
    *(int32_t *)(v105 + 124) = v108;
    *(int32_t *)(v105 + 120) = v108;
    int32_t v109 = *v107 + 1; // 0x140c8
    *v95 = v109;
    *v94 = v109;
    int16_t * v110 = (int16_t *)(v105 + 36); // 0x140dd
    *v110 = *v110 | 1;
    *v93 = 3;
    *v92 = 150;
    int32_t * v111 = v90; // 0x140f4
    int16_t * v112 = v91; // 0x140f4
    int32_t * v113 = v97; // 0x140f4
    int32_t v114 = v100; // 0x140f4
    int64_t v115 = v101; // 0x140f4
    int64_t v116 = v99; // 0x140f4
    int64_t v117 = v105; // 0x140f4
    int64_t v118 = v102; // 0x140f4
    int64_t v119 = v103; // 0x140f4
    int64_t v120 = v104; // 0x140f4
    goto lab_0x1422e;
  lab_0x1422e:;
    int32_t v121 = *v113 + 1; // 0x14233
    *v113 = v121;
    uint32_t v122 = *v111; // 0x14244
    uint32_t v123 = (int32_t)*v112; // 0x1424a
    int32_t v124 = v121; // 0x1424c
    int64_t v125 = v120; // 0x1424c
    if (v122 < v123) {
        // 0x1424e
        function_a875(v118, (int64_t)(v122 - v123));
        *v112 = (int16_t)*v111;
        v124 = *v113;
        v125 = v120 & 0xfffffffe;
    }
    // 0x14ad2
    *(int32_t *)(v117 + 132) = v124 - 1;
    *(int32_t *)(v117 + 156) = *v113;
    int64_t v126 = v125; // 0x14ada
    int64_t v127 = v119; // 0x14ada
    int64_t v128 = v118; // 0x14ada
    int64_t v129 = v117; // 0x14ada
    int64_t v130 = v116; // 0x14ada
    int64_t v131 = v115; // 0x14ada
    int32_t v132 = 0; // 0x14ada
    int32_t * v133; // 0x12cfb
    int64_t v134; // 0x12cfb
    int64_t v135; // 0x12cfb
    int64_t v136; // 0x12cfb
    int64_t v137; // 0x12cfb
    int64_t v138; // 0x12cfb
    int32_t v139; // 0x12cfb
    int32_t v140; // 0x12cfb
    int64_t v141; // 0x12cfb
    if ((v125 & 16) == 0) {
        goto lab_0x14b7a;
    } else {
        // 0x14ad2
        v133 = (int32_t *)(v119 + 52);
        v135 = v125;
        v134 = v119;
        v141 = v118;
        v136 = v117;
        v137 = v116;
        v138 = v115;
        v140 = 0;
        v139 = v114;
        goto lab_0x14ae0;
    }
  lab_0x14b7a:;
    int64_t v142 = v129;
    int64_t v143 = v128;
    int64_t v144; // 0x12cfb
    int64_t v145; // 0x12cfb
    if ((v126 & 32) == 0) {
        goto lab_0x14c54;
    } else {
        int16_t * v146 = (int16_t *)(v127 + 66); // 0x14b88
        uint16_t v147 = *v146; // 0x14b88
        if (v147 == 0) {
            goto lab_0x14c54;
        } else {
            // 0x14b97
            if (*(int16_t *)(v142 + 16) > 9) {
                goto lab_0x14c54;
            } else {
                int32_t * v148 = (int32_t *)(v131 + 360); // 0x14bb5
                int32_t v149 = v147; // 0x14bbb
                if (*v148 + v149 > *(int32_t *)(v131 + 364)) {
                    // 0x14bce
                    *v146 = 0;
                    v145 = v130;
                    v144 = v126 & 0xffffffdf;
                } else {
                    int32_t * v150 = (int32_t *)(v127 + 52); // 0x14bdf
                    int32_t v151 = *v150 + v149; // 0x14bed
                    int32_t * v152 = (int32_t *)(v142 + 156); // 0x14bef
                    v145 = v130;
                    v144 = v126;
                    if (v151 - *v152 >= 1) {
                        // 0x14bfd
                        *v152 = v151;
                        uint32_t v153 = v151 - *(int32_t *)(v142 + 152); // 0x14c2c
                        *(int32_t *)(v131 + 64) = v153 + *v148;
                        *v152 = *v150 + (int32_t)*v146;
                        v145 = v153;
                        v144 = v126;
                    }
                }
                goto lab_0x14c77;
            }
        }
    }
  lab_0x14c54:;
    int32_t v154 = *(int32_t *)(v142 + 152); // 0x14c54
    int32_t * v155 = (int32_t *)(v142 + 156); // 0x14c5a
    v145 = v130;
    v144 = v126;
    if (v154 - *v155 >= 1) {
        // 0x14c68
        *v155 = v154;
        v145 = v130;
        v144 = v126;
    }
    goto lab_0x14c77;
  lab_0x14ae0:;
    int32_t * v161 = (int32_t *)(v136 + 132); // 0x14ae0
    int32_t v213 = *v161; // 0x14ae0
    int32_t v214 = *v133; // 0x14ae6
    int32_t * v163; // 0x12cfb
    int32_t * v162; // 0x12cfb
    if (v213 - v214 < 0) {
        // 0x14ae0
        v162 = (int32_t *)(v136 + 136);
        v163 = (int32_t *)(v134 + 56);
        goto lab_0x14b32;
    } else {
        // 0x14af3
        v126 = v135;
        v127 = v134;
        v128 = v141;
        v129 = v136;
        v130 = v137;
        v131 = v138;
        v132 = v140;
        if (v213 != v214) {
            goto lab_0x14b7a;
        } else {
            int32_t * v215 = (int32_t *)(v136 + 136);
            int32_t v216 = *v215; // 0x14b02
            int32_t * v217 = (int32_t *)(v134 + 56);
            int32_t v218 = *v217; // 0x14b08
            v162 = v215;
            v163 = v217;
            if (v216 - v218 < 0) {
                goto lab_0x14b32;
            } else {
                // 0x14b15
                v126 = v135;
                v127 = v134;
                v128 = v141;
                v129 = v136;
                v130 = v137;
                v131 = v138;
                v132 = v140;
                if (v216 != v218) {
                    goto lab_0x14b7a;
                } else {
                    // 0x14b24
                    v162 = v215;
                    v163 = v217;
                    v126 = v135;
                    v127 = v134;
                    v128 = v141;
                    v129 = v136;
                    v130 = v137;
                    v131 = v138;
                    v132 = v140;
                    if (v139 > *(int32_t *)(v136 + 144)) {
                        goto lab_0x14b32;
                    } else {
                        goto lab_0x14b7a;
                    }
                }
            }
        }
    }
  lab_0x14c77:;
    int16_t * v156 = (int16_t *)(v127 + 46); // 0x14c77
    int16_t v157 = *v156; // 0x14c77
    int16_t v158 = v157; // 0x14c80
    if (v157 < 6) {
        // 0x14c8e
        if (*(char *)(v127 + 68) != 27) {
            goto lab_0x14cbc;
        } else {
            int16_t * v159 = (int16_t *)(v142 + 36); // 0x14c98
            *v159 = *v159 | 1;
            v158 = *v156;
            goto lab_0x14ca3;
        }
    } else {
        goto lab_0x14ca3;
    }
  lab_0x14ca3:
    // 0x14ca3
    if (v144 % 2 == 0 == v158 == 0) {
        // 0x14dc8
        function_a4f0(v143);
        goto lab_0x14e80;
    } else {
        goto lab_0x14cbc;
    }
  lab_0x14b32:;
    int32_t * v160 = (int32_t *)(v136 + 144); // 0x14b38
    *v160 = v139;
    *v161 = *v133;
    *v162 = *v163;
    uint32_t v164 = *v160; // 0x14b54
    int32_t * v165 = (int32_t *)(v136 + 196); // 0x14b5a
    v126 = v135;
    v127 = v134;
    v128 = v141;
    v129 = v136;
    v130 = v137;
    v131 = v138;
    v132 = 1;
    if (v164 > *v165) {
        // 0x14b64
        *v165 = v164;
        v126 = v135;
        v127 = v134;
        v128 = v141;
        v129 = v136;
        v130 = v137;
        v131 = v138;
        v132 = 1;
    }
    goto lab_0x14b7a;
  lab_0x14cbc:;
    int16_t * v166 = (int16_t *)(v142 + 16);
    int16_t v167 = *v166; // 0x14cbc
    int64_t v168; // 0x12cfb
    int32_t * v169; // 0x12cfb
    if (v167 > 9) {
        // 0x14dc8
        function_a4f0(v143);
        goto lab_0x14e80;
    } else {
        // 0x14cca
        v169 = (int32_t *)(v142 + 152);
        if (*(int32_t *)(v127 + 52) != *v169) {
            goto lab_0x14d8d;
        } else {
            // 0x14cdd
            if (v167 == 4 == v142 == *(int64_t *)v142) {
                int16_t * v170 = (int16_t *)(v142 + 36); // 0x14cf7
                *v170 = *v170 | 2;
                *v169 = *v169 + (int32_t)*v156;
                int64_t v171 = (int64_t)(*(char *)(v127 + 61) % 2); // 0x14d25
                if (*(char *)(v131 + 329) == 0) {
                    // 0x14d72
                    function_c59c(v131, v143);
                    v168 = v171;
                } else {
                    // 0x14d3a
                    v168 = v171;
                    if ((int32_t)function_17d52(v131, v143, v143, v145) != 0) {
                        // 0x14d57
                        function_c59c(v131, v143);
                        v168 = v171;
                    }
                }
                goto lab_0x14dc8_2;
            } else {
                goto lab_0x14d8d;
            }
        }
    }
  lab_0x14e80:
    if (v132 != 0) {
        // 0x14e9b
        function_15563(v142);
        goto lab_0x14fc5;
    } else {
        // 0x14e89
        if (*(int16_t *)(v142 + 36) % 2 == 0) {
            goto lab_0x14fc5;
        } else {
            // 0x14e9b
            function_15563(v142);
            goto lab_0x14fc5;
        }
    }
  lab_0x14d8d:;
    int64_t v172 = function_12a0d(v142, v127, v143); // 0x14d9d
    int16_t * v173 = (int16_t *)(v142 + 36); // 0x14da5
    *v173 = *v173 | 1;
    v168 = v172 & 0xffffffff;
    goto lab_0x14dc8_2;
  lab_0x14dc8_2:
    // 0x14dc8
    if (v168 % 2 != 0) {
        uint16_t v174 = *v166; // 0x14dd6
        int16_t v175 = v174; // 0x14dde
        if (v174 <= 9) {
            // 0x14de0
            function_11c8c(v131);
            int16_t * v176 = (int16_t *)(v142 + 36); // 0x14def
            *v176 = *v176 | 1;
            *v169 = *v169 + 1;
            v175 = *v166;
        }
        int64_t v177 = (int64_t)v175 + 0xfffffffd; // 0x14e0e
        if ((int32_t)v177 < 8) {
            int32_t v178 = *(int32_t *)((4 * v177 & 0x3fffffffc) + (int64_t)&g20); // 0x14e27
            return (int64_t)v178 + (int64_t)&g20;
        }
    }
    goto lab_0x14e80;
  lab_0x14550:;
    int64_t v179; // 0x12cfb
    int32_t v180; // 0x12cfb
    int64_t v181; // 0x12cfb
    int32_t * v182; // 0x146d4
    int32_t * v183; // 0x146f2
    if ((v184 & 2) == 0) {
        if ((v184 & 16) == 0) {
            // 0x14fb0
            function_a4f0(a1);
            goto lab_0x14fc5;
        } else {
            int16_t v185 = *v186; // 0x1457d
            if (v185 == 3) {
                int32_t * v187 = (int32_t *)(v188 + 120); // 0x1459e
                int32_t v189 = *net_long2; // 0x145a1
                int32_t v190 = *v187 - v189; // 0x145a6
                v25 = v188;
                v45 = a1;
                v17 = v15;
                v21 = v184;
                if (v190 >= 0 == (v190 != 0)) {
                    goto lab_0x14eee_4;
                } else {
                    int32_t v191 = v189 - *(int32_t *)(v188 + 168); // 0x145bd
                    v25 = v188;
                    v45 = a1;
                    v17 = v15;
                    v21 = v184;
                    if (v191 >= 0 == (v191 != 0)) {
                        goto lab_0x14eee_4;
                    } else {
                        // 0x145c9
                        *v186 = 4;
                        *v187 = *net_long2;
                        if ((char)*v192 > -1) {
                            // 0x1469b
                            function_11af7(v193);
                            goto lab_0x146aa;
                        } else {
                            // 0x145f1
                            if ((int32_t)function_190aa(v193) != 1) {
                                int32_t v194; // 0x14600
                                if (v194 != 2) {
                                    // 0x14689
                                    *v186 = 6;
                                    goto lab_0x146aa;
                                } else {
                                    int32_t v195 = *v192; // 0x1464e
                                    *v192 = v195 & 0xf000 | 1;
                                    goto lab_0x146aa;
                                }
                            } else {
                                // 0x1460f
                                function_11af7(v193);
                                *v192 = *v192 & -129;
                                goto lab_0x146aa;
                            }
                        }
                    }
                }
            } else {
                // 0x14587
                v181 = v196;
                v133 = net_long;
                v135 = v184;
                v134 = v15;
                v141 = a1;
                v136 = v188;
                v137 = v181;
                v138 = v193;
                v140 = 0;
                v139 = v197;
                if (v185 > 10) {
                    goto lab_0x14ae0;
                } else {
                    // 0x146cf
                    v182 = (int32_t *)(v188 + 120);
                    int32_t v198 = *net_long2 - *v182; // 0x146d7
                    v180 = 0;
                    if (v198 >= 0 == (v198 != 0)) {
                        goto lab_0x14881;
                    } else {
                        if (v199 != 0) {
                            goto lab_0x1486f;
                        } else {
                            // 0x146f2
                            v183 = (int32_t *)(v188 + 144);
                            if (*v183 != v197) {
                                goto lab_0x1486f;
                            } else {
                                // 0x14704
                                v179 = v181;
                                if ((*(int32_t *)&g58 & 2) == 0) {
                                    goto lab_0x14745;
                                } else {
                                    // 0x14714
                                    function_3080("Slirp", 128, " dup ack  m = %p  so = %p", a1, v193, v4);
                                    v179 = a1;
                                    goto lab_0x14745;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        // 0x1455a
        v25 = function_16fc0(v188, 0);
        v45 = a1;
        v17 = v15;
        v21 = v184;
        goto lab_0x14eee_4;
    }
  lab_0x14881:;
    int16_t * v200 = (int16_t *)(v188 + 30); // 0x14881
    if (*v200 < 4) {
        goto lab_0x148a7;
    } else {
        int32_t * v201 = (int32_t *)(v188 + 172); // 0x1488b
        uint32_t v202 = *(int32_t *)(v188 + 176); // 0x14891
        if (*v201 > v202) {
            // 0x1489b
            *v201 = v202;
            goto lab_0x148a7;
        } else {
            goto lab_0x148a7;
        }
    }
  lab_0x148a7:
    // 0x148a7
    *v200 = 0;
    int32_t v203 = *net_long2; // 0x148ad
    int32_t * v204 = (int32_t *)(v188 + 168); // 0x148b2
    int32_t v205 = *v204; // 0x148b2
    int32_t v206 = v203 - v205; // 0x148b8
    v207 = v208;
    int32_t v209; // 0x12cfb
    int32_t v210; // 0x12cfb
    int32_t * v211; // 0x148c9
    if (v206 >= 0 == (v206 != 0)) {
        goto lab_0x14eac;
    } else {
        // 0x148c4
        v211 = (int32_t *)(v188 + 120);
        int16_t v212 = *(int16_t *)(v188 + 182); // 0x148d6
        v209 = v205;
        v210 = v203;
        if (v212 == 0) {
            goto lab_0x14907;
        } else {
            // 0x148e2
            v209 = v205;
            v210 = v203;
            if (v203 - *(int32_t *)(v188 + 184) < 1) {
                goto lab_0x14907;
            } else {
                // 0x148f5
                function_1514f(v188, (int64_t)v212 & 0xffffffff);
                v209 = *v204;
                v210 = *net_long2;
                goto lab_0x14907;
            }
        }
    }
  lab_0x1486f:
    // 0x1486f
    *(int16_t *)(v188 + 30) = 0;
    v133 = net_long;
    v135 = v184;
    v134 = v15;
    v141 = a1;
    v136 = v188;
    v137 = v181;
    v138 = v193;
    v140 = 0;
    v139 = v197;
    goto lab_0x14ae0;
  lab_0x146aa:
    // 0x146aa
    function_12a0d(v188, 0, 0);
    *(int32_t *)(v188 + 132) = *net_long - 1;
    v180 = 0;
    goto lab_0x14881;
  lab_0x14eac:
    // 0x14eac
    if (v207 != 0) {
        // 0x14fb0
        function_a4f0(a1);
        goto lab_0x14fc5;
    } else {
        // 0x14eba
        function_a4f0(a1);
        int16_t * v219 = (int16_t *)(v188 + 36); // 0x14ec9
        *v219 = *v219 | 1;
        function_15563(v188);
        goto lab_0x14fc5;
    }
  lab_0x14907:;
    // 0x14907
    int32_t v220; // 0x12cfb
    if (v210 != v209) {
        // 0x14928
        v220 = v180;
        if (*(int16_t *)(v188 + 20) != 0) {
            goto lab_0x14939;
        } else {
            // 0x14931
            *(int16_t *)(v188 + 18) = *(int16_t *)(v188 + 28);
            v220 = v180;
            goto lab_0x14939;
        }
    } else {
        // 0x14916
        *(int16_t *)(v188 + 18) = 0;
        v220 = 1;
        goto lab_0x14939;
    }
  lab_0x14745:;
    int16_t * v221 = (int16_t *)(v188 + 18); // 0x14745
    if (*v221 == 0) {
        goto lab_0x1475a;
    } else {
        // 0x1474e
        if (*net_long2 == *v182) {
            int16_t * v222 = (int16_t *)(v188 + 30); // 0x14765
            int16_t v223 = *v222 + 1; // 0x14769
            *v222 = v223;
            if (v223 != 3) {
                // 0x14843
                v133 = net_long;
                v135 = v184;
                v134 = v15;
                v141 = a1;
                v136 = v188;
                v137 = v179;
                v138 = v193;
                v140 = 0;
                v139 = v197;
                if (v223 < 4) {
                    goto lab_0x14ae0;
                } else {
                    int32_t * v224 = (int32_t *)(v188 + 172); // 0x1484d
                    *v224 = *v224 + (int32_t)*(int16_t *)(v188 + 32);
                    function_15563(v188);
                    // 0x14fb0
                    function_a4f0(a1);
                    goto lab_0x14fc5;
                }
            } else {
                int32_t * v225 = (int32_t *)(v188 + 124); // 0x1477e
                int32_t v226 = *v225; // 0x1477e
                int32_t * v227 = (int32_t *)(v188 + 172); // 0x14787
                uint32_t v228 = *v227; // 0x14787
                uint32_t v229 = *v183; // 0x1478d
                uint32_t v230 = (v228 > v229 ? v229 : v228) / 2; // 0x14798
                int16_t * v231 = (int16_t *)(v188 + 32); // 0x1479a
                uint32_t v232 = (int32_t)*v231; // 0x147a6
                uint32_t v233 = v230 / v232; // 0x147a6
                int32_t * v234 = (int32_t *)(v188 + 176); // 0x147cf
                *v234 = (v233 == 1 | v230 < v232 ? 2 : v233) * v232;
                *v221 = 0;
                *(int16_t *)(v188 + 182) = 0;
                *v225 = *net_long2;
                *v227 = (int32_t)*v231;
                function_15563(v188);
                *v227 = (int32_t)*v222 * (int32_t)*v231 + *v234;
                if (v226 - *v225 < 1) {
                    // 0x14fb0
                    function_a4f0(a1);
                    goto lab_0x14fc5;
                } else {
                    // 0x14835
                    *v225 = v226;
                    // 0x14fb0
                    function_a4f0(a1);
                    goto lab_0x14fc5;
                }
            }
        } else {
            goto lab_0x1475a;
        }
    }
  lab_0x1475a:
    // 0x1475a
    *(int16_t *)(v188 + 30) = 0;
    v133 = net_long;
    v135 = v184;
    v134 = v15;
    v141 = a1;
    v136 = v188;
    v137 = v179;
    v138 = v193;
    v140 = 0;
    v139 = v197;
    goto lab_0x14ae0;
  lab_0x14939:;
    int32_t * v235 = (int32_t *)(v188 + 172); // 0x14939
    uint32_t v236 = *v235; // 0x14939
    int64_t v237 = (int64_t)*(int16_t *)(v188 + 32); // 0x14944
    int64_t v238 = v237; // 0x14951
    if (v236 > *(int32_t *)(v188 + 176)) {
        // 0x14953
        v238 = (int32_t)(v237 * v237) / v236;
        goto lab_0x14965;
    } else {
        goto lab_0x14965;
    }
  lab_0x14965:;
    unsigned char v239 = *(char *)(v188 + 204); // 0x14965
    unsigned char v240 = v239 % 32;
    int64_t v241 = 0xffff; // 0x14976
    if (v240 == 0) {
        goto lab_dec_label_pc_0x148cc;
    } else {
        v241 = 0xffff << (int32_t)v240;
        goto lab_dec_label_pc_0x148cc;
    }
  lab_dec_label_pc_0x148cc:;
    uint32_t v242 = v203 - *v211; // 0x148cc
    int64_t v243 = v241;
    int64_t v244 = v238 + (int64_t)v236; // 0x1497c
    int64_t v245 = (int32_t)v243 > (int32_t)v244 ? v244 : v243;
    *v235 = (int32_t)v245;
    int32_t * v246 = (int32_t *)(v193 + 392); // 0x14992
    uint32_t v247 = *v246; // 0x14992
    int32_t v248; // 0x12cfb
    if (v247 >= v242) {
        // 0x149eb
        function_120b2(v193, (int64_t)v242);
        int32_t * v249 = (int32_t *)(v188 + 144); // 0x14a02
        *v249 = *v249 - v242;
        v248 = 0;
        goto lab_0x14a22;
    } else {
        int32_t * v250 = (int32_t *)(v188 + 144); // 0x149a2
        *v250 = *v250 - v247;
        function_120b2(v193, (int64_t)*v246);
        v248 = 1;
        goto lab_0x14a22;
    }
  lab_0x14a22:;
    int32_t v251 = *net_long2; // 0x14a22
    *v211 = v251;
    int32_t * v252 = (int32_t *)(v188 + 124); // 0x14a2a
    if (*v252 - v251 >= 0) {
        goto lab_0x14a3e;
    } else {
        // 0x14a38
        *v252 = v251;
        goto lab_0x14a3e;
    }
  lab_0x14a3e:;
    int64_t v253 = v239; // 0x14974
    int16_t v254 = *v186; // 0x14a3e
    if (v254 == 7) {
        // 0x14a8b
        v133 = net_long;
        v135 = v184;
        v134 = v15;
        v141 = a1;
        v136 = v188;
        v137 = v253;
        v138 = v193;
        v140 = v220;
        v139 = v197;
        if (v248 == 0) {
            goto lab_0x14ae0;
        } else {
            // 0x14a94
            *v186 = 10;
            function_1949b(v188);
            *(int16_t *)(v188 + 24) = 20;
            v133 = net_long;
            v135 = v184;
            v134 = v15;
            v141 = a1;
            v136 = v188;
            v137 = v253;
            v138 = v193;
            v140 = v220;
            v139 = v197;
            goto lab_0x14ae0;
        }
    } else {
        if (v254 > 7) {
            // 0x14a54
            v133 = net_long;
            v135 = v184;
            v134 = v15;
            v141 = a1;
            v136 = v188;
            v137 = v253;
            v138 = v193;
            v140 = v220;
            v139 = v197;
            switch (v254) {
                case 8: {
                    // 0x14aaa
                    v133 = net_long;
                    v135 = v184;
                    v134 = v15;
                    v141 = a1;
                    v136 = v188;
                    v137 = v253;
                    v138 = v193;
                    v140 = v220;
                    v139 = v197;
                    if (v248 == 0) {
                        goto lab_0x14ae0;
                    } else {
                        // 0x14ab3
                        function_17098(v188);
                        // 0x14fb0
                        function_a4f0(a1);
                        goto lab_0x14fc5;
                    }
                }
                case 10: {
                    // 0x14ac0
                    *(int16_t *)(v188 + 24) = 20;
                    v207 = v208;
                    goto lab_0x14eac;
                }
                default: {
                    goto lab_0x14ae0;
                }
            }
        } else {
            // 0x14a4d
            v133 = net_long;
            v135 = v184;
            v134 = v15;
            v141 = a1;
            v136 = v188;
            v137 = v253;
            v138 = v193;
            v140 = v220;
            v139 = v197;
            if (v248 == 0 || v254 != 6) {
                goto lab_0x14ae0;
            } else {
                // 0x14a69
                if ((*v192 & 8) == 0) {
                    goto lab_0x14a83;
                } else {
                    // 0x14a7d
                    *(int16_t *)(v188 + 24) = (int16_t)&g77;
                    goto lab_0x14a83;
                }
            }
        }
    }
  lab_0x14a83:
    // 0x14a83
    *v186 = 9;
    v133 = net_long;
    v135 = v184;
    v134 = v15;
    v141 = a1;
    v136 = v188;
    v137 = v253;
    v138 = v193;
    v140 = v220;
    v139 = v197;
    goto lab_0x14ae0;
  lab_0x13a2f:;
    int16_t * v255 = (int16_t *)(v188 + 36); // 0x13a2f
    *v255 = *v255 | 1;
    function_15563(v188);
    goto lab_0x14fc5;
  lab_0x138e2:
    // 0x138e2
    function_120b2(v193, (int64_t)v256);
    *v257 = *net_long2;
    function_a4f0(a1);
    if (*v257 != *v258) {
        // 0x13937
        if (*(int16_t *)(v188 + 20) != 0) {
            goto lab_0x13948;
        } else {
            // 0x13940
            *(int16_t *)(v188 + 18) = *(int16_t *)(v188 + 28);
            goto lab_0x13948;
        }
    } else {
        // 0x1392f
        *(int16_t *)(v188 + 18) = 0;
        goto lab_0x13948;
    }
  lab_0x13948:
    // 0x13948
    if (*(int32_t *)(v193 + 392) == 0) {
        goto lab_0x14fc5;
    } else {
        // 0x1395d
        function_15563(v188);
        goto lab_0x14fc5;
    }
  lab_0x13bd8:
    // 0x13bd8
    if ((char)v259 <= -1) {
        goto lab_0x14019;
    } else {
        goto lab_0x13bf2;
    }
  lab_0x14019:
    // 0x14019
    function_1659d(v188);
    int64_t v260 = v261; // 0x14029
    if (v39 != 0) {
        // 0x1402b
        function_14fe8(v188, v39, v43, v15);
        v260 = v15;
    }
    // 0x14046
    v14 = v262;
    v13 = v54;
    v12 = v263;
    v11 = v186;
    v10 = v264;
    v9 = v265;
    v8 = net_long;
    v26 = v260;
    v40 = v197;
    v37 = v55;
    v38 = v193;
    v24 = v188;
    v44 = a1;
    v16 = v15;
    v20 = v19;
    if (v42 == 0) {
        goto lab_0x1405d;
    } else {
        int32_t * v266 = (int32_t *)(v188 + 140);
        *v266 = v42;
        v90 = v262;
        v91 = v54;
        v92 = v263;
        v93 = v186;
        v94 = v264;
        v95 = v265;
        v96 = v266;
        v97 = net_long;
        v98 = (int32_t *)(v55 + (int64_t)&g69);
        v99 = v260;
        v100 = v197;
        v101 = v193;
        v102 = a1;
        v103 = v15;
        v104 = v19;
        v105 = v188;
        goto lab_0x14070;
    }
  lab_0x13bf2:;
    char * v267 = (char *)(v193 + 329); // 0x13bf9
    char v268 = *v267; // 0x13bf9
    if ((v268 & 16) == 0) {
        uint16_t v269 = *(int16_t *)(v193 + 72); // 0x13c36
        if ((int32_t)function_17310(v193, (int64_t)v269) != -1) {
            goto lab_0x13fa9;
        } else {
            // 0x13c57
            if (*__errno_location() == 11) {
                goto lab_0x13fa9;
            } else {
                // 0x13c67
                if (*__errno_location() == 115) {
                    goto lab_0x13fa9;
                } else {
                    // 0x13c77
                    if (*__errno_location() == 11) {
                        goto lab_0x13fa9;
                    } else {
                        // 0x13c87
                        if ((*(int32_t *)&g58 & 2) != 0) {
                            char * err_str = strerror(*__errno_location()); // 0x13ca0
                            uint32_t v270 = *__errno_location(); // 0x13cad
                            function_3080("Slirp", 128, " tcp fconnect errno = %d-%s", (int64_t)v270, (int64_t)err_str, v4);
                        }
                        // 0x13cd1
                        if (*__errno_location() != 111) {
                            int64_t v271; // 0x12cfb
                            switch (v47) {
                                case 2: {
                                    // 0x13d2e
                                    v271 = *__errno_location() == 113;
                                    // break -> 0x13d8f
                                    break;
                                }
                                case 10: {
                                    // 0x13d4a
                                    v271 = *__errno_location() != 113 ? 0 : 3;
                                    // break -> 0x13d8f
                                    break;
                                }
                                default: {
                                    // 0x13d66
                                    function_2ea0("Slirp", "../src/tcp_input.c", (int64_t)&g66, "tcp_input", 0);
                                    unsigned char v272; // 0x12cfb
                                    v271 = v272;
                                    // break -> 0x13d8f
                                    break;
                                }
                            }
                            // 0x13d8f
                            *net_long = htonl(*net_long);
                            *net_long2 = htonl(*net_long2);
                            *net_short = htons(*net_short);
                            *net_short2 = htons(*net_short2);
                            *v57 = -48 - (int64_t)v52 + *v57;
                            *v56 = v53 + 48 + *v56;
                            switch (v47) {
                                case 2: {
                                    // 0x13e49
                                    *v57 = *v57 + 28;
                                    *v56 = *v56 - 28;
                                    *(int64_t *)v48 = v36;
                                    *(int64_t *)(v48 + 8) = v35;
                                    *(int32_t *)(v48 + 16) = v34;
                                    int32_t err_num = *__errno_location(); // 0x13ea6
                                    function_8b39(a1, 3, v271, 0, (int64_t)strerror(err_num));
                                    // break -> 0x13f8c
                                    break;
                                }
                                case 10: {
                                    // 0x13eda
                                    *v57 = *v57 + 8;
                                    *v56 = *v56 - 8;
                                    *(int64_t *)v48 = v33;
                                    *(int64_t *)(v48 + 8) = v32;
                                    *(int64_t *)(v48 + 16) = v31;
                                    *(int64_t *)(v48 + 24) = v30;
                                    *(int64_t *)(v48 + 32) = v29;
                                    function_6903(a1, 1, v271);
                                    // break -> 0x13f8c
                                    break;
                                }
                                default: {
                                    // 0x13f67
                                    function_2ea0("Slirp", "../src/tcp_input.c", (int64_t)&g67, "tcp_input", 0);
                                    // break -> 0x13f8c
                                    break;
                                }
                            }
                        } else {
                            // 0x13cdd
                            function_16709(v188, v15, a1, (int64_t)(*net_long + 1), 0, 20, v7 % 0x10000);
                        }
                        // 0x13f8c
                        function_17098(v188);
                        function_a4f0(a1);
                        goto lab_0x14fc5;
                    }
                }
            }
        }
    } else {
        // 0x13c0a
        *v267 = v268 & -17;
        goto lab_0x14019;
    }
  lab_0x13fa9:
    // 0x13fa9
    *(int64_t *)(v193 + 48) = a1;
    *(int64_t *)(v193 + 56) = v15;
    *v263 = 150;
    *v186 = 3;
    int32_t v273 = *net_long; // 0x13fd2
    *(int32_t *)(v188 + 160) = v273;
    int32_t v274 = v273 + 1; // 0x13fe3
    *v265 = v274;
    *v264 = v274;
    function_1659d(v188);
    goto lab_0x14fc5;
  lab_0x14131:
    if ((v19 & 4) == 0) {
        if ((v19 & 2) == 0) {
            // 0x14fb0
            function_a4f0(a1);
            goto lab_0x14fc5;
        } else {
            if ((v19 & 16) != 0) {
                int32_t v275 = *net_long2; // 0x14173
                *(int32_t *)(v188 + 120) = v275;
                int32_t * v276 = (int32_t *)(v188 + 124); // 0x1417b
                if (*v276 - v275 < 0) {
                    // 0x14189
                    *v276 = v275;
                }
            }
            // 0x1418f
            *(int16_t *)(v188 + 18) = 0;
            int32_t v277 = *net_long; // 0x14195
            *(int32_t *)(v188 + 160) = v277;
            int32_t v278 = v277 + 1; // 0x141a6
            *v265 = v278;
            *v264 = v278;
            int16_t * v279 = (int16_t *)(v188 + 36); // 0x141bb
            *v279 = *v279 | 1;
            if ((v19 & 16) == 0) {
                goto lab_0x14228;
            } else {
                // 0x141d0
                if (*(int32_t *)(v188 + 120) - *(int32_t *)(v188 + 140) < 1) {
                    goto lab_0x14228;
                } else {
                    // 0x141e1
                    function_11af7(v193);
                    *v186 = 4;
                    function_12a0d(v188, 0, 0);
                    int16_t v280 = *(int16_t *)(v188 + 182); // 0x14208
                    v111 = v262;
                    v112 = v54;
                    v113 = net_long;
                    v114 = v197;
                    v115 = v193;
                    v116 = v261;
                    v117 = v188;
                    v118 = a1;
                    v119 = v15;
                    v120 = v19;
                    if (v280 != 0) {
                        // 0x14214
                        function_1514f(v188, (int64_t)v280 & 0xffffffff);
                        v111 = v262;
                        v112 = v54;
                        v113 = net_long;
                        v114 = v197;
                        v115 = v193;
                        v116 = v261;
                        v117 = v188;
                        v118 = a1;
                        v119 = v15;
                        v120 = v19;
                    }
                    goto lab_0x1422e;
                }
            }
        }
    } else {
        if ((v19 & 16) != 0) {
            // 0x14149
            function_16fc0(v188, 0);
        }
        // 0x14fb0
        function_a4f0(a1);
        goto lab_0x14fc5;
    }
  lab_0x14228:
    // 0x14228
    *v186 = 3;
    v111 = v262;
    v112 = v54;
    v113 = net_long;
    v114 = v197;
    v115 = v193;
    v116 = v261;
    v117 = v188;
    v118 = a1;
    v119 = v15;
    v120 = v19;
    goto lab_0x1422e;
}

// Address range: 0x14fe8 - 0x1514f
int64_t function_14fe8(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0x14fff
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1503b
        int64_t v2; // 0x14fe8
        int64_t v3; // 0x14fe8
        function_3080("Slirp", 128, "tcp_dooptions...", a4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x1504f
            function_3080("Slirp", 128, " tp = %p  cnt=%i", a1, (int64_t)a3, v2);
        }
    }
    if (a3 >= 0 == (a3 != 0)) {
        int32_t v4 = a3; // 0x1511c
        int64_t v5 = a2;
        char v6 = *(char *)v5; // 0x15082
        while (v6 != 0) {
            int32_t v7 = 1; // 0x15099
            if (v6 != 1) {
                unsigned char v8 = *(char *)(v5 + 1); // 0x150ac
                if (v8 == 0) {
                    // break -> 0x15138
                    break;
                }
                int32_t v9 = v8; // 0x150b2
                v7 = v9;
                if (v6 == 2 && v8 == 4) {
                    // 0x150cb
                    v7 = v9;
                    if ((*(char *)(a4 + 61) & 2) != 0) {
                        // 0x150dd
                        function_15314(a1, (int64_t)ntohs(*(int16_t *)(v5 + 2)));
                        v7 = v9;
                    }
                }
            }
            // 0x15119
            v4 -= v7;
            if (v4 >= 0 != v4 != 0) {
                // break -> 0x15138
                break;
            }
            v5 += (int64_t)v7;
            v6 = *(char *)v5;
        }
    }
    int64_t result = 0; // 0x15146
    if (v1 != __readfsqword(40)) {
        // 0x15148
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1514d
    return result;
}

// Address range: 0x1514f - 0x15314
int64_t function_1514f(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x1515d
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1518d
        int64_t v2; // 0x1514f
        int64_t v3; // 0x1514f
        int64_t v4; // 0x1514f
        function_3080("Slirp", 128, "tcp_xmit_timer...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x151bd
            function_3080("Slirp", 128, " tp = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x151cd
                function_3080("Slirp", 128, " rtt = %d", v1 & 0xffffffff, v3, v2);
            }
        }
    }
    int16_t * v5 = (int16_t *)(a1 + 188); // 0x151ef
    int16_t v6 = *v5; // 0x151ef
    int16_t * v7; // 0x1514f
    if (v6 == 0) {
        int16_t v8 = a2;
        *v5 = 8 * v8;
        int16_t * v9 = (int16_t *)(a1 + 190);
        *v9 = 2 * v8;
        v7 = v9;
    } else {
        int64_t v10 = ((int64_t)(v6 / 8) ^ 0xffffffff) + v1; // 0x15213
        int16_t v11 = v10; // 0x15222
        int16_t v12 = v6 + v11; // 0x15225
        *v5 = v12 >= 0 == (v12 != 0) ? v12 : 1;
        int16_t * v13 = (int16_t *)(a1 + 190);
        int16_t v14 = *v13; // 0x15254
        int16_t v15 = (int16_t)(v11 >= 0 ? v10 : -v10) - v14 / 4 + v14; // 0x15272
        *v13 = v15 >= 0 == (v15 != 0) ? v15 : 1;
        v7 = v13;
    }
    // 0x152ab
    *(int16_t *)(a1 + 182) = 0;
    *(int16_t *)(a1 + 26) = 0;
    uint16_t result2 = *v7 + *v5 / 8; // 0x152ce
    int16_t * v16 = (int16_t *)(a1 + 28); // 0x152d0
    *v16 = result2;
    uint16_t result = *(int16_t *)(a1 + 192); // 0x152d8
    if (result2 < result) {
        // 0x152e4
        *v16 = result;
        // 0x15301
        *(int16_t *)(a1 + 202) = 0;
        return result;
    }
    // 0x152f1
    if (result2 >= 25) {
        // 0x152fb
        *v16 = 24;
    }
    // 0x15301
    *(int16_t *)(a1 + 202) = 0;
    return result2;
}

// Address range: 0x15314 - 0x15563
int64_t function_15314(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x15320
    int64_t v2 = *(int64_t *)(a1 + 112); // 0x15327
    int64_t v3; // 0x15314
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1535c
        int64_t v4; // 0x15314
        int64_t v5; // 0x15314
        function_3080("Slirp", 128, "tcp_mss...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x15390
            function_3080("Slirp", 128, " tp = %p", a1, v4, v3);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x153a0
                function_3080("Slirp", 128, " offer = %d", v1 & 0xffffffff, v4, v3);
            }
        }
    }
    // 0x153c2
    int64_t v6; // 0x15314
    int32_t v7; // 0x15314
    switch (*(int16_t *)(v2 + 72)) {
        case 2: {
            int64_t v8 = *(int64_t *)(v2 + 40); // 0x153dd
            int32_t v9 = *(int32_t *)(v8 + 140); // 0x153e1
            int32_t v10 = *(int32_t *)(v8 + 136); // 0x153ef
            int32_t v11 = v9 - v10; // 0x153f5
            int32_t v12 = v11 == 0 | v11 < 0 != ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v9 : v10; // 0x153f7
            v7 = v12 - 40;
            // break -> 0x15450
            break;
        }
        case 10: {
            int64_t v13 = *(int64_t *)(v2 + 40); // 0x15406
            int32_t v14 = *(int32_t *)(v13 + 140); // 0x1540a
            int32_t v15 = *(int32_t *)(v13 + 136); // 0x15418
            int32_t v16 = v14 - v15; // 0x1541e
            int32_t v17 = v16 == 0 | v16 < 0 != ((v16 ^ v14) & (v15 ^ v14)) < 0 ? v14 : v15; // 0x15420
            v7 = v17 - 60;
            // break -> 0x15450
            break;
        }
        default: {
            // 0x1542b
            function_2ea0("Slirp", "../src/tcp_input.c", (int64_t)&g84, "tcp_mss", 0);
            v6 = 0;
            // break -> 0x15450
            break;
        }
    }
    uint32_t v18 = v7;
    int32_t v19 = v1; // 0x15450
    int32_t v20 = v19 - 1 < v18 ? v19 : v18;
    int32_t v21 = v20 < 32 == (31 - v20 & v20) < 0 ? v20 : 32; // 0x1546c
    int16_t * v22 = (int16_t *)(a1 + 32); // 0x15477
    if (v19 == 0 != (int64_t)v21 >= (int64_t)*v22) {
        int32_t v23 = v21 - 0x8000; // 0x1548e
        int16_t v24 = v23 == 0 | v23 < 0 != (0x7fff - v21 & v21) < 0 ? (int16_t)v21 : -0x8000; // 0x1549f
        *v22 = v24;
    }
    // 0x154a3
    *(int32_t *)(a1 + 172) = v21;
    int64_t result = v21; // 0x154b6
    int32_t v25 = (0x100000000 * (int64_t)((int32_t)&g38 >> 31) | (int64_t)(int32_t)&g38) % result; // 0x154bb
    int64_t v26; // 0x15314
    if (v25 == 0) {
        // 0x154d9
        function_c48d(v2 + 392, (int64_t)&g38 & 0xffffffff);
        v26 = &g38;
    } else {
        int64_t v27 = v21 + (int32_t)&g38 - v25;
        function_c48d(v2 + 392, v27);
        v26 = v27;
    }
    // 0x15517
    function_c48d(v2 + 360, v26 & 0xffffffff);
    if ((*(int32_t *)&g58 & 2) != 0) {
        // 0x1553c
        function_3080("Slirp", 128, " returning mss = %d", result, v6, v3);
    }
    // 0x1555e
    return result;
}

// Address range: 0x15563 - 0x16346
int64_t function_15563(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x1557e
    int64_t v2 = *(int64_t *)(a1 + 112); // 0x15594
    int64_t v3; // 0x15563
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x155c5
        int64_t v4; // 0x15563
        int64_t v5; // 0x15563
        function_3080("Slirp", 128, "tcp_output...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x155d5
            function_3080("Slirp", 128, " tp = %p", a1, v4, v3);
        }
    }
    int32_t * host_long = (int32_t *)(a1 + 168); // 0x15603
    int32_t * v6 = (int32_t *)(a1 + 120); // 0x15610
    int16_t * v7; // 0x15563
    int32_t * v8; // 0x15563
    int16_t * v9; // 0x15563
    int16_t * v10; // 0x15563
    if (*host_long != *v6) {
        // 0x155fc
        v7 = (int16_t *)(a1 + 28);
        goto lab_0x15665;
    } else {
        int16_t * v11 = (int16_t *)(a1 + 28);
        v7 = v11;
        if (*(int16_t *)(a1 + 180) < *v11) {
            goto lab_0x15665;
        } else {
            int16_t * v12 = (int16_t *)(a1 + 32);
            int32_t * v13 = (int32_t *)(a1 + 172);
            *v13 = (int32_t)*v12;
            v10 = v11;
            v9 = v12;
            v8 = v13;
            goto lab_0x15666_2;
        }
    }
  lab_0x159dd_2:;
    int64_t v14 = 0; // 0x159e6
    uint32_t v15; // 0x159dd
    int16_t * v16; // 0x15563
    int16_t * v17; // 0x15563
    int16_t * v18; // 0x15563
    if (v15 == 0) {
        goto lab_0x16320;
    } else {
        // 0x159e8
        v14 = 0;
        if (*v18 != 0) {
            goto lab_0x16320;
        } else {
            // 0x159f8
            v14 = 0;
            if (*v16 != 0) {
                goto lab_0x16320;
            } else {
                // 0x15a08
                *v17 = 0;
                function_16346(a1);
                v14 = 0;
                goto lab_0x16320;
            }
        }
    }
  lab_0x16320:;
    int64_t result = v14; // 0x1632d
    if (v1 != __readfsqword(40)) {
        // 0x1632f
        __stack_chk_fail();
        result = &g91;
    }
    // 0x16334
    return result;
  lab_0x158b9:;
    char * v19; // 0x15563
    int32_t * v20; // 0x15563
    int32_t * host_long3; // 0x15563
    int64_t v21; // 0x15563
    uint32_t v22; // 0x15806
    uint32_t v23; // 0x15814
    int64_t v24; // 0x15818
    if (v23 == 0) {
        goto lab_0x15952;
    } else {
        unsigned char v25 = *v19 % 64;
        int64_t v26 = v25 == 0 ? 0xffff : 0xffff << (int64_t)v25;
        int64_t v27 = v24 - v26; // 0x158e0
        int64_t v28 = v27 == 0 | v27 < 0 != (v27 & v26) < 0 ? v24 : v26; // 0x158e3
        int64_t v29 = v28 - (int64_t)(*v20 - *host_long3); // 0x1590a
        if (v29 < 2 * v21) {
            if (2 * v29 < (int64_t)v22) {
                goto lab_0x15952;
            } else {
                goto lab_0x15a4d;
            }
        } else {
            goto lab_0x15a4d;
        }
    }
  lab_0x15952:;
    // 0x15952
    int16_t * v30; // 0x15563
    uint16_t v31 = *v30; // 0x15959
    int32_t v32; // 0x15563
    int32_t * v33; // 0x15563
    int32_t v34; // 0x157db
    int32_t v35; // 0x157eb
    if (v31 % 2 == 0) {
        if ((v32 & 6) == 0) {
            int32_t v36 = *v33 - v35; // 0x15993
            if (v36 >= 0 != v36 != 0) {
                if (v32 % 2 == 0) {
                    goto lab_0x159dd_2;
                }
                if (v34 != v35 && (v31 & 16) != 0) {
                    goto lab_0x159dd_2;
                }
            }
        }
    }
    goto lab_0x15a4d;
  lab_0x15a4d:;
    int32_t v37 = 0; // 0x15a6c
    char v38; // bp-104, 0x15563
    int32_t * host_long2; // 0x15677
    if ((v32 & 2) != 0) {
        // 0x15a6e
        *host_long2 = *(int32_t *)(a1 + 140);
        v37 = 0;
        if ((*v30 & 8) == 0) {
            // 0x15a9a
            v38 = 2;
            htons((int16_t)function_15314(a1, 0));
            v37 = 4;
        }
    }
    uint32_t v39 = v37;
    uint32_t v40 = v39 + 68; // 0x15ae9
    int16_t * v41; // 0x15563
    int64_t v42 = (int32_t)*v41 - v39; // 0x15b03
    int64_t v43; // 0x15563
    int64_t v44 = v43 > v42 ? v42 : v43;
    int64_t v45 = function_a39a(*(int64_t *)(v2 + 40));
    int64_t * v46; // 0x15563
    int32_t v47; // 0x15563
    int32_t v48; // 0x15563
    int64_t v49; // 0x15563
    int32_t * v50; // 0x15563
    int32_t v51; // 0x15684
    int64_t v52; // 0x1576f
    if (v44 == 0) {
        // 0x15bc5
        v47 = 1;
        if (v45 == 0) {
            // break -> 0x16282
            goto lab_0x16282_3;
        }
        int64_t * v53 = (int64_t *)(v45 + 48);
        *v53 = *v53 + 16;
        *(int32_t *)(v45 + 56) = v40;
        v46 = v53;
        v48 = v32;
    } else {
        // 0x15b34
        v47 = 1;
        if (v45 == 0) {
            // break -> 0x16282
            goto lab_0x16282_3;
        }
        int64_t * v54 = (int64_t *)(v45 + 48);
        *v54 = *v54 + 16;
        int32_t * v55 = (int32_t *)(v45 + 56); // 0x15b69
        *v55 = v40;
        function_c938(v49, v51, v44 & 0xffffffff, *v54 + (int64_t)v40);
        *v55 = *v55 + (int32_t)v44;
        uint32_t v56 = *v50; // 0x15bae
        int32_t v57 = v44 + v52 != (int64_t)v56 ? v32 : v32 | 8;
        v46 = v54;
        v48 = v57;
    }
    uint32_t v58 = v48;
    int64_t * v59 = v46;
    int64_t v60 = *v59; // 0x15bfd
    memcpy((int64_t *)v60, (int64_t *)(a1 + 40), 68);
    if (v58 % 2 != 0) {
        // 0x15c29
        if ((*v30 & 16) != 0) {
            int32_t v61 = *host_long2; // 0x15c45
            if (v61 == *host_long) {
                // 0x15c59
                *host_long2 = v61 - 1;
            }
        }
    }
    if (v44 != 0) {
        goto lab_0x15c92;
    } else {
        if (v58 % 4 != 0) {
            goto lab_0x15c92;
        } else {
            // 0x15c82
            if (*v16 == 0) {
                // 0x15ca9
                *(int32_t *)(v60 + 52) = htonl(*host_long);
                goto lab_0x15cc1;
            } else {
                goto lab_0x15c92;
            }
        }
    }
  lab_0x15c92:
    // 0x15c92
    *(int32_t *)(v60 + 52) = htonl(*host_long2);
    goto lab_0x15cc1;
  lab_0x15cc1:
    // 0x15cc1
    *(int32_t *)(v60 + 56) = htonl(*host_long3);
    if (v39 != 0) {
        // 0x15ce2
        memcpy((int64_t *)(v60 + 68), (int64_t *)&v38, v39);
        char * v62 = (char *)(v60 + 60); // 0x15d11
        *v62 = *v62 % 16 | 4 * (char)v39 + 80;
    }
    char * v63 = (char *)(v60 + 61); // 0x15d25
    *v63 = (char)v58;
    int64_t v64 = v24; // 0x15d38
    int32_t * v65; // 0x15563
    if (v23 < *v65 / 4) {
        // 0x15d3a
        v64 = v24 < (int64_t)*v41 ? 0 : v24;
    }
    int64_t v66 = v64;
    unsigned char v67 = *v19 % 64;
    uint64_t v68 = (int64_t)v67;
    int64_t v69 = v67 == 0 ? 0xffff : 0xffff << v68;
    int64_t v70 = v66 > v69 ? v69 : v66;
    int64_t v71 = (int64_t)(*v20 - *host_long3); // 0x15db2
    uint64_t v72 = v70 < v71 ? v71 : v70;
    *(int16_t *)(v60 + 62) = htons((int16_t)(v72 >> v68));
    int32_t v73 = *v33; // 0x15e0c
    int32_t v74 = *v6; // 0x15e19
    if (v73 - v74 < 1) {
        // 0x15e6b
        *v33 = v74;
    } else {
        int16_t v75 = htons((int16_t)(v73 - ntohl(*(int32_t *)(v60 + 52)))); // 0x15e53
        *(int16_t *)(v60 + 66) = v75;
        *v63 = *v63 | 32;
    }
    int32_t v76 = v44;
    if (v44 != -(int64_t)v39) {
        // 0x15e90
        *(int16_t *)(v60 + 46) = htons((int16_t)(v39 + v76) + 20);
    }
    uint32_t v77 = v40 + v76; // 0x15eb8
    *(int16_t *)(v60 + 64) = (int16_t)function_44c3(v45, (int64_t)v77);
    char * v78; // 0x15563
    if (*v78 == 0) {
        goto lab_0x15eec;
    } else {
        // 0x15ed8
        if (*v16 != 0) {
            int32_t v79 = *host_long2 + v76; // 0x16070
            if (v79 - *host_long >= 1) {
                // 0x16087
                *host_long = v79;
            }
            goto lab_0x160a6;
        } else {
            goto lab_0x15eec;
        }
    }
  lab_0x15eec:;
    int32_t v80 = *host_long2; // 0x15ef3
    int32_t v81 = v80; // 0x15f07
    if (v58 % 4 != 0) {
        int32_t v82 = v80; // 0x15f14
        if ((v58 & 2) != 0) {
            // 0x15f16
            v82 = v80 + 1;
            *host_long2 = v82;
        }
        int32_t v83 = v82; // 0x15f41
        v81 = v83;
        if (v58 % 2 != 0) {
            // 0x15f3a
            *host_long2 = v83 + 1;
            *v30 = *v30 | 16;
            v81 = *host_long2;
        }
    }
    int32_t v84 = v81 + v76; // 0x15f79
    *host_long2 = v84;
    int16_t * v85; // 0x15563
    if (v84 - *host_long >= 1) {
        // 0x15fa4
        *host_long = v84;
        if (*v85 == 0) {
            // 0x15fce
            *v85 = 1;
            *(int32_t *)(a1 + 184) = v80;
        }
    }
    // 0x15ff1
    int16_t * v86; // 0x15563
    if (*v18 == 0) {
        // 0x16005
        if (*host_long2 != *v6) {
            // 0x16021
            *v18 = *v86;
            if (*v16 != 0) {
                // 0x16047
                *v16 = 0;
                *v17 = 0;
            }
        }
    }
    goto lab_0x160a6;
  lab_0x160a6:;
    int32_t * v87 = (int32_t *)(v45 + 56); // 0x160b1
    *v87 = v77;
    int64_t v88 = *v59; // 0x160b4
    int64_t v89 = v88 + 8; // 0x160bb
    int64_t v90 = *(int64_t *)v89; // 0x160bb
    int64_t v91; // 0x15563
    int64_t v92; // 0x15563
    int32_t v93; // 0x15563
    int32_t v94; // 0x15563
    int16_t * v95; // 0x15563
    switch (*v95) {
        case 2: {
            // 0x1612a
            *v59 = v88 + 28;
            int32_t v96 = *v87 - 28; // 0x16139
            *v87 = v96;
            int64_t v97 = *v59; // 0x1613f
            *(int16_t *)(v97 + 2) = (int16_t)v96;
            *(int32_t *)(v97 + 12) = (int32_t)v90;
            *(char *)(v97 + 8) = 64;
            *(char *)(v97 + 1) = *(char *)(v2 + 328);
            v94 = function_9e96(v2, v45);
            v92 = v91;
            // break -> 0x16278
            break;
        }
        case 10: {
            // 0x161be
            *v59 = v89;
            *v87 = *v87 - 8;
            int64_t v98 = *v59; // 0x161d3
            *(int64_t *)(v98 + 24) = *(int64_t *)(v88 + 24);
            *(int64_t *)(v98 + 32) = *(int64_t *)(v88 + 32);
            *(int64_t *)(v98 + 8) = 0x100000000 * v90 / 0x100000000;
            *(int64_t *)(v98 + 16) = *(int64_t *)(v88 + 16);
            v94 = function_80bc(v2, v45, 0);
            v92 = v91;
            // break -> 0x16278
            break;
        }
        default: {
            // 0x16253
            function_2ea0("Slirp", "../src/tcp_output.c", (int64_t)&g18, "tcp_output", 0);
            v94 = v93;
            v92 = 0;
            // break -> 0x16278
            break;
        }
    }
    // 0x16278
    v47 = v94;
    if (v94 != 0) {
        // break -> 0x16282
        goto lab_0x16282_3;
    }
    // 0x1628d
    if (v72 >= 1) {
        int32_t v99 = *host_long3 + (int32_t)v72; // 0x162a2
        if (v99 - *v20 >= 1) {
            // 0x162b9
            *v20 = v99;
        }
    }
    // 0x162d8
    *(int32_t *)(a1 + 216) = *host_long3;
    *v30 = *v30 & -4;
    int32_t v100 = 0; // 0x16314
    int64_t v101 = v92; // 0x16314
    v14 = 0;
    int64_t v102; // 0x15563
    if (v102 <= v21 && v43 <= v42) {
        goto lab_0x16320;
    }
    goto lab_0x15666;
  lab_0x15665:
    // 0x15665
    v10 = v7;
    v9 = (int16_t *)(a1 + 32);
    v8 = (int32_t *)(a1 + 172);
    goto lab_0x15666_2;
  lab_0x15666_2:
    // 0x15666
    v41 = v9;
    v86 = v10;
    host_long2 = (int32_t *)(a1 + 124);
    v78 = (char *)(a1 + 34);
    v49 = v2 + 392;
    v50 = (int32_t *)v49;
    v16 = (int16_t *)(a1 + 20);
    v17 = (int16_t *)(a1 + 26);
    v18 = (int16_t *)(a1 + 18);
    v65 = (int32_t *)(v2 + 364);
    v19 = (char *)(a1 + 205);
    v20 = (int32_t *)(a1 + 164);
    host_long3 = (int32_t *)(a1 + 152);
    v30 = (int16_t *)(a1 + 36);
    v33 = (int32_t *)(a1 + 128);
    v85 = (int16_t *)(a1 + 182);
    while (true) {
      lab_0x15666:
        // 0x15666
        v91 = v101;
        v93 = v100;
        uint32_t v103 = *v8; // 0x15695
        uint32_t v104 = *(int32_t *)(a1 + 144); // 0x156a2
        int16_t v105 = *(int16_t *)(a1 + 16); // 0x156b7
        unsigned char v106 = *(char *)((int64_t)v105 + (int64_t)&g21); // 0x156c6
        if ((*(int32_t *)&g58 & 2) != 0) {
            // 0x156e3
            function_3080("Slirp", 128, " --- tcp_output flags = 0x%x", (int64_t)v106, v91, v3);
        }
        // 0x15708
        v51 = *host_long2 - *v6;
        uint32_t v107 = v103 > v104 ? v104 : v103; // 0x156aa
        int64_t v108 = v107; // 0x156ad
        int32_t v109 = v106; // 0x156cd
        int32_t v110 = v109; // 0x15715
        int64_t v111 = v108; // 0x15715
        if (*v78 != 0) {
            if (v107 != 0) {
                // 0x1573c
                *v16 = 0;
                *v17 = 0;
                v110 = v109;
                v111 = v108;
            } else {
                // 0x1571c
                v110 = *v50 > v51 ? v109 & 254 : v109;
                v111 = 1;
            }
        }
        uint64_t v112 = v111;
        int32_t v113 = v110;
        int32_t v114 = *v50; // 0x15756
        uint64_t v115 = (int64_t)v114; // 0x1575d
        v52 = v51;
        int64_t v116 = (v112 > v115 ? v115 : v112) - v52; // 0x15771
        int32_t v117 = v114; // 0x1577a
        int64_t v118 = v116; // 0x1577a
        if (v116 < 0) {
            // 0x1577c
            v117 = v114;
            v118 = 0;
            if (v112 == 0) {
                // 0x15787
                *v18 = 0;
                *host_long2 = *v6;
                v117 = *v50;
                v118 = 0;
            }
        }
        // 0x157a8
        v102 = v118;
        v15 = v117;
        v21 = (int64_t)*v41;
        v43 = v102 > v21 ? v21 : v102;
        v34 = *host_long2;
        v35 = *v6;
        v32 = v34 - v15 - v35 + (int32_t)v43 >= 0 ? v113 : v113 & -2;
        v22 = *v65;
        v23 = v22 - *(int32_t *)(v2 + 360);
        v24 = v23;
        if (v43 == 0) {
            goto lab_0x158b9;
        } else {
            if (v102 < v21) {
                if (v43 + v52 < (int64_t)v15) {
                    // 0x15858
                    if (*v78 != 0) {
                        goto lab_0x15a4d;
                    } else {
                        uint32_t v119 = *(int32_t *)(a1 + 196); // 0x15872
                        if (v119 != 0 == v43 >= (int64_t)(v119 / 2)) {
                            goto lab_0x15a4d;
                        } else {
                            // 0x15896
                            if (v34 - *host_long < 0) {
                                goto lab_0x15a4d;
                            } else {
                                goto lab_0x158b9;
                            }
                        }
                    }
                } else {
                    goto lab_0x15a4d;
                }
            } else {
                goto lab_0x15a4d;
            }
        }
    }
  lab_0x16282_3:
    // 0x16282
    v14 = v47;
    goto lab_0x16320;
}

// Address range: 0x16346 - 0x163f5
int64_t function_16346(int64_t a1) {
    int16_t v1 = *(int16_t *)(a1 + 188); // 0x16352
    int16_t v2 = *(int16_t *)(a1 + 190); // 0x16364
    int16_t * v3 = (int16_t *)(a1 + 26); // 0x16377
    int32_t v4 = *(int32_t *)(4 * (int64_t)*v3 + (int64_t)&g27); // 0x16388
    int16_t v5 = ((int32_t)v2 + (int32_t)(v1 / 4)) / 2 * v4; // 0x16399
    int16_t * v6 = (int16_t *)(a1 + 20); // 0x16399
    *v6 = v5;
    if (v5 > 9) {
        if (v5 >= 121) {
            // 0x163c5
            *v6 = 120;
        }
    } else {
        // 0x163ab
        *v6 = 10;
    }
    uint16_t v7 = *v3; // 0x163d3
    int64_t result = v7; // 0x163db
    if (v7 <= 11) {
        // 0x163dd
        *v3 = v7 + 1;
        result = a1;
    }
    // 0x163f2
    return result;
}

// Address range: 0x163f5 - 0x1644d
int64_t function_163f5(int64_t sock) {
    int64_t v1 = __readfsqword(40); // 0x16400
    int32_t option_value = 1; // bp-20, 0x1640f
    int32_t v2 = setsockopt((int32_t)sock, SO_BROADCAST, 1, (int64_t *)&option_value, 4); // 0x16432
    int64_t result = v2; // 0x16444
    if (v1 != __readfsqword(40)) {
        // 0x16446
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1644b
    return result;
}

// Address range: 0x1644d - 0x164a5
int64_t function_1644d(int64_t sock) {
    int64_t v1 = __readfsqword(40); // 0x16458
    int32_t option_value = 1; // bp-20, 0x16467
    int32_t v2 = setsockopt((int32_t)sock, SO_DEBUG, 2, (int64_t *)&option_value, 4); // 0x1648a
    int64_t result = v2; // 0x1649c
    if (v1 != __readfsqword(40)) {
        // 0x1649e
        __stack_chk_fail();
        result = &g91;
    }
    // 0x164a3
    return result;
}

// Address range: 0x164a5 - 0x164fc
int64_t function_164a5(int64_t * a1) {
    int64_t result = 16; // 0x164a5
    int64_t v1; // 0x164a5
    switch ((int16_t)v1) {
        case 10: {
            // 0x164ce
            result = 28;
        }
        case 2: {
            // 0x164fa
            return result;
        }
        default: {
            // 0x164d5
            result = function_2ea0("Slirp", "../src/socket.h", 136, "sockaddr_size", 0);
            return result;
        }
    }
}

// Address range: 0x164fc - 0x16557
int64_t function_164fc(int64_t result) {
    // 0x164fc
    *(int32_t *)(result + (int64_t)&g69) = 1;
    int64_t v1 = result + 448; // 0x16516
    *(int64_t *)(result + (int64_t)&g11) = v1;
    *(int64_t *)v1 = v1;
    *(int64_t *)(result + (int64_t)&g68) = v1;
    return result;
}

// Address range: 0x16557 - 0x1659d
int64_t function_16557(int64_t a1) {
    int64_t v1 = a1 + 448; // 0x16583
    int64_t * v2 = (int64_t *)v1; // 0x16583
    int64_t result = *v2; // 0x16583
    if (result == v1) {
        // 0x1659a
        return result;
    }
    function_17098(*(int64_t *)(result + 336));
    int64_t result2 = *v2; // 0x16583
    while (result2 != v1) {
        // 0x16565
        function_17098(*(int64_t *)(result2 + 336));
        result2 = *v2;
    }
    // 0x1659a
    return result2;
}

// Address range: 0x1659d - 0x16709
int64_t function_1659d(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 112); // 0x165ae
    *(int64_t *)(a1 + 40) = 0;
    int64_t v2 = a1 + 48; // 0x165c5
    int64_t * v3 = (int64_t *)v2; // 0x165d6
    memset(v3, 0, 36);
    *(int16_t *)(a1 + 84) = 0;
    switch (*(int16_t *)(v1 + 72)) {
        case 2: {
            // 0x165fb
            *(char *)(a1 + 57) = 6;
            *(int16_t *)(a1 + 86) = htons(20);
            *(int32_t *)v2 = *(int32_t *)(v1 + 76);
            *(int32_t *)(a1 + 52) = *(int32_t *)(v1 + 204);
            *(int16_t *)(a1 + 88) = *(int16_t *)(v1 + 74);
            *(int16_t *)(a1 + 90) = *(int16_t *)(v1 + 202);
            // break -> 0x166c6
            break;
        }
        case 10: {
            // 0x16644
            *(char *)(a1 + 81) = 6;
            *(int16_t *)(a1 + 86) = htons(20);
            *v3 = *(int64_t *)(v1 + 80);
            *(int64_t *)(a1 + 56) = *(int64_t *)(v1 + 88);
            *(int64_t *)(a1 + 64) = *(int64_t *)(v1 + 208);
            *(int64_t *)(a1 + 72) = *(int64_t *)(v1 + 216);
            *(int16_t *)(a1 + 88) = *(int16_t *)(v1 + 74);
            *(int16_t *)(a1 + 90) = *(int16_t *)(v1 + 202);
            // break -> 0x166c6
            break;
        }
        default: {
            // 0x166a1
            function_2ea0("Slirp", "../src/tcp_subr.c", 96, "tcp_template", 0);
            // break -> 0x166c6
            break;
        }
    }
    // 0x166c6
    *(int32_t *)(a1 + 92) = 0;
    *(int32_t *)(a1 + 96) = 0;
    *(char *)(a1 + 100) = 80;
    *(char *)(a1 + 101) = 0;
    *(int16_t *)(a1 + 102) = 0;
    *(int16_t *)(a1 + 104) = 0;
    *(int16_t *)(a1 + 106) = 0;
    return 80;
}

// Address range: 0x16709 - 0x16ebd
int64_t function_16709(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    int64_t host_long2 = 0x100000000 * a4 / 0x100000000; // 0x1672c
    int64_t host_long = 0x100000000 * a5 / 0x100000000; // 0x16732
    int64_t v1 = 0x100000000 * a6 / 0x100000000; // 0x16739
    int64_t v2 = __readfsqword(40); // 0x1674a
    int64_t v3 = a2; // 0x1676e
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1678d
        function_3080("Slirp", 128, "tcp_respond...", a4, a5, a6);
        v3 = 128;
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x167c4
            function_3080("Slirp", 128, " tp = %p", a1, a5, a6);
            v3 = 128;
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x167fb
                function_3080("Slirp", 128, " ti = %p", a2, a5, a6);
                v3 = 128;
                if (*(int32_t *)&g58 % 2 != 0) {
                    // 0x16832
                    function_3080("Slirp", 128, " m = %p", a3, a5, a6);
                    v3 = 128;
                    if (*(int32_t *)&g58 % 2 != 0) {
                        // 0x16867
                        function_3080("Slirp", 128, " ack = %u", host_long2 & 0xffffffff, a5, a6);
                        v3 = 128;
                        if (*(int32_t *)&g58 % 2 != 0) {
                            // 0x1689c
                            function_3080("Slirp", 128, " seq = %u", host_long & 0xffffffff, a5, a6);
                            v3 = 128;
                            if (*(int32_t *)&g58 % 2 != 0) {
                                // 0x168ac
                                function_3080("Slirp", 128, " flags = %x", v1 & 0xffffffff, a5, a6);
                                v3 = 128;
                            }
                        }
                    }
                }
            }
        }
    }
    int16_t host_short = 0; // 0x168d9
    if (a1 != 0) {
        int64_t v4 = *(int64_t *)(a1 + 112); // 0x168e2
        int32_t v5 = *(int32_t *)(v4 + 360); // 0x168f7
        host_short = (int16_t)(*(int32_t *)(v4 + 364) - v5);
    }
    int64_t v6 = 0x1000000000000 * a7 / 0x1000000000000; // 0x16743
    int64_t v7; // 0x16709
    int64_t v8; // 0x16709
    int64_t v9; // 0x16709
    if (a3 != 0) {
        // 0x16a35
        *(int64_t *)(a3 + 48) = a2;
        *(int32_t *)(a3 + 56) = 68;
        switch ((int16_t)v6) {
            case 2: {
                int32_t * v10 = (int32_t *)(a2 + 12); // 0x16a78
                int32_t * v11 = (int32_t *)(a2 + 8); // 0x16a85
                *v10 = *v11;
                *v11 = *v10;
                int16_t * v12 = (int16_t *)(a2 + 50); // 0x16aa6
                int16_t * v13 = (int16_t *)(a2 + 48); // 0x16ab5
                *v12 = *v13;
                *v13 = *v12;
                v9 = v1;
                v8 = a3;
                v7 = a2;
                // break -> 0x16b7f
                break;
            }
            case 10: {
                int64_t * v14 = (int64_t *)(a2 + 32); // 0x16adf
                int64_t * v15 = (int64_t *)(a2 + 24); // 0x16ae3
                int64_t * v16 = (int64_t *)(a2 + 16); // 0x16afd
                int64_t * v17 = (int64_t *)(a2 + 8); // 0x16b01
                *v15 = *v17;
                *v14 = *v16;
                *v17 = *v15;
                *v16 = *v14;
                int16_t * v18 = (int16_t *)(a2 + 50); // 0x16b2b
                int16_t * v19 = (int16_t *)(a2 + 48); // 0x16b3a
                *v18 = *v19;
                *v19 = *v18;
                v9 = v1;
                v8 = a3;
                v7 = a2;
                // break -> 0x16b7f
                break;
            }
            default: {
                // 0x16b5a
                function_2ea0("Slirp", "../src/tcp_subr.c", 182, "tcp_respond", 0);
                v9 = v1;
                v8 = a3;
                v7 = a2;
                // break -> 0x16b7f
                break;
            }
        }
        goto lab_0x16b7f;
    } else {
        if (a1 == 0) {
            goto lab_0x16e9d;
        } else {
            int64_t v20 = function_a39a(*(int64_t *)(*(int64_t *)(a1 + 112) + 40)); // 0x16932
            if (v20 == 0) {
                goto lab_0x16e9d;
            } else {
                int64_t * v21 = (int64_t *)(v20 + 48); // 0x16959
                int64_t v22 = *v21; // 0x16959
                int64_t v23 = v22 + 16; // 0x1695d
                *v21 = v23;
                *(int64_t *)v23 = v3;
                *(int64_t *)(v22 + 24) = *(int64_t *)(a2 + 8);
                *(int64_t *)(v22 + 32) = *(int64_t *)(a2 + 16);
                *(int64_t *)(v22 + 40) = *(int64_t *)(a2 + 24);
                *(int64_t *)(v22 + 48) = *(int64_t *)(a2 + 32);
                *(int64_t *)(v22 + 56) = *(int64_t *)(a2 + 40);
                *(int64_t *)(v22 + 64) = *(int64_t *)(a2 + 48);
                *(int64_t *)(v22 + 72) = *(int64_t *)(a2 + 56);
                *(int32_t *)(v22 + 80) = *(int32_t *)(a2 + 64);
                int64_t v24 = *v21; // 0x169c9
                switch ((int16_t)v6) {
                    case 2: {
                        // 0x169e7
                        *(char *)(v24 + 16) = 0;
                        v9 = 16;
                        v8 = v20;
                        v7 = v24;
                        // break -> 0x16b7f
                        break;
                    }
                    case 10: {
                        // 0x169f4
                        *(char *)(v24 + 40) = 0;
                        v9 = 16;
                        v8 = v20;
                        v7 = v24;
                        // break -> 0x16b7f
                        break;
                    }
                    default: {
                        // 0x16a01
                        function_2ea0("Slirp", "../src/tcp_subr.c", 153, "tcp_respond", 0);
                        v9 = 16;
                        v8 = v20;
                        v7 = v24;
                        // break -> 0x16b7f
                        break;
                    }
                }
                goto lab_0x16b7f;
            }
        }
    }
  lab_0x16b7f:
    // 0x16b7f
    *(int16_t *)(v7 + 46) = htons(20);
    int32_t * v25 = (int32_t *)(v8 + 56); // 0x16bac
    *v25 = 68;
    *(int64_t *)v7 = 0;
    *(int16_t *)(v7 + 44) = 0;
    *(int32_t *)(v7 + 52) = htonl((int32_t)host_long);
    *(int32_t *)(v7 + 56) = htonl((int32_t)host_long2);
    *(char *)(v7 + 60) = 80;
    *(char *)(v7 + 61) = (char)v9;
    if (a1 == 0) {
        // 0x16c71
        *(int16_t *)(v7 + 62) = htons(host_short);
    } else {
        unsigned char v26 = *(char *)(a1 + 205); // 0x16c45
        int16_t v27 = htons((int16_t)((int32_t)host_short >> (int32_t)(v26 % 32))); // 0x16c5d
        *(int16_t *)(v7 + 62) = v27;
    }
    // 0x16c8b
    *(int16_t *)(v7 + 66) = 0;
    int16_t * v28 = (int16_t *)(v7 + 64); // 0x16c9f
    *v28 = 0;
    *v28 = (int16_t)function_44c3(v8, 68);
    int64_t * v29 = (int64_t *)(v8 + 48); // 0x16ccb
    int64_t v30 = *v29; // 0x16ccb
    int64_t v31 = v30 + 8; // 0x16cd2
    int64_t v32 = *(int64_t *)v31; // 0x16cd2
    switch ((int16_t)v6) {
        case 2: {
            // 0x16d2e
            *v29 = v30 + 28;
            int32_t v33 = *v25 - 28; // 0x16d52
            *v25 = v33;
            int64_t v34 = *v29; // 0x16d68
            *(int16_t *)(v34 + 2) = (int16_t)v33;
            *(int32_t *)(v34 + 12) = (int32_t)v32;
            *(char *)(v34 + 8) = (v9 & 4) == 0 ? 64 : -1;
            function_9e96(0, v8);
            // break -> 0x16e9d
            break;
        }
        case 10: {
            // 0x16ddb
            *v29 = v31;
            *v25 = *v25 - 8;
            int64_t v35 = *v29; // 0x16e15
            *(int64_t *)(v35 + 24) = *(int64_t *)(v30 + 24);
            *(int64_t *)(v35 + 32) = *(int64_t *)(v30 + 32);
            *(int64_t *)(v35 + 8) = 0x100000000 * v32 / 0x100000000;
            *(int64_t *)(v35 + 16) = *(int64_t *)(v30 + 16);
            function_80bc(0, v8, 0);
            // break -> 0x16e9d
            break;
        }
        default: {
            // 0x16e77
            function_2ea0("Slirp", "../src/tcp_subr.c", 245, "tcp_respond", 0);
            // break -> 0x16e9d
            break;
        }
    }
    goto lab_0x16e9d;
  lab_0x16e9d:;
    int64_t result = 0; // 0x16eaa
    if (v2 != __readfsqword(40)) {
        // 0x16eac
        __stack_chk_fail();
        result = &g91;
    }
    // 0x16eb1
    return result;
}

// Address range: 0x16ebd - 0x16fc0
int64_t function_16ebd(int64_t a1) {
    int64_t * mem = malloc(224); // 0x16ecf
    int64_t result = 0; // 0x16eda
    if (mem != NULL) {
        // 0x16f91
        result = (int64_t)mem;
        memset(mem, 0, 224);
        *(int64_t *)(result + 8) = result;
        *mem = result;
        uint32_t v1 = *(int32_t *)(*(int64_t *)(a1 + 40) + 136); // 0x16f0b
        int64_t v2 = (int64_t)v1 - (*(int16_t *)(a1 + 72) != 2 ? 60 : 40); // 0x16f2b
        int32_t v3 = v2; // 0x16f34
        int32_t v4 = v3 - 0x8000; // 0x16f34
        int16_t v5 = v4 < 0 == (0x7fff - v3 & v3) < 0 == (v4 != 0) ? -0x8000 : (int16_t)v2; // 0x16f3c
        *(int16_t *)(result + 32) = v5;
        *(int16_t *)(result + 36) = 0;
        *(int64_t *)(result + 112) = a1;
        *(int16_t *)(result + 188) = 0;
        *(int16_t *)(result + 190) = 24;
        *(int16_t *)(result + 192) = 2;
        *(int16_t *)(result + 28) = 12;
        *(int32_t *)(result + 172) = 0x3fffc000;
        *(int32_t *)(result + 176) = 0x3fffc000;
        *(int16_t *)(result + 16) = 0;
        *(int64_t *)(a1 + 336) = result;
    }
    // 0x16fb9
    return result;
}

// Address range: 0x16fc0 - 0x17098
int64_t function_16fc0(int64_t a1, int64_t a2) {
    // 0x16fc0
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x16ffc
        int64_t v1; // 0x16fc0
        int64_t v2; // 0x16fc0
        int64_t v3; // 0x16fc0
        function_3080("Slirp", 128, "tcp_drop...", v3, v2, v1);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x17030
            function_3080("Slirp", 128, " tp = %p", a1, v2, v1);
            if (*(int32_t *)&g58 % 2 != 0) {
                uint32_t v4 = *__errno_location(); // 0x17045
                function_3080("Slirp", 128, " errno = %d", (int64_t)v4, v2, v1);
            }
        }
    }
    int16_t * v5 = (int16_t *)(a1 + 16); // 0x1706a
    if (*v5 >= 3) {
        // 0x17074
        *v5 = 0;
        function_15563(a1);
    }
    // 0x1708a
    return function_17098(a1);
}

// Address range: 0x17098 - 0x17227
int64_t function_17098(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 112); // 0x170ab
    int64_t v2 = *(int64_t *)(v1 + 40); // 0x170b7
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x170ec
        int64_t v3; // 0x17098
        int64_t v4; // 0x17098
        int64_t v5; // 0x17098
        function_3080("Slirp", 128, "tcp_close...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x170fc
            function_3080("Slirp", 128, " tp = %p", a1, v4, v3);
        }
        // 0x17120
        if (a1 != (int64_t)"Slirp") {
            int64_t v6 = *(int64_t *)(int64_t)"Slirp"; // 0x17131
            int64_t v7 = *(int64_t *)(v6 + 8); // 0x1713c
            function_ab7f(v7);
            function_a4f0(*(int64_t *)(v7 + 16));
            int64_t v8 = v6; // 0x17167
            while (v6 != a1) {
                // 0x1712d
                v6 = *(int64_t *)v8;
                v7 = *(int64_t *)(v6 + 8);
                function_ab7f(v7);
                function_a4f0(*(int64_t *)(v7 + 16));
                v8 = v6;
            }
        }
    }
    // 0x17169
    free((int64_t *)a1);
    *(int64_t *)(v1 + 336) = 0;
    int64_t * v9 = (int64_t *)(v2 + (int64_t)&g68); // 0x17188
    if (v1 == *v9) {
        // 0x17195
        *v9 = v2 + 448;
    }
    // 0x171ab
    close(*(int32_t *)(v1 + 16));
    function_c3ab(v1 + 360);
    function_c3ab(v1 + 392);
    function_f77a(v1);
    return 0;
}

// Address range: 0x17227 - 0x17310
int64_t function_17227(int64_t a1) {
    int64_t result = 0; // 0x17241
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x17260
        int64_t v1; // 0x17227
        int64_t v2; // 0x17227
        int64_t v3; // 0x17227
        function_3080("Slirp", 128, "tcp_sockclosed...", v3, v2, v1);
        result = 0;
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x17270
            result = function_3080("Slirp", 128, " tp = %p", a1, v2, v1);
        }
    }
    // 0x17294
    if (a1 == 0) {
        // 0x1730e
        return result;
    }
    uint16_t v4 = *(int16_t *)(a1 + 16); // 0x1729f
    if (v4 >= 6) {
        // 0x1730e
        return function_15563(a1);
    }
    int32_t v5 = *(int32_t *)((4 * (int64_t)v4 & 0x3fffffffc) + (int64_t)&g22); // 0x172ba
    return (int64_t)v5 + (int64_t)&g22;
}

// Address range: 0x17310 - 0x17600
int64_t function_17310(int64_t a1, uint64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x1732b
    int64_t v2; // 0x17310
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x17371
        int64_t v3; // 0x17310
        int64_t v4; // 0x17310
        function_3080("Slirp", 128, "tcp_fconnect...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x17381
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
        }
    }
    int64_t v5 = function_1c25e(a2 % 0x10000, 1, 0); // 0x173bb
    int32_t sock = v5; // 0x173c0
    *(int32_t *)(a1 + 16) = sock;
    int64_t v6; // 0x17310
    if (sock < 0) {
        // 0x175e4
        v6 = sock;
        goto lab_0x175ea;
    } else {
        int64_t v7 = v5 & 0xffffffff; // 0x173ff
        function_1c142(v7);
        function_1644d(v7);
        int32_t option_value = 1; // bp-164, 0x1744c
        setsockopt(sock, SO_DEBUG, 10, (int64_t *)&option_value, 4);
        option_value = 1;
        setsockopt(sock, SO_BROADCAST, 1, (int64_t *)&option_value, 4);
        int64_t addr = *(int64_t *)(a1 + 72); // bp-152, 0x174bd
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x17566
            function_3080("Slirp", 128, " connect()ing...", *(int64_t *)(a1 + 176), 4, v2);
        }
        int64_t v8 = function_11cd0(a1, (int64_t)&addr); // 0x17597
        v6 = 0xffffffff;
        if ((int32_t)v8 >= 0) {
            int64_t addr_len = function_164a5(&addr); // 0x175b1
            int32_t v9 = connect(sock, (struct sockaddr *)&addr, (int32_t)addr_len); // 0x175ca
            function_11aba(a1);
            // 0x175e4
            v6 = v9;
            goto lab_0x175ea;
        } else {
            goto lab_0x175ea;
        }
    }
  lab_0x175ea:;
    int64_t result = v6; // 0x175f7
    if (v1 != __readfsqword(40)) {
        // 0x175f9
        __stack_chk_fail();
        result = &g91;
    }
    // 0x175fe
    return result;
}

// Address range: 0x17600 - 0x17b83
int64_t function_17600(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x17613
    int64_t v2 = *(int64_t *)(a1 + 40); // 0x17629
    int32_t addr_len = 128; // bp-204, 0x17634
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1766b
        int64_t v3; // 0x17600
        int64_t v4; // 0x17600
        int64_t v5; // 0x17600
        function_3080("Slirp", 128, "tcp_connect...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x1767b
            function_3080("Slirp", 128, " inso = %p", a1, v4, v3);
        }
    }
    int32_t * v6 = (int32_t *)(a1 + 332); // 0x176a9
    int64_t v7 = a1; // 0x176b6
    if ((*v6 & (int32_t)&g36) == 0) {
        // 0x176cb
        v7 = function_f694(v2);
        if ((int32_t)function_17b83(v7) >= 0) {
            // 0x17708
            *(int64_t *)(v7 + 200) = *(int64_t *)(a1 + 200);
            *(int64_t *)(v7 + 208) = *(int64_t *)(a1 + 208);
            *(int64_t *)(v7 + 216) = *(int64_t *)(a1 + 216);
            *(int64_t *)(v7 + 224) = *(int64_t *)(a1 + 224);
            *(int64_t *)(v7 + 232) = *(int64_t *)(a1 + 232);
            *(int64_t *)(v7 + 240) = *(int64_t *)(a1 + 240);
            *(int64_t *)(v7 + 248) = *(int64_t *)(a1 + 248);
            *(int64_t *)(v7 + 256) = *(int64_t *)(a1 + 256);
            *(int64_t *)(v7 + 264) = *(int64_t *)(a1 + 264);
            *(int64_t *)(v7 + 272) = *(int64_t *)(a1 + 272);
            *(int64_t *)(v7 + 280) = *(int64_t *)(a1 + 280);
            *(int64_t *)(v7 + 288) = *(int64_t *)(a1 + 288);
            *(int64_t *)(v7 + 296) = *(int64_t *)(a1 + 296);
            *(int64_t *)(v7 + 304) = *(int64_t *)(a1 + 304);
            *(int64_t *)(v7 + 312) = *(int64_t *)(a1 + 312);
            *(int64_t *)(v7 + 320) = *(int64_t *)(a1 + 320);
            *(int16_t *)(v7 + 72) = *(int16_t *)(a1 + 72);
            goto lab_0x1780c;
        } else {
            // 0x176f4
            function_2d70(v7);
            goto lab_0x17b65;
        }
    } else {
        goto lab_0x1780c;
    }
  lab_0x1780c:;
    int64_t * v8 = (int64_t *)(v7 + 336); // 0x17813
    function_15314(*v8, 0);
    int64_t addr; // bp-168, 0x17600
    int32_t accepted_sock_fd = accept(*(int32_t *)(a1 + 16), (struct sockaddr *)&addr, &addr_len); // 0x17844
    if (accepted_sock_fd >= 0) {
        int64_t v9 = accepted_sock_fd; // 0x17879
        function_1c142(v9);
        function_1644d(v9);
        int32_t option_value = 1; // bp-200, 0x178c6
        setsockopt(accepted_sock_fd, SO_DEBUG, 10, (int64_t *)&option_value, 4);
        function_163f5(v9);
        *(int64_t *)(v7 + 72) = addr;
        function_11fe2(v7);
        int32_t * fd = (int32_t *)(v7 + 16);
        int32_t * v10; // 0x17600
        if ((*v6 & (int32_t)&g36) == 0) {
            // 0x17873
            v10 = (int32_t *)(v7 + 332);
        } else {
            // 0x179d7
            close(*fd);
            int32_t * v11 = (int32_t *)(v7 + 332);
            *v11 = 1;
            v10 = v11;
        }
        int32_t * v12 = v10;
        *fd = accepted_sock_fd;
        *v12 = *v12 | 0x2000;
        *(char *)(v7 + 328) = (char)function_17be5(v7);
        int64_t v13 = *v8; // 0x17a86
        function_1659d(v13);
        *(int16_t *)(v13 + 16) = 2;
        *(int16_t *)(v13 + 22) = 150;
        int32_t * v14 = (int32_t *)(v2 + (int64_t)&g69); // 0x17ac4
        int32_t * v15 = (int32_t *)(v13 + 140); // 0x17ad1
        *v15 = *v14;
        *v14 = *v14 + 0xfa00;
        int32_t v16 = *v15; // 0x17afe
        *(int32_t *)(v13 + 128) = v16;
        *(int32_t *)(v13 + 168) = v16;
        *(int32_t *)(v13 + 124) = v16;
        *(int32_t *)(v13 + 120) = v16;
        function_15563(v13);
    } else {
        // 0x17858
        function_17098(*v8);
    }
    goto lab_0x17b65;
  lab_0x17b65:;
    int64_t result = 0; // 0x17b72
    if (v1 != __readfsqword(40)) {
        // 0x17b74
        __stack_chk_fail();
        result = &g91;
    }
    // 0x17b79
    return result;
}

// Address range: 0x17b83 - 0x17be5
int64_t function_17b83(int64_t a1) {
    int64_t v1 = function_16ebd(a1); // 0x17b96
    *(int64_t *)(a1 + 336) = v1;
    int64_t result = 0xffffffff; // 0x17bb7
    if (v1 != 0) {
        // 0x17bc0
        function_ab4c(a1, *(int64_t *)(a1 + 40) + 448);
        result = 0;
    }
    // 0x17be3
    return result;
}

// Address range: 0x17be5 - 0x17d52
int64_t function_17be5(int64_t a1) {
    int32_t v1 = 0; // 0x17d1f
    int64_t v2 = 0;
    int16_t * v3 = (int16_t *)(v2 + (int64_t)&g24); // 0x17c19
    if (*v3 != 0) {
        // 0x17c22
        if (ntohs(*(int16_t *)(a1 + 74)) == *v3) {
            // break -> 0x17cc0
            return 0;
        }
    }
    int16_t * v4 = (int16_t *)(v2 + (int64_t)&g23); // 0x17c77
    if (*v4 != 0) {
        // 0x17c84
        if (ntohs(*(int16_t *)(a1 + 202)) == *v4) {
            // break -> 0x17cc0
            return 0;
        }
    }
    // 0x17d1f
    v1++;
    int64_t v5 = 6 * (int64_t)v1; // 0x17d32
    while (*(char *)(v5 + (int64_t)&g25) != 0) {
        // 0x17bfd
        v3 = (int16_t *)(v5 + (int64_t)&g24);
        if (*v3 != 0) {
            // 0x17c22
            if (ntohs(*(int16_t *)(a1 + 74)) == *v3) {
                // break -> 0x17cc0
                break;
            }
        }
        // 0x17c5b
        v4 = (int16_t *)(v5 + (int64_t)&g23);
        if (*v4 != 0) {
            // 0x17c84
            if (ntohs(*(int16_t *)(a1 + 202)) == *v4) {
                // break -> 0x17cc0
                break;
            }
        }
        // 0x17d1f
        v1++;
        v5 = 6 * (int64_t)v1;
    }
    // 0x17d50
    return 0;
}

// Address range: 0x17d52 - 0x190aa
int64_t function_17d52(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0x17d6e
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x17dbc
        int64_t v2; // 0x17d52
        int64_t v3; // 0x17d52
        function_3080("Slirp", 128, "tcp_emu...", a4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x17df3
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x17e03
                function_3080("Slirp", 128, " m = %p", a2, v3, v2);
            }
        }
    }
    char * v4 = (char *)(a1 + 329); // 0x17e31
    unsigned char v5 = *v4; // 0x17e31
    if (v5 < 8) {
        int32_t v6 = *(int32_t *)(4 * (int64_t)v5 + (int64_t)&g26); // 0x17e55
        return (int64_t)v6 + (int64_t)&g26;
    }
    // 0x1907a
    *v4 = 0;
    int64_t result = 1; // 0x1909a
    if (v1 != __readfsqword(40)) {
        // 0x1909c
        __stack_chk_fail();
        result = &g91;
    }
    // 0x190a1
    return result;
}

// Address range: 0x190aa - 0x19297
int64_t function_190aa(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 40); // 0x190ba
    int64_t v2; // 0x190aa
    int64_t v3; // 0x190aa
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x190fd
        int64_t v4; // 0x190aa
        function_3080("Slirp", 128, "tcp_ctl...", v4, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x1910d
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
        }
    }
    int32_t v5 = *(int32_t *)(a1 + 76); // 0x19135
    int64_t * v6; // 0x190aa
    int64_t result; // 0x190aa
    if (v5 != *(int32_t *)(v1 + 20)) {
        int64_t v7 = *(int64_t *)(v1 + 128);
        if (v7 != 0) {
            int32_t v8 = (int32_t)*(int16_t *)(a1 + 74); // 0x1916d
            if (*(int32_t *)(v7 + 20) == v8) {
                // 0x19175
                if (v5 == *(int32_t *)(v7 + 16)) {
                    // 0x1918b
                    if (*(int64_t *)v7 == 0) {
                        // 0x191b8
                        v6 = (int64_t *)(v7 + 24);
                        if ((*(int32_t *)&g58 & 2) == 0) {
                            goto lab_0x191f0;
                        } else {
                            // 0x191c8
                            function_3080("Slirp", 128, " executing %s", *v6, v3, v2);
                            goto lab_0x191f0;
                        }
                    } else {
                        // 0x19197
                        *(int32_t *)(a1 + 16) = -1;
                        *(int64_t *)(a1 + 24) = v7;
                        result = 1;
                        return result;
                    }
                }
            }
            int64_t v9 = *(int64_t *)(v7 + 32);
            while (v9 != 0) {
                int64_t v10 = v9;
                if (*(int32_t *)(v10 + 20) == v8) {
                    // 0x19175
                    if (v5 == *(int32_t *)(v10 + 16)) {
                        // 0x1918b
                        if (*(int64_t *)v10 == 0) {
                            // 0x191b8
                            v6 = (int64_t *)(v10 + 24);
                            if ((*(int32_t *)&g58 & 2) == 0) {
                                goto lab_0x191f0;
                            } else {
                                // 0x191c8
                                function_3080("Slirp", 128, " executing %s", *v6, v3, v2);
                                goto lab_0x191f0;
                            }
                        } else {
                            // 0x19197
                            *(int32_t *)(a1 + 16) = -1;
                            *(int64_t *)(a1 + 24) = v10;
                            result = 1;
                            return result;
                        }
                    }
                }
                // 0x1920c
                v9 = *(int64_t *)(v10 + 32);
            }
        }
    }
    int32_t v11 = *(int32_t *)(a1 + 396); // 0x19227
    int64_t * v12 = (int64_t *)(a1 + 400); // 0x19230
    int64_t str = *v12; // 0x19230
    int64_t v13 = *(int64_t *)(a1 + 416); // 0x1923b
    uint32_t chars_printed = snprintf((char *)str, v11 + (int32_t)(v13 - str), "Error: No application configured.\r\n"); // 0x19268
    *(int32_t *)(a1 + 392) = chars_printed;
    *v12 = *v12 + (int64_t)chars_printed;
    result = 0;
  lab_0x19295:
    // 0x19295
    return result;
  lab_0x191f0:
    // 0x191f0
    result = function_af8e(a1, *v6);
    return result;
}

// Address range: 0x19297 - 0x1933b
int64_t function_19297(int64_t result) {
    // 0x19297
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x192b6
        int64_t v1; // 0x19297
        int64_t v2; // 0x19297
        int64_t v3; // 0x19297
        function_3080("Slirp", 128, "tcp_fasttimo...", v3, v2, v1);
    }
    int64_t result2 = result + 448; // 0x192d7
    int64_t v4 = *(int64_t *)result2; // 0x192d7
    if (v4 == 0) {
        // 0x19331
        return result;
    }
    // 0x19322
    if (v4 == result2) {
        // 0x19331
        return result2;
    }
    int64_t v5 = v4; // 0x1932f
    int64_t v6 = *(int64_t *)(v5 + 336); // 0x192e5
    int16_t v7; // 0x192f2
    int16_t * v8; // 0x192f2
    if (v6 != 0) {
        // 0x192f2
        v8 = (int16_t *)(v6 + 36);
        v7 = *v8;
        if ((v7 & 2) != 0) {
            // 0x19300
            *v8 = v7 & -4 | 1;
            function_15563(v6);
        }
    }
    // 0x1931e
    v5 = *(int64_t *)v5;
    while (v5 != result2) {
        // 0x192e5
        v6 = *(int64_t *)(v5 + 336);
        if (v6 != 0) {
            // 0x192f2
            v8 = (int16_t *)(v6 + 36);
            v7 = *v8;
            if ((v7 & 2) != 0) {
                // 0x19300
                *v8 = v7 & -4 | 1;
                function_15563(v6);
            }
        }
        // 0x1931e
        v5 = *(int64_t *)v5;
    }
    // 0x19331
    return result2;
}

// Address range: 0x1933b - 0x1949b
int64_t function_1933b(int64_t result) {
    // 0x1933b
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1935e
        int64_t v1; // 0x1933b
        int64_t v2; // 0x1933b
        int64_t v3; // 0x1933b
        function_3080("Slirp", 128, "tcp_slowtimo...", v3, v2, v1);
    }
    int64_t v4 = result + 448; // 0x1937f
    int64_t v5 = *(int64_t *)v4; // 0x1937f
    if (v5 == 0) {
        // 0x1948e
        return result;
    }
    int64_t v6 = v5; // 0x19454
    if (v5 != v4) {
        while (true) {
            int64_t v7 = v6;
            v6 = *(int64_t *)v7;
            int64_t v8 = *(int64_t *)(v7 + 336); // 0x19398
            if (v8 != 0) {
                int64_t * v9 = (int64_t *)(v6 + 8);
                int64_t v10 = 0;
                int16_t * v11 = (int16_t *)(v8 + 18 + 0x100000000 * v10 / 0x80000000); // 0x193b7
                int16_t v12 = *v11; // 0x193b7
                int16_t v13; // 0x193cd
                if (v12 != 0) {
                    // 0x193c1
                    v13 = v12 - 1;
                    *v11 = v13;
                    if (v13 == 0) {
                        // 0x193ef
                        function_194c9(v8, v10);
                        if (v7 != *v9) {
                            goto lab_0x19444;
                        }
                    }
                }
                int64_t v14 = v10 + 1; // 0x19403
                while ((int32_t)v14 < 4) {
                    // 0x193b0
                    v10 = v14 & 0xffffffff;
                    v11 = (int16_t *)(v8 + 18 + 0x100000000 * v10 / 0x80000000);
                    v12 = *v11;
                    if (v12 != 0) {
                        // 0x193c1
                        v13 = v12 - 1;
                        *v11 = v13;
                        if (v13 == 0) {
                            // 0x193ef
                            function_194c9(v8, v10);
                            if (v7 != *v9) {
                                goto lab_0x19444;
                            }
                        }
                    }
                    // 0x19403
                    v14 = v10 + 1;
                }
                int16_t * v15 = (int16_t *)(v8 + 180); // 0x1940d
                *v15 = *v15 + 1;
                int16_t * v16 = (int16_t *)(v8 + 182); // 0x1941e
                int16_t v17 = *v16; // 0x1941e
                if (v17 != 0) {
                    // 0x1942a
                    *v16 = v17 + 1;
                }
            }
          lab_0x19444:
            // 0x19444
            if (v6 == v4) {
                // break -> 0x1945a
                break;
            }
        }
    }
    int32_t * v18 = (int32_t *)(result + (int64_t)&g69); // 0x1945e
    *v18 = *v18 + 0xfa00;
    int32_t * v19 = (int32_t *)(result + (int64_t)&g70); // 0x19478
    *v19 = *v19 + 1;
    // 0x1948e
    return result;
}

// Address range: 0x1949b - 0x194c9
int64_t function_1949b(int64_t result) {
    int64_t v1 = 0; // 0x1949b
    *(int16_t *)(result + 18 + 0x100000000 * v1 / 0x80000000) = 0;
    int64_t v2 = v1 + 1; // 0x194bd
    v1 = v2 & 0xffffffff;
    while ((int32_t)v2 < 4) {
        // 0x194ab
        *(int16_t *)(result + 18 + 0x100000000 * v1 / 0x80000000) = 0;
        v2 = v1 + 1;
        v1 = v2 & 0xffffffff;
    }
    // 0x194c5
    return result;
}

// Address range: 0x194c9 - 0x19784
int64_t function_194c9(int64_t result, int64_t a2) {
    // 0x194c9
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x194ea
        int64_t v1; // 0x194c9
        int64_t v2; // 0x194c9
        int64_t v3; // 0x194c9
        function_3080("Slirp", 128, "tcp_timers...", v3, v2, v1);
    }
    uint32_t v4 = (int32_t)a2; // 0x1950a
    if (v4 == 1) {
        // 0x196c8
        function_16346(result);
        char * v5 = (char *)(result + 34); // 0x196d0
        *v5 = 1;
        function_15563(result);
        *v5 = 0;
        // 0x1977b
        return result;
    }
    if (v4 > 1) {
        if (v4 != 2) {
            // 0x1952a
            if (v4 != 3) {
                // 0x1977b
                return result;
            }
            // 0x19533
            if (*(int16_t *)(result + 16) == 10 || *(int16_t *)(result + 180) > (int16_t)&g77) {
                // 0x1977b
                return function_17098(result);
            }
            // 0x1954a
            *(int16_t *)(result + 24) = 150;
            // 0x1977b
            return result;
        }
        int16_t v6 = *(int16_t *)(result + 16); // 0x196e5
        if (v6 < 4) {
            // 0x1977b
            return function_16fc0(result, 0);
        }
        // 0x196ef
        if (v6 > 5 || g61 == 0) {
            // 0x1975b
            *(int16_t *)(result + 22) = 0x3840;
            // 0x1977b
            return result;
        }
        // 0x19707
        if (*(int16_t *)(result + 180) > 0x3cef) {
            // 0x1977b
            return function_16fc0(result, 0);
        }
        uint16_t v7 = *(int16_t *)(*(int64_t *)(result + 112) + 72); // 0x19718
        int32_t v8 = *(int32_t *)(result + 120); // 0x1971f
        uint32_t v9 = *(int32_t *)(result + 152); // 0x19725
        function_16709(result, result + 40, 0, (int64_t)v9, (int64_t)(v8 - 1), 0, (int64_t)v7);
        *(int16_t *)(result + 22) = 150;
        // 0x1977b
        return result;
    }
    // 0x19518
    if (v4 != 0) {
        // 0x1977b
        return result;
    }
    int16_t * v10 = (int16_t *)(result + 26); // 0x19565
    int16_t v11 = *v10 + 1; // 0x19569
    *v10 = v11;
    int16_t v12 = v11; // 0x19578
    if (v11 >= 13) {
        int16_t * v13 = (int16_t *)(result + 32); // 0x1957a
        uint16_t v14 = *v13; // 0x1957a
        *v13 = v14 / 2;
        if (v14 < 64) {
            // 0x1958f
            *v10 = 12;
            // 0x1977b
            return function_16fc0(result, (int64_t)*(int16_t *)(result + 202) & 0xffffffff);
        }
        // 0x195b2
        *v10 = 6;
        v12 = 6;
    }
    int16_t * v15 = (int16_t *)(result + 188); // 0x195b8
    int16_t * v16 = (int16_t *)(result + 190); // 0x195c6
    int32_t v17 = *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g27); // 0x195e2
    uint16_t v18 = (int16_t)(((int32_t)*v16 + (int32_t)(*v15 / 8)) * v17); // 0x195ee
    int16_t * v19 = (int16_t *)(result + 28); // 0x195ee
    *v19 = v18;
    uint16_t v20 = *(int16_t *)(result + 192); // 0x195f6
    int16_t v21; // 0x194c9
    if (v20 > v18) {
        // 0x19602
        *v19 = v20;
        v21 = v20;
    } else {
        // 0x1960f
        v21 = v18;
        if (v18 >= 25) {
            // 0x19619
            *v19 = 24;
            v21 = 24;
        }
    }
    // 0x1961f
    *(int16_t *)(result + 18) = v21;
    if (*v10 >= 4) {
        // 0x19631
        *v16 = *v15 / 8 + *v16;
        *v15 = 0;
    }
    // 0x19657
    *(int32_t *)(result + 124) = *(int32_t *)(result + 120);
    *(int16_t *)(result + 182) = 0;
    int32_t * v22 = (int32_t *)(result + 172); // 0x19666
    uint32_t v23 = *v22; // 0x19666
    uint32_t v24 = *(int32_t *)(result + 144); // 0x1966c
    uint32_t v25 = (v23 > v24 ? v24 : v23) / 2; // 0x19677
    int16_t * v26 = (int16_t *)(result + 32); // 0x19679
    uint32_t v27 = (int32_t)*v26; // 0x19685
    uint32_t v28 = v25 / v27; // 0x19685
    int32_t v29 = v28 == 1 | v25 < v27 ? 2 : v28;
    *v22 = v27;
    *(int32_t *)(result + 176) = v29 * (int32_t)*v26;
    *(int16_t *)(result + 30) = 0;
    function_15563(result);
    // 0x1977b
    return result;
}

// Address range: 0x19784 - 0x197b3
int64_t function_19784(int64_t str, int64_t str2) {
    int32_t memcmp_rc = memcmp((int64_t *)str, (int64_t *)str2, 16); // 0x197a7
    return (int64_t)(memcmp_rc & -256) | (int64_t)(memcmp_rc == 0);
}

// Address range: 0x197b3 - 0x198b7
int64_t function_197b3(int64_t a1, int64_t a2) {
    // 0x197b3
    int64_t v1; // 0x197b3
    int16_t v2 = v1;
    int64_t v3; // 0x197b3
    if (v2 != (int16_t)v3) {
        // 0x198b5
        return 0;
    }
    switch (v2) {
        case 2: {
            // 0x197f9
            if (*(int32_t *)(a1 + 4) != *(int32_t *)(a2 + 4) || *(int16_t *)(a1 + 2) != *(int16_t *)(a2 + 2)) {
                // 0x198b5
                return 0;
            }
            // 0x198b5
            return 1;
        }
        case 10: {
            // 0x1983e
            if ((char)function_19784(a1 + 8, a2 + 8) == 0 || *(int16_t *)(a1 + 2) != *(int16_t *)(a2 + 2)) {
                // 0x198b5
                return 0;
            }
            // 0x198b5
            return 1;
        }
    }
    // 0x198b5
    return function_2ea0("Slirp", "../src/socket.h", 122, "sockaddr_equal", 0);
}

// Address range: 0x198b7 - 0x1990e
int64_t function_198b7(int64_t a1) {
    int64_t result = 16; // 0x198b7
    int64_t v1; // 0x198b7
    switch ((int16_t)v1) {
        case 10: {
            // 0x198e0
            result = 28;
        }
        case 2: {
            // 0x1990c
            return result;
        }
        default: {
            // 0x198e7
            result = function_2ea0("Slirp", "../src/socket.h", 136, "sockaddr_size", 0);
            return result;
        }
    }
}

// Address range: 0x1990e - 0x19928
int64_t function_1990e(int64_t a1) {
    // 0x1990e
    return (bool)(a1 != 0);
}

// Address range: 0x19928 - 0x19948
int64_t function_19928(int64_t result) {
    // 0x19928
    *(int32_t *)(result + 160) = *(int32_t *)&g60;
    return result;
}

// Address range: 0x19948 - 0x19996
int64_t function_19948(int64_t result) {
    int32_t * v1 = (int32_t *)(result + 16); // 0x19958
    uint32_t fd = *v1; // 0x19958
    if (fd >= 0) {
        // 0x1995f
        close(fd);
        *v1 = -1;
    }
    // 0x19978
    function_2d70(*(int64_t *)(result + 8));
    *(int64_t *)result = 0;
    return result;
}

// Address range: 0x19996 - 0x19aac
int64_t function_19996(int64_t a1, int64_t a2, int64_t a3) {
    int32_t result = 0;
    int64_t v1 = a1 + (int64_t)&g87 + 168 * (int64_t)result; // 0x199d9
    while ((int32_t)function_1990e(v1) != 0) {
        int32_t v2 = *(int32_t *)(v1 + 160); // 0x199fd
        if (*(int32_t *)&g60 - v2 > (int32_t)&g1) {
            // 0x19a0e
            function_19948(v1);
            goto lab_0x19a2e;
        }
        int32_t v3 = result + 1; // 0x19a1c
        if (v3 >= 20) {
            // 0x19aaa
            return 0xffffffff;
        }
        result = v3;
        v1 = a1 + (int64_t)&g87 + 168 * (int64_t)result;
    }
    goto lab_0x19a2e;
  lab_0x19a2e:;
    int64_t * v4 = (int64_t *)v1; // 0x19a3f
    memset(v4, 0, 168);
    memcpy((int64_t *)(v1 + 24), (int64_t *)a2, (int32_t)function_198b7(a2));
    *(int32_t *)(v1 + 16) = -1;
    *(int16_t *)(v1 + 20) = (int16_t)&g36;
    int64_t v5; // 0x19996
    *(int16_t *)(v1 + 152) = *(int16_t *)&v5;
    *v4 = a1;
    function_19928(v1);
    // 0x19aaa
    return result;
}

// Address range: 0x19aac - 0x19b4e
int64_t function_19aac(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = 0;
    int64_t v2 = a1 + (int64_t)&g87 + 168 * v1; // 0x19aef
    int64_t result; // 0x19aac
    int64_t v3; // 0x19aac
    if ((int32_t)function_1990e(v2) != 0) {
        // 0x19b06
        if ((int32_t)function_197b3(v2 + 24, a2) != 0) {
            // 0x19b21
            if (*(int16_t *)(v2 + 152) == (int16_t)v3) {
                // 0x19b38
                result = v1 & 0xffffffff;
                return result;
            }
        }
    }
    int64_t v4 = v1 + 1;
    result = 0xffffffff;
    while (v4 < 20) {
        // 0x19ac9
        v1 = v4;
        v2 = a1 + (int64_t)&g87 + 168 * v1;
        if ((int32_t)function_1990e(v2) != 0) {
            // 0x19b06
            if ((int32_t)function_197b3(v2 + 24, a2) != 0) {
                // 0x19b21
                if (*(int16_t *)(v2 + 152) == (int16_t)v3) {
                    // 0x19b38
                    result = v1 & 0xffffffff;
                    return result;
                }
            }
        }
        // 0x19b3d
        v4 = v1 + 1;
        result = 0xffffffff;
    }
  lab_0x19b4c:
    // 0x19b4c
    return result;
}

// Address range: 0x19b4e - 0x19bfb
int64_t function_19b4e(int64_t a1, int32_t a2, int64_t buf, int64_t a4) {
    int32_t * fd = (int32_t *)(a1 + 16); // 0x19b6f
    int32_t v1 = *fd; // 0x19b6f
    int32_t v2 = v1; // 0x19b74
    if (v1 < 0) {
        // 0x19b76
        v2 = open64((char *)*(int64_t *)(a1 + 8), 0);
        *fd = v2;
    }
    // 0x19b99
    if (v2 < 0) {
        // 0x19bf9
        return 0xffffffff;
    }
    int32_t nbyte = a4; // 0x19bab
    int64_t result = 0; // 0x19baf
    if (nbyte != 0) {
        // 0x19bb1
        lseek64(v2, (int32_t)*(int16_t *)(a1 + 20) * a2, 0);
        result = read(*fd, (int64_t *)buf, nbyte);
    }
    // 0x19bf9
    return result;
}

// Address range: 0x19bfb - 0x19c9c
int64_t function_19bfb(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a2 + 48); // 0x19c19
    memset((int64_t *)*v1, 0, *(int32_t *)(a2 + 36));
    int64_t v2 = *v1; // 0x19c2e
    *v1 = v2 + 16;
    int64_t result = (*(int16_t *)(a1 + 24) != 10 ? 36 : 56) + v2;
    *v1 = result + 8;
    return result;
}

// Address range: 0x19c9c - 0x19d9e
int64_t function_19c9c(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = __readfsqword(40); // 0x19cb0
    int64_t v2; // bp-56, 0x19c9c
    int64_t v3; // bp-88, 0x19c9c
    if (*(int16_t *)(a1 + 24) != 10) {
        // 0x19d32
        function_1b11d(0, a2, &v3, &v2, 16);
    } else {
        // 0x19ccd
        function_1bf57(0, a2, &v3, &v2);
    }
    int64_t result = 0; // 0x19d95
    if (v1 != __readfsqword(40)) {
        // 0x19d97
        __stack_chk_fail();
        result = &g91;
    }
    // 0x19d9c
    return result;
}

// Address range: 0x19d9e - 0x19efe
int64_t function_19d9e(int64_t a1, int64_t * a2, int64_t * a3, uint32_t a4, int64_t a5) {
    int64_t v1 = function_a39a(a1); // 0x19dca
    if (v1 == 0) {
        // 0x19efc
        return 0xffffffff;
    }
    int64_t v2 = function_19bfb(a1, v1); // 0x19df2
    *(int16_t *)(v2 + 8) = htons(6);
    int32_t v3 = 2; // 0x19ecb
    if (a4 > 0) {
        int64_t v4 = v2 + 10; // 0x19e47
        int64_t v5 = 0;
        int32_t v6 = 0;
        int64_t v7 = *(int64_t *)(8 * v5 + (int64_t)a2); // 0x19e2f
        int32_t chars_printed = snprintf((char *)(v4 + (int64_t)v6), (int32_t)&g82 - v6, "%s", (char *)v7); // 0x19e64
        int32_t v8 = v6 + 1 + chars_printed; // 0x19e6c
        int32_t v9 = *(int32_t *)(4 * v5 + (int64_t)a3); // 0x19e83
        int32_t chars_printed2 = snprintf((char *)(v4 + (int64_t)v8), (int32_t)&g82 - v8, "%u", v9); // 0x19eb6
        int32_t v10 = v8 + 1 + chars_printed2; // 0x19ebe
        v5++;
        while (v5 != (int64_t)a4) {
            // 0x19e1b
            v6 = v10;
            v7 = *(int64_t *)(8 * v5 + (int64_t)a2);
            chars_printed = snprintf((char *)(v4 + (int64_t)v6), (int32_t)&g82 - v6, "%s", (char *)v7);
            v8 = v6 + 1 + chars_printed;
            v9 = *(int32_t *)(4 * v5 + (int64_t)a3);
            chars_printed2 = snprintf((char *)(v4 + (int64_t)v8), (int32_t)&g82 - v8, "%u", v9);
            v10 = v8 + 1 + chars_printed2;
            v5++;
        }
        // 0x19ec5
        v3 = v10 + 2;
    }
    // 0x19ed1
    *(int32_t *)(v1 + 56) = v3;
    function_19c9c(a1, v1, a5);
    // 0x19efc
    return 0;
}

// Address range: 0x19efe - 0x1a007
int64_t function_19efe(int64_t a1, int64_t host_short, char * str, int64_t a4) {
    int64_t v1 = a1; // 0x19f26
    if ((*(int32_t *)&g58 & 8) != 0) {
        // 0x19f28
        int64_t v2; // 0x19efe
        int64_t v3; // 0x19efe
        function_3080("Slirp", 128, "tftp error msg: %s", (int64_t)str, v3, v2);
        v1 = (int64_t)"Slirp";
    }
    int64_t v4 = function_a39a(v1); // 0x19f56
    if (v4 != 0) {
        int64_t v5 = function_19bfb(a1, v4); // 0x19f78
        *(int16_t *)(v5 + 8) = htons(5);
        *(int16_t *)(v5 + 10) = htons((int16_t)host_short);
        function_1c2cc(v5 + 12, (int64_t)&g81, (int64_t)str);
        *(int32_t *)(v4 + 56) = strlen(str) + 5;
        function_19c9c(a1, v4, a4);
    }
    // 0x19ff8
    return function_19948(a1);
}

// Address range: 0x1a007 - 0x1a151
int64_t function_1a007(int64_t result, int64_t a2) {
    int64_t v1 = function_a39a(result); // 0x1a021
    if (v1 == 0) {
        // 0x1a14f
        return 0;
    }
    int64_t v2 = function_19bfb(result, v1); // 0x1a043
    *(int16_t *)(v2 + 8) = htons(3);
    int32_t * v3 = (int32_t *)(result + 156); // 0x1a064
    *(int16_t *)(v2 + 10) = htons((int16_t)*v3 + 1);
    int16_t * v4 = (int16_t *)(result + 20); // 0x1a085
    int32_t v5 = function_19b4e(result, *v3, v2 + 12, (int64_t)*v4); // 0x1a0af
    if (v5 < 0) {
        // 0x1a0b8
        function_a4f0(v1);
        // 0x1a14f
        return function_19efe(result, 1, "File not found", v2);
    }
    // 0x1a0e5
    *(int32_t *)(v1 + 56) = v5 + 4;
    function_19c9c(result, v1, a2);
    if (v5 != (int32_t)*v4) {
        // 0x1a129
        function_19948(result);
    } else {
        // 0x1a11b
        function_19928(result);
    }
    // 0x1a135
    *v3 = *v3 + 1;
    // 0x1a14f
    return result;
}

// Address range: 0x1a151 - 0x1a8b4
int64_t function_1a151(int64_t a1, int64_t a2, int64_t a3, int32_t a4) {
    int64_t v1 = __readfsqword(40); // 0x1a177
    int64_t v2 = function_19aac(a1, a2, a3); // 0x1a1ab
    if ((int32_t)v2 >= 0) {
        // 0x1a1bf
        function_19948(a1 + (int64_t)&g87 + 168 * 0x100000000 * v2 / 0x100000000);
    }
    int64_t v3 = function_19996(a1, a2, a3); // 0x1a211
    int32_t v4; // 0x1a151
    int64_t v5; // 0x1a152
    int32_t v6; // 0x1a2ac
    int64_t * v7; // 0x1a2f1
    int64_t v8; // 0x1a151
    char * str2; // 0x1a351
    int64_t v9; // 0x1a151
    int32_t v10; // 0x1a3cc
    int64_t v11; // 0x1a255
    if ((int32_t)v3 >= 0) {
        // 0x1a229
        v11 = a1 + (int64_t)&g87 + 168 * 0x100000000 * v3 / 0x100000000;
        int64_t * v12 = (int64_t *)(a1 + (int64_t)&g86); // 0x1a266
        int64_t str = *v12; // 0x1a266
        if (str != 0) {
            // 0x1a29c
            int64_t v13; // bp-8, 0x1a151
            v5 = &v13;
            v6 = a4 - 10;
            int32_t len = strlen((char *)str); // 0x1a2c6
            int64_t v14 = len; // 0x1a2c6
            int64_t v15 = function_2d50(v14 + (int64_t)&g39); // 0x1a2e2
            v7 = (int64_t *)(v11 + 8);
            *v7 = v15;
            memcpy((int64_t *)v15, (int64_t *)*v12, len);
            *(char *)(*v7 + v14) = 47;
            v8 = *v7 + v14;
            int64_t v16 = v8 + 1; // 0x1a34e
            str2 = (char *)v16;
            v9 = a3 + 10;
            v4 = 0;
            while (v4 <= (int32_t)&g34 == v4 < v6) {
                int64_t v17 = v4; // 0x1a3a2
                char v18 = *(char *)(v9 + v17); // 0x1a3bf
                *(char *)(v16 + v17) = v18;
                v10 = v4 + 1;
                if (v18 == 0) {
                    // 0x1a3ee
                    if ((*(int32_t *)&g58 & 8) == 0) {
                        goto lab_0x1a426;
                    } else {
                        // 0x1a3ff
                        int64_t v19; // 0x1a151
                        int64_t v20; // 0x1a151
                        function_3080("Slirp", 128, "tftp rrq file: %s", v16, v20, v19);
                        goto lab_0x1a426;
                    }
                }
                v4 = v10;
            }
            // 0x1a372
            function_19efe(v11, 2, "Access violation", a3);
        } else {
            // 0x1a272
            function_19efe(v11, 2, "Access violation", a3);
        }
    }
    goto lab_0x1a89e;
  lab_0x1a89e:;
    int64_t result = 0; // 0x1a8ab
    if (v1 != __readfsqword(40)) {
        // 0x1a8ad
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1a8b2
    return result;
  lab_0x1a426:;
    int64_t v21; // 0x1a151
    int32_t v22; // 0x1a151
    int64_t v23; // 0x1a151
    int64_t v24; // 0x1a151
    int64_t v25; // 0x1a151
    int16_t * v26; // 0x1a151
    if (v6 - v10 > 5) {
        // 0x1a461
        if (strcasecmp((char *)(v9 + (int64_t)v10), "octet") == 0) {
            // 0x1a4b5
            if (strncmp(str2, "../", 3) == 0) {
                // 0x1a51a
                function_19efe(v11, 2, "Access violation", a3);
                goto lab_0x1a89e;
            } else {
                // 0x1a4db
                if (*(char *)(v8 + (int64_t)strlen(str2)) == 47) {
                    // 0x1a51a
                    function_19efe(v11, 2, "Access violation", a3);
                    goto lab_0x1a89e;
                } else {
                    // 0x1a4ff
                    if (strstr(str2, "/../") == NULL) {
                        // 0x1a544
                        if ((int32_t)function_19b4e(v11, 0, 0, 0) >= 0) {
                            // 0x1a590
                            if (*(char *)(v9 + (int64_t)(a4 - 11)) == 0) {
                                int32_t v27 = v4 + 7; // 0x1a4b5
                                if (v27 < v6) {
                                    // 0x1a5d9
                                    int64_t v28; // bp-168, 0x1a151
                                    v23 = &v28;
                                    v24 = v5 - 176;
                                    v25 = v5 - 184;
                                    v26 = (int16_t *)(v11 + 20);
                                    v21 = 0;
                                    v22 = v27;
                                    goto lab_0x1a5d9_2;
                                } else {
                                    // 0x1a871
                                    *(int32_t *)(v11 + 156) = 0;
                                    function_1a007(v11, a3);
                                    goto lab_0x1a89e;
                                }
                            } else {
                                // 0x1a5af
                                function_19efe(v11, 2, "Access violation", a3);
                                goto lab_0x1a89e;
                            }
                        } else {
                            // 0x1a566
                            function_19efe(v11, 1, "File not found", a3);
                            goto lab_0x1a89e;
                        }
                    } else {
                        // 0x1a51a
                        function_19efe(v11, 2, "Access violation", a3);
                        goto lab_0x1a89e;
                    }
                }
            }
        } else {
            // 0x1a48b
            function_19efe(v11, 4, "Unsupported transfer mode", a3);
            goto lab_0x1a89e;
        }
    } else {
        // 0x1a437
        function_19efe(v11, 2, "Access violation", a3);
        goto lab_0x1a89e;
    }
  lab_0x1a5d9_2:;
    int64_t v29 = v21;
    int32_t v30 = v22; // 0x1a151
    goto lab_0x1a5d9_3;
  lab_0x1a5d9_3:;
    char * str3 = (char *)(v9 + (int64_t)v30); // 0x1a5f0
    int32_t v31 = v30 + 1 + strlen(str3); // 0x1a610
    int32_t v32; // 0x1a688
    int32_t str_as_i2; // 0x1a6b9
    if (v31 < v6) {
        char * str4 = (char *)(v9 + (int64_t)v31);
        v32 = v31 + 1 + strlen(str4);
        if (strcasecmp(str3, "tsize") != 0) {
            // 0x1a75c
            if (strcasecmp(str3, "blksize") != 0) {
                goto lab_0x1a7f2_2;
            } else {
                int32_t str_as_i = atoi(str4); // 0x1a780
                if (str_as_i < 1) {
                    goto lab_0x1a7f2_2;
                } else {
                    int32_t v33 = str_as_i - (int32_t)&g81; // 0x1a799
                    int16_t v34 = v33 == 0 | v33 < 0 != ((v33 ^ str_as_i) & (str_as_i ^ (int32_t)&g81)) < 0 ? (int16_t)str_as_i : (int16_t)&g81; // 0x1a7b3
                    *v26 = v34;
                    *(int64_t *)(8 * v29 + v24) = (int64_t)"blksize";
                    *(int32_t *)(4 * v29 + v25) = (int32_t)*v26;
                    goto lab_0x1a7f2_3;
                }
            }
        } else {
            // 0x1a6af
            str_as_i2 = atoi(str4);
            if (str_as_i2 != 0) {
                goto lab_0x1a724;
            } else {
                // 0x1a6cd
                if ((int32_t)function_1d0d0((char *)*v7, v23) != 0) {
                    // 0x1a6fa
                    function_19efe(v11, 1, "File not found", a3);
                    goto lab_0x1a89e;
                } else {
                    goto lab_0x1a724;
                }
            }
        }
    } else {
        // 0x1a627
        function_19efe(v11, 2, "Access violation", a3);
        goto lab_0x1a89e;
    }
  lab_0x1a7f2_2:
    // 0x1a7f2
    v30 = v32;
    int64_t v35 = v29; // 0x1a7fe
    if (v32 < v6) {
        goto lab_0x1a5d9_3;
    } else {
        goto lab_0x1a80f;
    }
  lab_0x1a724:
    // 0x1a724
    *(int64_t *)(8 * v29 + v24) = (int64_t)"tsize";
    *(int32_t *)(4 * v29 + v25) = str_as_i2;
    goto lab_0x1a7f2_3;
  lab_0x1a80f:;
    int32_t v37 = v35;
    if (v37 < 1) {
        // 0x1a871
        *(int32_t *)(v11 + 156) = 0;
        function_1a007(v11, a3);
        goto lab_0x1a89e;
    } else {
        // 0x1a842
        int64_t v38; // bp-184, 0x1a151
        int64_t v39; // bp-192, 0x1a151
        function_19d9e(v11, &v38, &v39, v37, a3);
        goto lab_0x1a89e;
    }
  lab_0x1a7f2_3:;
    int64_t v36 = v29 + 1;
    v21 = v36;
    v22 = v32;
    v35 = v36;
    if (v36 < 2 == v32 < v6) {
        goto lab_0x1a5d9_2;
    } else {
        goto lab_0x1a80f;
    }
}

// Address range: 0x1a8b4 - 0x1a928
int64_t function_1a8b4(int64_t a1, int64_t a2, int64_t a3, int32_t a4) {
    int64_t v1 = function_19aac(a1, a2, a3); // 0x1a8dd
    int64_t result = v1; // 0x1a8e9
    if ((int32_t)v1 >= 0) {
        // 0x1a8eb
        result = function_1a007(a1 + (int64_t)&g87 + 168 * 0x100000000 * v1 / 0x100000000, a3);
    }
    // 0x1a926
    return result;
}

// Address range: 0x1a928 - 0x1a995
int64_t function_1a928(int64_t a1, int64_t a2, int64_t a3, int32_t a4) {
    int64_t v1 = function_19aac(a1, a2, a3); // 0x1a951
    int64_t result = v1; // 0x1a95d
    if ((int32_t)v1 >= 0) {
        // 0x1a95f
        result = function_19948(a1 + (int64_t)&g87 + 168 * 0x100000000 * v1 / 0x100000000);
    }
    // 0x1a993
    return result;
}

// Address range: 0x1a995 - 0x1aa3c
int64_t function_1a995(int16_t * a1, int64_t a2) {
    int64_t v1 = *(int64_t *)(a2 + 48); // 0x1a9a9
    uint16_t v2 = ntohs(*(int16_t *)(v1 + 8)); // 0x1a9be
    int64_t result = v2; // 0x1a995
    switch (v2) {
        case 4: {
            int64_t v3 = *(int64_t *)(a2 + 64); // 0x1aa03
            result = function_1a8b4(v3, (int64_t)a1, v1, *(int32_t *)(a2 + 56));
            // break -> 0x1aa39
            break;
        }
        case 5: {
            int64_t v4 = *(int64_t *)(a2 + 64); // 0x1aa24
            result = function_1a928(v4, (int64_t)a1, v1, *(int32_t *)(a2 + 56));
            // break -> 0x1aa39
            break;
        }
        case 1: {
            int64_t v5 = *(int64_t *)(a2 + 64); // 0x1a9e2
            result = function_1a151(v5, (int64_t)a1, v1, *(int32_t *)(a2 + 56));
            // break -> 0x1aa39
            break;
        }
    }
    // 0x1aa39
    return result;
}

// Address range: 0x1aa3c - 0x1aa94
int64_t function_1aa3c(int64_t sock) {
    int64_t v1 = __readfsqword(40); // 0x1aa47
    int32_t option_value = 1; // bp-20, 0x1aa56
    int32_t v2 = setsockopt((int32_t)sock, SO_DEBUG, 2, (int64_t *)&option_value, 4); // 0x1aa79
    int64_t result = v2; // 0x1aa8b
    if (v1 != __readfsqword(40)) {
        // 0x1aa8d
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1aa92
    return result;
}

// Address range: 0x1aa94 - 0x1aae1
int64_t function_1aa94(int64_t result) {
    int64_t v1 = result + (int64_t)&g71; // 0x1aaa0
    *(int64_t *)(result + (int64_t)&g72) = v1;
    *(int64_t *)v1 = v1;
    *(int64_t *)(result + (int64_t)&g78) = v1;
    return result;
}

// Address range: 0x1aae1 - 0x1ab20
int64_t function_1aae1(int64_t a1) {
    int64_t v1 = a1 + (int64_t)&g71; // 0x1ab06
    int64_t * v2 = (int64_t *)v1; // 0x1ab06
    int64_t result = *v2; // 0x1ab06
    if (result == v1) {
        // 0x1ab1d
        return result;
    }
    function_1b3c9(result);
    int64_t result2 = *v2; // 0x1ab06
    while (result2 != v1) {
        // 0x1aaef
        function_1b3c9(result2);
        result2 = *v2;
    }
    // 0x1ab1d
    return result2;
}

// Address range: 0x1ab20 - 0x1b11d
int64_t function_1ab20(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 / 0x100000000; // 0x1ab33
    int64_t v2 = __readfsqword(40); // 0x1ab39
    int64_t v3 = *(int64_t *)(a1 + 64); // 0x1ab48
    int64_t v4; // 0x1ab20
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1ab80
        int64_t v5; // 0x1ab20
        int64_t v6; // 0x1ab20
        function_3080("Slirp", 128, "udp_input...", v6, v5, v4);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x1abb0
            function_3080("Slirp", 128, " m = %p", a1, v5, v4);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x1abc0
                function_3080("Slirp", 128, " iphlen = %d", v1 & 0xffffffff, v5, v4);
            }
        }
    }
    int64_t v7 = v1; // 0x1abee
    if ((int32_t)v1 >= 21) {
        // 0x1abf0
        function_9e0e(a1, 0);
        v7 = 20;
    }
    int64_t * v8 = (int64_t *)(a1 + 48); // 0x1ac07
    int64_t v9 = *v8; // 0x1ac07
    int64_t v10 = v9 + v7; // 0x1ac13
    int16_t * net_short = (int16_t *)(v10 + 4); // 0x1ac17
    uint16_t v11 = ntohs(*net_short); // 0x1ac21
    int32_t v12 = v11; // 0x1ac29
    int16_t * v13 = (int16_t *)(v9 + 2); // 0x1ac2f
    uint16_t v14 = *v13; // 0x1ac2f
    if (v11 == v14) {
        goto lab_0x1ac7e;
    } else {
        if (v11 > v14) {
            // 0x1b0f3
            function_a4f0(a1);
            goto lab_0x1b0fb;
        } else {
            // 0x1ac55
            function_a875(a1, (int64_t)(v12 - (int32_t)v14));
            *v13 = v11;
            goto lab_0x1ac7e;
        }
    }
  lab_0x1ac7e:;
    int64_t * v15 = (int64_t *)v9; // 0x1ac7e
    int64_t v16 = *v15; // 0x1ac7e
    int64_t v17 = v9 + 8; // 0x1ac82
    int64_t * v18 = (int64_t *)v17; // 0x1ac82
    int64_t v19 = *v18; // 0x1ac82
    int32_t * v20 = (int32_t *)(v9 + 16); // 0x1ac95
    int32_t v21 = *v20; // 0x1ac95
    if (*(int16_t *)(v10 + 6) == 0) {
        goto lab_0x1ad01;
    } else {
        // 0x1acc0
        memset(v15, 0, 8);
        *(char *)v17 = 0;
        *(int16_t *)(v9 + 10) = *net_short;
        if ((int32_t)function_44c3(a1, (int64_t)(v12 + 20)) != 0) {
            // 0x1b0f3
            function_a4f0(a1);
            goto lab_0x1b0fb;
        } else {
            goto lab_0x1ad01;
        }
    }
  lab_0x1ad01:;
    int16_t v22 = 2; // bp-184, 0x1ad01
    int64_t v23 = &v22; // 0x1ad11
    int32_t * v24 = (int32_t *)(v9 + 12); // 0x1ad1f
    *(int32_t *)(v23 + 4) = *v24;
    int16_t * v25 = (int16_t *)v10; // 0x1ad27
    *(int16_t *)(v23 + 2) = *v25;
    int16_t * net_short2 = (int16_t *)(v10 + 2); // 0x1ad37
    if (ntohs(*net_short2) != 67) {
        goto lab_0x1ad76;
    } else {
        int32_t v26 = *v20; // 0x1ad4c
        if (v26 != *(int32_t *)(v3 + 20) == (v26 != -1)) {
            goto lab_0x1ad76;
        } else {
            // 0x1ad69
            function_4485(a1);
            // 0x1b0f3
            function_a4f0(a1);
            goto lab_0x1b0fb;
        }
    }
  lab_0x1ad76:
    // 0x1ad76
    if (ntohs(*net_short2) != 69) {
        goto lab_0x1adf9;
    } else {
        // 0x1ad8b
        if (*v20 != *(int32_t *)(v3 + 20)) {
            goto lab_0x1adf9;
        } else {
            // 0x1ad9e
            *v8 = *v8 + v7;
            int32_t * v27 = (int32_t *)(a1 + 56); // 0x1adb1
            int32_t v28 = v7; // 0x1adb4
            *v27 = *v27 - v28;
            function_1a995(&v22, a1);
            *v8 = *v8 - v7;
            *v27 = *v27 + v28;
            // 0x1b0f3
            function_a4f0(a1);
            goto lab_0x1b0fb;
        }
    }
  lab_0x1b0fb:;
    int64_t result = 0; // 0x1b108
    if (v2 != __readfsqword(40)) {
        // 0x1b10a
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1b10f
    return result;
  lab_0x1adf9:;
    // 0x1adf9
    int64_t v29; // 0x1ab20
    if (*(int32_t *)(v3 + 124) != 0) {
        // 0x1b0f3
        function_a4f0(a1);
        goto lab_0x1b0fb;
    } else {
        int64_t v30 = function_f5a7(v3 + (int64_t)&g78, v3 + (int64_t)&g71, &v22, NULL); // 0x1ae36
        v29 = v30;
        if (v30 != 0) {
            goto lab_0x1af55;
        } else {
            int64_t v31 = function_f694(v3); // 0x1ae5a
            if ((int32_t)function_1b34d(v31, 2) != -1) {
                // 0x1aedd
                *(int16_t *)(v31 + 200) = 2;
                *(int32_t *)(v31 + 204) = *v24;
                *(int16_t *)(v31 + 202) = *v25;
                char v32 = function_1b422(v31); // 0x1af2a
                char * v33 = (char *)(v31 + 328); // 0x1af2a
                *v33 = v32;
                v29 = v31;
                if (v32 == 0) {
                    // 0x1af42
                    *v33 = *(char *)(v9 + 1);
                    v29 = v31;
                }
                goto lab_0x1af55;
            } else {
                // 0x1ae7f
                if ((*(int32_t *)&g58 & 2) != 0) {
                    char * err_str = strerror(*__errno_location()); // 0x1ae98
                    uint32_t v34 = *__errno_location(); // 0x1aea5
                    function_3080("Slirp", 128, " udp_attach errno = %d-%s", (int64_t)v34, (int64_t)err_str, v4);
                }
                // 0x1aec9
                function_f77a(v31);
                // 0x1b0f3
                function_a4f0(a1);
                goto lab_0x1b0fb;
            }
        }
    }
  lab_0x1af55:
    // 0x1af55
    *(int16_t *)(v29 + 72) = 2;
    *(int32_t *)(v29 + 76) = *v20;
    *(int16_t *)(v29 + 74) = *net_short2;
    int32_t v35 = (int32_t)v7 + 8; // 0x1af87
    int64_t v36 = v35; // 0x1af8a
    int32_t * v37 = (int32_t *)(a1 + 56); // 0x1af90
    *v37 = *v37 - v35;
    *v8 = *v8 + v36;
    if ((int32_t)function_11417(v29, a1) != -1) {
        int64_t * v38 = (int64_t *)(v29 + 48); // 0x1b08c
        function_a4f0(*v38);
        *v37 = *v37 + v35;
        *v8 = *v8 - v36;
        *v15 = v16;
        *v18 = v19;
        *v20 = v21;
        *v38 = a1;
        goto lab_0x1b0fb;
    } else {
        // 0x1afca
        *v37 = *v37 + v35;
        *v8 = *v8 - v36;
        *v15 = v16;
        *v18 = v19;
        *v20 = v21;
        if ((*(int32_t *)&g58 & 2) != 0) {
            char * err_str2 = strerror(*__errno_location()); // 0x1b02a
            uint32_t v39 = *__errno_location(); // 0x1b037
            function_3080("Slirp", 128, "udp tx errno = %d-%s", (int64_t)v39, (int64_t)err_str2, v4);
        }
        int32_t err_num = *__errno_location(); // 0x1b060
        function_8b39(a1, 3, 0, 0, (int64_t)strerror(err_num));
        // 0x1b0f3
        function_a4f0(a1);
        goto lab_0x1b0fb;
    }
}

// Address range: 0x1b11d - 0x1b34d
int64_t function_1b11d(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t a5) {
    struct in_addr in; // 0x1b1ef
    struct in_addr in2; // 0x1b22d
    int64_t v1 = (int64_t)a4;
    int64_t v2 = (int64_t)a3;
    int32_t * v3; // 0x1b11d
    int32_t * v4; // 0x1b11d
    if (*(int32_t *)&g58 % 2 == 0) {
        // 0x1b214
        v4 = (int32_t *)(v2 + 4);
        v3 = (int32_t *)(v1 + 4);
        goto lab_0x1b252;
    } else {
        // 0x1b16e
        int64_t v5; // 0x1b11d
        function_3080("Slirp", 128, "udp_output...", v1, a5, v5);
        if (*(int32_t *)&g58 % 2 == 0) {
            // 0x1b214
            v4 = (int32_t *)(v2 + 4);
            v3 = (int32_t *)(v1 + 4);
            goto lab_0x1b252;
        } else {
            // 0x1b1a2
            function_3080("Slirp", 128, " so = %p", a1, a5, v5);
            if (*(int32_t *)&g58 % 2 == 0) {
                // 0x1b214
                v4 = (int32_t *)(v2 + 4);
                v3 = (int32_t *)(v1 + 4);
                goto lab_0x1b252;
            } else {
                // 0x1b1d6
                function_3080("Slirp", 128, " m = %p", a2, a5, v5);
                if (*(int32_t *)&g58 % 2 == 0) {
                    // 0x1b214
                    v4 = (int32_t *)(v2 + 4);
                    v3 = (int32_t *)(v1 + 4);
                    goto lab_0x1b252;
                } else {
                    int32_t * v6 = (int32_t *)(v2 + 4);

                    in.s_addr = *v6;
                    function_3080("Slirp", 128, " saddr = %s", (int64_t)inet_ntoa(in), a5, v5);
                    if (*(int32_t *)&g58 % 2 == 0) {
                        // 0x1b214
                        v4 = (int32_t *)(v2 + 4);
                        v3 = (int32_t *)(v1 + 4);
                        goto lab_0x1b252;
                    } else {
                        int32_t * v7 = (int32_t *)(v1 + 4);

                        in2.s_addr = *v7;
                        function_3080("Slirp", 128, " daddr = %s", (int64_t)inet_ntoa(in2), a5, v5);
                        v4 = v6;
                        v3 = v7;
                        goto lab_0x1b252;
                    }
                }
            }
        }
    }
  lab_0x1b252:;
    int64_t * v8 = (int64_t *)(a2 + 48); // 0x1b256
    *v8 = *v8 - 28;
    int32_t * v9 = (int32_t *)(a2 + 56); // 0x1b26a
    *v9 = *v9 + 28;
    int64_t v10 = *v8; // 0x1b27d
    memset((int64_t *)v10, 0, 8);
    char * v11 = (char *)(v10 + 8); // 0x1b296
    *v11 = 0;
    *(char *)(v10 + 9) = 17;
    int16_t v12 = htons((int16_t)*v9 - 20); // 0x1b2ad
    int16_t * v13 = (int16_t *)(v10 + 10); // 0x1b2b2
    *v13 = v12;
    *(int32_t *)(v10 + 12) = *v4;
    *(int32_t *)(v10 + 16) = *v3;
    *(int16_t *)(v10 + 20) = *(int16_t *)(v2 + 2);
    *(int16_t *)(v10 + 22) = *(int16_t *)(v1 + 2);
    *(int16_t *)(v10 + 24) = *v13;
    int16_t * v14 = (int16_t *)(v10 + 26); // 0x1b2ea
    *v14 = 0;
    int16_t v15 = function_44c3(a2, (int64_t)*v9); // 0x1b305
    *v14 = v15 != 0 ? v15 : -1;
    *(int16_t *)(v10 + 2) = (int16_t)*v9;
    *v11 = 64;
    *(char *)(v10 + 1) = (char)a5;
    return function_9e96(a1, a2) & 0xffffffff;
}

// Address range: 0x1b34d - 0x1b3c9
int64_t function_1b34d(int64_t a1, uint64_t a2) {
    int32_t v1 = function_1c25e(a2 % 0x10000, 2, 0); // 0x1b374
    int32_t * v2 = (int32_t *)(a1 + 16); // 0x1b37a
    *v2 = v1;
    int64_t result = 0xffffffff; // 0x1b387
    if (v1 != -1) {
        // 0x1b389
        *(int32_t *)(a1 + 344) = *(int32_t *)&g60 + 0x3a980;
        function_ab4c(a1, *(int64_t *)(a1 + 40) + (int64_t)&g71);
        result = (int64_t)*v2;
    }
    // 0x1b3c0
    return result;
}

// Address range: 0x1b3c9 - 0x1b422
int64_t function_1b3c9(int64_t a1) {
    // 0x1b3c9
    close(*(int32_t *)(a1 + 16));
    return function_f77a(a1);
}

// Address range: 0x1b422 - 0x1b58f
int64_t function_1b422(int64_t a1) {
    int32_t v1 = 0; // 0x1b55c
    int64_t v2 = 0;
    int16_t * v3 = (int16_t *)(v2 + (int64_t)&g29); // 0x1b456
    if (*v3 != 0) {
        // 0x1b45f
        if (ntohs(*(int16_t *)(a1 + 74)) == *v3) {
            // break -> 0x1b4fd
            return 0;
        }
    }
    int16_t * v4 = (int16_t *)(v2 + (int64_t)&g28); // 0x1b4b4
    if (*v4 != 0) {
        // 0x1b4c1
        if (ntohs(*(int16_t *)(a1 + 202)) == *v4) {
            // break -> 0x1b4fd
            return 0;
        }
    }
    // 0x1b55c
    v1++;
    int64_t v5 = 6 * (int64_t)v1; // 0x1b56f
    while (*(char *)(v5 + (int64_t)&g30) != 0) {
        // 0x1b43a
        v3 = (int16_t *)(v5 + (int64_t)&g29);
        if (*v3 != 0) {
            // 0x1b45f
            if (ntohs(*(int16_t *)(a1 + 74)) == *v3) {
                // break -> 0x1b4fd
                break;
            }
        }
        // 0x1b498
        v4 = (int16_t *)(v5 + (int64_t)&g28);
        if (*v4 != 0) {
            // 0x1b4c1
            if (ntohs(*(int16_t *)(a1 + 202)) == *v4) {
                // break -> 0x1b4fd
                break;
            }
        }
        // 0x1b55c
        v1++;
        v5 = 6 * (int64_t)v1;
    }
    // 0x1b58d
    return 0;
}

// Address range: 0x1b58f - 0x1b761
int64_t function_1b58f(int64_t a1, int32_t a2, int64_t a3, int64_t a4, int64_t a5, char * a6) {
    int64_t v1 = __readfsqword(40); // 0x1b5ac
    int32_t addr_len = 16; // bp-52, 0x1b5bb
    int64_t v2 = function_f694(a1); // 0x1b5c9
    int32_t v3 = function_1c25e(2, 2, 0); // 0x1b5e6
    int32_t * sock = (int32_t *)(v2 + 16); // 0x1b5ec
    *sock = v3;
    int64_t v4; // 0x1b58f
    if (v3 >= 0) {
        int32_t * v5 = (int32_t *)(v2 + 344); // 0x1b623
        *v5 = *(int32_t *)&g60 + 0x3a980;
        function_ab4c(v2, a1 + (int64_t)&g71);
        int16_t addr = 2; // bp-40, 0x1b643
        if (bind(*sock, (struct sockaddr *)&addr, addr_len) >= 0) {
            // 0x1b688
            function_1aa3c((int64_t)*sock);
            getsockname(*sock, (struct sockaddr *)&addr, &addr_len);
            *(int64_t *)(v2 + 72) = (int64_t)addr;
            function_11fe2(v2);
            *(int16_t *)(v2 + 200) = 2;
            *(int16_t *)(v2 + 202) = (int16_t)a5;
            *(int32_t *)(v2 + 204) = (int32_t)a4;
            int32_t v6 = (int64_t)a6; // 0x1b6f9
            if (v6 != (int32_t)&g36) {
                // 0x1b702
                *v5 = 0;
            }
            int32_t * v7 = (int32_t *)(v2 + 332); // 0x1b714
            *v7 = *v7 & 0xf000 | v6 | 4;
            v4 = v2;
        } else {
            // 0x1b672
            function_1b3c9(v2);
            v4 = 0;
        }
    } else {
        // 0x1b5fa
        function_f77a(v2);
        v4 = 0;
    }
    int64_t result = v4; // 0x1b758
    if (v1 != __readfsqword(40)) {
        // 0x1b75a
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1b75f
    return result;
}

// Address range: 0x1b761 - 0x1b790
int64_t function_1b761(int64_t str, int64_t str2) {
    int32_t memcmp_rc = memcmp((int64_t *)str, (int64_t *)str2, 16); // 0x1b784
    return (int64_t)(memcmp_rc & -256) | (int64_t)(memcmp_rc == 0);
}

// Address range: 0x1b790 - 0x1bf57
int64_t function_1b790(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x1b7a3
    int64_t v2 = *(int64_t *)(a1 + 64); // 0x1b7b9
    int64_t v3; // 0x1b790
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1b7fb
        int64_t v4; // 0x1b790
        int64_t v5; // 0x1b790
        function_3080("Slirp", 128, "udp6_input...", v5, v4, v3);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x1b80b
            function_3080("Slirp", 128, " m = %p", a1, v4, v3);
        }
    }
    // 0x1b832
    int32_t * v6; // 0x1b85a
    int64_t v7; // 0x1b876
    int64_t v8; // 0x1b882
    int64_t * v9; // 0x1b84b
    int64_t v10; // 0x1b84b
    if (*(int32_t *)(v2 + 124) != 0) {
        // 0x1bf2a
        function_a4f0(a1);
        goto lab_0x1bf39;
    } else {
        // 0x1b844
        v9 = (int64_t *)(a1 + 48);
        v10 = *v9;
        v6 = (int32_t *)(a1 + 56);
        *v6 = *v6 - 40;
        v7 = *v9;
        v8 = v7 + 40;
        *v9 = v8;
        *v6 = *v6 + 40;
        *v9 = *v9 - 40;
        if ((int32_t)function_4820(a1) != 0) {
            // 0x1bf2a
            function_a4f0(a1);
            goto lab_0x1bf39;
        } else {
            int16_t host_short = ntohs(*(int16_t *)(v7 + 44)); // 0x1b904
            int16_t * net_short = (int16_t *)(v10 + 4); // 0x1b916
            if (host_short == ntohs(*net_short)) {
                goto lab_0x1b998;
            } else {
                int64_t v11 = host_short; // 0x1b94a
                if (v11 > (int64_t)ntohs(*net_short)) {
                    // 0x1bf2a
                    function_a4f0(a1);
                    goto lab_0x1bf39;
                } else {
                    // 0x1b950
                    function_a875(a1, v11 - (int64_t)ntohs(*net_short) & 0xffffffff);
                    *net_short = htons(host_short);
                    goto lab_0x1b998;
                }
            }
        }
    }
  lab_0x1bf39:;
    int64_t result = 0; // 0x1bf46
    if (v1 != __readfsqword(40)) {
        // 0x1bf48
        __stack_chk_fail();
        result = &g91;
    }
    // 0x1bf4d
    return result;
  lab_0x1b998:;
    int64_t * v12 = (int64_t *)v10; // 0x1b99c
    int64_t v13 = *v12; // 0x1b99c
    int64_t * v14 = (int64_t *)(v10 + 8); // 0x1b99f
    int64_t v15 = *v14; // 0x1b99f
    int64_t * v16 = (int64_t *)(v10 + 16); // 0x1b9ab
    int64_t v17 = *v16; // 0x1b9ab
    int64_t v18 = v10 + 24; // 0x1b9af
    int64_t * str = (int64_t *)v18; // 0x1b9af
    int64_t v19 = *str; // 0x1b9af
    int64_t * v20 = (int64_t *)(v10 + 32); // 0x1b9bb
    int64_t v21 = *v20; // 0x1b9bb
    int16_t v22 = 10; // bp-104, 0x1b9c3
    int16_t * net_short2 = (int16_t *)(v7 + 42); // 0x1b9ec
    if (ntohs(*net_short2) != (int16_t)&g45) {
        goto lab_0x1bb1e;
    } else {
        // 0x1ba04
        if ((char)function_1b761(v18, v2 + 44) != 0) {
            goto lab_0x1ba85;
        } else {
            char v23 = -1; // bp-120, 0x1ba26
            if ((char)function_1b761(v18, (int64_t)&v23) == 0) {
                goto lab_0x1bb1e;
            } else {
                goto lab_0x1ba85;
            }
        }
    }
  lab_0x1bb1e:
    // 0x1bb1e
    if (ntohs(*net_short2) != 69) {
        goto lab_0x1bbfe;
    } else {
        // 0x1bb3a
        if (memcmp(str, (int64_t *)(v2 + 44), 16) != 0) {
            goto lab_0x1bbfe;
        } else {
            // 0x1bb65
            *v9 = *v9 + 40;
            *v6 = *v6 - 40;
            function_1a995(&v22, a1);
            *v9 = *v9 - 40;
            *v6 = *v6 + 40;
            // 0x1bf2a
            function_a4f0(a1);
            goto lab_0x1bf39;
        }
    }
  lab_0x1bbfe:;
    int64_t v24 = function_f5a7(v2 + (int64_t)&g78, v2 + (int64_t)&g71, &v22, NULL); // 0x1bc26
    int64_t v25 = v24; // 0x1bc3a
    if (v24 != 0) {
        goto lab_0x1bd13;
    } else {
        int64_t v26 = function_f694(v2); // 0x1bc4a
        if ((int32_t)function_1b34d(v26, 10) != -1) {
            // 0x1bccd
            *(int16_t *)(v26 + 200) = 10;
            *(int64_t *)(v26 + 208) = *v14;
            *(int64_t *)(v26 + 216) = *v16;
            *(int16_t *)(v26 + 202) = *(int16_t *)v8;
            v25 = v26;
            goto lab_0x1bd13;
        } else {
            // 0x1bc6f
            if ((*(int32_t *)&g58 & 2) != 0) {
                char * err_str = strerror(*__errno_location()); // 0x1bc88
                uint32_t v27 = *__errno_location(); // 0x1bc95
                function_3080("Slirp", 128, " udp6_attach errno = %d-%s", (int64_t)v27, (int64_t)err_str, v3);
            }
            // 0x1bcb9
            function_f77a(v26);
            // 0x1bf2a
            function_a4f0(a1);
            goto lab_0x1bf39;
        }
    }
  lab_0x1ba85:
    // 0x1ba85
    *v9 = *v9 + 40;
    *v6 = *v6 - 40;
    function_5152(&v22, a1);
    *v9 = *v9 - 40;
    *v6 = *v6 + 40;
    // 0x1bf2a
    function_a4f0(a1);
    goto lab_0x1bf39;
  lab_0x1bd13:
    // 0x1bd13
    *(int16_t *)(v25 + 72) = 10;
    *(int64_t *)(v25 + 80) = *str;
    *(int64_t *)(v25 + 88) = *v20;
    *(int16_t *)(v25 + 74) = *net_short2;
    *v6 = *v6 - 48;
    *v9 = *v9 + 48;
    if ((int32_t)function_11417(v25, a1) != -1) {
        int64_t * v28 = (int64_t *)(v25 + 48); // 0x1be97
        function_a4f0(*v28);
        *v6 = *v6 + 48;
        *v9 = *v9 - 48;
        *v12 = v13;
        *v14 = v15;
        *v16 = v17;
        *str = v19;
        *v20 = v21;
        *v28 = a1;
        goto lab_0x1bf39;
    } else {
        // 0x1bdbc
        *v6 = *v6 + 48;
        *v9 = *v9 - 48;
        *v12 = v13;
        *v14 = v15;
        *v16 = v17;
        *str = v19;
        *v20 = v21;
        if ((*(int32_t *)&g58 & 2) != 0) {
            char * err_str2 = strerror(*__errno_location()); // 0x1be41
            uint32_t v29 = *__errno_location(); // 0x1be4e
            function_3080("Slirp", 128, "udp tx errno = %d-%s", (int64_t)v29, (int64_t)err_str2, v3);
        }
        // 0x1be72
        function_6903(a1, 1, 0);
        // 0x1bf2a
        function_a4f0(a1);
        goto lab_0x1bf39;
    }
}

// Address range: 0x1bf57 - 0x1c142
int64_t function_1bf57(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4) {
    int64_t v1 = (int64_t)a4;
    if (*(int32_t *)&g58 % 2 != 0) {
        // 0x1bf9c
        int64_t v2; // 0x1bf57
        int64_t v3; // 0x1bf57
        function_3080("Slirp", 128, "udp6_output...", v1, v3, v2);
        if (*(int32_t *)&g58 % 2 != 0) {
            // 0x1bfd0
            function_3080("Slirp", 128, " so = %p", a1, v3, v2);
            if (*(int32_t *)&g58 % 2 != 0) {
                // 0x1bfe0
                function_3080("Slirp", 128, " m = %p", a2, v3, v2);
            }
        }
    }
    int64_t v4 = (int64_t)a3;
    int64_t * v5 = (int64_t *)(a2 + 48); // 0x1c008
    *v5 = *v5 - 8;
    int32_t * v6 = (int32_t *)(a2 + 56); // 0x1c01c
    *v6 = *v6 + 8;
    int64_t v7 = *v5;
    *v5 = v7 - 40;
    int32_t v8 = *v6 + 40; // 0x1c052
    *v6 = v8;
    int64_t v9 = *v5; // 0x1c062
    int16_t v10 = htons((int16_t)v8 - 40); // 0x1c079
    int16_t * v11 = (int16_t *)(v9 + 4); // 0x1c084
    *v11 = v10;
    *(char *)(v9 + 6) = 17;
    *(int64_t *)(v9 + 8) = *(int64_t *)(v4 + 8);
    *(int64_t *)(v9 + 16) = *(int64_t *)(v4 + 16);
    *(int64_t *)(v9 + 24) = *(int64_t *)(v1 + 8);
    *(int64_t *)(v9 + 32) = *(int64_t *)(v1 + 16);
    *(int16_t *)v7 = *(int16_t *)(v4 + 2);
    *(int16_t *)(v7 + 2) = *(int16_t *)(v1 + 2);
    *(int16_t *)(v7 + 4) = *v11;
    int16_t * v12 = (int16_t *)(v7 + 6); // 0x1c0f5
    *v12 = 0;
    int16_t v13 = function_4820(a2); // 0x1c10d
    *v12 = v13 != 0 ? v13 : -1;
    return function_80bc(a1, a2, 0);
}

// Address range: 0x1c142 - 0x1c1d0
int64_t function_1c142(int64_t a1) {
    int32_t fd = a1; // 0x1c14a
    if (fcntl(fd, F_GETFL) == -1) {
        // 0x1c16a
        __assert_fail("f != -1", "../src/util.c", 52, "slirp_set_nonblock");
    }
    int32_t v1 = fcntl(fd, F_SETFL); // 0x1c1a0
    int64_t result = v1; // 0x1c1ac
    if (v1 == -1) {
        // 0x1c1ae
        __assert_fail("f != -1", "../src/util.c", 54, "slirp_set_nonblock");
        result = &g91;
    }
    // 0x1c1cd
    return result;
}

// Address range: 0x1c1d0 - 0x1c25e
int64_t function_1c1d0(int64_t a1) {
    int32_t fd = a1; // 0x1c1d8
    if (fcntl(fd, F_GETFD) == -1) {
        // 0x1c1f8
        __assert_fail("f != -1", "../src/util.c", 66, "slirp_set_cloexec");
    }
    int32_t v1 = fcntl(fd, F_SETFD); // 0x1c22e
    int64_t result = v1; // 0x1c23a
    if (v1 == -1) {
        // 0x1c23c
        __assert_fail("f != -1", "../src/util.c", 68, "slirp_set_cloexec");
        result = &g91;
    }
    // 0x1c25b
    return result;
}

// Address range: 0x1c25e - 0x1c2cc
int64_t function_1c25e(int64_t a1, int64_t a2, int64_t a3) {
    int32_t domain = a1; // 0x1c266
    int32_t type = a2; // 0x1c269
    int32_t protocol = a3; // 0x1c26c
    int32_t sock_fd = socket(domain, type | 0x80000, protocol); // 0x1c283
    if (sock_fd != -1 || *__errno_location() != 22) {
        // 0x1c2ca
        return sock_fd;
    }
    int32_t sock_fd2 = socket(domain, type, protocol); // 0x1c2af
    if (sock_fd2 >= 0) {
        // 0x1c2bd
        function_1c1d0((int64_t)sock_fd2);
    }
    // 0x1c2ca
    return sock_fd2;
}

// Address range: 0x1c2cc - 0x1c339
int64_t function_1c2cc(int64_t result, int64_t a2, int64_t a3) {
    // 0x1c2cc
    if ((int32_t)a2 < 1) {
        // 0x1c337
        return result;
    }
    char v1 = *(char *)a3; // 0x1c2f5
    char v2 = v1; // 0x1c302
    int64_t v3 = a3; // 0x1c302
    if (v1 == 0) {
        // 0x1c32d
        *(char *)result = 0;
        // 0x1c337
        return result;
    }
    int64_t v4 = result;
    int64_t result2 = v4; // 0x1c318
    while (v4 < result - 1 + 0x100000000 * a2 / 0x100000000) {
        // 0x1c31a
        v3++;
        int64_t v5 = v4 + 1; // 0x1c31e
        *(char *)v4 = v2;
        v2 = *(char *)v3;
        result2 = v5;
        if (v2 == 0) {
            // break -> 0x1c32d
            break;
        }
        v4 = v5;
        result2 = v4;
    }
    // 0x1c32d
    *(char *)result2 = 0;
    // 0x1c337
    return result2;
}

// Address range: 0x1c339 - 0x1c346
int64_t slirp_version_string(void) {
    // 0x1c339
    return (int64_t)"4.0.0";
}

// Address range: 0x1c346 - 0x1c399
int64_t function_1c346(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t result = 0; // 0x1c36c
    if ((char)function_126ba((int64_t *)a1) != 48) {
        // 0x1c375
        int64_t v1; // 0x1c346
        int64_t v2; // 0x1c346
        function_3080("Slirp", 16, "vmstate: get_nullptr expected VMS_NULLPTR_MARKER", a4, v2, v1);
        result = 0xffffffea;
    }
    // 0x1c397
    return result;
}

// Address range: 0x1c399 - 0x1c3f4
int64_t function_1c399(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c399
    int64_t result; // 0x1c399
    if (a2 != 0) {
        // 0x1c3d0
        int64_t v1; // 0x1c399
        int64_t v2; // 0x1c399
        function_3080("Slirp", 16, "vmstate: put_nullptr must be called with pv == NULL", a4, v2, v1);
        result = 0xffffffea;
    } else {
        // 0x1c3b8
        function_12712((int64_t *)a1, 48);
        result = 0;
    }
    // 0x1c3f2
    return result;
}

// Address range: 0x1c3f4 - 0x1c42f
int64_t function_1c3f4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c3f4
    *(char *)a2 = (char)function_126ba((int64_t *)a1);
    return 0;
}

// Address range: 0x1c42f - 0x1c46e
int64_t function_1c42f(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c42f
    uint64_t v1; // 0x1c42f
    function_12712((int64_t *)a1, v1 % 256);
    return 0;
}

// Address range: 0x1c46e - 0x1c4aa
int64_t function_1c46e(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c46e
    *(int16_t *)a2 = (int16_t)function_1273d(a1);
    return 0;
}

// Address range: 0x1c4aa - 0x1c4e9
int64_t function_1c4aa(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c4aa
    uint64_t v1; // 0x1c4aa
    function_12799(a1, v1 % 0x10000);
    return 0;
}

// Address range: 0x1c4e9 - 0x1c524
int64_t function_1c4e9(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c4e9
    *(int32_t *)a2 = (int32_t)function_127d1(a1);
    return 0;
}

// Address range: 0x1c524 - 0x1c55f
int64_t function_1c524(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c524
    int64_t v1; // 0x1c524
    function_1284f(a1, v1 & 0xffffffff);
    return 0;
}

// Address range: 0x1c55f - 0x1c59b
int64_t function_1c55f(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c55f
    *(int16_t *)a2 = (int16_t)function_128a5(a1);
    return 0;
}

// Address range: 0x1c59b - 0x1c5da
int64_t function_1c59b(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c59b
    int64_t v1; // 0x1c59b
    function_12901(a1, 0x1000000000000 * v1 / 0x1000000000000 & 0xffffffff);
    return 0;
}

// Address range: 0x1c5da - 0x1c615
int64_t function_1c5da(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c5da
    *(int32_t *)a2 = (int32_t)function_12939(a1);
    return 0;
}

// Address range: 0x1c615 - 0x1c650
int64_t function_1c615(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c615
    int64_t v1; // 0x1c615
    function_129b7(a1, v1 & 0xffffffff);
    return 0;
}

// Address range: 0x1c650 - 0x1c6c4
int64_t function_1c650(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = *(int64_t *)(a4 + 72); // 0x1c66c
    int32_t v2 = *(int32_t *)(a4 + 80); // 0x1c678
    int64_t v3 = function_2d50(a3); // 0x1c685
    *(int64_t *)v3 = a2;
    int64_t v4 = function_1cd2e((int64_t *)a1, (char (**)[13])v1, v3, v2); // 0x1c6ab
    function_2d70(v3);
    return v4 & 0xffffffff;
}

// Address range: 0x1c6c4 - 0x1c72e
int64_t function_1c6c4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = function_2d50(a3); // 0x1c6ef
    *(int64_t *)v1 = a2;
    int64_t v2 = function_1cc71((int64_t *)a1, (char (**)[13])*(int64_t *)(a4 + 72), v1); // 0x1c715
    function_2d70(v1);
    return v2 & 0xffffffff;
}

// Address range: 0x1c72e - 0x1c764
int64_t function_1c72e(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c72e
    function_12648(a1, (int64_t *)a2, a3);
    return 0;
}

// Address range: 0x1c764 - 0x1c79a
int64_t function_1c764(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c764
    function_12681(a1, (char *)a2, a3);
    return 0;
}

// Address range: 0x1c79a - 0x1c88b
int64_t function_1c79a(int64_t a1, int64_t a2) {
    int32_t v1 = *(int32_t *)(a2 + 64); // 0x1c7b1
    int32_t v2; // 0x1c79a
    if ((v1 & 4) == 0) {
        if ((v1 & 16) == 0) {
            if ((v1 & (int32_t)&g89) == 0) {
                if ((char)v1 > -1) {
                    // 0x1c83e
                    v2 = 1;
                    if ((v1 & (int32_t)&g76) != 0) {
                        unsigned char v3 = *(char *)(*(int64_t *)(a2 + 40) + a1); // 0x1c85d
                        v2 = v3;
                    }
                } else {
                    uint16_t v4 = *(int16_t *)(*(int64_t *)(a2 + 40) + a1); // 0x1c833
                    v2 = v4;
                }
            } else {
                // 0x1c7fe
                v2 = *(int32_t *)(*(int64_t *)(a2 + 40) + a1);
            }
        } else {
            // 0x1c7d8
            v2 = *(int32_t *)(*(int64_t *)(a2 + 40) + a1);
        }
    } else {
        // 0x1c7bb
        v2 = *(int32_t *)(a2 + 32);
    }
    int32_t result = v2; // 0x1c874
    if ((v1 & 0x4000) != 0) {
        // 0x1c876
        result = *(int32_t *)(a2 + 32) * v2;
    }
    // 0x1c886
    return result;
}

// Address range: 0x1c88b - 0x1c8f0
int64_t function_1c88b(int64_t a1, int64_t a2) {
    int32_t v1 = (int32_t)*(int64_t *)(a2 + 16); // 0x1c89f
    int32_t v2 = *(int32_t *)(a2 + 64); // 0x1c8a6
    int32_t result = v1; // 0x1c8b0
    if ((v2 & 256) != 0) {
        int32_t v3 = *(int32_t *)(*(int64_t *)(a2 + 48) + a1); // 0x1c8c1
        result = v3 * ((v2 & (int32_t)&g36) == 0 ? 1 : v1);
    }
    // 0x1c8eb
    return result;
}

// Address range: 0x1c8f0 - 0x1cc71
int64_t function_1c8f0(int64_t a1, int64_t a2, int64_t a3, uint32_t a4) {
    int64_t v1 = *(int64_t *)(a2 + 32); // 0x1c91e
    int64_t v2; // 0x1c8f0
    if (v1 != 0 && (int32_t)v1 != 0) {
        // 0x1c949
        int64_t v3; // 0x1c8f0
        function_3080("Slirp", 16, "pre-save failed: %s", a2, v3, v2);
        // 0x1cc6f
        return v1 & 0xffffffff;
    }
    int64_t v4 = *(int64_t *)(a2 + 40); // 0x1c912
    int64_t * v5 = (int64_t *)v4; // 0x1cc5e
    int64_t v6 = *v5; // 0x1cc5e
    if (v6 == 0) {
        // 0x1cc6f
        return 0;
    }
    int64_t v7 = v6; // 0x1cc5e
    int64_t * v8 = v5; // 0x1cc5e
    int64_t v9 = a2; // 0x1c8f0
    int64_t v10 = v4; // 0x1cc55
    int64_t v11; // 0x1cbf9
    int64_t * v12; // 0x1c8f0
    int64_t v13; // 0x1c8f0
    int64_t v14; // 0x1c8f0
    while (true) {
      lab_0x1c978:
        // 0x1c978
        v14 = v10;
        v12 = v8;
        v11 = v7;
        int64_t v15 = *(int64_t *)(v14 + 88); // 0x1c97c
        if (v15 == 0) {
            // 0x1c9b0
            v13 = v9;
            if ((int64_t)a4 < (int64_t)*(int32_t *)(v14 + 80)) {
                goto lab_0x1cbe5;
            } else {
                goto lab_0x1c9c0;
            }
        } else {
            // 0x1c985
            v13 = a4;
            if ((char)v15 != 0) {
                goto lab_0x1c9c0;
            } else {
                goto lab_0x1cbe5;
            }
        }
    }
  lab_0x1cc6f_2:;
    // 0x1cc6f
    int64_t v16; // 0x1c8f0
    return v16 & 0xffffffff;
  lab_0x1cbe5:;
    int64_t v17 = v13;
    int32_t * v18 = (int32_t *)(v14 + 64); // 0x1cbe9
    int64_t v19 = v17; // 0x1cbf3
    if ((*v18 & (int32_t)"back") != 0) {
        // 0x1cbf5
        function_3080("Slirp", 16, "Output state validation failed: %s/%s", v17, v11, v2);
        v19 = 16;
        if ((*v18 & (int32_t)"back") != 0) {
            // 0x1cc36
            __assert_fail("!(field->flags & VMS_MUST_EXIST)", "../src/vmstate.c", 353, "vmstate_save_state_v");
            v19 = (int64_t)"../src/vmstate.c";
        }
    }
    goto lab_0x1cc55;
  lab_0x1c9c0:;
    int64_t v20 = *(int64_t *)(v14 + 8) + a3; // 0x1c9cc
    int64_t v21 = function_1c79a(a3, v14); // 0x1c9e1
    int32_t v22 = v21; // 0x1c9e6
    int64_t v23 = function_1c88b(a3, v14); // 0x1c9f7
    int32_t v24 = v23; // 0x1c9fc
    int32_t * v25 = (int32_t *)(v14 + 64); // 0x1ca03
    int64_t v26 = v20; // 0x1ca0b
    int64_t v27 = v14; // 0x1ca0b
    if ((*v25 & 2) != 0) {
        int64_t v28 = *(int64_t *)v20; // 0x1ca11
        v26 = v28;
        v27 = v14;
        if (v24 != 0 && v22 != 0 && v28 == 0) {
            // 0x1ca2b
            __assert_fail("first_elem || !n_elems || !size", "../src/vmstate.c", 320, "vmstate_save_state_v");
            v26 = v28;
            v27 = (int64_t)"../src/vmstate.c";
        }
    }
    // 0x1ca4a
    v19 = v27;
    if (v22 > 0) {
        int64_t v29 = 0x100000000 * v23;
        int64_t v30 = v29 / 0x100000000;
        int64_t * v31 = (int64_t *)(v14 + 72);
        int32_t * v32 = (int32_t *)(v14 + 84);
        int64_t * v33 = (int64_t *)(v14 + 56);
        int64_t v34 = 0;
        int64_t v35 = v29 * v34 / 0x100000000 + v26; // 0x1ca64
        int32_t v36 = *v25; // 0x1ca76
        int32_t v37 = v36; // 0x1ca7e
        int64_t v38 = v35; // 0x1ca7e
        int32_t v39; // 0x1c8f0
        if ((v36 & 64) != 0) {
            // 0x1ca80
            v39 = v36;
            if (v35 == 0) {
                // 0x1ca87
                __assert_fail("curr_elem", "../src/vmstate.c", 327, "vmstate_save_state_v");
                v39 = *v25;
            }
            // 0x1caa6
            v38 = *(int64_t *)v35;
            v37 = v39;
        }
        int64_t v40 = v38;
        int32_t v41 = v37;
        int64_t v42; // 0x1c8f0
        int64_t v43; // 0x1c8f0
        int64_t v44; // 0x1cb21
        int64_t v45; // 0x1cb58
        if (v24 == 0 || v40 != 0) {
            if ((v41 & 8) == 0) {
                if ((int16_t)v41 > -1) {
                    // 0x1cb71
                    v43 = *(int64_t *)(*v33 + 16);
                    v42 = v40;
                } else {
                    // 0x1cb4d
                    v45 = *v31;
                    v43 = function_1c8f0(a1, v45, v40, *v32);
                    v42 = v45;
                }
            } else {
                // 0x1cb1d
                v44 = *v31;
                v43 = function_1cc71((int64_t *)a1, (char (**)[13])v44, v40);
                v42 = v44;
            }
        } else {
            if ((v41 & 64) == 0) {
                // 0x1cacc
                __assert_fail("field->flags & VMS_ARRAY_OF_POINTER", "../src/vmstate.c", 332, "vmstate_save_state_v");
            }
            // 0x1caeb
            v43 = function_1c399(a1, v40, v30, 0);
            v42 = v40;
        }
        int64_t v46 = v42;
        v16 = v43;
        if ((int32_t)v16 != 0) {
            // 0x1cb9a
            function_3080("Slirp", 16, "Save of field %s/%s failed", v46, *v12, v2);
            goto lab_0x1cc6f_2;
        }
        // 0x1cbd7
        v34++;
        v19 = v46;
        while (v34 < 0x100000000 * v21 / 0x100000000) {
            // 0x1ca56
            v35 = v29 * v34 / 0x100000000 + v26;
            v36 = *v25;
            v37 = v36;
            v38 = v35;
            if ((v36 & 64) != 0) {
                // 0x1ca80
                v39 = v36;
                if (v35 == 0) {
                    // 0x1ca87
                    __assert_fail("curr_elem", "../src/vmstate.c", 327, "vmstate_save_state_v");
                    v39 = *v25;
                }
                // 0x1caa6
                v38 = *(int64_t *)v35;
                v37 = v39;
            }
            // 0x1cab1
            v40 = v38;
            v41 = v37;
            if (v24 == 0 || v40 != 0) {
                if ((v41 & 8) == 0) {
                    if ((int16_t)v41 > -1) {
                        // 0x1cb71
                        v43 = *(int64_t *)(*v33 + 16);
                        v42 = v40;
                    } else {
                        // 0x1cb4d
                        v45 = *v31;
                        v43 = function_1c8f0(a1, v45, v40, *v32);
                        v42 = v45;
                    }
                } else {
                    // 0x1cb1d
                    v44 = *v31;
                    v43 = function_1cc71((int64_t *)a1, (char (**)[13])v44, v40);
                    v42 = v44;
                }
            } else {
                if ((v41 & 64) == 0) {
                    // 0x1cacc
                    __assert_fail("field->flags & VMS_ARRAY_OF_POINTER", "../src/vmstate.c", 332, "vmstate_save_state_v");
                }
                // 0x1caeb
                v43 = function_1c399(a1, v40, v30, 0);
                v42 = v40;
            }
            // 0x1cb94
            v46 = v42;
            v16 = v43;
            if ((int32_t)v16 != 0) {
                // 0x1cb9a
                function_3080("Slirp", 16, "Save of field %s/%s failed", v46, *v12, v2);
                goto lab_0x1cc6f_2;
            }
            // 0x1cbd7
            v34++;
            v19 = v46;
        }
    }
    goto lab_0x1cc55;
  lab_0x1cc55:
    // 0x1cc55
    v10 = v14 + 96;
    v8 = (int64_t *)v10;
    v7 = *v8;
    v9 = v19;
    if (v7 == 0) {
        // break -> 0x1cc6f
        goto lab_0x1cc6f_2;
    }
    goto lab_0x1c978;
}

// Address range: 0x1cc71 - 0x1cca2
int64_t function_1cc71(int64_t * a1, char (**a2)[13], int64_t a3) {
    int64_t v1 = (int64_t)a2;
    return function_1c8f0((int64_t)a1, v1, a3, *(int32_t *)(v1 + 8));
}

// Address range: 0x1cca2 - 0x1cd2e
int64_t function_1cca2(int64_t a1, int64_t a2, int64_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 64); // 0x1ccba
    if ((v1 & 2) == 0 || (v1 & (int32_t)&g37) == 0) {
        // 0x1cd2b
        return 0;
    }
    int64_t v2 = function_1c88b(a3, a2); // 0x1cce2
    int64_t v3 = 0x100000000 * function_1c79a(a3, a2) / 0x100000000 * 0x100000000 * v2 / 0x100000000;
    int64_t result = 0; // 0x1cd13
    if (v3 != 0) {
        // 0x1cd15
        *(int64_t *)a1 = function_2d50(v3);
        result = a1;
    }
    // 0x1cd2b
    return result;
}

// Address range: 0x1cd2e - 0x1d0c3
int64_t function_1cd2e(int64_t * a1, char (**a2)[13], int64_t a3, uint32_t a4) {
    int64_t v1 = (int64_t)a2;
    int64_t v2 = (int64_t)*(int32_t *)(v1 + 8); // 0x1cd5c
    int64_t v3 = a4; // 0x1cd62
    if (v3 > v2) {
        // 0x1cd64
        function_3080("Slirp", 16, "%s: incoming version_id %d is too new for local version_id %d", v1, (int64_t)a4, v2);
        // 0x1d0c1
        return 0xffffffea;
    }
    int64_t v4 = *(int64_t *)(v1 + 16); // 0x1cda9
    if (v4 != 0 && (int32_t)v4 != 0) {
        // 0x1d0c1
        return v4 & 0xffffffff;
    }
    int64_t v5 = *(int64_t *)(v1 + 40); // 0x1cd49
    int64_t * v6 = (int64_t *)v5; // 0x1d08c
    int64_t v7 = *v6; // 0x1d08c
    int32_t v8 = 0; // 0x1d092
    if (v7 == 0) {
      lab_0x1d098:;
        int64_t v9 = *(int64_t *)(v1 + 24); // 0x1d09c
        // 0x1d0c1
        return v9 == 0 ? v8 : (int32_t)v9;
    }
    int64_t v10 = v7; // 0x1d08c
    int64_t * v11 = v6; // 0x1d08c
    int64_t v12 = v1; // 0x1cd2e
    int32_t v13 = 0;
    int64_t v14 = v5; // 0x1d083
    int64_t v15; // 0x1d04f
    int64_t * v16; // 0x1cd2e
    int64_t v17; // 0x1cd2e
    int64_t v18; // 0x1cd2e
    int32_t v19; // 0x1cd2e
    while (true) {
      lab_0x1cddc:
        // 0x1cddc
        v18 = v14;
        v19 = v13;
        v16 = v11;
        v15 = v10;
        int64_t v20 = *(int64_t *)(v18 + 88); // 0x1cde0
        if (v20 == 0) {
            // 0x1ce14
            v17 = v12;
            if (v3 < (int64_t)*(int32_t *)(v18 + 80)) {
                goto lab_0x1d03b;
            } else {
                goto lab_0x1ce24;
            }
        } else {
            // 0x1cde9
            v17 = a4;
            if ((char)v20 != 0) {
                goto lab_0x1ce24;
            } else {
                goto lab_0x1d03b;
            }
        }
    }
  lab_0x1d04b:;
    // 0x1d04b
    int64_t v21; // 0x1cd2e
    int64_t v22; // 0x1cd2e
    function_3080("Slirp", 16, "Input validation failed: %s/%s", v21, v15, v22);
    int64_t result = 0xffffffff; // 0x1d081
  lab_0x1d0c1:
    // 0x1d0c1
    return result;
  lab_0x1d03b:
    // 0x1d03b
    v21 = v17;
    int32_t v23 = v19; // 0x1d049
    int64_t v24 = v21; // 0x1d049
    if ((*(int32_t *)(v18 + 64) & (int32_t)"back") != 0) {
        // break -> 0x1d04b
        goto lab_0x1d04b;
    }
    goto lab_0x1d083;
  lab_0x1ce24:;
    int64_t v25 = *(int64_t *)(v18 + 8) + a3; // 0x1ce30
    int64_t v26 = function_1c79a(a3, v18); // 0x1ce45
    int32_t v27 = v26; // 0x1ce4a
    int64_t v28 = function_1c88b(a3, v18); // 0x1ce5b
    int32_t v29 = v28; // 0x1ce60
    function_1cca2(v25, v18, a3);
    int32_t * v30 = (int32_t *)(v18 + 64); // 0x1ce7e
    int64_t v31 = v25; // 0x1ce86
    int64_t v32 = v18; // 0x1ce86
    if ((*v30 & 2) != 0) {
        int64_t v33 = *(int64_t *)v25; // 0x1ce8c
        v31 = v33;
        v32 = v18;
        if (v29 != 0 && v27 != 0 && v33 == 0) {
            // 0x1cea6
            __assert_fail("first_elem || !n_elems || !size", "../src/vmstate.c", 407, "slirp_vmstate_load_state");
            v31 = v33;
            v32 = (int64_t)"../src/vmstate.c";
        }
    }
    // 0x1cec5
    v23 = v19;
    v24 = v32;
    if (v27 > 0) {
        int64_t v34 = 0x100000000 * v28;
        int64_t v35 = v34 / 0x100000000;
        int64_t * v36 = (int64_t *)(v18 + 72);
        int32_t * v37 = (int32_t *)(v18 + 84);
        int64_t * v38 = (int64_t *)(v18 + 56);
        int64_t v39 = 0;
        int64_t v40 = v34 * v39 / 0x100000000 + v31; // 0x1cedf
        int32_t v41 = *v30; // 0x1ceea
        int64_t v42 = v40; // 0x1cef2
        if ((v41 & 64) != 0) {
            // 0x1cef4
            v42 = *(int64_t *)v40;
        }
        int64_t v43 = v42;
        int64_t v44; // 0x1cd2e
        int64_t v45; // 0x1cd2e
        int64_t v46; // 0x1cf6f
        int32_t v47; // 0x1cf73
        int64_t v48; // 0x1cfae
        if (v29 == 0 || v43 != 0) {
            if ((v41 & 8) == 0) {
                if ((int16_t)v41 > -1) {
                    // 0x1cfc7
                    v45 = *(int64_t *)(*v38 + 8);
                    v44 = v43;
                } else {
                    // 0x1cfa3
                    v48 = *v36;
                    v45 = function_1cd2e(a1, (char (**)[13])v48, v43, *v37);
                    v44 = v48;
                }
            } else {
                // 0x1cf6b
                v46 = *v36;
                v47 = *(int32_t *)(v46 + 8);
                v45 = function_1cd2e(a1, (char (**)[13])v46, v43, v47);
                v44 = v46;
            }
        } else {
            if ((v41 & 64) == 0) {
                // 0x1cf1a
                __assert_fail("field->flags & VMS_ARRAY_OF_POINTER", "../src/vmstate.c", 417, "slirp_vmstate_load_state");
            }
            // 0x1cf39
            v45 = function_1c346((int64_t)a1, v43, v35, 0);
            v44 = v43;
        }
        int64_t v49 = v44;
        int64_t v50 = v45;
        int32_t v51 = v50;
        if (v51 < 0) {
            // 0x1cff0
            function_3080("Slirp", 16, "Failed to load %s:%s", v49, *v16, v22);
            result = v50 & 0xffffffff;
            goto lab_0x1d0c1;
        }
        // 0x1d02d
        v39++;
        v23 = v51;
        v24 = v49;
        while (v39 < 0x100000000 * v26 / 0x100000000) {
            // 0x1ced1
            v40 = v34 * v39 / 0x100000000 + v31;
            v41 = *v30;
            v42 = v40;
            if ((v41 & 64) != 0) {
                // 0x1cef4
                v42 = *(int64_t *)v40;
            }
            // 0x1ceff
            v43 = v42;
            if (v29 == 0 || v43 != 0) {
                if ((v41 & 8) == 0) {
                    if ((int16_t)v41 > -1) {
                        // 0x1cfc7
                        v45 = *(int64_t *)(*v38 + 8);
                        v44 = v43;
                    } else {
                        // 0x1cfa3
                        v48 = *v36;
                        v45 = function_1cd2e(a1, (char (**)[13])v48, v43, *v37);
                        v44 = v48;
                    }
                } else {
                    // 0x1cf6b
                    v46 = *v36;
                    v47 = *(int32_t *)(v46 + 8);
                    v45 = function_1cd2e(a1, (char (**)[13])v46, v43, v47);
                    v44 = v46;
                }
            } else {
                if ((v41 & 64) == 0) {
                    // 0x1cf1a
                    __assert_fail("field->flags & VMS_ARRAY_OF_POINTER", "../src/vmstate.c", 417, "slirp_vmstate_load_state");
                }
                // 0x1cf39
                v45 = function_1c346((int64_t)a1, v43, v35, 0);
                v44 = v43;
            }
            // 0x1cfea
            v49 = v44;
            v50 = v45;
            v51 = v50;
            if (v51 < 0) {
                // 0x1cff0
                function_3080("Slirp", 16, "Failed to load %s:%s", v49, *v16, v22);
                result = v50 & 0xffffffff;
                goto lab_0x1d0c1;
            }
            // 0x1d02d
            v39++;
            v23 = v51;
            v24 = v49;
        }
    }
    goto lab_0x1d083;
  lab_0x1d083:
    // 0x1d083
    v13 = v23;
    v14 = v18 + 96;
    v11 = (int64_t *)v14;
    v10 = *v11;
    v12 = v24;
    v8 = v13;
    if (v10 == 0) {
        goto lab_0x1d098;
    }
    goto lab_0x1cddc;
}

// Address range: 0x1d0d0 - 0x1d0e0
int64_t function_1d0d0(char * a1, int64_t a2) {
    // 0x1d0d0
    return __xstat64(1, a1, (struct stat64 *)a2);
}

// Address range: 0x1d0e0 - 0x1d0e9
int64_t function_1d0e0(void) {
    // 0x1d0e0
    int64_t result; // 0x1d0e0
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// void __assert_fail(const char * assertion, const char * file, unsigned int line, const char * function);
// void __cxa_finalize(void * d);
// int * __errno_location(void);
// void __gmon_start__(void);
// void __stack_chk_fail(void);
// int __xstat64(int ver, const char * filename, struct stat64 * stat_buf);
// int accept(int fd, __SOCKADDR_ARG addr, socklen_t * restrict addr_len);
// int atoi(const char * nptr);
// int bind(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// int close(int fd);
// int connect(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// int dup2(int fd, int fd2);
// int fclose(FILE * stream);
// int fcntl(int fd, int cmd, ...);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen64(const char * restrict filename, const char * restrict modes);
// void free(void * ptr);
// int64_t g_assertion_message_expr(void);
// int64_t g_error_free(void);
// int64_t g_free(void);
// int64_t g_getenv(void);
// int64_t g_log(void);
// int64_t g_malloc(void);
// int64_t g_malloc0(void);
// int64_t g_malloc0_n(void);
// int64_t g_malloc_n(void);
// int64_t g_parse_debug_string(void);
// int64_t g_rand_free(void);
// int64_t g_rand_int_range(void);
// int64_t g_rand_new(void);
// int64_t g_realloc(void);
// int64_t g_return_if_fail_warning(void);
// int64_t g_spawn_async(void);
// int64_t g_strdup(void);
// int64_t g_strfreev(void);
// int64_t g_string_append_printf(void);
// int64_t g_string_free(void);
// int64_t g_string_new(void);
// int64_t g_strsplit(void);
// int64_t g_strstr_len(void);
// int getpeername(int fd, __SOCKADDR_ARG addr, socklen_t * restrict len);
// int getsockname(int fd, __SOCKADDR_ARG addr, socklen_t * restrict len);
// int getsockopt(int fd, int level, int optname, void * restrict optval, socklen_t * restrict optlen);
// uint32_t htonl(uint32_t hostlong);
// uint16_t htons(uint16_t hostshort);
// unsigned int if_nametoindex(const char * ifname);
// char * inet_ntoa(struct in_addr __in);
// const char * inet_ntop(int af, const void * restrict cp, char * restrict buf, socklen_t len);
// int inet_pton(int af, const char * restrict cp, void * restrict buf);
// int ioctl(int fd, unsigned long int request, ...);
// int listen(int fd, int n);
// __off64_t lseek64(int fd, __off64_t offset, int whence);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memmove(void * dest, const void * src, size_t n);
// void * memset(void * s, int c, size_t n);
// uint32_t ntohl(uint32_t netlong);
// uint16_t ntohs(uint16_t netshort);
// int open64(const char * file, int oflag, ...);
// void qsort(void * base, size_t nmemb, size_t size, __compar_fn_t compar);
// ssize_t read(int fd, void * buf, size_t nbytes);
// void * realloc(void * ptr, size_t size);
// ssize_t recv(int fd, void * buf, size_t n, int flags);
// ssize_t recvfrom(int fd, void * restrict buf, size_t n, int flags, __SOCKADDR_ARG addr, socklen_t * restrict addr_len);
// ssize_t send(int fd, const void * buf, size_t n, int flags);
// ssize_t sendto(int fd, const void * buf, size_t n, int flags, __CONST_SOCKADDR_ARG addr, socklen_t addr_len);
// __pid_t setsid(void);
// int setsockopt(int fd, int level, int optname, const void * optval, socklen_t optlen);
// int shutdown(int fd, int how);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int socket(int domain, int type, int protocol);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int strcasecmp(const char * s1, const char * s2);
// char * strchr(char * s, int c);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strstr(char * haystack, const char * needle);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.5.0)
// Detected functions: 349
