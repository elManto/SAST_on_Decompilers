
//#include <emmintrin.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
//#include <errno.h>
//#include <string>
//#include <math.h>
//#include <defs.h>

#include <stdarg.h>


#include "precomp.hpp"
#include "utils.hpp"
#include "grfmt_pxm.hpp"
#include <iostream>

//#include <opencv2/core/mat.hpp>
//
//
// global variables
//
int unk_765E00;
int unk_432079;



//----- (0000000000091CE6) ----------------------------------------------------
unsigned int  sub_91CE6(unsigned int a1, unsigned int *a2, int a3, int a4, char *a5, int a6, int a7)
{
  unsigned int result; // rax
  char *v8; // [rsp+30] [rbp-38]
  unsigned int v9; // [rsp+38] [rbp-30]
  char *v10; // [rsp+40] [rbp-28]
  unsigned int v11; // [rsp+48] [rbp-20]
  unsigned int v12; // [rsp+50] [rbp-18]
  unsigned int v13; // [rsp+58] [rbp-10]

  if ( a7 )
  {
    if ( a7 != 2 )
      __assert_fail(
        "0",
        "/home/mantovan/Repositories/opencv/modules/imgcodecs/src/grfmt_pam.cpp",
        0xD5u,
        "void basic_conversion(void*, const channel_layout*, int, int, void*, int, int)");
    v10 = a5;
    v11 = a1;
    v12 = 2LL * a4 + a1;
    if ( a6 == 1 )
    {
      while ( 1 )
      {
        result = v11;
        if ( v11 >= v12 )
          break;
        v10[2] = *(char *)(2LL * a2[3] + v11);
        v10[1] = v10[2];
        *v10 = v10[1];
        v10 += 3;
        v11 += 2LL * a3;
      }
    }
    else
    {
      if ( a6 != 3 )
        __assert_fail(
          "0",
          "/home/mantovan/Repositories/opencv/modules/imgcodecs/src/grfmt_pam.cpp",
          0xD0u,
          "void basic_conversion(void*, const channel_layout*, int, int, void*, int, int)");
      while ( 1 )
      {
        result = v11;
        if ( v11 >= v12 )
          break;
        *v10 = *(char *)(2LL * a2[2] + v11);
        v10[1] = *(char *)(2LL * a2[1] + v11);
        v10[2] = *(char *)(2LL * *a2 + v11);
        v10 += 3;
        v11 += 2LL * a3;
      }
    }
  }
  else
  {
    v8 = a5;
    v9 = a1;
    v13 = a4 + a1;
    if ( a6 == 1 )
    {
      while ( 1 )
      {
        result = v9;
        if ( v9 >= v13 )
          break;
        v8[2] = *(char *)(a2[3] + v9);
        v8[1] = v8[2];
        *v8 = v8[1];
        v8 += 3;
        v9 += a3;
      }
    }
    else
    {
      if ( a6 != 3 )
        __assert_fail(
          "0",
          "/home/mantovan/Repositories/opencv/modules/imgcodecs/src/grfmt_pam.cpp",
          0xBBu,
          "void basic_conversion(void*, const channel_layout*, int, int, void*, int, int)");
      while ( 1 )
      {
        result = v9;
        if ( v9 >= v13 )
          break;
        *v8 = *(char *)(a2[2] + v9);
        v8[1] = *(char *)(a2[1] + v9);
        v8[2] = *(char *)(*a2 + v9);
        v8 += 3;
        v9 += a3;
      }
    }
  }
  return result;
}


//----- (00000000000830EA) ----------------------------------------------------
int64  sub_830EA(int64 a1, char a2, char a3)
{
  char v3; // al
  int64 result; // rax
  int64 v5; // rdx
  char *v6; // rax
  signed int i; // [rsp+10] [rbp-10]
  signed int v8; // [rsp+14] [rbp-C]
  char v9; // [rsp+18] [rbp-8]

  v8 = 1 << a2;
  if ( a3 )
    v3 = -1;
  else
    v3 = 0;
  v9 = v3;
  for ( i = 0; ; ++i )
  {
    result = (unsigned int)i;
    if ( i >= v8 )
      break;
    v5 = a1 + 4LL * i;
    *(char *)(v5 + 2) = v9 ^ (unsigned int)(255 * i / (v8 - 1));
    v6 = (char *)(4LL * i + a1);
    v6[1] = *(char *)(v5 + 2);
    *v6 = v6[1];
    v6[3] = 0;
  }
  return result;
}

//----- (0000000000083B06) ----------------------------------------------------
char * sub_83B06(int64 a1, char *a2, int a3, char *a4)
{
  char *v4; // rax
  char v5; // al
  char v6; // al
  char v7; // al
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  char v13; // al
  char *v15; // [rsp+10] [rbp-30]
  int64 v16; // [rsp+18] [rbp-28]
  char *v17; // [rsp+18] [rbp-28]
  char v18; // [rsp+2E] [rbp-12]
  char v19; // [rsp+2F] [rbp-11]
  char v20; // [rsp+30] [rbp-10]
  char v21; // [rsp+34] [rbp-C]
  int64 v22; // [rsp+38] [rbp-8]

  v16 = a1;
  v15 = a2;
  v22 = a3 + a1;
  v18 = *a4;
  v19 = a4[1];
  while ( 1 )
  {
    v16 += 8LL;
    if ( v16 >= v22 )
      break;
    v4 = v15++;
    v21 = *v4;
    if ( *v4 & 0x80 )
      v5 = v19;
    else
      v5 = v18;
    *(char *)(v16 - 8) = v5;
    if ( v21 & 0x40 )
      v6 = v19;
    else
      v6 = v18;
    *(char *)(v16 - 7) = v6;
    if ( v21 & 0x20 )
      v7 = v19;
    else
      v7 = v18;
    *(char *)(v16 - 6) = v7;
    if ( v21 & 0x10 )
      v8 = v19;
    else
      v8 = v18;
    *(char *)(v16 - 5) = v8;
    if ( v21 & 8 )
      v9 = v19;
    else
      v9 = v18;
    *(char *)(v16 - 4) = v9;
    if ( v21 & 4 )
      v10 = v19;
    else
      v10 = v18;
    *(char *)(v16 - 3) = v10;
    if ( v21 & 2 )
      v11 = v19;
    else
      v11 = v18;
    *(char *)(v16 - 2) = v11;
    if ( v21 & 1 )
      v12 = v19;
    else
      v12 = v18;
    *(char *)(v16 - 1) = v12;
  }
  v20 = *v15;
  v17 = (char *)(v16 - 8);
  while ( (unsigned int64)v17 < v22 )
  {
    if ( v20 & 0x80 )
      v13 = v19;
    else
      v13 = v18;
    *v17++ = v13;
    v20 *= 2;
  }
  return v17;
}


//----- (0000000000087760) ----------------------------------------------------
void * sub_87760(int64 a1)
{
  void *result; // rax

  result = *(void **)a1;
  if ( *(int *)a1 != a1 + 16 )
  {
    if ( *(int *)a1 )
      delete[] (*(void **)a1);
    *(int *)a1 = a1 + 16;
    result = (void *)a1;
    *(int *)(a1 + 8) = 1032LL;
  }
  return result;
}

//----- (0000000000087574) ----------------------------------------------------
void * sub_87574(int64 a1)
{
  return sub_87760(a1);
}


//----- (0000000000087590) ----------------------------------------------------
int * sub_87590(int *a1, int64 a2)
{
  int *result; // rax
  int64 v3; // rdx

  if ( a2 > a1[1] )
  {
    sub_87760((int64)a1);
    result = a1;
    a1[1] = a2;
    if ( a2 > 0x408 )
    {
      a1 = new int [a2];
      result = a1;
    }
  }
  else
  {
    result = a1;
    a1[1] = a2;
  }
  return result;
}


bool sub_91B10()
{
  return unk_432079 != 0;
}


//----- (000000000009E56C) ----------------------------------------------------
int64  sub_9E56C(int64 a1, char *a2, int a3)
{
  int v4; // [rsp+C] [rbp-2C]
  unsigned int v5; // [rsp+20] [rbp-18]
  int v6; // [rsp+24] [rbp-14]
  char *dest; // [rsp+28] [rbp-10]

  v4 = a3;
  dest = a2;
  v5 = 0;
  if ( a3 < 0 )
    __assert_fail(
      "count >= 0",
      "/home/mantovan/Repositories/opencv/modules/imgcodecs/src/bitstrm.cpp",
      0xE0u,
      "int cv::RLByteStream::getBytes(void*, int)");
  while ( v4 > 0 )
  {
    while ( 1 )
    {
      v6 = *(int *)(a1 + 24) - *(int *)(a1 + 32);
      if ( v6 > v4 )
        v6 = v4;
      if ( v6 > 0 )
        break;
      (*(void ( **)(int64))(*(int *)a1 + 40LL))(a1);
    }
    memcpy(dest, *(const void **)(a1 + 32), v6);
    *(int *)(a1 + 32) += v6;
    dest += v6;
    v4 -= v6;
    v5 += v6;
  }
  return v5;
}


//----- (000000000009E286) ----------------------------------------------------
uint64  sub_9E286(uint64 a1, int a2)
{
  uint64 result; // rax
  int v3; // ecx

  if ( a2 < 0 )
    __assert_fail(
      "isOpened() && pos >= 0",
      "/home/mantovan/Repositories/opencv/modules/imgcodecs/src/bitstrm.cpp",
      0xA8u,
      "void cv::RBaseStream::setPos(int)");
  if ( *(int *)(a1 + 40) )
  {
    v3 = *(int *)(a1 + 48);
    *(int *)(a1 + 52) = a2 - a2 % v3;
    result = a1;
    *(int *)(a1 + 32) = a2 % v3 + *(int *)(a1 + 16);
  }
  else
  {
    *(int *)(a1 + 32) = a2 + *(int *)(a1 + 16);
    result = a1;
    *(int *)(a1 + 52) = 0;
  }
  return result;
}


uint64  sub_9387E(uint64 a1, cv::Mat *a2)
{
  bool v2; // al
  unsigned int v3; // ebx
  int v4; // ebx
  bool v5; // al
  bool v6; // al
  char v7; // ST2B_1
  bool v8; // al
  char v9; // ST2A_1
  bool v10; // al
  uint64 ( *v11)(char *, char *, uint64, uint64, uint64); // rbx
  unsigned int v12; // eax
  int v13; // eax
  int v14; // eax
  char v16; // [rsp+19] [rbp-C9F]
  int i; // [rsp+1C] [rbp-C9C]
  int j; // [rsp+1C] [rbp-C9C]
  int k; // [rsp+1C] [rbp-C9C]
  int v20; // [rsp+20] [rbp-C98]
  int v21; // [rsp+20] [rbp-C98]
  int v22; // [rsp+20] [rbp-C98]
  int v23; // [rsp+20] [rbp-C98]
  unsigned int v24; // [rsp+24] [rbp-C94]
  int v25; // [rsp+2C] [rbp-C8C]
  int v26; // [rsp+30] [rbp-C88]
  char *dest; // [rsp+38] [rbp-C80]
  char *v28; // [rsp+40] [rbp-C78]
  uint64 n; // [rsp+48] [rbp-C70]
  char *src; // [rsp+50] [rbp-C68]
  char *v31; // [rsp+58] [rbp-C60]
  int v32; // [rsp+60] [rbp-C58]
  int v33; // [rsp+64] [rbp-C54]
  int v34; // [rsp+68] [rbp-C50]
  int v35; // [rsp+6C] [rbp-C4C]
  char v36; // [rsp+70] [rbp-C48]
  char v37; // [rsp+470] [rbp-848]
  char v38; // [rsp+890] [rbp-428]
  uint64 v39; // [rsp+CA8] [rbp-10]

  //v39 = __readfsqword(0x28u);
  //dest = (char *)cv::Mat::ptr(a2, 0);
  dest = (char*)a2->ptr();
  v24 = a2->channels();
  n = (unsigned long)((char *)a2 + 72);
  v25 = *(int *)(a1 + 8) * *(int *)(a1 + 228);
  v26 = ((0x88442211uLL >> 4 * (*(char *)(a1 + 16) & 7u)) & 0xF) * v25;
  v28 = 0LL;
  src = (char *)CV_MAT_CN((uint64)&v37);
  v2 = *(int *)(a1 + 236) < 0 ;
  if ( v2 )
  {
    v3 = 0;
  }
  else
  {
    if ( *(int *)(a1 + 240) )
    {
      v28 = (char *)&unk_765E00 + 288 * *(signed int *)(a1 + 240);
    }
    else
    {
      if ( *(int *)(a1 + 228) <= 2 )
      {
        v32 = 0;
        v33 = 0;
        v34 = 0;
      }
      else
      {
        v34 = 0;
        v33 = 1;
        v32 = 2;
      }
      v35 = 0;
    }

    sub_9E286(a1 + 160, *(int *)(a1 + 236));
    v4 = *(int *)(a1 + 232);
    v5 = v4 == (unsigned int)a2->depth() && v24 == *(int *)(a1 + 228) && *(char *)(a1 + 244) != 1;
    if ( v5 )
    {
      v6 = *(int *)(a1 + 232) == 2 && !sub_91B10();
      if ( v6 )
      {
        v20 = 0;
        while ( v20 < *(int *)(a1 + 12) )
        {
          sub_9E56C(a1 + 160, src, v26);
          for ( i = 0; i < v25; ++i )
          {
            v7 = src[2 * i];
            dest[2 * i] = src[2 * i + 1];
            dest[2 * i + 1] = v7;
          }
          ++v20;
          dest += n;
        }
      }
      else
      {
        sub_9E56C(a1 + 160, dest, v26 * *(int *)(a1 + 12));
      }
    }
    else if ( *(char *)(a1 + 244) )
    {
      if ( v24 == 1 )
      {
        sub_87590((int*)&v38, 2uLL);
        v31 = (char *)sub_87590((int*)&v38, 2uLL);
        *v31 = 0;
        v31[1] = -1;
        v21 = 0;
        while ( v21 < *(int *)(a1 + 12) )
        {
          sub_9E56C(a1 + 160, src, v26);
          sub_83B06((unsigned uint64)dest, src, *(int *)(a1 + 8), v31);
          ++v21;
          dest += n;
        }
      }
      else if ( v24 == 3 )
      {
        sub_830EA((uint64)&v36, 1, 0);
        v22 = 0;
        while ( v22 < *(int *)(a1 + 12) )
        {
          sub_9E56C(a1 + 160, src, v26);
          ++v22;
          dest += n;
        }
      }
    }
    else
    {
      v23 = 0;
      while ( v23 < *(int *)(a1 + 12) )
      {
        sub_9E56C(a1 + 160, src, v26);
        v8 = *(int *)(a1 + 232) == 2 && !sub_91B10();
        if ( v8 )
        {
          for ( j = 0; j < v25; ++j )
          {
            v9 = src[2 * j];
            src[2 * j] = src[2 * j + 1];
            src[2 * j + 1] = v9;
          }
        }
        v10 = !(unsigned int)a2->depth() && *(int *)(a1 + 232) == 2;
        if ( v10 )
        {
          for ( k = 0; k < v25; ++k )
            src[k] = *(char *)&src[2 * k] >> 8;
        }
        if ( v24 == *(int *)(a1 + 228) )
        {
          memcpy(dest, src, n);
        }
        else if ( v28 )
        {
          v16 = 0;
          if ( *((uint64 *)v28 + 33) )
          {
            v11 = (uint64 ( *)(char *, char *, uint64, uint64, uint64))*((uint64 *)v28 + 33);
            v12 = a2->depth();
            v16 = v11(src, dest, *(unsigned int *)(a1 + 8), v24, v12);
          }
          if ( v16 != 1 )
          {
            v13 = a2->depth();
            sub_91CE6(
              (unsigned uint64)src,
              (unsigned int *)v28 + 68,
              *(int *)(a1 + 228),
              *(int *)(a1 + 8),
              dest,
              v24,
              v13);
          }
        }
        else
        {
          v14 = a2->depth();
          sub_91CE6(
            (unsigned uint64)src,
            (unsigned int *)&v32,
            *(int *)(a1 + 228),
            *(int *)(a1 + 8),
            dest,
            v24,
            v14);
        }
        ++v23;
        dest += n;
      }
    }
    v3 = 1;
  }
  sub_87574((uint64)&v38);
  sub_87574((uint64)&v37);
  return v3;
}
// 69F50: using guessed type uint64  __cxa_begin_catch(uint64);
// 6ED90: using guessed type uint64  cv::MatStep::operator unsigned long(uint64);
// 6F2A0: using guessed type uint64  __cxa_end_catch(uint64);


