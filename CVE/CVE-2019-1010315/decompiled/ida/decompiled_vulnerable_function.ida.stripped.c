__int64 __fastcall sub_F9E0(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15
  FILE *v6; // r13
  int *v7; // rbp
  __int64 v8; // rbx
  bool v9; // cf
  bool v10; // zf
  unsigned int v11; // ebx
  int *v13; // rsi
  const char *v14; // rdi
  signed __int64 v15; // rcx
  bool v16; // cf
  bool v17; // zf
  const char *v18; // rdi
  signed __int64 v19; // rcx
  size_t *v20; // rsi
  size_t v21; // r12
  char v22; // al
  bool v23; // cf
  bool v24; // zf
  const char *v25; // rdi
  signed __int64 v26; // rcx
  size_t *v27; // rsi
  char v28; // al
  bool v29; // cf
  bool v30; // zf
  bool v31; // cf
  bool v32; // zf
  _BYTE *v33; // rsi
  const char *v34; // rdi
  signed __int64 v35; // rcx
  const char *v36; // rdi
  signed __int64 v37; // rcx
  size_t *v38; // rsi
  unsigned int v39; // ebx
  unsigned __int64 v40; // r12
  signed __int64 v41; // rbx
  __int64 v42; // r9
  bool v43; // cf
  bool v44; // zf
  const char *v45; // rdi
  signed __int64 v46; // rcx
  size_t *v47; // rsi
  char v48; // al
  bool v49; // cf
  bool v50; // zf
  const char *v51; // rdi
  signed __int64 v52; // rcx
  size_t *v53; // rsi
  char v54; // al
  bool v55; // cf
  bool v56; // zf
  const char *v57; // rdi
  signed __int64 v58; // rcx
  size_t *v59; // rsi
  int v60; // eax
  bool v61; // cf
  bool v62; // zf
  int v63; // edx
  int v64; // eax
  const char *v65; // rdi
  signed __int64 v66; // rcx
  _BYTE *v67; // rsi
  unsigned __int16 v68; // ax
  int v69; // eax
  int v70; // eax
  bool v71; // cf
  bool v72; // zf
  int v73; // edx
  int v74; // er13
  unsigned __int64 v75; // r9
  const char *v76; // r10
  const char *v77; // r11
  signed __int64 v78; // rcx
  _BYTE *v79; // rsi
  const char *v80; // rdi
  char v81; // al
  bool v82; // cf
  bool v83; // zf
  const char *v84; // rdi
  signed __int64 v85; // rcx
  _BYTE *v86; // rsi
  char v87; // al
  bool v88; // cf
  bool v89; // zf
  signed __int64 v90; // rcx
  _BYTE *v91; // rsi
  const char *v92; // rdi
  char v93; // al
  bool v94; // cf
  bool v95; // zf
  signed __int64 v96; // rcx
  _BYTE *v97; // rsi
  const char *v98; // rdi
  char v99; // al
  bool v100; // cf
  bool v101; // zf
  int v102; // eax
  char *v103; // rdi
  const char *v104; // rdi
  signed __int64 v105; // rcx
  _BYTE *v106; // rsi
  char v107; // al
  bool v108; // cf
  bool v109; // zf
  const char *v110; // rdi
  signed __int64 v111; // rcx
  _BYTE *v112; // rsi
  char v113; // al
  bool v114; // cf
  bool v115; // zf
  const char *v116; // rdi
  signed __int64 v117; // rcx
  _BYTE *v118; // rsi
  char v119; // al
  bool v120; // cf
  bool v121; // zf
  const char *v122; // rdi
  signed __int64 v123; // rcx
  _BYTE *v124; // rsi
  signed __int64 v125; // r12
  unsigned __int64 v126; // ST38_8
  const char *v127; // ST30_8
  const char *v128; // ST20_8
  __int64 v129; // [rsp+8h] [rbp-B0h]
  void *v130; // [rsp+10h] [rbp-A8h]
  char *v131; // [rsp+10h] [rbp-A8h]
  _BYTE *ptr; // [rsp+18h] [rbp-A0h]
  unsigned __int16 v133; // [rsp+20h] [rbp-98h]
  FILE *v134; // [rsp+28h] [rbp-90h]
  unsigned __int16 v135; // [rsp+4Ah] [rbp-6Eh]
  unsigned int v136; // [rsp+4Ch] [rbp-6Ch]
  unsigned int v137; // [rsp+50h] [rbp-68h]
  size_t size; // [rsp+54h] [rbp-64h]
  int v139; // [rsp+5Ch] [rbp-5Ch]
  int v140; // [rsp+60h] [rbp-58h]
  unsigned __int64 v141; // [rsp+64h] [rbp-54h]
  int v142; // [rsp+6Ch] [rbp-4Ch]
  unsigned __int64 v143; // [rsp+78h] [rbp-40h]

  v5 = a5;
  v6 = stream;
  v7 = a3;
  v129 = a4;
  v143 = __readfsqword(0x28u);
  v8 = sub_117F0();
  v140 = *v7;
  if ( !(unsigned int)sub_11710(stream) )
    goto LABEL_3;
  v9 = v136 < 0xC;
  v10 = v136 == 12;
  if ( v136 != 12 )
    goto LABEL_3;
  v13 = &v142;
  v14 = "DSD ";
  v15 = 4LL;
  do
  {
    if ( !v15 )
      break;
    v9 = *(_BYTE *)v13 < (const unsigned __int8)*v14;
    v10 = *(_BYTE *)v13 == *v14;
    v13 = (int *)((char *)v13 + 1);
    ++v14;
    --v15;
  }
  while ( v10 );
  if ( (!v9 && !v10) != v9 )
  {
LABEL_3:
    v11 = 1;
    sub_11570((unsigned __int64)"%s is not a valid .DFF file!");
    return v11;
  }
  if ( !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v129, &v140, 16LL) )
  {
LABEL_134:
    v11 = 1;
    WavpackGetErrorMessage(v129);
    sub_11570((unsigned __int64)"%s");
    return v11;
  }
  WavpackBigEndianToNative(&v140, "4D4");
  if ( v8 && !(*(_BYTE *)(v5 + 17) & 8) && v141 < 0xFFFFFFFFFFFFFFFFLL && v141 != 0 && v141 + 12 != v8 )
  {
    v11 = 1;
    sub_11570((unsigned __int64)"%s is not a valid .DFF file (by total size)!");
    return v11;
  }
  if ( dword_2190D8 )
    sub_11570((unsigned __int64)"file header indicated length = %lld");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !(unsigned int)sub_11710(v6) || v136 != 12 )
          goto LABEL_3;
        if ( !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v129, &size, 12LL) )
          goto LABEL_134;
        WavpackBigEndianToNative(&size, "4D");
        v16 = 0;
        v17 = dword_2190D8 == 0;
        if ( dword_2190D8 )
          sub_11570((unsigned __int64)"chunk header indicated length = %lld");
        v18 = "FVER";
        v19 = 4LL;
        v20 = &size;
        v21 = *(size_t *)((char *)&size + 4);
        do
        {
          if ( !v19 )
            break;
          v16 = *(_BYTE *)v20 < (const unsigned __int8)*v18;
          v17 = *(_BYTE *)v20 == *v18;
          v20 = (size_t *)((char *)v20 + 1);
          ++v18;
          --v19;
        }
        while ( v17 );
        v22 = (!v16 && !v17) - v16;
        v23 = 0;
        v24 = v22 == 0;
        if ( v22 )
          break;
        if ( *(size_t *)((char *)&size + 4) != 4 || !(unsigned int)sub_11710(v6) || v136 != 4 )
        {
          sub_11570((unsigned __int64)"%s is not a valid .DFF file!");
          return 1;
        }
        if ( !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v129, &v137, 4LL) )
        {
          WavpackGetErrorMessage(v129);
          sub_11570((unsigned __int64)"%s");
          return 1;
        }
        WavpackBigEndianToNative(&v137, "L");
        if ( dword_2190D8 )
          sub_11570((unsigned __int64)"dsdiff file version = 0x%08x");
      }
      v25 = "PROP";
      v26 = 4LL;
      v27 = &size;
      do
      {
        if ( !v26 )
          break;
        v23 = *(_BYTE *)v27 < (const unsigned __int8)*v25;
        v24 = *(_BYTE *)v27 == *v25;
        v27 = (size_t *)((char *)v27 + 1);
        ++v25;
        --v26;
      }
      while ( v24 );
      v28 = (!v23 && !v24) - v23;
      v29 = 0;
      v30 = v28 == 0;
      if ( !v28 )
        break;
      v36 = "DSD ";
      v37 = 4LL;
      v38 = &size;
      do
      {
        if ( !v37 )
          break;
        v29 = *(_BYTE *)v38 < (const unsigned __int8)*v36;
        v30 = *(_BYTE *)v38 == *v36;
        v38 = (size_t *)((char *)v38 + 1);
        ++v36;
        --v37;
      }
      while ( v30 );
      v11 = (char)((!v29 && !v30) - v29);
      if ( (!v29 && !v30) == v29 )
      {
        v125 = *(signed __int64 *)((char *)&size + 4) / *(signed int *)(v5 + 28);
        if ( dword_2190D8 )
          sub_11570((unsigned __int64)"setting configuration with %lld samples");
        if ( (unsigned int)WavpackSetConfiguration64(v129, v5, v125, 0LL) )
          return v11;
        WavpackGetErrorMessage(v129);
        sub_11570((unsigned __int64)"%s: %s");
        return 1;
      }
      v39 = (HIDWORD(size) + 1) & 0xFFFFFFFE;
      if ( v39 > 0x400000 )
        goto LABEL_3;
      v130 = malloc((signed int)v39);
      if ( dword_2190D8 )
        sub_11570((unsigned __int64)"extra unknown chunk \"%c%c%c%c\" of %d bytes");
      if ( !(unsigned int)sub_11710(v6)
        || v39 != v136
        || !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v129, v130, v39) )
      {
        v11 = 1;
        WavpackGetErrorMessage(v129);
        sub_11570((unsigned __int64)"%s");
        free(v130);
        return v11;
      }
      free(v130);
    }
    if ( *(size_t *)((char *)&size + 4) - 4 > 0x3FC )
      goto LABEL_3;
    if ( dword_2190D8 )
    {
      sub_11570((unsigned __int64)"got PROP chunk of %d bytes total");
      v21 = *(size_t *)((char *)&size + 4);
    }
    ptr = malloc(v21);
    if ( !(unsigned int)sub_11710(v6) || v136 != *(size_t *)((char *)&size + 4) )
      break;
    v31 = 0;
    v32 = (*(_BYTE *)(v5 + 17) & 2) == 0;
    if ( !(*(_BYTE *)(v5 + 17) & 2) )
    {
      v102 = WavpackAddWrapper(v129, ptr, v136);
      v31 = 0;
      v32 = v102 == 0;
      if ( !v102 )
      {
        WavpackGetErrorMessage(v129);
        v103 = "%s";
        goto LABEL_124;
      }
    }
    v33 = ptr;
    v34 = "SND ";
    v35 = 4LL;
    do
    {
      if ( !v35 )
        break;
      v31 = *v33 < (const unsigned __int8)*v34;
      v32 = *v33++ == *v34++;
      --v35;
    }
    while ( v32 );
    if ( (!v31 && !v32) == v31 )
    {
      v133 = 0;
      v40 = (unsigned __int64)(ptr + 4);
      v131 = &ptr[*(size_t *)((char *)&size + 4)];
LABEL_62:
      while ( (unsigned __int64)&v131[-v40] > 0xB )
      {
        while ( 1 )
        {
          v41 = v40 + 12;
          size = *(_QWORD *)v40;
          v139 = *(_DWORD *)(v40 + 8);
          WavpackBigEndianToNative(&size, "4D");
          v42 = *(size_t *)((char *)&size + 4);
          if ( *(signed __int64 *)((char *)&size + 4) <= 0 )
            goto LABEL_133;
          v43 = *(size_t *)((char *)&size + 4) < (unsigned __int64)&v131[-v41];
          v44 = *(size_t *)((char *)&size + 4) == (_QWORD)&v131[-v41];
          if ( *(signed __int64 *)((char *)&size + 4) > (signed __int64)&v131[-v41] )
            goto LABEL_133;
          v45 = "FS  ";
          v46 = 4LL;
          v47 = &size;
          do
          {
            if ( !v46 )
              break;
            v43 = *(_BYTE *)v47 < (const unsigned __int8)*v45;
            v44 = *(_BYTE *)v47 == *v45;
            v47 = (size_t *)((char *)v47 + 1);
            ++v45;
            --v46;
          }
          while ( v44 );
          v48 = (!v43 && !v44) - v43;
          v49 = 0;
          v50 = v48 == 0;
          if ( !v48 )
          {
            v49 = *(size_t *)((char *)&size + 4) < 4;
            v50 = *(size_t *)((char *)&size + 4) == 4;
            if ( *(size_t *)((char *)&size + 4) == 4 )
            {
              v137 = *(_DWORD *)(v40 + 12);
              WavpackBigEndianToNative(&v137, "L");
              v40 = *(size_t *)((char *)&size + 4) + v41;
              if ( dword_2190D8 )
                sub_11570((unsigned __int64)"got sample rate of %u Hz");
              goto LABEL_62;
            }
          }
          v51 = "CHNL";
          v52 = 4LL;
          v53 = &size;
          do
          {
            if ( !v52 )
              break;
            v49 = *(_BYTE *)v53 < (const unsigned __int8)*v51;
            v50 = *(_BYTE *)v53 == *v51;
            v53 = (size_t *)((char *)v53 + 1);
            ++v51;
            --v52;
          }
          while ( v50 );
          v54 = (!v49 && !v50) - v49;
          v55 = *(size_t *)((char *)&size + 4) < 1;
          v56 = *(size_t *)((char *)&size + 4) == 1;
          if ( *(signed __int64 *)((char *)&size + 4) > 1 )
          {
            v55 = 0;
            v56 = v54 == 0;
            if ( !v54 )
              break;
          }
          v57 = "CMPR";
          v58 = 4LL;
          v59 = &size;
          do
          {
            if ( !v58 )
              break;
            v55 = *(_BYTE *)v59 < (const unsigned __int8)*v57;
            v56 = *(_BYTE *)v59 == *v57;
            v59 = (size_t *)((char *)v59 + 1);
            ++v57;
            --v58;
          }
          while ( v56 );
          v60 = (char)((!v55 && !v56) - v55);
          if ( *(signed __int64 *)((char *)&size + 4) <= 3 || (v61 = 0, v62 = v60 == 0, v60) )
          {
            if ( dword_2190D8 )
            {
              sub_11570((unsigned __int64)"got PROP/SND chunk type \"%c%c%c%c\" of %d bytes");
              v42 = *(size_t *)((char *)&size + 4);
            }
          }
          else
          {
            v65 = "DSD ";
            v66 = 4LL;
            v67 = (_BYTE *)(v40 + 12);
            do
            {
              if ( !v66 )
                break;
              v61 = *v67 < (const unsigned __int8)*v65;
              v62 = *v67++ == *v65++;
              --v66;
            }
            while ( v62 );
            if ( (!v61 && !v62) != v61 )
            {
              sub_11570((unsigned __int64)"DSDIFF files must be uncompressed, not \"%c%c%c%c\"!");
              free(ptr);
              return 1;
            }
          }
          v40 = v41 + v42;
          if ( (unsigned __int64)&v131[-v41 - v42] <= 0xB )
            goto LABEL_83;
        }
        v68 = *(_WORD *)(v40 + 12);
        v40 += 14LL;
        v135 = v68;
        WavpackBigEndianToNative(&v135, "S");
        v69 = HIDWORD(size) + 1;
        if ( HIDWORD(size) - 2 >= 0 )
          v69 = HIDWORD(size) - 2;
        v70 = v69 >> 2;
        if ( !v135 || v135 < (unsigned __int16)v70 )
        {
LABEL_133:
          sub_11570((unsigned __int64)"%s is not a valid .DFF file!");
          free(ptr);
          return 1;
        }
        v71 = 0;
        v72 = (_WORD)v70 == 0;
        v73 = dword_2190D8;
        if ( (_WORD)v70 )
        {
          v134 = v6;
          v74 = v133;
          v75 = v40 + 4LL * (unsigned __int16)(v70 - 1) + 4;
          v76 = "SRGT";
          v77 = "MRGT";
          do
          {
            v78 = 4LL;
            v79 = (_BYTE *)v40;
            v80 = "SLFT";
            do
            {
              if ( !v78 )
                break;
              v71 = *v79 < (const unsigned __int8)*v80;
              v72 = *v79++ == *v80++;
              --v78;
            }
            while ( v72 );
            v81 = (!v71 && !v72) - v71;
            v82 = 0;
            v83 = v81 == 0;
            if ( !v81 )
              goto LABEL_166;
            v84 = "MLFT";
            v85 = 4LL;
            v86 = (_BYTE *)v40;
            do
            {
              if ( !v85 )
                break;
              v82 = *v86 < (const unsigned __int8)*v84;
              v83 = *v86++ == *v84++;
              --v85;
            }
            while ( v83 );
            v87 = (!v82 && !v83) - v82;
            v88 = 0;
            v89 = v87 == 0;
            if ( v87 )
            {
              v90 = 4LL;
              v91 = (_BYTE *)v40;
              v92 = v76;
              do
              {
                if ( !v90 )
                  break;
                v88 = *v91 < (const unsigned __int8)*v92;
                v89 = *v91++ == *v92++;
                --v90;
              }
              while ( v89 );
              v93 = (!v88 && !v89) - v88;
              v94 = 0;
              v95 = v93 == 0;
              if ( !v93 )
                goto LABEL_167;
              v96 = 4LL;
              v97 = (_BYTE *)v40;
              v98 = v77;
              do
              {
                if ( !v96 )
                  break;
                v94 = *v97 < (const unsigned __int8)*v98;
                v95 = *v97++ == *v98++;
                --v96;
              }
              while ( v95 );
              v99 = (!v94 && !v95) - v94;
              v100 = 0;
              v101 = v99 == 0;
              if ( v99 )
              {
                v104 = "LS  ";
                v105 = 4LL;
                v106 = (_BYTE *)v40;
                do
                {
                  if ( !v105 )
                    break;
                  v100 = *v106 < (const unsigned __int8)*v104;
                  v101 = *v106++ == *v104++;
                  --v105;
                }
                while ( v101 );
                v107 = (!v100 && !v101) - v100;
                v108 = 0;
                v109 = v107 == 0;
                if ( v107 )
                {
                  v110 = "RS  ";
                  v111 = 4LL;
                  v112 = (_BYTE *)v40;
                  do
                  {
                    if ( !v111 )
                      break;
                    v108 = *v112 < (const unsigned __int8)*v110;
                    v109 = *v112++ == *v110++;
                    --v111;
                  }
                  while ( v109 );
                  v113 = (!v108 && !v109) - v108;
                  v114 = 0;
                  v115 = v113 == 0;
                  if ( v113 )
                  {
                    v116 = "C   ";
                    v117 = 4LL;
                    v118 = (_BYTE *)v40;
                    do
                    {
                      if ( !v117 )
                        break;
                      v114 = *v118 < (const unsigned __int8)*v116;
                      v115 = *v118++ == *v116++;
                      --v117;
                    }
                    while ( v115 );
                    v119 = (!v114 && !v115) - v114;
                    v120 = 0;
                    v121 = v119 == 0;
                    if ( v119 )
                    {
                      v122 = "LFE ";
                      v123 = 4LL;
                      v124 = (_BYTE *)v40;
                      do
                      {
                        if ( !v123 )
                          break;
                        v120 = *v124 < (const unsigned __int8)*v122;
                        v121 = *v124++ == *v122++;
                        --v123;
                      }
                      while ( v121 );
                      if ( (!v120 && !v121) == v120 )
                      {
                        v74 |= 8u;
                      }
                      else if ( v73 )
                      {
                        v126 = v75;
                        v127 = v77;
                        v128 = v76;
                        sub_11570((unsigned __int64)"undefined channel ID %c%c%c%c");
                        v73 = dword_2190D8;
                        v75 = v126;
                        v77 = v127;
                        v76 = v128;
                      }
                    }
                    else
                    {
                      v74 |= 4u;
                    }
                  }
                  else
                  {
                    v74 |= 0x20u;
                  }
                }
                else
                {
                  v74 |= 0x10u;
                }
              }
              else
              {
LABEL_167:
                v74 |= 2u;
              }
            }
            else
            {
LABEL_166:
              v74 |= 1u;
            }
            v40 += 4LL;
            v71 = v75 < v40;
            v72 = v75 == v40;
          }
          while ( v75 != v40 );
          v133 = v74;
          v6 = v134;
        }
        if ( v73 )
          sub_11570((unsigned __int64)"%d channels, mask = 0x%08x");
      }
LABEL_83:
      if ( v133 )
      {
        if ( *(_DWORD *)(v5 + 48) || (v63 = *(_DWORD *)(v5 + 16), BYTE1(v63) & 4) )
        {
          sub_11570((unsigned __int64)"this DSDIFF file already has channel order information!");
          free(ptr);
          return 1;
        }
        *(_DWORD *)(v5 + 48) = v133;
      }
      else
      {
        v63 = *(_DWORD *)(v5 + 16);
      }
      *(_QWORD *)(v5 + 8) = 4294967304LL;
      v64 = v135;
      *(_DWORD *)(v5 + 16) = v63 | 0x20;
      *(_DWORD *)(v5 + 28) = v64;
      *(_DWORD *)(v5 + 44) = v137 >> 3;
    }
    else if ( dword_2190D8 )
    {
      sub_11570((unsigned __int64)"got unknown PROP chunk type \"%c%c%c%c\" of %d bytes");
    }
    free(ptr);
  }
  v103 = "%s is not a valid .DFF file!";
LABEL_124:
  v11 = 1;
  sub_11570((char)v103);
  free(ptr);
  return v11;
}
