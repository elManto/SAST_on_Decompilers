#include <glob.h>
#include <iconv.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <emmintrin.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//Global variables
QWORD _gmon_start__;
QWORD dword_2190D8;
QWORD dword_2190CC;
QWORD dword_21906C;
__int64 (* WavpackGetLibraryVersionString)(_QWORD, _QWORD);
QWORD unk_12CF0;
QWORD dword_2190A0;
QWORD dword_2190B4;
QWORD dword_2190AC;
QWORD dword_21909C;
QWORD dword_219098;
QWORD off_218220;
QWORD dword_219094;
QWORD dword_2190A8;
QWORD dword_2190A4;
QWORD dword_2190B8;
QWORD dword_2190C0;
QWORD dword_2190C4;
QWORD dword_2190BC;
QWORD dword_2190D0;
QWORD dword_2190B0;
QWORD dword_219068;
QWORD dword_2190C8;
QWORD qword_219070;
QWORD algn_7CCB;
QWORD unk_219010;
QWORD ITM_deregisterTMCloneTable;
QWORD byte_219050;
QWORD __cxa_finalize;
QWORD off_219008;
QWORD unk_129E4;
QWORD unk_129E8;
QWORD unk_129EC;
QWORD xmmword_15D20;
QWORD xmmword_15D30;
QWORD xmmword_15D40;
QWORD xmmword_15D50;
QWORD xmmword_15D70;
QWORD unk_2188E0;
QWORD xmmword_15D80;
QWORD xmmword_15D90;
QWORD xmmword_16430;
QWORD xmmword_16420;
QWORD xmmword_16410;
QWORD xmmword_16400;
QWORD unk_16440;
QWORD unk_2182F0;
QWORD unk_2182C0;
QWORD unk_16C35;
QWORD dword_2190D4;
QWORD unk_170CE;
QWORD xmmword_172A0;
QWORD xmmword_172B0;
QWORD xmmword_172C0;
QWORD xmmword_172D0;
QWORD xmmword_172E0;
QWORD xmmword_172F0;
QWORD xmmword_17300;
QWORD xmmword_17310;
QWORD xmmword_17320;
QWORD xmmword_17330;
QWORD xmmword_17340;
QWORD xmmword_17350;
QWORD xmmword_173B0;
QWORD xmmword_173C0;
QWORD xmmword_17370;
QWORD xmmword_17380;
QWORD xmmword_17390;
QWORD xmmword_173A0;
QWORD xmmword_17360;
QWORD* off_218748;
QWORD off_218218;
QWORD* off_218210;


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_2FF0();
// double log10(double x);
// int fileno(FILE *stream);
// void *memset(void *s, int c, size_t n);
// char *stpcpy(char *dest, const char *src);
// int utimes(const char *file, const struct timeval tvp[2]);
// int puts(const char *s);
// int fseek(FILE *stream, __int64 off, int whence);
// void __noreturn exit(int status);
// int strcasecmp(const char *s1, const char *s2);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// char *strpbrk(const char *s, const char *accept);
// int strncmp(const char *s1, const char *s2, size_t n);
// void *malloc(size_t size);
// FILE *fopen(const char *filename, const char *modes);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int fputc(int c, FILE *stream);
// void free(void *ptr);
// size_t strlen(const char *s);
// int ferror(FILE *stream);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// const unsigned __int16 **__ctype_b_loc(void);
// int fgetc(FILE *stream);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// char *strstr(const char *haystack, const char *needle);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *strcat(char *dest, const char *src);
// int fputs(const char *s, FILE *stream);
// __int64 strtol(const char *nptr, char **endptr, int base);
// void *memmove(void *dest, const void *src, size_t n);
// char *strchr(const char *s, int c);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int __fxstat(int ver, int fildes, struct stat *stat_buf);
// char *strdup(const char *s);
// int strcmp(const char *s1, const char *s2);
// double exp2(double x);
// char *strcpy(char *dest, const char *src);
// int glob(const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t *pglob);
// const __int32_t **__ctype_tolower_loc(void);
// int memcmp(const void *s1, const void *s2, size_t n);
// void *calloc(size_t nmemb, size_t size);
// void globfree(glob_t *pglob);
// int fclose(FILE *stream);
// int remove(const char *filename);
// int ftruncate(int fd, __off_t length);
// int sigemptyset(sigset_t *set);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// void *realloc(void *ptr, size_t size);
// char *setlocale(int category, const char *locale);
// double floor(double x);
// void *memcpy(void *dest, const void *src, size_t n);
// int iconv_close(iconv_t cd);
// int rename(const char *old, const char *new);
// double strtod(const char *nptr, char **endptr);
// int fflush(FILE *stream);
_BOOL4  main(int a1, char **a2, char **a3);
// void  __noreturn start(__int64 a1, void (*a2)(void));
__int64 (**sub_7CD0())(void);
__int64 sub_7D10();
__int64 (**sub_7D60())(void);
__int64 sub_7DA0();
unsigned __int64  sub_7DB0(void *dest, __int64 a2, signed int a3, int a4);
unsigned __int64  sub_7EB0(void *dest, unsigned __int8 *a2, int a3, int a4, int a5);
signed __int64  sub_7FF0(int *a1, __int64 a2, double a3);
signed __int64  sub_85B0(__int64 a1, _DWORD *a2, char a3, signed int a4, int a5);
unsigned __int64  sub_8A80(double a1);
__int64  sub_8B10(__int64 a1, _QWORD *a2);
__int64  sub_92C0(__int64 a1, __int64 a2, unsigned int a3);
__int64  sub_9380(const char *a1, char *a2, char *a3, const __m128i *a4);
FILE * sub_C560(const char *a1);
__int64  sub_C6B0(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5);
signed __int64  sub_D130(FILE *a1, __int64 a2, __int64 a3);
__int64  sub_D700(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5, double a6);
signed __int64  sub_DFC0(FILE *a1, __int64 a2, __int64 a3);
__int64  sub_E340(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5);
__int64  sub_F9E0(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5);
signed __int64  sub_104C0(FILE *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64  sub_10A20(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5, double a6);
void sub_11140();
_BOOL4  sub_11150(char *filename, char *file);
signed __int64  sub_11230(const char *a1);
char * sub_112A0(char *dest);
const char * sub_113E0(const char *a1);
__int64 sub_11410();
int sub_11530();
unsigned __int64 sub_11570(__int64 a1, ...);
unsigned __int64 sub_11680();
__int64 sub_11700();
_BOOL4  sub_11710(FILE *stream, __int64 a2, unsigned int a3, _DWORD *a4);
_BOOL4  sub_11780(FILE *stream, __int64 a2, unsigned int a3, _DWORD *a4);
__int64  sub_117F0(FILE *a1);
__int64 j__ftell(FILE *stream);
int  sub_11870(FILE *a1, __int64 a2);
_BOOL4  sub_118A0(FILE *a1);
_BOOL4  sub_118D0(FILE *stream);
_BOOL4  sub_11910(const char *a1);
int  sub_11940(__int64 a1);
__int64  sub_11980(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, _DWORD *a5, int a6);
__int64  sub_12820(__int64 a1, unsigned __int64 a2, signed int a3, __int64 a4, _DWORD *a5);
void  init(unsigned int a1, __int64 a2, __int64 a3);
void fini(void); // idb
int  sub_129B0(char *filename, struct stat *stat_buf);
int  sub_129C0(int fildes, struct stat *stat_buf);
void term_proc();
// int  _libc_start_main(int ( *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);

//-------------------------------------------------------------------------
// Data declarations

size_t size = 282584257676671uLL; // idb
char aPreQuantize_0[12] = "pre-quantize"; // idb
char aUsageWavpackOp_0[] = " Usage:\n    WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\n\n    The default operation is lossless. Multiple input files may be specified\n    and the source file type is automatically determined (see accepted formats\n    below). Raw PCM data may also be used (see --raw-pcm option).\n\n All Utilities:             WAVPACK:  create or transcode WavPack files\n                            WVUNPACK: unpack or verify existing WavPack files\n                            WVGAIN:   apply ReplayGain to WavPack files\n                            WVTAG:    apply or edit metadata tags on WavPack files\n\n Input Formats:             .wav (default, includes bwf/rf64 varients)\n                            .wv  (transcode operation, tags copied)\n                            .caf (Core Audio Format)\n                            .w64 (Sony Wave64)\n                            .dff (Philips DSDIFF)\n                            .dsf (Sony DSD stream)\n\n Options:\n    -a                      Adobe Audition (CoolEdit) mode for 32-bit floats\n    --allow-huge-tags       allow tag data up to 16 MB (embedding > 1 MB is not\n                             recommended for portable devices and may not work\n                             with some programs including WavPack pre-4.70)\n    -bn                     enable hybrid compression\n                              n = 2.0 to 23.9 bits/sample, or\n                              n = 24-9600 kbits/second (kbps)\n                              add -c to create correction file (.wvc)\n    --blocksize=n           specify block size in samples (max = 131072 and\n                               min = 16 with --merge-blocks, otherwise 128)\n    -c                      hybrid lossless mode (use with -b to create\n                             correction file (.wvc) in hybrid mode)\n    -cc                     maximum hybrid lossless compression (but degrades\n                             decode speed and may result in lower quality)\n    --channel-order=<list>  specify (comma separated) channel order if not\n                             Microsoft standard (which is FL,FR,FC,LFE,BL,BR,\n                             FLC,FRC,BC,SL,SR,TC,TFL,TFC,TFR,TBL,TBC,TBR);\n                             specify '...' to indicate that channels are not\n                             assigned to specific speakers, or terminate list\n                             with '...' to indicate that any channels beyond\n                             those specified are unassigned\n    --cross-decorr          use cross-channel correlation in hybrid mode (on by\n                             default in lossless mode and with -cc option)\n    -d                      delete source file if successful (use with caution!)\n    -f                      fast mode (faster encode and decode, but some\n                             compromise in compression ratio)\n    -h                      high quality (better compression ratio, but slower\n                             encode and decode than default mode)\n    -hh                     very high quality (best compression, but slowest\n                             and NOT recommended for portable hardware use)\n    --help                  this extended help display\n    -i                      ignore length in file header (no pipe output allowed)\n    --import-id3            attempt to import ID3v2 tags from the trailer of files\n                             (standard on DSF, optional on WAV and DSDIFF)\n    -jn                     joint-stereo override (0 = left/right, 1 = mid/side)\n    -m                      compute & store MD5 signature of raw audio data\n    --merge-blocks          merge consecutive blocks with equal redundancy\n                             (used with --blocksize option and is useful for\n                             files generated by the lossyWAV program or\n                             decoded HDCD files)\n    -n                      calculate average and peak quantization noise\n                             (for hybrid mode only, reference fullscale sine)\n    --no-utf8-convert       don't recode passed tags from local encoding to\n                             UTF-8, assume they are in UTF-8 already\n    -o FILENAME | PATH      specify output filename or path\n    --pair-unassigned-chans encode unassigned channels into stereo pairs\n    --pre-quantize=bits     pre-quantize samples to <bits> BEFORE encoding and MD5\n                             (common use would be --pre-quantize=20 for 24-bit or\n                             float material recorded with typical converters)\n    -q                      quiet (keep console output to a minimum)\n    -r                      remove file headers (file-appropriate headers\n                             will be regenerated during unpacking)\n    --raw-pcm               input data is raw pcm (default is 44100 Hz, 16-bit\n                             signed, 2-channels, little-endian)\n    --raw-pcm=sr,bps[f|s|u],nch,[le|be]\n                            input data is raw pcm with specified sample rate,\n                             sample bit depth (float or signed or unsigned), number\n                             of channels, and little-endian or big-endian\n                             (defaulted parameters may be omitted)\n    --raw-pcm-skip=begin[,end]\n                            skip <begin> bytes before encoding (i.e., a header)\n                             and <end> bytes at the end-of-file (i.e., a trailer)\n    -sn                     override default noise shaping where n is a float\n                             value between -1.0 and 1.0; negative values move noise\n                             lower in freq, positive values move noise higher\n                             in freq, use '0' for no shaping (white noise)\n    -t                      copy input file's time stamp to output file(s)\n    --use-dns               force use of dynamic noise shaping (hybrid mode only)\n    -v                      verify output file integrity after write (no pipes)\n    --version               write the version to stdout\n    -w Encoder              write actual \"Encoder\" information to APEv2 tag\n    -w Settings             write actual \"Settings\" information to APEv2 tag\n    -w \"Field=Value\"        write specified text metadata to APEv2 tag\n    -w \"Field=@file.ext\"    write specified text metadata from file to APEv2\n                             tag, normally used for embedded cuesheets and logs\n                             (field names \"Cuesheet\" and \"Log\")\n    --write-binary-tag \"Field=@file.ext\"\n                            write the specified binary metadata file to APEv2\n                             tag, normally used for cover art with the specified\n                             field name \"Cover Art (Front)\"\n    -x[n]                   extra encode processing (optional n = 1 to 6, 1=default)\n                             -x1 to -x3 to choose best of predefined filters\n                             -x4 to -x6 to generate custom filters (very slow!)\n    -y                      yes to all warnings (use with caution!)\n    -z1                     set console title to indicate progress\n\n Web:\n     Visit www.wavpack.com for latest version and complete information"; // idb
_BYTE byte_15C20[256] =
{
  0,
  128,
  64,
  192,
  32,
  160,
  96,
  224,
  16,
  144,
  80,
  208,
  48,
  176,
  112,
  240,
  8,
  136,
  72,
  200,
  40,
  168,
  104,
  232,
  24,
  152,
  88,
  216,
  56,
  184,
  120,
  248,
  4,
  132,
  68,
  196,
  36,
  164,
  100,
  228,
  20,
  148,
  84,
  212,
  52,
  180,
  116,
  244,
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227,
  19,
  147,
  83,
  211,
  51,
  179,
  115,
  243,
  11,
  139,
  75,
  203,
  43,
  171,
  107,
  235,
  27,
  155,
  91,
  219,
  59,
  187,
  123,
  251,
  7,
  135,
  71,
  199,
  39,
  167,
  103,
  231,
  23,
  151,
  87,
  215,
  55,
  183,
  119,
  247,
  15,
  143,
  79,
  207,
  47,
  175,
  111,
  239,
  31,
  159,
  95,
  223,
  63,
  191,
  127,
  255
}; // idb
unsigned __int16 word_170C0[7] = { 4u, 3u, 7u, 51u, 15u, 55u, 63u }; // idb
FILE *stdin; // idb
FILE *stderr; // idb
void *ptr; // idb
_BYTE byte_219080[20]; // idb


////----- (0000000000002FD8) ----------------------------------------------------
//__int64 (**init_proc())(void)
//{
//  __int64 (**result)(void); // rax
//
//  result = &_gmon_start__;
//  if ( &_gmon_start__ )
//    result = (__int64 (**)(void))_gmon_start__();
//  return result;
//}
//// 2194A8: using guessed type __int64 _gmon_start__(void);
//
////----- (0000000000002FF0) ----------------------------------------------------
//void sub_2FF0()
//{
//  JUMPOUT(&size);
//}

//----- (0000000000003780) ----------------------------------------------------
_BOOL4  main(int a1, char **a2, char **a3)
{
  int v4; // er13
  char **v5; // rbx
  char *v6; // rdi
  const char *v7; // rax
  char **v8; // r12
  unsigned int v9; // ebp
  signed int v10; // ebp
  char *v11; // rdi
  char *v12; // r12
  char *v13; // rax
  char *v14; // r13
  unsigned int v15; // eax
  bool v16; // cf
  bool v17; // zf
  __int64 v18; // rax
  signed __int64 v19; // rcx
  __int64 v20; // rsi
  const char *v21; // rdi
  char *v22; // r12
  __int64 v23; // rbp
  int v24; // eax
  int v25; // ebx
  signed __int64 v26; // rbx
  char *v27; // r13
  int v28; // eax
  const char *v29; // rdi
  int v30; // er14
  int v31; // eax
  int v32; // ebx
  __int64 v33; // r15
  int v34; // ebx
  char *v35; // rax
  size_t v36; // rdx
  size_t v37; // r13
  char v38; // al
  char v39; // dl
  __int64 v40; // rax
  unsigned int v41; // ecx
  unsigned int v42; // eax
  int v43; // eax
  float v44; // xmm0_4
  int v45; // eax
  int v46; // ebp
  signed __int64 v47; // r14
  size_t v48; // rax
  size_t v49; // r13
  char *v50; // rax
  const char *v51; // rax
  const char *v52; // rcx
  char v53; // al
  char *v54; // r14
  int v55; // er12
  size_t v56; // r12
  char *v57; // rax
  signed __int64 v58; // rdi
  signed __int64 v59; // r12
  char *v60; // r13
  void *v61; // rax
  size_t v62; // r14
  int v63; // eax
  char *v64; // rax
  _BOOL4 v65; // eax
  char *v66; // r12
  char *v67; // rax
  bool v68; // cf
  bool v69; // zf
  const char *v70; // rdi
  signed __int64 v71; // rcx
  char *v72; // rsi
  char v73; // al
  bool v74; // cf
  bool v75; // zf
  const char *v76; // rdi
  signed __int64 v77; // rcx
  char *v78; // rsi
  unsigned int v79; // eax
  const char *v80; // r12
  FILE *v81; // r14
  int v82; // eax
  const char *v83; // rax
  char *v84; // r12
  char *v85; // r12
  signed int v86; // edx
  void *v87; // rax
  __time_t v88; // r14
  char *v89; // r14
  signed int v90; // eax
  _BYTE *v91; // rdi
  const char *v92; // rax
  int v93; // eax
  const char **v94; // r13
  char *v95; // r12
  FILE *v96; // rax
  int v97; // ecx
  FILE *v98; // r15
  int v99; // edi
  signed __int64 v100; // rax
  unsigned __int64 v101; // rsi
  __int64 v102; // rdx
  int v103; // ebx
  _BYTE *v104; // rbp
  _QWORD *v105; // r8
  signed int v106; // eax
  FILE *v107; // rcx
  char *v108; // r15
  void *v109; // r12
  int v110; // ebx
  signed __int64 v111; // rax
  const char *v112; // r8
  signed __int64 v113; // rax
  signed __int64 v114; // rdx
  int v115; // er9
  FILE *v116; // ST18_8
  const char **v117; // rax
  int v118; // edi
  signed __int64 v119; // rax
  __int64 v120; // rdx
  char *v122; // rax
  char v123; // r14
  const char **v124; // r12
  char *v125; // rbx
  char *v126; // rbp
  const char *v127; // rdi
  const char *v128; // rax
  signed int v129; // er13
  char *v130; // rdi
  int v131; // ebp
  const char *v132; // rax
  size_t v133; // r14
  void *v134; // r15
  char *v135; // rax
  int v136; // er15
  void *v137; // r12
  char *v138; // r15
  __time_t v139; // rax
  char v140; // si
  unsigned __int64 v141; // rdx
  __int64 v142; // rax
  iconv_t v143; // r10
  iconv_t v144; // ST50_8
  int v145; // er13
  __int64 v146; // rax
  char *v147; // r12
  double v148; // xmm1_8
  unsigned __int64 v149; // kr78_8
  unsigned __int64 v150; // rdx
  __int128 *v151; // rsi
  char *v152; // rdi
  __int64 v153; // rax
  signed __int64 v154; // rcx
  int *v155; // rsi
  unsigned int v156; // er14
  signed __int64 v157; // rdx
  int v158; // er14
  __int64 v159; // rdx
  signed __int64 v160; // rcx
  __int64 *v161; // rdi
  signed __int64 v162; // rcx
  char **v163; // rdi
  FILE *v164; // rax
  const char *v165; // rax
  signed __int64 v166; // rsi
  char v167; // al
  char *v168; // r14
  int j; // er8
  int v170; // er13
  signed __int64 v171; // rax
  const char *v172; // rax
  FILE *v173; // rax
  struct timezone *v174; // rsi
  const char *v175; // rax
  unsigned __int8 v176; // r13
  __int64 v177; // rsi
  unsigned int v178; // er13
  __int64 v179; // rsi
  int v180; // eax
  void *v181; // r13
  __int64 v182; // r14
  unsigned __int64 v183; // rsi
  unsigned int v184; // er13
  unsigned int v185; // er13
  signed __int64 v186; // r14
  int v187; // eax
  int v188; // eax
  float *v189; // r14
  __int64 v190; // rbp
  signed __int64 v191; // r13
  int v192; // er12
  signed int v193; // ebx
  int *v194; // r11
  char *v195; // rdi
  int *v196; // rdx
  __int64 v197; // rax
  int v198; // esi
  double v199; // xmm0_8
  double v200; // xmm0_8
  double v201; // xmm1_8
  char *v202; // rcx
  signed __int64 v203; // rcx
  const char *v204; // r13
  const char *v205; // rdi
  size_t v206; // rbp
  int v207; // eax
  const char *v208; // r13
  size_t v209; // r14
  void *v210; // r15
  char *v211; // rax
  FILE *v212; // rbp
  char *v213; // rax
  unsigned __int64 v214; // rdx
  signed __int64 v215; // rcx
  signed __int64 v216; // r8
  signed __int64 v217; // rdi
  __int64 v218; // rax
  __int64 ii; // rax
  float *v220; // rbp
  signed __int64 v221; // r14
  int v222; // er13
  __int64 l; // r12
  float v224; // xmm6_4
  __int64 v225; // rsi
  const char *v226; // rax
  FILE *v227; // rax
  signed __int64 v228; // rax
  __int64 v229; // rax
  FILE *v230; // rax
  unsigned __int64 v231; // rdx
  const char *v232; // rax
  char v233; // al
  const char *v234; // rax
  __int64 m; // rax
  float v236; // ecx
  int v237; // edx
  const char *v238; // rax
  __int64 k; // rax
  __int64 v240; // rdx
  unsigned int v241; // er14
  signed int v242; // eax
  int *v243; // r13
  unsigned int v244; // er8
  signed int v245; // STA0_4
  unsigned int v246; // er13
  char *v247; // r14
  unsigned int v248; // STA4_4
  char *v249; // rsi
  char *v250; // rsi
  int v251; // er13
  struct timezone *v252; // rsi
  __int64 v253; // r14
  char *v254; // rdi
  char *v255; // r13
  const char *v256; // r14
  const char *v257; // r8
  int v258; // eax
  double v259; // xmm0_8
  char *v260; // r14
  char *v261; // rbp
  unsigned int v262; // ebx
  void *v263; // r13
  int v264; // eax
  unsigned int v265; // ST70_4
  void *v266; // rax
  void *v267; // rbx
  unsigned int v268; // eax
  signed int v269; // ST70_4
  __int64 v270; // r13
  signed int v271; // er14
  __int64 v272; // rdx
  char *v273; // rax
  __int64 v274; // rcx
  int v275; // eax
  unsigned int v276; // eax
  signed int v277; // er14
  _BOOL4 v278; // eax
  const char *v279; // rsi
  _BOOL4 v280; // eax
  const char *v281; // rsi
  double v282; // xmm0_8
  int v283; // eax
  int v284; // er13
  int v285; // ST90_4
  double v286; // ST08_8
  double v287; // ST70_8
  double v288; // ST68_8
  signed int v289; // eax
  int v290; // er13
  double v291; // xmm0_8
  char **v292; // r13
  __int64 v293; // r14
  unsigned int v294; // er12
  char *v295; // rbx
  signed int v296; // eax
  const unsigned __int16 *v297; // rcx
  __int64 i; // rdx
  signed __int64 v299; // rax
  char v300; // si
  signed int v301; // er12
  __int64 v302; // r14
  char v303; // ST50_1
  const unsigned __int16 **v304; // rax
  char *v305; // r8
  int v306; // eax
  char v307; // al
  int v308; // eax
  __int64 v309; // rbp
  const char *v310; // rdx
  int v311; // eax
  __int64 v312; // rcx
  __int64 v313; // rax
  char *v314; // r8
  int v315; // eax
  char *v316; // r8
  int v317; // er12
  int v318; // eax
  char *v319; // r8
  size_t *outbytesleft; // [rsp+8h] [rbp-2370h]
  size_t *outbyteslefta; // [rsp+8h] [rbp-2370h]
  int outbytesleftb; // [rsp+8h] [rbp-2370h]
  size_t *outbytesleftc; // [rsp+8h] [rbp-2370h]
  int v324; // [rsp+10h] [rbp-2368h]
  const char *v325; // [rsp+10h] [rbp-2368h]
  __int64 v326; // [rsp+10h] [rbp-2368h]
  const char **ptr; // [rsp+18h] [rbp-2360h]
  signed int outbuf; // [rsp+20h] [rbp-2358h]
  char **outbufa; // [rsp+20h] [rbp-2358h]
  char outbufb; // [rsp+20h] [rbp-2358h]
  char *dest; // [rsp+28h] [rbp-2350h]
  char *desta; // [rsp+28h] [rbp-2350h]
  unsigned int inbytesleft; // [rsp+38h] [rbp-2340h]
  signed int inbyteslefta; // [rsp+38h] [rbp-2340h]
  signed int inbytesleftb; // [rsp+38h] [rbp-2340h]
  _BOOL4 inbuf; // [rsp+40h] [rbp-2338h]
  signed int inbufa; // [rsp+40h] [rbp-2338h]
  char **inbufb; // [rsp+40h] [rbp-2338h]
  size_t n; // [rsp+48h] [rbp-2330h]
  int na; // [rsp+48h] [rbp-2330h]
  char *nb; // [rsp+48h] [rbp-2330h]
  signed int nc; // [rsp+48h] [rbp-2330h]
  char *nd; // [rsp+48h] [rbp-2330h]
  signed int cd; // [rsp+50h] [rbp-2328h]
  signed int cda; // [rsp+50h] [rbp-2328h]
  signed int v346; // [rsp+58h] [rbp-2320h]
  signed int v347; // [rsp+58h] [rbp-2320h]
  signed int v348; // [rsp+58h] [rbp-2320h]
  const char *v349; // [rsp+58h] [rbp-2320h]
  char *filename; // [rsp+60h] [rbp-2318h]
  signed int filenamea; // [rsp+60h] [rbp-2318h]
  signed int v352; // [rsp+68h] [rbp-2310h]
  unsigned int v353; // [rsp+68h] [rbp-2310h]
  signed int v354; // [rsp+70h] [rbp-2308h]
  unsigned int v355; // [rsp+70h] [rbp-2308h]
  char *v356; // [rsp+70h] [rbp-2308h]
  _BYTE *s2; // [rsp+78h] [rbp-2300h]
  char v358; // [rsp+80h] [rbp-22F8h]
  double v359; // [rsp+88h] [rbp-22F0h]
  signed int v360; // [rsp+88h] [rbp-22F0h]
  double v361; // [rsp+90h] [rbp-22E8h]
  int v362; // [rsp+90h] [rbp-22E8h]
  __int16 v363; // [rsp+9Ch] [rbp-22DCh]
  unsigned int v364; // [rsp+A0h] [rbp-22D8h]
  unsigned int size; // [rsp+B8h] [rbp-22C0h]
  __int64 v366; // [rsp+C0h] [rbp-22B8h]
  double v367; // [rsp+C8h] [rbp-22B0h]
  const char **v368; // [rsp+D0h] [rbp-22A8h]
  char *newa; // [rsp+D8h] [rbp-22A0h]
  char *file; // [rsp+E0h] [rbp-2298h]
  char *v371; // [rsp+E8h] [rbp-2290h]
  __int64 v372; // [rsp+110h] [rbp-2268h]
  int v373; // [rsp+11Ch] [rbp-225Ch]
  double v374; // [rsp+120h] [rbp-2258h]
  struct timezone tz; // [rsp+128h] [rbp-2250h]
  struct timeval tv; // [rsp+130h] [rbp-2248h]
  struct timeval v377; // [rsp+140h] [rbp-2238h]
  unsigned __int64 v378; // [rsp+150h] [rbp-2228h]
  FILE *v379; // [rsp+158h] [rbp-2220h]
  char *nptr; // [rsp+170h] [rbp-2208h]
  FILE *v381; // [rsp+178h] [rbp-2200h]
  float v382; // [rsp+190h] [rbp-21E8h]
  int v383; // [rsp+194h] [rbp-21E4h]
  __int64 v384; // [rsp+198h] [rbp-21E0h]
  int v385; // [rsp+1A0h] [rbp-21D8h]
  unsigned int v386; // [rsp+1A4h] [rbp-21D4h]
  unsigned int v387; // [rsp+1A8h] [rbp-21D0h]
  int v388; // [rsp+1ACh] [rbp-21CCh]
  int v389; // [rsp+1B0h] [rbp-21C8h]
  int v390; // [rsp+1B4h] [rbp-21C4h]
  int v391; // [rsp+1BCh] [rbp-21BCh]
  unsigned int v392; // [rsp+1C0h] [rbp-21B8h]
  __int64 v393; // [rsp+1E8h] [rbp-2190h]
  char v394; // [rsp+1F0h] [rbp-2188h]
  int v395; // [rsp+1F8h] [rbp-2180h]
  int v396; // [rsp+1FCh] [rbp-217Ch]
  int v397; // [rsp+200h] [rbp-2178h]
  int v398; // [rsp+204h] [rbp-2174h]
  int v399; // [rsp+20Ch] [rbp-216Ch]
  int v400; // [rsp+210h] [rbp-2168h]
  int v401; // [rsp+21Ch] [rbp-215Ch]
  int v402; // [rsp+220h] [rbp-2158h]
  __int64 v403; // [rsp+250h] [rbp-2128h]
  unsigned int v404; // [rsp+258h] [rbp-2120h]
  __int128 v405; // [rsp+2B0h] [rbp-20C8h]
  __m128i v406; // [rsp+2C0h] [rbp-20B8h]
  __int128 v407; // [rsp+2D0h] [rbp-20A8h]
  char v408; // [rsp+2E0h] [rbp-2098h]
  char s1[8200]; // [rsp+330h] [rbp-2048h]
  char v410[8200]; // [rsp+348h] [rbp-2030h]
  unsigned __int64 v411; // [rsp+2338h] [rbp-40h]

  v4 = a1;
  v5 = a2;
  v6 = *a2;
  v411 = __readfsqword(0x28u);
  if ( sub_113E0(v6) )
  {
    v7 = sub_113E0(*a2);
    a2 = (char **)"ebug";
    if ( strstr(v7, "ebug") || (v92 = sub_113E0(*v5), a2 = (char **)"DEBUG", strstr(v92, "DEBUG")) )
    {
      dword_2190D8 = 1;
      goto LABEL_4;
    }
  }
  if ( dword_2190D8 )
  {
LABEL_4:
    if ( v4 != 1 )
    {
      v8 = v5;
      v9 = 1;
      do
      {
        ++v8;
        a2 = (char **)v9++;
        sub_11570((__int64)"arg %d: %s", a2, *v8);
      }
      while ( v4 != v9 );
    }
  }
  ptr = 0LL;
  dest = 0LL;
  outbuf = 0;
  v10 = 0;
  memset(&v382, 0, 0x58uLL);
  v11 = (char *)&v393;
  v324 = 0;
  outbytesleft = (size_t *)&v5[v4 - 1];
LABEL_8:
  while ( v5 != (char **)outbytesleft )
  {
    while ( 1 )
    {
      ++v5;
      v12 = *v5;
      if ( **v5 != 45 )
        goto LABEL_10;
      v38 = v12[1];
      if ( v38 == 45 )
        break;
      if ( v38 )
        goto LABEL_59;
LABEL_10:
      if ( !v10 )
      {
        if ( outbuf )
        {
          v37 = strlen(*v5);
          a2 = (char **)v12;
          v11 = (char *)malloc(v37 + 4096);
          dest = v11;
          memcpy(v11, v12, v37 + 1);
          outbuf = 0;
        }
        else
        {
          v46 = dword_2190CC + 1;
          v47 = dword_2190CC + 1;
          ptr = (const char **)realloc(ptr, 8LL * (dword_2190CC + 1));
          v48 = strlen(v12);
          v49 = v48;
          v50 = (char *)malloc(v48 + 10);
          v11 = v50;
          a2 = (char **)v12;
          ptr[v47 - 1] = v50;
          v51 = (const char *)memcpy(v50, v12, v49 + 1);
          v52 = v51;
          v53 = *v51;
          if ( v53 != 45 && v53 != 64 )
          {
            v11 = (char *)v52;
            if ( sub_11230(v52) )
            {
              v46 = dword_2190CC + 1;
            }
            else
            {
              a2 = (char **)".raw";
              if ( !(v385 & 0x1000) )
                a2 = (char **)".wav";
              v11 = (char *)ptr[dword_2190CC];
              v46 = dword_2190CC + 1;
              strcat(v11, (const char *)a2);
            }
          }
          dword_2190CC = v46;
          v10 = 0;
        }
        goto LABEL_8;
      }
      if ( !strcasecmp(*v5, "encoder") )
      {
        v12 = (char *)malloc(0x50uLL);
        *v5 = v12;
      }
      else if ( !strcasecmp(v12, "settings") )
      {
        sub_7FF0((int *)s1, (__int64)&v382, *(double *)a3[0]);
        v12 = (char *)malloc(strlen(s1) + 16);
        __sprintf_chk(v12, 1LL, -1LL, "%s=%s", *(double *)a3[0]);
        *v5 = v12;
      }
      v13 = strchr(v12, 61);
      v14 = v13;
      if ( v13 && v12 < v13 )
      {
        v54 = v13;
        v55 = dword_21906C + 1;
        dword_21906C = v55;
        v56 = 32LL * v55;
        v57 = (char *)realloc(ptr, v56);
        v58 = v14 - *v5;
        v59 = (signed __int64)&v57[v56 - 32];
        ptr = v57;
        v60 = v14 + 1;
        v61 = malloc(v58 + 1);
        *(_QWORD *)v59 = v61;
        v62 = v54 - *v5;
        memcpy(v61, *v5, v62);
        *(_BYTE *)(*(_QWORD *)v59 + v62) = 0;
        v63 = strlen(v60);
        *(_DWORD *)(v59 + 24) = v63;
        v64 = (char *)malloc(v63 + 1);
        a2 = (char **)v60;
        *(_QWORD *)(v59 + 8) = v64;
        v11 = v64;
        strcpy(v64, v60);
        *(_QWORD *)(v59 + 16) = 0LL;
        v65 = v10 == 2;
        v10 = 0;
        *(_DWORD *)(v59 + 28) = v65;
        goto LABEL_8;
      }
      v11 = "error in tag spec: %s !";
      a2 = (char **)v12;
      v10 = 0;
      sub_11570((__int64)"error in tag spec: %s !", v12);
      ++v324;
      if ( v5 == (char **)outbytesleft )
        goto LABEL_17;
    }
    if ( v12[2] )
    {
      v66 = v12 + 2;
      nptr = v66;
      v67 = v66;
      do
      {
        v68 = 0;
        v69 = *v67 == 0;
        if ( !*v67 )
          break;
        nptr = ++v67;
        v68 = (unsigned __int8)*(v67 - 1) < 0x3Du;
        v69 = *(v67 - 1) == 61;
      }
      while ( *(v67 - 1) != 61 );
      v70 = "help";
      v71 = 5LL;
      v72 = v66;
      do
      {
        if ( !v71 )
          break;
        v68 = (unsigned __int8)*v72 < *v70;
        v69 = *v72++ == *v70++;
        --v71;
      }
      while ( v69 );
      v73 = (!v68 && !v69) - v68;
      v74 = 0;
      v75 = v73 == 0;
      if ( !v73 )
      {
        puts(aUsageWavpackOp_0);
        return 0LL;
      }
      v76 = "version";
      v77 = 8LL;
      v78 = v66;
      do
      {
        if ( !v77 )
          break;
        v74 = (unsigned __int8)*v78 < *v76;
        v75 = *v78++ == *v76++;
        --v77;
      }
      while ( v75 );
      if ( (!v74 && !v75) == v74 )
      {
        __printf_chk(1LL, "wavpack %s\n", "5.1.0");
        v229 = ((__int64 (*)(void))WavpackGetLibraryVersionString)();
        __printf_chk(1LL, &unk_12CF0, v229);
        return 0LL;
      }
      a2 = (char **)"optimize-mono";
      if ( !strcmp(v66, "optimize-mono") )
      {
        v11 = "warning: --optimize-mono deprecated, now enabled by default";
        sub_11570((__int64)"warning: --optimize-mono deprecated, now enabled by default", "optimize-mono");
        goto LABEL_8;
      }
      a2 = (char **)"dns";
      if ( !strcmp(v66, "dns") )
      {
        v11 = "warning: --dns deprecated, use --use-dns";
        sub_11570((__int64)"warning: --dns deprecated, use --use-dns", "dns");
        ++v324;
        goto LABEL_8;
      }
      a2 = (char **)"use-dns";
      v11 = v66;
      if ( !strcmp(v66, "use-dns") )
      {
        v386 |= 0x20000u;
        goto LABEL_8;
      }
      a2 = (char **)"cross-decorr";
      v11 = v66;
      if ( !strcmp(v66, "cross-decorr") )
      {
        v386 |= 0x20u;
        goto LABEL_8;
      }
      a2 = (char **)"merge-blocks";
      v11 = v66;
      if ( !strcmp(v66, "merge-blocks") )
      {
        v386 |= 0x10000000u;
        goto LABEL_8;
      }
      a2 = (char **)"pair-unassigned-chans";
      v11 = v66;
      if ( !strcmp(v66, "pair-unassigned-chans") )
      {
        v386 |= 0x20000000u;
        goto LABEL_8;
      }
      a2 = (char **)"import-id3";
      v11 = v66;
      if ( !strcmp(v66, "import-id3") )
      {
        dword_2190A0 = 1;
        goto LABEL_8;
      }
      a2 = (char **)"no-utf8-convert";
      v11 = v66;
      if ( !strcmp(v66, "no-utf8-convert") )
      {
        dword_2190B4 = 1;
        goto LABEL_8;
      }
      a2 = (char **)"allow-huge-tags";
      v11 = v66;
      if ( !strcmp(v66, "allow-huge-tags") )
      {
        dword_2190AC = 1;
        goto LABEL_8;
      }
      a2 = (char **)"write-binary-tag";
      v11 = v66;
      if ( !strcmp(v66, "write-binary-tag") )
      {
        v10 = 2;
      }
      else if ( !strncmp(v66, "raw-pcm-skip", 0xCuLL) )
      {
        v315 = strtol(nptr, &nptr, 10);
        v316 = nptr;
        v317 = v315;
        dword_21909C = v315;
        if ( *nptr == 44 )
        {
          ++nptr;
          v318 = strtol(nptr, &nptr, 10);
          v316 = nptr;
          dword_219098 = v318;
        }
        if ( *v316 || v317 < 0 || dword_219098 < 0 )
        {
          sub_11570((__int64)"syntax error in raw-pcm-skip specification!", &nptr);
          ++v324;
        }
        a2 = (char **)(unsigned int)dword_21909C;
        v11 = "raw_pcm_skip = %d, %d bytes";
        sub_11570((__int64)"raw_pcm_skip = %d, %d bytes", (unsigned int)dword_21909C, (unsigned int)dword_219098);
      }
      else
      {
        a2 = (char **)"raw-pcm";
        v290 = strncmp(v66, "raw-pcm", 7uLL);
        if ( v290 )
        {
          if ( !strncmp(v66, "blocksize", 9uLL) )
          {
            v11 = nptr;
            a2 = 0LL;
            v390 = strtol(nptr, 0LL, 10);
            if ( (unsigned int)(v390 - 16) > 0x1FFF0 )
            {
              v11 = "invalid blocksize!";
              sub_11570((__int64)"invalid blocksize!", 0LL);
              ++v324;
            }
          }
          else
          {
            a2 = (char **)"channel-order";
            v11 = v66;
            if ( !strncmp(v66, "channel-order", 0xDuLL) )
            {
              v292 = v5;
              v293 = 0LL;
              v294 = 0;
              inbyteslefta = v10;
              v295 = nptr;
              while ( 2 )
              {
                v296 = v293;
                if ( !*v295 )
                {
                  v10 = inbyteslefta;
                  v5 = v292;
                  goto LABEL_769;
                }
                if ( *v295 == 46 )
                {
                  v319 = v295;
                  v10 = inbyteslefta;
                  v5 = v292;
                  nptr = v319 + 1;
                  if ( v319[1] == 46 )
                  {
                    nptr = v319 + 2;
                    if ( v319[2] == 46 )
                    {
                      v310 = v319 + 3;
                      nptr = v319 + 3;
                      if ( !v319[3] )
                      {
                        v385 |= 0x400u;
                        v314 = v319 + 3;
                        goto LABEL_768;
                      }
                    }
                  }
LABEL_772:
                  v11 = "syntax error in channel order specification!";
                  sub_11570((__int64)"syntax error in channel order specification!");
                  ++v324;
                }
                else
                {
                  v297 = *__ctype_b_loc();
                  for ( i = 0LL; ; ++i )
                  {
                    a2 = (char **)*v295;
                    v299 = (signed int)i;
                    if ( !(v297[(_QWORD)a2] & 0x400) )
                    {
                      if ( (_DWORD)v299 )
                        goto LABEL_761;
                      goto LABEL_771;
                    }
                    if ( i == 5 )
                      break;
                    nptr = v295 + 1;
                    v300 = *v295++;
                    s1[i] = v300;
                  }
                  v299 = 5LL;
LABEL_761:
                  s1[v299] = 0;
                  v309 = 0LL;
                  v310 = s1;
                  while ( 1 )
                  {
                    v11 = (char *)v310;
                    inbufb = (char **)v310;
                    v311 = strcasecmp(v310, (const char *)*(&off_218220 + v309));
                    v310 = (const char *)inbufb;
                    v312 = (unsigned int)v309;
                    if ( !v311 )
                      break;
                    if ( ++v309 == 18 )
                      goto LABEL_773;
                  }
                  v313 = v294;
                  byte_219080[v293] = v309;
                  a2 = (char **)(1LL << v309);
                  v294 |= 1LL << v309;
                  if ( _bittest64(&v313, (unsigned int)v309) )
                  {
LABEL_773:
                    a2 = inbufb;
                    v10 = inbyteslefta;
                    v5 = v292;
                    sub_11570((__int64)"unknown or repeated channel spec: %s!", inbufb, inbufb, v312);
                    goto LABEL_772;
                  }
                  if ( *v295 )
                  {
                    nptr = v295 + 1;
                    if ( *v295 == 44 )
                    {
                      ++v295;
                      goto LABEL_766;
                    }
LABEL_771:
                    v10 = inbyteslefta;
                    v5 = v292;
                    goto LABEL_772;
                  }
LABEL_766:
                  if ( ++v293 != 18 )
                    continue;
                  v10 = inbyteslefta;
                  v314 = v295;
                  v296 = 18;
                  v5 = v292;
LABEL_768:
                  if ( *v314 )
                  {
                    v11 = "too many channels specified!";
                    sub_11570((__int64)"too many channels specified!", a2, v310);
                    ++v324;
                  }
                  else
                  {
LABEL_769:
                    v392 = v294;
                    dword_219094 = v296;
                  }
                }
                break;
              }
            }
            else if ( !strncmp(v66, aPreQuantize_0, 0x12uLL) )
            {
              v11 = nptr;
              a2 = 0LL;
              dword_2190A8 = strtol(nptr, 0LL, 10);
              dword_2190A4 = dword_2190A8;
              if ( (unsigned int)(dword_2190A8 - 4) > 0x1C )
              {
LABEL_677:
                v11 = "invalid quantize bits!";
                sub_11570((__int64)"invalid quantize bits!", 0LL);
                ++v324;
                goto LABEL_8;
              }
            }
            else
            {
              if ( !strncmp(v66, "pre-quantize", 0xCuLL) )
              {
                v11 = nptr;
                a2 = 0LL;
                dword_2190A8 = strtol(nptr, 0LL, 10);
                if ( (unsigned int)(dword_2190A8 - 4) <= 0x1C )
                  goto LABEL_8;
                goto LABEL_677;
              }
              v11 = "unknown option: %s !";
              a2 = (char **)v66;
              sub_11570((__int64)"unknown option: %s !", v66);
              ++v324;
            }
          }
        }
        else
        {
          v404 = 2;
          inbufa = 0;
          v403 = 68719520836LL;
          inbytesleftb = 0;
          v301 = 0;
          v302 = 0LL;
          while ( 1 )
          {
            if ( !*nptr )
              goto LABEL_734;
            if ( v302 == 3 )
              break;
            v349 = nptr;
            v303 = *nptr;
            v304 = __ctype_b_loc();
            v305 = (char *)v349;
            if ( (*v304)[v303] & 0x800 )
            {
              a2 = &nptr;
              v306 = strtol(v349, &nptr, 10);
              v305 = nptr;
              *((_DWORD *)&v403 + v302) = v306;
            }
            if ( v302 == 1 )
            {
              v307 = *v305 & 0xDF;
              switch ( v307 )
              {
                case 70:
                  ++v305;
                  v301 = 1;
                  nptr = v305;
                  break;
                case 85:
                  ++v305;
                  inbytesleftb = 1;
                  nptr = v305;
                  break;
                case 83:
                  ++v305;
                  inbufa = 1;
                  nptr = v305;
                  break;
              }
            }
            ++v302;
            if ( *v305 != 44 )
              goto LABEL_733;
            nptr = v305 + 1;
          }
          a2 = (char **)"be";
          nd = nptr;
          if ( !strcasecmp(nptr, "be") )
          {
            v305 = nd + 2;
            v290 = 1;
            nptr = nd + 2;
          }
          else
          {
            a2 = (char **)"le";
            v290 = strcasecmp(nd, "le");
            if ( v290 )
            {
LABEL_739:
              v11 = "syntax error in raw PCM specification!";
              sub_11570((__int64)"syntax error in raw PCM specification!", a2);
              ++v324;
              goto LABEL_8;
            }
            v305 = nd + 2;
            nptr = nd + 2;
          }
LABEL_733:
          if ( *v305 )
            goto LABEL_739;
LABEL_734:
          a2 = (char **)(unsigned int)v403;
          if ( (unsigned int)(v403 - 1) > 0x3B9AC9FF
            || (unsigned int)(HIDWORD(v403) - 1) > 0x1F
            || HIDWORD(v403) != 32 && v301
            || (v11 = (char *)v404, v404 - 1 > 0xFF) )
          {
            v11 = "argument range error in raw PCM specification!";
            sub_11570((__int64)"argument range error in raw PCM specification!");
            ++v324;
          }
          else
          {
            v308 = v385;
            if ( HIDWORD(v403) == 1 )
            {
              a2 = (char **)(unsigned int)((signed int)a2 >> 3);
              v391 = (signed int)a2;
              v384 = 4294967304LL;
              v388 = (signed int)v11;
              v385 |= 0x1020u;
            }
            else
            {
              v391 = (signed int)a2;
              LODWORD(v384) = HIDWORD(v403);
              v388 = (signed int)v11;
              HIDWORD(v384) = (HIDWORD(v403) + 7) >> 3;
              if ( v301 )
                v301 = 127;
              v389 = v301;
              a2 = (char **)(v385 | 0x1000u);
              v385 |= 0x1000u;
              if ( SHIDWORD(v403) <= 8 )
              {
                if ( inbufa )
                  v385 = v308 | 0x1002;
              }
              else
              {
                if ( inbytesleftb )
                  v385 = v308 | 0x1004;
                if ( v290 )
                  v385 |= 1u;
              }
            }
          }
        }
      }
    }
    else
    {
LABEL_59:
      while ( 1 )
      {
        *v5 = v12 + 1;
        v39 = v12[1];
        if ( !v39 )
          break;
        switch ( v39 )
        {
          case 65:
          case 97:
            v385 |= 0x100u;
            break;
          case 66:
          case 98:
            v11 = v12 + 2;
            a2 = v5;
            v386 |= 8u;
            *v5 = v12 + 2;
            v44 = strtod(v12 + 2, v5);
            --*v5;
            v382 = v44;
            if ( v44 < 2.0 || v44 > 9600.0 )
            {
              v11 = "hybrid spec must be 2.0 to 9600!";
              sub_11570((__int64)"hybrid spec must be 2.0 to 9600!", v5);
              ++v324;
            }
            a3[0] = LODWORD(v382);
            if ( v382 >= 24.0 )
              v386 |= 0x2000u;
            break;
          case 67:
          case 99:
            v43 = v386 | 0x100000;
            if ( !(v386 & 0x80000) )
              v43 = v386 | 0x80000;
            v386 = v43;
            break;
          case 68:
          case 100:
            dword_2190B8 = 1;
            break;
          case 70:
          case 102:
            v386 |= 0x200u;
            break;
          case 72:
          case 104:
            v41 = v386;
            v42 = v386;
            BYTE1(v41) |= 8u;
            BYTE1(v42) |= 0x10u;
            if ( !(v386 & 0x800) )
              v42 = v41;
            v386 = v42;
            break;
          case 73:
          case 105:
            v385 |= 0x800u;
            break;
          case 74:
          case 106:
            v11 = v12 + 2;
            a2 = v5;
            *v5 = v12 + 2;
            v40 = strtol(v12 + 2, v5, 10);
            if ( v40 )
            {
              if ( v40 == 1 )
              {
                v386 |= 0x10010u;
              }
              else
              {
                v11 = "-j0 or -j1 only!";
                sub_11570((__int64)"-j0 or -j1 only!", v5);
                ++v324;
              }
            }
            else
            {
              v386 = v386 & 0xFFFFFFEF | 0x10000;
            }
            goto LABEL_86;
          case 77:
          case 109:
            v386 |= 0x8000000u;
            break;
          case 78:
          case 110:
            v386 |= 0x800000u;
            break;
          case 79:
          case 111:
            outbuf = 1;
            break;
          case 81:
          case 113:
            dword_2190C0 = 1;
            break;
          case 82:
          case 114:
            v385 |= 0x200u;
            break;
          case 83:
          case 115:
            v11 = v12 + 2;
            a2 = v5;
            *v5 = v12 + 2;
            *(double *)a3[0] = strtod(v12 + 2, v5);
            *(float *)a3[0] = *(double *)a3[0];
            v383 = a3[0];

            if ( *(float *)a3[0] == 0.0 )
            {
              v79 = v386 & 0xFFFFFFBF;
              BYTE1(v79) |= 0x80u;
              v386 = v79;
            }
            else if ( *(float *)a3[0] >= -1.0 && *(float *)a3[0] <= 1.0 )
            {
              v386 |= 0x8040u;
            }
            else
            {
              v11 = "-s-1.00 to -s1.00 only!";
              sub_11570((__int64)"-s-1.00 to -s1.00 only!", v5);
              ++v324;
            }
            goto LABEL_86;
          case 84:
          case 116:
            dword_2190C4 = 1;
            break;
          case 86:
          case 118:
            dword_2190BC = 1;
            break;
          case 87:
          case 119:
            if ( ++v10 == 2 )
            {
              v11 = "warning: -ww deprecated, use --write-binary-tag";
              sub_11570((__int64)"warning: -ww deprecated, use --write-binary-tag", a2);
              ++v324;
            }
            break;
          case 88:
          case 120:
            v11 = v12 + 2;
            a2 = v5;
            *v5 = v12 + 2;
            v387 = strtol(v12 + 2, v5, 10);
            if ( v387 > 6 )
            {
              v11 = "extra mode only goes from 1 to 6!";
              sub_11570((__int64)"extra mode only goes from 1 to 6!", v5);
              ++v324;
            }
            else
            {
              v386 |= 0x2000000u;
            }
LABEL_86:
            --*v5;
            break;
          case 89:
          case 121:
            dword_2190D0 = 1;
            break;
          case 90:
          case 122:
            v11 = v12 + 2;
            a2 = v5;
            *v5 = v12 + 2;
            v45 = strtol(v12 + 2, v5, 10);
            --*v5;
            dword_2190B0 = v45;
            break;
          default:
            v11 = "illegal option: %c !";
            a2 = (char **)(unsigned int)v39;
            sub_11570((__int64)"illegal option: %c !", a2);
            ++v324;
            break;
        }
        v12 = *v5;
      }
    }
  }
LABEL_17:
  sub_11680();
  if ( outbuf )
  {
    v11 = "no output filename or path specified with -o option!";
    sub_11570((__int64)"no output filename or path specified with -o option!", a2);
    ++v324;
  }
  if ( v10 )
  {
    a2 = (char **)"--write-binary-tag";
    v11 = "no tag specified with %s option!";
    if ( v10 == 1 )
      a2 = (char **)"-w";
    sub_11570((__int64)"no tag specified with %s option!", a2);
    ++v324;
  }
  if ( !(~BYTE1(v386) & 0xA) )
  {
    v11 = "high and fast modes are mutually exclusive!";
    sub_11570((__int64)"high and fast modes are mutually exclusive!", a2);
    ++v324;
  }
  if ( !(v385 & 0x800) )
  {
LABEL_25:
    if ( dword_2190BC && dest )
      goto LABEL_27;
    goto LABEL_29;
  }
  if ( !dest )
  {
    v15 = v386;
    if ( !(v386 & 8) )
      goto LABEL_30;
LABEL_129:
    if ( v15 & 0x10000000 )
    {
      v11 = "--merge-blocks option is for lossless mode only!";
      sub_11570((__int64)"--merge-blocks option is for lossless mode only!", a2);
      v15 = v386;
      ++v324;
      if ( (v386 & 0x28000) != 163840 )
        goto LABEL_32;
    }
    else if ( (v15 & 0x28000) != 163840 )
    {
      goto LABEL_131;
    }
    v11 = "-s and --use-dns options are mutually exclusive!";
    sub_11570((__int64)"-s and --use-dns options are mutually exclusive!", a2);
    ++v324;
    v15 = v386;
    goto LABEL_32;
  }
  if ( *dest != 45 )
    goto LABEL_25;
  v11 = "can't ignore length in header when using stdout!";
  sub_11570((__int64)"can't ignore length in header when using stdout!", a2);
  ++v324;
  if ( dword_2190BC )
  {
LABEL_27:
    if ( *dest == 45 )
    {
      v11 = "can't verify output file when using stdout!";
      sub_11570((__int64)"can't verify output file when using stdout!", a2);
      ++v324;
    }
  }
LABEL_29:
  v15 = v386;
  if ( v386 & 8 )
  {
    if ( v15 & 0x80000 && dest && *dest == 45 )
    {
      v11 = "can't create correction file when using stdout!";
      sub_11570((__int64)"can't create correction file when using stdout!", a2);
      ++v324;
      v15 = v386;
    }
    goto LABEL_129;
  }
LABEL_30:
  if ( v15 & 0x8A8000 )
  {
    v11 = "-c, -n, -s, and --use-dns options are for hybrid mode (-b) only!";
    sub_11570((__int64)"-c, -n, -s, and --use-dns options are for hybrid mode (-b) only!", a2);
    ++v324;
    v15 = v386;
  }
LABEL_32:
  if ( v15 & 0x10000000 )
  {
    if ( !v390 )
    {
      v11 = "--merge-blocks only makes sense when --blocksize is specified!";
      sub_11570((__int64)"--merge-blocks only makes sense when --blocksize is specified!", a2);
      ++v324;
    }
    goto LABEL_35;
  }
LABEL_131:
  if ( v390 && v390 <= 127 )
  {
    v11 = "minimum blocksize is 128 when --merge-blocks is not specified!";
    sub_11570((__int64)"minimum blocksize is 128 when --merge-blocks is not specified!", a2);
    ++v324;
  }
LABEL_35:
  v18 = WavpackGetLibraryVersionString(v11, a2);
  v19 = 6LL;
  v20 = v18;
  v21 = "5.1.0";
  do
  {
    if ( !v19 )
      break;
    v16 = *(_BYTE *)v20 < (const unsigned __int8)*v21;
    v17 = *(_BYTE *)v20++ == *v21++;
    --v19;
  }
  while ( v17 );
  if ( (!v16 && !v17) != v16 )
  {
    v146 = WavpackGetLibraryVersionString(v21, v20);
    v20 = 1LL;
    __fprintf_chk(stderr, 1LL, "\n WARNING: WAVPACK using libwavpack version %s, expected %s (see README)\n\n", v146);
    fflush(stderr);
LABEL_40:
    if ( dword_21906C <= 0 )
    {
LABEL_151:
      if ( v324 )
      {
LABEL_182:
        fwrite("\ntype 'wavpack' for short help or 'wavpack --help' for full help\n", 1uLL, 0x41uLL, stderr);
        fflush(stderr);
        return 1LL;
      }
      goto LABEL_152;
    }
LABEL_41:
    v22 = (char *)ptr;
    v23 = 0LL;
    while ( 1 )
    {
      v26 = 32 * v23;
      v27 = &v22[32 * v23];
      v20 = *((_QWORD *)v27 + 1);
      if ( *(_BYTE *)v20 != 64 )
      {
        if ( !*((_DWORD *)v27 + 7) )
          goto LABEL_42;
        sub_11570((__int64)"binary tags must be from files: %s !");
        ++v324;
        goto LABEL_49;
      }
      v80 = (const char *)(v20 + 1);
      v81 = sub_C560((const char *)(v20 + 1));
      if ( !v81 )
        break;
LABEL_138:
      v82 = sub_117F0(v81);
      *(_DWORD *)((char *)ptr + v26 + 24) = v82;
      if ( sub_11230(v80) )
      {
        v83 = (const char *)sub_11230(v80);
        v84 = (char *)ptr;
        *(_QWORD *)&v84[v26 + 16] = strdup(v83);
      }
      v85 = (char *)ptr + v26;
      v86 = *(_DWORD *)((char *)ptr + v26 + 24);
      if ( v86 >= ((unsigned int)dword_2190AC < 1 ? 0x100000 : 0x1000000) )
      {
        sub_118A0(v81);
LABEL_142:
        v20 = *(_QWORD *)((char *)ptr + v26 + 8);
        sub_11570((__int64)"error in tag spec: %s !", v20);
        ++v324;
        goto LABEL_49;
      }
      v20 = (__int64)calloc(v86 + 2, 1uLL);
      if ( !(unsigned int)sub_11710(v81, v20, *((_DWORD *)v85 + 6), &nptr)
        || *(_DWORD *)((char *)ptr + v26 + 24) != (_DWORD)nptr )
      {
        free((void *)v20);
        sub_118A0(v81);
        goto LABEL_142;
      }
      sub_118A0(v81);
      v147 = (char *)ptr + v26;
      free(*(void **)((char *)ptr + v26 + 8));
      *((_QWORD *)v147 + 1) = v20;
LABEL_49:
      v22 = (char *)ptr;
      v27 = (char *)ptr + v26;
      if ( *(_DWORD *)((char *)ptr + v26 + 28) )
      {
        v28 = strlen(*(const char **)v27);
        v29 = (const char *)*((_QWORD *)v27 + 2);
        v30 = v28;
        if ( v29 )
        {
          v31 = strlen(v29);
          v32 = v31 + v30;
          v33 = v31;
        }
        else
        {
          v32 = v28;
          v33 = 0LL;
        }
        v34 = v32 + 1;
        v35 = (char *)realloc(*((void **)v27 + 1), v34 + *((_DWORD *)v27 + 6));
        v36 = *((signed int *)v27 + 6);
        *((_QWORD *)v27 + 1) = v35;
        memmove(&v35[v33 + 1 + v30], v35, v36);
        strcpy(*((char **)v27 + 1), *(const char **)v27);
        v20 = *((_QWORD *)v27 + 2);
        if ( v20 )
          strcat(*((char **)v27 + 1), (const char *)v20);
        v25 = *((_DWORD *)v27 + 6) + v34;
        *((_DWORD *)v27 + 6) = v25;
        goto LABEL_44;
      }
LABEL_42:
      v24 = *((_DWORD *)v27 + 6);
      if ( v24 )
      {
        v87 = realloc(*((void **)v27 + 1), 2 * v24 + 1);
        v20 = (unsigned int)dword_2190B4;
        v88 = (__time_t)v87;
        *((_QWORD *)v27 + 1) = v87;
        if ( !(_DWORD)v20 )
        {
          v136 = 2 * *((_DWORD *)v27 + 6);
          n = v136 + 1;
          v137 = calloc(n, 1uLL);
          tv.tv_sec = (__time_t)v137;
          v377.tv_sec = v88;
          v378 = 0LL;
          nptr = (char *)v136;
          if ( v136 + 1 <= 3 || *(_BYTE *)v88 != -17 || *(_BYTE *)(v88 + 1) != -69 || *(_BYTE *)(v88 + 2) != -65 )
          {
            v138 = setlocale(0, "");
            v139 = v377.tv_sec;
            if ( *(_BYTE *)v377.tv_sec != -1 || *(_BYTE *)(v377.tv_sec + 1) != -2 )
            {
              v378 = strlen((const char *)v88);
              v143 = iconv_open("UTF-8", "");
            }
            else
            {
              v140 = 0;
              v377.tv_sec += 2LL;
              v141 = v378;
              v142 = v139 - v378;
              while ( *(_WORD *)(v141 + v142 + 2) )
              {
                v141 += 2LL;
                v140 = 1;
              }
              if ( v140 )
                v378 = v141;
              v143 = iconv_open("UTF-8", "UTF-16LE");
            }
            if ( v143 == (iconv_t)-1LL )
            {
              v20 = (__int64)v138;
              setlocale(0, v138);
            }
            else
            {
              v144 = v143;
              v145 = iconv(v143, (char **)&v377, &v378, (char **)&tv, (size_t *)&nptr);
              iconv_close(v144);
              v20 = (__int64)v138;
              setlocale(0, v138);
              if ( v145 != -1 )
              {
                v20 = (__int64)v137;
                memmove((void *)v88, v137, n);
              }
            }
            free(v137);
          }
          else
          {
            v20 = v88 + 3;
            memmove((void *)v88, (const void *)(v88 + 3), v136 - 2);
            *(_BYTE *)(v88 + n - 3) = 0;
          }
        }
        v22 = (char *)ptr;
        v89 = (char *)ptr + v26;
        v90 = *(_DWORD *)((char *)ptr + v26 + 24);
        v91 = *(_BYTE **)((char *)ptr + v26 + 8);
        if ( v90 > 2 && *v91 == -17 && v91[1] == -69 && v91[2] == -65 )
        {
          v207 = v90 - 3;
          v20 = (__int64)(v91 + 3);
          *((_DWORD *)v89 + 6) = v207;
          memmove(v91, v91 + 3, v207);
          *(_BYTE *)(*((_QWORD *)v89 + 1) + *((signed int *)v89 + 6)) = 0;
          v91 = (_BYTE *)*((_QWORD *)v89 + 1);
        }
        v25 = strlen(v91);
        *((_DWORD *)v89 + 6) = v25;
      }
      else
      {
        v22 = (char *)ptr;
        v25 = *(_DWORD *)((char *)ptr + v26 + 24);
      }
LABEL_44:
      dword_219068 += v25;
      if ( dword_219068 > ((unsigned int)dword_2190AC < 1 ? 0x100000 : 0x1000000) )
      {
        sub_11570((__int64)"total APEv2 tag size exceeds %d MB !", (unsigned int)dword_2190AC < 1 ? 1 : 16);
        goto LABEL_182;
      }
      if ( dword_21906C <= (signed int)++v23 )
        goto LABEL_151;
    }
    if ( dword_2190CC && (v208 = *ptr, sub_113E0(*ptr)) && *v208 != 45 )
    {
      v209 = strlen(v208) + 1;
      v210 = malloc(v209 + 4095);
      memcpy(v210, v208, v209);
      v211 = (char *)sub_113E0((const char *)v210);
      strcpy(v211, v80);
      v81 = sub_C560((const char *)v210);
      free(v210);
      if ( v81 || !dest )
      {
LABEL_226:
        if ( !v81 )
          goto LABEL_142;
        goto LABEL_138;
      }
    }
    else if ( !dest )
    {
      goto LABEL_142;
    }
    if ( !sub_113E0(dest) || *dest == 45 )
      goto LABEL_142;
    v133 = strlen(dest) + 1;
    v134 = malloc(v133 + 4095);
    memcpy(v134, dest, v133);
    v135 = (char *)sub_113E0((const char *)v134);
    strcpy(v135, v80);
    v81 = sub_C560((const char *)v134);
    free(v134);
    goto LABEL_226;
  }
  if ( dword_2190C0 | v324 )
    goto LABEL_40;
  WavpackGetLibraryVersionString(v21, v20);
  v20 = 1LL;
  __fprintf_chk(
    stderr,
    1LL,
    "\n"
    " WAVPACK  Hybrid Lossless Audio Compressor  %s Version %s\n"
    " Copyright (c) 1998 - 2019 David Bryant.  All Rights Reserved.\n"
    "\n",
    "Linux");
  fflush(stderr);
  if ( dword_21906C > 0 )
  {
    v324 = 0;
    goto LABEL_41;
  }
LABEL_152:
  if ( !dword_2190CC )
  {
    puts(
      " Usage:   WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\n"
      "             (default is lossless; multiple input files allowed)\n"
      "\n"
      " Utils:   WAVPACK:  create or transcode WavPack files\n"
      "          WVUNPACK: unpack or verify existing WavPack files\n"
      "          WVGAIN:   apply ReplayGain to WavPack files\n"
      "          WVTAG:    apply or edit metadata tags on WavPack files\n"
      "\n"
      " Formats: .wav (default, bwf/rf64 okay)  .wv (transcode, with tags)\n"
      "          .w64 (Sony Wave64)             .caf (Core Audio Format)\n"
      "          .dff (Philips DSDIFF)          .dsf (Sony DSD stream)\n"
      "\n"
      " Options: -bn = enable hybrid compression, n = 2.0 to 23.9 bits/sample, or\n"
      "                                           n = 24-9600 kbits/second (kbps)\n"
      "          -c  = create correction file (.wvc) for hybrid mode (=lossless)\n"
      "          -f  = fast mode (fast, but some compromise in compression ratio)\n"
      "          -h  = high quality (better compression ratio, but slower)\n"
      "          -v  = verify output file integrity after write (no pipes)\n"
      "          -x  = extra encode processing (no decoding speed penalty)\n"
      "          --help = complete help\n"
      "\n"
      " Web:     Visit www.wavpack.com for latest version and info");
    return 1LL;
  }
  dword_2190C8 = 0;
  if ( dword_2190CC <= 0 )
  {
    if ( !dest || *dest != 64 )
      goto LABEL_187;
    goto LABEL_417;
  }
  v93 = 0;
  v94 = ptr;
  do
  {
    v95 = (char *)v94[v93];
    if ( *v95 == 64 )
    {
      v96 = fopen(v95 + 1, "rb");
      v97 = dword_2190C8;
      v98 = v96;
      v99 = dword_2190CC - 1;
      if ( dword_2190C8 < dword_2190CC - 1 )
      {
        v100 = (signed __int64)&v94[dword_2190C8];
        v101 = (unsigned __int64)&(&v94[dword_2190C8 + 1])[(unsigned __int64)(unsigned int)(dword_2190CC
                                                                                          - 2
                                                                                          - dword_2190C8)];
        do
        {
          v102 = *(_QWORD *)(v100 + 8);
          v100 += 8LL;
          *(_QWORD *)(v100 - 8) = v102;
        }
        while ( v101 != v100 );
      }
      dword_2190CC = v99;
      dword_2190C8 = v97 - 1;
      if ( !v98 )
      {
        sub_11570((__int64)"file %s not found!", v95 + 1);
        free(v95);
        return 1LL;
      }
      v103 = 0;
      v104 = 0LL;
      do
      {
        v104 = realloc(v104, v103 + 1024);
        v105 = &v104[v103];
        v20 = 1LL;
        *v105 = 0LL;
        v105[127] = 0LL;
        memset(
          (void *)((unsigned __int64)(v105 + 1) & 0xFFFFFFFFFFFFFFF8LL),
          0,
          8LL * (((unsigned int)v105 - (((_DWORD)v105 + 8) & 0xFFFFFFF8) + 1024) >> 3));
        v106 = fread(v105, 1uLL, 0x400uLL, v98);
        v103 += v106;
      }
      while ( v106 > 1023 );
      v107 = v98;
      v108 = v95;
      v109 = v104;
      do
      {
        v110 = (char)*v104;
        v111 = (signed __int64)(v104 + 1);
        if ( !*v104 )
          break;
        if ( v110 == 13 || v110 == 10 )
        {
          do
          {
            do
              v110 = *(char *)(++v111 - 1);
            while ( v110 == 10 );
          }
          while ( v110 == 13 );
          if ( !*(_BYTE *)(v111 - 1) )
            break;
        }
        outbyteslefta = (size_t *)v107;
        v104 = (_BYTE *)v111;
        v112 = (const char *)malloc(0x1000uLL);
        v113 = 1LL;
        while ( 1 )
        {
          ++v104;
          //v112[v113 - 1] = v110;
          v114 = (signed int)v113;
          v110 = (char)*(v104 - 1);
          if ( v110 == 10 || v110 == 13 || !*(v104 - 1) )
            break;
          if ( ++v113 == 4097 )
          {
            v114 = 4096LL;
            break;
          }
        }
        v115 = dword_2190CC;
        //v112[v114] = 0;
        v116 = (FILE *)outbyteslefta;
        v325 = v112;
        outbytesleftb = v115;
        dword_2190CC = v115 + 1;
        outbufa = (char **)(8LL * (v115 + 1));
        v117 = (const char **)realloc(v94, (size_t)outbufa);
        v20 = (unsigned int)dword_2190C8;
        v94 = v117;
        v107 = v116;
        v118 = dword_2190C8 + 1;
        if ( outbytesleftb > dword_2190C8 + 1 )
        {
          v119 = (signed __int64)outbufa + (_QWORD)v117 - 8;
          v20 = (__int64)outbufa + (_QWORD)v94 + -8 * (unsigned int)(outbytesleftb - 2 - v20) - 16;
          do
          {
            v120 = *(_QWORD *)(v119 - 8);
            v119 -= 8LL;
            *(_QWORD *)(v119 + 8) = v120;
          }
          while ( v20 != v119 );
        }
        dword_2190C8 = v118;
        v94[v118] = v325;
      }
      while ( v110 );
      fclose(v107);
      free(v109);
      free(v108);
    }
    v93 = ++dword_2190C8;
  }
  while ( dword_2190C8 < dword_2190CC );
  ptr = v94;
  if ( dest && *dest == 64 )
  {
LABEL_417:
    v212 = fopen(dest + 1, "rb");
    if ( v212 )
    {
      v20 = 1LL;
      memset(s1, 0, 0x2000uLL);
      fread(s1, 1uLL, 0x1FFFuLL, v212);
      v213 = s1;
      do
      {
        do
          LODWORD(v214) = *(++v213 - 1);
        while ( (_DWORD)v214 == 10 );
      }
      while ( (_DWORD)v214 == 13 );
      if ( *(v213 - 1) )
      {
        v215 = 1LL;
        v216 = 9217LL;
        while ( 1 )
        {
          dest[v215 - 1] = v214;
          v214 = (unsigned int)v213[v215 - 1];
          v217 = (signed int)v215;
          if ( (unsigned __int8)v213[v215 - 1] <= 0xDu )
          {
            if ( _bittest64(&v216, v214) )
              break;
          }
          if ( ++v215 == 4097 )
          {
            v217 = 4096LL;
            break;
          }
        }
        dest[v217] = 0;
        fclose(v212);
        goto LABEL_186;
      }
      sub_11570((__int64)"output spec file is empty!");
      free(dest);
      fclose(v212);
    }
    else
    {
      sub_11570((__int64)"file %s not found!", dest + 1);
      free(dest);
    }
    return 1LL;
  }
LABEL_186:
  if ( !dword_2190CC )
  {
    sub_11570((__int64)"nothing to do!", v20);
    inbytesleft = 1;
    goto LABEL_281;
  }
LABEL_187:
  if ( dword_2190BC )
  {
    if ( v386 & 0x2000000 )
    {
      if ( v387 )
      {
        v148 = 1.0 - 1.0 / (double)((1 << v387) + 1);
        *(double *)a3[0] = 100.0 * v148;
        *(double *)&qword_219070 = 100.0 * v148;
      }
      else
      {
        qword_219070 = 4634394012173520077LL;
      }
    }
    else
    {
      qword_219070 = 4632233691727265792LL;
    }
  }
  else
  {
    qword_219070 = 4636737291354636288LL;
  }
  if ( !dest )
  {
    v123 = 0;
    inbuf = 1;
    goto LABEL_194;
  }
  if ( *dest == 45 )
    goto LABEL_409;
  v122 = sub_112A0(dest);
  if ( dword_2190CC > 1 && !v122 )
  {
    sub_11570((__int64)"%s is not a valid output path", dest);
    free(dest);
    return 1LL;
  }
  v123 = 1;
  inbuf = 1;
  if ( v122 )
    goto LABEL_194;
LABEL_409:
  v123 = 0;
  inbuf = sub_11230(dest) == 0;
LABEL_194:
  dword_2190C8 = 0;
  inbytesleft = 0;
  if ( dword_2190CC <= 0 )
    goto LABEL_280;
  v124 = ptr;
  v125 = dest;
  outbufb = v123;
  while ( 2 )
  {
    if ( !(unsigned int)sub_11700() )
    {
      if ( outbufb )
      {
        v132 = sub_113E0(v124[dword_2190C8]);
        strcat(v125, v132);
        if ( sub_11230(v125) )
          goto LABEL_217;
      }
      else if ( !v125 )
      {
        v203 = -1LL;
        v204 = v124[dword_2190C8];
        v205 = v124[dword_2190C8];
        do
        {
          if ( !v203 )
            break;
          v17 = *v205++ == outbufb;
          --v203;
        }
        while ( !v17 );
        v206 = ~v203;
        v125 = (char *)malloc(8 - v203);
        memcpy(v125, v204, v206);
        if ( sub_11230(v125) )
LABEL_217:
          *(_BYTE *)sub_11230(v125) = 0;
      }
      if ( inbuf && *v125 != 45 )
        strcat(v125, ".wv");
      if ( v386 & 0x80000 )
      {
        v149 = (unsigned __int64)&v125[strlen(v125)];
        v126 = (char *)malloc(v149 - (_QWORD)v125 + 10);
        memcpy(v126, v125, v149 - (_QWORD)v125 + 1);
        if ( sub_11230(v126) )
          *(_BYTE *)sub_11230(v126) = 0;
        v150 = (unsigned __int64)&v126[strlen(v126)];
        *(_DWORD *)v150 = 1668708142;
        *(_BYTE *)(v150 + 4) = 0;
      }
      else
      {
        v126 = 0LL;
      }
      v127 = v124[dword_2190C8];
      if ( dword_2190CC > 1 && !dword_2190C0 )
      {
        __fprintf_chk(stderr, 1LL, "\n%s:\n", v124[dword_2190C8]);
        fflush(stderr);
        v127 = v124[dword_2190C8];
      }
      if ( !sub_11230(v127) || (v128 = (const char *)sub_11230(v124[dword_2190C8]), strcasecmp(v128, ".wv")) )
      {
        v129 = sub_9380(v124[dword_2190C8], v125, v126, (const __m128i *)&v382);
        if ( v129 )
          goto LABEL_277;
        goto LABEL_208;
      }
      v152 = &v394;
      v153 = dword_2190C8;
      v154 = 22LL;
      v155 = (int *)&v382;
      v156 = v386;
      v157 = 1287LL;
      while ( v154 )
      {
        *(_DWORD *)v152 = *v155;
        ++v155;
        v152 += 4;
        --v154;
      }
      desta = (char *)v124[v153];
      if ( v397 & 0x200 )
        v157 = (unsigned int)dword_2190A0 < 1 ? 1283 : 1287;
      outbytesleftc = (size_t *)WavpackOpenFileInput(desta, &v408, v157, 0LL);
      if ( !outbytesleftc )
      {
        sub_11570((__int64)&v408, &v408);
        ++inbytesleft;
        goto LABEL_208;
      }
      v158 = v156 & 0x80008;
      v363 = WavpackGetMode(outbytesleftc);
      if ( !(v363 & 2) && v158 != 8 )
      {
        sub_11570((__int64)"can't transcode lossy file %s to lossless...not allowed!", desta);
        WavpackCloseFile(outbytesleftc, desta);
        ++inbytesleft;
        goto LABEL_208;
      }
      v366 = WavpackGetNumSamples64(outbytesleftc, &v408, v159);
      if ( v366 == -1 )
      {
        sub_11570((__int64)"can't transcode file %s of unknown length!", desta);
        WavpackCloseFile(outbytesleftc, desta);
        ++inbytesleft;
        goto LABEL_208;
      }
      v160 = 6LL;
      v161 = (__int64 *)&v378;
      while ( v160 )
      {
        *(_DWORD *)v161 = 0;
        v161 = (__int64 *)((char *)v161 + 4);
        --v160;
      }
      v162 = 6LL;
      v163 = &nptr;
      while ( v162 )
      {
        *(_DWORD *)v163 = 0;
        v163 = (char **)((char *)v163 + 4);
        --v162;
      }
      if ( v126 )
      {
        v326 = WavpackOpenFileOutput(sub_92C0, &v378, &nptr);
        if ( *v125 == 45 )
        {
          if ( !dword_2190D0 )
          {
            v164 = fopen(v126, "rb");
            v381 = v164;
            if ( v164 )
              goto LABEL_305;
          }
LABEL_314:
          v168 = (char *)malloc(strlen(v125) + 16);
LABEL_315:
          filename = (char *)malloc(strlen(v125) + 16);
LABEL_316:
          for ( j = 0; ; j = v170 )
          {
            na = j;
            strcpy(v168, v125);
            v170 = na + 1;
            if ( sub_11230(v168) )
            {
              if ( na )
              {
                v171 = sub_11230(v168);
                __sprintf_chk(v171, 1LL, -1LL, ".tmp%d", *(double *)a3[0]);
              }
              else
              {
                v228 = sub_11230(v168);
                *(_DWORD *)v228 = 1886221358;
                *(_BYTE *)(v228 + 4) = 0;
              }
              v172 = (const char *)sub_11230(v125);
              strcat(v168, v172);
            }
            else if ( na )
            {
              __sprintf_chk(&v168[strlen(v168)], 1LL, -1LL, ".tmp%d", *(double *)a3[0]);
            }
            else
            {
              v170 = 1;
              strcat(v168, ".tmp");
            }
            v173 = fopen(v168, "rb");
            if ( !v173 )
            {
              if ( !v126 )
                break;
              *(_WORD *)stpcpy(filename, v168) = 99;
              v173 = fopen(filename, "rb");
              if ( !v173 )
                break;
            }
            fclose(v173);
          }
          v174 = &tz;
          gettimeofday(&tv, &tz);
          nb = v168;
          cd = 1;
          if ( *v125 != 45 )
          {
LABEL_325:
            v174 = (struct timezone *)"w+b";
            v379 = fopen(v168, "w+b");
            if ( !v379 )
            {
              v166 = (signed __int64)v168;
              sub_11570((__int64)"can't create file %s!", v168);
LABEL_311:
              WavpackCloseFile(outbytesleftc, v166);
              goto LABEL_312;
            }
LABEL_326:
            if ( !dword_2190C0 )
            {
              if ( *v125 == 45 )
              {
                v234 = "stdin";
                if ( *desta != 45 )
                {
                  v234 = desta;
                  if ( strlen(desta) > 0x1E )
                    v234 = sub_113E0(desta);
                }
                v174 = (struct timezone *)(&size + 1);
                __fprintf_chk(stderr, 1LL, "packing %s to stdout,", v234);
              }
              else if ( v126 )
              {
                sub_11230(v126);
                v175 = v125;
                if ( strlen(v125) > 0x1E )
                  v175 = sub_113E0(v125);
                v174 = (struct timezone *)(&size + 1);
                __fprintf_chk(stderr, 1LL, "creating %s (+%s),", v175);
              }
              else
              {
                v238 = v125;
                if ( strlen(v125) > 0x1E )
                  v238 = sub_113E0(v125);
                v174 = (struct timezone *)(&size + 1);
                __fprintf_chk(stderr, 1LL, "creating %s,", v238);
              }
              fflush(stderr);
            }
            v176 = WavpackGetFileFormat(outbytesleftc, v174);
            v177 = WavpackGetFileExtension(outbytesleftc);
            WavpackSetFileInformation(v326, v177, v176);
            if ( (unsigned int)WavpackGetWrapperBytes(outbytesleftc, v177) )
            {
              if ( !(v397 & 0x200) )
              {
                v178 = WavpackGetWrapperBytes(outbytesleftc, v177);
                v179 = WavpackGetWrapperData(outbytesleftc);
                if ( !(unsigned int)WavpackAddWrapper(v326, v179, v178) )
                {
                  v182 = v326;
LABEL_454:
                  v225 = WavpackGetErrorMessage(v182);
                  sub_11570((__int64)"%s", v225);
                  WavpackCloseFile(outbytesleftc, v225);
                  sub_118A0(v379);
                  v226 = nb;
                  if ( !cd )
                    v226 = v125;
                  sub_11910(v226);
                  WavpackCloseFile(v182, v225);
                  ++inbytesleft;
                  goto LABEL_208;
                }
              }
              WavpackFreeWrapper(outbytesleftc);
            }
            v396 = WavpackGetBytesPerSample(outbytesleftc);
            v395 = WavpackGetBitsPerSample(outbytesleftc);
            v402 = WavpackGetChannelMask(outbytesleftc);
            v399 = WavpackGetNumChannels(outbytesleftc);
            v401 = WavpackGetSampleRate(outbytesleftc);
            v180 = WavpackGetQualifyMode(outbytesleftc);
            v397 |= v180;
            v181 = malloc(v399 + 1);
            WavpackGetChannelIdentities(outbytesleftc, v181);
            if ( v363 & 8 )
              v400 = WavpackGetFloatNormExp(outbytesleftc);
            if ( v363 & 0x800 )
              v398 |= 0x8000000u;
            v182 = v326;
            if ( !(unsigned int)WavpackSetConfiguration64(v326, &v394, v366, v181) )
              goto LABEL_454;
            free(v181);
            v183 = 0LL;
            if ( v397 & 8 )
            {
              v184 = WavpackGetChannelLayout(outbytesleftc, 0LL);
              if ( (_BYTE)v184 )
              {
                WavpackGetChannelLayout(outbytesleftc, s1);
                v183 = v184;
                WavpackSetChannelLayout(v326, v184, s1);
              }
            }
            else
            {
              v183 = (unsigned int)WavpackGetChannelLayout(outbytesleftc, 0LL);
              WavpackSetChannelLayout(v326, v183, 0LL);
            }
            if ( v126 )
            {
              if ( cd )
              {
                v183 = (unsigned __int64)"w+b";
                v381 = fopen(filename, "w+b");
                if ( !v381 )
                {
                  sub_11570((__int64)"can't create correction file!", "w+b");
                  WavpackCloseFile(outbytesleftc, "w+b");
                  sub_118A0(v379);
                  goto LABEL_504;
                }
              }
              else
              {
                v183 = (unsigned __int64)"w+b";
                v381 = fopen(v126, "w+b");
                if ( !v381 )
                {
                  sub_11570((__int64)"can't create correction file!", "w+b");
                  WavpackCloseFile(outbytesleftc, "w+b");
                  sub_118A0(v379);
                  nb = v125;
LABEL_504:
                  sub_11910(nb);
                  WavpackCloseFile(v326, "w+b");
                  ++inbytesleft;
                  goto LABEL_208;
                }
              }
            }
            v185 = 0x10000;
            v354 = WavpackGetBytesPerSample(outbytesleftc);
            v346 = WavpackGetNumChannels(outbytesleftc);
            v358 = WavpackGetQualifyMode(outbytesleftc);
            if ( v358 & 0x40 )
            {
              v364 = 4096;
              v186 = 4096LL;
            }
            else
            {
              while ( 1 )
              {
                v186 = v185;
                if ( 4 * (unsigned __int64)v185 * (signed int)WavpackGetNumChannels(v326) <= 0x200000 )
                  break;
                v185 >>= 1;
              }
              v364 = v185;
            }
            v187 = WavpackGetNumChannels(v326);
            v371 = (char *)malloc(v364 * v354 * v187);
            MD5_Init(&v403);
            if ( v358 & 8 && (v183 = 0LL, v346 >= (unsigned __int8)WavpackGetChannelLayout(outbytesleftc, 0LL)) )
            {
              s2 = malloc(v346);
              for ( k = 0LL; v346 > (signed int)k; ++k )
                s2[k] = k;
              v183 = (unsigned __int64)s2;
              WavpackGetChannelLayout(outbytesleftc, s2);
            }
            else
            {
              s2 = 0LL;
            }
            WavpackPackInit(v326, v183);
            v188 = WavpackGetNumChannels(v326);
            v189 = (float *)malloc(v188 * 4 * v186);
            v352 = dword_2190A8;
            if ( dword_2190A8 )
            {
              if ( dword_2190A8 < 8 * v354 )
              {
                v352 = -1 << (8 * v354 - dword_2190A8);
                if ( WavpackGetMode(outbytesleftc) & 8 )
                {
                  v283 = WavpackGetFloatNormExp(outbytesleftc);
                  v284 = dword_2190A8;
                  v285 = v283;
                  v359 = exp2((double)(dword_2190A8 + 126 - v283));
                  *(double *)a3[0] = exp2((double)(v285 - 126 - v284));
                  v361 = *(double *)a3[0];
                }
                else
                {
                  v361 = 1.0;
                  v359 = 1.0;
                }
              }
              else
              {
                v352 = 0;
                v361 = 1.0;
                v359 = 1.0;
              }
            }
            else
            {
              v361 = 1.0;
              v359 = 1.0;
            }
            file = v126;
            v368 = v124;
            newa = v125;
            v190 = (__int64)v371;
            v191 = 4LL * v346;
            v367 = -1.0;
            while ( 1 )
            {
              v192 = WavpackUnpackSamples(outbytesleftc, v189, v364);
              v193 = v192;
              if ( !v192 )
                break;
              if ( v352 )
              {
                size = v192 * v346;
                if ( WavpackGetMode(outbytesleftc) & 8 )
                {
                  v372 = v190;
                  v373 = v192;
                  v220 = v189;
                  v221 = v191;
                  v222 = v192;
                  for ( l = 0LL; size > (unsigned int)l; ++l )
                  {
                    *(double *)a3[0] = floor(v220[l] * v359 + 0.5) * v361;
                    v224 = *(double *)a3[0];
                    v220[l] = v224;
                  }
                  v193 = v222;
                  v192 = v373;
                  v191 = v221;
                  v189 = v220;
                  v190 = v372;
                }
                else
                {
                  if ( dword_2190A4 )
                  {
                    for ( m = 0LL; size > (unsigned int)m; ++m )
                    {
                      v236 = v189[m];
                      v237 = (v352 ^ (v352 >> 1)) + LODWORD(v236);
                      if ( v236 < 0.0 || v237 << 8 * (4 - v354) > 0 )
                        LODWORD(v189[m]) = v237;
                    }
                  }
                  for ( ii = 0LL; size > (unsigned int)ii; ++ii )
                    LODWORD(v189[ii]) &= v352;
                }
              }
              if ( !(unsigned int)WavpackPackSamples(v326, v189, (unsigned int)v192) )
              {
                v124 = v368;
                v129 = 2;
                v125 = newa;
                v126 = file;
                v151 = (__int128 *)WavpackGetErrorMessage(v326);
                sub_11570((__int64)"%s", v151);
                free(v189);
                goto LABEL_269;
              }
              if ( s2 )
                sub_7DB0(v189, (__int64)s2, v346, v192);
              if ( v358 & 0x30 )
              {
                if ( v358 & 0x40 )
                {
                  if ( v346 )
                  {
                    v194 = (int *)v189;
                    v195 = (char *)v190;
                    do
                    {
                      v196 = v194;
                      v197 = 0LL;
                      do
                      {
                        while ( v192 <= (signed int)v197 )
                        {
                          v195[v197++] = 0;
                          v196 = (int *)((char *)v196 + v191);
                          if ( v197 == 4096 )
                            goto LABEL_371;
                        }
                        v198 = *v196;
                        if ( v358 & 0x10 )
                          LOBYTE(v198) = byte_15C20[(unsigned __int8)*v196];
                        v195[v197++] = v198;
                        v196 = (int *)((char *)v196 + v191);
                      }
                      while ( v197 != 4096 );
LABEL_371:
                      v195 += 4096;
                      v194 = (int *)((char *)v194 + ((signed __int64)v346 << 14) - 4LL * (v346 << 12) + 4);
                    }
                    while ( &v371[4096 * (v346 - 1) + 4096] != v195 );
                  }
                  v193 = 4096;
                }
                else if ( v192 * v346 )
                {
                  v218 = 0LL;
                  do
                  {
                    *(_BYTE *)(v190 + v218) = LODWORD(v189[v218]);
                    ++v218;
                  }
                  while ( (unsigned int)(v192 * v346 - 1) + 1LL != v218 );
                }
              }
              else
              {
                sub_85B0(v190, v189, v358, v354, v192 * v346);
              }
              MD5_Update(&v403, v190, v346 * v354 * v193);
              if ( (unsigned int)sub_11700() )
              {
                v151 = (__int128 *)&stderr->_flags;
                v124 = v368;
                v125 = newa;
                v126 = file;
                v129 = 1;
                fputc(10, stderr);
                fflush(stderr);
                free(v189);
                goto LABEL_269;
              }
              *(double *)a3[0] = WavpackGetProgress(v326);
              if ( *(double *)a3[0] != -1.0 )
              {
                v199 = WavpackGetProgress(v326);
                *(double *)a3[0] = floor(v199 * *(double *)&qword_219070 + 0.5);
                if ( *(double *)a3[0] != v367 )
                {
                  v200 = WavpackGetProgress(v326);
                  v201 = floor(v200 * *(double *)&qword_219070 + 0.5);
                  *(double *)a3[0] = v201 / 100.0;
                  if ( dword_2190B0 )
                    sub_8A80(*(double *)a3[0]);
                  if ( !dword_2190C0 )
                  {
                    v202 = " ";
                    if ( v367 != -1.0 )
                      v202 = "\b\b\b\b\b\b\b\b\b\b\b\b";
                    __fprintf_chk(stderr, 1LL, "%s%3d%% done...", v202);
                    fflush(stderr);
                  }
                  v367 = v201;
                }
              }
            }
            v124 = v368;
            v125 = newa;
            v126 = file;
            if ( s2 )
              free(s2);
            free(v189);
            if ( !(unsigned int)WavpackFlushSamples(v326, v189) )
              goto LABEL_547;
            v151 = (__int128 *)&v403;
            MD5_Final(&v405, &v403);
            free(v371);
            v353 = WavpackGetNumErrors(outbytesleftc);
            if ( v353 )
            {
              v151 = (__int128 *)(unsigned int)WavpackGetNumErrors(outbytesleftc);
              sub_11570((__int64)"missing data or crc errors detected in %d block(s)!", v151);
              v353 = 1;
            }
            if ( v366 == WavpackGetNumSamples64(v326, v151, v240) )
            {
              if ( v363 & 2 && !dword_2190A8 )
                goto LABEL_525;
            }
            else
            {
              sub_11570((__int64)"incorrect number of samples read from source file!");
              if ( !(v363 & 2) || (v353 = 1, dword_2190A8) )
              {
LABEL_710:
                v129 = 1;
                goto LABEL_269;
              }
LABEL_525:
              v151 = (__int128 *)s1;
              if ( (unsigned int)WavpackGetMD5Sum(outbytesleftc, s1) )
              {
                v151 = &v405;
                if ( memcmp(s1, &v405, 0x10uLL) )
                {
                  v129 = 1;
                  sub_11570((__int64)"MD5 signature in source should match, but does not!", &v405);
                  goto LABEL_269;
                }
              }
            }
	    __m128i a4;
            if ( v353 )
              goto LABEL_710;
            v151 = (__int128 *)&v406;
            if ( (unsigned int)WavpackGetMD5Sum(outbytesleftc, &v406) )
            {
              if ( v363 & 2 && dword_2190A8 )
              {
                a4 = _mm_load_si128((const __m128i *)&v405);
                v406 = a4;
              }
              v151 = (__int128 *)&v406;
              WavpackStoreMD5Sum(v326, &v406);
            }
            else if ( v398 & 0x8000000 )
            {
              v151 = &v405;
              a4 = _mm_load_si128((const __m128i *)&v405);
              v406 = a4;
              WavpackStoreMD5Sum(v326, &v405);
            }
            v347 = 0;
            if ( (unsigned int)WavpackGetWrapperBytes(outbytesleftc, v151) )
            {
              v356 = (char *)WavpackGetWrapperData(outbytesleftc);
              v276 = WavpackGetWrapperBytes(outbytesleftc, v151);
              v277 = v276;
              if ( !(v397 & 0x200) )
              {
                v151 = (__int128 *)v356;
                if ( !(unsigned int)WavpackAddWrapper(v326, v356, v276) )
                {
                  v129 = 1;
                  v151 = (__int128 *)WavpackGetErrorMessage(v326);
                  sub_11570((__int64)"%s", v151);
                  WavpackFreeWrapper(outbytesleftc);
                  goto LABEL_269;
                }
              }
              if ( dword_2190A0 && v277 > 10 && (v151 = (__int128 *)"ID3", !strncmp(v356, "ID3", 3uLL)) )
              {
                v151 = (__int128 *)v356;
                v347 = sub_12820(0LL, (unsigned __int64)v356, v277, (__int64)s1, &v377);
                if ( !dword_2190AC && SLODWORD(v377.tv_sec) > 0x100000 )
                {
                  sub_11570((__int64)"imported tag items exceed 1 MB, use --allow-huge-tags to override", v356);
                  goto LABEL_691;
                }
                if ( SLODWORD(v377.tv_sec) > 0x1000000 )
                {
                  sub_11570((__int64)"imported tag items exceed 16 MB", v356);
LABEL_691:
                  v129 = 1;
                  WavpackFreeWrapper(outbytesleftc);
                  goto LABEL_269;
                }
                if ( v347 > 0 )
                {
                  v151 = (__int128 *)v356;
                  v347 = sub_12820(v326, (unsigned __int64)v356, v277, (__int64)s1, 0LL);
                }
                if ( v347 < 0 )
                {
                  v151 = (__int128 *)s1;
                  sub_11570((__int64)"ID3v2 import: %s", s1);
                  goto LABEL_691;
                }
                WavpackFreeWrapper(outbytesleftc);
              }
              else
              {
                WavpackFreeWrapper(outbytesleftc);
                v347 = 0;
              }
            }
            if ( !(unsigned int)WavpackFlushSamples(v326, v151) )
              goto LABEL_547;
            if ( !(v363 & 0x10) )
            {
              v241 = dword_21906C | v347;
              if ( !(dword_21906C | v347) )
              {
LABEL_551:
                WavpackCloseFile(outbytesleftc, v151);
                if ( !(unsigned int)sub_118A0(v379) )
                {
                  sub_11570((__int64)"can't close WavPack file!");
                  if ( !v126 )
                  {
                    if ( cd )
                    {
                      sub_11910(nb);
                      v129 = cd;
                    }
                    else
                    {
                      v129 = 1;
                      sub_11910(v125);
                    }
                    goto LABEL_276;
                  }
                  if ( (unsigned int)sub_118A0(v381) )
                  {
                    v129 = 1;
                    if ( cd )
                    {
                      sub_11910(nb);
                      v129 = cd;
                      goto LABEL_275;
                    }
                    goto LABEL_274;
                  }
                  v129 = 1;
LABEL_698:
                  sub_11570((__int64)"can't close correction file!");
LABEL_695:
                  if ( cd )
                  {
                    sub_11910(nb);
                    goto LABEL_275;
                  }
                  goto LABEL_274;
                }
                if ( v126 && !(unsigned int)sub_118A0(v381) )
                {
                  v129 = 1;
                  sub_11570((__int64)"can't close correction file!");
                  goto LABEL_695;
                }
                if ( dword_2190BC )
                {
                  v275 = WavpackLossyBlocks(v326, v151);
                  v151 = 0LL;
                  if ( !v275 )
                    v151 = &v405;
                  if ( cd )
                  {
                    v129 = sub_8B10((__int64)nb, v151);
                    if ( v129 )
                      goto LABEL_623;
                    if ( dword_2190C4 )
                    {
                      v249 = nb;
                      goto LABEL_564;
                    }
                  }
                  else
                  {
                    v129 = sub_8B10((__int64)v125, v151);
                    if ( v129 )
                    {
LABEL_274:
                      sub_11910(v125);
                      filename = v126;
                      if ( v126 )
                        goto LABEL_275;
                      goto LABEL_276;
                    }
                    if ( dword_2190C4 )
                    {
                      v249 = v125;
                      goto LABEL_564;
                    }
                  }
                }
                else if ( dword_2190C4 )
                {
                  v249 = nb;
                  if ( !cd )
                    v249 = v125;
LABEL_564:
                  if ( !(unsigned int)sub_11150(desta, v249) )
                    goto LABEL_792;
                  if ( v126 )
                  {
                    v250 = filename;
                    if ( !cd )
                      v250 = v126;
                    if ( !(unsigned int)sub_11150(desta, v250) )
LABEL_792:
                      sub_11570((__int64)"failure copying time stamp!");
                  }
                }
                if ( dword_2190B8 )
                {
                  if ( strcasecmp(desta, v125) )
                  {
                    v280 = sub_11910(desta);
                    if ( dword_2190C0 )
                    {
                      if ( v280 )
                        goto LABEL_572;
                      v281 = "can't delete";
                    }
                    else
                    {
                      v281 = "can't delete";
                      if ( v280 )
                        v281 = "deleted";
                    }
                    sub_11570((__int64)"%s source file %s", v281, desta);
                  }
LABEL_572:
                  if ( v363 & 1 )
                  {
                    *(_WORD *)__stpcpy_chk(s1, desta, 4096LL) = 99;
                    if ( !v126 || strcasecmp(s1, v126) )
                    {
                      v278 = sub_11910(s1);
                      if ( dword_2190C0 )
                      {
                        if ( !v278 )
                        {
                          v279 = "can't delete";
                          goto LABEL_644;
                        }
                      }
                      else
                      {
                        v279 = "can't delete";
                        if ( v278 )
                          v279 = "deleted";
LABEL_644:
                        sub_11570((__int64)"%s source file %s", v279, s1);
                      }
                    }
                  }
                }
                if ( !cd )
                  goto LABEL_793;
                v166 = (signed __int64)v125;
                v251 = rename(nb, v125);
                if ( v251 )
                {
                  v166 = (signed __int64)nb;
                  sub_11570((__int64)"can not rename temp file %s to %s!", nb, v125);
                  v251 = cd;
                }
                if ( v126 )
                {
                  v166 = (signed __int64)v126;
                  if ( rename(filename, v126) )
                  {
                    v166 = (signed __int64)filename;
                    sub_11570((__int64)"can not rename temp file %s to %s!", filename, v126);
                    v251 = cd;
                  }
                  free(nb);
                  free(filename);
                }
                else
                {
                  free(nb);
                }
                if ( !v251 )
                {
LABEL_793:
                  v252 = &tz;
                  gettimeofday(&v377, &tz);
                  nc = v377.tv_sec;
                  cda = v377.tv_usec;
                  v348 = tv.tv_sec;
                  filenamea = tv.tv_usec;
                  if ( (v398 & 0x800000) != 0 )
                  {
                    v252 = 0LL;
                    *(double *)a4[0] = WavpackGetEncodedNoise(v326, 0LL);
                    if ( *(double *)a4[0] > 0.0 )
                    {
                      v258 = WavpackGetBitsPerSample(v326);
                      v259 = 0.5;
                      while ( v258 )
                      {
                        --v258;
                        v259 = v259 + v259;
                      }
                      v252 = (struct timezone *)&v374;
                      v286 = v259 * (v259 - 1.0) * 0.5;
                      v287 = WavpackGetEncodedNoise(v326, &v374);
                      v288 = log10(v374 / v286);
                      v289 = WavpackGetNumSamples(v326, &v374);
                      *(double *)a4[0] = log10(v287 / (double)v289 / v286) * 10.0;
                      sub_11570(
                        (__int64)"ave noise = %.2f dB, peak noise = %.2f dB",
                        *(double *)a4[0],
                        10.0 * v288);
                    }
                  }
                  if ( !dword_2190C0 )
                  {
                    v407 = 0LL;
                    if ( v241 )
                    {
                      v252 = (struct timezone *)v241;
                      sub_11570((__int64)"successfully imported %d items from ID3v2 tag", v241);
                    }
                    if ( v386 & 0x8000000 )
                    {
                      v253 = 0LL;
                      strcpy(s1, "original md5 signature: 00000000000000000000000000000000");
                      do
                      {
                        v254 = &v410[2 * v253];
                        v252 = (struct timezone *)(&size + 1);
                        ++v253;
                        __sprintf_chk(v254, 1LL, -1LL, "%02x", 0.0);
                      }
                      while ( v253 != 16 );
                      sub_11570((__int64)s1, 1LL);
                    }
                    if ( *v125 == 45 )
                    {
                      if ( *desta == 45 )
                      {
                        v256 = "packed";
                        v255 = "";
                        desta = "stdin";
                      }
                      else
                      {
                        v256 = "packed";
                        v255 = "";
                        if ( strlen(desta) > 0x1E )
                          desta = (char *)sub_113E0(desta);
                      }
                    }
                    else
                    {
                      desta = v125;
                      if ( strlen(v125) > 0x1E )
                        desta = (char *)sub_113E0(v125);
                      v255 = " (+.wvc)";
                      v256 = "created (and verified)";
                      if ( !(_DWORD)nptr )
                        v255 = "";
                      if ( !dword_2190BC )
                        v256 = "created";
                    }
                    if ( (unsigned int)WavpackLossyBlocks(v326, v252) )
                    {
                      if ( WavpackGetAverageBitrate(v326, 1LL) != 0.0 )
                      {
                        v291 = WavpackGetAverageBitrate(v326, 1LL);
                        __sprintf_chk(&v407, 1LL, 16LL, ", %d kbps", v291 / 1000.0);
                      }
                      v257 = "lossy";
                    }
                    else
                    {
                      if ( WavpackGetRatio(v326) != 0.0 )
                      {
                        v282 = WavpackGetRatio(v326);
                        __sprintf_chk(&v407, 1LL, 16LL, ", %.2f%%", 100.0 - v282 * 100.0);
                      }
                      v257 = "lossless";
                    }
                    v252 = (struct timezone *)v256;
                    *(double *)a4[0] = (double)nc
                                            + (double)cda / 1000000.0
                                            - ((double)v348
                                             + (double)filenamea / 1000000.0);
                    sub_11570(
                      (__int64)"%s %s%s in %.2f secs (%s%s)",
                      v256,
                      desta,
                      v255,
                      v257,
                      &v407,
                      *(double *)a4[0]);
                  }
                  WavpackCloseFile(v326, v252);
                  goto LABEL_208;
                }
LABEL_312:
                WavpackCloseFile(v326, v166);
                ++inbytesleft;
                goto LABEL_208;
              }
            }
            v360 = WavpackGetNumBinaryTagItems(outbytesleftc);
            v362 = WavpackGetNumTagItems(outbytesleftc);
            v355 = 0;
            v242 = 1;
LABEL_541:
            if ( v362 <= (signed int)v355 )
            {
              v260 = file;
              v261 = newa;
LABEL_609:
              while ( 1 )
              {
                v151 = (__int128 *)v353;
                if ( v360 <= (signed int)v353 || !v242 )
                  break;
                v262 = (unsigned __int64)WavpackGetBinaryTagItemIndexed(outbytesleftc, v353, 0LL, 0LL) + 1;
                v263 = malloc((signed int)v262);
                WavpackGetBinaryTagItemIndexed(outbytesleftc, v353, v263, v262);
                v264 = WavpackGetBinaryTagItem(outbytesleftc, v263, 0LL, 0LL);
                v265 = v264;
                v266 = malloc(v264);
                v267 = v266;
                v268 = WavpackGetBinaryTagItem(outbytesleftc, v263, v266, v265);
                v269 = WavpackAppendBinaryTagItem(v326, v263, v267, v268);
                free(v267);
                free(v263);
                ++v353;
                v242 = v269;
              }
              v125 = v261;
              v270 = 0LL;
              v126 = v260;
              v271 = v242;
              while ( dword_21906C > (signed int)v270 )
              {
                if ( !v271 )
                  goto LABEL_547;
                v273 = (char *)ptr + 32 * v270;
                v274 = *((unsigned int *)v273 + 6);
                v151 = *(__int128 **)v273;
                if ( (_DWORD)v274 )
                {
                  v272 = *((_QWORD *)v273 + 1);
                  if ( *((_DWORD *)v273 + 7) )
                    v271 = WavpackAppendBinaryTagItem(v326, v151, v272, v274);
                  else
                    v271 = WavpackAppendTagItem(v326, v151, v272, v274);
                }
                else
                {
                  WavpackDeleteTagItem(v326, v151);
                }
                ++v270;
              }
              if ( v271 && (unsigned int)WavpackWriteTag(v326) )
              {
                v241 = v347;
                goto LABEL_551;
              }
LABEL_547:
              v129 = 2;
              v151 = (__int128 *)WavpackGetErrorMessage(v326);
              sub_11570((__int64)"%s", v151);
LABEL_269:
              WavpackCloseFile(outbytesleftc, v151);
              if ( !(unsigned int)sub_118A0(v379) )
                sub_11570((__int64)"can't close WavPack file!");
              if ( v126 && !(unsigned int)sub_118A0(v381) )
                goto LABEL_698;
              if ( !cd )
                goto LABEL_274;
LABEL_623:
              sub_11910(nb);
              if ( v126 )
LABEL_275:
                sub_11910(filename);
LABEL_276:
              WavpackCloseFile(v326, v151);
LABEL_277:
              ++inbytesleft;
              if ( v129 == 2 )
              {
                dest = v125;
                if ( dword_2190CC > 1 )
                  goto LABEL_279;
                goto LABEL_280;
              }
LABEL_208:
              if ( outbufb )
              {
                sub_113E0(v125);
              }
              else if ( *v125 != 45 )
              {
                v130 = v125;
                v125 = 0LL;
                free(v130);
              }
              if ( v126 )
                free(v126);
              v131 = dword_2190C8 + 1;
              free((void *)v124[dword_2190C8]);
              dword_2190C8 = v131;
              if ( v131 >= dword_2190CC )
                break;
              continue;
            }
            if ( !v242 )
            {
              v260 = file;
              v261 = newa;
              goto LABEL_609;
            }
            v246 = (unsigned __int64)WavpackGetTagItemIndexed(outbytesleftc, v355, 0LL, 0LL) + 1;
            v247 = (char *)malloc((signed int)v246);
            WavpackGetTagItemIndexed(outbytesleftc, v355, v247, v246);
            if ( !strcasecmp(v247, "encoder") )
            {
              v243 = (int *)malloc(0x50uLL);
              __sprintf_chk(v243, 1LL, 80LL, "WavPack %s", *(double *)a4[0]);
            }
            else
            {
              if ( strcasecmp(v247, "settings") )
              {
                v248 = WavpackGetTagItem(outbytesleftc, v247, 0LL, 0LL);
                v243 = (int *)malloc((signed int)(v248 + 1));
                WavpackGetTagItem(outbytesleftc, v247, v243, v248 + 1);
                v244 = v248;
                goto LABEL_540;
              }
              v243 = (int *)malloc(0x100uLL);
              sub_7FF0(v243, (__int64)&v394, *(double *)a4[0]);
            }
            v244 = strlen((const char *)v243);
LABEL_540:
            v245 = WavpackAppendTagItem(v326, v247, v243, v244);
            free(v243);
            free(v247);
            ++v355;
            v242 = v245;
            goto LABEL_541;
          }
LABEL_459:
          nb = v168;
          v379 = (FILE *)stdout;
          goto LABEL_326;
        }
        v230 = fopen(v125, "rb");
        v379 = v230;
        if ( !v230 )
        {
          if ( !dword_2190D0 )
          {
LABEL_485:
            v164 = fopen(v126, "rb");
            v381 = v164;
            if ( v164 )
            {
LABEL_305:
              sub_118A0(v164);
              v165 = v126;
              if ( strlen(v126) > 0x1E )
                v165 = sub_113E0(v126);
              v166 = 1LL;
              __fprintf_chk(stderr, 1LL, "overwrite %s (yes/no/all)? ", v165);
              fflush(stderr);
              if ( dword_2190B0 )
                sub_11940((__int64)"overwrite?");
              v167 = sub_11410();
              if ( v167 == 97 )
              {
                dword_2190D0 = 1;
              }
              else if ( v167 == 110 )
              {
                goto LABEL_311;
              }
              goto LABEL_314;
            }
          }
          v168 = (char *)malloc(strlen(v125) + 16);
          filename = 0LL;
          if ( v126 )
            goto LABEL_315;
          goto LABEL_316;
        }
        sub_118A0(v230);
        if ( dword_2190D0 )
        {
LABEL_469:
          if ( v126 )
            goto LABEL_314;
          goto LABEL_470;
        }
LABEL_475:
        v231 = strlen(v125);
        v232 = v125;
        if ( v158 == 8 )
        {
          if ( v231 > 0x1E )
            v232 = sub_113E0(v125);
          v166 = 1LL;
          __fprintf_chk(stderr, 1LL, "overwrite %s with lossy transcode (yes/no/all)? ", v232);
        }
        else
        {
          if ( v231 > 0x1E )
            v232 = sub_113E0(v125);
          v166 = 1LL;
          __fprintf_chk(stderr, 1LL, "overwrite %s (yes/no/all)? ", v232);
        }
        fflush(stderr);
        if ( dword_2190B0 )
          sub_11940((__int64)"overwrite?");
        v233 = sub_11410();
        if ( v233 == 97 )
        {
          dword_2190D0 = 1;
          goto LABEL_469;
        }
        if ( v233 == 110 )
          goto LABEL_311;
        if ( v126 )
        {
          if ( dword_2190D0 )
            goto LABEL_314;
          goto LABEL_485;
        }
      }
      else
      {
        v326 = WavpackOpenFileOutput(sub_92C0, &v378, 0LL);
        if ( *v125 == 45 || (v227 = fopen(v125, "rb"), (v379 = v227) == 0LL) )
        {
          v174 = &tz;
          gettimeofday(&tv, &tz);
          filename = 0LL;
          if ( *v125 != 45 )
          {
            nb = 0LL;
            cd = 0;
            v168 = v125;
            goto LABEL_325;
          }
          v168 = 0LL;
          cd = 0;
          goto LABEL_459;
        }
        sub_118A0(v227);
        if ( !dword_2190D0 )
          goto LABEL_475;
      }
LABEL_470:
      filename = 0LL;
      v168 = (char *)malloc(strlen(v125) + 16);
      goto LABEL_316;
    }
    break;
  }
  dest = v125;
  if ( dword_2190CC > 1 )
  {
    if ( inbytesleft )
    {
LABEL_279:
      __fprintf_chk(stderr, 1LL, "\n **** warning: errors occurred in %d of %d files! ****\n", inbytesleft);
      fflush(stderr);
    }
    else if ( !dword_2190C0 )
    {
      __fprintf_chk(stderr, 1LL, "\n **** %d files successfully processed ****\n", (unsigned int)dword_2190CC);
      fflush(stderr);
    }
  }
LABEL_280:
  free(ptr);
LABEL_281:
  if ( dest )
    free(dest);
  if ( dword_2190B0 )
    sub_11940((__int64)"WavPack Completed");
  return inbytesleft != 0;
}
// 3000: using guessed type __int64  WavpackAppendTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 3040: using guessed type __int64  __stpcpy_chk(_QWORD, _QWORD, _QWORD);
// 3070: using guessed type __int64  WavpackGetBinaryTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 3090: using guessed type __int64  __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 30D0: using guessed type __int64  WavpackOpenFileInput(_QWORD, _QWORD, _QWORD, _QWORD);
// 30F0: using guessed type __int64  __printf_chk(_QWORD, _QWORD, _QWORD);
// 3160: using guessed type __int64  WavpackFreeWrapper(_QWORD);
// 3170: using guessed type __int64  WavpackWriteTag(_QWORD);
// 3180: using guessed type __int64  WavpackGetBitsPerSample(_QWORD);
// 3190: using guessed type __int64  WavpackGetChannelIdentities(_QWORD, _QWORD);
// 31A0: using guessed type double  WavpackGetEncodedNoise(_QWORD, _QWORD);
// 31B0: using guessed type __int64  WavpackSetFileInformation(_QWORD, _QWORD, _QWORD);
// 31D0: using guessed type __int64  WavpackGetNumSamples(_QWORD, _QWORD);
// 31E0: using guessed type __int64  WavpackAppendBinaryTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 3210: using guessed type __int64  WavpackGetTagItemIndexed(_QWORD, _QWORD, _QWORD, _QWORD);
// 3260: using guessed type __int64  WavpackGetChannelLayout(_QWORD, _QWORD);
// 3290: using guessed type __int64  WavpackGetBytesPerSample(_QWORD);
// 32A0: using guessed type __int64  MD5_Final(_QWORD, _QWORD);
// 32B0: using guessed type __int64  MD5_Update(_QWORD, _QWORD, _QWORD);
// 32C0: using guessed type double  WavpackGetProgress(_QWORD);
// 32F0: using guessed type __int64  WavpackGetNumTagItems(_QWORD);
// 3300: using guessed type double  WavpackGetAverageBitrate(_QWORD, _QWORD);
// 3330: using guessed type __int64  WavpackGetLibraryVersionString(_QWORD, _QWORD);
// 3340: using guessed type __int64  WavpackGetBinaryTagItemIndexed(_QWORD, _QWORD, _QWORD, _QWORD);
// 3350: using guessed type __int64  WavpackPackInit(_QWORD, _QWORD);
// 3370: using guessed type __int64  WavpackFlushSamples(_QWORD, _QWORD);
// 33B0: using guessed type __int64  WavpackGetFloatNormExp(_QWORD);
// 33E0: using guessed type __int64  WavpackGetFileExtension(_QWORD);
// 33F0: using guessed type __int64  WavpackGetNumSamples64(_QWORD, _QWORD, _QWORD);
// 3400: using guessed type __int64  WavpackGetChannelMask(_QWORD);
// 3410: using guessed type __int64  WavpackPackSamples(_QWORD, _QWORD, _QWORD);
// 3420: using guessed type __int64  WavpackUnpackSamples(_QWORD, _QWORD, _QWORD);
// 3450: using guessed type __int64  WavpackGetWrapperData(_QWORD);
// 3480: using guessed type __int64  WavpackGetSampleRate(_QWORD);
// 3490: using guessed type __int64  WavpackGetWrapperBytes(_QWORD, _QWORD);
// 34A0: using guessed type double  WavpackGetRatio(_QWORD);
// 34B0: using guessed type __int64  WavpackGetNumErrors(_QWORD);
// 3510: using guessed type __int64  WavpackGetFileFormat(_QWORD, _QWORD);
// 3540: using guessed type __int64  MD5_Init(_QWORD);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3570: using guessed type __int64  WavpackLossyBlocks(_QWORD, _QWORD);
// 3580: using guessed type __int64  WavpackGetMD5Sum(_QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 35E0: using guessed type __int64  WavpackGetTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 3600: using guessed type __int64  WavpackGetNumChannels(_QWORD);
// 3620: using guessed type __int64  WavpackOpenFileOutput(_QWORD, _QWORD, _QWORD);
// 3630: using guessed type __int64  WavpackDeleteTagItem(_QWORD, _QWORD);
// 3640: using guessed type __int64  WavpackSetChannelLayout(_QWORD, _QWORD, _QWORD);
// 3650: using guessed type __int64  __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, double);
// 3680: using guessed type __int64  WavpackGetQualifyMode(_QWORD);
// 3690: using guessed type __int64  WavpackGetNumBinaryTagItems(_QWORD);
// 36B0: using guessed type __int64  WavpackCloseFile(_QWORD, _QWORD);
// 36F0: using guessed type __int64  WavpackStoreMD5Sum(_QWORD, _QWORD);
// 3700: using guessed type __int64  WavpackGetMode(_QWORD);
// 218220: using guessed type void *off_218220;
// 219048: using guessed type __int64 stdout;
// 219068: using guessed type int dword_219068;
// 21906C: using guessed type int dword_21906C;
// 219070: using guessed type __int64 qword_219070;
// 219094: using guessed type int dword_219094;
// 219098: using guessed type int dword_219098;
// 21909C: using guessed type int dword_21909C;
// 2190A0: using guessed type int dword_2190A0;
// 2190A4: using guessed type int dword_2190A4;
// 2190A8: using guessed type int dword_2190A8;
// 2190AC: using guessed type int dword_2190AC;
// 2190B0: using guessed type int dword_2190B0;
// 2190B4: using guessed type int dword_2190B4;
// 2190B8: using guessed type int dword_2190B8;
// 2190BC: using guessed type int dword_2190BC;
// 2190C0: using guessed type int dword_2190C0;
// 2190C4: using guessed type int dword_2190C4;
// 2190C8: using guessed type int dword_2190C8;
// 2190CC: using guessed type int dword_2190CC;
// 2190D0: using guessed type int dword_2190D0;
// 2190D8: using guessed type int dword_2190D8;
// 3780: using guessed type char s1[8200];

//----- (0000000000007CA0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
//void  __noreturn start(__int64 a1, void (*a2)(void))
//{
//  int v2; // esi
//  int v3; // [rsp-8h] [rbp-8h]
//  __int64 _0; // [rsp+0h] [rbp+0h]
//
//  v2 = v3;
//  *(_QWORD *)&v3 = a1;
//  _libc_start_main((int ( *)(int, char **, char **))main, v2, (char **)&_0, (void (*)(void))init, fini, a2, &v3);
//  __halt();
//  JUMPOUT(*(_QWORD *)algn_7CCB);
//}
//// 7CA6: positive sp value 8 has been found
//
////----- (0000000000007CD0) ----------------------------------------------------
//__int64 (**sub_7CD0())(void)
//{
//  __int64 (**result)(void); // rax
//
//  result = (__int64 (**)(void))&unk_219010;
//  if ( &unk_219010 != &unk_219010 )
//  {
//    result = &ITM_deregisterTMCloneTable;
//    if ( &ITM_deregisterTMCloneTable )
//      result = (__int64 (**)(void))ITM_deregisterTMCloneTable();
//  }
//  return result;
//}
//// 2194B0: using guessed type __int64 ITM_deregisterTMCloneTable(void);
//
////----- (0000000000007D10) ----------------------------------------------------
//__int64 sub_7D10()
//{
//  return 0LL;
//}
//
////----- (0000000000007D60) ----------------------------------------------------
//__int64 (**sub_7D60())(void)
//{
//  __int64 (**result)(void); // rax
//
//  if ( !byte_219050 )
//  {
//    if ( &__cxa_finalize )
//      _cxa_finalize(off_219008);
//    result = sub_7CD0();
//    byte_219050 = 1;
//  }
//  return result;
//}
// 3770: using guessed type __int64  _cxa_finalize(_QWORD);
// 219008: using guessed type void *off_219008;
// 219050: using guessed type char byte_219050;

//----- (0000000000007DA0) ----------------------------------------------------
__int64 sub_7DA0()
{
  return sub_7D10();
}

//----- (0000000000007DB0) ----------------------------------------------------
unsigned __int64  sub_7DB0(void *dest, __int64 a2, signed int a3, int a4)
{
  char *v4; // r13
  signed int v5; // ebp
  int v6; // er12
  char *v7; // r14
  size_t v8; // rbx
  __int64 v9; // rax
  void *v10; // rdi
  int v12; // ST0C_4
  char src; // [rsp+10h] [rbp-88h]
  unsigned __int64 v14; // [rsp+58h] [rbp-40h]

  v4 = (char *)dest;
  v5 = a3;
  v6 = a4 - 1;
  v14 = __readfsqword(0x28u);
  if ( a3 > 16 )
  {
    v12 = a4;
    v8 = 4LL * a3;
    v7 = (char *)malloc(4LL * a3);
    if ( !v12 )
    {
LABEL_10:
      free(v7);
      return __readfsqword(0x28u) ^ v14;
    }
  }
  else
  {
    if ( !a4 )
      return __readfsqword(0x28u) ^ v14;
    v7 = &src;
    v8 = 4LL * a3;
  }
  do
  {
    v9 = 0LL;
    if ( v5 > 0 )
    {
      do
      {
        *(_DWORD *)&v7[4 * v9] = *(_DWORD *)&v4[4 * *(unsigned __int8 *)(a2 + v9)];
        ++v9;
      }
      while ( (unsigned int)(v5 - 1) + 1LL != v9 );
    }
    v10 = v4;
    --v6;
    v4 += v8;
    memcpy(v10, v7, v8);
  }
  while ( v6 != -1 );
  if ( v5 > 16 )
    goto LABEL_10;
  return __readfsqword(0x28u) ^ v14;
}

//----- (0000000000007EB0) ----------------------------------------------------
unsigned __int64  sub_7EB0(void *dest, unsigned __int8 *a2, int a3, int a4, int a5)
{
  _BYTE *v5; // r9
  int v6; // er15
  int v7; // ebp
  int v8; // er12
  int v9; // eax
  char *v10; // r14
  signed __int64 v11; // r13
  _BYTE *v12; // rbx
  unsigned __int8 *v13; // rdi
  signed __int64 v14; // rsi
  char *v15; // rdx
  __int64 v16; // rax
  int v18; // ST1C_4
  size_t n; // [rsp+0h] [rbp-A8h]
  unsigned __int8 *v20; // [rsp+8h] [rbp-A0h]
  int v21; // [rsp+18h] [rbp-90h]
  char src; // [rsp+20h] [rbp-88h]
  unsigned __int64 v23; // [rsp+68h] [rbp-40h]

  v5 = dest;
  v6 = a5;
  v7 = a3;
  v8 = a4 - 1;
  v23 = __readfsqword(0x28u);
  v20 = a2;
  v9 = a5 * a3;
  v21 = a5 * a3;
  if ( a5 * a3 > 64 )
  {
    v18 = a4;
    n = v9;
    v10 = (char *)malloc(v9);
    v5 = dest;
    if ( !v18 )
    {
LABEL_15:
      free(v10);
      return __readfsqword(0x28u) ^ v23;
    }
  }
  else
  {
    if ( !a4 )
      return __readfsqword(0x28u) ^ v23;
    v10 = &src;
    n = v21;
  }
  v11 = (signed __int64)&a2[v7 - 1 + 1];
  while ( 1 )
  {
    v12 = v5;
    if ( v7 > 0 )
    {
      v13 = v20;
      v12 = v5;
      v14 = (unsigned int)(v6 - 1) + 1LL;
      do
      {
        v15 = &v10[v6 * *v13];
        if ( v6 )
        {
          v16 = 0LL;
          do
          {
            v15[v16] = v12[v16];
            ++v16;
          }
          while ( v16 != v14 );
          v12 += v14;
        }
        ++v13;
      }
      while ( v13 != (unsigned __int8 *)v11 );
    }
    --v8;
    memcpy(v5, v10, n);
    if ( v8 == -1 )
      break;
    v5 = v12;
  }
  if ( v21 > 64 )
    goto LABEL_15;
  return __readfsqword(0x28u) ^ v23;
}

//----- (0000000000007FF0) ----------------------------------------------------
signed __int64  sub_7FF0(int *a1, __int64 a2, double a3)
{
  int *v3; // rbx
  __int64 v4; // rbp
  int v5; // eax
  int *v6; // rdi
  int v7; // edx
  unsigned int v8; // eax
  int *v9; // rcx
  int v10; // esi
  unsigned int v11; // edx
  signed __int64 v12; // rcx
  int *v13; // rdi
  int v14; // edx
  unsigned int v15; // eax
  signed __int64 result; // rax
  int v17; // edx
  unsigned int v18; // eax
  int *v19; // rdx
  int v20; // ecx
  unsigned int v21; // eax
  int v22; // edx
  unsigned int v23; // eax
  __m128i v24; // xmm0
  unsigned __int8 v25; // cf
  signed __int64 v26; // rbx
  int v27; // eax
  int *v28; // rdi
  int v29; // edx
  unsigned int v30; // eax
  int *v31; // rdx
  int v32; // ecx
  unsigned int v33; // eax
  __m128i v34; // xmm0
  signed __int64 v35; // rdx
  int *v36; // rdx
  int v37; // ecx
  unsigned int v38; // eax
  __m128i v39; // xmm0
  int *v40; // rdx
  int v41; // ecx
  unsigned int v42; // eax
  __m128i v43; // xmm0
  int *v44; // rdx
  int v45; // ecx
  unsigned int v46; // eax
  signed __int64 v47; // rdx
  int *v48; // rdi
  int v49; // edx
  unsigned int v50; // eax
  int *v51; // rdx
  int v52; // ecx
  unsigned int v53; // eax
  signed __int64 v54; // rdx

  v3 = a1;
  v4 = a2;
  *(_WORD *)a1 = 45;
  v5 = *(_DWORD *)(a2 + 20);
  if ( v5 & 0x200 )
  {
    *(_WORD *)((char *)a1 + 1) = 102;
    v5 = *(_DWORD *)(a2 + 20);
  }
  else
  {
    if ( v5 & 0x1000 )
    {
      *((_BYTE *)a1 + 3) = 0;
      *(_WORD *)((char *)a1 + 1) = 26728;
      v5 = *(_DWORD *)(a2 + 20);
      if ( !(v5 & 8) )
        goto LABEL_6;
      goto LABEL_40;
    }
    if ( v5 & 0x800 )
    {
      *(_WORD *)((char *)a1 + 1) = 104;
      v5 = *(_DWORD *)(a2 + 20);
    }
  }
  if ( !(v5 & 8) )
    goto LABEL_6;
  do
  {
LABEL_40:
    v17 = *a1;
    ++a1;
    v18 = ~v17 & (v17 - 16843009) & 0x80808080;
  }
  while ( !v18 );
  if ( !((unsigned __int16)~(_WORD)v17 & (unsigned __int16)(v17 - 257) & 0x8080) )
    v18 >>= 16;
  a3 = *(float *)a2;
  if ( !((unsigned __int16)~(_WORD)v17 & (unsigned __int16)(v17 - 257) & 0x8080) )
    a1 = (int *)((char *)a1 + 2);
  __sprintf_chk((char *)a1 - __CFADD__((_BYTE)v18, (_BYTE)v18) - 3, 1LL, -1LL, &unk_129E4, a3);
  v5 = *(_DWORD *)(a2 + 20);
  if ( v5 & 0x100000 )
  {
    v51 = v3;
    do
    {
      v52 = *v51;
      ++v51;
      v53 = ~v52 & (v52 - 16843009) & 0x80808080;
    }
    while ( !v53 );
    if ( !((unsigned __int16)~(_WORD)v52 & (unsigned __int16)(v52 - 257) & 0x8080) )
      v53 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v52 & (unsigned __int16)(v52 - 257) & 0x8080) )
      v51 = (int *)((char *)v51 + 2);
    v54 = (signed __int64)((char *)v51 - __CFADD__((_BYTE)v53, (_BYTE)v53) - 3);
    *(_WORD *)v54 = 25443;
    *(_BYTE *)(v54 + 2) = 0;
    v5 = *(_DWORD *)(a2 + 20);
  }
  else if ( v5 & 0x80000 )
  {
    v19 = v3;
    do
    {
      v20 = *v19;
      ++v19;
      v21 = ~v20 & (v20 - 16843009) & 0x80808080;
    }
    while ( !v21 );
    if ( !((unsigned __int16)~(_WORD)v20 & (unsigned __int16)(v20 - 257) & 0x8080) )
      v21 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v20 & (unsigned __int16)(v20 - 257) & 0x8080) )
      v19 = (int *)((char *)v19 + 2);
    *(_WORD *)((char *)v19 - __CFADD__((_BYTE)v21, (_BYTE)v21) - 3) = 99;
    v5 = *(_DWORD *)(a2 + 20);
  }
LABEL_6:
  if ( v5 & 0x2000000 )
  {
    v6 = v3;
    do
    {
      v7 = *v6;
      ++v6;
      v8 = ~v7 & (v7 - 16843009) & 0x80808080;
    }
    while ( !v8 );
    if ( !((unsigned __int16)~(_WORD)v7 & (unsigned __int16)(v7 - 257) & 0x8080) )
      v8 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v7 & (unsigned __int16)(v7 - 257) & 0x8080) )
      v6 = (int *)((char *)v6 + 2);
    __sprintf_chk((char *)v6 - __CFADD__((_BYTE)v8, (_BYTE)v8) - 3, 1LL, -1LL, &unk_129E8, a3);
    v5 = *(_DWORD *)(a2 + 20);
  }
  if ( v5 & 0x10000 )
  {
    v9 = v3;
    do
    {
      v10 = *v9;
      ++v9;
      v11 = ~v10 & (v10 - 16843009) & 0x80808080;
    }
    while ( !v11 );
    if ( !((unsigned __int16)~(_WORD)v10 & (unsigned __int16)(v10 - 257) & 0x8080) )
      v11 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v10 & (unsigned __int16)(v10 - 257) & 0x8080) )
      v9 = (int *)((char *)v9 + 2);
    v12 = (signed __int64)((char *)v9 - __CFADD__((_BYTE)v11, (_BYTE)v11) - 3);
    if ( v5 & 0x10 )
    {
      *(_BYTE *)(v12 + 2) = 0;
      *(_WORD *)v12 = 12650;
      v27 = *(_DWORD *)(v4 + 20);
      if ( (v27 & 0x8000) == 0 )
        goto LABEL_24;
      goto LABEL_61;
    }
    *(_BYTE *)(v12 + 2) = 0;
    *(_WORD *)v12 = 12394;
    v5 = *(_DWORD *)(v4 + 20);
  }
  if ( (v5 & 0x8000) == 0 )
    goto LABEL_24;
LABEL_61:
  v28 = v3;
  do
  {
    v29 = *v28;
    ++v28;
    v30 = ~v29 & (v29 - 16843009) & 0x80808080;
  }
  while ( !v30 );
  if ( !((unsigned __int16)~(_WORD)v29 & (unsigned __int16)(v29 - 257) & 0x8080) )
    v30 >>= 16;
  a3 = *(float *)(v4 + 4);
  if ( !((unsigned __int16)~(_WORD)v29 & (unsigned __int16)(v29 - 257) & 0x8080) )
    v28 = (int *)((char *)v28 + 2);
  __sprintf_chk((char *)v28 - __CFADD__((_BYTE)v30, (_BYTE)v30) - 3, 1LL, -1LL, &unk_129EC, a3);
LABEL_24:
  if ( dword_2190A8 )
  {
    v13 = v3;
    do
    {
      v14 = *v13;
      ++v13;
      v15 = ~v14 & (v14 - 16843009) & 0x80808080;
    }
    while ( !v15 );
    if ( !((unsigned __int16)~(_WORD)v14 & (unsigned __int16)(v14 - 257) & 0x8080) )
      v15 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v14 & (unsigned __int16)(v14 - 257) & 0x8080) )
      v13 = (int *)((char *)v13 + 2);
    __sprintf_chk((char *)v13 - __CFADD__((_BYTE)v15, (_BYTE)v15) - 3, 1LL, -1LL, " --pre-quantize%s=%d", a3);
  }
  if ( *(_DWORD *)(v4 + 36) )
  {
    v48 = v3;
    do
    {
      v49 = *v48;
      ++v48;
      v50 = ~v49 & (v49 - 16843009) & 0x80808080;
    }
    while ( !v50 );
    if ( !((unsigned __int16)~(_WORD)v49 & (unsigned __int16)(v49 - 257) & 0x8080) )
      v50 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v49 & (unsigned __int16)(v49 - 257) & 0x8080) )
      v48 = (int *)((char *)v48 + 2);
    __sprintf_chk((char *)v48 - __CFADD__((_BYTE)v50, (_BYTE)v50) - 3, 1LL, -1LL, " --blocksize=%d", a3);
  }
  result = *(unsigned int *)(v4 + 20);
  if ( result & 0x20000 )
  {
    v44 = v3;
    do
    {
      v45 = *v44;
      ++v44;
      v46 = ~v45 & (v45 - 16843009) & 0x80808080;
    }
    while ( !v46 );
    if ( !((unsigned __int16)~(_WORD)v45 & (unsigned __int16)(v45 - 257) & 0x8080) )
      v46 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v45 & (unsigned __int16)(v45 - 257) & 0x8080) )
      v44 = (int *)((char *)v44 + 2);
    v47 = (signed __int64)((char *)v44 - __CFADD__((_BYTE)v46, (_BYTE)v46) - 3);
    *(_QWORD *)v47 = 7218537324306312480LL;
    *(_WORD *)(v47 + 8) = 29550;
    *(_BYTE *)(v47 + 10) = 0;
    result = *(unsigned int *)(v4 + 20);
  }
  if ( result & 0x20 )
  {
    v40 = v3;
    do
    {
      v41 = *v40;
      ++v40;
      v42 = ~v41 & (v41 - 16843009) & 0x80808080;
    }
    while ( !v42 );
    v43 = _mm_load_si128((const __m128i *)&xmmword_15D20);
    if ( !((unsigned __int16)~(_WORD)v41 & (unsigned __int16)(v41 - 257) & 0x8080) )
      v42 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v41 & (unsigned __int16)(v41 - 257) & 0x8080) )
      v40 = (int *)((char *)v40 + 2);
    *(__m128i *)((char *)v40 - __CFADD__((_BYTE)v42, (_BYTE)v42) - 3) = v43;
    result = *(unsigned int *)(v4 + 20);
  }
  if ( result & 0x10000000 )
  {
    v36 = v3;
    do
    {
      v37 = *v36;
      ++v36;
      v38 = ~v37 & (v37 - 16843009) & 0x80808080;
    }
    while ( !v38 );
    v39 = _mm_load_si128((const __m128i *)&xmmword_15D30);
    if ( !((unsigned __int16)~(_WORD)v37 & (unsigned __int16)(v37 - 257) & 0x8080) )
      v38 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v37 & (unsigned __int16)(v37 - 257) & 0x8080) )
      v36 = (int *)((char *)v36 + 2);
    *(__m128i *)((char *)v36 - __CFADD__((_BYTE)v38, (_BYTE)v38) - 3) = v39;
    result = *(unsigned int *)(v4 + 20);
  }
  if ( result & 0x20000000 )
  {
    v31 = v3;
    do
    {
      v32 = *v31;
      ++v31;
      v33 = ~v32 & (v32 - 16843009) & 0x80808080;
    }
    while ( !v33 );
    v34 = _mm_load_si128((const __m128i *)&xmmword_15D40);
    if ( !((unsigned __int16)~(_WORD)v32 & (unsigned __int16)(v32 - 257) & 0x8080) )
      v33 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v32 & (unsigned __int16)(v32 - 257) & 0x8080) )
      v31 = (int *)((char *)v31 + 2);
    v25 = __CFADD__((_BYTE)v33, (_BYTE)v33);
    result = 8317692662768297061LL;
    v35 = (signed __int64)((char *)v31 - v25 - 3);
    *(__m128i *)v35 = v34;
    *(_QWORD *)(v35 + 16) = 8317692662768297061LL;
    *(_BYTE *)(v35 + 24) = 0;
  }
  if ( dword_2190AC )
  {
    do
    {
      v22 = *v3;
      ++v3;
      v23 = ~v22 & (v22 - 16843009) & 0x80808080;
    }
    while ( !v23 );
    v24 = _mm_load_si128((const __m128i *)&xmmword_15D50);
    if ( !((unsigned __int16)~(_WORD)v22 & (unsigned __int16)(v22 - 257) & 0x8080) )
      v23 >>= 16;
    if ( !((unsigned __int16)~(_WORD)v22 & (unsigned __int16)(v22 - 257) & 0x8080) )
      v3 = (int *)((char *)v3 + 2);
    v25 = __CFADD__((_BYTE)v23, (_BYTE)v23);
    result = 29543LL;
    v26 = (signed __int64)((char *)v3 - v25 - 3);
    *(__m128i *)v26 = v24;
    *(_WORD *)(v26 + 16) = 29543;
    *(_BYTE *)(v26 + 18) = 0;
  }
  return result;
}
// 3650: using guessed type __int64  __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, double);
// 15D20: using guessed type __int128 xmmword_15D20;
// 15D30: using guessed type __int128 xmmword_15D30;
// 15D40: using guessed type __int128 xmmword_15D40;
// 15D50: using guessed type __int128 xmmword_15D50;
// 2190A8: using guessed type int dword_2190A8;
// 2190AC: using guessed type int dword_2190AC;

//----- (00000000000085B0) ----------------------------------------------------
signed __int64  sub_85B0(__int64 a1, _DWORD *a2, char a3, signed int a4, int a5)
{
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v8; // rax
  __int64 v9; // r8
  unsigned __int64 v10; // rax
  int v11; // edx
  __int64 v12; // r9
  signed __int64 v13; // r8
  __int64 v14; // rdx
  int v15; // eax
  signed __int64 v16; // r8
  __int64 v17; // rdx
  int v18; // eax
  __int64 v19; // rax
  __int64 v20; // rax
  unsigned __int64 v21; // rax
  signed __int64 v22; // r8
  __int64 v23; // rdx
  int v24; // eax
  __int64 v25; // r8
  __int64 v26; // rax
  int v27; // edx
  signed __int64 v28; // r8
  __int64 v29; // rax
  int v30; // edx
  __int64 v31; // r9
  __int64 v32; // rax
  int v33; // edx
  unsigned __int64 v34; // rax
  __int64 v35; // rax
  int v36; // ebx
  unsigned int v37; // eax
  __int64 v38; // rdx
  signed __int64 v39; // rcx
  int v40; // eax
  unsigned __int64 v41; // rax
  int v42; // ebx

  if ( !(a3 & 1) )
  {
    if ( a3 & 4 )
    {
      if ( a4 == 2 )
      {
        if ( a5 )
        {
          v9 = (unsigned int)(a5 - 1);
          v34 = 0LL;
          do
          {
            *(_WORD *)(a1 + v34) = a2[v34 / 2] + -32768;
            v34 += 2LL;
          }
          while ( v34 != 2 * v9 + 2 );
          return a1 + 2 * v9 + 2;
        }
        return a1;
      }
      if ( a4 <= 2 )
      {
        if ( a4 != 1 )
          return a1;
LABEL_48:
        v5 = (unsigned int)(a5 - 1);
        if ( a5 )
        {
          v20 = 0LL;
          do
          {
            *(_BYTE *)(a1 + v20) = LOBYTE(a2[v20]) + -128;
            ++v20;
          }
          while ( v20 != v5 + 1 );
          return a1 + v5 + 1;
        }
        return a1;
      }
      if ( a4 != 3 )
      {
        if ( a4 != 4 )
          return a1;
        v12 = (unsigned int)(a5 - 1);
        if ( !a5 )
          return a1;
        v13 = (signed __int64)&a2[v12 + 1];
        v14 = a1;
        do
        {
          v15 = *a2;
          ++a2;
          v14 += 4LL;
          *(_DWORD *)(v14 - 4) = v15 + 2147483648;
        }
        while ( a2 != (_DWORD *)v13 );
        return a1 + 4 * v12 + 4;
      }
      v37 = a5 - 1;
      if ( !a5 )
        return a1;
      v25 = v37;
      v38 = a1;
      v39 = a1 + 3LL * v37 + 3;
      do
      {
        ++a2;
        v38 += 3LL;
        v40 = *(a2 - 1) + 0x800000;
        *(_WORD *)(v38 - 3) = *((_WORD *)a2 - 2);
        *(_BYTE *)(v38 - 1) = BYTE2(v40);
      }
      while ( v39 != v38 );
    }
    else
    {
      if ( a4 == 1 )
      {
        if ( a3 & 2 )
        {
          v5 = (unsigned int)(a5 - 1);
          if ( a5 )
          {
            v8 = 0LL;
            do
            {
              *(_BYTE *)(a1 + v8) = a2[v8];
              ++v8;
            }
            while ( v8 != v5 + 1 );
            return a1 + v5 + 1;
          }
          return a1;
        }
        goto LABEL_48;
      }
      if ( a4 != 3 )
      {
        if ( a4 != 4 )
        {
          if ( a4 == 2 && a5 )
          {
            v9 = (unsigned int)(a5 - 1);
            v21 = 0LL;
            do
            {
              *(_WORD *)(a1 + v21) = a2[v21 / 2];
              v21 += 2LL;
            }
            while ( v21 != 2 * v9 + 2 );
            return a1 + 2 * v9 + 2;
          }
          return a1;
        }
        v12 = (unsigned int)(a5 - 1);
        if ( !a5 )
          return a1;
        v22 = (signed __int64)&a2[v12 + 1];
        v23 = a1;
        do
        {
          v24 = *a2;
          ++a2;
          v23 += 4LL;
          *(_DWORD *)(v23 - 4) = v24;
        }
        while ( a2 != (_DWORD *)v22 );
        return a1 + 4 * v12 + 4;
      }
      if ( !a5 )
        return a1;
      v25 = (unsigned int)(a5 - 1);
      v26 = a1;
      do
      {
        ++a2;
        v27 = *(a2 - 1);
        v26 += 3LL;
        *(_WORD *)(v26 - 3) = v27;
        *(_BYTE *)(v26 - 1) = BYTE2(v27);
      }
      while ( a1 + 3 * v25 + 3 != v26 );
    }
    return a1 + 3 * v25 + 3;
  }
  if ( !(a3 & 4) )
  {
    if ( a4 == 1 )
    {
      if ( a3 & 2 )
      {
        v5 = (unsigned int)(a5 - 1);
        if ( a5 )
        {
          v19 = 0LL;
          do
          {
            *(_BYTE *)(a1 + v19) = a2[v19];
            ++v19;
          }
          while ( v5 + 1 != v19 );
          return a1 + v5 + 1;
        }
        return a1;
      }
      goto LABEL_5;
    }
    if ( a4 != 3 )
    {
      if ( a4 != 4 )
      {
        if ( a4 == 2 && a5 )
        {
          v9 = (unsigned int)(a5 - 1);
          v10 = 0LL;
          do
          {
            v11 = a2[v10 / 2];
            *(_BYTE *)(a1 + v10) = BYTE1(v11);
            *(_BYTE *)(a1 + v10 + 1) = v11;
            v10 += 2LL;
          }
          while ( v10 != 2 * v9 + 2 );
          return a1 + 2 * v9 + 2;
        }
        return a1;
      }
      v12 = (unsigned int)(a5 - 1);
      if ( !a5 )
        return a1;
      v28 = (signed __int64)&a2[v12 + 1];
      v29 = a1;
      do
      {
        v30 = *a2;
        ++a2;
        v29 += 4LL;
        *(_BYTE *)(v29 - 2) = BYTE1(v30);
        *(_BYTE *)(v29 - 4) = HIBYTE(v30);
        *(_BYTE *)(v29 - 3) = BYTE2(v30);
        *(_BYTE *)(v29 - 1) = v30;
      }
      while ( a2 != (_DWORD *)v28 );
      return a1 + 4 * v12 + 4;
    }
    v31 = (unsigned int)(a5 - 1);
    if ( !a5 )
      return a1;
    v32 = a1;
    do
    {
      ++a2;
      v33 = *(a2 - 1);
      v32 += 3LL;
      *(_BYTE *)(v32 - 2) = BYTE1(v33);
      *(_BYTE *)(v32 - 3) = BYTE2(v33);
      *(_BYTE *)(v32 - 1) = v33;
    }
    while ( a1 + 3 * v31 + 3 != v32 );
    return a1 + 3 * v31 + 3;
  }
  if ( a4 == 2 )
  {
    if ( a5 )
    {
      v9 = (unsigned int)(a5 - 1);
      v41 = 0LL;
      do
      {
        v42 = a2[v41 / 2];
        *(_BYTE *)(a1 + v41) = (unsigned __int16)(v42 + -32768) >> 8;
        *(_BYTE *)(a1 + v41 + 1) = v42;
        v41 += 2LL;
      }
      while ( 2 * v9 + 2 != v41 );
      return a1 + 2 * v9 + 2;
    }
    return a1;
  }
  if ( a4 <= 2 )
  {
    if ( a4 == 1 )
    {
LABEL_5:
      v5 = (unsigned int)(a5 - 1);
      if ( a5 )
      {
        v6 = 0LL;
        do
        {
          *(_BYTE *)(a1 + v6) = LOBYTE(a2[v6]) + -128;
          ++v6;
        }
        while ( v6 != v5 + 1 );
        return a1 + v5 + 1;
      }
      return a1;
    }
    return a1;
  }
  if ( a4 != 3 )
  {
    if ( a4 != 4 )
      return a1;
    v12 = (unsigned int)(a5 - 1);
    if ( !a5 )
      return a1;
    v16 = (signed __int64)&a2[v12 + 1];
    v17 = a1;
    do
    {
      v18 = *a2;
      ++a2;
      v17 += 4LL;
      v18 += 2147483648;
      *(_BYTE *)(v17 - 2) = BYTE1(v18);
      *(_BYTE *)(v17 - 4) = HIBYTE(v18);
      *(_BYTE *)(v17 - 3) = BYTE2(v18);
      *(_BYTE *)(v17 - 1) = v18;
    }
    while ( (_DWORD *)v16 != a2 );
    return a1 + 4 * v12 + 4;
  }
  v31 = (unsigned int)(a5 - 1);
  if ( !a5 )
    return a1;
  v35 = a1;
  do
  {
    ++a2;
    v36 = *(a2 - 1);
    v35 += 3LL;
    *(_BYTE *)(v35 - 2) = (unsigned __int16)*(a2 - 1) >> 8;
    *(_BYTE *)(v35 - 3) = (unsigned int)(v36 + 0x800000) >> 16;
    *(_BYTE *)(v35 - 1) = v36;
  }
  while ( a1 + 3 * v31 + 3 != v35 );
  return a1 + 3 * v31 + 3;
}

//----- (0000000000008A80) ----------------------------------------------------
unsigned __int64  sub_8A80(double a1)
{
  __int64 v2; // [rsp-28h] [rbp-38h]
  unsigned __int64 v3; // [rsp+0h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  __sprintf_chk(&v2, 1LL, 40LL, "%d%% (WavPack)", (a1 + (double)dword_2190C8) / (double)dword_2190CC * 100.0 + 0.5);
  sub_11940((__int64)&v2);
  return __readfsqword(0x28u) ^ v3;
}
// 3650: using guessed type __int64  __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, double);
// 2190C8: using guessed type int dword_2190C8;
// 2190CC: using guessed type int dword_2190CC;

//----- (0000000000008B10) ----------------------------------------------------
__int64  sub_8B10(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _DWORD *v4; // rbp
  __int64 v5; // r13
  unsigned int v6; // er14
  signed __int64 v7; // r13
  __int64 v8; // rsi
  int v9; // eax
  signed int v10; // er12
  char *v11; // r15
  int *v12; // r9
  char *v13; // rdi
  int *v14; // rdx
  __int64 v15; // rax
  int v16; // esi
  int v17; // er12
  __m128d v18; // xmm1
  double v19; // xmm0_8
  __m128d v20; // xmm7
  double v21; // xmm0_8
  __m128d v22; // xmm1
  int v23; // er11
  int v24; // er10
  unsigned int v25; // ebp
  __int64 v27; // rax
  __m128d v28; // xmm6
  __int64 v29; // rdx
  __m128i v30; // xmm0
  __int64 v31; // rax
  __int128 *v32; // rbx
  __int64 v33; // r15
  __int64 v34; // r14
  __int128 *v35; // rdi
  __int8 *v36; // rdi
  __int64 v37; // rdx
  __int64 v38; // rdx
  __int64 v39; // rdx
  __int64 v40; // rax
  _QWORD *v41; // [rsp+8h] [rbp-1C0h]
  _BYTE *ptr; // [rsp+10h] [rbp-1B8h]
  __int64 v43; // [rsp+18h] [rbp-1B0h]
  char v44; // [rsp+20h] [rbp-1A8h]
  signed int v45; // [rsp+24h] [rbp-1A4h]
  double v46; // [rsp+28h] [rbp-1A0h]
  signed int v47; // [rsp+38h] [rbp-190h]
  char v48; // [rsp+60h] [rbp-168h]
  __int128 v49; // [rsp+C0h] [rbp-108h]
  __m128i v50; // [rsp+D0h] [rbp-F8h]
  __m128i v51; // [rsp+E0h] [rbp-E8h]
  char v52; // [rsp+F0h] [rbp-D8h]
  __m128i v53; // [rsp+100h] [rbp-C8h]
  __m128i v54; // [rsp+110h] [rbp-B8h]
  char v55; // [rsp+120h] [rbp-A8h]
  char v56; // [rsp+130h] [rbp-98h]
  unsigned __int64 v57; // [rsp+188h] [rbp-40h]

  v41 = a2;
  v57 = __readfsqword(0x28u);
  v2 = WavpackOpenFileInput(a1, &v56, 1281LL, 0LL);
  if ( !v2 )
  {
    v25 = 1;
    sub_11570((__int64)&v56);
    return v25;
  }
  v3 = v2;
  if ( a2 )
    MD5_Init(&v48);
  v44 = WavpackGetQualifyMode(v3);
  v45 = WavpackGetNumChannels(v3);
  v47 = WavpackGetBytesPerSample(v3);
  v4 = malloc(v45 << 14);
  if ( v44 & 8 )
  {
    v5 = v45;
    if ( (unsigned __int8)WavpackGetChannelLayout(v3, 0LL) <= v45 )
    {
      ptr = malloc(v45);
      v6 = -1;
      if ( v45 )
      {
        v40 = 0LL;
        v6 = v45 - 1;
        do
        {
          ptr[v40] = v40;
          ++v40;
        }
        while ( (unsigned int)(v45 - 1) + 1LL != v40 );
      }
      WavpackGetChannelLayout(v3, ptr);
    }
    else
    {
      ptr = 0LL;
      v6 = v45 - 1;
    }
  }
  else
  {
    v5 = v45;
    ptr = 0LL;
    v6 = v45 - 1;
  }
  v7 = 4 * v5;
  v43 = 0LL;
  v46 = -1.0;
  while ( 1 )
  {
    v8 = (__int64)v4;
    v9 = WavpackUnpackSamples(v3, v4, 4096LL);
    v43 += v9;
    v10 = v9;
    if ( !v9 )
      break;
    if ( v41 )
    {
      if ( ptr )
        sub_7DB0(v4, (__int64)ptr, v45, v9);
      if ( !(v44 & 0x30) )
      {
        sub_85B0((__int64)v4, v4, v44, v47, v10 * v45);
        MD5_Update(&v48, v4, v24 * v23 * v10);
        if ( (unsigned int)sub_11700() )
        {
LABEL_34:
          v8 = (__int64)stderr;
          fputc(10, stderr);
          fflush(stderr);
          free(v4);
          if ( ptr )
            free(ptr);
          goto LABEL_36;
        }
        goto LABEL_25;
      }
      v11 = (char *)malloc(v45 << 12);
      if ( v44 & 0x40 )
      {
        if ( v45 )
        {
          v12 = v4;
          v13 = v11;
          do
          {
            v14 = v12;
            v15 = 0LL;
            do
            {
              while ( v10 <= (signed int)v15 )
              {
                v13[v15++] = 0;
                v14 = (int *)((char *)v14 + v7);
                if ( v15 == 4096 )
                  goto LABEL_21;
              }
              v16 = *v14;
              if ( v44 & 0x10 )
                LOBYTE(v16) = byte_15C20[(unsigned __int8)*v14];
              v13[v15++] = v16;
              v14 = (int *)((char *)v14 + v7);
            }
            while ( v15 != 4096 );
LABEL_21:
            v13 += 4096;
            v12 = (int *)((char *)v12 + (v45 << 14) - 4LL * (v45 << 12) + 4);
          }
          while ( v13 != &v11[4096 * v6 + 4096] );
        }
        v17 = v45 << 12;
      }
      else
      {
        v17 = v45 * v10;
        if ( v17 )
        {
          v27 = 0LL;
          do
          {
            v11[v27] = v4[v27];
            ++v27;
          }
          while ( (unsigned int)(v17 - 1) + 1LL != v27 );
        }
      }
      MD5_Update(&v48, v11, v17);
      free(v11);
    }
    if ( (unsigned int)sub_11700() )
      goto LABEL_34;
LABEL_25:
    if ( WavpackGetProgress(v3) != -1.0 )
    {
      v19 = *(double *)&qword_219070 + WavpackGetProgress(v3) * (100.0 - *(double *)&qword_219070) + 0.5;
      v18[0] = v19;
      if ( fabs(v19) < 4.503599627370496e15 )
      {
        v20[0] = (double)(signed int)v19;

      }
      if ( v19 != v46 )
      {
        v21 = WavpackGetProgress(v3);
        v22[0] = *(double *)&qword_219070 + v21 * (100.0 - *(double *)&qword_219070) + 0.5;
        if ( fabs(v22[0]) < 4.503599627370496e15 )
        {
          v28[0] = (double)(signed int)v22[0];
          v46 = v22[0];
          if ( !dword_2190B0 )
            goto LABEL_31;
LABEL_44:
          sub_8A80(v22[0] / 100.0);
          if ( !dword_2190C0 )
          {
LABEL_32:
            __fprintf_chk(stderr, 1LL, "%s%3d%% done...", "\b\b\b\b\b\b\b\b\b\b\b\b");
            fflush(stderr);
          }
        }
        else
        {
          v46 = *(double *)&qword_219070 + v21 * (100.0 - *(double *)&qword_219070) + 0.5;
          if ( dword_2190B0 )
            goto LABEL_44;
LABEL_31:
          if ( !dword_2190C0 )
            goto LABEL_32;
        }
      }
    }
  }
  free(v4);
  if ( ptr )
  {
    free(ptr);
    if ( v41 )
      goto LABEL_48;
LABEL_53:
    if ( WavpackGetNumSamples64(v3, v8, v29) == -1 )
      goto LABEL_70;
    if ( WavpackGetNumSamples64(v3, v8, v37) > v43 )
    {
      v25 = 1;
      v8 = WavpackGetNumSamples64(v3, v8, v38) - v43;
      sub_11570((__int64)"file is missing %llu samples!", v8);
      goto LABEL_61;
    }
    if ( WavpackGetNumSamples64(v3, v8, v38) >= v43 )
    {
LABEL_70:
      v25 = 0;
    }
    else
    {
      v25 = 1;
      v8 = v43 - WavpackGetNumSamples64(v3, v8, v39);
      sub_11570((__int64)"file has %llu extra samples!", v8);
    }
LABEL_61:
    if ( (unsigned int)WavpackGetNumErrors(v3) )
    {
      v8 = (unsigned int)WavpackGetNumErrors(v3);
      sub_11570((__int64)"missing data or crc errors detected in %d block(s)!", v8);
LABEL_36:
      v25 = 1;
      goto LABEL_37;
    }
  }
  else
  {
    if ( !v41 )
      goto LABEL_53;
LABEL_48:
    v8 = (__int64)&v48;
    MD5_Final(&v49, &v48);
    v29 = *v41 ^ v49 | v41[1] ^ *((_QWORD *)&v49 + 1);
    if ( *(QWORD *)v41 == v49 )
      goto LABEL_53;
    v30 = _mm_load_si128((const __m128i *)&xmmword_15D70);
    v52 = 0;
    v55 = 0;
    v50 = v30;
    v31 = v3;
    v51 = v30;
    v32 = (__int128 *)&v50;
    v33 = 0LL;
    v34 = v31;
    v53 = v30;
    v54 = v30;
    do
    {
      v35 = v32;
      v32 = (__int128 *)((char *)v32 + 2);
      __sprintf_chk(v35, 1LL, -1LL, "%02x", *(double *)v30[0]);
      v36 = v53[2 * v33++];
      __sprintf_chk(v36, 1LL, -1LL, "%02x", *(double *)v30[0]);
    }
    while ( v33 != 16 );
    v3 = v34;
    v25 = 1;
    sub_11570((__int64)"original md5: %s", &v50);
    v8 = (__int64)&v53;
    sub_11570((__int64)"verified md5: %s", &v53);
    sub_11570((__int64)"MD5 signatures should match, but do not!");
  }
LABEL_37:
  WavpackCloseFile(v3, v8);
  return v25;
}
// 3090: using guessed type __int64  __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 30D0: using guessed type __int64  WavpackOpenFileInput(_QWORD, _QWORD, _QWORD, _QWORD);
// 3260: using guessed type __int64  WavpackGetChannelLayout(_QWORD, _QWORD);
// 3290: using guessed type __int64  WavpackGetBytesPerSample(_QWORD);
// 32A0: using guessed type __int64  MD5_Final(_QWORD, _QWORD);
// 32B0: using guessed type __int64  MD5_Update(_QWORD, _QWORD, _QWORD);
// 32C0: using guessed type double  WavpackGetProgress(_QWORD);
// 33F0: using guessed type __int64  WavpackGetNumSamples64(_QWORD, _QWORD, _QWORD);
// 3420: using guessed type __int64  WavpackUnpackSamples(_QWORD, _QWORD, _QWORD);
// 34B0: using guessed type __int64  WavpackGetNumErrors(_QWORD);
// 3540: using guessed type __int64  MD5_Init(_QWORD);
// 3600: using guessed type __int64  WavpackGetNumChannels(_QWORD);
// 3650: using guessed type __int64  __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, double);
// 3680: using guessed type __int64  WavpackGetQualifyMode(_QWORD);
// 36B0: using guessed type __int64  WavpackCloseFile(_QWORD, _QWORD);
// 15D70: using guessed type __int128 xmmword_15D70;
// 219070: using guessed type __int64 qword_219070;
// 2190B0: using guessed type int dword_2190B0;
// 2190C0: using guessed type int dword_2190C0;

//----- (00000000000092C0) ----------------------------------------------------
__int64  sub_92C0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // ebx
  __int64 v4; // rbp
  FILE *v5; // rdi
  unsigned int v6; // er12
  int v7; // eax
  int v9; // [rsp+4h] [rbp-24h]
  unsigned __int64 v10; // [rsp+8h] [rbp-20h]

  v3 = *(_DWORD *)(a1 + 16);
  v10 = __readfsqword(0x28u);
  if ( v3 )
    return 0;
  v4 = a1;
  v5 = *(FILE **)(a1 + 8);
  if ( !v5 )
    return 1;
  if ( !a2 )
    return 1;
  v6 = a3;
  if ( !a3 )
    return 1;
  if ( (unsigned int)sub_11780(v5, a2, a3, &v9) && v6 == v9 )
  {
    v7 = *(_DWORD *)(v4 + 4);
    *(_DWORD *)v4 += v6;
    if ( !v7 )
      *(_DWORD *)(v4 + 4) = v6;
    return 1;
  }
  sub_118D0(*(FILE **)(v4 + 8));
  sub_118A0(*(FILE **)(v4 + 8));
  *(_QWORD *)(v4 + 8) = 0LL;
  *(_DWORD *)(v4 + 16) = 1;
  return v3;
}

//----- (0000000000009380) ----------------------------------------------------
__int64  sub_9380(const char *a1, char *a2, char *a3, const __m128i *a4)
{
  __m128i v4; // xmm0
  __int64 v5; // rax
  _BOOL4 v6; // ebx
  char *v7; // rsi
  size_t *v8; // rdx
  __m128i v9; // xmm0
  __int64 v10; // r14
  int *v11; // rax
  int v12; // ecx
  unsigned int v13; // edx
  bool v14; // zf
  char *v15; // rbx
  int i; // er13
  int v17; // er12
  signed __int64 v18; // rax
  const char *v19; // rax
  FILE *v20; // rax
  FILE *v21; // r13
  int v22; // er15
  FILE *v23; // rax
  FILE *v24; // r13
  int v25; // er15
  unsigned int v26; // ebx
  FILE *v27; // rax
  size_t v28; // rbp
  int v29; // ecx
  FILE *v30; // rax
  int *v31; // rdx
  int v32; // ecx
  unsigned int v33; // eax
  unsigned __int8 v34; // cf
  const char *v35; // rax
  __int8 v36; // al
  const char *v37; // rdi
  const char *v38; // rax
  unsigned int v40; // er13
  unsigned int v41; // er14
  __int64 v42; // rax
  signed __int64 v43; // rdx
  signed __int64 v44; // rbp
  char *v45; // r15
  signed int v46; // ebx
  __int32 v47; // ebp
  __int64 v48; // rax
  char *v49; // rdi
  char *v50; // rdx
  int v51; // eax
  int v52; // eax
  unsigned int v53; // er12
  unsigned __int8 *v54; // r13
  __int64 v55; // rdx
  __int64 v56; // rbx
  __int64 v57; // rdx
  __int64 v58; // r15
  unsigned __int8 *v59; // r9
  _DWORD *v60; // rsi
  __int64 v61; // r8
  __int64 v62; // rcx
  unsigned __int8 *v63; // rax
  __int64 v64; // rdx
  char *v65; // rdi
  unsigned int v66; // er15
  signed int v67; // er13
  signed int v68; // ebx
  char *v69; // r12
  const char *v70; // rdi
  signed __int64 j; // rbp
  int v72; // ebp
  char *v73; // r12
  int v74; // eax
  float *v75; // r13
  __int64 v76; // rdx
  unsigned int v77; // esi
  unsigned int v78; // eax
  unsigned int v79; // edx
  unsigned int v80; // ebp
  int v81; // ebx
  int v82; // eax
  signed int v83; // ebx
  int v84; // eax
  __int64 v85; // rcx
  __int64 v86; // rax
  signed __int64 v87; // rcx
  __m128d v88; // xmm2
  double v89; // xmm0_8
  __m128d v90; // xmm7
  __m128d v91; // xmm1
  __m128d v92; // xmm5
  char *v93; // rcx
  int *v94; // rdx
  int v95; // ecx
  unsigned int v96; // eax
  const char *v97; // rax
  int *v98; // rdx
  int v99; // ecx
  unsigned int v100; // eax
  unsigned int v101; // ecx
  bool v102; // zf
  const char *v103; // rax
  char v104; // al
  const char *v105; // rsi
  __int64 v106; // rbp
  char *v107; // r13
  __int64 v108; // rax
  unsigned __int64 v109; // rsi
  char v110; // al
  int v111; // er9
  float *v112; // rax
  __m128d v113; // xmm0
  __m128d v114; // xmm7
  float v115; // xmm6_4
  int v116; // eax
  int v117; // eax
  __m128d v118; // xmm2
  double v119; // xmm0_8
  __m128d v120; // xmm7
  __m128d v121; // xmm1
  __m128d v122; // xmm4
  char *v123; // rcx
  int v124; // ebx
  int v125; // eax
  __int64 v126; // rcx
  __int64 v127; // rax
  signed __int64 v128; // rcx
  unsigned __int8 v129; // al
  __int32 v130; // ebx
  __int64 v131; // rax
  signed __int64 v132; // rsi
  unsigned __int64 v133; // rax
  __int64 v134; // rsi
  signed __int64 v135; // rdi
  float *v136; // rax
  signed __int64 v137; // rax
  unsigned __int64 v138; // rsi
  signed int v139; // er13
  signed int v140; // er12
  char *v141; // r15
  char *v142; // rbp
  __m128i v143; // xmm0
  char *v144; // rdi
  char *v145; // r15
  const char *v146; // rbx
  unsigned __int64 v147; // rsi
  const char *v148; // rcx
  size_t v149; // rax
  signed __int64 v150; // rsi
  unsigned __int64 v151; // rax
  FILE *v152; // rax
  size_t v153; // rbx
  int *v154; // rdx
  int v155; // ecx
  unsigned int v156; // eax
  unsigned int v157; // ecx
  bool v158; // zf
  const char *v159; // rax
  char v160; // al
  double v161; // xmm0_8
  const char *v162; // r8
  unsigned __int64 v163; // rdi
  __int64 v164; // rdx
  __int64 v165; // rbx
  unsigned int v166; // eax
  char *v167; // rdi
  __int64 v168; // rcx
  __int64 v169; // rdx
  __int64 v170; // rbx
  char *v171; // rbx
  char *v172; // rdi
  __int64 v173; // rcx
  __int64 v174; // rax
  signed __int64 v175; // rcx
  __int64 v176; // rcx
  __int64 v177; // rax
  signed __int64 v178; // rcx
  int v179; // eax
  signed int v180; // ebp
  char *v181; // rbx
  signed int v182; // ebp
  float *v183; // rdi
  char *v184; // rsi
  signed __int64 v185; // r8
  int v186; // eax
  int v187; // edx
  _BOOL4 v188; // eax
  const char *v189; // rsi
  char *v190; // rsi
  __int64 v191; // rbx
  __int64 v192; // rbx
  signed __int64 v193; // rdx
  int v194; // ebx
  signed __int64 v195; // rsi
  unsigned __int64 v196; // rax
  float *v197; // rdi
  char *v198; // rsi
  signed __int64 v199; // r8
  __int16 v200; // ax
  int v201; // edx
  signed __int64 v202; // rsi
  unsigned __int64 v203; // rax
  double v204; // xmm0_8
  double v205; // xmm0_8
  FILE *v206; // rbx
  char *v207; // r12
  float *v208; // rdi
  unsigned __int8 *v209; // rsi
  signed __int64 v210; // r8
  int v211; // eax
  int v212; // edx
  unsigned __int64 v213; // rcx
  int v214; // eax
  int v215; // ecx
  float *v216; // rax
  int v217; // edx
  unsigned int v218; // er13
  signed __int64 v219; // rsi
  char *v220; // rbp
  signed __int64 v221; // rcx
  unsigned __int64 v222; // rax
  float *v223; // rdi
  unsigned __int16 *v224; // rsi
  signed __int64 v225; // r8
  int v226; // eax
  int v227; // edx
  int v228; // eax
  int v229; // edx
  double v230; // xmm0_8
  double v231; // ST10_8
  double v232; // ST38_8
  double v233; // ST28_8
  __int64 v234; // rdx
  signed int v235; // eax
  double v236; // xmm0_8
  double v237; // xmm0_8
  int v238; // ST58_4
  int v239; // ST60_4
  size_t v240; // rbp
  char *src; // [rsp+8h] [rbp-370h]
  FILE *stream; // [rsp+10h] [rbp-368h]
  char *newa; // [rsp+18h] [rbp-360h]
  signed int newb; // [rsp+18h] [rbp-360h]
  unsigned int v245; // [rsp+20h] [rbp-358h]
  signed int v246; // [rsp+20h] [rbp-358h]
  char *old; // [rsp+28h] [rbp-350h]
  char *filename; // [rsp+30h] [rbp-348h]
  __int64 v249; // [rsp+38h] [rbp-340h]
  unsigned __int32 v250; // [rsp+38h] [rbp-340h]
  char *dest; // [rsp+40h] [rbp-338h]
  int v252; // [rsp+48h] [rbp-330h]
  unsigned __int8 *v253; // [rsp+50h] [rbp-328h]
  char v254; // [rsp+50h] [rbp-328h]
  char *v255; // [rsp+68h] [rbp-310h]
  __int64 v256; // [rsp+68h] [rbp-310h]
  _DWORD *v257; // [rsp+70h] [rbp-308h]
  double v258; // [rsp+70h] [rbp-308h]
  double v259; // [rsp+78h] [rbp-300h]
  char *v260; // [rsp+78h] [rbp-300h]
  double v261; // [rsp+80h] [rbp-2F8h]
  __int64 v262; // [rsp+88h] [rbp-2F0h]
  double v263; // [rsp+90h] [rbp-2E8h]
  int v264; // [rsp+98h] [rbp-2E0h]
  unsigned int v265; // [rsp+A0h] [rbp-2D8h]
  signed int v266; // [rsp+A4h] [rbp-2D4h]
  _BYTE v267[5]; // [rsp+BBh] [rbp-2BDh]
  int v268; // [rsp+C0h] [rbp-2B8h]
  int v269; // [rsp+C0h] [rbp-2B8h]
  char ptr; // [rsp+DBh] [rbp-29Dh]
  int v271; // [rsp+DCh] [rbp-29Ch]
  double v272; // [rsp+E0h] [rbp-298h]
  struct timezone tz; // [rsp+E8h] [rbp-290h]
  struct timeval tv; // [rsp+F0h] [rbp-288h]
  struct timeval v275; // [rsp+100h] [rbp-278h]
  size_t size[2]; // [rsp+110h] [rbp-268h]
  __int64 v277; // [rsp+120h] [rbp-258h]
  size_t v278[2]; // [rsp+130h] [rbp-248h]
  __int64 v279; // [rsp+140h] [rbp-238h]
  __m128i v280; // [rsp+150h] [rbp-228h]
  __m128i v281; // [rsp+160h] [rbp-218h]
  __m128i v282; // [rsp+170h] [rbp-208h]
  __m128i v283; // [rsp+180h] [rbp-1F8h]
  __m128i v284; // [rsp+190h] [rbp-1E8h]
  __int64 v285; // [rsp+1A0h] [rbp-1D8h]
  char v286; // [rsp+1B0h] [rbp-1C8h]
  char v287; // [rsp+210h] [rbp-168h]
  __int128 v288; // [rsp+220h] [rbp-158h]
  char s1[16]; // [rsp+230h] [rbp-148h]
  __m128i v290; // [rsp+240h] [rbp-138h]
  __m128i v291; // [rsp+250h] [rbp-128h]
  __int64 v292; // [rsp+260h] [rbp-118h]
  char v293; // [rsp+268h] [rbp-110h]
  unsigned __int64 v294; // [rsp+338h] [rbp-40h]

  v4 = _mm_load_si128(a4);
  v294 = __readfsqword(0x28u);
  v280 = v4;
  v5 = a4[5][0];
  src = a2;
  v6 = a3 != 0LL;
  v14 = a3 == 0LL;
  v7 = (char *)size;
  newa = a3;
  v8 = v278;
  filename = (char *)a1;
  v281 = _mm_load_si128(a4 + 1);
  v285 = v5;
  if ( v14 )
    v8 = 0LL;
  v9 = _mm_load_si128(a4 + 2);
  v277 = 0LL;
  v279 = 0LL;
  v282 = v9;
  v283 = _mm_load_si128(a4 + 3);
  v284 = _mm_load_si128(a4 + 4);
  *(QWORD *)size = 0LL;
  *(QWORD *)v278 = 0LL;
  v10 = WavpackOpenFileOutput(sub_92C0, size, v8);
  if ( *a1 == 45 )
  {
    stream = stdin;
  }
  else
  {
    v7 = "rb";
    stream = fopen(a1, "rb");
    if ( !stream )
    {
      v26 = 1;
      sub_11570((__int64)"can't open file %s!", a1);
      WavpackCloseFile(v10, a1);
      return v26;
    }
  }
  if ( !(v281[0] & 0x10) )
    goto LABEL_6;
  v42 = sub_117F0(stream);
  if ( !v42 )
  {
    if ( !dword_219098 )
    {
      v281[0] |= 0x800u;
      v44 = -1LL;
      goto LABEL_77;
    }
    v70 = "can't skip trailer in raw PCM read from stdin!";
LABEL_407:
    sub_11570((__int64)v70, v7, v43);
    goto LABEL_84;
  }
  v70 = "no raw PCM data to encode!";
  v43 = (v42 - (dword_21909C + dword_219098)) % (v281[0] * v280[0]);
  v44 = (v42 - (dword_21909C + dword_219098)) / (v281[0] * v280[0]);
  if ( v44 <= 0 )
    goto LABEL_407;
  if ( v43 )
    sub_11570(
      (__int64)"warning: raw PCM infile length does not divide evenly, %d bytes will be discarded",
      (unsigned int)v43);
LABEL_77:
  if ( !v283[0] && !(v281[0] & 4) )
  {
    if ( v281[3] <= 2 )
    {
      v283[0] = 5 - v281[0];
    }
    else if ( v281[0] > 18 )
    {
      v283[0] = 0x3FFFF;
    }
    else
    {
      v283[0] = (1 << v281[12]) - 1;
    }
  }
  if ( !(unsigned int)WavpackSetConfiguration64(v10, &v280, v44, 0LL) )
  {
    v7 = (char *)WavpackGetErrorMessage(v10);
    sub_11570((__int64)"%s", v7);
    goto LABEL_84;
  }
LABEL_6:
  if ( *src != 45 )
  {
    v27 = fopen(src, "rb");
    size[1] = (size_t)v27;
    if ( !v27 || (v28 = fread(&ptr, 1uLL, 1uLL, v27), sub_118A0((FILE *)size[1]), v28 != 1) )
    {
      if ( !newa )
        goto LABEL_39;
LABEL_34:
      v11 = (int *)src;
      if ( !dword_2190D0 )
      {
        v30 = fopen(newa, "rb");
        v278[1] = (size_t)v30;
        if ( !v30 )
          goto LABEL_38;
        v240 = fread(&ptr, 1uLL, 1uLL, v30);
        sub_118A0((FILE *)v278[1]);
        if ( v240 != 1 )
          goto LABEL_38;
        goto LABEL_355;
      }
      do
      {
        v29 = *v11;
        ++v11;
        v13 = ~v29 & (v29 - 16843009) & 0x80808080;
      }
      while ( !v13 );
LABEL_11:
      v14 = (unsigned __int16)(v13 & 0x8080) == 0;
      if ( !(v13 & 0x8080) )
        LOBYTE(v13) = BYTE2(v13);
      if ( v14 )
        v11 = (int *)((char *)v11 + 2);
      v15 = (char *)malloc((char *)v11 - __CFADD__((_BYTE)v13, (_BYTE)v13) - 3 - src + 16);
LABEL_16:
      dest = (char *)malloc(strlen(src) + 16);
LABEL_17:
      for ( i = 0; ; i = v17 )
      {
        v17 = i + 1;
        strcpy(v15, src);
        if ( sub_11230(v15) )
        {
          if ( i )
          {
            v18 = sub_11230(v15);
            __sprintf_chk(v18, 1LL, -1LL, ".tmp%d", 0.0);
          }
          else
          {
            v137 = sub_11230(v15);
            *(_DWORD *)v137 = 1886221358;
            *(_BYTE *)(v137 + 4) = 0;
          }
          v19 = (const char *)sub_11230(src);
          strcat(v15, v19);
        }
        else
        {
          v163 = (unsigned __int64)&v15[strlen(v15)];
          if ( i )
          {
            __sprintf_chk(v163, 1LL, -1LL, ".tmp%d", 0.0);
          }
          else
          {
            *(_DWORD *)v163 = 1886221358;
            *(_BYTE *)(v163 + 4) = 0;
            v17 = 1;
          }
        }
        v20 = fopen(v15, "rb");
        v21 = v20;
        if ( v20 )
        {
          v22 = fread(&ptr, 1uLL, 1uLL, v20);
          fclose(v21);
          if ( v22 == 1 )
            continue;
        }
        if ( !newa )
          break;
        *(_WORD *)stpcpy(dest, v15) = 99;
        v23 = fopen(dest, "rb");
        v24 = v23;
        if ( !v23 )
          break;
        v25 = fread(&ptr, 1uLL, 1uLL, v23);
        fclose(v24);
        if ( v25 != 1 )
          break;
      }
      v7 = (char *)&tz;
      gettimeofday(&tv, &tz);
      old = v15;
      v245 = 1;
      if ( *src != 45 )
        goto LABEL_41;
      goto LABEL_86;
    }
    if ( dword_2190D0 )
    {
      if ( !newa )
        goto LABEL_229;
    }
    else
    {
      v98 = (int *)src;
      do
      {
        v99 = *v98;
        ++v98;
        v100 = ~v99 & (v99 - 16843009) & 0x80808080;
      }
      while ( !v100 );
      v101 = v100 >> 16;
      v102 = (unsigned __int16)(v100 & 0x8080) == 0;
      if ( !(v100 & 0x8080) )
        LOBYTE(v100) = v101;
      if ( v102 )
        v98 = (int *)((char *)v98 + 2);
      v34 = __CFADD__((_BYTE)v100, (_BYTE)v100);
      v103 = src;
      if ( (unsigned __int64)((char *)v98 - v34 - 3 - src) > 0x1E )
        v103 = sub_113E0(src);
      v7 = (_BYTE *)(&size + 1);
      __fprintf_chk(stderr, 1LL, "overwrite %s (yes/no/all)? ", v103);
      fflush(stderr);
      if ( dword_2190B0 )
        sub_11940((__int64)"overwrite?");
      v104 = sub_11410();
      if ( v104 != 97 )
      {
        if ( v104 == 110 )
          goto LABEL_84;
        v6 = 1;
        if ( newa )
          goto LABEL_34;
LABEL_229:
        dest = 0LL;
        v15 = (char *)malloc(strlen(src) + 16);
        goto LABEL_17;
      }
      dword_2190D0 = 1;
      if ( !newa )
        goto LABEL_229;
    }
LABEL_9:
    v11 = (int *)src;
    do
    {
      v12 = *v11;
      ++v11;
      v13 = ~v12 & (v12 - 16843009) & 0x80808080;
    }
    while ( !v13 );
    goto LABEL_11;
  }
  if ( newa )
  {
    if ( !dword_2190D0 )
    {
      v152 = fopen(newa, "rb");
      v278[1] = (size_t)v152;
      if ( v152 )
      {
        v153 = fread(&ptr, 1uLL, 1uLL, v152);
        sub_118A0((FILE *)v278[1]);
        if ( v153 != 1 )
          goto LABEL_582;
        v6 = 1;
LABEL_355:
        v154 = (int *)newa;
        do
        {
          v155 = *v154;
          ++v154;
          v156 = ~v155 & (v155 - 16843009) & 0x80808080;
        }
        while ( !v156 );
        v157 = v156 >> 16;
        v158 = (unsigned __int16)(v156 & 0x8080) == 0;
        if ( !(v156 & 0x8080) )
          LOBYTE(v156) = v157;
        if ( v158 )
          v154 = (int *)((char *)v154 + 2);
        v34 = __CFADD__((_BYTE)v156, (_BYTE)v156);
        v159 = newa;
        if ( (unsigned __int64)((char *)v154 - v34 - 3 - newa) > 0x1E )
          v159 = sub_113E0(newa);
        v7 = (_BYTE *)(&size + 1);
        __fprintf_chk(stderr, 1LL, "overwrite %s (yes/no/all)? ", v159);
        fflush(stderr);
        if ( dword_2190B0 )
          sub_11940((__int64)"overwrite?");
        v160 = sub_11410();
        if ( v160 == 97 )
        {
          dword_2190D0 = 1;
        }
        else if ( v160 == 110 )
        {
          goto LABEL_84;
        }
LABEL_38:
        if ( !v6 )
          goto LABEL_39;
LABEL_582:
        v15 = (char *)malloc(strlen(src) + 16);
        dest = 0LL;
        if ( !newa )
          goto LABEL_17;
        goto LABEL_16;
      }
    }
    goto LABEL_9;
  }
LABEL_39:
  v7 = (char *)&tz;
  gettimeofday(&tv, &tz);
  if ( *src != 45 )
  {
    v15 = src;
    v245 = 0;
    dest = 0LL;
    old = 0LL;
LABEL_41:
    v7 = "w+b";
    size[1] = (size_t)fopen(v15, "w+b");
    if ( size[1] )
      goto LABEL_42;
    v7 = v15;
    sub_11570((__int64)"can't create file %s!", v15);
LABEL_84:
    sub_118A0(stream);
    goto LABEL_63;
  }
  v245 = 0;
  dest = 0LL;
  old = 0LL;
LABEL_86:
  size[1] = stdout;
LABEL_42:
  if ( !dword_2190C0 )
  {
    if ( *src == 45 )
    {
      v148 = "stdin";
      if ( *filename != 45 )
      {
        v149 = strlen(filename);
        v148 = filename;
        if ( v149 > 0x1E )
          v148 = sub_113E0(filename);
      }
      v7 = (_BYTE *)(&size + 1);
      __fprintf_chk(stderr, 1LL, "packing %s to stdout,", v148);
    }
    else if ( newa )
    {
      sub_11230(newa);
      v31 = (int *)src;
      do
      {
        v32 = *v31;
        ++v31;
        v33 = ~v32 & (v32 - 16843009) & 0x80808080;
      }
      while ( !v33 );
      if ( !(~v32 & (v32 - 16843009) & 0x8080) )
        LOBYTE(v33) = (~v32 & (v32 - 16843009) & 0x80808080) >> 16;
      if ( !(~v32 & (v32 - 16843009) & 0x8080) )
        v31 = (int *)((char *)v31 + 2);
      v34 = __CFADD__((_BYTE)v33, (_BYTE)v33);
      v35 = src;
      if ( (unsigned __int64)((char *)v31 - v34 - 3 - src) > 0x1E )
        v35 = sub_113E0(src);
      v7 = (_BYTE *)(&size + 1);
      __fprintf_chk(stderr, 1LL, "creating %s (+%s),", v35);
    }
    else
    {
      v94 = (int *)src;
      do
      {
        v95 = *v94;
        ++v94;
        v96 = ~v95 & (v95 - 16843009) & 0x80808080;
      }
      while ( !v96 );
      if ( !((unsigned __int16)~(_WORD)v95 & (unsigned __int16)(v95 - 257) & 0x8080) )
        LOBYTE(v96) = (~v95 & (v95 - 16843009) & 0x80808080) >> 16;
      if ( !((unsigned __int16)~(_WORD)v95 & (unsigned __int16)(v95 - 257) & 0x8080) )
        v94 = (int *)((char *)v94 + 2);
      v34 = __CFADD__((_BYTE)v96, (_BYTE)v96);
      v97 = src;
      if ( (unsigned __int64)((char *)v94 - v34 - 3 - src) > 0x1E )
        v97 = sub_113E0(src);
      v7 = (_BYTE *)(&size + 1);
      __fprintf_chk(stderr, 1LL, "creating %s,", v97);
    }
    fflush(stderr);
  }
  v36 = v281[0];
  if ( v281[1] & 0x10
    && (!(v281[0] & 0x30)
     || (v7 = "dff", WavpackSetFileInformation(v10, "dff", 3LL), v36 = v281[0], v281[1] & 0x10)) )
  {
    v40 = dword_21909C;
    if ( dword_21909C )
    {
      v249 = v10;
      do
      {
        v41 = 256;
        if ( v40 < 0x100 )
          v41 = v40;
        v7 = s1;
        if ( !(unsigned int)sub_11710(stream, (__int64)s1, v41, &v271) || v271 != v41 )
        {
          v7 = filename;
          v10 = v249;
          sub_11570((__int64)"can't read file %s!", filename);
          goto LABEL_60;
        }
        v40 -= v271;
      }
      while ( v40 );
      v10 = v249;
      v266 = 1;
      v36 = v281[0];
    }
    else
    {
      v266 = 1;
    }
  }
  else
  {
    if ( !(unsigned int)sub_11710(stream, (__int64)s1, 4u, &v271) || v271 != 4 )
    {
      v7 = filename;
      v37 = "can't read file %s!";
      goto LABEL_59;
    }
    v105 = "RIFF";
    LODWORD(v106) = 0;
    v107 = (char *)&unk_2188E0;
    while ( strncmp(s1, v105, 4uLL) )
    {
      LODWORD(v106) = v106 + 1;
      v107 += 40;
      if ( (_DWORD)v106 == 6 )
      {
        v7 = filename;
        v37 = "%s is not a recognized file type!";
LABEL_59:
        sub_11570((__int64)v37, v7);
LABEL_60:
        sub_118A0(stream);
        sub_118A0((FILE *)size[1]);
        v38 = src;
        if ( v245 )
          v38 = old;
        sub_11910(v38);
LABEL_63:
        v26 = 1;
        WavpackCloseFile(v10, v7);
        return v26;
      }
      v105 = (const char *)*((_QWORD *)v107 + 1);
    }
    v106 = (signed int)v106;
    v218 = *((unsigned __int8 *)&unk_2188E0 + 40 * (signed int)v106);
    if ( sub_11230(filename) )
      v219 = sub_11230(filename) + 1;
    else
      v219 = *((_QWORD *)&unk_2188E0 + 5 * v106 + 2);
    WavpackSetFileInformation(v10, v219, v218);
    v7 = filename;
    v220 = (char *)&unk_2188E0 + 40 * v106;
    if ( (*((unsigned int ( **)(FILE *, char *, char *, __int64, __m128i *))v220 + 3))(
           stream,
           filename,
           s1,
           v10,
           &v280) )
    {
      goto LABEL_60;
    }
    v266 = *((_DWORD *)v220 + 8);
    v36 = v281[0];
  }
  if ( v36 & 8
    && (v7 = 0LL, v129 = WavpackGetChannelLayout(v10, 0LL), v130 = v281[3], v129 <= v281[3]) )
  {
    v45 = (char *)malloc(v281[3]);
    if ( v130 )
    {
      v131 = 0LL;
      do
      {
        v45[v131] = v131;
        ++v131;
      }
      while ( (unsigned int)(v130 - 1) + 1LL != v131 );
    }
    v7 = v45;
    WavpackGetChannelLayout(v10, v45);
  }
  else
  {
    v45 = 0LL;
  }
  v46 = dword_219094;
  if ( dword_219094 || v281[1] & 4 )
  {
    v47 = v281[3];
    if ( dword_219094 > v281[3] || dword_219094 < v281[3] && !(v281[1] & 4) )
    {
      v7 = (char *)(unsigned int)dword_219094;
      sub_11570((__int64)"file does not have %d channel(s)!", (unsigned int)dword_219094);
      goto LABEL_60;
    }
    if ( dword_219094 )
    {
      v45 = (char *)malloc(v281[3]);
      if ( v47 > 0 )
      {
        v48 = 0LL;
        do
        {
          v45[v48] = v48;
          ++v48;
        }
        while ( (unsigned int)(v47 - 1) + 1LL != v48 );
      }
      v7 = byte_219080;
      memcpy(v45, byte_219080, v46);
      if ( v46 > 0 )
      {
        v7 = 0LL;
        do
        {
          v49 = v45;
          v50 = v45;
          v51 = 0;
          while ( (unsigned __int8)*v50 != (_DWORD)v7 )
          {
            ++v51;
            ++v50;
            if ( v46 == v51 )
              goto LABEL_234;
          }
          v7 = (char *)(unsigned int)((_DWORD)v7 + 1);
          if ( v46 != v51 )
            continue;
          do
          {
LABEL_234:
            if ( (unsigned __int8)*v49 > (signed int)v7 )
              --*v49;
            ++v49;
          }
          while ( &v45[v46 - 1 + 1] != v49 );
        }
        while ( v46 > (signed int)v7 );
      }
    }
  }
  if ( !newa )
    goto LABEL_108;
  if ( !v245 )
  {
    v7 = "w+b";
    v278[1] = (size_t)fopen(newa, "w+b");
    if ( v278[1] )
      goto LABEL_108;
    sub_11570((__int64)"can't create correction file!", "w+b");
    sub_118A0(stream);
    sub_118A0((FILE *)size[1]);
    old = src;
LABEL_486:
    v26 = 1;
    sub_11910(old);
    WavpackCloseFile(v10, "w+b");
    return v26;
  }
  v7 = "w+b";
  v278[1] = (size_t)fopen(dest, "w+b");
  if ( !v278[1] )
  {
    sub_11570((__int64)"can't create correction file!", "w+b");
    sub_118A0(stream);
    sub_118A0((FILE *)size[1]);
    goto LABEL_486;
  }
LABEL_108:
  v250 = v281[0];
  v52 = v281[1] & 0x8000000;
  if ( v281[0] & 0x30 )
  {
    if ( v52 || (v255 = 0LL, dword_2190BC) )
    {
      MD5_Init(&v286);
      v255 = &v287;
    }
    WavpackPackInit(v10, v7);
    v53 = WavpackGetNumChannels(v10);
    v54 = (unsigned __int8 *)malloc((signed int)(v53 << 12));
    v257 = malloc((signed __int64)(signed int)v53 << 14);
    v56 = WavpackGetNumSamples64(v10, v7, v55);
    if ( v56 )
    {
      v253 = (unsigned __int8 *)v45;
      v259 = -1.0;
      while ( 1 )
      {
        LODWORD(v275.tv_sec) = 0;
        if ( v56 <= 4096 && (v250 & 0x40) == 0 )
          break;
        sub_11710(stream, (__int64)v54, v53 << 12, &v275);
        if ( !(v250 & 0x40) )
          goto LABEL_240;
        if ( v53 << 12 == LODWORD(v275.tv_sec) )
        {
          if ( v56 <= 4095 )
          {
            LODWORD(v58) = v56;
            v56 -= (signed int)v56;
          }
          else
          {
            v56 -= 4096LL;
            LODWORD(v58) = 4096;
          }
        }
        else
        {
          v56 = 0LL;
          LODWORD(v58) = 0;
          sub_11570((__int64)"incomplete DSD block!", v54);
        }
LABEL_119:
        v7 = (char *)v253;
        if ( v253 && !(v250 & 8) )
        {
          if ( v250 & 0x40 )
          {
            sub_7EB0(v54, v253, v53, 1, 4096);
          }
          else
          {
            v7 = (char *)v253;
            sub_7EB0(v54, v253, v53, v58, 1);
          }
        }
        if ( v255 )
        {
          v7 = (char *)v54;
          MD5_Update(&v286, v54, LODWORD(v275.tv_sec));
        }
        if ( !(_DWORD)v58 )
        {
LABEL_142:
          v45 = (char *)v253;
          goto LABEL_143;
        }
        if ( v250 & 0x40 )
        {
          v59 = v54;
          v60 = v257;
          v61 = 0LL;
          LODWORD(v62) = 0;
          do
          {
            v63 = v59;
            if ( v53 )
            {
              do
              {
                while ( 1 )
                {
                  v57 = *v63;
                  if ( (signed int)v58 > (signed int)v62 )
                    break;
                  v61 = (unsigned int)v61 - (((unsigned __int8)v57 < 1u) - 1);
                  v63 += 4096;
                  if ( v63 == &v59[4096 * (unsigned __int64)(v53 - 1) + 4096] )
                    goto LABEL_135;
                }
                if ( v250 & 0x10 )
                  v57 = (unsigned __int8)byte_15C20[*v63];
                v63 += 4096;
                *v60 = v57;
                ++v60;
              }
              while ( v63 != &v59[4096 * (unsigned __int64)(v53 - 1) + 4096] );
            }
LABEL_135:
            v62 = (unsigned int)(v62 + 1);
            ++v59;
          }
          while ( (_DWORD)v62 != 4096 );
          if ( (_DWORD)v61 )
            sub_11570((__int64)"blocks not padded with NULLs, MD5 will not match!", v60, v57, v62, v61, v59);
        }
        else if ( (_DWORD)v58 * v53 )
        {
          v108 = 0LL;
          do
          {
            v257[v108] = v54[v108];
            ++v108;
          }
          while ( v108 != (unsigned int)v58 * v53 - 1 + 1LL );
        }
        v7 = (char *)v257;
        if ( !(unsigned int)WavpackPackSamples(v10, v257, (unsigned int)v58) )
        {
          v45 = (char *)v253;
          v26 = 2;
          v7 = (char *)WavpackGetErrorMessage(v10);
          sub_11570((__int64)"%s", v7);
          free(v257);
          free(v54);
          goto LABEL_146;
        }
        if ( (unsigned int)sub_11700() )
        {
          v7 = (char *)stderr;
          v45 = (char *)v253;
          v26 = 1;
          fputc(10, stderr);
          fflush(stderr);
          free(v257);
          free(v54);
          goto LABEL_146;
        }
        if ( WavpackGetProgress(v10) != -1.0 )
        {
          v119 = *(double *)&qword_219070 * WavpackGetProgress(v10) + 0.5;
          v118[0] = v119;
          if ( fabs(v119) < 4.503599627370496e15 )
          {
            v120[0] = (double)(signed int)v119;
          }
          if ( v119 != v259 )
          {
            v121[0] = WavpackGetProgress(v10) * *(double *)&qword_219070 + 0.5;
            if ( fabs(v121[0]) < 4.503599627370496e15 )
            {
              v122[0] = (double)(signed int)v121[0];
            }
            if ( dword_2190B0 )
              sub_8A80(v121[0] / 100.0);
            v7 = (char *)(unsigned int)dword_2190C0;
            if ( dword_2190C0 )
            {
              v259 = v121[0];
            }
            else
            {
              v123 = " ";
              if ( v259 != -1.0 )
                v123 = "\b\b\b\b\b\b\b\b\b\b\b\b";
              v7 = (_BYTE *)(&size + 1);
              v259 = v121[0];
              __fprintf_chk(stderr, 1LL, "%s%3d%% done...", v123);
              fflush(stderr);
            }
          }
        }
        if ( !v56 )
          goto LABEL_142;
      }
      sub_11710(stream, (__int64)v54, v56 * v53, &v275);
LABEL_240:
      v57 = LODWORD(v275.tv_sec) % v53;
      v58 = (signed int)(LODWORD(v275.tv_sec) / v53);
      v56 -= v58;
      goto LABEL_119;
    }
LABEL_143:
    free(v257);
    free(v54);
    if ( (unsigned int)WavpackFlushSamples(v10, v7) )
    {
      v65 = v255;
      v26 = 0;
      if ( !v255 )
        goto LABEL_146;
      goto LABEL_145;
    }
LABEL_586:
    v26 = 2;
    v7 = (char *)WavpackGetErrorMessage(v10);
    sub_11570((__int64)"%s", v7);
    goto LABEL_146;
  }
  if ( v52 || dword_2190BC )
  {
    v254 = 1;
    v260 = &v287;
  }
  else
  {
    v254 = 0;
    v260 = 0LL;
  }
  for ( j = 0x10000LL; (unsigned __int64)(4 * j * (signed int)WavpackGetNumChannels(v10)) > 0x200000; j >>= 1 )
    ;
  v262 = j;
  if ( v260 )
    MD5_Init(&v286);
  WavpackPackInit(v10, v7);
  v72 = WavpackGetBytesPerSample(v10);
  v265 = (unsigned __int64)WavpackGetNumChannels(v10) * v72;
  v73 = (char *)malloc((unsigned int)v262 * v265);
  v74 = WavpackGetNumChannels(v10);
  v75 = (float *)malloc(v74 * 4 * v262);
  v256 = WavpackGetNumSamples64(v10, v7, v76);
  v252 = dword_2190A8;
  if ( dword_2190A8 )
  {
    if ( (signed int)(8 * (unsigned __int64)WavpackGetBytesPerSample(v10)) > dword_2190A8 )
    {
      v182 = 1 << (8 * (unsigned __int64)WavpackGetBytesPerSample(v10) - dword_2190A8);
      v252 = -v182;
      if ( WavpackGetMode(v10) & 8 )
      {
        v238 = WavpackGetFloatNormExp(v10);
        v239 = dword_2190A8;
        v261 = exp2((double)(dword_2190A8 + 126 - v238));
        v258 = exp2((double)(v238 - 126 - v239));
      }
      else
      {
        v258 = 1.0;
        v261 = 1.0;
      }
      v264 = v252 ^ (v252 >> 1);
      v254 &= v182 == 0;
    }
    else
    {
      v264 = 0;
      v252 = 0;
      v258 = 1.0;
      v261 = 1.0;
    }
  }
  else
  {
    v264 = 0;
    v258 = 1.0;
    v261 = 1.0;
  }
  v267[4] = 0;
  v263 = -1.0;
  *(_DWORD *)v267 = (v250 >> 11) & 1;
  while ( 1 )
  {
    LODWORD(v275.tv_sec) = 0;
    if ( v262 < v256 || v267[0] )
      v77 = v262 * v265;
    else
      v77 = v256 * v265;
    v78 = v77 / v265;
    v79 = v77;
    v7 = v73;
    v256 -= v78;
    sub_11710(stream, (__int64)v73, v79, &v275);
    v80 = LODWORD(v275.tv_sec) / v265;
    if ( v45 )
    {
      if ( v250 & 8 )
      {
        if ( !v254 )
          goto LABEL_178;
      }
      else
      {
        v124 = WavpackGetBytesPerSample(v10);
        v125 = WavpackGetNumChannels(v10);
        v7 = v45;
        sub_7EB0(v73, (unsigned __int8 *)v45, v125, v80, v124);
        if ( !v254 )
          goto LABEL_179;
      }
      v7 = v73;
      MD5_Update(&v286, v73, (signed int)(v80 * v265));
      if ( v250 & 8 )
      {
LABEL_178:
        v81 = WavpackGetBytesPerSample(v10);
        v82 = WavpackGetNumChannels(v10);
        v7 = v45;
        sub_7EB0(v73, (unsigned __int8 *)v45, v82, v80, v81);
        goto LABEL_179;
      }
    }
    else if ( v254 )
    {
      v7 = v73;
      MD5_Update(&v286, v73, (signed int)(LODWORD(v275.tv_sec) / v265 * v265));
    }
LABEL_179:
    if ( !v80 )
      break;
    v83 = WavpackGetBytesPerSample(v10);
    v84 = v80 * (unsigned __int64)WavpackGetNumChannels(v10);
    if ( v250 & 1 )
    {
      if ( v250 & 4 )
      {
        if ( v83 == 2 )
        {
          if ( v84 )
          {
            v213 = 0LL;
            do
            {
              LODWORD(v75[v213 / 2]) = (unsigned __int16)__ROL2__(*(_WORD *)&v73[v213], 8) - 0x8000;
              v213 += 2LL;
            }
            while ( 2LL * (unsigned int)(v84 - 1) + 2 != v213 );
          }
        }
        else
        {
          if ( v83 <= 2 )
          {
            if ( v83 != 1 )
              goto LABEL_187;
LABEL_184:
            if ( v84 )
            {
              v85 = (unsigned int)(v84 - 1);
              v86 = 0LL;
              v87 = v85 + 1;
              do
              {
                LODWORD(v75[v86]) = (unsigned __int8)v73[v86] - 128;
                ++v86;
              }
              while ( v86 != v87 );
            }
            goto LABEL_187;
          }
          if ( v83 == 3 )
          {
            if ( v84 )
            {
              v208 = v75;
              v209 = (unsigned __int8 *)v73;
              v210 = (signed __int64)&v73[3 * (v84 - 1) + 3];
              do
              {
                v211 = v209[1];
                v212 = *v209;
                v209 += 3;
                ++v208;
                *((_DWORD *)v208 - 1) = (*(v209 - 1) | (v212 << 16) | (v211 << 8)) - 0x800000;
              }
              while ( (unsigned __int8 *)v210 != v209 );
            }
          }
          else if ( v83 == 4 && v84 )
          {
            v132 = 4LL * (unsigned int)(v84 - 1) + 4;
            v133 = 0LL;
            do
            {
              LODWORD(v75[v133 / 4]) = _byteswap_ulong(*(_DWORD *)&v73[v133]) + 2147483648;
              v133 += 4LL;
            }
            while ( v132 != v133 );
          }
        }
      }
      else
      {
        switch ( v83 )
        {
          case 1:
            if ( !(v250 & 2) )
              goto LABEL_184;
            if ( v84 )
            {
              v176 = (unsigned int)(v84 - 1);
              v177 = 0LL;
              v178 = v176 + 1;
              do
              {
                LODWORD(v75[v177]) = v73[v177];
                ++v177;
              }
              while ( v178 != v177 );
            }
            break;
          case 3:
            if ( v84 )
            {
              v197 = v75;
              v198 = v73;
              v199 = (signed __int64)&v73[3 * (v84 - 1) + 3];
              do
              {
                v200 = *(_WORD *)(v198 + 1);
                v201 = *v198;
                v198 += 3;
                ++v197;
                *((_DWORD *)v197 - 1) = (v201 << 16) | (unsigned __int16)__ROL2__(v200, 8);
              }
              while ( v198 != (char *)v199 );
            }
            break;
          case 4:
            if ( v84 )
            {
              v202 = 4LL * (unsigned int)(v84 - 1) + 4;
              v203 = 0LL;
              do
              {
                LODWORD(v75[v203 / 4]) = _byteswap_ulong(*(_DWORD *)&v73[v203]);
                v203 += 4LL;
              }
              while ( v202 != v203 );
            }
            break;
          default:
            if ( v83 == 2 && v84 )
            {
              v147 = 0LL;
              do
              {
                LODWORD(v75[v147 / 2]) = (unsigned __int8)v73[v147 + 1] | (v73[v147] << 8);
                v147 += 2LL;
              }
              while ( 2LL * (unsigned int)(v84 - 1) + 2 != v147 );
            }
            break;
        }
      }
    }
    else
    {
      if ( !(v250 & 4) )
      {
        if ( v83 != 1 )
        {
          if ( v83 == 3 )
          {
            if ( v84 )
            {
              v223 = v75;
              v224 = (unsigned __int16 *)v73;
              v225 = (signed __int64)&v73[3 * (v84 - 1) + 3];
              do
              {
                v226 = *((char *)v224 + 2);
                v227 = *v224;
                v224 = (unsigned __int16 *)((char *)v224 + 3);
                ++v223;
                *((_DWORD *)v223 - 1) = v227 | (v226 << 16);
              }
              while ( v224 != (unsigned __int16 *)v225 );
            }
          }
          else if ( v83 == 4 )
          {
            if ( v84 )
            {
              v221 = 4LL * (unsigned int)(v84 - 1) + 4;
              v222 = 0LL;
              do
              {
                v75[v222 / 4] = *(float *)&v73[v222];
                v222 += 4LL;
              }
              while ( v221 != v222 );
            }
          }
          else if ( v83 == 2 && v84 )
          {
            v109 = 0LL;
            do
            {
              LODWORD(v75[v109 / 2]) = (unsigned __int8)v73[v109] | (v73[v109 + 1] << 8);
              v109 += 2LL;
            }
            while ( 2LL * (unsigned int)(v84 - 1) + 2 != v109 );
          }
          goto LABEL_187;
        }
        if ( v250 & 2 )
        {
          if ( v84 )
          {
            v126 = (unsigned int)(v84 - 1);
            v127 = 0LL;
            v128 = v126 + 1;
            do
            {
              LODWORD(v75[v127]) = v73[v127];
              ++v127;
            }
            while ( v128 != v127 );
          }
          goto LABEL_187;
        }
        goto LABEL_402;
      }
      if ( v83 == 2 )
      {
        if ( v84 )
        {
          v195 = 2LL * (unsigned int)(v84 - 1) + 2;
          v196 = 0LL;
          do
          {
            LODWORD(v75[v196 / 2]) = *(unsigned __int16 *)&v73[v196] - 0x8000;
            v196 += 2LL;
          }
          while ( v195 != v196 );
        }
      }
      else
      {
        if ( v83 <= 2 )
        {
          if ( v83 != 1 )
            goto LABEL_187;
LABEL_402:
          if ( v84 )
          {
            v173 = (unsigned int)(v84 - 1);
            v174 = 0LL;
            v175 = v173 + 1;
            do
            {
              LODWORD(v75[v174]) = (unsigned __int8)v73[v174] - 128;
              ++v174;
            }
            while ( v175 != v174 );
          }
          goto LABEL_187;
        }
        if ( v83 == 3 )
        {
          if ( v84 )
          {
            v183 = v75;
            v184 = v73;
            v185 = (signed __int64)&v73[3 * (v84 - 1) + 3];
            do
            {
              v186 = (unsigned __int8)v184[1];
              v187 = (unsigned __int8)v184[2];
              v184 += 3;
              ++v183;
              *((_DWORD *)v183 - 1) = ((unsigned __int8)*(v184 - 3) | (v187 << 16) | (v186 << 8)) - 0x800000;
            }
            while ( v184 != (char *)v185 );
          }
        }
        else if ( v83 == 4 && v84 )
        {
          v150 = 4LL * (unsigned int)(v84 - 1) + 4;
          v151 = 0LL;
          do
          {
            LODWORD(v75[v151 / 4]) = *(_DWORD *)&v73[v151] + 2147483648;
            v151 += 4LL;
          }
          while ( v150 != v151 );
        }
      }
    }
LABEL_187:
    if ( !v252 )
      goto LABEL_188;
    v268 = v80 * (unsigned __int64)WavpackGetNumChannels(v10);
    v110 = WavpackGetMode(v10);
    v111 = v268;
    if ( v110 & 8 )
    {
      if ( v268 )
      {
        v112 = v75;
        do
        {
          v113[0] = *v112 * v261 + 0.5;
          if ( fabs(v113[0]) < 4.503599627370496e15 )
          {
            v114[0] = (double)(signed int)v113[0];
          }
          ++v112;
          v115 = v113[0] * v258;
          *(v112 - 1) = v115;
        }
        while ( &v75[v268 - 1 + 1] != v112 );
      }
      goto LABEL_262;
    }
    if ( dword_2190A4 )
    {
      v214 = WavpackGetBytesPerSample(v10);
      v111 = v268;
      v215 = 8 * (4 - v214);
      if ( !v268 )
        goto LABEL_262;
      v135 = (signed __int64)(v75 + 1);
      v216 = v75;
      v134 = (unsigned int)(v268 - 1);
      do
      {
        v217 = *(_DWORD *)v216 + v264;
        if ( *(_DWORD *)v216 < 0 || v217 << v215 > 0 )
          *(_DWORD *)v216 = v217;
        ++v216;
      }
      while ( v216 != &v75[v268 - 1 + 1] );
    }
    else
    {
      v134 = (unsigned int)(v268 - 1);
      v135 = (signed __int64)(v75 + 1);
      if ( !v268 )
        goto LABEL_262;
    }
    v136 = v75;
    do
    {
      *(_DWORD *)v136 &= v252;
      ++v136;
    }
    while ( (float *)(v135 + 4 * v134) != v136 );
LABEL_262:
    v269 = v111;
    if ( v260 )
    {
      v116 = WavpackGetNumChannels(v10);
      sub_85B0((__int64)v73, v75, v250, v83, v80 * v116);
      v117 = WavpackGetBytesPerSample(v10);
      MD5_Update(&v286, v73, (unsigned int)(v269 * v117));
    }
LABEL_188:
    if ( !(unsigned int)WavpackPackSamples(v10, v75, v80) )
    {
      v26 = 2;
      v7 = (char *)WavpackGetErrorMessage(v10);
      sub_11570((__int64)"%s", v7);
      free(v75);
      free(v73);
      goto LABEL_146;
    }
    if ( (unsigned int)sub_11700() )
    {
      v7 = (char *)stderr;
      v26 = 1;
      fputc(10, stderr);
      fflush(stderr);
      free(v75);
      free(v73);
      goto LABEL_146;
    }
    if ( WavpackGetProgress(v10) != -1.0 )
    {
      v89 = *(double *)&qword_219070 * WavpackGetProgress(v10) + 0.5;
      v88[0] = v89;
      if ( fabs(v89) < 4.503599627370496e15 )
      {
        v90[0] = (double)(signed int)v89;

      }
      if ( v89 != v263 )
      {
        v91[0] = WavpackGetProgress(v10) * *(double *)&qword_219070 + 0.5;
        if ( fabs(v91[0]) < 4.503599627370496e15 )
        {
          v92[0] = (double)(signed int)v91[0];

        }
        if ( dword_2190B0 )
          sub_8A80(v91[0] / 100.0);
        if ( dword_2190C0 )
        {
          v263 = v91[0];
        }
        else
        {
          v93 = " ";
          if ( v263 != -1.0 )
            v93 = "\b\b\b\b\b\b\b\b\b\b\b\b";
          v263 = v91[0];
          __fprintf_chk(stderr, 1LL, "%s%3d%% done...", v93);
          fflush(stderr);
        }
      }
    }
  }
  v26 = *(_DWORD *)&v267[1];
  free(v75);
  free(v73);
  if ( !(unsigned int)WavpackFlushSamples(v10, v7) )
    goto LABEL_586;
  v65 = v260;
  if ( v260 )
  {
LABEL_145:
    v7 = &v286;
    MD5_Final(v65, &v286);
  }
LABEL_146:
  if ( v45 )
    free(v45);
  if ( v26 )
  {
    v66 = 0;
    sub_118A0(stream);
    goto LABEL_308;
  }
  if ( v281[7] & 8 )
  {
    v7 = &v287;
    WavpackStoreMD5Sum(v10, &v287);
  }
  v66 = v281[0] & 0x1800;
  if ( v281[0] & 0x1800 )
  {
    v66 = 0;
    sub_118A0(stream);
LABEL_380:
    if ( !(unsigned int)WavpackFlushSamples(v10, v7) )
      goto LABEL_389;
    if ( v66 | dword_21906C )
    {
      if ( dword_21906C > 0 )
      {
        v165 = 0LL;
        v166 = 1;
        while ( 1 )
        {
          while ( 1 )
          {
            v167 = (char *)ptr + 32 * v165;
            v168 = *((unsigned int *)v167 + 6);
            if ( (_DWORD)v168 )
              break;
            if ( (signed int)v165 + 1 >= dword_21906C )
              goto LABEL_392;
            ++v165;
          }
          v169 = *((_QWORD *)v167 + 1);
          v7 = *(char **)v167;
          v166 = *((_DWORD *)v167 + 7) ? (unsigned int)WavpackAppendBinaryTagItem(v10, v7, v169, v168) : (unsigned int)WavpackAppendTagItem(v10, v7, v169, v168);
          if ( dword_21906C <= (signed int)v165 + 1 )
            break;
          ++v165;
          if ( !v166 )
            goto LABEL_389;
        }
LABEL_392:
        if ( !v166 )
          goto LABEL_389;
      }
      if ( !(unsigned int)WavpackWriteTag(v10) )
      {
LABEL_389:
        v26 = 2;
        v7 = (char *)WavpackGetErrorMessage(v10);
        sub_11570((__int64)"%s", v7);
        goto LABEL_308;
      }
    }
    v170 = WavpackGetNumSamples64(v10, v7, v164);
    if ( v170 != WavpackGetSampleIndex64(v10) )
    {
      if ( !(v281[1] & 8) )
      {
        v26 = 1;
        sub_11570((__int64)"couldn't read all samples, file may be corrupt!!");
        goto LABEL_308;
      }
      v171 = (char *)malloc(HIDWORD(size[0]));
      if ( !v171 )
      {
        v26 = 1;
        sub_11570((__int64)"couldn't update WavPack header with actual length!!");
        goto LABEL_308;
      }
      v7 = 0LL;
      if ( sub_11870((FILE *)size[1], 0LL)
        || (v7 = v171, !(unsigned int)sub_11710((FILE *)size[1], (__int64)v171, HIDWORD(size[0]), &v271))
        || HIDWORD(size[0]) != v271
        || (v7 = "wvpk", strncmp(v171, "wvpk", 4uLL))
        || (WavpackUpdateNumSamples(v10, v171), v7 = 0LL, sub_11870((FILE *)size[1], 0LL))
        || (v7 = v171, !(unsigned int)sub_11780((FILE *)size[1], (__int64)v171, HIDWORD(size[0]), &v271))
        || HIDWORD(size[0]) != v271 )
      {
        sub_11570((__int64)"couldn't update WavPack header with actual length!!", v7);
        v172 = v171;
        v26 = 1;
        free(v172);
        goto LABEL_308;
      }
      free(v171);
      v206 = (FILE *)v278[1];
      if ( v278[1] )
      {
        v207 = (char *)malloc(HIDWORD(v278[0]));
        if ( v207 )
        {
          v7 = 0LL;
          if ( sub_11870(v206, 0LL)
            || (v7 = v207, !(unsigned int)sub_11710((FILE *)v278[1], (__int64)v207, HIDWORD(v278[0]), &v271))
            || HIDWORD(v278[0]) != v271
            || (v7 = "wvpk", strncmp(v207, "wvpk", 4uLL))
            || (WavpackUpdateNumSamples(v10, v207), v7 = 0LL, (v26 = sub_11870((FILE *)v278[1], 0LL)) != 0)
            || (v7 = v207, !(unsigned int)sub_11780((FILE *)v278[1], (__int64)v207, HIDWORD(v278[0]), &v271))
            || HIDWORD(v278[0]) != v271 )
          {
            v26 = 1;
            sub_11570((__int64)"couldn't update WavPack header with actual length!!", v7);
          }
          free(v207);
          if ( (unsigned int)sub_118A0((FILE *)size[1]) )
            goto LABEL_310;
        }
        else
        {
          sub_11570((__int64)"couldn't update WavPack header with actual length!!");
          if ( (unsigned int)sub_118A0((FILE *)size[1]) )
          {
            if ( newa )
            {
              if ( (unsigned int)sub_118A0((FILE *)v278[1]) )
              {
                v26 = 1;
                goto LABEL_424;
              }
              v26 = 1;
              sub_11570((__int64)"can't close correction file!");
              goto LABEL_461;
            }
            if ( !v245 )
              goto LABEL_466;
            goto LABEL_579;
          }
        }
LABEL_526:
        sub_11570((__int64)"can't close WavPack file!", v7);
        if ( newa )
        {
          if ( (unsigned int)sub_118A0((FILE *)v278[1]) )
          {
            if ( v245 )
            {
              v26 = v245;
              goto LABEL_425;
            }
            v26 = 1;
            sub_11910(src);
            goto LABEL_463;
          }
          goto LABEL_512;
        }
        if ( !v245 )
        {
          v26 = 1;
          sub_11910(src);
          goto LABEL_464;
        }
LABEL_579:
        sub_11910(old);
        v26 = v245;
        goto LABEL_464;
      }
    }
    if ( !(unsigned int)sub_118A0((FILE *)size[1]) )
      goto LABEL_526;
    if ( newa && !(unsigned int)sub_118A0((FILE *)v278[1]) )
    {
LABEL_512:
      sub_11570((__int64)"can't close correction file!");
LABEL_433:
      v7 = (char *)v245;
      if ( v245 )
      {
        v26 = v245;
LABEL_462:
        sub_11910(old);
        newa = dest;
        goto LABEL_463;
      }
LABEL_466:
      v26 = 1;
      goto LABEL_467;
    }
LABEL_313:
    if ( dword_2190BC )
    {
      v179 = WavpackLossyBlocks(v10, v7);
      v7 = &v287;
      if ( v179 )
        v7 = 0LL;
      if ( !v245 )
      {
        v26 = sub_8B10((__int64)src, v7);
        if ( v26 )
          goto LABEL_467;
LABEL_315:
        if ( dword_2190C4 )
        {
          v190 = src;
          if ( !(unsigned int)sub_11150(filename, src)
            || newa && (v190 = newa, !(unsigned int)sub_11150(filename, newa)) )
          {
            sub_11570((__int64)"failure copying time stamp!", v190);
          }
        }
        if ( !dword_2190B8 )
          goto LABEL_317;
        v188 = sub_11910(filename);
        if ( dword_2190C0 )
        {
          if ( v188 )
            goto LABEL_317;
          v189 = "can't delete";
        }
        else
        {
          v189 = "can't delete";
          if ( v188 )
            v189 = "deleted";
        }
        sub_11570((__int64)"%s source file %s", v189, filename);
LABEL_317:
        v138 = (unsigned __int64)&tz;
        gettimeofday(&v275, &tz);
        v139 = tv.tv_sec;
        v140 = tv.tv_usec;
        newb = v275.tv_sec;
        v246 = v275.tv_usec;
        if ( v281[6] < 0 )
        {
          v138 = 0LL;
          if ( WavpackGetEncodedNoise(v10, 0LL) > 0.0 )
          {
            v228 = WavpackGetBitsPerSample(v10);
            v229 = v228 - 1;
            v230 = 0.5;
            if ( v228 )
            {
              do
              {
                --v229;
                v230 = v230 + v230;
              }
              while ( v229 != -1 );
            }
            v138 = (unsigned __int64)&v272;
            v231 = v230 * (v230 - 1.0) * 0.5;
            v232 = WavpackGetEncodedNoise(v10, &v272);
            v233 = log10(v272 / v231);
            v235 = WavpackGetNumSamples64(v10, &v272, v234);
            v236 = log10(v232 / (double)v235 / v231);
            sub_11570((__int64)"ave noise = %.2f dB, peak noise = %.2f dB", v236 * 10.0, 10.0 * v233);
          }
        }
        if ( !dword_2190C0 )
        {
          v288 = 0LL;
          if ( v66 )
          {
            v138 = v66;
            sub_11570((__int64)"successfully imported %d items from ID3v2 tag", v66);
          }
          if ( v281[7] & 8 )
          {
            v292 = 3472328296227680304LL;
            v141 = &v287;
            v293 = 0;
            *(__m128i *)s1 = _mm_load_si128((const __m128i *)&xmmword_15D80);
            v142 = v290[8];
            v290 = _mm_load_si128((const __m128i *)&xmmword_15D90);
            v143 = _mm_load_si128((const __m128i *)&xmmword_15D70);
            v291 = v143;
            do
            {
              v144 = v142;
              v138 = 1LL;
              ++v141;
              v142 += 2;
              __sprintf_chk(v144, 1LL, -1LL, "%02x", *(double *)v143[0]);
            }
            while ( v142 != &v293 );
            sub_11570((__int64)s1, 1LL);
          }
          if ( *src == 45 )
          {
            if ( *filename == 45 )
            {
              v146 = "packed";
              v145 = "";
              src = "stdin";
            }
            else if ( strlen(filename) > 0x1E )
            {
              v146 = "packed";
              v145 = "";
              src = (char *)sub_113E0(filename);
            }
            else
            {
              v146 = "packed";
              v145 = "";
              src = filename;
            }
          }
          else
          {
            if ( strlen(src) > 0x1E )
              src = (char *)sub_113E0(src);
            v145 = "";
            v146 = "created";
            if ( LODWORD(v278[0]) )
              v145 = " (+.wvc)";
            if ( dword_2190BC )
              v146 = "created (and verified)";
          }
          if ( (unsigned int)WavpackLossyBlocks(v10, v138) )
          {
            v161 = WavpackGetAverageBitrate(v10, 1LL);
            v162 = "lossy";
            if ( v161 != 0.0 )
            {
              v237 = WavpackGetAverageBitrate(v10, 1LL);
              __sprintf_chk(&v288, 1LL, 16LL, ", %d kbps", v237 / 1000.0);
              v162 = "lossy";
            }
          }
          else
          {
            v204 = WavpackGetRatio(v10);
            v162 = "lossless";
            if ( v204 != 0.0 )
            {
              v205 = WavpackGetRatio(v10);
              __sprintf_chk(&v288, 1LL, 16LL, ", %.2f%%", 100.0 - v205 * 100.0);
              v162 = "lossless";
            }
          }
          v138 = (unsigned __int64)v146;
          sub_11570(
            (__int64)"%s %s%s in %.2f secs (%s%s)",
            v146,
            src,
            v145,
            v162,
            &v288,
            (double)v246 / 1000000.0 + (double)newb - ((double)v140 / 1000000.0 + (double)v139));
        }
        v26 = 0;
        WavpackCloseFile(v10, v138);
        return v26;
      }
      v26 = sub_8B10((__int64)old, v7);
      if ( v26 )
        goto LABEL_425;
    }
    else if ( !v245 )
    {
      goto LABEL_315;
    }
    if ( rename(old, src) )
    {
      v181 = old;
      v7 = old;
      sub_11570((__int64)"can not rename temp file %s to %s!", old, src);
      if ( !newa )
      {
LABEL_602:
        free(v181);
        goto LABEL_63;
      }
      v7 = newa;
      if ( !rename(dest, newa) )
      {
        free(old);
        free(dest);
        goto LABEL_63;
      }
    }
    else
    {
      if ( !newa )
      {
        free(old);
        goto LABEL_315;
      }
      if ( !rename(dest, newa) )
      {
        free(old);
        free(dest);
        goto LABEL_315;
      }
    }
    v181 = dest;
    v7 = dest;
    sub_11570((__int64)"can not rename temp file %s to %s!", dest, newa);
    free(old);
    goto LABEL_602;
  }
  if ( v266 != 1 )
  {
    v191 = WavpackGetNumSamples64(v10, v7, v64);
    v192 = (signed int)WavpackGetNumChannels(v10) * v191;
    v193 = v192 * (signed int)WavpackGetBytesPerSample(v10) % v266;
    if ( v193 )
    {
      v194 = v266 - v193;
      while ( --v194 != -1 )
      {
        while ( !(unsigned int)sub_11710(stream, (__int64)&v275, 1u, &v271) || v271 != 1 )
        {
          --v194;
          sub_11570((__int64)"warning: input file missing required padding byte!", &v275);
          if ( v194 == -1 )
            goto LABEL_153;
        }
        if ( LOBYTE(v275.tv_sec) )
          sub_11570((__int64)"warning: input file has non-zero padding byte!", &v275);
      }
    }
  }
LABEL_153:
  v67 = 0;
  v68 = 0x10000;
  v69 = (char *)malloc(0x10000uLL);
  while ( 1 )
  {
    v7 = &v69[v67];
    if ( !(unsigned int)sub_11710(stream, (__int64)v7, v68 - v67, &v271) || !v271 )
      break;
    v67 += v271;
    if ( v68 == v67 )
    {
      v68 += 0x10000;
      v69 = (char *)realloc(v69, v68);
    }
  }
  if ( !v67 )
    goto LABEL_611;
  if ( !(v281[1] & 2) )
  {
    v7 = v69;
    if ( !(unsigned int)WavpackAddWrapper(v10, v69, (unsigned int)v67) )
    {
      v66 = 0;
      v26 = 2;
      v7 = (char *)WavpackGetErrorMessage(v10);
      sub_11570((__int64)"%s", v7);
      free(v69);
      sub_118A0(stream);
      goto LABEL_308;
    }
  }
  if ( !dword_2190A0 || v67 <= 10 )
  {
LABEL_611:
    free(v69);
    sub_118A0(stream);
    goto LABEL_380;
  }
  v7 = v69;
  v180 = sub_12820(0LL, (unsigned __int64)v69, v67, (__int64)s1, &v275);
  if ( !dword_2190AC && SLODWORD(v275.tv_sec) > 0x100000 )
  {
    v66 = 0;
    v26 = 1;
    sub_11570((__int64)"imported tag items exceed 1 MB, use --allow-huge-tags to override", v69);
    free(v69);
    sub_118A0(stream);
    goto LABEL_308;
  }
  if ( SLODWORD(v275.tv_sec) > 0x1000000 )
  {
    sub_11570((__int64)"imported tag items exceed 16 MB", v69);
  }
  else
  {
    if ( v180 > 0 )
    {
      v7 = v69;
      v180 = sub_12820(v10, (unsigned __int64)v69, v67, (__int64)s1, 0LL);
    }
    if ( v180 >= 0 )
    {
      if ( v180 )
      {
        free(v69);
        v66 = v180;
      }
      else
      {
        free(v69);
      }
      sub_118A0(stream);
      goto LABEL_380;
    }
    v7 = s1;
    sub_11570((__int64)"ID3v2 import: %s", s1);
  }
  v26 = 1;
  free(v69);
  sub_118A0(stream);
LABEL_308:
  if ( !(unsigned int)sub_118A0((FILE *)size[1]) )
    sub_11570((__int64)"can't close WavPack file!", v7);
LABEL_310:
  if ( newa && !(unsigned int)sub_118A0((FILE *)v278[1]) )
  {
    sub_11570((__int64)"can't close correction file!", v7);
    if ( !v26 )
      goto LABEL_433;
LABEL_461:
    if ( !v245 )
    {
      sub_11910(src);
      goto LABEL_463;
    }
    goto LABEL_462;
  }
  if ( !v26 )
    goto LABEL_313;
LABEL_424:
  if ( !v245 )
  {
LABEL_467:
    sub_11910(src);
    if ( !newa )
      goto LABEL_464;
LABEL_463:
    sub_11910(newa);
    goto LABEL_464;
  }
LABEL_425:
  sub_11910(old);
  if ( newa )
    sub_11910(dest);
LABEL_464:
  WavpackCloseFile(v10, v7);
  return v26;
}
// 3000: using guessed type __int64  WavpackAppendTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 3090: using guessed type __int64  __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 3170: using guessed type __int64  WavpackWriteTag(_QWORD);
// 3180: using guessed type __int64  WavpackGetBitsPerSample(_QWORD);
// 31A0: using guessed type double  WavpackGetEncodedNoise(_QWORD, _QWORD);
// 31B0: using guessed type __int64  WavpackSetFileInformation(_QWORD, _QWORD, _QWORD);
// 31E0: using guessed type __int64  WavpackAppendBinaryTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 3250: using guessed type __int64  WavpackUpdateNumSamples(_QWORD, _QWORD);
// 3260: using guessed type __int64  WavpackGetChannelLayout(_QWORD, _QWORD);
// 3290: using guessed type __int64  WavpackGetBytesPerSample(_QWORD);
// 32A0: using guessed type __int64  MD5_Final(_QWORD, _QWORD);
// 32B0: using guessed type __int64  MD5_Update(_QWORD, _QWORD, _QWORD);
// 32C0: using guessed type double  WavpackGetProgress(_QWORD);
// 3300: using guessed type double  WavpackGetAverageBitrate(_QWORD, _QWORD);
// 3350: using guessed type __int64  WavpackPackInit(_QWORD, _QWORD);
// 3370: using guessed type __int64  WavpackFlushSamples(_QWORD, _QWORD);
// 33B0: using guessed type __int64  WavpackGetFloatNormExp(_QWORD);
// 33F0: using guessed type __int64  WavpackGetNumSamples64(_QWORD, _QWORD, _QWORD);
// 3410: using guessed type __int64  WavpackPackSamples(_QWORD, _QWORD, _QWORD);
// 34A0: using guessed type double  WavpackGetRatio(_QWORD);
// 3540: using guessed type __int64  MD5_Init(_QWORD);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3570: using guessed type __int64  WavpackLossyBlocks(_QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 3600: using guessed type __int64  WavpackGetNumChannels(_QWORD);
// 3620: using guessed type __int64  WavpackOpenFileOutput(_QWORD, _QWORD, _QWORD);
// 3650: using guessed type __int64  __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, double);
// 36B0: using guessed type __int64  WavpackCloseFile(_QWORD, _QWORD);
// 36F0: using guessed type __int64  WavpackStoreMD5Sum(_QWORD, _QWORD);
// 3700: using guessed type __int64  WavpackGetMode(_QWORD);
// 3720: using guessed type __int64  WavpackGetSampleIndex64(_QWORD);
// 15D70: using guessed type __int128 xmmword_15D70;
// 15D80: using guessed type __int128 xmmword_15D80;
// 15D90: using guessed type __int128 xmmword_15D90;
// 219048: using guessed type __int64 stdout;
// 219068: using guessed type int dword_219068;
// 21906C: using guessed type int dword_21906C;
// 219070: using guessed type __int64 qword_219070;
// 219094: using guessed type int dword_219094;
// 219098: using guessed type int dword_219098;
// 21909C: using guessed type int dword_21909C;
// 2190A0: using guessed type int dword_2190A0;
// 2190A4: using guessed type int dword_2190A4;
// 2190A8: using guessed type int dword_2190A8;
// 2190AC: using guessed type int dword_2190AC;
// 2190B0: using guessed type int dword_2190B0;
// 2190B8: using guessed type int dword_2190B8;
// 2190BC: using guessed type int dword_2190BC;
// 2190C0: using guessed type int dword_2190C0;
// 2190C4: using guessed type int dword_2190C4;
// 2190D0: using guessed type int dword_2190D0;

//----- (000000000000C560) ----------------------------------------------------
FILE * sub_C560(const char *a1)
{
  void *v1; // r12
  unsigned __int64 v2; // rbx
  signed __int64 v3; // rbp
  const void *v4; // r15
  size_t v5; // rbp
  FILE *v6; // rbx
  unsigned __int64 v8; // [rsp+0h] [rbp-128h]
  __int64 v9; // [rsp+8h] [rbp-120h]
  struct stat stat_buf; // [rsp+50h] [rbp-D8h]
  unsigned __int64 v11; // [rsp+E8h] [rbp-40h]

  v11 = __readfsqword(0x28u);
  glob(a1, 0, 0LL, (glob_t *)&v8);
  if ( v8 )
  {
    v1 = 0LL;
    v2 = 0LL;
    do
    {
      v3 = 8 * v2;
      if ( __xstat(1, *(const char **)(v9 + 8 * v2), &stat_buf) != -1 && (stat_buf.st_mode & 0xF000) != 0x4000 )
      {
        if ( v1 )
        {
          v6 = 0LL;
          free(v1);
          globfree((glob_t *)&v8);
          return v6;
        }
        v4 = *(const void **)(v9 + v3);
        v5 = strlen(*(const char **)(v9 + v3));
        v1 = malloc(v5 + 10);
        memcpy(v1, v4, v5 + 1);
      }
      ++v2;
    }
    while ( v2 < v8 );
    globfree((glob_t *)&v8);
    if ( v1 )
    {
      v6 = fopen((const char *)v1, "rb");
      free(v1);
    }
    else
    {
      v6 = 0LL;
    }
  }
  else
  {
    v6 = 0LL;
    globfree((glob_t *)&v8);
  }
  return v6;
}

//----- (000000000000C6B0) ----------------------------------------------------
__int64  sub_C6B0(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5)
{
  int *v5; // r13
  FILE *v6; // rbp
  const char *v7; // rdi
  __int64 v8; // r12
  int *v9; // rsi
  signed __int64 v10; // rcx
  bool v11; // cf
  bool v12; // zf
  int v13; // ebx
  __int64 v14; // r14
  bool v15; // cf
  bool v16; // zf
  unsigned int v17; // er15
  __int64 *v19; // rsi
  const char *v20; // rdi
  signed __int64 v21; // rcx
  bool v22; // cf
  bool v23; // zf
  const char *v24; // rdi
  signed __int64 v25; // rcx
  char *v26; // rsi
  char v27; // al
  bool v28; // cf
  bool v29; // zf
  unsigned int v30; // ecx
  __int64 v31; // rax
  const char *v32; // rdi
  signed __int64 v33; // rcx
  char *v34; // rsi
  char v35; // al
  bool v36; // cf
  bool v37; // zf
  unsigned int v38; // er8
  int v39; // edi
  __int64 v40; // rsi
  unsigned __int16 v41; // ax
  int v42; // er10
  const char *v43; // rdi
  signed __int64 v44; // rcx
  char *v45; // rsi
  unsigned int v46; // ebx
  void *v47; // r15
  __int64 v48; // rax
  void *v49; // rdi
  int v50; // edx
  int v51; // eax
  int v52; // ecx
  __int64 v53; // rax
  int v54; // edx
  signed __int64 v55; // rax
  __int64 v56; // rdx
  __int128 v57; // tt
  signed __int64 v58; // rsi
  unsigned __int16 v59; // ax
  __int64 v60; // rax
  __int64 v61; // rax
  __int64 v62; // [rsp+0h] [rbp-E8h]
  __int64 v63; // [rsp+8h] [rbp-E0h]
  signed int v64; // [rsp+18h] [rbp-D0h]
  signed int v65; // [rsp+1Ch] [rbp-CCh]
  unsigned int v66; // [rsp+20h] [rbp-C8h]
  int v67; // [rsp+24h] [rbp-C4h]
  unsigned int v68; // [rsp+3Ch] [rbp-ACh]
  __int128 v69; // [rsp+40h] [rbp-A8h]
  __int64 v70; // [rsp+50h] [rbp-98h]
  unsigned int v71; // [rsp+58h] [rbp-90h]
  char v72; // [rsp+60h] [rbp-88h]
  char v73; // [rsp+61h] [rbp-87h]
  char v74; // [rsp+62h] [rbp-86h]
  char v75; // [rsp+63h] [rbp-85h]
  unsigned int v76; // [rsp+64h] [rbp-84h]
  int v77; // [rsp+68h] [rbp-80h]
  int v78; // [rsp+6Ch] [rbp-7Ch]
  __int64 v79; // [rsp+70h] [rbp-78h]
  __int128 v80; // [rsp+80h] [rbp-68h]
  __int128 v81; // [rsp+90h] [rbp-58h]
  __int64 v82; // [rsp+A0h] [rbp-48h]
  unsigned __int64 v83; // [rsp+A8h] [rbp-40h]

  v5 = a3;
  v6 = stream;
  v7 = "RF64";
  v8 = a5;
  v62 = a2;
  v63 = a4;
  v9 = a3;
  v10 = 4LL;
  v82 = 0LL;
  v70 = 0LL;
  v83 = __readfsqword(0x28u);
  v11 = 0;
  v12 = 1;
  do
  {
    if ( !v10 )
      break;
    v11 = *(_BYTE *)v9 < (const unsigned __int8)*v7;
    v12 = *(_BYTE *)v9 == *v7;
    v9 = (int *)((char *)v9 + 1);
    ++v7;
    --v10;
  }
  while ( v12 );
  v71 = 0;
  v13 = (char)((!v11 && !v12) - v11);
  v80 = 0LL;
  v81 = 0LL;
  v69 = 0LL;
  v14 = sub_117F0(v6);
  if ( v13 && v14 > 0xFFFFFFFFLL && !(*(_BYTE *)(v8 + 17) & 8) )
  {
    v17 = 1;
    sub_11570((__int64)"can't handle .WAV files larger than 4 GB (non-standard)!", v9, 0.0);
    return v17;
  }
  v77 = *v5;
  if ( !(unsigned int)sub_11710(v6, (__int64)&v78, 8u, &v68) )
    goto LABEL_9;
  v15 = v68 < 8;
  v16 = v68 == 8;
  if ( v68 != 8 )
    goto LABEL_9;
  v19 = &v79;
  v20 = "WAVE";
  v21 = 4LL;
  do
  {
    if ( !v21 )
      break;
    v15 = *(_BYTE *)v19 < (const unsigned __int8)*v20;
    v16 = *(_BYTE *)v19 == *v20;
    v19 = (__int64 *)((char *)v19 + 1);
    ++v20;
    --v21;
  }
  while ( v16 );
  v64 = (char)((!v15 && !v16) - v15);
  if ( (!v15 && !v16) != v15 )
  {
LABEL_9:
    v17 = 1;
    sub_11570((__int64)"%s is not a valid .WAV file!", v62, 0.0);
    return v17;
  }
  if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v63, &v77, 12LL) )
    goto LABEL_40;
  v65 = 0;
  v67 = v13;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( !(unsigned int)sub_11710(v6, (__int64)&v72, 8u, &v68) || v68 != 8 )
        goto LABEL_9;
      if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v63, &v72, 8LL) )
        goto LABEL_40;
      WavpackLittleEndianToNative(&v72, "4L", 0.0);
      v24 = "ds64";
      v25 = 4LL;
      v26 = &v72;
      do
      {
        if ( !v25 )
          break;
        v22 = (unsigned __int8)*v26 < *v24;
        v23 = *v26++ == *v24++;
        --v25;
      }
      while ( v23 );
      v27 = (!v22 && !v23) - v22;
      v28 = 0;
      v29 = v27 == 0;
      if ( !v27 )
        break;
      v32 = "fmt ";
      v33 = 4LL;
      v34 = &v72;
      do
      {
        if ( !v33 )
          break;
        v28 = (unsigned __int8)*v34 < *v32;
        v29 = *v34++ == *v32++;
        --v33;
      }
      while ( v29 );
      v35 = (!v28 && !v29) - v28;
      v36 = 0;
      v37 = v35 == 0;
      if ( v35 )
      {
        v43 = "data";
        v44 = 4LL;
        v45 = &v72;
        do
        {
          if ( !v44 )
            break;
          v36 = (unsigned __int8)*v45 < *v43;
          v37 = *v45++ == *v43++;
          --v44;
        }
        while ( v37 );
        v17 = (char)((!v36 && !v37) - v36);
        if ( (!v36 && !v37) == v36 )
        {
          v52 = WORD1(v80);
          if ( v65 )
          {
            if ( v76 == -1 )
            {
              v53 = *((_QWORD *)&v69 + 1);
              if ( !WORD1(v80) )
                goto LABEL_9;
LABEL_125:
              v54 = *(_DWORD *)(v8 + 16) & 0x800;
              if ( v14 )
              {
                if ( !v54 )
                {
                  if ( v14 - v53 > 0x1000000 )
                  {
                    v17 = 1;
                    sub_11570((__int64)"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!", v45);
                    return v17;
                  }
                  goto LABEL_128;
                }
                if ( j__ftell(v6) != -1 )
                {
                  v61 = j__ftell(v6);
                  v52 = WORD1(v80);
                  v58 = (v14 - v61) / WORD6(v80);
LABEL_132:
                  v59 = WORD6(v80);
                  *(_DWORD *)(v8 + 28) = v52;
                  *(_DWORD *)(v8 + 12) = (unsigned __int16)(v59 / (unsigned __int16)v52);
                  *(_DWORD *)(v8 + 44) = DWORD1(v80);
                  if ( !(unsigned int)WavpackSetConfiguration64(v63, v8, v58, 0LL) )
                  {
                    v17 = 1;
                    v60 = WavpackGetErrorMessage(v63);
                    sub_11570((__int64)"%s: %s", v62, v60);
                  }
                  return v17;
                }
                v52 = WORD1(v80);
              }
              else if ( !v54 )
              {
LABEL_128:
                v57 = v53;
                v55 = v53 / WORD6(v80);
                v56 = v57 % WORD6(v80);
                v58 = v55;
                if ( v65 && v70 != v55 )
                  goto LABEL_9;
                if ( !v55 )
                {
                  v17 = 1;
                  sub_11570((__int64)"this .WAV file has no audio samples, probably is corrupt!", 0LL, v56);
                  return v17;
                }
                if ( v55 > 1099511627519LL )
                {
                  v17 = 1;
                  sub_11570((__int64)"%s has too many samples for WavPack!", v62);
                  return v17;
                }
                goto LABEL_132;
              }
              v58 = -1LL;
              goto LABEL_132;
            }
            if ( !WORD1(v80) )
              goto LABEL_9;
          }
          else if ( !WORD1(v80) || !v67 )
          {
            goto LABEL_9;
          }
          v53 = v76;
          goto LABEL_125;
        }
        v66 = v76;
        v46 = (v76 + 1) & 0xFFFFFFFE;
        if ( v46 > 0x400000 )
          goto LABEL_9;
        v47 = malloc((signed int)v46);
        if ( dword_2190D8 )
          sub_11570(
            (__int64)"extra unknown chunk \"%c%c%c%c\" of %d bytes",
            (unsigned int)v72,
            (unsigned int)v73,
            (unsigned int)v74,
            (unsigned int)v75,
            v66,
            v62);
        if ( !(unsigned int)sub_11710(v6, (__int64)v47, v46, &v68)
          || v46 != v68
          || !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v63, v47, v46) )
        {
          v48 = WavpackGetErrorMessage(v63);
          sub_11570((__int64)"%s", v48);
          v49 = v47;
          v17 = 1;
          free(v49);
          return v17;
        }
        free(v47);
      }
      else
      {
        if ( v64 || v76 - 16 > 0x18 || !(unsigned int)sub_11710(v6, (__int64)&v80, v76, &v68) || v76 != v68 )
          goto LABEL_9;
        if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v63, &v80, v76) )
          goto LABEL_40;
        WavpackLittleEndianToNative(&v80, "SSLLSSSSLS", 0.0);
        if ( !dword_2190D8 )
          goto LABEL_53;
        sub_11570((__int64)"format tag size = %d", v76);
        sub_11570(
          (__int64)"FormatTag = %x, NumChannels = %d, BitsPerSample = %d",
          (unsigned __int16)v80,
          WORD1(v80),
          HIWORD(v80));
        sub_11570(
          (__int64)"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d",
          WORD6(v80),
          DWORD1(v80),
          DWORD2(v80));
        v38 = v76;
        if ( v76 <= 0x10 )
          goto LABEL_57;
        sub_11570((__int64)"cbSize = %d, ValidBitsPerSample = %d", (unsigned __int16)v81, WORD1(v81));
        v38 = v76;
        if ( v76 > 0x14 )
        {
          sub_11570((__int64)"ChannelMask = %x, SubFormat = %d", DWORD1(v81), WORD4(v81));
LABEL_53:
          v38 = v76;
        }
        if ( v38 > 0x10 && (_WORD)v81 == 2 )
          *(_DWORD *)(v8 + 16) |= 0x100u;
LABEL_57:
        v39 = (unsigned __int16)v80;
        if ( (_WORD)v80 == -2 && v38 == 40 )
        {
          v39 = WORD4(v81);
LABEL_88:
          v40 = WORD1(v81);
          if ( WORD1(v81) )
            goto LABEL_61;
          goto LABEL_60;
        }
        if ( v38 == 40 )
          goto LABEL_88;
LABEL_60:
        v40 = HIWORD(v80);
LABEL_61:
        *(_DWORD *)(v8 + 8) = v40;
        if ( (v39 & 0xFFFFFFFD) == 1 )
          LOBYTE(v64) = (_DWORD)v40 == 32 || v39 != 3;
        if ( (unsigned __int16)(WORD1(v80) - 1) > 0xFFu
          || (v41 = WORD6(v80) / WORD1(v80),
              v42 = (unsigned __int16)(WORD6(v80) / WORD1(v80)),
              v42 < ((signed int)v40 + 7) >> 3)
          || v41 > 4u
          || WORD6(v80) % WORD1(v80)
          || (unsigned int)(v40 - 1) > 0x1F
          || !(v64 & 1) )
        {
          v17 = 1;
          sub_11570((__int64)"%s is an unsupported .WAV format!", v62);
          return v17;
        }
        if ( v38 > 0x27 )
        {
          if ( DWORD1(v81) )
          {
            if ( *(_DWORD *)(v8 + 48) || *(_BYTE *)(v8 + 17) & 4 )
            {
              v17 = 1;
              sub_11570((__int64)"this WAV file already has channel order information!");
              return v17;
            }
            *(_DWORD *)(v8 + 48) = DWORD1(v81);
          }
        }
        else if ( !*(_DWORD *)(v8 + 48) && !(*(_BYTE *)(v8 + 17) & 4) )
        {
          if ( WORD1(v80) > 2u )
          {
            if ( WORD1(v80) > 0x12u )
              *(_DWORD *)(v8 + 48) = 0x3FFFF;
            else
              *(_DWORD *)(v8 + 48) = (1 << SBYTE2(v80)) - 1;
          }
          else
          {
            *(_DWORD *)(v8 + 48) = 5 - WORD1(v80);
          }
        }
        v50 = dword_2190D8;
        if ( v39 == 3 )
        {
          *(_DWORD *)(v8 + 32) = 127;
          v64 = 1;
          if ( v50 )
          {
LABEL_109:
            sub_11570((__int64)"data format: normalized 32-bit floating point");
            v64 = 1;
          }
        }
        else
        {
          if ( !(*(_BYTE *)(v8 + 17) & 1) || v41 != 4 )
            goto LABEL_100;
          if ( HIWORD(v80) == 24 )
          {
            *(_DWORD *)(v8 + 32) = 150;
            goto LABEL_115;
          }
          if ( HIWORD(v80) == 32 )
          {
            *(_DWORD *)(v8 + 32) = 142;
LABEL_115:
            if ( v50 )
            {
              v51 = *(_DWORD *)(v8 + 32);
LABEL_111:
              sub_11570(
                (__int64)"data format: 32-bit floating point (Audition %d:%d float type 1)",
                (unsigned int)(v51 - 126),
                (unsigned int)(150 - v51));
              v64 = 1;
            }
            else
            {
              v64 = 1;
            }
          }
          else
          {
LABEL_100:
            v64 = 1;
            if ( dword_2190D8 )
            {
              v51 = *(_DWORD *)(v8 + 32);
              if ( v51 == 127 )
                goto LABEL_109;
              if ( v51 )
                goto LABEL_111;
              sub_11570((__int64)"data format: %d-bit integers stored in %d byte(s)", v40, (unsigned int)v42);
            }
          }
        }
      }
    }
    if ( v76 <= 0x1B || !(unsigned int)sub_11710(v6, (__int64)&v69, 0x1Cu, &v68) || v68 != 28 )
      goto LABEL_9;
    if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v63, &v69, 28LL) )
      goto LABEL_40;
    WavpackLittleEndianToNative(&v69, "DDDL", 0.0);
    if ( dword_2190D8 )
      sub_11570((__int64)"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d", v69, v70, v71);
    v30 = v71;
    if ( 12LL * v71 != v76 - 28LL )
      goto LABEL_9;
    --v71;
    if ( v30 )
      break;
LABEL_86:
    v65 = 1;
  }
  while ( (unsigned int)sub_11710(v6, (__int64)&v79 + 4, 0xCu, &v68)
       && v68 == 12
       && (*(_BYTE *)(v8 + 17) & 2 || (unsigned int)WavpackAddWrapper(v63, (char *)&v79 + 4, 12LL)) )
  {
    v12 = v71-- == 0;
    if ( v12 )
      goto LABEL_86;
  }
LABEL_40:
  v17 = 1;
  v31 = WavpackGetErrorMessage(v63);
  sub_11570((__int64)"%s", v31, 0.0);
  return v17;
}
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 34C0: using guessed type __int64  WavpackLittleEndianToNative(_QWORD, _QWORD, double);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 2190D8: using guessed type int dword_2190D8;

//----- (000000000000D130) ----------------------------------------------------
signed __int64  sub_D130(FILE *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  signed int v4; // er13
  int v5; // ebx
  int v6; // er14
  int v7; // eax
  signed __int16 v8; // r10
  signed int v9; // er15
  signed __int64 v10; // rdx
  unsigned int v11; // er13
  signed __int64 v12; // rcx
  unsigned __int64 v13; // rax
  signed __int64 v14; // r14
  signed __int64 v15; // ST08_8
  int *v16; // rsi
  signed __int64 result; // rax
  int v18; // eax
  signed __int16 v19; // ST2C_2
  signed __int16 v20; // ST2C_2
  __int16 v21; // [rsp+8h] [rbp-110h]
  int v22; // [rsp+14h] [rbp-104h]
  signed int v23; // [rsp+28h] [rbp-F0h]
  int v24; // [rsp+3Ch] [rbp-DCh]
  __int64 v25; // [rsp+40h] [rbp-D8h]
  __int64 v26; // [rsp+48h] [rbp-D0h]
  __int64 v27; // [rsp+50h] [rbp-C8h]
  int v28; // [rsp+58h] [rbp-C0h]
  int v29; // [rsp+5Ch] [rbp-BCh]
  int v30; // [rsp+60h] [rbp-B8h]
  int v31; // [rsp+64h] [rbp-B4h]
  int v32; // [rsp+68h] [rbp-B0h]
  int v33; // [rsp+6Ch] [rbp-ACh]
  unsigned int v34; // [rsp+70h] [rbp-A8h]
  int v35; // [rsp+74h] [rbp-A4h]
  int v36; // [rsp+78h] [rbp-A0h]
  int v37; // [rsp+7Ch] [rbp-9Ch]
  int v38; // [rsp+80h] [rbp-98h]
  int v39; // [rsp+84h] [rbp-94h]
  __int128 v40; // [rsp+88h] [rbp-90h]
  __int64 v41; // [rsp+98h] [rbp-80h]
  int v42; // [rsp+A0h] [rbp-78h]
  __int16 v43; // [rsp+B0h] [rbp-68h]
  __int16 v44; // [rsp+B2h] [rbp-66h]
  int v45; // [rsp+B4h] [rbp-64h]
  int v46; // [rsp+B8h] [rbp-60h]
  __int16 v47; // [rsp+BCh] [rbp-5Ch]
  __int16 v48; // [rsp+BEh] [rbp-5Ah]
  __int128 v49; // [rsp+C0h] [rbp-58h]
  __int64 v50; // [rsp+D0h] [rbp-48h]
  unsigned __int64 v51; // [rsp+D8h] [rbp-40h]

  v3 = a3;
  v51 = __readfsqword(0x28u);
  v4 = WavpackGetNumChannels(a2);
  v22 = WavpackGetChannelMask(a2);
  v5 = WavpackGetSampleRate(a2);
  v6 = WavpackGetBytesPerSample(a2);
  v21 = WavpackGetBitsPerSample(a2);
  v7 = WavpackGetFloatNormExp(a2);
  v8 = 1;
  if ( v7 )
  {
    v18 = WavpackGetFloatNormExp(a2);
    v8 = 3;
    if ( v18 != 127 )
    {
      sub_11570((__int64)"can't create valid RIFF wav header for non-normalized floating data!");
      return 0LL;
    }
  }
  if ( v3 == -1 )
    v3 = 2147479552 / (v6 * v4);
  v9 = dword_2190D8;
  v10 = v4 * v3 * v6;
  if ( v10 > 4278190080LL )
  {
    if ( dword_2190D8 )
    {
      v20 = v8;
      v9 = 1;
      sub_11570((__int64)"total_data_bytes = %lld, so rf64", v4 * v3 * v6);
      v23 = 0;
      v10 = v4 * v3 * v6;
      v8 = v20;
    }
    else
    {
      v23 = 0;
      v9 = 1;
    }
  }
  else
  {
    v23 = 1;
    if ( dword_2190D8 )
    {
      v19 = v8;
      v9 = 0;
      sub_11570((__int64)"total_data_bytes = %lld, so riff", v4 * v3 * v6);
      v10 = v4 * v3 * v6;
      v8 = v19;
    }
  }
  v45 = v5;
  v43 = v8;
  v44 = v4;
  v47 = v4 * v6;
  v49 = 0LL;
  v50 = 0LL;
  v46 = v6 * v4 * v5;
  v48 = v21;
  if ( v4 <= 2 && 5 - v4 == v22 )
  {
    v11 = 16;
    v12 = 16LL;
  }
  else
  {
    LOWORD(v49) = 22;
    WORD4(v49) = v8;
    v48 = 8 * v6;
    v43 = -2;
    BYTE14(v49) = 16;
    LOBYTE(v50) = -128;
    v11 = 40;
    WORD1(v49) = v21;
    v12 = 40LL;
    BYTE3(v50) = -86;
    *(_WORD *)((char *)&v50 + 5) = -25800;
    HIBYTE(v50) = 113;
    v49 = v22;
  }
  v13 = (v10 + 1) & 0xFFFFFFFFFFFFFFFELL;
  if ( v9 )
  {
    v14 = v13 + v12 + 56;
    v35 = 875972178;
    v37 = 1163280727;
  }
  else
  {
    v35 = 1179011410;
    v37 = 1163280727;
    v14 = v13 + v12 + 20;
  }
  if ( v23 )
  {
    v15 = v10;
    v14 += 36LL;
    v33 = 544501094;
    v31 = 1635017060;
    v34 = v11;
    v40 = 0LL;
    v41 = 0LL;
    v42 = 0;
    v38 = 1802401130;
    v39 = 28;
    WavpackNativeToLittleEndian(&v38, "4L");
    v10 = v15;
    if ( !v9 )
    {
LABEL_14:
      v36 = v14;
      v32 = v10;
      goto LABEL_15;
    }
  }
  else
  {
    v33 = 544501094;
    v31 = 1635017060;
    v34 = v11;
    if ( !v9 )
      goto LABEL_14;
  }
  v29 = 875983716;
  v30 = 28;
  v28 = 0;
  v25 = v14;
  v26 = v10;
  v27 = v3;
  v36 = -1;
  v32 = -1;
  WavpackNativeToLittleEndian(&v29, "4L");
  WavpackNativeToLittleEndian(&v25, "DDDL");
LABEL_15:
  WavpackNativeToLittleEndian(&v35, "4L");
  WavpackNativeToLittleEndian(&v33, "4L");
  WavpackNativeToLittleEndian(&v43, "SSLLSSSSLS");
  WavpackNativeToLittleEndian(&v31, "4L");
  v16 = &v35;
  if ( !(unsigned int)sub_11780(a1, (__int64)&v35, 0xCu, &v24)
    || v24 != 12
    || v9
    && ((v16 = &v29, !(unsigned int)sub_11780(a1, (__int64)&v29, 8u, &v24))
     || v24 != 8
     || (v16 = (int *)&v25, !(unsigned int)sub_11780(a1, (__int64)&v25, 0x1Cu, &v24))
     || v24 != 28)
    || v23 && ((v16 = &v38, !(unsigned int)sub_11780(a1, (__int64)&v38, 0x24u, &v24)) || v24 != 36)
    || (v16 = &v33, !(unsigned int)sub_11780(a1, (__int64)&v33, 8u, &v24))
    || v24 != 8
    || (v16 = (int *)&v43, !(unsigned int)sub_11780(a1, (__int64)&v43, v11, &v24))
    || v24 != v11
    || (v16 = &v31, !(unsigned int)sub_11780(a1, (__int64)&v31, 8u, &v24))
    || (result = 1LL, v24 != 8) )
  {
    sub_11570((__int64)"can't write .WAV data, disk probably full!", v16);
    result = 0LL;
  }
  return result;
}
// 3180: using guessed type __int64  WavpackGetBitsPerSample(_QWORD);
// 3290: using guessed type __int64  WavpackGetBytesPerSample(_QWORD);
// 33B0: using guessed type __int64  WavpackGetFloatNormExp(_QWORD);
// 3400: using guessed type __int64  WavpackGetChannelMask(_QWORD);
// 3480: using guessed type __int64  WavpackGetSampleRate(_QWORD);
// 34E0: using guessed type __int64  WavpackNativeToLittleEndian(_QWORD, _QWORD);
// 3600: using guessed type __int64  WavpackGetNumChannels(_QWORD);
// 2190D8: using guessed type int dword_2190D8;

//----- (000000000000D700) ----------------------------------------------------
__int64  sub_D700(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5, double a6)
{
  __int64 v6; // r15
  __int64 v7; // r13
  int *v8; // rbp
  FILE *v9; // rbx
  __int64 v10; // r12
  unsigned int v11; // ebp
  __int64 v13; // rax
  __int64 v14; // r13
  __int64 v15; // r9
  unsigned __int64 v16; // rdx
  signed __int64 v17; // r8
  int v18; // edi
  __int64 v19; // rsi
  unsigned __int16 v20; // ax
  int v21; // er10
  int v22; // edx
  unsigned int v23; // er15
  int v24; // ecx
  __int64 v25; // r15
  int v26; // eax
  signed __int64 v27; // rax
  signed __int64 v28; // rsi
  unsigned __int16 v29; // ax
  __int64 v30; // rax
  __int128 v31; // tt
  __int64 v32; // rax
  __int64 v33; // [rsp+0h] [rbp-F8h]
  void *ptr; // [rsp+8h] [rbp-F0h]
  _BOOL4 v35; // [rsp+14h] [rbp-E4h]
  __int64 v36; // [rsp+20h] [rbp-D8h]
  __int64 v37; // [rsp+28h] [rbp-D0h]
  unsigned int v38; // [rsp+3Ch] [rbp-BCh]
  __int128 v39; // [rsp+40h] [rbp-B8h]
  __int64 v40; // [rsp+50h] [rbp-A8h]
  int v41; // [rsp+60h] [rbp-98h]
  int v42; // [rsp+64h] [rbp-94h]
  unsigned __int64 v43; // [rsp+70h] [rbp-88h]
  __int128 v44; // [rsp+78h] [rbp-80h]
  unsigned __int16 v45; // [rsp+90h] [rbp-68h]
  unsigned __int16 v46; // [rsp+92h] [rbp-66h]
  unsigned int v47; // [rsp+94h] [rbp-64h]
  unsigned int v48; // [rsp+98h] [rbp-60h]
  unsigned __int16 v49; // [rsp+9Ch] [rbp-5Ch]
  unsigned __int16 v50; // [rsp+9Eh] [rbp-5Ah]
  unsigned __int16 v51; // [rsp+A0h] [rbp-58h]
  unsigned __int16 v52; // [rsp+A2h] [rbp-56h]
  unsigned int v53; // [rsp+A4h] [rbp-54h]
  unsigned __int16 v54; // [rsp+A8h] [rbp-50h]
  unsigned __int64 v55; // [rsp+B8h] [rbp-40h]

  v6 = a4;
  v7 = a2;
  v8 = a3;
  v9 = stream;
  v10 = a5;
  v55 = __readfsqword(0x28u);
  v33 = sub_117F0(stream);
  v41 = *v8;
  if ( !(unsigned int)sub_11710(stream, (__int64)&v42, 0x24u, &v38)
    || v38 != 36
    || xmmword_16430 != *(QWORD *)&v41
    || xmmword_16420 != v44 )
  {
    goto LABEL_3;
  }
  v35 = 0;
  if ( !(*(_BYTE *)(v10 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v6, &v41, 40LL) )
  {
LABEL_9:
    v11 = 1;
    v13 = WavpackGetErrorMessage(v6);
    sub_11570((__int64)"%s", v13);
    return v11;
  }
  WavpackLittleEndianToNative(&v41, "88D", a6);
  if ( !v33 || *(_BYTE *)(v10 + 17) & 8 )
    goto LABEL_11;
  if ( v43 < 0xFFFFFFFFFFFFFFFFLL && v43 != 0 && v43 != v33 )
  {
LABEL_3:
    v11 = 1;
    sub_11570((__int64)"%s is not a valid .W64 file!", v7);
    return v11;
  }
  v35 = 0;
LABEL_11:
  v37 = a2;
  v14 = v6;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( !(unsigned int)sub_11710(v9, (__int64)&v39, 0x18u, &v38) || v38 != 24 )
      {
LABEL_91:
        v7 = v37;
        goto LABEL_3;
      }
      if ( !(*(_BYTE *)(v10 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v14, &v39, 24LL) )
      {
LABEL_101:
        v6 = v14;
        goto LABEL_9;
      }
      WavpackLittleEndianToNative(&v39, "88D", a6);
      v15 = v40 - 24;
      v40 -= 24LL;
      if ( v39 != xmmword_16410 )
        break;
      if ( v35 )
        goto LABEL_91;
      v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      v40 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      if ( v16 - 16 > 0x18 || !(unsigned int)sub_11710(v9, (__int64)&v45, v16, &v38) || v38 != v40 )
        goto LABEL_91;
      if ( !(*(_BYTE *)(v10 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v14, &v45, v38) )
        goto LABEL_101;
      WavpackLittleEndianToNative(&v45, "SSLLSSSSLS", a6);
      if ( !dword_2190D8 )
        goto LABEL_24;
      sub_11570((__int64)"format tag size = %d", v40);
      sub_11570((__int64)"FormatTag = %x, NumChannels = %d, BitsPerSample = %d", v45, v46, v50);
      sub_11570((__int64)"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d", v49, v47, v48);
      v17 = v40;
      if ( v40 <= 16 )
        goto LABEL_28;
      sub_11570((__int64)"cbSize = %d, ValidBitsPerSample = %d", v51, v52);
      v17 = v40;
      if ( v40 > 20 )
      {
        sub_11570((__int64)"ChannelMask = %x, SubFormat = %d", v53, v54);
LABEL_24:
        v17 = v40;
      }
      if ( v17 > 16 && v51 == 2 )
        *(_DWORD *)(v10 + 16) |= 0x100u;
LABEL_28:
      v18 = v45;
      if ( v17 == 40 && v45 == -2 )
      {
        v18 = v54;
      }
      else if ( v17 != 40 )
      {
        goto LABEL_31;
      }
      v19 = v52;
      if ( !v52 )
LABEL_31:
        v19 = v50;
      *(_DWORD *)(v10 + 8) = v19;
      if ( (v18 & 0xFFFFFFFD) == 1 )
        v35 = v18 != 3 || (_DWORD)v19 == 32;
      if ( (unsigned __int16)(v46 - 1) > 0xFFu
        || (v20 = v49 / v46, v21 = (unsigned __int16)(v49 / v46), v21 < ((signed int)v19 + 7) >> 3)
        || v20 > 4u
        || v49 % v46
        || (unsigned int)(v19 - 1) > 0x1F
        || !v35 )
      {
        v11 = 1;
        sub_11570((__int64)"%s is an unsupported .W64 format!", v37);
        return v11;
      }
      if ( v17 > 39 )
      {
        if ( v53 )
        {
          if ( *(_DWORD *)(v10 + 48) || *(_BYTE *)(v10 + 17) & 4 )
          {
            v11 = 1;
            sub_11570((__int64)"this W64 file already has channel order information!");
            return v11;
          }
          *(_DWORD *)(v10 + 48) = v53;
        }
      }
      else if ( !*(_DWORD *)(v10 + 48) && !(*(_BYTE *)(v10 + 17) & 4) )
      {
        if ( v46 > 2u )
        {
          if ( v46 > 0x12u )
            *(_DWORD *)(v10 + 48) = 0x3FFFF;
          else
            *(_DWORD *)(v10 + 48) = (1 << v46) - 1;
        }
        else
        {
          *(_DWORD *)(v10 + 48) = 5 - v46;
        }
      }
      v22 = dword_2190D8;
      if ( v18 == 3 )
      {
        *(_DWORD *)(v10 + 32) = 127;
        if ( v22 )
          goto LABEL_90;
        goto LABEL_51;
      }
      if ( *(_BYTE *)(v10 + 17) & 1 && v20 == 4 )
      {
        if ( v50 == 24 )
        {
          *(_DWORD *)(v10 + 32) = 150;
        }
        else
        {
          if ( v50 != 32 )
            goto LABEL_48;
          *(_DWORD *)(v10 + 32) = 142;
        }
        if ( v22 )
          goto LABEL_50;
LABEL_51:
        v35 = 1;
      }
      else
      {
LABEL_48:
        if ( !dword_2190D8 )
          goto LABEL_51;
        if ( *(_DWORD *)(v10 + 32) != 127 )
        {
LABEL_50:
          sub_11570((__int64)"data format: %d-bit integers stored in %d byte(s)", v19, (unsigned int)v21);
          goto LABEL_51;
        }
LABEL_90:
        sub_11570((__int64)"data format: normalized 32-bit floating point");
        v35 = 1;
      }
    }
    if ( xmmword_16400 == v39 )
      break;
    v23 = (v15 + 7) & 0xFFFFFFF8;
    if ( v23 > 0x400000 )
      goto LABEL_91;
    v36 = v15;
    ptr = malloc((signed int)v23);
    if ( dword_2190D8 )
      sub_11570(
        (__int64)"extra unknown chunk \"%c%c%c%c\" of %d bytes",
        (unsigned int)(char)v39,
        (unsigned int)SBYTE1(v39),
        (unsigned int)SBYTE2(v39),
        (unsigned int)SBYTE3(v39),
        v36,
        v33);
    if ( !(unsigned int)sub_11710(v9, (__int64)ptr, v23, &v38)
      || v23 != v38
      || !(*(_BYTE *)(v10 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v14, ptr, v23) )
    {
      v11 = 1;
      v32 = WavpackGetErrorMessage(v14);
      sub_11570((__int64)"%s", v32);
      free(ptr);
      return v11;
    }
    free(ptr);
  }
  v24 = v46;
  v11 = 0;
  v25 = v14;
  v7 = v37;
  if ( !v46 )
    goto LABEL_3;
  v26 = *(_DWORD *)(v10 + 16);
  if ( v26 & 0x800 || v15 <= 0 )
  {
    BYTE1(v26) |= 8u;
    v28 = -1LL;
    *(_DWORD *)(v10 + 16) = v26;
    if ( v33 )
    {
      v28 = j__ftell(v9);
      if ( v28 != -1 )
      {
        v31 = v33 - j__ftell(v9);
        v28 = v31 / v49;
      }
      v24 = v46;
    }
LABEL_68:
    v29 = v49;
    *(_DWORD *)(v10 + 28) = v24;
    *(_DWORD *)(v10 + 12) = (unsigned __int16)(v29 / (unsigned __int16)v24);
    *(_DWORD *)(v10 + 44) = v47;
    if ( !(unsigned int)WavpackSetConfiguration64(v25, v10, v28, 0LL) )
    {
      v11 = 1;
      v30 = WavpackGetErrorMessage(v25);
      sub_11570((__int64)"%s: %s", v37, v30);
    }
  }
  else if ( v33 && v33 - v15 > 0x1000000 )
  {
    v11 = 1;
    sub_11570(
      (__int64)"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!",
      (unsigned __int64)v39 ^ (unsigned __int64)xmmword_16410 | *((_QWORD *)&v39 + 1) ^ *((_QWORD *)&xmmword_16410 + 1));
  }
  else
  {
    v27 = v15 / v49;
    v28 = v15 / v49;
    if ( v27 )
    {
      if ( v27 <= 1099511627519LL )
        goto LABEL_68;
      v11 = 1;
      sub_11570((__int64)"%s has too many samples for WavPack!", v37);
    }
    else
    {
      v11 = 1;
      sub_11570((__int64)"this .W64 file has no audio samples, probably is corrupt!", 0LL, v15 % v49);
    }
  }
  return v11;
}
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 34C0: using guessed type __int64  WavpackLittleEndianToNative(_QWORD, _QWORD, double);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 16400: using guessed type __int128 xmmword_16400;
// 16410: using guessed type __int128 xmmword_16410;
// 16420: using guessed type __int128 xmmword_16420;
// 16430: using guessed type __int128 xmmword_16430;
// 2190D8: using guessed type int dword_2190D8;

//----- (000000000000DFC0) ----------------------------------------------------
signed __int64  sub_DFC0(FILE *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  signed int v4; // er15
  int v5; // er12
  int v6; // er14
  int v7; // er13
  __int16 v8; // bp
  int v9; // eax
  signed __int16 v10; // si
  __int64 v11; // rdx
  __int64 v12; // rdx
  signed __int64 v13; // rcx
  signed __int64 v14; // rsi
  unsigned int v15; // er13
  __m128i *v16; // rsi
  signed __int64 result; // rax
  int v18; // eax
  __int64 v19; // [rsp+0h] [rbp-F8h]
  int v20; // [rsp+1Ch] [rbp-DCh]
  __m128i v21; // [rsp+20h] [rbp-D8h]
  __int64 v22; // [rsp+30h] [rbp-C8h]
  __m128i v23; // [rsp+40h] [rbp-B8h]
  __int64 v24; // [rsp+50h] [rbp-A8h]
  __m128i v25; // [rsp+60h] [rbp-98h]
  unsigned __int64 v26; // [rsp+70h] [rbp-88h]
  __m128i v27; // [rsp+78h] [rbp-80h]
  __int16 v28; // [rsp+90h] [rbp-68h]
  __int16 v29; // [rsp+92h] [rbp-66h]
  int v30; // [rsp+94h] [rbp-64h]
  int v31; // [rsp+98h] [rbp-60h]
  __int16 v32; // [rsp+9Ch] [rbp-5Ch]
  __int16 v33; // [rsp+9Eh] [rbp-5Ah]
  __int128 v34; // [rsp+A0h] [rbp-58h]
  __int64 v35; // [rsp+B0h] [rbp-48h]
  unsigned __int64 v36; // [rsp+B8h] [rbp-40h]

  v3 = a2;
  v19 = a3;
  v36 = __readfsqword(0x28u);
  v4 = WavpackGetNumChannels(a2);
  v5 = WavpackGetChannelMask(a2);
  v6 = WavpackGetSampleRate(a2);
  v7 = WavpackGetBytesPerSample(a2);
  v8 = WavpackGetBitsPerSample(a2);
  v9 = WavpackGetFloatNormExp(a2);
  v10 = 1;
  v11 = v19;
  if ( v9 && (v18 = WavpackGetFloatNormExp(v3), v10 = 3, v11 = v19, v18 != 127) )
  {
    sub_11570((__int64)"can't create valid Wave64 header for non-normalized floating data!", 3LL, v19);
    result = 0LL;
  }
  else
  {
    if ( v11 == -1 )
      v11 = 2147479552 / (v7 * v4);
    v28 = v10;
    v29 = v4;
    v34 = 0LL;
    v30 = v6;
    v35 = 0LL;
    v12 = v4 * v7 * v11;
    v33 = v8;
    v31 = v7 * v4 * v6;
    v32 = v4 * v7;
    if ( v4 > 2 || 5 - v4 != v5 )
    {
      WORD4(v34) = v10;
      LOWORD(v34) = 22;
      v28 = -2;
      *(_WORD *)((char *)&v35 + 5) = -25800;
      v13 = 64LL;
      WORD1(v34) = v8;
      v34 = v5;
      v14 = 40LL;
      v33 = 8 * v7;
      BYTE14(v34) = 16;
      v15 = 40;
      LOBYTE(v35) = -128;
      BYTE3(v35) = -86;
      HIBYTE(v35) = 113;
    }
    else
    {
      v13 = 40LL;
      v14 = 16LL;
      v15 = 16;
    }
    v24 = v13;
    v25 = _mm_load_si128((const __m128i *)&xmmword_16430);
    v22 = v12 + 24;
    v26 = v14 + ((v12 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 88;
    v27 = _mm_load_si128((const __m128i *)&xmmword_16420);
    v23 = _mm_load_si128((const __m128i *)&xmmword_16410);
    v21 = _mm_load_si128((const __m128i *)&xmmword_16400);
    WavpackNativeToLittleEndian(&v25, "88D");
    WavpackNativeToLittleEndian(&v23, "88D");
    WavpackNativeToLittleEndian(&v28, "SSLLSSSSLS");
    WavpackNativeToLittleEndian(&v21, "88D");
    v16 = &v25;
    if ( (unsigned int)sub_11780(a1, (__int64)&v25, 0x28u, &v20)
      && v20 == 40
      && (v16 = &v23, (unsigned int)sub_11780(a1, (__int64)&v23, 0x18u, &v20))
      && v20 == 24
      && (v16 = (__m128i *)&v28, (unsigned int)sub_11780(a1, (__int64)&v28, v15, &v20))
      && v15 == v20
      && (v16 = &v21, (unsigned int)sub_11780(a1, (__int64)&v21, 0x18u, &v20))
      && v20 == 24 )
    {
      result = 1LL;
    }
    else
    {
      sub_11570((__int64)"can't write .W64 data, disk probably full!", v16);
      result = 0LL;
    }
  }
  return result;
}
// 3180: using guessed type __int64  WavpackGetBitsPerSample(_QWORD);
// 3290: using guessed type __int64  WavpackGetBytesPerSample(_QWORD);
// 33B0: using guessed type __int64  WavpackGetFloatNormExp(_QWORD);
// 3400: using guessed type __int64  WavpackGetChannelMask(_QWORD);
// 3480: using guessed type __int64  WavpackGetSampleRate(_QWORD);
// 34E0: using guessed type __int64  WavpackNativeToLittleEndian(_QWORD, _QWORD);
// 3600: using guessed type __int64  WavpackGetNumChannels(_QWORD);
// 16400: using guessed type __int128 xmmword_16400;
// 16410: using guessed type __int128 xmmword_16410;
// 16420: using guessed type __int128 xmmword_16420;
// 16430: using guessed type __int128 xmmword_16430;

//----- (000000000000E340) ----------------------------------------------------
__int64  sub_E340(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5)
{
  int *v5; // r12
  FILE *v6; // rbp
  __int64 v7; // r13
  __int64 v8; // rbx
  unsigned int v9; // er12
  bool v11; // cf
  bool v12; // zf
  const char *v13; // rdi
  signed __int64 v14; // rcx
  char *v15; // rsi
  char v16; // al
  bool v17; // cf
  bool v18; // zf
  __int64 v19; // rdx
  bool v20; // cf
  bool v21; // zf
  int *v22; // rsi
  const char *v23; // rdi
  signed __int64 v24; // rcx
  signed int v25; // er8
  char v26; // r9
  double v27; // xmm0_8
  double v28; // xmm2_8
  __m128d v29; // xmm2
  unsigned int v30; // ecx
  __int64 v31; // rsi
  unsigned int v32; // eax
  int v33; // edx
  const char *v34; // rdx
  const char *v35; // rdi
  signed __int64 v36; // rcx
  char *v37; // rsi
  char v38; // al
  bool v39; // cf
  bool v40; // zf
  size_t v41; // r12
  unsigned int *v42; // r13
  __int64 v43; // rdx
  __int64 v44; // rsi
  signed int *v45; // rdx
  signed int v46; // er12
  signed int v47; // eax
  char *v48; // rax
  const char *v49; // rdi
  const char *v50; // rcx
  const char *v51; // ST40_8
  unsigned int v52; // ST58_4
  unsigned int v53; // ST24_4
  char *v54; // rax
  char *v55; // rcx
  char *v56; // r8
  const char *v57; // rdi
  signed __int64 v58; // rcx
  char *v59; // rsi
  size_t v60; // r13
  void *v61; // r12
  __int64 v62; // rax
  const char *v63; // rsi
  char *v64; // rax
  signed int v65; // er10
  unsigned int v66; // ebp
  unsigned int *v67; // rbx
  int v68; // er12
  signed int v69; // esi
  int *v70; // rdx
  signed __int64 v71; // rax
  int v72; // ecx
  int v73; // er8
  signed int v74; // eax
  unsigned int *v75; // rdx
  _BYTE *v76; // r9
  signed __int64 v77; // r11
  unsigned int v78; // esi
  __int64 v79; // rcx
  char *v80; // rcx
  _BYTE *v81; // rax
  __int64 v82; // rax
  __int64 v83; // rax
  void *v84; // rdi
  const char *v85; // rdi
  signed int v86; // ST40_4
  signed __int64 v87; // rdx
  int v88; // ST48_4
  signed int v89; // ST40_4
  _BYTE *v90; // ST68_8
  unsigned int *v91; // ST60_8
  int v92; // ST5C_4
  signed int v93; // ST50_4
  signed __int64 v94; // ST48_8
  char *v95; // ST40_8
  __int64 v96; // rax
  int v97; // eax
  signed __int64 v98; // rax
  signed int v99; // ecx
  __int128 v100; // tt
  __int64 v101; // rax
  __int64 v102; // [rsp+0h] [rbp-108h]
  __int64 v103; // [rsp+8h] [rbp-100h]
  signed int v104; // [rsp+24h] [rbp-E4h]
  int v105; // [rsp+24h] [rbp-E4h]
  signed int v106; // [rsp+24h] [rbp-E4h]
  __int64 v107; // [rsp+28h] [rbp-E0h]
  _BYTE *v108; // [rsp+30h] [rbp-D8h]
  char *ptr; // [rsp+38h] [rbp-D0h]
  FILE *v110; // [rsp+40h] [rbp-C8h]
  signed int v111; // [rsp+40h] [rbp-C8h]
  __int64 v112; // [rsp+50h] [rbp-B8h]
  unsigned int v113; // [rsp+58h] [rbp-B0h]
  unsigned int v114; // [rsp+74h] [rbp-94h]
  char v115; // [rsp+78h] [rbp-90h]
  int v116; // [rsp+7Ch] [rbp-8Ch]
  __int16 v117; // [rsp+80h] [rbp-88h]
  char v118; // [rsp+84h] [rbp-84h]
  char v119; // [rsp+85h] [rbp-83h]
  char v120; // [rsp+86h] [rbp-82h]
  char v121; // [rsp+87h] [rbp-81h]
  size_t size; // [rsp+88h] [rbp-80h]
  double v123; // [rsp+90h] [rbp-78h]
  int v124; // [rsp+98h] [rbp-70h]
  unsigned int v125; // [rsp+9Ch] [rbp-6Ch]
  unsigned int v126; // [rsp+A0h] [rbp-68h]
  unsigned int v127; // [rsp+A4h] [rbp-64h]
  unsigned int v128; // [rsp+A8h] [rbp-60h]
  unsigned int v129; // [rsp+ACh] [rbp-5Ch]
  __int64 v130; // [rsp+BFh] [rbp-49h]
  char v131; // [rsp+C7h] [rbp-41h]
  unsigned __int64 v132; // [rsp+C8h] [rbp-40h]

  v5 = a3;
  v6 = stream;
  v7 = a2;
  v8 = a5;
  v102 = a4;
  v132 = __readfsqword(0x28u);
  v103 = sub_117F0(stream);
  v116 = *v5;
  if ( !(unsigned int)sub_11710(stream, (__int64)&v117, 4u, &v114) || v114 != 4 )
  {
LABEL_3:
    v9 = 1;
    sub_11570((__int64)"%s is not a valid .CAF file!", v7);
    return v9;
  }
  if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v102, &v116, 8LL) )
    goto LABEL_101;
  WavpackBigEndianToNative(&v116, "4SS");
  if ( v117 != 1 )
  {
    v9 = 1;
    sub_11570((__int64)"%s: can't handle version %d .CAF files!", a2);
    return v9;
  }
  v108 = 0LL;
  ptr = 0LL;
  v113 = 0;
  v104 = 0;
  v107 = a2;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !(unsigned int)sub_11710(v6, (__int64)&v118, 0xCu, &v114) || v114 != 12 )
        {
LABEL_102:
          v7 = v107;
          goto LABEL_3;
        }
        if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v102, &v118, 12LL) )
          goto LABEL_101;
        WavpackBigEndianToNative(&v118, "4D");
        v13 = "desc";
        v14 = 4LL;
        v15 = &v118;
        do
        {
          if ( !v14 )
            break;
          v11 = (unsigned __int8)*v15 < *v13;
          v12 = *v15++ == *v13++;
          --v14;
        }
        while ( v12 );
        v16 = (!v11 && !v12) - v11;
        v17 = 0;
        v18 = v16 == 0;
        if ( v16 )
          break;
        if ( size != 32 || !(unsigned int)sub_11710(v6, (__int64)&v123, 0x20u, &v114) || v114 != size )
          goto LABEL_102;
        if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v102, &v123, v114) )
          goto LABEL_101;
        WavpackBigEndianToNative(&v123, "D4LLLLL");
        v20 = 0;
        v21 = dword_2190D8 == 0;
        if ( dword_2190D8 )
        {
          BYTE4(v130) = 0;
          LODWORD(v130) = v124;
          sub_11570((__int64)"format = %s, flags = %x, sampling rate = %g", &v130, v125, v123);
          sub_11570((__int64)"packet = %d bytes and %d frames", v126, v127);
          sub_11570((__int64)"channels per frame = %d, bits per channel = %d", v128, v129);
        }
        v22 = &v124;
        v23 = "lpcm";
        v24 = 4LL;
        do
        {
          if ( !v24 )
            break;
          v20 = *(_BYTE *)v22 < (const unsigned __int8)*v23;
          v21 = *(_BYTE *)v22 == *v23;
          v22 = (int *)((char *)v22 + 1);
          ++v23;
          --v24;
        }
        while ( v21 );
        v25 = (char)((!v20 && !v21) - v20);
        if ( (!v20 && !v21) != v20 )
          goto LABEL_207;
        v26 = v125;
        if ( v125 & 0xFFFFFFFC )
          goto LABEL_207;
        v27 = v123;
        if ( v123 < 1.0 || v123 > 16777215.0 )
          goto LABEL_207;
        v28 = v123;
        if ( fabs(v123) < 4.503599627370496e15 )
        {
          v29[0] = (double)(signed int)v123;
        }
        if ( v123 != v28
          || (v30 = v128, v128 - 1 > 0xFF)
          || (v31 = v129, v129 - 1 > 0x1F)
          || v129 != 32 && v125 & 1
          || v127 != 1
          || (v19 = v126 % v128, v32 = v126 / v128, v126 / v128 < (v129 + 7) >> 3)
          || v32 > 4
          || (_DWORD)v19 )
        {
LABEL_207:
          v9 = 1;
          sub_11570((__int64)"%s is an unsupported .CAF format!", v107, v19);
          return v9;
        }
        if ( v125 & 1 )
          v25 = 127;
        *(_DWORD *)(v8 + 12) = v32;
        *(_DWORD *)(v8 + 32) = v25;
        *(_DWORD *)(v8 + 8) = v31;
        *(_DWORD *)(v8 + 28) = v30;
        *(_DWORD *)(v8 + 44) = (signed int)v27;
        if ( !(v26 & 2) && v32 != 1 )
          *(_DWORD *)(v8 + 16) |= 1u;
        if ( v32 == 1 )
          *(_DWORD *)(v8 + 16) |= 2u;
        if ( dword_2190D8 )
        {
          v33 = *(_DWORD *)(v8 + 16) & 1;
          if ( v25 == 127 )
          {
            v63 = "little";
            if ( v33 )
              v63 = (const char *)&unk_16440;
            sub_11570((__int64)"data format: 32-bit %s-endian floating point", v63);
          }
          else
          {
            v12 = v33 == 0;
            v34 = "little";
            if ( !v12 )
              v34 = (const char *)&unk_16440;
            sub_11570((__int64)"data format: %d-bit %s-endian integers stored in %d byte(s)", v31, v34, v32);
          }
        }
      }
      v35 = "chan";
      v36 = 4LL;
      v37 = &v118;
      do
      {
        if ( !v36 )
          break;
        v17 = (unsigned __int8)*v37 < *v35;
        v18 = *v37++ == *v35++;
        --v36;
      }
      while ( v18 );
      v38 = (!v17 && !v18) - v17;
      v39 = 0;
      v40 = v38 == 0;
      if ( v38 )
        break;
      v41 = size;
      if ( size - 12 > 0x3F4 )
      {
        v9 = 1;
        sub_11570((__int64)"this .CAF file has an invalid 'chan' chunk!", v37);
        return v9;
      }
      if ( dword_2190D8 )
      {
        sub_11570((__int64)"'chan' chunk is %d bytes", (unsigned int)size);
        v41 = size;
      }
      v42 = (unsigned int *)malloc(v41);
      if ( !(unsigned int)sub_11710(v6, (__int64)v42, v41, &v114) || (v43 = v114, v114 != size) )
      {
        v9 = 1;
        sub_11570((__int64)"%s is not a valid .CAF file!", v107, v43);
        free(v42);
        return v9;
      }
      if ( !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v102, v42, v114) )
      {
        v9 = 1;
        v96 = WavpackGetErrorMessage(v102);
        sub_11570((__int64)"%s", v96);
        free(v42);
        return v9;
      }
      WavpackBigEndianToNative(v42, "LLL");
      if ( *(_DWORD *)(v8 + 48) || *(_DWORD *)(v8 + 16) & 0x400 )
      {
        v85 = "this CAF file already has channel order information!";
LABEL_160:
        v9 = 1;
        sub_11570((__int64)v85);
        free(v42);
        return v9;
      }
      v44 = *v42;
      if ( !(_DWORD)v44 )
      {
        v106 = v42[2];
        if ( size != 20LL * v106 + 12 || *(_DWORD *)(v8 + 28) != v106 )
        {
          v85 = "channel descriptions in 'chan' chunk are the wrong size!";
          goto LABEL_160;
        }
        if ( v106 > 255 )
        {
          sub_11570((__int64)"%d channel descriptions is more than we can handle...ignoring!");
          goto LABEL_100;
        }
        v108 = malloc(v106);
        memset(v108, -1, v106);
        v64 = (char *)malloc(v106 + 1);
        v65 = v106;
        ptr = v64;
        if ( v106 > 0 )
        {
          v110 = v6;
          v112 = v8;
          v66 = 0;
          v67 = v42 + 3;
          do
          {
            ++v66;
            WavpackBigEndianToNative(v67, "LLLLL");
            if ( dword_2190D8 )
              sub_11570((__int64)"chan %d --> %d", v66, *v67);
            v67 += 5;
          }
          while ( v106 != v66 );
          v6 = v110;
          v8 = v112;
          v65 = v106;
        }
        v68 = 0;
        v69 = 1;
        do
        {
          if ( v65 > 0 )
          {
            v70 = (int *)(v42 + 8);
            v71 = 1LL;
            if ( v42[3] == v69 )
            {
              v81 = v108;
LABEL_140:
              *(_DWORD *)(v8 + 48) |= 1 << (v69 - 1);
              *v81 = v68++;
            }
            else
            {
              while ( v71 != (unsigned int)(v65 - 1) + 1LL )
              {
                v72 = *v70;
                v70 += 5;
                if ( v72 == v69 )
                {
                  v81 = &v108[v71];
                  goto LABEL_140;
                }
                ++v71;
              }
            }
          }
          ++v69;
        }
        while ( v69 != 19 );
        v73 = 0;
        v74 = 0;
        if ( v65 <= 0 )
        {
LABEL_146:
          if ( v74 != v65 )
            goto LABEL_147;
          v88 = v73;
          v89 = v65;
          free(v108);
          v108 = 0LL;
          v65 = v89;
          v73 = v88;
        }
        else
        {
          v75 = v42 + 3;
          v73 = 0;
          v76 = v108;
          v77 = (signed __int64)&v108[v65 - 1 + 1];
          do
          {
            if ( *v76 == -1 )
            {
              v78 = *v75;
              v79 = v73++;
              v80 = &ptr[v79];
              if ( *v75 - 1 > 0xFFFFFFFD || v78 == 100 )
              {
                *v80 = -1;
              }
              else if ( v78 - 33 > 0xB && v78 - 200 > 7 && v78 - 301 > 4 )
              {
                v90 = v76;
                v91 = v75;
                v92 = v73;
                v93 = v65;
                v94 = v77;
                v95 = v80;
                sub_11570((__int64)"warning: unknown channel descriptions label: %d");
                v76 = v90;
                v75 = v91;
                v73 = v92;
                v65 = v93;
                v77 = v94;
                *v95 = -1;
              }
              else
              {
                if ( v78 > 0x12C )
                  LOBYTE(v78) = v78 - 80;
                *v80 = v78;
              }
              *v76 = v68++;
            }
            ++v76;
            v75 += 5;
          }
          while ( (_BYTE *)v77 != v76 );
          if ( !*v108 )
          {
            v74 = 0;
            do
              ++v74;
            while ( v65 > v74 && (unsigned __int8)v108[v74] == v74 );
            goto LABEL_146;
          }
LABEL_147:
          *(_DWORD *)(v8 + 16) |= 8u;
          v113 = v65;
        }
        if ( v73 )
        {
          ptr[v73] = 0;
        }
        else
        {
          v86 = v65;
          free(ptr);
          ptr = 0LL;
          v65 = v86;
        }
        if ( dword_2190D8 )
        {
          v111 = v65;
          sub_11570(
            (__int64)"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS",
            *v42,
            *(unsigned int *)(v8 + 48),
            v42[2]);
          if ( v108 )
          {
            if ( v111 <= 8 )
            {
              v131 = 0;
              v130 = 4050765991979987505LL;
              if ( v111 <= 0 )
              {
                v106 = 0;
              }
              else
              {
                v82 = 0LL;
                do
                {
                  *((_BYTE *)&v130 + v82) = v108[v82] + 49;
                  ++v82;
                }
                while ( v82 != (unsigned int)(v111 - 1) + 1LL );
              }
              *((_BYTE *)&v130 + v106) = 0;
              sub_11570((__int64)"reordering string = \"%s\"\n", &v130);
            }
          }
        }
        goto LABEL_100;
      }
      if ( (_DWORD)v44 == 0x10000 )
      {
        v12 = dword_2190D8 == 0;
        *(_DWORD *)(v8 + 48) = v42[1];
        if ( !v12 )
          sub_11570((__int64)"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x", 0x10000LL);
      }
      else
      {
        v45 = (signed int *)&unk_2182F0;
        v46 = 6619138;
        v47 = 1;
        if ( (_DWORD)v44 == 6553601 )
        {
          *(_DWORD *)(v8 + 48) = 4;
          v113 = 6553601;
          v87 = 4LL;
LABEL_79:
          if ( dword_2190D8 )
          {
            v55 = "yes";
            v56 = "yes";
            if ( !ptr )
              v56 = "no";
            if ( !v108 )
              v55 = "no";
            sub_11570(
              (__int64)"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s",
              v113,
              v87,
              v55,
              v56);
          }
        }
        else
        {
          while ( 1 )
          {
            if ( (_DWORD)v44 == v46 )
            {
              v105 = *(_DWORD *)(v8 + 16);
              v48 = (char *)&unk_2182C0 + 24 * v47;
              v49 = (const char *)*((_QWORD *)v48 + 1);
              v87 = *((unsigned int *)v48 + 1);
              v50 = (const char *)*((_QWORD *)v48 + 2);
              *(_DWORD *)(v8 + 48) = v87;
              if ( v49 )
              {
                v51 = v50;
                v52 = v87;
                v108 = strdup(v49);
                v50 = v51;
                v87 = v52;
                *(_DWORD *)(v8 + 16) = v105 | 8;
              }
              v113 = v46;
              if ( v50 )
              {
                v53 = v87;
                v54 = strdup(v50);
                v87 = v53;
                ptr = v54;
              }
              goto LABEL_79;
            }
            if ( ++v47 == 47 )
              break;
            v46 = *v45;
            v45 += 6;
          }
          if ( dword_2190D8 )
            sub_11570((__int64)"layout_tag 0x%08x not found in table...all channels unassigned", v44, v45);
        }
      }
LABEL_100:
      free(v42);
      v104 = 1;
    }
    v57 = "data";
    v58 = 4LL;
    v59 = &v118;
    do
    {
      if ( !v58 )
        break;
      v39 = (unsigned __int8)*v59 < *v57;
      v40 = *v59++ == *v57++;
      --v58;
    }
    while ( v40 );
    v9 = (char)((!v39 && !v40) - v39);
    if ( (!v39 && !v40) == v39 )
      break;
    v60 = size;
    if ( size > 0x100000 )
      goto LABEL_102;
    v61 = malloc(size);
    if ( dword_2190D8 )
      sub_11570(
        (__int64)"extra unknown chunk \"%c%c%c%c\" of %d bytes",
        (unsigned int)v118,
        (unsigned int)v119,
        (unsigned int)v120,
        (unsigned int)v121,
        v60,
        v102);
    if ( !(unsigned int)sub_11710(v6, (__int64)v61, v60, &v114)
      || v114 != (_DWORD)v60
      || !(*(_BYTE *)(v8 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v102, v61, (unsigned int)v60) )
    {
      v83 = WavpackGetErrorMessage(v102);
      sub_11570((__int64)"%s", v83);
      v84 = v61;
      v9 = 1;
      free(v84);
      return v9;
    }
    free(v61);
  }
  if ( !(unsigned int)sub_11710(v6, (__int64)&v115, 4u, &v114) || v114 != 4 )
  {
    sub_11570((__int64)"%s is not a valid .CAF file!", v107);
    return 1;
  }
  v97 = *(_DWORD *)(v8 + 16);
  if ( !(v97 & 0x200) )
  {
    if ( (unsigned int)WavpackAddWrapper(v102, &v115, 4LL) )
    {
      v97 = *(_DWORD *)(v8 + 16);
      goto LABEL_172;
    }
    v101 = WavpackGetErrorMessage(v102);
    sub_11570((__int64)"%s", v101);
    return 1;
  }
LABEL_172:
  if ( v97 & 0x800 || size == -1LL )
  {
    BYTE1(v97) |= 8u;
    *(_DWORD *)(v8 + 16) = v97;
    if ( v103 && j__ftell(v6) != -1 )
    {
      v100 = v103 - j__ftell(v6);
      v98 = v100 / v126;
    }
    else
    {
      v98 = -1LL;
    }
LABEL_179:
    if ( !v104 && !*(_DWORD *)(v8 + 48) )
    {
      v99 = *(_DWORD *)(v8 + 28);
      if ( v99 <= 2 && !(*(_BYTE *)(v8 + 17) & 4) )
        *(_DWORD *)(v8 + 48) = 5 - v99;
    }
    if ( (unsigned int)WavpackSetConfiguration64(v102, v8, v98, ptr) )
    {
      if ( ptr )
        free(ptr);
      if ( v113 || v108 )
      {
        if ( !(unsigned int)WavpackSetChannelLayout(v102, v113, v108) )
        {
          sub_11570((__int64)"problem with setting channel layout (should not happen)", v113);
          return 1;
        }
        if ( v108 )
          free(v108);
      }
      return v9;
    }
LABEL_101:
    v9 = 1;
    v62 = WavpackGetErrorMessage(v102);
    sub_11570((__int64)"%s", v62);
    return v9;
  }
  if ( v103 && (signed __int64)(v103 - size) > 0x1000000 )
  {
    sub_11570((__int64)".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!", v107);
  }
  else
  {
    v98 = (signed __int64)(size - 4) / v126;
    if ( (signed __int64)(size - 4) % v126 )
    {
      sub_11570((__int64)".CAF file %s has an invalid data chunk size, probably is corrupt!", v107);
    }
    else if ( v98 )
    {
      if ( v98 <= 1099511627519LL )
        goto LABEL_179;
      sub_11570((__int64)"%s has too many samples for WavPack!", v107);
    }
    else
    {
      sub_11570((__int64)"this .CAF file has no audio samples, probably is corrupt!", &v115);
    }
  }
  return 1;
}
// 3020: using guessed type __int64  WavpackBigEndianToNative(_QWORD, _QWORD);
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 3640: using guessed type __int64  WavpackSetChannelLayout(_QWORD, _QWORD, _QWORD);
// 2190D8: using guessed type int dword_2190D8;

//----- (000000000000F9E0) ----------------------------------------------------
__int64  sub_F9E0(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15
  FILE *v6; // r13
  int *v7; // rbp
  __int64 v8; // rbx
  bool v9; // cf
  bool v10; // zf
  unsigned int v11; // ebx
  int *v13; // rsi
  const char *v14; // rdi
  signed __int64 v15; // rcx
  bool v16; // cf
  bool v17; // zf
  const char *v18; // rdi
  signed __int64 v19; // rcx
  size_t *v20; // rsi
  size_t v21; // r12
  char v22; // al
  bool v23; // cf
  bool v24; // zf
  const char *v25; // rdi
  signed __int64 v26; // rcx
  size_t *v27; // rsi
  char v28; // al
  bool v29; // cf
  bool v30; // zf
  __int64 v31; // rdx
  bool v32; // cf
  bool v33; // zf
  char *v34; // rsi
  const char *v35; // rdi
  signed __int64 v36; // rcx
  const char *v37; // rdi
  signed __int64 v38; // rcx
  size_t *v39; // rsi
  unsigned int v40; // ebx
  char *v41; // r12
  signed __int64 v42; // rbx
  __int64 v43; // r9
  bool v44; // cf
  bool v45; // zf
  const char *v46; // rdi
  signed __int64 v47; // rcx
  size_t *v48; // rsi
  char v49; // al
  bool v50; // cf
  bool v51; // zf
  const char *v52; // rdi
  signed __int64 v53; // rcx
  size_t *v54; // rsi
  char v55; // al
  bool v56; // cf
  bool v57; // zf
  const char *v58; // rdi
  signed __int64 v59; // rcx
  size_t *v60; // rsi
  int v61; // eax
  bool v62; // cf
  bool v63; // zf
  int v64; // eax
  const char *v65; // rdi
  signed __int64 v66; // rcx
  _BYTE *v67; // rsi
  unsigned __int16 v68; // ax
  int v69; // eax
  int v70; // eax
  bool v71; // cf
  bool v72; // zf
  signed __int64 v73; // rcx
  int v74; // er13
  unsigned __int64 v75; // r9
  const char *v76; // r10
  const char *v77; // r11
  char *v78; // rsi
  const char *v79; // rdi
  char v80; // al
  bool v81; // cf
  bool v82; // zf
  const char *v83; // rdi
  char *v84; // rsi
  char v85; // al
  bool v86; // cf
  bool v87; // zf
  char *v88; // rsi
  const char *v89; // rdi
  char v90; // al
  bool v91; // cf
  bool v92; // zf
  char *v93; // rsi
  const char *v94; // rdi
  char v95; // al
  bool v96; // cf
  bool v97; // zf
  int v98; // eax
  char *v99; // rdi
  __int64 v100; // rsi
  const char *v101; // rdi
  char *v102; // rsi
  char v103; // al
  bool v104; // cf
  bool v105; // zf
  __int64 v106; // rax
  const char *v107; // rdi
  char *v108; // rsi
  char v109; // al
  bool v110; // cf
  bool v111; // zf
  __int64 v112; // rsi
  __int64 v113; // rax
  const char *v114; // rdi
  char *v115; // rsi
  char v116; // al
  bool v117; // cf
  bool v118; // zf
  const char *v119; // rdi
  char *v120; // rsi
  signed __int64 v121; // r12
  __int64 v122; // rax
  __int64 v123; // rax
  unsigned __int64 v124; // ST38_8
  const char *v125; // ST30_8
  const char *v126; // ST20_8
  __int64 v127; // [rsp+0h] [rbp-B8h]
  __int64 v128; // [rsp+8h] [rbp-B0h]
  void *v129; // [rsp+10h] [rbp-A8h]
  char *v130; // [rsp+10h] [rbp-A8h]
  char *ptr; // [rsp+18h] [rbp-A0h]
  unsigned __int16 v132; // [rsp+20h] [rbp-98h]
  FILE *v133; // [rsp+28h] [rbp-90h]
  unsigned __int16 v134; // [rsp+4Ah] [rbp-6Eh]
  unsigned int v135; // [rsp+4Ch] [rbp-6Ch]
  unsigned int v136; // [rsp+50h] [rbp-68h]
  size_t size; // [rsp+54h] [rbp-64h]
  int v138; // [rsp+5Ch] [rbp-5Ch]
  int v139; // [rsp+60h] [rbp-58h]
  unsigned __int64 v140; // [rsp+64h] [rbp-54h]
  int v141; // [rsp+6Ch] [rbp-4Ch]
  unsigned __int64 v142; // [rsp+78h] [rbp-40h]

  v5 = a5;
  v6 = stream;
  v7 = a3;
  v127 = a2;
  v128 = a4;
  v142 = __readfsqword(0x28u);
  v8 = sub_117F0(stream);
  v139 = *v7;
  if ( !(unsigned int)sub_11710(stream, (__int64)&v140, 0xCu, &v135) )
    goto LABEL_3;
  v9 = v135 < 0xC;
  v10 = v135 == 12;
  if ( v135 != 12 )
    goto LABEL_3;
  v13 = &v141;
  v14 = "DSD ";
  v15 = 4LL;
  do
  {
    if ( !v15 )
      break;
    v9 = *(_BYTE *)v13 < (const unsigned __int8)*v14;
    v10 = *(_BYTE *)v13 == *v14;
    v13 = (int *)((char *)v13 + 1);
    ++v14;
    --v15;
  }
  while ( v10 );
  if ( (!v9 && !v10) != v9 )
  {
LABEL_3:
    v11 = 1;
    sub_11570((__int64)"%s is not a valid .DFF file!", v127);
    return v11;
  }
  if ( !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v128, &v139, 16LL) )
  {
LABEL_134:
    v11 = 1;
    v106 = WavpackGetErrorMessage(v128);
    sub_11570((__int64)"%s", v106);
    return v11;
  }
  WavpackBigEndianToNative(&v139, "4D4");
  if ( v8 && !(*(_BYTE *)(v5 + 17) & 8) && v140 < 0xFFFFFFFFFFFFFFFFLL && v140 != 0 && v140 + 12 != v8 )
  {
    v11 = 1;
    sub_11570((__int64)"%s is not a valid .DFF file (by total size)!", v127);
    return v11;
  }
  if ( dword_2190D8 )
    sub_11570((__int64)"file header indicated length = %lld", v140);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !(unsigned int)sub_11710(v6, (__int64)&size, 0xCu, &v135) || v135 != 12 )
          goto LABEL_3;
        if ( !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v128, &size, 12LL) )
          goto LABEL_134;
        WavpackBigEndianToNative(&size, "4D");
        v16 = 0;
        v17 = dword_2190D8 == 0;
        if ( dword_2190D8 )
          sub_11570((__int64)"chunk header indicated length = %lld", *(size_t *)((char *)&size + 4));
        v18 = "FVER";
        v19 = 4LL;
        v20 = &size;
        v21 = *(size_t *)((char *)&size + 4);
        do
        {
          if ( !v19 )
            break;
          v16 = *(_BYTE *)v20 < (const unsigned __int8)*v18;
          v17 = *(_BYTE *)v20 == *v18;
          v20 = (size_t *)((char *)v20 + 1);
          ++v18;
          --v19;
        }
        while ( v17 );
        v22 = (!v16 && !v17) - v16;
        v23 = 0;
        v24 = v22 == 0;
        if ( v22 )
          break;
        if ( *(size_t *)((char *)&size + 4) != 4 || !(unsigned int)sub_11710(v6, (__int64)&v136, 4u, &v135) || v135 != 4 )
        {
          sub_11570((__int64)"%s is not a valid .DFF file!", v127);
          return 1;
        }
        if ( !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v128, &v136, 4LL) )
        {
          v123 = WavpackGetErrorMessage(v128);
          sub_11570((__int64)"%s", v123);
          return 1;
        }
        WavpackBigEndianToNative(&v136, "L");
        if ( dword_2190D8 )
          sub_11570((__int64)"dsdiff file version = 0x%08x", v136);
      }
      v25 = "PROP";
      v26 = 4LL;
      v27 = &size;
      do
      {
        if ( !v26 )
          break;
        v23 = *(_BYTE *)v27 < (const unsigned __int8)*v25;
        v24 = *(_BYTE *)v27 == *v25;
        v27 = (size_t *)((char *)v27 + 1);
        ++v25;
        --v26;
      }
      while ( v24 );
      v28 = (!v23 && !v24) - v23;
      v29 = 0;
      v30 = v28 == 0;
      if ( !v28 )
        break;
      v37 = "DSD ";
      v38 = 4LL;
      v39 = &size;
      do
      {
        if ( !v38 )
          break;
        v29 = *(_BYTE *)v39 < (const unsigned __int8)*v37;
        v30 = *(_BYTE *)v39 == *v37;
        v39 = (size_t *)((char *)v39 + 1);
        ++v37;
        --v38;
      }
      while ( v30 );
      v11 = (char)((!v29 && !v30) - v29);
      if ( (!v29 && !v30) == v29 )
      {
        v121 = *(signed __int64 *)((char *)&size + 4) / *(signed int *)(v5 + 28);
        if ( dword_2190D8 )
          sub_11570(
            (__int64)"setting configuration with %lld samples",
            *(signed __int64 *)((char *)&size + 4) / *(signed int *)(v5 + 28));
        if ( (unsigned int)WavpackSetConfiguration64(v128, v5, v121, 0LL) )
          return v11;
        v122 = WavpackGetErrorMessage(v128);
        sub_11570((__int64)"%s: %s", v127, v122);
        return 1;
      }
      v40 = (HIDWORD(size) + 1) & 0xFFFFFFFE;
      if ( v40 > 0x400000 )
        goto LABEL_3;
      v129 = malloc((signed int)v40);
      if ( dword_2190D8 )
        sub_11570(
          (__int64)"extra unknown chunk \"%c%c%c%c\" of %d bytes",
          (unsigned int)(char)size,
          (unsigned int)SBYTE1(size),
          (unsigned int)SBYTE2(size),
          (unsigned int)SBYTE3(size),
          v21,
          v127);
      if ( !(unsigned int)sub_11710(v6, (__int64)v129, v40, &v135)
        || v40 != v135
        || !(*(_BYTE *)(v5 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v128, v129, v40) )
      {
        v11 = 1;
        v113 = WavpackGetErrorMessage(v128);
        sub_11570((__int64)"%s", v113);
        free(v129);
        return v11;
      }
      free(v129);
    }
    if ( *(size_t *)((char *)&size + 4) - 4 > 0x3FC )
      goto LABEL_3;
    if ( dword_2190D8 )
    {
      sub_11570((__int64)"got PROP chunk of %d bytes total", HIDWORD(size));
      v21 = *(size_t *)((char *)&size + 4);
    }
    ptr = (char *)malloc(v21);
    if ( !(unsigned int)sub_11710(v6, (__int64)ptr, v21, &v135) )
      break;
    v31 = v135;
    if ( v135 != *(size_t *)((char *)&size + 4) )
      break;
    v32 = 0;
    v33 = (*(_BYTE *)(v5 + 17) & 2) == 0;
    if ( !(*(_BYTE *)(v5 + 17) & 2) )
    {
      v98 = WavpackAddWrapper(v128, ptr, v135);
      v32 = 0;
      v33 = v98 == 0;
      if ( !v98 )
      {
        v99 = "%s";
        v100 = WavpackGetErrorMessage(v128);
        goto LABEL_124;
      }
    }
    v34 = ptr;
    v35 = "SND ";
    v36 = 4LL;
    do
    {
      if ( !v36 )
        break;
      v32 = (unsigned __int8)*v34 < *v35;
      v33 = *v34++ == *v35++;
      --v36;
    }
    while ( v33 );
    if ( (!v32 && !v33) == v32 )
    {
      v132 = 0;
      v41 = ptr + 4;
      v130 = &ptr[*(size_t *)((char *)&size + 4)];
LABEL_62:
      while ( (unsigned __int64)(v130 - v41) > 0xB )
      {
        while ( 1 )
        {
          v42 = (signed __int64)(v41 + 12);
          size = *(_QWORD *)v41;
          v138 = *((_DWORD *)v41 + 2);
          WavpackBigEndianToNative(&size, "4D");
          v43 = *(size_t *)((char *)&size + 4);
          if ( *(signed __int64 *)((char *)&size + 4) <= 0 )
            goto LABEL_133;
          v44 = *(size_t *)((char *)&size + 4) < (unsigned __int64)&v130[-v42];
          v45 = *(size_t *)((char *)&size + 4) == (_QWORD)&v130[-v42];
          if ( *(signed __int64 *)((char *)&size + 4) > (signed __int64)&v130[-v42] )
            goto LABEL_133;
          v46 = "FS  ";
          v47 = 4LL;
          v48 = &size;
          do
          {
            if ( !v47 )
              break;
            v44 = *(_BYTE *)v48 < (const unsigned __int8)*v46;
            v45 = *(_BYTE *)v48 == *v46;
            v48 = (size_t *)((char *)v48 + 1);
            ++v46;
            --v47;
          }
          while ( v45 );
          v49 = (!v44 && !v45) - v44;
          v50 = 0;
          v51 = v49 == 0;
          if ( !v49 )
          {
            v50 = *(size_t *)((char *)&size + 4) < 4;
            v51 = *(size_t *)((char *)&size + 4) == 4;
            if ( *(size_t *)((char *)&size + 4) == 4 )
            {
              v136 = *((_DWORD *)v41 + 3);
              WavpackBigEndianToNative(&v136, "L");
              v41 = (char *)(*(size_t *)((char *)&size + 4) + v42);
              if ( dword_2190D8 )
                sub_11570((__int64)"got sample rate of %u Hz", v136);
              goto LABEL_62;
            }
          }
          v52 = "CHNL";
          v53 = 4LL;
          v54 = &size;
          do
          {
            if ( !v53 )
              break;
            v50 = *(_BYTE *)v54 < (const unsigned __int8)*v52;
            v51 = *(_BYTE *)v54 == *v52;
            v54 = (size_t *)((char *)v54 + 1);
            ++v52;
            --v53;
          }
          while ( v51 );
          v55 = (!v50 && !v51) - v50;
          v56 = *(size_t *)((char *)&size + 4) < 1;
          v57 = *(size_t *)((char *)&size + 4) == 1;
          if ( *(signed __int64 *)((char *)&size + 4) > 1 )
          {
            v56 = 0;
            v57 = v55 == 0;
            if ( !v55 )
              break;
          }
          v58 = "CMPR";
          v59 = 4LL;
          v60 = &size;
          do
          {
            if ( !v59 )
              break;
            v56 = *(_BYTE *)v60 < (const unsigned __int8)*v58;
            v57 = *(_BYTE *)v60 == *v58;
            v60 = (size_t *)((char *)v60 + 1);
            ++v58;
            --v59;
          }
          while ( v57 );
          v61 = (char)((!v56 && !v57) - v56);
          if ( *(signed __int64 *)((char *)&size + 4) <= 3 || (v62 = 0, v63 = v61 == 0, v61) )
          {
            if ( dword_2190D8 )
            {
              sub_11570(
                (__int64)"got PROP/SND chunk type \"%c%c%c%c\" of %d bytes",
                (unsigned int)(char)size,
                (unsigned int)SBYTE1(size),
                (unsigned int)SBYTE2(size),
                (unsigned int)SBYTE3(size));
              v43 = *(size_t *)((char *)&size + 4);
            }
          }
          else
          {
            v65 = "DSD ";
            v66 = 4LL;
            v67 = v41 + 12;
            do
            {
              if ( !v66 )
                break;
              v62 = *v67 < (const unsigned __int8)*v65;
              v63 = *v67++ == *v65++;
              --v66;
            }
            while ( v63 );
            if ( (!v62 && !v63) != v62 )
            {
              sub_11570(
                (__int64)"DSDIFF files must be uncompressed, not \"%c%c%c%c\"!",
                (unsigned int)v41[12],
                (unsigned int)v41[13],
                (unsigned int)v41[14],
                (unsigned int)v41[15]);
              free(ptr);
              return 1;
            }
          }
          v41 = (char *)(v42 + v43);
          if ( (unsigned __int64)&v130[-v42 - v43] <= 0xB )
            goto LABEL_83;
        }
        v68 = *((_WORD *)v41 + 6);
        v41 += 14;
        v134 = v68;
        WavpackBigEndianToNative(&v134, "S");
        v69 = HIDWORD(size) + 1;
        if ( HIDWORD(size) - 2 >= 0 )
          v69 = HIDWORD(size) - 2;
        v70 = v69 >> 2;
        if ( !v134 || v134 < (unsigned __int16)v70 )
        {
LABEL_133:
          sub_11570((__int64)"%s is not a valid .DFF file!", v127);
          free(ptr);
          return 1;
        }
        v71 = 0;
        v72 = (_WORD)v70 == 0;
        v73 = (unsigned int)(v70 - 1);
        v31 = (unsigned int)dword_2190D8;
        if ( (_WORD)v70 )
        {
          v133 = v6;
          v74 = v132;
          v75 = (unsigned __int64)&v41[4 * (unsigned __int16)(v70 - 1) + 4];
          v76 = "SRGT";
          v77 = "MRGT";
          do
          {
            v73 = 4LL;
            v78 = v41;
            v79 = "SLFT";
            do
            {
              if ( !v73 )
                break;
              v71 = (unsigned __int8)*v78 < *v79;
              v72 = *v78++ == *v79++;
              --v73;
            }
            while ( v72 );
            v80 = (!v71 && !v72) - v71;
            v81 = 0;
            v82 = v80 == 0;
            if ( !v80 )
              goto LABEL_166;
            v83 = "MLFT";
            v73 = 4LL;
            v84 = v41;
            do
            {
              if ( !v73 )
                break;
              v81 = (unsigned __int8)*v84 < *v83;
              v82 = *v84++ == *v83++;
              --v73;
            }
            while ( v82 );
            v85 = (!v81 && !v82) - v81;
            v86 = 0;
            v87 = v85 == 0;
            if ( v85 )
            {
              v73 = 4LL;
              v88 = v41;
              v89 = v76;
              do
              {
                if ( !v73 )
                  break;
                v86 = (unsigned __int8)*v88 < *v89;
                v87 = *v88++ == *v89++;
                --v73;
              }
              while ( v87 );
              v90 = (!v86 && !v87) - v86;
              v91 = 0;
              v92 = v90 == 0;
              if ( !v90 )
                goto LABEL_167;
              v73 = 4LL;
              v93 = v41;
              v94 = v77;
              do
              {
                if ( !v73 )
                  break;
                v91 = (unsigned __int8)*v93 < *v94;
                v92 = *v93++ == *v94++;
                --v73;
              }
              while ( v92 );
              v95 = (!v91 && !v92) - v91;
              v96 = 0;
              v97 = v95 == 0;
              if ( v95 )
              {
                v101 = "LS  ";
                v73 = 4LL;
                v102 = v41;
                do
                {
                  if ( !v73 )
                    break;
                  v96 = (unsigned __int8)*v102 < *v101;
                  v97 = *v102++ == *v101++;
                  --v73;
                }
                while ( v97 );
                v103 = (!v96 && !v97) - v96;
                v104 = 0;
                v105 = v103 == 0;
                if ( v103 )
                {
                  v107 = "RS  ";
                  v73 = 4LL;
                  v108 = v41;
                  do
                  {
                    if ( !v73 )
                      break;
                    v104 = (unsigned __int8)*v108 < *v107;
                    v105 = *v108++ == *v107++;
                    --v73;
                  }
                  while ( v105 );
                  v109 = (!v104 && !v105) - v104;
                  v110 = 0;
                  v111 = v109 == 0;
                  if ( v109 )
                  {
                    v114 = "C   ";
                    v73 = 4LL;
                    v115 = v41;
                    do
                    {
                      if ( !v73 )
                        break;
                      v110 = (unsigned __int8)*v115 < *v114;
                      v111 = *v115++ == *v114++;
                      --v73;
                    }
                    while ( v111 );
                    v116 = (!v110 && !v111) - v110;
                    v117 = 0;
                    v118 = v116 == 0;
                    if ( v116 )
                    {
                      v119 = "LFE ";
                      v73 = 4LL;
                      v120 = v41;
                      do
                      {
                        if ( !v73 )
                          break;
                        v117 = (unsigned __int8)*v120 < *v119;
                        v118 = *v120++ == *v119++;
                        --v73;
                      }
                      while ( v118 );
                      if ( (!v117 && !v118) == v117 )
                      {
                        v74 |= 8u;
                      }
                      else if ( (_DWORD)v31 )
                      {
                        v124 = v75;
                        v125 = v77;
                        v126 = v76;
                        sub_11570(
                          (__int64)"undefined channel ID %c%c%c%c",
                          (unsigned int)*v41,
                          (unsigned int)v41[1],
                          (unsigned int)v41[2],
                          (unsigned int)v41[3]);
                        v31 = (unsigned int)dword_2190D8;
                        v75 = v124;
                        v77 = v125;
                        v76 = v126;
                      }
                    }
                    else
                    {
                      v74 |= 4u;
                    }
                  }
                  else
                  {
                    v74 |= 0x20u;
                  }
                }
                else
                {
                  v74 |= 0x10u;
                }
              }
              else
              {
LABEL_167:
                v74 |= 2u;
              }
            }
            else
            {
LABEL_166:
              v74 |= 1u;
            }
            v41 += 4;
            v71 = v75 < (unsigned __int64)v41;
            v72 = v75 == (_QWORD)v41;
          }
          while ( (char *)v75 != v41 );
          v132 = v74;
          v6 = v133;
        }
        if ( (_DWORD)v31 )
          sub_11570((__int64)"%d channels, mask = 0x%08x", v134, v132, v73);
      }
LABEL_83:
      if ( v132 )
      {
        v112 = *(unsigned int *)(v5 + 48);
        if ( (_DWORD)v112 || (v31 = *(unsigned int *)(v5 + 16), BYTE1(v31) & 4) )
        {
          sub_11570((__int64)"this DSDIFF file already has channel order information!", v112, v31);
          free(ptr);
          return 1;
        }
        *(_DWORD *)(v5 + 48) = v132;
      }
      else
      {
        LODWORD(v31) = *(_DWORD *)(v5 + 16);
      }
      *(_QWORD *)(v5 + 8) = 4294967304LL;
      v64 = v134;
      *(_DWORD *)(v5 + 16) = v31 | 0x20;
      *(_DWORD *)(v5 + 28) = v64;
      *(_DWORD *)(v5 + 44) = v136 >> 3;
    }
    else if ( dword_2190D8 )
    {
      sub_11570(
        (__int64)"got unknown PROP chunk type \"%c%c%c%c\" of %d bytes",
        (unsigned int)*ptr,
        (unsigned int)ptr[1],
        (unsigned int)ptr[2],
        (unsigned int)ptr[3],
        *(size_t *)((char *)&size + 4),
        v127);
    }
    free(ptr);
  }
  v100 = v127;
  v99 = "%s is not a valid .DFF file!";
LABEL_124:
  v11 = 1;
  sub_11570((__int64)v99, v100);
  free(ptr);
  return v11;
}
// 3020: using guessed type __int64  WavpackBigEndianToNative(_QWORD, _QWORD);
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 2190D8: using guessed type int dword_2190D8;

//----- (00000000000104C0) ----------------------------------------------------
signed __int64  sub_104C0(FILE *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // er14
  __int64 v5; // rbx
  __int64 v6; // rbp
  int v7; // er12
  signed int v8; // er13
  size_t v9; // r14
  char *v10; // r15
  const char *v11; // r9
  const char *v12; // r8
  char *v13; // rsi
  unsigned int v14; // er10
  signed __int64 v15; // rdi
  signed int v16; // eax
  int v17; // ecx
  __int64 v18; // rbp
  int v19; // eax
  int *v20; // rsi
  signed __int64 result; // rax
  unsigned int v22; // eax
  char v23; // dl
  char v24; // dl
  FILE *stream; // [rsp+8h] [rbp-E0h]
  int v26; // [rsp+30h] [rbp-B8h]
  int v27; // [rsp+36h] [rbp-B2h]
  __int64 v28; // [rsp+3Ah] [rbp-AEh]
  int v29; // [rsp+42h] [rbp-A6h]
  size_t v30; // [rsp+46h] [rbp-A2h]
  __int16 v31; // [rsp+4Eh] [rbp-9Ah]
  int v32; // [rsp+50h] [rbp-98h]
  unsigned __int64 v33; // [rsp+54h] [rbp-94h]
  int v34; // [rsp+5Ch] [rbp-8Ch]
  int v35; // [rsp+60h] [rbp-88h]
  size_t v36; // [rsp+64h] [rbp-84h]
  int v37; // [rsp+6Ch] [rbp-7Ch]
  int v38; // [rsp+70h] [rbp-78h]
  __int64 v39; // [rsp+74h] [rbp-74h]
  int v40; // [rsp+7Ch] [rbp-6Ch]
  int v41; // [rsp+80h] [rbp-68h]
  __int64 v42; // [rsp+84h] [rbp-64h]
  int v43; // [rsp+8Ch] [rbp-5Ch]
  int v44; // [rsp+90h] [rbp-58h]
  __int64 v45; // [rsp+94h] [rbp-54h]
  int v46; // [rsp+9Ch] [rbp-4Ch]
  unsigned __int64 v47; // [rsp+A8h] [rbp-40h]

  v4 = a4;
  v5 = a2;
  v6 = a3;
  stream = a1;
  v47 = __readfsqword(0x28u);
  v7 = WavpackGetChannelMask(a2);
  v8 = WavpackGetNumChannels(a2);
  if ( dword_2190D8 )
    sub_11570((__int64)"WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\n", v6, v4);
  v9 = 4 * v8;
  v10 = (char *)malloc(v9);
  if ( v10 )
  {
    if ( v8 > 0 )
    {
      v11 = "SRGT";
      v12 = "SLFT";
      v13 = v10;
      if ( v8 > 2 )
        v11 = "MRGT";
      if ( v8 > 2 )
        v12 = "MLFT";
      v14 = 0;
      v15 = (signed __int64)&v10[4 * (v8 - 1) + 4];
      v16 = 1;
      do
      {
        if ( !v16 )
          goto LABEL_28;
        while ( 1 )
        {
          if ( v16 & v7 )
          {
            if ( v16 & 1 )
            {
              *(_DWORD *)v13 = *(_DWORD *)v12;
              v16 *= 2;
              goto LABEL_26;
            }
            LOBYTE(v17) = v16;
            v16 *= 2;
LABEL_24:
            if ( v17 & 2 )
            {
              *(_DWORD *)v13 = *(_DWORD *)v11;
              goto LABEL_26;
            }
            if ( v17 & 4 )
            {
              *(_DWORD *)v13 = 538976323;
              goto LABEL_26;
            }
            if ( v17 & 8 )
            {
              *(_DWORD *)v13 = 541410892;
              goto LABEL_26;
            }
            v24 = v17;
            v17 = v16;
            LOBYTE(v16) = v24;
          }
          else
          {
            while ( 1 )
            {
              v17 = 2 * v16;
              if ( !(2 * v16) )
                break;
              if ( v17 & v7 )
              {
                v16 *= 4;
                goto LABEL_24;
              }
              v16 *= 2;
            }
            LOBYTE(v16) = 0;
          }
          if ( v16 & 0x10 )
            break;
          while ( 1 )
          {
            if ( v16 & 0x20 )
            {
              *(_DWORD *)v13 = 538989394;
            }
            else
            {
              *v13 = 67;
              v13[1] = v14 / 0x64 + 48;
              v13[2] = v14 % 0x64 / 0xA + 48;
              v22 = 5 * (v14 / 0xA);
              v23 = v14++;
              v13[3] = v23 - 2 * v22 + 48;
            }
            v16 = v17;
LABEL_26:
            v13 += 4;
            if ( v13 == (char *)v15 )
              goto LABEL_19;
            if ( v16 )
              break;
LABEL_28:
            v17 = 0;
          }
        }
        *(_DWORD *)v13 = 538989388;
        v13 += 4;
        v16 = v17;
      }
      while ( v13 != (char *)v15 );
    }
LABEL_19:
    v18 = v8 * v6;
    v32 = 944591430;
    v34 = 541348676;
    v35 = 1347375696;
    v37 = 541347411;
    v38 = 1380275782;
    v39 = 4LL;
    v40 = 17104896;
    v41 = 538989382;
    v42 = 4LL;
    v33 = v9 + ((v18 + 1) & 0xFFFFFFFFFFFFFFFELL) + 110;
    v36 = v9 + 66;
    v19 = WavpackGetSampleRate(v5);
    v28 = v18;
    v43 = 8 * v19;
    v30 = v9 + 2;
    v31 = v8;
    v29 = 1280198723;
    v44 = 1380994371;
    v45 = 20LL;
    v46 = 541348676;
    v27 = 541348676;
    WavpackNativeToBigEndian(&v32, "4D4");
    WavpackNativeToBigEndian(&v38, "4DL");
    WavpackNativeToBigEndian(&v35, "4D4");
    WavpackNativeToBigEndian(&v41, "4DL");
    WavpackNativeToBigEndian(&v29, "4DS");
    WavpackNativeToBigEndian(&v44, "4D4");
    WavpackNativeToBigEndian(&v27, "4D");
    v20 = &v32;
    if ( !(unsigned int)sub_11780(stream, (__int64)&v32, 0x10u, &v26) )
      goto LABEL_61;
    if ( v26 != 16 )
      goto LABEL_61;
    v20 = &v38;
    if ( !(unsigned int)sub_11780(stream, (__int64)&v38, 0x10u, &v26) )
      goto LABEL_61;
    if ( v26 == 16
      && (v20 = &v35, (unsigned int)sub_11780(stream, (__int64)&v35, 0x10u, &v26))
      && v26 == 16
      && (v20 = &v41, (unsigned int)sub_11780(stream, (__int64)&v41, 0x10u, &v26))
      && v26 == 16
      && (v20 = &v29, (unsigned int)sub_11780(stream, (__int64)&v29, 0xEu, &v26))
      && v26 == 14
      && (v20 = (int *)v10, (unsigned int)sub_11780(stream, (__int64)v10, 4 * v8, &v26))
      && 4 * v8 == v26
      && (v20 = &v44, (unsigned int)sub_11780(stream, (__int64)&v44, 0x10u, &v26))
      && v26 == 16
      && (v20 = (int *)&unk_16C35, (unsigned int)sub_11780(stream, (__int64)&unk_16C35, 0x10u, &v26))
      && v26 == 16
      && (v20 = &v27, (unsigned int)sub_11780(stream, (__int64)&v27, 0xCu, &v26))
      && v26 == 12 )
    {
      free(v10);
      result = 1LL;
    }
    else
    {
LABEL_61:
      sub_11570((__int64)"can't write .DSF data, disk probably full!", v20);
      free(v10);
      result = 0LL;
    }
  }
  else
  {
    sub_11570((__int64)"can't allocate memory!");
    result = 0LL;
  }
  return result;
}
// 3310: using guessed type __int64  WavpackNativeToBigEndian(_QWORD, _QWORD);
// 3400: using guessed type __int64  WavpackGetChannelMask(_QWORD);
// 3480: using guessed type __int64  WavpackGetSampleRate(_QWORD);
// 3600: using guessed type __int64  WavpackGetNumChannels(_QWORD);
// 2190D8: using guessed type int dword_2190D8;

//----- (0000000000010A20) ----------------------------------------------------
__int64  sub_10A20(FILE *stream, __int64 a2, int *a3, __int64 a4, __int64 a5, double a6)
{
  __int64 v6; // r13
  int *v7; // rbp
  FILE *v8; // rbx
  __int64 v9; // r12
  __int64 v10; // r14
  unsigned int v11; // ebx
  const char *v13; // rsi
  bool v14; // cf
  bool v15; // zf
  const char *v16; // rdi
  signed __int64 v17; // rcx
  char *v18; // rsi
  __int64 v19; // rbp
  __int64 v20; // rdx
  __int64 v21; // r14
  __int64 v22; // rsi
  __int64 v23; // r14
  unsigned int v24; // eax
  unsigned int v25; // edx
  int v26; // eax
  int v27; // eax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // [rsp+8h] [rbp-B0h]
  unsigned int v31; // [rsp+10h] [rbp-A8h]
  char s1; // [rsp+14h] [rbp-A4h]
  __int64 v33; // [rsp+18h] [rbp-A0h]
  int v34; // [rsp+20h] [rbp-98h]
  const char *v35; // [rsp+24h] [rbp-94h]
  unsigned __int64 v36; // [rsp+2Ch] [rbp-8Ch]
  __int64 v37; // [rsp+34h] [rbp-84h]
  char v38; // [rsp+40h] [rbp-78h]
  __int64 v39; // [rsp+44h] [rbp-74h]
  int v40; // [rsp+4Ch] [rbp-6Ch]
  int v41; // [rsp+50h] [rbp-68h]
  unsigned int v42; // [rsp+54h] [rbp-64h]
  unsigned int v43; // [rsp+58h] [rbp-60h]
  unsigned int v44; // [rsp+5Ch] [rbp-5Ch]
  unsigned int v45; // [rsp+60h] [rbp-58h]
  __int64 v46; // [rsp+64h] [rbp-54h]
  unsigned int v47; // [rsp+6Ch] [rbp-4Ch]
  int v48; // [rsp+70h] [rbp-48h]
  unsigned __int64 v49; // [rsp+78h] [rbp-40h]

  v6 = a5;
  v7 = a3;
  v8 = stream;
  v9 = a2;
  v30 = a4;
  v49 = __readfsqword(0x28u);
  v10 = sub_117F0(stream);
  v34 = *v7;
  if ( !(unsigned int)sub_11710(stream, (__int64)&v35, 0x18u, &v31) || v31 != 24 )
  {
LABEL_3:
    v11 = 1;
    sub_11570((__int64)"%s is not a valid .DSF file!", v9);
    return v11;
  }
  if ( !(*(_BYTE *)(v6 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v30, &v34, 28LL) )
    goto LABEL_55;
  v13 = "4DDD";
  WavpackLittleEndianToNative(&v34, "4DDD", a6);
  if ( dword_2190D8 )
  {
    v13 = v35;
    sub_11570((__int64)"file header lengths = %lld, %lld, %lld", v35, v36, v37);
  }
  if ( v10 && !(*(_BYTE *)(v6 + 17) & 8) && v36 < 0xFFFFFFFFFFFFFFFFLL && v36 != 0 && v36 != v10 )
  {
    v11 = 1;
    sub_11570((__int64)"%s is not a valid .DSF file (by total size)!", v9);
    return v11;
  }
  if ( *(_DWORD *)(v6 + 48) || *(_BYTE *)(v6 + 17) & 4 )
  {
    v11 = 1;
    sub_11570((__int64)"this DSF file already has channel order information!", v13);
    return v11;
  }
  if ( !(unsigned int)sub_11710(stream, (__int64)&v38, 0x34u, &v31) )
    goto LABEL_3;
  v14 = v31 < 0x34;
  v15 = v31 == 52;
  if ( v31 != 52 )
    goto LABEL_3;
  v16 = "fmt ";
  v17 = 4LL;
  v18 = &v38;
  do
  {
    if ( !v17 )
      break;
    v14 = (unsigned __int8)*v18 < *v16;
    v15 = *v18++ == *v16++;
    --v17;
  }
  while ( v15 );
  if ( (!v14 && !v15) != v14 )
    goto LABEL_3;
  if ( !(*(_BYTE *)(v6 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v30, &v38, 52LL) )
    goto LABEL_55;
  WavpackLittleEndianToNative(&v38, "4DLLLLLLDL4", a6);
  if ( v39 != 52 || v40 != 1 || v41 || v47 != 4096 || v48 || v45 != 1 && v45 != 8 || v43 - 1 > 5 || v42 - 1 > 6 )
    goto LABEL_3;
  if ( dword_2190D8 )
  {
    sub_11570((__int64)"sampling rate = %d Hz", v44);
    sub_11570((__int64)"channel type = %d, channel count = %d", v42, v43);
    sub_11570((__int64)"block size = %d, bits per sample = %d", v47, v45);
    sub_11570((__int64)"sample count = %lld", v46);
  }
  if ( !(unsigned int)sub_11710(v8, (__int64)&s1, 0xCu, &v31) )
    goto LABEL_3;
  if ( v31 != 12 )
    goto LABEL_3;
  v11 = strncmp(&s1, "data", 4uLL);
  if ( v11 )
    goto LABEL_3;
  if ( !(*(_BYTE *)(v6 + 17) & 2) && !(unsigned int)WavpackAddWrapper(v30, &s1, 12LL) )
  {
LABEL_55:
    v11 = 1;
    v29 = WavpackGetErrorMessage(v30);
    sub_11570((__int64)"%s", v29);
    return v11;
  }
  WavpackLittleEndianToNative(&s1, "4D", a6);
  v19 = v46;
  v20 = v46 % (8 * v47);
  v21 = v46 / (8 * v47);
  v22 = v46 - 8 * v21 * v47;
  v23 = (v46 != 8 * v21 * v47) + v21;
  if ( dword_2190D8 )
  {
    sub_11570((__int64)"leftover samples = %lld, leftover bits = %d", v22, v22 % 8);
    sub_11570((__int64)"data chunk size (specified) = %lld", v33 - 12);
    v22 = v43 * (v23 << 12);
    sub_11570((__int64)"data chunk size (calculated) = %lld", v22);
  }
  if ( v19 & 7 )
    sub_11570((__int64)"warning: DSF file has partial-byte leftover samples!", v22, v20);
  v24 = v44;
  if ( v44 & 7 )
  {
    sub_11570((__int64)"warning: DSF file has non-integer bytes/second!", v22, v20);
    v24 = v44;
  }
  v15 = v45 == 1;
  *(_QWORD *)(v6 + 8) = 4294967304LL;
  v25 = v43;
  *(_DWORD *)(v6 + 44) = v24 >> 3;
  v26 = *(_DWORD *)(v6 + 16);
  *(_DWORD *)(v6 + 28) = v25;
  *(_DWORD *)(v6 + 48) = word_170C0[v42 - 1];
  if ( v15 )
    v27 = v26 | 0x50;
  else
    v27 = v26 | 0x60;
  *(_DWORD *)(v6 + 16) = v27;
  if ( !(unsigned int)WavpackSetConfiguration64(v30, v6, (v19 + 7) / 8, 0LL) )
  {
    v11 = 1;
    v28 = WavpackGetErrorMessage(v30);
    sub_11570((__int64)"%s: %s", v9, v28);
  }
  return v11;
}
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 34C0: using guessed type __int64  WavpackLittleEndianToNative(_QWORD, _QWORD, double);
// 3550: using guessed type __int64  WavpackSetConfiguration64(_QWORD, _QWORD, _QWORD, _QWORD);
// 3590: using guessed type __int64  WavpackAddWrapper(_QWORD, _QWORD, _QWORD);
// 2190D8: using guessed type int dword_2190D8;

//----- (0000000000011140) ----------------------------------------------------
void sub_11140()
{
  dword_2190D4 = 1;
}
// 2190D4: using guessed type int dword_2190D4;

//----- (0000000000011150) ----------------------------------------------------
_BOOL4  sub_11150(char *filename, char *file)
{
  char *v2; // r9
  char *v3; // rbx
  signed __int64 v4; // rcx
  char *v5; // rsi
  _BYTE *v6; // rdi
  bool v7; // cf
  bool v8; // zf
  _BOOL4 result; // rax
  char v10; // dl
  bool v11; // cf
  bool v12; // zf
  signed __int64 v13; // rcx
  char *v14; // rsi
  _BYTE *v15; // rdi
  int v16; // edx
  __time_t v17; // [rsp+0h] [rbp-C8h]
  __int64 v18; // [rsp+8h] [rbp-C0h]
  __time_t v19; // [rsp+10h] [rbp-B8h]
  __int64 v20; // [rsp+18h] [rbp-B0h]
  struct stat stat_buf; // [rsp+20h] [rbp-A8h]
  unsigned __int64 v22; // [rsp+B8h] [rbp-10h]

  v2 = filename;
  v3 = file;
  v4 = 2LL;
  v5 = filename;
  v6 = &unk_170CE;
  v22 = __readfsqword(0x28u);
  v7 = 0;
  v8 = 1;
  do
  {
    if ( !v4 )
      break;
    v7 = (unsigned __int8)*v5 < *v6;
    v8 = *v5++ == *v6++;
    --v4;
  }
  while ( v8 );
  result = 1LL;
  v10 = (!v7 && !v8) - v7;
  v11 = 0;
  v12 = v10 == 0;
  if ( v10 )
  {
    v13 = 2LL;
    v14 = v3;
    v15 = &unk_170CE;
    do
    {
      if ( !v13 )
        break;
      v11 = (unsigned __int8)*v14 < *v15;
      v12 = *v14++ == *v15++;
      --v13;
    }
    while ( v12 );
    if ( (!v11 && !v12) != v11 )
    {
      v16 = sub_129B0(v2, &stat_buf);
      result = 0LL;
      if ( !v16 )
      {
        v18 = 0LL;
        v20 = 0LL;
        v17 = stat_buf.st_atim.tv_sec;
        v19 = stat_buf.st_mtim.tv_sec;
        result = utimes(v3, (const struct timeval *)&v17) == 0;
      }
    }
  }
  return result;
}

//----- (0000000000011230) ----------------------------------------------------
signed __int64  sub_11230(const char *a1)
{
  unsigned __int64 v1; // rbp
  const char *i; // rdi
  char v3; // al
  signed __int64 v4; // rbx

  v1 = (unsigned __int64)a1;
  for ( i = &a1[strlen(a1)]; ; --i )
  {
    v4 = (signed __int64)(i - 1);
    if ( v1 > (unsigned __int64)(i - 1) )
      return 0LL;
    v3 = *(i - 1);
    if ( v3 == 47 )
      return 0LL;
    if ( v3 == 46 )
      break;
  }
  if ( !*i )
    return 0LL;
  if ( strlen(i) >= 5 )
    v4 = 0LL;
  return v4;
}

//----- (00000000000112A0) ----------------------------------------------------
char * sub_112A0(char *dest)
{
  size_t v1; // rax
  char *v2; // rbp
  char *v3; // r12
  char v4; // al
  const char **v5; // rax
  __int64 v7; // [rsp+0h] [rbp-108h]
  char **v8; // [rsp+8h] [rbp-100h]
  struct stat stat_buf; // [rsp+50h] [rbp-B8h]
  unsigned __int64 v10; // [rsp+E8h] [rbp-20h]

  v10 = __readfsqword(0x28u);
  v1 = strlen(dest);
  v2 = &dest[v1];
  if ( dest == &dest[v1] )
    return 0LL;
  v3 = strpbrk(dest, "*?");
  if ( v3 )
    return 0LL;
  v4 = *(v2 - 1);
  if ( v4 == 47 )
    return dest;
  if ( dest == v2 - 1 && v4 == 46 )
  {
    v3 = dest;
    *(_WORD *)v2 = 47;
  }
  else if ( glob(dest, 6, 0LL, (glob_t *)&v7) || !v7 || sub_129B0(*v8, &stat_buf) || !(stat_buf.st_mode & 0x4000) )
  {
    globfree((glob_t *)&v7);
  }
  else
  {
    v5 = (const char **)v8;
    *dest = 0;
    v3 = dest;
    strcat(dest, *v5);
    globfree((glob_t *)&v7);
  }
  return v3;
}

//----- (00000000000113E0) ----------------------------------------------------
const char * sub_113E0(const char *a1)
{
  const char *result; // rax

  for ( result = &a1[strlen(a1)]; a1 <= result - 1 && *(result - 1) != 47; --result )
    ;
  if ( !*result )
    result = 0LL;
  return result;
}

//----- (0000000000011410) ----------------------------------------------------
__int64 sub_11410()
{
  unsigned int v0; // ebx
  int v1; // eax
  unsigned int v2; // eax
  FILE *v3; // rsi

  v0 = 0;
  while ( 1 )
  {
    v1 = fgetc(stdin);
    if ( v1 == 3 )
    {
      fwrite("^C\n", 1uLL, 3uLL, stderr);
      exit(1);
    }
    if ( v1 == -1 )
    {
      fwrite("\r\n", 1uLL, 2uLL, stderr);
      exit(1);
    }
    if ( v1 == 13 || v1 == 10 )
      break;
    v2 = v1 & 0xFFFFFFDF;
    switch ( v2 )
    {
      case 0x59u:
        v0 = 121;
        break;
      case 0x4Eu:
        v0 = 110;
        break;
      case 0x41u:
        v0 = 97;
        break;
      default:
        v3 = stderr;
LABEL_11:
        fputc(7, v3);
        fflush(stderr);
        break;
    }
  }
  v3 = stderr;
  if ( !(_BYTE)v0 )
    goto LABEL_11;
  fwrite("\r\n", 1uLL, 2uLL, stderr);
  fflush(stderr);
  return v0;
}

//----- (0000000000011530) ----------------------------------------------------
int sub_11530()
{
  fwrite("                                \n", 1uLL, 0x21uLL, stderr);
  return fflush(stderr);
}

//----- (0000000000011570) ----------------------------------------------------
unsigned __int64 sub_11570(__int64 a1, ...)
{
  _G_va_list va; // [rsp+8h] [rbp-2E0h]
  char s; // [rsp+20h] [rbp-2C8h]
  char v4; // [rsp+21h] [rbp-2C7h]
  unsigned __int64 v5; // [rsp+228h] [rbp-C0h]

  va_start(va, a1);
  v5 = __readfsqword(0x28u);
  s = 13;
  __vsprintf_chk(&v4, 1LL, 511LL, a1, va);
  fputs(&s, stderr);
  sub_11530();
  return __readfsqword(0x28u) ^ v5;
}
// 32E0: using guessed type __int64  __vsprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011680) ----------------------------------------------------
unsigned __int64 sub_11680()
{
  void (*v1)(); // [rsp+0h] [rbp-A8h]
  __int64 v2; // [rsp+8h] [rbp-A0h]
  int v3; // [rsp+88h] [rbp-20h]
  unsigned __int64 v4; // [rsp+98h] [rbp-10h]

  dword_2190D4 = 0;
  v4 = __readfsqword(0x28u);
  v1 = sub_11140;
  sigemptyset((sigset_t *)&v2);
  v3 = 0;
  sigaction(2, (const struct sigaction *)&v1, 0LL);
  return __readfsqword(0x28u) ^ v4;
}
// 2190D4: using guessed type int dword_2190D4;

//----- (0000000000011700) ----------------------------------------------------
__int64 sub_11700()
{
  return (unsigned int)dword_2190D4;
}
// 2190D4: using guessed type int dword_2190D4;

//----- (0000000000011710) ----------------------------------------------------
_BOOL4  sub_11710(FILE *stream, __int64 a2, unsigned int a3, _DWORD *a4)
{
  FILE *v4; // rbx
  unsigned int v5; // er12
  _DWORD *v6; // r13
  __int64 v7; // rdi
  int v8; // eax

  v4 = stream;
  *a4 = 0;
  if ( a3 )
  {
    v5 = a3;
    v6 = a4;
    v7 = 0LL;
    do
    {
      v8 = fread((void *)(a2 + v7), 1uLL, v5, v4);
      if ( !v8 )
        break;
      v7 = (unsigned int)(*v6 + v8);
      v5 -= v8;
      *v6 = v7;
    }
    while ( v5 );
  }
  return ferror(v4) == 0;
}

//----- (0000000000011780) ----------------------------------------------------
_BOOL4  sub_11780(FILE *stream, __int64 a2, unsigned int a3, _DWORD *a4)
{
  FILE *v4; // rbx
  unsigned int v5; // er12
  _DWORD *v6; // r13
  __int64 v7; // rdi
  int v8; // eax

  v4 = stream;
  *a4 = 0;
  if ( a3 )
  {
    v5 = a3;
    v6 = a4;
    v7 = 0LL;
    do
    {
      v8 = fwrite((const void *)(a2 + v7), 1uLL, v5, v4);
      if ( !v8 )
        break;
      v7 = (unsigned int)(*v6 + v8);
      v5 -= v8;
      *v6 = v7;
    }
    while ( v5 );
  }
  return ferror(v4) == 0;
}

//----- (00000000000117F0) ----------------------------------------------------
__int64  sub_117F0(FILE *a1)
{
  int v1; // eax
  __int64 result; // rax
  __int64 v3; // [rsp+0h] [rbp-A8h]
  int v4; // [rsp+18h] [rbp-90h]
  __int64 v5; // [rsp+30h] [rbp-78h]
  unsigned __int64 v6; // [rsp+98h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( a1 && (v1 = fileno(a1), !sub_129C0(v1, (struct stat *)&v3)) && (v4 & 0xF000) == 0x8000 )
    result = v5;
  else
    result = 0LL;
  return result;
}

//----- (0000000000011870) ----------------------------------------------------
int  sub_11870(FILE *a1, __int64 a2)
{
  return fseek(a1, a2, 0);
}

//----- (00000000000118A0) ----------------------------------------------------
_BOOL4  sub_118A0(FILE *a1)
{
  _BOOL4 result; // rax

  if ( a1 )
    result = fclose(a1) == 0;
  else
    result = 0LL;
  return result;
}

//----- (00000000000118D0) ----------------------------------------------------
_BOOL4  sub_118D0(FILE *stream)
{
  int v1; // eax

  if ( !stream )
    return 0LL;
  fflush(stream);
  v1 = fileno(stream);
  return ftruncate(v1, 0LL) == 0;
}

//----- (0000000000011910) ----------------------------------------------------
_BOOL4  sub_11910(const char *a1)
{
  _BOOL4 result; // rax

  if ( a1 )
    result = remove(a1) == 0;
  else
    result = 0LL;
  return result;
}

//----- (0000000000011940) ----------------------------------------------------
int  sub_11940(__int64 a1)
{
  __fprintf_chk(stderr, 1LL, "\x1B]0;%s\a", a1);
  return fflush(stderr);
}
// 3090: using guessed type __int64  __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011980) ----------------------------------------------------
__int64  sub_11980(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, _DWORD *a5, int a6)
{
  signed __int64 v6; // r12
  const char *v7; // rdi
  signed __int64 v8; // rcx
  bool v9; // cf
  bool v10; // zf
  int v11; // edx
  __int16 v12; // ax
  __int64 *v13; // rsi
  __int64 v14; // rbp
  __int16 v15; // ax
  char v16; // al
  __int64 v17; // rcx
  int v19; // ebx
  int v20; // eax
  int v21; // er13
  int v22; // er14
  const void *v23; // rsi
  bool v24; // cf
  bool v25; // zf
  __int64 *v26; // rsi
  const char *v27; // rdi
  signed __int64 v28; // rcx
  const char *v29; // rdi
  signed __int64 v30; // rcx
  int v31; // ebx
  signed __int64 v32; // r15
  unsigned __int64 v33; // rbp
  unsigned __int64 v34; // r14
  unsigned __int16 *v35; // r13
  char *v36; // rax
  __int16 *v37; // rsi
  signed __int64 v38; // rdi
  unsigned __int16 v39; // dx
  __int16 v40; // dx
  unsigned __int16 *v41; // rdi
  int v42; // ecx
  char *v43; // rsi
  int v44; // er8
  int v45; // er9
  int v46; // ecx
  char *v47; // rbx
  __int64 v48; // rbp
  char *v49; // r12
  signed int v50; // er13
  char v51; // r14
  char *v52; // rax
  char *v53; // r15
  signed __int64 v54; // rax
  char v55; // dl
  __int64 v56; // rcx
  void *v57; // r13
  iconv_t v58; // rax
  void *v59; // r14
  int v60; // ST28_4
  unsigned __int16 *v61; // r8
  char *v62; // rbx
  __int64 v63; // rbp
  bool v64; // sf
  char *v65; // rax
  const unsigned __int16 **v66; // rax
  const unsigned __int16 *v67; // r15
  char *v68; // rbp
  unsigned int v69; // eax
  int v70; // ebx
  int v71; // er13
  const char *v72; // rbp
  int v73; // ebx
  char *i; // rax
  __m128i v75; // xmm0
  const char **v76; // rbx
  const char *v77; // rsi
  unsigned int v78; // er14
  char *v79; // r15
  unsigned int v80; // eax
  int v81; // er15
  char v82; // r13
  _BYTE *v83; // r15
  __int64 v84; // r14
  signed __int64 v85; // rax
  char *v86; // rax
  const char *v87; // rcx
  const char *v88; // r13
  signed int v89; // ebx
  const char *v90; // ST40_8
  size_t v91; // ST28_8
  unsigned int v92; // ebx
  char *v93; // rax
  char *v94; // rbp
  char *v95; // rax
  char *v96; // rax
  char *v97; // rax
  char *v98; // rax
  char *v99; // r14
  unsigned __int8 v100; // al
  const char *v101; // rax
  __m128i v102; // xmm0
  __m128i v103; // xmm0
  __m128i v104; // xmm0
  __m128i v105; // xmm0
  __m128i v106; // xmm0
  __m128i v107; // xmm0
  __m128i v108; // xmm0
  __m128i v109; // xmm0
  __m128i v110; // xmm0
  __m128i v111; // xmm0
  char *ptr; // [rsp+0h] [rbp-108h]
  size_t nmemb; // [rsp+8h] [rbp-100h]
  unsigned int v114; // [rsp+14h] [rbp-F4h]
  __int64 v115; // [rsp+18h] [rbp-F0h]
  int v116; // [rsp+20h] [rbp-E8h]
  int v117; // [rsp+24h] [rbp-E4h]
  size_t size; // [rsp+28h] [rbp-E0h]
  char *dest; // [rsp+38h] [rbp-D0h]
  __int64 src; // [rsp+40h] [rbp-C8h]
  _DWORD *v121; // [rsp+48h] [rbp-C0h]
  signed int v122; // [rsp+68h] [rbp-A0h]
  int v123; // [rsp+6Ch] [rbp-9Ch]
  signed __int64 v124; // [rsp+78h] [rbp-90h]
  void *v125; // [rsp+80h] [rbp-88h]
  char *v126; // [rsp+88h] [rbp-80h]
  unsigned __int64 v127; // [rsp+90h] [rbp-78h]
  __int64 v128; // [rsp+98h] [rbp-70h]
  char *v129; // [rsp+A0h] [rbp-68h]
  char *s; // [rsp+A8h] [rbp-60h]
  __int64 v131; // [rsp+B4h] [rbp-54h]
  __int16 v132; // [rsp+BCh] [rbp-4Ch]
  __int64 v133; // [rsp+BEh] [rbp-4Ah]
  __int16 v134; // [rsp+C6h] [rbp-42h]
  unsigned __int64 v135; // [rsp+C8h] [rbp-40h]

  v135 = __readfsqword(0x28u);
  v115 = a1;
  dest = (char *)a4;
  v121 = a5;
  v117 = a6;
  if ( a5 )
    *a5 = 0;
  if ( a3 <= 9 )
  {
    v114 = -1;
    v106 = _mm_load_si128((const __m128i *)&xmmword_172A0);
    *(_DWORD *)(a4 + 16) = 1701077349;
    *(_WORD *)(a4 + 20) = 114;
    *(__m128i *)a4 = v106;
    return v114;
  }
  v6 = a2 + 10;
  v7 = "ID3";
  v8 = 3LL;
  v9 = a3 < 0xA;
  v11 = a3 - 10;
  v10 = v11 == 0;
  v131 = *(_QWORD *)a2;
  v12 = *(_WORD *)(a2 + 8);
  v13 = &v131;
  do
  {
    if ( !v8 )
      break;
    v9 = *(_BYTE *)v13 < (const unsigned __int8)*v7;
    v10 = *(_BYTE *)v13 == *v7;
    v13 = (__int64 *)((char *)v13 + 1);
    ++v7;
    --v8;
  }
  while ( v10 );
  v132 = v12;
  if ( (!v9 && !v10) != v9 )
  {
    v114 = -1;
    v107 = _mm_load_si128((const __m128i *)&xmmword_172B0);
    *((_WORD *)dest + 8) = 25710;
    dest[18] = 0;
    *(__m128i *)dest = v107;
    return v114;
  }
  if ( BYTE3(v131) != 3 || BYTE4(v131) == -1 || v131 & 0x1F0000000000LL )
  {
    v114 = -1;
    v102 = _mm_load_si128((const __m128i *)&xmmword_172C0);
    *((_WORD *)dest + 8) = 51;
    *(__m128i *)dest = v102;
    return v114;
  }
  if ( (v131 & 0x800000000000LL) != 0 )
  {
    v114 = -1;
    *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_172D0);
    *((_QWORD *)dest + 2) = 7310577382524806176LL;
    *((_WORD *)dest + 12) = 100;
    return v114;
  }
  if ( v131 & 0x400000000000LL )
  {
    v114 = -1;
    v109 = _mm_load_si128((const __m128i *)&xmmword_172E0);
    *((_QWORD *)dest + 2) = 7234316346693281124LL;
    dest[24] = 0;
    *(__m128i *)dest = v109;
    return v114;
  }
  if ( v131 & 0x200000000000LL )
  {
    v114 = -1;
    *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_172F0);
    *((__m128i *)dest + 1) = _mm_load_si128((const __m128i *)&xmmword_17300);
    return v114;
  }
  if ( ((HIBYTE(v132) | v132 | HIBYTE(v131) | BYTE6(v131)) & 0x80u) != 0 )
  {
    v114 = -1;
    v111 = _mm_load_si128((const __m128i *)&xmmword_172C0);
    *((_QWORD *)dest + 2) = 8295740883037855795LL;
    *((_DWORD *)dest + 6) = 694516329;
    *(__m128i *)dest = v111;
    dest[28] = 0;
    return v114;
  }
  if ( v11 < ((unsigned __int8)v132 << 7) + HIBYTE(v132) + (HIBYTE(v131) << 14) + (BYTE6(v131) << 21) )
  {
    v114 = -1;
    v108 = _mm_load_si128((const __m128i *)&xmmword_17310);
    dest[16] = 0;
    *(__m128i *)dest = v108;
    return v114;
  }
  if ( v11 <= 9 )
    return 0;
  v122 = 0;
  v114 = 0;
  while ( 1 )
  {
    v14 = *(_QWORD *)v6;
    v15 = *(_WORD *)(v6 + 8);
    v10 = (unsigned __int8)*(_QWORD *)v6 == 0;
    v133 = *(_QWORD *)v6;
    v134 = v15;
    if ( v10 )
    {
      v16 = BYTE1(v133);
      if ( !BYTE1(v133) )
      {
        if ( BYTE2(v133) )
          goto LABEL_21;
        if ( !BYTE3(v133) )
          return v114;
      }
      v16 = 0;
    }
    else
    {
      v16 = v14;
    }
LABEL_21:
    v17 = 0LL;
    if ( (unsigned __int8)(v16 - 58) <= 6u )
    {
LABEL_25:
      *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_17320);
      *((_WORD *)dest + 8) = 31092;
      dest[18] = 0;
      return (unsigned int)-1;
    }
    while ( 1 )
    {
      if ( (unsigned __int8)(v16 - 48) > 0x2Au )
        goto LABEL_25;
      if ( ++v17 == 4 )
        break;
      v16 = *((_BYTE *)&v133 + v17);
      if ( (unsigned __int8)(v16 - 58) <= 6u )
        goto LABEL_25;
    }
    if ( HIBYTE(v134) )
    {
      v104 = _mm_load_si128((const __m128i *)&xmmword_17330);
      *((_QWORD *)dest + 2) = 7020098208707994721LL;
      *((_DWORD *)dest + 6) = 1702043751;
      *(__m128i *)dest = v104;
      *((_WORD *)dest + 14) = 116;
      return (unsigned int)-1;
    }
    if ( v117 )
    {
      v19 = BYTE4(v133) << 21;
      v20 = (BYTE6(v133) << 7) + HIBYTE(v133) + (BYTE5(v133) << 14);
    }
    else
    {
      v19 = BYTE4(v133) << 24;
      v20 = (BYTE6(v133) << 8) + HIBYTE(v133) + (BYTE5(v133) << 16);
    }
    v21 = v20 + v19;
    if ( !(v20 + v19) )
    {
      v103 = _mm_load_si128((const __m128i *)&xmmword_17340);
      *((_QWORD *)dest + 2) = 28259061315955809LL;
      *(__m128i *)dest = v103;
      return (unsigned int)-1;
    }
    v22 = v11 - 10;
    if ( v21 > v11 - 10 )
    {
      v105 = _mm_load_si128((const __m128i *)&xmmword_17350);
      *((_DWORD *)dest + 4) = 1685021216;
      *((_WORD *)dest + 10) = 121;
      *(__m128i *)dest = v105;
      return (unsigned int)-1;
    }
    v23 = (const void *)(v6 + 10);
    ptr = (char *)malloc(v21 + 4);
    v6 += v21 + 10LL;
    memcpy(ptr, v23, v21);
    v24 = (unsigned __int8)v14 < 0x54u;
    v25 = (_BYTE)v14 == 84;
    v116 = v22 - v21;
    v26 = &v133;
    if ( (_BYTE)v14 == 84 )
      break;
    v27 = "APIC";
    v28 = 4LL;
    do
    {
      if ( !v28 )
        break;
      v24 = *(_BYTE *)v26 < (const unsigned __int8)*v27;
      v25 = *(_BYTE *)v26 == *v27;
      v26 = (__int64 *)((char *)v26 + 1);
      ++v27;
      --v28;
    }
    while ( v25 );
    if ( (!v24 && !v25) == v24 )
    {
      if ( *ptr )
      {
        *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_173B0);
        *((_WORD *)dest + 16) = 103;
        *((__m128i *)dest + 1) = _mm_load_si128((const __m128i *)&xmmword_173C0);
        return (unsigned int)-1;
      }
      v72 = ptr + 1;
      v73 = v21 - 1;
      for ( i = ptr + 1; ; ++i )
      {
        if ( &ptr[v21 - 1 + 1] == i )
          goto LABEL_108;
        if ( !*i )
          break;
        --v73;
      }
      if ( v73 - 1 < 0 )
      {
LABEL_108:
        v75 = _mm_load_si128((const __m128i *)&xmmword_17370);
        *((_QWORD *)dest + 2) = 7883952608597144948LL;
        *((_DWORD *)dest + 6) = 2037653605;
        *(__m128i *)dest = v75;
        *((_WORD *)dest + 14) = 25968;
        dest[30] = 0;
        return (unsigned int)-1;
      }
      if ( v73 == 1 )
      {
        *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_17380);
        return (unsigned int)-1;
      }
      v82 = i[1];
      v83 = i + 2;
      v84 = (unsigned int)(v73 - 2);
      v85 = (signed __int64)&i[v84 + 2];
      do
      {
        LODWORD(v84) = v84 - 1;
        if ( (_BYTE *)v85 == v83 )
          goto LABEL_127;
        ++v83;
      }
      while ( *(v83 - 1) );
      if ( (signed int)v84 < 0 )
      {
LABEL_127:
        *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_17370);
        dest[32] = 0;
        *((__m128i *)dest + 1) = _mm_load_si128((const __m128i *)&xmmword_17390);
        return (unsigned int)-1;
      }
      if ( (signed int)v84 <= 1 )
      {
        *(__m128i *)dest = _mm_load_si128((const __m128i *)&xmmword_173A0);
        return (unsigned int)-1;
      }
      v86 = strstr(ptr + 1, "jpeg");
      v87 = ".jpg";
      if ( !v86 )
      {
        v96 = strstr(v72, "JPEG");
        v87 = ".jpg";
        if ( !v96 )
        {
          v97 = strstr(v72, "png");
          v87 = ".png";
          if ( !v97 )
          {
            v98 = strstr(v72, "PNG");
            v87 = ".png";
            if ( !v98 )
            {
              if ( *v83 == -1 )
              {
                v87 = "";
                if ( v83[1] == -40 )
                  v87 = ".jpg";
              }
              else
              {
                v87 = "";
                if ( *v83 == -119 && v83[1] == 80 )
                  v87 = ".png";
              }
            }
          }
        }
      }
      if ( v82 == 3 )
      {
LABEL_135:
        v88 = "Cover Art (Front)";
        v89 = 17;
        v122 = 1;
        goto LABEL_136;
      }
      if ( v82 == 4 )
      {
        v89 = 16;
        v88 = "Cover Art (Back)";
LABEL_136:
        v90 = v87;
        v91 = strlen(v87);
        v92 = v84 + v89 + v91 + 1;
        v93 = (char *)malloc((signed int)v92);
        v94 = v93;
        v95 = stpcpy(v93, v88);
        memcpy(v95, v90, v91 + 1);
        memcpy(&v94[(signed int)v92 - (signed __int64)(signed int)v84], v83, (signed int)v84);
        if ( v115 && !(unsigned int)WavpackAppendBinaryTagItem(v115, v88, v94, v92) )
          goto LABEL_156;
        ++v114;
        if ( v121 )
          *v121 += v92 + strlen(v88) + 1;
        free(v94);
        goto LABEL_38;
      }
      if ( (unsigned __int8)(v82 - 1) > 1u && !v122 )
        goto LABEL_135;
    }
LABEL_38:
    free(ptr);
    v11 = v116;
    if ( v116 <= 9 )
      return v114;
  }
  v29 = "TXXX";
  v30 = 4LL;
  do
  {
    if ( !v30 )
      break;
    v24 = *(_BYTE *)v26 < (const unsigned __int8)*v29;
    v25 = *(_BYTE *)v26 == *v29;
    v26 = (__int64 *)((char *)v26 + 1);
    ++v29;
    --v30;
  }
  while ( v25 );
  v123 = (char)((!v24 && !v25) - v24);
  if ( !*ptr )
  {
    v47 = &ptr[v21];
    v124 = v6;
    v48 = 0LL;
    v49 = ptr + 1;
    nmemb = 3 * v21;
    src = 3 * v21 - 1;
    while ( 1 )
    {
      v50 = v48;
      if ( (signed int)v48 > 1 || v49 >= v47 )
      {
        v6 = v124;
        goto LABEL_89;
      }
      v51 = *v49;
      if ( !*v49 )
        break;
      ++v49;
      v52 = (char *)malloc(nmemb);
      v53 = v52;
      (&v129)[v48] = v52;
      *v52 = v51;
      v54 = 1LL;
      do
      {
        v56 = (signed int)v54;
        if ( v47 == v49 )
        {
          v49 = v47;
LABEL_77:
          v53[v56] = 0;
          goto LABEL_78;
        }
        v55 = *(++v49 - 1);
        v53[v54++] = v55;
      }
      while ( v55 );
      if ( v47 == v49 )
        goto LABEL_77;
LABEL_78:
      v57 = calloc(nmemb, 1uLL);
      v125 = v57;
      v126 = v53;
      v128 = src;
      v127 = strlen(v53);
      v58 = iconv_open("UTF-8", "ISO-8859-1");
      v59 = v58;
      if ( v58 != (iconv_t)-1LL )
      {
        v60 = iconv(v58, &v126, &v127, (char **)&v125, (size_t *)&v128);
        iconv_close(v59);
        if ( v60 != -1 )
          memcpy(v53, v57, nmemb);
      }
      ++v48;
      free(v57);
    }
    v6 = v124;
    if ( !(_DWORD)v48 )
      goto LABEL_38;
    goto LABEL_110;
  }
  if ( *ptr != 1 )
  {
    v110 = _mm_load_si128((const __m128i *)&xmmword_17360);
    *((_QWORD *)dest + 2) = 7594317344498065522LL;
    *((_WORD *)dest + 12) = 26478;
    *(__m128i *)dest = v110;
    dest[26] = 0;
    return (unsigned int)-1;
  }
  v31 = 2 * v21;
  v32 = 0LL;
  v33 = (unsigned __int64)&ptr[v21 & 0xFFFFFFFFFFFFFFFELL];
  v34 = (unsigned __int64)(ptr + 1);
  size = 2 * v21;
  v35 = (unsigned __int16 *)malloc(v21);
  while ( 2 )
  {
    if ( v33 - 2 > v34 && *(_BYTE *)v34 == -1 && *(_BYTE *)(v34 + 1) == -2 )
    {
      v36 = (char *)malloc(size);
      v37 = (__int16 *)(v34 + 2);
      (&v129)[v32] = v36;
      if ( v33 > v34 + 2 )
      {
        v38 = (signed __int64)(v35 + 1);
        v39 = *(_WORD *)(v34 + 2);
        *v35 = v39;
        if ( !v39 )
        {
LABEL_120:
          v34 = (unsigned __int64)(v37 + 1);
LABEL_59:
          v41 = v35 + 1;
          v42 = 0;
LABEL_63:
          v43 = &v36[v42];
          if ( !v39 )
          {
LABEL_86:
            *v43 = 0;
            if ( v32 == 1 )
            {
              v61 = v35;
              v50 = 2;
              goto LABEL_88;
            }
            v32 = 1LL;
            continue;
          }
          if ( v39 <= 0x7Fu )
          {
            if ( v31 <= v42 + 1 )
              goto LABEL_82;
            *v43 = v39;
            ++v42;
          }
          else
          {
            if ( v39 > 0x7FFu )
              goto LABEL_66;
LABEL_82:
            v44 = v42 + 2;
            if ( v31 <= v42 + 2 )
            {
LABEL_66:
              v44 = v42 + 3;
              if ( v31 <= v42 + 3 )
                goto LABEL_86;
              *v43 = (v39 >> 12) | 0xE0;
              v45 = v42 + 1;
              v46 = v42 + 2;
              v36[v45] = (v39 >> 6) & 0x3F | 0x80;
            }
            else
            {
              v46 = v42 + 1;
              *v43 = (v39 >> 6) | 0xC0;
            }
            v36[v46] = v39 & 0x3F | 0x80;
            v42 = v44;
          }
          v39 = *v41;
          ++v41;
          goto LABEL_63;
        }
        while ( 1 )
        {
          ++v37;
          if ( v33 <= (unsigned __int64)v37 )
            break;
          v38 += 2LL;
          v40 = *v37;
          *(_WORD *)(v38 - 2) = *v37;
          if ( !v40 )
          {
            v39 = *v35;
            goto LABEL_120;
          }
        }
      }
      v39 = *v35;
      v34 = (unsigned __int64)v37;
      goto LABEL_59;
    }
    break;
  }
  v61 = v35;
  v50 = v32;
LABEL_88:
  free(v61);
LABEL_89:
  if ( !v50 )
    goto LABEL_38;
  if ( v123 || v50 != 2 )
  {
LABEL_110:
    v76 = (const char **)off_218748;
    v77 = "TALB";
    v78 = v114;
    while ( 1 )
    {
      if ( !strncmp((const char *)&v133, v77, 4uLL) )
      {
        if ( v115 )
        {
          v79 = v129;
          v80 = strlen(v129);
          if ( !(unsigned int)WavpackAppendTagItem(v115, *v76, v79, v80) )
            goto LABEL_156;
        }
        ++v78;
        if ( v121 )
        {
          v81 = strlen(v129);
          *v121 += strlen(*v76) + v81 + 1;
        }
      }
      v76 += 2;
      if ( &off_218748[52] == (char **)v76 )
        break;
      v77 = *(v76 - 1);
    }
    v114 = v78;
LABEL_101:
    v71 = v50 - 1;
    free((&v129)[v71]);
    if ( v71 )
      free(v129);
    goto LABEL_38;
  }
  v62 = v129;
  v63 = (unsigned __int8)*v129;
  v64 = (v63 & 0x80u) != 0LL;
  if ( (_BYTE)v63 )
  {
    v65 = v129;
    while ( !v64 )
    {
      v64 = *++v65 < 0;
      if ( !*v65 )
        goto LABEL_96;
    }
  }
  else
  {
LABEL_96:
    v66 = __ctype_b_loc();
    v67 = *v66;
    if ( (*v66)[v63] & 0x100 )
    {
      v99 = v62;
      while ( 1 )
      {
        v100 = *++v99;
        if ( !*v99 )
          break;
        while ( v67[v100] & 0x100 )
        {
          *(++v99 - 1) = (*__ctype_tolower_loc())[v100];
          v100 = *v99;
          if ( !*v99 )
            goto LABEL_97;
        }
      }
    }
  }
LABEL_97:
  if ( !v115 || (v68 = s, v69 = strlen(s), (unsigned int)WavpackAppendTagItem(v115, v62, v68, v69)) )
  {
    ++v114;
    if ( v121 )
    {
      v70 = strlen(v62);
      *v121 += strlen(s) + v70 + 1;
    }
    goto LABEL_101;
  }
LABEL_156:
  v101 = (const char *)WavpackGetErrorMessage(v115);
  strcpy(dest, v101);
  return (unsigned int)-1;
}
// 3000: using guessed type __int64  WavpackAppendTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 31E0: using guessed type __int64  WavpackAppendBinaryTagItem(_QWORD, _QWORD, _QWORD, _QWORD);
// 31F0: using guessed type __int64  WavpackGetErrorMessage(_QWORD);
// 172A0: using guessed type __int128 xmmword_172A0;
// 172B0: using guessed type __int128 xmmword_172B0;
// 172C0: using guessed type __int128 xmmword_172C0;
// 172D0: using guessed type __int128 xmmword_172D0;
// 172E0: using guessed type __int128 xmmword_172E0;
// 172F0: using guessed type __int128 xmmword_172F0;
// 17300: using guessed type __int128 xmmword_17300;
// 17310: using guessed type __int128 xmmword_17310;
// 17320: using guessed type __int128 xmmword_17320;
// 17330: using guessed type __int128 xmmword_17330;
// 17340: using guessed type __int128 xmmword_17340;
// 17350: using guessed type __int128 xmmword_17350;
// 17360: using guessed type __int128 xmmword_17360;
// 17370: using guessed type __int128 xmmword_17370;
// 17380: using guessed type __int128 xmmword_17380;
// 17390: using guessed type __int128 xmmword_17390;
// 173A0: using guessed type __int128 xmmword_173A0;
// 173B0: using guessed type __int128 xmmword_173B0;
// 173C0: using guessed type __int128 xmmword_173C0;
// 218748: using guessed type char *off_218748[2];

//----- (0000000000012820) ----------------------------------------------------
__int64  sub_12820(__int64 a1, unsigned __int64 a2, signed int a3, __int64 a4, _DWORD *a5)
{
  __int64 v5; // r14
  unsigned int v6; // er12
  _BYTE *v7; // rbx
  _DWORD *v8; // rbp
  unsigned __int64 v9; // rdx
  signed __int64 v10; // rax
  unsigned int v11; // er13
  int v12; // er9
  int v14; // eax

  v5 = a4;
  v6 = a3;
  v7 = (_BYTE *)a2;
  v8 = a5;
  if ( a5 )
    *a5 = 0;
  if ( a3 <= 9 )
    goto LABEL_24;
  v9 = a2 + a3;
  v10 = v9 - 10;
  if ( v9 - 10 > a2 )
  {
    while ( *v7 != 73 || v7[1] != 68 || v7[2] != 51 || v7[3] != 3 )
    {
      if ( (_BYTE *)v10 == ++v7 )
        goto LABEL_18;
    }
    v6 = v9 - (_DWORD)v7;
  }
  if ( (_BYTE *)v10 == v7 )
  {
LABEL_18:
    v11 = 0;
  }
  else
  {
LABEL_24:
    v11 = sub_11980(0LL, (__int64)v7, v6, a4, a5, 0);
    if ( (signed int)v11 <= 0 )
    {
      v14 = sub_11980(0LL, (__int64)v7, v6, v5, v8, 1);
      if ( v14 > 0 )
      {
        if ( a1 )
        {
          v12 = 1;
          return sub_11980(a1, (__int64)v7, v6, v5, v8, v12);
        }
        v11 = v14;
      }
    }
    else
    {
      v12 = 0;
      if ( a1 )
        return sub_11980(a1, (__int64)v7, v6, v5, v8, v12);
    }
  }
  return v11;
}

//----- (0000000000012930) ----------------------------------------------------
void  init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  signed __int64 v4; // rbp
  __int64 v5; // rbx

  v3 = a3;
  v4 = &off_218218 - off_218210;
  init_proc();
  if ( v4 )
  {
    v5 = 0LL;
    do
      ((void ( *)(_QWORD, __int64, __int64))off_218210[v5++])(a1, a2, v3);
    while ( v4 != v5 );
  }
}
// 218210: using guessed type __int64 ( *off_218210[2])();
// 218218: using guessed type __int64 ( *off_218218)();

//----- (00000000000129B0) ----------------------------------------------------
int  sub_129B0(char *filename, struct stat *stat_buf)
{
  return __xstat(1, filename, stat_buf);
}

//----- (00000000000129C0) ----------------------------------------------------
int  sub_129C0(int fildes, struct stat *stat_buf)
{
  return __fxstat(1, fildes, stat_buf);
}

//----- (00000000000129D0) ----------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 49 function(s) have been successfully decompiled
