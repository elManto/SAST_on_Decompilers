#include <stdio.h>

/* WARNING: Could not reconcile some variable overlaps */

Bool bdfReadCharacters(FontFilePtr file,FontPtr pFont,bdfFileState *pState,int bit,int byte,
                      int glyph,int scan)

{
  uint uVar1;
  ushort uVar2;
  void *pvVar3;
  long lVar4;
  void **ppvVar5;
  long lVar6;
  short sVar7;
  uchar uVar8;
  byte bVar9;
  byte bVar10;
  short sVar11;
  int nbytes;
  uint uVar12;
  int iVar13;
  Bool BVar14;
  int iVar15;
  int iVar16;
  uchar *__s;
  void *pvVar17;
  byte *__s_00;
  Atom AVar18;
  CharInfoPtr p_Var19;
  uchar *puVar20;
  long lVar21;
  uint *puVar22;
  uint *puVar23;
  ulong uVar24;
  CharInfoPtr p_Var25;
  uint uVar26;
  int iVar27;
  ulong uVar28;
  CharInfoPtr *pp_Var29;
  uchar *puVar30;
  CharInfoPtr *pp_Var31;
  byte *pbVar32;
  uint uVar33;
  short sVar34;
  ulong uVar35;
  char cVar36;
  ushort uVar37;
  byte *s;
  long in_FS_OFFSET;
  bool bVar38;
  bool bVar39;
  bool bVar40;
  byte bVar41;
  void **local_1198;
  short *local_1168;
  uchar *local_1158;
  int local_1150;
  char *local_1148;
  uint local_1140;
  uchar *local_1138;
  uint local_1130;
  int local_112c;
  int local_1108;
  int local_1104;
  int nchars;
  int wx;
  int wy;
  int bw;
  int bh;
  int bl;
  int bb;
  int enc;
  int enc2;
  CharInfoPtr *bdfEncoding [256];
  char charName [100];
  uchar lineBuf [1024];
  uchar lineBuf_1 [1024];
  
  bVar41 = 0;
  pvVar3 = pFont->fontPrivate;
  lVar4 = *(long *)(in_FS_OFFSET + 0x28);
  ppvVar5 = *(void ***)((long)pvVar3 + 0x38);
  local_1198 = (void **)0x0;
  if (ppvVar5 != (void **)0x0) {
    local_1198 = ppvVar5 + 2;
    ppvVar5[2] = (void *)0x0;
    ppvVar5[3] = (void *)0x0;
  }
  pp_Var29 = (CharInfoPtr *)bdfEncoding;
  lVar21 = 0x100;
  *(undefined8 *)((long)pvVar3 + 0x10) = 0;
  pp_Var31 = pp_Var29;
  while (lVar21 != 0) {
    lVar21 = lVar21 + -1;
    *pp_Var31 = (CharInfoPtr)0x0;
    pp_Var31 = pp_Var31 + 1;
  }
  __s = bdfGetLine(file,lineBuf,0x400);
  if ((__s == (uchar *)0x0) || (nbytes = sscanf((char *)__s,"CHARS %d",&nchars), nbytes != 1)) {
    bdfError("bad \'CHARS\' in bdf file\n");
    BVar14 = 0;
    goto LAB_001193d7;
  }
  if (nchars < 1) {
    bdfError("invalid number of CHARS in BDF file\n");
    BVar14 = 0;
    goto LAB_001193d7;
  }
  if (nchars < 0x5555556) {
    local_1168 = (short *)calloc((long)nchars,0x18);
    if (local_1168 == (short *)0x0) {
      bdfEncoding[0] = (CharInfoPtr *)0x0;
      bdfError("Couldn\'t allocate pCI (%d*%d)\n",(ulong)(uint)nchars,0x18);
    }
    else {
      *(short **)((long)pvVar3 + 0x10) = local_1168;
      if (ppvVar5 != (void **)0x0) {
        pvVar17 = malloc((long)nchars << 3);
        *ppvVar5 = pvVar17;
        if (pvVar17 == (void *)0x0) {
          bdfEncoding[0] = (CharInfoPtr *)0x0;
          bdfError("Couldn\'t allocate glyphNames (%d*%d)\n",(ulong)(uint)nchars,8);
          goto LAB_0011942c;
        }
        pvVar17 = malloc((long)nchars << 2);
        ppvVar5[1] = pvVar17;
        if (pvVar17 == (void *)0x0) {
          bdfError("Couldn\'t allocate sWidth (%d *%d)\n",(ulong)(uint)nchars,4);
          BVar14 = 0;
          goto LAB_001193d7;
        }
      }
      __s_00 = bdfGetLine(file,lineBuf,0x400);
      uVar24 = (ulong)(uint)nchars;
      *(undefined8 *)&pFont->info = 0x10000000100;
      if (nchars < 1) {
        uVar28 = 0;
        local_112c = 0;
        local_1150 = 0;
LAB_0011a23a:
        if ((int)uVar28 == (int)uVar24) {
          nchars = local_1150;
          bVar40 = false;
          bVar38 = __s_00 == (byte *)0x0;
          *(int *)((long)pvVar3 + 4) = local_1150;
          if (bVar38) {
LAB_0011992f:
            bdfError("missing \'ENDFONT\'\n");
          }
          else {
LAB_0011a1c3:
            local_1148 = "STARTCHAR";
            lVar21 = 9;
            s = __s_00;
            do {
              if (lVar21 == 0) break;
              lVar21 = lVar21 + -1;
              bVar40 = *s < (byte)*local_1148;
              bVar38 = *s == *local_1148;
              s = s + (ulong)bVar41 * -2 + 1;
              local_1148 = (char *)((byte *)local_1148 + (ulong)bVar41 * -2 + 1);
            } while (bVar38);
            bVar39 = false;
            bVar40 = (!bVar40 && !bVar38) == bVar40;
            nchars = local_1150;
            if (bVar40) {
              bdfError("more characters than specified\n");
            }
            else {
              lVar21 = 7;
              s = (byte *)"ENDFONT";
              do {
                if (lVar21 == 0) break;
                lVar21 = lVar21 + -1;
                bVar39 = *__s_00 < *s;
                bVar40 = *__s_00 == *s;
                __s_00 = __s_00 + (ulong)bVar41 * -2 + 1;
                s = s + (ulong)bVar41 * -2 + 1;
              } while (bVar40);
              cVar36 = (!bVar39 && !bVar40) - bVar39;
              nbytes = (int)cVar36;
              if (cVar36 != '\0') goto LAB_0011992f;
              if (local_112c == 0) {
                bdfWarning("No characters with valid encodings\n");
              }
              iVar15 = (((uint)(pFont->info).lastRow - (uint)(pFont->info).firstRow) + 1) *
                       (((uint)(pFont->info).lastCol - (uint)(pFont->info).firstCol) + 1);
              iVar16 = iVar15 + 0x7f;
              if (iVar16 < 0) {
                iVar16 = iVar15 + 0xfe;
              }
              pvVar17 = calloc((long)(iVar16 >> 7),8);
              *(void **)((long)pvVar3 + 0x28) = pvVar17;
              if (pvVar17 != (void *)0x0) {
                uVar37 = (pFont->info).firstRow;
                uVar24 = (ulong)uVar37;
                uVar2 = (pFont->info).lastRow;
                uVar28 = (ulong)uVar2;
                __s_00 = (byte *)&(pFont->info).field_0xa;
                *__s_00 = *__s_00 | 0x40;
                if (uVar37 <= uVar2) {
                  pp_Var31 = pp_Var29 + uVar24;
                  do {
                    p_Var19 = *pp_Var31;
                    uVar37 = (pFont->info).lastCol;
                    uVar2 = (pFont->info).firstCol;
                    if (p_Var19 == (CharInfoPtr)0x0) {
                      __s_00 = (byte *)&(pFont->info).field_0xa;
                      *__s_00 = *__s_00 & 0xbf;
                      nbytes = nbytes + 1 + ((uint)uVar37 - (uint)uVar2);
                    }
                    else {
                      if (uVar2 <= uVar37) {
                        lVar21 = (ulong)uVar2 * 8;
                        iVar16 = (uint)uVar2 - nbytes;
                        while( true ) {
                          lVar6 = *(long *)((long)&(p_Var19->metrics).leftSideBearing + lVar21);
                          if (lVar6 == 0) {
                            __s_00 = (byte *)&(pFont->info).field_0xa;
                            *__s_00 = *__s_00 & 0xbf;
                          }
                          else {
                            iVar15 = nbytes + 0x7f;
                            if (-1 < nbytes) {
                              iVar15 = nbytes;
                            }
                            ppvVar5 = (void **)(*(long *)((long)pvVar3 + 0x28) +
                                               (long)(iVar15 >> 7) * 8);
                            pvVar17 = *ppvVar5;
                            if (pvVar17 == (void *)0x0) {
                              pvVar17 = calloc(0x80,8);
                              *ppvVar5 = pvVar17;
                              pvVar17 = *(void **)(*(long *)((long)pvVar3 + 0x28) +
                                                  (long)(iVar15 >> 7) * 8);
                              if (pvVar17 == (void *)0x0) goto LAB_0011942c;
                            }
                            uVar26 = (uint)(nbytes >> 0x1f) >> 0x19;
                            *(long *)((long)pvVar17 +
                                     (long)(int)((nbytes + uVar26 & 0x7f) - uVar26) * 8) = lVar6;
                          }
                          nbytes = nbytes + 1;
                          lVar21 = lVar21 + 8;
                          if ((uint)(pFont->info).lastCol < (uint)(iVar16 + nbytes)) break;
                          p_Var19 = *pp_Var31;
                        }
                        uVar28 = (ulong)(pFont->info).lastRow;
                      }
                    }
                    uVar26 = (int)uVar24 + 1;
                    uVar24 = (ulong)uVar26;
                    pp_Var31 = pp_Var31 + 1;
                  } while (uVar26 <= (uint)uVar28);
                }
                do {
                  if (*pp_Var29 != (CharInfoPtr)0x0) {
                    free(*pp_Var29);
                  }
                  pp_Var29 = pp_Var29 + 1;
                } while ((CharInfoPtr *)charName != pp_Var29);
                BVar14 = 1;
                goto LAB_001193d7;
              }
              bdfError("Couldn\'t allocate ppCI (%d,%d)\n",(ulong)(uint)(iVar16 >> 7),8);
            }
          }
          goto LAB_0011942c;
        }
      }
      else {
        bVar40 = __s_00 == (byte *)0x0;
        if (bVar40) {
          bdfEncoding[0] = (CharInfoPtr *)0x0;
          uVar28 = 0;
        }
        else {
          local_112c = 0;
          local_1108 = 0;
          local_1150 = 0;
          local_1148 = "STARTCHAR";
          do {
            bVar38 = false;
            lVar21 = 9;
            s = __s_00;
            pbVar32 = (byte *)local_1148;
            do {
              if (lVar21 == 0) break;
              lVar21 = lVar21 + -1;
              bVar38 = *s < *pbVar32;
              bVar40 = *s == *pbVar32;
              s = s + (ulong)bVar41 * -2 + 1;
              pbVar32 = pbVar32 + (ulong)bVar41 * -2 + 1;
            } while (bVar40);
            uVar26 = SEXT14((char)((!bVar38 && !bVar40) - bVar38));
            uVar28 = (ulong)uVar26;
            if (uVar26 != 0) {
              uVar26 = local_1108 + local_1150;
              uVar28 = (ulong)uVar26;
              bVar40 = uVar26 < (uint)uVar24;
              bVar38 = uVar26 == (uint)uVar24;
              if (!bVar38) goto LAB_0011a117;
              *(int *)((long)pvVar3 + 4) = local_1150;
              goto LAB_0011a1c3;
            }
            nbytes = sscanf((char *)__s_00,"STARTCHAR %s",charName);
            if (nbytes != 1) {
              bdfError("bad character name in BDF file\n");
              goto LAB_0011942c;
            }
            if (ppvVar5 != (void **)0x0) {
              pvVar17 = *ppvVar5;
              AVar18 = bdfForceMakeAtom(charName,(int *)0x0);
              *(Atom *)((long)pvVar17 + (long)local_1150 * 8) = AVar18;
            }
            __s = bdfGetLine(file,lineBuf,0x400);
            if ((__s == (uchar *)0x0) ||
               (nbytes = sscanf((char *)__s,"ENCODING %d %d",&enc,&enc2), nbytes < 1)) {
              bdfError("bad \'ENCODING\' in BDF file\n");
              goto LAB_0011942c;
            }
            uVar24 = (ulong)(uint)enc;
            if (enc < -1) {
LAB_0011a12e:
              bdfError("bad ENCODING value");
              goto LAB_0011942c;
            }
            if (nbytes == 2) {
              if (enc2 < -1) goto LAB_0011a12e;
              if (enc == -1) {
                uVar24 = (ulong)(uint)enc2;
                enc = enc2;
                goto LAB_001195f9;
              }
LAB_00119602:
              if ((int)uVar24 < 0x10000) {
                uVar35 = uVar24 & 0xff;
                uVar26 = (int)uVar24 >> 8;
                uVar37 = (ushort)(uVar24 >> 8);
                if (uVar26 < (pFont->info).firstRow) {
                  (pFont->info).firstRow = uVar37;
                }
                if ((pFont->info).lastRow < uVar26) {
                  (pFont->info).lastRow = uVar37;
                }
                if ((uint)uVar35 < (uint)(pFont->info).firstCol) {
                  (pFont->info).firstCol = (ushort)uVar35;
                }
                if ((uint)(pFont->info).lastCol < (uint)uVar35) {
                  (pFont->info).lastCol = (ushort)uVar35;
                }
                p_Var19 = (CharInfoPtr)bdfEncoding[uVar26];
                if (p_Var19 == (CharInfoPtr)0x0) {
                  p_Var19 = (CharInfoPtr)malloc(0x800);
                  *(CharInfoPtr *)(bdfEncoding + uVar26) = p_Var19;
                  if (p_Var19 == (CharInfoPtr)0x0) {
                    bdfError("Couldn\'t allocate row %d of encoding (%d*%d)\n",(ulong)uVar26,0x100,8
                            );
                    goto LAB_0011942c;
                  }
                  p_Var25 = p_Var19;
                  do {
                    *(undefined8 *)&p_Var25->metrics = 0;
                    p_Var25 = (CharInfoPtr)&(p_Var25->metrics).descent;
                  } while (p_Var25 != (CharInfoPtr)&p_Var19[0x55].metrics.descent);
                }
                local_112c = local_112c + 1;
                *(short **)((long)&p_Var19->metrics + uVar35 * 8) = local_1168;
              }
              else {
                bdfError("char \'%s\' has encoding too large (%d)\n",charName);
              }
            }
            else {
LAB_001195f9:
              if ((int)uVar24 != -1) goto LAB_00119602;
              if (ppvVar5 == (void **)0x0) {
                local_1108 = local_1108 + 1;
                uVar28 = 1;
              }
            }
            __s = bdfGetLine(file,lineBuf,0x400);
            if (__s == (uchar *)0x0) {
LAB_0011a081:
              bdfError("bad \'SWIDTH\'\n");
              goto LAB_0011942c;
            }
            nbytes = sscanf((char *)__s,"SWIDTH %d %d",&wx);
            if (nbytes != 2) goto LAB_0011a081;
            if (wy != 0) {
              bdfError("SWIDTH y value must be zero\n");
              goto LAB_0011942c;
            }
            if (ppvVar5 != (void **)0x0) {
              *(int *)((long)ppvVar5[1] + (long)local_1150 * 4) = wx;
            }
            __s = bdfGetLine(file,lineBuf,0x400);
            if ((__s == (uchar *)0x0) ||
               (nbytes = sscanf((char *)__s,"DWIDTH %d %d",&wx,&wy), nbytes != 2)) {
              bdfError("bad \'DWIDTH\'\n");
              goto LAB_0011942c;
            }
            if (wy != 0) {
              bdfError("DWIDTH y value must be zero\n");
              goto LAB_0011942c;
            }
            __s = bdfGetLine(file,lineBuf,0x400);
            if ((__s == (uchar *)0x0) ||
               (nbytes = sscanf((char *)__s,"BBX %d %d %d %d",&bw), nbytes != 4)) {
              bdfError("bad \'BBX\'\n");
              goto LAB_0011942c;
            }
            if ((bh < 0) || (bw < 0)) {
              bdfError("character \'%s\' has a negative sized bitmap, %dx%d\n",charName);
              goto LAB_0011942c;
            }
            __s_00 = bdfGetLine(file,lineBuf,0x400);
            bVar40 = false;
            bVar38 = __s_00 == (byte *)0x0;
            if (bVar38) {
LAB_001197ea:
              local_1168[5] = 0;
            }
            else {
              lVar21 = 10;
              s = __s_00;
              pbVar32 = (byte *)"ATTRIBUTES";
              do {
                if (lVar21 == 0) break;
                lVar21 = lVar21 + -1;
                bVar40 = *s < *pbVar32;
                bVar38 = *s == *pbVar32;
                s = s + (ulong)bVar41 * -2 + 1;
                pbVar32 = pbVar32 + (ulong)bVar41 * -2 + 1;
              } while (bVar38);
              if ((!bVar40 && !bVar38) != bVar40) goto LAB_001197ea;
              s = __s_00 + 0xb;
              if ((__s_00[0xb] == 9) || (__s_00[0xb] == 0x20)) {
                do {
                  do {
                    s = s + 1;
                  } while (*s == 0x20);
                } while (*s == 9);
              }
              bVar9 = bdfHexByte(s);
              bVar10 = bdfHexByte(s + 2);
              local_1168[5] = (ushort)bVar10 + (ushort)bVar9 * 0x100;
              __s_00 = bdfGetLine(file,lineBuf,0x400);
            }
            bVar40 = false;
            bVar38 = __s_00 == (byte *)0x0;
            if (bVar38) {
LAB_0011a141:
              bdfError("missing \'BITMAP\'\n");
              goto LAB_0011942c;
            }
            lVar21 = 6;
            s = (byte *)"BITMAP";
            do {
              if (lVar21 == 0) break;
              lVar21 = lVar21 + -1;
              bVar40 = *__s_00 < *s;
              bVar38 = *__s_00 == *s;
              __s_00 = __s_00 + (ulong)bVar41 * -2 + 1;
              s = s + (ulong)bVar41 * -2 + 1;
            } while (bVar38);
            cVar36 = (!bVar40 && !bVar38) - bVar40;
            nbytes = (int)cVar36;
            puVar23 = (uint *)charName;
            if (cVar36 != '\0') goto LAB_0011a141;
            do {
              puVar22 = puVar23;
              uVar26 = *puVar22 + 0xfefefeff & ~*puVar22;
              uVar12 = uVar26 & 0x80808080;
              bVar9 = (byte)uVar12;
              puVar23 = puVar22 + 1;
            } while (uVar12 == 0);
            bVar40 = (uVar26 & 0x8080) == 0;
            if (bVar40) {
              bVar9 = (byte)(uVar12 >> 0x10);
            }
            if (bVar40) {
              puVar23 = (uint *)((long)puVar22 + 6);
            }
            if ((long)puVar23 + ((-3 - (ulong)CARRY1(bVar9,bVar9)) - (long)charName) == 1) {
              if ((byte)(charName[0] - 0x30U) < 10) {
                pState->digitCount = pState->digitCount + 1;
                pState->digitWidths = pState->digitWidths + wx;
              }
              else {
                if (charName[0] == 'x') {
                  iVar16 = bb + bh;
                  if (bb + bh < 1) {
                    iVar16 = bh;
                  }
                  pState->exHeight = iVar16;
                }
              }
            }
            if ((int)uVar28 == 0) {
              sVar7 = (short)bl;
              sVar34 = (short)bh + (short)bb;
              sVar11 = -(short)bb;
              *local_1168 = sVar7;
              local_1168[1] = (short)bw + sVar7;
              local_1168[3] = sVar34;
              local_1168[4] = sVar11;
              nbytes = (int)(short)((short)bw + sVar7) - (int)sVar7;
              uVar26 = (int)sVar11 + (int)sVar34;
              local_1168[2] = (short)wx;
              *(undefined8 *)(local_1168 + 8) = 0;
              if (glyph == 1) {
                local_1140 = nbytes + 7 >> 3;
LAB_00119b70:
                local_1104 = uVar26 * local_1140;
                if (local_1104 < 1) {
                  local_1158 = (uchar *)0x0;
                  goto LAB_001199ed;
                }
                local_1158 = (uchar *)malloc((long)local_1104);
                if (local_1158 != (uchar *)0x0) goto LAB_001199ed;
                bdfError("Couldn\'t allocate picture (%d*%d)\n",(ulong)local_1140,(ulong)uVar26);
LAB_00119bb2:
                *(undefined8 *)(local_1168 + 8) = 0;
              }
              else {
                if (glyph == 2) {
                  local_1140 = nbytes + 0xf >> 3 & 0xfffffffe;
                  goto LAB_00119b70;
                }
                if (glyph == 4) {
                  local_1140 = nbytes + 0x1f >> 3 & 0xfffffffc;
                  goto LAB_00119b70;
                }
                if (glyph == 8) {
                  local_1140 = nbytes + 0x3f >> 3 & 0xfffffff8;
                  goto LAB_00119b70;
                }
                local_1104 = 0;
                local_1140 = 0;
                local_1158 = (uchar *)0x0;
LAB_001199ed:
                *(uchar **)(local_1168 + 8) = local_1158;
                if (local_1198 != (void **)0x0) {
                  lVar21 = 0;
                  uVar33 = nbytes + 7 >> 3;
                  iVar16 = *(int *)local_1198;
                  uVar12 = uVar33;
                  do {
                    *(uint *)((long)local_1198 + lVar21 * 4) = iVar16 + uVar12 * uVar26;
                    while( true ) {
                      lVar21 = lVar21 + 1;
                      iVar16 = *(int *)((long)local_1198 + lVar21 * 4);
                      uVar12 = uVar33;
                      if (((lVar21 == 0) ||
                          (iVar15 = (int)lVar21, uVar12 = nbytes + 0xf >> 3 & 0xfffffffe,
                          iVar15 == 1)) || (uVar12 = nbytes + 0x1f >> 3 & 0xfffffffc, iVar15 == 2))
                      break;
                      *(uint *)((long)local_1198 + lVar21 * 4) =
                           iVar16 + (nbytes + 0x3f >> 3 & 0xfffffff8U) * uVar26;
                      if (iVar15 == 3) goto LAB_00119bf2;
                    }
                  } while( true );
                }
LAB_00119bf2:
                iVar16 = nbytes + 7 >> 3;
                if ((int)uVar26 < 1) {
                  if (uVar26 == 0) {
                    uVar28 = 0;
                    goto LAB_00119e7a;
                  }
LAB_00119e98:
                  bdfError("missing \'ENDCHAR\'\n");
BAILOUT:
                  if (local_1158 != (uchar *)0x0) {
                    free(local_1158);
                  }
                  goto LAB_00119bb2;
                }
                local_1130 = 0;
                uVar12 = 0xff << (8 - ((byte)nbytes & 7) & 0x1f);
                bVar9 = (byte)uVar12;
                uVar33 = (local_1140 - iVar16) - 1;
                __s = local_1158 + 1;
                do {
                  __s_00 = bdfGetLine(file,lineBuf_1,0x400);
                  if (__s_00 == (byte *)0x0) goto LAB_00119e98;
                  bVar40 = false;
                  bVar38 = nbytes == 0;
                  if (bVar38) {
                    lVar21 = 7;
                    s = __s_00;
                    pbVar32 = (byte *)"ENDCHAR";
                    do {
                      if (lVar21 == 0) break;
                      lVar21 = lVar21 + -1;
                      bVar40 = *s < *pbVar32;
                      bVar38 = *s == *pbVar32;
                      s = s + (ulong)bVar41 * -2 + 1;
                      pbVar32 = pbVar32 + (ulong)bVar41 * -2 + 1;
                    } while (bVar38);
                    bVar40 = (!bVar40 && !bVar38) == bVar40;
                    if (bVar40) goto LAB_00119ccc;
                  }
                  else {
                    _iVar13 = strlen((char *)__s_00);
                    iVar13 = (int)_iVar13;
                    iVar15 = iVar13;
                    if ((_iVar13 & 1) != 0) {
                      bdfError("odd number of characters in hex encoding\n");
                      iVar15 = iVar13 + 1;
                      __s_00[iVar13] = 0x30;
                      __s_00[iVar15] = 0;
                    }
                    iVar15 = iVar15 >> 1;
                    iVar13 = iVar15;
                    if (iVar16 <= iVar15) {
                      iVar13 = iVar16;
                    }
                    if (0 < iVar13) {
                      iVar27 = (int)uVar28;
                      puVar20 = local_1158 + (long)iVar27;
                      s = __s_00;
                      do {
                        puVar30 = puVar20 + 1;
                        uVar8 = bdfHexByte(s);
                        *puVar20 = uVar8;
                        puVar20 = puVar30;
                        s = s + 2;
                      } while (puVar30 != __s + (ulong)(iVar13 - 1U) + (long)iVar27);
                      uVar28 = (ulong)(iVar27 + 1 + (iVar13 - 1U));
                    }
                    iVar13 = (int)uVar28;
                    if (iVar15 < iVar16) {
                      if (0 < iVar16 - iVar15) {
                        uVar1 = (iVar16 - iVar15) - 1;
                        puVar20 = local_1158 + (long)iVar13;
                        do {
                          *puVar20 = '\0';
                          puVar20 = puVar20 + 1;
                        } while (puVar20 != __s + (long)iVar13 + (ulong)uVar1);
                        uVar28 = (ulong)(iVar13 + 1 + uVar1);
                      }
                    }
                    else {
                      if (bVar9 != 0) {
                        bVar10 = local_1158[(long)iVar13 + -1];
                        if ((~(uVar12 & 0xff) & (uint)bVar10) != 0) {
                          local_1158[(long)iVar13 + -1] = bVar10 & bVar9;
                        }
                      }
                    }
                    if ((iVar16 < (int)local_1140) && (0 < (int)(local_1140 - iVar16))) {
                      iVar15 = (int)uVar28;
                      puVar20 = local_1158 + (long)iVar15;
                      do {
                        *puVar20 = '\0';
                        puVar20 = puVar20 + 1;
                      } while (__s + (long)iVar15 + (ulong)uVar33 != puVar20);
                      uVar28 = (ulong)(iVar15 + 1 + uVar33);
                    }
                  }
                  local_1130 = local_1130 + 1;
                } while (uVar26 != local_1130);
                nbytes = strncmp((char *)__s_00,"ENDCHAR",7);
                bVar40 = nbytes == 0;
                if (!bVar40) {
LAB_00119e7a:
                  local_1138 = lineBuf_1;
                  __s_00 = bdfGetLine(file,local_1138,0x400);
                  bVar40 = __s_00 == (byte *)0x0;
                  if (bVar40) goto LAB_00119e98;
                }
LAB_00119ccc:
                bVar38 = false;
                lVar21 = 7;
                s = (byte *)"ENDCHAR";
                do {
                  if (lVar21 == 0) break;
                  lVar21 = lVar21 + -1;
                  bVar38 = *__s_00 < *s;
                  bVar40 = *__s_00 == *s;
                  __s_00 = __s_00 + (ulong)bVar41 * -2 + 1;
                  s = s + (ulong)bVar41 * -2 + 1;
                } while (bVar40);
                if ((!bVar38 && !bVar40) != bVar38) goto LAB_00119e98;
                nbytes = (int)uVar28;
                if (nbytes != local_1104) {
                  bdfError("bytes != rows * bytes_per_row (%d != %d * %d)\n",uVar28,(ulong)uVar26);
                  goto BAILOUT;
                }
                if (local_1158 != (uchar *)0x0) {
                  if (bit == 0) {
                    BitOrderInvert(local_1158,nbytes);
                  }
                  if (bit != byte) {
                    if (scan == 2) {
                      TwoByteSwap(local_1158,nbytes);
                    }
                    else {
                      if (scan == 4) {
                        FourByteSwap(local_1158,nbytes);
                      }
                    }
                  }
                }
              }
              local_1168 = local_1168 + 0xc;
              local_1150 = local_1150 + 1;
            }
            else {
              do {
                __s_00 = bdfGetLine(file,lineBuf_1,0x400);
                nbytes = nbytes + 1;
                bVar40 = false;
                bVar38 = __s_00 == (byte *)0x0;
                if (bVar38) goto LAB_001198d3;
                lVar21 = 7;
                s = (byte *)"ENDCHAR";
                do {
                  if (lVar21 == 0) break;
                  lVar21 = lVar21 + -1;
                  bVar40 = *__s_00 < *s;
                  bVar38 = *__s_00 == *s;
                  __s_00 = __s_00 + (ulong)bVar41 * -2 + 1;
                  s = s + (ulong)bVar41 * -2 + 1;
                } while (bVar38);
              } while ((nbytes <= bh) && ((!bVar40 && !bVar38) != bVar40));
              if ((nbytes != 1) && ((!bVar40 && !bVar38) != bVar40)) {
                bdfError("Error in bitmap, missing \'ENDCHAR\'\n");
              }
            }
LAB_001198d3:
            __s_00 = bdfGetLine(file,lineBuf,0x400);
            uVar24 = (ulong)(uint)nchars;
            if (nchars <= local_1150) {
              uVar28 = (ulong)(uint)(local_1108 + local_1150);
              goto LAB_0011a23a;
            }
            bVar40 = __s_00 == (byte *)0x0;
          } while (!bVar40);
          uVar28 = (ulong)(uint)(local_1108 + local_1150);
          if (nchars == local_1108 + local_1150) {
            nchars = local_1150;
            *(int *)((long)pvVar3 + 4) = local_1150;
            goto LAB_0011992f;
          }
        }
      }
LAB_0011a117:
      bdfError("%d too few characters\n",(ulong)(uint)((int)uVar24 - (int)uVar28),uVar24,uVar28);
    }
  }
  else {
    bdfEncoding[0] = (CharInfoPtr *)0x0;
    bdfError("Couldn\'t allocate pCI (%d*%d)\n",(ulong)(uint)nchars,0x18);
  }
LAB_0011942c:
  while( true ) {
    pp_Var29 = pp_Var29 + 1;
    if ((CharInfoPtr)bdfEncoding[0] != (CharInfoPtr)0x0) {
      free(bdfEncoding[0]);
    }
    if ((CharInfoPtr *)charName == pp_Var29) break;
    bdfEncoding[0] = (CharInfoPtr *)*pp_Var29;
  }
  BVar14 = 0;
LAB_001193d7:
  if (lVar4 == *(long *)(in_FS_OFFSET + 0x28)) {
    return BVar14;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}

