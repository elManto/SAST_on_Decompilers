Bool __fastcall bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState, int bit, int byte, int glyph, int scan)
{
  FontPtr v7; // r15
  _buffile *v8; // r12
  _BitmapFont *v9; // r13
  _QWORD *v10; // rbp
  unsigned __int8 *v11; // rsi
  unsigned __int8 *v12; // rax
  CharInfoPtr *v14; // rbp
  CharInfoPtr *v15; // rdi
  char *j; // rbx
  _CharInfo *v17; // rax
  void *v18; // rax
  void *v19; // rax
  unsigned __int8 *v20; // rax
  int v21; // edx
  unsigned __int8 *v22; // rsi
  bool v23; // cf
  bool v24; // zf
  unsigned __int8 *v25; // r15
  const char *v26; // rdi
  signed __int64 v27; // rcx
  unsigned __int8 *v28; // rsi
  int v29; // ebx
  Atom *v30; // r13
  const char *v31; // rsi
  unsigned __int8 *v32; // rax
  int v33; // eax
  int v34; // edx
  int v35; // er13
  unsigned int v36; // er14
  CharInfoPtr *v37; // rax
  const char *v38; // rsi
  unsigned __int8 *v39; // rax
  const char *v40; // rsi
  unsigned __int8 *v41; // rax
  const char *v42; // rsi
  unsigned __int8 *v43; // rax
  unsigned __int8 *v44; // rax
  bool v45; // cf
  bool v46; // zf
  const char *v47; // rdi
  signed __int64 v48; // rcx
  unsigned __int8 *v49; // rsi
  bool v50; // cf
  bool v51; // zf
  const char *v52; // rdi
  signed __int64 v53; // rcx
  unsigned __int8 *v54; // rsi
  int v55; // er14
  char *v56; // rdx
  int v57; // ecx
  unsigned int v58; // eax
  int v59; // er13
  const char *v60; // rdi
  signed __int64 v61; // rcx
  bool v62; // cf
  bool v63; // zf
  unsigned __int8 *v64; // rsi
  unsigned __int8 *v65; // rax
  int v66; // ecx
  __int16 v67; // dx
  INT16 v68; // si
  INT16 v69; // cx
  INT16 v70; // r13
  int v71; // eax
  int v72; // ecx
  const char *v73; // rsi
  int v74; // er9
  __int64 v75; // rax
  int v76; // edx
  unsigned int i; // er11
  int v78; // eax
  bdfFileState *v79; // rsi
  int v80; // eax
  unsigned __int8 *v81; // rax
  const char *v82; // r14
  bool v83; // cf
  bool v84; // zf
  unsigned __int8 *v85; // rsi
  signed __int64 v86; // rcx
  const char *v87; // rdi
  char v88; // al
  bool v89; // cf
  bool v90; // zf
  signed __int64 v91; // rcx
  const char *v92; // rdi
  int v93; // eax
  int v94; // er13
  int v95; // ecx
  unsigned __int8 *v96; // r15
  unsigned __int8 *v97; // rbp
  signed __int64 v98; // r13
  unsigned __int8 *v99; // rdi
  unsigned __int8 *v100; // rdx
  unsigned __int8 *v101; // rax
  int v102; // eax
  unsigned __int8 *v103; // rax
  unsigned __int8 *v104; // r14
  unsigned __int8 v105; // al
  __int16 v106; // ax
  unsigned __int8 *v107; // rax
  CharInfoPtr *v108; // rdx
  bool v109; // cf
  bool v110; // zf
  const char *v111; // rdi
  signed __int64 v112; // rcx
  unsigned __int8 *v113; // rsi
  char v114; // dl
  bool v115; // cf
  bool v116; // zf
  unsigned __int8 *v117; // rdi
  signed __int64 v118; // rcx
  int v119; // ebx
  int v120; // eax
  int v121; // ebp
  int v122; // eax
  size_t v123; // rbp
  CharInfoPtr **v124; // rax
  __int64 v125; // rdx
  unsigned int v126; // edi
  CharInfoPtr **v127; // r14
  bdfFileState *v128; // rcx
  CharInfoPtr *v129; // rsi
  int v130; // er9
  signed __int64 v131; // rax
  signed __int64 v132; // rbp
  int v133; // er8
  int v134; // er12
  __int64 v135; // rax
  __int64 v136; // r12
  __int64 v137; // rdi
  CharInfoPtr v138; // r13
  void **v139; // rbx
  int v140; // ST20_4
  bdfFileState *v141; // ST18_8
  int v142; // ST14_4
  _QWORD *v143; // ST00_8
  void *v144; // rax
  int *v145; // [rsp+0h] [rbp-1198h]
  int glypha; // [rsp+14h] [rbp-1184h]
  bdfFileState *pStatea; // [rsp+18h] [rbp-1180h]
  int bita; // [rsp+20h] [rbp-1178h]
  int bytea; // [rsp+24h] [rbp-1174h]
  int str; // [rsp+28h] [rbp-1170h]
  CharInfoPtr ci; // [rsp+30h] [rbp-1168h]
  FontPtr pFonta; // [rsp+38h] [rbp-1160h]
  unsigned __int8 *ptr; // [rsp+40h] [rbp-1158h]
  int ndx; // [rsp+48h] [rbp-1150h]
  unsigned int v155; // [rsp+4Ch] [rbp-114Ch]
  unsigned int v156; // [rsp+58h] [rbp-1140h]
  int v157; // [rsp+5Ch] [rbp-113Ch]
  int v158; // [rsp+68h] [rbp-1130h]
  int numEncodedGlyphs; // [rsp+6Ch] [rbp-112Ch]
  _QWORD *v160; // [rsp+70h] [rbp-1128h]
  unsigned __int8 *v161; // [rsp+78h] [rbp-1120h]
  signed __int64 v162; // [rsp+80h] [rbp-1118h]
  BitmapFontPtr bitmapFont; // [rsp+88h] [rbp-1110h]
  int nignored; // [rsp+90h] [rbp-1108h]
  int v165; // [rsp+94h] [rbp-1104h]
  int v166; // [rsp+98h] [rbp-1100h]
  char v167; // [rsp+A3h] [rbp-10F5h]
  int v168; // [rsp+ACh] [rbp-10ECh]
  int nchars; // [rsp+BCh] [rbp-10DCh]
  int wx; // [rsp+C0h] [rbp-10D8h]
  int wy; // [rsp+C4h] [rbp-10D4h]
  int bw; // [rsp+C8h] [rbp-10D0h]
  int bh_0; // [rsp+CCh] [rbp-10CCh]
  int bl_0; // [rsp+D0h] [rbp-10C8h]
  int bb; // [rsp+D4h] [rbp-10C4h]
  int enc; // [rsp+D8h] [rbp-10C0h]
  int enc2; // [rsp+DCh] [rbp-10BCh]
  CharInfoPtr *bdfEncoding[256]; // [rsp+E0h] [rbp-10B8h]
  char charName[100]; // [rsp+8E0h] [rbp-8B8h]
  unsigned __int8 lineBuf[1024]; // [rsp+950h] [rbp-848h]
  unsigned __int8 buf; // [rsp+D50h] [rbp-448h]
  unsigned __int64 v182; // [rsp+1158h] [rbp-40h]

  v7 = pFont;
  v8 = file;
  v9 = (_BitmapFont *)pFont->fontPrivate;
  v182 = __readfsqword(0x28u);
  pStatea = pState;
  bita = bit;
  v10 = &v9->bitmapExtra->glyphNames;
  bytea = byte;
  glypha = glyph;
  v145 = 0LL;
  if ( v10 )
  {
    v10[2] = 0LL;
    v10[3] = 0LL;
    v145 = (int *)(v10 + 2);
  }
  v9->metrics = 0LL;
  memset(bdfEncoding, 0, sizeof(bdfEncoding));
  v11 = lineBuf;
  v12 = bdfGetLine(file, lineBuf, 1024);
  if ( !v12 || (v11 = "CHARS %d", sscanf((const char *)v12, "CHARS %d", &nchars) != 1) )
  {
    bdfError("bad 'CHARS' in bdf file\n", v11);
    return 0;
  }
  if ( nchars <= 0 )
  {
    bdfError("invalid number of CHARS in BDF file\n");
    return 0;
  }
  if ( nchars > 89478485 )
  {
    v14 = 0LL;
    bdfError("Couldn't allocate pCI (%d*%d)\n", (unsigned int)nchars, 24LL);
    goto LABEL_10;
  }
  v17 = (_CharInfo *)calloc(nchars, 0x18uLL);
  ci = v17;
  if ( !v17 )
  {
    v14 = 0LL;
    bdfError("Couldn't allocate pCI (%d*%d)\n", (unsigned int)nchars, 24LL);
    goto LABEL_10;
  }
  v9->metrics = v17;
  if ( v10 )
  {
    v18 = malloc(8LL * nchars);
    *v10 = v18;
    if ( !v18 )
    {
      v14 = 0LL;
      bdfError("Couldn't allocate glyphNames (%d*%d)\n", (unsigned int)nchars, 8LL);
      goto LABEL_10;
    }
    v19 = malloc(4LL * nchars);
    v10[1] = v19;
    if ( !v19 )
    {
      bdfError("Couldn't allocate sWidth (%d *%d)\n", (unsigned int)nchars, 4LL);
      return 0;
    }
  }
  v20 = bdfGetLine(file, lineBuf, 1024);
  v21 = nchars;
  v22 = (unsigned __int8 *)1099511628032LL;
  *(_QWORD *)&v7->info.firstCol = 1099511628032LL;
  if ( v21 <= 0 )
  {
    v66 = 0;
    numEncodedGlyphs = 0;
    ndx = 0;
LABEL_219:
    if ( v66 == v21 )
    {
      v109 = 0;
      v110 = v20 == 0LL;
      nchars = ndx;
      v9->num_chars = ndx;
      if ( v20 )
        goto LABEL_208;
LABEL_216:
      v14 = bdfEncoding[0];
LABEL_88:
      bdfError("missing 'ENDFONT'\n", v22);
      goto LABEL_10;
    }
LABEL_198:
    v14 = bdfEncoding[0];
    goto LABEL_199;
  }
  v23 = 0;
  v24 = v20 == 0LL;
  if ( !v20 )
  {
    v14 = 0LL;
    v66 = 0;
LABEL_199:
    bdfError("%d too few characters\n", (unsigned int)(v21 - v66));
    goto LABEL_10;
  }
  pFonta = v7;
  numEncodedGlyphs = 0;
  nignored = 0;
  ndx = 0;
  v25 = lineBuf;
  bitmapFont = v9;
  while ( 1 )
  {
    v26 = "STARTCHAR";
    v27 = 9LL;
    v28 = v20;
    do
    {
      if ( !v27 )
        break;
      v23 = *v28 < *v26;
      v24 = *v28++ == *v26++;
      --v27;
    }
    while ( v24 );
    v29 = (char)((!v23 && !v24) - v23);
    if ( (!v23 && !v24) != v23 )
      break;
    if ( sscanf((const char *)v20, "STARTCHAR %s", charName) != 1 )
    {
      bdfError("bad character name in BDF file\n");
      goto LABEL_187;
    }
    if ( v10 )
    {
      v30 = (Atom *)(*v10 + 8LL * ndx);
      *v30 = bdfForceMakeAtom(charName, 0LL);
    }
    v31 = (const char *)v25;
    v32 = bdfGetLine(v8, v25, 1024);
    if ( !v32 || (v31 = "ENCODING %d %d", v33 = sscanf((const char *)v32, "ENCODING %d %d", &enc, &enc2), v33 <= 0) )
    {
      bdfError("bad 'ENCODING' in BDF file\n", v31);
      goto LABEL_187;
    }
    v34 = enc;
    if ( enc < -1 )
      goto LABEL_200;
    if ( v33 == 2 )
    {
      if ( enc2 < -1 )
      {
LABEL_200:
        bdfError("bad ENCODING value");
        goto LABEL_187;
      }
      if ( enc != -1 )
        goto LABEL_35;
      enc = enc2;
      v34 = enc2;
    }
    if ( v34 == -1 )
    {
      if ( !v10 )
      {
        ++nignored;
        v29 = 1;
      }
      goto LABEL_46;
    }
LABEL_35:
    if ( v34 > 0xFFFF )
    {
      bdfError("char '%s' has encoding too large (%d)\n", charName);
    }
    else
    {
      v35 = (unsigned __int8)v34;
      v36 = v34 >> 8;
      if ( v34 >> 8 < (unsigned int)pFonta->info.firstRow )
        pFonta->info.firstRow = v36;
      if ( v36 > pFonta->info.lastRow )
        pFonta->info.lastRow = v36;
      if ( pFonta->info.firstCol > (unsigned int)(unsigned __int8)v34 )
        pFonta->info.firstCol = (unsigned __int8)v34;
      if ( pFonta->info.lastCol < (unsigned int)(unsigned __int8)v34 )
        pFonta->info.lastCol = (unsigned __int8)v34;
      v37 = bdfEncoding[v36];
      if ( !v37 )
      {
        v37 = (CharInfoPtr *)malloc(0x800uLL);
        bdfEncoding[v36] = v37;
        if ( !v37 )
        {
          bdfError("Couldn't allocate row %d of encoding (%d*%d)\n", v36, 256LL, 8LL);
          goto LABEL_187;
        }
        v108 = v37;
        do
        {
          *v108 = 0LL;
          ++v108;
        }
        while ( v108 != v37 + 256 );
      }
      ++numEncodedGlyphs;
      v37[v35] = ci;
    }
LABEL_46:
    v38 = (const char *)v25;
    v39 = bdfGetLine(v8, v25, 1024);
    if ( !v39 || (v38 = "SWIDTH %d %d", sscanf((const char *)v39, "SWIDTH %d %d", &wx, &wy) != 2) )
    {
      bdfError("bad 'SWIDTH'\n", v38);
      goto LABEL_187;
    }
    if ( wy )
    {
      bdfError("SWIDTH y value must be zero\n");
      goto LABEL_187;
    }
    if ( v10 )
      *(_DWORD *)(v10[1] + 4LL * ndx) = wx;
    v40 = (const char *)v25;
    v41 = bdfGetLine(v8, v25, 1024);
    if ( !v41 || (v40 = "DWIDTH %d %d", sscanf((const char *)v41, "DWIDTH %d %d", &wx, &wy) != 2) )
    {
      bdfError("bad 'DWIDTH'\n", v40);
      goto LABEL_187;
    }
    if ( wy )
    {
      bdfError("DWIDTH y value must be zero\n");
      goto LABEL_187;
    }
    v42 = (const char *)v25;
    v43 = bdfGetLine(v8, v25, 1024);
    if ( !v43
      || (v42 = "BBX %d %d %d %d", sscanf((const char *)v43, "BBX %d %d %d %d", &bw, &bh_0, &bl_0, &bb, v145) != 4) )
    {
      bdfError("bad 'BBX'\n", v42);
LABEL_187:
      v14 = bdfEncoding[0];
      goto LABEL_10;
    }
    if ( bh_0 < 0 || bw < 0 )
    {
      bdfError("character '%s' has a negative sized bitmap, %dx%d\n", charName, (unsigned int)bw);
      goto LABEL_187;
    }
    v44 = bdfGetLine(v8, v25, 1024);
    v45 = 0;
    v46 = v44 == 0LL;
    if ( !v44 )
      goto LABEL_260;
    v47 = "ATTRIBUTES";
    v48 = 10LL;
    v49 = v44;
    do
    {
      if ( !v48 )
        break;
      v45 = *v49 < *v47;
      v46 = *v49++ == *v47++;
      --v48;
    }
    while ( v46 );
    if ( (!v45 && !v46) == v45 )
    {
      v104 = v44 + 11;
      v105 = v44[11];
      if ( v105 == 9 || v105 == 32 )
      {
        do
        {
          do
            ++v104;
          while ( *v104 == 32 );
        }
        while ( *v104 == 9 );
      }
      LOBYTE(v106) = bdfHexByte(v104);
      ci->metrics.attributes = (v106 << 8) + bdfHexByte(v104 + 2);
      v44 = bdfGetLine(v8, v25, 1024);
    }
    else
    {
LABEL_260:
      ci->metrics.attributes = 0;
    }
    v50 = 0;
    v51 = v44 == 0LL;
    if ( !v44 )
      goto LABEL_261;
    v52 = "BITMAP";
    v53 = 6LL;
    v54 = v44;
    do
    {
      if ( !v53 )
        break;
      v50 = *v54 < *v52;
      v51 = *v54++ == *v52++;
      --v53;
    }
    while ( v51 );
    v55 = (char)((!v50 && !v51) - v50);
    if ( (!v50 && !v51) != v50 )
    {
LABEL_261:
      bdfError("missing 'BITMAP'\n");
      goto LABEL_187;
    }
    v56 = charName;
    do
    {
      v57 = *(_DWORD *)v56;
      v56 += 4;
      v58 = ~v57 & (v57 - 16843009) & 0x80808080;
    }
    while ( !v58 );
    v59 = bh_0;
    if ( !((unsigned __int16)~(_WORD)v57 & (unsigned __int16)(v57 - 257) & 0x8080) )
      LOBYTE(v58) = (~v57 & (v57 - 16843009) & 0x80808080) >> 16;
    if ( !((unsigned __int16)~(_WORD)v57 & (unsigned __int16)(v57 - 257) & 0x8080) )
      v56 += 2;
    if ( &v56[-__CFADD__((_BYTE)v58, (_BYTE)v58) - 3] - charName == 1 )
    {
      if ( (unsigned __int8)(charName[0] - 48) <= 9u )
      {
        v79 = pStatea;
        v80 = wx;
        ++v79->digitCount;
        v79->digitWidths += v80;
      }
      else if ( charName[0] == 120 )
      {
        v78 = bh_0 + bb;
        if ( bh_0 + bb <= 0 )
          v78 = bh_0;
        pStatea->exHeight = v78;
      }
    }
    if ( v29 )
    {
      while ( 1 )
      {
        v65 = bdfGetLine(v8, &buf, 1024);
        ++v55;
        v62 = 0;
        v63 = v65 == 0LL;
        v64 = v65;
        if ( !v65 )
          goto LABEL_84;
        v60 = "ENDCHAR";
        v61 = 7LL;
        do
        {
          if ( !v61 )
            break;
          v62 = *v64 < *v60;
          v63 = *v64++ == *v60++;
          --v61;
        }
        while ( v63 );
        if ( v59 < v55 || (!v62 && !v63) == v62 )
        {
          if ( v55 != 1 && (!v62 && !v63) != v62 )
            bdfError("Error in bitmap, missing 'ENDCHAR'\n", v64);
          goto LABEL_84;
        }
      }
    }
    v67 = bl_0;
    v68 = wx;
    v69 = bl_0 + bw;
    v70 = bb + v59;
    v71 = -bb;
    ci->metrics.leftSideBearing = bl_0;
    ci->metrics.rightSideBearing = v69;
    ci->metrics.ascent = v70;
    ci->metrics.descent = v71;
    v72 = v69 - v67;
    ci->metrics.characterWidth = v68;
    ci->bits = 0LL;
    str = v72;
    v155 = v70 + (signed __int16)v71;
    switch ( glypha )
    {
      case 1:
        v156 = (v72 + 7) >> 3;
        break;
      case 2:
        v156 = ((v72 + 15) >> 3) & 0xFFFFFFFE;
        break;
      case 4:
        v156 = ((v72 + 31) >> 3) & 0xFFFFFFFC;
        break;
      case 8:
        v156 = ((v72 + 63) >> 3) & 0xFFFFFFF8;
        break;
      default:
        v165 = 0;
        v156 = 0;
        ptr = 0LL;
        goto LABEL_94;
    }
    v165 = v156 * v155;
    if ( (signed int)(v156 * v155) <= 0 )
    {
      ptr = 0LL;
LABEL_94:
      v73 = (const char *)ptr;
      ci->bits = (char *)ptr;
      if ( v145 )
      {
        v74 = str + 7;
        v75 = 0LL;
        v73 = (const char *)(v155 * (((str + 63) >> 3) & 0xFFFFFFF8));
        v76 = *v145;
LABEL_100:
        for ( i = (str + 7) >> 3; ; i = ((str + 15) >> 3) & 0xFFFFFFFE )
        {
LABEL_101:
          v145[v75] = v155 * i + v76;
          while ( 1 )
          {
            v76 = v145[++v75];
            if ( !v75 )
              goto LABEL_100;
            if ( (_DWORD)v75 == 1 )
              break;
            if ( (_DWORD)v75 == 2 )
            {
              i = ((str + 31) >> 3) & 0xFFFFFFFC;
              goto LABEL_101;
            }
            v145[v75] = (_DWORD)v73 + v76;
            if ( (_DWORD)v75 == 3 )
              goto LABEL_125;
          }
        }
      }
      v74 = str + 7;
LABEL_125:
      v157 = v74 >> 3;
      if ( (signed int)v155 <= 0 )
      {
        if ( !v155 )
        {
          v29 = 0;
          goto LABEL_161;
        }
LABEL_162:
        bdfError("missing 'ENDCHAR'\n", v73);
      }
      else
      {
        v158 = 0;
        v160 = v10;
        v161 = v25;
        v167 = 255 << (8 - (str & 7));
        v162 = (signed __int64)(ptr + 1);
        do
        {
          v73 = (const char *)&buf;
          v81 = bdfGetLine(v8, &buf, 1024);
          v82 = (const char *)v81;
          if ( !v81 )
          {
            v10 = v160;
            v25 = v161;
            goto LABEL_162;
          }
          v83 = 0;
          v84 = str == 0;
          if ( str )
          {
            v93 = strlen((const char *)v81);
            v94 = v93;
            if ( v93 & 1 )
            {
              bdfError("odd number of characters in hex encoding\n");
              v93 = v94 + 1;
              v82[v94] = 48;
              v82[v94 + 1] = 0;
            }
            v95 = v93 >> 1;
            v166 = v93 >> 1;
            if ( v157 <= v93 >> 1 )
              v95 = v157;
            if ( v95 > 0 )
            {
              v96 = (unsigned __int8 *)v82;
              v168 = v95 - 1;
              v97 = &ptr[v29];
              v98 = v162 + v29 + (unsigned int)(v95 - 1);
              do
              {
                v99 = v96;
                ++v97;
                v96 += 2;
                *(v97 - 1) = bdfHexByte(v99);
              }
              while ( v97 != (unsigned __int8 *)v98 );
              v29 += v168 + 1;
            }
            if ( v157 > v166 )
            {
              if ( v157 - v166 > 0 )
              {
                v107 = &ptr[v29];
                do
                  *v107++ = 0;
                while ( v107 != (unsigned __int8 *)(v29 + v162 + (unsigned int)(v157 - v166 - 1)) );
                v29 += v157 - v166;
              }
            }
            else if ( v167 )
            {
              v100 = &ptr[v29 - 1];
              if ( *v100 & (unsigned __int8)~v167 )
                *v100 &= v167;
            }
            if ( v157 < (signed int)v156 && (signed int)(v156 - v157) > 0 )
            {
              v101 = &ptr[v29];
              do
                *v101++ = 0;
              while ( (unsigned __int8 *)(v29 + v162 + v156 - v157 - 1) != v101 );
              v29 += v156 - v157;
            }
          }
          else
          {
            v85 = v81;
            v86 = 7LL;
            v87 = "ENDCHAR";
            do
            {
              if ( !v86 )
                break;
              v83 = *v85 < *v87;
              v84 = *v85++ == *v87++;
              --v86;
            }
            while ( v84 );
            v88 = (!v83 && !v84) - v83;
            v89 = 0;
            v90 = v88 == 0;
            if ( !v88 )
            {
              v10 = v160;
              v25 = v161;
              goto LABEL_134;
            }
          }
          ++v158;
        }
        while ( v155 != v158 );
        v10 = v160;
        v25 = v161;
        v102 = strncmp(v82, "ENDCHAR", 7uLL);
        v89 = 0;
        v90 = v102 == 0;
        if ( !v102 )
          goto LABEL_134;
LABEL_161:
        v73 = (const char *)&buf;
        v103 = bdfGetLine(v8, &buf, 1024);
        v89 = 0;
        v90 = v103 == 0LL;
        v82 = (const char *)v103;
        if ( !v103 )
          goto LABEL_162;
LABEL_134:
        v91 = 7LL;
        v73 = v82;
        v92 = "ENDCHAR";
        do
        {
          if ( !v91 )
            break;
          v89 = (const unsigned __int8)*v73 < *v92;
          v90 = *v73++ == *v92++;
          --v91;
        }
        while ( v90 );
        if ( (!v89 && !v90) != v89 )
          goto LABEL_162;
        if ( v29 == v165 )
        {
          if ( ptr )
          {
            if ( !bita )
              BitOrderInvert(ptr, v29);
            if ( bita != bytea )
            {
              if ( scan == 2 )
              {
                TwoByteSwap(ptr, v29);
              }
              else if ( scan == 4 )
              {
                FourByteSwap(ptr, v29);
              }
            }
          }
          goto LABEL_122;
        }
        bdfError("bytes != rows * bytes_per_row (%d != %d * %d)\n", (unsigned int)v29, v155, v156);
      }
      if ( ptr )
        free(ptr);
      goto LABEL_121;
    }
    ptr = (unsigned __int8 *)malloc((signed int)(v156 * v155));
    if ( ptr )
      goto LABEL_94;
    bdfError("Couldn't allocate picture (%d*%d)\n", v156, v155);
LABEL_121:
    ci->bits = 0LL;
LABEL_122:
    ++ci;
    ++ndx;
LABEL_84:
    v22 = v25;
    v20 = bdfGetLine(v8, v25, 1024);
    v21 = nchars;
    if ( nchars <= ndx )
    {
      v66 = ndx + nignored;
      v9 = bitmapFont;
      v7 = pFonta;
      goto LABEL_219;
    }
    v23 = 0;
    v24 = v20 == 0LL;
    if ( !v20 )
    {
      v66 = ndx + nignored;
      v14 = bdfEncoding[0];
      if ( nchars != ndx + nignored )
        goto LABEL_199;
      nchars = ndx;
      bitmapFont->num_chars = ndx;
      goto LABEL_88;
    }
  }
  v66 = ndx + nignored;
  v9 = bitmapFont;
  v7 = pFonta;
  v109 = ndx + nignored < (unsigned int)v21;
  v110 = ndx + nignored == v21;
  if ( ndx + nignored != v21 )
    goto LABEL_198;
  nchars = ndx;
  bitmapFont->num_chars = ndx;
LABEL_208:
  v111 = "STARTCHAR";
  v112 = 9LL;
  v113 = v20;
  do
  {
    if ( !v112 )
      break;
    v109 = *v113 < *v111;
    v110 = *v113++ == *v111++;
    --v112;
  }
  while ( v110 );
  v114 = (!v109 && !v110) - v109;
  v115 = 0;
  v116 = v114 == 0;
  if ( !v114 )
  {
    bdfError("more characters than specified\n", v113);
    v14 = bdfEncoding[0];
    goto LABEL_10;
  }
  v117 = (unsigned __int8 *)&unk_30A40;
  v118 = 7LL;
  v22 = v20;
  do
  {
    if ( !v118 )
      break;
    v115 = *v22 < *v117;
    v116 = *v22++ == *v117++;
    --v118;
  }
  while ( v116 );
  v119 = (char)((!v115 && !v116) - v115);
  if ( (!v115 && !v116) != v115 )
    goto LABEL_216;
  if ( !numEncodedGlyphs )
    bdfWarning("No characters with valid encodings\n", v22);
  v120 = (v7->info.lastCol - v7->info.firstCol + 1) * (v7->info.lastRow - v7->info.firstRow + 1);
  v121 = v120 + 254;
  v122 = v120 + 127;
  if ( v122 < 0 )
    v122 = v121;
  v123 = v122 >> 7;
  v124 = (CharInfoPtr **)calloc(v123, 8uLL);
  v9->encoding = v124;
  if ( !v124 )
  {
    bdfError("Couldn't allocate ppCI (%d,%d)\n", (unsigned int)v123, 8LL);
    v14 = bdfEncoding[0];
LABEL_10:
    v15 = v14;
    for ( j = (char *)&bdfEncoding[1]; ; j += 8 )
    {
      if ( v15 )
        free(v15);
      if ( charName == j )
        break;
      v15 = *(CharInfoPtr **)j;
    }
    return 0;
  }
  v125 = v7->info.firstRow;
  v126 = v7->info.lastRow;
  *((_BYTE *)&v7->info + 10) |= 0x40u;
  if ( (unsigned int)v125 <= v126 )
  {
    v127 = &bdfEncoding[v125];
    v128 = (bdfFileState *)v9;
    do
    {
      v129 = *v127;
      v130 = v7->info.lastCol;
      v131 = v7->info.firstCol;
      if ( *v127 )
      {
        if ( (unsigned __int16)v130 >= (unsigned __int16)v131 )
        {
          v132 = v131;
          v133 = (unsigned __int16)v131 - v119;
          while ( 1 )
          {
            v138 = v129[v132];
            if ( v138 )
            {
              v134 = v119 + 127;
              v135 = *(_QWORD *)&v128->fontName[24];
              if ( v119 >= 0 )
                v134 = v119;
              v136 = v134 >> 7;
              v137 = *(_QWORD *)(v135 + 8 * v136);
              if ( !v137 )
              {
                v140 = v125;
                v141 = v128;
                v142 = v133;
                v143 = (_QWORD *)(v135 + 8 * v136);
                v144 = calloc(0x80uLL, 8uLL);
                v128 = v141;
                v133 = v142;
                LODWORD(v125) = v140;
                *v143 = v144;
                v137 = *(_QWORD *)(*(_QWORD *)&v141->fontName[24] + 8 * v136);
                if ( !v137 )
                  goto LABEL_187;
              }
              *(_QWORD *)(v137 + 8LL * (v119 % 128)) = v138;
            }
            else
            {
              *((_BYTE *)&v7->info + 10) &= 0xBFu;
            }
            ++v119;
            ++v132;
            if ( v7->info.lastCol < (unsigned int)(v133 + v119) )
              break;
            v129 = *v127;
          }
          v126 = v7->info.lastRow;
        }
      }
      else
      {
        *((_BYTE *)&v7->info + 10) &= 0xBFu;
        v119 += v130 - v131 + 1;
      }
      LODWORD(v125) = v125 + 1;
      ++v127;
    }
    while ( v126 >= (unsigned int)v125 );
  }
  v139 = (void **)bdfEncoding;
  do
  {
    if ( *v139 )
      free(*v139);
    ++v139;
  }
  while ( charName != (char *)v139 );
  return 1;
}
