/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_7FD0();
// __int64 FT_Get_Sfnt_Name_Count(void); weak
// __int64 __fastcall __strcat_chk(_QWORD, _QWORD, _QWORD); weak
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
__int64 __fastcall add_range(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall bitmapAddInkMetrics(_QWORD); // weak
// __int64 __fastcall __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void free(void *ptr);
int StoreFontClientFont(FontPtr pfont, Font id);
__int64 __fastcall FontCharInkMetrics(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall BufFileClose(void *ptr); // idb
// int strcasecmp(const char *s1, const char *s2);
// __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int *__errno_location(void);
int AddFontNamesName(FontNamesPtr, char *, int);
// int unlink(const char *name);
// __int64 __fastcall FT_Get_Name_Index(_QWORD, _QWORD); weak
// char *strncpy(char *dest, const char *src, size_t n);
// __int64 __fastcall FT_Load_Glyph(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall _fs_connection_died(_QWORD); // weak
__int64 __fastcall FontFileInitTable(_QWORD, _QWORD); // weak
// int strncmp(const char *s1, const char *s2, size_t n);
__int64 __fastcall _fs_init_fontinfo(_QWORD, _QWORD); // weak
__int64 __fastcall _FontTransWrite(_QWORD, _QWORD); // weak
__int64 __fastcall BufFileCreate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
FontPtr CreateFontRec(void);
// __int64 __fastcall FT_Get_X11_Font_Format(_QWORD); weak
// char *strcpy(char *dest, const char *src);
__int64 __fastcall FontCharReshape(_QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall FT_Load_Sfnt_Table(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FT_Get_Postscript_Name(_QWORD); weak
__int64 FontFileRegisterLocalFpeFunctions(void); // weak
__int64 __fastcall bdfError(_QWORD); // weak
// __int64 __fastcall inflate(_QWORD, _QWORD); weak
// __int64 __fastcall FT_Set_Pixel_Sizes(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FT_New_Size(_QWORD, _QWORD); weak
// __int64 __fastcall FT_Done_Size(_QWORD); weak
__int64 __fastcall FontFileRegisterBitmapSource(_QWORD, _QWORD); // weak
// ssize_t writev(int fd, const struct iovec *iovec, int count);
__int64 __fastcall FontFileReadDirectory(char *s); // idb
__int64 __fastcall BufFileOpenWrite(_QWORD, _QWORD); // weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
__int64 __cdecl FontFileStartListFonts(_QWORD); // weak
__int64 __fastcall _fs_wait_for_readable(_QWORD, _QWORD); // weak
// double strtod(const char *nptr, char **endptr);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// struct lconv *localeconv(void);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fcntl(int fd, int cmd, ...);
__int64 __fastcall bdfForceMakeAtom(char *string); // idb
// ssize_t write(int fd, const void *buf, size_t n);
__int64 __fastcall FTGetEnglishName(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall fs_load_all_glyphs(FontPtr pfont); // idb
__int64 __fastcall FontFileAddFontAlias(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _fs_connect(_QWORD, _QWORD); // weak
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
__int64 __fastcall FontFileAddEntry(_QWORD, _QWORD); // weak
// int fclose(FILE *stream);
__int64 __fastcall FontFileSortDir(_QWORD); // weak
__int64 __fastcall _FontTransClose(void *ptr); // idb
__int64 __fastcall _fs_done_read(_QWORD, _QWORD); // weak
// DIR *opendir(const char *name);
__int64 __fastcall _fs_io_fini(_QWORD); // weak
// int shutdown(int fd, int how);
// __int64 __fastcall FT_Done_Face(_QWORD); weak
// char *stpcpy(char *dest, const char *src);
void DeleteFontClientID(Font id);
__int64 __fastcall _fs_poll_connect(_QWORD, _QWORD); // weak
__int64 __fastcall QueryGlyphExtents(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD); // weak
int RegisterFPEFunctions(NameCheckFunc name_func, InitFpeFunc init_func, FreeFpeFunc free_func, ResetFpeFunc reset_func, OpenFontFunc open_func, CloseFontFunc close_func, ListFontsFunc list_func, StartLfwiFunc start_lfwi_func, NextLfwiFunc next_lfwi_func, WakeupFpeFunc wakeup_func, ClientDiedFunc client_died, LoadGlyphsFunc load_glyphs, StartLaFunc start_list_alias_func, NextLaFunc next_list_alias_func, SetPathFunc set_path_func);
// size_t strlen(const char *s);
__int64 __fastcall _fs_convert_lfwi_reply(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall BufFilePushCompressed(_QWORD, _QWORD); // weak
__int64 __fastcall _fs_start_read(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall BufFileOpenRead(_QWORD); // weak
void DestroyFontRec(FontPtr font);
__int64 __fastcall FontFileFreeEntry(_QWORD); // weak
__int64 __fastcall FontFileMatchName(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _FontTransFreeConnInfo(void *ptr); // idb
// __int64 __fastcall FT_Activate_Size(_QWORD); weak
// char *strchr(const char *s, int c);
__int64 __fastcall _FontTransConnect(_QWORD, _QWORD); // weak
// __int64 __fastcall __fdelt_chk(_QWORD); weak
__int64 __fastcall FTtoXReturnCode(_QWORD, _QWORD); // weak
// const char *gai_strerror(int ecode);
__int64 __fastcall FontFileMakeDir(char *s); // idb
// char *strrchr(const char *s, int c);
// __int64 __fastcall FT_New_Face(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 BuiltinRegisterFontFileFunctions(void); // weak
// int uname(struct utsname *name);
__int64 __fastcall _fs_pad_length(_QWORD, _QWORD); // weak
__int64 __fastcall BuiltinReadDirectory(_QWORD, _QWORD); // weak
// __int64 __fastcall FT_Init_FreeType(_QWORD); weak
// __off_t lseek(int fd, __off_t offset, int whence);
int GetDefaultPointSize(void);
// __int64 __fastcall FontEncName(_QWORD, _QWORD); weak
__int64 __fastcall bdfHexByte(_QWORD, _QWORD); // weak
__int64 __fastcall FontFileOpenBitmap(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall FontComputeInfoAccelerators(_QWORD); // weak
__int64 __fastcall FontDefaultFormat(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// void *memset(void *s, int c, size_t n);
__int64 __fastcall SPropRecValList_new(_QWORD, _QWORD); // weak
// int fscanf(FILE *stream, const char *format, ...);
// __int64 __fastcall FontEncRecode(_QWORD, _QWORD); weak
__int64 __fastcall BuiltinFileOpen(_QWORD); // weak
__int64 __fastcall FontFileFindNamesInScalableDir(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// int ioctl(int fd, unsigned __int64 request, ...);
__int64 __fastcall FontFileMatchBitmapSource(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
double __fastcall xlfd_round_double(double, double, double, double, double, double, double); // weak
__int64 __fastcall FontFileRegisterRenderer(_QWORD); // weak
// __int64 __fastcall FT_Get_PS_Font_Info(_QWORD, _QWORD); weak
// __int64 __fastcall FT_Set_Charmap(_QWORD, _QWORD); weak
// int close(int fd);
__int64 __fastcall fs_create_font(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _fs_io_init(_QWORD, _QWORD); // weak
__int64 __fastcall bitmapComputeWeight(_QWORD); // weak
// __int64 FontEncFromXLFD(void); weak
// int closedir(DIR *dirp);
__int64 __fastcall _fs_write_pad(_QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall FT_Outline_Get_BBox(_QWORD, _QWORD); weak
// __int64 __fastcall FontEncFind(_QWORD, _QWORD); weak
void fs_register_fpe_functions(void);
__int64 __fastcall FontFileSortTable(_QWORD); // weak
// __int64 __fastcall FT_Select_Charmap(_QWORD, _QWORD); weak
// __int64 __fastcall FT_Get_Sfnt_Table(_QWORD, _QWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
__int64 __fastcall FontFileFreeTable(_QWORD); // weak
// int memcmp(const void *s1, const void *s2, size_t n);
__int64 __fastcall _fs_unmark_block(_QWORD, _QWORD); // weak
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
__int64 __fastcall FontFileOpen(char *s); // idb
__int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD); // weak
// void *calloc(size_t nmemb, size_t size);
char *NameForAtom(Atom atom);
__int64 __fastcall pcfReadFont(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
Font GetNewFontClientID(void);
__int64 __fastcall FontFileFindScaledInstance(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _fs_flush(_QWORD); // weak
// int strcmp(const char *s1, const char *s2);
FontResolutionPtr GetClientResolutions(int *);
// __int64 __fastcall FT_MulFix(_QWORD, _QWORD); weak
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 strtol(const char *nptr, char **endptr, int base);
void EmptyFontPatternCache(FontPatternCachePtr);
// void *memcpy(void *dest, const void *src, size_t n);
__int64 __fastcall bdfGetLine(_QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall inflateEnd(_QWORD); weak
// int inet_pton(int af, const char *cp, void *buf);
void TwoByteSwap(unsigned __int8 *, int);
__int64 __fastcall FontFileDirectoryChanged(_QWORD); // weak
__int64 __fastcall _FontTransGetHostname(char *dest); // idb
// int fileno(FILE *stream);
// __int64 __fastcall __stpcpy_chk(_QWORD, _QWORD, _QWORD); weak
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// __int64 __fastcall FT_Get_BDF_Charset_ID(_QWORD, _QWORD, _QWORD); weak
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
void FreeFontNames(FontNamesPtr);
// struct dirent *readdir(DIR *dirp);
__int64 __fastcall fs_build_range(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall bitmapComputeFontBounds(_QWORD); // weak
__int64 __fastcall _fs_convert_char_info(_QWORD, _QWORD); // weak
__int64 __fastcall FontCouldBeTerminal(_QWORD); // weak
__int64 __fastcall bdfReadFont(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall FontFileFindNameInScalableDir(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall pcfError(_QWORD); // weak
// void *malloc(size_t size);
// int fflush(FILE *stream);
// int _IO_getc(_IO_FILE *fp);
__int64 __fastcall FTRemap(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall BufFileWrite(_QWORD, _QWORD); // weak
__int64 __fastcall FTPickMapping(_QWORD, _QWORD, _QWORD); // weak
// int ungetc(int c, FILE *stream);
__int64 __fastcall BitmapOpenScalable(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall SPropRecValList_add_by_font_cap(_QWORD, _QWORD); // weak
__int64 __fastcall BuiltinFileClose(_QWORD, _QWORD); // weak
// int __fxstat(int ver, int fildes, struct stat *stat_buf);
Atom MakeAtom(char *string, unsigned int len, int makeit);
// int sscanf(const char *s, const char *format, ...);
__int64 __fastcall _fs_io_reinit(_QWORD); // weak
__int64 __fastcall GetTimeInMillis(_QWORD); // weak
__int64 __fastcall bitmapComputeFontInkBounds(_QWORD); // weak
__int64 __fastcall FontFilePriorityRegisterRenderer(_QWORD, _QWORD); // weak
__int64 __fastcall FontFileAddScaledInstance(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall FontFileClose(_QWORD); // weak
// __int64 __fastcall __strncpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall _fs_clean_aborted_loadglyphs(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall bdfGetPropertyValue(char *string); // idb
// void *realloc(void *ptr, size_t size);
// __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall _fs_mark_block(_QWORD, _QWORD); // weak
__int64 __fastcall FontFileFreeDir(void *ptr); // idb
// __int64 __fastcall __printf_chk(_QWORD, _QWORD); weak
__int64 __fastcall BufFilePushZIP(_QWORD, _QWORD); // weak
// __int64 __fastcall FT_Get_Char_Index(_QWORD, _QWORD); weak
__int64 CatalogueRegisterLocalFpeFunctions(void); // weak
__int64 FontFileUnregisterBitmapSource(void); // weak
// ssize_t readv(int fd, const struct iovec *iovec, int count);
int RepadBitmap(char *, char *, unsigned int, unsigned int, int, int);
__int64 __fastcall SPropRecValList_search_record(_QWORD, _QWORD, _QWORD); // weak
// void *memmove(void *dest, const void *src, size_t n);
__int64 __fastcall FontParseXLFDName(char *dest); // idb
int client_auth_generation(ClientPtr client);
__int64 __fastcall _FontTransRead(_QWORD, _QWORD, _QWORD); // weak
__int64 _FontTransOpenCOTSClient(void); // weak
// __int64 __fastcall FT_Render_Glyph(_QWORD, _QWORD); weak
// int open(const char *file, int oflag, ...);
__int64 __fastcall bdfIsInteger(_QWORD); // weak
__int64 __fastcall _FontTransSetOption(_QWORD, _QWORD, _QWORD); // weak
// FILE *fopen(const char *filename, const char *modes);
// __int64 __fastcall inflateInit2_(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 BuiltinRegisterFpeFunctions(void); // weak
// __int64 sysconf(int name);
// __int64 __fastcall FT_Set_Transform(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FT_Vector_Transform(_QWORD, _QWORD); weak
FontNamesPtr MakeFontNamesRecord(unsigned int);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// double sin(double x);
// double floor(double x);
int init_fs_handlers(FontPathElementPtr fpe, BlockHandlerProcPtr block_handler);
// char *strcat(char *dest, const char *src);
// int creat(const char *file, mode_t mode);
int ClientSignal(ClientPtr client);
void remove_fs_handlers(FontPathElementPtr fpe, BlockHandlerProcPtr block_handler, int all);
__int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD); // weak
__int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD); // weak
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
__int64 __fastcall sub_192F0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall FontFileSwitchStringsToBitmapPointers(_QWORD); // weak
__int64 __fastcall FontFileAddFontFile(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall FT_Has_PS_Glyph_Names(_QWORD); weak
__int64 __fastcall FontParseRanges(_QWORD, _QWORD); // weak
// double hypot(double x, double y);
__int64 BitmapRegisterFontFileFunctions(void); // weak
__int64 __fastcall CheckFSFormat(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall FT_Set_Char_Size(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall _FontTransGetConnectionNumber(_QWORD); // weak
__int64 __fastcall find_old_font(_QWORD); // weak
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// char *strdup(const char *s);
__int64 __fastcall FontFileMatchRenderer(_QWORD); // weak
__int64 __fastcall pcfReadFontInfo(_QWORD, _QWORD); // weak
__int64 FontFileRemoveScaledInstance(void); // weak
// double ceil(double x);
void BitOrderInvert(unsigned __int8 *, int);
void FreeTypeRegisterFontFileFunctions(void);
__int64 __fastcall set_font_authorizations(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall bdfSpecialProperty(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall fs_alloc_glyphs(_QWORD, _QWORD); // weak
void FontFileRegisterFpeFunctions(void);
// char *strstr(const char *haystack, const char *needle);
__int64 __fastcall bdfWarning(_QWORD, _QWORD); // weak
__int64 __fastcall _fs_convert_props(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall FT_Get_Sfnt_Name(_QWORD, _QWORD, _QWORD); weak
// int rand(void);
// const __int32_t **__ctype_tolower_loc(void);
void FourByteSwap(unsigned __int8 *, int);
// const unsigned __int16 **__ctype_b_loc(void);
// void freeaddrinfo(struct addrinfo *ai);
__int64 __fastcall ErrorF(_QWORD); // weak
__int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD); // weak
// __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double); weak
// int socket(int domain, int type, int protocol);
__int64 __fastcall _fs_free_props(_QWORD); // weak
int j_FontFileInitFPE(FontPathElementPtr fpe); // idb
int j_FontFileFreeFPE(FontPathElementPtr fpe); // idb
int j_FontFileListNextFontOrAlias(pointer client, FontPathElementPtr fpe, char **namep, int *namelenp, char **resolvedp, int *resolvedlenp, pointer c_private); // idb
int j_FontFileListNextFontWithInfo(pointer client, FontPathElementPtr fpe, char **name, int *namelen, FontInfoPtr *info, int *numFonts, pointer c_private); // idb
void j_FontFileCloseFont(FontPathElementPtr fpe, FontPtr pFont); // idb
__int64 j_bitmapGetGlyphs(void); // weak
int j_FontFileOpenFont(pointer client, FontPathElementPtr fpe, Mask flags, char *name, int namelen, fsBitmapFormat format, fsBitmapFormatMask fmask, XID id, FontPtr *pFont, char **aliasName, FontPtr non_cachable_font); // idb
int j_FontFileListFonts(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, FontNamesPtr names); // idb
// __int64 __fastcall _cxa_finalize(_QWORD); weak
const char *__fastcall start(char *a1, int a2, double a3);
__int64 (**sub_9300())(void);
__int64 sub_9340();
__int64 (**sub_9390())(void);
__int64 sub_93D0();
signed __int64 __fastcall FontFileRegisterBitmapSource(__int64 a1);
void __fastcall FontFileUnregisterBitmapSource(__int64 a1);
void FontFileEmptyBitmapSource();
__int64 __fastcall FontFileMatchBitmapSource(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7, unsigned int a8, unsigned int a9);
__int64 __fastcall sub_96C0(__int64 a1);
signed __int64 __fastcall sub_96F0(__int64 a1, int a2);
signed __int64 __fastcall sub_9720(__int64 a1);
signed __int64 __fastcall sub_9760(unsigned __int64 *a1, unsigned int a2);
__int64 __fastcall sub_9840(unsigned int a1, __int64 a2);
_QWORD *__fastcall BufFileCreate(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall BufFileOpenRead(int a1);
__int64 __fastcall BufFileOpenWrite(int a1);
__int64 __fastcall BufFileRead(__int64 a1, __int64 a2, int a3);
__int64 __fastcall BufFileWrite(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall BufFileClose(void *ptr); // idb
signed __int64 __fastcall sub_9AA0(__int64 a1);
__int64 __fastcall sub_9EE0(__int64 a1, int a2);
signed __int64 __fastcall sub_9F30(__int64 a1);
__int64 __fastcall BufFilePushCompressed(__int64 a1);
void __fastcall FontDefaultFormat(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
__int64 __fastcall sub_A150(_IO_FILE *fp, _QWORD *a2);
__int64 __fastcall FontFileReadDirectory(char *s, __int64 *a2, double a3);
_BOOL8 __fastcall FontFileDirectoryChanged(__int64 a1);
__int64 __fastcall FontFileOpen(char *s); // idb
__int64 __fastcall FontFileClose(void *a1);
__int64 __fastcall FontFileOpenWrite(const char *a1);
signed __int64 __fastcall sub_B2F0(unsigned __int8 *a1, unsigned __int8 *a2);
signed __int64 __fastcall compar(const void *a1, const void *a2);
__int64 __fastcall sub_B3A0(__int64 a1, char *a2, __int16 a3, signed int *a4, int *a5, _DWORD *a6);
__int64 __fastcall sub_B570(char *a1, int a2, _BYTE *a3, unsigned int a4);
signed __int64 __fastcall FontFileInitTable(__int64 a1, unsigned int a2);
void __fastcall FontFileFreeEntry(void **a1);
void __fastcall FontFileFreeTable(_DWORD *a1);
char *__fastcall FontFileMakeDir(char *s, unsigned int a2);
void __fastcall FontFileFreeDir(void *ptr);
__m128i *__fastcall FontFileAddEntry(signed int *a1, const __m128i *a2);
void __fastcall FontFileSortTable(void **a1);
__int64 __fastcall FontFileSortDir(__int64 a1);
__int64 __fastcall FontFileCountDashes(__int64 a1, unsigned int a2);
signed __int64 __fastcall FontFileFindNameInScalableDir(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall FontFileFindNameInDir(__int64 a1, __int64 a2);
__int64 __fastcall FontFileFindNamesInScalableDir(__int64 a1, __int64 a2, int a3, struct _FontNames *a4, _DWORD *a5, int a6, _DWORD *a7);
__int64 __fastcall FontFileFindNamesInDir(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_BOOL8 __fastcall FontFileMatchName(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall FontFileAddFontFile(__int64 a1, char *a2, const char *a3);
signed __int64 __fastcall FontFileAddFontAlias(__int64 a1, char *a2, const char *a3);
__int64 __fastcall font_encoding_recode(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall font_encoding_name(__int64 a1, __int64 a2, __int64 a3);
_BOOL8 __fastcall FontFileNameCheck(_BYTE *a1);
signed __int64 __fastcall FontFileFreeFPE(__int64 a1);
__int64 __fastcall FontFileInitFPE(FontPathElementPtr fpe); // idb
__int64 __fastcall sub_C960(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6, __int64 a7);
__int64 __fastcall sub_CAB0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall FontFileCloseFont(__int64 a1, __int64 a2);
__int64 __fastcall FontFileListNextFontOrAlias(void *ptr, __int64 a2, char **a3, int *a4, _QWORD *a5, _DWORD *a6, signed int *ptra);
signed __int64 __fastcall FontFileResetFPE(__int64 a1, __int64 a2);
void __fastcall sub_CCE0(_BYTE *a1, char *a2, int a3);
signed __int64 __fastcall sub_CD50(char *a1, int a2, const char *a3, char **a4, const __m128i *a5);
unsigned __int64 __fastcall sub_D0B0(struct _FontNames *a1, int *a2, __int64 a3, char *a4, const __m128i *a5, __int64 a6, __int32 a7, _DWORD *a8);
// void __usercall sub_DB58(__int64 a1@<rax>, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7, unsigned int a8, __int64 a9, __int64 a10);
void __fastcall sub_DB9A(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, _QWORD *a10, __int64 a11, int a12, unsigned int a13, __int64 a14, __int64 a15);
void __fastcall sub_DBF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, _QWORD *a10, __int64 a11);
signed __int64 __fastcall FontFileOpenFont(__int64 a1, __int64 a2, unsigned int a3, char *a4, int a5, unsigned int a6, unsigned int a7, __int64 a8, _QWORD *a9, __int128 a10);
__int64 __fastcall sub_DD70(__int64 *a1, char *a2, int a3, unsigned int a4, struct _FontNames *a5, int a6);
__int64 __fastcall FontFileListFonts(__int64 a1, __int64 a2, char *a3, int a4, unsigned int a5, struct _FontNames *a6);
__int64 __fastcall sub_E130(__int64 a1, char **a2, unsigned int *a3, __int64 *a4);
__int64 __fastcall FontFileListNextFontWithInfo(void *ptr, __int64 a2, char **a3, _DWORD *a4, __int64 *a5, _DWORD *a6, FontNamesPtr *ptra);
__int64 __fastcall FontFileOpenBitmap(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6);
__int64 __fastcall FontFileStartListFonts(__int64 a1, __int64 a2, char *a3, int a4, unsigned int a5, _QWORD *a6, int a7);
__int64 __fastcall FontFileStartListFontsWithInfo(__int64 a1);
__int64 __fastcall FontFileStartListFontsAndAliases(__int64 a1);
int FontFileRegisterLocalFpeFunctions();
signed __int64 __fastcall FontFileAddScaledInstance(__int64 a1, const __m128i *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall FontFileSwitchStringsToBitmapPointers(__int64 a1);
signed __int64 __fastcall FontFileRemoveScaledInstance(__int64 a1, __int64 a2);
signed __int64 __fastcall FontFileCompleteXLFD(unsigned int *a1, __int64 a2);
__int64 __fastcall FontFileFindScaledInstance(__int64 a1, double *a2, int a3);
__int64 __fastcall sub_F4D0(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_F520(__int64 a1);
signed __int64 __fastcall sub_F560(__int64 a1);
__int64 __fastcall BufFilePushZIP(__int64 a1);
__int64 FontFileRegisterFpeFunctions();
__int64 __fastcall FontFilePriorityRegisterRenderer(__int64 a1, int a2);
__int64 __fastcall FontFileRegisterRenderer(__int64 a1);
const char **__fastcall FontFileMatchRenderer(const char *a1);
signed __int64 __fastcall sub_FE30(FontPathElementPtr fpe);
int __fastcall sub_FE40(pointer client, FontPathElementPtr fpe, char **namep, int *namelenp, char **resolvedp, int *resolvedlenp, pointer c_private);
signed __int64 __fastcall sub_FEF0(const void *a1, const void *a2);
int __fastcall sub_FFC0(pointer client, FontPathElementPtr fpe, char **name, int *namelen, FontInfoPtr *info, int *numFonts, pointer c_private);
void j_j_FontFileCloseFont(FontPathElementPtr fpe, FontPtr pFont); // idb
_BOOL8 __fastcall sub_10080(char *name);
void __fastcall sub_100B0(__int64 a1);
__int64 __fastcall sub_10130(__int64 a1, int a2);
signed __int64 __fastcall sub_10480(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6);
signed __int64 __fastcall sub_10570(pointer client, FontPathElementPtr fpe, char *pat, __int64 len, __int64 max, pointer *privatep);
signed __int64 __fastcall sub_10580(pointer client, FontPathElementPtr fpe, char *pat, __int64 len, __int64 max, pointer *privatep);
__int64 __fastcall sub_10590(FontPathElementPtr fpe);
signed __int64 __fastcall sub_105E0(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, FontNamesPtr names);
int __fastcall sub_10660(pointer client, FontPathElementPtr fpe, Mask flags, char *name, int namelen, fsBitmapFormat format, fsBitmapFormatMask fmask, XID id, FontPtr *pFont, char **aliasName, FontPtr non_cachable_font);
int __fastcall sub_10710(FontPathElementPtr fpe);
int CatalogueRegisterLocalFpeFunctions();
signed __int64 __fastcall FTPickMapping(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall FTRemap(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_10D30(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_10D90(unsigned __int16 *a1, __int16 *a2, unsigned __int16 *a3, _WORD *a4, unsigned __int8 *a5, int a6);
__int64 __fastcall sub_10EE0(int a1, unsigned __int16 *a2, __int16 *a3, unsigned __int16 *a4, _WORD *a5, const char *a6);
__int64 __fastcall sub_11180(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5, _DWORD *a6);
void __fastcall sub_11300(void *ptr);
void __fastcall sub_113D0(void *ptr);
signed __int64 __fastcall sub_11620(int a1, char a2, unsigned int *a3, int a4, _QWORD *a5, _QWORD *a6, _DWORD *a7, int *a8, int *a9);
__int64 __fastcall sub_11840(__int64 a1);
__int64 __fastcall sub_118D0(__int64 a1, _WORD *a2, __int64 a3, const char *a4, __int64 a5, __int64 a6, const __m128i *a7, int a8, unsigned __int64 *a9, const char *a10, int a11);
void __fastcall sub_12690(FontPtr font);
signed __int64 __fastcall sub_126F0(unsigned int a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_12760(__int64 a1, __int64 a2, unsigned __int16 a3, __m128i *a4);
signed __int64 __fastcall sub_12830(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, signed __int64 *a6, double a7, __int64 *a8, _QWORD *a9);
signed __int64 __fastcall sub_12C20(unsigned int a1, char a2, signed __int16 *a3, double *a4, int a5);
signed __int64 __fastcall sub_13FF0(unsigned int a1, char a2, signed __int16 **a3, __int64 a4);
signed __int64 __fastcall sub_14170(unsigned int a1, char a2, signed __int16 **a3, __int64 a4);
signed __int64 __fastcall sub_14250(__int64 a1, __int64 a2, __int16 *a3, unsigned int a4, signed __int64 *a5, __int64 a6);
__int64 __fastcall sub_143E0(unsigned int a1, char a2, signed __int16 **a3, __int64 a4);
signed __int64 __fastcall sub_145E0(__int64 a1, __int64 a2, __int16 *a3, unsigned int a4, signed __int64 *a5, signed __int64 *a6);
__int64 __fastcall sub_148D0(char *s, __int64 a2, size_t a3, unsigned __int16 *a4, const __m128i *a5, char *a6);
__int64 __fastcall sub_18790(__int64 a1, unsigned __int16 *a2, char *a3, __int64 a4, char *a5, __int64 a6);
__int64 __fastcall sub_18820(__int64 a1, FontPtr *a2, __int64 a3, char *a4, char *a5, __int64 a6, unsigned int a7, unsigned int a8);
__int64 FreeTypeRegisterFontFileFunctions();
signed __int64 __fastcall sub_18980(__int64 a1, int a2, int a3, int a4, __m128i *a5);
__int64 __fastcall FTtoXReturnCode(int a1);
__int64 __fastcall FTGetEnglishName(__int64 a1, int a2, _BYTE *a3, signed int a4);
__int64 __fastcall sub_18C10(double **a1, const char *a2, char *a3);
__int64 __fastcall SPropRecValList_new(_QWORD *a1);
signed __int64 __fastcall SPropRecValList_search_record(__int64 *a1, _QWORD *a2, const char *a3);
signed __int64 __fastcall SPropRecValList_add_by_font_cap(double **a1, const char *a2);
void __fastcall sub_191E0(__int64 a1);
void __fastcall sub_192E0(FontPtr font);
signed __int64 __fastcall sub_192F0(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6, int a7);
__int64 __fastcall bdfReadFont(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6);
__int64 __fastcall bdfReadFontInfo(__m128i *a1, __int64 a2);
unsigned __int64 bdfError(__int64 a1, ...);
unsigned __int64 bdfWarning(__int64 a1, ...);
unsigned __int64 __fastcall bdfGetLine(__int64 a1, unsigned __int64 a2, int a3);
Atom __fastcall bdfForceMakeAtom(char *string, _DWORD *a2);
__int64 __fastcall bdfGetPropertyValue(char *string); // idb
signed __int64 __fastcall bdfIsInteger(char *a1);
__int64 __fastcall bdfHexByte(__int64 a1);
signed __int64 __fastcall bdfSpecialProperty(_WORD *a1, Atom *a2, char a3, __int64 a4);
signed __int64 __fastcall bitmapGetGlyphs(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned int a4, signed __int64 *a5, _QWORD *a6);
__int64 __fastcall bitmapGetMetrics(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 *a5, __int64 a6);
signed __int64 __fastcall sub_1C080(__int64 a1, __int64 a2, __int64 a3, char *a4);
__int64 __fastcall sub_1C100(__int64 a1, FontPtr *a2, __int64 a3, __int64 a4, char *a5, unsigned int a6, unsigned int a7);
__int64 BitmapRegisterFontFileFunctions();
__int16 __fastcall bitmapComputeFontBounds(__int64 a1);
signed __int64 __fastcall bitmapComputeFontInkBounds(__int64 a1);
signed __int64 __fastcall bitmapAddInkMetrics(__int64 a1);
signed __int64 bitmapComputeWeight();
signed __int64 __fastcall sub_1CAF0(__int64 a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7);
signed __int64 __fastcall sub_1CCD0(double *a1, __int64 a2, double *a3, double *a4, _QWORD *a5, double a6, double a7);
void __fastcall sub_1CE90(FontPtr font);
__int64 __fastcall BitmapOpenScalable(__int64 a1, FontPtr *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7, unsigned int a8);
__int64 __fastcall BitmapGetInfoScalable(__int64 a1, __m128i *a2, __int64 a3);
unsigned __int64 __fastcall FontCharInkMetrics(__int64 a1, signed __int16 *a2, _WORD *a3);
__int64 __fastcall FontCharReshape(__int64 a1, signed __int16 *a2, signed __int16 *a3);
__int64 __fastcall sub_207D0(unsigned __int8 **a1);
__int64 __fastcall sub_208E0(__int64 a1, char a2);
__int64 __fastcall sub_20AE0(__int64 a1, char a2);
_BOOL8 __fastcall sub_20BE0(__int64 a1, char a2, _WORD *a3);
signed __int64 __fastcall sub_20C50(__int64 a1, _DWORD *a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
_BOOL8 __fastcall sub_20D00(__int64 a1, __int64 a2, _DWORD *a3, int a4, int a5);
void __fastcall sub_210F0(FontPtr font);
_BOOL8 __fastcall sub_211C0(__int64 a1, _WORD *a2);
unsigned __int64 pcfError(__int64 a1, ...);
char *__fastcall sub_21450(__int64 a1, unsigned int *a2);
signed __int64 __fastcall sub_21570(__int64 a1, __int64 a2, _DWORD *a3, int a4);
signed __int64 __fastcall pcfReadFont(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5, signed int a6);
signed __int64 __fastcall pcfReadFontInfo(unsigned __int16 *a1, unsigned __int8 **a2);
__int64 __fastcall sub_22690(__int64 a1, unsigned int a2);
__int64 __fastcall sub_22770(__int64 a1, char a2, unsigned int a3);
__int64 __fastcall sub_22950(__int64 a1, char a2, int a3);
__int64 __fastcall sub_22A20(__int64 a1, char a2, signed __int16 *a3);
__int64 __fastcall sub_22A90(__int64 a1, unsigned __int8 a2);
char __fastcall sub_22AD0(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_22C20(__int64 a1, unsigned __int16 *a2);
signed __int64 __fastcall pcfWriteFont(__int64 a1, __int64 a2);
void __fastcall sub_23C80(FontPtr font);
unsigned __int64 sub_23CB0(__int64 a1, ...);
signed __int64 __fastcall sub_23DA0(_DWORD *a1, __int64 a2);
signed __int64 __fastcall sub_23DE0(_DWORD *a1, int a2, Atom **a3, _QWORD *a4, __int64 a5);
void __fastcall SnfSetFormat(int a1, int a2, int a3, int a4);
__int64 __fastcall snfReadFont(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5, int a6);
__int64 __fastcall snfReadFontInfo(__int64 a1, __int64 a2);
signed __int64 __fastcall BuiltinReadDirectory(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_24F50(unsigned __int64 *a1, unsigned int a2);
signed __int64 __fastcall sub_24FC0(__int64 a1);
signed __int64 __fastcall sub_24FE0(__int64 a1);
__int64 __fastcall BuiltinFileOpen(_BYTE *a1);
__int64 __fastcall BuiltinFileClose(void *a1);
signed __int64 __fastcall sub_25200(FontPathElementPtr fpe);
signed __int64 __fastcall sub_25210(FontPathElementPtr fpe);
__int64 __fastcall sub_25230(FontPathElementPtr fpe);
_BOOL8 __fastcall sub_25280(char *name);
int BuiltinRegisterFpeFunctions();
signed __int64 sub_25300();
signed __int64 sub_25310();
__int64 __fastcall sub_25320(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_25360(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6, unsigned int a7);
__int64 BuiltinRegisterFontFileFunctions();
signed __int64 __fastcall sub_254C0(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned int a4, signed __int64 *a5, __int64 *a6);
__int64 __fastcall sub_25730(FontPtr pfont, signed __int64 a2, unsigned __int8 *a3, unsigned int a4, signed __int64 *a5, _QWORD *a6);
__int64 __fastcall fs_convert_char_info(_WORD *a1, _WORD *a2);
__int64 __fastcall fs_init_fontinfo(__int64 a1, __int16 *a2);
__int64 __fastcall fs_convert_props(unsigned int *a1, unsigned int *a2, __int64 a3, __int64 a4);
void __fastcall fs_free_props(__int64 a1);
void __fastcall sub_25EC0(FontPtr font);
__int64 __fastcall fs_convert_lfwi_reply(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall fs_build_range(__int64 a1, int a2, unsigned int a3, int a4, unsigned __int8 *a5, __int64 a6, __int64 a7);
unsigned __int64 __fastcall fs_clean_aborted_loadglyphs(__int64 a1, signed int a2, unsigned __int8 *a3);
FontPtr __fastcall fs_create_font(struct _FontPathElement *a1, const void *a2, int a3, fsBitmapFormat a4, int a5);
signed __int64 __fastcall fs_alloc_glyphs(__int64 a1, int a2);
__int64 __fastcall sub_26AD0(__int64 a1, _DWORD *a2);
void __fastcall sub_26B90(__int64 *a1);
void __fastcall block_handler(pointer a1, OSTimePtr a2, pointer a3);
unsigned __int64 __fastcall sub_26DB0(__int64 a1);
_BOOL8 __fastcall sub_26E50(char *name);
char *__fastcall sub_26E90(const char *a1);
__int64 __fastcall sub_26EC0(__int64 a1);
signed __int64 __fastcall sub_27130(FontPathElementPtr fpe);
_BOOL8 __fastcall sub_27150(__int64 a1);
signed __int64 __fastcall sub_271D0(__int64 a1, int a2);
void __fastcall sub_27230(FontPathElementPtr fpe, FontPtr pFont);
signed __int64 __fastcall sub_27270(signed __int64 *a1);
_QWORD *__fastcall sub_272E0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_27370(__int64 a1, int *a2, _QWORD *a3);
unsigned __int64 __fastcall sub_27710(__int64 a1, struct _Client *a2);
void __fastcall fs_mark_block(__int64 a1, int a2);
__int64 __fastcall sub_27910(__int64 a1);
__int64 __fastcall sub_27930(__int64 a1);
signed __int64 __fastcall sub_27950(__int64 a1, __int64 a2, int a3, char *a4);
signed __int64 __fastcall sub_27B60(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, pointer *privatep);
__int64 __fastcall fs_unmark_block(__int64 a1, int a2);
__int64 __fastcall sub_27D30(__int64 a1);
__int64 __fastcall sub_27DB0(__int64 a1);
void __fastcall sub_282B0(void *ptr);
__int64 __fastcall sub_282E0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_283D0(__int64 a1, int *a2);
void __fastcall client_died(pointer client, FontPathElementPtr fpe);
signed __int64 __fastcall sub_285E0(pointer client, FontPathElementPtr fpe, char **name, int *namelen, FontInfoPtr *info, int *numFonts);
signed __int64 __fastcall sub_28730(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, FontNamesPtr names);
unsigned __int64 __fastcall sub_288D0(__int64 a1, struct _Client *a2);
__int64 __fastcall sub_29CC0(__int64 a1);
signed __int64 __fastcall sub_29D50(FontPathElementPtr fpe);
signed __int64 __fastcall sub_29E20(FontPathElementPtr fpe);
void __fastcall fs_connection_died(__int64 a1);
signed __int64 __fastcall sub_29FE0(__int64 a1);
signed __int64 __fastcall sub_2A070(__int64 a1, __int64 a2, int a3, char *a4, unsigned int a5, unsigned int a6, unsigned int a7, __int64 *a8);
signed __int64 __fastcall load_glyphs(pointer client, FontPtr pfont, int range_flag, unsigned int nchars, int item_size, unsigned __int8 *data);
signed __int64 __fastcall sub_2A7C0(pointer client, FontPathElementPtr fpe, Mask flags, char *name, int namelen, fsBitmapFormat format, fsBitmapFormatMask fmask, XID id, FontPtr *pFont, char **aliasName);
__int64 __fastcall wakeup_func(FontPathElementPtr fpe, unsigned __int64 *LastSelectMask);
__int64 __fastcall fs_load_all_glyphs(FontPtr pfont); // idb
int fs_register_fpe_functions();
signed __int64 __fastcall sub_2AAE0(_QWORD *a1, __int64 a2);
signed __int64 __fastcall fs_poll_connect(__int64 a1, int a2);
void *__fastcall fs_connect(__int64 a1, signed int *a2);
char *__fastcall fs_done_read(__int64 a1, __int64 a2);
__int64 __fastcall fs_pad_length(__int64 a1);
signed __int64 __fastcall fs_flush(__int64 a1);
void __fastcall fs_io_reinit(__int64 a1);
__int64 __fastcall fs_io_init(_QWORD *a1);
void __fastcall fs_io_fini(__int64 a1);
signed __int64 __fastcall fs_write(__int64 a1, const void *a2, size_t a3);
signed __int64 __fastcall fs_write_pad(__int64 a1, __int64 a2, __int64 a3);
int __fastcall fs_wait_for_readable(__int64 a1, int a2);
signed __int64 __fastcall fs_start_read(_QWORD *a1, __int64 a2, _QWORD *a3);
unsigned __int64 sub_2B450(__int64 a1, ...);
unsigned __int64 sub_2B530(int a1, __int64 a2, ...);
int __fastcall sub_2B640(__int64 a1);
ssize_t __fastcall sub_2B670(__int64 a1, void *a2, unsigned int a3);
signed __int64 __fastcall sub_2B6B0(__int64 a1, unsigned int a2, unsigned int a3);
int __fastcall sub_2B6E0(__int64 a1);
int __fastcall sub_2B710(__int64 a1);
ssize_t __fastcall sub_2B740(__int64 a1, const struct iovec *a2, unsigned int a3);
ssize_t __fastcall sub_2B780(__int64 a1, const struct iovec *a2, unsigned int a3);
ssize_t __fastcall sub_2B7C0(__int64 a1, const void *a2, unsigned int a3);
int __fastcall sub_2B800(__int64 a1, __int64 a2);
__int64 __fastcall sub_2B840(int a1, const char *a2);
_DWORD *__fastcall sub_2B8E0(unsigned int a1, unsigned int a2);
_DWORD *__fastcall sub_2BAA0(const char *a1, __int64 a2, __int64 a3, __int64 a4, int a5);
_DWORD *__fastcall sub_2BB50(const char **a1, __int64 a2, __int64 a3, __int64 a4);
_DWORD *__fastcall sub_2BB60(const char **a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_2BC10(__int64 a1);
void __fastcall FontTransFreeConnInfo(void *ptr);
unsigned int __fastcall FontTransSetOption(__int64 a1, unsigned int a2, unsigned int a3);
__int64 __fastcall FontTransBytesReadable(__int64 a1);
__int64 __fastcall FontTransRead(__int64 a1);
__int64 __fastcall FontTransWrite(__int64 a1);
__int64 __fastcall FontTransReadv(__int64 a1);
__int64 __fastcall FontTransWritev(__int64 a1);
__int64 __fastcall FontTransDisconnect(__int64 a1);
__int64 __fastcall FontTransClose(void *ptr); // idb
__int64 __fastcall FontTransCloseForCloning(void *ptr); // idb
_BOOL8 __fastcall FontTransIsLocal(__int64 a1);
signed __int64 __fastcall FontTransGetMyAddr(__int64 a1, _DWORD *a2, _DWORD *a3, _QWORD *a4);
signed __int64 __fastcall FontTransGetPeerAddr(__int64 a1, _DWORD *a2, _DWORD *a3, _QWORD *a4);
__int64 __fastcall FontTransGetConnectionNumber(__int64 a1);
__int64 __fastcall FontTransGetHostname(char *dest, int a2);
signed __int64 __fastcall sub_2C010(__int64 a1, char *a2, char *a3);
signed __int64 __fastcall sub_2C820(unsigned int *a1, const char *a2, const char *a3);
__int64 __fastcall sub_2CCA0(char *s, void **a2, void **a3, char **a4);
char ***__fastcall sub_2CFB0(unsigned int a1, char *a2);
char ***__fastcall FontTransOpenCOTSClient(char *a1);
char ***__fastcall FontTransOpenCLTSClient(char *a1);
__int64 __fastcall FontTransConnect(unsigned int *a1, char *a2);
__int64 __fastcall MakeAtom(const char *a1, unsigned int a2, int a3);
_BOOL8 __fastcall ValidAtom(unsigned __int64 a1);
__int64 __fastcall NameForAtom(unsigned __int64 a1);
__int64 __fastcall FontComputeInfoAccelerators(__int64 a1);
_BOOL8 __fastcall FontCouldBeTerminal(__int64 a1);
void __fastcall FreeFontNames(void *ptr);
_QWORD *__fastcall MakeFontNamesRecord(unsigned int a1);
signed __int64 __fastcall AddFontNamesName(signed int *a1, const char *a2, int a3);
unsigned __int64 __fastcall QueryGlyphExtents(_WORD *a1, unsigned __int64 *a2, unsigned __int64 a3, int *a4);
signed __int64 __fastcall QueryTextExtents(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// signed __int64 __usercall ParseGlyphCachingMode@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>);
void *InitGlyphCaching();
void *__fastcall SetGlyphCachingMode(int a1);
__int64 __fastcall add_range(unsigned __int8 *a1, int *a2, void **a3, int a4);
signed __int64 __fastcall sub_2E480(char *a1, double *a2);
char *__fastcall sub_2E610(char *a1, int *a2, int a3);
__int64 xlfd_round_double();
__int64 __fastcall FontParseXLFDName(char *dest, double *a2, signed int a3);
__int64 __fastcall FontParseRanges(const char *a1, _DWORD *a2);
signed __int64 __fastcall CheckFSFormat(unsigned int a1, char a2, int *a3, int *a4, int *a5, int *a6, int *a7);
void register_fpe_functions();
__int64 __fastcall EmptyFontPatternCache(_QWORD *a1);
struct _FontPatternCache *MakeFontPatternCache();
void __fastcall FreeFontPatternCache(void *ptr);
void *__fastcall CacheFontPattern(signed __int64 a1, char *a2, int a3, void *a4);
__int64 __fastcall FindCachedFontPattern(__int64 a1, char *a2, int a3);
void __fastcall RemoveCachedFontPattern(__int64 a1, __int64 a2);
__int64 AllocateFontPrivateIndex();
_DWORD *CreateFontRec();
void __fastcall DestroyFontRec(void *ptr);
void ResetFontPrivateIndex();
signed __int64 __fastcall FontSetNewPrivate(__int64 a1, int a2, __int64 a3);
__int64 __fastcall BitOrderInvert(unsigned __int8 *a1, int a2);
__int64 __fastcall TwoByteSwap(unsigned __int8 *a1, int a2);
__int64 __fastcall FourByteSwap(char *a1, int a2);
__int64 __fastcall RepadBitmap(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int a4, int a5, int a6);
__int64 client_auth_generation();
signed __int64 ClientSignal();
__int64 find_old_font();
__int64 GetClientResolutions();
__int64 GetDefaultPointSize();
__int64 GetNewFontClientID();
__int64 GetTimeInMillis();
signed __int64 init_fs_handlers();
__int64 RegisterFPEFunctions();
__int64 set_font_authorizations();
__int64 StoreFontClientFont();
void term_proc();
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

size_t dword_0 = 282584257676671uLL; // idb
char byte_4 = '\x02'; // weak
_UNKNOWN loc_D75C; // weak
_UNKNOWN loc_D7A4; // weak
_UNKNOWN loc_DBE0; // weak
_UNKNOWN loc_DC01; // weak
_UNKNOWN loc_20068; // weak
_UNKNOWN loc_2AEFB; // weak
_BYTE byte_300C0[9] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 }; // idb
__int128 xmmword_30160 = 9223372036854775807LL; // weak
_UNKNOWN unk_304A0; // weak
char aRawPixel[10] = "RAW_PIXEL_"; // idb
char aRaw[4] = "RAW_"; // idb
__int128 xmmword_30670 = 0x08000000000000000LL; // weak
signed int builtin_alias_count = 3; // idb
signed int builtin_dir_count = 2; // idb
_UNKNOWN builtin_files_count; // weak
signed int dword_33FC0[4] = { 48, 32, 8, 360 }; // idb
signed int dword_34040[4] = { 0, 3, 2, 1 }; // idb
_UNKNOWN unk_34AF8; // weak
unsigned __int8 byte_34B20[256] =
{
  0u,
  128u,
  64u,
  192u,
  32u,
  160u,
  96u,
  224u,
  16u,
  144u,
  80u,
  208u,
  48u,
  176u,
  112u,
  240u,
  8u,
  136u,
  72u,
  200u,
  40u,
  168u,
  104u,
  232u,
  24u,
  152u,
  88u,
  216u,
  56u,
  184u,
  120u,
  248u,
  4u,
  132u,
  68u,
  196u,
  36u,
  164u,
  100u,
  228u,
  20u,
  148u,
  84u,
  212u,
  52u,
  180u,
  116u,
  244u,
  12u,
  140u,
  76u,
  204u,
  44u,
  172u,
  108u,
  236u,
  28u,
  156u,
  92u,
  220u,
  60u,
  188u,
  124u,
  252u,
  2u,
  130u,
  66u,
  194u,
  34u,
  162u,
  98u,
  226u,
  18u,
  146u,
  82u,
  210u,
  50u,
  178u,
  114u,
  242u,
  10u,
  138u,
  74u,
  202u,
  42u,
  170u,
  106u,
  234u,
  26u,
  154u,
  90u,
  218u,
  58u,
  186u,
  122u,
  250u,
  6u,
  134u,
  70u,
  198u,
  38u,
  166u,
  102u,
  230u,
  22u,
  150u,
  86u,
  214u,
  54u,
  182u,
  118u,
  246u,
  14u,
  142u,
  78u,
  206u,
  46u,
  174u,
  110u,
  238u,
  30u,
  158u,
  94u,
  222u,
  62u,
  190u,
  126u,
  254u,
  1u,
  129u,
  65u,
  193u,
  33u,
  161u,
  97u,
  225u,
  17u,
  145u,
  81u,
  209u,
  49u,
  177u,
  113u,
  241u,
  9u,
  137u,
  73u,
  201u,
  41u,
  169u,
  105u,
  233u,
  25u,
  153u,
  89u,
  217u,
  57u,
  185u,
  121u,
  249u,
  5u,
  133u,
  69u,
  197u,
  37u,
  165u,
  101u,
  229u,
  21u,
  149u,
  85u,
  213u,
  53u,
  181u,
  117u,
  245u,
  13u,
  141u,
  77u,
  205u,
  45u,
  173u,
  109u,
  237u,
  29u,
  157u,
  93u,
  221u,
  61u,
  189u,
  125u,
  253u,
  3u,
  131u,
  67u,
  195u,
  35u,
  163u,
  99u,
  227u,
  19u,
  147u,
  83u,
  211u,
  51u,
  179u,
  115u,
  243u,
  11u,
  139u,
  75u,
  203u,
  43u,
  171u,
  107u,
  235u,
  27u,
  155u,
  91u,
  219u,
  59u,
  187u,
  123u,
  251u,
  7u,
  135u,
  71u,
  199u,
  39u,
  167u,
  103u,
  231u,
  23u,
  151u,
  87u,
  215u,
  55u,
  183u,
  119u,
  247u,
  15u,
  143u,
  79u,
  207u,
  47u,
  175u,
  111u,
  239u,
  31u,
  159u,
  95u,
  223u,
  63u,
  191u,
  127u,
  255u
}; // idb
char *off_23A800[6] =
{
  "FOUNDRY",
  "FAMILY_NAME",
  "WEIGHT_NAME",
  "SLANT",
  "SETWIDTH_NAME",
  "ADD_STYLE_NAME"
}; // weak
char *off_23A880[8] =
{
  "fn",
  "FaceNumber",
  "ai",
  "AutoItalic",
  "ds",
  "DoubleStrike",
  "fp",
  "FontProperties"
}; // weak
char *off_23A980[2] = { "FontFile", (char *)3LL }; // idb
char *builtin_alias[6] =
{
  "fixed",
  "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1",
  "6x13",
  "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1",
  "-misc-fixed-medium-r-semicondensed--13-100-100-100-c-60-iso8859-1",
  "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1"
}; // weak
char *builtin_dir[5] =
{
  "6x13.builtin",
  "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1",
  "cursor.builtin",
  "cursor",
  "6x13.builtin"
}; // weak
char *builtin_files = "6x13.builtin"; // weak
char *off_23AB40[3] = { "inet", (char *)0x100000002LL, (char *)2LL }; // idb
__int64 (__fastcall *off_23ABE0[18])() =
{
  &pcfReadFont,
  &pcfReadFontInfo,
  &pcfReadFont,
  &pcfReadFontInfo,
  &pcfReadFont,
  &pcfReadFontInfo,
  &snfReadFont,
  &snfReadFontInfo,
  &snfReadFont,
  &snfReadFontInfo,
  &snfReadFont,
  &snfReadFontInfo,
  &bdfReadFont,
  &bdfReadFontInfo,
  &bdfReadFont,
  &bdfReadFontInfo,
  &bdfReadFont,
  &bdfReadFontInfo
}; // weak
char **off_23AC80 = &FontTransSocketTCPFuncs; // weak
void *off_23B880 = &off_23B880; // weak
char *off_23B8A0 = ".bdf"; // weak
char *off_23B8D8 = ".pcf"; // weak
char *off_23B920 = ".ttf"; // weak
char *off_23B958 = ".ttc"; // weak
char *off_23B990 = ".otf"; // weak
char *off_23B9C8 = ".otc"; // weak
char *off_23BA00 = ".pfa"; // weak
char *off_23BA38 = ".pfb"; // weak
char *off_23BA80[8] =
{
  "FONT_ASCENT",
  "FONT_DESCENT",
  "DEFAULT_CHAR",
  "POINT_SIZE",
  "RESOLUTION",
  "X_HEIGHT",
  "WEIGHT",
  "QUAD_WIDTH"
}; // weak
char *off_23BAE0 = ".pcf"; // weak
_UNKNOWN unk_23BCD8; // weak
_UNKNOWN unk_23BCE0; // weak
char *off_23BD00 = "RAW_MIN_SPACE"; // weak
void *off_23BF00 = (void *)0x31338LL; // weak
char *off_23C1A0 = "FOUNDRY"; // weak
_UNKNOWN unk_23C380; // weak
_UNKNOWN unk_23C388; // weak
void *off_23C440 = (void *)0x33F75LL; // weak
char *FontTransSocketTCPFuncs = "tcp"; // weak
_UNKNOWN glyphCachingMode; // weak
int dword_23C6F4 = 1; // weak
__int16 *off_23C6F8 = &asc_34B18; // weak
void *off_23C700 = (void *)0x34B1ALL; // weak
void *off_23C708 = (void *)0x33F9DLL; // weak
_UNKNOWN serverGeneration; // weak
_UNKNOWN _bss_start; // weak
char byte_23C720; // weak
int dword_23C730; // weak
void *ptr; // idb
char byte_23C740; // idb
int dword_23C758; // weak
char dest[1024]; // idb
__int64 qword_23CB60; // weak
int dword_23CB70; // weak
void *qword_23CB78; // idb
_QWORD qword_23CB80[32]; // idb
int dword_23CC80; // weak
_UNKNOWN unk_23CC90; // weak
_UNKNOWN unk_23CCB0; // weak
__int64 qword_23CCC8; // weak
int dword_23CCD0; // weak
int dword_23CCD4; // weak
int dword_23CCD8; // weak
int dword_23CCDC; // weak
int dword_23CCE0; // weak
int dword_23CCE4; // weak
int dword_23CCE8; // weak
__int64 qword_23CCF0; // weak
__int64 qword_23CCF8; // weak
__int128 xmmword_23CD00; // weak
int dword_23CD10; // weak
_UNKNOWN unk_23CD14; // weak
int dword_23CD18; // weak
__int64 qword_23CD20; // weak
__int64 qword_23CD28; // weak
__int64 qword_23CD30; // weak
int dword_23CD38; // weak
void *qword_23CD40; // idb
int dword_23CD48; // weak
int dword_23CD4C; // weak
int dword_23CD50; // weak
int dword_23CD54; // weak
void *qword_23CD58; // idb
__int64 qword_23CD60; // weak
int dword_23CD68; // weak
pointer serverClient[2]; // idb
_UNKNOWN FontFileBitmapSources; // weak
_UNKNOWN ftypeLibrary; // weak
_UNKNOWN bdfFileLineNum; // weak
_UNKNOWN fs_glyph_requested; // weak
_UNKNOWN fs_glyph_undefined; // weak
_QWORD fs_fd_mask[16]; // idb
// extern _UNKNOWN __cxa_finalize; weak
// extern struct _IO_FILE *stderr;


//----- (0000000000007FB8) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 23D200: using guessed type __int64 _gmon_start__(void);

//----- (0000000000007FD0) ----------------------------------------------------
void sub_7FD0()
{
  JUMPOUT(&dword_0);
}

//----- (00000000000090E0) ----------------------------------------------------
const char *__fastcall start(char *a1, int a2, double a3)
{
  __int64 v3; // r12
  const char *v4; // rbx
  struct lconv *v5; // rax
  char *v6; // rdx
  char *v7; // rdx
  __int16 *v8; // rax
  unsigned __int64 i; // rdi
  const char *v10; // rbp
  signed int v11; // eax
  signed int v12; // er13
  const unsigned __int16 **v13; // rax
  __int64 v14; // rcx
  const unsigned __int16 *v15; // rax
  int v16; // er8
  __int64 v17; // r8
  const char *v18; // rax
  __int16 *v19; // rdi
  _BYTE *v20; // rsi
  char *v21; // rax
  _BYTE *v22; // rcx
  char v23; // dl

  v3 = a2;
  v4 = a1;
  if ( !qword_23CD60 )
  {
    v5 = localeconv();
    v6 = v5->decimal_point;
    qword_23CD60 = (__int64)v5;
    if ( v6 && *v6 )
      off_23C708 = v6;
    v7 = v5->positive_sign;
    if ( v7 && *v7 )
      off_23C700 = v5->positive_sign;
    v8 = (__int16 *)v5->negative_sign;
    if ( v8 && *(_BYTE *)v8 )
      off_23C6F8 = v8;
  }
  if ( a2 )
  {
    *a1 = 32;
    v4 = a1 + 1;
  }
  __sprintf_chk(v4, 1LL, -1LL, "%.*le", 3LL, a3);
  for ( i = (unsigned __int64)&v4[strlen(v4)]; ; --i )
  {
    v10 = (const char *)(i - 1);
    if ( (*(_BYTE *)i & 0xDF) == 69 )
      break;
  }
  v11 = strtol((const char *)(i + 1), 0LL, 10);
  if ( a3 == 0.0 )
    v11 = 0;
  v12 = v11;
  while ( 1 )
  {
    if ( v4 > v10 )
    {
      v16 = 0;
      goto LABEL_27;
    }
    v13 = __ctype_b_loc();
    v14 = *v10;
    v15 = *v13;
    if ( v15[v14] & 0x800 )
    {
      if ( (_BYTE)v14 != 48 )
        break;
    }
    --v10;
  }
  v16 = 0;
  do
    v16 += (v15[(--v10)[1]] & 0x800) != 0;
  while ( v4 <= v10 );
LABEL_27:
  if ( v12 <= 2 && v16 - v12 <= 4 )
  {
    v17 = (unsigned int)(v16 - (v12 + 1));
    if ( (signed int)v17 < 0 )
      v17 = 0LL;
    __sprintf_chk(v4, 1LL, -1LL, "%.*lf", v17, a3);
    v18 = v4;
    if ( v12 < 0 )
    {
      while ( *v18 && *v18 != 48 )
        ++v18;
      while ( *(++v18 - 1) )
        *((_BYTE *)v18 - 1) = *v18;
    }
  }
  else
  {
    __sprintf_chk(v4, 1LL, -1LL, "%.*le", (unsigned int)(v16 - 1), a3);
  }
  v19 = off_23C6F8;
  v20 = off_23C700;
  v21 = (char *)v4;
  v22 = off_23C708;
  while ( 1 )
  {
    v23 = *v21;
    if ( !*v21 )
      break;
    if ( *(_BYTE *)v19 == v23 )
    {
      *v21 = 126;
    }
    else if ( *v20 == v23 )
    {
      *v21 = 43;
    }
    else if ( *v22 == v23 )
    {
      *v21 = 46;
    }
    ++v21;
  }
  return &v4[-v3];
}
// 9060: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 23C6F8: using guessed type __int16 *off_23C6F8;
// 23C700: using guessed type void *off_23C700;
// 23C708: using guessed type void *off_23C708;
// 23CD60: using guessed type __int64 qword_23CD60;

//----- (0000000000009300) ----------------------------------------------------
__int64 (**sub_9300())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))&_bss_start;
  if ( &_bss_start != &_bss_start )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}
// 23D1F8: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000009340) ----------------------------------------------------
__int64 sub_9340()
{
  return 0LL;
}

//----- (0000000000009390) ----------------------------------------------------
__int64 (**sub_9390())(void)
{
  __int64 (**result)(void); // rax

  if ( !byte_23C720 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_23B880);
    result = sub_9300();
    byte_23C720 = 1;
  }
  return result;
}
// 90D0: using guessed type __int64 __fastcall _cxa_finalize(_QWORD);
// 23B880: using guessed type void *off_23B880;
// 23C720: using guessed type char byte_23C720;

//----- (00000000000093D0) ----------------------------------------------------
__int64 sub_93D0()
{
  return sub_9340();
}

//----- (00000000000093E0) ----------------------------------------------------
signed __int64 __fastcall FontFileRegisterBitmapSource(__int64 a1)
{
  __int64 v1; // rsi
  _QWORD *v2; // r8
  signed __int64 v3; // rdx
  signed __int64 result; // rax

  v1 = *((signed int *)&FontFileBitmapSources + 3);
  v2 = (_QWORD *)FontFileBitmapSources;
  if ( (signed int)v1 > 0 )
  {
    if ( a1 == *FontFileBitmapSources )
      return 1LL;
    v3 = FontFileBitmapSources + 8LL;
    while ( v3 != FontFileBitmapSources + 8LL + 8LL * (unsigned int)(v1 - 1) )
    {
      v3 += 8LL;
      if ( *(_QWORD *)(v3 - 8) == a1 )
        return 1LL;
    }
  }
  if ( *((_DWORD *)&FontFileBitmapSources + 2) != (_DWORD)v1 )
    goto LABEL_7;
  v2 = realloc(FontFileBitmapSources, 8LL * ((signed int)v1 + 4));
  result = 0LL;
  if ( v2 )
  {
    *((_DWORD *)&FontFileBitmapSources + 2) = v1 + 4;
    FontFileBitmapSources = v2;
    v1 = *((signed int *)&FontFileBitmapSources + 3);
LABEL_7:
    *((_DWORD *)&FontFileBitmapSources + 3) = v1 + 1;
    v2[v1] = a1;
    result = 1LL;
  }
  return result;
}

//----- (0000000000009480) ----------------------------------------------------
void __fastcall FontFileUnregisterBitmapSource(__int64 a1)
{
  int v1; // er8
  char *v2; // rdx
  signed __int64 v3; // rax
  int v4; // er8
  int v5; // ecx
  signed __int64 v6; // rax

  v1 = *((_DWORD *)&FontFileBitmapSources + 3);
  if ( v1 > 0 )
  {
    v2 = (char *)FontFileBitmapSources;
    if ( a1 == *FontFileBitmapSources )
    {
      v5 = 0;
      v4 = v1 - 1;
LABEL_8:
      *((_DWORD *)&FontFileBitmapSources + 3) = v4;
      if ( v4 )
      {
        if ( v4 > v5 )
        {
          v6 = 8LL * v5 + 8;
          while ( 1 )
          {
            ++v5;
            *(_QWORD *)&v2[v6 - 8] = *(_QWORD *)&v2[v6];
            v6 += 8LL;
            if ( *((_DWORD *)&FontFileBitmapSources + 3) <= v5 )
              break;
            v2 = (char *)FontFileBitmapSources;
          }
        }
      }
      else
      {
        *((_DWORD *)&FontFileBitmapSources + 2) = 0;
        free(v2);
        FontFileBitmapSources = 0LL;
      }
    }
    else
    {
      v3 = 1LL;
      v4 = v1 - 1;
      while ( 1 )
      {
        v5 = v3;
        if ( (unsigned int)v4 + 1LL == v3 )
          break;
        if ( *(_QWORD *)(FontFileBitmapSources + 8 * ++v3 - 8) == a1 )
          goto LABEL_8;
      }
    }
  }
}

//----- (0000000000009530) ----------------------------------------------------
void FontFileEmptyBitmapSource()
{
  void *v0; // rdi

  if ( *((_DWORD *)&FontFileBitmapSources + 3) )
  {
    v0 = (void *)FontFileBitmapSources;
    *((_QWORD *)&FontFileBitmapSources + 1) = 0LL;
    free(v0);
    FontFileBitmapSources = 0LL;
  }
}

//----- (0000000000009570) ----------------------------------------------------
__int64 __fastcall FontFileMatchBitmapSource(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7, unsigned int a8, unsigned int a9)
{
  __int64 v9; // r13
  __int64 v10; // r12
  __int64 v11; // r14
  signed __int64 v12; // rbp
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 result; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rax
  unsigned int v20; // [rsp+Ch] [rbp-3Ch]

  if ( *((_DWORD *)&FontFileBitmapSources + 3) <= 0 )
    return 83LL;
  v9 = a6;
  v10 = a5;
  v20 = a3;
  v11 = 0LL;
  while ( 1 )
  {
    v12 = 8 * v11;
    v13 = *(_QWORD *)(FontFileBitmapSources + 8 * v11);
    if ( v13 != a1 )
    {
      v14 = FontFileFindNameInDir(*(_QWORD *)(v13 + 24) + 24LL, v10);
      if ( v14 )
      {
        v15 = FontFileFindScaledInstance(v14, v9, a9);
        if ( v15 )
          break;
      }
    }
    if ( *((_DWORD *)&FontFileBitmapSources + 3) <= (signed int)++v11 )
      return 83LL;
  }
  v17 = *(_QWORD *)(v15 + 128);
  if ( v17 )
  {
    *(_QWORD *)a2 = v17;
    *(_QWORD *)(v17 + 136) = *(_QWORD *)(FontFileBitmapSources + v12);
    return 85LL;
  }
  v18 = *(_QWORD *)(v15 + 120);
  if ( !v18 )
    return 83LL;
  v19 = *(_QWORD *)(v18 + 40);
  if ( v19 )
  {
    *(_QWORD *)a2 = v19;
    *(_QWORD *)(v19 + 136) = *(_QWORD *)(FontFileBitmapSources + v12);
    result = 85LL;
  }
  else
  {
    result = FontFileOpenBitmap(*(_QWORD *)(FontFileBitmapSources + v12), a2, v20, v18, a7, a8);
    if ( (_DWORD)result == 85 )
    {
      if ( *(_QWORD *)a2 )
        *(_QWORD *)(*(_QWORD *)a2 + 136LL) = *(_QWORD *)(FontFileBitmapSources + v12);
    }
  }
  return result;
}
// 8610: using guessed type __int64 __fastcall FontFileOpenBitmap(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8880: using guessed type __int64 __fastcall FontFileFindScaledInstance(_QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);

//----- (00000000000096C0) ----------------------------------------------------
__int64 __fastcall sub_96C0(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)a1 == a1 + 16 )
    result = 0LL;
  else
    result = (*(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 8216))(0xFFFFFFFFLL, a1);
  return result;
}

//----- (00000000000096F0) ----------------------------------------------------
signed __int64 __fastcall sub_96F0(__int64 a1, int a2)
{
  if ( a2 )
    close(*(_QWORD *)(a1 + 8240));
  return 1LL;
}

//----- (0000000000009720) ----------------------------------------------------
signed __int64 __fastcall sub_9720(__int64 a1)
{
  int v1; // eax
  signed __int64 result; // rax

  v1 = read(*(_DWORD *)(a1 + 8240), (void *)(a1 + 16), 0x2000uLL);
  if ( v1 <= 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = v1 - 1;
    *(_QWORD *)a1 = a1 + 17;
    result = *(unsigned __int8 *)(a1 + 16);
  }
  return result;
}

//----- (0000000000009760) ----------------------------------------------------
signed __int64 __fastcall sub_9760(unsigned __int64 *a1, unsigned int a2)
{
  __int64 v2; // rcx
  int v3; // edx
  signed __int64 result; // rax
  int v5; // er12
  signed int v6; // edx
  int v7; // eax

  v2 = *a1;
  v3 = *((_DWORD *)a1 + 2);
  if ( (signed int)(a2 + *a1 - ((_DWORD)a1 + 16)) <= (signed int)(v3 + *a1 - ((_DWORD)a1 + 16)) )
  {
    *((_DWORD *)a1 + 2) = v3 - a2;
    result = a2;
    *a1 = (signed int)a2 + v2;
    return result;
  }
  v5 = a2 - v3;
  if ( lseek(*((_DWORD *)a1 + 2060), (signed int)(a2 - v3), 1) != -1 )
  {
LABEL_5:
    *((_DWORD *)a1 + 2) = 0;
    return a2;
  }
  if ( *__errno_location() == 29 )
  {
    if ( !v5 )
      goto LABEL_5;
    while ( 1 )
    {
      v6 = 0x2000;
      if ( v5 < 0x2000 )
        v6 = v5;
      v7 = read(*((_DWORD *)a1 + 2060), a1 + 2, v6);
      if ( v7 <= 0 )
        break;
      v5 -= v7;
      if ( !v5 )
        goto LABEL_5;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000009840) ----------------------------------------------------
__int64 __fastcall sub_9840(unsigned int a1, __int64 a2)
{
  unsigned int v2; // ebp
  _BYTE *v3; // rdx
  __int64 v4; // rdi

  v2 = a1;
  v3 = *(_BYTE **)a2;
  if ( a1 != -1 )
  {
    *(_QWORD *)a2 = v3 + 1;
    *v3 = a1;
    v3 = *(_BYTE **)a2;
  }
  v4 = *(_QWORD *)(a2 + 8240);
  *(_DWORD *)(a2 + 8) = 0x2000;
  *(_QWORD *)a2 = a2 + 16;
  if ( write(v4, (const void *)(a2 + 16), (signed int)v3 - ((signed int)a2 + 16)) != (_DWORD)v3 - ((_DWORD)a2 + 16) )
    v2 = -1;
  return v2;
}

//----- (00000000000098A0) ----------------------------------------------------
_QWORD *__fastcall BufFileCreate(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12
  __int64 v6; // rbp
  __int64 v7; // rbx
  _QWORD *result; // rax

  v5 = a3;
  v6 = a4;
  v7 = a5;
  result = malloc(0x2038uLL);
  if ( result )
  {
    result[1030] = a1;
    result[1026] = a2;
    result[1027] = v5;
    result[1028] = v6;
    *result = result + 2;
    result[1] = 0LL;
    result[1029] = v7;
  }
  return result;
}

//----- (0000000000009910) ----------------------------------------------------
__int64 __fastcall BufFileOpenRead(int a1)
{
  return BufFileCreate(a1, sub_9720, 0LL, sub_9760, sub_96F0);
}
// 8150: using guessed type __int64 __fastcall BufFileCreate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000009930) ----------------------------------------------------
__int64 __fastcall BufFileOpenWrite(int a1)
{
  __int64 result; // rax

  result = BufFileCreate(a1, 0LL, sub_9840, 0LL, sub_96C0);
  *(_DWORD *)(result + 8) = 0x2000;
  *(_QWORD *)result = result + 16;
  return result;
}
// 8150: using guessed type __int64 __fastcall BufFileCreate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000009970) ----------------------------------------------------
__int64 __fastcall BufFileRead(__int64 a1, __int64 a2, int a3)
{
  int v3; // er13
  __int64 v4; // r12
  int v5; // ebp
  _BYTE *v6; // rax
  int v7; // eax

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a3 - 1;
    do
    {
      v7 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v7 - 1;
      if ( v7 )
      {
        v6 = (_BYTE *)(*(_QWORD *)a1)++;
        LOBYTE(v6) = *v6;
      }
      else
      {
        LODWORD(v6) = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
        *(_DWORD *)(a1 + 12) = (_DWORD)v6;
        if ( (_DWORD)v6 == -1 )
          return (unsigned int)(v3 - v5 - 1);
      }
      --v5;
      *(_BYTE *)(++v4 - 1) = (_BYTE)v6;
    }
    while ( v5 != -1 );
  }
  v5 = -1;
  return (unsigned int)(v3 - v5 - 1);
}

//----- (00000000000099F0) ----------------------------------------------------
__int64 __fastcall BufFileWrite(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er13
  __int64 v4; // rbx
  __int64 v5; // r12
  bool v6; // zf
  _BYTE *v8; // rax
  char v9; // dl

  v3 = a3;
  v4 = a2;
  v5 = a2 + a3;
  while ( v4 != v5 )
  {
    ++v4;
    v6 = (*(_DWORD *)(a1 + 8))-- == 1;
    if ( v6 )
    {
      if ( (*(unsigned int (__fastcall **)(_QWORD, __int64))(a1 + 8216))(*(unsigned __int8 *)(v4 - 1), a1) == -1 )
        return (unsigned int)-1;
    }
    else
    {
      v8 = *(_BYTE **)a1;
      v9 = *(_BYTE *)(v4 - 1);
      ++*(_QWORD *)a1;
      *v8 = v9;
    }
  }
  return v3;
}

//----- (0000000000009A70) ----------------------------------------------------
__int64 __fastcall BufFileClose(void *ptr)
{
  unsigned int v1; // ebp

  v1 = (*((__int64 (**)(void))ptr + 1029))();
  free(ptr);
  return v1;
}

//----- (0000000000009AA0) ----------------------------------------------------
signed __int64 __fastcall sub_9AA0(__int64 a1)
{
  unsigned __int64 v1; // r15
  __int64 *v2; // rbx
  _BYTE *v3; // rbp
  __int64 v4; // rdi
  __int64 v5; // rcx
  int v6; // eax
  __int64 v7; // r12
  int v8; // er14
  _BYTE *v9; // r13
  int v10; // eax
  int v11; // eax
  _BYTE *v12; // rax
  int v13; // esi
  int v14; // er9
  int v15; // er11
  int v16; // er10
  int v17; // edi
  int v18; // eax
  unsigned __int64 v19; // r8
  signed __int64 v20; // r8
  signed __int64 v21; // rax
  signed __int64 v22; // rax
  _BYTE *v23; // rcx
  char v24; // si
  __int64 v25; // rax
  __int16 v26; // di
  signed __int64 result; // rax
  char v28; // cl
  bool v29; // zf
  signed __int64 v30; // rax
  unsigned __int64 v31; // [rsp+8h] [rbp-70h]
  unsigned __int8 *v32; // [rsp+10h] [rbp-68h]
  signed __int64 v33; // [rsp+18h] [rbp-60h]
  unsigned __int64 v34; // [rsp+20h] [rbp-58h]
  char v35; // [rsp+2Fh] [rbp-49h]
  signed __int64 v36; // [rsp+30h] [rbp-48h]
  __int64 v37; // [rsp+38h] [rbp-40h]

  v1 = a1 + 16;
  v2 = *(__int64 **)(a1 + 8240);
  v31 = a1 + 8208;
  v37 = a1;
  v36 = a1 + 16;
  v3 = (_BYTE *)v2[1];
  v34 = (unsigned __int64)(v2 + 12);
  v35 = *((_BYTE *)v2 + 24);
  v33 = v2[2];
  while ( 1 )
  {
    for ( ; v34 < (unsigned __int64)v3 && v31 > v1; *(_BYTE *)(v1 - 1) = *v3 )
    {
      --v3;
      ++v1;
    }
    if ( v31 == v1 )
    {
LABEL_29:
      v2[1] = (__int64)v3;
      v2[2] = v33;
      *((_BYTE *)v2 + 24) = v35;
      if ( v36 == v1 )
      {
        *(_DWORD *)(v37 + 8) = 0;
        result = 0xFFFFFFFFLL;
      }
      else
      {
        *(_QWORD *)v37 = v37 + 17;
        *(_DWORD *)(v37 + 8) = v1 - v36 - 1;
        result = *(unsigned __int8 *)(v37 + 16);
      }
      return result;
    }
    v4 = v2[7];
    v5 = v2[5];
    v32 = (unsigned __int8 *)(v2 + 10);
    v6 = *((_DWORD *)v2 + 16);
    if ( v6 <= 0 )
    {
      v16 = *((_DWORD *)v2 + 18);
      v13 = *((_DWORD *)v2 + 17);
      if ( v16 >= *((_DWORD *)v2 + 19) )
      {
        if ( v4 <= v5 )
        {
          v8 = *((_DWORD *)v2 + 17);
LABEL_44:
          if ( v8 <= 0 )
            goto LABEL_29;
          v7 = *v2;
          goto LABEL_11;
        }
      }
      else if ( v4 <= v5 )
      {
        v15 = v2[9] & 7;
        v14 = 8 - v15;
        v32 += v16 >> 3;
        goto LABEL_18;
      }
      v8 = v13 + 1;
      v29 = v13 + 1 == *((_DWORD *)v2 + 8);
      *((_DWORD *)v2 + 17) = v13 + 1;
      if ( !v29 )
        goto LABEL_42;
    }
    else
    {
      if ( v4 <= v5 )
        goto LABEL_10;
      v8 = *((_DWORD *)v2 + 17) + 1;
      v29 = v8 == *((_DWORD *)v2 + 8);
      *((_DWORD *)v2 + 17) = v8;
      if ( !v29 )
      {
LABEL_42:
        v2[5] = (1 << v8) - 1;
        goto LABEL_43;
      }
    }
    v2[5] = v2[6];
LABEL_43:
    if ( v6 <= 0 )
      goto LABEL_44;
LABEL_10:
    v7 = *v2;
    v2[5] = 511LL;
    v2[8] = 38654705664LL;
    v8 = 9;
LABEL_11:
    v9 = v2 + 10;
    do
    {
      while ( 1 )
      {
        v11 = *(_DWORD *)(v7 + 8);
        *(_DWORD *)(v7 + 8) = v11 - 1;
        if ( !v11 )
          break;
        v12 = *(_BYTE **)v7;
        ++v9;
        ++*(_QWORD *)v7;
        *(v9 - 1) = *v12;
        if ( !--v8 )
          goto LABEL_16;
      }
      v10 = (*(__int64 (__fastcall **)(__int64))(v7 + 8208))(v7);
      *(_DWORD *)(v7 + 12) = v10;
      if ( v10 == -1LL )
        break;
      *v9++ = v10;
      --v8;
    }
    while ( v8 );
LABEL_16:
    v13 = *((_DWORD *)v2 + 17);
    if ( v13 == v8 )
      goto LABEL_29;
    *((_DWORD *)v2 + 18) = 0;
    v14 = 8;
    LOBYTE(v15) = 0;
    v16 = 0;
    *((_DWORD *)v2 + 19) = 8 * (v13 - v8) - (v13 - 1);
LABEL_18:
    v17 = v13 - v14;
    v18 = v32[1];
    LODWORD(v19) = (signed int)*v32 >> v15;
    if ( v13 - v14 > 7 )
    {
      v28 = v14;
      v17 -= 8;
      LOBYTE(v14) = 16 - v15;
      v19 = (signed int)((v18 << v28) | v19);
      LOBYTE(v18) = v32[2];
    }
    else
    {
      v19 = (signed int)v19;
    }
    *((_DWORD *)v2 + 18) = v16 + v13;
    v20 = ((unsigned __int8)(byte_300C0[v17] & v18) << v14) | v19;
    if ( v20 != 256 )
      break;
    if ( *((_DWORD *)v2 + 7) )
    {
      v30 = 510LL;
      do
      {
        *(_WORD *)(v2[8176] + v30) = 0;
        v30 -= 2LL;
      }
      while ( v30 != -2 );
      *((_DWORD *)v2 + 16) = 1;
      v2[7] = 257LL;
      v33 = -1LL;
    }
    else
    {
      v21 = v2[7];
      if ( v21 <= 256 )
        goto LABEL_34;
      v22 = 256LL;
      v23 = v3;
      do
      {
        *(++v23 - 1) = *(_BYTE *)(v2[8175] + v22);
        v22 = *(unsigned __int16 *)(v2[8176] + 2 * v22);
LABEL_24:
        ;
      }
      while ( v22 > 255 );
      v3 = v23 + 1;
      v24 = *(_BYTE *)(v2[8175] + v22);
      *v23 = v24;
      v25 = v2[7];
      v35 = v24;
      if ( v2[6] <= v25 || (v26 = v33, v33 == -1) )
      {
        v33 = v20;
      }
      else
      {
        v33 = v20;
        *(_WORD *)(v2[8176] + 2 * v25) = v26;
        *(_BYTE *)(v2[8175] + v25) = v24;
        v2[7] = v25 + 1;
      }
    }
    if ( v31 <= v1 )
      goto LABEL_29;
  }
  v21 = v2[7];
  if ( v21 > v20 )
  {
    v22 = v20;
    v23 = v3;
    goto LABEL_24;
  }
LABEL_34:
  if ( v33 != -1 && v21 >= v20 )
  {
    v23 = v3 + 1;
    *v3 = v35;
    v22 = v33;
    goto LABEL_24;
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000009EE0) ----------------------------------------------------
__int64 __fastcall sub_9EE0(__int64 a1, int a2)
{
  int i; // ebp
  __int64 result; // rax
  int v4; // eax

  for ( i = a2; i; --i )
  {
    v4 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v4 - 1;
    if ( v4 )
    {
      ++*(_QWORD *)a1;
    }
    else
    {
      result = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      *(_DWORD *)(a1 + 12) = result;
      if ( (_DWORD)result == -1 )
        return result;
    }
  }
  return 0LL;
}

//----- (0000000000009F30) ----------------------------------------------------
signed __int64 __fastcall sub_9F30(__int64 a1)
{
  void **v1; // rdi
  void *v2; // rbx

  v1 = *(void ***)(a1 + 8240);
  v2 = *v1;
  free(v1);
  BufFileClose(v2);
  return 1LL;
}

//----- (0000000000009F60) ----------------------------------------------------
__int64 __fastcall BufFilePushCompressed(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  char v8; // bp
  int v9; // er13
  __int64 v10; // r12
  _DWORD *v11; // rax
  _DWORD *v12; // rdi
  signed __int64 v13; // rax
  signed __int64 v14; // rdx
  signed __int64 v15; // rax
  int v16; // ecx
  unsigned __int8 *v18; // rax
  unsigned __int8 *v19; // rax
  char *v20; // rax

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 )
  {
    v18 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v3 = *v18;
  }
  else
  {
    v3 = (*(__int64 (**)(void))(a1 + 8208))();
    *(_DWORD *)(a1 + 12) = v3;
  }
  if ( v3 != 31 )
    return 0LL;
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v4 - 1;
  if ( v4 )
  {
    v19 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v5 = *v19;
  }
  else
  {
    v5 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
    *(_DWORD *)(a1 + 12) = v5;
  }
  if ( v5 != 157 )
    return 0LL;
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v6 - 1;
  if ( v6 )
  {
    v20 = (char *)(*(_QWORD *)a1)++;
    v8 = *v20;
  }
  else
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
    v8 = v7;
    *(_DWORD *)(a1 + 12) = v7;
    if ( v7 == -1 )
      return 0LL;
  }
  v9 = v8 & 0x1F;
  if ( (unsigned int)(v9 - 10) > 6 )
    return 0LL;
  v10 = 1 << v9;
  v11 = malloc((unsigned int)(3 << v9) + 65416LL);
  v12 = v11;
  if ( !v11 )
    return 0LL;
  *(_QWORD *)v11 = v1;
  v11[8] = v9;
  v11[7] = v8 & 0x80;
  *((_QWORD *)v11 + 6) = v10;
  v13 = (signed __int64)(v11 + 16354);
  v12[17] = 9;
  *((_QWORD *)v12 + 5) = 511LL;
  v14 = 255LL;
  *((_QWORD *)v12 + 8175) = v13;
  v15 = v10 + v13;
  for ( *((_QWORD *)v12 + 8176) = v15; ; v15 = *((_QWORD *)v12 + 8176) )
  {
    *(_WORD *)(v15 + 2 * v14) = 0;
    *(_BYTE *)(*((_QWORD *)v12 + 8175) + v14) = v14;
    if ( --v14 == -1 )
      break;
  }
  v16 = v12[7];
  *((_QWORD *)v12 + 2) = -1LL;
  v12[16] = 0;
  *((_QWORD *)v12 + 9) = 0LL;
  *((_QWORD *)v12 + 7) = (v16 != 0) + 256LL;
  *((_OWORD *)v12 + 5) = 0LL;
  *((_QWORD *)v12 + 1) = v12 + 24;
  return BufFileCreate(v12, sub_9AA0, 0LL, sub_9EE0, sub_9F30);
}
// 8150: using guessed type __int64 __fastcall BufFileCreate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000A130) ----------------------------------------------------
void __fastcall FontDefaultFormat(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = 1;
  *a2 = 1;
  *a3 = 4;
  *a4 = 1;
}

//----- (000000000000A150) ----------------------------------------------------
__int64 __fastcall sub_A150(_IO_FILE *fp, _QWORD *a2)
{
  int v2; // er15
  unsigned int v3; // ebp
  char *v4; // rbx
  int v5; // ebx
  size_t v6; // rsi
  char *v7; // rax
  int v8; // er12
  signed int v9; // eax
  char *v10; // rcx
  char *v11; // rax
  char *v12; // rax
  void *v13; // rdx
  char *v15; // rcx
  char *v16; // rax
  int v17; // eax
  void *v18; // rax
  char *v19; // rax
  char *v20; // rax
  bool v21; // cc
  _QWORD *v22; // [rsp+8h] [rbp-40h]

  v2 = 0;
  v3 = 0;
  v4 = (char *)ptr;
  v22 = a2;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_2:
        if ( dword_23C730 == v2 )
        {
          if ( v2 )
          {
            v5 = 2 * v2;
            v6 = 2 * v2;
          }
          else
          {
            v6 = 64LL;
            v5 = 64;
          }
LABEL_5:
          v7 = (char *)realloc(ptr, v6);
          if ( !v7 )
            return 3LL;
          dword_23C730 = v5;
          ptr = v7;
          v4 = &v7[v2];
        }
        v8 = 2 * v2;
LABEL_8:
        v9 = _IO_getc(fp);
        if ( v9 == 13 )
          goto LABEL_46;
        if ( v9 <= 13 )
        {
          if ( v9 != 9 )
          {
            if ( v9 == 10 )
            {
LABEL_46:
              dword_23C758 = 4;
              if ( !v3 || v3 == 3 )
              {
LABEL_104:
                *v22 = 0LL;
                return 1LL;
              }
              goto LABEL_48;
            }
            goto LABEL_15;
          }
          goto LABEL_58;
        }
        if ( v9 == 33 )
          break;
        if ( v9 > 33 )
        {
          if ( v9 != 34 )
            goto LABEL_13;
          goto LABEL_20;
        }
        if ( v9 == 32 )
        {
LABEL_58:
          dword_23C758 = 1;
          if ( v3 == 1 )
            goto LABEL_80;
          if ( v3 >= 1 && v3 != 3 )
          {
            v15 = v4;
            v3 = 2;
            ++v4;
            *v15 = v9;
            ++v2;
          }
        }
        else
        {
LABEL_16:
          dword_23C758 = 2;
          v10 = v4;
          if ( v3 )
          {
            if ( v3 != 3 )
              goto LABEL_18;
            goto LABEL_70;
          }
          v3 = 1;
          ++v4;
          *v10 = v9;
          ++v2;
        }
      }
LABEL_41:
      dword_23C758 = 5;
      if ( !v3 || v3 == 3 )
        break;
LABEL_43:
      *v4 = 33;
      ++v2;
      ++v4;
    }
LABEL_83:
    if ( v2 != dword_23C730 )
      break;
    v5 = 64;
    v6 = 64LL;
    v3 = 3;
    if ( !v2 )
      goto LABEL_5;
LABEL_85:
    v19 = (char *)realloc(ptr, v8);
    if ( !v19 )
      return 3LL;
    ptr = v19;
    v4 = &v19[v2];
    dword_23C730 = 2 * v2;
    v17 = _IO_getc(fp);
    if ( v17 == 13 )
    {
LABEL_103:
      dword_23C758 = 4;
      goto LABEL_104;
    }
    if ( v17 <= 13 )
    {
LABEL_50:
      if ( v17 != 9 )
      {
        if ( v17 == 10 )
          goto LABEL_103;
        if ( v17 == -1 )
        {
          v3 = 3;
LABEL_54:
          dword_23C758 = 3;
          if ( !v3 || (v9 = -1, v3 == 3) )
          {
            *v22 = 0LL;
            return 2LL;
          }
LABEL_48:
          v13 = ptr;
          *v4 = 0;
          *v22 = v13;
          ungetc(v9, fp);
          return 0LL;
        }
        goto LABEL_69;
      }
LABEL_119:
      dword_23C758 = 1;
      v3 = 3;
    }
    else
    {
      if ( v17 != 33 )
      {
        if ( v17 > 33 )
        {
          if ( v17 == 34 )
          {
LABEL_19:
            v3 = 3;
            goto LABEL_20;
          }
          v3 = 3;
LABEL_113:
          if ( v17 == 92 )
            goto LABEL_14;
          goto LABEL_69;
        }
        goto LABEL_118;
      }
      dword_23C758 = 5;
      v3 = 3;
    }
  }
  while ( 2 )
  {
    v3 = 3;
    v17 = _IO_getc(fp);
    if ( v17 == 13 )
      goto LABEL_103;
    if ( v17 > 13 )
    {
      v21 = v17 <= 33;
      if ( v17 == 33 )
        goto LABEL_41;
      break;
    }
    while ( 2 )
    {
      switch ( v17 )
      {
        case 9:
          goto LABEL_119;
        case 10:
          goto LABEL_103;
        case -1:
          goto LABEL_54;
      }
LABEL_69:
      while ( 2 )
      {
        dword_23C758 = 2;
LABEL_70:
        if ( dword_23C730 != v2 )
        {
          v17 = _IO_getc(fp);
          if ( v17 == 13 )
            goto LABEL_103;
          if ( v17 <= 13 )
            goto LABEL_50;
          if ( v17 == 33 )
          {
            v3 = 3;
            goto LABEL_41;
          }
          if ( v17 > 33 )
          {
            if ( v17 == 34 )
              goto LABEL_19;
            v3 = 3;
            if ( v17 == 92 )
              goto LABEL_14;
            continue;
          }
          goto LABEL_118;
        }
        break;
      }
      v5 = 64;
      v6 = 64LL;
      v3 = 3;
      if ( !v2 )
        goto LABEL_5;
      v16 = (char *)realloc(ptr, v8);
      if ( !v16 )
        return 3LL;
      ptr = v16;
      v4 = &v16[v2];
      dword_23C730 = 2 * v2;
      v17 = _IO_getc(fp);
      if ( v17 == 13 )
        goto LABEL_103;
      if ( v17 <= 13 )
        continue;
      break;
    }
    v21 = v17 <= 33;
    if ( v17 == 33 )
    {
      dword_23C758 = 5;
      if ( v2 == dword_23C730 )
        goto LABEL_85;
      continue;
    }
    break;
  }
  if ( v21 )
  {
LABEL_118:
    if ( v17 == 32 )
      goto LABEL_119;
    goto LABEL_69;
  }
  if ( v17 != 34 )
    goto LABEL_113;
LABEL_20:
  dword_23C758 = 0;
  if ( v3 > 1 )
  {
    if ( v3 != 2 )
    {
      while ( 1 )
      {
        if ( dword_23C730 != v2 )
        {
          v3 = 3;
          goto LABEL_8;
        }
        v5 = 64;
        v6 = 64LL;
        v3 = 3;
        if ( !v2 )
          goto LABEL_5;
        v20 = (char *)realloc(ptr, v8);
        if ( !v20 )
          return 3LL;
        ptr = v20;
        v4 = &v20[v2];
        dword_23C730 = 2 * v2;
        v9 = _IO_getc(fp);
        if ( v9 == 13 )
          goto LABEL_103;
        if ( v9 <= 13 )
        {
          if ( v9 == 9 )
            goto LABEL_119;
          if ( v9 == 10 )
            goto LABEL_103;
          goto LABEL_15;
        }
        if ( v9 == 33 )
        {
          dword_23C758 = 5;
          goto LABEL_83;
        }
        if ( v9 <= 33 )
          break;
        if ( v9 != 34 )
          goto LABEL_13;
        dword_23C758 = 0;
      }
      if ( v9 == 32 )
        goto LABEL_119;
      goto LABEL_16;
    }
    goto LABEL_22;
  }
  while ( 1 )
  {
    if ( dword_23C730 != v2 )
    {
      v3 = 2;
      goto LABEL_8;
    }
    v5 = 64;
    v6 = 64LL;
    v3 = 2;
    if ( !v2 )
      goto LABEL_5;
    v12 = (char *)realloc(ptr, v8);
    if ( !v12 )
      return 3LL;
    ptr = v12;
    v4 = &v12[v2];
    dword_23C730 = 2 * v2;
    v9 = _IO_getc(fp);
    if ( v9 == 13 )
    {
LABEL_123:
      dword_23C758 = 4;
      goto LABEL_48;
    }
    if ( v9 <= 13 )
    {
      if ( v9 != 9 )
        goto LABEL_122;
LABEL_125:
      dword_23C758 = 1;
      v3 = 2;
      v10 = v4;
LABEL_18:
      ++v4;
      *v10 = v9;
      ++v2;
      goto LABEL_2;
    }
    if ( v9 == 33 )
      goto LABEL_41;
    if ( v9 <= 33 )
    {
      if ( v9 == 32 )
        goto LABEL_125;
      goto LABEL_16;
    }
    if ( v9 != 34 )
    {
LABEL_13:
      if ( v9 != 92 )
        goto LABEL_16;
LABEL_14:
      v9 = _IO_getc(fp);
LABEL_15:
      if ( v9 == -1 )
        goto LABEL_54;
      goto LABEL_16;
    }
    dword_23C758 = 0;
LABEL_22:
    if ( dword_23C730 != v2 )
    {
      v3 = 1;
      goto LABEL_8;
    }
    v5 = 64;
    v6 = 64LL;
    v3 = 1;
    if ( !v2 )
      goto LABEL_5;
    v11 = (char *)realloc(ptr, v8);
    if ( !v11 )
      return 3LL;
    ptr = v11;
    v4 = &v11[v2];
    dword_23C730 = 2 * v2;
    v9 = _IO_getc(fp);
    if ( v9 == 13 )
      goto LABEL_123;
    if ( v9 <= 13 )
      break;
    if ( v9 == 33 )
    {
      dword_23C758 = 5;
      goto LABEL_43;
    }
    if ( v9 <= 33 )
    {
      if ( v9 == 32 )
        goto LABEL_79;
      goto LABEL_16;
    }
    if ( v9 != 34 )
      goto LABEL_13;
    dword_23C758 = 0;
  }
  if ( v9 != 9 )
  {
LABEL_122:
    if ( v9 == 10 )
      goto LABEL_123;
    goto LABEL_15;
  }
LABEL_79:
  dword_23C758 = 1;
LABEL_80:
  v18 = ptr;
  *v4 = 0;
  *v22 = v18;
  return 0LL;
}
// 23C730: using guessed type int dword_23C730;
// 23C758: using guessed type int dword_23C758;

//----- (000000000000A880) ----------------------------------------------------
__int64 __fastcall FontFileReadDirectory(char *s, __int64 *a2, double a3)
{
  __int64 *v3; // r15
  size_t v4; // rbx
  char *v5; // rax
  signed __int64 v6; // rbx
  char *v7; // rax
  FILE *v8; // rax
  FILE *v9; // rbx
  int v10; // eax
  __int64 v11; // r14
  int v12; // eax
  __int64 v13; // rcx
  char *v14; // rdx
  int v15; // ecx
  unsigned int v16; // eax
  bool v17; // zf
  _WORD *v18; // rax
  unsigned __int64 v19; // rdx
  unsigned int v20; // ebp
  int *v22; // rax
  char *v23; // rdx
  int v24; // ecx
  unsigned int v25; // eax
  bool v26; // zf
  FILE *v27; // rbx
  int v28; // eax
  int v29; // eax
  char *v30; // r12
  size_t v31; // rax
  signed int v32; // eax
  bool v33; // cf
  bool v34; // zf
  char *v35; // rdx
  int v36; // ecx
  unsigned int v37; // eax
  bool v38; // zf
  char *v39; // ST10_8
  int v40; // eax
  char *v41; // rsi
  const char *v42; // rdi
  signed __int64 v43; // rcx
  char v44; // cl
  int v45; // er12
  __int64 v46; // r13
  __int64 v47; // rax
  unsigned int v48; // eax
  unsigned int v49; // ST18_4
  __int64 v50; // rcx
  char *v51; // [rsp+10h] [rbp-21A8h]
  __int64 v52; // [rsp+18h] [rbp-21A0h]
  int v53; // [rsp+34h] [rbp-2184h]
  char *sa; // [rsp+38h] [rbp-2180h]
  char *v55; // [rsp+40h] [rbp-2178h]
  __int16 v56; // [rsp+48h] [rbp-2170h]
  __int16 v57; // [rsp+4Ah] [rbp-216Eh]
  struct stat stat_buf; // [rsp+50h] [rbp-2168h]
  struct stat v59; // [rsp+E0h] [rbp-20D8h]
  char v60; // [rsp+170h] [rbp-2048h]
  char v61; // [rsp+570h] [rbp-1C48h]
  char v62; // [rsp+96Fh] [rbp-1849h]
  char filename; // [rsp+970h] [rbp-1848h]
  char v64; // [rsp+D6Fh] [rbp-1449h]
  char v65[1024]; // [rsp+D70h] [rbp-1448h]
  char v66; // [rsp+1170h] [rbp-1048h]
  char v67; // [rsp+1570h] [rbp-C48h]
  char v68; // [rsp+1970h] [rbp-848h]
  char v69[1032]; // [rsp+1D70h] [rbp-448h]
  unsigned __int64 v70; // [rsp+2178h] [rbp-40h]

  v3 = a2;
  v70 = __readfsqword(0x28u);
  v4 = strlen(s);
  if ( v4 + 11 > 0x400 )
    return 86;
  v5 = strchr(s, 58);
  if ( v5 )
  {
    v6 = v5 - s;
    __strncpy_chk(v65, s, v5 - s, 1024LL);
    v65[v6] = 0;
  }
  else
  {
    __memcpy_chk(v65, s, v4 + 1, 1024LL);
  }
  v7 = (char *)__stpcpy_chk(&filename, v65, 1024LL);
  if ( *(&v62 + v7 - &filename) != 47 )
    *(_WORD *)v7 = 47;
  __strcat_chk(&filename, "fonts.dir", 1024LL);
  v8 = fopen(&filename, "rt");
  v9 = v8;
  if ( v8 )
  {
    v10 = fileno(v8);
    if ( __fxstat(1, v10, &stat_buf) == -1 || fscanf(v9, "%d\n", &v53) != 1 || (v11 = FontFileMakeDir(s)) == 0 )
    {
      fclose(v9);
      return 86;
    }
    *(_QWORD *)(v11 + 8) = stat_buf.st_mtim.tv_sec;
    if ( !byte_23C740 )
      __sprintf_chk(&byte_23C740, 1LL, 24LL, "%%%ds %%%d[^\n]\n", 1023LL, a3);
    while ( 1 )
    {
      v12 = fscanf(v9, &byte_23C740, &v60, &v61);
      if ( v12 == -1 )
        break;
      if ( v12 != 2 )
      {
        v20 = 86;
        FontFileFreeDir((void *)v11);
        fclose(v9);
        return v20;
      }
      FontFileAddFontFile(v11, &v61, &v60, v13);
    }
    fclose(v9);
    v14 = v65;
    do
    {
      v15 = *(_DWORD *)v14;
      v14 += 4;
      v16 = ~v15 & (v15 - 16843009) & 0x80808080;
    }
    while ( !v16 );
    v17 = (unsigned __int16)(v16 & 0x8080) == 0;
    if ( !(v16 & 0x8080) )
      v16 >>= 16;
    if ( v17 )
      v14 += 2;
    if ( (unsigned __int64)(&v14[-__CFADD__((_BYTE)v16, (_BYTE)v16) - 3] - v65) > 0x3FF )
      goto LABEL_24;
    v18 = (_WORD *)__stpcpy_chk(&v68, v65, 1024LL);
    v19 = strlen(v65);
    if ( v19 + 13 > 0x400 )
      goto LABEL_24;
  }
  else
  {
    v22 = __errno_location();
    v23 = v65;
    if ( *v22 != 2 )
      return 86;
    do
    {
      v24 = *(_DWORD *)v23;
      v23 += 4;
      v25 = ~v24 & (v24 - 16843009) & 0x80808080;
    }
    while ( !v25 );
    v26 = (unsigned __int16)(v25 & 0x8080) == 0;
    if ( !(v25 & 0x8080) )
      v25 >>= 16;
    if ( v26 )
      v23 += 2;
    if ( (unsigned __int64)(&v23[-__CFADD__((_BYTE)v25, (_BYTE)v25) - 3] - v65) > 0x3FF )
      return 86;
    v18 = (_WORD *)__stpcpy_chk(&v68, v65, 1024LL);
    v19 = strlen(v65);
    if ( v19 + 13 > 0x400 )
      return 86;
    v11 = 0LL;
  }
  if ( *(&v64 + v19) != 47 )
    *v18 = 47;
  __strcat_chk(&v68, "fonts.alias", 1024LL);
  v27 = fopen(&v68, "rt");
  if ( v27 )
  {
    if ( !v11 )
    {
      v11 = FontFileMakeDir(v65);
      if ( !v11 )
      {
        v20 = 80;
        fclose(v27);
        return v20;
      }
    }
    v28 = fileno(v27);
    if ( __fxstat(1, v28, &v59) == -1 )
    {
      v20 = 86;
      fclose(v27);
      goto LABEL_25;
    }
    *(_QWORD *)(v11 + 16) = v59.st_mtim.tv_sec;
LABEL_45:
    while ( 1 )
    {
      v29 = sub_A150(v27, &sa);
      if ( v29 == 2 )
        break;
      if ( v29 == 3 )
        goto LABEL_69;
      if ( !v29 )
      {
        v30 = sa;
        v31 = strlen(sa);
        if ( v31 > 0x3FF )
          goto LABEL_75;
        __memcpy_chk(&v66, v30, v31 + 1, 1024LL);
        v32 = sub_A150(v27, &sa);
        v33 = (unsigned int)v32 < 1;
        v34 = v32 == 1;
        if ( v32 == 1 )
        {
          v41 = &v66;
          v42 = "FILE_NAMES_ALIASES";
          v43 = 19LL;
          do
          {
            if ( !v43 )
              break;
            v33 = (unsigned __int8)*v41 < *v42;
            v34 = *v41++ == *v42++;
            --v43;
          }
          while ( v34 );
          v44 = (!v33 && !v34) - v33;
          v45 = v44;
          if ( v44 )
          {
LABEL_75:
            v20 = 86;
            goto LABEL_70;
          }
          if ( *(_DWORD *)(v11 + 48) > 0 )
          {
            v46 = 0LL;
            while ( 1 )
            {
              v47 = v46 + *(_QWORD *)(v11 + 56);
              if ( *(_DWORD *)(v47 + 16) == 2 )
              {
                v51 = *(char **)(v47 + 32);
                v52 = FontFileMatchRenderer(v51);
                if ( v52 )
                {
                  v48 = strlen(v51) - *(_DWORD *)(v52 + 8);
                  if ( v48 <= 0x3FF )
                  {
                    v49 = v48;
                    sub_CCE0(v69, v51, v48);
                    v55 = v69;
                    v69[v49] = 0;
                    v56 = v49;
                    v57 = FontFileCountDashes(v69, v49, (signed int)v49);
                    if ( !FontFileFindNameInDir(v11 + 48, &v55)
                      && !(unsigned int)FontFileAddFontAlias(v11, v69, *(_QWORD *)(*(_QWORD *)(v11 + 56) + v46), v50) )
                    {
                      break;
                    }
                  }
                }
              }
              ++v45;
              v46 += 152LL;
              if ( v45 >= *(_DWORD *)(v11 + 48) )
                goto LABEL_45;
            }
LABEL_53:
            v20 = 80;
            fclose(v27);
            goto LABEL_25;
          }
        }
        else if ( v32 <= 1 )
        {
          if ( !v32 )
          {
            if ( strlen(sa) > 0x3FF )
              goto LABEL_75;
            v35 = &v66;
            do
            {
              v36 = *(_DWORD *)v35;
              v35 += 4;
              v37 = ~v36 & (v36 - 16843009) & 0x80808080;
            }
            while ( !v37 );
            v38 = (unsigned __int16)(v37 & 0x8080) == 0;
            if ( !(v37 & 0x8080) )
              LOBYTE(v37) = BYTE2(v37);
            if ( v38 )
              LODWORD(v35) = (_DWORD)v35 + 2;
            sub_CCE0(&v66, &v66, (_DWORD)v35 - (__CFADD__((_BYTE)v37, (_BYTE)v37) + 3) - (unsigned __int64)&v66);
            v39 = sa;
            v40 = strlen(sa);
            sub_CCE0(&v67, v39, v40);
            if ( !(unsigned int)FontFileAddFontAlias(v11, &v66, &v67, &v67) )
            {
LABEL_69:
              v20 = 80;
LABEL_70:
              fclose(v27);
              goto LABEL_25;
            }
          }
        }
        else
        {
          if ( v32 == 2 )
            goto LABEL_75;
          if ( v32 == 3 )
            goto LABEL_53;
        }
      }
    }
    fclose(v27);
LABEL_59:
    v20 = 85;
    FontFileSortDir(v11);
    *v3 = v11;
    return v20;
  }
  if ( *__errno_location() == 2 )
  {
    if ( v11 )
      goto LABEL_59;
    return 86;
  }
  if ( !v11 )
    return 86;
LABEL_24:
  v20 = 86;
LABEL_25:
  FontFileFreeDir((void *)v11);
  return v20;
}
// 7FF0: using guessed type __int64 __fastcall __strcat_chk(_QWORD, _QWORD, _QWORD);
// 8320: using guessed type __int64 __fastcall FontFileAddFontAlias(_QWORD, _QWORD, _QWORD, _QWORD);
// 8370: using guessed type __int64 __fastcall FontFileSortDir(_QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8980: using guessed type __int64 __fastcall __stpcpy_chk(_QWORD, _QWORD, _QWORD);
// 8B80: using guessed type __int64 __fastcall __strncpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 8E60: using guessed type __int64 __fastcall FontFileAddFontFile(_QWORD, _QWORD, _QWORD, _QWORD);
// 8F10: using guessed type __int64 __fastcall FontFileMatchRenderer(_QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);
// 9060: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// A880: using guessed type char var_1448[1024];
// A880: using guessed type char var_448[1032];

//----- (000000000000B010) ----------------------------------------------------
_BOOL8 __fastcall FontFileDirectoryChanged(__int64 a1)
{
  const char *v1; // r12
  size_t v2; // rbx
  _BOOL8 result; // rax
  size_t v4; // rdx
  char *v5; // rbx
  const char *v6; // r14
  size_t v7; // r12
  size_t v8; // rdx
  char *v9; // r12
  __int64 v10; // [rsp+0h] [rbp-4C8h]
  __int64 v11; // [rsp+58h] [rbp-470h]
  char filename[1032]; // [rsp+90h] [rbp-438h]
  unsigned __int64 v13; // [rsp+498h] [rbp-30h]

  v1 = *(const char **)a1;
  v13 = __readfsqword(0x28u);
  v2 = strlen(v1);
  if ( v2 + 10 > 0x400 )
    return 0LL;
  v4 = v2;
  v5 = &filename[v2];
  __memcpy_chk(filename, v1, v4, 1024LL);
  *(_QWORD *)v5 = 7594245945063010150LL;
  *((_WORD *)v5 + 4) = 114;
  if ( __xstat(1, filename, (struct stat *)&v10) == -1 )
  {
    if ( *__errno_location() != 2 )
      return 1LL;
    result = *(_QWORD *)(a1 + 8) != 0LL;
  }
  else
  {
    if ( *(_QWORD *)(a1 + 8) != v11 )
      return 1LL;
    v6 = *(const char **)a1;
    v7 = strlen(*(const char **)a1);
    if ( v7 + 12 > 0x400 )
      return 0LL;
    v8 = v7;
    v9 = &filename[v7];
    __memcpy_chk(filename, v6, v8, 1024LL);
    *((_DWORD *)v9 + 2) = 7561577;
    *(_QWORD *)v9 = 7809574302246661990LL;
    if ( __xstat(1, filename, (struct stat *)&v10) == -1 )
    {
      if ( *__errno_location() != 2 )
        return 1LL;
      result = *(_QWORD *)(a1 + 16) != 0LL;
    }
    else
    {
      result = *(_QWORD *)(a1 + 16) != v11;
    }
  }
  return result;
}
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// B010: using guessed type char filename[1032];

//----- (000000000000B1B0) ----------------------------------------------------
__int64 __fastcall FontFileOpen(char *s)
{
  char *v1; // rbx
  int v2; // eax
  int v3; // er12
  __int64 v4; // rbp
  signed int v5; // eax
  bool v6; // cf
  bool v7; // zf
  char *v8; // rdi
  signed __int64 v9; // rcx
  char *v10; // rsi
  bool v11; // cf
  bool v12; // zf
  char *v13; // rsi
  char *v14; // rdi
  signed __int64 v15; // rcx
  __int64 result; // rax
  void *v17; // rdi

  v1 = s;
  v2 = open(s, 0);
  if ( v2 < 0 )
    return 0LL;
  v3 = v2;
  v4 = BufFileOpenRead((unsigned int)v2);
  if ( !v4 )
  {
    close(v3);
    return v4;
  }
  v5 = strlen(s);
  v6 = (unsigned int)v5 < 2;
  v7 = v5 == 2;
  if ( v5 <= 2 )
    return v4;
  v8 = ".Z";
  v9 = 3LL;
  v10 = &v1[v5 - 2];
  do
  {
    if ( !v9 )
      break;
    v6 = (unsigned __int8)*v10 < (unsigned __int8)*v8;
    v7 = *v10++ == *v8++;
    --v9;
  }
  while ( v7 );
  if ( (!v6 && !v7) == v6 )
  {
    result = BufFilePushCompressed(v4, v10);
    if ( result )
      return result;
    goto LABEL_17;
  }
  v11 = (unsigned int)v5 < 3;
  v12 = v5 == 3;
  if ( v5 == 3 )
    return v4;
  v13 = &v1[v5 - 3];
  v14 = ".gz";
  v15 = 4LL;
  do
  {
    if ( !v15 )
      break;
    v11 = (unsigned __int8)*v13 < (unsigned __int8)*v14;
    v12 = *v13++ == *v14++;
    --v15;
  }
  while ( v12 );
  if ( (!v11 && !v12) != v11 )
    return v4;
  result = BufFilePushZIP(v4, v13);
  if ( !result )
  {
LABEL_17:
    v17 = (void *)v4;
    v4 = 0LL;
    BufFileClose(v17);
    return v4;
  }
  return result;
}
// 8460: using guessed type __int64 __fastcall BufFilePushCompressed(_QWORD, _QWORD);
// 8490: using guessed type __int64 __fastcall BufFileOpenRead(_QWORD);
// 8C00: using guessed type __int64 __fastcall BufFilePushZIP(_QWORD, _QWORD);

//----- (000000000000B290) ----------------------------------------------------
__int64 __fastcall FontFileClose(void *a1)
{
  return BufFileClose(a1);
}

//----- (000000000000B2A0) ----------------------------------------------------
__int64 __fastcall FontFileOpenWrite(const char *a1)
{
  int v1; // eax
  __int64 result; // rax

  v1 = creat(a1, 0x1B6u);
  if ( v1 < 0 )
    result = 0LL;
  else
    result = BufFileOpenWrite((unsigned int)v1, 438LL);
  return result;
}
// 8250: using guessed type __int64 __fastcall BufFileOpenWrite(_QWORD, _QWORD);

//----- (000000000000B2F0) ----------------------------------------------------
signed __int64 __fastcall sub_B2F0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  signed int v2; // edx
  unsigned __int8 v3; // r9
  unsigned __int8 v4; // r10
  unsigned __int8 *v6; // r8
  unsigned __int8 *v7; // rcx
  unsigned __int8 v8; // al
  bool v9; // cc

  v2 = 0;
  while ( 1 )
  {
    v3 = *a1;
    v4 = *a2;
    if ( !*a1 )
      return (unsigned int)-(v4 != 0);
    if ( (unsigned __int8)(v3 - 48) > 9u || (unsigned __int8)(v4 - 48) > 9u )
    {
      v2 = 0;
      v9 = v3 <= v4;
      if ( v3 < v4 )
        return 0xFFFFFFFFLL;
    }
    else
    {
      if ( v2 != 1 )
      {
        v6 = a2;
        v7 = a1;
        while ( 1 )
        {
          ++v7;
          v8 = *++v6 - 48;
          if ( (unsigned __int8)(*v7 - 48) > 9u )
            break;
          if ( v8 > 9u )
            return 1LL;
        }
        if ( v8 <= 9u )
          return 0xFFFFFFFFLL;
        v2 = 1;
      }
      v9 = v3 <= v4;
      if ( v3 < v4 )
        return 0xFFFFFFFFLL;
    }
    if ( !v9 )
      break;
    ++a1;
    ++a2;
  }
  return 1LL;
}

//----- (000000000000B390) ----------------------------------------------------
signed __int64 __fastcall compar(const void *a1, const void *a2)
{
  return sub_B2F0(*(unsigned __int8 **)a1, *(unsigned __int8 **)a2);
}

//----- (000000000000B3A0) ----------------------------------------------------
__int64 __fastcall sub_B3A0(__int64 a1, char *a2, __int16 a3, signed int *a4, int *a5, _DWORD *a6)
{
  __int64 v6; // rbp
  char *v7; // rdi
  char *v8; // rcx
  char *v9; // r8
  char v10; // al
  int v11; // er12
  unsigned int v12; // er14
  signed int v14; // er11
  __int64 v15; // r15
  __int64 v16; // r13
  int v17; // eax
  int v18; // edi
  signed int v19; // er14
  __int64 v20; // r15
  __int64 v21; // r13
  int v22; // eax
  signed int *v23; // [rsp+8h] [rbp-50h]
  int *v24; // [rsp+10h] [rbp-48h]

  v6 = a1;
  v7 = 0LL;
  v23 = a4;
  v24 = a5;
  v8 = a2;
  v9 = 0LL;
  while ( 1 )
  {
    v10 = *v8;
    if ( !*v8 )
      break;
    if ( (v10 == 63 || v10 == 42) && !v7 )
      v7 = v8;
    if ( (unsigned __int8)(v10 - 48) <= 9u && !v9 )
      v9 = v8;
    ++v8;
  }
  v11 = *(_DWORD *)v6;
  if ( v7 )
  {
    *a6 = a3;
    if ( !*(_DWORD *)(v6 + 16) )
    {
LABEL_12:
      v12 = -1;
      *v23 = 0;
      *v24 = v11;
      return v12;
    }
    if ( v9 && v7 > v9 )
      v18 = (_DWORD)v9 - (_DWORD)a2;
    else
      v18 = (_DWORD)v7 - (_DWORD)a2;
    v19 = 0;
LABEL_27:
    if ( v19 < v11 )
    {
      v20 = *(_QWORD *)(v6 + 8);
      do
      {
        v21 = (v11 + v19) / 2;
        v22 = strncmp(a2, *(const char **)(v20 + 152 * v21), v18);
        if ( !v22 )
          break;
        if ( v22 >= 0 )
        {
          v19 = v21 + 1;
          goto LABEL_27;
        }
        v11 = (v11 + v19) / 2;
      }
      while ( (signed int)v21 > v19 );
    }
    *v23 = v19;
    v12 = -1;
    *v24 = v11;
  }
  else
  {
    *a6 = -1;
    if ( !*(_DWORD *)(v6 + 16) )
      goto LABEL_12;
    v14 = 0;
LABEL_16:
    if ( v14 >= v11 )
    {
LABEL_22:
      v12 = -1;
      *v23 = 1;
      *v24 = 0;
    }
    else
    {
      v15 = *(_QWORD *)(v6 + 8);
      while ( 1 )
      {
        v16 = (v14 + v11) / 2;
        v12 = (v14 + v11) / 2;
        v17 = sub_B2F0((unsigned __int8 *)a2, *(unsigned __int8 **)(v15 + 152 * v16));
        if ( !v17 )
          break;
        if ( v17 >= 0 )
        {
          v14 = v16 + 1;
          goto LABEL_16;
        }
        v11 = v16;
        if ( (signed int)v16 <= v14 )
          goto LABEL_22;
      }
    }
  }
  return v12;
}

//----- (000000000000B570) ----------------------------------------------------
__int64 __fastcall sub_B570(char *a1, int a2, _BYTE *a3, unsigned int a4)
{
  signed int v4; // er13
  unsigned int v5; // er12
  char v6; // al
  _BYTE *v7; // rbx
  bool v8; // cc
  char v9; // r14
  __int64 result; // rax
  signed __int64 v11; // rbp
  char v12; // al
  int v13; // er13
  char v14; // al

  v4 = a2;
  v5 = a4;
  v6 = *a1;
  v7 = a3;
  v8 = *a1 <= 42;
  if ( *a1 != 42 )
  {
    while ( !v8 )
    {
      if ( v6 != 45 )
      {
        if ( v6 == 63 )
        {
          v5 -= *a3 == 45;
          goto LABEL_6;
        }
        goto LABEL_20;
      }
      if ( *a3 != 45 )
        goto LABEL_21;
      --v4;
      --v5;
LABEL_6:
      v6 = *++a1;
      v7 = ++a3;
      v8 = *a1 <= 42;
      if ( *a1 == 42 )
        goto LABEL_7;
    }
    if ( !v6 )
      return *a3 == 0;
LABEL_20:
    if ( v6 != *a3 )
      goto LABEL_21;
    goto LABEL_6;
  }
LABEL_7:
  v9 = a1[1];
  result = 1LL;
  if ( v9 )
  {
    v11 = (signed __int64)(a1 + 2);
    if ( v9 == 45 )
    {
      v13 = v4 - 1;
      do
      {
        while ( 1 )
        {
          v14 = *(++v7 - 1);
          if ( v14 != 45 )
            break;
          if ( v13 <= (signed int)--v5 )
          {
            result = sub_B570(v11, (unsigned int)v13, v7, v5);
            if ( (_DWORD)result )
              return 1LL;
            if ( v13 == v5 )
              return result;
          }
        }
      }
      while ( v14 );
      result = 0LL;
    }
    else
    {
LABEL_9:
      while ( 1 )
      {
        v12 = *(++v7 - 1);
        if ( v9 != v12 )
          break;
LABEL_14:
        if ( (signed int)v5 >= v4 && (unsigned int)sub_B570(v11, (unsigned int)v4, v7, v5) )
          return 1LL;
      }
      while ( v12 )
      {
        if ( v12 != 45 )
          goto LABEL_9;
        if ( (signed int)v5 < v4 )
          break;
        ++v7;
        --v5;
        v12 = *(v7 - 1);
        if ( v9 == v12 )
          goto LABEL_14;
      }
LABEL_21:
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000000B6D0) ----------------------------------------------------
signed __int64 __fastcall FontFileInitTable(__int64 a1, unsigned int a2)
{
  signed __int64 result; // rax
  void *v3; // rax

  if ( a2 > 0xD79435 )
    return 0LL;
  if ( !a2 )
  {
    *(_QWORD *)(a1 + 8) = 0LL;
LABEL_4:
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = a2;
    result = 1LL;
    *(_DWORD *)(a1 + 16) = 0;
    return result;
  }
  v3 = malloc(152LL * (signed int)a2);
  *(_QWORD *)(a1 + 8) = v3;
  if ( v3 )
    goto LABEL_4;
  return 0LL;
}

//----- (000000000000B740) ----------------------------------------------------
void __fastcall FontFileFreeEntry(void **a1)
{
  void **v1; // rbp
  void *v2; // rdi
  int v3; // ebx
  _QWORD *v4; // r12
  char *v5; // rax
  __int64 v6; // rbp
  void *v7; // rdi

  v1 = a1;
  v2 = *a1;
  if ( v2 )
    free(v2);
  v3 = *((_DWORD *)v1 + 4);
  *v1 = 0LL;
  switch ( v3 )
  {
    case 2:
      free(v1[4]);
      v1[4] = 0LL;
      break;
    case 3:
      free(v1[3]);
      v1[3] = 0LL;
      break;
    case 0:
      free(v1[4]);
      v4 = v1[5];
      v5 = (char *)v4[16];
      if ( *((_DWORD *)v4 + 30) > 0 )
      {
        v6 = 0LL;
        do
        {
          v7 = *(void **)&v5[v6 + 112];
          if ( v7 )
          {
            free(v7);
            v5 = (char *)v4[16];
          }
          ++v3;
          v6 += 136LL;
        }
        while ( v3 < *((_DWORD *)v4 + 30) );
      }
      free(v5);
      free(v4);
      break;
  }
}

//----- (000000000000B820) ----------------------------------------------------
void __fastcall FontFileFreeTable(_DWORD *a1)
{
  _DWORD *v1; // r12
  __int64 v2; // rbp
  int v3; // ebx
  __int64 v4; // rdi

  v1 = a1;
  if ( *a1 > 0 )
  {
    v2 = 0LL;
    v3 = 0;
    do
    {
      ++v3;
      v4 = v2 + *((_QWORD *)v1 + 1);
      v2 += 152LL;
      FontFileFreeEntry(v4);
    }
    while ( *v1 > v3 );
  }
  free(*((void **)v1 + 1));
}
// 84B0: using guessed type __int64 __fastcall FontFileFreeEntry(_QWORD);

//----- (000000000000B870) ----------------------------------------------------
char *__fastcall FontFileMakeDir(char *s, unsigned int a2)
{
  char *v2; // rax
  const char *v3; // r13
  size_t v4; // rbx
  int v5; // eax
  int v6; // er15
  __int64 v7; // rdx
  signed __int64 v8; // rbp
  bool v9; // zf
  __int64 v10; // rax
  char *v11; // rax
  char *v12; // r14
  signed __int64 v13; // rax
  char *v14; // rdi
  __int64 v15; // rbx
  int v17; // eax
  void *v18; // rdi
  _BOOL4 v19; // [rsp+4h] [rbp-44h]
  signed __int64 v20; // [rsp+8h] [rbp-40h]

  v2 = strchr(s, 58);
  v3 = v2;
  if ( v2 )
  {
    v4 = (signed int)v2 - (signed int)s;
    v5 = strlen(v2);
    v6 = v5;
    v7 = v5 + 1;
    v8 = v4 + (s[v4 - 1] != 47);
    v9 = v5 == 0;
    v10 = 0LL;
    v19 = s[v4 - 1] != 47;
    if ( !v9 )
      v10 = v7;
  }
  else
  {
    v17 = strlen(s);
    v4 = v17;
    if ( s[v17 - 1] == 47 )
    {
      v8 = v17;
      v6 = 0;
      v19 = 0;
    }
    else
    {
      v8 = v17 + 1LL;
      v6 = 0;
      v19 = 1;
    }
    v10 = 0LL;
  }
  v11 = (char *)malloc(v8 + v10 + 81);
  v12 = v11;
  if ( v11 )
  {
    v20 = (signed __int64)(v11 + 24);
    if ( (unsigned int)FontFileInitTable(v11 + 24, 0LL) )
    {
      if ( (unsigned int)FontFileInitTable(v12 + 48, a2) )
      {
        *((_QWORD *)v12 + 1) = 0LL;
        *((_QWORD *)v12 + 2) = 0LL;
        v13 = (signed __int64)&v12[v8 + 81];
        *(_QWORD *)v12 = v12 + 80;
        if ( !v6 )
          v13 = 0LL;
        *((_QWORD *)v12 + 9) = v13;
        strncpy(v12 + 80, s, v4)[v4] = 0;
        v14 = (char *)*((_QWORD *)v12 + 9);
        if ( v14 )
          strcpy(v14, v3);
        if ( v19 )
        {
          v15 = *(_QWORD *)v12;
          *(_WORD *)(v15 + strlen(*(const char **)v12)) = 47;
        }
        return v12;
      }
      FontFileFreeTable(v20);
    }
    v18 = v12;
    v12 = 0LL;
    free(v18);
  }
  return v12;
}
// 8110: using guessed type __int64 __fastcall FontFileInitTable(_QWORD, _QWORD);
// 87E0: using guessed type __int64 __fastcall FontFileFreeTable(_QWORD);

//----- (000000000000BA00) ----------------------------------------------------
void __fastcall FontFileFreeDir(void *ptr)
{
  FontFileFreeTable((char *)ptr + 24);
  FontFileFreeTable((char *)ptr + 48);
  free(ptr);
}
// 87E0: using guessed type __int64 __fastcall FontFileFreeTable(_QWORD);

//----- (000000000000BA20) ----------------------------------------------------
__m128i *__fastcall FontFileAddEntry(signed int *a1, const __m128i *a2)
{
  __int64 v2; // rdx
  char *v3; // rax
  __m128i *v4; // rbp
  void *v5; // rax
  signed int v7; // ebp

  if ( a1[4] )
    return 0LL;
  v2 = *a1;
  v3 = (char *)*((_QWORD *)a1 + 1);
  if ( (_DWORD)v2 == a1[1] )
  {
    v7 = v2 + 100;
    v3 = (char *)realloc(*((void **)a1 + 1), 152LL * ((signed int)v2 + 100));
    if ( !v3 )
      return 0LL;
    a1[1] = v7;
    *((_QWORD *)a1 + 1) = v3;
    v2 = *a1;
  }
  v4 = (__m128i *)&v3[152 * v2];
  *v4 = _mm_loadu_si128(a2);
  v4[1] = _mm_loadu_si128(a2 + 1);
  v4[2] = _mm_loadu_si128(a2 + 2);
  v4[3] = _mm_loadu_si128(a2 + 3);
  v4[4] = _mm_loadu_si128(a2 + 4);
  v4[5] = _mm_loadu_si128(a2 + 5);
  v4[6] = _mm_loadu_si128(a2 + 6);
  v4[7] = _mm_loadu_si128(a2 + 7);
  v4[8] = _mm_loadu_si128(a2 + 8);
  v4[9].m128i_i64[0] = a2[9].m128i_i64[0];
  v5 = malloc(SLOWORD(a2->m128i_i64[1]) + 1);
  v4->m128i_i64[0] = (__int64)v5;
  if ( v5 )
  {
    memcpy(v5, (const void *)a2->m128i_i64[0], SLOWORD(a2->m128i_i64[1]));
    *(_BYTE *)(v4->m128i_i64[0] + SLOWORD(v4->m128i_i64[1])) = 0;
    ++*a1;
    return v4;
  }
  return 0LL;
}

//----- (000000000000BB50) ----------------------------------------------------
void __fastcall FontFileSortTable(void **a1)
{
  if ( !*((_DWORD *)a1 + 4) )
  {
    qsort(a1[1], *(signed int *)a1, 0x98uLL, (__compar_fn_t)compar);
    *((_DWORD *)a1 + 4) = 1;
  }
}

//----- (000000000000BB90) ----------------------------------------------------
__int64 __fastcall FontFileSortDir(__int64 a1)
{
  FontFileSortTable(a1 + 24);
  FontFileSortTable(a1 + 48);
  return FontFileSwitchStringsToBitmapPointers(a1);
}
// 87A0: using guessed type __int64 __fastcall FontFileSortTable(_QWORD);
// 8E50: using guessed type __int64 __fastcall FontFileSwitchStringsToBitmapPointers(_QWORD);

//----- (000000000000BBB0) ----------------------------------------------------
__int64 __fastcall FontFileCountDashes(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  __int64 v3; // rsi

  result = 0LL;
  v3 = a1 + a2;
  while ( a1 != v3 )
  {
    while ( *(_BYTE *)(++a1 - 1) == 45 )
    {
      result = (unsigned int)(result + 1);
      if ( a1 == v3 )
        return result;
    }
  }
  return result;
}

//----- (000000000000BBE0) ----------------------------------------------------
signed __int64 __fastcall FontFileFindNameInScalableDir(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // rbx
  char **v4; // r12
  int v5; // eax
  __int64 v6; // r9
  __int64 v8; // rsi
  int v9; // er10
  char *v10; // r11
  signed __int64 v11; // r8
  signed __int64 v12; // rbp
  signed int v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // edx
  int v17; // [rsp+Ch] [rbp-2Ch]
  int v18; // [rsp+10h] [rbp-28h]
  int v19; // [rsp+14h] [rbp-24h]
  unsigned __int64 v20; // [rsp+18h] [rbp-20h]

  v20 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(a1 + 8) )
    return 0LL;
  v3 = a3;
  v4 = (char **)a2;
  v5 = sub_B3A0(a1, *(char **)a2, *(_WORD *)(a2 + 10), &v17, &v18, &v19);
  if ( v5 < 0 )
  {
    if ( v17 < v18 )
    {
      v8 = *(_QWORD *)(a1 + 8);
      v9 = v19;
      v10 = *v4;
      v11 = v8 + 152LL * v17;
      v12 = v8 + 152 * ((unsigned int)(v18 - 1 - v17) + (signed __int64)v17) + 152;
      while ( 1 )
      {
        v13 = *(signed __int16 *)(v11 + 10);
        if ( v13 >= v9 )
        {
          v14 = sub_B570(v10, v9, *(_BYTE **)v11, v13);
          if ( v14 <= 0 )
          {
            if ( v14 )
              return 0LL;
          }
          else
          {
            if ( !v3 )
              return v6;
            v15 = *(_DWORD *)(v11 + 16);
            v16 = v15 ? -(v15 == 3) : *(_DWORD *)(*(_QWORD *)(v11 + 24) + 52LL);
            if ( ((*v3 & 3) != 2 && (*v3 & 0xC) != 8 || v16 & 1) && (!(*v3 & 0x40) || v16 & 2) )
              return v6;
          }
        }
        v11 += 152LL;
        if ( v11 == v12 )
          return 0LL;
      }
    }
    return 0LL;
  }
  return *(_QWORD *)(a1 + 8) + 152LL * v5;
}

//----- (000000000000BD70) ----------------------------------------------------
__int64 __fastcall FontFileFindNameInDir(__int64 a1, __int64 a2)
{
  return FontFileFindNameInScalableDir(a1, a2, 0LL);
}
// 8A30: using guessed type __int64 __fastcall FontFileFindNameInScalableDir(_QWORD, _QWORD, _QWORD);

//----- (000000000000BD80) ----------------------------------------------------
__int64 __fastcall FontFileFindNamesInScalableDir(__int64 a1, __int64 a2, int a3, struct _FontNames *a4, _DWORD *a5, int a6, _DWORD *a7)
{
  unsigned int v7; // ecx
  int v8; // ebx
  _DWORD *v9; // r13
  int v10; // er12
  int v11; // eax
  int v12; // er14
  char **v13; // r15
  int v15; // eax
  signed int v16; // ecx
  int v17; // eax
  char *v18; // r10
  int v19; // edx
  int v20; // edx
  char *v21; // ST20_8
  int v22; // eax
  int v23; // eax
  FontNamesPtr v24; // [rsp+8h] [rbp-F0h]
  int v25; // [rsp+34h] [rbp-C4h]
  int v26; // [rsp+38h] [rbp-C0h]
  int v27; // [rsp+3Ch] [rbp-BCh]
  char v28; // [rsp+40h] [rbp-B8h]
  unsigned __int64 v29; // [rsp+B8h] [rbp-40h]

  v24 = a4;
  v7 = 85;
  v29 = __readfsqword(0x28u);
  if ( a3 <= 0 )
    return v7;
  v8 = a3;
  v9 = a5;
  v10 = a6;
  v11 = sub_B3A0(a1, *(char **)a2, *(_WORD *)(a2 + 10), &v25, &v26, &v27);
  v12 = v11;
  if ( v11 < 0 )
  {
    v12 = v25;
    v13 = (char **)(*(_QWORD *)(a1 + 8) + 152LL * v25);
    v15 = v26;
  }
  else
  {
    v13 = (char **)(*(_QWORD *)(a1 + 8) + 152LL * v11);
    if ( !v10 || *((_DWORD *)v13 + 4) != 3 )
    {
      if ( a7 )
        *a7 = v8 - 1;
      return (unsigned int)AddFontNamesName(v24, *v13, *((signed __int16 *)v13 + 4));
    }
    v15 = v11 + 1;
    v25 = v12;
    v26 = v12 + 1;
  }
  if ( v12 < v15 )
  {
    do
    {
      v16 = *((signed __int16 *)v13 + 5);
      if ( v16 >= v27 )
      {
        v17 = sub_B570(*(char **)a2, v27, *v13, v16);
        if ( v17 <= 0 )
        {
          if ( v17 )
            break;
        }
        else
        {
          if ( v9 )
          {
            v19 = *((_DWORD *)v13 + 4);
            v20 = v19 ? -(v19 == 3) : *((_DWORD *)v13[3] + 13);
            if ( ((*v9 & 3) == 2 || (*v9 & 0xC) == 8) && !(v20 & 1) || *v9 & 0x40 && !(v20 & 2) )
              goto LABEL_12;
          }
          if ( v10 & 2 && *((_DWORD *)v13 + 4) == 3 )
          {
            if ( (unsigned int)FontParseXLFDName(v18) && !(v28 & 0xF) )
              goto LABEL_12;
            v18 = *v13;
          }
          v7 = AddFontNamesName(v24, v18, *((signed __int16 *)v13 + 4));
          if ( v7 != 85 )
            goto LABEL_28;
          if ( v10 & 1 )
          {
            if ( *((_DWORD *)v13 + 4) == 3 )
            {
              v24->length[v24->nnames - 1] = -v24->length[v24->nnames - 1];
              v21 = v13[3];
              v22 = strlen(v13[3]);
              v23 = AddFontNamesName(v24, v21, v22);
              v7 = 85;
              if ( v23 != 85 )
              {
                v7 = v23;
                goto LABEL_28;
              }
            }
          }
          if ( !--v8 )
            goto LABEL_28;
        }
      }
LABEL_12:
      ++v12;
      v13 += 19;
    }
    while ( v12 < v26 );
  }
  v7 = 85;
LABEL_28:
  if ( a7 )
    *a7 = v8;
  return v7;
}

//----- (000000000000C030) ----------------------------------------------------
__int64 __fastcall FontFileFindNamesInDir(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return FontFileFindNamesInScalableDir(a1, a2, a3, a4, 0LL, 0LL, 0LL);
}
// 8690: using guessed type __int64 __fastcall FontFileFindNamesInScalableDir(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000C050) ----------------------------------------------------
_BOOL8 __fastcall FontFileMatchName(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v5; // [rsp+0h] [rbp-C8h]
  __int64 *v6; // [rsp+8h] [rbp-C0h]
  int v7; // [rsp+10h] [rbp-B8h]
  __int64 v8; // [rsp+20h] [rbp-A8h]
  __int16 v9; // [rsp+28h] [rbp-A0h]
  __int16 v10; // [rsp+2Ah] [rbp-9Eh]
  unsigned __int64 v11; // [rsp+B8h] [rbp-10h]

  v3 = a3;
  v11 = __readfsqword(0x28u);
  v8 = a1;
  v9 = a2;
  v5 = 4294967297LL;
  v7 = 1;
  v6 = &v8;
  v10 = FontFileCountDashes(a1, a2, a3);
  return FontFileFindNameInDir(&v5, v3) != 0;
}
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);

//----- (000000000000C0E0) ----------------------------------------------------
__int64 __fastcall FontFileAddFontFile(__int64 a1, char *a2, const char *a3)
{
  __int64 v3; // r14
  const char *v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rbp
  __int16 v7; // ax
  int v8; // edx
  __int64 v9; // rdx
  unsigned int v10; // er12
  _QWORD *v11; // r13
  const char *v13; // r12
  const char *v14; // r13
  signed int v15; // er15
  char *v16; // rax
  bool v17; // cf
  bool v18; // zf
  const char *v19; // rdi
  signed __int64 v20; // rcx
  const char *v21; // rsi
  char *v22; // r12
  __m128i *v23; // rbx
  int v24; // eax
  double v25; // xmm0_8
  __int32 v26; // eax
  bool v27; // cc
  double v28; // xmm0_8
  __int32 v29; // edx
  __int64 v30; // rbp
  FontResolutionPtr v31; // rax
  char *v32; // rdi
  __int64 v33; // rax
  __m128i v34; // xmm0
  __int64 v35; // r15
  __m128i *v36; // rax
  char *v37; // rax
  int v38; // [rsp+1Ch] [rbp-1DCh]
  __int128 v39; // [rsp+20h] [rbp-1D8h]
  __int128 v40; // [rsp+30h] [rbp-1C8h]
  __int128 v41; // [rsp+40h] [rbp-1B8h]
  __int128 v42; // [rsp+50h] [rbp-1A8h]
  __int128 v43; // [rsp+60h] [rbp-198h]
  __int128 v44; // [rsp+70h] [rbp-188h]
  __int128 v45; // [rsp+80h] [rbp-178h]
  __int64 v46; // [rsp+90h] [rbp-168h]
  int v47; // [rsp+A0h] [rbp-158h]
  __int64 v48; // [rsp+A4h] [rbp-154h]
  __int64 v49; // [rsp+F0h] [rbp-108h]
  char *s; // [rsp+120h] [rbp-D8h]
  __int16 v51; // [rsp+128h] [rbp-D0h]
  __int16 v52; // [rsp+12Ah] [rbp-CEh]
  int v53; // [rsp+130h] [rbp-C8h]
  __int64 v54; // [rsp+138h] [rbp-C0h]
  __int128 ptr; // [rsp+140h] [rbp-B8h]
  unsigned __int64 v56; // [rsp+1B8h] [rbp-40h]

  v3 = a1;
  v4 = a3;
  v56 = __readfsqword(0x28u);
  v5 = FontFileMatchRenderer(a3);
  if ( !v5 )
    return 0;
  v6 = v5;
  v7 = strlen(a2);
  if ( v7 > 1024 )
  {
    v8 = 1024;
    v51 = 1024;
  }
  else
  {
    v51 = v7;
    v8 = v7;
  }
  s = a2;
  sub_CCE0(a2, a2, v8);
  v52 = FontFileCountDashes(a2, (unsigned int)v51, v9);
  a2[v51] = 0;
  if ( v52 != 14 || !(unsigned int)FontParseXLFDName(s) || (v39 & 3) == 2 || (v39 & 0xC) == 8 || v39 & 0x40 )
    goto LABEL_67;
  if ( !(v39 & 3) )
    goto LABEL_68;
  if ( !(v39 & 0xC) )
    goto LABEL_68;
  v13 = *(const char **)(a1 + 72);
  if ( !v13 || *v13 != 58 )
    goto LABEL_68;
  v14 = v13 + 1;
  v15 = 1;
  while ( 1 )
  {
    v16 = strchr(v14, 58);
    if ( !v16 )
      break;
    v17 = (unsigned int)((_DWORD)v16 - (_DWORD)v14) < 8;
    v18 = (_DWORD)v16 - (_DWORD)v14 == 8;
    if ( (_DWORD)v16 - (_DWORD)v14 == 8 )
    {
      v19 = "unscaled";
      v20 = 8LL;
      v21 = v14;
      do
      {
        if ( !v20 )
          break;
        v17 = (const unsigned __int8)*v21 < *v19;
        v18 = *v21++ == *v19++;
        --v20;
      }
      while ( v18 );
      if ( (!v17 && !v18) == v17 )
        v15 = 0;
    }
    v14 = v16 + 1;
  }
  if ( (unsigned int)strlen(v13) + (_DWORD)v13 - (_DWORD)v14 == 8 && !strncmp(v14, "unscaled", 8uLL) || !v15 )
  {
LABEL_67:
    v10 = 0;
  }
  else
  {
LABEL_68:
    if ( !(v39 & 0xF) )
    {
      v11 = 0LL;
LABEL_35:
      v22 = strdup(v4);
      *(_QWORD *)&ptr = v22;
      if ( !v22 )
        return 0;
      v23 = (__m128i *)malloc(0x90uLL);
      if ( !v23 )
      {
        v32 = v22;
        v10 = 0;
        free(v32);
        return v10;
      }
      memset(v23, 0, 0x78uLL);
      if ( (v39 & 0xC) != 4 || (signed int)(10.0 * *(double *)&v43) != GetDefaultPointSize() )
      {
        v24 = GetDefaultPointSize();
        v23[3].m128i_i64[1] = 0LL;
        v23[3].m128i_i64[0] = 0LL;
        LODWORD(v23->m128i_i64[0]) = 4;
        v23[5].m128i_i32[2] = -1;
        v25 = (double)v24;
        v26 = v44;
        v27 = (signed int)v44 <= 0;
        v28 = v25 / 10.0;
        *(double *)v23[4].m128i_i64 = v28;
        *(double *)&v23[2].m128i_i64[1] = v28;
        if ( v27 || (v29 = DWORD1(v44), SDWORD1(v44) <= 0) )
        {
          v31 = GetClientResolutions(&v38);
          if ( v31 && v38 > 0 )
          {
            v23[5].m128i_i32[0] = v31->x_resolution;
            v23[5].m128i_i32[1] = v31->y_resolution;
          }
          else
          {
            v23[5].m128i_i64[0] = 322122547275LL;
          }
        }
        else
        {
          v23[5].m128i_i32[0] = v26;
          v23[5].m128i_i32[1] = v29;
        }
        FontFileCompleteXLFD(v23, v23);
      }
      else
      {
        v33 = v46;
        *v23 = _mm_load_si128((const __m128i *)&v39);
        v34 = _mm_load_si128((const __m128i *)&v40);
        v23[7].m128i_i64[0] = v33;
        v23[1] = v34;
        v23[2] = _mm_load_si128((const __m128i *)&v41);
        v23[3] = _mm_load_si128((const __m128i *)&v42);
        v23[4] = _mm_load_si128((const __m128i *)&v43);
        v23[5] = _mm_load_si128((const __m128i *)&v44);
        v23[6] = _mm_load_si128((const __m128i *)&v45);
      }
      v23[7].m128i_i64[1] = 0LL;
      v23[8].m128i_i64[0] = 0LL;
      v23[8].m128i_i64[1] = 0LL;
      v54 = v6;
      v53 = 0;
      *((_QWORD *)&ptr + 1) = v23;
      v30 = FontFileAddEntry(v3 + 24, &s);
      if ( v30 )
      {
        if ( v39 & 0xF && v11 )
        {
          FontFileCompleteXLFD(&v39, &v39);
          FontFileAddScaledInstance(v30, &v39, 0LL, *v11);
        }
        return 1;
      }
      free(v23);
      goto LABEL_11;
    }
    v10 = 1;
  }
  v53 = 2;
  v54 = v6;
  ptr = (unsigned __int64)strdup(v4);
  if ( !(_QWORD)ptr )
    return 0;
  v11 = (_QWORD *)FontFileAddEntry(v3 + 48, &s);
  if ( !v11 )
  {
LABEL_11:
    free((void *)ptr);
    return 0;
  }
  if ( v10 )
  {
    if ( v39 & 0xF )
    {
      v48 = 0LL;
      memset((char *)&v48 + 4, 0, 0x70uLL);
      v47 = 5;
      v49 = v44;
      FontParseXLFDName(s);
      v51 = strlen(s);
      v35 = FontFileFindNameInDir(v3 + 24, &s);
      if ( v35 )
      {
        if ( (v39 & 0xC) != 4 )
          goto LABEL_69;
        if ( (signed int)(10.0 * *(double *)&v43) != GetDefaultPointSize() )
          goto LABEL_69;
        v36 = *(__m128i **)(v35 + 40);
        *v36 = _mm_load_si128((const __m128i *)&v39);
        v36[1] = _mm_load_si128((const __m128i *)&v40);
        v36[2] = _mm_load_si128((const __m128i *)&v41);
        v36[3] = _mm_load_si128((const __m128i *)&v42);
        v36[4] = _mm_load_si128((const __m128i *)&v43);
        v36[5] = _mm_load_si128((const __m128i *)&v44);
        v36[6] = _mm_load_si128((const __m128i *)&v45);
        v36[7].m128i_i64[0] = v46;
        free(*(void **)(v35 + 32));
        v37 = strdup(v4);
        *(_QWORD *)(v35 + 32) = v37;
        if ( v37 )
        {
LABEL_69:
          FontFileCompleteXLFD(&v39, &v39);
          FontFileAddScaledInstance(v35, &v39, 0LL, *v11);
          return v10;
        }
        return 0;
      }
    }
    goto LABEL_35;
  }
  return 1;
}
// 8350: using guessed type __int64 __fastcall FontFileAddEntry(_QWORD, _QWORD);
// 8420: using guessed type __int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD);
// 8B60: using guessed type __int64 __fastcall FontFileAddScaledInstance(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 8F10: using guessed type __int64 __fastcall FontFileMatchRenderer(_QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);

//----- (000000000000C730) ----------------------------------------------------
signed __int64 __fastcall FontFileAddFontAlias(__int64 a1, char *a2, const char *a3)
{
  const char *v3; // rbp
  signed __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // rdx
  char *v7; // [rsp+0h] [rbp-B8h]
  __int16 v8; // [rsp+8h] [rbp-B0h]
  __int16 v9; // [rsp+Ah] [rbp-AEh]
  int v10; // [rsp+10h] [rbp-A8h]
  void *ptr; // [rsp+18h] [rbp-A0h]
  unsigned __int64 v12; // [rsp+98h] [rbp-20h]

  v3 = a3;
  v12 = __readfsqword(0x28u);
  if ( !strcmp(a2, a3) )
    goto LABEL_2;
  v8 = strlen(a2);
  sub_CCE0(a2, a2, v8);
  v7 = a2;
  v9 = FontFileCountDashes(a2, (unsigned int)v8, v5);
  v10 = 3;
  ptr = strdup(v3);
  if ( !ptr )
    goto LABEL_2;
  v6 = FontFileAddEntry(a1 + 48, &v7);
  result = 1LL;
  if ( !v6 )
  {
    free(ptr);
LABEL_2:
    result = 0LL;
  }
  return result;
}
// 8350: using guessed type __int64 __fastcall FontFileAddEntry(_QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);

//----- (000000000000C830) ----------------------------------------------------
__int64 __fastcall font_encoding_recode(__int64 a1, __int64 a2, __int64 a3)
{
  if ( *(_QWORD *)(a3 + 48) == a2 )
    return FontEncRecode(a1, a3);
  ErrorF("Inconsistent mapping/encoding\n");
  return 0LL;
}
// 8670: using guessed type __int64 __fastcall FontEncRecode(_QWORD, _QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);

//----- (000000000000C860) ----------------------------------------------------
__int64 __fastcall font_encoding_name(__int64 a1, __int64 a2, __int64 a3)
{
  if ( *(_QWORD *)(a3 + 48) == a2 )
    return FontEncName(a1, a3);
  ErrorF("Inconsistent mapping/encoding\n");
  return 0LL;
}
// 85F0: using guessed type __int64 __fastcall FontEncName(_QWORD, _QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);

//----- (000000000000C8A0) ----------------------------------------------------
_BOOL8 __fastcall FontFileNameCheck(_BYTE *a1)
{
  return *a1 == 47;
}

//----- (000000000000C8B0) ----------------------------------------------------
signed __int64 __fastcall FontFileFreeFPE(__int64 a1)
{
  FontFileUnregisterBitmapSource();
  FontFileFreeDir(*(void **)(a1 + 24));
  return 85LL;
}
// 8C30: using guessed type __int64 FontFileUnregisterBitmapSource(void);

//----- (000000000000C8D0) ----------------------------------------------------
__int64 __fastcall FontFileInitFPE(FontPathElementPtr fpe)
{
  FontPathElementPtr v1; // rbp
  char *v2; // rdi
  unsigned int v3; // ebx
  __int64 v5; // rax
  __int64 v6; // [rsp+0h] [rbp-28h]
  unsigned __int64 v7; // [rsp+8h] [rbp-20h]

  v1 = fpe;
  v2 = fpe->name;
  v7 = __readfsqword(0x28u);
  v3 = FontFileReadDirectory(v2);
  if ( v3 == 85 )
  {
    v5 = v6;
    if ( *(_DWORD *)(v6 + 48) > 0 )
    {
      if ( !(unsigned int)FontFileRegisterBitmapSource(v1, &v6) )
      {
        v3 = 80;
        j_FontFileFreeFPE(v1);
        return v3;
      }
      v5 = v6;
    }
    v1->c_private = (pointer)v5;
  }
  return v3;
}
// 8220: using guessed type __int64 __fastcall FontFileRegisterBitmapSource(_QWORD, _QWORD);

//----- (000000000000C960) ----------------------------------------------------
__int64 __fastcall sub_C960(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6, __int64 a7)
{
  __int64 v7; // rbx
  __int64 v8; // r12
  size_t v9; // rax
  __int64 v10; // r13
  size_t v11; // rbp
  size_t v12; // rdx
  __int64 result; // rax
  unsigned int v14; // [rsp+4h] [rbp-864h]
  unsigned int v15; // [rsp+10h] [rbp-858h]
  unsigned int v16; // [rsp+14h] [rbp-854h]
  const char *v17; // [rsp+18h] [rbp-850h]
  char v18[2056]; // [rsp+20h] [rbp-848h]
  unsigned __int64 v19; // [rsp+828h] [rbp-40h]

  v7 = a4;
  v14 = a3;
  v19 = __readfsqword(0x28u);
  v16 = a5;
  v15 = a6;
  if ( a4 == -24 )
    return 83LL;
  v8 = *(_QWORD *)(a4 + 24);
  if ( !*(_QWORD *)(v8 + 16) )
    return 83LL;
  v17 = **(const char ***)(a1 + 24);
  v9 = strlen(v17);
  v10 = *(_QWORD *)(v7 + 32);
  v11 = v9;
  v12 = v9 + strlen(*(const char **)(v7 + 32));
  result = 83LL;
  if ( v12 <= 0x800 )
  {
    __memcpy_chk(v18, v17, v11, 2049LL);
    __strcpy_chk(&v18[v11], v10, 2049LL);
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64, char *, _QWORD, _QWORD, __int64))(v8 + 16))(
               a1,
               a2,
               v14,
               v7,
               v18,
               v16,
               v15,
               a7);
    if ( (_DWORD)result == 85 )
    {
      *(_QWORD *)(v7 + 40) = *(_QWORD *)a2;
      *(_QWORD *)(*(_QWORD *)a2 + 160LL) = v7;
    }
  }
  return result;
}
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// C960: using guessed type char var_848[2056];

//----- (000000000000CAB0) ----------------------------------------------------
__int64 __fastcall sub_CAB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  size_t v5; // rax
  __int64 v6; // r13
  size_t v7; // rbp
  size_t v8; // rdx
  __int64 result; // rax
  const char *v10; // [rsp+8h] [rbp-850h]
  char v11[2056]; // [rsp+10h] [rbp-848h]
  unsigned __int64 v12; // [rsp+818h] [rbp-40h]

  v12 = __readfsqword(0x28u);
  if ( a3 == -24 )
    return 83LL;
  v3 = *(_QWORD *)(a3 + 24);
  v4 = a3;
  if ( !*(_QWORD *)(v3 + 32) )
    return 83LL;
  v10 = **(const char ***)(a1 + 24);
  v5 = strlen(v10);
  v6 = *(_QWORD *)(v4 + 32);
  v7 = v5;
  v8 = v5 + strlen(*(const char **)(v4 + 32));
  result = 83LL;
  if ( v8 <= 0x800 )
  {
    __memcpy_chk(v11, v10, v7, 2049LL);
    __strcpy_chk(&v11[v7], v6, 2049LL);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *))(v3 + 32))(a1, a2, v4, v11);
  }
  return result;
}
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// CAB0: using guessed type char var_848[2056];

//----- (000000000000CBB0) ----------------------------------------------------
__int64 __fastcall FontFileCloseFont(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  int v3; // eax

  v2 = *(_QWORD *)(a2 + 160);
  if ( v2 )
  {
    v3 = *(_DWORD *)(v2 + 16);
    if ( v3 )
    {
      if ( v3 == 2 )
        *(_QWORD *)(v2 + 40) = 0LL;
    }
    else
    {
      FontFileRemoveScaledInstance();
    }
    *(_QWORD *)(a2 + 160) = 0LL;
  }
  return (*(__int64 (__fastcall **)(__int64))(a2 + 120))(a2);
}
// 8F30: using guessed type __int64 FontFileRemoveScaledInstance(void);

//----- (000000000000CC00) ----------------------------------------------------
__int64 __fastcall FontFileListNextFontOrAlias(void *ptr, __int64 a2, char **a3, int *a4, _QWORD *a5, _DWORD *a6, signed int *ptra)
{
  struct _FontNames *v7; // rdi
  __int64 v8; // rax
  char *v9; // rsi
  int v10; // eax
  __int64 result; // rax
  __int64 v12; // rdx
  int v13; // eax

  v7 = *(struct _FontNames **)ptra;
  v8 = ptra[2];
  if ( (_DWORD)v8 == **(_DWORD **)ptra )
  {
    FreeFontNames(v7);
    free(ptra);
    result = 83LL;
  }
  else
  {
    v9 = v7->names[v8];
    v10 = v7->length[v8];
    *a3 = v9;
    if ( v10 < 0 )
    {
      *a4 = -v10;
      v12 = *(_QWORD *)(*(_QWORD *)ptra + 16LL);
      v13 = ptra[2] + 1;
      ptra[2] = v13;
      *a5 = *(_QWORD *)(v12 + 8LL * v13);
      *a6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)ptra + 8LL) + 4LL * ptra[2]);
      result = 82LL;
    }
    else
    {
      *a4 = v10;
      result = 85LL;
    }
    ++ptra[2];
  }
  return result;
}

//----- (000000000000CC90) ----------------------------------------------------
signed __int64 __fastcall FontFileResetFPE(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 24);
  if ( (unsigned int)FontFileDirectoryChanged(*(_QWORD *)(a1 + 24))
    || *(_DWORD *)(v2 + 48) > 0 && !(unsigned int)FontFileRegisterBitmapSource(a1, a2) )
  {
    result = 89LL;
  }
  else
  {
    result = 85LL;
  }
  return result;
}
// 8220: using guessed type __int64 __fastcall FontFileRegisterBitmapSource(_QWORD, _QWORD);
// 8950: using guessed type __int64 __fastcall FontFileDirectoryChanged(_QWORD);

//----- (000000000000CCE0) ----------------------------------------------------
void __fastcall sub_CCE0(_BYTE *a1, char *a2, int a3)
{
  __int64 v3; // r9
  _BYTE *v4; // rdx
  signed __int64 v5; // r9
  char *v6; // r8
  char v7; // al

  if ( a3 > 0 )
  {
    v3 = (unsigned int)(a3 - 1);
    v4 = a1;
    v5 = v3 + 1;
    v6 = &a2[v5];
    do
    {
      while ( 1 )
      {
        v7 = *a2;
        if ( (unsigned __int8)(*a2 - 65) > 0x19u && (unsigned __int8)(v7 + 64) > 0x16u )
          break;
        ++a2;
        *(++v4 - 1) = v7 + 32;
        if ( a2 == v6 )
          goto LABEL_9;
      }
      if ( (unsigned __int8)(v7 + 40) < 7u )
        v7 += 32;
      ++a2;
      *(++v4 - 1) = v7;
    }
    while ( a2 != v6 );
LABEL_9:
    a1 += v5;
  }
  *a1 = 0;
}

//----- (000000000000CD50) ----------------------------------------------------
signed __int64 __fastcall sub_CD50(char *a1, int a2, const char *a3, char **a4, const __m128i *a5)
{
  const char *v5; // rbx
  char **v6; // r12
  const __m128i *v7; // r14
  signed int v8; // eax
  __int64 v9; // rdx
  signed int v11; // ebp
  __int64 v12; // rax
  char *v13; // r11
  int v14; // [rsp+10h] [rbp-548h]
  __m128i v15; // [rsp+90h] [rbp-4C8h]
  __m128i v16; // [rsp+A0h] [rbp-4B8h]
  __m128i v17; // [rsp+B0h] [rbp-4A8h]
  __m128i v18; // [rsp+C0h] [rbp-498h]
  __m128i v19; // [rsp+D0h] [rbp-488h]
  __m128i v20; // [rsp+E0h] [rbp-478h]
  __m128i v21; // [rsp+F0h] [rbp-468h]
  __int64 v22; // [rsp+100h] [rbp-458h]
  char v23[1032]; // [rsp+110h] [rbp-448h]
  unsigned __int64 v24; // [rsp+518h] [rbp-40h]

  v5 = a3;
  v6 = a4;
  v7 = a5;
  *a4 = (char *)a3;
  v24 = __readfsqword(0x28u);
  v8 = strlen(a3);
  if ( v8 <= 1024 && a2 <= 1023 )
  {
    v11 = v8;
    if ( (unsigned int)FontFileCountDashes(v5, (unsigned int)v8, v9) == 14 )
    {
      v12 = v7[7].m128i_i64[0];
      v15 = _mm_load_si128(v7);
      v22 = v12;
      v16 = _mm_load_si128(v7 + 1);
      v17 = _mm_load_si128(v7 + 2);
      v18 = _mm_load_si128(v7 + 3);
      v19 = _mm_load_si128(v7 + 4);
      v20 = _mm_load_si128(v7 + 5);
      v21 = _mm_load_si128(v7 + 6);
      sub_CCE0(v23, a1, a2);
      v23[a2] = 0;
      if ( (unsigned int)FontParseXLFDName(v13) )
      {
        if ( !v14 )
        {
          if ( (unsigned int)FontParseXLFDName(*v6) )
          {
            sub_CCE0(dest, *v6, v11 + 1);
            if ( (unsigned int)FontParseXLFDName(dest) )
              *v6 = dest;
          }
        }
      }
    }
  }
  return 1LL;
}
// 8420: using guessed type __int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// CD50: using guessed type char var_448[1032];

//----- (000000000000D0B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_D0B0(struct _FontNames *a1, int *a2, __int64 a3, char *a4, const __m128i *a5, __int64 a6, __int32 a7, _DWORD *a8)
{
  int v8; // er9
  int *v9; // r14
  const __m128i *v10; // r15
  int v11; // ebp
  __int64 v12; // rbx
  __int64 v13; // rax
  int v14; // er12
  __m128i v15; // xmm0
  int v16; // esi
  __int32 v17; // edi
  int v18; // er8
  __int64 v19; // xmm0_8
  char *v20; // rdx
  int v21; // ecx
  unsigned int v22; // eax
  __int64 v23; // rax
  __int64 v24; // rbp
  char *v26; // rsi
  int v27; // edx
  unsigned int v28; // eax
  unsigned int v29; // edx
  bool v30; // zf
  char *v31; // rdx
  int v32; // ecx
  unsigned int v33; // eax
  bool v34; // zf
  char *v35; // r12
  int v36; // eax
  const char *v37; // r12
  char *v38; // rbx
  int v39; // eax
  __int64 v40; // [rsp+28h] [rbp-580h]
  char *v41; // [rsp+30h] [rbp-578h]
  FontNamesPtr v42; // [rsp+38h] [rbp-570h]
  __int64 v43; // [rsp+40h] [rbp-568h]
  char *s; // [rsp+58h] [rbp-550h]
  char v45; // [rsp+60h] [rbp-548h]
  __m128i v46; // [rsp+E0h] [rbp-4C8h]
  __m128i v47; // [rsp+F0h] [rbp-4B8h]
  __m128i v48; // [rsp+100h] [rbp-4A8h]
  __m128i v49; // [rsp+110h] [rbp-498h]
  __m128i v50; // [rsp+120h] [rbp-488h]
  __m128i v51; // [rsp+130h] [rbp-478h]
  __m128i v52; // [rsp+140h] [rbp-468h]
  __int64 v53; // [rsp+150h] [rbp-458h]
  char v54; // [rsp+160h] [rbp-448h]
  unsigned __int64 v55; // [rsp+568h] [rbp-40h]

  v40 = a6;
  v8 = *a2;
  v55 = __readfsqword(0x28u);
  v42 = a1;
  v43 = a3;
  v41 = a4;
  if ( v8 > 0 && *a8 )
  {
    v9 = a2;
    v10 = a5;
    v11 = 0;
    while ( 1 )
    {
      v12 = v11;
      FontParseXLFDName(*(char **)(*((_QWORD *)v9 + 2) + 8LL * v11));
      v13 = v10[7].m128i_i64[0];
      v14 = v11 + 1;
      v46 = _mm_load_si128(v10);
      v15 = _mm_load_si128(v10 + 1);
      v53 = v13;
      v47 = v15;
      v48 = _mm_load_si128(v10 + 2);
      v49 = _mm_load_si128(v10 + 3);
      v50 = _mm_load_si128(v10 + 4);
      v51 = _mm_load_si128(v10 + 5);
      v52 = _mm_load_si128(v10 + 6);
      if ( (unsigned int)FontFileCompleteXLFD(&v46, &v45) )
        break;
LABEL_4:
      if ( *v9 > v14 )
      {
        v11 = v14;
        if ( *a8 )
          continue;
      }
      return __readfsqword(0x28u) ^ v55;
    }
    --*a8;
    __strcpy_chk(&v54, *(_QWORD *)(*((_QWORD *)v9 + 2) + 8LL * v11), 1024LL);
    v16 = v10->m128i_i64[0];
    v17 = v10[5].m128i_i32[1];
    if ( (v10->m128i_i64[0] & 0x13) == 16 && v17 )
    {
      LOBYTE(v18) = v16;
      if ( (v16 & 0x2C) == 32 )
        goto LABEL_10;
    }
    else
    {
      v18 = v10->m128i_i64[0];
      v46.m128i_i64[1] = v10->m128i_i64[1];
      v47.m128i_i64[0] = v10[1].m128i_i64[0];
      v19 = v10[1].m128i_i64[1];
      v46.m128i_i32[0] = v18 & 3 | v46.m128i_i32[0] & 0xFFFFFFFC;
      v47.m128i_i64[1] = v19;
      v48.m128i_i64[0] = v10[2].m128i_i64[0];
      if ( (v16 & 0x2C) == 32 && v17 )
        goto LABEL_10;
    }
    v48.m128i_i64[1] = v10[2].m128i_i64[1];
    v49.m128i_i64[0] = v10[3].m128i_i64[0];
    v46.m128i_i32[0] = v18 & 0xC | v46.m128i_i32[0] & 0xFFFFFFF3;
    v49.m128i_i64[1] = v10[3].m128i_i64[1];
    v50.m128i_i64[0] = v10[4].m128i_i64[0];
LABEL_10:
    if ( v10[5].m128i_i32[2] <= 0 )
      v51.m128i_i32[2] = 0;
    if ( !v10[5].m128i_i32[0] )
      v51.m128i_i32[0] = 0;
    if ( !v17 )
      v51.m128i_i32[1] = 0;
    v53 = v40;
    v52.m128i_i32[2] = a7;
    FontParseXLFDName(&v54);
    if ( *(_DWORD *)(*((_QWORD *)v9 + 1) + 4LL * v11) < 0 )
    {
      v26 = v41;
      v10[7].m128i_i64[0] = v40;
      v10[6].m128i_i32[2] = a7;
      do
      {
        v27 = *(_DWORD *)v26;
        v26 += 4;
        v28 = ~v27 & (v27 - 16843009) & 0x80808080;
      }
      while ( !v28 );
      v29 = v28 >> 16;
      v30 = (unsigned __int16)(v28 & 0x8080) == 0;
      if ( !(v28 & 0x8080) )
        LOBYTE(v28) = v29;
      if ( v30 )
        LODWORD(v26) = (_DWORD)v26 + 2;
      if ( (unsigned int)sub_CD50(
                           v41,
                           (unsigned int)v26 - (__CFADD__((_BYTE)v28, (_BYTE)v28) + 3) - (unsigned int)v41,
                           *(const char **)(*((_QWORD *)v9 + 2) + 8LL * v11 + 8),
                           &s,
                           v10) )
      {
        v31 = &v54;
        do
        {
          v32 = *(_DWORD *)v31;
          v31 += 4;
          v33 = ~v32 & (v32 - 16843009) & 0x80808080;
        }
        while ( !v33 );
        v34 = (unsigned __int16)(v33 & 0x8080) == 0;
        if ( !(v33 & 0x8080) )
          LOBYTE(v33) = BYTE2(v33);
        if ( v34 )
          LODWORD(v31) = (_DWORD)v31 + 2;
        AddFontNamesName(v42, &v54, (_DWORD)v31 - (__CFADD__((_BYTE)v33, (_BYTE)v33) + 3) - (unsigned __int64)&v54);
        v42->length[v42->nnames - 1] = -v42->length[v42->nnames - 1];
        v35 = s;
        v36 = strlen(s);
        AddFontNamesName(v42, v35, v36);
        v37 = *(const char **)(*((_QWORD *)v9 + 2) + 8LL * v11);
        if ( strcmp(&v54, v37)
          && (unsigned int)FontFileMatchName(v37, (unsigned int)-*(_DWORD *)(*((_QWORD *)v9 + 1) + 4LL * v11), v43)
          && *a8 )
        {
          --*a8;
          AddFontNamesName(
            v42,
            *(char **)(*((_QWORD *)v9 + 2) + 8LL * v11),
            -*(_DWORD *)(*((_QWORD *)v9 + 1) + 4LL * v11));
          v42->length[v42->nnames - 1] = -v42->length[v42->nnames - 1];
          v38 = s;
          v39 = strlen(s);
          AddFontNamesName(v42, v38, v39);
        }
      }
      v14 = v11 + 2;
    }
    else
    {
      v20 = &v54;
      do
      {
        v21 = *(_DWORD *)v20;
        v20 += 4;
        v22 = ~v21 & (v21 - 16843009) & 0x80808080;
      }
      while ( !v22 );
      if ( !(~v21 & (v21 - 16843009) & 0x8080) )
        LOBYTE(v22) = (~v21 & (v21 - 16843009) & 0x80808080) >> 16;
      if ( !(~v21 & (v21 - 16843009) & 0x8080) )
        LODWORD(v20) = (_DWORD)v20 + 2;
      AddFontNamesName(v42, &v54, (_DWORD)v20 - (__CFADD__((_BYTE)v22, (_BYTE)v22) + 3) - (unsigned __int64)&v54);
      v23 = *((_QWORD *)v9 + 2);
      v24 = *(_QWORD *)(v23 + 8LL * v11);
      if ( strcmp(&v54, *(const char **)(v23 + 8 * v12))
        && (unsigned int)FontFileMatchName(v24, *(unsigned int *)(*((_QWORD *)v9 + 1) + 4 * v12), v43)
        && *a8 )
      {
        --*a8;
        AddFontNamesName(v42, *(char **)(*((_QWORD *)v9 + 2) + 8 * v12), *(_DWORD *)(*((_QWORD *)v9 + 1) + 4 * v12));
      }
    }
    goto LABEL_4;
  }
  return __readfsqword(0x28u) ^ v55;
}
// 8420: using guessed type __int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD);
// 84D0: using guessed type __int64 __fastcall FontFileMatchName(_QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);

//----- (000000000000DB58) ----------------------------------------------------
void __usercall sub_DB58(__int64 a1@<rax>, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7, unsigned int a8, __int64 a9, __int64 a10)
{
  int v10; // eax

  v10 = sub_C960(a6, a5, a8, a1, a9, HIDWORD(a9), a10);
  JUMPOUT(v10, 85, sub_DBF0);
  JUMPOUT(v10, 83, &loc_D7A4);
  JUMPOUT(&loc_D75C);
}

//----- (000000000000DB9A) ----------------------------------------------------
void __fastcall sub_DB9A(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, _QWORD *a10, __int64 a11, int a12, unsigned int a13, __int64 a14, __int64 a15)
{
  JUMPOUT(sub_C960(a11, (__int64)a10, a13, a4, a14, HIDWORD(a14), a15), 85, &loc_D75C);
  JUMPOUT(*a10, 0LL, &loc_DC01);
  JUMPOUT(loc_DBE0);
}

//----- (000000000000DBF0) ----------------------------------------------------
void __fastcall sub_DBF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, _QWORD *a10, __int64 a11)
{
  JUMPOUT(*a10, 0LL, &loc_D75C);
  *(_QWORD *)(*a10 + 136LL) = a11;
  JUMPOUT(&loc_D75C);
}

//----- (000000000000DD20) ----------------------------------------------------
signed __int64 __fastcall FontFileOpenFont(__int64 a1, __int64 a2, unsigned int a3, char *a4, int a5, unsigned int a6, unsigned int a7, __int64 a8, _QWORD *a9, __int128 a10)
{
  __int64 v10; // r14
  unsigned int v11; // ebp
  void *v12; // r13
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // rax
  int v16; // edx
  unsigned int v17; // er15
  __int64 v18; // rdx
  __int64 v19; // r10
  __int64 v20; // rdx
  _QWORD *v21; // rax
  _QWORD *v22; // ST50_8
  __int64 v23; // r10
  int v24; // eax
  __int64 v25; // r11
  const char *v26; // rbp
  size_t v27; // rbx
  __int64 v28; // rdx
  __int64 (__fastcall *v29)(__int64, _QWORD *, _QWORD, __int64, char *, __m128i *, _QWORD, _QWORD, _QWORD); // rax
  unsigned int v30; // eax
  __int64 v31; // r10
  __int64 v32; // rdx
  __int64 v33; // rdx
  __int64 v34; // rax
  __int64 v35; // rcx
  __int64 v36; // rax
  __int64 (__fastcall *v37)(__int64, _QWORD *, _QWORD, __int64, char *, _QWORD, _QWORD, _QWORD); // rax
  __int64 v38; // rdi
  unsigned int v39; // esi
  const char **v41; // [rsp+0h] [rbp-1130h]
  char *v42; // [rsp+8h] [rbp-1128h]
  __int64 v43; // [rsp+10h] [rbp-1120h]
  __int64 v44; // [rsp+28h] [rbp-1108h]
  unsigned int v45; // [rsp+38h] [rbp-10F8h]
  int v46; // [rsp+54h] [rbp-10DCh]
  char *v47; // [rsp+58h] [rbp-10D8h]
  __int16 v48; // [rsp+60h] [rbp-10D0h]
  __int16 v49; // [rsp+62h] [rbp-10CEh]
  __m128i v50[6]; // [rsp+68h] [rbp-10C8h]
  __int64 v51; // [rsp+C8h] [rbp-1068h]
  int v52; // [rsp+D0h] [rbp-1060h]
  void *v53; // [rsp+D8h] [rbp-1058h]
  char dest[1024]; // [rsp+E8h] [rbp-1048h]
  char v55[1024]; // [rsp+4E8h] [rbp-C48h]
  char v56[2056]; // [rsp+8E8h] [rbp-848h]
  unsigned __int64 v57; // [rsp+10F0h] [rbp-40h]

  v38 = a2;
  v39 = a3;
  if ( a5 > 1023 )
    return 80LL;
  v10 = a5;
  v11 = a5;
  v42 = a4;
  v45 = a6;
  v57 = __readfsqword(0x28u);
  v41 = *(const char ***)(v38 + 24);
  sub_CCE0(dest, a4, a5);
  dest[v10] = 0;
  v12 = (void *)FontParseRanges(dest, &v46);
  v47 = dest;
  v48 = v10;
  v49 = FontFileCountDashes(dest, (unsigned int)v10, v13);
  v14 = FontParseXLFDName(dest);
  if ( !v14 )
    memset(v50, 0, 0x78uLL);
  v15 = FontFileFindNameInDir(v41 + 6, &v47);
  if ( v15
    || v49 == 14
    && (unsigned int)FontParseXLFDName(dest)
    && (v48 = strlen(dest), (v15 = FontFileFindNameInDir(v41 + 6, &v47)) != 0) )
  {
    v16 = *(_DWORD *)(v15 + 16);
    if ( v16 == 2 )
    {
      v33 = *(_QWORD *)(v15 + 40);
      JUMPOUT(v33, 0LL, sub_DB58);
      goto LABEL_32;
    }
    if ( v16 == 3 )
    {
      v53 = v12;
      v17 = 82;
      v52 = v46;
      sub_CD50(*(char **)v15, *(signed __int16 *)(v15 + 8), *(const char **)(v15 + 24), (char **)a10, v50);
      goto LABEL_10;
    }
  }
  sub_CCE0(dest, v42, v11);
  dest[v10] = 0;
  v47 = dest;
  v48 = v11;
  v49 = FontFileCountDashes(dest, v11, v18);
  if ( !(unsigned int)FontParseXLFDName(dest)
    || (v48 = strlen(dest), (v19 = FontFileFindNameInScalableDir(v41 + 3, &v47, v50)) == 0) )
  {
    sub_CCE0(dest, v42, v11);
    dest[v10] = 0;
    v47 = dest;
    v48 = v11;
    v49 = FontFileCountDashes(dest, v11, v20);
    v21 = (_QWORD *)FontFileFindNameInScalableDir(v41 + 3, &v47, v50);
    if ( !v21 )
      goto LABEL_30;
    v22 = v21;
    __strcpy_chk(dest, *v21, 1024LL);
    v19 = (__int64)v22;
    v47 = dest;
    v48 = *((_WORD *)v22 + 4);
    v49 = *((_WORD *)v22 + 5);
  }
  if ( *(_DWORD *)(v19 + 16) )
    goto LABEL_30;
  v44 = v19;
  if ( !(unsigned int)FontFileCompleteXLFD(v50, *(_QWORD *)(v19 + 40)) )
    goto LABEL_30;
  v23 = v44;
  if ( (v50[0].m128i_i8[0] & 3) != 2 && (v50[0].m128i_i8[0] & 0xC) != 8 && !(v50[0].m128i_i32[0] & 0xFFFFFFB0) )
  {
    v34 = FontFileFindScaledInstance(v44, v50, 0LL);
    v23 = v44;
    if ( v34 )
    {
      v33 = *(_QWORD *)(v34 + 128);
      if ( !v33 )
      {
        v35 = *(_QWORD *)(v34 + 120);
        if ( v35 )
        {
          v36 = *(_QWORD *)(v35 + 40);
          JUMPOUT(v36, 0LL, sub_DB9A);
          v17 = 85;
          *a9 = v36;
          *(_QWORD *)(v36 + 136) = v38;
          goto LABEL_10;
        }
LABEL_30:
        v17 = 83;
        goto LABEL_10;
      }
LABEL_32:
      v17 = 85;
      *a9 = v33;
      *(_QWORD *)(v33 + 136) = v38;
      goto LABEL_10;
    }
  }
  v43 = v23;
  v17 = FontFileMatchBitmapSource(v38, a9, v39, v23, &v47, v50, v45, a7, 0LL);
  if ( v17 == 85 )
  {
    v17 = 85;
    goto LABEL_10;
  }
  sub_CCE0(v55, v42, v11);
  v24 = v46;
  v51 = v25;
  v55[v10] = 0;
  v53 = v12;
  v52 = v24;
  v26 = *v41;
  v27 = strlen(*v41);
  if ( v27 + strlen(*(const char **)(v43 + 32)) > 0x800 )
    goto LABEL_30;
  __memcpy_chk(v56, v26, v27 + 1, 2049LL);
  __strcpy_chk(&v56[v27], *(_QWORD *)(v43 + 32), 2049LL);
  v28 = *(_QWORD *)(v43 + 24);
  v29 = *(__int64 (__fastcall **)(__int64, _QWORD *, _QWORD, __int64, char *, __m128i *, _QWORD, _QWORD, _QWORD))(v28 + 24);
  if ( v29 )
  {
    v30 = v29(v38, a9, v39, v43, v56, v50, v45, a7, *((_QWORD *)&a10 + 1));
    v31 = v43;
    v17 = v30;
  }
  else
  {
    v37 = *(__int64 (__fastcall **)(__int64, _QWORD *, _QWORD, __int64, char *, _QWORD, _QWORD, _QWORD))(v28 + 16);
    if ( !v37 )
      goto LABEL_10;
    v17 = v37(v38, a9, v39, v43, v56, v45, a7, *((_QWORD *)&a10 + 1));
    v31 = v43;
  }
  if ( v17 == 85 )
  {
    v32 = *a9;
    if ( *(_WORD *)(*a9 + 8LL) <= *(_WORD *)(*a9 + 10LL) && *(_WORD *)(v32 + 12) <= *(_WORD *)(v32 + 14) )
    {
      if ( !(unsigned int)FontFileAddScaledInstance(v31, v50, v32, 0LL) )
      {
        *(_QWORD *)(*a9 + 160LL) = 0LL;
        JUMPOUT(&loc_DC01);
      }
      *(_QWORD *)(*a9 + 136LL) = v38;
      return v17;
    }
    v17 = 83;
    (*(void (__fastcall **)(_QWORD))(v32 + 120))(*a9);
  }
LABEL_10:
  if ( v12 )
    free(v12);
  return v17;
}
// 8420: using guessed type __int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD);
// 86B0: using guessed type __int64 __fastcall FontFileMatchBitmapSource(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8880: using guessed type __int64 __fastcall FontFileFindScaledInstance(_QWORD, _QWORD, _QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8A30: using guessed type __int64 __fastcall FontFileFindNameInScalableDir(_QWORD, _QWORD, _QWORD);
// 8B60: using guessed type __int64 __fastcall FontFileAddScaledInstance(_QWORD, _QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 8E80: using guessed type __int64 __fastcall FontParseRanges(_QWORD, _QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);
// DD20: using guessed type char dest[1024];
// DD20: using guessed type char var_C48[1024];
// DD20: using guessed type char var_848[2056];

//----- (000000000000DD70) ----------------------------------------------------
__int64 __fastcall sub_DD70(__int64 *a1, char *a2, int a3, unsigned int a4, struct _FontNames *a5, int a6)
{
  __int64 v6; // r12
  struct _FontNames *v7; // rbx
  unsigned int v8; // er11
  __int64 v9; // rdx
  unsigned int v10; // er10
  void *v12; // r15
  unsigned int v13; // er10
  char *v14; // rdx
  int v15; // ecx
  unsigned int v16; // eax
  FontNamesPtr v17; // rax
  signed __int64 v18; // rdi
  struct _FontNames *v19; // r12
  FontNamesPtr v20; // rax
  struct _FontNames *v21; // r12
  signed __int64 v22; // [rsp+8h] [rbp-918h]
  int v23; // [rsp+20h] [rbp-900h]
  unsigned int v24; // [rsp+28h] [rbp-8F8h]
  unsigned int v25; // [rsp+2Ch] [rbp-8F4h]
  int v26; // [rsp+3Ch] [rbp-8E4h]
  char *v27; // [rsp+40h] [rbp-8E0h]
  __int16 v28; // [rsp+48h] [rbp-8D8h]
  __int16 v29; // [rsp+4Ah] [rbp-8D6h]
  char *v30; // [rsp+50h] [rbp-8D0h]
  __int16 v31; // [rsp+58h] [rbp-8C8h]
  __int16 v32; // [rsp+5Ah] [rbp-8C6h]
  char v33; // [rsp+60h] [rbp-8C0h]
  char v34[1024]; // [rsp+E0h] [rbp-840h]
  char dest; // [rsp+4E0h] [rbp-440h]
  unsigned __int64 v36; // [rsp+8E8h] [rbp-38h]

  v25 = a4;
  v23 = a6;
  v36 = __readfsqword(0x28u);
  if ( a3 > 1023 )
    return 80;
  v6 = *a1;
  v7 = a5;
  sub_CCE0(v34, a2, a3);
  v28 = v8;
  v34[v8] = 0;
  v27 = v34;
  v29 = FontFileCountDashes(v34, v8, v9);
  __strcpy_chk(&dest, v34, 1024LL);
  if ( v29 == 14 && (unsigned int)FontParseXLFDName(&dest) )
  {
    v12 = (void *)FontParseRanges(v34, &v26);
    v22 = v6 + 48;
    v13 = FontFileFindNamesInScalableDir(v6 + 48, &v27, v25, v7, 0LL, (unsigned int)(v23 != 0) + 2, &v25);
    v30 = &dest;
    v14 = &dest;
    do
    {
      v15 = *(_DWORD *)v14;
      v14 += 4;
      v16 = ~v15 & (v15 - 16843009) & 0x80808080;
    }
    while ( !v16 );
    v24 = v13;
    if ( !((unsigned __int16)~(_WORD)v15 & (unsigned __int16)(v15 - 257) & 0x8080) )
      LOBYTE(v16) = (~v15 & (v15 - 16843009) & 0x80808080) >> 16;
    if ( !((unsigned __int16)~(_WORD)v15 & (unsigned __int16)(v15 - 257) & 0x8080) )
      v14 += 2;
    v31 = &v14[-__CFADD__((_BYTE)v16, (_BYTE)v16) - 3] - &dest;
    v32 = v29;
    v17 = MakeFontNamesRecord(0);
    if ( v17 )
    {
      v18 = v6 + 24;
      v19 = v17;
      FontFileFindNamesInScalableDir(v18, &v30, v25, v17, &v33, v23 != 0, 0LL);
      sub_D0B0(v7, &v19->nnames, (__int64)&v27, &dest, (const __m128i *)&v33, (__int64)v12, v26, &v25);
      FreeFontNames(v19);
      v20 = MakeFontNamesRecord(0);
      if ( v20 )
      {
        v21 = v20;
        FontFileFindNamesInScalableDir(v22, &v30, v25, v20, &v33, v23 != 0, 0LL);
        sub_D0B0(v7, &v21->nnames, (__int64)&v27, &dest, (const __m128i *)&v33, (__int64)v12, v26, &v25);
        FreeFontNames(v21);
        v10 = v24;
        if ( v12 )
        {
          free(v12);
          v10 = v24;
        }
        return v10;
      }
    }
    if ( v12 )
      free(v12);
    return 80;
  }
  v10 = FontFileFindNamesInScalableDir(v6 + 48, &v27, v25, v7, 0LL, v23 != 0, &v25);
  if ( v10 == 85 )
    v10 = FontFileFindNamesInScalableDir(v6 + 24, &v27, v25, v7, 0LL, v23 != 0, 0LL);
  return v10;
}
// 8690: using guessed type __int64 __fastcall FontFileFindNamesInScalableDir(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 8E80: using guessed type __int64 __fastcall FontParseRanges(_QWORD, _QWORD);
// DD70: using guessed type char var_840[1024];

//----- (000000000000E110) ----------------------------------------------------
__int64 __fastcall FontFileListFonts(__int64 a1, __int64 a2, char *a3, int a4, unsigned int a5, struct _FontNames *a6)
{
  return sub_DD70((__int64 *)(a2 + 24), a3, a4, a5, a6, 0);
}

//----- (000000000000E130) ----------------------------------------------------
__int64 __fastcall sub_E130(__int64 a1, char **a2, unsigned int *a3, __int64 *a4)
{
  unsigned int v4; // ebx
  unsigned int v5; // ecx
  unsigned int *v6; // r12
  __int64 v7; // rdx
  __int64 v8; // rax
  int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // ST08_4
  __int64 v13; // rdx
  __int64 v14; // rdx
  _QWORD *v15; // rax
  __int64 v16; // r14
  __int16 v17; // ax
  int v18; // eax
  unsigned int v19; // ST08_4
  __int64 v20; // rdx
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 v25; // r11
  size_t v26; // r12
  unsigned int v27; // ST08_4
  __int64 v28; // rdx
  __int64 (__fastcall *v29)(__int64, __int64, __int64, char **, __int64, char *); // rax
  __int64 (__fastcall *v30)(__int64, __int64, __int64, __int64); // rax
  const char **v31; // [rsp+8h] [rbp-1120h]
  const char *v32; // [rsp+8h] [rbp-1120h]
  __int64 v33; // [rsp+8h] [rbp-1120h]
  void *ptr; // [rsp+10h] [rbp-1118h]
  __int64 *v35; // [rsp+18h] [rbp-1110h]
  char *v36; // [rsp+20h] [rbp-1108h]
  int v37; // [rsp+4Ch] [rbp-10DCh]
  char *v38; // [rsp+50h] [rbp-10D8h]
  __int16 v39; // [rsp+58h] [rbp-10D0h]
  __int16 v40; // [rsp+5Ah] [rbp-10CEh]
  __m128i v41[6]; // [rsp+60h] [rbp-10C8h]
  __int64 v42; // [rsp+C0h] [rbp-1068h]
  int v43; // [rsp+C8h] [rbp-1060h]
  void *v44; // [rsp+D0h] [rbp-1058h]
  char dest[1024]; // [rsp+E0h] [rbp-1048h]
  char v46[1024]; // [rsp+4E0h] [rbp-C48h]
  char v47; // [rsp+8E0h] [rbp-848h]
  unsigned __int64 v48; // [rsp+10E8h] [rbp-40h]

  v4 = *a3;
  v48 = __readfsqword(0x28u);
  v35 = a4;
  v5 = 80;
  if ( (signed int)v4 > 1023 )
    return v5;
  v6 = a3;
  v31 = *(const char ***)(a1 + 24);
  v36 = *a2;
  sub_CCE0(dest, *a2, v4);
  dest[v4] = 0;
  ptr = (void *)FontParseRanges(dest, &v37);
  v38 = dest;
  v39 = v4;
  v40 = FontFileCountDashes(dest, v4, v7);
  if ( !(unsigned int)FontParseXLFDName(dest) )
    memset(v41, 0, 0x78uLL);
  v8 = FontFileFindNameInDir(v31 + 6, &v38);
  if ( !v8 )
  {
    if ( v40 != 14 )
      goto LABEL_12;
    if ( !(unsigned int)FontParseXLFDName(dest) )
      goto LABEL_12;
    v39 = strlen(dest);
    v8 = FontFileFindNameInDir(v31 + 6, &v38);
    if ( !v8 )
      goto LABEL_12;
  }
  v9 = *(_DWORD *)(v8 + 16);
  if ( v9 != 2 )
  {
    if ( v9 == 3 )
    {
      v43 = v37;
      v44 = ptr;
      sub_CD50(*(char **)v8, *(signed __int16 *)(v8 + 8), *(const char **)(v8 + 24), a2, v41);
      v10 = strlen(*a2);
      v5 = 82;
      *v6 = v10;
      goto LABEL_8;
    }
LABEL_12:
    sub_CCE0(dest, v36, v4);
    v38 = dest;
    v39 = v4;
    dest[v4] = 0;
    v40 = FontFileCountDashes(dest, v4, v13);
    if ( !(unsigned int)FontParseXLFDName(dest)
      || (v39 = strlen(dest), (v16 = FontFileFindNameInScalableDir(v31 + 3, &v38, v41)) == 0) )
    {
      sub_CCE0(dest, v36, v4);
      v38 = dest;
      v39 = v4;
      dest[v4] = 0;
      v40 = FontFileCountDashes(dest, v4, v14);
      v15 = (_QWORD *)FontFileFindNameInScalableDir(v31 + 3, &v38, v41);
      v16 = (__int64)v15;
      v5 = 83;
      if ( !v15 )
        goto LABEL_8;
      __strcpy_chk(dest, *v15, 1024LL);
      v17 = *(_WORD *)(v16 + 8);
      v38 = dest;
      v39 = v17;
      v40 = *(_WORD *)(v16 + 10);
    }
    v5 = 83;
    if ( *(_DWORD *)(v16 + 16) )
      goto LABEL_17;
    v18 = FontFileCompleteXLFD(v41, *(_QWORD *)(v16 + 40));
    v5 = 83;
    if ( !v18 )
      goto LABEL_17;
    v21 = FontFileFindScaledInstance(v16, v41, 0LL);
    if ( v21 )
    {
      v22 = *(_QWORD *)(v21 + 128);
      v5 = 83;
      if ( v22 )
      {
        v5 = 85;
        *v35 = v22 + 8;
        return v5;
      }
      v23 = *(_QWORD *)(v21 + 120);
      if ( !v23 )
        goto LABEL_17;
      v24 = *(_QWORD *)(v23 + 40);
      if ( v24 )
      {
        v5 = 85;
        *v35 = v24 + 8;
        return v5;
      }
      v5 = sub_CAB0(a1, *v35, v23);
LABEL_38:
      if ( v5 == 85 )
        return v5;
LABEL_17:
      v19 = v5;
      sub_CCE0(dest, v36, v4);
      v5 = v19;
      goto LABEL_8;
    }
    sub_CCE0(v46, v36, v4);
    v42 = v25;
    v46[v4] = 0;
    v44 = ptr;
    v43 = v37;
    v32 = *v31;
    v26 = strlen(v32);
    if ( v26 + strlen(*(const char **)(v16 + 32)) <= 0x800 )
    {
      v33 = __memcpy_chk(&v47, v32, v26 + 1, 2049LL);
      __strcpy_chk(v33 + v26, *(_QWORD *)(v16 + 32), 2049LL);
      v28 = *(_QWORD *)(v16 + 24);
      v29 = *(__int64 (__fastcall **)(__int64, __int64, __int64, char **, __int64, char *))(v28 + 40);
      if ( v29 )
      {
        v5 = v29(a1, *v35, v16, &v38, v33, (char *)v41);
        goto LABEL_35;
      }
      v30 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(v28 + 32);
      if ( v30 )
      {
        v5 = v30(a1, *v35, v16, v33);
        goto LABEL_35;
      }
    }
    v5 = 83;
LABEL_35:
    if ( ptr )
    {
      v27 = v5;
      free(ptr);
      v5 = v27;
    }
    ptr = 0LL;
    goto LABEL_38;
  }
  v20 = *(_QWORD *)(v8 + 40);
  if ( v20 )
  {
    v5 = 85;
    *v35 = v20 + 8;
  }
  else
  {
    v5 = sub_CAB0(a1, *v35, v8);
    if ( v5 == 83 )
      goto LABEL_12;
  }
LABEL_8:
  if ( ptr )
  {
    v11 = v5;
    free(ptr);
    v5 = v11;
  }
  return v5;
}
// 8420: using guessed type __int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD);
// 8880: using guessed type __int64 __fastcall FontFileFindScaledInstance(_QWORD, _QWORD, _QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8A30: using guessed type __int64 __fastcall FontFileFindNameInScalableDir(_QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 8E80: using guessed type __int64 __fastcall FontParseRanges(_QWORD, _QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);
// E130: using guessed type char dest[1024];
// E130: using guessed type char var_C48[1024];

//----- (000000000000E6E0) ----------------------------------------------------
__int64 __fastcall FontFileListNextFontWithInfo(void *ptr, __int64 a2, char **a3, _DWORD *a4, __int64 *a5, _DWORD *a6, FontNamesPtr *ptra)
{
  char **v7; // r13
  FontNamesPtr v8; // rdx
  __int64 v9; // rax
  _DWORD *v10; // r12
  char **v11; // rcx
  int *v12; // rdx
  _DWORD *v13; // rbp
  __int64 result; // rax
  FontNamesPtr v15; // rcx
  int v16; // edx
  int v17; // [rsp+Ch] [rbp-3Ch]
  char *v18; // [rsp+10h] [rbp-38h]
  unsigned __int64 v19; // [rsp+18h] [rbp-30h]

  v7 = a3;
  v19 = __readfsqword(0x28u);
  v8 = *ptra;
  v9 = *((signed int *)ptra + 2);
  if ( (_DWORD)v9 == (*ptra)->nnames )
  {
    FreeFontNames(*ptra);
    free(ptra);
    result = 83LL;
  }
  else
  {
    v10 = a4;
    v11 = v8->names;
    v12 = v8->length;
    v13 = a6;
    v18 = v11[v9];
    v17 = v12[v9];
    result = sub_E130(a2, &v18, (unsigned int *)&v17, a5);
    if ( (_DWORD)result == 83 )
      result = 80LL;
    *v7 = v18;
    *v10 = v17;
    v15 = *ptra;
    v16 = *((_DWORD *)ptra + 2) + 1;
    *((_DWORD *)ptra + 2) = v16;
    *v13 = v15->nnames - v16;
  }
  return result;
}

//----- (000000000000E7B0) ----------------------------------------------------
__int64 __fastcall FontFileOpenBitmap(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  return sub_C960(a1, a2, a3, a4, a5, a6, 0LL);
}

//----- (000000000000E7C0) ----------------------------------------------------
__int64 __fastcall FontFileStartListFonts(__int64 a1, __int64 a2, char *a3, int a4, unsigned int a5, _QWORD *a6, int a7)
{
  int v7; // er13
  char *v8; // r12
  unsigned int v9; // er14
  unsigned int v10; // er15
  _DWORD *v11; // rax
  _DWORD *v12; // rbx
  struct _FontNames *v13; // r8
  _QWORD *v15; // [rsp+8h] [rbp-40h]

  v7 = a4;
  v8 = a3;
  v9 = a5;
  v10 = 80;
  v15 = a6;
  v11 = malloc(0x10uLL);
  if ( v11 )
  {
    v12 = v11;
    v13 = MakeFontNamesRecord(0);
    *(_QWORD *)v12 = v13;
    if ( v13 )
    {
      v10 = sub_DD70((__int64 *)(a2 + 24), v8, v7, v9, v13, a7);
      if ( v10 == 85 )
      {
        v12[2] = 0;
        *v15 = v12;
        return v10;
      }
      FreeFontNames(*(FontNamesPtr *)v12);
    }
    free(v12);
  }
  return v10;
}

//----- (000000000000E870) ----------------------------------------------------
__int64 __fastcall FontFileStartListFontsWithInfo(__int64 a1)
{
  return FontFileStartListFonts(a1);
}
// 8270: using guessed type __int64 __cdecl FontFileStartListFonts(_QWORD);

//----- (000000000000E880) ----------------------------------------------------
__int64 __fastcall FontFileStartListFontsAndAliases(__int64 a1)
{
  return FontFileStartListFonts(a1);
}
// 8270: using guessed type __int64 __cdecl FontFileStartListFonts(_QWORD);

//----- (000000000000E890) ----------------------------------------------------
int FontFileRegisterLocalFpeFunctions()
{
  return RegisterFPEFunctions(
           (NameCheckFunc)FontFileNameCheck,
           (InitFpeFunc)FontFileInitFPE,
           (FreeFpeFunc)FontFileFreeFPE,
           (ResetFpeFunc)FontFileResetFPE,
           (OpenFontFunc)FontFileOpenFont,
           (CloseFontFunc)FontFileCloseFont,
           (ListFontsFunc)FontFileListFonts,
           (StartLfwiFunc)FontFileStartListFontsWithInfo,
           (NextLfwiFunc)FontFileListNextFontWithInfo,
           0LL,
           0LL,
           0LL,
           (StartLaFunc)FontFileStartListFontsAndAliases,
           (NextLaFunc)FontFileListNextFontOrAlias,
           (SetPathFunc)FontFileEmptyBitmapSource);
}

//----- (000000000000E900) ----------------------------------------------------
signed __int64 __fastcall FontFileAddScaledInstance(__int64 a1, const __m128i *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r13
  const __m128i *v5; // rbx
  __int64 v6; // r12
  __int64 v7; // rsi
  char *v8; // rdi
  __m128i *v9; // rax
  __int64 v10; // rsi
  signed __int64 result; // rax
  __int64 v12; // [rsp+0h] [rbp-38h]
  __int64 v13; // [rsp+8h] [rbp-30h]

  v4 = a1;
  v5 = a2;
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(signed int *)(v6 + 120);
  v8 = *(char **)(v6 + 128);
  if ( (_DWORD)v7 == *(_DWORD *)(v6 + 124) )
  {
    v13 = a4;
    v12 = a3;
    v8 = (char *)realloc(v8, 136LL * ((signed int)v7 + 4));
    result = 0LL;
    if ( !v8 )
      return result;
    *(_DWORD *)(v6 + 124) = v7 + 4;
    *(_QWORD *)(v6 + 128) = v8;
    v7 = *(signed int *)(v6 + 120);
    a4 = v13;
    a3 = v12;
  }
  *(_DWORD *)(v6 + 120) = v7 + 1;
  v9 = (__m128i *)&v8[136 * v7];
  *v9 = _mm_loadu_si128(v5);
  v9[1] = _mm_loadu_si128(v5 + 1);
  v9[2] = _mm_loadu_si128(v5 + 2);
  v9[3] = _mm_loadu_si128(v5 + 3);
  v9[4] = _mm_loadu_si128(v5 + 4);
  v9[5] = _mm_loadu_si128(v5 + 5);
  v9[6] = _mm_loadu_si128(v5 + 6);
  v10 = v5[7].m128i_i64[0];
  v9[8].m128i_i64[0] = a3;
  v9[7].m128i_i64[0] = v10;
  v9[7].m128i_i64[1] = a4;
  result = 1LL;
  if ( a3 )
    *(_QWORD *)(a3 + 160) = v4;
  return result;
}

//----- (000000000000EA00) ----------------------------------------------------
_QWORD *__fastcall FontFileSwitchStringsToBitmapPointers(__int64 a1)
{
  _QWORD *result; // rax
  _QWORD *v2; // r9
  signed __int64 v3; // r10
  int v4; // er11
  __int64 v5; // r8
  _QWORD *v6; // rcx
  int v7; // esi
  int v8; // edx

  result = (_QWORD *)*(unsigned int *)(a1 + 24);
  v2 = *(_QWORD **)(a1 + 56);
  if ( (signed int)result > 0 )
  {
    v3 = *(_QWORD *)(a1 + 32) + 40LL;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)v3;
      result = (_QWORD *)*(unsigned int *)(*(_QWORD *)v3 + 120LL);
      if ( (signed int)result > 0 )
      {
        v6 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v3 + 128LL) + 120LL);
        v7 = 0;
        do
        {
          v8 = 0;
          for ( result = v2; *(_DWORD *)(a1 + 48) > v8; result += 19 )
          {
            while ( *result != *v6 )
            {
              ++v8;
              result += 19;
              if ( *(_DWORD *)(a1 + 48) <= v8 )
                goto LABEL_10;
            }
            *v6 = result;
            ++v8;
          }
LABEL_10:
          ++v7;
          v6 += 17;
        }
        while ( *(_DWORD *)(v5 + 120) > v7 );
      }
      ++v4;
      v3 += 152LL;
    }
    while ( *(_DWORD *)(a1 + 24) > v4 );
  }
  return result;
}

//----- (000000000000EAA0) ----------------------------------------------------
signed __int64 __fastcall FontFileRemoveScaledInstance(__int64 a1, __int64 a2)
{
  __int64 v2; // r12
  signed __int64 result; // rax
  int v4; // ebp
  int v5; // edx
  signed __int64 v6; // rbx
  void *v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __m128i v10; // xmm0
  int v11; // edx

  v2 = *(_QWORD *)(a1 + 40);
  result = *(unsigned int *)(v2 + 120);
  if ( (signed int)result > 0 )
  {
    v4 = 0;
    do
    {
      while ( 1 )
      {
        v6 = 136LL * v4;
        result = v6 + *(_QWORD *)(v2 + 128);
        if ( *(_QWORD *)(result + 128) == a2 )
          break;
        v5 = *(_DWORD *)(v2 + 120);
LABEL_4:
        if ( ++v4 >= v5 )
          return result;
      }
      v7 = *(void **)(result + 112);
      if ( v7 )
        free(v7);
      result = *(unsigned int *)(v2 + 120);
      v5 = result - 1;
      *(_DWORD *)(v2 + 120) = result - 1;
      if ( (signed int)result - 1 <= v4 )
        goto LABEL_4;
      result = v6 + 136;
      do
      {
        v8 = *(_QWORD *)(v2 + 128);
        ++v4;
        v9 = *(_QWORD *)(v8 + result + 128);
        *(__m128i *)(v8 + result - 136) = _mm_loadu_si128((const __m128i *)(v8 + result));
        v10 = _mm_loadu_si128((const __m128i *)(v8 + result + 16));
        *(_QWORD *)(v8 + result - 8) = v9;
        *(__m128i *)(v8 + result - 120) = v10;
        *(__m128i *)(v8 + result - 104) = _mm_loadu_si128((const __m128i *)(v8 + result + 32));
        *(__m128i *)(v8 + result - 88) = _mm_loadu_si128((const __m128i *)(v8 + result + 48));
        *(__m128i *)(v8 + result - 72) = _mm_loadu_si128((const __m128i *)(v8 + result + 64));
        *(__m128i *)(v8 + result - 56) = _mm_loadu_si128((const __m128i *)(v8 + result + 80));
        *(__m128i *)(v8 + result - 40) = _mm_loadu_si128((const __m128i *)(v8 + result + 96));
        *(__m128i *)(v8 + result - 24) = _mm_loadu_si128((const __m128i *)(v8 + result + 112));
        v11 = *(_DWORD *)(v2 + 120);
        result += 136LL;
      }
      while ( v11 > v4 );
      ++v4;
    }
    while ( v4 < v11 );
  }
  return result;
}

//----- (000000000000EBD0) ----------------------------------------------------
signed __int64 __fastcall FontFileCompleteXLFD(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // rbx
  FontResolutionPtr v3; // rax
  unsigned int v4; // edi
  unsigned int v5; // ecx
  signed int v6; // edx
  signed int v7; // er8
  signed int v8; // edi
  double v9; // xmm6_8
  double v10; // xmm1_8
  double v11; // xmm2_8
  double v12; // xmm0_8
  double v13; // xmm1_8
  double v14; // xmm2_8
  double v15; // xmm0_8
  double v16; // xmm4_8
  double v17; // xmm5_8
  double i; // xmm3_8
  double v19; // xmm0_8
  double v20; // xmm3_8
  double v22; // xmm4_8
  double v23; // xmm5_8
  double v24; // xmm3_8
  double v25; // xmm7_8
  char v26; // al
  double v27; // xmm4_8
  double v28; // xmm5_8
  double v29; // xmm4_8
  double v30; // xmm5_8
  double v31; // xmm4_8
  double v32; // xmm5_8
  double v33; // xmm4_8
  double v34; // xmm5_8
  double v35; // xmm4_8
  double v36; // xmm5_8
  double v37; // xmm4_8
  double v38; // xmm5_8
  double v39; // xmm4_8
  double v40; // xmm5_8
  double v41; // xmm0_8
  signed int v42; // eax
  double v43; // xmm0_8
  struct _FontResolution *v44; // ST00_8
  double v45; // xmm0_8
  double v46; // xmm0_8
  double v47; // [rsp+0h] [rbp-38h]
  double v48; // [rsp+8h] [rbp-30h]
  struct _FontResolution *v49; // [rsp+8h] [rbp-30h]
  int v50; // [rsp+14h] [rbp-24h]
  unsigned __int64 v51; // [rsp+18h] [rbp-20h]

  v2 = a1;
  v51 = __readfsqword(0x28u);
  v3 = GetClientResolutions(&v50);
  v4 = *a1;
  v5 = *v2;
  if ( !(*v2 & 3) || !(v4 & 0xC) )
  {
    v6 = v2[20];
    v7 = v2[21];
    if ( v50 )
    {
      v8 = v2[21];
      if ( v6 > 0 )
      {
        if ( v7 > 0 )
          goto LABEL_6;
        goto LABEL_20;
      }
      v6 = v3->x_resolution;
      v2[20] = v6;
      if ( v7 <= 0 )
      {
LABEL_20:
        v7 = v3->y_resolution;
        v2[21] = v7;
        goto LABEL_21;
      }
    }
LABEL_21:
    if ( v6 <= 0 )
    {
      v6 = *(_DWORD *)(a2 + 80);
      v8 = v7;
      v2[20] = v6;
      if ( v7 > 0 )
      {
        if ( v6 <= 0 )
          return 0LL;
        goto LABEL_6;
      }
    }
    else
    {
      v8 = v7;
      if ( v7 > 0 )
        goto LABEL_6;
    }
    v2[21] = *(_DWORD *)(a2 + 84);
    goto LABEL_24;
  }
  if ( (signed int)v2[21] > 0 )
  {
    v6 = v2[20];
    if ( v6 > 0 )
    {
      v8 = v2[21];
      v5 = *v2;
      goto LABEL_6;
    }
    goto LABEL_41;
  }
  v44 = v3;
  v48 = hypot(*((double *)v2 + 2), *((double *)v2 + 4));
  v45 = hypot(*((double *)v2 + 6), *((double *)v2 + 8));
  v3 = v44;
  if ( v45 < 9.999999999999999e-21 )
    return 0LL;
  v2[21] = (signed int)(v48 * 72.27 / v45 + 0.5);
  v6 = v2[20];
  if ( v6 <= 0 )
  {
    v4 = *v2;
LABEL_41:
    if ( (v4 & 3) - 2 <= 1 )
    {
      v49 = v3;
      v47 = hypot(*((double *)v2 + 1), *((double *)v2 + 3));
      v46 = hypot(*((double *)v2 + 5), *((double *)v2 + 7));
      if ( v46 < 9.999999999999999e-21 )
        return 0LL;
      v3 = v49;
      v6 = (signed int)(v47 * 72.27 / v46 + 0.5);
      v2[20] = v6;
    }
    else
    {
      v6 = v2[21];
      v2[20] = v6;
    }
LABEL_24:
    if ( v6 <= 0 )
      return 0LL;
  }
  v8 = v2[21];
  if ( v8 <= 0 )
    return 0LL;
  v5 = *v2;
LABEL_6:
  if ( !(v5 & 0xF) )
  {
    if ( v50 )
    {
      v42 = v3->point_size;
      *((_QWORD *)v2 + 7) = 0LL;
      *((_QWORD *)v2 + 6) = 0LL;
      v5 = v5 & 0xFFFFFFF3 | 4;
      *v2 = v5;
      v43 = (double)v42 / 10.0;
      *((double *)v2 + 8) = v43;
      *((double *)v2 + 5) = v43;
    }
    else
    {
      if ( !(*(_BYTE *)a2 & 0xC) )
        return 0LL;
      *((_QWORD *)v2 + 5) = *(_QWORD *)(a2 + 40);
      *((_QWORD *)v2 + 6) = *(_QWORD *)(a2 + 48);
      *((_QWORD *)v2 + 7) = *(_QWORD *)(a2 + 56);
      *((_QWORD *)v2 + 8) = *(_QWORD *)(a2 + 64);
      v5 = *(_DWORD *)a2 & 0xC | v5 & 0xFFFFFFF3;
      *v2 = v5;
    }
  }
  v9 = 1.0;
  v10 = (double)v6;
  v11 = (double)v8;
  if ( (v5 & 3) == 1 )
  {
    v12 = *((double *)v2 + 1);
    v5 |= 3u;
    v9 = v10 / v11;
    *v2 = v5;
    *((double *)v2 + 1) = v12 * (v10 / v11);
  }
  v13 = v10 / 72.27;
  v14 = v11 / 72.27;
  if ( !(v5 & 0xC) )
    goto LABEL_33;
  v15 = *((double *)v2 + 5);
  v16 = *((double *)v2 + 6);
  v17 = *((double *)v2 + 7);
  for ( i = *((double *)v2 + 8); ; *((double *)v2 + 8) = i )
  {
    v19 = v15 * v13;
    v16 = v16 * v14;
    v17 = v17 * v13;
    v20 = i * v14;
    if ( v5 & 3 )
    {
      if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*((double *)v2 + 1) - v19) & xmmword_30160) > v9
        || COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*((double *)v2 + 2) - v16) & xmmword_30160) > 1.0
        || COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*((double *)v2 + 3) - v17) & xmmword_30160) > 1.0
        || COERCE_DOUBLE(xmmword_30160 & COERCE_UNSIGNED_INT64(*((double *)v2 + 4) - v20)) > 1.0 )
      {
        break;
      }
    }
    if ( (v5 & 0xF) != 6 )
    {
      *((double *)v2 + 1) = v19;
      *((double *)v2 + 2) = v16;
      *((double *)v2 + 3) = v17;
      *((double *)v2 + 4) = v20;
      *v2 = (((v5 & 0xC) != 8) + 2) | v5 & 0xFFFFFFFC;
LABEL_36:
      *((double *)v2 + 1) = xlfd_round_double(v19, v13, v14, v20, v16, v17, v9);
      *((double *)v2 + 2) = xlfd_round_double(*((double *)v2 + 2), v13, v14, v20, v27, v28, v9);
      *((double *)v2 + 3) = xlfd_round_double(*((double *)v2 + 3), v13, v14, v20, v29, v30, v9);
      *((double *)v2 + 4) = xlfd_round_double(*((double *)v2 + 4), v13, v14, v20, v31, v32, v9);
      *((double *)v2 + 5) = xlfd_round_double(*((double *)v2 + 5), v13, v14, v20, v33, v34, v9);
      *((double *)v2 + 6) = xlfd_round_double(*((double *)v2 + 6), v13, v14, v20, v35, v36, v9);
      *((double *)v2 + 7) = xlfd_round_double(*((double *)v2 + 7), v13, v14, v20, v37, v38, v9);
      v41 = xlfd_round_double(*((double *)v2 + 8), v13, v14, v20, v39, v40, v9);
      *((double *)v2 + 8) = v41;
      v2[19] = (signed int)(v41 * 10.0);
      v2[18] = (signed int)*((double *)v2 + 4);
      return 1LL;
    }
LABEL_33:
    if ( COERCE_DOUBLE(*(_QWORD *)&v13 & xmmword_30160) < 9.999999999999999e-21
      || COERCE_DOUBLE(xmmword_30160 & *(_QWORD *)&v14) < 9.999999999999999e-21 )
    {
      return 0LL;
    }
    v19 = *((double *)v2 + 1);
    v22 = *((double *)v2 + 2);
    v23 = *((double *)v2 + 3);
    v24 = *((double *)v2 + 4);
    v25 = *((double *)v2 + 1) / v13;
    v5 = (4 * ((*v2 & 3) == 2) + 4) | *v2 & 0xFFFFFFF3;
    v26 = (4 * ((*v2 & 3) == 2) + 4) | *(_BYTE *)v2 & 0xF3;
    *v2 = v5;
    v16 = v22 / v14;
    *((double *)v2 + 5) = v25;
    v17 = v23 / v13;
    *((double *)v2 + 6) = v16;
    v20 = v24 / v14;
    *((double *)v2 + 7) = v17;
    *((double *)v2 + 8) = v20;
    if ( (v26 & 0xC) != 4 )
      goto LABEL_36;
    v15 = (double)(signed int)(v25 * 10.0 + 0.5) / 10.0;
    i = (double)(signed int)(v20 * 10.0 + 0.5) / 10.0;
    *((double *)v2 + 5) = v15;
  }
  return 0LL;
}
// 86C0: using guessed type double __fastcall xlfd_round_double(double, double, double, double, double, double, double);
// 30160: using guessed type __int128 xmmword_30160;

//----- (000000000000F150) ----------------------------------------------------
__int64 __fastcall FontFileFindScaledInstance(__int64 a1, double *a2, int a3)
{
  __int64 v3; // rcx
  signed int v4; // edi
  __int64 v5; // rdx
  signed __int64 v6; // r8
  __int64 v7; // rcx
  __int64 result; // rax
  int v9; // ecx
  int v10; // ecx
  int v11; // er9
  _BYTE *v12; // rcx
  _BYTE *v13; // rdi
  _BYTE *v14; // rcx
  _BYTE *v15; // rdi
  signed __int64 v16; // r11
  char v17; // bl
  _BYTE *v18; // r9
  __int64 v19; // rcx
  double v20; // xmm4_8
  double v21; // xmm5_8
  double v22; // xmm6_8
  double v23; // xmm7_8
  double v24; // xmm3_8
  signed __int64 v25; // rcx
  signed int v26; // er8
  signed int v27; // esi
  __int64 v28; // rdx
  signed int v29; // edx
  double v30; // xmm0_8
  __int64 v31; // rdx

  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_DWORD *)(v3 + 120);
  if ( a3 )
  {
    result = 0LL;
    if ( v4 )
    {
      result = *(_QWORD *)(v3 + 128);
      v20 = a2[5];
      v21 = a2[6];
      v22 = a2[7];
      v23 = a2[8];
      v24 = (*(double *)(result + 56) - v22) * (*(double *)(result + 56) - v22)
          + (*(double *)(result + 40) - v20) * (*(double *)(result + 40) - v20)
          + (*(double *)(result + 48) - v21) * (*(double *)(result + 48) - v21)
          + (*(double *)(result + 64) - v23) * (*(double *)(result + 64) - v23);
      if ( v4 > 1 )
      {
        v25 = result + 176;
        v26 = 0;
        v27 = 1;
        do
        {
          v28 = *(_QWORD *)(v25 + 88);
          if ( !v28 || *(_BYTE *)(v28 + 19) & 2 )
          {
            v29 = (signed int)((*(double *)(v25 + 16) - v22) * (*(double *)(v25 + 16) - v22)
                             + (*(double *)v25 - v20) * (*(double *)v25 - v20)
                             + (*(double *)(v25 + 8) - v21) * (*(double *)(v25 + 8) - v21)
                             + (*(double *)(v25 + 24) - v23) * (*(double *)(v25 + 24) - v23));
            v30 = fmin((double)v29, v24);
            if ( v24 > (double)v29 )
              v26 = v27;
            v24 = v30;
          }
          ++v27;
          v25 += 136LL;
        }
        while ( v27 != v4 );
        result += 136LL * v26;
      }
      v31 = *(_QWORD *)(result + 128);
      if ( v31 && !(*(_BYTE *)(v31 + 19) & 2) )
        result = 0LL;
    }
  }
  else
  {
    if ( v4 <= 0 )
      return 0LL;
    v5 = *(_QWORD *)(v3 + 128);
    v6 = v5 + 136LL * (unsigned int)(v4 - 1) + 136;
    while ( 1 )
    {
      v7 = *(_QWORD *)(v5 + 128);
      result = v5;
      if ( (!v7 || *(_BYTE *)(v7 + 19) & 2) && *(_QWORD *)(v5 + 80) == *((_QWORD *)a2 + 10) )
        break;
      v5 += 136LL;
      if ( v5 == v6 )
        return 0LL;
    }
LABEL_8:
    v9 = *((_DWORD *)a2 + 22);
    if ( *(_DWORD *)(v5 + 88) == v9 || *(_DWORD *)(v5 + 88) == 0 || (unsigned int)(v9 + 1) <= 1 )
    {
      v10 = *(_DWORD *)a2;
      if ( (!(*(_DWORD *)a2 & 3)
         || !(((unsigned __int8)v10 ^ (unsigned __int8)*(_DWORD *)v5) & 3)
         && *(double *)(v5 + 8) == a2[1]
         && *(double *)(v5 + 16) == a2[2]
         && *(double *)(v5 + 24) == a2[3]
         && *(double *)(v5 + 32) == a2[4])
        && (!(v10 & 0xC)
         || !((*(_DWORD *)v5 ^ v10) & 0xC)
         && *(double *)(v5 + 40) == a2[5]
         && *(double *)(v5 + 48) == a2[6]
         && *(double *)(v5 + 56) == a2[7]
         && *(double *)(v5 + 64) == a2[8]) )
      {
        v11 = *(_DWORD *)(v5 + 104);
        if ( !v11 )
          return result;
        if ( v11 == *((_DWORD *)a2 + 26) )
        {
          if ( v11 <= 0 )
            return result;
          v12 = *(_BYTE **)(v5 + 112);
          v13 = (_BYTE *)*((_QWORD *)a2 + 14);
          if ( v13[1] == v12[1] && *v13 == *v12 && v13[3] == v12[3] )
          {
            v14 = v12 + 4;
            v15 = v13 + 4;
            v16 = (signed __int64)&v14[4 * (v11 - 1)];
            do
            {
              v18 = v14;
              if ( *(v14 - 2) != *(v15 - 2) )
                break;
              if ( (_BYTE *)v16 == v14 )
                return result;
              if ( v14[1] != v15[1] )
                break;
              if ( *v14 != *v15 )
                break;
              v17 = v15[3];
              v14 += 4;
              v15 += 4;
            }
            while ( v18[3] == v17 );
          }
        }
      }
    }
    while ( 1 )
    {
      v5 += 136LL;
      if ( v5 == v6 )
        break;
      while ( 1 )
      {
        v19 = *(_QWORD *)(v5 + 128);
        result = v5;
        if ( v19 )
        {
          if ( !(*(_BYTE *)(v19 + 19) & 2) )
            break;
        }
        if ( *(_QWORD *)(v5 + 80) == *((_QWORD *)a2 + 10) )
          goto LABEL_8;
        v5 += 136LL;
        if ( v5 == v6 )
          goto LABEL_39;
      }
    }
LABEL_39:
    result = 0LL;
  }
  return result;
}

//----- (000000000000F4D0) ----------------------------------------------------
__int64 __fastcall sub_F4D0(__int64 a1, unsigned int a2)
{
  unsigned int v2; // er12
  int i; // ebp
  int v4; // eax
  int v5; // eax

  v2 = a2;
  for ( i = 0; a2 != i; ++i )
  {
    v5 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v5 - 1;
    if ( v5 )
    {
      ++*(_QWORD *)a1;
    }
    else
    {
      v4 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      *(_DWORD *)(a1 + 12) = v4;
      if ( v4 == -1 )
        return (unsigned int)-1;
    }
  }
  return v2;
}

//----- (000000000000F520) ----------------------------------------------------
signed __int64 __fastcall sub_F520(__int64 a1)
{
  void **v1; // rbx

  v1 = *(void ***)(a1 + 8240);
  inflateEnd(*(_QWORD *)(a1 + 8240));
  BufFileClose(v1[2063]);
  free(v1);
  return 1LL;
}
// 8920: using guessed type __int64 __fastcall inflateEnd(_QWORD);

//----- (000000000000F560) ----------------------------------------------------
signed __int64 __fastcall sub_F560(__int64 a1)
{
  int v1; // eax
  unsigned __int8 *v2; // rax
  signed __int64 result; // rax
  __int64 v4; // rbp
  signed int v5; // eax
  int v6; // eax
  __int64 v7; // rbx
  __int64 v8; // r15
  _BYTE *v9; // rax
  __int64 v10; // rdx
  signed int v11; // er13
  int v12; // eax
  _QWORD *v13; // rdx
  int v14; // eax

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 >= 0 )
  {
    *(_DWORD *)(a1 + 8) = v1 - 1;
    v2 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    return *v2;
  }
  v4 = *(_QWORD *)(a1 + 8240);
  v5 = *(_DWORD *)(v4 + 112);
  if ( v5 == -1 )
    goto LABEL_21;
  if ( v5 <= -1 )
  {
    if ( v5 != -3 )
      return 0xFFFFFFFFLL;
    goto LABEL_21;
  }
  if ( v5 )
  {
    if ( v5 != 1 )
      return 0xFFFFFFFFLL;
LABEL_21:
    *(_DWORD *)(a1 + 8) = 0;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(v4 + 32) = 0x2000;
  *(_QWORD *)(v4 + 24) = v4 + 116;
  do
  {
    if ( !*(_DWORD *)(v4 + 8) )
    {
      v7 = 0LL;
      do
      {
        v10 = *(_QWORD *)(v4 + 16504);
        v11 = v7;
        v12 = *(_DWORD *)(v10 + 8);
        *(_DWORD *)(v10 + 8) = v12 - 1;
        if ( v12 )
        {
          v13 = *(_QWORD **)(v4 + 16504);
          v9 = (_BYTE *)(*v13)++;
          LOBYTE(v9) = *v9;
        }
        else
        {
          v8 = *(_QWORD *)(v4 + 16504);
          LODWORD(v9) = (*(__int64 (__fastcall **)(__int64))(v8 + 8208))(v8);
          *(_DWORD *)(v8 + 12) = (_DWORD)v9;
          if ( (_DWORD)v9 == -1 )
            goto LABEL_19;
        }
        *(_BYTE *)(v4 + v7++ + 8308) = (_BYTE)v9;
      }
      while ( v7 != 0x2000 );
      v11 = 0x2000;
LABEL_19:
      *(_DWORD *)(v4 + 8) += v11;
      *(_QWORD *)v4 = v4 + 8308;
    }
    v6 = inflate(v4, 0LL);
    *(_DWORD *)(v4 + 112) = v6;
  }
  while ( !v6 && *(_DWORD *)(v4 + 32) );
  *(_QWORD *)a1 = v4 + 116;
  v14 = 0x2000 - *(_DWORD *)(v4 + 32);
  if ( 0x2000 - *(_DWORD *)(v4 + 32) < 0 )
  {
    *(_DWORD *)(a1 + 8) = v14;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = v14 - 1;
    *(_QWORD *)a1 = v4 + 117;
    result = *(unsigned __int8 *)(v4 + 116);
  }
  return result;
}
// 81E0: using guessed type __int64 __fastcall inflate(_QWORD, _QWORD);

//----- (000000000000F700) ----------------------------------------------------
__int64 __fastcall BufFilePushZIP(__int64 a1)
{
  _QWORD *v1; // rax
  _DWORD *v2; // rbx
  int v3; // eax
  __int64 v4; // rbp
  int v5; // eax
  int v6; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  char v14; // r12
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // er13
  int v32; // eax
  int i; // er13
  int v34; // eax
  int v35; // eax
  _BYTE *v36; // rax
  unsigned __int8 *v37; // rax
  unsigned __int8 *v38; // rax
  char *v39; // rax
  int v40; // eax
  int v41; // edx
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int v46; // eax
  unsigned __int8 *v47; // rax
  int v48; // eax
  int v49; // eax
  unsigned __int8 *v50; // rax
  unsigned __int8 *v51; // rax
  unsigned __int8 *v52; // rdx

  v1 = malloc(0x4080uLL);
  if ( !v1 )
    return 0LL;
  v1[8] = 0LL;
  v1[9] = 0LL;
  v1[10] = 0LL;
  v1[2063] = a1;
  *v1 = 0LL;
  v1[3] = 0LL;
  *((_DWORD *)v1 + 8) = 0;
  *((_DWORD *)v1 + 2) = 0;
  v2 = v1;
  v3 = inflateInit2_(v1, 4294967281LL, "1.2.11", 112LL);
  v2[28] = v3;
  if ( v3 )
    goto LABEL_6;
  v4 = *((_QWORD *)v2 + 2063);
  v2[8] = 0x2000;
  v2[2] = 0;
  *((_QWORD *)v2 + 3) = v2 + 2077;
  v5 = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(v4 + 8) = v5 - 1;
  if ( v5 )
  {
    v36 = (_BYTE *)(*(_QWORD *)v4)++;
    if ( *v36 != 31 )
      goto LABEL_6;
  }
  else
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v6;
    if ( v6 == -1 || v6 != 31 )
      goto LABEL_6;
  }
  v8 = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(v4 + 8) = v8 - 1;
  if ( v8 )
  {
    v37 = (unsigned __int8 *)(*(_QWORD *)v4)++;
    v9 = *v37;
  }
  else
  {
    v9 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v9;
    if ( v9 == -1 )
      goto LABEL_6;
  }
  if ( v9 != 139 )
    goto LABEL_6;
  v10 = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(v4 + 8) = v10 - 1;
  if ( v10 )
  {
    v38 = (unsigned __int8 *)(*(_QWORD *)v4)++;
    v11 = *v38;
  }
  else
  {
    v11 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v11;
    if ( v11 == -1 )
      goto LABEL_6;
  }
  if ( v11 != 8 )
    goto LABEL_6;
  v12 = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(v4 + 8) = v12 - 1;
  if ( v12 )
  {
    v39 = (char *)(*(_QWORD *)v4)++;
    v14 = *v39;
  }
  else
  {
    v13 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    v14 = v13;
    *(_DWORD *)(v4 + 12) = v13;
    if ( v13 == -1 )
      goto LABEL_6;
  }
  if ( v14 & 0xE0 )
    goto LABEL_6;
  v15 = *(_DWORD *)(v4 + 8);
  v16 = v15 - 1;
  *(_DWORD *)(v4 + 8) = v15 - 1;
  if ( v15 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v17 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v17;
    if ( v17 == -1 )
      goto LABEL_6;
    v16 = *(_DWORD *)(v4 + 8);
  }
  v18 = v16 - 1;
  *(_DWORD *)(v4 + 8) = v16 - 1;
  if ( v16 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v19 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v19;
    if ( v19 == -1 )
      goto LABEL_6;
    v18 = *(_DWORD *)(v4 + 8);
  }
  v20 = v18 - 1;
  *(_DWORD *)(v4 + 8) = v18 - 1;
  if ( v18 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v21 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v21;
    if ( v21 == -1 )
      goto LABEL_6;
    v20 = *(_DWORD *)(v4 + 8);
  }
  *(_DWORD *)(v4 + 8) = v20 - 1;
  if ( v20 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v22 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v22;
    if ( v22 == -1 )
      goto LABEL_6;
  }
  v23 = *(_DWORD *)(v4 + 8);
  v24 = v23;
  v25 = v23 - 1;
  *(_DWORD *)(v4 + 8) = v25;
  if ( v24 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v26 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v26;
    if ( v26 == -1 )
      goto LABEL_6;
    v25 = *(_DWORD *)(v4 + 8);
  }
  *(_DWORD *)(v4 + 8) = v25 - 1;
  if ( v25 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v27 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v27;
    if ( v27 == -1 )
      goto LABEL_6;
  }
  if ( v14 & 4 )
  {
    v28 = *(_DWORD *)(v4 + 8);
    v29 = v28;
    v30 = v28 - 1;
    *(_DWORD *)(v4 + 8) = v30;
    if ( v29 )
    {
      v52 = (unsigned __int8 *)(*(_QWORD *)v4)++;
      v31 = *v52;
    }
    else
    {
      v31 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
      *(_DWORD *)(v4 + 12) = v31;
      if ( v31 == -1 )
        goto LABEL_6;
      v30 = *(_DWORD *)(v4 + 8);
    }
    *(_DWORD *)(v4 + 8) = v30 - 1;
    if ( v30 )
    {
      v51 = (unsigned __int8 *)(*(_QWORD *)v4)++;
      v32 = *v51;
    }
    else
    {
      v32 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
      *(_DWORD *)(v4 + 12) = v32;
      if ( v32 == -1 )
        goto LABEL_6;
    }
    for ( i = (v32 << 8) + v31; i >= 0; --i )
    {
      v35 = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(v4 + 8) = v35 - 1;
      if ( v35 )
      {
        ++*(_QWORD *)v4;
      }
      else
      {
        v34 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
        *(_DWORD *)(v4 + 12) = v34;
        if ( v34 == -1 )
          goto LABEL_6;
      }
    }
  }
  if ( v14 & 8 )
  {
    do
    {
      v46 = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(v4 + 8) = v46 - 1;
      if ( v46 )
      {
        v47 = (unsigned __int8 *)(*(_QWORD *)v4)++;
        v45 = *v47;
      }
      else
      {
        v45 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
        *(_DWORD *)(v4 + 12) = v45;
        if ( v45 == -1 )
          goto LABEL_6;
      }
    }
    while ( v45 );
  }
  if ( v14 & 0x10 )
  {
    do
    {
      v49 = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(v4 + 8) = v49 - 1;
      if ( v49 )
      {
        v50 = (unsigned __int8 *)(*(_QWORD *)v4)++;
        v48 = *v50;
      }
      else
      {
        v48 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
        *(_DWORD *)(v4 + 12) = v48;
        if ( v48 == -1 )
          goto LABEL_6;
      }
    }
    while ( v48 );
  }
  if ( !(v14 & 2) )
    return BufFileCreate(v2, sub_F560, 0LL, sub_F4D0, sub_F520);
  v40 = *(_DWORD *)(v4 + 8);
  v41 = v40;
  v42 = v40 - 1;
  *(_DWORD *)(v4 + 8) = v42;
  if ( v41 )
  {
    ++*(_QWORD *)v4;
  }
  else
  {
    v43 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
    *(_DWORD *)(v4 + 12) = v43;
    if ( v43 == -1 )
      goto LABEL_6;
    v42 = *(_DWORD *)(v4 + 8);
  }
  *(_DWORD *)(v4 + 8) = v42 - 1;
  if ( v42 )
  {
    ++*(_QWORD *)v4;
    return BufFileCreate(v2, sub_F560, 0LL, sub_F4D0, sub_F520);
  }
  v44 = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
  *(_DWORD *)(v4 + 12) = v44;
  if ( v44 == -1 )
  {
LABEL_6:
    free(v2);
    return 0LL;
  }
  return BufFileCreate(v2, sub_F560, 0LL, sub_F4D0, sub_F520);
}
// 8150: using guessed type __int64 __fastcall BufFileCreate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8D10: using guessed type __int64 __fastcall inflateInit2_(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000FBD0) ----------------------------------------------------
__int64 FontFileRegisterFpeFunctions()
{
  BitmapRegisterFontFileFunctions();
  FreeTypeRegisterFontFileFunctions();
  FontFileRegisterLocalFpeFunctions();
  return CatalogueRegisterLocalFpeFunctions();
}
// 81C0: using guessed type __int64 FontFileRegisterLocalFpeFunctions(void);
// 8C20: using guessed type __int64 CatalogueRegisterLocalFpeFunctions(void);
// 8EA0: using guessed type __int64 BitmapRegisterFontFileFunctions(void);

//----- (000000000000FBF0) ----------------------------------------------------
__int64 __fastcall FontFilePriorityRegisterRenderer(__int64 a1, int a2)
{
  void *v2; // r13
  size_t v3; // rsi
  int v4; // er12
  int v5; // ecx
  unsigned int v6; // ebp
  char *v7; // rax
  signed __int64 v8; // rbx
  int v9; // er14
  int v11; // ebp
  const char ***v12; // r15
  const char *v13; // r12
  int v14; // [rsp+Ch] [rbp-4Ch]
  __int64 v15; // [rsp+18h] [rbp-40h]
  int v16[16]; // [rsp+18h] [rbp-40h]

  v2 = qword_23CB78;
  v14 = a2;
  v15 = serverGeneration;
  if ( qword_23CB60 == serverGeneration )
  {
    v11 = dword_23CB70;
    if ( dword_23CB70 <= 0 )
    {
      v3 = 16LL;
      v4 = 1;
      v5 = 0;
    }
    else
    {
      v12 = (const char ***)qword_23CB78;
      v9 = 0;
      v13 = *(const char **)a1;
      while ( 1 )
      {
        v8 = (signed __int64)v12;
        if ( !strcasecmp(**v12, v13) )
          break;
        v5 = v9 + 1;
        v12 += 2;
        if ( v11 == v9 + 1 )
        {
          v4 = v9 + 2;
          v3 = 16LL * (v9 + 2);
          goto LABEL_5;
        }
        ++v9;
      }
      if ( *((_DWORD *)v12 + 2) >= a2 )
      {
        v6 = 1;
        if ( *((_DWORD *)v12 + 2) == a2 && v15 == 1 )
          ErrorF("Warning: font renderer for \"%s\" already registered at priority %d\n");
        return v6;
      }
      if ( v11 > v9 )
        goto LABEL_8;
      v4 = v9 + 1;
      v5 = v9;
      v3 = 16LL * (v9 + 1);
    }
  }
  else
  {
    qword_23CB60 = serverGeneration;
    dword_23CB70 = 0;
    if ( qword_23CB78 )
      free(qword_23CB78);
    qword_23CB78 = 0LL;
    v2 = 0LL;
    v3 = 16LL;
    v4 = 1;
    v5 = 0;
  }
LABEL_5:
  v16[0] = v5;
  v6 = 0;
  v7 = (char *)realloc(v2, v3);
  if ( v7 )
  {
    qword_23CB78 = v7;
    dword_23CB70 = v4;
    v8 = (signed __int64)&v7[16 * v16[0]];
    v9 = v16[0];
LABEL_8:
    v6 = 1;
    *(_DWORD *)(a1 + 48) = v9;
    *(_QWORD *)v8 = a1;
    *(_DWORD *)(v8 + 8) = v14;
  }
  return v6;
}
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);
// 23CB60: using guessed type __int64 qword_23CB60;
// 23CB70: using guessed type int dword_23CB70;

//----- (000000000000FDA0) ----------------------------------------------------
__int64 __fastcall FontFileRegisterRenderer(__int64 a1)
{
  return FontFilePriorityRegisterRenderer(a1, 0LL);
}
// 8B50: using guessed type __int64 __fastcall FontFilePriorityRegisterRenderer(_QWORD, _QWORD);

//----- (000000000000FDB0) ----------------------------------------------------
const char **__fastcall FontFileMatchRenderer(const char *a1)
{
  signed int v1; // ebp
  const char ***v2; // rbx
  const char ***v3; // r12
  const char **v4; // r15
  __int64 v5; // rdx

  v1 = strlen(a1);
  if ( dword_23CB70 <= 0 )
    return 0LL;
  v2 = (const char ***)qword_23CB78;
  v3 = (const char ***)((char *)qword_23CB78 + 16 * (unsigned int)(dword_23CB70 - 1) + 16);
  while ( 1 )
  {
    v4 = *v2;
    v5 = *((signed int *)*v2 + 2);
    if ( (signed int)v5 <= v1 && !strcasecmp(&a1[v1 - v5], *v4) )
      break;
    v2 += 2;
    if ( v3 == v2 )
      return 0LL;
  }
  return v4;
}
// 23CB70: using guessed type int dword_23CB70;

//----- (000000000000FE30) ----------------------------------------------------
signed __int64 __fastcall sub_FE30(FontPathElementPtr fpe)
{
  return 89LL;
}

//----- (000000000000FE40) ----------------------------------------------------
int __fastcall sub_FE40(pointer client, FontPathElementPtr fpe, char **namep, int *namelenp, char **resolvedp, int *resolvedlenp, pointer c_private)
{
  char **v7; // r14
  _QWORD *v8; // rdx
  int v9; // eax
  int *v10; // r13
  char **v11; // r12
  int result; // eax
  int *resolvedlenpa; // [rsp+8h] [rbp-40h]

  v7 = namep;
  v8 = fpe->c_private;
  resolvedlenpa = resolvedlenp;
  v9 = *((_DWORD *)c_private + 2);
  if ( v9 == *((_DWORD *)v8 + 2) )
  {
LABEL_6:
    free(c_private);
    result = 83;
  }
  else
  {
    v10 = namelenp;
    v11 = resolvedp;
    while ( 1 )
    {
      result = j_FontFileListNextFontOrAlias(
                 client,
                 *(FontPathElementPtr *)(v8[2] + 8LL * v9),
                 v7,
                 v10,
                 v11,
                 resolvedlenpa,
                 *(pointer *)(*(_QWORD *)c_private + 8LL * v9));
      if ( result != 83 )
        break;
      v9 = *((_DWORD *)c_private + 2) + 1;
      *((_DWORD *)c_private + 2) = v9;
      v8 = fpe->c_private;
      if ( *((_DWORD *)v8 + 2) == v9 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (000000000000FEF0) ----------------------------------------------------
signed __int64 __fastcall sub_FEF0(const void *a1, const void *a2)
{
  __int64 v2; // rbp
  const char *v3; // rdi
  char *v4; // rax
  const char *v5; // rdi
  char *v6; // rbx
  bool v7; // r12
  char *v8; // rbp
  signed __int64 result; // rax
  int v10; // ebx

  v2 = *(_QWORD *)(*(_QWORD *)a2 + 24LL);
  v3 = *(const char **)(*(_QWORD *)(*(_QWORD *)a1 + 24LL) + 72LL);
  if ( v3 )
  {
    v4 = strstr(v3, "pri=");
    v5 = *(const char **)(v2 + 72);
    v6 = v4;
    v7 = v4 == 0LL;
    if ( !v5 )
      return (unsigned int)-(v4 != 0LL);
  }
  else
  {
    v5 = *(const char **)(v2 + 72);
    v6 = 0LL;
    v7 = 1;
    if ( !v5 )
      return 0LL;
  }
  v8 = strstr(v5, "pri=");
  if ( v8 || (result = 0LL, !v7) )
  {
    result = 1LL;
    if ( v6 )
    {
      if ( v8 )
      {
        v10 = strtol(v6 + 4, 0LL, 10);
        result = v10 - (unsigned int)strtol(v8 + 4, 0LL, 10);
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

//----- (000000000000FFC0) ----------------------------------------------------
int __fastcall sub_FFC0(pointer client, FontPathElementPtr fpe, char **name, int *namelen, FontInfoPtr *info, int *numFonts, pointer c_private)
{
  char **v7; // r14
  _QWORD *v8; // rdx
  int v9; // eax
  int *v10; // r13
  FontInfoPtr *v11; // r12
  int result; // eax
  int *numFontsa; // [rsp+8h] [rbp-40h]

  v7 = name;
  v8 = fpe->c_private;
  numFontsa = numFonts;
  v9 = *((_DWORD *)c_private + 2);
  if ( v9 == *((_DWORD *)v8 + 2) )
  {
LABEL_6:
    free(c_private);
    result = 83;
  }
  else
  {
    v10 = namelen;
    v11 = info;
    while ( 1 )
    {
      result = j_FontFileListNextFontWithInfo(
                 client,
                 *(FontPathElementPtr *)(v8[2] + 8LL * v9),
                 v7,
                 v10,
                 v11,
                 numFontsa,
                 *(pointer *)(*(_QWORD *)c_private + 8LL * v9));
      if ( result != 83 )
        break;
      v9 = *((_DWORD *)c_private + 2) + 1;
      *((_DWORD *)c_private + 2) = v9;
      v8 = fpe->c_private;
      if ( *((_DWORD *)v8 + 2) == v9 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (0000000000010080) ----------------------------------------------------
_BOOL8 __fastcall sub_10080(char *name)
{
  return strncmp(name, "catalogue:", 0xAuLL) == 0;
}

//----- (00000000000100B0) ----------------------------------------------------
void __fastcall sub_100B0(__int64 a1)
{
  __int64 v1; // r12
  int v2; // ebp
  struct _FontPathElement *v3; // rbx
  bool v4; // zf

  if ( *(_DWORD *)(a1 + 8) > 0 )
  {
    v1 = 0LL;
    v2 = 0;
    do
    {
      while ( 1 )
      {
        v3 = *(struct _FontPathElement **)(*(_QWORD *)(a1 + 16) + v1);
        v4 = v3->refcount-- == 1;
        if ( v4 )
          break;
        ++v2;
        v1 += 8LL;
        if ( v2 >= *(_DWORD *)(a1 + 8) )
          goto LABEL_6;
      }
      ++v2;
      v1 += 8LL;
      j_FontFileFreeFPE(v3);
      free(v3->name);
      free(v3);
    }
    while ( v2 < *(_DWORD *)(a1 + 8) );
  }
LABEL_6:
  *(_DWORD *)(a1 + 8) = 0;
}

//----- (0000000000010130) ----------------------------------------------------
__int64 __fastcall sub_10130(__int64 a1, int a2)
{
  __time_t *v2; // r13
  const char *v3; // rbx
  int v4; // eax
  unsigned int v5; // ecx
  struct dirent *i; // rax
  int v8; // eax
  __int64 v9; // rbp
  int v10; // eax
  __int64 v11; // r15
  int v12; // ST20_4
  char *v13; // rax
  size_t v14; // rax
  struct _FontPathElement *v15; // r15
  int v16; // eax
  char *v17; // rax
  _BYTE *v18; // rax
  __int64 v19; // rdx
  signed int v20; // esi
  _QWORD *v21; // rax
  int v22; // esi
  size_t v23; // rsi
  DIR *dirp; // [rsp+8h] [rbp-8F0h]
  char *src; // [rsp+10h] [rbp-8E8h]
  __int64 v26; // [rsp+18h] [rbp-8E0h]
  struct stat stat_buf; // [rsp+20h] [rbp-8D8h]
  char v28; // [rsp+B0h] [rbp-848h]
  char buf[1032]; // [rsp+4B0h] [rbp-448h]
  unsigned __int64 v30; // [rsp+8B8h] [rbp-40h]

  v2 = *(__time_t **)(a1 + 24);
  v30 = __readfsqword(0x28u);
  v3 = (const char *)(*(_QWORD *)(a1 + 8) + 10LL);
  v4 = __xstat(1, v3, &stat_buf);
  v5 = 86;
  if ( v4 >= 0 && (stat_buf.st_mode & 0xF000) == 0x4000 )
  {
    if ( a2 || (v5 = 85, stat_buf.st_mtim.tv_sec > *v2) )
    {
      dirp = opendir(v3);
      if ( !dirp )
      {
        free(v2);
        return 86;
      }
      sub_100B0(*(_QWORD *)(a1 + 24));
LABEL_8:
      for ( i = readdir(dirp); i; i = readdir(dirp) )
      {
        __snprintf_chk(&v28, 1024LL, 1LL, 1024LL, "%s/%s", v3, i->d_name);
        v8 = readlink(&v28, buf, 0x3FFuLL);
        LODWORD(v9) = v8;
        if ( v8 < 0 )
          goto LABEL_8;
        buf[v8] = 0;
        if ( buf[0] != 47 )
        {
          v10 = strlen(v3);
          v11 = v10;
          v12 = v10;
          memmove(&buf[v10 + 1], buf, 1023LL - v10);
          __memcpy_chk(buf, v3, v11, 1024LL);
          buf[v11] = 47;
          LODWORD(v9) = v9 + v12 + 1;
        }
        v13 = strchr(&v28, 58);
        if ( v13 )
        {
          src = v13;
          v26 = (signed int)v9;
          v14 = strlen(v13);
          if ( (signed int)v9 + v14 <= 0x3FF )
          {
            LODWORD(v9) = v14 + v9;
            memcpy(&buf[v26], src, v14);
          }
        }
        v15 = (struct _FontPathElement *)malloc(0x20uLL);
        if ( !v15 )
          goto LABEL_8;
        v16 = *(_DWORD *)(a1 + 16);
        v15->name_length = v9;
        v15->type = v16;
        v17 = (char *)malloc((signed int)v9 + 1);
        v15->name = v17;
        if ( v17 )
        {
          v9 = (signed int)v9;
          v18 = memcpy(v17, buf, (signed int)v9);
          v15->refcount = 1;
          v18[v9] = 0;
          if ( j_FontFileInitFPE(v15) == 85 )
          {
            v19 = *((signed int *)v2 + 2);
            v20 = *((_DWORD *)v2 + 3);
            v21 = (_QWORD *)v2[2];
            if ( (signed int)v19 < v20 )
            {
LABEL_26:
              *((_DWORD *)v2 + 2) = v19 + 1;
              v21[v19] = v15;
              goto LABEL_8;
            }
            if ( v20 )
            {
              v22 = 2 * v20;
              *((_DWORD *)v2 + 3) = v22;
              v23 = 8LL * v22;
            }
            else
            {
              *((_DWORD *)v2 + 3) = 16;
              v23 = 128LL;
            }
            v21 = realloc(v21, v23);
            if ( v21 )
            {
              v19 = *((signed int *)v2 + 2);
              v2[2] = (__time_t)v21;
              goto LABEL_26;
            }
            j_FontFileFreeFPE(v15);
            free(v15);
            goto LABEL_8;
          }
          free(v15->name);
        }
        free(v15);
      }
      closedir(dirp);
      qsort((void *)v2[2], *((signed int *)v2 + 2), 8uLL, (__compar_fn_t)sub_FEF0);
      v5 = 85;
      *v2 = stat_buf.st_mtim.tv_sec;
    }
  }
  return v5;
}
// 8030: using guessed type __int64 __fastcall __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 10130: using guessed type char buf[1032];

//----- (0000000000010480) ----------------------------------------------------
signed __int64 __fastcall sub_10480(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  __int64 v6; // rbp
  _DWORD *v7; // rbx
  signed __int64 result; // rax
  __int64 v9; // r15
  _QWORD *v10; // [rsp+8h] [rbp-40h]

  v6 = *(_QWORD *)(a2 + 24);
  v10 = a6;
  sub_10130(a2, 0);
  v7 = malloc(8LL * *(signed int *)(v6 + 8) + 16);
  result = 80LL;
  if ( v7 )
  {
    *(_QWORD *)v7 = v7 + 4;
    if ( *(_DWORD *)(v6 + 8) <= 0 )
    {
LABEL_8:
      v7[2] = 0;
      *v10 = v7;
      result = 85LL;
    }
    else
    {
      v9 = 0LL;
      while ( (unsigned int)FontFileStartListFonts(a1) == 85 )
      {
        if ( *(_DWORD *)(v6 + 8) <= (signed int)++v9 )
          goto LABEL_8;
      }
      free(v7);
      result = 80LL;
    }
  }
  return result;
}
// 8270: using guessed type __int64 __cdecl FontFileStartListFonts(_QWORD);

//----- (0000000000010570) ----------------------------------------------------
signed __int64 __fastcall sub_10570(pointer client, FontPathElementPtr fpe, char *pat, __int64 len, __int64 max, pointer *privatep)
{
  return sub_10480((__int64)client, (__int64)fpe, (__int64)pat, len, max, privatep);
}

//----- (0000000000010580) ----------------------------------------------------
signed __int64 __fastcall sub_10580(pointer client, FontPathElementPtr fpe, char *pat, __int64 len, __int64 max, pointer *privatep)
{
  return sub_10480((__int64)client, (__int64)fpe, (__int64)pat, len, max, privatep);
}

//----- (0000000000010590) ----------------------------------------------------
__int64 __fastcall sub_10590(FontPathElementPtr fpe)
{
  _QWORD *v1; // rax

  v1 = malloc(0x18uLL);
  if ( !v1 )
    return 80LL;
  fpe->c_private = v1;
  *v1 = 0LL;
  v1[1] = 0LL;
  v1[2] = 0LL;
  return sub_10130((__int64)fpe, 1);
}

//----- (00000000000105E0) ----------------------------------------------------
signed __int64 __fastcall sub_105E0(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, FontNamesPtr names)
{
  struct _FontNames *v6; // r15
  int v7; // er13
  char *v8; // r12
  int v9; // er14
  _QWORD *v10; // rbp
  __int64 v11; // rbx

  v6 = names;
  v7 = len;
  v8 = pat;
  v9 = max;
  v10 = fpe->c_private;
  sub_10130((__int64)fpe, 0);
  if ( *((_DWORD *)v10 + 2) > 0 )
  {
    v11 = 0LL;
    do
      j_FontFileListFonts(client, *(FontPathElementPtr *)(v10[2] + 8 * v11++), v8, v7, v9, v6);
    while ( *((_DWORD *)v10 + 2) > (signed int)v11 );
  }
  return 85LL;
}

//----- (0000000000010660) ----------------------------------------------------
int __fastcall sub_10660(pointer client, FontPathElementPtr fpe, Mask flags, char *name, int namelen, fsBitmapFormat format, fsBitmapFormatMask fmask, XID id, FontPtr *pFont, char **aliasName, FontPtr non_cachable_font)
{
  fsBitmapFormat v11; // er14
  int v12; // er13
  Mask v13; // rbp
  char *v14; // r12
  _DWORD *v15; // rbx
  __int64 v16; // r15
  int result; // eax

  v11 = format;
  v12 = namelen;
  v13 = flags;
  v14 = name;
  v15 = fpe->c_private;
  sub_10130((__int64)fpe, 0);
  if ( v15[2] <= 0 )
    return 83;
  v16 = 0LL;
  while ( 1 )
  {
    result = j_FontFileOpenFont(
               client,
               *(FontPathElementPtr *)(*((_QWORD *)v15 + 2) + 8 * v16),
               v13,
               v14,
               v12,
               v11,
               fmask,
               id,
               pFont,
               aliasName,
               non_cachable_font);
    if ( result == 85 || result == 82 )
      break;
    if ( v15[2] <= (signed int)++v16 )
      return 83;
  }
  return result;
}

//----- (0000000000010710) ----------------------------------------------------
int __fastcall sub_10710(FontPathElementPtr fpe)
{
  void **v2; // rbx

  if ( strncmp(fpe->name, "catalogue:", 0xAuLL) )
    return j_FontFileFreeFPE(fpe);
  v2 = (void **)fpe->c_private;
  sub_100B0((__int64)v2);
  free(v2[2]);
  free(v2);
  return 85;
}

//----- (0000000000010770) ----------------------------------------------------
int CatalogueRegisterLocalFpeFunctions()
{
  return RegisterFPEFunctions(
           (NameCheckFunc)sub_10080,
           (InitFpeFunc)sub_10590,
           (FreeFpeFunc)sub_10710,
           (ResetFpeFunc)sub_FE30,
           (OpenFontFunc)sub_10660,
           j_j_FontFileCloseFont,
           (ListFontsFunc)sub_105E0,
           (StartLfwiFunc)sub_10580,
           (NextLfwiFunc)sub_FFC0,
           0LL,
           0LL,
           0LL,
           (StartLaFunc)sub_10570,
           (NextLaFunc)sub_FE40,
           (SetPathFunc)FontFileEmptyBitmapSource);
}

//----- (00000000000107E0) ----------------------------------------------------
signed __int64 __fastcall FTPickMapping(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r13
  __int64 v6; // rbp
  __int64 v7; // rbx
  const char *v8; // rax
  const char *v9; // r12
  const char *v10; // rdi
  int v11; // er14
  signed int v12; // er14
  size_t v13; // r15
  __int64 v14; // rax
  signed __int64 result; // rax
  __int64 v16; // r15
  int v17; // eax
  int *v18; // r12
  int v19; // eax
  int v20; // er9
  signed __int64 v21; // r8
  __int64 *v22; // rax
  signed __int64 v23; // rdi
  __int64 v24; // rdx
  __int64 v25; // rdx
  __int64 *v26; // rax
  __int64 *v27; // rax
  __int64 *v28; // rcx
  __int64 v29; // rax
  char *s1; // [rsp+0h] [rbp-78h]
  char s1a; // [rsp+0h] [rbp-78h]
  char *v32; // [rsp+8h] [rbp-70h]
  char *s; // [rsp+10h] [rbp-68h]
  char *v34; // [rsp+18h] [rbp-60h]
  char v35[24]; // [rsp+20h] [rbp-58h]
  unsigned __int64 v36; // [rsp+38h] [rbp-40h]

  v5 = a3;
  v6 = a5;
  v7 = a4;
  v36 = __readfsqword(0x28u);
  if ( !a1 || (v8 = (const char *)FontEncFromXLFD(), (v9 = v8) == 0LL) )
  {
    v9 = "iso8859-1";
    if ( strcasecmp("iso8859-1", "microsoft-symbol") )
      goto LABEL_6;
LABEL_15:
    if ( !(unsigned int)FT_Get_BDF_Charset_ID(v7, &s, &v34) )
    {
      v12 = 1;
      goto LABEL_11;
    }
LABEL_16:
    if ( !(unsigned int)FT_Select_Charmap(v7, 1094992451LL) )
      goto LABEL_12;
    s1a = 1;
    v12 = 1;
    goto LABEL_43;
  }
  if ( !strcasecmp(v8, "microsoft-symbol") )
    goto LABEL_15;
  if ( *v9 == 45 )
  {
    v10 = v9;
    goto LABEL_9;
  }
  if ( !*v9 )
  {
LABEL_18:
    v12 = FT_Get_BDF_Charset_ID(v7, &s, &v34);
    if ( !v12 )
      goto LABEL_11;
    goto LABEL_19;
  }
LABEL_6:
  v10 = v9;
  while ( *++v10 != 45 )
  {
    if ( !*v10 )
      goto LABEL_18;
  }
LABEL_9:
  v11 = strcasecmp(v10 + 1, "fontspecific");
  if ( (unsigned int)FT_Get_BDF_Charset_ID(v7, &s, &v34) )
  {
    if ( !v11 )
      goto LABEL_16;
LABEL_19:
    v12 = 0;
    v16 = FontEncFind(v9, v5);
    goto LABEL_20;
  }
  v12 = v11 == 0;
LABEL_11:
  s1 = s;
  v13 = strlen(s);
  v32 = v34;
  if ( v13 + strlen(v34) > 0x12 )
  {
LABEL_12:
    *(_DWORD *)v6 = 0;
    v14 = *(_QWORD *)(v7 + 168);
    *(_DWORD *)(v6 + 16) = 0;
    *(_QWORD *)(v6 + 24) = 0LL;
    *(_QWORD *)(v6 + 8) = v14;
    return 85LL;
  }
  __memcpy_chk(v35, s1, v13, 20LL);
  v35[v13] = 45;
  __strcpy_chk(&v35[v13 + 1], v32, 20LL);
  ErrorF("%s %s\n");
  if ( strcasecmp(v35, "iso10646-1") )
  {
    if ( !strcasecmp(v35, v9) )
      goto LABEL_12;
    return 88LL;
  }
  s1a = v12 & 1;
LABEL_43:
  v16 = FontEncFind(v9, v5);
  if ( !v16 && s1a )
  {
    v16 = FontEncFind("microsoft-symbol", v5);
    if ( !v16 )
      goto LABEL_46;
    goto LABEL_21;
  }
LABEL_20:
  if ( !v16 )
  {
LABEL_46:
    ErrorF("FreeType: couldn't find encoding '%s' for '%s'\n");
    return 83LL;
  }
LABEL_21:
  v17 = FT_Has_PS_Glyph_Names(v7);
  v18 = *(int **)(v16 + 24);
  if ( v17 )
  {
    if ( v18 )
    {
      v19 = *v18;
      v25 = *(_QWORD *)(v16 + 24);
      if ( *v18 == 3 )
      {
LABEL_40:
        *(_DWORD *)v6 = 1;
        *(_DWORD *)(v6 + 16) = 0;
        result = 85LL;
        *(_QWORD *)(v6 + 24) = v25;
        return result;
      }
      while ( 1 )
      {
        v25 = *(_QWORD *)(v25 + 40);
        if ( !v25 )
          goto LABEL_24;
        if ( *(_DWORD *)v25 == 3 )
          goto LABEL_40;
      }
    }
    return 88LL;
  }
  if ( !v18 )
    return 88LL;
  v19 = *v18;
LABEL_24:
  v20 = *(_DWORD *)(v7 + 72);
  v21 = (unsigned int)(v20 - 1);
  while ( v19 == 1 )
  {
    if ( v20 > 0 )
    {
      v26 = *(__int64 **)(v7 + 80);
      v24 = *v26;
      if ( *(_DWORD *)(*v26 + 12) == 65539 )
        goto LABEL_32;
      v27 = v26 + 1;
      v28 = &v27[v21];
      while ( v28 != v27 )
      {
        v24 = *v27;
        ++v27;
        if ( *(_DWORD *)(v24 + 12) == 65539 )
          goto LABEL_32;
      }
    }
LABEL_54:
    v18 = (int *)*((_QWORD *)v18 + 5);
    if ( !v18 )
      return 88LL;
    v19 = *v18;
  }
  if ( v19 != 2 || v20 <= 0 )
    goto LABEL_54;
  v22 = *(__int64 **)(v7 + 80);
  v23 = (signed __int64)&v22[v21 + 1];
  while ( 1 )
  {
    v24 = *v22;
    if ( v18[1] == *(unsigned __int16 *)(*v22 + 12) && v18[2] == *(unsigned __int16 *)(v24 + 14) )
      break;
    ++v22;
    if ( (__int64 *)v23 == v22 )
      goto LABEL_54;
  }
LABEL_32:
  *(_DWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = v24;
  if ( v12 && (v29 = FT_Get_Sfnt_Table(v7, 2LL)) != 0 )
    *(_DWORD *)(v6 + 16) = *(unsigned __int16 *)(v29 + 86) - 32;
  else
    *(_DWORD *)(v6 + 16) = 0;
  *(_QWORD *)(v6 + 24) = v18;
  return 85LL;
}
// 8740: using guessed type __int64 FontEncFromXLFD(void);
// 8780: using guessed type __int64 __fastcall FontEncFind(_QWORD, _QWORD);
// 87B0: using guessed type __int64 __fastcall FT_Select_Charmap(_QWORD, _QWORD);
// 87C0: using guessed type __int64 __fastcall FT_Get_Sfnt_Table(_QWORD, _QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 89A0: using guessed type __int64 __fastcall FT_Get_BDF_Charset_ID(_QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 8E70: using guessed type __int64 __fastcall FT_Has_PS_Glyph_Names(_QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);
// 107E0: using guessed type char var_58[24];

//----- (0000000000010C80) ----------------------------------------------------
__int64 __fastcall FTRemap(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // rax
  unsigned int v7; // er12
  unsigned int v8; // ST0C_4

  v3 = a2;
  v4 = *(_QWORD *)(a2 + 24);
  if ( v4 )
  {
    if ( !*(_DWORD *)v3 )
    {
      v7 = *(_DWORD *)(v3 + 16) + (unsigned __int64)FontEncRecode(a3, v4);
      FT_Set_Charmap(a1, *(_QWORD *)(v3 + 8));
      return FT_Get_Char_Index(a1, v7);
    }
    v5 = FontEncName(a3, v4);
    if ( v5 )
      return FT_Get_Name_Index(a1, v5);
    return 0LL;
  }
  if ( a3 > 0xFF )
    return 0LL;
  v8 = a3;
  FT_Set_Charmap(a1, *(_QWORD *)(v3 + 8));
  return FT_Get_Char_Index(a1, v8);
}
// 80D0: using guessed type __int64 __fastcall FT_Get_Name_Index(_QWORD, _QWORD);
// 85F0: using guessed type __int64 __fastcall FontEncName(_QWORD, _QWORD);
// 8670: using guessed type __int64 __fastcall FontEncRecode(_QWORD, _QWORD);
// 86F0: using guessed type __int64 __fastcall FT_Set_Charmap(_QWORD, _QWORD);
// 8C10: using guessed type __int64 __fastcall FT_Get_Char_Index(_QWORD, _QWORD);

//----- (0000000000010D30) ----------------------------------------------------
__int64 __fastcall sub_10D30(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  unsigned int v4; // edx
  __int64 v6; // [rsp+8h] [rbp-20h]
  unsigned __int8 v7; // [rsp+16h] [rbp-12h]
  unsigned __int8 v8; // [rsp+17h] [rbp-11h]
  unsigned __int64 v9; // [rsp+18h] [rbp-10h]

  v6 = 2LL;
  v9 = __readfsqword(0x28u);
  v3 = FT_Load_Sfnt_Table(a1, a2, a3, &v7, &v6);
  v4 = 0;
  if ( !v3 )
    v4 = (v7 << 8) | v8;
  return v4;
}
// 81A0: using guessed type __int64 __fastcall FT_Load_Sfnt_Table(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000010D90) ----------------------------------------------------
__int64 __fastcall sub_10D90(unsigned __int16 *a1, __int16 *a2, unsigned __int16 *a3, _WORD *a4, unsigned __int8 *a5, int a6)
{
  signed int v6; // er10
  signed int v7; // er11
  signed int v8; // ebp
  signed int v9; // ebx
  signed __int64 v10; // r12
  signed int v11; // er9
  signed int v12; // eax
  signed int v13; // er8
  unsigned __int16 v14; // ax
  signed int v15; // er8
  signed int v16; // eax
  __int16 v17; // r8
  __int64 result; // rax

  if ( a6 <= 0 )
  {
    v6 = -1;
    v7 = 256;
    v9 = 256;
    v8 = -1;
  }
  else
  {
    v6 = -1;
    v7 = 256;
    v8 = -1;
    v9 = 256;
    v10 = (signed __int64)&a5[4 * (a6 - 1) + 4];
    do
    {
      v11 = *a5;
      v12 = a5[2];
      if ( (_BYTE)v11 == (_BYTE)v12 )
      {
        if ( v9 > a5[1] )
          v9 = a5[1];
        if ( v8 < a5[3] )
          v8 = a5[3];
      }
      else
      {
        v8 = 255;
        v9 = 0;
      }
      if ( v7 > v11 )
        v7 = *a5;
      if ( v6 < v12 )
        v6 = a5[2];
      a5 += 4;
    }
    while ( (unsigned __int8 *)v10 != a5 );
  }
  v13 = *a3;
  v14 = *a3;
  if ( v13 >= v9 )
  {
    v13 = *a1;
    v14 = *a1;
    if ( v13 < v9 )
    {
      v14 = v9;
      *a1 = v9;
      v13 = v9;
    }
  }
  else
  {
    *a1 = v13;
  }
  if ( v13 <= v8 )
  {
    if ( *a3 > v8 )
      *a3 = v8;
  }
  else
  {
    *a3 = v14;
  }
  v15 = (unsigned __int16)*a4;
  if ( v15 < v7 )
  {
    *a2 = v15;
    *a1 = *a3;
    v16 = (unsigned __int16)*a2;
    v17 = *a2;
    goto LABEL_22;
  }
  v16 = (unsigned __int16)*a2;
  v17 = *a2;
  if ( v16 >= v7 )
  {
LABEL_22:
    if ( v16 <= v6 )
      goto LABEL_23;
LABEL_28:
    *a4 = v17;
    result = *a1;
    *a3 = result;
    return result;
  }
  v17 = v7;
  *a2 = v7;
  if ( v7 > v6 )
    goto LABEL_28;
LABEL_23:
  result = (unsigned __int16)*a4;
  if ( (signed int)result > v6 )
    *a4 = v6;
  return result;
}

//----- (0000000000010EE0) ----------------------------------------------------
__int64 __fastcall sub_10EE0(int a1, unsigned __int16 *a2, __int16 *a3, unsigned __int16 *a4, _WORD *a5, const char *a6)
{
  const char *v6; // r15
  unsigned __int8 *v7; // rbp
  __int64 v8; // rbx
  unsigned int v9; // er13
  const unsigned __int16 *i; // rsi
  char v11; // dl
  signed int v12; // er14
  const char *j; // r12
  unsigned __int64 v14; // rax
  __int16 v15; // r12
  unsigned __int8 *v16; // rax
  unsigned __int8 *v17; // rdx
  unsigned __int64 v18; // rax
  char v19; // dl
  const unsigned __int16 **v21; // [rsp+8h] [rbp-80h]
  unsigned __int16 *v22; // [rsp+20h] [rbp-68h]
  __int16 *v23; // [rsp+28h] [rbp-60h]
  unsigned __int16 *v24; // [rsp+30h] [rbp-58h]
  _WORD *v25; // [rsp+38h] [rbp-50h]
  char *v26; // [rsp+40h] [rbp-48h]
  unsigned __int64 v27; // [rsp+48h] [rbp-40h]

  v6 = a6;
  v7 = 0LL;
  v8 = 0LL;
  v22 = a2;
  v23 = a3;
  v24 = a4;
  v25 = a5;
  v26 = (char *)a6;
  v27 = __readfsqword(0x28u);
  v21 = __ctype_b_loc();
  while ( 1 )
  {
    v9 = v8;
    i = *v21;
    while ( 1 )
    {
      v11 = *v6;
      if ( *v6 != 44 && !(i[v11] & 0x2000) )
        break;
      ++v6;
    }
    v12 = 0;
    if ( v11 == 45 )
      goto LABEL_7;
    v18 = strtol(v6, &v26, 0);
    if ( v26 == v6 || v18 > 0xFFFF )
      break;
    v19 = *v26;
    v15 = v18;
    v6 = v26;
    for ( i = *v21; i[*v6] & 0x2000; v19 = *++v6 )
      ;
    v12 = v18;
    if ( v19 == 44 || !v19 )
      goto LABEL_13;
    if ( v19 != 45 )
      break;
LABEL_7:
    for ( j = v6 + 1; i[*j] & 0x2000; ++j )
      ;
    v14 = strtol(j, &v26, 0);
    v6 = v26;
    if ( j == v26 )
    {
      if ( *j != 44 && *j )
        break;
      v6 = j;
      v15 = v12;
      LOWORD(v12) = -1;
    }
    else
    {
      if ( v14 > 0xFFFF )
        break;
      v15 = v14;
      if ( a1 > 0 || v12 <= (signed int)v14 )
      {
        v15 = v12;
        LOWORD(v12) = v14;
      }
    }
LABEL_13:
    v16 = (unsigned __int8 *)realloc(v7, 4 * ++v8);
    if ( !v16 )
    {
      v9 = 0;
      free(v7);
      return v9;
    }
    v17 = &v16[4 * v8 - 4];
    v7 = v16;
    *v17 = HIBYTE(v15);
    v17[1] = v15;
    v17[3] = v12;
    v17[2] = BYTE1(v12);
  }
  if ( v7 )
  {
    if ( a1 )
    {
      if ( (_DWORD)v8 )
      {
        v9 = a1;
        *v22 = v7[1];
        *v24 = v7[3];
        *v23 = *v7;
        *v25 = v7[2];
      }
    }
    else if ( (_DWORD)v8 )
    {
      v9 = 0;
      sub_10D90(v22, v23, v24, v25, v7, v8);
    }
    free(v7);
  }
  else
  {
    v9 = 0;
  }
  return v9;
}

//----- (0000000000011180) ----------------------------------------------------
__int64 __fastcall sub_11180(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  unsigned int v6; // er15
  _DWORD *v7; // rbx
  signed __int64 v8; // r12
  unsigned int v9; // er13
  __int64 v10; // r14
  signed __int64 v11; // ST20_8
  signed __int64 v12; // ST18_8
  __int64 result; // rax
  int v14; // edx
  __int16 v15; // dx
  char v16; // [rsp+24h] [rbp-44h]
  unsigned __int64 v17; // [rsp+28h] [rbp-40h]

  v6 = a5;
  v7 = a6;
  v8 = (signed __int64)(a6 + 1);
  v9 = a4;
  v10 = a3;
  v11 = (signed __int64)(a6 + 3);
  v17 = __readfsqword(0x28u);
  v12 = (signed __int64)(a6 + 2);
  FontDefaultFormat(a6, a6 + 1, a6 + 2, a6 + 3);
  result = CheckFSFormat(v9, v6, v7, v8, v11, v12, &v16);
  if ( (_DWORD)result == 85 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 0;
      *(_BYTE *)(a2 + 96) = *v7;
      *(_BYTE *)(a2 + 97) = v7[1];
      *(_BYTE *)(a2 + 98) = v7[2];
      v14 = v7[3];
      *(_QWORD *)(a2 + 112) = sub_14250;
      *(_QWORD *)(a2 + 104) = sub_145E0;
      *(_DWORD *)(a2 + 100) = v9;
      *(_BYTE *)(a2 + 99) = v14;
      *(_QWORD *)(a2 + 128) = 0LL;
      *(_QWORD *)(a2 + 120) = sub_12690;
      *(_QWORD *)(a2 + 136) = a1;
      *(_QWORD *)(a2 + 144) = 0LL;
      *(_QWORD *)(a2 + 152) = 0LL;
      *(_QWORD *)(a2 + 160) = 0LL;
    }
    *(_DWORD *)(v10 + 12) = 0;
    *(_WORD *)(v10 + 8) = 0;
    *(_BYTE *)(v10 + 10) = *(_BYTE *)(v10 + 10) & 0x80 | 0x30;
    v15 = *(_WORD *)(v10 + 10) & 0xFE7F;
    *(_WORD *)(v10 + 10) = v15;
    *(_BYTE *)(v10 + 11) = (HIBYTE(v15) | 2) & 0xFB;
  }
  return result;
}
// 8630: using guessed type __int64 __fastcall FontDefaultFormat(_QWORD, _QWORD, _QWORD, _QWORD);
// 8EB0: using guessed type __int64 __fastcall CheckFSFormat(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011300) ----------------------------------------------------
void __fastcall sub_11300(void *ptr)
{
  int v1; // eax
  signed __int64 v2; // rcx
  int v3; // edx
  __int64 v4; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rax
  _QWORD *v7; // rdx

  v1 = **(unsigned __int8 **)ptr;
  if ( (_BYTE)v1 )
  {
    v2 = *(_QWORD *)ptr + 1LL;
    v3 = 0;
    do
    {
      ++v2;
      v3 = v1 + __ROL4__(v3, 5);
      v1 = *(unsigned __int8 *)(v2 - 1);
    }
    while ( (_BYTE)v1 );
    LODWORD(v4) = v3 & 0x1F;
  }
  else
  {
    LODWORD(v4) = 0;
  }
  v4 = (signed int)v4;
  v5 = (_QWORD *)qword_23CB80[(signed int)v4];
  if ( ptr == v5 )
  {
    qword_23CB80[v4] = *((_QWORD *)ptr + 5);
    goto LABEL_13;
  }
  if ( !v5 )
    goto LABEL_12;
  v6 = (_QWORD *)v5[5];
  if ( ptr != v6 )
  {
    while ( v6 )
    {
      v7 = (_QWORD *)v6[5];
      if ( ptr == v7 )
        goto LABEL_14;
      v6 = (_QWORD *)v6[5];
    }
LABEL_12:
    ErrorF("FreeType: freeing unknown face\n");
    goto LABEL_13;
  }
  v7 = ptr;
  v6 = v5;
LABEL_14:
  v6[5] = v7[5];
LABEL_13:
  FT_Done_Face(*((_QWORD *)ptr + 1));
  free(*(void **)ptr);
  free(ptr);
}
// 83D0: using guessed type __int64 __fastcall FT_Done_Face(_QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);

//----- (00000000000113D0) ----------------------------------------------------
void __fastcall sub_113D0(void *ptr)
{
  _QWORD *v1; // r12
  _QWORD *v2; // rbp
  int v3; // eax
  bool v4; // zf
  void *v5; // rdi
  void *v6; // rdi
  _QWORD *v7; // rdx
  _QWORD *v8; // rax
  void *v9; // rdi
  void *v10; // rdi
  _QWORD *v11; // rcx
  int v12; // eax
  int v13; // edx
  __int64 v14; // r13
  char *v15; // rdi
  signed __int64 v16; // r14
  __int64 v17; // rbx
  signed __int64 v18; // rax
  _QWORD *v19; // rcx
  int v20; // eax
  int v21; // edx
  __int64 v22; // rbx
  void *v23; // rdi

  v1 = ptr;
  v2 = *(_QWORD **)ptr;
  if ( *(_QWORD *)ptr )
  {
    if ( v2 == *(_QWORD **)(*v2 + 32LL) )
      *(_QWORD *)(*v2 + 32LL) = 0LL;
    v3 = *((_DWORD *)v2 + 84) - 1;
    v4 = *((_DWORD *)v2 + 84) == 1;
    *((_DWORD *)v2 + 84) = v3;
    if ( v3 < 0 || v4 )
    {
      v7 = *(_QWORD **)(*v2 + 24LL);
      if ( v2 == v7 )
      {
        *(_QWORD *)(*v2 + 24LL) = v2[43];
      }
      else if ( v7 )
      {
        v8 = (_QWORD *)v7[43];
        if ( v2 == v8 )
        {
          v8 = *(_QWORD **)(*v2 + 24LL);
LABEL_46:
          v8[43] = v2[43];
        }
        else
        {
          while ( v8 )
          {
            if ( v2 == (_QWORD *)v8[43] )
              goto LABEL_46;
            v8 = (_QWORD *)v8[43];
          }
        }
      }
      FT_Done_Size(v2[1]);
      if ( !*(_QWORD *)(*v2 + 24LL) )
        sub_11300((void *)*v2);
      v9 = (void *)v2[15];
      if ( v9 )
        free(v9);
      v10 = (void *)v2[19];
      if ( v10 )
        free(v10);
      v11 = (_QWORD *)v2[23];
      if ( v11 )
      {
        v12 = *((_DWORD *)v2 + 44);
        v13 = *((_DWORD *)v2 + 44) + 15;
        if ( v13 >= 0 && v13 >> 4 )
        {
          v14 = 0LL;
          do
          {
            v15 = (char *)v11[v14];
            v16 = 8 * v14;
            if ( v15 )
            {
              v17 = 0LL;
              do
              {
                while ( *(_DWORD *)(*(_QWORD *)(v2[24] + v16) + v17) != 3 )
                {
                  v17 += 4LL;
                  if ( v17 == 64 )
                    goto LABEL_32;
                }
                v18 = 3 * v17;
                v17 += 4LL;
                free(*(void **)&v15[2 * v18 + 16]);
                v15 = *(char **)(v2[23] + v16);
              }
              while ( v17 != 64 );
LABEL_32:
              free(v15);
              v11 = (_QWORD *)v2[23];
              v12 = *((_DWORD *)v2 + 44);
            }
            if ( v12 + 15 < 0 )
              break;
            ++v14;
          }
          while ( (v12 + 15) >> 4 > (signed int)v14 );
        }
        free(v11);
      }
      v19 = (_QWORD *)v2[24];
      if ( v19 )
      {
        v20 = *((_DWORD *)v2 + 44);
        v21 = *((_DWORD *)v2 + 44) + 15;
        if ( v21 >= 0 && v21 >> 4 )
        {
          v22 = 0LL;
          do
          {
            v23 = (void *)v19[v22];
            if ( v23 )
            {
              free(v23);
              v19 = (_QWORD *)v2[24];
              v20 = *((_DWORD *)v2 + 44);
            }
            if ( v20 + 15 < 0 )
              break;
            ++v22;
          }
          while ( (v20 + 15) >> 4 > (signed int)v22 );
        }
        free(v19);
      }
      free(v2);
    }
  }
  v5 = (void *)v1[11];
  if ( v5 )
    free(v5);
  v6 = (void *)v1[10];
  if ( v6 )
    free(v6);
  free(v1);
}
// 8210: using guessed type __int64 __fastcall FT_Done_Size(_QWORD);

//----- (0000000000011620) ----------------------------------------------------
signed __int64 __fastcall sub_11620(int a1, char a2, unsigned int *a3, int a4, _QWORD *a5, _QWORD *a6, _DWORD *a7, int *a8, int *a9)
{
  int v9; // ebx
  unsigned int v10; // er10
  char *v11; // rax
  int v12; // er12
  signed __int64 v13; // r13
  int v14; // ebx
  char *v15; // rax
  void **v16; // r13
  signed __int64 result; // rax
  int v18; // edi
  _QWORD *v19; // ST18_8
  _QWORD *v20; // ST10_8
  unsigned int *v21; // ST08_8
  int v22; // edi
  _QWORD *v23; // ST08_8
  _QWORD *v24; // ST18_8
  _QWORD *v25; // ST10_8
  unsigned int *v26; // ST08_8
  _QWORD *v27; // ST08_8

  v9 = a1;
  v10 = *a3;
  if ( a4 >= 0 && a2 & 8 )
    v9 = a1 + (v10 >> 1);
  if ( v9 > v10 )
  {
    *a7 = 0;
    result = 85LL;
  }
  else
  {
    v11 = (char *)*a6;
    if ( !*a6 )
    {
      v18 = (signed int)(v10 + 15) < 0 ? ((signed int)(v10 + 30) >> 4) - 1 : (signed int)(v10 + 15) >> 4;
      v19 = a6;
      v20 = a5;
      v21 = a3;
      v11 = (char *)calloc(v18, 8uLL);
      a6 = v19;
      a3 = v21;
      a5 = v20;
      *v19 = v11;
      if ( !v11 )
        goto LABEL_30;
    }
    v12 = v9 < 0 ? ((v9 + 15) >> 4) - 1 : v9 >> 4;
    v13 = 8LL * v12;
    v14 = v9 - 16 * v12;
    if ( !*(_QWORD *)&v11[v13] )
    {
      v24 = a6;
      v25 = a5;
      v26 = a3;
      *(_QWORD *)&v11[v13] = calloc(0x10uLL, 8uLL);
      a3 = v26;
      a5 = v25;
      if ( !*(_QWORD *)(*v24 + 8LL * v12) )
        goto LABEL_30;
    }
    v15 = (char *)*a5;
    if ( !*a5 )
    {
      v22 = (signed int)(*a3 + 15) < 0 ? ((signed int)(*a3 + 30) >> 4) - 1 : (signed int)(*a3 + 15) >> 4;
      v23 = a5;
      v15 = (char *)calloc(v22, 8uLL);
      a5 = v23;
      *v23 = v15;
      if ( !v15 )
        goto LABEL_30;
    }
    v16 = (void **)&v15[v13];
    if ( *v16 || (v27 = a5, *v16 = malloc(0x180uLL), *(_QWORD *)(*v27 + 8LL * v12)) )
    {
      *a7 = 1;
      *a8 = v12;
      *a9 = v14;
      result = 85LL;
    }
    else
    {
LABEL_30:
      result = 80LL;
    }
  }
  return result;
}

//----- (0000000000011840) ----------------------------------------------------
__int64 __fastcall sub_11840(__int64 a1)
{
  unsigned int v1; // eax
  unsigned int v2; // ebp
  __int64 v3; // rsi
  __int64 result; // rax
  signed __int64 v5; // rsi

  if ( *(_QWORD *)(*(_QWORD *)a1 + 32LL) == a1 )
    return 85LL;
  v1 = FT_Activate_Size(*(_QWORD *)(a1 + 8));
  v2 = v1;
  if ( v1 )
  {
    v3 = v1;
    *(_QWORD *)(*(_QWORD *)a1 + 32LL) = 0LL;
    ErrorF("FreeType: couldn't activate instance: %d\n");
    result = FTtoXReturnCode(v2, v3);
  }
  else
  {
    v5 = 0LL;
    if ( *(_DWORD *)(a1 + 24) )
      v5 = a1 + 32;
    FT_Set_Transform(*(_QWORD *)(*(_QWORD *)a1 + 8LL), v5, 0LL);
    *(_QWORD *)(*(_QWORD *)a1 + 32LL) = a1;
    result = 85LL;
  }
  return result;
}
// 84F0: using guessed type __int64 __fastcall FT_Activate_Size(_QWORD);
// 8530: using guessed type __int64 __fastcall FTtoXReturnCode(_QWORD, _QWORD);
// 8D40: using guessed type __int64 __fastcall FT_Set_Transform(_QWORD, _QWORD, _QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);

//----- (00000000000118D0) ----------------------------------------------------
__int64 __fastcall sub_118D0(__int64 a1, _WORD *a2, __int64 a3, const char *a4, __int64 a5, __int64 a6, const __m128i *a7, int a8, unsigned __int64 *a9, const char *a10, int a11)
{
  __int64 v11; // r15
  _WORD *v12; // r13
  __int64 v13; // r12
  __int64 v14; // rbx
  const char *v15; // rbp
  double v16; // xmm1_8
  double v17; // xmm0_8
  __int64 v18; // ST10_8
  double v19; // xmm0_8
  double v20; // xmm6_8
  double v21; // xmm0_8
  __int64 v22; // r9
  double v23; // xmm4_8
  double v24; // xmm3_8
  double v25; // xmm1_8
  __int16 v26; // r11
  __int64 v27; // rcx
  __int64 result; // rax
  double v29; // xmm0_8
  __int64 v30; // rsi
  _BYTE *v31; // rdi
  int v32; // eax
  __int64 v33; // rax
  _DWORD *v34; // rax
  int v35; // er15
  signed __int64 v36; // rax
  signed __int64 v37; // rax
  _WORD *v38; // r11
  unsigned __int16 *v39; // r10
  int v40; // er9
  __int64 v41; // rax
  double v42; // rdx
  __int64 v43; // rax
  __int64 v44; // r13
  __int64 v45; // rax
  unsigned __int64 v46; // rdx
  _BYTE *v47; // rax
  int v48; // er8
  char v49; // dl
  __int64 v50; // ST40_8
  int v51; // eax
  _QWORD *v52; // rbp
  int v53; // ecx
  __int64 v54; // rdi
  __int64 v55; // rax
  unsigned __int64 v56; // rdx
  __m128i v57; // xmm0
  unsigned int v58; // eax
  unsigned int v59; // er13
  __int64 v60; // rsi
  unsigned int v61; // er13
  void *v62; // rax
  signed __int64 v63; // rax
  unsigned __int8 v64; // cl
  signed __int64 v65; // rdx
  signed __int64 v66; // rdx
  signed __int64 v67; // rdx
  __int16 v68; // si
  signed __int64 v69; // rdx
  signed __int16 v70; // cx
  __int64 v71; // rsi
  signed int v72; // er13
  __int64 v73; // rax
  int v74; // er8
  __int64 v75; // r10
  signed __int64 v76; // r9
  signed int v77; // er11
  signed __int16 *v78; // rcx
  int v79; // eax
  int v80; // edx
  int v81; // edx
  signed __int16 *v82; // r9
  __int64 v83; // r8
  __int64 v84; // r10
  signed __int64 v85; // r9
  signed __int64 v86; // rax
  signed __int64 v87; // r9
  signed __int128 v88; // ax
  unsigned __int64 v89; // rsi
  unsigned __int64 v90; // rdi
  int v91; // eax
  __int64 v92; // rcx
  _QWORD *v93; // rdx
  __int64 v94; // rax
  double v95; // [rsp+8h] [rbp-E0h]
  signed int v96; // [rsp+10h] [rbp-D8h]
  signed int v97; // [rsp+1Ch] [rbp-CCh]
  signed int v98; // [rsp+20h] [rbp-C8h]
  signed int v99; // [rsp+24h] [rbp-C4h]
  __int64 v100; // [rsp+38h] [rbp-B0h]
  signed __int64 v101; // [rsp+40h] [rbp-A8h]
  __int64 v102; // [rsp+48h] [rbp-A0h]
  __int64 v103; // [rsp+50h] [rbp-98h]
  __int64 v104; // [rsp+58h] [rbp-90h]
  char v105; // [rsp+70h] [rbp-78h]
  unsigned __int64 v106; // [rsp+A0h] [rbp-48h]
  unsigned __int64 v107; // [rsp+A8h] [rbp-40h]

  v11 = a5;
  v12 = a2;
  v13 = a3;
  v14 = a1;
  v15 = a4;
  v16 = *(double *)(a5 + 64);
  v17 = *(double *)(a5 + 56);
  v18 = a6;
  v107 = __readfsqword(0x28u);
  v99 = *(_DWORD *)(a5 + 80);
  v98 = *(_DWORD *)(a5 + 84);
  v19 = hypot(v17, v16);
  v20 = v19;
  v95 = v19;
  v21 = *(double *)(v11 + 40);
  v22 = v18;
  v23 = *(double *)(v11 + 64);
  if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v21 - v23) & xmmword_30160) < COERCE_DOUBLE(*(_QWORD *)(v11 + 40) & xmmword_30160)
                                                                       * 0.001 )
  {
    v96 = 0;
    v29 = (v21 + v23) * 0.5 * 65536.0 / v95;
    v100 = (unsigned int)(signed int)v29;
    v103 = (unsigned int)(signed int)v29;
  }
  else
  {
    v96 = 1;
    v100 = (signed int)(v21 * 65536.0 / v20);
    v103 = (signed int)(v23 * 65536.0 / v20);
  }
  v24 = 0.001 * v95;
  if ( COERCE_DOUBLE(*(_QWORD *)(v11 + 48) & xmmword_30160) < 0.001 * v95 )
  {
    v25 = *(double *)(v11 + 56);
    v102 = 0LL;
    if ( COERCE_DOUBLE(xmmword_30160 & *(_QWORD *)&v25) < v24 )
      goto LABEL_5;
  }
  else
  {
    v96 = 1;
    v25 = *(double *)(v11 + 56);
    v102 = (signed int)(*(double *)(v11 + 48) * 65536.0 / v95);
    if ( COERCE_DOUBLE(xmmword_30160 & *(_QWORD *)&v25) < v24 )
    {
LABEL_5:
      v104 = 0LL;
      goto LABEL_6;
    }
  }
  v96 = 1;
  v104 = (signed int)(v25 * 65536.0 / v95);
LABEL_6:
  v26 = *(_WORD *)(v22 + 10);
  v27 = *(_QWORD *)(v13 + 8);
  if ( v26 == 14 )
  {
    v31 = *(_BYTE **)v22;
    v46 = *(_QWORD *)v22 + *(signed __int16 *)(v22 + 8) - 2LL;
    v30 = *(signed __int16 *)(v22 + 8);
    if ( v46 >= *(_QWORD *)v22 )
    {
      v47 = *(_BYTE **)v22;
      v48 = 0;
      while ( *v47 != 45 || ++v48 != 11 )
      {
        if ( v46 < (unsigned __int64)++v47 )
          goto LABEL_81;
      }
      v49 = v47[1];
      if ( v49 == 99 )
      {
        if ( v47[2] == 45 )
        {
          if ( !a11 )
            goto LABEL_125;
          goto LABEL_82;
        }
      }
      else if ( v49 == 109 && v47[2] == 45 )
      {
        if ( !a11 )
          goto LABEL_121;
LABEL_82:
        if ( a11 != 99 )
        {
          if ( a11 != 109 )
          {
            v97 = 1;
            if ( *(_BYTE *)(v27 + 16) & 4 )
              goto LABEL_9;
LABEL_85:
            v50 = v22;
            v51 = FT_Get_PS_Font_Info(v27, &v105);
            v22 = v50;
            v26 = *(_WORD *)(v50 + 10);
            if ( v51 || !(_BYTE)v106 )
              v97 = 0;
            goto LABEL_9;
          }
LABEL_121:
          v97 = 1;
          goto LABEL_19;
        }
LABEL_125:
        v97 = 2;
        goto LABEL_19;
      }
    }
LABEL_81:
    if ( !a11 )
      goto LABEL_8;
    goto LABEL_82;
  }
  if ( a11 )
  {
    v97 = 2;
    if ( a11 == 99 || (v97 = 1, a11 == 109) )
    {
LABEL_10:
      v101 = v14 + 8;
      result = FTPickMapping(0LL, 0LL, v15);
      if ( (_DWORD)result != 85 )
        return result;
      goto LABEL_20;
    }
  }
LABEL_8:
  v97 = 1;
  if ( !(*(_BYTE *)(v27 + 16) & 4) )
    goto LABEL_85;
LABEL_9:
  if ( v26 != 14 )
    goto LABEL_10;
  v30 = (unsigned int)*(signed __int16 *)(v22 + 8);
  v31 = *(_BYTE **)v22;
LABEL_19:
  v101 = v14 + 8;
  result = FTPickMapping(v31, v30, v15);
  if ( (_DWORD)result != 85 )
    return result;
LABEL_20:
  v32 = *(_DWORD *)(v11 + 104);
  *(_QWORD *)(v14 + 88) = 0LL;
  *(_DWORD *)(v14 + 56) = v32;
  if ( v32 )
  {
    v62 = malloc(4LL * *(signed int *)(v11 + 104));
    *(_QWORD *)(v14 + 88) = v62;
    if ( !v62 )
      return 80LL;
    memcpy(v62, *(const void **)(v11 + 112), 4LL * *(signed int *)(v11 + 104));
  }
  if ( !v12 )
  {
    *(_QWORD *)(v14 + 48) = 0LL;
    goto LABEL_34;
  }
  v33 = *(_QWORD *)(v14 + 32);
  if ( !v33 )
  {
    *((_DWORD *)v12 + 1) = 0;
    v35 = 0;
    *v12 = 0;
    LOBYTE(v63) = -1;
LABEL_117:
    v70 = (unsigned __int8)v63;
LABEL_112:
    v12[1] = v70;
    goto LABEL_29;
  }
  v34 = *(_DWORD **)(v33 + 48);
  v35 = v34[10];
  if ( !v34[5] )
  {
    v63 = v34[4] - 1;
    if ( v63 > 0xFFFF )
      v63 = 0xFFFFLL;
    if ( v35 )
    {
      v64 = v35;
      v65 = v35 + 255LL;
      if ( v35 >= 0LL )
        v65 = v35;
      v66 = v65 >> 8;
      v35 = -(v35 != 0LL);
    }
    else
    {
      v64 = 0;
      LOWORD(v66) = 0;
    }
    v12[2] = v66;
    v67 = v63 + 255;
    if ( v63 >= 0 )
      v67 = v63;
    v68 = 0;
    v69 = v67 >> 8;
    v12[3] = v69;
    if ( !*((_DWORD *)v12 + 1) )
      v68 = v64;
    *v12 = v68;
    v70 = 255;
    if ( (_WORD)v69 )
      goto LABEL_112;
    goto LABEL_117;
  }
  v12[2] = v35;
  v36 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 32) + 48LL) + 16LL) - 1;
  if ( v36 > 255 )
    LOWORD(v36) = 255;
  v12[3] = v36;
  *v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 32) + 48LL) + 44LL);
  v37 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 32) + 48LL) + 20LL) - 1;
  if ( v37 > 255 )
    LOWORD(v37) = 255;
  v12[1] = v37;
  v35 = -((*(_QWORD *)v12 & 0xFFFF0000FFFFLL) != 0);
LABEL_29:
  v38 = v12 + 3;
  v39 = v12 + 1;
  if ( a10 )
  {
    sub_10EE0(0, v12, v12 + 2, v12 + 1, v12 + 3, a10);
    v38 = v12 + 3;
    v39 = v12 + 1;
  }
  v40 = *(_DWORD *)(v14 + 56);
  if ( v40 )
    sub_10D90(v12, v12 + 2, v39, v38, *(unsigned __int8 **)(v14 + 88), v40);
  *(_QWORD *)(v14 + 48) = v12;
  if ( v35 != -1 )
  {
    *(_DWORD *)(v14 + 40) = FTRemap(*(_QWORD *)(v13 + 8), v101, 0LL);
    goto LABEL_35;
  }
LABEL_34:
  *(_DWORD *)(v14 + 40) = 0;
LABEL_35:
  v41 = FT_Get_Sfnt_Table(*(_QWORD *)(v13 + 8), 5LL);
  v42 = *(double *)a9;
  if ( !(*a9 & 0x20) && (unsigned __int16)v12[3] + 1 - (unsigned __int16)v12[2] > 1 && v41 )
    *(_QWORD *)&v42 |= 0x10uLL;
  *a9 = *(_QWORD *)&v42 & 0xFFFFFFFFFFFFFFDFLL;
  if ( !*(_DWORD *)(v13 + 16) && v97 != 2 || (*a9 = *(_QWORD *)&v42 & 0xFFFFFFFFFFFFFFCFLL, !*(_DWORD *)(v13 + 16)) )
  {
    if ( !(*(_BYTE *)(*(_QWORD *)(v13 + 8) + 16LL) & 8) )
      *a9 &= 0xFFFFFFFFFFFFFFEFLL;
  }
  if ( v41 )
  {
    v43 = *(_QWORD *)(v41 + 8);
    if ( v43 )
      a9[15] = COERCE_UNSIGNED_INT64(sin((double)(signed int)v43 * 0.0009765625 / 5760.0 * 1.570796326794897)) ^ xmmword_30670;
  }
  v44 = *(_QWORD *)(v13 + 24);
  if ( v44 )
  {
    while ( 1 )
    {
      if ( !strcmp(**(const char ***)v44, v15) && v95 == *(double *)(v44 + 16) )
      {
        v45 = *(_QWORD *)(v44 + 64);
        v106 = __PAIR__(v98, v99);
        if ( v45 == __PAIR__(v98, v99)
          && *(_DWORD *)(v44 + 24) == v96
          && (!v96
           || *(_QWORD *)(v44 + 32) == v100
           && v102 == *(_QWORD *)(v44 + 48)
           && v103 == *(_QWORD *)(v44 + 56)
           && v104 == *(_QWORD *)(v44 + 40))
          && *(_DWORD *)(v44 + 88) == v97
          && a8 == *(_DWORD *)(v44 + 72)
          && *(_DWORD *)(v44 + 160) == LODWORD(a7->m128i_i64[0])
          && *(_DWORD *)(v44 + 164) == HIDWORD(a7->m128i_i64[0])
          && *(_DWORD *)(v44 + 168) == LODWORD(a7->m128i_i64[1])
          && *(double *)(v44 + 208) == *((double *)a9 + 1)
          && *(double *)(v44 + 216) == *((double *)a9 + 2)
          && *(double *)(v44 + 224) == *((double *)a9 + 3)
          && *(double *)(v44 + 232) == *((double *)a9 + 4)
          && *(_QWORD *)(v44 + 240) == a9[5]
          && *(_QWORD *)(v44 + 248) == a9[6]
          && *(_QWORD *)(v44 + 200) == *a9
          && *(double *)(v44 + 256) == *((double *)a9 + 7)
          && *(_DWORD *)(v44 + 268) < 0
          && *((_DWORD *)a9 + 17) < 0 )
        {
          break;
        }
      }
      v44 = *(_QWORD *)(v44 + 344);
      if ( !v44 )
        goto LABEL_90;
    }
    ++*(_DWORD *)(v44 + 336);
    result = 85LL;
    *(_QWORD *)v14 = v44;
    return result;
  }
LABEL_90:
  v52 = malloc(0x160uLL);
  if ( !v52 )
    return 80LL;
  *((_DWORD *)v52 + 84) = 1;
  *v52 = v13;
  v52[12] = 0LL;
  v52[13] = 0LL;
  *((double *)v52 + 2) = v95;
  *((_DWORD *)v52 + 18) = a8;
  v52[14] = 0LL;
  v52[15] = 0LL;
  *((_DWORD *)v52 + 32) = 0;
  *((_DWORD *)v52 + 22) = v97;
  v52[17] = 0LL;
  v52[19] = 0LL;
  *((_DWORD *)v52 + 6) = v96;
  v52[4] = v100;
  v52[5] = v104;
  v52[6] = v102;
  v52[7] = v103;
  *((_DWORD *)v52 + 16) = v99;
  *((_DWORD *)v52 + 17) = v98;
  *((__m128i *)v52 + 10) = _mm_load_si128(a7);
  v52[23] = 0LL;
  v53 = *((_DWORD *)a9 + 17);
  v52[24] = 0LL;
  v54 = *(_QWORD *)(v13 + 8);
  if ( v53 < 0 )
    v55 = *(_QWORD *)(v54 + 32);
  else
    LODWORD(v55) = 2 * *(_DWORD *)(v54 + 32);
  *((_DWORD *)v52 + 44) = v55;
  v56 = a9[16];
  *(__m128i *)(v52 + 25) = _mm_load_si128((const __m128i *)a9);
  v57 = _mm_load_si128((const __m128i *)a9 + 1);
  v52[41] = v56;
  *(__m128i *)(v52 + 27) = v57;
  *(__m128i *)(v52 + 29) = _mm_load_si128((const __m128i *)a9 + 2);
  *(__m128i *)(v52 + 31) = _mm_load_si128((const __m128i *)a9 + 3);
  *(__m128i *)(v52 + 33) = _mm_load_si128((const __m128i *)a9 + 4);
  *(__m128i *)(v52 + 35) = _mm_load_si128((const __m128i *)a9 + 5);
  *(__m128i *)(v52 + 37) = _mm_load_si128((const __m128i *)a9 + 6);
  *(__m128i *)(v52 + 39) = _mm_load_si128((const __m128i *)a9 + 7);
  v58 = FT_New_Size(v54, v52 + 1);
  v59 = v58;
  if ( v58 )
  {
    v71 = v58;
    ErrorF("FreeType: couldn't create size object: %d\n");
    free(v52);
    return FTtoXReturnCode(v59, v71);
  }
  sub_11840((__int64)v52);
  if ( *(_DWORD *)(v13 + 16) )
  {
    v72 = v96;
    if ( v96 )
      goto LABEL_154;
    v73 = *(_QWORD *)(v13 + 8);
    v74 = *(_DWORD *)(v73 + 56);
    if ( v74 <= 0 )
      goto LABEL_154;
    v75 = *(_QWORD *)(v73 + 64);
    v76 = -1LL;
    v77 = 100;
    v78 = *(signed __int16 **)(v73 + 64);
    do
    {
      v79 = v78[1] - (signed int)((double)v99 * v95 / 72.0 + 0.5);
      if ( (unsigned int)(v79 + 1) <= 2 )
      {
        v80 = *v78 - (signed int)((double)v98 * v95 / 72.0 + 0.5);
        if ( (unsigned int)(v80 + 1) <= 2 )
        {
          v81 = v79 * v79 + v80 * v80;
          if ( v81 < v77 )
          {
            v77 = v81;
            v76 = v72;
          }
        }
      }
      ++v72;
      v78 += 16;
    }
    while ( v74 != v72 );
    if ( (_DWORD)v76 == -1 )
    {
LABEL_154:
      free(v52);
      return 83LL;
    }
    v82 = (signed __int16 *)(v75 + 32 * v76);
    v60 = (unsigned int)v82[1];
    v61 = FT_Set_Pixel_Sizes(*(_QWORD *)(*v52 + 8LL), v60, (unsigned int)*v82);
  }
  else
  {
    v60 = (signed int)(v95 * 64.0 + 0.5);
    v61 = FT_Set_Char_Size(*(_QWORD *)(*v52 + 8LL), v60, v60, (unsigned int)v99, (unsigned int)v98);
  }
  if ( v61 )
  {
    FT_Done_Size(v52[1]);
    free(v52);
    result = FTtoXReturnCode(v61, v60);
  }
  else
  {
    v83 = *(_QWORD *)(v13 + 8);
    if ( *(_BYTE *)(v83 + 16) & 8 )
    {
      v52[10] = 0xFFFFLL;
      v84 = (unsigned int)(signed int)(v95 * 64.0 + 0.5);
      v85 = v84 * v98 + 36;
      v86 = v85;
      v87 = v85 >> 63;
      v88 = 1024819115206086201LL * (signed __int128)v86;
      v89 = ((*((_QWORD *)&v88 + 1) >> 2) - v87 + 32) & 0xFFFFFFFFFFFFFFC0LL;
      v90 = (((signed __int64)((unsigned __int128)(1024819115206086201LL * (signed __int128)(v84 * v99 + 36)) >> 64) >> 2)
           - ((v84 * v99 + 36) >> 63)
           + 32) & 0xFFFFFFFFFFFFFFC0LL;
      if ( !v90 || v89 )
      {
        if ( !v90 && v89 )
          v90 = ((*((_QWORD *)&v88 + 1) >> 2) - v87 + 32) & 0xFFFFFFFFFFFFFFC0LL;
      }
      else
      {
        v89 = (((signed __int64)((unsigned __int128)(1024819115206086201LL * (signed __int128)(v84 * v99 + 36)) >> 64) >> 2)
             - ((v84 * v99 + 36) >> 63)
             + 32) & 0xFFFFFFFFFFFFFFC0LL;
      }
      v91 = *(_DWORD *)(v83 + 56);
      if ( v91 )
      {
        v92 = 0LL;
        v93 = (_QWORD *)(*(_QWORD *)(v83 + 64) + 16LL);
        while ( ((*v93 + 32LL) & 0xFFFFFFFFFFFFFFC0LL) != v90 || ((v93[1] + 32LL) & 0xFFFFFFFFFFFFFFC0LL) != v89 )
        {
          ++v92;
          v93 += 4;
          if ( (unsigned int)(v91 - 1) + 1LL == v92 )
            goto LABEL_146;
        }
        v52[10] = v92;
      }
    }
LABEL_146:
    v94 = *v52;
    v52[43] = *(_QWORD *)(*v52 + 24LL);
    *(_QWORD *)(v94 + 24) = v52;
    result = 85LL;
    *(_QWORD *)v14 = v52;
  }
  return result;
}
// 81F0: using guessed type __int64 __fastcall FT_Set_Pixel_Sizes(_QWORD, _QWORD, _QWORD);
// 8200: using guessed type __int64 __fastcall FT_New_Size(_QWORD, _QWORD);
// 8210: using guessed type __int64 __fastcall FT_Done_Size(_QWORD);
// 8530: using guessed type __int64 __fastcall FTtoXReturnCode(_QWORD, _QWORD);
// 86E0: using guessed type __int64 __fastcall FT_Get_PS_Font_Info(_QWORD, _QWORD);
// 87C0: using guessed type __int64 __fastcall FT_Get_Sfnt_Table(_QWORD, _QWORD);
// 8A80: using guessed type __int64 __fastcall FTRemap(_QWORD, _QWORD, _QWORD);
// 8AA0: using guessed type __int64 __fastcall FTPickMapping(_QWORD, _QWORD, _QWORD);
// 8EC0: using guessed type __int64 __fastcall FT_Set_Char_Size(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);
// 30160: using guessed type __int128 xmmword_30160;
// 30670: using guessed type __int128 xmmword_30670;

//----- (0000000000012690) ----------------------------------------------------
void __fastcall sub_12690(FontPtr font)
{
  FontPtr v1; // rbx
  pointer v2; // rdi

  if ( font )
  {
    v1 = font;
    v2 = font->fontPrivate;
    if ( v2 )
      sub_113D0(v2);
    if ( v1->info.nprops > 0 )
    {
      free(v1->info.isStringProp);
      free(v1->info.props);
    }
    DestroyFontRec(v1);
  }
}

//----- (00000000000126F0) ----------------------------------------------------
signed __int64 __fastcall sub_126F0(unsigned int a1, __int64 a2, _DWORD *a3)
{
  unsigned __int16 *v3; // rax
  signed __int64 result; // rax

  v3 = *(unsigned __int16 **)(a2 + 48);
  if ( v3
    && (*v3 > (unsigned int)(unsigned __int8)a1
     || (unsigned __int8)a1 > (unsigned int)v3[1]
     || v3[2] > a1 >> 8
     || a1 >> 8 > v3[3]) )
  {
    *a3 = *(_DWORD *)(a2 + 40);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    *a3 = FTRemap(*(_QWORD *)(**(_QWORD **)a2 + 8LL), a2 + 8, a1);
    result = 0LL;
  }
  return result;
}
// 8A80: using guessed type __int64 __fastcall FTRemap(_QWORD, _QWORD, _QWORD);

//----- (0000000000012760) ----------------------------------------------------
__int64 __fastcall sub_12760(__int64 a1, __int64 a2, unsigned __int16 a3, __m128i *a4)
{
  __int64 v4; // rax
  signed __int64 v5; // rsi
  unsigned __int16 v6; // r12
  __int64 v7; // rax
  __m128i *v8; // rbx
  signed __int64 v9; // rdx
  signed __int64 v10; // rax
  signed __int64 v11; // rdx
  signed __int64 v12; // rsi
  __int64 result; // rax
  const __m128i *v14; // rdx

  if ( a2 == 0xFFFF )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 64);
  if ( !v4 )
    return 0xFFFFFFFFLL;
  v5 = v4 + 32 * a2;
  v6 = a3;
  v7 = *(_QWORD *)(v5 + 24);
  v8 = a4;
  v9 = v7 + 63;
  if ( v7 >= 0 )
    v9 = *(_QWORD *)(v5 + 24);
  v10 = *(_QWORD *)(v5 + 16);
  v11 = v9 >> 6;
  v12 = v10 + 63;
  if ( v10 >= 0 )
    v12 = v10;
  if ( (unsigned int)FT_Set_Pixel_Sizes(a1, v12 >> 6, v11) )
    return 0xFFFFFFFFLL;
  result = FT_Load_Glyph(a1, v6, 0x4000LL);
  if ( (_DWORD)result )
    return 0xFFFFFFFFLL;
  if ( v8 )
  {
    v14 = *(const __m128i **)(a1 + 152);
    *v8 = _mm_loadu_si128(v14 + 3);
    v8[1] = _mm_loadu_si128(v14 + 4);
    v8[2] = _mm_loadu_si128(v14 + 5);
    v8[3] = _mm_loadu_si128(v14 + 6);
  }
  return result;
}
// 80F0: using guessed type __int64 __fastcall FT_Load_Glyph(_QWORD, _QWORD, _QWORD);
// 81F0: using guessed type __int64 __fastcall FT_Set_Pixel_Sizes(_QWORD, _QWORD, _QWORD);

//----- (0000000000012830) ----------------------------------------------------
signed __int64 __fastcall sub_12830(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, signed __int64 *a6, double a7, __int64 *a8, _QWORD *a9)
{
  unsigned int v9; // er15
  __int64 v10; // r12
  __int64 v11; // rbp
  signed __int64 *v12; // r14
  int v13; // eax
  signed __int64 v14; // r15
  __int64 v15; // rdi
  __int64 v16; // rax
  __int64 v17; // rax
  double v18; // xmm0_8
  signed __int64 v19; // rax
  __int64 v20; // rsi
  __int64 v21; // rcx
  signed __int64 v22; // rdx
  __int64 v23; // rdi
  __int64 v24; // rsi
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // rax
  unsigned __int16 v29; // cx
  __int64 v30; // rdx
  unsigned __int16 v31; // ST08_2
  __int16 v32; // ax
  unsigned __int16 v33; // cx
  double v34; // xmm1_8
  double v35; // [rsp+0h] [rbp-B8h]
  __int64 v36; // [rsp+8h] [rbp-B0h]
  unsigned int v37; // [rsp+24h] [rbp-94h]
  __int64 v38; // [rsp+30h] [rbp-88h]
  __int64 v39; // [rsp+38h] [rbp-80h]
  __int64 v40; // [rsp+40h] [rbp-78h]
  __int64 v41; // [rsp+48h] [rbp-70h]
  __int64 v42; // [rsp+50h] [rbp-68h]
  __int64 v43; // [rsp+58h] [rbp-60h]
  unsigned __int64 v44; // [rsp+60h] [rbp-58h]
  __int64 v45; // [rsp+68h] [rbp-50h]
  unsigned __int64 v46; // [rsp+78h] [rbp-40h]

  v37 = a1;
  v35 = a7;
  v46 = __readfsqword(0x28u);
  if ( !(*(_BYTE *)(a2 + 16) & 8) )
    return 0xFFFFFFFFLL;
  v9 = a4;
  v10 = a3;
  v11 = a5;
  v12 = a6;
  v44 = 0LL;
  v13 = FT_Load_Sfnt_Table(a2, 1752003704LL, 0LL, 0LL, &v44);
  if ( !v9 || v13 )
  {
    v36 = 0LL;
    v15 = 0LL;
  }
  else if ( a1 >= v9 )
  {
    v15 = 0LL;
    v36 = 0LL;
    if ( 4 * (unsigned __int64)(v9 - 1) + 4 <= v44 )
    {
      v29 = sub_10D30(a2, 1752003704LL, 4LL * (v9 - 1));
      v15 = v29;
      v30 = 4LL * (v9 - 1) + 2 * (v37 - v9) + 4;
      if ( v30 + 2 <= v44 )
      {
        v31 = v29;
        v32 = sub_10D30(a2, 1752003704LL, v30);
        v33 = v31;
        v36 = v32;
        v15 = v33;
      }
    }
  }
  else
  {
    v14 = 4LL * a1;
    v15 = 0LL;
    v36 = 0LL;
    if ( 4 * (unsigned __int64)v37 + 4 <= v44 )
    {
      v15 = (unsigned __int16)sub_10D30(a2, 1752003704LL, 4LL * v37);
      v36 = (signed __int16)sub_10D30(a2, 1752003704LL, v14 + 2);
    }
  }
  v16 = FT_MulFix(v15, *(_QWORD *)(v10 + 32));
  *a8 = v16;
  v12[2] = v16;
  *v12 = FT_MulFix(v36, *(_QWORD *)(v10 + 32));
  v12[1] = FT_MulFix(*(_QWORD *)(a2 + 112), *(_QWORD *)(v10 + 40));
  v17 = FT_MulFix(*(_QWORD *)(a2 + 128), *(_QWORD *)(v10 + 40));
  v12[3] = v17;
  if ( a7 <= 0.0 )
  {
    if ( a7 < 0.0 )
    {
      v34 = (double)(signed int)*v12;
      v12[2] = (unsigned int)(signed int)((double)(signed int)v12[1] * a7 + (double)(signed int)v12[2]);
      *v12 = (unsigned int)(signed int)((double)(signed int)v17 * a7 + v34);
    }
  }
  else
  {
    v18 = (double)(signed int)v12[1] * a7 + (double)(signed int)*v12;
    v12[2] = (unsigned int)(signed int)((double)(signed int)v17 * v35 + (double)(signed int)v12[2]);
    *v12 = (unsigned int)(signed int)v18;
  }
  *a9 = -1LL;
  v42 = *v12;
  v38 = v42;
  v44 = v12[2];
  v40 = v44;
  v41 = v12[1];
  v39 = v41;
  v45 = v12[3];
  v43 = v45;
  FT_Vector_Transform(&v38, v11);
  FT_Vector_Transform(&v40, v11);
  FT_Vector_Transform(&v42, v11);
  FT_Vector_Transform(&v44, v11);
  v19 = v44;
  v20 = v40;
  v21 = v38;
  v22 = v42;
  if ( (signed __int64)v44 <= v42 )
    v22 = v44;
  if ( v22 > v40 )
    v22 = v40;
  if ( v22 > v38 )
    v22 = v38;
  if ( (signed __int64)v44 < v42 )
    v19 = v42;
  v23 = v43;
  *v12 = v22;
  if ( v19 < v20 )
    v19 = v20;
  v24 = v41;
  v25 = v23;
  if ( v19 < v21 )
    v19 = v21;
  v26 = v39;
  v12[2] = v19;
  v27 = v45;
  if ( v45 <= v23 )
    v25 = v45;
  if ( v25 > v24 )
    v25 = v24;
  if ( v25 > v26 )
    v25 = v26;
  if ( v45 < v23 )
    v27 = v23;
  v12[1] = v25;
  if ( v27 < v24 )
    v27 = v24;
  if ( v27 < v26 )
    v27 = v26;
  v12[3] = v27;
  return 0LL;
}
// 81A0: using guessed type __int64 __fastcall FT_Load_Sfnt_Table(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 88C0: using guessed type __int64 __fastcall FT_MulFix(_QWORD, _QWORD);
// 8D50: using guessed type __int64 __fastcall FT_Vector_Transform(_QWORD, _QWORD);

//----- (0000000000012C20) ----------------------------------------------------
signed __int64 __fastcall sub_12C20(unsigned int a1, char a2, signed __int16 *a3, double *a4, int a5)
{
  signed __int16 *v5; // r13
  char v6; // r12
  double *v7; // rbp
  int v8; // ebx
  __int64 v9; // r15
  _QWORD *v10; // r14
  __int64 v11; // rax
  double v12; // xmm0_8
  __int64 *v13; // rsi
  unsigned int v14; // eax
  __int64 v15; // r14
  char *v16; // r9
  __int64 v17; // rax
  __int64 v18; // r11
  double v19; // xmm6_8
  int v20; // edi
  __int64 v21; // r9
  signed __int64 v22; // rcx
  signed __int64 v23; // r8
  int v24; // eax
  signed __int64 v25; // r10
  double v26; // xmm1_8
  __int64 v27; // xmm4_8
  __m128d v28; // xmm0
  double v29; // xmm3_8
  __m128d v30; // xmm14
  signed int v31; // edx
  double v32; // xmm3_8
  int v33; // edi
  __m128d v34; // xmm0
  __m128d v35; // xmm11
  signed __int16 v36; // dx
  int v37; // er8
  int v38; // esi
  __m128d v39; // xmm0
  __m128d v40; // xmm7
  __int64 v41; // rax
  int v43; // esi
  int v44; // edi
  int v45; // er14
  int v46; // ebx
  unsigned __int8 *v47; // rax
  __int64 v48; // r8
  int v49; // er14
  __int64 v50; // rcx
  int v51; // eax
  int v52; // edi
  int v53; // er12
  int v54; // edx
  int v55; // er14
  int v56; // er15
  int v57; // er11
  __int64 v58; // rcx
  unsigned __int8 *v59; // r10
  __int64 v60; // r9
  unsigned __int8 *v61; // rax
  unsigned __int8 *v62; // rbp
  unsigned __int8 v63; // al
  signed __int64 v64; // r13
  unsigned __int8 *v65; // r10
  signed __int64 v66; // r9
  __int64 v67; // rsi
  __int64 v68; // rbp
  int v69; // edi
  __m128d v70; // xmm0
  double v71; // xmm1_8
  __m128d v72; // xmm7
  int v73; // ecx
  int v74; // eax
  __int64 v75; // rdi
  __int64 v76; // rsi
  int v77; // er8
  int v78; // edx
  int v79; // eax
  int v80; // ecx
  int v81; // er12
  int v82; // ebp
  signed __int64 v83; // r11
  unsigned __int8 *v84; // rdx
  int v85; // edi
  unsigned __int8 *v86; // r8
  char v87; // si
  unsigned __int8 v88; // cl
  int v89; // eax
  int v90; // eax
  unsigned __int8 *v91; // rcx
  int v92; // er10
  unsigned __int8 *v93; // r8
  int v94; // eax
  int v95; // er9
  int i; // edi
  int v97; // edx
  char v98; // si
  int v99; // edx
  int v100; // eax
  __int64 v101; // rsi
  __int64 v102; // rax
  __int64 v103; // rdx
  signed __int64 v104; // r11
  signed __int64 v105; // rcx
  double v106; // xmm0_8
  __int64 v107; // rax
  signed __int64 v108; // r8
  double v109; // xmm9_8
  signed __int64 v110; // r11
  signed __int64 v111; // r8
  int v112; // esi
  __m128d v113; // xmm3
  double v114; // xmm6_8
  __m128d v115; // xmm12
  signed int v116; // edx
  signed __int64 v117; // rcx
  __int64 v118; // rdi
  __int64 v119; // r9
  signed __int64 v120; // r10
  signed __int64 v121; // rdi
  signed __int64 v122; // rcx
  int v123; // edi
  __m128d v124; // xmm0
  __m128d v125; // xmm13
  __int64 v126; // rdx
  int v127; // er15
  int v128; // er14
  unsigned __int8 *v129; // r8
  int v130; // er9
  signed int v131; // ebp
  int v132; // er12
  int v133; // eax
  __int64 v134; // rax
  int v135; // ebx
  int v136; // eax
  unsigned __int8 *v137; // r10
  int v138; // eax
  int v139; // eax
  int v140; // ebx
  int v141; // eax
  unsigned __int8 *v142; // rax
  unsigned __int8 v143; // dl
  unsigned __int8 *v144; // rax
  unsigned __int8 v145; // dl
  int v146; // er10
  unsigned __int8 *j; // rdi
  signed int v148; // esi
  unsigned __int8 *k; // rdi
  int v150; // edx
  int v151; // esi
  __int64 v152; // rdi
  double v153; // xmm8_8
  double v154; // xmm6_8
  __m128d v155; // xmm0
  double v156; // xmm3_8
  __m128d v157; // xmm15
  signed int v158; // esi
  double v159; // xmm3_8
  __m128d v160; // xmm0
  __m128d v161; // xmm14
  unsigned int v162; // [rsp+0h] [rbp-148h]
  int v163; // [rsp+0h] [rbp-148h]
  int v164; // [rsp+0h] [rbp-148h]
  double *v165; // [rsp+0h] [rbp-148h]
  int v166; // [rsp+0h] [rbp-148h]
  unsigned __int8 *v167; // [rsp+8h] [rbp-140h]
  int v168; // [rsp+10h] [rbp-138h]
  double *v169; // [rsp+10h] [rbp-138h]
  int v170; // [rsp+18h] [rbp-130h]
  int v171; // [rsp+18h] [rbp-130h]
  __int64 v172; // [rsp+18h] [rbp-130h]
  int v173; // [rsp+20h] [rbp-128h]
  __int64 v174; // [rsp+20h] [rbp-128h]
  int v175; // [rsp+28h] [rbp-120h]
  char v176; // [rsp+28h] [rbp-120h]
  signed __int64 v177; // [rsp+28h] [rbp-120h]
  int v178; // [rsp+30h] [rbp-118h]
  char v179; // [rsp+30h] [rbp-118h]
  int v180; // [rsp+38h] [rbp-110h]
  signed __int64 v181; // [rsp+38h] [rbp-110h]
  int v182; // [rsp+40h] [rbp-108h]
  int v183; // [rsp+44h] [rbp-104h]
  __int64 v184; // [rsp+48h] [rbp-100h]
  signed __int64 v185; // [rsp+50h] [rbp-F8h]
  signed __int16 *v186; // [rsp+58h] [rbp-F0h]
  double *v187; // [rsp+60h] [rbp-E8h]
  __int64 v188; // [rsp+68h] [rbp-E0h]
  __int64 v189; // [rsp+70h] [rbp-D8h]
  __int64 v190; // [rsp+90h] [rbp-B8h]
  __int64 v191; // [rsp+98h] [rbp-B0h]
  __int64 v192; // [rsp+A0h] [rbp-A8h]
  __int64 v193; // [rsp+A8h] [rbp-A0h]
  __int64 v194; // [rsp+B0h] [rbp-98h]
  unsigned __int64 v195; // [rsp+B8h] [rbp-90h]
  char v196; // [rsp+C0h] [rbp-88h]
  unsigned __int64 v197; // [rsp+108h] [rbp-40h]

  v5 = a3;
  v6 = a2;
  v7 = a4;
  v8 = a5;
  v9 = *(_QWORD *)a4;
  v162 = a1;
  v197 = __readfsqword(0x28u);
  sub_11840((__int64)a4);
  if ( !v5 )
    return 80LL;
  if ( v8 )
  {
    v173 = 0;
    v10 = 0LL;
    goto LABEL_4;
  }
  if ( *((_DWORD *)v7 + 22) == 2 || a2 & 4 )
  {
    v41 = *((_QWORD *)v7 + 15);
  }
  else
  {
    v173 = a2 & 8;
    if ( !(a2 & 8) )
    {
      if ( !((_BYTE)v7[9] & 8)
        && !(unsigned int)sub_12760(*(_QWORD *)(v9 + 8), *((_QWORD *)v7 + 10), a1, (__m128i *)&v196) )
      {
        v10 = 0LL;
        v16 = &v196;
LABEL_157:
        v102 = *((_QWORD *)v16 + 2);
        v103 = *(_QWORD *)v16;
        v104 = v102 + 63;
        v105 = v102 + *(_QWORD *)v16;
        v106 = (double)(signed int)v102;
        if ( v102 >= 0 )
          v104 = *((_QWORD *)v16 + 2);
        v107 = *((_QWORD *)v16 + 4);
        v108 = v105 + 63;
        v109 = v7[28];
        v110 = v104 >> 6;
        if ( v105 >= 0 )
          v108 = v105;
        v111 = v108 >> 6;
        v112 = v111;
        v27 = xmmword_30160;
        v113.m128d_f64[0] = (double)(signed int)v107 * v109 * 0.015625 + 0.5;
        v26 = ((double)(signed int)v103 + v106 + v106) * 0.5 * 0.015625;
        v114 = (double)(signed int)v107 * v109 * 0.015625 + 0.5;
        if ( COERCE_DOUBLE(*(_QWORD *)&v113.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
        {
          v115.m128d_f64[0] = (double)(signed int)v113.m128d_f64[0];
          *(_QWORD *)&v114 = COERCE_UNSIGNED_INT64(
                               v115.m128d_f64[0]
                             - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v115, v113) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v113.m128d_f64[0];
        }
        v116 = (signed int)v114;
        v117 = *((_QWORD *)v16 + 3);
        v118 = *((_QWORD *)v16 + 1);
        v119 = *((_QWORD *)v7 + 25);
        v120 = v117 + 63;
        if ( v117 >= 0 )
          v120 = v117;
        v121 = v118 - v117;
        v122 = v121 + 63;
        v25 = v120 >> 6;
        if ( v121 >= 0 )
          v122 = v121;
        v22 = v122 >> 6;
        v123 = (signed int)v114;
        if ( v119 & 8 )
          v123 = *((_DWORD *)v7 + 60) + v116;
        v33 = *((_DWORD *)v7 + 61) + v123;
        if ( v119 & 1 )
          v112 = v111 + *((_DWORD *)v7 + 60);
        v38 = *((_DWORD *)v7 + 83) + *((_DWORD *)v7 + 63) + v112;
        v37 = *((_DWORD *)v7 + 82) + v110 + *((_DWORD *)v7 + 62);
        v124.m128d_f64[0] = (double)(1000 * (signed int)v107) * v109 * ((double)v33 / (double)v116) * 0.015625 / v7[12];
        if ( COERCE_DOUBLE(*(_QWORD *)&v124.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
        {
          v125.m128d_f64[0] = (double)(signed int)v124.m128d_f64[0];
          *(_QWORD *)&v124.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                            v125.m128d_f64[0]
                                          - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v125, v124) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v124.m128d_f64[0];
        }
        v36 = (signed int)v124.m128d_f64[0];
LABEL_38:
        v5[5] = v36;
        *v5 = v37;
        v5[1] = v38;
        v5[2] = v33;
        v5[3] = v25;
        v5[4] = v22;
        if ( *((_DWORD *)v7 + 22) )
          v5[2] = *(_WORD *)(*((_QWORD *)v7 + 15) + 4LL);
        if ( *((_BYTE *)v7 + 201) & 8 )
        {
          v39.m128d_f64[0] = v7[18] * 0.5 - v26 + 0.5;
          if ( COERCE_DOUBLE(*(_QWORD *)&v39.m128d_f64[0] & v27) < 4.503599627370496e15 )
          {
            v40.m128d_f64[0] = (double)(signed int)v39.m128d_f64[0];
            *(_QWORD *)&v39.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                             v40.m128d_f64[0]
                                           - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v40, v39) & 0x3FF0000000000000LL)) | ~v27 & *(_QWORD *)&v39.m128d_f64[0];
          }
          v173 = (signed int)v39.m128d_f64[0];
          *v5 = v37 + (signed int)v39.m128d_f64[0];
          v5[1] = v38 + (signed int)v39.m128d_f64[0];
        }
LABEL_4:
        if ( !(v6 & 2) )
          goto LABEL_5;
        return 85LL;
      }
      if ( !((_BYTE)v7[25] & 0x10)
        || (unsigned int)sub_12830(
                           a1,
                           *(_QWORD *)(v9 + 8),
                           *((_QWORD *)v7 + 1),
                           *(_DWORD *)(v9 + 20),
                           (__int64)(v7 + 4),
                           &v192,
                           v7[40],
                           &v190,
                           &v191) )
      {
        v13 = (__int64 *)a1;
        v14 = FT_Load_Glyph(*(_QWORD *)(*(_QWORD *)v7 + 8LL), a1, *((unsigned int *)v7 + 18));
        if ( v14 )
          return FTtoXReturnCode(v14, v13);
        v15 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 152LL);
        v16 = (char *)(v15 + 48);
        if ( *(_DWORD *)(v15 + 144) == 1651078259 && v15 != -48 )
        {
          v10 = (_QWORD *)(v15 + 48);
          goto LABEL_157;
        }
        v13 = &v192;
        v14 = FT_Outline_Get_BBox(v15 + 200, &v192);
        if ( v14 )
          return FTtoXReturnCode(v14, v13);
        v190 = *(_QWORD *)(v15 + 80);
        v17 = *(_QWORD *)(v15 + 104);
        v10 = (_QWORD *)(v15 + 48);
        v191 = v17;
      }
      else
      {
        v10 = 0LL;
      }
      v18 = *((_QWORD *)v7 + 25);
      v19 = v7[13];
      v20 = *((_DWORD *)v7 + 61);
      v21 = (v194 + 32) >> 6;
      v22 = (31 - v193) >> 6;
      v23 = (_QWORD)v7[25] & 8LL;
      v24 = v21;
      v25 = (signed __int64)(v195 + 32) >> 6;
      v26 = (double)((signed int)v194 + (signed int)v192) * 0.5 * 0.015625;
      if ( v19 == 0.0 )
      {
        v153 = v7[29];
        v154 = v7[14];
        v27 = xmmword_30160;
        v155.m128d_f64[0] = (double)(signed int)v191 * v153 * v154 * 0.015625 + 0.5;
        v156 = (double)(signed int)v191 * v153 * v154 * 0.015625 + 0.5;
        if ( COERCE_DOUBLE(*(_QWORD *)&v155.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
        {
          v157.m128d_f64[0] = (double)(signed int)v155.m128d_f64[0];
          *(_QWORD *)&v156 = COERCE_UNSIGNED_INT64(
                               v157.m128d_f64[0]
                             - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v157, v155) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v155.m128d_f64[0];
        }
        v158 = (signed int)v156;
        if ( (signed int)v156 <= 0 )
          v158 = *(signed __int16 *)(*((_QWORD *)v7 + 15) + 4LL);
        v159 = (double)v158;
        if ( v23 )
          v158 += *((_DWORD *)v7 + 60);
        v33 = v158 + v20;
        v160.m128d_f64[0] = (double)(1000 * (signed int)v191) * v153 * ((double)v33 / v159) * v154 * 0.015625;
        if ( COERCE_DOUBLE(*(_QWORD *)&v160.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
        {
          v161.m128d_f64[0] = (double)(signed int)v160.m128d_f64[0];
          *(_QWORD *)&v160.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                            v161.m128d_f64[0]
                                          - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v161, v160) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v160.m128d_f64[0];
        }
        v36 = (signed int)v160.m128d_f64[0];
        if ( !v36 )
          v36 = *(_WORD *)(*((_QWORD *)v7 + 15) + 10LL);
      }
      else
      {
        v27 = xmmword_30160;
        v28.m128d_f64[0] = (double)(signed int)v190 * v7[28] * v19 * 0.015625 + 0.5;
        v29 = (double)(signed int)v190 * v7[28] * v19 * 0.015625 + 0.5;
        if ( COERCE_DOUBLE(*(_QWORD *)&v28.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
        {
          v30.m128d_f64[0] = (double)(signed int)v28.m128d_f64[0];
          *(_QWORD *)&v29 = COERCE_UNSIGNED_INT64(
                              v30.m128d_f64[0]
                            - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v30, v28) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v28.m128d_f64[0];
        }
        v31 = (signed int)v29;
        v32 = (double)(signed int)v29;
        if ( v23 )
          v31 += *((_DWORD *)v7 + 60);
        v33 = v31 + v20;
        v34.m128d_f64[0] = (double)(1000 * (signed int)v190) * v7[28] * ((double)v33 / v32) * v19 * 0.015625;
        if ( COERCE_DOUBLE(*(_QWORD *)&v34.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
        {
          v35.m128d_f64[0] = (double)(signed int)v34.m128d_f64[0];
          *(_QWORD *)&v34.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                           v35.m128d_f64[0]
                                         - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v35, v34) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v34.m128d_f64[0];
        }
        v36 = (signed int)v34.m128d_f64[0];
      }
      if ( v18 & 1 )
        v24 = v21 + *((_DWORD *)v7 + 60);
      v37 = *((_DWORD *)v7 + 62) + (unsigned __int64)((v192 + 32) >> 6);
      v38 = *((_DWORD *)v7 + 63) + v24;
      goto LABEL_38;
    }
    v41 = *((_QWORD *)v7 + 19);
  }
  v10 = 0LL;
  *(_QWORD *)v5 = *(_QWORD *)v41;
  v173 = 0;
  *((_DWORD *)v5 + 2) = *(_DWORD *)(v41 + 8);
  if ( a2 & 2 )
    return 85LL;
LABEL_5:
  v170 = 1;
  if ( *((_DWORD *)v7 + 22) != 2 )
  {
    v170 = v6 & 8;
    if ( v6 & 8 )
    {
      v170 = 1;
    }
    else if ( ((_BYTE)v7[9] & 8 || (unsigned int)sub_12760(*(_QWORD *)(v9 + 8), *((_QWORD *)v7 + 10), v162, 0LL))
           && (_BYTE)v7[25] & 0x10 )
    {
      v170 = (*(_QWORD *)(*(_QWORD *)(v9 + 8) + 16LL) >> 3) & 1;
    }
  }
  v168 = v6 & 4;
  if ( v6 & 4 )
  {
LABEL_50:
    if ( !(*((_BYTE *)v7 + 201) & 8) || !(v8 & 1) )
    {
      v168 = -1;
      goto LABEL_53;
    }
    v12 = 0.0;
    v168 = -1;
    goto LABEL_91;
  }
  if ( v10 )
  {
    v11 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 152LL);
  }
  else
  {
    v13 = (__int64 *)v162;
    v14 = FT_Load_Glyph(*(_QWORD *)(*(_QWORD *)v7 + 8LL), v162, *((unsigned int *)v7 + 18));
    if ( v14 )
      return FTtoXReturnCode(v14, v13);
    v11 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 152LL);
    v10 = (_QWORD *)(v11 + 48);
  }
  if ( *(_DWORD *)(v11 + 144) != 1651078259 )
  {
    v13 = &v192;
    v14 = FT_Outline_Get_BBox(v11 + 200, &v192);
    if ( v14 )
      return FTtoXReturnCode(v14, v13);
    v193 &= 0xFFFFFFFFFFFFFFC0LL;
    v195 = (v195 + 63) & 0xFFFFFFFFFFFFFFC0LL;
    if ( !(unsigned int)((signed __int64)(v195 - v193) >> 6) )
      goto LABEL_50;
    v13 = (__int64 *)(&dword_0 + 2);
    v14 = FT_Render_Glyph(*(_QWORD *)(*(_QWORD *)(v9 + 8) + 152LL), 2LL);
    if ( v14 )
      return FTtoXReturnCode(v14, v13);
    if ( !(*((_BYTE *)v7 + 201) & 8) || !(v8 & 1) )
    {
      v168 = 1;
      goto LABEL_53;
    }
    v101 = *(_QWORD *)(v9 + 8);
    if ( v170 )
    {
      v168 = -1;
      if ( (unsigned int)sub_12830(
                           v162,
                           v101,
                           *((_QWORD *)v7 + 1),
                           *(_DWORD *)(v9 + 20),
                           (__int64)(v7 + 4),
                           &v192,
                           v7[40],
                           &v190,
                           &v191) )
      {
LABEL_154:
        v12 = (double)((signed int)v194 + (signed int)v192) * 0.5 * 0.015625;
        goto LABEL_91;
      }
    }
    else
    {
      v152 = *(_QWORD *)(v101 + 152);
      v13 = &v192;
      v14 = FT_Outline_Get_BBox(v152 + 200, &v192);
      if ( v14 )
        return FTtoXReturnCode(v14, v13);
    }
    v168 = 1;
    goto LABEL_154;
  }
  if ( !(*((_BYTE *)v7 + 201) & 8) || !(v8 & 1) )
    goto LABEL_53;
  v12 = ((double)(signed int)v10[2] + (double)(signed int)v10[2] + (double)(signed int)*v10) * 0.5 * 0.015625;
LABEL_91:
  v70.m128d_f64[0] = v7[18] * 0.5 - v12 + 0.5;
  v71 = v70.m128d_f64[0];
  if ( COERCE_DOUBLE(*(_QWORD *)&v70.m128d_f64[0] & xmmword_30160) < 4.503599627370496e15 )
  {
    v72.m128d_f64[0] = (double)(signed int)v70.m128d_f64[0];
    *(_QWORD *)&v71 = COERCE_UNSIGNED_INT64(v72.m128d_f64[0] - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v72, v70) & 0x3FF0000000000000LL)) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v70.m128d_f64[0];
  }
  v173 = (signed int)v71;
LABEL_53:
  v43 = 1;
  v44 = 1;
  v175 = v5[3];
  v45 = v5[1] - *v5;
  v178 = *v5;
  if ( v175 + v5[4] > 0 )
    v44 = v5[3] + v5[4];
  v163 = v5[3] + v5[4];
  if ( v45 > 0 )
    v43 = v5[1] - *v5;
  v182 = v44;
  v46 = -*((_DWORD *)v7 + 42) & ((v43 + 8 * *((_DWORD *)v7 + 42) - 1) >> 3);
  v183 = v46 * v44;
  v47 = (unsigned __int8 *)calloc(1uLL, v46 * v44);
  v167 = v47;
  if ( !v47 )
    return 80LL;
  *((_QWORD *)v5 + 2) = v47;
  if ( v168 == -1 || v45 <= 0 || v163 <= 0 )
    return 85LL;
  v48 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 152LL);
  v49 = *(_DWORD *)(v48 + 192) - v178;
  v50 = *((_QWORD *)v7 + 25);
  v164 = v175 - *(_DWORD *)(v48 + 196);
  v184 = *((_QWORD *)v7 + 25);
  if ( v50 & 0x800 )
    v49 += v173;
  if ( v170 & v168 )
  {
    v13 = &v192;
    v14 = FT_Outline_Get_BBox(v48 + 200, &v192);
    if ( !v14 )
    {
      v73 = *v5;
      v74 = v5[1];
      v75 = (31 - v193) >> 6;
      LOWORD(v184) = *((_QWORD *)v7 + 25);
      v76 = (signed __int64)(v195 + 32) >> 6;
      v185 = (_QWORD)v7[25] & 1LL;
      if ( (_QWORD)v7[25] & 1 )
        v74 -= *((_DWORD *)v7 + 60);
      if ( (_QWORD)v7[25] & 0x800LL )
      {
        v73 -= v173;
        v74 -= v173;
      }
      if ( v6 & 8 )
      {
        if ( !*((_DWORD *)v7 + 69) && !*((_DWORD *)v7 + 70) )
        {
LABEL_101:
          v77 = v74 - (unsigned __int64)((v194 + 32) >> 6);
          v78 = v5[3] - (_DWORD)v76;
          v79 = v5[4] - (_DWORD)v75;
          v80 = (unsigned __int64)((v192 + 32) >> 6) - v73;
          if ( v80 >= 0 || v77 <= 0 )
          {
            if ( v77 < 0 && v80 > 0 )
              --v49;
          }
          else
          {
            ++v49;
          }
          goto LABEL_104;
        }
      }
      else if ( !*((_QWORD *)v7 + 31) )
      {
        goto LABEL_101;
      }
      v78 = v5[3] - (_DWORD)v76;
      v79 = v5[4] - (_DWORD)v75;
LABEL_104:
      v48 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 152LL);
      if ( v78 >= 0 || v79 <= 0 )
      {
        if ( v79 < 0 )
          v164 = (v78 <= 0) + v164 - 1;
      }
      else
      {
        ++v164;
      }
      goto LABEL_65;
    }
    return FTtoXReturnCode(v14, v13);
  }
  v185 = (_QWORD)v7[25] & 1LL;
LABEL_65:
  if ( v49 < 0 )
  {
    v51 = ((v49 + 7) >> 3) - 1;
    v176 = -(char)v49 & 7;
    v179 = 8 - v176;
  }
  else
  {
    v51 = v49 >> 3;
    v179 = v49 & 7;
    v176 = 8 - (v49 & 7);
  }
  v52 = v164;
  v53 = 0;
  if ( v164 < 0 )
    v52 = 0;
  v171 = v52;
  if ( v52 < v182 )
  {
    v54 = v52 - v164;
    v55 = v52 - v164;
    if ( *(_DWORD *)(v48 + 152) > (unsigned int)(v52 - v164) )
    {
      v186 = v5;
      if ( v51 >= 0 )
        v53 = v51;
      v187 = v7;
      v56 = v53 - v51;
      v57 = v46 * v52;
      v180 = v53 - v51 - 1;
      v188 = v53 + 1;
      v58 = v53 - v51 + 2;
      v189 = v53 - v51 + 2;
      do
      {
        if ( v46 > v53 )
        {
          v59 = &v167[v57];
          v60 = *(_QWORD *)(v48 + 168) + v54 * *(_DWORD *)(v48 + 160);
          if ( *(_DWORD *)(v48 + 160) > v180 && v180 >= 0 )
            v59[v53] |= *(unsigned __int8 *)(v60 + v180) << v176;
          if ( v56 >= 0 && *(_DWORD *)(v48 + 160) > v56 )
          {
            v61 = (unsigned __int8 *)(v60 + v56);
            v59[v53] |= (signed int)*v61 >> v179;
            if ( v46 > v53 + 1 )
            {
              v62 = &v59[v188];
              v63 = v59[v188] | (*v61 << v176);
              v59[v188] = v63;
              if ( v56 + 1 < *(_DWORD *)(v48 + 160) )
              {
                v64 = v60 - 1;
                v65 = &v59[v188 - v58];
                v66 = v60 - 2;
                v67 = v189;
                v68 = (__int64)&v62[-v189];
                do
                {
                  v69 = v67;
                  *(_BYTE *)(v68 + v67) = ((signed int)*(unsigned __int8 *)(v64 + v67) >> v179) | v63;
                  if ( v58 + (unsigned int)(v46 - 2 - v53) == v67 )
                    break;
                  v63 = v65[v67 + 1] | (*(unsigned __int8 *)(v66 + v67 + 1) << v176);
                  v65[v67++ + 1] = v63;
                }
                while ( *(_DWORD *)(v48 + 160) > v69 );
              }
            }
          }
        }
        if ( v54 == v182 - v164 - 1 )
          break;
        v57 += v46;
        v54 = v171 - v164 + v54 - v55 + 1;
      }
      while ( *(_DWORD *)(v48 + 152) > (unsigned int)(v54 + v171 - v164 - v55) );
      v5 = v186;
      v7 = v187;
    }
  }
  if ( v185 && *((_DWORD *)v7 + 60) > 0 )
  {
    v165 = v7;
    v81 = 0;
    v82 = *((_DWORD *)v7 + 60);
    v83 = (unsigned int)(v46 - 1) + 1LL;
    do
    {
      if ( v184 & 2 )
      {
        v91 = v167;
        v92 = 0;
        do
        {
          if ( v46 > 0 )
          {
            v93 = &v91[v83];
            v94 = 0;
            v95 = *v91;
            for ( i = v95 << 7; ; i = v95 << 7 )
            {
              v97 = v95;
              ++v91;
              LOBYTE(v97) = (unsigned __int8)v95 >> 1;
              v98 = ~(_BYTE)v95;
              v99 = v94 | v95 | v97;
              v100 = v99 & ~(~v95 & 2 * v99);
              *(v91 - 1) = v99 & ~(~(_BYTE)v95 & 2 * v99);
              if ( v91 == v93 )
                break;
              v95 = *v91;
              if ( v98 & 1 && (v95 & 0x80u) != 0 )
                *(v91 - 1) = v100 & 0xFE;
              v94 = i;
            }
          }
          ++v92;
        }
        while ( v92 < v182 );
      }
      else
      {
        v84 = v167;
        v85 = 0;
        do
        {
          v86 = &v84[v83];
          v87 = 0;
          if ( v46 > 0 )
          {
            do
            {
              v88 = *v84++;
              *(v84 - 1) = v87 | v88 | (v88 >> 1);
              v87 = v88 << 7;
            }
            while ( v84 != v86 );
          }
          ++v85;
        }
        while ( v85 < v182 );
      }
      ++v81;
    }
    while ( v81 != v82 );
    v7 = v165;
  }
  if ( !v168 && *((_QWORD *)v7 + 41) )
  {
    v126 = *((_QWORD *)v7 + 15);
    v127 = *((_DWORD *)v7 + 83) - *((_DWORD *)v7 + 82);
    v166 = *(signed __int16 *)(v126 + 8) + *(signed __int16 *)(v126 + 6);
    if ( v7[26] < 0.0 )
      v127 = *((_DWORD *)v7 + 82) - *((_DWORD *)v7 + 83);
    v128 = v46 - 1;
    v129 = v167;
    v130 = 0;
    v169 = v7;
    v131 = v46;
    v132 = v127 * (*(signed __int16 *)(v126 + 8) - 1 + v5[3]);
    v172 = v46;
    v133 = 0;
    if ( v46 - 1 <= 0 )
      v133 = v46 - 1;
    v174 = v133;
    v134 = (unsigned int)(v46 - 2);
    v181 = v134 + 1;
    v177 = v128 - v134 - 1;
    do
    {
      v137 = v129;
      v138 = v132 / v166;
      if ( v132 / v166 >= 0 )
      {
        v135 = v138 >> 3;
        v136 = v132 / v166 & 7;
        if ( v136 && v128 >= 0 )
        {
          v146 = v128;
          for ( j = &v129[v128]; ; --j )
          {
            --v146;
            v148 = (signed int)*j >> v136;
            *j = v148;
            if ( v146 == -1 )
              break;
            if ( v128 != v146 )
              *j = v148 | (*(j - 1) << (8 - v136));
          }
        }
        if ( v135 )
        {
          if ( v128 > 0 )
          {
            v144 = &v129[v128];
            do
            {
              v145 = *(v144-- - 1);
              v144[1] = v145;
            }
            while ( &v129[v177] != v144 );
          }
          v129[v174] = 0;
        }
      }
      else
      {
        v139 = -v138;
        v140 = v139 >> 3;
        v141 = v139 & 7;
        if ( v141 && v131 > 0 )
        {
          for ( k = v129; ; *(k - 1) = (v150 >> (8 - v141)) | v151 )
          {
            v151 = *k << v141;
            *k = v151;
            if ( &v129[v128] == k )
              break;
            v150 = (k++)[1];
          }
        }
        if ( v140 )
        {
          if ( v131 > 1 )
          {
            v142 = v129;
            do
            {
              v143 = (v142++)[1];
              *(v142 - 1) = v143;
            }
            while ( &v129[v181] != v142 );
            v137 = &v129[v128];
          }
          *v137 = 0;
        }
      }
      ++v130;
      v132 -= v127;
      v129 += v172;
    }
    while ( v130 < v182 );
    v7 = v169;
  }
  v89 = *((_DWORD *)v7 + 40);
  if ( !v89 )
  {
    BitOrderInvert(*((unsigned __int8 **)v5 + 2), v183);
    v89 = *((_DWORD *)v7 + 40);
  }
  if ( *((_DWORD *)v7 + 41) == v89 )
    return 85LL;
  v90 = *((_DWORD *)v7 + 43);
  if ( v90 != 2 )
  {
    if ( v90 == 4 )
      FourByteSwap(*((unsigned __int8 **)v5 + 2), v183);
    return 85LL;
  }
  TwoByteSwap(*((unsigned __int8 **)v5 + 2), v183);
  return 85LL;
}
// 80F0: using guessed type __int64 __fastcall FT_Load_Glyph(_QWORD, _QWORD, _QWORD);
// 8530: using guessed type __int64 __fastcall FTtoXReturnCode(_QWORD, _QWORD);
// 8770: using guessed type __int64 __fastcall FT_Outline_Get_BBox(_QWORD, _QWORD);
// 8CC0: using guessed type __int64 __fastcall FT_Render_Glyph(_QWORD, _QWORD);
// 30160: using guessed type __int128 xmmword_30160;

//----- (0000000000013FF0) ----------------------------------------------------
signed __int64 __fastcall sub_13FF0(unsigned int a1, char a2, signed __int16 **a3, __int64 a4)
{
  signed __int16 **v4; // r12
  __int64 v5; // rbx
  signed __int64 result; // rax
  signed int v7; // ecx
  signed __int16 *v8; // rdx
  int v9; // [rsp+Ch] [rbp-3Ch]
  int v10; // [rsp+10h] [rbp-38h]
  int v11; // [rsp+14h] [rbp-34h]
  unsigned __int64 v12; // [rsp+18h] [rbp-30h]

  v4 = a3;
  v5 = a4;
  v12 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a4 + 88) == 2 )
  {
    *a3 = *(signed __int16 **)(a4 + 120);
    return 85LL;
  }
  if ( a2 & 8 )
  {
    *a3 = *(signed __int16 **)(a4 + 152);
    return 85LL;
  }
  result = sub_11620(
             a1,
             a2,
             (unsigned int *)(a4 + 176),
             *(_DWORD *)(a4 + 268),
             (_QWORD *)(a4 + 184),
             (_QWORD *)(a4 + 192),
             &v9,
             &v10,
             &v11);
  if ( (_DWORD)result != 85 )
    return result;
  if ( v9 && (v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 192) + 8LL * v10) + 4LL * v11), v7 != 1) )
  {
    v8 = (signed __int16 *)(*(_QWORD *)(*(_QWORD *)(v5 + 184) + 8LL * v10) + 24LL * v11);
    if ( v7 > 1 )
    {
LABEL_10:
      *v4 = v8;
      return result;
    }
    result = sub_12C20(a1, a2 | 2u, v8, (double *)v5, 0);
    if ( (_DWORD)result == 85 )
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 192) + 8LL * v10) + 4LL * v11) = 2;
      v8 = (signed __int16 *)(*(_QWORD *)(*(_QWORD *)(v5 + 184) + 8LL * v10) + 24LL * v11);
      goto LABEL_10;
    }
  }
  else
  {
    *v4 = 0LL;
  }
  return result;
}

//----- (0000000000014170) ----------------------------------------------------
signed __int64 __fastcall sub_14170(unsigned int a1, char a2, signed __int16 **a3, __int64 a4)
{
  signed __int16 **v4; // rbp
  __int64 v5; // rbx
  unsigned int v6; // edi
  unsigned int v7; // eax
  __int64 v8; // rcx
  unsigned int v10; // [rsp+4h] [rbp-24h]
  unsigned __int64 v11; // [rsp+8h] [rbp-20h]

  v4 = a3;
  v5 = a4;
  v10 = 0;
  v11 = __readfsqword(0x28u);
  if ( (unsigned int)sub_126F0(a1, a4, &v10) || !v10 || v10 == *(_DWORD *)(v5 + 40) )
  {
    *v4 = 0LL;
    return 85LL;
  }
  if ( (unsigned int)sub_13FF0(v10, a2, v4, *(_QWORD *)v5) != 85 || !*v4 )
  {
    v6 = *(_DWORD *)(v5 + 40);
    v7 = v10;
    v8 = *(_QWORD *)v5;
    if ( v6 != v10 )
    {
      if ( (unsigned int)sub_13FF0(v6, a2, v4, v8) == 85 && *v4 )
        return 85LL;
      v8 = *(_QWORD *)v5;
      v7 = *(_DWORD *)(v5 + 40);
    }
    return sub_13FF0(v7, a2 | 4u, v4, v8);
  }
  return 85LL;
}

//----- (0000000000014250) ----------------------------------------------------
signed __int64 __fastcall sub_14250(__int64 a1, __int64 a2, __int16 *a3, unsigned int a4, signed __int64 *a5, __int64 a6)
{
  signed __int64 v6; // r15
  char v7; // bp
  signed int v8; // er13
  __int16 *v9; // r12
  unsigned int v10; // ebx
  __int64 v11; // r14
  __int16 v12; // r13
  signed int v13; // eax
  void *v14; // rax
  __int64 *v16; // [rsp+8h] [rbp-70h]
  __int64 v17; // [rsp+18h] [rbp-60h]
  signed __int64 *v18; // [rsp+28h] [rbp-50h]
  void *v19; // [rsp+30h] [rbp-48h]
  unsigned __int64 v20; // [rsp+38h] [rbp-40h]

  v6 = a2 - 1;
  v7 = 0;
  v8 = 0;
  v9 = a3;
  v10 = a4;
  v11 = a6;
  v20 = __readfsqword(0x28u);
  v18 = a5;
  v16 = *(__int64 **)(a1 + 152);
  v17 = *v16;
  if ( a2 )
  {
    do
    {
      if ( v10 <= 1 )
      {
        v8 = *(unsigned __int8 *)v9;
        v9 = (__int16 *)((char *)v9 + 1);
      }
      else if ( v10 <= 3 )
      {
        v12 = *v9;
        ++v9;
        v13 = *(_DWORD *)(v17 + 268);
        v8 = (unsigned __int16)__ROL2__(v12, 8);
        if ( *(_BYTE *)(v17 + 201) & 4 )
        {
          v7 = 8;
          if ( v8 > v13 )
            v7 = 8 * (*(_DWORD *)(v17 + 264) <= v8);
        }
        else
        {
          v7 = 0;
          if ( v8 <= v13 )
            v7 = 8 * (*(_DWORD *)(v17 + 264) <= v8);
        }
      }
      v11 += 8LL;
      if ( (unsigned int)sub_14170(v8, v7, (signed __int16 **)&v19, (__int64)v16) != 85 || (v14 = v19) == 0LL )
        v14 = &unk_23CC90;
      --v6;
      *(_QWORD *)(v11 - 8) = v14;
    }
    while ( v6 != -1 );
  }
  *v18 = 8 * a2 >> 3;
  return 85LL;
}

//----- (00000000000143E0) ----------------------------------------------------
__int64 __fastcall sub_143E0(unsigned int a1, char a2, signed __int16 **a3, __int64 a4)
{
  signed __int16 **v4; // r14
  __int64 v5; // rbx
  unsigned int *v6; // rdx
  _QWORD *v7; // r9
  _QWORD *v8; // r8
  int v9; // ecx
  unsigned int v10; // ebp
  signed int v12; // ecx
  signed __int16 *v13; // rdx
  unsigned int v14; // eax
  int v15; // [rsp+14h] [rbp-3Ch]
  int v16; // [rsp+18h] [rbp-38h]
  int v17; // [rsp+1Ch] [rbp-34h]
  unsigned __int64 v18; // [rsp+20h] [rbp-30h]

  v4 = a3;
  v5 = a4;
  v6 = (unsigned int *)(a4 + 176);
  v7 = (_QWORD *)(a4 + 192);
  v8 = (_QWORD *)(a4 + 184);
  v9 = *(_DWORD *)(a4 + 268);
  v18 = __readfsqword(0x28u);
  v10 = sub_11620(a1, a2, v6, v9, v8, v7, &v15, &v16, &v17);
  if ( v10 == 85 )
  {
    if ( v15 && (v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 192) + 8LL * v16) + 4LL * v17), v12 != 1) )
    {
      v13 = (signed __int16 *)(*(_QWORD *)(*(_QWORD *)(v5 + 184) + 8LL * v16) + 24LL * v17);
      if ( v12 == 3 )
      {
        *v4 = v13;
      }
      else
      {
        v14 = sub_12C20(a1, a2 | 1u, v13, (double *)v5, v12 > 1);
        if ( v14 != 85
          && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 192) + 8LL * v16) + 4LL * v17) <= 1
           || (ErrorF("Warning: FreeTypeRasteriseGlyph() returns an error,\n"),
               ErrorF("\tso the backend tries to set a white space.\n"),
               v14 = sub_12C20(
                       a1,
                       a2 | 5u,
                       (signed __int16 *)(*(_QWORD *)(*(_QWORD *)(v5 + 184) + 8LL * v16) + 24LL * v17),
                       (double *)v5,
                       *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 192) + 8LL * v16) + 4LL * v17) > 1),
               v14 != 85)) )
        {
          v10 = v14;
        }
        else
        {
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 192) + 8LL * v16) + 4LL * v17) = 3;
          *v4 = (signed __int16 *)(*(_QWORD *)(*(_QWORD *)(v5 + 184) + 8LL * v16) + 24LL * v17);
        }
      }
    }
    else
    {
      *v4 = 0LL;
    }
  }
  return v10;
}
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);

//----- (00000000000145E0) ----------------------------------------------------
signed __int64 __fastcall sub_145E0(__int64 a1, __int64 a2, __int16 *a3, unsigned int a4, signed __int64 *a5, signed __int64 *a6)
{
  unsigned int v6; // er14
  __int16 *v7; // r13
  __int64 v8; // rbp
  signed __int64 *v9; // rbx
  signed int v10; // er12
  __int64 v11; // r15
  __int16 v12; // r12
  signed int v13; // eax
  unsigned int v14; // edi
  unsigned int v15; // eax
  __int64 v16; // rcx
  signed __int64 v17; // rax
  bool v19; // zf
  signed __int16 *v20; // rdx
  int v21; // eax
  int v22; // esi
  int v23; // eax
  void *v24; // rax
  char v25; // [rsp+Ch] [rbp-8Ch]
  __int64 v26; // [rsp+28h] [rbp-70h]
  signed __int64 *v27; // [rsp+30h] [rbp-68h]
  signed __int64 *v28; // [rsp+38h] [rbp-60h]
  unsigned int v29; // [rsp+4Ch] [rbp-4Ch]
  __int64 v30; // [rsp+50h] [rbp-48h]
  unsigned __int64 v31; // [rsp+58h] [rbp-40h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a6;
  v10 = 0;
  v11 = *(_QWORD *)(a1 + 152);
  v31 = __readfsqword(0x28u);
  v27 = a5;
  v28 = a6;
  v25 = 0;
  v26 = *(_QWORD *)v11;
LABEL_2:
  if ( --v8 != -1 )
  {
    while ( 1 )
    {
      if ( v6 <= 1 )
      {
        v10 = *(unsigned __int8 *)v7;
        v7 = (__int16 *)((char *)v7 + 1);
      }
      else if ( v6 <= 3 )
      {
        v12 = *v7;
        ++v7;
        v13 = *(_DWORD *)(v26 + 268);
        v10 = (unsigned __int16)__ROL2__(v12, 8);
        if ( *(_BYTE *)(v26 + 201) & 4 )
        {
          if ( v13 < v10 )
            v25 = 8 * (*(_DWORD *)(v26 + 264) <= v10);
          else
            v25 = 8;
        }
        else if ( v13 < v10 )
        {
          v25 = 0;
        }
        else
        {
          v25 = 8 * (*(_DWORD *)(v26 + 264) <= v10);
        }
      }
      v29 = 0;
      if ( (unsigned int)sub_126F0(v10, v11, &v29) || !v29 || v29 == *(_DWORD *)(v11 + 40) )
        break;
      if ( (unsigned int)sub_143E0(v29, v25, (signed __int16 **)&v30, *(_QWORD *)v11) == 85 )
      {
        v17 = v30;
        if ( v30 )
          goto LABEL_18;
      }
      v14 = *(_DWORD *)(v11 + 40);
      v15 = v29;
      v16 = *(_QWORD *)v11;
      if ( v14 != v29 )
      {
        if ( (unsigned int)sub_143E0(v14, v25, (signed __int16 **)&v30, v16) == 85 )
        {
          v17 = v30;
          if ( v30 )
            goto LABEL_18;
        }
        v16 = *(_QWORD *)v11;
        v15 = *(_DWORD *)(v11 + 40);
      }
      if ( (unsigned int)sub_143E0(v15, v25 | 4u, (signed __int16 **)&v30, v16) != 85 || (v17 = v30) == 0 )
      {
        if ( *(_QWORD *)(v11 + 80) )
        {
LABEL_17:
          v17 = v11 + 64;
          goto LABEL_18;
        }
LABEL_21:
        v20 = *(signed __int16 **)(v11 + 48);
        v21 = v20[9] - v20[8];
        if ( v21 <= 0 )
          v21 = 1;
        v22 = -*(_DWORD *)(*(_QWORD *)v11 + 168LL) & ((v21 + 8 * *(_DWORD *)(*(_QWORD *)v11 + 168LL) - 1) >> 3);
        v23 = v20[12] + v20[11];
        if ( v23 <= 0 )
          v23 = 1;
        v24 = calloc(1uLL, v23 * v22);
        if ( !v24 )
          goto LABEL_2;
        *(_QWORD *)(v11 + 80) = v24;
        goto LABEL_17;
      }
LABEL_18:
      --v8;
      *v9 = v17;
      ++v9;
      if ( v8 == -1 )
        goto LABEL_19;
    }
    v19 = *(_QWORD *)(v11 + 80) == 0LL;
    v30 = 0LL;
    if ( !v19 )
      goto LABEL_17;
    goto LABEL_21;
  }
LABEL_19:
  *v27 = v9 - v28;
  return 85LL;
}

//----- (00000000000148D0) ----------------------------------------------------
__int64 __fastcall sub_148D0(char *s, __int64 a2, size_t a3, unsigned __int16 *a4, const __m128i *a5, char *a6)
{
  __int64 v6; // r15
  unsigned int v7; // ebx
  _QWORD **v8; // rax
  _QWORD **v9; // r14
  char *v10; // rax
  char *v11; // r13
  char *v12; // rax
  int v13; // ebx
  __int64 v14; // r8
  char *v15; // rcx
  const char *v16; // rbx
  int v17; // eax
  char *v18; // r13
  signed int v19; // ebx
  char *v20; // rbp
  double v21; // xmm0_8
  double v22; // xmm1_8
  char *v23; // rbp
  bool v24; // r12
  const char **v25; // rbp
  size_t v27; // rax
  unsigned __int64 v28; // rbp
  char *v29; // rax
  char *v30; // kr20_8
  char *v31; // rax
  char v32; // al
  __int64 v33; // rbp
  unsigned __int8 v34; // cl
  signed __int64 v35; // rax
  int v36; // eax
  unsigned __int64 v37; // rax
  signed __int64 v38; // rdx
  char *v39; // rax
  char *v40; // rbp
  char *v41; // rax
  __int64 v42; // rax
  _BYTE *v43; // rbp
  unsigned __int8 v44; // cl
  signed __int64 v45; // rax
  const char *v46; // rbp
  char *v47; // rax
  char *v48; // rcx
  _BOOL4 v49; // esi
  bool v50; // dl
  bool v51; // al
  int v52; // eax
  int v53; // eax
  int v54; // esi
  int v55; // eax
  int v56; // eax
  int v57; // ebx
  signed __int64 v58; // rdx
  int v59; // eax
  __int64 v60; // rbx
  double v61; // xmm0_8
  double v62; // xmm5_8
  double v63; // xmm4_8
  double v64; // xmm0_8
  double v65; // xmm1_8
  double v66; // xmm2_8
  double v67; // xmm1_8
  char *v68; // rax
  __int64 v69; // rdi
  bool v70; // zf
  const char *v71; // rax
  signed int v72; // STE8_4
  char **v73; // STE0_8
  char *v74; // rax
  char **v75; // r9
  signed int v76; // er11
  char v77; // dl
  double v78; // xmm2_8
  double v79; // xmm7_8
  double v80; // xmm3_8
  char *v81; // rbp
  int v82; // eax
  char *v83; // rax
  void *v84; // ST68_8
  __int64 v85; // rax
  const char *v86; // rdx
  __int64 v87; // r9
  _WORD *v88; // rax
  _DWORD *v89; // r10
  int v90; // esi
  char *v91; // rax
  signed int v92; // er14
  signed int v93; // er13
  signed int v94; // er9
  signed int v95; // er12
  signed int v96; // er11
  signed int v97; // er15
  signed int v98; // er8
  int v99; // eax
  int v100; // edx
  int v101; // ebx
  signed int v102; // eax
  signed int v103; // er15
  signed int v104; // er14
  signed int v105; // er13
  signed int v106; // er12
  signed int v107; // er9
  signed int v108; // ebp
  signed __int16 v109; // ax
  signed __int16 v110; // ax
  signed __int16 v111; // ax
  signed __int16 v112; // dx
  int v113; // eax
  signed __int16 v114; // dx
  signed __int16 v115; // cx
  int v116; // eax
  __int64 v117; // rax
  signed int v118; // eax
  unsigned int v119; // eax
  unsigned int v120; // edi
  signed int v121; // STD0_4
  signed int v122; // STC8_4
  signed int v123; // STC0_4
  _DWORD *v124; // STB8_8
  int v125; // eax
  signed int v126; // eax
  const char **v127; // rdi
  double v128; // xmm0_8
  char *v129; // rbp
  double v130; // xmm0_8
  char *v131; // rbp
  double v132; // xmm0_8
  char *v133; // rbp
  double v134; // xmm0_8
  const char **v135; // rdi
  __int64 v136; // rax
  int v137; // eax
  signed __int16 v138; // di
  signed __int16 v139; // r10
  signed __int16 v140; // r9
  double v141; // xmm0_8
  signed __int64 v142; // rax
  unsigned __int16 *v143; // rsi
  __int64 v144; // rax
  __int64 v145; // rdi
  signed int v146; // er11
  char **v147; // ST78_8
  int v148; // eax
  char **v149; // rdi
  char **v150; // r8
  signed __int16 *v151; // rdx
  signed int v152; // eax
  signed int v153; // edx
  void *v154; // rax
  char *v155; // rsi
  int v156; // edx
  unsigned int v157; // eax
  __int64 v158; // rbp
  signed __int64 v159; // rbx
  char *v160; // r12
  char v161; // al
  char *i; // r13
  char *v163; // r14
  unsigned int v164; // eax
  Atom v165; // rax
  signed __int64 v166; // rcx
  Atom v167; // rax
  size_t v168; // ST58_8
  Atom v169; // rax
  signed __int64 v170; // rcx
  signed int v171; // ecx
  char *v172; // r8
  char **v173; // ST98_8
  char **v174; // ST90_8
  signed int v175; // ecx
  char *v176; // r8
  char **v177; // ST98_8
  char **v178; // ST90_8
  const char *v179; // rax
  char **v180; // ST90_8
  signed int v181; // ecx
  char *v182; // r8
  char **v183; // ST90_8
  char *v184; // ST60_8
  signed __int64 v185; // r15
  const char *v186; // rax
  char *v187; // ST48_8
  unsigned int v188; // eax
  double v189; // xmm3_8
  double v190; // xmm6_8
  double v191; // xmm13_8
  double v192; // xmm14_8
  double v193; // xmm8_8
  double v194; // xmm2_8
  double v195; // xmm4_8
  double v196; // xmm0_8
  double v197; // xmm4_8
  double v198; // xmm11_8
  double v199; // xmm0_8
  double v200; // xmm10_8
  double v201; // xmm11_8
  double v202; // xmm4_8
  double v203; // xmm12_8
  double v204; // xmm15_8
  double v205; // xmm5_8
  double v206; // xmm0_8
  double v207; // xmm7_8
  double v208; // xmm11_8
  double v209; // xmm7_8
  double v210; // xmm5_8
  double v211; // xmm0_8
  double v212; // xmm15_8
  double v213; // xmm12_8
  double v214; // xmm15_8
  double v215; // xmm4_8
  double v216; // xmm12_8
  double v217; // xmm10_8
  double v218; // xmm7_8
  double v219; // xmm4_8
  double v220; // xmm12_8
  double v221; // xmm0_8
  double v222; // xmm15_8
  double v223; // xmm0_8
  double v224; // STA0_8
  double v225; // ST98_8
  double v226; // xmm8_8
  double v227; // xmm2_8
  char *v228; // STC0_8
  double v229; // xmm0_8
  signed int v230; // eax
  char *v231; // r9
  __int64 v232; // rcx
  signed int v233; // edx
  double v234; // xmm5_8
  double v235; // xmm0_8
  double v236; // xmm4_8
  double v237; // xmm3_8
  double v238; // xmm0_8
  char *v239; // r9
  signed int v240; // edx
  signed int v241; // esi
  signed int v242; // ecx
  char *v243; // ST118_8
  int v244; // edx
  int v245; // eax
  char **v246; // ST108_8
  double v247; // xmm0_8
  char **v248; // r9
  char *v249; // rax
  int v250; // eax
  char *v251; // rax
  char *v252; // rbp
  int v253; // eax
  char *v254; // rbp
  int v255; // eax
  char *v256; // rbp
  int v257; // eax
  __int64 v258; // rsi
  __int64 v259; // ST70_8
  signed int v260; // eax
  double v261; // xmm0_8
  double v262; // xmm0_8
  signed int v263; // esi
  char *v264; // rdi
  char **v265; // ST90_8
  signed int v266; // ecx
  double v267; // xmm0_8
  char **v268; // ST80_8
  double v269; // xmm0_8
  double v270; // xmm2_8
  bool v271; // cc
  double v272; // xmm3_8
  double v273; // xmm0_8
  signed int v274; // eax
  double v275; // xmm0_8
  int v276; // er8
  int v277; // eax
  int v278; // edx
  int v279; // edi
  int v280; // eax
  char *v281; // rbp
  int v282; // eax
  char *v283; // rbp
  int v284; // eax
  char **v285; // ST90_8
  char *v286; // ST60_8
  double v287; // xmm1_8
  double v288; // xmm2_8
  signed int v289; // eax
  Atom v290; // rax
  signed __int64 v291; // r8
  signed __int64 v292; // r15
  signed __int64 v293; // rax
  double v294; // xmm4_8
  char **v295; // ST90_8
  char **v296; // ST90_8
  char **v297; // ST90_8
  size_t v298; // ST58_8
  double v299; // xmm0_8
  double v300; // xmm3_8
  double v301; // xmm4_8
  double v302; // xmm0_8
  signed int v303; // eax
  signed int v304; // edx
  int v305; // edi
  int v306; // eax
  double v307; // xmm4_8
  char **v308; // r15
  double v309; // xmm5_8
  double v310; // xmm0_8
  char *v311; // rax
  signed int v312; // eax
  int sa; // [rsp+8h] [rbp-630h]
  char *sb; // [rsp+8h] [rbp-630h]
  unsigned __int16 *v315; // [rsp+10h] [rbp-628h]
  char *v316; // [rsp+18h] [rbp-620h]
  char *v317; // [rsp+18h] [rbp-620h]
  const __m128i *v318; // [rsp+20h] [rbp-618h]
  signed int v319; // [rsp+20h] [rbp-618h]
  signed __int16 v320; // [rsp+20h] [rbp-618h]
  void *v321; // [rsp+20h] [rbp-618h]
  void *v322; // [rsp+20h] [rbp-618h]
  double v323; // [rsp+20h] [rbp-618h]
  signed int v324; // [rsp+20h] [rbp-618h]
  signed int v325; // [rsp+20h] [rbp-618h]
  size_t nmemb; // [rsp+28h] [rbp-610h]
  size_t nmemba; // [rsp+28h] [rbp-610h]
  int nmembb; // [rsp+28h] [rbp-610h]
  signed int nmembc; // [rsp+28h] [rbp-610h]
  char *string; // [rsp+30h] [rbp-608h]
  int stringa; // [rsp+30h] [rbp-608h]
  signed __int16 stringb; // [rsp+30h] [rbp-608h]
  int stringc; // [rsp+30h] [rbp-608h]
  int ptr; // [rsp+38h] [rbp-600h]
  char *ptra; // [rsp+38h] [rbp-600h]
  int v336; // [rsp+40h] [rbp-5F8h]
  double v337; // [rsp+40h] [rbp-5F8h]
  signed int v338; // [rsp+40h] [rbp-5F8h]
  signed __int16 v339; // [rsp+40h] [rbp-5F8h]
  __int64 v340; // [rsp+40h] [rbp-5F8h]
  signed __int16 *v341; // [rsp+40h] [rbp-5F8h]
  double v342; // [rsp+40h] [rbp-5F8h]
  char *v343; // [rsp+48h] [rbp-5F0h]
  signed int v344; // [rsp+48h] [rbp-5F0h]
  int v345; // [rsp+48h] [rbp-5F0h]
  int v346; // [rsp+48h] [rbp-5F0h]
  signed __int16 v347; // [rsp+48h] [rbp-5F0h]
  int v348; // [rsp+50h] [rbp-5E8h]
  int v349; // [rsp+50h] [rbp-5E8h]
  signed __int16 v350; // [rsp+50h] [rbp-5E8h]
  char **v351; // [rsp+50h] [rbp-5E8h]
  double v352; // [rsp+50h] [rbp-5E8h]
  double v353; // [rsp+50h] [rbp-5E8h]
  double v354; // [rsp+50h] [rbp-5E8h]
  double v355; // [rsp+50h] [rbp-5E8h]
  signed int v356; // [rsp+58h] [rbp-5E0h]
  signed int v357; // [rsp+58h] [rbp-5E0h]
  int v358; // [rsp+58h] [rbp-5E0h]
  signed int v359; // [rsp+58h] [rbp-5E0h]
  signed int v360; // [rsp+58h] [rbp-5E0h]
  signed __int64 v361; // [rsp+58h] [rbp-5E0h]
  char *v362; // [rsp+60h] [rbp-5D8h]
  int v363; // [rsp+60h] [rbp-5D8h]
  signed __int16 v364; // [rsp+60h] [rbp-5D8h]
  char **v365; // [rsp+60h] [rbp-5D8h]
  char *v366; // [rsp+68h] [rbp-5D0h]
  signed __int16 v367; // [rsp+68h] [rbp-5D0h]
  signed __int16 v368; // [rsp+68h] [rbp-5D0h]
  signed int v369; // [rsp+68h] [rbp-5D0h]
  unsigned int v370; // [rsp+68h] [rbp-5D0h]
  double v371; // [rsp+68h] [rbp-5D0h]
  double v372; // [rsp+68h] [rbp-5D0h]
  char **v373; // [rsp+68h] [rbp-5D0h]
  char **v374; // [rsp+68h] [rbp-5D0h]
  int v375; // [rsp+70h] [rbp-5C8h]
  int v376; // [rsp+70h] [rbp-5C8h]
  signed __int16 v377; // [rsp+70h] [rbp-5C8h]
  __int64 v378; // [rsp+70h] [rbp-5C8h]
  double v379; // [rsp+70h] [rbp-5C8h]
  signed int v380; // [rsp+7Ch] [rbp-5BCh]
  signed int v381; // [rsp+80h] [rbp-5B8h]
  signed int v382; // [rsp+80h] [rbp-5B8h]
  char v383; // [rsp+80h] [rbp-5B8h]
  signed int len; // [rsp+88h] [rbp-5B0h]
  signed __int16 lena; // [rsp+88h] [rbp-5B0h]
  _QWORD **lenb; // [rsp+88h] [rbp-5B0h]
  unsigned int lenc; // [rsp+88h] [rbp-5B0h]
  unsigned int lend; // [rsp+88h] [rbp-5B0h]
  char *lene; // [rsp+88h] [rbp-5B0h]
  const char *lenf; // [rsp+88h] [rbp-5B0h]
  double leng; // [rsp+88h] [rbp-5B0h]
  signed int lenh; // [rsp+88h] [rbp-5B0h]
  char *v393; // [rsp+90h] [rbp-5A8h]
  char *v394; // [rsp+90h] [rbp-5A8h]
  char *v395; // [rsp+90h] [rbp-5A8h]
  __int16 v396; // [rsp+90h] [rbp-5A8h]
  int v397; // [rsp+90h] [rbp-5A8h]
  const char **v398; // [rsp+98h] [rbp-5A0h]
  __int64 v399; // [rsp+98h] [rbp-5A0h]
  int v400; // [rsp+98h] [rbp-5A0h]
  bool v401; // [rsp+A0h] [rbp-598h]
  __int64 v402; // [rsp+A0h] [rbp-598h]
  double v403; // [rsp+A0h] [rbp-598h]
  signed int v404; // [rsp+A8h] [rbp-590h]
  unsigned int v405; // [rsp+A8h] [rbp-590h]
  signed int v406; // [rsp+A8h] [rbp-590h]
  int v407; // [rsp+A8h] [rbp-590h]
  __int64 v408; // [rsp+B0h] [rbp-588h]
  double v409; // [rsp+B0h] [rbp-588h]
  char **v410; // [rsp+B0h] [rbp-588h]
  __int64 v411; // [rsp+B8h] [rbp-580h]
  signed int v412; // [rsp+B8h] [rbp-580h]
  __int64 v413; // [rsp+C0h] [rbp-578h]
  double v414; // [rsp+C0h] [rbp-578h]
  __int64 v415; // [rsp+C8h] [rbp-570h]
  double v416; // [rsp+C8h] [rbp-570h]
  char *v417; // [rsp+D0h] [rbp-568h]
  int v418; // [rsp+D8h] [rbp-560h]
  char *v419; // [rsp+E0h] [rbp-558h]
  char *v420; // [rsp+E0h] [rbp-558h]
  const char **v421; // [rsp+E8h] [rbp-550h]
  unsigned int v422; // [rsp+F4h] [rbp-544h]
  __int64 v423; // [rsp+F8h] [rbp-540h]
  unsigned __int16 v424; // [rsp+108h] [rbp-530h]
  unsigned __int16 v425; // [rsp+10Ah] [rbp-52Eh]
  unsigned __int16 v426; // [rsp+10Ch] [rbp-52Ch]
  unsigned __int16 v427; // [rsp+10Eh] [rbp-52Ah]
  char v428; // [rsp+110h] [rbp-528h]
  __int64 v429; // [rsp+118h] [rbp-520h]
  char *endptr; // [rsp+120h] [rbp-518h]
  __int64 v431; // [rsp+160h] [rbp-4D8h]
  double v432; // [rsp+168h] [rbp-4D0h]
  double v433; // [rsp+170h] [rbp-4C8h]
  double v434; // [rsp+178h] [rbp-4C0h]
  double v435; // [rsp+180h] [rbp-4B8h]
  __int64 v436; // [rsp+188h] [rbp-4B0h]
  __int64 v437; // [rsp+190h] [rbp-4A8h]
  void *v438; // [rsp+198h] [rbp-4A0h]
  __int64 v439; // [rsp+1A0h] [rbp-498h]
  __int64 v440; // [rsp+1A8h] [rbp-490h]
  __int64 v441; // [rsp+1B0h] [rbp-488h]
  double v442; // [rsp+1B8h] [rbp-480h]
  double v443; // [rsp+1C0h] [rbp-478h]
  double v444; // [rsp+1C8h] [rbp-470h]
  double v445; // [rsp+1D0h] [rbp-468h]
  __int64 v446; // [rsp+1D8h] [rbp-460h]
  __int64 v447; // [rsp+1E0h] [rbp-458h]
  char v448; // [rsp+1F0h] [rbp-448h]
  char v449; // [rsp+1F1h] [rbp-447h]
  unsigned __int64 v450; // [rsp+5F8h] [rbp-40h]

  v6 = a2;
  v7 = 80;
  v450 = __readfsqword(0x28u);
  nmemb = a3;
  v315 = a4;
  v318 = a5;
  v316 = a6;
  v8 = (_QWORD **)calloc(1uLL, 0x60uLL);
  if ( !v8 )
    return v7;
  v9 = v8;
  ptr = *(_DWORD *)(a2 + 72);
  if ( (unsigned int)SPropRecValList_new(&v428, 96LL) )
    goto LABEL_33;
  sa = strlen(s);
  v10 = strrchr(s, 47);
  v11 = v10 + 1;
  if ( !v10 )
    v11 = s;
  v12 = strrchr(v11, 58);
  if ( v12 )
  {
    string = v12;
    v13 = (_DWORD)v11 - (_DWORD)s;
    sb = (char *)malloc((signed int)v11 + sa - (signed int)v12);
    if ( sb )
    {
      v14 = v13;
      v15 = string;
      if ( v13 > 0 )
      {
        memcpy(sb, s, v13);
        v15 = string;
        v14 = v13;
      }
      strcpy(&sb[v14], v15 + 1);
      if ( (unsigned int)SPropRecValList_add_by_font_cap(&v428, v11) )
      {
        v7 = 86;
        free(sb);
        goto LABEL_34;
      }
      goto LABEL_10;
    }
LABEL_33:
    v7 = 80;
    goto LABEL_34;
  }
  sb = strdup(s);
  if ( !sb )
    goto LABEL_34;
LABEL_10:
  v433 = 1.0;
  v434 = 1.0;
  v435 = 1.0;
  v442 = 1.0;
  v443 = 1.0;
  v445 = 1.0;
  v431 = 0LL;
  v432 = 0.0;
  v436 = 1LL;
  v437 = 0LL;
  v438 = 0LL;
  v439 = -1LL;
  v440 = 0LL;
  v441 = -8589934592LL;
  v444 = 0.0;
  v446 = 0LL;
  v447 = 0LL;
  if ( !(unsigned int)SPropRecValList_search_record(&v428, &v429, "FaceNumber")
    || (v16 = *(const char **)(v429 + 8), v17 = strtol(*(const char **)(v429 + 8), &endptr, 10), !*v16)
    || (v336 = v17, *endptr)
    || v17 <= 0 )
  {
    v18 = strdup(sb);
    if ( v18 )
    {
      v336 = 0;
      goto LABEL_14;
    }
    goto LABEL_32;
  }
  v27 = strlen(v16);
  v28 = strlen(sb);
  v29 = (char *)malloc(v28 + v27 + 3);
  v18 = v29;
  if ( !v29 )
  {
LABEL_32:
    free(sb);
    goto LABEL_33;
  }
  *v29 = 0;
  v343 = strrchr(sb, 47);
  if ( v343 )
  {
    memcpy(v18, sb, v28 + 1);
    strrchr(v18, 47)[1] = 0;
    v30 = &v18[strlen(v18)];
    *v30 = 58;
    v31 = stpcpy(v30 + 1, v16);
    *v31 = 58;
    strcpy(v31 + 1, v343 + 1);
  }
  else
  {
    *v18 = 58;
    v83 = stpcpy(v18 + 1, v16);
    *v83 = 58;
    memcpy(v83 + 1, sb, v28 + 1);
  }
LABEL_14:
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "AutoItalic") )
    v432 = *(double *)(v429 + 8);
  v19 = -1;
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "Hinting") )
    v19 = *(_DWORD *)(v429 + 8);
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "ScaleWidth") )
  {
    v433 = *(double *)(v429 + 8);
    if ( v433 <= 0.0 )
    {
      v24 = 1;
      v25 = 0LL;
      v7 = 83;
      fwrite("ScaleWitdh needs plus.\n", 1uLL, 0x17uLL, stderr);
      goto LABEL_27;
    }
  }
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "ScaleBBoxWidth") )
  {
    v20 = *(char **)(v429 + 8);
    if ( !*v20 )
    {
LABEL_22:
      v21 = 1.0;
      v22 = 1.0;
LABEL_23:
      v434 = v22;
      v435 = v21;
      goto LABEL_24;
    }
    v22 = strtod(*(const char **)(v429 + 8), &endptr);
    v77 = *endptr;
    if ( v20 == endptr )
    {
      if ( v77 != 44 && v77 != 59 )
        goto LABEL_22;
      v22 = 1.0;
    }
    else if ( v77 != 59 && v77 != 44 )
    {
      if ( v22 > 0.0 )
      {
        v21 = 1.0;
        goto LABEL_23;
      }
LABEL_136:
      fwrite("ScaleBBoxWitdh needs plus.\n", 1uLL, 0x1BuLL, stderr);
      goto LABEL_26;
    }
    v81 = endptr + 1;
    v21 = 1.0;
    if ( v77 == 44 )
    {
      v21 = strtod(endptr + 1, &endptr);
      if ( endptr == v81 )
        v21 = 1.0;
      if ( *endptr != 59 && *endptr != 44 )
      {
LABEL_149:
        if ( v22 > 0.0 )
        {
          if ( v21 <= 0.0 )
          {
            fwrite("ScaleBBoxHeight needs plus.\n", 1uLL, 0x1CuLL, stderr);
            goto LABEL_26;
          }
          goto LABEL_23;
        }
        goto LABEL_136;
      }
      v81 = endptr + 1;
    }
    v82 = strtol(v81, &endptr, 10);
    if ( endptr != v81 )
      HIDWORD(v436) = v82;
    if ( *endptr == 44 )
    {
      v254 = endptr + 1;
      v255 = strtol(endptr + 1, &endptr, 10);
      if ( v254 != endptr )
        LODWORD(v437) = v255;
      if ( *endptr == 44 )
      {
        v256 = endptr + 1;
        v257 = strtol(endptr + 1, &endptr, 10);
        if ( v256 != endptr )
          HIDWORD(v437) = v257;
      }
    }
    goto LABEL_149;
  }
LABEL_24:
  if ( !(unsigned int)SPropRecValList_search_record(&v428, &v429, "ForceSpacing") )
  {
    v348 = 0;
    goto LABEL_48;
  }
  v23 = *(char **)(v429 + 8);
  if ( strlen(*(const char **)(v429 + 8)) != 1 )
  {
LABEL_26:
    v24 = 1;
    v25 = 0LL;
    v7 = 83;
    goto LABEL_27;
  }
  v32 = *v23;
  if ( *v23 == 99 )
    goto LABEL_156;
  if ( *v23 > 99 )
  {
    if ( v32 != 109 && v32 != 112 )
      goto LABEL_26;
LABEL_156:
    v348 = *v23;
    goto LABEL_48;
  }
  if ( v32 != 77 )
    goto LABEL_26;
  v431 |= 0x800uLL;
  v348 = 109;
LABEL_48:
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "DoubleStrike") )
  {
    v33 = *(_QWORD *)(v429 + 8);
    if ( !*(_BYTE *)v33 )
      goto LABEL_26;
    v34 = *(_BYTE *)v33 - 76;
    if ( v34 > 0x2Du )
      goto LABEL_26;
    v35 = 1LL << v34;
    if ( (1LL << v34) & 0x400000004LL )
    {
      v431 &= 0xFFFFFFFFFFFFFFF4LL;
    }
    else if ( v35 & 0x200000002000LL )
    {
      v431 |= 1uLL;
    }
    else
    {
      if ( !(v35 & 0x300000003LL) )
        goto LABEL_26;
      v431 |= 3uLL;
    }
    v36 = *(unsigned __int8 *)(v33 + 1);
    if ( (_BYTE)v36 )
    {
      v37 = (unsigned int)(v36 - 66);
      if ( (unsigned __int8)v37 <= 0x37u )
      {
        v38 = 36099170066513921LL;
        if ( _bittest64(&v38, v37) )
          v431 |= 8uLL;
      }
    }
    v39 = strchr((const char *)v33, 59);
    if ( v39 || (v39 = strchr((const char *)v33, 44)) != 0LL )
    {
      v40 = v39 + 1;
      if ( v39[1] )
      {
        v137 = strtol(v39 + 1, &endptr, 10);
        if ( endptr != v40 && ptr >= v137 )
          v431 &= 0xFFFFFFFFFFFFFFFDLL;
      }
      v41 = strchr(v40, 44);
      if ( v41 )
      {
        if ( v41[1] )
        {
          v252 = v41 + 1;
          v253 = strtol(v41 + 1, &endptr, 10);
          if ( endptr != v252 && ptr >= v253 && v431 & 1 )
            LODWORD(v436) = ptr / v253 + v436;
        }
      }
    }
  }
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "VeryLazyMetrics") )
  {
    if ( *(_DWORD *)(v429 + 8) == -1 )
      v42 = v431 | 0x30;
    else
      v42 = v431 & 0xFFFFFFFFFFFFFFEFLL | 0x20;
    v431 = v42;
  }
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "EmbeddedBitmap") )
  {
    v43 = *(_BYTE **)(v429 + 8);
    if ( strlen(*(const char **)(v429 + 8)) != 1 )
      goto LABEL_26;
    v44 = *v43 - 78;
    if ( v44 > 0x2Bu )
      goto LABEL_26;
    v45 = 1LL << v44;
    if ( (1LL << v44) & 0x80000000800LL )
    {
      v356 = -1;
      v344 = -1;
      goto LABEL_74;
    }
    if ( v45 & 0x100000001LL )
    {
      v356 = 0;
      v344 = 0;
      goto LABEL_74;
    }
    if ( !(v45 & 0x8000000080LL) )
      goto LABEL_26;
  }
  v356 = 0;
  v344 = -1;
LABEL_74:
  if ( v431 & 0x10 && (unsigned int)SPropRecValList_search_record(&v428, &v429, "VeryLazyBitmapWidthScale") )
  {
    v84 = *(void **)(v429 + 8);
    fwrite("Warning: `bs' option is not required in X-TT version 2.\n", 1uLL, 0x38uLL, stderr);
    v438 = v84;
  }
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "CodeRange") )
  {
    ptra = strdup(*(const char **)(v429 + 8));
    if ( !ptra )
    {
      v24 = 1;
      v25 = 0LL;
      v7 = 80;
      goto LABEL_27;
    }
  }
  else
  {
    ptra = 0LL;
  }
  v425 = 0;
  LOWORD(endptr) = 255;
  v426 = 255;
  v427 = 0;
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, &unk_304A0)
    && (unsigned int)sub_10EE0(1, &v425, (__int16 *)&v427, &v426, &endptr, *(const char **)(v429 + 8)) == 1 )
  {
    LODWORD(v439) = v425 | (v427 << 8);
    v85 = v431;
    HIDWORD(v439) = v426 | ((unsigned __int16)endptr << 8);
    BYTE1(v85) = BYTE1(v431) & 0xFB;
    if ( (signed int)v439 > SHIDWORD(v439) )
      v85 = v431 | 0x400;
    v431 = v85;
  }
  v425 = 255;
  v426 = 0;
  v424 = 0;
  v427 = 255;
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "ForceConstantSpacingMetrics") )
  {
    v46 = *(const char **)(v429 + 8);
    if ( v46 )
    {
      v362 = strchr(*(const char **)(v429 + 8), 59);
      v366 = strchr(v46, 44);
      v47 = strchr(v46, 46);
      v48 = v366;
      v49 = v362 != 0LL;
      v50 = v49 && v47 != 0LL;
      if ( v366 && (_BYTE)v49 )
      {
        if ( v362 >= v366 )
        {
          if ( !v50 )
            goto LABEL_233;
          goto LABEL_245;
        }
        v48 = 0LL;
      }
      if ( !v50 )
      {
        v51 = v47 == 0LL;
LABEL_86:
        if ( v51 && v46 != v362 && !v48 )
        {
          if ( (unsigned int)sub_10EE0(1, &v424, (__int16 *)&v426, &v425, &v427, v46) == 1 )
            HIDWORD(v441) = v424 | (v426 << 8);
LABEL_90:
          if ( v362 )
          {
            v52 = strtol(v362 + 1, &endptr, 10);
            if ( v362 + 1 != endptr )
              LODWORD(v440) = v52;
            if ( *endptr == 44 )
            {
              v281 = endptr + 1;
              v282 = strtol(endptr + 1, &endptr, 10);
              if ( v281 != endptr )
                HIDWORD(v440) = v282;
              if ( *endptr == 44 )
              {
                v283 = endptr + 1;
                v284 = strtol(endptr + 1, &endptr, 10);
                if ( v283 != endptr )
                  LODWORD(v441) = v284;
              }
            }
          }
          goto LABEL_94;
        }
LABEL_233:
        v128 = strtod(v46, &endptr);
        if ( v46 != endptr )
          v442 = v128;
        if ( *endptr == 44 )
        {
          v129 = endptr + 1;
          v130 = strtod(endptr + 1, &endptr);
          if ( v129 != endptr )
          {
            v431 |= 0x100uLL;
            v444 = v130;
          }
          if ( *endptr == 44 )
          {
            v131 = endptr + 1;
            v132 = strtod(endptr + 1, &endptr);
            if ( v131 != endptr )
            {
              v431 |= 0x200uLL;
              v445 = v132;
            }
            if ( *endptr == 44 )
            {
              v133 = endptr + 1;
              v134 = strtod(endptr + 1, &endptr);
              if ( v133 != endptr )
                v443 = v134;
            }
          }
        }
        goto LABEL_90;
      }
LABEL_245:
      if ( v362 >= v47 )
        goto LABEL_233;
      v51 = 1;
      goto LABEL_86;
    }
  }
LABEL_94:
  v380 = -1;
  if ( (unsigned int)SPropRecValList_search_record(&v428, &v429, "FontProperties") )
    v380 = *(_DWORD *)(v429 + 8);
  LODWORD(v441) = HIDWORD(v437) + v441;
  HIDWORD(v440) += v437;
  v53 = 2 * (v19 == 0) | 8;
  v443 = v443 * v435;
  if ( v344 )
    v53 = 2 * (v19 == 0);
  v345 = v53;
  v442 = v442 * v434 * v433;
  v434 = v434 * v433;
  if ( 0.0 != v432 )
  {
    v54 = v53;
    v55 = v53 | 8;
    if ( v356 )
      v55 = v54;
    v345 = v55;
  }
  if ( !dword_23CC80 )
  {
    if ( (unsigned int)FT_Init_FreeType(&ftypeLibrary) )
    {
      v24 = 1;
      v25 = 0LL;
      v7 = 80;
      ErrorF("FreeType: error initializing ftypeEngine: %d\n");
      goto LABEL_120;
    }
    dword_23CC80 = 1;
  }
  v56 = (unsigned __int8)*v18;
  v57 = 0;
  v58 = (signed __int64)(v18 + 1);
  if ( (_BYTE)v56 )
  {
    do
    {
      ++v58;
      v57 = v56 + __ROL4__(v57, 5);
      v56 = *(unsigned __int8 *)(v58 - 1);
    }
    while ( (_BYTE)v56 );
    v59 = v57 & 0x1F;
  }
  else
  {
    v59 = 0;
  }
  v60 = v59;
  v25 = (const char **)qword_23CB80[v59];
  if ( v25 )
  {
    while ( strcmp(*v25, v18) )
    {
      v25 = (const char **)v25[5];
      if ( !v25 )
        goto LABEL_122;
    }
  }
  else
  {
LABEL_122:
    v25 = (const char **)calloc(1uLL, 0x30uLL);
    if ( !v25 )
      goto LABEL_130;
    v68 = strdup(v18);
    *v25 = v68;
    if ( !v68 )
    {
      v127 = v25;
      v24 = 1;
      v25 = 0LL;
      free(v127);
      v7 = 80;
      goto LABEL_120;
    }
    if ( (unsigned int)FT_New_Face(ftypeLibrary, sb, v336, v25 + 1) )
    {
      v24 = 1;
      v7 = 83;
      ErrorF("FreeType: couldn't open face %s: %d\n");
      free((void *)*v25);
      v135 = v25;
      v25 = 0LL;
      free(v135);
      goto LABEL_120;
    }
    v69 = (__int64)v25[1];
    v70 = (*(_QWORD *)(v69 + 16) & 1) == 0;
    *((_DWORD *)v25 + 4) = ~(unsigned __int8)*(_QWORD *)(v69 + 16) & 1;
    if ( !v70 )
    {
      v136 = FT_Get_Sfnt_Table(v69, 1LL);
      if ( v136 && !*(_WORD *)(v136 + 12) )
        *((_DWORD *)v25 + 4) = 1;
      v69 = (__int64)v25[1];
    }
    *((_DWORD *)v25 + 5) = (unsigned __int16)sub_10D30(v69, 1751672161LL, 34LL);
    v71 = (const char *)qword_23CB80[v60];
    qword_23CB80[v60] = v25;
    v25[5] = v71;
  }
  v61 = hypot(*(double *)(v6 + 56), *(double *)(v6 + 64));
  v62 = *(double *)(v6 + 48);
  v63 = *(double *)(v6 + 64);
  if ( (signed int)(*(double *)(v6 + 56) / v61 * 65536.0) != 0LL
    || (signed int)(*(double *)(v6 + 48) / v61 * 65536.0) != 0LL
    || (signed int)(*(double *)(v6 + 40) / v61 * 65536.0) != 0x10000LL
    || (v357 = -1, (signed int)(v63 / v61 * 65536.0) != 0x10000LL) )
  {
    v345 |= 8u;
    v357 = 0;
  }
  v64 = *(double *)(v6 + 8);
  v65 = *(double *)(v6 + 16);
  if ( *((_DWORD *)v25 + 4) )
  {
    v345 &= 0xFFFFFFF7;
  }
  else
  {
    v78 = v432;
    v79 = v432 * v64 + *(double *)(v6 + 24);
    *(double *)(v6 + 56) = *(double *)(v6 + 40) * v432 + *(double *)(v6 + 56);
    *(double *)(v6 + 24) = v79;
    v80 = v78 * v65 + *(double *)(v6 + 32);
    *(double *)(v6 + 64) = v78 * v62 + v63;
    *(double *)(v6 + 32) = v80;
  }
  v66 = hypot(v64, v65);
  v67 = hypot(*(double *)(v6 + 24), *(double *)(v6 + 32));
  if ( v66 <= v67 )
    v24 = v67 < 1.0;
  else
    v24 = v66 < 1.0;
  v7 = 83;
  if ( v24 )
    goto LABEL_120;
  v7 = sub_118D0(
         (__int64)v9,
         v315,
         (__int64)v25,
         v18,
         v6,
         (__int64)v316,
         v318,
         v345,
         (unsigned __int64 *)&v431,
         ptra,
         v348);
  if ( v7 != 85 )
  {
    v24 = 1;
    goto LABEL_120;
  }
  v86 = v25[1];
  v87 = (__int64)*v9;
  v337 = 0.00048828125;
  if ( *((_WORD *)v86 + 68) )
    v337 = 1.0 / (double)*((unsigned __int16 *)v86 + 68);
  v346 = *(_DWORD *)(v87 + 88);
  v88 = *(_WORD **)(v87 + 120);
  if ( v88 )
  {
    LOWORD(v363) = v88[2];
    LOWORD(v381) = v88[3];
    LOWORD(v375) = v88[4];
    LOWORD(len) = v88[5];
    LOWORD(v349) = v88[1];
    LOWORD(v358) = *v88;
    v338 = *(_DWORD *)(v87 + 128);
    v417 = *(char **)(v87 + 136);
    goto LABEL_167;
  }
  v189 = *(double *)(v87 + 224);
  if ( *((_DWORD *)v25 + 4) )
  {
    v374 = (char **)*v9;
    v354 = (double)(signed int)*(_QWORD *)(*(_QWORD *)(v87 + 8) + 72LL);
    v258 = *(_QWORD *)(v87 + 8);
    v259 = (__int64)*v9;
    lenh = (signed int)floor(v354 * v189 * 0.015625 + 0.5);
    v375 = -(signed int)(*(_QWORD *)(v258 + 56) / 64LL);
    v361 = *(_QWORD *)(v258 + 48) / 64LL;
    LOWORD(v381) = v361;
    v400 = (signed int)floor(v354 * *(double *)(v259 + 288) * 0.015625 + 0.5);
    v260 = *(_DWORD *)(v6 + 88);
    if ( v260 )
      v261 = floor((double)v260 * v189 + 0.5);
    else
      v261 = floor(v354 * 10.0 * v189 * 0.015625 + 0.5);
    v338 = (signed int)v261;
    v262 = floor(0.015625 * v354 + 0.5);
    v248 = v374;
    v263 = 0;
    v264 = v374[25];
    v403 = (double)(signed int)v262;
    v372 = *(double *)(v6 + 8);
    if ( (unsigned __int16)v264 & 0x100 )
    {
      v265 = v248;
      v263 = (signed int)floor(v354 * *((double *)v248 + 38) * 0.015625 + 0.5);
      v248 = v265;
    }
    v266 = lenh;
    if ( (unsigned __int16)v264 & 0x200 )
    {
      v267 = v354;
      v268 = v248;
      v266 = (signed int)floor(v267 * *((double *)v248 + 39) * 0.015625 + 0.5);
      v248 = v268;
    }
    v269 = *((double *)v248 + 26);
    if ( v269 != 0.0 )
    {
      v270 = (double)((signed int)v361 + v375);
      v271 = v269 <= 0.0;
      v272 = (double)(signed int)v361;
      v273 = v269 * v270;
      if ( v271 )
      {
        v309 = 0.5 - v273;
        v310 = (double)(signed int)(0.5 - v273) * v272 / v270 + 0.5;
        *((_DWORD *)v248 + 83) = (signed int)v309 - (signed int)v310;
        *((_DWORD *)v248 + 82) = -(signed int)v310;
      }
      else
      {
        v274 = (signed int)(v273 + 0.5);
        v275 = (double)v274 * v272 / v270 + 0.5;
        *((_DWORD *)v248 + 83) = (signed int)v275;
        *((_DWORD *)v248 + 82) = (signed int)v275 - v274;
      }
    }
    LOWORD(v363) = lenh;
    if ( (unsigned __int8)v264 & 8 )
      v363 = *((_DWORD *)v248 + 60) + lenh;
    v276 = *((_DWORD *)v248 + 82);
    v277 = *((_DWORD *)v248 + 63);
    v278 = *((_DWORD *)v248 + 83);
    v358 = v276 + *((_DWORD *)v248 + 62);
    if ( (unsigned __int8)v264 & 1 )
    {
      v279 = *((_DWORD *)v248 + 60);
      v266 += v279;
      v277 += v279 + lenh;
    }
    else
    {
      LOWORD(v277) = lenh + v277;
    }
    LOWORD(v349) = v278 + v277;
    v227 = 0.0;
    LOWORD(v324) = 0;
    v417 = 0LL;
    LOWORD(len) = 0;
    v407 = *((_DWORD *)v248 + 70) + v266 + v278;
    v397 = *((_DWORD *)v248 + 69) + v263 + v276;
  }
  else
  {
    v190 = *(double *)(v6 + 8);
    v191 = *(double *)(v6 + 16);
    v192 = *(double *)(v6 + 32);
    v193 = fmax((double)*((signed __int16 *)v86 + 69), (double)(signed int)*((_QWORD *)v86 + 16));
    v194 = *(double *)(v6 + 24);
    v195 = fmax((double)-*((signed __int16 *)v86 + 70), (double)-*((_DWORD *)v86 + 28));
    v196 = (double)(signed int)*((_QWORD *)v86 + 13) * v189;
    v352 = (double)*((signed __int16 *)v86 + 72);
    *(double *)&v365 = v195;
    *(_QWORD *)&v197 = *(_QWORD *)&v195 ^ xmmword_30670;
    v323 = v193 * v194;
    v198 = v196;
    v199 = v196 * v191;
    v200 = v194 * v197;
    v201 = v198 * v190;
    v202 = v197 * v192;
    v203 = fmax(v352, (double)(signed int)*((_QWORD *)v86 + 15)) * v189;
    v204 = v199 + v202;
    v205 = v201 + v200;
    v206 = v199 + v193 * v192;
    v371 = v193 * v192;
    v207 = v201 + v193 * v194;
    v208 = fmax(v207, v201 + v200);
    v209 = fmin(v207, v205);
    *(_QWORD *)&v210 = *(_QWORD *)&v206 ^ xmmword_30670;
    if ( v204 <= v206 )
      *(_QWORD *)&v210 = *(_QWORD *)&v204 ^ xmmword_30670;
    v211 = fmax(v206, v204);
    v212 = v203;
    v213 = v203 * v191;
    v214 = v212 * v190;
    v215 = v202 + v213;
    v379 = v213;
    v216 = v200 + v214;
    v217 = fmax(v200 + v214, v208);
    v218 = fmin(v216, v209);
    if ( COERCE_DOUBLE(*(_QWORD *)&v210 ^ xmmword_30670) > v215 )
      *(_QWORD *)&v210 = *(_QWORD *)&v215 ^ xmmword_30670;
    v219 = fmax(v215, v211);
    v220 = v379 + v371;
    v221 = v214 + v323;
    v222 = fmax(v214 + v323, v217);
    v223 = fmin(v221, v218);
    if ( COERCE_DOUBLE(*(_QWORD *)&v210 ^ xmmword_30670) > v379 + v371 )
      *(_QWORD *)&v210 = xmmword_30670 ^ *(_QWORD *)&v220;
    v224 = v210;
    v402 = (__int64)*v9;
    lenf = v25[1];
    v415 = *(_QWORD *)(v6 + 24);
    v225 = fmax(v220, v219);
    v406 = (signed int)floor(v223 * v337 + 0.5);
    v412 = (signed int)floor(v222 * v337 + 0.5);
    v375 = (signed int)ceil(v337 * v224 - 0.5);
    v381 = (signed int)floor(v225 * v337 + 0.5);
    if ( *((_WORD *)lenf + 73) <= 0 )
      v226 = v193 + *(double *)&v365;
    else
      v226 = (double)*((signed __int16 *)lenf + 73);
    if ( v191 == 0.0 )
    {
      v227 = 0.0;
      *(_QWORD *)&v372 = *(_QWORD *)&v190 & xmmword_30160;
      leng = v189 * v352 * COERCE_DOUBLE(*(_QWORD *)&v190 & xmmword_30160);
    }
    else
    {
      v294 = *(double *)(v402 + 232) * v226;
      if ( v192 == 0.0 )
      {
        *(_QWORD *)&v227 = *(_QWORD *)&v194 & xmmword_30160;
        v372 = 0.0;
        leng = v294 * COERCE_DOUBLE(v415 & xmmword_30160);
      }
      else
      {
        *(_QWORD *)&v372 = COERCE_UNSIGNED_INT64(v190 - v194 * v191 / v192) & xmmword_30160;
        *(_QWORD *)&v227 = COERCE_UNSIGNED_INT64(v194 - v190 * v192 / v191) & xmmword_30160;
        leng = v189 * v352 * v372;
        v307 = v294 * v227;
        if ( leng <= v307 )
        {
          v227 = 0.0;
        }
        else
        {
          leng = v307;
          v372 = 0.0;
        }
      }
    }
    v228 = (char *)v402;
    v403 = leng * v337;
    v229 = floor(leng * v337 + 0.5);
    v230 = (signed int)v229;
    v231 = v228;
    v232 = *((_QWORD *)v228 + 25);
    v396 = *((_QWORD *)v228 + 25);
    LODWORD(v232) = v232 & 8;
    v399 = (unsigned int)v232;
    v233 = (signed int)v229;
    if ( (_DWORD)v232 )
      v233 += *((_DWORD *)v231 + 60);
    v363 = *((_DWORD *)v231 + 61) + v233;
    v234 = *((double *)v231 + 39);
    v235 = *((double *)v231 + 38);
    v409 = (double)v363 / (double)v230;
    if ( v372 == 0.0 )
    {
      v236 = *((double *)v231 + 37) * v226 * v227;
      v237 = v235 * v226 * v227;
      v353 = v226 * v234 * v227;
    }
    else
    {
      v236 = *((double *)v231 + 36) * v352 * v372;
      v237 = v235 * v352 * v372;
      v353 = v352 * v234 * v372;
    }
    v420 = v231;
    v414 = v236 * v337;
    v238 = floor(v236 * v337 + 0.5);
    v239 = v420;
    v240 = (signed int)v238;
    if ( v399 )
      v240 += *((_DWORD *)v420 + 60);
    v241 = v406;
    v400 = *((_DWORD *)v420 + 68) + (signed int)v238;
    v416 = (double)v400 / (double)v240;
    if ( v396 & 0x100 )
    {
      v241 = (signed int)floor(v237 * v337 + 0.5);
      v239 = v420;
    }
    v242 = v412;
    if ( v396 & 0x200 )
    {
      v243 = v239;
      v242 = (signed int)floor(v353 * v337 + 0.5);
      v239 = v243;
    }
    if ( v357 == -1 )
    {
      v299 = *((double *)v239 + 26);
      if ( v299 != 0.0 )
      {
        v300 = (double)(v381 + v375);
        v271 = v299 <= 0.0;
        v301 = (double)v381;
        v302 = v299 * v300;
        if ( v271 )
        {
          v312 = (signed int)((double)(signed int)(0.5 - v302) * v301 / v300 + 0.5);
          v305 = -v312;
          *((_DWORD *)v239 + 83) = (signed int)(0.5 - v302) - v312;
        }
        else
        {
          v303 = (signed int)(v302 + 0.5);
          v304 = (signed int)((double)v303 * v301 / v300 + 0.5);
          *((_DWORD *)v239 + 83) = v304;
          v305 = v304 - v303;
        }
        *((_DWORD *)v239 + 82) = v305;
      }
    }
    v244 = *((_DWORD *)v239 + 63);
    v358 = *((_DWORD *)v239 + 62) + v406;
    LOWORD(v349) = v412 + v244;
    if ( v396 & 1 )
    {
      v245 = *((_DWORD *)v239 + 60);
      v242 += v245;
      v349 = v245 + v412 + v244;
    }
    v246 = (char **)v239;
    v407 = *((_DWORD *)v239 + 70) + v242;
    v397 = *((_DWORD *)v239 + 69) + v241;
    v338 = (signed int)floor(10.0 * leng * v337 * v409 + 0.5);
    len = (signed int)floor(1000.0 * (v409 * v403) / v67 + 0.5);
    v417 = (char *)(unsigned int)(signed int)floor(10.0 * (v409 * v403) * 1000.0 / v67 + 0.5);
    v247 = floor(v414 * v416 * 1000.0 / v67 + 0.5);
    v248 = v246;
    v324 = (signed int)v247;
  }
  *((double *)v248 + 12) = v67;
  *((double *)v248 + 18) = v403;
  if ( v372 == 0.0 )
  {
    v248[13] = 0LL;
    *((double *)v248 + 14) = v227 / v67;
  }
  else
  {
    v248[14] = 0LL;
    *((double *)v248 + 13) = v372 / v67;
  }
  v373 = v248;
  v249 = (char *)malloc(0xCuLL);
  v373[15] = v249;
  if ( !v249 )
    goto LABEL_130;
  *((_WORD *)v249 + 3) = v381;
  *((_WORD *)v373[15] + 4) = v375;
  *((_WORD *)v373[15] + 5) = len;
  *((_WORD *)v373[15] + 1) = v349;
  *(_WORD *)v373[15] = v358;
  *((_WORD *)v373[15] + 2) = v363;
  *((_DWORD *)v373 + 32) = v338;
  v373[17] = v417;
  v250 = sub_143E0(*((_DWORD *)v9 + 10), 0, (signed __int16 **)&v429, (__int64)*v9);
  v75 = v373;
  if ( v250 != 85 || !v429 )
  {
    v280 = sub_143E0(*((_DWORD *)v9 + 10), 4, (signed __int16 **)&v429, (__int64)*v9);
    v75 = v373;
    if ( v280 != 85 || !v429 )
    {
LABEL_130:
      v24 = 1;
      v7 = 80;
      goto LABEL_120;
    }
  }
  if ( *((_DWORD *)v75 + 67) >= 0 )
  {
    endptr = 0LL;
    v76 = *((_DWORD *)v75 + 71);
    if ( !v75[19] )
    {
      v72 = *((_DWORD *)v75 + 71);
      v73 = v75;
      v74 = (char *)malloc(0xCuLL);
      v75 = v73;
      v76 = v72;
      v73[19] = v74;
      if ( !v74 )
        goto LABEL_130;
    }
    if ( v76 >= 0 )
    {
      v410 = v75;
      v306 = sub_14170(v76, 0, (signed __int16 **)&endptr, (__int64)v9);
      v75 = v410;
      if ( v306 == 85 )
      {
        v251 = v410[19];
        if ( endptr && *((_WORD *)endptr + 2) > 0 )
        {
          *(_WORD *)v251 = *(_WORD *)endptr;
          *((_WORD *)v410[19] + 1) = *((_WORD *)endptr + 1);
          *((_WORD *)v410[19] + 2) = *((_WORD *)endptr + 2);
          *((_WORD *)v410[19] + 3) = *((_WORD *)endptr + 3);
          v311 = endptr;
          *((_WORD *)v410[19] + 4) = *((_WORD *)endptr + 4);
          *((_WORD *)v410[19] + 5) = *((_WORD *)v311 + 5);
LABEL_376:
          if ( ((unsigned int)sub_143E0(*((_DWORD *)v9 + 10), 8, (signed __int16 **)&v429, (__int64)*v9) != 85 || !v429)
            && ((unsigned int)sub_143E0(*((_DWORD *)v9 + 10), 12, (signed __int16 **)&v429, (__int64)*v9) != 85 || !v429) )
          {
            goto LABEL_130;
          }
          goto LABEL_167;
        }
LABEL_375:
        *(_WORD *)v251 = v397;
        *((_WORD *)v75[19] + 1) = v407;
        *((_WORD *)v75[19] + 2) = v400;
        *((_WORD *)v75[19] + 3) = v381;
        *((_WORD *)v75[19] + 4) = v375;
        *((_WORD *)v75[19] + 5) = v324;
        goto LABEL_376;
      }
      endptr = 0LL;
    }
    v251 = v75[19];
    goto LABEL_375;
  }
LABEL_167:
  if ( v346 == 2 )
  {
    *(_DWORD *)(v6 + 88) = v338;
    if ( v315 )
    {
      v315[9] = v349;
      v315[10] = v363;
      v315[8] = v358;
      v315[12] = v375;
      v339 = v375;
      v315[11] = v381;
      v347 = v381;
      v315[13] = len;
      *(_QWORD *)(v315 + 14) = *((_QWORD *)v315 + 2);
      *((_DWORD *)v315 + 9) = *((_DWORD *)v315 + 6);
      goto LABEL_270;
    }
    goto LABEL_260;
  }
  if ( !v315 )
  {
LABEL_260:
    if ( nmemb )
      *(_QWORD *)(nmemb + 152) = v9;
    goto LABEL_120;
  }
  v89 = *v9;
  endptr = 0LL;
  v90 = v315[1];
  v376 = v89[50] & 0x400;
  v418 = v90 + 1 - *v315;
  v382 = v315[2];
  if ( v315[3] < v315[2] )
  {
    v140 = -32767;
    v368 = 0x7FFF;
    v339 = -32767;
    v347 = -32767;
    v138 = 0x7FFF;
    lena = -32767;
    v350 = -32767;
    v139 = 0x7FFF;
    v364 = -32767;
    v377 = 0x7FFF;
    stringb = 0x7FFF;
    v320 = 0x7FFF;
    LOWORD(v359) = -32767;
LABEL_419:
    *(_DWORD *)(v6 + 88) = 0;
    goto LABEL_269;
  }
  stringa = v315[2] << 8;
  v339 = -32767;
  v347 = -32767;
  v91 = 0LL;
  v350 = -32767;
  v364 = -32767;
  v413 = (__int64)v9;
  v419 = v18;
  v92 = 0x7FFF;
  v367 = -32767;
  v93 = 0x7FFF;
  v94 = 0x7FFF;
  v423 = v6;
  v359 = -32767;
  v411 = 0LL;
  v95 = 0x7FFF;
  v408 = 0LL;
  v404 = 0;
  v96 = -32767;
  v319 = 0;
  v421 = v25;
  v97 = 0x7FFF;
  v422 = v7;
  v98 = 0x7FFF;
  while ( 2 )
  {
    if ( !v91 || !(v319 & 1) )
      goto LABEL_183;
    v100 = v89[66];
    if ( v376 )
    {
      if ( v100 < stringa )
      {
LABEL_173:
        v99 = *((signed __int16 *)v91 + 2);
        v319 = 1;
        if ( (_WORD)v99 )
        {
          v404 += v418;
          v408 += v418 * abs(v99);
          v411 += v418 * v99;
          goto LABEL_175;
        }
        goto LABEL_183;
      }
    }
    else if ( v100 >= stringa )
    {
      goto LABEL_182;
    }
    if ( (v89[67] & 0xFF00) > stringa )
      goto LABEL_173;
LABEL_182:
    v319 = 0;
LABEL_183:
    v101 = *v315;
    if ( v101 > v90 )
      goto LABEL_175;
    v102 = v97;
    v103 = v92;
    v104 = v93;
    v105 = v95;
    v106 = v94;
    v107 = v102;
    do
    {
      v119 = v89[67];
      v120 = v101 | stringa;
      if ( v376 )
      {
        if ( v119 >= v120 )
          goto LABEL_187;
      }
      else if ( v119 < v120 )
      {
        goto LABEL_225;
      }
      if ( v120 < v89[66] )
      {
LABEL_225:
        v108 = 0;
LABEL_226:
        v121 = v96;
        v122 = v98;
        v123 = v107;
        v124 = v89;
        endptr = 0LL;
        v125 = sub_14170(v120, v108, (signed __int16 **)&endptr, v413);
        v89 = v124;
        v107 = v123;
        v98 = v122;
        v96 = v121;
        v90 = v315[1];
        if ( v125 != 85 )
          goto LABEL_221;
        goto LABEL_188;
      }
LABEL_187:
      v108 = 8;
      if ( v319 != 1 )
        goto LABEL_226;
LABEL_188:
      if ( endptr )
      {
        v109 = *((_WORD *)endptr + 3);
        if ( (signed __int16)v106 > v109 )
          v106 = *((unsigned __int16 *)endptr + 3);
        if ( v347 >= v109 )
          v109 = v347;
        v347 = v109;
        v110 = *((_WORD *)endptr + 4);
        if ( (signed __int16)v107 > v110 )
          v107 = *((unsigned __int16 *)endptr + 4);
        if ( v339 >= v110 )
          v110 = v339;
        v339 = v110;
        v111 = *(_WORD *)endptr;
        if ( (signed __int16)v104 > *(_WORD *)endptr )
          v104 = *(unsigned __int16 *)endptr;
        if ( v364 >= v111 )
          v111 = v364;
        v112 = v350;
        v364 = v111;
        v113 = *((signed __int16 *)endptr + 1);
        if ( (signed __int16)v105 > *((_WORD *)endptr + 1) )
          v105 = *((signed __int16 *)endptr + 1);
        if ( v350 < (signed __int16)v113 )
          v112 = *((_WORD *)endptr + 1);
        v350 = v112;
        v114 = *((_WORD *)endptr + 2);
        v115 = *((_WORD *)endptr + 5);
        if ( (signed __int16)v103 > v114 )
          v103 = *((unsigned __int16 *)endptr + 2);
        if ( (signed __int16)v96 < v114 )
          v96 = *((unsigned __int16 *)endptr + 2);
        if ( (signed __int16)v98 > v115 )
          v98 = *((unsigned __int16 *)endptr + 5);
        if ( v115 <= v367 )
          v115 = v367;
        v367 = v115;
        v116 = v113 - v114;
        if ( v359 >= v116 )
          v116 = v359;
        v359 = v116;
        if ( v114 )
        {
          ++v404;
          v117 = -v114;
          if ( v114 >= 0 )
            v117 = v114;
          v411 += v114;
          v408 += v117;
          v118 = 1;
          if ( !v108 )
            v118 = v319;
          v319 = v118;
        }
      }
LABEL_221:
      ++v101;
    }
    while ( v101 <= v90 );
    v126 = v107;
    v94 = v106;
    v95 = v105;
    v93 = v104;
    v92 = v103;
    v97 = v126;
LABEL_175:
    ++v382;
    stringa += 256;
    if ( v382 <= v315[3] )
    {
      v91 = endptr;
      continue;
    }
    break;
  }
  v138 = v94;
  v139 = v95;
  v320 = v93;
  stringb = v92;
  v377 = v97;
  v140 = v367;
  v368 = v98;
  v25 = v421;
  v18 = v419;
  v9 = (_QWORD **)v413;
  v24 = 0;
  lena = v96;
  v7 = v422;
  v6 = v423;
  if ( v404 <= 0 )
    goto LABEL_419;
  v141 = ((double)(signed int)v408 * 10.0 + 0.5 * (double)v404) / (double)v404;
  LODWORD(v142) = (signed int)v141;
  if ( v411 < 0 )
    v142 = -(signed __int64)(unsigned int)(signed int)v141;
  *(_DWORD *)(v423 + 88) = v142;
LABEL_269:
  v315[13] = v140;
  v315[15] = v139;
  v315[9] = v350;
  v315[8] = v364;
  v315[10] = lena;
  v315[17] = v138;
  v315[12] = v339;
  v315[11] = v347;
  v315[14] = v320;
  v315[16] = stringb;
  v315[18] = v377;
  v315[6] = v359;
  v315[19] = v368;
LABEL_270:
  v143 = v315;
  v144 = *((_QWORD *)v315 + 2);
  *((_BYTE *)v143 + 10) |= 0x20u;
  v315[32] = v347;
  *((_QWORD *)v315 + 5) = v144;
  LODWORD(v144) = *((_DWORD *)v315 + 6);
  v315[33] = v339;
  *((_DWORD *)v315 + 12) = v144;
  *(_QWORD *)(v143 + 26) = *(_QWORD *)(v143 + 14);
  *((_DWORD *)v143 + 15) = *((_DWORD *)v143 + 9);
  v315[4] = 0;
  FontComputeInfoAccelerators(v315);
  if ( nmemb )
    *(_QWORD *)(nmemb + 152) = v9;
  v321 = *(void **)v316;
  v378 = (__int64)*v9;
  v145 = *(_QWORD *)(**v9 + 8LL);
  v317 = (char *)**v9;
  v146 = 2048;
  if ( *(_WORD *)(v145 + 136) )
    v146 = *(unsigned __int16 *)(v145 + 136);
  v360 = v146;
  v340 = FT_Get_Sfnt_Table(v145, 2LL);
  v147 = (char **)FT_Get_Sfnt_Table(*((_QWORD *)v317 + 1), 5LL);
  v148 = FT_Get_PS_Font_Info(*((_QWORD *)v317 + 1), &endptr);
  v149 = v147;
  v150 = &endptr;
  v151 = 0LL;
  if ( !v148 )
    v149 = 0LL;
  if ( v148 )
  {
    v150 = 0LL;
    if ( v148 )
      v151 = (signed __int16 *)v340;
  }
  v351 = v150;
  v341 = v151;
  *((_DWORD *)v315 + 17) = 0;
  __strcpy_chk(&v448, v321, 1024LL);
  v152 = (unsigned int)FontParseXLFDName(&v448) < 1 ? 6 : 20;
  if ( !*((_DWORD *)v317 + 4) )
    v152 += 3;
  if ( v380 )
  {
    if ( v341 )
    {
      v152 += 8;
      v383 = 1;
    }
    else
    {
      v152 += 2;
      v383 = 0;
    }
    if ( v149 || (v153 = 0, v351) )
      v153 = 3;
  }
  else
  {
    v383 = 0;
    v153 = 0;
  }
  nmemba = v152 + v153 + 2;
  v322 = malloc(16 * nmemba);
  *((_QWORD *)v315 + 9) = v322;
  if ( !v322 )
    goto LABEL_130;
  v154 = calloc(nmemba, 1uLL);
  *((_QWORD *)v315 + 10) = v154;
  if ( v154 )
  {
    v155 = &v448;
    **((_QWORD **)v315 + 9) = MakeAtom("FONT", 4u, 1);
    do
    {
      v156 = *(_DWORD *)v155;
      v155 += 4;
      v157 = ~v156 & (v156 - 16843009) & 0x80808080;
    }
    while ( !v157 );
    if ( !((unsigned __int16)~(_WORD)v156 & (unsigned __int16)(v156 - 257) & 0x8080) )
      LOBYTE(v157) = (~v156 & (v156 - 16843009) & 0x80808080) >> 16;
    if ( !((unsigned __int16)~(_WORD)v156 & (unsigned __int16)(v156 - 257) & 0x8080) )
      LODWORD(v155) = (_DWORD)v155 + 2;
    *(_QWORD *)(*((_QWORD *)v315 + 9) + 8LL) = MakeAtom(
                                                 &v448,
                                                 (_DWORD)v155
                                               - (__CFADD__((_BYTE)v157, (_BYTE)v157)
                                                + 3)
                                               - (unsigned int)&v448,
                                                 1);
    **((_BYTE **)v315 + 10) = 1;
    if ( v448 && v449 )
    {
      v398 = v25;
      v401 = v24;
      v405 = v7;
      lenb = v9;
      v158 = 0LL;
      v159 = 1LL;
      v393 = v18;
      v160 = &v449;
      while ( 1 )
      {
        v161 = *v160;
        if ( v158 == 13 )
        {
          for ( i = v160; *i && *i != 91; ++i )
            ;
          v167 = MakeAtom("CHARSET_ENCODING", 0x10u, 1);
          v166 = 16 * v159;
          *(_QWORD *)(*((_QWORD *)v315 + 9) + 16 * v159) = v167;
        }
        else
        {
          if ( v161 != 45 && (i = v160, v161) )
          {
            do
              ++i;
            while ( *i && *i != 45 );
          }
          else
          {
            i = v160;
          }
          v163 = off_23A800[v158];
          v164 = strlen(off_23A800[v158]);
          v165 = MakeAtom(v163, v164, 1);
          v166 = 16 * v159;
          *(_QWORD *)(*((_QWORD *)v315 + 9) + 16 * v159) = v165;
          switch ( (_DWORD)v158 )
          {
            case 6:
              *(_QWORD *)(*((_QWORD *)v315 + 9) + v166 + 8) = (signed int)(COERCE_DOUBLE(*(_QWORD *)(v6 + 32) & xmmword_30160)
                                                                         + 0.5);
              goto LABEL_305;
            case 7:
              *(_QWORD *)(*((_QWORD *)v315 + 9) + v166 + 8) = (signed int)(COERCE_DOUBLE(*(_QWORD *)(v6 + 64) & xmmword_30160)
                                                                         * 10.0
                                                                         + 0.5);
              goto LABEL_305;
            case 8:
              *(_QWORD *)(*((_QWORD *)v315 + 9) + v166 + 8) = *(signed int *)(v6 + 80);
              goto LABEL_305;
            case 9:
              *(_QWORD *)(*((_QWORD *)v315 + 9) + v166 + 8) = *(signed int *)(v6 + 84);
              goto LABEL_305;
            case 0xB:
              *(_QWORD *)(*((_QWORD *)v315 + 9) + v166 + 8) = *(signed int *)(v6 + 88);
              goto LABEL_305;
            default:
              break;
          }
        }
        *(_QWORD *)(*((_QWORD *)v315 + 9) + v166 + 8) = MakeAtom(v160, (signed int)i - (signed int)v160, 1);
        *(_BYTE *)(*((_QWORD *)v315 + 10) + v159) = 1;
        v369 = v159 + 1;
        if ( v159 == 14 )
          break;
LABEL_305:
        v160 = i + 1;
        ++v158;
        ++v159;
      }
      v24 = v401;
      v9 = lenb;
      v18 = v393;
      v25 = v398;
      v7 = v405;
    }
    else
    {
      v369 = 1;
    }
    v168 = 16LL * v369;
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v168) = MakeAtom(aRawPixel, 0xEu, 1);
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v168 + 8) = 1000LL;
    v169 = MakeAtom(aRaw, 0xEu, 1);
    v170 = 16LL * v369;
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v168 + 16) = v169;
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v168 + 24) = (unsigned int)(signed int)(72270.0
                                                                              / (double)*(signed int *)(v6 + 84)
                                                                              + 0.5);
    nmembb = v369 + 2;
    if ( !*((_DWORD *)v317 + 4) )
    {
      v298 = v170 + 32;
      *(_QWORD *)(*((_QWORD *)v315 + 9) + v170 + 32) = MakeAtom("RAW_AVERAGE_WIDTH", 0x11u, 1);
      *(_QWORD *)(*((_QWORD *)v315 + 9) + v298 + 8) = (signed int)v417;
      nmembb = v369 + 3;
    }
    if ( v380 )
    {
      v297 = (char **)(16LL * nmembb++);
      *(char **)((char *)v297 + *((_QWORD *)v315 + 9)) = (char *)MakeAtom("FONT_ASCENT", 0xBu, 1);
      *(char **)((char *)v297 + *((_QWORD *)v315 + 9) + 8) = (char *)(signed __int16)v315[32];
    }
    if ( !*((_DWORD *)v317 + 4) )
    {
      v296 = (char **)(16LL * nmembb++);
      *(char **)((char *)v296 + *((_QWORD *)v315 + 9)) = (char *)MakeAtom("RAW_ASCENT", 0xAu, 1);
      *(char **)((char *)v296 + *((_QWORD *)v315 + 9) + 8) = (char *)(unsigned int)(signed int)((double)*(signed __int16 *)(*((_QWORD *)v317 + 1) + 138LL)
                                                                                              / (double)v360
                                                                                              * 1000.0);
    }
    if ( v380 )
    {
      v295 = (char **)(16LL * nmembb++);
      *(char **)((char *)v295 + *((_QWORD *)v315 + 9)) = (char *)MakeAtom("FONT_DESCENT", 0xCu, 1);
      *(char **)((char *)v295 + *((_QWORD *)v315 + 9) + 8) = (char *)(signed __int16)v315[33];
    }
    if ( !*((_DWORD *)v317 + 4) )
    {
      v285 = (char **)(16LL * nmembb++);
      *(char **)((char *)v285 + *((_QWORD *)v315 + 9)) = (char *)MakeAtom("RAW_DESCENT", 0xBu, 1);
      *(char **)((char *)v285 + *((_QWORD *)v315 + 9) + 8) = (char *)(unsigned int)(signed int)COERCE_DOUBLE(COERCE_UNSIGNED_INT64((double)*(signed __int16 *)(*((_QWORD *)v317 + 1) + 140LL) / (double)v360 * 1000.0) ^ xmmword_30670);
    }
    v171 = FTGetEnglishName(*((_QWORD *)v317 + 1), 0LL, &v448, 1024LL);
    v172 = &v448;
    if ( v171 < 0 )
    {
      if ( v351 )
      {
        v172 = v351[1];
        if ( v172 )
        {
          v171 = strlen(v351[1]);
          goto LABEL_328;
        }
        v175 = FTGetEnglishName(*((_QWORD *)v317 + 1), 4LL, &v448, 1024LL);
        if ( v175 < 0 )
          goto LABEL_442;
      }
      else
      {
        v175 = FTGetEnglishName(*((_QWORD *)v317 + 1), 4LL, &v448, 1024LL);
        if ( v175 < 0 )
          goto LABEL_333;
      }
      v176 = &v448;
      goto LABEL_331;
    }
LABEL_328:
    v394 = v172;
    lenc = v171;
    if ( v171 > 0 )
    {
      v173 = (char **)nmembb;
      v174 = (char **)(16LL * nmembb++);
      *(char **)((char *)v174 + *((_QWORD *)v315 + 9)) = (char *)MakeAtom("COPYRIGHT", 9u, 1);
      *(char **)((char *)v174 + *((_QWORD *)v315 + 9) + 8) = (char *)MakeAtom(v394, lenc, 1);
      *((_BYTE *)v173 + *((_QWORD *)v315 + 10)) = 1;
    }
    v175 = FTGetEnglishName(*((_QWORD *)v317 + 1), 4LL, &v448, 1024LL);
    v176 = &v448;
    if ( v175 >= 0 )
    {
LABEL_331:
      v395 = v176;
      lend = v175;
      if ( v175 > 0 )
      {
        v177 = (char **)nmembb;
        v178 = (char **)(16LL * nmembb++);
        *(char **)((char *)v178 + *((_QWORD *)v315 + 9)) = (char *)MakeAtom("FACE_NAME", 9u, 1);
        *(char **)((char *)v178 + *((_QWORD *)v315 + 9) + 8) = (char *)MakeAtom(v395, lend, 1);
        *((_BYTE *)v177 + *((_QWORD *)v315 + 10)) = 1;
      }
      goto LABEL_333;
    }
    if ( !v351 )
      goto LABEL_333;
LABEL_442:
    v176 = v351[2];
    if ( v176 )
    {
      v175 = strlen(v351[2]);
      goto LABEL_331;
    }
LABEL_333:
    v179 = (const char *)FT_Get_Postscript_Name(*((_QWORD *)v317 + 1));
    if ( v179 && (v180 = (char **)v179, v181 = strlen(v179), v182 = (char *)v180, v181 >= 0) )
    {
LABEL_335:
      lene = v182;
      v370 = v181;
      if ( v181 > 0 )
      {
        v183 = (char **)nmembb;
        v184 = (char *)(16LL * nmembb++);
        *(_QWORD *)&v184[*((_QWORD *)v315 + 9)] = MakeAtom("_ADOBE_POSTSCRIPT_FONTNAME", 0x1Au, 1);
        *(_QWORD *)&v184[*((_QWORD *)v315 + 9) + 8] = MakeAtom(lene, v370, 1);
        *((_BYTE *)v183 + *((_QWORD *)v315 + 10)) = 1;
      }
    }
    else
    {
      v181 = FTGetEnglishName(*((_QWORD *)v317 + 1), 6LL, &v448, 1024LL);
      if ( v181 >= 0 )
      {
        v182 = &v448;
        goto LABEL_335;
      }
      if ( v351 )
      {
        v182 = v351[2];
        if ( v182 )
        {
          v181 = strlen(v351[2]);
          goto LABEL_335;
        }
      }
    }
    if ( v383 )
    {
      v286 = (char *)(16LL * nmembb);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9)] = MakeAtom("SUBSCRIPT_SIZE", 0xEu, 1);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 8] = (signed int)floor(
                                                                  (double)v341[6] / (double)v360 * *(double *)(v6 + 32)
                                                                + 0.5);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 16] = MakeAtom("SUBSCRIPT_X", 0xBu, 1);
      *(_QWORD *)(*((_QWORD *)v315 + 9) + 16LL * nmembb + 16 + 8) = (signed int)floor(
                                                                                  (double)v341[7]
                                                                                / (double)v360
                                                                                * *(double *)(v6 + 8)
                                                                                + 0.5);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 32] = MakeAtom("SUBSCRIPT_Y", 0xBu, 1);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 40] = (signed int)floor(
                                                                   (double)v341[8] / (double)v360 * *(double *)(v6 + 32)
                                                                 + 0.5);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 48] = MakeAtom("SUPERSCRIPT_SIZE", 0x10u, 1);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 56] = (signed int)floor(
                                                                   (double)v341[10]
                                                                 / (double)v360
                                                                 * *(double *)(v6 + 32)
                                                                 + 0.5);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 64] = MakeAtom("SUPERSCRIPT_X", 0xDu, 1);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 72] = (signed int)floor(
                                                                   (double)v341[11] / (double)v360 * *(double *)(v6 + 8)
                                                                 + 0.5);
      *(_QWORD *)(*((_QWORD *)v315 + 9) + 16LL * nmembb + 80) = MakeAtom("SUPERSCRIPT_Y", 0xDu, 1);
      *(_QWORD *)&v286[*((_QWORD *)v315 + 9) + 88] = (signed int)floor(
                                                                   (double)v341[12]
                                                                 / (double)v360
                                                                 * *(double *)(v6 + 32)
                                                                 + 0.5);
      stringc = nmembb + 6;
    }
    else
    {
      if ( !v380 )
        goto LABEL_339;
      stringc = nmembb;
    }
    if ( v149 || (nmembb = stringc, v351) )
    {
      v287 = *(double *)(v6 + 32);
      v288 = (double)v360;
      if ( v149 )
      {
        v355 = (double)v360;
        v342 = *(double *)(v6 + 32);
        nmembc = (signed int)floor((double)-*((signed __int16 *)v149 + 8) / v288 * v287 + 0.5);
        v289 = *((signed __int16 *)v149 + 9);
      }
      else
      {
        v308 = v351;
        v355 = (double)v360;
        v342 = v287;
        nmembc = (signed int)floor((double)-*((signed __int16 *)v308 + 25) / v288 * v287 + 0.5);
        v289 = *((unsigned __int16 *)v308 + 26);
      }
      v325 = (signed int)floor((double)v289 / v355 * v342 + 0.5);
      v290 = MakeAtom("UNDERLINE_THICKNESS", 0x13u, 1);
      v291 = 16LL * stringc;
      v292 = v291;
      *(_QWORD *)(*((_QWORD *)v315 + 9) + v291) = v290;
      v293 = 1LL;
      if ( v325 > 0 )
        v293 = v325;
      *(_QWORD *)(*((_QWORD *)v315 + 9) + v291 + 8) = v293;
      *(_QWORD *)(*((_QWORD *)v315 + 9) + v291 + 16) = MakeAtom("UNDERLINE_POSITION", 0x12u, 1);
      *(_QWORD *)(*((_QWORD *)v315 + 9) + v292 + 24) = nmembc;
      nmembb = stringc + 2;
      if ( v149 && *(_QWORD *)(v378 + 32) == *(_QWORD *)(v378 + 56) )
      {
        *(_QWORD *)(*((_QWORD *)v315 + 9) + v292 + 32) = MakeAtom("ITALIC_ANGLE", 0xCu, 1);
        *(_QWORD *)(*((_QWORD *)v315 + 9) + v292 + 32 + 8) = ((signed __int64)v149[1] >> 10) + 5760;
        nmembb = stringc + 3;
      }
    }
LABEL_339:
    v185 = 16LL * nmembb;
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v185) = MakeAtom("FONT_TYPE", 9u, 1);
    v186 = (const char *)FT_Get_X11_Font_Format(*((_QWORD *)v317 + 1));
    v187 = (char *)v186;
    v188 = strlen(v186);
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v185 + 8) = MakeAtom(v187, v188, 1);
    *(_BYTE *)(*((_QWORD *)v315 + 10) + nmembb) = 1;
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v185 + 16) = MakeAtom("RASTERIZER_NAME", 0xFu, 1);
    *(_QWORD *)(*((_QWORD *)v315 + 9) + v185 + 16 + 8) = MakeAtom("FreeType", 0xAu, 1);
    *(_BYTE *)(*((_QWORD *)v315 + 10) + nmembb + 1) = 1;
    *((_DWORD *)v315 + 17) = nmembb + 2;
  }
  else
  {
    v24 = 1;
    v7 = 80;
    free(v322);
  }
LABEL_120:
  if ( ptra )
    free(ptra);
LABEL_27:
  free(v18);
  free(sb);
  if ( v24 )
  {
    if ( v25 && !*v9 && !v25[3] )
      sub_11300(v25);
LABEL_34:
    sub_113D0(v9);
  }
  return v7;
}
// 8170: using guessed type __int64 __fastcall FT_Get_X11_Font_Format(_QWORD);
// 81B0: using guessed type __int64 __fastcall FT_Get_Postscript_Name(_QWORD);
// 8300: using guessed type __int64 __fastcall FTGetEnglishName(_QWORD, _QWORD, _QWORD, _QWORD);
// 8570: using guessed type __int64 __fastcall FT_New_Face(_QWORD, _QWORD, _QWORD, _QWORD);
// 85C0: using guessed type __int64 __fastcall FT_Init_FreeType(_QWORD);
// 8620: using guessed type __int64 __fastcall FontComputeInfoAccelerators(_QWORD);
// 8650: using guessed type __int64 __fastcall SPropRecValList_new(_QWORD, _QWORD);
// 86E0: using guessed type __int64 __fastcall FT_Get_PS_Font_Info(_QWORD, _QWORD);
// 87C0: using guessed type __int64 __fastcall FT_Get_Sfnt_Table(_QWORD, _QWORD);
// 8AD0: using guessed type __int64 __fastcall SPropRecValList_add_by_font_cap(_QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 8C60: using guessed type __int64 __fastcall SPropRecValList_search_record(_QWORD, _QWORD, _QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);
// 30160: using guessed type __int128 xmmword_30160;
// 30670: using guessed type __int128 xmmword_30670;
// 23A800: using guessed type char *off_23A800[6];
// 23CC80: using guessed type int dword_23CC80;

//----- (0000000000018790) ----------------------------------------------------
__int64 __fastcall sub_18790(__int64 a1, unsigned __int16 *a2, char *a3, __int64 a4, char *a5, __int64 a6)
{
  char *v6; // r14
  char *v7; // r12
  __int64 v8; // r13
  __int64 result; // rax
  __int64 _0; // [rsp+0h] [rbp+0h]
  int vars8; // [rsp+8h] [rbp+8h]
  unsigned __int64 vars18; // [rsp+18h] [rbp+18h]

  v6 = a3;
  v7 = a5;
  v8 = a6;
  vars18 = __readfsqword(0x28u);
  result = sub_11180(a1, 0LL, (__int64)a2, 0, 0, &_0);
  if ( (_DWORD)result == 85 )
  {
    vars8 *= 8;
    result = sub_148D0(v7, v8, 0LL, a2, (const __m128i *)&_0, v6);
  }
  return result;
}

//----- (0000000000018820) ----------------------------------------------------
__int64 __fastcall sub_18820(__int64 a1, FontPtr *a2, __int64 a3, char *a4, char *a5, __int64 a6, unsigned int a7, unsigned int a8)
{
  char *v8; // r13
  char *v9; // rbp
  __int64 v10; // r12
  FontPtr v11; // rbx
  __int64 result; // rax
  unsigned int v13; // [rsp+0h] [rbp-68h]
  __m128i v14; // [rsp+10h] [rbp-58h]
  unsigned __int64 v15; // [rsp+28h] [rbp-40h]

  v8 = a4;
  v9 = a5;
  v10 = a6;
  v15 = __readfsqword(0x28u);
  v11 = CreateFontRec();
  result = 80LL;
  if ( v11 )
  {
    v13 = sub_11180(a1, (__int64)v11, (__int64)&v11->info, a7, a8, &v14);
    if ( v13 != 85 )
    {
LABEL_3:
      DestroyFontRec(v11);
      return v13;
    }
    result = sub_148D0(v9, v10, (size_t)v11, &v11->info.firstCol, &v14, v8);
    if ( (_DWORD)result != 85 )
    {
      v13 = result;
      goto LABEL_3;
    }
    *a2 = v11;
  }
  return result;
}

//----- (0000000000018900) ----------------------------------------------------
__int64 FreeTypeRegisterFontFileFunctions()
{
  FontFileRegisterRenderer(&off_23B920);
  FontFileRegisterRenderer(&off_23B958);
  FontFileRegisterRenderer(&off_23B990);
  FontFileRegisterRenderer(&off_23B9C8);
  FontFileRegisterRenderer(&off_23BA00);
  FontFileRegisterRenderer(&off_23BA38);
  FontFilePriorityRegisterRenderer(&off_23B8A0, 4294967286LL);
  return FontFilePriorityRegisterRenderer(&off_23B8D8, 4294967286LL);
}
// 86D0: using guessed type __int64 __fastcall FontFileRegisterRenderer(_QWORD);
// 8B50: using guessed type __int64 __fastcall FontFilePriorityRegisterRenderer(_QWORD, _QWORD);
// 23B8A0: using guessed type char *off_23B8A0;
// 23B8D8: using guessed type char *off_23B8D8;
// 23B920: using guessed type char *off_23B920;
// 23B958: using guessed type char *off_23B958;
// 23B990: using guessed type char *off_23B990;
// 23B9C8: using guessed type char *off_23B9C8;
// 23BA00: using guessed type char *off_23BA00;
// 23BA38: using guessed type char *off_23BA38;

//----- (0000000000018980) ----------------------------------------------------
signed __int64 __fastcall sub_18980(__int64 a1, int a2, int a3, int a4, __m128i *a5)
{
  int v5; // er14
  int v6; // eax
  int v7; // ebp
  unsigned int v8; // er15
  __m128i v9; // xmm0
  signed __int64 result; // rax
  int v11; // [rsp+4h] [rbp-64h]
  __m128i *v12; // [rsp+8h] [rbp-60h]
  __int128 v13; // [rsp+10h] [rbp-58h]
  __int64 v14; // [rsp+20h] [rbp-48h]
  unsigned __int64 v15; // [rsp+28h] [rbp-40h]

  v5 = a3;
  v15 = __readfsqword(0x28u);
  v11 = a4;
  v12 = a5;
  v6 = FT_Get_Sfnt_Name_Count();
  if ( v6 > 0 )
  {
    v7 = v6;
    v8 = 0;
    do
    {
      if ( !(unsigned int)FT_Get_Sfnt_Name(a1, v8, &v13)
        && WORD3(v13) == a2
        && (unsigned __int16)v13 == v5
        && (v11 == -1 || WORD1(v13) == v11) )
      {
        if ( (unsigned __int16)v13 <= 1u )
        {
          if ( !WORD2(v13) )
            goto LABEL_12;
        }
        else if ( (_WORD)v13 != 3 || (WORD2(v13) - 1033) & 0xFBFF )
        {
LABEL_12:
          v9 = _mm_load_si128((const __m128i *)&v13);
          v12[1].m128i_i64[0] = v14;
          result = 1LL;
          *v12 = v9;
          return result;
        }
      }
      ++v8;
    }
    while ( v7 != v8 );
  }
  return 0LL;
}
// 7FE0: using guessed type __int64 FT_Get_Sfnt_Name_Count(void);
// 8FE0: using guessed type __int64 __fastcall FT_Get_Sfnt_Name(_QWORD, _QWORD, _QWORD);

//----- (0000000000018A90) ----------------------------------------------------
__int64 __fastcall FTtoXReturnCode(int a1)
{
  return 3 * (unsigned int)(a1 != 64) + 80;
}

//----- (0000000000018AA0) ----------------------------------------------------
__int64 __fastcall FTGetEnglishName(__int64 a1, int a2, _BYTE *a3, signed int a4)
{
  signed int v4; // er12
  _BYTE *v5; // rbx
  _BYTE *v6; // rdx
  signed __int64 v7; // rcx
  _BYTE *v8; // rax
  int v9; // ebp
  __int64 v11; // [rsp+0h] [rbp-48h]
  void *src; // [rsp+8h] [rbp-40h]
  int v13; // [rsp+10h] [rbp-38h]
  unsigned __int64 v14; // [rsp+18h] [rbp-30h]

  v4 = a4;
  v5 = a3;
  v14 = __readfsqword(0x28u);
  if ( (unsigned int)sub_18980(a1, a2, 3, 1, (__m128i *)&v11) || (unsigned int)sub_18980(a1, a2, 0, -1, (__m128i *)&v11) )
  {
    v6 = src;
    if ( v13 > 0 && v4 > 1 )
    {
      v7 = (signed __int64)&v5[((unsigned int)(v13 - 1) >> 1) + 1];
      v8 = v5;
      while ( 1 )
      {
        ++v8;
        if ( *v6 )
        {
          *(v8 - 1) = 63;
          v9 = (_DWORD)v8 - (_DWORD)v5;
          if ( v8 == (_BYTE *)v7 )
            goto LABEL_9;
        }
        else
        {
          v9 = (_DWORD)v8 - (_DWORD)v5;
          *(v8 - 1) = v6[1];
          if ( v8 == (_BYTE *)v7 )
            goto LABEL_9;
        }
        v6 += 2;
        if ( v8 == &v5[v4 - 2 + 1] )
          goto LABEL_9;
      }
    }
    v8 = v5;
    v9 = 0;
LABEL_9:
    *v8 = 0;
  }
  else if ( (unsigned int)sub_18980(a1, a2, 1, 0, (__m128i *)&v11) )
  {
    v9 = v13;
    if ( v13 >= v4 )
      v9 = v4 - 1;
    memcpy(v5, src, v9);
    v5[v9] = 0;
  }
  else
  {
    v9 = -1;
  }
  return (unsigned int)v9;
}

//----- (0000000000018C10) ----------------------------------------------------
__int64 __fastcall sub_18C10(double **a1, const char *a2, char *a3)
{
  __int64 v3; // r15
  double **v4; // r13
  const char *v5; // rdi
  unsigned int v6; // er14
  char **v7; // rbx
  char *v8; // rax
  double *v9; // rax
  double *v10; // rdx
  const char *v12; // rdx
  const char *v13; // rcx
  unsigned int v14; // eax
  double v15; // xmm0_8
  char *s; // [rsp+0h] [rbp-58h]
  double v17; // [rsp+8h] [rbp-50h]
  char *endptr; // [rsp+10h] [rbp-48h]
  unsigned __int64 v19; // [rsp+18h] [rbp-40h]

  v3 = 0LL;
  v4 = a1;
  v5 = "FontFile";
  s = a3;
  v19 = __readfsqword(0x28u);
  while ( 1 )
  {
    v6 = strcasecmp(v5, a2);
    if ( !v6 )
      break;
    if ( ++v3 == 17 )
    {
      v12 = "truetype font : invalid record name \"%s.\"\n";
      v13 = a2;
LABEL_12:
      v6 = -1;
      __fprintf_chk(stderr, 1LL, v12, v13);
      return v6;
    }
    v5 = off_23A980[2 * v3];
  }
  v7 = &off_23A980[2 * (signed int)v3];
  switch ( *((_DWORD *)v7 + 2) + 1 )
  {
    case 0:
      if ( *s )
      {
        v6 = -1;
        __fprintf_chk(stderr, 1LL, "truetype font property : %s record needs void.\n", a2);
      }
      goto LABEL_8;
    case 1:
      v14 = strtol(s, &endptr, 0);
      if ( !*endptr )
        goto LABEL_29;
      v13 = a2;
      v12 = "truetype font property : %s record needs integer value.\n";
      goto LABEL_12;
    case 2:
      v15 = strtod(s, &endptr);
      if ( !*endptr )
      {
        v17 = v15;
        goto LABEL_8;
      }
      v13 = a2;
      v12 = "truetype font property : %s record needs floating point value.\n";
      goto LABEL_12;
    case 3:
      if ( !strcasecmp(s, "yes")
        || !strcasecmp(s, "y")
        || !strcasecmp(s, "on")
        || !strcasecmp(s, "true")
        || !strcasecmp(s, "t")
        || !strcasecmp(s, "ok") )
      {
        v14 = -1;
      }
      else
      {
        v14 = strcasecmp(s, "no");
        if ( v14 )
        {
          v14 = strcasecmp(s, "n");
          if ( v14 )
          {
            v14 = strcasecmp(s, "off");
            if ( v14 )
            {
              v14 = strcasecmp(s, "false");
              if ( v14 )
              {
                v14 = strcasecmp(s, "f");
                if ( v14 )
                {
                  v14 = strcasecmp(s, "bad");
                  v13 = a2;
                  v12 = "truetype font property : %s record needs boolean value.\n";
                  if ( v14 )
                    goto LABEL_12;
                }
              }
            }
          }
        }
      }
LABEL_29:
      *(_QWORD *)&v17 = v14;
LABEL_8:
      v9 = (double *)malloc(0x18uLL);
      if ( v9 )
      {
        v10 = *v4;
        *(_QWORD *)v9 = v7;
        *v4 = v9;
        *((_QWORD *)v9 + 2) = v10;
        v9[1] = v17;
      }
      else
      {
LABEL_33:
        v6 = -1;
        fwrite("truetype font property : cannot allocate memory.\n", 1uLL, 0x31uLL, stderr);
      }
      break;
    case 4:
      v8 = strdup(s);
      if ( !v8 )
        goto LABEL_33;
      v17 = *(double *)&v8;
      goto LABEL_8;
    default:
      goto LABEL_8;
  }
  return v6;
}
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018F60) ----------------------------------------------------
__int64 __fastcall SPropRecValList_new(_QWORD *a1)
{
  *a1 = 0LL;
  return 0LL;
}

//----- (0000000000018F70) ----------------------------------------------------
signed __int64 __fastcall SPropRecValList_search_record(__int64 *a1, _QWORD *a2, const char *a3)
{
  __int64 v3; // rbx
  const char *v4; // rbp

  *a2 = 0LL;
  v3 = *a1;
  if ( !*a1 )
    return 0LL;
  v4 = a3;
  while ( strcasecmp(**(const char ***)v3, v4) )
  {
    v3 = *(_QWORD *)(v3 + 16);
    if ( !v3 )
      return 0LL;
  }
  *a2 = v3;
  return 0xFFFFFFFFLL;
}

//----- (0000000000018FD0) ----------------------------------------------------
signed __int64 __fastcall SPropRecValList_add_by_font_cap(double **a1, const char *a2)
{
  const char *v2; // r12
  char *v3; // rax
  char *v4; // rbp
  unsigned __int64 v5; // r14
  __int64 v6; // rbx
  const unsigned __int16 *v7; // rax
  char *v8; // rax
  char *v9; // r13
  size_t v10; // rbx
  char *v11; // rbp
  char *v12; // rax
  __int64 v13; // rbx
  const char *i; // rdi
  int v16; // er14
  __int64 v17; // r13
  size_t v18; // rdi
  void *v19; // rbx
  char *v20; // [rsp+0h] [rbp-48h]
  double **v21; // [rsp+8h] [rbp-40h]

  v2 = a2;
  v21 = a1;
  v3 = strrchr(a2, 58);
  if ( v3 )
  {
    v4 = v3 - 1;
    v5 = (unsigned __int64)v3;
    if ( a2 <= v3 - 1 )
    {
      v6 = *(v3 - 1);
      if ( (_BYTE)v6 == 58 )
      {
LABEL_22:
        if ( (char *)v5 != v4 )
        {
          v16 = v5 - (_DWORD)v4;
          LODWORD(v17) = v16 - 1;
          v18 = v16;
          v5 = (unsigned __int64)v4;
          v17 = (signed int)v17;
          v19 = malloc(v18);
          memcpy(v19, v4 + 1, (signed int)v17);
          *((_BYTE *)v19 + v17) = 0;
          sub_18C10(v21, "FaceNumber", (char *)v19);
          free(v19);
        }
      }
      else
      {
        v7 = *__ctype_b_loc();
        while ( v7[v6] & 0x800 )
        {
          if ( --v4 == a2 - 1 )
            break;
          v6 = *v4;
          if ( (_BYTE)v6 == 58 )
            goto LABEL_22;
        }
      }
    }
    if ( (unsigned __int64)a2 < v5 )
    {
      while ( 2 )
      {
        while ( 1 )
        {
          v8 = strchr(v2, 58);
          v9 = v8;
          v10 = v8 - v2;
          if ( v8 - v2 > 0 )
            break;
          v2 = v8 + 1;
          if ( (unsigned __int64)(v8 + 1) >= v5 )
            return 0LL;
        }
        v11 = (char *)malloc(v10 + 1);
        memcpy(v11, v2, v10);
        v11[v10] = 0;
        v20 = &v11[v10];
        v12 = strchr(v11, 61);
        if ( v12 )
        {
          *v12 = 0;
          v20 = v12 + 1;
        }
        v13 = 0LL;
        for ( i = "fn"; strcasecmp(i, v11); i = off_23A880[2 * v13] )
        {
          if ( ++v13 == 15 )
            goto LABEL_21;
        }
        if ( (unsigned int)sub_18C10(v21, off_23A880[2 * (signed int)v13 + 1], v20) )
        {
LABEL_21:
          fwrite("truetype font : Illegal Font Cap.\n", 1uLL, 0x22uLL, stderr);
          return 0xFFFFFFFFLL;
        }
        v2 = v9 + 1;
        free(v11);
        if ( (unsigned __int64)(v9 + 1) < v5 )
          continue;
        break;
      }
    }
  }
  return 0LL;
}
// 23A880: using guessed type char *off_23A880[8];

//----- (00000000000191E0) ----------------------------------------------------
void __fastcall sub_191E0(__int64 a1)
{
  __int64 v1; // r13
  __int64 v2; // rbx
  void **v3; // r14
  char *v4; // rdi
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // eax
  __int64 v9; // rbp
  signed __int64 v10; // r12
  void *v11; // rdi
  __int64 v12; // r12
  int v13; // ebp
  void *v14; // rdi

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 152);
  v3 = *(void ***)(v2 + 56);
  free(*(void **)(v2 + 24));
  v4 = *(char **)(v2 + 40);
  if ( v4 )
  {
    v5 = (*(unsigned __int16 *)(v1 + 14) - *(unsigned __int16 *)(v1 + 12) + 1)
       * (*(unsigned __int16 *)(v1 + 10) - *(unsigned __int16 *)(v1 + 8) + 1);
    v6 = v5 + 254;
    v7 = v5 + 127;
    if ( v7 < 0 )
      v7 = v6;
    v8 = v7 >> 7;
    if ( v8 > 0 )
    {
      v9 = 0LL;
      v10 = 8LL * (unsigned int)(v8 - 1) + 8;
      do
      {
        v11 = *(void **)&v4[v9];
        v9 += 8LL;
        free(v11);
        v4 = *(char **)(v2 + 40);
      }
      while ( v10 != v9 );
    }
  }
  free(v4);
  if ( *(_DWORD *)(v2 + 4) > 0 )
  {
    v12 = 0LL;
    v13 = 0;
    do
    {
      ++v13;
      v14 = *(void **)(*(_QWORD *)(v2 + 16) + v12 + 16);
      v12 += 24LL;
      free(v14);
    }
    while ( *(_DWORD *)(v2 + 4) > v13 );
  }
  free(*(void **)(v2 + 16));
  if ( v3 )
  {
    free(*v3);
    free(v3[1]);
    free(v3);
  }
  free(*(void **)(v1 + 80));
  free((void *)v2);
}

//----- (00000000000192E0) ----------------------------------------------------
void __fastcall sub_192E0(FontPtr font)
{
  sub_191E0((__int64)font);
  DestroyFontRec(font);
}

//----- (0000000000019300) ----------------------------------------------------
signed __int64 __fastcall sub_192F0(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6, int a7)
{
  _WORD *v7; // r15
  __int64 v8; // r12
  __int64 v9; // r13
  _QWORD *v10; // rbp
  const char *v11; // rax
  __int64 v13; // rbp
  void *v14; // rdi
  char *j; // rbx
  _WORD *v16; // rax
  void *v17; // rax
  void *v18; // rax
  const char *v19; // rax
  unsigned int v20; // edx
  bool v21; // cf
  bool v22; // zf
  char *v23; // r15
  const char *v24; // rdi
  signed __int64 v25; // rcx
  const char *v26; // rsi
  int v27; // ebx
  _QWORD *v28; // r13
  const char *v29; // rax
  int v30; // eax
  signed int v31; // edx
  int v32; // er13
  unsigned int v33; // er14
  _QWORD *v34; // rax
  const char *v35; // rax
  const char *v36; // rax
  const char *v37; // rax
  __int64 v38; // rax
  bool v39; // cf
  bool v40; // zf
  const char *v41; // rdi
  signed __int64 v42; // rcx
  _BYTE *v43; // rsi
  bool v44; // cf
  bool v45; // zf
  const char *v46; // rdi
  signed __int64 v47; // rcx
  _BYTE *v48; // rsi
  int v49; // er14
  char *v50; // rdx
  int v51; // ecx
  unsigned int v52; // eax
  int v53; // er13
  const char *v54; // rdi
  signed __int64 v55; // rcx
  bool v56; // cf
  bool v57; // zf
  _BYTE *v58; // rsi
  __int64 v59; // rax
  __int16 v60; // dx
  __int16 v61; // si
  __int16 v62; // cx
  __int16 v63; // r13
  int v64; // eax
  int v65; // ecx
  int v66; // er9
  __int64 v67; // rax
  int v68; // edx
  unsigned int i; // er11
  int v70; // eax
  __int64 v71; // rsi
  int v72; // eax
  const char *v73; // rax
  const char *v74; // r14
  bool v75; // cf
  bool v76; // zf
  const char *v77; // rsi
  signed __int64 v78; // rcx
  const char *v79; // rdi
  char v80; // al
  bool v81; // cf
  bool v82; // zf
  signed __int64 v83; // rcx
  const char *v84; // rsi
  const char *v85; // rdi
  int v86; // eax
  int v87; // er13
  int v88; // ecx
  const char *v89; // r15
  unsigned __int8 *v90; // rbp
  signed __int64 v91; // r13
  const char *v92; // rdi
  unsigned __int8 *v93; // rdx
  unsigned __int8 *v94; // rax
  int v95; // eax
  __int64 v96; // rax
  _BYTE *v97; // r14
  char v98; // al
  unsigned int v99; // er13
  unsigned __int8 *v100; // rax
  _QWORD *v101; // rdx
  bool v102; // cf
  bool v103; // zf
  const char *v104; // rdi
  signed __int64 v105; // rcx
  const char *v106; // rsi
  char v107; // dl
  bool v108; // cf
  bool v109; // zf
  const char *v110; // rdi
  signed __int64 v111; // rcx
  const char *v112; // rsi
  int v113; // ebx
  int v114; // ecx
  int v115; // eax
  int v116; // ebp
  int v117; // eax
  void *v118; // rax
  __int64 v119; // rdx
  unsigned int v120; // edi
  __int64 *v121; // r14
  __int64 v122; // rcx
  __int64 v123; // rsi
  int v124; // er9
  __int64 v125; // rax
  signed __int64 v126; // rbp
  int v127; // er8
  int v128; // er12
  __int64 v129; // rax
  __int64 v130; // r12
  __int64 v131; // rdi
  __int64 v132; // r13
  void **v133; // rbx
  int v134; // ST20_4
  __int64 v135; // ST18_8
  int v136; // ST14_4
  _QWORD *v137; // ST00_8
  void *v138; // rax
  int *v139; // [rsp+0h] [rbp-1198h]
  int v140; // [rsp+14h] [rbp-1184h]
  __int64 v141; // [rsp+18h] [rbp-1180h]
  int v142; // [rsp+20h] [rbp-1178h]
  int v143; // [rsp+24h] [rbp-1174h]
  int string; // [rsp+28h] [rbp-1170h]
  _WORD *v145; // [rsp+30h] [rbp-1168h]
  _WORD *v146; // [rsp+38h] [rbp-1160h]
  unsigned __int8 *ptr; // [rsp+40h] [rbp-1158h]
  int v148; // [rsp+48h] [rbp-1150h]
  int v149; // [rsp+4Ch] [rbp-114Ch]
  signed int v150; // [rsp+58h] [rbp-1140h]
  int v151; // [rsp+5Ch] [rbp-113Ch]
  int v152; // [rsp+68h] [rbp-1130h]
  int v153; // [rsp+6Ch] [rbp-112Ch]
  _QWORD *v154; // [rsp+70h] [rbp-1128h]
  char *v155; // [rsp+78h] [rbp-1120h]
  signed __int64 v156; // [rsp+80h] [rbp-1118h]
  __int64 v157; // [rsp+88h] [rbp-1110h]
  int v158; // [rsp+90h] [rbp-1108h]
  int v159; // [rsp+94h] [rbp-1104h]
  int v160; // [rsp+98h] [rbp-1100h]
  char v161; // [rsp+A3h] [rbp-10F5h]
  int v162; // [rsp+ACh] [rbp-10ECh]
  int v163; // [rsp+BCh] [rbp-10DCh]
  int v164; // [rsp+C0h] [rbp-10D8h]
  int v165; // [rsp+C4h] [rbp-10D4h]
  int v166; // [rsp+C8h] [rbp-10D0h]
  int v167; // [rsp+CCh] [rbp-10CCh]
  int v168; // [rsp+D0h] [rbp-10C8h]
  int v169; // [rsp+D4h] [rbp-10C4h]
  int v170; // [rsp+D8h] [rbp-10C0h]
  int v171; // [rsp+DCh] [rbp-10BCh]
  __int64 v172[256]; // [rsp+E0h] [rbp-10B8h]
  __int64 v173[256]; // [rsp+E8h] [rbp-10B0h]
  char v174; // [rsp+8E0h] [rbp-8B8h]
  char v175; // [rsp+950h] [rbp-848h]
  char v176; // [rsp+D50h] [rbp-448h]
  unsigned __int64 v177; // [rsp+1158h] [rbp-40h]

  v7 = (_WORD *)a2;
  v8 = a1;
  v9 = *(_QWORD *)(a2 + 152);
  v177 = __readfsqword(0x28u);
  v141 = a3;
  v142 = a4;
  v10 = *(_QWORD **)(v9 + 56);
  v143 = a5;
  v140 = a6;
  v139 = 0LL;
  if ( v10 )
  {
    v10[2] = 0LL;
    v10[3] = 0LL;
    v139 = (int *)(v10 + 2);
  }
  *(_QWORD *)(v9 + 16) = 0LL;
  memset(v172, 0, sizeof(v172));
  v11 = (const char *)bdfGetLine(a1, &v175, 1024LL);
  if ( !v11 || sscanf(v11, "CHARS %d", &v163) != 1 )
  {
    bdfError("bad 'CHARS' in bdf file\n");
    return 0LL;
  }
  if ( v163 <= 0 )
  {
    bdfError("invalid number of CHARS in BDF file\n");
    return 0LL;
  }
  if ( v163 > 89478485 )
  {
    v13 = 0LL;
    bdfError("Couldn't allocate pCI (%d*%d)\n");
    goto LABEL_10;
  }
  v16 = calloc(v163, 0x18uLL);
  v145 = v16;
  if ( !v16 )
  {
    v13 = 0LL;
    bdfError("Couldn't allocate pCI (%d*%d)\n");
    goto LABEL_10;
  }
  *(_QWORD *)(v9 + 16) = v16;
  if ( v10 )
  {
    v17 = malloc(8LL * v163);
    *v10 = v17;
    if ( !v17 )
    {
      v13 = 0LL;
      bdfError("Couldn't allocate glyphNames (%d*%d)\n");
      goto LABEL_10;
    }
    v18 = malloc(4LL * v163);
    v10[1] = v18;
    if ( !v18 )
    {
      bdfError("Couldn't allocate sWidth (%d *%d)\n");
      return 0LL;
    }
  }
  v19 = (const char *)bdfGetLine(a1, &v175, 1024LL);
  v20 = v163;
  *(_QWORD *)(a2 + 8) = 1099511628032LL;
  if ( (signed int)v20 <= 0 )
  {
    v114 = 0;
    v153 = 0;
    v148 = 0;
LABEL_220:
    if ( v114 == v20 )
    {
      v102 = 0;
      v103 = v19 == 0LL;
      v163 = v148;
      *(_DWORD *)(v9 + 4) = v148;
      if ( v19 )
        goto LABEL_209;
LABEL_217:
      v13 = v172[0];
LABEL_88:
      bdfError("missing 'ENDFONT'\n");
      goto LABEL_10;
    }
LABEL_199:
    v13 = v172[0];
    goto LABEL_200;
  }
  v21 = 0;
  v22 = v19 == 0LL;
  if ( !v19 )
  {
    v13 = 0LL;
LABEL_200:
    bdfError("%d too few characters\n");
    goto LABEL_10;
  }
  v146 = (_WORD *)a2;
  v153 = 0;
  v158 = 0;
  v148 = 0;
  v23 = &v175;
  v157 = v9;
  while ( 1 )
  {
    v24 = "STARTCHAR";
    v25 = 9LL;
    v26 = v19;
    do
    {
      if ( !v25 )
        break;
      v21 = (const unsigned __int8)*v26 < *v24;
      v22 = *v26++ == *v24++;
      --v25;
    }
    while ( v22 );
    v27 = (char)((!v21 && !v22) - v21);
    if ( (!v21 && !v22) != v21 )
      break;
    if ( sscanf(v19, "STARTCHAR %s", &v174) != 1 )
    {
      bdfError("bad character name in BDF file\n");
      goto LABEL_188;
    }
    if ( v10 )
    {
      v28 = (_QWORD *)(*v10 + 8LL * v148);
      *v28 = bdfForceMakeAtom(&v174);
    }
    v29 = (const char *)bdfGetLine(v8, v23, 1024LL);
    if ( !v29 || (v30 = sscanf(v29, "ENCODING %d %d", &v170, &v171), v30 <= 0) )
    {
      bdfError("bad 'ENCODING' in BDF file\n");
      goto LABEL_188;
    }
    v31 = v170;
    if ( v170 < -1 )
      goto LABEL_201;
    if ( v30 == 2 )
    {
      if ( v171 < -1 )
      {
LABEL_201:
        bdfError("bad ENCODING value");
        goto LABEL_188;
      }
      if ( v170 != -1 )
        goto LABEL_35;
      v170 = v171;
      v31 = v171;
    }
    if ( v31 == -1 )
    {
      if ( !v10 )
      {
        ++v158;
        v27 = 1;
      }
      goto LABEL_46;
    }
LABEL_35:
    if ( v31 > 0xFFFF )
    {
      bdfError("char '%s' has encoding too large (%d)\n");
    }
    else
    {
      v32 = (unsigned __int8)v31;
      v33 = v31 >> 8;
      if ( v31 >> 8 < (unsigned int)(unsigned __int16)v146[6] )
        v146[6] = v33;
      if ( v33 > (unsigned __int16)v146[7] )
        v146[7] = v33;
      if ( (unsigned __int16)v146[4] > (unsigned int)(unsigned __int8)v31 )
        v146[4] = (unsigned __int8)v31;
      if ( (unsigned __int16)v146[5] < (unsigned int)(unsigned __int8)v31 )
        v146[5] = (unsigned __int8)v31;
      v34 = (_QWORD *)v172[v33];
      if ( !v34 )
      {
        v34 = malloc(0x800uLL);
        v172[v33] = (__int64)v34;
        if ( !v34 )
        {
          bdfError("Couldn't allocate row %d of encoding (%d*%d)\n");
          goto LABEL_188;
        }
        v101 = v34;
        do
        {
          *v101 = 0LL;
          ++v101;
        }
        while ( v101 != v34 + 256 );
      }
      ++v153;
      v34[v32] = v145;
    }
LABEL_46:
    v35 = (const char *)bdfGetLine(v8, v23, 1024LL);
    if ( !v35 || sscanf(v35, "SWIDTH %d %d", &v164, &v165) != 2 )
    {
      bdfError("bad 'SWIDTH'\n");
      goto LABEL_188;
    }
    if ( v165 )
    {
      bdfError("SWIDTH y value must be zero\n");
      goto LABEL_188;
    }
    if ( v10 )
      *(_DWORD *)(v10[1] + 4LL * v148) = v164;
    v36 = (const char *)bdfGetLine(v8, v23, 1024LL);
    if ( !v36 || sscanf(v36, "DWIDTH %d %d", &v164, &v165) != 2 )
    {
      bdfError("bad 'DWIDTH'\n");
      goto LABEL_188;
    }
    if ( v165 )
    {
      bdfError("DWIDTH y value must be zero\n");
      goto LABEL_188;
    }
    v37 = (const char *)bdfGetLine(v8, v23, 1024LL);
    if ( !v37 || sscanf(v37, "BBX %d %d %d %d", &v166, &v167, &v168, &v169, v139) != 4 )
    {
      bdfError("bad 'BBX'\n");
LABEL_188:
      v13 = v172[0];
      goto LABEL_10;
    }
    if ( v167 < 0 || v166 < 0 )
    {
      bdfError("character '%s' has a negative sized bitmap, %dx%d\n");
      goto LABEL_188;
    }
    v38 = bdfGetLine(v8, v23, 1024LL);
    v39 = 0;
    v40 = v38 == 0;
    if ( !v38 )
      goto LABEL_261;
    v41 = "ATTRIBUTES";
    v42 = 10LL;
    v43 = (_BYTE *)v38;
    do
    {
      if ( !v42 )
        break;
      v39 = *v43 < (const unsigned __int8)*v41;
      v40 = *v43++ == *v41++;
      --v42;
    }
    while ( v40 );
    if ( (!v39 && !v40) == v39 )
    {
      v97 = (_BYTE *)(v38 + 11);
      v98 = *(_BYTE *)(v38 + 11);
      if ( v98 == 9 || v98 == 32 )
      {
        do
        {
          do
            ++v97;
          while ( *v97 == 32 );
        }
        while ( *v97 == 9 );
      }
      v99 = (unsigned int)bdfHexByte(v97, v43) << 8;
      v145[5] = v99 + (unsigned __int8)bdfHexByte(v97 + 2, v43);
      v38 = bdfGetLine(v8, v23, 1024LL);
    }
    else
    {
LABEL_261:
      v145[5] = 0;
    }
    v44 = 0;
    v45 = v38 == 0;
    if ( !v38 )
      goto LABEL_262;
    v46 = "BITMAP";
    v47 = 6LL;
    v48 = (_BYTE *)v38;
    do
    {
      if ( !v47 )
        break;
      v44 = *v48 < (const unsigned __int8)*v46;
      v45 = *v48++ == *v46++;
      --v47;
    }
    while ( v45 );
    v49 = (char)((!v44 && !v45) - v44);
    if ( (!v44 && !v45) != v44 )
    {
LABEL_262:
      bdfError("missing 'BITMAP'\n");
      goto LABEL_188;
    }
    v50 = &v174;
    do
    {
      v51 = *(_DWORD *)v50;
      v50 += 4;
      v52 = ~v51 & (v51 - 16843009) & 0x80808080;
    }
    while ( !v52 );
    v53 = v167;
    if ( !((unsigned __int16)~(_WORD)v51 & (unsigned __int16)(v51 - 257) & 0x8080) )
      LOBYTE(v52) = (~v51 & (v51 - 16843009) & 0x80808080) >> 16;
    if ( !((unsigned __int16)~(_WORD)v51 & (unsigned __int16)(v51 - 257) & 0x8080) )
      v50 += 2;
    if ( &v50[-__CFADD__((_BYTE)v52, (_BYTE)v52) - 3] - &v174 == 1 )
    {
      if ( (unsigned __int8)(v174 - 48) <= 9u )
      {
        v71 = v141;
        v72 = v164;
        ++*(_DWORD *)(v71 + 1052);
        *(_DWORD *)(v71 + 1056) += v72;
      }
      else if ( v174 == 120 )
      {
        v70 = v167 + v169;
        if ( v167 + v169 <= 0 )
          v70 = v167;
        *(_DWORD *)(v141 + 1060) = v70;
      }
    }
    if ( v27 )
    {
      while ( 1 )
      {
        v59 = bdfGetLine(v8, &v176, 1024LL);
        ++v49;
        v56 = 0;
        v57 = v59 == 0;
        v58 = (_BYTE *)v59;
        if ( !v59 )
          goto LABEL_84;
        v54 = "ENDCHAR";
        v55 = 7LL;
        do
        {
          if ( !v55 )
            break;
          v56 = *v58 < (const unsigned __int8)*v54;
          v57 = *v58++ == *v54++;
          --v55;
        }
        while ( v57 );
        if ( v53 < v49 || (!v56 && !v57) == v56 )
        {
          if ( v49 != 1 && (!v56 && !v57) != v56 )
            bdfError("Error in bitmap, missing 'ENDCHAR'\n");
          goto LABEL_84;
        }
      }
    }
    v60 = v168;
    v61 = v164;
    v62 = v168 + v166;
    v63 = v169 + v53;
    v64 = -v169;
    *v145 = v168;
    v145[1] = v62;
    v145[3] = v63;
    v145[4] = v64;
    v65 = v62 - v60;
    v145[2] = v61;
    *((_QWORD *)v145 + 2) = 0LL;
    string = v65;
    v149 = v63 + (signed __int16)v64;
    switch ( v140 )
    {
      case 1:
        v150 = (v65 + 7) >> 3;
        break;
      case 2:
        v150 = ((v65 + 15) >> 3) & 0xFFFFFFFE;
        break;
      case 4:
        v150 = ((v65 + 31) >> 3) & 0xFFFFFFFC;
        break;
      case 8:
        v150 = ((v65 + 63) >> 3) & 0xFFFFFFF8;
        break;
      default:
        v159 = 0;
        v150 = 0;
        ptr = 0LL;
        goto LABEL_94;
    }
    v159 = v150 * v149;
    if ( v150 * v149 <= 0 )
    {
      ptr = 0LL;
LABEL_94:
      *((_QWORD *)v145 + 2) = ptr;
      if ( v139 )
      {
        v66 = string + 7;
        v67 = 0LL;
        v68 = *v139;
LABEL_100:
        for ( i = (string + 7) >> 3; ; i = ((string + 15) >> 3) & 0xFFFFFFFE )
        {
LABEL_101:
          v139[v67] = v149 * i + v68;
          while ( 1 )
          {
            v68 = v139[++v67];
            if ( !v67 )
              goto LABEL_100;
            if ( (_DWORD)v67 == 1 )
              break;
            if ( (_DWORD)v67 == 2 )
            {
              i = ((string + 31) >> 3) & 0xFFFFFFFC;
              goto LABEL_101;
            }
            v139[v67] = v149 * (((string + 63) >> 3) & 0xFFFFFFF8) + v68;
            if ( (_DWORD)v67 == 3 )
              goto LABEL_125;
          }
        }
      }
      v66 = string + 7;
LABEL_125:
      v151 = v66 >> 3;
      if ( v149 <= 0 )
      {
        if ( !v149 )
        {
          v27 = 0;
          v96 = bdfGetLine(v8, &v176, 1024LL);
          goto LABEL_162;
        }
LABEL_163:
        bdfError("missing 'ENDCHAR'\n");
      }
      else
      {
        v152 = 0;
        v154 = v10;
        v155 = v23;
        v161 = 255 << (8 - (string & 7));
        v156 = (signed __int64)(ptr + 1);
        do
        {
          v73 = (const char *)bdfGetLine(v8, &v176, 1024LL);
          v74 = v73;
          if ( !v73 )
          {
            v10 = v154;
            v23 = v155;
            goto LABEL_163;
          }
          v75 = 0;
          v76 = string == 0;
          if ( string )
          {
            v86 = strlen(v73);
            v87 = v86;
            if ( v86 & 1 )
            {
              bdfError("odd number of characters in hex encoding\n");
              v86 = v87 + 1;
              v74[v87] = 48;
              v74[v87 + 1] = 0;
            }
            v88 = v86 >> 1;
            v160 = v86 >> 1;
            if ( v151 <= v86 >> 1 )
              v88 = v151;
            if ( v88 > 0 )
            {
              v89 = v74;
              v162 = v88 - 1;
              v90 = &ptr[v27];
              v91 = v156 + v27 + (unsigned int)(v88 - 1);
              do
              {
                v92 = v89;
                ++v90;
                v89 += 2;
                *(v90 - 1) = bdfHexByte(v92, ptr);
              }
              while ( v90 != (unsigned __int8 *)v91 );
              v27 += v162 + 1;
            }
            if ( v151 > v160 )
            {
              if ( v151 - v160 > 0 )
              {
                v100 = &ptr[v27];
                do
                  *v100++ = 0;
                while ( v100 != (unsigned __int8 *)(v27 + v156 + (unsigned int)(v151 - v160 - 1)) );
                v27 += v151 - v160;
              }
            }
            else if ( v161 )
            {
              v93 = &ptr[v27 - 1];
              if ( *v93 & (unsigned __int8)~v161 )
                *v93 &= v161;
            }
            if ( v151 < v150 && v150 - v151 > 0 )
            {
              v94 = &ptr[v27];
              do
                *v94++ = 0;
              while ( (unsigned __int8 *)(v27 + v156 + (unsigned int)(v150 - v151 - 1)) != v94 );
              v27 += v150 - v151;
            }
          }
          else
          {
            v77 = v73;
            v78 = 7LL;
            v79 = "ENDCHAR";
            do
            {
              if ( !v78 )
                break;
              v75 = (const unsigned __int8)*v77 < *v79;
              v76 = *v77++ == *v79++;
              --v78;
            }
            while ( v76 );
            v80 = (!v75 && !v76) - v75;
            v81 = 0;
            v82 = v80 == 0;
            if ( !v80 )
            {
              v10 = v154;
              v23 = v155;
              goto LABEL_134;
            }
          }
          ++v152;
        }
        while ( v149 != v152 );
        v10 = v154;
        v23 = v155;
        v95 = strncmp(v74, "ENDCHAR", 7uLL);
        v81 = 0;
        v82 = v95 == 0;
        if ( !v95 )
          goto LABEL_134;
        v96 = bdfGetLine(v8, &v176, 1024LL);
LABEL_162:
        v81 = 0;
        v82 = v96 == 0;
        v74 = (const char *)v96;
        if ( !v96 )
          goto LABEL_163;
LABEL_134:
        v83 = 7LL;
        v84 = v74;
        v85 = "ENDCHAR";
        do
        {
          if ( !v83 )
            break;
          v81 = (const unsigned __int8)*v84 < *v85;
          v82 = *v84++ == *v85++;
          --v83;
        }
        while ( v82 );
        if ( (!v81 && !v82) != v81 )
          goto LABEL_163;
        if ( v27 == v159 )
        {
          if ( ptr )
          {
            if ( !v142 )
              BitOrderInvert(ptr, v27);
            if ( v142 != v143 )
            {
              if ( a7 == 2 )
              {
                TwoByteSwap(ptr, v27);
              }
              else if ( a7 == 4 )
              {
                FourByteSwap(ptr, v27);
              }
            }
          }
          goto LABEL_122;
        }
        bdfError("bytes != rows * bytes_per_row (%d != %d * %d)\n");
      }
      if ( ptr )
        free(ptr);
      goto LABEL_121;
    }
    ptr = (unsigned __int8 *)malloc(v150 * v149);
    if ( ptr )
      goto LABEL_94;
    bdfError("Couldn't allocate picture (%d*%d)\n");
LABEL_121:
    *((_QWORD *)v145 + 2) = 0LL;
LABEL_122:
    v145 += 12;
    ++v148;
LABEL_84:
    v19 = (const char *)bdfGetLine(v8, v23, 1024LL);
    v20 = v163;
    if ( v163 <= v148 )
    {
      v114 = v148 + v158;
      v9 = v157;
      v7 = v146;
      goto LABEL_220;
    }
    v21 = 0;
    v22 = v19 == 0LL;
    if ( !v19 )
    {
      v13 = v172[0];
      if ( v163 != v148 + v158 )
        goto LABEL_200;
      v163 = v148;
      *(_DWORD *)(v157 + 4) = v148;
      goto LABEL_88;
    }
  }
  v9 = v157;
  v7 = v146;
  v102 = v148 + v158 < v20;
  v103 = v148 + v158 == v20;
  if ( v148 + v158 != v20 )
    goto LABEL_199;
  v163 = v148;
  *(_DWORD *)(v157 + 4) = v148;
LABEL_209:
  v104 = "STARTCHAR";
  v105 = 9LL;
  v106 = v19;
  do
  {
    if ( !v105 )
      break;
    v102 = (const unsigned __int8)*v106 < *v104;
    v103 = *v106++ == *v104++;
    --v105;
  }
  while ( v103 );
  v107 = (!v102 && !v103) - v102;
  v108 = 0;
  v109 = v107 == 0;
  if ( !v107 )
  {
    bdfError("more characters than specified\n");
    v13 = v172[0];
    goto LABEL_10;
  }
  v110 = "ENDFONT";
  v111 = 7LL;
  v112 = v19;
  do
  {
    if ( !v111 )
      break;
    v108 = (const unsigned __int8)*v112 < *v110;
    v109 = *v112++ == *v110++;
    --v111;
  }
  while ( v109 );
  v113 = (char)((!v108 && !v109) - v108);
  if ( (!v108 && !v109) != v108 )
    goto LABEL_217;
  if ( !v153 )
    bdfWarning("No characters with valid encodings\n", v112);
  v115 = ((unsigned __int16)v7[5] - (unsigned __int16)v7[4] + 1)
       * ((unsigned __int16)v7[7] - (unsigned __int16)v7[6] + 1);
  v116 = v115 + 254;
  v117 = v115 + 127;
  if ( v117 < 0 )
    v117 = v116;
  v118 = calloc(v117 >> 7, 8uLL);
  *(_QWORD *)(v9 + 40) = v118;
  if ( !v118 )
  {
    bdfError("Couldn't allocate ppCI (%d,%d)\n");
    v13 = v172[0];
LABEL_10:
    v14 = (void *)v13;
    for ( j = (char *)v173; ; j += 8 )
    {
      if ( v14 )
        free(v14);
      if ( &v174 == j )
        break;
      v14 = *(void **)j;
    }
    return 0LL;
  }
  v119 = (unsigned __int16)v7[6];
  v120 = (unsigned __int16)v7[7];
  *((_BYTE *)v7 + 18) |= 0x40u;
  if ( (unsigned int)v119 <= v120 )
  {
    v121 = &v172[v119];
    v122 = v9;
    do
    {
      v123 = *v121;
      v124 = (unsigned __int16)v7[5];
      v125 = (unsigned __int16)v7[4];
      if ( *v121 )
      {
        if ( (unsigned __int16)v124 >= (unsigned __int16)v125 )
        {
          v126 = 8 * v125;
          v127 = (unsigned __int16)v125 - v113;
          while ( 1 )
          {
            v132 = *(_QWORD *)(v123 + v126);
            if ( v132 )
            {
              v128 = v113 + 127;
              v129 = *(_QWORD *)(v122 + 40);
              if ( v113 >= 0 )
                v128 = v113;
              v130 = v128 >> 7;
              v131 = *(_QWORD *)(v129 + 8 * v130);
              if ( !v131 )
              {
                v134 = v119;
                v135 = v122;
                v136 = v127;
                v137 = (_QWORD *)(v129 + 8 * v130);
                v138 = calloc(0x80uLL, 8uLL);
                v122 = v135;
                v127 = v136;
                LODWORD(v119) = v134;
                *v137 = v138;
                v131 = *(_QWORD *)(*(_QWORD *)(v135 + 40) + 8 * v130);
                if ( !v131 )
                  goto LABEL_188;
              }
              *(_QWORD *)(v131 + 8LL * (v113 % 128)) = v132;
            }
            else
            {
              *((_BYTE *)v7 + 18) &= 0xBFu;
            }
            ++v113;
            v126 += 8LL;
            if ( (unsigned __int16)v7[5] < (unsigned int)(v127 + v113) )
              break;
            v123 = *v121;
          }
          v120 = (unsigned __int16)v7[7];
        }
      }
      else
      {
        *((_BYTE *)v7 + 18) &= 0xBFu;
        v113 += v124 - v125 + 1;
      }
      LODWORD(v119) = v119 + 1;
      ++v121;
    }
    while ( v120 >= (unsigned int)v119 );
  }
  v133 = (void **)v172;
  do
  {
    if ( *v133 )
      free(*v133);
    ++v133;
  }
  while ( &v174 != (char *)v133 );
  return 1LL;
}
// 81D0: using guessed type __int64 __fastcall bdfError(_QWORD);
// 8600: using guessed type __int64 __fastcall bdfHexByte(_QWORD, _QWORD);
// 8910: using guessed type __int64 __fastcall bdfGetLine(_QWORD, _QWORD, _QWORD);
// 8FC0: using guessed type __int64 __fastcall bdfWarning(_QWORD, _QWORD);
// 19300: using guessed type __int64 var_10B8[256];

//----- (000000000001A4D0) ----------------------------------------------------
__int64 __fastcall bdfReadFont(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  __int64 v6; // rbx
  __int64 v7; // rbp
  const char *v8; // rax
  unsigned int v9; // eax
  bool v10; // cf
  bool v11; // zf
  unsigned int v12; // ebp
  const char *v14; // rdi
  signed __int64 v15; // rcx
  char *v16; // rsi
  const char *v17; // rax
  const char *v18; // rax
  bool v19; // cf
  bool v20; // zf
  const char *v21; // rdi
  signed __int64 v22; // rcx
  const char *v23; // rsi
  const char *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // r14
  _QWORD *v27; // rax
  const char *v28; // rax
  bool v29; // cf
  bool v30; // zf
  const char *v31; // rdi
  signed __int64 v32; // rcx
  const char *v33; // rsi
  int v34; // eax
  int v35; // er14
  int i; // er15
  const char *v37; // rax
  bool v38; // cf
  bool v39; // zf
  const char *v40; // r13
  const char *v41; // rdi
  const char *v42; // rsi
  signed __int64 v43; // rcx
  __int64 v44; // rbx
  const unsigned __int16 *v45; // rax
  int v46; // eax
  _BYTE *v47; // r9
  void *v48; // rdi
  _BYTE *v49; // ST18_8
  void *v50; // rdi
  _BYTE *v51; // ST18_8
  bool v52; // cf
  bool v53; // zf
  _BYTE *v54; // rsi
  __int64 v55; // rax
  signed __int64 v56; // rcx
  const char *v57; // rdi
  char *v58; // rdx
  __int64 v59; // rbx
  int v60; // ecx
  unsigned int v61; // eax
  bool v62; // zf
  __int64 v63; // rax
  signed __int64 v64; // r8
  __int64 v65; // rax
  int v66; // eax
  int v67; // ecx
  _QWORD *v68; // r14
  const char *v69; // rax
  _BYTE *v70; // r9
  int v71; // er13
  int v72; // er11
  _BYTE *v73; // ST18_8
  __int64 v74; // rax
  int v75; // eax
  int v76; // ecx
  unsigned __int16 v77; // dx
  int v78; // edi
  int v79; // esi
  unsigned int v80; // eax
  __int64 v81; // rdx
  __int64 v82; // rax
  __int64 v83; // rax
  __int64 v84; // rdx
  int v85; // ecx
  int v86; // edx
  __int16 v87; // ax
  __int64 v88; // r12
  int v89; // edx
  char v90; // cl
  __int64 v91; // rbp
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rdx
  __int64 v95; // rax
  __int64 v96; // r8
  int v97; // ebp
  int v98; // eax
  int v99; // edx
  int v100; // esi
  int v101; // er11
  int v102; // er9
  int v103; // edi
  __int64 v104; // rax
  unsigned int v105; // er11
  unsigned int v106; // er9
  unsigned int v107; // esi
  int v108; // edi
  unsigned int j; // ecx
  int v110; // eax
  char *v111; // ST30_8
  char *v112; // r12
  __int64 v113; // rax
  double v114; // xmm0_8
  __int64 *v115; // rdx
  int v116; // ST30_4
  __int64 v117; // rax
  __int64 *v118; // rdx
  int v119; // ST30_4
  __int64 v120; // rax
  __int64 *v121; // rdx
  int v122; // ST30_4
  __int64 v123; // rax
  __int64 *v124; // rdx
  int v125; // ST30_4
  __int64 v126; // rax
  __int64 *v127; // rdx
  int v128; // ST30_4
  __int64 v129; // rax
  __int64 *v130; // rdx
  double v131; // xmm0_8
  int v132; // ST30_4
  __int64 v133; // rax
  __int64 *v134; // rdx
  unsigned int v135; // [rsp+8h] [rbp-1540h]
  unsigned int v136; // [rsp+10h] [rbp-1538h]
  unsigned int v137; // [rsp+18h] [rbp-1530h]
  int v138; // [rsp+18h] [rbp-1530h]
  unsigned int v139; // [rsp+1Ch] [rbp-152Ch]
  char *string; // [rsp+20h] [rbp-1528h]
  char *stringa; // [rsp+20h] [rbp-1528h]
  void *v142; // [rsp+28h] [rbp-1520h]
  __int64 v143; // [rsp+40h] [rbp-1508h]
  _QWORD *v144; // [rsp+50h] [rbp-14F8h]
  char *v145; // [rsp+58h] [rbp-14F0h]
  _QWORD *v146; // [rsp+68h] [rbp-14E0h]
  __int128 v147; // [rsp+70h] [rbp-14D8h]
  void *v148; // [rsp+80h] [rbp-14C8h]
  char v149; // [rsp+90h] [rbp-14B8h]
  __int64 v150; // [rsp+A0h] [rbp-14A8h]
  float v151; // [rsp+4A0h] [rbp-10A8h]
  int v152; // [rsp+4A4h] [rbp-10A4h]
  int v153; // [rsp+4A8h] [rbp-10A0h]
  int v154; // [rsp+4ACh] [rbp-109Ch]
  int v155; // [rsp+4B0h] [rbp-1098h]
  int v156; // [rsp+4B4h] [rbp-1094h]
  char *v157; // [rsp+4B8h] [rbp-1090h]
  char *v158; // [rsp+4C0h] [rbp-1088h]
  __int64 v159; // [rsp+4C8h] [rbp-1080h]
  __int64 v160; // [rsp+4D0h] [rbp-1078h]
  char *v161; // [rsp+4D8h] [rbp-1070h]
  char *v162; // [rsp+4E0h] [rbp-1068h]
  char *v163; // [rsp+4E8h] [rbp-1060h]
  char *v164; // [rsp+4F0h] [rbp-1058h]
  char v165; // [rsp+4F8h] [rbp-1050h]
  char v166; // [rsp+4F9h] [rbp-104Fh]
  char v167; // [rsp+4FAh] [rbp-104Eh]
  char v168; // [rsp+500h] [rbp-1048h]
  char v169; // [rsp+900h] [rbp-C48h]
  char v170; // [rsp+D00h] [rbp-848h]
  char v171; // [rsp+1100h] [rbp-448h]
  unsigned __int64 v172; // [rsp+1508h] [rbp-40h]

  v6 = a1;
  v7 = a2;
  *(_QWORD *)(a1 + 152) = 0LL;
  v137 = a4;
  v172 = __readfsqword(0x28u);
  v135 = a3;
  memset(&v149, 0, 0x470uLL);
  v136 = a5;
  v139 = a6;
  bdfFileLineNum = 0;
  v8 = (const char *)bdfGetLine(a2, &v171, 1024LL);
  if ( !v8 )
    goto LABEL_176;
  v9 = sscanf(v8, "STARTFONT %s", &v170);
  v10 = v9 < 1;
  v11 = v9 == 1;
  if ( v9 != 1 )
    goto LABEL_176;
  v14 = "2.1";
  v15 = 4LL;
  v16 = &v170;
  do
  {
    if ( !v15 )
      break;
    v10 = (unsigned __int8)*v16 < *v14;
    v11 = *v16++ == *v14++;
    --v15;
  }
  while ( v11 );
  if ( (!v10 && !v11) != v10 )
  {
LABEL_176:
    bdfError("bad 'STARTFONT'\n");
    goto LABEL_4;
  }
  v17 = (const char *)bdfGetLine(v7, &v171, 1024LL);
  if ( !v17 || sscanf(v17, "FONT %[^\n]", &v150) != 1 )
  {
    bdfError("bad 'FONT'\n");
    goto LABEL_4;
  }
  v18 = (const char *)bdfGetLine(v7, &v171, 1024LL);
  v19 = 0;
  v20 = v18 == 0LL;
  if ( !v18 )
    goto LABEL_177;
  v21 = "SIZE";
  v22 = 4LL;
  v23 = v18;
  do
  {
    if ( !v22 )
      break;
    v19 = (const unsigned __int8)*v23 < *v21;
    v20 = *v23++ == *v21++;
    --v22;
  }
  while ( v20 );
  if ( (!v19 && !v20) != v19 )
  {
LABEL_177:
    bdfError("missing 'SIZE'\n");
    goto LABEL_4;
  }
  if ( sscanf(v18, "SIZE %f%d%d", &v151, &v152, &v153) != 3 )
  {
    bdfError("bad 'SIZE'\n");
    goto LABEL_4;
  }
  if ( v151 < 1.0 || v152 <= 0 || v153 <= 0 )
  {
    bdfError("SIZE values must be > 0\n");
LABEL_4:
    v12 = 80;
    if ( *(_QWORD *)(v6 + 152) )
      sub_191E0(v6);
    return v12;
  }
  v24 = (const char *)bdfGetLine(v7, &v171, 1024LL);
  if ( !v24 || strncmp(v24, "FONTBOUNDINGBOX", 0xFuLL) )
  {
    bdfError("missing 'FONTBOUNDINGBOX'\n");
    goto LABEL_4;
  }
  v25 = calloc(1uLL, 0x40uLL);
  v26 = v25;
  if ( !v25 )
  {
    bdfError("Couldn't allocate bitmapFontRec (%d)\n");
    goto LABEL_4;
  }
  *(_QWORD *)(v6 + 152) = v25;
  v25[2] = 0LL;
  v25[3] = 0LL;
  v25[4] = 0LL;
  v25[5] = 0LL;
  v25[6] = 0LL;
  v27 = calloc(1uLL, 0x78uLL);
  v26[7] = v27;
  if ( !v27 )
  {
    bdfError("Couldn't allocate bitmapExtra (%d)\n");
    goto LABEL_4;
  }
  *v27 = 0LL;
  v27[1] = 0LL;
  v28 = (const char *)bdfGetLine(v7, &v171, 1024LL);
  v29 = 0;
  v30 = v28 == 0LL;
  if ( !v28 )
    goto LABEL_178;
  v31 = "STARTPROPERTIES";
  v32 = 15LL;
  v33 = v28;
  do
  {
    if ( !v32 )
      break;
    v29 = (const unsigned __int8)*v33 < *v31;
    v30 = *v33++ == *v31++;
    --v32;
  }
  while ( v30 );
  if ( (!v29 && !v30) != v29 )
  {
LABEL_178:
    bdfError("missing 'STARTPROPERTIES'\n");
    goto LABEL_4;
  }
  string = (char *)v28;
  if ( sscanf(v28, "STARTPROPERTIES %d") != 1 )
  {
    bdfError("bad 'STARTPROPERTIES'\n");
    goto LABEL_4;
  }
  v34 = v147;
  *(_QWORD *)(v6 + 80) = 0LL;
  *(_DWORD *)(v6 + 76) = 0;
  v142 = malloc(v34 + 6);
  *(_QWORD *)(v6 + 88) = v142;
  if ( !v142 )
  {
    bdfError("Couldn't allocate stringProps (%d*%d)\n");
    v47 = string;
LABEL_55:
    v48 = *(void **)(v6 + 88);
    if ( v48 )
    {
      v49 = v47;
      free(v48);
      v47 = v49;
      *(_QWORD *)(v6 + 88) = 0LL;
    }
    v50 = *(void **)(v6 + 80);
    if ( v50 )
    {
      v51 = v47;
      free(v50);
      v47 = v51;
      *(_QWORD *)(v6 + 80) = 0LL;
    }
    v52 = 0;
    v53 = v47 == 0LL;
    v54 = v47;
    if ( v47 )
    {
      do
      {
        v56 = 13LL;
        v57 = "ENDPROPERTIES";
        do
        {
          if ( !v56 )
            break;
          v52 = *v54 < (const unsigned __int8)*v57;
          v53 = *v54++ == *v57++;
          --v56;
        }
        while ( v53 );
        if ( (!v52 && !v53) != v52 )
          break;
        v55 = bdfGetLine(v7, &v171, 1024LL);
        v52 = 0;
        v53 = v55 == 0;
        v54 = (_BYTE *)v55;
      }
      while ( v55 );
    }
    goto LABEL_4;
  }
  v145 = (char *)calloc((signed int)v147 + 6, 0x10uLL);
  *(_QWORD *)(v6 + 80) = v145;
  if ( !v145 )
  {
    bdfError("Couldn't allocate props (%d*%d)\n");
    v47 = string;
    goto LABEL_55;
  }
  v146 = v26;
  v35 = v147;
  v143 = v6;
  for ( i = 0;
        --v35 + 1 > 0;
        i += (unsigned int)bdfSpecialProperty(v143, v144, (unsigned int)*((char *)v142 + v59), &v149) < 1 )
  {
    v37 = (const char *)bdfGetLine(v7, &v171, 1024LL);
    v38 = 0;
    v39 = v37 == 0LL;
    v40 = v37;
    if ( !v37 )
      goto LABEL_179;
    v41 = "ENDPROPERTIES";
    v42 = v37;
    v43 = 13LL;
    do
    {
      if ( !v43 )
        break;
      v38 = (const unsigned __int8)*v42 < *v41;
      v39 = *v42++ == *v41++;
      --v43;
    }
    while ( v39 );
    if ( (!v38 && !v39) == v38 )
    {
LABEL_179:
      v6 = v143;
      bdfError("\"STARTPROPERTIES %d\" followed by only %d properties\n");
      v47 = v40;
      goto LABEL_55;
    }
    v44 = *(unsigned __int8 *)v37;
    if ( (_BYTE)v44 )
    {
      v45 = *__ctype_b_loc();
      do
      {
        if ( !(v45[v44] & 0x2000) )
          break;
        v44 = *(unsigned __int8 *)++v40;
      }
      while ( (_BYTE)v44 );
    }
    v46 = sscanf(v40, "%s%s%s", &v168, &v169, &v170);
    if ( v46 == 2 )
    {
      if ( v169 != 34 )
      {
        if ( !(unsigned int)bdfIsInteger(&v169) )
          goto LABEL_95;
        v59 = i;
        *((_BYTE *)v142 + i) = 0;
        v66 = strtol(&v169, 0LL, 10);
        v64 = (signed __int64)&v145[16 * i];
        *(_QWORD *)(v64 + 8) = v66;
        goto LABEL_75;
      }
      v58 = &v168;
      v59 = i;
      *((_BYTE *)v142 + i) = 1;
      do
      {
        v67 = *(_DWORD *)v58;
        v58 += 4;
        v61 = ~v67 & (v67 - 16843009) & 0x80808080;
      }
      while ( !v61 );
    }
    else
    {
      if ( v46 != 3 )
      {
        v6 = v143;
        bdfError("missing '%s' parameter value\n");
        v47 = v40;
        goto LABEL_55;
      }
      if ( v169 != 34 )
      {
LABEL_95:
        v6 = v143;
        bdfError("invalid '%s' parameter value\n");
        v47 = v40;
        goto LABEL_55;
      }
      v58 = &v168;
      v59 = i;
      *((_BYTE *)v142 + i) = 1;
      do
      {
        v60 = *(_DWORD *)v58;
        v58 += 4;
        v61 = ~v60 & (v60 - 16843009) & 0x80808080;
      }
      while ( !v61 );
    }
    v62 = (unsigned __int16)(v61 & 0x8080) == 0;
    if ( !(v61 & 0x8080) )
      LOBYTE(v61) = BYTE2(v61);
    if ( v62 )
      v58 += 2;
    v63 = bdfGetPropertyValue((char *)&v40[&v58[-__CFADD__((_BYTE)v61, (_BYTE)v61) - 3] - &v168 + 1]);
    v64 = (signed __int64)&v145[16 * v59];
    *(_QWORD *)(v64 + 8) = v63;
    if ( !v63 )
    {
      v47 = v40;
      v6 = v143;
      goto LABEL_55;
    }
LABEL_75:
    v144 = (_QWORD *)v64;
    v65 = bdfForceMakeAtom(&v168);
    *v144 = v65;
    if ( !v65 )
    {
      v6 = v143;
      bdfError("Empty property name.\n");
      v47 = v40;
      goto LABEL_55;
    }
  }
  v68 = v146;
  v6 = v143;
  v69 = (const char *)bdfGetLine(v7, &v171, 1024LL);
  v70 = v69;
  if ( !v69 || (stringa = (char *)v69, v71 = strncmp(v69, "ENDPROPERTIES", 0xDuLL), v70 = stringa, v72 = i, v71) )
  {
    v73 = v70;
    bdfError("missing 'ENDPROPERTIES'\n");
    v47 = v73;
    goto LABEL_55;
  }
  if ( !v165 || !v166 )
  {
    bdfError("missing 'FONT_ASCENT' or 'FONT_DESCENT' properties\n");
    v47 = stringa;
    goto LABEL_55;
  }
  v74 = v146[7];
  if ( v74 )
  {
    *(_WORD *)(v74 + 96) = *(_WORD *)(v143 + 72);
    *(_WORD *)(v146[7] + 98LL) = *(_WORD *)(v143 + 74);
  }
  if ( !v158 )
  {
    v113 = bdfForceMakeAtom("POINT_SIZE");
    v114 = v151 * 10.0;
    v115 = (__int64 *)&v145[16 * i];
    v72 = i + 1;
    *v115 = v113;
    v158 = &v145[16 * i];
    v115[1] = (signed int)v114;
    *((_BYTE *)v142 + i) = 0;
  }
  if ( !v157 )
  {
    v111 = (char *)v72;
    v112 = &v145[16 * v72];
    *(_QWORD *)v112 = bdfForceMakeAtom("FONT");
    *((_QWORD *)v112 + 1) = (signed int)bdfForceMakeAtom((char *)&v150);
    v157 = &v145[16 * (signed int)v111];
    v72 = (_DWORD)v111 + 1;
    v111[(_QWORD)v142] = 1;
  }
  if ( !v163 )
  {
    v132 = v72;
    v133 = bdfForceMakeAtom("WEIGHT");
    v134 = (__int64 *)&v145[16 * v132];
    v72 = v132 + 1;
    *v134 = v133;
    v134[1] = -1LL;
    v163 = &v145[16 * v132];
    *((_BYTE *)v142 + v132) = 0;
  }
  if ( !v161 && v152 == v153 )
  {
    v128 = v72;
    v129 = bdfForceMakeAtom("RESOLUTION");
    v130 = (__int64 *)&v145[16 * v128];
    v72 = v128 + 1;
    v131 = (double)v152 * 100.0 / 72.27;
    *v130 = v129;
    v161 = &v145[16 * v128];
    v130[1] = (signed int)v131;
    *((_BYTE *)v142 + v128) = 0;
  }
  if ( !v159 )
  {
    v125 = v72;
    v126 = bdfForceMakeAtom("RESOLUTION_X");
    v127 = (__int64 *)&v145[16 * v125];
    v72 = v125 + 1;
    *v127 = v126;
    v161 = &v145[16 * v125];
    v127[1] = v152;
    *((_BYTE *)v142 + v125) = 0;
  }
  if ( !v160 )
  {
    v122 = v72;
    v123 = bdfForceMakeAtom("RESOLUTION_Y");
    v124 = (__int64 *)&v145[16 * v122];
    v72 = v122 + 1;
    *v124 = v123;
    v161 = &v145[16 * v122];
    v124[1] = v153;
    *((_BYTE *)v142 + v122) = 0;
  }
  if ( !v162 )
  {
    v119 = v72;
    v120 = bdfForceMakeAtom("X_HEIGHT");
    v121 = (__int64 *)&v145[16 * v119];
    v72 = v119 + 1;
    *v121 = v120;
    v121[1] = -1LL;
    v162 = &v145[16 * v119];
    *((_BYTE *)v142 + v119) = 0;
  }
  if ( !v164 )
  {
    v116 = v72;
    v117 = bdfForceMakeAtom("QUAD_WIDTH");
    v118 = (__int64 *)&v145[16 * v116];
    v72 = v116 + 1;
    *v118 = v117;
    v118[1] = -1LL;
    v164 = &v145[16 * v116];
    *((_BYTE *)v142 + v116) = 0;
  }
  *(_DWORD *)(v143 + 76) = v72;
  if ( !(unsigned int)sub_192F0(v7, v143, &v149, v135, v137, v136, v139) )
    goto LABEL_4;
  if ( v167 )
  {
    LOWORD(v75) = *(_WORD *)(v143 + 16);
    v76 = *(unsigned __int16 *)(v143 + 12);
    v77 = *(_WORD *)(v143 + 16) >> 8;
    if ( v77 >= (unsigned __int16)v76 && v77 <= *(_WORD *)(v143 + 14) )
    {
      v78 = *(unsigned __int16 *)(v143 + 8);
      v75 = (unsigned __int8)v75;
      if ( (unsigned __int16)v78 <= (unsigned __int8)v75 )
      {
        v79 = *(unsigned __int16 *)(v143 + 10);
        if ( (unsigned __int16)v79 >= (unsigned __int16)v75 )
        {
          v80 = (v79 - v78 + 1) * (v77 - v76) + v75 - v78;
          v81 = *(_QWORD *)(v146[5] + 8LL * (v80 >> 7));
          if ( v81 )
            v82 = *(_QWORD *)(v81 + 8LL * (v80 & 0x7F));
          else
            v82 = 0LL;
          v146[6] = v82;
        }
      }
    }
  }
  *(_BYTE *)(v143 + 96) = v135;
  *(_BYTE *)(v143 + 97) = v137;
  *(_BYTE *)(v143 + 98) = v136;
  *(_BYTE *)(v143 + 99) = v139;
  *(_BYTE *)(v143 + 19) = *(_BYTE *)(v143 + 19) & 0xFB | 2;
  bitmapComputeFontBounds(v143);
  if ( (unsigned int)FontCouldBeTerminal(v143 + 8) )
  {
    v85 = *(signed __int16 *)(v143 + 74);
    v86 = *(signed __int16 *)(v143 + 72);
    v87 = *(_WORD *)(v143 + 40);
    v88 = *(_QWORD *)(v143 + 152);
    v148 = 0LL;
    v147 = 0LL;
    WORD3(v147) = v86;
    WORD4(v147) = v85;
    v89 = v85 + v86;
    v90 = *(_BYTE *)(v143 + 98);
    WORD1(v147) = v87;
    WORD2(v147) = v87;
    switch ( v90 )
    {
      case 1:
        v138 = v89 * ((v87 + 7) >> 3);
        break;
      case 2:
        v138 = v89 * (((v87 + 15) >> 3) & 0xFFFFFFFE);
        break;
      case 4:
        v138 = v89 * (((v87 + 31) >> 3) & 0xFFFFFFFC);
        break;
      default:
        v138 = 0;
        if ( v90 == 8 )
          v138 = v89 * (((v87 + 63) >> 3) & 0xFFFFFFF8);
        break;
    }
    if ( *(_DWORD *)(v88 + 4) > 0 )
    {
      v91 = 0LL;
      do
      {
        v148 = malloc(v138);
        if ( !v148 )
        {
          v68 = v146;
          bdfError("Couldn't allocate bits (%d)\n");
          goto LABEL_148;
        }
        ++v71;
        FontCharReshape(v143, v91 + *(_QWORD *)(v88 + 16), &v147);
        v92 = v91 + *(_QWORD *)(v88 + 16);
        WORD5(v147) = *(_WORD *)(v92 + 10);
        free(*(void **)(v92 + 16));
        v93 = *(_QWORD *)(v88 + 16);
        *(__m128i *)(v93 + v91) = _mm_load_si128((const __m128i *)&v147);
        *(_QWORD *)(v93 + v91 + 16) = v148;
        v91 += 24LL;
      }
      while ( v71 < *(_DWORD *)(v88 + 4) );
      v68 = v146;
    }
    v96 = *(_QWORD *)(v88 + 56);
    if ( v96 )
    {
      v97 = SWORD4(v147) + SWORD3(v147);
      v98 = SWORD1(v147) - (signed __int16)v147;
      v99 = *(_DWORD *)(v88 + 4);
      v100 = v98 + 63;
      v101 = v98 + 31;
      v102 = v98 + 15;
      v103 = v98 + 7;
      v104 = 0LL;
      v105 = (v101 >> 3) & 0xFFFFFFFC;
      v106 = (v102 >> 3) & 0xFFFFFFFE;
      v107 = v97 * ((v100 >> 3) & 0xFFFFFFF8);
      v108 = v103 >> 3;
LABEL_162:
      for ( j = v108; ; j = v106 )
      {
LABEL_163:
        *(_DWORD *)(v96 + 4 * v104 + 16) = v97 * j * v99;
        while ( 1 )
        {
          ++v104;
          v99 = *(_DWORD *)(v88 + 4);
          if ( !v104 )
            goto LABEL_162;
          if ( (_DWORD)v104 == 1 )
            break;
          if ( (_DWORD)v104 == 2 )
          {
            j = v105;
            goto LABEL_163;
          }
          *(_DWORD *)(v96 + 4 * v104 + 16) = v107 * v99;
          if ( (_DWORD)v104 == 3 )
            goto LABEL_148;
        }
      }
    }
LABEL_148:
    bitmapComputeFontBounds(v143);
  }
  FontComputeInfoAccelerators(v143 + 8);
  v83 = v68[7];
  if ( v83 )
  {
    FontComputeInfoAccelerators(v83 + 32);
    if ( !(*(_BYTE *)(v143 + 18) & 4) )
      goto LABEL_125;
    goto LABEL_136;
  }
  if ( *(_BYTE *)(v143 + 18) & 4 )
  {
LABEL_136:
    if ( !(unsigned int)bitmapAddInkMetrics(v143) )
    {
      bdfError("Failed to add bitmap ink metrics\n");
      goto LABEL_4;
    }
LABEL_125:
    v84 = v68[7];
    if ( v84 )
      *(_BYTE *)(v84 + 42) = *(_BYTE *)(v143 + 18) & 0x20 | *(_BYTE *)(v84 + 42) & 0xDF;
  }
  bitmapComputeFontInkBounds(v143);
  if ( v162 && *((_QWORD *)v162 + 1) == -1LL )
  {
    v94 = v156;
    if ( !v156 )
      v94 = *(signed __int16 *)(v143 + 66);
    *((_QWORD *)v162 + 1) = v94;
  }
  if ( v164 && *((_QWORD *)v164 + 1) == -1LL )
  {
    if ( v154 )
      v95 = v155 / v154;
    else
      v95 = (*(signed __int16 *)(v143 + 64) + *(signed __int16 *)(v143 + 52)) / 2;
    *((_QWORD *)v164 + 1) = v95;
  }
  if ( v163 && *((_QWORD *)v163 + 1) == -1LL )
  {
    v110 = bitmapComputeWeight(v143);
    *((_QWORD *)v163 + 1) = v110;
  }
  *(_QWORD *)(v143 + 128) = 0LL;
  v12 = 85;
  *(_QWORD *)(v143 + 104) = bitmapGetGlyphs;
  *(_QWORD *)(v143 + 112) = bitmapGetMetrics;
  *(_QWORD *)(v143 + 120) = sub_192E0;
  return v12;
}
// 8020: using guessed type __int64 __fastcall bitmapAddInkMetrics(_QWORD);
// 8190: using guessed type __int64 __fastcall FontCharReshape(_QWORD, _QWORD, _QWORD);
// 81D0: using guessed type __int64 __fastcall bdfError(_QWORD);
// 8620: using guessed type __int64 __fastcall FontComputeInfoAccelerators(_QWORD);
// 8730: using guessed type __int64 __fastcall bitmapComputeWeight(_QWORD);
// 8910: using guessed type __int64 __fastcall bdfGetLine(_QWORD, _QWORD, _QWORD);
// 89F0: using guessed type __int64 __fastcall bitmapComputeFontBounds(_QWORD);
// 8A10: using guessed type __int64 __fastcall FontCouldBeTerminal(_QWORD);
// 8B40: using guessed type __int64 __fastcall bitmapComputeFontInkBounds(_QWORD);
// 8CE0: using guessed type __int64 __fastcall bdfIsInteger(_QWORD);
// 8E20: using guessed type __int64 __fastcall sub_192F0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8F80: using guessed type __int64 __fastcall bdfSpecialProperty(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001B560) ----------------------------------------------------
__int64 __fastcall bdfReadFontInfo(__m128i *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  char v6; // [rsp+10h] [rbp-D8h]
  __int128 v7; // [rsp+18h] [rbp-D0h]
  __int128 v8; // [rsp+28h] [rbp-C0h]
  __int128 v9; // [rsp+38h] [rbp-B0h]
  __int128 v10; // [rsp+48h] [rbp-A0h]
  __int128 v11; // [rsp+58h] [rbp-90h]
  __int64 v12; // [rsp+68h] [rbp-80h]
  unsigned __int64 v13; // [rsp+C8h] [rbp-20h]

  v13 = __readfsqword(0x28u);
  memset(&v6, 0, 0xB8uLL);
  result = bdfReadFont(&v6, a2, 1LL, 0LL, 1LL, 1LL);
  if ( (_DWORD)result == 85 )
  {
    v3 = v12;
    *a1 = _mm_loadu_si128((const __m128i *)&v7);
    v12 = 0LL;
    v4 = _mm_loadu_si128((const __m128i *)&v8);
    a1[5].m128i_i64[0] = v3;
    a1[1] = v4;
    a1[2] = _mm_loadu_si128((const __m128i *)&v9);
    a1[3] = _mm_loadu_si128((const __m128i *)&v10);
    v5 = _mm_loadu_si128((const __m128i *)&v11);
    *((_QWORD *)&v11 + 1) = 0LL;
    DWORD1(v11) = 0;
    a1[4] = v5;
    sub_191E0((__int64)&v6);
    result = 85LL;
  }
  return result;
}
// 8A20: using guessed type __int64 __fastcall bdfReadFont(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001B640) ----------------------------------------------------
unsigned __int64 bdfError(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v3; // [rsp+18h] [rbp-D0h]

  va_start(va, a1);
  v3 = __readfsqword(0x28u);
  __fprintf_chk(stderr, 1LL, "BDF Error on line %d: ", bdfFileLineNum);
  __vfprintf_chk(stderr, 1LL, a1, va);
  return __readfsqword(0x28u) ^ v3;
}
// 8090: using guessed type __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001B730) ----------------------------------------------------
unsigned __int64 bdfWarning(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v3; // [rsp+18h] [rbp-D0h]

  va_start(va, a1);
  v3 = __readfsqword(0x28u);
  __fprintf_chk(stderr, 1LL, "BDF Warning on line %d: ", bdfFileLineNum);
  __vfprintf_chk(stderr, 1LL, a1, va);
  return __readfsqword(0x28u) ^ v3;
}
// 8090: using guessed type __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001B820) ----------------------------------------------------
unsigned __int64 __fastcall bdfGetLine(__int64 a1, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // r12
  signed __int64 v4; // r13
  __int64 v5; // rbx
  _BYTE *v6; // rbp
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 *v10; // rax
  bool v12; // cf
  bool v13; // zf
  signed __int64 v14; // rcx
  _BYTE *v15; // rsi
  const char *v16; // rdi

  v3 = a2;
  v4 = a3 - 1;
  v5 = a1;
  while ( 2 )
  {
    v6 = (_BYTE *)v3;
LABEL_3:
    v7 = *(_DWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 8) = v7 - 1;
    if ( v7 )
    {
      while ( 1 )
      {
        v10 = (unsigned __int8 *)(*(_QWORD *)v5)++;
        v8 = *v10;
LABEL_5:
        if ( v8 == 13 )
          goto LABEL_3;
        if ( v8 == 10 )
          break;
        if ( (signed __int64)&v6[-v3] >= v4 )
        {
          *v6 = 0;
          goto LABEL_12;
        }
        *(++v6 - 1) = v8;
        v9 = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 8) = v9 - 1;
        if ( !v9 )
          goto LABEL_4;
      }
      ++bdfFileLineNum;
      *v6 = 0;
LABEL_12:
      v12 = (unsigned __int64)v6 < v3;
      v13 = v6 == (_BYTE *)v3;
      if ( v6 != (_BYTE *)v3 )
      {
        v14 = 7LL;
        v15 = (_BYTE *)v3;
        v16 = "COMMENT";
        do
        {
          if ( !v14 )
            break;
          v12 = *v15 < (const unsigned __int8)*v16;
          v13 = *v15++ == *v16++;
          --v14;
        }
        while ( v13 );
        if ( (!v12 && !v13) != v12 )
          return v3;
      }
      continue;
    }
    break;
  }
LABEL_4:
  v8 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
  *(_DWORD *)(v5 + 12) = v8;
  if ( v8 != -1 )
    goto LABEL_5;
  *v6 = 0;
  return 0LL;
}

//----- (000000000001B900) ----------------------------------------------------
Atom __fastcall bdfForceMakeAtom(char *string, _DWORD *a2)
{
  unsigned int v2; // eax
  Atom v3; // rbx

  v2 = strlen(string);
  if ( a2 )
    *a2 += v2 + 1;
  v3 = MakeAtom(string, v2, 1);
  if ( !v3 )
    bdfError("Atom allocation failed\n");
  return v3;
}
// 81D0: using guessed type __int64 __fastcall bdfError(_QWORD);

//----- (000000000001B950) ----------------------------------------------------
__int64 __fastcall bdfGetPropertyValue(char *string)
{
  char v1; // al
  char *v2; // rbx
  unsigned __int64 v3; // rax
  char *v4; // rdx
  signed __int64 v5; // rcx
  signed __int64 v6; // rcx
  unsigned __int64 v7; // rax
  char *v9; // rbp
  unsigned int v10; // er13
  _BYTE *v11; // r14
  char v12; // al
  _BYTE *v13; // rdx
  char v14; // si
  __int64 v15; // rbx

  v1 = *string;
  v2 = string;
  if ( !*string )
    return bdfForceMakeAtom(v2);
  if ( v1 == 9 || v1 == 32 )
  {
    do
    {
      v1 = *++v2;
      if ( !*v2 )
        return bdfForceMakeAtom(v2);
    }
    while ( v1 == 32 || v1 == 9 );
  }
  if ( v1 != 34 )
  {
    v3 = (unsigned __int8)*v2;
    v4 = v2;
    if ( (unsigned __int8)v3 <= 0x20u && (v5 = 4294977024LL, _bittest64(&v5, v3)) )
    {
LABEL_14:
      *v4 = 0;
    }
    else
    {
      v6 = 4294977024LL;
      while ( 1 )
      {
        v7 = (unsigned __int8)*++v4;
        if ( !(_BYTE)v7 )
          break;
        if ( (unsigned __int8)v7 <= 0x20u && _bittest64(&v6, v7) )
          goto LABEL_14;
      }
    }
    return bdfForceMakeAtom(v2);
  }
  v9 = v2 + 1;
  v10 = strlen(v2 + 1) + 1;
  v11 = malloc(v10);
  if ( v11 )
  {
    v12 = v2[1];
    v13 = v11;
    if ( !v12 )
    {
LABEL_24:
      v15 = 0LL;
      free(v11);
      bdfError("unterminated quoted string property: %s\n");
      return v15;
    }
    while ( 1 )
    {
      if ( v12 == 34 )
      {
        if ( v9[1] != 34 )
        {
          *v13 = 0;
          v15 = bdfForceMakeAtom(v11);
          free(v11);
          return v15;
        }
        v12 = v9[2];
        v14 = 34;
        ++v9;
      }
      else
      {
        v14 = *v9;
        v12 = v9[1];
      }
      ++v13;
      ++v9;
      *(v13 - 1) = v14;
      if ( !v12 )
        goto LABEL_24;
    }
  }
  v15 = 0LL;
  bdfError("Couldn't allocate property value string (%d)\n");
  return v15;
}
// 81D0: using guessed type __int64 __fastcall bdfError(_QWORD);

//----- (000000000001BAB0) ----------------------------------------------------
signed __int64 __fastcall bdfIsInteger(char *a1)
{
  signed __int64 v1; // rbx
  char v2; // bp
  const unsigned __int16 **v3; // rax
  const unsigned __int16 *v4; // rdx
  signed __int64 result; // rax
  __int64 v6; // rax

  v1 = (signed __int64)(a1 + 1);
  v2 = *a1;
  v3 = __ctype_b_loc();
  v4 = *v3;
  if ( (*v3)[v2] & 0x800 || (result = 0LL, !((v2 - 43) & 0xFD)) )
  {
    do
    {
      v6 = *(char *)(++v1 - 1);
      if ( !(_BYTE)v6 )
        return 1LL;
    }
    while ( v4[v6] & 0x800 );
    result = 0LL;
  }
  return result;
}

//----- (000000000001BB20) ----------------------------------------------------
__int64 __fastcall bdfHexByte(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // ebp
  int v3; // esi

  v1 = a1;
  v2 = 0;
  do
  {
    v3 = *(char *)(++v1 - 1);
    if ( (unsigned __int8)(*(_BYTE *)(v1 - 1) - 48) > 9u )
    {
      if ( (unsigned __int8)(v3 - 65) > 5u )
      {
        if ( (unsigned __int8)(v3 - 97) > 5u )
          bdfError("bad hex char '%c'");
        else
          v2 = v3 + 16 * v2 - 87;
      }
      else
      {
        v2 = v3 + 16 * v2 - 55;
      }
    }
    else
    {
      v2 = v3 - 48 + 16 * v2;
    }
  }
  while ( a1 + 2 != v1 );
  return v2;
}
// 81D0: using guessed type __int64 __fastcall bdfError(_QWORD);

//----- (000000000001BB90) ----------------------------------------------------
signed __int64 __fastcall bdfSpecialProperty(_WORD *a1, Atom *a2, char a3, __int64 a4)
{
  char v4; // r14
  __int64 v5; // r13
  Atom *v6; // r12
  char *v7; // rax
  const char *v8; // rsi
  const char *v9; // rbx
  const char **v10; // r15
  signed __int64 result; // rax

  v4 = a3;
  v5 = a4;
  v6 = a2;
  v7 = NameForAtom(*a2);
  v8 = off_23BA80[0];
  if ( off_23BA80[0] )
  {
    v9 = v7;
    v10 = (const char **)off_23BA80;
    do
    {
      if ( !strcmp(v9, v8) )
        break;
      ++v10;
      v8 = *v10;
    }
    while ( *v10 );
    switch ( ((char *)v10 - (char *)off_23BA80) >> 3 )
    {
      case 0LL:
        goto LABEL_19;
      case 1LL:
        result = 1LL;
        if ( !v4 )
        {
          a1[37] = v6[1];
          *(_BYTE *)(v5 + 1129) = 1;
        }
        break;
      case 2LL:
        result = 1LL;
        if ( !v4 )
        {
          a1[8] = v6[1];
          *(_BYTE *)(v5 + 1130) = 1;
        }
        break;
      case 3LL:
        *(_QWORD *)(v5 + 1072) = v6;
        result = 0LL;
        break;
      case 4LL:
        *(_QWORD *)(v5 + 1096) = v6;
        result = 0LL;
        break;
      case 5LL:
        *(_QWORD *)(v5 + 1104) = v6;
        result = 0LL;
        break;
      case 6LL:
        *(_QWORD *)(v5 + 1112) = v6;
        result = 0LL;
        break;
      case 7LL:
        *(_QWORD *)(v5 + 1120) = v6;
        result = 0LL;
        break;
      case 8LL:
        *(_QWORD *)(v5 + 1064) = v6;
        result = 0LL;
        break;
      case 9LL:
        *(_QWORD *)(v5 + 1080) = v6;
        result = 0LL;
        break;
      case 10LL:
        *(_QWORD *)(v5 + 1088) = v6;
        result = 0LL;
        break;
      default:
        result = 0LL;
        break;
    }
  }
  else
  {
LABEL_19:
    result = 1LL;
    if ( !v4 )
    {
      a1[36] = v6[1];
      *(_BYTE *)(v5 + 1128) = 1;
    }
  }
  return result;
}
// 23BA80: using guessed type char *off_23BA80[8];

//----- (000000000001BD20) ----------------------------------------------------
signed __int64 __fastcall bitmapGetGlyphs(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned int a4, signed __int64 *a5, _QWORD *a6)
{
  _QWORD *v6; // r12
  int v7; // er11
  __int64 v8; // rax
  __int64 v9; // rbp
  __int64 v10; // rbx
  unsigned int v11; // er10
  int v12; // ecx
  unsigned int v13; // edi
  int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // er13
  unsigned int v17; // eax
  __int64 v18; // r13
  __int64 v19; // rax
  signed __int64 v21; // rax
  unsigned __int8 *v22; // rdi
  unsigned int v23; // eax
  __int64 v24; // r12
  __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // r12
  __int64 v28; // rdi
  unsigned int v29; // ecx
  unsigned int v30; // eax
  __int64 v31; // rcx
  __int64 v32; // rax
  unsigned __int8 *v33; // rsi
  unsigned int i; // eax
  __int64 v35; // rcx
  __int64 v36; // rax

  v6 = a6;
  v7 = *(unsigned __int16 *)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 152);
  v9 = *(_QWORD *)(v8 + 40);
  v10 = *(_QWORD *)(v8 + 48);
  v11 = *(unsigned __int16 *)(a1 + 10) + 1 - v7;
  if ( a4 == 2 )
  {
    if ( !(*(_BYTE *)(a1 + 18) & 0x40) || (v26 = 0LL, !v10) )
    {
      while ( --a2 != -1 )
      {
        while ( 1 )
        {
          a3 += 2;
          v30 = (unsigned __int16)__ROL2__(*((_WORD *)a3 - 1), 8) - v7;
          if ( v11 <= v30 )
            break;
          v31 = *(_QWORD *)(v9 + 8LL * (v30 >> 7));
          if ( !v31 )
            break;
          v32 = *(_QWORD *)(v31 + 8LL * (v30 & 0x7F));
          if ( !v32 )
            break;
          --a2;
          *a6 = v32;
          ++a6;
          if ( a2 == -1 )
            goto LABEL_11;
        }
        if ( v10 )
        {
          *a6 = v10;
          ++a6;
        }
      }
      goto LABEL_11;
    }
    while ( v26 != a2 )
    {
      v29 = (unsigned __int16)__ROL2__(*(_WORD *)&a3[2 * v26], 8) - v7;
      if ( v11 > v29 )
      {
        v27 = *(_QWORD *)(v9 + 8LL * (v29 >> 7));
        v28 = 0LL;
        if ( v27 )
          v28 = *(_QWORD *)(v27 + 8LL * (v29 & 0x7F));
        a6[v26] = v28;
      }
      else
      {
        a6[v26] = v10;
      }
      ++v26;
    }
    v21 = 8 * v26 >> 3;
  }
  else if ( a4 < 2 )
  {
    v21 = 0LL;
    if ( !*(_WORD *)(a1 + 12) )
    {
      if ( !(*(_BYTE *)(a1 + 18) & 0x40) || (v22 = &a3[a2], !v10) )
      {
        v33 = &a3[a2];
        while ( v33 != a3 )
        {
          for ( i = *(++a3 - 1) - v7; v11 > i; i = *(++a3 - 1) - v7 )
          {
            v35 = *(_QWORD *)(v9 + 8LL * (i >> 7));
            if ( !v35 )
              break;
            v36 = *(_QWORD *)(v35 + 8LL * (i & 0x7F));
            if ( !v36 )
              break;
            *a6 = v36;
            ++a6;
            if ( v33 == a3 )
              goto LABEL_11;
          }
          if ( v10 )
          {
            *a6 = v10;
            ++a6;
          }
        }
        goto LABEL_11;
      }
      while ( v22 != a3 )
      {
        while ( 1 )
        {
          ++a3;
          ++a6;
          v23 = *(a3 - 1) - v7;
          if ( v11 <= v23 )
            break;
          v24 = *(_QWORD *)(v9 + 8LL * (v23 >> 7));
          v25 = 0LL;
          if ( v24 )
            v25 = *(_QWORD *)(v24 + 8LL * (v23 & 0x7F));
          *(a6 - 1) = v25;
          if ( v22 == a3 )
            goto LABEL_24;
        }
        *(a6 - 1) = v10;
      }
LABEL_24:
      v21 = 8 * a2 >> 3;
    }
  }
  else
  {
    if ( a4 == 3 )
    {
      v12 = *(unsigned __int16 *)(a1 + 12);
      v13 = *(unsigned __int16 *)(a1 + 14) + 1 - v12;
      while ( --a2 != -1 )
      {
        while ( 1 )
        {
          v14 = *a3;
          a3 += 2;
          v15 = v14 - v12;
          v16 = *(a3 - 1) - v7;
          if ( v13 <= v15 )
            break;
          if ( v11 <= v16 )
            break;
          v17 = v16 + v11 * v15;
          v18 = *(_QWORD *)(v9 + 8LL * (v17 >> 7));
          if ( !v18 )
            break;
          v19 = *(_QWORD *)(v18 + 8LL * (v17 & 0x7F));
          if ( !v19 )
            break;
          --a2;
          *a6 = v19;
          ++a6;
          if ( a2 == -1 )
            goto LABEL_11;
        }
        if ( v10 )
        {
          *a6 = v10;
          ++a6;
        }
      }
LABEL_11:
      *a5 = a6 - v6;
      return 85LL;
    }
    v21 = 0LL;
  }
  *a5 = v21;
  return 85LL;
}

//----- (000000000001BFF0) ----------------------------------------------------
__int64 __fastcall bitmapGetMetrics(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 *a5, __int64 a6)
{
  unsigned __int64 *v6; // r12
  _QWORD *v7; // rbp
  __int64 v8; // rbx
  __int64 v9; // r14
  __int64 result; // rax
  __int64 v11; // rsi
  __int64 v12; // rdi
  unsigned __int64 v13; // rcx
  void *v14; // rdx

  v6 = a5;
  v7 = *(_QWORD **)(a1 + 152);
  v8 = a6;
  v9 = v7[6];
  v7[6] = &unk_23CCB0;
  result = j_bitmapGetGlyphs();
  if ( (_DWORD)result == 85 && (v11 = v7[3]) != 0 && (v12 = v7[2], *v6) )
  {
    v13 = 0LL;
    do
    {
      v14 = *(void **)(v8 + 8 * v13);
      if ( v14 != &unk_23CCB0 )
        *(_QWORD *)(v8 + 8 * v13) = v11 + 4 * ((_QWORD)((_QWORD)v14 - v12) >> 3);
      ++v13;
    }
    while ( *v6 > v13 );
    v7[6] = v9;
  }
  else
  {
    v7[6] = v9;
  }
  return result;
}
// 90B8: using guessed type __int64 j_bitmapGetGlyphs(void);

//----- (000000000001C080) ----------------------------------------------------
signed __int64 __fastcall sub_1C080(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  char *v4; // r12
  __int64 v5; // rax
  signed __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // r12
  unsigned int v9; // ebx

  v4 = a4;
  v5 = FontFileMatchRenderer(a4);
  if ( !v5 )
    return 83LL;
  v6 = 7905747460161236407LL * ((v5 - (signed __int64)&off_23BAE0) >> 3);
  v7 = FontFileOpen(v4);
  v8 = v7;
  if ( !v7 )
    return 83LL;
  v9 = ((__int64 (__fastcall *)(__int64, __int64))off_23ABE0[2 * (signed int)v6 + 1])(a2, v7);
  FontFileClose(v8);
  return v9;
}
// 8B70: using guessed type __int64 __fastcall FontFileClose(_QWORD);
// 8F10: using guessed type __int64 __fastcall FontFileMatchRenderer(_QWORD);
// 23ABE0: using guessed type __int64 (__fastcall *off_23ABE0[18])();
// 23BAE0: using guessed type char *off_23BAE0;

//----- (000000000001C100) ----------------------------------------------------
__int64 __fastcall sub_1C100(__int64 a1, FontPtr *a2, __int64 a3, __int64 a4, char *a5, unsigned int a6, unsigned int a7)
{
  unsigned int v7; // er15
  unsigned int v8; // er14
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rbp
  FontPtr v12; // r13
  unsigned int v14; // [rsp+24h] [rbp-54h]
  unsigned int v15; // [rsp+28h] [rbp-50h]
  unsigned int v16; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v17; // [rsp+30h] [rbp-48h]
  char v18; // [rsp+34h] [rbp-44h]
  unsigned __int64 v19; // [rsp+38h] [rbp-40h]

  v7 = a6;
  v8 = 83;
  v9 = *(_QWORD *)(a4 + 24);
  v19 = __readfsqword(0x28u);
  v10 = FontFileOpen(a5);
  if ( v10 )
  {
    v11 = v10;
    v12 = CreateFontRec();
    if ( v12 )
    {
      FontDefaultFormat(&v14, &v15, &v16, &v17);
      CheckFSFormat(v7, a7, &v14, &v15, &v17, &v16, &v18);
      v12->refcnt = 0;
      v8 = ((__int64 (__fastcall *)(FontPtr, __int64, _QWORD, _QWORD, _QWORD, _QWORD))off_23ABE0[2
                                                                                               * (signed int)(-1227133513 * (unsigned __int64)((v9 - (signed __int64)&off_23BAE0) >> 3))])(
             v12,
             v11,
             v14,
             v15,
             v16,
             v17);
      FontFileClose(v11);
      if ( v8 == 85 )
        *a2 = v12;
      else
        free(v12);
    }
    else
    {
      v8 = 80;
      __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate pFont (%ld)\n", 184LL);
      FontFileClose(v11);
    }
  }
  return v8;
}
// 8630: using guessed type __int64 __fastcall FontDefaultFormat(_QWORD, _QWORD, _QWORD, _QWORD);
// 8B70: using guessed type __int64 __fastcall FontFileClose(_QWORD);
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8EB0: using guessed type __int64 __fastcall CheckFSFormat(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 23ABE0: using guessed type __int64 (__fastcall *off_23ABE0[18])();
// 23BAE0: using guessed type char *off_23BAE0;

//----- (000000000001C280) ----------------------------------------------------
__int64 BitmapRegisterFontFileFunctions()
{
  char **v0; // rbx
  char **v1; // rdi
  __int64 result; // rax

  v0 = &off_23BAE0;
  do
  {
    v1 = v0;
    v0 += 7;
    result = FontFileRegisterRenderer(v1);
  }
  while ( v0 != &off_23BAE0 + 63 );
  return result;
}
// 86D0: using guessed type __int64 __fastcall FontFileRegisterRenderer(_QWORD);
// 23BAE0: using guessed type char *off_23BAE0;

//----- (000000000001C2B0) ----------------------------------------------------
__int16 __fastcall bitmapComputeFontBounds(__int64 a1)
{
  __int64 v1; // r9
  __int64 v2; // rcx
  signed __int64 v3; // rsi
  signed __int64 v4; // rcx
  int v5; // edx
  __int16 *v6; // rax
  int v7; // er10
  int v8; // er11
  signed __int64 v9; // rbp
  int v10; // edx
  __int16 v11; // r8
  __int16 v12; // r8
  __int16 v13; // r8
  __int16 v14; // r8
  __int16 v15; // r8
  __int16 *v16; // rax
  __int16 v17; // cx
  int v18; // er8
  int v19; // ebx
  int v20; // ebx
  int v21; // ecx
  unsigned __int16 v22; // r13
  unsigned __int16 v23; // r12
  int v24; // ebp
  int v25; // esi
  __int16 v26; // r15
  int v27; // er15
  int v28; // er15
  __int16 v29; // r15
  __int16 v30; // r15
  __int16 v31; // r15
  __int16 v32; // r15
  __int16 v33; // ax

  v1 = *(_QWORD *)(a1 + 152);
  v2 = *(_QWORD *)(v1 + 56);
  if ( v2 )
  {
    v3 = v2 + 60;
    v4 = v2 + 48;
  }
  else
  {
    v3 = a1 + 36;
    v4 = a1 + 24;
  }
  *(_QWORD *)v3 = 9223231297218904063LL;
  *(_DWORD *)(v3 + 8) = -32769;
  *(_QWORD *)v4 = -9223231297218904064LL;
  *(_DWORD *)(v4 + 8) = 0x8000;
  v5 = *(_DWORD *)(v1 + 4);
  v6 = *(__int16 **)(v1 + 16);
  if ( v5 <= 0 )
  {
    v16 = *(__int16 **)(v1 + 56);
    v7 = 0;
    v8 = 0;
    LOWORD(v10) = -32768;
    if ( v16 )
      goto LABEL_78;
    goto LABEL_75;
  }
  v7 = 0;
  v8 = 0;
  v9 = (signed __int64)&v6[12 * (v5 - 1) + 12];
  v10 = -32768;
  do
  {
    v12 = v6[3];
    if ( !v12 && !v6[4] && !(*(_QWORD *)v6 & 0xFFFFFFFFFFFFLL) )
      goto LABEL_7;
    if ( v12 < *(_WORD *)(v3 + 6) )
    {
      *(_WORD *)(v3 + 6) = v12;
      v12 = v6[3];
    }
    if ( *(_WORD *)(v4 + 6) < v12 )
      *(_WORD *)(v4 + 6) = v12;
    v13 = v6[4];
    if ( *(_WORD *)(v3 + 8) > v13 )
    {
      *(_WORD *)(v3 + 8) = v13;
      v13 = v6[4];
    }
    if ( *(_WORD *)(v4 + 8) < v13 )
      *(_WORD *)(v4 + 8) = v13;
    v14 = *v6;
    if ( *(_WORD *)v3 > *v6 )
    {
      *(_WORD *)v3 = v14;
      v14 = *v6;
    }
    if ( *(_WORD *)v4 < v14 )
      *(_WORD *)v4 = v14;
    v15 = v6[1];
    if ( *(_WORD *)(v3 + 2) > v15 )
    {
      *(_WORD *)(v3 + 2) = v15;
      v15 = v6[1];
    }
    if ( *(_WORD *)(v4 + 2) < v15 )
      *(_WORD *)(v4 + 2) = v15;
    v11 = v6[2];
    if ( *(_WORD *)(v3 + 4) > v11 )
    {
      *(_WORD *)(v3 + 4) = v11;
      v11 = v6[2];
    }
    if ( *(_WORD *)(v4 + 4) < v11 )
    {
      *(_WORD *)(v4 + 4) = v11;
LABEL_7:
      v11 = v6[2];
    }
    if ( v11 < 0 )
      ++v8;
    else
      ++v7;
    *(_WORD *)(v3 + 10) &= v6[5];
    *(_WORD *)(v4 + 10) |= v6[5];
    if ( v10 < v6[1] - v6[2] )
      v10 = v6[1] - v6[2];
    v6 += 12;
  }
  while ( (__int16 *)v9 != v6 );
  v16 = *(__int16 **)(v1 + 56);
  if ( v16 )
  {
    if ( v8 > v7 )
    {
      v17 = v16[21] & 0xFE7F;
      LOBYTE(v17) = v17 | 0x80;
      v16[21] = v17;
      goto LABEL_38;
    }
LABEL_78:
    v16[21] &= 0xFE7Fu;
LABEL_38:
    *(_WORD *)(*(_QWORD *)(v1 + 56) + 44LL) = v10;
    v18 = *(unsigned __int16 *)(a1 + 12);
    LOWORD(v10) = -32768;
    v19 = *(unsigned __int16 *)(a1 + 14);
    LOWORD(v16) = 0x7FFF;
    *(_DWORD *)(a1 + 44) = -32769;
    *(_QWORD *)(a1 + 24) = -9223231297218904064LL;
    *(_DWORD *)(a1 + 32) = 0x8000;
    *(_QWORD *)(a1 + 36) = 9223231297218904063LL;
    if ( v18 <= v19 )
    {
      LODWORD(v16) = *(unsigned __int16 *)(a1 + 8);
      v20 = v19 + 1;
      v21 = 0;
      v10 = -32768;
      v22 = *(_WORD *)(a1 + 10);
      v23 = *(_WORD *)(a1 + 8);
      v24 = *(unsigned __int16 *)(a1 + 10) + 1 - (_DWORD)v16;
      while ( v23 > v22 )
      {
LABEL_73:
        if ( v20 == ++v18 )
          goto LABEL_74;
      }
      v25 = v24 + v21;
      while ( 2 )
      {
        v16 = *(__int16 **)(*(_QWORD *)(v1 + 40) + 8LL * (v21 >> 7));
        if ( v16 )
        {
          v16 = *(__int16 **)&v16[4 * (v21 & 0x7F)];
          if ( v16 )
          {
            v29 = v16[3];
            if ( v29 || v16[4] || *(_QWORD *)v16 & 0xFFFFFFFFFFFFLL )
            {
              if ( v29 < *(_WORD *)(a1 + 42) )
              {
                *(_WORD *)(a1 + 42) = v29;
                v29 = v16[3];
              }
              if ( *(_WORD *)(a1 + 30) < v29 )
                *(_WORD *)(a1 + 30) = v29;
              v30 = v16[4];
              if ( *(_WORD *)(a1 + 44) > v30 )
              {
                *(_WORD *)(a1 + 44) = v30;
                v30 = v16[4];
              }
              if ( *(_WORD *)(a1 + 32) < v30 )
                *(_WORD *)(a1 + 32) = v30;
              v31 = *v16;
              if ( *(_WORD *)(a1 + 36) > *v16 )
              {
                *(_WORD *)(a1 + 36) = v31;
                v31 = *v16;
              }
              if ( *(_WORD *)(a1 + 24) < v31 )
                *(_WORD *)(a1 + 24) = v31;
              v32 = v16[1];
              if ( *(_WORD *)(a1 + 38) > v32 )
              {
                *(_WORD *)(a1 + 38) = v32;
                v32 = v16[1];
              }
              if ( *(_WORD *)(a1 + 26) < v32 )
                *(_WORD *)(a1 + 26) = v32;
              v26 = v16[2];
              if ( *(_WORD *)(a1 + 40) > v26 )
              {
                *(_WORD *)(a1 + 40) = v26;
                v26 = v16[2];
              }
              if ( *(_WORD *)(a1 + 28) < v26 )
              {
                *(_WORD *)(a1 + 28) = v26;
                goto LABEL_44;
              }
            }
            else
            {
LABEL_44:
              v26 = v16[2];
            }
            if ( v26 < 0 )
              ++v8;
            else
              ++v7;
            *(_WORD *)(a1 + 46) &= v16[5];
            *(_WORD *)(a1 + 34) |= v16[5];
            v27 = v16[1];
            LODWORD(v16) = v16[2];
            v28 = v27 - (_DWORD)v16;
            if ( v10 < v28 )
              v10 = v28;
          }
        }
        if ( v25 == ++v21 )
          goto LABEL_73;
        continue;
      }
    }
  }
LABEL_74:
  if ( v8 > v7 )
  {
    v33 = *(_WORD *)(a1 + 18);
    *(_WORD *)(a1 + 20) = v10;
    LOWORD(v16) = v33 & 0xFE7F;
    LOBYTE(v16) = (unsigned __int8)v16 | 0x80;
    *(_WORD *)(a1 + 18) = (_WORD)v16;
  }
  else
  {
LABEL_75:
    *(_WORD *)(a1 + 18) &= 0xFE7Fu;
    *(_WORD *)(a1 + 20) = v10;
  }
  return (signed __int16)v16;
}

//----- (000000000001C6B0) ----------------------------------------------------
signed __int64 __fastcall bitmapComputeFontInkBounds(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // rdx
  signed __int64 v3; // rsi
  signed __int64 v4; // rdx
  int v5; // er8
  signed __int64 result; // rax
  signed __int64 v7; // r9
  __int16 v8; // r8
  __int16 v9; // r8
  __int16 v10; // r8
  __int16 v11; // r8
  __int16 v12; // r8
  __int16 v13; // r8
  int v14; // er8
  int v15; // er10
  int v16; // er10
  int v17; // edx
  unsigned __int16 v18; // bp
  unsigned __int16 v19; // bx
  int v20; // er11
  int v21; // esi
  __int16 *v22; // rax
  __int16 v23; // r12
  __int16 v24; // r12
  __int16 v25; // r12
  __int16 v26; // r12
  __int16 v27; // r12
  __int64 v28; // rax

  v1 = *(_QWORD *)(a1 + 152);
  v2 = *(_QWORD *)(v1 + 56);
  if ( *(_QWORD *)(v1 + 24) )
  {
    if ( v2 )
    {
      v3 = v2 + 84;
      v4 = v2 + 72;
    }
    else
    {
      v3 = a1 + 60;
      v4 = a1 + 48;
    }
    *(_QWORD *)v3 = 9223231297218904063LL;
    *(_DWORD *)(v3 + 8) = -32769;
    *(_QWORD *)v4 = -9223231297218904064LL;
    *(_DWORD *)(v4 + 8) = 0x8000;
    v5 = *(_DWORD *)(v1 + 4);
    result = *(_QWORD *)(v1 + 24);
    if ( v5 > 0 )
    {
      v7 = result + 4 * (3LL * (unsigned int)(v5 - 1) + 3);
      do
      {
        v8 = *(_WORD *)(result + 6);
        if ( v8 || *(_WORD *)(result + 8) || *(_WORD *)result || *(_WORD *)(result + 2) || *(_WORD *)(result + 4) )
        {
          if ( v8 < *(_WORD *)(v3 + 6) )
          {
            *(_WORD *)(v3 + 6) = v8;
            v8 = *(_WORD *)(result + 6);
          }
          if ( *(_WORD *)(v4 + 6) < v8 )
            *(_WORD *)(v4 + 6) = v8;
          v9 = *(_WORD *)(result + 8);
          if ( *(_WORD *)(v3 + 8) > v9 )
          {
            *(_WORD *)(v3 + 8) = v9;
            v9 = *(_WORD *)(result + 8);
          }
          if ( *(_WORD *)(v4 + 8) < v9 )
            *(_WORD *)(v4 + 8) = v9;
          v10 = *(_WORD *)result;
          if ( *(_WORD *)v3 > *(_WORD *)result )
          {
            *(_WORD *)v3 = v10;
            v10 = *(_WORD *)result;
          }
          if ( *(_WORD *)v4 < v10 )
            *(_WORD *)v4 = v10;
          v11 = *(_WORD *)(result + 2);
          if ( *(_WORD *)(v3 + 2) > v11 )
          {
            *(_WORD *)(v3 + 2) = v11;
            v11 = *(_WORD *)(result + 2);
          }
          if ( *(_WORD *)(v4 + 2) < v11 )
            *(_WORD *)(v4 + 2) = v11;
          v12 = *(_WORD *)(result + 4);
          if ( *(_WORD *)(v3 + 4) > v12 )
          {
            *(_WORD *)(v3 + 4) = v12;
            v12 = *(_WORD *)(result + 4);
          }
          if ( *(_WORD *)(v4 + 4) < v12 )
            *(_WORD *)(v4 + 4) = v12;
        }
        v13 = *(_WORD *)(result + 10);
        result += 12LL;
        *(_WORD *)(v3 + 10) &= v13;
        *(_WORD *)(v4 + 10) |= *(_WORD *)(result - 2);
      }
      while ( v7 != result );
    }
    if ( *(_QWORD *)(v1 + 56) )
    {
      *(_DWORD *)(a1 + 56) = 0x8000;
      v14 = *(unsigned __int16 *)(a1 + 12);
      v15 = *(unsigned __int16 *)(a1 + 14);
      *(_QWORD *)(a1 + 60) = 9223231297218904063LL;
      *(_DWORD *)(a1 + 68) = -32769;
      *(_QWORD *)(a1 + 48) = -9223231297218904064LL;
      if ( v14 <= v15 )
      {
        result = *(unsigned __int16 *)(a1 + 8);
        v16 = v15 + 1;
        v17 = 0;
        v18 = *(_WORD *)(a1 + 10);
        v19 = *(_WORD *)(a1 + 8);
        v20 = *(unsigned __int16 *)(a1 + 10) + 1 - result;
        do
        {
          if ( v19 <= v18 )
          {
            v21 = v20 + v17;
            do
            {
              result = *(_QWORD *)(*(_QWORD *)(v1 + 40) + 8LL * (v17 >> 7));
              if ( result )
              {
                result = *(_QWORD *)(result + 8LL * (v17 & 0x7F));
                if ( result )
                {
                  v22 = (__int16 *)(*(_QWORD *)(v1 + 24)
                                  + 12LL
                                  * (signed int)(-1431655765 * (unsigned __int64)((result - *(_QWORD *)(v1 + 16)) >> 3)));
                  v23 = v22[3];
                  if ( v23 || v22[4] || *v22 || v22[1] || v22[2] )
                  {
                    if ( v23 < *(_WORD *)(a1 + 66) )
                    {
                      *(_WORD *)(a1 + 66) = v23;
                      v23 = v22[3];
                    }
                    if ( *(_WORD *)(a1 + 54) < v23 )
                      *(_WORD *)(a1 + 54) = v23;
                    v24 = v22[4];
                    if ( *(_WORD *)(a1 + 68) > v24 )
                    {
                      *(_WORD *)(a1 + 68) = v24;
                      v24 = v22[4];
                    }
                    if ( *(_WORD *)(a1 + 56) < v24 )
                      *(_WORD *)(a1 + 56) = v24;
                    v25 = *v22;
                    if ( *(_WORD *)(a1 + 60) > *v22 )
                    {
                      *(_WORD *)(a1 + 60) = v25;
                      v25 = *v22;
                    }
                    if ( *(_WORD *)(a1 + 48) < v25 )
                      *(_WORD *)(a1 + 48) = v25;
                    v26 = v22[1];
                    if ( *(_WORD *)(a1 + 62) > v26 )
                    {
                      *(_WORD *)(a1 + 62) = v26;
                      v26 = v22[1];
                    }
                    if ( *(_WORD *)(a1 + 50) < v26 )
                      *(_WORD *)(a1 + 50) = v26;
                    v27 = v22[2];
                    if ( *(_WORD *)(a1 + 64) > v27 )
                    {
                      *(_WORD *)(a1 + 64) = v27;
                      v27 = v22[2];
                    }
                    if ( *(_WORD *)(a1 + 52) < v27 )
                      *(_WORD *)(a1 + 52) = v27;
                  }
                  *(_WORD *)(a1 + 70) &= v22[5];
                  result = (unsigned __int16)v22[5];
                  *(_WORD *)(a1 + 58) |= result;
                }
              }
              ++v17;
            }
            while ( v21 != v17 );
          }
          ++v14;
        }
        while ( v16 != v14 );
      }
    }
  }
  else
  {
    if ( v2 )
    {
      *(_QWORD *)(v2 + 84) = *(_QWORD *)(v2 + 60);
      *(_DWORD *)(v2 + 92) = *(_DWORD *)(v2 + 68);
      v28 = *(_QWORD *)(v1 + 56);
      *(_QWORD *)(v28 + 72) = *(_QWORD *)(v28 + 48);
      *(_DWORD *)(v28 + 80) = *(_DWORD *)(v28 + 56);
    }
    *(_QWORD *)(a1 + 60) = *(_QWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 44);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 24);
    result = *(unsigned int *)(a1 + 32);
    *(_DWORD *)(a1 + 56) = result;
  }
  return result;
}

//----- (000000000001CA20) ----------------------------------------------------
signed __int64 __fastcall bitmapAddInkMetrics(__int64 a1)
{
  __int64 v1; // rbp
  unsigned int v2; // er14
  char *v3; // rax
  __int64 v4; // rbx
  int v5; // er12
  char *v6; // rdx
  signed __int64 v7; // rsi
  signed __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 152);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = (char *)malloc(12LL * *(signed int *)(v1 + 4));
  *(_QWORD *)(v1 + 24) = v3;
  if ( v3 )
  {
    v4 = 0LL;
    v5 = 0;
    if ( (signed int)v2 > 0 )
    {
      while ( 1 )
      {
        v6 = &v3[v4];
        ++v5;
        v7 = *(_QWORD *)(v1 + 16) + 2 * v4;
        v4 += 12LL;
        FontCharInkMetrics(a1, v7, v6);
        if ( *(_DWORD *)(v1 + 4) <= v5 )
          break;
        v3 = *(char **)(v1 + 24);
      }
    }
    *(_BYTE *)(a1 + 18) |= 0x20u;
    result = 1LL;
  }
  else
  {
    __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate ink_metrics (%d*%ld)\n", v2);
    result = 0LL;
  }
  return result;
}
// 8060: using guessed type __int64 __fastcall FontCharInkMetrics(_QWORD, _QWORD, _QWORD);
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CAE0) ----------------------------------------------------
signed __int64 bitmapComputeWeight()
{
  return 10LL;
}

//----- (000000000001CAF0) ----------------------------------------------------
signed __int64 __fastcall sub_1CAF0(__int64 a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7)
{
  double *v7; // r15
  double *v8; // r14
  double *v9; // rbp
  double *v10; // r12
  double *v11; // r13
  double v12; // xmm0_8
  signed int v13; // esi
  signed int v14; // eax
  double v15; // xmm5_8
  double v16; // xmm2_8
  signed __int64 result; // rax
  double v18; // [rsp+8h] [rbp-50h]
  double v19; // [rsp+10h] [rbp-48h]
  double v20; // [rsp+18h] [rbp-40h]

  v7 = a3;
  v8 = a4;
  v9 = a2;
  v10 = a5;
  v11 = a6;
  v19 = hypot(*(double *)(a1 + 8), *(double *)(a1 + 16));
  v20 = hypot(a2[1], a2[2]);
  v18 = hypot(*(double *)(a1 + 24), *(double *)(a1 + 32));
  v12 = hypot(a2[3], a2[4]);
  if ( v19 < 9.999999999999999e-21 )
  {
    *v7 = 0.0;
    *v10 = 0.0;
  }
  else
  {
    *v7 = v20 / v19;
    *v10 = 1000.0 / v19;
  }
  *a7 = 1.0;
  v13 = *(_DWORD *)(a1 + 88);
  if ( v13 > 0 )
  {
    v14 = *((_DWORD *)v9 + 22);
    if ( v14 > 0 )
    {
      v15 = *v7;
      if ( COERCE_DOUBLE(*(_QWORD *)v7 & xmmword_30160) > 9.999999999999999e-21 )
      {
        v16 = (double)v14 / (double)v13;
        if ( (*(_DWORD *)v9 & 3) == 2 || (*(_DWORD *)v9 & 0xC) == 8 )
        {
          result = 0LL;
          if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v16 * (double)v13 - (double)v13 * v15) & xmmword_30160) >= 10.0 )
            return result;
        }
        else
        {
          *a7 = v16 / v15;
          *v7 = v16;
        }
      }
    }
  }
  if ( v18 >= 9.999999999999999e-21 )
  {
    result = 1LL;
    *v8 = v12 / v18;
    *v11 = 1000.0 / v18;
  }
  else
  {
    *v8 = 0.0;
    result = 1LL;
    *v11 = 0.0;
  }
  return result;
}
// 30160: using guessed type __int128 xmmword_30160;

//----- (000000000001CCD0) ----------------------------------------------------
signed __int64 __fastcall sub_1CCD0(double *a1, __int64 a2, double *a3, double *a4, _QWORD *a5, double a6, double a7)
{
  double *v7; // r14
  double *v8; // r12
  _QWORD *v9; // r13
  double v10; // xmm0_8
  double v11; // xmm8_8
  double v12; // xmm5_8
  double v13; // xmm6_8
  double v14; // xmm3_8
  double v15; // xmm4_8
  double v16; // xmm3_8
  double v17; // xmm0_8
  signed __int64 result; // rax
  double v19; // [rsp+8h] [rbp-40h]
  double v20; // [rsp+10h] [rbp-38h]

  v7 = a4;
  v8 = a3;
  v9 = a5;
  v20 = a6;
  v19 = hypot(a1[3], a1[4]);
  v10 = hypot(a1[1], a1[2]);
  if ( v19 < 9.999999999999999e-21 )
    return 0LL;
  if ( v10 < 9.999999999999999e-21 )
    return 0LL;
  *(_QWORD *)(a2 + 16) = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(double *)a2 = v20 / v10;
  *(double *)(a2 + 24) = a7 / v19;
  v11 = a1[3];
  v12 = a1[1];
  v13 = a1[4];
  v14 = a1[2];
  v15 = a1[3] * 0.0 + v20 / v10 * v12;
  *(double *)a2 = v15;
  *(double *)(a2 + 24) = v14 * 0.0 + v13 * (a7 / v19);
  *(double *)(a2 + 8) = v20 / v10 * v14 + v13 * 0.0;
  *(double *)(a2 + 16) = a7 / v19 * v11 + v12 * 0.0;
  *v7 = v15;
  *v9 = *(_QWORD *)(a2 + 24);
  v16 = *(double *)(a2 + 24);
  v17 = *(double *)a2 * v16 - *(double *)(a2 + 8) * *(double *)(a2 + 16);
  if ( COERCE_DOUBLE(*(_QWORD *)&v17 & xmmword_30160) < 9.999999999999999e-21 )
    return 0LL;
  result = 1LL;
  *v8 = v16 / v17;
  v8[1] = COERCE_DOUBLE(*(_QWORD *)(a2 + 8) ^ xmmword_30670) / v17;
  v8[2] = COERCE_DOUBLE(*(_QWORD *)(a2 + 16) ^ xmmword_30670) / v17;
  v8[3] = *(double *)a2 / v17;
  return result;
}
// 30160: using guessed type __int128 xmmword_30160;
// 30670: using guessed type __int128 xmmword_30670;

//----- (000000000001CE90) ----------------------------------------------------
void __fastcall sub_1CE90(FontPtr font)
{
  FontPtr v1; // r12
  pointer v2; // rbp
  char *v3; // rdi
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  __int64 v8; // rbx
  signed __int64 v9; // r13
  void *v10; // rdi

  v1 = font;
  v2 = font->fontPrivate;
  free(font->info.props);
  free(font->info.isStringProp);
  v3 = (char *)*((_QWORD *)v2 + 5);
  if ( v3 )
  {
    v4 = (v1->info.lastRow - v1->info.firstRow + 1) * (v1->info.lastCol - v1->info.firstCol + 1);
    v5 = v4 + 254;
    v6 = v4 + 127;
    if ( v6 < 0 )
      v6 = v5;
    v7 = v6 >> 7;
    if ( v7 > 0 )
    {
      v8 = 0LL;
      v9 = 8LL * (unsigned int)(v7 - 1) + 8;
      do
      {
        v10 = *(void **)&v3[v8];
        v8 += 8LL;
        free(v10);
        v3 = (char *)*((_QWORD *)v2 + 5);
      }
      while ( v8 != v9 );
    }
  }
  free(v3);
  free(*((void **)v2 + 4));
  free(*((void **)v2 + 3));
  free(*((void **)v2 + 2));
  free(v1->fontPrivate);
  DestroyFontRec(v1);
}

//----- (000000000001CF60) ----------------------------------------------------
__int64 __fastcall BitmapOpenScalable(__int64 a1, FontPtr *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7, unsigned int a8)
{
  __int64 v8; // r15
  double v9; // xmm1_8
  double v10; // xmm0_8
  __int64 v11; // rbx
  char *v12; // rdx
  int v13; // ecx
  unsigned int v14; // eax
  const char *v15; // rbx
  unsigned int v16; // ecx
  bool v17; // zf
  __int16 v18; // dx
  __int16 v19; // ax
  __int64 v20; // rdx
  __int64 v21; // r12
  __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v24; // r14
  __int64 v25; // r15
  int v26; // ebp
  double v27; // xmm4_8
  double v28; // xmm6_8
  double v29; // xmm5_8
  __int64 v30; // rbx
  signed int v31; // edx
  int v32; // eax
  unsigned int v33; // er13
  __int64 v35; // r15
  __int64 v36; // rax
  char **v37; // rax
  FontPtr v38; // xmm0_8
  signed int v39; // er13
  FontPtr v40; // r12
  FontPtr v41; // rax
  FontPtr v42; // rbp
  char v43; // al
  int v44; // eax
  unsigned __int8 *v45; // rcx
  signed int v46; // esi
  signed int v47; // edi
  signed int v48; // er9
  signed int v49; // er10
  signed __int64 v50; // r8
  signed __int64 v51; // rbx
  signed int v52; // edx
  signed int v53; // eax
  signed int v54; // er11
  signed int v55; // ecx
  signed int v56; // ebx
  void *v57; // rax
  void *v58; // r14
  int v59; // eax
  int v60; // eax
  void *v61; // rax
  int v62; // edi
  void *v63; // rax
  char v64; // al
  char v65; // al
  double v66; // xmm1_8
  signed int v67; // eax
  _WORD *v68; // r11
  int v69; // ebx
  __m128i v70; // xmm5
  _DWORD *v71; // r8
  struct _Font *v72; // r13
  __int64 v73; // xmm12_8
  double v74; // xmm11_8
  double v75; // xmm10_8
  signed int v76; // eax
  double v77; // xmm3_8
  double v78; // xmm1_8
  double v79; // xmm0_8
  double v80; // xmm4_8
  double v81; // xmm2_8
  double v82; // xmm15_8
  double v83; // xmm4_8
  double v84; // xmm1_8
  double v85; // xmm0_8
  double v86; // xmm2_8
  double v87; // xmm3_8
  double v88; // xmm1_8
  __m128d v89; // xmm9
  double v90; // xmm0_8
  double v91; // xmm2_8
  __m128d v92; // xmm13
  signed int v93; // edi
  __m128d v94; // xmm1
  __m128d v95; // xmm14
  signed int v96; // edx
  __m128d v97; // xmm4
  __m128d v98; // xmm0
  __m128d v99; // xmm3
  signed int v100; // eax
  signed int v101; // ecx
  double v102; // xmm0_8
  double v103; // xmm0_8
  signed int v104; // er9
  double v105; // xmm0_8
  double v106; // xmm0_8
  int v107; // eax
  int v108; // esi
  __int64 v109; // rdi
  signed __int16 *v110; // rbp
  int v111; // er10
  __int64 v112; // rax
  double v113; // xmm3_8
  double v114; // xmm2_8
  signed int v115; // eax
  double v116; // xmm8_8
  double v117; // xmm3_8
  double v118; // xmm4_8
  double v119; // xmm2_8
  double v120; // xmm13_8
  double v121; // xmm10_8
  double v122; // xmm14_8
  double v123; // xmm0_8
  double v124; // xmm3_8
  double v125; // xmm9_8
  double v126; // xmm8_8
  double v127; // xmm9_8
  __int64 v128; // rax
  int v129; // edx
  double v130; // xmm1_8
  double v131; // xmm8_8
  signed int v132; // edx
  double v133; // xmm1_8
  __int64 v134; // rax
  double v135; // xmm1_8
  double v136; // xmm1_8
  double v137; // xmm0_8
  _WORD *v138; // STE0_8
  _DWORD *v139; // STD8_8
  _QWORD *v140; // ST88_8
  __m128i v141; // STA0_16
  void *v142; // rax
  char *v143; // rdi
  int v144; // eax
  int v145; // eax
  __int64 v146; // rbx
  signed __int64 v147; // rbp
  void *v148; // rdi
  signed __int64 v149; // rcx
  int v150; // eax
  const char *v151; // rbp
  __int64 v152; // rdx
  __int64 v153; // rcx
  const char *v154; // rdx
  int v155; // er10
  int v156; // er9
  __int64 v157; // rbx
  int v158; // esi
  __int64 v159; // rax
  INT16 *v160; // rcx
  int v161; // eax
  int v162; // edx
  __int64 v163; // rdx
  INT16 v164; // ax
  INT16 v165; // ax
  INT16 v166; // ax
  INT16 v167; // ax
  INT16 v168; // ax
  signed __int16 v169; // ax
  signed __int64 v170; // rax
  double v171; // xmm0_8
  double v172; // xmm0_8
  int v173; // edx
  int v174; // ecx
  unsigned __int16 v175; // si
  int v176; // edi
  int v177; // eax
  unsigned int v178; // eax
  __int64 v179; // rdx
  __int64 v180; // rax
  pointer v181; // rdi
  _QWORD *v182; // rax
  int v183; // ecx
  int v184; // ebx
  int v185; // ecx
  int v186; // ebx
  unsigned int v187; // er12
  int v188; // er14
  __int64 v189; // rax
  signed __int16 *v190; // rax
  int v191; // edx
  __int64 v192; // r8
  __int64 v193; // rax
  signed __int16 *v194; // r12
  int v195; // eax
  int v196; // edx
  __int64 v197; // rdx
  __int64 v198; // rax
  signed __int16 *v199; // rdi
  int v200; // ebx
  int v201; // edx
  _BYTE *v202; // rax
  int v203; // ecx
  int v204; // edx
  int v205; // ebx
  char v206; // al
  _DWORD *v207; // r14
  _DWORD *v208; // rbp
  unsigned __int8 *v209; // r13
  double v210; // xmm6_8
  double v211; // xmm5_8
  double v212; // xmm8_8
  double v213; // xmm7_8
  signed __int64 v214; // rax
  int v215; // edi
  double v216; // xmm1_8
  double v217; // xmm0_8
  signed int v218; // esi
  signed int v219; // er8
  _DWORD *v220; // rcx
  __int64 v221; // rdx
  int v222; // er9
  int v223; // er11
  int v224; // er15
  int v225; // er10
  int v226; // eax
  int v227; // er9
  int v228; // er10
  int v229; // er9
  int v230; // eax
  int v231; // eax
  _DWORD *v232; // rax
  char **v233; // r12
  char *v234; // rbx
  unsigned int v235; // eax
  void **v236; // r12
  char *v237; // r14
  unsigned int v238; // eax
  char **v239; // r12
  char *v240; // r14
  unsigned int v241; // eax
  _BYTE *v242; // rbp
  char *v243; // rbx
  char **v244; // r15
  struct _FontProp *v245; // r13
  char *v246; // r12
  signed __int64 v247; // rax
  char *v248; // rax
  int v249; // ebx
  struct _FontProp *v250; // r8
  signed __int64 v251; // r11
  int v252; // eax
  double v253; // xmm7_8
  int v254; // er10
  char *v255; // rdi
  _QWORD *v256; // rsi
  signed __int64 v257; // rbx
  void *v258; // rdx
  void **v259; // rax
  int v260; // er9
  double v261; // xmm0_8
  double v262; // xmm0_8
  char *v263; // rsi
  int v264; // edx
  unsigned int v265; // eax
  Atom v266; // rax
  double v267; // xmm0_8
  unsigned int v268; // esi
  Atom v269; // rax
  char *v270; // rax
  double v271; // xmm0_8
  double v272; // xmm0_8
  double v273; // xmm0_8
  double v274; // xmm0_8
  int v275; // ecx
  int v276; // er9
  void *v277; // rax
  int v278; // eax
  int v279; // ebx
  int v280; // eax
  __int64 v281; // rbx
  signed __int64 v282; // rbp
  void *v283; // rdi
  __int64 v284; // rdx
  int v285; // eax
  double v286; // xmm3_8
  __m128d v287; // xmm1
  __m128d v288; // xmm0
  __m128d v289; // xmm0
  __m128d v290; // xmm2
  int v291; // er15
  __int64 v292; // rdi
  char *v293; // rcx
  int v294; // er10
  signed __int64 v295; // r8
  __int64 v296; // rax
  int v297; // edx
  signed __int64 v298; // rdi
  int v299; // ebp
  __int64 v300; // rcx
  char *v301; // r15
  signed __int64 v302; // rax
  char *v303; // rax
  int v304; // ecx
  int v305; // er8
  char *v306; // r11
  int v307; // edx
  int v308; // esi
  int v309; // er8
  __int64 v310; // r9
  int v311; // eax
  char *v312; // r9
  int v313; // er10
  size_t v314; // r8
  int v315; // eax
  int v316; // er10
  int v317; // ecx
  int v318; // eax
  int v319; // esi
  __int64 v320; // r10
  size_t v321; // r8
  char v322; // al
  int v323; // eax
  char *v324; // rdx
  int v325; // eax
  char v326; // cl
  unsigned __int8 *v327; // rcx
  int v328; // er8
  signed __int64 v329; // rdx
  int v330; // er10
  int v331; // eax
  signed int v332; // eax
  int v333; // er11
  __int64 v334; // rdx
  char *v335; // r10
  int v336; // er12
  char *v337; // rbp
  unsigned __int8 *v338; // rax
  int v339; // ecx
  int v340; // esi
  int v341; // er9
  __int64 v342; // r8
  signed __int64 v343; // rsi
  int v344; // eax
  char *v345; // rsi
  int v346; // er9
  signed __int64 v347; // r8
  int v348; // eax
  int v349; // er9
  int v350; // ecx
  __int64 v351; // r8
  int v352; // er9
  char v353; // al
  char *v354; // ST188_8
  int v355; // ST184_4
  unsigned __int8 *v356; // rdi
  int v357; // [rsp+8h] [rbp-750h]
  signed int v358; // [rsp+8h] [rbp-750h]
  int v359; // [rsp+8h] [rbp-750h]
  int v360; // [rsp+8h] [rbp-750h]
  char *v361; // [rsp+10h] [rbp-748h]
  signed int v362; // [rsp+10h] [rbp-748h]
  _QWORD *v363; // [rsp+10h] [rbp-748h]
  struct _FontProp *v364; // [rsp+10h] [rbp-748h]
  double v365; // [rsp+18h] [rbp-740h]
  signed int v366; // [rsp+18h] [rbp-740h]
  __int64 v367; // [rsp+18h] [rbp-740h]
  int v368; // [rsp+18h] [rbp-740h]
  __int64 v369; // [rsp+18h] [rbp-740h]
  double v370; // [rsp+20h] [rbp-738h]
  _DWORD *v371; // [rsp+20h] [rbp-738h]
  int v372; // [rsp+20h] [rbp-738h]
  FontPtr v373; // [rsp+20h] [rbp-738h]
  const __m128i *v374; // [rsp+28h] [rbp-730h]
  int v375; // [rsp+28h] [rbp-730h]
  signed int v376; // [rsp+28h] [rbp-730h]
  _BYTE *v377; // [rsp+28h] [rbp-730h]
  int v378; // [rsp+28h] [rbp-730h]
  double v379; // [rsp+30h] [rbp-728h]
  double v380; // [rsp+30h] [rbp-728h]
  double v381; // [rsp+38h] [rbp-720h]
  double v382; // [rsp+38h] [rbp-720h]
  __int64 v383; // [rsp+38h] [rbp-720h]
  __int64 v384; // [rsp+40h] [rbp-718h]
  double v385; // [rsp+40h] [rbp-718h]
  int v386; // [rsp+40h] [rbp-718h]
  double v387; // [rsp+40h] [rbp-718h]
  double ptr; // [rsp+48h] [rbp-710h]
  int ptra; // [rsp+48h] [rbp-710h]
  _DWORD *ptrb; // [rsp+48h] [rbp-710h]
  double ptrc; // [rsp+48h] [rbp-710h]
  double v392; // [rsp+50h] [rbp-708h]
  signed int v393; // [rsp+50h] [rbp-708h]
  FontPtr v394; // [rsp+50h] [rbp-708h]
  int v395; // [rsp+50h] [rbp-708h]
  __int64 v396; // [rsp+50h] [rbp-708h]
  __int64 v397; // [rsp+50h] [rbp-708h]
  double v398; // [rsp+58h] [rbp-700h]
  _BYTE *v399; // [rsp+58h] [rbp-700h]
  signed int v400; // [rsp+58h] [rbp-700h]
  struct _Font *v401; // [rsp+60h] [rbp-6F8h]
  signed int v402; // [rsp+60h] [rbp-6F8h]
  char **v403; // [rsp+68h] [rbp-6F0h]
  _BYTE *v404; // [rsp+70h] [rbp-6E8h]
  __int64 v405; // [rsp+78h] [rbp-6E0h]
  unsigned int v406; // [rsp+78h] [rbp-6E0h]
  __int64 v407; // [rsp+80h] [rbp-6D8h]
  int v408; // [rsp+80h] [rbp-6D8h]
  __int64 v409; // [rsp+80h] [rbp-6D8h]
  __int64 v410; // [rsp+80h] [rbp-6D8h]
  FontPtr *v411; // [rsp+88h] [rbp-6D0h]
  __int64 v412; // [rsp+90h] [rbp-6C8h]
  int v413; // [rsp+90h] [rbp-6C8h]
  const __m128i *v414; // [rsp+A0h] [rbp-6B8h]
  int v415; // [rsp+A0h] [rbp-6B8h]
  int v416; // [rsp+A0h] [rbp-6B8h]
  double v417; // [rsp+B0h] [rbp-6A8h]
  int v418; // [rsp+B0h] [rbp-6A8h]
  double v419; // [rsp+C8h] [rbp-690h]
  int v420; // [rsp+C8h] [rbp-690h]
  struct _Font *v421; // [rsp+D0h] [rbp-688h]
  int v422; // [rsp+D0h] [rbp-688h]
  int v423; // [rsp+D0h] [rbp-688h]
  char *v424; // [rsp+D0h] [rbp-688h]
  signed int v425; // [rsp+E0h] [rbp-678h]
  signed __int64 v426; // [rsp+E0h] [rbp-678h]
  __int64 v427; // [rsp+E8h] [rbp-670h]
  signed __int64 v428; // [rsp+E8h] [rbp-670h]
  int v429; // [rsp+E8h] [rbp-670h]
  int v430; // [rsp+E8h] [rbp-670h]
  signed int v431; // [rsp+F0h] [rbp-668h]
  FontPtr v432; // [rsp+F0h] [rbp-668h]
  _QWORD *v433; // [rsp+F8h] [rbp-660h]
  int v434; // [rsp+104h] [rbp-654h]
  int v435; // [rsp+108h] [rbp-650h]
  int v436; // [rsp+10Ch] [rbp-64Ch]
  signed __int16 *v437; // [rsp+110h] [rbp-648h]
  __int64 v438; // [rsp+118h] [rbp-640h]
  FontPtr font; // [rsp+120h] [rbp-638h]
  signed __int64 v440; // [rsp+128h] [rbp-630h]
  char *v441; // [rsp+128h] [rbp-630h]
  signed __int64 v442; // [rsp+128h] [rbp-630h]
  size_t n; // [rsp+130h] [rbp-628h]
  size_t na; // [rsp+130h] [rbp-628h]
  signed __int64 v445; // [rsp+138h] [rbp-620h]
  int v446; // [rsp+140h] [rbp-618h]
  _DWORD *v447; // [rsp+148h] [rbp-610h]
  __int64 v448; // [rsp+148h] [rbp-610h]
  __int64 v449; // [rsp+158h] [rbp-600h]
  signed __int16 *v450; // [rsp+160h] [rbp-5F8h]
  signed int v451; // [rsp+170h] [rbp-5E8h]
  double v452; // [rsp+188h] [rbp-5D0h]
  double v453; // [rsp+190h] [rbp-5C8h]
  double v454; // [rsp+198h] [rbp-5C0h]
  double v455; // [rsp+1A0h] [rbp-5B8h]
  double v456; // [rsp+1A8h] [rbp-5B0h]
  double v457; // [rsp+1B0h] [rbp-5A8h]
  double v458; // [rsp+1B8h] [rbp-5A0h]
  double v459; // [rsp+1C0h] [rbp-598h]
  FontPtr pFont; // [rsp+1C8h] [rbp-590h]
  double v461; // [rsp+1D0h] [rbp-588h]
  __int16 v462; // [rsp+1D8h] [rbp-580h]
  __int16 v463; // [rsp+1DAh] [rbp-57Eh]
  double v464; // [rsp+1E0h] [rbp-578h]
  __int16 v465; // [rsp+1E8h] [rbp-570h]
  __int16 v466; // [rsp+1EAh] [rbp-56Eh]
  double v467; // [rsp+1F0h] [rbp-568h]
  double v468; // [rsp+1F8h] [rbp-560h]
  double v469; // [rsp+200h] [rbp-558h]
  double v470; // [rsp+208h] [rbp-550h]
  __m128i v471; // [rsp+210h] [rbp-548h]
  __m128i v472; // [rsp+220h] [rbp-538h]
  __m128i v473; // [rsp+230h] [rbp-528h]
  __m128i v474; // [rsp+240h] [rbp-518h]
  __m128i v475; // [rsp+250h] [rbp-508h]
  __m128i v476; // [rsp+260h] [rbp-4F8h]
  __m128i v477; // [rsp+270h] [rbp-4E8h]
  __int64 v478; // [rsp+280h] [rbp-4D8h]
  double v479; // [rsp+290h] [rbp-4C8h]
  double v480; // [rsp+298h] [rbp-4C0h]
  double v481; // [rsp+2A0h] [rbp-4B8h]
  double v482; // [rsp+2A8h] [rbp-4B0h]
  char dest[1032]; // [rsp+310h] [rbp-448h]
  unsigned __int64 v484; // [rsp+718h] [rbp-40h]

  v8 = a6;
  v9 = *(double *)(a6 + 32);
  v10 = *(double *)(a6 + 24);
  v411 = a2;
  v484 = __readfsqword(0x28u);
  v407 = a4;
  if ( hypot(v10, v9) < 1.0 || hypot(*(double *)(v8 + 8), *(double *)(v8 + 16)) < 1.0 )
    return 83;
  *(double *)&pFont = 1.0;
  v456 = 0.0;
  v457 = 0.0;
  v458 = 0.0;
  v459 = 0.0;
  v11 = *(signed __int16 *)(v407 + 8);
  __memcpy_chk(dest, *(_QWORD *)v407, v11, 1024LL);
  dest[v11] = 0;
  v461 = COERCE_DOUBLE(dest);
  FontParseXLFDName(dest);
  v12 = dest;
  do
  {
    v13 = *(_DWORD *)v12;
    v12 += 4;
    v14 = ~v13 & (v13 - 16843009) & 0x80808080;
  }
  while ( !v14 );
  v15 = *(const char **)(v8 + 96);
  v16 = v14 >> 16;
  v17 = (unsigned __int16)(v14 & 0x8080) == 0;
  if ( !(v14 & 0x8080) )
    LOBYTE(v14) = v16;
  v464 = *(double *)(v8 + 96);
  if ( v17 )
    LOWORD(v12) = (_WORD)v12 + 2;
  v18 = (_WORD)v12 - (__CFADD__((_BYTE)v14, (_BYTE)v14) + 3) - (unsigned __int64)dest;
  v19 = *(_WORD *)(v407 + 10);
  v462 = v18;
  v463 = v19;
  v465 = strlen(v15);
  v466 = FontFileCountDashes(v15, (unsigned int)v465, v20);
  v412 = 0LL;
  v365 = 1.797693134862316e308/*+Inf*/;
  v425 = 20;
  v427 = 0LL;
  v370 = 1.797693134862316e308/*+Inf*/;
  v384 = 0LL;
  v414 = 0LL;
  v374 = 0LL;
  *(double *)&v421 = 0.0;
  *(double *)&v401 = 0.0;
  v417 = 0.0;
  v419 = 0.0;
  v398 = 0.0;
  v392 = 0.0;
  v381 = 0.0;
  ptr = 0.0;
  v431 = -1;
  v357 = 0;
  v405 = v8;
LABEL_10:
  if ( *((_DWORD *)&FontFileBitmapSources + 3) > 0 )
  {
    v21 = 0LL;
    v403 = 0LL;
    while ( 1 )
    {
      v361 = (char *)(8 * v21);
      v22 = *(_QWORD *)(FontFileBitmapSources + 8 * v21);
      if ( !v403 && *(_QWORD *)(v405 + 96) )
      {
        v128 = FontFileFindNameInDir(*(_QWORD *)(v22 + 24) + 48LL, &v464);
        if ( !v128 )
          goto LABEL_136;
        v129 = *(_DWORD *)(v128 + 16);
        if ( v129 != 2 )
        {
          if ( v129 == 3 && v425 > 0 )
          {
            v151 = *(const char **)(v128 + 24);
            --v425;
            v464 = *(double *)&v151;
            v465 = strlen(v151);
            v412 = v22;
            v466 = FontFileCountDashes(v151, (unsigned int)v465, v152);
            goto LABEL_10;
          }
LABEL_136:
          v412 = v22;
          v22 = *(_QWORD *)&v361[FontFileBitmapSources];
          goto LABEL_13;
        }
        v412 = v22;
        v403 = (char **)v128;
        v22 = *(_QWORD *)&v361[FontFileBitmapSources];
      }
LABEL_13:
      if ( a1 == v22 )
      {
        v23 = v407;
      }
      else
      {
        v23 = FontFileFindNameInDir(*(_QWORD *)(v22 + 24) + 24LL, &v461);
        if ( !v23 )
          goto LABEL_37;
      }
      v24 = *(_QWORD *)(v23 + 40);
      if ( *(_DWORD *)(v24 + 120) > 0 )
      {
        v25 = 0LL;
        v26 = 0;
        while ( 1 )
        {
          v30 = v25 + *(_QWORD *)(v24 + 128);
          if ( *(_QWORD *)(v30 + 120) )
          {
            if ( (unsigned int)sub_1CAF0(
                                 v25 + *(_QWORD *)(v24 + 128),
                                 (double *)v405,
                                 &v456,
                                 &v458,
                                 &v457,
                                 &v459,
                                 (double *)&pFont) )
              break;
          }
LABEL_21:
          ++v26;
          v25 += 136LL;
          if ( v26 >= *(_DWORD *)(v24 + 120) )
            goto LABEL_37;
        }
        if ( v458 < 1.0 )
        {
          v31 = (signed int)(20.0 * v458);
        }
        else
        {
          v31 = 160;
          if ( v458 != 1.0 )
          {
            v31 = 40;
            if ( v458 != 2.0 )
              v31 = (signed int)(30.0 / v458);
          }
        }
        if ( v456 < 1.0 )
        {
          v32 = v31 + (signed int)(v456 + v456);
        }
        else
        {
          v32 = v31 + 16;
          if ( v456 != 1.0 )
          {
            v32 = v31 + 4;
            if ( v456 != 2.0 )
              v32 = v31 + (signed int)(3.0 / v456);
          }
        }
        if ( v32 <= v357 )
        {
          if ( v32 == v357 )
          {
            if ( v365 > v458 )
              goto LABEL_33;
            if ( v458 == v365 )
            {
              if ( v370 > v456 )
                goto LABEL_33;
            }
            else
            {
              v357 = v32;
            }
          }
        }
        else
        {
LABEL_33:
          v365 = v458;
          v374 = (const __m128i *)v30;
          v381 = v457;
          v357 = v32;
          v398 = v459;
          v384 = *(_QWORD *)&v361[FontFileBitmapSources];
          v401 = pFont;
          v392 = v458;
          v370 = v456;
          ptr = v456;
        }
        if ( COERCE_DOUBLE(*(_QWORD *)&v456 & xmmword_30160) > 9.999999999999999e-21
          && COERCE_DOUBLE(*(_QWORD *)&v458 & xmmword_30160) > 9.999999999999999e-21 )
        {
          v27 = *(double *)(v405 + 8);
          v28 = *(double *)(v30 + 8);
          v29 = *(double *)(v405 + 8) * *(double *)&pFont;
          if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v29 - v28) & xmmword_30160) < 1.0
            && COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v405 + 16) * *(double *)&pFont - *(double *)(v30 + 16)) & xmmword_30160) < 9.999999999999999e-21
            && COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v405 + 24) - *(double *)(v30 + 24)) & xmmword_30160) < 9.999999999999999e-21 )
          {
            v130 = *(double *)(v405 + 32);
            v131 = *(double *)(v30 + 32);
            if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)(v405 + 32) - v131) & xmmword_30160) < 1.0 )
            {
              v132 = v130 / v131 < 1.0 ? (signed int)(v130 * 80.0 / v131) : (signed int)(80.0 / v130 / v131);
              v133 = v29 / v28 < 1.0 ? 8.0 * v27 * *(double *)&pFont / v28 : 8.0 / v27 * *(double *)&pFont / v28;
              if ( v132 + (signed int)v133 > v431 )
              {
                v414 = (const __m128i *)v30;
                v421 = pFont;
                v431 = v132 + (signed int)v133;
                v427 = *(_QWORD *)&v361[FontFileBitmapSources];
                v419 = v457 / v456;
                v417 = v459 / v458;
              }
            }
          }
        }
        goto LABEL_21;
      }
LABEL_37:
      if ( *((_DWORD *)&FontFileBitmapSources + 3) <= (signed int)++v21 )
      {
        v35 = v405;
        goto LABEL_39;
      }
    }
  }
  v35 = v405;
  v403 = 0LL;
LABEL_39:
  if ( v414 )
  {
    v471 = _mm_loadu_si128(v414);
    v472 = _mm_loadu_si128(v414 + 1);
    v473 = _mm_loadu_si128(v414 + 2);
    v474 = _mm_loadu_si128(v414 + 3);
    v475 = _mm_loadu_si128(v414 + 4);
    v476 = _mm_loadu_si128(v414 + 5);
    v477 = _mm_loadu_si128(v414 + 6);
    v36 = v414[7].m128i_i64[0];
    v453 = v419;
    v478 = v36;
    v455 = v417;
    v452 = 1.0;
    v454 = 1.0;
    pFont = v421;
    v37 = (char **)v414[7].m128i_i64[1];
  }
  else
  {
    if ( !v374 )
    {
      if ( !v403 )
        return 83;
      goto LABEL_45;
    }
    v427 = v384;
    v471 = _mm_loadu_si128(v374);
    v452 = ptr;
    v455 = v398;
    v472 = _mm_loadu_si128(v374 + 1);
    v454 = v392;
    v473 = _mm_loadu_si128(v374 + 2);
    v453 = v381;
    v474 = _mm_loadu_si128(v374 + 3);
    v475 = _mm_loadu_si128(v374 + 4);
    v476 = _mm_loadu_si128(v374 + 5);
    v477 = _mm_loadu_si128(v374 + 6);
    v134 = v374[7].m128i_i64[0];
    pFont = v401;
    v478 = v134;
    v37 = (char **)v374[7].m128i_i64[1];
  }
  if ( v403 )
  {
    if ( !v37 || v452 != 1.0 || 1.0 != v454 )
    {
LABEL_45:
      FontParseXLFDName(*v403);
      if ( (unsigned int)sub_1CAF0(
                           (__int64)&v471,
                           (double *)v471.m128i_i64,
                           &v452,
                           &v454,
                           &v453,
                           &v455,
                           (double *)&pFont) )
        goto LABEL_46;
      return 83;
    }
  }
  else if ( !v37 )
  {
    return 83;
  }
  v403 = v37;
  v412 = v427;
LABEL_46:
  v38 = pFont;
  if ( *(double *)&pFont != 1.0 )
  {
    v135 = *(double *)(v35 + 8);
    *(_DWORD *)v35 &= 0xFFFFFFF3;
    v136 = v135 * *(double *)&v38;
    v137 = *(double *)&v38 * *(double *)(v35 + 16);
    *(double *)(v35 + 8) = v136;
    *(double *)(v35 + 16) = v137;
    FontFileCompleteXLFD(v35, v35);
  }
  v39 = FontFileOpenBitmap(v412, &pFont, 1LL, v403, a7, a8);
  if ( v39 != 85 )
    return 83;
  v382 = v452;
  if ( !*(_DWORD *)(v35 + 88) )
    *(_DWORD *)(v35 + 88) = (signed int)((double)v476.m128i_i32[2] * v452);
  v40 = pFont;
  v379 = v454;
  v385 = v453;
  v371 = pFont->fontPrivate;
  v41 = CreateFontRec();
  v42 = v41;
  if ( !v41 )
  {
    __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate FontRec (%ld)\n", 184LL);
    goto LABEL_152;
  }
  v41->refcnt = 0;
  v41->bit = v40->bit;
  v41->byte = v40->byte;
  v41->glyph = v40->glyph;
  v43 = v40->scan;
  v42->unload_glyphs = 0LL;
  v42->scan = v43;
  v42->get_glyphs = (int (*)(FontPtr, unsigned __int64, unsigned __int8 *, FontEncoding, unsigned __int64 *, CharInfoPtr *))bitmapGetGlyphs;
  v42->get_metrics = (int (*)(FontPtr, unsigned __int64, unsigned __int8 *, FontEncoding, unsigned __int64 *, xCharInfo **))bitmapGetMetrics;
  v42->unload_font = (void (*)(FontPtr))sub_1CE90;
  *(__m128i *)&v42->info.firstCol = _mm_loadu_si128((const __m128i *)&v40->info);
  *(__m128i *)&v42->info.maxbounds.leftSideBearing = _mm_loadu_si128((const __m128i *)&v40->info.maxbounds);
  *(__m128i *)&v42->info.minbounds.characterWidth = _mm_loadu_si128((const __m128i *)&v40->info.minbounds.characterWidth);
  *(__m128i *)&v42->info.ink_maxbounds.descent = _mm_loadu_si128((const __m128i *)&v40->info.ink_maxbounds.descent);
  *(__m128i *)&v42->info.fontAscent = _mm_loadu_si128((const __m128i *)&v40->info.fontAscent);
  v42->info.isStringProp = v40->info.isStringProp;
  if ( *(_DWORD *)(v35 + 104) )
  {
    *((_BYTE *)&v42->info + 10) &= 0xBFu;
    v44 = *(_DWORD *)(v35 + 104);
    if ( v44 <= 0 )
      goto LABEL_485;
    v45 = *(unsigned __int8 **)(v35 + 112);
    v46 = 0;
    v47 = 255;
    v48 = 0;
    v49 = 255;
    v50 = (signed __int64)(v45 + 4);
    v51 = (signed __int64)&v45[4 * (v44 - 1) + 4];
    while ( 1 )
    {
      v52 = *v45;
      v53 = v45[2];
      if ( (_BYTE)v52 != (_BYTE)v53 )
      {
        v47 = v40->info.firstCol;
        v46 = v40->info.lastCol;
      }
      v54 = v45[1];
      v55 = v45[3];
      if ( v47 > v54 )
        v47 = v54;
      if ( v46 < v55 )
        v46 = v55;
      v45 = (unsigned __int8 *)v50;
      if ( v49 > v52 )
        v49 = v52;
      if ( v48 < v53 )
        v48 = v53;
      if ( v51 == v50 )
        break;
      v50 += 4LL;
    }
    if ( v46 < v47 || v48 < v49 )
    {
LABEL_485:
      v143 = (char *)v42;
      goto LABEL_162;
    }
    v56 = v40->info.lastCol;
    if ( v40->info.firstCol >= v47 )
      v47 = v40->info.firstCol;
    if ( v56 > v46 )
      v56 = v46;
    v362 = v47;
    if ( v40->info.firstRow >= v49 )
      v49 = v40->info.firstRow;
    v366 = v49;
    if ( v40->info.lastRow <= v48 )
      v48 = v40->info.lastRow;
    v358 = v48;
  }
  else
  {
    v56 = v40->info.lastCol;
    v362 = v40->info.firstCol;
    v366 = v40->info.firstRow;
    v358 = v40->info.lastRow;
  }
  v57 = malloc(0x40uLL);
  v58 = v57;
  if ( !v57 )
  {
    __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate bitmapFont (%ld)\n", 64LL);
    free(v42);
    goto LABEL_152;
  }
  v42->info.lastCol = v56;
  v42->fontPrivate = v57;
  v42->info.firstCol = v362;
  v42->info.lastRow = v358;
  v42->info.firstRow = v366;
  v375 = v56 - v362 + 1;
  v359 = v375 * (v358 - v366 + 1);
  v59 = *v371;
  *((_DWORD *)v58 + 1) = v359;
  *(_DWORD *)v58 = v59;
  v60 = v371[2];
  *((_QWORD *)v58 + 3) = 0LL;
  *((_QWORD *)v58 + 4) = 0LL;
  *((_QWORD *)v58 + 5) = 0LL;
  *((_QWORD *)v58 + 7) = 0LL;
  *((_DWORD *)v58 + 2) = v60;
  *((_QWORD *)v58 + 6) = 0LL;
  v61 = malloc(24LL * v359);
  *((_QWORD *)v58 + 2) = v61;
  if ( !v61 )
  {
    v153 = (unsigned int)v359;
    v154 = "Error: Couldn't allocate metrics (%d*%ld)\n";
LABEL_181:
    __fprintf_chk(stderr, 1LL, v154, v153);
    goto LABEL_156;
  }
  v62 = v359 + 254;
  if ( v359 + 127 >= 0 )
    v62 = v359 + 127;
  v63 = calloc(v62 >> 7, 8uLL);
  *((_QWORD *)v58 + 5) = v63;
  if ( !v63 )
  {
    v153 = (unsigned int)v359;
    v154 = "Error: Couldn't allocate encoding (%d*%ld)\n";
    goto LABEL_181;
  }
  v64 = *((_BYTE *)&v42->info + 11);
  if ( v379 == v382 )
    v65 = v64 & 0xFB;
  else
    v65 = v64 | 4;
  *((_BYTE *)&v42->info + 11) = v65;
  *((_BYTE *)&v42->info + 11) = v65 | 2;
  if ( !(unsigned int)sub_1CCD0((double *)v35, (__int64)&v467, &v479, &v461, &v464, v382, v379) )
    goto LABEL_156;
  v66 = v464;
  v42->info.fontAscent = (signed int)((double)v40->info.fontAscent * v464);
  v67 = v40->info.fontDescent;
  *(_QWORD *)&v42->info.maxbounds.descent = 9223231297218969600LL;
  *(_QWORD *)&v42->info.minbounds.characterWidth = 9223231297218904063LL;
  v42->info.fontDescent = (signed int)((double)v67 * v66);
  *(_QWORD *)&v42->info.maxbounds.leftSideBearing = -9223231297218904064LL;
  v68 = (_WORD *)*((_QWORD *)v58 + 2);
  if ( v359 <= 0 )
  {
    v284 = *(_QWORD *)&v42->info.minbounds.leftSideBearing;
    *(_QWORD *)&v42->info.ink_maxbounds.leftSideBearing = -9223231297218904064LL;
    v285 = *(_DWORD *)&v42->info.maxbounds.descent;
    *(_QWORD *)&v42->info.ink_minbounds.leftSideBearing = v284;
    LODWORD(v284) = *(_DWORD *)&v42->info.minbounds.descent;
    *(_DWORD *)&v42->info.ink_maxbounds.descent = v285;
    *(_DWORD *)&v42->info.ink_minbounds.descent = v284;
    goto LABEL_402;
  }
  ptra = 0;
  v69 = 0;
  v70 = _mm_loadl_epi64((const __m128i *)&xmmword_30160);
  v71 = v371;
  v72 = v42;
  while ( 1 )
  {
    v107 = v362
         + v69 % v375
         + (v69 / v375 + v366 - v40->info.firstRow) * (v40->info.lastCol - v40->info.firstCol + 1)
         - v40->info.firstCol;
    v108 = v107 + 127;
    if ( v107 >= 0 )
      v108 = v362
           + v69 % v375
           + (v69 / v375 + v366 - v40->info.firstRow) * (v40->info.lastCol - v40->info.firstCol + 1)
           - v40->info.firstCol;
    v109 = *(_QWORD *)(*((_QWORD *)v71 + 5) + 8LL * (v108 >> 7));
    if ( !v109 )
      goto LABEL_111;
    v110 = *(signed __int16 **)(v109 + 8LL * (v107 % 128));
    if ( !v110 )
      goto LABEL_111;
    v111 = *(_DWORD *)(v35 + 104);
    if ( v111 && v111 > 0 )
    {
      v149 = 1LL;
      do
      {
        if ( v362 + v69 % v375 + ((v69 / v375 + v366) << 8) >= *(unsigned __int8 *)(*(_QWORD *)(v35 + 112) + 4 * v149 - 3)
                                                             + (*(unsigned __int8 *)(*(_QWORD *)(v35 + 112)
                                                                                   + 4 * v149
                                                                                   - 4) << 8)
          && v362 + v69 % v375 + ((v69 / v375 + v366) << 8) <= *(unsigned __int8 *)(*(_QWORD *)(v35 + 112) + 4 * v149 - 1)
                                                             + (*(unsigned __int8 *)(*(_QWORD *)(v35 + 112)
                                                                                   + 4 * v149
                                                                                   - 2) << 8) )
        {
          goto LABEL_117;
        }
        v150 = v149++;
      }
      while ( (unsigned int)(v111 - 1) + 2LL != v149 );
      if ( v111 == v150 )
        goto LABEL_111;
    }
LABEL_117:
    if ( *(_QWORD *)v110 & 0xFFFF0000FFFFFFFFLL )
      break;
    if ( v110[4] || v110[2] )
      break;
LABEL_111:
    if ( v359 == ++v69 )
    {
      v42 = v72;
      v39 = 85;
      v155 = v69;
      v156 = 0;
      v157 = 0LL;
      v158 = 0;
      do
      {
        v159 = *(_QWORD *)(*((_QWORD *)v58 + 5) + 8LL * (v158 >> 7));
        if ( v159 )
        {
          v160 = *(INT16 **)(v159 + 8LL * (v158 & 0x7F));
          if ( v160 )
          {
            v161 = v362
                 + v158 % v375
                 + (v40->info.lastCol - v40->info.firstCol + 1) * (v366 + v158 / v375 - v40->info.firstRow)
                 - v40->info.firstCol;
            v162 = v161 + 127;
            if ( v161 >= 0 )
              v162 = v362
                   + v158 % v375
                   + (v40->info.lastCol - v40->info.firstCol + 1) * (v366 + v158 / v375 - v40->info.firstRow)
                   - v40->info.firstCol;
            v163 = *(_QWORD *)(*((_QWORD *)v371 + 5) + 8LL * (v162 >> 7));
            if ( v163 && *(_QWORD *)(v163 + 8LL * (v161 % 128)) )
            {
              ++v156;
              v157 += (signed int)abs(v160[5]);
              v164 = *v160;
              if ( v42->info.minbounds.leftSideBearing > *v160 )
              {
                v42->info.minbounds.leftSideBearing = v164;
                v164 = *v160;
              }
              if ( v42->info.maxbounds.leftSideBearing < v164 )
                v42->info.maxbounds.leftSideBearing = v164;
              v165 = v160[1];
              if ( v42->info.minbounds.rightSideBearing > v165 )
              {
                v42->info.minbounds.rightSideBearing = v165;
                v165 = v160[1];
              }
              if ( v42->info.maxbounds.rightSideBearing < v165 )
                v42->info.maxbounds.rightSideBearing = v165;
              v166 = v160[3];
              if ( v42->info.minbounds.ascent > v166 )
              {
                v42->info.minbounds.ascent = v166;
                v166 = v160[3];
              }
              if ( v42->info.maxbounds.ascent < v166 )
                v42->info.maxbounds.ascent = v166;
              v167 = v160[4];
              if ( v42->info.minbounds.descent > v167 )
              {
                v42->info.minbounds.descent = v167;
                v167 = v160[4];
              }
              if ( v42->info.maxbounds.descent < v167 )
                v42->info.maxbounds.descent = v167;
              v168 = v160[2];
              if ( v42->info.minbounds.characterWidth > v168 )
              {
                v42->info.minbounds.characterWidth = v168;
                v168 = v160[2];
              }
              if ( v42->info.maxbounds.characterWidth < v168 )
                v42->info.maxbounds.characterWidth = v168;
              v169 = v160[5];
              if ( (signed __int16)v42->info.minbounds.attributes > v169 )
              {
                v42->info.minbounds.attributes = v169;
                v169 = v160[5];
              }
              if ( (signed __int16)v42->info.maxbounds.attributes < v169 )
                v42->info.maxbounds.attributes = v169;
            }
          }
        }
        ++v158;
      }
      while ( v155 != v158 );
      *(_QWORD *)&v42->info.ink_minbounds.leftSideBearing = *(_QWORD *)&v42->info.minbounds.leftSideBearing;
      *(_DWORD *)&v42->info.ink_minbounds.descent = *(_DWORD *)&v42->info.minbounds.descent;
      *(_QWORD *)&v42->info.ink_maxbounds.leftSideBearing = *(_QWORD *)&v42->info.maxbounds.leftSideBearing;
      *(_DWORD *)&v42->info.ink_maxbounds.descent = *(_DWORD *)&v42->info.maxbounds.descent;
      if ( v156 )
      {
        v170 = ((v156 >> 1) + 10 * v157) / v156;
        if ( ptra < 0 )
          v170 = -(((v156 >> 1) + 10 * v157) / v156);
        v426 = v170;
        if ( v42->info.minbounds.characterWidth == v42->info.maxbounds.characterWidth )
        {
          *(_DWORD *)(v35 + 88) = 10 * v42->info.minbounds.characterWidth;
        }
        else
        {
          v171 = (double)(signed int)v170 * *(double *)(v35 + 8) / 1000.0;
          if ( v171 < 0.0 )
            v172 = v171 - 0.5;
          else
            v172 = v171 + 0.5;
          *(_DWORD *)(v35 + 88) = (signed int)v172;
        }
LABEL_222:
        FontComputeInfoAccelerators(&v42->info);
        LOWORD(v173) = v42->info.defaultCh;
        if ( (_WORD)v173 != -1 )
        {
          v174 = v42->info.firstRow;
          v175 = (unsigned __int16)v173 >> 8;
          if ( (unsigned __int16)((unsigned __int16)v173 >> 8) >= (unsigned __int16)v174 && v175 <= v42->info.lastRow )
          {
            v176 = v42->info.firstCol;
            v173 = (unsigned __int8)v173;
            if ( (unsigned __int8)v173 >= (unsigned __int16)v176 )
            {
              v177 = v42->info.lastCol;
              if ( (unsigned __int16)v173 <= (unsigned __int16)v177 )
              {
                v178 = v173 - v176 + (v175 - v174) * (v177 - v176 + 1);
                v179 = *(_QWORD *)(*((_QWORD *)v58 + 5) + 8LL * (v178 >> 7));
                if ( v179 )
                  v180 = *(_QWORD *)(v179 + 8LL * (v178 & 0x7F));
                else
                  v180 = 0LL;
                *((_QWORD *)v58 + 6) = v180;
              }
            }
          }
        }
        v181 = v42->fontPrivate;
        v452 = v461;
        v432 = pFont;
        v182 = pFont->fontPrivate;
        v454 = v464;
        v363 = v181;
        v433 = v182;
        if ( !(unsigned int)sub_1CCD0((double *)v35, (__int64)&v467, &v479, &v461, &v464, v382, v379) )
        {
          free(v42);
          if ( v181 )
          {
            free(*((void **)v181 + 2));
            free(*((void **)v181 + 3));
            free(*((void **)v181 + 4));
            v143 = (char *)*((_QWORD *)v181 + 5);
            goto LABEL_162;
          }
          goto LABEL_152;
        }
        v183 = v42->info.firstRow;
        v435 = v183;
        v434 = v42->info.firstCol;
        v184 = v42->info.lastRow - v183;
        v185 = v42->glyph;
        v186 = (v42->info.lastCol - v434 + 1) * (v184 + 1);
        v436 = v42->info.lastCol - v434 + 1;
        v420 = v42->glyph;
        if ( v186 > 0 )
        {
          v187 = 0;
          v188 = 0;
          do
          {
            v189 = *(_QWORD *)(*((_QWORD *)v181 + 5) + 8LL * (v188 >> 7));
            if ( v189 )
            {
              v190 = *(signed __int16 **)(v189 + 8LL * (v188 & 0x7F));
              if ( v190 )
              {
                v191 = v190[3] + v190[4];
                switch ( v185 )
                {
                  case 1:
                    v187 += ((v190[1] - *v190 + 7) >> 3) * v191;
                    break;
                  case 2:
                    v187 += (((v190[1] - *v190 + 15) >> 3) & 0xFFFFFFFE) * v191;
                    break;
                  case 4:
                    v187 += (((v190[1] - *v190 + 31) >> 3) & 0xFFFFFFFC) * v191;
                    break;
                  case 8:
                    v187 += (((v190[1] - *v190 + 63) >> 3) & 0xFFFFFFF8) * v191;
                    break;
                }
              }
            }
            ++v188;
          }
          while ( v186 != v188 );
          v367 = *((_QWORD *)v181 + 5);
          v399 = calloc(1uLL, v187);
          *((_QWORD *)v181 + 4) = v399;
          if ( v399 )
          {
            v192 = v367;
            v360 = 0;
            font = v42;
            v418 = v188;
            v451 = v39;
            v449 = v35;
            while ( 1 )
            {
              v193 = *(_QWORD *)(v192 + 8LL * (v360 >> 7));
              if ( v193 )
              {
                v194 = *(signed __int16 **)(v193 + 8LL * (v360 & 0x7F));
                if ( v194 )
                {
                  v195 = v434
                       + v360 % v436
                       + (v432->info.lastCol - v432->info.firstCol + 1) * (v435 + v360 / v436 - v432->info.firstRow)
                       - v432->info.firstCol;
                  v196 = v195 + 127;
                  if ( v195 >= 0 )
                    v196 = v434
                         + v360 % v436
                         + (v432->info.lastCol - v432->info.firstCol + 1) * (v435 + v360 / v436 - v432->info.firstRow)
                         - v432->info.firstCol;
                  v197 = *(_QWORD *)(v433[5] + 8LL * (v196 >> 7));
                  if ( v197 )
                  {
                    v198 = v195 % 128;
                    v199 = *(signed __int16 **)(v197 + 8 * v198);
                    v437 = *(signed __int16 **)(v197 + 8 * v198);
                    if ( v199 )
                      break;
                  }
                }
              }
LABEL_296:
              if ( v418 == ++v360 )
              {
                v42 = font;
                v39 = v451;
                v35 = v449;
                goto LABEL_302;
              }
              v192 = v363[5];
            }
            v200 = v194[3];
            v201 = v194[1];
            *((_QWORD *)v194 + 2) = v399;
            v202 = &unk_23BCE0;
            v413 = v200;
            if ( font->bit )
              v202 = &unk_23BCD8;
            v404 = v202;
            v386 = v200 + v194[4];
            v372 = v201 - *v194;
            if ( !v372
              || !(v200 + v194[4])
              || (v203 = v199[3], v204 = v199[4], v205 = v199[1] - *v199, v368 = v203 + v204, !v205)
              || !(v203 + v204) )
            {
LABEL_291:
              switch ( v420 )
              {
                case 1:
                  v399 += v386 * ((v194[1] - *v194 + 7) >> 3);
                  break;
                case 2:
                  v399 += (signed int)(v386 * (((v194[1] - *v194 + 15) >> 3) & 0xFFFFFFFE));
                  break;
                case 4:
                  v399 += (signed int)(v386 * (((v194[1] - *v194 + 31) >> 3) & 0xFFFFFFFC));
                  break;
                case 8:
                  v399 += (signed int)(v386 * (((v194[1] - *v194 + 63) >> 3) & 0xFFFFFFF8));
                  break;
              }
              goto LABEL_296;
            }
            v206 = font->glyph;
            switch ( v206 )
            {
              case 1:
                v402 = (v205 + 7) >> 3;
                v406 = (v372 + 7) >> 3;
                break;
              case 2:
                v402 = ((v205 + 15) >> 3) & 0xFFFFFFFE;
                v406 = ((v372 + 15) >> 3) & 0xFFFFFFFE;
                break;
              case 4:
                v402 = ((v205 + 31) >> 3) & 0xFFFFFFFC;
                v406 = ((v372 + 31) >> 3) & 0xFFFFFFFC;
                break;
              default:
                v402 = 0;
                v406 = 0;
                if ( v206 == 8 )
                {
                  v402 = ((v205 + 63) >> 3) & 0xFFFFFFF8;
                  v406 = ((v372 + 63) >> 3) & 0xFFFFFFF8;
                }
                break;
            }
            v438 = *((_QWORD *)v437 + 2);
            if ( v382 <= 0.0 || v379 <= 0.0 || v382 >= 1.0 && v379 >= 1.0 )
              goto LABEL_486;
            v286 = 1.0 / v382;
            v287.m128d_f64[0] = 1.0 / v382;
            if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(1.0 / v382) & xmmword_30160) < 4.503599627370496e15 )
            {
              v288.m128d_f64[0] = (double)(signed int)v286;
              *(_QWORD *)&v287.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                                COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v287, v288) & 0x3FF0000000000000LL)
                                              + v288.m128d_f64[0]) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v286;
            }
            v289.m128d_f64[0] = 1.0 / v379;
            if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(1.0 / v379) & xmmword_30160) < 4.503599627370496e15 )
            {
              v290.m128d_f64[0] = (double)(signed int)v289.m128d_f64[0];
              *(_QWORD *)&v289.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                                COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v289, v290) & 0x3FF0000000000000LL)
                                              + v290.m128d_f64[0]) | ~(_QWORD)xmmword_30160 & *(_QWORD *)&v289.m128d_f64[0];
            }
            v291 = v205 / 2;
            v378 = v368 / 2;
            if ( (double)(v205 / 2) > v287.m128d_f64[0] )
              v291 = (signed int)v287.m128d_f64[0];
            if ( (double)(v368 / 2) > v289.m128d_f64[0] )
              v378 = (signed int)v289.m128d_f64[0];
            v446 = 192 * v291 * v378;
            if ( v291 <= 1 && v378 <= 1 )
            {
LABEL_486:
              v207 = 0LL;
              v208 = 0LL;
              ptrb = 0LL;
              v209 = 0LL;
            }
            else
            {
              v423 = v205 + 1;
              v395 = (v205 + 1) * (v368 + 1);
              v209 = (unsigned __int8 *)malloc(v395);
              if ( v209 )
              {
                ptrb = calloc(2 * v372 + 4, 4uLL);
                v207 = (_DWORD *)(4LL * v372 + 12);
                if ( ptrb )
                {
                  v207 = (_DWORD *)((char *)v207 + (_QWORD)ptrb);
                  v208 = ptrb + 1;
                  if ( v368 > 0 )
                  {
                    v292 = v438;
                    v293 = (char *)v209;
                    v294 = 0;
                    v295 = (unsigned int)(v205 - 1) + 1LL;
                    do
                    {
                      v296 = 0LL;
                      if ( v205 > 0 )
                      {
                        do
                        {
                          v293[v296] = -((*(_BYTE *)(v292 + ((signed int)v296 >> 3)) & v404[v296 & 7]) != 0);
                          ++v296;
                        }
                        while ( v295 != v296 );
                        v293 += v295;
                      }
                      v292 += v402;
                      ++v293;
                      ++v294;
                    }
                    while ( v368 != v294 );
                    v429 = v294;
                    if ( v291 > 1 )
                    {
                      v333 = v291 >> 1;
                      v450 = v194;
                      v416 = 0;
                      v334 = v395 - v423;
                      v335 = (char *)&v209[v291 >> 1];
                      v397 = v291 >> 1;
                      v336 = v291 - (v291 >> 1) - 1;
                      v448 = (unsigned int)(v291 - (v291 >> 1) - 2);
                      v410 = 1 - (v291 - (v291 >> 1));
                      v337 = (char *)&v209[v334];
                      v442 = 1 - v397;
                      do
                      {
                        v338 = (unsigned __int8 *)&v335[-v397];
                        v339 = 0;
                        do
                        {
                          v340 = *v338++;
                          v339 += v340;
                        }
                        while ( &v335[v442 + (unsigned int)((v291 >> 1) - 1)] != (char *)v338 );
                        if ( v336 <= 0 )
                        {
                          v348 = v333;
                          v345 = v337;
                          v347 = (signed __int64)&v335[-v397];
                          v346 = 0;
                        }
                        else
                        {
                          v341 = v333 + 1;
                          v342 = 0LL;
                          v343 = v448 + 1;
                          do
                          {
                            v339 += (unsigned __int8)v335[v342];
                            v344 = v339 / v341++;
                            v337[v342++] = v344;
                          }
                          while ( v343 != v342 );
                          v345 = &v337[v343];
                          v346 = v291 - (v291 >> 1) - 1;
                          v347 = (signed __int64)&v335[v448 + v442];
                          v348 = v336 + v333;
                        }
                        if ( v205 > v348 )
                        {
                          v349 = v333 + v346;
                          do
                          {
                            ++v345;
                            ++v349;
                            v350 = *(unsigned __int8 *)(++v347 + v397 - 1) + v339;
                            *(v345 - 1) = v350 / v291;
                            v339 = v350 - *(unsigned __int8 *)(v347 + v410 - 1);
                          }
                          while ( v205 > v349 );
                        }
                        v351 = v410 + v347;
                        v352 = v291 - 1;
                        do
                        {
                          ++v345;
                          ++v351;
                          v353 = v339 / v352--;
                          *(v345 - 1) = v353;
                          v339 -= *(unsigned __int8 *)(v351 - 1);
                        }
                        while ( v336 != v352 );
                        v354 = v335;
                        v355 = v333;
                        memmove(&v335[-v397], v337, v205);
                        ++v416;
                        v335 = &v354[v423];
                        v333 = v355;
                      }
                      while ( v429 != v416 );
                      v194 = v450;
                      v208 = ptrb + 1;
                      if ( v378 <= 1 )
                      {
LABEL_445:
                        v327 = v209;
                        v328 = 0;
                        do
                        {
                          v329 = (signed __int64)&v327[v205 - 1 + 1];
                          if ( v205 > 0 )
                          {
                            do
                            {
                              v330 = v446 * *v327;
                              v331 = v330 + 255;
                              if ( v330 >= 0 )
                                v331 = v446 * *v327;
                              v332 = v331 >> 8;
                              if ( v332 > 255 )
                                LOBYTE(v332) = -1;
                              *(++v327 - 1) = v332;
                            }
                            while ( v327 != (unsigned __int8 *)v329 );
                          }
                          ++v327;
                          ++v328;
                        }
                        while ( v368 > v328 );
                        goto LABEL_266;
                      }
                    }
LABEL_425:
                    v297 = v378 - (v378 >> 1);
                    v415 = v378 >> 1;
                    if ( v205 > 0 )
                    {
                      v298 = v205 + 1LL;
                      v447 = v208;
                      v299 = v297 - 1;
                      v424 = (char *)&v209[v205];
                      v300 = (v205 + 1) * v415;
                      v301 = (char *)&v209[v300];
                      v396 = (v205 + 1) * v415;
                      v409 = (v205 + 1) * (1 - v297);
                      v445 = (signed __int64)&v209[v300 + 1 + (unsigned int)(v205 - 1)];
                      v430 = v415 + v297;
                      v302 = v298 * ((unsigned int)(v297 - 2) + 1LL);
                      na = v302 - v300;
                      v441 = &v424[v302];
                      do
                      {
                        v303 = &v301[-v396];
                        v304 = 0;
                        v305 = 0;
                        v306 = &v301[-v396];
                        while ( 1 )
                        {
                          v307 = (unsigned __int8)*v303;
                          v308 = v305 + 1;
                          v303 += v205 + 1;
                          v304 += v307;
                          if ( v415 == v305 + 1 )
                            break;
                          ++v305;
                        }
                        if ( v299 <= 0 )
                        {
                          v315 = v378 >> 1;
                          v312 = (char *)&v209[v205];
                          v314 = (size_t)&v301[-v396];
                          v313 = 0;
                        }
                        else
                        {
                          v309 = v305 + 2;
                          v310 = 0LL;
                          do
                          {
                            v304 += (unsigned __int8)v301[v310];
                            v311 = v304 / v309++;
                            v424[v310] = v311;
                            v310 += v298;
                          }
                          while ( v430 != v309 );
                          v312 = v441;
                          v313 = v299;
                          v314 = (size_t)&v301[na];
                          v315 = v308 + v299;
                        }
                        if ( v368 > v315 )
                        {
                          v316 = v308 + v313;
                          do
                          {
                            ++v316;
                            v317 = *(unsigned __int8 *)(v314 + v396) + v304;
                            *v312 = v317 / v378;
                            v312 += v298;
                            v318 = *(unsigned __int8 *)(v314 + v409);
                            v314 += v298;
                            v304 = v317 - v318;
                          }
                          while ( v368 > v316 );
                        }
                        v319 = v299 + v308;
                        v320 = 0LL;
                        v321 = v409 + v314;
                        do
                        {
                          v322 = v304 / v319--;
                          v312[v320] = v322;
                          v323 = *(unsigned __int8 *)(v321 + v320);
                          v320 += v298;
                          v304 -= v323;
                        }
                        while ( v299 != v319 );
                        if ( v368 > 0 )
                        {
                          v324 = (char *)&v209[v205];
                          v325 = 0;
                          do
                          {
                            v326 = *v324;
                            ++v325;
                            v324 += v298;
                            *v306 = v326;
                            v306 += v298;
                          }
                          while ( v368 != v325 );
                        }
                        ++v301;
                      }
                      while ( (char *)v445 != v301 );
                      v208 = v447;
                    }
                    if ( v368 <= 0 )
                      goto LABEL_266;
                    goto LABEL_445;
                  }
                  if ( v291 <= 1 || v378 > 1 )
                    goto LABEL_425;
                }
                else
                {
                  v208 = (_DWORD *)&byte_4;
                  __fprintf_chk(
                    stderr,
                    1LL,
                    "Warning: Couldn't allocate diffusion workspace (%ld)\n",
                    4LL * (2 * v372 + 4));
                  v356 = v209;
                  v209 = 0LL;
                  free(v356);
                  v413 = v194[3];
                }
              }
              else
              {
                v207 = 0LL;
                v208 = 0LL;
                __fprintf_chk(stderr, 1LL, "Warning: Couldn't allocate character grayscale (%d)\n", (unsigned int)v395);
                ptrb = 0LL;
                v413 = v194[3];
              }
            }
LABEL_266:
            v210 = v481;
            v211 = v479;
            v212 = v482;
            v213 = v480;
            v376 = (signed int)((0.0 * v481 + v479) * 65536.0);
            v393 = (signed int)(COERCE_DOUBLE(COERCE_UNSIGNED_INT64(0.0 * v482 + v480) ^ xmmword_30670) * 65536.0);
            if ( v386 > 0 )
            {
              v408 = 0;
              v422 = 0;
              v214 = 4LL * v372;
              v428 = v372;
              n = v214 - 4;
              v215 = v413;
              v440 = v214 - 8;
              while ( 1 )
              {
                v216 = (double)*v194 + 0.5;
                v217 = (double)(v215 - v422) - 0.5;
                v218 = (signed int)((v210 * v217 + v211 * v216 - (double)*v437) * 65536.0);
                v219 = (signed int)(((double)v437[3] - (v217 * v212 + v216 * v213)) * 65536.0);
                if ( !v209 )
                {
                  v275 = 0;
                  if ( v372 > 0 )
                  {
                    do
                    {
                      if ( v218 >> 16 >= 0 && v205 > v218 >> 16 )
                      {
                        v276 = v219 >> 16;
                        if ( v219 >> 16 >= 0
                          && v368 > v276
                          && (unsigned __int8)v404[BYTE2(v218) & 7] & *(char *)(v438 + v402 * v276 + (v218 >> 19)) )
                        {
                          v399[v408 + (v275 >> 3)] |= v404[v275 & 7];
                        }
                      }
                      v218 += v376;
                      v219 += v393;
                      ++v275;
                    }
                    while ( v372 != v275 );
                    v215 = v194[3];
                  }
                  goto LABEL_287;
                }
                if ( v372 <= 0 )
                  goto LABEL_286;
                v220 = v207;
                v221 = 0LL;
                do
                {
                  v226 = v218 >> 16;
                  if ( v218 >> 16 < 0 || v205 <= v226 || (v227 = v219 >> 16, v219 >> 16 < 0) || v368 <= v227 )
                    v228 = 0;
                  else
                    v228 = v209[(v205 + 1) * v227 + v226];
                  v229 = v208[v221];
                  v230 = v229 + 15;
                  if ( v229 >= 0 )
                    v230 = v208[v221];
                  v231 = v228 + (v230 >> 4);
                  if ( v231 > 255 )
                  {
                    v225 = 0;
                    v224 = 0;
                    v223 = 0;
                    v222 = 0;
LABEL_284:
                    v399[v408 + ((signed int)v221 >> 3)] |= v404[v221 & 7];
                    goto LABEL_274;
                  }
                  if ( v231 >= 0 )
                  {
                    if ( v231 <= 127 )
                    {
                      v222 = -v231;
                      v223 = -7 * v231;
                      v224 = -3 * v231;
                      v225 = -5 * v231;
                      goto LABEL_274;
                    }
                    v222 = v231 - 255;
                    v224 = 3 * (v231 - 255);
                    v225 = 5 * (v231 - 255);
                    v223 = 7 * (v231 - 255);
                    goto LABEL_284;
                  }
                  v225 = 0;
                  v224 = 0;
                  v223 = 0;
                  v222 = 0;
LABEL_274:
                  v208[v221 + 1] += v223;
                  v218 += v376;
                  ++v221;
                  *(v220 - 1) += v224;
                  v220[1] = v222;
                  *v220 += v225;
                  v219 += v393;
                  ++v220;
                }
                while ( (unsigned int)(v372 - 1) + 1LL != v221 );
                v215 = v194[3];
LABEL_286:
                *v207 += *(v207 - 1);
                *(_DWORD *)((char *)v207 + v440) += v208[v428];
                *(_DWORD *)((char *)v207 + n) += v207[v428];
                v207[v428] = 0;
                v232 = v208;
                *v208 = 0;
                *(v208 - 1) = 0;
                v208 = v207;
                v207 = v232;
LABEL_287:
                ++v422;
                v408 += v406;
                if ( v386 == v422 )
                {
                  v413 = v215;
                  break;
                }
              }
            }
            v386 = v413 + v194[4];
            if ( v209 )
            {
              free(v209);
              free(ptrb);
            }
            goto LABEL_291;
          }
LABEL_394:
          __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate bitmaps (%d)\n", v187);
          free(v42);
          free(*((void **)v181 + 2));
          free(*((void **)v181 + 3));
          free(*((void **)v181 + 4));
          v143 = (char *)*((_QWORD *)v181 + 5);
          if ( v143 )
          {
            v278 = v186 + 254;
            v279 = v186 + 127;
            if ( v279 >= 0 )
              v278 = v279;
            v280 = v278 >> 7;
            if ( v280 > 0 )
            {
              v281 = 0LL;
              v282 = 8LL * (unsigned int)(v280 - 1) + 8;
              do
              {
                v283 = *(void **)&v143[v281];
                v281 += 8LL;
                free(v283);
                v143 = (char *)v363[5];
              }
              while ( v282 != v281 );
            }
          }
          goto LABEL_162;
        }
        v277 = calloc(1uLL, 0LL);
        *((_QWORD *)v181 + 4) = v277;
        if ( !v277 )
        {
          v187 = 0;
          goto LABEL_394;
        }
LABEL_302:
        __strcpy_chk(dest, *v403, 1024LL);
        FontParseXLFDName(dest);
        v380 = v455;
        v373 = pFont;
        ptrc = v452;
        *(double *)&v383 = v453;
        v387 = v454;
        if ( qword_23CCC8 != serverGeneration )
        {
          v233 = &off_23C1A0;
          do
          {
            v234 = *v233;
            v233 += 3;
            v235 = strlen(v234);
            *(v233 - 2) = (char *)MakeAtom(v234, v235, 1);
          }
          while ( v233 != &off_23C1A0 + 60 );
          v236 = &off_23BF00;
          do
          {
            v237 = (char *)*v236;
            v236 += 3;
            v238 = strlen(v237);
            *(v236 - 2) = (void *)MakeAtom(v237, v238, 1);
          }
          while ( v236 != &off_23BF00 + 84 );
          v239 = &off_23BD00;
          do
          {
            v240 = *v239;
            v239 += 3;
            v241 = strlen(v240);
            *(v239 - 2) = (char *)MakeAtom(v240, v241, 1);
          }
          while ( v239 != &off_23BD00 + 63 );
          qword_23CCC8 = serverGeneration;
        }
        v364 = (struct _FontProp *)malloc(0x460uLL);
        if ( v364 )
        {
          v377 = malloc(0x46uLL);
          if ( v377 )
          {
            v394 = v42;
            v400 = v39;
            v242 = v377;
            v369 = v35;
            v243 = 0LL;
            v244 = &off_23C1A0;
            v245 = v364;
            v246 = dest;
            while ( 2 )
            {
              if ( *v246 )
              {
                v243 = v246 + 1;
                v246 = strchr(v246 + 1, 45);
                if ( !v246 )
                  v246 = &v243[strlen(v243)];
              }
              *v242 = 0;
              switch ( (unsigned __int64)*((unsigned int *)v244 + 4) )
              {
                case 0uLL:
                  v268 = (_DWORD)v246 - (_DWORD)v243;
                  goto LABEL_355;
                case 1uLL:
                  if ( !*v243 )
                    goto LABEL_361;
                  if ( *v243 == 91 )
                  {
                    v268 = 0;
                  }
                  else
                  {
                    v270 = v243;
                    do
                    {
                      if ( !*++v270 )
                      {
LABEL_361:
                        v268 = (_DWORD)v246 - (_DWORD)v243;
                        goto LABEL_355;
                      }
                    }
                    while ( *v270 != 91 );
                    v268 = (_DWORD)v270 - (_DWORD)v243;
                  }
LABEL_355:
                  v269 = MakeAtom(v243, v268, 1);
                  *v242 = 1;
                  v245->value = v269;
LABEL_319:
                  v248 = v244[1];
                  ++v245;
                  v244 += 3;
                  ++v242;
                  v245[-1].name = (__int64)v248;
                  if ( v244 != &off_23C1A0 + 60 )
                    continue;
                  v249 = 20;
                  v33 = v400;
                  v250 = v364 + 20;
                  v251 = (signed __int64)(v377 + 20);
                  v252 = v373->info.nprops;
                  if ( !v252 )
                    goto LABEL_333;
                  v253 = 0.0;
                  v254 = 0;
                  v255 = v373->info.isStringProp;
                  v256 = &v373->info.props->name;
                  v257 = (signed __int64)&v255[v252 - 1 + 1];
                  break;
                case 2uLL:
                  v267 = *(double *)(v369 + 32);
                  if ( v267 < 0.0 )
                    goto LABEL_353;
                  goto LABEL_351;
                case 3uLL:
                  v267 = 10.0 * *(double *)(v369 + 64);
                  if ( v267 < 0.0 )
LABEL_353:
                    v247 = (unsigned int)(signed int)(v267 - 0.5);
                  else
LABEL_351:
                    v247 = (unsigned int)(signed int)(v267 + 0.5);
                  goto LABEL_318;
                case 4uLL:
                  v245->value = *(signed int *)(v369 + 80);
                  goto LABEL_319;
                case 5uLL:
                  v245->value = *(signed int *)(v369 + 84);
                  goto LABEL_319;
                case 6uLL:
                  v245->value = *(signed int *)(v369 + 88);
                  goto LABEL_319;
                case 0xAuLL:
                  v263 = dest;
                  do
                  {
                    v264 = *(_DWORD *)v263;
                    v263 += 4;
                    v265 = ~v264 & (v264 - 16843009) & 0x80808080;
                  }
                  while ( !v265 );
                  if ( !((unsigned __int16)~(_WORD)v264 & (unsigned __int16)(v264 - 257) & 0x8080) )
                    LOBYTE(v265) = (~v264 & (v264 - 16843009) & 0x80808080) >> 16;
                  if ( !((unsigned __int16)~(_WORD)v264 & (unsigned __int16)(v264 - 257) & 0x8080) )
                    LODWORD(v263) = (_DWORD)v263 + 2;
                  v266 = MakeAtom(
                           dest,
                           (_DWORD)v263 - (__CFADD__((_BYTE)v265, (_BYTE)v265) + 3) - (unsigned int)dest,
                           1);
                  *v242 = 1;
                  v245->value = v266;
                  goto LABEL_319;
                case 0xBuLL:
                  v245->value = (unsigned int)(signed int)((double)v373->info.fontAscent * v380);
                  goto LABEL_319;
                case 0xCuLL:
                  v245->value = (unsigned int)(signed int)((double)v373->info.fontDescent * v380);
                  goto LABEL_319;
                case 0xDuLL:
                  v245->value = 1000LL;
                  goto LABEL_319;
                case 0xEuLL:
                  v245->value = (unsigned int)(signed int)(72270.0 / (double)*(signed int *)(v369 + 84) + 0.5);
                  goto LABEL_319;
                case 0xFuLL:
                  v247 = v426;
LABEL_318:
                  v245->value = v247;
                  goto LABEL_319;
                default:
                  goto LABEL_319;
              }
              break;
            }
            while ( 1 )
            {
              v258 = (void *)*v256;
              v259 = &off_23BF00;
              while ( v259[1] != v258 )
              {
                v259 += 3;
                if ( v259 == &off_23BF00 + 84 )
                  goto LABEL_331;
              }
              v260 = *((_DWORD *)v259 + 4);
              if ( v260 == 8 )
                break;
              if ( v260 != 9 )
              {
                if ( v260 == 7 )
                {
                  v271 = (double)(signed int)v256[1] * ptrc;
                  if ( v271 < 0.0 )
                    v272 = v271 - 0.5;
                  else
                    v272 = v271 + 0.5;
                  v250->value = (unsigned int)(signed int)v272;
                  v253 = *(double *)&v383;
                  v258 = (void *)*v256;
                }
                goto LABEL_328;
              }
              ++v250;
              ++v254;
              ++v251;
              v250[-1].value = v256[1];
              v250[-1].name = *v256;
              *(_BYTE *)(v251 - 1) = *v255;
LABEL_331:
              ++v255;
              v256 += 2;
              if ( v255 == (char *)v257 )
              {
                v249 = v254 + 20;
LABEL_333:
                if ( !pFont->refcnt )
                  j_FontFileCloseFont(0LL, pFont);
                v394->info.nprops = v249;
                v394->info.props = v364;
                v394->info.isStringProp = v377;
                *v411 = v394;
                return v33;
              }
            }
            v273 = (double)(signed int)v256[1] * v387;
            if ( v273 < 0.0 )
              v274 = v273 - 0.5;
            else
              v274 = v273 + 0.5;
            v250->value = (unsigned int)(signed int)v274;
            v253 = v380;
            v258 = (void *)*v256;
LABEL_328:
            v250->name = (__int64)v258;
            v261 = (double)(signed int)v256[1] * v253;
            if ( v261 < 0.0 )
              v262 = v261 - 0.5;
            else
              v262 = v261 + 0.5;
            v250[1].value = (unsigned int)(signed int)v262;
            v254 += 2;
            v250 += 2;
            v251 += 2LL;
            v250[-1].name = *(__int64 *)((char *)&off_23BD00
                                       + (((char *)v259 - (char *)&off_23BF00) & 0xFFFFFFFFFFFFFFF8LL)
                                       + 8);
            *(_BYTE *)(v251 - 2) = *v255;
            *(_BYTE *)(v251 - 1) = *v255;
            goto LABEL_331;
          }
          __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate isStringProp (%d)\n", 70LL);
          free(v364);
        }
        else
        {
          __fprintf_chk(stderr, 1LL, "Error: Couldn't allocate font properties (%ld*%d)\n", 16LL);
        }
        if ( !pFont->refcnt )
          j_FontFileCloseFont(0LL, pFont);
        v42->info.nprops = 1;
        v42->info.isStringProp = 0LL;
        v33 = 80;
        v42->info.props = v364;
        sub_1CE90(v42);
        return v33;
      }
LABEL_402:
      *(_DWORD *)(v35 + 88) = 0;
      v426 = 0LL;
      goto LABEL_222;
    }
  }
  v112 = *(_QWORD *)(*((_QWORD *)v58 + 5) + 8LL * (v69 >> 7));
  if ( v112 )
    goto LABEL_487;
  v138 = v68;
  v139 = v71;
  v140 = (_QWORD *)(*((_QWORD *)v58 + 5) + 8LL * (v69 >> 7));
  v141 = v70;
  v142 = calloc(0x80uLL, 8uLL);
  v70 = v141;
  v71 = v139;
  v68 = v138;
  *v140 = v142;
  v112 = *(_QWORD *)(*((_QWORD *)v58 + 5) + 8LL * (v69 >> 7));
  if ( v112 )
  {
LABEL_487:
    *(_QWORD *)(v112 + 8LL * (v69 & 0x7F)) = v68;
    v113 = (double)*v110;
    v114 = (double)-v110[4];
    v115 = v110[3];
    v116 = v467 * v113;
    v117 = v113 * v468;
    v118 = v469 * v114;
    v119 = v114 * v470;
    v120 = v470 * (double)v115;
    v121 = v116 + v118;
    v122 = v469 * (double)v115;
    v123 = v117 + v119;
    v124 = v117 + v120;
    v125 = v116 + v122;
    v126 = fmax(v116 + v122, v116 + v118);
    v127 = fmin(v125, v121);
    if ( v123 <= v124 )
    {
      v73 = xmmword_30670;
      v74 = v123;
      *(_QWORD *)&v75 = *(_QWORD *)&v123 ^ xmmword_30670;
    }
    else
    {
      v73 = xmmword_30670;
      v74 = v124;
      *(_QWORD *)&v75 = *(_QWORD *)&v124 ^ xmmword_30670;
    }
    v76 = v110[1];
    v77 = fmax(v124, v123);
    v78 = v467 * (double)v76;
    v79 = (double)v76 * v468;
    v80 = v118 + v78;
    v81 = v119 + v79;
    v82 = fmin(v80, v127);
    v83 = fmax(v80, v126);
    if ( v74 > v81 )
    {
      v74 = v81;
      *(_QWORD *)&v75 = *(_QWORD *)&v81 ^ v73;
    }
    v84 = v78 + v122;
    v85 = v79 + v120;
    v86 = fmax(v81, v77);
    v87 = fmin(v84, v82);
    v88 = fmax(v84, v83);
    v89.m128d_f64[0] = v87;
    if ( v74 > v85 )
      *(_QWORD *)&v75 = v73 ^ *(_QWORD *)&v85;
    v90 = fmax(v85, v86);
    v91 = v87;
    if ( COERCE_DOUBLE(*(_QWORD *)&v87 & v70.m128i_i64[0]) < 4.503599627370496e15 )
    {
      v92.m128d_f64[0] = (double)(signed int)v87;
      *(_QWORD *)&v91 = COERCE_UNSIGNED_INT64(v92.m128d_f64[0] - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v92, v89) & 0x3FF0000000000000LL)) | ~v70.m128i_i64[0] & *(_QWORD *)&v87;
    }
    v93 = (signed int)v91;
    v94.m128d_f64[0] = v88 + 0.5;
    *v68 = (signed int)v91;
    if ( COERCE_DOUBLE(*(_QWORD *)&v94.m128d_f64[0] & v70.m128i_i64[0]) < 4.503599627370496e15 )
    {
      v95.m128d_f64[0] = (double)(signed int)v94.m128d_f64[0];
      *(_QWORD *)&v94.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                       v95.m128d_f64[0]
                                     - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v95, v94) & 0x3FF0000000000000LL)) | ~v70.m128i_i64[0] & *(_QWORD *)&v94.m128d_f64[0];
    }
    v96 = (signed int)v94.m128d_f64[0];
    v94.m128d_f64[0] = v75;
    v68[1] = v96;
    if ( COERCE_DOUBLE(*(_QWORD *)&v75 & v70.m128i_i64[0]) < 4.503599627370496e15 )
    {
      v97.m128d_f64[0] = (double)(signed int)v75;
      *(_QWORD *)&v94.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                       COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v94, v97) & 0x3FF0000000000000LL)
                                     + v97.m128d_f64[0]) | ~v70.m128i_i64[0] & *(_QWORD *)&v75;
    }
    v98.m128d_f64[0] = v90 + 0.5;
    v68[4] = (signed int)v94.m128d_f64[0];
    if ( COERCE_DOUBLE(*(_QWORD *)&v98.m128d_f64[0] & v70.m128i_i64[0]) < 4.503599627370496e15 )
    {
      v99.m128d_f64[0] = (double)(signed int)v98.m128d_f64[0];
      *(_QWORD *)&v98.m128d_f64[0] = COERCE_UNSIGNED_INT64(
                                       v99.m128d_f64[0]
                                     - COERCE_DOUBLE(*(_OWORD *)&_mm_cmpgt_sd(v99, v98) & 0x3FF0000000000000LL)) | ~v70.m128i_i64[0] & *(_QWORD *)&v98.m128d_f64[0];
    }
    v100 = (signed int)v98.m128d_f64[0];
    v68[3] = (signed int)v98.m128d_f64[0];
    v101 = v110[2];
    ptra += v101;
    v102 = (double)v101 * v461;
    if ( v102 < 0.0 )
      v103 = v102 - 0.5;
    else
      v103 = v102 + 0.5;
    v104 = (signed int)v103;
    v68[2] = (signed int)v103;
    v105 = (double)v110[2] * v385;
    if ( v105 < 0.0 )
      v106 = v105 - 0.5;
    else
      v106 = v105 + 0.5;
    v68[5] = (signed int)v106;
    if ( !(_WORD)v104 )
    {
      if ( (_WORD)v93 == (_WORD)v96 )
        v68[1] = v96 + 1;
      if ( !((signed __int16)(signed int)v94.m128d_f64[0] + (signed __int16)v100) )
        v68[3] = v100 + 1;
    }
    v68 += 12;
    goto LABEL_111;
  }
  v42 = v72;
LABEL_156:
  free(v42);
  free(*((void **)v58 + 2));
  free(*((void **)v58 + 3));
  free(*((void **)v58 + 4));
  v143 = (char *)*((_QWORD *)v58 + 5);
  if ( v143 )
  {
    v144 = v359 + 254;
    if ( v359 + 127 >= 0 )
      v144 = v359 + 127;
    v145 = v144 >> 7;
    if ( v145 > 0 )
    {
      v146 = 0LL;
      v147 = 8LL * (unsigned int)(v145 - 1) + 8;
      do
      {
        v148 = *(void **)&v143[v146];
        v146 += 8LL;
        free(v148);
        v143 = (char *)*((_QWORD *)v58 + 5);
      }
      while ( v146 != v147 );
    }
  }
LABEL_162:
  free(v143);
LABEL_152:
  v33 = 80;
  if ( !pFont->refcnt )
    j_FontFileCloseFont(0LL, pFont);
  return v33;
}
// 4: using guessed type char;
// 8420: using guessed type __int64 __fastcall FontFileCompleteXLFD(_QWORD, _QWORD);
// 8610: using guessed type __int64 __fastcall FontFileOpenBitmap(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8620: using guessed type __int64 __fastcall FontComputeInfoAccelerators(_QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 8E00: using guessed type __int64 __cdecl FontFileCountDashes(_QWORD, _QWORD, _QWORD);
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 9050: using guessed type __int64 __fastcall FontFileFindNameInDir(_QWORD, _QWORD);
// 30160: using guessed type __int128 xmmword_30160;
// 30670: using guessed type __int128 xmmword_30670;
// 23BD00: using guessed type char *off_23BD00;
// 23BF00: using guessed type void *off_23BF00;
// 23C1A0: using guessed type char *off_23C1A0;
// 23CCC8: using guessed type __int64 qword_23CCC8;
// 1CF60: using guessed type char dest[1032];

//----- (00000000000200C0) ----------------------------------------------------
__int64 __fastcall BitmapGetInfoScalable(__int64 a1, __m128i *a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rdi
  __int64 v5; // [rsp+18h] [rbp-18h]
  unsigned __int64 v6; // [rsp+20h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  result = BitmapOpenScalable(a1, &v5, 0LL, a3);
  if ( (_DWORD)result == 85 )
  {
    v4 = v5;
    *a2 = _mm_loadu_si128((const __m128i *)(v5 + 8));
    a2[1] = _mm_loadu_si128((const __m128i *)(v4 + 24));
    a2[2] = _mm_loadu_si128((const __m128i *)(v4 + 40));
    a2[3] = _mm_loadu_si128((const __m128i *)(v4 + 56));
    a2[4] = _mm_loadu_si128((const __m128i *)(v4 + 72));
    a2[5].m128i_i64[0] = *(_QWORD *)(v4 + 88);
    *(_DWORD *)(v4 + 76) = 0;
    *(_QWORD *)(v4 + 80) = 0LL;
    *(_QWORD *)(v4 + 88) = 0LL;
    (*(void (__fastcall **)(__int64))(v4 + 120))(v4);
    result = 85LL;
  }
  return result;
}
// 8AC0: using guessed type __int64 __fastcall BitmapOpenScalable(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020180) ----------------------------------------------------
unsigned __int64 __fastcall FontCharInkMetrics(__int64 a1, signed __int16 *a2, _WORD *a3)
{
  char v3; // al
  bool v4; // zf
  unsigned __int8 *v5; // rax
  __int16 v6; // r15
  int v7; // ebp
  unsigned __int64 result; // rax
  signed __int16 v9; // r8
  int v10; // ebx
  __int64 v11; // rdi
  int v12; // er12
  __int64 v13; // rcx
  int v14; // er9
  int v15; // er9
  signed __int64 v16; // rax
  int v17; // ecx
  int v18; // er11
  _BYTE *v19; // r13
  int v20; // er14
  int v21; // edi
  int v22; // er10
  _BYTE *v23; // rcx
  int v24; // eax
  unsigned __int8 v25; // r8
  __int16 v26; // r10
  __int16 v27; // ax
  __int16 v28; // r14
  signed __int64 v29; // r9
  signed int i; // ebp
  unsigned __int8 v31; // r8
  _BYTE *v32; // rcx
  unsigned __int8 *v33; // rax
  unsigned __int8 v34; // cl
  unsigned __int8 *v35; // [rsp+0h] [rbp-48h]
  int v36; // [rsp+Ch] [rbp-3Ch]

  v3 = *(_BYTE *)(a1 + 96);
  v35 = (unsigned __int8 *)&unk_23C388;
  if ( v3 != 1 )
  {
    v4 = v3 == 0;
    v5 = 0LL;
    if ( v4 )
      v5 = (unsigned __int8 *)&unk_23C380;
    v35 = v5;
  }
  a3[2] = a2[2];
  a3[5] = a2[5];
  v6 = *a2;
  v7 = a2[1] - *a2;
  result = *(unsigned __int8 *)(a1 + 98);
  v9 = a2[3];
  v10 = (v7 + 7) >> 3;
  switch ( (_BYTE)result )
  {
    case 1:
      v36 = (v7 + 7) >> 3;
      LODWORD(v11) = 0;
      break;
    case 2:
      result = ((v7 + 15) >> 3) & 0xFFFFFFFE;
      v36 = result;
      LODWORD(v11) = result - v10;
      break;
    case 4:
      result = ((v7 + 31) >> 3) & 0xFFFFFFFC;
      v36 = result;
      LODWORD(v11) = result - v10;
      break;
    case 8:
      result = ((v7 + 63) >> 3) & 0xFFFFFFF8;
      v36 = result;
      LODWORD(v11) = result - v10;
      break;
    default:
      v36 = 0;
      LODWORD(v11) = -v10;
      break;
  }
  v12 = a2[3] + a2[4] - 1;
  v13 = *((_QWORD *)a2 + 2);
  v14 = v12;
  if ( v12 >= 0 )
  {
    while ( 2 )
    {
      LODWORD(result) = (v7 + 7) >> 3;
      while ( 1 )
      {
        result = (unsigned int)(result - 1);
        if ( (result & 0x80000000) != 0LL )
          break;
        if ( *(_BYTE *)(++v13 - 1) )
        {
          v11 = (signed int)v11;
          a3[3] = v14 - a2[4] + 1;
          v15 = v12;
          v16 = *((_QWORD *)a2 + 2) + v10 + (signed __int64)(v12 * v36);
          do
          {
            v17 = (v7 + 7) >> 3;
            while ( --v17 >= 0 )
            {
              if ( *(_BYTE *)--v16 )
                goto LABEL_22;
            }
            --v15;
            v16 -= v11;
          }
          while ( v15 != -1 );
LABEL_22:
          v18 = v10 - 1;
          a3[4] = v15 - v9 + 1;
          if ( v10 <= 0 )
          {
            v27 = 0;
            LOWORD(v20) = 8;
            v26 = 0;
            LOWORD(v21) = 0;
          }
          else
          {
            v19 = (_BYTE *)*((_QWORD *)a2 + 2);
            v20 = 8;
            LOWORD(v21) = 0;
            v22 = 0;
            do
            {
              v23 = v19;
              v24 = v12;
              v25 = 0;
              do
              {
                --v24;
                v25 |= *v23;
                v23 += v36;
              }
              while ( v24 != -1 );
              if ( v25 )
              {
                v33 = v35;
                if ( v22 == v18 )
                  v20 = v7 - 8 * v22;
                v21 = v20;
                while ( --v21 >= 0 )
                {
                  v34 = *v33++;
                  if ( v25 & v34 )
                  {
                    v26 = 8 * v22;
                    v27 = v21;
                    goto LABEL_29;
                  }
                }
              }
              ++v22;
              ++v19;
            }
            while ( v10 != v22 );
            v26 = 8 * v10;
            v27 = v21;
          }
LABEL_29:
          v28 = v6 + v26 - 1 + v20 - v27;
          result = (unsigned int)(8 * v18);
          v29 = v10 - 1LL;
          *a3 = v28;
          for ( i = v7 - result; v18 >= 0; i = 8 )
          {
            LODWORD(result) = v12;
            v31 = 0;
            v32 = (_BYTE *)(v29 + *((_QWORD *)a2 + 2));
            do
            {
              result = (unsigned int)(result - 1);
              v31 |= *v32;
              v32 += v36;
            }
            while ( (_DWORD)result != -1 );
            if ( v31 )
            {
              v21 = i;
              result = (unsigned __int64)&v35[i];
              while ( --v21 >= 0 )
              {
                if ( v31 & *(_BYTE *)--result )
                  goto LABEL_34;
              }
            }
            --v18;
            --v29;
          }
LABEL_34:
          a3[1] = v6 + v21 + 1 + 8 * v18;
          return result;
        }
      }
      --v14;
      v13 += (signed int)v11;
      if ( v14 != -1 )
        continue;
      break;
    }
  }
  *a3 = v6;
  a3[1] = v6;
  *(_DWORD *)(a3 + 3) = 0;
  return result;
}

//----- (0000000000020480) ----------------------------------------------------
__int64 __fastcall FontCharReshape(__int64 a1, signed __int16 *a2, signed __int16 *a3)
{
  __int64 v3; // r15
  signed __int16 *v4; // r12
  signed __int16 *v5; // rbp
  void *v6; // r8
  __int64 v7; // rbx
  int v8; // edx
  int v9; // eax
  char v10; // cl
  size_t v11; // rdx
  unsigned int v12; // ecx
  __int64 v13; // r13
  _BYTE *v14; // rax
  int v15; // edx
  _BYTE *v16; // r8
  int v17; // eax
  int v18; // er9
  __int64 result; // rax
  int v20; // er14
  int v21; // er10
  int v22; // edi
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // eax
  int v29; // esi
  int v30; // eax
  int v31; // edx
  int v32; // edx
  int v33; // eax
  int v34; // edx
  signed int v35; // [rsp+8h] [rbp-40h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = (void *)*((_QWORD *)a3 + 2);
  v7 = *((_QWORD *)a2 + 2);
  v8 = a3[1] - *a3;
  v9 = v4[4] + v4[3];
  v10 = *(_BYTE *)(a1 + 98);
  switch ( v10 )
  {
    case 1:
      v12 = (v8 + 7) >> 3;
      LODWORD(v13) = (a2[1] - *a2 + 7) >> 3;
      v11 = (signed int)(v12 * v9);
      break;
    case 2:
      v12 = ((v8 + 15) >> 3) & 0xFFFFFFFE;
      LODWORD(v13) = ((a2[1] - *a2 + 15) >> 3) & 0xFFFFFFFE;
      v11 = (signed int)(v12 * v9);
      break;
    case 4:
      v12 = ((v8 + 31) >> 3) & 0xFFFFFFFC;
      LODWORD(v13) = ((a2[1] - *a2 + 31) >> 3) & 0xFFFFFFFC;
      v11 = (signed int)(v12 * v9);
      break;
    case 8:
      v12 = ((v8 + 63) >> 3) & 0xFFFFFFF8;
      LODWORD(v13) = ((a2[1] - *a2 + 63) >> 3) & 0xFFFFFFF8;
      v11 = (signed int)(v12 * v9);
      break;
    default:
      v11 = 0LL;
      v12 = 0;
      LODWORD(v13) = 0;
      break;
  }
  v35 = v12;
  v14 = memset(v6, 0, v11);
  v15 = v4[3];
  v16 = v14;
  v17 = a2[3];
  if ( a2[3] >= v4[3] )
  {
    v18 = -v15;
    result = (signed int)v13 * (v17 - v15);
    v7 += result;
  }
  else
  {
    v18 = -v17;
    result = v35 * (v15 - v17);
    v16 += result;
  }
  LOWORD(v20) = a2[4];
  LOWORD(v21) = *a2;
  LOWORD(v22) = a2[1];
  if ( v4[4] <= (signed __int16)v20 )
    LOWORD(v20) = v4[4];
  if ( *v4 >= (signed __int16)v21 )
    LOWORD(v21) = *v4;
  if ( v4[1] <= (signed __int16)v22 )
    LOWORD(v22) = v4[1];
  v20 = (signed __int16)v20;
  v21 = (signed __int16)v21;
  v22 = (signed __int16)v22;
  if ( *(_BYTE *)(v3 + 96) == 1 )
  {
    if ( v18 < v20 )
    {
      result = v35;
      do
      {
        v29 = v21;
        if ( v21 < v22 )
        {
          do
          {
            v30 = v29 - *v5;
            v31 = v30 + 7;
            if ( v30 >= 0 )
              v31 = v29 - *v5;
            v32 = *(unsigned __int8 *)(v7 + (v31 >> 3));
            result = ((((unsigned int)((v29 - *v5) >> 31) >> 29) + (_BYTE)v30) & 7)
                   - ((unsigned int)((v29 - *v5) >> 31) >> 29);
            if ( _bittest(&v32, 7 - result) )
            {
              v33 = v29 - *v4;
              v34 = v33 + 7;
              if ( v33 >= 0 )
                v34 = v29 - *v4;
              result = (unsigned int)(1 << (7
                                          - (((((unsigned int)((v29 - *v4) >> 31) >> 29) + v33) & 7)
                                           - ((unsigned int)((v29 - *v4) >> 31) >> 29))));
              v16[v34 >> 3] |= result;
            }
            ++v29;
          }
          while ( v22 != v29 );
        }
        ++v18;
        v7 += (signed int)v13;
        v16 += v35;
      }
      while ( v20 != v18 );
    }
  }
  else if ( v18 < v20 )
  {
    v13 = (signed int)v13;
    do
    {
      v23 = v21;
      if ( v21 < v22 )
      {
        do
        {
          v24 = v23 - *a2;
          v25 = v24 + 7;
          if ( v24 >= 0 )
            v25 = v23 - *a2;
          v26 = *(unsigned __int8 *)(v7 + (v25 >> 3));
          result = ((((unsigned int)((v23 - *a2) >> 31) >> 29) + (_BYTE)v24) & 7)
                 - ((unsigned int)((v23 - *a2) >> 31) >> 29);
          if ( _bittest(&v26, result) )
          {
            v27 = v23 - *v4;
            v28 = v27 + 7;
            if ( v27 >= 0 )
              v28 = v23 - *v4;
            result = v28 >> 3;
            v16[result] |= 1 << (((((unsigned int)((v23 - *v4) >> 31) >> 29) + v27) & 7)
                               - ((unsigned int)((v23 - *v4) >> 31) >> 29));
          }
          ++v23;
        }
        while ( v22 != v23 );
      }
      ++v18;
      v7 += v13;
      v16 += v35;
    }
    while ( v20 != v18 );
  }
  return result;
}

//----- (00000000000207D0) ----------------------------------------------------
__int64 __fastcall sub_207D0(unsigned __int8 **a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // ebp
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // ebp
  int v13; // eax
  unsigned __int8 *v15; // rdx
  unsigned __int8 *v16; // rax
  unsigned __int8 *v17; // rax
  unsigned __int8 *v18; // rax

  v1 = *((_DWORD *)a1 + 2);
  v2 = v1 - 1;
  *((_DWORD *)a1 + 2) = v1 - 1;
  if ( v1 )
  {
    v15 = (*a1)++;
    v5 = v2 - 1;
    v3 = *v15;
    *((_DWORD *)a1 + 2) = v2 - 1;
    if ( !v2 )
    {
LABEL_3:
      v6 = ((__int64 (__fastcall *)(unsigned __int8 **))a1[1026])(a1);
      v7 = *((_DWORD *)a1 + 2);
      *((_DWORD *)a1 + 3) = v6;
      v8 = (v6 << 8) | v3;
      v9 = v7 - 1;
      *((_DWORD *)a1 + 2) = v7 - 1;
      if ( !v7 )
        goto LABEL_4;
LABEL_8:
      v17 = (*a1)++;
      v12 = (*v17 << 16) | v8;
      *((_DWORD *)a1 + 2) = v9 - 1;
      if ( !v9 )
        goto LABEL_5;
      goto LABEL_9;
    }
  }
  else
  {
    v3 = ((__int64 (*)(void))a1[1026])();
    *((_DWORD *)a1 + 3) = v3;
    v4 = *((_DWORD *)a1 + 2);
    v5 = v4 - 1;
    *((_DWORD *)a1 + 2) = v4 - 1;
    if ( !v4 )
      goto LABEL_3;
  }
  v16 = (*a1)++;
  LODWORD(v16) = *v16;
  v9 = v5 - 1;
  *((_DWORD *)a1 + 2) = v5 - 1;
  v8 = ((_DWORD)v16 << 8) | v3;
  if ( v5 )
    goto LABEL_8;
LABEL_4:
  v10 = ((__int64 (__fastcall *)(unsigned __int8 **))a1[1026])(a1);
  v11 = *((_DWORD *)a1 + 2);
  *((_DWORD *)a1 + 3) = v10;
  v12 = (v10 << 16) | v8;
  *((_DWORD *)a1 + 2) = v11 - 1;
  if ( !v11 )
  {
LABEL_5:
    v13 = ((__int64 (__fastcall *)(unsigned __int8 **))a1[1026])(a1);
    dword_23CCD0 += 4;
    *((_DWORD *)a1 + 3) = v13;
    return v12 | (unsigned int)(v13 << 24);
  }
LABEL_9:
  v18 = *a1;
  dword_23CCD0 += 4;
  *a1 = v18 + 1;
  return v12 | ((unsigned int)*v18 << 24);
}
// 23CCD0: using guessed type int dword_23CCD0;

//----- (00000000000208E0) ----------------------------------------------------
__int64 __fastcall sub_208E0(__int64 a1, char a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // ebp
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // ebp
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // ebp
  unsigned int v17; // eax
  int v19; // eax
  int v20; // ebp
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // ebp
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  unsigned __int8 *v30; // rax
  unsigned __int8 *v31; // rax
  unsigned __int8 *v32; // rax
  unsigned __int8 *v33; // rax
  unsigned __int8 *v34; // rax
  unsigned __int8 *v35; // rax
  unsigned __int8 *v36; // rax
  unsigned __int8 *v37; // rax

  v2 = *(_DWORD *)(a1 + 8);
  v3 = v2 - 1;
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( a2 & 4 )
  {
    if ( v2 )
    {
      v31 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v5 = *v31 << 24;
    }
    else
    {
      v4 = (*(__int64 (**)(void))(a1 + 8208))();
      *(_DWORD *)(a1 + 12) = v4;
      v5 = v4 << 24;
    }
    v6 = *(_DWORD *)(a1 + 8);
    v7 = v6;
    v8 = v6 - 1;
    *(_DWORD *)(a1 + 8) = v8;
    if ( v7 )
    {
      v33 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v10 = *v33 << 16;
    }
    else
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      v8 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) = v9;
      v10 = v9 << 16;
    }
    v11 = v10 | v5;
    v12 = v8;
    v13 = v8 - 1;
    *(_DWORD *)(a1 + 8) = v13;
    if ( v12 )
    {
      v32 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v15 = *v32 << 8;
    }
    else
    {
      v14 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      v13 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) = v14;
      v15 = v14 << 8;
    }
    v16 = v15 | v11;
    *(_DWORD *)(a1 + 8) = v13 - 1;
    if ( !v13 )
    {
      v17 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      dword_23CCD0 += 4;
      *(_DWORD *)(a1 + 12) = v17;
      return v16 | v17;
    }
    v34 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v29 = *v34;
  }
  else
  {
    if ( v2 )
    {
      v30 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v20 = *v30;
    }
    else
    {
      v19 = (*(__int64 (**)(void))(a1 + 8208))();
      v3 = *(_DWORD *)(a1 + 8);
      v20 = v19;
      *(_DWORD *)(a1 + 12) = v19;
    }
    v21 = v3 - 1;
    *(_DWORD *)(a1 + 8) = v3 - 1;
    if ( v3 )
    {
      v35 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v23 = *v35 << 8;
    }
    else
    {
      v22 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      v21 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) = v22;
      v23 = v22 << 8;
    }
    v24 = v21 - 1;
    v25 = v23 | v20;
    *(_DWORD *)(a1 + 8) = v21 - 1;
    if ( v21 )
    {
      v37 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v27 = *v37 << 16;
    }
    else
    {
      v26 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) = v26;
      v27 = v26 << 16;
    }
    v16 = v27 | v25;
    *(_DWORD *)(a1 + 8) = v24 - 1;
    if ( v24 )
    {
      v36 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v29 = *v36 << 24;
    }
    else
    {
      v28 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      *(_DWORD *)(a1 + 12) = v28;
      v29 = v28 << 24;
    }
  }
  dword_23CCD0 += 4;
  return v16 | (unsigned int)v29;
}
// 23CCD0: using guessed type int dword_23CCD0;

//----- (0000000000020AE0) ----------------------------------------------------
__int64 __fastcall sub_20AE0(__int64 a1, char a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // ebp
  int v6; // edx
  unsigned int v7; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  unsigned __int8 *v12; // rdx
  unsigned __int8 *v13; // rax
  unsigned __int8 *v14; // rax
  unsigned __int8 *v15; // rax

  v2 = *(_DWORD *)(a1 + 8);
  v3 = v2 - 1;
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( a2 & 4 )
  {
    if ( v2 )
    {
      v13 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v5 = *v13 << 8;
    }
    else
    {
      v4 = (*(__int64 (**)(void))(a1 + 8208))();
      *(_DWORD *)(a1 + 12) = v4;
      v5 = v4 << 8;
    }
    v6 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v6 - 1;
    if ( !v6 )
    {
      v7 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      dword_23CCD0 += 2;
      *(_DWORD *)(a1 + 12) = v7;
      return v5 | v7;
    }
    v14 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v11 = *v14;
  }
  else
  {
    if ( v2 )
    {
      v12 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v5 = *v12;
    }
    else
    {
      v9 = (*(__int64 (**)(void))(a1 + 8208))();
      v5 = v9;
      *(_DWORD *)(a1 + 12) = v9;
      v3 = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v3 - 1;
    if ( v3 )
    {
      v15 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v11 = *v15 << 8;
    }
    else
    {
      v10 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
      *(_DWORD *)(a1 + 12) = v10;
      v11 = v10 << 8;
    }
  }
  dword_23CCD0 += 2;
  return v5 | (unsigned int)v11;
}
// 23CCD0: using guessed type int dword_23CCD0;

//----- (0000000000020BE0) ----------------------------------------------------
_BOOL8 __fastcall sub_20BE0(__int64 a1, char a2, _WORD *a3)
{
  _WORD *v3; // rbp

  v3 = a3;
  *a3 = sub_20AE0(a1, a2);
  v3[1] = sub_20AE0(a1, a2);
  v3[2] = sub_20AE0(a1, a2);
  v3[3] = sub_20AE0(a1, a2);
  v3[4] = sub_20AE0(a1, a2);
  v3[5] = sub_20AE0(a1, a2);
  return *(_DWORD *)(a1 + 12) != -1;
}

//----- (0000000000020C50) ----------------------------------------------------
signed __int64 __fastcall sub_20C50(__int64 a1, _DWORD *a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  _DWORD *v6; // rbx
  signed __int64 v7; // rax
  signed __int64 v8; // rdx
  unsigned int v10; // esi
  int v11; // eax
  _DWORD *v12; // [rsp+0h] [rbp-28h]
  _DWORD *v13; // [rsp+8h] [rbp-20h]

  if ( a3 <= 0 )
    return 0LL;
  v6 = a2;
  if ( a4 != *a2 )
  {
    v7 = (signed __int64)(a2 + 4);
    v8 = (signed __int64)&a2[4 * (a3 - 1) + 4];
    while ( v7 != v8 )
    {
      v6 = (_DWORD *)v7;
      v7 += 16LL;
      if ( *(_DWORD *)(v7 - 16) == a4 )
        goto LABEL_7;
    }
    return 0LL;
  }
LABEL_7:
  v10 = v6[3];
  v13 = a6;
  v12 = a5;
  if ( v10 < dword_23CCD0 )
    return 0LL;
  v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 8224))(a1, v10 - dword_23CCD0);
  *(_DWORD *)(a1 + 12) = v11;
  if ( v11 == -1 )
    return 0LL;
  dword_23CCD0 = v6[3];
  *v13 = v6[2];
  *v12 = v6[1];
  return 1LL;
}
// 23CCD0: using guessed type int dword_23CCD0;

//----- (0000000000020D00) ----------------------------------------------------
_BOOL8 __fastcall sub_20D00(__int64 a1, __int64 a2, _DWORD *a3, int a4, int a5)
{
  __int64 v5; // rbx
  _DWORD *v6; // rsi
  int v7; // edx
  int v8; // eax
  int v9; // eax
  char v10; // cl
  char v11; // al
  int v12; // edx
  int v13; // eax
  int v14; // eax
  char v15; // al
  char v16; // cl
  int v17; // edx
  int v18; // eax
  int v19; // eax
  char v20; // al
  char v21; // cl
  int v22; // edx
  int v23; // eax
  int v24; // eax
  char v25; // al
  char v26; // cl
  int v27; // edx
  int v28; // eax
  int v29; // eax
  char v30; // al
  char v31; // cl
  int v32; // edx
  int v33; // eax
  int v34; // eax
  char v35; // al
  char v36; // cl
  int v37; // edx
  int v38; // eax
  int v39; // eax
  char v40; // al
  __int16 v41; // ax
  int v42; // eax
  __int16 v43; // ax
  char v44; // si
  __int16 v45; // ax
  char v46; // si
  int v48; // eax
  _BYTE *v49; // rax
  _BYTE *v50; // rax
  _BYTE *v51; // rax
  _BYTE *v52; // rax
  _BYTE *v53; // rax
  _BYTE *v54; // rax
  _BYTE *v55; // rax
  int v56; // [rsp+0h] [rbp-28h]
  char v57; // [rsp+4h] [rbp-24h]
  unsigned __int64 v58; // [rsp+8h] [rbp-20h]

  v5 = a2;
  v6 = a3;
  v58 = __readfsqword(0x28u);
  if ( !(unsigned int)sub_20C50(v5, a3, a4, a5, &v56, &v57) )
    return 0LL;
  if ( *(_DWORD *)(v5 + 12) == -1 )
    return 0LL;
  v56 = sub_207D0((unsigned __int8 **)v5);
  if ( v56 & 0xFFFFFE00 )
    return 0LL;
  v7 = dword_23CCD0 + 1;
  v8 = *(_DWORD *)(v5 + 8);
  ++dword_23CCD0;
  *(_DWORD *)(v5 + 8) = v8 - 1;
  if ( v8 )
  {
    v55 = (_BYTE *)(*(_QWORD *)v5)++;
    v10 = *v55 & 1;
  }
  else
  {
    v9 = (*(__int64 (__fastcall **)(__int64, _DWORD *))(v5 + 8208))(v5, v6);
    v7 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v9;
    v10 = v9 & 1;
  }
  v11 = *(_BYTE *)(a1 + 10);
  v12 = v7 + 1;
  dword_23CCD0 = v12;
  *(_BYTE *)(a1 + 10) = v10 | v11 & 0xFE;
  v13 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 8) = v13 - 1;
  if ( v13 )
  {
    v54 = (_BYTE *)(*(_QWORD *)v5)++;
    v15 = *v54 & 1;
  }
  else
  {
    v14 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
    v12 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v14;
    v15 = v14 & 1;
  }
  v16 = *(_BYTE *)(a1 + 10);
  v17 = v12 + 1;
  dword_23CCD0 = v17;
  *(_BYTE *)(a1 + 10) = v16 & 0xFB | 4 * v15;
  v18 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 8) = v18 - 1;
  if ( v18 )
  {
    v53 = (_BYTE *)(*(_QWORD *)v5)++;
    v20 = *v53 & 1;
  }
  else
  {
    v19 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
    v17 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v19;
    v20 = v19 & 1;
  }
  v21 = *(_BYTE *)(a1 + 10);
  v22 = v17 + 1;
  dword_23CCD0 = v22;
  *(_BYTE *)(a1 + 10) = v21 & 0xFD | 2 * v20;
  v23 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 8) = v23 - 1;
  if ( v23 )
  {
    v52 = (_BYTE *)(*(_QWORD *)v5)++;
    v25 = *v52 & 1;
  }
  else
  {
    v24 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
    v22 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v24;
    v25 = v24 & 1;
  }
  v26 = *(_BYTE *)(a1 + 10);
  v27 = v22 + 1;
  dword_23CCD0 = v27;
  *(_BYTE *)(a1 + 10) = v26 & 0xF7 | 8 * v25;
  v28 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 8) = v28 - 1;
  if ( v28 )
  {
    v51 = (_BYTE *)(*(_QWORD *)v5)++;
    v30 = *v51 & 1;
  }
  else
  {
    v29 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
    v27 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v29;
    v30 = v29 & 1;
  }
  v31 = *(_BYTE *)(a1 + 10);
  v32 = v27 + 1;
  dword_23CCD0 = v32;
  *(_BYTE *)(a1 + 10) = v31 & 0xEF | 16 * v30;
  v33 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 8) = v33 - 1;
  if ( v33 )
  {
    v50 = (_BYTE *)(*(_QWORD *)v5)++;
    v35 = *v50 & 1;
  }
  else
  {
    v34 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
    v32 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v34;
    v35 = v34 & 1;
  }
  v36 = *(_BYTE *)(a1 + 10);
  v37 = v32 + 1;
  dword_23CCD0 = v37;
  *(_BYTE *)(a1 + 10) = v36 & 0xDF | 32 * v35;
  v38 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 8) = v38 - 1;
  if ( v38 )
  {
    v49 = (_BYTE *)(*(_QWORD *)v5)++;
    v40 = *v49 & 3;
  }
  else
  {
    v39 = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
    v37 = dword_23CCD0;
    *(_DWORD *)(v5 + 12) = v39;
    v40 = v39 & 3;
  }
  v41 = ((v40 & 3) << 7) | *(_WORD *)(a1 + 10) & 0xFE7F;
  *(_WORD *)(a1 + 10) = v41;
  *(_BYTE *)(a1 + 11) = HIBYTE(v41) & 0xFB | 2;
  v42 = *(_DWORD *)(v5 + 8);
  dword_23CCD0 = v37 + 1;
  *(_DWORD *)(v5 + 8) = v42 - 1;
  if ( v42 )
    ++*(_QWORD *)v5;
  else
    *(_DWORD *)(v5 + 12) = (*(__int64 (__fastcall **)(__int64))(v5 + 8208))(v5);
  v43 = sub_208E0(v5, v56);
  v44 = v56;
  *(_WORD *)(a1 + 64) = v43;
  v45 = sub_208E0(v5, v44);
  v46 = v56;
  *(_WORD *)(a1 + 66) = v45;
  *(_WORD *)(a1 + 12) = sub_208E0(v5, v46);
  if ( *(_DWORD *)(v5 + 12) == -1
    || !(unsigned int)sub_20BE0(v5, v56, (_WORD *)(a1 + 28))
    || !(unsigned int)sub_20BE0(v5, v56, (_WORD *)(a1 + 16)) )
  {
    return 0LL;
  }
  v48 = v56;
  LOBYTE(v48) = 0;
  if ( v48 != 256 )
  {
    *(_QWORD *)(a1 + 52) = *(_QWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 36);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 24);
    return 1LL;
  }
  if ( !(unsigned int)sub_20BE0(v5, v56, (_WORD *)(a1 + 52)) )
    return 0LL;
  return (unsigned int)sub_20BE0(v5, v56, (_WORD *)(a1 + 40)) != 0;
}
// 23CCD0: using guessed type int dword_23CCD0;
// 23CCD4: using guessed type int dword_23CCD4;

//----- (00000000000210F0) ----------------------------------------------------
void __fastcall sub_210F0(FontPtr font)
{
  FontPtr v1; // r12
  void **v2; // rbp
  char *v3; // rdi
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  __int64 v8; // rbx
  signed __int64 v9; // r13
  void *v10; // rdi

  v1 = font;
  v2 = (void **)font->fontPrivate;
  free(v2[3]);
  v3 = (char *)v2[5];
  if ( v3 )
  {
    v4 = (v1->info.lastRow - v1->info.firstRow + 1) * (v1->info.lastCol - v1->info.firstCol + 1);
    v5 = v4 + 254;
    v6 = v4 + 127;
    if ( v6 < 0 )
      v6 = v5;
    v7 = v6 >> 7;
    if ( v7 > 0 )
    {
      v8 = 0LL;
      v9 = 8LL * (unsigned int)(v7 - 1) + 8;
      do
      {
        v10 = *(void **)&v3[v8];
        v8 += 8LL;
        free(v10);
        v3 = (char *)v2[5];
      }
      while ( v8 != v9 );
    }
  }
  free(v3);
  free(v2[4]);
  free(v2[2]);
  free(v1->info.isStringProp);
  free(v1->info.props);
  free(v2);
  DestroyFontRec(v1);
}

//----- (00000000000211C0) ----------------------------------------------------
_BOOL8 __fastcall sub_211C0(__int64 a1, _WORD *a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // eax
  __int16 v5; // ax
  int v6; // eax
  int v7; // edx
  int v8; // eax
  __int16 v9; // ax
  int v10; // eax
  int v11; // edx
  int v12; // eax
  __int16 v13; // ax
  int v14; // eax
  int v15; // edx
  int v16; // eax
  __int16 v17; // ax
  int v18; // eax
  int v19; // eax
  __int16 v20; // ax
  unsigned __int8 *v22; // rax
  unsigned __int8 *v23; // rax
  unsigned __int8 *v24; // rax
  unsigned __int8 *v25; // rax
  unsigned __int8 *v26; // rax

  v2 = dword_23CCD0 + 1;
  v3 = *(_DWORD *)(a1 + 8);
  ++dword_23CCD0;
  *(_DWORD *)(a1 + 8) = v3 - 1;
  if ( v3 )
  {
    v22 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v5 = *v22 - 128;
  }
  else
  {
    v4 = (*(__int64 (**)(void))(a1 + 8208))();
    v2 = dword_23CCD0;
    *(_DWORD *)(a1 + 12) = v4;
    v5 = v4 - 128;
  }
  *a2 = v5;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = v2 + 1;
  dword_23CCD0 = v7;
  *(_DWORD *)(a1 + 8) = v6 - 1;
  if ( v6 )
  {
    v23 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v9 = *v23 - 128;
  }
  else
  {
    v8 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
    v7 = dword_23CCD0;
    *(_DWORD *)(a1 + 12) = v8;
    v9 = v8 - 128;
  }
  a2[1] = v9;
  v10 = *(_DWORD *)(a1 + 8);
  v11 = v7 + 1;
  dword_23CCD0 = v11;
  *(_DWORD *)(a1 + 8) = v10 - 1;
  if ( v10 )
  {
    v24 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v13 = *v24 - 128;
  }
  else
  {
    v12 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
    v11 = dword_23CCD0;
    *(_DWORD *)(a1 + 12) = v12;
    v13 = v12 - 128;
  }
  a2[2] = v13;
  v14 = *(_DWORD *)(a1 + 8);
  v15 = v11 + 1;
  dword_23CCD0 = v15;
  *(_DWORD *)(a1 + 8) = v14 - 1;
  if ( v14 )
  {
    v25 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v17 = *v25 - 128;
  }
  else
  {
    v16 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
    v15 = dword_23CCD0;
    *(_DWORD *)(a1 + 12) = v16;
    v17 = v16 - 128;
  }
  a2[3] = v17;
  v18 = *(_DWORD *)(a1 + 8);
  dword_23CCD0 = v15 + 1;
  *(_DWORD *)(a1 + 8) = v18 - 1;
  if ( v18 )
  {
    v26 = (unsigned __int8 *)(*(_QWORD *)a1)++;
    v20 = *v26 - 128;
  }
  else
  {
    v19 = (*(__int64 (__fastcall **)(__int64))(a1 + 8208))(a1);
    *(_DWORD *)(a1 + 12) = v19;
    v20 = v19 - 128;
  }
  a2[4] = v20;
  a2[5] = 0;
  return *(_DWORD *)(a1 + 12) != -1;
}
// 23CCD0: using guessed type int dword_23CCD0;

//----- (0000000000021360) ----------------------------------------------------
unsigned __int64 pcfError(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v3; // [rsp+18h] [rbp-D0h]

  va_start(va, a1);
  v3 = __readfsqword(0x28u);
  fwrite("PCF Error: ", 1uLL, 0xBuLL, stderr);
  __vfprintf_chk(stderr, 1LL, a1, va);
  return __readfsqword(0x28u) ^ v3;
}
// 8090: using guessed type __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000021450) ----------------------------------------------------
char *__fastcall sub_21450(__int64 a1, unsigned int *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // er14
  char *v4; // rax
  char *v5; // r12
  char *v6; // rbx
  int v7; // eax
  bool v8; // zf

  dword_23CCD0 = 0;
  if ( (unsigned int)sub_207D0((unsigned __int8 **)a1) == 1885562369 )
  {
    v2 = sub_207D0((unsigned __int8 **)a1);
    v3 = v2;
    if ( *(_DWORD *)(a1 + 12) != -1 )
    {
      if ( v2 > 0x7FFFFFF )
      {
        v5 = 0LL;
        pcfError("pcfReadTOC(): invalid file format\n");
        return v5;
      }
      v4 = (char *)malloc(16LL * (signed int)v2);
      v5 = v4;
      if ( !v4 )
      {
        pcfError("pcfReadTOC(): Couldn't allocate tables (%d*%d)\n");
        return v5;
      }
      if ( !v3 )
      {
LABEL_12:
        *a2 = v3;
        return v5;
      }
      v6 = v4;
      while ( 1 )
      {
        *(_DWORD *)v6 = sub_207D0((unsigned __int8 **)a1);
        *((_DWORD *)v6 + 1) = sub_207D0((unsigned __int8 **)a1);
        *((_DWORD *)v6 + 2) = sub_207D0((unsigned __int8 **)a1);
        v7 = sub_207D0((unsigned __int8 **)a1);
        v8 = *(_DWORD *)(a1 + 12) == -1;
        *((_DWORD *)v6 + 3) = v7;
        if ( v8 )
          break;
        v6 += 16;
        if ( v6 == &v5[16 * v3] )
          goto LABEL_12;
      }
      free(v5);
    }
  }
  return 0LL;
}
// 8A40: using guessed type __int64 __fastcall pcfError(_QWORD);
// 23CCD0: using guessed type int dword_23CCD0;

//----- (0000000000021570) ----------------------------------------------------
signed __int64 __fastcall sub_21570(__int64 a1, __int64 a2, _DWORD *a3, int a4)
{
  __int64 v4; // rbx
  int v5; // eax
  void *v6; // r15
  Atom *v7; // rbp
  int v9; // eax
  __int64 v10; // r12
  void *v11; // rax
  _BYTE *v12; // r14
  signed __int64 v13; // rax
  Atom *v14; // r12
  _BYTE *v15; // rax
  char v16; // si
  int v17; // eax
  __int64 v18; // rsi
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // er12
  int v23; // eax
  int v24; // eax
  unsigned int v25; // er12
  char *v26; // rax
  char *v27; // r14
  _BYTE *v28; // rbx
  char *v29; // r12
  unsigned int v30; // eax
  Atom v31; // rax
  bool v32; // zf
  char *v33; // r12
  unsigned int v34; // eax
  int v35; // [rsp+Ch] [rbp-5Ch]
  Atom *v36; // [rsp+10h] [rbp-58h]
  Atom *v37; // [rsp+18h] [rbp-50h]
  int v38; // [rsp+20h] [rbp-48h]
  char v39; // [rsp+24h] [rbp-44h]
  unsigned __int64 v40; // [rsp+28h] [rbp-40h]

  v4 = a2;
  v40 = __readfsqword(0x28u);
  if ( !(unsigned int)sub_20C50(a2, a3, a4, 1, &v38, &v39) )
    goto LABEL_38;
  v5 = sub_207D0((unsigned __int8 **)a2);
  v38 = v5;
  if ( v5 & 0xFFFFFF00 )
    goto LABEL_38;
  v9 = sub_208E0(a2, v5);
  v10 = (unsigned int)(v9 - 1);
  v35 = v9;
  if ( (unsigned int)v10 > 0x7FFFFFE )
  {
    v6 = 0LL;
    v7 = 0LL;
    pcfError("pcfGetProperties(): invalid nprops value (%d)\n");
    goto LABEL_4;
  }
  if ( *(_DWORD *)(a2 + 12) == -1 )
  {
LABEL_38:
    v6 = 0LL;
    v7 = 0LL;
    goto LABEL_4;
  }
  v7 = (Atom *)malloc(16LL * v9);
  if ( !v7 )
  {
    v6 = 0LL;
    pcfError("pcfGetProperties(): Couldn't allocate props (%d*%d)\n");
    goto LABEL_4;
  }
  v11 = malloc(v35);
  v6 = v11;
  if ( !v11 )
  {
    pcfError("pcfGetProperties(): Couldn't allocate isStringProp (%d*%d)\n");
    goto LABEL_4;
  }
  v37 = v7;
  v12 = v11;
  v13 = (signed __int64)&v7[2 * v10 + 2];
  v14 = v7;
  v36 = (Atom *)v13;
  do
  {
    v19 = sub_208E0(v4, v38);
    ++dword_23CCD0;
    *v14 = v19;
    v20 = *(_DWORD *)(v4 + 8);
    *(_DWORD *)(v4 + 8) = v20 - 1;
    if ( v20 )
    {
      v15 = (_BYTE *)(*(_QWORD *)v4)++;
      LOBYTE(v15) = *v15;
    }
    else
    {
      LODWORD(v15) = (*(__int64 (__fastcall **)(__int64))(v4 + 8208))(v4);
      *(_DWORD *)(v4 + 12) = (_DWORD)v15;
    }
    v16 = v38;
    *v12 = (_BYTE)v15;
    v17 = sub_208E0(v4, v16);
    v18 = *v14;
    v14[1] = v17;
    if ( v18 < 0 || *v12 > 1u || (signed __int64)v17 < 0 && *v12 & 1 )
    {
      pcfError("pcfGetProperties(): invalid file format %ld %d %ld\n");
      goto LABEL_4;
    }
    if ( *(_DWORD *)(v4 + 12) == -1 )
      goto LABEL_4;
    v14 += 2;
    ++v12;
  }
  while ( v14 != v36 );
  v21 = v35 & 3;
  if ( v35 & 3 )
  {
    v22 = 4 - v21;
    v23 = (*(__int64 (__fastcall **)(__int64, _QWORD))(v4 + 8224))(v4, (unsigned int)(4 - v21));
    dword_23CCD0 += v22;
    *(_DWORD *)(v4 + 12) = v23;
    if ( v23 == -1 )
      goto LABEL_4;
  }
  v24 = sub_208E0(v4, v38);
  v25 = v24;
  if ( v24 < 0 || *(_DWORD *)(v4 + 12) == -1 )
    goto LABEL_4;
  v26 = (char *)malloc(v24);
  v27 = v26;
  if ( !v26 )
  {
    pcfError("pcfGetProperties(): Couldn't allocate strings (%d)\n");
    goto LABEL_4;
  }
  BufFileRead(v4, v26, v25);
  if ( *(_DWORD *)(v4 + 12) == -1 )
  {
LABEL_4:
    free(v6);
    free(v7);
    return 0LL;
  }
  dword_23CCD0 += v25;
  v28 = v6;
  do
  {
    v29 = &v27[*v37];
    v30 = strlen(&v27[*v37]);
    v31 = MakeAtom(v29, v30, 1);
    v32 = *v28 == 0;
    *v37 = v31;
    if ( !v32 )
    {
      v33 = &v27[v37[1]];
      v34 = strlen(&v27[v37[1]]);
      v37[1] = MakeAtom(v33, v34, 1);
    }
    ++v28;
    v37 += 2;
  }
  while ( v35 > (signed int)v28 - (signed int)v6 );
  free(v27);
  *(_QWORD *)(a1 + 80) = v6;
  *(_QWORD *)(a1 + 72) = v7;
  *(_DWORD *)(a1 + 68) = v35;
  return 1LL;
}
// 8A40: using guessed type __int64 __fastcall pcfError(_QWORD);
// 8DF0: using guessed type __int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD);
// 23CCD0: using guessed type int dword_23CCD0;

//----- (00000000000218E0) ----------------------------------------------------
signed __int64 __fastcall pcfReadFont(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5, signed int a6)
{
  __int64 v6; // r12
  __int64 v7; // rbx
  char *v8; // rbp
  int v9; // edx
  signed __int64 v10; // rax
  unsigned int v11; // eax
  signed int *v12; // r15
  char *v13; // r13
  void *v14; // r14
  void *v15; // rdi
  _WORD *v17; // r15
  unsigned int v18; // eax
  char v19; // si
  int *v20; // rdx
  __int64 v21; // r14
  int *v22; // ST38_8
  int v23; // eax
  bool v24; // zf
  __int64 v25; // rax
  int v26; // er8
  int v27; // ST38_4
  unsigned int v28; // er8
  unsigned int v29; // esi
  int v30; // er8
  signed int v31; // eax
  signed __int64 v32; // rax
  signed __int16 *v33; // r10
  signed __int64 v34; // r11
  __int64 v35; // rdi
  int v36; // er9
  int v37; // eax
  int v38; // er8
  signed __int64 v39; // ST58_8
  char v40; // cl
  signed __int16 *v41; // ST50_8
  unsigned int v42; // esi
  unsigned int v43; // eax
  signed int v44; // er15
  __int64 v45; // rax
  __int64 v46; // rdx
  signed __int64 v47; // rcx
  __int64 i; // rbx
  unsigned int v49; // eax
  __int16 v50; // ax
  char v51; // si
  __int16 v52; // ax
  char v53; // si
  __int16 v54; // ax
  char v55; // si
  __int16 v56; // ax
  char v57; // si
  int v58; // esi
  int v59; // eax
  int v60; // ecx
  int v61; // edx
  int v62; // eax
  int v63; // er15
  __int64 v64; // rbp
  int v65; // eax
  int v66; // ebx
  __int64 v67; // rax
  char *v68; // rdx
  char *v69; // ST50_8
  void *v70; // rax
  void **v71; // r15
  void *v72; // rdi
  _QWORD *v73; // rax
  unsigned __int16 v74; // r9
  int v75; // edx
  int v76; // er8
  int v77; // edi
  int v78; // edx
  unsigned int v79; // edx
  __int64 v80; // rcx
  __int64 v81; // rdx
  _WORD *ptr; // [rsp+8h] [rbp-C0h]
  int v83; // [rsp+10h] [rbp-B8h]
  unsigned int v84; // [rsp+14h] [rbp-B4h]
  int v85; // [rsp+18h] [rbp-B0h]
  signed int v86; // [rsp+1Ch] [rbp-ACh]
  __int64 v87; // [rsp+20h] [rbp-A8h]
  char *v88; // [rsp+28h] [rbp-A0h]
  signed int v89; // [rsp+30h] [rbp-98h]
  signed int v90; // [rsp+34h] [rbp-94h]
  void *v91; // [rsp+38h] [rbp-90h]
  int v92; // [rsp+38h] [rbp-90h]
  signed int v93; // [rsp+38h] [rbp-90h]
  signed int v94; // [rsp+40h] [rbp-88h]
  __int64 v95; // [rsp+40h] [rbp-88h]
  int v96; // [rsp+40h] [rbp-88h]
  char *v97; // [rsp+48h] [rbp-80h]
  int v98; // [rsp+48h] [rbp-80h]
  unsigned int v99; // [rsp+64h] [rbp-64h]
  char v100; // [rsp+68h] [rbp-60h]
  int v101; // [rsp+6Ch] [rbp-5Ch]
  int v102[6]; // [rsp+70h] [rbp-58h]
  unsigned __int64 v103; // [rsp+88h] [rbp-40h]

  v6 = a2;
  v7 = a1;
  *(_DWORD *)(a1 + 76) = 0;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  v103 = __readfsqword(0x28u);
  v83 = a3;
  v85 = a4;
  v84 = a5;
  v86 = a6;
  v8 = sub_21450(a2, (unsigned int *)&v101);
  if ( !v8 )
    goto LABEL_17;
  v87 = a1 + 8;
  if ( !(unsigned int)sub_21570(a1 + 8, a2, v8, v101) )
    goto LABEL_17;
  v9 = v101;
  if ( v101 <= 0 )
  {
LABEL_8:
    if ( (unsigned int)sub_20D00(v87, a2, v8, v101, 2) )
    {
      v9 = v101;
      v89 = 0;
      goto LABEL_10;
    }
LABEL_17:
    v12 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    ptr = 0LL;
    goto LABEL_18;
  }
  if ( *(_DWORD *)v8 != 256 )
  {
    v10 = (signed __int64)(v8 + 16);
    while ( (char *)v10 != &v8[16 * (v101 - 1) + 16] )
    {
      v10 += 16LL;
      if ( *(_DWORD *)(v10 - 16) == 256 )
        goto LABEL_20;
    }
    goto LABEL_8;
  }
LABEL_20:
  v89 = 1;
LABEL_10:
  if ( !(unsigned int)sub_20C50(a2, v8, v9, 4, &v99, &v100) )
    goto LABEL_17;
  v11 = sub_207D0((unsigned __int8 **)a2);
  v99 = v11;
  if ( v11 & 0xFFFFFE00 )
    goto LABEL_17;
  v90 = v11 & 0xFFFFFF00 ? (unsigned int)sub_20AE0(a2, v11) : (unsigned int)sub_208E0(a2, v11);
  if ( *(_DWORD *)(a2 + 12) == -1 )
    goto LABEL_17;
  if ( (unsigned int)v90 > 0x5555555 )
  {
    v12 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    pcfError("pcfReadFont(): invalid file format\n");
    ptr = 0LL;
    goto LABEL_18;
  }
  ptr = malloc(24LL * v90);
  if ( !ptr )
  {
    v12 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    pcfError("pcfReadFont(): Couldn't allocate metrics (%d*%d)\n");
    goto LABEL_18;
  }
  if ( v90 )
  {
    v17 = ptr;
    do
    {
      if ( v99 & 0xFFFFFF00 )
      {
        if ( !(unsigned int)sub_211C0(a2, v17) )
        {
LABEL_29:
          v12 = 0LL;
          v14 = 0LL;
          v91 = 0LL;
          goto LABEL_30;
        }
      }
      else if ( !(unsigned int)sub_20BE0(a2, v99, v17) )
      {
        goto LABEL_29;
      }
      v17 += 12;
    }
    while ( v17 != &ptr[12 * (v90 - 1) + 12] );
  }
  if ( !(unsigned int)sub_20C50(a2, v8, v101, 8, &v99, &v100)
    || (v18 = sub_207D0((unsigned __int8 **)a2), v99 = v18, v18 & 0xFFFFFF00)
    || (v94 = sub_208E0(a2, v18), v90 != v94)
    || *(_DWORD *)(a2 + 12) == -1 )
  {
    v12 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    goto LABEL_18;
  }
  v14 = 0LL;
  v12 = (signed int *)malloc(4LL * v90);
  if ( !v12 )
  {
    v13 = 0LL;
    pcfError("pcfReadFont(): Couldn't allocate offsets (%d*%d)\n");
    goto LABEL_18;
  }
  while ( 1 )
  {
    v19 = v99;
    if ( v94 <= (signed int)v14 )
      break;
    v12[(_QWORD)v14] = sub_208E0(v6, v99);
    v14 = (char *)v14 + 1;
    if ( *(_DWORD *)(v6 + 12) == -1 )
    {
LABEL_45:
      v14 = 0LL;
      v91 = 0LL;
LABEL_30:
      v13 = 0LL;
      free(v91);
LABEL_18:
      free(v13);
      free(v14);
      free(ptr);
      free(*(void **)(v7 + 80));
      v15 = *(void **)(v7 + 88);
      *(_DWORD *)(v7 + 76) = 0;
      *(_QWORD *)(v7 + 80) = 0LL;
      free(v15);
      free(v8);
      free(v12);
      return 80LL;
    }
  }
  v20 = v102;
  v21 = 0LL;
  while ( 1 )
  {
    v22 = v20;
    v23 = sub_208E0(v6, v19);
    v24 = *(_DWORD *)(v6 + 12) == -1;
    v20 = v22;
    v22[v21] = v23;
    if ( v24 )
      goto LABEL_45;
    if ( ++v21 == 4 )
      break;
    v19 = v99;
  }
  v25 = v99 & 3;
  v26 = v102[v25];
  if ( v26 )
  {
    v27 = v102[v25];
    v14 = malloc(v26);
    v28 = v27;
    if ( v14 )
      goto LABEL_48;
LABEL_65:
    v13 = 0LL;
    v14 = 0LL;
    pcfError("pcfReadFont(): Couldn't allocate bitmaps (%d)\n");
    goto LABEL_18;
  }
  v14 = malloc(1uLL);
  v28 = 0;
  if ( !v14 )
    goto LABEL_65;
LABEL_48:
  v92 = v28;
  BufFileRead(v6, v14, v28);
  if ( *(_DWORD *)(v6 + 12) == -1 )
  {
LABEL_73:
    v13 = 0LL;
    goto LABEL_18;
  }
  v29 = v99;
  v30 = v92;
  dword_23CCD0 += v92;
  if ( ((v99 >> 3) & 1) != v83 )
  {
    BitOrderInvert((unsigned __int8 *)v14, v92);
    v29 = v99;
    v30 = v92;
  }
  if ( (~((unsigned __int8)(v29 >> 3) ^ (unsigned __int8)(v29 >> 2)) & 1) != (v83 == v85) )
  {
    v31 = v86;
    if ( v83 == v85 )
      v31 = 1 << ((v29 >> 4) & 3);
    if ( v31 == 2 )
    {
      TwoByteSwap((unsigned __int8 *)v14, v30);
      LOBYTE(v29) = v99;
    }
    else if ( v31 == 4 )
    {
      FourByteSwap((unsigned __int8 *)v14, v30);
      LOBYTE(v29) = v99;
    }
  }
  if ( 1 << (v29 & 3) != v84 )
  {
    if ( v84 == 4 )
      v32 = 2LL;
    else
      v32 = v84 == 2;
    v97 = (char *)malloc(v102[v32]);
    if ( !v97 )
    {
      v13 = 0LL;
      pcfError("pcfReadFont(): Couldn't allocate padbitmaps (%d)\n");
      goto LABEL_18;
    }
    v33 = ptr;
    v34 = 0LL;
    v93 = 0;
    while ( v94 > (signed int)v34 )
    {
      v35 = v12[v34];
      v36 = v33[3];
      v37 = v33[4];
      v38 = v33[1];
      v39 = v34;
      v40 = v99 & 3;
      v41 = v33;
      v12[v34] = v93;
      v93 += RepadBitmap((char *)v14 + v35, &v97[v93], 1 << v40, v84, v38 - *v33, v37 + v36);
      v34 = v39 + 1;
      v33 = v41 + 12;
    }
    free(v14);
    v14 = v97;
  }
  v45 = 0LL;
  while ( v94 > (signed int)v45 )
  {
    v46 = (unsigned int)v12[v45];
    v47 = 12 * v45++;
    *(_QWORD *)&ptr[v47 + 8] = (char *)v14 + v46;
  }
  free(v12);
  if ( (unsigned int)sub_20C50(v6, v8, v101, 16, &v99, &v100) )
  {
    v43 = sub_207D0((unsigned __int8 **)v6);
    v42 = v43;
    v99 = v43;
    LOBYTE(v43) = 0;
    if ( v42 & 0xFFFFFE00
      || (v43 ? (v44 = sub_20AE0(v6, v42)) : (v44 = sub_208E0(v6, v42)), *(_DWORD *)(v6 + 12) == -1 || v90 != v44) )
    {
      v12 = 0LL;
      goto LABEL_73;
    }
    v91 = malloc(12LL * v44);
    if ( !v91 )
    {
      v12 = 0LL;
      v13 = 0LL;
      pcfError("pcfReadFont(): Couldn't allocate ink_metrics (%d*%d)\n");
      goto LABEL_18;
    }
    v95 = v7;
    for ( i = 0LL; v44 > (signed int)i; ++i )
    {
      if ( v99 & 0xFFFFFF00 )
      {
        if ( !(unsigned int)sub_211C0(v6, (_WORD *)v91 + 6 * i) )
        {
LABEL_105:
          v7 = v95;
          v12 = 0LL;
          goto LABEL_30;
        }
      }
      else if ( !(unsigned int)sub_20BE0(v6, v99, (_WORD *)v91 + 6 * i) )
      {
        goto LABEL_105;
      }
    }
    v7 = v95;
  }
  else
  {
    v91 = 0LL;
  }
  if ( !(unsigned int)sub_20C50(v6, v8, v101, 32, &v99, &v100) )
    goto LABEL_133;
  v49 = sub_207D0((unsigned __int8 **)v6);
  v99 = v49;
  if ( v49 & 0xFFFFFF00 )
    goto LABEL_133;
  v50 = sub_20AE0(v6, v49);
  v51 = v99;
  *(_WORD *)(v7 + 8) = v50;
  v52 = sub_20AE0(v6, v51);
  v53 = v99;
  *(_WORD *)(v7 + 10) = v52;
  v54 = sub_20AE0(v6, v53);
  v55 = v99;
  *(_WORD *)(v7 + 12) = v54;
  v56 = sub_20AE0(v6, v55);
  v57 = v99;
  *(_WORD *)(v7 + 14) = v56;
  *(_WORD *)(v7 + 16) = sub_20AE0(v6, v57);
  if ( *(_DWORD *)(v6 + 12) == -1
    || (v58 = *(unsigned __int16 *)(v7 + 8),
        v59 = *(unsigned __int16 *)(v7 + 10),
        (unsigned __int16)v58 > (unsigned __int16)v59)
    || (v60 = *(unsigned __int16 *)(v7 + 12),
        v61 = *(unsigned __int16 *)(v7 + 14),
        (unsigned __int16)v60 > (unsigned __int16)v61)
    || (v62 = v59 - v58, v62 > 255) )
  {
LABEL_133:
    v12 = 0LL;
    v13 = 0LL;
    free(v91);
    goto LABEL_18;
  }
  v96 = (v62 + 1) * (v61 - v60 + 1);
  v98 = (v96 + 127) / 128;
  v13 = (char *)calloc(v98, 8uLL);
  if ( !v13 )
  {
    v12 = 0LL;
    pcfError("pcfReadFont(): Couldn't allocate encoding (%d*%d)\n");
    free(v91);
    goto LABEL_18;
  }
  *(_BYTE *)(v7 + 18) |= 0x40u;
  v88 = v8;
  v63 = 0;
  v64 = v7;
  while ( v63 < v96 )
  {
    v65 = sub_20AE0(v6, v99);
    v66 = v65;
    if ( *(_DWORD *)(v6 + 12) == -1 )
      goto LABEL_109;
    if ( v65 == 0xFFFF )
    {
      *(_BYTE *)(v64 + 18) &= 0xBFu;
    }
    else
    {
      v67 = v63 / 128;
      v68 = &v13[8 * v67];
      if ( !*(_QWORD *)v68 )
      {
        v69 = &v13[8 * v67];
        v70 = calloc(0x80uLL, 8uLL);
        v68 = v69;
        *(_QWORD *)v69 = v70;
        if ( !v70 )
        {
LABEL_109:
          v7 = v64;
          v8 = v88;
LABEL_110:
          free(v91);
          if ( v98 > 0 )
          {
            v71 = (void **)v13;
            do
            {
              v72 = *v71;
              ++v71;
              free(v72);
            }
            while ( v71 != (void **)&v13[8 * (v98 - 1) + 8] );
          }
          v12 = 0LL;
          goto LABEL_18;
        }
      }
      *(_QWORD *)(*(_QWORD *)v68 + 8LL * (v63 & 0x7F)) = &ptr[12 * v66];
    }
    ++v63;
  }
  v7 = v64;
  v8 = v88;
  if ( v89 && !(unsigned int)sub_20D00(v87, v6, v88, v101, 256) )
    goto LABEL_110;
  v73 = malloc(0x40uLL);
  if ( !v73 )
  {
    pcfError("pcfReadFont(): Couldn't allocate bitmapFont (%d)\n");
    goto LABEL_110;
  }
  v74 = *(_WORD *)(v7 + 16);
  v75 = v101;
  *(_DWORD *)v73 = 1885562369;
  v73[4] = v14;
  v73[5] = v13;
  *((_DWORD *)v73 + 1) = v90;
  *((_DWORD *)v73 + 2) = v75;
  v73[6] = 0LL;
  v73[2] = ptr;
  v73[3] = v91;
  if ( v74 != -1 )
  {
    v76 = *(unsigned __int16 *)(v7 + 12);
    if ( (unsigned __int16)(v74 >> 8) >= (unsigned __int16)v76 && (unsigned __int16)(v74 >> 8) <= *(_WORD *)(v7 + 14) )
    {
      v77 = *(unsigned __int16 *)(v7 + 8);
      if ( (unsigned __int16)v77 <= (unsigned __int8)v74 )
      {
        v78 = *(unsigned __int16 *)(v7 + 10);
        if ( (unsigned __int16)v78 >= (unsigned __int8)v74 )
        {
          v79 = (unsigned __int8)v74 - v77 + ((v74 >> 8) - v76) * (v78 - v77 + 1);
          v80 = *(_QWORD *)&v13[8 * (v79 >> 7)];
          if ( v80 )
            v81 = *(_QWORD *)(v80 + 8LL * (v79 & 0x7F));
          else
            v81 = 0LL;
          v73[6] = v81;
        }
      }
    }
  }
  v73[7] = 0LL;
  *(_QWORD *)(v7 + 152) = v73;
  *(_QWORD *)(v7 + 128) = 0LL;
  *(_QWORD *)(v7 + 104) = bitmapGetGlyphs;
  *(_QWORD *)(v7 + 112) = bitmapGetMetrics;
  *(_QWORD *)(v7 + 120) = sub_210F0;
  *(_BYTE *)(v7 + 96) = v83;
  *(_BYTE *)(v7 + 97) = v85;
  *(_BYTE *)(v7 + 98) = v84;
  *(_BYTE *)(v7 + 99) = v86;
  free(v88);
  return 85LL;
}
// 8A40: using guessed type __int64 __fastcall pcfError(_QWORD);
// 8DF0: using guessed type __int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD);
// 23CCD0: using guessed type int dword_23CCD0;
// 218E0: using guessed type int var_58[6];

//----- (0000000000022410) ----------------------------------------------------
signed __int64 __fastcall pcfReadFontInfo(unsigned __int16 *a1, unsigned __int8 **a2)
{
  __int64 v2; // r12
  unsigned __int16 *v3; // rbx
  char *v4; // rax
  char *v5; // rbp
  int v6; // edx
  signed __int64 v7; // rax
  signed int v8; // er13
  int v9; // eax
  void *v10; // rdi
  unsigned __int16 v12; // ax
  char v13; // si
  unsigned __int16 v14; // ax
  char v15; // si
  unsigned __int16 v16; // ax
  char v17; // si
  unsigned __int16 v18; // ax
  char v19; // si
  int v20; // ecx
  int v21; // edx
  int v22; // esi
  unsigned __int16 v23; // ax
  int v24; // edx
  int v25; // er14
  int v26; // [rsp+Ch] [rbp-3Ch]
  int v27; // [rsp+10h] [rbp-38h]
  char v28; // [rsp+14h] [rbp-34h]
  unsigned __int64 v29; // [rsp+18h] [rbp-30h]

  v2 = (__int64)a2;
  v3 = a1;
  *((_QWORD *)a1 + 10) = 0LL;
  *((_QWORD *)a1 + 9) = 0LL;
  *((_DWORD *)a1 + 17) = 0;
  v29 = __readfsqword(0x28u);
  v4 = sub_21450((__int64)a2, (unsigned int *)&v26);
  v5 = v4;
  if ( !v4 || !(unsigned int)sub_21570((__int64)a1, (__int64)a2, v4, v26) )
    goto LABEL_12;
  v6 = v26;
  if ( v26 <= 0 )
  {
LABEL_8:
    if ( (unsigned int)sub_20D00((__int64)a1, (__int64)a2, v5, v26, 2) )
    {
      v6 = v26;
      v8 = 0;
      goto LABEL_10;
    }
LABEL_12:
    v10 = (void *)*((_QWORD *)a1 + 9);
    *((_DWORD *)v3 + 17) = 0;
    free(v10);
    free(*((void **)v3 + 10));
    free(v5);
    return 80LL;
  }
  if ( *(_DWORD *)v5 != 256 )
  {
    v7 = (signed __int64)(v5 + 16);
    while ( (char *)v7 != &v5[16 * (v26 - 1) + 16] )
    {
      v7 += 16LL;
      if ( *(_DWORD *)(v7 - 16) == 256 )
        goto LABEL_14;
    }
    goto LABEL_8;
  }
LABEL_14:
  v8 = 1;
LABEL_10:
  if ( !(unsigned int)sub_20C50((__int64)a2, v5, v6, 32, &v27, &v28) )
    goto LABEL_12;
  v9 = sub_207D0(a2);
  v27 = v9;
  if ( v9 & 0xFFFFFF00 )
    goto LABEL_12;
  v12 = sub_20AE0((__int64)a2, v9);
  v13 = v27;
  *a1 = v12;
  v14 = sub_20AE0(v2, v13);
  v15 = v27;
  a1[1] = v14;
  v16 = sub_20AE0(v2, v15);
  v17 = v27;
  a1[2] = v16;
  v18 = sub_20AE0(v2, v17);
  v19 = v27;
  a1[3] = v18;
  a1[4] = sub_20AE0(v2, v19);
  if ( *(_DWORD *)(v2 + 12) == -1 )
    goto LABEL_12;
  v20 = *a1;
  v21 = a1[1];
  if ( (unsigned __int16)v20 > (unsigned __int16)v21 )
    goto LABEL_12;
  v22 = a1[2];
  v23 = a1[3];
  if ( (unsigned __int16)v22 > v23 )
    goto LABEL_12;
  v24 = v21 - v20;
  if ( v24 > 255 )
    goto LABEL_12;
  *((_BYTE *)a1 + 10) |= 0x40u;
  v25 = (v24 + 1) * (v23 - v22 + 1);
  while ( v25 )
  {
    if ( (unsigned int)sub_20AE0(v2, v27) == 0xFFFF )
      *((_BYTE *)a1 + 10) &= 0xBFu;
    --v25;
    if ( *(_DWORD *)(v2 + 12) == -1 )
      goto LABEL_12;
  }
  if ( *(_DWORD *)(v2 + 12) == -1 || v8 && !(unsigned int)sub_20D00((__int64)a1, v2, v5, v26, 256) )
    goto LABEL_12;
  free(v5);
  return 85LL;
}

//----- (0000000000022690) ----------------------------------------------------
__int64 __fastcall sub_22690(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbx
  bool v3; // zf
  int v4; // edi
  int v5; // edi
  int v6; // eax
  __int64 v7; // rdi
  _BYTE *v9; // rax
  _BYTE *v10; // rax
  _BYTE *v11; // rax
  _BYTE *v12; // rax

  v2 = a1;
  dword_23CCD4 += 4;
  v3 = (*(_DWORD *)(a1 + 8))-- == 1;
  if ( v3 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))((unsigned __int8)a2, a1);
  }
  else
  {
    v9 = (_BYTE *)(*(_QWORD *)a1)++;
    *v9 = a2;
  }
  v4 = (signed int)a2 >> 8;
  v3 = (*(_DWORD *)(v2 + 8))-- == 1;
  if ( v3 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(v2 + 8216))((unsigned __int8)v4, v2);
  }
  else
  {
    v10 = (_BYTE *)(*(_QWORD *)v2)++;
    *v10 = v4;
  }
  v5 = (signed int)a2 >> 16;
  v3 = (*(_DWORD *)(v2 + 8))-- == 1;
  if ( v3 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(v2 + 8216))((unsigned __int8)v5, v2);
  }
  else
  {
    v11 = (_BYTE *)(*(_QWORD *)v2)++;
    *v11 = v5;
  }
  v6 = *(_DWORD *)(v2 + 8);
  v7 = a2 >> 24;
  *(_DWORD *)(v2 + 8) = v6 - 1;
  if ( v6 == 1 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(v2 + 8216))(v7, v2);
  v12 = (_BYTE *)(*(_QWORD *)v2)++;
  *v12 = HIBYTE(a2);
  return (unsigned int)v7;
}
// 23CCD4: using guessed type int dword_23CCD4;

//----- (0000000000022770) ----------------------------------------------------
__int64 __fastcall sub_22770(__int64 a1, char a2, unsigned int a3)
{
  unsigned int v3; // ebp
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  bool v7; // zf
  int v8; // eax
  __int64 v9; // rdi
  _BYTE *v10; // rax
  int v12; // eax
  _BYTE *v13; // rax
  _BYTE *v14; // rax
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  _BYTE *v17; // rax
  _BYTE *v18; // rax
  _BYTE *v19; // rax

  v3 = a3;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 8);
  dword_23CCD4 += 4;
  v6 = v5 - 1;
  *(_DWORD *)(a1 + 8) = v6;
  if ( a2 & 4 )
  {
    if ( v6 )
    {
      v13 = (_BYTE *)(*(_QWORD *)a1)++;
      *v13 = HIBYTE(a3);
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(a3 >> 24, a1);
    }
    v7 = (*(_DWORD *)(a1 + 8))-- == 1;
    if ( v7 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(BYTE2(v3), a1);
    }
    else
    {
      v16 = (_BYTE *)(*(_QWORD *)a1)++;
      *v16 = BYTE2(v3);
    }
    v7 = (*(_DWORD *)(a1 + 8))-- == 1;
    if ( v7 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(BYTE1(v3), a1);
    }
    else
    {
      v15 = (_BYTE *)(*(_QWORD *)a1)++;
      *v15 = BYTE1(v3);
    }
    v8 = *(_DWORD *)(a1 + 8);
    v9 = (unsigned __int8)v3;
    *(_DWORD *)(v4 + 8) = v8 - 1;
    if ( v8 != 1 )
    {
      v10 = (_BYTE *)(*(_QWORD *)v4)++;
      *v10 = v3;
      return (unsigned int)v9;
    }
  }
  else
  {
    if ( v6 )
    {
      v14 = (_BYTE *)(*(_QWORD *)a1)++;
      *v14 = a3;
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))((unsigned __int8)a3, a1);
    }
    v7 = (*(_DWORD *)(a1 + 8))-- == 1;
    if ( v7 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(BYTE1(v3), a1);
    }
    else
    {
      v18 = (_BYTE *)(*(_QWORD *)a1)++;
      *v18 = BYTE1(v3);
    }
    v7 = (*(_DWORD *)(a1 + 8))-- == 1;
    if ( v7 )
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(BYTE2(v3), a1);
    }
    else
    {
      v17 = (_BYTE *)(*(_QWORD *)a1)++;
      *v17 = BYTE2(v3);
    }
    v12 = *(_DWORD *)(a1 + 8);
    v9 = v3 >> 24;
    *(_DWORD *)(v4 + 8) = v12 - 1;
    if ( v12 != 1 )
    {
      v19 = (_BYTE *)(*(_QWORD *)v4)++;
      *v19 = HIBYTE(v3);
      return (unsigned int)v9;
    }
  }
  return (*(__int64 (__fastcall **)(__int64, __int64))(v4 + 8216))(v9, v4);
}
// 23CCD4: using guessed type int dword_23CCD4;

//----- (0000000000022950) ----------------------------------------------------
__int64 __fastcall sub_22950(__int64 a1, char a2, int a3)
{
  int v3; // eax
  int v4; // er12
  __int64 v5; // rbx
  unsigned __int8 v6; // bp
  int v7; // eax
  int v8; // eax
  __int64 v9; // rdi
  unsigned __int8 *v10; // rax
  int v12; // eax
  _BYTE *v13; // rax
  _BYTE *v14; // rax
  _BYTE *v15; // rax

  v3 = *(_DWORD *)(a1 + 8);
  v4 = a3 >> 8;
  dword_23CCD4 += 2;
  v5 = a1;
  v6 = a3;
  v7 = v3 - 1;
  *(_DWORD *)(a1 + 8) = v7;
  if ( a2 & 4 )
  {
    if ( v7 )
    {
      v13 = (_BYTE *)(*(_QWORD *)a1)++;
      *v13 = BYTE1(a3);
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(BYTE1(a3), a1);
    }
    v8 = *(_DWORD *)(a1 + 8);
    v9 = v6;
    *(_DWORD *)(v5 + 8) = v8 - 1;
    if ( v8 != 1 )
    {
      v10 = (unsigned __int8 *)(*(_QWORD *)v5)++;
      *v10 = v6;
      return (unsigned int)v9;
    }
  }
  else
  {
    if ( v7 )
    {
      v14 = (_BYTE *)(*(_QWORD *)a1)++;
      *v14 = a3;
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))((unsigned __int8)a3, a1);
    }
    v12 = *(_DWORD *)(a1 + 8);
    v9 = (unsigned __int8)v4;
    *(_DWORD *)(v5 + 8) = v12 - 1;
    if ( v12 != 1 )
    {
      v15 = (_BYTE *)(*(_QWORD *)v5)++;
      *v15 = v4;
      return (unsigned int)v9;
    }
  }
  return (*(__int64 (__fastcall **)(__int64, __int64))(v5 + 8216))(v9, v5);
}
// 23CCD4: using guessed type int dword_23CCD4;

//----- (0000000000022A20) ----------------------------------------------------
__int64 __fastcall sub_22A20(__int64 a1, char a2, signed __int16 *a3)
{
  signed __int16 *v3; // r12

  v3 = a3;
  sub_22950(a1, a2, *a3);
  sub_22950(a1, a2, v3[1]);
  sub_22950(a1, a2, v3[2]);
  sub_22950(a1, a2, v3[3]);
  sub_22950(a1, a2, v3[4]);
  return sub_22950(a1, a2, (unsigned __int16)v3[5]);
}

//----- (0000000000022A90) ----------------------------------------------------
__int64 __fastcall sub_22A90(__int64 a1, unsigned __int8 a2)
{
  int v2; // eax
  unsigned __int8 *v4; // rax

  v2 = *(_DWORD *)(a1 + 8);
  ++dword_23CCD4;
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 == 1 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8216))(a2, a1);
  v4 = (unsigned __int8 *)(*(_QWORD *)a1)++;
  *v4 = a2;
  return a2;
}
// 23CCD4: using guessed type int dword_23CCD4;

//----- (0000000000022AD0) ----------------------------------------------------
char __fastcall sub_22AD0(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // rbp
  bool v4; // zf
  int v5; // eax
  _BYTE *v6; // rax

  v3 = a3;
  sub_22A90(a1, *(_BYTE *)(a3 + 10) & 1);
  sub_22A90(a1, (*(_BYTE *)(v3 + 10) >> 2) & 1);
  sub_22A90(a1, (*(_BYTE *)(v3 + 10) >> 1) & 1);
  sub_22A90(a1, (*(_BYTE *)(v3 + 10) >> 3) & 1);
  sub_22A90(a1, (*(_BYTE *)(v3 + 10) >> 4) & 1);
  sub_22A90(a1, (*(_BYTE *)(v3 + 10) >> 5) & 1);
  sub_22A90(a1, (*(_WORD *)(v3 + 10) >> 7) & 3);
  ++dword_23CCD4;
  v4 = (*(_DWORD *)(a1 + 8))-- == 1;
  if ( v4 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(a1 + 8216))(0LL, a1);
  }
  else
  {
    v6 = (_BYTE *)(*(_QWORD *)a1)++;
    *v6 = 0;
  }
  sub_22770(a1, a2, *(signed __int16 *)(v3 + 64));
  sub_22770(a1, a2, *(signed __int16 *)(v3 + 66));
  sub_22770(a1, a2, *(signed __int16 *)(v3 + 12));
  sub_22A20(a1, a2, (signed __int16 *)(v3 + 28));
  sub_22A20(a1, a2, (signed __int16 *)(v3 + 16));
  v5 = a2;
  LOBYTE(v5) = 0;
  if ( v5 == 256 )
  {
    sub_22A20(a1, a2, (signed __int16 *)(v3 + 52));
    LOBYTE(v5) = sub_22A20(a1, a2, (signed __int16 *)(v3 + 40));
  }
  return v5;
}
// 23CCD4: using guessed type int dword_23CCD4;

//----- (0000000000022C20) ----------------------------------------------------
__int64 __fastcall sub_22C20(__int64 a1, unsigned __int16 *a2)
{
  sub_22A90(a1, *a2 + -128);
  sub_22A90(a1, a2[1] + -128);
  sub_22A90(a1, a2[2] + -128);
  sub_22A90(a1, a2[3] + -128);
  return sub_22A90(a1, (unsigned __int8)a2[4] + -128);
}

//----- (0000000000022C80) ----------------------------------------------------
signed __int64 __fastcall pcfWriteFont(__int64 a1, __int64 a2)
{
  __int64 v2; // r12
  __int64 v3; // r14
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rbp
  signed int v7; // ebx
  _QWORD *v8; // r13
  signed __int64 v9; // r14
  char *v10; // rax
  char *v11; // rax
  char v12; // dl
  int v13; // eax
  char v14; // cl
  signed int v15; // edx
  int v16; // eax
  __int64 v17; // rbx
  char *v18; // r14
  signed int v19; // er13
  unsigned int v20; // eax
  char *v21; // r13
  __int64 v22; // r14
  __int64 v23; // r15
  int v24; // edx
  signed __int64 v25; // rbx
  char *v26; // rax
  signed __int64 v27; // r13
  char *v28; // rbp
  unsigned int v29; // esi
  unsigned int v30; // ecx
  unsigned int v31; // edx
  char *v32; // rbp
  unsigned int v33; // eax
  __int64 v34; // rbp
  int v35; // er12
  __int64 v36; // r13
  unsigned int v37; // er14
  int v38; // ebx
  unsigned int v39; // eax
  signed __int16 *v40; // rdi
  int v41; // edx
  int v42; // ebx
  __int64 v43; // rdx
  __int64 v44; // r13
  int v45; // ebp
  signed __int16 *v46; // rsi
  __int64 v47; // r12
  int v48; // eax
  unsigned int v49; // eax
  __int64 v50; // rbx
  __int64 v51; // rbx
  _BYTE *v53; // rax
  bool v54; // zf
  int v55; // eax
  __int64 v56; // rax
  __int64 v57; // r12
  int v58; // ebx
  __int64 v59; // r14
  __int64 v60; // rax
  __int64 v61; // rdx
  __int64 v62; // rax
  __int64 v63; // rbx
  unsigned int *v64; // rbp
  unsigned int v65; // edx
  int v66; // ebx
  __int64 v67; // rbx
  char *v68; // r13
  char *v69; // r13
  int v70; // edx
  unsigned int v71; // eax
  int v72; // edx
  int v73; // esi
  __int64 v74; // rax
  __int64 v75; // r13
  __int64 v76; // r12
  int v77; // ebx
  __int64 v78; // r14
  unsigned int v79; // edx
  __int64 v80; // rax
  int v81; // eax
  unsigned int v82; // edx
  __int64 v83; // rax
  __int64 v84; // r13
  __int64 v85; // r12
  int v86; // ebx
  __int64 v87; // r14
  signed __int16 *v88; // rdx
  __int64 v89; // rax
  int v90; // eax
  unsigned int v91; // edx
  __int64 v92; // rax
  __int64 v93; // r13
  __int64 v94; // r12
  int v95; // ebx
  __int64 v96; // r14
  signed __int16 *v97; // rdx
  __int64 v98; // rax
  unsigned int v99; // ebp
  __int64 v100; // r13
  int v101; // er12
  Atom v102; // rdi
  char *v103; // rax
  unsigned int v104; // ebx
  unsigned int v105; // edx
  __int64 v106; // rbx
  char *v107; // r13
  _BYTE *v108; // rax
  signed int v109; // eax
  __int64 v110; // rbp
  int v111; // er15
  char *v112; // rax
  unsigned int v113; // esi
  _WORD *v114; // rcx
  _BYTE *v115; // rax
  __int64 v116; // r13
  int v117; // ebx
  unsigned __int16 *v118; // rsi
  __int64 v119; // r13
  int v120; // ebx
  unsigned __int16 *v121; // rsi
  __int64 v122; // [rsp+0h] [rbp-2A8h]
  int v123; // [rsp+0h] [rbp-2A8h]
  int v124; // [rsp+8h] [rbp-2A0h]
  char *v125; // [rsp+8h] [rbp-2A0h]
  int v126; // [rsp+10h] [rbp-298h]
  char *v127; // [rsp+10h] [rbp-298h]
  char *v128; // [rsp+10h] [rbp-298h]
  _QWORD *ptr; // [rsp+18h] [rbp-290h]
  unsigned int v130; // [rsp+24h] [rbp-284h]
  int v131; // [rsp+28h] [rbp-280h]
  int v132; // [rsp+2Ch] [rbp-27Ch]
  __int64 v133; // [rsp+30h] [rbp-278h]
  char *v134; // [rsp+30h] [rbp-278h]
  char *v135; // [rsp+30h] [rbp-278h]
  __int64 v136; // [rsp+30h] [rbp-278h]
  _WORD *v137; // [rsp+38h] [rbp-270h]
  __int64 v138; // [rsp+38h] [rbp-270h]
  __int64 v139; // [rsp+38h] [rbp-270h]
  _WORD *v140; // [rsp+40h] [rbp-268h]
  signed __int64 v141; // [rsp+48h] [rbp-260h]
  signed __int64 v142; // [rsp+50h] [rbp-258h]
  char v143[12]; // [rsp+60h] [rbp-248h]
  char v144[12]; // [rsp+68h] [rbp-240h]
  __int64 v145; // [rsp+70h] [rbp-238h]
  unsigned __int64 v146; // [rsp+268h] [rbp-40h]

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 152);
  v146 = __readfsqword(0x28u);
  v4 = *(_QWORD *)(v3 + 56);
  if ( v4 )
  {
    v137 = (_WORD *)(v4 + 60);
    v141 = v4 + 48;
    v142 = v4 + 72;
    v140 = (_WORD *)(v4 + 84);
  }
  else
  {
    v137 = (_WORD *)(a1 + 36);
    v141 = a1 + 24;
    v140 = (_WORD *)(a1 + 60);
    v142 = a1 + 48;
  }
  v5 = *(signed int *)(a1 + 76);
  ptr = malloc(16 * v5);
  if ( !ptr )
  {
    pcfError("pcfWriteFont(): Couldn't allocate offsetProps (%d*%d)");
    return 80LL;
  }
  if ( (signed int)v5 <= 0 )
  {
    v130 = 0;
  }
  else
  {
    v6 = 0LL;
    v7 = 0;
    v122 = v3;
    v8 = ptr + 1;
    do
    {
      *(v8 - 1) = v7;
      v9 = 16 * v6;
      v10 = NameForAtom(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16 * v6));
      v7 += strlen(v10) + 1;
      if ( *(_BYTE *)(*(_QWORD *)(a1 + 88) + v6) )
      {
        *v8 = v7;
        v11 = NameForAtom(*(_QWORD *)(*(_QWORD *)(a1 + 80) + v9 + 8));
        v7 += strlen(v11) + 1;
      }
      else
      {
        *v8 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + v9 + 8);
      }
      v8 += 2;
      ++v6;
    }
    while ( *(_DWORD *)(a1 + 76) > (signed int)v6 );
    v3 = v122;
    v130 = v7;
  }
  v12 = *(_BYTE *)(a1 + 99);
  v13 = 32;
  if ( v12 != 4 )
    v13 = 16 * (v12 == 2);
  if ( *(_BYTE *)(a1 + 96) == 1 )
    v13 |= 8u;
  if ( *(_BYTE *)(a1 + 97) == 1 )
    v13 |= 4u;
  v14 = *(_BYTE *)(a1 + 98);
  v15 = 2;
  if ( v14 != 4 )
    v15 = v14 == 2;
  v16 = v13 | v15;
  v123 = v16;
  v131 = 0;
  BYTE1(v16) |= 1u;
  v132 = 0;
  v124 = v16;
  v133 = a2;
  v17 = v3;
  v18 = v143;
  v19 = 0xFFFFFFF;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v20 = v19 & -v19;
            *(_DWORD *)v18 = v20;
            v19 &= ~v20;
            if ( v20 != 16 )
              break;
            if ( !*(_QWORD *)(v17 + 24) )
              goto LABEL_27;
            if ( (unsigned __int16)(*v140 + 128) > 0xFFu
              || (unsigned __int16)(v140[1] + 128) > 0xFFu
              || (unsigned __int16)(v140[2] + 128) > 0xFFu
              || (unsigned __int16)(v140[3] + 128) > 0xFFu
              || (unsigned __int16)(v140[4] + 128) > 0xFFu
              || v140[5] )
            {
              goto LABEL_163;
            }
            v114 = (_WORD *)v142;
LABEL_183:
            if ( (unsigned __int16)(*v114 + 128) <= 0xFFu
              && (unsigned __int16)(v114[1] + 128) <= 0xFFu
              && (unsigned __int16)(v114[2] + 128) <= 0xFFu
              && (unsigned __int16)(v114[3] + 128) <= 0xFFu
              && (unsigned __int16)(v114[4] + 128) <= 0xFFu
              && !v114[5] )
            {
              *((_DWORD *)v18 + 1) = v124;
              *((_DWORD *)v18 + 2) = (5 * *(_DWORD *)(v17 + 4) + 9) & 0xFFFFFFFC;
              goto LABEL_85;
            }
LABEL_163:
            *((_DWORD *)v18 + 1) = v123;
            *((_DWORD *)v18 + 2) = 12 * *(_DWORD *)(v17 + 4) + 8;
LABEL_85:
            v18 += 16;
            if ( !v19 )
              goto LABEL_28;
          }
          if ( v20 > 0x10 )
            break;
          if ( v20 == 2 )
          {
            v54 = (*(_BYTE *)(*(_QWORD *)(v17 + 56) + 42LL) & 0x20) == 0;
            goto LABEL_82;
          }
          if ( v20 > 2 )
          {
            if ( v20 != 4 )
            {
              if ( v20 == 8 )
              {
                v18 += 16;
                *((_DWORD *)v18 - 3) = v123;
                *((_DWORD *)v18 - 2) = (*(_DWORD *)(*(_QWORD *)(v17 + 56) + 4LL * (v123 & 3) + 16)
                                      + 4 * *(_DWORD *)(v17 + 4)
                                      + 27) & 0xFFFFFFFC;
              }
              goto LABEL_27;
            }
            if ( (unsigned __int16)(*v137 + 128) > 0xFFu
              || (unsigned __int16)(v137[1] + 128) > 0xFFu
              || (unsigned __int16)(v137[2] + 128) > 0xFFu
              || (unsigned __int16)(v137[3] + 128) > 0xFFu
              || (unsigned __int16)(v137[4] + 128) > 0xFFu
              || v137[5] )
            {
              goto LABEL_163;
            }
            v114 = (_WORD *)v141;
            goto LABEL_183;
          }
          if ( v20 == 1 )
          {
            v18 += 16;
            *((_DWORD *)v18 - 3) = v123;
            v70 = 9 * *(_DWORD *)(a1 + 76);
            v71 = (v70 + 11) & 0xFFFFFFFC;
            v131 = v71 - (v70 + 8);
            *((_DWORD *)v18 - 2) = v71 + ((v130 + 3) & 0xFFFFFFFC) + 4;
            if ( !v19 )
              goto LABEL_28;
          }
          else
          {
LABEL_27:
            if ( !v19 )
              goto LABEL_28;
          }
        }
        if ( v20 != 64 )
          break;
        v18 += 16;
        *((_DWORD *)v18 - 3) = v123;
        *((_DWORD *)v18 - 2) = 4 * *(_DWORD *)(v17 + 4) + 8;
        if ( !v19 )
          goto LABEL_28;
      }
      if ( v20 > 0x40 )
        break;
      if ( v20 != 32 )
        goto LABEL_27;
      v72 = *(unsigned __int16 *)(a1 + 14);
      v18 += 16;
      v73 = *(unsigned __int16 *)(a1 + 8);
      *((_DWORD *)v18 - 3) = v123;
      v132 = (*(unsigned __int16 *)(a1 + 10) - v73 + 1) * (v72 - *(unsigned __int16 *)(a1 + 12) + 1);
      *((_DWORD *)v18 - 2) = (2 * v132 + 17) & 0xFFFFFFFC;
      if ( !v19 )
        goto LABEL_28;
    }
    if ( v20 != 128 )
    {
      if ( v20 != 256 )
        goto LABEL_27;
      v54 = (*(_BYTE *)(a1 + 18) & 0x20) == 0;
LABEL_82:
      v55 = v123;
      if ( !v54 )
        v55 = v124;
      *((_DWORD *)v18 + 2) = 100;
      *((_DWORD *)v18 + 1) = v55;
      goto LABEL_85;
    }
    *((_DWORD *)v18 + 1) = v123;
    v109 = *(_DWORD *)(v17 + 4);
    if ( v109 <= 0 )
    {
      v113 = 0;
    }
    else
    {
      v110 = 0LL;
      v111 = 0;
      do
      {
        v112 = NameForAtom(*(_QWORD *)(**(_QWORD **)(v17 + 56) + 8 * v110));
        v111 += strlen(v112) + 1;
        v109 = *(_DWORD *)(v17 + 4);
        ++v110;
      }
      while ( v109 > (signed int)v110 );
      v113 = (v111 + 3) & 0xFFFFFFFC;
    }
    v18 += 16;
    *((_DWORD *)v18 - 2) = v113 + 4 * v109 + 12;
  }
  while ( v19 );
LABEL_28:
  v21 = v18;
  v22 = v17;
  v23 = v133;
  v24 = (_DWORD)v21 - (unsigned __int64)v143 + 8;
  v25 = (v21 - v143) >> 4;
  if ( (signed int)v25 > 0 )
  {
    v26 = v144;
    v27 = 16LL * (unsigned int)(v25 - 1);
    do
    {
      *((_DWORD *)v26 + 1) = v24;
      v24 += *(_DWORD *)v26;
      v26 += 16;
    }
    while ( &v143[v27 + 24] != v26 );
    dword_23CCD4 = 0;
    sub_22690(v133, 0x70636601u);
    sub_22690(v133, v25);
    v28 = v143;
    do
    {
      v29 = *(_DWORD *)v28;
      v28 += 16;
      sub_22690(v133, v29);
      sub_22690(v133, *((_DWORD *)v28 - 3));
      sub_22690(v133, *((_DWORD *)v28 - 2));
      sub_22690(v133, *((_DWORD *)v28 - 1));
    }
    while ( &v143[v27 + 16] != v28 );
    v30 = *(_DWORD *)&v144[4];
    v31 = dword_23CCD4;
    v125 = v28;
    if ( *(_DWORD *)&v144[4] < (unsigned int)dword_23CCD4 )
    {
LABEL_68:
      __printf_chk(1LL, "can't go backwards... %d > %d\n");
      free(ptr);
      return 83LL;
    }
    v32 = (char *)&v145;
    while ( 2 )
    {
      while ( v30 > v31 )
      {
        ++v31;
        v54 = (*(_DWORD *)(v23 + 8))-- == 1;
        dword_23CCD4 = v31;
        if ( v54 )
        {
          (*(void (__fastcall **)(_QWORD, __int64))(v23 + 8216))(0LL, v23);
          v31 = dword_23CCD4;
        }
        else
        {
          v53 = (_BYTE *)(*(_QWORD *)v23)++;
          *v53 = 0;
        }
        v30 = *((_DWORD *)v32 - 1);
      }
      sub_22690(v23, *((_DWORD *)v32 - 3));
      v33 = *((_DWORD *)v32 - 4);
      if ( v33 == 16 )
      {
        v81 = *((_DWORD *)v32 - 3);
        v82 = *(_DWORD *)(v22 + 4);
        LOBYTE(v81) = 0;
        if ( v81 == 256 )
        {
          sub_22950(v23, v123, v82);
          if ( *(_DWORD *)(v22 + 4) > 0 )
          {
            v119 = 0LL;
            v120 = 0;
            do
            {
              ++v120;
              v121 = (unsigned __int16 *)(v119 + *(_QWORD *)(v22 + 24));
              v119 += 12LL;
              sub_22C20(v23, v121);
            }
            while ( *(_DWORD *)(v22 + 4) > v120 );
          }
        }
        else
        {
          sub_22770(v23, v123, v82);
          if ( *(_DWORD *)(v22 + 4) > 0 )
          {
            v83 = v2;
            v84 = 0LL;
            v85 = v22;
            v86 = 0;
            v87 = v83;
            do
            {
              ++v86;
              v88 = (signed __int16 *)(v84 + *(_QWORD *)(v85 + 24));
              v84 += 12LL;
              sub_22A20(v23, v123, v88);
            }
            while ( *(_DWORD *)(v85 + 4) > v86 );
            v89 = v87;
            v22 = v85;
            v2 = v89;
          }
        }
      }
      else
      {
        if ( v33 <= 0x10 )
        {
          if ( v33 == 2 )
          {
            sub_22AD0(v23, *((_DWORD *)v32 - 3), *(_QWORD *)(v22 + 56) + 32LL);
          }
          else if ( v33 <= 2 )
          {
            if ( v33 == 1 )
            {
              sub_22770(v23, v123, *(_DWORD *)(v2 + 76));
              if ( *(_DWORD *)(v2 + 76) > 0 )
              {
                v127 = v32;
                v63 = 0LL;
                v64 = (unsigned int *)ptr;
                do
                {
                  v65 = *v64;
                  v64 += 4;
                  sub_22770(v23, v123, v65);
                  sub_22A90(v23, *(_BYTE *)(*(_QWORD *)(v2 + 88) + v63));
                  sub_22770(v23, v123, *(v64 - 2));
                  ++v63;
                }
                while ( *(_DWORD *)(v2 + 76) > (signed int)v63 );
                v32 = v127;
              }
              if ( v131 > 0 )
              {
                v66 = 0;
                do
                {
                  ++dword_23CCD4;
                  v54 = (*(_DWORD *)(v23 + 8))-- == 1;
                  if ( v54 )
                  {
                    (*(void (__fastcall **)(_QWORD, __int64))(v23 + 8216))(0LL, v23);
                  }
                  else
                  {
                    v115 = (_BYTE *)(*(_QWORD *)v23)++;
                    *v115 = 0;
                  }
                  ++v66;
                }
                while ( v131 != v66 );
              }
              v67 = 0LL;
              sub_22770(v23, v123, v130);
              if ( *(_DWORD *)(v2 + 76) > 0 )
              {
                do
                {
                  while ( 1 )
                  {
                    v68 = NameForAtom(*(_QWORD *)(*(_QWORD *)(v2 + 80) + 16 * v67));
                    dword_23CCD4 += strlen(v68) + 1;
                    BufFileWrite(v23, v68);
                    if ( *(_BYTE *)(*(_QWORD *)(v2 + 88) + v67) )
                      break;
                    if ( *(_DWORD *)(v2 + 76) <= (signed int)++v67 )
                      goto LABEL_66;
                  }
                  v69 = NameForAtom(*(_QWORD *)(*(_QWORD *)(v2 + 80) + 16 * v67 + 8));
                  dword_23CCD4 += strlen(v69) + 1;
                  BufFileWrite(v23, v69);
                  ++v67;
                }
                while ( *(_DWORD *)(v2 + 76) > (signed int)v67 );
              }
            }
          }
          else if ( v33 == 4 )
          {
            v90 = *((_DWORD *)v32 - 3);
            v91 = *(_DWORD *)(v22 + 4);
            LOBYTE(v90) = 0;
            if ( v90 == 256 )
            {
              sub_22950(v23, v123, v91);
              if ( *(_DWORD *)(v22 + 4) > 0 )
              {
                v116 = 0LL;
                v117 = 0;
                do
                {
                  ++v117;
                  v118 = (unsigned __int16 *)(v116 + *(_QWORD *)(v22 + 16));
                  v116 += 24LL;
                  sub_22C20(v23, v118);
                }
                while ( *(_DWORD *)(v22 + 4) > v117 );
              }
            }
            else
            {
              sub_22770(v23, v123, v91);
              if ( *(_DWORD *)(v22 + 4) > 0 )
              {
                v92 = v2;
                v93 = 0LL;
                v94 = v22;
                v95 = 0;
                v96 = v92;
                do
                {
                  ++v95;
                  v97 = (signed __int16 *)(v93 + *(_QWORD *)(v94 + 16));
                  v93 += 24LL;
                  sub_22A20(v23, v123, v97);
                }
                while ( *(_DWORD *)(v94 + 4) > v95 );
                v98 = v96;
                v22 = v94;
                v2 = v98;
              }
            }
          }
          else if ( v33 == 8 )
          {
            sub_22770(v23, v123, *(_DWORD *)(v22 + 4));
            v126 = v123 & 3;
            if ( *(_DWORD *)(v22 + 4) > 0 )
            {
              v134 = v32;
              v138 = v2;
              v34 = v22;
              v35 = 0;
              v36 = 0LL;
              v37 = 0;
              v38 = v123 & 3;
              do
              {
                sub_22770(v23, v123, v37);
                v40 = (signed __int16 *)(v36 + *(_QWORD *)(v34 + 16));
                if ( v123 & 3 )
                {
                  v41 = v40[1] - *v40;
                  if ( v38 == 1 )
                  {
                    v39 = ((v41 + 15) >> 3) & 0xFFFFFFFE;
                  }
                  else if ( v38 == 2 )
                  {
                    v39 = ((v41 + 31) >> 3) & 0xFFFFFFFC;
                  }
                  else
                  {
                    v39 = ((v41 + 63) >> 3) & 0xFFFFFFF8;
                  }
                }
                else
                {
                  v39 = (v40[1] - *v40 + 7) >> 3;
                }
                ++v35;
                v36 += 24LL;
                v37 += (v40[4] + v40[3]) * v39;
              }
              while ( *(_DWORD *)(v34 + 4) > v35 );
              v22 = v34;
              v2 = v138;
              v32 = v134;
            }
            v42 = 0;
            do
            {
              v43 = v42++;
              sub_22770(v23, v123, *(_DWORD *)(*(_QWORD *)(v22 + 56) + 4 * v43 + 16));
            }
            while ( v42 != 4 );
            if ( *(_DWORD *)(v22 + 4) > 0 )
            {
              v135 = v32;
              v44 = 0LL;
              v45 = 0;
              v139 = v2;
              do
              {
                v46 = (signed __int16 *)(v44 + *(_QWORD *)(v22 + 16));
                v47 = *((_QWORD *)v46 + 2);
                v48 = v46[1] - *v46;
                if ( v123 & 3 )
                {
                  if ( v126 == 1 )
                  {
                    v49 = ((v48 + 15) >> 3) & 0xFFFFFFFE;
                  }
                  else if ( v126 == 2 )
                  {
                    v49 = ((v48 + 31) >> 3) & 0xFFFFFFFC;
                  }
                  else
                  {
                    v49 = ((v48 + 63) >> 3) & 0xFFFFFFF8;
                  }
                }
                else
                {
                  v49 = (v48 + 7) >> 3;
                }
                v50 = v49 * (v46[4] + v46[3]);
                dword_23CCD4 += v50;
                v51 = v47 + v50;
                while ( v47 != v51 )
                {
                  while ( 1 )
                  {
                    ++v47;
                    v54 = (*(_DWORD *)(v23 + 8))-- == 1;
                    if ( !v54 )
                      break;
                    (*(void (__fastcall **)(_QWORD, __int64))(v23 + 8216))(*(unsigned __int8 *)(v47 - 1), v23);
                    if ( v47 == v51 )
                      goto LABEL_64;
                  }
                  v108 = (_BYTE *)(*(_QWORD *)v23)++;
                  *v108 = *(_BYTE *)(v47 - 1);
                }
LABEL_64:
                ++v45;
                v44 += 24LL;
              }
              while ( *(_DWORD *)(v22 + 4) > v45 );
              v32 = v135;
              v2 = v139;
            }
          }
          goto LABEL_66;
        }
        if ( v33 == 64 )
        {
          sub_22770(v23, v123, *(_DWORD *)(v22 + 4));
          if ( *(_DWORD *)(v22 + 4) > 0 )
          {
            v74 = v2;
            v75 = 0LL;
            v76 = v22;
            v77 = 0;
            v78 = v74;
            do
            {
              ++v77;
              v79 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v76 + 56) + 8LL) + v75);
              v75 += 4LL;
              sub_22770(v23, v123, v79);
            }
            while ( *(_DWORD *)(v76 + 4) > v77 );
            v80 = v78;
            v22 = v76;
            v2 = v80;
          }
        }
        else
        {
          if ( v33 <= 0x40 )
          {
            if ( v33 == 32 )
            {
              sub_22950(v23, v123, *(unsigned __int16 *)(v2 + 8));
              sub_22950(v23, v123, *(unsigned __int16 *)(v2 + 10));
              sub_22950(v23, v123, *(unsigned __int16 *)(v2 + 12));
              sub_22950(v23, v123, *(unsigned __int16 *)(v2 + 14));
              sub_22950(v23, v123, *(unsigned __int16 *)(v2 + 16));
              if ( v132 > 0 )
              {
                v56 = v2;
                v57 = v22;
                v58 = 0;
                v59 = v56;
                do
                {
                  while ( 1 )
                  {
                    v60 = *(_QWORD *)(*(_QWORD *)(v57 + 40) + 8LL * (v58 >> 7));
                    if ( !v60 )
                      break;
                    v61 = *(_QWORD *)(v60 + 8LL * (v58 & 0x7F));
                    if ( !v61 )
                      break;
                    ++v58;
                    sub_22950(v23, v123, -1431655765 * (unsigned __int64)((v61 - *(_QWORD *)(v57 + 16)) >> 3));
                    if ( v58 == v132 )
                      goto LABEL_94;
                  }
                  ++v58;
                  sub_22950(v23, v123, 0xFFFF);
                }
                while ( v58 != v132 );
LABEL_94:
                v62 = v59;
                v22 = v57;
                v2 = v62;
              }
            }
            goto LABEL_66;
          }
          if ( v33 == 128 )
          {
            sub_22770(v23, v123, *(_DWORD *)(v22 + 4));
            if ( *(_DWORD *)(v22 + 4) <= 0 )
            {
              v105 = 0;
            }
            else
            {
              v128 = v32;
              v99 = 0;
              v136 = v2;
              v100 = 0LL;
              v101 = 0;
              do
              {
                sub_22770(v23, v123, v99);
                ++v101;
                v102 = *(_QWORD *)(**(_QWORD **)(v22 + 56) + v100);
                v100 += 8LL;
                v103 = NameForAtom(v102);
                v99 += strlen(v103) + 1;
              }
              while ( *(_DWORD *)(v22 + 4) > v101 );
              v104 = v99;
              v2 = v136;
              v32 = v128;
              v105 = v104;
            }
            sub_22770(v23, v123, v105);
            if ( *(_DWORD *)(v22 + 4) > 0 )
            {
              v106 = 0LL;
              do
              {
                v107 = NameForAtom(*(_QWORD *)(**(_QWORD **)(v22 + 56) + 8 * v106));
                dword_23CCD4 += strlen(v107) + 1;
                BufFileWrite(v23, v107);
                ++v106;
              }
              while ( *(_DWORD *)(v22 + 4) > (signed int)v106 );
            }
          }
          else if ( v33 == 256 )
          {
            sub_22AD0(v23, *((_DWORD *)v32 - 3), v2 + 8);
            if ( v125 == v32 )
            {
LABEL_76:
              free(ptr);
              return 85LL;
            }
            goto LABEL_67;
          }
        }
      }
LABEL_66:
      if ( v125 == v32 )
        goto LABEL_76;
LABEL_67:
      v30 = *((_DWORD *)v32 + 3);
      v31 = dword_23CCD4;
      v32 += 16;
      if ( v30 < dword_23CCD4 )
        goto LABEL_68;
      continue;
    }
  }
  dword_23CCD4 = 0;
  sub_22690(v133, 0x70636601u);
  sub_22690(v133, v25);
  free(ptr);
  return 85LL;
}
// 8A40: using guessed type __int64 __fastcall pcfError(_QWORD);
// 8A90: using guessed type __int64 __fastcall BufFileWrite(_QWORD, _QWORD);
// 8BF0: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD);
// 23CCD4: using guessed type int dword_23CCD4;
// 23CCD8: using guessed type int dword_23CCD8;
// 22C80: using guessed type char var_248[12];

//----- (0000000000023C80) ----------------------------------------------------
void __fastcall sub_23C80(FontPtr font)
{
  void **v1; // rbp

  v1 = (void **)font->fontPrivate;
  free(v1[4]);
  free(v1);
  DestroyFontRec(font);
}

//----- (0000000000023CB0) ----------------------------------------------------
unsigned __int64 sub_23CB0(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v3; // [rsp+18h] [rbp-D0h]

  va_start(va, a1);
  v3 = __readfsqword(0x28u);
  fwrite("SNF Error: ", 1uLL, 0xBuLL, stderr);
  __vfprintf_chk(stderr, 1LL, a1, va);
  return __readfsqword(0x28u) ^ v3;
}
// 8090: using guessed type __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000023DA0) ----------------------------------------------------
signed __int64 __fastcall sub_23DA0(_DWORD *a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( (unsigned int)BufFileRead(a2, a1, 108LL) != 108 || *a1 != 4 )
    result = 83LL;
  else
    result = 2 * (unsigned int)(a1[26] == 4) + 83;
  return result;
}
// 8DF0: using guessed type __int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD);

//----- (0000000000023DE0) ----------------------------------------------------
signed __int64 __fastcall sub_23DE0(_DWORD *a1, int a2, Atom **a3, _QWORD *a4, __int64 a5)
{
  _QWORD *v5; // r15
  Atom **v6; // rbp
  __int64 v7; // r14
  unsigned int v8; // ebx
  unsigned int *v9; // rbx
  Atom *v10; // r13
  __int64 v11; // r14
  char *v12; // rbp
  unsigned int v13; // eax
  char *v14; // rbp
  unsigned int v15; // eax
  signed __int64 result; // rax
  signed __int64 v17; // [rsp+0h] [rbp-48h]
  unsigned int *ptr; // [rsp+8h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v7 = a5;
  v8 = a2 + 12 * *a1;
  ptr = (unsigned int *)malloc((signed int)v8);
  if ( ptr )
  {
    if ( v8 == (unsigned int)BufFileRead(v7, ptr, v8) )
    {
      v9 = ptr;
      v10 = *v6;
      v17 = (signed __int64)&ptr[3 * *a1];
      if ( *a1 )
      {
        v11 = 0LL;
        do
        {
          v12 = (char *)(v17 + *v9);
          v13 = strlen((const char *)(v17 + *v9));
          *v10 = MakeAtom(v12, v13, 1);
          *(_BYTE *)(*v5 + v11) = v9[2];
          if ( v9[2] )
          {
            v14 = (char *)(v17 + (signed int)v9[1]);
            v15 = strlen((const char *)(v17 + (signed int)v9[1]));
            v10[1] = (signed int)MakeAtom(v14, v15, 1);
          }
          else
          {
            v10[1] = (signed int)v9[1];
          }
          v10 += 2;
          v9 += 3;
          ++v11;
        }
        while ( *a1 > (unsigned int)v11 );
      }
      free(ptr);
      result = 85LL;
    }
    else
    {
      free(ptr);
      result = 83LL;
    }
  }
  else
  {
    sub_23CB0((__int64)"snfReadProps(): Couldn't allocate propspace (%d)\n", v8);
    result = 80LL;
  }
  return result;
}
// 8DF0: using guessed type __int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD);

//----- (0000000000023F50) ----------------------------------------------------
void __fastcall SnfSetFormat(int a1, int a2, int a3, int a4)
{
  dword_23CCE4 = a1;
  dword_23CCE0 = a2;
  dword_23CCDC = a3;
  dword_23CCD8 = a4;
  dword_23CCE8 = 1;
}
// 23CCD8: using guessed type int dword_23CCD8;
// 23CCDC: using guessed type int dword_23CCDC;
// 23CCE0: using guessed type int dword_23CCE0;
// 23CCE4: using guessed type int dword_23CCE4;
// 23CCE8: using guessed type int dword_23CCE8;

//----- (0000000000023F80) ----------------------------------------------------
__int64 __fastcall snfReadFont(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5, int a6)
{
  __int64 v6; // rbp
  unsigned int v7; // er15
  int v9; // ebx
  int v10; // ecx
  int v11; // eax
  bool v12; // sf
  int v13; // ecx
  int v14; // er13
  int v15; // eax
  int v16; // er14
  signed int v17; // er12
  unsigned int v18; // er15
  signed __int16 **v19; // rbx
  signed __int16 *v20; // rdi
  signed __int16 *v21; // r12
  __int64 v22; // r12
  int v23; // er14
  signed __int16 *v24; // rax
  __int64 v25; // r13
  __int64 v26; // rsi
  signed __int16 *v27; // r13
  int v28; // eax
  signed int v29; // edx
  signed __int16 *v30; // r13
  void **v31; // ST40_8
  signed __int16 *v32; // rax
  int v33; // er12
  int v34; // ebp
  signed __int64 v35; // r14
  int v36; // eax
  signed __int16 *v37; // r12
  signed __int16 *v38; // r13
  __int64 v39; // rsi
  int v40; // eax
  __int64 v41; // rsi
  char *v42; // rax
  char *v43; // rbx
  int v44; // ecx
  int v45; // edx
  int v46; // er8
  int v47; // eax
  int v48; // eax
  char v49; // si
  char v50; // dl
  __int16 v51; // ax
  int v52; // ecx
  char v53; // dl
  __int16 v54; // ax
  __int64 v55; // r8
  int v56; // edi
  __int64 v57; // rsi
  int v58; // eax
  unsigned __int16 v59; // ax
  int v60; // esi
  int v61; // edi
  int v62; // edx
  signed __int16 *v63; // rax
  __int64 v64; // r14
  signed __int16 *v65; // r13
  int v66; // [rsp+Ch] [rbp-11Ch]
  __int64 v67; // [rsp+10h] [rbp-118h]
  int v68; // [rsp+18h] [rbp-110h]
  unsigned int v69; // [rsp+1Ch] [rbp-10Ch]
  int v70; // [rsp+28h] [rbp-100h]
  int v71; // [rsp+2Ch] [rbp-FCh]
  signed __int16 *ptr; // [rsp+30h] [rbp-F8h]
  unsigned int v73; // [rsp+38h] [rbp-F0h]
  signed __int16 **v74; // [rsp+38h] [rbp-F0h]
  __int64 v75; // [rsp+40h] [rbp-E8h]
  char v76; // [rsp+48h] [rbp-E0h]
  signed int v77; // [rsp+48h] [rbp-E0h]
  int v78; // [rsp+4Ch] [rbp-DCh]
  int v79; // [rsp+50h] [rbp-D8h]
  int v80; // [rsp+54h] [rbp-D4h]
  int v81; // [rsp+58h] [rbp-D0h]
  int v82; // [rsp+5Ch] [rbp-CCh]
  __int64 v83; // [rsp+60h] [rbp-C8h]
  int v84; // [rsp+68h] [rbp-C0h]
  int v85; // [rsp+6Ch] [rbp-BCh]
  char v86; // [rsp+70h] [rbp-B8h]
  char v87; // [rsp+74h] [rbp-B4h]
  __int16 v88; // [rsp+78h] [rbp-B0h]
  char v89; // [rsp+7Ch] [rbp-ACh]
  char v90; // [rsp+80h] [rbp-A8h]
  char v91; // [rsp+84h] [rbp-A4h]
  char v92; // [rsp+88h] [rbp-A0h]
  int v93; // [rsp+8Ch] [rbp-9Ch]
  int v94; // [rsp+90h] [rbp-98h]
  int v95; // [rsp+94h] [rbp-94h]
  int v96; // [rsp+98h] [rbp-90h]
  int v97; // [rsp+9Ch] [rbp-8Ch]
  int v98; // [rsp+A0h] [rbp-88h]
  int v99; // [rsp+A4h] [rbp-84h]
  int v100; // [rsp+A8h] [rbp-80h]
  int v101; // [rsp+ACh] [rbp-7Ch]
  __int64 v102; // [rsp+B0h] [rbp-78h]
  int v103; // [rsp+B8h] [rbp-70h]
  __int64 v104; // [rsp+C0h] [rbp-68h]
  int v105; // [rsp+C8h] [rbp-60h]
  int v106; // [rsp+CCh] [rbp-5Ch]
  unsigned __int64 v107; // [rsp+E8h] [rbp-40h]

  v6 = a2;
  v107 = __readfsqword(0x28u);
  v67 = a1;
  v68 = a3;
  v70 = a4;
  v69 = a5;
  v71 = a6;
  v7 = sub_23DA0(&v86, a2);
  if ( v7 != 85 )
    return v7;
  if ( !dword_23CCE8 )
    FontDefaultFormat(&dword_23CCE4, &dword_23CCE0, &dword_23CCDC, &dword_23CCD8);
  v79 = dword_23CCE4;
  v81 = dword_23CCE0;
  v80 = dword_23CCDC;
  v82 = dword_23CCD8;
  v73 = ((v106 & 0xFFFFFF) + 3) & 0xFFFFFFFC;
  v9 = (v94 + 1 - v93) * (v96 + 1 - v95);
  v10 = (v94 + 1 - v93) * (v96 + 1 - v95);
  v11 = v9 + 254;
  v12 = v10 + 127 < 0;
  v13 = v10 + 127;
  v66 = (v94 + 1 - v93) * (v96 + 1 - v95);
  if ( !v12 )
    v11 = v13;
  v14 = 24 * v9 + 64;
  v15 = v11 >> 7;
  v16 = v14 + 8 * v15;
  v75 = v15;
  v78 = v16 + 16 * v97;
  v17 = (v97 + v16 + 16 * v97 + 3) & 0xFFFFFFFC;
  v18 = v17 + 12 * v9;
  if ( !(v92 & 8) )
    v18 = (v97 + v16 + 16 * v97 + 3) & 0xFFFFFFFC;
  v76 = v92 & 8;
  v19 = (signed __int16 **)malloc(v18);
  if ( !v19 )
  {
    v41 = v18;
    v7 = 80;
    sub_23CB0((__int64)"snfReadFont(): Couldn't allocate fontspace (%d)\n", v41);
    return v7;
  }
  ptr = (signed __int16 *)malloc((signed int)v73);
  if ( !ptr )
  {
    v7 = 80;
    sub_23CB0((__int64)"snfReadFont(): Couldn't allocate bitmaps (%d)\n", v73);
    free(v19);
    return v7;
  }
  v20 = (signed __int16 *)((char *)v19 + v14);
  v19[2] = (signed __int16 *)(v19 + 8);
  v21 = (signed __int16 *)((char *)v19 + v17);
  v19[5] = v20;
  v19[6] = 0LL;
  v19[4] = ptr;
  *((_DWORD *)v19 + 1) = v66;
  v19[7] = 0LL;
  *(_QWORD *)(v67 + 80) = (char *)v19 + v16;
  *(_QWORD *)(v67 + 88) = (char *)v19 + v78;
  if ( !v76 )
    v21 = 0LL;
  v19[3] = v21;
  memset(v20, 0, 8 * v75);
  if ( v66 > 0 )
  {
    v22 = 0LL;
    v23 = 0;
    do
    {
      v27 = v19[2];
      v28 = BufFileRead(v6, &v83, 16LL);
      v29 = 83;
      if ( v28 == 16 )
      {
        v30 = &v27[v22];
        *(_QWORD *)v30 = v83;
        *((_DWORD *)v30 + 2) = v84;
        if ( v85 & 0x1000000 )
        {
          v29 = 85;
          *((_QWORD *)v30 + 2) = (char *)ptr + (v85 & 0xFFFFFF);
        }
        else
        {
          *((_QWORD *)v30 + 2) = 0LL;
          v29 = 85;
        }
      }
      v24 = &v19[2][v22];
      if ( *((_QWORD *)v24 + 2) )
      {
        v25 = v23 >> 7;
        v26 = *(_QWORD *)&v19[5][4 * v25];
        if ( !v26 )
        {
          v31 = (void **)&v19[5][4 * v25];
          v77 = v29;
          *v31 = calloc(0x80uLL, 8uLL);
          v26 = *(_QWORD *)&v19[5][4 * v25];
          if ( !v26 )
          {
            v7 = 80;
            goto LABEL_27;
          }
          v29 = v77;
          v24 = &v19[2][v22];
        }
        *(_QWORD *)(v26 + 8LL * (v23 & 0x7F)) = v24;
      }
      ++v23;
      v22 += 12LL;
    }
    while ( v29 == 85 && v66 > v23 );
    v7 = v29;
    if ( v29 == 85 )
      goto LABEL_33;
LABEL_27:
    free(ptr);
    v32 = v19[5];
    if ( v32 )
    {
      v33 = v23 >> 7;
      if ( v23 >> 7 )
      {
        v34 = 0;
        v35 = 4LL * v23;
        while ( 1 )
        {
          ++v34;
          free(*(void **)&v32[v35]);
          if ( v33 == v34 )
            break;
          v32 = v19[5];
        }
      }
    }
    goto LABEL_32;
  }
LABEL_33:
  if ( (unsigned int)BufFileRead(v6, ptr, v73) != v73 )
  {
    v7 = 83;
    free(ptr);
    free(v19);
    return v7;
  }
  if ( v68 != v79 )
    BitOrderInvert((unsigned __int8 *)ptr, v73);
  if ( (v79 == v81) != (v68 == v70) )
  {
    v36 = v82;
    if ( v68 != v70 )
      v36 = v71;
    if ( v36 == 2 )
    {
      TwoByteSwap((unsigned __int8 *)ptr, v73);
    }
    else if ( v36 == 4 )
    {
      FourByteSwap((unsigned __int8 *)ptr, v73);
    }
  }
  if ( v69 != v80 )
  {
    v37 = v19[2];
    if ( v66 <= 0 )
    {
      v63 = (signed __int16 *)malloc(0LL);
      if ( v63 )
      {
        v19[4] = v63;
LABEL_59:
        free(ptr);
        goto LABEL_60;
      }
      v39 = 0LL;
    }
    else
    {
      v38 = v19[2];
      LODWORD(v39) = 0;
      do
      {
        if ( *((_QWORD *)v38 + 2) )
        {
          v40 = v38[3] + v38[4];
          switch ( v69 )
          {
            case 1u:
              LODWORD(v39) = ((v38[1] - *v38 + 7) >> 3) * v40 + v39;
              break;
            case 2u:
              LODWORD(v39) = (((v38[1] - *v38 + 15) >> 3) & 0xFFFFFFFE) * v40 + v39;
              break;
            case 4u:
              LODWORD(v39) = (((v38[1] - *v38 + 31) >> 3) & 0xFFFFFFFC) * v40 + v39;
              break;
            case 8u:
              LODWORD(v39) = (((v38[1] - *v38 + 63) >> 3) & 0xFFFFFFF8) * v40 + v39;
              break;
          }
        }
        v38 += 12;
      }
      while ( v38 != &v37[12 * (v66 - 1) + 12] );
      v42 = (char *)malloc((signed int)v39);
      v39 = (unsigned int)v39;
      if ( v42 )
      {
        v19[4] = (signed __int16 *)v42;
        v74 = v19;
        v43 = v42;
        do
        {
          v44 = v37[3];
          v45 = v37[4];
          v46 = v37[1];
          v47 = *v37;
          v37 += 12;
          v48 = RepadBitmap(*((char **)v37 - 1), v43, v80, v69, v46 - v47, v44 + v45);
          *((_QWORD *)v37 - 1) = v43;
          v43 += v48;
        }
        while ( v37 != v38 );
        v19 = v74;
        goto LABEL_59;
      }
    }
    v7 = 80;
    sub_23CB0((__int64)"snfReadFont(): Couldn't allocate padbitmaps (%d)\n", v39);
    free(ptr);
    free(v19);
    return v7;
  }
LABEL_60:
  v7 = sub_23DE0(&v97, v98, (Atom **)(v67 + 80), (_QWORD *)(v67 + 88), v6);
  if ( v7 != 85 )
  {
LABEL_32:
    free(v19);
    return v7;
  }
  v49 = v89;
  v50 = v91;
  *(_WORD *)(v67 + 8) = v93;
  *(_WORD *)(v67 + 10) = v94;
  *(_WORD *)(v67 + 12) = v95;
  *(_WORD *)(v67 + 14) = v96;
  v51 = v99;
  *(_WORD *)(v67 + 16) = v99;
  LOWORD(v52) = v51;
  LOBYTE(v51) = 2 * (v50 & 1) | v49 & 1 | *(_BYTE *)(v67 + 18) & 0xFC;
  v53 = v92;
  *(_BYTE *)(v67 + 18) = ((v87 & 1) << 6) | (4 * v92 & 0x20 | 4 * v92 & 0x10 | (4 * v92 & 8 | 4 * (v90 & 1) | v51 & 0xF3) & 0xCF) & 0xBF;
  v54 = ((v88 & 3) << 7) | *(_WORD *)(v67 + 18) & 0xFE7F;
  *(_WORD *)(v67 + 18) = v54;
  *(_WORD *)(v67 + 20) = 0;
  *(_BYTE *)(v67 + 19) = HIBYTE(v54) & 0xFB | 2;
  v55 = v102;
  v56 = v103;
  v57 = v104;
  v58 = v105;
  *(_QWORD *)(v67 + 36) = v102;
  *(_DWORD *)(v67 + 44) = v56;
  *(_QWORD *)(v67 + 24) = v57;
  *(_DWORD *)(v67 + 32) = v58;
  *(_WORD *)(v67 + 72) = v101;
  *(_WORD *)(v67 + 74) = v100;
  *(_DWORD *)(v67 + 76) = v97;
  if ( v53 & 8 )
  {
    if ( (unsigned int)BufFileRead(v6, &v83, 16LL) == 16 )
    {
      *(_QWORD *)(v67 + 60) = v83;
      *(_DWORD *)(v67 + 68) = v84;
    }
    if ( (unsigned int)BufFileRead(v6, &v83, 16LL) != 16 )
    {
LABEL_65:
      v7 = 83;
      free(v19);
      return v7;
    }
    *(_QWORD *)(v67 + 48) = v83;
    *(_DWORD *)(v67 + 56) = v84;
    if ( v66 > 0 )
    {
      v64 = 0LL;
      while ( 1 )
      {
        v65 = v19[3];
        if ( (unsigned int)BufFileRead(v6, &v83, 16LL) != 16 )
          goto LABEL_65;
        *(_QWORD *)&v65[v64] = v83;
        *(_DWORD *)&v65[v64 + 4] = v84;
        v64 += 6LL;
        if ( 2 * (3LL * (unsigned int)(v66 - 1) + 3) == v64 )
        {
          v7 = 85;
          LOWORD(v52) = *(_WORD *)(v67 + 16);
          goto LABEL_72;
        }
      }
    }
    LOWORD(v52) = *(_WORD *)(v67 + 16);
  }
  else
  {
    *(_QWORD *)(v67 + 60) = v55;
    *(_DWORD *)(v67 + 68) = v56;
    *(_QWORD *)(v67 + 48) = v57;
    *(_DWORD *)(v67 + 56) = v58;
  }
LABEL_72:
  if ( (_WORD)v52 != -1 )
  {
    v59 = (unsigned __int16)v52 >> 8;
    v60 = *(unsigned __int16 *)(v67 + 12);
    if ( (unsigned __int16)((unsigned __int16)v52 >> 8) >= (unsigned __int16)v60 && v59 <= *(_WORD *)(v67 + 14) )
    {
      v61 = *(unsigned __int16 *)(v67 + 8);
      v52 = (unsigned __int8)v52;
      if ( (unsigned __int16)v61 <= (unsigned __int8)v52 )
      {
        v62 = *(unsigned __int16 *)(v67 + 10);
        if ( (unsigned __int16)v62 >= (unsigned __int16)v52 )
          v19[6] = &v19[2][12 * (v52 - v61 + (v62 - v61 + 1) * (v59 - v60))];
      }
    }
  }
  v19[7] = 0LL;
  *(_QWORD *)(v67 + 152) = v19;
  *(_QWORD *)(v67 + 128) = 0LL;
  *(_QWORD *)(v67 + 104) = bitmapGetGlyphs;
  *(_QWORD *)(v67 + 120) = sub_23C80;
  *(_QWORD *)(v67 + 112) = bitmapGetMetrics;
  *(_BYTE *)(v67 + 96) = v68;
  *(_BYTE *)(v67 + 97) = v70;
  *(_BYTE *)(v67 + 98) = v69;
  *(_BYTE *)(v67 + 99) = v71;
  return v7;
}
// 8630: using guessed type __int64 __fastcall FontDefaultFormat(_QWORD, _QWORD, _QWORD, _QWORD);
// 8DF0: using guessed type __int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD);
// 23CCD8: using guessed type int dword_23CCD8;
// 23CCDC: using guessed type int dword_23CCDC;
// 23CCE0: using guessed type int dword_23CCE0;
// 23CCE4: using guessed type int dword_23CCE4;
// 23CCE8: using guessed type int dword_23CCE8;

//----- (0000000000024930) ----------------------------------------------------
__int64 __fastcall snfReadFontInfo(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // er12
  char v5; // cl
  char v6; // dl
  int v7; // er13
  int v8; // er12
  int v9; // eax
  size_t v10; // rdx
  unsigned int v11; // er14
  void *v12; // rax
  void *v13; // rax
  int v14; // eax
  int v15; // esi
  size_t size; // [rsp+0h] [rbp-D8h]
  int v17; // [rsp+8h] [rbp-D0h]
  int v18; // [rsp+Ch] [rbp-CCh]
  __int64 v19; // [rsp+10h] [rbp-C8h]
  int v20; // [rsp+18h] [rbp-C0h]
  char v21; // [rsp+20h] [rbp-B8h]
  char v22; // [rsp+24h] [rbp-B4h]
  __int16 v23; // [rsp+28h] [rbp-B0h]
  char v24; // [rsp+2Ch] [rbp-ACh]
  char v25; // [rsp+30h] [rbp-A8h]
  char v26; // [rsp+34h] [rbp-A4h]
  char v27; // [rsp+38h] [rbp-A0h]
  int v28; // [rsp+3Ch] [rbp-9Ch]
  int v29; // [rsp+40h] [rbp-98h]
  int v30; // [rsp+44h] [rbp-94h]
  int v31; // [rsp+48h] [rbp-90h]
  unsigned int v32; // [rsp+4Ch] [rbp-8Ch]
  int v33; // [rsp+50h] [rbp-88h]
  int v34; // [rsp+54h] [rbp-84h]
  int v35; // [rsp+58h] [rbp-80h]
  int v36; // [rsp+5Ch] [rbp-7Ch]
  __int64 v37; // [rsp+60h] [rbp-78h]
  int v38; // [rsp+68h] [rbp-70h]
  __int64 v39; // [rsp+70h] [rbp-68h]
  int v40; // [rsp+78h] [rbp-60h]
  int v41; // [rsp+7Ch] [rbp-5Ch]
  unsigned __int64 v42; // [rsp+98h] [rbp-40h]

  v2 = a2;
  v42 = __readfsqword(0x28u);
  v3 = sub_23DA0(&v21, a2);
  if ( v3 == 85 )
  {
    v5 = v24;
    v6 = v26;
    v7 = v29;
    v8 = v31;
    v17 = v28;
    *(_WORD *)a1 = v28;
    v9 = v30;
    *(_WORD *)(a1 + 2) = v7;
    *(_WORD *)(a1 + 6) = v8;
    v18 = v9;
    *(_WORD *)(a1 + 4) = v9;
    *(_WORD *)(a1 + 8) = v34;
    *(_BYTE *)(a1 + 10) = ((v22 & 1) << 6) | (4 * v27 & 0x20 | 4 * v27 & 0x10 | (4 * v27 & 8 | 4 * (v25 & 1) | (2 * (v6 & 1) | v5 & 1 | *(_BYTE *)(a1 + 10) & 0xFC) & 0xF3) & 0xCF) & 0xBF;
    LOWORD(v9) = ((v23 & 3) << 7) | *(_WORD *)(a1 + 10) & 0xFE7F;
    *(_WORD *)(a1 + 10) = v9;
    *(_BYTE *)(a1 + 11) = BYTE1(v9) & 0xFB | 2;
    *(_WORD *)(a1 + 12) = 0;
    *(_QWORD *)(a1 + 28) = v37;
    *(_DWORD *)(a1 + 36) = v38;
    *(_QWORD *)(a1 + 16) = v39;
    *(_DWORD *)(a1 + 24) = v40;
    v10 = v32;
    *(_WORD *)(a1 + 64) = v36;
    LOWORD(v9) = v35;
    *(_DWORD *)(a1 + 68) = v10;
    v11 = v10;
    *(_WORD *)(a1 + 66) = v9;
    size = v10;
    v12 = malloc(16 * v10);
    *(_QWORD *)(a1 + 72) = v12;
    if ( v12 )
    {
      v13 = malloc(size);
      *(_QWORD *)(a1 + 80) = v13;
      if ( v13 )
      {
        v14 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a2 + 8224))(
                a2,
                16 * (v7 + 1 - v17) * (v8 + 1 - v18) + (((v41 & 0xFFFFFF) + 3) & 0xFFFFFFFC));
        v15 = v33;
        *(_DWORD *)(v2 + 12) = v14;
        v3 = sub_23DE0(&v32, v15, (Atom **)(a1 + 72), (_QWORD *)(a1 + 80), v2);
        if ( v3 == 85 )
        {
          if ( v27 & 8 )
          {
            if ( (unsigned int)BufFileRead(v2, &v19, 16LL) != 16
              || (*(_QWORD *)(a1 + 52) = v19, *(_DWORD *)(a1 + 60) = v20,
                                              (unsigned int)BufFileRead(v2, &v19, 16LL) != 16) )
            {
              v3 = 83;
              free(*(void **)(a1 + 72));
              free(*(void **)(a1 + 80));
            }
            else
            {
              *(_QWORD *)(a1 + 40) = v19;
              *(_DWORD *)(a1 + 48) = v20;
            }
          }
          else
          {
            *(_QWORD *)(a1 + 52) = *(_QWORD *)(a1 + 28);
            *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 36);
            *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 16);
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 24);
          }
        }
        else
        {
          free(*(void **)(a1 + 72));
          free(*(void **)(a1 + 80));
        }
      }
      else
      {
        v3 = 80;
        sub_23CB0((__int64)"snfReadFontInfo(): Couldn't allocate isStringProp (%d*%d)\n", v11, 1LL);
        free(*(void **)(a1 + 72));
      }
    }
    else
    {
      v3 = 80;
      sub_23CB0((__int64)"snfReadFontInfo(): Couldn't allocate props (%d*%d)\n", v11, 16LL);
    }
  }
  return v3;
}
// 8DF0: using guessed type __int64 __fastcall BufFileRead(_QWORD, _QWORD, _QWORD);

//----- (0000000000024C60) ----------------------------------------------------
signed __int64 __fastcall BuiltinReadDirectory(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // r13
  void *v4; // rbp
  char **v5; // rbx
  const void *v6; // r15
  size_t v7; // rax
  const char **v8; // rcx
  char **v9; // rbx
  void **v10; // r13
  __int64 v11; // r15
  const char *v12; // rsi
  const char **v13; // ST10_8
  size_t v14; // rax
  const char *v15; // rsi
  const char **v16; // ST10_8
  size_t v17; // rax
  char **v18; // rbx
  signed int v19; // er13
  signed int v21; // er12
  void *v22; // rax
  __int64 v23; // r15
  __int64 v24; // r13
  char *v25; // rbx
  __int64 v26; // r15
  char *v27; // rax
  const char *v28; // rdi
  _QWORD *v29; // [rsp+18h] [rbp-40h]

  v29 = a2;
  v2 = FontFileMakeDir("");
  v3 = qword_23CCF8;
  v4 = (void *)v2;
  if ( qword_23CCF8 )
  {
    if ( builtin_dir_count > 0 )
    {
      v5 = builtin_dir;
      do
      {
        if ( v3 )
        {
          v6 = *(const void **)(v3 + 8);
          if ( v6 )
          {
            v7 = strlen(*(const char **)(v3 + 8));
            memmove(v5[1], v6, v7);
          }
        }
        if ( v5 == &builtin_dir[2 * (unsigned int)(builtin_dir_count - 1)] )
          break;
        v3 += 16LL;
        v5 += 2;
      }
      while ( v5 );
    }
  }
  else
  {
    v25 = (char *)calloc(builtin_dir_count, 0x10uLL);
    if ( v25 && builtin_dir_count > 0 )
    {
      v26 = 0LL;
      do
      {
        v27 = strdup(builtin_dir[v26]);
        v28 = builtin_dir[v26 + 1];
        *(_QWORD *)&v25[v26 * 8] = v27;
        *(_QWORD *)&v25[v26 * 8 + 8] = strdup(v28);
        v26 += 2LL;
      }
      while ( v26 != 2 * ((unsigned int)(builtin_dir_count - 1) + 1LL) );
    }
    qword_23CCF8 = (__int64)v25;
  }
  v8 = (const char **)qword_23CCF0;
  if ( qword_23CCF0 )
  {
    if ( builtin_alias_count > 0 )
    {
      v9 = builtin_alias;
      v10 = (void **)builtin_alias;
      v11 = qword_23CCF0 + 16LL * (unsigned int)(builtin_alias_count - 1);
      do
      {
        if ( v8 )
        {
          v12 = *v8;
          if ( *v8 )
          {
            v13 = v8;
            v14 = strlen(*v8);
            memmove(*v10, v12, v14);
            v8 = v13;
          }
          v15 = v8[1];
          if ( v15 )
          {
            v16 = v8;
            v17 = strlen(v8[1]);
            memmove(v10[1], v15, v17);
            v8 = v16;
          }
        }
        if ( (const char **)v11 == v8 )
          break;
        v8 += 2;
        v10 += 2;
      }
      while ( v10 );
LABEL_19:
      if ( builtin_dir_count > 0 )
        goto LABEL_20;
LABEL_27:
      v21 = 0;
      while ( (unsigned int)FontFileAddFontAlias(v4, *v9, v9[1], v8) )
      {
        ++v21;
        v9 += 2;
        if ( v21 >= builtin_alias_count )
          goto LABEL_43;
      }
LABEL_23:
      FontFileFreeDir(v4);
      return 86LL;
    }
    goto LABEL_42;
  }
  v22 = calloc(builtin_alias_count, 0x10uLL);
  v23 = (__int64)v22;
  if ( v22 )
  {
    if ( builtin_alias_count > 0 )
    {
      v9 = builtin_alias;
      v24 = 0LL;
      do
      {
        *(_QWORD *)(v23 + v24 * 8 + 8) = strdup(builtin_alias[v24 + 1]);
        v24 += 2LL;
      }
      while ( v24 != 2 * ((unsigned int)(builtin_alias_count - 1) + 1LL) );
      qword_23CCF0 = v23;
      goto LABEL_19;
    }
    qword_23CCF0 = (__int64)v22;
LABEL_42:
    if ( builtin_dir_count <= 0 )
      goto LABEL_43;
LABEL_20:
    v18 = builtin_dir;
    v19 = 0;
    while ( (unsigned int)FontFileAddFontFile(v4, v18[1], *v18, v8) )
    {
      ++v19;
      v18 += 2;
      if ( builtin_dir_count <= v19 )
        goto LABEL_25;
    }
    goto LABEL_23;
  }
  qword_23CCF0 = 0LL;
  if ( builtin_dir_count > 0 )
    goto LABEL_20;
LABEL_25:
  if ( builtin_alias_count > 0 )
  {
    v9 = builtin_alias;
    goto LABEL_27;
  }
LABEL_43:
  FontFileSortDir(v4);
  *v29 = v4;
  return 85LL;
}
// 8320: using guessed type __int64 __fastcall FontFileAddFontAlias(_QWORD, _QWORD, _QWORD, _QWORD);
// 8370: using guessed type __int64 __fastcall FontFileSortDir(_QWORD);
// 8E60: using guessed type __int64 __fastcall FontFileAddFontFile(_QWORD, _QWORD, _QWORD, _QWORD);
// 23AAA0: using guessed type char *builtin_alias[6];
// 23AAE0: using guessed type char *builtin_dir[5];
// 23CCF0: using guessed type __int64 qword_23CCF0;
// 23CCF8: using guessed type __int64 qword_23CCF8;

//----- (0000000000024F50) ----------------------------------------------------
__int64 __fastcall sub_24F50(unsigned __int64 *a1, unsigned int a2)
{
  __int64 result; // rax
  __int64 v3; // rsi
  int v4; // ecx
  unsigned __int64 v5; // rsi
  int v6; // edx
  __int64 v7; // rcx
  int v8; // ecx

  result = a2;
  v3 = *a1;
  v4 = *((_DWORD *)a1 + 2);
  if ( (signed int)(result + *a1 - ((_DWORD)a1 + 16)) <= (signed int)(v4 + *a1 - ((_DWORD)a1 + 16)) )
  {
    *((_DWORD *)a1 + 2) = v4 - result;
    *a1 = (signed int)result + v3;
  }
  else
  {
    v5 = a1[1030];
    v6 = *(_DWORD *)v5 + result - v4;
    v7 = *(_QWORD *)(v5 + 8);
    *(_DWORD *)v5 = v6;
    v8 = *(_DWORD *)(v7 + 8);
    if ( v6 > v8 )
    {
      *(_DWORD *)v5 = v8;
      v6 = v8;
    }
    if ( v6 < 0 )
      *(_DWORD *)v5 = 0;
    *((_DWORD *)a1 + 2) = 0;
  }
  return result;
}

//----- (0000000000024FC0) ----------------------------------------------------
signed __int64 __fastcall sub_24FC0(__int64 a1)
{
  free(*(void **)(a1 + 8240));
  return 1LL;
}

//----- (0000000000024FE0) ----------------------------------------------------
signed __int64 __fastcall sub_24FE0(__int64 a1)
{
  signed int *v1; // r9
  __int64 v2; // rcx
  __int64 v3; // rsi
  unsigned int v4; // er8
  unsigned int v5; // eax
  _DWORD *v6; // rsi
  int v7; // er10
  signed __int64 v8; // r11

  v1 = *(signed int **)(a1 + 8240);
  v2 = *((_QWORD *)v1 + 1);
  v3 = *v1;
  v4 = *(_DWORD *)(v2 + 8) - v3;
  if ( (signed int)v4 > 0 )
  {
    if ( (signed int)v4 <= 0x1FFF )
    {
      v5 = *(_DWORD *)(v2 + 8) - v3;
      v6 = (_DWORD *)(*(_QWORD *)(v2 + 16) + v3);
      v7 = v4 - 1;
      v8 = a1 + 16;
      if ( v4 < 8 )
      {
        if ( v4 & 4 )
        {
          *(_DWORD *)(a1 + 16) = *v6;
          *(_DWORD *)(v8 + v4 - 4) = *(_DWORD *)((char *)v6 + v4 - 4);
        }
        else if ( v4 )
        {
          *(_BYTE *)(a1 + 16) = *(_BYTE *)v6;
          if ( v4 & 2 )
            *(_WORD *)(v8 + v4 - 2) = *(_WORD *)((char *)v6 + v4 - 2);
        }
        goto LABEL_8;
      }
    }
    else
    {
      v5 = 0x2000;
      v6 = (_DWORD *)(*(_QWORD *)(v2 + 16) + v3);
      v7 = 0x1FFF;
      v4 = 0x2000;
      v8 = a1 + 16;
    }
    *(_QWORD *)(a1 + 16) = *(_QWORD *)v6;
    *(_QWORD *)(v8 + v5 - 8) = *(_QWORD *)((char *)v6 + v5 - 8);
    qmemcpy(
      (void *)((a1 + 24) & 0xFFFFFFFFFFFFFFF8LL),
      (char *)v6 - (v8 - ((a1 + 24) & 0xFFFFFFFFFFFFFFF8LL)),
      8LL * ((v5 + (_DWORD)v8 - (((_DWORD)a1 + 24) & 0xFFFFFFF8)) >> 3));
LABEL_8:
    *v1 += v4;
    *(_DWORD *)(a1 + 8) = v7;
    *(_QWORD *)a1 = a1 + 17;
    return *(unsigned __int8 *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 8) = 0;
  return 0xFFFFFFFFLL;
}

//----- (00000000000250E0) ----------------------------------------------------
__int64 __fastcall BuiltinFileOpen(_BYTE *a1)
{
  const char *v1; // r12
  const char **v2; // rbp
  int v3; // ebx
  _DWORD *v4; // rax
  void *v5; // rbp
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 result; // rax
  __int64 v9; // rax

  v1 = &a1[*a1 == 47];
  if ( builtin_files_count <= 0 )
  {
    v3 = 0;
  }
  else
  {
    v2 = (const char **)&builtin_files;
    v3 = 0;
    while ( strcmp(v1, *v2) )
    {
      ++v3;
      v2 += 3;
      if ( builtin_files_count == v3 )
        return 0LL;
    }
  }
  if ( builtin_files_count == v3 )
    return 0LL;
  v4 = malloc(0x10uLL);
  v5 = v4;
  if ( !v4 )
    return 0LL;
  *v4 = 0;
  *((_QWORD *)v4 + 1) = &(&builtin_files)[3 * v3];
  v6 = BufFileCreate(v4, sub_24FE0, 0LL, sub_24F50, sub_24FC0);
  v7 = v6;
  if ( !v6 )
  {
    free(v5);
    return 0LL;
  }
  result = BufFilePushZIP(v6, sub_24FE0);
  if ( !result )
  {
    v9 = *(_QWORD *)v7;
    *(_QWORD *)v7 = v7 + 16;
    *(_DWORD *)(v7 + 8) += v9 - (v7 + 16);
    result = v7;
  }
  return result;
}
// 8150: using guessed type __int64 __fastcall BufFileCreate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8C00: using guessed type __int64 __fastcall BufFilePushZIP(_QWORD, _QWORD);
// 23AB00: using guessed type char *builtin_files;

//----- (00000000000251F0) ----------------------------------------------------
__int64 __fastcall BuiltinFileClose(void *a1)
{
  return BufFileClose(a1);
}

//----- (0000000000025200) ----------------------------------------------------
signed __int64 __fastcall sub_25200(FontPathElementPtr fpe)
{
  return 85LL;
}

//----- (0000000000025210) ----------------------------------------------------
signed __int64 __fastcall sub_25210(FontPathElementPtr fpe)
{
  FontFileFreeDir(fpe->c_private);
  return 85LL;
}

//----- (0000000000025230) ----------------------------------------------------
__int64 __fastcall sub_25230(FontPathElementPtr fpe)
{
  FontPathElementPtr v1; // rbx
  char *v2; // rdi
  __int64 result; // rax
  void *v4; // [rsp+0h] [rbp-18h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v1 = fpe;
  v2 = fpe->name;
  v5 = __readfsqword(0x28u);
  result = BuiltinReadDirectory(v2, &v4);
  if ( (_DWORD)result == 85 )
    v1->c_private = v4;
  return result;
}
// 85B0: using guessed type __int64 __fastcall BuiltinReadDirectory(_QWORD, _QWORD);

//----- (0000000000025280) ----------------------------------------------------
_BOOL8 __fastcall sub_25280(char *name)
{
  return strcmp(name, "built-ins") == 0;
}

//----- (00000000000252A0) ----------------------------------------------------
int BuiltinRegisterFpeFunctions()
{
  BuiltinRegisterFontFileFunctions();
  return RegisterFPEFunctions(
           (NameCheckFunc)sub_25280,
           (InitFpeFunc)sub_25230,
           (FreeFpeFunc)sub_25210,
           (ResetFpeFunc)sub_25200,
           (OpenFontFunc)FontFileOpenFont,
           (CloseFontFunc)FontFileCloseFont,
           (ListFontsFunc)FontFileListFonts,
           (StartLfwiFunc)FontFileStartListFontsWithInfo,
           (NextLfwiFunc)FontFileListNextFontWithInfo,
           0LL,
           0LL,
           0LL,
           0LL,
           0LL,
           0LL);
}
// 8580: using guessed type __int64 BuiltinRegisterFontFileFunctions(void);

//----- (0000000000025300) ----------------------------------------------------
signed __int64 sub_25300()
{
  return 83LL;
}

//----- (0000000000025310) ----------------------------------------------------
signed __int64 sub_25310()
{
  return 83LL;
}

//----- (0000000000025320) ----------------------------------------------------
__int64 __fastcall sub_25320(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // ebp
  __int64 v5; // rax
  __int64 v6; // rbx

  v4 = 83;
  v5 = BuiltinFileOpen(a4);
  if ( v5 )
  {
    v6 = v5;
    v4 = pcfReadFontInfo(a2, v5);
    BuiltinFileClose(v6, 0LL);
  }
  return v4;
}
// 8680: using guessed type __int64 __fastcall BuiltinFileOpen(_QWORD);
// 8AE0: using guessed type __int64 __fastcall BuiltinFileClose(_QWORD, _QWORD);
// 8F20: using guessed type __int64 __fastcall pcfReadFontInfo(_QWORD, _QWORD);

//----- (0000000000025360) ----------------------------------------------------
__int64 __fastcall sub_25360(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6, unsigned int a7)
{
  unsigned int v7; // er13
  unsigned int v8; // ebp
  __int64 v9; // rax
  __int64 v10; // r12
  _DWORD *v11; // rbx
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // rcx
  __int64 v15; // rdx
  unsigned int v17; // [rsp+14h] [rbp-54h]
  unsigned int v18; // [rsp+18h] [rbp-50h]
  unsigned int v19; // [rsp+1Ch] [rbp-4Ch]
  unsigned int v20; // [rsp+20h] [rbp-48h]
  char v21; // [rsp+24h] [rbp-44h]
  unsigned __int64 v22; // [rsp+28h] [rbp-40h]

  v7 = a6;
  v8 = 83;
  v22 = __readfsqword(0x28u);
  v9 = BuiltinFileOpen(a5);
  if ( v9 )
  {
    v10 = v9;
    v11 = malloc(0xB8uLL);
    if ( v11 )
    {
      FontDefaultFormat(&v17, &v18, &v19, &v20);
      CheckFSFormat(v7, a7, &v17, &v18, &v20, &v19, &v21);
      v12 = v20;
      v13 = v19;
      v14 = v18;
      v15 = v17;
      *v11 = 0;
      v11[42] = -1;
      *((_QWORD *)v11 + 22) = 0LL;
      v8 = pcfReadFont(v11, v10, v15, v14, v13, v12);
      BuiltinFileClose(v10, 0LL);
      if ( v8 == 85 )
        *a2 = v11;
      else
        free(v11);
    }
    else
    {
      v8 = 80;
      BuiltinFileClose(v10, 0LL);
    }
  }
  return v8;
}
// 8630: using guessed type __int64 __fastcall FontDefaultFormat(_QWORD, _QWORD, _QWORD, _QWORD);
// 8680: using guessed type __int64 __fastcall BuiltinFileOpen(_QWORD);
// 8860: using guessed type __int64 __fastcall pcfReadFont(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8AE0: using guessed type __int64 __fastcall BuiltinFileClose(_QWORD, _QWORD);
// 8EB0: using guessed type __int64 __fastcall CheckFSFormat(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000254B0) ----------------------------------------------------
__int64 BuiltinRegisterFontFileFunctions()
{
  return FontFileRegisterRenderer(&off_23C440);
}
// 86D0: using guessed type __int64 __fastcall FontFileRegisterRenderer(_QWORD);
// 23C440: using guessed type void *off_23C440;

//----- (00000000000254C0) ----------------------------------------------------
signed __int64 __fastcall sub_254C0(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned int a4, signed __int64 *a5, __int64 *a6)
{
  __int64 *v6; // rax
  __int64 v7; // r11
  __int64 v8; // rbp
  int v9; // ebx
  __int64 *v10; // r12
  unsigned int v11; // er10
  int v12; // er13
  unsigned int v13; // edi
  int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // ecx
  signed __int64 v18; // rax
  unsigned __int8 *v19; // rcx
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rax
  unsigned __int8 *v24; // rsi
  __int64 i; // rax

  v6 = *(__int64 **)(a1 + 152);
  v7 = *v6;
  v8 = v6[2];
  if ( *v6 )
    v7 = v8 + v7 - v6[1];
  v9 = *(unsigned __int16 *)(a1 + 8);
  v10 = a6;
  v11 = *(unsigned __int16 *)(a1 + 10) + 1 - v9;
  if ( a4 == 2 )
  {
    if ( !(*(_BYTE *)(a1 + 18) & 0x40) || (v21 = 0LL, !v7) )
    {
      while ( --a2 != -1 )
      {
        while ( 1 )
        {
          a3 += 2;
          v23 = (unsigned int)(unsigned __int16)__ROL2__(*((_WORD *)a3 - 1), 8) - v9;
          if ( v11 <= (unsigned int)v23 )
            break;
          --a2;
          ++a6;
          *(a6 - 1) = v8 + 24 * v23;
          if ( a2 == -1 )
            goto LABEL_11;
        }
        if ( v7 )
        {
          *a6 = v7;
          ++a6;
        }
      }
      goto LABEL_11;
    }
    while ( v21 != a2 )
    {
      v22 = (unsigned int)(unsigned __int16)__ROL2__(*(_WORD *)&a3[2 * v21], 8) - v9;
      if ( v11 > (unsigned int)v22 )
        a6[v21] = v8 + 24 * v22;
      else
        a6[v21] = v7;
      ++v21;
    }
    v18 = 8 * v21 >> 3;
  }
  else if ( a4 < 2 )
  {
    v18 = 0LL;
    if ( !*(_WORD *)(a1 + 12) )
    {
      if ( !(*(_BYTE *)(a1 + 18) & 0x40) || (v19 = &a3[a2], !v7) )
      {
        v24 = &a3[a2];
        while ( v24 != a3 )
        {
          for ( i = (unsigned int)*(++a3 - 1) - v9; v11 > (unsigned int)i; i = (unsigned int)*(++a3 - 1) - v9 )
          {
            ++a6;
            *(a6 - 1) = v8 + 24 * i;
            if ( v24 == a3 )
              goto LABEL_11;
          }
          if ( v7 )
          {
            *a6 = v7;
            ++a6;
          }
        }
        goto LABEL_11;
      }
      while ( v19 != a3 )
      {
        while ( 1 )
        {
          ++a3;
          ++a6;
          v20 = (unsigned int)*(a3 - 1) - v9;
          if ( v11 <= (unsigned int)v20 )
            break;
          *(a6 - 1) = v8 + 24 * v20;
          if ( v19 == a3 )
            goto LABEL_22;
        }
        *(a6 - 1) = v7;
      }
LABEL_22:
      v18 = 8 * a2 >> 3;
    }
  }
  else
  {
    if ( a4 == 3 )
    {
      v12 = *(unsigned __int16 *)(a1 + 12);
      v13 = *(unsigned __int16 *)(a1 + 14) + 1 - v12;
      while ( --a2 != -1 )
      {
        while ( 1 )
        {
          v14 = *a3;
          a3 += 2;
          v15 = v14 - v12;
          v16 = *(a3 - 1) - v9;
          if ( v13 <= v15 || v11 <= v16 )
            break;
          --a2;
          ++a6;
          *(a6 - 1) = v8 + 24LL * (v16 + v11 * v15);
          if ( a2 == -1 )
            goto LABEL_11;
        }
        if ( v7 )
        {
          *a6 = v7;
          ++a6;
        }
      }
LABEL_11:
      *a5 = a6 - v10;
      return 85LL;
    }
    v18 = 0LL;
  }
  *a5 = v18;
  return 85LL;
}

//----- (0000000000025730) ----------------------------------------------------
__int64 __fastcall sub_25730(FontPtr pfont, signed __int64 a2, unsigned __int8 *a3, unsigned int a4, signed __int64 *a5, _QWORD *a6)
{
  struct _Font *v6; // rbp
  int v7; // er12
  __int64 *v8; // rax
  _QWORD *v9; // r14
  __int64 v10; // r15
  __int64 v11; // r13
  unsigned int v12; // ebx
  int v13; // er10
  unsigned int v14; // er11
  int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // ecx
  signed __int64 v18; // rcx
  void *v19; // rax
  __int64 result; // rax
  signed __int64 v21; // r9
  signed __int64 v22; // r10
  void *v23; // rax
  __int64 v24; // rax
  signed __int64 v25; // rsi
  void *v26; // rdi
  _QWORD *v27; // ST28_8
  signed __int64 *v28; // ST20_8
  unsigned __int8 *v29; // ST18_8
  signed __int64 v30; // ST10_8
  signed __int64 v31; // rcx
  __int16 v32; // ax
  __int64 v33; // rax
  unsigned __int8 *v34; // rdi
  signed __int64 v35; // rdx
  void *v36; // rdi
  signed __int64 v37; // rcx
  signed __int64 v38; // rsi
  __int64 v39; // rax
  signed __int64 v40; // r10
  void *v41; // rax
  __int64 v42; // rax
  signed __int64 *v43; // ST30_8
  unsigned __int8 *v44; // ST28_8
  unsigned int v45; // ST10_4
  int v46; // ST08_4
  _QWORD *v47; // ST28_8
  signed __int64 *v48; // ST20_8
  signed __int64 v49; // ST10_8
  signed __int64 v50; // ST08_8
  signed __int64 *v51; // ST30_8
  signed __int64 *v52; // ST28_8
  unsigned __int8 *v53; // ST20_8
  signed __int64 v54; // ST08_8
  signed __int64 v55; // rcx
  signed __int64 *v56; // ST30_8
  signed __int64 *v57; // ST28_8
  unsigned __int8 *v58; // ST20_8
  signed __int64 v59; // ST08_8
  _QWORD *v60; // [rsp+0h] [rbp-78h]
  signed __int64 v61; // [rsp+10h] [rbp-68h]
  signed __int64 v62; // [rsp+10h] [rbp-68h]
  signed __int64 v63; // [rsp+18h] [rbp-60h]
  signed __int64 *v64; // [rsp+38h] [rbp-40h]

  v6 = pfont;
  v7 = pfont->info.firstCol;
  v8 = (__int64 *)pfont->fontPrivate;
  v9 = pfont->fpePrivate;
  v60 = a6;
  v10 = v8[1];
  v11 = *v8;
  v12 = pfont->info.lastCol + 1 - v7;
  if ( a4 == 2 )
  {
    if ( *((_BYTE *)&pfont->info + 10) & 0x40 && v11 )
    {
      while ( 1 )
      {
        --a2;
        while ( 1 )
        {
          if ( a2 == -1 )
            goto LABEL_14;
          a3 += 2;
          v24 = (unsigned int)(unsigned __int16)__ROL2__(*((_WORD *)a3 - 1), 8) - v7;
          if ( v12 > (unsigned int)v24 )
            break;
          *a6 = v11;
LABEL_30:
          --a2;
          ++a6;
        }
        v22 = v10 + 24 * v24;
        if ( !v9[2] )
          break;
        v23 = *(void **)(v22 + 16);
        if ( v23 != &fs_glyph_requested && v23 != &fs_glyph_undefined )
          break;
        v51 = a6;
        v52 = a5;
        v53 = a3;
        v61 = (signed __int64)(a6 + 1);
        v54 = v22;
        result = fs_load_all_glyphs(pfont);
        v55 = v61;
        a3 = v53;
        a5 = v52;
        *v51 = v54;
        if ( (_DWORD)result != 85 )
          goto LABEL_83;
        a6 = (_QWORD *)v61;
      }
      *a6 = v22;
      goto LABEL_30;
    }
    while ( 1 )
    {
      v31 = a2 - 1;
      if ( !a2 )
        goto LABEL_14;
      v32 = *(_WORD *)a3;
      a3 += 2;
      v33 = (unsigned int)(unsigned __int16)__ROL2__(v32, 8) - v7;
      if ( v12 <= (unsigned int)v33 )
      {
        if ( !v11 )
          goto LABEL_41;
        do
        {
          --v31;
          ++a6;
          *(a6 - 1) = v11;
          if ( v31 == -1 )
            goto LABEL_14;
          a3 += 2;
          v33 = (unsigned int)(unsigned __int16)__ROL2__(*((_WORD *)a3 - 1), 8) - v7;
        }
        while ( v12 <= (unsigned int)v33 );
      }
      v25 = v10 + 24 * v33;
      result = 85LL;
      v26 = *(void **)(v25 + 16);
      if ( v9[2] && (v26 == &fs_glyph_requested || v26 == &fs_glyph_undefined) )
      {
        v27 = a6;
        v28 = a5;
        v29 = a3;
        v30 = v31;
        result = fs_load_all_glyphs(v6);
        a6 = v27;
        a5 = v28;
        a3 = v29;
        v31 = v30;
        v26 = *(void **)(v25 + 16);
      }
      if ( v26 )
      {
        *a6 = v25;
        ++a6;
      }
      else if ( v11 )
      {
        *a6 = v11;
        ++a6;
      }
      if ( (_DWORD)result != 85 )
        goto LABEL_22;
LABEL_41:
      a2 = v31;
    }
  }
  if ( a4 < 2 )
  {
    if ( !pfont->info.firstRow )
    {
      if ( *((_BYTE *)&pfont->info + 10) & 0x40 && v11 )
      {
LABEL_51:
        v34 = &a3[a2];
        while ( 1 )
        {
          --a2;
          if ( v34 == a3 )
            goto LABEL_14;
          v42 = (unsigned int)*(++a3 - 1) - v7;
          if ( v12 > (unsigned int)v42 )
          {
            v40 = v10 + 24 * v42;
            if ( v9[2] )
            {
              v41 = *(void **)(v40 + 16);
              if ( v41 == &fs_glyph_requested || v41 == &fs_glyph_undefined )
              {
                v56 = a6;
                v57 = a5;
                v58 = a3;
                v62 = (signed __int64)(a6 + 1);
                v59 = v40;
                result = fs_load_all_glyphs(v6);
                v55 = v62;
                a3 = v58;
                a5 = v57;
                *v56 = v59;
                if ( (_DWORD)result == 85 )
                {
                  a6 = (_QWORD *)v62;
                  goto LABEL_51;
                }
LABEL_83:
                v21 = (v55 - (signed __int64)v60) >> 3;
                goto LABEL_17;
              }
            }
            *a6 = v40;
          }
          else
          {
            *a6 = v11;
          }
          ++a6;
        }
      }
      while ( 1 )
      {
        v37 = a2 - 1;
        if ( !a2 )
          goto LABEL_14;
        v38 = (signed __int64)(a3 + 1);
        v39 = (unsigned int)*a3 - v7;
        if ( v12 > (unsigned int)v39 )
        {
LABEL_52:
          v35 = v10 + 24 * v39;
          result = 85LL;
          v36 = *(void **)(v35 + 16);
          if ( v9[2] && (v36 == &fs_glyph_requested || v36 == &fs_glyph_undefined) )
          {
            v47 = a6;
            v48 = a5;
            v49 = v35;
            v50 = v37;
            result = fs_load_all_glyphs(v6);
            v35 = v49;
            a6 = v47;
            a5 = v48;
            v37 = v50;
            v36 = *(void **)(v49 + 16);
          }
          if ( v36 )
          {
            *a6 = v35;
            ++a6;
          }
          else if ( v11 )
          {
            *a6 = v11;
            ++a6;
          }
          if ( (_DWORD)result != 85 )
            goto LABEL_22;
        }
        else if ( v11 )
        {
          while ( 1 )
          {
            --v37;
            ++a6;
            *(a6 - 1) = v11;
            if ( v37 == -1 )
              break;
            v39 = (unsigned int)*(unsigned __int8 *)(++v38 - 1) - v7;
            if ( v12 > (unsigned int)v39 )
              goto LABEL_52;
          }
LABEL_14:
          result = 85LL;
          v21 = a6 - v60;
          goto LABEL_17;
        }
        a3 = (unsigned __int8 *)v38;
        a2 = v37;
      }
    }
LABEL_16:
    v21 = 0LL;
    result = 85LL;
    goto LABEL_17;
  }
  if ( a4 != 3 )
    goto LABEL_16;
  v13 = pfont->info.firstRow;
  v14 = pfont->info.lastRow + 1 - v13;
LABEL_5:
  while ( 2 )
  {
    --a2;
LABEL_6:
    if ( a2 == -1 )
      goto LABEL_14;
    while ( 1 )
    {
      v15 = *a3;
      a3 += 2;
      v16 = v15 - v13;
      v17 = *(a3 - 1) - v7;
      if ( v14 <= v16 || v12 <= v17 )
      {
        if ( !v11 )
        {
          --a2;
          goto LABEL_6;
        }
        result = 85LL;
        goto LABEL_20;
      }
      v18 = v10 + 24LL * (v17 + v12 * v16);
      v19 = *(void **)(v18 + 16);
      if ( v9[2] )
      {
        if ( v19 == &fs_glyph_requested || v19 == &fs_glyph_undefined )
          break;
      }
      if ( !v19 )
      {
        if ( v11 )
        {
          *a6 = v11;
          ++a6;
        }
        goto LABEL_5;
      }
      --a2;
      *a6 = v18;
      ++a6;
      if ( a2 == -1 )
        goto LABEL_14;
    }
    v64 = a6;
    v43 = a5;
    v44 = a3;
    v63 = v18;
    v45 = v14;
    v46 = v13;
    result = fs_load_all_glyphs(pfont);
    v13 = v46;
    v14 = v45;
    a3 = v44;
    a5 = v43;
    a6 = v64;
    if ( !*(_QWORD *)(v63 + 16) )
    {
      if ( !v11 )
        goto LABEL_21;
LABEL_20:
      *a6 = v11;
      ++a6;
      goto LABEL_21;
    }
    *v64 = v63;
    a6 = v64 + 1;
LABEL_21:
    if ( (_DWORD)result == 85 )
      continue;
    break;
  }
LABEL_22:
  v21 = a6 - v60;
LABEL_17:
  *a5 = v21;
  return result;
}

//----- (0000000000025CD0) ----------------------------------------------------
__int64 __fastcall fs_convert_char_info(_WORD *a1, _WORD *a2)
{
  __int64 result; // rax

  a2[3] = a1[3];
  a2[4] = a1[4];
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = (unsigned __int16)a1[5];
  a2[5] = result;
  return result;
}

//----- (0000000000025D00) ----------------------------------------------------
__int64 __fastcall fs_init_fontinfo(__int64 a1, __int16 *a2)
{
  __int16 v2; // ax
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax

  if ( *(_DWORD *)(a1 + 48) == 1 )
  {
    v2 = *a2;
    v3 = a2[2];
    a2[4] = __ROL2__(a2[4], 8);
    *a2 = v3;
    a2[2] = v2;
    v4 = a2[1];
    a2[1] = a2[3];
    a2[3] = v4;
  }
  if ( (unsigned int)FontCouldBeTerminal(a2) )
  {
    v5 = a2[32];
    *((_BYTE *)a2 + 10) |= 2u;
    a2[17] = v5;
    a2[18] = a2[33];
    a2[14] = 0;
    a2[15] = a2[16];
    *((_QWORD *)a2 + 2) = *(_QWORD *)(a2 + 14);
    *((_DWORD *)a2 + 6) = *((_DWORD *)a2 + 9);
  }
  return FontComputeInfoAccelerators(a2);
}
// 8620: using guessed type __int64 __fastcall FontComputeInfoAccelerators(_QWORD);
// 8A10: using guessed type __int64 __fastcall FontCouldBeTerminal(_QWORD);

//----- (0000000000025D80) ----------------------------------------------------
__int64 __fastcall fs_convert_props(unsigned int *a1, unsigned int *a2, __int64 a3, __int64 a4)
{
  signed int v4; // er13
  unsigned int *v5; // rbx
  __int64 v6; // rbp
  Atom *v7; // rax
  Atom *v8; // r15
  Atom *v9; // r14
  char v10; // r12
  unsigned int v11; // ebp
  unsigned int v12; // er13
  __int64 v14; // [rsp+8h] [rbp-50h]
  signed __int64 v15; // [rsp+10h] [rbp-48h]
  unsigned int v16; // [rsp+1Ch] [rbp-3Ch]

  v4 = *a1;
  v14 = a3;
  v16 = *a1;
  *(_DWORD *)(a4 + 68) = *a1;
  if ( v4 >= 0 && (v5 = a2, v6 = a4, v7 = (Atom *)malloc(17LL * v4), (v8 = v7) != 0LL) )
  {
    v9 = &v7[2 * v4];
    *(_QWORD *)(v6 + 72) = v7;
    *(_QWORD *)(v6 + 80) = v9;
    if ( v4 )
    {
      v15 = (signed __int64)&a2[5LL * (unsigned int)(v4 - 1) + 5];
      do
      {
        v10 = *((_BYTE *)v5 + 16);
        v11 = v5[2];
        v12 = v5[3];
        *v8 = MakeAtom((char *)(v14 + *v5), v5[1], 1);
        if ( v10 )
        {
          *(_BYTE *)v9 = 0;
          v8[1] = v11;
        }
        else
        {
          *(_BYTE *)v9 = 1;
          v8[1] = (signed int)MakeAtom((char *)(v14 + v11), v12, 1);
        }
        v5 += 5;
        v8 += 2;
        v9 = (Atom *)((char *)v9 + 1);
      }
      while ( (unsigned int *)v15 != v5 );
    }
  }
  else
  {
    v16 = -1;
  }
  return v16;
}

//----- (0000000000025E80) ----------------------------------------------------
void __fastcall fs_free_props(__int64 a1)
{
  void *v1; // rax

  v1 = *(void **)(a1 + 72);
  if ( v1 )
  {
    free(v1);
    *(_DWORD *)(a1 + 68) = 0;
    *(_QWORD *)(a1 + 72) = 0LL;
  }
}

//----- (0000000000025EC0) ----------------------------------------------------
void __fastcall sub_25EC0(FontPtr font)
{
  struct _Font *v1; // rbp
  _QWORD *v2; // rbx
  Font *v3; // r12
  _QWORD *v4; // rdi

  v1 = font;
  v2 = font->fontPrivate;
  v3 = (Font *)font->fpePrivate;
  v4 = (_QWORD *)v2[1];
  if ( v4 )
    goto LABEL_4;
  while ( 1 )
  {
    v4 = (_QWORD *)v2[3];
    if ( !v4 )
      break;
    v2[3] = *v4;
LABEL_4:
    free(v4);
  }
  if ( find_old_font(*v3) )
    DeleteFontClientID(*v3);
  _fs_free_props(&v1->info);
  free(v2);
  DestroyFontRec(v1);
}
// 8EE0: using guessed type __int64 __fastcall find_old_font(_QWORD);
// 9080: using guessed type __int64 __fastcall _fs_free_props(_QWORD);

//----- (0000000000025F30) ----------------------------------------------------
__int64 __fastcall fs_convert_lfwi_reply(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // r12
  __int64 v8; // r13

  v6 = a4;
  v7 = a5;
  v8 = a6;
  *(_BYTE *)(a2 + 10) = ((*(_BYTE *)(a3 + 12) & 1) << 6) | *(_BYTE *)(a2 + 10) & 0xBF;
  *(_WORD *)(a2 + 10) = ((*(_BYTE *)(a3 + 20) != 0) << 7) | *(_WORD *)(a2 + 10) & 0xFE7F;
  *(_BYTE *)(a2 + 10) = *(_BYTE *)(a2 + 10) & 0xEF | 16 * ((*(_DWORD *)(a3 + 12) >> 1) & 1);
  *(_WORD *)(a2 + 4) = *(unsigned __int8 *)(a3 + 16);
  *(_WORD *)a2 = *(unsigned __int8 *)(a3 + 17);
  *(_WORD *)(a2 + 6) = *(unsigned __int8 *)(a3 + 18);
  *(_WORD *)(a2 + 2) = *(unsigned __int8 *)(a3 + 19);
  *(_WORD *)(a2 + 8) = *(unsigned __int8 *)(a3 + 23) + (*(unsigned __int8 *)(a3 + 22) << 8);
  *(_WORD *)(a2 + 66) = *(_WORD *)(a3 + 50);
  *(_WORD *)(a2 + 64) = *(_WORD *)(a3 + 48);
  *(_WORD *)(a2 + 28) = *(_WORD *)(a3 + 24);
  *(_WORD *)(a2 + 30) = *(_WORD *)(a3 + 26);
  *(_WORD *)(a2 + 32) = *(_WORD *)(a3 + 28);
  *(_WORD *)(a2 + 34) = *(_WORD *)(a3 + 30);
  *(_WORD *)(a2 + 36) = *(_WORD *)(a3 + 32);
  *(_WORD *)(a2 + 38) = *(_WORD *)(a3 + 34);
  *(_WORD *)(a2 + 52) = *(_WORD *)(a3 + 24);
  *(_WORD *)(a2 + 54) = *(_WORD *)(a3 + 26);
  *(_WORD *)(a2 + 56) = *(_WORD *)(a3 + 28);
  *(_WORD *)(a2 + 58) = *(_WORD *)(a3 + 30);
  *(_WORD *)(a2 + 60) = *(_WORD *)(a3 + 32);
  *(_WORD *)(a2 + 62) = *(_WORD *)(a3 + 34);
  *(_WORD *)(a2 + 16) = *(_WORD *)(a3 + 36);
  *(_WORD *)(a2 + 18) = *(_WORD *)(a3 + 38);
  *(_WORD *)(a2 + 20) = *(_WORD *)(a3 + 40);
  *(_WORD *)(a2 + 22) = *(_WORD *)(a3 + 42);
  *(_WORD *)(a2 + 24) = *(_WORD *)(a3 + 44);
  *(_WORD *)(a2 + 26) = *(_WORD *)(a3 + 46);
  *(_WORD *)(a2 + 40) = *(_WORD *)(a3 + 36);
  *(_WORD *)(a2 + 42) = *(_WORD *)(a3 + 38);
  *(_WORD *)(a2 + 44) = *(_WORD *)(a3 + 40);
  *(_WORD *)(a2 + 46) = *(_WORD *)(a3 + 42);
  *(_WORD *)(a2 + 48) = *(_WORD *)(a3 + 44);
  *(_WORD *)(a2 + 50) = *(_WORD *)(a3 + 46);
  _fs_init_fontinfo(a1, a2);
  return 5 * (unsigned int)((unsigned int)_fs_convert_props(v6, v7, v8, a2) != -1) + 80;
}
// 8130: using guessed type __int64 __fastcall _fs_init_fontinfo(_QWORD, _QWORD);
// 8FD0: using guessed type __int64 __fastcall _fs_convert_props(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000260D0) ----------------------------------------------------
__int64 __fastcall fs_build_range(__int64 a1, int a2, unsigned int a3, int a4, unsigned __int8 *a5, __int64 a6, __int64 a7)
{
  __int64 *v7; // rax
  int v8; // ebp
  __int64 v9; // r12
  unsigned __int8 *v10; // rbx
  __int64 v11; // r13
  unsigned __int64 v12; // rcx
  unsigned __int16 v13; // si
  unsigned __int64 v14; // rdi
  void *v15; // rax
  signed int v16; // edx
  unsigned __int8 *v17; // r13
  unsigned __int64 v18; // rax
  void *v19; // rax
  __int64 result; // rax
  unsigned __int64 v21; // rbp
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r15
  unsigned __int64 v24; // r14
  unsigned __int64 v25; // r15
  unsigned __int64 v26; // rbx
  unsigned __int64 v27; // r13
  void **v28; // r14
  void *v29; // rax
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // rsi
  int v32; // eax
  int v33; // eax
  unsigned __int64 v34; // rbp
  int v35; // er8
  unsigned __int64 v36; // r14
  unsigned __int64 v37; // r12
  void **v38; // r14
  void *v39; // rax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // rdx
  __int64 v42; // [rsp+8h] [rbp-E0h]
  unsigned __int64 v43; // [rsp+18h] [rbp-D0h]
  unsigned int v44; // [rsp+20h] [rbp-C8h]
  int v45; // [rsp+3Ch] [rbp-ACh]
  unsigned __int64 v46; // [rsp+40h] [rbp-A8h]
  __int64 v47; // [rsp+48h] [rbp-A0h]
  int v48; // [rsp+50h] [rbp-98h]
  int v49; // [rsp+50h] [rbp-98h]
  int v50; // [rsp+54h] [rbp-94h]
  signed __int64 v51; // [rsp+58h] [rbp-90h]
  char v52; // [rsp+60h] [rbp-88h]
  unsigned __int64 v53; // [rsp+68h] [rbp-80h]
  int v54; // [rsp+70h] [rbp-78h]
  signed __int64 v55; // [rsp+78h] [rbp-70h]
  unsigned __int16 v56; // [rsp+9Ah] [rbp-4Eh]
  unsigned __int16 v57; // [rsp+9Ch] [rbp-4Ch]
  unsigned __int16 v58; // [rsp+9Eh] [rbp-4Ah]
  char v59; // [rsp+A0h] [rbp-48h]
  char v60; // [rsp+A1h] [rbp-47h]
  char v61; // [rsp+A2h] [rbp-46h]
  char v62; // [rsp+A3h] [rbp-45h]
  char v63; // [rsp+A4h] [rbp-44h]
  char v64; // [rsp+A5h] [rbp-43h]
  char v65; // [rsp+A6h] [rbp-42h]
  char v66; // [rsp+A7h] [rbp-41h]
  unsigned __int64 v67; // [rsp+A8h] [rbp-40h]

  v50 = a2;
  v42 = a6;
  v67 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL) )
    return 1024LL;
  v7 = *(__int64 **)(a1 + 152);
  v8 = a4;
  v9 = a3;
  v10 = a5;
  v11 = *v7;
  v58 = *(_WORD *)(a1 + 12);
  v52 = *(_WORD *)(a1 + 12);
  v12 = *(unsigned __int16 *)(a1 + 8);
  v47 = v7[1];
  v13 = *(_WORD *)(a1 + 14);
  v14 = *(unsigned __int16 *)(a1 + 10);
  v57 = v12;
  v43 = v12;
  v56 = v13;
  if ( *v7 )
  {
    v15 = *(void **)(v11 + 16);
    if ( v15 == &fs_glyph_undefined )
    {
      v40 = v14 + 1 - v12;
      v41 = -6148914691236517205LL * ((v11 - v47) >> 3) % v40;
      v62 = v43 + v41;
      v60 = v43 + v41;
      v61 = v52 + -6148914691236517205LL * ((v11 - v47) >> 3) / v40;
      v59 = v52 + -6148914691236517205LL * ((v11 - v47) >> 3) / v40;
      result = add_range(&v59, a6, a7, 0LL);
      if ( (_DWORD)result != 85 )
        return result;
      v16 = 0;
      *(_QWORD *)(v11 + 16) = &fs_glyph_requested;
    }
    else
    {
      v16 = v15 != &fs_glyph_requested;
    }
    if ( v50 )
      goto LABEL_18;
  }
  else
  {
    v16 = 1;
    if ( v50 )
      goto LABEL_18;
  }
  if ( v8 != 1 )
  {
LABEL_18:
    if ( v50 && !(_DWORD)v9 )
    {
      v10 = (unsigned __int8 *)&v63;
      LODWORD(v9) = 2;
      v63 = v58;
      v64 = v57;
      v65 = v13;
      v66 = v14;
    }
    while ( 1 )
    {
      v54 = v9 - 1;
      if ( !(_DWORD)v9 )
        goto LABEL_14;
      v21 = *v10;
      v55 = (signed __int64)(v10 + 2);
      v45 = v10[1];
      v22 = v10[1];
      if ( v50 )
      {
        if ( (_DWORD)v9 == 1 )
        {
          v30 = v14;
          v44 = v56;
          v49 = (unsigned __int16)v14;
          v53 = v56;
        }
        else
        {
          v44 = v10[2];
          v53 = v10[2];
          v55 = (signed __int64)(v10 + 4);
          v30 = v10[3];
          v49 = v10[3];
          v54 = v9 - 2;
        }
        v23 = *v10;
        if ( v58 > v21 )
        {
          LODWORD(v21) = v58;
          v23 = v58;
        }
        if ( v56 < v53 )
        {
          v53 = v56;
          v44 = v56;
        }
        v31 = (unsigned __int8)v22;
        v32 = v57;
        if ( v31 >= v43 )
          v32 = v10[1];
        v45 = v32;
        v33 = (unsigned __int16)v14;
        if ( v14 >= v30 )
          v33 = v49;
        v48 = v33;
        if ( v23 > v53 )
          goto LABEL_42;
      }
      else
      {
        if ( v58 > v21 || v56 < v21 || v22 < v43 || v22 > v14 )
          goto LABEL_42;
        v23 = *v10;
        v53 = *v10;
        v44 = *v10;
        v48 = v10[1];
      }
      v46 = v45;
      v51 = (v14 + 1 - v43) * (v23 - v58) - v43;
      v24 = v23;
      v25 = v48;
      do
      {
        while ( 1 )
        {
          v26 = v46;
          if ( v46 > v25 )
            break;
          v27 = v24;
          v28 = (void **)(v47 + 24 * (v46 + v51) + 16);
          while ( 1 )
          {
            while ( 1 )
            {
              v29 = *v28;
              if ( *v28 == &fs_glyph_undefined )
                break;
              LOBYTE(v29) = v29 != &fs_glyph_requested;
              ++v26;
              v28 += 3;
              v16 &= (unsigned int)v29;
              if ( v26 > v25 )
                goto LABEL_40;
            }
            if ( v44 == (_DWORD)v21 && (v45 & 0xF && v46 > v43 || (v48 & 0xF) != 15) && v14 > v25 )
              break;
            v62 = v26;
            v60 = v26;
            v61 = v27;
            v59 = v27;
            result = add_range(&v59, v42, a7, 0LL);
            if ( (_DWORD)result != 85 )
              return result;
            ++v26;
            v16 = 0;
            v28 += 3;
            *(v28 - 3) = &fs_glyph_requested;
            if ( v26 > v25 )
            {
LABEL_40:
              v24 = v27;
              goto LABEL_41;
            }
          }
          v45 &= 0xF0u;
          v24 = v27;
          v48 = (unsigned __int8)(v48 & 0xF0) + 15;
          v46 = v45;
          if ( v45 < v43 )
          {
            LOBYTE(v45) = v57;
            v46 = v57;
          }
          v25 = v48;
          if ( v48 > v14 )
          {
            v25 = (unsigned __int16)v14;
            LOBYTE(v48) = v14;
          }
        }
LABEL_41:
        ++v24;
        v51 += v14 + 1 - v43;
      }
      while ( v24 <= v53 );
LABEL_42:
      v10 = (unsigned __int8 *)v55;
      LODWORD(v9) = v54;
    }
  }
  if ( v58 )
    return 1024LL;
  v17 = &v10[v9];
LABEL_9:
  while ( v10 != v17 )
  {
    while ( 1 )
    {
      v18 = *(++v10 - 1);
      if ( v43 > v18 || v14 < v18 )
        break;
      v19 = *(void **)(v47 + 24 * (v18 - v43) + 16);
      if ( v19 == &fs_glyph_undefined )
      {
        v34 = *(v10 - 1) & 0xF0;
        v35 = v34 + 15;
        v36 = (signed int)v34 + 15;
        if ( v34 < v43 )
          v34 = v43;
        if ( v35 > v14 )
          v36 = v14;
        if ( v34 <= v36 )
        {
          v37 = v36;
          v38 = (void **)(v47 + 24 * (v34 - v43) + 16);
          while ( 1 )
          {
            v39 = *v38;
            if ( *v38 == &fs_glyph_undefined )
            {
              v62 = v34;
              v60 = v34;
              v61 = 0;
              v59 = 0;
              result = add_range(&v59, v42, a7, 0LL);
              if ( (_DWORD)result != 85 )
                return result;
              v16 = 0;
              *v38 = &fs_glyph_requested;
            }
            else
            {
              LOBYTE(v39) = v39 != &fs_glyph_requested;
              v16 &= (unsigned int)v39;
            }
            ++v34;
            v38 += 3;
            if ( v34 > v37 )
              goto LABEL_9;
          }
        }
        goto LABEL_9;
      }
      LOBYTE(v19) = v19 != &fs_glyph_requested;
      v16 &= (unsigned int)v19;
      if ( v10 == v17 )
        goto LABEL_14;
    }
  }
LABEL_14:
  if ( v16 )
    return 1024LL;
  return 85LL;
}
// 8010: using guessed type __int64 __fastcall add_range(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000267A0) ----------------------------------------------------
unsigned __int64 __fastcall fs_clean_aborted_loadglyphs(__int64 a1, signed int a2, unsigned __int8 *a3)
{
  __int64 v3; // r10
  unsigned __int8 v4; // al
  __int16 v5; // cx
  unsigned __int8 *v6; // r8
  signed int v7; // er11
  signed int v8; // er9
  int v9; // ecx
  int v10; // eax
  signed __int64 i; // rdx
  __int16 v13; // dx
  char v14; // [rsp+4h] [rbp-24h]
  char v15; // [rsp+5h] [rbp-23h]
  char v16; // [rsp+6h] [rbp-22h]
  char v17; // [rsp+7h] [rbp-21h]
  unsigned __int64 v18; // [rsp+8h] [rbp-20h]

  v3 = *(_QWORD *)(a1 + 152);
  v18 = __readfsqword(0x28u);
  if ( *(_QWORD *)(v3 + 8) )
  {
    if ( a2 )
    {
      if ( a2 <= 0 )
        return __readfsqword(0x28u) ^ v18;
      v4 = *a3;
      LOBYTE(v5) = a3[2];
    }
    else
    {
      v13 = *(_WORD *)(a1 + 12);
      a2 = 1;
      v15 = *(_WORD *)(a1 + 8);
      v14 = v13;
      v4 = v13;
      v17 = *(_WORD *)(a1 + 10);
      v5 = *(_WORD *)(a1 + 14);
      v16 = *(_WORD *)(a1 + 14);
      a3 = (unsigned __int8 *)&v14;
    }
    v6 = a3 + 1;
    v7 = 0;
    while ( 1 )
    {
      v8 = v4;
      if ( (unsigned __int8)v5 >= v4 )
      {
        v9 = v6[2];
        do
        {
          v10 = *v6;
          for ( i = *(_QWORD *)(v3 + 8)
                  + 24LL
                  * (v10
                   + (v8 - *(unsigned __int16 *)(a1 + 12))
                   * (*(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 8) + 1)
                   - *(unsigned __int16 *)(a1 + 8)); v9 >= v10; v9 = v6[2] )
          {
            while ( *(_UNKNOWN **)(i + 16) != &fs_glyph_requested )
            {
              ++v10;
              i += 24LL;
              if ( v9 < v10 )
                goto LABEL_13;
            }
            ++v10;
            i += 24LL;
            *(_QWORD *)(i - 8) = &fs_glyph_undefined;
          }
LABEL_13:
          ++v8;
        }
        while ( v6[1] >= v8 );
      }
      ++v7;
      v6 += 4;
      if ( v7 >= a2 )
        break;
      v4 = *(v6 - 1);
      LOBYTE(v5) = v6[1];
    }
  }
  return __readfsqword(0x28u) ^ v18;
}

//----- (0000000000026900) ----------------------------------------------------
FontPtr __fastcall fs_create_font(struct _FontPathElement *a1, const void *a2, int a3, fsBitmapFormat a4, int a5)
{
  int v5; // er14
  size_t v6; // rbp
  fsBitmapFormat v7; // er12
  FontPtr v8; // rbx
  _OWORD *v9; // rax
  _OWORD *v10; // r13
  char v11; // al
  char v12; // al
  Font v13; // rax
  struct _Font *v15; // rdi
  int v16; // [rsp+18h] [rbp-50h]
  int v17; // [rsp+1Ch] [rbp-4Ch]
  int v18; // [rsp+20h] [rbp-48h]
  int v19; // [rsp+24h] [rbp-44h]
  unsigned __int64 v20; // [rsp+28h] [rbp-40h]

  v5 = a5;
  v6 = a3;
  v7 = a4;
  v20 = __readfsqword(0x28u);
  v8 = CreateFontRec();
  if ( v8 )
  {
    v9 = malloc(v6 + 81);
    v10 = v9;
    if ( v9 )
    {
      *v9 = 0LL;
      v9[1] = 0LL;
      v9[2] = 0LL;
      v9[3] = 0LL;
      v9[4] = 0LL;
      v8->fpe = a1;
      v8->fontPrivate = v9;
      v8->fpePrivate = v9 + 2;
      CheckFSFormat(v7, 27LL, &v16, &v17, &v18, &v19, 0LL);
      v11 = v16;
      v8->format = v7;
      v8->info.nprops = 0;
      v8->info.props = 0LL;
      v8->info.isStringProp = 0LL;
      v8->bit = v11;
      v12 = v17;
      v8->unload_glyphs = 0LL;
      v8->byte = v12;
      v8->scan = v18;
      v8->glyph = v19;
      v8->get_glyphs = (int (*)(FontPtr, unsigned __int64, unsigned __int8 *, FontEncoding, unsigned __int64 *, CharInfoPtr *))sub_25730;
      v8->get_metrics = (int (*)(FontPtr, unsigned __int64, unsigned __int8 *, FontEncoding, unsigned __int64 *, xCharInfo **))sub_254C0;
      v8->unload_font = (void (*)(FontPtr))sub_25EC0;
      *((_QWORD *)v10 + 8) = v10 + 5;
      *((_DWORD *)v10 + 18) = v7;
      *((_DWORD *)v10 + 19) = v5;
      memcpy(v10 + 5, a2, v6);
      *((_BYTE *)v10 + v6 + 80) = 0;
      v13 = GetNewFontClientID();
      *((_QWORD *)v10 + 4) = v13;
      if ( StoreFontClientFont(v8, v13) )
        return v8;
      free(v10);
    }
    v15 = v8;
    v8 = 0LL;
    DestroyFontRec(v15);
  }
  return v8;
}
// 8EB0: using guessed type __int64 __fastcall CheckFSFormat(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000026AA0) ----------------------------------------------------
signed __int64 __fastcall fs_alloc_glyphs(__int64 a1, int a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax

  v2 = *(_QWORD *)(a1 + 152);
  v3 = malloc(a2 + 8LL);
  *v3 = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(v2 + 24) = v3;
  return (signed __int64)(v3 + 1);
}

//----- (0000000000026AD0) ----------------------------------------------------
__int64 __fastcall sub_26AD0(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rbp
  __int64 v3; // rdi
  __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+8h] [rbp-20h]

  v2 = a1;
  v3 = *(signed int *)(a1 + 8);
  v6 = __readfsqword(0x28u);
  if ( (_DWORD)v3 != -1
    && (1LL << (char)*(_DWORD *)(v2 + 8) % 64) & fs_fd_mask[__fdelt_chk(v3)]
    && (unsigned int)_fs_start_read(v2, 8LL, &v5) == 1
    && (unsigned int)_fs_start_read(v2, (unsigned int)(4 * *(_DWORD *)(v5 + 4)), &v5) == 1 )
  {
    *a2 = 1;
    result = v5;
  }
  else
  {
    *a2 = 0;
    result = 0LL;
  }
  return result;
}
// 8470: using guessed type __int64 __fastcall _fs_start_read(_QWORD, _QWORD, _QWORD);
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);

//----- (0000000000026B90) ----------------------------------------------------
void __fastcall sub_26B90(__int64 *a1)
{
  __int64 i; // rbx

  for ( i = *a1; *a1; i = *a1 )
  {
    *a1 = *(_QWORD *)(i + 8);
    ClientSignal(*(ClientPtr *)i);
    free((void *)i);
  }
}

//----- (0000000000026BD0) ----------------------------------------------------
void __fastcall block_handler(pointer a1, OSTimePtr a2, pointer a3)
{
  OSTimePtr v3; // rbp
  __int64 v4; // rax
  _QWORD *v5; // rdi
  char v6; // al
  __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rcx
  int v10; // edx
  int v11; // esi
  int v12; // edx
  signed __int64 v13; // rcx
  signed __int64 v14; // rsi
  __int64 v15; // rax
  __m128i *v16; // rsi

  v3 = a2;
  v4 = 0LL;
  v5 = fs_fd_mask;
  do
  {
    *(_QWORD *)((char *)a3 + v4 * 8) |= fs_fd_mask[v4];
    ++v4;
  }
  while ( v4 != 16 );
  v6 = dword_23CD18;
  if ( dword_23CD18 & 1 && (v7 = qword_23CD20) != 0 )
  {
    do
    {
      while ( *(_BYTE *)(v7 + 152) & 1 )
      {
        v5 = (_QWORD *)v7;
        _fs_flush(v7);
        v7 = *(_QWORD *)v7;
        if ( !v7 )
          goto LABEL_12;
      }
      v7 = *(_QWORD *)v7;
    }
    while ( v7 );
LABEL_12:
    v6 = dword_23CD18;
    if ( dword_23CD18 & 0x20 )
    {
LABEL_6:
      xmmword_23CD00 = 0uLL;
      if ( *a2 )
      {
        *(__m128i *)*a2 = _mm_load_si128((const __m128i *)&xmmword_23CD00);
        return;
      }
LABEL_34:
      *v3 = (struct timeval *)&xmmword_23CD00;
      return;
    }
  }
  else if ( dword_23CD18 & 0x20 )
  {
    goto LABEL_6;
  }
  if ( v6 & 0x4E )
  {
    v8 = GetTimeInMillis(v5);
    v9 = qword_23CD20;
    v10 = v8 + 10000000;
    if ( qword_23CD20 )
    {
      do
      {
        v11 = *(_DWORD *)(v9 + 152);
        if ( v11 & 0x40 && *(_DWORD *)(v9 + 164) - v10 < 0 )
          v10 = *(_DWORD *)(v9 + 164);
        if ( v11 & 4 && *(_DWORD *)(v9 + 168) - v10 < 0 )
          v10 = *(_DWORD *)(v9 + 168);
        if ( v11 & 2 && *(_DWORD *)(v9 + 160) - v10 < 0 )
          v10 = *(_DWORD *)(v9 + 160);
        if ( v11 & 8 && *(_DWORD *)(v9 + 156) - v10 < 0 )
          v10 = *(_DWORD *)(v9 + 156);
        v9 = *(_QWORD *)v9;
      }
      while ( v9 );
      v12 = v10 - v8;
      v13 = v12;
      if ( v12 < 0 )
        v13 = 0LL;
      v14 = (unsigned int)v13 / 0x3E8;
      v15 = (signed int)(1000 * ((unsigned int)v13 % 0x3E8));
    }
    else
    {
      v15 = 0LL;
      v14 = 10000LL;
      v13 = 10000000LL;
    }
    *(_QWORD *)&xmmword_23CD00 = v14;
    *((_QWORD *)&xmmword_23CD00 + 1) = v15;
    v16 = (__m128i *)*v3;
    if ( !*v3 )
      goto LABEL_34;
    if ( v13 < 1000 * v16->m128i_i64[0]
             + ((signed __int64)((unsigned __int128)(2361183241434822607LL * (signed __int128)v16->m128i_i64[1]) >> 64) >> 7)
             - (v16->m128i_i64[1] >> 63) )
      *v16 = _mm_load_si128((const __m128i *)&xmmword_23CD00);
  }
}
// 8890: using guessed type __int64 __fastcall _fs_flush(_QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 23CD00: using guessed type __int128 xmmword_23CD00;
// 23CD18: using guessed type int dword_23CD18;
// 23CD20: using guessed type __int64 qword_23CD20;

//----- (0000000000026DB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_26DB0(__int64 a1)
{
  FontResolutionPtr v1; // rbp
  int v2; // eax
  int v4; // [rsp+0h] [rbp-28h]
  char v5; // [rsp+4h] [rbp-24h]
  char v6; // [rsp+5h] [rbp-23h]
  __int16 v7; // [rsp+6h] [rbp-22h]
  unsigned __int64 v8; // [rsp+8h] [rbp-20h]

  v8 = __readfsqword(0x28u);
  v1 = GetClientResolutions(&v4);
  v2 = v4;
  if ( v4 )
  {
    v6 = v4;
    ++*(_DWORD *)(a1 + 16);
    v5 = 11;
    v7 = (6 * v2 + 7) >> 2;
    if ( (unsigned int)_fs_write(a1, &v5, 4LL) != -1 )
      _fs_write_pad(a1, v1, 6 * v4);
  }
  return __readfsqword(0x28u) ^ v8;
}
// 8760: using guessed type __int64 __fastcall _fs_write_pad(_QWORD, _QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000026E50) ----------------------------------------------------
_BOOL8 __fastcall sub_26E50(char *name)
{
  _BOOL8 result; // rax

  result = 0LL;
  if ( name )
  {
    if ( *name != 47 )
      result = strchr(name, 47) != 0LL;
  }
  return result;
}

//----- (0000000000026E90) ----------------------------------------------------
char *__fastcall sub_26E90(const char *a1)
{
  char *v1; // rax
  char *result; // rax

  v1 = strchr(a1, 47);
  if ( v1 )
    result = strrchr(v1 + 1, 47);
  else
    result = 0LL;
  return result;
}

//----- (0000000000026EC0) ----------------------------------------------------
__int64 __fastcall sub_26EC0(__int64 a1)
{
  FontResolutionPtr v1; // rbx
  int v2; // eax
  __int64 v3; // rax
  char *v4; // rax
  const char *v5; // rbp
  int v6; // er14
  char v7; // r13
  int v8; // eax
  char *v9; // rbx
  __int64 result; // rax
  char *v11; // rsi
  char *v12; // rbp
  __int64 v13; // rax
  char v14; // [rsp+Bh] [rbp-3Dh]
  int v15; // [rsp+Ch] [rbp-3Ch]
  char v16; // [rsp+10h] [rbp-38h]
  char v17; // [rsp+11h] [rbp-37h]
  __int16 v18; // [rsp+12h] [rbp-36h]
  char v19; // [rsp+14h] [rbp-34h]
  char v20; // [rsp+15h] [rbp-33h]
  __int16 v21; // [rsp+16h] [rbp-32h]
  unsigned __int64 v22; // [rsp+18h] [rbp-30h]

  v22 = __readfsqword(0x28u);
  v1 = GetClientResolutions(&v15);
  v2 = v15;
  if ( v15 )
  {
    v17 = v15;
    ++*(_DWORD *)(a1 + 16);
    v16 = 11;
    v18 = (6 * v2 + 7) >> 2;
    if ( (unsigned int)_fs_write(a1, &v16, 4LL) != 1 || (unsigned int)_fs_write_pad(a1, v1, 6 * v15) != 1 )
      return 0xFFFFFFFFLL;
  }
  v3 = *(signed int *)(a1 + 44);
  if ( !(_DWORD)v3 || (v4 = sub_26E90(*(const char **)(*(_QWORD *)(a1 + 56) + 16 * v3 - 16))) == 0LL )
  {
    v4 = sub_26E90(*(const char **)(a1 + 24));
    if ( !v4 )
    {
      *(_DWORD *)(a1 + 32) = 0;
      return 1LL;
    }
  }
  *(_DWORD *)(a1 + 32) = 1;
  v5 = v4 + 1;
  if ( v4[1] )
  {
    v6 = 0;
    v7 = 0;
    do
    {
      ++v7;
      v9 = strchr(v5, 43);
      if ( !v9 )
        v9 = (char *)&v5[strlen(v5)];
      v8 = (_DWORD)v9 - (_DWORD)v5;
      v5 = v9;
      v6 += v8 + 1;
    }
    while ( *v9 );
    LODWORD(v4) = (v6 + 7) >> 2;
  }
  else
  {
    v9 = v4 + 1;
    LOWORD(v4) = 1;
    v7 = 0;
    v6 = 0;
  }
  ++*(_DWORD *)(a1 + 16);
  v11 = &v19;
  v19 = 4;
  v20 = v7;
  v21 = (signed __int16)v4;
  if ( (unsigned int)_fs_write(a1, &v19, 4LL) != 1 )
    return 0xFFFFFFFFLL;
  while ( *v9 )
  {
    v12 = strchr(v9, 43);
    if ( !v12 )
      v12 = &v9[strlen(v9)];
    v14 = (_BYTE)v12 - (_BYTE)v9;
    if ( (unsigned int)_fs_write(a1, &v14, 1LL) == 1 )
    {
      v11 = v9;
      v9 = v12;
      if ( (unsigned int)_fs_write(a1, v11, v14) == 1 )
        continue;
    }
    return 0xFFFFFFFFLL;
  }
  v13 = _fs_pad_length(v6, v11);
  result = _fs_write(a1, "....", v13 - v6);
  if ( (_DWORD)result != 1 )
    return 0xFFFFFFFFLL;
  return result;
}
// 85A0: using guessed type __int64 __fastcall _fs_pad_length(_QWORD, _QWORD);
// 8760: using guessed type __int64 __fastcall _fs_write_pad(_QWORD, _QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000027130) ----------------------------------------------------
signed __int64 __fastcall sub_27130(FontPathElementPtr fpe)
{
  sub_26EC0((__int64)fpe->c_private);
  return 85LL;
}

//----- (0000000000027150) ----------------------------------------------------
_BOOL8 __fastcall sub_27150(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rdx
  signed __int64 v3; // rax

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 == -1 )
    return 0LL;
  if ( (1LL << (char)*(_DWORD *)(a1 + 8) % 64) & fs_fd_mask[__fdelt_chk(v1)] )
  {
    v2 = *(_QWORD *)(a1 + 136);
    v3 = *(_QWORD *)(a1 + 128) - v2;
    if ( (unsigned __int64)v3 > 7 )
      return v3 >= (unsigned int)(4 * *(_DWORD *)(*(_QWORD *)(a1 + 112) + v2 + 4));
  }
  return 0LL;
}
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);

//----- (00000000000271D0) ----------------------------------------------------
signed __int64 __fastcall sub_271D0(__int64 a1, int a2)
{
  int v3; // [rsp+0h] [rbp-18h]
  int v4; // [rsp+4h] [rbp-14h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v5 = __readfsqword(0x28u);
  if ( !(*(_BYTE *)(a1 + 152) & 0x10) )
  {
    ++*(_DWORD *)(a1 + 16);
    v4 = a2;
    v3 = 131093;
    _fs_write(a1, &v3, 8LL);
  }
  return 85LL;
}
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000027230) ----------------------------------------------------
void __fastcall sub_27230(FontPathElementPtr fpe, FontPtr pFont)
{
  _DWORD *v2; // rax
  FontPtr v3; // rbx
  _DWORD *v4; // rdi
  __int64 v5; // rsi

  v2 = pFont->fpePrivate;
  v3 = pFont;
  v4 = fpe->c_private;
  if ( v4[9] == v2[2] )
  {
    v5 = *(_QWORD *)v2;
    sub_271D0((__int64)v4, *(_QWORD *)v2);
    ((void (__fastcall *)(FontPtr, __int64))v3->unload_font)(v3, v5);
  }
  else
  {
    ((void (__fastcall *)(FontPtr))pFont->unload_font)(pFont);
  }
}

//----- (0000000000027270) ----------------------------------------------------
signed __int64 __fastcall sub_27270(signed __int64 *a1)
{
  signed __int64 result; // rax
  __int64 v2; // rbp

  result = *a1;
  if ( *a1 )
  {
    v2 = *(_QWORD *)(result + 160);
    result = sub_271D0(*(_QWORD *)(*(_QWORD *)(result + 136) + 24LL), a1[1]);
    if ( *((_BYTE *)a1 + 20) & 0x20 )
    {
      *(_DWORD *)(v2 + 8) = -1;
    }
    else
    {
      result = *((unsigned int *)a1 + 6);
      if ( (_DWORD)result )
        result = (*(__int64 (__fastcall **)(signed __int64))(*a1 + 120))(*a1);
      *a1 = 0LL;
    }
  }
  return result;
}

//----- (00000000000272E0) ----------------------------------------------------
_QWORD *__fastcall sub_272E0(__int64 a1, __int64 a2, int a3)
{
  int v3; // ebx
  _QWORD *result; // rax
  __int64 v5; // rcx
  _QWORD *v6; // rcx

  v3 = a3;
  result = malloc(dword_33FC0[a3 - 1] + 56LL);
  if ( result )
  {
    v5 = *(_QWORD *)(a1 + 176);
    result[1] = a2;
    *((_DWORD *)result + 8) = 81;
    *(_DWORD *)result = v3;
    result[3] = result + 7;
    result[5] = 0LL;
    *((_WORD *)result + 8) = -1;
    result[6] = 0LL;
    if ( v5 )
    {
      while ( *(_QWORD *)(v5 + 48) )
        v5 = *(_QWORD *)(v5 + 48);
      v6 = (_QWORD *)(v5 + 48);
    }
    else
    {
      v6 = (_QWORD *)(a1 + 176);
    }
    *v6 = result;
  }
  return result;
}

//----- (0000000000027370) ----------------------------------------------------
__int64 __fastcall sub_27370(__int64 a1, int *a2, _QWORD *a3)
{
  __int64 v3; // r14
  __int64 v4; // rax
  _DWORD *v5; // r15
  __int64 v6; // r10
  unsigned int v7; // er12
  __int64 v8; // r8
  __int64 v9; // rbp
  __int64 v10; // rbx
  __int64 v11; // ST30_8
  char *v12; // r9
  __int64 v13; // r10
  int v14; // edx
  __int64 v15; // r13
  void *v16; // r11
  signed __int64 v17; // rcx
  _DWORD *v18; // r8
  unsigned __int16 *v19; // r15
  __int64 v20; // r14
  signed __int64 v21; // r12
  signed __int64 v22; // rax
  void *v23; // rsi
  __int64 v24; // rdx
  int v25; // esi
  int v26; // edi
  int v27; // eax
  unsigned int v28; // ebx
  signed __int64 v30; // ST48_8
  __int64 v31; // ST50_8
  void *v32; // ST40_8
  _DWORD *v33; // ST38_8
  char *v34; // ST30_8
  void *v35; // rax
  int v36; // eax
  int v37; // esi
  int v38; // edx
  int *v39; // [rsp+8h] [rbp-A0h]
  __int64 v40; // [rsp+10h] [rbp-98h]
  __int64 v41; // [rsp+18h] [rbp-90h]
  int v42; // [rsp+18h] [rbp-90h]
  __int64 v43; // [rsp+20h] [rbp-88h]
  _QWORD *v44; // [rsp+28h] [rbp-80h]
  __int64 v45; // [rsp+38h] [rbp-70h]
  __int64 v46; // [rsp+58h] [rbp-50h]
  int v47; // [rsp+64h] [rbp-44h]
  unsigned __int64 v48; // [rsp+68h] [rbp-40h]

  v3 = *a3;
  v39 = a2;
  v40 = a1;
  v48 = __readfsqword(0x28u);
  v44 = a3;
  v43 = *(_QWORD *)(v3 + 160);
  v41 = *(_QWORD *)(v3 + 152);
  v4 = sub_26AD0(a1, &v47);
  v5 = (_DWORD *)v4;
  if ( v4 )
  {
    v6 = v41;
    if ( *(_BYTE *)v4 == 1 )
    {
      if ( !v47 )
        return 81;
      v28 = 80;
      _fs_done_read(a1, (unsigned int)(4 * *(_DWORD *)(v4 + 4)));
      goto LABEL_25;
    }
    v7 = *(_DWORD *)(v4 + 12);
    v8 = 0LL;
    if ( *a2 == 2 && (v8 = v44[2], (v42 = *((_DWORD *)v44 + 2)) != 0) )
    {
      v36 = *(unsigned __int16 *)(v3 + 8);
      v8 += 4LL;
      v37 = *(unsigned __int16 *)(v3 + 12);
      v38 = *(unsigned __int16 *)(v3 + 10) - v36 + 1;
      v10 = *(unsigned __int8 *)(v8 - 3) + v38 * (*(unsigned __int8 *)(v8 - 4) - v37) - v36;
      v9 = *(unsigned __int8 *)(v8 - 1) + v38 * (*(unsigned __int8 *)(v8 - 2) - v37) - v36;
    }
    else
    {
      v9 = v7;
      v42 = 0;
      v10 = 0LL;
    }
    v45 = v8;
    v11 = v6;
    v12 = (char *)fs_alloc_glyphs(v3, (unsigned int)v5[4]);
    v13 = v11;
    if ( v12 )
    {
      v14 = *v39;
      if ( v5[3] )
      {
        v15 = 0LL;
        v16 = &fs_glyph_requested;
        v17 = -281470681743361LL;
        v46 = 2 * v7;
        v18 = v5;
        v19 = (unsigned __int16 *)v3;
        v20 = v45;
        while ( 1 )
        {
          while ( 1 )
          {
            v21 = 24 * v10;
            v22 = 24 * v10 + *(_QWORD *)(v13 + 8);
            if ( v14 != 1 && *(void **)(v22 + 16) != v16 )
              break;
            if ( v17 & *(_QWORD *)v22 || *(_WORD *)(v22 + 8) || (v23 = 0LL, *(_WORD *)(v22 + 4)) )
            {
              v23 = &unk_23CD14;
              v24 = *(_QWORD *)&v18[2 * v15 + 5] >> 32;
              if ( (_DWORD)v24 )
              {
                v30 = v17;
                v31 = v13;
                v32 = v16;
                v33 = v18;
                v34 = &v12[(unsigned int)v24];
                v35 = memcpy(v12, (char *)&v18[v46 + 5] + (unsigned int)*(_QWORD *)&v18[2 * v15 + 5], (unsigned int)v24);
                v13 = v31;
                v17 = v30;
                v23 = v35;
                v16 = v32;
                v12 = v34;
                v18 = v33;
                v22 = *(_QWORD *)(v31 + 8) + v21;
              }
            }
            if ( *(void **)(v22 + 16) == v16 )
            {
              --*(_QWORD *)(v43 + 16);
              v22 = v21 + *(_QWORD *)(v13 + 8);
            }
            *(_QWORD *)(v22 + 16) = v23;
            v14 = *v39;
            if ( v9 != v10 )
              goto LABEL_10;
LABEL_20:
            if ( --v42 )
            {
              v25 = v19[4];
              v20 += 4LL;
              v26 = v19[6];
              v27 = v19[5] - v25 + 1;
              v10 = *(unsigned __int8 *)(v20 - 3) + v27 * (*(unsigned __int8 *)(v20 - 4) - v26) - v25;
              ++v15;
              v9 = (*(unsigned __int8 *)(v20 - 2) - v26) * v27 + *(unsigned __int8 *)(v20 - 1) - v25;
              if ( v18[3] > (unsigned int)v15 )
                continue;
            }
LABEL_22:
            v5 = v18;
            goto LABEL_23;
          }
          if ( v9 == v10 )
            goto LABEL_20;
LABEL_10:
          ++v10;
          if ( v18[3] <= (unsigned int)++v15 )
            goto LABEL_22;
        }
      }
LABEL_23:
      v28 = 85;
      if ( v14 == 1 )
      {
        *(_QWORD *)(v43 + 16) = 0LL;
        *((_DWORD *)v44 + 4) = 4;
      }
      goto LABEL_25;
    }
  }
  else
  {
    v28 = 81;
    if ( !v47 )
      return v28;
  }
  v28 = 80;
LABEL_25:
  _fs_done_read(v40, (unsigned int)(4 * v5[1]));
  return v28;
}
// 8390: using guessed type __int64 __fastcall _fs_done_read(_QWORD, _QWORD);
// 8F90: using guessed type __int64 __fastcall fs_alloc_glyphs(_QWORD, _QWORD);

//----- (0000000000027710) ----------------------------------------------------
unsigned __int64 __fastcall sub_27710(__int64 a1, struct _Client *a2)
{
  struct _Client **v2; // r13
  struct _Client **i; // rax
  struct _Client **v4; // rbx
  struct _Client **v5; // rax
  int v6; // er13
  struct _Client *v7; // rax
  unsigned __int64 v8; // rax
  struct _Client *v9; // rax
  struct _Client *v10; // rax
  unsigned int v12; // [rsp+4h] [rbp-54h]
  int *v13; // [rsp+8h] [rbp-50h]
  char v14; // [rsp+14h] [rbp-44h]
  char v15; // [rsp+15h] [rbp-43h]
  __int16 v16; // [rsp+16h] [rbp-42h]
  int v17; // [rsp+18h] [rbp-40h]
  int v18; // [rsp+1Ch] [rbp-3Ch]
  int v19; // [rsp+20h] [rbp-38h]
  int v20; // [rsp+24h] [rbp-34h]
  unsigned __int64 v21; // [rsp+28h] [rbp-30h]

  v2 = *(struct _Client ***)(a1 + 64);
  v21 = __readfsqword(0x28u);
  v20 = 0;
  if ( !v2 )
  {
LABEL_7:
    v5 = (struct _Client **)malloc(0x20uLL);
    v4 = v5;
    if ( !v5 )
      return __readfsqword(0x28u) ^ v21;
    *v5 = a2;
    v5[1] = (struct _Client *)v2;
    *(_QWORD *)(a1 + 64) = v5;
    v5[2] = (struct _Client *)GetNewFontClientID();
    goto LABEL_13;
  }
  if ( a2 != *v2 )
  {
    for ( i = v2; ; i = (struct _Client **)i[1] )
    {
      v4 = (struct _Client **)i[1];
      if ( !v4 )
        break;
      if ( *v4 == a2 )
      {
        if ( (struct _Client **)(a1 + 64) != i + 1 )
        {
          i[1] = v4[1];
          v4[1] = *(struct _Client **)(a1 + 64);
          *(_QWORD *)(a1 + 64) = v4;
        }
        goto LABEL_11;
      }
    }
    goto LABEL_7;
  }
  v4 = v2;
LABEL_11:
  v6 = *((_DWORD *)v4 + 6);
  if ( v6 == client_auth_generation(a2) )
    goto LABEL_16;
  LOWORD(v18) = 9;
  v7 = v4[2];
  ++*(_DWORD *)(a1 + 16);
  HIWORD(v18) = 2;
  v19 = (signed int)v7;
  _fs_write(a1, &v18, 8LL);
LABEL_13:
  v14 = 8;
  v15 = set_font_authorizations(&v13, &v12, a2);
  if ( v15 )
  {
    v12 = (v12 + 3) & 0xFFFFFFFC;
    v8 = (unsigned __int64)((signed int)v12 + 8LL) >> 2;
  }
  else
  {
    v12 = 4;
    v13 = &v20;
    LOWORD(v8) = 3;
  }
  v16 = v8;
  v9 = v4[2];
  ++*(_DWORD *)(a1 + 16);
  v17 = (signed int)v9;
  _fs_write(a1, &v14, 8LL);
  _fs_write(a1, v13, (signed int)v12);
  *(_QWORD *)(a1 + 72) = 0LL;
  *((_DWORD *)v4 + 6) = client_auth_generation(a2);
LABEL_16:
  v10 = v4[2];
  if ( *(struct _Client **)(a1 + 72) != v10 )
  {
    ++*(_DWORD *)(a1 + 16);
    v18 = 131082;
    v19 = (signed int)v10;
    _fs_write(a1, &v18, 8LL);
    *(_QWORD *)(a1 + 72) = v4[2];
  }
  return __readfsqword(0x28u) ^ v21;
}
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);
// 8F70: using guessed type __int64 __fastcall set_font_authorizations(_QWORD, _QWORD, _QWORD);

//----- (0000000000027900) ----------------------------------------------------
void __fastcall fs_mark_block(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 152) |= a2;
  dword_23CD18 |= a2;
}
// 23CD18: using guessed type int dword_23CD18;

//----- (0000000000027910) ----------------------------------------------------
__int64 __fastcall sub_27910(__int64 a1)
{
  __int64 result; // rax

  _fs_mark_block(a1, 8LL);
  result = (unsigned int)GetTimeInMillis(a1) + 30000;
  *(_DWORD *)(a1 + 156) = result;
  return result;
}
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (0000000000027930) ----------------------------------------------------
__int64 __fastcall sub_27930(__int64 a1)
{
  if ( !(*(_BYTE *)(a1 + 152) & 8) )
    sub_27910(a1);
  return _fs_flush(a1);
}
// 8890: using guessed type __int64 __fastcall _fs_flush(_QWORD);

//----- (0000000000027950) ----------------------------------------------------
signed __int64 __fastcall sub_27950(__int64 a1, __int64 a2, int a3, char *a4)
{
  _DWORD *v4; // rbx
  signed __int64 result; // rax
  int v6; // er13
  char *v7; // rbp
  _QWORD *v8; // r14
  __int64 v9; // rax
  int v10; // edx
  _QWORD *v11; // rax
  bool v12; // zf
  int v13; // eax
  int v14; // er12
  char *v15; // rax
  int v16; // er14
  char v17; // di
  char v18; // si
  char v19; // cl
  char v20; // dl
  char v21; // [rsp+10h] [rbp-158h]
  char v22; // [rsp+11h] [rbp-157h]
  __int16 v23; // [rsp+12h] [rbp-156h]
  int v24; // [rsp+14h] [rbp-154h]
  unsigned int v25; // [rsp+18h] [rbp-150h]
  int v26; // [rsp+1Ch] [rbp-14Ch]
  char v27; // [rsp+20h] [rbp-148h]
  unsigned __int64 v28; // [rsp+128h] [rbp-40h]

  v28 = __readfsqword(0x28u);
  v4 = *(_DWORD **)(*(_QWORD *)(a2 + 136) + 24LL);
  result = 87LL;
  if ( !(v4[38] & 0x10) )
  {
    v6 = a3;
    v7 = a4;
    v8 = sub_272E0((__int64)v4, a1, 2);
    result = 80LL;
    if ( v8 )
    {
      v9 = v8[3];
      *(_QWORD *)v9 = a2;
      *(_DWORD *)(v9 + 8) = v6;
      *(_QWORD *)(v9 + 16) = v7;
      *(_QWORD *)(v9 + 24) = 0LL;
      v10 = v4[38];
      if ( v10 & 0x44 )
      {
        result = 84LL;
        if ( !(v10 & 8) )
        {
          sub_27910((__int64)v4);
          result = 84LL;
        }
      }
      else
      {
        v11 = *(_QWORD **)(a2 + 160);
        v21 = 20;
        v12 = (*(_BYTE *)(a2 + 18) & 2) == 0;
        v24 = *v11;
        v13 = *(_DWORD *)(a2 + 100);
        v25 = *(_DWORD *)(a2 + 100);
        if ( !v12 )
          v25 = v13 & 0xFFFFFFF3 | 8;
        ++v4[4];
        v22 = 1;
        v23 = v6 + 4;
        v26 = 2 * v6;
        _fs_write(v4, &v21, 16LL);
        *((_WORD *)v8 + 8) = v4[4];
        if ( v6 && v6 > 0 )
        {
          v14 = 0;
          v15 = &v27;
          while ( 1 )
          {
            v17 = v7[1];
            v18 = *v7;
            v19 = v7[3];
            v20 = v7[2];
            if ( v4[12] > 1 )
            {
              ++v14;
              *v15 = v18;
              v15[1] = v17;
              v15[2] = v20;
              v15[3] = v19;
              v16 = v14 & 0x3F;
              if ( !(v14 & 0x3F) )
                goto LABEL_15;
            }
            else
            {
              ++v14;
              *v15 = v17;
              v15[1] = v18;
              v15[2] = v19;
              v15[3] = v20;
              v16 = v14 & 0x3F;
              if ( !(v14 & 0x3F) )
              {
LABEL_15:
                _fs_write(v4, &v27, 256LL);
                v15 = &v27;
                goto LABEL_12;
              }
            }
            v15 += 4;
LABEL_12:
            v7 += 4;
            if ( v6 == v14 )
            {
              if ( v16 )
                _fs_write(v4, &v27, 4 * v16);
              break;
            }
          }
        }
        sub_27930((__int64)v4);
        result = 84LL;
      }
    }
  }
  return result;
}
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000027B60) ----------------------------------------------------
signed __int64 __fastcall sub_27B60(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, pointer *privatep)
{
  _DWORD *v6; // rbx
  signed __int64 result; // rax
  char *v8; // r13
  int v9; // er12
  _QWORD *v10; // r14
  _QWORD *v11; // rdx
  int v12; // ecx
  int v13; // edx
  int v14; // [rsp+Ch] [rbp-4Ch]
  __int16 v15; // [rsp+1Ch] [rbp-3Ch]
  __int16 v16; // [rsp+1Eh] [rbp-3Ah]
  int v17; // [rsp+20h] [rbp-38h]
  __int16 v18; // [rsp+24h] [rbp-34h]
  unsigned __int64 v19; // [rsp+28h] [rbp-30h]

  v6 = fpe->c_private;
  v19 = __readfsqword(0x28u);
  result = 83LL;
  if ( !(v6[38] & 0x10) )
  {
    v8 = pat;
    v9 = len;
    v14 = max;
    v10 = sub_272E0((__int64)v6, (__int64)client, 4);
    result = 80LL;
    if ( v10 )
    {
      v11 = (_QWORD *)v10[3];
      v12 = v10[3];
      *v11 = 0LL;
      v11[44] = 0LL;
      memset(
        (void *)((unsigned __int64)(v11 + 1) & 0xFFFFFFFFFFFFFFF8LL),
        0,
        8LL * ((v12 - (((_DWORD)v11 + 8) & 0xFFFFFFF8) + 360) >> 3));
      *(_DWORD *)v11 = 0;
      v13 = v6[38];
      if ( v13 & 0x44 )
      {
        result = 84LL;
        if ( !(v13 & 8) )
        {
          sub_27910((__int64)v6);
          result = 84LL;
        }
      }
      else
      {
        sub_27710((__int64)v6, (struct _Client *)client);
        sub_26DB0((__int64)v6);
        ++v6[4];
        v15 = 14;
        v18 = v9;
        v17 = v14;
        v16 = (v9 + 15) >> 2;
        _fs_write(v6, &v15, 12LL);
        _fs_write_pad(v6, v8, v9);
        *((_WORD *)v10 + 8) = v6[4];
        sub_27930((__int64)v6);
        result = 85LL;
      }
    }
  }
  return result;
}
// 8760: using guessed type __int64 __fastcall _fs_write_pad(_QWORD, _QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000027CE0) ----------------------------------------------------
__int64 __fastcall fs_unmark_block(__int64 a1, int a2)
{
  __int64 result; // rax
  int v3; // esi
  int v4; // edx

  result = *(unsigned int *)(a1 + 152);
  if ( a2 & (unsigned int)result )
  {
    dword_23CD18 = 0;
    v3 = result & ~a2;
    result = qword_23CD20;
    *(_DWORD *)(a1 + 152) = v3;
    if ( result )
    {
      v4 = 0;
      do
      {
        v4 |= *(_DWORD *)(result + 152);
        result = *(_QWORD *)result;
      }
      while ( result );
      dword_23CD18 = v4;
    }
  }
  return result;
}
// 23CD18: using guessed type int dword_23CD18;
// 23CD20: using guessed type __int64 qword_23CD20;

//----- (0000000000027D30) ----------------------------------------------------
__int64 __fastcall sub_27D30(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  void *v3; // rdi
  __int64 v4; // rdi

  v1 = a1;
  result = _fs_unmark_block(a1, 39LL);
  v3 = *(void **)(a1 + 184);
  if ( v3 )
  {
    _FontTransClose(v3);
    *(_QWORD *)(v1 + 184) = 0LL;
    result = _fs_io_reinit(v1);
  }
  v4 = *(signed int *)(v1 + 8);
  if ( (signed int)v4 >= 0 )
  {
    result = __fdelt_chk(v4);
    fs_fd_mask[result] &= __ROL8__(-2LL, *(_DWORD *)(v1 + 8) % 64);
    *(_DWORD *)(v1 + 8) = -1;
  }
  *(_DWORD *)(v1 + 12) = 0;
  return result;
}
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8B20: using guessed type __int64 __fastcall _fs_io_reinit(_QWORD);

//----- (0000000000027DB0) ----------------------------------------------------
__int64 __fastcall sub_27DB0(__int64 a1)
{
  __int64 v1; // rbx
  signed int v2; // eax
  _DWORD *v3; // r12
  __int64 v4; // rdi
  __int64 result; // rax
  __int64 v6; // r13
  _WORD *v7; // r15
  int v8; // er8
  signed __int64 v9; // rdx
  int v10; // eax
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rax
  int v14; // eax
  void *v15; // rdi
  unsigned __int8 v16; // al
  signed __int64 v17; // r14
  char *v18; // rax
  int v19; // er8
  char *v20; // r14
  char *v21; // r13
  char *v22; // r12
  int v23; // ebx
  int v24; // eax
  char *v25; // rsi
  unsigned __int64 v26; // rdx
  _BYTE *v27; // rdi
  char *v28; // rsi
  unsigned __int64 v29; // rcx
  __int64 v30; // rax
  __int64 v31; // rsi
  char *v32; // [rsp+0h] [rbp-78h]
  int v33; // [rsp+8h] [rbp-70h]
  _DWORD *v34; // [rsp+8h] [rbp-70h]
  __int64 v35; // [rsp+10h] [rbp-68h]
  __int64 v36; // [rsp+18h] [rbp-60h]
  _WORD *v37; // [rsp+28h] [rbp-50h]
  __int16 v38; // [rsp+32h] [rbp-46h]
  unsigned __int64 v39; // [rsp+38h] [rbp-40h]

  v1 = a1;
  v39 = __readfsqword(0x28u);
  v2 = *(_DWORD *)(a1 + 12);
  v3 = &v37;
  while ( 2 )
  {
    switch ( v2 )
    {
      case 0:
        v13 = *(signed int *)(v1 + 44);
        if ( (_DWORD)v13 )
          v4 = *(_QWORD *)(*(_QWORD *)(v1 + 56) + 16 * v13 - 16);
        else
          v4 = *(_QWORD *)(v1 + 24);
        *(_QWORD *)(v1 + 184) = _fs_connect(v4, v3);
        *(_DWORD *)(v1 + 164) = (unsigned __int64)GetTimeInMillis(v4) + 5000;
        result = (unsigned int)v37;
        if ( (_DWORD)v37 )
          goto LABEL_5;
        *(_DWORD *)(v1 + 12) = 1;
        goto LABEL_30;
      case 1:
        v4 = *(_QWORD *)(v1 + 184);
        result = _fs_poll_connect(v4, 0LL);
        if ( (_DWORD)result != 1 )
          goto LABEL_4;
        v11 = _FontTransGetConnectionNumber(*(_QWORD *)(v1 + 184));
        *(_DWORD *)(v1 + 8) = v11;
        v12 = __fdelt_chk(v11);
        fs_fd_mask[v12] |= 1LL << (char)*(_DWORD *)(v1 + 8) % 64;
        v2 = *(_DWORD *)(v1 + 12);
        goto LABEL_19;
      case 2:
        v37 = (_WORD *)(&loc_20068 + 4);
        v9 = 8LL;
        goto LABEL_17;
      case 3:
        v4 = v1;
        result = _fs_start_read(v1, 12LL, v3);
        if ( (_DWORD)result != 1 )
          goto LABEL_4;
        if ( v37[1] > 2u )
          goto LABEL_31;
        LODWORD(v6) = 4 * (unsigned __int16)v37[5] + 4 * (unsigned __int16)v37[4] + 12;
        if ( *v37 )
          goto LABEL_11;
        v4 = v1;
        result = _fs_start_read(v1, 4 * (unsigned __int16)v37[5] + 4 * (unsigned __int16)v37[4] + 24, v3);
        if ( (_DWORD)result != 1 )
          goto LABEL_4;
        LODWORD(v6) = v6 + 4 * *(_DWORD *)((char *)v37 + (signed int)v6);
LABEL_11:
        v6 = (signed int)v6;
        v4 = v1;
        result = _fs_start_read(v1, (signed int)v6, v3);
        if ( (_DWORD)result != 1 )
          goto LABEL_4;
        v7 = v37;
        if ( v37 )
        {
          *(_DWORD *)(v1 + 16) = 0;
          v8 = *(_DWORD *)(v1 + 44);
          *(_DWORD *)(v1 + 48) = (unsigned __int16)v7[1];
          if ( !v8 )
          {
            v15 = *(void **)(v1 + 56);
            if ( v15 )
            {
              free(v15);
              v8 = 0;
              *(_QWORD *)(v1 + 56) = 0LL;
              *(_DWORD *)(v1 + 40) = 0;
            }
            v16 = *((_BYTE *)v7 + 6);
            if ( v16 )
            {
              v33 = v8;
              v17 = 16LL * v16;
              v18 = (char *)malloc(v17 + 4 * (unsigned __int16)v7[4]);
              v32 = v18;
              if ( v18 )
              {
                v19 = v33;
                v35 = v6;
                v36 = v1;
                v34 = v3;
                v20 = &v18[v17];
                v21 = (char *)(v7 + 6);
                v22 = v18;
                v23 = v19;
                do
                {
                  v25 = v21 + 2;
                  *((_DWORD *)v22 + 2) = *v21;
                  v26 = v21[1];
                  *(_QWORD *)v22 = v20;
                  if ( v26 < 8 )
                  {
                    if ( v26 & 4 )
                    {
                      *(_DWORD *)v20 = *(_DWORD *)v25;
                      *(_DWORD *)&v20[v26 - 4] = *(_DWORD *)&v25[v26 - 4];
                    }
                    else if ( v26 )
                    {
                      *v20 = *v25;
                      if ( v26 & 2 )
                        *(_WORD *)&v20[v26 - 2] = *(_WORD *)&v21[v26];
                    }
                  }
                  else
                  {
                    v27 = (_BYTE *)((unsigned __int64)(v20 + 8) & 0xFFFFFFFFFFFFFFF8LL);
                    *(_QWORD *)v20 = *(_QWORD *)(v21 + 2);
                    *(_QWORD *)&v20[v26 - 8] = *(_QWORD *)&v25[v26 - 8];
                    v28 = &v25[-(v20 - v27)];
                    v29 = (v26 + v20 - v27) >> 3;
                    qmemcpy(v27, v28, 8 * v29);
                    v25 = &v28[8 * v29];
                  }
                  v20[v26] = 0;
                  v20 += v26 + 1;
                  ++v23;
                  v22 += 16;
                  v21 += _fs_pad_length((char)v26 + 2, v25);
                  v24 = *((unsigned __int8 *)v7 + 6);
                }
                while ( v23 < v24 );
                v1 = v36;
                v6 = v35;
                v3 = v34;
                *(_DWORD *)(v36 + 40) = v24;
                *(_QWORD *)(v36 + 56) = v32;
              }
            }
          }
          _fs_done_read(v1, v6);
          if ( !*v7 )
            goto LABEL_15;
        }
        goto LABEL_31;
      case 4:
        v4 = v1;
        result = sub_26EC0(v1);
        if ( !*(_DWORD *)(v1 + 32) )
          goto LABEL_4;
        LOBYTE(v37) = 3;
        *(_WORD **)((char *)&v37 + 2) = (_WORD *)(&dword_0 + 3);
        v38 = 0;
        ++*(_DWORD *)(v1 + 16);
        v9 = 12LL;
LABEL_17:
        if ( (unsigned int)_fs_write(v1, v3, v9) != 1 )
          goto LABEL_31;
        *(_DWORD *)(v1 + 164) = (unsigned __int64)GetTimeInMillis(v1) + 30000;
        v2 = *(_DWORD *)(v1 + 12);
        goto LABEL_19;
      case 5:
        if ( !*(_DWORD *)(v1 + 32) )
          goto LABEL_25;
        v4 = v1;
        v30 = sub_26AD0(v1, v3);
        if ( v30 )
        {
          v31 = (unsigned int)(4 * *(_DWORD *)(v30 + 4));
          if ( *(_BYTE *)v30 != 1 || *(_BYTE *)(v30 + 12) != 4 )
          {
            _fs_done_read(v1, v31);
            v2 = *(_DWORD *)(v1 + 12);
LABEL_19:
            if ( v2 <= 5 )
LABEL_25:
              *(_DWORD *)(v1 + 12) = ++v2;
            goto LABEL_20;
          }
          _fs_done_read(v1, v31);
          goto LABEL_31;
        }
        result = (unsigned int)v37;
LABEL_4:
        if ( (_DWORD)result )
        {
LABEL_5:
          if ( (_DWORD)result == 1 )
          {
LABEL_15:
            v2 = *(_DWORD *)(v1 + 12);
            goto LABEL_19;
          }
          if ( (_DWORD)result != -1 )
            return result;
LABEL_31:
          sub_27D30(v1);
          v14 = *(_DWORD *)(v1 + 44);
          if ( v14 >= *(_DWORD *)(v1 + 40) )
          {
            *(_DWORD *)(v1 + 44) = 0;
            return 0xFFFFFFFFLL;
          }
          *(_DWORD *)(v1 + 44) = v14 + 1;
          v2 = *(_DWORD *)(v1 + 12);
LABEL_20:
          if ( v2 == 6 )
          {
            v10 = dword_23CD10 + 1;
            dword_23CD10 = v10;
            *(_DWORD *)(v1 + 36) = v10;
            return 1LL;
          }
          continue;
        }
LABEL_30:
        if ( (signed int)((unsigned __int64)GetTimeInMillis(v4) - *(_DWORD *)(v1 + 164)) >= 0 )
          goto LABEL_31;
        return 0LL;
      default:
        goto LABEL_19;
    }
  }
}
// 8330: using guessed type __int64 __fastcall _fs_connect(_QWORD, _QWORD);
// 8390: using guessed type __int64 __fastcall _fs_done_read(_QWORD, _QWORD);
// 8400: using guessed type __int64 __fastcall _fs_poll_connect(_QWORD, _QWORD);
// 8470: using guessed type __int64 __fastcall _fs_start_read(_QWORD, _QWORD, _QWORD);
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 85A0: using guessed type __int64 __fastcall _fs_pad_length(_QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8ED0: using guessed type __int64 __fastcall _FontTransGetConnectionNumber(_QWORD);
// 23CD10: using guessed type int dword_23CD10;

//----- (00000000000282B0) ----------------------------------------------------
void __fastcall sub_282B0(void *ptr)
{
  void *v1; // rbx
  void *v2; // rdi

  v1 = ptr;
  sub_27D30((__int64)ptr);
  _fs_io_fini(ptr);
  v2 = (void *)*((_QWORD *)ptr + 7);
  if ( v2 )
    free(v2);
  free(v1);
}
// 83B0: using guessed type __int64 __fastcall _fs_io_fini(_QWORD);

//----- (00000000000282E0) ----------------------------------------------------
__int64 __fastcall sub_282E0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rdx
  _QWORD *v3; // rax
  __int64 v4; // rax
  __int64 v6; // rax
  _QWORD *v7; // rdx

  v2 = *(_QWORD **)(a1 + 176);
  if ( !v2 )
    goto LABEL_7;
  if ( v2 != a2 )
  {
    while ( 1 )
    {
      v3 = (_QWORD *)v2[6];
      if ( !v3 )
        break;
      if ( a2 == v3 )
      {
        v7 = v2 + 6;
        goto LABEL_15;
      }
      v2 = (_QWORD *)v2[6];
    }
LABEL_7:
    if ( *(_DWORD *)a2 != 2 )
      goto LABEL_8;
    goto LABEL_16;
  }
  v7 = (_QWORD *)(a1 + 176);
LABEL_15:
  *v7 = a2[6];
  if ( *(_DWORD *)a2 == 2 )
  {
LABEL_16:
    v6 = a2[3];
    if ( *(_DWORD *)(v6 + 8) )
      free(*(void **)(v6 + 16));
  }
LABEL_8:
  free(a2);
  v4 = *(_QWORD *)(a1 + 176);
  if ( !v4 )
    return _fs_unmark_block(a1, 8LL);
  while ( *(_DWORD *)(v4 + 32) != 81 )
  {
    v4 = *(_QWORD *)(v4 + 48);
    if ( !v4 )
      return _fs_unmark_block(a1, 8LL);
  }
  *(_DWORD *)(a1 + 156) = (unsigned __int64)GetTimeInMillis(a2) + 30000;
  return _fs_mark_block(a1, 8LL);
}
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (00000000000283D0) ----------------------------------------------------
__int64 __fastcall sub_283D0(__int64 a1, int *a2)
{
  int v2; // eax
  __int64 result; // rax
  __int64 v4; // r12
  _DWORD *v5; // r12
  __int64 v6; // r12
  __int64 v7; // rax

  v2 = *a2;
  if ( *a2 == 2 )
  {
    v6 = *((_QWORD *)a2 + 3);
    _fs_clean_aborted_loadglyphs(*(_QWORD *)v6, *(unsigned int *)(v6 + 8), *(_QWORD *)(v6 + 16));
    sub_26B90((__int64 *)(v6 + 24));
    result = sub_282E0(a1, a2);
  }
  else if ( v2 == 4 )
  {
    v5 = (_DWORD *)*((_QWORD *)a2 + 3);
    if ( *v5 == 1 )
    {
      v7 = __fdelt_chk(*(signed int *)(a1 + 8));
      fs_fd_mask[v7] |= 1LL << (char)*(_DWORD *)(a1 + 8) % 64;
    }
    _fs_free_props(v5 + 2);
    result = sub_282E0(a1, a2);
  }
  else
  {
    if ( v2 == 1 )
    {
      v4 = *((_QWORD *)a2 + 3);
      sub_27270(*((signed __int64 **)a2 + 3));
      sub_26B90((__int64 *)(v4 + 40));
    }
    result = sub_282E0(a1, a2);
  }
  return result;
}
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 8B90: using guessed type __int64 __fastcall _fs_clean_aborted_loadglyphs(_QWORD, _QWORD, _QWORD);
// 9080: using guessed type __int64 __fastcall _fs_free_props(_QWORD);

//----- (00000000000284C0) ----------------------------------------------------
void __fastcall client_died(pointer client, FontPathElementPtr fpe)
{
  _QWORD *v2; // r12
  __int64 v3; // rax
  int *v4; // rax
  int *v5; // rsi
  pointer v6; // rax
  _QWORD *v7; // r13
  pointer *v8; // rbx
  __int16 v9; // [rsp+0h] [rbp-38h]
  __int16 v10; // [rsp+2h] [rbp-36h]
  int v11; // [rsp+4h] [rbp-34h]
  unsigned __int64 v12; // [rsp+8h] [rbp-30h]

  v2 = fpe->c_private;
  v12 = __readfsqword(0x28u);
  v3 = v2[8];
  if ( v3 )
  {
    if ( client == *(pointer *)v3 )
    {
      v7 = v2 + 8;
      v8 = (pointer *)v2[8];
LABEL_17:
      v9 = 9;
      v6 = v8[2];
      ++*((_DWORD *)v2 + 4);
      v10 = 2;
      v11 = (signed int)v6;
      _fs_write(v2, &v9, 8LL);
      *v7 = v8[1];
      free(v8);
    }
    else
    {
      while ( 1 )
      {
        v8 = *(pointer **)(v3 + 8);
        if ( !v8 )
          break;
        if ( *v8 == client )
        {
          v7 = (_QWORD *)(v3 + 8);
          goto LABEL_17;
        }
        v3 = *(_QWORD *)(v3 + 8);
      }
    }
  }
  v4 = (int *)v2[22];
  if ( v4 )
  {
    if ( client == *((pointer *)v4 + 1) )
    {
LABEL_13:
      v5 = (int *)*((_QWORD *)v4 + 5);
      if ( v5 )
      {
        *((_QWORD *)v4 + 1) = *((_QWORD *)v5 + 1);
        *((_QWORD *)v4 + 5) = *((_QWORD *)v5 + 5);
      }
      else
      {
        v5 = v4;
      }
      sub_283D0((__int64)v2, v5);
    }
    else
    {
      while ( 1 )
      {
        v4 = (int *)*((_QWORD *)v4 + 6);
        if ( !v4 )
          break;
        if ( *((pointer *)v4 + 1) == client )
          goto LABEL_13;
      }
    }
  }
}
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (00000000000285E0) ----------------------------------------------------
signed __int64 __fastcall sub_285E0(pointer client, FontPathElementPtr fpe, char **name, int *namelen, FontInfoPtr *info, int *numFonts)
{
  signed int *v6; // r12
  __int64 v7; // rbx
  int *v8; // rbp
  unsigned int v9; // er13
  __int64 v10; // rax
  signed int *v11; // rdi
  int v12; // eax

  v6 = (signed int *)fpe->c_private;
  v7 = *((_QWORD *)v6 + 22);
  if ( !v7 )
    return 83LL;
  while ( *(_DWORD *)v7 != 4 || *(pointer *)(v7 + 8) != client )
  {
    v7 = *(_QWORD *)(v7 + 48);
    if ( !v7 )
      return 83LL;
  }
  v8 = *(int **)(v7 + 24);
  v9 = 84;
  if ( !*v8 )
    return v9;
  *name = (char *)(v8 + 24);
  *namelen = v8[1];
  *info = (FontInfoPtr)(v8 + 2);
  *numFonts = v8[88];
  v10 = __fdelt_chk(v6[2]);
  fs_fd_mask[v10] |= 1LL << (char)v6[2] % 64;
  v11 = v6;
  if ( (unsigned int)sub_27150((__int64)v6) )
  {
    v11 = v6;
    _fs_mark_block(v6, 32LL);
    v12 = *v8;
    v9 = *(_DWORD *)(v7 + 32);
    if ( *v8 != 1 )
    {
LABEL_9:
      if ( v12 == 2 )
        sub_282E0((__int64)v6, (_QWORD *)v7);
      return v9;
    }
  }
  else
  {
    v12 = *v8;
    v9 = *(_DWORD *)(v7 + 32);
    if ( *v8 != 1 )
      goto LABEL_9;
  }
  *v8 = 0;
  *(_DWORD *)(v7 + 32) = 81;
  v6[39] = (unsigned __int64)GetTimeInMillis(v11) + 30000;
  _fs_mark_block(v6, 8LL);
  return v9;
}
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (0000000000028730) ----------------------------------------------------
signed __int64 __fastcall sub_28730(pointer client, FontPathElementPtr fpe, char *pat, int len, int max, FontNamesPtr names)
{
  char *v6; // r13
  int v7; // er12
  _QWORD *v8; // rbp
  __int64 v9; // rsi
  signed __int64 result; // rax
  _QWORD *v11; // r14
  int v12; // edx
  unsigned int v13; // [rsp+4h] [rbp-54h]
  int v14; // [rsp+4h] [rbp-54h]
  FontNamesPtr v15; // [rsp+8h] [rbp-50h]
  __int16 v16; // [rsp+1Ch] [rbp-3Ch]
  __int16 v17; // [rsp+1Eh] [rbp-3Ah]
  int v18; // [rsp+20h] [rbp-38h]
  __int16 v19; // [rsp+24h] [rbp-34h]
  unsigned __int64 v20; // [rsp+28h] [rbp-30h]

  v6 = pat;
  v7 = len;
  v8 = fpe->c_private;
  v20 = __readfsqword(0x28u);
  v9 = v8[22];
  if ( v9 )
  {
    while ( *(_DWORD *)v9 != 3 || *(pointer *)(v9 + 8) != client )
    {
      v9 = *(_QWORD *)(v9 + 48);
      if ( !v9 )
        goto LABEL_9;
    }
    v13 = *(_DWORD *)(v9 + 32);
    if ( *(_DWORD *)(v9 + 32) == 81 )
    {
      result = 84LL;
    }
    else
    {
      sub_282E0((__int64)v8, (_QWORD *)v9);
      result = v13;
    }
  }
  else
  {
LABEL_9:
    result = 83LL;
    if ( !(v8[19] & 0x10) )
    {
      v15 = names;
      v14 = max;
      v11 = sub_272E0((__int64)v8, (__int64)client, 3);
      result = 80LL;
      if ( v11 )
      {
        *(_QWORD *)v11[3] = v15;
        v12 = *((_DWORD *)v8 + 38);
        if ( v12 & 0x44 )
        {
          result = 84LL;
          if ( !(v12 & 8) )
          {
            sub_27910((__int64)v8);
            result = 84LL;
          }
        }
        else
        {
          sub_27710((__int64)v8, (struct _Client *)client);
          sub_26DB0((__int64)v8);
          ++*((_DWORD *)v8 + 4);
          v16 = 13;
          v19 = v7;
          v18 = v14;
          v17 = (v7 + 15) >> 2;
          _fs_write(v8, &v16, 12LL);
          _fs_write_pad(v8, v6, v7);
          *((_WORD *)v11 + 8) = *((_DWORD *)v8 + 4);
          sub_27930((__int64)v8);
          result = 84LL;
        }
      }
    }
  }
  return result;
}
// 8760: using guessed type __int64 __fastcall _fs_write_pad(_QWORD, _QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);

//----- (00000000000288D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_288D0(__int64 a1, struct _Client *a2)
{
  struct _Client *v2; // r12
  __int64 v3; // r13
  __int64 v4; // rbp
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // r14
  __int16 v8; // ax
  signed int v10; // er14
  __int64 v11; // r15
  signed __int64 v12; // r13
  __int64 *v13; // rsi
  __int64 v14; // rax
  __int64 v15; // r14
  __int64 v16; // r10
  unsigned int v17; // eax
  _DWORD *v18; // rdx
  signed __int64 v19; // r11
  signed __int64 v20; // r8
  signed __int64 v21; // r9
  char *v22; // rsi
  signed __int64 v23; // ST20_8
  _DWORD *v24; // ST18_8
  __int64 v25; // ST10_8
  signed __int64 v26; // ST08_8
  signed int v27; // er13
  FontNamesPtr *v28; // r13
  __int64 v29; // rax
  __int64 v30; // r15
  int v31; // er8
  char *v32; // rax
  unsigned int v33; // ebx
  FontNamesPtr *v34; // r14
  signed __int64 v35; // rbp
  __int64 v36; // r13
  int v37; // eax
  struct _Client *v38; // rdi
  signed __int64 *v39; // r9
  signed int v40; // eax
  __int64 v41; // rax
  _WORD *v42; // r15
  __int64 v43; // rax
  signed __int64 *v44; // r9
  int v45; // edx
  signed __int64 *v46; // ST18_8
  int v47; // edx
  signed __int64 *v48; // r9
  _WORD *v49; // r14
  _WORD *v50; // r12
  signed __int64 v51; // r15
  _QWORD *v52; // rbp
  __int64 v53; // r13
  __int64 v54; // rax
  __int64 v55; // r14
  signed __int64 *v56; // r9
  __int16 v57; // ax
  int v58; // eax
  signed __int64 *v59; // r9
  signed __int64 *v60; // ST08_8
  signed __int64 *v61; // r9
  int v62; // eax
  __int64 v63; // r14
  __int64 v64; // rax
  __int64 *v65; // r15
  __int64 v66; // ST08_8
  __int64 v67; // rdi
  signed __int64 *v68; // r9
  int v69; // edx
  signed __int64 v70; // rax
  __int64 *v71; // r9
  int v72; // er8
  int v73; // ecx
  unsigned int v74; // eax
  __int64 v75; // rdi
  int v76; // edx
  unsigned int v77; // ecx
  unsigned int v78; // esi
  unsigned int v79; // eax
  bool v80; // zf
  signed __int64 *v81; // ST08_8
  _WORD *v82; // r15
  signed __int64 v83; // r11
  _WORD *v84; // r14
  __int64 v85; // rbx
  __int16 v86; // ax
  __int16 v87; // cx
  __int16 v88; // ax
  __int16 v89; // ax
  __int16 v90; // dx
  __int16 v91; // dx
  signed __int64 v92; // ST20_8
  signed __int64 v93; // ST20_8
  signed __int64 *v94; // ST18_8
  int v95; // ST10_4
  signed __int64 *v96; // ST08_8
  signed __int64 *v97; // ST08_8
  char *v98; // rdi
  char *v99; // rsi
  unsigned int v100; // ecx
  __int64 v101; // rax
  int v102; // eax
  __int64 v103; // rax
  __int64 v104; // rax
  signed __int64 *v105; // ST10_8
  __int64 *v106; // ST08_8
  __int64 v107; // rax
  __int64 v108; // rdi
  int v109; // edx
  __int16 v110; // ax
  char *v111; // rdi
  char *v112; // rsi
  unsigned int v113; // ecx
  unsigned __int64 v114; // rax
  __int64 v115; // rcx
  __int64 v116; // rdx
  unsigned __int64 *v117; // rcx
  __int64 v118; // rdx
  _QWORD *v119; // rsi
  _QWORD *v120; // rcx
  signed __int64 *v121; // ST10_8
  __int64 v122; // [rsp+8h] [rbp-120h]
  _DWORD *v123; // [rsp+8h] [rbp-120h]
  __int64 v124; // [rsp+8h] [rbp-120h]
  __int64 v125; // [rsp+8h] [rbp-120h]
  signed __int64 *v126; // [rsp+8h] [rbp-120h]
  signed __int64 *v127; // [rsp+8h] [rbp-120h]
  signed __int64 v128; // [rsp+8h] [rbp-120h]
  __int64 v129; // [rsp+10h] [rbp-118h]
  signed __int64 *v130; // [rsp+10h] [rbp-118h]
  int v131; // [rsp+10h] [rbp-118h]
  _WORD *v132; // [rsp+10h] [rbp-118h]
  __int64 *v133; // [rsp+10h] [rbp-118h]
  __int64 v134; // [rsp+18h] [rbp-110h]
  signed int v135; // [rsp+20h] [rbp-108h]
  __int64 v136; // [rsp+28h] [rbp-100h]
  _QWORD *v137; // [rsp+30h] [rbp-F8h]
  __int64 v138; // [rsp+38h] [rbp-F0h]
  char *v139; // [rsp+40h] [rbp-E8h]
  signed __int64 v140; // [rsp+48h] [rbp-E0h]
  __int64 v141; // [rsp+50h] [rbp-D8h]
  __int64 v142; // [rsp+58h] [rbp-D0h]
  signed __int64 *v143; // [rsp+60h] [rbp-C8h]
  char v144; // [rsp+78h] [rbp-B0h]
  int v145; // [rsp+7Ch] [rbp-ACh]
  int v146; // [rsp+80h] [rbp-A8h]
  int v147; // [rsp+84h] [rbp-A4h]
  int v148; // [rsp+88h] [rbp-A0h]
  int v149; // [rsp+8Ch] [rbp-9Ch]
  __int64 v150; // [rsp+90h] [rbp-98h]
  int v151; // [rsp+98h] [rbp-90h]
  unsigned __int64 v152; // [rsp+E8h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 24);
  v152 = __readfsqword(0x28u);
  v5 = sub_26AD0(v4, &v144);
  if ( v5 )
  {
    v6 = *(_QWORD *)(v4 + 176);
    v7 = v5;
    if ( v6 )
    {
      v8 = *(_WORD *)(v5 + 2);
      if ( *(_WORD *)(v6 + 16) == v8 )
      {
LABEL_13:
        v10 = *(_DWORD *)v6;
        if ( *(_DWORD *)v6 == 2 )
        {
          v27 = sub_27370(*(_QWORD *)(a1 + 24), (int *)v6, *(_QWORD **)(v6 + 24));
          *(_DWORD *)(v6 + 32) = v27;
          goto LABEL_40;
        }
        if ( v10 > 2 )
        {
          if ( v10 == 3 )
          {
            v124 = *(_QWORD *)(a1 + 24);
            v28 = *(FontNamesPtr **)(v6 + 24);
            v29 = sub_26AD0(*(_QWORD *)(a1 + 24), &v150);
            v30 = v29;
            if ( v29 )
            {
              if ( *(_BYTE *)v29 != 1 )
              {
                v31 = *(_DWORD *)(v29 + 12);
                v32 = (char *)(v29 + 16);
                if ( v31 )
                {
                  v134 = v6;
                  v129 = v4;
                  v33 = 0;
                  v34 = v28;
                  do
                  {
                    v35 = (signed __int64)(v32 + 1);
                    v36 = (unsigned __int8)*v32;
                    v37 = AddFontNamesName(*v34, v32 + 1, (unsigned __int8)*v32);
                    if ( v37 != 85 )
                    {
                      v6 = v134;
                      v27 = v37;
                      v4 = v129;
                      _fs_done_read(v124, (unsigned int)(4 * *(_DWORD *)(v30 + 4)));
                      *(_DWORD *)(v134 + 32) = v27;
                      goto LABEL_40;
                    }
                    ++v33;
                    v32 = (char *)(v35 + v36);
                  }
                  while ( *(_DWORD *)(v30 + 12) > v33 );
                  v4 = v129;
                  v6 = v134;
                }
                v27 = 85;
                _fs_done_read(v124, (unsigned int)(4 * *(_DWORD *)(v30 + 4)));
                *(_DWORD *)(v6 + 32) = 85;
                goto LABEL_41;
              }
              if ( (_DWORD)v150 )
              {
                v27 = 80;
                _fs_done_read(v124, (unsigned int)(4 * *(_DWORD *)(v29 + 4)));
                *(_DWORD *)(v6 + 32) = 80;
                goto LABEL_41;
              }
            }
            else if ( (_DWORD)v150 )
            {
              goto LABEL_57;
            }
            goto LABEL_59;
          }
          if ( v10 == 4 )
          {
            v11 = *(_QWORD *)(a1 + 24);
            v12 = *(_QWORD *)(v6 + 24) + 8LL;
            v122 = *(_QWORD *)(v6 + 24);
            _fs_free_props(v12);
            v13 = &v150;
            v14 = sub_26AD0(v11, &v150);
            v15 = v14;
            v16 = v122;
            if ( v14 && *(_BYTE *)v14 != 1 )
            {
              v17 = *(unsigned __int8 *)(v14 + 1);
              if ( !(_BYTE)v17 )
              {
                *(_DWORD *)v122 = 2;
                v27 = 83;
                _fs_done_read(v11, (unsigned int)(4 * *(_DWORD *)(v15 + 4)));
                *(_DWORD *)(v6 + 32) = 83;
                goto LABEL_41;
              }
              v18 = (_DWORD *)(v15 + 52);
              v19 = v122 + 96;
              if ( *(_DWORD *)(v11 + 48) <= 1 )
              {
                if ( v17 >= 8 )
                {
                  v111 = (char *)((v122 + 104) & 0xFFFFFFFFFFFFFFF8LL);
                  *(_QWORD *)(v122 + 96) = *(_QWORD *)(v15 + 52);
                  *(_QWORD *)(v19 + v17 - 8) = *(_QWORD *)((char *)v18 + v17 - 8);
                  v112 = (char *)v18 - (v19 - (_QWORD)v111);
                  v113 = (v17 + (_DWORD)v19 - (_DWORD)v111) >> 3;
                  qmemcpy(v111, v112, 8LL * v113);
                  v13 = (__int64 *)&v112[8 * v113];
                }
                else if ( v17 & 4 )
                {
                  *(_DWORD *)(v122 + 96) = *v18;
                  *(_DWORD *)(v19 + v17 - 4) = *(_DWORD *)((char *)v18 + v17 - 4);
                }
                else if ( v17 )
                {
                  *(_BYTE *)(v122 + 96) = *(_BYTE *)v18;
                  if ( v17 & 2 )
                    *(_WORD *)(v19 + v17 - 2) = *(_WORD *)((char *)v18 + v17 - 2);
                }
                v101 = _fs_pad_length(*(unsigned __int8 *)(v15 + 1), v13);
                v16 = v122;
                v19 = v122 + 96;
                v18 = (_DWORD *)(v101 + v15 + 52);
                v20 = (signed __int64)(v18 + 2);
                v21 = (signed __int64)v18 + (unsigned int)(20 * *v18) + 8;
                if ( *(_DWORD *)(v11 + 48) <= 1 )
                  goto LABEL_28;
                v17 = *(unsigned __int8 *)(v15 + 1);
                v22 = (char *)(v21 + (unsigned int)v18[1]);
              }
              else
              {
                v20 = v15 + 60;
                v21 = v15 + 60 + (unsigned int)(20 * *(_DWORD *)(v15 + 52));
                v22 = (char *)(v21 + *(unsigned int *)(v15 + 56));
              }
              if ( v17 >= 8 )
              {
                *(_QWORD *)(v16 + 96) = *(_QWORD *)v22;
                *(_QWORD *)(v19 + v17 - 8) = *(_QWORD *)&v22[v17 - 8];
                v98 = (char *)((v19 + 8) & 0xFFFFFFFFFFFFFFF8LL);
                v99 = &v22[-(v19 - (_QWORD)v98)];
                v100 = (v17 + (_DWORD)v19 - (_DWORD)v98) >> 3;
                qmemcpy(v98, v99, 8LL * v100);
                v22 = &v99[8 * v100];
              }
              else if ( v17 & 4 )
              {
                *(_DWORD *)(v16 + 96) = *(_DWORD *)v22;
                *(_DWORD *)(v19 + v17 - 4) = *(_DWORD *)&v22[v17 - 4];
              }
              else if ( v17 )
              {
                *(_BYTE *)(v16 + 96) = *v22;
                if ( v17 & 2 )
                  *(_WORD *)(v19 + v17 - 2) = *(_WORD *)&v22[v17 - 2];
              }
              v23 = v21;
              v24 = v18;
              v25 = v16;
              v26 = v20;
              _fs_pad_length(*(unsigned __int8 *)(v15 + 1), v22);
              v21 = v23;
              v18 = v24;
              v16 = v25;
              v20 = v26;
LABEL_28:
              v123 = (_DWORD *)v16;
              v27 = _fs_convert_lfwi_reply(v11, v12, v15, v18, v20, v21);
              if ( v27 == 85 )
              {
                v123[1] = *(unsigned __int8 *)(v15 + 1);
                v102 = *(_DWORD *)(v15 + 8);
                *v123 = 1;
                v123[88] = v102;
                _fs_unmark_block(v11, 32LL);
                v103 = __fdelt_chk(*(signed int *)(v11 + 8));
                fs_fd_mask[v103] &= __ROL8__(-2LL, *(_DWORD *)(v11 + 8) % 64);
                _fs_done_read(v11, (unsigned int)(4 * *(_DWORD *)(v15 + 4)));
                *(_DWORD *)(v6 + 32) = 85;
                goto LABEL_41;
              }
              *v123 = 2;
              _fs_done_read(v11, (unsigned int)(4 * *(_DWORD *)(v15 + 4)));
              goto LABEL_30;
            }
            if ( (_DWORD)v150 )
            {
              *(_DWORD *)v122 = 2;
              _fs_done_read(v11, (unsigned int)(4 * *(_DWORD *)(v14 + 4)));
LABEL_57:
              *(_DWORD *)(v6 + 32) = 80;
              v27 = 80;
              goto LABEL_41;
            }
LABEL_59:
            *(_DWORD *)(v6 + 32) = 81;
            goto LABEL_10;
          }
          goto LABEL_54;
        }
        if ( v10 != 1 )
        {
LABEL_54:
          v27 = *(_DWORD *)(v6 + 32);
LABEL_40:
          if ( v27 != 81 )
          {
            do
            {
LABEL_41:
              v38 = *(struct _Client **)(v6 + 8);
              *(_DWORD *)(v6 + 32) = v27;
              if ( v38 != v2 )
                ClientSignal(v38);
              v6 = *(_QWORD *)(v6 + 40);
            }
            while ( v6 );
            _fs_unmark_block(v4, 8LL);
          }
LABEL_10:
          if ( (unsigned int)sub_27150(v4) )
            _fs_mark_block(v4, 32LL);
          else
            _fs_unmark_block(v4, 32LL);
          return __readfsqword(0x28u) ^ v152;
        }
        v39 = *(signed __int64 **)(v6 + 24);
        v40 = *((_DWORD *)v39 + 4);
        if ( v40 == 1 )
        {
          v63 = *(_QWORD *)(a1 + 24);
          v127 = *(signed __int64 **)(v6 + 24);
          v64 = sub_26AD0(*(_QWORD *)(a1 + 24), &v145);
          v44 = v127;
          if ( v64 )
          {
            if ( *(_BYTE *)v64 != 1 )
            {
              v65 = &v150;
              if ( !(*((_BYTE *)v127 + 20) & 0x20) )
                v65 = (__int64 *)(*v127 + 8);
              v133 = v127;
              *((_BYTE *)v65 + 10) = ((*(_BYTE *)(v64 + 8) & 1) << 6) | *((_BYTE *)v65 + 10) & 0xBF;
              *((_WORD *)v65 + 5) = ((*(_BYTE *)(v64 + 16) != 0) << 7) | *((_WORD *)v65 + 5) & 0xFE7F;
              *((_BYTE *)v65 + 10) = *((_BYTE *)v65 + 10) & 0xEF | 16 * ((*(_DWORD *)(v64 + 8) >> 1) & 1);
              *((_WORD *)v65 + 2) = *(unsigned __int8 *)(v64 + 12);
              *(_WORD *)v65 = *(unsigned __int8 *)(v64 + 13);
              *((_WORD *)v65 + 3) = *(unsigned __int8 *)(v64 + 14);
              *((_WORD *)v65 + 1) = *(unsigned __int8 *)(v64 + 15);
              *((_WORD *)v65 + 4) = *(unsigned __int8 *)(v64 + 19) + (*(unsigned __int8 *)(v64 + 18) << 8);
              *((_WORD *)v65 + 33) = *(_WORD *)(v64 + 46);
              *((_WORD *)v65 + 32) = *(_WORD *)(v64 + 44);
              *((_WORD *)v65 + 14) = *(_WORD *)(v64 + 20);
              *((_WORD *)v65 + 15) = *(_WORD *)(v64 + 22);
              *((_WORD *)v65 + 16) = *(_WORD *)(v64 + 24);
              *((_WORD *)v65 + 17) = *(_WORD *)(v64 + 26);
              *((_WORD *)v65 + 18) = *(_WORD *)(v64 + 28);
              *((_WORD *)v65 + 19) = *(_WORD *)(v64 + 30);
              *((_WORD *)v65 + 26) = *(_WORD *)(v64 + 20);
              *((_WORD *)v65 + 27) = *(_WORD *)(v64 + 22);
              *((_WORD *)v65 + 28) = *(_WORD *)(v64 + 24);
              *((_WORD *)v65 + 29) = *(_WORD *)(v64 + 26);
              *((_WORD *)v65 + 30) = *(_WORD *)(v64 + 28);
              *((_WORD *)v65 + 31) = *(_WORD *)(v64 + 30);
              *((_WORD *)v65 + 8) = *(_WORD *)(v64 + 32);
              *((_WORD *)v65 + 9) = *(_WORD *)(v64 + 34);
              *((_WORD *)v65 + 10) = *(_WORD *)(v64 + 36);
              *((_WORD *)v65 + 11) = *(_WORD *)(v64 + 38);
              *((_WORD *)v65 + 12) = *(_WORD *)(v64 + 40);
              *((_WORD *)v65 + 13) = *(_WORD *)(v64 + 42);
              *((_WORD *)v65 + 20) = *(_WORD *)(v64 + 32);
              *((_WORD *)v65 + 21) = *(_WORD *)(v64 + 34);
              v66 = v64;
              *((_WORD *)v65 + 22) = *(_WORD *)(v64 + 36);
              *((_WORD *)v65 + 23) = *(_WORD *)(v64 + 38);
              *((_WORD *)v65 + 24) = *(_WORD *)(v64 + 40);
              *((_WORD *)v65 + 25) = *(_WORD *)(v64 + 42);
              _fs_init_fontinfo(v63, v65);
              v67 = v63;
              v145 = _fs_convert_props(v66 + 48, v66 + 56, v66 + 56 + (unsigned int)(20 * *(_DWORD *)(v66 + 48)), v65);
              _fs_done_read(v63, (unsigned int)(4 * *(_DWORD *)(v66 + 4)));
              v68 = v133;
              if ( v145 != -1 )
              {
                v69 = *((_DWORD *)v133 + 5);
                v70 = *v133;
                if ( !(v69 & 0x20) )
                {
                  if ( *(_BYTE *)(v70 + 18) & 2 )
                    *((_DWORD *)v133 + 9) = *((_DWORD *)v133 + 9) & 0xFFFFFFF3 | 8;
                  if ( !glyphCachingMode || glyphCachingMode == 1 && !*(_WORD *)(v70 + 14) )
                  {
                    v69 |= 0xFu;
                    *((_DWORD *)v133 + 5) = v69;
                  }
                  if ( v69 & 8 )
                  {
                    v107 = *(_QWORD *)(v6 + 24);
                    v146 = 262420;
                    v108 = *(_QWORD *)(v3 + 24);
                    v147 = *(_QWORD *)(v107 + 8);
                    v109 = *(_DWORD *)(v107 + 36);
                    v149 = 0;
                    v148 = v109;
                    *(_WORD *)(v107 + 32) = *(_WORD *)(v108 + 16) + 1;
                    ++*(_DWORD *)(v108 + 16);
                    _fs_write(v108, &v146, 16LL);
                    v67 = v63;
                    _fs_flush(v63);
                    v68 = v133;
                  }
                  v110 = *((_WORD *)v68 + 15);
                  *((_DWORD *)v68 + 4) = 2;
                  *(_WORD *)(v6 + 16) = v110;
                  *(_DWORD *)(v63 + 156) = (unsigned __int64)GetTimeInMillis(v67) + 30000;
                  *(_DWORD *)(v6 + 32) = 81;
                  goto LABEL_10;
                }
                if ( *v65 != *(_QWORD *)(v70 + 8)
                  || *((_WORD *)v65 + 4) != *(_WORD *)(v70 + 16)
                  || (*(_BYTE *)(v70 + 18) ^ *((_BYTE *)v65 + 10)) & 0x7F
                  || (*(_WORD *)(v70 + 18) ^ *((_WORD *)v65 + 5)) & 0x180
                  || (*(_BYTE *)(v70 + 19) ^ *((_BYTE *)v65 + 11)) & 6
                  || *((_WORD *)v65 + 6) != *(_WORD *)(v70 + 20)
                  || v65[8] != *(_QWORD *)(v70 + 72)
                  || v65[2] != *(_QWORD *)(v70 + 24)
                  || *((_DWORD *)v65 + 6) != *(_DWORD *)(v70 + 32)
                  || *((_DWORD *)v65 + 7) != *(_DWORD *)(v70 + 36)
                  || v65[4] != *(_QWORD *)(v70 + 40)
                  || v65[5] != *(_QWORD *)(v70 + 48)
                  || *((_DWORD *)v65 + 12) != *(_DWORD *)(v70 + 56)
                  || *((_DWORD *)v65 + 13) != *(_DWORD *)(v70 + 60)
                  || v65[7] != *(_QWORD *)(v70 + 64) )
                {
LABEL_106:
                  sub_27270(v133);
                  _fs_free_props(v65);
                  v39 = v133;
                  goto LABEL_51;
                }
                v118 = 0LL;
                while ( *((_DWORD *)v65 + 17) > (signed int)v118 )
                {
                  if ( *(_BYTE *)(v65[10] + v118) == *(_BYTE *)(*(_QWORD *)(v70 + 88) + v118) )
                  {
                    v119 = (_QWORD *)(16 * v118 + v65[9]);
                    v120 = (_QWORD *)(*(_QWORD *)(v70 + 80) + 16 * v118);
                    if ( *v119 == *v120 )
                    {
                      ++v118;
                      if ( v119[1] == v120[1] )
                        continue;
                    }
                  }
                  goto LABEL_106;
                }
                *((_DWORD *)v133 + 4) = 4;
                _fs_free_props(v65);
                v71 = v133;
                goto LABEL_113;
              }
              goto LABEL_169;
            }
            if ( !v145 )
              goto LABEL_59;
            _fs_done_read(v63, (unsigned int)(4 * *(_DWORD *)(v64 + 4)));
            v44 = v127;
          }
          else if ( !v145 )
          {
            goto LABEL_59;
          }
LABEL_147:
          v96 = v44;
          sub_27270(v44);
          v39 = v96;
          goto LABEL_51;
        }
        if ( v40 > 1 )
        {
          if ( v40 != 2 )
          {
            if ( v40 != 3 || !(*((_BYTE *)v39 + 20) & 8) )
            {
LABEL_51:
              *((_DWORD *)v39 + 4) = 4;
              v41 = *(_QWORD *)(v6 + 40);
              v27 = 83;
              if ( !v41 )
              {
                *(_DWORD *)(v6 + 32) = 83;
                goto LABEL_41;
              }
              goto LABEL_52;
            }
            v81 = *(signed __int64 **)(v6 + 24);
            v27 = sub_27370(*(_QWORD *)(a1 + 24), (int *)v6, *(_QWORD **)(v6 + 24));
            v61 = v81;
            if ( v27 == 81 )
              goto LABEL_59;
            goto LABEL_93;
          }
          v42 = (_WORD *)*v39;
          v130 = *(signed __int64 **)(v6 + 24);
          v136 = *(_QWORD *)(a1 + 24);
          v138 = *(_QWORD *)(*v39 + 160);
          v137 = *(_QWORD **)(*v39 + 152);
          v43 = sub_26AD0(v136, &v146);
          v125 = v43;
          v44 = v130;
          if ( v43 )
          {
            if ( *(_BYTE *)v43 != 1 )
            {
              v45 = *(_DWORD *)(v43 + 8);
              if ( *(_BYTE *)(*v130 + 18) & 2 && *(_DWORD *)(v136 + 48) > 1 )
              {
                v46 = v130;
                v131 = *(_DWORD *)(v43 + 8);
                v139 = (char *)malloc(48LL * v45);
                v47 = v131;
                v48 = v46;
                if ( v139 )
                {
                  v137[1] = v139;
                  v137[2] = &v139[24 * v131];
                  goto LABEL_67;
                }
              }
              else
              {
                v94 = v130;
                v95 = *(_DWORD *)(v43 + 8);
                v139 = (char *)malloc(24LL * v45);
                v47 = v95;
                v48 = v94;
                if ( v139 )
                {
                  v10 = 0;
                  v137[1] = v139;
                  v137[2] = v139;
LABEL_67:
                  *(_QWORD *)(v138 + 16) = 0LL;
                  if ( v47 <= 0 )
                  {
                    v121 = v48;
                    _fs_done_read(v136, (unsigned int)(4 * *(_DWORD *)(v125 + 4)));
                    v71 = v121;
                  }
                  else
                  {
                    v135 = v10;
                    v49 = (_WORD *)v137[2];
                    v141 = v4;
                    v142 = v6;
                    v143 = v48;
                    v50 = v42;
                    v51 = v125 + 12;
                    v52 = v139 + 16;
                    v140 = 8 * (3LL * (unsigned int)(v47 - 1) + 3);
                    v132 = (_WORD *)(v137[2] + v140);
                    do
                    {
                      v150 = *(_QWORD *)v51;
                      v151 = *(_DWORD *)(v51 + 8);
                      _fs_convert_char_info(&v150, v49);
                      if ( v49[3] > v50[15] )
                      {
                        ErrorF("fserve: warning: %s %s ascent (%d) > maxascent (%d)\n");
                        v49[3] = v50[15];
                      }
                      if ( v49[4] > v50[16] )
                      {
                        ErrorF("fserve: warning: %s %s descent (%d) > maxdescent (%d)\n");
                        v49[4] = v50[16];
                      }
                      v51 += 12LL;
                      if ( *(_QWORD *)v49 & 0xFFFF0000FFFFFFFFLL || v49[4] || v49[2] )
                      {
                        if ( v135 || *v49 != v49[1] && (signed __int16)v49[4] + (signed __int16)v49[3] )
                        {
                          *v52 = &fs_glyph_undefined;
                          ++*(_QWORD *)(v138 + 16);
                        }
                        else
                        {
                          *v52 = &unk_23CD14;
                        }
                      }
                      else
                      {
                        *v52 = 0LL;
                      }
                      v49 += 12;
                      v52 += 3;
                    }
                    while ( v49 != v132 );
                    v82 = v50;
                    v4 = v141;
                    v2 = a2;
                    _fs_done_read(v136, (unsigned int)(4 * *(_DWORD *)(v125 + 4)));
                    v71 = v143;
                    if ( v135 )
                    {
                      v83 = -281470681743361LL;
                      v84 = (_WORD *)v137[1];
                      v85 = v137[2];
                      v128 = v85 + v140;
                      do
                      {
                        if ( v83 & *(_QWORD *)v85 || *(_WORD *)(v85 + 8) || *(_WORD *)(v85 + 4) )
                        {
                          v87 = 0;
                          v88 = 0;
                          if ( v82[30] <= 0 )
                            v88 = v82[30];
                          *v84 = v88;
                          v89 = v82[25];
                          if ( v82[26] >= v89 )
                            v89 = v82[26];
                          v84[1] = v89;
                          v86 = v82[36];
                          if ( v82[27] >= v86 )
                            v86 = v82[27];
                          v84[3] = v86;
                          v90 = v82[37];
                          if ( v82[28] >= v90 )
                            v90 = v82[28];
                          v84[4] = v90;
                          v91 = v82[25];
                          if ( v82[26] >= v91 )
                            v91 = v82[26];
                          if ( v82[30] <= 0 )
                            v87 = v82[30];
                          v84[2] = v91 - v87;
                          v84[5] = *(_WORD *)(v85 + 10);
                        }
                        else
                        {
                          *(_QWORD *)v84 = *(_QWORD *)v85;
                          *((_DWORD *)v84 + 2) = *(_DWORD *)(v85 + 8);
                          v86 = v84[3];
                        }
                        if ( v82[15] < v86 )
                        {
                          v93 = v83;
                          ErrorF("fserve: warning: %s %s ascent (%d) > maxascent (%d)\n");
                          v83 = v93;
                          v84[3] = v82[15];
                        }
                        if ( v84[4] > v82[16] )
                        {
                          v92 = v83;
                          ErrorF("fserve: warning: %s %s descent (%d) > maxdescent (%d)\n");
                          v83 = v92;
                          v84[4] = v82[16];
                        }
                        v84 += 12;
                        v85 += 24LL;
                      }
                      while ( v85 != v128 );
                      v4 = v141;
                      v6 = v142;
                      v71 = v143;
                      v2 = a2;
                    }
                  }
                  v72 = *(unsigned __int16 *)(*v71 + 8);
                  v73 = *(unsigned __int16 *)(*v71 + 10);
                  v74 = *(unsigned __int16 *)(*v71 + 16);
                  *v137 = 0LL;
                  v75 = *v71;
                  v76 = *(unsigned __int16 *)(*v71 + 14);
                  v77 = v73 + 1 - v72;
                  if ( (_WORD)v76 )
                  {
                    v75 = *(unsigned __int16 *)(v75 + 12);
                    v78 = (unsigned __int8)v74 - v72;
                    v79 = (v74 >> 8) - v75;
                    if ( v79 < v76 - (signed int)v75 + 1 && v77 > v78 )
                      *v137 = &v139[24 * (v78 + v77 * v79)];
                  }
                  else
                  {
                    v104 = v74 - v72;
                    if ( v77 > (unsigned int)v104 )
                      *v137 = &v139[24 * v104];
                  }
                  v80 = (*((_BYTE *)v71 + 20) & 8) == 0;
                  *((_DWORD *)v71 + 4) = 3;
                  if ( !v80 )
                  {
                    *(_WORD *)(v6 + 16) = *((_WORD *)v71 + 16);
                    *(_DWORD *)(v136 + 156) = (unsigned __int64)GetTimeInMillis(v75) + 30000;
                    *(_DWORD *)(v6 + 32) = 81;
                    goto LABEL_10;
                  }
LABEL_113:
                  *((_DWORD *)v71 + 4) = 4;
                  goto LABEL_114;
                }
              }
              v105 = v48;
              _fs_done_read(v136, (unsigned int)(4 * *(_DWORD *)(v125 + 4)));
              v68 = v105;
LABEL_169:
              v106 = v68;
              v27 = 80;
              sub_27270(v68);
              *((_DWORD *)v106 + 4) = 4;
              v41 = *(_QWORD *)(v6 + 40);
              if ( !v41 )
              {
                *(_DWORD *)(v6 + 32) = 80;
                goto LABEL_41;
              }
              goto LABEL_52;
            }
            if ( !v146 )
              goto LABEL_59;
            _fs_done_read(v136, (unsigned int)(4 * *(_DWORD *)(v43 + 4)));
            v44 = v130;
          }
          else if ( !v146 )
          {
            goto LABEL_59;
          }
          goto LABEL_147;
        }
        if ( v40 )
          goto LABEL_51;
        v53 = *(_QWORD *)(a1 + 24);
        v126 = *(signed __int64 **)(v6 + 24);
        v54 = sub_26AD0(v53, &v150);
        v55 = v54;
        v56 = v126;
        if ( v54 )
        {
          if ( *(_BYTE *)v54 != 1 )
          {
            if ( *(_DWORD *)(v54 + 8) && !(*((_BYTE *)v126 + 20) & 0x20) )
            {
              sub_27270(v126);
              v114 = find_old_font(*(unsigned int *)(v55 + 8));
              v59 = v126;
              *v126 = v114;
              *((_DWORD *)v126 + 6) = 0;
              v115 = *(unsigned int *)(v55 + 8);
              *((_DWORD *)v126 + 4) = 4;
              v126[1] = v115;
              v116 = *(_QWORD *)(v53 + 176);
              if ( v116 )
              {
                while ( 1 )
                {
                  if ( v6 != v116 && *(_DWORD *)v116 == 1 )
                  {
                    v117 = *(unsigned __int64 **)(v116 + 24);
                    if ( v117[1] == *(_DWORD *)(v55 + 8) )
                      break;
                  }
                  v116 = *(_QWORD *)(v116 + 48);
                  if ( !v116 )
                    goto LABEL_186;
                }
                *(_QWORD *)(v6 + 40) = *(_QWORD *)(v116 + 40);
                *(_QWORD *)(v116 + 40) = v6;
                *((_DWORD *)v126 + 4) = 5;
                v114 = *v117;
                *v126 = *v117;
              }
LABEL_186:
              LODWORD(v150) = v114 < 1 ? 83 : 1024;
            }
            else
            {
              *(_BYTE *)(*v126 + 19) = 2 * (*(_BYTE *)(v54 + 12) != 0) | *(_BYTE *)(*v126 + 19) & 0xFD;
              v57 = *((_WORD *)v126 + 14);
              *((_DWORD *)v126 + 4) = 1;
              *(_WORD *)(v6 + 16) = v57;
              v58 = GetTimeInMillis(v53);
              v59 = v126;
              *(_DWORD *)(v53 + 156) = v58 + 30000;
              LODWORD(v150) = 81;
            }
            v60 = v59;
            _fs_done_read(v53, (unsigned int)(4 * *(_DWORD *)(v55 + 4)));
            v27 = v150;
            v61 = v60;
            if ( (_DWORD)v150 == 81 )
              goto LABEL_59;
LABEL_91:
            v62 = *((_DWORD *)v61 + 4);
            if ( v62 != 4 )
            {
              if ( v62 == 5 )
                goto LABEL_59;
LABEL_93:
              *((_DWORD *)v61 + 4) = 4;
              v41 = *(_QWORD *)(v6 + 40);
              if ( !v41 )
              {
LABEL_30:
                *(_DWORD *)(v6 + 32) = v27;
                goto LABEL_40;
              }
              do
              {
LABEL_52:
                *(_DWORD *)(*(_QWORD *)(v41 + 24) + 16LL) = 4;
                v41 = *(_QWORD *)(v41 + 40);
              }
              while ( v41 );
              goto LABEL_30;
            }
LABEL_114:
            v41 = *(_QWORD *)(v6 + 40);
            v27 = 85;
            if ( !v41 )
            {
              *(_DWORD *)(v6 + 32) = 85;
              goto LABEL_41;
            }
            goto LABEL_52;
          }
          if ( !(_DWORD)v150 )
            goto LABEL_59;
          _fs_done_read(v53, (unsigned int)(4 * *(_DWORD *)(v54 + 4)));
          v56 = v126;
        }
        else if ( !(_DWORD)v150 )
        {
          goto LABEL_59;
        }
        v97 = v56;
        v27 = 83;
        sub_27270(v56);
        v61 = v97;
        goto LABEL_91;
      }
      while ( 1 )
      {
        v6 = *(_QWORD *)(v6 + 48);
        if ( !v6 )
          break;
        if ( *(_WORD *)(v6 + 16) == v8 )
          goto LABEL_13;
      }
    }
    if ( *(_WORD *)v7 == 2 )
    {
      LOBYTE(v150) = 0;
      WORD1(v150) = 1;
      ++*(_DWORD *)(v4 + 16);
      _fs_write(v4, &v150, 4LL);
    }
    _fs_done_read(v4, (unsigned int)(4 * *(_DWORD *)(v7 + 4)));
    goto LABEL_10;
  }
  return __readfsqword(0x28u) ^ v152;
}
// 8130: using guessed type __int64 __fastcall _fs_init_fontinfo(_QWORD, _QWORD);
// 8390: using guessed type __int64 __fastcall _fs_done_read(_QWORD, _QWORD);
// 8450: using guessed type __int64 __fastcall _fs_convert_lfwi_reply(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 85A0: using guessed type __int64 __fastcall _fs_pad_length(_QWORD, _QWORD);
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);
// 8890: using guessed type __int64 __fastcall _fs_flush(_QWORD);
// 8A00: using guessed type __int64 __fastcall _fs_convert_char_info(_QWORD, _QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);
// 8EE0: using guessed type __int64 __fastcall find_old_font(_QWORD);
// 8FD0: using guessed type __int64 __fastcall _fs_convert_props(_QWORD, _QWORD, _QWORD, _QWORD);
// 9040: using guessed type __int64 __fastcall ErrorF(_QWORD);
// 9080: using guessed type __int64 __fastcall _fs_free_props(_QWORD);

//----- (0000000000029CC0) ----------------------------------------------------
__int64 __fastcall sub_29CC0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rbx

  result = sub_27DB0(a1);
  if ( (_DWORD)result == -1 )
  {
    result = (unsigned int)GetTimeInMillis(a1) + 1000;
    *(_DWORD *)(a1 + 168) = result;
  }
  else if ( (_DWORD)result == 1 )
  {
    _fs_unmark_block(a1, 80LL);
    result = _fs_unmark_block(a1, 16LL);
LABEL_4:
    v2 = *(_QWORD *)(a1 + 176);
    while ( v2 )
    {
      if ( *(_DWORD *)(v2 + 32) == 81 )
      {
        ClientSignal(*(ClientPtr *)(v2 + 8));
        result = sub_283D0(a1, (int *)v2);
        goto LABEL_4;
      }
    }
  }
  return result;
}
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);

//----- (0000000000029D50) ----------------------------------------------------
signed __int64 __fastcall sub_29D50(FontPathElementPtr fpe)
{
  __int64 *v1; // rdx
  FontPathElementPtr v2; // rbp
  __int64 *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // r12
  bool v6; // zf

  v1 = (__int64 *)qword_23CD20;
  v2 = fpe;
  v3 = (__int64 *)fpe->c_private;
  if ( qword_23CD20 )
  {
    if ( (__int64 *)qword_23CD20 == v3 )
    {
      v1 = &qword_23CD20;
LABEL_10:
      *v1 = *v3;
    }
    else
    {
      while ( *v1 )
      {
        if ( v3 == (__int64 *)*v1 )
          goto LABEL_10;
        v1 = (__int64 *)*v1;
      }
    }
  }
  _fs_unmark_block(v3, *((unsigned int *)v3 + 38));
  sub_27D30((__int64)v3);
  v4 = (_QWORD *)v3[8];
  if ( v4 )
  {
    do
    {
      v5 = (_QWORD *)v4[1];
      free(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  v6 = qword_23CD20 == 0;
  v3[8] = 0LL;
  remove_fs_handlers(v2, (BlockHandlerProcPtr)block_handler, v6);
  sub_282B0(v3);
  v2->c_private = 0LL;
  return 85LL;
}
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 23CD20: using guessed type __int64 qword_23CD20;

//----- (0000000000029E20) ----------------------------------------------------
signed __int64 __fastcall sub_29E20(FontPathElementPtr fpe)
{
  const char *v1; // rbp
  size_t v2; // rax
  signed __int64 v3; // rsi
  char *v4; // rax
  char *v5; // rbx
  __int64 v7; // rax
  int v8; // eax

  v1 = &fpe->name[*fpe->name == 58];
  v2 = strlen(v1);
  v3 = v2 + 193;
  v4 = (char *)calloc(1uLL, v2 + 193);
  if ( !v4 )
    return 80LL;
  v5 = v4;
  if ( !(unsigned int)_fs_io_init(v4, v3) )
  {
    free(v5);
    return 80LL;
  }
  *((_QWORD *)v5 + 1) = 0xFFFFFFFFLL;
  *((_QWORD *)v5 + 3) = v5 + 192;
  strcpy(v5 + 192, v1);
  if ( init_fs_handlers(fpe, (BlockHandlerProcPtr)block_handler) != 85 )
  {
    sub_282B0(v5);
    return 80LL;
  }
  v7 = qword_23CD20;
  fpe->c_private = v5;
  qword_23CD20 = (__int64)v5;
  *(_QWORD *)v5 = v7;
  while ( 1 )
  {
    v8 = sub_27DB0((__int64)v5);
    if ( v8 )
      break;
    if ( *((_DWORD *)v5 + 3) > 1 )
    {
      if ( (unsigned int)_fs_wait_for_readable(v5, 1000LL) == -1 )
        goto LABEL_11;
    }
    else if ( (unsigned int)_fs_poll_connect(*((_QWORD *)v5 + 23), 1000LL) == -1 )
    {
      goto LABEL_11;
    }
  }
  if ( v8 != 1 )
  {
LABEL_11:
    sub_29D50(fpe);
    return 86LL;
  }
  return 85LL;
}
// 8280: using guessed type __int64 __fastcall _fs_wait_for_readable(_QWORD, _QWORD);
// 8400: using guessed type __int64 __fastcall _fs_poll_connect(_QWORD, _QWORD);
// 8720: using guessed type __int64 __fastcall _fs_io_init(_QWORD, _QWORD);
// 23CD20: using guessed type __int64 qword_23CD20;

//----- (0000000000029F60) ----------------------------------------------------
void __fastcall fs_connection_died(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // rbp

  if ( !(*(_BYTE *)(a1 + 152) & 4) )
  {
    v1 = a1;
    sub_27D30(a1);
    v2 = *(_QWORD **)(a1 + 64);
    if ( v2 )
    {
      do
      {
        v3 = (_QWORD *)v2[1];
        free(v2);
        v2 = v3;
      }
      while ( v3 );
    }
    *(_QWORD *)(v1 + 64) = 0LL;
    *(_DWORD *)(v1 + 168) = GetTimeInMillis(v2);
    _fs_mark_block(v1, 4LL);
    _fs_unmark_block(v1, 67LL);
  }
}
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (0000000000029FE0) ----------------------------------------------------
signed __int64 __fastcall sub_29FE0(__int64 a1)
{
  signed __int64 result; // rax
  unsigned int v2; // [rsp+4h] [rbp-24h]
  unsigned __int64 v3; // [rsp+8h] [rbp-20h]

  v3 = __readfsqword(0x28u);
  do
  {
    if ( sub_26AD0(a1, &v2) )
      return 1LL;
    result = v2;
    if ( v2 )
      return result;
  }
  while ( (unsigned int)_fs_wait_for_readable(a1, 30000LL) == 1 );
  _fs_connection_died(a1);
  return 0xFFFFFFFFLL;
}
// 8100: using guessed type __int64 __fastcall _fs_connection_died(_QWORD);
// 8280: using guessed type __int64 __fastcall _fs_wait_for_readable(_QWORD, _QWORD);

//----- (000000000002A070) ----------------------------------------------------
signed __int64 __fastcall sub_2A070(__int64 a1, __int64 a2, int a3, char *a4, unsigned int a5, unsigned int a6, unsigned int a7, __int64 *a8)
{
  __int64 v8; // r15
  signed __int64 result; // rax
  int v10; // ebx
  int v11; // er13
  struct _Client *v12; // rbp
  __int64 v13; // r14
  __int64 *v14; // r12
  Atom v15; // rax
  int v16; // edx
  __int64 v17; // rsi
  _QWORD *v18; // rcx
  __int64 v19; // rdx
  signed __int64 v20; // rsi
  Atom v21; // rdi
  __int64 v22; // rax
  int v23; // eax
  __int64 v24; // rax
  __int64 v25; // rsi
  __int64 v26; // rax
  int v27; // eax
  __int64 v28; // rax
  __int64 v29; // rax
  char *v30; // [rsp+0h] [rbp-498h]
  unsigned int v31; // [rsp+0h] [rbp-498h]
  _QWORD *v32; // [rsp+8h] [rbp-490h]
  __int64 v33; // [rsp+18h] [rbp-480h]
  __int16 v34; // [rsp+2Ch] [rbp-46Ch]
  __int16 v35; // [rsp+2Eh] [rbp-46Ah]
  int v36; // [rsp+30h] [rbp-468h]
  __int16 v37; // [rsp+34h] [rbp-464h]
  __int16 v38; // [rsp+36h] [rbp-462h]
  __int64 v39; // [rsp+38h] [rbp-460h]
  __int16 v40; // [rsp+40h] [rbp-458h]
  __int16 v41; // [rsp+42h] [rbp-456h]
  int v42; // [rsp+44h] [rbp-454h]
  int v43; // [rsp+48h] [rbp-450h]
  int v44; // [rsp+4Ch] [rbp-44Ch]
  char v45; // [rsp+50h] [rbp-448h]
  char v46; // [rsp+51h] [rbp-447h]
  unsigned __int64 v47; // [rsp+458h] [rbp-40h]

  v8 = *(_QWORD *)(a2 + 24);
  v47 = __readfsqword(0x28u);
  v30 = a4;
  result = 83LL;
  if ( *(_BYTE *)(v8 + 152) & 0x10 )
    return result;
  v10 = a3;
  v11 = a5;
  if ( a5 - 1 > 0x3FE )
    return result;
  v12 = (struct _Client *)a1;
  v33 = a3 & 0x20;
  if ( a3 & 0x20 )
  {
    v13 = *a8;
    v14 = *(__int64 **)(*a8 + 160);
    v15 = MakeAtom("FONT", 4u, 0);
    if ( !v15 )
      goto LABEL_21;
    v16 = *(_DWORD *)(v13 + 76);
    if ( v16 <= 0 )
      goto LABEL_21;
    v17 = (unsigned int)(v16 - 1);
    v18 = *(_QWORD **)(v13 + 80);
    v19 = 0LL;
    v20 = v17 + 1;
    while ( v15 != *v18 || !*(_BYTE *)(*(_QWORD *)(v13 + 88) + v19) )
    {
      ++v19;
      v18 += 2;
      if ( v20 == v19 )
        goto LABEL_21;
    }
    v21 = v18[1];
    if ( v21 && (v30 = NameForAtom(v21)) != 0LL )
    {
      v11 = strlen(v30);
    }
    else
    {
LABEL_21:
      v11 = *((_DWORD *)v14 + 6);
      v30 = (char *)v14[4];
    }
    v32 = sub_272E0(*(_QWORD *)(*(_QWORD *)(v13 + 136) + 24LL), (__int64)v12, 1);
    if ( v32 )
      goto LABEL_23;
    return 80LL;
  }
  v24 = fs_create_font(a2, a4, a5, a6, a7);
  v13 = v24;
  if ( !v24 )
    return 80LL;
  v14 = *(__int64 **)(v24 + 160);
  v32 = sub_272E0(*(_QWORD *)(*(_QWORD *)(v24 + 136) + 24LL), a1, 1);
  if ( !v32 )
  {
    (*(void (__fastcall **)(__int64, __int64))(v13 + 120))(v13, a1);
    return 80LL;
  }
LABEL_23:
  v23 = *(_DWORD *)(v8 + 152);
  if ( v23 & 0x44 )
  {
    if ( !(v23 & 8) )
      sub_27910(v8);
    return 84LL;
  }
  *((_DWORD *)v14 + 2) = *(_DWORD *)(v8 + 36);
  v25 = v32[3];
  v26 = *v14;
  *(_DWORD *)(v25 + 20) = v10;
  *(_QWORD *)(v25 + 8) = v26;
  *(_QWORD *)v25 = v13;
  *(_DWORD *)(v25 + 16) = 0;
  LODWORD(v26) = *((_DWORD *)v14 + 10);
  *(_QWORD *)(v25 + 40) = 0LL;
  *(_DWORD *)(v25 + 36) = v26;
  *(_DWORD *)(v25 + 24) = v33 == 0;
  sub_27710(v8, v12);
  sub_26DB0(v8);
  v45 = v11;
  __memcpy_chk(&v46, v30, v11, 1023LL);
  v40 = 15;
  v42 = *v14;
  v44 = *((_DWORD *)v14 + 10);
  v27 = *((_DWORD *)v14 + 11);
  ++*(_DWORD *)(v8 + 16);
  v43 = v27;
  v41 = (v11 + 20) >> 2;
  _fs_write(v8, &v40, 16LL);
  _fs_write_pad(v8, &v45, v11 + 1);
  *((_WORD *)v32 + 8) = *(_DWORD *)(v8 + 16);
  v34 = 16;
  v28 = *v14;
  v35 = 2;
  v36 = v28;
  *(_WORD *)(v25 + 28) = *(_WORD *)(v8 + 16) + 1;
  ++*(_DWORD *)(v8 + 16);
  _fs_write(v8, &v34, 8LL);
  if ( !(*(_BYTE *)(v25 + 20) & 0x20) )
  {
    v37 = 274;
    v29 = *v14;
    v38 = 3;
    v39 = (unsigned int)v29;
    *(_WORD *)(v25 + 30) = *(_WORD *)(v8 + 16) + 1;
    ++*(_DWORD *)(v8 + 16);
    _fs_write(v8, &v37, 12LL);
  }
  sub_27930(v8);
  result = *((unsigned int *)v32 + 8);
  if ( *(_BYTE *)(v25 + 20) & 0x10 )
  {
    while ( (_DWORD)result == 81 )
    {
      if ( !(*(_BYTE *)(v8 + 152) & 0x20) && (unsigned int)sub_29FE0(v8) != 1 )
      {
        *((_DWORD *)v32 + 8) = 83;
        sub_27270((signed __int64 *)v25);
        *(_DWORD *)(v25 + 24) = 0;
        sub_282E0(v8, v32);
        return 83LL;
      }
      sub_288D0(*(_QWORD *)(v13 + 136), v12);
      LODWORD(result) = *((_DWORD *)v32 + 8);
    }
    v31 = result;
    if ( (_DWORD)result == 85 )
    {
      v22 = v25;
      *a8 = *(_QWORD *)v25;
    }
    else
    {
      sub_27270((signed __int64 *)v25);
      v22 = v25;
    }
    *(_DWORD *)(v22 + 24) = 0;
    sub_282E0(v8, v32);
    result = v31;
  }
  else if ( (_DWORD)result == 81 )
  {
    return 84LL;
  }
  return result;
}
// 8710: using guessed type __int64 __fastcall fs_create_font(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8760: using guessed type __int64 __fastcall _fs_write_pad(_QWORD, _QWORD, _QWORD);
// 8830: using guessed type __int64 __fastcall _fs_write(_QWORD, _QWORD, _QWORD);
// 88D0: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002A4F0) ----------------------------------------------------
signed __int64 __fastcall load_glyphs(pointer client, FontPtr pfont, int range_flag, unsigned int nchars, int item_size, unsigned __int8 *data)
{
  unsigned int v6; // er14
  pointer v7; // r12
  __int64 v8; // rdx
  FontPtr v9; // rdi
  __int64 v10; // rcx
  unsigned __int8 *v11; // r8
  FontPathElementPtr v12; // rax
  __int64 v13; // r13
  __int64 i; // rbx
  _QWORD *v15; // rax
  __int64 *v16; // rbp
  signed __int64 result; // rax
  _QWORD *v18; // rax
  _QWORD *v19; // rdx
  _QWORD *v20; // rsi
  int v21; // eax
  unsigned int v22; // ST14_4
  unsigned int v23; // [rsp+4h] [rbp-64h]
  unsigned int v24; // [rsp+8h] [rbp-60h]
  unsigned int v25; // [rsp+Ch] [rbp-5Ch]
  unsigned __int8 *v26; // [rsp+10h] [rbp-58h]
  FontPtr v27; // [rsp+18h] [rbp-50h]
  unsigned int v28; // [rsp+2Ch] [rbp-3Ch]
  void *ptr; // [rsp+30h] [rbp-38h]
  unsigned __int64 v30; // [rsp+38h] [rbp-30h]

  v6 = range_flag;
  v7 = client;
  v8 = nchars;
  v9 = pfont;
  v10 = (unsigned int)item_size;
  v11 = data;
  v30 = __readfsqword(0x28u);
  v12 = pfont->fpe;
  v27 = pfont;
  v28 = 0;
  ptr = 0LL;
  v13 = (__int64)v12->c_private;
  for ( i = *(_QWORD *)(v13 + 176); i; i = *(_QWORD *)(i + 48) )
  {
    if ( *(_DWORD *)i == 2 )
    {
      v15 = *(_QWORD **)(i + 24);
      if ( v9 == (FontPtr)*v15 )
      {
        v16 = v15 + 3;
        if ( *(pointer *)(i + 8) != v7 )
          goto LABEL_8;
        if ( *(_DWORD *)(i + 32) == 81 )
          return 84LL;
        v22 = *(_DWORD *)(i + 32);
        sub_26B90(v16);
        sub_282E0(v13, (_QWORD *)i);
        return v22;
      }
    }
    else if ( *(_DWORD *)i == 1 )
    {
      v20 = *(_QWORD **)(i + 24);
      if ( v9 == (FontPtr)*v20 )
      {
        v21 = *(_DWORD *)(i + 32);
        if ( *(pointer *)(i + 8) == v7 )
        {
          v26 = data;
          v25 = v10;
          v24 = v8;
          v23 = *(_DWORD *)(i + 32);
          if ( v21 == 81 )
            return 84LL;
          sub_26B90(v20 + 5);
          sub_282E0(v13, (_QWORD *)i);
          result = v23;
          v9 = v27;
          v8 = v24;
          v10 = v25;
          v11 = v26;
          if ( v23 != 85 )
            return result;
          break;
        }
        if ( v21 == 81 )
        {
          v16 = v20 + 5;
LABEL_8:
          result = fs_build_range(v9, v6, v8, v10, data, &v28, &ptr);
          if ( (_DWORD)result != 85 )
            goto LABEL_23;
          if ( v28 )
          {
            _fs_clean_aborted_loadglyphs(v27, v28, ptr);
            free(ptr);
          }
          v18 = (_QWORD *)*v16;
          if ( *v16 )
          {
            while ( 1 )
            {
              if ( v7 == (pointer)*v18 )
                return 84LL;
              if ( !v18[1] )
                break;
              v18 = (_QWORD *)v18[1];
            }
            v16 = v18 + 1;
          }
          v19 = malloc(0x10uLL);
          result = 11LL;
          if ( v19 )
          {
            *v19 = v7;
            v19[1] = 0LL;
            *v16 = (__int64)v19;
            return 84LL;
          }
          return result;
        }
      }
    }
  }
  result = fs_build_range(v9, v6, v8, v10, v11, &v28, &ptr);
  if ( (_DWORD)result == 85 )
  {
    if ( *((_DWORD *)v27->fpePrivate + 2) == *(_DWORD *)(v13 + 36) )
    {
      result = sub_27950((__int64)v7, (__int64)v27, v28, (char *)ptr);
    }
    else
    {
      _fs_clean_aborted_loadglyphs(v27, v28, ptr);
      free(ptr);
      result = sub_2A070((__int64)v7, (__int64)v27->fpe, 32, 0LL, 0, 0, 0, (__int64 *)&v27);
    }
  }
  else
  {
LABEL_23:
    if ( (_DWORD)result == 1024 )
      result = 85LL;
  }
  return result;
}
// 89E0: using guessed type __int64 __fastcall fs_build_range(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 8B90: using guessed type __int64 __fastcall _fs_clean_aborted_loadglyphs(_QWORD, _QWORD, _QWORD);

//----- (000000000002A7C0) ----------------------------------------------------
signed __int64 __fastcall sub_2A7C0(pointer client, FontPathElementPtr fpe, Mask flags, char *name, int namelen, fsBitmapFormat format, fsBitmapFormatMask fmask, XID id, FontPtr *pFont, char **aliasName)
{
  unsigned int v10; // er9
  _QWORD *v11; // rbp
  __int64 v12; // rbx
  unsigned int v13; // er12
  FontPtr *v14; // rdi

  v10 = format & 0xFFFFFFF3;
  v11 = fpe->c_private;
  *aliasName = 0LL;
  v12 = v11[22];
  if ( !v12 )
    return sub_2A070((__int64)client, (__int64)fpe, flags, name, namelen, v10, fmask, (__int64 *)pFont);
  while ( *(_DWORD *)v12 != 1 || *(pointer *)(v12 + 8) != client )
  {
    v12 = *(_QWORD *)(v12 + 48);
    if ( !v12 )
      return sub_2A070((__int64)client, (__int64)fpe, flags, name, namelen, v10, fmask, (__int64 *)pFont);
  }
  v13 = *(_DWORD *)(v12 + 32);
  if ( v13 == 81 )
  {
    v13 = 84;
  }
  else
  {
    v14 = *(FontPtr **)(v12 + 24);
    if ( v13 == 85 )
      *pFont = *v14;
    else
      sub_27270((signed __int64 *)v14);
    sub_282E0((__int64)v11, (_QWORD *)v12);
  }
  return v13;
}

//----- (000000000002A860) ----------------------------------------------------
__int64 __fastcall wakeup_func(FontPathElementPtr fpe, unsigned __int64 *LastSelectMask)
{
  signed int *v2; // rbx
  signed int v3; // eax
  FontPathElementPtr v4; // rbp
  __int64 v5; // rdi
  int v7; // eax
  signed int v8; // edx
  __int64 v9; // rbp

  v2 = (signed int *)fpe->c_private;
  v3 = v2[38];
  if ( v3 & 0x40 )
  {
    v5 = (__int64)fpe->c_private;
    sub_29CC0(v5);
    v3 = v2[38];
  }
  else
  {
    v4 = fpe;
    if ( v3 & 0x20 )
      goto LABEL_29;
    v5 = v2[2];
    if ( (_DWORD)v5 == -1 )
      goto LABEL_6;
    if ( (1LL << v2[2] % 64) & LastSelectMask[__fdelt_chk(v5)] )
    {
LABEL_29:
      v5 = (__int64)v4;
      sub_288D0((__int64)v4, 0LL);
      v3 = v2[38];
    }
    else
    {
      v3 = v2[38];
    }
  }
LABEL_6:
  if ( v3 & 0xE )
  {
    v7 = GetTimeInMillis(v5);
    v8 = v2[38];
    if ( v8 & 8 && v2[39] - v7 <= 0 )
    {
      if ( !(v8 & 0x10) )
      {
        _fs_mark_block(v2, 16LL);
LABEL_21:
        v9 = *((_QWORD *)v2 + 22);
        while ( v9 )
        {
          if ( *(_DWORD *)(v9 + 32) == 81 )
          {
            ClientSignal(*(ClientPtr *)(v9 + 8));
            sub_283D0((__int64)v2, (int *)v9);
            goto LABEL_21;
          }
        }
        if ( v2[2] >= 0 )
          _fs_connection_died(v2);
      }
    }
    else if ( v8 & 4 )
    {
      if ( v2[42] - v7 <= 0 && !(v8 & 0x40) )
      {
        v2[11] = 0;
        _fs_mark_block(v2, 64LL);
        _fs_unmark_block(v2, 4LL);
        sub_29CC0((__int64)v2);
      }
    }
    else if ( v8 & 2 && v2[40] - v7 <= 0 )
    {
      _fs_flush(v2);
    }
  }
  return 0LL;
}
// 8100: using guessed type __int64 __fastcall _fs_connection_died(_QWORD);
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8890: using guessed type __int64 __fastcall _fs_flush(_QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (000000000002A9E0) ----------------------------------------------------
__int64 __fastcall fs_load_all_glyphs(FontPtr pfont)
{
  _BYTE *v1; // r12
  __int64 result; // rax

  v1 = pfont->fpe->c_private;
  while ( 1 )
  {
    result = load_glyphs(serverClient[0], pfont, 1, 0, 0, 0LL);
    if ( (_DWORD)result != 84 )
      break;
    if ( !(v1[152] & 0x20) && (unsigned int)sub_29FE0((__int64)v1) != 1 )
    {
      client_died(serverClient[0], pfont->fpe);
      return 87LL;
    }
    sub_288D0((__int64)pfont->fpe, (struct _Client *)serverClient[0]);
  }
  return result;
}

//----- (000000000002AA70) ----------------------------------------------------
int fs_register_fpe_functions()
{
  return RegisterFPEFunctions(
           (NameCheckFunc)sub_26E50,
           (InitFpeFunc)sub_29E20,
           (FreeFpeFunc)sub_29D50,
           (ResetFpeFunc)sub_27130,
           (OpenFontFunc)sub_2A7C0,
           (CloseFontFunc)sub_27230,
           (ListFontsFunc)sub_28730,
           (StartLfwiFunc)sub_27B60,
           (NextLfwiFunc)sub_285E0,
           (WakeupFpeFunc)wakeup_func,
           (ClientDiedFunc)client_died,
           (LoadGlyphsFunc)load_glyphs,
           0LL,
           0LL,
           0LL);
}

//----- (000000000002AAE0) ----------------------------------------------------
signed __int64 __fastcall sub_2AAE0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  _QWORD *v4; // rbx
  size_t v5; // rdx
  unsigned int v6; // er12
  signed __int64 v8; // rax
  bool v9; // sf
  signed __int64 v10; // rbp
  void *v11; // rdi
  unsigned __int64 v12; // rbp
  void *v13; // rax

  v2 = a2;
  v3 = a1[3];
  v4 = a1;
  if ( v3 )
  {
    v5 = a1[2] - v3;
    if ( v3 != a1[2] )
    {
      memmove((void *)*a1, (const void *)(*a1 + v3), v5);
      v5 = a1[2] - a1[3];
    }
    a1[2] = v5;
    a1[3] = 0LL;
  }
  v6 = 1;
  if ( a1[1] >= v2 )
    return v6;
  v8 = v2 + 2047;
  v9 = v2 + 1024 < 0;
  v10 = v2 + 1024;
  v11 = (void *)*a1;
  if ( v9 )
    v10 = v8;
  v12 = v10 & 0xFFFFFFFFFFFFFC00LL;
  v13 = realloc(v11, v12);
  if ( !v13 )
    return (unsigned int)-1;
  *v4 = v13;
  v4[1] = v12;
  return 1LL;
}

//----- (000000000002AB80) ----------------------------------------------------
signed __int64 __fastcall fs_poll_connect(__int64 a1, int a2)
{
  int v2; // eax
  int v3; // er15
  __int64 v4; // rbp
  signed __int64 v5; // r13
  __int64 v6; // rax
  int v7; // eax
  __int64 v9; // [rsp+0h] [rbp-D8h]
  __int64 v10; // [rsp+8h] [rbp-D0h]
  fd_set writefds; // [rsp+10h] [rbp-C8h]
  unsigned __int64 v12; // [rsp+98h] [rbp-40h]

  v12 = __readfsqword(0x28u);
  v2 = _FontTransGetConnectionNumber(a1);
  v3 = v2 + 1;
  v4 = v2;
  v5 = 1LL << v2 % 64;
  do
  {
    v10 = 0LL;
    v9 = a2;
    memset(&writefds, 0, sizeof(writefds));
    v6 = __fdelt_chk(v4);
    writefds.fds_bits[v6] |= v5;
    v7 = select(v3, 0LL, &writefds, 0LL, (struct timeval *)&v9);
    if ( v7 >= 0 )
      return v7 != 0;
  }
  while ( *__errno_location() == 4 );
  return 0xFFFFFFFFLL;
}
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 8ED0: using guessed type __int64 __fastcall _FontTransGetConnectionNumber(_QWORD);

//----- (000000000002AC60) ----------------------------------------------------
void *__fastcall fs_connect(__int64 a1, signed int *a2)
{
  __int64 v2; // rax
  void *v3; // rbp
  signed int v4; // ebx
  int v5; // eax
  void *v6; // rdi
  signed int v7; // edx

  v2 = _FontTransOpenCOTSClient();
  v3 = (void *)v2;
  if ( v2 )
  {
    v4 = 6;
    _FontTransSetOption(v2, 1LL, 1LL);
    while ( 1 )
    {
      v5 = _FontTransConnect(v3, a1);
      if ( v5 != -2 )
        break;
      if ( !--v4 )
        goto LABEL_5;
    }
    if ( v5 < 0 )
    {
      v7 = 0;
      if ( v5 != -3 )
      {
LABEL_5:
        v6 = v3;
        v3 = 0LL;
        _FontTransClose(v6);
        v7 = -1;
        goto LABEL_8;
      }
    }
    else
    {
      v7 = 1;
    }
LABEL_8:
    *a2 = v7;
  }
  else
  {
    *a2 = -1;
  }
  return v3;
}
// 8510: using guessed type __int64 __fastcall _FontTransConnect(_QWORD, _QWORD);
// 8CB0: using guessed type __int64 _FontTransOpenCOTSClient(void);
// 8CF0: using guessed type __int64 __fastcall _FontTransSetOption(_QWORD, _QWORD, _QWORD);

//----- (000000000002AD00) ----------------------------------------------------
char *__fastcall fs_done_read(__int64 a1, __int64 a2)
{
  char *v2; // rdx
  char *result; // rax
  bool v4; // cc

  v2 = *(char **)(a1 + 128);
  result = *(char **)(a1 + 136);
  if ( *(_QWORD *)(a1 + 128) - (_QWORD)result >= a2 )
  {
    result += a2;
    *(_QWORD *)(a1 + 144) -= a2;
    *(_QWORD *)(a1 + 136) = result;
    if ( v2 == result )
    {
      v4 = *(_QWORD *)(a1 + 120) <= 0x8000LL;
      *(_QWORD *)(a1 + 136) = 0LL;
      *(_QWORD *)(a1 + 128) = 0LL;
      if ( !v4 )
      {
        result = (char *)realloc(*(void **)(a1 + 112), 0x8000uLL);
        *(_QWORD *)(a1 + 120) = 0x8000LL;
        *(_QWORD *)(a1 + 112) = result;
      }
    }
  }
  return result;
}

//----- (000000000002AD80) ----------------------------------------------------
__int64 __fastcall fs_pad_length(__int64 a1)
{
  return a1 + dword_34040[a1 & 3];
}

//----- (000000000002ADA0) ----------------------------------------------------
signed __int64 __fastcall fs_flush(__int64 a1)
{
  __int64 v1; // rsi
  __int64 i; // rbx
  __int64 v3; // rcx
  __int64 v4; // rdi
  int v5; // eax
  __int64 v6; // rdx
  signed __int64 result; // rax
  int v8; // eax

  if ( *(_DWORD *)(a1 + 8) < 0 )
    return 0xFFFFFFFFLL;
  v1 = *(_QWORD *)(a1 + 104);
  for ( i = a1; ; v1 = *(_QWORD *)(i + 104) )
  {
    v3 = *(_QWORD *)(i + 96);
    if ( *(_QWORD *)(i + 96) - v1 <= 0 )
    {
LABEL_6:
      result = 1LL;
      if ( v1 != v3 )
        return result;
      goto LABEL_13;
    }
    while ( 1 )
    {
      v4 = *(_QWORD *)(i + 184);
      v5 = _FontTransWrite(v4, *(_QWORD *)(i + 80) + v1);
      if ( v5 <= 0LL )
        break;
      v1 = *(_QWORD *)(i + 104) + v5;
      v3 = *(_QWORD *)(i + 96);
      v6 = *(_QWORD *)(i + 96) - v1;
      *(_QWORD *)(i + 104) = v1;
      if ( v6 <= 0 )
        goto LABEL_6;
    }
    if ( !v5 )
      break;
    v8 = *__errno_location();
    if ( v8 == 11 )
      break;
    if ( v8 != 4 )
    {
      _fs_connection_died(i);
      return 0xFFFFFFFFLL;
    }
  }
  *(_DWORD *)(i + 160) = (unsigned __int64)GetTimeInMillis(v4) + 1000;
  _fs_mark_block(i, 2LL);
  result = 1LL;
  if ( *(_QWORD *)(i + 104) != *(_QWORD *)(i + 96) )
    return result;
LABEL_13:
  _fs_unmark_block(i, 3LL);
  if ( *(_QWORD *)(i + 88) > 1024LL )
    *(_QWORD *)(i + 80) = realloc(*(void **)(i + 80), 0x400uLL);
  *(_QWORD *)(i + 96) = 0LL;
  *(_QWORD *)(i + 104) = 0LL;
  return 1LL;
}
// 8100: using guessed type __int64 __fastcall _fs_connection_died(_QWORD);
// 8140: using guessed type __int64 __fastcall _FontTransWrite(_QWORD, _QWORD);
// 8800: using guessed type __int64 __fastcall _fs_unmark_block(_QWORD, _QWORD);
// 8B30: using guessed type __int64 __fastcall GetTimeInMillis(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (000000000002AF80) ----------------------------------------------------
void __fastcall fs_io_reinit(__int64 a1)
{
  bool v1; // cc
  void *v2; // rax
  void *v3; // rax

  v1 = *(_QWORD *)(a1 + 88) <= 1024LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  if ( !v1 )
  {
    v3 = realloc(*(void **)(a1 + 80), 0x400uLL);
    *(_QWORD *)(a1 + 88) = 1024LL;
    *(_QWORD *)(a1 + 80) = v3;
  }
  v1 = *(_QWORD *)(a1 + 120) > 0x8000LL;
  *(_QWORD *)(a1 + 136) = 0LL;
  *(_QWORD *)(a1 + 128) = 0LL;
  if ( v1 )
  {
    v2 = realloc(*(void **)(a1 + 112), 0x8000uLL);
    *(_QWORD *)(a1 + 120) = 0x8000LL;
    *(_QWORD *)(a1 + 112) = v2;
  }
}

//----- (000000000002B000) ----------------------------------------------------
__int64 __fastcall fs_io_init(_QWORD *a1)
{
  unsigned int v1; // er12
  void *v2; // rax
  void *v3; // rbp
  void *v4; // rax

  v1 = 0;
  a1[13] = 0LL;
  a1[12] = 0LL;
  v2 = malloc(0x400uLL);
  a1[10] = v2;
  if ( v2 )
  {
    a1[11] = 1024LL;
    a1[17] = 0LL;
    a1[16] = 0LL;
    v3 = v2;
    v4 = malloc(0x400uLL);
    a1[14] = v4;
    if ( v4 )
    {
      a1[15] = 1024LL;
      v1 = 1;
    }
    else
    {
      free(v3);
      a1[10] = 0LL;
    }
  }
  return v1;
}

//----- (000000000002B0A0) ----------------------------------------------------
void __fastcall fs_io_fini(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdi
  void *v3; // rdi

  v1 = a1;
  v2 = *(void **)(a1 + 80);
  if ( v2 )
    free(v2);
  v3 = *(void **)(v1 + 112);
  if ( v3 )
    free(v3);
}

//----- (000000000002B0D0) ----------------------------------------------------
signed __int64 __fastcall fs_write(__int64 a1, const void *a2, size_t a3)
{
  _QWORD *v3; // r14
  size_t v4; // r12
  __int64 v5; // rbp
  _QWORD *v6; // rbx
  __int64 v7; // rdi
  signed __int64 result; // rax

  if ( !a3 )
    return 1LL;
  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result != -1 )
  {
    v3 = (_QWORD *)(a1 + 80);
    v4 = a3;
    v5 = a3;
    v6 = (_QWORD *)a1;
    do
    {
      v7 = v6[12];
      if ( v5 + v7 <= v6[11] )
      {
        memcpy((void *)(v6[10] + v7), a2, v4);
        memset((void *)(v6[10] + v4 + v6[12]), 0, v5 - v4);
        v6[12] += v5;
        _fs_mark_block(v6, 1LL);
        return 1LL;
      }
      if ( (signed int)_fs_flush(v6) < 0 )
        return 0xFFFFFFFFLL;
    }
    while ( (signed int)sub_2AAE0(v3, v5) >= 0 );
    _fs_connection_died(v6);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8100: using guessed type __int64 __fastcall _fs_connection_died(_QWORD);
// 8890: using guessed type __int64 __fastcall _fs_flush(_QWORD);
// 8BD0: using guessed type __int64 __fastcall _fs_mark_block(_QWORD, _QWORD);

//----- (000000000002B0F0) ----------------------------------------------------
signed __int64 __fastcall fs_write_pad(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax

  if ( !(a3 + dword_34040[a3 & 3]) )
    return 1LL;
  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result != -1 )
    JUMPOUT(&loc_2AEFB);
  return result;
}

//----- (000000000002B120) ----------------------------------------------------
int __fastcall fs_wait_for_readable(__int64 a1, int a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rax
  int result; // eax
  int v8; // eax
  __int64 v9; // [rsp+10h] [rbp-158h]
  __int64 v10; // [rsp+18h] [rbp-150h]
  fd_set readfds; // [rsp+20h] [rbp-148h]
  fd_set exceptfds; // [rsp+A0h] [rbp-C8h]
  unsigned __int64 v13; // [rsp+128h] [rbp-40h]

  v2 = a1;
  v13 = __readfsqword(0x28u);
  while ( 1 )
  {
    if ( *(_DWORD *)(v2 + 8) < 0 )
      return -1;
    memset(&readfds, 0, sizeof(readfds));
    memset(&exceptfds, 0, sizeof(exceptfds));
    v3 = *(signed int *)(v2 + 8);
    v9 = a2 / 1000;
    v10 = 1000 * (a2 % 1000);
    v4 = __fdelt_chk(v3);
    v5 = *(signed int *)(v2 + 8);
    readfds.fds_bits[v4] |= 1LL << *(_DWORD *)(v2 + 8) % 64;
    v6 = __fdelt_chk(v5);
    LODWORD(v5) = *(_DWORD *)(v2 + 8);
    exceptfds.fds_bits[v6] |= 1LL << (char)*(_DWORD *)(v2 + 8) % 64;
    result = select(v5 + 1, &readfds, 0LL, &exceptfds, (struct timeval *)&v9);
    if ( result >= 0 )
      break;
    v8 = *__errno_location();
    if ( v8 != 4 && v8 != 11 )
      return -1;
  }
  if ( result )
  {
    if ( !((1LL << (char)*(_DWORD *)(v2 + 8) % 64) & readfds.fds_bits[__fdelt_chk(*(signed int *)(v2 + 8))]) )
      return -1;
    result = 1;
  }
  return result;
}
// 8520: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);

//----- (000000000002B2B0) ----------------------------------------------------
signed __int64 __fastcall fs_start_read(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // r13
  __int64 v4; // rax
  signed __int64 result; // rax
  __int64 v6; // rax
  signed int v7; // er12
  __int64 v8; // rcx
  __int64 v9; // r14
  int *v10; // rax
  int *v11; // r15
  __int64 v12; // rax
  int v13; // eax

  v3 = a3;
  v4 = a1[16] - a1[17];
  a1[18] = a2;
  if ( v4 >= a2 )
    goto LABEL_2;
  if ( (unsigned int)sub_2AAE0(a1 + 14, a2) != 1 )
  {
LABEL_22:
    _fs_connection_died(a1);
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)_fs_flush(a1) < 0 )
    return 0xFFFFFFFFLL;
  v6 = a1[16];
  v7 = 0;
  while ( 1 )
  {
    v8 = v6 - a1[17];
    if ( a1[18] - v8 <= 0 )
      break;
    v9 = a1[15] - v6;
    v10 = __errno_location();
    *v10 = 0;
    v11 = v10;
    v12 = (signed int)_FontTransRead(a1[23], a1[14] + a1[16], (unsigned int)v9);
    if ( (signed int)v12 <= 0LL )
    {
      if ( (_DWORD)v12 )
      {
        v13 = *v11;
        if ( *v11 != 11 )
          goto LABEL_13;
        if ( v7 )
          goto LABEL_22;
LABEL_18:
        if ( !(unsigned int)_fs_wait_for_readable(a1, 0LL) )
          return 0LL;
        v6 = a1[16];
        v7 = 1;
      }
      else
      {
        if ( !v7 )
          goto LABEL_18;
        v13 = *v11;
LABEL_13:
        if ( v13 != 4 )
          goto LABEL_22;
        v6 = a1[16];
      }
    }
    else
    {
      v6 = a1[16] + v12;
      v7 = 0;
      a1[16] = v6;
    }
  }
  if ( a2 > v8 )
    return 0LL;
LABEL_2:
  result = 1LL;
  if ( v3 )
    *v3 = a1[14] + a1[17];
  return result;
}
// 8100: using guessed type __int64 __fastcall _fs_connection_died(_QWORD);
// 8280: using guessed type __int64 __fastcall _fs_wait_for_readable(_QWORD, _QWORD);
// 8890: using guessed type __int64 __fastcall _fs_flush(_QWORD);
// 8CA0: using guessed type __int64 __fastcall _FontTransRead(_QWORD, _QWORD, _QWORD);

//----- (000000000002B450) ----------------------------------------------------
unsigned __int64 sub_2B450(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v3; // [rsp+18h] [rbp-C0h]

  va_start(va, a1);
  v3 = __readfsqword(0x28u);
  __vfprintf_chk(stderr, 1LL, "%s", va);
  fflush(stderr);
  return __readfsqword(0x28u) ^ v3;
}
// 8090: using guessed type __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002B530) ----------------------------------------------------
unsigned __int64 sub_2B530(int a1, __int64 a2, ...)
{
  int *v3; // rax
  int v4; // er13
  int *v5; // rbp
  gcc_va_list va; // [rsp+0h] [rbp-F8h]
  unsigned __int64 v7; // [rsp+18h] [rbp-E0h]

  va_start(va, a2);
  v7 = __readfsqword(0x28u);
  if ( a1 == 1 )
  {
    v3 = __errno_location();
    v4 = *v3;
    v5 = v3;
    sub_2B450((__int64)"%s", "_FontTrans");
    __vfprintf_chk(stderr, 1LL, a2, va);
    fflush(stderr);
    *v5 = v4;
  }
  return __readfsqword(0x28u) ^ v7;
}
// 8090: using guessed type __int64 __fastcall __vfprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002B640) ----------------------------------------------------
int __fastcall sub_2B640(__int64 a1)
{
  sub_2B530(2, (__int64)"SocketINETClose(%p,%d)\n", a1, *(unsigned int *)(a1 + 28));
  return close(*(_DWORD *)(a1 + 28));
}

//----- (000000000002B670) ----------------------------------------------------
ssize_t __fastcall sub_2B670(__int64 a1, void *a2, unsigned int a3)
{
  unsigned int v3; // ebx

  v3 = a3;
  sub_2B530(2, (__int64)"SocketRead(%d,%p,%d)\n", *(unsigned int *)(a1 + 28), a2, a3);
  return read(*(_DWORD *)(a1 + 28), a2, (signed int)v3);
}

//----- (000000000002B6B0) ----------------------------------------------------
signed __int64 __fastcall sub_2B6B0(__int64 a1, unsigned int a2, unsigned int a3)
{
  sub_2B530(2, (__int64)"SocketSetOption(%d,%d,%d)\n", *(unsigned int *)(a1 + 28), a2, a3);
  return 0xFFFFFFFFLL;
}

//----- (000000000002B6E0) ----------------------------------------------------
int __fastcall sub_2B6E0(__int64 a1)
{
  sub_2B530(2, (__int64)"SocketUNIXCloseForCloning(%p,%d)\n", a1, *(unsigned int *)(a1 + 28));
  return close(*(_DWORD *)(a1 + 28));
}

//----- (000000000002B710) ----------------------------------------------------
int __fastcall sub_2B710(__int64 a1)
{
  sub_2B530(2, (__int64)"SocketDisconnect(%p,%d)\n", a1, *(unsigned int *)(a1 + 28));
  return shutdown(*(_DWORD *)(a1 + 28), 2);
}

//----- (000000000002B740) ----------------------------------------------------
ssize_t __fastcall sub_2B740(__int64 a1, const struct iovec *a2, unsigned int a3)
{
  int v3; // ebp

  v3 = a3;
  sub_2B530(2, (__int64)"SocketWritev(%d,%p,%d)\n", *(unsigned int *)(a1 + 28), a2, a3);
  return writev(*(_DWORD *)(a1 + 28), a2, v3);
}

//----- (000000000002B780) ----------------------------------------------------
ssize_t __fastcall sub_2B780(__int64 a1, const struct iovec *a2, unsigned int a3)
{
  int v3; // ebp

  v3 = a3;
  sub_2B530(2, (__int64)"SocketReadv(%d,%p,%d)\n", *(unsigned int *)(a1 + 28), a2, a3);
  return readv(*(_DWORD *)(a1 + 28), a2, v3);
}

//----- (000000000002B7C0) ----------------------------------------------------
ssize_t __fastcall sub_2B7C0(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // ebx

  v3 = a3;
  sub_2B530(2, (__int64)"SocketWrite(%d,%p,%d)\n", *(unsigned int *)(a1 + 28), a2, a3);
  return write(*(_DWORD *)(a1 + 28), a2, (signed int)v3);
}

//----- (000000000002B800) ----------------------------------------------------
int __fastcall sub_2B800(__int64 a1, __int64 a2)
{
  sub_2B530(2, (__int64)"SocketBytesReadable(%p,%d,%p)\n", a1, *(unsigned int *)(a1 + 28), a2);
  return ioctl(*(_DWORD *)(a1 + 28), 0x541BuLL, a2);
}

//----- (000000000002B840) ----------------------------------------------------
__int64 __fastcall sub_2B840(int a1, const char *a2)
{
  unsigned int v2; // ebx
  const char **v3; // rbp

  v2 = a1 + 1;
  sub_2B530(3, (__int64)"SocketSelectFamily(%s)\n", a2);
  if ( (unsigned int)(a1 + 1) > 5 )
    return (unsigned int)(a1 != -1) - 2;
  v3 = (const char **)&off_23AB40[3 * (signed int)v2];
  while ( strcmp(a2, *v3) )
  {
    ++v2;
    v3 += 3;
    if ( v2 == 6 )
      return (unsigned int)(a1 != -1) - 2;
  }
  return v2;
}

//----- (000000000002B8E0) ----------------------------------------------------
_DWORD *__fastcall sub_2B8E0(unsigned int a1, unsigned int a2)
{
  _DWORD *v2; // r12
  char **v3; // rax
  int v4; // er13
  int v5; // eax
  int v7; // edi
  int v8; // edi
  int v9; // edi
  void *v10; // rdi
  int v11; // [rsp+0h] [rbp-38h]
  int optval; // [rsp+4h] [rbp-34h]
  unsigned __int64 v13; // [rsp+8h] [rbp-30h]

  v13 = __readfsqword(0x28u);
  sub_2B530(3, (__int64)"SocketOpen(%d,%d)\n", a1, a2);
  v2 = calloc(1uLL, 0x60uLL);
  if ( v2 )
  {
    v3 = &off_23AB40[3 * (signed int)a1];
    v4 = *((_DWORD *)v3 + 2);
    v5 = socket(*((_DWORD *)v3 + 2), a2, *((_DWORD *)v3 + 5));
    v2[7] = v5;
    if ( v5 < 0 || v5 >= sysconf(4) )
    {
      sub_2B530(2, (__int64)"SocketOpen: socket() failed for %s\n", off_23AB40[3 * (signed int)a1]);
      v10 = v2;
      v2 = 0LL;
      free(v10);
    }
    else if ( (v4 & 0xFFFFFFF7) == 2 )
    {
      v7 = v2[7];
      optval = 1;
      setsockopt(v7, 6, 1, &optval, 4u);
    }
    else if ( v4 == 1 )
    {
      v8 = v2[7];
      v11 = 4;
      if ( !getsockopt(v8, 1, 7, &optval, (socklen_t *)&v11) && optval <= 0xFFFF )
      {
        v9 = v2[7];
        optval = 0x10000;
        setsockopt(v9, 1, 7, &optval, 4u);
      }
    }
  }
  else
  {
    sub_2B530(1, (__int64)"SocketOpen: malloc failed\n");
  }
  return v2;
}

//----- (000000000002BAA0) ----------------------------------------------------
_DWORD *__fastcall sub_2BAA0(const char *a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  int v5; // ebx
  _DWORD *result; // rax
  signed int v7; // eax

  v5 = a5;
  sub_2B530(2, (__int64)"SocketOpenCOTSClient(%s,%s,%s)\n", a2, a3, a4);
  while ( 1 )
  {
    v7 = sub_2B840(v5, a1);
    v5 = v7;
    if ( v7 < 0 )
      break;
    result = sub_2B8E0(v7, HIDWORD(off_23AB40[3 * v7 + 1]));
    if ( result )
    {
      result[2] = v5;
      return result;
    }
  }
  if ( v7 == -1 )
    sub_2B530(1, (__int64)"SocketOpenCOTSClient: Unable to open socket for %s\n", a1);
  else
    sub_2B530(1, (__int64)"SocketOpenCOTSClient: Unable to determine socket type for %s\n", a1);
  return 0LL;
}

//----- (000000000002BB50) ----------------------------------------------------
_DWORD *__fastcall sub_2BB50(const char **a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_2BAA0(*a1, a2, a3, a4, -1);
}

//----- (000000000002BB60) ----------------------------------------------------
_DWORD *__fastcall sub_2BB60(const char **a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // ebx
  _DWORD *result; // rax
  signed int v6; // eax
  const char *v7; // rdx

  v4 = -1;
  sub_2B530(2, (__int64)"SocketOpenCLTSClient(%s,%s,%s)\n", a2, a3, a4);
  while ( 1 )
  {
    v6 = sub_2B840(v4, *a1);
    v4 = v6;
    if ( v6 < 0 )
      break;
    result = sub_2B8E0(v6, HIDWORD(off_23AB40[3 * v6 + 1]));
    if ( result )
    {
      result[2] = v4;
      return result;
    }
  }
  v7 = *a1;
  if ( v6 == -1 )
    sub_2B530(1, (__int64)"SocketOpenCLTSClient: Unable to open socket for %s\n", v7);
  else
    sub_2B530(1, (__int64)"SocketOpenCLTSClient: Unable to determine socket type for %s\n", v7);
  return 0LL;
}

//----- (000000000002BC10) ----------------------------------------------------
__int64 __fastcall sub_2BC10(__int64 a1)
{
  __int64 v1; // rbp
  unsigned int v2; // er12
  int v3; // eax

  v1 = *(_QWORD *)(a1 + 48);
  sub_2B530(2, (__int64)"SocketUNIXClose(%p,%d)\n", a1, *(unsigned int *)(a1 + 28));
  v2 = close(*(_DWORD *)(a1 + 28));
  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 && v1 && *(_WORD *)v1 == 1 && *(_BYTE *)(v1 + 2) && !(v3 & 0x10) && !(*(_BYTE *)(*(_QWORD *)a1 + 8LL) & 0x20) )
    unlink((const char *)(v1 + 2));
  return v2;
}

//----- (000000000002BC80) ----------------------------------------------------
void __fastcall FontTransFreeConnInfo(void *ptr)
{
  _QWORD *v1; // rbx
  void *v2; // rdi
  void *v3; // rdi
  void *v4; // rdi

  v1 = ptr;
  sub_2B530(3, (__int64)"FreeConnInfo(%p)\n", ptr);
  v2 = (void *)*((_QWORD *)ptr + 6);
  if ( v2 )
    free(v2);
  v3 = (void *)v1[8];
  if ( v3 )
    free(v3);
  v4 = (void *)v1[4];
  if ( v4 )
    free(v4);
  free(v1);
}

//----- (000000000002BCD0) ----------------------------------------------------
unsigned int __fastcall FontTransSetOption(__int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebp
  unsigned int v4; // er12
  signed __int64 v5; // rdx
  int v6; // esi
  unsigned int result; // eax

  v3 = *(_DWORD *)(a1 + 28);
  v4 = a3;
  sub_2B530(2, (__int64)"SetOption(%d,%d,%d)\n", v3, a2, a3);
  if ( a2 != 1 )
  {
    if ( a2 == 2 )
    {
      v5 = 1LL;
      v6 = 2;
      return fcntl(v3, v6, v5);
    }
    return 0;
  }
  if ( v4 != 1 )
    return 0;
  result = fcntl(v3, 3, 0LL);
  if ( result != -1 )
  {
    BYTE1(result) |= 8u;
    v6 = 4;
    v5 = result;
    return fcntl(v3, v6, v5);
  }
  return result;
}

//----- (000000000002BD60) ----------------------------------------------------
__int64 __fastcall FontTransBytesReadable(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48LL))(a1);
}

//----- (000000000002BD70) ----------------------------------------------------
__int64 __fastcall FontTransRead(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 56LL))(a1);
}

//----- (000000000002BD80) ----------------------------------------------------
__int64 __fastcall FontTransWrite(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64LL))(a1);
}

//----- (000000000002BD90) ----------------------------------------------------
__int64 __fastcall FontTransReadv(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72LL))(a1);
}

//----- (000000000002BDA0) ----------------------------------------------------
__int64 __fastcall FontTransWritev(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 80LL))(a1);
}

//----- (000000000002BDB0) ----------------------------------------------------
__int64 __fastcall FontTransDisconnect(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 88LL))(a1);
}

//----- (000000000002BDC0) ----------------------------------------------------
__int64 __fastcall FontTransClose(void *ptr)
{
  unsigned int v1; // ebp

  sub_2B530(2, (__int64)"Close(%d)\n", *((unsigned int *)ptr + 7));
  v1 = (*(__int64 (__fastcall **)(void *))(*(_QWORD *)ptr + 96LL))(ptr);
  _FontTransFreeConnInfo(ptr);
  return v1;
}

//----- (000000000002BE00) ----------------------------------------------------
__int64 __fastcall FontTransCloseForCloning(void *ptr)
{
  unsigned int v1; // ebp

  sub_2B530(2, (__int64)"CloseForCloning(%d)\n", *((unsigned int *)ptr + 7));
  v1 = (*(__int64 (__fastcall **)(void *))(*(_QWORD *)ptr + 104LL))(ptr);
  _FontTransFreeConnInfo(ptr);
  return v1;
}

//----- (000000000002BE40) ----------------------------------------------------
_BOOL8 __fastcall FontTransIsLocal(__int64 a1)
{
  return *(_DWORD *)(a1 + 40) == 1;
}

//----- (000000000002BE50) ----------------------------------------------------
signed __int64 __fastcall FontTransGetMyAddr(__int64 a1, _DWORD *a2, _DWORD *a3, _QWORD *a4)
{
  _DWORD *v4; // r12
  _QWORD *v5; // rbp
  void *v6; // rax
  signed __int64 result; // rax

  v4 = a3;
  v5 = a4;
  sub_2B530(2, (__int64)"GetMyAddr(%d)\n", *(unsigned int *)(a1 + 28));
  *a2 = *(_DWORD *)(a1 + 40);
  *v4 = *(_DWORD *)(a1 + 56);
  v6 = malloc(*(signed int *)(a1 + 56));
  *v5 = v6;
  if ( v6 )
  {
    memcpy(v6, *(const void **)(a1 + 48), *(signed int *)(a1 + 56));
    result = 0LL;
  }
  else
  {
    sub_2B530(1, (__int64)"GetMyAddr: malloc failed\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000002BEE0) ----------------------------------------------------
signed __int64 __fastcall FontTransGetPeerAddr(__int64 a1, _DWORD *a2, _DWORD *a3, _QWORD *a4)
{
  _DWORD *v4; // r12
  _QWORD *v5; // rbp
  void *v6; // rax
  signed __int64 result; // rax

  v4 = a3;
  v5 = a4;
  sub_2B530(2, (__int64)"GetPeerAddr(%d)\n", *(unsigned int *)(a1 + 28));
  *a2 = *(_DWORD *)(a1 + 40);
  *v4 = *(_DWORD *)(a1 + 72);
  v6 = malloc(*(signed int *)(a1 + 72));
  *v5 = v6;
  if ( v6 )
  {
    memcpy(v6, *(const void **)(a1 + 64), *(signed int *)(a1 + 72));
    result = 0LL;
  }
  else
  {
    sub_2B530(1, (__int64)"GetPeerAddr: malloc failed\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000002BF70) ----------------------------------------------------
__int64 __fastcall FontTransGetConnectionNumber(__int64 a1)
{
  return *(unsigned int *)(a1 + 28);
}

//----- (000000000002BF80) ----------------------------------------------------
__int64 __fastcall FontTransGetHostname(char *dest, int a2)
{
  int v2; // ebx
  int v3; // eax
  __int64 _0; // [rsp+0h] [rbp+0h]
  unsigned __int64 vars188; // [rsp+188h] [rbp+188h]

  v2 = a2 - 1;
  vars188 = __readfsqword(0x28u);
  uname((struct utsname *)&_0);
  v3 = strlen((const char *)&_0);
  if ( a2 > v3 )
    v2 = v3;
  strncpy(dest, (const char *)&_0, v2);
  dest[v2] = 0;
  return (unsigned int)v2;
}

//----- (000000000002C010) ----------------------------------------------------
signed __int64 __fastcall sub_2C010(__int64 a1, char *a2, char *a3)
{
  char *v3; // r8
  char *v4; // r12
  __int64 v5; // rbx
  __int64 v6; // rdx
  __int64 v7; // rcx
  char *v8; // rbp
  int v9; // eax
  char *v10; // rcx
  char *v11; // r13
  struct addrinfo *v12; // r14
  int v13; // eax
  __int64 v14; // rax
  signed int v15; // ebp
  int v16; // edx
  __int64 v17; // r15
  socklen_t v18; // er14
  const char *v19; // rax
  char **v20; // rax
  bool v21; // cf
  bool v22; // zf
  int v23; // edi
  int *v24; // rax
  _QWORD *v25; // rcx
  int v26; // edx
  __int64 v27; // rsi
  unsigned __int64 v28; // rax
  signed __int64 result; // rax
  char *v30; // ST08_8
  char *v31; // ST08_8
  __int64 v32; // rax
  unsigned int v33; // eax
  _QWORD *v34; // rdx
  __int64 v35; // rcx
  const char *v36; // rax
  char **v37; // rax
  bool v38; // cf
  bool v39; // zf
  char *v40; // rsi
  const char *v41; // rdi
  signed __int64 v42; // rcx
  _DWORD *v43; // rax
  void *v44; // rdx
  const char *v45; // rsi
  char *v46; // rsi
  const char *v47; // rdi
  signed __int64 v48; // rcx
  _DWORD *v49; // rax
  struct sockaddr *v50; // rbp
  int v51; // edi
  int v52; // er13
  void *v53; // rax
  int v54; // er14
  unsigned __int64 v55; // rcx
  int v56; // er12
  void *v57; // rax
  signed __int64 v58; // rdi
  const char *v59; // rsi
  const char *v60; // rax
  int *v61; // rax
  const char *v62; // rsi
  int *v63; // rax
  char *buf; // [rsp+8h] [rbp-260h]
  char *s1; // [rsp+10h] [rbp-258h]
  void *ptr; // [rsp+18h] [rbp-250h]
  unsigned int optval; // [rsp+2Ch] [rbp-23Ch]
  struct addrinfo req; // [rsp+30h] [rbp-238h]
  struct sockaddr src; // [rsp+60h] [rbp-208h]
  struct sockaddr addr; // [rsp+70h] [rbp-1F8h]
  char v71; // [rsp+F0h] [rbp-178h]
  char dest; // [rsp+120h] [rbp-148h]
  unsigned __int64 v73; // [rsp+228h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  s1 = a3;
  v6 = *(unsigned int *)(a1 + 28);
  v73 = __readfsqword(0x28u);
  sub_2B530(2, (__int64)"SocketINETConnect(%d,%s,%s)\n", v6, a2, v3);
  if ( !a2 )
  {
    v4 = &dest;
    dest = 0;
    _FontTransGetHostname(&dest);
    v7 = qword_23CD28;
    if ( qword_23CD28 )
      goto LABEL_3;
LABEL_68:
    v10 = (char *)malloc(0x70uLL);
    qword_23CD28 = (__int64)v10;
    *((_QWORD *)v10 + 1) = 0LL;
    v8 = v10 + 48;
    v11 = v10 + 16;
    goto LABEL_26;
  }
  v7 = qword_23CD28;
  if ( !qword_23CD28 )
    goto LABEL_68;
LABEL_3:
  v8 = (char *)(v7 + 48);
  buf = (char *)v7;
  v9 = strcmp(v4, (const char *)(v7 + 48));
  v10 = buf;
  v11 = buf + 16;
  v12 = (struct addrinfo *)*((_QWORD *)buf + 1);
  if ( v9 || (v13 = strcmp(s1, buf + 16), v10 = buf, v13) )
  {
    if ( v12 )
    {
      v30 = v10;
      freeaddrinfo(v12);
      v10 = v30;
    }
    *((_QWORD *)v10 + 1) = 0LL;
    goto LABEL_26;
  }
  if ( !v12 )
  {
LABEL_26:
    v31 = v10;
    strncpy(v11, s1, 0x20uLL);
    v31[47] = 0;
    strncpy(v8, v4, 0x40uLL);
    v31[111] = 0;
    v32 = *(signed int *)(a1 + 8);
    *(_OWORD *)&req.ai_flags = 0LL;
    *(_OWORD *)&req.ai_addrlen = 0LL;
    *(_OWORD *)&req.ai_canonname = 0LL;
    req.ai_socktype = HIDWORD(off_23AB40[3 * v32 + 1]);
    v33 = getaddrinfo(v4, s1, &req, (struct addrinfo **)v31 + 1);
    if ( v33 )
    {
      v60 = gai_strerror(v33);
      sub_2B530(1, (__int64)"SocketINETConnect() can't get address for %s:%s: %s\n", v4, s1, v60);
      *__errno_location() = 22;
      return 0xFFFFFFFFLL;
    }
    v34 = (_QWORD *)qword_23CD28;
    v35 = *(_QWORD *)(qword_23CD28 + 8);
    for ( *(_QWORD *)qword_23CD28 = v35; v35; *v34 = v35 )
    {
      v35 = *(_QWORD *)(v35 + 40);
      ++v33;
    }
    sub_2B530(4, (__int64)"Got New Address list with %d addresses\n", v33);
    v10 = (char *)qword_23CD28;
    v14 = 0LL;
    *(_QWORD *)qword_23CD28 = 0LL;
    goto LABEL_7;
  }
  v14 = *(_QWORD *)buf;
LABEL_7:
  v15 = 0;
LABEL_8:
  if ( v14 )
  {
LABEL_9:
    v16 = *(_DWORD *)(v14 + 4);
    v17 = *(_QWORD *)(v14 + 24);
    v18 = *(_DWORD *)(v14 + 16);
    if ( v16 != 2 )
      goto LABEL_10;
  }
  else
  {
    while ( 1 )
    {
      if ( v15 )
      {
        sub_2B530(1, (__int64)"SocketINETConnect() no usable address for %s:%s\n", v4, s1);
        return 0xFFFFFFFFLL;
      }
      v14 = *((_QWORD *)v10 + 1);
      v15 = 1;
      *(_QWORD *)v10 = v14;
      v16 = *(_DWORD *)(v14 + 4);
      v17 = *(_QWORD *)(v14 + 24);
      v18 = *(_DWORD *)(v14 + 16);
      if ( v16 == 2 )
        break;
LABEL_10:
      if ( v16 == 10 )
      {
        v36 = inet_ntop(10, (const void *)(v17 + 8), &v71, 0x2Eu);
        sub_2B530(4, (__int64)"SocketINETConnect() sockname.sin6_addr = %s\n", v36);
        sub_2B530(
          4,
          (__int64)"SocketINETConnect() sockname.sin6_port = %d\n",
          (unsigned __int16)__ROR2__(*(_WORD *)(v17 + 2), 8));
        v37 = &off_23AB40[3 * *(signed int *)(v5 + 8)];
        v38 = *((_DWORD *)v37 + 2) < 2u;
        v39 = *((_DWORD *)v37 + 2) == 2;
        if ( *((_DWORD *)v37 + 2) != 2 )
        {
LABEL_15:
          if ( v17 )
            goto LABEL_16;
          v10 = (char *)qword_23CD28;
          v14 = *(_QWORD *)qword_23CD28;
          goto LABEL_8;
        }
        v40 = *v37;
        v41 = "tcp";
        v42 = 4LL;
        do
        {
          if ( !v42 )
            break;
          v38 = (unsigned __int8)*v40 < *v41;
          v39 = *v40++ == *v41++;
          --v42;
        }
        while ( v39 );
        if ( (!v38 && !v39) != v38 )
        {
          v59 = "SocketINETConnect() Skipping IPv6 address\n";
          goto LABEL_59;
        }
        sub_2B640(v5);
        v43 = sub_2BAA0("tcp", (__int64)"tcp", (__int64)v4, (__int64)s1, -1);
        v44 = v43;
        if ( v43 )
        {
          *(_DWORD *)(v5 + 28) = v43[7];
          if ( LODWORD(off_23AB40[3 * v43[2] + 1]) == 10 )
            goto LABEL_63;
          ptr = v43;
          v45 = "SocketINETConnect() Cannot get IPv6 socket for IPv6 address\n";
          goto LABEL_46;
        }
        sub_2B530(4, (__int64)"SocketINETConnect() Cannot get IPv6 socket for IPv6 address\n", 0LL);
LABEL_60:
        v10 = (char *)qword_23CD28;
        v14 = *(_QWORD *)qword_23CD28;
      }
      v14 = *(_QWORD *)(v14 + 40);
      *(_QWORD *)v10 = v14;
      if ( v14 )
        goto LABEL_9;
    }
  }
  v19 = inet_ntop(2, (const void *)(v17 + 4), &v71, 0x2Eu);
  sub_2B530(4, (__int64)"SocketINETConnect() sockname.sin_addr = %s\n", v19);
  sub_2B530(
    4,
    (__int64)"SocketINETConnect() sockname.sin_port = %d\n",
    (unsigned __int16)__ROR2__(*(_WORD *)(v17 + 2), 8));
  v20 = &off_23AB40[3 * *(signed int *)(v5 + 8)];
  v21 = *((_DWORD *)v20 + 2) < 0xAu;
  v22 = *((_DWORD *)v20 + 2) == 10;
  if ( *((_DWORD *)v20 + 2) != 10 )
    goto LABEL_15;
  v46 = *v20;
  v47 = "tcp";
  v48 = 4LL;
  do
  {
    if ( !v48 )
      break;
    v21 = (unsigned __int8)*v46 < *v47;
    v22 = *v46++ == *v47++;
    --v48;
  }
  while ( v22 );
  if ( (!v21 && !v22) != v21 )
  {
    v59 = "SocketINETConnect Skipping IPv4 address\n";
LABEL_59:
    sub_2B530(4, (__int64)v59);
    goto LABEL_60;
  }
  sub_2B640(v5);
  v49 = sub_2BAA0("tcp", (__int64)"tcp", (__int64)v4, (__int64)s1, *(_DWORD *)(v5 + 8));
  v44 = v49;
  if ( !v49 )
  {
    sub_2B530(4, (__int64)"SocketINETConnect() Cannot get IPv4  socketfor IPv4 address\n", 0LL);
    goto LABEL_60;
  }
  *(_DWORD *)(v5 + 28) = v49[7];
  if ( LODWORD(off_23AB40[3 * v49[2] + 1]) != 2 )
  {
    v45 = "SocketINETConnect() Cannot get IPv4  socketfor IPv4 address\n";
    ptr = v49;
LABEL_46:
    sub_2B530(4, (__int64)v45);
    free(ptr);
    goto LABEL_60;
  }
LABEL_63:
  free(v44);
LABEL_16:
  v23 = *(_DWORD *)(v5 + 28);
  optval = 1;
  setsockopt(v23, 1, 9, &optval, 4u);
  if ( connect(*(_DWORD *)(v5 + 28), (const struct sockaddr *)v17, v18) >= 0 )
  {
    v50 = &addr;
    sub_2B530(3, (__int64)"SocketINETGetAddr(%p)\n", v5);
    memset(&addr, 0, 0x80uLL);
    v51 = *(_DWORD *)(v5 + 28);
    optval = 128;
    if ( getsockname(v51, &addr, &optval) < 0 )
    {
      v61 = __errno_location();
      sub_2B530(1, (__int64)"SocketINETGetAddr: getsockname() failed: %d\n", (unsigned int)*v61);
    }
    else
    {
      v52 = optval;
      v53 = malloc(optval);
      *(_QWORD *)(v5 + 48) = v53;
      if ( v53 )
      {
        v54 = addr.sa_family;
        *(_DWORD *)(v5 + 56) = v52;
        *(_DWORD *)(v5 + 40) = v54;
        memcpy(v53, &addr, v52);
        if ( v54 == 10 )
        {
          optval = 128;
          v55 = 128LL;
        }
        else
        {
          v50 = &src;
          optval = 16;
          v55 = 16LL;
        }
        memset(v50, 0, 8 * (v55 >> 3));
        sub_2B530(3, (__int64)"SocketINETGetPeerAddr(%p)\n", v5);
        if ( getpeername(*(_DWORD *)(v5 + 28), v50, &optval) < 0 )
        {
          v63 = __errno_location();
          sub_2B530(1, (__int64)"SocketINETGetPeerAddr: getpeername() failed: %d\n", (unsigned int)*v63);
        }
        else
        {
          v56 = optval;
          v57 = malloc(optval);
          *(_QWORD *)(v5 + 64) = v57;
          if ( v57 )
          {
            *(_DWORD *)(v5 + 72) = v56;
            memcpy(v57, v50, v56);
            return 0LL;
          }
          sub_2B530(1, (__int64)"SocketINETGetPeerAddr: Can't allocate space for the addr\n");
        }
        v62 = "SocketINETConnect: ...SocketINETGetPeerAddr() failed:\n";
LABEL_76:
        sub_2B530(1, (__int64)v62);
        v25 = (_QWORD *)qword_23CD28;
        v27 = *(_QWORD *)(*(_QWORD *)qword_23CD28 + 40LL);
        result = 0xFFFFFFFFLL;
        goto LABEL_57;
      }
      sub_2B530(1, (__int64)"SocketINETGetAddr: Can't allocate space for the addr\n");
    }
    v62 = "SocketINETConnect: ...SocketINETGetAddr() failed:\n";
    goto LABEL_76;
  }
  v24 = __errno_location();
  v25 = (_QWORD *)qword_23CD28;
  v26 = *v24;
  v27 = *(_QWORD *)(*(_QWORD *)qword_23CD28 + 40LL);
  if ( *v24 == 111 || v26 == 4 )
  {
LABEL_56:
    result = 4294967294LL;
    goto LABEL_57;
  }
  if ( v27 || *(_QWORD *)(qword_23CD28 + 8) != *(_QWORD *)qword_23CD28 )
  {
    v28 = (unsigned int)(v26 - 97);
    if ( (unsigned int)v28 <= 0xF )
    {
      v58 = 40981LL;
      if ( !_bittest64(&v58, v28) )
        goto LABEL_72;
      goto LABEL_56;
    }
  }
  if ( v26 == 11 || v26 == 115 )
  {
    result = 4294967293LL;
  }
  else
  {
LABEL_72:
    sub_2B530(2, (__int64)"SocketINETConnect: Can't connect: errno = %d\n");
    v25 = (_QWORD *)qword_23CD28;
    v27 = *(_QWORD *)(*(_QWORD *)qword_23CD28 + 40LL);
    result = 0xFFFFFFFFLL;
  }
LABEL_57:
  *v25 = v27;
  return result;
}
// 23CD28: using guessed type __int64 qword_23CD28;

//----- (000000000002C820) ----------------------------------------------------
signed __int64 __fastcall sub_2C820(unsigned int *a1, const char *a2, const char *a3)
{
  const char *v3; // r13
  const char *v4; // rbx
  unsigned int *v5; // rbp
  const char *v6; // r8
  __int64 v7; // rdx
  int v8; // er12
  int v9; // er12
  bool v10; // cf
  bool v11; // zf
  bool v12; // r14
  char v13; // al
  char *v14; // r14
  char *v15; // r15
  signed __int64 v16; // r13
  socklen_t v17; // ebx
  int v18; // edx
  signed __int64 result; // rax
  const char *v20; // rdi
  signed __int64 v21; // rcx
  void *v22; // r14
  void *v23; // r15
  int v24; // eax
  struct addrinfo *v25; // rdi
  struct addrinfo *v26; // rsi
  int v27; // ecx
  struct addrinfo *v28; // rax
  _BOOL4 v29; // er15
  bool v30; // dl
  bool v31; // al
  int v32; // edx
  int v33; // er9
  struct addrinfo *pai; // [rsp+10h] [rbp-1C8h]
  struct addrinfo *ai; // [rsp+18h] [rbp-1C0h]
  struct sockaddr addr; // [rsp+20h] [rbp-1B8h]
  char s1; // [rsp+90h] [rbp-148h]
  unsigned __int64 v38; // [rsp+198h] [rbp-40h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = a3;
  v7 = a1[7];
  v38 = __readfsqword(0x28u);
  v8 = *(_DWORD *)(*(_QWORD *)a1 + 8LL);
  sub_2B530(2, (__int64)"SocketUNIXConnect(%d,%s,%s)\n", v7, a2, v6);
  v9 = v8 & 0x20;
  if ( !a2 )
    goto LABEL_3;
  v10 = 0;
  v11 = *a2 == 0 || *a2 == 47;
  v12 = *a2 != 0 && *a2 != 47;
  if ( !v12 )
    goto LABEL_3;
  v20 = "unix";
  v21 = 5LL;
  do
  {
    if ( !v21 )
      break;
    v10 = (const unsigned __int8)*a2 < *v20;
    v11 = *a2++ == *v20++;
    --v21;
  }
  while ( v11 );
  if ( (!v10 && !v11) == v10 )
    goto LABEL_3;
  _FontTransGetHostname(&s1);
  if ( !strcmp(&s1, v3) )
    goto LABEL_3;
  if ( getaddrinfo(&s1, 0LL, 0LL, &pai) )
  {
LABEL_29:
    sub_2B530(1, (__int64)"SocketUNIXConnect: Cannot connect to non-local host %s\n", v3);
    return 0xFFFFFFFFLL;
  }
  v24 = getaddrinfo(v3, 0LL, 0LL, &ai);
  v25 = pai;
  if ( v24 )
  {
LABEL_61:
    freeaddrinfo(v25);
    goto LABEL_29;
  }
  if ( !pai )
  {
    freeaddrinfo(0LL);
    v25 = ai;
    goto LABEL_61;
  }
  v26 = pai;
  do
  {
    if ( ai )
    {
      v27 = v26->ai_family;
      v28 = ai;
      do
      {
        v29 = 0;
        v30 = v12;
        if ( v27 == v28->ai_family )
        {
          if ( v27 == 2 )
          {
            v32 = *(_DWORD *)&v26->ai_addr->sa_data[2];
            v33 = *(_DWORD *)&v28->ai_addr->sa_data[2];
            v29 = v33 == v32;
            v30 = v33 != v32;
          }
          else if ( v27 == 10 )
          {
            v29 = *(_OWORD *)&v28->ai_addr->sa_data[6] == *(_OWORD *)&v26->ai_addr->sa_data[6];
            v30 = *(_OWORD *)&v28->ai_addr->sa_data[6] != *(_OWORD *)&v26->ai_addr->sa_data[6];
          }
        }
        v28 = v28->ai_next;
      }
      while ( v28 && v30 );
      v31 = !v29;
    }
    else
    {
      v31 = v12;
      v29 = 0;
    }
    v26 = v26->ai_next;
  }
  while ( v26 && v31 );
  freeaddrinfo(pai);
  freeaddrinfo(ai);
  if ( !v29 )
    goto LABEL_29;
LABEL_3:
  if ( v4 && (v13 = *v4) != 0 )
  {
    addr.sa_family = 1;
    if ( v13 == 64 )
    {
      v15 = "";
      v16 = 0LL;
      v14 = "";
    }
    else
    {
      v14 = "";
      v15 = "@";
      v16 = 0LL;
      if ( !v9 )
        v15 = "";
      if ( v13 != 47 )
      {
        v16 = 18LL;
        if ( v13 != 47 )
          v14 = "/tmp/.font-unix/fs";
      }
    }
    if ( strlen(v4) + v16 > 0x6B )
    {
      sub_2B530(1, (__int64)"SocketUNIXConnect: path too long\n");
      result = 0xFFFFFFFFLL;
    }
    else
    {
      __snprintf_chk(addr.sa_data, 108LL, 1LL, 108LL, "%s%s%s", v15, v14);
      v17 = strlen(addr.sa_data) + 2;
      if ( v9 )
        addr.sa_data[0] = 0;
      if ( connect(v5[7], &addr, v17) >= 0 )
      {
        v22 = malloc(v17);
        *((_QWORD *)v5 + 6) = v22;
        if ( v22 && (v23 = malloc(v17), (*((_QWORD *)v5 + 8) = v23) != 0LL) )
        {
          if ( v9 )
            addr.sa_data[0] = 64;
          v5[14] = v17;
          v5[18] = v17;
          v5[10] = 1;
          memcpy(v22, &addr, (signed int)v17);
          memcpy(v23, &addr, (signed int)v17);
          result = 0LL;
        }
        else
        {
          sub_2B530(1, (__int64)"SocketUNIXCreateListener: Can't allocate space for the addr\n");
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        v18 = *__errno_location();
        if ( v18 == 11 || v18 == 115 )
        {
          result = 4294967293LL;
        }
        else if ( v18 == 4 )
        {
          result = 4294967294LL;
        }
        else if ( v18 != 2 && v18 != 111 )
        {
          sub_2B530(2, (__int64)"SocketUNIXConnect: Can't connect: errno = %d\n");
          result = 0xFFFFFFFFLL;
        }
        else
        {
          result = 0xFFFFFFFFLL;
          if ( v9 )
          {
            *(_DWORD *)(*(_QWORD *)v5 + 8LL) &= 0xFFFFFFDF;
            result = 4294967294LL;
          }
        }
      }
    }
  }
  else
  {
    sub_2B530(1, (__int64)"SocketUNIXConnect: Missing port specification\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 8030: using guessed type __int64 __fastcall __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CCA0) ----------------------------------------------------
__int64 __fastcall sub_2CCA0(char *s, void **a2, void **a3, char **a4)
{
  void **v4; // r14
  void **v5; // r13
  char **v6; // r15
  char *v7; // rax
  char *v8; // rbx
  char *v9; // rax
  char *v10; // rbp
  const char *v11; // r12
  char *v12; // rax
  signed int v13; // eax
  bool v14; // cf
  bool v15; // zf
  char *v16; // rax
  char *v17; // rax
  char *v18; // rax
  char *v19; // rax
  __int64 result; // rax
  const char *v21; // rdi
  signed __int64 v22; // rcx
  const char *v23; // rsi
  char v24; // dl
  bool v25; // cf
  bool v26; // zf
  char *v27; // rcx
  const char *v28; // rdi
  signed __int64 v29; // rcx
  const char *v30; // rsi
  char *sa; // [rsp+8h] [rbp-180h]
  char *v32; // [rsp+10h] [rbp-178h]
  char buf; // [rsp+20h] [rbp-168h]
  char dest; // [rsp+40h] [rbp-148h]
  unsigned __int64 v35; // [rsp+148h] [rbp-40h]

  v4 = a3;
  v5 = a2;
  v6 = a4;
  v35 = __readfsqword(0x28u);
  sub_2B530(3, (__int64)"ParseAddress(%s)\n", s);
  v7 = strdup(s);
  v8 = v7;
  v9 = strchr(v7, 47);
  if ( !v9 )
  {
    v9 = strrchr(v8, 58);
    if ( !v9 )
      goto LABEL_43;
  }
  if ( *v9 == 58 )
  {
    v11 = "local";
    v10 = v8;
    if ( v9 != v8 )
      v11 = "tcp";
  }
  else
  {
    *v9 = 0;
    v10 = v9 + 1;
    v11 = v8;
    if ( !*v8 )
    {
      v11 = "tcp";
      if ( v9[1] == 58 )
        v11 = "local";
    }
  }
  v12 = strrchr(v10, 58);
  if ( v12 )
  {
    *v12 = 0;
    sa = v12 + 1;
    v13 = strlen(v10);
    if ( v13 )
    {
      v14 = (unsigned int)v13 < 3;
      v15 = v13 == 3;
      if ( v13 > 3 )
      {
        v21 = "tcp";
        v22 = 4LL;
        v23 = v11;
        do
        {
          if ( !v22 )
            break;
          v14 = (const unsigned __int8)*v23 < *v21;
          v15 = *v23++ == *v21++;
          --v22;
        }
        while ( v15 );
        v24 = (!v14 && !v15) - v14;
        v25 = 0;
        v26 = v24 == 0;
        if ( !v24 )
          goto LABEL_44;
        v28 = "inet6";
        v29 = 6LL;
        v30 = v11;
        do
        {
          if ( !v29 )
            break;
          v25 = (const unsigned __int8)*v30 < *v28;
          v26 = *v30++ == *v28++;
          --v29;
        }
        while ( v26 );
        if ( (!v25 && !v26) == v25 )
        {
LABEL_44:
          if ( *v10 == 91 )
          {
            v27 = &v10[v13 - 1];
            if ( *v27 == 93 )
            {
              *v27 = 0;
              v32 = &v10[v13 - 1];
              if ( inet_pton(10, v10 + 1, &buf) == 1 )
              {
                ++v10;
                v11 = "inet6";
              }
              else
              {
                *v32 = 93;
              }
            }
          }
        }
      }
    }
    else
    {
      v10 = &dest;
      _FontTransGetHostname(&dest);
    }
    v16 = strchr(sa, 47);
    if ( v16 )
      *v16 = 0;
    v17 = strdup(v11);
    *v5 = v17;
    if ( v17 )
    {
      v18 = strdup(v10);
      *v4 = v18;
      if ( v18 )
      {
        v19 = strdup(sa);
        *v6 = v19;
        if ( v19 )
        {
          free(v8);
          return 1LL;
        }
        free(*v4);
      }
      else
      {
        *v6 = 0LL;
      }
      *v4 = 0LL;
      free(*v5);
      *v5 = 0LL;
      free(v8);
      result = 0LL;
    }
    else
    {
      *v6 = 0LL;
      *v4 = 0LL;
      *v5 = 0LL;
      free(v8);
      result = 0LL;
    }
  }
  else
  {
LABEL_43:
    *a2 = 0LL;
    *v4 = 0LL;
    *v6 = 0LL;
    free(v8);
    result = 0LL;
  }
  return result;
}

//----- (000000000002CFB0) ----------------------------------------------------
char ***__fastcall sub_2CFB0(unsigned int a1, char *a2)
{
  unsigned int v2; // er14
  char *v3; // rbx
  char *v4; // rbp
  __int64 v5; // rbx
  char **v6; // rbp
  char ***v7; // rbx
  char *v8; // rdi
  char ***v9; // rax
  char *v10; // rdi
  char ***v11; // ST08_8
  char *src; // [rsp+18h] [rbp-60h]
  void *ptr; // [rsp+20h] [rbp-58h]
  void *v15; // [rsp+28h] [rbp-50h]
  char dest; // [rsp+30h] [rbp-48h]
  char v17; // [rsp+43h] [rbp-35h]
  int v18; // [rsp+44h] [rbp-34h]
  unsigned __int64 v19; // [rsp+48h] [rbp-30h]

  v2 = a1;
  v19 = __readfsqword(0x28u);
  src = 0LL;
  ptr = 0LL;
  v15 = 0LL;
  sub_2B530(2, (__int64)"Open(%d,%s)\n", a1, a2);
  if ( (unsigned int)sub_2CCA0(a2, (void **)&src, &ptr, (char **)&v15) )
  {
    v3 = src;
    v4 = &dest;
    sub_2B530(3, (__int64)"SelectTransport(%s)\n", src);
    strncpy(&dest, v3, 0x13uLL);
    v17 = 0;
    do
    {
      v5 = (unsigned __int8)*v4;
      if ( !(_BYTE)v5 )
        break;
      if ( (*__ctype_b_loc())[v5] & 0x100 )
        *v4 = (*__ctype_tolower_loc())[v5];
      ++v4;
    }
    while ( &v18 != (int *)v4 );
    v6 = &FontTransSocketTCPFuncs;
    v7 = &off_23AC80;
    if ( !strcmp(&dest, FontTransSocketTCPFuncs) )
    {
LABEL_10:
      v8 = src;
      if ( v2 != 2 )
      {
        if ( v2 == 3 )
          v9 = (char ***)((__int64 (__fastcall *)(char **, char *, void *, void *))v6[3])(v6, src, ptr, v15);
        else
          v9 = (char ***)((__int64 (__fastcall *)(char **, char *, void *, void *))v6[2])(v6, src, ptr, v15);
        if ( v9 )
        {
          *v9 = v6;
          v10 = src;
          v11 = v9;
          v9[4] = (char **)v15;
          free(v10);
          free(ptr);
          return v11;
        }
        v8 = src;
      }
      if ( (_BYTE)v6[1] & 4 )
        goto LABEL_17;
      sub_2B530(1, (__int64)"Open: transport open failed for %s/%s:%s\n", v8, ptr, v15);
    }
    else
    {
      while ( 1 )
      {
        v7 += 2;
        if ( &off_23AC80 + 10 == v7 )
          break;
        v6 = *v7;
        if ( !strcmp(&dest, **v7) )
          goto LABEL_10;
      }
      sub_2B530(1, (__int64)"Open: Unable to find transport for %s\n", src);
    }
    v8 = src;
LABEL_17:
    free(v8);
    free(ptr);
    free(v15);
    return 0LL;
  }
  sub_2B530(1, (__int64)"Open: Unable to Parse address %s\n", a2);
  return 0LL;
}
// 23AC80: using guessed type char **off_23AC80;
// 23C680: using guessed type char *FontTransSocketTCPFuncs;

//----- (000000000002D200) ----------------------------------------------------
char ***__fastcall FontTransOpenCOTSClient(char *a1)
{
  sub_2B530(2, (__int64)"OpenCOTSClient(%s)\n", a1);
  return sub_2CFB0(1u, a1);
}

//----- (000000000002D230) ----------------------------------------------------
char ***__fastcall FontTransOpenCLTSClient(char *a1)
{
  sub_2B530(2, (__int64)"OpenCLTSClient(%s)\n", a1);
  return sub_2CFB0(3u, a1);
}

//----- (000000000002D260) ----------------------------------------------------
__int64 __fastcall FontTransConnect(unsigned int *a1, char *a2)
{
  __int64 v2; // rdx
  unsigned int v3; // ebx
  void *v4; // rdi
  void *ptr; // [rsp+0h] [rbp-38h]
  void *v7; // [rsp+8h] [rbp-30h]
  void *v8; // [rsp+10h] [rbp-28h]
  unsigned __int64 v9; // [rsp+18h] [rbp-20h]

  v2 = a1[7];
  v9 = __readfsqword(0x28u);
  sub_2B530(2, (__int64)"Connect(%d,%s)\n", v2, a2);
  if ( !(unsigned int)sub_2CCA0(a2, &ptr, &v7, (char **)&v8) )
  {
    v3 = -1;
    sub_2B530(1, (__int64)"Connect: Unable to Parse address %s\n", a2);
    return v3;
  }
  if ( v8 && *(_BYTE *)v8 )
  {
    v3 = (*(__int64 (__fastcall **)(unsigned int *, void *))(*(_QWORD *)a1 + 40LL))(a1, v7);
    if ( ptr )
      free(ptr);
    if ( v7 )
      free(v7);
    v4 = v8;
    if ( v8 )
    {
LABEL_9:
      free(v4);
      return v3;
    }
  }
  else
  {
    sub_2B530(1, (__int64)"Connect: Missing port specification in %s\n", a2);
    if ( ptr )
      free(ptr);
    v4 = v7;
    v3 = -1;
    if ( v7 )
      goto LABEL_9;
  }
  return v3;
}

//----- (000000000002D370) ----------------------------------------------------
__int64 __fastcall MakeAtom(const char *a1, unsigned int a2, int a3)
{
  int v3; // er9
  const char *v4; // rdx
  int v5; // eax
  int v6; // ebp
  __int64 *v7; // r12
  int v8; // ebx
  __int64 v9; // rax
  __int64 v10; // rcx
  char v11; // r10
  __int64 v12; // r14
  char *v14; // rax
  char *v15; // r13
  __int64 v16; // rax
  int v17; // edx
  int v18; // er15
  char *j; // rsi
  unsigned __int64 v20; // rcx
  void *v21; // rax
  int v22; // er14
  char *v23; // r8
  int v24; // ebx
  int v25; // er10
  __int64 *v26; // rdi
  __int64 v27; // r9
  int v28; // eax
  int v29; // ecx
  char *i; // rsi
  int v31; // ST14_4
  char *v32; // ST08_8
  char *v33; // r8
  int v34; // ecx
  __int64 v35; // rdx
  char v36; // cl
  int v37; // ebx
  size_t v38; // rbp
  signed __int64 v39; // rcx
  int v40; // [rsp+8h] [rbp-50h]

  v3 = a3;
  if ( a2 )
  {
    v4 = a1;
    v5 = 0;
    do
      v5 = *(++v4 - 1) ^ 8 * v5;
    while ( v4 != &a1[a2] );
    v6 = abs(v5);
  }
  else
  {
    v6 = 0;
  }
  v7 = (__int64 *)qword_23CD58;
  if ( qword_23CD58 )
  {
    v8 = v6 & dword_23CD4C;
    v9 = *((_QWORD *)qword_23CD58 + (v6 & dword_23CD4C));
    if ( v9 )
    {
      if ( *(_DWORD *)(v9 + 12) == v6 && *(_DWORD *)(v9 + 8) == a2 )
      {
        v35 = 0LL;
        while ( a2 != v35 )
        {
          v36 = *(_BYTE *)(*(_QWORD *)v9 + v35++);
          if ( v36 != a1[v35 - 1] )
            goto LABEL_8;
        }
        return *(_QWORD *)(v9 + 16);
      }
      while ( 1 )
      {
LABEL_8:
        v8 += v6 % dword_23CD48 | 1;
        if ( dword_23CD54 <= v8 )
          v8 -= dword_23CD54;
        v9 = *((_QWORD *)qword_23CD58 + v8);
        if ( !v9 )
          break;
        if ( *(_DWORD *)(v9 + 12) == v6 && *(_DWORD *)(v9 + 8) == a2 )
        {
          v10 = 0LL;
          while ( a2 != v10 )
          {
            v11 = *(_BYTE *)(*(_QWORD *)v9 + v10++);
            if ( v11 != a1[v10 - 1] )
              goto LABEL_8;
          }
          return *(_QWORD *)(v9 + 16);
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v12 = 0LL;
  if ( !v3 )
    return v12;
  v14 = (char *)malloc(a2 + 25LL);
  v15 = v14;
  if ( !v14 )
  {
    __fprintf_chk(stderr, 1LL, "MakeAtom(): Error: Couldn't allocate AtomListRec (%ld)\n", a2 + 25LL);
    return v12;
  }
  *((_DWORD *)v14 + 2) = a2;
  *(_QWORD *)v14 = v14 + 24;
  strncpy(v14 + 24, a1, a2);
  v16 = qword_23CD30;
  v17 = dword_23CD54;
  v15[a2 + 24] = 0;
  v18 = dword_23CD50;
  *((_DWORD *)v15 + 3) = v6;
  qword_23CD30 = v16 + 1;
  *((_QWORD *)v15 + 2) = v16 + 1;
  if ( v17 / 2 <= v18 )
  {
    if ( v17 )
    {
      v22 = 2 * v17;
      v40 = v17;
      v23 = (char *)calloc(2 * v17, 8uLL);
      if ( v23 )
      {
        v24 = v22 - 1;
        v25 = v22 - 3;
        if ( v40 > 0 )
        {
          v26 = v7;
          do
          {
            v27 = *v26;
            if ( *v26 )
            {
              v28 = *(_DWORD *)(v27 + 12);
              v29 = v28 & v24;
              for ( i = &v23[8 * (v28 & v24)]; *(_QWORD *)i; i = &v23[8 * v29] )
              {
                v29 += v28 % v25 | 1;
                if ( v22 <= v29 )
                  v29 -= v22;
              }
              *(_QWORD *)i = v27;
            }
            ++v26;
          }
          while ( &v7[(unsigned int)(v40 - 1) + 1] != v26 );
        }
        goto LABEL_36;
      }
      v39 = 8LL * v22;
    }
    else
    {
      v23 = (char *)calloc(0x400uLL, 8uLL);
      v39 = 0x2000LL;
      if ( v23 )
      {
        v25 = 1021;
        v24 = 1023;
        v22 = 1024;
LABEL_36:
        v31 = v25;
        v32 = v23;
        free(v7);
        v33 = v32;
        dword_23CD54 = v22;
        dword_23CD4C = v24;
        qword_23CD58 = v32;
        dword_23CD48 = v31;
        goto LABEL_37;
      }
    }
    __fprintf_chk(stderr, 1LL, "ResizeHashTable(): Error: Couldn't allocate newHashTable (%ld)\n", v39);
    v24 = dword_23CD4C;
    v33 = (char *)qword_23CD58;
    v18 = dword_23CD50;
LABEL_37:
    v34 = v6 & v24;
    for ( j = &v33[8 * (v6 & v24)]; *(_QWORD *)j; j = &v33[8 * v34] )
    {
      v34 += v6 % dword_23CD48 | 1;
      if ( dword_23CD54 <= v34 )
        v34 -= dword_23CD54;
    }
    goto LABEL_23;
  }
  j = (char *)&v7[v8];
LABEL_23:
  *(_QWORD *)j = v15;
  v20 = *((_QWORD *)v15 + 2);
  dword_23CD50 = v18 + 1;
  v21 = qword_23CD40;
  if ( dword_23CD38 <= v20 )
  {
    if ( dword_23CD38 )
    {
      v37 = 2 * dword_23CD38;
      v38 = 16LL * dword_23CD38;
    }
    else
    {
      v38 = 8000LL;
      v37 = 1000;
    }
    v21 = realloc(qword_23CD40, v38);
    if ( !v21 )
    {
      v12 = 0LL;
      __fprintf_chk(stderr, 1LL, "ResizeReverseMap(): Error: Couldn't reallocate reverseMap (%ld)\n", v38);
      return v12;
    }
    qword_23CD40 = v21;
    dword_23CD38 = v37;
    v20 = *((_QWORD *)v15 + 2);
  }
  *((_QWORD *)v21 + v20) = v15;
  return *((_QWORD *)v15 + 2);
}
// 8E40: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 23CD30: using guessed type __int64 qword_23CD30;
// 23CD38: using guessed type int dword_23CD38;
// 23CD48: using guessed type int dword_23CD48;
// 23CD4C: using guessed type int dword_23CD4C;
// 23CD50: using guessed type int dword_23CD50;
// 23CD54: using guessed type int dword_23CD54;

//----- (000000000002D7A0) ----------------------------------------------------
_BOOL8 __fastcall ValidAtom(unsigned __int64 a1)
{
  _BOOL8 result; // rax

  result = 0LL;
  if ( a1 )
    result = qword_23CD30 >= a1;
  return result;
}
// 23CD30: using guessed type __int64 qword_23CD30;

//----- (000000000002D7C0) ----------------------------------------------------
__int64 __fastcall NameForAtom(unsigned __int64 a1)
{
  __int64 result; // rax

  if ( a1 && qword_23CD30 >= a1 )
    result = **((_QWORD **)qword_23CD40 + a1);
  else
    result = 0LL;
  return result;
}
// 23CD30: using guessed type __int64 qword_23CD30;

//----- (000000000002D7F0) ----------------------------------------------------
__int64 __fastcall FontComputeInfoAccelerators(__int64 a1)
{
  __int16 v1; // dx
  char v2; // al
  bool v3; // cc
  __int16 v4; // cx
  __int64 result; // rax
  __int16 v6; // si
  char v7; // si
  bool v8; // zf
  __int16 v9; // r8

  v1 = *(_WORD *)(a1 + 28);
  v2 = *(_BYTE *)(a1 + 10) & 0xFE;
  v3 = *(_WORD *)(a1 + 12) > v1;
  *(_BYTE *)(a1 + 10) = v2;
  if ( !v3 )
    *(_BYTE *)(a1 + 10) = v2 | 1;
  v4 = *(_WORD *)(a1 + 34);
  result = *(unsigned __int16 *)(a1 + 32);
  v6 = *(_WORD *)(a1 + 20);
  if ( v4 == *(_WORD *)(a1 + 22) )
  {
    v9 = *(_WORD *)(a1 + 36);
    if ( v9 == *(_WORD *)(a1 + 24) && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a1 + 16) )
    {
      if ( (_WORD)result != v6 )
      {
        *(_BYTE *)(a1 + 10) &= 0xF9u;
        goto LABEL_5;
      }
      if ( *(_WORD *)(a1 + 38) == *(_WORD *)(a1 + 26) )
      {
        v7 = *(_BYTE *)(a1 + 10);
        v8 = *(_WORD *)(a1 + 16) == 0;
        *(_BYTE *)(a1 + 10) |= 4u;
        if ( v8 && *(_WORD *)(a1 + 18) == (_WORD)result && v4 == *(_WORD *)(a1 + 64) && v9 == *(_WORD *)(a1 + 66) )
          *(_BYTE *)(a1 + 10) = v7 | 6;
        else
          *(_BYTE *)(a1 + 10) &= 0xFDu;
      }
      else
      {
        *(_BYTE *)(a1 + 10) &= 0xF9u;
      }
LABEL_17:
      *(_BYTE *)(a1 + 10) |= 8u;
      goto LABEL_6;
    }
  }
  *(_BYTE *)(a1 + 10) &= 0xF9u;
  if ( (_WORD)result == v6 )
    goto LABEL_17;
LABEL_5:
  *(_BYTE *)(a1 + 10) &= 0xF7u;
LABEL_6:
  if ( v1 < 0
    || *(_WORD *)(a1 + 12) > 0
    || (result = (unsigned int)-*(signed __int16 *)(a1 + 66), *(signed __int16 *)(a1 + 34) < (signed int)result)
    || (result = (unsigned int)*(signed __int16 *)(a1 + 64), *(_WORD *)(a1 + 22) > *(_WORD *)(a1 + 64))
    || -*(signed __int16 *)(a1 + 36) > (signed int)result
    || *(_WORD *)(a1 + 66) < *(_WORD *)(a1 + 24) )
  {
    *(_BYTE *)(a1 + 10) &= 0xEFu;
  }
  else
  {
    *(_BYTE *)(a1 + 10) |= 0x10u;
  }
  return result;
}

//----- (000000000002D900) ----------------------------------------------------
_BOOL8 __fastcall FontCouldBeTerminal(__int64 a1)
{
  _BOOL8 result; // rax
  __int16 v2; // dx
  unsigned __int16 v3; // cx
  unsigned __int16 v4; // si

  result = 0LL;
  if ( *(_WORD *)(a1 + 28) >= 0 )
  {
    v2 = *(_WORD *)(a1 + 20);
    if ( *(_WORD *)(a1 + 18) <= v2 && v2 == *(_WORD *)(a1 + 32) )
    {
      v3 = *(_WORD *)(a1 + 22);
      if ( (signed __int16)v3 <= *(_WORD *)(a1 + 64) )
      {
        v4 = *(_WORD *)(a1 + 24);
        if ( (signed __int16)v4 <= *(_WORD *)(a1 + 66)
          && (*(_WORD *)(a1 + 16) || v2 != *(_WORD *)(a1 + 30) || *(_DWORD *)(a1 + 64) != *(_DWORD *)(a1 + 34)) )
        {
          result = (v4 | v3) != 0;
        }
      }
    }
  }
  return result;
}

//----- (000000000002D960) ----------------------------------------------------
void __fastcall FreeFontNames(void *ptr)
{
  void *v1; // rbx
  __int64 v2; // r12
  int v3; // ebp
  void *v4; // rdi

  if ( ptr )
  {
    v1 = ptr;
    if ( *(_DWORD *)ptr > 0 )
    {
      v2 = 0LL;
      v3 = 0;
      do
      {
        ++v3;
        v4 = *(void **)(*((_QWORD *)v1 + 2) + v2);
        v2 += 8LL;
        free(v4);
      }
      while ( *(_DWORD *)v1 > v3 );
    }
    free(*((void **)v1 + 2));
    free(*((void **)v1 + 1));
    free(v1);
  }
}

//----- (000000000002D9D0) ----------------------------------------------------
_QWORD *__fastcall MakeFontNamesRecord(unsigned int a1)
{
  _DWORD *v1; // rax
  _QWORD *v2; // rbx
  void *v4; // rax
  void *v5; // r12
  void *v6; // rax
  void *ptr; // ST08_8
  void *v8; // rdi

  v1 = malloc(0x18uLL);
  v2 = v1;
  if ( v1 )
  {
    *v1 = 0;
    v1[1] = a1;
    if ( a1 )
    {
      v4 = malloc(4LL * a1);
      v5 = v4;
      v2[1] = v4;
      v6 = malloc(8LL * a1);
      v2[2] = v6;
      if ( !v5 || !v6 )
      {
        ptr = v6;
        free(v5);
        free(ptr);
        v8 = v2;
        v2 = 0LL;
        free(v8);
      }
    }
    else
    {
      *((_QWORD *)v1 + 1) = 0LL;
      *((_QWORD *)v1 + 2) = 0LL;
    }
  }
  return v2;
}

//----- (000000000002DA70) ----------------------------------------------------
signed __int64 __fastcall AddFontNamesName(signed int *a1, const char *a2, int a3)
{
  const char *v3; // r13
  size_t v4; // rbp
  __int64 v5; // r12
  void *v6; // r14
  signed __int64 result; // rax
  signed int v8; // eax
  void *v9; // rcx
  bool v10; // zf
  int v11; // eax
  signed int v12; // edx
  size_t v13; // rsi
  size_t v14; // r15
  void *v15; // rax
  void *v16; // ST00_8
  void *v17; // ST08_8
  void *v18; // [rsp+0h] [rbp-48h]
  signed int ptr; // [rsp+8h] [rbp-40h]

  v3 = a2;
  v4 = a3;
  v5 = *a1;
  v6 = malloc(a3 + 1);
  result = 80LL;
  if ( v6 )
  {
    v8 = a1[1];
    v9 = (void *)*((_QWORD *)a1 + 1);
    if ( v8 <= (signed int)v5 )
    {
      v10 = 2 * v8 == 0;
      v11 = 2 * v8;
      v12 = v11;
      if ( v10 )
      {
        v14 = 64LL;
        v13 = 32LL;
        v12 = 8;
      }
      else
      {
        v13 = 4LL * v11;
        v14 = 8LL * v11;
      }
      ptr = v12;
      v18 = realloc(*((void **)a1 + 1), v13);
      v15 = realloc(*((void **)a1 + 2), v14);
      v9 = v18;
      if ( !v18 || !v15 )
      {
        v16 = v15;
        v17 = v9;
        free(v6);
        free(v17);
        free(v16);
        return 80LL;
      }
      *((_QWORD *)a1 + 1) = v18;
      *((_QWORD *)a1 + 2) = v15;
      a1[1] = ptr;
    }
    *((_DWORD *)v9 + v5) = v4;
    *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v5) = v6;
    strncpy((char *)v6, v3, v4);
    ++*a1;
    *((_BYTE *)v6 + v4) = 0;
    result = 85LL;
  }
  return result;
}

//----- (000000000002DBB0) ----------------------------------------------------
unsigned __int64 __fastcall QueryGlyphExtents(_WORD *a1, unsigned __int64 *a2, unsigned __int64 a3, int *a4)
{
  unsigned __int64 result; // rax
  int v5; // er8
  signed __int64 v6; // r8
  int v7; // edi
  int v8; // er9
  int v9; // er10
  int v10; // edi
  int v11; // er9
  int v12; // edi
  int v13; // er10
  int v14; // edi
  int v15; // edx

  *a4 = (a1[9] >> 7) & 3;
  a4[1] = (signed __int16)a1[36];
  result = (unsigned int)(signed __int16)a1[37];
  a4[2] = result;
  if ( a3 )
  {
    result = *a2;
    v5 = *(signed __int16 *)(*a2 + 6);
    if ( *(_WORD *)(*a2 + 4) || *(_WORD *)(result + 2) || *(_WORD *)result || (_WORD)v5 || *(_WORD *)(result + 8) )
    {
      a4[3] = v5;
      a4[4] = *(signed __int16 *)(result + 8);
      a4[6] = *(signed __int16 *)result;
      a4[7] = *(signed __int16 *)(result + 2);
      a4[5] = *(signed __int16 *)(result + 4);
    }
    if ( (a1[9] & 5) == 5 )
    {
      v15 = a4[5] * a3;
      a4[5] = v15;
      result = (unsigned int)*(signed __int16 *)(result + 4);
      a4[7] += v15 - result;
    }
    else
    {
      v6 = 1LL;
      if ( a3 > 1 )
      {
        do
        {
          result = a2[v6];
          v7 = *(signed __int16 *)(result + 6);
          if ( *(_WORD *)(result + 4)
            || *(_WORD *)(result + 2)
            || *(_WORD *)result
            || (_WORD)v7
            || *(_WORD *)(result + 8) )
          {
            v8 = a4[4];
            if ( a4[3] >= v7 )
              v7 = a4[3];
            v9 = a4[6];
            a4[3] = v7;
            v10 = *(signed __int16 *)(result + 8);
            if ( v10 < v8 )
              v10 = v8;
            v11 = a4[5];
            a4[4] = v10;
            v12 = v11 + *(signed __int16 *)result;
            if ( v12 > v9 )
              v12 = v9;
            v13 = a4[7];
            a4[6] = v12;
            v14 = v11 + *(signed __int16 *)(result + 2);
            if ( v14 < v13 )
              v14 = v13;
            a4[7] = v14;
            result = (unsigned int)(v11 + *(signed __int16 *)(result + 4));
            a4[5] = result;
          }
          ++v6;
        }
        while ( a3 != v6 );
      }
    }
  }
  else
  {
    *(_QWORD *)(a4 + 3) = 0LL;
    *(_QWORD *)(a4 + 5) = 0LL;
    a4[7] = 0;
  }
  return result;
}

//----- (000000000002DD40) ----------------------------------------------------
signed __int64 __fastcall QueryTextExtents(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // rbp
  _QWORD *v6; // r12
  signed __int64 result; // rax
  unsigned int v8; // er15
  __int16 v9; // ax
  int v10; // ebx
  int v11; // er14
  _WORD *v12; // r8
  __int64 v13; // rsi
  __int64 v14; // rdx
  _WORD *v15; // rax
  __int64 v16; // rcx
  unsigned __int8 v17; // bl
  __int64 v18; // [rsp+8h] [rbp-60h]
  char v19; // [rsp+10h] [rbp-58h]
  _WORD *v20; // [rsp+18h] [rbp-50h]
  char v21; // [rsp+26h] [rbp-42h]
  char v22; // [rsp+27h] [rbp-41h]
  unsigned __int64 v23; // [rsp+28h] [rbp-40h]

  v4 = a3;
  v5 = a4;
  v23 = __readfsqword(0x28u);
  v20 = 0LL;
  v6 = malloc(8 * a2);
  result = 0LL;
  if ( !v6 )
    return result;
  v8 = (*(_WORD *)(a1 + 14) != 0) + 2;
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *, _QWORD *))(a1 + 112))(a1, a2, v4, v8, &v18, v6);
  v9 = *(_WORD *)(a1 + 16);
  v10 = v18;
  v11 = v18;
  v22 = *(_WORD *)(a1 + 16);
  v21 = HIBYTE(v9);
  (*(void (__fastcall **)(__int64, signed __int64, char *, _QWORD, char *, _WORD **))(a1 + 112))(
    a1,
    1LL,
    &v21,
    v8,
    &v19,
    &v20);
  if ( v20 && (v20[3] || v20[4] || *v20 || v20[1] || v20[2]) )
  {
    v13 = v18;
    if ( !v18 )
      goto LABEL_24;
    goto LABEL_5;
  }
  v13 = v18;
  v20 = 0LL;
  if ( v18 )
  {
LABEL_5:
    v12 = v20;
    v14 = 0LL;
    while ( 1 )
    {
      v15 = (_WORD *)v6[v14];
      v16 = v11;
      if ( v15 && (v15[3] || v15[4] || *v15 || v15[1] || v15[2]) )
        goto LABEL_10;
      if ( v12 )
        break;
LABEL_12:
      if ( v13 == ++v14 )
        goto LABEL_13;
    }
    v6[v14] = v12;
LABEL_10:
    if ( v13 == v11 )
    {
      v16 = v14;
      v11 = v14;
    }
    goto LABEL_12;
  }
LABEL_24:
  v16 = v10;
  v14 = 0LL;
LABEL_13:
  v17 = *(_BYTE *)(a1 + 18);
  *(_BYTE *)(a1 + 18) &= 0xFBu;
  QueryGlyphExtents(a1, &v6[v16], v14 - v16, v5, v12);
  *(_BYTE *)(a1 + 18) = 4 * ((v17 >> 2) & 1) | *(_BYTE *)(a1 + 18) & 0xFB;
  free(v6);
  return 1LL;
}
// 8410: using guessed type __int64 __fastcall QueryGlyphExtents(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002DF60) ----------------------------------------------------
signed __int64 __usercall ParseGlyphCachingMode@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>)
{
  _BYTE *v3; // rdx
  const char *v4; // rdi
  signed __int64 v5; // rcx
  _BYTE *v6; // rsi
  char v7; // al
  bool v8; // cf
  bool v9; // zf
  const char *v10; // rdi
  signed __int64 v11; // rcx
  _BYTE *v12; // rsi
  char v13; // al
  bool v14; // cf
  bool v15; // zf
  const char *v16; // rdi
  _BYTE *v17; // rsi
  signed __int64 v18; // rcx
  signed __int64 result; // rax

  v3 = a3;
  v4 = "none";
  v5 = 5LL;
  v6 = v3;
  do
  {
    if ( !v5 )
      break;
    a1 = *v6 < (const unsigned __int8)*v4;
    a2 = *v6++ == *v4++;
    --v5;
  }
  while ( a2 );
  v7 = (!a1 && !a2) - a1;
  v8 = 0;
  v9 = v7 == 0;
  if ( v7 )
  {
    v10 = "all";
    v11 = 4LL;
    v12 = v3;
    do
    {
      if ( !v11 )
        break;
      v8 = *v12 < (const unsigned __int8)*v10;
      v9 = *v12++ == *v10++;
      --v11;
    }
    while ( v9 );
    v13 = (!v8 && !v9) - v8;
    v14 = 0;
    v15 = v13 == 0;
    if ( v13 )
    {
      v16 = "16";
      v17 = v3;
      v18 = 3LL;
      do
      {
        if ( !v18 )
          break;
        v14 = *v17 < (const unsigned __int8)*v16;
        v15 = *v17++ == *v16++;
        --v18;
      }
      while ( v15 );
      result = 0LL;
      if ( (!v14 && !v15) == v14 )
      {
        dword_23C6F4 = 1;
        result = 1LL;
      }
    }
    else
    {
      dword_23C6F4 = 2;
      result = 1LL;
    }
  }
  else
  {
    dword_23C6F4 = 0;
    result = 1LL;
  }
  return result;
}
// 23C6F4: using guessed type int dword_23C6F4;

//----- (000000000002DFF0) ----------------------------------------------------
void *InitGlyphCaching()
{
  void *result; // rax

  result = &glyphCachingMode;
  glyphCachingMode = dword_23C6F4;
  return result;
}
// 23C6F4: using guessed type int dword_23C6F4;

//----- (000000000002E000) ----------------------------------------------------
void *__fastcall SetGlyphCachingMode(int a1)
{
  void *result; // rax

  result = &glyphCachingMode;
  if ( glyphCachingMode > a1 && a1 >= 0 )
    glyphCachingMode = a1;
  return result;
}

//----- (000000000002E020) ----------------------------------------------------
__int64 __fastcall add_range(unsigned __int8 *a1, int *a2, void **a3, int a4)
{
  int *v4; // r14
  void **v5; // r12
  signed int v6; // er15
  signed int v7; // edx
  char v8; // al
  __int64 result; // rax
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rbx
  int v12; // edx
  int v13; // er10
  char *v14; // r11
  int v15; // esi
  char *v16; // r8
  int v17; // er13
  int v18; // er9
  int v19; // eax
  unsigned __int64 v20; // rbp
  int v21; // edi
  _BYTE *v22; // rax
  _BYTE *v23; // r12
  void *v24; // rdi
  char *v25; // rsi
  int v26; // er8
  unsigned __int64 v27; // r12
  unsigned __int64 v28; // rdx
  unsigned __int8 v29; // r10
  char *v30; // r13
  int v31; // edi
  unsigned __int8 v32; // di
  int v33; // edi
  signed __int64 v34; // rdx
  void **v35; // [rsp+0h] [rbp-58h]
  int v36; // [rsp+8h] [rbp-50h]
  char v37; // [rsp+Fh] [rbp-49h]
  char v38; // [rsp+14h] [rbp-44h]
  char v39; // [rsp+15h] [rbp-43h]
  char v40; // [rsp+16h] [rbp-42h]
  unsigned __int8 v41; // [rsp+17h] [rbp-41h]
  unsigned __int64 v42; // [rsp+18h] [rbp-40h]

  v4 = a2;
  v5 = a3;
  v6 = *a1;
  v42 = __readfsqword(0x28u);
  v35 = a3;
  v7 = a1[2];
  v37 = v6;
  if ( a4 )
  {
    v10 = a1[1] + (v6 << 8);
    v11 = (v7 << 8) + a1[3];
    if ( v10 <= v11 )
    {
      v11 = v10;
      v10 = (v7 << 8) + a1[3];
    }
  }
  else
  {
    if ( (_BYTE)v6 != (_BYTE)v7 )
    {
      if ( v6 > v7 )
        return 0LL;
      do
      {
        v8 = a1[1];
        v40 = v6;
        v38 = v6;
        v39 = v8;
        v41 = a1[3];
        result = add_range(&v38, a2, v5, 0LL);
        if ( (_DWORD)result != 85 )
          break;
        ++v6;
      }
      while ( a1[2] >= v6 );
      return result;
    }
    v11 = (v6 << 8) + a1[1];
    v10 = (v7 << 8) + a1[3];
  }
  v36 = *a2;
  v12 = *a2 - 1;
  if ( v12 < 0 )
  {
    v20 = 0LL;
    v17 = 0;
    goto LABEL_16;
  }
  v13 = 0;
  v14 = (char *)*v35;
  while ( 1 )
  {
    while ( 1 )
    {
      v15 = (v12 + v13) / 2;
      v16 = &v14[4 * v15];
      v17 = (v12 + v13) / 2;
      LOBYTE(v18) = *v16;
      v19 = (unsigned __int8)v16[1] + ((unsigned __int8)*v16 << 8);
      v20 = v19;
      if ( !v19 || v19 - 1LL <= v10 )
        break;
      v12 = v17 - 1;
      if ( v17 - 1 < v13 )
        goto LABEL_16;
    }
    v21 = (unsigned __int8)v16[3] + ((unsigned __int8)v16[2] << 8);
    if ( v21 + 1LL >= v11 )
      break;
    v13 = v15 + 1;
    if ( v12 < v15 + 1 )
      goto LABEL_16;
  }
  v25 = &v14[4 * v15];
  v26 = (unsigned __int8)v16[1];
  v27 = v21;
  if ( (_BYTE)v18 != v37 && !a4 )
  {
LABEL_16:
    if ( v36 && (v22 = *v35) != 0LL )
    {
      if ( v36 & 0xF )
      {
LABEL_19:
        v23 = &v22[4 * v17];
        v24 = v23 + 4;
        if ( v17 < v36 && v11 > v20 )
        {
          v34 = (signed __int64)(v23 + 8);
          v23 += 4;
          v24 = (void *)v34;
        }
        memmove(v24, v23, &v22[4 * v36] - v23);
        v23[1] = v11;
        v23[3] = v10;
        *v23 = BYTE1(v11);
        result = 85LL;
        v23[2] = BYTE1(v10);
        ++*v4;
        return result;
      }
      v22 = realloc(*v35, 4 * v36 + 64);
      *v35 = v22;
    }
    else
    {
      *v35 = malloc(0x40uLL);
      *v4 = 0;
      v22 = *v35;
    }
    if ( !v22 )
    {
      *v4 = 0;
      return 80LL;
    }
    v36 = *v4;
    goto LABEL_19;
  }
  if ( v11 < v19 )
  {
    v26 = (unsigned __int8)v11;
    v25[1] = v11;
    v18 = v11 >> 8;
    *v25 = BYTE1(v11);
    v20 = (unsigned __int8)v11 + (v18 << 8);
  }
  if ( v10 > v21 )
  {
    v25[3] = v10;
    v25[2] = BYTE1(v10);
    v21 = (unsigned __int8)v10 + ((unsigned int)(v10 >> 8) << 8);
    v27 = v21;
  }
  v28 = (unsigned __int64)*v35 + 4 * *v4;
  if ( *v35 > v25 )
  {
    v30 = v25;
  }
  else
  {
    v29 = v18;
    v30 = v25;
    if ( v21 + 1 >= v20 )
    {
      while ( a4 || (_BYTE)v18 == v29 )
      {
        v31 = (unsigned __int8)v30[1];
        if ( v20 > v31 + (v29 << 8) )
          v20 = v31 + (v29 << 8);
        v30 -= 4;
        if ( *v35 > v30 || ((unsigned __int8)v30[2] << 8) + (unsigned __int8)v30[3] + 1 < v20 )
          break;
        v29 = *v30;
      }
    }
  }
  v32 = v18;
  if ( (unsigned __int64)v25 < v28 )
  {
    while ( (!(_BYTE)v26 && !v32 || (v32 << 8) + v26 - 1 <= v27) && (a4 || (_BYTE)v18 == v32) )
    {
      v33 = (unsigned __int8)v25[3];
      if ( v27 < v33 + ((unsigned __int8)v25[2] << 8) )
        v27 = v33 + ((unsigned __int8)v25[2] << 8);
      v25 += 4;
      if ( v28 <= (unsigned __int64)v25 )
        break;
      v26 = (unsigned __int8)v25[1];
      v32 = *v25;
    }
  }
  if ( v30 + 4 != v25 - 4 )
    *v4 -= (v25 - 4 - (_BYTE *)memmove(v30 + 4, v25 - 4, v28 - (_QWORD)(v25 - 4))) >> 2;
  v30[5] = v20;
  v30[7] = v27;
  v30[4] = BYTE1(v20);
  result = 85LL;
  v30[6] = BYTE1(v27);
  return result;
}
// 8010: using guessed type __int64 __fastcall add_range(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002E480) ----------------------------------------------------
signed __int64 __fastcall sub_2E480(char *a1, double *a2)
{
  char *v2; // r12
  char v3; // al
  __int16 *v4; // r9
  char *v5; // r8
  char *v6; // rcx
  char *v7; // rdi
  char *v8; // rdx
  char v9; // al
  double v10; // xmm0_8
  char *v11; // rdx
  signed __int64 v12; // r12
  signed __int64 result; // rax
  struct lconv *v14; // rax
  char *v15; // rdx
  char *v16; // rdx
  __int16 *v17; // rax
  char *endptr; // [rsp+8h] [rbp-80h]
  char nptr; // [rsp+10h] [rbp-78h]
  unsigned __int64 v20; // [rsp+68h] [rbp-20h]

  v2 = a1;
  v20 = __readfsqword(0x28u);
  if ( !qword_23CD60 )
  {
    v14 = localeconv();
    v15 = v14->decimal_point;
    qword_23CD60 = (__int64)v14;
    if ( v15 && *v15 )
      off_23C708 = v15;
    v16 = v14->positive_sign;
    if ( v16 && *v16 )
      off_23C700 = v14->positive_sign;
    v17 = (__int16 *)v14->negative_sign;
    if ( v17 && *(_BYTE *)v17 )
      off_23C6F8 = v17;
  }
  v3 = *a1;
  endptr = a1;
  if ( v3 )
  {
    v4 = off_23C6F8;
    v5 = (char *)off_23C708;
    v6 = a1 + 1;
    v7 = (char *)off_23C700;
    v8 = &nptr;
    while ( 1 )
    {
      if ( v3 == 46 )
      {
        v9 = *v5;
        ++v8;
        endptr = v6;
        *(v8 - 1) = v9;
        v3 = *v6;
        if ( !*v6 )
          goto LABEL_12;
      }
      else
      {
        if ( v3 == 126 )
        {
          *v8 = *(_BYTE *)v4;
        }
        else
        {
          if ( v3 == 43 )
            v3 = *v7;
          *v8 = v3;
        }
        v3 = *v6;
        ++v8;
        endptr = v6;
        if ( !v3 )
          goto LABEL_12;
      }
      ++v6;
      if ( (unsigned __int64)(v8 - &nptr) > 0x4E )
        goto LABEL_12;
    }
  }
  v8 = &nptr;
LABEL_12:
  *v8 = 0;
  v10 = strtod(&nptr, &endptr);
  v11 = endptr;
  *a2 = v10;
  v12 = (signed __int64)&v2[v11 - &nptr];
  result = 0LL;
  if ( v11 != &nptr )
    result = v12;
  return result;
}
// 23C6F8: using guessed type __int16 *off_23C6F8;
// 23C700: using guessed type void *off_23C700;
// 23C708: using guessed type void *off_23C708;
// 23CD60: using guessed type __int64 qword_23CD60;

//----- (000000000002E610) ----------------------------------------------------
char *__fastcall sub_2E610(char *a1, int *a2, int a3)
{
  double *v3; // r13
  int v4; // er12
  char *v5; // rbx
  const unsigned __int16 **v6; // r14
  __int64 v7; // rcx
  int v8; // eax
  unsigned __int8 v9; // dl
  int v10; // ecx
  __int64 v11; // xmm0_8
  char *result; // rax
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  char *v16; // rax
  char *v17; // rax
  char *v18; // rax
  char *v19; // rax
  char *v20; // rdx
  const unsigned __int16 *v21; // rcx
  char v22; // al
  char v23; // dl
  int v24; // edx

  v3 = (double *)(a2 + 2);
  v4 = a3;
  v5 = a1;
  if ( a3 != 3 )
  {
    v3 = (double *)(a2 + 10);
    if ( a3 != 12 )
      return 0LL;
  }
  v6 = __ctype_b_loc();
  while ( 1 )
  {
    v7 = *v5;
    v8 = *v5;
    if ( !((*v6)[v7] & 0x2000) )
      break;
    ++v5;
  }
  if ( (_BYTE)v7 == 91 )
  {
    v16 = (char *)sub_2E480(v5 + 1, v3);
    if ( !v16 )
      return 0LL;
    v17 = (char *)sub_2E480(v16, v3 + 1);
    if ( !v17 )
      return 0LL;
    v18 = (char *)sub_2E480(v17, v3 + 2);
    if ( !v18 )
      return 0LL;
    v19 = (char *)sub_2E480(v18, v3 + 3);
    v20 = v19;
    if ( !v19 )
      return 0LL;
    v21 = *v6;
    v22 = *v19;
    if ( (*v6)[v22] & 0x2000 )
    {
      do
        v22 = *++v20;
      while ( v21[*v20] & 0x2000 );
    }
    if ( v22 != 93 )
      return 0LL;
    result = v20 + 1;
    v23 = v20[1];
    if ( v21[v23] & 0x2000 )
    {
      do
        v23 = *++result;
      while ( v21[*result] & 0x2000 );
    }
    if ( v23 != 45 )
      return 0LL;
    v24 = *a2 | 8;
    if ( v4 != 12 )
      v24 = *a2 | 2;
    *a2 = v24;
  }
  else
  {
    if ( (_BYTE)v7 != 42 )
    {
      v9 = v7 - 48;
      v10 = 0;
      if ( v9 > 9u )
      {
        if ( (_BYTE)v8 == 45 )
        {
          *a2 &= ~v4;
          return v5;
        }
      }
      else
      {
        do
        {
          ++v5;
          v10 = v8 + 10 * v10 - 48;
          v8 = *v5;
        }
        while ( (unsigned __int8)(*v5 - 48) <= 9u );
        if ( (_BYTE)v8 == 45 )
        {
          *a2 &= ~v4;
          if ( v10 )
          {
            v3[3] = (double)v10;
            if ( v4 == 12 )
            {
              v3[3] = (double)v10 / 10.0;
              *a2 |= 4u;
            }
            else
            {
              *a2 |= 1u;
            }
            v11 = *((_QWORD *)v3 + 3);
            result = v5;
            v3[2] = 0.0;
            v3[1] = 0.0;
            *(_QWORD *)v3 = v11;
            return result;
          }
          return v5;
        }
      }
      return 0LL;
    }
    result = v5 + 1;
    if ( v5[1] != 45 )
      return 0LL;
    v13 = *a2 & ~v4;
    v14 = v13 | 0x10;
    v15 = v13 | 0x20;
    if ( v4 == 12 )
      v14 = v15;
    *a2 = v14;
  }
  return result;
}

//----- (000000000002E830) ----------------------------------------------------
__int64 xlfd_round_double()
{
  return 0LL;
}

//----- (000000000002E990) ----------------------------------------------------
__int64 __fastcall FontParseXLFDName(char *dest, double *a2, signed int a3)
{
  signed int v3; // er13
  char *v4; // rbx
  double *v5; // r12
  char v6; // al
  const char *v7; // rdi
  __int64 result; // rax
  char *v9; // rax
  char *v10; // rax
  char *v11; // r14
  char *v12; // rax
  char *v13; // rax
  char *v14; // rax
  char *v15; // rax
  char *v16; // rax
  char *v17; // rax
  char *v18; // r8
  char *v19; // rcx
  unsigned int v20; // edx
  int v21; // eax
  char *v22; // r10
  int v23; // edx
  char *v24; // rax
  int v25; // er15
  char *v26; // r11
  int v27; // edx
  char *v28; // rax
  char *v29; // rax
  char *v30; // r11
  char *v31; // r8
  void *v32; // r10
  char *v33; // ST48_8
  void *v34; // ST40_8
  char *v35; // ST38_8
  char *v36; // rax
  char *v37; // rax
  double v38; // xmm0_8
  double v39; // xmm0_8
  double v40; // xmm0_8
  int v41; // eax
  int v42; // ecx
  int v43; // eax
  int v44; // eax
  unsigned int v45; // eax
  const char *v46; // rbp
  char *v47; // rsi
  const char *v48; // rbp
  char *v49; // rsi
  char *v50; // r8
  unsigned __int64 v51; // kr20_8
  unsigned __int64 v52; // rcx
  double v53; // xmm0_8
  signed int v54; // er14
  __int64 v55; // r13
  __int64 v56; // rbp
  unsigned __int64 v57; // kr30_8
  signed __int64 v58; // rcx
  int *v59; // rdi
  int *v60; // rsi
  char v61; // r13
  char *v62; // ST40_8
  __int64 v63; // r11
  char *v64; // rax
  char *v65; // rax
  char *v66; // rax
  char *v67; // rdx
  size_t v68; // kr48_8
  char *v69; // rcx
  const char *v70; // rax
  const char *v71; // rax
  const char *v72; // rax
  const char *v73; // rsi
  const char *v74; // rax
  const char *v75; // rax
  const char *v76; // rax
  const char *v77; // rsi
  char *v78; // [rsp+18h] [rbp-540h]
  char *v79; // [rsp+18h] [rbp-540h]
  signed int v80; // [rsp+18h] [rbp-540h]
  char *v81; // [rsp+20h] [rbp-538h]
  const char *v82; // [rsp+20h] [rbp-538h]
  __int128 v83; // [rsp+28h] [rbp-530h]
  __int128 v84; // [rsp+28h] [rbp-530h]
  unsigned int v85; // [rsp+40h] [rbp-518h]
  double v86; // [rsp+48h] [rbp-510h]
  double v87; // [rsp+50h] [rbp-508h]
  double v88; // [rsp+58h] [rbp-500h]
  double v89; // [rsp+60h] [rbp-4F8h]
  double v90; // [rsp+68h] [rbp-4F0h]
  double v91; // [rsp+70h] [rbp-4E8h]
  double v92; // [rsp+78h] [rbp-4E0h]
  double v93; // [rsp+80h] [rbp-4D8h]
  int v94; // [rsp+88h] [rbp-4D0h]
  int v95; // [rsp+8Ch] [rbp-4CCh]
  unsigned int v96; // [rsp+90h] [rbp-4C8h]
  int v97; // [rsp+94h] [rbp-4C4h]
  int v98; // [rsp+98h] [rbp-4C0h]
  char v99; // [rsp+C0h] [rbp-498h]
  char src[1032]; // [rsp+110h] [rbp-448h]
  unsigned __int64 v101; // [rsp+518h] [rbp-40h]

  v3 = a3;
  v4 = dest;
  v5 = a2;
  v101 = __readfsqword(0x28u);
  memset(&v85, 0, 0x78uLL);
  if ( a3 != 3 )
    memset(a2, 0, 0x78uLL);
  v6 = *dest;
  v7 = dest + 1;
  if ( *v4 != 45 )
  {
    if ( v6 != 42 || v4[1] != 45 )
      return 0LL;
    v7 = v4 + 2;
  }
  v9 = strchr(v7, 45);
  if ( !v9 )
    return 0LL;
  v10 = strchr(v9 + 1, 45);
  if ( !v10 )
    return 0LL;
  v11 = v10 + 1;
  v12 = strchr(v10 + 1, 45);
  if ( !v12 )
    return 0LL;
  v13 = strchr(v12 + 1, 45);
  if ( !v13 )
    return 0LL;
  v14 = strchr(v13 + 1, 45);
  if ( !v14 )
    return 0LL;
  v15 = strchr(v14 + 1, 45);
  if ( !v15 )
    return 0LL;
  v16 = sub_2E610(v15 + 1, (int *)&v85, 3);
  if ( !v16 )
    return 0LL;
  v17 = sub_2E610(v16 + 1, (int *)&v85, 12);
  v18 = v17;
  if ( !v17 )
    return 0LL;
  if ( v17[1] == 42 )
  {
    v96 = -1;
    v19 = v17 + 2;
    LOBYTE(v17) = v17[2];
  }
  else
  {
    v19 = v17 + 1;
    v96 = 0;
    LODWORD(v17) = v17[1];
    if ( (unsigned __int8)((_BYTE)v17 - 48) <= 9u )
    {
      v20 = 0;
      do
      {
        ++v19;
        v20 = (_DWORD)v17 + 10 * v20 - 48;
        v96 = v20;
        LODWORD(v17) = *v19;
      }
      while ( (unsigned __int8)(*v19 - 48) <= 9u );
    }
  }
  if ( (_BYTE)v17 != 45 )
    return 0LL;
  if ( v19[1] == 42 )
  {
    v97 = -1;
    v22 = v19 + 2;
    LOBYTE(v21) = v19[2];
  }
  else
  {
    v97 = 0;
    v21 = v19[1];
    v22 = v19 + 1;
    if ( (unsigned __int8)(v19[1] - 48) <= 9u )
    {
      v23 = 0;
      do
      {
        ++v22;
        v23 = v21 + 10 * v23 - 48;
        v97 = v23;
        v21 = *v22;
      }
      while ( (unsigned __int8)(*v22 - 48) <= 9u );
    }
  }
  if ( (_BYTE)v21 != 45 )
    return 0LL;
  v81 = v18;
  v78 = v22;
  v24 = strchr(v22 + 1, 45);
  v25 = (signed int)v24;
  if ( !v24 )
    return 0LL;
  if ( v24[1] == 42 )
  {
    v98 = -1;
    v26 = v24 + 2;
    LOBYTE(v24) = v24[2];
  }
  else
  {
    v26 = v24 + 1;
    v98 = 0;
    LODWORD(v24) = v24[1];
    if ( (unsigned __int8)((_BYTE)v24 - 48) <= 9u )
    {
      v27 = 0;
      do
      {
        ++v26;
        v27 = (_DWORD)v24 + 10 * v27 - 48;
        v98 = v27;
        LODWORD(v24) = *v26;
      }
      while ( (unsigned __int8)(*v26 - 48) <= 9u );
    }
  }
  if ( (_BYTE)v24 != 45 )
    return 0LL;
  *(_QWORD *)&v83 = v78;
  v79 = v26;
  v28 = strchr(v26 + 1, 45);
  if ( !v28 )
    return 0LL;
  v29 = strchr(v28 + 1, 45);
  v30 = v79;
  v31 = v81;
  v32 = (void *)v83;
  if ( v29 )
    return 0LL;
  if ( v3 )
  {
    v33 = v79;
    v34 = v32;
    v35 = v31;
    v36 = strrchr(v4, 45);
    v37 = strchr(v36, 91);
    v31 = v35;
    v32 = v34;
    v30 = v33;
    if ( v37 )
    {
      v85 |= 0x40u;
      *v37 = 0;
    }
  }
  if ( v89 < 0.0 )
    v38 = v89 - 0.5;
  else
    v38 = v89 + 0.5;
  v94 = (signed int)v38;
  v39 = 10.0 * v93;
  if ( v93 < 0.0 )
    v40 = v39 - 0.5;
  else
    v40 = v39 + 0.5;
  v95 = (signed int)v40;
  v80 = v25 - (_DWORD)v32 + 1;
  if ( v3 == 1 )
  {
    v61 = 42;
    goto LABEL_84;
  }
  if ( v3 <= 1 )
  {
    if ( v3 )
      return 1LL;
LABEL_77:
    v58 = 30LL;
    v59 = (int *)a2;
    v60 = (int *)&v85;
    while ( v58 )
    {
      *v59 = *v60;
      ++v60;
      ++v59;
      --v58;
    }
    return 1LL;
  }
  if ( v3 == 2 )
  {
    v61 = 48;
LABEL_84:
    *((_QWORD *)&v84 + 1) = v32;
    *(_QWORD *)&v84 = v30;
    v62 = v31;
    __strcpy_chk(src, v31, 1024LL);
    v63 = v84 - (_QWORD)v62;
    *(_QWORD *)&v84 = v62;
    v82 = &src[v63];
    v64 = strchr(v11, 45);
    v65 = strchr(v64 + 1, 45);
    v66 = strchr(v65 + 1, 45);
    v67 = strchr(v66 + 1, 45);
    v68 = strlen(v82) + 1;
    if ( v68 + v67 - v4 + v80 + 1 + 9 <= 0x3FF )
    {
      v67[1] = v61;
      v67[2] = 45;
      v67[3] = v61;
      *((_DWORD *)v67 + 1) = 707602989;
      if ( v80 > 2 )
      {
        v69 = (char *)memcpy(v67 + 8, &src[*((_QWORD *)&v84 + 1) - v84], v80) + v80;
      }
      else
      {
        v69 = v67 + 11;
        *((_WORD *)v67 + 4) = 10797;
        v67[10] = 45;
      }
      *v69 = v61;
      memcpy(v69 + 1, v82, v68);
      goto LABEL_77;
    }
    return 0LL;
  }
  if ( v3 != 3 )
    return 1LL;
  v41 = *(_DWORD *)a2;
  v42 = *(_DWORD *)a2 & 3;
  if ( v42 )
  {
    v86 = a2[1];
    v87 = a2[2];
    v85 = v42 | v85 & 0xFFFFFFFC;
    v88 = a2[3];
    v40 = a2[4];
    v89 = a2[4];
  }
  v43 = v41 & 0xC;
  if ( v43 )
  {
    v90 = a2[5];
    v91 = a2[6];
    v85 = v85 & 0xFFFFFFF3 | v43;
    v92 = a2[7];
    v40 = a2[8];
    v93 = a2[8];
  }
  if ( *((_DWORD *)a2 + 20) >= 0 )
    v96 = *((_DWORD *)a2 + 20);
  if ( *((_DWORD *)a2 + 21) >= 0 )
    v97 = *((_DWORD *)a2 + 21);
  v44 = *((_DWORD *)a2 + 22);
  if ( v44 >= 0 )
    goto LABEL_55;
  if ( v44 != -1 )
  {
    v44 = -v44;
LABEL_55:
    v98 = v44;
  }
  v45 = (unsigned int)&strchr(v11, 45)[-(_DWORD)v11];
  v46 = &v11[v45 + 1];
  __sprintf_chk(src, 1LL, 1024LL, "%*.*s", v45, v40);
  v47 = (char *)(strchr(v46, 45) - v46);
  __sprintf_chk(&src[strlen(src)], 1LL, -1LL, &unk_34AF8, (unsigned int)v47, v40);
  v48 = &v46[(signed int)v47 + 1];
  v49 = (char *)(strchr(v48, 45) - v48);
  __sprintf_chk(&src[strlen(src)], 1LL, -1LL, &unk_34AF8, (unsigned int)v49, v40);
  v50 = (char *)(strchr(&v48[(signed int)v49 + 1], 45) - &v48[(signed int)v49 + 1]);
  __sprintf_chk(&src[strlen(src)], 1LL, -1LL, &unk_34AF8, v50, v40);
  v51 = strlen(src) + 1;
  *(_WORD *)&src[v51 - 1] = 45;
  if ( (v85 & 3) == 2 )
  {
    *(_WORD *)&src[v51] = 91;
    v70 = start(&v99, 0, v86);
    __strcat_chk(src, v70, 1024LL);
    v71 = start(&v99, 1, v87);
    __strcat_chk(src, v71, 1024LL);
    v72 = start(&v99, 1, v88);
    __strcat_chk(src, v72, 1024LL);
    v73 = start(&v99, 1, v89);
    *(_WORD *)__stpcpy_chk(&src[strlen(src)], v73, 1024LL) = 93;
  }
  else
  {
    __sprintf_chk(&src[v51], 1LL, -1LL, "%d", (unsigned int)(signed int)(v89 + 0.5), v89 + 0.5);
  }
  v52 = strlen(src) + 1;
  *(_WORD *)&src[v52 - 1] = 45;
  if ( (v85 & 0xC) == 8 )
  {
    *(_WORD *)&src[v52] = 91;
    v74 = start(&v99, 0, v90);
    __strcat_chk(src, v74, 1024LL);
    v75 = start(&v99, 1, v91);
    __strcat_chk(src, v75, 1024LL);
    v76 = start(&v99, 1, v92);
    __strcat_chk(src, v76, 1024LL);
    v53 = v93;
    v77 = start(&v99, 1, v93);
    *(_WORD *)__stpcpy_chk(&src[strlen(src)], v77, 1024LL) = 93;
  }
  else
  {
    v53 = 10.0 * v93;
    __sprintf_chk(&src[v52], 1LL, -1LL, "%d", (unsigned int)(signed int)(10.0 * v93 + 0.5), 10.0 * v93);
  }
  __sprintf_chk(&src[strlen(src)], 1LL, -1LL, "-%d-%d%*.*s%d%s", v96, v53);
  strcpy(v11, src);
  if ( *(_BYTE *)v5 & 0x40 )
  {
    v54 = *((_DWORD *)v5 + 26);
    if ( !v54 )
    {
      strcat(v4, "[]");
      return 1LL;
    }
    v55 = *((_QWORD *)v5 + 14);
  }
  else
  {
    v54 = *((_DWORD *)v5 + 26);
    v55 = *((_QWORD *)v5 + 14);
    result = 1LL;
    if ( !v54 )
      return result;
  }
  v56 = 0LL;
  strcat(v4, "[");
  while ( v54 > (signed int)v56 )
  {
    v57 = strlen(v4) + 1;
    if ( v57 - 1 > 0x3F1 )
      break;
    if ( (_DWORD)v56 )
      *(_WORD *)&v4[v57 - 1] = 32;
    __sprintf_chk(
      &v4[strlen(v4)],
      1LL,
      -1LL,
      "%d",
      (*(unsigned __int8 *)(v55 + 4 * v56) << 8) + (unsigned int)*(unsigned __int8 *)(v55 + 4 * v56 + 1),
      v53);
    if ( *(_BYTE *)(v55 + 4 * v56 + 1) != *(_BYTE *)(v55 + 4 * v56 + 3)
      || *(_BYTE *)(v55 + 4 * v56) != *(_BYTE *)(v55 + 4 * v56 + 2) )
    {
      __sprintf_chk(
        &v4[strlen(v4)],
        1LL,
        -1LL,
        "_%d",
        (*(unsigned __int8 *)(v55 + 4 * v56 + 2) << 8) + (unsigned int)*(unsigned __int8 *)(v55 + 4 * v56 + 3),
        v53);
    }
    ++v56;
  }
  strcat(v4, "]");
  return 1LL;
}
// 7FF0: using guessed type __int64 __fastcall __strcat_chk(_QWORD, _QWORD, _QWORD);
// 8980: using guessed type __int64 __fastcall __stpcpy_chk(_QWORD, _QWORD, _QWORD);
// 8BC0: using guessed type __int64 __fastcall __strcpy_chk(_QWORD, _QWORD, _QWORD);
// 9060: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 2E990: using guessed type char src[1032];

//----- (000000000002F530) ----------------------------------------------------
__int64 __fastcall FontParseRanges(const char *a1, _DWORD *a2)
{
  char *v2; // rax
  signed int v3; // ebx
  char *v4; // rax
  char *v5; // rbx
  char v6; // al
  char *v7; // r15
  unsigned __int64 v8; // rax
  char v9; // al
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  char v12; // al
  char v14; // [rsp+4h] [rbp-54h]
  char v15; // [rsp+5h] [rbp-53h]
  char v16; // [rsp+6h] [rbp-52h]
  char v17; // [rsp+7h] [rbp-51h]
  char *endptr; // [rsp+8h] [rbp-50h]
  __int64 v19; // [rsp+10h] [rbp-48h]
  unsigned __int64 v20; // [rsp+18h] [rbp-40h]

  v20 = __readfsqword(0x28u);
  v19 = 0LL;
  v2 = strchr(a1, 45);
  if ( v2 )
  {
    v3 = 1;
    do
    {
      ++v3;
      v2 = strchr(v2 + 1, 45);
    }
    while ( v2 && v3 <= 13 );
    *a2 = 0;
    if ( v2 )
    {
      v4 = strchr(v2, 91);
      if ( v4 )
      {
        v5 = v4 + 1;
        v6 = v4[1];
        if ( v6 != 93 )
        {
          if ( v6 )
          {
            while ( 1 )
            {
              v10 = strtol(v5, &endptr, 0);
              if ( v10 > 0xFFFF || endptr == v5 )
                return v19;
              v15 = v10;
              v17 = v10;
              v11 = v10 >> 8;
              v14 = v11;
              v16 = v11;
              v12 = *endptr;
              if ( *endptr == 93 || v12 == 32 )
                break;
              if ( v12 != 95 )
                return v19;
              v7 = endptr + 1;
              v8 = strtol(endptr + 1, &endptr, 0);
              v5 = endptr;
              if ( endptr == v7 || v8 > 0xFFFF )
                return v19;
              v16 = BYTE1(v8);
              v17 = v8;
              v9 = *endptr;
              if ( *endptr == 93 || v9 == 32 )
              {
                if ( v9 == 32 )
                {
                  do
                    ++v5;
                  while ( *v5 == 32 );
                }
                goto LABEL_23;
              }
LABEL_16:
              if ( !*v5 || *v5 == 93 )
                return v19;
            }
            v5 = endptr;
            if ( v12 == 32 )
            {
              do
                ++v5;
              while ( *v5 == 32 );
            }
LABEL_23:
            if ( (unsigned int)add_range(&v14, a2, &v19, 1LL) != 85 )
              return v19;
            goto LABEL_16;
          }
        }
      }
    }
  }
  else
  {
    *a2 = 0;
  }
  return 0LL;
}
// 8010: using guessed type __int64 __fastcall add_range(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002F710) ----------------------------------------------------
signed __int64 __fastcall CheckFSFormat(unsigned int a1, char a2, int *a3, int *a4, int *a5, int *a6, int *a7)
{
  int v7; // eax
  signed __int64 result; // rax
  int v9; // eax
  int v10; // edx

  if ( a2 & 2 )
    *a3 = (a1 >> 1) & 1;
  if ( a2 & 1 )
    *a4 = a1 & 1;
  if ( a2 & 0x10 )
  {
    v7 = a1 & 0x3000;
    if ( v7 == 4096 )
    {
      *a5 = 2;
      if ( a2 & 8 )
        goto LABEL_12;
      goto LABEL_17;
    }
    if ( v7 != 0x2000 )
    {
      if ( a1 & 0x3000 )
      {
        *a5 = v7;
        return 88LL;
      }
      *a5 = 1;
      if ( a2 & 8 )
        goto LABEL_12;
LABEL_17:
      if ( a2 & 4 )
        goto LABEL_18;
      return 85LL;
    }
    *a5 = 4;
  }
  if ( !(a2 & 8) )
    goto LABEL_17;
LABEL_12:
  v9 = a1 & 0x300;
  if ( v9 == 256 )
  {
    *a6 = 2;
    if ( a2 & 4 )
      goto LABEL_18;
    return 85LL;
  }
  if ( v9 == 512 )
  {
    *a6 = 4;
    goto LABEL_17;
  }
  if ( a1 & 0x300 )
  {
    *a6 = v9;
    return 88LL;
  }
  *a6 = 1;
  if ( !(a2 & 4) )
    return 85LL;
LABEL_18:
  v10 = a1 & 0xC;
  *a7 = v10;
  if ( !(a1 & 8) )
    return 85LL;
  result = 88LL;
  if ( v10 == 8 )
    return 85LL;
  return result;
}

//----- (000000000002F820) ----------------------------------------------------
void register_fpe_functions()
{
  BuiltinRegisterFpeFunctions();
  FontFileRegisterFpeFunctions();
  fs_register_fpe_functions();
}
// 8D20: using guessed type __int64 BuiltinRegisterFpeFunctions(void);

//----- (000000000002F840) ----------------------------------------------------
__int64 __fastcall EmptyFontPatternCache(_QWORD *a1)
{
  signed __int64 v1; // r12
  _QWORD *v2; // r13
  _QWORD *v3; // rax
  signed __int64 v4; // rbx
  signed __int64 v5; // rbp
  void *v6; // rdi
  __int64 result; // rax

  v1 = (signed __int64)(a1 + 16);
  v2 = a1;
  v3 = a1;
  do
  {
    *v3 = 0LL;
    ++v3;
  }
  while ( v3 != (_QWORD *)v1 );
  v4 = (signed __int64)(a1 + 22);
  v5 = (signed __int64)(a1 + 406);
  do
  {
    v6 = *(void **)(v4 - 24);
    *(_QWORD *)(v4 - 40) = 0LL;
    *(_QWORD *)(v4 - 8) = 0LL;
    *(_QWORD *)(v4 - 48) = v4;
    v4 += 48LL;
    free(v6);
    result = 0LL;
    *(_QWORD *)(v4 - 72) = 0LL;
    *(_WORD *)(v4 - 80) = 0;
  }
  while ( v4 != v5 );
  v2[400] = v1;
  v2[394] = 0LL;
  return result;
}

//----- (000000000002F8E0) ----------------------------------------------------
struct _FontPatternCache *MakeFontPatternCache()
{
  struct _FontPatternCache *v0; // rax
  struct _FontPatternCache *v1; // rbx
  signed __int64 v2; // rdx

  v0 = (struct _FontPatternCache *)malloc(0xC88uLL);
  v1 = v0;
  if ( v0 )
  {
    v2 = (signed __int64)v0 + 144;
    do
    {
      *(_QWORD *)(v2 + 8) = 0LL;
      *(_QWORD *)(v2 + 24) = 0LL;
      *(_WORD *)v2 = 0;
      v2 += 48LL;
    }
    while ( (struct _FontPatternCache *)v2 != (struct _FontPatternCache *)((char *)v0 + 3216) );
    EmptyFontPatternCache(v0);
  }
  return v1;
}

//----- (000000000002F940) ----------------------------------------------------
void __fastcall FreeFontPatternCache(void *ptr)
{
  void **v1; // rbp
  void **v2; // rbx
  void *v3; // r12
  void *v4; // rdi

  v1 = (void **)((char *)ptr + 3224);
  v2 = (void **)((char *)ptr + 152);
  v3 = ptr;
  do
  {
    v4 = *v2;
    v2 += 6;
    free(v4);
  }
  while ( v2 != v1 );
  free(v3);
}

//----- (000000000002F980) ----------------------------------------------------
void *__fastcall CacheFontPattern(signed __int64 a1, char *a2, int a3, void *a4)
{
  size_t v4; // r12
  char *v5; // rbp
  void *result; // rax
  signed __int64 v7; // r13
  int v8; // ebx
  void *v9; // r15
  int v10; // edx
  signed __int64 v11; // rcx
  __int64 v12; // rax
  signed __int64 v13; // rcx
  signed __int64 *v14; // rdx
  signed __int64 v15; // rax
  bool v16; // zf
  __int64 v17; // rax
  signed __int64 v18; // rcx
  __int64 v19; // rsi
  signed __int64 v20; // rax
  void *v21; // [rsp+8h] [rbp-40h]

  v4 = a3;
  v5 = a2;
  v21 = a4;
  result = malloc(a3);
  if ( result )
  {
    v7 = *(_QWORD *)(a1 + 3200);
    v8 = v4;
    v9 = result;
    if ( v7 )
    {
      *(_QWORD *)(a1 + 3200) = *(_QWORD *)v7;
    }
    else
    {
      v17 = abs((unsigned __int8)rand()) & 0x3F;
      v7 = a1 + 48 * v17 + 128;
      v18 = a1 + 48 * v17;
      v19 = *(_QWORD *)(v18 + 128);
      if ( v19 )
      {
        *(_QWORD *)(v19 + 8) = *(_QWORD *)(v18 + 136);
        v19 = *(_QWORD *)(v18 + 128);
      }
      v20 = a1 + 48 * v17;
      **(_QWORD **)(v20 + 136) = v19;
      free(*(void **)(v20 + 152));
    }
    memcpy(v9, v5, v4);
    *(_QWORD *)(v7 + 24) = v9;
    *(_WORD *)(v7 + 16) = v4;
    if ( (_DWORD)v4 )
    {
      v10 = 0;
      v11 = (signed __int64)&v5[(unsigned int)(v4 - 1) + 1];
      do
        v10 = *(++v5 - 1) ^ 2 * v10;
      while ( v5 != (char *)v11 );
      v8 = abs(v10);
      v12 = v8 & 0xF;
      v13 = a1 + 8 * v12;
    }
    else
    {
      v13 = a1;
      v12 = 0LL;
    }
    v14 = (signed __int64 *)(a1 + 8 * v12);
    *(_DWORD *)(v7 + 32) = v8;
    v15 = *v14;
    v16 = *v14 == 0;
    *(_QWORD *)v7 = *v14;
    if ( !v16 )
      *(_QWORD *)(v15 + 8) = v7;
    result = v21;
    *v14 = v7;
    *(_QWORD *)(v7 + 8) = v13;
    *(_QWORD *)(v7 + 40) = v21;
  }
  return result;
}

//----- (000000000002FAE0) ----------------------------------------------------
__int64 __fastcall FindCachedFontPattern(__int64 a1, char *a2, int a3)
{
  const void *v3; // r13
  int v4; // er12
  __int64 v5; // rax
  char *v6; // rdx
  signed __int64 v7; // rsi
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  __int64 *v11; // rbx

  v3 = a2;
  v4 = a3;
  if ( a3 )
  {
    v5 = (unsigned int)(a3 - 1);
    v6 = a2;
    v7 = (signed __int64)&a2[v5 + 1];
    v8 = 0;
    do
      v8 = *(++v6 - 1) ^ 2 * v8;
    while ( v6 != (char *)v7 );
    v9 = abs(v8);
    v10 = v9 & 0xF;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v11 = *(__int64 **)(a1 + 8LL * v10);
  if ( !v11 )
    return 0LL;
  while ( *((signed __int16 *)v11 + 8) != v4
       || *((_DWORD *)v11 + 8) != v9
       || memcmp((const void *)v11[3], v3, *((signed __int16 *)v11 + 8)) )
  {
    v11 = (__int64 *)*v11;
    if ( !v11 )
      return 0LL;
  }
  return v11[5];
}

//----- (000000000002FB90) ----------------------------------------------------
void __fastcall RemoveCachedFontPattern(__int64 a1, __int64 a2)
{
  __int64 *v2; // rbx
  signed __int64 v3; // rbp
  __int64 v4; // rax

  v2 = (__int64 *)(a1 + 128);
  v3 = a1 + 3200;
  do
  {
    while ( v2[5] != a2 )
    {
      v2 += 6;
      if ( v2 == (__int64 *)v3 )
        return;
    }
    v4 = *v2;
    v2[5] = 0LL;
    if ( v4 )
    {
      *(_QWORD *)(v4 + 8) = v2[1];
      v4 = *v2;
    }
    *(_QWORD *)v2[1] = v4;
    *v2 = *(_QWORD *)(a1 + 3200);
    *(_QWORD *)(a1 + 3200) = v2;
    v2 += 6;
    free((void *)*(v2 - 3));
    *(v2 - 3) = 0LL;
  }
  while ( v2 != (__int64 *)v3 );
}

//----- (000000000002FC20) ----------------------------------------------------
__int64 AllocateFontPrivateIndex()
{
  return (unsigned int)dword_23CD68++;
}
// 23CD68: using guessed type int dword_23CD68;

//----- (000000000002FC30) ----------------------------------------------------
_DWORD *CreateFontRec()
{
  int v0; // ebx
  _DWORD *result; // rax

  v0 = dword_23CD68;
  result = calloc(8 * dword_23CD68 + 184, 1uLL);
  if ( result )
  {
    result[42] = v0 - 1;
    if ( v0 )
      *((_QWORD *)result + 22) = result + 46;
  }
  return result;
}
// 23CD68: using guessed type int dword_23CD68;

//----- (000000000002FC70) ----------------------------------------------------
void __fastcall DestroyFontRec(void *ptr)
{
  char *v1; // rbx
  char *v2; // rdi

  v1 = (char *)ptr;
  v2 = (char *)*((_QWORD *)ptr + 22);
  if ( v2 && v2 != v1 + 184 )
    free(v2);
  free(v1);
}

//----- (000000000002FCA0) ----------------------------------------------------
void ResetFontPrivateIndex()
{
  dword_23CD68 = 0;
}
// 23CD68: using guessed type int dword_23CD68;

//----- (000000000002FCB0) ----------------------------------------------------
signed __int64 __fastcall FontSetNewPrivate(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r13
  int v4; // ebx
  _QWORD *v5; // rcx
  __int64 v6; // rbp
  size_t v7; // rdi
  int v8; // ebx
  void *v10; // rax

  v3 = a3;
  v4 = *(_DWORD *)(a1 + 168);
  v5 = *(_QWORD **)(a1 + 176);
  if ( v4 >= a2 )
  {
LABEL_8:
    v5[a2] = v3;
    return 1LL;
  }
  v6 = a1;
  v7 = 8LL * (a2 + 1);
  if ( !v5 )
  {
    v5 = malloc(v7);
    if ( !v5 )
      return 0LL;
    v8 = v4 + 1;
LABEL_6:
    *(_QWORD *)(v6 + 176) = v5;
    for ( *(_DWORD *)(v6 + 168) = v8; v8 < a2; *(_DWORD *)(v6 + 168) = v8 )
    {
      v5[v8] = 0LL;
      v5 = *(_QWORD **)(v6 + 176);
      v8 = *(_DWORD *)(v6 + 168) + 1;
    }
    goto LABEL_8;
  }
  if ( (_QWORD *)(v6 + 184) == v5 )
  {
    v10 = malloc(v7);
    if ( !v10 )
      return 0LL;
    v8 = v4 + 1;
    v5 = memcpy(v10, (const void *)(v6 + 184), 8LL * v8);
    goto LABEL_6;
  }
  v5 = realloc(v5, 8LL * (a2 + 1));
  if ( v5 )
  {
    v8 = *(_DWORD *)(v6 + 168) + 1;
    goto LABEL_6;
  }
  return 0LL;
}

//----- (000000000002FDC0) ----------------------------------------------------
__int64 __fastcall BitOrderInvert(unsigned __int8 *a1, int a2)
{
  signed __int64 v2; // rcx
  __int64 v3; // rax
  __int64 result; // rax

  if ( a2 > 0 )
  {
    v2 = (signed __int64)&a1[a2 - 1 + 1];
    do
    {
      v3 = *a1++;
      result = byte_34B20[v3];
      *(a1 - 1) = result;
    }
    while ( (unsigned __int8 *)v2 != a1 );
  }
  return result;
}

//----- (000000000002FDF0) ----------------------------------------------------
__int64 __fastcall TwoByteSwap(unsigned __int8 *a1, int a2)
{
  signed __int64 v2; // rcx
  __int64 result; // rax
  unsigned __int8 v4; // dl

  if ( a2 > 0 )
  {
    v2 = (signed __int64)&a1[2 * ((unsigned int)(a2 - 1) >> 1) + 2];
    do
    {
      result = *a1;
      v4 = a1[1];
      a1 += 2;
      *(a1 - 2) = v4;
      *(a1 - 1) = result;
    }
    while ( a1 != (unsigned __int8 *)v2 );
  }
  return result;
}

//----- (000000000002FE20) ----------------------------------------------------
__int64 __fastcall FourByteSwap(char *a1, int a2)
{
  signed __int64 v2; // rcx
  char v3; // al
  char v4; // dl
  __int64 result; // rax

  if ( a2 > 0 )
  {
    v2 = (signed __int64)&a1[4 * ((unsigned int)(a2 - 1) >> 2) + 4];
    do
    {
      v3 = *a1;
      v4 = a1[3];
      a1 += 4;
      *(a1 - 4) = v4;
      *(a1 - 1) = v3;
      result = (unsigned __int8)*(a1 - 3);
      *(a1 - 3) = *(a1 - 2);
      *(a1 - 2) = result;
    }
    while ( a1 != (char *)v2 );
  }
  return result;
}

//----- (000000000002FE60) ----------------------------------------------------
__int64 __fastcall RepadBitmap(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  _BYTE *v6; // r11
  _BYTE *v7; // r10
  int v8; // esi
  bool v9; // cc
  int v10; // eax
  int v11; // ebp
  int v12; // ecx
  signed __int64 v13; // rbx
  _BYTE *v14; // rdx
  _BYTE *v15; // rdi
  int v16; // edx
  signed __int64 v17; // rdx

  v6 = a1;
  v7 = a2;
  if ( a3 == 2 )
  {
    v8 = 2 * ((a5 + 15) >> 4);
    goto LABEL_6;
  }
  if ( a3 <= 2 )
  {
    v8 = (a5 + 7) >> 3;
    if ( a3 != 1 )
      return 0LL;
    goto LABEL_6;
  }
  if ( a3 != 4 )
  {
    if ( a3 != 8 )
      return 0LL;
    v8 = 8 * ((a5 + 63) >> 6);
LABEL_6:
    v9 = a4 <= 2;
    if ( a4 != 2 )
      goto LABEL_7;
LABEL_24:
    v10 = 2 * ((a5 + 15) >> 4);
    goto LABEL_11;
  }
  v8 = 4 * ((a5 + 31) >> 5);
  v9 = a4 <= 2;
  if ( a4 == 2 )
    goto LABEL_24;
LABEL_7:
  if ( v9 )
  {
    v10 = (a5 + 7) >> 3;
    if ( a4 == 1 )
      goto LABEL_11;
    return 0LL;
  }
  if ( a4 == 4 )
  {
    v10 = 4 * ((a5 + 31) >> 5);
    goto LABEL_11;
  }
  if ( a4 != 8 )
    return 0LL;
  v10 = 8 * ((a5 + 63) >> 6);
LABEL_11:
  v11 = v10;
  if ( v8 <= v10 )
    v11 = v8;
  if ( a6 > 0 )
  {
    v12 = 0;
    v13 = (unsigned int)(v11 - 1) + 1LL;
    do
    {
      v14 = &v6[v13];
      v15 = v7;
      if ( v11 <= 0 )
      {
        v16 = 0;
      }
      else
      {
        do
          *v15++ = *v6++;
        while ( v6 != v14 );
        v7 += v13;
        v16 = v11;
      }
      if ( v10 > v16 )
      {
        v17 = (signed __int64)&v7[v10 - 1 - v16 + 1];
        do
          *(++v7 - 1) = 0;
        while ( v7 != (_BYTE *)v17 );
      }
      ++v12;
      v6 += v8 - v11;
    }
    while ( a6 != v12 );
  }
  return (unsigned int)(a6 * v10);
}

//----- (000000000002FFD0) ----------------------------------------------------
__int64 client_auth_generation()
{
  return 0LL;
}

//----- (000000000002FFE0) ----------------------------------------------------
signed __int64 ClientSignal()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000030020) ----------------------------------------------------
__int64 find_old_font()
{
  return 0LL;
}

//----- (0000000000030030) ----------------------------------------------------
__int64 GetClientResolutions()
{
  return 0LL;
}

//----- (0000000000030040) ----------------------------------------------------
__int64 GetDefaultPointSize()
{
  return 0LL;
}

//----- (0000000000030050) ----------------------------------------------------
__int64 GetNewFontClientID()
{
  return 0LL;
}

//----- (0000000000030060) ----------------------------------------------------
__int64 GetTimeInMillis()
{
  return 0LL;
}

//----- (0000000000030070) ----------------------------------------------------
signed __int64 init_fs_handlers()
{
  return 85LL;
}

//----- (0000000000030080) ----------------------------------------------------
__int64 RegisterFPEFunctions()
{
  return 0LL;
}

//----- (00000000000300A0) ----------------------------------------------------
__int64 set_font_authorizations()
{
  return 0LL;
}

//----- (00000000000300B0) ----------------------------------------------------
__int64 StoreFontClientFont()
{
  return 0LL;
}

//----- (00000000000300B4) ----------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 365 function(s) have been successfully decompiled
